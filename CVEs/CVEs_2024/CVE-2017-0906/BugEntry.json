{"buggy_code": ["import base64\nimport re\nfrom datetime import datetime\nimport logging\nimport ssl\nfrom xml.etree import ElementTree\n\nimport iso8601\nimport six\n\nimport recurly\nimport recurly.errors\nfrom recurly.link_header import parse_link_value\nfrom six.moves import http_client\nfrom six.moves.urllib.parse import urlencode, urljoin, urlsplit\n\n\nclass Money(object):\n\n    \"\"\"An amount of money in one or more currencies.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        if args and kwargs:\n            raise ValueError(\"Money may be single currency or multi-currency but not both\")\n        elif kwargs:\n            self.currencies = dict(kwargs)\n        elif args and len(args) > 1:\n            raise ValueError(\"Multi-currency Money must be instantiated with codes\")\n        elif args:\n            self.currencies = { recurly.DEFAULT_CURRENCY: args[0] }\n        else:\n            self.currencies = dict()\n\n    @classmethod\n    def from_element(cls, elem):\n        currency = dict()\n        for child_el in elem:\n            if not child_el.tag:\n                continue\n            currency[child_el.tag] = int(child_el.text)\n        return cls(**currency)\n\n    def add_to_element(self, elem):\n        for currency, amount in self.currencies.items():\n            currency_el = ElementTree.Element(currency)\n            currency_el.attrib['type'] = 'integer'\n            currency_el.text = six.text_type(amount)\n            elem.append(currency_el)\n\n    def __getitem__(self, name):\n        return self.currencies[name]\n\n    def __setitem__(self, name, value):\n        self.currencies[name] = value\n\n    def __delitem__(self, name, value):\n        del self.currencies[name]\n\n    def __contains__(self, name):\n        return name in self.currencies\n\n\nclass PageError(ValueError):\n    \"\"\"An error raised when requesting to continue to a stream page that\n    doesn't exist.\n\n    This error can be raised when requesting the next page for the last page in\n    a series, or the first page for the first page in a series.\n\n    \"\"\"\n    pass\n\n\nclass Page(list):\n\n    \"\"\"A set of related `Resource` instances retrieved together from\n    the API.\n\n    Use `Page` instances as `list` instances to access their contents.\n\n    \"\"\"\n    def __iter__(self):\n        if not self:\n            raise StopIteration\n        page = self\n        while page:\n            for x in list.__iter__(page):\n                yield x\n            try:\n                page = page.next_page()\n            except PageError:\n                try:\n                    del self.next_url\n                except AttributeError:\n                    pass\n                raise StopIteration\n\n    def next_page(self):\n        \"\"\"Return the next `Page` after this one in the result sequence\n        it's from.\n\n        If the current page is the last page in the sequence, calling\n        this method raises a `ValueError`.\n\n        \"\"\"\n        try:\n            next_url = self.next_url\n        except AttributeError:\n            raise PageError(\"Page %r has no next page\" % self)\n        return self.page_for_url(next_url)\n\n    def first_page(self):\n        \"\"\"Return the first `Page` in the result sequence this `Page`\n        instance is from.\n\n        If the current page is already the first page in the sequence,\n        calling this method raises a `ValueError`.\n\n        \"\"\"\n        try:\n            start_url = self.start_url\n        except AttributeError:\n            raise PageError(\"Page %r is already the first page\" % self)\n        return self.page_for_url(start_url)\n\n    @classmethod\n    def page_for_url(cls, url):\n        \"\"\"Return a new `Page` containing the items at the given\n        endpoint URL.\"\"\"\n        resp, elem = Resource.element_for_url(url)\n\n        value = Resource.value_for_element(elem)\n\n        return cls.page_for_value(resp, value)\n\n    @classmethod\n    def count_for_url(cls, url):\n        \"\"\"Return the count of server side resources given a url\"\"\"\n        headers = Resource.headers_for_url(url)\n        return int(headers['X-Records'])\n\n    @classmethod\n    def page_for_value(cls, resp, value):\n        \"\"\"Return a new `Page` representing the given resource `value`\n        retrieved using the HTTP response `resp`.\n\n        This method records pagination ``Link`` headers present in `resp`, so\n        that the returned `Page` can return their resources from its\n        `next_page()` and `first_page()` methods.\n\n        \"\"\"\n        page = cls(value)\n        links = parse_link_value(resp.getheader('Link'))\n        for url, data in six.iteritems(links):\n            if data.get('rel') == 'start':\n                page.start_url = url\n            if data.get('rel') == 'next':\n                page.next_url = url\n\n        return page\n\n\nclass Resource(object):\n\n    \"\"\"A Recurly API resource.\n\n    This superclass implements the general behavior for all the\n    specific Recurly API resources.\n\n    All method parameters and return values that are XML elements are\n    `xml.etree.ElementTree.Element` instances.\n\n    \"\"\"\n\n    _classes_for_nodename = dict()\n\n    sensitive_attributes = ()\n    \"\"\"Attributes that are not logged with the rest of a `Resource`\n    of this class when submitted in a ``POST`` or ``PUT`` request.\"\"\"\n    xml_attribute_attributes = ()\n    \"\"\"Attributes of a `Resource` of this class that are not serialized\n    as subelements, but rather attributes of the top level element.\"\"\"\n    inherits_currency = False\n    \"\"\"Whether a `Resource` of this class inherits a currency from a\n    parent `Resource`, and therefore should not use `Money` instances\n    even though this `Resource` class has no ``currency`` attribute of\n    its own.\"\"\"\n\n    def serializable_attributes(self):\n        \"\"\" Attributes to be serialized in a ``POST`` or ``PUT`` request.\n        Returns all attributes unless a blacklist is specified\n        \"\"\"\n\n        if hasattr(self, 'blacklist_attributes'):\n            return [attr for attr in self.attributes if attr not in\n                    self.blacklist_attributes]\n        else:\n            return self.attributes\n\n\n    def __init__(self, **kwargs):\n        try:\n            self.attributes.index('currency') # Test for currency attribute,\n            self.currency                     # and test if it's set.\n        except ValueError:\n            pass\n        except AttributeError:\n            self.currency = recurly.DEFAULT_CURRENCY\n\n        for key, value in six.iteritems(kwargs):\n            setattr(self, key, value)\n\n    @classmethod\n    def http_request(cls, url, method='GET', body=None, headers=None):\n        \"\"\"Make an HTTP request with the given method to the given URL,\n        returning the resulting `http_client.HTTPResponse` instance.\n\n        If the `body` argument is a `Resource` instance, it is serialized\n        to XML by calling its `to_element()` method before submitting it.\n        Requests are authenticated per the Recurly API specification\n        using the ``recurly.API_KEY`` value for the API key.\n\n        Requests and responses are logged at the ``DEBUG`` level to the\n        ``recurly.http.request`` and ``recurly.http.response`` loggers\n        respectively.\n\n        \"\"\"\n\n        if recurly.API_KEY is None:\n            raise recurly.UnauthorizedError('recurly.API_KEY not set')\n\n        is_non_ascii = lambda s: any(ord(c) >= 128 for c in s)\n\n        if is_non_ascii(recurly.API_KEY) or is_non_ascii(recurly.SUBDOMAIN):\n            raise recurly.ConfigurationError(\"\"\"Setting API_KEY or SUBDOMAIN to\n                    unicode strings may cause problems. Please use strings.\n                    Issue described here:\n                    https://gist.github.com/maximehardy/d3a0a6427d2b6791b3dc\"\"\")\n\n        urlparts = urlsplit(url)\n        connection_options = {}\n        if recurly.SOCKET_TIMEOUT_SECONDS:\n            connection_options['timeout'] = recurly.SOCKET_TIMEOUT_SECONDS\n        if urlparts.scheme != 'https':\n            connection = http_client.HTTPConnection(urlparts.netloc, **connection_options)\n        elif recurly.CA_CERTS_FILE is None:\n            connection = http_client.HTTPSConnection(urlparts.netloc, **connection_options)\n        else:\n            connection_options['context'] = ssl.create_default_context(cafile=recurly.CA_CERTS_FILE)\n            connection = http_client.HTTPSConnection(urlparts.netloc, **connection_options)\n\n        headers = {} if headers is None else dict(headers)\n        headers.setdefault('Accept', 'application/xml')\n        headers.update({\n            'User-Agent': recurly.USER_AGENT\n        })\n        headers['X-Api-Version'] = recurly.api_version()\n        headers['Authorization'] = 'Basic %s' % base64.b64encode(six.b('%s:' % recurly.API_KEY)).decode()\n\n        log = logging.getLogger('recurly.http.request')\n        if log.isEnabledFor(logging.DEBUG):\n            log.debug(\"%s %s HTTP/1.1\", method, url)\n            for header, value in six.iteritems(headers):\n                if header == 'Authorization':\n                    value = '<redacted>'\n                log.debug(\"%s: %s\", header, value)\n            log.debug('')\n            if method in ('POST', 'PUT') and body is not None:\n                if isinstance(body, Resource):\n                    log.debug(body.as_log_output())\n                else:\n                    log.debug(body)\n\n        if isinstance(body, Resource):\n            body = ElementTree.tostring(body.to_element(), encoding='UTF-8')\n            headers['Content-Type'] = 'application/xml; charset=utf-8'\n        if method in ('POST', 'PUT') and body is None:\n            headers['Content-Length'] = '0'\n        connection.request(method, url, body, headers)\n        resp = connection.getresponse()\n\n        resp_headers = cls.headers_as_dict(resp)\n\n        log = logging.getLogger('recurly.http.response')\n        if log.isEnabledFor(logging.DEBUG):\n            log.debug(\"HTTP/1.1 %d %s\", resp.status, resp.reason)\n            log.debug(resp_headers)\n            log.debug('')\n\n        recurly.cache_rate_limit_headers(resp_headers)\n\n        return resp\n\n    @classmethod\n    def headers_as_dict(cls, resp):\n        \"\"\"Turns an array of response headers into a dictionary\"\"\"\n        if six.PY2:\n            pairs = [header.split(': ') for header in resp.msg.headers]\n            return dict([(k, v.strip()) for k, v in pairs])\n        else:\n            return dict([(k, v.strip()) for k, v in resp.msg._headers])\n\n    def as_log_output(self):\n        \"\"\"Returns an XML string containing a serialization of this\n        instance suitable for logging.\n\n        Attributes named in the instance's `sensitive_attributes` are\n        redacted.\n\n        \"\"\"\n        elem = self.to_element()\n        for attrname in self.sensitive_attributes:\n            for sensitive_el in elem.iter(attrname):\n                sensitive_el.text = 'XXXXXXXXXXXXXXXX'\n        return ElementTree.tostring(elem, encoding='UTF-8')\n\n    @classmethod\n    def _learn_nodenames(cls, classes):\n        for resource_class in classes:\n            try:\n                rc_is_subclass = issubclass(resource_class, cls)\n            except TypeError:\n                continue\n            if not rc_is_subclass:\n                continue\n            nodename = getattr(resource_class, 'nodename', None)\n            if nodename is None:\n                continue\n\n            cls._classes_for_nodename[nodename] = resource_class\n\n    @classmethod\n    def get(cls, uuid):\n        \"\"\"Return a `Resource` instance of this class identified by\n        the given code or UUID.\n\n        Only `Resource` classes with specified `member_path` attributes\n        can be directly requested with this method.\n\n        \"\"\"\n        url = urljoin(recurly.base_uri(), cls.member_path % (uuid,))\n        resp, elem = cls.element_for_url(url)\n        return cls.from_element(elem)\n\n    @classmethod\n    def headers_for_url(cls, url):\n        \"\"\"Return the headers only for the given URL as a dict\"\"\"\n        response = cls.http_request(url, method='HEAD')\n        if response.status != 200:\n            cls.raise_http_error(response)\n\n        return Resource.headers_as_dict(response)\n\n    @classmethod\n    def element_for_url(cls, url):\n        \"\"\"Return the resource at the given URL, as a\n        (`http_client.HTTPResponse`, `xml.etree.ElementTree.Element`) tuple\n        resulting from a ``GET`` request to that URL.\"\"\"\n        response = cls.http_request(url)\n        if response.status != 200:\n            cls.raise_http_error(response)\n\n        assert response.getheader('Content-Type').startswith('application/xml')\n\n        response_xml = response.read()\n        logging.getLogger('recurly.http.response').debug(response_xml)\n        response_doc = ElementTree.fromstring(response_xml)\n\n        return response, response_doc\n\n    @classmethod\n    def _subclass_for_nodename(cls, nodename):\n        try:\n            return cls._classes_for_nodename[nodename]\n        except KeyError:\n            raise ValueError(\"Could not determine resource class for array member with tag %r\"\n                % nodename)\n\n    @classmethod\n    def value_for_element(cls, elem):\n        \"\"\"Deserialize the given XML `Element` into its representative\n        value.\n\n        Depending on the content of the element, the returned value may be:\n        * a string, integer, or boolean value\n        * a `datetime.datetime` instance\n        * a list of `Resource` instances\n        * a single `Resource` instance\n        * a `Money` instance\n        * ``None``\n\n        \"\"\"\n        log = logging.getLogger('recurly.resource')\n        if elem is None:\n            log.debug(\"Converting %r element into None value\", elem)\n            return\n\n        if elem.attrib.get('nil') is not None:\n            log.debug(\"Converting %r element with nil attribute into None value\", elem.tag)\n            return\n\n        if elem.tag.endswith('_in_cents') and 'currency' not in cls.attributes and not cls.inherits_currency:\n            log.debug(\"Converting %r element in class with no matching 'currency' into a Money value\", elem.tag)\n            return Money.from_element(elem)\n\n        attr_type = elem.attrib.get('type')\n        log.debug(\"Converting %r element with type %r\", elem.tag, attr_type)\n\n        if attr_type == 'integer':\n            return int(elem.text.strip())\n        if attr_type == 'float':\n            return float(elem.text.strip())\n        if attr_type == 'boolean':\n            return elem.text.strip() == 'true'\n        if attr_type == 'datetime':\n            return iso8601.parse_date(elem.text.strip())\n        if attr_type == 'array':\n            return [cls._subclass_for_nodename(sub_elem.tag).from_element(sub_elem) for sub_elem in elem]\n\n        # Unknown types may be the names of resource classes.\n        if attr_type is not None:\n            try:\n                value_class = cls._subclass_for_nodename(attr_type)\n            except ValueError:\n                log.debug(\"Not converting %r element with type %r to a resource as that matches no known nodename\",\n                    elem.tag, attr_type)\n            else:\n                return value_class.from_element(elem)\n\n        # Untyped complex elements should still be resource instances. Guess from the nodename.\n        if len(elem):  # has children\n            value_class = cls._subclass_for_nodename(elem.tag)\n            log.debug(\"Converting %r tag into a %s\", elem.tag, value_class.__name__)\n            return value_class.from_element(elem)\n\n        value = elem.text or ''\n        return value.strip()\n\n    @classmethod\n    def element_for_value(cls, attrname, value):\n        \"\"\"Serialize the given value into an XML `Element` with the\n        given tag name, returning it.\n\n        The value argument may be:\n        * a `Resource` instance\n        * a `Money` instance\n        * a `datetime.datetime` instance\n        * a string, integer, or boolean value\n        * ``None``\n        * a list or tuple of these values\n\n        \"\"\"\n        if isinstance(value, Resource):\n            if attrname in cls._classes_for_nodename:\n                # override the child's node name with this attribute name\n                return value.to_element(attrname)\n\n            return value.to_element()\n\n        el = ElementTree.Element(attrname)\n\n        if value is None:\n            el.attrib['nil'] = 'nil'\n        elif isinstance(value, bool):\n            el.attrib['type'] = 'boolean'\n            el.text = 'true' if value else 'false'\n        elif isinstance(value, int):\n            el.attrib['type'] = 'integer'\n            el.text = str(value)\n        elif isinstance(value, datetime):\n            el.attrib['type'] = 'datetime'\n            el.text = value.strftime('%Y-%m-%dT%H:%M:%SZ')\n        elif isinstance(value, list) or isinstance(value, tuple):\n            for sub_resource in value:\n                if hasattr(sub_resource, 'to_element'):\n                  el.append(sub_resource.to_element())\n                else:\n                  el.append(cls.element_for_value(re.sub(r\"s$\", \"\", attrname), sub_resource))\n        elif isinstance(value, Money):\n            value.add_to_element(el)\n        else:\n            el.text = six.text_type(value)\n\n        return el\n\n    @classmethod\n    def paginated(self, url):\n        \"\"\" Exposes Page.page_for_url in Resource \"\"\"\n        return Page.page_for_url(url)\n\n    @classmethod\n    def from_element(cls, elem):\n        \"\"\"Return a new instance of this `Resource` class representing\n        the given XML element.\"\"\"\n        return cls().update_from_element(elem)\n\n    def update_from_element(self, elem):\n        \"\"\"Reset this `Resource` instance to represent the values in\n        the given XML element.\"\"\"\n        self._elem = elem\n\n        for attrname in self.attributes:\n            try:\n                delattr(self, attrname)\n            except AttributeError:\n                pass\n\n        document_url = elem.attrib.get('href')\n        if document_url is not None:\n            self._url = document_url\n\n        return self\n\n    def _make_actionator(self, url, method, extra_handler=None):\n        def actionator(*args, **kwargs):\n            if kwargs:\n                full_url = '%s?%s' % (url, urlencode(kwargs))\n            else:\n                full_url = url\n\n            body = args[0] if args else None\n            response = self.http_request(full_url, method, body)\n\n            if response.status == 200:\n                response_xml = response.read()\n                logging.getLogger('recurly.http.response').debug(response_xml)\n                return self.update_from_element(ElementTree.fromstring(response_xml))\n            elif response.status == 201:\n                response_xml = response.read()\n                logging.getLogger('recurly.http.response').debug(response_xml)\n                elem = ElementTree.fromstring(response_xml)\n                return self.value_for_element(elem)\n            elif response.status == 204:\n                pass\n            elif extra_handler is not None:\n                return extra_handler(response)\n            else:\n                self.raise_http_error(response)\n        return actionator\n\n    #usually the path is the same as the element name\n    def __getpath__(self, name):\n        return name\n\n    def __getattr__(self, name):\n        if name.startswith('_'):\n            raise AttributeError(name)\n\n        try:\n            selfnode = self._elem\n        except AttributeError:\n            raise AttributeError(name)\n\n        if name in self.xml_attribute_attributes:\n            try:\n                return selfnode.attrib[name]\n            except KeyError:\n                raise AttributeError(name)\n\n        elem = selfnode.find(self.__getpath__(name))\n\n        if elem is None:\n            # It might be an <a name> link.\n            for anchor_elem in selfnode.findall('a'):\n                if anchor_elem.attrib.get('name') == name:\n                    url = anchor_elem.attrib['href']\n                    method = anchor_elem.attrib['method'].upper()\n                    return self._make_actionator(url, method)\n\n            raise AttributeError(name)\n\n        # Follow links.\n        if 'href' in elem.attrib:\n            def make_relatitator(url):\n                def relatitator(**kwargs):\n                    if kwargs:\n                        full_url = '%s?%s' % (url, urlencode(kwargs))\n                    else:\n                        full_url = url\n\n                    resp, elem = Resource.element_for_url(full_url)\n                    value = Resource.value_for_element(elem)\n\n                    if isinstance(value, list):\n                        return Page.page_for_value(resp, value)\n                    return value\n                return relatitator\n\n            url = elem.attrib['href']\n\n            if url is '':\n                return Resource.value_for_element(elem)\n            else:\n                return make_relatitator(url)\n\n        return self.value_for_element(elem)\n\n    @classmethod\n    def all(cls, **kwargs):\n        \"\"\"Return a `Page` of instances of this `Resource` class from\n        its general collection endpoint.\n\n        Only `Resource` classes with specified `collection_path`\n        endpoints can be requested with this method. Any provided\n        keyword arguments are passed to the API endpoint as query\n        parameters.\n\n        \"\"\"\n        url = urljoin(recurly.base_uri(), cls.collection_path)\n        if kwargs:\n            url = '%s?%s' % (url, urlencode(kwargs))\n        return Page.page_for_url(url)\n\n    @classmethod\n    def count(cls, **kwargs):\n        \"\"\"Return a count of server side resources given\n        filtering arguments in kwargs.\n        \"\"\"\n        url = urljoin(recurly.base_uri(), cls.collection_path)\n        if kwargs:\n            url = '%s?%s' % (url, urlencode(kwargs))\n        return Page.count_for_url(url)\n\n    def save(self):\n        \"\"\"Save this `Resource` instance to the service.\n\n        If this is a new instance, it is created through a ``POST``\n        request to its collection endpoint. If this instance already\n        exists in the service, it is updated through a ``PUT`` request\n        to its own URL.\n\n        \"\"\"\n        if hasattr(self, '_url'):\n            return self._update()\n        return self._create()\n\n    def _update(self):\n        return self.put(self._url)\n\n    def _create(self):\n        url = urljoin(recurly.base_uri(), self.collection_path)\n        return self.post(url)\n\n    def put(self, url):\n        \"\"\"Sends this `Resource` instance to the service with a\n        ``PUT`` request to the given URL.\"\"\"\n        response = self.http_request(url, 'PUT', self, {'Content-Type': 'application/xml; charset=utf-8'})\n        if response.status != 200:\n            self.raise_http_error(response)\n\n        response_xml = response.read()\n        logging.getLogger('recurly.http.response').debug(response_xml)\n        self.update_from_element(ElementTree.fromstring(response_xml))\n\n    def post(self, url, body=None):\n        \"\"\"Sends this `Resource` instance to the service with a\n        ``POST`` request to the given URL. Takes an optional body\"\"\"\n        response = self.http_request(url, 'POST', body or self, {'Content-Type': 'application/xml; charset=utf-8'})\n        if response.status not in (200, 201, 204):\n            self.raise_http_error(response)\n\n        self._url = response.getheader('Location')\n\n        if response.status in (200, 201):\n            response_xml = response.read()\n            logging.getLogger('recurly.http.response').debug(response_xml)\n            self.update_from_element(ElementTree.fromstring(response_xml))\n\n    def delete(self):\n        \"\"\"Submits a deletion request for this `Resource` instance as\n        a ``DELETE`` request to its URL.\"\"\"\n        response = self.http_request(self._url, 'DELETE')\n        if response.status != 204:\n            self.raise_http_error(response)\n\n    @classmethod\n    def raise_http_error(cls, response):\n        \"\"\"Raise a `ResponseError` of the appropriate subclass in\n        reaction to the given `http_client.HTTPResponse`.\"\"\"\n        response_xml = response.read()\n        logging.getLogger('recurly.http.response').debug(response_xml)\n        exc_class = recurly.errors.error_class_for_http_status(response.status)\n        raise exc_class(response_xml)\n\n    def to_element(self, root_name=None):\n        \"\"\"Serialize this `Resource` instance to an XML element.\"\"\"\n        if not root_name:\n            root_name = self.nodename\n        elem = ElementTree.Element(root_name)\n        for attrname in self.serializable_attributes():\n            # Only use values that have been loaded into the internal\n            # __dict__. For retrieved objects we look into the XML response at\n            # access time, so the internal __dict__ contains only the elements\n            # that have been set on the client side.\n            try:\n                value = self.__dict__[attrname]\n            except KeyError:\n                continue\n\n            if attrname in self.xml_attribute_attributes:\n                elem.attrib[attrname] = six.text_type(value)\n            else:\n                sub_elem = self.element_for_value(attrname, value)\n                elem.append(sub_elem)\n\n        return elem\n"], "fixing_code": ["import base64\nimport re\nfrom datetime import datetime\nimport logging\nimport ssl\nfrom xml.etree import ElementTree\n\nimport iso8601\nimport six\n\nimport recurly\nimport recurly.errors\nfrom recurly.link_header import parse_link_value\nfrom six.moves import http_client\nfrom six.moves.urllib.parse import urlencode, urlsplit, quote\n\nclass Money(object):\n\n    \"\"\"An amount of money in one or more currencies.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        if args and kwargs:\n            raise ValueError(\"Money may be single currency or multi-currency but not both\")\n        elif kwargs:\n            self.currencies = dict(kwargs)\n        elif args and len(args) > 1:\n            raise ValueError(\"Multi-currency Money must be instantiated with codes\")\n        elif args:\n            self.currencies = { recurly.DEFAULT_CURRENCY: args[0] }\n        else:\n            self.currencies = dict()\n\n    @classmethod\n    def from_element(cls, elem):\n        currency = dict()\n        for child_el in elem:\n            if not child_el.tag:\n                continue\n            currency[child_el.tag] = int(child_el.text)\n        return cls(**currency)\n\n    def add_to_element(self, elem):\n        for currency, amount in self.currencies.items():\n            currency_el = ElementTree.Element(currency)\n            currency_el.attrib['type'] = 'integer'\n            currency_el.text = six.text_type(amount)\n            elem.append(currency_el)\n\n    def __getitem__(self, name):\n        return self.currencies[name]\n\n    def __setitem__(self, name, value):\n        self.currencies[name] = value\n\n    def __delitem__(self, name, value):\n        del self.currencies[name]\n\n    def __contains__(self, name):\n        return name in self.currencies\n\n\nclass PageError(ValueError):\n    \"\"\"An error raised when requesting to continue to a stream page that\n    doesn't exist.\n\n    This error can be raised when requesting the next page for the last page in\n    a series, or the first page for the first page in a series.\n\n    \"\"\"\n    pass\n\n\nclass Page(list):\n\n    \"\"\"A set of related `Resource` instances retrieved together from\n    the API.\n\n    Use `Page` instances as `list` instances to access their contents.\n\n    \"\"\"\n    def __iter__(self):\n        if not self:\n            raise StopIteration\n        page = self\n        while page:\n            for x in list.__iter__(page):\n                yield x\n            try:\n                page = page.next_page()\n            except PageError:\n                try:\n                    del self.next_url\n                except AttributeError:\n                    pass\n                raise StopIteration\n\n    def next_page(self):\n        \"\"\"Return the next `Page` after this one in the result sequence\n        it's from.\n\n        If the current page is the last page in the sequence, calling\n        this method raises a `ValueError`.\n\n        \"\"\"\n        try:\n            next_url = self.next_url\n        except AttributeError:\n            raise PageError(\"Page %r has no next page\" % self)\n        return self.page_for_url(next_url)\n\n    def first_page(self):\n        \"\"\"Return the first `Page` in the result sequence this `Page`\n        instance is from.\n\n        If the current page is already the first page in the sequence,\n        calling this method raises a `ValueError`.\n\n        \"\"\"\n        try:\n            start_url = self.start_url\n        except AttributeError:\n            raise PageError(\"Page %r is already the first page\" % self)\n        return self.page_for_url(start_url)\n\n    @classmethod\n    def page_for_url(cls, url):\n        \"\"\"Return a new `Page` containing the items at the given\n        endpoint URL.\"\"\"\n        resp, elem = Resource.element_for_url(url)\n\n        value = Resource.value_for_element(elem)\n\n        return cls.page_for_value(resp, value)\n\n    @classmethod\n    def count_for_url(cls, url):\n        \"\"\"Return the count of server side resources given a url\"\"\"\n        headers = Resource.headers_for_url(url)\n        return int(headers['X-Records'])\n\n    @classmethod\n    def page_for_value(cls, resp, value):\n        \"\"\"Return a new `Page` representing the given resource `value`\n        retrieved using the HTTP response `resp`.\n\n        This method records pagination ``Link`` headers present in `resp`, so\n        that the returned `Page` can return their resources from its\n        `next_page()` and `first_page()` methods.\n\n        \"\"\"\n        page = cls(value)\n        links = parse_link_value(resp.getheader('Link'))\n        for url, data in six.iteritems(links):\n            if data.get('rel') == 'start':\n                page.start_url = url\n            if data.get('rel') == 'next':\n                page.next_url = url\n\n        return page\n\n\nclass Resource(object):\n\n    \"\"\"A Recurly API resource.\n\n    This superclass implements the general behavior for all the\n    specific Recurly API resources.\n\n    All method parameters and return values that are XML elements are\n    `xml.etree.ElementTree.Element` instances.\n\n    \"\"\"\n\n    _classes_for_nodename = dict()\n\n    sensitive_attributes = ()\n    \"\"\"Attributes that are not logged with the rest of a `Resource`\n    of this class when submitted in a ``POST`` or ``PUT`` request.\"\"\"\n    xml_attribute_attributes = ()\n    \"\"\"Attributes of a `Resource` of this class that are not serialized\n    as subelements, but rather attributes of the top level element.\"\"\"\n    inherits_currency = False\n    \"\"\"Whether a `Resource` of this class inherits a currency from a\n    parent `Resource`, and therefore should not use `Money` instances\n    even though this `Resource` class has no ``currency`` attribute of\n    its own.\"\"\"\n\n    def serializable_attributes(self):\n        \"\"\" Attributes to be serialized in a ``POST`` or ``PUT`` request.\n        Returns all attributes unless a blacklist is specified\n        \"\"\"\n\n        if hasattr(self, 'blacklist_attributes'):\n            return [attr for attr in self.attributes if attr not in\n                    self.blacklist_attributes]\n        else:\n            return self.attributes\n\n\n    def __init__(self, **kwargs):\n        try:\n            self.attributes.index('currency') # Test for currency attribute,\n            self.currency                     # and test if it's set.\n        except ValueError:\n            pass\n        except AttributeError:\n            self.currency = recurly.DEFAULT_CURRENCY\n\n        for key, value in six.iteritems(kwargs):\n            setattr(self, key, value)\n\n    @classmethod\n    def http_request(cls, url, method='GET', body=None, headers=None):\n        \"\"\"Make an HTTP request with the given method to the given URL,\n        returning the resulting `http_client.HTTPResponse` instance.\n\n        If the `body` argument is a `Resource` instance, it is serialized\n        to XML by calling its `to_element()` method before submitting it.\n        Requests are authenticated per the Recurly API specification\n        using the ``recurly.API_KEY`` value for the API key.\n\n        Requests and responses are logged at the ``DEBUG`` level to the\n        ``recurly.http.request`` and ``recurly.http.response`` loggers\n        respectively.\n\n        \"\"\"\n\n        if recurly.API_KEY is None:\n            raise recurly.UnauthorizedError('recurly.API_KEY not set')\n\n        is_non_ascii = lambda s: any(ord(c) >= 128 for c in s)\n\n        if is_non_ascii(recurly.API_KEY) or is_non_ascii(recurly.SUBDOMAIN):\n            raise recurly.ConfigurationError(\"\"\"Setting API_KEY or SUBDOMAIN to\n                    unicode strings may cause problems. Please use strings.\n                    Issue described here:\n                    https://gist.github.com/maximehardy/d3a0a6427d2b6791b3dc\"\"\")\n\n        urlparts = urlsplit(url)\n        connection_options = {}\n        if recurly.SOCKET_TIMEOUT_SECONDS:\n            connection_options['timeout'] = recurly.SOCKET_TIMEOUT_SECONDS\n        if urlparts.scheme != 'https':\n            connection = http_client.HTTPConnection(urlparts.netloc, **connection_options)\n        elif recurly.CA_CERTS_FILE is None:\n            connection = http_client.HTTPSConnection(urlparts.netloc, **connection_options)\n        else:\n            connection_options['context'] = ssl.create_default_context(cafile=recurly.CA_CERTS_FILE)\n            connection = http_client.HTTPSConnection(urlparts.netloc, **connection_options)\n\n        headers = {} if headers is None else dict(headers)\n        headers.setdefault('Accept', 'application/xml')\n        headers.update({\n            'User-Agent': recurly.USER_AGENT\n        })\n        headers['X-Api-Version'] = recurly.api_version()\n        headers['Authorization'] = 'Basic %s' % base64.b64encode(six.b('%s:' % recurly.API_KEY)).decode()\n\n        log = logging.getLogger('recurly.http.request')\n        if log.isEnabledFor(logging.DEBUG):\n            log.debug(\"%s %s HTTP/1.1\", method, url)\n            for header, value in six.iteritems(headers):\n                if header == 'Authorization':\n                    value = '<redacted>'\n                log.debug(\"%s: %s\", header, value)\n            log.debug('')\n            if method in ('POST', 'PUT') and body is not None:\n                if isinstance(body, Resource):\n                    log.debug(body.as_log_output())\n                else:\n                    log.debug(body)\n\n        if isinstance(body, Resource):\n            body = ElementTree.tostring(body.to_element(), encoding='UTF-8')\n            headers['Content-Type'] = 'application/xml; charset=utf-8'\n        if method in ('POST', 'PUT') and body is None:\n            headers['Content-Length'] = '0'\n        connection.request(method, url, body, headers)\n        resp = connection.getresponse()\n\n        resp_headers = cls.headers_as_dict(resp)\n\n        log = logging.getLogger('recurly.http.response')\n        if log.isEnabledFor(logging.DEBUG):\n            log.debug(\"HTTP/1.1 %d %s\", resp.status, resp.reason)\n            log.debug(resp_headers)\n            log.debug('')\n\n        recurly.cache_rate_limit_headers(resp_headers)\n\n        return resp\n\n    @classmethod\n    def headers_as_dict(cls, resp):\n        \"\"\"Turns an array of response headers into a dictionary\"\"\"\n        if six.PY2:\n            pairs = [header.split(': ') for header in resp.msg.headers]\n            return dict([(k, v.strip()) for k, v in pairs])\n        else:\n            return dict([(k, v.strip()) for k, v in resp.msg._headers])\n\n    def as_log_output(self):\n        \"\"\"Returns an XML string containing a serialization of this\n        instance suitable for logging.\n\n        Attributes named in the instance's `sensitive_attributes` are\n        redacted.\n\n        \"\"\"\n        elem = self.to_element()\n        for attrname in self.sensitive_attributes:\n            for sensitive_el in elem.iter(attrname):\n                sensitive_el.text = 'XXXXXXXXXXXXXXXX'\n        return ElementTree.tostring(elem, encoding='UTF-8')\n\n    @classmethod\n    def _learn_nodenames(cls, classes):\n        for resource_class in classes:\n            try:\n                rc_is_subclass = issubclass(resource_class, cls)\n            except TypeError:\n                continue\n            if not rc_is_subclass:\n                continue\n            nodename = getattr(resource_class, 'nodename', None)\n            if nodename is None:\n                continue\n\n            cls._classes_for_nodename[nodename] = resource_class\n\n    @classmethod\n    def get(cls, uuid):\n        \"\"\"Return a `Resource` instance of this class identified by\n        the given code or UUID.\n\n        Only `Resource` classes with specified `member_path` attributes\n        can be directly requested with this method.\n\n        \"\"\"\n        uuid = quote(str(uuid))\n        url = recurly.base_uri() + (cls.member_path % (uuid,))\n        resp, elem = cls.element_for_url(url)\n        return cls.from_element(elem)\n\n    @classmethod\n    def headers_for_url(cls, url):\n        \"\"\"Return the headers only for the given URL as a dict\"\"\"\n        response = cls.http_request(url, method='HEAD')\n        if response.status != 200:\n            cls.raise_http_error(response)\n\n        return Resource.headers_as_dict(response)\n\n    @classmethod\n    def element_for_url(cls, url):\n        \"\"\"Return the resource at the given URL, as a\n        (`http_client.HTTPResponse`, `xml.etree.ElementTree.Element`) tuple\n        resulting from a ``GET`` request to that URL.\"\"\"\n        response = cls.http_request(url)\n        if response.status != 200:\n            cls.raise_http_error(response)\n\n        assert response.getheader('Content-Type').startswith('application/xml')\n\n        response_xml = response.read()\n        logging.getLogger('recurly.http.response').debug(response_xml)\n        response_doc = ElementTree.fromstring(response_xml)\n\n        return response, response_doc\n\n    @classmethod\n    def _subclass_for_nodename(cls, nodename):\n        try:\n            return cls._classes_for_nodename[nodename]\n        except KeyError:\n            raise ValueError(\"Could not determine resource class for array member with tag %r\"\n                % nodename)\n\n    @classmethod\n    def value_for_element(cls, elem):\n        \"\"\"Deserialize the given XML `Element` into its representative\n        value.\n\n        Depending on the content of the element, the returned value may be:\n        * a string, integer, or boolean value\n        * a `datetime.datetime` instance\n        * a list of `Resource` instances\n        * a single `Resource` instance\n        * a `Money` instance\n        * ``None``\n\n        \"\"\"\n        log = logging.getLogger('recurly.resource')\n        if elem is None:\n            log.debug(\"Converting %r element into None value\", elem)\n            return\n\n        if elem.attrib.get('nil') is not None:\n            log.debug(\"Converting %r element with nil attribute into None value\", elem.tag)\n            return\n\n        if elem.tag.endswith('_in_cents') and 'currency' not in cls.attributes and not cls.inherits_currency:\n            log.debug(\"Converting %r element in class with no matching 'currency' into a Money value\", elem.tag)\n            return Money.from_element(elem)\n\n        attr_type = elem.attrib.get('type')\n        log.debug(\"Converting %r element with type %r\", elem.tag, attr_type)\n\n        if attr_type == 'integer':\n            return int(elem.text.strip())\n        if attr_type == 'float':\n            return float(elem.text.strip())\n        if attr_type == 'boolean':\n            return elem.text.strip() == 'true'\n        if attr_type == 'datetime':\n            return iso8601.parse_date(elem.text.strip())\n        if attr_type == 'array':\n            return [cls._subclass_for_nodename(sub_elem.tag).from_element(sub_elem) for sub_elem in elem]\n\n        # Unknown types may be the names of resource classes.\n        if attr_type is not None:\n            try:\n                value_class = cls._subclass_for_nodename(attr_type)\n            except ValueError:\n                log.debug(\"Not converting %r element with type %r to a resource as that matches no known nodename\",\n                    elem.tag, attr_type)\n            else:\n                return value_class.from_element(elem)\n\n        # Untyped complex elements should still be resource instances. Guess from the nodename.\n        if len(elem):  # has children\n            value_class = cls._subclass_for_nodename(elem.tag)\n            log.debug(\"Converting %r tag into a %s\", elem.tag, value_class.__name__)\n            return value_class.from_element(elem)\n\n        value = elem.text or ''\n        return value.strip()\n\n    @classmethod\n    def element_for_value(cls, attrname, value):\n        \"\"\"Serialize the given value into an XML `Element` with the\n        given tag name, returning it.\n\n        The value argument may be:\n        * a `Resource` instance\n        * a `Money` instance\n        * a `datetime.datetime` instance\n        * a string, integer, or boolean value\n        * ``None``\n        * a list or tuple of these values\n\n        \"\"\"\n        if isinstance(value, Resource):\n            if attrname in cls._classes_for_nodename:\n                # override the child's node name with this attribute name\n                return value.to_element(attrname)\n\n            return value.to_element()\n\n        el = ElementTree.Element(attrname)\n\n        if value is None:\n            el.attrib['nil'] = 'nil'\n        elif isinstance(value, bool):\n            el.attrib['type'] = 'boolean'\n            el.text = 'true' if value else 'false'\n        elif isinstance(value, int):\n            el.attrib['type'] = 'integer'\n            el.text = str(value)\n        elif isinstance(value, datetime):\n            el.attrib['type'] = 'datetime'\n            el.text = value.strftime('%Y-%m-%dT%H:%M:%SZ')\n        elif isinstance(value, list) or isinstance(value, tuple):\n            for sub_resource in value:\n                if hasattr(sub_resource, 'to_element'):\n                  el.append(sub_resource.to_element())\n                else:\n                  el.append(cls.element_for_value(re.sub(r\"s$\", \"\", attrname), sub_resource))\n        elif isinstance(value, Money):\n            value.add_to_element(el)\n        else:\n            el.text = six.text_type(value)\n\n        return el\n\n    @classmethod\n    def paginated(self, url):\n        \"\"\" Exposes Page.page_for_url in Resource \"\"\"\n        return Page.page_for_url(url)\n\n    @classmethod\n    def from_element(cls, elem):\n        \"\"\"Return a new instance of this `Resource` class representing\n        the given XML element.\"\"\"\n        return cls().update_from_element(elem)\n\n    def update_from_element(self, elem):\n        \"\"\"Reset this `Resource` instance to represent the values in\n        the given XML element.\"\"\"\n        self._elem = elem\n\n        for attrname in self.attributes:\n            try:\n                delattr(self, attrname)\n            except AttributeError:\n                pass\n\n        document_url = elem.attrib.get('href')\n        if document_url is not None:\n            self._url = document_url\n\n        return self\n\n    def _make_actionator(self, url, method, extra_handler=None):\n        def actionator(*args, **kwargs):\n            if kwargs:\n                full_url = '%s?%s' % (url, urlencode(kwargs))\n            else:\n                full_url = url\n\n            body = args[0] if args else None\n            response = self.http_request(full_url, method, body)\n\n            if response.status == 200:\n                response_xml = response.read()\n                logging.getLogger('recurly.http.response').debug(response_xml)\n                return self.update_from_element(ElementTree.fromstring(response_xml))\n            elif response.status == 201:\n                response_xml = response.read()\n                logging.getLogger('recurly.http.response').debug(response_xml)\n                elem = ElementTree.fromstring(response_xml)\n                return self.value_for_element(elem)\n            elif response.status == 204:\n                pass\n            elif extra_handler is not None:\n                return extra_handler(response)\n            else:\n                self.raise_http_error(response)\n        return actionator\n\n    #usually the path is the same as the element name\n    def __getpath__(self, name):\n        return name\n\n    def __getattr__(self, name):\n        if name.startswith('_'):\n            raise AttributeError(name)\n\n        try:\n            selfnode = self._elem\n        except AttributeError:\n            raise AttributeError(name)\n\n        if name in self.xml_attribute_attributes:\n            try:\n                return selfnode.attrib[name]\n            except KeyError:\n                raise AttributeError(name)\n\n        elem = selfnode.find(self.__getpath__(name))\n\n        if elem is None:\n            # It might be an <a name> link.\n            for anchor_elem in selfnode.findall('a'):\n                if anchor_elem.attrib.get('name') == name:\n                    url = anchor_elem.attrib['href']\n                    method = anchor_elem.attrib['method'].upper()\n                    return self._make_actionator(url, method)\n\n            raise AttributeError(name)\n\n        # Follow links.\n        if 'href' in elem.attrib:\n            def make_relatitator(url):\n                def relatitator(**kwargs):\n                    if kwargs:\n                        full_url = '%s?%s' % (url, urlencode(kwargs))\n                    else:\n                        full_url = url\n\n                    resp, elem = Resource.element_for_url(full_url)\n                    value = Resource.value_for_element(elem)\n\n                    if isinstance(value, list):\n                        return Page.page_for_value(resp, value)\n                    return value\n                return relatitator\n\n            url = elem.attrib['href']\n\n            if url is '':\n                return Resource.value_for_element(elem)\n            else:\n                return make_relatitator(url)\n\n        return self.value_for_element(elem)\n\n    @classmethod\n    def all(cls, **kwargs):\n        \"\"\"Return a `Page` of instances of this `Resource` class from\n        its general collection endpoint.\n\n        Only `Resource` classes with specified `collection_path`\n        endpoints can be requested with this method. Any provided\n        keyword arguments are passed to the API endpoint as query\n        parameters.\n\n        \"\"\"\n        url = recurly.base_uri() + cls.collection_path\n        if kwargs:\n            url = '%s?%s' % (url, urlencode(kwargs))\n        return Page.page_for_url(url)\n\n    @classmethod\n    def count(cls, **kwargs):\n        \"\"\"Return a count of server side resources given\n        filtering arguments in kwargs.\n        \"\"\"\n        url = recurly.base_uri() + cls.collection_path\n        if kwargs:\n            url = '%s?%s' % (url, urlencode(kwargs))\n        return Page.count_for_url(url)\n\n    def save(self):\n        \"\"\"Save this `Resource` instance to the service.\n\n        If this is a new instance, it is created through a ``POST``\n        request to its collection endpoint. If this instance already\n        exists in the service, it is updated through a ``PUT`` request\n        to its own URL.\n\n        \"\"\"\n        if hasattr(self, '_url'):\n            return self._update()\n        return self._create()\n\n    def _update(self):\n        return self.put(self._url)\n\n    def _create(self):\n        url = recurly.base_uri() + self.collection_path\n        return self.post(url)\n\n    def put(self, url):\n        \"\"\"Sends this `Resource` instance to the service with a\n        ``PUT`` request to the given URL.\"\"\"\n        response = self.http_request(url, 'PUT', self, {'Content-Type': 'application/xml; charset=utf-8'})\n        if response.status != 200:\n            self.raise_http_error(response)\n\n        response_xml = response.read()\n        logging.getLogger('recurly.http.response').debug(response_xml)\n        self.update_from_element(ElementTree.fromstring(response_xml))\n\n    def post(self, url, body=None):\n        \"\"\"Sends this `Resource` instance to the service with a\n        ``POST`` request to the given URL. Takes an optional body\"\"\"\n        response = self.http_request(url, 'POST', body or self, {'Content-Type': 'application/xml; charset=utf-8'})\n        if response.status not in (200, 201, 204):\n            self.raise_http_error(response)\n\n        self._url = response.getheader('Location')\n\n        if response.status in (200, 201):\n            response_xml = response.read()\n            logging.getLogger('recurly.http.response').debug(response_xml)\n            self.update_from_element(ElementTree.fromstring(response_xml))\n\n    def delete(self):\n        \"\"\"Submits a deletion request for this `Resource` instance as\n        a ``DELETE`` request to its URL.\"\"\"\n        response = self.http_request(self._url, 'DELETE')\n        if response.status != 204:\n            self.raise_http_error(response)\n\n    @classmethod\n    def raise_http_error(cls, response):\n        \"\"\"Raise a `ResponseError` of the appropriate subclass in\n        reaction to the given `http_client.HTTPResponse`.\"\"\"\n        response_xml = response.read()\n        logging.getLogger('recurly.http.response').debug(response_xml)\n        exc_class = recurly.errors.error_class_for_http_status(response.status)\n        raise exc_class(response_xml)\n\n    def to_element(self, root_name=None):\n        \"\"\"Serialize this `Resource` instance to an XML element.\"\"\"\n        if not root_name:\n            root_name = self.nodename\n        elem = ElementTree.Element(root_name)\n        for attrname in self.serializable_attributes():\n            # Only use values that have been loaded into the internal\n            # __dict__. For retrieved objects we look into the XML response at\n            # access time, so the internal __dict__ contains only the elements\n            # that have been set on the client side.\n            try:\n                value = self.__dict__[attrname]\n            except KeyError:\n                continue\n\n            if attrname in self.xml_attribute_attributes:\n                elem.attrib[attrname] = six.text_type(value)\n            else:\n                sub_elem = self.element_for_value(attrname, value)\n                elem.append(sub_elem)\n\n        return elem\n"], "filenames": ["recurly/resource.py"], "buggy_code_start_loc": [15], "buggy_code_end_loc": [642], "fixing_code_start_loc": [15], "fixing_code_end_loc": [642], "type": "CWE-918", "message": "The Recurly Client Python Library before 2.0.5, 2.1.16, 2.2.22, 2.3.1, 2.4.5, 2.5.1, 2.6.2 is vulnerable to a Server-Side Request Forgery vulnerability in the \"Resource.get\" method that could result in compromise of API keys or other critical resources.", "other": {"cve": {"id": "CVE-2017-0906", "sourceIdentifier": "support@hackerone.com", "published": "2017-11-13T17:29:00.457", "lastModified": "2019-10-09T23:21:11.307", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The Recurly Client Python Library before 2.0.5, 2.1.16, 2.2.22, 2.3.1, 2.4.5, 2.5.1, 2.6.2 is vulnerable to a Server-Side Request Forgery vulnerability in the \"Resource.get\" method that could result in compromise of API keys or other critical resources."}, {"lang": "es", "value": "La biblioteca de Python Recurly Client en versiones anteriores a la 2.0.5, 2.1.16, 2.2.22, 2.3.1, 2.4.5, 2.5.1 y 2.6.2 es vulnerable a Server-Side Request Forgery en el m\u00e9todo \"Resource.get\" que podr\u00eda conllevar el compromiso de las claves API o de otros recursos cr\u00edticos."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_python:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndIncluding": "2.0.4", "matchCriteriaId": "557D1B51-6392-4527-B1E3-2090E32CA9EF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_python:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.1.0", "versionEndIncluding": "2.1.15", "matchCriteriaId": "40615C43-B326-44B4-A5AE-E2F70A44B8C7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_python:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.2.0", "versionEndIncluding": "2.2.21", "matchCriteriaId": "E6EB0197-8002-48CC-AC2F-86C81F75BB96"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_python:2.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "703E03AB-A209-427E-AF2A-733AE854C038"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_python:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndIncluding": "2.4.4", "matchCriteriaId": "29D290C7-CC59-4AA8-9CFD-936ED5E388B1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_python:2.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "12D506D9-3FE7-4775-BA47-EF65D67ACF25"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_python:2.6.0:*:*:*:*:*:*:*", "matchCriteriaId": "36D3D568-796D-4AAC-B44B-E01DBF470E24"}, {"vulnerable": true, "criteria": "cpe:2.3:a:recurly:recurly_client_python:2.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "15EA0F95-0F90-4B0A-9CDB-E2EB8E4773A9"}]}]}], "references": [{"url": "https://dev.recurly.com/page/python-updates", "source": "support@hackerone.com", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/recurly/recurly-client-python/commit/049c74699ce93cf126feff06d632ea63fba36742", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://hackerone.com/reports/288635", "source": "support@hackerone.com", "tags": ["Permissions Required"]}]}, "github_commit_url": "https://github.com/recurly/recurly-client-python/commit/049c74699ce93cf126feff06d632ea63fba36742"}}