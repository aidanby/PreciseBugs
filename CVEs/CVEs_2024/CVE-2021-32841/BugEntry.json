{"buggy_code": ["using System;\nusing System.IO;\nusing System.Numerics;\nusing System.Text;\nusing ICSharpCode.SharpZipLib.Core;\n\nnamespace ICSharpCode.SharpZipLib.Tar\n{\n\t/// <summary>\n\t/// Used to advise clients of 'events' while processing archives\n\t/// </summary>\n\tpublic delegate void ProgressMessageHandler(TarArchive archive, TarEntry entry, string message);\n\n\t/// <summary>\n\t/// The TarArchive class implements the concept of a\n\t/// 'Tape Archive'. A tar archive is a series of entries, each of\n\t/// which represents a file system object. Each entry in\n\t/// the archive consists of a header block followed by 0 or more data blocks.\n\t/// Directory entries consist only of the header block, and are followed by entries\n\t/// for the directory's contents. File entries consist of a\n\t/// header followed by the number of blocks needed to\n\t/// contain the file's contents. All entries are written on\n\t/// block boundaries. Blocks are 512 bytes long.\n\t///\n\t/// TarArchives are instantiated in either read or write mode,\n\t/// based upon whether they are instantiated with an InputStream\n\t/// or an OutputStream. Once instantiated TarArchives read/write\n\t/// mode can not be changed.\n\t///\n\t/// There is currently no support for random access to tar archives.\n\t/// However, it seems that subclassing TarArchive, and using the\n\t/// TarBuffer.CurrentRecord and TarBuffer.CurrentBlock\n\t/// properties, this would be rather trivial.\n\t/// </summary>\n\tpublic class TarArchive : IDisposable\n\t{\n\t\t/// <summary>\n\t\t/// Client hook allowing detailed information to be reported during processing\n\t\t/// </summary>\n\t\tpublic event ProgressMessageHandler ProgressMessageEvent;\n\n\t\t/// <summary>\n\t\t/// Raises the ProgressMessage event\n\t\t/// </summary>\n\t\t/// <param name=\"entry\">The <see cref=\"TarEntry\">TarEntry</see> for this event</param>\n\t\t/// <param name=\"message\">message for this event.  Null is no message</param>\n\t\tprotected virtual void OnProgressMessageEvent(TarEntry entry, string message)\n\t\t{\n\t\t\tProgressMessageHandler handler = ProgressMessageEvent;\n\t\t\tif (handler != null)\n\t\t\t{\n\t\t\t\thandler(this, entry, message);\n\t\t\t}\n\t\t}\n\n\t\t#region Constructors\n\n\t\t/// <summary>\n\t\t/// Constructor for a default <see cref=\"TarArchive\"/>.\n\t\t/// </summary>\n\t\tprotected TarArchive()\n\t\t{\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Initialise a TarArchive for input.\n\t\t/// </summary>\n\t\t/// <param name=\"stream\">The <see cref=\"TarInputStream\"/> to use for input.</param>\n\t\tprotected TarArchive(TarInputStream stream)\n\t\t{\n\t\t\tif (stream == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(stream));\n\t\t\t}\n\n\t\t\ttarIn = stream;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Initialise a TarArchive for output.\n\t\t/// </summary>\n\t\t/// <param name=\"stream\">The <see cref=\"TarOutputStream\"/> to use for output.</param>\n\t\tprotected TarArchive(TarOutputStream stream)\n\t\t{\n\t\t\tif (stream == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(stream));\n\t\t\t}\n\n\t\t\ttarOut = stream;\n\t\t}\n\n\t\t#endregion Constructors\n\n\t\t#region Static factory methods\n\n\t\t/// <summary>\n\t\t/// The InputStream based constructors create a TarArchive for the\n\t\t/// purposes of extracting or listing a tar archive. Thus, use\n\t\t/// these constructors when you wish to extract files from or list\n\t\t/// the contents of an existing tar archive.\n\t\t/// </summary>\n\t\t/// <param name=\"inputStream\">The stream to retrieve archive data from.</param>\n\t\t/// <returns>Returns a new <see cref=\"TarArchive\"/> suitable for reading from.</returns>\n\t\t[Obsolete(\"No Encoding for Name field is specified, any non-ASCII bytes will be discarded\")]\n\t\tpublic static TarArchive CreateInputTarArchive(Stream inputStream)\n\t\t{\n\t\t\treturn CreateInputTarArchive(inputStream, null);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// The InputStream based constructors create a TarArchive for the\n\t\t/// purposes of extracting or listing a tar archive. Thus, use\n\t\t/// these constructors when you wish to extract files from or list\n\t\t/// the contents of an existing tar archive.\n\t\t/// </summary>\n\t\t/// <param name=\"inputStream\">The stream to retrieve archive data from.</param>\n\t\t/// <param name=\"nameEncoding\">The <see cref=\"Encoding\"/> used for the Name fields, or null for ASCII only</param>\n\t\t/// <returns>Returns a new <see cref=\"TarArchive\"/> suitable for reading from.</returns>\n\t\tpublic static TarArchive CreateInputTarArchive(Stream inputStream, Encoding nameEncoding)\n\t\t{\n\t\t\tif (inputStream == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(inputStream));\n\t\t\t}\n\n\t\t\tvar tarStream = inputStream as TarInputStream;\n\n\t\t\tTarArchive result;\n\t\t\tif (tarStream != null)\n\t\t\t{\n\t\t\t\tresult = new TarArchive(tarStream);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = CreateInputTarArchive(inputStream, TarBuffer.DefaultBlockFactor, nameEncoding);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create TarArchive for reading setting block factor\n\t\t/// </summary>\n\t\t/// <param name=\"inputStream\">A stream containing the tar archive contents</param>\n\t\t/// <param name=\"blockFactor\">The blocking factor to apply</param>\n\t\t/// <returns>Returns a <see cref=\"TarArchive\"/> suitable for reading.</returns>\n\t\t[Obsolete(\"No Encoding for Name field is specified, any non-ASCII bytes will be discarded\")]\n\t\tpublic static TarArchive CreateInputTarArchive(Stream inputStream, int blockFactor)\n\t\t{\n\t\t\treturn CreateInputTarArchive(inputStream, blockFactor, null);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create TarArchive for reading setting block factor\n\t\t/// </summary>\n\t\t/// <param name=\"inputStream\">A stream containing the tar archive contents</param>\n\t\t/// <param name=\"blockFactor\">The blocking factor to apply</param>\n\t\t/// <param name=\"nameEncoding\">The <see cref=\"Encoding\"/> used for the Name fields, or null for ASCII only</param>\n\t\t/// <returns>Returns a <see cref=\"TarArchive\"/> suitable for reading.</returns>\n\t\tpublic static TarArchive CreateInputTarArchive(Stream inputStream, int blockFactor, Encoding nameEncoding)\n\t\t{\n\t\t\tif (inputStream == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(inputStream));\n\t\t\t}\n\n\t\t\tif (inputStream is TarInputStream)\n\t\t\t{\n\t\t\t\tthrow new ArgumentException(\"TarInputStream not valid\");\n\t\t\t}\n\n\t\t\treturn new TarArchive(new TarInputStream(inputStream, blockFactor, nameEncoding));\n\t\t}\n\t\t/// <summary>\n\t\t/// Create a TarArchive for writing to, using the default blocking factor\n\t\t/// </summary>\n\t\t/// <param name=\"outputStream\">The <see cref=\"Stream\"/> to write to</param>\n\t\t/// <param name=\"nameEncoding\">The <see cref=\"Encoding\"/> used for the Name fields, or null for ASCII only</param>\n\t\t/// <returns>Returns a <see cref=\"TarArchive\"/> suitable for writing.</returns>\n\t\tpublic static TarArchive CreateOutputTarArchive(Stream outputStream, Encoding nameEncoding)\n\t\t{\n\t\t\tif (outputStream == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(outputStream));\n\t\t\t}\n\n\t\t\tvar tarStream = outputStream as TarOutputStream;\n\n\t\t\tTarArchive result;\n\t\t\tif (tarStream != null)\n\t\t\t{\n\t\t\t\tresult = new TarArchive(tarStream);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = CreateOutputTarArchive(outputStream, TarBuffer.DefaultBlockFactor, nameEncoding);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\t/// <summary>\n\t\t/// Create a TarArchive for writing to, using the default blocking factor\n\t\t/// </summary>\n\t\t/// <param name=\"outputStream\">The <see cref=\"Stream\"/> to write to</param>\n\t\t/// <returns>Returns a <see cref=\"TarArchive\"/> suitable for writing.</returns>\n\t\tpublic static TarArchive CreateOutputTarArchive(Stream outputStream)\n\t\t{\n\t\t\treturn CreateOutputTarArchive(outputStream, null);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create a <see cref=\"TarArchive\">tar archive</see> for writing.\n\t\t/// </summary>\n\t\t/// <param name=\"outputStream\">The stream to write to</param>\n\t\t/// <param name=\"blockFactor\">The blocking factor to use for buffering.</param>\n\t\t/// <returns>Returns a <see cref=\"TarArchive\"/> suitable for writing.</returns>\n\t\tpublic static TarArchive CreateOutputTarArchive(Stream outputStream, int blockFactor)\n\t\t{\n\t\t\treturn CreateOutputTarArchive(outputStream, blockFactor, null);\n\t\t}\n\t\t/// <summary>\n\t\t/// Create a <see cref=\"TarArchive\">tar archive</see> for writing.\n\t\t/// </summary>\n\t\t/// <param name=\"outputStream\">The stream to write to</param>\n\t\t/// <param name=\"blockFactor\">The blocking factor to use for buffering.</param>\n\t\t/// <param name=\"nameEncoding\">The <see cref=\"Encoding\"/> used for the Name fields, or null for ASCII only</param>\n\t\t/// <returns>Returns a <see cref=\"TarArchive\"/> suitable for writing.</returns>\n\t\tpublic static TarArchive CreateOutputTarArchive(Stream outputStream, int blockFactor, Encoding nameEncoding)\n\t\t{\n\t\t\tif (outputStream == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(outputStream));\n\t\t\t}\n\n\t\t\tif (outputStream is TarOutputStream)\n\t\t\t{\n\t\t\t\tthrow new ArgumentException(\"TarOutputStream is not valid\");\n\t\t\t}\n\n\t\t\treturn new TarArchive(new TarOutputStream(outputStream, blockFactor, nameEncoding));\n\t\t}\n\n\t\t#endregion Static factory methods\n\n\t\t/// <summary>\n\t\t/// Set the flag that determines whether existing files are\n\t\t/// kept, or overwritten during extraction.\n\t\t/// </summary>\n\t\t/// <param name=\"keepExistingFiles\">\n\t\t/// If true, do not overwrite existing files.\n\t\t/// </param>\n\t\tpublic void SetKeepOldFiles(bool keepExistingFiles)\n\t\t{\n\t\t\tif (isDisposed)\n\t\t\t{\n\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t}\n\n\t\t\tkeepOldFiles = keepExistingFiles;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Get/set the ascii file translation flag. If ascii file translation\n\t\t/// is true, then the file is checked to see if it a binary file or not.\n\t\t/// If the flag is true and the test indicates it is ascii text\n\t\t/// file, it will be translated. The translation converts the local\n\t\t/// operating system's concept of line ends into the UNIX line end,\n\t\t/// '\\n', which is the defacto standard for a TAR archive. This makes\n\t\t/// text files compatible with UNIX.\n\t\t/// </summary>\n\t\tpublic bool AsciiTranslate\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\n\t\t\t\treturn asciiTranslate;\n\t\t\t}\n\n\t\t\tset\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\n\t\t\t\tasciiTranslate = value;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Set the ascii file translation flag.\n\t\t/// </summary>\n\t\t/// <param name= \"translateAsciiFiles\">\n\t\t/// If true, translate ascii text files.\n\t\t/// </param>\n\t\t[Obsolete(\"Use the AsciiTranslate property\")]\n\t\tpublic void SetAsciiTranslation(bool translateAsciiFiles)\n\t\t{\n\t\t\tif (isDisposed)\n\t\t\t{\n\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t}\n\n\t\t\tasciiTranslate = translateAsciiFiles;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// PathPrefix is added to entry names as they are written if the value is not null.\n\t\t/// A slash character is appended after PathPrefix\n\t\t/// </summary>\n\t\tpublic string PathPrefix\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\n\t\t\t\treturn pathPrefix;\n\t\t\t}\n\n\t\t\tset\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\n\t\t\t\tpathPrefix = value;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// RootPath is removed from entry names if it is found at the\n\t\t/// beginning of the name.\n\t\t/// </summary>\n\t\tpublic string RootPath\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\n\t\t\t\treturn rootPath;\n\t\t\t}\n\n\t\t\tset\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\t\t\t\t// Convert to forward slashes for matching. Trim trailing / for correct final path\n\t\t\t\trootPath = value.Replace('\\\\', '/').TrimEnd('/');\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Set user and group information that will be used to fill in the\n\t\t/// tar archive's entry headers. This information is based on that available\n\t\t/// for the linux operating system, which is not always available on other\n\t\t/// operating systems.  TarArchive allows the programmer to specify values\n\t\t/// to be used in their place.\n\t\t/// <see cref=\"ApplyUserInfoOverrides\"/> is set to true by this call.\n\t\t/// </summary>\n\t\t/// <param name=\"userId\">\n\t\t/// The user id to use in the headers.\n\t\t/// </param>\n\t\t/// <param name=\"userName\">\n\t\t/// The user name to use in the headers.\n\t\t/// </param>\n\t\t/// <param name=\"groupId\">\n\t\t/// The group id to use in the headers.\n\t\t/// </param>\n\t\t/// <param name=\"groupName\">\n\t\t/// The group name to use in the headers.\n\t\t/// </param>\n\t\tpublic void SetUserInfo(int userId, string userName, int groupId, string groupName)\n\t\t{\n\t\t\tif (isDisposed)\n\t\t\t{\n\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t}\n\n\t\t\tthis.userId = userId;\n\t\t\tthis.userName = userName;\n\t\t\tthis.groupId = groupId;\n\t\t\tthis.groupName = groupName;\n\t\t\tapplyUserInfoOverrides = true;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Get or set a value indicating if overrides defined by <see cref=\"SetUserInfo\">SetUserInfo</see> should be applied.\n\t\t/// </summary>\n\t\t/// <remarks>If overrides are not applied then the values as set in each header will be used.</remarks>\n\t\tpublic bool ApplyUserInfoOverrides\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\n\t\t\t\treturn applyUserInfoOverrides;\n\t\t\t}\n\n\t\t\tset\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\n\t\t\t\tapplyUserInfoOverrides = value;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Get the archive user id.\n\t\t/// See <see cref=\"ApplyUserInfoOverrides\">ApplyUserInfoOverrides</see> for detail\n\t\t/// on how to allow setting values on a per entry basis.\n\t\t/// </summary>\n\t\t/// <returns>\n\t\t/// The current user id.\n\t\t/// </returns>\n\t\tpublic int UserId\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\n\t\t\t\treturn userId;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Get the archive user name.\n\t\t/// See <see cref=\"ApplyUserInfoOverrides\">ApplyUserInfoOverrides</see> for detail\n\t\t/// on how to allow setting values on a per entry basis.\n\t\t/// </summary>\n\t\t/// <returns>\n\t\t/// The current user name.\n\t\t/// </returns>\n\t\tpublic string UserName\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\n\t\t\t\treturn userName;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Get the archive group id.\n\t\t/// See <see cref=\"ApplyUserInfoOverrides\">ApplyUserInfoOverrides</see> for detail\n\t\t/// on how to allow setting values on a per entry basis.\n\t\t/// </summary>\n\t\t/// <returns>\n\t\t/// The current group id.\n\t\t/// </returns>\n\t\tpublic int GroupId\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\n\t\t\t\treturn groupId;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Get the archive group name.\n\t\t/// See <see cref=\"ApplyUserInfoOverrides\">ApplyUserInfoOverrides</see> for detail\n\t\t/// on how to allow setting values on a per entry basis.\n\t\t/// </summary>\n\t\t/// <returns>\n\t\t/// The current group name.\n\t\t/// </returns>\n\t\tpublic string GroupName\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\n\t\t\t\treturn groupName;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Get the archive's record size. Tar archives are composed of\n\t\t/// a series of RECORDS each containing a number of BLOCKS.\n\t\t/// This allowed tar archives to match the IO characteristics of\n\t\t/// the physical device being used. Archives are expected\n\t\t/// to be properly \"blocked\".\n\t\t/// </summary>\n\t\t/// <returns>\n\t\t/// The record size this archive is using.\n\t\t/// </returns>\n\t\tpublic int RecordSize\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\n\t\t\t\tif (tarIn != null)\n\t\t\t\t{\n\t\t\t\t\treturn tarIn.RecordSize;\n\t\t\t\t}\n\t\t\t\telse if (tarOut != null)\n\t\t\t\t{\n\t\t\t\t\treturn tarOut.RecordSize;\n\t\t\t\t}\n\t\t\t\treturn TarBuffer.DefaultRecordSize;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Sets the IsStreamOwner property on the underlying stream.\n\t\t/// Set this to false to prevent the Close of the TarArchive from closing the stream.\n\t\t/// </summary>\n\t\tpublic bool IsStreamOwner\n\t\t{\n\t\t\tset\n\t\t\t{\n\t\t\t\tif (tarIn != null)\n\t\t\t\t{\n\t\t\t\t\ttarIn.IsStreamOwner = value;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttarOut.IsStreamOwner = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Close the archive.\n\t\t/// </summary>\n\t\t[Obsolete(\"Use Close instead\")]\n\t\tpublic void CloseArchive()\n\t\t{\n\t\t\tClose();\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Perform the \"list\" command for the archive contents.\n\t\t///\n\t\t/// NOTE That this method uses the <see cref=\"ProgressMessageEvent\"> progress event</see> to actually list\n\t\t/// the contents. If the progress display event is not set, nothing will be listed!\n\t\t/// </summary>\n\t\tpublic void ListContents()\n\t\t{\n\t\t\tif (isDisposed)\n\t\t\t{\n\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t}\n\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tTarEntry entry = tarIn.GetNextEntry();\n\n\t\t\t\tif (entry == null)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tOnProgressMessageEvent(entry, null);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Perform the \"extract\" command and extract the contents of the archive.\n\t\t/// </summary>\n\t\t/// <param name=\"destinationDirectory\">\n\t\t/// The destination directory into which to extract.\n\t\t/// </param>\n\t\tpublic void ExtractContents(string destinationDirectory) \n\t\t\t=> ExtractContents(destinationDirectory, false);\n\n\t\t/// <summary>\n\t\t/// Perform the \"extract\" command and extract the contents of the archive.\n\t\t/// </summary>\n\t\t/// <param name=\"destinationDirectory\">\n\t\t/// The destination directory into which to extract.\n\t\t/// </param>\n\t\t/// <param name=\"allowParentTraversal\">Allow parent directory traversal in file paths (e.g. ../file)</param>\n\t\tpublic void ExtractContents(string destinationDirectory, bool allowParentTraversal)\n\t\t{\n\t\t\tif (isDisposed)\n\t\t\t{\n\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t}\n\n\t\t\tvar fullDistDir = Path.GetFullPath(destinationDirectory);\n\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tTarEntry entry = tarIn.GetNextEntry();\n\n\t\t\t\tif (entry == null)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (entry.TarHeader.TypeFlag == TarHeader.LF_LINK || entry.TarHeader.TypeFlag == TarHeader.LF_SYMLINK)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tExtractEntry(fullDistDir, entry, allowParentTraversal);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Extract an entry from the archive. This method assumes that the\n\t\t/// tarIn stream has been properly set with a call to GetNextEntry().\n\t\t/// </summary>\n\t\t/// <param name=\"destDir\">\n\t\t/// The destination directory into which to extract.\n\t\t/// </param>\n\t\t/// <param name=\"entry\">\n\t\t/// The TarEntry returned by tarIn.GetNextEntry().\n\t\t/// </param>\n\t\t/// <param name=\"allowParentTraversal\">Allow parent directory traversal in file paths (e.g. ../file)</param>\n\t\tprivate void ExtractEntry(string destDir, TarEntry entry, bool allowParentTraversal)\n\t\t{\n\t\t\tOnProgressMessageEvent(entry, null);\n\n\t\t\tstring name = entry.Name;\n\n\t\t\tif (Path.IsPathRooted(name))\n\t\t\t{\n\t\t\t\t// NOTE:\n\t\t\t\t// for UNC names...  \\\\machine\\share\\zoom\\beet.txt gives \\zoom\\beet.txt\n\t\t\t\tname = name.Substring(Path.GetPathRoot(name).Length);\n\t\t\t}\n\n\t\t\tname = name.Replace('/', Path.DirectorySeparatorChar);\n\n\t\t\tstring destFile = Path.Combine(destDir, name);\n\n\t\t\tif (!allowParentTraversal && !Path.GetFullPath(destFile).StartsWith(destDir, StringComparison.InvariantCultureIgnoreCase))\n\t\t\t{\n\t\t\t\tthrow new InvalidNameException(\"Parent traversal in paths is not allowed\");\n\t\t\t}\n\n\t\t\tif (entry.IsDirectory)\n\t\t\t{\n\t\t\t\tEnsureDirectoryExists(destFile);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstring parentDirectory = Path.GetDirectoryName(destFile);\n\t\t\t\tEnsureDirectoryExists(parentDirectory);\n\n\t\t\t\tbool process = true;\n\t\t\t\tvar fileInfo = new FileInfo(destFile);\n\t\t\t\tif (fileInfo.Exists)\n\t\t\t\t{\n\t\t\t\t\tif (keepOldFiles)\n\t\t\t\t\t{\n\t\t\t\t\t\tOnProgressMessageEvent(entry, \"Destination file already exists\");\n\t\t\t\t\t\tprocess = false;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((fileInfo.Attributes & FileAttributes.ReadOnly) != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tOnProgressMessageEvent(entry, \"Destination file already exists, and is read-only\");\n\t\t\t\t\t\tprocess = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (process)\n\t\t\t\t{\n\t\t\t\t\tusing (var outputStream = File.Create(destFile))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (this.asciiTranslate)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// May need to translate the file.\n\t\t\t\t\t\t\tExtractAndTranslateEntry(destFile, outputStream);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// If translation is disabled, just copy the entry across directly.\n\t\t\t\t\t\t\ttarIn.CopyEntryContents(outputStream);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Extract a TAR entry, and perform an ASCII translation if required.\n\t\tprivate void ExtractAndTranslateEntry(string destFile, Stream outputStream)\n\t\t{\n\t\t\tbool asciiTrans = !IsBinary(destFile);\n\n\t\t\tif (asciiTrans)\n\t\t\t{\n\t\t\t\tusing (var outw = new StreamWriter(outputStream, new UTF8Encoding(false), 1024, true))\n\t\t\t\t{\n\t\t\t\t\tbyte[] rdbuf = new byte[32 * 1024];\n\n\t\t\t\t\twhile (true)\n\t\t\t\t\t{\n\t\t\t\t\t\tint numRead = tarIn.Read(rdbuf, 0, rdbuf.Length);\n\n\t\t\t\t\t\tif (numRead <= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (int off = 0, b = 0; b < numRead; ++b)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (rdbuf[b] == 10)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstring s = Encoding.ASCII.GetString(rdbuf, off, (b - off));\n\t\t\t\t\t\t\t\toutw.WriteLine(s);\n\t\t\t\t\t\t\t\toff = b + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// No translation required.\n\t\t\t\ttarIn.CopyEntryContents(outputStream);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Write an entry to the archive. This method will call the putNextEntry\n\t\t/// and then write the contents of the entry, and finally call closeEntry()\n\t\t/// for entries that are files. For directories, it will call putNextEntry(),\n\t\t/// and then, if the recurse flag is true, process each entry that is a\n\t\t/// child of the directory.\n\t\t/// </summary>\n\t\t/// <param name=\"sourceEntry\">\n\t\t/// The TarEntry representing the entry to write to the archive.\n\t\t/// </param>\n\t\t/// <param name=\"recurse\">\n\t\t/// If true, process the children of directory entries.\n\t\t/// </param>\n\t\tpublic void WriteEntry(TarEntry sourceEntry, bool recurse)\n\t\t{\n\t\t\tif (sourceEntry == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(sourceEntry));\n\t\t\t}\n\n\t\t\tif (isDisposed)\n\t\t\t{\n\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (recurse)\n\t\t\t\t{\n\t\t\t\t\tTarHeader.SetValueDefaults(sourceEntry.UserId, sourceEntry.UserName,\n\t\t\t\t\t\t\t\t\t\t\t   sourceEntry.GroupId, sourceEntry.GroupName);\n\t\t\t\t}\n\t\t\t\tWriteEntryCore(sourceEntry, recurse);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tif (recurse)\n\t\t\t\t{\n\t\t\t\t\tTarHeader.RestoreSetValues();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Write an entry to the archive. This method will call the putNextEntry\n\t\t/// and then write the contents of the entry, and finally call closeEntry()\n\t\t/// for entries that are files. For directories, it will call putNextEntry(),\n\t\t/// and then, if the recurse flag is true, process each entry that is a\n\t\t/// child of the directory.\n\t\t/// </summary>\n\t\t/// <param name=\"sourceEntry\">\n\t\t/// The TarEntry representing the entry to write to the archive.\n\t\t/// </param>\n\t\t/// <param name=\"recurse\">\n\t\t/// If true, process the children of directory entries.\n\t\t/// </param>\n\t\tprivate void WriteEntryCore(TarEntry sourceEntry, bool recurse)\n\t\t{\n\t\t\tstring tempFileName = null;\n\t\t\tstring entryFilename = sourceEntry.File;\n\n\t\t\tvar entry = (TarEntry)sourceEntry.Clone();\n\n\t\t\tif (applyUserInfoOverrides)\n\t\t\t{\n\t\t\t\tentry.GroupId = groupId;\n\t\t\t\tentry.GroupName = groupName;\n\t\t\t\tentry.UserId = userId;\n\t\t\t\tentry.UserName = userName;\n\t\t\t}\n\n\t\t\tOnProgressMessageEvent(entry, null);\n\n\t\t\tif (asciiTranslate && !entry.IsDirectory)\n\t\t\t{\n\t\t\t\tif (!IsBinary(entryFilename))\n\t\t\t\t{\n\t\t\t\t\ttempFileName = PathUtils.GetTempFileName();\n\n\t\t\t\t\tusing (StreamReader inStream = File.OpenText(entryFilename))\n\t\t\t\t\t{\n\t\t\t\t\t\tusing (Stream outStream = File.Create(tempFileName))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\twhile (true)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstring line = inStream.ReadLine();\n\t\t\t\t\t\t\t\tif (line == null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbyte[] data = Encoding.ASCII.GetBytes(line);\n\t\t\t\t\t\t\t\toutStream.Write(data, 0, data.Length);\n\t\t\t\t\t\t\t\toutStream.WriteByte((byte)'\\n');\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\toutStream.Flush();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tentry.Size = new FileInfo(tempFileName).Length;\n\t\t\t\t\tentryFilename = tempFileName;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstring newName = null;\n\n\t\t\tif (!String.IsNullOrEmpty(rootPath))\n\t\t\t{\n\t\t\t\tif (entry.Name.StartsWith(rootPath, StringComparison.OrdinalIgnoreCase))\n\t\t\t\t{\n\t\t\t\t\tnewName = entry.Name.Substring(rootPath.Length + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pathPrefix != null)\n\t\t\t{\n\t\t\t\tnewName = (newName == null) ? pathPrefix + \"/\" + entry.Name : pathPrefix + \"/\" + newName;\n\t\t\t}\n\n\t\t\tif (newName != null)\n\t\t\t{\n\t\t\t\tentry.Name = newName;\n\t\t\t}\n\n\t\t\ttarOut.PutNextEntry(entry);\n\n\t\t\tif (entry.IsDirectory)\n\t\t\t{\n\t\t\t\tif (recurse)\n\t\t\t\t{\n\t\t\t\t\tTarEntry[] list = entry.GetDirectoryEntries();\n\t\t\t\t\tfor (int i = 0; i < list.Length; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tWriteEntryCore(list[i], recurse);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tusing (Stream inputStream = File.OpenRead(entryFilename))\n\t\t\t\t{\n\t\t\t\t\tbyte[] localBuffer = new byte[32 * 1024];\n\t\t\t\t\twhile (true)\n\t\t\t\t\t{\n\t\t\t\t\t\tint numRead = inputStream.Read(localBuffer, 0, localBuffer.Length);\n\n\t\t\t\t\t\tif (numRead <= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttarOut.Write(localBuffer, 0, numRead);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!string.IsNullOrEmpty(tempFileName))\n\t\t\t\t{\n\t\t\t\t\tFile.Delete(tempFileName);\n\t\t\t\t}\n\n\t\t\t\ttarOut.CloseEntry();\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.\n\t\t/// </summary>\n\t\tpublic void Dispose()\n\t\t{\n\t\t\tDispose(true);\n\t\t\tGC.SuppressFinalize(this);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Releases the unmanaged resources used by the FileStream and optionally releases the managed resources.\n\t\t/// </summary>\n\t\t/// <param name=\"disposing\">true to release both managed and unmanaged resources;\n\t\t/// false to release only unmanaged resources.</param>\n\t\tprotected virtual void Dispose(bool disposing)\n\t\t{\n\t\t\tif (!isDisposed)\n\t\t\t{\n\t\t\t\tisDisposed = true;\n\t\t\t\tif (disposing)\n\t\t\t\t{\n\t\t\t\t\tif (tarOut != null)\n\t\t\t\t\t{\n\t\t\t\t\t\ttarOut.Flush();\n\t\t\t\t\t\ttarOut.Dispose();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tarIn != null)\n\t\t\t\t\t{\n\t\t\t\t\t\ttarIn.Dispose();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Closes the archive and releases any associated resources.\n\t\t/// </summary>\n\t\tpublic virtual void Close()\n\t\t{\n\t\t\tDispose(true);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Ensures that resources are freed and other cleanup operations are performed\n\t\t/// when the garbage collector reclaims the <see cref=\"TarArchive\"/>.\n\t\t/// </summary>\n\t\t~TarArchive()\n\t\t{\n\t\t\tDispose(false);\n\t\t}\n\n\t\tprivate static void EnsureDirectoryExists(string directoryName)\n\t\t{\n\t\t\tif (!Directory.Exists(directoryName))\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tDirectory.CreateDirectory(directoryName);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tthrow new TarException(\"Exception creating directory '\" + directoryName + \"', \" + e.Message, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// TODO: TarArchive - Is there a better way to test for a text file?\n\t\t// It no longer reads entire files into memory but is still a weak test!\n\t\t// This assumes that byte values 0-7, 14-31 or 255 are binary\n\t\t// and that all non text files contain one of these values\n\t\tprivate static bool IsBinary(string filename)\n\t\t{\n\t\t\tusing (FileStream fs = File.OpenRead(filename))\n\t\t\t{\n\t\t\t\tint sampleSize = Math.Min(4096, (int)fs.Length);\n\t\t\t\tbyte[] content = new byte[sampleSize];\n\n\t\t\t\tint bytesRead = fs.Read(content, 0, sampleSize);\n\n\t\t\t\tfor (int i = 0; i < bytesRead; ++i)\n\t\t\t\t{\n\t\t\t\t\tbyte b = content[i];\n\t\t\t\t\tif ((b < 8) || ((b > 13) && (b < 32)) || (b == 255))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t#region Instance Fields\n\n\t\tprivate bool keepOldFiles;\n\t\tprivate bool asciiTranslate;\n\n\t\tprivate int userId;\n\t\tprivate string userName = string.Empty;\n\t\tprivate int groupId;\n\t\tprivate string groupName = string.Empty;\n\n\t\tprivate string rootPath;\n\t\tprivate string pathPrefix;\n\n\t\tprivate bool applyUserInfoOverrides;\n\n\t\tprivate TarInputStream tarIn;\n\t\tprivate TarOutputStream tarOut;\n\t\tprivate bool isDisposed;\n\n\t\t#endregion Instance Fields\n\t}\n}\n"], "fixing_code": ["using System;\nusing System.IO;\nusing System.Numerics;\nusing System.Text;\nusing ICSharpCode.SharpZipLib.Core;\n\nnamespace ICSharpCode.SharpZipLib.Tar\n{\n\t/// <summary>\n\t/// Used to advise clients of 'events' while processing archives\n\t/// </summary>\n\tpublic delegate void ProgressMessageHandler(TarArchive archive, TarEntry entry, string message);\n\n\t/// <summary>\n\t/// The TarArchive class implements the concept of a\n\t/// 'Tape Archive'. A tar archive is a series of entries, each of\n\t/// which represents a file system object. Each entry in\n\t/// the archive consists of a header block followed by 0 or more data blocks.\n\t/// Directory entries consist only of the header block, and are followed by entries\n\t/// for the directory's contents. File entries consist of a\n\t/// header followed by the number of blocks needed to\n\t/// contain the file's contents. All entries are written on\n\t/// block boundaries. Blocks are 512 bytes long.\n\t///\n\t/// TarArchives are instantiated in either read or write mode,\n\t/// based upon whether they are instantiated with an InputStream\n\t/// or an OutputStream. Once instantiated TarArchives read/write\n\t/// mode can not be changed.\n\t///\n\t/// There is currently no support for random access to tar archives.\n\t/// However, it seems that subclassing TarArchive, and using the\n\t/// TarBuffer.CurrentRecord and TarBuffer.CurrentBlock\n\t/// properties, this would be rather trivial.\n\t/// </summary>\n\tpublic class TarArchive : IDisposable\n\t{\n\t\t/// <summary>\n\t\t/// Client hook allowing detailed information to be reported during processing\n\t\t/// </summary>\n\t\tpublic event ProgressMessageHandler ProgressMessageEvent;\n\n\t\t/// <summary>\n\t\t/// Raises the ProgressMessage event\n\t\t/// </summary>\n\t\t/// <param name=\"entry\">The <see cref=\"TarEntry\">TarEntry</see> for this event</param>\n\t\t/// <param name=\"message\">message for this event.  Null is no message</param>\n\t\tprotected virtual void OnProgressMessageEvent(TarEntry entry, string message)\n\t\t{\n\t\t\tProgressMessageHandler handler = ProgressMessageEvent;\n\t\t\tif (handler != null)\n\t\t\t{\n\t\t\t\thandler(this, entry, message);\n\t\t\t}\n\t\t}\n\n\t\t#region Constructors\n\n\t\t/// <summary>\n\t\t/// Constructor for a default <see cref=\"TarArchive\"/>.\n\t\t/// </summary>\n\t\tprotected TarArchive()\n\t\t{\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Initialise a TarArchive for input.\n\t\t/// </summary>\n\t\t/// <param name=\"stream\">The <see cref=\"TarInputStream\"/> to use for input.</param>\n\t\tprotected TarArchive(TarInputStream stream)\n\t\t{\n\t\t\tif (stream == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(stream));\n\t\t\t}\n\n\t\t\ttarIn = stream;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Initialise a TarArchive for output.\n\t\t/// </summary>\n\t\t/// <param name=\"stream\">The <see cref=\"TarOutputStream\"/> to use for output.</param>\n\t\tprotected TarArchive(TarOutputStream stream)\n\t\t{\n\t\t\tif (stream == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(stream));\n\t\t\t}\n\n\t\t\ttarOut = stream;\n\t\t}\n\n\t\t#endregion Constructors\n\n\t\t#region Static factory methods\n\n\t\t/// <summary>\n\t\t/// The InputStream based constructors create a TarArchive for the\n\t\t/// purposes of extracting or listing a tar archive. Thus, use\n\t\t/// these constructors when you wish to extract files from or list\n\t\t/// the contents of an existing tar archive.\n\t\t/// </summary>\n\t\t/// <param name=\"inputStream\">The stream to retrieve archive data from.</param>\n\t\t/// <returns>Returns a new <see cref=\"TarArchive\"/> suitable for reading from.</returns>\n\t\t[Obsolete(\"No Encoding for Name field is specified, any non-ASCII bytes will be discarded\")]\n\t\tpublic static TarArchive CreateInputTarArchive(Stream inputStream)\n\t\t{\n\t\t\treturn CreateInputTarArchive(inputStream, null);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// The InputStream based constructors create a TarArchive for the\n\t\t/// purposes of extracting or listing a tar archive. Thus, use\n\t\t/// these constructors when you wish to extract files from or list\n\t\t/// the contents of an existing tar archive.\n\t\t/// </summary>\n\t\t/// <param name=\"inputStream\">The stream to retrieve archive data from.</param>\n\t\t/// <param name=\"nameEncoding\">The <see cref=\"Encoding\"/> used for the Name fields, or null for ASCII only</param>\n\t\t/// <returns>Returns a new <see cref=\"TarArchive\"/> suitable for reading from.</returns>\n\t\tpublic static TarArchive CreateInputTarArchive(Stream inputStream, Encoding nameEncoding)\n\t\t{\n\t\t\tif (inputStream == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(inputStream));\n\t\t\t}\n\n\t\t\tvar tarStream = inputStream as TarInputStream;\n\n\t\t\tTarArchive result;\n\t\t\tif (tarStream != null)\n\t\t\t{\n\t\t\t\tresult = new TarArchive(tarStream);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = CreateInputTarArchive(inputStream, TarBuffer.DefaultBlockFactor, nameEncoding);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create TarArchive for reading setting block factor\n\t\t/// </summary>\n\t\t/// <param name=\"inputStream\">A stream containing the tar archive contents</param>\n\t\t/// <param name=\"blockFactor\">The blocking factor to apply</param>\n\t\t/// <returns>Returns a <see cref=\"TarArchive\"/> suitable for reading.</returns>\n\t\t[Obsolete(\"No Encoding for Name field is specified, any non-ASCII bytes will be discarded\")]\n\t\tpublic static TarArchive CreateInputTarArchive(Stream inputStream, int blockFactor)\n\t\t{\n\t\t\treturn CreateInputTarArchive(inputStream, blockFactor, null);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create TarArchive for reading setting block factor\n\t\t/// </summary>\n\t\t/// <param name=\"inputStream\">A stream containing the tar archive contents</param>\n\t\t/// <param name=\"blockFactor\">The blocking factor to apply</param>\n\t\t/// <param name=\"nameEncoding\">The <see cref=\"Encoding\"/> used for the Name fields, or null for ASCII only</param>\n\t\t/// <returns>Returns a <see cref=\"TarArchive\"/> suitable for reading.</returns>\n\t\tpublic static TarArchive CreateInputTarArchive(Stream inputStream, int blockFactor, Encoding nameEncoding)\n\t\t{\n\t\t\tif (inputStream == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(inputStream));\n\t\t\t}\n\n\t\t\tif (inputStream is TarInputStream)\n\t\t\t{\n\t\t\t\tthrow new ArgumentException(\"TarInputStream not valid\");\n\t\t\t}\n\n\t\t\treturn new TarArchive(new TarInputStream(inputStream, blockFactor, nameEncoding));\n\t\t}\n\t\t/// <summary>\n\t\t/// Create a TarArchive for writing to, using the default blocking factor\n\t\t/// </summary>\n\t\t/// <param name=\"outputStream\">The <see cref=\"Stream\"/> to write to</param>\n\t\t/// <param name=\"nameEncoding\">The <see cref=\"Encoding\"/> used for the Name fields, or null for ASCII only</param>\n\t\t/// <returns>Returns a <see cref=\"TarArchive\"/> suitable for writing.</returns>\n\t\tpublic static TarArchive CreateOutputTarArchive(Stream outputStream, Encoding nameEncoding)\n\t\t{\n\t\t\tif (outputStream == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(outputStream));\n\t\t\t}\n\n\t\t\tvar tarStream = outputStream as TarOutputStream;\n\n\t\t\tTarArchive result;\n\t\t\tif (tarStream != null)\n\t\t\t{\n\t\t\t\tresult = new TarArchive(tarStream);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = CreateOutputTarArchive(outputStream, TarBuffer.DefaultBlockFactor, nameEncoding);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\t/// <summary>\n\t\t/// Create a TarArchive for writing to, using the default blocking factor\n\t\t/// </summary>\n\t\t/// <param name=\"outputStream\">The <see cref=\"Stream\"/> to write to</param>\n\t\t/// <returns>Returns a <see cref=\"TarArchive\"/> suitable for writing.</returns>\n\t\tpublic static TarArchive CreateOutputTarArchive(Stream outputStream)\n\t\t{\n\t\t\treturn CreateOutputTarArchive(outputStream, null);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create a <see cref=\"TarArchive\">tar archive</see> for writing.\n\t\t/// </summary>\n\t\t/// <param name=\"outputStream\">The stream to write to</param>\n\t\t/// <param name=\"blockFactor\">The blocking factor to use for buffering.</param>\n\t\t/// <returns>Returns a <see cref=\"TarArchive\"/> suitable for writing.</returns>\n\t\tpublic static TarArchive CreateOutputTarArchive(Stream outputStream, int blockFactor)\n\t\t{\n\t\t\treturn CreateOutputTarArchive(outputStream, blockFactor, null);\n\t\t}\n\t\t/// <summary>\n\t\t/// Create a <see cref=\"TarArchive\">tar archive</see> for writing.\n\t\t/// </summary>\n\t\t/// <param name=\"outputStream\">The stream to write to</param>\n\t\t/// <param name=\"blockFactor\">The blocking factor to use for buffering.</param>\n\t\t/// <param name=\"nameEncoding\">The <see cref=\"Encoding\"/> used for the Name fields, or null for ASCII only</param>\n\t\t/// <returns>Returns a <see cref=\"TarArchive\"/> suitable for writing.</returns>\n\t\tpublic static TarArchive CreateOutputTarArchive(Stream outputStream, int blockFactor, Encoding nameEncoding)\n\t\t{\n\t\t\tif (outputStream == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(outputStream));\n\t\t\t}\n\n\t\t\tif (outputStream is TarOutputStream)\n\t\t\t{\n\t\t\t\tthrow new ArgumentException(\"TarOutputStream is not valid\");\n\t\t\t}\n\n\t\t\treturn new TarArchive(new TarOutputStream(outputStream, blockFactor, nameEncoding));\n\t\t}\n\n\t\t#endregion Static factory methods\n\n\t\t/// <summary>\n\t\t/// Set the flag that determines whether existing files are\n\t\t/// kept, or overwritten during extraction.\n\t\t/// </summary>\n\t\t/// <param name=\"keepExistingFiles\">\n\t\t/// If true, do not overwrite existing files.\n\t\t/// </param>\n\t\tpublic void SetKeepOldFiles(bool keepExistingFiles)\n\t\t{\n\t\t\tif (isDisposed)\n\t\t\t{\n\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t}\n\n\t\t\tkeepOldFiles = keepExistingFiles;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Get/set the ascii file translation flag. If ascii file translation\n\t\t/// is true, then the file is checked to see if it a binary file or not.\n\t\t/// If the flag is true and the test indicates it is ascii text\n\t\t/// file, it will be translated. The translation converts the local\n\t\t/// operating system's concept of line ends into the UNIX line end,\n\t\t/// '\\n', which is the defacto standard for a TAR archive. This makes\n\t\t/// text files compatible with UNIX.\n\t\t/// </summary>\n\t\tpublic bool AsciiTranslate\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\n\t\t\t\treturn asciiTranslate;\n\t\t\t}\n\n\t\t\tset\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\n\t\t\t\tasciiTranslate = value;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Set the ascii file translation flag.\n\t\t/// </summary>\n\t\t/// <param name= \"translateAsciiFiles\">\n\t\t/// If true, translate ascii text files.\n\t\t/// </param>\n\t\t[Obsolete(\"Use the AsciiTranslate property\")]\n\t\tpublic void SetAsciiTranslation(bool translateAsciiFiles)\n\t\t{\n\t\t\tif (isDisposed)\n\t\t\t{\n\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t}\n\n\t\t\tasciiTranslate = translateAsciiFiles;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// PathPrefix is added to entry names as they are written if the value is not null.\n\t\t/// A slash character is appended after PathPrefix\n\t\t/// </summary>\n\t\tpublic string PathPrefix\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\n\t\t\t\treturn pathPrefix;\n\t\t\t}\n\n\t\t\tset\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\n\t\t\t\tpathPrefix = value;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// RootPath is removed from entry names if it is found at the\n\t\t/// beginning of the name.\n\t\t/// </summary>\n\t\tpublic string RootPath\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\n\t\t\t\treturn rootPath;\n\t\t\t}\n\n\t\t\tset\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\t\t\t\t// Convert to forward slashes for matching. Trim trailing / for correct final path\n\t\t\t\trootPath = value.Replace('\\\\', '/').TrimEnd('/');\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Set user and group information that will be used to fill in the\n\t\t/// tar archive's entry headers. This information is based on that available\n\t\t/// for the linux operating system, which is not always available on other\n\t\t/// operating systems.  TarArchive allows the programmer to specify values\n\t\t/// to be used in their place.\n\t\t/// <see cref=\"ApplyUserInfoOverrides\"/> is set to true by this call.\n\t\t/// </summary>\n\t\t/// <param name=\"userId\">\n\t\t/// The user id to use in the headers.\n\t\t/// </param>\n\t\t/// <param name=\"userName\">\n\t\t/// The user name to use in the headers.\n\t\t/// </param>\n\t\t/// <param name=\"groupId\">\n\t\t/// The group id to use in the headers.\n\t\t/// </param>\n\t\t/// <param name=\"groupName\">\n\t\t/// The group name to use in the headers.\n\t\t/// </param>\n\t\tpublic void SetUserInfo(int userId, string userName, int groupId, string groupName)\n\t\t{\n\t\t\tif (isDisposed)\n\t\t\t{\n\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t}\n\n\t\t\tthis.userId = userId;\n\t\t\tthis.userName = userName;\n\t\t\tthis.groupId = groupId;\n\t\t\tthis.groupName = groupName;\n\t\t\tapplyUserInfoOverrides = true;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Get or set a value indicating if overrides defined by <see cref=\"SetUserInfo\">SetUserInfo</see> should be applied.\n\t\t/// </summary>\n\t\t/// <remarks>If overrides are not applied then the values as set in each header will be used.</remarks>\n\t\tpublic bool ApplyUserInfoOverrides\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\n\t\t\t\treturn applyUserInfoOverrides;\n\t\t\t}\n\n\t\t\tset\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\n\t\t\t\tapplyUserInfoOverrides = value;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Get the archive user id.\n\t\t/// See <see cref=\"ApplyUserInfoOverrides\">ApplyUserInfoOverrides</see> for detail\n\t\t/// on how to allow setting values on a per entry basis.\n\t\t/// </summary>\n\t\t/// <returns>\n\t\t/// The current user id.\n\t\t/// </returns>\n\t\tpublic int UserId\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\n\t\t\t\treturn userId;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Get the archive user name.\n\t\t/// See <see cref=\"ApplyUserInfoOverrides\">ApplyUserInfoOverrides</see> for detail\n\t\t/// on how to allow setting values on a per entry basis.\n\t\t/// </summary>\n\t\t/// <returns>\n\t\t/// The current user name.\n\t\t/// </returns>\n\t\tpublic string UserName\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\n\t\t\t\treturn userName;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Get the archive group id.\n\t\t/// See <see cref=\"ApplyUserInfoOverrides\">ApplyUserInfoOverrides</see> for detail\n\t\t/// on how to allow setting values on a per entry basis.\n\t\t/// </summary>\n\t\t/// <returns>\n\t\t/// The current group id.\n\t\t/// </returns>\n\t\tpublic int GroupId\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\n\t\t\t\treturn groupId;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Get the archive group name.\n\t\t/// See <see cref=\"ApplyUserInfoOverrides\">ApplyUserInfoOverrides</see> for detail\n\t\t/// on how to allow setting values on a per entry basis.\n\t\t/// </summary>\n\t\t/// <returns>\n\t\t/// The current group name.\n\t\t/// </returns>\n\t\tpublic string GroupName\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\n\t\t\t\treturn groupName;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Get the archive's record size. Tar archives are composed of\n\t\t/// a series of RECORDS each containing a number of BLOCKS.\n\t\t/// This allowed tar archives to match the IO characteristics of\n\t\t/// the physical device being used. Archives are expected\n\t\t/// to be properly \"blocked\".\n\t\t/// </summary>\n\t\t/// <returns>\n\t\t/// The record size this archive is using.\n\t\t/// </returns>\n\t\tpublic int RecordSize\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (isDisposed)\n\t\t\t\t{\n\t\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t\t}\n\n\t\t\t\tif (tarIn != null)\n\t\t\t\t{\n\t\t\t\t\treturn tarIn.RecordSize;\n\t\t\t\t}\n\t\t\t\telse if (tarOut != null)\n\t\t\t\t{\n\t\t\t\t\treturn tarOut.RecordSize;\n\t\t\t\t}\n\t\t\t\treturn TarBuffer.DefaultRecordSize;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Sets the IsStreamOwner property on the underlying stream.\n\t\t/// Set this to false to prevent the Close of the TarArchive from closing the stream.\n\t\t/// </summary>\n\t\tpublic bool IsStreamOwner\n\t\t{\n\t\t\tset\n\t\t\t{\n\t\t\t\tif (tarIn != null)\n\t\t\t\t{\n\t\t\t\t\ttarIn.IsStreamOwner = value;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttarOut.IsStreamOwner = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Close the archive.\n\t\t/// </summary>\n\t\t[Obsolete(\"Use Close instead\")]\n\t\tpublic void CloseArchive()\n\t\t{\n\t\t\tClose();\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Perform the \"list\" command for the archive contents.\n\t\t///\n\t\t/// NOTE That this method uses the <see cref=\"ProgressMessageEvent\"> progress event</see> to actually list\n\t\t/// the contents. If the progress display event is not set, nothing will be listed!\n\t\t/// </summary>\n\t\tpublic void ListContents()\n\t\t{\n\t\t\tif (isDisposed)\n\t\t\t{\n\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t}\n\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tTarEntry entry = tarIn.GetNextEntry();\n\n\t\t\t\tif (entry == null)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tOnProgressMessageEvent(entry, null);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Perform the \"extract\" command and extract the contents of the archive.\n\t\t/// </summary>\n\t\t/// <param name=\"destinationDirectory\">\n\t\t/// The destination directory into which to extract.\n\t\t/// </param>\n\t\tpublic void ExtractContents(string destinationDirectory) \n\t\t\t=> ExtractContents(destinationDirectory, false);\n\n\t\t/// <summary>\n\t\t/// Perform the \"extract\" command and extract the contents of the archive.\n\t\t/// </summary>\n\t\t/// <param name=\"destinationDirectory\">\n\t\t/// The destination directory into which to extract.\n\t\t/// </param>\n\t\t/// <param name=\"allowParentTraversal\">Allow parent directory traversal in file paths (e.g. ../file)</param>\n\t\tpublic void ExtractContents(string destinationDirectory, bool allowParentTraversal)\n\t\t{\n\t\t\tif (isDisposed)\n\t\t\t{\n\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t}\n\n\t\t\tvar fullDistDir = Path.GetFullPath(destinationDirectory);\n\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tTarEntry entry = tarIn.GetNextEntry();\n\n\t\t\t\tif (entry == null)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (entry.TarHeader.TypeFlag == TarHeader.LF_LINK || entry.TarHeader.TypeFlag == TarHeader.LF_SYMLINK)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tExtractEntry(fullDistDir, entry, allowParentTraversal);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Extract an entry from the archive. This method assumes that the\n\t\t/// tarIn stream has been properly set with a call to GetNextEntry().\n\t\t/// </summary>\n\t\t/// <param name=\"destDir\">\n\t\t/// The destination directory into which to extract.\n\t\t/// </param>\n\t\t/// <param name=\"entry\">\n\t\t/// The TarEntry returned by tarIn.GetNextEntry().\n\t\t/// </param>\n\t\t/// <param name=\"allowParentTraversal\">Allow parent directory traversal in file paths (e.g. ../file)</param>\n\t\tprivate void ExtractEntry(string destDir, TarEntry entry, bool allowParentTraversal)\n\t\t{\n\t\t\tOnProgressMessageEvent(entry, null);\n\n\t\t\tstring name = entry.Name;\n\n\t\t\tif (Path.IsPathRooted(name))\n\t\t\t{\n\t\t\t\t// NOTE:\n\t\t\t\t// for UNC names...  \\\\machine\\share\\zoom\\beet.txt gives \\zoom\\beet.txt\n\t\t\t\tname = name.Substring(Path.GetPathRoot(name).Length);\n\t\t\t}\n\n\t\t\tname = name.Replace('/', Path.DirectorySeparatorChar);\n\n\t\t\tstring destFile = Path.Combine(destDir, name);\n\t\t\tvar destFileDir = Path.GetDirectoryName(Path.GetFullPath(destFile)) ?? \"\";\n\n\t\t\tif (!allowParentTraversal && !destFileDir.StartsWith(destDir, StringComparison.InvariantCultureIgnoreCase))\n\t\t\t{\n\t\t\t\tthrow new InvalidNameException(\"Parent traversal in paths is not allowed\");\n\t\t\t}\n\n\t\t\tif (entry.IsDirectory)\n\t\t\t{\n\t\t\t\tEnsureDirectoryExists(destFile);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstring parentDirectory = Path.GetDirectoryName(destFile);\n\t\t\t\tEnsureDirectoryExists(parentDirectory);\n\n\t\t\t\tbool process = true;\n\t\t\t\tvar fileInfo = new FileInfo(destFile);\n\t\t\t\tif (fileInfo.Exists)\n\t\t\t\t{\n\t\t\t\t\tif (keepOldFiles)\n\t\t\t\t\t{\n\t\t\t\t\t\tOnProgressMessageEvent(entry, \"Destination file already exists\");\n\t\t\t\t\t\tprocess = false;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((fileInfo.Attributes & FileAttributes.ReadOnly) != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tOnProgressMessageEvent(entry, \"Destination file already exists, and is read-only\");\n\t\t\t\t\t\tprocess = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (process)\n\t\t\t\t{\n\t\t\t\t\tusing (var outputStream = File.Create(destFile))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (this.asciiTranslate)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// May need to translate the file.\n\t\t\t\t\t\t\tExtractAndTranslateEntry(destFile, outputStream);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// If translation is disabled, just copy the entry across directly.\n\t\t\t\t\t\t\ttarIn.CopyEntryContents(outputStream);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Extract a TAR entry, and perform an ASCII translation if required.\n\t\tprivate void ExtractAndTranslateEntry(string destFile, Stream outputStream)\n\t\t{\n\t\t\tbool asciiTrans = !IsBinary(destFile);\n\n\t\t\tif (asciiTrans)\n\t\t\t{\n\t\t\t\tusing (var outw = new StreamWriter(outputStream, new UTF8Encoding(false), 1024, true))\n\t\t\t\t{\n\t\t\t\t\tbyte[] rdbuf = new byte[32 * 1024];\n\n\t\t\t\t\twhile (true)\n\t\t\t\t\t{\n\t\t\t\t\t\tint numRead = tarIn.Read(rdbuf, 0, rdbuf.Length);\n\n\t\t\t\t\t\tif (numRead <= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (int off = 0, b = 0; b < numRead; ++b)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (rdbuf[b] == 10)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstring s = Encoding.ASCII.GetString(rdbuf, off, (b - off));\n\t\t\t\t\t\t\t\toutw.WriteLine(s);\n\t\t\t\t\t\t\t\toff = b + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// No translation required.\n\t\t\t\ttarIn.CopyEntryContents(outputStream);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Write an entry to the archive. This method will call the putNextEntry\n\t\t/// and then write the contents of the entry, and finally call closeEntry()\n\t\t/// for entries that are files. For directories, it will call putNextEntry(),\n\t\t/// and then, if the recurse flag is true, process each entry that is a\n\t\t/// child of the directory.\n\t\t/// </summary>\n\t\t/// <param name=\"sourceEntry\">\n\t\t/// The TarEntry representing the entry to write to the archive.\n\t\t/// </param>\n\t\t/// <param name=\"recurse\">\n\t\t/// If true, process the children of directory entries.\n\t\t/// </param>\n\t\tpublic void WriteEntry(TarEntry sourceEntry, bool recurse)\n\t\t{\n\t\t\tif (sourceEntry == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(sourceEntry));\n\t\t\t}\n\n\t\t\tif (isDisposed)\n\t\t\t{\n\t\t\t\tthrow new ObjectDisposedException(\"TarArchive\");\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (recurse)\n\t\t\t\t{\n\t\t\t\t\tTarHeader.SetValueDefaults(sourceEntry.UserId, sourceEntry.UserName,\n\t\t\t\t\t\t\t\t\t\t\t   sourceEntry.GroupId, sourceEntry.GroupName);\n\t\t\t\t}\n\t\t\t\tWriteEntryCore(sourceEntry, recurse);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tif (recurse)\n\t\t\t\t{\n\t\t\t\t\tTarHeader.RestoreSetValues();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Write an entry to the archive. This method will call the putNextEntry\n\t\t/// and then write the contents of the entry, and finally call closeEntry()\n\t\t/// for entries that are files. For directories, it will call putNextEntry(),\n\t\t/// and then, if the recurse flag is true, process each entry that is a\n\t\t/// child of the directory.\n\t\t/// </summary>\n\t\t/// <param name=\"sourceEntry\">\n\t\t/// The TarEntry representing the entry to write to the archive.\n\t\t/// </param>\n\t\t/// <param name=\"recurse\">\n\t\t/// If true, process the children of directory entries.\n\t\t/// </param>\n\t\tprivate void WriteEntryCore(TarEntry sourceEntry, bool recurse)\n\t\t{\n\t\t\tstring tempFileName = null;\n\t\t\tstring entryFilename = sourceEntry.File;\n\n\t\t\tvar entry = (TarEntry)sourceEntry.Clone();\n\n\t\t\tif (applyUserInfoOverrides)\n\t\t\t{\n\t\t\t\tentry.GroupId = groupId;\n\t\t\t\tentry.GroupName = groupName;\n\t\t\t\tentry.UserId = userId;\n\t\t\t\tentry.UserName = userName;\n\t\t\t}\n\n\t\t\tOnProgressMessageEvent(entry, null);\n\n\t\t\tif (asciiTranslate && !entry.IsDirectory)\n\t\t\t{\n\t\t\t\tif (!IsBinary(entryFilename))\n\t\t\t\t{\n\t\t\t\t\ttempFileName = PathUtils.GetTempFileName();\n\n\t\t\t\t\tusing (StreamReader inStream = File.OpenText(entryFilename))\n\t\t\t\t\t{\n\t\t\t\t\t\tusing (Stream outStream = File.Create(tempFileName))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\twhile (true)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstring line = inStream.ReadLine();\n\t\t\t\t\t\t\t\tif (line == null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbyte[] data = Encoding.ASCII.GetBytes(line);\n\t\t\t\t\t\t\t\toutStream.Write(data, 0, data.Length);\n\t\t\t\t\t\t\t\toutStream.WriteByte((byte)'\\n');\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\toutStream.Flush();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tentry.Size = new FileInfo(tempFileName).Length;\n\t\t\t\t\tentryFilename = tempFileName;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstring newName = null;\n\n\t\t\tif (!String.IsNullOrEmpty(rootPath))\n\t\t\t{\n\t\t\t\tif (entry.Name.StartsWith(rootPath, StringComparison.OrdinalIgnoreCase))\n\t\t\t\t{\n\t\t\t\t\tnewName = entry.Name.Substring(rootPath.Length + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pathPrefix != null)\n\t\t\t{\n\t\t\t\tnewName = (newName == null) ? pathPrefix + \"/\" + entry.Name : pathPrefix + \"/\" + newName;\n\t\t\t}\n\n\t\t\tif (newName != null)\n\t\t\t{\n\t\t\t\tentry.Name = newName;\n\t\t\t}\n\n\t\t\ttarOut.PutNextEntry(entry);\n\n\t\t\tif (entry.IsDirectory)\n\t\t\t{\n\t\t\t\tif (recurse)\n\t\t\t\t{\n\t\t\t\t\tTarEntry[] list = entry.GetDirectoryEntries();\n\t\t\t\t\tfor (int i = 0; i < list.Length; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tWriteEntryCore(list[i], recurse);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tusing (Stream inputStream = File.OpenRead(entryFilename))\n\t\t\t\t{\n\t\t\t\t\tbyte[] localBuffer = new byte[32 * 1024];\n\t\t\t\t\twhile (true)\n\t\t\t\t\t{\n\t\t\t\t\t\tint numRead = inputStream.Read(localBuffer, 0, localBuffer.Length);\n\n\t\t\t\t\t\tif (numRead <= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttarOut.Write(localBuffer, 0, numRead);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!string.IsNullOrEmpty(tempFileName))\n\t\t\t\t{\n\t\t\t\t\tFile.Delete(tempFileName);\n\t\t\t\t}\n\n\t\t\t\ttarOut.CloseEntry();\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.\n\t\t/// </summary>\n\t\tpublic void Dispose()\n\t\t{\n\t\t\tDispose(true);\n\t\t\tGC.SuppressFinalize(this);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Releases the unmanaged resources used by the FileStream and optionally releases the managed resources.\n\t\t/// </summary>\n\t\t/// <param name=\"disposing\">true to release both managed and unmanaged resources;\n\t\t/// false to release only unmanaged resources.</param>\n\t\tprotected virtual void Dispose(bool disposing)\n\t\t{\n\t\t\tif (!isDisposed)\n\t\t\t{\n\t\t\t\tisDisposed = true;\n\t\t\t\tif (disposing)\n\t\t\t\t{\n\t\t\t\t\tif (tarOut != null)\n\t\t\t\t\t{\n\t\t\t\t\t\ttarOut.Flush();\n\t\t\t\t\t\ttarOut.Dispose();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tarIn != null)\n\t\t\t\t\t{\n\t\t\t\t\t\ttarIn.Dispose();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Closes the archive and releases any associated resources.\n\t\t/// </summary>\n\t\tpublic virtual void Close()\n\t\t{\n\t\t\tDispose(true);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Ensures that resources are freed and other cleanup operations are performed\n\t\t/// when the garbage collector reclaims the <see cref=\"TarArchive\"/>.\n\t\t/// </summary>\n\t\t~TarArchive()\n\t\t{\n\t\t\tDispose(false);\n\t\t}\n\n\t\tprivate static void EnsureDirectoryExists(string directoryName)\n\t\t{\n\t\t\tif (!Directory.Exists(directoryName))\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tDirectory.CreateDirectory(directoryName);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tthrow new TarException(\"Exception creating directory '\" + directoryName + \"', \" + e.Message, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// TODO: TarArchive - Is there a better way to test for a text file?\n\t\t// It no longer reads entire files into memory but is still a weak test!\n\t\t// This assumes that byte values 0-7, 14-31 or 255 are binary\n\t\t// and that all non text files contain one of these values\n\t\tprivate static bool IsBinary(string filename)\n\t\t{\n\t\t\tusing (FileStream fs = File.OpenRead(filename))\n\t\t\t{\n\t\t\t\tint sampleSize = Math.Min(4096, (int)fs.Length);\n\t\t\t\tbyte[] content = new byte[sampleSize];\n\n\t\t\t\tint bytesRead = fs.Read(content, 0, sampleSize);\n\n\t\t\t\tfor (int i = 0; i < bytesRead; ++i)\n\t\t\t\t{\n\t\t\t\t\tbyte b = content[i];\n\t\t\t\t\tif ((b < 8) || ((b > 13) && (b < 32)) || (b == 255))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t#region Instance Fields\n\n\t\tprivate bool keepOldFiles;\n\t\tprivate bool asciiTranslate;\n\n\t\tprivate int userId;\n\t\tprivate string userName = string.Empty;\n\t\tprivate int groupId;\n\t\tprivate string groupName = string.Empty;\n\n\t\tprivate string rootPath;\n\t\tprivate string pathPrefix;\n\n\t\tprivate bool applyUserInfoOverrides;\n\n\t\tprivate TarInputStream tarIn;\n\t\tprivate TarOutputStream tarOut;\n\t\tprivate bool isDisposed;\n\n\t\t#endregion Instance Fields\n\t}\n}\n"], "filenames": ["src/ICSharpCode.SharpZipLib/Tar/TarArchive.cs"], "buggy_code_start_loc": [661], "buggy_code_end_loc": [663], "fixing_code_start_loc": [661], "fixing_code_end_loc": [664], "type": "CWE-22", "message": "SharpZipLib (or #ziplib) is a Zip, GZip, Tar and BZip2 library. Starting version 1.3.0 and prior to version 1.3.3, a check was added if the destination file is under destination directory. However, it is not enforced that `destDir` ends with slash. If the `destDir` is not slash terminated like `/home/user/dir` it is possible to create a file with a name thats begins with the destination directory, i.e. `/home/user/dir.sh`. Because of the file name and destination directory constraints, the arbitrary file creation impact is limited and depends on the use case. Version 1.3.3 contains a patch for this vulnerability.", "other": {"cve": {"id": "CVE-2021-32841", "sourceIdentifier": "security-advisories@github.com", "published": "2022-01-26T22:15:07.837", "lastModified": "2022-02-07T19:09:29.293", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "SharpZipLib (or #ziplib) is a Zip, GZip, Tar and BZip2 library. Starting version 1.3.0 and prior to version 1.3.3, a check was added if the destination file is under destination directory. However, it is not enforced that `destDir` ends with slash. If the `destDir` is not slash terminated like `/home/user/dir` it is possible to create a file with a name thats begins with the destination directory, i.e. `/home/user/dir.sh`. Because of the file name and destination directory constraints, the arbitrary file creation impact is limited and depends on the use case. Version 1.3.3 contains a patch for this vulnerability."}, {"lang": "es", "value": "SharpZipLib (o #ziplib) es una biblioteca Zip, GZip, Tar y BZip2. A partir de la versi\u00f3n 1.3.0 y versiones anteriores a 1.3.3, fue a\u00f1adida una comprobaci\u00f3n de si el archivo de destino est\u00e1 en el directorio de destino. Sin embargo, no es obligatorio que \"destDir\" termine en barra. Si \"destDir\" no termina en barra como \"/home/user/dir\" es posible crear un fichero con un nombre que empiece por el directorio de destino, por ejemplo \"/home/user/dir.sh\". Debido a las restricciones del nombre del archivo y del directorio de destino, el impacto de la creaci\u00f3n arbitraria de archivos es limitado y depende del caso de uso. La versi\u00f3n 1.3.3 contiene un parche para esta vulnerabilidad"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sharpziplib_project:sharpziplib:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.3.0", "versionEndExcluding": "1.3.3", "matchCriteriaId": "C56750EF-B437-4DCF-8355-37F595174730"}]}]}], "references": [{"url": "https://github.com/icsharpcode/SharpZipLib/commit/5c3b293de5d65b108e7f2cd0ea8f81c1b8273f78", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/icsharpcode/SharpZipLib/releases/tag/v1.3.3", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://securitylab.github.com/advisories/GHSL-2021-125-sharpziplib/", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/icsharpcode/SharpZipLib/commit/5c3b293de5d65b108e7f2cd0ea8f81c1b8273f78"}}