{"buggy_code": ["// SPDX-License-Identifier: BSD-2-Clause\n/*\n  Copyright (c) 2012-2016, Matthias Schiffer <mschiffer@universe-factory.net>\n  All rights reserved.\n*/\n\n/**\n   \\file\n\n   Functions for receiving and handling packets\n*/\n\n\n#include \"fastd.h\"\n#include \"handshake.h\"\n#include \"hash.h\"\n#include \"peer.h\"\n#include \"peer_hashtable.h\"\n\n#include <sys/uio.h>\n\n\n/** Handles the ancillary control messages of received packets */\nstatic inline void\nhandle_socket_control(struct msghdr *message, const fastd_socket_t *sock, fastd_peer_address_t *local_addr) {\n\tmemset(local_addr, 0, sizeof(fastd_peer_address_t));\n\n\tconst uint8_t *end = (const uint8_t *)message->msg_control + message->msg_controllen;\n\n\tstruct cmsghdr *cmsg;\n\tfor (cmsg = CMSG_FIRSTHDR(message); cmsg; cmsg = CMSG_NXTHDR(message, cmsg)) {\n\t\tif ((const uint8_t *)cmsg + sizeof(*cmsg) > end)\n\t\t\treturn;\n\n#ifdef USE_PKTINFO\n\t\tif (cmsg->cmsg_level == IPPROTO_IP && cmsg->cmsg_type == IP_PKTINFO) {\n\t\t\tstruct in_pktinfo pktinfo;\n\n\t\t\tif ((const uint8_t *)CMSG_DATA(cmsg) + sizeof(pktinfo) > end)\n\t\t\t\treturn;\n\n\t\t\tmemcpy(&pktinfo, CMSG_DATA(cmsg), sizeof(pktinfo));\n\n\t\t\tlocal_addr->in.sin_family = AF_INET;\n\t\t\tlocal_addr->in.sin_addr = pktinfo.ipi_addr;\n\t\t\tlocal_addr->in.sin_port = fastd_peer_address_get_port(sock->bound_addr);\n\n\t\t\treturn;\n\t\t}\n#endif\n\n\t\tif (cmsg->cmsg_level == IPPROTO_IPV6 && cmsg->cmsg_type == IPV6_PKTINFO) {\n\t\t\tstruct in6_pktinfo pktinfo;\n\n\t\t\tif ((uint8_t *)CMSG_DATA(cmsg) + sizeof(pktinfo) > end)\n\t\t\t\treturn;\n\n\t\t\tmemcpy(&pktinfo, CMSG_DATA(cmsg), sizeof(pktinfo));\n\n\t\t\tlocal_addr->in6.sin6_family = AF_INET6;\n\t\t\tlocal_addr->in6.sin6_addr = pktinfo.ipi6_addr;\n\t\t\tlocal_addr->in6.sin6_port = fastd_peer_address_get_port(sock->bound_addr);\n\n\t\t\tif (IN6_IS_ADDR_LINKLOCAL(&local_addr->in6.sin6_addr))\n\t\t\t\tlocal_addr->in6.sin6_scope_id = pktinfo.ipi6_ifindex;\n\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n/** Initializes the hashtables used to keep track of handshakes sent to unknown peers */\nvoid fastd_receive_unknown_init(void) {\n\tsize_t i, j;\n\tfor (i = 0; i < UNKNOWN_TABLES; i++) {\n\t\tctx.unknown_handshakes[i] = fastd_new0_array(UNKNOWN_ENTRIES, fastd_handshake_timeout_t);\n\n\t\tfor (j = 0; j < UNKNOWN_ENTRIES; j++)\n\t\t\tctx.unknown_handshakes[i][j].timeout = ctx.now;\n\t}\n\n\tfastd_random_bytes(&ctx.unknown_handshake_seed, sizeof(ctx.unknown_handshake_seed), false);\n}\n\n/** Frees the hashtables used to keep track of handshakes sent to unknown peers */\nvoid fastd_receive_unknown_free(void) {\n\tsize_t i;\n\tfor (i = 0; i < UNKNOWN_TABLES; i++)\n\t\tfree(ctx.unknown_handshakes[i]);\n}\n\n/** Returns the i'th hash bucket for a peer address */\nfastd_handshake_timeout_t *unknown_hash_entry(int64_t base, size_t i, const fastd_peer_address_t *addr) {\n\tint64_t slice = base - i;\n\tuint32_t hash = ctx.unknown_handshake_seed;\n\tfastd_hash(&hash, &slice, sizeof(slice));\n\tfastd_peer_address_hash(&hash, addr);\n\tfastd_hash_final(&hash);\n\n\treturn &ctx.unknown_handshakes[(size_t)slice % UNKNOWN_TABLES][hash % UNKNOWN_ENTRIES];\n}\n\n\n/**\n   Checks if a handshake should be sent after an unexpected payload packet has been received\n\n   backoff_unknown() tries to avoid flooding hosts with handshakes.\n*/\nstatic bool backoff_unknown(const fastd_peer_address_t *addr) {\n\tstatic const size_t table_interval = MIN_HANDSHAKE_INTERVAL / (UNKNOWN_TABLES - 1);\n\n\tint64_t base = ctx.now / table_interval;\n\tsize_t first_empty = UNKNOWN_TABLES, i;\n\n\tfor (i = 0; i < UNKNOWN_TABLES; i++) {\n\t\tconst fastd_handshake_timeout_t *t = unknown_hash_entry(base, i, addr);\n\n\t\tif (fastd_timed_out(t->timeout)) {\n\t\t\tif (first_empty == UNKNOWN_TABLES)\n\t\t\t\tfirst_empty = i;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!fastd_peer_address_equal(addr, &t->address))\n\t\t\tcontinue;\n\n\t\tpr_debug2(\"sent a handshake to unknown address %I a short time ago, not sending again\", addr);\n\t\treturn true;\n\t}\n\n\t/* We didn't find the address in any of the hashtables, now insert it */\n\tif (first_empty == UNKNOWN_TABLES)\n\t\tfirst_empty = fastd_rand(0, UNKNOWN_TABLES);\n\n\tfastd_handshake_timeout_t *t = unknown_hash_entry(base, first_empty, addr);\n\n\tt->address = *addr;\n\tt->timeout = ctx.now + MIN_HANDSHAKE_INTERVAL - first_empty * table_interval;\n\n\treturn false;\n}\n\n/** Handles a packet received from a known peer address */\nstatic inline void handle_socket_receive_known(\n\tfastd_socket_t *sock, const fastd_peer_address_t *local_addr, const fastd_peer_address_t *remote_addr,\n\tfastd_peer_t *peer, fastd_buffer_t *buffer) {\n\tif (!fastd_peer_may_connect(peer)) {\n\t\tfastd_buffer_free(buffer);\n\t\treturn;\n\t}\n\n\tconst uint8_t *packet_type = buffer->data;\n\n\tswitch (*packet_type) {\n\tcase PACKET_DATA:\n\t\tif (!fastd_peer_is_established(peer) || !fastd_peer_address_equal(&peer->local_address, local_addr)) {\n\t\t\tfastd_buffer_free(buffer);\n\n\t\t\tif (!backoff_unknown(remote_addr)) {\n\t\t\t\tpr_debug(\"unexpectedly received payload data from %P[%I]\", peer, remote_addr);\n\t\t\t\tconf.protocol->handshake_init(sock, local_addr, remote_addr, NULL);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tconf.protocol->handle_recv(peer, buffer);\n\t\tbreak;\n\n\tcase PACKET_HANDSHAKE:\n\t\tfastd_handshake_handle(sock, local_addr, remote_addr, peer, buffer);\n\t}\n}\n\n/** Determines if packets from known addresses are accepted */\nstatic inline bool allow_unknown_peers(void) {\n\treturn ctx.has_floating || fastd_allow_verify();\n}\n\n/** Handles a packet received from an unknown address */\nstatic inline void handle_socket_receive_unknown(\n\tfastd_socket_t *sock, const fastd_peer_address_t *local_addr, const fastd_peer_address_t *remote_addr,\n\tfastd_buffer_t *buffer) {\n\tconst uint8_t *packet_type = buffer->data;\n\n\tswitch (*packet_type) {\n\tcase PACKET_DATA:\n\t\tfastd_buffer_free(buffer);\n\n\t\tif (!backoff_unknown(remote_addr)) {\n\t\t\tpr_debug(\"unexpectedly received payload data from unknown address %I\", remote_addr);\n\t\t\tconf.protocol->handshake_init(sock, local_addr, remote_addr, NULL);\n\t\t}\n\t\tbreak;\n\n\tcase PACKET_HANDSHAKE:\n\t\tfastd_handshake_handle(sock, local_addr, remote_addr, NULL, buffer);\n\t}\n}\n\n/** Handles a packet read from a socket */\nstatic inline void handle_socket_receive(\n\tfastd_socket_t *sock, const fastd_peer_address_t *local_addr, const fastd_peer_address_t *remote_addr,\n\tfastd_buffer_t *buffer) {\n\tfastd_peer_t *peer = NULL;\n\n\tif (sock->peer) {\n\t\tif (!fastd_peer_address_equal(&sock->peer->address, remote_addr)) {\n\t\t\tfastd_buffer_free(buffer);\n\t\t\treturn;\n\t\t}\n\n\t\tpeer = sock->peer;\n\t} else {\n\t\tpeer = fastd_peer_hashtable_lookup(remote_addr);\n\t}\n\n\tif (peer) {\n\t\thandle_socket_receive_known(sock, local_addr, remote_addr, peer, buffer);\n\t} else if (allow_unknown_peers()) {\n\t\thandle_socket_receive_unknown(sock, local_addr, remote_addr, buffer);\n\t} else {\n\t\tpr_debug(\"received packet from unknown peer %I\", remote_addr);\n\t\tfastd_buffer_free(buffer);\n\t}\n}\n\n/** Reads a packet from a socket */\nvoid fastd_receive(fastd_socket_t *sock) {\n\tsize_t max_len = max_size_t(fastd_max_payload(ctx.max_mtu) + conf.overhead, MAX_HANDSHAKE_SIZE);\n\tfastd_buffer_t *buffer = fastd_buffer_alloc(max_len, conf.decrypt_headroom);\n\tfastd_peer_address_t local_addr;\n\tfastd_peer_address_t recvaddr;\n\tstruct iovec buffer_vec = { .iov_base = buffer->data, .iov_len = buffer->len };\n\tuint8_t cbuf[1024] __attribute__((aligned(8)));\n\n\tstruct msghdr message = {\n\t\t.msg_name = &recvaddr,\n\t\t.msg_namelen = sizeof(recvaddr),\n\t\t.msg_iov = &buffer_vec,\n\t\t.msg_iovlen = 1,\n\t\t.msg_control = cbuf,\n\t\t.msg_controllen = sizeof(cbuf),\n\t};\n\n\tssize_t len = recvmsg(sock->fd.fd, &message, 0);\n\tif (len <= 0) {\n\t\tif (len < 0)\n\t\t\tpr_warn_errno(\"recvmsg\");\n\n\t\tfastd_buffer_free(buffer);\n\t\treturn;\n\t}\n\n\tbuffer->len = len;\n\n\thandle_socket_control(&message, sock, &local_addr);\n\n#ifdef USE_PKTINFO\n\tif (!local_addr.sa.sa_family) {\n\t\tpr_error(\"received packet without packet info\");\n\t\tfastd_buffer_free(buffer);\n\t\treturn;\n\t}\n#endif\n\n\tfastd_peer_address_simplify(&local_addr);\n\tfastd_peer_address_simplify(&recvaddr);\n\n\thandle_socket_receive(sock, &local_addr, &recvaddr, buffer);\n}\n\n/** Handles a received and decrypted payload packet */\nvoid fastd_handle_receive(fastd_peer_t *peer, fastd_buffer_t *buffer, bool reordered) {\n\tif (conf.mode == MODE_TAP) {\n\t\tif (buffer->len < sizeof(fastd_eth_header_t)) {\n\t\t\tpr_debug(\"received truncated packet\");\n\t\t\tfastd_buffer_free(buffer);\n\t\t\treturn;\n\t\t}\n\n\t\tfastd_eth_addr_t src_addr = fastd_buffer_source_address(buffer);\n\n\t\tif (fastd_eth_addr_is_unicast(src_addr))\n\t\t\tfastd_peer_eth_addr_add(peer, src_addr);\n\t}\n\n\tfastd_stats_add(peer, STAT_RX, buffer->len);\n\n\tif (reordered)\n\t\tfastd_stats_add(peer, STAT_RX_REORDERED, buffer->len);\n\n\tfastd_iface_write(peer->iface, buffer);\n\n\tif (conf.mode == MODE_TAP && conf.forward) {\n\t\t/*\n\t\t  Misaligned buffers come from the null method, as it uses a 1-byte header\n\t\t  rather than (16*n+8)-byte like all other methods. When such a buffer enters\n\t\t  the transmit path again through fastd's forward feature, it will violate\n\t\t  the fastd_block128_t alignment.\n\t\t*/\n\t\tbuffer = fastd_buffer_align(buffer, conf.encrypt_headroom);\n\n\t\tfastd_send_data(buffer, peer, NULL);\n\t\treturn;\n\t}\n\n\tfastd_buffer_free(buffer);\n}\n"], "fixing_code": ["// SPDX-License-Identifier: BSD-2-Clause\n/*\n  Copyright (c) 2012-2016, Matthias Schiffer <mschiffer@universe-factory.net>\n  All rights reserved.\n*/\n\n/**\n   \\file\n\n   Functions for receiving and handling packets\n*/\n\n\n#include \"fastd.h\"\n#include \"handshake.h\"\n#include \"hash.h\"\n#include \"peer.h\"\n#include \"peer_hashtable.h\"\n\n#include <sys/uio.h>\n\n\n/** Handles the ancillary control messages of received packets */\nstatic inline void\nhandle_socket_control(struct msghdr *message, const fastd_socket_t *sock, fastd_peer_address_t *local_addr) {\n\tmemset(local_addr, 0, sizeof(fastd_peer_address_t));\n\n\tconst uint8_t *end = (const uint8_t *)message->msg_control + message->msg_controllen;\n\n\tstruct cmsghdr *cmsg;\n\tfor (cmsg = CMSG_FIRSTHDR(message); cmsg; cmsg = CMSG_NXTHDR(message, cmsg)) {\n\t\tif ((const uint8_t *)cmsg + sizeof(*cmsg) > end)\n\t\t\treturn;\n\n#ifdef USE_PKTINFO\n\t\tif (cmsg->cmsg_level == IPPROTO_IP && cmsg->cmsg_type == IP_PKTINFO) {\n\t\t\tstruct in_pktinfo pktinfo;\n\n\t\t\tif ((const uint8_t *)CMSG_DATA(cmsg) + sizeof(pktinfo) > end)\n\t\t\t\treturn;\n\n\t\t\tmemcpy(&pktinfo, CMSG_DATA(cmsg), sizeof(pktinfo));\n\n\t\t\tlocal_addr->in.sin_family = AF_INET;\n\t\t\tlocal_addr->in.sin_addr = pktinfo.ipi_addr;\n\t\t\tlocal_addr->in.sin_port = fastd_peer_address_get_port(sock->bound_addr);\n\n\t\t\treturn;\n\t\t}\n#endif\n\n\t\tif (cmsg->cmsg_level == IPPROTO_IPV6 && cmsg->cmsg_type == IPV6_PKTINFO) {\n\t\t\tstruct in6_pktinfo pktinfo;\n\n\t\t\tif ((uint8_t *)CMSG_DATA(cmsg) + sizeof(pktinfo) > end)\n\t\t\t\treturn;\n\n\t\t\tmemcpy(&pktinfo, CMSG_DATA(cmsg), sizeof(pktinfo));\n\n\t\t\tlocal_addr->in6.sin6_family = AF_INET6;\n\t\t\tlocal_addr->in6.sin6_addr = pktinfo.ipi6_addr;\n\t\t\tlocal_addr->in6.sin6_port = fastd_peer_address_get_port(sock->bound_addr);\n\n\t\t\tif (IN6_IS_ADDR_LINKLOCAL(&local_addr->in6.sin6_addr))\n\t\t\t\tlocal_addr->in6.sin6_scope_id = pktinfo.ipi6_ifindex;\n\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n/** Initializes the hashtables used to keep track of handshakes sent to unknown peers */\nvoid fastd_receive_unknown_init(void) {\n\tsize_t i, j;\n\tfor (i = 0; i < UNKNOWN_TABLES; i++) {\n\t\tctx.unknown_handshakes[i] = fastd_new0_array(UNKNOWN_ENTRIES, fastd_handshake_timeout_t);\n\n\t\tfor (j = 0; j < UNKNOWN_ENTRIES; j++)\n\t\t\tctx.unknown_handshakes[i][j].timeout = ctx.now;\n\t}\n\n\tfastd_random_bytes(&ctx.unknown_handshake_seed, sizeof(ctx.unknown_handshake_seed), false);\n}\n\n/** Frees the hashtables used to keep track of handshakes sent to unknown peers */\nvoid fastd_receive_unknown_free(void) {\n\tsize_t i;\n\tfor (i = 0; i < UNKNOWN_TABLES; i++)\n\t\tfree(ctx.unknown_handshakes[i]);\n}\n\n/** Returns the i'th hash bucket for a peer address */\nfastd_handshake_timeout_t *unknown_hash_entry(int64_t base, size_t i, const fastd_peer_address_t *addr) {\n\tint64_t slice = base - i;\n\tuint32_t hash = ctx.unknown_handshake_seed;\n\tfastd_hash(&hash, &slice, sizeof(slice));\n\tfastd_peer_address_hash(&hash, addr);\n\tfastd_hash_final(&hash);\n\n\treturn &ctx.unknown_handshakes[(size_t)slice % UNKNOWN_TABLES][hash % UNKNOWN_ENTRIES];\n}\n\n\n/**\n   Checks if a handshake should be sent after an unexpected payload packet has been received\n\n   backoff_unknown() tries to avoid flooding hosts with handshakes.\n*/\nstatic bool backoff_unknown(const fastd_peer_address_t *addr) {\n\tstatic const size_t table_interval = MIN_HANDSHAKE_INTERVAL / (UNKNOWN_TABLES - 1);\n\n\tint64_t base = ctx.now / table_interval;\n\tsize_t first_empty = UNKNOWN_TABLES, i;\n\n\tfor (i = 0; i < UNKNOWN_TABLES; i++) {\n\t\tconst fastd_handshake_timeout_t *t = unknown_hash_entry(base, i, addr);\n\n\t\tif (fastd_timed_out(t->timeout)) {\n\t\t\tif (first_empty == UNKNOWN_TABLES)\n\t\t\t\tfirst_empty = i;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!fastd_peer_address_equal(addr, &t->address))\n\t\t\tcontinue;\n\n\t\tpr_debug2(\"sent a handshake to unknown address %I a short time ago, not sending again\", addr);\n\t\treturn true;\n\t}\n\n\t/* We didn't find the address in any of the hashtables, now insert it */\n\tif (first_empty == UNKNOWN_TABLES)\n\t\tfirst_empty = fastd_rand(0, UNKNOWN_TABLES);\n\n\tfastd_handshake_timeout_t *t = unknown_hash_entry(base, first_empty, addr);\n\n\tt->address = *addr;\n\tt->timeout = ctx.now + MIN_HANDSHAKE_INTERVAL - first_empty * table_interval;\n\n\treturn false;\n}\n\n/** Handles a packet received from a known peer address */\nstatic inline void handle_socket_receive_known(\n\tfastd_socket_t *sock, const fastd_peer_address_t *local_addr, const fastd_peer_address_t *remote_addr,\n\tfastd_peer_t *peer, fastd_buffer_t *buffer) {\n\tif (!fastd_peer_may_connect(peer)) {\n\t\tfastd_buffer_free(buffer);\n\t\treturn;\n\t}\n\n\tconst uint8_t *packet_type = buffer->data;\n\n\tswitch (*packet_type) {\n\tcase PACKET_DATA:\n\t\tif (!fastd_peer_is_established(peer) || !fastd_peer_address_equal(&peer->local_address, local_addr)) {\n\t\t\tfastd_buffer_free(buffer);\n\n\t\t\tif (!backoff_unknown(remote_addr)) {\n\t\t\t\tpr_debug(\"unexpectedly received payload data from %P[%I]\", peer, remote_addr);\n\t\t\t\tconf.protocol->handshake_init(sock, local_addr, remote_addr, NULL);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tconf.protocol->handle_recv(peer, buffer);\n\t\tbreak;\n\n\tcase PACKET_HANDSHAKE:\n\t\tfastd_handshake_handle(sock, local_addr, remote_addr, peer, buffer);\n\t\tbreak;\n\n\tdefault:\n\t\tfastd_buffer_free(buffer);\n\t\tpr_debug(\"received packet with invalid type from %P[%I]\", peer, remote_addr);\n\t}\n}\n\n/** Determines if packets from known addresses are accepted */\nstatic inline bool allow_unknown_peers(void) {\n\treturn ctx.has_floating || fastd_allow_verify();\n}\n\n/** Handles a packet received from an unknown address */\nstatic inline void handle_socket_receive_unknown(\n\tfastd_socket_t *sock, const fastd_peer_address_t *local_addr, const fastd_peer_address_t *remote_addr,\n\tfastd_buffer_t *buffer) {\n\tconst uint8_t *packet_type = buffer->data;\n\n\tswitch (*packet_type) {\n\tcase PACKET_DATA:\n\t\tfastd_buffer_free(buffer);\n\n\t\tif (!backoff_unknown(remote_addr)) {\n\t\t\tpr_debug(\"unexpectedly received payload data from unknown address %I\", remote_addr);\n\t\t\tconf.protocol->handshake_init(sock, local_addr, remote_addr, NULL);\n\t\t}\n\t\tbreak;\n\n\tcase PACKET_HANDSHAKE:\n\t\tfastd_handshake_handle(sock, local_addr, remote_addr, NULL, buffer);\n\t\tbreak;\n\n\tdefault:\n\t\tfastd_buffer_free(buffer);\n\t\tpr_debug(\"received packet with invalid type from unknown address %I\", remote_addr);\n\t}\n}\n\n/** Handles a packet read from a socket */\nstatic inline void handle_socket_receive(\n\tfastd_socket_t *sock, const fastd_peer_address_t *local_addr, const fastd_peer_address_t *remote_addr,\n\tfastd_buffer_t *buffer) {\n\tfastd_peer_t *peer = NULL;\n\n\tif (sock->peer) {\n\t\tif (!fastd_peer_address_equal(&sock->peer->address, remote_addr)) {\n\t\t\tfastd_buffer_free(buffer);\n\t\t\treturn;\n\t\t}\n\n\t\tpeer = sock->peer;\n\t} else {\n\t\tpeer = fastd_peer_hashtable_lookup(remote_addr);\n\t}\n\n\tif (peer) {\n\t\thandle_socket_receive_known(sock, local_addr, remote_addr, peer, buffer);\n\t} else if (allow_unknown_peers()) {\n\t\thandle_socket_receive_unknown(sock, local_addr, remote_addr, buffer);\n\t} else {\n\t\tpr_debug(\"received packet from unknown peer %I\", remote_addr);\n\t\tfastd_buffer_free(buffer);\n\t}\n}\n\n/** Reads a packet from a socket */\nvoid fastd_receive(fastd_socket_t *sock) {\n\tsize_t max_len = max_size_t(fastd_max_payload(ctx.max_mtu) + conf.overhead, MAX_HANDSHAKE_SIZE);\n\tfastd_buffer_t *buffer = fastd_buffer_alloc(max_len, conf.decrypt_headroom);\n\tfastd_peer_address_t local_addr;\n\tfastd_peer_address_t recvaddr;\n\tstruct iovec buffer_vec = { .iov_base = buffer->data, .iov_len = buffer->len };\n\tuint8_t cbuf[1024] __attribute__((aligned(8)));\n\n\tstruct msghdr message = {\n\t\t.msg_name = &recvaddr,\n\t\t.msg_namelen = sizeof(recvaddr),\n\t\t.msg_iov = &buffer_vec,\n\t\t.msg_iovlen = 1,\n\t\t.msg_control = cbuf,\n\t\t.msg_controllen = sizeof(cbuf),\n\t};\n\n\tssize_t len = recvmsg(sock->fd.fd, &message, 0);\n\tif (len <= 0) {\n\t\tif (len < 0)\n\t\t\tpr_warn_errno(\"recvmsg\");\n\n\t\tfastd_buffer_free(buffer);\n\t\treturn;\n\t}\n\n\tbuffer->len = len;\n\n\thandle_socket_control(&message, sock, &local_addr);\n\n#ifdef USE_PKTINFO\n\tif (!local_addr.sa.sa_family) {\n\t\tpr_error(\"received packet without packet info\");\n\t\tfastd_buffer_free(buffer);\n\t\treturn;\n\t}\n#endif\n\n\tfastd_peer_address_simplify(&local_addr);\n\tfastd_peer_address_simplify(&recvaddr);\n\n\thandle_socket_receive(sock, &local_addr, &recvaddr, buffer);\n}\n\n/** Handles a received and decrypted payload packet */\nvoid fastd_handle_receive(fastd_peer_t *peer, fastd_buffer_t *buffer, bool reordered) {\n\tif (conf.mode == MODE_TAP) {\n\t\tif (buffer->len < sizeof(fastd_eth_header_t)) {\n\t\t\tpr_debug(\"received truncated packet\");\n\t\t\tfastd_buffer_free(buffer);\n\t\t\treturn;\n\t\t}\n\n\t\tfastd_eth_addr_t src_addr = fastd_buffer_source_address(buffer);\n\n\t\tif (fastd_eth_addr_is_unicast(src_addr))\n\t\t\tfastd_peer_eth_addr_add(peer, src_addr);\n\t}\n\n\tfastd_stats_add(peer, STAT_RX, buffer->len);\n\n\tif (reordered)\n\t\tfastd_stats_add(peer, STAT_RX_REORDERED, buffer->len);\n\n\tfastd_iface_write(peer->iface, buffer);\n\n\tif (conf.mode == MODE_TAP && conf.forward) {\n\t\t/*\n\t\t  Misaligned buffers come from the null method, as it uses a 1-byte header\n\t\t  rather than (16*n+8)-byte like all other methods. When such a buffer enters\n\t\t  the transmit path again through fastd's forward feature, it will violate\n\t\t  the fastd_block128_t alignment.\n\t\t*/\n\t\tbuffer = fastd_buffer_align(buffer, conf.encrypt_headroom);\n\n\t\tfastd_send_data(buffer, peer, NULL);\n\t\treturn;\n\t}\n\n\tfastd_buffer_free(buffer);\n}\n"], "filenames": ["src/receive.c"], "buggy_code_start_loc": [171], "buggy_code_end_loc": [197], "fixing_code_start_loc": [172], "fixing_code_end_loc": [208], "type": "CWE-617", "message": "receive.c in fastd before v21 allows denial of service (assertion failure) when receiving packets with an invalid type code.", "other": {"cve": {"id": "CVE-2020-27638", "sourceIdentifier": "cve@mitre.org", "published": "2020-10-22T13:15:15.613", "lastModified": "2022-04-28T18:23:56.790", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "receive.c in fastd before v21 allows denial of service (assertion failure) when receiving packets with an invalid type code."}, {"lang": "es", "value": "En el archivo Receive.c en fastd versiones anteriores a v21, permite una denegaci\u00f3n de servicio (fallo de aserci\u00f3n) cuando se reciben paquetes con un c\u00f3digo de tipo no v\u00e1lido"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fastd_project:fastd:*:*:*:*:*:*:*:*", "versionEndExcluding": "21.0", "matchCriteriaId": "17B42321-B3C8-436A-AD7B-65B61786EA0A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}], "references": [{"url": "https://bugs.debian.org/972521", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://fastd.readthedocs.io/en/stable/releases/v21.html", "source": "cve@mitre.org", "tags": ["Broken Link", "Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/NeoRaider/fastd/commit/737925113363b6130879729cdff9ccc46c33eaea", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/10/msg00025.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/D2LNSF2LI4RQ7BVGHTJQUJWP7RVGHDTK/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GUZ3AGTAXH7OOP45F5WXBVRQ3IDWUR7M/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WSMH65GHKHMJAK2VMPROIPIUS4IA63CW/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/NeoRaider/fastd/commit/737925113363b6130879729cdff9ccc46c33eaea"}}