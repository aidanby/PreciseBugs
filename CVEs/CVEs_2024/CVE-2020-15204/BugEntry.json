{"buggy_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/data_flow_ops.cc.\n\n#include <limits.h>\n#include <vector>\n\n#include \"tensorflow/core/common_runtime/device.h\"\n#include \"tensorflow/core/framework/device_base.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/gtl/map_util.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/macros.h\"\n#include \"tensorflow/core/platform/mutex.h\"\n#include \"tensorflow/core/platform/thread_annotations.h\"\n#include \"tensorflow/core/platform/types.h\"\n\nnamespace tensorflow {\n\nclass GetSessionHandleOp : public OpKernel {\n public:\n  explicit GetSessionHandleOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& val = ctx->input(0);\n    int64 id = ctx->session_state()->GetNewId();\n    TensorStore::TensorAndKey tk{val, id, requested_device()};\n    OP_REQUIRES_OK(ctx, ctx->tensor_store()->AddTensor(name(), tk));\n\n    Tensor* handle = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &handle));\n    if (ctx->expected_output_dtype(0) == DT_RESOURCE) {\n      ResourceHandle resource_handle = MakeResourceHandle<Tensor>(\n          ctx, SessionState::kTensorHandleResourceTypeName,\n          tk.GetHandle(name()));\n      resource_handle.set_maybe_type_name(\n          SessionState::kTensorHandleResourceTypeName);\n      handle->scalar<ResourceHandle>()() = resource_handle;\n    } else {\n      // Legacy behavior in V1.\n      handle->flat<tstring>().setConstant(tk.GetHandle(name()));\n    }\n  }\n\n  TF_DISALLOW_COPY_AND_ASSIGN(GetSessionHandleOp);\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"GetSessionHandle\").Device(DEVICE_CPU),\n                        GetSessionHandleOp);\nREGISTER_KERNEL_BUILDER(Name(\"GetSessionHandleV2\").Device(DEVICE_CPU),\n                        GetSessionHandleOp);\n\n#define REGISTER_GPU_KERNEL(type)                         \\\n  REGISTER_KERNEL_BUILDER(Name(\"GetSessionHandle\")        \\\n                              .Device(DEVICE_GPU)         \\\n                              .HostMemory(\"handle\")       \\\n                              .TypeConstraint<type>(\"T\"), \\\n                          GetSessionHandleOp)             \\\n  REGISTER_KERNEL_BUILDER(Name(\"GetSessionHandleV2\")      \\\n                              .Device(DEVICE_GPU)         \\\n                              .HostMemory(\"handle\")       \\\n                              .TypeConstraint<type>(\"T\"), \\\n                          GetSessionHandleOp)\n\nTF_CALL_NUMBER_TYPES(REGISTER_GPU_KERNEL);\nREGISTER_GPU_KERNEL(bool);\n#undef REGISTER_GPU_KERNEL\n\n\nclass GetSessionTensorOp : public OpKernel {\n public:\n  explicit GetSessionTensorOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& handle = ctx->input(0);\n    const string& name = handle.scalar<tstring>()();\n    Tensor val;\n    OP_REQUIRES_OK(ctx, ctx->session_state()->GetTensor(name, &val));\n    ctx->set_output(0, val);\n  }\n\n  TF_DISALLOW_COPY_AND_ASSIGN(GetSessionTensorOp);\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"GetSessionTensor\").Device(DEVICE_CPU),\n                        GetSessionTensorOp);\n\n#define REGISTER_GPU_KERNEL(type)                             \\\n  REGISTER_KERNEL_BUILDER(Name(\"GetSessionTensor\")            \\\n                              .Device(DEVICE_GPU)             \\\n                              .HostMemory(\"handle\")           \\\n                              .TypeConstraint<type>(\"dtype\"), \\\n                          GetSessionTensorOp)\n\nTF_CALL_NUMBER_TYPES(REGISTER_GPU_KERNEL);\nREGISTER_GPU_KERNEL(bool);\n#undef REGISTER_GPU_KERNEL\n\n\nclass DeleteSessionTensorOp : public OpKernel {\n public:\n  explicit DeleteSessionTensorOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& handle = ctx->input(0);\n    const string& name = handle.scalar<tstring>()();\n    OP_REQUIRES_OK(ctx, ctx->session_state()->DeleteTensor(name));\n  }\n\n  TF_DISALLOW_COPY_AND_ASSIGN(DeleteSessionTensorOp);\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"DeleteSessionTensor\").Device(DEVICE_CPU),\n                        DeleteSessionTensorOp);\nREGISTER_KERNEL_BUILDER(\n    Name(\"DeleteSessionTensor\").Device(DEVICE_GPU).HostMemory(\"handle\"),\n    DeleteSessionTensorOp);\n\n}  // namespace tensorflow\n", "# Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Raw ops tests.\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom absl.testing import parameterized\n\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import gen_math_ops\nfrom tensorflow.python.ops import gen_string_ops\nfrom tensorflow.python.platform import test\n\n\n@test_util.run_all_in_graph_and_eager_modes\n@test_util.disable_tfrt\nclass RawOpsTest(test.TestCase, parameterized.TestCase):\n\n  def testSimple(self):\n    x = constant_op.constant(1)\n    self.assertEqual([2], self.evaluate(gen_math_ops.Add(x=x, y=x)))\n\n  def testRequiresKwargs(self):\n    with self.assertRaisesRegex(TypeError, \"only takes keyword args\"):\n      gen_math_ops.Add(1., 1.)\n\n  def testRequiresKwargs_providesSuggestion(self):\n    msg = \"possible keys: \\\\['x', 'y', 'name'\\\\]\"\n    with self.assertRaisesRegex(TypeError, msg):\n      gen_math_ops.Add(1., y=2.)\n\n  def testName(self):\n    x = constant_op.constant(1)\n    op = gen_math_ops.Add(x=x, y=x, name=\"double\")\n    if not context.executing_eagerly():\n      # `Tensor.name` is not available in eager.\n      self.assertEqual(op.name, \"double:0\")\n\n  def testDoc(self):\n    self.assertEqual(gen_math_ops.add.__doc__, gen_math_ops.Add.__doc__)\n\n  def testDefaults(self):\n    x = constant_op.constant([[True]])\n    self.assertAllClose(\n        gen_math_ops.Any(input=x, axis=0),\n        gen_math_ops.Any(input=x, axis=0, keep_dims=False))\n\n  @parameterized.parameters([[0, 8]], [[-1, 6]])\n  def testStringNGramsBadDataSplits(self, splits):\n    data = [\"aa\", \"bb\", \"cc\", \"dd\", \"ee\", \"ff\"]\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"Invalid split value\"):\n      self.evaluate(\n          gen_string_ops.string_n_grams(\n              data=data,\n              data_splits=splits,\n              separator=\"\",\n              ngram_widths=[2],\n              left_pad=\"\",\n              right_pad=\"\",\n              pad_width=0,\n              preserve_short_sequences=False))\n\n\nif __name__ == \"__main__\":\n  ops.enable_eager_execution()\n  test.main()\n"], "fixing_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/data_flow_ops.cc.\n\n#include <limits.h>\n\n#include <vector>\n\n#include \"tensorflow/core/common_runtime/device.h\"\n#include \"tensorflow/core/framework/device_base.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/gtl/map_util.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/macros.h\"\n#include \"tensorflow/core/platform/mutex.h\"\n#include \"tensorflow/core/platform/thread_annotations.h\"\n#include \"tensorflow/core/platform/types.h\"\n\nnamespace tensorflow {\n\nclass GetSessionHandleOp : public OpKernel {\n public:\n  explicit GetSessionHandleOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& val = ctx->input(0);\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"GetSessionHandle called on null session state\"));\n    int64 id = session_state->GetNewId();\n    TensorStore::TensorAndKey tk{val, id, requested_device()};\n    OP_REQUIRES_OK(ctx, ctx->tensor_store()->AddTensor(name(), tk));\n\n    Tensor* handle = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &handle));\n    if (ctx->expected_output_dtype(0) == DT_RESOURCE) {\n      ResourceHandle resource_handle = MakeResourceHandle<Tensor>(\n          ctx, SessionState::kTensorHandleResourceTypeName,\n          tk.GetHandle(name()));\n      resource_handle.set_maybe_type_name(\n          SessionState::kTensorHandleResourceTypeName);\n      handle->scalar<ResourceHandle>()() = resource_handle;\n    } else {\n      // Legacy behavior in V1.\n      handle->flat<tstring>().setConstant(tk.GetHandle(name()));\n    }\n  }\n\n  TF_DISALLOW_COPY_AND_ASSIGN(GetSessionHandleOp);\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"GetSessionHandle\").Device(DEVICE_CPU),\n                        GetSessionHandleOp);\nREGISTER_KERNEL_BUILDER(Name(\"GetSessionHandleV2\").Device(DEVICE_CPU),\n                        GetSessionHandleOp);\n\n#define REGISTER_GPU_KERNEL(type)                         \\\n  REGISTER_KERNEL_BUILDER(Name(\"GetSessionHandle\")        \\\n                              .Device(DEVICE_GPU)         \\\n                              .HostMemory(\"handle\")       \\\n                              .TypeConstraint<type>(\"T\"), \\\n                          GetSessionHandleOp)             \\\n  REGISTER_KERNEL_BUILDER(Name(\"GetSessionHandleV2\")      \\\n                              .Device(DEVICE_GPU)         \\\n                              .HostMemory(\"handle\")       \\\n                              .TypeConstraint<type>(\"T\"), \\\n                          GetSessionHandleOp)\n\nTF_CALL_NUMBER_TYPES(REGISTER_GPU_KERNEL);\nREGISTER_GPU_KERNEL(bool);\n#undef REGISTER_GPU_KERNEL\n\n\nclass GetSessionTensorOp : public OpKernel {\n public:\n  explicit GetSessionTensorOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& handle = ctx->input(0);\n    const string& name = handle.scalar<tstring>()();\n    Tensor val;\n    OP_REQUIRES_OK(ctx, ctx->session_state()->GetTensor(name, &val));\n    ctx->set_output(0, val);\n  }\n\n  TF_DISALLOW_COPY_AND_ASSIGN(GetSessionTensorOp);\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"GetSessionTensor\").Device(DEVICE_CPU),\n                        GetSessionTensorOp);\n\n#define REGISTER_GPU_KERNEL(type)                             \\\n  REGISTER_KERNEL_BUILDER(Name(\"GetSessionTensor\")            \\\n                              .Device(DEVICE_GPU)             \\\n                              .HostMemory(\"handle\")           \\\n                              .TypeConstraint<type>(\"dtype\"), \\\n                          GetSessionTensorOp)\n\nTF_CALL_NUMBER_TYPES(REGISTER_GPU_KERNEL);\nREGISTER_GPU_KERNEL(bool);\n#undef REGISTER_GPU_KERNEL\n\n\nclass DeleteSessionTensorOp : public OpKernel {\n public:\n  explicit DeleteSessionTensorOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& handle = ctx->input(0);\n    const string& name = handle.scalar<tstring>()();\n    OP_REQUIRES_OK(ctx, ctx->session_state()->DeleteTensor(name));\n  }\n\n  TF_DISALLOW_COPY_AND_ASSIGN(DeleteSessionTensorOp);\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"DeleteSessionTensor\").Device(DEVICE_CPU),\n                        DeleteSessionTensorOp);\nREGISTER_KERNEL_BUILDER(\n    Name(\"DeleteSessionTensor\").Device(DEVICE_GPU).HostMemory(\"handle\"),\n    DeleteSessionTensorOp);\n\n}  // namespace tensorflow\n", "# Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Raw ops tests.\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom absl.testing import parameterized\n\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import gen_data_flow_ops\nfrom tensorflow.python.ops import gen_math_ops\nfrom tensorflow.python.ops import gen_string_ops\nfrom tensorflow.python.platform import test\n\n\n@test_util.run_all_in_graph_and_eager_modes\n@test_util.disable_tfrt\nclass RawOpsTest(test.TestCase, parameterized.TestCase):\n\n  def testSimple(self):\n    x = constant_op.constant(1)\n    self.assertEqual([2], self.evaluate(gen_math_ops.Add(x=x, y=x)))\n\n  def testRequiresKwargs(self):\n    with self.assertRaisesRegex(TypeError, \"only takes keyword args\"):\n      gen_math_ops.Add(1., 1.)\n\n  def testRequiresKwargs_providesSuggestion(self):\n    msg = \"possible keys: \\\\['x', 'y', 'name'\\\\]\"\n    with self.assertRaisesRegex(TypeError, msg):\n      gen_math_ops.Add(1., y=2.)\n\n  def testName(self):\n    x = constant_op.constant(1)\n    op = gen_math_ops.Add(x=x, y=x, name=\"double\")\n    if not context.executing_eagerly():\n      # `Tensor.name` is not available in eager.\n      self.assertEqual(op.name, \"double:0\")\n\n  def testDoc(self):\n    self.assertEqual(gen_math_ops.add.__doc__, gen_math_ops.Add.__doc__)\n\n  def testDefaults(self):\n    x = constant_op.constant([[True]])\n    self.assertAllClose(\n        gen_math_ops.Any(input=x, axis=0),\n        gen_math_ops.Any(input=x, axis=0, keep_dims=False))\n\n  @parameterized.parameters([[0, 8]], [[-1, 6]])\n  def testStringNGramsBadDataSplits(self, splits):\n    data = [\"aa\", \"bb\", \"cc\", \"dd\", \"ee\", \"ff\"]\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"Invalid split value\"):\n      self.evaluate(\n          gen_string_ops.string_n_grams(\n              data=data,\n              data_splits=splits,\n              separator=\"\",\n              ngram_widths=[2],\n              left_pad=\"\",\n              right_pad=\"\",\n              pad_width=0,\n              preserve_short_sequences=False))\n\n  def testGetSessionHandle(self):\n    if context.executing_eagerly():\n      with self.assertRaisesRegex(\n          errors.FailedPreconditionError,\n          \"GetSessionHandle called on null session state\"):\n        gen_data_flow_ops.GetSessionHandle(value=[1])\n\n\nif __name__ == \"__main__\":\n  ops.enable_eager_execution()\n  test.main()\n"], "filenames": ["tensorflow/core/kernels/session_ops.cc", "tensorflow/python/ops/raw_ops_test.py"], "buggy_code_start_loc": [18, 27], "buggy_code_end_loc": [46, 81], "fixing_code_start_loc": [19, 28], "fixing_code_end_loc": [52, 90], "type": "CWE-476", "message": "In eager mode, TensorFlow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1 does not set the session state. Hence, calling `tf.raw_ops.GetSessionHandle` or `tf.raw_ops.GetSessionHandleV2` results in a null pointer dereference In linked snippet, in eager mode, `ctx->session_state()` returns `nullptr`. Since code immediately dereferences this, we get a segmentation fault. The issue is patched in commit 9a133d73ae4b4664d22bd1aa6d654fec13c52ee1, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.", "other": {"cve": {"id": "CVE-2020-15204", "sourceIdentifier": "security-advisories@github.com", "published": "2020-09-25T19:15:15.713", "lastModified": "2021-09-16T15:45:46.697", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In eager mode, TensorFlow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1 does not set the session state. Hence, calling `tf.raw_ops.GetSessionHandle` or `tf.raw_ops.GetSessionHandleV2` results in a null pointer dereference In linked snippet, in eager mode, `ctx->session_state()` returns `nullptr`. Since code immediately dereferences this, we get a segmentation fault. The issue is patched in commit 9a133d73ae4b4664d22bd1aa6d654fec13c52ee1, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1."}, {"lang": "es", "value": "En modo eager, TensorFlow versiones anteriores a 1.15.4, 2.0.3, 2.1.2, 2.2.1 y 2.3.1 no establece el estado de la sesi\u00f3n.&#xa0;Por lo tanto, llamar a \"tf.raw_ops.GetSessionHandle\" o \"tf.raw_ops.GetSessionHandleV2\" resulta en una desreferencia del puntero null. En el fragmento vinculado, en modo eager, \"ctx-) session_state()\" devuelve \"nullptr\".&#xa0;Dado que el c\u00f3digo elimina inmediatamente la referencia a esto, obtenemos un fallo de segmentaci\u00f3n.&#xa0;El problema es parcheado en el commit 9a133d73ae4b4664d22bd1aa6d654fec13c52ee1 y es publicado en TensorFlow versiones 1.15.4, 2.0.3, 2.1.2, 2.2.1 o 2.3.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:-:*:*:*", "versionEndExcluding": "1.15.4", "matchCriteriaId": "EC688B44-17B7-462D-B6E3-BAAF99334782"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:-:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.0.3", "matchCriteriaId": "B6271763-8DFA-4A8F-9596-F1148961ECC5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:-:*:*:*", "versionStartIncluding": "2.1.0", "versionEndExcluding": "2.1.2", "matchCriteriaId": "AA3FD62B-13CB-4EB5-939F-C848DE9AE071"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:-:*:*:*", "versionStartIncluding": "2.2.0", "versionEndExcluding": "2.2.1", "matchCriteriaId": "029CB8A9-ED3D-486D-967C-4CE0AF8D8FAD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:-:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.1", "matchCriteriaId": "B617650A-B5A1-44BB-BB3A-2EF83648B100"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.2:*:*:*:*:*:*:*", "matchCriteriaId": "B009C22E-30A4-4288-BCF6-C3E81DEAF45A"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-10/msg00065.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/commit/9a133d73ae4b4664d22bd1aa6d654fec13c52ee1", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/releases/tag/v2.3.1", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-q8gv-q7wr-9jf8", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/9a133d73ae4b4664d22bd1aa6d654fec13c52ee1"}}