{"buggy_code": ["'use strict';\n// @ts-check\n// ==================================================================================\n// utils.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2020\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 0. helper functions\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst fs = require('fs');\nconst spawn = require('child_process').spawn;\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst util = require('util');\n\nlet _platform = process.platform;\nconst _linux = (_platform === 'linux');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\n// const _sunos = (_platform === 'sunos');\n\nlet _cores = 0;\nlet wmicPath = '';\nlet codepage = '';\n\nconst execOptsWin = {\n  windowsHide: true,\n  maxBuffer: 1024 * 20000,\n  encoding: 'UTF-8',\n  env: util._extend({}, process.env, { LANG: 'en_US.UTF-8' })\n};\n\nfunction toInt(value) {\n  let result = parseInt(value, 10);\n  if (isNaN(result)) {\n    result = 0;\n  }\n  return result;\n}\n\nfunction isFunction(functionToCheck) {\n  let getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\nfunction unique(obj) {\n  let uniques = [];\n  let stringify = {};\n  for (let i = 0; i < obj.length; i++) {\n    let keys = Object.keys(obj[i]);\n    keys.sort(function (a, b) { return a - b; });\n    let str = '';\n    for (let j = 0; j < keys.length; j++) {\n      str += JSON.stringify(keys[j]);\n      str += JSON.stringify(obj[i][keys[j]]);\n    }\n    if (!{}.hasOwnProperty.call(stringify, str)) {\n      uniques.push(obj[i]);\n      stringify[str] = true;\n    }\n  }\n  return uniques;\n}\n\nfunction sortByKey(array, keys) {\n  return array.sort(function (a, b) {\n    let x = '';\n    let y = '';\n    keys.forEach(function (key) {\n      x = x + a[key]; y = y + b[key];\n    });\n    return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n  });\n}\n\nfunction cores() {\n  if (_cores === 0) {\n    _cores = os.cpus().length;\n  }\n  return _cores;\n}\n\nfunction getValue(lines, property, separator, trimmed) {\n  separator = separator || ':';\n  property = property.toLowerCase();\n  trimmed = trimmed || false;\n  for (let i = 0; i < lines.length; i++) {\n    let line = lines[i].toLowerCase().replace(/\\t/g, '');\n    if (trimmed) {\n      line = line.trim();\n    }\n    if (line.startsWith(property)) {\n      const parts = lines[i].split(separator);\n      if (parts.length >= 2) {\n        parts.shift();\n        return parts.join(separator).trim();\n      } else {\n        return '';\n      }\n    }\n  }\n  return '';\n}\n\nfunction decodeEscapeSequence(str, base) {\n  base = base || 16;\n  return str.replace(/\\\\x([0-9A-Fa-f]{2})/g, function () {\n    return String.fromCharCode(parseInt(arguments[1], base));\n  });\n}\n\nfunction detectSplit(str) {\n  let seperator = '';\n  let part = 0;\n  str.split('').forEach(element => {\n    if (element >= '0' && element <= '9') {\n      if (part === 1) { part++; }\n    } else {\n      if (part === 0) { part++; }\n      if (part === 1) {\n        seperator += element;\n      }\n    }\n  });\n  return seperator;\n}\n\nfunction parseTime(t, pmDesignator) {\n  pmDesignator = pmDesignator || '';\n  t = t.toUpperCase();\n  let hour = 0;\n  let min = 0;\n  let splitter = detectSplit(t);\n  let parts = t.split(splitter);\n  if (parts.length >= 2) {\n    if (parts[2]) {\n      parts[1] += parts[2];\n    }\n    let isPM = (parts[1] && (parts[1].toLowerCase().indexOf('pm') > -1) || (parts[1].toLowerCase().indexOf('p.m.') > -1) || (parts[1].toLowerCase().indexOf('p. m.') > -1) || (parts[1].toLowerCase().indexOf('n') > -1) || (parts[1].toLowerCase().indexOf('ch') > -1) || (parts[1].toLowerCase().indexOf('\u00f6s') > -1) || (pmDesignator && parts[1].toLowerCase().indexOf(pmDesignator) > -1));\n    hour = parseInt(parts[0], 10);\n    min = parseInt(parts[1], 10);\n    hour = isPM && hour < 12 ? hour + 12 : hour;\n    return ('0' + hour).substr(-2) + ':' + ('0' + min).substr(-2);\n  }\n}\n\nfunction parseDateTime(dt, culture) {\n  const result = {\n    date: '',\n    time: ''\n  };\n  culture = culture || {};\n  let dateFormat = (culture.dateFormat || '').toLowerCase();\n  let pmDesignator = (culture.pmDesignator || '');\n\n  const parts = dt.split(' ');\n  if (parts[0]) {\n    if (parts[0].indexOf('/') >= 0) {\n      // Dateformat: mm/dd/yyyy or dd/mm/yyyy or dd/mm/yy or yyyy/mm/dd\n      const dtparts = parts[0].split('/');\n      if (dtparts.length === 3) {\n        if (dtparts[0].length === 4) {\n          // Dateformat: yyyy/mm/dd\n          result.date = dtparts[0] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[2]).substr(-2);\n        } else if (dtparts[2].length === 2) {\n          if ((dateFormat.indexOf('/d/') > -1 || dateFormat.indexOf('/dd/') > -1)) {\n            // Dateformat: mm/dd/yy\n            result.date = '20' + dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n          } else {\n            // Dateformat: dd/mm/yy\n            result.date = '20' + dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n          }\n        } else {\n          // Dateformat: mm/dd/yyyy or dd/mm/yyyy\n          const isEN = ((dt.toLowerCase().indexOf('pm') > -1) || (dt.toLowerCase().indexOf('p.m.') > -1) || (dt.toLowerCase().indexOf('p. m.') > -1) || (dt.toLowerCase().indexOf('am') > -1) || (dt.toLowerCase().indexOf('a.m.') > -1) || (dt.toLowerCase().indexOf('a. m.') > -1));\n          if ((isEN || dateFormat.indexOf('/d/') > -1 || dateFormat.indexOf('/dd/') > -1) && dateFormat.indexOf('dd/') !== 0) {\n            // Dateformat: mm/dd/yyyy\n            result.date = dtparts[2] + '-' + ('0' + dtparts[0]).substr(-2) + '-' + ('0' + dtparts[1]).substr(-2);\n          } else {\n            // Dateformat: dd/mm/yyyy\n            result.date = dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n          }\n        }\n      }\n    }\n    if (parts[0].indexOf('.') >= 0) {\n      const dtparts = parts[0].split('.');\n      if (dtparts.length === 3) {\n        if (dateFormat.indexOf('.d.') > -1 || dateFormat.indexOf('.dd.') > -1) {\n          // Dateformat: mm.dd.yyyy\n          result.date = dtparts[2] + '-' + ('0' + dtparts[0]).substr(-2) + '-' + ('0' + dtparts[1]).substr(-2);\n        } else {\n          // Dateformat: dd.mm.yyyy\n          result.date = dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n        }\n      }\n    }\n    if (parts[0].indexOf('-') >= 0) {\n      // Dateformat: yyyy-mm-dd\n      const dtparts = parts[0].split('-');\n      if (dtparts.length === 3) {\n        result.date = dtparts[0] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[2]).substr(-2);\n      }\n    }\n  }\n  if (parts[1]) {\n    parts.shift();\n    let time = parts.join(' ');\n    result.time = parseTime(time, pmDesignator);\n  }\n  return result;\n}\n\nfunction parseHead(head, rights) {\n  let space = (rights > 0);\n  let count = 1;\n  let from = 0;\n  let to = 0;\n  let result = [];\n  for (let i = 0; i < head.length; i++) {\n    if (count <= rights) {\n      // if (head[i] === ' ' && !space) {\n      if (/\\s/.test(head[i]) && !space) {\n        to = i - 1;\n        result.push({\n          from: from,\n          to: to + 1,\n          cap: head.substring(from, to + 1)\n        });\n        from = to + 2;\n        count++;\n      }\n      space = head[i] === ' ';\n    } else {\n      if (!/\\s/.test(head[i]) && space) {\n        to = i - 1;\n        if (from < to) {\n          result.push({\n            from: from,\n            to: to,\n            cap: head.substring(from, to)\n          });\n        }\n        from = to + 1;\n        count++;\n      }\n      space = head[i] === ' ';\n    }\n  }\n  to = 1000;\n  result.push({\n    from: from,\n    to: to,\n    cap: head.substring(from, to)\n  });\n  let len = result.length;\n  for (var i = 0; i < len; i++) {\n    if (result[i].cap.replace(/\\s/g, '').length === 0) {\n      if (i + 1 < len) {\n        result[i].to = result[i + 1].to;\n        result[i].cap = result[i].cap + result[i + 1].cap;\n        result.splice(i + 1, 1);\n        len = len - 1;\n      }\n    }\n  }\n  return result;\n}\n\nfunction findObjectByKey(array, key, value) {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i][key] === value) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction getWmic() {\n  if (os.type() === 'Windows_NT' && !wmicPath) {\n    wmicPath = process.env.WINDIR + '\\\\system32\\\\wbem\\\\wmic.exe';\n    if (!fs.existsSync(wmicPath)) {\n      try {\n        const wmicPathArray = execSync('WHERE WMIC').toString().split('\\r\\n');\n        if (wmicPathArray && wmicPathArray.length) {\n          wmicPath = wmicPathArray[0];\n        } else {\n          wmicPath = 'wmic';\n        }\n      } catch (e) {\n        wmicPath = 'wmic';\n      }\n    }\n  }\n  return wmicPath;\n}\n\nfunction wmic(command, options) {\n  options = options || execOptsWin;\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      try {\n        exec(getWmic() + ' ' + command, options, function (error, stdout) {\n          resolve(stdout, error);\n        }).stdin.end();\n      } catch (e) {\n        resolve('', e);\n      }\n    });\n  });\n}\n\nfunction getVboxmanage() {\n  return _windows ? process.env.VBOX_INSTALL_PATH || process.env.VBOX_MSI_INSTALL_PATH + '\\\\VBoxManage.exe' + '\" ' : 'vboxmanage';\n}\n\nfunction powerShell(cmd) {\n\n  let result = '';\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      try {\n        const child = spawn('powershell.exe', ['-NoLogo', '-InputFormat', 'Text', '-NoExit', '-ExecutionPolicy', 'Unrestricted', '-Command', '-'], {\n          stdio: 'pipe'\n        });\n\n        if (child && !child.pid) {\n          child.on('error', function () {\n            resolve(result);\n          });\n        }\n        if (child && child.pid) {\n          child.stdout.on('data', function (data) {\n            result = result + data.toString('utf8');\n          });\n          child.stderr.on('data', function () {\n            child.kill();\n            resolve(result);\n          });\n          child.on('close', function () {\n            child.kill();\n            resolve(result);\n          });\n          child.on('error', function () {\n            child.kill();\n            resolve(result);\n          });\n          try {\n            child.stdin.write(cmd + os.EOL);\n            child.stdin.write('exit' + os.EOL);\n            child.stdin.end();\n          } catch (e) {\n            child.kill();\n            resolve(result);\n          }\n        } else {\n          resolve(result);\n        }\n      } catch (e) {\n        resolve(result);\n      }\n    });\n  });\n}\n\nfunction getCodepage() {\n  if (_windows) {\n    if (!codepage) {\n      try {\n        const stdout = execSync('chcp');\n        const lines = stdout.toString().split('\\r\\n');\n        const parts = lines[0].split(':');\n        codepage = parts.length > 1 ? parts[1].replace('.', '') : '';\n      } catch (err) {\n        codepage = '437';\n      }\n    }\n    return codepage;\n  }\n  if (_linux || _darwin || _freebsd || _openbsd || _netbsd) {\n    if (!codepage) {\n      try {\n        const stdout = execSync('echo $LANG');\n        const lines = stdout.toString().split('\\r\\n');\n        const parts = lines[0].split('.');\n        codepage = parts.length > 1 ? parts[1].trim() : '';\n        if (!codepage) {\n          codepage = 'UTF-8';\n        }\n      } catch (err) {\n        codepage = 'UTF-8';\n      }\n    }\n    return codepage;\n  }\n}\n\nfunction isRaspberry() {\n  const PI_MODEL_NO = [\n    'BCM2708',\n    'BCM2709',\n    'BCM2710',\n    'BCM2835',\n    'BCM2837B0'\n  ];\n  let cpuinfo = [];\n  try {\n    cpuinfo = fs.readFileSync('/proc/cpuinfo', { encoding: 'utf8' }).split('\\n');\n  } catch (e) {\n    return false;\n  }\n  const hardware = getValue(cpuinfo, 'hardware');\n  return (hardware && PI_MODEL_NO.indexOf(hardware) > -1);\n}\n\nfunction isRaspbian() {\n  let osrelease = [];\n  try {\n    osrelease = fs.readFileSync('/etc/os-release', { encoding: 'utf8' }).split('\\n');\n  } catch (e) {\n    return false;\n  }\n  const id = getValue(osrelease, 'id');\n  return (id && id.indexOf('raspbian') > -1);\n}\n\nfunction execWin(cmd, opts, callback) {\n  if (!callback) {\n    callback = opts;\n    opts = execOptsWin;\n  }\n  let newCmd = 'chcp 65001 > nul && cmd /C ' + cmd + ' && chcp ' + codepage + ' > nul';\n  exec(newCmd, opts, function (error, stdout) {\n    callback(error, stdout);\n  });\n}\n\nfunction darwinXcodeExists() {\n  const cmdLineToolsExists = fs.existsSync('/Library/Developer/CommandLineTools/usr/bin/');\n  const xcodeAppExists = fs.existsSync('/Applications/Xcode.app/Contents/Developer/Tools');\n  const xcodeExists = fs.existsSync('/Library/Developer/Xcode/');\n  return (cmdLineToolsExists || xcodeExists || xcodeAppExists);\n}\n\nfunction nanoSeconds() {\n  const time = process.hrtime();\n  if (!Array.isArray(time) || time.length !== 2) {\n    return 0;\n  }\n  return +time[0] * 1e9 + +time[1];\n}\n\nfunction countUniqueLines(lines, startingWith) {\n  startingWith = startingWith || '';\n  const uniqueLines = [];\n  lines.forEach(line => {\n    if (line.startsWith(startingWith)) {\n      if (uniqueLines.indexOf(line) === -1) {\n        uniqueLines.push(line);\n      }\n    }\n  });\n  return uniqueLines.length;\n}\n\nfunction countLines(lines, startingWith) {\n  startingWith = startingWith || '';\n  const uniqueLines = [];\n  lines.forEach(line => {\n    if (line.startsWith(startingWith)) {\n      uniqueLines.push(line);\n    }\n  });\n  return uniqueLines.length;\n}\n\nfunction sanitizeShellString(str) {\n  let result = str;\n  result = result.replace(/>/g, \"\");\n  result = result.replace(/</g, \"\");\n  result = result.replace(/\\*/g, \"\");\n  result = result.replace(/\\?/g, \"\");\n  result = result.replace(/\\[/g, \"\");\n  result = result.replace(/\\]/g, \"\");\n  result = result.replace(/\\|/g, \"\");\n  result = result.replace(/\\`/g, \"\");\n  result = result.replace(/$/g, \"\");\n  result = result.replace(/;/g, \"\");\n  result = result.replace(/&/g, \"\");\n  result = result.replace(/\\)/g, \"\");\n  result = result.replace(/\\(/g, \"\");\n  result = result.replace(/\\$/g, \"\");\n  result = result.replace(/#/g, \"\");\n  result = result.replace(/\\\\/g, \"\");\n  return result\n}\n\nfunction noop() { }\n\nexports.toInt = toInt;\nexports.execOptsWin = execOptsWin;\nexports.getCodepage = getCodepage;\nexports.execWin = execWin;\nexports.isFunction = isFunction;\nexports.unique = unique;\nexports.sortByKey = sortByKey;\nexports.cores = cores;\nexports.getValue = getValue;\nexports.decodeEscapeSequence = decodeEscapeSequence;\nexports.parseDateTime = parseDateTime;\nexports.parseHead = parseHead;\nexports.findObjectByKey = findObjectByKey;\nexports.getWmic = getWmic;\nexports.wmic = wmic;\nexports.darwinXcodeExists = darwinXcodeExists;\nexports.getVboxmanage = getVboxmanage;\nexports.powerShell = powerShell;\nexports.nanoSeconds = nanoSeconds;\nexports.countUniqueLines = countUniqueLines;\nexports.countLines = countLines;\nexports.noop = noop;\nexports.isRaspberry = isRaspberry;\nexports.isRaspbian = isRaspbian;\nexports.sanitizeShellString = sanitizeShellString;\n"], "fixing_code": ["'use strict';\n// @ts-check\n// ==================================================================================\n// utils.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2020\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 0. helper functions\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst fs = require('fs');\nconst spawn = require('child_process').spawn;\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst util = require('util');\n\nlet _platform = process.platform;\nconst _linux = (_platform === 'linux');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\n// const _sunos = (_platform === 'sunos');\n\nlet _cores = 0;\nlet wmicPath = '';\nlet codepage = '';\n\nconst execOptsWin = {\n  windowsHide: true,\n  maxBuffer: 1024 * 20000,\n  encoding: 'UTF-8',\n  env: util._extend({}, process.env, { LANG: 'en_US.UTF-8' })\n};\n\nfunction toInt(value) {\n  let result = parseInt(value, 10);\n  if (isNaN(result)) {\n    result = 0;\n  }\n  return result;\n}\n\nfunction isFunction(functionToCheck) {\n  let getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\nfunction unique(obj) {\n  let uniques = [];\n  let stringify = {};\n  for (let i = 0; i < obj.length; i++) {\n    let keys = Object.keys(obj[i]);\n    keys.sort(function (a, b) { return a - b; });\n    let str = '';\n    for (let j = 0; j < keys.length; j++) {\n      str += JSON.stringify(keys[j]);\n      str += JSON.stringify(obj[i][keys[j]]);\n    }\n    if (!{}.hasOwnProperty.call(stringify, str)) {\n      uniques.push(obj[i]);\n      stringify[str] = true;\n    }\n  }\n  return uniques;\n}\n\nfunction sortByKey(array, keys) {\n  return array.sort(function (a, b) {\n    let x = '';\n    let y = '';\n    keys.forEach(function (key) {\n      x = x + a[key]; y = y + b[key];\n    });\n    return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n  });\n}\n\nfunction cores() {\n  if (_cores === 0) {\n    _cores = os.cpus().length;\n  }\n  return _cores;\n}\n\nfunction getValue(lines, property, separator, trimmed) {\n  separator = separator || ':';\n  property = property.toLowerCase();\n  trimmed = trimmed || false;\n  for (let i = 0; i < lines.length; i++) {\n    let line = lines[i].toLowerCase().replace(/\\t/g, '');\n    if (trimmed) {\n      line = line.trim();\n    }\n    if (line.startsWith(property)) {\n      const parts = lines[i].split(separator);\n      if (parts.length >= 2) {\n        parts.shift();\n        return parts.join(separator).trim();\n      } else {\n        return '';\n      }\n    }\n  }\n  return '';\n}\n\nfunction decodeEscapeSequence(str, base) {\n  base = base || 16;\n  return str.replace(/\\\\x([0-9A-Fa-f]{2})/g, function () {\n    return String.fromCharCode(parseInt(arguments[1], base));\n  });\n}\n\nfunction detectSplit(str) {\n  let seperator = '';\n  let part = 0;\n  str.split('').forEach(element => {\n    if (element >= '0' && element <= '9') {\n      if (part === 1) { part++; }\n    } else {\n      if (part === 0) { part++; }\n      if (part === 1) {\n        seperator += element;\n      }\n    }\n  });\n  return seperator;\n}\n\nfunction parseTime(t, pmDesignator) {\n  pmDesignator = pmDesignator || '';\n  t = t.toUpperCase();\n  let hour = 0;\n  let min = 0;\n  let splitter = detectSplit(t);\n  let parts = t.split(splitter);\n  if (parts.length >= 2) {\n    if (parts[2]) {\n      parts[1] += parts[2];\n    }\n    let isPM = (parts[1] && (parts[1].toLowerCase().indexOf('pm') > -1) || (parts[1].toLowerCase().indexOf('p.m.') > -1) || (parts[1].toLowerCase().indexOf('p. m.') > -1) || (parts[1].toLowerCase().indexOf('n') > -1) || (parts[1].toLowerCase().indexOf('ch') > -1) || (parts[1].toLowerCase().indexOf('\u00f6s') > -1) || (pmDesignator && parts[1].toLowerCase().indexOf(pmDesignator) > -1));\n    hour = parseInt(parts[0], 10);\n    min = parseInt(parts[1], 10);\n    hour = isPM && hour < 12 ? hour + 12 : hour;\n    return ('0' + hour).substr(-2) + ':' + ('0' + min).substr(-2);\n  }\n}\n\nfunction parseDateTime(dt, culture) {\n  const result = {\n    date: '',\n    time: ''\n  };\n  culture = culture || {};\n  let dateFormat = (culture.dateFormat || '').toLowerCase();\n  let pmDesignator = (culture.pmDesignator || '');\n\n  const parts = dt.split(' ');\n  if (parts[0]) {\n    if (parts[0].indexOf('/') >= 0) {\n      // Dateformat: mm/dd/yyyy or dd/mm/yyyy or dd/mm/yy or yyyy/mm/dd\n      const dtparts = parts[0].split('/');\n      if (dtparts.length === 3) {\n        if (dtparts[0].length === 4) {\n          // Dateformat: yyyy/mm/dd\n          result.date = dtparts[0] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[2]).substr(-2);\n        } else if (dtparts[2].length === 2) {\n          if ((dateFormat.indexOf('/d/') > -1 || dateFormat.indexOf('/dd/') > -1)) {\n            // Dateformat: mm/dd/yy\n            result.date = '20' + dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n          } else {\n            // Dateformat: dd/mm/yy\n            result.date = '20' + dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n          }\n        } else {\n          // Dateformat: mm/dd/yyyy or dd/mm/yyyy\n          const isEN = ((dt.toLowerCase().indexOf('pm') > -1) || (dt.toLowerCase().indexOf('p.m.') > -1) || (dt.toLowerCase().indexOf('p. m.') > -1) || (dt.toLowerCase().indexOf('am') > -1) || (dt.toLowerCase().indexOf('a.m.') > -1) || (dt.toLowerCase().indexOf('a. m.') > -1));\n          if ((isEN || dateFormat.indexOf('/d/') > -1 || dateFormat.indexOf('/dd/') > -1) && dateFormat.indexOf('dd/') !== 0) {\n            // Dateformat: mm/dd/yyyy\n            result.date = dtparts[2] + '-' + ('0' + dtparts[0]).substr(-2) + '-' + ('0' + dtparts[1]).substr(-2);\n          } else {\n            // Dateformat: dd/mm/yyyy\n            result.date = dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n          }\n        }\n      }\n    }\n    if (parts[0].indexOf('.') >= 0) {\n      const dtparts = parts[0].split('.');\n      if (dtparts.length === 3) {\n        if (dateFormat.indexOf('.d.') > -1 || dateFormat.indexOf('.dd.') > -1) {\n          // Dateformat: mm.dd.yyyy\n          result.date = dtparts[2] + '-' + ('0' + dtparts[0]).substr(-2) + '-' + ('0' + dtparts[1]).substr(-2);\n        } else {\n          // Dateformat: dd.mm.yyyy\n          result.date = dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n        }\n      }\n    }\n    if (parts[0].indexOf('-') >= 0) {\n      // Dateformat: yyyy-mm-dd\n      const dtparts = parts[0].split('-');\n      if (dtparts.length === 3) {\n        result.date = dtparts[0] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[2]).substr(-2);\n      }\n    }\n  }\n  if (parts[1]) {\n    parts.shift();\n    let time = parts.join(' ');\n    result.time = parseTime(time, pmDesignator);\n  }\n  return result;\n}\n\nfunction parseHead(head, rights) {\n  let space = (rights > 0);\n  let count = 1;\n  let from = 0;\n  let to = 0;\n  let result = [];\n  for (let i = 0; i < head.length; i++) {\n    if (count <= rights) {\n      // if (head[i] === ' ' && !space) {\n      if (/\\s/.test(head[i]) && !space) {\n        to = i - 1;\n        result.push({\n          from: from,\n          to: to + 1,\n          cap: head.substring(from, to + 1)\n        });\n        from = to + 2;\n        count++;\n      }\n      space = head[i] === ' ';\n    } else {\n      if (!/\\s/.test(head[i]) && space) {\n        to = i - 1;\n        if (from < to) {\n          result.push({\n            from: from,\n            to: to,\n            cap: head.substring(from, to)\n          });\n        }\n        from = to + 1;\n        count++;\n      }\n      space = head[i] === ' ';\n    }\n  }\n  to = 1000;\n  result.push({\n    from: from,\n    to: to,\n    cap: head.substring(from, to)\n  });\n  let len = result.length;\n  for (var i = 0; i < len; i++) {\n    if (result[i].cap.replace(/\\s/g, '').length === 0) {\n      if (i + 1 < len) {\n        result[i].to = result[i + 1].to;\n        result[i].cap = result[i].cap + result[i + 1].cap;\n        result.splice(i + 1, 1);\n        len = len - 1;\n      }\n    }\n  }\n  return result;\n}\n\nfunction findObjectByKey(array, key, value) {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i][key] === value) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction getWmic() {\n  if (os.type() === 'Windows_NT' && !wmicPath) {\n    wmicPath = process.env.WINDIR + '\\\\system32\\\\wbem\\\\wmic.exe';\n    if (!fs.existsSync(wmicPath)) {\n      try {\n        const wmicPathArray = execSync('WHERE WMIC').toString().split('\\r\\n');\n        if (wmicPathArray && wmicPathArray.length) {\n          wmicPath = wmicPathArray[0];\n        } else {\n          wmicPath = 'wmic';\n        }\n      } catch (e) {\n        wmicPath = 'wmic';\n      }\n    }\n  }\n  return wmicPath;\n}\n\nfunction wmic(command, options) {\n  options = options || execOptsWin;\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      try {\n        exec(getWmic() + ' ' + command, options, function (error, stdout) {\n          resolve(stdout, error);\n        }).stdin.end();\n      } catch (e) {\n        resolve('', e);\n      }\n    });\n  });\n}\n\nfunction getVboxmanage() {\n  return _windows ? process.env.VBOX_INSTALL_PATH || process.env.VBOX_MSI_INSTALL_PATH + '\\\\VBoxManage.exe' + '\" ' : 'vboxmanage';\n}\n\nfunction powerShell(cmd) {\n\n  let result = '';\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      try {\n        const child = spawn('powershell.exe', ['-NoLogo', '-InputFormat', 'Text', '-NoExit', '-ExecutionPolicy', 'Unrestricted', '-Command', '-'], {\n          stdio: 'pipe'\n        });\n\n        if (child && !child.pid) {\n          child.on('error', function () {\n            resolve(result);\n          });\n        }\n        if (child && child.pid) {\n          child.stdout.on('data', function (data) {\n            result = result + data.toString('utf8');\n          });\n          child.stderr.on('data', function () {\n            child.kill();\n            resolve(result);\n          });\n          child.on('close', function () {\n            child.kill();\n            resolve(result);\n          });\n          child.on('error', function () {\n            child.kill();\n            resolve(result);\n          });\n          try {\n            child.stdin.write(cmd + os.EOL);\n            child.stdin.write('exit' + os.EOL);\n            child.stdin.end();\n          } catch (e) {\n            child.kill();\n            resolve(result);\n          }\n        } else {\n          resolve(result);\n        }\n      } catch (e) {\n        resolve(result);\n      }\n    });\n  });\n}\n\nfunction getCodepage() {\n  if (_windows) {\n    if (!codepage) {\n      try {\n        const stdout = execSync('chcp');\n        const lines = stdout.toString().split('\\r\\n');\n        const parts = lines[0].split(':');\n        codepage = parts.length > 1 ? parts[1].replace('.', '') : '';\n      } catch (err) {\n        codepage = '437';\n      }\n    }\n    return codepage;\n  }\n  if (_linux || _darwin || _freebsd || _openbsd || _netbsd) {\n    if (!codepage) {\n      try {\n        const stdout = execSync('echo $LANG');\n        const lines = stdout.toString().split('\\r\\n');\n        const parts = lines[0].split('.');\n        codepage = parts.length > 1 ? parts[1].trim() : '';\n        if (!codepage) {\n          codepage = 'UTF-8';\n        }\n      } catch (err) {\n        codepage = 'UTF-8';\n      }\n    }\n    return codepage;\n  }\n}\n\nfunction isRaspberry() {\n  const PI_MODEL_NO = [\n    'BCM2708',\n    'BCM2709',\n    'BCM2710',\n    'BCM2835',\n    'BCM2837B0'\n  ];\n  let cpuinfo = [];\n  try {\n    cpuinfo = fs.readFileSync('/proc/cpuinfo', { encoding: 'utf8' }).split('\\n');\n  } catch (e) {\n    return false;\n  }\n  const hardware = getValue(cpuinfo, 'hardware');\n  return (hardware && PI_MODEL_NO.indexOf(hardware) > -1);\n}\n\nfunction isRaspbian() {\n  let osrelease = [];\n  try {\n    osrelease = fs.readFileSync('/etc/os-release', { encoding: 'utf8' }).split('\\n');\n  } catch (e) {\n    return false;\n  }\n  const id = getValue(osrelease, 'id');\n  return (id && id.indexOf('raspbian') > -1);\n}\n\nfunction execWin(cmd, opts, callback) {\n  if (!callback) {\n    callback = opts;\n    opts = execOptsWin;\n  }\n  let newCmd = 'chcp 65001 > nul && cmd /C ' + cmd + ' && chcp ' + codepage + ' > nul';\n  exec(newCmd, opts, function (error, stdout) {\n    callback(error, stdout);\n  });\n}\n\nfunction darwinXcodeExists() {\n  const cmdLineToolsExists = fs.existsSync('/Library/Developer/CommandLineTools/usr/bin/');\n  const xcodeAppExists = fs.existsSync('/Applications/Xcode.app/Contents/Developer/Tools');\n  const xcodeExists = fs.existsSync('/Library/Developer/Xcode/');\n  return (cmdLineToolsExists || xcodeExists || xcodeAppExists);\n}\n\nfunction nanoSeconds() {\n  const time = process.hrtime();\n  if (!Array.isArray(time) || time.length !== 2) {\n    return 0;\n  }\n  return +time[0] * 1e9 + +time[1];\n}\n\nfunction countUniqueLines(lines, startingWith) {\n  startingWith = startingWith || '';\n  const uniqueLines = [];\n  lines.forEach(line => {\n    if (line.startsWith(startingWith)) {\n      if (uniqueLines.indexOf(line) === -1) {\n        uniqueLines.push(line);\n      }\n    }\n  });\n  return uniqueLines.length;\n}\n\nfunction countLines(lines, startingWith) {\n  startingWith = startingWith || '';\n  const uniqueLines = [];\n  lines.forEach(line => {\n    if (line.startsWith(startingWith)) {\n      uniqueLines.push(line);\n    }\n  });\n  return uniqueLines.length;\n}\n\nfunction sanitizeShellString(str) {\n  let result = str;\n  result = result.replace(/>/g, \"\");\n  result = result.replace(/</g, \"\");\n  result = result.replace(/\\*/g, \"\");\n  result = result.replace(/\\?/g, \"\");\n  result = result.replace(/\\[/g, \"\");\n  result = result.replace(/\\]/g, \"\");\n  result = result.replace(/\\|/g, \"\");\n  result = result.replace(/\\`/g, \"\");\n  result = result.replace(/$/g, \"\");\n  result = result.replace(/;/g, \"\");\n  result = result.replace(/&/g, \"\");\n  result = result.replace(/\\)/g, \"\");\n  result = result.replace(/\\(/g, \"\");\n  result = result.replace(/\\$/g, \"\");\n  result = result.replace(/#/g, \"\");\n  result = result.replace(/\\\\/g, \"\");\n  result = result.replace(/\\t/g, \"\");\n  result = result.replace(/\\n/g, \"\");\n  result = result.replace(/\\\"/g, \"\");\n  return result\n}\n\nfunction noop() { }\n\nexports.toInt = toInt;\nexports.execOptsWin = execOptsWin;\nexports.getCodepage = getCodepage;\nexports.execWin = execWin;\nexports.isFunction = isFunction;\nexports.unique = unique;\nexports.sortByKey = sortByKey;\nexports.cores = cores;\nexports.getValue = getValue;\nexports.decodeEscapeSequence = decodeEscapeSequence;\nexports.parseDateTime = parseDateTime;\nexports.parseHead = parseHead;\nexports.findObjectByKey = findObjectByKey;\nexports.getWmic = getWmic;\nexports.wmic = wmic;\nexports.darwinXcodeExists = darwinXcodeExists;\nexports.getVboxmanage = getVboxmanage;\nexports.powerShell = powerShell;\nexports.nanoSeconds = nanoSeconds;\nexports.countUniqueLines = countUniqueLines;\nexports.countLines = countLines;\nexports.noop = noop;\nexports.isRaspberry = isRaspberry;\nexports.isRaspbian = isRaspbian;\nexports.sanitizeShellString = sanitizeShellString;\n"], "filenames": ["lib/util.js"], "buggy_code_start_loc": [505], "buggy_code_end_loc": [505], "fixing_code_start_loc": [506], "fixing_code_end_loc": [509], "type": "CWE-78", "message": "systeminformation is an npm package that provides system and OS information library for node.js. In systeminformation before version 4.26.2 there is a command injection vulnerability. Problem was fixed in version 4.26.2 with a shell string sanitation fix.", "other": {"cve": {"id": "CVE-2020-26300", "sourceIdentifier": "security-advisories@github.com", "published": "2021-09-09T01:15:06.930", "lastModified": "2022-04-26T15:33:28.443", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "systeminformation is an npm package that provides system and OS information library for node.js. In systeminformation before version 4.26.2 there is a command injection vulnerability. Problem was fixed in version 4.26.2 with a shell string sanitation fix."}, {"lang": "es", "value": "systeminformation es un paquete npm que proporciona una biblioteca de informaci\u00f3n del sistema y del Sistema Operativo para node.js. En systeminformation versiones anteriores a 4.26.2 Se presenta una vulnerabilidad de inyecci\u00f3n de comandos. El problema fue corregido en la versi\u00f3n 4.26.2 con una correcci\u00f3n de la cadena de shell"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:C/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.4, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:systeminformation:systeminformation:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "4.26.2", "matchCriteriaId": "C283FAC7-26F9-43F2-AB4E-C26555994A20"}]}]}], "references": [{"url": "https://github.com/advisories/GHSA-fj59-f6c3-3vw4", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sebhildebrandt/systeminformation/commit/bad372e654cdd549e7d786acbba0035ded54c607", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sebhildebrandt/systeminformation/security/advisories/GHSA-fj59-f6c3-3vw4", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.npmjs.com/package/systeminformation", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sebhildebrandt/systeminformation/commit/bad372e654cdd549e7d786acbba0035ded54c607"}}