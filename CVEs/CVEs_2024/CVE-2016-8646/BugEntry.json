{"buggy_code": ["/*\n * algif_hash: User-space interface for hash algorithms\n *\n * This file provides the user-space API for hash algorithms.\n *\n * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#include <crypto/hash.h>\n#include <crypto/if_alg.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/net.h>\n#include <net/sock.h>\n\nstruct hash_ctx {\n\tstruct af_alg_sgl sgl;\n\n\tu8 *result;\n\n\tstruct af_alg_completion completion;\n\n\tunsigned int len;\n\tbool more;\n\n\tstruct ahash_request req;\n};\n\nstatic int hash_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\tsize_t ignored)\n{\n\tint limit = ALG_MAX_PAGES * PAGE_SIZE;\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tlong copied = 0;\n\tint err;\n\n\tif (limit > sk->sk_sndbuf)\n\t\tlimit = sk->sk_sndbuf;\n\n\tlock_sock(sk);\n\tif (!ctx->more) {\n\t\terr = crypto_ahash_init(&ctx->req);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\tctx->more = 0;\n\n\twhile (msg_data_left(msg)) {\n\t\tint len = msg_data_left(msg);\n\n\t\tif (len > limit)\n\t\t\tlen = limit;\n\n\t\tlen = af_alg_make_sg(&ctx->sgl, &msg->msg_iter, len);\n\t\tif (len < 0) {\n\t\t\terr = copied ? 0 : len;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tahash_request_set_crypt(&ctx->req, ctx->sgl.sg, NULL, len);\n\n\t\terr = af_alg_wait_for_completion(crypto_ahash_update(&ctx->req),\n\t\t\t\t\t\t &ctx->completion);\n\t\taf_alg_free_sg(&ctx->sgl);\n\t\tif (err)\n\t\t\tgoto unlock;\n\n\t\tcopied += len;\n\t\tiov_iter_advance(&msg->msg_iter, len);\n\t}\n\n\terr = 0;\n\n\tctx->more = msg->msg_flags & MSG_MORE;\n\tif (!ctx->more) {\n\t\tahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);\n\t\terr = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),\n\t\t\t\t\t\t &ctx->completion);\n\t}\n\nunlock:\n\trelease_sock(sk);\n\n\treturn err ?: copied;\n}\n\nstatic ssize_t hash_sendpage(struct socket *sock, struct page *page,\n\t\t\t     int offset, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tint err;\n\n\tif (flags & MSG_SENDPAGE_NOTLAST)\n\t\tflags |= MSG_MORE;\n\n\tlock_sock(sk);\n\tsg_init_table(ctx->sgl.sg, 1);\n\tsg_set_page(ctx->sgl.sg, page, size, offset);\n\n\tahash_request_set_crypt(&ctx->req, ctx->sgl.sg, ctx->result, size);\n\n\tif (!(flags & MSG_MORE)) {\n\t\tif (ctx->more)\n\t\t\terr = crypto_ahash_finup(&ctx->req);\n\t\telse\n\t\t\terr = crypto_ahash_digest(&ctx->req);\n\t} else {\n\t\tif (!ctx->more) {\n\t\t\terr = crypto_ahash_init(&ctx->req);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t}\n\n\t\terr = crypto_ahash_update(&ctx->req);\n\t}\n\n\terr = af_alg_wait_for_completion(err, &ctx->completion);\n\tif (err)\n\t\tgoto unlock;\n\n\tctx->more = flags & MSG_MORE;\n\nunlock:\n\trelease_sock(sk);\n\n\treturn err ?: size;\n}\n\nstatic int hash_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t\tint flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tunsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));\n\tint err;\n\n\tif (len > ds)\n\t\tlen = ds;\n\telse if (len < ds)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\tlock_sock(sk);\n\tif (ctx->more) {\n\t\tctx->more = 0;\n\t\tahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);\n\t\terr = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),\n\t\t\t\t\t\t &ctx->completion);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\terr = memcpy_to_msg(msg, ctx->result, len);\n\nunlock:\n\trelease_sock(sk);\n\n\treturn err ?: len;\n}\n\nstatic int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n\tstruct sock *sk2;\n\tstruct alg_sock *ask2;\n\tstruct hash_ctx *ctx2;\n\tint err;\n\n\terr = crypto_ahash_export(req, state);\n\tif (err)\n\t\treturn err;\n\n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n\n\tsk2 = newsock->sk;\n\task2 = alg_sk(sk2);\n\tctx2 = ask2->private;\n\tctx2->more = 1;\n\n\terr = crypto_ahash_import(&ctx2->req, state);\n\tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\n\treturn err;\n}\n\nstatic struct proto_ops algif_hash_ops = {\n\t.family\t\t=\tPF_ALG,\n\n\t.connect\t=\tsock_no_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.getname\t=\tsock_no_getname,\n\t.ioctl\t\t=\tsock_no_ioctl,\n\t.listen\t\t=\tsock_no_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.getsockopt\t=\tsock_no_getsockopt,\n\t.mmap\t\t=\tsock_no_mmap,\n\t.bind\t\t=\tsock_no_bind,\n\t.setsockopt\t=\tsock_no_setsockopt,\n\t.poll\t\t=\tsock_no_poll,\n\n\t.release\t=\taf_alg_release,\n\t.sendmsg\t=\thash_sendmsg,\n\t.sendpage\t=\thash_sendpage,\n\t.recvmsg\t=\thash_recvmsg,\n\t.accept\t\t=\thash_accept,\n};\n\nstatic void *hash_bind(const char *name, u32 type, u32 mask)\n{\n\treturn crypto_alloc_ahash(name, type, mask);\n}\n\nstatic void hash_release(void *private)\n{\n\tcrypto_free_ahash(private);\n}\n\nstatic int hash_setkey(void *private, const u8 *key, unsigned int keylen)\n{\n\treturn crypto_ahash_setkey(private, key, keylen);\n}\n\nstatic void hash_sock_destruct(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\n\tsock_kzfree_s(sk, ctx->result,\n\t\t      crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req)));\n\tsock_kfree_s(sk, ctx, ctx->len);\n\taf_alg_release_parent(sk);\n}\n\nstatic int hash_accept_parent(void *private, struct sock *sk)\n{\n\tstruct hash_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tunsigned len = sizeof(*ctx) + crypto_ahash_reqsize(private);\n\tunsigned ds = crypto_ahash_digestsize(private);\n\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->result = sock_kmalloc(sk, ds, GFP_KERNEL);\n\tif (!ctx->result) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(ctx->result, 0, ds);\n\n\tctx->len = len;\n\tctx->more = 0;\n\taf_alg_init_completion(&ctx->completion);\n\n\task->private = ctx;\n\n\tahash_request_set_tfm(&ctx->req, private);\n\tahash_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t   af_alg_complete, &ctx->completion);\n\n\tsk->sk_destruct = hash_sock_destruct;\n\n\treturn 0;\n}\n\nstatic const struct af_alg_type algif_type_hash = {\n\t.bind\t\t=\thash_bind,\n\t.release\t=\thash_release,\n\t.setkey\t\t=\thash_setkey,\n\t.accept\t\t=\thash_accept_parent,\n\t.ops\t\t=\t&algif_hash_ops,\n\t.name\t\t=\t\"hash\",\n\t.owner\t\t=\tTHIS_MODULE\n};\n\nstatic int __init algif_hash_init(void)\n{\n\treturn af_alg_register_type(&algif_type_hash);\n}\n\nstatic void __exit algif_hash_exit(void)\n{\n\tint err = af_alg_unregister_type(&algif_type_hash);\n\tBUG_ON(err);\n}\n\nmodule_init(algif_hash_init);\nmodule_exit(algif_hash_exit);\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["/*\n * algif_hash: User-space interface for hash algorithms\n *\n * This file provides the user-space API for hash algorithms.\n *\n * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#include <crypto/hash.h>\n#include <crypto/if_alg.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/net.h>\n#include <net/sock.h>\n\nstruct hash_ctx {\n\tstruct af_alg_sgl sgl;\n\n\tu8 *result;\n\n\tstruct af_alg_completion completion;\n\n\tunsigned int len;\n\tbool more;\n\n\tstruct ahash_request req;\n};\n\nstatic int hash_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\tsize_t ignored)\n{\n\tint limit = ALG_MAX_PAGES * PAGE_SIZE;\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tlong copied = 0;\n\tint err;\n\n\tif (limit > sk->sk_sndbuf)\n\t\tlimit = sk->sk_sndbuf;\n\n\tlock_sock(sk);\n\tif (!ctx->more) {\n\t\terr = crypto_ahash_init(&ctx->req);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\tctx->more = 0;\n\n\twhile (msg_data_left(msg)) {\n\t\tint len = msg_data_left(msg);\n\n\t\tif (len > limit)\n\t\t\tlen = limit;\n\n\t\tlen = af_alg_make_sg(&ctx->sgl, &msg->msg_iter, len);\n\t\tif (len < 0) {\n\t\t\terr = copied ? 0 : len;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tahash_request_set_crypt(&ctx->req, ctx->sgl.sg, NULL, len);\n\n\t\terr = af_alg_wait_for_completion(crypto_ahash_update(&ctx->req),\n\t\t\t\t\t\t &ctx->completion);\n\t\taf_alg_free_sg(&ctx->sgl);\n\t\tif (err)\n\t\t\tgoto unlock;\n\n\t\tcopied += len;\n\t\tiov_iter_advance(&msg->msg_iter, len);\n\t}\n\n\terr = 0;\n\n\tctx->more = msg->msg_flags & MSG_MORE;\n\tif (!ctx->more) {\n\t\tahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);\n\t\terr = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),\n\t\t\t\t\t\t &ctx->completion);\n\t}\n\nunlock:\n\trelease_sock(sk);\n\n\treturn err ?: copied;\n}\n\nstatic ssize_t hash_sendpage(struct socket *sock, struct page *page,\n\t\t\t     int offset, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tint err;\n\n\tif (flags & MSG_SENDPAGE_NOTLAST)\n\t\tflags |= MSG_MORE;\n\n\tlock_sock(sk);\n\tsg_init_table(ctx->sgl.sg, 1);\n\tsg_set_page(ctx->sgl.sg, page, size, offset);\n\n\tahash_request_set_crypt(&ctx->req, ctx->sgl.sg, ctx->result, size);\n\n\tif (!(flags & MSG_MORE)) {\n\t\tif (ctx->more)\n\t\t\terr = crypto_ahash_finup(&ctx->req);\n\t\telse\n\t\t\terr = crypto_ahash_digest(&ctx->req);\n\t} else {\n\t\tif (!ctx->more) {\n\t\t\terr = crypto_ahash_init(&ctx->req);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t}\n\n\t\terr = crypto_ahash_update(&ctx->req);\n\t}\n\n\terr = af_alg_wait_for_completion(err, &ctx->completion);\n\tif (err)\n\t\tgoto unlock;\n\n\tctx->more = flags & MSG_MORE;\n\nunlock:\n\trelease_sock(sk);\n\n\treturn err ?: size;\n}\n\nstatic int hash_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t\tint flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tunsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));\n\tint err;\n\n\tif (len > ds)\n\t\tlen = ds;\n\telse if (len < ds)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\tlock_sock(sk);\n\tif (ctx->more) {\n\t\tctx->more = 0;\n\t\tahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);\n\t\terr = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),\n\t\t\t\t\t\t &ctx->completion);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\terr = memcpy_to_msg(msg, ctx->result, len);\n\nunlock:\n\trelease_sock(sk);\n\n\treturn err ?: len;\n}\n\nstatic int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n\tstruct sock *sk2;\n\tstruct alg_sock *ask2;\n\tstruct hash_ctx *ctx2;\n\tbool more;\n\tint err;\n\n\tlock_sock(sk);\n\tmore = ctx->more;\n\terr = more ? crypto_ahash_export(req, state) : 0;\n\trelease_sock(sk);\n\n\tif (err)\n\t\treturn err;\n\n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n\n\tsk2 = newsock->sk;\n\task2 = alg_sk(sk2);\n\tctx2 = ask2->private;\n\tctx2->more = more;\n\n\tif (!more)\n\t\treturn err;\n\n\terr = crypto_ahash_import(&ctx2->req, state);\n\tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\n\treturn err;\n}\n\nstatic struct proto_ops algif_hash_ops = {\n\t.family\t\t=\tPF_ALG,\n\n\t.connect\t=\tsock_no_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.getname\t=\tsock_no_getname,\n\t.ioctl\t\t=\tsock_no_ioctl,\n\t.listen\t\t=\tsock_no_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.getsockopt\t=\tsock_no_getsockopt,\n\t.mmap\t\t=\tsock_no_mmap,\n\t.bind\t\t=\tsock_no_bind,\n\t.setsockopt\t=\tsock_no_setsockopt,\n\t.poll\t\t=\tsock_no_poll,\n\n\t.release\t=\taf_alg_release,\n\t.sendmsg\t=\thash_sendmsg,\n\t.sendpage\t=\thash_sendpage,\n\t.recvmsg\t=\thash_recvmsg,\n\t.accept\t\t=\thash_accept,\n};\n\nstatic void *hash_bind(const char *name, u32 type, u32 mask)\n{\n\treturn crypto_alloc_ahash(name, type, mask);\n}\n\nstatic void hash_release(void *private)\n{\n\tcrypto_free_ahash(private);\n}\n\nstatic int hash_setkey(void *private, const u8 *key, unsigned int keylen)\n{\n\treturn crypto_ahash_setkey(private, key, keylen);\n}\n\nstatic void hash_sock_destruct(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\n\tsock_kzfree_s(sk, ctx->result,\n\t\t      crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req)));\n\tsock_kfree_s(sk, ctx, ctx->len);\n\taf_alg_release_parent(sk);\n}\n\nstatic int hash_accept_parent(void *private, struct sock *sk)\n{\n\tstruct hash_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tunsigned len = sizeof(*ctx) + crypto_ahash_reqsize(private);\n\tunsigned ds = crypto_ahash_digestsize(private);\n\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->result = sock_kmalloc(sk, ds, GFP_KERNEL);\n\tif (!ctx->result) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(ctx->result, 0, ds);\n\n\tctx->len = len;\n\tctx->more = 0;\n\taf_alg_init_completion(&ctx->completion);\n\n\task->private = ctx;\n\n\tahash_request_set_tfm(&ctx->req, private);\n\tahash_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t   af_alg_complete, &ctx->completion);\n\n\tsk->sk_destruct = hash_sock_destruct;\n\n\treturn 0;\n}\n\nstatic const struct af_alg_type algif_type_hash = {\n\t.bind\t\t=\thash_bind,\n\t.release\t=\thash_release,\n\t.setkey\t\t=\thash_setkey,\n\t.accept\t\t=\thash_accept_parent,\n\t.ops\t\t=\t&algif_hash_ops,\n\t.name\t\t=\t\"hash\",\n\t.owner\t\t=\tTHIS_MODULE\n};\n\nstatic int __init algif_hash_init(void)\n{\n\treturn af_alg_register_type(&algif_type_hash);\n}\n\nstatic void __exit algif_hash_exit(void)\n{\n\tint err = af_alg_unregister_type(&algif_type_hash);\n\tBUG_ON(err);\n}\n\nmodule_init(algif_hash_init);\nmodule_exit(algif_hash_exit);\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["crypto/algif_hash.c"], "buggy_code_start_loc": [183], "buggy_code_end_loc": [198], "fixing_code_start_loc": [184], "fixing_code_end_loc": [206], "type": "CWE-476", "message": "The hash_accept function in crypto/algif_hash.c in the Linux kernel before 4.3.6 allows local users to cause a denial of service (OOPS) by attempting to trigger use of in-kernel hash algorithms for a socket that has received zero bytes of data.", "other": {"cve": {"id": "CVE-2016-8646", "sourceIdentifier": "secalert@redhat.com", "published": "2016-11-28T03:59:08.907", "lastModified": "2023-02-12T23:26:17.017", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The hash_accept function in crypto/algif_hash.c in the Linux kernel before 4.3.6 allows local users to cause a denial of service (OOPS) by attempting to trigger use of in-kernel hash algorithms for a socket that has received zero bytes of data."}, {"lang": "es", "value": "La funci\u00f3n hash_accept en crypto/algif_hash.c en el kernel Linux en versiones anteriores a 4.3.6 permite a usuarios locales provocar una denegaci\u00f3n de servicio (OOPS) intentando desencadenar el uso de algoritmos hash in-kernel para un enchufe que ha recibido cero bytes de datos."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.3.5", "matchCriteriaId": "E5BF9CD8-D36A-4452-9E07-9728C7CCD2AB"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=4afa5f9617927453ac04b24b584f6c718dfb4f45", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.3.6", "source": "secalert@redhat.com", "tags": ["Release Notes"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/11/15/2", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/94309", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2017:1297", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2017:1298", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2017:1308", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1388821", "source": "secalert@redhat.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/4afa5f9617927453ac04b24b584f6c718dfb4f45", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/4afa5f9617927453ac04b24b584f6c718dfb4f45"}}