{"buggy_code": ["/**\n * WinPR: Windows Portable Runtime\n * NTLM Security Package (AV_PAIRs)\n *\n * Copyright 2011-2014 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <assert.h>\n\n#include \"ntlm.h\"\n#include \"../sspi.h\"\n\n#include <winpr/crt.h>\n#include <winpr/print.h>\n#include <winpr/sysinfo.h>\n#include <winpr/tchar.h>\n#include <winpr/crypto.h>\n\n#include \"ntlm_compute.h\"\n\n#include \"ntlm_av_pairs.h\"\n\n#include \"../../log.h\"\n#define TAG WINPR_TAG(\"sspi.NTLM\")\n\nstatic const char* const AV_PAIR_STRINGS[] = {\n\t\"MsvAvEOL\",           \"MsvAvNbComputerName\", \"MsvAvNbDomainName\", \"MsvAvDnsComputerName\",\n\t\"MsvAvDnsDomainName\", \"MsvAvDnsTreeName\",    \"MsvAvFlags\",        \"MsvAvTimestamp\",\n\t\"MsvAvRestrictions\",  \"MsvAvTargetName\",     \"MsvChannelBindings\"\n};\n\nstatic BOOL ntlm_av_pair_check(NTLM_AV_PAIR* pAvPair, size_t cbAvPair);\nstatic NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPairList, size_t* pcbAvPairList);\n\nstatic INLINE void ntlm_av_pair_set_id(NTLM_AV_PAIR* pAvPair, UINT16 id)\n{\n\tData_Write_UINT16(&pAvPair->AvId, id);\n}\n\nstatic INLINE void ntlm_av_pair_set_len(NTLM_AV_PAIR* pAvPair, UINT16 len)\n{\n\tData_Write_UINT16(&pAvPair->AvLen, len);\n}\n\nstatic BOOL ntlm_av_pair_list_init(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList)\n{\n\tNTLM_AV_PAIR* pAvPair = pAvPairList;\n\n\tif (!pAvPair || (cbAvPairList < sizeof(NTLM_AV_PAIR)))\n\t\treturn FALSE;\n\n\tntlm_av_pair_set_id(pAvPair, MsvAvEOL);\n\tntlm_av_pair_set_len(pAvPair, 0);\n\treturn TRUE;\n}\n\nstatic INLINE UINT16 ntlm_av_pair_get_id(const NTLM_AV_PAIR* pAvPair)\n{\n\tUINT16 AvId;\n\n\tData_Read_UINT16(&pAvPair->AvId, AvId);\n\n\treturn AvId;\n}\n\nULONG ntlm_av_pair_list_length(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList)\n{\n\tsize_t cbAvPair;\n\tNTLM_AV_PAIR* pAvPair;\n\n\tpAvPair = ntlm_av_pair_get(pAvPairList, cbAvPairList, MsvAvEOL, &cbAvPair);\n\tif (!pAvPair)\n\t\treturn 0;\n\n\treturn ((PBYTE)pAvPair - (PBYTE)pAvPairList) + sizeof(NTLM_AV_PAIR);\n}\n\nstatic INLINE SIZE_T ntlm_av_pair_get_len(const NTLM_AV_PAIR* pAvPair)\n{\n\tUINT16 AvLen;\n\n\tData_Read_UINT16(&pAvPair->AvLen, AvLen);\n\n\treturn AvLen;\n}\n\nvoid ntlm_print_av_pair_list(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList)\n{\n\tsize_t cbAvPair = cbAvPairList;\n\tNTLM_AV_PAIR* pAvPair = pAvPairList;\n\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\treturn;\n\n\tWLog_INFO(TAG, \"AV_PAIRs =\");\n\n\twhile (pAvPair && ntlm_av_pair_get_id(pAvPair) != MsvAvEOL)\n\t{\n\t\tWLog_INFO(TAG, \"\\t%s AvId: %\" PRIu16 \" AvLen: %\" PRIu16 \"\",\n\t\t          AV_PAIR_STRINGS[ntlm_av_pair_get_id(pAvPair)], ntlm_av_pair_get_id(pAvPair),\n\t\t          ntlm_av_pair_get_len(pAvPair));\n\t\twinpr_HexDump(TAG, WLOG_INFO, ntlm_av_pair_get_value_pointer(pAvPair),\n\t\t              ntlm_av_pair_get_len(pAvPair));\n\n\t\tpAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);\n\t}\n}\n\nstatic ULONG ntlm_av_pair_list_size(ULONG AvPairsCount, ULONG AvPairsValueLength)\n{\n\t/* size of headers + value lengths + terminating MsvAvEOL AV_PAIR */\n\treturn ((AvPairsCount + 1) * 4) + AvPairsValueLength;\n}\n\nPBYTE ntlm_av_pair_get_value_pointer(NTLM_AV_PAIR* pAvPair)\n{\n\treturn (PBYTE)pAvPair + sizeof(NTLM_AV_PAIR);\n}\n\nstatic size_t ntlm_av_pair_get_next_offset(NTLM_AV_PAIR* pAvPair)\n{\n\treturn ntlm_av_pair_get_len(pAvPair) + sizeof(NTLM_AV_PAIR);\n}\n\nstatic BOOL ntlm_av_pair_check(NTLM_AV_PAIR* pAvPair, size_t cbAvPair)\n{\n\tif (!pAvPair || cbAvPair < sizeof(NTLM_AV_PAIR))\n\t\treturn FALSE;\n\treturn cbAvPair >= ntlm_av_pair_get_next_offset(pAvPair);\n}\n\nstatic NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPair, size_t* pcbAvPair)\n{\n\tsize_t offset;\n\n\tif (!pcbAvPair)\n\t\treturn NULL;\n\tif (!ntlm_av_pair_check(pAvPair, *pcbAvPair))\n\t\treturn NULL;\n\n\toffset = ntlm_av_pair_get_next_offset(pAvPair);\n\t*pcbAvPair -= offset;\n\treturn (NTLM_AV_PAIR*)((PBYTE)pAvPair + offset);\n}\n\nNTLM_AV_PAIR* ntlm_av_pair_get(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId,\n                               size_t* pcbAvPairListRemaining)\n{\n\tsize_t cbAvPair = cbAvPairList;\n\tNTLM_AV_PAIR* pAvPair = pAvPairList;\n\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\tpAvPair = NULL;\n\n\twhile (pAvPair)\n\t{\n\t\tUINT16 id = ntlm_av_pair_get_id(pAvPair);\n\n\t\tif (id == AvId)\n\t\t\tbreak;\n\t\tif (id == MsvAvEOL)\n\t\t{\n\t\t\tpAvPair = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);\n\t}\n\n\tif (!pAvPair)\n\t\tcbAvPair = 0;\n\tif (pcbAvPairListRemaining)\n\t\t*pcbAvPairListRemaining = cbAvPair;\n\n\treturn pAvPair;\n}\n\nstatic BOOL ntlm_av_pair_add(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId,\n                             PBYTE Value, UINT16 AvLen)\n{\n\tsize_t cbAvPair;\n\tNTLM_AV_PAIR* pAvPair;\n\n\tpAvPair = ntlm_av_pair_get(pAvPairList, cbAvPairList, MsvAvEOL, &cbAvPair);\n\n\t/* size of header + value length + terminating MsvAvEOL AV_PAIR */\n\tif (!pAvPair || cbAvPair < 2 * sizeof(NTLM_AV_PAIR) + AvLen)\n\t\treturn FALSE;\n\n\tntlm_av_pair_set_id(pAvPair, AvId);\n\tntlm_av_pair_set_len(pAvPair, AvLen);\n\tif (AvLen)\n\t{\n\t\tassert(Value != NULL);\n\t\tCopyMemory(ntlm_av_pair_get_value_pointer(pAvPair), Value, AvLen);\n\t}\n\n\tpAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);\n\treturn ntlm_av_pair_list_init(pAvPair, cbAvPair);\n}\n\nstatic BOOL ntlm_av_pair_add_copy(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList,\n                                  NTLM_AV_PAIR* pAvPair, size_t cbAvPair)\n{\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\treturn FALSE;\n\n\treturn ntlm_av_pair_add(pAvPairList, cbAvPairList, ntlm_av_pair_get_id(pAvPair),\n\t                        ntlm_av_pair_get_value_pointer(pAvPair), ntlm_av_pair_get_len(pAvPair));\n}\n\nstatic int ntlm_get_target_computer_name(PUNICODE_STRING pName, COMPUTER_NAME_FORMAT type)\n{\n\tchar* name;\n\tint status;\n\tDWORD nSize = 0;\n\tCHAR* computerName;\n\n\tif (GetComputerNameExA(ComputerNameNetBIOS, NULL, &nSize) || GetLastError() != ERROR_MORE_DATA)\n\t\treturn -1;\n\n\tcomputerName = calloc(nSize, sizeof(CHAR));\n\n\tif (!computerName)\n\t\treturn -1;\n\n\tif (!GetComputerNameExA(ComputerNameNetBIOS, computerName, &nSize))\n\t{\n\t\tfree(computerName);\n\t\treturn -1;\n\t}\n\n\tif (nSize > MAX_COMPUTERNAME_LENGTH)\n\t\tcomputerName[MAX_COMPUTERNAME_LENGTH] = '\\0';\n\n\tname = computerName;\n\n\tif (!name)\n\t\treturn -1;\n\n\tif (type == ComputerNameNetBIOS)\n\t\tCharUpperA(name);\n\n\tstatus = ConvertToUnicode(CP_UTF8, 0, name, -1, &pName->Buffer, 0);\n\n\tif (status <= 0)\n\t{\n\t\tfree(name);\n\t\treturn status;\n\t}\n\n\tpName->Length = (USHORT)((status - 1) * 2);\n\tpName->MaximumLength = pName->Length;\n\tfree(name);\n\treturn 1;\n}\n\nstatic void ntlm_free_unicode_string(PUNICODE_STRING string)\n{\n\tif (string)\n\t{\n\t\tif (string->Length > 0)\n\t\t{\n\t\t\tfree(string->Buffer);\n\t\t\tstring->Buffer = NULL;\n\t\t\tstring->Length = 0;\n\t\t\tstring->MaximumLength = 0;\n\t\t}\n\t}\n}\n\n/**\n * From http://www.ietf.org/proceedings/72/slides/sasl-2.pdf:\n *\n * tls-server-end-point:\n *\n * The hash of the TLS server's end entity certificate as it appears, octet for octet,\n * in the server's Certificate message (note that the Certificate message contains a\n * certificate_list, the first element of which is the server's end entity certificate.)\n * The hash function to be selected is as follows: if the certificate's signature hash\n * algorithm is either MD5 or SHA-1, then use SHA-256, otherwise use the certificate's\n * signature hash algorithm.\n */\n\n/**\n * Channel Bindings sample usage:\n * https://raw.github.com/mozilla/mozilla-central/master/extensions/auth/nsAuthSSPI.cpp\n */\n\n/*\ntypedef struct gss_channel_bindings_struct {\n    OM_uint32 initiator_addrtype;\n    gss_buffer_desc initiator_address;\n    OM_uint32 acceptor_addrtype;\n    gss_buffer_desc acceptor_address;\n    gss_buffer_desc application_data;\n} *gss_channel_bindings_t;\n */\n\nstatic BOOL ntlm_md5_update_uint32_be(WINPR_DIGEST_CTX* md5, UINT32 num)\n{\n\tBYTE be32[4];\n\tbe32[0] = (num >> 0) & 0xFF;\n\tbe32[1] = (num >> 8) & 0xFF;\n\tbe32[2] = (num >> 16) & 0xFF;\n\tbe32[3] = (num >> 24) & 0xFF;\n\treturn winpr_Digest_Update(md5, be32, 4);\n}\n\nstatic void ntlm_compute_channel_bindings(NTLM_CONTEXT* context)\n{\n\tWINPR_DIGEST_CTX* md5;\n\tBYTE* ChannelBindingToken;\n\tUINT32 ChannelBindingTokenLength;\n\tSEC_CHANNEL_BINDINGS* ChannelBindings;\n\tZeroMemory(context->ChannelBindingsHash, WINPR_MD5_DIGEST_LENGTH);\n\tChannelBindings = context->Bindings.Bindings;\n\n\tif (!ChannelBindings)\n\t\treturn;\n\n\tif (!(md5 = winpr_Digest_New()))\n\t\treturn;\n\n\tif (!winpr_Digest_Init(md5, WINPR_MD_MD5))\n\t\tgoto out;\n\n\tChannelBindingTokenLength = context->Bindings.BindingsLength - sizeof(SEC_CHANNEL_BINDINGS);\n\tChannelBindingToken = &((BYTE*)ChannelBindings)[ChannelBindings->dwApplicationDataOffset];\n\n\tif (!ntlm_md5_update_uint32_be(md5, ChannelBindings->dwInitiatorAddrType))\n\t\tgoto out;\n\n\tif (!ntlm_md5_update_uint32_be(md5, ChannelBindings->cbInitiatorLength))\n\t\tgoto out;\n\n\tif (!ntlm_md5_update_uint32_be(md5, ChannelBindings->dwAcceptorAddrType))\n\t\tgoto out;\n\n\tif (!ntlm_md5_update_uint32_be(md5, ChannelBindings->cbAcceptorLength))\n\t\tgoto out;\n\n\tif (!ntlm_md5_update_uint32_be(md5, ChannelBindings->cbApplicationDataLength))\n\t\tgoto out;\n\n\tif (!winpr_Digest_Update(md5, (void*)ChannelBindingToken, ChannelBindingTokenLength))\n\t\tgoto out;\n\n\tif (!winpr_Digest_Final(md5, context->ChannelBindingsHash, WINPR_MD5_DIGEST_LENGTH))\n\t\tgoto out;\n\nout:\n\twinpr_Digest_Free(md5);\n}\n\nstatic void ntlm_compute_single_host_data(NTLM_CONTEXT* context)\n{\n\t/**\n\t * The Single_Host_Data structure allows a client to send machine-specific information\n\t * within an authentication exchange to services on the same machine. The client can\n\t * produce additional information to be processed in an implementation-specific way when\n\t * the client and server are on the same host. If the server and client platforms are\n\t * different or if they are on different hosts, then the information MUST be ignored.\n\t * Any fields after the MachineID field MUST be ignored on receipt.\n\t */\n\tData_Write_UINT32(&context->SingleHostData.Size, 48);\n\tData_Write_UINT32(&context->SingleHostData.Z4, 0);\n\tData_Write_UINT32(&context->SingleHostData.DataPresent, 1);\n\tData_Write_UINT32(&context->SingleHostData.CustomData, SECURITY_MANDATORY_MEDIUM_RID);\n\tFillMemory(context->SingleHostData.MachineID, 32, 0xAA);\n}\n\nint ntlm_construct_challenge_target_info(NTLM_CONTEXT* context)\n{\n\tint rc = -1;\n\tint length;\n\tULONG AvPairsCount;\n\tULONG AvPairsLength;\n\tNTLM_AV_PAIR* pAvPairList;\n\tsize_t cbAvPairList;\n\tUNICODE_STRING NbDomainName = { 0 };\n\tUNICODE_STRING NbComputerName = { 0 };\n\tUNICODE_STRING DnsDomainName = { 0 };\n\tUNICODE_STRING DnsComputerName = { 0 };\n\n\tif (ntlm_get_target_computer_name(&NbDomainName, ComputerNameNetBIOS) < 0)\n\t\tgoto fail;\n\n\tNbComputerName.Buffer = NULL;\n\n\tif (ntlm_get_target_computer_name(&NbComputerName, ComputerNameNetBIOS) < 0)\n\t\tgoto fail;\n\n\tDnsDomainName.Buffer = NULL;\n\n\tif (ntlm_get_target_computer_name(&DnsDomainName, ComputerNameDnsDomain) < 0)\n\t\tgoto fail;\n\n\tDnsComputerName.Buffer = NULL;\n\n\tif (ntlm_get_target_computer_name(&DnsComputerName, ComputerNameDnsHostname) < 0)\n\t\tgoto fail;\n\n\tAvPairsCount = 5;\n\tAvPairsLength = NbDomainName.Length + NbComputerName.Length + DnsDomainName.Length +\n\t                DnsComputerName.Length + 8;\n\tlength = ntlm_av_pair_list_size(AvPairsCount, AvPairsLength);\n\n\tif (!sspi_SecBufferAlloc(&context->ChallengeTargetInfo, length))\n\t\tgoto fail;\n\n\tpAvPairList = (NTLM_AV_PAIR*)context->ChallengeTargetInfo.pvBuffer;\n\tcbAvPairList = context->ChallengeTargetInfo.cbBuffer;\n\n\tif (!ntlm_av_pair_list_init(pAvPairList, cbAvPairList))\n\t\tgoto fail;\n\n\tif (!ntlm_av_pair_add(pAvPairList, cbAvPairList, MsvAvNbDomainName, (PBYTE)NbDomainName.Buffer,\n\t                      NbDomainName.Length))\n\t\tgoto fail;\n\n\tif (!ntlm_av_pair_add(pAvPairList, cbAvPairList, MsvAvNbComputerName,\n\t                      (PBYTE)NbComputerName.Buffer, NbComputerName.Length))\n\t\tgoto fail;\n\n\tif (!ntlm_av_pair_add(pAvPairList, cbAvPairList, MsvAvDnsDomainName,\n\t                      (PBYTE)DnsDomainName.Buffer, DnsDomainName.Length))\n\t\tgoto fail;\n\n\tif (!ntlm_av_pair_add(pAvPairList, cbAvPairList, MsvAvDnsComputerName,\n\t                      (PBYTE)DnsComputerName.Buffer, DnsComputerName.Length))\n\t\tgoto fail;\n\n\tif (!ntlm_av_pair_add(pAvPairList, cbAvPairList, MsvAvTimestamp, context->Timestamp,\n\t                      sizeof(context->Timestamp)))\n\t\tgoto fail;\n\n\trc = 1;\nfail:\n\tntlm_free_unicode_string(&NbDomainName);\n\tntlm_free_unicode_string(&NbComputerName);\n\tntlm_free_unicode_string(&DnsDomainName);\n\tntlm_free_unicode_string(&DnsComputerName);\n\treturn rc;\n}\n\nint ntlm_construct_authenticate_target_info(NTLM_CONTEXT* context)\n{\n\tULONG size;\n\tULONG AvPairsCount;\n\tULONG AvPairsValueLength;\n\tNTLM_AV_PAIR* AvTimestamp;\n\tNTLM_AV_PAIR* AvNbDomainName;\n\tNTLM_AV_PAIR* AvNbComputerName;\n\tNTLM_AV_PAIR* AvDnsDomainName;\n\tNTLM_AV_PAIR* AvDnsComputerName;\n\tNTLM_AV_PAIR* AvDnsTreeName;\n\tNTLM_AV_PAIR* ChallengeTargetInfo;\n\tNTLM_AV_PAIR* AuthenticateTargetInfo;\n\tsize_t cbAvTimestamp;\n\tsize_t cbAvNbDomainName;\n\tsize_t cbAvNbComputerName;\n\tsize_t cbAvDnsDomainName;\n\tsize_t cbAvDnsComputerName;\n\tsize_t cbAvDnsTreeName;\n\tsize_t cbChallengeTargetInfo;\n\tsize_t cbAuthenticateTargetInfo;\n\tAvPairsCount = 1;\n\tAvPairsValueLength = 0;\n\tChallengeTargetInfo = (NTLM_AV_PAIR*)context->ChallengeTargetInfo.pvBuffer;\n\tcbChallengeTargetInfo = context->ChallengeTargetInfo.cbBuffer;\n\tAvNbDomainName = ntlm_av_pair_get(ChallengeTargetInfo, cbChallengeTargetInfo, MsvAvNbDomainName,\n\t                                  &cbAvNbDomainName);\n\tAvNbComputerName = ntlm_av_pair_get(ChallengeTargetInfo, cbChallengeTargetInfo,\n\t                                    MsvAvNbComputerName, &cbAvNbComputerName);\n\tAvDnsDomainName = ntlm_av_pair_get(ChallengeTargetInfo, cbChallengeTargetInfo,\n\t                                   MsvAvDnsDomainName, &cbAvDnsDomainName);\n\tAvDnsComputerName = ntlm_av_pair_get(ChallengeTargetInfo, cbChallengeTargetInfo,\n\t                                     MsvAvDnsComputerName, &cbAvDnsComputerName);\n\tAvDnsTreeName = ntlm_av_pair_get(ChallengeTargetInfo, cbChallengeTargetInfo, MsvAvDnsTreeName,\n\t                                 &cbAvDnsTreeName);\n\tAvTimestamp = ntlm_av_pair_get(ChallengeTargetInfo, cbChallengeTargetInfo, MsvAvTimestamp,\n\t                               &cbAvTimestamp);\n\n\tif (AvNbDomainName)\n\t{\n\t\tAvPairsCount++; /* MsvAvNbDomainName */\n\t\tAvPairsValueLength += ntlm_av_pair_get_len(AvNbDomainName);\n\t}\n\n\tif (AvNbComputerName)\n\t{\n\t\tAvPairsCount++; /* MsvAvNbComputerName */\n\t\tAvPairsValueLength += ntlm_av_pair_get_len(AvNbComputerName);\n\t}\n\n\tif (AvDnsDomainName)\n\t{\n\t\tAvPairsCount++; /* MsvAvDnsDomainName */\n\t\tAvPairsValueLength += ntlm_av_pair_get_len(AvDnsDomainName);\n\t}\n\n\tif (AvDnsComputerName)\n\t{\n\t\tAvPairsCount++; /* MsvAvDnsComputerName */\n\t\tAvPairsValueLength += ntlm_av_pair_get_len(AvDnsComputerName);\n\t}\n\n\tif (AvDnsTreeName)\n\t{\n\t\tAvPairsCount++; /* MsvAvDnsTreeName */\n\t\tAvPairsValueLength += ntlm_av_pair_get_len(AvDnsTreeName);\n\t}\n\n\tAvPairsCount++; /* MsvAvTimestamp */\n\tAvPairsValueLength += 8;\n\n\tif (context->UseMIC)\n\t{\n\t\tAvPairsCount++; /* MsvAvFlags */\n\t\tAvPairsValueLength += 4;\n\t}\n\n\tif (context->SendSingleHostData)\n\t{\n\t\tAvPairsCount++; /* MsvAvSingleHost */\n\t\tntlm_compute_single_host_data(context);\n\t\tAvPairsValueLength += context->SingleHostData.Size;\n\t}\n\n\t/**\n\t * Extended Protection for Authentication:\n\t * http://blogs.technet.com/b/srd/archive/2009/12/08/extended-protection-for-authentication.aspx\n\t */\n\n\tif (!context->SuppressExtendedProtection)\n\t{\n\t\t/**\n\t\t * SEC_CHANNEL_BINDINGS structure\n\t\t * http://msdn.microsoft.com/en-us/library/windows/desktop/dd919963/\n\t\t */\n\t\tAvPairsCount++; /* MsvChannelBindings */\n\t\tAvPairsValueLength += 16;\n\t\tntlm_compute_channel_bindings(context);\n\n\t\tif (context->ServicePrincipalName.Length > 0)\n\t\t{\n\t\t\tAvPairsCount++; /* MsvAvTargetName */\n\t\t\tAvPairsValueLength += context->ServicePrincipalName.Length;\n\t\t}\n\t}\n\n\tsize = ntlm_av_pair_list_size(AvPairsCount, AvPairsValueLength);\n\n\tif (context->NTLMv2)\n\t\tsize += 8; /* unknown 8-byte padding */\n\n\tif (!sspi_SecBufferAlloc(&context->AuthenticateTargetInfo, size))\n\t\tgoto fail;\n\n\tAuthenticateTargetInfo = (NTLM_AV_PAIR*)context->AuthenticateTargetInfo.pvBuffer;\n\tcbAuthenticateTargetInfo = context->AuthenticateTargetInfo.cbBuffer;\n\n\tif (!ntlm_av_pair_list_init(AuthenticateTargetInfo, cbAuthenticateTargetInfo))\n\t\tgoto fail;\n\n\tif (AvNbDomainName)\n\t{\n\t\tif (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo, AvNbDomainName,\n\t\t                           cbAvNbDomainName))\n\t\t\tgoto fail;\n\t}\n\n\tif (AvNbComputerName)\n\t{\n\t\tif (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo,\n\t\t                           AvNbComputerName, cbAvNbComputerName))\n\t\t\tgoto fail;\n\t}\n\n\tif (AvDnsDomainName)\n\t{\n\t\tif (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo,\n\t\t                           AvDnsDomainName, cbAvDnsDomainName))\n\t\t\tgoto fail;\n\t}\n\n\tif (AvDnsComputerName)\n\t{\n\t\tif (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo,\n\t\t                           AvDnsComputerName, cbAvDnsComputerName))\n\t\t\tgoto fail;\n\t}\n\n\tif (AvDnsTreeName)\n\t{\n\t\tif (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo, AvDnsTreeName,\n\t\t                           cbAvDnsTreeName))\n\t\t\tgoto fail;\n\t}\n\n\tif (AvTimestamp)\n\t{\n\t\tif (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo, AvTimestamp,\n\t\t                           cbAvTimestamp))\n\t\t\tgoto fail;\n\t}\n\n\tif (context->UseMIC)\n\t{\n\t\tUINT32 flags;\n\t\tData_Write_UINT32(&flags, MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK);\n\n\t\tif (!ntlm_av_pair_add(AuthenticateTargetInfo, cbAuthenticateTargetInfo, MsvAvFlags,\n\t\t                      (PBYTE)&flags, 4))\n\t\t\tgoto fail;\n\t}\n\n\tif (context->SendSingleHostData)\n\t{\n\t\tif (!ntlm_av_pair_add(AuthenticateTargetInfo, cbAuthenticateTargetInfo, MsvAvSingleHost,\n\t\t                      (PBYTE)&context->SingleHostData, context->SingleHostData.Size))\n\t\t\tgoto fail;\n\t}\n\n\tif (!context->SuppressExtendedProtection)\n\t{\n\t\tif (!ntlm_av_pair_add(AuthenticateTargetInfo, cbAuthenticateTargetInfo, MsvChannelBindings,\n\t\t                      context->ChannelBindingsHash, 16))\n\t\t\tgoto fail;\n\n\t\tif (context->ServicePrincipalName.Length > 0)\n\t\t{\n\t\t\tif (!ntlm_av_pair_add(AuthenticateTargetInfo, cbAuthenticateTargetInfo, MsvAvTargetName,\n\t\t\t                      (PBYTE)context->ServicePrincipalName.Buffer,\n\t\t\t                      context->ServicePrincipalName.Length))\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (context->NTLMv2)\n\t{\n\t\tNTLM_AV_PAIR* AvEOL;\n\t\tAvEOL = ntlm_av_pair_get(ChallengeTargetInfo, cbChallengeTargetInfo, MsvAvEOL, NULL);\n\n\t\tif (!AvEOL)\n\t\t\tgoto fail;\n\n\t\tZeroMemory(AvEOL, sizeof(NTLM_AV_PAIR));\n\t}\n\n\treturn 1;\nfail:\n\tsspi_SecBufferFree(&context->AuthenticateTargetInfo);\n\treturn -1;\n}\n"], "fixing_code": ["/**\n * WinPR: Windows Portable Runtime\n * NTLM Security Package (AV_PAIRs)\n *\n * Copyright 2011-2014 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <assert.h>\n\n#include \"ntlm.h\"\n#include \"../sspi.h\"\n\n#include <winpr/crt.h>\n#include <winpr/print.h>\n#include <winpr/sysinfo.h>\n#include <winpr/tchar.h>\n#include <winpr/crypto.h>\n\n#include \"ntlm_compute.h\"\n\n#include \"ntlm_av_pairs.h\"\n\n#include \"../../log.h\"\n#define TAG WINPR_TAG(\"sspi.NTLM\")\n\nstatic BOOL ntlm_av_pair_get_next_offset(const NTLM_AV_PAIR* pAvPair, size_t size, size_t* pOffset);\n\nstatic BOOL ntlm_av_pair_check_data(const NTLM_AV_PAIR* pAvPair, size_t cbAvPair, size_t size)\n{\n\tsize_t offset;\n\tif (!pAvPair || cbAvPair < sizeof(NTLM_AV_PAIR) + size)\n\t\treturn FALSE;\n\tif (!ntlm_av_pair_get_next_offset(pAvPair, cbAvPair, &offset))\n\t\treturn FALSE;\n\treturn cbAvPair >= offset;\n}\n\nstatic const char* get_av_pair_string(UINT16 pair)\n{\n\tswitch (pair)\n\t{\n\t\tcase MsvAvEOL:\n\t\t\treturn \"MsvAvEOL\";\n\t\tcase MsvAvNbComputerName:\n\t\t\treturn \"MsvAvNbComputerName\";\n\t\tcase MsvAvNbDomainName:\n\t\t\treturn \"MsvAvNbDomainName\";\n\t\tcase MsvAvDnsComputerName:\n\t\t\treturn \"MsvAvDnsComputerName\";\n\t\tcase MsvAvDnsDomainName:\n\t\t\treturn \"MsvAvDnsDomainName\";\n\t\tcase MsvAvDnsTreeName:\n\t\t\treturn \"MsvAvDnsTreeName\";\n\t\tcase MsvAvFlags:\n\t\t\treturn \"MsvAvFlags\";\n\t\tcase MsvAvTimestamp:\n\t\t\treturn \"MsvAvTimestamp\";\n\t\tcase MsvAvSingleHost:\n\t\t\treturn \"MsvAvSingleHost\";\n\t\tcase MsvAvTargetName:\n\t\t\treturn \"MsvAvTargetName\";\n\t\tcase MsvChannelBindings:\n\t\t\treturn \"MsvChannelBindings\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t}\n}\n\nstatic BOOL ntlm_av_pair_check(const NTLM_AV_PAIR* pAvPair, size_t cbAvPair);\nstatic NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPairList, size_t* pcbAvPairList);\n\nstatic INLINE void ntlm_av_pair_set_id(NTLM_AV_PAIR* pAvPair, UINT16 id)\n{\n\tData_Write_UINT16(&pAvPair->AvId, id);\n}\n\nstatic INLINE void ntlm_av_pair_set_len(NTLM_AV_PAIR* pAvPair, UINT16 len)\n{\n\tData_Write_UINT16(&pAvPair->AvLen, len);\n}\n\nstatic BOOL ntlm_av_pair_list_init(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList)\n{\n\tNTLM_AV_PAIR* pAvPair = pAvPairList;\n\n\tif (!pAvPair || (cbAvPairList < sizeof(NTLM_AV_PAIR)))\n\t\treturn FALSE;\n\n\tntlm_av_pair_set_id(pAvPair, MsvAvEOL);\n\tntlm_av_pair_set_len(pAvPair, 0);\n\treturn TRUE;\n}\n\nstatic INLINE BOOL ntlm_av_pair_get_id(const NTLM_AV_PAIR* pAvPair, size_t size, UINT16* pair)\n{\n\tUINT16 AvId;\n\tif (!pAvPair || !pair)\n\t\treturn FALSE;\n\n\tif (size < sizeof(NTLM_AV_PAIR))\n\t\treturn FALSE;\n\n\tData_Read_UINT16(&pAvPair->AvId, AvId);\n\n\t*pair = AvId;\n\treturn TRUE;\n}\n\nULONG ntlm_av_pair_list_length(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList)\n{\n\tsize_t cbAvPair;\n\tNTLM_AV_PAIR* pAvPair;\n\n\tpAvPair = ntlm_av_pair_get(pAvPairList, cbAvPairList, MsvAvEOL, &cbAvPair);\n\tif (!pAvPair)\n\t\treturn 0;\n\n\treturn ((PBYTE)pAvPair - (PBYTE)pAvPairList) + sizeof(NTLM_AV_PAIR);\n}\n\nstatic INLINE BOOL ntlm_av_pair_get_len(const NTLM_AV_PAIR* pAvPair, size_t size, size_t* pAvLen)\n{\n\tUINT16 AvLen;\n\tif (!pAvPair)\n\t\treturn FALSE;\n\n\tif (size < sizeof(NTLM_AV_PAIR))\n\t\treturn FALSE;\n\n\tData_Read_UINT16(&pAvPair->AvLen, AvLen);\n\n\t*pAvLen = AvLen;\n\treturn TRUE;\n}\n\nvoid ntlm_print_av_pair_list(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList)\n{\n\tUINT16 pair;\n\tsize_t cbAvPair = cbAvPairList;\n\tNTLM_AV_PAIR* pAvPair = pAvPairList;\n\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\treturn;\n\n\tWLog_INFO(TAG, \"AV_PAIRs =\");\n\n\twhile (pAvPair && ntlm_av_pair_get_id(pAvPair, cbAvPair, &pair) && (pair != MsvAvEOL))\n\t{\n\t\tsize_t cbLen = 0;\n\t\tntlm_av_pair_get_len(pAvPair, cbAvPair, &cbLen);\n\n\t\tWLog_INFO(TAG, \"\\t%s AvId: %\" PRIu16 \" AvLen: %\" PRIu16 \"\", get_av_pair_string(pair), pair);\n\t\twinpr_HexDump(TAG, WLOG_INFO, ntlm_av_pair_get_value_pointer(pAvPair), cbLen);\n\n\t\tpAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);\n\t}\n}\n\nstatic ULONG ntlm_av_pair_list_size(ULONG AvPairsCount, ULONG AvPairsValueLength)\n{\n\t/* size of headers + value lengths + terminating MsvAvEOL AV_PAIR */\n\treturn ((AvPairsCount + 1) * 4) + AvPairsValueLength;\n}\n\nPBYTE ntlm_av_pair_get_value_pointer(NTLM_AV_PAIR* pAvPair)\n{\n\treturn (PBYTE)pAvPair + sizeof(NTLM_AV_PAIR);\n}\n\nstatic BOOL ntlm_av_pair_get_next_offset(const NTLM_AV_PAIR* pAvPair, size_t size, size_t* pOffset)\n{\n\tsize_t avLen;\n\tif (!pOffset)\n\t\treturn FALSE;\n\n\tif (!ntlm_av_pair_get_len(pAvPair, size, &avLen))\n\t\treturn FALSE;\n\t*pOffset = avLen + sizeof(NTLM_AV_PAIR);\n\treturn TRUE;\n}\n\nstatic BOOL ntlm_av_pair_check(const NTLM_AV_PAIR* pAvPair, size_t cbAvPair)\n{\n\treturn ntlm_av_pair_check_data(pAvPair, cbAvPair, 0);\n}\n\nstatic NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPair, size_t* pcbAvPair)\n{\n\tsize_t offset;\n\n\tif (!pcbAvPair)\n\t\treturn NULL;\n\tif (!ntlm_av_pair_check(pAvPair, *pcbAvPair))\n\t\treturn NULL;\n\n\tif (!ntlm_av_pair_get_next_offset(pAvPair, *pcbAvPair, &offset))\n\t\treturn NULL;\n\n\t*pcbAvPair -= offset;\n\treturn (NTLM_AV_PAIR*)((PBYTE)pAvPair + offset);\n}\n\nNTLM_AV_PAIR* ntlm_av_pair_get(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId,\n                               size_t* pcbAvPairListRemaining)\n{\n\tUINT16 id;\n\tsize_t cbAvPair = cbAvPairList;\n\tNTLM_AV_PAIR* pAvPair = pAvPairList;\n\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\tpAvPair = NULL;\n\n\twhile (pAvPair && ntlm_av_pair_get_id(pAvPair, cbAvPair, &id))\n\t{\n\t\tif (id == AvId)\n\t\t\tbreak;\n\t\tif (id == MsvAvEOL)\n\t\t{\n\t\t\tpAvPair = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);\n\t}\n\n\tif (!pAvPair)\n\t\tcbAvPair = 0;\n\tif (pcbAvPairListRemaining)\n\t\t*pcbAvPairListRemaining = cbAvPair;\n\n\treturn pAvPair;\n}\n\nstatic BOOL ntlm_av_pair_add(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId,\n                             PBYTE Value, UINT16 AvLen)\n{\n\tsize_t cbAvPair;\n\tNTLM_AV_PAIR* pAvPair;\n\n\tpAvPair = ntlm_av_pair_get(pAvPairList, cbAvPairList, MsvAvEOL, &cbAvPair);\n\n\t/* size of header + value length + terminating MsvAvEOL AV_PAIR */\n\tif (!pAvPair || cbAvPair < 2 * sizeof(NTLM_AV_PAIR) + AvLen)\n\t\treturn FALSE;\n\n\tntlm_av_pair_set_id(pAvPair, AvId);\n\tntlm_av_pair_set_len(pAvPair, AvLen);\n\tif (AvLen)\n\t{\n\t\tassert(Value != NULL);\n\t\tCopyMemory(ntlm_av_pair_get_value_pointer(pAvPair), Value, AvLen);\n\t}\n\n\tpAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);\n\treturn ntlm_av_pair_list_init(pAvPair, cbAvPair);\n}\n\nstatic BOOL ntlm_av_pair_add_copy(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList,\n                                  NTLM_AV_PAIR* pAvPair, size_t cbAvPair)\n{\n\tUINT16 pair;\n\tsize_t avLen;\n\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\treturn FALSE;\n\n\tif (!ntlm_av_pair_get_id(pAvPair, cbAvPair, &pair))\n\t\treturn FALSE;\n\n\tif (!ntlm_av_pair_get_len(pAvPair, cbAvPair, &avLen))\n\t\treturn FALSE;\n\n\treturn ntlm_av_pair_add(pAvPairList, cbAvPairList, pair,\n\t                        ntlm_av_pair_get_value_pointer(pAvPair), avLen);\n}\n\nstatic int ntlm_get_target_computer_name(PUNICODE_STRING pName, COMPUTER_NAME_FORMAT type)\n{\n\tchar* name;\n\tint status;\n\tDWORD nSize = 0;\n\tCHAR* computerName;\n\n\tif (GetComputerNameExA(ComputerNameNetBIOS, NULL, &nSize) || GetLastError() != ERROR_MORE_DATA)\n\t\treturn -1;\n\n\tcomputerName = calloc(nSize, sizeof(CHAR));\n\n\tif (!computerName)\n\t\treturn -1;\n\n\tif (!GetComputerNameExA(ComputerNameNetBIOS, computerName, &nSize))\n\t{\n\t\tfree(computerName);\n\t\treturn -1;\n\t}\n\n\tif (nSize > MAX_COMPUTERNAME_LENGTH)\n\t\tcomputerName[MAX_COMPUTERNAME_LENGTH] = '\\0';\n\n\tname = computerName;\n\n\tif (!name)\n\t\treturn -1;\n\n\tif (type == ComputerNameNetBIOS)\n\t\tCharUpperA(name);\n\n\tstatus = ConvertToUnicode(CP_UTF8, 0, name, -1, &pName->Buffer, 0);\n\n\tif (status <= 0)\n\t{\n\t\tfree(name);\n\t\treturn status;\n\t}\n\n\tpName->Length = (USHORT)((status - 1) * 2);\n\tpName->MaximumLength = pName->Length;\n\tfree(name);\n\treturn 1;\n}\n\nstatic void ntlm_free_unicode_string(PUNICODE_STRING string)\n{\n\tif (string)\n\t{\n\t\tif (string->Length > 0)\n\t\t{\n\t\t\tfree(string->Buffer);\n\t\t\tstring->Buffer = NULL;\n\t\t\tstring->Length = 0;\n\t\t\tstring->MaximumLength = 0;\n\t\t}\n\t}\n}\n\n/**\n * From http://www.ietf.org/proceedings/72/slides/sasl-2.pdf:\n *\n * tls-server-end-point:\n *\n * The hash of the TLS server's end entity certificate as it appears, octet for octet,\n * in the server's Certificate message (note that the Certificate message contains a\n * certificate_list, the first element of which is the server's end entity certificate.)\n * The hash function to be selected is as follows: if the certificate's signature hash\n * algorithm is either MD5 or SHA-1, then use SHA-256, otherwise use the certificate's\n * signature hash algorithm.\n */\n\n/**\n * Channel Bindings sample usage:\n * https://raw.github.com/mozilla/mozilla-central/master/extensions/auth/nsAuthSSPI.cpp\n */\n\n/*\ntypedef struct gss_channel_bindings_struct {\n    OM_uint32 initiator_addrtype;\n    gss_buffer_desc initiator_address;\n    OM_uint32 acceptor_addrtype;\n    gss_buffer_desc acceptor_address;\n    gss_buffer_desc application_data;\n} *gss_channel_bindings_t;\n */\n\nstatic BOOL ntlm_md5_update_uint32_be(WINPR_DIGEST_CTX* md5, UINT32 num)\n{\n\tBYTE be32[4];\n\tbe32[0] = (num >> 0) & 0xFF;\n\tbe32[1] = (num >> 8) & 0xFF;\n\tbe32[2] = (num >> 16) & 0xFF;\n\tbe32[3] = (num >> 24) & 0xFF;\n\treturn winpr_Digest_Update(md5, be32, 4);\n}\n\nstatic void ntlm_compute_channel_bindings(NTLM_CONTEXT* context)\n{\n\tWINPR_DIGEST_CTX* md5;\n\tBYTE* ChannelBindingToken;\n\tUINT32 ChannelBindingTokenLength;\n\tSEC_CHANNEL_BINDINGS* ChannelBindings;\n\tZeroMemory(context->ChannelBindingsHash, WINPR_MD5_DIGEST_LENGTH);\n\tChannelBindings = context->Bindings.Bindings;\n\n\tif (!ChannelBindings)\n\t\treturn;\n\n\tif (!(md5 = winpr_Digest_New()))\n\t\treturn;\n\n\tif (!winpr_Digest_Init(md5, WINPR_MD_MD5))\n\t\tgoto out;\n\n\tChannelBindingTokenLength = context->Bindings.BindingsLength - sizeof(SEC_CHANNEL_BINDINGS);\n\tChannelBindingToken = &((BYTE*)ChannelBindings)[ChannelBindings->dwApplicationDataOffset];\n\n\tif (!ntlm_md5_update_uint32_be(md5, ChannelBindings->dwInitiatorAddrType))\n\t\tgoto out;\n\n\tif (!ntlm_md5_update_uint32_be(md5, ChannelBindings->cbInitiatorLength))\n\t\tgoto out;\n\n\tif (!ntlm_md5_update_uint32_be(md5, ChannelBindings->dwAcceptorAddrType))\n\t\tgoto out;\n\n\tif (!ntlm_md5_update_uint32_be(md5, ChannelBindings->cbAcceptorLength))\n\t\tgoto out;\n\n\tif (!ntlm_md5_update_uint32_be(md5, ChannelBindings->cbApplicationDataLength))\n\t\tgoto out;\n\n\tif (!winpr_Digest_Update(md5, (void*)ChannelBindingToken, ChannelBindingTokenLength))\n\t\tgoto out;\n\n\tif (!winpr_Digest_Final(md5, context->ChannelBindingsHash, WINPR_MD5_DIGEST_LENGTH))\n\t\tgoto out;\n\nout:\n\twinpr_Digest_Free(md5);\n}\n\nstatic void ntlm_compute_single_host_data(NTLM_CONTEXT* context)\n{\n\t/**\n\t * The Single_Host_Data structure allows a client to send machine-specific information\n\t * within an authentication exchange to services on the same machine. The client can\n\t * produce additional information to be processed in an implementation-specific way when\n\t * the client and server are on the same host. If the server and client platforms are\n\t * different or if they are on different hosts, then the information MUST be ignored.\n\t * Any fields after the MachineID field MUST be ignored on receipt.\n\t */\n\tData_Write_UINT32(&context->SingleHostData.Size, 48);\n\tData_Write_UINT32(&context->SingleHostData.Z4, 0);\n\tData_Write_UINT32(&context->SingleHostData.DataPresent, 1);\n\tData_Write_UINT32(&context->SingleHostData.CustomData, SECURITY_MANDATORY_MEDIUM_RID);\n\tFillMemory(context->SingleHostData.MachineID, 32, 0xAA);\n}\n\nint ntlm_construct_challenge_target_info(NTLM_CONTEXT* context)\n{\n\tint rc = -1;\n\tint length;\n\tULONG AvPairsCount;\n\tULONG AvPairsLength;\n\tNTLM_AV_PAIR* pAvPairList;\n\tsize_t cbAvPairList;\n\tUNICODE_STRING NbDomainName = { 0 };\n\tUNICODE_STRING NbComputerName = { 0 };\n\tUNICODE_STRING DnsDomainName = { 0 };\n\tUNICODE_STRING DnsComputerName = { 0 };\n\n\tif (ntlm_get_target_computer_name(&NbDomainName, ComputerNameNetBIOS) < 0)\n\t\tgoto fail;\n\n\tNbComputerName.Buffer = NULL;\n\n\tif (ntlm_get_target_computer_name(&NbComputerName, ComputerNameNetBIOS) < 0)\n\t\tgoto fail;\n\n\tDnsDomainName.Buffer = NULL;\n\n\tif (ntlm_get_target_computer_name(&DnsDomainName, ComputerNameDnsDomain) < 0)\n\t\tgoto fail;\n\n\tDnsComputerName.Buffer = NULL;\n\n\tif (ntlm_get_target_computer_name(&DnsComputerName, ComputerNameDnsHostname) < 0)\n\t\tgoto fail;\n\n\tAvPairsCount = 5;\n\tAvPairsLength = NbDomainName.Length + NbComputerName.Length + DnsDomainName.Length +\n\t                DnsComputerName.Length + 8;\n\tlength = ntlm_av_pair_list_size(AvPairsCount, AvPairsLength);\n\n\tif (!sspi_SecBufferAlloc(&context->ChallengeTargetInfo, length))\n\t\tgoto fail;\n\n\tpAvPairList = (NTLM_AV_PAIR*)context->ChallengeTargetInfo.pvBuffer;\n\tcbAvPairList = context->ChallengeTargetInfo.cbBuffer;\n\n\tif (!ntlm_av_pair_list_init(pAvPairList, cbAvPairList))\n\t\tgoto fail;\n\n\tif (!ntlm_av_pair_add(pAvPairList, cbAvPairList, MsvAvNbDomainName, (PBYTE)NbDomainName.Buffer,\n\t                      NbDomainName.Length))\n\t\tgoto fail;\n\n\tif (!ntlm_av_pair_add(pAvPairList, cbAvPairList, MsvAvNbComputerName,\n\t                      (PBYTE)NbComputerName.Buffer, NbComputerName.Length))\n\t\tgoto fail;\n\n\tif (!ntlm_av_pair_add(pAvPairList, cbAvPairList, MsvAvDnsDomainName,\n\t                      (PBYTE)DnsDomainName.Buffer, DnsDomainName.Length))\n\t\tgoto fail;\n\n\tif (!ntlm_av_pair_add(pAvPairList, cbAvPairList, MsvAvDnsComputerName,\n\t                      (PBYTE)DnsComputerName.Buffer, DnsComputerName.Length))\n\t\tgoto fail;\n\n\tif (!ntlm_av_pair_add(pAvPairList, cbAvPairList, MsvAvTimestamp, context->Timestamp,\n\t                      sizeof(context->Timestamp)))\n\t\tgoto fail;\n\n\trc = 1;\nfail:\n\tntlm_free_unicode_string(&NbDomainName);\n\tntlm_free_unicode_string(&NbComputerName);\n\tntlm_free_unicode_string(&DnsDomainName);\n\tntlm_free_unicode_string(&DnsComputerName);\n\treturn rc;\n}\n\nint ntlm_construct_authenticate_target_info(NTLM_CONTEXT* context)\n{\n\tULONG size;\n\tULONG AvPairsCount;\n\tULONG AvPairsValueLength;\n\tNTLM_AV_PAIR* AvTimestamp;\n\tNTLM_AV_PAIR* AvNbDomainName;\n\tNTLM_AV_PAIR* AvNbComputerName;\n\tNTLM_AV_PAIR* AvDnsDomainName;\n\tNTLM_AV_PAIR* AvDnsComputerName;\n\tNTLM_AV_PAIR* AvDnsTreeName;\n\tNTLM_AV_PAIR* ChallengeTargetInfo;\n\tNTLM_AV_PAIR* AuthenticateTargetInfo;\n\tsize_t cbAvTimestamp;\n\tsize_t cbAvNbDomainName;\n\tsize_t cbAvNbComputerName;\n\tsize_t cbAvDnsDomainName;\n\tsize_t cbAvDnsComputerName;\n\tsize_t cbAvDnsTreeName;\n\tsize_t cbChallengeTargetInfo;\n\tsize_t cbAuthenticateTargetInfo;\n\tAvPairsCount = 1;\n\tAvPairsValueLength = 0;\n\tChallengeTargetInfo = (NTLM_AV_PAIR*)context->ChallengeTargetInfo.pvBuffer;\n\tcbChallengeTargetInfo = context->ChallengeTargetInfo.cbBuffer;\n\tAvNbDomainName = ntlm_av_pair_get(ChallengeTargetInfo, cbChallengeTargetInfo, MsvAvNbDomainName,\n\t                                  &cbAvNbDomainName);\n\tAvNbComputerName = ntlm_av_pair_get(ChallengeTargetInfo, cbChallengeTargetInfo,\n\t                                    MsvAvNbComputerName, &cbAvNbComputerName);\n\tAvDnsDomainName = ntlm_av_pair_get(ChallengeTargetInfo, cbChallengeTargetInfo,\n\t                                   MsvAvDnsDomainName, &cbAvDnsDomainName);\n\tAvDnsComputerName = ntlm_av_pair_get(ChallengeTargetInfo, cbChallengeTargetInfo,\n\t                                     MsvAvDnsComputerName, &cbAvDnsComputerName);\n\tAvDnsTreeName = ntlm_av_pair_get(ChallengeTargetInfo, cbChallengeTargetInfo, MsvAvDnsTreeName,\n\t                                 &cbAvDnsTreeName);\n\tAvTimestamp = ntlm_av_pair_get(ChallengeTargetInfo, cbChallengeTargetInfo, MsvAvTimestamp,\n\t                               &cbAvTimestamp);\n\n\tif (AvNbDomainName)\n\t{\n\t\tsize_t avLen;\n\t\tif (!ntlm_av_pair_get_len(AvNbDomainName, cbAvNbDomainName, &avLen))\n\t\t\tgoto fail;\n\t\tAvPairsCount++; /* MsvAvNbDomainName */\n\t\tAvPairsValueLength += avLen;\n\t}\n\n\tif (AvNbComputerName)\n\t{\n\t\tsize_t avLen;\n\t\tif (!ntlm_av_pair_get_len(AvNbComputerName, cbAvNbComputerName, &avLen))\n\t\t\tgoto fail;\n\t\tAvPairsCount++; /* MsvAvNbComputerName */\n\t\tAvPairsValueLength += avLen;\n\t}\n\n\tif (AvDnsDomainName)\n\t{\n\t\tsize_t avLen;\n\t\tif (!ntlm_av_pair_get_len(AvDnsDomainName, cbAvDnsDomainName, &avLen))\n\t\t\tgoto fail;\n\t\tAvPairsCount++; /* MsvAvDnsDomainName */\n\t\tAvPairsValueLength += avLen;\n\t}\n\n\tif (AvDnsComputerName)\n\t{\n\t\tsize_t avLen;\n\t\tif (!ntlm_av_pair_get_len(AvDnsComputerName, cbAvDnsComputerName, &avLen))\n\t\t\tgoto fail;\n\t\tAvPairsCount++; /* MsvAvDnsComputerName */\n\t\tAvPairsValueLength += avLen;\n\t}\n\n\tif (AvDnsTreeName)\n\t{\n\t\tsize_t avLen;\n\t\tif (!ntlm_av_pair_get_len(AvDnsTreeName, cbAvDnsTreeName, &avLen))\n\t\t\tgoto fail;\n\t\tAvPairsCount++; /* MsvAvDnsTreeName */\n\t\tAvPairsValueLength += avLen;\n\t}\n\n\tAvPairsCount++; /* MsvAvTimestamp */\n\tAvPairsValueLength += 8;\n\n\tif (context->UseMIC)\n\t{\n\t\tAvPairsCount++; /* MsvAvFlags */\n\t\tAvPairsValueLength += 4;\n\t}\n\n\tif (context->SendSingleHostData)\n\t{\n\t\tAvPairsCount++; /* MsvAvSingleHost */\n\t\tntlm_compute_single_host_data(context);\n\t\tAvPairsValueLength += context->SingleHostData.Size;\n\t}\n\n\t/**\n\t * Extended Protection for Authentication:\n\t * http://blogs.technet.com/b/srd/archive/2009/12/08/extended-protection-for-authentication.aspx\n\t */\n\n\tif (!context->SuppressExtendedProtection)\n\t{\n\t\t/**\n\t\t * SEC_CHANNEL_BINDINGS structure\n\t\t * http://msdn.microsoft.com/en-us/library/windows/desktop/dd919963/\n\t\t */\n\t\tAvPairsCount++; /* MsvChannelBindings */\n\t\tAvPairsValueLength += 16;\n\t\tntlm_compute_channel_bindings(context);\n\n\t\tif (context->ServicePrincipalName.Length > 0)\n\t\t{\n\t\t\tAvPairsCount++; /* MsvAvTargetName */\n\t\t\tAvPairsValueLength += context->ServicePrincipalName.Length;\n\t\t}\n\t}\n\n\tsize = ntlm_av_pair_list_size(AvPairsCount, AvPairsValueLength);\n\n\tif (context->NTLMv2)\n\t\tsize += 8; /* unknown 8-byte padding */\n\n\tif (!sspi_SecBufferAlloc(&context->AuthenticateTargetInfo, size))\n\t\tgoto fail;\n\n\tAuthenticateTargetInfo = (NTLM_AV_PAIR*)context->AuthenticateTargetInfo.pvBuffer;\n\tcbAuthenticateTargetInfo = context->AuthenticateTargetInfo.cbBuffer;\n\n\tif (!ntlm_av_pair_list_init(AuthenticateTargetInfo, cbAuthenticateTargetInfo))\n\t\tgoto fail;\n\n\tif (AvNbDomainName)\n\t{\n\t\tif (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo, AvNbDomainName,\n\t\t                           cbAvNbDomainName))\n\t\t\tgoto fail;\n\t}\n\n\tif (AvNbComputerName)\n\t{\n\t\tif (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo,\n\t\t                           AvNbComputerName, cbAvNbComputerName))\n\t\t\tgoto fail;\n\t}\n\n\tif (AvDnsDomainName)\n\t{\n\t\tif (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo,\n\t\t                           AvDnsDomainName, cbAvDnsDomainName))\n\t\t\tgoto fail;\n\t}\n\n\tif (AvDnsComputerName)\n\t{\n\t\tif (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo,\n\t\t                           AvDnsComputerName, cbAvDnsComputerName))\n\t\t\tgoto fail;\n\t}\n\n\tif (AvDnsTreeName)\n\t{\n\t\tif (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo, AvDnsTreeName,\n\t\t                           cbAvDnsTreeName))\n\t\t\tgoto fail;\n\t}\n\n\tif (AvTimestamp)\n\t{\n\t\tif (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo, AvTimestamp,\n\t\t                           cbAvTimestamp))\n\t\t\tgoto fail;\n\t}\n\n\tif (context->UseMIC)\n\t{\n\t\tUINT32 flags;\n\t\tData_Write_UINT32(&flags, MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK);\n\n\t\tif (!ntlm_av_pair_add(AuthenticateTargetInfo, cbAuthenticateTargetInfo, MsvAvFlags,\n\t\t                      (PBYTE)&flags, 4))\n\t\t\tgoto fail;\n\t}\n\n\tif (context->SendSingleHostData)\n\t{\n\t\tif (!ntlm_av_pair_add(AuthenticateTargetInfo, cbAuthenticateTargetInfo, MsvAvSingleHost,\n\t\t                      (PBYTE)&context->SingleHostData, context->SingleHostData.Size))\n\t\t\tgoto fail;\n\t}\n\n\tif (!context->SuppressExtendedProtection)\n\t{\n\t\tif (!ntlm_av_pair_add(AuthenticateTargetInfo, cbAuthenticateTargetInfo, MsvChannelBindings,\n\t\t                      context->ChannelBindingsHash, 16))\n\t\t\tgoto fail;\n\n\t\tif (context->ServicePrincipalName.Length > 0)\n\t\t{\n\t\t\tif (!ntlm_av_pair_add(AuthenticateTargetInfo, cbAuthenticateTargetInfo, MsvAvTargetName,\n\t\t\t                      (PBYTE)context->ServicePrincipalName.Buffer,\n\t\t\t                      context->ServicePrincipalName.Length))\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (context->NTLMv2)\n\t{\n\t\tNTLM_AV_PAIR* AvEOL;\n\t\tAvEOL = ntlm_av_pair_get(ChallengeTargetInfo, cbChallengeTargetInfo, MsvAvEOL, NULL);\n\n\t\tif (!AvEOL)\n\t\t\tgoto fail;\n\n\t\tZeroMemory(AvEOL, sizeof(NTLM_AV_PAIR));\n\t}\n\n\treturn 1;\nfail:\n\tsspi_SecBufferFree(&context->AuthenticateTargetInfo);\n\treturn -1;\n}\n"], "filenames": ["winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.c"], "buggy_code_start_loc": [42], "buggy_code_end_loc": [529], "fixing_code_start_loc": [42], "fixing_code_end_loc": [609], "type": "CWE-125", "message": "In FreeRDP before version 2.1.2, an out of bounds read occurs resulting in accessing a memory location that is outside of the boundaries of the static array PRIMARY_DRAWING_ORDER_FIELD_BYTES. This is fixed in version 2.1.2.", "other": {"cve": {"id": "CVE-2020-11097", "sourceIdentifier": "security-advisories@github.com", "published": "2020-06-22T22:15:12.103", "lastModified": "2022-07-19T11:46:06.800", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In FreeRDP before version 2.1.2, an out of bounds read occurs resulting in accessing a memory location that is outside of the boundaries of the static array PRIMARY_DRAWING_ORDER_FIELD_BYTES. This is fixed in version 2.1.2."}, {"lang": "es", "value": "En FreeRDP versiones anteriores a 2.1.2, se produce una lectura fuera de l\u00edmites resultando en el acceso a una ubicaci\u00f3n de memoria que est\u00e1 fuera de l\u00edmites de la matriz est\u00e1tica PRIMARY_DRAWING_ORDER_FIELD_BYTES. Esto es corregido en la versi\u00f3n 2.1.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.2", "matchCriteriaId": "DDAC8E89-8F23-4799-AA42-AD419455D1F6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00080.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.freerdp.com/2020/06/22/2_1_2-released", "source": "security-advisories@github.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/commit/58a3122250d54de3a944c487776bcd4d1da4721e", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-c8x2-c3c9-9r3f", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6Y35HBHG2INICLSGCIKNAR7GCXEHQACQ/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XOZLH35OJWIQLM7FYDXAP2EAUBDXE76V/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4481-1/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/58a3122250d54de3a944c487776bcd4d1da4721e"}}