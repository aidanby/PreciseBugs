{"buggy_code": ["/*\n * A framebuffer driver for VBE 2.0+ compliant video cards\n *\n * (c) 2007 Michal Januszewski <spock@gentoo.org>\n *     Loosely based upon the vesafb driver.\n *\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/skbuff.h>\n#include <linux/timer.h>\n#include <linux/completion.h>\n#include <linux/connector.h>\n#include <linux/random.h>\n#include <linux/platform_device.h>\n#include <linux/limits.h>\n#include <linux/fb.h>\n#include <linux/io.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <video/edid.h>\n#include <video/uvesafb.h>\n#ifdef CONFIG_X86\n#include <video/vga.h>\n#endif\n#include \"edid.h\"\n\nstatic struct cb_id uvesafb_cn_id = {\n\t.idx = CN_IDX_V86D,\n\t.val = CN_VAL_V86D_UVESAFB\n};\nstatic char v86d_path[PATH_MAX] = \"/sbin/v86d\";\nstatic char v86d_started;\t/* has v86d been started by uvesafb? */\n\nstatic const struct fb_fix_screeninfo uvesafb_fix = {\n\t.id\t= \"VESA VGA\",\n\t.type\t= FB_TYPE_PACKED_PIXELS,\n\t.accel\t= FB_ACCEL_NONE,\n\t.visual = FB_VISUAL_TRUECOLOR,\n};\n\nstatic int mtrr\t\t= 3;\t/* enable mtrr by default */\nstatic bool blank\t= 1;\t/* enable blanking by default */\nstatic int ypan\t\t= 1;\t/* 0: scroll, 1: ypan, 2: ywrap */\nstatic bool pmi_setpal\t= true; /* use PMI for palette changes */\nstatic bool nocrtc;\t\t/* ignore CRTC settings */\nstatic bool noedid;\t\t/* don't try DDC transfers */\nstatic int vram_remap;\t\t/* set amt. of memory to be used */\nstatic int vram_total;\t\t/* set total amount of memory */\nstatic u16 maxclk;\t\t/* maximum pixel clock */\nstatic u16 maxvf;\t\t/* maximum vertical frequency */\nstatic u16 maxhf;\t\t/* maximum horizontal frequency */\nstatic u16 vbemode;\t\t/* force use of a specific VBE mode */\nstatic char *mode_option;\nstatic u8  dac_width\t= 6;\n\nstatic struct uvesafb_ktask *uvfb_tasks[UVESAFB_TASKS_MAX];\nstatic DEFINE_MUTEX(uvfb_lock);\n\n/*\n * A handler for replies from userspace.\n *\n * Make sure each message passes consistency checks and if it does,\n * find the kernel part of the task struct, copy the registers and\n * the buffer contents and then complete the task.\n */\nstatic void uvesafb_cn_callback(struct cn_msg *msg, struct netlink_skb_parms *nsp)\n{\n\tstruct uvesafb_task *utask;\n\tstruct uvesafb_ktask *task;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn;\n\n\tif (msg->seq >= UVESAFB_TASKS_MAX)\n\t\treturn;\n\n\tmutex_lock(&uvfb_lock);\n\ttask = uvfb_tasks[msg->seq];\n\n\tif (!task || msg->ack != task->ack) {\n\t\tmutex_unlock(&uvfb_lock);\n\t\treturn;\n\t}\n\n\tutask = (struct uvesafb_task *)msg->data;\n\n\t/* Sanity checks for the buffer length. */\n\tif (task->t.buf_len < utask->buf_len ||\n\t    utask->buf_len > msg->len - sizeof(*utask)) {\n\t\tmutex_unlock(&uvfb_lock);\n\t\treturn;\n\t}\n\n\tuvfb_tasks[msg->seq] = NULL;\n\tmutex_unlock(&uvfb_lock);\n\n\tmemcpy(&task->t, utask, sizeof(*utask));\n\n\tif (task->t.buf_len && task->buf)\n\t\tmemcpy(task->buf, utask + 1, task->t.buf_len);\n\n\tcomplete(task->done);\n\treturn;\n}\n\nstatic int uvesafb_helper_start(void)\n{\n\tchar *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"PATH=/sbin:/bin\",\n\t\tNULL,\n\t};\n\n\tchar *argv[] = {\n\t\tv86d_path,\n\t\tNULL,\n\t};\n\n\treturn call_usermodehelper(v86d_path, argv, envp, UMH_WAIT_PROC);\n}\n\n/*\n * Execute a uvesafb task.\n *\n * Returns 0 if the task is executed successfully.\n *\n * A message sent to the userspace consists of the uvesafb_task\n * struct and (optionally) a buffer. The uvesafb_task struct is\n * a simplified version of uvesafb_ktask (its kernel counterpart)\n * containing only the register values, flags and the length of\n * the buffer.\n *\n * Each message is assigned a sequence number (increased linearly)\n * and a random ack number. The sequence number is used as a key\n * for the uvfb_tasks array which holds pointers to uvesafb_ktask\n * structs for all requests.\n */\nstatic int uvesafb_exec(struct uvesafb_ktask *task)\n{\n\tstatic int seq;\n\tstruct cn_msg *m;\n\tint err;\n\tint len = sizeof(task->t) + task->t.buf_len;\n\n\t/*\n\t * Check whether the message isn't longer than the maximum\n\t * allowed by connector.\n\t */\n\tif (sizeof(*m) + len > CONNECTOR_MAX_MSG_SIZE) {\n\t\tpr_warn(\"message too long (%d), can't execute task\\n\",\n\t\t\t(int)(sizeof(*m) + len));\n\t\treturn -E2BIG;\n\t}\n\n\tm = kzalloc(sizeof(*m) + len, GFP_KERNEL);\n\tif (!m)\n\t\treturn -ENOMEM;\n\n\tinit_completion(task->done);\n\n\tmemcpy(&m->id, &uvesafb_cn_id, sizeof(m->id));\n\tm->seq = seq;\n\tm->len = len;\n\tm->ack = prandom_u32();\n\n\t/* uvesafb_task structure */\n\tmemcpy(m + 1, &task->t, sizeof(task->t));\n\n\t/* Buffer */\n\tmemcpy((u8 *)(m + 1) + sizeof(task->t), task->buf, task->t.buf_len);\n\n\t/*\n\t * Save the message ack number so that we can find the kernel\n\t * part of this task when a reply is received from userspace.\n\t */\n\ttask->ack = m->ack;\n\n\tmutex_lock(&uvfb_lock);\n\n\t/* If all slots are taken -- bail out. */\n\tif (uvfb_tasks[seq]) {\n\t\tmutex_unlock(&uvfb_lock);\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/* Save a pointer to the kernel part of the task struct. */\n\tuvfb_tasks[seq] = task;\n\tmutex_unlock(&uvfb_lock);\n\n\terr = cn_netlink_send(m, 0, 0, GFP_KERNEL);\n\tif (err == -ESRCH) {\n\t\t/*\n\t\t * Try to start the userspace helper if sending\n\t\t * the request failed the first time.\n\t\t */\n\t\terr = uvesafb_helper_start();\n\t\tif (err) {\n\t\t\tpr_err(\"failed to execute %s\\n\", v86d_path);\n\t\t\tpr_err(\"make sure that the v86d helper is installed and executable\\n\");\n\t\t} else {\n\t\t\tv86d_started = 1;\n\t\t\terr = cn_netlink_send(m, 0, 0, gfp_any());\n\t\t\tif (err == -ENOBUFS)\n\t\t\t\terr = 0;\n\t\t}\n\t} else if (err == -ENOBUFS)\n\t\terr = 0;\n\n\tif (!err && !(task->t.flags & TF_EXIT))\n\t\terr = !wait_for_completion_timeout(task->done,\n\t\t\t\tmsecs_to_jiffies(UVESAFB_TIMEOUT));\n\n\tmutex_lock(&uvfb_lock);\n\tuvfb_tasks[seq] = NULL;\n\tmutex_unlock(&uvfb_lock);\n\n\tseq++;\n\tif (seq >= UVESAFB_TASKS_MAX)\n\t\tseq = 0;\nout:\n\tkfree(m);\n\treturn err;\n}\n\n/*\n * Free a uvesafb_ktask struct.\n */\nstatic void uvesafb_free(struct uvesafb_ktask *task)\n{\n\tif (task) {\n\t\tkfree(task->done);\n\t\tkfree(task);\n\t}\n}\n\n/*\n * Prepare a uvesafb_ktask struct to be used again.\n */\nstatic void uvesafb_reset(struct uvesafb_ktask *task)\n{\n\tstruct completion *cpl = task->done;\n\n\tmemset(task, 0, sizeof(*task));\n\ttask->done = cpl;\n}\n\n/*\n * Allocate and prepare a uvesafb_ktask struct.\n */\nstatic struct uvesafb_ktask *uvesafb_prep(void)\n{\n\tstruct uvesafb_ktask *task;\n\n\ttask = kzalloc(sizeof(*task), GFP_KERNEL);\n\tif (task) {\n\t\ttask->done = kzalloc(sizeof(*task->done), GFP_KERNEL);\n\t\tif (!task->done) {\n\t\t\tkfree(task);\n\t\t\ttask = NULL;\n\t\t}\n\t}\n\treturn task;\n}\n\nstatic void uvesafb_setup_var(struct fb_var_screeninfo *var,\n\t\tstruct fb_info *info, struct vbe_mode_ib *mode)\n{\n\tstruct uvesafb_par *par = info->par;\n\n\tvar->vmode = FB_VMODE_NONINTERLACED;\n\tvar->sync = FB_SYNC_VERT_HIGH_ACT;\n\n\tvar->xres = mode->x_res;\n\tvar->yres = mode->y_res;\n\tvar->xres_virtual = mode->x_res;\n\tvar->yres_virtual = (par->ypan) ?\n\t\t\tinfo->fix.smem_len / mode->bytes_per_scan_line :\n\t\t\tmode->y_res;\n\tvar->xoffset = 0;\n\tvar->yoffset = 0;\n\tvar->bits_per_pixel = mode->bits_per_pixel;\n\n\tif (var->bits_per_pixel == 15)\n\t\tvar->bits_per_pixel = 16;\n\n\tif (var->bits_per_pixel > 8) {\n\t\tvar->red.offset    = mode->red_off;\n\t\tvar->red.length    = mode->red_len;\n\t\tvar->green.offset  = mode->green_off;\n\t\tvar->green.length  = mode->green_len;\n\t\tvar->blue.offset   = mode->blue_off;\n\t\tvar->blue.length   = mode->blue_len;\n\t\tvar->transp.offset = mode->rsvd_off;\n\t\tvar->transp.length = mode->rsvd_len;\n\t} else {\n\t\tvar->red.offset    = 0;\n\t\tvar->green.offset  = 0;\n\t\tvar->blue.offset   = 0;\n\t\tvar->transp.offset = 0;\n\n\t\tvar->red.length    = 8;\n\t\tvar->green.length  = 8;\n\t\tvar->blue.length   = 8;\n\t\tvar->transp.length = 0;\n\t}\n}\n\nstatic int uvesafb_vbe_find_mode(struct uvesafb_par *par,\n\t\tint xres, int yres, int depth, unsigned char flags)\n{\n\tint i, match = -1, h = 0, d = 0x7fffffff;\n\n\tfor (i = 0; i < par->vbe_modes_cnt; i++) {\n\t\th = abs(par->vbe_modes[i].x_res - xres) +\n\t\t    abs(par->vbe_modes[i].y_res - yres) +\n\t\t    abs(depth - par->vbe_modes[i].depth);\n\n\t\t/*\n\t\t * We have an exact match in terms of resolution\n\t\t * and depth.\n\t\t */\n\t\tif (h == 0)\n\t\t\treturn i;\n\n\t\tif (h < d || (h == d && par->vbe_modes[i].depth > depth)) {\n\t\t\td = h;\n\t\t\tmatch = i;\n\t\t}\n\t}\n\ti = 1;\n\n\tif (flags & UVESAFB_EXACT_DEPTH &&\n\t\t\tpar->vbe_modes[match].depth != depth)\n\t\ti = 0;\n\n\tif (flags & UVESAFB_EXACT_RES && d > 24)\n\t\ti = 0;\n\n\tif (i != 0)\n\t\treturn match;\n\telse\n\t\treturn -1;\n}\n\nstatic u8 *uvesafb_vbe_state_save(struct uvesafb_par *par)\n{\n\tstruct uvesafb_ktask *task;\n\tu8 *state;\n\tint err;\n\n\tif (!par->vbe_state_size)\n\t\treturn NULL;\n\n\tstate = kmalloc(par->vbe_state_size, GFP_KERNEL);\n\tif (!state)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttask = uvesafb_prep();\n\tif (!task) {\n\t\tkfree(state);\n\t\treturn NULL;\n\t}\n\n\ttask->t.regs.eax = 0x4f04;\n\ttask->t.regs.ecx = 0x000f;\n\ttask->t.regs.edx = 0x0001;\n\ttask->t.flags = TF_BUF_RET | TF_BUF_ESBX;\n\ttask->t.buf_len = par->vbe_state_size;\n\ttask->buf = state;\n\terr = uvesafb_exec(task);\n\n\tif (err || (task->t.regs.eax & 0xffff) != 0x004f) {\n\t\tpr_warn(\"VBE get state call failed (eax=0x%x, err=%d)\\n\",\n\t\t\ttask->t.regs.eax, err);\n\t\tkfree(state);\n\t\tstate = NULL;\n\t}\n\n\tuvesafb_free(task);\n\treturn state;\n}\n\nstatic void uvesafb_vbe_state_restore(struct uvesafb_par *par, u8 *state_buf)\n{\n\tstruct uvesafb_ktask *task;\n\tint err;\n\n\tif (!state_buf)\n\t\treturn;\n\n\ttask = uvesafb_prep();\n\tif (!task)\n\t\treturn;\n\n\ttask->t.regs.eax = 0x4f04;\n\ttask->t.regs.ecx = 0x000f;\n\ttask->t.regs.edx = 0x0002;\n\ttask->t.buf_len = par->vbe_state_size;\n\ttask->t.flags = TF_BUF_ESBX;\n\ttask->buf = state_buf;\n\n\terr = uvesafb_exec(task);\n\tif (err || (task->t.regs.eax & 0xffff) != 0x004f)\n\t\tpr_warn(\"VBE state restore call failed (eax=0x%x, err=%d)\\n\",\n\t\t\ttask->t.regs.eax, err);\n\n\tuvesafb_free(task);\n}\n\nstatic int uvesafb_vbe_getinfo(struct uvesafb_ktask *task,\n\t\t\t       struct uvesafb_par *par)\n{\n\tint err;\n\n\ttask->t.regs.eax = 0x4f00;\n\ttask->t.flags = TF_VBEIB;\n\ttask->t.buf_len = sizeof(struct vbe_ib);\n\ttask->buf = &par->vbe_ib;\n\tstrncpy(par->vbe_ib.vbe_signature, \"VBE2\", 4);\n\n\terr = uvesafb_exec(task);\n\tif (err || (task->t.regs.eax & 0xffff) != 0x004f) {\n\t\tpr_err(\"Getting VBE info block failed (eax=0x%x, err=%d)\\n\",\n\t\t       (u32)task->t.regs.eax, err);\n\t\treturn -EINVAL;\n\t}\n\n\tif (par->vbe_ib.vbe_version < 0x0200) {\n\t\tpr_err(\"Sorry, pre-VBE 2.0 cards are not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!par->vbe_ib.mode_list_ptr) {\n\t\tpr_err(\"Missing mode list!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpr_info(\"\");\n\n\t/*\n\t * Convert string pointers and the mode list pointer into\n\t * usable addresses. Print informational messages about the\n\t * video adapter and its vendor.\n\t */\n\tif (par->vbe_ib.oem_vendor_name_ptr)\n\t\tpr_cont(\"%s, \",\n\t\t\t((char *)task->buf) + par->vbe_ib.oem_vendor_name_ptr);\n\n\tif (par->vbe_ib.oem_product_name_ptr)\n\t\tpr_cont(\"%s, \",\n\t\t\t((char *)task->buf) + par->vbe_ib.oem_product_name_ptr);\n\n\tif (par->vbe_ib.oem_product_rev_ptr)\n\t\tpr_cont(\"%s, \",\n\t\t\t((char *)task->buf) + par->vbe_ib.oem_product_rev_ptr);\n\n\tif (par->vbe_ib.oem_string_ptr)\n\t\tpr_cont(\"OEM: %s, \",\n\t\t\t((char *)task->buf) + par->vbe_ib.oem_string_ptr);\n\n\tpr_cont(\"VBE v%d.%d\\n\",\n\t\t(par->vbe_ib.vbe_version & 0xff00) >> 8,\n\t\tpar->vbe_ib.vbe_version & 0xff);\n\n\treturn 0;\n}\n\nstatic int uvesafb_vbe_getmodes(struct uvesafb_ktask *task,\n\t\t\t\tstruct uvesafb_par *par)\n{\n\tint off = 0, err;\n\tu16 *mode;\n\n\tpar->vbe_modes_cnt = 0;\n\n\t/* Count available modes. */\n\tmode = (u16 *) (((u8 *)&par->vbe_ib) + par->vbe_ib.mode_list_ptr);\n\twhile (*mode != 0xffff) {\n\t\tpar->vbe_modes_cnt++;\n\t\tmode++;\n\t}\n\n\tpar->vbe_modes = kzalloc(sizeof(struct vbe_mode_ib) *\n\t\t\t\tpar->vbe_modes_cnt, GFP_KERNEL);\n\tif (!par->vbe_modes)\n\t\treturn -ENOMEM;\n\n\t/* Get info about all available modes. */\n\tmode = (u16 *) (((u8 *)&par->vbe_ib) + par->vbe_ib.mode_list_ptr);\n\twhile (*mode != 0xffff) {\n\t\tstruct vbe_mode_ib *mib;\n\n\t\tuvesafb_reset(task);\n\t\ttask->t.regs.eax = 0x4f01;\n\t\ttask->t.regs.ecx = (u32) *mode;\n\t\ttask->t.flags = TF_BUF_RET | TF_BUF_ESDI;\n\t\ttask->t.buf_len = sizeof(struct vbe_mode_ib);\n\t\ttask->buf = par->vbe_modes + off;\n\n\t\terr = uvesafb_exec(task);\n\t\tif (err || (task->t.regs.eax & 0xffff) != 0x004f) {\n\t\t\tpr_warn(\"Getting mode info block for mode 0x%x failed (eax=0x%x, err=%d)\\n\",\n\t\t\t\t*mode, (u32)task->t.regs.eax, err);\n\t\t\tmode++;\n\t\t\tpar->vbe_modes_cnt--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmib = task->buf;\n\t\tmib->mode_id = *mode;\n\n\t\t/*\n\t\t * We only want modes that are supported with the current\n\t\t * hardware configuration, color, graphics and that have\n\t\t * support for the LFB.\n\t\t */\n\t\tif ((mib->mode_attr & VBE_MODE_MASK) == VBE_MODE_MASK &&\n\t\t\t\t mib->bits_per_pixel >= 8)\n\t\t\toff++;\n\t\telse\n\t\t\tpar->vbe_modes_cnt--;\n\n\t\tmode++;\n\t\tmib->depth = mib->red_len + mib->green_len + mib->blue_len;\n\n\t\t/*\n\t\t * Handle 8bpp modes and modes with broken color component\n\t\t * lengths.\n\t\t */\n\t\tif (mib->depth == 0 || (mib->depth == 24 &&\n\t\t\t\t\tmib->bits_per_pixel == 32))\n\t\t\tmib->depth = mib->bits_per_pixel;\n\t}\n\n\tif (par->vbe_modes_cnt > 0)\n\t\treturn 0;\n\telse\n\t\treturn -EINVAL;\n}\n\n/*\n * The Protected Mode Interface is 32-bit x86 code, so we only run it on\n * x86 and not x86_64.\n */\n#ifdef CONFIG_X86_32\nstatic int uvesafb_vbe_getpmi(struct uvesafb_ktask *task,\n\t\t\t      struct uvesafb_par *par)\n{\n\tint i, err;\n\n\tuvesafb_reset(task);\n\ttask->t.regs.eax = 0x4f0a;\n\ttask->t.regs.ebx = 0x0;\n\terr = uvesafb_exec(task);\n\n\tif ((task->t.regs.eax & 0xffff) != 0x4f || task->t.regs.es < 0xc000) {\n\t\tpar->pmi_setpal = par->ypan = 0;\n\t} else {\n\t\tpar->pmi_base = (u16 *)phys_to_virt(((u32)task->t.regs.es << 4)\n\t\t\t\t\t\t+ task->t.regs.edi);\n\t\tpar->pmi_start = (u8 *)par->pmi_base + par->pmi_base[1];\n\t\tpar->pmi_pal = (u8 *)par->pmi_base + par->pmi_base[2];\n\t\tpr_info(\"protected mode interface info at %04x:%04x\\n\",\n\t\t\t(u16)task->t.regs.es, (u16)task->t.regs.edi);\n\t\tpr_info(\"pmi: set display start = %p, set palette = %p\\n\",\n\t\t\tpar->pmi_start, par->pmi_pal);\n\n\t\tif (par->pmi_base[3]) {\n\t\t\tpr_info(\"pmi: ports =\");\n\t\t\tfor (i = par->pmi_base[3]/2;\n\t\t\t\t\tpar->pmi_base[i] != 0xffff; i++)\n\t\t\t\tpr_cont(\" %x\", par->pmi_base[i]);\n\t\t\tpr_cont(\"\\n\");\n\n\t\t\tif (par->pmi_base[i] != 0xffff) {\n\t\t\t\tpr_info(\"can't handle memory requests, pmi disabled\\n\");\n\t\t\t\tpar->ypan = par->pmi_setpal = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n#endif /* CONFIG_X86_32 */\n\n/*\n * Check whether a video mode is supported by the Video BIOS and is\n * compatible with the monitor limits.\n */\nstatic int uvesafb_is_valid_mode(struct fb_videomode *mode,\n\t\t\t\t struct fb_info *info)\n{\n\tif (info->monspecs.gtf) {\n\t\tfb_videomode_to_var(&info->var, mode);\n\t\tif (fb_validate_mode(&info->var, info))\n\t\t\treturn 0;\n\t}\n\n\tif (uvesafb_vbe_find_mode(info->par, mode->xres, mode->yres, 8,\n\t\t\t\tUVESAFB_EXACT_RES) == -1)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int uvesafb_vbe_getedid(struct uvesafb_ktask *task, struct fb_info *info)\n{\n\tstruct uvesafb_par *par = info->par;\n\tint err = 0;\n\n\tif (noedid || par->vbe_ib.vbe_version < 0x0300)\n\t\treturn -EINVAL;\n\n\ttask->t.regs.eax = 0x4f15;\n\ttask->t.regs.ebx = 0;\n\ttask->t.regs.ecx = 0;\n\ttask->t.buf_len = 0;\n\ttask->t.flags = 0;\n\n\terr = uvesafb_exec(task);\n\n\tif ((task->t.regs.eax & 0xffff) != 0x004f || err)\n\t\treturn -EINVAL;\n\n\tif ((task->t.regs.ebx & 0x3) == 3) {\n\t\tpr_info(\"VBIOS/hardware supports both DDC1 and DDC2 transfers\\n\");\n\t} else if ((task->t.regs.ebx & 0x3) == 2) {\n\t\tpr_info(\"VBIOS/hardware supports DDC2 transfers\\n\");\n\t} else if ((task->t.regs.ebx & 0x3) == 1) {\n\t\tpr_info(\"VBIOS/hardware supports DDC1 transfers\\n\");\n\t} else {\n\t\tpr_info(\"VBIOS/hardware doesn't support DDC transfers\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttask->t.regs.eax = 0x4f15;\n\ttask->t.regs.ebx = 1;\n\ttask->t.regs.ecx = task->t.regs.edx = 0;\n\ttask->t.flags = TF_BUF_RET | TF_BUF_ESDI;\n\ttask->t.buf_len = EDID_LENGTH;\n\ttask->buf = kzalloc(EDID_LENGTH, GFP_KERNEL);\n\tif (!task->buf)\n\t\treturn -ENOMEM;\n\n\terr = uvesafb_exec(task);\n\n\tif ((task->t.regs.eax & 0xffff) == 0x004f && !err) {\n\t\tfb_edid_to_monspecs(task->buf, &info->monspecs);\n\n\t\tif (info->monspecs.vfmax && info->monspecs.hfmax) {\n\t\t\t/*\n\t\t\t * If the maximum pixel clock wasn't specified in\n\t\t\t * the EDID block, set it to 300 MHz.\n\t\t\t */\n\t\t\tif (info->monspecs.dclkmax == 0)\n\t\t\t\tinfo->monspecs.dclkmax = 300 * 1000000;\n\t\t\tinfo->monspecs.gtf = 1;\n\t\t}\n\t} else {\n\t\terr = -EINVAL;\n\t}\n\n\tkfree(task->buf);\n\treturn err;\n}\n\nstatic void uvesafb_vbe_getmonspecs(struct uvesafb_ktask *task,\n\t\t\t\t    struct fb_info *info)\n{\n\tstruct uvesafb_par *par = info->par;\n\tint i;\n\n\tmemset(&info->monspecs, 0, sizeof(info->monspecs));\n\n\t/*\n\t * If we don't get all necessary data from the EDID block,\n\t * mark it as incompatible with the GTF and set nocrtc so\n\t * that we always use the default BIOS refresh rate.\n\t */\n\tif (uvesafb_vbe_getedid(task, info)) {\n\t\tinfo->monspecs.gtf = 0;\n\t\tpar->nocrtc = 1;\n\t}\n\n\t/* Kernel command line overrides. */\n\tif (maxclk)\n\t\tinfo->monspecs.dclkmax = maxclk * 1000000;\n\tif (maxvf)\n\t\tinfo->monspecs.vfmax = maxvf;\n\tif (maxhf)\n\t\tinfo->monspecs.hfmax = maxhf * 1000;\n\n\t/*\n\t * In case DDC transfers are not supported, the user can provide\n\t * monitor limits manually. Lower limits are set to \"safe\" values.\n\t */\n\tif (info->monspecs.gtf == 0 && maxclk && maxvf && maxhf) {\n\t\tinfo->monspecs.dclkmin = 0;\n\t\tinfo->monspecs.vfmin = 60;\n\t\tinfo->monspecs.hfmin = 29000;\n\t\tinfo->monspecs.gtf = 1;\n\t\tpar->nocrtc = 0;\n\t}\n\n\tif (info->monspecs.gtf)\n\t\tpr_info(\"monitor limits: vf = %d Hz, hf = %d kHz, clk = %d MHz\\n\",\n\t\t\tinfo->monspecs.vfmax,\n\t\t\t(int)(info->monspecs.hfmax / 1000),\n\t\t\t(int)(info->monspecs.dclkmax / 1000000));\n\telse\n\t\tpr_info(\"no monitor limits have been set, default refresh rate will be used\\n\");\n\n\t/* Add VBE modes to the modelist. */\n\tfor (i = 0; i < par->vbe_modes_cnt; i++) {\n\t\tstruct fb_var_screeninfo var;\n\t\tstruct vbe_mode_ib *mode;\n\t\tstruct fb_videomode vmode;\n\n\t\tmode = &par->vbe_modes[i];\n\t\tmemset(&var, 0, sizeof(var));\n\n\t\tvar.xres = mode->x_res;\n\t\tvar.yres = mode->y_res;\n\n\t\tfb_get_mode(FB_VSYNCTIMINGS | FB_IGNOREMON, 60, &var, info);\n\t\tfb_var_to_videomode(&vmode, &var);\n\t\tfb_add_videomode(&vmode, &info->modelist);\n\t}\n\n\t/* Add valid VESA modes to our modelist. */\n\tfor (i = 0; i < VESA_MODEDB_SIZE; i++) {\n\t\tif (uvesafb_is_valid_mode((struct fb_videomode *)\n\t\t\t\t\t\t&vesa_modes[i], info))\n\t\t\tfb_add_videomode(&vesa_modes[i], &info->modelist);\n\t}\n\n\tfor (i = 0; i < info->monspecs.modedb_len; i++) {\n\t\tif (uvesafb_is_valid_mode(&info->monspecs.modedb[i], info))\n\t\t\tfb_add_videomode(&info->monspecs.modedb[i],\n\t\t\t\t\t&info->modelist);\n\t}\n\n\treturn;\n}\n\nstatic void uvesafb_vbe_getstatesize(struct uvesafb_ktask *task,\n\t\t\t\t     struct uvesafb_par *par)\n{\n\tint err;\n\n\tuvesafb_reset(task);\n\n\t/*\n\t * Get the VBE state buffer size. We want all available\n\t * hardware state data (CL = 0x0f).\n\t */\n\ttask->t.regs.eax = 0x4f04;\n\ttask->t.regs.ecx = 0x000f;\n\ttask->t.regs.edx = 0x0000;\n\ttask->t.flags = 0;\n\n\terr = uvesafb_exec(task);\n\n\tif (err || (task->t.regs.eax & 0xffff) != 0x004f) {\n\t\tpr_warn(\"VBE state buffer size cannot be determined (eax=0x%x, err=%d)\\n\",\n\t\t\ttask->t.regs.eax, err);\n\t\tpar->vbe_state_size = 0;\n\t\treturn;\n\t}\n\n\tpar->vbe_state_size = 64 * (task->t.regs.ebx & 0xffff);\n}\n\nstatic int uvesafb_vbe_init(struct fb_info *info)\n{\n\tstruct uvesafb_ktask *task = NULL;\n\tstruct uvesafb_par *par = info->par;\n\tint err;\n\n\ttask = uvesafb_prep();\n\tif (!task)\n\t\treturn -ENOMEM;\n\n\terr = uvesafb_vbe_getinfo(task, par);\n\tif (err)\n\t\tgoto out;\n\n\terr = uvesafb_vbe_getmodes(task, par);\n\tif (err)\n\t\tgoto out;\n\n\tpar->nocrtc = nocrtc;\n#ifdef CONFIG_X86_32\n\tpar->pmi_setpal = pmi_setpal;\n\tpar->ypan = ypan;\n\n\tif (par->pmi_setpal || par->ypan) {\n\t\tif (__supported_pte_mask & _PAGE_NX) {\n\t\t\tpar->pmi_setpal = par->ypan = 0;\n\t\t\tpr_warn(\"NX protection is active, better not use the PMI\\n\");\n\t\t} else {\n\t\t\tuvesafb_vbe_getpmi(task, par);\n\t\t}\n\t}\n#else\n\t/* The protected mode interface is not available on non-x86. */\n\tpar->pmi_setpal = par->ypan = 0;\n#endif\n\n\tINIT_LIST_HEAD(&info->modelist);\n\tuvesafb_vbe_getmonspecs(task, info);\n\tuvesafb_vbe_getstatesize(task, par);\n\nout:\tuvesafb_free(task);\n\treturn err;\n}\n\nstatic int uvesafb_vbe_init_mode(struct fb_info *info)\n{\n\tstruct list_head *pos;\n\tstruct fb_modelist *modelist;\n\tstruct fb_videomode *mode;\n\tstruct uvesafb_par *par = info->par;\n\tint i, modeid;\n\n\t/* Has the user requested a specific VESA mode? */\n\tif (vbemode) {\n\t\tfor (i = 0; i < par->vbe_modes_cnt; i++) {\n\t\t\tif (par->vbe_modes[i].mode_id == vbemode) {\n\t\t\t\tmodeid = i;\n\t\t\t\tuvesafb_setup_var(&info->var, info,\n\t\t\t\t\t\t&par->vbe_modes[modeid]);\n\t\t\t\tfb_get_mode(FB_VSYNCTIMINGS | FB_IGNOREMON, 60,\n\t\t\t\t\t\t&info->var, info);\n\t\t\t\t/*\n\t\t\t\t * With pixclock set to 0, the default BIOS\n\t\t\t\t * timings will be used in set_par().\n\t\t\t\t */\n\t\t\t\tinfo->var.pixclock = 0;\n\t\t\t\tgoto gotmode;\n\t\t\t}\n\t\t}\n\t\tpr_info(\"requested VBE mode 0x%x is unavailable\\n\", vbemode);\n\t\tvbemode = 0;\n\t}\n\n\t/* Count the modes in the modelist */\n\ti = 0;\n\tlist_for_each(pos, &info->modelist)\n\t\ti++;\n\n\t/*\n\t * Convert the modelist into a modedb so that we can use it with\n\t * fb_find_mode().\n\t */\n\tmode = kzalloc(i * sizeof(*mode), GFP_KERNEL);\n\tif (mode) {\n\t\ti = 0;\n\t\tlist_for_each(pos, &info->modelist) {\n\t\t\tmodelist = list_entry(pos, struct fb_modelist, list);\n\t\t\tmode[i] = modelist->mode;\n\t\t\ti++;\n\t\t}\n\n\t\tif (!mode_option)\n\t\t\tmode_option = UVESAFB_DEFAULT_MODE;\n\n\t\ti = fb_find_mode(&info->var, info, mode_option, mode, i,\n\t\t\tNULL, 8);\n\n\t\tkfree(mode);\n\t}\n\n\t/* fb_find_mode() failed */\n\tif (i == 0) {\n\t\tinfo->var.xres = 640;\n\t\tinfo->var.yres = 480;\n\t\tmode = (struct fb_videomode *)\n\t\t\t\tfb_find_best_mode(&info->var, &info->modelist);\n\n\t\tif (mode) {\n\t\t\tfb_videomode_to_var(&info->var, mode);\n\t\t} else {\n\t\t\tmodeid = par->vbe_modes[0].mode_id;\n\t\t\tuvesafb_setup_var(&info->var, info,\n\t\t\t\t\t&par->vbe_modes[modeid]);\n\t\t\tfb_get_mode(FB_VSYNCTIMINGS | FB_IGNOREMON, 60,\n\t\t\t\t\t&info->var, info);\n\n\t\t\tgoto gotmode;\n\t\t}\n\t}\n\n\t/* Look for a matching VBE mode. */\n\tmodeid = uvesafb_vbe_find_mode(par, info->var.xres, info->var.yres,\n\t\t\tinfo->var.bits_per_pixel, UVESAFB_EXACT_RES);\n\n\tif (modeid == -1)\n\t\treturn -EINVAL;\n\n\tuvesafb_setup_var(&info->var, info, &par->vbe_modes[modeid]);\n\ngotmode:\n\t/*\n\t * If we are not VBE3.0+ compliant, we're done -- the BIOS will\n\t * ignore our timings anyway.\n\t */\n\tif (par->vbe_ib.vbe_version < 0x0300 || par->nocrtc)\n\t\tfb_get_mode(FB_VSYNCTIMINGS | FB_IGNOREMON, 60,\n\t\t\t\t\t&info->var, info);\n\n\treturn modeid;\n}\n\nstatic int uvesafb_setpalette(struct uvesafb_pal_entry *entries, int count,\n\t\tint start, struct fb_info *info)\n{\n\tstruct uvesafb_ktask *task;\n#ifdef CONFIG_X86\n\tstruct uvesafb_par *par = info->par;\n\tint i = par->mode_idx;\n#endif\n\tint err = 0;\n\n\t/*\n\t * We support palette modifications for 8 bpp modes only, so\n\t * there can never be more than 256 entries.\n\t */\n\tif (start + count > 256)\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_X86\n\t/* Use VGA registers if mode is VGA-compatible. */\n\tif (i >= 0 && i < par->vbe_modes_cnt &&\n\t    par->vbe_modes[i].mode_attr & VBE_MODE_VGACOMPAT) {\n\t\tfor (i = 0; i < count; i++) {\n\t\t\toutb_p(start + i,        dac_reg);\n\t\t\toutb_p(entries[i].red,   dac_val);\n\t\t\toutb_p(entries[i].green, dac_val);\n\t\t\toutb_p(entries[i].blue,  dac_val);\n\t\t}\n\t}\n#ifdef CONFIG_X86_32\n\telse if (par->pmi_setpal) {\n\t\t__asm__ __volatile__(\n\t\t\"call *(%%esi)\"\n\t\t: /* no return value */\n\t\t: \"a\" (0x4f09),         /* EAX */\n\t\t  \"b\" (0),              /* EBX */\n\t\t  \"c\" (count),          /* ECX */\n\t\t  \"d\" (start),          /* EDX */\n\t\t  \"D\" (entries),        /* EDI */\n\t\t  \"S\" (&par->pmi_pal)); /* ESI */\n\t}\n#endif /* CONFIG_X86_32 */\n\telse\n#endif /* CONFIG_X86 */\n\t{\n\t\ttask = uvesafb_prep();\n\t\tif (!task)\n\t\t\treturn -ENOMEM;\n\n\t\ttask->t.regs.eax = 0x4f09;\n\t\ttask->t.regs.ebx = 0x0;\n\t\ttask->t.regs.ecx = count;\n\t\ttask->t.regs.edx = start;\n\t\ttask->t.flags = TF_BUF_ESDI;\n\t\ttask->t.buf_len = sizeof(struct uvesafb_pal_entry) * count;\n\t\ttask->buf = entries;\n\n\t\terr = uvesafb_exec(task);\n\t\tif ((task->t.regs.eax & 0xffff) != 0x004f)\n\t\t\terr = 1;\n\n\t\tuvesafb_free(task);\n\t}\n\treturn err;\n}\n\nstatic int uvesafb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\tunsigned blue, unsigned transp,\n\t\tstruct fb_info *info)\n{\n\tstruct uvesafb_pal_entry entry;\n\tint shift = 16 - dac_width;\n\tint err = 0;\n\n\tif (regno >= info->cmap.len)\n\t\treturn -EINVAL;\n\n\tif (info->var.bits_per_pixel == 8) {\n\t\tentry.red   = red   >> shift;\n\t\tentry.green = green >> shift;\n\t\tentry.blue  = blue  >> shift;\n\t\tentry.pad   = 0;\n\n\t\terr = uvesafb_setpalette(&entry, 1, regno, info);\n\t} else if (regno < 16) {\n\t\tswitch (info->var.bits_per_pixel) {\n\t\tcase 16:\n\t\t\tif (info->var.red.offset == 10) {\n\t\t\t\t/* 1:5:5:5 */\n\t\t\t\t((u32 *) (info->pseudo_palette))[regno] =\n\t\t\t\t\t\t((red   & 0xf800) >>  1) |\n\t\t\t\t\t\t((green & 0xf800) >>  6) |\n\t\t\t\t\t\t((blue  & 0xf800) >> 11);\n\t\t\t} else {\n\t\t\t\t/* 0:5:6:5 */\n\t\t\t\t((u32 *) (info->pseudo_palette))[regno] =\n\t\t\t\t\t\t((red   & 0xf800)      ) |\n\t\t\t\t\t\t((green & 0xfc00) >>  5) |\n\t\t\t\t\t\t((blue  & 0xf800) >> 11);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 24:\n\t\tcase 32:\n\t\t\tred   >>= 8;\n\t\t\tgreen >>= 8;\n\t\t\tblue  >>= 8;\n\t\t\t((u32 *)(info->pseudo_palette))[regno] =\n\t\t\t\t(red   << info->var.red.offset)   |\n\t\t\t\t(green << info->var.green.offset) |\n\t\t\t\t(blue  << info->var.blue.offset);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tstruct uvesafb_pal_entry *entries;\n\tint shift = 16 - dac_width;\n\tint i, err = 0;\n\n\tif (info->var.bits_per_pixel == 8) {\n\t\tif (cmap->start + cmap->len > info->cmap.start +\n\t\t    info->cmap.len || cmap->start < info->cmap.start)\n\t\t\treturn -EINVAL;\n\n\t\tentries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);\n\t\tif (!entries)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\tentries[i].red   = cmap->red[i]   >> shift;\n\t\t\tentries[i].green = cmap->green[i] >> shift;\n\t\t\tentries[i].blue  = cmap->blue[i]  >> shift;\n\t\t\tentries[i].pad   = 0;\n\t\t}\n\t\terr = uvesafb_setpalette(entries, cmap->len, cmap->start, info);\n\t\tkfree(entries);\n\t} else {\n\t\t/*\n\t\t * For modes with bpp > 8, we only set the pseudo palette in\n\t\t * the fb_info struct. We rely on uvesafb_setcolreg to do all\n\t\t * sanity checking.\n\t\t */\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\terr |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],\n\t\t\t\t\t\tcmap->green[i], cmap->blue[i],\n\t\t\t\t\t\t0, info);\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int uvesafb_pan_display(struct fb_var_screeninfo *var,\n\t\tstruct fb_info *info)\n{\n#ifdef CONFIG_X86_32\n\tint offset;\n\tstruct uvesafb_par *par = info->par;\n\n\toffset = (var->yoffset * info->fix.line_length + var->xoffset) / 4;\n\n\t/*\n\t * It turns out it's not the best idea to do panning via vm86,\n\t * so we only allow it if we have a PMI.\n\t */\n\tif (par->pmi_start) {\n\t\t__asm__ __volatile__(\n\t\t\t\"call *(%%edi)\"\n\t\t\t: /* no return value */\n\t\t\t: \"a\" (0x4f07),         /* EAX */\n\t\t\t  \"b\" (0),              /* EBX */\n\t\t\t  \"c\" (offset),         /* ECX */\n\t\t\t  \"d\" (offset >> 16),   /* EDX */\n\t\t\t  \"D\" (&par->pmi_start));    /* EDI */\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int uvesafb_blank(int blank, struct fb_info *info)\n{\n\tstruct uvesafb_ktask *task;\n\tint err = 1;\n#ifdef CONFIG_X86\n\tstruct uvesafb_par *par = info->par;\n\n\tif (par->vbe_ib.capabilities & VBE_CAP_VGACOMPAT) {\n\t\tint loop = 10000;\n\t\tu8 seq = 0, crtc17 = 0;\n\n\t\tif (blank == FB_BLANK_POWERDOWN) {\n\t\t\tseq = 0x20;\n\t\t\tcrtc17 = 0x00;\n\t\t\terr = 0;\n\t\t} else {\n\t\t\tseq = 0x00;\n\t\t\tcrtc17 = 0x80;\n\t\t\terr = (blank == FB_BLANK_UNBLANK) ? 0 : -EINVAL;\n\t\t}\n\n\t\tvga_wseq(NULL, 0x00, 0x01);\n\t\tseq |= vga_rseq(NULL, 0x01) & ~0x20;\n\t\tvga_wseq(NULL, 0x00, seq);\n\n\t\tcrtc17 |= vga_rcrt(NULL, 0x17) & ~0x80;\n\t\twhile (loop--);\n\t\tvga_wcrt(NULL, 0x17, crtc17);\n\t\tvga_wseq(NULL, 0x00, 0x03);\n\t} else\n#endif /* CONFIG_X86 */\n\t{\n\t\ttask = uvesafb_prep();\n\t\tif (!task)\n\t\t\treturn -ENOMEM;\n\n\t\ttask->t.regs.eax = 0x4f10;\n\t\tswitch (blank) {\n\t\tcase FB_BLANK_UNBLANK:\n\t\t\ttask->t.regs.ebx = 0x0001;\n\t\t\tbreak;\n\t\tcase FB_BLANK_NORMAL:\n\t\t\ttask->t.regs.ebx = 0x0101;\t/* standby */\n\t\t\tbreak;\n\t\tcase FB_BLANK_POWERDOWN:\n\t\t\ttask->t.regs.ebx = 0x0401;\t/* powerdown */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = uvesafb_exec(task);\n\t\tif (err || (task->t.regs.eax & 0xffff) != 0x004f)\n\t\t\terr = 1;\nout:\t\tuvesafb_free(task);\n\t}\n\treturn err;\n}\n\nstatic int uvesafb_open(struct fb_info *info, int user)\n{\n\tstruct uvesafb_par *par = info->par;\n\tint cnt = atomic_read(&par->ref_count);\n\tu8 *buf = NULL;\n\n\tif (!cnt && par->vbe_state_size) {\n\t\tbuf =  uvesafb_vbe_state_save(par);\n\t\tif (IS_ERR(buf)) {\n\t\t\tpr_warn(\"save hardware state failed, error code is %ld!\\n\",\n\t\t\t\tPTR_ERR(buf));\n\t\t} else {\n\t\t\tpar->vbe_state_orig = buf;\n\t\t}\n\t}\n\n\tatomic_inc(&par->ref_count);\n\treturn 0;\n}\n\nstatic int uvesafb_release(struct fb_info *info, int user)\n{\n\tstruct uvesafb_ktask *task = NULL;\n\tstruct uvesafb_par *par = info->par;\n\tint cnt = atomic_read(&par->ref_count);\n\n\tif (!cnt)\n\t\treturn -EINVAL;\n\n\tif (cnt != 1)\n\t\tgoto out;\n\n\ttask = uvesafb_prep();\n\tif (!task)\n\t\tgoto out;\n\n\t/* First, try to set the standard 80x25 text mode. */\n\ttask->t.regs.eax = 0x0003;\n\tuvesafb_exec(task);\n\n\t/*\n\t * Now try to restore whatever hardware state we might have\n\t * saved when the fb device was first opened.\n\t */\n\tuvesafb_vbe_state_restore(par, par->vbe_state_orig);\nout:\n\tatomic_dec(&par->ref_count);\n\tuvesafb_free(task);\n\treturn 0;\n}\n\nstatic int uvesafb_set_par(struct fb_info *info)\n{\n\tstruct uvesafb_par *par = info->par;\n\tstruct uvesafb_ktask *task = NULL;\n\tstruct vbe_crtc_ib *crtc = NULL;\n\tstruct vbe_mode_ib *mode = NULL;\n\tint i, err = 0, depth = info->var.bits_per_pixel;\n\n\tif (depth > 8 && depth != 32)\n\t\tdepth = info->var.red.length + info->var.green.length +\n\t\t\tinfo->var.blue.length;\n\n\ti = uvesafb_vbe_find_mode(par, info->var.xres, info->var.yres, depth,\n\t\t\t\t UVESAFB_EXACT_RES | UVESAFB_EXACT_DEPTH);\n\tif (i >= 0)\n\t\tmode = &par->vbe_modes[i];\n\telse\n\t\treturn -EINVAL;\n\n\ttask = uvesafb_prep();\n\tif (!task)\n\t\treturn -ENOMEM;\nsetmode:\n\ttask->t.regs.eax = 0x4f02;\n\ttask->t.regs.ebx = mode->mode_id | 0x4000;\t/* use LFB */\n\n\tif (par->vbe_ib.vbe_version >= 0x0300 && !par->nocrtc &&\n\t    info->var.pixclock != 0) {\n\t\ttask->t.regs.ebx |= 0x0800;\t\t/* use CRTC data */\n\t\ttask->t.flags = TF_BUF_ESDI;\n\t\tcrtc = kzalloc(sizeof(struct vbe_crtc_ib), GFP_KERNEL);\n\t\tif (!crtc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tcrtc->horiz_start = info->var.xres + info->var.right_margin;\n\t\tcrtc->horiz_end\t  = crtc->horiz_start + info->var.hsync_len;\n\t\tcrtc->horiz_total = crtc->horiz_end + info->var.left_margin;\n\n\t\tcrtc->vert_start  = info->var.yres + info->var.lower_margin;\n\t\tcrtc->vert_end    = crtc->vert_start + info->var.vsync_len;\n\t\tcrtc->vert_total  = crtc->vert_end + info->var.upper_margin;\n\n\t\tcrtc->pixel_clock = PICOS2KHZ(info->var.pixclock) * 1000;\n\t\tcrtc->refresh_rate = (u16)(100 * (crtc->pixel_clock /\n\t\t\t\t(crtc->vert_total * crtc->horiz_total)));\n\n\t\tif (info->var.vmode & FB_VMODE_DOUBLE)\n\t\t\tcrtc->flags |= 0x1;\n\t\tif (info->var.vmode & FB_VMODE_INTERLACED)\n\t\t\tcrtc->flags |= 0x2;\n\t\tif (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))\n\t\t\tcrtc->flags |= 0x4;\n\t\tif (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))\n\t\t\tcrtc->flags |= 0x8;\n\t\tmemcpy(&par->crtc, crtc, sizeof(*crtc));\n\t} else {\n\t\tmemset(&par->crtc, 0, sizeof(*crtc));\n\t}\n\n\ttask->t.buf_len = sizeof(struct vbe_crtc_ib);\n\ttask->buf = &par->crtc;\n\n\terr = uvesafb_exec(task);\n\tif (err || (task->t.regs.eax & 0xffff) != 0x004f) {\n\t\t/*\n\t\t * The mode switch might have failed because we tried to\n\t\t * use our own timings.  Try again with the default timings.\n\t\t */\n\t\tif (crtc != NULL) {\n\t\t\tpr_warn(\"mode switch failed (eax=0x%x, err=%d) - trying again with default timings\\n\",\n\t\t\t\ttask->t.regs.eax, err);\n\t\t\tuvesafb_reset(task);\n\t\t\tkfree(crtc);\n\t\t\tcrtc = NULL;\n\t\t\tinfo->var.pixclock = 0;\n\t\t\tgoto setmode;\n\t\t} else {\n\t\t\tpr_err(\"mode switch failed (eax=0x%x, err=%d)\\n\",\n\t\t\t       task->t.regs.eax, err);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tpar->mode_idx = i;\n\n\t/* For 8bpp modes, always try to set the DAC to 8 bits. */\n\tif (par->vbe_ib.capabilities & VBE_CAP_CAN_SWITCH_DAC &&\n\t    mode->bits_per_pixel <= 8) {\n\t\tuvesafb_reset(task);\n\t\ttask->t.regs.eax = 0x4f08;\n\t\ttask->t.regs.ebx = 0x0800;\n\n\t\terr = uvesafb_exec(task);\n\t\tif (err || (task->t.regs.eax & 0xffff) != 0x004f ||\n\t\t    ((task->t.regs.ebx & 0xff00) >> 8) != 8) {\n\t\t\tdac_width = 6;\n\t\t} else {\n\t\t\tdac_width = 8;\n\t\t}\n\t}\n\n\tinfo->fix.visual = (info->var.bits_per_pixel == 8) ?\n\t\t\t\tFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\n\tinfo->fix.line_length = mode->bytes_per_scan_line;\n\nout:\n\tkfree(crtc);\n\tuvesafb_free(task);\n\n\treturn err;\n}\n\nstatic void uvesafb_check_limits(struct fb_var_screeninfo *var,\n\t\tstruct fb_info *info)\n{\n\tconst struct fb_videomode *mode;\n\tstruct uvesafb_par *par = info->par;\n\n\t/*\n\t * If pixclock is set to 0, then we're using default BIOS timings\n\t * and thus don't have to perform any checks here.\n\t */\n\tif (!var->pixclock)\n\t\treturn;\n\n\tif (par->vbe_ib.vbe_version < 0x0300) {\n\t\tfb_get_mode(FB_VSYNCTIMINGS | FB_IGNOREMON, 60, var, info);\n\t\treturn;\n\t}\n\n\tif (!fb_validate_mode(var, info))\n\t\treturn;\n\n\tmode = fb_find_best_mode(var, &info->modelist);\n\tif (mode) {\n\t\tif (mode->xres == var->xres && mode->yres == var->yres &&\n\t\t    !(mode->vmode & (FB_VMODE_INTERLACED | FB_VMODE_DOUBLE))) {\n\t\t\tfb_videomode_to_var(var, mode);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (info->monspecs.gtf && !fb_get_mode(FB_MAXTIMINGS, 0, var, info))\n\t\treturn;\n\t/* Use default refresh rate */\n\tvar->pixclock = 0;\n}\n\nstatic int uvesafb_check_var(struct fb_var_screeninfo *var,\n\t\tstruct fb_info *info)\n{\n\tstruct uvesafb_par *par = info->par;\n\tstruct vbe_mode_ib *mode = NULL;\n\tint match = -1;\n\tint depth = var->red.length + var->green.length + var->blue.length;\n\n\t/*\n\t * Various apps will use bits_per_pixel to set the color depth,\n\t * which is theoretically incorrect, but which we'll try to handle\n\t * here.\n\t */\n\tif (depth == 0 || abs(depth - var->bits_per_pixel) >= 8)\n\t\tdepth = var->bits_per_pixel;\n\n\tmatch = uvesafb_vbe_find_mode(par, var->xres, var->yres, depth,\n\t\t\t\t\t\tUVESAFB_EXACT_RES);\n\tif (match == -1)\n\t\treturn -EINVAL;\n\n\tmode = &par->vbe_modes[match];\n\tuvesafb_setup_var(var, info, mode);\n\n\t/*\n\t * Check whether we have remapped enough memory for this mode.\n\t * We might be called at an early stage, when we haven't remapped\n\t * any memory yet, in which case we simply skip the check.\n\t */\n\tif (var->yres * mode->bytes_per_scan_line > info->fix.smem_len\n\t\t\t\t\t\t&& info->fix.smem_len)\n\t\treturn -EINVAL;\n\n\tif ((var->vmode & FB_VMODE_DOUBLE) &&\n\t\t\t\t!(par->vbe_modes[match].mode_attr & 0x100))\n\t\tvar->vmode &= ~FB_VMODE_DOUBLE;\n\n\tif ((var->vmode & FB_VMODE_INTERLACED) &&\n\t\t\t\t!(par->vbe_modes[match].mode_attr & 0x200))\n\t\tvar->vmode &= ~FB_VMODE_INTERLACED;\n\n\tuvesafb_check_limits(var, info);\n\n\tvar->xres_virtual = var->xres;\n\tvar->yres_virtual = (par->ypan) ?\n\t\t\t\tinfo->fix.smem_len / mode->bytes_per_scan_line :\n\t\t\t\tvar->yres;\n\treturn 0;\n}\n\nstatic struct fb_ops uvesafb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_open\t= uvesafb_open,\n\t.fb_release\t= uvesafb_release,\n\t.fb_setcolreg\t= uvesafb_setcolreg,\n\t.fb_setcmap\t= uvesafb_setcmap,\n\t.fb_pan_display\t= uvesafb_pan_display,\n\t.fb_blank\t= uvesafb_blank,\n\t.fb_fillrect\t= cfb_fillrect,\n\t.fb_copyarea\t= cfb_copyarea,\n\t.fb_imageblit\t= cfb_imageblit,\n\t.fb_check_var\t= uvesafb_check_var,\n\t.fb_set_par\t= uvesafb_set_par,\n};\n\nstatic void uvesafb_init_info(struct fb_info *info, struct vbe_mode_ib *mode)\n{\n\tunsigned int size_vmode;\n\tunsigned int size_remap;\n\tunsigned int size_total;\n\tstruct uvesafb_par *par = info->par;\n\tint i, h;\n\n\tinfo->pseudo_palette = ((u8 *)info->par + sizeof(struct uvesafb_par));\n\tinfo->fix = uvesafb_fix;\n\tinfo->fix.ypanstep = par->ypan ? 1 : 0;\n\tinfo->fix.ywrapstep = (par->ypan > 1) ? 1 : 0;\n\n\t/* Disable blanking if the user requested so. */\n\tif (!blank)\n\t\tinfo->fbops->fb_blank = NULL;\n\n\t/*\n\t * Find out how much IO memory is required for the mode with\n\t * the highest resolution.\n\t */\n\tsize_remap = 0;\n\tfor (i = 0; i < par->vbe_modes_cnt; i++) {\n\t\th = par->vbe_modes[i].bytes_per_scan_line *\n\t\t\t\t\tpar->vbe_modes[i].y_res;\n\t\tif (h > size_remap)\n\t\t\tsize_remap = h;\n\t}\n\tsize_remap *= 2;\n\n\t/*\n\t *   size_vmode -- that is the amount of memory needed for the\n\t *                 used video mode, i.e. the minimum amount of\n\t *                 memory we need.\n\t */\n\tsize_vmode = info->var.yres * mode->bytes_per_scan_line;\n\n\t/*\n\t *   size_total -- all video memory we have. Used for mtrr\n\t *                 entries, resource allocation and bounds\n\t *                 checking.\n\t */\n\tsize_total = par->vbe_ib.total_memory * 65536;\n\tif (vram_total)\n\t\tsize_total = vram_total * 1024 * 1024;\n\tif (size_total < size_vmode)\n\t\tsize_total = size_vmode;\n\n\t/*\n\t *   size_remap -- the amount of video memory we are going to\n\t *                 use for vesafb.  With modern cards it is no\n\t *                 option to simply use size_total as th\n\t *                 wastes plenty of kernel address space.\n\t */\n\tif (vram_remap)\n\t\tsize_remap = vram_remap * 1024 * 1024;\n\tif (size_remap < size_vmode)\n\t\tsize_remap = size_vmode;\n\tif (size_remap > size_total)\n\t\tsize_remap = size_total;\n\n\tinfo->fix.smem_len = size_remap;\n\tinfo->fix.smem_start = mode->phys_base_ptr;\n\n\t/*\n\t * We have to set yres_virtual here because when setup_var() was\n\t * called, smem_len wasn't defined yet.\n\t */\n\tinfo->var.yres_virtual = info->fix.smem_len /\n\t\t\t\t mode->bytes_per_scan_line;\n\n\tif (par->ypan && info->var.yres_virtual > info->var.yres) {\n\t\tpr_info(\"scrolling: %s using protected mode interface, yres_virtual=%d\\n\",\n\t\t\t(par->ypan > 1) ? \"ywrap\" : \"ypan\",\n\t\t\tinfo->var.yres_virtual);\n\t} else {\n\t\tpr_info(\"scrolling: redraw\\n\");\n\t\tinfo->var.yres_virtual = info->var.yres;\n\t\tpar->ypan = 0;\n\t}\n\n\tinfo->flags = FBINFO_FLAG_DEFAULT |\n\t\t\t(par->ypan ? FBINFO_HWACCEL_YPAN : 0);\n\n\tif (!par->ypan)\n\t\tinfo->fbops->fb_pan_display = NULL;\n}\n\nstatic void uvesafb_init_mtrr(struct fb_info *info)\n{\n\tstruct uvesafb_par *par = info->par;\n\n\tif (mtrr && !(info->fix.smem_start & (PAGE_SIZE - 1))) {\n\t\tint temp_size = info->fix.smem_len;\n\n\t\tint rc;\n\n\t\t/* Find the largest power-of-two */\n\t\ttemp_size = roundup_pow_of_two(temp_size);\n\n\t\t/* Try and find a power of two to add */\n\t\tdo {\n\t\t\trc = arch_phys_wc_add(info->fix.smem_start, temp_size);\n\t\t\ttemp_size >>= 1;\n\t\t} while (temp_size >= PAGE_SIZE && rc == -EINVAL);\n\n\t\tif (rc >= 0)\n\t\t\tpar->mtrr_handle = rc;\n\t}\n}\n\nstatic void uvesafb_ioremap(struct fb_info *info)\n{\n\tinfo->screen_base = ioremap_wc(info->fix.smem_start, info->fix.smem_len);\n}\n\nstatic ssize_t uvesafb_show_vbe_ver(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\n\tstruct uvesafb_par *par = info->par;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%.4x\\n\", par->vbe_ib.vbe_version);\n}\n\nstatic DEVICE_ATTR(vbe_version, S_IRUGO, uvesafb_show_vbe_ver, NULL);\n\nstatic ssize_t uvesafb_show_vbe_modes(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\n\tstruct uvesafb_par *par = info->par;\n\tint ret = 0, i;\n\n\tfor (i = 0; i < par->vbe_modes_cnt && ret < PAGE_SIZE; i++) {\n\t\tret += snprintf(buf + ret, PAGE_SIZE - ret,\n\t\t\t\"%dx%d-%d, 0x%.4x\\n\",\n\t\t\tpar->vbe_modes[i].x_res, par->vbe_modes[i].y_res,\n\t\t\tpar->vbe_modes[i].depth, par->vbe_modes[i].mode_id);\n\t}\n\n\treturn ret;\n}\n\nstatic DEVICE_ATTR(vbe_modes, S_IRUGO, uvesafb_show_vbe_modes, NULL);\n\nstatic ssize_t uvesafb_show_vendor(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\n\tstruct uvesafb_par *par = info->par;\n\n\tif (par->vbe_ib.oem_vendor_name_ptr)\n\t\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", (char *)\n\t\t\t(&par->vbe_ib) + par->vbe_ib.oem_vendor_name_ptr);\n\telse\n\t\treturn 0;\n}\n\nstatic DEVICE_ATTR(oem_vendor, S_IRUGO, uvesafb_show_vendor, NULL);\n\nstatic ssize_t uvesafb_show_product_name(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\n\tstruct uvesafb_par *par = info->par;\n\n\tif (par->vbe_ib.oem_product_name_ptr)\n\t\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", (char *)\n\t\t\t(&par->vbe_ib) + par->vbe_ib.oem_product_name_ptr);\n\telse\n\t\treturn 0;\n}\n\nstatic DEVICE_ATTR(oem_product_name, S_IRUGO, uvesafb_show_product_name, NULL);\n\nstatic ssize_t uvesafb_show_product_rev(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\n\tstruct uvesafb_par *par = info->par;\n\n\tif (par->vbe_ib.oem_product_rev_ptr)\n\t\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", (char *)\n\t\t\t(&par->vbe_ib) + par->vbe_ib.oem_product_rev_ptr);\n\telse\n\t\treturn 0;\n}\n\nstatic DEVICE_ATTR(oem_product_rev, S_IRUGO, uvesafb_show_product_rev, NULL);\n\nstatic ssize_t uvesafb_show_oem_string(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\n\tstruct uvesafb_par *par = info->par;\n\n\tif (par->vbe_ib.oem_string_ptr)\n\t\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t\t(char *)(&par->vbe_ib) + par->vbe_ib.oem_string_ptr);\n\telse\n\t\treturn 0;\n}\n\nstatic DEVICE_ATTR(oem_string, S_IRUGO, uvesafb_show_oem_string, NULL);\n\nstatic ssize_t uvesafb_show_nocrtc(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\n\tstruct uvesafb_par *par = info->par;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", par->nocrtc);\n}\n\nstatic ssize_t uvesafb_store_nocrtc(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\n\tstruct uvesafb_par *par = info->par;\n\n\tif (count > 0) {\n\t\tif (buf[0] == '0')\n\t\t\tpar->nocrtc = 0;\n\t\telse\n\t\t\tpar->nocrtc = 1;\n\t}\n\treturn count;\n}\n\nstatic DEVICE_ATTR(nocrtc, S_IRUGO | S_IWUSR, uvesafb_show_nocrtc,\n\t\t\tuvesafb_store_nocrtc);\n\nstatic struct attribute *uvesafb_dev_attrs[] = {\n\t&dev_attr_vbe_version.attr,\n\t&dev_attr_vbe_modes.attr,\n\t&dev_attr_oem_vendor.attr,\n\t&dev_attr_oem_product_name.attr,\n\t&dev_attr_oem_product_rev.attr,\n\t&dev_attr_oem_string.attr,\n\t&dev_attr_nocrtc.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group uvesafb_dev_attgrp = {\n\t.name = NULL,\n\t.attrs = uvesafb_dev_attrs,\n};\n\nstatic int uvesafb_probe(struct platform_device *dev)\n{\n\tstruct fb_info *info;\n\tstruct vbe_mode_ib *mode = NULL;\n\tstruct uvesafb_par *par;\n\tint err = 0, i;\n\n\tinfo = framebuffer_alloc(sizeof(*par) +\tsizeof(u32) * 256, &dev->dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tpar = info->par;\n\n\terr = uvesafb_vbe_init(info);\n\tif (err) {\n\t\tpr_err(\"vbe_init() failed with %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\tinfo->fbops = &uvesafb_ops;\n\n\ti = uvesafb_vbe_init_mode(info);\n\tif (i < 0) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t} else {\n\t\tmode = &par->vbe_modes[i];\n\t}\n\n\tif (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {\n\t\terr = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tuvesafb_init_info(info, mode);\n\n\tif (!request_region(0x3c0, 32, \"uvesafb\")) {\n\t\tpr_err(\"request region 0x3c0-0x3e0 failed\\n\");\n\t\terr = -EIO;\n\t\tgoto out_mode;\n\t}\n\n\tif (!request_mem_region(info->fix.smem_start, info->fix.smem_len,\n\t\t\t\t\"uvesafb\")) {\n\t\tpr_err(\"cannot reserve video memory at 0x%lx\\n\",\n\t\t       info->fix.smem_start);\n\t\terr = -EIO;\n\t\tgoto out_reg;\n\t}\n\n\tuvesafb_init_mtrr(info);\n\tuvesafb_ioremap(info);\n\n\tif (!info->screen_base) {\n\t\tpr_err(\"abort, cannot ioremap 0x%x bytes of video memory at 0x%lx\\n\",\n\t\t       info->fix.smem_len, info->fix.smem_start);\n\t\terr = -EIO;\n\t\tgoto out_mem;\n\t}\n\n\tplatform_set_drvdata(dev, info);\n\n\tif (register_framebuffer(info) < 0) {\n\t\tpr_err(\"failed to register framebuffer device\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out_unmap;\n\t}\n\n\tpr_info(\"framebuffer at 0x%lx, mapped to 0x%p, using %dk, total %dk\\n\",\n\t\tinfo->fix.smem_start, info->screen_base,\n\t\tinfo->fix.smem_len / 1024, par->vbe_ib.total_memory * 64);\n\tfb_info(info, \"%s frame buffer device\\n\", info->fix.id);\n\n\terr = sysfs_create_group(&dev->dev.kobj, &uvesafb_dev_attgrp);\n\tif (err != 0)\n\t\tfb_warn(info, \"failed to register attributes\\n\");\n\n\treturn 0;\n\nout_unmap:\n\tiounmap(info->screen_base);\nout_mem:\n\trelease_mem_region(info->fix.smem_start, info->fix.smem_len);\nout_reg:\n\trelease_region(0x3c0, 32);\nout_mode:\n\tif (!list_empty(&info->modelist))\n\t\tfb_destroy_modelist(&info->modelist);\n\tfb_destroy_modedb(info->monspecs.modedb);\n\tfb_dealloc_cmap(&info->cmap);\nout:\n\tkfree(par->vbe_modes);\n\n\tframebuffer_release(info);\n\treturn err;\n}\n\nstatic int uvesafb_remove(struct platform_device *dev)\n{\n\tstruct fb_info *info = platform_get_drvdata(dev);\n\n\tif (info) {\n\t\tstruct uvesafb_par *par = info->par;\n\n\t\tsysfs_remove_group(&dev->dev.kobj, &uvesafb_dev_attgrp);\n\t\tunregister_framebuffer(info);\n\t\trelease_region(0x3c0, 32);\n\t\tiounmap(info->screen_base);\n\t\tarch_phys_wc_del(par->mtrr_handle);\n\t\trelease_mem_region(info->fix.smem_start, info->fix.smem_len);\n\t\tfb_destroy_modedb(info->monspecs.modedb);\n\t\tfb_dealloc_cmap(&info->cmap);\n\n\t\tkfree(par->vbe_modes);\n\t\tkfree(par->vbe_state_orig);\n\t\tkfree(par->vbe_state_saved);\n\n\t\tframebuffer_release(info);\n\t}\n\treturn 0;\n}\n\nstatic struct platform_driver uvesafb_driver = {\n\t.probe  = uvesafb_probe,\n\t.remove = uvesafb_remove,\n\t.driver = {\n\t\t.name = \"uvesafb\",\n\t},\n};\n\nstatic struct platform_device *uvesafb_device;\n\n#ifndef MODULE\nstatic int uvesafb_setup(char *options)\n{\n\tchar *this_opt;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!*this_opt) continue;\n\n\t\tif (!strcmp(this_opt, \"redraw\"))\n\t\t\typan = 0;\n\t\telse if (!strcmp(this_opt, \"ypan\"))\n\t\t\typan = 1;\n\t\telse if (!strcmp(this_opt, \"ywrap\"))\n\t\t\typan = 2;\n\t\telse if (!strcmp(this_opt, \"vgapal\"))\n\t\t\tpmi_setpal = 0;\n\t\telse if (!strcmp(this_opt, \"pmipal\"))\n\t\t\tpmi_setpal = 1;\n\t\telse if (!strncmp(this_opt, \"mtrr:\", 5))\n\t\t\tmtrr = simple_strtoul(this_opt+5, NULL, 0);\n\t\telse if (!strcmp(this_opt, \"nomtrr\"))\n\t\t\tmtrr = 0;\n\t\telse if (!strcmp(this_opt, \"nocrtc\"))\n\t\t\tnocrtc = 1;\n\t\telse if (!strcmp(this_opt, \"noedid\"))\n\t\t\tnoedid = 1;\n\t\telse if (!strcmp(this_opt, \"noblank\"))\n\t\t\tblank = 0;\n\t\telse if (!strncmp(this_opt, \"vtotal:\", 7))\n\t\t\tvram_total = simple_strtoul(this_opt + 7, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"vremap:\", 7))\n\t\t\tvram_remap = simple_strtoul(this_opt + 7, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"maxhf:\", 6))\n\t\t\tmaxhf = simple_strtoul(this_opt + 6, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"maxvf:\", 6))\n\t\t\tmaxvf = simple_strtoul(this_opt + 6, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"maxclk:\", 7))\n\t\t\tmaxclk = simple_strtoul(this_opt + 7, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"vbemode:\", 8))\n\t\t\tvbemode = simple_strtoul(this_opt + 8, NULL, 0);\n\t\telse if (this_opt[0] >= '0' && this_opt[0] <= '9') {\n\t\t\tmode_option = this_opt;\n\t\t} else {\n\t\t\tpr_warn(\"unrecognized option %s\\n\", this_opt);\n\t\t}\n\t}\n\n\tif (mtrr != 3 && mtrr != 0)\n\t\tpr_warn(\"uvesafb: mtrr should be set to 0 or 3; %d is unsupported\", mtrr);\n\n\treturn 0;\n}\n#endif /* !MODULE */\n\nstatic ssize_t v86d_show(struct device_driver *dev, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", v86d_path);\n}\n\nstatic ssize_t v86d_store(struct device_driver *dev, const char *buf,\n\t\tsize_t count)\n{\n\tstrncpy(v86d_path, buf, PATH_MAX);\n\treturn count;\n}\nstatic DRIVER_ATTR_RW(v86d);\n\nstatic int uvesafb_init(void)\n{\n\tint err;\n\n#ifndef MODULE\n\tchar *option = NULL;\n\n\tif (fb_get_options(\"uvesafb\", &option))\n\t\treturn -ENODEV;\n\tuvesafb_setup(option);\n#endif\n\terr = cn_add_callback(&uvesafb_cn_id, \"uvesafb\", uvesafb_cn_callback);\n\tif (err)\n\t\treturn err;\n\n\terr = platform_driver_register(&uvesafb_driver);\n\n\tif (!err) {\n\t\tuvesafb_device = platform_device_alloc(\"uvesafb\", 0);\n\t\tif (uvesafb_device)\n\t\t\terr = platform_device_add(uvesafb_device);\n\t\telse\n\t\t\terr = -ENOMEM;\n\n\t\tif (err) {\n\t\t\tplatform_device_put(uvesafb_device);\n\t\t\tplatform_driver_unregister(&uvesafb_driver);\n\t\t\tcn_del_callback(&uvesafb_cn_id);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = driver_create_file(&uvesafb_driver.driver,\n\t\t\t\t&driver_attr_v86d);\n\t\tif (err) {\n\t\t\tpr_warn(\"failed to register attributes\\n\");\n\t\t\terr = 0;\n\t\t}\n\t}\n\treturn err;\n}\n\nmodule_init(uvesafb_init);\n\nstatic void uvesafb_exit(void)\n{\n\tstruct uvesafb_ktask *task;\n\n\tif (v86d_started) {\n\t\ttask = uvesafb_prep();\n\t\tif (task) {\n\t\t\ttask->t.flags = TF_EXIT;\n\t\t\tuvesafb_exec(task);\n\t\t\tuvesafb_free(task);\n\t\t}\n\t}\n\n\tcn_del_callback(&uvesafb_cn_id);\n\tdriver_remove_file(&uvesafb_driver.driver, &driver_attr_v86d);\n\tplatform_device_unregister(uvesafb_device);\n\tplatform_driver_unregister(&uvesafb_driver);\n}\n\nmodule_exit(uvesafb_exit);\n\nstatic int param_set_scroll(const char *val, const struct kernel_param *kp)\n{\n\typan = 0;\n\n\tif (!strcmp(val, \"redraw\"))\n\t\typan = 0;\n\telse if (!strcmp(val, \"ypan\"))\n\t\typan = 1;\n\telse if (!strcmp(val, \"ywrap\"))\n\t\typan = 2;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nstatic const struct kernel_param_ops param_ops_scroll = {\n\t.set = param_set_scroll,\n};\n#define param_check_scroll(name, p) __param_check(name, p, void)\n\nmodule_param_named(scroll, ypan, scroll, 0);\nMODULE_PARM_DESC(scroll,\n\t\"Scrolling mode, set to 'redraw', 'ypan', or 'ywrap'\");\nmodule_param_named(vgapal, pmi_setpal, invbool, 0);\nMODULE_PARM_DESC(vgapal, \"Set palette using VGA registers\");\nmodule_param_named(pmipal, pmi_setpal, bool, 0);\nMODULE_PARM_DESC(pmipal, \"Set palette using PMI calls\");\nmodule_param(mtrr, uint, 0);\nMODULE_PARM_DESC(mtrr,\n\t\"Memory Type Range Registers setting. Use 0 to disable.\");\nmodule_param(blank, bool, 0);\nMODULE_PARM_DESC(blank, \"Enable hardware blanking\");\nmodule_param(nocrtc, bool, 0);\nMODULE_PARM_DESC(nocrtc, \"Ignore CRTC timings when setting modes\");\nmodule_param(noedid, bool, 0);\nMODULE_PARM_DESC(noedid,\n\t\"Ignore EDID-provided monitor limits when setting modes\");\nmodule_param(vram_remap, uint, 0);\nMODULE_PARM_DESC(vram_remap, \"Set amount of video memory to be used [MiB]\");\nmodule_param(vram_total, uint, 0);\nMODULE_PARM_DESC(vram_total, \"Set total amount of video memoery [MiB]\");\nmodule_param(maxclk, ushort, 0);\nMODULE_PARM_DESC(maxclk, \"Maximum pixelclock [MHz], overrides EDID data\");\nmodule_param(maxhf, ushort, 0);\nMODULE_PARM_DESC(maxhf,\n\t\"Maximum horizontal frequency [kHz], overrides EDID data\");\nmodule_param(maxvf, ushort, 0);\nMODULE_PARM_DESC(maxvf,\n\t\"Maximum vertical frequency [Hz], overrides EDID data\");\nmodule_param(mode_option, charp, 0);\nMODULE_PARM_DESC(mode_option,\n\t\"Specify initial video mode as \\\"<xres>x<yres>[-<bpp>][@<refresh>]\\\"\");\nmodule_param(vbemode, ushort, 0);\nMODULE_PARM_DESC(vbemode,\n\t\"VBE mode number to set, overrides the 'mode' option\");\nmodule_param_string(v86d, v86d_path, PATH_MAX, 0660);\nMODULE_PARM_DESC(v86d, \"Path to the v86d userspace helper.\");\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Michal Januszewski <spock@gentoo.org>\");\nMODULE_DESCRIPTION(\"Framebuffer driver for VBE2.0+ compliant graphics boards\");\n\n"], "fixing_code": ["/*\n * A framebuffer driver for VBE 2.0+ compliant video cards\n *\n * (c) 2007 Michal Januszewski <spock@gentoo.org>\n *     Loosely based upon the vesafb driver.\n *\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/skbuff.h>\n#include <linux/timer.h>\n#include <linux/completion.h>\n#include <linux/connector.h>\n#include <linux/random.h>\n#include <linux/platform_device.h>\n#include <linux/limits.h>\n#include <linux/fb.h>\n#include <linux/io.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <video/edid.h>\n#include <video/uvesafb.h>\n#ifdef CONFIG_X86\n#include <video/vga.h>\n#endif\n#include \"edid.h\"\n\nstatic struct cb_id uvesafb_cn_id = {\n\t.idx = CN_IDX_V86D,\n\t.val = CN_VAL_V86D_UVESAFB\n};\nstatic char v86d_path[PATH_MAX] = \"/sbin/v86d\";\nstatic char v86d_started;\t/* has v86d been started by uvesafb? */\n\nstatic const struct fb_fix_screeninfo uvesafb_fix = {\n\t.id\t= \"VESA VGA\",\n\t.type\t= FB_TYPE_PACKED_PIXELS,\n\t.accel\t= FB_ACCEL_NONE,\n\t.visual = FB_VISUAL_TRUECOLOR,\n};\n\nstatic int mtrr\t\t= 3;\t/* enable mtrr by default */\nstatic bool blank\t= 1;\t/* enable blanking by default */\nstatic int ypan\t\t= 1;\t/* 0: scroll, 1: ypan, 2: ywrap */\nstatic bool pmi_setpal\t= true; /* use PMI for palette changes */\nstatic bool nocrtc;\t\t/* ignore CRTC settings */\nstatic bool noedid;\t\t/* don't try DDC transfers */\nstatic int vram_remap;\t\t/* set amt. of memory to be used */\nstatic int vram_total;\t\t/* set total amount of memory */\nstatic u16 maxclk;\t\t/* maximum pixel clock */\nstatic u16 maxvf;\t\t/* maximum vertical frequency */\nstatic u16 maxhf;\t\t/* maximum horizontal frequency */\nstatic u16 vbemode;\t\t/* force use of a specific VBE mode */\nstatic char *mode_option;\nstatic u8  dac_width\t= 6;\n\nstatic struct uvesafb_ktask *uvfb_tasks[UVESAFB_TASKS_MAX];\nstatic DEFINE_MUTEX(uvfb_lock);\n\n/*\n * A handler for replies from userspace.\n *\n * Make sure each message passes consistency checks and if it does,\n * find the kernel part of the task struct, copy the registers and\n * the buffer contents and then complete the task.\n */\nstatic void uvesafb_cn_callback(struct cn_msg *msg, struct netlink_skb_parms *nsp)\n{\n\tstruct uvesafb_task *utask;\n\tstruct uvesafb_ktask *task;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn;\n\n\tif (msg->seq >= UVESAFB_TASKS_MAX)\n\t\treturn;\n\n\tmutex_lock(&uvfb_lock);\n\ttask = uvfb_tasks[msg->seq];\n\n\tif (!task || msg->ack != task->ack) {\n\t\tmutex_unlock(&uvfb_lock);\n\t\treturn;\n\t}\n\n\tutask = (struct uvesafb_task *)msg->data;\n\n\t/* Sanity checks for the buffer length. */\n\tif (task->t.buf_len < utask->buf_len ||\n\t    utask->buf_len > msg->len - sizeof(*utask)) {\n\t\tmutex_unlock(&uvfb_lock);\n\t\treturn;\n\t}\n\n\tuvfb_tasks[msg->seq] = NULL;\n\tmutex_unlock(&uvfb_lock);\n\n\tmemcpy(&task->t, utask, sizeof(*utask));\n\n\tif (task->t.buf_len && task->buf)\n\t\tmemcpy(task->buf, utask + 1, task->t.buf_len);\n\n\tcomplete(task->done);\n\treturn;\n}\n\nstatic int uvesafb_helper_start(void)\n{\n\tchar *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"PATH=/sbin:/bin\",\n\t\tNULL,\n\t};\n\n\tchar *argv[] = {\n\t\tv86d_path,\n\t\tNULL,\n\t};\n\n\treturn call_usermodehelper(v86d_path, argv, envp, UMH_WAIT_PROC);\n}\n\n/*\n * Execute a uvesafb task.\n *\n * Returns 0 if the task is executed successfully.\n *\n * A message sent to the userspace consists of the uvesafb_task\n * struct and (optionally) a buffer. The uvesafb_task struct is\n * a simplified version of uvesafb_ktask (its kernel counterpart)\n * containing only the register values, flags and the length of\n * the buffer.\n *\n * Each message is assigned a sequence number (increased linearly)\n * and a random ack number. The sequence number is used as a key\n * for the uvfb_tasks array which holds pointers to uvesafb_ktask\n * structs for all requests.\n */\nstatic int uvesafb_exec(struct uvesafb_ktask *task)\n{\n\tstatic int seq;\n\tstruct cn_msg *m;\n\tint err;\n\tint len = sizeof(task->t) + task->t.buf_len;\n\n\t/*\n\t * Check whether the message isn't longer than the maximum\n\t * allowed by connector.\n\t */\n\tif (sizeof(*m) + len > CONNECTOR_MAX_MSG_SIZE) {\n\t\tpr_warn(\"message too long (%d), can't execute task\\n\",\n\t\t\t(int)(sizeof(*m) + len));\n\t\treturn -E2BIG;\n\t}\n\n\tm = kzalloc(sizeof(*m) + len, GFP_KERNEL);\n\tif (!m)\n\t\treturn -ENOMEM;\n\n\tinit_completion(task->done);\n\n\tmemcpy(&m->id, &uvesafb_cn_id, sizeof(m->id));\n\tm->seq = seq;\n\tm->len = len;\n\tm->ack = prandom_u32();\n\n\t/* uvesafb_task structure */\n\tmemcpy(m + 1, &task->t, sizeof(task->t));\n\n\t/* Buffer */\n\tmemcpy((u8 *)(m + 1) + sizeof(task->t), task->buf, task->t.buf_len);\n\n\t/*\n\t * Save the message ack number so that we can find the kernel\n\t * part of this task when a reply is received from userspace.\n\t */\n\ttask->ack = m->ack;\n\n\tmutex_lock(&uvfb_lock);\n\n\t/* If all slots are taken -- bail out. */\n\tif (uvfb_tasks[seq]) {\n\t\tmutex_unlock(&uvfb_lock);\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/* Save a pointer to the kernel part of the task struct. */\n\tuvfb_tasks[seq] = task;\n\tmutex_unlock(&uvfb_lock);\n\n\terr = cn_netlink_send(m, 0, 0, GFP_KERNEL);\n\tif (err == -ESRCH) {\n\t\t/*\n\t\t * Try to start the userspace helper if sending\n\t\t * the request failed the first time.\n\t\t */\n\t\terr = uvesafb_helper_start();\n\t\tif (err) {\n\t\t\tpr_err(\"failed to execute %s\\n\", v86d_path);\n\t\t\tpr_err(\"make sure that the v86d helper is installed and executable\\n\");\n\t\t} else {\n\t\t\tv86d_started = 1;\n\t\t\terr = cn_netlink_send(m, 0, 0, gfp_any());\n\t\t\tif (err == -ENOBUFS)\n\t\t\t\terr = 0;\n\t\t}\n\t} else if (err == -ENOBUFS)\n\t\terr = 0;\n\n\tif (!err && !(task->t.flags & TF_EXIT))\n\t\terr = !wait_for_completion_timeout(task->done,\n\t\t\t\tmsecs_to_jiffies(UVESAFB_TIMEOUT));\n\n\tmutex_lock(&uvfb_lock);\n\tuvfb_tasks[seq] = NULL;\n\tmutex_unlock(&uvfb_lock);\n\n\tseq++;\n\tif (seq >= UVESAFB_TASKS_MAX)\n\t\tseq = 0;\nout:\n\tkfree(m);\n\treturn err;\n}\n\n/*\n * Free a uvesafb_ktask struct.\n */\nstatic void uvesafb_free(struct uvesafb_ktask *task)\n{\n\tif (task) {\n\t\tkfree(task->done);\n\t\tkfree(task);\n\t}\n}\n\n/*\n * Prepare a uvesafb_ktask struct to be used again.\n */\nstatic void uvesafb_reset(struct uvesafb_ktask *task)\n{\n\tstruct completion *cpl = task->done;\n\n\tmemset(task, 0, sizeof(*task));\n\ttask->done = cpl;\n}\n\n/*\n * Allocate and prepare a uvesafb_ktask struct.\n */\nstatic struct uvesafb_ktask *uvesafb_prep(void)\n{\n\tstruct uvesafb_ktask *task;\n\n\ttask = kzalloc(sizeof(*task), GFP_KERNEL);\n\tif (task) {\n\t\ttask->done = kzalloc(sizeof(*task->done), GFP_KERNEL);\n\t\tif (!task->done) {\n\t\t\tkfree(task);\n\t\t\ttask = NULL;\n\t\t}\n\t}\n\treturn task;\n}\n\nstatic void uvesafb_setup_var(struct fb_var_screeninfo *var,\n\t\tstruct fb_info *info, struct vbe_mode_ib *mode)\n{\n\tstruct uvesafb_par *par = info->par;\n\n\tvar->vmode = FB_VMODE_NONINTERLACED;\n\tvar->sync = FB_SYNC_VERT_HIGH_ACT;\n\n\tvar->xres = mode->x_res;\n\tvar->yres = mode->y_res;\n\tvar->xres_virtual = mode->x_res;\n\tvar->yres_virtual = (par->ypan) ?\n\t\t\tinfo->fix.smem_len / mode->bytes_per_scan_line :\n\t\t\tmode->y_res;\n\tvar->xoffset = 0;\n\tvar->yoffset = 0;\n\tvar->bits_per_pixel = mode->bits_per_pixel;\n\n\tif (var->bits_per_pixel == 15)\n\t\tvar->bits_per_pixel = 16;\n\n\tif (var->bits_per_pixel > 8) {\n\t\tvar->red.offset    = mode->red_off;\n\t\tvar->red.length    = mode->red_len;\n\t\tvar->green.offset  = mode->green_off;\n\t\tvar->green.length  = mode->green_len;\n\t\tvar->blue.offset   = mode->blue_off;\n\t\tvar->blue.length   = mode->blue_len;\n\t\tvar->transp.offset = mode->rsvd_off;\n\t\tvar->transp.length = mode->rsvd_len;\n\t} else {\n\t\tvar->red.offset    = 0;\n\t\tvar->green.offset  = 0;\n\t\tvar->blue.offset   = 0;\n\t\tvar->transp.offset = 0;\n\n\t\tvar->red.length    = 8;\n\t\tvar->green.length  = 8;\n\t\tvar->blue.length   = 8;\n\t\tvar->transp.length = 0;\n\t}\n}\n\nstatic int uvesafb_vbe_find_mode(struct uvesafb_par *par,\n\t\tint xres, int yres, int depth, unsigned char flags)\n{\n\tint i, match = -1, h = 0, d = 0x7fffffff;\n\n\tfor (i = 0; i < par->vbe_modes_cnt; i++) {\n\t\th = abs(par->vbe_modes[i].x_res - xres) +\n\t\t    abs(par->vbe_modes[i].y_res - yres) +\n\t\t    abs(depth - par->vbe_modes[i].depth);\n\n\t\t/*\n\t\t * We have an exact match in terms of resolution\n\t\t * and depth.\n\t\t */\n\t\tif (h == 0)\n\t\t\treturn i;\n\n\t\tif (h < d || (h == d && par->vbe_modes[i].depth > depth)) {\n\t\t\td = h;\n\t\t\tmatch = i;\n\t\t}\n\t}\n\ti = 1;\n\n\tif (flags & UVESAFB_EXACT_DEPTH &&\n\t\t\tpar->vbe_modes[match].depth != depth)\n\t\ti = 0;\n\n\tif (flags & UVESAFB_EXACT_RES && d > 24)\n\t\ti = 0;\n\n\tif (i != 0)\n\t\treturn match;\n\telse\n\t\treturn -1;\n}\n\nstatic u8 *uvesafb_vbe_state_save(struct uvesafb_par *par)\n{\n\tstruct uvesafb_ktask *task;\n\tu8 *state;\n\tint err;\n\n\tif (!par->vbe_state_size)\n\t\treturn NULL;\n\n\tstate = kmalloc(par->vbe_state_size, GFP_KERNEL);\n\tif (!state)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttask = uvesafb_prep();\n\tif (!task) {\n\t\tkfree(state);\n\t\treturn NULL;\n\t}\n\n\ttask->t.regs.eax = 0x4f04;\n\ttask->t.regs.ecx = 0x000f;\n\ttask->t.regs.edx = 0x0001;\n\ttask->t.flags = TF_BUF_RET | TF_BUF_ESBX;\n\ttask->t.buf_len = par->vbe_state_size;\n\ttask->buf = state;\n\terr = uvesafb_exec(task);\n\n\tif (err || (task->t.regs.eax & 0xffff) != 0x004f) {\n\t\tpr_warn(\"VBE get state call failed (eax=0x%x, err=%d)\\n\",\n\t\t\ttask->t.regs.eax, err);\n\t\tkfree(state);\n\t\tstate = NULL;\n\t}\n\n\tuvesafb_free(task);\n\treturn state;\n}\n\nstatic void uvesafb_vbe_state_restore(struct uvesafb_par *par, u8 *state_buf)\n{\n\tstruct uvesafb_ktask *task;\n\tint err;\n\n\tif (!state_buf)\n\t\treturn;\n\n\ttask = uvesafb_prep();\n\tif (!task)\n\t\treturn;\n\n\ttask->t.regs.eax = 0x4f04;\n\ttask->t.regs.ecx = 0x000f;\n\ttask->t.regs.edx = 0x0002;\n\ttask->t.buf_len = par->vbe_state_size;\n\ttask->t.flags = TF_BUF_ESBX;\n\ttask->buf = state_buf;\n\n\terr = uvesafb_exec(task);\n\tif (err || (task->t.regs.eax & 0xffff) != 0x004f)\n\t\tpr_warn(\"VBE state restore call failed (eax=0x%x, err=%d)\\n\",\n\t\t\ttask->t.regs.eax, err);\n\n\tuvesafb_free(task);\n}\n\nstatic int uvesafb_vbe_getinfo(struct uvesafb_ktask *task,\n\t\t\t       struct uvesafb_par *par)\n{\n\tint err;\n\n\ttask->t.regs.eax = 0x4f00;\n\ttask->t.flags = TF_VBEIB;\n\ttask->t.buf_len = sizeof(struct vbe_ib);\n\ttask->buf = &par->vbe_ib;\n\tstrncpy(par->vbe_ib.vbe_signature, \"VBE2\", 4);\n\n\terr = uvesafb_exec(task);\n\tif (err || (task->t.regs.eax & 0xffff) != 0x004f) {\n\t\tpr_err(\"Getting VBE info block failed (eax=0x%x, err=%d)\\n\",\n\t\t       (u32)task->t.regs.eax, err);\n\t\treturn -EINVAL;\n\t}\n\n\tif (par->vbe_ib.vbe_version < 0x0200) {\n\t\tpr_err(\"Sorry, pre-VBE 2.0 cards are not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!par->vbe_ib.mode_list_ptr) {\n\t\tpr_err(\"Missing mode list!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpr_info(\"\");\n\n\t/*\n\t * Convert string pointers and the mode list pointer into\n\t * usable addresses. Print informational messages about the\n\t * video adapter and its vendor.\n\t */\n\tif (par->vbe_ib.oem_vendor_name_ptr)\n\t\tpr_cont(\"%s, \",\n\t\t\t((char *)task->buf) + par->vbe_ib.oem_vendor_name_ptr);\n\n\tif (par->vbe_ib.oem_product_name_ptr)\n\t\tpr_cont(\"%s, \",\n\t\t\t((char *)task->buf) + par->vbe_ib.oem_product_name_ptr);\n\n\tif (par->vbe_ib.oem_product_rev_ptr)\n\t\tpr_cont(\"%s, \",\n\t\t\t((char *)task->buf) + par->vbe_ib.oem_product_rev_ptr);\n\n\tif (par->vbe_ib.oem_string_ptr)\n\t\tpr_cont(\"OEM: %s, \",\n\t\t\t((char *)task->buf) + par->vbe_ib.oem_string_ptr);\n\n\tpr_cont(\"VBE v%d.%d\\n\",\n\t\t(par->vbe_ib.vbe_version & 0xff00) >> 8,\n\t\tpar->vbe_ib.vbe_version & 0xff);\n\n\treturn 0;\n}\n\nstatic int uvesafb_vbe_getmodes(struct uvesafb_ktask *task,\n\t\t\t\tstruct uvesafb_par *par)\n{\n\tint off = 0, err;\n\tu16 *mode;\n\n\tpar->vbe_modes_cnt = 0;\n\n\t/* Count available modes. */\n\tmode = (u16 *) (((u8 *)&par->vbe_ib) + par->vbe_ib.mode_list_ptr);\n\twhile (*mode != 0xffff) {\n\t\tpar->vbe_modes_cnt++;\n\t\tmode++;\n\t}\n\n\tpar->vbe_modes = kzalloc(sizeof(struct vbe_mode_ib) *\n\t\t\t\tpar->vbe_modes_cnt, GFP_KERNEL);\n\tif (!par->vbe_modes)\n\t\treturn -ENOMEM;\n\n\t/* Get info about all available modes. */\n\tmode = (u16 *) (((u8 *)&par->vbe_ib) + par->vbe_ib.mode_list_ptr);\n\twhile (*mode != 0xffff) {\n\t\tstruct vbe_mode_ib *mib;\n\n\t\tuvesafb_reset(task);\n\t\ttask->t.regs.eax = 0x4f01;\n\t\ttask->t.regs.ecx = (u32) *mode;\n\t\ttask->t.flags = TF_BUF_RET | TF_BUF_ESDI;\n\t\ttask->t.buf_len = sizeof(struct vbe_mode_ib);\n\t\ttask->buf = par->vbe_modes + off;\n\n\t\terr = uvesafb_exec(task);\n\t\tif (err || (task->t.regs.eax & 0xffff) != 0x004f) {\n\t\t\tpr_warn(\"Getting mode info block for mode 0x%x failed (eax=0x%x, err=%d)\\n\",\n\t\t\t\t*mode, (u32)task->t.regs.eax, err);\n\t\t\tmode++;\n\t\t\tpar->vbe_modes_cnt--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmib = task->buf;\n\t\tmib->mode_id = *mode;\n\n\t\t/*\n\t\t * We only want modes that are supported with the current\n\t\t * hardware configuration, color, graphics and that have\n\t\t * support for the LFB.\n\t\t */\n\t\tif ((mib->mode_attr & VBE_MODE_MASK) == VBE_MODE_MASK &&\n\t\t\t\t mib->bits_per_pixel >= 8)\n\t\t\toff++;\n\t\telse\n\t\t\tpar->vbe_modes_cnt--;\n\n\t\tmode++;\n\t\tmib->depth = mib->red_len + mib->green_len + mib->blue_len;\n\n\t\t/*\n\t\t * Handle 8bpp modes and modes with broken color component\n\t\t * lengths.\n\t\t */\n\t\tif (mib->depth == 0 || (mib->depth == 24 &&\n\t\t\t\t\tmib->bits_per_pixel == 32))\n\t\t\tmib->depth = mib->bits_per_pixel;\n\t}\n\n\tif (par->vbe_modes_cnt > 0)\n\t\treturn 0;\n\telse\n\t\treturn -EINVAL;\n}\n\n/*\n * The Protected Mode Interface is 32-bit x86 code, so we only run it on\n * x86 and not x86_64.\n */\n#ifdef CONFIG_X86_32\nstatic int uvesafb_vbe_getpmi(struct uvesafb_ktask *task,\n\t\t\t      struct uvesafb_par *par)\n{\n\tint i, err;\n\n\tuvesafb_reset(task);\n\ttask->t.regs.eax = 0x4f0a;\n\ttask->t.regs.ebx = 0x0;\n\terr = uvesafb_exec(task);\n\n\tif ((task->t.regs.eax & 0xffff) != 0x4f || task->t.regs.es < 0xc000) {\n\t\tpar->pmi_setpal = par->ypan = 0;\n\t} else {\n\t\tpar->pmi_base = (u16 *)phys_to_virt(((u32)task->t.regs.es << 4)\n\t\t\t\t\t\t+ task->t.regs.edi);\n\t\tpar->pmi_start = (u8 *)par->pmi_base + par->pmi_base[1];\n\t\tpar->pmi_pal = (u8 *)par->pmi_base + par->pmi_base[2];\n\t\tpr_info(\"protected mode interface info at %04x:%04x\\n\",\n\t\t\t(u16)task->t.regs.es, (u16)task->t.regs.edi);\n\t\tpr_info(\"pmi: set display start = %p, set palette = %p\\n\",\n\t\t\tpar->pmi_start, par->pmi_pal);\n\n\t\tif (par->pmi_base[3]) {\n\t\t\tpr_info(\"pmi: ports =\");\n\t\t\tfor (i = par->pmi_base[3]/2;\n\t\t\t\t\tpar->pmi_base[i] != 0xffff; i++)\n\t\t\t\tpr_cont(\" %x\", par->pmi_base[i]);\n\t\t\tpr_cont(\"\\n\");\n\n\t\t\tif (par->pmi_base[i] != 0xffff) {\n\t\t\t\tpr_info(\"can't handle memory requests, pmi disabled\\n\");\n\t\t\t\tpar->ypan = par->pmi_setpal = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n#endif /* CONFIG_X86_32 */\n\n/*\n * Check whether a video mode is supported by the Video BIOS and is\n * compatible with the monitor limits.\n */\nstatic int uvesafb_is_valid_mode(struct fb_videomode *mode,\n\t\t\t\t struct fb_info *info)\n{\n\tif (info->monspecs.gtf) {\n\t\tfb_videomode_to_var(&info->var, mode);\n\t\tif (fb_validate_mode(&info->var, info))\n\t\t\treturn 0;\n\t}\n\n\tif (uvesafb_vbe_find_mode(info->par, mode->xres, mode->yres, 8,\n\t\t\t\tUVESAFB_EXACT_RES) == -1)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int uvesafb_vbe_getedid(struct uvesafb_ktask *task, struct fb_info *info)\n{\n\tstruct uvesafb_par *par = info->par;\n\tint err = 0;\n\n\tif (noedid || par->vbe_ib.vbe_version < 0x0300)\n\t\treturn -EINVAL;\n\n\ttask->t.regs.eax = 0x4f15;\n\ttask->t.regs.ebx = 0;\n\ttask->t.regs.ecx = 0;\n\ttask->t.buf_len = 0;\n\ttask->t.flags = 0;\n\n\terr = uvesafb_exec(task);\n\n\tif ((task->t.regs.eax & 0xffff) != 0x004f || err)\n\t\treturn -EINVAL;\n\n\tif ((task->t.regs.ebx & 0x3) == 3) {\n\t\tpr_info(\"VBIOS/hardware supports both DDC1 and DDC2 transfers\\n\");\n\t} else if ((task->t.regs.ebx & 0x3) == 2) {\n\t\tpr_info(\"VBIOS/hardware supports DDC2 transfers\\n\");\n\t} else if ((task->t.regs.ebx & 0x3) == 1) {\n\t\tpr_info(\"VBIOS/hardware supports DDC1 transfers\\n\");\n\t} else {\n\t\tpr_info(\"VBIOS/hardware doesn't support DDC transfers\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttask->t.regs.eax = 0x4f15;\n\ttask->t.regs.ebx = 1;\n\ttask->t.regs.ecx = task->t.regs.edx = 0;\n\ttask->t.flags = TF_BUF_RET | TF_BUF_ESDI;\n\ttask->t.buf_len = EDID_LENGTH;\n\ttask->buf = kzalloc(EDID_LENGTH, GFP_KERNEL);\n\tif (!task->buf)\n\t\treturn -ENOMEM;\n\n\terr = uvesafb_exec(task);\n\n\tif ((task->t.regs.eax & 0xffff) == 0x004f && !err) {\n\t\tfb_edid_to_monspecs(task->buf, &info->monspecs);\n\n\t\tif (info->monspecs.vfmax && info->monspecs.hfmax) {\n\t\t\t/*\n\t\t\t * If the maximum pixel clock wasn't specified in\n\t\t\t * the EDID block, set it to 300 MHz.\n\t\t\t */\n\t\t\tif (info->monspecs.dclkmax == 0)\n\t\t\t\tinfo->monspecs.dclkmax = 300 * 1000000;\n\t\t\tinfo->monspecs.gtf = 1;\n\t\t}\n\t} else {\n\t\terr = -EINVAL;\n\t}\n\n\tkfree(task->buf);\n\treturn err;\n}\n\nstatic void uvesafb_vbe_getmonspecs(struct uvesafb_ktask *task,\n\t\t\t\t    struct fb_info *info)\n{\n\tstruct uvesafb_par *par = info->par;\n\tint i;\n\n\tmemset(&info->monspecs, 0, sizeof(info->monspecs));\n\n\t/*\n\t * If we don't get all necessary data from the EDID block,\n\t * mark it as incompatible with the GTF and set nocrtc so\n\t * that we always use the default BIOS refresh rate.\n\t */\n\tif (uvesafb_vbe_getedid(task, info)) {\n\t\tinfo->monspecs.gtf = 0;\n\t\tpar->nocrtc = 1;\n\t}\n\n\t/* Kernel command line overrides. */\n\tif (maxclk)\n\t\tinfo->monspecs.dclkmax = maxclk * 1000000;\n\tif (maxvf)\n\t\tinfo->monspecs.vfmax = maxvf;\n\tif (maxhf)\n\t\tinfo->monspecs.hfmax = maxhf * 1000;\n\n\t/*\n\t * In case DDC transfers are not supported, the user can provide\n\t * monitor limits manually. Lower limits are set to \"safe\" values.\n\t */\n\tif (info->monspecs.gtf == 0 && maxclk && maxvf && maxhf) {\n\t\tinfo->monspecs.dclkmin = 0;\n\t\tinfo->monspecs.vfmin = 60;\n\t\tinfo->monspecs.hfmin = 29000;\n\t\tinfo->monspecs.gtf = 1;\n\t\tpar->nocrtc = 0;\n\t}\n\n\tif (info->monspecs.gtf)\n\t\tpr_info(\"monitor limits: vf = %d Hz, hf = %d kHz, clk = %d MHz\\n\",\n\t\t\tinfo->monspecs.vfmax,\n\t\t\t(int)(info->monspecs.hfmax / 1000),\n\t\t\t(int)(info->monspecs.dclkmax / 1000000));\n\telse\n\t\tpr_info(\"no monitor limits have been set, default refresh rate will be used\\n\");\n\n\t/* Add VBE modes to the modelist. */\n\tfor (i = 0; i < par->vbe_modes_cnt; i++) {\n\t\tstruct fb_var_screeninfo var;\n\t\tstruct vbe_mode_ib *mode;\n\t\tstruct fb_videomode vmode;\n\n\t\tmode = &par->vbe_modes[i];\n\t\tmemset(&var, 0, sizeof(var));\n\n\t\tvar.xres = mode->x_res;\n\t\tvar.yres = mode->y_res;\n\n\t\tfb_get_mode(FB_VSYNCTIMINGS | FB_IGNOREMON, 60, &var, info);\n\t\tfb_var_to_videomode(&vmode, &var);\n\t\tfb_add_videomode(&vmode, &info->modelist);\n\t}\n\n\t/* Add valid VESA modes to our modelist. */\n\tfor (i = 0; i < VESA_MODEDB_SIZE; i++) {\n\t\tif (uvesafb_is_valid_mode((struct fb_videomode *)\n\t\t\t\t\t\t&vesa_modes[i], info))\n\t\t\tfb_add_videomode(&vesa_modes[i], &info->modelist);\n\t}\n\n\tfor (i = 0; i < info->monspecs.modedb_len; i++) {\n\t\tif (uvesafb_is_valid_mode(&info->monspecs.modedb[i], info))\n\t\t\tfb_add_videomode(&info->monspecs.modedb[i],\n\t\t\t\t\t&info->modelist);\n\t}\n\n\treturn;\n}\n\nstatic void uvesafb_vbe_getstatesize(struct uvesafb_ktask *task,\n\t\t\t\t     struct uvesafb_par *par)\n{\n\tint err;\n\n\tuvesafb_reset(task);\n\n\t/*\n\t * Get the VBE state buffer size. We want all available\n\t * hardware state data (CL = 0x0f).\n\t */\n\ttask->t.regs.eax = 0x4f04;\n\ttask->t.regs.ecx = 0x000f;\n\ttask->t.regs.edx = 0x0000;\n\ttask->t.flags = 0;\n\n\terr = uvesafb_exec(task);\n\n\tif (err || (task->t.regs.eax & 0xffff) != 0x004f) {\n\t\tpr_warn(\"VBE state buffer size cannot be determined (eax=0x%x, err=%d)\\n\",\n\t\t\ttask->t.regs.eax, err);\n\t\tpar->vbe_state_size = 0;\n\t\treturn;\n\t}\n\n\tpar->vbe_state_size = 64 * (task->t.regs.ebx & 0xffff);\n}\n\nstatic int uvesafb_vbe_init(struct fb_info *info)\n{\n\tstruct uvesafb_ktask *task = NULL;\n\tstruct uvesafb_par *par = info->par;\n\tint err;\n\n\ttask = uvesafb_prep();\n\tif (!task)\n\t\treturn -ENOMEM;\n\n\terr = uvesafb_vbe_getinfo(task, par);\n\tif (err)\n\t\tgoto out;\n\n\terr = uvesafb_vbe_getmodes(task, par);\n\tif (err)\n\t\tgoto out;\n\n\tpar->nocrtc = nocrtc;\n#ifdef CONFIG_X86_32\n\tpar->pmi_setpal = pmi_setpal;\n\tpar->ypan = ypan;\n\n\tif (par->pmi_setpal || par->ypan) {\n\t\tif (__supported_pte_mask & _PAGE_NX) {\n\t\t\tpar->pmi_setpal = par->ypan = 0;\n\t\t\tpr_warn(\"NX protection is active, better not use the PMI\\n\");\n\t\t} else {\n\t\t\tuvesafb_vbe_getpmi(task, par);\n\t\t}\n\t}\n#else\n\t/* The protected mode interface is not available on non-x86. */\n\tpar->pmi_setpal = par->ypan = 0;\n#endif\n\n\tINIT_LIST_HEAD(&info->modelist);\n\tuvesafb_vbe_getmonspecs(task, info);\n\tuvesafb_vbe_getstatesize(task, par);\n\nout:\tuvesafb_free(task);\n\treturn err;\n}\n\nstatic int uvesafb_vbe_init_mode(struct fb_info *info)\n{\n\tstruct list_head *pos;\n\tstruct fb_modelist *modelist;\n\tstruct fb_videomode *mode;\n\tstruct uvesafb_par *par = info->par;\n\tint i, modeid;\n\n\t/* Has the user requested a specific VESA mode? */\n\tif (vbemode) {\n\t\tfor (i = 0; i < par->vbe_modes_cnt; i++) {\n\t\t\tif (par->vbe_modes[i].mode_id == vbemode) {\n\t\t\t\tmodeid = i;\n\t\t\t\tuvesafb_setup_var(&info->var, info,\n\t\t\t\t\t\t&par->vbe_modes[modeid]);\n\t\t\t\tfb_get_mode(FB_VSYNCTIMINGS | FB_IGNOREMON, 60,\n\t\t\t\t\t\t&info->var, info);\n\t\t\t\t/*\n\t\t\t\t * With pixclock set to 0, the default BIOS\n\t\t\t\t * timings will be used in set_par().\n\t\t\t\t */\n\t\t\t\tinfo->var.pixclock = 0;\n\t\t\t\tgoto gotmode;\n\t\t\t}\n\t\t}\n\t\tpr_info(\"requested VBE mode 0x%x is unavailable\\n\", vbemode);\n\t\tvbemode = 0;\n\t}\n\n\t/* Count the modes in the modelist */\n\ti = 0;\n\tlist_for_each(pos, &info->modelist)\n\t\ti++;\n\n\t/*\n\t * Convert the modelist into a modedb so that we can use it with\n\t * fb_find_mode().\n\t */\n\tmode = kzalloc(i * sizeof(*mode), GFP_KERNEL);\n\tif (mode) {\n\t\ti = 0;\n\t\tlist_for_each(pos, &info->modelist) {\n\t\t\tmodelist = list_entry(pos, struct fb_modelist, list);\n\t\t\tmode[i] = modelist->mode;\n\t\t\ti++;\n\t\t}\n\n\t\tif (!mode_option)\n\t\t\tmode_option = UVESAFB_DEFAULT_MODE;\n\n\t\ti = fb_find_mode(&info->var, info, mode_option, mode, i,\n\t\t\tNULL, 8);\n\n\t\tkfree(mode);\n\t}\n\n\t/* fb_find_mode() failed */\n\tif (i == 0) {\n\t\tinfo->var.xres = 640;\n\t\tinfo->var.yres = 480;\n\t\tmode = (struct fb_videomode *)\n\t\t\t\tfb_find_best_mode(&info->var, &info->modelist);\n\n\t\tif (mode) {\n\t\t\tfb_videomode_to_var(&info->var, mode);\n\t\t} else {\n\t\t\tmodeid = par->vbe_modes[0].mode_id;\n\t\t\tuvesafb_setup_var(&info->var, info,\n\t\t\t\t\t&par->vbe_modes[modeid]);\n\t\t\tfb_get_mode(FB_VSYNCTIMINGS | FB_IGNOREMON, 60,\n\t\t\t\t\t&info->var, info);\n\n\t\t\tgoto gotmode;\n\t\t}\n\t}\n\n\t/* Look for a matching VBE mode. */\n\tmodeid = uvesafb_vbe_find_mode(par, info->var.xres, info->var.yres,\n\t\t\tinfo->var.bits_per_pixel, UVESAFB_EXACT_RES);\n\n\tif (modeid == -1)\n\t\treturn -EINVAL;\n\n\tuvesafb_setup_var(&info->var, info, &par->vbe_modes[modeid]);\n\ngotmode:\n\t/*\n\t * If we are not VBE3.0+ compliant, we're done -- the BIOS will\n\t * ignore our timings anyway.\n\t */\n\tif (par->vbe_ib.vbe_version < 0x0300 || par->nocrtc)\n\t\tfb_get_mode(FB_VSYNCTIMINGS | FB_IGNOREMON, 60,\n\t\t\t\t\t&info->var, info);\n\n\treturn modeid;\n}\n\nstatic int uvesafb_setpalette(struct uvesafb_pal_entry *entries, int count,\n\t\tint start, struct fb_info *info)\n{\n\tstruct uvesafb_ktask *task;\n#ifdef CONFIG_X86\n\tstruct uvesafb_par *par = info->par;\n\tint i = par->mode_idx;\n#endif\n\tint err = 0;\n\n\t/*\n\t * We support palette modifications for 8 bpp modes only, so\n\t * there can never be more than 256 entries.\n\t */\n\tif (start + count > 256)\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_X86\n\t/* Use VGA registers if mode is VGA-compatible. */\n\tif (i >= 0 && i < par->vbe_modes_cnt &&\n\t    par->vbe_modes[i].mode_attr & VBE_MODE_VGACOMPAT) {\n\t\tfor (i = 0; i < count; i++) {\n\t\t\toutb_p(start + i,        dac_reg);\n\t\t\toutb_p(entries[i].red,   dac_val);\n\t\t\toutb_p(entries[i].green, dac_val);\n\t\t\toutb_p(entries[i].blue,  dac_val);\n\t\t}\n\t}\n#ifdef CONFIG_X86_32\n\telse if (par->pmi_setpal) {\n\t\t__asm__ __volatile__(\n\t\t\"call *(%%esi)\"\n\t\t: /* no return value */\n\t\t: \"a\" (0x4f09),         /* EAX */\n\t\t  \"b\" (0),              /* EBX */\n\t\t  \"c\" (count),          /* ECX */\n\t\t  \"d\" (start),          /* EDX */\n\t\t  \"D\" (entries),        /* EDI */\n\t\t  \"S\" (&par->pmi_pal)); /* ESI */\n\t}\n#endif /* CONFIG_X86_32 */\n\telse\n#endif /* CONFIG_X86 */\n\t{\n\t\ttask = uvesafb_prep();\n\t\tif (!task)\n\t\t\treturn -ENOMEM;\n\n\t\ttask->t.regs.eax = 0x4f09;\n\t\ttask->t.regs.ebx = 0x0;\n\t\ttask->t.regs.ecx = count;\n\t\ttask->t.regs.edx = start;\n\t\ttask->t.flags = TF_BUF_ESDI;\n\t\ttask->t.buf_len = sizeof(struct uvesafb_pal_entry) * count;\n\t\ttask->buf = entries;\n\n\t\terr = uvesafb_exec(task);\n\t\tif ((task->t.regs.eax & 0xffff) != 0x004f)\n\t\t\terr = 1;\n\n\t\tuvesafb_free(task);\n\t}\n\treturn err;\n}\n\nstatic int uvesafb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\t\tunsigned blue, unsigned transp,\n\t\tstruct fb_info *info)\n{\n\tstruct uvesafb_pal_entry entry;\n\tint shift = 16 - dac_width;\n\tint err = 0;\n\n\tif (regno >= info->cmap.len)\n\t\treturn -EINVAL;\n\n\tif (info->var.bits_per_pixel == 8) {\n\t\tentry.red   = red   >> shift;\n\t\tentry.green = green >> shift;\n\t\tentry.blue  = blue  >> shift;\n\t\tentry.pad   = 0;\n\n\t\terr = uvesafb_setpalette(&entry, 1, regno, info);\n\t} else if (regno < 16) {\n\t\tswitch (info->var.bits_per_pixel) {\n\t\tcase 16:\n\t\t\tif (info->var.red.offset == 10) {\n\t\t\t\t/* 1:5:5:5 */\n\t\t\t\t((u32 *) (info->pseudo_palette))[regno] =\n\t\t\t\t\t\t((red   & 0xf800) >>  1) |\n\t\t\t\t\t\t((green & 0xf800) >>  6) |\n\t\t\t\t\t\t((blue  & 0xf800) >> 11);\n\t\t\t} else {\n\t\t\t\t/* 0:5:6:5 */\n\t\t\t\t((u32 *) (info->pseudo_palette))[regno] =\n\t\t\t\t\t\t((red   & 0xf800)      ) |\n\t\t\t\t\t\t((green & 0xfc00) >>  5) |\n\t\t\t\t\t\t((blue  & 0xf800) >> 11);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 24:\n\t\tcase 32:\n\t\t\tred   >>= 8;\n\t\t\tgreen >>= 8;\n\t\t\tblue  >>= 8;\n\t\t\t((u32 *)(info->pseudo_palette))[regno] =\n\t\t\t\t(red   << info->var.red.offset)   |\n\t\t\t\t(green << info->var.green.offset) |\n\t\t\t\t(blue  << info->var.blue.offset);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tstruct uvesafb_pal_entry *entries;\n\tint shift = 16 - dac_width;\n\tint i, err = 0;\n\n\tif (info->var.bits_per_pixel == 8) {\n\t\tif (cmap->start + cmap->len > info->cmap.start +\n\t\t    info->cmap.len || cmap->start < info->cmap.start)\n\t\t\treturn -EINVAL;\n\n\t\tentries = kmalloc_array(cmap->len, sizeof(*entries),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!entries)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\tentries[i].red   = cmap->red[i]   >> shift;\n\t\t\tentries[i].green = cmap->green[i] >> shift;\n\t\t\tentries[i].blue  = cmap->blue[i]  >> shift;\n\t\t\tentries[i].pad   = 0;\n\t\t}\n\t\terr = uvesafb_setpalette(entries, cmap->len, cmap->start, info);\n\t\tkfree(entries);\n\t} else {\n\t\t/*\n\t\t * For modes with bpp > 8, we only set the pseudo palette in\n\t\t * the fb_info struct. We rely on uvesafb_setcolreg to do all\n\t\t * sanity checking.\n\t\t */\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\terr |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],\n\t\t\t\t\t\tcmap->green[i], cmap->blue[i],\n\t\t\t\t\t\t0, info);\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int uvesafb_pan_display(struct fb_var_screeninfo *var,\n\t\tstruct fb_info *info)\n{\n#ifdef CONFIG_X86_32\n\tint offset;\n\tstruct uvesafb_par *par = info->par;\n\n\toffset = (var->yoffset * info->fix.line_length + var->xoffset) / 4;\n\n\t/*\n\t * It turns out it's not the best idea to do panning via vm86,\n\t * so we only allow it if we have a PMI.\n\t */\n\tif (par->pmi_start) {\n\t\t__asm__ __volatile__(\n\t\t\t\"call *(%%edi)\"\n\t\t\t: /* no return value */\n\t\t\t: \"a\" (0x4f07),         /* EAX */\n\t\t\t  \"b\" (0),              /* EBX */\n\t\t\t  \"c\" (offset),         /* ECX */\n\t\t\t  \"d\" (offset >> 16),   /* EDX */\n\t\t\t  \"D\" (&par->pmi_start));    /* EDI */\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int uvesafb_blank(int blank, struct fb_info *info)\n{\n\tstruct uvesafb_ktask *task;\n\tint err = 1;\n#ifdef CONFIG_X86\n\tstruct uvesafb_par *par = info->par;\n\n\tif (par->vbe_ib.capabilities & VBE_CAP_VGACOMPAT) {\n\t\tint loop = 10000;\n\t\tu8 seq = 0, crtc17 = 0;\n\n\t\tif (blank == FB_BLANK_POWERDOWN) {\n\t\t\tseq = 0x20;\n\t\t\tcrtc17 = 0x00;\n\t\t\terr = 0;\n\t\t} else {\n\t\t\tseq = 0x00;\n\t\t\tcrtc17 = 0x80;\n\t\t\terr = (blank == FB_BLANK_UNBLANK) ? 0 : -EINVAL;\n\t\t}\n\n\t\tvga_wseq(NULL, 0x00, 0x01);\n\t\tseq |= vga_rseq(NULL, 0x01) & ~0x20;\n\t\tvga_wseq(NULL, 0x00, seq);\n\n\t\tcrtc17 |= vga_rcrt(NULL, 0x17) & ~0x80;\n\t\twhile (loop--);\n\t\tvga_wcrt(NULL, 0x17, crtc17);\n\t\tvga_wseq(NULL, 0x00, 0x03);\n\t} else\n#endif /* CONFIG_X86 */\n\t{\n\t\ttask = uvesafb_prep();\n\t\tif (!task)\n\t\t\treturn -ENOMEM;\n\n\t\ttask->t.regs.eax = 0x4f10;\n\t\tswitch (blank) {\n\t\tcase FB_BLANK_UNBLANK:\n\t\t\ttask->t.regs.ebx = 0x0001;\n\t\t\tbreak;\n\t\tcase FB_BLANK_NORMAL:\n\t\t\ttask->t.regs.ebx = 0x0101;\t/* standby */\n\t\t\tbreak;\n\t\tcase FB_BLANK_POWERDOWN:\n\t\t\ttask->t.regs.ebx = 0x0401;\t/* powerdown */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = uvesafb_exec(task);\n\t\tif (err || (task->t.regs.eax & 0xffff) != 0x004f)\n\t\t\terr = 1;\nout:\t\tuvesafb_free(task);\n\t}\n\treturn err;\n}\n\nstatic int uvesafb_open(struct fb_info *info, int user)\n{\n\tstruct uvesafb_par *par = info->par;\n\tint cnt = atomic_read(&par->ref_count);\n\tu8 *buf = NULL;\n\n\tif (!cnt && par->vbe_state_size) {\n\t\tbuf =  uvesafb_vbe_state_save(par);\n\t\tif (IS_ERR(buf)) {\n\t\t\tpr_warn(\"save hardware state failed, error code is %ld!\\n\",\n\t\t\t\tPTR_ERR(buf));\n\t\t} else {\n\t\t\tpar->vbe_state_orig = buf;\n\t\t}\n\t}\n\n\tatomic_inc(&par->ref_count);\n\treturn 0;\n}\n\nstatic int uvesafb_release(struct fb_info *info, int user)\n{\n\tstruct uvesafb_ktask *task = NULL;\n\tstruct uvesafb_par *par = info->par;\n\tint cnt = atomic_read(&par->ref_count);\n\n\tif (!cnt)\n\t\treturn -EINVAL;\n\n\tif (cnt != 1)\n\t\tgoto out;\n\n\ttask = uvesafb_prep();\n\tif (!task)\n\t\tgoto out;\n\n\t/* First, try to set the standard 80x25 text mode. */\n\ttask->t.regs.eax = 0x0003;\n\tuvesafb_exec(task);\n\n\t/*\n\t * Now try to restore whatever hardware state we might have\n\t * saved when the fb device was first opened.\n\t */\n\tuvesafb_vbe_state_restore(par, par->vbe_state_orig);\nout:\n\tatomic_dec(&par->ref_count);\n\tuvesafb_free(task);\n\treturn 0;\n}\n\nstatic int uvesafb_set_par(struct fb_info *info)\n{\n\tstruct uvesafb_par *par = info->par;\n\tstruct uvesafb_ktask *task = NULL;\n\tstruct vbe_crtc_ib *crtc = NULL;\n\tstruct vbe_mode_ib *mode = NULL;\n\tint i, err = 0, depth = info->var.bits_per_pixel;\n\n\tif (depth > 8 && depth != 32)\n\t\tdepth = info->var.red.length + info->var.green.length +\n\t\t\tinfo->var.blue.length;\n\n\ti = uvesafb_vbe_find_mode(par, info->var.xres, info->var.yres, depth,\n\t\t\t\t UVESAFB_EXACT_RES | UVESAFB_EXACT_DEPTH);\n\tif (i >= 0)\n\t\tmode = &par->vbe_modes[i];\n\telse\n\t\treturn -EINVAL;\n\n\ttask = uvesafb_prep();\n\tif (!task)\n\t\treturn -ENOMEM;\nsetmode:\n\ttask->t.regs.eax = 0x4f02;\n\ttask->t.regs.ebx = mode->mode_id | 0x4000;\t/* use LFB */\n\n\tif (par->vbe_ib.vbe_version >= 0x0300 && !par->nocrtc &&\n\t    info->var.pixclock != 0) {\n\t\ttask->t.regs.ebx |= 0x0800;\t\t/* use CRTC data */\n\t\ttask->t.flags = TF_BUF_ESDI;\n\t\tcrtc = kzalloc(sizeof(struct vbe_crtc_ib), GFP_KERNEL);\n\t\tif (!crtc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tcrtc->horiz_start = info->var.xres + info->var.right_margin;\n\t\tcrtc->horiz_end\t  = crtc->horiz_start + info->var.hsync_len;\n\t\tcrtc->horiz_total = crtc->horiz_end + info->var.left_margin;\n\n\t\tcrtc->vert_start  = info->var.yres + info->var.lower_margin;\n\t\tcrtc->vert_end    = crtc->vert_start + info->var.vsync_len;\n\t\tcrtc->vert_total  = crtc->vert_end + info->var.upper_margin;\n\n\t\tcrtc->pixel_clock = PICOS2KHZ(info->var.pixclock) * 1000;\n\t\tcrtc->refresh_rate = (u16)(100 * (crtc->pixel_clock /\n\t\t\t\t(crtc->vert_total * crtc->horiz_total)));\n\n\t\tif (info->var.vmode & FB_VMODE_DOUBLE)\n\t\t\tcrtc->flags |= 0x1;\n\t\tif (info->var.vmode & FB_VMODE_INTERLACED)\n\t\t\tcrtc->flags |= 0x2;\n\t\tif (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))\n\t\t\tcrtc->flags |= 0x4;\n\t\tif (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))\n\t\t\tcrtc->flags |= 0x8;\n\t\tmemcpy(&par->crtc, crtc, sizeof(*crtc));\n\t} else {\n\t\tmemset(&par->crtc, 0, sizeof(*crtc));\n\t}\n\n\ttask->t.buf_len = sizeof(struct vbe_crtc_ib);\n\ttask->buf = &par->crtc;\n\n\terr = uvesafb_exec(task);\n\tif (err || (task->t.regs.eax & 0xffff) != 0x004f) {\n\t\t/*\n\t\t * The mode switch might have failed because we tried to\n\t\t * use our own timings.  Try again with the default timings.\n\t\t */\n\t\tif (crtc != NULL) {\n\t\t\tpr_warn(\"mode switch failed (eax=0x%x, err=%d) - trying again with default timings\\n\",\n\t\t\t\ttask->t.regs.eax, err);\n\t\t\tuvesafb_reset(task);\n\t\t\tkfree(crtc);\n\t\t\tcrtc = NULL;\n\t\t\tinfo->var.pixclock = 0;\n\t\t\tgoto setmode;\n\t\t} else {\n\t\t\tpr_err(\"mode switch failed (eax=0x%x, err=%d)\\n\",\n\t\t\t       task->t.regs.eax, err);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tpar->mode_idx = i;\n\n\t/* For 8bpp modes, always try to set the DAC to 8 bits. */\n\tif (par->vbe_ib.capabilities & VBE_CAP_CAN_SWITCH_DAC &&\n\t    mode->bits_per_pixel <= 8) {\n\t\tuvesafb_reset(task);\n\t\ttask->t.regs.eax = 0x4f08;\n\t\ttask->t.regs.ebx = 0x0800;\n\n\t\terr = uvesafb_exec(task);\n\t\tif (err || (task->t.regs.eax & 0xffff) != 0x004f ||\n\t\t    ((task->t.regs.ebx & 0xff00) >> 8) != 8) {\n\t\t\tdac_width = 6;\n\t\t} else {\n\t\t\tdac_width = 8;\n\t\t}\n\t}\n\n\tinfo->fix.visual = (info->var.bits_per_pixel == 8) ?\n\t\t\t\tFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\n\tinfo->fix.line_length = mode->bytes_per_scan_line;\n\nout:\n\tkfree(crtc);\n\tuvesafb_free(task);\n\n\treturn err;\n}\n\nstatic void uvesafb_check_limits(struct fb_var_screeninfo *var,\n\t\tstruct fb_info *info)\n{\n\tconst struct fb_videomode *mode;\n\tstruct uvesafb_par *par = info->par;\n\n\t/*\n\t * If pixclock is set to 0, then we're using default BIOS timings\n\t * and thus don't have to perform any checks here.\n\t */\n\tif (!var->pixclock)\n\t\treturn;\n\n\tif (par->vbe_ib.vbe_version < 0x0300) {\n\t\tfb_get_mode(FB_VSYNCTIMINGS | FB_IGNOREMON, 60, var, info);\n\t\treturn;\n\t}\n\n\tif (!fb_validate_mode(var, info))\n\t\treturn;\n\n\tmode = fb_find_best_mode(var, &info->modelist);\n\tif (mode) {\n\t\tif (mode->xres == var->xres && mode->yres == var->yres &&\n\t\t    !(mode->vmode & (FB_VMODE_INTERLACED | FB_VMODE_DOUBLE))) {\n\t\t\tfb_videomode_to_var(var, mode);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (info->monspecs.gtf && !fb_get_mode(FB_MAXTIMINGS, 0, var, info))\n\t\treturn;\n\t/* Use default refresh rate */\n\tvar->pixclock = 0;\n}\n\nstatic int uvesafb_check_var(struct fb_var_screeninfo *var,\n\t\tstruct fb_info *info)\n{\n\tstruct uvesafb_par *par = info->par;\n\tstruct vbe_mode_ib *mode = NULL;\n\tint match = -1;\n\tint depth = var->red.length + var->green.length + var->blue.length;\n\n\t/*\n\t * Various apps will use bits_per_pixel to set the color depth,\n\t * which is theoretically incorrect, but which we'll try to handle\n\t * here.\n\t */\n\tif (depth == 0 || abs(depth - var->bits_per_pixel) >= 8)\n\t\tdepth = var->bits_per_pixel;\n\n\tmatch = uvesafb_vbe_find_mode(par, var->xres, var->yres, depth,\n\t\t\t\t\t\tUVESAFB_EXACT_RES);\n\tif (match == -1)\n\t\treturn -EINVAL;\n\n\tmode = &par->vbe_modes[match];\n\tuvesafb_setup_var(var, info, mode);\n\n\t/*\n\t * Check whether we have remapped enough memory for this mode.\n\t * We might be called at an early stage, when we haven't remapped\n\t * any memory yet, in which case we simply skip the check.\n\t */\n\tif (var->yres * mode->bytes_per_scan_line > info->fix.smem_len\n\t\t\t\t\t\t&& info->fix.smem_len)\n\t\treturn -EINVAL;\n\n\tif ((var->vmode & FB_VMODE_DOUBLE) &&\n\t\t\t\t!(par->vbe_modes[match].mode_attr & 0x100))\n\t\tvar->vmode &= ~FB_VMODE_DOUBLE;\n\n\tif ((var->vmode & FB_VMODE_INTERLACED) &&\n\t\t\t\t!(par->vbe_modes[match].mode_attr & 0x200))\n\t\tvar->vmode &= ~FB_VMODE_INTERLACED;\n\n\tuvesafb_check_limits(var, info);\n\n\tvar->xres_virtual = var->xres;\n\tvar->yres_virtual = (par->ypan) ?\n\t\t\t\tinfo->fix.smem_len / mode->bytes_per_scan_line :\n\t\t\t\tvar->yres;\n\treturn 0;\n}\n\nstatic struct fb_ops uvesafb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_open\t= uvesafb_open,\n\t.fb_release\t= uvesafb_release,\n\t.fb_setcolreg\t= uvesafb_setcolreg,\n\t.fb_setcmap\t= uvesafb_setcmap,\n\t.fb_pan_display\t= uvesafb_pan_display,\n\t.fb_blank\t= uvesafb_blank,\n\t.fb_fillrect\t= cfb_fillrect,\n\t.fb_copyarea\t= cfb_copyarea,\n\t.fb_imageblit\t= cfb_imageblit,\n\t.fb_check_var\t= uvesafb_check_var,\n\t.fb_set_par\t= uvesafb_set_par,\n};\n\nstatic void uvesafb_init_info(struct fb_info *info, struct vbe_mode_ib *mode)\n{\n\tunsigned int size_vmode;\n\tunsigned int size_remap;\n\tunsigned int size_total;\n\tstruct uvesafb_par *par = info->par;\n\tint i, h;\n\n\tinfo->pseudo_palette = ((u8 *)info->par + sizeof(struct uvesafb_par));\n\tinfo->fix = uvesafb_fix;\n\tinfo->fix.ypanstep = par->ypan ? 1 : 0;\n\tinfo->fix.ywrapstep = (par->ypan > 1) ? 1 : 0;\n\n\t/* Disable blanking if the user requested so. */\n\tif (!blank)\n\t\tinfo->fbops->fb_blank = NULL;\n\n\t/*\n\t * Find out how much IO memory is required for the mode with\n\t * the highest resolution.\n\t */\n\tsize_remap = 0;\n\tfor (i = 0; i < par->vbe_modes_cnt; i++) {\n\t\th = par->vbe_modes[i].bytes_per_scan_line *\n\t\t\t\t\tpar->vbe_modes[i].y_res;\n\t\tif (h > size_remap)\n\t\t\tsize_remap = h;\n\t}\n\tsize_remap *= 2;\n\n\t/*\n\t *   size_vmode -- that is the amount of memory needed for the\n\t *                 used video mode, i.e. the minimum amount of\n\t *                 memory we need.\n\t */\n\tsize_vmode = info->var.yres * mode->bytes_per_scan_line;\n\n\t/*\n\t *   size_total -- all video memory we have. Used for mtrr\n\t *                 entries, resource allocation and bounds\n\t *                 checking.\n\t */\n\tsize_total = par->vbe_ib.total_memory * 65536;\n\tif (vram_total)\n\t\tsize_total = vram_total * 1024 * 1024;\n\tif (size_total < size_vmode)\n\t\tsize_total = size_vmode;\n\n\t/*\n\t *   size_remap -- the amount of video memory we are going to\n\t *                 use for vesafb.  With modern cards it is no\n\t *                 option to simply use size_total as th\n\t *                 wastes plenty of kernel address space.\n\t */\n\tif (vram_remap)\n\t\tsize_remap = vram_remap * 1024 * 1024;\n\tif (size_remap < size_vmode)\n\t\tsize_remap = size_vmode;\n\tif (size_remap > size_total)\n\t\tsize_remap = size_total;\n\n\tinfo->fix.smem_len = size_remap;\n\tinfo->fix.smem_start = mode->phys_base_ptr;\n\n\t/*\n\t * We have to set yres_virtual here because when setup_var() was\n\t * called, smem_len wasn't defined yet.\n\t */\n\tinfo->var.yres_virtual = info->fix.smem_len /\n\t\t\t\t mode->bytes_per_scan_line;\n\n\tif (par->ypan && info->var.yres_virtual > info->var.yres) {\n\t\tpr_info(\"scrolling: %s using protected mode interface, yres_virtual=%d\\n\",\n\t\t\t(par->ypan > 1) ? \"ywrap\" : \"ypan\",\n\t\t\tinfo->var.yres_virtual);\n\t} else {\n\t\tpr_info(\"scrolling: redraw\\n\");\n\t\tinfo->var.yres_virtual = info->var.yres;\n\t\tpar->ypan = 0;\n\t}\n\n\tinfo->flags = FBINFO_FLAG_DEFAULT |\n\t\t\t(par->ypan ? FBINFO_HWACCEL_YPAN : 0);\n\n\tif (!par->ypan)\n\t\tinfo->fbops->fb_pan_display = NULL;\n}\n\nstatic void uvesafb_init_mtrr(struct fb_info *info)\n{\n\tstruct uvesafb_par *par = info->par;\n\n\tif (mtrr && !(info->fix.smem_start & (PAGE_SIZE - 1))) {\n\t\tint temp_size = info->fix.smem_len;\n\n\t\tint rc;\n\n\t\t/* Find the largest power-of-two */\n\t\ttemp_size = roundup_pow_of_two(temp_size);\n\n\t\t/* Try and find a power of two to add */\n\t\tdo {\n\t\t\trc = arch_phys_wc_add(info->fix.smem_start, temp_size);\n\t\t\ttemp_size >>= 1;\n\t\t} while (temp_size >= PAGE_SIZE && rc == -EINVAL);\n\n\t\tif (rc >= 0)\n\t\t\tpar->mtrr_handle = rc;\n\t}\n}\n\nstatic void uvesafb_ioremap(struct fb_info *info)\n{\n\tinfo->screen_base = ioremap_wc(info->fix.smem_start, info->fix.smem_len);\n}\n\nstatic ssize_t uvesafb_show_vbe_ver(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\n\tstruct uvesafb_par *par = info->par;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%.4x\\n\", par->vbe_ib.vbe_version);\n}\n\nstatic DEVICE_ATTR(vbe_version, S_IRUGO, uvesafb_show_vbe_ver, NULL);\n\nstatic ssize_t uvesafb_show_vbe_modes(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\n\tstruct uvesafb_par *par = info->par;\n\tint ret = 0, i;\n\n\tfor (i = 0; i < par->vbe_modes_cnt && ret < PAGE_SIZE; i++) {\n\t\tret += snprintf(buf + ret, PAGE_SIZE - ret,\n\t\t\t\"%dx%d-%d, 0x%.4x\\n\",\n\t\t\tpar->vbe_modes[i].x_res, par->vbe_modes[i].y_res,\n\t\t\tpar->vbe_modes[i].depth, par->vbe_modes[i].mode_id);\n\t}\n\n\treturn ret;\n}\n\nstatic DEVICE_ATTR(vbe_modes, S_IRUGO, uvesafb_show_vbe_modes, NULL);\n\nstatic ssize_t uvesafb_show_vendor(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\n\tstruct uvesafb_par *par = info->par;\n\n\tif (par->vbe_ib.oem_vendor_name_ptr)\n\t\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", (char *)\n\t\t\t(&par->vbe_ib) + par->vbe_ib.oem_vendor_name_ptr);\n\telse\n\t\treturn 0;\n}\n\nstatic DEVICE_ATTR(oem_vendor, S_IRUGO, uvesafb_show_vendor, NULL);\n\nstatic ssize_t uvesafb_show_product_name(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\n\tstruct uvesafb_par *par = info->par;\n\n\tif (par->vbe_ib.oem_product_name_ptr)\n\t\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", (char *)\n\t\t\t(&par->vbe_ib) + par->vbe_ib.oem_product_name_ptr);\n\telse\n\t\treturn 0;\n}\n\nstatic DEVICE_ATTR(oem_product_name, S_IRUGO, uvesafb_show_product_name, NULL);\n\nstatic ssize_t uvesafb_show_product_rev(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\n\tstruct uvesafb_par *par = info->par;\n\n\tif (par->vbe_ib.oem_product_rev_ptr)\n\t\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", (char *)\n\t\t\t(&par->vbe_ib) + par->vbe_ib.oem_product_rev_ptr);\n\telse\n\t\treturn 0;\n}\n\nstatic DEVICE_ATTR(oem_product_rev, S_IRUGO, uvesafb_show_product_rev, NULL);\n\nstatic ssize_t uvesafb_show_oem_string(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\n\tstruct uvesafb_par *par = info->par;\n\n\tif (par->vbe_ib.oem_string_ptr)\n\t\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t\t(char *)(&par->vbe_ib) + par->vbe_ib.oem_string_ptr);\n\telse\n\t\treturn 0;\n}\n\nstatic DEVICE_ATTR(oem_string, S_IRUGO, uvesafb_show_oem_string, NULL);\n\nstatic ssize_t uvesafb_show_nocrtc(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\n\tstruct uvesafb_par *par = info->par;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", par->nocrtc);\n}\n\nstatic ssize_t uvesafb_store_nocrtc(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\n\tstruct uvesafb_par *par = info->par;\n\n\tif (count > 0) {\n\t\tif (buf[0] == '0')\n\t\t\tpar->nocrtc = 0;\n\t\telse\n\t\t\tpar->nocrtc = 1;\n\t}\n\treturn count;\n}\n\nstatic DEVICE_ATTR(nocrtc, S_IRUGO | S_IWUSR, uvesafb_show_nocrtc,\n\t\t\tuvesafb_store_nocrtc);\n\nstatic struct attribute *uvesafb_dev_attrs[] = {\n\t&dev_attr_vbe_version.attr,\n\t&dev_attr_vbe_modes.attr,\n\t&dev_attr_oem_vendor.attr,\n\t&dev_attr_oem_product_name.attr,\n\t&dev_attr_oem_product_rev.attr,\n\t&dev_attr_oem_string.attr,\n\t&dev_attr_nocrtc.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group uvesafb_dev_attgrp = {\n\t.name = NULL,\n\t.attrs = uvesafb_dev_attrs,\n};\n\nstatic int uvesafb_probe(struct platform_device *dev)\n{\n\tstruct fb_info *info;\n\tstruct vbe_mode_ib *mode = NULL;\n\tstruct uvesafb_par *par;\n\tint err = 0, i;\n\n\tinfo = framebuffer_alloc(sizeof(*par) +\tsizeof(u32) * 256, &dev->dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tpar = info->par;\n\n\terr = uvesafb_vbe_init(info);\n\tif (err) {\n\t\tpr_err(\"vbe_init() failed with %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\tinfo->fbops = &uvesafb_ops;\n\n\ti = uvesafb_vbe_init_mode(info);\n\tif (i < 0) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t} else {\n\t\tmode = &par->vbe_modes[i];\n\t}\n\n\tif (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {\n\t\terr = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tuvesafb_init_info(info, mode);\n\n\tif (!request_region(0x3c0, 32, \"uvesafb\")) {\n\t\tpr_err(\"request region 0x3c0-0x3e0 failed\\n\");\n\t\terr = -EIO;\n\t\tgoto out_mode;\n\t}\n\n\tif (!request_mem_region(info->fix.smem_start, info->fix.smem_len,\n\t\t\t\t\"uvesafb\")) {\n\t\tpr_err(\"cannot reserve video memory at 0x%lx\\n\",\n\t\t       info->fix.smem_start);\n\t\terr = -EIO;\n\t\tgoto out_reg;\n\t}\n\n\tuvesafb_init_mtrr(info);\n\tuvesafb_ioremap(info);\n\n\tif (!info->screen_base) {\n\t\tpr_err(\"abort, cannot ioremap 0x%x bytes of video memory at 0x%lx\\n\",\n\t\t       info->fix.smem_len, info->fix.smem_start);\n\t\terr = -EIO;\n\t\tgoto out_mem;\n\t}\n\n\tplatform_set_drvdata(dev, info);\n\n\tif (register_framebuffer(info) < 0) {\n\t\tpr_err(\"failed to register framebuffer device\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out_unmap;\n\t}\n\n\tpr_info(\"framebuffer at 0x%lx, mapped to 0x%p, using %dk, total %dk\\n\",\n\t\tinfo->fix.smem_start, info->screen_base,\n\t\tinfo->fix.smem_len / 1024, par->vbe_ib.total_memory * 64);\n\tfb_info(info, \"%s frame buffer device\\n\", info->fix.id);\n\n\terr = sysfs_create_group(&dev->dev.kobj, &uvesafb_dev_attgrp);\n\tif (err != 0)\n\t\tfb_warn(info, \"failed to register attributes\\n\");\n\n\treturn 0;\n\nout_unmap:\n\tiounmap(info->screen_base);\nout_mem:\n\trelease_mem_region(info->fix.smem_start, info->fix.smem_len);\nout_reg:\n\trelease_region(0x3c0, 32);\nout_mode:\n\tif (!list_empty(&info->modelist))\n\t\tfb_destroy_modelist(&info->modelist);\n\tfb_destroy_modedb(info->monspecs.modedb);\n\tfb_dealloc_cmap(&info->cmap);\nout:\n\tkfree(par->vbe_modes);\n\n\tframebuffer_release(info);\n\treturn err;\n}\n\nstatic int uvesafb_remove(struct platform_device *dev)\n{\n\tstruct fb_info *info = platform_get_drvdata(dev);\n\n\tif (info) {\n\t\tstruct uvesafb_par *par = info->par;\n\n\t\tsysfs_remove_group(&dev->dev.kobj, &uvesafb_dev_attgrp);\n\t\tunregister_framebuffer(info);\n\t\trelease_region(0x3c0, 32);\n\t\tiounmap(info->screen_base);\n\t\tarch_phys_wc_del(par->mtrr_handle);\n\t\trelease_mem_region(info->fix.smem_start, info->fix.smem_len);\n\t\tfb_destroy_modedb(info->monspecs.modedb);\n\t\tfb_dealloc_cmap(&info->cmap);\n\n\t\tkfree(par->vbe_modes);\n\t\tkfree(par->vbe_state_orig);\n\t\tkfree(par->vbe_state_saved);\n\n\t\tframebuffer_release(info);\n\t}\n\treturn 0;\n}\n\nstatic struct platform_driver uvesafb_driver = {\n\t.probe  = uvesafb_probe,\n\t.remove = uvesafb_remove,\n\t.driver = {\n\t\t.name = \"uvesafb\",\n\t},\n};\n\nstatic struct platform_device *uvesafb_device;\n\n#ifndef MODULE\nstatic int uvesafb_setup(char *options)\n{\n\tchar *this_opt;\n\n\tif (!options || !*options)\n\t\treturn 0;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!*this_opt) continue;\n\n\t\tif (!strcmp(this_opt, \"redraw\"))\n\t\t\typan = 0;\n\t\telse if (!strcmp(this_opt, \"ypan\"))\n\t\t\typan = 1;\n\t\telse if (!strcmp(this_opt, \"ywrap\"))\n\t\t\typan = 2;\n\t\telse if (!strcmp(this_opt, \"vgapal\"))\n\t\t\tpmi_setpal = 0;\n\t\telse if (!strcmp(this_opt, \"pmipal\"))\n\t\t\tpmi_setpal = 1;\n\t\telse if (!strncmp(this_opt, \"mtrr:\", 5))\n\t\t\tmtrr = simple_strtoul(this_opt+5, NULL, 0);\n\t\telse if (!strcmp(this_opt, \"nomtrr\"))\n\t\t\tmtrr = 0;\n\t\telse if (!strcmp(this_opt, \"nocrtc\"))\n\t\t\tnocrtc = 1;\n\t\telse if (!strcmp(this_opt, \"noedid\"))\n\t\t\tnoedid = 1;\n\t\telse if (!strcmp(this_opt, \"noblank\"))\n\t\t\tblank = 0;\n\t\telse if (!strncmp(this_opt, \"vtotal:\", 7))\n\t\t\tvram_total = simple_strtoul(this_opt + 7, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"vremap:\", 7))\n\t\t\tvram_remap = simple_strtoul(this_opt + 7, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"maxhf:\", 6))\n\t\t\tmaxhf = simple_strtoul(this_opt + 6, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"maxvf:\", 6))\n\t\t\tmaxvf = simple_strtoul(this_opt + 6, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"maxclk:\", 7))\n\t\t\tmaxclk = simple_strtoul(this_opt + 7, NULL, 0);\n\t\telse if (!strncmp(this_opt, \"vbemode:\", 8))\n\t\t\tvbemode = simple_strtoul(this_opt + 8, NULL, 0);\n\t\telse if (this_opt[0] >= '0' && this_opt[0] <= '9') {\n\t\t\tmode_option = this_opt;\n\t\t} else {\n\t\t\tpr_warn(\"unrecognized option %s\\n\", this_opt);\n\t\t}\n\t}\n\n\tif (mtrr != 3 && mtrr != 0)\n\t\tpr_warn(\"uvesafb: mtrr should be set to 0 or 3; %d is unsupported\", mtrr);\n\n\treturn 0;\n}\n#endif /* !MODULE */\n\nstatic ssize_t v86d_show(struct device_driver *dev, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", v86d_path);\n}\n\nstatic ssize_t v86d_store(struct device_driver *dev, const char *buf,\n\t\tsize_t count)\n{\n\tstrncpy(v86d_path, buf, PATH_MAX);\n\treturn count;\n}\nstatic DRIVER_ATTR_RW(v86d);\n\nstatic int uvesafb_init(void)\n{\n\tint err;\n\n#ifndef MODULE\n\tchar *option = NULL;\n\n\tif (fb_get_options(\"uvesafb\", &option))\n\t\treturn -ENODEV;\n\tuvesafb_setup(option);\n#endif\n\terr = cn_add_callback(&uvesafb_cn_id, \"uvesafb\", uvesafb_cn_callback);\n\tif (err)\n\t\treturn err;\n\n\terr = platform_driver_register(&uvesafb_driver);\n\n\tif (!err) {\n\t\tuvesafb_device = platform_device_alloc(\"uvesafb\", 0);\n\t\tif (uvesafb_device)\n\t\t\terr = platform_device_add(uvesafb_device);\n\t\telse\n\t\t\terr = -ENOMEM;\n\n\t\tif (err) {\n\t\t\tplatform_device_put(uvesafb_device);\n\t\t\tplatform_driver_unregister(&uvesafb_driver);\n\t\t\tcn_del_callback(&uvesafb_cn_id);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = driver_create_file(&uvesafb_driver.driver,\n\t\t\t\t&driver_attr_v86d);\n\t\tif (err) {\n\t\t\tpr_warn(\"failed to register attributes\\n\");\n\t\t\terr = 0;\n\t\t}\n\t}\n\treturn err;\n}\n\nmodule_init(uvesafb_init);\n\nstatic void uvesafb_exit(void)\n{\n\tstruct uvesafb_ktask *task;\n\n\tif (v86d_started) {\n\t\ttask = uvesafb_prep();\n\t\tif (task) {\n\t\t\ttask->t.flags = TF_EXIT;\n\t\t\tuvesafb_exec(task);\n\t\t\tuvesafb_free(task);\n\t\t}\n\t}\n\n\tcn_del_callback(&uvesafb_cn_id);\n\tdriver_remove_file(&uvesafb_driver.driver, &driver_attr_v86d);\n\tplatform_device_unregister(uvesafb_device);\n\tplatform_driver_unregister(&uvesafb_driver);\n}\n\nmodule_exit(uvesafb_exit);\n\nstatic int param_set_scroll(const char *val, const struct kernel_param *kp)\n{\n\typan = 0;\n\n\tif (!strcmp(val, \"redraw\"))\n\t\typan = 0;\n\telse if (!strcmp(val, \"ypan\"))\n\t\typan = 1;\n\telse if (!strcmp(val, \"ywrap\"))\n\t\typan = 2;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nstatic const struct kernel_param_ops param_ops_scroll = {\n\t.set = param_set_scroll,\n};\n#define param_check_scroll(name, p) __param_check(name, p, void)\n\nmodule_param_named(scroll, ypan, scroll, 0);\nMODULE_PARM_DESC(scroll,\n\t\"Scrolling mode, set to 'redraw', 'ypan', or 'ywrap'\");\nmodule_param_named(vgapal, pmi_setpal, invbool, 0);\nMODULE_PARM_DESC(vgapal, \"Set palette using VGA registers\");\nmodule_param_named(pmipal, pmi_setpal, bool, 0);\nMODULE_PARM_DESC(pmipal, \"Set palette using PMI calls\");\nmodule_param(mtrr, uint, 0);\nMODULE_PARM_DESC(mtrr,\n\t\"Memory Type Range Registers setting. Use 0 to disable.\");\nmodule_param(blank, bool, 0);\nMODULE_PARM_DESC(blank, \"Enable hardware blanking\");\nmodule_param(nocrtc, bool, 0);\nMODULE_PARM_DESC(nocrtc, \"Ignore CRTC timings when setting modes\");\nmodule_param(noedid, bool, 0);\nMODULE_PARM_DESC(noedid,\n\t\"Ignore EDID-provided monitor limits when setting modes\");\nmodule_param(vram_remap, uint, 0);\nMODULE_PARM_DESC(vram_remap, \"Set amount of video memory to be used [MiB]\");\nmodule_param(vram_total, uint, 0);\nMODULE_PARM_DESC(vram_total, \"Set total amount of video memoery [MiB]\");\nmodule_param(maxclk, ushort, 0);\nMODULE_PARM_DESC(maxclk, \"Maximum pixelclock [MHz], overrides EDID data\");\nmodule_param(maxhf, ushort, 0);\nMODULE_PARM_DESC(maxhf,\n\t\"Maximum horizontal frequency [kHz], overrides EDID data\");\nmodule_param(maxvf, ushort, 0);\nMODULE_PARM_DESC(maxvf,\n\t\"Maximum vertical frequency [Hz], overrides EDID data\");\nmodule_param(mode_option, charp, 0);\nMODULE_PARM_DESC(mode_option,\n\t\"Specify initial video mode as \\\"<xres>x<yres>[-<bpp>][@<refresh>]\\\"\");\nmodule_param(vbemode, ushort, 0);\nMODULE_PARM_DESC(vbemode,\n\t\"VBE mode number to set, overrides the 'mode' option\");\nmodule_param_string(v86d, v86d_path, PATH_MAX, 0660);\nMODULE_PARM_DESC(v86d, \"Path to the v86d userspace helper.\");\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Michal Januszewski <spock@gentoo.org>\");\nMODULE_DESCRIPTION(\"Framebuffer driver for VBE2.0+ compliant graphics boards\");\n\n"], "filenames": ["drivers/video/fbdev/uvesafb.c"], "buggy_code_start_loc": [1047], "buggy_code_end_loc": [1048], "fixing_code_start_loc": [1047], "fixing_code_end_loc": [1049], "type": "CWE-190", "message": "An integer overflow in the uvesafb_setcmap function in drivers/video/fbdev/uvesafb.c in the Linux kernel before 4.17.4 could result in local attackers being able to crash the kernel or potentially elevate privileges because kmalloc_array is not used.", "other": {"cve": {"id": "CVE-2018-13406", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-06T14:29:01.287", "lastModified": "2023-02-24T18:37:35.957", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An integer overflow in the uvesafb_setcmap function in drivers/video/fbdev/uvesafb.c in the Linux kernel before 4.17.4 could result in local attackers being able to crash the kernel or potentially elevate privileges because kmalloc_array is not used."}, {"lang": "es", "value": "Un desbordamiento de enteros en la funci\u00f3n uvesafb_setcmap en drivers/video/fbdev/uvesafb.c en el kernel de Linux en versiones anteriores a la 4.17.4 podr\u00eda resultar en que los atacantes locales puedan cerrar inesperadamente el kernel o elevar privilegios debido a que no se emplea kmalloc_array."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.6.24", "versionEndExcluding": "3.16.58", "matchCriteriaId": "31CCCF87-8A36-4E19-BA79-B029333E1A53"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "3.18.114", "matchCriteriaId": "DB372191-C0D0-4019-8693-3E0F28145791"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.19", "versionEndExcluding": "4.4.139", "matchCriteriaId": "ADA25713-590A-499D-B0D9-50C8E9360FFD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.111", "matchCriteriaId": "D6DD85D5-9C65-45E1-8D56-14E23CDB2744"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.14.53", "matchCriteriaId": "BED521F0-3242-49B0-B663-1CFE8E123620"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.15", "versionEndExcluding": "4.17.4", "matchCriteriaId": "BB0CE3BC-2D14-475F-94A9-A9D7DAE36206"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=9f645bcc566a1e9f921bdae7528a01ced5bc3713", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://www.securityfocus.com/bid/104685", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1041355", "source": "cve@mitre.org", "tags": ["VDB Entry", "Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.17.4", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/torvalds/linux/commit/9f645bcc566a1e9f921bdae7528a01ced5bc3713", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/03/msg00017.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3752-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3752-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3752-3/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3753-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3753-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3754-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/9f645bcc566a1e9f921bdae7528a01ced5bc3713"}}