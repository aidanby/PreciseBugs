{"buggy_code": ["package org.xerial.snappy;\n\nimport java.io.OutputStream;\n\nimport org.xerial.snappy.buffer.CachedBufferAllocator;\n\npublic class SnappyHadoopCompatibleOutputStream extends SnappyOutputStream\n{\n    public SnappyHadoopCompatibleOutputStream(OutputStream out)\n    {\n        this(out, DEFAULT_BLOCK_SIZE);\n    }\n\n    public SnappyHadoopCompatibleOutputStream(OutputStream out, int blockSize)\n    {\n        super(out, blockSize, CachedBufferAllocator.getBufferAllocatorFactory());\n    }\n\n    @Override\n    protected int writeHeader()\n    {\n        return 0;\n    }\n\n    @Override\n    protected void writeBlockPreemble()\n    {\n        writeCurrentDataSize();\n    }\n}\n", "/*--------------------------------------------------------------------------\n *  Copyright 2011 Taro L. Saito\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *--------------------------------------------------------------------------*/\n//--------------------------------------\n// XerialJ\n//\n// SnappyInputStream.java\n// Since: 2011/03/31 20:14:56\n//\n// $URL$\n// $Author$\n//--------------------------------------\npackage org.xerial.snappy;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * A stream filter for reading data compressed by {@link SnappyOutputStream}.\n *\n * @author leo\n */\npublic class SnappyInputStream\n        extends InputStream\n{\n    private boolean finishedReading = false;\n    protected final InputStream in;\n\n    private byte[] compressed;\n    private byte[] uncompressed;\n    private int uncompressedCursor = 0;\n    private int uncompressedLimit = 0;\n\n    private byte[] header = new byte[SnappyCodec.headerSize()];\n\n    /**\n     * Create a filter for reading compressed data as a uncompressed stream\n     *\n     * @param input\n     * @throws IOException\n     */\n    public SnappyInputStream(InputStream input)\n            throws IOException\n    {\n        this.in = input;\n        readHeader();\n    }\n\n    /**\n     * Close the stream\n     */\n    /* (non-Javadoc)\n     * @see java.io.InputStream#close()\n     */\n    @Override\n    public void close()\n            throws IOException\n    {\n        compressed = null;\n        uncompressed = null;\n        if (in != null) {\n            in.close();\n        }\n    }\n\n    protected void readHeader()\n            throws IOException\n    {\n        int readBytes = 0;\n        while (readBytes < header.length) {\n            int ret = in.read(header, readBytes, header.length - readBytes);\n            if (ret == -1) {\n                break;\n            }\n            readBytes += ret;\n        }\n\n        // Quick test of the header\n        if (readBytes == 0) {\n            // Snappy produces at least 1-byte result. So the empty input is not a valid input\n            throw new SnappyIOException(SnappyErrorCode.EMPTY_INPUT, \"Cannot decompress empty stream\");\n        }\n        if (readBytes < header.length || !SnappyCodec.hasMagicHeaderPrefix(header)) {\n            // do the default uncompression\n            // (probably) compressed by Snappy.compress(byte[])\n            readFully(header, readBytes);\n            return;\n        }\n    }\n\n    private static boolean isValidHeader(byte[] header)\n            throws IOException\n    {\n        SnappyCodec codec = SnappyCodec.readHeader(new ByteArrayInputStream(header));\n        if (codec.isValidMagicHeader()) {\n            // The input data is compressed by SnappyOutputStream\n            if (codec.version < SnappyCodec.MINIMUM_COMPATIBLE_VERSION) {\n                throw new SnappyIOException(SnappyErrorCode.INCOMPATIBLE_VERSION, String.format(\n                        \"Compressed with an incompatible codec version %d. At least version %d is required\",\n                        codec.version, SnappyCodec.MINIMUM_COMPATIBLE_VERSION));\n            }\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n\n    protected void readFully(byte[] fragment, int fragmentLength)\n            throws IOException\n    {\n        if (fragmentLength == 0) {\n            finishedReading = true;\n            return;\n        }\n        // read the entire input data to the buffer\n        compressed = new byte[Math.max(8 * 1024, fragmentLength)]; // 8K\n        System.arraycopy(fragment, 0, compressed, 0, fragmentLength);\n        int cursor = fragmentLength;\n        for (int readBytes = 0; (readBytes = in.read(compressed, cursor, compressed.length - cursor)) != -1; ) {\n            cursor += readBytes;\n            if (cursor >= compressed.length) {\n                byte[] newBuf = new byte[(compressed.length * 2)];\n                System.arraycopy(compressed, 0, newBuf, 0, compressed.length);\n                compressed = newBuf;\n            }\n        }\n\n        finishedReading = true;\n\n        // Uncompress\n        int uncompressedLength = Snappy.uncompressedLength(compressed, 0, cursor);\n        uncompressed = new byte[uncompressedLength];\n        Snappy.uncompress(compressed, 0, cursor, uncompressed, 0);\n        this.uncompressedCursor = 0;\n        this.uncompressedLimit = uncompressedLength;\n    }\n\n    /**\n     * Reads up to len bytes of data from the input stream into an array of\n     * bytes.\n     */\n    /* (non-Javadoc)\n     * @see java.io.InputStream#read(byte[], int, int)\n     */\n    @Override\n    public int read(byte[] b, int byteOffset, int byteLength)\n            throws IOException\n    {\n        int writtenBytes = 0;\n        for (; writtenBytes < byteLength; ) {\n\n            if (uncompressedCursor >= uncompressedLimit) {\n                if (hasNextChunk()) {\n                    continue;\n                }\n                else {\n                    return writtenBytes == 0 ? -1 : writtenBytes;\n                }\n            }\n            int bytesToWrite = Math.min(uncompressedLimit - uncompressedCursor, byteLength - writtenBytes);\n            System.arraycopy(uncompressed, uncompressedCursor, b, byteOffset + writtenBytes, bytesToWrite);\n            writtenBytes += bytesToWrite;\n            uncompressedCursor += bytesToWrite;\n        }\n\n        return writtenBytes;\n    }\n\n    /**\n     * Read uncompressed data into the specified array\n     *\n     * @param array\n     * @param byteOffset\n     * @param byteLength\n     * @return written bytes\n     * @throws IOException\n     */\n    public int rawRead(Object array, int byteOffset, int byteLength)\n            throws IOException\n    {\n        int writtenBytes = 0;\n        for (; writtenBytes < byteLength; ) {\n\n            if (uncompressedCursor >= uncompressedLimit) {\n                if (hasNextChunk()) {\n                    continue;\n                }\n                else {\n                    return writtenBytes == 0 ? -1 : writtenBytes;\n                }\n            }\n            int bytesToWrite = Math.min(uncompressedLimit - uncompressedCursor, byteLength - writtenBytes);\n            Snappy.arrayCopy(uncompressed, uncompressedCursor, bytesToWrite, array, byteOffset + writtenBytes);\n            writtenBytes += bytesToWrite;\n            uncompressedCursor += bytesToWrite;\n        }\n\n        return writtenBytes;\n    }\n\n    /**\n     * Read long array from the stream\n     *\n     * @param d input\n     * @param off offset\n     * @param len the number of long elements to read\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(long[] d, int off, int len)\n            throws IOException\n    {\n        return rawRead(d, off * 8, len * 8);\n    }\n\n    /**\n     * Read long array from the stream\n     *\n     * @param d\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(long[] d)\n            throws IOException\n    {\n        return read(d, 0, d.length);\n    }\n\n    /**\n     * Read double array from the stream\n     *\n     * @param d input\n     * @param off offset\n     * @param len the number of double elements to read\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(double[] d, int off, int len)\n            throws IOException\n    {\n        return rawRead(d, off * 8, len * 8);\n    }\n\n    /**\n     * Read double array from the stream\n     *\n     * @param d\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(double[] d)\n            throws IOException\n    {\n        return read(d, 0, d.length);\n    }\n\n    /**\n     * Read int array from the stream\n     *\n     * @param d\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(int[] d)\n            throws IOException\n    {\n        return read(d, 0, d.length);\n    }\n\n    /**\n     * Read int array from the stream\n     *\n     * @param d input\n     * @param off offset\n     * @param len the number of int elements to read\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(int[] d, int off, int len)\n            throws IOException\n    {\n        return rawRead(d, off * 4, len * 4);\n    }\n\n    /**\n     * Read float array from the stream\n     *\n     * @param d input\n     * @param off offset\n     * @param len the number of float elements to read\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(float[] d, int off, int len)\n            throws IOException\n    {\n        return rawRead(d, off * 4, len * 4);\n    }\n\n    /**\n     * Read float array from the stream\n     *\n     * @param d\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(float[] d)\n            throws IOException\n    {\n        return read(d, 0, d.length);\n    }\n\n    /**\n     * Read short array from the stream\n     *\n     * @param d input\n     * @param off offset\n     * @param len the number of short elements to read\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(short[] d, int off, int len)\n            throws IOException\n    {\n        return rawRead(d, off * 2, len * 2);\n    }\n\n    /**\n     * Read short array from the stream\n     *\n     * @param d\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(short[] d)\n            throws IOException\n    {\n        return read(d, 0, d.length);\n    }\n\n    /**\n     * Read next len bytes\n     *\n     * @param dest\n     * @param offset\n     * @param len\n     * @return read bytes\n     */\n    private int readNext(byte[] dest, int offset, int len)\n            throws IOException\n    {\n        int readBytes = 0;\n        while (readBytes < len) {\n            int ret = in.read(dest, readBytes + offset, len - readBytes);\n            if (ret == -1) {\n                finishedReading = true;\n                return readBytes;\n            }\n            readBytes += ret;\n        }\n        return readBytes;\n    }\n\n    protected boolean hasNextChunk()\n            throws IOException\n    {\n        if (finishedReading) {\n            return false;\n        }\n\n        uncompressedCursor = 0;\n        uncompressedLimit = 0;\n\n        int readBytes = readNext(header, 0, 4);\n        if (readBytes < 4) {\n            return false;\n        }\n\n        int chunkSize = SnappyOutputStream.readInt(header, 0);\n        if (chunkSize == SnappyCodec.MAGIC_HEADER_HEAD) {\n            // Concatenated data\n            int remainingHeaderSize = SnappyCodec.headerSize() - 4;\n            readBytes = readNext(header, 4, remainingHeaderSize);\n            if(readBytes < remainingHeaderSize) {\n                throw new SnappyIOException(SnappyErrorCode.FAILED_TO_UNCOMPRESS, String.format(\"Insufficient header size in a concatenated block\"));\n            }\n\n            if (isValidHeader(header)) {\n                return hasNextChunk();\n            }\n            else {\n                return false;\n            }\n        }\n\n        // chunkSize is negative\n        if (chunkSize < 0) {\n            throw new SnappyError(SnappyErrorCode.INVALID_CHUNK_SIZE, \"chunkSize is too big or negative : \" + chunkSize);\n        }\n\n        // extend the compressed data buffer size\n        if (compressed == null || chunkSize > compressed.length) {\n            // chunkSize exceeds limit\n            try {\n                compressed = new byte[chunkSize];\n            }\n            catch (java.lang.OutOfMemoryError e) {\n                throw new SnappyError(SnappyErrorCode.INVALID_CHUNK_SIZE, e.getMessage());\n            }\n        }\n        readBytes = 0;\n        while (readBytes < chunkSize) {\n            int ret = in.read(compressed, readBytes, chunkSize - readBytes);\n            if (ret == -1) {\n                break;\n            }\n            readBytes += ret;\n        }\n        if (readBytes < chunkSize) {\n            throw new IOException(\"failed to read chunk\");\n        }\n        int uncompressedLength = Snappy.uncompressedLength(compressed, 0, chunkSize);\n        if (uncompressed == null || uncompressedLength > uncompressed.length) {\n            uncompressed = new byte[uncompressedLength];\n        }\n        int actualUncompressedLength = Snappy.uncompress(compressed, 0, chunkSize, uncompressed, 0);\n        if (uncompressedLength != actualUncompressedLength) {\n            throw new SnappyIOException(SnappyErrorCode.INVALID_CHUNK_SIZE, String.format(\"expected %,d bytes, but decompressed chunk has %,d bytes\", uncompressedLength, actualUncompressedLength));\n        }\n        uncompressedLimit = actualUncompressedLength;\n\n        return true;\n    }\n\n    /**\n     * Reads the next byte of uncompressed data from the input stream. The value\n     * byte is returned as an int in the range 0 to 255. If no byte is available\n     * because the end of the stream has been reached, the value -1 is returned.\n     * This method blocks until input data is available, the end of the stream\n     * is detected, or an exception is thrown.\n     */\n    /* (non-Javadoc)\n     * @see java.io.InputStream#read()\n     */\n    @Override\n    public int read()\n            throws IOException\n    {\n        if (uncompressedCursor < uncompressedLimit) {\n            return uncompressed[uncompressedCursor++] & 0xFF;\n        }\n        else {\n            if (hasNextChunk()) {\n                return read();\n            }\n            else {\n                return -1;\n            }\n        }\n    }\n\n    /* (non-Javadoc)\n     * @see java.io.InputStream#available()\n     */\n    @Override\n    public int available()\n            throws IOException\n    {\n        if (uncompressedCursor < uncompressedLimit) {\n            return uncompressedLimit - uncompressedCursor;\n        }\n        else {\n            if (hasNextChunk()) {\n                return uncompressedLimit - uncompressedCursor;\n            }\n            else {\n                return 0;\n            }\n        }\n    }\n}\n", "/*--------------------------------------------------------------------------\n *  Copyright 2011 Taro L. Saito\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *--------------------------------------------------------------------------*/\n//--------------------------------------\n// XerialJ\n//\n// SnappyOutputStream.java\n// Since: 2011/03/31 17:44:10\n//\n// $URL$\n// $Author$\n//--------------------------------------\npackage org.xerial.snappy;\n\nimport org.xerial.snappy.buffer.BufferAllocatorFactory;\nimport org.xerial.snappy.buffer.BufferAllocator;\nimport org.xerial.snappy.buffer.CachedBufferAllocator;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\n/**\n * This class implements a stream filter for writing compressed data using\n * Snappy.\n * <p>\n * The input data is blocked into 32kb size (in default), and each block is\n * compressed and then passed to the given {@link OutputStream}.\n * </p>\n * The output data format is:\n * <ol>\n * <li>snappy codec header defined in {@link SnappyCodec} (8 bytes)\n * <li>codec version (4 bytes integer, at least 1) and compatible version (4 bytes integer)\n * <li>compressed block 1 : a pair of (compressed data size [4 byte integer.\n * Big-endian], compressed data...)\n * <li>compressed block 2\n * <li>...\n * </ol>\n * <p/>\n * Note that the compressed data created by {@link SnappyOutputStream} cannot be\n * uncompressed by {@link Snappy#uncompress(byte[])} since the output formats of\n * {@link Snappy#compress(byte[])} and {@link SnappyOutputStream} are different.\n * Use {@link SnappyInputStream} for uncompress the data generated by\n * {@link SnappyOutputStream}.\n *\n * @author leo\n */\npublic class SnappyOutputStream\n        extends OutputStream\n{\n    static final int MIN_BLOCK_SIZE = 1 * 1024;\n    static final int DEFAULT_BLOCK_SIZE = 32 * 1024; // Use 32kb for the default block size\n\n    protected final OutputStream out;\n    private final int blockSize;\n\n    private final BufferAllocator inputBufferAllocator;\n    private final BufferAllocator outputBufferAllocator;\n\n    // The input and output buffer fields are set to null when closing this stream:\n    protected byte[] inputBuffer;\n    protected byte[] outputBuffer;\n    private int inputCursor = 0;\n    private int outputCursor = 0;\n    private boolean headerWritten;\n    private boolean closed;\n\n    public SnappyOutputStream(OutputStream out)\n    {\n        this(out, DEFAULT_BLOCK_SIZE);\n    }\n\n    /**\n     * @param out\n     * @param blockSize byte size of the internal buffer size\n     * @throws IOException\n     */\n    public SnappyOutputStream(OutputStream out, int blockSize)\n    {\n        this(out, blockSize, CachedBufferAllocator.getBufferAllocatorFactory());\n    }\n\n    public SnappyOutputStream(OutputStream out, int blockSize, BufferAllocatorFactory bufferAllocatorFactory)\n    {\n        this.out = out;\n        this.blockSize = Math.max(MIN_BLOCK_SIZE, blockSize);\n        int inputSize = blockSize;\n        int outputSize = SnappyCodec.HEADER_SIZE + 4 + Snappy.maxCompressedLength(blockSize);\n\n        this.inputBufferAllocator = bufferAllocatorFactory.getBufferAllocator(inputSize);\n        this.outputBufferAllocator = bufferAllocatorFactory.getBufferAllocator(outputSize);\n\n        inputBuffer = inputBufferAllocator.allocate(inputSize);\n        outputBuffer = outputBufferAllocator.allocate(outputSize);\n    }\n\n    /* (non-Javadoc)\n     * @see java.io.OutputStream#write(byte[], int, int)\n     */\n    @Override\n    public void write(byte[] b, int byteOffset, int byteLength)\n            throws IOException\n    {\n        if (closed) {\n            throw new IOException(\"Stream is closed\");\n        }\n        int cursor = 0;\n        while (cursor < byteLength) {\n            int readLen = Math.min(byteLength - cursor, blockSize - inputCursor);\n            // copy the input data to uncompressed buffer\n            if (readLen > 0) {\n                System.arraycopy(b, byteOffset + cursor, inputBuffer, inputCursor, readLen);\n                inputCursor += readLen;\n            }\n            if (inputCursor < blockSize) {\n                return;\n            }\n\n            compressInput();\n            cursor += readLen;\n        }\n    }\n\n    /**\n     * Compress the input long array data\n     *\n     * @param d input array\n     * @param off offset in the array\n     * @param len the number of elements in the array to copy\n     * @throws IOException\n     */\n    public void write(long[] d, int off, int len)\n            throws IOException\n    {\n        rawWrite(d, off * 8, len * 8);\n    }\n\n    /**\n     * Compress the input double array data\n     *\n     * @param f input array\n     * @param off offset in the array\n     * @param len the number of elements in the array to copy\n     * @throws IOException\n     */\n    public void write(double[] f, int off, int len)\n            throws IOException\n    {\n        rawWrite(f, off * 8, len * 8);\n    }\n\n    /**\n     * Compress the input float array data\n     *\n     * @param f input array\n     * @param off offset in the array\n     * @param len the number of elements in the array to copy\n     * @throws IOException\n     */\n    public void write(float[] f, int off, int len)\n            throws IOException\n    {\n        rawWrite(f, off * 4, len * 4);\n    }\n\n    /**\n     * Compress the input int array data\n     *\n     * @param f input array\n     * @param off offset in the array\n     * @param len the number of elements in the array to copy\n     * @throws IOException\n     */\n    public void write(int[] f, int off, int len)\n            throws IOException\n    {\n        rawWrite(f, off * 4, len * 4);\n    }\n\n    /**\n     * Compress the input short array data\n     *\n     * @param f input array\n     * @param off offset in the array\n     * @param len the number of elements in the array to copy\n     * @throws IOException\n     */\n    public void write(short[] f, int off, int len)\n            throws IOException\n    {\n        rawWrite(f, off * 2, len * 2);\n    }\n\n    /**\n     * Compress the input array data\n     *\n     * @param d\n     * @throws IOException\n     */\n    public void write(long[] d)\n            throws IOException\n    {\n        write(d, 0, d.length);\n    }\n\n    /**\n     * Compress the input array data\n     *\n     * @param f\n     * @throws IOException\n     */\n    public void write(double[] f)\n            throws IOException\n    {\n        write(f, 0, f.length);\n    }\n\n    /**\n     * Compress the input array data\n     *\n     * @param f\n     * @throws IOException\n     */\n    public void write(float[] f)\n            throws IOException\n    {\n        write(f, 0, f.length);\n    }\n\n    /**\n     * Compress the input array data\n     *\n     * @param f\n     * @throws IOException\n     */\n    public void write(int[] f)\n            throws IOException\n    {\n        write(f, 0, f.length);\n    }\n\n    /**\n     * Compress the input array data\n     *\n     * @param f\n     * @throws IOException\n     */\n    public void write(short[] f)\n            throws IOException\n    {\n        write(f, 0, f.length);\n    }\n\n    private boolean hasSufficientOutputBufferFor(int inputSize)\n    {\n        int maxCompressedSize = Snappy.maxCompressedLength(inputSize);\n        return maxCompressedSize < outputBuffer.length - outputCursor - 4;\n    }\n\n    /**\n     * Compress the raw byte array data.\n     *\n     * @param array array data of any type (e.g., byte[], float[], long[], ...)\n     * @param byteOffset\n     * @param byteLength\n     * @throws IOException\n     */\n    public void rawWrite(Object array, int byteOffset, int byteLength)\n            throws IOException\n    {\n        if (closed) {\n            throw new IOException(\"Stream is closed\");\n        }\n        int cursor = 0;\n        while (cursor < byteLength) {\n            int readLen = Math.min(byteLength - cursor, blockSize - inputCursor);\n            // copy the input data to uncompressed buffer\n            if (readLen > 0) {\n                Snappy.arrayCopy(array, byteOffset + cursor, readLen, inputBuffer, inputCursor);\n                inputCursor += readLen;\n            }\n            if (inputCursor < blockSize) {\n                return;\n            }\n\n            compressInput();\n            cursor += readLen;\n        }\n    }\n\n    /**\n     * Writes the specified byte to this output stream. The general contract for\n     * write is that one byte is written to the output stream. The byte to be\n     * written is the eight low-order bits of the argument b. The 24 high-order\n     * bits of b are ignored.\n     */\n    /* (non-Javadoc)\n     * @see java.io.OutputStream#write(int)\n     */\n    @Override\n    public void write(int b)\n            throws IOException\n    {\n        if (closed) {\n            throw new IOException(\"Stream is closed\");\n        }\n        if (inputCursor >= inputBuffer.length) {\n            compressInput();\n        }\n        inputBuffer[inputCursor++] = (byte) b;\n    }\n\n    /* (non-Javadoc)\n     * @see java.io.OutputStream#flush()\n     */\n    @Override\n    public void flush()\n            throws IOException\n    {\n        if (closed) {\n            throw new IOException(\"Stream is closed\");\n        }\n        compressInput();\n        dumpOutput();\n        out.flush();\n    }\n\n    static void writeInt(byte[] dst, int offset, int v)\n    {\n        dst[offset] = (byte) ((v >> 24) & 0xFF);\n        dst[offset + 1] = (byte) ((v >> 16) & 0xFF);\n        dst[offset + 2] = (byte) ((v >> 8) & 0xFF);\n        dst[offset + 3] = (byte) ((v >> 0) & 0xFF);\n    }\n\n    static int readInt(byte[] buffer, int pos)\n    {\n        int b1 = (buffer[pos] & 0xFF) << 24;\n        int b2 = (buffer[pos + 1] & 0xFF) << 16;\n        int b3 = (buffer[pos + 2] & 0xFF) << 8;\n        int b4 = buffer[pos + 3] & 0xFF;\n        return b1 | b2 | b3 | b4;\n    }\n\n    protected void dumpOutput()\n            throws IOException\n    {\n        if (outputCursor > 0) {\n            out.write(outputBuffer, 0, outputCursor);\n            outputCursor = 0;\n        }\n    }\n\n    protected void compressInput()\n            throws IOException\n    {\n        if (!headerWritten) {\n            outputCursor = writeHeader();\n            headerWritten = true;\n        }\n        if (inputCursor <= 0) {\n            return; // no need to dump\n        }\n        // Compress and dump the buffer content\n        if (!hasSufficientOutputBufferFor(inputCursor)) {\n            dumpOutput();\n        }\n        writeBlockPreemble();\n        int compressedSize = Snappy.compress(inputBuffer, 0, inputCursor, outputBuffer, outputCursor + 4);\n        // Write compressed data size\n        writeInt(outputBuffer, outputCursor, compressedSize);\n        outputCursor += 4 + compressedSize;\n        inputCursor = 0;\n    }\n\n    protected int writeHeader(){\n        return SnappyCodec.currentHeader.writeHeader(outputBuffer, 0);\n    }\n\n    /**\n     * Optionally write a preemble before a block. Hadoop requires the actual block data size being written. This base\n     * implementation does nothing. Derive implementation can call {@code writeCurrentDataSize()}.\n     */\n    protected void writeBlockPreemble()\n    {\n        // do nothing\n    }\n\n    protected void writeCurrentDataSize(){\n        writeInt(outputBuffer, outputCursor, inputCursor);\n        outputCursor += 4;\n    }\n\n    /**\n     * close the stream\n     */\n    /* (non-Javadoc)\n     * @see java.io.OutputStream#close()\n     */\n    @Override\n    public void close()\n            throws IOException\n    {\n        if (closed) {\n            return;\n        }\n        try {\n            flush();\n            out.close();\n        }\n        finally {\n            closed = true;\n            inputBufferAllocator.release(inputBuffer);\n            outputBufferAllocator.release(outputBuffer);\n            inputBuffer = null;\n            outputBuffer = null;\n        }\n    }\n}\n", "/*--------------------------------------------------------------------------\n *  Copyright 2011 Taro L. Saito\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *--------------------------------------------------------------------------*/\n//--------------------------------------\n// XerialJ\n//\n// SnappyOutputStreamTest.java\n// Since: 2011/03/31 18:26:31\n//\n// $URL$\n// $Author$\n//--------------------------------------\npackage org.xerial.snappy;\n\nimport static org.junit.Assert.*;\n\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\nimport java.nio.ByteOrder;\n\nimport org.junit.Test;\nimport org.xerial.snappy.buffer.BufferAllocatorFactory;\nimport org.xerial.snappy.buffer.CachedBufferAllocator;\nimport org.xerial.snappy.buffer.DefaultBufferAllocator;\nimport org.xerial.util.FileResource;\nimport org.xerial.util.log.Logger;\n\npublic class SnappyOutputStreamTest\n{\n    private static Logger _logger = Logger.getLogger(SnappyOutputStreamTest.class);\n\n    @Test\n    public void test()\n            throws Exception\n    {\n        ByteArrayOutputStream buf = new ByteArrayOutputStream();\n        SnappyOutputStream sout = new SnappyOutputStream(buf);\n\n        BufferedInputStream input = new BufferedInputStream(FileResource.find(SnappyOutputStreamTest.class,\n                \"alice29.txt\").openStream());\n        assertNotNull(input);\n\n        ByteArrayOutputStream orig = new ByteArrayOutputStream();\n        byte[] tmp = new byte[1024];\n        for (int readBytes = 0; (readBytes = input.read(tmp)) != -1; ) {\n            sout.write(tmp, 0, readBytes);\n            orig.write(tmp, 0, readBytes); // preserve the original data\n        }\n        input.close();\n        sout.flush();\n        orig.flush();\n\n        int compressedSize = buf.size();\n        _logger.debug(\"compressed size: \" + compressedSize);\n\n        ByteArrayOutputStream decompressed = new ByteArrayOutputStream();\n        byte[] compressed = buf.toByteArray();\n        // decompress\n        for (int cursor = SnappyCodec.headerSize(); cursor < compressed.length; ) {\n            int chunkSize = SnappyOutputStream.readInt(compressed, cursor);\n            cursor += 4;\n            byte[] tmpOut = new byte[Snappy.uncompressedLength(compressed, cursor, chunkSize)];\n            int decompressedSize = Snappy.uncompress(compressed, cursor, chunkSize, tmpOut, 0);\n            cursor += chunkSize;\n\n            decompressed.write(tmpOut);\n        }\n        decompressed.flush();\n        assertEquals(orig.size(), decompressed.size());\n        assertArrayEquals(orig.toByteArray(), decompressed.toByteArray());\n    }\n\n    @Test\n    public void bufferSize()\n            throws Exception\n    {\n        ByteArrayOutputStream b = new ByteArrayOutputStream();\n        SnappyOutputStream os = new SnappyOutputStream(b, 1500);\n        final int bytesToWrite = 5000;\n        byte[] orig = new byte[bytesToWrite];\n        for (int i = 0; i < 5000; ++i) {\n            byte v = (byte) (i % 128);\n            orig[i] = v;\n            os.write(v);\n        }\n        os.close();\n        SnappyInputStream is = new SnappyInputStream(new ByteArrayInputStream(b.toByteArray()));\n        byte[] buf = new byte[bytesToWrite / 101];\n        while (is.read(buf) != -1) {\n        }\n        is.close();\n    }\n\n    @Test\n    public void smallWrites()\n            throws Exception\n    {\n\n        byte[] orig = CalgaryTest.readFile(\"alice29.txt\");\n        ByteArrayOutputStream b = new ByteArrayOutputStream();\n        SnappyOutputStream out = new SnappyOutputStream(b);\n\n        for (byte c : orig) {\n            out.write(c);\n        }\n        out.close();\n\n        SnappyInputStream is = new SnappyInputStream(new ByteArrayInputStream(b.toByteArray()));\n        byte[] decompressed = new byte[orig.length];\n        int cursor = 0;\n        int readLen = 0;\n        for (int i = 0; i < decompressed.length && (readLen = is.read(decompressed, i, decompressed.length - i)) != -1; ) {\n            i += readLen;\n        }\n        is.close();\n        assertArrayEquals(orig, decompressed);\n    }\n\n    /**\n     * Compress the input array by passing it chunk-by-chunk to a SnappyOutputStream.\n     *\n     * @param orig the data to compress\n     * @param maxChunkSize the maximum chunk size, in bytes.\n     * @return the compressed bytes\n     */\n    private static byte[] compressAsChunks(byte[] orig, int maxChunkSize)\n            throws Exception\n    {\n        ByteArrayOutputStream b = new ByteArrayOutputStream();\n        SnappyOutputStream out = new SnappyOutputStream(b);\n\n        int remaining = orig.length;\n        for (int start = 0; start < orig.length; start += maxChunkSize) {\n            out.write(orig, start, remaining < maxChunkSize ? remaining : maxChunkSize);\n            remaining -= maxChunkSize;\n        }\n        out.close();\n        return b.toByteArray();\n    }\n\n    @Test\n    public void batchingOfWritesShouldNotAffectCompressedDataSize()\n            throws Exception\n    {\n        // Regression test for issue #100, a bug where the size of compressed data could be affected\n        // by the batching of writes to the SnappyOutputStream rather than the total amount of data\n        // written to the stream.\n        byte[] orig = CalgaryTest.readFile(\"alice29.txt\");\n        // Compress the data once so that we know the expected size:\n        byte[] expectedCompressedData = compressAsChunks(orig, Integer.MAX_VALUE);\n        // Hardcoding an expected compressed size here will catch regressions that lower the\n        // compression quality:\n        if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN)\n            assertEquals(90992, expectedCompressedData.length);\n        else\n            assertEquals(91080, expectedCompressedData.length);\n        // The chunk size should not affect the size of the compressed output:\n        int[] chunkSizes = new int[] {1, 100, 1023, 1024, 10000};\n        for (int chunkSize : chunkSizes) {\n            byte[] compressedData = compressAsChunks(orig, chunkSize);\n            assertEquals(String.format(\"when chunk size = %,d\", chunkSize), expectedCompressedData.length, compressedData.length);\n            assertArrayEquals(expectedCompressedData, compressedData);\n        }\n    }\n\n    @Test\n    public void closeShouldBeIdempotent()\n            throws Exception\n    {\n        // Regression test for issue #107, a bug where close() was non-idempotent and would release\n        // its buffers to the allocator multiple times, which could cause scenarios where two open\n        // SnappyOutputStreams could share the same buffers, leading to stream corruption issues.\n        final BufferAllocatorFactory bufferAllocatorFactory = CachedBufferAllocator.getBufferAllocatorFactory();\n        final int BLOCK_SIZE = 4096;\n        // Create a stream, use it, then close it once:\n        ByteArrayOutputStream ba1 = new ByteArrayOutputStream();\n        SnappyOutputStream os1 = new SnappyOutputStream(ba1, BLOCK_SIZE, bufferAllocatorFactory);\n        os1.write(42);\n        os1.close();\n        // Create a new output stream, which should end up re-using the first stream's freed buffers\n        ByteArrayOutputStream ba2 = new ByteArrayOutputStream();\n        SnappyOutputStream os2 = new SnappyOutputStream(ba2, BLOCK_SIZE, bufferAllocatorFactory);\n        // Close the first stream a second time, which is supposed to be safe due to idempotency:\n        os1.close();\n        // Allocate a third output stream, which is supposed to get its own fresh set of buffers:\n        ByteArrayOutputStream ba3 = new ByteArrayOutputStream();\n        SnappyOutputStream os3 = new SnappyOutputStream(ba3, BLOCK_SIZE, bufferAllocatorFactory);\n        // Since the second and third streams should have distinct sets of buffers, writes to these\n        // streams should not interfere with one another:\n        os2.write(2);\n        os3.write(3);\n        os2.close();\n        os3.close();\n        SnappyInputStream in2 = new SnappyInputStream(new ByteArrayInputStream(ba2.toByteArray()));\n        assertEquals(2, in2.read());\n        in2.close();\n        SnappyInputStream in3 = new SnappyInputStream(new ByteArrayInputStream(ba3.toByteArray()));\n        assertEquals(3, in3.read());\n        in3.close();\n    }\n\n    @Test\n    public void writingToClosedStreamShouldThrowIOException()\n            throws IOException\n    {\n        ByteArrayOutputStream b = new ByteArrayOutputStream();\n        SnappyOutputStream os = new SnappyOutputStream(b);\n        os.close();\n        try {\n            os.write(4);\n            fail(\"Expected write() to throw IOException\");\n        }\n        catch (IOException e) {\n            // Expected exception\n        }\n        try {\n            os.write(new int[] {1, 2, 3, 4});\n            fail(\"Expected write() to throw IOException\");\n        }\n        catch (IOException e) {\n            // Expected exception\n        }\n    }\n\n    @Test\n    public void flushingClosedStreamShouldThrowIOException()\n            throws IOException\n    {\n        ByteArrayOutputStream b = new ByteArrayOutputStream();\n        SnappyOutputStream os = new SnappyOutputStream(b);\n        os.close();\n        try {\n            os.flush();\n        }\n        catch (IOException e) {\n            // Expected exception\n        }\n    }\n\n    @Test\n    public void closingStreamShouldMakeBuffersEligibleForGarbageCollection()\n            throws IOException\n    {\n        ByteArrayOutputStream b = new ByteArrayOutputStream();\n        SnappyOutputStream os = new SnappyOutputStream(b, 4095, DefaultBufferAllocator.factory);\n        WeakReference<byte[]> inputBuffer = new WeakReference<byte[]>(os.inputBuffer);\n        WeakReference<byte[]> outputBuffer = new WeakReference<byte[]>(os.inputBuffer);\n        os.close();\n        System.gc();\n        assertNull(inputBuffer.get());\n        assertNull(outputBuffer.get());\n    }\n\n    @Test\n    public void longArrayCompress()\n            throws Exception\n    {\n        long[] l = new long[10];\n        for (int i = 0; i < l.length; ++i) {\n            l[i] = i % 3 + i * 11;\n        }\n\n        ByteArrayOutputStream b = new ByteArrayOutputStream();\n        SnappyOutputStream os = new SnappyOutputStream(b);\n\n        os.write(l);\n        os.close();\n        SnappyInputStream is = new SnappyInputStream(new ByteArrayInputStream(b.toByteArray()));\n        long[] l2 = new long[10];\n        int readBytes = is.read(l2);\n        is.close();\n\n        assertEquals(10 * 8, readBytes);\n        assertArrayEquals(l, l2);\n    }\n\n    @Test\n    public void writeDoubleArray()\n            throws Exception\n    {\n        ByteArrayOutputStream b = new ByteArrayOutputStream();\n        SnappyOutputStream os = new SnappyOutputStream(b);\n\n        double[] orig = new double[] {1.0, 2.0, 1.4, 0.00343430014, -4.4, 4e-20};\n        os.write(orig);\n        os.close();\n\n        SnappyInputStream is = new SnappyInputStream(new ByteArrayInputStream(b.toByteArray()));\n        double[] uncompressed = new double[orig.length];\n        is.read(uncompressed);\n        is.close();\n\n        assertArrayEquals(orig, uncompressed, 0.0);\n    }\n\n    @Test\n    public void writeFloatArray()\n            throws Exception\n    {\n        ByteArrayOutputStream b = new ByteArrayOutputStream();\n        SnappyOutputStream os = new SnappyOutputStream(b);\n\n        float[] orig = new float[] {1.0f, 2.0f, 1.4f, 0.00343430014f, -4.4f, 4e-20f};\n        os.write(orig);\n        os.close();\n\n        SnappyInputStream is = new SnappyInputStream(new ByteArrayInputStream(b.toByteArray()));\n        float[] uncompressed = new float[orig.length];\n        is.read(uncompressed);\n        is.close();\n\n        assertArrayEquals(orig, uncompressed, 0.0f);\n    }\n\n    @Test\n    public void writeIntArray()\n            throws Exception\n    {\n        ByteArrayOutputStream b = new ByteArrayOutputStream();\n        SnappyOutputStream os = new SnappyOutputStream(b);\n\n        int[] orig = new int[] {0, -1, -34, 43, 234, 34324, -234};\n        os.write(orig);\n        os.close();\n\n        SnappyInputStream is = new SnappyInputStream(new ByteArrayInputStream(b.toByteArray()));\n        int[] uncompressed = new int[orig.length];\n        is.read(uncompressed);\n        is.close();\n\n        assertArrayEquals(orig, uncompressed);\n    }\n\n    @Test\n    public void writeShortArray()\n            throws Exception\n    {\n        ByteArrayOutputStream b = new ByteArrayOutputStream();\n        SnappyOutputStream os = new SnappyOutputStream(b);\n\n        short[] orig = new short[] {0, -1, -34, 43, 234, 324, -234};\n        os.write(orig);\n        os.close();\n\n        SnappyInputStream is = new SnappyInputStream(new ByteArrayInputStream(b.toByteArray()));\n        short[] uncompressed = new short[orig.length];\n        is.read(uncompressed);\n        is.close();\n\n        assertArrayEquals(orig, uncompressed);\n    }\n}\n", "/*--------------------------------------------------------------------------\n *  Copyright 2011 Taro L. Saito\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *--------------------------------------------------------------------------*/\n//--------------------------------------\n// snappy-java Project\n//\n// SnappyTest.java\n// Since: 2011/03/30\n//\n// $URL$\n// $Author$\n//--------------------------------------\npackage org.xerial.snappy;\n\nimport static org.junit.Assert.*;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\n\nimport org.junit.Assume;\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.xerial.util.log.Logger;\n\npublic class SnappyTest\n{\n    private static Logger _logger = Logger.getLogger(SnappyTest.class);\n\n    @Test\n    public void getVersion()\n            throws Exception\n    {\n        String version = Snappy.getNativeLibraryVersion();\n        _logger.debug(\"version: \" + version);\n    }\n\n    @Test\n    public void directBufferCheck()\n            throws Exception\n    {\n\n        try {\n            ByteBuffer src = ByteBuffer.allocate(1024);\n            src.put(\"hello world\".getBytes());\n            src.flip();\n            ByteBuffer dest = ByteBuffer.allocate(1024);\n            int maxCompressedLen = Snappy.compress(src, dest);\n        }\n        catch (SnappyError e) {\n            Assert.assertTrue(e.errorCode == SnappyErrorCode.NOT_A_DIRECT_BUFFER);\n            return;\n        }\n\n        fail(\"shouldn't reach here\");\n    }\n\n    @Test\n    public void directBuffer()\n            throws Exception\n    {\n\n        StringBuilder s = new StringBuilder();\n        for (int i = 0; i < 20; ++i) {\n            s.append(\"Hello world!\");\n        }\n        String origStr = s.toString();\n        byte[] orig = origStr.getBytes();\n        int BUFFER_SIZE = orig.length;\n        ByteBuffer src = ByteBuffer.allocateDirect(orig.length);\n        src.put(orig);\n        src.flip();\n        _logger.debug(\"input size: \" + src.remaining());\n        int maxCompressedLen = Snappy.maxCompressedLength(src.remaining());\n        _logger.debug(\"max compressed length:\" + maxCompressedLen);\n\n        ByteBuffer compressed = ByteBuffer.allocateDirect(maxCompressedLen);\n        int compressedSize = Snappy.compress(src, compressed);\n        _logger.debug(\"compressed length: \" + compressedSize);\n\n        assertTrue(Snappy.isValidCompressedBuffer(compressed));\n\n        assertEquals(0, src.position());\n        assertEquals(orig.length, src.remaining());\n        assertEquals(orig.length, src.limit());\n\n        assertEquals(0, compressed.position());\n        assertEquals(compressedSize, compressed.limit());\n        assertEquals(compressedSize, compressed.remaining());\n\n        int uncompressedLen = Snappy.uncompressedLength(compressed);\n        _logger.debug(\"uncompressed length: \" + uncompressedLen);\n        ByteBuffer extract = ByteBuffer.allocateDirect(uncompressedLen);\n        int uncompressedLen2 = Snappy.uncompress(compressed, extract);\n        assertEquals(uncompressedLen, uncompressedLen2);\n        assertEquals(uncompressedLen, extract.remaining());\n\n        byte[] b = new byte[uncompressedLen];\n        extract.get(b);\n        String decompressed = new String(b);\n        _logger.debug(decompressed);\n\n        assertEquals(origStr, decompressed);\n    }\n\n    @Test\n    public void bufferOffset()\n            throws Exception\n    {\n\n        String m = \"ACCAGGGGGGGGGGGGGGGGGGGGATAGATATTTCCCGAGATATTTTATATAAAAAAA\";\n        byte[] orig = m.getBytes();\n        final int offset = 100;\n        ByteBuffer input = ByteBuffer.allocateDirect(orig.length + offset);\n        input.position(offset);\n        input.put(orig);\n        input.flip();\n        input.position(offset);\n\n        // compress\n        int maxCompressedLength = Snappy.maxCompressedLength(input.remaining());\n        final int offset2 = 40;\n        ByteBuffer compressed = ByteBuffer.allocateDirect(maxCompressedLength + offset2);\n        compressed.position(offset2);\n        Snappy.compress(input, compressed);\n        assertTrue(Snappy.isValidCompressedBuffer(compressed));\n\n        // uncompress\n        final int offset3 = 80;\n        int uncompressedLength = Snappy.uncompressedLength(compressed);\n        ByteBuffer uncompressed = ByteBuffer.allocateDirect(uncompressedLength + offset3);\n        uncompressed.position(offset3);\n        Snappy.uncompress(compressed, uncompressed);\n        assertEquals(offset3, uncompressed.position());\n        assertEquals(offset3 + uncompressedLength, uncompressed.limit());\n        assertEquals(uncompressedLength, uncompressed.remaining());\n\n        // extract string\n        byte[] recovered = new byte[uncompressedLength];\n        uncompressed.get(recovered);\n        String m2 = new String(recovered);\n\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void byteArrayCompress()\n            throws Exception\n    {\n\n        String m = \"ACCAGGGGGGGGGGGGGGGGGGGGATAGATATTTCCCGAGATATTTTATATAAAAAAA\";\n        byte[] input = m.getBytes();\n        byte[] output = new byte[Snappy.maxCompressedLength(input.length)];\n        int compressedSize = Snappy.compress(input, 0, input.length, output, 0);\n        byte[] uncompressed = new byte[input.length];\n\n        assertTrue(Snappy.isValidCompressedBuffer(output, 0, compressedSize));\n        int uncompressedSize = Snappy.uncompress(output, 0, compressedSize, uncompressed, 0);\n        String m2 = new String(uncompressed);\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void rangeCheck()\n            throws Exception\n    {\n        String m = \"ACCAGGGGGGGGGGGGGGGGGGGGATAGATATTTCCCGAGATATTTTATATAAAAAAA\";\n        byte[] input = m.getBytes();\n        byte[] output = new byte[Snappy.maxCompressedLength(input.length)];\n        int compressedSize = Snappy.compress(input, 0, input.length, output, 0);\n\n        assertTrue(Snappy.isValidCompressedBuffer(output, 0, compressedSize));\n        // Intentionally set an invalid range\n        assertFalse(Snappy.isValidCompressedBuffer(output, 0, compressedSize + 1));\n        assertFalse(Snappy.isValidCompressedBuffer(output, 1, compressedSize));\n\n        // Test the ByteBuffer API\n        ByteBuffer bin = ByteBuffer.allocateDirect(input.length);\n        bin.put(input);\n        bin.flip();\n        ByteBuffer bout = ByteBuffer.allocateDirect(Snappy.maxCompressedLength(bin.remaining()));\n        int compressedSize2 = Snappy.compress(bin, bout);\n        assertEquals(compressedSize, compressedSize2);\n\n        assertTrue(Snappy.isValidCompressedBuffer(bout));\n        // Intentionally set an invalid range\n        bout.limit(bout.limit() + 1);\n        assertFalse(Snappy.isValidCompressedBuffer(bout));\n        bout.limit(bout.limit() - 1);\n        bout.position(1);\n        assertFalse(Snappy.isValidCompressedBuffer(bout));\n    }\n\n    @Test\n    public void highLevelAPI()\n            throws Exception\n    {\n\n        String m = \"Hello! 01234 ACGDSFSDFJ World. FDSDF02394234 fdsfda03924\";\n        byte[] input = m.getBytes();\n        byte[] output = Snappy.compress(input);\n\n        byte[] uncompressed = Snappy.uncompress(output);\n        String m2 = new String(uncompressed);\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void lowLevelAPI()\n            throws Exception\n    {\n\n        String m = \"Hello! 01234 ACGDSFSDFJ World. FDSDF02394234 fdsfda03924\";\n        byte[] input = m.getBytes();\n        byte[] output = Snappy.rawCompress(input, input.length);\n\n        byte[] uncompressed = Snappy.uncompress(output);\n        String m2 = new String(uncompressed);\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void simpleUsage()\n            throws Exception\n    {\n\n        String input = \"Hello snappy-java! Snappy-java is a JNI-based wrapper\"\n                + \" for using Snappy from Google (written in C++), a fast compresser/decompresser.\";\n        byte[] compressed = Snappy.compress(input.getBytes(\"UTF-8\"));\n        byte[] uncompressed = Snappy.uncompress(compressed);\n        String result = new String(uncompressed, \"UTF-8\");\n        _logger.debug(result);\n    }\n\n    @Test\n    public void floatArray()\n            throws Exception\n    {\n        float[] data = new float[] {1.0f, -0.3f, 1.3f, 234.4f, 34};\n        byte[] compressed = Snappy.compress(data);\n        float[] result = Snappy.uncompressFloatArray(compressed);\n        assertArrayEquals(data, result, 0.0f);\n    }\n\n    @Test\n    public void doubleArray()\n            throws Exception\n    {\n        double[] data = new double[] {1.0, -0.3, 1.3, 234.4, 34};\n        byte[] compressed = Snappy.compress(data);\n        double[] result = Snappy.uncompressDoubleArray(compressed);\n        assertArrayEquals(data, result, 0.0f);\n    }\n\n    @Test\n    public void longArray()\n            throws Exception\n    {\n        long[] data = new long[] {2, 3, 15, 4234, 43251531412342342L, 23423422342L};\n        byte[] compressed = Snappy.compress(data);\n        long[] result = Snappy.uncompressLongArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void shortArray()\n            throws Exception\n    {\n        short[] data = new short[] {432, -32267, 1, 3, 34, 43, 34, Short.MAX_VALUE, -1};\n        byte[] compressed = Snappy.compress(data);\n        short[] result = Snappy.uncompressShortArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void intArray()\n            throws Exception\n    {\n        int[] data = new int[] {432, -32267, 1, 3, 34, 43, 34, Short.MAX_VALUE, -1, Integer.MAX_VALUE, 3424, 43};\n        byte[] compressed = Snappy.compress(data);\n        int[] result = Snappy.uncompressIntArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void charArray()\n            throws Exception\n    {\n        char[] data = new char[] {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '!'};\n        byte[] compressed = Snappy.compress(data);\n        char[] result = Snappy.uncompressCharArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void string()\n            throws Exception\n    {\n        String s = \"Hello Snappy! Snappy! Snappy!\";\n        byte[] compressed = Snappy.compress(s);\n        String uncompressedString = Snappy.uncompressString(compressed);\n        assertEquals(s, uncompressedString);\n    }\n\n    @Test\n    public void isValidCompressedData()\n            throws Exception\n    {\n\n        byte[] b = new byte[] {(byte) 91, (byte) 34, (byte) 80, (byte) 73, (byte) 34, (byte) 93};\n\n        assertFalse(Snappy.isValidCompressedBuffer(b));\n\n        try {\n            byte[] uncompressed = Snappy.uncompress(b);\n            fail(\"cannot reach here since the input is invalid data\");\n        }\n        catch (IOException e) {\n            _logger.debug(e);\n        }\n    }\n\n\n    /*\n    Tests happy cases for SnappyInputStream.read method\n    - {0}\n     */\n    @Test\n    public void isValidChunkLengthForSnappyInputStreamIn()\n            throws Exception {\n        byte[] data = {0};\n        SnappyInputStream in = new SnappyInputStream(new ByteArrayInputStream(data));\n        byte[] out = new byte[50];\n        in.read(out);\n    }\n\n    /*\n    Tests sad cases for SnappyInputStream.read method\n    - Expects a java.lang.NegativeArraySizeException catched into a SnappyError\n    - {-126, 'S', 'N', 'A', 'P', 'P', 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0,(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff}\n     */\n    @Test(expected = SnappyError.class)\n    public void isInvalidChunkLengthForSnappyInputStreamInNegative()\n            throws Exception {\n        byte[] data = {-126, 'S', 'N', 'A', 'P', 'P', 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0,(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff};\n        SnappyInputStream in = new SnappyInputStream(new ByteArrayInputStream(data));\n        byte[] out = new byte[50];\n        in.read(out);\n    }\n\n    /*\n    Tests sad cases for SnappyInputStream.read method\n    - Expects a java.lang.OutOfMemoryError\n    - {-126, 'S', 'N', 'A', 'P', 'P', 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0,(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff}\n     */\n    @Test(expected = SnappyError.class)\n    public void isInvalidChunkLengthForSnappyInputStreamOutOfMemory()\n            throws Exception {\n        byte[] data = {-126, 'S', 'N', 'A', 'P', 'P', 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0, (byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff};\n        SnappyInputStream in = new SnappyInputStream(new ByteArrayInputStream(data));\n        byte[] out = new byte[50];\n        try {\n            in.read(out);\n        } catch (Exception ignored) {\n            // Exception here will be catched\n            // But OutOfMemoryError will not be caught, and will still be thrown\n        }\n    }\n\n    /*\n    Tests happy cases for BitShuffle.shuffle method\n    - double: 0, 10\n    - float: 0, 10\n    - int: 0, 10\n    - long: 0, 10\n    - short: 0, 10\n     */\n    @Test\n    public void isValidArrayInputLength()\n            throws Exception {\n        byte[] a = Snappy.compress(new char[0]);\n        byte[] b = Snappy.compress(new double[0]);\n        byte[] c = Snappy.compress(new float[0]);\n        byte[] d = Snappy.compress(new int[0]);\n        byte[] e = Snappy.compress(new long[0]);\n        byte[] f = Snappy.compress(new short[0]);\n        byte[] g = Snappy.compress(new char[10]);\n        byte[] h = Snappy.compress(new double[10]);\n        byte[] i = Snappy.compress(new float[10]);\n        byte[] j = Snappy.compress(new int[10]);\n        byte[] k = Snappy.compress(new long[10]);\n        byte[] l = Snappy.compress(new short[10]);\n    }\n\n    /*\n    Tests sad cases for Snappy.compress\n    - Allocate a buffer whose byte size will be a bit larger than Integer.MAX_VALUE\n    - char\n    - double\n    - float\n    - int\n    - long\n    - short\n     */\n    @Test(expected = SnappyError.class)\n    public void isTooLargeDoubleArrayInputLength() throws Exception {\n        assumingCIIsFalse();\n        Snappy.compress(new double[Integer.MAX_VALUE / 8 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeCharArrayInputLength() throws Exception {\n        assumingCIIsFalse();\n        Snappy.compress(new char[Integer.MAX_VALUE / 2 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeFloatArrayInputLength() throws Exception {\n        assumingCIIsFalse();\n        Snappy.compress(new float[Integer.MAX_VALUE / 4 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeIntArrayInputLength() throws Exception {\n        assumingCIIsFalse();\n        Snappy.compress(new int[Integer.MAX_VALUE / 4 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeLongArrayInputLength() throws Exception {\n        assumingCIIsFalse();\n        Snappy.compress(new long[Integer.MAX_VALUE / 8 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeShortArrayInputLength() throws Exception {\n        assumingCIIsFalse();\n        Snappy.compress(new short[Integer.MAX_VALUE / 2 + 1]);\n    }\n\n    /*\n    Tests happy cases for Snappy.compress\n    - char: 0, 10\n    */\n    @Test\n    public void isValidArrayInputLengthForBitShuffleShuffle()\n            throws Exception\n    {\n        byte[] b = BitShuffle.shuffle(new double[0]);\n        byte[] c = BitShuffle.shuffle(new float[0]);\n        byte[] d = BitShuffle.shuffle(new int[0]);\n        byte[] e = BitShuffle.shuffle(new long[0]);\n        byte[] f = BitShuffle.shuffle(new short[0]);\n        byte[] n = BitShuffle.shuffle(new double[10]);\n        byte[] o = BitShuffle.shuffle(new float[10]);\n        byte[] p = BitShuffle.shuffle(new int[10]);\n        byte[] q = BitShuffle.shuffle(new long[10]);\n        byte[] r = BitShuffle.shuffle(new short[10]);\n    }\n\n    /*\n    Tests sad cases for BitShuffle.shuffle method\n    - Allocate a buffer whose byte size will be a bit larger than Integer.MAX_VALUE\n    - double: 8\n    - float: 4\n    - int: 4\n    - long: 8\n    - short: 2\n     */\n    @Test(expected = SnappyError.class)\n    public void isTooLargeDoubleArrayInputLengthForBitShuffleShuffle() throws Exception {\n        assumingCIIsFalse();\n        BitShuffle.shuffle(new double[Integer.MAX_VALUE / 8 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeFloatArrayInputLengthForBitShuffleShuffle() throws Exception {\n        assumingCIIsFalse();\n        BitShuffle.shuffle(new float[Integer.MAX_VALUE / 4 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeIntArrayInputLengthForBitShuffleShuffle() throws Exception {\n        assumingCIIsFalse();\n        BitShuffle.shuffle(new float[Integer.MAX_VALUE / 4 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeLongArrayInputLengthForBitShuffleShuffle() throws Exception {\n        assumingCIIsFalse();\n        BitShuffle.shuffle(new long[Integer.MAX_VALUE / 8 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeShortArrayInputLengthForBitShuffleShuffle() throws Exception {\n        assumingCIIsFalse();\n        BitShuffle.shuffle(new short[Integer.MAX_VALUE / 2 + 1]);\n    }\n\n    private void assumingCIIsFalse() {\n        if (System.getenv(\"CI\") == null)\n            return;\n        Assume.assumeFalse(\"Skipped on CI\", System.getenv(\"CI\").equals(\"true\"));\n    }\n}\n"], "fixing_code": ["package org.xerial.snappy;\n\nimport org.xerial.snappy.buffer.CachedBufferAllocator;\n\nimport java.io.OutputStream;\n\npublic class SnappyHadoopCompatibleOutputStream extends SnappyOutputStream\n{\n    public SnappyHadoopCompatibleOutputStream(OutputStream out)\n    {\n        this(out, DEFAULT_BLOCK_SIZE);\n    }\n\n    public SnappyHadoopCompatibleOutputStream(OutputStream out, int blockSize)\n    {\n        super(out, blockSize, CachedBufferAllocator.getBufferAllocatorFactory());\n    }\n\n    @Override\n    protected int writeHeader()\n    {\n        return 0;\n    }\n\n    @Override\n    protected void writeBlockPreemble()\n    {\n        writeCurrentDataSize();\n    }\n}\n", "/*--------------------------------------------------------------------------\n *  Copyright 2011 Taro L. Saito\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *--------------------------------------------------------------------------*/\n//--------------------------------------\n// XerialJ\n//\n// SnappyInputStream.java\n// Since: 2011/03/31 20:14:56\n//\n// $URL$\n// $Author$\n//--------------------------------------\npackage org.xerial.snappy;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * A stream filter for reading data compressed by {@link SnappyOutputStream}.\n *\n * @author leo\n */\npublic class SnappyInputStream\n        extends InputStream\n{\n    public static final int MAX_CHUNK_SIZE = 512 * 1024 * 1024; // 512 MiB\n\n    private boolean finishedReading = false;\n    protected final InputStream in;\n    private final int maxChunkSize;\n\n    private byte[] compressed;\n    private byte[] uncompressed;\n    private int uncompressedCursor = 0;\n    private int uncompressedLimit = 0;\n\n    private byte[] header = new byte[SnappyCodec.headerSize()];\n\n    /**\n     * Create a filter for reading compressed data as a uncompressed stream\n     *\n     * @param input\n     * @throws IOException\n     */\n    public SnappyInputStream(InputStream input)\n            throws IOException\n    {\n        this(input, MAX_CHUNK_SIZE);\n    }\n\n\n    /**\n     * Create a filter for reading compressed data as a uncompressed stream with provided maximum chunk size\n     *\n     * @param input\n     * @param maxChunkSize\n     * @throws IOException\n     */\n    public SnappyInputStream(InputStream input, int maxChunkSize)\n            throws IOException\n    {\n        this.maxChunkSize = maxChunkSize;\n        this.in = input;\n        readHeader();\n    }\n\n    /**\n     * Close the stream\n     */\n    /* (non-Javadoc)\n     * @see java.io.InputStream#close()\n     */\n    @Override\n    public void close()\n            throws IOException\n    {\n        compressed = null;\n        uncompressed = null;\n        if (in != null) {\n            in.close();\n        }\n    }\n\n    protected void readHeader()\n            throws IOException\n    {\n        int readBytes = 0;\n        while (readBytes < header.length) {\n            int ret = in.read(header, readBytes, header.length - readBytes);\n            if (ret == -1) {\n                break;\n            }\n            readBytes += ret;\n        }\n\n        // Quick test of the header\n        if (readBytes == 0) {\n            // Snappy produces at least 1-byte result. So the empty input is not a valid input\n            throw new SnappyIOException(SnappyErrorCode.EMPTY_INPUT, \"Cannot decompress empty stream\");\n        }\n        if (readBytes < header.length || !SnappyCodec.hasMagicHeaderPrefix(header)) {\n            // do the default uncompression\n            // (probably) compressed by Snappy.compress(byte[])\n            readFully(header, readBytes);\n            return;\n        }\n    }\n\n    private static boolean isValidHeader(byte[] header)\n            throws IOException\n    {\n        SnappyCodec codec = SnappyCodec.readHeader(new ByteArrayInputStream(header));\n        if (codec.isValidMagicHeader()) {\n            // The input data is compressed by SnappyOutputStream\n            if (codec.version < SnappyCodec.MINIMUM_COMPATIBLE_VERSION) {\n                throw new SnappyIOException(SnappyErrorCode.INCOMPATIBLE_VERSION, String.format(\n                        \"Compressed with an incompatible codec version %d. At least version %d is required\",\n                        codec.version, SnappyCodec.MINIMUM_COMPATIBLE_VERSION));\n            }\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n\n    protected void readFully(byte[] fragment, int fragmentLength)\n            throws IOException\n    {\n        if (fragmentLength == 0) {\n            finishedReading = true;\n            return;\n        }\n        // read the entire input data to the buffer\n        compressed = new byte[Math.max(8 * 1024, fragmentLength)]; // 8K\n        System.arraycopy(fragment, 0, compressed, 0, fragmentLength);\n        int cursor = fragmentLength;\n        for (int readBytes = 0; (readBytes = in.read(compressed, cursor, compressed.length - cursor)) != -1; ) {\n            cursor += readBytes;\n            if (cursor >= compressed.length) {\n                byte[] newBuf = new byte[(compressed.length * 2)];\n                System.arraycopy(compressed, 0, newBuf, 0, compressed.length);\n                compressed = newBuf;\n            }\n        }\n\n        finishedReading = true;\n\n        // Uncompress\n        int uncompressedLength = Snappy.uncompressedLength(compressed, 0, cursor);\n        uncompressed = new byte[uncompressedLength];\n        Snappy.uncompress(compressed, 0, cursor, uncompressed, 0);\n        this.uncompressedCursor = 0;\n        this.uncompressedLimit = uncompressedLength;\n    }\n\n    /**\n     * Reads up to len bytes of data from the input stream into an array of\n     * bytes.\n     */\n    /* (non-Javadoc)\n     * @see java.io.InputStream#read(byte[], int, int)\n     */\n    @Override\n    public int read(byte[] b, int byteOffset, int byteLength)\n            throws IOException\n    {\n        int writtenBytes = 0;\n        for (; writtenBytes < byteLength; ) {\n\n            if (uncompressedCursor >= uncompressedLimit) {\n                if (hasNextChunk()) {\n                    continue;\n                }\n                else {\n                    return writtenBytes == 0 ? -1 : writtenBytes;\n                }\n            }\n            int bytesToWrite = Math.min(uncompressedLimit - uncompressedCursor, byteLength - writtenBytes);\n            System.arraycopy(uncompressed, uncompressedCursor, b, byteOffset + writtenBytes, bytesToWrite);\n            writtenBytes += bytesToWrite;\n            uncompressedCursor += bytesToWrite;\n        }\n\n        return writtenBytes;\n    }\n\n    /**\n     * Read uncompressed data into the specified array\n     *\n     * @param array\n     * @param byteOffset\n     * @param byteLength\n     * @return written bytes\n     * @throws IOException\n     */\n    public int rawRead(Object array, int byteOffset, int byteLength)\n            throws IOException\n    {\n        int writtenBytes = 0;\n        for (; writtenBytes < byteLength; ) {\n\n            if (uncompressedCursor >= uncompressedLimit) {\n                if (hasNextChunk()) {\n                    continue;\n                }\n                else {\n                    return writtenBytes == 0 ? -1 : writtenBytes;\n                }\n            }\n            int bytesToWrite = Math.min(uncompressedLimit - uncompressedCursor, byteLength - writtenBytes);\n            Snappy.arrayCopy(uncompressed, uncompressedCursor, bytesToWrite, array, byteOffset + writtenBytes);\n            writtenBytes += bytesToWrite;\n            uncompressedCursor += bytesToWrite;\n        }\n\n        return writtenBytes;\n    }\n\n    /**\n     * Read long array from the stream\n     *\n     * @param d input\n     * @param off offset\n     * @param len the number of long elements to read\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(long[] d, int off, int len)\n            throws IOException\n    {\n        return rawRead(d, off * 8, len * 8);\n    }\n\n    /**\n     * Read long array from the stream\n     *\n     * @param d\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(long[] d)\n            throws IOException\n    {\n        return read(d, 0, d.length);\n    }\n\n    /**\n     * Read double array from the stream\n     *\n     * @param d input\n     * @param off offset\n     * @param len the number of double elements to read\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(double[] d, int off, int len)\n            throws IOException\n    {\n        return rawRead(d, off * 8, len * 8);\n    }\n\n    /**\n     * Read double array from the stream\n     *\n     * @param d\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(double[] d)\n            throws IOException\n    {\n        return read(d, 0, d.length);\n    }\n\n    /**\n     * Read int array from the stream\n     *\n     * @param d\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(int[] d)\n            throws IOException\n    {\n        return read(d, 0, d.length);\n    }\n\n    /**\n     * Read int array from the stream\n     *\n     * @param d input\n     * @param off offset\n     * @param len the number of int elements to read\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(int[] d, int off, int len)\n            throws IOException\n    {\n        return rawRead(d, off * 4, len * 4);\n    }\n\n    /**\n     * Read float array from the stream\n     *\n     * @param d input\n     * @param off offset\n     * @param len the number of float elements to read\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(float[] d, int off, int len)\n            throws IOException\n    {\n        return rawRead(d, off * 4, len * 4);\n    }\n\n    /**\n     * Read float array from the stream\n     *\n     * @param d\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(float[] d)\n            throws IOException\n    {\n        return read(d, 0, d.length);\n    }\n\n    /**\n     * Read short array from the stream\n     *\n     * @param d input\n     * @param off offset\n     * @param len the number of short elements to read\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(short[] d, int off, int len)\n            throws IOException\n    {\n        return rawRead(d, off * 2, len * 2);\n    }\n\n    /**\n     * Read short array from the stream\n     *\n     * @param d\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(short[] d)\n            throws IOException\n    {\n        return read(d, 0, d.length);\n    }\n\n    /**\n     * Read next len bytes\n     *\n     * @param dest\n     * @param offset\n     * @param len\n     * @return read bytes\n     */\n    private int readNext(byte[] dest, int offset, int len)\n            throws IOException\n    {\n        int readBytes = 0;\n        while (readBytes < len) {\n            int ret = in.read(dest, readBytes + offset, len - readBytes);\n            if (ret == -1) {\n                finishedReading = true;\n                return readBytes;\n            }\n            readBytes += ret;\n        }\n        return readBytes;\n    }\n\n    protected boolean hasNextChunk()\n            throws IOException\n    {\n        if (finishedReading) {\n            return false;\n        }\n\n        uncompressedCursor = 0;\n        uncompressedLimit = 0;\n\n        int readBytes = readNext(header, 0, 4);\n        if (readBytes < 4) {\n            return false;\n        }\n\n        int chunkSize = SnappyOutputStream.readInt(header, 0);\n        if (chunkSize == SnappyCodec.MAGIC_HEADER_HEAD) {\n            // Concatenated data\n            int remainingHeaderSize = SnappyCodec.headerSize() - 4;\n            readBytes = readNext(header, 4, remainingHeaderSize);\n            if(readBytes < remainingHeaderSize) {\n                throw new SnappyIOException(SnappyErrorCode.FAILED_TO_UNCOMPRESS, String.format(\"Insufficient header size in a concatenated block\"));\n            }\n\n            if (isValidHeader(header)) {\n                return hasNextChunk();\n            }\n            else {\n                return false;\n            }\n        }\n\n        // chunkSize is negative\n        if (chunkSize < 0) {\n            throw new SnappyError(SnappyErrorCode.INVALID_CHUNK_SIZE, \"chunkSize is too big or negative : \" + chunkSize);\n        }\n\n        // chunkSize is big\n        if (chunkSize > maxChunkSize) {\n            throw new SnappyError(SnappyErrorCode.FAILED_TO_UNCOMPRESS, String.format(\"Received chunkSize %,d is greater than max configured chunk size %,d\", chunkSize, maxChunkSize));\n        }\n\n        // extend the compressed data buffer size\n        if (compressed == null || chunkSize > compressed.length) {\n            // chunkSize exceeds limit\n            try {\n                compressed = new byte[chunkSize];\n            }\n            catch (java.lang.OutOfMemoryError e) {\n                throw new SnappyError(SnappyErrorCode.INVALID_CHUNK_SIZE, e.getMessage());\n            }\n        }\n        readBytes = 0;\n        while (readBytes < chunkSize) {\n            int ret = in.read(compressed, readBytes, chunkSize - readBytes);\n            if (ret == -1) {\n                break;\n            }\n            readBytes += ret;\n        }\n        if (readBytes < chunkSize) {\n            throw new IOException(\"failed to read chunk\");\n        }\n        int uncompressedLength = Snappy.uncompressedLength(compressed, 0, chunkSize);\n        if (uncompressed == null || uncompressedLength > uncompressed.length) {\n            uncompressed = new byte[uncompressedLength];\n        }\n        int actualUncompressedLength = Snappy.uncompress(compressed, 0, chunkSize, uncompressed, 0);\n        if (uncompressedLength != actualUncompressedLength) {\n            throw new SnappyIOException(SnappyErrorCode.INVALID_CHUNK_SIZE, String.format(\"expected %,d bytes, but decompressed chunk has %,d bytes\", uncompressedLength, actualUncompressedLength));\n        }\n        uncompressedLimit = actualUncompressedLength;\n\n        return true;\n    }\n\n    /**\n     * Reads the next byte of uncompressed data from the input stream. The value\n     * byte is returned as an int in the range 0 to 255. If no byte is available\n     * because the end of the stream has been reached, the value -1 is returned.\n     * This method blocks until input data is available, the end of the stream\n     * is detected, or an exception is thrown.\n     */\n    /* (non-Javadoc)\n     * @see java.io.InputStream#read()\n     */\n    @Override\n    public int read()\n            throws IOException\n    {\n        if (uncompressedCursor < uncompressedLimit) {\n            return uncompressed[uncompressedCursor++] & 0xFF;\n        }\n        else {\n            if (hasNextChunk()) {\n                return read();\n            }\n            else {\n                return -1;\n            }\n        }\n    }\n\n    /* (non-Javadoc)\n     * @see java.io.InputStream#available()\n     */\n    @Override\n    public int available()\n            throws IOException\n    {\n        if (uncompressedCursor < uncompressedLimit) {\n            return uncompressedLimit - uncompressedCursor;\n        }\n        else {\n            if (hasNextChunk()) {\n                return uncompressedLimit - uncompressedCursor;\n            }\n            else {\n                return 0;\n            }\n        }\n    }\n}\n", "/*--------------------------------------------------------------------------\n *  Copyright 2011 Taro L. Saito\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *--------------------------------------------------------------------------*/\n//--------------------------------------\n// XerialJ\n//\n// SnappyOutputStream.java\n// Since: 2011/03/31 17:44:10\n//\n// $URL$\n// $Author$\n//--------------------------------------\npackage org.xerial.snappy;\n\nimport org.xerial.snappy.buffer.BufferAllocatorFactory;\nimport org.xerial.snappy.buffer.BufferAllocator;\nimport org.xerial.snappy.buffer.CachedBufferAllocator;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\n/**\n * This class implements a stream filter for writing compressed data using\n * Snappy.\n * <p>\n * The input data is blocked into 32kb size (in default), and each block is\n * compressed and then passed to the given {@link OutputStream}.\n * </p>\n * The output data format is:\n * <ol>\n * <li>snappy codec header defined in {@link SnappyCodec} (8 bytes)\n * <li>codec version (4 bytes integer, at least 1) and compatible version (4 bytes integer)\n * <li>compressed block 1 : a pair of (compressed data size [4 byte integer.\n * Big-endian], compressed data...)\n * <li>compressed block 2\n * <li>...\n * </ol>\n * <p/>\n * Note that the compressed data created by {@link SnappyOutputStream} cannot be\n * uncompressed by {@link Snappy#uncompress(byte[])} since the output formats of\n * {@link Snappy#compress(byte[])} and {@link SnappyOutputStream} are different.\n * Use {@link SnappyInputStream} for uncompress the data generated by\n * {@link SnappyOutputStream}.\n *\n * @author leo\n */\npublic class SnappyOutputStream\n        extends OutputStream\n{\n    public static final int MAX_BLOCK_SIZE = 512 * 1024 * 1024; // 512 MiB\n    static final int MIN_BLOCK_SIZE = 1 * 1024;\n    static final int DEFAULT_BLOCK_SIZE = 32 * 1024; // Use 32kb for the default block size\n\n    protected final OutputStream out;\n    private final int blockSize;\n\n    private final BufferAllocator inputBufferAllocator;\n    private final BufferAllocator outputBufferAllocator;\n\n    // The input and output buffer fields are set to null when closing this stream:\n    protected byte[] inputBuffer;\n    protected byte[] outputBuffer;\n    private int inputCursor = 0;\n    private int outputCursor = 0;\n    private boolean headerWritten;\n    private boolean closed;\n\n    public SnappyOutputStream(OutputStream out)\n    {\n        this(out, DEFAULT_BLOCK_SIZE);\n    }\n\n    /**\n     * @param out\n     * @param blockSize byte size of the internal buffer size\n     * @throws IllegalArgumentException when blockSize is larger than 512 MiB\n     */\n    public SnappyOutputStream(OutputStream out, int blockSize)\n    {\n        this(out, blockSize, CachedBufferAllocator.getBufferAllocatorFactory());\n    }\n\n    public SnappyOutputStream(OutputStream out, int blockSize, BufferAllocatorFactory bufferAllocatorFactory)\n    {\n        this.out = out;\n        this.blockSize = Math.max(MIN_BLOCK_SIZE, blockSize);\n        if (this.blockSize > MAX_BLOCK_SIZE){\n            throw new IllegalArgumentException(String.format(\"Provided chunk size %,d larger than max %,d\", this.blockSize, MAX_BLOCK_SIZE));\n        }\n        int inputSize = blockSize;\n        int outputSize = SnappyCodec.HEADER_SIZE + 4 + Snappy.maxCompressedLength(blockSize);\n\n        this.inputBufferAllocator = bufferAllocatorFactory.getBufferAllocator(inputSize);\n        this.outputBufferAllocator = bufferAllocatorFactory.getBufferAllocator(outputSize);\n\n        inputBuffer = inputBufferAllocator.allocate(inputSize);\n        outputBuffer = outputBufferAllocator.allocate(outputSize);\n    }\n\n    /* (non-Javadoc)\n     * @see java.io.OutputStream#write(byte[], int, int)\n     */\n    @Override\n    public void write(byte[] b, int byteOffset, int byteLength)\n            throws IOException\n    {\n        if (closed) {\n            throw new IOException(\"Stream is closed\");\n        }\n        int cursor = 0;\n        while (cursor < byteLength) {\n            int readLen = Math.min(byteLength - cursor, blockSize - inputCursor);\n            // copy the input data to uncompressed buffer\n            if (readLen > 0) {\n                System.arraycopy(b, byteOffset + cursor, inputBuffer, inputCursor, readLen);\n                inputCursor += readLen;\n            }\n            if (inputCursor < blockSize) {\n                return;\n            }\n\n            compressInput();\n            cursor += readLen;\n        }\n    }\n\n    /**\n     * Compress the input long array data\n     *\n     * @param d input array\n     * @param off offset in the array\n     * @param len the number of elements in the array to copy\n     * @throws IOException\n     */\n    public void write(long[] d, int off, int len)\n            throws IOException\n    {\n        rawWrite(d, off * 8, len * 8);\n    }\n\n    /**\n     * Compress the input double array data\n     *\n     * @param f input array\n     * @param off offset in the array\n     * @param len the number of elements in the array to copy\n     * @throws IOException\n     */\n    public void write(double[] f, int off, int len)\n            throws IOException\n    {\n        rawWrite(f, off * 8, len * 8);\n    }\n\n    /**\n     * Compress the input float array data\n     *\n     * @param f input array\n     * @param off offset in the array\n     * @param len the number of elements in the array to copy\n     * @throws IOException\n     */\n    public void write(float[] f, int off, int len)\n            throws IOException\n    {\n        rawWrite(f, off * 4, len * 4);\n    }\n\n    /**\n     * Compress the input int array data\n     *\n     * @param f input array\n     * @param off offset in the array\n     * @param len the number of elements in the array to copy\n     * @throws IOException\n     */\n    public void write(int[] f, int off, int len)\n            throws IOException\n    {\n        rawWrite(f, off * 4, len * 4);\n    }\n\n    /**\n     * Compress the input short array data\n     *\n     * @param f input array\n     * @param off offset in the array\n     * @param len the number of elements in the array to copy\n     * @throws IOException\n     */\n    public void write(short[] f, int off, int len)\n            throws IOException\n    {\n        rawWrite(f, off * 2, len * 2);\n    }\n\n    /**\n     * Compress the input array data\n     *\n     * @param d\n     * @throws IOException\n     */\n    public void write(long[] d)\n            throws IOException\n    {\n        write(d, 0, d.length);\n    }\n\n    /**\n     * Compress the input array data\n     *\n     * @param f\n     * @throws IOException\n     */\n    public void write(double[] f)\n            throws IOException\n    {\n        write(f, 0, f.length);\n    }\n\n    /**\n     * Compress the input array data\n     *\n     * @param f\n     * @throws IOException\n     */\n    public void write(float[] f)\n            throws IOException\n    {\n        write(f, 0, f.length);\n    }\n\n    /**\n     * Compress the input array data\n     *\n     * @param f\n     * @throws IOException\n     */\n    public void write(int[] f)\n            throws IOException\n    {\n        write(f, 0, f.length);\n    }\n\n    /**\n     * Compress the input array data\n     *\n     * @param f\n     * @throws IOException\n     */\n    public void write(short[] f)\n            throws IOException\n    {\n        write(f, 0, f.length);\n    }\n\n    private boolean hasSufficientOutputBufferFor(int inputSize)\n    {\n        int maxCompressedSize = Snappy.maxCompressedLength(inputSize);\n        return maxCompressedSize < outputBuffer.length - outputCursor - 4;\n    }\n\n    /**\n     * Compress the raw byte array data.\n     *\n     * @param array array data of any type (e.g., byte[], float[], long[], ...)\n     * @param byteOffset\n     * @param byteLength\n     * @throws IOException\n     */\n    public void rawWrite(Object array, int byteOffset, int byteLength)\n            throws IOException\n    {\n        if (closed) {\n            throw new IOException(\"Stream is closed\");\n        }\n        int cursor = 0;\n        while (cursor < byteLength) {\n            int readLen = Math.min(byteLength - cursor, blockSize - inputCursor);\n            // copy the input data to uncompressed buffer\n            if (readLen > 0) {\n                Snappy.arrayCopy(array, byteOffset + cursor, readLen, inputBuffer, inputCursor);\n                inputCursor += readLen;\n            }\n            if (inputCursor < blockSize) {\n                return;\n            }\n\n            compressInput();\n            cursor += readLen;\n        }\n    }\n\n    /**\n     * Writes the specified byte to this output stream. The general contract for\n     * write is that one byte is written to the output stream. The byte to be\n     * written is the eight low-order bits of the argument b. The 24 high-order\n     * bits of b are ignored.\n     */\n    /* (non-Javadoc)\n     * @see java.io.OutputStream#write(int)\n     */\n    @Override\n    public void write(int b)\n            throws IOException\n    {\n        if (closed) {\n            throw new IOException(\"Stream is closed\");\n        }\n        if (inputCursor >= inputBuffer.length) {\n            compressInput();\n        }\n        inputBuffer[inputCursor++] = (byte) b;\n    }\n\n    /* (non-Javadoc)\n     * @see java.io.OutputStream#flush()\n     */\n    @Override\n    public void flush()\n            throws IOException\n    {\n        if (closed) {\n            throw new IOException(\"Stream is closed\");\n        }\n        compressInput();\n        dumpOutput();\n        out.flush();\n    }\n\n    static void writeInt(byte[] dst, int offset, int v)\n    {\n        dst[offset] = (byte) ((v >> 24) & 0xFF);\n        dst[offset + 1] = (byte) ((v >> 16) & 0xFF);\n        dst[offset + 2] = (byte) ((v >> 8) & 0xFF);\n        dst[offset + 3] = (byte) ((v >> 0) & 0xFF);\n    }\n\n    static int readInt(byte[] buffer, int pos)\n    {\n        int b1 = (buffer[pos] & 0xFF) << 24;\n        int b2 = (buffer[pos + 1] & 0xFF) << 16;\n        int b3 = (buffer[pos + 2] & 0xFF) << 8;\n        int b4 = buffer[pos + 3] & 0xFF;\n        return b1 | b2 | b3 | b4;\n    }\n\n    protected void dumpOutput()\n            throws IOException\n    {\n        if (outputCursor > 0) {\n            out.write(outputBuffer, 0, outputCursor);\n            outputCursor = 0;\n        }\n    }\n\n    protected void compressInput()\n            throws IOException\n    {\n        if (!headerWritten) {\n            outputCursor = writeHeader();\n            headerWritten = true;\n        }\n        if (inputCursor <= 0) {\n            return; // no need to dump\n        }\n        // Compress and dump the buffer content\n        if (!hasSufficientOutputBufferFor(inputCursor)) {\n            dumpOutput();\n        }\n        writeBlockPreemble();\n        int compressedSize = Snappy.compress(inputBuffer, 0, inputCursor, outputBuffer, outputCursor + 4);\n        // Write compressed data size\n        writeInt(outputBuffer, outputCursor, compressedSize);\n        outputCursor += 4 + compressedSize;\n        inputCursor = 0;\n    }\n\n    protected int writeHeader(){\n        return SnappyCodec.currentHeader.writeHeader(outputBuffer, 0);\n    }\n\n    /**\n     * Optionally write a preemble before a block. Hadoop requires the actual block data size being written. This base\n     * implementation does nothing. Derive implementation can call {@code writeCurrentDataSize()}.\n     */\n    protected void writeBlockPreemble()\n    {\n        // do nothing\n    }\n\n    protected void writeCurrentDataSize(){\n        writeInt(outputBuffer, outputCursor, inputCursor);\n        outputCursor += 4;\n    }\n\n    /**\n     * close the stream\n     */\n    /* (non-Javadoc)\n     * @see java.io.OutputStream#close()\n     */\n    @Override\n    public void close()\n            throws IOException\n    {\n        if (closed) {\n            return;\n        }\n        try {\n            flush();\n            out.close();\n        }\n        finally {\n            closed = true;\n            inputBufferAllocator.release(inputBuffer);\n            outputBufferAllocator.release(outputBuffer);\n            inputBuffer = null;\n            outputBuffer = null;\n        }\n    }\n}\n", "/*--------------------------------------------------------------------------\n *  Copyright 2011 Taro L. Saito\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *--------------------------------------------------------------------------*/\n//--------------------------------------\n// XerialJ\n//\n// SnappyOutputStreamTest.java\n// Since: 2011/03/31 18:26:31\n//\n// $URL$\n// $Author$\n//--------------------------------------\npackage org.xerial.snappy;\n\nimport static org.junit.Assert.*;\n\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\nimport java.nio.ByteOrder;\n\nimport org.junit.Test;\nimport org.junit.Assert;\nimport org.xerial.snappy.buffer.BufferAllocatorFactory;\nimport org.xerial.snappy.buffer.CachedBufferAllocator;\nimport org.xerial.snappy.buffer.DefaultBufferAllocator;\nimport org.xerial.util.FileResource;\nimport org.xerial.util.log.Logger;\n\npublic class SnappyOutputStreamTest\n{\n    private static Logger _logger = Logger.getLogger(SnappyOutputStreamTest.class);\n\n    @Test\n    public void test()\n            throws Exception\n    {\n        ByteArrayOutputStream buf = new ByteArrayOutputStream();\n        SnappyOutputStream sout = new SnappyOutputStream(buf);\n\n        BufferedInputStream input = new BufferedInputStream(FileResource.find(SnappyOutputStreamTest.class,\n                \"alice29.txt\").openStream());\n        assertNotNull(input);\n\n        ByteArrayOutputStream orig = new ByteArrayOutputStream();\n        byte[] tmp = new byte[1024];\n        for (int readBytes = 0; (readBytes = input.read(tmp)) != -1; ) {\n            sout.write(tmp, 0, readBytes);\n            orig.write(tmp, 0, readBytes); // preserve the original data\n        }\n        input.close();\n        sout.flush();\n        orig.flush();\n\n        int compressedSize = buf.size();\n        _logger.debug(\"compressed size: \" + compressedSize);\n\n        ByteArrayOutputStream decompressed = new ByteArrayOutputStream();\n        byte[] compressed = buf.toByteArray();\n        // decompress\n        for (int cursor = SnappyCodec.headerSize(); cursor < compressed.length; ) {\n            int chunkSize = SnappyOutputStream.readInt(compressed, cursor);\n            cursor += 4;\n            byte[] tmpOut = new byte[Snappy.uncompressedLength(compressed, cursor, chunkSize)];\n            int decompressedSize = Snappy.uncompress(compressed, cursor, chunkSize, tmpOut, 0);\n            cursor += chunkSize;\n\n            decompressed.write(tmpOut);\n        }\n        decompressed.flush();\n        assertEquals(orig.size(), decompressed.size());\n        assertArrayEquals(orig.toByteArray(), decompressed.toByteArray());\n    }\n\n    @Test\n    public void bufferSize()\n            throws Exception\n    {\n        ByteArrayOutputStream b = new ByteArrayOutputStream();\n        SnappyOutputStream os = new SnappyOutputStream(b, 1500);\n        final int bytesToWrite = 5000;\n        byte[] orig = new byte[bytesToWrite];\n        for (int i = 0; i < 5000; ++i) {\n            byte v = (byte) (i % 128);\n            orig[i] = v;\n            os.write(v);\n        }\n        os.close();\n        SnappyInputStream is = new SnappyInputStream(new ByteArrayInputStream(b.toByteArray()));\n        byte[] buf = new byte[bytesToWrite / 101];\n        while (is.read(buf) != -1) {\n        }\n        is.close();\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void invalidBlockSize()\n            throws Exception\n    {\n        // We rely on catch below, if there is no error this test will pass\n        // This can be done better with Assertions.assertThrows\n        Boolean exceptionThrown = false;\n        ByteArrayOutputStream b = new ByteArrayOutputStream();\n        SnappyOutputStream os = new SnappyOutputStream(b, 1024 * 1024 * 1024);\n    }\n\n    @Test\n    public void smallWrites()\n            throws Exception\n    {\n\n        byte[] orig = CalgaryTest.readFile(\"alice29.txt\");\n        ByteArrayOutputStream b = new ByteArrayOutputStream();\n        SnappyOutputStream out = new SnappyOutputStream(b);\n\n        for (byte c : orig) {\n            out.write(c);\n        }\n        out.close();\n\n        SnappyInputStream is = new SnappyInputStream(new ByteArrayInputStream(b.toByteArray()));\n        byte[] decompressed = new byte[orig.length];\n        int cursor = 0;\n        int readLen = 0;\n        for (int i = 0; i < decompressed.length && (readLen = is.read(decompressed, i, decompressed.length - i)) != -1; ) {\n            i += readLen;\n        }\n        is.close();\n        assertArrayEquals(orig, decompressed);\n    }\n\n    /**\n     * Compress the input array by passing it chunk-by-chunk to a SnappyOutputStream.\n     *\n     * @param orig the data to compress\n     * @param maxChunkSize the maximum chunk size, in bytes.\n     * @return the compressed bytes\n     */\n    private static byte[] compressAsChunks(byte[] orig, int maxChunkSize)\n            throws Exception\n    {\n        ByteArrayOutputStream b = new ByteArrayOutputStream();\n        SnappyOutputStream out = new SnappyOutputStream(b);\n\n        int remaining = orig.length;\n        for (int start = 0; start < orig.length; start += maxChunkSize) {\n            out.write(orig, start, remaining < maxChunkSize ? remaining : maxChunkSize);\n            remaining -= maxChunkSize;\n        }\n        out.close();\n        return b.toByteArray();\n    }\n\n    @Test\n    public void batchingOfWritesShouldNotAffectCompressedDataSize()\n            throws Exception\n    {\n        // Regression test for issue #100, a bug where the size of compressed data could be affected\n        // by the batching of writes to the SnappyOutputStream rather than the total amount of data\n        // written to the stream.\n        byte[] orig = CalgaryTest.readFile(\"alice29.txt\");\n        // Compress the data once so that we know the expected size:\n        byte[] expectedCompressedData = compressAsChunks(orig, Integer.MAX_VALUE);\n        // Hardcoding an expected compressed size here will catch regressions that lower the\n        // compression quality:\n        if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN)\n            assertEquals(90992, expectedCompressedData.length);\n        else\n            assertEquals(91080, expectedCompressedData.length);\n        // The chunk size should not affect the size of the compressed output:\n        int[] chunkSizes = new int[] {1, 100, 1023, 1024, 10000};\n        for (int chunkSize : chunkSizes) {\n            byte[] compressedData = compressAsChunks(orig, chunkSize);\n            assertEquals(String.format(\"when chunk size = %,d\", chunkSize), expectedCompressedData.length, compressedData.length);\n            assertArrayEquals(expectedCompressedData, compressedData);\n        }\n    }\n\n    @Test\n    public void closeShouldBeIdempotent()\n            throws Exception\n    {\n        // Regression test for issue #107, a bug where close() was non-idempotent and would release\n        // its buffers to the allocator multiple times, which could cause scenarios where two open\n        // SnappyOutputStreams could share the same buffers, leading to stream corruption issues.\n        final BufferAllocatorFactory bufferAllocatorFactory = CachedBufferAllocator.getBufferAllocatorFactory();\n        final int BLOCK_SIZE = 4096;\n        // Create a stream, use it, then close it once:\n        ByteArrayOutputStream ba1 = new ByteArrayOutputStream();\n        SnappyOutputStream os1 = new SnappyOutputStream(ba1, BLOCK_SIZE, bufferAllocatorFactory);\n        os1.write(42);\n        os1.close();\n        // Create a new output stream, which should end up re-using the first stream's freed buffers\n        ByteArrayOutputStream ba2 = new ByteArrayOutputStream();\n        SnappyOutputStream os2 = new SnappyOutputStream(ba2, BLOCK_SIZE, bufferAllocatorFactory);\n        // Close the first stream a second time, which is supposed to be safe due to idempotency:\n        os1.close();\n        // Allocate a third output stream, which is supposed to get its own fresh set of buffers:\n        ByteArrayOutputStream ba3 = new ByteArrayOutputStream();\n        SnappyOutputStream os3 = new SnappyOutputStream(ba3, BLOCK_SIZE, bufferAllocatorFactory);\n        // Since the second and third streams should have distinct sets of buffers, writes to these\n        // streams should not interfere with one another:\n        os2.write(2);\n        os3.write(3);\n        os2.close();\n        os3.close();\n        SnappyInputStream in2 = new SnappyInputStream(new ByteArrayInputStream(ba2.toByteArray()));\n        assertEquals(2, in2.read());\n        in2.close();\n        SnappyInputStream in3 = new SnappyInputStream(new ByteArrayInputStream(ba3.toByteArray()));\n        assertEquals(3, in3.read());\n        in3.close();\n    }\n\n    @Test\n    public void writingToClosedStreamShouldThrowIOException()\n            throws IOException\n    {\n        ByteArrayOutputStream b = new ByteArrayOutputStream();\n        SnappyOutputStream os = new SnappyOutputStream(b);\n        os.close();\n        try {\n            os.write(4);\n            fail(\"Expected write() to throw IOException\");\n        }\n        catch (IOException e) {\n            // Expected exception\n        }\n        try {\n            os.write(new int[] {1, 2, 3, 4});\n            fail(\"Expected write() to throw IOException\");\n        }\n        catch (IOException e) {\n            // Expected exception\n        }\n    }\n\n    @Test\n    public void flushingClosedStreamShouldThrowIOException()\n            throws IOException\n    {\n        ByteArrayOutputStream b = new ByteArrayOutputStream();\n        SnappyOutputStream os = new SnappyOutputStream(b);\n        os.close();\n        try {\n            os.flush();\n        }\n        catch (IOException e) {\n            // Expected exception\n        }\n    }\n\n    @Test\n    public void closingStreamShouldMakeBuffersEligibleForGarbageCollection()\n            throws IOException\n    {\n        ByteArrayOutputStream b = new ByteArrayOutputStream();\n        SnappyOutputStream os = new SnappyOutputStream(b, 4095, DefaultBufferAllocator.factory);\n        WeakReference<byte[]> inputBuffer = new WeakReference<byte[]>(os.inputBuffer);\n        WeakReference<byte[]> outputBuffer = new WeakReference<byte[]>(os.inputBuffer);\n        os.close();\n        System.gc();\n        assertNull(inputBuffer.get());\n        assertNull(outputBuffer.get());\n    }\n\n    @Test\n    public void longArrayCompress()\n            throws Exception\n    {\n        long[] l = new long[10];\n        for (int i = 0; i < l.length; ++i) {\n            l[i] = i % 3 + i * 11;\n        }\n\n        ByteArrayOutputStream b = new ByteArrayOutputStream();\n        SnappyOutputStream os = new SnappyOutputStream(b);\n\n        os.write(l);\n        os.close();\n        SnappyInputStream is = new SnappyInputStream(new ByteArrayInputStream(b.toByteArray()));\n        long[] l2 = new long[10];\n        int readBytes = is.read(l2);\n        is.close();\n\n        assertEquals(10 * 8, readBytes);\n        assertArrayEquals(l, l2);\n    }\n\n    @Test\n    public void writeDoubleArray()\n            throws Exception\n    {\n        ByteArrayOutputStream b = new ByteArrayOutputStream();\n        SnappyOutputStream os = new SnappyOutputStream(b);\n\n        double[] orig = new double[] {1.0, 2.0, 1.4, 0.00343430014, -4.4, 4e-20};\n        os.write(orig);\n        os.close();\n\n        SnappyInputStream is = new SnappyInputStream(new ByteArrayInputStream(b.toByteArray()));\n        double[] uncompressed = new double[orig.length];\n        is.read(uncompressed);\n        is.close();\n\n        assertArrayEquals(orig, uncompressed, 0.0);\n    }\n\n    @Test\n    public void writeFloatArray()\n            throws Exception\n    {\n        ByteArrayOutputStream b = new ByteArrayOutputStream();\n        SnappyOutputStream os = new SnappyOutputStream(b);\n\n        float[] orig = new float[] {1.0f, 2.0f, 1.4f, 0.00343430014f, -4.4f, 4e-20f};\n        os.write(orig);\n        os.close();\n\n        SnappyInputStream is = new SnappyInputStream(new ByteArrayInputStream(b.toByteArray()));\n        float[] uncompressed = new float[orig.length];\n        is.read(uncompressed);\n        is.close();\n\n        assertArrayEquals(orig, uncompressed, 0.0f);\n    }\n\n    @Test\n    public void writeIntArray()\n            throws Exception\n    {\n        ByteArrayOutputStream b = new ByteArrayOutputStream();\n        SnappyOutputStream os = new SnappyOutputStream(b);\n\n        int[] orig = new int[] {0, -1, -34, 43, 234, 34324, -234};\n        os.write(orig);\n        os.close();\n\n        SnappyInputStream is = new SnappyInputStream(new ByteArrayInputStream(b.toByteArray()));\n        int[] uncompressed = new int[orig.length];\n        is.read(uncompressed);\n        is.close();\n\n        assertArrayEquals(orig, uncompressed);\n    }\n\n    @Test\n    public void writeShortArray()\n            throws Exception\n    {\n        ByteArrayOutputStream b = new ByteArrayOutputStream();\n        SnappyOutputStream os = new SnappyOutputStream(b);\n\n        short[] orig = new short[] {0, -1, -34, 43, 234, 324, -234};\n        os.write(orig);\n        os.close();\n\n        SnappyInputStream is = new SnappyInputStream(new ByteArrayInputStream(b.toByteArray()));\n        short[] uncompressed = new short[orig.length];\n        is.read(uncompressed);\n        is.close();\n\n        assertArrayEquals(orig, uncompressed);\n    }\n}\n", "/*--------------------------------------------------------------------------\n *  Copyright 2011 Taro L. Saito\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *--------------------------------------------------------------------------*/\n//--------------------------------------\n// snappy-java Project\n//\n// SnappyTest.java\n// Since: 2011/03/30\n//\n// $URL$\n// $Author$\n//--------------------------------------\npackage org.xerial.snappy;\n\nimport static org.junit.Assert.*;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\n\nimport org.junit.Assume;\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.xerial.util.log.Logger;\n\npublic class SnappyTest\n{\n    private static Logger _logger = Logger.getLogger(SnappyTest.class);\n\n    @Test\n    public void getVersion()\n            throws Exception\n    {\n        String version = Snappy.getNativeLibraryVersion();\n        _logger.debug(\"version: \" + version);\n    }\n\n    @Test\n    public void directBufferCheck()\n            throws Exception\n    {\n\n        try {\n            ByteBuffer src = ByteBuffer.allocate(1024);\n            src.put(\"hello world\".getBytes());\n            src.flip();\n            ByteBuffer dest = ByteBuffer.allocate(1024);\n            int maxCompressedLen = Snappy.compress(src, dest);\n        }\n        catch (SnappyError e) {\n            Assert.assertTrue(e.errorCode == SnappyErrorCode.NOT_A_DIRECT_BUFFER);\n            return;\n        }\n\n        fail(\"shouldn't reach here\");\n    }\n\n    @Test\n    public void directBuffer()\n            throws Exception\n    {\n\n        StringBuilder s = new StringBuilder();\n        for (int i = 0; i < 20; ++i) {\n            s.append(\"Hello world!\");\n        }\n        String origStr = s.toString();\n        byte[] orig = origStr.getBytes();\n        int BUFFER_SIZE = orig.length;\n        ByteBuffer src = ByteBuffer.allocateDirect(orig.length);\n        src.put(orig);\n        src.flip();\n        _logger.debug(\"input size: \" + src.remaining());\n        int maxCompressedLen = Snappy.maxCompressedLength(src.remaining());\n        _logger.debug(\"max compressed length:\" + maxCompressedLen);\n\n        ByteBuffer compressed = ByteBuffer.allocateDirect(maxCompressedLen);\n        int compressedSize = Snappy.compress(src, compressed);\n        _logger.debug(\"compressed length: \" + compressedSize);\n\n        assertTrue(Snappy.isValidCompressedBuffer(compressed));\n\n        assertEquals(0, src.position());\n        assertEquals(orig.length, src.remaining());\n        assertEquals(orig.length, src.limit());\n\n        assertEquals(0, compressed.position());\n        assertEquals(compressedSize, compressed.limit());\n        assertEquals(compressedSize, compressed.remaining());\n\n        int uncompressedLen = Snappy.uncompressedLength(compressed);\n        _logger.debug(\"uncompressed length: \" + uncompressedLen);\n        ByteBuffer extract = ByteBuffer.allocateDirect(uncompressedLen);\n        int uncompressedLen2 = Snappy.uncompress(compressed, extract);\n        assertEquals(uncompressedLen, uncompressedLen2);\n        assertEquals(uncompressedLen, extract.remaining());\n\n        byte[] b = new byte[uncompressedLen];\n        extract.get(b);\n        String decompressed = new String(b);\n        _logger.debug(decompressed);\n\n        assertEquals(origStr, decompressed);\n    }\n\n    @Test\n    public void bufferOffset()\n            throws Exception\n    {\n\n        String m = \"ACCAGGGGGGGGGGGGGGGGGGGGATAGATATTTCCCGAGATATTTTATATAAAAAAA\";\n        byte[] orig = m.getBytes();\n        final int offset = 100;\n        ByteBuffer input = ByteBuffer.allocateDirect(orig.length + offset);\n        input.position(offset);\n        input.put(orig);\n        input.flip();\n        input.position(offset);\n\n        // compress\n        int maxCompressedLength = Snappy.maxCompressedLength(input.remaining());\n        final int offset2 = 40;\n        ByteBuffer compressed = ByteBuffer.allocateDirect(maxCompressedLength + offset2);\n        compressed.position(offset2);\n        Snappy.compress(input, compressed);\n        assertTrue(Snappy.isValidCompressedBuffer(compressed));\n\n        // uncompress\n        final int offset3 = 80;\n        int uncompressedLength = Snappy.uncompressedLength(compressed);\n        ByteBuffer uncompressed = ByteBuffer.allocateDirect(uncompressedLength + offset3);\n        uncompressed.position(offset3);\n        Snappy.uncompress(compressed, uncompressed);\n        assertEquals(offset3, uncompressed.position());\n        assertEquals(offset3 + uncompressedLength, uncompressed.limit());\n        assertEquals(uncompressedLength, uncompressed.remaining());\n\n        // extract string\n        byte[] recovered = new byte[uncompressedLength];\n        uncompressed.get(recovered);\n        String m2 = new String(recovered);\n\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void byteArrayCompress()\n            throws Exception\n    {\n\n        String m = \"ACCAGGGGGGGGGGGGGGGGGGGGATAGATATTTCCCGAGATATTTTATATAAAAAAA\";\n        byte[] input = m.getBytes();\n        byte[] output = new byte[Snappy.maxCompressedLength(input.length)];\n        int compressedSize = Snappy.compress(input, 0, input.length, output, 0);\n        byte[] uncompressed = new byte[input.length];\n\n        assertTrue(Snappy.isValidCompressedBuffer(output, 0, compressedSize));\n        int uncompressedSize = Snappy.uncompress(output, 0, compressedSize, uncompressed, 0);\n        String m2 = new String(uncompressed);\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void rangeCheck()\n            throws Exception\n    {\n        String m = \"ACCAGGGGGGGGGGGGGGGGGGGGATAGATATTTCCCGAGATATTTTATATAAAAAAA\";\n        byte[] input = m.getBytes();\n        byte[] output = new byte[Snappy.maxCompressedLength(input.length)];\n        int compressedSize = Snappy.compress(input, 0, input.length, output, 0);\n\n        assertTrue(Snappy.isValidCompressedBuffer(output, 0, compressedSize));\n        // Intentionally set an invalid range\n        assertFalse(Snappy.isValidCompressedBuffer(output, 0, compressedSize + 1));\n        assertFalse(Snappy.isValidCompressedBuffer(output, 1, compressedSize));\n\n        // Test the ByteBuffer API\n        ByteBuffer bin = ByteBuffer.allocateDirect(input.length);\n        bin.put(input);\n        bin.flip();\n        ByteBuffer bout = ByteBuffer.allocateDirect(Snappy.maxCompressedLength(bin.remaining()));\n        int compressedSize2 = Snappy.compress(bin, bout);\n        assertEquals(compressedSize, compressedSize2);\n\n        assertTrue(Snappy.isValidCompressedBuffer(bout));\n        // Intentionally set an invalid range\n        bout.limit(bout.limit() + 1);\n        assertFalse(Snappy.isValidCompressedBuffer(bout));\n        bout.limit(bout.limit() - 1);\n        bout.position(1);\n        assertFalse(Snappy.isValidCompressedBuffer(bout));\n    }\n\n    @Test\n    public void highLevelAPI()\n            throws Exception\n    {\n\n        String m = \"Hello! 01234 ACGDSFSDFJ World. FDSDF02394234 fdsfda03924\";\n        byte[] input = m.getBytes();\n        byte[] output = Snappy.compress(input);\n\n        byte[] uncompressed = Snappy.uncompress(output);\n        String m2 = new String(uncompressed);\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void lowLevelAPI()\n            throws Exception\n    {\n\n        String m = \"Hello! 01234 ACGDSFSDFJ World. FDSDF02394234 fdsfda03924\";\n        byte[] input = m.getBytes();\n        byte[] output = Snappy.rawCompress(input, input.length);\n\n        byte[] uncompressed = Snappy.uncompress(output);\n        String m2 = new String(uncompressed);\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void simpleUsage()\n            throws Exception\n    {\n\n        String input = \"Hello snappy-java! Snappy-java is a JNI-based wrapper\"\n                + \" for using Snappy from Google (written in C++), a fast compresser/decompresser.\";\n        byte[] compressed = Snappy.compress(input.getBytes(\"UTF-8\"));\n        byte[] uncompressed = Snappy.uncompress(compressed);\n        String result = new String(uncompressed, \"UTF-8\");\n        _logger.debug(result);\n    }\n\n    @Test\n    public void floatArray()\n            throws Exception\n    {\n        float[] data = new float[] {1.0f, -0.3f, 1.3f, 234.4f, 34};\n        byte[] compressed = Snappy.compress(data);\n        float[] result = Snappy.uncompressFloatArray(compressed);\n        assertArrayEquals(data, result, 0.0f);\n    }\n\n    @Test\n    public void doubleArray()\n            throws Exception\n    {\n        double[] data = new double[] {1.0, -0.3, 1.3, 234.4, 34};\n        byte[] compressed = Snappy.compress(data);\n        double[] result = Snappy.uncompressDoubleArray(compressed);\n        assertArrayEquals(data, result, 0.0f);\n    }\n\n    @Test\n    public void longArray()\n            throws Exception\n    {\n        long[] data = new long[] {2, 3, 15, 4234, 43251531412342342L, 23423422342L};\n        byte[] compressed = Snappy.compress(data);\n        long[] result = Snappy.uncompressLongArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void shortArray()\n            throws Exception\n    {\n        short[] data = new short[] {432, -32267, 1, 3, 34, 43, 34, Short.MAX_VALUE, -1};\n        byte[] compressed = Snappy.compress(data);\n        short[] result = Snappy.uncompressShortArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void intArray()\n            throws Exception\n    {\n        int[] data = new int[] {432, -32267, 1, 3, 34, 43, 34, Short.MAX_VALUE, -1, Integer.MAX_VALUE, 3424, 43};\n        byte[] compressed = Snappy.compress(data);\n        int[] result = Snappy.uncompressIntArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void charArray()\n            throws Exception\n    {\n        char[] data = new char[] {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '!'};\n        byte[] compressed = Snappy.compress(data);\n        char[] result = Snappy.uncompressCharArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void string()\n            throws Exception\n    {\n        String s = \"Hello Snappy! Snappy! Snappy!\";\n        byte[] compressed = Snappy.compress(s);\n        String uncompressedString = Snappy.uncompressString(compressed);\n        assertEquals(s, uncompressedString);\n    }\n\n    @Test\n    public void isValidCompressedData()\n            throws Exception\n    {\n\n        byte[] b = new byte[] {(byte) 91, (byte) 34, (byte) 80, (byte) 73, (byte) 34, (byte) 93};\n\n        assertFalse(Snappy.isValidCompressedBuffer(b));\n\n        try {\n            byte[] uncompressed = Snappy.uncompress(b);\n            fail(\"cannot reach here since the input is invalid data\");\n        }\n        catch (IOException e) {\n            _logger.debug(e);\n        }\n    }\n\n\n    /*\n    Tests happy cases for SnappyInputStream.read method\n    - {0}\n     */\n    @Test\n    public void isValidChunkLengthForSnappyInputStreamIn()\n            throws Exception {\n        byte[] data = {0};\n        SnappyInputStream in = new SnappyInputStream(new ByteArrayInputStream(data));\n        byte[] out = new byte[50];\n        in.read(out);\n    }\n\n    /*\n    Tests sad cases for SnappyInputStream.read method\n    - Expects a java.lang.NegativeArraySizeException catched into a SnappyError\n    - {-126, 'S', 'N', 'A', 'P', 'P', 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0,(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff}\n     */\n    @Test(expected = SnappyError.class)\n    public void isInvalidChunkLengthForSnappyInputStreamInNegative()\n            throws Exception {\n        byte[] data = {-126, 'S', 'N', 'A', 'P', 'P', 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0,(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff};\n        SnappyInputStream in = new SnappyInputStream(new ByteArrayInputStream(data));\n        byte[] out = new byte[50];\n        in.read(out);\n    }\n\n    /*\n    Tests sad cases for SnappyInputStream.read method\n    - Expects a java.lang.OutOfMemoryError\n    - {-126, 'S', 'N', 'A', 'P', 'P', 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0,(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff}\n     */\n    @Test(expected = SnappyError.class)\n    public void isInvalidChunkLengthForSnappyInputStreamOutOfMemory()\n            throws Exception {\n        byte[] data = {-126, 'S', 'N', 'A', 'P', 'P', 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0, (byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff};\n        SnappyInputStream in = new SnappyInputStream(new ByteArrayInputStream(data));\n        byte[] out = new byte[50];\n        try {\n            in.read(out);\n        } catch (Exception ignored) {\n            // Exception here will be catched\n            // But OutOfMemoryError will not be caught, and will still be thrown\n        }\n    }\n\n    /*\n    Tests sad cases for SnappyInputStream.read method\n    - Expects a failed to compress exception due to upper bounds chunk size\n    - {-126, 'S', 'N', 'A', 'P', 'P', 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0,(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff}\n     */\n    @Test\n    public void isInvalidChunkLengthForSnappyInputStream()\n            throws Exception {\n        byte[] data = {-126, 'S', 'N', 'A', 'P', 'P', 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0, (byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff};\n        SnappyInputStream in = new SnappyInputStream(new ByteArrayInputStream(data));\n        byte[] out = new byte[50];\n        try {\n            in.read(out);\n        } catch (SnappyError error) {\n            Assert.assertEquals(error.errorCode, SnappyErrorCode.FAILED_TO_UNCOMPRESS);\n        }\n    }\n\n    /*\n    Tests happy cases for BitShuffle.shuffle method\n    - double: 0, 10\n    - float: 0, 10\n    - int: 0, 10\n    - long: 0, 10\n    - short: 0, 10\n     */\n    @Test\n    public void isValidArrayInputLength()\n            throws Exception {\n        byte[] a = Snappy.compress(new char[0]);\n        byte[] b = Snappy.compress(new double[0]);\n        byte[] c = Snappy.compress(new float[0]);\n        byte[] d = Snappy.compress(new int[0]);\n        byte[] e = Snappy.compress(new long[0]);\n        byte[] f = Snappy.compress(new short[0]);\n        byte[] g = Snappy.compress(new char[10]);\n        byte[] h = Snappy.compress(new double[10]);\n        byte[] i = Snappy.compress(new float[10]);\n        byte[] j = Snappy.compress(new int[10]);\n        byte[] k = Snappy.compress(new long[10]);\n        byte[] l = Snappy.compress(new short[10]);\n    }\n\n    /*\n    Tests sad cases for Snappy.compress\n    - Allocate a buffer whose byte size will be a bit larger than Integer.MAX_VALUE\n    - char\n    - double\n    - float\n    - int\n    - long\n    - short\n     */\n    @Test(expected = SnappyError.class)\n    public void isTooLargeDoubleArrayInputLength() throws Exception {\n        assumingCIIsFalse();\n        Snappy.compress(new double[Integer.MAX_VALUE / 8 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeCharArrayInputLength() throws Exception {\n        assumingCIIsFalse();\n        Snappy.compress(new char[Integer.MAX_VALUE / 2 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeFloatArrayInputLength() throws Exception {\n        assumingCIIsFalse();\n        Snappy.compress(new float[Integer.MAX_VALUE / 4 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeIntArrayInputLength() throws Exception {\n        assumingCIIsFalse();\n        Snappy.compress(new int[Integer.MAX_VALUE / 4 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeLongArrayInputLength() throws Exception {\n        assumingCIIsFalse();\n        Snappy.compress(new long[Integer.MAX_VALUE / 8 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeShortArrayInputLength() throws Exception {\n        assumingCIIsFalse();\n        Snappy.compress(new short[Integer.MAX_VALUE / 2 + 1]);\n    }\n\n    /*\n    Tests happy cases for Snappy.compress\n    - char: 0, 10\n    */\n    @Test\n    public void isValidArrayInputLengthForBitShuffleShuffle()\n            throws Exception\n    {\n        byte[] b = BitShuffle.shuffle(new double[0]);\n        byte[] c = BitShuffle.shuffle(new float[0]);\n        byte[] d = BitShuffle.shuffle(new int[0]);\n        byte[] e = BitShuffle.shuffle(new long[0]);\n        byte[] f = BitShuffle.shuffle(new short[0]);\n        byte[] n = BitShuffle.shuffle(new double[10]);\n        byte[] o = BitShuffle.shuffle(new float[10]);\n        byte[] p = BitShuffle.shuffle(new int[10]);\n        byte[] q = BitShuffle.shuffle(new long[10]);\n        byte[] r = BitShuffle.shuffle(new short[10]);\n    }\n\n    /*\n    Tests sad cases for BitShuffle.shuffle method\n    - Allocate a buffer whose byte size will be a bit larger than Integer.MAX_VALUE\n    - double: 8\n    - float: 4\n    - int: 4\n    - long: 8\n    - short: 2\n     */\n    @Test(expected = SnappyError.class)\n    public void isTooLargeDoubleArrayInputLengthForBitShuffleShuffle() throws Exception {\n        assumingCIIsFalse();\n        BitShuffle.shuffle(new double[Integer.MAX_VALUE / 8 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeFloatArrayInputLengthForBitShuffleShuffle() throws Exception {\n        assumingCIIsFalse();\n        BitShuffle.shuffle(new float[Integer.MAX_VALUE / 4 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeIntArrayInputLengthForBitShuffleShuffle() throws Exception {\n        assumingCIIsFalse();\n        BitShuffle.shuffle(new float[Integer.MAX_VALUE / 4 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeLongArrayInputLengthForBitShuffleShuffle() throws Exception {\n        assumingCIIsFalse();\n        BitShuffle.shuffle(new long[Integer.MAX_VALUE / 8 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeShortArrayInputLengthForBitShuffleShuffle() throws Exception {\n        assumingCIIsFalse();\n        BitShuffle.shuffle(new short[Integer.MAX_VALUE / 2 + 1]);\n    }\n\n    private void assumingCIIsFalse() {\n        if (System.getenv(\"CI\") == null)\n            return;\n        Assume.assumeFalse(\"Skipped on CI\", System.getenv(\"CI\").equals(\"true\"));\n    }\n}\n"], "filenames": ["src/main/java/org/xerial/snappy/SnappyHadoopCompatibleOutputStream.java", "src/main/java/org/xerial/snappy/SnappyInputStream.java", "src/main/java/org/xerial/snappy/SnappyOutputStream.java", "src/test/java/org/xerial/snappy/SnappyOutputStreamTest.java", "src/test/java/org/xerial/snappy/SnappyTest.java"], "buggy_code_start_loc": [2, 38, 61, 36, 382], "buggy_code_end_loc": [6, 424, 97, 106, 382], "fixing_code_start_loc": [3, 39, 62, 37, 383], "fixing_code_end_loc": [5, 448, 102, 119, 401], "type": "CWE-770", "message": "snappy-java is a Java port of the snappy, a fast C++ compresser/decompresser developed by Google. The SnappyInputStream was found to be vulnerable to Denial of Service (DoS) attacks when decompressing data with a too large chunk size. Due to missing upper bound check on chunk length, an unrecoverable fatal error can occur. All versions of snappy-java including the latest released version 1.1.10.3 are vulnerable to this issue. A fix has been introduced in commit `9f8c3cf74` which will be included in the 1.1.10.4 release. Users are advised to upgrade. Users unable to upgrade should only accept compressed data from trusted sources.", "other": {"cve": {"id": "CVE-2023-43642", "sourceIdentifier": "security-advisories@github.com", "published": "2023-09-25T20:15:11.723", "lastModified": "2023-09-26T15:46:35.600", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "snappy-java is a Java port of the snappy, a fast C++ compresser/decompresser developed by Google. The SnappyInputStream was found to be vulnerable to Denial of Service (DoS) attacks when decompressing data with a too large chunk size. Due to missing upper bound check on chunk length, an unrecoverable fatal error can occur. All versions of snappy-java including the latest released version 1.1.10.3 are vulnerable to this issue. A fix has been introduced in commit `9f8c3cf74` which will be included in the 1.1.10.4 release. Users are advised to upgrade. Users unable to upgrade should only accept compressed data from trusted sources."}, {"lang": "es", "value": "snappy-java es una adaptaci\u00f3n Java de snappy, un r\u00e1pido compresor/descompresor de C++ desarrollado por Google. Se descubri\u00f3 que SnappyInputStream era vulnerable a ataques de denegaci\u00f3n de servicio (DoS) al descomprimir datos con un tama\u00f1o de fragmento demasiado grande. Debido a que falta la verificaci\u00f3n del l\u00edmite superior en la longitud del fragmento, puede ocurrir un error fatal irrecuperable. Todas las versiones de snappy-java, incluida la \u00faltima versi\u00f3n 1.1.10.3, son vulnerables a este problema.\nSe introdujo una soluci\u00f3n en el commit `9f8c3cf74` que se incluir\u00e1 en la versi\u00f3n 1.1.10.4.\nSe recomienda a los usuarios que actualicen. Los usuarios que no puedan actualizar solo deben aceptar datos comprimidos de fuentes confiables."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xerial:snappy-java:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.10.4", "matchCriteriaId": "A4D939A7-FF7A-4C6D-A2B5-D9D3C9D02023"}]}]}], "references": [{"url": "https://github.com/xerial/snappy-java/commit/9f8c3cf74223ed0a8a834134be9c917b9f10ceb5", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/xerial/snappy-java/security/advisories/GHSA-55g7-9cwv-5qfv", "source": "security-advisories@github.com", "tags": ["Exploit"]}]}, "github_commit_url": "https://github.com/xerial/snappy-java/commit/9f8c3cf74223ed0a8a834134be9c917b9f10ceb5"}}