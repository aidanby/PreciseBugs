{"buggy_code": ["/*\n * Simple NUMA memory policy for the Linux kernel.\n *\n * Copyright 2003,2004 Andi Kleen, SuSE Labs.\n * (C) Copyright 2005 Christoph Lameter, Silicon Graphics, Inc.\n * Subject to the GNU Public License, version 2.\n *\n * NUMA policy allows the user to give hints in which node(s) memory should\n * be allocated.\n *\n * Support four policies per VMA and per process:\n *\n * The VMA policy has priority over the process policy for a page fault.\n *\n * interleave     Allocate memory interleaved over a set of nodes,\n *                with normal fallback if it fails.\n *                For VMA based allocations this interleaves based on the\n *                offset into the backing object or offset into the mapping\n *                for anonymous memory. For process policy an process counter\n *                is used.\n *\n * bind           Only allocate memory on a specific set of nodes,\n *                no fallback.\n *                FIXME: memory is allocated starting with the first node\n *                to the last. It would be better if bind would truly restrict\n *                the allocation to memory nodes instead\n *\n * preferred       Try a specific node first before normal fallback.\n *                As a special case NUMA_NO_NODE here means do the allocation\n *                on the local CPU. This is normally identical to default,\n *                but useful to set in a VMA when you have a non default\n *                process policy.\n *\n * default        Allocate on the local node first, or when on a VMA\n *                use the process policy. This is what Linux always did\n *\t\t  in a NUMA aware kernel and still does by, ahem, default.\n *\n * The process policy is applied for most non interrupt memory allocations\n * in that process' context. Interrupts ignore the policies and always\n * try to allocate on the local CPU. The VMA policy is only applied for memory\n * allocations for a VMA in the VM.\n *\n * Currently there are a few corner cases in swapping where the policy\n * is not applied, but the majority should be handled. When process policy\n * is used it is not remembered over swap outs/swap ins.\n *\n * Only the highest zone in the zone hierarchy gets policied. Allocations\n * requesting a lower zone just use default policy. This implies that\n * on systems with highmem kernel lowmem allocation don't get policied.\n * Same with GFP_DMA allocations.\n *\n * For shmfs/tmpfs/hugetlbfs shared memory the policy is shared between\n * all users and remembered even when nobody has memory mapped.\n */\n\n/* Notebook:\n   fix mmap readahead to honour policy and enable policy for any page cache\n   object\n   statistics for bigpages\n   global policy for page cache? currently it uses process policy. Requires\n   first item above.\n   handle mremap for shared memory (currently ignored for the policy)\n   grows down?\n   make bind policy root only? It can trigger oom much faster and the\n   kernel is not always grateful with that.\n*/\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/mempolicy.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/hugetlb.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/task.h>\n#include <linux/nodemask.h>\n#include <linux/cpuset.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/nsproxy.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/compat.h>\n#include <linux/swap.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/migrate.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/ctype.h>\n#include <linux/mm_inline.h>\n#include <linux/mmu_notifier.h>\n#include <linux/printk.h>\n\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n\n#include \"internal.h\"\n\n/* Internal flags */\n#define MPOL_MF_DISCONTIG_OK (MPOL_MF_INTERNAL << 0)\t/* Skip checks for continuous vmas */\n#define MPOL_MF_INVERT (MPOL_MF_INTERNAL << 1)\t\t/* Invert check for nodemask */\n\nstatic struct kmem_cache *policy_cache;\nstatic struct kmem_cache *sn_cache;\n\n/* Highest zone. An specific allocation for a zone below that is not\n   policied. */\nenum zone_type policy_zone = 0;\n\n/*\n * run-time system-wide default policy => local allocation\n */\nstatic struct mempolicy default_policy = {\n\t.refcnt = ATOMIC_INIT(1), /* never free it */\n\t.mode = MPOL_PREFERRED,\n\t.flags = MPOL_F_LOCAL,\n};\n\nstatic struct mempolicy preferred_node_policy[MAX_NUMNODES];\n\nstruct mempolicy *get_task_policy(struct task_struct *p)\n{\n\tstruct mempolicy *pol = p->mempolicy;\n\tint node;\n\n\tif (pol)\n\t\treturn pol;\n\n\tnode = numa_node_id();\n\tif (node != NUMA_NO_NODE) {\n\t\tpol = &preferred_node_policy[node];\n\t\t/* preferred_node_policy is not initialised early in boot */\n\t\tif (pol->mode)\n\t\t\treturn pol;\n\t}\n\n\treturn &default_policy;\n}\n\nstatic const struct mempolicy_operations {\n\tint (*create)(struct mempolicy *pol, const nodemask_t *nodes);\n\t/*\n\t * If read-side task has no lock to protect task->mempolicy, write-side\n\t * task will rebind the task->mempolicy by two step. The first step is\n\t * setting all the newly nodes, and the second step is cleaning all the\n\t * disallowed nodes. In this way, we can avoid finding no node to alloc\n\t * page.\n\t * If we have a lock to protect task->mempolicy in read-side, we do\n\t * rebind directly.\n\t *\n\t * step:\n\t * \tMPOL_REBIND_ONCE - do rebind work at once\n\t * \tMPOL_REBIND_STEP1 - set all the newly nodes\n\t * \tMPOL_REBIND_STEP2 - clean all the disallowed nodes\n\t */\n\tvoid (*rebind)(struct mempolicy *pol, const nodemask_t *nodes,\n\t\t\tenum mpol_rebind_step step);\n} mpol_ops[MPOL_MAX];\n\nstatic inline int mpol_store_user_nodemask(const struct mempolicy *pol)\n{\n\treturn pol->flags & MPOL_MODE_FLAGS;\n}\n\nstatic void mpol_relative_nodemask(nodemask_t *ret, const nodemask_t *orig,\n\t\t\t\t   const nodemask_t *rel)\n{\n\tnodemask_t tmp;\n\tnodes_fold(tmp, *orig, nodes_weight(*rel));\n\tnodes_onto(*ret, tmp, *rel);\n}\n\nstatic int mpol_new_interleave(struct mempolicy *pol, const nodemask_t *nodes)\n{\n\tif (nodes_empty(*nodes))\n\t\treturn -EINVAL;\n\tpol->v.nodes = *nodes;\n\treturn 0;\n}\n\nstatic int mpol_new_preferred(struct mempolicy *pol, const nodemask_t *nodes)\n{\n\tif (!nodes)\n\t\tpol->flags |= MPOL_F_LOCAL;\t/* local allocation */\n\telse if (nodes_empty(*nodes))\n\t\treturn -EINVAL;\t\t\t/*  no allowed nodes */\n\telse\n\t\tpol->v.preferred_node = first_node(*nodes);\n\treturn 0;\n}\n\nstatic int mpol_new_bind(struct mempolicy *pol, const nodemask_t *nodes)\n{\n\tif (nodes_empty(*nodes))\n\t\treturn -EINVAL;\n\tpol->v.nodes = *nodes;\n\treturn 0;\n}\n\n/*\n * mpol_set_nodemask is called after mpol_new() to set up the nodemask, if\n * any, for the new policy.  mpol_new() has already validated the nodes\n * parameter with respect to the policy mode and flags.  But, we need to\n * handle an empty nodemask with MPOL_PREFERRED here.\n *\n * Must be called holding task's alloc_lock to protect task's mems_allowed\n * and mempolicy.  May also be called holding the mmap_semaphore for write.\n */\nstatic int mpol_set_nodemask(struct mempolicy *pol,\n\t\t     const nodemask_t *nodes, struct nodemask_scratch *nsc)\n{\n\tint ret;\n\n\t/* if mode is MPOL_DEFAULT, pol is NULL. This is right. */\n\tif (pol == NULL)\n\t\treturn 0;\n\t/* Check N_MEMORY */\n\tnodes_and(nsc->mask1,\n\t\t  cpuset_current_mems_allowed, node_states[N_MEMORY]);\n\n\tVM_BUG_ON(!nodes);\n\tif (pol->mode == MPOL_PREFERRED && nodes_empty(*nodes))\n\t\tnodes = NULL;\t/* explicit local allocation */\n\telse {\n\t\tif (pol->flags & MPOL_F_RELATIVE_NODES)\n\t\t\tmpol_relative_nodemask(&nsc->mask2, nodes, &nsc->mask1);\n\t\telse\n\t\t\tnodes_and(nsc->mask2, *nodes, nsc->mask1);\n\n\t\tif (mpol_store_user_nodemask(pol))\n\t\t\tpol->w.user_nodemask = *nodes;\n\t\telse\n\t\t\tpol->w.cpuset_mems_allowed =\n\t\t\t\t\t\tcpuset_current_mems_allowed;\n\t}\n\n\tif (nodes)\n\t\tret = mpol_ops[pol->mode].create(pol, &nsc->mask2);\n\telse\n\t\tret = mpol_ops[pol->mode].create(pol, NULL);\n\treturn ret;\n}\n\n/*\n * This function just creates a new policy, does some check and simple\n * initialization. You must invoke mpol_set_nodemask() to set nodes.\n */\nstatic struct mempolicy *mpol_new(unsigned short mode, unsigned short flags,\n\t\t\t\t  nodemask_t *nodes)\n{\n\tstruct mempolicy *policy;\n\n\tpr_debug(\"setting mode %d flags %d nodes[0] %lx\\n\",\n\t\t mode, flags, nodes ? nodes_addr(*nodes)[0] : NUMA_NO_NODE);\n\n\tif (mode == MPOL_DEFAULT) {\n\t\tif (nodes && !nodes_empty(*nodes))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\treturn NULL;\n\t}\n\tVM_BUG_ON(!nodes);\n\n\t/*\n\t * MPOL_PREFERRED cannot be used with MPOL_F_STATIC_NODES or\n\t * MPOL_F_RELATIVE_NODES if the nodemask is empty (local allocation).\n\t * All other modes require a valid pointer to a non-empty nodemask.\n\t */\n\tif (mode == MPOL_PREFERRED) {\n\t\tif (nodes_empty(*nodes)) {\n\t\t\tif (((flags & MPOL_F_STATIC_NODES) ||\n\t\t\t     (flags & MPOL_F_RELATIVE_NODES)))\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t} else if (mode == MPOL_LOCAL) {\n\t\tif (!nodes_empty(*nodes) ||\n\t\t    (flags & MPOL_F_STATIC_NODES) ||\n\t\t    (flags & MPOL_F_RELATIVE_NODES))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tmode = MPOL_PREFERRED;\n\t} else if (nodes_empty(*nodes))\n\t\treturn ERR_PTR(-EINVAL);\n\tpolicy = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\tif (!policy)\n\t\treturn ERR_PTR(-ENOMEM);\n\tatomic_set(&policy->refcnt, 1);\n\tpolicy->mode = mode;\n\tpolicy->flags = flags;\n\n\treturn policy;\n}\n\n/* Slow path of a mpol destructor. */\nvoid __mpol_put(struct mempolicy *p)\n{\n\tif (!atomic_dec_and_test(&p->refcnt))\n\t\treturn;\n\tkmem_cache_free(policy_cache, p);\n}\n\nstatic void mpol_rebind_default(struct mempolicy *pol, const nodemask_t *nodes,\n\t\t\t\tenum mpol_rebind_step step)\n{\n}\n\n/*\n * step:\n * \tMPOL_REBIND_ONCE  - do rebind work at once\n * \tMPOL_REBIND_STEP1 - set all the newly nodes\n * \tMPOL_REBIND_STEP2 - clean all the disallowed nodes\n */\nstatic void mpol_rebind_nodemask(struct mempolicy *pol, const nodemask_t *nodes,\n\t\t\t\t enum mpol_rebind_step step)\n{\n\tnodemask_t tmp;\n\n\tif (pol->flags & MPOL_F_STATIC_NODES)\n\t\tnodes_and(tmp, pol->w.user_nodemask, *nodes);\n\telse if (pol->flags & MPOL_F_RELATIVE_NODES)\n\t\tmpol_relative_nodemask(&tmp, &pol->w.user_nodemask, nodes);\n\telse {\n\t\t/*\n\t\t * if step == 1, we use ->w.cpuset_mems_allowed to cache the\n\t\t * result\n\t\t */\n\t\tif (step == MPOL_REBIND_ONCE || step == MPOL_REBIND_STEP1) {\n\t\t\tnodes_remap(tmp, pol->v.nodes,\n\t\t\t\t\tpol->w.cpuset_mems_allowed, *nodes);\n\t\t\tpol->w.cpuset_mems_allowed = step ? tmp : *nodes;\n\t\t} else if (step == MPOL_REBIND_STEP2) {\n\t\t\ttmp = pol->w.cpuset_mems_allowed;\n\t\t\tpol->w.cpuset_mems_allowed = *nodes;\n\t\t} else\n\t\t\tBUG();\n\t}\n\n\tif (nodes_empty(tmp))\n\t\ttmp = *nodes;\n\n\tif (step == MPOL_REBIND_STEP1)\n\t\tnodes_or(pol->v.nodes, pol->v.nodes, tmp);\n\telse if (step == MPOL_REBIND_ONCE || step == MPOL_REBIND_STEP2)\n\t\tpol->v.nodes = tmp;\n\telse\n\t\tBUG();\n\n\tif (!node_isset(current->il_next, tmp)) {\n\t\tcurrent->il_next = next_node_in(current->il_next, tmp);\n\t\tif (current->il_next >= MAX_NUMNODES)\n\t\t\tcurrent->il_next = numa_node_id();\n\t}\n}\n\nstatic void mpol_rebind_preferred(struct mempolicy *pol,\n\t\t\t\t  const nodemask_t *nodes,\n\t\t\t\t  enum mpol_rebind_step step)\n{\n\tnodemask_t tmp;\n\n\tif (pol->flags & MPOL_F_STATIC_NODES) {\n\t\tint node = first_node(pol->w.user_nodemask);\n\n\t\tif (node_isset(node, *nodes)) {\n\t\t\tpol->v.preferred_node = node;\n\t\t\tpol->flags &= ~MPOL_F_LOCAL;\n\t\t} else\n\t\t\tpol->flags |= MPOL_F_LOCAL;\n\t} else if (pol->flags & MPOL_F_RELATIVE_NODES) {\n\t\tmpol_relative_nodemask(&tmp, &pol->w.user_nodemask, nodes);\n\t\tpol->v.preferred_node = first_node(tmp);\n\t} else if (!(pol->flags & MPOL_F_LOCAL)) {\n\t\tpol->v.preferred_node = node_remap(pol->v.preferred_node,\n\t\t\t\t\t\t   pol->w.cpuset_mems_allowed,\n\t\t\t\t\t\t   *nodes);\n\t\tpol->w.cpuset_mems_allowed = *nodes;\n\t}\n}\n\n/*\n * mpol_rebind_policy - Migrate a policy to a different set of nodes\n *\n * If read-side task has no lock to protect task->mempolicy, write-side\n * task will rebind the task->mempolicy by two step. The first step is\n * setting all the newly nodes, and the second step is cleaning all the\n * disallowed nodes. In this way, we can avoid finding no node to alloc\n * page.\n * If we have a lock to protect task->mempolicy in read-side, we do\n * rebind directly.\n *\n * step:\n * \tMPOL_REBIND_ONCE  - do rebind work at once\n * \tMPOL_REBIND_STEP1 - set all the newly nodes\n * \tMPOL_REBIND_STEP2 - clean all the disallowed nodes\n */\nstatic void mpol_rebind_policy(struct mempolicy *pol, const nodemask_t *newmask,\n\t\t\t\tenum mpol_rebind_step step)\n{\n\tif (!pol)\n\t\treturn;\n\tif (!mpol_store_user_nodemask(pol) && step == MPOL_REBIND_ONCE &&\n\t    nodes_equal(pol->w.cpuset_mems_allowed, *newmask))\n\t\treturn;\n\n\tif (step == MPOL_REBIND_STEP1 && (pol->flags & MPOL_F_REBINDING))\n\t\treturn;\n\n\tif (step == MPOL_REBIND_STEP2 && !(pol->flags & MPOL_F_REBINDING))\n\t\tBUG();\n\n\tif (step == MPOL_REBIND_STEP1)\n\t\tpol->flags |= MPOL_F_REBINDING;\n\telse if (step == MPOL_REBIND_STEP2)\n\t\tpol->flags &= ~MPOL_F_REBINDING;\n\telse if (step >= MPOL_REBIND_NSTEP)\n\t\tBUG();\n\n\tmpol_ops[pol->mode].rebind(pol, newmask, step);\n}\n\n/*\n * Wrapper for mpol_rebind_policy() that just requires task\n * pointer, and updates task mempolicy.\n *\n * Called with task's alloc_lock held.\n */\n\nvoid mpol_rebind_task(struct task_struct *tsk, const nodemask_t *new,\n\t\t\tenum mpol_rebind_step step)\n{\n\tmpol_rebind_policy(tsk->mempolicy, new, step);\n}\n\n/*\n * Rebind each vma in mm to new nodemask.\n *\n * Call holding a reference to mm.  Takes mm->mmap_sem during call.\n */\n\nvoid mpol_rebind_mm(struct mm_struct *mm, nodemask_t *new)\n{\n\tstruct vm_area_struct *vma;\n\n\tdown_write(&mm->mmap_sem);\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\tmpol_rebind_policy(vma->vm_policy, new, MPOL_REBIND_ONCE);\n\tup_write(&mm->mmap_sem);\n}\n\nstatic const struct mempolicy_operations mpol_ops[MPOL_MAX] = {\n\t[MPOL_DEFAULT] = {\n\t\t.rebind = mpol_rebind_default,\n\t},\n\t[MPOL_INTERLEAVE] = {\n\t\t.create = mpol_new_interleave,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n\t[MPOL_PREFERRED] = {\n\t\t.create = mpol_new_preferred,\n\t\t.rebind = mpol_rebind_preferred,\n\t},\n\t[MPOL_BIND] = {\n\t\t.create = mpol_new_bind,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n};\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstruct queue_pages {\n\tstruct list_head *pagelist;\n\tunsigned long flags;\n\tnodemask_t *nmask;\n\tstruct vm_area_struct *prev;\n};\n\n/*\n * Scan through pages checking if pages follow certain conditions,\n * and move them to the pagelist if they do.\n */\nstatic int queue_pages_pte_range(pmd_t *pmd, unsigned long addr,\n\t\t\tunsigned long end, struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct page *page;\n\tstruct queue_pages *qp = walk->private;\n\tunsigned long flags = qp->flags;\n\tint nid, ret;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tif (pmd_trans_huge(*pmd)) {\n\t\tptl = pmd_lock(walk->mm, pmd);\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tpage = pmd_page(*pmd);\n\t\t\tif (is_huge_zero_page(page)) {\n\t\t\t\tspin_unlock(ptl);\n\t\t\t\t__split_huge_pmd(vma, pmd, addr, false, NULL);\n\t\t\t} else {\n\t\t\t\tget_page(page);\n\t\t\t\tspin_unlock(ptl);\n\t\t\t\tlock_page(page);\n\t\t\t\tret = split_huge_page(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t}\n\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\nretry:\n\tpte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE) {\n\t\tif (!pte_present(*pte))\n\t\t\tcontinue;\n\t\tpage = vm_normal_page(vma, addr, *pte);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\t/*\n\t\t * vm_normal_page() filters out zero pages, but there might\n\t\t * still be PageReserved pages to skip, perhaps in a VDSO.\n\t\t */\n\t\tif (PageReserved(page))\n\t\t\tcontinue;\n\t\tnid = page_to_nid(page);\n\t\tif (node_isset(nid, *qp->nmask) == !!(flags & MPOL_MF_INVERT))\n\t\t\tcontinue;\n\t\tif (PageTransCompound(page)) {\n\t\t\tget_page(page);\n\t\t\tpte_unmap_unlock(pte, ptl);\n\t\t\tlock_page(page);\n\t\t\tret = split_huge_page(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\t/* Failed to split -- skip. */\n\t\t\tif (ret) {\n\t\t\t\tpte = pte_offset_map_lock(walk->mm, pmd,\n\t\t\t\t\t\taddr, &ptl);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto retry;\n\t\t}\n\n\t\tmigrate_page_add(page, qp->pagelist, flags);\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\treturn 0;\n}\n\nstatic int queue_pages_hugetlb(pte_t *pte, unsigned long hmask,\n\t\t\t       unsigned long addr, unsigned long end,\n\t\t\t       struct mm_walk *walk)\n{\n#ifdef CONFIG_HUGETLB_PAGE\n\tstruct queue_pages *qp = walk->private;\n\tunsigned long flags = qp->flags;\n\tint nid;\n\tstruct page *page;\n\tspinlock_t *ptl;\n\tpte_t entry;\n\n\tptl = huge_pte_lock(hstate_vma(walk->vma), walk->mm, pte);\n\tentry = huge_ptep_get(pte);\n\tif (!pte_present(entry))\n\t\tgoto unlock;\n\tpage = pte_page(entry);\n\tnid = page_to_nid(page);\n\tif (node_isset(nid, *qp->nmask) == !!(flags & MPOL_MF_INVERT))\n\t\tgoto unlock;\n\t/* With MPOL_MF_MOVE, we migrate only unshared hugepage. */\n\tif (flags & (MPOL_MF_MOVE_ALL) ||\n\t    (flags & MPOL_MF_MOVE && page_mapcount(page) == 1))\n\t\tisolate_huge_page(page, qp->pagelist);\nunlock:\n\tspin_unlock(ptl);\n#else\n\tBUG();\n#endif\n\treturn 0;\n}\n\n#ifdef CONFIG_NUMA_BALANCING\n/*\n * This is used to mark a range of virtual addresses to be inaccessible.\n * These are later cleared by a NUMA hinting fault. Depending on these\n * faults, pages may be migrated for better NUMA placement.\n *\n * This is assuming that NUMA faults are handled using PROT_NONE. If\n * an architecture makes a different choice, it will need further\n * changes to the core.\n */\nunsigned long change_prot_numa(struct vm_area_struct *vma,\n\t\t\tunsigned long addr, unsigned long end)\n{\n\tint nr_updated;\n\n\tnr_updated = change_protection(vma, addr, end, PAGE_NONE, 0, 1);\n\tif (nr_updated)\n\t\tcount_vm_numa_events(NUMA_PTE_UPDATES, nr_updated);\n\n\treturn nr_updated;\n}\n#else\nstatic unsigned long change_prot_numa(struct vm_area_struct *vma,\n\t\t\tunsigned long addr, unsigned long end)\n{\n\treturn 0;\n}\n#endif /* CONFIG_NUMA_BALANCING */\n\nstatic int queue_pages_test_walk(unsigned long start, unsigned long end,\n\t\t\t\tstruct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct queue_pages *qp = walk->private;\n\tunsigned long endvma = vma->vm_end;\n\tunsigned long flags = qp->flags;\n\n\tif (!vma_migratable(vma))\n\t\treturn 1;\n\n\tif (endvma > end)\n\t\tendvma = end;\n\tif (vma->vm_start > start)\n\t\tstart = vma->vm_start;\n\n\tif (!(flags & MPOL_MF_DISCONTIG_OK)) {\n\t\tif (!vma->vm_next && vma->vm_end < end)\n\t\t\treturn -EFAULT;\n\t\tif (qp->prev && qp->prev->vm_end < vma->vm_start)\n\t\t\treturn -EFAULT;\n\t}\n\n\tqp->prev = vma;\n\n\tif (flags & MPOL_MF_LAZY) {\n\t\t/* Similar to task_numa_work, skip inaccessible VMAs */\n\t\tif (!is_vm_hugetlb_page(vma) &&\n\t\t\t(vma->vm_flags & (VM_READ | VM_EXEC | VM_WRITE)) &&\n\t\t\t!(vma->vm_flags & VM_MIXEDMAP))\n\t\t\tchange_prot_numa(vma, start, endvma);\n\t\treturn 1;\n\t}\n\n\t/* queue pages from current vma */\n\tif (flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL))\n\t\treturn 0;\n\treturn 1;\n}\n\n/*\n * Walk through page tables and collect pages to be migrated.\n *\n * If pages found in a given range are on a set of nodes (determined by\n * @nodes and @flags,) it's isolated and queued to the pagelist which is\n * passed via @private.)\n */\nstatic int\nqueue_pages_range(struct mm_struct *mm, unsigned long start, unsigned long end,\n\t\tnodemask_t *nodes, unsigned long flags,\n\t\tstruct list_head *pagelist)\n{\n\tstruct queue_pages qp = {\n\t\t.pagelist = pagelist,\n\t\t.flags = flags,\n\t\t.nmask = nodes,\n\t\t.prev = NULL,\n\t};\n\tstruct mm_walk queue_pages_walk = {\n\t\t.hugetlb_entry = queue_pages_hugetlb,\n\t\t.pmd_entry = queue_pages_pte_range,\n\t\t.test_walk = queue_pages_test_walk,\n\t\t.mm = mm,\n\t\t.private = &qp,\n\t};\n\n\treturn walk_page_range(start, end, &queue_pages_walk);\n}\n\n/*\n * Apply policy to a single VMA\n * This must be called with the mmap_sem held for writing.\n */\nstatic int vma_replace_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tstruct mempolicy *pol)\n{\n\tint err;\n\tstruct mempolicy *old;\n\tstruct mempolicy *new;\n\n\tpr_debug(\"vma %lx-%lx/%lx vm_ops %p vm_file %p set_policy %p\\n\",\n\t\t vma->vm_start, vma->vm_end, vma->vm_pgoff,\n\t\t vma->vm_ops, vma->vm_file,\n\t\t vma->vm_ops ? vma->vm_ops->set_policy : NULL);\n\n\tnew = mpol_dup(pol);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\tif (vma->vm_ops && vma->vm_ops->set_policy) {\n\t\terr = vma->vm_ops->set_policy(vma, new);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\n\told = vma->vm_policy;\n\tvma->vm_policy = new; /* protected by mmap_sem */\n\tmpol_put(old);\n\n\treturn 0;\n err_out:\n\tmpol_put(new);\n\treturn err;\n}\n\n/* Step 2: apply policy to a range and do splits. */\nstatic int mbind_range(struct mm_struct *mm, unsigned long start,\n\t\t       unsigned long end, struct mempolicy *new_pol)\n{\n\tstruct vm_area_struct *next;\n\tstruct vm_area_struct *prev;\n\tstruct vm_area_struct *vma;\n\tint err = 0;\n\tpgoff_t pgoff;\n\tunsigned long vmstart;\n\tunsigned long vmend;\n\n\tvma = find_vma(mm, start);\n\tif (!vma || vma->vm_start > start)\n\t\treturn -EFAULT;\n\n\tprev = vma->vm_prev;\n\tif (start > vma->vm_start)\n\t\tprev = vma;\n\n\tfor (; vma && vma->vm_start < end; prev = vma, vma = next) {\n\t\tnext = vma->vm_next;\n\t\tvmstart = max(start, vma->vm_start);\n\t\tvmend   = min(end, vma->vm_end);\n\n\t\tif (mpol_equal(vma_policy(vma), new_pol))\n\t\t\tcontinue;\n\n\t\tpgoff = vma->vm_pgoff +\n\t\t\t((vmstart - vma->vm_start) >> PAGE_SHIFT);\n\t\tprev = vma_merge(mm, prev, vmstart, vmend, vma->vm_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, pgoff,\n\t\t\t\t new_pol, vma->vm_userfaultfd_ctx);\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tnext = vma->vm_next;\n\t\t\tif (mpol_equal(vma_policy(vma), new_pol))\n\t\t\t\tcontinue;\n\t\t\t/* vma_merge() joined vma && vma->next, case 8 */\n\t\t\tgoto replace;\n\t\t}\n\t\tif (vma->vm_start != vmstart) {\n\t\t\terr = split_vma(vma->vm_mm, vma, vmstart, 1);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (vma->vm_end != vmend) {\n\t\t\terr = split_vma(vma->vm_mm, vma, vmend, 0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n replace:\n\t\terr = vma_replace_policy(vma, new_pol);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n out:\n\treturn err;\n}\n\n/* Set the process memory policy */\nstatic long do_set_mempolicy(unsigned short mode, unsigned short flags,\n\t\t\t     nodemask_t *nodes)\n{\n\tstruct mempolicy *new, *old;\n\tNODEMASK_SCRATCH(scratch);\n\tint ret;\n\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\tnew = mpol_new(mode, flags, nodes);\n\tif (IS_ERR(new)) {\n\t\tret = PTR_ERR(new);\n\t\tgoto out;\n\t}\n\n\ttask_lock(current);\n\tret = mpol_set_nodemask(new, nodes, scratch);\n\tif (ret) {\n\t\ttask_unlock(current);\n\t\tmpol_put(new);\n\t\tgoto out;\n\t}\n\told = current->mempolicy;\n\tcurrent->mempolicy = new;\n\tif (new && new->mode == MPOL_INTERLEAVE &&\n\t    nodes_weight(new->v.nodes))\n\t\tcurrent->il_next = first_node(new->v.nodes);\n\ttask_unlock(current);\n\tmpol_put(old);\n\tret = 0;\nout:\n\tNODEMASK_SCRATCH_FREE(scratch);\n\treturn ret;\n}\n\n/*\n * Return nodemask for policy for get_mempolicy() query\n *\n * Called with task's alloc_lock held\n */\nstatic void get_policy_nodemask(struct mempolicy *p, nodemask_t *nodes)\n{\n\tnodes_clear(*nodes);\n\tif (p == &default_policy)\n\t\treturn;\n\n\tswitch (p->mode) {\n\tcase MPOL_BIND:\n\t\t/* Fall through */\n\tcase MPOL_INTERLEAVE:\n\t\t*nodes = p->v.nodes;\n\t\tbreak;\n\tcase MPOL_PREFERRED:\n\t\tif (!(p->flags & MPOL_F_LOCAL))\n\t\t\tnode_set(p->v.preferred_node, *nodes);\n\t\t/* else return empty node mask for local allocation */\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic int lookup_node(unsigned long addr)\n{\n\tstruct page *p;\n\tint err;\n\n\terr = get_user_pages(addr & PAGE_MASK, 1, 0, &p, NULL);\n\tif (err >= 0) {\n\t\terr = page_to_nid(p);\n\t\tput_page(p);\n\t}\n\treturn err;\n}\n\n/* Retrieve NUMA policy */\nstatic long do_get_mempolicy(int *policy, nodemask_t *nmask,\n\t\t\t     unsigned long addr, unsigned long flags)\n{\n\tint err;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = NULL;\n\tstruct mempolicy *pol = current->mempolicy;\n\n\tif (flags &\n\t\t~(unsigned long)(MPOL_F_NODE|MPOL_F_ADDR|MPOL_F_MEMS_ALLOWED))\n\t\treturn -EINVAL;\n\n\tif (flags & MPOL_F_MEMS_ALLOWED) {\n\t\tif (flags & (MPOL_F_NODE|MPOL_F_ADDR))\n\t\t\treturn -EINVAL;\n\t\t*policy = 0;\t/* just so it's initialized */\n\t\ttask_lock(current);\n\t\t*nmask  = cpuset_current_mems_allowed;\n\t\ttask_unlock(current);\n\t\treturn 0;\n\t}\n\n\tif (flags & MPOL_F_ADDR) {\n\t\t/*\n\t\t * Do NOT fall back to task policy if the\n\t\t * vma/shared policy at addr is NULL.  We\n\t\t * want to return MPOL_DEFAULT in this case.\n\t\t */\n\t\tdown_read(&mm->mmap_sem);\n\t\tvma = find_vma_intersection(mm, addr, addr+1);\n\t\tif (!vma) {\n\t\t\tup_read(&mm->mmap_sem);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (vma->vm_ops && vma->vm_ops->get_policy)\n\t\t\tpol = vma->vm_ops->get_policy(vma, addr);\n\t\telse\n\t\t\tpol = vma->vm_policy;\n\t} else if (addr)\n\t\treturn -EINVAL;\n\n\tif (!pol)\n\t\tpol = &default_policy;\t/* indicates default behavior */\n\n\tif (flags & MPOL_F_NODE) {\n\t\tif (flags & MPOL_F_ADDR) {\n\t\t\terr = lookup_node(addr);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t\t*policy = err;\n\t\t} else if (pol == current->mempolicy &&\n\t\t\t\tpol->mode == MPOL_INTERLEAVE) {\n\t\t\t*policy = current->il_next;\n\t\t} else {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t*policy = pol == &default_policy ? MPOL_DEFAULT :\n\t\t\t\t\t\tpol->mode;\n\t\t/*\n\t\t * Internal mempolicy flags must be masked off before exposing\n\t\t * the policy to userspace.\n\t\t */\n\t\t*policy |= (pol->flags & MPOL_MODE_FLAGS);\n\t}\n\n\tif (vma) {\n\t\tup_read(&current->mm->mmap_sem);\n\t\tvma = NULL;\n\t}\n\n\terr = 0;\n\tif (nmask) {\n\t\tif (mpol_store_user_nodemask(pol)) {\n\t\t\t*nmask = pol->w.user_nodemask;\n\t\t} else {\n\t\t\ttask_lock(current);\n\t\t\tget_policy_nodemask(pol, nmask);\n\t\t\ttask_unlock(current);\n\t\t}\n\t}\n\n out:\n\tmpol_cond_put(pol);\n\tif (vma)\n\t\tup_read(&current->mm->mmap_sem);\n\treturn err;\n}\n\n#ifdef CONFIG_MIGRATION\n/*\n * page migration\n */\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags)\n{\n\t/*\n\t * Avoid migrating a page that is shared with others.\n\t */\n\tif ((flags & MPOL_MF_MOVE_ALL) || page_mapcount(page) == 1) {\n\t\tif (!isolate_lru_page(page)) {\n\t\t\tlist_add_tail(&page->lru, pagelist);\n\t\t\tinc_node_page_state(page, NR_ISOLATED_ANON +\n\t\t\t\t\t    page_is_file_cache(page));\n\t\t}\n\t}\n}\n\nstatic struct page *new_node_page(struct page *page, unsigned long node, int **x)\n{\n\tif (PageHuge(page))\n\t\treturn alloc_huge_page_node(page_hstate(compound_head(page)),\n\t\t\t\t\tnode);\n\telse\n\t\treturn __alloc_pages_node(node, GFP_HIGHUSER_MOVABLE |\n\t\t\t\t\t\t    __GFP_THISNODE, 0);\n}\n\n/*\n * Migrate pages from one node to a target node.\n * Returns error or the number of pages not migrated.\n */\nstatic int migrate_to_node(struct mm_struct *mm, int source, int dest,\n\t\t\t   int flags)\n{\n\tnodemask_t nmask;\n\tLIST_HEAD(pagelist);\n\tint err = 0;\n\n\tnodes_clear(nmask);\n\tnode_set(source, nmask);\n\n\t/*\n\t * This does not \"check\" the range but isolates all pages that\n\t * need migration.  Between passing in the full user address\n\t * space range and MPOL_MF_DISCONTIG_OK, this call can not fail.\n\t */\n\tVM_BUG_ON(!(flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL)));\n\tqueue_pages_range(mm, mm->mmap->vm_start, mm->task_size, &nmask,\n\t\t\tflags | MPOL_MF_DISCONTIG_OK, &pagelist);\n\n\tif (!list_empty(&pagelist)) {\n\t\terr = migrate_pages(&pagelist, new_node_page, NULL, dest,\n\t\t\t\t\tMIGRATE_SYNC, MR_SYSCALL);\n\t\tif (err)\n\t\t\tputback_movable_pages(&pagelist);\n\t}\n\n\treturn err;\n}\n\n/*\n * Move pages between the two nodesets so as to preserve the physical\n * layout as much as possible.\n *\n * Returns the number of page that could not be moved.\n */\nint do_migrate_pages(struct mm_struct *mm, const nodemask_t *from,\n\t\t     const nodemask_t *to, int flags)\n{\n\tint busy = 0;\n\tint err;\n\tnodemask_t tmp;\n\n\terr = migrate_prep();\n\tif (err)\n\t\treturn err;\n\n\tdown_read(&mm->mmap_sem);\n\n\t/*\n\t * Find a 'source' bit set in 'tmp' whose corresponding 'dest'\n\t * bit in 'to' is not also set in 'tmp'.  Clear the found 'source'\n\t * bit in 'tmp', and return that <source, dest> pair for migration.\n\t * The pair of nodemasks 'to' and 'from' define the map.\n\t *\n\t * If no pair of bits is found that way, fallback to picking some\n\t * pair of 'source' and 'dest' bits that are not the same.  If the\n\t * 'source' and 'dest' bits are the same, this represents a node\n\t * that will be migrating to itself, so no pages need move.\n\t *\n\t * If no bits are left in 'tmp', or if all remaining bits left\n\t * in 'tmp' correspond to the same bit in 'to', return false\n\t * (nothing left to migrate).\n\t *\n\t * This lets us pick a pair of nodes to migrate between, such that\n\t * if possible the dest node is not already occupied by some other\n\t * source node, minimizing the risk of overloading the memory on a\n\t * node that would happen if we migrated incoming memory to a node\n\t * before migrating outgoing memory source that same node.\n\t *\n\t * A single scan of tmp is sufficient.  As we go, we remember the\n\t * most recent <s, d> pair that moved (s != d).  If we find a pair\n\t * that not only moved, but what's better, moved to an empty slot\n\t * (d is not set in tmp), then we break out then, with that pair.\n\t * Otherwise when we finish scanning from_tmp, we at least have the\n\t * most recent <s, d> pair that moved.  If we get all the way through\n\t * the scan of tmp without finding any node that moved, much less\n\t * moved to an empty node, then there is nothing left worth migrating.\n\t */\n\n\ttmp = *from;\n\twhile (!nodes_empty(tmp)) {\n\t\tint s,d;\n\t\tint source = NUMA_NO_NODE;\n\t\tint dest = 0;\n\n\t\tfor_each_node_mask(s, tmp) {\n\n\t\t\t/*\n\t\t\t * do_migrate_pages() tries to maintain the relative\n\t\t\t * node relationship of the pages established between\n\t\t\t * threads and memory areas.\n                         *\n\t\t\t * However if the number of source nodes is not equal to\n\t\t\t * the number of destination nodes we can not preserve\n\t\t\t * this node relative relationship.  In that case, skip\n\t\t\t * copying memory from a node that is in the destination\n\t\t\t * mask.\n\t\t\t *\n\t\t\t * Example: [2,3,4] -> [3,4,5] moves everything.\n\t\t\t *          [0-7] - > [3,4,5] moves only 0,1,2,6,7.\n\t\t\t */\n\n\t\t\tif ((nodes_weight(*from) != nodes_weight(*to)) &&\n\t\t\t\t\t\t(node_isset(s, *to)))\n\t\t\t\tcontinue;\n\n\t\t\td = node_remap(s, *from, *to);\n\t\t\tif (s == d)\n\t\t\t\tcontinue;\n\n\t\t\tsource = s;\t/* Node moved. Memorize */\n\t\t\tdest = d;\n\n\t\t\t/* dest not in remaining from nodes? */\n\t\t\tif (!node_isset(dest, tmp))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (source == NUMA_NO_NODE)\n\t\t\tbreak;\n\n\t\tnode_clear(source, tmp);\n\t\terr = migrate_to_node(mm, source, dest, flags);\n\t\tif (err > 0)\n\t\t\tbusy += err;\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\tup_read(&mm->mmap_sem);\n\tif (err < 0)\n\t\treturn err;\n\treturn busy;\n\n}\n\n/*\n * Allocate a new page for page migration based on vma policy.\n * Start by assuming the page is mapped by the same vma as contains @start.\n * Search forward from there, if not.  N.B., this assumes that the\n * list of pages handed to migrate_pages()--which is how we get here--\n * is in virtual address order.\n */\nstatic struct page *new_page(struct page *page, unsigned long start, int **x)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long uninitialized_var(address);\n\n\tvma = find_vma(current->mm, start);\n\twhile (vma) {\n\t\taddress = page_address_in_vma(page, vma);\n\t\tif (address != -EFAULT)\n\t\t\tbreak;\n\t\tvma = vma->vm_next;\n\t}\n\n\tif (PageHuge(page)) {\n\t\tBUG_ON(!vma);\n\t\treturn alloc_huge_page_noerr(vma, address, 1);\n\t}\n\t/*\n\t * if !vma, alloc_page_vma() will use task or system default policy\n\t */\n\treturn alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);\n}\n#else\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags)\n{\n}\n\nint do_migrate_pages(struct mm_struct *mm, const nodemask_t *from,\n\t\t     const nodemask_t *to, int flags)\n{\n\treturn -ENOSYS;\n}\n\nstatic struct page *new_page(struct page *page, unsigned long start, int **x)\n{\n\treturn NULL;\n}\n#endif\n\nstatic long do_mbind(unsigned long start, unsigned long len,\n\t\t     unsigned short mode, unsigned short mode_flags,\n\t\t     nodemask_t *nmask, unsigned long flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct mempolicy *new;\n\tunsigned long end;\n\tint err;\n\tLIST_HEAD(pagelist);\n\n\tif (flags & ~(unsigned long)MPOL_MF_VALID)\n\t\treturn -EINVAL;\n\tif ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))\n\t\treturn -EPERM;\n\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\n\tif (mode == MPOL_DEFAULT)\n\t\tflags &= ~MPOL_MF_STRICT;\n\n\tlen = (len + PAGE_SIZE - 1) & PAGE_MASK;\n\tend = start + len;\n\n\tif (end < start)\n\t\treturn -EINVAL;\n\tif (end == start)\n\t\treturn 0;\n\n\tnew = mpol_new(mode, mode_flags, nmask);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\tif (flags & MPOL_MF_LAZY)\n\t\tnew->flags |= MPOL_F_MOF;\n\n\t/*\n\t * If we are using the default policy then operation\n\t * on discontinuous address spaces is okay after all\n\t */\n\tif (!new)\n\t\tflags |= MPOL_MF_DISCONTIG_OK;\n\n\tpr_debug(\"mbind %lx-%lx mode:%d flags:%d nodes:%lx\\n\",\n\t\t start, start + len, mode, mode_flags,\n\t\t nmask ? nodes_addr(*nmask)[0] : NUMA_NO_NODE);\n\n\tif (flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL)) {\n\n\t\terr = migrate_prep();\n\t\tif (err)\n\t\t\tgoto mpol_out;\n\t}\n\t{\n\t\tNODEMASK_SCRATCH(scratch);\n\t\tif (scratch) {\n\t\t\tdown_write(&mm->mmap_sem);\n\t\t\ttask_lock(current);\n\t\t\terr = mpol_set_nodemask(new, nmask, scratch);\n\t\t\ttask_unlock(current);\n\t\t\tif (err)\n\t\t\t\tup_write(&mm->mmap_sem);\n\t\t} else\n\t\t\terr = -ENOMEM;\n\t\tNODEMASK_SCRATCH_FREE(scratch);\n\t}\n\tif (err)\n\t\tgoto mpol_out;\n\n\terr = queue_pages_range(mm, start, end, nmask,\n\t\t\t  flags | MPOL_MF_INVERT, &pagelist);\n\tif (!err)\n\t\terr = mbind_range(mm, start, end, new);\n\n\tif (!err) {\n\t\tint nr_failed = 0;\n\n\t\tif (!list_empty(&pagelist)) {\n\t\t\tWARN_ON_ONCE(flags & MPOL_MF_LAZY);\n\t\t\tnr_failed = migrate_pages(&pagelist, new_page, NULL,\n\t\t\t\tstart, MIGRATE_SYNC, MR_MEMPOLICY_MBIND);\n\t\t\tif (nr_failed)\n\t\t\t\tputback_movable_pages(&pagelist);\n\t\t}\n\n\t\tif (nr_failed && (flags & MPOL_MF_STRICT))\n\t\t\terr = -EIO;\n\t} else\n\t\tputback_movable_pages(&pagelist);\n\n\tup_write(&mm->mmap_sem);\n mpol_out:\n\tmpol_put(new);\n\treturn err;\n}\n\n/*\n * User space interface with variable sized bitmaps for nodelists.\n */\n\n/* Copy a node mask from user space. */\nstatic int get_nodes(nodemask_t *nodes, const unsigned long __user *nmask,\n\t\t     unsigned long maxnode)\n{\n\tunsigned long k;\n\tunsigned long nlongs;\n\tunsigned long endmask;\n\n\t--maxnode;\n\tnodes_clear(*nodes);\n\tif (maxnode == 0 || !nmask)\n\t\treturn 0;\n\tif (maxnode > PAGE_SIZE*BITS_PER_BYTE)\n\t\treturn -EINVAL;\n\n\tnlongs = BITS_TO_LONGS(maxnode);\n\tif ((maxnode % BITS_PER_LONG) == 0)\n\t\tendmask = ~0UL;\n\telse\n\t\tendmask = (1UL << (maxnode % BITS_PER_LONG)) - 1;\n\n\t/* When the user specified more nodes than supported just check\n\t   if the non supported part is all zero. */\n\tif (nlongs > BITS_TO_LONGS(MAX_NUMNODES)) {\n\t\tif (nlongs > PAGE_SIZE/sizeof(long))\n\t\t\treturn -EINVAL;\n\t\tfor (k = BITS_TO_LONGS(MAX_NUMNODES); k < nlongs; k++) {\n\t\t\tunsigned long t;\n\t\t\tif (get_user(t, nmask + k))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (k == nlongs - 1) {\n\t\t\t\tif (t & endmask)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t} else if (t)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tnlongs = BITS_TO_LONGS(MAX_NUMNODES);\n\t\tendmask = ~0UL;\n\t}\n\n\tif (copy_from_user(nodes_addr(*nodes), nmask, nlongs*sizeof(unsigned long)))\n\t\treturn -EFAULT;\n\tnodes_addr(*nodes)[nlongs-1] &= endmask;\n\treturn 0;\n}\n\n/* Copy a kernel node mask to user space */\nstatic int copy_nodes_to_user(unsigned long __user *mask, unsigned long maxnode,\n\t\t\t      nodemask_t *nodes)\n{\n\tunsigned long copy = ALIGN(maxnode-1, 64) / 8;\n\tconst int nbytes = BITS_TO_LONGS(MAX_NUMNODES) * sizeof(long);\n\n\tif (copy > nbytes) {\n\t\tif (copy > PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\tif (clear_user((char __user *)mask + nbytes, copy - nbytes))\n\t\t\treturn -EFAULT;\n\t\tcopy = nbytes;\n\t}\n\treturn copy_to_user(mask, nodes_addr(*nodes), copy) ? -EFAULT : 0;\n}\n\nSYSCALL_DEFINE6(mbind, unsigned long, start, unsigned long, len,\n\t\tunsigned long, mode, const unsigned long __user *, nmask,\n\t\tunsigned long, maxnode, unsigned, flags)\n{\n\tnodemask_t nodes;\n\tint err;\n\tunsigned short mode_flags;\n\n\tmode_flags = mode & MPOL_MODE_FLAGS;\n\tmode &= ~MPOL_MODE_FLAGS;\n\tif (mode >= MPOL_MAX)\n\t\treturn -EINVAL;\n\tif ((mode_flags & MPOL_F_STATIC_NODES) &&\n\t    (mode_flags & MPOL_F_RELATIVE_NODES))\n\t\treturn -EINVAL;\n\terr = get_nodes(&nodes, nmask, maxnode);\n\tif (err)\n\t\treturn err;\n\treturn do_mbind(start, len, mode, mode_flags, &nodes, flags);\n}\n\n/* Set the process memory policy */\nSYSCALL_DEFINE3(set_mempolicy, int, mode, const unsigned long __user *, nmask,\n\t\tunsigned long, maxnode)\n{\n\tint err;\n\tnodemask_t nodes;\n\tunsigned short flags;\n\n\tflags = mode & MPOL_MODE_FLAGS;\n\tmode &= ~MPOL_MODE_FLAGS;\n\tif ((unsigned int)mode >= MPOL_MAX)\n\t\treturn -EINVAL;\n\tif ((flags & MPOL_F_STATIC_NODES) && (flags & MPOL_F_RELATIVE_NODES))\n\t\treturn -EINVAL;\n\terr = get_nodes(&nodes, nmask, maxnode);\n\tif (err)\n\t\treturn err;\n\treturn do_set_mempolicy(mode, flags, &nodes);\n}\n\nSYSCALL_DEFINE4(migrate_pages, pid_t, pid, unsigned long, maxnode,\n\t\tconst unsigned long __user *, old_nodes,\n\t\tconst unsigned long __user *, new_nodes)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tstruct mm_struct *mm = NULL;\n\tstruct task_struct *task;\n\tnodemask_t task_nodes;\n\tint err;\n\tnodemask_t *old;\n\tnodemask_t *new;\n\tNODEMASK_SCRATCH(scratch);\n\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\told = &scratch->mask1;\n\tnew = &scratch->mask2;\n\n\terr = get_nodes(old, old_nodes, maxnode);\n\tif (err)\n\t\tgoto out;\n\n\terr = get_nodes(new, new_nodes, maxnode);\n\tif (err)\n\t\tgoto out;\n\n\t/* Find the mm_struct */\n\trcu_read_lock();\n\ttask = pid ? find_task_by_vpid(pid) : current;\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\terr = -ESRCH;\n\t\tgoto out;\n\t}\n\tget_task_struct(task);\n\n\terr = -EINVAL;\n\n\t/*\n\t * Check if this process has the right to modify the specified\n\t * process. The right exists if the process has administrative\n\t * capabilities, superuser privileges or the same\n\t * userid as the target process.\n\t */\n\ttcred = __task_cred(task);\n\tif (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&\n\t    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&\n\t    !capable(CAP_SYS_NICE)) {\n\t\trcu_read_unlock();\n\t\terr = -EPERM;\n\t\tgoto out_put;\n\t}\n\trcu_read_unlock();\n\n\ttask_nodes = cpuset_mems_allowed(task);\n\t/* Is the user allowed to access the target nodes? */\n\tif (!nodes_subset(*new, task_nodes) && !capable(CAP_SYS_NICE)) {\n\t\terr = -EPERM;\n\t\tgoto out_put;\n\t}\n\n\tif (!nodes_subset(*new, node_states[N_MEMORY])) {\n\t\terr = -EINVAL;\n\t\tgoto out_put;\n\t}\n\n\terr = security_task_movememory(task);\n\tif (err)\n\t\tgoto out_put;\n\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\n\tif (!mm) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = do_migrate_pages(mm, old, new,\n\t\tcapable(CAP_SYS_NICE) ? MPOL_MF_MOVE_ALL : MPOL_MF_MOVE);\n\n\tmmput(mm);\nout:\n\tNODEMASK_SCRATCH_FREE(scratch);\n\n\treturn err;\n\nout_put:\n\tput_task_struct(task);\n\tgoto out;\n\n}\n\n\n/* Retrieve NUMA policy */\nSYSCALL_DEFINE5(get_mempolicy, int __user *, policy,\n\t\tunsigned long __user *, nmask, unsigned long, maxnode,\n\t\tunsigned long, addr, unsigned long, flags)\n{\n\tint err;\n\tint uninitialized_var(pval);\n\tnodemask_t nodes;\n\n\tif (nmask != NULL && maxnode < MAX_NUMNODES)\n\t\treturn -EINVAL;\n\n\terr = do_get_mempolicy(&pval, &nodes, addr, flags);\n\n\tif (err)\n\t\treturn err;\n\n\tif (policy && put_user(pval, policy))\n\t\treturn -EFAULT;\n\n\tif (nmask)\n\t\terr = copy_nodes_to_user(nmask, maxnode, &nodes);\n\n\treturn err;\n}\n\n#ifdef CONFIG_COMPAT\n\nCOMPAT_SYSCALL_DEFINE5(get_mempolicy, int __user *, policy,\n\t\t       compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode,\n\t\t       compat_ulong_t, addr, compat_ulong_t, flags)\n{\n\tlong err;\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tDECLARE_BITMAP(bm, MAX_NUMNODES);\n\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\n\tif (nmask)\n\t\tnm = compat_alloc_user_space(alloc_size);\n\n\terr = sys_get_mempolicy(policy, nm, nr_bits+1, addr, flags);\n\n\tif (!err && nmask) {\n\t\tunsigned long copy_size;\n\t\tcopy_size = min_t(unsigned long, sizeof(bm), alloc_size);\n\t\terr = copy_from_user(bm, nm, copy_size);\n\t\t/* ensure entire bitmap is zeroed */\n\t\terr |= clear_user(nmask, ALIGN(maxnode-1, 8) / 8);\n\t\terr |= compat_put_bitmap(nmask, bm, nr_bits);\n\t}\n\n\treturn err;\n}\n\nCOMPAT_SYSCALL_DEFINE3(set_mempolicy, int, mode, compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode)\n{\n\tlong err = 0;\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tDECLARE_BITMAP(bm, MAX_NUMNODES);\n\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\n\tif (nmask) {\n\t\terr = compat_get_bitmap(bm, nmask, nr_bits);\n\t\tnm = compat_alloc_user_space(alloc_size);\n\t\terr |= copy_to_user(nm, bm, alloc_size);\n\t}\n\n\tif (err)\n\t\treturn -EFAULT;\n\n\treturn sys_set_mempolicy(mode, nm, nr_bits+1);\n}\n\nCOMPAT_SYSCALL_DEFINE6(mbind, compat_ulong_t, start, compat_ulong_t, len,\n\t\t       compat_ulong_t, mode, compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode, compat_ulong_t, flags)\n{\n\tlong err = 0;\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tnodemask_t bm;\n\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\n\tif (nmask) {\n\t\terr = compat_get_bitmap(nodes_addr(bm), nmask, nr_bits);\n\t\tnm = compat_alloc_user_space(alloc_size);\n\t\terr |= copy_to_user(nm, nodes_addr(bm), alloc_size);\n\t}\n\n\tif (err)\n\t\treturn -EFAULT;\n\n\treturn sys_mbind(start, len, mode, nm, nr_bits+1, flags);\n}\n\n#endif\n\nstruct mempolicy *__get_vma_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr)\n{\n\tstruct mempolicy *pol = NULL;\n\n\tif (vma) {\n\t\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\t\tpol = vma->vm_ops->get_policy(vma, addr);\n\t\t} else if (vma->vm_policy) {\n\t\t\tpol = vma->vm_policy;\n\n\t\t\t/*\n\t\t\t * shmem_alloc_page() passes MPOL_F_SHARED policy with\n\t\t\t * a pseudo vma whose vma->vm_ops=NULL. Take a reference\n\t\t\t * count on these policies which will be dropped by\n\t\t\t * mpol_cond_put() later\n\t\t\t */\n\t\t\tif (mpol_needs_cond_ref(pol))\n\t\t\t\tmpol_get(pol);\n\t\t}\n\t}\n\n\treturn pol;\n}\n\n/*\n * get_vma_policy(@vma, @addr)\n * @vma: virtual memory area whose policy is sought\n * @addr: address in @vma for shared policy lookup\n *\n * Returns effective policy for a VMA at specified address.\n * Falls back to current->mempolicy or system default policy, as necessary.\n * Shared policies [those marked as MPOL_F_SHARED] require an extra reference\n * count--added by the get_policy() vm_op, as appropriate--to protect against\n * freeing by another task.  It is the caller's responsibility to free the\n * extra reference for shared policies.\n */\nstatic struct mempolicy *get_vma_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr)\n{\n\tstruct mempolicy *pol = __get_vma_policy(vma, addr);\n\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol;\n}\n\nbool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}\n\nstatic int apply_policy_zone(struct mempolicy *policy, enum zone_type zone)\n{\n\tenum zone_type dynamic_policy_zone = policy_zone;\n\n\tBUG_ON(dynamic_policy_zone == ZONE_MOVABLE);\n\n\t/*\n\t * if policy->v.nodes has movable memory only,\n\t * we apply policy when gfp_zone(gfp) = ZONE_MOVABLE only.\n\t *\n\t * policy->v.nodes is intersect with node_states[N_MEMORY].\n\t * so if the following test faile, it implies\n\t * policy->v.nodes has movable memory only.\n\t */\n\tif (!nodes_intersects(policy->v.nodes, node_states[N_HIGH_MEMORY]))\n\t\tdynamic_policy_zone = ZONE_MOVABLE;\n\n\treturn zone >= dynamic_policy_zone;\n}\n\n/*\n * Return a nodemask representing a mempolicy for filtering nodes for\n * page allocation\n */\nstatic nodemask_t *policy_nodemask(gfp_t gfp, struct mempolicy *policy)\n{\n\t/* Lower zones don't get a nodemask applied for MPOL_BIND */\n\tif (unlikely(policy->mode == MPOL_BIND) &&\n\t\t\tapply_policy_zone(policy, gfp_zone(gfp)) &&\n\t\t\tcpuset_nodemask_valid_mems_allowed(&policy->v.nodes))\n\t\treturn &policy->v.nodes;\n\n\treturn NULL;\n}\n\n/* Return a zonelist indicated by gfp for node representing a mempolicy */\nstatic struct zonelist *policy_zonelist(gfp_t gfp, struct mempolicy *policy,\n\tint nd)\n{\n\tif (policy->mode == MPOL_PREFERRED && !(policy->flags & MPOL_F_LOCAL))\n\t\tnd = policy->v.preferred_node;\n\telse {\n\t\t/*\n\t\t * __GFP_THISNODE shouldn't even be used with the bind policy\n\t\t * because we might easily break the expectation to stay on the\n\t\t * requested node and not break the policy.\n\t\t */\n\t\tWARN_ON_ONCE(policy->mode == MPOL_BIND && (gfp & __GFP_THISNODE));\n\t}\n\n\treturn node_zonelist(nd, gfp);\n}\n\n/* Do dynamic interleaving for a process */\nstatic unsigned interleave_nodes(struct mempolicy *policy)\n{\n\tunsigned nid, next;\n\tstruct task_struct *me = current;\n\n\tnid = me->il_next;\n\tnext = next_node_in(nid, policy->v.nodes);\n\tif (next < MAX_NUMNODES)\n\t\tme->il_next = next;\n\treturn nid;\n}\n\n/*\n * Depending on the memory policy provide a node from which to allocate the\n * next slab entry.\n */\nunsigned int mempolicy_slab_node(void)\n{\n\tstruct mempolicy *policy;\n\tint node = numa_mem_id();\n\n\tif (in_interrupt())\n\t\treturn node;\n\n\tpolicy = current->mempolicy;\n\tif (!policy || policy->flags & MPOL_F_LOCAL)\n\t\treturn node;\n\n\tswitch (policy->mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * handled MPOL_F_LOCAL above\n\t\t */\n\t\treturn policy->v.preferred_node;\n\n\tcase MPOL_INTERLEAVE:\n\t\treturn interleave_nodes(policy);\n\n\tcase MPOL_BIND: {\n\t\tstruct zoneref *z;\n\n\t\t/*\n\t\t * Follow bind policy behavior and start allocation at the\n\t\t * first node.\n\t\t */\n\t\tstruct zonelist *zonelist;\n\t\tenum zone_type highest_zoneidx = gfp_zone(GFP_KERNEL);\n\t\tzonelist = &NODE_DATA(node)->node_zonelists[ZONELIST_FALLBACK];\n\t\tz = first_zones_zonelist(zonelist, highest_zoneidx,\n\t\t\t\t\t\t\t&policy->v.nodes);\n\t\treturn z->zone ? z->zone->node : node;\n\t}\n\n\tdefault:\n\t\tBUG();\n\t}\n}\n\n/*\n * Do static interleaving for a VMA with known offset @n.  Returns the n'th\n * node in pol->v.nodes (starting from n=0), wrapping around if n exceeds the\n * number of present nodes.\n */\nstatic unsigned offset_il_node(struct mempolicy *pol,\n\t\t\t       struct vm_area_struct *vma, unsigned long n)\n{\n\tunsigned nnodes = nodes_weight(pol->v.nodes);\n\tunsigned target;\n\tint i;\n\tint nid;\n\n\tif (!nnodes)\n\t\treturn numa_node_id();\n\ttarget = (unsigned int)n % nnodes;\n\tnid = first_node(pol->v.nodes);\n\tfor (i = 0; i < target; i++)\n\t\tnid = next_node(nid, pol->v.nodes);\n\treturn nid;\n}\n\n/* Determine a node number for interleave */\nstatic inline unsigned interleave_nid(struct mempolicy *pol,\n\t\t struct vm_area_struct *vma, unsigned long addr, int shift)\n{\n\tif (vma) {\n\t\tunsigned long off;\n\n\t\t/*\n\t\t * for small pages, there is no difference between\n\t\t * shift and PAGE_SHIFT, so the bit-shift is safe.\n\t\t * for huge pages, since vm_pgoff is in units of small\n\t\t * pages, we need to shift off the always 0 bits to get\n\t\t * a useful offset.\n\t\t */\n\t\tBUG_ON(shift < PAGE_SHIFT);\n\t\toff = vma->vm_pgoff >> (shift - PAGE_SHIFT);\n\t\toff += (addr - vma->vm_start) >> shift;\n\t\treturn offset_il_node(pol, vma, off);\n\t} else\n\t\treturn interleave_nodes(pol);\n}\n\n#ifdef CONFIG_HUGETLBFS\n/*\n * huge_zonelist(@vma, @addr, @gfp_flags, @mpol)\n * @vma: virtual memory area whose policy is sought\n * @addr: address in @vma for shared policy lookup and interleave policy\n * @gfp_flags: for requested zone\n * @mpol: pointer to mempolicy pointer for reference counted mempolicy\n * @nodemask: pointer to nodemask pointer for MPOL_BIND nodemask\n *\n * Returns a zonelist suitable for a huge page allocation and a pointer\n * to the struct mempolicy for conditional unref after allocation.\n * If the effective policy is 'BIND, returns a pointer to the mempolicy's\n * @nodemask for filtering the zonelist.\n *\n * Must be protected by read_mems_allowed_begin()\n */\nstruct zonelist *huge_zonelist(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tgfp_t gfp_flags, struct mempolicy **mpol,\n\t\t\t\tnodemask_t **nodemask)\n{\n\tstruct zonelist *zl;\n\n\t*mpol = get_vma_policy(vma, addr);\n\t*nodemask = NULL;\t/* assume !MPOL_BIND */\n\n\tif (unlikely((*mpol)->mode == MPOL_INTERLEAVE)) {\n\t\tzl = node_zonelist(interleave_nid(*mpol, vma, addr,\n\t\t\t\thuge_page_shift(hstate_vma(vma))), gfp_flags);\n\t} else {\n\t\tzl = policy_zonelist(gfp_flags, *mpol, numa_node_id());\n\t\tif ((*mpol)->mode == MPOL_BIND)\n\t\t\t*nodemask = &(*mpol)->v.nodes;\n\t}\n\treturn zl;\n}\n\n/*\n * init_nodemask_of_mempolicy\n *\n * If the current task's mempolicy is \"default\" [NULL], return 'false'\n * to indicate default policy.  Otherwise, extract the policy nodemask\n * for 'bind' or 'interleave' policy into the argument nodemask, or\n * initialize the argument nodemask to contain the single node for\n * 'preferred' or 'local' policy and return 'true' to indicate presence\n * of non-default mempolicy.\n *\n * We don't bother with reference counting the mempolicy [mpol_get/put]\n * because the current task is examining it's own mempolicy and a task's\n * mempolicy is only ever changed by the task itself.\n *\n * N.B., it is the caller's responsibility to free a returned nodemask.\n */\nbool init_nodemask_of_mempolicy(nodemask_t *mask)\n{\n\tstruct mempolicy *mempolicy;\n\tint nid;\n\n\tif (!(mask && current->mempolicy))\n\t\treturn false;\n\n\ttask_lock(current);\n\tmempolicy = current->mempolicy;\n\tswitch (mempolicy->mode) {\n\tcase MPOL_PREFERRED:\n\t\tif (mempolicy->flags & MPOL_F_LOCAL)\n\t\t\tnid = numa_node_id();\n\t\telse\n\t\t\tnid = mempolicy->v.preferred_node;\n\t\tinit_nodemask_of_node(mask, nid);\n\t\tbreak;\n\n\tcase MPOL_BIND:\n\t\t/* Fall through */\n\tcase MPOL_INTERLEAVE:\n\t\t*mask =  mempolicy->v.nodes;\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\ttask_unlock(current);\n\n\treturn true;\n}\n#endif\n\n/*\n * mempolicy_nodemask_intersects\n *\n * If tsk's mempolicy is \"default\" [NULL], return 'true' to indicate default\n * policy.  Otherwise, check for intersection between mask and the policy\n * nodemask for 'bind' or 'interleave' policy.  For 'perferred' or 'local'\n * policy, always return true since it may allocate elsewhere on fallback.\n *\n * Takes task_lock(tsk) to prevent freeing of its mempolicy.\n */\nbool mempolicy_nodemask_intersects(struct task_struct *tsk,\n\t\t\t\t\tconst nodemask_t *mask)\n{\n\tstruct mempolicy *mempolicy;\n\tbool ret = true;\n\n\tif (!mask)\n\t\treturn ret;\n\ttask_lock(tsk);\n\tmempolicy = tsk->mempolicy;\n\tif (!mempolicy)\n\t\tgoto out;\n\n\tswitch (mempolicy->mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * MPOL_PREFERRED and MPOL_F_LOCAL are only preferred nodes to\n\t\t * allocate from, they may fallback to other nodes when oom.\n\t\t * Thus, it's possible for tsk to have allocated memory from\n\t\t * nodes in mask.\n\t\t */\n\t\tbreak;\n\tcase MPOL_BIND:\n\tcase MPOL_INTERLEAVE:\n\t\tret = nodes_intersects(mempolicy->v.nodes, *mask);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\nout:\n\ttask_unlock(tsk);\n\treturn ret;\n}\n\n/* Allocate a page in interleaved policy.\n   Own path because it needs to do special accounting. */\nstatic struct page *alloc_page_interleave(gfp_t gfp, unsigned order,\n\t\t\t\t\tunsigned nid)\n{\n\tstruct zonelist *zl;\n\tstruct page *page;\n\n\tzl = node_zonelist(nid, gfp);\n\tpage = __alloc_pages(gfp, order, zl);\n\tif (page && page_zone(page) == zonelist_zone(&zl->_zonerefs[0]))\n\t\tinc_zone_page_state(page, NUMA_INTERLEAVE_HIT);\n\treturn page;\n}\n\n/**\n * \talloc_pages_vma\t- Allocate a page for a VMA.\n *\n * \t@gfp:\n *      %GFP_USER    user allocation.\n *      %GFP_KERNEL  kernel allocations,\n *      %GFP_HIGHMEM highmem/user allocations,\n *      %GFP_FS      allocation should not call back into a file system.\n *      %GFP_ATOMIC  don't sleep.\n *\n *\t@order:Order of the GFP allocation.\n * \t@vma:  Pointer to VMA or NULL if not available.\n *\t@addr: Virtual Address of the allocation. Must be inside the VMA.\n *\t@node: Which node to prefer for allocation (modulo policy).\n *\t@hugepage: for hugepages try only the preferred node if possible\n *\n * \tThis function allocates a page from the kernel page pool and applies\n *\ta NUMA policy associated with the VMA or the current process.\n *\tWhen VMA is not NULL caller must hold down_read on the mmap_sem of the\n *\tmm_struct of the VMA to prevent it from going away. Should be used for\n *\tall allocations for pages that will be mapped into user space. Returns\n *\tNULL when no page can be allocated.\n */\nstruct page *\nalloc_pages_vma(gfp_t gfp, int order, struct vm_area_struct *vma,\n\t\tunsigned long addr, int node, bool hugepage)\n{\n\tstruct mempolicy *pol;\n\tstruct page *page;\n\tunsigned int cpuset_mems_cookie;\n\tstruct zonelist *zl;\n\tnodemask_t *nmask;\n\nretry_cpuset:\n\tpol = get_vma_policy(vma, addr);\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\n\tif (pol->mode == MPOL_INTERLEAVE) {\n\t\tunsigned nid;\n\n\t\tnid = interleave_nid(pol, vma, addr, PAGE_SHIFT + order);\n\t\tmpol_cond_put(pol);\n\t\tpage = alloc_page_interleave(gfp, order, nid);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE) && hugepage)) {\n\t\tint hpage_node = node;\n\n\t\t/*\n\t\t * For hugepage allocation and non-interleave policy which\n\t\t * allows the current node (or other explicitly preferred\n\t\t * node) we only try to allocate from the current/preferred\n\t\t * node and don't fall back to other nodes, as the cost of\n\t\t * remote accesses would likely offset THP benefits.\n\t\t *\n\t\t * If the policy is interleave, or does not allow the current\n\t\t * node in its nodemask, we allocate the standard way.\n\t\t */\n\t\tif (pol->mode == MPOL_PREFERRED &&\n\t\t\t\t\t\t!(pol->flags & MPOL_F_LOCAL))\n\t\t\thpage_node = pol->v.preferred_node;\n\n\t\tnmask = policy_nodemask(gfp, pol);\n\t\tif (!nmask || node_isset(hpage_node, *nmask)) {\n\t\t\tmpol_cond_put(pol);\n\t\t\tpage = __alloc_pages_node(hpage_node,\n\t\t\t\t\t\tgfp | __GFP_THISNODE, order);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnmask = policy_nodemask(gfp, pol);\n\tzl = policy_zonelist(gfp, pol, node);\n\tpage = __alloc_pages_nodemask(gfp, order, zl, nmask);\n\tmpol_cond_put(pol);\nout:\n\tif (unlikely(!page && read_mems_allowed_retry(cpuset_mems_cookie)))\n\t\tgoto retry_cpuset;\n\treturn page;\n}\n\n/**\n * \talloc_pages_current - Allocate pages.\n *\n *\t@gfp:\n *\t\t%GFP_USER   user allocation,\n *      \t%GFP_KERNEL kernel allocation,\n *      \t%GFP_HIGHMEM highmem allocation,\n *      \t%GFP_FS     don't call back into a file system.\n *      \t%GFP_ATOMIC don't sleep.\n *\t@order: Power of two of allocation size in pages. 0 is a single page.\n *\n *\tAllocate a page from the kernel page pool.  When not in\n *\tinterrupt context and apply the current process NUMA policy.\n *\tReturns NULL when no page can be allocated.\n *\n *\tDon't call cpuset_update_task_memory_state() unless\n *\t1) it's ok to take cpuset_sem (can WAIT), and\n *\t2) allocating for current task (not interrupt).\n */\nstruct page *alloc_pages_current(gfp_t gfp, unsigned order)\n{\n\tstruct mempolicy *pol = &default_policy;\n\tstruct page *page;\n\tunsigned int cpuset_mems_cookie;\n\n\tif (!in_interrupt() && !(gfp & __GFP_THISNODE))\n\t\tpol = get_task_policy(current);\n\nretry_cpuset:\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\n\t/*\n\t * No reference counting needed for current->mempolicy\n\t * nor system default_policy\n\t */\n\tif (pol->mode == MPOL_INTERLEAVE)\n\t\tpage = alloc_page_interleave(gfp, order, interleave_nodes(pol));\n\telse\n\t\tpage = __alloc_pages_nodemask(gfp, order,\n\t\t\t\tpolicy_zonelist(gfp, pol, numa_node_id()),\n\t\t\t\tpolicy_nodemask(gfp, pol));\n\n\tif (unlikely(!page && read_mems_allowed_retry(cpuset_mems_cookie)))\n\t\tgoto retry_cpuset;\n\n\treturn page;\n}\nEXPORT_SYMBOL(alloc_pages_current);\n\nint vma_dup_policy(struct vm_area_struct *src, struct vm_area_struct *dst)\n{\n\tstruct mempolicy *pol = mpol_dup(vma_policy(src));\n\n\tif (IS_ERR(pol))\n\t\treturn PTR_ERR(pol);\n\tdst->vm_policy = pol;\n\treturn 0;\n}\n\n/*\n * If mpol_dup() sees current->cpuset == cpuset_being_rebound, then it\n * rebinds the mempolicy its copying by calling mpol_rebind_policy()\n * with the mems_allowed returned by cpuset_mems_allowed().  This\n * keeps mempolicies cpuset relative after its cpuset moves.  See\n * further kernel/cpuset.c update_nodemask().\n *\n * current's mempolicy may be rebinded by the other task(the task that changes\n * cpuset's mems), so we needn't do rebind work for current task.\n */\n\n/* Slow path of a mempolicy duplicate */\nstruct mempolicy *__mpol_dup(struct mempolicy *old)\n{\n\tstruct mempolicy *new = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\n\tif (!new)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* task's mempolicy is protected by alloc_lock */\n\tif (old == current->mempolicy) {\n\t\ttask_lock(current);\n\t\t*new = *old;\n\t\ttask_unlock(current);\n\t} else\n\t\t*new = *old;\n\n\tif (current_cpuset_is_being_rebound()) {\n\t\tnodemask_t mems = cpuset_mems_allowed(current);\n\t\tif (new->flags & MPOL_F_REBINDING)\n\t\t\tmpol_rebind_policy(new, &mems, MPOL_REBIND_STEP2);\n\t\telse\n\t\t\tmpol_rebind_policy(new, &mems, MPOL_REBIND_ONCE);\n\t}\n\tatomic_set(&new->refcnt, 1);\n\treturn new;\n}\n\n/* Slow path of a mempolicy comparison */\nbool __mpol_equal(struct mempolicy *a, struct mempolicy *b)\n{\n\tif (!a || !b)\n\t\treturn false;\n\tif (a->mode != b->mode)\n\t\treturn false;\n\tif (a->flags != b->flags)\n\t\treturn false;\n\tif (mpol_store_user_nodemask(a))\n\t\tif (!nodes_equal(a->w.user_nodemask, b->w.user_nodemask))\n\t\t\treturn false;\n\n\tswitch (a->mode) {\n\tcase MPOL_BIND:\n\t\t/* Fall through */\n\tcase MPOL_INTERLEAVE:\n\t\treturn !!nodes_equal(a->v.nodes, b->v.nodes);\n\tcase MPOL_PREFERRED:\n\t\treturn a->v.preferred_node == b->v.preferred_node;\n\tdefault:\n\t\tBUG();\n\t\treturn false;\n\t}\n}\n\n/*\n * Shared memory backing store policy support.\n *\n * Remember policies even when nobody has shared memory mapped.\n * The policies are kept in Red-Black tree linked from the inode.\n * They are protected by the sp->lock rwlock, which should be held\n * for any accesses to the tree.\n */\n\n/*\n * lookup first element intersecting start-end.  Caller holds sp->lock for\n * reading or for writing\n */\nstatic struct sp_node *\nsp_lookup(struct shared_policy *sp, unsigned long start, unsigned long end)\n{\n\tstruct rb_node *n = sp->root.rb_node;\n\n\twhile (n) {\n\t\tstruct sp_node *p = rb_entry(n, struct sp_node, nd);\n\n\t\tif (start >= p->end)\n\t\t\tn = n->rb_right;\n\t\telse if (end <= p->start)\n\t\t\tn = n->rb_left;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!n)\n\t\treturn NULL;\n\tfor (;;) {\n\t\tstruct sp_node *w = NULL;\n\t\tstruct rb_node *prev = rb_prev(n);\n\t\tif (!prev)\n\t\t\tbreak;\n\t\tw = rb_entry(prev, struct sp_node, nd);\n\t\tif (w->end <= start)\n\t\t\tbreak;\n\t\tn = prev;\n\t}\n\treturn rb_entry(n, struct sp_node, nd);\n}\n\n/*\n * Insert a new shared policy into the list.  Caller holds sp->lock for\n * writing.\n */\nstatic void sp_insert(struct shared_policy *sp, struct sp_node *new)\n{\n\tstruct rb_node **p = &sp->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct sp_node *nd;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tnd = rb_entry(parent, struct sp_node, nd);\n\t\tif (new->start < nd->start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new->end > nd->end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\trb_link_node(&new->nd, parent, p);\n\trb_insert_color(&new->nd, &sp->root);\n\tpr_debug(\"inserting %lx-%lx: %d\\n\", new->start, new->end,\n\t\t new->policy ? new->policy->mode : 0);\n}\n\n/* Find shared policy intersecting idx */\nstruct mempolicy *\nmpol_shared_policy_lookup(struct shared_policy *sp, unsigned long idx)\n{\n\tstruct mempolicy *pol = NULL;\n\tstruct sp_node *sn;\n\n\tif (!sp->root.rb_node)\n\t\treturn NULL;\n\tread_lock(&sp->lock);\n\tsn = sp_lookup(sp, idx, idx+1);\n\tif (sn) {\n\t\tmpol_get(sn->policy);\n\t\tpol = sn->policy;\n\t}\n\tread_unlock(&sp->lock);\n\treturn pol;\n}\n\nstatic void sp_free(struct sp_node *n)\n{\n\tmpol_put(n->policy);\n\tkmem_cache_free(sn_cache, n);\n}\n\n/**\n * mpol_misplaced - check whether current page node is valid in policy\n *\n * @page: page to be checked\n * @vma: vm area where page mapped\n * @addr: virtual address where page mapped\n *\n * Lookup current policy node id for vma,addr and \"compare to\" page's\n * node id.\n *\n * Returns:\n *\t-1\t- not misplaced, page is in the right node\n *\tnode\t- node id where the page should be\n *\n * Policy determination \"mimics\" alloc_page_vma().\n * Called from fault path where we know the vma and faulting address.\n */\nint mpol_misplaced(struct page *page, struct vm_area_struct *vma, unsigned long addr)\n{\n\tstruct mempolicy *pol;\n\tstruct zoneref *z;\n\tint curnid = page_to_nid(page);\n\tunsigned long pgoff;\n\tint thiscpu = raw_smp_processor_id();\n\tint thisnid = cpu_to_node(thiscpu);\n\tint polnid = -1;\n\tint ret = -1;\n\n\tBUG_ON(!vma);\n\n\tpol = get_vma_policy(vma, addr);\n\tif (!(pol->flags & MPOL_F_MOF))\n\t\tgoto out;\n\n\tswitch (pol->mode) {\n\tcase MPOL_INTERLEAVE:\n\t\tBUG_ON(addr >= vma->vm_end);\n\t\tBUG_ON(addr < vma->vm_start);\n\n\t\tpgoff = vma->vm_pgoff;\n\t\tpgoff += (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\tpolnid = offset_il_node(pol, vma, pgoff);\n\t\tbreak;\n\n\tcase MPOL_PREFERRED:\n\t\tif (pol->flags & MPOL_F_LOCAL)\n\t\t\tpolnid = numa_node_id();\n\t\telse\n\t\t\tpolnid = pol->v.preferred_node;\n\t\tbreak;\n\n\tcase MPOL_BIND:\n\n\t\t/*\n\t\t * allows binding to multiple nodes.\n\t\t * use current page if in policy nodemask,\n\t\t * else select nearest allowed node, if any.\n\t\t * If no allowed nodes, use current [!misplaced].\n\t\t */\n\t\tif (node_isset(curnid, pol->v.nodes))\n\t\t\tgoto out;\n\t\tz = first_zones_zonelist(\n\t\t\t\tnode_zonelist(numa_node_id(), GFP_HIGHUSER),\n\t\t\t\tgfp_zone(GFP_HIGHUSER),\n\t\t\t\t&pol->v.nodes);\n\t\tpolnid = z->zone->node;\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/* Migrate the page towards the node whose CPU is referencing it */\n\tif (pol->flags & MPOL_F_MORON) {\n\t\tpolnid = thisnid;\n\n\t\tif (!should_numa_migrate_memory(current, page, curnid, thiscpu))\n\t\t\tgoto out;\n\t}\n\n\tif (curnid != polnid)\n\t\tret = polnid;\nout:\n\tmpol_cond_put(pol);\n\n\treturn ret;\n}\n\n/*\n * Drop the (possibly final) reference to task->mempolicy.  It needs to be\n * dropped after task->mempolicy is set to NULL so that any allocation done as\n * part of its kmem_cache_free(), such as by KASAN, doesn't reference a freed\n * policy.\n */\nvoid mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}\n\nstatic void sp_delete(struct shared_policy *sp, struct sp_node *n)\n{\n\tpr_debug(\"deleting %lx-l%lx\\n\", n->start, n->end);\n\trb_erase(&n->nd, &sp->root);\n\tsp_free(n);\n}\n\nstatic void sp_node_init(struct sp_node *node, unsigned long start,\n\t\t\tunsigned long end, struct mempolicy *pol)\n{\n\tnode->start = start;\n\tnode->end = end;\n\tnode->policy = pol;\n}\n\nstatic struct sp_node *sp_alloc(unsigned long start, unsigned long end,\n\t\t\t\tstruct mempolicy *pol)\n{\n\tstruct sp_node *n;\n\tstruct mempolicy *newpol;\n\n\tn = kmem_cache_alloc(sn_cache, GFP_KERNEL);\n\tif (!n)\n\t\treturn NULL;\n\n\tnewpol = mpol_dup(pol);\n\tif (IS_ERR(newpol)) {\n\t\tkmem_cache_free(sn_cache, n);\n\t\treturn NULL;\n\t}\n\tnewpol->flags |= MPOL_F_SHARED;\n\tsp_node_init(n, start, end, newpol);\n\n\treturn n;\n}\n\n/* Replace a policy range. */\nstatic int shared_policy_replace(struct shared_policy *sp, unsigned long start,\n\t\t\t\t unsigned long end, struct sp_node *new)\n{\n\tstruct sp_node *n;\n\tstruct sp_node *n_new = NULL;\n\tstruct mempolicy *mpol_new = NULL;\n\tint ret = 0;\n\nrestart:\n\twrite_lock(&sp->lock);\n\tn = sp_lookup(sp, start, end);\n\t/* Take care of old policies in the same range. */\n\twhile (n && n->start < end) {\n\t\tstruct rb_node *next = rb_next(&n->nd);\n\t\tif (n->start >= start) {\n\t\t\tif (n->end <= end)\n\t\t\t\tsp_delete(sp, n);\n\t\t\telse\n\t\t\t\tn->start = end;\n\t\t} else {\n\t\t\t/* Old policy spanning whole new range. */\n\t\t\tif (n->end > end) {\n\t\t\t\tif (!n_new)\n\t\t\t\t\tgoto alloc_new;\n\n\t\t\t\t*mpol_new = *n->policy;\n\t\t\t\tatomic_set(&mpol_new->refcnt, 1);\n\t\t\t\tsp_node_init(n_new, end, n->end, mpol_new);\n\t\t\t\tn->end = start;\n\t\t\t\tsp_insert(sp, n_new);\n\t\t\t\tn_new = NULL;\n\t\t\t\tmpol_new = NULL;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tn->end = start;\n\t\t}\n\t\tif (!next)\n\t\t\tbreak;\n\t\tn = rb_entry(next, struct sp_node, nd);\n\t}\n\tif (new)\n\t\tsp_insert(sp, new);\n\twrite_unlock(&sp->lock);\n\tret = 0;\n\nerr_out:\n\tif (mpol_new)\n\t\tmpol_put(mpol_new);\n\tif (n_new)\n\t\tkmem_cache_free(sn_cache, n_new);\n\n\treturn ret;\n\nalloc_new:\n\twrite_unlock(&sp->lock);\n\tret = -ENOMEM;\n\tn_new = kmem_cache_alloc(sn_cache, GFP_KERNEL);\n\tif (!n_new)\n\t\tgoto err_out;\n\tmpol_new = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\tif (!mpol_new)\n\t\tgoto err_out;\n\tgoto restart;\n}\n\n/**\n * mpol_shared_policy_init - initialize shared policy for inode\n * @sp: pointer to inode shared policy\n * @mpol:  struct mempolicy to install\n *\n * Install non-NULL @mpol in inode's shared policy rb-tree.\n * On entry, the current task has a reference on a non-NULL @mpol.\n * This must be released on exit.\n * This is called at get_inode() calls and we can use GFP_KERNEL.\n */\nvoid mpol_shared_policy_init(struct shared_policy *sp, struct mempolicy *mpol)\n{\n\tint ret;\n\n\tsp->root = RB_ROOT;\t\t/* empty tree == default mempolicy */\n\trwlock_init(&sp->lock);\n\n\tif (mpol) {\n\t\tstruct vm_area_struct pvma;\n\t\tstruct mempolicy *new;\n\t\tNODEMASK_SCRATCH(scratch);\n\n\t\tif (!scratch)\n\t\t\tgoto put_mpol;\n\t\t/* contextualize the tmpfs mount point mempolicy */\n\t\tnew = mpol_new(mpol->mode, mpol->flags, &mpol->w.user_nodemask);\n\t\tif (IS_ERR(new))\n\t\t\tgoto free_scratch; /* no valid nodemask intersection */\n\n\t\ttask_lock(current);\n\t\tret = mpol_set_nodemask(new, &mpol->w.user_nodemask, scratch);\n\t\ttask_unlock(current);\n\t\tif (ret)\n\t\t\tgoto put_new;\n\n\t\t/* Create pseudo-vma that contains just the policy */\n\t\tmemset(&pvma, 0, sizeof(struct vm_area_struct));\n\t\tpvma.vm_end = TASK_SIZE;\t/* policy covers entire file */\n\t\tmpol_set_shared_policy(sp, &pvma, new); /* adds ref */\n\nput_new:\n\t\tmpol_put(new);\t\t\t/* drop initial ref */\nfree_scratch:\n\t\tNODEMASK_SCRATCH_FREE(scratch);\nput_mpol:\n\t\tmpol_put(mpol);\t/* drop our incoming ref on sb mpol */\n\t}\n}\n\nint mpol_set_shared_policy(struct shared_policy *info,\n\t\t\tstruct vm_area_struct *vma, struct mempolicy *npol)\n{\n\tint err;\n\tstruct sp_node *new = NULL;\n\tunsigned long sz = vma_pages(vma);\n\n\tpr_debug(\"set_shared_policy %lx sz %lu %d %d %lx\\n\",\n\t\t vma->vm_pgoff,\n\t\t sz, npol ? npol->mode : -1,\n\t\t npol ? npol->flags : -1,\n\t\t npol ? nodes_addr(npol->v.nodes)[0] : NUMA_NO_NODE);\n\n\tif (npol) {\n\t\tnew = sp_alloc(vma->vm_pgoff, vma->vm_pgoff + sz, npol);\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t}\n\terr = shared_policy_replace(info, vma->vm_pgoff, vma->vm_pgoff+sz, new);\n\tif (err && new)\n\t\tsp_free(new);\n\treturn err;\n}\n\n/* Free a backing policy store on inode delete. */\nvoid mpol_free_shared_policy(struct shared_policy *p)\n{\n\tstruct sp_node *n;\n\tstruct rb_node *next;\n\n\tif (!p->root.rb_node)\n\t\treturn;\n\twrite_lock(&p->lock);\n\tnext = rb_first(&p->root);\n\twhile (next) {\n\t\tn = rb_entry(next, struct sp_node, nd);\n\t\tnext = rb_next(&n->nd);\n\t\tsp_delete(p, n);\n\t}\n\twrite_unlock(&p->lock);\n}\n\n#ifdef CONFIG_NUMA_BALANCING\nstatic int __initdata numabalancing_override;\n\nstatic void __init check_numabalancing_enable(void)\n{\n\tbool numabalancing_default = false;\n\n\tif (IS_ENABLED(CONFIG_NUMA_BALANCING_DEFAULT_ENABLED))\n\t\tnumabalancing_default = true;\n\n\t/* Parsed by setup_numabalancing. override == 1 enables, -1 disables */\n\tif (numabalancing_override)\n\t\tset_numabalancing_state(numabalancing_override == 1);\n\n\tif (num_online_nodes() > 1 && !numabalancing_override) {\n\t\tpr_info(\"%s automatic NUMA balancing. Configure with numa_balancing= or the kernel.numa_balancing sysctl\\n\",\n\t\t\tnumabalancing_default ? \"Enabling\" : \"Disabling\");\n\t\tset_numabalancing_state(numabalancing_default);\n\t}\n}\n\nstatic int __init setup_numabalancing(char *str)\n{\n\tint ret = 0;\n\tif (!str)\n\t\tgoto out;\n\n\tif (!strcmp(str, \"enable\")) {\n\t\tnumabalancing_override = 1;\n\t\tret = 1;\n\t} else if (!strcmp(str, \"disable\")) {\n\t\tnumabalancing_override = -1;\n\t\tret = 1;\n\t}\nout:\n\tif (!ret)\n\t\tpr_warn(\"Unable to parse numa_balancing=\\n\");\n\n\treturn ret;\n}\n__setup(\"numa_balancing=\", setup_numabalancing);\n#else\nstatic inline void __init check_numabalancing_enable(void)\n{\n}\n#endif /* CONFIG_NUMA_BALANCING */\n\n/* assumes fs == KERNEL_DS */\nvoid __init numa_policy_init(void)\n{\n\tnodemask_t interleave_nodes;\n\tunsigned long largest = 0;\n\tint nid, prefer = 0;\n\n\tpolicy_cache = kmem_cache_create(\"numa_policy\",\n\t\t\t\t\t sizeof(struct mempolicy),\n\t\t\t\t\t 0, SLAB_PANIC, NULL);\n\n\tsn_cache = kmem_cache_create(\"shared_policy_node\",\n\t\t\t\t     sizeof(struct sp_node),\n\t\t\t\t     0, SLAB_PANIC, NULL);\n\n\tfor_each_node(nid) {\n\t\tpreferred_node_policy[nid] = (struct mempolicy) {\n\t\t\t.refcnt = ATOMIC_INIT(1),\n\t\t\t.mode = MPOL_PREFERRED,\n\t\t\t.flags = MPOL_F_MOF | MPOL_F_MORON,\n\t\t\t.v = { .preferred_node = nid, },\n\t\t};\n\t}\n\n\t/*\n\t * Set interleaving policy for system init. Interleaving is only\n\t * enabled across suitably sized nodes (default is >= 16MB), or\n\t * fall back to the largest node if they're all smaller.\n\t */\n\tnodes_clear(interleave_nodes);\n\tfor_each_node_state(nid, N_MEMORY) {\n\t\tunsigned long total_pages = node_present_pages(nid);\n\n\t\t/* Preserve the largest node */\n\t\tif (largest < total_pages) {\n\t\t\tlargest = total_pages;\n\t\t\tprefer = nid;\n\t\t}\n\n\t\t/* Interleave this node? */\n\t\tif ((total_pages << PAGE_SHIFT) >= (16 << 20))\n\t\t\tnode_set(nid, interleave_nodes);\n\t}\n\n\t/* All too small, use the largest */\n\tif (unlikely(nodes_empty(interleave_nodes)))\n\t\tnode_set(prefer, interleave_nodes);\n\n\tif (do_set_mempolicy(MPOL_INTERLEAVE, 0, &interleave_nodes))\n\t\tpr_err(\"%s: interleaving failed\\n\", __func__);\n\n\tcheck_numabalancing_enable();\n}\n\n/* Reset policy of current process to default */\nvoid numa_default_policy(void)\n{\n\tdo_set_mempolicy(MPOL_DEFAULT, 0, NULL);\n}\n\n/*\n * Parse and format mempolicy from/to strings\n */\n\n/*\n * \"local\" is implemented internally by MPOL_PREFERRED with MPOL_F_LOCAL flag.\n */\nstatic const char * const policy_modes[] =\n{\n\t[MPOL_DEFAULT]    = \"default\",\n\t[MPOL_PREFERRED]  = \"prefer\",\n\t[MPOL_BIND]       = \"bind\",\n\t[MPOL_INTERLEAVE] = \"interleave\",\n\t[MPOL_LOCAL]      = \"local\",\n};\n\n\n#ifdef CONFIG_TMPFS\n/**\n * mpol_parse_str - parse string to mempolicy, for tmpfs mpol mount option.\n * @str:  string containing mempolicy to parse\n * @mpol:  pointer to struct mempolicy pointer, returned on success.\n *\n * Format of input:\n *\t<mode>[=<flags>][:<nodelist>]\n *\n * On success, returns 0, else 1\n */\nint mpol_parse_str(char *str, struct mempolicy **mpol)\n{\n\tstruct mempolicy *new = NULL;\n\tunsigned short mode;\n\tunsigned short mode_flags;\n\tnodemask_t nodes;\n\tchar *nodelist = strchr(str, ':');\n\tchar *flags = strchr(str, '=');\n\tint err = 1;\n\n\tif (nodelist) {\n\t\t/* NUL-terminate mode or flags string */\n\t\t*nodelist++ = '\\0';\n\t\tif (nodelist_parse(nodelist, nodes))\n\t\t\tgoto out;\n\t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))\n\t\t\tgoto out;\n\t} else\n\t\tnodes_clear(nodes);\n\n\tif (flags)\n\t\t*flags++ = '\\0';\t/* terminate mode string */\n\n\tfor (mode = 0; mode < MPOL_MAX; mode++) {\n\t\tif (!strcmp(str, policy_modes[mode])) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mode >= MPOL_MAX)\n\t\tgoto out;\n\n\tswitch (mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * Insist on a nodelist of one node only\n\t\t */\n\t\tif (nodelist) {\n\t\t\tchar *rest = nodelist;\n\t\t\twhile (isdigit(*rest))\n\t\t\t\trest++;\n\t\t\tif (*rest)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase MPOL_INTERLEAVE:\n\t\t/*\n\t\t * Default to online nodes with memory if no nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\tnodes = node_states[N_MEMORY];\n\t\tbreak;\n\tcase MPOL_LOCAL:\n\t\t/*\n\t\t * Don't allow a nodelist;  mpol_new() checks flags\n\t\t */\n\t\tif (nodelist)\n\t\t\tgoto out;\n\t\tmode = MPOL_PREFERRED;\n\t\tbreak;\n\tcase MPOL_DEFAULT:\n\t\t/*\n\t\t * Insist on a empty nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\terr = 0;\n\t\tgoto out;\n\tcase MPOL_BIND:\n\t\t/*\n\t\t * Insist on a nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\tgoto out;\n\t}\n\n\tmode_flags = 0;\n\tif (flags) {\n\t\t/*\n\t\t * Currently, we only support two mutually exclusive\n\t\t * mode flags.\n\t\t */\n\t\tif (!strcmp(flags, \"static\"))\n\t\t\tmode_flags |= MPOL_F_STATIC_NODES;\n\t\telse if (!strcmp(flags, \"relative\"))\n\t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;\n\t\telse\n\t\t\tgoto out;\n\t}\n\n\tnew = mpol_new(mode, mode_flags, &nodes);\n\tif (IS_ERR(new))\n\t\tgoto out;\n\n\t/*\n\t * Save nodes for mpol_to_str() to show the tmpfs mount options\n\t * for /proc/mounts, /proc/pid/mounts and /proc/pid/mountinfo.\n\t */\n\tif (mode != MPOL_PREFERRED)\n\t\tnew->v.nodes = nodes;\n\telse if (nodelist)\n\t\tnew->v.preferred_node = first_node(nodes);\n\telse\n\t\tnew->flags |= MPOL_F_LOCAL;\n\n\t/*\n\t * Save nodes for contextualization: this will be used to \"clone\"\n\t * the mempolicy in a specific context [cpuset] at a later time.\n\t */\n\tnew->w.user_nodemask = nodes;\n\n\terr = 0;\n\nout:\n\t/* Restore string for error message */\n\tif (nodelist)\n\t\t*--nodelist = ':';\n\tif (flags)\n\t\t*--flags = '=';\n\tif (!err)\n\t\t*mpol = new;\n\treturn err;\n}\n#endif /* CONFIG_TMPFS */\n\n/**\n * mpol_to_str - format a mempolicy structure for printing\n * @buffer:  to contain formatted mempolicy string\n * @maxlen:  length of @buffer\n * @pol:  pointer to mempolicy to be formatted\n *\n * Convert @pol into a string.  If @buffer is too short, truncate the string.\n * Recommend a @maxlen of at least 32 for the longest mode, \"interleave\", the\n * longest flag, \"relative\", and to display at least a few node ids.\n */\nvoid mpol_to_str(char *buffer, int maxlen, struct mempolicy *pol)\n{\n\tchar *p = buffer;\n\tnodemask_t nodes = NODE_MASK_NONE;\n\tunsigned short mode = MPOL_DEFAULT;\n\tunsigned short flags = 0;\n\n\tif (pol && pol != &default_policy && !(pol->flags & MPOL_F_MORON)) {\n\t\tmode = pol->mode;\n\t\tflags = pol->flags;\n\t}\n\n\tswitch (mode) {\n\tcase MPOL_DEFAULT:\n\t\tbreak;\n\tcase MPOL_PREFERRED:\n\t\tif (flags & MPOL_F_LOCAL)\n\t\t\tmode = MPOL_LOCAL;\n\t\telse\n\t\t\tnode_set(pol->v.preferred_node, nodes);\n\t\tbreak;\n\tcase MPOL_BIND:\n\tcase MPOL_INTERLEAVE:\n\t\tnodes = pol->v.nodes;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tsnprintf(p, maxlen, \"unknown\");\n\t\treturn;\n\t}\n\n\tp += snprintf(p, maxlen, \"%s\", policy_modes[mode]);\n\n\tif (flags & MPOL_MODE_FLAGS) {\n\t\tp += snprintf(p, buffer + maxlen - p, \"=\");\n\n\t\t/*\n\t\t * Currently, the only defined flags are mutually exclusive\n\t\t */\n\t\tif (flags & MPOL_F_STATIC_NODES)\n\t\t\tp += snprintf(p, buffer + maxlen - p, \"static\");\n\t\telse if (flags & MPOL_F_RELATIVE_NODES)\n\t\t\tp += snprintf(p, buffer + maxlen - p, \"relative\");\n\t}\n\n\tif (!nodes_empty(nodes))\n\t\tp += scnprintf(p, buffer + maxlen - p, \":%*pbl\",\n\t\t\t       nodemask_pr_args(&nodes));\n}\n"], "fixing_code": ["/*\n * Simple NUMA memory policy for the Linux kernel.\n *\n * Copyright 2003,2004 Andi Kleen, SuSE Labs.\n * (C) Copyright 2005 Christoph Lameter, Silicon Graphics, Inc.\n * Subject to the GNU Public License, version 2.\n *\n * NUMA policy allows the user to give hints in which node(s) memory should\n * be allocated.\n *\n * Support four policies per VMA and per process:\n *\n * The VMA policy has priority over the process policy for a page fault.\n *\n * interleave     Allocate memory interleaved over a set of nodes,\n *                with normal fallback if it fails.\n *                For VMA based allocations this interleaves based on the\n *                offset into the backing object or offset into the mapping\n *                for anonymous memory. For process policy an process counter\n *                is used.\n *\n * bind           Only allocate memory on a specific set of nodes,\n *                no fallback.\n *                FIXME: memory is allocated starting with the first node\n *                to the last. It would be better if bind would truly restrict\n *                the allocation to memory nodes instead\n *\n * preferred       Try a specific node first before normal fallback.\n *                As a special case NUMA_NO_NODE here means do the allocation\n *                on the local CPU. This is normally identical to default,\n *                but useful to set in a VMA when you have a non default\n *                process policy.\n *\n * default        Allocate on the local node first, or when on a VMA\n *                use the process policy. This is what Linux always did\n *\t\t  in a NUMA aware kernel and still does by, ahem, default.\n *\n * The process policy is applied for most non interrupt memory allocations\n * in that process' context. Interrupts ignore the policies and always\n * try to allocate on the local CPU. The VMA policy is only applied for memory\n * allocations for a VMA in the VM.\n *\n * Currently there are a few corner cases in swapping where the policy\n * is not applied, but the majority should be handled. When process policy\n * is used it is not remembered over swap outs/swap ins.\n *\n * Only the highest zone in the zone hierarchy gets policied. Allocations\n * requesting a lower zone just use default policy. This implies that\n * on systems with highmem kernel lowmem allocation don't get policied.\n * Same with GFP_DMA allocations.\n *\n * For shmfs/tmpfs/hugetlbfs shared memory the policy is shared between\n * all users and remembered even when nobody has memory mapped.\n */\n\n/* Notebook:\n   fix mmap readahead to honour policy and enable policy for any page cache\n   object\n   statistics for bigpages\n   global policy for page cache? currently it uses process policy. Requires\n   first item above.\n   handle mremap for shared memory (currently ignored for the policy)\n   grows down?\n   make bind policy root only? It can trigger oom much faster and the\n   kernel is not always grateful with that.\n*/\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/mempolicy.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/hugetlb.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/task.h>\n#include <linux/nodemask.h>\n#include <linux/cpuset.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/nsproxy.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/compat.h>\n#include <linux/swap.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/migrate.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/ctype.h>\n#include <linux/mm_inline.h>\n#include <linux/mmu_notifier.h>\n#include <linux/printk.h>\n\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n\n#include \"internal.h\"\n\n/* Internal flags */\n#define MPOL_MF_DISCONTIG_OK (MPOL_MF_INTERNAL << 0)\t/* Skip checks for continuous vmas */\n#define MPOL_MF_INVERT (MPOL_MF_INTERNAL << 1)\t\t/* Invert check for nodemask */\n\nstatic struct kmem_cache *policy_cache;\nstatic struct kmem_cache *sn_cache;\n\n/* Highest zone. An specific allocation for a zone below that is not\n   policied. */\nenum zone_type policy_zone = 0;\n\n/*\n * run-time system-wide default policy => local allocation\n */\nstatic struct mempolicy default_policy = {\n\t.refcnt = ATOMIC_INIT(1), /* never free it */\n\t.mode = MPOL_PREFERRED,\n\t.flags = MPOL_F_LOCAL,\n};\n\nstatic struct mempolicy preferred_node_policy[MAX_NUMNODES];\n\nstruct mempolicy *get_task_policy(struct task_struct *p)\n{\n\tstruct mempolicy *pol = p->mempolicy;\n\tint node;\n\n\tif (pol)\n\t\treturn pol;\n\n\tnode = numa_node_id();\n\tif (node != NUMA_NO_NODE) {\n\t\tpol = &preferred_node_policy[node];\n\t\t/* preferred_node_policy is not initialised early in boot */\n\t\tif (pol->mode)\n\t\t\treturn pol;\n\t}\n\n\treturn &default_policy;\n}\n\nstatic const struct mempolicy_operations {\n\tint (*create)(struct mempolicy *pol, const nodemask_t *nodes);\n\t/*\n\t * If read-side task has no lock to protect task->mempolicy, write-side\n\t * task will rebind the task->mempolicy by two step. The first step is\n\t * setting all the newly nodes, and the second step is cleaning all the\n\t * disallowed nodes. In this way, we can avoid finding no node to alloc\n\t * page.\n\t * If we have a lock to protect task->mempolicy in read-side, we do\n\t * rebind directly.\n\t *\n\t * step:\n\t * \tMPOL_REBIND_ONCE - do rebind work at once\n\t * \tMPOL_REBIND_STEP1 - set all the newly nodes\n\t * \tMPOL_REBIND_STEP2 - clean all the disallowed nodes\n\t */\n\tvoid (*rebind)(struct mempolicy *pol, const nodemask_t *nodes,\n\t\t\tenum mpol_rebind_step step);\n} mpol_ops[MPOL_MAX];\n\nstatic inline int mpol_store_user_nodemask(const struct mempolicy *pol)\n{\n\treturn pol->flags & MPOL_MODE_FLAGS;\n}\n\nstatic void mpol_relative_nodemask(nodemask_t *ret, const nodemask_t *orig,\n\t\t\t\t   const nodemask_t *rel)\n{\n\tnodemask_t tmp;\n\tnodes_fold(tmp, *orig, nodes_weight(*rel));\n\tnodes_onto(*ret, tmp, *rel);\n}\n\nstatic int mpol_new_interleave(struct mempolicy *pol, const nodemask_t *nodes)\n{\n\tif (nodes_empty(*nodes))\n\t\treturn -EINVAL;\n\tpol->v.nodes = *nodes;\n\treturn 0;\n}\n\nstatic int mpol_new_preferred(struct mempolicy *pol, const nodemask_t *nodes)\n{\n\tif (!nodes)\n\t\tpol->flags |= MPOL_F_LOCAL;\t/* local allocation */\n\telse if (nodes_empty(*nodes))\n\t\treturn -EINVAL;\t\t\t/*  no allowed nodes */\n\telse\n\t\tpol->v.preferred_node = first_node(*nodes);\n\treturn 0;\n}\n\nstatic int mpol_new_bind(struct mempolicy *pol, const nodemask_t *nodes)\n{\n\tif (nodes_empty(*nodes))\n\t\treturn -EINVAL;\n\tpol->v.nodes = *nodes;\n\treturn 0;\n}\n\n/*\n * mpol_set_nodemask is called after mpol_new() to set up the nodemask, if\n * any, for the new policy.  mpol_new() has already validated the nodes\n * parameter with respect to the policy mode and flags.  But, we need to\n * handle an empty nodemask with MPOL_PREFERRED here.\n *\n * Must be called holding task's alloc_lock to protect task's mems_allowed\n * and mempolicy.  May also be called holding the mmap_semaphore for write.\n */\nstatic int mpol_set_nodemask(struct mempolicy *pol,\n\t\t     const nodemask_t *nodes, struct nodemask_scratch *nsc)\n{\n\tint ret;\n\n\t/* if mode is MPOL_DEFAULT, pol is NULL. This is right. */\n\tif (pol == NULL)\n\t\treturn 0;\n\t/* Check N_MEMORY */\n\tnodes_and(nsc->mask1,\n\t\t  cpuset_current_mems_allowed, node_states[N_MEMORY]);\n\n\tVM_BUG_ON(!nodes);\n\tif (pol->mode == MPOL_PREFERRED && nodes_empty(*nodes))\n\t\tnodes = NULL;\t/* explicit local allocation */\n\telse {\n\t\tif (pol->flags & MPOL_F_RELATIVE_NODES)\n\t\t\tmpol_relative_nodemask(&nsc->mask2, nodes, &nsc->mask1);\n\t\telse\n\t\t\tnodes_and(nsc->mask2, *nodes, nsc->mask1);\n\n\t\tif (mpol_store_user_nodemask(pol))\n\t\t\tpol->w.user_nodemask = *nodes;\n\t\telse\n\t\t\tpol->w.cpuset_mems_allowed =\n\t\t\t\t\t\tcpuset_current_mems_allowed;\n\t}\n\n\tif (nodes)\n\t\tret = mpol_ops[pol->mode].create(pol, &nsc->mask2);\n\telse\n\t\tret = mpol_ops[pol->mode].create(pol, NULL);\n\treturn ret;\n}\n\n/*\n * This function just creates a new policy, does some check and simple\n * initialization. You must invoke mpol_set_nodemask() to set nodes.\n */\nstatic struct mempolicy *mpol_new(unsigned short mode, unsigned short flags,\n\t\t\t\t  nodemask_t *nodes)\n{\n\tstruct mempolicy *policy;\n\n\tpr_debug(\"setting mode %d flags %d nodes[0] %lx\\n\",\n\t\t mode, flags, nodes ? nodes_addr(*nodes)[0] : NUMA_NO_NODE);\n\n\tif (mode == MPOL_DEFAULT) {\n\t\tif (nodes && !nodes_empty(*nodes))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\treturn NULL;\n\t}\n\tVM_BUG_ON(!nodes);\n\n\t/*\n\t * MPOL_PREFERRED cannot be used with MPOL_F_STATIC_NODES or\n\t * MPOL_F_RELATIVE_NODES if the nodemask is empty (local allocation).\n\t * All other modes require a valid pointer to a non-empty nodemask.\n\t */\n\tif (mode == MPOL_PREFERRED) {\n\t\tif (nodes_empty(*nodes)) {\n\t\t\tif (((flags & MPOL_F_STATIC_NODES) ||\n\t\t\t     (flags & MPOL_F_RELATIVE_NODES)))\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t} else if (mode == MPOL_LOCAL) {\n\t\tif (!nodes_empty(*nodes) ||\n\t\t    (flags & MPOL_F_STATIC_NODES) ||\n\t\t    (flags & MPOL_F_RELATIVE_NODES))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tmode = MPOL_PREFERRED;\n\t} else if (nodes_empty(*nodes))\n\t\treturn ERR_PTR(-EINVAL);\n\tpolicy = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\tif (!policy)\n\t\treturn ERR_PTR(-ENOMEM);\n\tatomic_set(&policy->refcnt, 1);\n\tpolicy->mode = mode;\n\tpolicy->flags = flags;\n\n\treturn policy;\n}\n\n/* Slow path of a mpol destructor. */\nvoid __mpol_put(struct mempolicy *p)\n{\n\tif (!atomic_dec_and_test(&p->refcnt))\n\t\treturn;\n\tkmem_cache_free(policy_cache, p);\n}\n\nstatic void mpol_rebind_default(struct mempolicy *pol, const nodemask_t *nodes,\n\t\t\t\tenum mpol_rebind_step step)\n{\n}\n\n/*\n * step:\n * \tMPOL_REBIND_ONCE  - do rebind work at once\n * \tMPOL_REBIND_STEP1 - set all the newly nodes\n * \tMPOL_REBIND_STEP2 - clean all the disallowed nodes\n */\nstatic void mpol_rebind_nodemask(struct mempolicy *pol, const nodemask_t *nodes,\n\t\t\t\t enum mpol_rebind_step step)\n{\n\tnodemask_t tmp;\n\n\tif (pol->flags & MPOL_F_STATIC_NODES)\n\t\tnodes_and(tmp, pol->w.user_nodemask, *nodes);\n\telse if (pol->flags & MPOL_F_RELATIVE_NODES)\n\t\tmpol_relative_nodemask(&tmp, &pol->w.user_nodemask, nodes);\n\telse {\n\t\t/*\n\t\t * if step == 1, we use ->w.cpuset_mems_allowed to cache the\n\t\t * result\n\t\t */\n\t\tif (step == MPOL_REBIND_ONCE || step == MPOL_REBIND_STEP1) {\n\t\t\tnodes_remap(tmp, pol->v.nodes,\n\t\t\t\t\tpol->w.cpuset_mems_allowed, *nodes);\n\t\t\tpol->w.cpuset_mems_allowed = step ? tmp : *nodes;\n\t\t} else if (step == MPOL_REBIND_STEP2) {\n\t\t\ttmp = pol->w.cpuset_mems_allowed;\n\t\t\tpol->w.cpuset_mems_allowed = *nodes;\n\t\t} else\n\t\t\tBUG();\n\t}\n\n\tif (nodes_empty(tmp))\n\t\ttmp = *nodes;\n\n\tif (step == MPOL_REBIND_STEP1)\n\t\tnodes_or(pol->v.nodes, pol->v.nodes, tmp);\n\telse if (step == MPOL_REBIND_ONCE || step == MPOL_REBIND_STEP2)\n\t\tpol->v.nodes = tmp;\n\telse\n\t\tBUG();\n\n\tif (!node_isset(current->il_next, tmp)) {\n\t\tcurrent->il_next = next_node_in(current->il_next, tmp);\n\t\tif (current->il_next >= MAX_NUMNODES)\n\t\t\tcurrent->il_next = numa_node_id();\n\t}\n}\n\nstatic void mpol_rebind_preferred(struct mempolicy *pol,\n\t\t\t\t  const nodemask_t *nodes,\n\t\t\t\t  enum mpol_rebind_step step)\n{\n\tnodemask_t tmp;\n\n\tif (pol->flags & MPOL_F_STATIC_NODES) {\n\t\tint node = first_node(pol->w.user_nodemask);\n\n\t\tif (node_isset(node, *nodes)) {\n\t\t\tpol->v.preferred_node = node;\n\t\t\tpol->flags &= ~MPOL_F_LOCAL;\n\t\t} else\n\t\t\tpol->flags |= MPOL_F_LOCAL;\n\t} else if (pol->flags & MPOL_F_RELATIVE_NODES) {\n\t\tmpol_relative_nodemask(&tmp, &pol->w.user_nodemask, nodes);\n\t\tpol->v.preferred_node = first_node(tmp);\n\t} else if (!(pol->flags & MPOL_F_LOCAL)) {\n\t\tpol->v.preferred_node = node_remap(pol->v.preferred_node,\n\t\t\t\t\t\t   pol->w.cpuset_mems_allowed,\n\t\t\t\t\t\t   *nodes);\n\t\tpol->w.cpuset_mems_allowed = *nodes;\n\t}\n}\n\n/*\n * mpol_rebind_policy - Migrate a policy to a different set of nodes\n *\n * If read-side task has no lock to protect task->mempolicy, write-side\n * task will rebind the task->mempolicy by two step. The first step is\n * setting all the newly nodes, and the second step is cleaning all the\n * disallowed nodes. In this way, we can avoid finding no node to alloc\n * page.\n * If we have a lock to protect task->mempolicy in read-side, we do\n * rebind directly.\n *\n * step:\n * \tMPOL_REBIND_ONCE  - do rebind work at once\n * \tMPOL_REBIND_STEP1 - set all the newly nodes\n * \tMPOL_REBIND_STEP2 - clean all the disallowed nodes\n */\nstatic void mpol_rebind_policy(struct mempolicy *pol, const nodemask_t *newmask,\n\t\t\t\tenum mpol_rebind_step step)\n{\n\tif (!pol)\n\t\treturn;\n\tif (!mpol_store_user_nodemask(pol) && step == MPOL_REBIND_ONCE &&\n\t    nodes_equal(pol->w.cpuset_mems_allowed, *newmask))\n\t\treturn;\n\n\tif (step == MPOL_REBIND_STEP1 && (pol->flags & MPOL_F_REBINDING))\n\t\treturn;\n\n\tif (step == MPOL_REBIND_STEP2 && !(pol->flags & MPOL_F_REBINDING))\n\t\tBUG();\n\n\tif (step == MPOL_REBIND_STEP1)\n\t\tpol->flags |= MPOL_F_REBINDING;\n\telse if (step == MPOL_REBIND_STEP2)\n\t\tpol->flags &= ~MPOL_F_REBINDING;\n\telse if (step >= MPOL_REBIND_NSTEP)\n\t\tBUG();\n\n\tmpol_ops[pol->mode].rebind(pol, newmask, step);\n}\n\n/*\n * Wrapper for mpol_rebind_policy() that just requires task\n * pointer, and updates task mempolicy.\n *\n * Called with task's alloc_lock held.\n */\n\nvoid mpol_rebind_task(struct task_struct *tsk, const nodemask_t *new,\n\t\t\tenum mpol_rebind_step step)\n{\n\tmpol_rebind_policy(tsk->mempolicy, new, step);\n}\n\n/*\n * Rebind each vma in mm to new nodemask.\n *\n * Call holding a reference to mm.  Takes mm->mmap_sem during call.\n */\n\nvoid mpol_rebind_mm(struct mm_struct *mm, nodemask_t *new)\n{\n\tstruct vm_area_struct *vma;\n\n\tdown_write(&mm->mmap_sem);\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\tmpol_rebind_policy(vma->vm_policy, new, MPOL_REBIND_ONCE);\n\tup_write(&mm->mmap_sem);\n}\n\nstatic const struct mempolicy_operations mpol_ops[MPOL_MAX] = {\n\t[MPOL_DEFAULT] = {\n\t\t.rebind = mpol_rebind_default,\n\t},\n\t[MPOL_INTERLEAVE] = {\n\t\t.create = mpol_new_interleave,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n\t[MPOL_PREFERRED] = {\n\t\t.create = mpol_new_preferred,\n\t\t.rebind = mpol_rebind_preferred,\n\t},\n\t[MPOL_BIND] = {\n\t\t.create = mpol_new_bind,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n};\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstruct queue_pages {\n\tstruct list_head *pagelist;\n\tunsigned long flags;\n\tnodemask_t *nmask;\n\tstruct vm_area_struct *prev;\n};\n\n/*\n * Scan through pages checking if pages follow certain conditions,\n * and move them to the pagelist if they do.\n */\nstatic int queue_pages_pte_range(pmd_t *pmd, unsigned long addr,\n\t\t\tunsigned long end, struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct page *page;\n\tstruct queue_pages *qp = walk->private;\n\tunsigned long flags = qp->flags;\n\tint nid, ret;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tif (pmd_trans_huge(*pmd)) {\n\t\tptl = pmd_lock(walk->mm, pmd);\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tpage = pmd_page(*pmd);\n\t\t\tif (is_huge_zero_page(page)) {\n\t\t\t\tspin_unlock(ptl);\n\t\t\t\t__split_huge_pmd(vma, pmd, addr, false, NULL);\n\t\t\t} else {\n\t\t\t\tget_page(page);\n\t\t\t\tspin_unlock(ptl);\n\t\t\t\tlock_page(page);\n\t\t\t\tret = split_huge_page(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t}\n\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\nretry:\n\tpte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE) {\n\t\tif (!pte_present(*pte))\n\t\t\tcontinue;\n\t\tpage = vm_normal_page(vma, addr, *pte);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\t/*\n\t\t * vm_normal_page() filters out zero pages, but there might\n\t\t * still be PageReserved pages to skip, perhaps in a VDSO.\n\t\t */\n\t\tif (PageReserved(page))\n\t\t\tcontinue;\n\t\tnid = page_to_nid(page);\n\t\tif (node_isset(nid, *qp->nmask) == !!(flags & MPOL_MF_INVERT))\n\t\t\tcontinue;\n\t\tif (PageTransCompound(page)) {\n\t\t\tget_page(page);\n\t\t\tpte_unmap_unlock(pte, ptl);\n\t\t\tlock_page(page);\n\t\t\tret = split_huge_page(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\t/* Failed to split -- skip. */\n\t\t\tif (ret) {\n\t\t\t\tpte = pte_offset_map_lock(walk->mm, pmd,\n\t\t\t\t\t\taddr, &ptl);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto retry;\n\t\t}\n\n\t\tmigrate_page_add(page, qp->pagelist, flags);\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\treturn 0;\n}\n\nstatic int queue_pages_hugetlb(pte_t *pte, unsigned long hmask,\n\t\t\t       unsigned long addr, unsigned long end,\n\t\t\t       struct mm_walk *walk)\n{\n#ifdef CONFIG_HUGETLB_PAGE\n\tstruct queue_pages *qp = walk->private;\n\tunsigned long flags = qp->flags;\n\tint nid;\n\tstruct page *page;\n\tspinlock_t *ptl;\n\tpte_t entry;\n\n\tptl = huge_pte_lock(hstate_vma(walk->vma), walk->mm, pte);\n\tentry = huge_ptep_get(pte);\n\tif (!pte_present(entry))\n\t\tgoto unlock;\n\tpage = pte_page(entry);\n\tnid = page_to_nid(page);\n\tif (node_isset(nid, *qp->nmask) == !!(flags & MPOL_MF_INVERT))\n\t\tgoto unlock;\n\t/* With MPOL_MF_MOVE, we migrate only unshared hugepage. */\n\tif (flags & (MPOL_MF_MOVE_ALL) ||\n\t    (flags & MPOL_MF_MOVE && page_mapcount(page) == 1))\n\t\tisolate_huge_page(page, qp->pagelist);\nunlock:\n\tspin_unlock(ptl);\n#else\n\tBUG();\n#endif\n\treturn 0;\n}\n\n#ifdef CONFIG_NUMA_BALANCING\n/*\n * This is used to mark a range of virtual addresses to be inaccessible.\n * These are later cleared by a NUMA hinting fault. Depending on these\n * faults, pages may be migrated for better NUMA placement.\n *\n * This is assuming that NUMA faults are handled using PROT_NONE. If\n * an architecture makes a different choice, it will need further\n * changes to the core.\n */\nunsigned long change_prot_numa(struct vm_area_struct *vma,\n\t\t\tunsigned long addr, unsigned long end)\n{\n\tint nr_updated;\n\n\tnr_updated = change_protection(vma, addr, end, PAGE_NONE, 0, 1);\n\tif (nr_updated)\n\t\tcount_vm_numa_events(NUMA_PTE_UPDATES, nr_updated);\n\n\treturn nr_updated;\n}\n#else\nstatic unsigned long change_prot_numa(struct vm_area_struct *vma,\n\t\t\tunsigned long addr, unsigned long end)\n{\n\treturn 0;\n}\n#endif /* CONFIG_NUMA_BALANCING */\n\nstatic int queue_pages_test_walk(unsigned long start, unsigned long end,\n\t\t\t\tstruct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct queue_pages *qp = walk->private;\n\tunsigned long endvma = vma->vm_end;\n\tunsigned long flags = qp->flags;\n\n\tif (!vma_migratable(vma))\n\t\treturn 1;\n\n\tif (endvma > end)\n\t\tendvma = end;\n\tif (vma->vm_start > start)\n\t\tstart = vma->vm_start;\n\n\tif (!(flags & MPOL_MF_DISCONTIG_OK)) {\n\t\tif (!vma->vm_next && vma->vm_end < end)\n\t\t\treturn -EFAULT;\n\t\tif (qp->prev && qp->prev->vm_end < vma->vm_start)\n\t\t\treturn -EFAULT;\n\t}\n\n\tqp->prev = vma;\n\n\tif (flags & MPOL_MF_LAZY) {\n\t\t/* Similar to task_numa_work, skip inaccessible VMAs */\n\t\tif (!is_vm_hugetlb_page(vma) &&\n\t\t\t(vma->vm_flags & (VM_READ | VM_EXEC | VM_WRITE)) &&\n\t\t\t!(vma->vm_flags & VM_MIXEDMAP))\n\t\t\tchange_prot_numa(vma, start, endvma);\n\t\treturn 1;\n\t}\n\n\t/* queue pages from current vma */\n\tif (flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL))\n\t\treturn 0;\n\treturn 1;\n}\n\n/*\n * Walk through page tables and collect pages to be migrated.\n *\n * If pages found in a given range are on a set of nodes (determined by\n * @nodes and @flags,) it's isolated and queued to the pagelist which is\n * passed via @private.)\n */\nstatic int\nqueue_pages_range(struct mm_struct *mm, unsigned long start, unsigned long end,\n\t\tnodemask_t *nodes, unsigned long flags,\n\t\tstruct list_head *pagelist)\n{\n\tstruct queue_pages qp = {\n\t\t.pagelist = pagelist,\n\t\t.flags = flags,\n\t\t.nmask = nodes,\n\t\t.prev = NULL,\n\t};\n\tstruct mm_walk queue_pages_walk = {\n\t\t.hugetlb_entry = queue_pages_hugetlb,\n\t\t.pmd_entry = queue_pages_pte_range,\n\t\t.test_walk = queue_pages_test_walk,\n\t\t.mm = mm,\n\t\t.private = &qp,\n\t};\n\n\treturn walk_page_range(start, end, &queue_pages_walk);\n}\n\n/*\n * Apply policy to a single VMA\n * This must be called with the mmap_sem held for writing.\n */\nstatic int vma_replace_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tstruct mempolicy *pol)\n{\n\tint err;\n\tstruct mempolicy *old;\n\tstruct mempolicy *new;\n\n\tpr_debug(\"vma %lx-%lx/%lx vm_ops %p vm_file %p set_policy %p\\n\",\n\t\t vma->vm_start, vma->vm_end, vma->vm_pgoff,\n\t\t vma->vm_ops, vma->vm_file,\n\t\t vma->vm_ops ? vma->vm_ops->set_policy : NULL);\n\n\tnew = mpol_dup(pol);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\tif (vma->vm_ops && vma->vm_ops->set_policy) {\n\t\terr = vma->vm_ops->set_policy(vma, new);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\n\told = vma->vm_policy;\n\tvma->vm_policy = new; /* protected by mmap_sem */\n\tmpol_put(old);\n\n\treturn 0;\n err_out:\n\tmpol_put(new);\n\treturn err;\n}\n\n/* Step 2: apply policy to a range and do splits. */\nstatic int mbind_range(struct mm_struct *mm, unsigned long start,\n\t\t       unsigned long end, struct mempolicy *new_pol)\n{\n\tstruct vm_area_struct *next;\n\tstruct vm_area_struct *prev;\n\tstruct vm_area_struct *vma;\n\tint err = 0;\n\tpgoff_t pgoff;\n\tunsigned long vmstart;\n\tunsigned long vmend;\n\n\tvma = find_vma(mm, start);\n\tif (!vma || vma->vm_start > start)\n\t\treturn -EFAULT;\n\n\tprev = vma->vm_prev;\n\tif (start > vma->vm_start)\n\t\tprev = vma;\n\n\tfor (; vma && vma->vm_start < end; prev = vma, vma = next) {\n\t\tnext = vma->vm_next;\n\t\tvmstart = max(start, vma->vm_start);\n\t\tvmend   = min(end, vma->vm_end);\n\n\t\tif (mpol_equal(vma_policy(vma), new_pol))\n\t\t\tcontinue;\n\n\t\tpgoff = vma->vm_pgoff +\n\t\t\t((vmstart - vma->vm_start) >> PAGE_SHIFT);\n\t\tprev = vma_merge(mm, prev, vmstart, vmend, vma->vm_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, pgoff,\n\t\t\t\t new_pol, vma->vm_userfaultfd_ctx);\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tnext = vma->vm_next;\n\t\t\tif (mpol_equal(vma_policy(vma), new_pol))\n\t\t\t\tcontinue;\n\t\t\t/* vma_merge() joined vma && vma->next, case 8 */\n\t\t\tgoto replace;\n\t\t}\n\t\tif (vma->vm_start != vmstart) {\n\t\t\terr = split_vma(vma->vm_mm, vma, vmstart, 1);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (vma->vm_end != vmend) {\n\t\t\terr = split_vma(vma->vm_mm, vma, vmend, 0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n replace:\n\t\terr = vma_replace_policy(vma, new_pol);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n out:\n\treturn err;\n}\n\n/* Set the process memory policy */\nstatic long do_set_mempolicy(unsigned short mode, unsigned short flags,\n\t\t\t     nodemask_t *nodes)\n{\n\tstruct mempolicy *new, *old;\n\tNODEMASK_SCRATCH(scratch);\n\tint ret;\n\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\tnew = mpol_new(mode, flags, nodes);\n\tif (IS_ERR(new)) {\n\t\tret = PTR_ERR(new);\n\t\tgoto out;\n\t}\n\n\ttask_lock(current);\n\tret = mpol_set_nodemask(new, nodes, scratch);\n\tif (ret) {\n\t\ttask_unlock(current);\n\t\tmpol_put(new);\n\t\tgoto out;\n\t}\n\told = current->mempolicy;\n\tcurrent->mempolicy = new;\n\tif (new && new->mode == MPOL_INTERLEAVE &&\n\t    nodes_weight(new->v.nodes))\n\t\tcurrent->il_next = first_node(new->v.nodes);\n\ttask_unlock(current);\n\tmpol_put(old);\n\tret = 0;\nout:\n\tNODEMASK_SCRATCH_FREE(scratch);\n\treturn ret;\n}\n\n/*\n * Return nodemask for policy for get_mempolicy() query\n *\n * Called with task's alloc_lock held\n */\nstatic void get_policy_nodemask(struct mempolicy *p, nodemask_t *nodes)\n{\n\tnodes_clear(*nodes);\n\tif (p == &default_policy)\n\t\treturn;\n\n\tswitch (p->mode) {\n\tcase MPOL_BIND:\n\t\t/* Fall through */\n\tcase MPOL_INTERLEAVE:\n\t\t*nodes = p->v.nodes;\n\t\tbreak;\n\tcase MPOL_PREFERRED:\n\t\tif (!(p->flags & MPOL_F_LOCAL))\n\t\t\tnode_set(p->v.preferred_node, *nodes);\n\t\t/* else return empty node mask for local allocation */\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic int lookup_node(unsigned long addr)\n{\n\tstruct page *p;\n\tint err;\n\n\terr = get_user_pages(addr & PAGE_MASK, 1, 0, &p, NULL);\n\tif (err >= 0) {\n\t\terr = page_to_nid(p);\n\t\tput_page(p);\n\t}\n\treturn err;\n}\n\n/* Retrieve NUMA policy */\nstatic long do_get_mempolicy(int *policy, nodemask_t *nmask,\n\t\t\t     unsigned long addr, unsigned long flags)\n{\n\tint err;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = NULL;\n\tstruct mempolicy *pol = current->mempolicy;\n\n\tif (flags &\n\t\t~(unsigned long)(MPOL_F_NODE|MPOL_F_ADDR|MPOL_F_MEMS_ALLOWED))\n\t\treturn -EINVAL;\n\n\tif (flags & MPOL_F_MEMS_ALLOWED) {\n\t\tif (flags & (MPOL_F_NODE|MPOL_F_ADDR))\n\t\t\treturn -EINVAL;\n\t\t*policy = 0;\t/* just so it's initialized */\n\t\ttask_lock(current);\n\t\t*nmask  = cpuset_current_mems_allowed;\n\t\ttask_unlock(current);\n\t\treturn 0;\n\t}\n\n\tif (flags & MPOL_F_ADDR) {\n\t\t/*\n\t\t * Do NOT fall back to task policy if the\n\t\t * vma/shared policy at addr is NULL.  We\n\t\t * want to return MPOL_DEFAULT in this case.\n\t\t */\n\t\tdown_read(&mm->mmap_sem);\n\t\tvma = find_vma_intersection(mm, addr, addr+1);\n\t\tif (!vma) {\n\t\t\tup_read(&mm->mmap_sem);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (vma->vm_ops && vma->vm_ops->get_policy)\n\t\t\tpol = vma->vm_ops->get_policy(vma, addr);\n\t\telse\n\t\t\tpol = vma->vm_policy;\n\t} else if (addr)\n\t\treturn -EINVAL;\n\n\tif (!pol)\n\t\tpol = &default_policy;\t/* indicates default behavior */\n\n\tif (flags & MPOL_F_NODE) {\n\t\tif (flags & MPOL_F_ADDR) {\n\t\t\terr = lookup_node(addr);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t\t*policy = err;\n\t\t} else if (pol == current->mempolicy &&\n\t\t\t\tpol->mode == MPOL_INTERLEAVE) {\n\t\t\t*policy = current->il_next;\n\t\t} else {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t*policy = pol == &default_policy ? MPOL_DEFAULT :\n\t\t\t\t\t\tpol->mode;\n\t\t/*\n\t\t * Internal mempolicy flags must be masked off before exposing\n\t\t * the policy to userspace.\n\t\t */\n\t\t*policy |= (pol->flags & MPOL_MODE_FLAGS);\n\t}\n\n\tif (vma) {\n\t\tup_read(&current->mm->mmap_sem);\n\t\tvma = NULL;\n\t}\n\n\terr = 0;\n\tif (nmask) {\n\t\tif (mpol_store_user_nodemask(pol)) {\n\t\t\t*nmask = pol->w.user_nodemask;\n\t\t} else {\n\t\t\ttask_lock(current);\n\t\t\tget_policy_nodemask(pol, nmask);\n\t\t\ttask_unlock(current);\n\t\t}\n\t}\n\n out:\n\tmpol_cond_put(pol);\n\tif (vma)\n\t\tup_read(&current->mm->mmap_sem);\n\treturn err;\n}\n\n#ifdef CONFIG_MIGRATION\n/*\n * page migration\n */\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags)\n{\n\t/*\n\t * Avoid migrating a page that is shared with others.\n\t */\n\tif ((flags & MPOL_MF_MOVE_ALL) || page_mapcount(page) == 1) {\n\t\tif (!isolate_lru_page(page)) {\n\t\t\tlist_add_tail(&page->lru, pagelist);\n\t\t\tinc_node_page_state(page, NR_ISOLATED_ANON +\n\t\t\t\t\t    page_is_file_cache(page));\n\t\t}\n\t}\n}\n\nstatic struct page *new_node_page(struct page *page, unsigned long node, int **x)\n{\n\tif (PageHuge(page))\n\t\treturn alloc_huge_page_node(page_hstate(compound_head(page)),\n\t\t\t\t\tnode);\n\telse\n\t\treturn __alloc_pages_node(node, GFP_HIGHUSER_MOVABLE |\n\t\t\t\t\t\t    __GFP_THISNODE, 0);\n}\n\n/*\n * Migrate pages from one node to a target node.\n * Returns error or the number of pages not migrated.\n */\nstatic int migrate_to_node(struct mm_struct *mm, int source, int dest,\n\t\t\t   int flags)\n{\n\tnodemask_t nmask;\n\tLIST_HEAD(pagelist);\n\tint err = 0;\n\n\tnodes_clear(nmask);\n\tnode_set(source, nmask);\n\n\t/*\n\t * This does not \"check\" the range but isolates all pages that\n\t * need migration.  Between passing in the full user address\n\t * space range and MPOL_MF_DISCONTIG_OK, this call can not fail.\n\t */\n\tVM_BUG_ON(!(flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL)));\n\tqueue_pages_range(mm, mm->mmap->vm_start, mm->task_size, &nmask,\n\t\t\tflags | MPOL_MF_DISCONTIG_OK, &pagelist);\n\n\tif (!list_empty(&pagelist)) {\n\t\terr = migrate_pages(&pagelist, new_node_page, NULL, dest,\n\t\t\t\t\tMIGRATE_SYNC, MR_SYSCALL);\n\t\tif (err)\n\t\t\tputback_movable_pages(&pagelist);\n\t}\n\n\treturn err;\n}\n\n/*\n * Move pages between the two nodesets so as to preserve the physical\n * layout as much as possible.\n *\n * Returns the number of page that could not be moved.\n */\nint do_migrate_pages(struct mm_struct *mm, const nodemask_t *from,\n\t\t     const nodemask_t *to, int flags)\n{\n\tint busy = 0;\n\tint err;\n\tnodemask_t tmp;\n\n\terr = migrate_prep();\n\tif (err)\n\t\treturn err;\n\n\tdown_read(&mm->mmap_sem);\n\n\t/*\n\t * Find a 'source' bit set in 'tmp' whose corresponding 'dest'\n\t * bit in 'to' is not also set in 'tmp'.  Clear the found 'source'\n\t * bit in 'tmp', and return that <source, dest> pair for migration.\n\t * The pair of nodemasks 'to' and 'from' define the map.\n\t *\n\t * If no pair of bits is found that way, fallback to picking some\n\t * pair of 'source' and 'dest' bits that are not the same.  If the\n\t * 'source' and 'dest' bits are the same, this represents a node\n\t * that will be migrating to itself, so no pages need move.\n\t *\n\t * If no bits are left in 'tmp', or if all remaining bits left\n\t * in 'tmp' correspond to the same bit in 'to', return false\n\t * (nothing left to migrate).\n\t *\n\t * This lets us pick a pair of nodes to migrate between, such that\n\t * if possible the dest node is not already occupied by some other\n\t * source node, minimizing the risk of overloading the memory on a\n\t * node that would happen if we migrated incoming memory to a node\n\t * before migrating outgoing memory source that same node.\n\t *\n\t * A single scan of tmp is sufficient.  As we go, we remember the\n\t * most recent <s, d> pair that moved (s != d).  If we find a pair\n\t * that not only moved, but what's better, moved to an empty slot\n\t * (d is not set in tmp), then we break out then, with that pair.\n\t * Otherwise when we finish scanning from_tmp, we at least have the\n\t * most recent <s, d> pair that moved.  If we get all the way through\n\t * the scan of tmp without finding any node that moved, much less\n\t * moved to an empty node, then there is nothing left worth migrating.\n\t */\n\n\ttmp = *from;\n\twhile (!nodes_empty(tmp)) {\n\t\tint s,d;\n\t\tint source = NUMA_NO_NODE;\n\t\tint dest = 0;\n\n\t\tfor_each_node_mask(s, tmp) {\n\n\t\t\t/*\n\t\t\t * do_migrate_pages() tries to maintain the relative\n\t\t\t * node relationship of the pages established between\n\t\t\t * threads and memory areas.\n                         *\n\t\t\t * However if the number of source nodes is not equal to\n\t\t\t * the number of destination nodes we can not preserve\n\t\t\t * this node relative relationship.  In that case, skip\n\t\t\t * copying memory from a node that is in the destination\n\t\t\t * mask.\n\t\t\t *\n\t\t\t * Example: [2,3,4] -> [3,4,5] moves everything.\n\t\t\t *          [0-7] - > [3,4,5] moves only 0,1,2,6,7.\n\t\t\t */\n\n\t\t\tif ((nodes_weight(*from) != nodes_weight(*to)) &&\n\t\t\t\t\t\t(node_isset(s, *to)))\n\t\t\t\tcontinue;\n\n\t\t\td = node_remap(s, *from, *to);\n\t\t\tif (s == d)\n\t\t\t\tcontinue;\n\n\t\t\tsource = s;\t/* Node moved. Memorize */\n\t\t\tdest = d;\n\n\t\t\t/* dest not in remaining from nodes? */\n\t\t\tif (!node_isset(dest, tmp))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (source == NUMA_NO_NODE)\n\t\t\tbreak;\n\n\t\tnode_clear(source, tmp);\n\t\terr = migrate_to_node(mm, source, dest, flags);\n\t\tif (err > 0)\n\t\t\tbusy += err;\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\tup_read(&mm->mmap_sem);\n\tif (err < 0)\n\t\treturn err;\n\treturn busy;\n\n}\n\n/*\n * Allocate a new page for page migration based on vma policy.\n * Start by assuming the page is mapped by the same vma as contains @start.\n * Search forward from there, if not.  N.B., this assumes that the\n * list of pages handed to migrate_pages()--which is how we get here--\n * is in virtual address order.\n */\nstatic struct page *new_page(struct page *page, unsigned long start, int **x)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long uninitialized_var(address);\n\n\tvma = find_vma(current->mm, start);\n\twhile (vma) {\n\t\taddress = page_address_in_vma(page, vma);\n\t\tif (address != -EFAULT)\n\t\t\tbreak;\n\t\tvma = vma->vm_next;\n\t}\n\n\tif (PageHuge(page)) {\n\t\tBUG_ON(!vma);\n\t\treturn alloc_huge_page_noerr(vma, address, 1);\n\t}\n\t/*\n\t * if !vma, alloc_page_vma() will use task or system default policy\n\t */\n\treturn alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);\n}\n#else\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags)\n{\n}\n\nint do_migrate_pages(struct mm_struct *mm, const nodemask_t *from,\n\t\t     const nodemask_t *to, int flags)\n{\n\treturn -ENOSYS;\n}\n\nstatic struct page *new_page(struct page *page, unsigned long start, int **x)\n{\n\treturn NULL;\n}\n#endif\n\nstatic long do_mbind(unsigned long start, unsigned long len,\n\t\t     unsigned short mode, unsigned short mode_flags,\n\t\t     nodemask_t *nmask, unsigned long flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct mempolicy *new;\n\tunsigned long end;\n\tint err;\n\tLIST_HEAD(pagelist);\n\n\tif (flags & ~(unsigned long)MPOL_MF_VALID)\n\t\treturn -EINVAL;\n\tif ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))\n\t\treturn -EPERM;\n\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\n\tif (mode == MPOL_DEFAULT)\n\t\tflags &= ~MPOL_MF_STRICT;\n\n\tlen = (len + PAGE_SIZE - 1) & PAGE_MASK;\n\tend = start + len;\n\n\tif (end < start)\n\t\treturn -EINVAL;\n\tif (end == start)\n\t\treturn 0;\n\n\tnew = mpol_new(mode, mode_flags, nmask);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\tif (flags & MPOL_MF_LAZY)\n\t\tnew->flags |= MPOL_F_MOF;\n\n\t/*\n\t * If we are using the default policy then operation\n\t * on discontinuous address spaces is okay after all\n\t */\n\tif (!new)\n\t\tflags |= MPOL_MF_DISCONTIG_OK;\n\n\tpr_debug(\"mbind %lx-%lx mode:%d flags:%d nodes:%lx\\n\",\n\t\t start, start + len, mode, mode_flags,\n\t\t nmask ? nodes_addr(*nmask)[0] : NUMA_NO_NODE);\n\n\tif (flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL)) {\n\n\t\terr = migrate_prep();\n\t\tif (err)\n\t\t\tgoto mpol_out;\n\t}\n\t{\n\t\tNODEMASK_SCRATCH(scratch);\n\t\tif (scratch) {\n\t\t\tdown_write(&mm->mmap_sem);\n\t\t\ttask_lock(current);\n\t\t\terr = mpol_set_nodemask(new, nmask, scratch);\n\t\t\ttask_unlock(current);\n\t\t\tif (err)\n\t\t\t\tup_write(&mm->mmap_sem);\n\t\t} else\n\t\t\terr = -ENOMEM;\n\t\tNODEMASK_SCRATCH_FREE(scratch);\n\t}\n\tif (err)\n\t\tgoto mpol_out;\n\n\terr = queue_pages_range(mm, start, end, nmask,\n\t\t\t  flags | MPOL_MF_INVERT, &pagelist);\n\tif (!err)\n\t\terr = mbind_range(mm, start, end, new);\n\n\tif (!err) {\n\t\tint nr_failed = 0;\n\n\t\tif (!list_empty(&pagelist)) {\n\t\t\tWARN_ON_ONCE(flags & MPOL_MF_LAZY);\n\t\t\tnr_failed = migrate_pages(&pagelist, new_page, NULL,\n\t\t\t\tstart, MIGRATE_SYNC, MR_MEMPOLICY_MBIND);\n\t\t\tif (nr_failed)\n\t\t\t\tputback_movable_pages(&pagelist);\n\t\t}\n\n\t\tif (nr_failed && (flags & MPOL_MF_STRICT))\n\t\t\terr = -EIO;\n\t} else\n\t\tputback_movable_pages(&pagelist);\n\n\tup_write(&mm->mmap_sem);\n mpol_out:\n\tmpol_put(new);\n\treturn err;\n}\n\n/*\n * User space interface with variable sized bitmaps for nodelists.\n */\n\n/* Copy a node mask from user space. */\nstatic int get_nodes(nodemask_t *nodes, const unsigned long __user *nmask,\n\t\t     unsigned long maxnode)\n{\n\tunsigned long k;\n\tunsigned long nlongs;\n\tunsigned long endmask;\n\n\t--maxnode;\n\tnodes_clear(*nodes);\n\tif (maxnode == 0 || !nmask)\n\t\treturn 0;\n\tif (maxnode > PAGE_SIZE*BITS_PER_BYTE)\n\t\treturn -EINVAL;\n\n\tnlongs = BITS_TO_LONGS(maxnode);\n\tif ((maxnode % BITS_PER_LONG) == 0)\n\t\tendmask = ~0UL;\n\telse\n\t\tendmask = (1UL << (maxnode % BITS_PER_LONG)) - 1;\n\n\t/* When the user specified more nodes than supported just check\n\t   if the non supported part is all zero. */\n\tif (nlongs > BITS_TO_LONGS(MAX_NUMNODES)) {\n\t\tif (nlongs > PAGE_SIZE/sizeof(long))\n\t\t\treturn -EINVAL;\n\t\tfor (k = BITS_TO_LONGS(MAX_NUMNODES); k < nlongs; k++) {\n\t\t\tunsigned long t;\n\t\t\tif (get_user(t, nmask + k))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (k == nlongs - 1) {\n\t\t\t\tif (t & endmask)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t} else if (t)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tnlongs = BITS_TO_LONGS(MAX_NUMNODES);\n\t\tendmask = ~0UL;\n\t}\n\n\tif (copy_from_user(nodes_addr(*nodes), nmask, nlongs*sizeof(unsigned long)))\n\t\treturn -EFAULT;\n\tnodes_addr(*nodes)[nlongs-1] &= endmask;\n\treturn 0;\n}\n\n/* Copy a kernel node mask to user space */\nstatic int copy_nodes_to_user(unsigned long __user *mask, unsigned long maxnode,\n\t\t\t      nodemask_t *nodes)\n{\n\tunsigned long copy = ALIGN(maxnode-1, 64) / 8;\n\tconst int nbytes = BITS_TO_LONGS(MAX_NUMNODES) * sizeof(long);\n\n\tif (copy > nbytes) {\n\t\tif (copy > PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\tif (clear_user((char __user *)mask + nbytes, copy - nbytes))\n\t\t\treturn -EFAULT;\n\t\tcopy = nbytes;\n\t}\n\treturn copy_to_user(mask, nodes_addr(*nodes), copy) ? -EFAULT : 0;\n}\n\nSYSCALL_DEFINE6(mbind, unsigned long, start, unsigned long, len,\n\t\tunsigned long, mode, const unsigned long __user *, nmask,\n\t\tunsigned long, maxnode, unsigned, flags)\n{\n\tnodemask_t nodes;\n\tint err;\n\tunsigned short mode_flags;\n\n\tmode_flags = mode & MPOL_MODE_FLAGS;\n\tmode &= ~MPOL_MODE_FLAGS;\n\tif (mode >= MPOL_MAX)\n\t\treturn -EINVAL;\n\tif ((mode_flags & MPOL_F_STATIC_NODES) &&\n\t    (mode_flags & MPOL_F_RELATIVE_NODES))\n\t\treturn -EINVAL;\n\terr = get_nodes(&nodes, nmask, maxnode);\n\tif (err)\n\t\treturn err;\n\treturn do_mbind(start, len, mode, mode_flags, &nodes, flags);\n}\n\n/* Set the process memory policy */\nSYSCALL_DEFINE3(set_mempolicy, int, mode, const unsigned long __user *, nmask,\n\t\tunsigned long, maxnode)\n{\n\tint err;\n\tnodemask_t nodes;\n\tunsigned short flags;\n\n\tflags = mode & MPOL_MODE_FLAGS;\n\tmode &= ~MPOL_MODE_FLAGS;\n\tif ((unsigned int)mode >= MPOL_MAX)\n\t\treturn -EINVAL;\n\tif ((flags & MPOL_F_STATIC_NODES) && (flags & MPOL_F_RELATIVE_NODES))\n\t\treturn -EINVAL;\n\terr = get_nodes(&nodes, nmask, maxnode);\n\tif (err)\n\t\treturn err;\n\treturn do_set_mempolicy(mode, flags, &nodes);\n}\n\nSYSCALL_DEFINE4(migrate_pages, pid_t, pid, unsigned long, maxnode,\n\t\tconst unsigned long __user *, old_nodes,\n\t\tconst unsigned long __user *, new_nodes)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tstruct mm_struct *mm = NULL;\n\tstruct task_struct *task;\n\tnodemask_t task_nodes;\n\tint err;\n\tnodemask_t *old;\n\tnodemask_t *new;\n\tNODEMASK_SCRATCH(scratch);\n\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\told = &scratch->mask1;\n\tnew = &scratch->mask2;\n\n\terr = get_nodes(old, old_nodes, maxnode);\n\tif (err)\n\t\tgoto out;\n\n\terr = get_nodes(new, new_nodes, maxnode);\n\tif (err)\n\t\tgoto out;\n\n\t/* Find the mm_struct */\n\trcu_read_lock();\n\ttask = pid ? find_task_by_vpid(pid) : current;\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\terr = -ESRCH;\n\t\tgoto out;\n\t}\n\tget_task_struct(task);\n\n\terr = -EINVAL;\n\n\t/*\n\t * Check if this process has the right to modify the specified\n\t * process. The right exists if the process has administrative\n\t * capabilities, superuser privileges or the same\n\t * userid as the target process.\n\t */\n\ttcred = __task_cred(task);\n\tif (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&\n\t    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&\n\t    !capable(CAP_SYS_NICE)) {\n\t\trcu_read_unlock();\n\t\terr = -EPERM;\n\t\tgoto out_put;\n\t}\n\trcu_read_unlock();\n\n\ttask_nodes = cpuset_mems_allowed(task);\n\t/* Is the user allowed to access the target nodes? */\n\tif (!nodes_subset(*new, task_nodes) && !capable(CAP_SYS_NICE)) {\n\t\terr = -EPERM;\n\t\tgoto out_put;\n\t}\n\n\tif (!nodes_subset(*new, node_states[N_MEMORY])) {\n\t\terr = -EINVAL;\n\t\tgoto out_put;\n\t}\n\n\terr = security_task_movememory(task);\n\tif (err)\n\t\tgoto out_put;\n\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\n\tif (!mm) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = do_migrate_pages(mm, old, new,\n\t\tcapable(CAP_SYS_NICE) ? MPOL_MF_MOVE_ALL : MPOL_MF_MOVE);\n\n\tmmput(mm);\nout:\n\tNODEMASK_SCRATCH_FREE(scratch);\n\n\treturn err;\n\nout_put:\n\tput_task_struct(task);\n\tgoto out;\n\n}\n\n\n/* Retrieve NUMA policy */\nSYSCALL_DEFINE5(get_mempolicy, int __user *, policy,\n\t\tunsigned long __user *, nmask, unsigned long, maxnode,\n\t\tunsigned long, addr, unsigned long, flags)\n{\n\tint err;\n\tint uninitialized_var(pval);\n\tnodemask_t nodes;\n\n\tif (nmask != NULL && maxnode < MAX_NUMNODES)\n\t\treturn -EINVAL;\n\n\terr = do_get_mempolicy(&pval, &nodes, addr, flags);\n\n\tif (err)\n\t\treturn err;\n\n\tif (policy && put_user(pval, policy))\n\t\treturn -EFAULT;\n\n\tif (nmask)\n\t\terr = copy_nodes_to_user(nmask, maxnode, &nodes);\n\n\treturn err;\n}\n\n#ifdef CONFIG_COMPAT\n\nCOMPAT_SYSCALL_DEFINE5(get_mempolicy, int __user *, policy,\n\t\t       compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode,\n\t\t       compat_ulong_t, addr, compat_ulong_t, flags)\n{\n\tlong err;\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tDECLARE_BITMAP(bm, MAX_NUMNODES);\n\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\n\tif (nmask)\n\t\tnm = compat_alloc_user_space(alloc_size);\n\n\terr = sys_get_mempolicy(policy, nm, nr_bits+1, addr, flags);\n\n\tif (!err && nmask) {\n\t\tunsigned long copy_size;\n\t\tcopy_size = min_t(unsigned long, sizeof(bm), alloc_size);\n\t\terr = copy_from_user(bm, nm, copy_size);\n\t\t/* ensure entire bitmap is zeroed */\n\t\terr |= clear_user(nmask, ALIGN(maxnode-1, 8) / 8);\n\t\terr |= compat_put_bitmap(nmask, bm, nr_bits);\n\t}\n\n\treturn err;\n}\n\nCOMPAT_SYSCALL_DEFINE3(set_mempolicy, int, mode, compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode)\n{\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tDECLARE_BITMAP(bm, MAX_NUMNODES);\n\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\n\tif (nmask) {\n\t\tif (compat_get_bitmap(bm, nmask, nr_bits))\n\t\t\treturn -EFAULT;\n\t\tnm = compat_alloc_user_space(alloc_size);\n\t\tif (copy_to_user(nm, bm, alloc_size))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn sys_set_mempolicy(mode, nm, nr_bits+1);\n}\n\nCOMPAT_SYSCALL_DEFINE6(mbind, compat_ulong_t, start, compat_ulong_t, len,\n\t\t       compat_ulong_t, mode, compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode, compat_ulong_t, flags)\n{\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tnodemask_t bm;\n\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\n\tif (nmask) {\n\t\tif (compat_get_bitmap(nodes_addr(bm), nmask, nr_bits))\n\t\t\treturn -EFAULT;\n\t\tnm = compat_alloc_user_space(alloc_size);\n\t\tif (copy_to_user(nm, nodes_addr(bm), alloc_size))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn sys_mbind(start, len, mode, nm, nr_bits+1, flags);\n}\n\n#endif\n\nstruct mempolicy *__get_vma_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr)\n{\n\tstruct mempolicy *pol = NULL;\n\n\tif (vma) {\n\t\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\t\tpol = vma->vm_ops->get_policy(vma, addr);\n\t\t} else if (vma->vm_policy) {\n\t\t\tpol = vma->vm_policy;\n\n\t\t\t/*\n\t\t\t * shmem_alloc_page() passes MPOL_F_SHARED policy with\n\t\t\t * a pseudo vma whose vma->vm_ops=NULL. Take a reference\n\t\t\t * count on these policies which will be dropped by\n\t\t\t * mpol_cond_put() later\n\t\t\t */\n\t\t\tif (mpol_needs_cond_ref(pol))\n\t\t\t\tmpol_get(pol);\n\t\t}\n\t}\n\n\treturn pol;\n}\n\n/*\n * get_vma_policy(@vma, @addr)\n * @vma: virtual memory area whose policy is sought\n * @addr: address in @vma for shared policy lookup\n *\n * Returns effective policy for a VMA at specified address.\n * Falls back to current->mempolicy or system default policy, as necessary.\n * Shared policies [those marked as MPOL_F_SHARED] require an extra reference\n * count--added by the get_policy() vm_op, as appropriate--to protect against\n * freeing by another task.  It is the caller's responsibility to free the\n * extra reference for shared policies.\n */\nstatic struct mempolicy *get_vma_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr)\n{\n\tstruct mempolicy *pol = __get_vma_policy(vma, addr);\n\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol;\n}\n\nbool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}\n\nstatic int apply_policy_zone(struct mempolicy *policy, enum zone_type zone)\n{\n\tenum zone_type dynamic_policy_zone = policy_zone;\n\n\tBUG_ON(dynamic_policy_zone == ZONE_MOVABLE);\n\n\t/*\n\t * if policy->v.nodes has movable memory only,\n\t * we apply policy when gfp_zone(gfp) = ZONE_MOVABLE only.\n\t *\n\t * policy->v.nodes is intersect with node_states[N_MEMORY].\n\t * so if the following test faile, it implies\n\t * policy->v.nodes has movable memory only.\n\t */\n\tif (!nodes_intersects(policy->v.nodes, node_states[N_HIGH_MEMORY]))\n\t\tdynamic_policy_zone = ZONE_MOVABLE;\n\n\treturn zone >= dynamic_policy_zone;\n}\n\n/*\n * Return a nodemask representing a mempolicy for filtering nodes for\n * page allocation\n */\nstatic nodemask_t *policy_nodemask(gfp_t gfp, struct mempolicy *policy)\n{\n\t/* Lower zones don't get a nodemask applied for MPOL_BIND */\n\tif (unlikely(policy->mode == MPOL_BIND) &&\n\t\t\tapply_policy_zone(policy, gfp_zone(gfp)) &&\n\t\t\tcpuset_nodemask_valid_mems_allowed(&policy->v.nodes))\n\t\treturn &policy->v.nodes;\n\n\treturn NULL;\n}\n\n/* Return a zonelist indicated by gfp for node representing a mempolicy */\nstatic struct zonelist *policy_zonelist(gfp_t gfp, struct mempolicy *policy,\n\tint nd)\n{\n\tif (policy->mode == MPOL_PREFERRED && !(policy->flags & MPOL_F_LOCAL))\n\t\tnd = policy->v.preferred_node;\n\telse {\n\t\t/*\n\t\t * __GFP_THISNODE shouldn't even be used with the bind policy\n\t\t * because we might easily break the expectation to stay on the\n\t\t * requested node and not break the policy.\n\t\t */\n\t\tWARN_ON_ONCE(policy->mode == MPOL_BIND && (gfp & __GFP_THISNODE));\n\t}\n\n\treturn node_zonelist(nd, gfp);\n}\n\n/* Do dynamic interleaving for a process */\nstatic unsigned interleave_nodes(struct mempolicy *policy)\n{\n\tunsigned nid, next;\n\tstruct task_struct *me = current;\n\n\tnid = me->il_next;\n\tnext = next_node_in(nid, policy->v.nodes);\n\tif (next < MAX_NUMNODES)\n\t\tme->il_next = next;\n\treturn nid;\n}\n\n/*\n * Depending on the memory policy provide a node from which to allocate the\n * next slab entry.\n */\nunsigned int mempolicy_slab_node(void)\n{\n\tstruct mempolicy *policy;\n\tint node = numa_mem_id();\n\n\tif (in_interrupt())\n\t\treturn node;\n\n\tpolicy = current->mempolicy;\n\tif (!policy || policy->flags & MPOL_F_LOCAL)\n\t\treturn node;\n\n\tswitch (policy->mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * handled MPOL_F_LOCAL above\n\t\t */\n\t\treturn policy->v.preferred_node;\n\n\tcase MPOL_INTERLEAVE:\n\t\treturn interleave_nodes(policy);\n\n\tcase MPOL_BIND: {\n\t\tstruct zoneref *z;\n\n\t\t/*\n\t\t * Follow bind policy behavior and start allocation at the\n\t\t * first node.\n\t\t */\n\t\tstruct zonelist *zonelist;\n\t\tenum zone_type highest_zoneidx = gfp_zone(GFP_KERNEL);\n\t\tzonelist = &NODE_DATA(node)->node_zonelists[ZONELIST_FALLBACK];\n\t\tz = first_zones_zonelist(zonelist, highest_zoneidx,\n\t\t\t\t\t\t\t&policy->v.nodes);\n\t\treturn z->zone ? z->zone->node : node;\n\t}\n\n\tdefault:\n\t\tBUG();\n\t}\n}\n\n/*\n * Do static interleaving for a VMA with known offset @n.  Returns the n'th\n * node in pol->v.nodes (starting from n=0), wrapping around if n exceeds the\n * number of present nodes.\n */\nstatic unsigned offset_il_node(struct mempolicy *pol,\n\t\t\t       struct vm_area_struct *vma, unsigned long n)\n{\n\tunsigned nnodes = nodes_weight(pol->v.nodes);\n\tunsigned target;\n\tint i;\n\tint nid;\n\n\tif (!nnodes)\n\t\treturn numa_node_id();\n\ttarget = (unsigned int)n % nnodes;\n\tnid = first_node(pol->v.nodes);\n\tfor (i = 0; i < target; i++)\n\t\tnid = next_node(nid, pol->v.nodes);\n\treturn nid;\n}\n\n/* Determine a node number for interleave */\nstatic inline unsigned interleave_nid(struct mempolicy *pol,\n\t\t struct vm_area_struct *vma, unsigned long addr, int shift)\n{\n\tif (vma) {\n\t\tunsigned long off;\n\n\t\t/*\n\t\t * for small pages, there is no difference between\n\t\t * shift and PAGE_SHIFT, so the bit-shift is safe.\n\t\t * for huge pages, since vm_pgoff is in units of small\n\t\t * pages, we need to shift off the always 0 bits to get\n\t\t * a useful offset.\n\t\t */\n\t\tBUG_ON(shift < PAGE_SHIFT);\n\t\toff = vma->vm_pgoff >> (shift - PAGE_SHIFT);\n\t\toff += (addr - vma->vm_start) >> shift;\n\t\treturn offset_il_node(pol, vma, off);\n\t} else\n\t\treturn interleave_nodes(pol);\n}\n\n#ifdef CONFIG_HUGETLBFS\n/*\n * huge_zonelist(@vma, @addr, @gfp_flags, @mpol)\n * @vma: virtual memory area whose policy is sought\n * @addr: address in @vma for shared policy lookup and interleave policy\n * @gfp_flags: for requested zone\n * @mpol: pointer to mempolicy pointer for reference counted mempolicy\n * @nodemask: pointer to nodemask pointer for MPOL_BIND nodemask\n *\n * Returns a zonelist suitable for a huge page allocation and a pointer\n * to the struct mempolicy for conditional unref after allocation.\n * If the effective policy is 'BIND, returns a pointer to the mempolicy's\n * @nodemask for filtering the zonelist.\n *\n * Must be protected by read_mems_allowed_begin()\n */\nstruct zonelist *huge_zonelist(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tgfp_t gfp_flags, struct mempolicy **mpol,\n\t\t\t\tnodemask_t **nodemask)\n{\n\tstruct zonelist *zl;\n\n\t*mpol = get_vma_policy(vma, addr);\n\t*nodemask = NULL;\t/* assume !MPOL_BIND */\n\n\tif (unlikely((*mpol)->mode == MPOL_INTERLEAVE)) {\n\t\tzl = node_zonelist(interleave_nid(*mpol, vma, addr,\n\t\t\t\thuge_page_shift(hstate_vma(vma))), gfp_flags);\n\t} else {\n\t\tzl = policy_zonelist(gfp_flags, *mpol, numa_node_id());\n\t\tif ((*mpol)->mode == MPOL_BIND)\n\t\t\t*nodemask = &(*mpol)->v.nodes;\n\t}\n\treturn zl;\n}\n\n/*\n * init_nodemask_of_mempolicy\n *\n * If the current task's mempolicy is \"default\" [NULL], return 'false'\n * to indicate default policy.  Otherwise, extract the policy nodemask\n * for 'bind' or 'interleave' policy into the argument nodemask, or\n * initialize the argument nodemask to contain the single node for\n * 'preferred' or 'local' policy and return 'true' to indicate presence\n * of non-default mempolicy.\n *\n * We don't bother with reference counting the mempolicy [mpol_get/put]\n * because the current task is examining it's own mempolicy and a task's\n * mempolicy is only ever changed by the task itself.\n *\n * N.B., it is the caller's responsibility to free a returned nodemask.\n */\nbool init_nodemask_of_mempolicy(nodemask_t *mask)\n{\n\tstruct mempolicy *mempolicy;\n\tint nid;\n\n\tif (!(mask && current->mempolicy))\n\t\treturn false;\n\n\ttask_lock(current);\n\tmempolicy = current->mempolicy;\n\tswitch (mempolicy->mode) {\n\tcase MPOL_PREFERRED:\n\t\tif (mempolicy->flags & MPOL_F_LOCAL)\n\t\t\tnid = numa_node_id();\n\t\telse\n\t\t\tnid = mempolicy->v.preferred_node;\n\t\tinit_nodemask_of_node(mask, nid);\n\t\tbreak;\n\n\tcase MPOL_BIND:\n\t\t/* Fall through */\n\tcase MPOL_INTERLEAVE:\n\t\t*mask =  mempolicy->v.nodes;\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\ttask_unlock(current);\n\n\treturn true;\n}\n#endif\n\n/*\n * mempolicy_nodemask_intersects\n *\n * If tsk's mempolicy is \"default\" [NULL], return 'true' to indicate default\n * policy.  Otherwise, check for intersection between mask and the policy\n * nodemask for 'bind' or 'interleave' policy.  For 'perferred' or 'local'\n * policy, always return true since it may allocate elsewhere on fallback.\n *\n * Takes task_lock(tsk) to prevent freeing of its mempolicy.\n */\nbool mempolicy_nodemask_intersects(struct task_struct *tsk,\n\t\t\t\t\tconst nodemask_t *mask)\n{\n\tstruct mempolicy *mempolicy;\n\tbool ret = true;\n\n\tif (!mask)\n\t\treturn ret;\n\ttask_lock(tsk);\n\tmempolicy = tsk->mempolicy;\n\tif (!mempolicy)\n\t\tgoto out;\n\n\tswitch (mempolicy->mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * MPOL_PREFERRED and MPOL_F_LOCAL are only preferred nodes to\n\t\t * allocate from, they may fallback to other nodes when oom.\n\t\t * Thus, it's possible for tsk to have allocated memory from\n\t\t * nodes in mask.\n\t\t */\n\t\tbreak;\n\tcase MPOL_BIND:\n\tcase MPOL_INTERLEAVE:\n\t\tret = nodes_intersects(mempolicy->v.nodes, *mask);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\nout:\n\ttask_unlock(tsk);\n\treturn ret;\n}\n\n/* Allocate a page in interleaved policy.\n   Own path because it needs to do special accounting. */\nstatic struct page *alloc_page_interleave(gfp_t gfp, unsigned order,\n\t\t\t\t\tunsigned nid)\n{\n\tstruct zonelist *zl;\n\tstruct page *page;\n\n\tzl = node_zonelist(nid, gfp);\n\tpage = __alloc_pages(gfp, order, zl);\n\tif (page && page_zone(page) == zonelist_zone(&zl->_zonerefs[0]))\n\t\tinc_zone_page_state(page, NUMA_INTERLEAVE_HIT);\n\treturn page;\n}\n\n/**\n * \talloc_pages_vma\t- Allocate a page for a VMA.\n *\n * \t@gfp:\n *      %GFP_USER    user allocation.\n *      %GFP_KERNEL  kernel allocations,\n *      %GFP_HIGHMEM highmem/user allocations,\n *      %GFP_FS      allocation should not call back into a file system.\n *      %GFP_ATOMIC  don't sleep.\n *\n *\t@order:Order of the GFP allocation.\n * \t@vma:  Pointer to VMA or NULL if not available.\n *\t@addr: Virtual Address of the allocation. Must be inside the VMA.\n *\t@node: Which node to prefer for allocation (modulo policy).\n *\t@hugepage: for hugepages try only the preferred node if possible\n *\n * \tThis function allocates a page from the kernel page pool and applies\n *\ta NUMA policy associated with the VMA or the current process.\n *\tWhen VMA is not NULL caller must hold down_read on the mmap_sem of the\n *\tmm_struct of the VMA to prevent it from going away. Should be used for\n *\tall allocations for pages that will be mapped into user space. Returns\n *\tNULL when no page can be allocated.\n */\nstruct page *\nalloc_pages_vma(gfp_t gfp, int order, struct vm_area_struct *vma,\n\t\tunsigned long addr, int node, bool hugepage)\n{\n\tstruct mempolicy *pol;\n\tstruct page *page;\n\tunsigned int cpuset_mems_cookie;\n\tstruct zonelist *zl;\n\tnodemask_t *nmask;\n\nretry_cpuset:\n\tpol = get_vma_policy(vma, addr);\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\n\tif (pol->mode == MPOL_INTERLEAVE) {\n\t\tunsigned nid;\n\n\t\tnid = interleave_nid(pol, vma, addr, PAGE_SHIFT + order);\n\t\tmpol_cond_put(pol);\n\t\tpage = alloc_page_interleave(gfp, order, nid);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE) && hugepage)) {\n\t\tint hpage_node = node;\n\n\t\t/*\n\t\t * For hugepage allocation and non-interleave policy which\n\t\t * allows the current node (or other explicitly preferred\n\t\t * node) we only try to allocate from the current/preferred\n\t\t * node and don't fall back to other nodes, as the cost of\n\t\t * remote accesses would likely offset THP benefits.\n\t\t *\n\t\t * If the policy is interleave, or does not allow the current\n\t\t * node in its nodemask, we allocate the standard way.\n\t\t */\n\t\tif (pol->mode == MPOL_PREFERRED &&\n\t\t\t\t\t\t!(pol->flags & MPOL_F_LOCAL))\n\t\t\thpage_node = pol->v.preferred_node;\n\n\t\tnmask = policy_nodemask(gfp, pol);\n\t\tif (!nmask || node_isset(hpage_node, *nmask)) {\n\t\t\tmpol_cond_put(pol);\n\t\t\tpage = __alloc_pages_node(hpage_node,\n\t\t\t\t\t\tgfp | __GFP_THISNODE, order);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnmask = policy_nodemask(gfp, pol);\n\tzl = policy_zonelist(gfp, pol, node);\n\tpage = __alloc_pages_nodemask(gfp, order, zl, nmask);\n\tmpol_cond_put(pol);\nout:\n\tif (unlikely(!page && read_mems_allowed_retry(cpuset_mems_cookie)))\n\t\tgoto retry_cpuset;\n\treturn page;\n}\n\n/**\n * \talloc_pages_current - Allocate pages.\n *\n *\t@gfp:\n *\t\t%GFP_USER   user allocation,\n *      \t%GFP_KERNEL kernel allocation,\n *      \t%GFP_HIGHMEM highmem allocation,\n *      \t%GFP_FS     don't call back into a file system.\n *      \t%GFP_ATOMIC don't sleep.\n *\t@order: Power of two of allocation size in pages. 0 is a single page.\n *\n *\tAllocate a page from the kernel page pool.  When not in\n *\tinterrupt context and apply the current process NUMA policy.\n *\tReturns NULL when no page can be allocated.\n *\n *\tDon't call cpuset_update_task_memory_state() unless\n *\t1) it's ok to take cpuset_sem (can WAIT), and\n *\t2) allocating for current task (not interrupt).\n */\nstruct page *alloc_pages_current(gfp_t gfp, unsigned order)\n{\n\tstruct mempolicy *pol = &default_policy;\n\tstruct page *page;\n\tunsigned int cpuset_mems_cookie;\n\n\tif (!in_interrupt() && !(gfp & __GFP_THISNODE))\n\t\tpol = get_task_policy(current);\n\nretry_cpuset:\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\n\t/*\n\t * No reference counting needed for current->mempolicy\n\t * nor system default_policy\n\t */\n\tif (pol->mode == MPOL_INTERLEAVE)\n\t\tpage = alloc_page_interleave(gfp, order, interleave_nodes(pol));\n\telse\n\t\tpage = __alloc_pages_nodemask(gfp, order,\n\t\t\t\tpolicy_zonelist(gfp, pol, numa_node_id()),\n\t\t\t\tpolicy_nodemask(gfp, pol));\n\n\tif (unlikely(!page && read_mems_allowed_retry(cpuset_mems_cookie)))\n\t\tgoto retry_cpuset;\n\n\treturn page;\n}\nEXPORT_SYMBOL(alloc_pages_current);\n\nint vma_dup_policy(struct vm_area_struct *src, struct vm_area_struct *dst)\n{\n\tstruct mempolicy *pol = mpol_dup(vma_policy(src));\n\n\tif (IS_ERR(pol))\n\t\treturn PTR_ERR(pol);\n\tdst->vm_policy = pol;\n\treturn 0;\n}\n\n/*\n * If mpol_dup() sees current->cpuset == cpuset_being_rebound, then it\n * rebinds the mempolicy its copying by calling mpol_rebind_policy()\n * with the mems_allowed returned by cpuset_mems_allowed().  This\n * keeps mempolicies cpuset relative after its cpuset moves.  See\n * further kernel/cpuset.c update_nodemask().\n *\n * current's mempolicy may be rebinded by the other task(the task that changes\n * cpuset's mems), so we needn't do rebind work for current task.\n */\n\n/* Slow path of a mempolicy duplicate */\nstruct mempolicy *__mpol_dup(struct mempolicy *old)\n{\n\tstruct mempolicy *new = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\n\tif (!new)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* task's mempolicy is protected by alloc_lock */\n\tif (old == current->mempolicy) {\n\t\ttask_lock(current);\n\t\t*new = *old;\n\t\ttask_unlock(current);\n\t} else\n\t\t*new = *old;\n\n\tif (current_cpuset_is_being_rebound()) {\n\t\tnodemask_t mems = cpuset_mems_allowed(current);\n\t\tif (new->flags & MPOL_F_REBINDING)\n\t\t\tmpol_rebind_policy(new, &mems, MPOL_REBIND_STEP2);\n\t\telse\n\t\t\tmpol_rebind_policy(new, &mems, MPOL_REBIND_ONCE);\n\t}\n\tatomic_set(&new->refcnt, 1);\n\treturn new;\n}\n\n/* Slow path of a mempolicy comparison */\nbool __mpol_equal(struct mempolicy *a, struct mempolicy *b)\n{\n\tif (!a || !b)\n\t\treturn false;\n\tif (a->mode != b->mode)\n\t\treturn false;\n\tif (a->flags != b->flags)\n\t\treturn false;\n\tif (mpol_store_user_nodemask(a))\n\t\tif (!nodes_equal(a->w.user_nodemask, b->w.user_nodemask))\n\t\t\treturn false;\n\n\tswitch (a->mode) {\n\tcase MPOL_BIND:\n\t\t/* Fall through */\n\tcase MPOL_INTERLEAVE:\n\t\treturn !!nodes_equal(a->v.nodes, b->v.nodes);\n\tcase MPOL_PREFERRED:\n\t\treturn a->v.preferred_node == b->v.preferred_node;\n\tdefault:\n\t\tBUG();\n\t\treturn false;\n\t}\n}\n\n/*\n * Shared memory backing store policy support.\n *\n * Remember policies even when nobody has shared memory mapped.\n * The policies are kept in Red-Black tree linked from the inode.\n * They are protected by the sp->lock rwlock, which should be held\n * for any accesses to the tree.\n */\n\n/*\n * lookup first element intersecting start-end.  Caller holds sp->lock for\n * reading or for writing\n */\nstatic struct sp_node *\nsp_lookup(struct shared_policy *sp, unsigned long start, unsigned long end)\n{\n\tstruct rb_node *n = sp->root.rb_node;\n\n\twhile (n) {\n\t\tstruct sp_node *p = rb_entry(n, struct sp_node, nd);\n\n\t\tif (start >= p->end)\n\t\t\tn = n->rb_right;\n\t\telse if (end <= p->start)\n\t\t\tn = n->rb_left;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!n)\n\t\treturn NULL;\n\tfor (;;) {\n\t\tstruct sp_node *w = NULL;\n\t\tstruct rb_node *prev = rb_prev(n);\n\t\tif (!prev)\n\t\t\tbreak;\n\t\tw = rb_entry(prev, struct sp_node, nd);\n\t\tif (w->end <= start)\n\t\t\tbreak;\n\t\tn = prev;\n\t}\n\treturn rb_entry(n, struct sp_node, nd);\n}\n\n/*\n * Insert a new shared policy into the list.  Caller holds sp->lock for\n * writing.\n */\nstatic void sp_insert(struct shared_policy *sp, struct sp_node *new)\n{\n\tstruct rb_node **p = &sp->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct sp_node *nd;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tnd = rb_entry(parent, struct sp_node, nd);\n\t\tif (new->start < nd->start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new->end > nd->end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\trb_link_node(&new->nd, parent, p);\n\trb_insert_color(&new->nd, &sp->root);\n\tpr_debug(\"inserting %lx-%lx: %d\\n\", new->start, new->end,\n\t\t new->policy ? new->policy->mode : 0);\n}\n\n/* Find shared policy intersecting idx */\nstruct mempolicy *\nmpol_shared_policy_lookup(struct shared_policy *sp, unsigned long idx)\n{\n\tstruct mempolicy *pol = NULL;\n\tstruct sp_node *sn;\n\n\tif (!sp->root.rb_node)\n\t\treturn NULL;\n\tread_lock(&sp->lock);\n\tsn = sp_lookup(sp, idx, idx+1);\n\tif (sn) {\n\t\tmpol_get(sn->policy);\n\t\tpol = sn->policy;\n\t}\n\tread_unlock(&sp->lock);\n\treturn pol;\n}\n\nstatic void sp_free(struct sp_node *n)\n{\n\tmpol_put(n->policy);\n\tkmem_cache_free(sn_cache, n);\n}\n\n/**\n * mpol_misplaced - check whether current page node is valid in policy\n *\n * @page: page to be checked\n * @vma: vm area where page mapped\n * @addr: virtual address where page mapped\n *\n * Lookup current policy node id for vma,addr and \"compare to\" page's\n * node id.\n *\n * Returns:\n *\t-1\t- not misplaced, page is in the right node\n *\tnode\t- node id where the page should be\n *\n * Policy determination \"mimics\" alloc_page_vma().\n * Called from fault path where we know the vma and faulting address.\n */\nint mpol_misplaced(struct page *page, struct vm_area_struct *vma, unsigned long addr)\n{\n\tstruct mempolicy *pol;\n\tstruct zoneref *z;\n\tint curnid = page_to_nid(page);\n\tunsigned long pgoff;\n\tint thiscpu = raw_smp_processor_id();\n\tint thisnid = cpu_to_node(thiscpu);\n\tint polnid = -1;\n\tint ret = -1;\n\n\tBUG_ON(!vma);\n\n\tpol = get_vma_policy(vma, addr);\n\tif (!(pol->flags & MPOL_F_MOF))\n\t\tgoto out;\n\n\tswitch (pol->mode) {\n\tcase MPOL_INTERLEAVE:\n\t\tBUG_ON(addr >= vma->vm_end);\n\t\tBUG_ON(addr < vma->vm_start);\n\n\t\tpgoff = vma->vm_pgoff;\n\t\tpgoff += (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\tpolnid = offset_il_node(pol, vma, pgoff);\n\t\tbreak;\n\n\tcase MPOL_PREFERRED:\n\t\tif (pol->flags & MPOL_F_LOCAL)\n\t\t\tpolnid = numa_node_id();\n\t\telse\n\t\t\tpolnid = pol->v.preferred_node;\n\t\tbreak;\n\n\tcase MPOL_BIND:\n\n\t\t/*\n\t\t * allows binding to multiple nodes.\n\t\t * use current page if in policy nodemask,\n\t\t * else select nearest allowed node, if any.\n\t\t * If no allowed nodes, use current [!misplaced].\n\t\t */\n\t\tif (node_isset(curnid, pol->v.nodes))\n\t\t\tgoto out;\n\t\tz = first_zones_zonelist(\n\t\t\t\tnode_zonelist(numa_node_id(), GFP_HIGHUSER),\n\t\t\t\tgfp_zone(GFP_HIGHUSER),\n\t\t\t\t&pol->v.nodes);\n\t\tpolnid = z->zone->node;\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/* Migrate the page towards the node whose CPU is referencing it */\n\tif (pol->flags & MPOL_F_MORON) {\n\t\tpolnid = thisnid;\n\n\t\tif (!should_numa_migrate_memory(current, page, curnid, thiscpu))\n\t\t\tgoto out;\n\t}\n\n\tif (curnid != polnid)\n\t\tret = polnid;\nout:\n\tmpol_cond_put(pol);\n\n\treturn ret;\n}\n\n/*\n * Drop the (possibly final) reference to task->mempolicy.  It needs to be\n * dropped after task->mempolicy is set to NULL so that any allocation done as\n * part of its kmem_cache_free(), such as by KASAN, doesn't reference a freed\n * policy.\n */\nvoid mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}\n\nstatic void sp_delete(struct shared_policy *sp, struct sp_node *n)\n{\n\tpr_debug(\"deleting %lx-l%lx\\n\", n->start, n->end);\n\trb_erase(&n->nd, &sp->root);\n\tsp_free(n);\n}\n\nstatic void sp_node_init(struct sp_node *node, unsigned long start,\n\t\t\tunsigned long end, struct mempolicy *pol)\n{\n\tnode->start = start;\n\tnode->end = end;\n\tnode->policy = pol;\n}\n\nstatic struct sp_node *sp_alloc(unsigned long start, unsigned long end,\n\t\t\t\tstruct mempolicy *pol)\n{\n\tstruct sp_node *n;\n\tstruct mempolicy *newpol;\n\n\tn = kmem_cache_alloc(sn_cache, GFP_KERNEL);\n\tif (!n)\n\t\treturn NULL;\n\n\tnewpol = mpol_dup(pol);\n\tif (IS_ERR(newpol)) {\n\t\tkmem_cache_free(sn_cache, n);\n\t\treturn NULL;\n\t}\n\tnewpol->flags |= MPOL_F_SHARED;\n\tsp_node_init(n, start, end, newpol);\n\n\treturn n;\n}\n\n/* Replace a policy range. */\nstatic int shared_policy_replace(struct shared_policy *sp, unsigned long start,\n\t\t\t\t unsigned long end, struct sp_node *new)\n{\n\tstruct sp_node *n;\n\tstruct sp_node *n_new = NULL;\n\tstruct mempolicy *mpol_new = NULL;\n\tint ret = 0;\n\nrestart:\n\twrite_lock(&sp->lock);\n\tn = sp_lookup(sp, start, end);\n\t/* Take care of old policies in the same range. */\n\twhile (n && n->start < end) {\n\t\tstruct rb_node *next = rb_next(&n->nd);\n\t\tif (n->start >= start) {\n\t\t\tif (n->end <= end)\n\t\t\t\tsp_delete(sp, n);\n\t\t\telse\n\t\t\t\tn->start = end;\n\t\t} else {\n\t\t\t/* Old policy spanning whole new range. */\n\t\t\tif (n->end > end) {\n\t\t\t\tif (!n_new)\n\t\t\t\t\tgoto alloc_new;\n\n\t\t\t\t*mpol_new = *n->policy;\n\t\t\t\tatomic_set(&mpol_new->refcnt, 1);\n\t\t\t\tsp_node_init(n_new, end, n->end, mpol_new);\n\t\t\t\tn->end = start;\n\t\t\t\tsp_insert(sp, n_new);\n\t\t\t\tn_new = NULL;\n\t\t\t\tmpol_new = NULL;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tn->end = start;\n\t\t}\n\t\tif (!next)\n\t\t\tbreak;\n\t\tn = rb_entry(next, struct sp_node, nd);\n\t}\n\tif (new)\n\t\tsp_insert(sp, new);\n\twrite_unlock(&sp->lock);\n\tret = 0;\n\nerr_out:\n\tif (mpol_new)\n\t\tmpol_put(mpol_new);\n\tif (n_new)\n\t\tkmem_cache_free(sn_cache, n_new);\n\n\treturn ret;\n\nalloc_new:\n\twrite_unlock(&sp->lock);\n\tret = -ENOMEM;\n\tn_new = kmem_cache_alloc(sn_cache, GFP_KERNEL);\n\tif (!n_new)\n\t\tgoto err_out;\n\tmpol_new = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\tif (!mpol_new)\n\t\tgoto err_out;\n\tgoto restart;\n}\n\n/**\n * mpol_shared_policy_init - initialize shared policy for inode\n * @sp: pointer to inode shared policy\n * @mpol:  struct mempolicy to install\n *\n * Install non-NULL @mpol in inode's shared policy rb-tree.\n * On entry, the current task has a reference on a non-NULL @mpol.\n * This must be released on exit.\n * This is called at get_inode() calls and we can use GFP_KERNEL.\n */\nvoid mpol_shared_policy_init(struct shared_policy *sp, struct mempolicy *mpol)\n{\n\tint ret;\n\n\tsp->root = RB_ROOT;\t\t/* empty tree == default mempolicy */\n\trwlock_init(&sp->lock);\n\n\tif (mpol) {\n\t\tstruct vm_area_struct pvma;\n\t\tstruct mempolicy *new;\n\t\tNODEMASK_SCRATCH(scratch);\n\n\t\tif (!scratch)\n\t\t\tgoto put_mpol;\n\t\t/* contextualize the tmpfs mount point mempolicy */\n\t\tnew = mpol_new(mpol->mode, mpol->flags, &mpol->w.user_nodemask);\n\t\tif (IS_ERR(new))\n\t\t\tgoto free_scratch; /* no valid nodemask intersection */\n\n\t\ttask_lock(current);\n\t\tret = mpol_set_nodemask(new, &mpol->w.user_nodemask, scratch);\n\t\ttask_unlock(current);\n\t\tif (ret)\n\t\t\tgoto put_new;\n\n\t\t/* Create pseudo-vma that contains just the policy */\n\t\tmemset(&pvma, 0, sizeof(struct vm_area_struct));\n\t\tpvma.vm_end = TASK_SIZE;\t/* policy covers entire file */\n\t\tmpol_set_shared_policy(sp, &pvma, new); /* adds ref */\n\nput_new:\n\t\tmpol_put(new);\t\t\t/* drop initial ref */\nfree_scratch:\n\t\tNODEMASK_SCRATCH_FREE(scratch);\nput_mpol:\n\t\tmpol_put(mpol);\t/* drop our incoming ref on sb mpol */\n\t}\n}\n\nint mpol_set_shared_policy(struct shared_policy *info,\n\t\t\tstruct vm_area_struct *vma, struct mempolicy *npol)\n{\n\tint err;\n\tstruct sp_node *new = NULL;\n\tunsigned long sz = vma_pages(vma);\n\n\tpr_debug(\"set_shared_policy %lx sz %lu %d %d %lx\\n\",\n\t\t vma->vm_pgoff,\n\t\t sz, npol ? npol->mode : -1,\n\t\t npol ? npol->flags : -1,\n\t\t npol ? nodes_addr(npol->v.nodes)[0] : NUMA_NO_NODE);\n\n\tif (npol) {\n\t\tnew = sp_alloc(vma->vm_pgoff, vma->vm_pgoff + sz, npol);\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t}\n\terr = shared_policy_replace(info, vma->vm_pgoff, vma->vm_pgoff+sz, new);\n\tif (err && new)\n\t\tsp_free(new);\n\treturn err;\n}\n\n/* Free a backing policy store on inode delete. */\nvoid mpol_free_shared_policy(struct shared_policy *p)\n{\n\tstruct sp_node *n;\n\tstruct rb_node *next;\n\n\tif (!p->root.rb_node)\n\t\treturn;\n\twrite_lock(&p->lock);\n\tnext = rb_first(&p->root);\n\twhile (next) {\n\t\tn = rb_entry(next, struct sp_node, nd);\n\t\tnext = rb_next(&n->nd);\n\t\tsp_delete(p, n);\n\t}\n\twrite_unlock(&p->lock);\n}\n\n#ifdef CONFIG_NUMA_BALANCING\nstatic int __initdata numabalancing_override;\n\nstatic void __init check_numabalancing_enable(void)\n{\n\tbool numabalancing_default = false;\n\n\tif (IS_ENABLED(CONFIG_NUMA_BALANCING_DEFAULT_ENABLED))\n\t\tnumabalancing_default = true;\n\n\t/* Parsed by setup_numabalancing. override == 1 enables, -1 disables */\n\tif (numabalancing_override)\n\t\tset_numabalancing_state(numabalancing_override == 1);\n\n\tif (num_online_nodes() > 1 && !numabalancing_override) {\n\t\tpr_info(\"%s automatic NUMA balancing. Configure with numa_balancing= or the kernel.numa_balancing sysctl\\n\",\n\t\t\tnumabalancing_default ? \"Enabling\" : \"Disabling\");\n\t\tset_numabalancing_state(numabalancing_default);\n\t}\n}\n\nstatic int __init setup_numabalancing(char *str)\n{\n\tint ret = 0;\n\tif (!str)\n\t\tgoto out;\n\n\tif (!strcmp(str, \"enable\")) {\n\t\tnumabalancing_override = 1;\n\t\tret = 1;\n\t} else if (!strcmp(str, \"disable\")) {\n\t\tnumabalancing_override = -1;\n\t\tret = 1;\n\t}\nout:\n\tif (!ret)\n\t\tpr_warn(\"Unable to parse numa_balancing=\\n\");\n\n\treturn ret;\n}\n__setup(\"numa_balancing=\", setup_numabalancing);\n#else\nstatic inline void __init check_numabalancing_enable(void)\n{\n}\n#endif /* CONFIG_NUMA_BALANCING */\n\n/* assumes fs == KERNEL_DS */\nvoid __init numa_policy_init(void)\n{\n\tnodemask_t interleave_nodes;\n\tunsigned long largest = 0;\n\tint nid, prefer = 0;\n\n\tpolicy_cache = kmem_cache_create(\"numa_policy\",\n\t\t\t\t\t sizeof(struct mempolicy),\n\t\t\t\t\t 0, SLAB_PANIC, NULL);\n\n\tsn_cache = kmem_cache_create(\"shared_policy_node\",\n\t\t\t\t     sizeof(struct sp_node),\n\t\t\t\t     0, SLAB_PANIC, NULL);\n\n\tfor_each_node(nid) {\n\t\tpreferred_node_policy[nid] = (struct mempolicy) {\n\t\t\t.refcnt = ATOMIC_INIT(1),\n\t\t\t.mode = MPOL_PREFERRED,\n\t\t\t.flags = MPOL_F_MOF | MPOL_F_MORON,\n\t\t\t.v = { .preferred_node = nid, },\n\t\t};\n\t}\n\n\t/*\n\t * Set interleaving policy for system init. Interleaving is only\n\t * enabled across suitably sized nodes (default is >= 16MB), or\n\t * fall back to the largest node if they're all smaller.\n\t */\n\tnodes_clear(interleave_nodes);\n\tfor_each_node_state(nid, N_MEMORY) {\n\t\tunsigned long total_pages = node_present_pages(nid);\n\n\t\t/* Preserve the largest node */\n\t\tif (largest < total_pages) {\n\t\t\tlargest = total_pages;\n\t\t\tprefer = nid;\n\t\t}\n\n\t\t/* Interleave this node? */\n\t\tif ((total_pages << PAGE_SHIFT) >= (16 << 20))\n\t\t\tnode_set(nid, interleave_nodes);\n\t}\n\n\t/* All too small, use the largest */\n\tif (unlikely(nodes_empty(interleave_nodes)))\n\t\tnode_set(prefer, interleave_nodes);\n\n\tif (do_set_mempolicy(MPOL_INTERLEAVE, 0, &interleave_nodes))\n\t\tpr_err(\"%s: interleaving failed\\n\", __func__);\n\n\tcheck_numabalancing_enable();\n}\n\n/* Reset policy of current process to default */\nvoid numa_default_policy(void)\n{\n\tdo_set_mempolicy(MPOL_DEFAULT, 0, NULL);\n}\n\n/*\n * Parse and format mempolicy from/to strings\n */\n\n/*\n * \"local\" is implemented internally by MPOL_PREFERRED with MPOL_F_LOCAL flag.\n */\nstatic const char * const policy_modes[] =\n{\n\t[MPOL_DEFAULT]    = \"default\",\n\t[MPOL_PREFERRED]  = \"prefer\",\n\t[MPOL_BIND]       = \"bind\",\n\t[MPOL_INTERLEAVE] = \"interleave\",\n\t[MPOL_LOCAL]      = \"local\",\n};\n\n\n#ifdef CONFIG_TMPFS\n/**\n * mpol_parse_str - parse string to mempolicy, for tmpfs mpol mount option.\n * @str:  string containing mempolicy to parse\n * @mpol:  pointer to struct mempolicy pointer, returned on success.\n *\n * Format of input:\n *\t<mode>[=<flags>][:<nodelist>]\n *\n * On success, returns 0, else 1\n */\nint mpol_parse_str(char *str, struct mempolicy **mpol)\n{\n\tstruct mempolicy *new = NULL;\n\tunsigned short mode;\n\tunsigned short mode_flags;\n\tnodemask_t nodes;\n\tchar *nodelist = strchr(str, ':');\n\tchar *flags = strchr(str, '=');\n\tint err = 1;\n\n\tif (nodelist) {\n\t\t/* NUL-terminate mode or flags string */\n\t\t*nodelist++ = '\\0';\n\t\tif (nodelist_parse(nodelist, nodes))\n\t\t\tgoto out;\n\t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))\n\t\t\tgoto out;\n\t} else\n\t\tnodes_clear(nodes);\n\n\tif (flags)\n\t\t*flags++ = '\\0';\t/* terminate mode string */\n\n\tfor (mode = 0; mode < MPOL_MAX; mode++) {\n\t\tif (!strcmp(str, policy_modes[mode])) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mode >= MPOL_MAX)\n\t\tgoto out;\n\n\tswitch (mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * Insist on a nodelist of one node only\n\t\t */\n\t\tif (nodelist) {\n\t\t\tchar *rest = nodelist;\n\t\t\twhile (isdigit(*rest))\n\t\t\t\trest++;\n\t\t\tif (*rest)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase MPOL_INTERLEAVE:\n\t\t/*\n\t\t * Default to online nodes with memory if no nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\tnodes = node_states[N_MEMORY];\n\t\tbreak;\n\tcase MPOL_LOCAL:\n\t\t/*\n\t\t * Don't allow a nodelist;  mpol_new() checks flags\n\t\t */\n\t\tif (nodelist)\n\t\t\tgoto out;\n\t\tmode = MPOL_PREFERRED;\n\t\tbreak;\n\tcase MPOL_DEFAULT:\n\t\t/*\n\t\t * Insist on a empty nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\terr = 0;\n\t\tgoto out;\n\tcase MPOL_BIND:\n\t\t/*\n\t\t * Insist on a nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\tgoto out;\n\t}\n\n\tmode_flags = 0;\n\tif (flags) {\n\t\t/*\n\t\t * Currently, we only support two mutually exclusive\n\t\t * mode flags.\n\t\t */\n\t\tif (!strcmp(flags, \"static\"))\n\t\t\tmode_flags |= MPOL_F_STATIC_NODES;\n\t\telse if (!strcmp(flags, \"relative\"))\n\t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;\n\t\telse\n\t\t\tgoto out;\n\t}\n\n\tnew = mpol_new(mode, mode_flags, &nodes);\n\tif (IS_ERR(new))\n\t\tgoto out;\n\n\t/*\n\t * Save nodes for mpol_to_str() to show the tmpfs mount options\n\t * for /proc/mounts, /proc/pid/mounts and /proc/pid/mountinfo.\n\t */\n\tif (mode != MPOL_PREFERRED)\n\t\tnew->v.nodes = nodes;\n\telse if (nodelist)\n\t\tnew->v.preferred_node = first_node(nodes);\n\telse\n\t\tnew->flags |= MPOL_F_LOCAL;\n\n\t/*\n\t * Save nodes for contextualization: this will be used to \"clone\"\n\t * the mempolicy in a specific context [cpuset] at a later time.\n\t */\n\tnew->w.user_nodemask = nodes;\n\n\terr = 0;\n\nout:\n\t/* Restore string for error message */\n\tif (nodelist)\n\t\t*--nodelist = ':';\n\tif (flags)\n\t\t*--flags = '=';\n\tif (!err)\n\t\t*mpol = new;\n\treturn err;\n}\n#endif /* CONFIG_TMPFS */\n\n/**\n * mpol_to_str - format a mempolicy structure for printing\n * @buffer:  to contain formatted mempolicy string\n * @maxlen:  length of @buffer\n * @pol:  pointer to mempolicy to be formatted\n *\n * Convert @pol into a string.  If @buffer is too short, truncate the string.\n * Recommend a @maxlen of at least 32 for the longest mode, \"interleave\", the\n * longest flag, \"relative\", and to display at least a few node ids.\n */\nvoid mpol_to_str(char *buffer, int maxlen, struct mempolicy *pol)\n{\n\tchar *p = buffer;\n\tnodemask_t nodes = NODE_MASK_NONE;\n\tunsigned short mode = MPOL_DEFAULT;\n\tunsigned short flags = 0;\n\n\tif (pol && pol != &default_policy && !(pol->flags & MPOL_F_MORON)) {\n\t\tmode = pol->mode;\n\t\tflags = pol->flags;\n\t}\n\n\tswitch (mode) {\n\tcase MPOL_DEFAULT:\n\t\tbreak;\n\tcase MPOL_PREFERRED:\n\t\tif (flags & MPOL_F_LOCAL)\n\t\t\tmode = MPOL_LOCAL;\n\t\telse\n\t\t\tnode_set(pol->v.preferred_node, nodes);\n\t\tbreak;\n\tcase MPOL_BIND:\n\tcase MPOL_INTERLEAVE:\n\t\tnodes = pol->v.nodes;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tsnprintf(p, maxlen, \"unknown\");\n\t\treturn;\n\t}\n\n\tp += snprintf(p, maxlen, \"%s\", policy_modes[mode]);\n\n\tif (flags & MPOL_MODE_FLAGS) {\n\t\tp += snprintf(p, buffer + maxlen - p, \"=\");\n\n\t\t/*\n\t\t * Currently, the only defined flags are mutually exclusive\n\t\t */\n\t\tif (flags & MPOL_F_STATIC_NODES)\n\t\t\tp += snprintf(p, buffer + maxlen - p, \"static\");\n\t\telse if (flags & MPOL_F_RELATIVE_NODES)\n\t\t\tp += snprintf(p, buffer + maxlen - p, \"relative\");\n\t}\n\n\tif (!nodes_empty(nodes))\n\t\tp += scnprintf(p, buffer + maxlen - p, \":%*pbl\",\n\t\t\t       nodemask_pr_args(&nodes));\n}\n"], "filenames": ["mm/mempolicy.c"], "buggy_code_start_loc": [1532], "buggy_code_end_loc": [1572], "fixing_code_start_loc": [1531], "fixing_code_end_loc": [1568], "type": "CWE-388", "message": "Incorrect error handling in the set_mempolicy and mbind compat syscalls in mm/mempolicy.c in the Linux kernel through 4.10.9 allows local users to obtain sensitive information from uninitialized stack data by triggering failure of a certain bitmap operation.", "other": {"cve": {"id": "CVE-2017-7616", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-10T14:59:00.293", "lastModified": "2018-06-20T01:29:01.307", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Incorrect error handling in the set_mempolicy and mbind compat syscalls in mm/mempolicy.c in the Linux kernel through 4.10.9 allows local users to obtain sensitive information from uninitialized stack data by triggering failure of a certain bitmap operation."}, {"lang": "es", "value": "El manejo incorrecto de los errores en las syscalls set_mempolicy y mbind compat en mm/mempolicy.c en el kernel de Linux hasta la versi\u00f3n 4.10.9 permite a los usuarios locales obtener informaci\u00f3n confidencial de datos de pila no inicializados al activar el fallo de una determinada operaci\u00f3n de mapa de bits."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-388"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.10.9", "matchCriteriaId": "526CF197-BAE6-4F03-9D2F-07A864CD9185"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=cf01fb9985e8deb25ccf0ea54d916b8871ae0e62", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/97527", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1038503", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:1842", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:2077", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:1854", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/cf01fb9985e8deb25ccf0ea54d916b8871ae0e62", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://source.android.com/security/bulletin/2017-09-01", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/cf01fb9985e8deb25ccf0ea54d916b8871ae0e62"}}