{"buggy_code": ["# @auth0/nextjs-auth0\n\nThe Auth0 Next.js SDK is a library for implementing user authentication in Next.js applications.\n\n[![CircleCI](https://img.shields.io/circleci/build/github/auth0/nextjs-auth0/main?style=flat-square)](https://circleci.com/gh/auth0/nextjs-auth0/tree/main)\n[![NPM version](https://img.shields.io/npm/v/@auth0/nextjs-auth0.svg?style=flat-square)](https://npmjs.org/package/@auth0/nextjs-auth0)\n[![License](https://img.shields.io/:license-mit-blue.svg?style=flat)](https://opensource.org/licenses/MIT)\n\n## Table of Contents\n\n- [Installation](#installation)\n- [Getting Started](#getting-started)\n  - [Auth0 Configuration](#auth0-configuration)\n  - [Basic Setup](#basic-setup)\n- [Documentation](#documentation)\n  - [QuickStart](https://auth0.com/docs/quickstart/webapp/nextjs)\n  - [API Reference](#api-reference)\n  - [v1 Migration Guide](./V1_MIGRATION_GUIDE.md)\n  - [Cookies and Security](#cookies-and-security)\n  - [Base Path and Internationalized Routing](#base-path-and-internationalized-routing)\n  - [Architecture](./ARCHITECTURE.md)\n  - [Comparison with auth0-react](#comparison-with-auth0-react)\n  - [Testing](#testing)\n- [Contributing](#contributing)\n- [Vulnerability Reporting](#vulnerability-reporting)\n- [What is Auth0?](#what-is-auth0)\n- [License](#license)\n\n## Installation\n\nUsing [npm](https://npmjs.org):\n\n```sh\nnpm install @auth0/nextjs-auth0\n```\n\nThis library supports the following tooling versions:\n\n- Node.js: `^10.13.0 || >=12.0.0`\n\n- Next.js: `>=10`\n\n## Getting Started\n\n### Auth0 Configuration\n\nCreate a **Regular Web Application** in the [Auth0 Dashboard](https://manage.auth0.com/#/applications).\n\n> **If you're using an existing application**, verify that you have configured the following settings in your Regular Web Application:\n>\n> - Click on the \"Settings\" tab of your application's page.\n> - Scroll down and click on the \"Show Advanced Settings\" link.\n> - Under \"Advanced Settings\", click on the \"OAuth\" tab.\n> - Ensure that \"JsonWebToken Signature Algorithm\" is set to `RS256` and that \"OIDC Conformant\" is enabled.\n\nNext, configure the following URLs for your application under the \"Application URIs\" section of the \"Settings\" page:\n\n- **Allowed Callback URLs**: `http://localhost:3000/api/auth/callback`\n- **Allowed Logout URLs**: `http://localhost:3000/`\n\nTake note of the **Client ID**, **Client Secret**, and **Domain** values under the \"Basic Information\" section. You'll need these values in the next step.\n\n### Basic Setup\n\nYou need to allow your Next.js application to communicate properly with Auth0. You can do so by creating a `.env.local` file under your root project directory that defines the necessary Auth0 configuration values as follows:\n\n```bash\n# A long, secret value used to encrypt the session cookie\nAUTH0_SECRET='LONG_RANDOM_VALUE'\n# The base url of your application\nAUTH0_BASE_URL='http://localhost:3000'\n# The url of your Auth0 tenant domain\nAUTH0_ISSUER_BASE_URL='https://YOUR_AUTH0_DOMAIN.auth0.com'\n# Your Auth0 application's Client ID\nAUTH0_CLIENT_ID='YOUR_AUTH0_CLIENT_ID'\n# Your Auth0 application's Client Secret\nAUTH0_CLIENT_SECRET='YOUR_AUTH0_CLIENT_SECRET'\n```\n\nYou can execute the following command to generate a suitable string for the `AUTH0_SECRET` value:\n\n```bash\nnode -e \"console.log(crypto.randomBytes(32).toString('hex'))\"\n```\n\nYou can see a full list of Auth0 configuration options in the [\"Configuration properties\"](https://auth0.github.io/nextjs-auth0/modules/config.html#configuration-properties) section of the \"Module config\" document.\n\n> For more details about loading environmental variables in Next.js, visit the [\"Environment Variables\"](https://nextjs.org/docs/basic-features/environment-variables) document.\n\nGo to your Next.js application and create a [catch-all, dynamic API route handler](https://nextjs.org/docs/api-routes/dynamic-api-routes#optional-catch-all-api-routes) under the `/pages/api` directory:\n\n- Create an `auth` directory under the `/pages/api/` directory.\n\n- Create a `[...auth0].js` file under the newly created `auth` directory.\n\nThe path to your dynamic API route file would be `/pages/api/auth/[...auth0].js`. Populate that file as follows:\n\n```js\nimport { handleAuth } from '@auth0/nextjs-auth0';\n\nexport default handleAuth();\n```\n\nExecuting `handleAuth()` creates the following route handlers under the hood that perform different parts of the authentication flow:\n\n- `/api/auth/login`: Your Next.js application redirects users to your Identity Provider for them to log in.\n\n- `/api/auth/callback`: Your Identity Provider redirects users to this route after they successfully log in.\n\n- `/api/auth/logout`: Your Next.js application logs out the user.\n\n- `/api/auth/me`: You can fetch user profile information in JSON format.\n\nWrap your `pages/_app.js` component with the `UserProvider` component:\n\n```jsx\n// pages/_app.js\nimport React from 'react';\nimport { UserProvider } from '@auth0/nextjs-auth0';\n\nexport default function App({ Component, pageProps }) {\n  return (\n    <UserProvider>\n      <Component {...pageProps} />\n    </UserProvider>\n  );\n}\n```\n\nYou can now determine if a user is authenticated by checking that the `user` object returned by the `useUser()` hook is defined. You can also log in or log out your users from the frontend layer of your Next.js application by redirecting them to the appropriate automatically-generated route:\n\n```jsx\n// pages/index.js\nimport { useUser } from '@auth0/nextjs-auth0';\n\nexport default function Index() {\n  const { user, error, isLoading } = useUser();\n\n  if (isLoading) return <div>Loading...</div>;\n  if (error) return <div>{error.message}</div>;\n\n  if (user) {\n    return (\n      <div>\n        Welcome {user.name}! <a href=\"/api/auth/logout\">Logout</a>\n      </div>\n    );\n  }\n\n  return <a href=\"/api/auth/login\">Login</a>;\n}\n```\n\nFor other comprehensive examples, see the [EXAMPLES.md](./EXAMPLES.md) document.\n\n## Documentation\n\n### API Reference\n\n- [Configuration Options](https://auth0.github.io/nextjs-auth0/modules/config.html)\n\n**Server-side methods**:\n\n- [handleAuth](https://auth0.github.io/nextjs-auth0/modules/handlers_auth.html)\n- [handleLogin](https://auth0.github.io/nextjs-auth0/modules/handlers_login.html#handlelogin)\n- [handleCallback](https://auth0.github.io/nextjs-auth0/modules/handlers_callback.html)\n- [handleLogout](https://auth0.github.io/nextjs-auth0/modules/handlers_logout.html)\n- [handleProfile](https://auth0.github.io/nextjs-auth0/modules/handlers_profile.html)\n- [withApiAuthRequired](https://auth0.github.io/nextjs-auth0/modules/helpers_with_api_auth_required.html)\n- [withPageAuthRequired](https://auth0.github.io/nextjs-auth0/modules/helpers_with_page_auth_required.html#withpageauthrequired)\n- [getSession](https://auth0.github.io/nextjs-auth0/modules/session_get_session.html)\n- [getAccessToken](https://auth0.github.io/nextjs-auth0/modules/session_get_access_token.html)\n- [initAuth0](https://auth0.github.io/nextjs-auth0/modules/instance.html)\n\n**Client-side methods/components**:\n\n- [UserProvider](https://auth0.github.io/nextjs-auth0/modules/frontend_use_user.html#userprovider)\n- [useUser](https://auth0.github.io/nextjs-auth0/modules/frontend_use_user.html)\n- [withPageAuthRequired](https://auth0.github.io/nextjs-auth0/modules/frontend_with_page_auth_required.html)\n\nVisit the auto-generated [API Docs](https://auth0.github.io/nextjs-auth0/) for more details.\n\n### Cookies and Security\n\nAll cookies will be set to `HttpOnly, SameSite=Lax` and will be set to `Secure` if the application's `AUTH0_BASE_URL` is `https`.\n\nThe `HttpOnly` setting will make sure that client-side JavaScript is unable to access the cookie to reduce the attack surface of [XSS attacks](https://auth0.com/blog/developers-guide-to-common-vulnerabilities-and-how-to-prevent-them/#Cross-Site-Scripting--XSS-).\n\nThe `SameSite=Lax` setting will help mitigate CSRF attacks. Learn more about SameSite by reading the [\"Upcoming Browser Behavior Changes: What Developers Need to Know\"](https://auth0.com/blog/browser-behavior-changes-what-developers-need-to-know/) blog post.\n\n### Base Path and Internationalized Routing\n\nWith Next.js you can deploy a Next.js application under a sub-path of a domain using [Base Path](https://nextjs.org/docs/api-reference/next.config.js/basepath) and serve internationalized (i18n) routes using [Internationalized Routing](https://nextjs.org/docs/advanced-features/i18n-routing).\n\nIf you use these features the urls of your application will change and so the urls to the nextjs-auth0 routes will change. To accommodate this there are various places in the SDK that you can customise the url.\n\nFor example if `basePath: '/foo'` you should prepend this to the `loginUrl` and `profileUrl` specified in your `Auth0Provider`\n\n```jsx\n// _app.jsx\nfunction App({ Component, pageProps }) {\n  return (\n    <UserProvider loginUrl=\"/foo/api/auth/login\" profileUrl=\"/foo/api/auth/me\">\n      <Component {...pageProps} />\n    </UserProvider>\n  );\n}\n```\n\nAlso, any links to login or logout should include the `basePath`:\n\n```html\n<a href=\"/foo/api/auth/login\">Login</a><br />\n<a href=\"/foo/api/auth/logout\">Logout</a>\n```\n\nYou should configure [baseUrl](https://auth0.github.io/nextjs-auth0/interfaces/config.baseconfig.html#baseurl) (or the `AUTH0_BASE_URL` environment variable) eg\n\n```shell\n# .env.local\nAUTH0_BASE_URL=http://localhost:3000/foo\n```\n\nFor any pages that are protected with the Server Side [withPageAuthRequired](https://auth0.github.io/nextjs-auth0/modules/helpers_with_page_auth_required.html#withpageauthrequired) you should update the `returnTo` parameter depending on the `basePath` and `locale` if necessary.\n\n```js\n// ./pages/my-ssr-page.jsx\nexport default MySsrPage = () => <></>;\n\nconst getFullReturnTo = (ctx) => {\n  // TODO: implement getFullReturnTo based on the ctx.resolvedUrl, ctx.locale\n  // and your next.config.js's basePath and i18n settings.\n  return '/foo/en-US/my-ssr-page';\n};\n\nexport const getServerSideProps = (ctx) => {\n  const returnTo = getFullReturnTo(ctx.req);\n  return withPageAuthRequired({ returnTo })(ctx);\n};\n```\n\n### Comparison with the Auth0 React SDK\n\nWe also provide an Auth0 React SDK, [auth0-react](https://github.com/auth0/auth0-react), which may be suitable for your Next.js application.\n\nThe SPA security model used by `auth0-react` is different from the Web Application security model used by this SDK. In short, this SDK protects pages and API routes with a cookie session (see [\"Cookies and Security\"](#cookies-and-security)). A SPA library like `auth0-react` will store the user's ID Token and Access Token directly in the browser and use them to access external APIs directly.\n\nYou should be aware of the security implications of both models. However, [auth0-react](https://github.com/auth0/auth0-react) may be more suitable for your needs if you meet any of the following scenarios:\n\n- You are using [Static HTML Export](https://nextjs.org/docs/advanced-features/static-html-export) with Next.js.\n- You do not need to access user data during server-side rendering.\n- You want to get the access token and call external API's directly from the frontend layer rather than using Next.js API Routes as a proxy to call external APIs\n\n### Testing\n\nBy default, the SDK creates and manages a singleton instance to run for the lifetime of the application. When testing your application, you may need to reset this instance, so its state does not leak between tests.\n\nIf you're using Jest, we recommend using `jest.resetModules()` after each test. Alternatively, you can look at [creating your own instance of the SDK](./EXAMPLES.md#create-your-own-instance-of-the-sdk), so it can be recreated between tests.\n\n## Contributing\n\nWe appreciate feedback and contribution to this repo! Before you get started, please read the following:\n\n- [Auth0's general contribution guidelines](./CONTRIBUTING.md)\n- [Auth0's code of conduct guidelines](./CODE-OF-CONDUCT.md)\n\nStart by installing the dependencies of this project:\n\n```sh\nnpm install\n```\n\nIn order to build a release, you can run the following commands, and the output will be stored in the `dist` folder:\n\n```sh\nnpm run clean\nnpm run lint\nnpm run build\n```\n\nAdditionally, you can also run tests:\n\n```sh\nnpm run build:test # Build the Next.js test app\nnpm run test\nnpm run test:watch\n```\n\n## Vulnerability Reporting\n\nPlease do not report security vulnerabilities on the public GitHub issue tracker. The [Responsible Disclosure Program](https://auth0.com/responsible-disclosure-policy) details the procedure for disclosing security issues.\n\n## What is Auth0?\n\nAuth0 helps you to easily:\n\n- Implement authentication with multiple identity providers, including social (e.g., Google, Facebook, Microsoft, LinkedIn, GitHub, Twitter, etc.), or enterprise (e.g., Windows Azure AD, Google Apps, Active Directory, ADFS, SAML, etc.)\n- Log in users with username/password databases, passwordless, or multi-factor authentication\n- Link multiple user accounts together\n- Generate signed JSON Web Tokens to authorize your API calls and flow the user identity securely\n- Access demographics and analytics detailing how, when, and where users are logging in\n- Enrich user profiles from other data sources using customizable JavaScript rules\n\n[Why Auth0?](https://auth0.com/why-auth0) Because you should save time, be happy, and focus on what really matters: building your product.\n\n## License\n\nThis project is licensed under the MIT license. See the [LICENSE](LICENSE) file for more info.\n", "import { strict as assert } from 'assert';\nimport { NextApiResponse, NextApiRequest } from 'next';\nimport { HandleCallback as BaseHandleCallback } from '../auth0-session';\nimport { Session } from '../session';\nimport { assertReqRes } from '../utils/assert';\nimport { NextConfig } from '../config';\n\n/**\n * Use this function for validating additional claims on the user's ID Token or adding removing items from\n * the session after login, eg\n *\n * ### Validate additional claims\n *\n * ```js\n * // pages/api/auth/[...auth0].js\n * import { handleAuth, handleCallback } from '@auth0/nextjs-auth0';\n *\n * const afterCallback = (req, res, session, state) => {\n *   if (!session.user.isAdmin) {\n *     throw new UnauthorizedError('User is not admin');\n *   }\n *   return session;\n * };\n *\n * export default handleAuth({\n *   async callback(req, res) {\n *     try {\n *       await handleCallback(req, res, { afterCallback });\n *     } catch (error) {\n *       res.status(error.status || 500).end(error.message);\n *     }\n *   }\n * });\n * ```\n *\n * ### Modify the session after login\n *\n * ```js\n * // pages/api/auth/[...auth0].js\n * import { handleAuth, handleCallback } from '@auth0/nextjs-auth0';\n *\n * const afterCallback = (req, res, session, state) => {\n *   session.user.customProperty = 'foo';\n *   delete session.refreshToken;\n *   return session;\n * };\n *\n * export default handleAuth({\n *   async callback(req, res) {\n *     try {\n *       await handleCallback(req, res, { afterCallback });\n *     } catch (error) {\n *       res.status(error.status || 500).end(error.message);\n *     }\n *   }\n * });\n * ```\n *\n * @category Server\n */\nexport type AfterCallback = (\n  req: NextApiRequest,\n  res: NextApiResponse,\n  session: Session,\n  state: { [key: string]: any }\n) => Promise<Session> | Session;\n\n/**\n * Options to customize the callback handler.\n *\n * @category Server\n */\nexport interface CallbackOptions {\n  afterCallback?: AfterCallback;\n\n  /**\n   * This is useful to specify in addition to {@Link BaseConfig.baseURL} when your app runs on multiple domains,\n   * it should match {@Link LoginOptions.authorizationParams.redirect_uri}.\n   */\n  redirectUri?: string;\n\n  /**\n   * This is useful to specify instead of {@Link NextConfig.organization} when your app has multiple\n   * organizations, it should match {@Link LoginOptions.authorizationParams}.\n   */\n  organization?: string;\n}\n\n/**\n * The handler for the `api/auth/callback` route.\n *\n * @category Server\n */\nexport type HandleCallback = (req: NextApiRequest, res: NextApiResponse, options?: CallbackOptions) => Promise<void>;\n\n/**\n * @ignore\n */\nconst idTokenValidator = (afterCallback?: AfterCallback, organization?: string): AfterCallback => (\n  req,\n  res,\n  session,\n  state\n) => {\n  if (organization) {\n    assert(session.user.org_id, 'Organization Id (org_id) claim must be a string present in the ID token');\n    assert.equal(\n      session.user.org_id,\n      organization,\n      `Organization Id (org_id) claim value mismatch in the ID token; ` +\n        `expected \"${organization}\", found \"${session.user.org_id}\"`\n    );\n  }\n  if (afterCallback) {\n    return afterCallback(req, res, session, state);\n  }\n  return session;\n};\n\n/**\n * @ignore\n */\nexport default function handleCallbackFactory(handler: BaseHandleCallback, config: NextConfig): HandleCallback {\n  return async (req, res, options = {}): Promise<void> => {\n    assertReqRes(req, res);\n    return handler(req, res, {\n      ...options,\n      afterCallback: idTokenValidator(options.afterCallback, options.organization || config.organization)\n    });\n  };\n}\n", "import { NextApiResponse, NextApiRequest } from 'next';\nimport { AuthorizationParameters, HandleLogin as BaseHandleLogin } from '../auth0-session';\nimport isSafeRedirect from '../utils/url-helpers';\nimport { assertReqRes } from '../utils/assert';\nimport { NextConfig } from '../config';\n\n/**\n * Use this to store additional state for the user before they visit the Identity Provider to login.\n *\n * ```js\n * // pages/api/auth/[...auth0].js\n * import { handleAuth, handleLogin } from '@auth0/nextjs-auth0';\n *\n * const getLoginState = (req, loginOptions) => {\n *   return { basket_id: getBasketId(req) };\n * };\n *\n * export default handleAuth({\n *   async login(req, res) {\n *     try {\n *       await handleLogin(req, res, { getLoginState });\n *     } catch (error) {\n *       res.status(error.status || 500).end(error.message);\n *     }\n *   }\n * });\n * ```\n *\n * @category Server\n */\nexport type GetLoginState = (req: NextApiRequest, options: LoginOptions) => { [key: string]: any };\n\n/**\n * Authorization params to pass to the login handler.\n *\n * @category Server\n */\nexport interface AuthorizationParams extends Partial<AuthorizationParameters> {\n  /**\n   * The invitation id to join an organization.\n   *\n   * To create a link for your user's to accept an organization invite, read the `invitation` and `organization`\n   * query params and pass them to the authorization server to log the user in:\n   *\n   * ```js\n   * // pages/api/invite.js\n   * import { handleLogin } from '@auth0/nextjs-auth0';\n   *\n   * export default async function invite(req, res) {\n   *   try {\n   *     const { invitation, organization } = req.query;\n   *     if (!invitation) {\n   *       res.status(400).end('Missing \"invitation\" parameter');\n   *     }\n   *     await handleLogin(req, res, {\n   *       authorizationParams: {\n   *         invitation,\n   *         organization\n   *       }\n   *     });\n   *   } catch (error) {\n   *     res.status(error.status || 500).end(error.message);\n   *   }\n   * } ;\n   * ```\n   *\n   * Your invite url can then take the format:\n   * `https://example.com/api/invite?invitation=invitation_id&organization=org_id`\n   */\n  invitation?: string;\n  /**\n   * This is useful to specify instead of {@Link NextConfig.organization} when your app has multiple\n   * organizations, it should match {@Link CallbackOptions.organization}.\n   */\n  organization?: string;\n}\n\n/**\n * Custom options to pass to login.\n *\n * @category Server\n */\nexport interface LoginOptions {\n  /**\n   * Override the default {@link BaseConfig.authorizationParams authorizationParams}\n   */\n  authorizationParams?: AuthorizationParams;\n\n  /**\n   *  URL to return to after login, overrides the Default is {@link BaseConfig.baseURL}\n   */\n  returnTo?: string;\n\n  /**\n   *  Generate a unique state value for use during login transactions.\n   */\n  getLoginState?: GetLoginState;\n}\n\n/**\n * The handler for the `api/auth/login` route.\n *\n * @category Server\n */\nexport type HandleLogin = (req: NextApiRequest, res: NextApiResponse, options?: LoginOptions) => Promise<void>;\n\n/**\n * @ignore\n */\nexport default function handleLoginFactory(handler: BaseHandleLogin, nextConfig: NextConfig): HandleLogin {\n  return async (req, res, options = {}): Promise<void> => {\n    assertReqRes(req, res);\n    if (req.query.returnTo) {\n      const returnTo = Array.isArray(req.query.returnTo) ? req.query.returnTo[0] : req.query.returnTo;\n\n      if (!isSafeRedirect(returnTo)) {\n        throw new Error('Invalid value provided for returnTo, must be a relative url');\n      }\n\n      options = { ...options, returnTo };\n    }\n    if (nextConfig.organization) {\n      options = {\n        ...options,\n        authorizationParams: { organization: nextConfig.organization, ...options.authorizationParams }\n      };\n    }\n\n    return handler(req, res, options);\n  };\n}\n", "import { NextApiResponse, NextApiRequest } from 'next';\nimport { HandleLogout as BaseHandleLogout } from '../auth0-session';\nimport { assertReqRes } from '../utils/assert';\n\n/**\n * Custom options to pass to logout.\n *\n * @category Server\n */\nexport interface LogoutOptions {\n  /**\n   *  URL to returnTo after logout, overrides the\n   *  Default in {@link BaseConfig.routes.postLogoutRedirect routes.postLogoutRedirect}\n   */\n  returnTo?: string;\n}\n\n/**\n * The handler for the `api/auth/logout` route.\n *\n * @category Server\n */\nexport type HandleLogout = (req: NextApiRequest, res: NextApiResponse, options?: LogoutOptions) => Promise<void>;\n\n/**\n * @ignore\n */\nexport default function handleLogoutFactory(handler: BaseHandleLogout): HandleLogout {\n  return async (req, res, options): Promise<void> => {\n    assertReqRes(req, res);\n    return handler(req, res, options);\n  };\n}\n", "import { NextApiResponse, NextApiRequest } from 'next';\nimport { ClientFactory } from '../auth0-session';\nimport { SessionCache, Session, fromJson, GetAccessToken } from '../session';\nimport { assertReqRes } from '../utils/assert';\n\nexport type AfterRefetch = (req: NextApiRequest, res: NextApiResponse, session: Session) => Promise<Session> | Session;\n\n/**\n * Custom options for {@link HandleProfile}\n *\n * @category Server\n */\nexport type ProfileOptions = {\n  /**\n   * If set to `true` this will refetch the user profile information from `/userinfo` and save it to the session.\n   */\n  refetch?: boolean;\n\n  /**\n   * Like {@AfterCallback} when a session is created, you can use this function to validate or add/remove claims\n   * after the session is updated. Will only run if {@link ProfileOptions.refetch} is `true`\n   */\n  afterRefetch?: AfterRefetch;\n};\n\n/**\n * The handler for the `/api/auth/me` route.\n *\n * @category Server\n */\nexport type HandleProfile = (req: NextApiRequest, res: NextApiResponse, options?: ProfileOptions) => Promise<void>;\n\n/**\n * @ignore\n */\nexport default function profileHandler(\n  getClient: ClientFactory,\n  getAccessToken: GetAccessToken,\n  sessionCache: SessionCache\n): HandleProfile {\n  return async (req, res, options): Promise<void> => {\n    assertReqRes(req, res);\n\n    if (!sessionCache.isAuthenticated(req, res)) {\n      res.status(401).json({\n        error: 'not_authenticated',\n        description: 'The user does not have an active session or is not authenticated'\n      });\n      return;\n    }\n\n    const session = sessionCache.get(req, res) as Session;\n    res.setHeader('Cache-Control', 'no-store');\n\n    if (options?.refetch) {\n      const { accessToken } = await getAccessToken(req, res);\n      if (!accessToken) {\n        throw new Error('No access token available to refetch the profile');\n      }\n\n      const client = await getClient();\n      const userInfo = await client.userinfo(accessToken);\n\n      let newSession = fromJson({\n        ...session,\n        user: {\n          ...session.user,\n          ...userInfo\n        }\n      }) as Session;\n\n      if (options.afterRefetch) {\n        newSession = await options.afterRefetch(req, res, newSession);\n      }\n\n      sessionCache.set(req, res, newSession);\n\n      res.json(newSession.user);\n      return;\n    }\n\n    res.json(session.user);\n  };\n}\n", "/**\n * The error thrown by {@link GetAccessToken}\n *\n * @category Server\n */\nexport class AccessTokenError extends Error {\n  public code: string;\n\n  constructor(code: string, message: string) {\n    super(message);\n\n    // Saving class name in the property of our custom error as a shortcut.\n    this.name = this.constructor.name;\n\n    // Capturing stack trace, excluding constructor call from it.\n    Error.captureStackTrace(this, this.constructor);\n\n    // Machine readable code.\n    this.code = code;\n  }\n}\n", "import nock from 'nock';\nimport { CookieJar } from 'tough-cookie';\nimport { JWT } from 'jose';\nimport { encodeState } from '../../../src/auth0-session/hooks/get-login-state';\nimport { SessionResponse, setup, teardown } from '../fixtures/server';\nimport { makeIdToken } from '../fixtures/cert';\nimport { toSignedCookieJar, get, post, defaultConfig } from '../fixtures/helpers';\n\nconst expectedDefaultState = encodeState({ returnTo: 'https://example.org' });\n\ndescribe('callback', () => {\n  afterEach(teardown);\n\n  it('should error when the body is empty', async () => {\n    const baseURL = await setup(defaultConfig);\n\n    const cookieJar = toSignedCookieJar(\n      {\n        nonce: '__test_nonce__',\n        state: '__test_state__'\n      },\n      baseURL\n    );\n\n    await expect(post(baseURL, '/callback', { body: {}, cookieJar })).rejects.toThrowError(\n      'state missing from the response'\n    );\n  });\n\n  it('should error when the state cookie is missing', async () => {\n    const baseURL = await setup(defaultConfig);\n\n    await expect(\n      post(baseURL, '/callback', {\n        body: {\n          state: '__test_state__',\n          id_token: '__invalid_token__'\n        },\n        cookieJar: new CookieJar()\n      })\n    ).rejects.toThrowError('checks.state argument is missing');\n  });\n\n  it(\"should error when state doesn't match\", async () => {\n    const baseURL = await setup(defaultConfig);\n\n    const cookieJar = toSignedCookieJar(\n      {\n        nonce: '__valid_nonce__',\n        state: '__valid_state__'\n      },\n      baseURL\n    );\n\n    await expect(\n      post(baseURL, '/callback', {\n        body: {\n          state: '__invalid_state__',\n          id_token: '__invalid_token__'\n        },\n        cookieJar\n      })\n    ).rejects.toThrowError('state mismatch, expected __valid_state__, got: __invalid_state__');\n  });\n\n  it(\"should error when id_token can't be parsed\", async () => {\n    const baseURL = await setup(defaultConfig);\n\n    const cookieJar = toSignedCookieJar(\n      {\n        nonce: '__valid_nonce__',\n        state: '__valid_state__'\n      },\n      baseURL\n    );\n\n    await expect(\n      post(baseURL, '/callback', {\n        body: {\n          state: '__valid_state__',\n          id_token: '__invalid_token__'\n        },\n        cookieJar\n      })\n    ).rejects.toThrowError('failed to decode JWT (JWTMalformed: JWTs must have three components)');\n  });\n\n  it('should error when id_token has invalid alg', async () => {\n    const baseURL = await setup(defaultConfig);\n\n    const cookieJar = toSignedCookieJar(\n      {\n        nonce: '__valid_nonce__',\n        state: '__valid_state__'\n      },\n      baseURL\n    );\n\n    await expect(\n      post(baseURL, '/callback', {\n        body: {\n          state: '__valid_state__',\n          id_token: JWT.sign({ sub: '__test_sub__' }, 'secret', {\n            algorithm: 'HS256'\n          })\n        },\n        cookieJar\n      })\n    ).rejects.toThrowError('unexpected JWT alg received, expected RS256, got: HS256');\n  });\n\n  it('should error when id_token is missing issuer', async () => {\n    const baseURL = await setup(defaultConfig);\n\n    const cookieJar = toSignedCookieJar(\n      {\n        nonce: '__valid_nonce__',\n        state: '__valid_state__'\n      },\n      baseURL\n    );\n\n    await expect(\n      post(baseURL, '/callback', {\n        body: {\n          state: '__valid_state__',\n          id_token: makeIdToken({ iss: undefined })\n        },\n        cookieJar\n      })\n    ).rejects.toThrowError('missing required JWT property iss');\n  });\n\n  it('should error when nonce is missing from cookies', async () => {\n    const baseURL = await setup(defaultConfig);\n\n    const cookieJar = toSignedCookieJar(\n      {\n        state: '__valid_state__'\n      },\n      baseURL\n    );\n\n    await expect(\n      post(baseURL, '/callback', {\n        body: {\n          state: '__valid_state__',\n          id_token: makeIdToken({ nonce: '__test_nonce__' })\n        },\n        cookieJar\n      })\n    ).rejects.toThrowError('nonce mismatch, expected undefined, got: __test_nonce__');\n  });\n\n  it('should error when legacy samesite fallback is off', async () => {\n    const baseURL = await setup({ ...defaultConfig, legacySameSiteCookie: false });\n\n    const cookieJar = toSignedCookieJar(\n      {\n        _state: '__valid_state__'\n      },\n      baseURL\n    );\n\n    await expect(\n      post(baseURL, '/callback', {\n        body: {\n          state: '__valid_state__',\n          id_token: makeIdToken()\n        },\n        cookieJar\n      })\n    ).rejects.toThrowError('checks.state argument is missing');\n  });\n\n  it('should error for expired ID Token', async () => {\n    const baseURL = await setup({ ...defaultConfig, legacySameSiteCookie: false });\n\n    const expected = {\n      nickname: '__test_nickname__',\n      sub: '__test_sub__',\n      iss: 'https://op.example.com/',\n      aud: '__test_client_id__',\n      nonce: '__test_nonce__',\n      auth_time: 10\n    };\n\n    const cookieJar = toSignedCookieJar(\n      {\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n        max_age: '100'\n      },\n      baseURL\n    );\n\n    await expect(\n      post(baseURL, '/callback', {\n        body: {\n          state: expectedDefaultState,\n          id_token: makeIdToken(expected)\n        },\n        cookieJar\n      })\n    ).rejects.toThrowError('too much time has elapsed since the last End-User authentication');\n  });\n\n  it('should expose the id token claims when id_token is valid', async () => {\n    const baseURL = await setup({ ...defaultConfig, legacySameSiteCookie: false });\n\n    const expected = {\n      nickname: '__test_nickname__',\n      sub: '__test_sub__',\n      iss: 'https://op.example.com/',\n      aud: '__test_client_id__',\n      nonce: '__test_nonce__'\n    };\n\n    const cookieJar = toSignedCookieJar(\n      {\n        state: expectedDefaultState,\n        nonce: '__test_nonce__'\n      },\n      baseURL\n    );\n\n    const { res } = await post(baseURL, '/callback', {\n      body: {\n        state: expectedDefaultState,\n        id_token: makeIdToken(expected)\n      },\n      cookieJar,\n      fullResponse: true\n    });\n\n    const session: SessionResponse = await get(baseURL, '/session', { cookieJar });\n\n    expect(res.headers.location).toEqual('https://example.org');\n    expect(session.claims).toEqual(expect.objectContaining(expected));\n  });\n\n  it(\"should expose all tokens when id_token is valid and response_type is 'code id_token'\", async () => {\n    const baseURL = await setup({\n      ...defaultConfig,\n      clientSecret: '__test_client_secret__',\n      authorizationParams: {\n        response_type: 'code id_token',\n        audience: 'https://api.example.com/',\n        scope: 'openid profile email read:reports offline_access'\n      }\n    });\n\n    const idToken = makeIdToken({\n      c_hash: '77QmUPtjPfzWtF2AnpK9RQ'\n    });\n\n    nock('https://op.example.com')\n      .post('/oauth/token')\n      .reply(200, () => ({\n        access_token: '__test_access_token__',\n        refresh_token: '__test_refresh_token__',\n        id_token: idToken,\n        token_type: 'Bearer',\n        expires_in: 86400\n      }));\n\n    const cookieJar = toSignedCookieJar(\n      {\n        state: expectedDefaultState,\n        nonce: '__test_nonce__'\n      },\n      baseURL\n    );\n\n    await post(baseURL, '/callback', {\n      body: {\n        state: expectedDefaultState,\n        id_token: idToken,\n        code: 'jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y'\n      },\n      cookieJar\n    });\n\n    const session: SessionResponse = await get(baseURL, '/session', { cookieJar });\n    expect(session).toEqual(\n      expect.objectContaining({\n        token_type: 'Bearer',\n        access_token: '__test_access_token__',\n        id_token: idToken,\n        refresh_token: '__test_refresh_token__',\n        expires_at: expect.any(Number)\n      })\n    );\n  });\n\n  it('should use basic auth on token endpoint when using code flow', async () => {\n    const idToken = makeIdToken({\n      c_hash: '77QmUPtjPfzWtF2AnpK9RQ'\n    });\n\n    const baseURL = await setup({\n      ...defaultConfig,\n      clientSecret: '__test_client_secret__',\n      authorizationParams: {\n        response_type: 'code id_token',\n        audience: 'https://api.example.com/',\n        scope: 'openid profile email read:reports offline_access'\n      }\n    });\n\n    let credentials = '';\n    let body = '';\n    nock('https://op.example.com')\n      .post('/oauth/token')\n      .reply(200, function (_uri, requestBody) {\n        credentials = this.req.headers.authorization.replace('Basic ', '');\n        body = requestBody as string;\n        return {\n          access_token: '__test_access_token__',\n          refresh_token: '__test_refresh_token__',\n          id_token: idToken,\n          token_type: 'Bearer',\n          expires_in: 86400\n        };\n      });\n\n    const cookieJar = toSignedCookieJar(\n      {\n        state: expectedDefaultState,\n        nonce: '__test_nonce__'\n      },\n      baseURL\n    );\n\n    const code = 'jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y';\n    await post(baseURL, '/callback', {\n      body: {\n        state: expectedDefaultState,\n        id_token: idToken,\n        code\n      },\n      cookieJar\n    });\n\n    expect(Buffer.from(credentials, 'base64').toString()).toEqual('__test_client_id__:__test_client_secret__');\n    expect(body).toEqual(\n      `grant_type=authorization_code&code=${code}&redirect_uri=${encodeURIComponent(baseURL)}%2Fcallback`\n    );\n  });\n\n  it('should redirect to default base url', async () => {\n    const baseURL = await setup(defaultConfig);\n\n    const state = encodeState({ foo: 'bar' });\n    const cookieJar = toSignedCookieJar(\n      {\n        state: state,\n        nonce: '__test_nonce__'\n      },\n      baseURL\n    );\n\n    const { res } = await post(baseURL, '/callback', {\n      body: {\n        state: state,\n        id_token: makeIdToken()\n      },\n      cookieJar,\n      fullResponse: true\n    });\n\n    expect(res.statusCode).toEqual(302);\n    expect(res.headers.location).toEqual(baseURL);\n  });\n\n  it('should accept custom runtime redirect over base url', async () => {\n    const redirectUri = 'http://messi:3000/api/auth/callback/runtime';\n    const baseURL = await setup(defaultConfig, { callbackOptions: { redirectUri } });\n    const state = encodeState({ foo: 'bar' });\n    const cookieJar = toSignedCookieJar( { state, nonce: '__test_nonce__' }, baseURL);\n    const { res } = await post(baseURL, '/callback', {\n      body: {\n        state: state,\n        id_token: makeIdToken()\n      },\n      cookieJar,\n      fullResponse: true\n    });\n\n    expect(res.statusCode).toEqual(302);\n    expect(res.headers.location).toEqual(baseURL);\n  });\n});\n", "import nock from 'nock';\nimport { JSONWebKeySet } from 'jose';\nimport { ConfigParameters } from '../../src';\nimport { makeIdToken } from '../auth0-session/fixtures/cert';\n\nexport function discovery(params: ConfigParameters, discoveryOptions?: any): nock.Scope {\n  return nock(params.issuerBaseURL as string)\n    .get('/.well-known/openid-configuration')\n    .reply(200, () => {\n      return {\n        issuer: `${params.issuerBaseURL}/`,\n        authorization_endpoint: `${params.issuerBaseURL}/authorize`,\n        token_endpoint: `${params.issuerBaseURL}/oauth/token`,\n        userinfo_endpoint: `${params.issuerBaseURL}/userinfo`,\n        jwks_uri: `${params.issuerBaseURL}/.well-known/jwks.json`,\n        scopes_supported: [\n          'openid',\n          'profile',\n          'offline_access',\n          'name',\n          'given_name',\n          'family_name',\n          'nickname',\n          'email',\n          'email_verified',\n          'picture',\n          'created_at',\n          'identities',\n          'phone',\n          'address'\n        ],\n        response_types_supported: ['code'],\n        id_token_signing_alg_values_supported: ['RS256'],\n        token_endpoint_auth_methods_supported: ['client_secret_basic', 'client_secret_post'],\n        claims_supported: [\n          'aud',\n          'auth_time',\n          'created_at',\n          'email',\n          'email_verified',\n          'exp',\n          'family_name',\n          'given_name',\n          'iat',\n          'identities',\n          'iss',\n          'name',\n          'nickname',\n          'phone_number',\n          'picture',\n          'sub'\n        ],\n        ...(discoveryOptions || {})\n      };\n    });\n}\n\nexport function userInfoWithDelay(params: ConfigParameters, delay: number): nock.Scope {\n  return nock(params.issuerBaseURL as string)\n    .get('/userinfo')\n    .reply((_uri, _requestBody, cb) => {\n      setTimeout(() => cb(null, [200, {}]), delay);\n    });\n}\n\nexport function jwksEndpoint(params: ConfigParameters, keyset: JSONWebKeySet): nock.Scope {\n  return nock(params.issuerBaseURL as string)\n    .get('/.well-known/jwks.json')\n    .reply(200, keyset);\n}\n\nexport function codeExchange(params: ConfigParameters, idToken: string, code = 'code'): nock.Scope {\n  return nock(`${params.issuerBaseURL}`)\n    .post(\n      '/oauth/token',\n      `grant_type=authorization_code&code=${code}&redirect_uri=${encodeURIComponent(\n        `${params.baseURL}api/auth/callback`\n      )}`\n    )\n    .reply(200, {\n      access_token: 'eyJz93a...k4laUWw',\n      expires_in: 750,\n      scope: 'read:foo delete:foo',\n      refresh_token: 'GEbRxBN...edjnXbL',\n      id_token: idToken,\n      token_type: 'Bearer'\n    });\n}\n\nexport function refreshTokenExchange(\n  params: ConfigParameters,\n  refreshToken: string,\n  payload: object,\n  newToken?: string\n): nock.Scope {\n  const idToken = makeIdToken({\n    iss: `${params.issuerBaseURL}/`,\n    aud: params.clientID,\n    ...payload\n  });\n\n  return nock(`${params.issuerBaseURL}`)\n    .post('/oauth/token', `grant_type=refresh_token&refresh_token=${refreshToken}`)\n    .reply(200, {\n      access_token: newToken || 'eyJz93a...k4laUWw',\n      id_token: idToken,\n      token_type: 'Bearer',\n      expires_in: 750,\n      scope: 'read:foo write:foo'\n    });\n}\n\nexport function refreshTokenRotationExchange(\n  params: ConfigParameters,\n  refreshToken: string,\n  payload: object,\n  newToken?: string,\n  newrefreshToken?: string\n): nock.Scope {\n  const idToken = makeIdToken({\n    iss: `${params.issuerBaseURL}/`,\n    aud: params.clientID,\n    ...payload\n  });\n\n  return nock(`${params.issuerBaseURL}`)\n    .post('/oauth/token', `grant_type=refresh_token&refresh_token=${refreshToken}`)\n    .reply(200, {\n      access_token: newToken || 'eyJz93a...k4laUWw',\n      refresh_token: newrefreshToken || 'GEbRxBN...edjnXbL',\n      id_token: idToken,\n      token_type: 'Bearer',\n      expires_in: 750,\n      scope: 'read:foo write:foo'\n    });\n}\n\nexport function userInfo(params: ConfigParameters, token: string, payload: object): nock.Scope {\n  return nock(`${params.issuerBaseURL}`, {\n    reqheaders: {\n      authorization: `Bearer ${token}`\n    }\n  })\n    .get('/userinfo')\n    .reply(200, payload);\n}\n", "import { CookieJar } from 'tough-cookie';\nimport timekeeper = require('timekeeper');\nimport { withApi, withoutApi } from '../fixtures/default-settings';\nimport { makeIdToken } from '../auth0-session/fixtures/cert';\nimport { get, post, toSignedCookieJar } from '../auth0-session/fixtures/helpers';\nimport { encodeState } from '../../src/auth0-session/hooks/get-login-state';\nimport { setup, teardown } from '../fixtures/setup';\nimport { Session, AfterCallback } from '../../src';\n\nconst callback = (baseUrl: string, body: any, cookieJar?: CookieJar): Promise<any> =>\n  post(baseUrl, `/api/auth/callback`, {\n    body,\n    cookieJar,\n    fullResponse: true\n  });\n\ndescribe('callback handler', () => {\n  afterEach(teardown);\n\n  test('should require a state', async () => {\n    const baseUrl = await setup(withoutApi);\n    await expect(\n      callback(baseUrl, {\n        state: '__test_state__'\n      })\n    ).rejects.toThrow('checks.state argument is missing');\n  });\n\n  test('should validate the state', async () => {\n    const baseUrl = await setup(withoutApi);\n    const cookieJar = toSignedCookieJar(\n      {\n        state: '__other_state__'\n      },\n      baseUrl\n    );\n    await expect(\n      callback(\n        baseUrl,\n        {\n          state: '__test_state__'\n        },\n        cookieJar\n      )\n    ).rejects.toThrow('state mismatch, expected __other_state__, got: __test_state__');\n  });\n\n  test('should validate the audience', async () => {\n    const baseUrl = await setup(withoutApi, { idTokenClaims: { aud: 'bar' } });\n    const state = encodeState({ returnTo: baseUrl });\n    const cookieJar = toSignedCookieJar(\n      {\n        state,\n        nonce: '__test_nonce__'\n      },\n      baseUrl\n    );\n    await expect(\n      callback(\n        baseUrl,\n        {\n          state,\n          code: 'code'\n        },\n        cookieJar\n      )\n    ).rejects.toThrow('aud mismatch, expected __test_client_id__, got: bar');\n  });\n\n  test('should validate the issuer', async () => {\n    const baseUrl = await setup(withoutApi, { idTokenClaims: { aud: 'bar', iss: 'other-issuer' } });\n    const state = encodeState({ returnTo: baseUrl });\n    const cookieJar = toSignedCookieJar(\n      {\n        state,\n        nonce: '__test_nonce__'\n      },\n      baseUrl\n    );\n    await expect(\n      callback(\n        baseUrl,\n        {\n          state,\n          code: 'code'\n        },\n        cookieJar\n      )\n    ).rejects.toThrow('unexpected iss value, expected https://acme.auth0.local/, got: other-issuer');\n  });\n\n  test('should create the session without OIDC claims', async () => {\n    const baseUrl = await setup(withoutApi);\n    const state = encodeState({ returnTo: baseUrl });\n    const cookieJar = toSignedCookieJar(\n      {\n        state,\n        nonce: '__test_nonce__'\n      },\n      baseUrl\n    );\n    const { res } = await callback(\n      baseUrl,\n      {\n        state,\n        code: 'code'\n      },\n      cookieJar\n    );\n    expect(res.statusCode).toBe(302);\n    const body = await get(baseUrl, `/api/session`, { cookieJar });\n\n    expect(body.user).toStrictEqual({\n      nickname: '__test_nickname__',\n      sub: '__test_sub__'\n    });\n  });\n\n  test('should set the correct expiration', async () => {\n    timekeeper.freeze(0);\n    const baseUrl = await setup(withoutApi);\n    const state = encodeState({ returnTo: baseUrl });\n    const cookieJar = toSignedCookieJar(\n      {\n        state,\n        nonce: '__test_nonce__'\n      },\n      baseUrl\n    );\n    const { res } = await post(baseUrl, `/api/auth/callback`, {\n      fullResponse: true,\n      cookieJar,\n      body: {\n        state,\n        code: 'code'\n      }\n    });\n    expect(res.statusCode).toBe(302);\n\n    const [sessionCookie] = cookieJar.getCookiesSync(baseUrl);\n    const expiryInHrs = new Date(sessionCookie.expires).getTime() / 1000 / 60 / 60;\n    expect(expiryInHrs).toBe(24);\n    timekeeper.reset();\n  });\n\n  test('should create the session without OIDC claims with api config', async () => {\n    timekeeper.freeze(0);\n    const baseUrl = await setup(withApi);\n    const state = encodeState({ returnTo: baseUrl });\n    const cookieJar = toSignedCookieJar(\n      {\n        state,\n        nonce: '__test_nonce__'\n      },\n      baseUrl\n    );\n    const { res } = await callback(\n      baseUrl,\n      {\n        state,\n        code: 'code'\n      },\n      cookieJar\n    );\n    expect(res.statusCode).toBe(302);\n    const session = await get(baseUrl, `/api/session`, { cookieJar });\n\n    expect(session).toStrictEqual({\n      accessToken: 'eyJz93a...k4laUWw',\n      accessTokenExpiresAt: 750,\n      accessTokenScope: 'read:foo delete:foo',\n      idToken: makeIdToken({ iss: 'https://acme.auth0.local/' }),\n      token_type: 'Bearer',\n      refreshToken: 'GEbRxBN...edjnXbL',\n      user: {\n        nickname: '__test_nickname__',\n        sub: '__test_sub__'\n      }\n    });\n    timekeeper.reset();\n  });\n\n  test('remove tokens with afterCallback hook', async () => {\n    timekeeper.freeze(0);\n    const afterCallback: AfterCallback = (_req, _res, session: Session): Session => {\n      delete session.accessToken;\n      delete session.refreshToken;\n      return session;\n    };\n    const baseUrl = await setup(withApi, { callbackOptions: { afterCallback } });\n    const state = encodeState({ returnTo: baseUrl });\n    const cookieJar = toSignedCookieJar(\n      {\n        state,\n        nonce: '__test_nonce__'\n      },\n      baseUrl\n    );\n    const { res } = await callback(\n      baseUrl,\n      {\n        state,\n        code: 'code'\n      },\n      cookieJar\n    );\n    expect(res.statusCode).toBe(302);\n    const session = await get(baseUrl, `/api/session`, { cookieJar });\n\n    expect(session).toStrictEqual({\n      accessTokenExpiresAt: 750,\n      accessTokenScope: 'read:foo delete:foo',\n      idToken: makeIdToken({ iss: 'https://acme.auth0.local/' }),\n      token_type: 'Bearer',\n      user: {\n        nickname: '__test_nickname__',\n        sub: '__test_sub__'\n      }\n    });\n    timekeeper.reset();\n  });\n\n  test('add properties to session with afterCallback hook', async () => {\n    timekeeper.freeze(0);\n    const afterCallback: AfterCallback = (_req, _res, session: Session): Session => {\n      session.foo = 'bar';\n      return session;\n    };\n    const baseUrl = await setup(withApi, { callbackOptions: { afterCallback } });\n    const state = encodeState({ returnTo: baseUrl });\n    const cookieJar = toSignedCookieJar(\n      {\n        state,\n        nonce: '__test_nonce__'\n      },\n      baseUrl\n    );\n    const { res } = await callback(\n      baseUrl,\n      {\n        state,\n        code: 'code'\n      },\n      cookieJar\n    );\n    expect(res.statusCode).toBe(302);\n    const session = await get(baseUrl, '/api/session', { cookieJar });\n\n    expect(session).toMatchObject({\n      foo: 'bar',\n      user: {\n        nickname: '__test_nickname__',\n        sub: '__test_sub__'\n      }\n    });\n    timekeeper.reset();\n  });\n\n  test('throws from afterCallback hook', async () => {\n    const afterCallback = (): Session => {\n      throw new Error('some validation error.');\n    };\n    const baseUrl = await setup(withApi, { callbackOptions: { afterCallback } });\n    const state = encodeState({ returnTo: baseUrl });\n    const cookieJar = toSignedCookieJar(\n      {\n        state,\n        nonce: '__test_nonce__'\n      },\n      baseUrl\n    );\n    await expect(\n      callback(\n        baseUrl,\n        {\n          state,\n          code: 'code'\n        },\n        cookieJar\n      )\n    ).rejects.toThrow('some validation error.');\n  });\n\n  test('throws for missing org_id claim', async () => {\n    const baseUrl = await setup({ ...withApi, organization: 'foo' });\n    const state = encodeState({ returnTo: baseUrl });\n    const cookieJar = toSignedCookieJar(\n      {\n        state,\n        nonce: '__test_nonce__'\n      },\n      baseUrl\n    );\n    await expect(\n      callback(\n        baseUrl,\n        {\n          state,\n          code: 'code'\n        },\n        cookieJar\n      )\n    ).rejects.toThrow('Organization Id (org_id) claim must be a string present in the ID token');\n  });\n\n  test('throws for org_id claim mismatch', async () => {\n    const baseUrl = await setup({ ...withApi, organization: 'foo' }, { idTokenClaims: { org_id: 'bar' } });\n    const state = encodeState({ returnTo: baseUrl });\n    const cookieJar = toSignedCookieJar(\n      {\n        state,\n        nonce: '__test_nonce__'\n      },\n      baseUrl\n    );\n    await expect(\n      callback(\n        baseUrl,\n        {\n          state,\n          code: 'code'\n        },\n        cookieJar\n      )\n    ).rejects.toThrow('Organization Id (org_id) claim value mismatch in the ID token; expected \"foo\", found \"bar\"');\n  });\n\n  test('accepts a valid organization', async () => {\n    const baseUrl = await setup(withApi, {\n      idTokenClaims: { org_id: 'foo' },\n      callbackOptions: { organization: 'foo' }\n    });\n    const state = encodeState({ returnTo: baseUrl });\n    const cookieJar = toSignedCookieJar(\n      {\n        state,\n        nonce: '__test_nonce__'\n      },\n      baseUrl\n    );\n    await expect(\n      callback(\n        baseUrl,\n        {\n          state,\n          code: 'code'\n        },\n        cookieJar\n      )\n    ).resolves.not.toThrow();\n    const session = await get(baseUrl, '/api/session', { cookieJar });\n\n    expect(session.user.org_id).toEqual('foo');\n  });\n});\n", "import { parse as urlParse } from 'url';\nimport { withoutApi, withApi } from '../fixtures/default-settings';\nimport { decodeState } from '../../src/auth0-session/hooks/get-login-state';\nimport { setup, teardown } from '../fixtures/setup';\nimport { get, getCookie } from '../auth0-session/fixtures/helpers';\nimport { Cookie, CookieJar } from 'tough-cookie';\n\ndescribe('login handler', () => {\n  afterEach(teardown);\n\n  test('should create a state', async () => {\n    const baseUrl = await setup(withoutApi);\n    const cookieJar = new CookieJar();\n    await get(baseUrl, '/api/auth/login', { cookieJar });\n\n    expect(cookieJar.getCookiesSync(baseUrl)).toEqual(\n      expect.arrayContaining([\n        expect.objectContaining({\n          key: 'nonce',\n          value: expect.any(String),\n          path: '/',\n          sameSite: 'lax'\n        }),\n        expect.objectContaining({\n          key: 'state',\n          value: expect.any(String),\n          path: '/',\n          sameSite: 'lax'\n        }),\n        expect.objectContaining({\n          key: 'code_verifier',\n          value: expect.any(String),\n          path: '/',\n          sameSite: 'lax'\n        })\n      ])\n    );\n  });\n\n  test('should add returnTo to the state', async () => {\n    const baseUrl = await setup(withoutApi, { loginOptions: { returnTo: '/custom-url' } });\n    const cookieJar = new CookieJar();\n    await get(baseUrl, '/api/auth/login', { cookieJar });\n\n    const { value: state } = getCookie('state', cookieJar, baseUrl) as Cookie;\n    expect(state).toBeTruthy();\n\n    const decodedState = decodeState(state.split('.')[0]);\n    expect(decodedState.returnTo).toEqual('/custom-url');\n  });\n\n  test('should redirect to the identity provider', async () => {\n    const baseUrl = await setup(withoutApi);\n    const cookieJar = new CookieJar();\n    const {\n      res: { statusCode, headers }\n    } = await get(baseUrl, '/api/auth/login', { cookieJar, fullResponse: true });\n\n    expect(statusCode).toBe(302);\n\n    const { value: state } = getCookie('state', cookieJar, baseUrl) as Cookie;\n    expect(urlParse(headers.location, true)).toMatchObject({\n      protocol: 'https:',\n      host: 'acme.auth0.local',\n      hash: null,\n      query: {\n        client_id: '__test_client_id__',\n        scope: 'openid profile email',\n        response_type: 'code',\n        redirect_uri: 'http://www.acme.com/api/auth/callback',\n        nonce: expect.any(String),\n        state: state.split('.')[0],\n        code_challenge: expect.any(String),\n        code_challenge_method: 'S256'\n      },\n      pathname: '/authorize'\n    });\n  });\n\n  test('should allow sending custom parameters to the authorization server', async () => {\n    const loginOptions = {\n      authorizationParams: {\n        max_age: 123,\n        login_hint: 'foo@acme.com',\n        ui_locales: 'nl',\n        scope: 'some other scope openid',\n        foo: 'bar',\n        organization: 'foo',\n        invitation: 'bar'\n      }\n    };\n    const baseUrl = await setup(withoutApi, { loginOptions });\n    const cookieJar = new CookieJar();\n    const {\n      res: { statusCode, headers }\n    } = await get(baseUrl, '/api/auth/login', { cookieJar, fullResponse: true });\n\n    expect(statusCode).toBe(302);\n    expect(urlParse(headers.location, true)).toMatchObject({\n      query: {\n        ...loginOptions.authorizationParams,\n        max_age: '123'\n      }\n    });\n  });\n\n  test('should pass organization config to the authorization server', async () => {\n    const baseUrl = await setup({ ...withoutApi, organization: 'foo' });\n    const cookieJar = new CookieJar();\n    const {\n      res: { statusCode, headers }\n    } = await get(baseUrl, '/api/auth/login', { cookieJar, fullResponse: true });\n\n    expect(statusCode).toBe(302);\n    expect(urlParse(headers.location, true)).toMatchObject({\n      query: {\n        organization: 'foo'\n      }\n    });\n  });\n\n  test('should prefer organization auth param to config', async () => {\n    const baseUrl = await setup(\n      { ...withoutApi, organization: 'foo' },\n      { loginOptions: { authorizationParams: { organization: 'bar' } } }\n    );\n    const cookieJar = new CookieJar();\n    const {\n      res: { statusCode, headers }\n    } = await get(baseUrl, '/api/auth/login', { cookieJar, fullResponse: true });\n\n    expect(statusCode).toBe(302);\n    expect(urlParse(headers.location, true)).toMatchObject({\n      query: {\n        organization: 'bar'\n      }\n    });\n  });\n\n  test('should allow adding custom data to the state', async () => {\n    const loginOptions = {\n      getLoginState: (): Record<string, any> => {\n        return {\n          foo: 'bar'\n        };\n      }\n    };\n    const baseUrl = await setup(withoutApi, { loginOptions });\n    const cookieJar = new CookieJar();\n    await get(baseUrl, '/api/auth/login', { cookieJar });\n\n    const { value: state } = getCookie('state', cookieJar, baseUrl) as Cookie;\n\n    const decodedState = decodeState(state.split('.')[0]);\n    expect(decodedState).toEqual({\n      foo: 'bar',\n      returnTo: 'http://www.acme.com/'\n    });\n  });\n\n  test('should merge returnTo and state', async () => {\n    const loginOptions = {\n      returnTo: '/profile',\n      getLoginState: (): Record<string, any> => {\n        return {\n          foo: 'bar'\n        };\n      }\n    };\n    const baseUrl = await setup(withoutApi, { loginOptions });\n    const cookieJar = new CookieJar();\n    await get(baseUrl, '/api/auth/login', { cookieJar });\n\n    const { value: state } = getCookie('state', cookieJar, baseUrl) as Cookie;\n\n    const decodedState = decodeState(state.split('.')[0]);\n    expect(decodedState).toEqual({\n      foo: 'bar',\n      returnTo: '/profile'\n    });\n  });\n\n  test('should allow the getState method to overwrite returnTo', async () => {\n    const loginOptions = {\n      returnTo: '/profile',\n      getLoginState: (): Record<string, any> => {\n        return {\n          foo: 'bar',\n          returnTo: '/foo'\n        };\n      }\n    };\n    const baseUrl = await setup(withoutApi, { loginOptions });\n    const cookieJar = new CookieJar();\n    await get(baseUrl, '/api/auth/login', { cookieJar });\n\n    const { value: state } = getCookie('state', cookieJar, baseUrl) as Cookie;\n\n    const decodedState = decodeState(state.split('.')[0]);\n    expect(decodedState).toEqual({\n      foo: 'bar',\n      returnTo: '/foo'\n    });\n  });\n\n  test('should allow the returnTo url to be provided in the querystring', async () => {\n    const loginOptions = {\n      returnTo: '/profile'\n    };\n    const baseUrl = await setup(withoutApi, { loginOptions });\n    const cookieJar = new CookieJar();\n    await get(baseUrl, '/api/auth/login?returnTo=/foo', { cookieJar });\n    const { value: state } = getCookie('state', cookieJar, baseUrl) as Cookie;\n\n    const decodedState = decodeState(state.split('.')[0]);\n    expect(decodedState).toEqual({\n      returnTo: '/foo'\n    });\n  });\n\n  test('should take the first returnTo url provided in the querystring', async () => {\n    const loginOptions = {\n      returnTo: '/profile'\n    };\n    const baseUrl = await setup(withoutApi, { loginOptions });\n    const cookieJar = new CookieJar();\n    await get(baseUrl, '/api/auth/login?returnTo=/foo&returnTo=/bar', { cookieJar });\n    const { value: state } = getCookie('state', cookieJar, baseUrl) as Cookie;\n\n    const decodedState = decodeState(state.split('.')[0]);\n    expect(decodedState).toEqual({\n      returnTo: '/foo'\n    });\n  });\n\n  test('should not allow absolute urls to be provided in the querystring', async () => {\n    const loginOptions = {\n      returnTo: '/default-redirect'\n    };\n    const baseUrl = await setup(withoutApi, { loginOptions });\n\n    await expect(\n      get(baseUrl, '/api/auth/login?returnTo=https://www.google.com', { fullResponse: true })\n    ).rejects.toThrow('Invalid value provided for returnTo, must be a relative url');\n  });\n\n  test('should allow the returnTo to be be overwritten by getState() when provided in the querystring', async () => {\n    const loginOptions = {\n      returnTo: '/profile',\n      getLoginState: (): Record<string, any> => {\n        return {\n          returnTo: '/foo'\n        };\n      }\n    };\n    const baseUrl = await setup(withoutApi, { loginOptions });\n    const cookieJar = new CookieJar();\n    await get(baseUrl, '/api/auth/login', { cookieJar });\n    const { value: state } = getCookie('state', cookieJar, baseUrl) as Cookie;\n\n    const decodedState = decodeState(state.split('.')[0]);\n    expect(decodedState).toEqual({\n      returnTo: '/foo'\n    });\n  });\n\n  test('should redirect to the identity provider with scope and audience', async () => {\n    const baseUrl = await setup(withApi);\n    const {\n      res: { statusCode, headers }\n    } = await get(baseUrl, '/api/auth/login', { fullResponse: true });\n\n    expect(statusCode).toBe(302);\n\n    expect(urlParse(headers.location, true).query).toMatchObject({\n      scope: 'openid profile read:customer',\n      audience: 'https://api.acme.com'\n    });\n  });\n});\n", "import { parse } from 'cookie';\nimport { parse as parseUrl } from 'url';\nimport { withoutApi } from '../fixtures/default-settings';\nimport { setup, teardown, login } from '../fixtures/setup';\n\ndescribe('logout handler', () => {\n  afterEach(teardown);\n\n  test('should redirect to the identity provider', async () => {\n    const baseUrl = await setup(withoutApi);\n    const cookieJar = await login(baseUrl);\n\n    const { status, headers } = await fetch(`${baseUrl}/api/auth/logout`, {\n      redirect: 'manual',\n      headers: {\n        cookie: cookieJar.getCookieStringSync(baseUrl)\n      }\n    });\n\n    expect(status).toBe(302);\n    expect(parseUrl(headers.get('location') as string, true)).toMatchObject({\n      protocol: 'https:',\n      host: 'acme.auth0.local',\n      query: {\n        returnTo: 'http://www.acme.com',\n        client_id: '__test_client_id__'\n      },\n      pathname: '/v2/logout'\n    });\n  });\n\n  test('should return to the custom path', async () => {\n    const customReturnTo = 'https://www.foo.bar';\n    const baseUrl = await setup(withoutApi, {\n      logoutOptions: { returnTo: customReturnTo }\n    });\n    const cookieJar = await login(baseUrl);\n\n    const { status, headers } = await fetch(`${baseUrl}/api/auth/logout`, {\n      redirect: 'manual',\n      headers: {\n        cookie: cookieJar.getCookieStringSync(baseUrl)\n      }\n    });\n\n    expect(status).toBe(302);\n    expect(parseUrl(headers.get('location') as string, true).query).toMatchObject({\n      returnTo: 'https://www.foo.bar'\n    });\n  });\n\n  test('should use end_session_endpoint if available', async () => {\n    const baseUrl = await setup(withoutApi, {\n      discoveryOptions: { end_session_endpoint: 'https://my-end-session-endpoint/logout' }\n    });\n    const cookieJar = await login(baseUrl);\n\n    const { status, headers } = await fetch(`${baseUrl}/api/auth/logout`, {\n      redirect: 'manual',\n      headers: {\n        cookie: cookieJar.getCookieStringSync(baseUrl)\n      }\n    });\n\n    expect(status).toBe(302);\n    expect(parseUrl(headers.get('location') as string)).toMatchObject({\n      host: 'my-end-session-endpoint',\n      pathname: '/logout'\n    });\n  });\n\n  test('should delete the session', async () => {\n    const baseUrl = await setup(withoutApi, {\n      discoveryOptions: { end_session_endpoint: 'https://my-end-session-endpoint/logout' }\n    });\n    const cookieJar = await login(baseUrl);\n\n    const res = await fetch(`${baseUrl}/api/auth/logout`, {\n      redirect: 'manual',\n      headers: {\n        cookie: cookieJar.getCookieStringSync(baseUrl)\n      }\n    });\n\n    expect(parse(res.headers.get('set-cookie') as string)).toMatchObject({\n      appSession: '',\n      'Max-Age': '0',\n      Path: '/'\n    });\n  });\n});\n", "import nock from 'nock';\nimport { withApi, withoutApi } from '../fixtures/default-settings';\nimport { refreshTokenRotationExchange, userInfo } from '../fixtures/oidc-nocks';\nimport { get } from '../auth0-session/fixtures/helpers';\nimport { setup, teardown, login } from '../fixtures/setup';\nimport { Session, AfterCallback } from '../../src';\nimport { makeIdToken } from '../auth0-session/fixtures/cert';\n\ndescribe('profile handler', () => {\n  afterEach(teardown);\n\n  test('should throw an error when not logged in', async () => {\n    const baseUrl = await setup(withoutApi);\n\n    await expect(get(baseUrl, '/api/auth/me')).rejects.toThrow('Unauthorized');\n  });\n\n  test('should return the profile when logged in', async () => {\n    const baseUrl = await setup(withoutApi);\n    const cookieJar = await login(baseUrl);\n\n    const profile = await get(baseUrl, '/api/auth/me', { cookieJar });\n    expect(profile).toStrictEqual({ nickname: '__test_nickname__', sub: '__test_sub__' });\n  });\n\n  test('should not allow caching the profile response', async () => {\n    const baseUrl = await setup(withoutApi);\n    const cookieJar = await login(baseUrl);\n\n    const { res } = await get(baseUrl, '/api/auth/me', { cookieJar, fullResponse: true });\n    expect(res.headers['cache-control']).toEqual('no-store');\n  });\n\n  test('should not allow caching the profile response when refetch is true', async () => {\n    const baseUrl = await setup(withoutApi, { profileOptions: { refetch: true } });\n    const cookieJar = await login(baseUrl);\n\n    const { res } = await get(baseUrl, '/api/auth/me', { cookieJar, fullResponse: true });\n    expect(res.headers['cache-control']).toEqual('no-store');\n  });\n\n  test('should throw if re-fetching with no Access Token', async () => {\n    const afterCallback: AfterCallback = (_req, _res, session: Session): Session => {\n      delete session.accessToken;\n      return session;\n    };\n    const baseUrl = await setup(withoutApi, { profileOptions: { refetch: true }, callbackOptions: { afterCallback } });\n    const cookieJar = await login(baseUrl);\n\n    await expect(get(baseUrl, '/api/auth/me', { cookieJar })).rejects.toThrow(\n      'The user does not have a valid access token.'\n    );\n  });\n\n  test('should refetch the user and update the session', async () => {\n    const baseUrl = await setup(withoutApi, { profileOptions: { refetch: true }, userInfoPayload: { foo: 'bar' } });\n    const cookieJar = await login(baseUrl);\n\n    const profile = await get(baseUrl, '/api/auth/me', { cookieJar });\n    expect(profile).toMatchObject({ foo: 'bar', nickname: '__test_nickname__', sub: '__test_sub__' });\n    // check that the session is saved\n    userInfo(withoutApi, 'eyJz93a...k4laUWw', {});\n    const profile2 = await get(baseUrl, '/api/auth/me', { cookieJar });\n    expect(profile2).toMatchObject({ foo: 'bar', nickname: '__test_nickname__', sub: '__test_sub__' });\n  });\n\n  test(\"should refetch the user and fail if it can't get an access token\", async () => {\n    const afterCallback: AfterCallback = (_req, _res, session: Session): Session => {\n      session.accessTokenExpiresAt = -60;\n      return session;\n    };\n    const baseUrl = await setup(withoutApi, {\n      profileOptions: { refetch: true },\n      userInfoPayload: { foo: 'bar' },\n      callbackOptions: {\n        afterCallback\n      }\n    });\n    const cookieJar = await login(baseUrl);\n\n    nock(`${withoutApi.issuerBaseURL}`)\n      .post('/oauth/token', `grant_type=refresh_token&refresh_token=GEbRxBN...edjnXbL`)\n      .reply(200, {\n        id_token: makeIdToken({ iss: 'https://acme.auth0.local/' }),\n        token_type: 'Bearer',\n        expires_in: 750,\n        scope: 'read:foo write:foo'\n      });\n    await expect(get(baseUrl, '/api/auth/me', { cookieJar })).rejects.toThrow(\n      'No access token available to refetch the profile'\n    );\n  });\n\n  test('should refetch the user and preserve new tokens', async () => {\n    const afterCallback: AfterCallback = (_req, _res, session: Session): Session => {\n      session.accessTokenExpiresAt = -60;\n      return session;\n    };\n    const baseUrl = await setup(withApi, {\n      profileOptions: { refetch: true },\n      userInfoPayload: { foo: 'bar' },\n      callbackOptions: {\n        afterCallback\n      },\n      userInfoToken: 'new-access-token'\n    });\n    refreshTokenRotationExchange(withApi, 'GEbRxBN...edjnXbL', {}, 'new-access-token', 'new-refresh-token');\n    const cookieJar = await login(baseUrl);\n    const profile = await get(baseUrl, '/api/auth/me', { cookieJar });\n    expect(profile).toMatchObject({ foo: 'bar' });\n    const session = await get(baseUrl, '/api/session', { cookieJar });\n    expect(session.accessToken).toEqual('new-access-token');\n    expect(session.refreshToken).toEqual('new-refresh-token');\n  });\n\n  test('should update the session in the afterRefetch hook', async () => {\n    const baseUrl = await setup(withoutApi, {\n      profileOptions: {\n        refetch: true,\n        afterRefetch(_req, _res, session) {\n          session.user.foo = 'bar';\n          return session;\n        }\n      }\n    });\n    const cookieJar = await login(baseUrl);\n\n    const user = await get(baseUrl, '/api/auth/me', { cookieJar });\n    expect(user.foo).toEqual('bar');\n  });\n\n  test('should throw from the afterRefetch hook', async () => {\n    const baseUrl = await setup(withoutApi, {\n      profileOptions: {\n        refetch: true,\n        afterRefetch() {\n          throw new Error('some validation error');\n        }\n      }\n    });\n    const cookieJar = await login(baseUrl);\n\n    await expect(get(baseUrl, '/api/auth/me', { cookieJar })).rejects.toThrowError('some validation error');\n  });\n});\n"], "fixing_code": ["# @auth0/nextjs-auth0\n\nThe Auth0 Next.js SDK is a library for implementing user authentication in Next.js applications.\n\n[![CircleCI](https://img.shields.io/circleci/build/github/auth0/nextjs-auth0/main?style=flat-square)](https://circleci.com/gh/auth0/nextjs-auth0/tree/main)\n[![NPM version](https://img.shields.io/npm/v/@auth0/nextjs-auth0.svg?style=flat-square)](https://npmjs.org/package/@auth0/nextjs-auth0)\n[![License](https://img.shields.io/:license-mit-blue.svg?style=flat)](https://opensource.org/licenses/MIT)\n\n## Table of Contents\n\n- [Installation](#installation)\n- [Getting Started](#getting-started)\n  - [Auth0 Configuration](#auth0-configuration)\n  - [Basic Setup](#basic-setup)\n- [Documentation](#documentation)\n  - [QuickStart](https://auth0.com/docs/quickstart/webapp/nextjs)\n  - [API Reference](#api-reference)\n  - [v1 Migration Guide](./V1_MIGRATION_GUIDE.md)\n  - [Cookies and Security](#cookies-and-security)\n  - [Error Handling and Security](#error-handling-and-security)\n  - [Base Path and Internationalized Routing](#base-path-and-internationalized-routing)\n  - [Architecture](./ARCHITECTURE.md)\n  - [Comparison with auth0-react](#comparison-with-auth0-react)\n  - [Testing](#testing)\n- [Contributing](#contributing)\n- [Vulnerability Reporting](#vulnerability-reporting)\n- [What is Auth0?](#what-is-auth0)\n- [License](#license)\n\n## Installation\n\nUsing [npm](https://npmjs.org):\n\n```sh\nnpm install @auth0/nextjs-auth0\n```\n\nThis library supports the following tooling versions:\n\n- Node.js: `^10.13.0 || >=12.0.0`\n\n- Next.js: `>=10`\n\n## Getting Started\n\n### Auth0 Configuration\n\nCreate a **Regular Web Application** in the [Auth0 Dashboard](https://manage.auth0.com/#/applications).\n\n> **If you're using an existing application**, verify that you have configured the following settings in your Regular Web Application:\n>\n> - Click on the \"Settings\" tab of your application's page.\n> - Scroll down and click on the \"Show Advanced Settings\" link.\n> - Under \"Advanced Settings\", click on the \"OAuth\" tab.\n> - Ensure that \"JsonWebToken Signature Algorithm\" is set to `RS256` and that \"OIDC Conformant\" is enabled.\n\nNext, configure the following URLs for your application under the \"Application URIs\" section of the \"Settings\" page:\n\n- **Allowed Callback URLs**: `http://localhost:3000/api/auth/callback`\n- **Allowed Logout URLs**: `http://localhost:3000/`\n\nTake note of the **Client ID**, **Client Secret**, and **Domain** values under the \"Basic Information\" section. You'll need these values in the next step.\n\n### Basic Setup\n\nYou need to allow your Next.js application to communicate properly with Auth0. You can do so by creating a `.env.local` file under your root project directory that defines the necessary Auth0 configuration values as follows:\n\n```bash\n# A long, secret value used to encrypt the session cookie\nAUTH0_SECRET='LONG_RANDOM_VALUE'\n# The base url of your application\nAUTH0_BASE_URL='http://localhost:3000'\n# The url of your Auth0 tenant domain\nAUTH0_ISSUER_BASE_URL='https://YOUR_AUTH0_DOMAIN.auth0.com'\n# Your Auth0 application's Client ID\nAUTH0_CLIENT_ID='YOUR_AUTH0_CLIENT_ID'\n# Your Auth0 application's Client Secret\nAUTH0_CLIENT_SECRET='YOUR_AUTH0_CLIENT_SECRET'\n```\n\nYou can execute the following command to generate a suitable string for the `AUTH0_SECRET` value:\n\n```bash\nnode -e \"console.log(crypto.randomBytes(32).toString('hex'))\"\n```\n\nYou can see a full list of Auth0 configuration options in the [\"Configuration properties\"](https://auth0.github.io/nextjs-auth0/modules/config.html#configuration-properties) section of the \"Module config\" document.\n\n> For more details about loading environmental variables in Next.js, visit the [\"Environment Variables\"](https://nextjs.org/docs/basic-features/environment-variables) document.\n\nGo to your Next.js application and create a [catch-all, dynamic API route handler](https://nextjs.org/docs/api-routes/dynamic-api-routes#optional-catch-all-api-routes) under the `/pages/api` directory:\n\n- Create an `auth` directory under the `/pages/api/` directory.\n\n- Create a `[...auth0].js` file under the newly created `auth` directory.\n\nThe path to your dynamic API route file would be `/pages/api/auth/[...auth0].js`. Populate that file as follows:\n\n```js\nimport { handleAuth } from '@auth0/nextjs-auth0';\n\nexport default handleAuth();\n```\n\nExecuting `handleAuth()` creates the following route handlers under the hood that perform different parts of the authentication flow:\n\n- `/api/auth/login`: Your Next.js application redirects users to your Identity Provider for them to log in.\n\n- `/api/auth/callback`: Your Identity Provider redirects users to this route after they successfully log in.\n\n- `/api/auth/logout`: Your Next.js application logs out the user.\n\n- `/api/auth/me`: You can fetch user profile information in JSON format.\n\nWrap your `pages/_app.js` component with the `UserProvider` component:\n\n```jsx\n// pages/_app.js\nimport React from 'react';\nimport { UserProvider } from '@auth0/nextjs-auth0';\n\nexport default function App({ Component, pageProps }) {\n  return (\n    <UserProvider>\n      <Component {...pageProps} />\n    </UserProvider>\n  );\n}\n```\n\nYou can now determine if a user is authenticated by checking that the `user` object returned by the `useUser()` hook is defined. You can also log in or log out your users from the frontend layer of your Next.js application by redirecting them to the appropriate automatically-generated route:\n\n```jsx\n// pages/index.js\nimport { useUser } from '@auth0/nextjs-auth0';\n\nexport default function Index() {\n  const { user, error, isLoading } = useUser();\n\n  if (isLoading) return <div>Loading...</div>;\n  if (error) return <div>{error.message}</div>;\n\n  if (user) {\n    return (\n      <div>\n        Welcome {user.name}! <a href=\"/api/auth/logout\">Logout</a>\n      </div>\n    );\n  }\n\n  return <a href=\"/api/auth/login\">Login</a>;\n}\n```\n\nFor other comprehensive examples, see the [EXAMPLES.md](./EXAMPLES.md) document.\n\n## Documentation\n\n### API Reference\n\n- [Configuration Options](https://auth0.github.io/nextjs-auth0/modules/config.html)\n\n**Server-side methods**:\n\n- [handleAuth](https://auth0.github.io/nextjs-auth0/modules/handlers_auth.html)\n- [handleLogin](https://auth0.github.io/nextjs-auth0/modules/handlers_login.html#handlelogin)\n- [handleCallback](https://auth0.github.io/nextjs-auth0/modules/handlers_callback.html)\n- [handleLogout](https://auth0.github.io/nextjs-auth0/modules/handlers_logout.html)\n- [handleProfile](https://auth0.github.io/nextjs-auth0/modules/handlers_profile.html)\n- [withApiAuthRequired](https://auth0.github.io/nextjs-auth0/modules/helpers_with_api_auth_required.html)\n- [withPageAuthRequired](https://auth0.github.io/nextjs-auth0/modules/helpers_with_page_auth_required.html#withpageauthrequired)\n- [getSession](https://auth0.github.io/nextjs-auth0/modules/session_get_session.html)\n- [getAccessToken](https://auth0.github.io/nextjs-auth0/modules/session_get_access_token.html)\n- [initAuth0](https://auth0.github.io/nextjs-auth0/modules/instance.html)\n\n**Client-side methods/components**:\n\n- [UserProvider](https://auth0.github.io/nextjs-auth0/modules/frontend_use_user.html#userprovider)\n- [useUser](https://auth0.github.io/nextjs-auth0/modules/frontend_use_user.html)\n- [withPageAuthRequired](https://auth0.github.io/nextjs-auth0/modules/frontend_with_page_auth_required.html)\n\nVisit the auto-generated [API Docs](https://auth0.github.io/nextjs-auth0/) for more details.\n\n### Cookies and Security\n\nAll cookies will be set to `HttpOnly, SameSite=Lax` and will be set to `Secure` if the application's `AUTH0_BASE_URL` is `https`.\n\nThe `HttpOnly` setting will make sure that client-side JavaScript is unable to access the cookie to reduce the attack surface of [XSS attacks](https://auth0.com/blog/developers-guide-to-common-vulnerabilities-and-how-to-prevent-them/#Cross-Site-Scripting--XSS-).\n\nThe `SameSite=Lax` setting will help mitigate CSRF attacks. Learn more about SameSite by reading the [\"Upcoming Browser Behavior Changes: What Developers Need to Know\"](https://auth0.com/blog/browser-behavior-changes-what-developers-need-to-know/) blog post.\n\n### Error Handling and Security\n\nThe default server side error handler for the `/api/auth/*` routes prints the error message to screen, eg\n\n```js\ntry {\n  await handler(req, res);\n} catch (error) {\n  res.status(error.status || 400).end(error.message);\n}\n```\n\nBecause the error can come from the OpenID Connect `error` query parameter we do some [basic escaping](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html#rule-1-html-encode-before-inserting-untrusted-data-into-html-element-content) which makes sure the default error handler is safe from XSS.\n\nIf you write your own error handler, you should **not** render the error message without using a templating engine that will properly escape it for other HTML contexts first.\n\n### Base Path and Internationalized Routing\n\nWith Next.js you can deploy a Next.js application under a sub-path of a domain using [Base Path](https://nextjs.org/docs/api-reference/next.config.js/basepath) and serve internationalized (i18n) routes using [Internationalized Routing](https://nextjs.org/docs/advanced-features/i18n-routing).\n\nIf you use these features the urls of your application will change and so the urls to the nextjs-auth0 routes will change. To accommodate this there are various places in the SDK that you can customise the url.\n\nFor example if `basePath: '/foo'` you should prepend this to the `loginUrl` and `profileUrl` specified in your `Auth0Provider`\n\n```jsx\n// _app.jsx\nfunction App({ Component, pageProps }) {\n  return (\n    <UserProvider loginUrl=\"/foo/api/auth/login\" profileUrl=\"/foo/api/auth/me\">\n      <Component {...pageProps} />\n    </UserProvider>\n  );\n}\n```\n\nAlso, any links to login or logout should include the `basePath`:\n\n```html\n<a href=\"/foo/api/auth/login\">Login</a><br />\n<a href=\"/foo/api/auth/logout\">Logout</a>\n```\n\nYou should configure [baseUrl](https://auth0.github.io/nextjs-auth0/interfaces/config.baseconfig.html#baseurl) (or the `AUTH0_BASE_URL` environment variable) eg\n\n```shell\n# .env.local\nAUTH0_BASE_URL=http://localhost:3000/foo\n```\n\nFor any pages that are protected with the Server Side [withPageAuthRequired](https://auth0.github.io/nextjs-auth0/modules/helpers_with_page_auth_required.html#withpageauthrequired) you should update the `returnTo` parameter depending on the `basePath` and `locale` if necessary.\n\n```js\n// ./pages/my-ssr-page.jsx\nexport default MySsrPage = () => <></>;\n\nconst getFullReturnTo = (ctx) => {\n  // TODO: implement getFullReturnTo based on the ctx.resolvedUrl, ctx.locale\n  // and your next.config.js's basePath and i18n settings.\n  return '/foo/en-US/my-ssr-page';\n};\n\nexport const getServerSideProps = (ctx) => {\n  const returnTo = getFullReturnTo(ctx.req);\n  return withPageAuthRequired({ returnTo })(ctx);\n};\n```\n\n### Comparison with the Auth0 React SDK\n\nWe also provide an Auth0 React SDK, [auth0-react](https://github.com/auth0/auth0-react), which may be suitable for your Next.js application.\n\nThe SPA security model used by `auth0-react` is different from the Web Application security model used by this SDK. In short, this SDK protects pages and API routes with a cookie session (see [\"Cookies and Security\"](#cookies-and-security)). A SPA library like `auth0-react` will store the user's ID Token and Access Token directly in the browser and use them to access external APIs directly.\n\nYou should be aware of the security implications of both models. However, [auth0-react](https://github.com/auth0/auth0-react) may be more suitable for your needs if you meet any of the following scenarios:\n\n- You are using [Static HTML Export](https://nextjs.org/docs/advanced-features/static-html-export) with Next.js.\n- You do not need to access user data during server-side rendering.\n- You want to get the access token and call external API's directly from the frontend layer rather than using Next.js API Routes as a proxy to call external APIs\n\n### Testing\n\nBy default, the SDK creates and manages a singleton instance to run for the lifetime of the application. When testing your application, you may need to reset this instance, so its state does not leak between tests.\n\nIf you're using Jest, we recommend using `jest.resetModules()` after each test. Alternatively, you can look at [creating your own instance of the SDK](./EXAMPLES.md#create-your-own-instance-of-the-sdk), so it can be recreated between tests.\n\n## Contributing\n\nWe appreciate feedback and contribution to this repo! Before you get started, please read the following:\n\n- [Auth0's general contribution guidelines](./CONTRIBUTING.md)\n- [Auth0's code of conduct guidelines](./CODE-OF-CONDUCT.md)\n\nStart by installing the dependencies of this project:\n\n```sh\nnpm install\n```\n\nIn order to build a release, you can run the following commands, and the output will be stored in the `dist` folder:\n\n```sh\nnpm run clean\nnpm run lint\nnpm run build\n```\n\nAdditionally, you can also run tests:\n\n```sh\nnpm run build:test # Build the Next.js test app\nnpm run test\nnpm run test:watch\n```\n\n## Vulnerability Reporting\n\nPlease do not report security vulnerabilities on the public GitHub issue tracker. The [Responsible Disclosure Program](https://auth0.com/responsible-disclosure-policy) details the procedure for disclosing security issues.\n\n## What is Auth0?\n\nAuth0 helps you to easily:\n\n- Implement authentication with multiple identity providers, including social (e.g., Google, Facebook, Microsoft, LinkedIn, GitHub, Twitter, etc.), or enterprise (e.g., Windows Azure AD, Google Apps, Active Directory, ADFS, SAML, etc.)\n- Log in users with username/password databases, passwordless, or multi-factor authentication\n- Link multiple user accounts together\n- Generate signed JSON Web Tokens to authorize your API calls and flow the user identity securely\n- Access demographics and analytics detailing how, when, and where users are logging in\n- Enrich user profiles from other data sources using customizable JavaScript rules\n\n[Why Auth0?](https://auth0.com/why-auth0) Because you should save time, be happy, and focus on what really matters: building your product.\n\n## License\n\nThis project is licensed under the MIT license. See the [LICENSE](LICENSE) file for more info.\n", "import { strict as assert } from 'assert';\nimport { NextApiResponse, NextApiRequest } from 'next';\nimport { HandleCallback as BaseHandleCallback } from '../auth0-session';\nimport { Session } from '../session';\nimport { assertReqRes } from '../utils/assert';\nimport { NextConfig } from '../config';\nimport { HandlerError } from '../utils/errors';\n\n/**\n * Use this function for validating additional claims on the user's ID Token or adding removing items from\n * the session after login, eg\n *\n * ### Validate additional claims\n *\n * ```js\n * // pages/api/auth/[...auth0].js\n * import { handleAuth, handleCallback } from '@auth0/nextjs-auth0';\n *\n * const afterCallback = (req, res, session, state) => {\n *   if (!session.user.isAdmin) {\n *     throw new UnauthorizedError('User is not admin');\n *   }\n *   return session;\n * };\n *\n * export default handleAuth({\n *   async callback(req, res) {\n *     try {\n *       await handleCallback(req, res, { afterCallback });\n *     } catch (error) {\n *       res.status(error.status || 500).end(error.message);\n *     }\n *   }\n * });\n * ```\n *\n * ### Modify the session after login\n *\n * ```js\n * // pages/api/auth/[...auth0].js\n * import { handleAuth, handleCallback } from '@auth0/nextjs-auth0';\n *\n * const afterCallback = (req, res, session, state) => {\n *   session.user.customProperty = 'foo';\n *   delete session.refreshToken;\n *   return session;\n * };\n *\n * export default handleAuth({\n *   async callback(req, res) {\n *     try {\n *       await handleCallback(req, res, { afterCallback });\n *     } catch (error) {\n *       res.status(error.status || 500).end(error.message);\n *     }\n *   }\n * });\n * ```\n *\n * @category Server\n */\nexport type AfterCallback = (\n  req: NextApiRequest,\n  res: NextApiResponse,\n  session: Session,\n  state: { [key: string]: any }\n) => Promise<Session> | Session;\n\n/**\n * Options to customize the callback handler.\n *\n * @category Server\n */\nexport interface CallbackOptions {\n  afterCallback?: AfterCallback;\n\n  /**\n   * This is useful to specify in addition to {@Link BaseConfig.baseURL} when your app runs on multiple domains,\n   * it should match {@Link LoginOptions.authorizationParams.redirect_uri}.\n   */\n  redirectUri?: string;\n\n  /**\n   * This is useful to specify instead of {@Link NextConfig.organization} when your app has multiple\n   * organizations, it should match {@Link LoginOptions.authorizationParams}.\n   */\n  organization?: string;\n}\n\n/**\n * The handler for the `api/auth/callback` route.\n *\n * @category Server\n */\nexport type HandleCallback = (req: NextApiRequest, res: NextApiResponse, options?: CallbackOptions) => Promise<void>;\n\n/**\n * @ignore\n */\nconst idTokenValidator = (afterCallback?: AfterCallback, organization?: string): AfterCallback => (\n  req,\n  res,\n  session,\n  state\n) => {\n  if (organization) {\n    assert(session.user.org_id, 'Organization Id (org_id) claim must be a string present in the ID token');\n    assert.equal(\n      session.user.org_id,\n      organization,\n      `Organization Id (org_id) claim value mismatch in the ID token; ` +\n        `expected \"${organization}\", found \"${session.user.org_id}\"`\n    );\n  }\n  if (afterCallback) {\n    return afterCallback(req, res, session, state);\n  }\n  return session;\n};\n\n/**\n * @ignore\n */\nexport default function handleCallbackFactory(handler: BaseHandleCallback, config: NextConfig): HandleCallback {\n  return async (req, res, options = {}): Promise<void> => {\n    try {\n      assertReqRes(req, res);\n      return await handler(req, res, {\n        ...options,\n        afterCallback: idTokenValidator(options.afterCallback, options.organization || config.organization)\n      });\n    } catch (e) {\n      throw new HandlerError(e);\n    }\n  };\n}\n", "import { NextApiResponse, NextApiRequest } from 'next';\nimport { AuthorizationParameters, HandleLogin as BaseHandleLogin } from '../auth0-session';\nimport isSafeRedirect from '../utils/url-helpers';\nimport { assertReqRes } from '../utils/assert';\nimport { NextConfig } from '../config';\nimport { HandlerError } from '../utils/errors';\n\n/**\n * Use this to store additional state for the user before they visit the Identity Provider to login.\n *\n * ```js\n * // pages/api/auth/[...auth0].js\n * import { handleAuth, handleLogin } from '@auth0/nextjs-auth0';\n *\n * const getLoginState = (req, loginOptions) => {\n *   return { basket_id: getBasketId(req) };\n * };\n *\n * export default handleAuth({\n *   async login(req, res) {\n *     try {\n *       await handleLogin(req, res, { getLoginState });\n *     } catch (error) {\n *       res.status(error.status || 500).end(error.message);\n *     }\n *   }\n * });\n * ```\n *\n * @category Server\n */\nexport type GetLoginState = (req: NextApiRequest, options: LoginOptions) => { [key: string]: any };\n\n/**\n * Authorization params to pass to the login handler.\n *\n * @category Server\n */\nexport interface AuthorizationParams extends Partial<AuthorizationParameters> {\n  /**\n   * The invitation id to join an organization.\n   *\n   * To create a link for your user's to accept an organization invite, read the `invitation` and `organization`\n   * query params and pass them to the authorization server to log the user in:\n   *\n   * ```js\n   * // pages/api/invite.js\n   * import { handleLogin } from '@auth0/nextjs-auth0';\n   *\n   * export default async function invite(req, res) {\n   *   try {\n   *     const { invitation, organization } = req.query;\n   *     if (!invitation) {\n   *       res.status(400).end('Missing \"invitation\" parameter');\n   *     }\n   *     await handleLogin(req, res, {\n   *       authorizationParams: {\n   *         invitation,\n   *         organization\n   *       }\n   *     });\n   *   } catch (error) {\n   *     res.status(error.status || 500).end(error.message);\n   *   }\n   * } ;\n   * ```\n   *\n   * Your invite url can then take the format:\n   * `https://example.com/api/invite?invitation=invitation_id&organization=org_id`\n   */\n  invitation?: string;\n  /**\n   * This is useful to specify instead of {@Link NextConfig.organization} when your app has multiple\n   * organizations, it should match {@Link CallbackOptions.organization}.\n   */\n  organization?: string;\n}\n\n/**\n * Custom options to pass to login.\n *\n * @category Server\n */\nexport interface LoginOptions {\n  /**\n   * Override the default {@link BaseConfig.authorizationParams authorizationParams}\n   */\n  authorizationParams?: AuthorizationParams;\n\n  /**\n   *  URL to return to after login, overrides the Default is {@link BaseConfig.baseURL}\n   */\n  returnTo?: string;\n\n  /**\n   *  Generate a unique state value for use during login transactions.\n   */\n  getLoginState?: GetLoginState;\n}\n\n/**\n * The handler for the `api/auth/login` route.\n *\n * @category Server\n */\nexport type HandleLogin = (req: NextApiRequest, res: NextApiResponse, options?: LoginOptions) => Promise<void>;\n\n/**\n * @ignore\n */\nexport default function handleLoginFactory(handler: BaseHandleLogin, nextConfig: NextConfig): HandleLogin {\n  return async (req, res, options = {}): Promise<void> => {\n    try {\n      assertReqRes(req, res);\n      if (req.query.returnTo) {\n        const returnTo = Array.isArray(req.query.returnTo) ? req.query.returnTo[0] : req.query.returnTo;\n\n        if (!isSafeRedirect(returnTo)) {\n          throw new Error('Invalid value provided for returnTo, must be a relative url');\n        }\n\n        options = { ...options, returnTo };\n      }\n      if (nextConfig.organization) {\n        options = {\n          ...options,\n          authorizationParams: { organization: nextConfig.organization, ...options.authorizationParams }\n        };\n      }\n\n      return await handler(req, res, options);\n    } catch (e) {\n      throw new HandlerError(e);\n    }\n  };\n}\n", "import { NextApiResponse, NextApiRequest } from 'next';\nimport { HandleLogout as BaseHandleLogout } from '../auth0-session';\nimport { assertReqRes } from '../utils/assert';\nimport { HandlerError } from '../utils/errors';\n\n/**\n * Custom options to pass to logout.\n *\n * @category Server\n */\nexport interface LogoutOptions {\n  /**\n   *  URL to returnTo after logout, overrides the\n   *  Default in {@link BaseConfig.routes.postLogoutRedirect routes.postLogoutRedirect}\n   */\n  returnTo?: string;\n}\n\n/**\n * The handler for the `api/auth/logout` route.\n *\n * @category Server\n */\nexport type HandleLogout = (req: NextApiRequest, res: NextApiResponse, options?: LogoutOptions) => Promise<void>;\n\n/**\n * @ignore\n */\nexport default function handleLogoutFactory(handler: BaseHandleLogout): HandleLogout {\n  return async (req, res, options): Promise<void> => {\n    try {\n      assertReqRes(req, res);\n      return await handler(req, res, options);\n    } catch (e) {\n      throw new HandlerError(e);\n    }\n  };\n}\n", "import { NextApiResponse, NextApiRequest } from 'next';\nimport { ClientFactory } from '../auth0-session';\nimport { SessionCache, Session, fromJson, GetAccessToken } from '../session';\nimport { assertReqRes } from '../utils/assert';\nimport { HandlerError } from '../utils/errors';\n\nexport type AfterRefetch = (req: NextApiRequest, res: NextApiResponse, session: Session) => Promise<Session> | Session;\n\n/**\n * Custom options for {@link HandleProfile}\n *\n * @category Server\n */\nexport type ProfileOptions = {\n  /**\n   * If set to `true` this will refetch the user profile information from `/userinfo` and save it to the session.\n   */\n  refetch?: boolean;\n\n  /**\n   * Like {@AfterCallback} when a session is created, you can use this function to validate or add/remove claims\n   * after the session is updated. Will only run if {@link ProfileOptions.refetch} is `true`\n   */\n  afterRefetch?: AfterRefetch;\n};\n\n/**\n * The handler for the `/api/auth/me` route.\n *\n * @category Server\n */\nexport type HandleProfile = (req: NextApiRequest, res: NextApiResponse, options?: ProfileOptions) => Promise<void>;\n\n/**\n * @ignore\n */\nexport default function profileHandler(\n  getClient: ClientFactory,\n  getAccessToken: GetAccessToken,\n  sessionCache: SessionCache\n): HandleProfile {\n  return async (req, res, options): Promise<void> => {\n    try {\n      assertReqRes(req, res);\n\n      if (!sessionCache.isAuthenticated(req, res)) {\n        res.status(401).json({\n          error: 'not_authenticated',\n          description: 'The user does not have an active session or is not authenticated'\n        });\n        return;\n      }\n\n      const session = sessionCache.get(req, res) as Session;\n      res.setHeader('Cache-Control', 'no-store');\n\n      if (options?.refetch) {\n        const { accessToken } = await getAccessToken(req, res);\n        if (!accessToken) {\n          throw new Error('No access token available to refetch the profile');\n        }\n\n        const client = await getClient();\n        const userInfo = await client.userinfo(accessToken);\n\n        let newSession = fromJson({\n          ...session,\n          user: {\n            ...session.user,\n            ...userInfo\n          }\n        }) as Session;\n\n        if (options.afterRefetch) {\n          newSession = await options.afterRefetch(req, res, newSession);\n        }\n\n        sessionCache.set(req, res, newSession);\n\n        res.json(newSession.user);\n        return;\n      }\n\n      res.json(session.user);\n    } catch (e) {\n      throw new HandlerError(e);\n    }\n  };\n}\n", "import { HttpError } from 'http-errors';\n\n/**\n * The error thrown by {@link GetAccessToken}\n *\n * @category Server\n */\nexport class AccessTokenError extends Error {\n  public code: string;\n\n  constructor(code: string, message: string) {\n    super(message);\n\n    // Saving class name in the property of our custom error as a shortcut.\n    this.name = this.constructor.name;\n\n    // Capturing stack trace, excluding constructor call from it.\n    Error.captureStackTrace(this, this.constructor);\n\n    // Machine readable code.\n    this.code = code;\n  }\n}\n\n// eslint-disable-next-line max-len\n// Basic escaping for putting untrusted data directly into the HTML body, per: https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html#rule-1-html-encode-before-inserting-untrusted-data-into-html-element-content\nfunction htmlSafe(input: string): string {\n  return input\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;');\n}\n\n/**\n * The error thrown by API route handlers.\n *\n * Because the error message can come from the OpenID Connect `error` query parameter we\n * do some basic escaping which makes sure the default error handler is safe from XSS.\n *\n * If you write your own error handler, you should **not** render the error message\n * without using a templating engine that will properly escape it for other HTML contexts first.\n *\n * @category Server\n */\nexport class HandlerError extends Error {\n  public status: number | undefined;\n  public code: string | undefined;\n\n  constructor(error: Error | AccessTokenError | HttpError) {\n    super(htmlSafe(error.message));\n\n    this.name = error.name;\n\n    if ('code' in error) {\n      this.code = error.code;\n    }\n\n    if ('status' in error) {\n      this.status = error.status;\n    }\n  }\n}\n", "import nock from 'nock';\nimport { CookieJar } from 'tough-cookie';\nimport { JWT } from 'jose';\nimport { encodeState } from '../../../src/auth0-session/hooks/get-login-state';\nimport { SessionResponse, setup, teardown } from '../fixtures/server';\nimport { makeIdToken } from '../fixtures/cert';\nimport { toSignedCookieJar, get, post, defaultConfig } from '../fixtures/helpers';\n\nconst expectedDefaultState = encodeState({ returnTo: 'https://example.org' });\n\ndescribe('callback', () => {\n  afterEach(teardown);\n\n  it('should error when the body is empty', async () => {\n    const baseURL = await setup(defaultConfig);\n\n    const cookieJar = toSignedCookieJar(\n      {\n        nonce: '__test_nonce__',\n        state: '__test_state__'\n      },\n      baseURL\n    );\n\n    await expect(post(baseURL, '/callback', { body: {}, cookieJar })).rejects.toThrowError(\n      'state missing from the response'\n    );\n  });\n\n  it('should error when the state cookie is missing', async () => {\n    const baseURL = await setup(defaultConfig);\n\n    await expect(\n      post(baseURL, '/callback', {\n        body: {\n          state: '__test_state__',\n          id_token: '__invalid_token__'\n        },\n        cookieJar: new CookieJar()\n      })\n    ).rejects.toThrowError('checks.state argument is missing');\n  });\n\n  it(\"should error when state doesn't match\", async () => {\n    const baseURL = await setup(defaultConfig);\n\n    const cookieJar = toSignedCookieJar(\n      {\n        nonce: '__valid_nonce__',\n        state: '__valid_state__'\n      },\n      baseURL\n    );\n\n    await expect(\n      post(baseURL, '/callback', {\n        body: {\n          state: '__invalid_state__',\n          id_token: '__invalid_token__'\n        },\n        cookieJar\n      })\n    ).rejects.toThrowError('state mismatch, expected __valid_state__, got: __invalid_state__');\n  });\n\n  it(\"should error when id_token can't be parsed\", async () => {\n    const baseURL = await setup(defaultConfig);\n\n    const cookieJar = toSignedCookieJar(\n      {\n        nonce: '__valid_nonce__',\n        state: '__valid_state__'\n      },\n      baseURL\n    );\n\n    await expect(\n      post(baseURL, '/callback', {\n        body: {\n          state: '__valid_state__',\n          id_token: '__invalid_token__'\n        },\n        cookieJar\n      })\n    ).rejects.toThrowError('failed to decode JWT (JWTMalformed: JWTs must have three components)');\n  });\n\n  it('should error when id_token has invalid alg', async () => {\n    const baseURL = await setup(defaultConfig);\n\n    const cookieJar = toSignedCookieJar(\n      {\n        nonce: '__valid_nonce__',\n        state: '__valid_state__'\n      },\n      baseURL\n    );\n\n    await expect(\n      post(baseURL, '/callback', {\n        body: {\n          state: '__valid_state__',\n          id_token: JWT.sign({ sub: '__test_sub__' }, 'secret', {\n            algorithm: 'HS256'\n          })\n        },\n        cookieJar\n      })\n    ).rejects.toThrowError('unexpected JWT alg received, expected RS256, got: HS256');\n  });\n\n  it('should error when id_token is missing issuer', async () => {\n    const baseURL = await setup(defaultConfig);\n\n    const cookieJar = toSignedCookieJar(\n      {\n        nonce: '__valid_nonce__',\n        state: '__valid_state__'\n      },\n      baseURL\n    );\n\n    await expect(\n      post(baseURL, '/callback', {\n        body: {\n          state: '__valid_state__',\n          id_token: makeIdToken({ iss: undefined })\n        },\n        cookieJar\n      })\n    ).rejects.toThrowError('missing required JWT property iss');\n  });\n\n  it('should error when nonce is missing from cookies', async () => {\n    const baseURL = await setup(defaultConfig);\n\n    const cookieJar = toSignedCookieJar(\n      {\n        state: '__valid_state__'\n      },\n      baseURL\n    );\n\n    await expect(\n      post(baseURL, '/callback', {\n        body: {\n          state: '__valid_state__',\n          id_token: makeIdToken({ nonce: '__test_nonce__' })\n        },\n        cookieJar\n      })\n    ).rejects.toThrowError('nonce mismatch, expected undefined, got: __test_nonce__');\n  });\n\n  it('should error when legacy samesite fallback is off', async () => {\n    const baseURL = await setup({ ...defaultConfig, legacySameSiteCookie: false });\n\n    const cookieJar = toSignedCookieJar(\n      {\n        _state: '__valid_state__'\n      },\n      baseURL\n    );\n\n    await expect(\n      post(baseURL, '/callback', {\n        body: {\n          state: '__valid_state__',\n          id_token: makeIdToken()\n        },\n        cookieJar\n      })\n    ).rejects.toThrowError('checks.state argument is missing');\n  });\n\n  it('should error for expired ID Token', async () => {\n    const baseURL = await setup({ ...defaultConfig, legacySameSiteCookie: false });\n\n    const expected = {\n      nickname: '__test_nickname__',\n      sub: '__test_sub__',\n      iss: 'https://op.example.com/',\n      aud: '__test_client_id__',\n      nonce: '__test_nonce__',\n      auth_time: 10\n    };\n\n    const cookieJar = toSignedCookieJar(\n      {\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n        max_age: '100'\n      },\n      baseURL\n    );\n\n    await expect(\n      post(baseURL, '/callback', {\n        body: {\n          state: expectedDefaultState,\n          id_token: makeIdToken(expected)\n        },\n        cookieJar\n      })\n    ).rejects.toThrowError('too much time has elapsed since the last End-User authentication');\n  });\n\n  it('should expose the id token claims when id_token is valid', async () => {\n    const baseURL = await setup({ ...defaultConfig, legacySameSiteCookie: false });\n\n    const expected = {\n      nickname: '__test_nickname__',\n      sub: '__test_sub__',\n      iss: 'https://op.example.com/',\n      aud: '__test_client_id__',\n      nonce: '__test_nonce__'\n    };\n\n    const cookieJar = toSignedCookieJar(\n      {\n        state: expectedDefaultState,\n        nonce: '__test_nonce__'\n      },\n      baseURL\n    );\n\n    const { res } = await post(baseURL, '/callback', {\n      body: {\n        state: expectedDefaultState,\n        id_token: makeIdToken(expected)\n      },\n      cookieJar,\n      fullResponse: true\n    });\n\n    const session: SessionResponse = await get(baseURL, '/session', { cookieJar });\n\n    expect(res.headers.location).toEqual('https://example.org');\n    expect(session.claims).toEqual(expect.objectContaining(expected));\n  });\n\n  it(\"should expose all tokens when id_token is valid and response_type is 'code id_token'\", async () => {\n    const baseURL = await setup({\n      ...defaultConfig,\n      clientSecret: '__test_client_secret__',\n      authorizationParams: {\n        response_type: 'code id_token',\n        audience: 'https://api.example.com/',\n        scope: 'openid profile email read:reports offline_access'\n      }\n    });\n\n    const idToken = makeIdToken({\n      c_hash: '77QmUPtjPfzWtF2AnpK9RQ'\n    });\n\n    nock('https://op.example.com')\n      .post('/oauth/token')\n      .reply(200, () => ({\n        access_token: '__test_access_token__',\n        refresh_token: '__test_refresh_token__',\n        id_token: idToken,\n        token_type: 'Bearer',\n        expires_in: 86400\n      }));\n\n    const cookieJar = toSignedCookieJar(\n      {\n        state: expectedDefaultState,\n        nonce: '__test_nonce__'\n      },\n      baseURL\n    );\n\n    await post(baseURL, '/callback', {\n      body: {\n        state: expectedDefaultState,\n        id_token: idToken,\n        code: 'jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y'\n      },\n      cookieJar\n    });\n\n    const session: SessionResponse = await get(baseURL, '/session', { cookieJar });\n    expect(session).toEqual(\n      expect.objectContaining({\n        token_type: 'Bearer',\n        access_token: '__test_access_token__',\n        id_token: idToken,\n        refresh_token: '__test_refresh_token__',\n        expires_at: expect.any(Number)\n      })\n    );\n  });\n\n  it('should use basic auth on token endpoint when using code flow', async () => {\n    const idToken = makeIdToken({\n      c_hash: '77QmUPtjPfzWtF2AnpK9RQ'\n    });\n\n    const baseURL = await setup({\n      ...defaultConfig,\n      clientSecret: '__test_client_secret__',\n      authorizationParams: {\n        response_type: 'code id_token',\n        audience: 'https://api.example.com/',\n        scope: 'openid profile email read:reports offline_access'\n      }\n    });\n\n    let credentials = '';\n    let body = '';\n    nock('https://op.example.com')\n      .post('/oauth/token')\n      .reply(200, function (_uri, requestBody) {\n        credentials = this.req.headers.authorization.replace('Basic ', '');\n        body = requestBody as string;\n        return {\n          access_token: '__test_access_token__',\n          refresh_token: '__test_refresh_token__',\n          id_token: idToken,\n          token_type: 'Bearer',\n          expires_in: 86400\n        };\n      });\n\n    const cookieJar = toSignedCookieJar(\n      {\n        state: expectedDefaultState,\n        nonce: '__test_nonce__'\n      },\n      baseURL\n    );\n\n    const code = 'jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y';\n    await post(baseURL, '/callback', {\n      body: {\n        state: expectedDefaultState,\n        id_token: idToken,\n        code\n      },\n      cookieJar\n    });\n\n    expect(Buffer.from(credentials, 'base64').toString()).toEqual('__test_client_id__:__test_client_secret__');\n    expect(body).toEqual(\n      `grant_type=authorization_code&code=${code}&redirect_uri=${encodeURIComponent(baseURL)}%2Fcallback`\n    );\n  });\n\n  it('should redirect to default base url', async () => {\n    const baseURL = await setup(defaultConfig);\n\n    const state = encodeState({ foo: 'bar' });\n    const cookieJar = toSignedCookieJar(\n      {\n        state: state,\n        nonce: '__test_nonce__'\n      },\n      baseURL\n    );\n\n    const { res } = await post(baseURL, '/callback', {\n      body: {\n        state: state,\n        id_token: makeIdToken()\n      },\n      cookieJar,\n      fullResponse: true\n    });\n\n    expect(res.statusCode).toEqual(302);\n    expect(res.headers.location).toEqual(baseURL);\n  });\n\n  it('should accept custom runtime redirect over base url', async () => {\n    const redirectUri = 'http://messi:3000/api/auth/callback/runtime';\n    const baseURL = await setup(defaultConfig, { callbackOptions: { redirectUri } });\n    const state = encodeState({ foo: 'bar' });\n    const cookieJar = toSignedCookieJar({ state, nonce: '__test_nonce__' }, baseURL);\n    const { res } = await post(baseURL, '/callback', {\n      body: {\n        state: state,\n        id_token: makeIdToken()\n      },\n      cookieJar,\n      fullResponse: true\n    });\n\n    expect(res.statusCode).toEqual(302);\n    expect(res.headers.location).toEqual(baseURL);\n  });\n});\n", "import nock from 'nock';\nimport { JSONWebKeySet } from 'jose';\nimport { ConfigParameters } from '../../src';\nimport { makeIdToken } from '../auth0-session/fixtures/cert';\n\nexport function discovery(params: ConfigParameters, discoveryOptions?: any): nock.Scope {\n  const { error, ...metadata } = discoveryOptions || {};\n\n  if (error) {\n    return nock(params.issuerBaseURL as string)\n      .get('/.well-known/openid-configuration')\n      .reply(500, { error })\n      .get('/.well-known/oauth-authorization-server')\n      .reply(500, { error });\n  }\n\n  return nock(params.issuerBaseURL as string)\n    .get('/.well-known/openid-configuration')\n    .reply(200, () => {\n      return {\n        issuer: `${params.issuerBaseURL}/`,\n        authorization_endpoint: `${params.issuerBaseURL}/authorize`,\n        token_endpoint: `${params.issuerBaseURL}/oauth/token`,\n        userinfo_endpoint: `${params.issuerBaseURL}/userinfo`,\n        jwks_uri: `${params.issuerBaseURL}/.well-known/jwks.json`,\n        scopes_supported: [\n          'openid',\n          'profile',\n          'offline_access',\n          'name',\n          'given_name',\n          'family_name',\n          'nickname',\n          'email',\n          'email_verified',\n          'picture',\n          'created_at',\n          'identities',\n          'phone',\n          'address'\n        ],\n        response_types_supported: ['code'],\n        id_token_signing_alg_values_supported: ['RS256'],\n        token_endpoint_auth_methods_supported: ['client_secret_basic', 'client_secret_post'],\n        claims_supported: [\n          'aud',\n          'auth_time',\n          'created_at',\n          'email',\n          'email_verified',\n          'exp',\n          'family_name',\n          'given_name',\n          'iat',\n          'identities',\n          'iss',\n          'name',\n          'nickname',\n          'phone_number',\n          'picture',\n          'sub'\n        ],\n        ...metadata\n      };\n    });\n}\n\nexport function userInfoWithDelay(params: ConfigParameters, delay: number): nock.Scope {\n  return nock(params.issuerBaseURL as string)\n    .get('/userinfo')\n    .reply((_uri, _requestBody, cb) => {\n      setTimeout(() => cb(null, [200, {}]), delay);\n    });\n}\n\nexport function jwksEndpoint(params: ConfigParameters, keyset: JSONWebKeySet): nock.Scope {\n  return nock(params.issuerBaseURL as string)\n    .get('/.well-known/jwks.json')\n    .reply(200, keyset);\n}\n\nexport function codeExchange(params: ConfigParameters, idToken: string, code = 'code'): nock.Scope {\n  return nock(`${params.issuerBaseURL}`)\n    .post(\n      '/oauth/token',\n      `grant_type=authorization_code&code=${code}&redirect_uri=${encodeURIComponent(\n        `${params.baseURL}api/auth/callback`\n      )}`\n    )\n    .reply(200, {\n      access_token: 'eyJz93a...k4laUWw',\n      expires_in: 750,\n      scope: 'read:foo delete:foo',\n      refresh_token: 'GEbRxBN...edjnXbL',\n      id_token: idToken,\n      token_type: 'Bearer'\n    });\n}\n\nexport function refreshTokenExchange(\n  params: ConfigParameters,\n  refreshToken: string,\n  payload: object,\n  newToken?: string\n): nock.Scope {\n  const idToken = makeIdToken({\n    iss: `${params.issuerBaseURL}/`,\n    aud: params.clientID,\n    ...payload\n  });\n\n  return nock(`${params.issuerBaseURL}`)\n    .post('/oauth/token', `grant_type=refresh_token&refresh_token=${refreshToken}`)\n    .reply(200, {\n      access_token: newToken || 'eyJz93a...k4laUWw',\n      id_token: idToken,\n      token_type: 'Bearer',\n      expires_in: 750,\n      scope: 'read:foo write:foo'\n    });\n}\n\nexport function refreshTokenRotationExchange(\n  params: ConfigParameters,\n  refreshToken: string,\n  payload: object,\n  newToken?: string,\n  newrefreshToken?: string\n): nock.Scope {\n  const idToken = makeIdToken({\n    iss: `${params.issuerBaseURL}/`,\n    aud: params.clientID,\n    ...payload\n  });\n\n  return nock(`${params.issuerBaseURL}`)\n    .post('/oauth/token', `grant_type=refresh_token&refresh_token=${refreshToken}`)\n    .reply(200, {\n      access_token: newToken || 'eyJz93a...k4laUWw',\n      refresh_token: newrefreshToken || 'GEbRxBN...edjnXbL',\n      id_token: idToken,\n      token_type: 'Bearer',\n      expires_in: 750,\n      scope: 'read:foo write:foo'\n    });\n}\n\nexport function userInfo(params: ConfigParameters, token: string, payload: object): nock.Scope {\n  return nock(`${params.issuerBaseURL}`, {\n    reqheaders: {\n      authorization: `Bearer ${token}`\n    }\n  })\n    .get('/userinfo')\n    .reply(200, payload);\n}\n", "import { CookieJar } from 'tough-cookie';\nimport timekeeper = require('timekeeper');\nimport { withApi, withoutApi } from '../fixtures/default-settings';\nimport { makeIdToken } from '../auth0-session/fixtures/cert';\nimport { get, post, toSignedCookieJar } from '../auth0-session/fixtures/helpers';\nimport { encodeState } from '../../src/auth0-session/hooks/get-login-state';\nimport { setup, teardown } from '../fixtures/setup';\nimport { Session, AfterCallback } from '../../src';\n\nconst callback = (baseUrl: string, body: any, cookieJar?: CookieJar): Promise<any> =>\n  post(baseUrl, `/api/auth/callback`, {\n    body,\n    cookieJar,\n    fullResponse: true\n  });\n\ndescribe('callback handler', () => {\n  afterEach(teardown);\n\n  test('should require a state', async () => {\n    const baseUrl = await setup(withoutApi);\n    await expect(\n      callback(baseUrl, {\n        state: '__test_state__'\n      })\n    ).rejects.toThrow('checks.state argument is missing');\n  });\n\n  test('should validate the state', async () => {\n    const baseUrl = await setup(withoutApi);\n    const cookieJar = toSignedCookieJar(\n      {\n        state: '__other_state__'\n      },\n      baseUrl\n    );\n    await expect(\n      callback(\n        baseUrl,\n        {\n          state: '__test_state__'\n        },\n        cookieJar\n      )\n    ).rejects.toThrow('state mismatch, expected __other_state__, got: __test_state__');\n  });\n\n  test('should validate the audience', async () => {\n    const baseUrl = await setup(withoutApi, { idTokenClaims: { aud: 'bar' } });\n    const state = encodeState({ returnTo: baseUrl });\n    const cookieJar = toSignedCookieJar(\n      {\n        state,\n        nonce: '__test_nonce__'\n      },\n      baseUrl\n    );\n    await expect(\n      callback(\n        baseUrl,\n        {\n          state,\n          code: 'code'\n        },\n        cookieJar\n      )\n    ).rejects.toThrow('aud mismatch, expected __test_client_id__, got: bar');\n  });\n\n  test('should validate the issuer', async () => {\n    const baseUrl = await setup(withoutApi, { idTokenClaims: { aud: 'bar', iss: 'other-issuer' } });\n    const state = encodeState({ returnTo: baseUrl });\n    const cookieJar = toSignedCookieJar(\n      {\n        state,\n        nonce: '__test_nonce__'\n      },\n      baseUrl\n    );\n    await expect(\n      callback(\n        baseUrl,\n        {\n          state,\n          code: 'code'\n        },\n        cookieJar\n      )\n    ).rejects.toThrow('unexpected iss value, expected https://acme.auth0.local/, got: other-issuer');\n  });\n\n  it('should escape html in error qp', async () => {\n    const baseUrl = await setup(withoutApi);\n    await expect(get(baseUrl, `/api/auth/callback?error=%3Cscript%3Ealert(%27xss%27)%3C%2Fscript%3E`)).rejects.toThrow(\n      '&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;'\n    );\n  });\n\n  test('should create the session without OIDC claims', async () => {\n    const baseUrl = await setup(withoutApi);\n    const state = encodeState({ returnTo: baseUrl });\n    const cookieJar = toSignedCookieJar(\n      {\n        state,\n        nonce: '__test_nonce__'\n      },\n      baseUrl\n    );\n    const { res } = await callback(\n      baseUrl,\n      {\n        state,\n        code: 'code'\n      },\n      cookieJar\n    );\n    expect(res.statusCode).toBe(302);\n    const body = await get(baseUrl, `/api/session`, { cookieJar });\n\n    expect(body.user).toStrictEqual({\n      nickname: '__test_nickname__',\n      sub: '__test_sub__'\n    });\n  });\n\n  test('should set the correct expiration', async () => {\n    timekeeper.freeze(0);\n    const baseUrl = await setup(withoutApi);\n    const state = encodeState({ returnTo: baseUrl });\n    const cookieJar = toSignedCookieJar(\n      {\n        state,\n        nonce: '__test_nonce__'\n      },\n      baseUrl\n    );\n    const { res } = await post(baseUrl, `/api/auth/callback`, {\n      fullResponse: true,\n      cookieJar,\n      body: {\n        state,\n        code: 'code'\n      }\n    });\n    expect(res.statusCode).toBe(302);\n\n    const [sessionCookie] = cookieJar.getCookiesSync(baseUrl);\n    const expiryInHrs = new Date(sessionCookie.expires).getTime() / 1000 / 60 / 60;\n    expect(expiryInHrs).toBe(24);\n    timekeeper.reset();\n  });\n\n  test('should create the session without OIDC claims with api config', async () => {\n    timekeeper.freeze(0);\n    const baseUrl = await setup(withApi);\n    const state = encodeState({ returnTo: baseUrl });\n    const cookieJar = toSignedCookieJar(\n      {\n        state,\n        nonce: '__test_nonce__'\n      },\n      baseUrl\n    );\n    const { res } = await callback(\n      baseUrl,\n      {\n        state,\n        code: 'code'\n      },\n      cookieJar\n    );\n    expect(res.statusCode).toBe(302);\n    const session = await get(baseUrl, `/api/session`, { cookieJar });\n\n    expect(session).toStrictEqual({\n      accessToken: 'eyJz93a...k4laUWw',\n      accessTokenExpiresAt: 750,\n      accessTokenScope: 'read:foo delete:foo',\n      idToken: makeIdToken({ iss: 'https://acme.auth0.local/' }),\n      token_type: 'Bearer',\n      refreshToken: 'GEbRxBN...edjnXbL',\n      user: {\n        nickname: '__test_nickname__',\n        sub: '__test_sub__'\n      }\n    });\n    timekeeper.reset();\n  });\n\n  test('remove tokens with afterCallback hook', async () => {\n    timekeeper.freeze(0);\n    const afterCallback: AfterCallback = (_req, _res, session: Session): Session => {\n      delete session.accessToken;\n      delete session.refreshToken;\n      return session;\n    };\n    const baseUrl = await setup(withApi, { callbackOptions: { afterCallback } });\n    const state = encodeState({ returnTo: baseUrl });\n    const cookieJar = toSignedCookieJar(\n      {\n        state,\n        nonce: '__test_nonce__'\n      },\n      baseUrl\n    );\n    const { res } = await callback(\n      baseUrl,\n      {\n        state,\n        code: 'code'\n      },\n      cookieJar\n    );\n    expect(res.statusCode).toBe(302);\n    const session = await get(baseUrl, `/api/session`, { cookieJar });\n\n    expect(session).toStrictEqual({\n      accessTokenExpiresAt: 750,\n      accessTokenScope: 'read:foo delete:foo',\n      idToken: makeIdToken({ iss: 'https://acme.auth0.local/' }),\n      token_type: 'Bearer',\n      user: {\n        nickname: '__test_nickname__',\n        sub: '__test_sub__'\n      }\n    });\n    timekeeper.reset();\n  });\n\n  test('add properties to session with afterCallback hook', async () => {\n    timekeeper.freeze(0);\n    const afterCallback: AfterCallback = (_req, _res, session: Session): Session => {\n      session.foo = 'bar';\n      return session;\n    };\n    const baseUrl = await setup(withApi, { callbackOptions: { afterCallback } });\n    const state = encodeState({ returnTo: baseUrl });\n    const cookieJar = toSignedCookieJar(\n      {\n        state,\n        nonce: '__test_nonce__'\n      },\n      baseUrl\n    );\n    const { res } = await callback(\n      baseUrl,\n      {\n        state,\n        code: 'code'\n      },\n      cookieJar\n    );\n    expect(res.statusCode).toBe(302);\n    const session = await get(baseUrl, '/api/session', { cookieJar });\n\n    expect(session).toMatchObject({\n      foo: 'bar',\n      user: {\n        nickname: '__test_nickname__',\n        sub: '__test_sub__'\n      }\n    });\n    timekeeper.reset();\n  });\n\n  test('throws from afterCallback hook', async () => {\n    const afterCallback = (): Session => {\n      throw new Error('some validation error.');\n    };\n    const baseUrl = await setup(withApi, { callbackOptions: { afterCallback } });\n    const state = encodeState({ returnTo: baseUrl });\n    const cookieJar = toSignedCookieJar(\n      {\n        state,\n        nonce: '__test_nonce__'\n      },\n      baseUrl\n    );\n    await expect(\n      callback(\n        baseUrl,\n        {\n          state,\n          code: 'code'\n        },\n        cookieJar\n      )\n    ).rejects.toThrow('some validation error.');\n  });\n\n  test('throws for missing org_id claim', async () => {\n    const baseUrl = await setup({ ...withApi, organization: 'foo' });\n    const state = encodeState({ returnTo: baseUrl });\n    const cookieJar = toSignedCookieJar(\n      {\n        state,\n        nonce: '__test_nonce__'\n      },\n      baseUrl\n    );\n    await expect(\n      callback(\n        baseUrl,\n        {\n          state,\n          code: 'code'\n        },\n        cookieJar\n      )\n    ).rejects.toThrow('Organization Id (org_id) claim must be a string present in the ID token');\n  });\n\n  test('throws for org_id claim mismatch', async () => {\n    const baseUrl = await setup({ ...withApi, organization: 'foo' }, { idTokenClaims: { org_id: 'bar' } });\n    const state = encodeState({ returnTo: baseUrl });\n    const cookieJar = toSignedCookieJar(\n      {\n        state,\n        nonce: '__test_nonce__'\n      },\n      baseUrl\n    );\n    await expect(\n      callback(\n        baseUrl,\n        {\n          state,\n          code: 'code'\n        },\n        cookieJar\n      )\n    ).rejects.toThrow(\n      'Organization Id (org_id) claim value mismatch in the ID token; expected &quot;foo&quot;, found &quot;bar&quot;'\n    );\n  });\n\n  test('accepts a valid organization', async () => {\n    const baseUrl = await setup(withApi, {\n      idTokenClaims: { org_id: 'foo' },\n      callbackOptions: { organization: 'foo' }\n    });\n    const state = encodeState({ returnTo: baseUrl });\n    const cookieJar = toSignedCookieJar(\n      {\n        state,\n        nonce: '__test_nonce__'\n      },\n      baseUrl\n    );\n    await expect(\n      callback(\n        baseUrl,\n        {\n          state,\n          code: 'code'\n        },\n        cookieJar\n      )\n    ).resolves.not.toThrow();\n    const session = await get(baseUrl, '/api/session', { cookieJar });\n\n    expect(session.user.org_id).toEqual('foo');\n  });\n});\n", "import { parse as urlParse } from 'url';\nimport { withoutApi, withApi } from '../fixtures/default-settings';\nimport { decodeState } from '../../src/auth0-session/hooks/get-login-state';\nimport { setup, teardown } from '../fixtures/setup';\nimport { get, getCookie } from '../auth0-session/fixtures/helpers';\nimport { Cookie, CookieJar } from 'tough-cookie';\n\ndescribe('login handler', () => {\n  afterEach(teardown);\n\n  test('should create a state', async () => {\n    const baseUrl = await setup(withoutApi);\n    const cookieJar = new CookieJar();\n    await get(baseUrl, '/api/auth/login', { cookieJar });\n\n    expect(cookieJar.getCookiesSync(baseUrl)).toEqual(\n      expect.arrayContaining([\n        expect.objectContaining({\n          key: 'nonce',\n          value: expect.any(String),\n          path: '/',\n          sameSite: 'lax'\n        }),\n        expect.objectContaining({\n          key: 'state',\n          value: expect.any(String),\n          path: '/',\n          sameSite: 'lax'\n        }),\n        expect.objectContaining({\n          key: 'code_verifier',\n          value: expect.any(String),\n          path: '/',\n          sameSite: 'lax'\n        })\n      ])\n    );\n  });\n\n  test('should add returnTo to the state', async () => {\n    const baseUrl = await setup(withoutApi, { loginOptions: { returnTo: '/custom-url' } });\n    const cookieJar = new CookieJar();\n    await get(baseUrl, '/api/auth/login', { cookieJar });\n\n    const { value: state } = getCookie('state', cookieJar, baseUrl) as Cookie;\n    expect(state).toBeTruthy();\n\n    const decodedState = decodeState(state.split('.')[0]);\n    expect(decodedState.returnTo).toEqual('/custom-url');\n  });\n\n  test('should redirect to the identity provider', async () => {\n    const baseUrl = await setup(withoutApi);\n    const cookieJar = new CookieJar();\n    const {\n      res: { statusCode, headers }\n    } = await get(baseUrl, '/api/auth/login', { cookieJar, fullResponse: true });\n\n    expect(statusCode).toBe(302);\n\n    const { value: state } = getCookie('state', cookieJar, baseUrl) as Cookie;\n    expect(urlParse(headers.location, true)).toMatchObject({\n      protocol: 'https:',\n      host: 'acme.auth0.local',\n      hash: null,\n      query: {\n        client_id: '__test_client_id__',\n        scope: 'openid profile email',\n        response_type: 'code',\n        redirect_uri: 'http://www.acme.com/api/auth/callback',\n        nonce: expect.any(String),\n        state: state.split('.')[0],\n        code_challenge: expect.any(String),\n        code_challenge_method: 'S256'\n      },\n      pathname: '/authorize'\n    });\n  });\n\n  test('should allow sending custom parameters to the authorization server', async () => {\n    const loginOptions = {\n      authorizationParams: {\n        max_age: 123,\n        login_hint: 'foo@acme.com',\n        ui_locales: 'nl',\n        scope: 'some other scope openid',\n        foo: 'bar',\n        organization: 'foo',\n        invitation: 'bar'\n      }\n    };\n    const baseUrl = await setup(withoutApi, { loginOptions });\n    const cookieJar = new CookieJar();\n    const {\n      res: { statusCode, headers }\n    } = await get(baseUrl, '/api/auth/login', { cookieJar, fullResponse: true });\n\n    expect(statusCode).toBe(302);\n    expect(urlParse(headers.location, true)).toMatchObject({\n      query: {\n        ...loginOptions.authorizationParams,\n        max_age: '123'\n      }\n    });\n  });\n\n  test('should pass organization config to the authorization server', async () => {\n    const baseUrl = await setup({ ...withoutApi, organization: 'foo' });\n    const cookieJar = new CookieJar();\n    const {\n      res: { statusCode, headers }\n    } = await get(baseUrl, '/api/auth/login', { cookieJar, fullResponse: true });\n\n    expect(statusCode).toBe(302);\n    expect(urlParse(headers.location, true)).toMatchObject({\n      query: {\n        organization: 'foo'\n      }\n    });\n  });\n\n  test('should prefer organization auth param to config', async () => {\n    const baseUrl = await setup(\n      { ...withoutApi, organization: 'foo' },\n      { loginOptions: { authorizationParams: { organization: 'bar' } } }\n    );\n    const cookieJar = new CookieJar();\n    const {\n      res: { statusCode, headers }\n    } = await get(baseUrl, '/api/auth/login', { cookieJar, fullResponse: true });\n\n    expect(statusCode).toBe(302);\n    expect(urlParse(headers.location, true)).toMatchObject({\n      query: {\n        organization: 'bar'\n      }\n    });\n  });\n\n  test('should allow adding custom data to the state', async () => {\n    const loginOptions = {\n      getLoginState: (): Record<string, any> => {\n        return {\n          foo: 'bar'\n        };\n      }\n    };\n    const baseUrl = await setup(withoutApi, { loginOptions });\n    const cookieJar = new CookieJar();\n    await get(baseUrl, '/api/auth/login', { cookieJar });\n\n    const { value: state } = getCookie('state', cookieJar, baseUrl) as Cookie;\n\n    const decodedState = decodeState(state.split('.')[0]);\n    expect(decodedState).toEqual({\n      foo: 'bar',\n      returnTo: 'http://www.acme.com/'\n    });\n  });\n\n  test('should merge returnTo and state', async () => {\n    const loginOptions = {\n      returnTo: '/profile',\n      getLoginState: (): Record<string, any> => {\n        return {\n          foo: 'bar'\n        };\n      }\n    };\n    const baseUrl = await setup(withoutApi, { loginOptions });\n    const cookieJar = new CookieJar();\n    await get(baseUrl, '/api/auth/login', { cookieJar });\n\n    const { value: state } = getCookie('state', cookieJar, baseUrl) as Cookie;\n\n    const decodedState = decodeState(state.split('.')[0]);\n    expect(decodedState).toEqual({\n      foo: 'bar',\n      returnTo: '/profile'\n    });\n  });\n\n  test('should allow the getState method to overwrite returnTo', async () => {\n    const loginOptions = {\n      returnTo: '/profile',\n      getLoginState: (): Record<string, any> => {\n        return {\n          foo: 'bar',\n          returnTo: '/foo'\n        };\n      }\n    };\n    const baseUrl = await setup(withoutApi, { loginOptions });\n    const cookieJar = new CookieJar();\n    await get(baseUrl, '/api/auth/login', { cookieJar });\n\n    const { value: state } = getCookie('state', cookieJar, baseUrl) as Cookie;\n\n    const decodedState = decodeState(state.split('.')[0]);\n    expect(decodedState).toEqual({\n      foo: 'bar',\n      returnTo: '/foo'\n    });\n  });\n\n  test('should allow the returnTo url to be provided in the querystring', async () => {\n    const loginOptions = {\n      returnTo: '/profile'\n    };\n    const baseUrl = await setup(withoutApi, { loginOptions });\n    const cookieJar = new CookieJar();\n    await get(baseUrl, '/api/auth/login?returnTo=/foo', { cookieJar });\n    const { value: state } = getCookie('state', cookieJar, baseUrl) as Cookie;\n\n    const decodedState = decodeState(state.split('.')[0]);\n    expect(decodedState).toEqual({\n      returnTo: '/foo'\n    });\n  });\n\n  test('should take the first returnTo url provided in the querystring', async () => {\n    const loginOptions = {\n      returnTo: '/profile'\n    };\n    const baseUrl = await setup(withoutApi, { loginOptions });\n    const cookieJar = new CookieJar();\n    await get(baseUrl, '/api/auth/login?returnTo=/foo&returnTo=/bar', { cookieJar });\n    const { value: state } = getCookie('state', cookieJar, baseUrl) as Cookie;\n\n    const decodedState = decodeState(state.split('.')[0]);\n    expect(decodedState).toEqual({\n      returnTo: '/foo'\n    });\n  });\n\n  test('should not allow absolute urls to be provided in the querystring', async () => {\n    const loginOptions = {\n      returnTo: '/default-redirect'\n    };\n    const baseUrl = await setup(withoutApi, { loginOptions });\n\n    await expect(\n      get(baseUrl, '/api/auth/login?returnTo=https://www.google.com', { fullResponse: true })\n    ).rejects.toThrow('Invalid value provided for returnTo, must be a relative url');\n  });\n\n  test('should escape html in errors', async () => {\n    const baseUrl = await setup(withoutApi, { discoveryOptions: { error: '<script>alert(\"xss\")</script>' } });\n\n    await expect(get(baseUrl, '/api/auth/login', { fullResponse: true })).rejects.toThrow(\n      '&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;'\n    );\n  });\n\n  test('should allow the returnTo to be be overwritten by getState() when provided in the querystring', async () => {\n    const loginOptions = {\n      returnTo: '/profile',\n      getLoginState: (): Record<string, any> => {\n        return {\n          returnTo: '/foo'\n        };\n      }\n    };\n    const baseUrl = await setup(withoutApi, { loginOptions });\n    const cookieJar = new CookieJar();\n    await get(baseUrl, '/api/auth/login', { cookieJar });\n    const { value: state } = getCookie('state', cookieJar, baseUrl) as Cookie;\n\n    const decodedState = decodeState(state.split('.')[0]);\n    expect(decodedState).toEqual({\n      returnTo: '/foo'\n    });\n  });\n\n  test('should redirect to the identity provider with scope and audience', async () => {\n    const baseUrl = await setup(withApi);\n    const {\n      res: { statusCode, headers }\n    } = await get(baseUrl, '/api/auth/login', { fullResponse: true });\n\n    expect(statusCode).toBe(302);\n\n    expect(urlParse(headers.location, true).query).toMatchObject({\n      scope: 'openid profile read:customer',\n      audience: 'https://api.acme.com'\n    });\n  });\n});\n", "import { parse } from 'cookie';\nimport { parse as parseUrl, URL } from 'url';\nimport { withoutApi } from '../fixtures/default-settings';\nimport { setup, teardown, login } from '../fixtures/setup';\nimport { IncomingMessage } from 'http';\n\njest.mock('../../src/utils/assert', () => ({\n  assertReqRes(req: IncomingMessage) {\n    if (req.url?.includes('error=')) {\n      const url = new URL(req.url, 'http://example.com');\n      throw new Error(url.searchParams.get('error') as string);\n    }\n  }\n}));\n\ndescribe('logout handler', () => {\n  afterEach(teardown);\n\n  test('should redirect to the identity provider', async () => {\n    const baseUrl = await setup(withoutApi);\n    const cookieJar = await login(baseUrl);\n\n    const { status, headers } = await fetch(`${baseUrl}/api/auth/logout`, {\n      redirect: 'manual',\n      headers: {\n        cookie: cookieJar.getCookieStringSync(baseUrl)\n      }\n    });\n\n    expect(status).toBe(302);\n    expect(parseUrl(headers.get('location') as string, true)).toMatchObject({\n      protocol: 'https:',\n      host: 'acme.auth0.local',\n      query: {\n        returnTo: 'http://www.acme.com',\n        client_id: '__test_client_id__'\n      },\n      pathname: '/v2/logout'\n    });\n  });\n\n  test('should return to the custom path', async () => {\n    const customReturnTo = 'https://www.foo.bar';\n    const baseUrl = await setup(withoutApi, {\n      logoutOptions: { returnTo: customReturnTo }\n    });\n    const cookieJar = await login(baseUrl);\n\n    const { status, headers } = await fetch(`${baseUrl}/api/auth/logout`, {\n      redirect: 'manual',\n      headers: {\n        cookie: cookieJar.getCookieStringSync(baseUrl)\n      }\n    });\n\n    expect(status).toBe(302);\n    expect(parseUrl(headers.get('location') as string, true).query).toMatchObject({\n      returnTo: 'https://www.foo.bar'\n    });\n  });\n\n  test('should use end_session_endpoint if available', async () => {\n    const baseUrl = await setup(withoutApi, {\n      discoveryOptions: { end_session_endpoint: 'https://my-end-session-endpoint/logout' }\n    });\n    const cookieJar = await login(baseUrl);\n\n    const { status, headers } = await fetch(`${baseUrl}/api/auth/logout`, {\n      redirect: 'manual',\n      headers: {\n        cookie: cookieJar.getCookieStringSync(baseUrl)\n      }\n    });\n\n    expect(status).toBe(302);\n    expect(parseUrl(headers.get('location') as string)).toMatchObject({\n      host: 'my-end-session-endpoint',\n      pathname: '/logout'\n    });\n  });\n\n  test('should delete the session', async () => {\n    const baseUrl = await setup(withoutApi, {\n      discoveryOptions: { end_session_endpoint: 'https://my-end-session-endpoint/logout' }\n    });\n    const cookieJar = await login(baseUrl);\n\n    const res = await fetch(`${baseUrl}/api/auth/logout`, {\n      redirect: 'manual',\n      headers: {\n        cookie: cookieJar.getCookieStringSync(baseUrl)\n      }\n    });\n\n    expect(parse(res.headers.get('set-cookie') as string)).toMatchObject({\n      appSession: '',\n      'Max-Age': '0',\n      Path: '/'\n    });\n  });\n\n  test('should escape html in errors', async () => {\n    const baseUrl = await setup(withoutApi);\n\n    const res = await fetch(`${baseUrl}/api/auth/logout?error=%3Cscript%3Ealert(%27xss%27)%3C%2Fscript%3E`);\n\n    expect(await res.text()).toEqual('&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;');\n  });\n});\n", "import nock from 'nock';\nimport { withApi, withoutApi } from '../fixtures/default-settings';\nimport { refreshTokenRotationExchange, userInfo } from '../fixtures/oidc-nocks';\nimport { get } from '../auth0-session/fixtures/helpers';\nimport { setup, teardown, login } from '../fixtures/setup';\nimport { Session, AfterCallback } from '../../src';\nimport { makeIdToken } from '../auth0-session/fixtures/cert';\nimport { IncomingMessage } from 'http';\nimport { URL } from 'url';\n\njest.mock('../../src/utils/assert', () => ({\n  assertReqRes(req: IncomingMessage) {\n    if (req.url?.includes('error=')) {\n      const url = new URL(req.url, 'http://example.com');\n      throw new Error(url.searchParams.get('error') as string);\n    }\n  }\n}));\n\ndescribe('profile handler', () => {\n  afterEach(teardown);\n\n  test('should throw an error when not logged in', async () => {\n    const baseUrl = await setup(withoutApi);\n\n    await expect(get(baseUrl, '/api/auth/me')).rejects.toThrow('Unauthorized');\n  });\n\n  test('should return the profile when logged in', async () => {\n    const baseUrl = await setup(withoutApi);\n    const cookieJar = await login(baseUrl);\n\n    const profile = await get(baseUrl, '/api/auth/me', { cookieJar });\n    expect(profile).toStrictEqual({ nickname: '__test_nickname__', sub: '__test_sub__' });\n  });\n\n  test('should not allow caching the profile response', async () => {\n    const baseUrl = await setup(withoutApi);\n    const cookieJar = await login(baseUrl);\n\n    const { res } = await get(baseUrl, '/api/auth/me', { cookieJar, fullResponse: true });\n    expect(res.headers['cache-control']).toEqual('no-store');\n  });\n\n  test('should not allow caching the profile response when refetch is true', async () => {\n    const baseUrl = await setup(withoutApi, { profileOptions: { refetch: true } });\n    const cookieJar = await login(baseUrl);\n\n    const { res } = await get(baseUrl, '/api/auth/me', { cookieJar, fullResponse: true });\n    expect(res.headers['cache-control']).toEqual('no-store');\n  });\n\n  test('should throw if re-fetching with no Access Token', async () => {\n    const afterCallback: AfterCallback = (_req, _res, session: Session): Session => {\n      delete session.accessToken;\n      return session;\n    };\n    const baseUrl = await setup(withoutApi, { profileOptions: { refetch: true }, callbackOptions: { afterCallback } });\n    const cookieJar = await login(baseUrl);\n\n    await expect(get(baseUrl, '/api/auth/me', { cookieJar })).rejects.toThrow(\n      'The user does not have a valid access token.'\n    );\n  });\n\n  test('should refetch the user and update the session', async () => {\n    const baseUrl = await setup(withoutApi, { profileOptions: { refetch: true }, userInfoPayload: { foo: 'bar' } });\n    const cookieJar = await login(baseUrl);\n\n    const profile = await get(baseUrl, '/api/auth/me', { cookieJar });\n    expect(profile).toMatchObject({ foo: 'bar', nickname: '__test_nickname__', sub: '__test_sub__' });\n    // check that the session is saved\n    userInfo(withoutApi, 'eyJz93a...k4laUWw', {});\n    const profile2 = await get(baseUrl, '/api/auth/me', { cookieJar });\n    expect(profile2).toMatchObject({ foo: 'bar', nickname: '__test_nickname__', sub: '__test_sub__' });\n  });\n\n  test(\"should refetch the user and fail if it can't get an access token\", async () => {\n    const afterCallback: AfterCallback = (_req, _res, session: Session): Session => {\n      session.accessTokenExpiresAt = -60;\n      return session;\n    };\n    const baseUrl = await setup(withoutApi, {\n      profileOptions: { refetch: true },\n      userInfoPayload: { foo: 'bar' },\n      callbackOptions: {\n        afterCallback\n      }\n    });\n    const cookieJar = await login(baseUrl);\n\n    nock(`${withoutApi.issuerBaseURL}`)\n      .post('/oauth/token', `grant_type=refresh_token&refresh_token=GEbRxBN...edjnXbL`)\n      .reply(200, {\n        id_token: makeIdToken({ iss: 'https://acme.auth0.local/' }),\n        token_type: 'Bearer',\n        expires_in: 750,\n        scope: 'read:foo write:foo'\n      });\n    await expect(get(baseUrl, '/api/auth/me', { cookieJar })).rejects.toThrow(\n      'No access token available to refetch the profile'\n    );\n  });\n\n  test('should refetch the user and preserve new tokens', async () => {\n    const afterCallback: AfterCallback = (_req, _res, session: Session): Session => {\n      session.accessTokenExpiresAt = -60;\n      return session;\n    };\n    const baseUrl = await setup(withApi, {\n      profileOptions: { refetch: true },\n      userInfoPayload: { foo: 'bar' },\n      callbackOptions: {\n        afterCallback\n      },\n      userInfoToken: 'new-access-token'\n    });\n    refreshTokenRotationExchange(withApi, 'GEbRxBN...edjnXbL', {}, 'new-access-token', 'new-refresh-token');\n    const cookieJar = await login(baseUrl);\n    const profile = await get(baseUrl, '/api/auth/me', { cookieJar });\n    expect(profile).toMatchObject({ foo: 'bar' });\n    const session = await get(baseUrl, '/api/session', { cookieJar });\n    expect(session.accessToken).toEqual('new-access-token');\n    expect(session.refreshToken).toEqual('new-refresh-token');\n  });\n\n  test('should update the session in the afterRefetch hook', async () => {\n    const baseUrl = await setup(withoutApi, {\n      profileOptions: {\n        refetch: true,\n        afterRefetch(_req, _res, session) {\n          session.user.foo = 'bar';\n          return session;\n        }\n      }\n    });\n    const cookieJar = await login(baseUrl);\n\n    const user = await get(baseUrl, '/api/auth/me', { cookieJar });\n    expect(user.foo).toEqual('bar');\n  });\n\n  test('should throw from the afterRefetch hook', async () => {\n    const baseUrl = await setup(withoutApi, {\n      profileOptions: {\n        refetch: true,\n        afterRefetch() {\n          throw new Error('some validation error');\n        }\n      }\n    });\n    const cookieJar = await login(baseUrl);\n\n    await expect(get(baseUrl, '/api/auth/me', { cookieJar })).rejects.toThrowError('some validation error');\n  });\n\n  test('should escape html in errors', async () => {\n    const baseUrl = await setup(withoutApi);\n\n    const res = await fetch(`${baseUrl}/api/auth/me?error=%3Cscript%3Ealert(%27xss%27)%3C%2Fscript%3E`);\n\n    expect(await res.text()).toEqual('&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;');\n  });\n});\n"], "filenames": ["README.md", "src/handlers/callback.ts", "src/handlers/login.ts", "src/handlers/logout.ts", "src/handlers/profile.ts", "src/utils/errors.ts", "tests/auth0-session/handlers/callback.test.ts", "tests/fixtures/oidc-nocks.ts", "tests/handlers/callback.test.ts", "tests/handlers/login.test.ts", "tests/handlers/logout.test.ts", "tests/handlers/profile.test.ts"], "buggy_code_start_loc": [19, 6, 5, 3, 4, 0, 380, 6, 89, 246, 2, 7], "buggy_code_end_loc": [190, 130, 130, 32, 83, 21, 381, 54, 326, 246, 90, 144], "fixing_code_start_loc": [20, 7, 6, 4, 5, 1, 380, 7, 90, 247, 2, 8], "fixing_code_end_loc": [208, 135, 134, 37, 87, 65, 381, 64, 335, 255, 109, 164], "type": "CWE-79", "message": "The Auth0 Next.js SDK is a library for implementing user authentication in Next.js applications. Versions before and including `1.4.1` are vulnerable to reflected XSS. An attacker can execute arbitrary code by providing an XSS payload in the `error` query parameter which is then processed by the callback handler as an error message. You are affected by this vulnerability if you are using `@auth0/nextjs-auth0` version `1.4.1` or lower **unless** you are using custom error handling that does not return the error message in an HTML response. Upgrade to version `1.4.1` to resolve. The fix adds basic HTML escaping to the error message and it should not impact your users.", "other": {"cve": {"id": "CVE-2021-32702", "sourceIdentifier": "security-advisories@github.com", "published": "2021-06-25T17:15:08.383", "lastModified": "2021-07-01T19:29:18.183", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Auth0 Next.js SDK is a library for implementing user authentication in Next.js applications. Versions before and including `1.4.1` are vulnerable to reflected XSS. An attacker can execute arbitrary code by providing an XSS payload in the `error` query parameter which is then processed by the callback handler as an error message. You are affected by this vulnerability if you are using `@auth0/nextjs-auth0` version `1.4.1` or lower **unless** you are using custom error handling that does not return the error message in an HTML response. Upgrade to version `1.4.1` to resolve. The fix adds basic HTML escaping to the error message and it should not impact your users."}, {"lang": "es", "value": "El SDK de Auth0 Next.js es una biblioteca para implementar la autenticaci\u00f3n de usuarios en las aplicaciones Next.js. Las versiones anteriores a la \"1.4.1\" e incluy\u00e9ndola, son vulnerables a un ataque de tipo XSS reflejado. Un atacante puede ejecutar c\u00f3digo arbitrario al proporcionar una carga \u00fatil de tipo XSS en el par\u00e1metro de consulta \"error\" que luego es procesado por el controlador de devoluci\u00f3n de llamada como un mensaje de error. Est\u00e1 afectado por esta vulnerabilidad si est\u00e1 usando \"@auth0/nextjs-auth0\" versi\u00f3n \"1.4.1\" o inferior **a menos que** est\u00e9 usando un manejo de errores personalizado que no devuelva el mensaje de error en una respuesta HTML. Actualizar a versi\u00f3n \"1.4.1\" para solucionarlo. La correcci\u00f3n a\u00f1ade un escape HTML b\u00e1sico al mensaje de error y no deber\u00eda afectar a sus usuarios"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:auth0:nextjs-auth0:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.4.2", "matchCriteriaId": "F04AAC80-E950-4A31-B658-C7B7825CE71E"}]}]}], "references": [{"url": "https://github.com/auth0/nextjs-auth0/commit/6996e2528ceed98627caa28abafbc09e90163ccf", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/auth0/nextjs-auth0/security/advisories/GHSA-954c-jjx6-cxv7", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.npmjs.com/package/@auth0/nextjs-auth0", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/auth0/nextjs-auth0/commit/6996e2528ceed98627caa28abafbc09e90163ccf"}}