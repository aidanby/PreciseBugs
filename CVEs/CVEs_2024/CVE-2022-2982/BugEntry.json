{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * quickfix.c: functions for quickfix mode, using a file with error messages\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n\nstruct dir_stack_T\n{\n    struct dir_stack_T\t*next;\n    char_u\t\t*dirname;\n};\n\n/*\n * For each error the next struct is allocated and linked in a list.\n */\ntypedef struct qfline_S qfline_T;\nstruct qfline_S\n{\n    qfline_T\t*qf_next;\t// pointer to next error in the list\n    qfline_T\t*qf_prev;\t// pointer to previous error in the list\n    linenr_T\tqf_lnum;\t// line number where the error occurred\n    linenr_T\tqf_end_lnum;\t// line number when the error has range or zero\n    int\t\tqf_fnum;\t// file number for the line\n    int\t\tqf_col;\t\t// column where the error occurred\n    int\t\tqf_end_col;\t// column when the error has range or zero\n    int\t\tqf_nr;\t\t// error number\n    char_u\t*qf_module;\t// module name for this error\n    char_u\t*qf_pattern;\t// search pattern for the error\n    char_u\t*qf_text;\t// description of the error\n    char_u\tqf_viscol;\t// set to TRUE if qf_col and qf_end_col is\n\t\t\t\t// screen column\n    char_u\tqf_cleared;\t// set to TRUE if line has been deleted\n    char_u\tqf_type;\t// type of the error (mostly 'E'); 1 for\n\t\t\t\t// :helpgrep\n    char_u\tqf_valid;\t// valid error message detected\n};\n\n/*\n * There is a stack of error lists.\n */\n#define LISTCOUNT   10\n#define INVALID_QFIDX (-1)\n#define INVALID_QFBUFNR (0)\n\n/*\n * Quickfix list type.\n */\ntypedef enum\n{\n    QFLT_QUICKFIX, // Quickfix list - global list\n    QFLT_LOCATION, // Location list - per window list\n    QFLT_INTERNAL  // Internal - Temporary list used by getqflist()/getloclist()\n} qfltype_T;\n\n/*\n * Quickfix/Location list definition\n * Contains a list of entries (qfline_T). qf_start points to the first entry\n * and qf_last points to the last entry. qf_count contains the list size.\n *\n * Usually the list contains one or more entries. But an empty list can be\n * created using setqflist()/setloclist() with a title and/or user context\n * information and entries can be added later using setqflist()/setloclist().\n */\ntypedef struct qf_list_S\n{\n    int_u\tqf_id;\t\t// Unique identifier for this list\n    qfltype_T\tqfl_type;\n    qfline_T\t*qf_start;\t// pointer to the first error\n    qfline_T\t*qf_last;\t// pointer to the last error\n    qfline_T\t*qf_ptr;\t// pointer to the current error\n    int\t\tqf_count;\t// number of errors (0 means empty list)\n    int\t\tqf_index;\t// current index in the error list\n    int\t\tqf_nonevalid;\t// TRUE if not a single valid entry found\n    char_u\t*qf_title;\t// title derived from the command that created\n\t\t\t\t// the error list or set by setqflist\n    typval_T\t*qf_ctx;\t// context set by setqflist/setloclist\n    callback_T  qf_qftf_cb;\t// 'quickfixtextfunc' callback function\n\n    struct dir_stack_T\t*qf_dir_stack;\n    char_u\t\t*qf_directory;\n    struct dir_stack_T\t*qf_file_stack;\n    char_u\t\t*qf_currfile;\n    int\t\t\tqf_multiline;\n    int\t\t\tqf_multiignore;\n    int\t\t\tqf_multiscan;\n    long\t\tqf_changedtick;\n} qf_list_T;\n\n/*\n * Quickfix/Location list stack definition\n * Contains a list of quickfix/location lists (qf_list_T)\n */\nstruct qf_info_S\n{\n    // Count of references to this list. Used only for location lists.\n    // When a location list window reference this list, qf_refcount\n    // will be 2. Otherwise, qf_refcount will be 1. When qf_refcount\n    // reaches 0, the list is freed.\n    int\t\tqf_refcount;\n    int\t\tqf_listcount;\t    // current number of lists\n    int\t\tqf_curlist;\t    // current error list\n    qf_list_T\tqf_lists[LISTCOUNT];\n    qfltype_T\tqfl_type;\t    // type of list\n    int\t\tqf_bufnr;\t    // quickfix window buffer number\n};\n\nstatic qf_info_T ql_info;\t// global quickfix list\nstatic int_u last_qf_id = 0;\t// Last used quickfix list id\n\n#define FMT_PATTERNS 13\t\t// maximum number of % recognized\n\n/*\n * Structure used to hold the info of one part of 'errorformat'\n */\ntypedef struct efm_S efm_T;\nstruct efm_S\n{\n    regprog_T\t    *prog;\t// pre-formatted part of 'errorformat'\n    efm_T\t    *next;\t// pointer to next (NULL if last)\n    char_u\t    addr[FMT_PATTERNS]; // indices of used % patterns\n    char_u\t    prefix;\t// prefix of this format line:\n\t\t\t\t//   'D' enter directory\n\t\t\t\t//   'X' leave directory\n\t\t\t\t//   'A' start of multi-line message\n\t\t\t\t//   'E' error message\n\t\t\t\t//   'W' warning message\n\t\t\t\t//   'I' informational message\n\t\t\t\t//   'N' note message\n\t\t\t\t//   'C' continuation line\n\t\t\t\t//   'Z' end of multi-line message\n\t\t\t\t//   'G' general, unspecific message\n\t\t\t\t//   'P' push file (partial) message\n\t\t\t\t//   'Q' pop/quit file (partial) message\n\t\t\t\t//   'O' overread (partial) message\n    char_u\t    flags;\t// additional flags given in prefix\n\t\t\t\t//   '-' do not include this line\n\t\t\t\t//   '+' include whole line in message\n    int\t\t    conthere;\t// %> used\n};\n\n// List of location lists to be deleted.\n// Used to delay the deletion of locations lists by autocmds.\ntypedef struct qf_delq_S\n{\n    struct qf_delq_S\t*next;\n    qf_info_T\t\t*qi;\n} qf_delq_T;\nstatic qf_delq_T *qf_delq_head = NULL;\n\n// Counter to prevent autocmds from freeing up location lists when they are\n// still being used.\nstatic int\tquickfix_busy = 0;\n\nstatic efm_T\t*fmt_start = NULL; // cached across qf_parse_line() calls\n\n// callback function for 'quickfixtextfunc'\nstatic callback_T qftf_cb;\n\nstatic void\tqf_new_list(qf_info_T *qi, char_u *qf_title);\nstatic int\tqf_add_entry(qf_list_T *qfl, char_u *dir, char_u *fname, char_u *module, int bufnum, char_u *mesg, long lnum, long end_lnum, int col, int end_col, int vis_col, char_u *pattern, int nr, int type, int valid);\nstatic void\tqf_free(qf_list_T *qfl);\nstatic char_u\t*qf_types(int, int);\nstatic int\tqf_get_fnum(qf_list_T *qfl, char_u *, char_u *);\nstatic char_u\t*qf_push_dir(char_u *, struct dir_stack_T **, int is_file_stack);\nstatic char_u\t*qf_pop_dir(struct dir_stack_T **);\nstatic char_u\t*qf_guess_filepath(qf_list_T *qfl, char_u *);\nstatic void\tqf_jump_newwin(qf_info_T *qi, int dir, int errornr, int forceit, int newwin);\nstatic void\tqf_fmt_text(char_u *text, char_u *buf, int bufsize);\nstatic void\tqf_range_text(qfline_T *qfp, char_u *buf, int bufsize);\nstatic int\tqf_win_pos_update(qf_info_T *qi, int old_qf_index);\nstatic win_T\t*qf_find_win(qf_info_T *qi);\nstatic buf_T\t*qf_find_buf(qf_info_T *qi);\nstatic void\tqf_update_buffer(qf_info_T *qi, qfline_T *old_last);\nstatic void\tqf_fill_buffer(qf_list_T *qfl, buf_T *buf, qfline_T *old_last, int qf_winid);\nstatic buf_T\t*load_dummy_buffer(char_u *fname, char_u *dirname_start, char_u *resulting_dir);\nstatic void\twipe_dummy_buffer(buf_T *buf, char_u *dirname_start);\nstatic void\tunload_dummy_buffer(buf_T *buf, char_u *dirname_start);\nstatic qf_info_T *ll_get_or_alloc_list(win_T *);\n\n// Quickfix window check helper macro\n#define IS_QF_WINDOW(wp) (bt_quickfix((wp)->w_buffer) && (wp)->w_llist_ref == NULL)\n// Location list window check helper macro\n#define IS_LL_WINDOW(wp) (bt_quickfix((wp)->w_buffer) && (wp)->w_llist_ref != NULL)\n\n// Quickfix and location list stack check helper macros\n#define IS_QF_STACK(qi)\t\t((qi)->qfl_type == QFLT_QUICKFIX)\n#define IS_LL_STACK(qi)\t\t((qi)->qfl_type == QFLT_LOCATION)\n#define IS_QF_LIST(qfl)\t\t((qfl)->qfl_type == QFLT_QUICKFIX)\n#define IS_LL_LIST(qfl)\t\t((qfl)->qfl_type == QFLT_LOCATION)\n\n/*\n * Return location list for window 'wp'\n * For location list window, return the referenced location list\n */\n#define GET_LOC_LIST(wp) (IS_LL_WINDOW(wp) ? (wp)->w_llist_ref : (wp)->w_llist)\n\n// Macro to loop through all the items in a quickfix list\n// Quickfix item index starts from 1, so i below starts at 1\n#define FOR_ALL_QFL_ITEMS(qfl, qfp, i) \\\n\t\t    for ((i) = 1, (qfp) = (qfl)->qf_start; \\\n\t\t\t    !got_int && (i) <= (qfl)->qf_count && (qfp) != NULL; \\\n\t\t\t    ++(i), (qfp) = (qfp)->qf_next)\n\n/*\n * Looking up a buffer can be slow if there are many.  Remember the last one\n * to make this a lot faster if there are multiple matches in the same file.\n */\nstatic char_u   *qf_last_bufname = NULL;\nstatic bufref_T  qf_last_bufref = {NULL, 0, 0};\n\n/*\n * Maximum number of bytes allowed per line while reading a errorfile.\n */\n#define LINE_MAXLEN 4096\n\n/*\n * Patterns used.  Keep in sync with qf_parse_fmt[].\n */\nstatic struct fmtpattern\n{\n    char_u\tconvchar;\n    char\t*pattern;\n} fmt_pat[FMT_PATTERNS] =\n    {\n\t{'f', \".\\\\+\"},\t    // only used when at end\n\t{'n', \"\\\\d\\\\+\"},\t// 1\n\t{'l', \"\\\\d\\\\+\"},\t// 2\n\t{'e', \"\\\\d\\\\+\"},\t// 3\n\t{'c', \"\\\\d\\\\+\"},\t// 4\n\t{'k', \"\\\\d\\\\+\"},\t// 5\n\t{'t', \".\"},\t\t// 6\n#define FMT_PATTERN_M 7\n\t{'m', \".\\\\+\"},\t\t// 7\n#define FMT_PATTERN_R 8\n\t{'r', \".*\"},\t\t// 8\n\t{'p', \"[- \t.]*\"},\t// 9\n\t{'v', \"\\\\d\\\\+\"},\t// 10\n\t{'s', \".\\\\+\"},\t\t// 11\n\t{'o', \".\\\\+\"}\t\t// 12\n    };\n\n/*\n * Convert an errorformat pattern to a regular expression pattern.\n * See fmt_pat definition above for the list of supported patterns.  The\n * pattern specifier is supplied in \"efmpat\".  The converted pattern is stored\n * in \"regpat\".  Returns a pointer to the location after the pattern.\n */\n    static char_u *\nefmpat_to_regpat(\n\tchar_u\t*efmpat,\n\tchar_u\t*regpat,\n\tefm_T\t*efminfo,\n\tint\tidx,\n\tint\tround)\n{\n    char_u\t*srcptr;\n\n    if (efminfo->addr[idx])\n    {\n\t// Each errorformat pattern can occur only once\n\tsemsg(_(e_too_many_chr_in_format_string), *efmpat);\n\treturn NULL;\n    }\n    if ((idx && idx < FMT_PATTERN_R\n\t\t&& vim_strchr((char_u *)\"DXOPQ\", efminfo->prefix) != NULL)\n\t    || (idx == FMT_PATTERN_R\n\t\t&& vim_strchr((char_u *)\"OPQ\", efminfo->prefix) == NULL))\n    {\n\tsemsg(_(e_unexpected_chr_in_format_str), *efmpat);\n\treturn NULL;\n    }\n    efminfo->addr[idx] = (char_u)++round;\n    *regpat++ = '\\\\';\n    *regpat++ = '(';\n#ifdef BACKSLASH_IN_FILENAME\n    if (*efmpat == 'f')\n    {\n\t// Also match \"c:\" in the file name, even when\n\t// checking for a colon next: \"%f:\".\n\t// \"\\%(\\a:\\)\\=\"\n\tSTRCPY(regpat, \"\\\\%(\\\\a:\\\\)\\\\=\");\n\tregpat += 10;\n    }\n#endif\n    if (*efmpat == 'f' && efmpat[1] != NUL)\n    {\n\tif (efmpat[1] != '\\\\' && efmpat[1] != '%')\n\t{\n\t    // A file name may contain spaces, but this isn't\n\t    // in \"\\f\".  For \"%f:%l:%m\" there may be a \":\" in\n\t    // the file name.  Use \".\\{-1,}x\" instead (x is\n\t    // the next character), the requirement that :999:\n\t    // follows should work.\n\t    STRCPY(regpat, \".\\\\{-1,}\");\n\t    regpat += 7;\n\t}\n\telse\n\t{\n\t    // File name followed by '\\\\' or '%': include as\n\t    // many file name chars as possible.\n\t    STRCPY(regpat, \"\\\\f\\\\+\");\n\t    regpat += 4;\n\t}\n    }\n    else\n    {\n\tsrcptr = (char_u *)fmt_pat[idx].pattern;\n\twhile ((*regpat = *srcptr++) != NUL)\n\t    ++regpat;\n    }\n    *regpat++ = '\\\\';\n    *regpat++ = ')';\n\n    return regpat;\n}\n\n/*\n * Convert a scanf like format in 'errorformat' to a regular expression.\n * Returns a pointer to the location after the pattern.\n */\n    static char_u *\nscanf_fmt_to_regpat(\n\tchar_u\t**pefmp,\n\tchar_u\t*efm,\n\tint\tlen,\n\tchar_u\t*regpat)\n{\n    char_u\t*efmp = *pefmp;\n\n    if (*efmp == '[' || *efmp == '\\\\')\n    {\n\tif ((*regpat++ = *efmp) == '[')\t// %*[^a-z0-9] etc.\n\t{\n\t    if (efmp[1] == '^')\n\t\t*regpat++ = *++efmp;\n\t    if (efmp < efm + len)\n\t    {\n\t\t*regpat++ = *++efmp;\t    // could be ']'\n\t\twhile (efmp < efm + len\n\t\t\t&& (*regpat++ = *++efmp) != ']')\n\t\t    // skip ;\n\t\tif (efmp == efm + len)\n\t\t{\n\t\t    emsg(_(e_missing_rsb_in_format_string));\n\t\t    return NULL;\n\t\t}\n\t    }\n\t}\n\telse if (efmp < efm + len)\t// %*\\D, %*\\s etc.\n\t    *regpat++ = *++efmp;\n\t*regpat++ = '\\\\';\n\t*regpat++ = '+';\n    }\n    else\n    {\n\t// TODO: scanf()-like: %*ud, %*3c, %*f, ... ?\n\tsemsg(_(e_unsupported_chr_in_format_string), *efmp);\n\treturn NULL;\n    }\n\n    *pefmp = efmp;\n\n    return regpat;\n}\n\n/*\n * Analyze/parse an errorformat prefix.\n */\n    static char_u *\nefm_analyze_prefix(char_u *efmp, efm_T *efminfo)\n{\n    if (vim_strchr((char_u *)\"+-\", *efmp) != NULL)\n\tefminfo->flags = *efmp++;\n    if (vim_strchr((char_u *)\"DXAEWINCZGOPQ\", *efmp) != NULL)\n\tefminfo->prefix = *efmp;\n    else\n    {\n\tsemsg(_(e_invalid_chr_in_format_string_prefix), *efmp);\n\treturn NULL;\n    }\n\n    return efmp;\n}\n\n/*\n * Converts a 'errorformat' string part in 'efm' to a regular expression\n * pattern.  The resulting regex pattern is returned in \"regpat\". Additional\n * information about the 'erroformat' pattern is returned in \"fmt_ptr\".\n * Returns OK or FAIL.\n */\n    static int\nefm_to_regpat(\n\tchar_u\t*efm,\n\tint\tlen,\n\tefm_T\t*fmt_ptr,\n\tchar_u\t*regpat)\n{\n    char_u\t*ptr;\n    char_u\t*efmp;\n    int\t\tround;\n    int\t\tidx = 0;\n\n    // Build a regexp pattern for a 'errorformat' option part\n    ptr = regpat;\n    *ptr++ = '^';\n    round = 0;\n    for (efmp = efm; efmp < efm + len; ++efmp)\n    {\n\tif (*efmp == '%')\n\t{\n\t    ++efmp;\n\t    for (idx = 0; idx < FMT_PATTERNS; ++idx)\n\t\tif (fmt_pat[idx].convchar == *efmp)\n\t\t    break;\n\t    if (idx < FMT_PATTERNS)\n\t    {\n\t\tptr = efmpat_to_regpat(efmp, ptr, fmt_ptr, idx, round);\n\t\tif (ptr == NULL)\n\t\t    return FAIL;\n\t\tround++;\n\t    }\n\t    else if (*efmp == '*')\n\t    {\n\t\t++efmp;\n\t\tptr = scanf_fmt_to_regpat(&efmp, efm, len, ptr);\n\t\tif (ptr == NULL)\n\t\t    return FAIL;\n\t    }\n\t    else if (vim_strchr((char_u *)\"%\\\\.^$~[\", *efmp) != NULL)\n\t\t*ptr++ = *efmp;\t\t// regexp magic characters\n\t    else if (*efmp == '#')\n\t\t*ptr++ = '*';\n\t    else if (*efmp == '>')\n\t\tfmt_ptr->conthere = TRUE;\n\t    else if (efmp == efm + 1)\t\t// analyse prefix\n\t    {\n\t\t// prefix is allowed only at the beginning of the errorformat\n\t\t// option part\n\t\tefmp = efm_analyze_prefix(efmp, fmt_ptr);\n\t\tif (efmp == NULL)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\tsemsg(_(e_invalid_chr_in_format_string), *efmp);\n\t\treturn FAIL;\n\t    }\n\t}\n\telse\t\t\t// copy normal character\n\t{\n\t    if (*efmp == '\\\\' && efmp + 1 < efm + len)\n\t\t++efmp;\n\t    else if (vim_strchr((char_u *)\".*^$~[\", *efmp) != NULL)\n\t\t*ptr++ = '\\\\';\t// escape regexp atoms\n\t    if (*efmp)\n\t\t*ptr++ = *efmp;\n\t}\n    }\n    *ptr++ = '$';\n    *ptr = NUL;\n\n    return OK;\n}\n\n/*\n * Free the 'errorformat' information list\n */\n    static void\nfree_efm_list(efm_T **efm_first)\n{\n    efm_T *efm_ptr;\n\n    for (efm_ptr = *efm_first; efm_ptr != NULL; efm_ptr = *efm_first)\n    {\n\t*efm_first = efm_ptr->next;\n\tvim_regfree(efm_ptr->prog);\n\tvim_free(efm_ptr);\n    }\n    fmt_start = NULL;\n}\n\n/*\n * Compute the size of the buffer used to convert a 'errorformat' pattern into\n * a regular expression pattern.\n */\n    static int\nefm_regpat_bufsz(char_u *efm)\n{\n    int sz;\n    int i;\n\n    sz = (FMT_PATTERNS * 3) + ((int)STRLEN(efm) << 2);\n    for (i = FMT_PATTERNS; i > 0; )\n\tsz += (int)STRLEN(fmt_pat[--i].pattern);\n#ifdef BACKSLASH_IN_FILENAME\n    sz += 12; // \"%f\" can become twelve chars longer (see efm_to_regpat)\n#else\n    sz += 2; // \"%f\" can become two chars longer\n#endif\n\n    return sz;\n}\n\n/*\n * Return the length of a 'errorformat' option part (separated by \",\").\n */\n    static int\nefm_option_part_len(char_u *efm)\n{\n    int len;\n\n    for (len = 0; efm[len] != NUL && efm[len] != ','; ++len)\n\tif (efm[len] == '\\\\' && efm[len + 1] != NUL)\n\t    ++len;\n\n    return len;\n}\n\n/*\n * Parse the 'errorformat' option. Multiple parts in the 'errorformat' option\n * are parsed and converted to regular expressions. Returns information about\n * the parsed 'errorformat' option.\n */\n    static efm_T *\nparse_efm_option(char_u *efm)\n{\n    efm_T\t*fmt_ptr = NULL;\n    efm_T\t*fmt_first = NULL;\n    efm_T\t*fmt_last = NULL;\n    char_u\t*fmtstr = NULL;\n    int\t\tlen;\n    int\t\tsz;\n\n    // Each part of the format string is copied and modified from errorformat\n    // to regex prog.  Only a few % characters are allowed.\n\n    // Get some space to modify the format string into.\n    sz = efm_regpat_bufsz(efm);\n    if ((fmtstr = alloc_id(sz, aid_qf_efm_fmtstr)) == NULL)\n\tgoto parse_efm_error;\n\n    while (efm[0] != NUL)\n    {\n\t// Allocate a new eformat structure and put it at the end of the list\n\tfmt_ptr = ALLOC_CLEAR_ONE_ID(efm_T, aid_qf_efm_fmtpart);\n\tif (fmt_ptr == NULL)\n\t    goto parse_efm_error;\n\tif (fmt_first == NULL)\t    // first one\n\t    fmt_first = fmt_ptr;\n\telse\n\t    fmt_last->next = fmt_ptr;\n\tfmt_last = fmt_ptr;\n\n\t// Isolate one part in the 'errorformat' option\n\tlen = efm_option_part_len(efm);\n\n\tif (efm_to_regpat(efm, len, fmt_ptr, fmtstr) == FAIL)\n\t    goto parse_efm_error;\n\tif ((fmt_ptr->prog = vim_regcomp(fmtstr, RE_MAGIC + RE_STRING)) == NULL)\n\t    goto parse_efm_error;\n\t// Advance to next part\n\tefm = skip_to_option_part(efm + len);\t// skip comma and spaces\n    }\n\n    if (fmt_first == NULL)\t// nothing found\n\temsg(_(e_errorformat_contains_no_pattern));\n\n    goto parse_efm_end;\n\nparse_efm_error:\n    free_efm_list(&fmt_first);\n\nparse_efm_end:\n    vim_free(fmtstr);\n\n    return fmt_first;\n}\n\nenum {\n    QF_FAIL = 0,\n    QF_OK = 1,\n    QF_END_OF_INPUT = 2,\n    QF_NOMEM = 3,\n    QF_IGNORE_LINE = 4,\n    QF_MULTISCAN = 5,\n};\n\n/*\n * State information used to parse lines and add entries to a quickfix/location\n * list.\n */\ntypedef struct {\n    char_u\t*linebuf;\n    int\t\tlinelen;\n    char_u\t*growbuf;\n    int\t\tgrowbufsiz;\n    FILE\t*fd;\n    typval_T\t*tv;\n    char_u\t*p_str;\n    listitem_T\t*p_li;\n    buf_T\t*buf;\n    linenr_T\tbuflnum;\n    linenr_T\tlnumlast;\n    vimconv_T\tvc;\n} qfstate_T;\n\n/*\n * Allocate more memory for the line buffer used for parsing lines.\n */\n    static char_u *\nqf_grow_linebuf(qfstate_T *state, int newsz)\n{\n    char_u\t*p;\n\n    // If the line exceeds LINE_MAXLEN exclude the last\n    // byte since it's not a NL character.\n    state->linelen = newsz > LINE_MAXLEN ? LINE_MAXLEN - 1 : newsz;\n    if (state->growbuf == NULL)\n    {\n\tstate->growbuf = alloc_id(state->linelen + 1, aid_qf_linebuf);\n\tif (state->growbuf == NULL)\n\t    return NULL;\n\tstate->growbufsiz = state->linelen;\n    }\n    else if (state->linelen > state->growbufsiz)\n    {\n\tif ((p = vim_realloc(state->growbuf, state->linelen + 1)) == NULL)\n\t    return NULL;\n\tstate->growbuf = p;\n\tstate->growbufsiz = state->linelen;\n    }\n    return state->growbuf;\n}\n\n/*\n * Get the next string (separated by newline) from state->p_str.\n */\n    static int\nqf_get_next_str_line(qfstate_T *state)\n{\n    // Get the next line from the supplied string\n    char_u\t*p_str = state->p_str;\n    char_u\t*p;\n    int\t\tlen;\n\n    if (*p_str == NUL) // Reached the end of the string\n\treturn QF_END_OF_INPUT;\n\n    p = vim_strchr(p_str, '\\n');\n    if (p != NULL)\n\tlen = (int)(p - p_str) + 1;\n    else\n\tlen = (int)STRLEN(p_str);\n\n    if (len > IOSIZE - 2)\n    {\n\tstate->linebuf = qf_grow_linebuf(state, len);\n\tif (state->linebuf == NULL)\n\t    return QF_NOMEM;\n    }\n    else\n    {\n\tstate->linebuf = IObuff;\n\tstate->linelen = len;\n    }\n    vim_strncpy(state->linebuf, p_str, state->linelen);\n\n    // Increment using len in order to discard the rest of the\n    // line if it exceeds LINE_MAXLEN.\n    p_str += len;\n    state->p_str = p_str;\n\n    return QF_OK;\n}\n\n/*\n * Get the next string from the List item state->p_li.\n */\n    static int\nqf_get_next_list_line(qfstate_T *state)\n{\n    listitem_T\t*p_li = state->p_li;\n    int\t\tlen;\n\n    while (p_li != NULL\n\t    && (p_li->li_tv.v_type != VAR_STRING\n\t\t|| p_li->li_tv.vval.v_string == NULL))\n\tp_li = p_li->li_next;\t// Skip non-string items\n\n    if (p_li == NULL)\t\t// End of the list\n    {\n\tstate->p_li = NULL;\n\treturn QF_END_OF_INPUT;\n    }\n\n    len = (int)STRLEN(p_li->li_tv.vval.v_string);\n    if (len > IOSIZE - 2)\n    {\n\tstate->linebuf = qf_grow_linebuf(state, len);\n\tif (state->linebuf == NULL)\n\t    return QF_NOMEM;\n    }\n    else\n    {\n\tstate->linebuf = IObuff;\n\tstate->linelen = len;\n    }\n\n    vim_strncpy(state->linebuf, p_li->li_tv.vval.v_string, state->linelen);\n\n    state->p_li = p_li->li_next;\t// next item\n    return QF_OK;\n}\n\n/*\n * Get the next string from state->buf.\n */\n    static int\nqf_get_next_buf_line(qfstate_T *state)\n{\n    char_u\t*p_buf = NULL;\n    int\t\tlen;\n\n    // Get the next line from the supplied buffer\n    if (state->buflnum > state->lnumlast)\n\treturn QF_END_OF_INPUT;\n\n    p_buf = ml_get_buf(state->buf, state->buflnum, FALSE);\n    state->buflnum += 1;\n\n    len = (int)STRLEN(p_buf);\n    if (len > IOSIZE - 2)\n    {\n\tstate->linebuf = qf_grow_linebuf(state, len);\n\tif (state->linebuf == NULL)\n\t    return QF_NOMEM;\n    }\n    else\n    {\n\tstate->linebuf = IObuff;\n\tstate->linelen = len;\n    }\n    vim_strncpy(state->linebuf, p_buf, state->linelen);\n\n    return QF_OK;\n}\n\n/*\n * Get the next string from file state->fd.\n */\n    static int\nqf_get_next_file_line(qfstate_T *state)\n{\n    int\t    discard;\n    int\t    growbuflen;\n\n    if (fgets((char *)IObuff, IOSIZE, state->fd) == NULL)\n\treturn QF_END_OF_INPUT;\n\n    discard = FALSE;\n    state->linelen = (int)STRLEN(IObuff);\n    if (state->linelen == IOSIZE - 1 && !(IObuff[state->linelen - 1] == '\\n'))\n    {\n\t// The current line exceeds IObuff, continue reading using\n\t// growbuf until EOL or LINE_MAXLEN bytes is read.\n\tif (state->growbuf == NULL)\n\t{\n\t    state->growbufsiz = 2 * (IOSIZE - 1);\n\t    state->growbuf = alloc_id(state->growbufsiz, aid_qf_linebuf);\n\t    if (state->growbuf == NULL)\n\t\treturn QF_NOMEM;\n\t}\n\n\t// Copy the read part of the line, excluding null-terminator\n\tmemcpy(state->growbuf, IObuff, IOSIZE - 1);\n\tgrowbuflen = state->linelen;\n\n\tfor (;;)\n\t{\n\t    char_u\t*p;\n\n\t    if (fgets((char *)state->growbuf + growbuflen,\n\t\t\tstate->growbufsiz - growbuflen, state->fd) == NULL)\n\t\tbreak;\n\t    state->linelen = (int)STRLEN(state->growbuf + growbuflen);\n\t    growbuflen += state->linelen;\n\t    if ((state->growbuf)[growbuflen - 1] == '\\n')\n\t\tbreak;\n\t    if (state->growbufsiz == LINE_MAXLEN)\n\t    {\n\t\tdiscard = TRUE;\n\t\tbreak;\n\t    }\n\n\t    state->growbufsiz = 2 * state->growbufsiz < LINE_MAXLEN\n\t\t? 2 * state->growbufsiz : LINE_MAXLEN;\n\t    if ((p = vim_realloc(state->growbuf, state->growbufsiz)) == NULL)\n\t\treturn QF_NOMEM;\n\t    state->growbuf = p;\n\t}\n\n\twhile (discard)\n\t{\n\t    // The current line is longer than LINE_MAXLEN, continue\n\t    // reading but discard everything until EOL or EOF is\n\t    // reached.\n\t    if (fgets((char *)IObuff, IOSIZE, state->fd) == NULL\n\t\t    || (int)STRLEN(IObuff) < IOSIZE - 1\n\t\t    || IObuff[IOSIZE - 2] == '\\n')\n\t\tbreak;\n\t}\n\n\tstate->linebuf = state->growbuf;\n\tstate->linelen = growbuflen;\n    }\n    else\n\tstate->linebuf = IObuff;\n\n    // Convert a line if it contains a non-ASCII character.\n    if (state->vc.vc_type != CONV_NONE && has_non_ascii(state->linebuf))\n    {\n\tchar_u\t*line;\n\n\tline = string_convert(&state->vc, state->linebuf, &state->linelen);\n\tif (line != NULL)\n\t{\n\t    if (state->linelen < IOSIZE)\n\t    {\n\t\tSTRCPY(state->linebuf, line);\n\t\tvim_free(line);\n\t    }\n\t    else\n\t    {\n\t\tvim_free(state->growbuf);\n\t\tstate->linebuf = state->growbuf = line;\n\t\tstate->growbufsiz = state->linelen < LINE_MAXLEN\n\t\t\t\t\t\t? state->linelen : LINE_MAXLEN;\n\t    }\n\t}\n    }\n\n    return QF_OK;\n}\n\n/*\n * Get the next string from a file/buffer/list/string.\n */\n    static int\nqf_get_nextline(qfstate_T *state)\n{\n    int status = QF_FAIL;\n\n    if (state->fd == NULL)\n    {\n\tif (state->tv != NULL)\n\t{\n\t    if (state->tv->v_type == VAR_STRING)\n\t\t// Get the next line from the supplied string\n\t\tstatus = qf_get_next_str_line(state);\n\t    else if (state->tv->v_type == VAR_LIST)\n\t\t// Get the next line from the supplied list\n\t\tstatus = qf_get_next_list_line(state);\n\t}\n\telse\n\t    // Get the next line from the supplied buffer\n\t    status = qf_get_next_buf_line(state);\n    }\n    else\n\t// Get the next line from the supplied file\n\tstatus = qf_get_next_file_line(state);\n\n    if (status != QF_OK)\n\treturn status;\n\n    // remove newline/CR from the line\n    if (state->linelen > 0 && state->linebuf[state->linelen - 1] == '\\n')\n    {\n\tstate->linebuf[state->linelen - 1] = NUL;\n#ifdef USE_CRNL\n\tif (state->linelen > 1 && state->linebuf[state->linelen - 2] == '\\r')\n\t    state->linebuf[state->linelen - 2] = NUL;\n#endif\n    }\n\n    remove_bom(state->linebuf);\n\n    return QF_OK;\n}\n\ntypedef struct {\n    char_u\t*namebuf;\n    char_u\t*module;\n    char_u\t*errmsg;\n    int\t\terrmsglen;\n    long\tlnum;\n    long\tend_lnum;\n    int\t\tcol;\n    int\t\tend_col;\n    char_u\tuse_viscol;\n    char_u\t*pattern;\n    int\t\tenr;\n    int\t\ttype;\n    int\t\tvalid;\n} qffields_T;\n\n/*\n * Parse the match for filename ('%f') pattern in regmatch.\n * Return the matched value in \"fields->namebuf\".\n */\n    static int\nqf_parse_fmt_f(regmatch_T *rmp, int midx, qffields_T *fields, int prefix)\n{\n    int c;\n\n    if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL)\n\treturn QF_FAIL;\n\n    // Expand ~/file and $HOME/file to full path.\n    c = *rmp->endp[midx];\n    *rmp->endp[midx] = NUL;\n    expand_env(rmp->startp[midx], fields->namebuf, CMDBUFFSIZE);\n    *rmp->endp[midx] = c;\n\n    // For separate filename patterns (%O, %P and %Q), the specified file\n    // should exist.\n    if (vim_strchr((char_u *)\"OPQ\", prefix) != NULL\n\t    && mch_getperm(fields->namebuf) == -1)\n\treturn QF_FAIL;\n\n    return QF_OK;\n}\n\n/*\n * Parse the match for error number ('%n') pattern in regmatch.\n * Return the matched value in \"fields->enr\".\n */\n    static int\nqf_parse_fmt_n(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->enr = (int)atol((char *)rmp->startp[midx]);\n    return QF_OK;\n}\n\n/*\n * Parse the match for line number ('%l') pattern in regmatch.\n * Return the matched value in \"fields->lnum\".\n */\n    static int\nqf_parse_fmt_l(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->lnum = atol((char *)rmp->startp[midx]);\n    return QF_OK;\n}\n\n/*\n * Parse the match for end line number ('%e') pattern in regmatch.\n * Return the matched value in \"fields->end_lnum\".\n */\n    static int\nqf_parse_fmt_e(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->end_lnum = atol((char *)rmp->startp[midx]);\n    return QF_OK;\n}\n\n/*\n * Parse the match for column number ('%c') pattern in regmatch.\n * Return the matched value in \"fields->col\".\n */\n    static int\nqf_parse_fmt_c(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->col = (int)atol((char *)rmp->startp[midx]);\n    return QF_OK;\n}\n\n/*\n * Parse the match for end column number ('%k') pattern in regmatch.\n * Return the matched value in \"fields->end_col\".\n */\n    static int\nqf_parse_fmt_k(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->end_col = (int)atol((char *)rmp->startp[midx]);\n    return QF_OK;\n}\n\n/*\n * Parse the match for error type ('%t') pattern in regmatch.\n * Return the matched value in \"fields->type\".\n */\n    static int\nqf_parse_fmt_t(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->type = *rmp->startp[midx];\n    return QF_OK;\n}\n\n/*\n * Copy a non-error line into the error string.  Return the matched line in\n * \"fields->errmsg\".\n */\n    static int\ncopy_nonerror_line(char_u *linebuf, int linelen, qffields_T *fields)\n{\n    char_u\t*p;\n\n    if (linelen >= fields->errmsglen)\n    {\n\t// linelen + null terminator\n\tif ((p = vim_realloc(fields->errmsg, linelen + 1)) == NULL)\n\t    return QF_NOMEM;\n\tfields->errmsg = p;\n\tfields->errmsglen = linelen + 1;\n    }\n    // copy whole line to error message\n    vim_strncpy(fields->errmsg, linebuf, linelen);\n\n    return QF_OK;\n}\n\n/*\n * Parse the match for error message ('%m') pattern in regmatch.\n * Return the matched value in \"fields->errmsg\".\n */\n    static int\nqf_parse_fmt_m(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    char_u\t*p;\n    int\t\tlen;\n\n    if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL)\n\treturn QF_FAIL;\n    len = (int)(rmp->endp[midx] - rmp->startp[midx]);\n    if (len >= fields->errmsglen)\n    {\n\t// len + null terminator\n\tif ((p = vim_realloc(fields->errmsg, len + 1)) == NULL)\n\t    return QF_NOMEM;\n\tfields->errmsg = p;\n\tfields->errmsglen = len + 1;\n    }\n    vim_strncpy(fields->errmsg, rmp->startp[midx], len);\n    return QF_OK;\n}\n\n/*\n * Parse the match for rest of a single-line file message ('%r') pattern.\n * Return the matched value in \"tail\".\n */\n    static int\nqf_parse_fmt_r(regmatch_T *rmp, int midx, char_u **tail)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    *tail = rmp->startp[midx];\n    return QF_OK;\n}\n\n/*\n * Parse the match for the pointer line ('%p') pattern in regmatch.\n * Return the matched value in \"fields->col\".\n */\n    static int\nqf_parse_fmt_p(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    char_u\t*match_ptr;\n\n    if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->col = 0;\n    for (match_ptr = rmp->startp[midx]; match_ptr != rmp->endp[midx];\n\t\t\t\t\t\t\t\t++match_ptr)\n    {\n\t++fields->col;\n\tif (*match_ptr == TAB)\n\t{\n\t    fields->col += 7;\n\t    fields->col -= fields->col % 8;\n\t}\n    }\n    ++fields->col;\n    fields->use_viscol = TRUE;\n    return QF_OK;\n}\n\n/*\n * Parse the match for the virtual column number ('%v') pattern in regmatch.\n * Return the matched value in \"fields->col\".\n */\n    static int\nqf_parse_fmt_v(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->col = (int)atol((char *)rmp->startp[midx]);\n    fields->use_viscol = TRUE;\n    return QF_OK;\n}\n\n/*\n * Parse the match for the search text ('%s') pattern in regmatch.\n * Return the matched value in \"fields->pattern\".\n */\n    static int\nqf_parse_fmt_s(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    int\t\tlen;\n\n    if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL)\n\treturn QF_FAIL;\n    len = (int)(rmp->endp[midx] - rmp->startp[midx]);\n    if (len > CMDBUFFSIZE - 5)\n\tlen = CMDBUFFSIZE - 5;\n    STRCPY(fields->pattern, \"^\\\\V\");\n    STRNCAT(fields->pattern, rmp->startp[midx], len);\n    fields->pattern[len + 3] = '\\\\';\n    fields->pattern[len + 4] = '$';\n    fields->pattern[len + 5] = NUL;\n    return QF_OK;\n}\n\n/*\n * Parse the match for the module ('%o') pattern in regmatch.\n * Return the matched value in \"fields->module\".\n */\n    static int\nqf_parse_fmt_o(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    int\t\tlen;\n\n    if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL)\n\treturn QF_FAIL;\n    len = (int)(rmp->endp[midx] - rmp->startp[midx]);\n    if (len > CMDBUFFSIZE)\n\tlen = CMDBUFFSIZE;\n    STRNCAT(fields->module, rmp->startp[midx], len);\n    return QF_OK;\n}\n\n/*\n * 'errorformat' format pattern parser functions.\n * The '%f' and '%r' formats are parsed differently from other formats.\n * See qf_parse_match() for details.\n * Keep in sync with fmt_pat[].\n */\nstatic int (*qf_parse_fmt[FMT_PATTERNS])(regmatch_T *, int, qffields_T *) =\n{\n    NULL, // %f\n    qf_parse_fmt_n,\n    qf_parse_fmt_l,\n    qf_parse_fmt_e,\n    qf_parse_fmt_c,\n    qf_parse_fmt_k,\n    qf_parse_fmt_t,\n    qf_parse_fmt_m,\n    NULL, // %r\n    qf_parse_fmt_p,\n    qf_parse_fmt_v,\n    qf_parse_fmt_s,\n    qf_parse_fmt_o\n};\n\n/*\n * Parse the error format pattern matches in \"regmatch\" and set the values in\n * \"fields\".  fmt_ptr contains the 'efm' format specifiers/prefixes that have a\n * match.  Returns QF_OK if all the matches are successfully parsed. On\n * failure, returns QF_FAIL or QF_NOMEM.\n */\n    static int\nqf_parse_match(\n\tchar_u\t\t*linebuf,\n\tint\t\tlinelen,\n\tefm_T\t\t*fmt_ptr,\n\tregmatch_T\t*regmatch,\n\tqffields_T\t*fields,\n\tint\t\tqf_multiline,\n\tint\t\tqf_multiscan,\n\tchar_u\t\t**tail)\n{\n    int\t\tidx = fmt_ptr->prefix;\n    int\t\ti;\n    int\t\tmidx;\n    int\t\tstatus;\n\n    if ((idx == 'C' || idx == 'Z') && !qf_multiline)\n\treturn QF_FAIL;\n    if (vim_strchr((char_u *)\"EWIN\", idx) != NULL)\n\tfields->type = idx;\n    else\n\tfields->type = 0;\n\n    // Extract error message data from matched line.\n    // We check for an actual submatch, because \"\\[\" and \"\\]\" in\n    // the 'errorformat' may cause the wrong submatch to be used.\n    for (i = 0; i < FMT_PATTERNS; i++)\n    {\n\tstatus = QF_OK;\n\tmidx = (int)fmt_ptr->addr[i];\n\tif (i == 0 && midx > 0)\t\t\t\t// %f\n\t    status = qf_parse_fmt_f(regmatch, midx, fields, idx);\n\telse if (i == FMT_PATTERN_M)\n\t{\n\t    if (fmt_ptr->flags == '+' && !qf_multiscan)\t// %+\n\t\tstatus = copy_nonerror_line(linebuf, linelen, fields);\n\t    else if (midx > 0)\t\t\t\t// %m\n\t\tstatus = qf_parse_fmt_m(regmatch, midx, fields);\n\t}\n\telse if (i == FMT_PATTERN_R && midx > 0)\t// %r\n\t    status = qf_parse_fmt_r(regmatch, midx, tail);\n\telse if (midx > 0)\t\t\t\t// others\n\t    status = (qf_parse_fmt[i])(regmatch, midx, fields);\n\n\tif (status != QF_OK)\n\t    return status;\n    }\n\n    return QF_OK;\n}\n\n/*\n * Parse an error line in 'linebuf' using a single error format string in\n * 'fmt_ptr->prog' and return the matching values in 'fields'.\n * Returns QF_OK if the efm format matches completely and the fields are\n * successfully copied. Otherwise returns QF_FAIL or QF_NOMEM.\n */\n    static int\nqf_parse_get_fields(\n\tchar_u\t\t*linebuf,\n\tint\t\tlinelen,\n\tefm_T\t\t*fmt_ptr,\n\tqffields_T\t*fields,\n\tint\t\tqf_multiline,\n\tint\t\tqf_multiscan,\n\tchar_u\t\t**tail)\n{\n    regmatch_T\tregmatch;\n    int\t\tstatus = QF_FAIL;\n    int\t\tr;\n\n    if (qf_multiscan &&\n\t\tvim_strchr((char_u *)\"OPQ\", fmt_ptr->prefix) == NULL)\n\treturn QF_FAIL;\n\n    fields->namebuf[0] = NUL;\n    fields->module[0] = NUL;\n    fields->pattern[0] = NUL;\n    if (!qf_multiscan)\n\tfields->errmsg[0] = NUL;\n    fields->lnum = 0;\n    fields->end_lnum = 0;\n    fields->col = 0;\n    fields->end_col = 0;\n    fields->use_viscol = FALSE;\n    fields->enr = -1;\n    fields->type = 0;\n    *tail = NULL;\n\n    // Always ignore case when looking for a matching error.\n    regmatch.rm_ic = TRUE;\n    regmatch.regprog = fmt_ptr->prog;\n    r = vim_regexec(&regmatch, linebuf, (colnr_T)0);\n    fmt_ptr->prog = regmatch.regprog;\n    if (r)\n\tstatus = qf_parse_match(linebuf, linelen, fmt_ptr, &regmatch,\n\t\tfields, qf_multiline, qf_multiscan, tail);\n\n    return status;\n}\n\n/*\n * Parse directory error format prefixes (%D and %X).\n * Push and pop directories from the directory stack when scanning directory\n * names.\n */\n    static int\nqf_parse_dir_pfx(int idx, qffields_T *fields, qf_list_T *qfl)\n{\n    if (idx == 'D')\t\t\t\t// enter directory\n    {\n\tif (*fields->namebuf == NUL)\n\t{\n\t    emsg(_(e_missing_or_empty_directory_name));\n\t    return QF_FAIL;\n\t}\n\tqfl->qf_directory =\n\t    qf_push_dir(fields->namebuf, &qfl->qf_dir_stack, FALSE);\n\tif (qfl->qf_directory == NULL)\n\t    return QF_FAIL;\n    }\n    else if (idx == 'X')\t\t\t// leave directory\n\tqfl->qf_directory = qf_pop_dir(&qfl->qf_dir_stack);\n\n    return QF_OK;\n}\n\n/*\n * Parse global file name error format prefixes (%O, %P and %Q).\n */\n    static int\nqf_parse_file_pfx(\n\tint idx,\n\tqffields_T *fields,\n\tqf_list_T *qfl,\n\tchar_u *tail)\n{\n    fields->valid = FALSE;\n    if (*fields->namebuf == NUL || mch_getperm(fields->namebuf) >= 0)\n    {\n\tif (*fields->namebuf && idx == 'P')\n\t    qfl->qf_currfile =\n\t\tqf_push_dir(fields->namebuf, &qfl->qf_file_stack, TRUE);\n\telse if (idx == 'Q')\n\t    qfl->qf_currfile = qf_pop_dir(&qfl->qf_file_stack);\n\t*fields->namebuf = NUL;\n\tif (tail && *tail)\n\t{\n\t    STRMOVE(IObuff, skipwhite(tail));\n\t    qfl->qf_multiscan = TRUE;\n\t    return QF_MULTISCAN;\n\t}\n    }\n\n    return QF_OK;\n}\n\n/*\n * Parse a non-error line (a line which doesn't match any of the error\n * format in 'efm').\n */\n    static int\nqf_parse_line_nomatch(char_u *linebuf, int linelen, qffields_T *fields)\n{\n    fields->namebuf[0] = NUL;\t// no match found, remove file name\n    fields->lnum = 0;\t\t// don't jump to this line\n    fields->valid = FALSE;\n\n    return copy_nonerror_line(linebuf, linelen, fields);\n}\n\n/*\n * Parse multi-line error format prefixes (%C and %Z)\n */\n    static int\nqf_parse_multiline_pfx(\n\tint idx,\n\tqf_list_T *qfl,\n\tqffields_T *fields)\n{\n    char_u\t\t*ptr;\n    int\t\t\tlen;\n\n    if (!qfl->qf_multiignore)\n    {\n\tqfline_T *qfprev = qfl->qf_last;\n\n\tif (qfprev == NULL)\n\t    return QF_FAIL;\n\tif (*fields->errmsg && !qfl->qf_multiignore)\n\t{\n\t    len = (int)STRLEN(qfprev->qf_text);\n\t    ptr = alloc_id(len + STRLEN(fields->errmsg) + 2,\n\t\t\t\t\t\taid_qf_multiline_pfx);\n\t    if (ptr == NULL)\n\t\treturn QF_FAIL;\n\t    STRCPY(ptr, qfprev->qf_text);\n\t    vim_free(qfprev->qf_text);\n\t    qfprev->qf_text = ptr;\n\t    *(ptr += len) = '\\n';\n\t    STRCPY(++ptr, fields->errmsg);\n\t}\n\tif (qfprev->qf_nr == -1)\n\t    qfprev->qf_nr = fields->enr;\n\tif (vim_isprintc(fields->type) && !qfprev->qf_type)\n\t    // only printable chars allowed\n\t    qfprev->qf_type = fields->type;\n\n\tif (!qfprev->qf_lnum)\n\t    qfprev->qf_lnum = fields->lnum;\n\tif (!qfprev->qf_end_lnum)\n\t    qfprev->qf_end_lnum = fields->end_lnum;\n\tif (!qfprev->qf_col)\n\t{\n\t    qfprev->qf_col = fields->col;\n\t    qfprev->qf_viscol = fields->use_viscol;\n\t}\n\tif (!qfprev->qf_end_col)\n\t    qfprev->qf_end_col = fields->end_col;\n\tif (!qfprev->qf_fnum)\n\t    qfprev->qf_fnum = qf_get_fnum(qfl,\n\t\t    qfl->qf_directory,\n\t\t    *fields->namebuf || qfl->qf_directory != NULL\n\t\t    ? fields->namebuf\n\t\t    : qfl->qf_currfile != NULL && fields->valid\n\t\t    ? qfl->qf_currfile : 0);\n    }\n    if (idx == 'Z')\n\tqfl->qf_multiline = qfl->qf_multiignore = FALSE;\n    line_breakcheck();\n\n    return QF_IGNORE_LINE;\n}\n\n/*\n * Parse a line and get the quickfix fields.\n * Return the QF_ status.\n */\n    static int\nqf_parse_line(\n\tqf_list_T\t*qfl,\n\tchar_u\t\t*linebuf,\n\tint\t\tlinelen,\n\tefm_T\t\t*fmt_first,\n\tqffields_T\t*fields)\n{\n    efm_T\t\t*fmt_ptr;\n    int\t\t\tidx = 0;\n    char_u\t\t*tail = NULL;\n    int\t\t\tstatus;\n\nrestofline:\n    // If there was no %> item start at the first pattern\n    if (fmt_start == NULL)\n\tfmt_ptr = fmt_first;\n    else\n    {\n\t// Otherwise start from the last used pattern\n\tfmt_ptr = fmt_start;\n\tfmt_start = NULL;\n    }\n\n    // Try to match each part of 'errorformat' until we find a complete\n    // match or no match.\n    fields->valid = TRUE;\n    for ( ; fmt_ptr != NULL; fmt_ptr = fmt_ptr->next)\n    {\n\tidx = fmt_ptr->prefix;\n\tstatus = qf_parse_get_fields(linebuf, linelen, fmt_ptr, fields,\n\t\t\t\tqfl->qf_multiline, qfl->qf_multiscan, &tail);\n\tif (status == QF_NOMEM)\n\t    return status;\n\tif (status == QF_OK)\n\t    break;\n    }\n    qfl->qf_multiscan = FALSE;\n\n    if (fmt_ptr == NULL || idx == 'D' || idx == 'X')\n    {\n\tif (fmt_ptr != NULL)\n\t{\n\t    // 'D' and 'X' directory specifiers\n\t    status = qf_parse_dir_pfx(idx, fields, qfl);\n\t    if (status != QF_OK)\n\t\treturn status;\n\t}\n\n\tstatus = qf_parse_line_nomatch(linebuf, linelen, fields);\n\tif (status != QF_OK)\n\t    return status;\n\n\tif (fmt_ptr == NULL)\n\t    qfl->qf_multiline = qfl->qf_multiignore = FALSE;\n    }\n    else if (fmt_ptr != NULL)\n    {\n\t// honor %> item\n\tif (fmt_ptr->conthere)\n\t    fmt_start = fmt_ptr;\n\n\tif (vim_strchr((char_u *)\"AEWIN\", idx) != NULL)\n\t{\n\t    qfl->qf_multiline = TRUE;\t// start of a multi-line message\n\t    qfl->qf_multiignore = FALSE;// reset continuation\n\t}\n\telse if (vim_strchr((char_u *)\"CZ\", idx) != NULL)\n\t{\t\t\t\t// continuation of multi-line msg\n\t    status = qf_parse_multiline_pfx(idx, qfl, fields);\n\t    if (status != QF_OK)\n\t\treturn status;\n\t}\n\telse if (vim_strchr((char_u *)\"OPQ\", idx) != NULL)\n\t{\t\t\t\t// global file names\n\t    status = qf_parse_file_pfx(idx, fields, qfl, tail);\n\t    if (status == QF_MULTISCAN)\n\t\tgoto restofline;\n\t}\n\tif (fmt_ptr->flags == '-')\t// generally exclude this line\n\t{\n\t    if (qfl->qf_multiline)\n\t\t// also exclude continuation lines\n\t\tqfl->qf_multiignore = TRUE;\n\t    return QF_IGNORE_LINE;\n\t}\n    }\n\n    return QF_OK;\n}\n\n/*\n * Returns TRUE if the specified quickfix/location stack is empty\n */\n    static int\nqf_stack_empty(qf_info_T *qi)\n{\n    return qi == NULL || qi->qf_listcount <= 0;\n}\n\n/*\n * Returns TRUE if the specified quickfix/location list is empty.\n */\n    static int\nqf_list_empty(qf_list_T *qfl)\n{\n    return qfl == NULL || qfl->qf_count <= 0;\n}\n\n/*\n * Returns TRUE if the specified quickfix/location list is not empty and\n * has valid entries.\n */\n    static int\nqf_list_has_valid_entries(qf_list_T *qfl)\n{\n    return !qf_list_empty(qfl) && !qfl->qf_nonevalid;\n}\n\n/*\n * Return a pointer to a list in the specified quickfix stack\n */\n    static qf_list_T *\nqf_get_list(qf_info_T *qi, int idx)\n{\n    return &qi->qf_lists[idx];\n}\n\n/*\n * Allocate the fields used for parsing lines and populating a quickfix list.\n */\n    static int\nqf_alloc_fields(qffields_T *pfields)\n{\n    pfields->namebuf = alloc_id(CMDBUFFSIZE + 1, aid_qf_namebuf);\n    pfields->module = alloc_id(CMDBUFFSIZE + 1, aid_qf_module);\n    pfields->errmsglen = CMDBUFFSIZE + 1;\n    pfields->errmsg = alloc_id(pfields->errmsglen, aid_qf_errmsg);\n    pfields->pattern = alloc_id(CMDBUFFSIZE + 1, aid_qf_pattern);\n    if (pfields->namebuf == NULL || pfields->errmsg == NULL\n\t\t|| pfields->pattern == NULL || pfields->module == NULL)\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * Free the fields used for parsing lines and populating a quickfix list.\n */\n    static void\nqf_free_fields(qffields_T *pfields)\n{\n    vim_free(pfields->namebuf);\n    vim_free(pfields->module);\n    vim_free(pfields->errmsg);\n    vim_free(pfields->pattern);\n}\n\n/*\n * Setup the state information used for parsing lines and populating a\n * quickfix list.\n */\n    static int\nqf_setup_state(\n\tqfstate_T\t*pstate,\n\tchar_u\t\t*enc,\n\tchar_u\t\t*efile,\n\ttypval_T\t*tv,\n\tbuf_T\t\t*buf,\n\tlinenr_T\tlnumfirst,\n\tlinenr_T\tlnumlast)\n{\n    pstate->vc.vc_type = CONV_NONE;\n    if (enc != NULL && *enc != NUL)\n\tconvert_setup(&pstate->vc, enc, p_enc);\n\n    if (efile != NULL && (pstate->fd = mch_fopen((char *)efile, \"r\")) == NULL)\n    {\n\tsemsg(_(e_cant_open_errorfile_str), efile);\n\treturn FAIL;\n    }\n\n    if (tv != NULL)\n    {\n\tif (tv->v_type == VAR_STRING)\n\t    pstate->p_str = tv->vval.v_string;\n\telse if (tv->v_type == VAR_LIST)\n\t    pstate->p_li = tv->vval.v_list->lv_first;\n\tpstate->tv = tv;\n    }\n    pstate->buf = buf;\n    pstate->buflnum = lnumfirst;\n    pstate->lnumlast = lnumlast;\n\n    return OK;\n}\n\n/*\n * Cleanup the state information used for parsing lines and populating a\n * quickfix list.\n */\n    static void\nqf_cleanup_state(qfstate_T *pstate)\n{\n    if (pstate->fd != NULL)\n\tfclose(pstate->fd);\n\n    vim_free(pstate->growbuf);\n    if (pstate->vc.vc_type != CONV_NONE)\n\tconvert_setup(&pstate->vc, NULL, NULL);\n}\n\n/*\n * Process the next line from a file/buffer/list/string and add it\n * to the quickfix list 'qfl'.\n */\n    static int\nqf_init_process_nextline(\n\tqf_list_T\t*qfl,\n\tefm_T\t\t*fmt_first,\n\tqfstate_T\t*state,\n\tqffields_T\t*fields)\n{\n    int\t\t    status;\n\n    // Get the next line from a file/buffer/list/string\n    status = qf_get_nextline(state);\n    if (status != QF_OK)\n\treturn status;\n\n    status = qf_parse_line(qfl, state->linebuf, state->linelen,\n\t    fmt_first, fields);\n    if (status != QF_OK)\n\treturn status;\n\n    return qf_add_entry(qfl,\n\t\tqfl->qf_directory,\n\t\t(*fields->namebuf || qfl->qf_directory != NULL)\n\t\t? fields->namebuf\n\t\t: ((qfl->qf_currfile != NULL && fields->valid)\n\t\t    ? qfl->qf_currfile : (char_u *)NULL),\n\t\tfields->module,\n\t\t0,\n\t\tfields->errmsg,\n\t\tfields->lnum,\n\t\tfields->end_lnum,\n\t\tfields->col,\n\t\tfields->end_col,\n\t\tfields->use_viscol,\n\t\tfields->pattern,\n\t\tfields->enr,\n\t\tfields->type,\n\t\tfields->valid);\n}\n\n/*\n * Read the errorfile \"efile\" into memory, line by line, building the error\n * list.\n * Alternative: when \"efile\" is NULL read errors from buffer \"buf\".\n * Alternative: when \"tv\" is not NULL get errors from the string or list.\n * Always use 'errorformat' from \"buf\" if there is a local value.\n * Then \"lnumfirst\" and \"lnumlast\" specify the range of lines to use.\n * Set the title of the list to \"qf_title\".\n * Return -1 for error, number of errors for success.\n */\n    static int\nqf_init_ext(\n    qf_info_T\t    *qi,\n    int\t\t    qf_idx,\n    char_u\t    *efile,\n    buf_T\t    *buf,\n    typval_T\t    *tv,\n    char_u\t    *errorformat,\n    int\t\t    newlist,\t\t// TRUE: start a new error list\n    linenr_T\t    lnumfirst,\t\t// first line number to use\n    linenr_T\t    lnumlast,\t\t// last line number to use\n    char_u\t    *qf_title,\n    char_u\t    *enc)\n{\n    qf_list_T\t    *qfl;\n    qfstate_T\t    state;\n    qffields_T\t    fields;\n    qfline_T\t    *old_last = NULL;\n    int\t\t    adding = FALSE;\n    static efm_T    *fmt_first = NULL;\n    char_u\t    *efm;\n    static char_u   *last_efm = NULL;\n    int\t\t    retval = -1;\t// default: return error flag\n    int\t\t    status;\n\n    // Do not used the cached buffer, it may have been wiped out.\n    VIM_CLEAR(qf_last_bufname);\n\n    CLEAR_FIELD(state);\n    CLEAR_FIELD(fields);\n    if ((qf_alloc_fields(&fields) == FAIL) ||\n\t\t(qf_setup_state(&state, enc, efile, tv, buf,\n\t\t\t\t\tlnumfirst, lnumlast) == FAIL))\n\tgoto qf_init_end;\n\n    if (newlist || qf_idx == qi->qf_listcount)\n    {\n\t// make place for a new list\n\tqf_new_list(qi, qf_title);\n\tqf_idx = qi->qf_curlist;\n\tqfl = qf_get_list(qi, qf_idx);\n    }\n    else\n    {\n\t// Adding to existing list, use last entry.\n\tadding = TRUE;\n\tqfl = qf_get_list(qi, qf_idx);\n\tif (!qf_list_empty(qfl))\n\t    old_last = qfl->qf_last;\n    }\n\n    // Use the local value of 'errorformat' if it's set.\n    if (errorformat == p_efm && tv == NULL && *buf->b_p_efm != NUL)\n\tefm = buf->b_p_efm;\n    else\n\tefm = errorformat;\n\n    // If the errorformat didn't change between calls, then reuse the\n    // previously parsed values.\n    if (last_efm == NULL || (STRCMP(last_efm, efm) != 0))\n    {\n\t// free the previously parsed data\n\tVIM_CLEAR(last_efm);\n\tfree_efm_list(&fmt_first);\n\n\t// parse the current 'efm'\n\tfmt_first = parse_efm_option(efm);\n\tif (fmt_first != NULL)\n\t    last_efm = vim_strsave(efm);\n    }\n\n    if (fmt_first == NULL)\t// nothing found\n\tgoto error2;\n\n    // got_int is reset here, because it was probably set when killing the\n    // \":make\" command, but we still want to read the errorfile then.\n    got_int = FALSE;\n\n    // Read the lines in the error file one by one.\n    // Try to recognize one of the error formats in each line.\n    while (!got_int)\n    {\n\tstatus = qf_init_process_nextline(qfl, fmt_first, &state, &fields);\n\tif (status == QF_NOMEM)\t\t// memory alloc failure\n\t    goto qf_init_end;\n\tif (status == QF_END_OF_INPUT)\t// end of input\n\t    break;\n\tif (status == QF_FAIL)\n\t    goto error2;\n\n\tline_breakcheck();\n    }\n    if (state.fd == NULL || !ferror(state.fd))\n    {\n\tif (qfl->qf_index == 0)\n\t{\n\t    // no valid entry found\n\t    qfl->qf_ptr = qfl->qf_start;\n\t    qfl->qf_index = 1;\n\t    qfl->qf_nonevalid = TRUE;\n\t}\n\telse\n\t{\n\t    qfl->qf_nonevalid = FALSE;\n\t    if (qfl->qf_ptr == NULL)\n\t\tqfl->qf_ptr = qfl->qf_start;\n\t}\n\t// return number of matches\n\tretval = qfl->qf_count;\n\tgoto qf_init_end;\n    }\n    emsg(_(e_error_while_reading_errorfile));\nerror2:\n    if (!adding)\n    {\n\t// Error when creating a new list. Free the new list\n\tqf_free(qfl);\n\tqi->qf_listcount--;\n\tif (qi->qf_curlist > 0)\n\t    --qi->qf_curlist;\n    }\nqf_init_end:\n    if (qf_idx == qi->qf_curlist)\n\tqf_update_buffer(qi, old_last);\n    qf_cleanup_state(&state);\n    qf_free_fields(&fields);\n\n    return retval;\n}\n\n/*\n * Read the errorfile \"efile\" into memory, line by line, building the error\n * list. Set the error list's title to qf_title.\n * Return -1 for error, number of errors for success.\n */\n    int\nqf_init(win_T\t    *wp,\n\tchar_u\t    *efile,\n\tchar_u\t    *errorformat,\n\tint\t    newlist,\t\t// TRUE: start a new error list\n\tchar_u\t    *qf_title,\n\tchar_u\t    *enc)\n{\n    qf_info_T\t    *qi = &ql_info;\n\n    if (wp != NULL)\n    {\n\tqi = ll_get_or_alloc_list(wp);\n\tif (qi == NULL)\n\t    return FAIL;\n    }\n\n    return qf_init_ext(qi, qi->qf_curlist, efile, curbuf, NULL, errorformat,\n\t    newlist, (linenr_T)0, (linenr_T)0, qf_title, enc);\n}\n\n/*\n * Set the title of the specified quickfix list. Frees the previous title.\n * Prepends ':' to the title.\n */\n    static void\nqf_store_title(qf_list_T *qfl, char_u *title)\n{\n    VIM_CLEAR(qfl->qf_title);\n\n    if (title != NULL)\n    {\n\tchar_u *p = alloc_id(STRLEN(title) + 2, aid_qf_title);\n\n\tqfl->qf_title = p;\n\tif (p != NULL)\n\t    STRCPY(p, title);\n    }\n}\n\n/*\n * The title of a quickfix/location list is set, by default, to the command\n * that created the quickfix list with the \":\" prefix.\n * Create a quickfix list title string by prepending \":\" to a user command.\n * Returns a pointer to a static buffer with the title.\n */\n    static char_u *\nqf_cmdtitle(char_u *cmd)\n{\n    static char_u qftitle_str[IOSIZE];\n\n    vim_snprintf((char *)qftitle_str, IOSIZE, \":%s\", (char *)cmd);\n    return qftitle_str;\n}\n\n/*\n * Return a pointer to the current list in the specified quickfix stack\n */\n    static qf_list_T *\nqf_get_curlist(qf_info_T *qi)\n{\n    return qf_get_list(qi, qi->qf_curlist);\n}\n\n/*\n * Prepare for adding a new quickfix list. If the current list is in the\n * middle of the stack, then all the following lists are freed and then\n * the new list is added.\n */\n    static void\nqf_new_list(qf_info_T *qi, char_u *qf_title)\n{\n    int\t\ti;\n    qf_list_T\t*qfl;\n\n    // If the current entry is not the last entry, delete entries beyond\n    // the current entry.  This makes it possible to browse in a tree-like\n    // way with \":grep\".\n    while (qi->qf_listcount > qi->qf_curlist + 1)\n\tqf_free(&qi->qf_lists[--qi->qf_listcount]);\n\n    // When the stack is full, remove to oldest entry\n    // Otherwise, add a new entry.\n    if (qi->qf_listcount == LISTCOUNT)\n    {\n\tqf_free(&qi->qf_lists[0]);\n\tfor (i = 1; i < LISTCOUNT; ++i)\n\t    qi->qf_lists[i - 1] = qi->qf_lists[i];\n\tqi->qf_curlist = LISTCOUNT - 1;\n    }\n    else\n\tqi->qf_curlist = qi->qf_listcount++;\n    qfl = qf_get_curlist(qi);\n    CLEAR_POINTER(qfl);\n    qf_store_title(qfl, qf_title);\n    qfl->qfl_type = qi->qfl_type;\n    qfl->qf_id = ++last_qf_id;\n}\n\n/*\n * Queue location list stack delete request.\n */\n    static void\nlocstack_queue_delreq(qf_info_T *qi)\n{\n    qf_delq_T\t*q;\n\n    q = ALLOC_ONE(qf_delq_T);\n    if (q != NULL)\n    {\n\tq->qi = qi;\n\tq->next = qf_delq_head;\n\tqf_delq_head = q;\n    }\n}\n\n/*\n * Return the global quickfix stack window buffer number.\n */\n    int\nqf_stack_get_bufnr(void)\n{\n    return ql_info.qf_bufnr;\n}\n\n/*\n * Wipe the quickfix window buffer (if present) for the specified\n * quickfix/location list.\n */\n    static void\nwipe_qf_buffer(qf_info_T *qi)\n{\n    buf_T\t*qfbuf;\n\n    if (qi->qf_bufnr != INVALID_QFBUFNR)\n    {\n\tqfbuf = buflist_findnr(qi->qf_bufnr);\n\tif (qfbuf != NULL && qfbuf->b_nwindows == 0)\n\t{\n\t    // If the quickfix buffer is not loaded in any window, then\n\t    // wipe the buffer.\n\t    close_buffer(NULL, qfbuf, DOBUF_WIPE, FALSE, FALSE);\n\t    qi->qf_bufnr = INVALID_QFBUFNR;\n\t}\n    }\n}\n\n/*\n * Free a location list stack\n */\n    static void\nll_free_all(qf_info_T **pqi)\n{\n    int\t\ti;\n    qf_info_T\t*qi;\n\n    qi = *pqi;\n    if (qi == NULL)\n\treturn;\n    *pqi = NULL;\t// Remove reference to this list\n\n    // If the location list is still in use, then queue the delete request\n    // to be processed later.\n    if (quickfix_busy > 0)\n    {\n\tlocstack_queue_delreq(qi);\n\treturn;\n    }\n\n    qi->qf_refcount--;\n    if (qi->qf_refcount < 1)\n    {\n\t// No references to this location list.\n\t// If the quickfix window buffer is loaded, then wipe it\n\twipe_qf_buffer(qi);\n\n\tfor (i = 0; i < qi->qf_listcount; ++i)\n\t    qf_free(qf_get_list(qi, i));\n\tvim_free(qi);\n    }\n}\n\n/*\n * Free all the quickfix/location lists in the stack.\n */\n    void\nqf_free_all(win_T *wp)\n{\n    int\t\ti;\n    qf_info_T\t*qi = &ql_info;\n\n    if (wp != NULL)\n    {\n\t// location list\n\tll_free_all(&wp->w_llist);\n\tll_free_all(&wp->w_llist_ref);\n    }\n    else\n\t// quickfix list\n\tfor (i = 0; i < qi->qf_listcount; ++i)\n\t    qf_free(qf_get_list(qi, i));\n}\n\n/*\n * Delay freeing of location list stacks when the quickfix code is running.\n * Used to avoid problems with autocmds freeing location list stacks when the\n * quickfix code is still referencing the stack.\n * Must always call decr_quickfix_busy() exactly once after this.\n */\n    static void\nincr_quickfix_busy(void)\n{\n    quickfix_busy++;\n}\n\n/*\n * Safe to free location list stacks. Process any delayed delete requests.\n */\n    static void\ndecr_quickfix_busy(void)\n{\n    if (--quickfix_busy == 0)\n    {\n\t// No longer referencing the location lists. Process all the pending\n\t// delete requests.\n\twhile (qf_delq_head != NULL)\n\t{\n\t    qf_delq_T\t*q = qf_delq_head;\n\n\t    qf_delq_head = q->next;\n\t    ll_free_all(&q->qi);\n\t    vim_free(q);\n\t}\n    }\n#ifdef ABORT_ON_INTERNAL_ERROR\n    if (quickfix_busy < 0)\n    {\n\temsg(\"quickfix_busy has become negative\");\n\tabort();\n    }\n#endif\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\ncheck_quickfix_busy(void)\n{\n    if (quickfix_busy != 0)\n    {\n\tsemsg(\"quickfix_busy not zero on exit: %ld\", (long)quickfix_busy);\n# ifdef ABORT_ON_INTERNAL_ERROR\n\tabort();\n# endif\n    }\n}\n#endif\n\n/*\n * Add an entry to the end of the list of errors.\n * Returns QF_OK on success or QF_FAIL on a memory allocation failure.\n */\n    static int\nqf_add_entry(\n    qf_list_T\t*qfl,\t\t// quickfix list entry\n    char_u\t*dir,\t\t// optional directory name\n    char_u\t*fname,\t\t// file name or NULL\n    char_u\t*module,\t// module name or NULL\n    int\t\tbufnum,\t\t// buffer number or zero\n    char_u\t*mesg,\t\t// message\n    long\tlnum,\t\t// line number\n    long\tend_lnum,\t// line number for end\n    int\t\tcol,\t\t// column\n    int\t\tend_col,\t// column for end\n    int\t\tvis_col,\t// using visual column\n    char_u\t*pattern,\t// search pattern\n    int\t\tnr,\t\t// error number\n    int\t\ttype,\t\t// type character\n    int\t\tvalid)\t\t// valid entry\n{\n    qfline_T\t*qfp;\n    qfline_T\t**lastp;\t// pointer to qf_last or NULL\n\n    if ((qfp = ALLOC_ONE_ID(qfline_T, aid_qf_qfline)) == NULL)\n\treturn QF_FAIL;\n    if (bufnum != 0)\n    {\n\tbuf_T *buf = buflist_findnr(bufnum);\n\n\tqfp->qf_fnum = bufnum;\n\tif (buf != NULL)\n\t    buf->b_has_qf_entry |=\n\t\tIS_QF_LIST(qfl) ? BUF_HAS_QF_ENTRY : BUF_HAS_LL_ENTRY;\n    }\n    else\n\tqfp->qf_fnum = qf_get_fnum(qfl, dir, fname);\n    if ((qfp->qf_text = vim_strsave(mesg)) == NULL)\n    {\n\tvim_free(qfp);\n\treturn QF_FAIL;\n    }\n    qfp->qf_lnum = lnum;\n    qfp->qf_end_lnum = end_lnum;\n    qfp->qf_col = col;\n    qfp->qf_end_col = end_col;\n    qfp->qf_viscol = vis_col;\n    if (pattern == NULL || *pattern == NUL)\n\tqfp->qf_pattern = NULL;\n    else if ((qfp->qf_pattern = vim_strsave(pattern)) == NULL)\n    {\n\tvim_free(qfp->qf_text);\n\tvim_free(qfp);\n\treturn QF_FAIL;\n    }\n    if (module == NULL || *module == NUL)\n\tqfp->qf_module = NULL;\n    else if ((qfp->qf_module = vim_strsave(module)) == NULL)\n    {\n\tvim_free(qfp->qf_text);\n\tvim_free(qfp->qf_pattern);\n\tvim_free(qfp);\n\treturn QF_FAIL;\n    }\n    qfp->qf_nr = nr;\n    if (type != 1 && !vim_isprintc(type)) // only printable chars allowed\n\ttype = 0;\n    qfp->qf_type = type;\n    qfp->qf_valid = valid;\n\n    lastp = &qfl->qf_last;\n    if (qf_list_empty(qfl))\t\t// first element in the list\n    {\n\tqfl->qf_start = qfp;\n\tqfl->qf_ptr = qfp;\n\tqfl->qf_index = 0;\n\tqfp->qf_prev = NULL;\n    }\n    else\n    {\n\tqfp->qf_prev = *lastp;\n\t(*lastp)->qf_next = qfp;\n    }\n    qfp->qf_next = NULL;\n    qfp->qf_cleared = FALSE;\n    *lastp = qfp;\n    ++qfl->qf_count;\n    if (qfl->qf_index == 0 && qfp->qf_valid)\t// first valid entry\n    {\n\tqfl->qf_index = qfl->qf_count;\n\tqfl->qf_ptr = qfp;\n    }\n\n    return QF_OK;\n}\n\n/*\n * Allocate a new quickfix/location list stack\n */\n    static qf_info_T *\nqf_alloc_stack(qfltype_T qfltype)\n{\n    qf_info_T *qi;\n\n    qi = ALLOC_CLEAR_ONE_ID(qf_info_T, aid_qf_qfinfo);\n    if (qi != NULL)\n    {\n\tqi->qf_refcount++;\n\tqi->qfl_type = qfltype;\n\tqi->qf_bufnr = INVALID_QFBUFNR;\n    }\n    return qi;\n}\n\n/*\n * Return the location list stack for window 'wp'.\n * If not present, allocate a location list stack\n */\n    static qf_info_T *\nll_get_or_alloc_list(win_T *wp)\n{\n    if (IS_LL_WINDOW(wp))\n\t// For a location list window, use the referenced location list\n\treturn wp->w_llist_ref;\n\n    // For a non-location list window, w_llist_ref should not point to a\n    // location list.\n    ll_free_all(&wp->w_llist_ref);\n\n    if (wp->w_llist == NULL)\n\twp->w_llist = qf_alloc_stack(QFLT_LOCATION);\t// new location list\n    return wp->w_llist;\n}\n\n/*\n * Get the quickfix/location list stack to use for the specified Ex command.\n * For a location list command, returns the stack for the current window.  If\n * the location list is not found, then returns NULL and prints an error\n * message if 'print_emsg' is TRUE.\n */\n    static qf_info_T *\nqf_cmd_get_stack(exarg_T *eap, int print_emsg)\n{\n    qf_info_T\t*qi = &ql_info;\n\n    if (is_loclist_cmd(eap->cmdidx))\n    {\n\tqi = GET_LOC_LIST(curwin);\n\tif (qi == NULL)\n\t{\n\t    if (print_emsg)\n\t\temsg(_(e_no_location_list));\n\t    return NULL;\n\t}\n    }\n\n    return qi;\n}\n\n/*\n * Get the quickfix/location list stack to use for the specified Ex command.\n * For a location list command, returns the stack for the current window.\n * If the location list is not present, then allocates a new one.\n * Returns NULL if the allocation fails.  For a location list command, sets\n * 'pwinp' to curwin.\n */\n    static qf_info_T *\nqf_cmd_get_or_alloc_stack(exarg_T *eap, win_T **pwinp)\n{\n    qf_info_T\t*qi = &ql_info;\n\n    if (is_loclist_cmd(eap->cmdidx))\n    {\n\tqi = ll_get_or_alloc_list(curwin);\n\tif (qi == NULL)\n\t    return NULL;\n\t*pwinp = curwin;\n    }\n\n    return qi;\n}\n\n/*\n * Copy location list entries from 'from_qfl' to 'to_qfl'.\n */\n    static int\ncopy_loclist_entries(qf_list_T *from_qfl, qf_list_T *to_qfl)\n{\n    int\t\ti;\n    qfline_T    *from_qfp;\n    qfline_T    *prevp;\n\n    // copy all the location entries in this list\n    FOR_ALL_QFL_ITEMS(from_qfl, from_qfp, i)\n    {\n\tif (qf_add_entry(to_qfl,\n\t\t    NULL,\n\t\t    NULL,\n\t\t    from_qfp->qf_module,\n\t\t    0,\n\t\t    from_qfp->qf_text,\n\t\t    from_qfp->qf_lnum,\n\t\t    from_qfp->qf_end_lnum,\n\t\t    from_qfp->qf_col,\n\t\t    from_qfp->qf_end_col,\n\t\t    from_qfp->qf_viscol,\n\t\t    from_qfp->qf_pattern,\n\t\t    from_qfp->qf_nr,\n\t\t    0,\n\t\t    from_qfp->qf_valid) == QF_FAIL)\n\t    return FAIL;\n\n\t// qf_add_entry() will not set the qf_num field, as the\n\t// directory and file names are not supplied. So the qf_fnum\n\t// field is copied here.\n\tprevp = to_qfl->qf_last;\n\tprevp->qf_fnum = from_qfp->qf_fnum;\t// file number\n\tprevp->qf_type = from_qfp->qf_type;\t// error type\n\tif (from_qfl->qf_ptr == from_qfp)\n\t    to_qfl->qf_ptr = prevp;\t\t// current location\n    }\n\n    return OK;\n}\n\n/*\n * Copy the specified location list 'from_qfl' to 'to_qfl'.\n */\n    static int\ncopy_loclist(qf_list_T *from_qfl, qf_list_T *to_qfl)\n{\n    // Some of the fields are populated by qf_add_entry()\n    to_qfl->qfl_type = from_qfl->qfl_type;\n    to_qfl->qf_nonevalid = from_qfl->qf_nonevalid;\n    to_qfl->qf_count = 0;\n    to_qfl->qf_index = 0;\n    to_qfl->qf_start = NULL;\n    to_qfl->qf_last = NULL;\n    to_qfl->qf_ptr = NULL;\n    if (from_qfl->qf_title != NULL)\n\tto_qfl->qf_title = vim_strsave(from_qfl->qf_title);\n    else\n\tto_qfl->qf_title = NULL;\n    if (from_qfl->qf_ctx != NULL)\n    {\n\tto_qfl->qf_ctx = alloc_tv();\n\tif (to_qfl->qf_ctx != NULL)\n\t    copy_tv(from_qfl->qf_ctx, to_qfl->qf_ctx);\n    }\n    else\n\tto_qfl->qf_ctx = NULL;\n    if (from_qfl->qf_qftf_cb.cb_name != NULL)\n\tcopy_callback(&to_qfl->qf_qftf_cb, &from_qfl->qf_qftf_cb);\n    else\n\tto_qfl->qf_qftf_cb.cb_name = NULL;\n\n    if (from_qfl->qf_count)\n\tif (copy_loclist_entries(from_qfl, to_qfl) == FAIL)\n\t    return FAIL;\n\n    to_qfl->qf_index = from_qfl->qf_index;\t// current index in the list\n\n    // Assign a new ID for the location list\n    to_qfl->qf_id = ++last_qf_id;\n    to_qfl->qf_changedtick = 0L;\n\n    // When no valid entries are present in the list, qf_ptr points to\n    // the first item in the list\n    if (to_qfl->qf_nonevalid)\n    {\n\tto_qfl->qf_ptr = to_qfl->qf_start;\n\tto_qfl->qf_index = 1;\n    }\n\n    return OK;\n}\n\n/*\n * Copy the location list stack 'from' window to 'to' window.\n */\n    void\ncopy_loclist_stack(win_T *from, win_T *to)\n{\n    qf_info_T\t*qi;\n    int\t\tidx;\n\n    // When copying from a location list window, copy the referenced\n    // location list. For other windows, copy the location list for\n    // that window.\n    if (IS_LL_WINDOW(from))\n\tqi = from->w_llist_ref;\n    else\n\tqi = from->w_llist;\n\n    if (qi == NULL)\t\t    // no location list to copy\n\treturn;\n\n    // allocate a new location list\n    if ((to->w_llist = qf_alloc_stack(QFLT_LOCATION)) == NULL)\n\treturn;\n\n    to->w_llist->qf_listcount = qi->qf_listcount;\n\n    // Copy the location lists one at a time\n    for (idx = 0; idx < qi->qf_listcount; ++idx)\n    {\n\tto->w_llist->qf_curlist = idx;\n\n\tif (copy_loclist(qf_get_list(qi, idx),\n\t\t\tqf_get_list(to->w_llist, idx)) == FAIL)\n\t{\n\t    qf_free_all(to);\n\t    return;\n\t}\n    }\n\n    to->w_llist->qf_curlist = qi->qf_curlist;\t// current list\n}\n\n/*\n * Get buffer number for file \"directory/fname\".\n * Also sets the b_has_qf_entry flag.\n */\n    static int\nqf_get_fnum(qf_list_T *qfl, char_u *directory, char_u *fname)\n{\n    char_u\t*ptr = NULL;\n    buf_T\t*buf;\n    char_u\t*bufname;\n\n    if (fname == NULL || *fname == NUL)\t\t// no file name\n\treturn 0;\n\n#ifdef VMS\n    vms_remove_version(fname);\n#endif\n#ifdef BACKSLASH_IN_FILENAME\n    if (directory != NULL)\n\tslash_adjust(directory);\n    slash_adjust(fname);\n#endif\n    if (directory != NULL && !vim_isAbsName(fname)\n\t    && (ptr = concat_fnames(directory, fname, TRUE)) != NULL)\n    {\n\t// Here we check if the file really exists.\n\t// This should normally be true, but if make works without\n\t// \"leaving directory\"-messages we might have missed a\n\t// directory change.\n\tif (mch_getperm(ptr) < 0)\n\t{\n\t    vim_free(ptr);\n\t    directory = qf_guess_filepath(qfl, fname);\n\t    if (directory)\n\t\tptr = concat_fnames(directory, fname, TRUE);\n\t    else\n\t\tptr = vim_strsave(fname);\n\t}\n\t// Use concatenated directory name and file name\n\tbufname = ptr;\n    }\n    else\n\tbufname = fname;\n\n    if (qf_last_bufname != NULL && STRCMP(bufname, qf_last_bufname) == 0\n\t    && bufref_valid(&qf_last_bufref))\n    {\n\tbuf = qf_last_bufref.br_buf;\n\tvim_free(ptr);\n    }\n    else\n    {\n\tvim_free(qf_last_bufname);\n\tbuf = buflist_new(bufname, NULL, (linenr_T)0, BLN_NOOPT);\n\tif (bufname == ptr)\n\t    qf_last_bufname = bufname;\n\telse\n\t    qf_last_bufname = vim_strsave(bufname);\n\tset_bufref(&qf_last_bufref, buf);\n    }\n    if (buf == NULL)\n\treturn 0;\n\n    buf->b_has_qf_entry =\n\t\t\tIS_QF_LIST(qfl) ? BUF_HAS_QF_ENTRY : BUF_HAS_LL_ENTRY;\n    return buf->b_fnum;\n}\n\n/*\n * Push dirbuf onto the directory stack and return pointer to actual dir or\n * NULL on error.\n */\n    static char_u *\nqf_push_dir(char_u *dirbuf, struct dir_stack_T **stackptr, int is_file_stack)\n{\n    struct dir_stack_T  *ds_new;\n    struct dir_stack_T  *ds_ptr;\n\n    // allocate new stack element and hook it in\n    ds_new = ALLOC_ONE_ID(struct dir_stack_T, aid_qf_dirstack);\n    if (ds_new == NULL)\n\treturn NULL;\n\n    ds_new->next = *stackptr;\n    *stackptr = ds_new;\n\n    // store directory on the stack\n    if (vim_isAbsName(dirbuf)\n\t    || (*stackptr)->next == NULL\n\t    || is_file_stack)\n\t(*stackptr)->dirname = vim_strsave(dirbuf);\n    else\n    {\n\t// Okay we don't have an absolute path.\n\t// dirbuf must be a subdir of one of the directories on the stack.\n\t// Let's search...\n\tds_new = (*stackptr)->next;\n\t(*stackptr)->dirname = NULL;\n\twhile (ds_new)\n\t{\n\t    vim_free((*stackptr)->dirname);\n\t    (*stackptr)->dirname = concat_fnames(ds_new->dirname, dirbuf,\n\t\t    TRUE);\n\t    if (mch_isdir((*stackptr)->dirname) == TRUE)\n\t\tbreak;\n\n\t    ds_new = ds_new->next;\n\t}\n\n\t// clean up all dirs we already left\n\twhile ((*stackptr)->next != ds_new)\n\t{\n\t    ds_ptr = (*stackptr)->next;\n\t    (*stackptr)->next = (*stackptr)->next->next;\n\t    vim_free(ds_ptr->dirname);\n\t    vim_free(ds_ptr);\n\t}\n\n\t// Nothing found -> it must be on top level\n\tif (ds_new == NULL)\n\t{\n\t    vim_free((*stackptr)->dirname);\n\t    (*stackptr)->dirname = vim_strsave(dirbuf);\n\t}\n    }\n\n    if ((*stackptr)->dirname != NULL)\n\treturn (*stackptr)->dirname;\n    else\n    {\n\tds_ptr = *stackptr;\n\t*stackptr = (*stackptr)->next;\n\tvim_free(ds_ptr);\n\treturn NULL;\n    }\n}\n\n/*\n * pop dirbuf from the directory stack and return previous directory or NULL if\n * stack is empty\n */\n    static char_u *\nqf_pop_dir(struct dir_stack_T **stackptr)\n{\n    struct dir_stack_T  *ds_ptr;\n\n    // TODO: Should we check if dirbuf is the directory on top of the stack?\n    // What to do if it isn't?\n\n    // pop top element and free it\n    if (*stackptr != NULL)\n    {\n\tds_ptr = *stackptr;\n\t*stackptr = (*stackptr)->next;\n\tvim_free(ds_ptr->dirname);\n\tvim_free(ds_ptr);\n    }\n\n    // return NEW top element as current dir or NULL if stack is empty\n    return *stackptr ? (*stackptr)->dirname : NULL;\n}\n\n/*\n * clean up directory stack\n */\n    static void\nqf_clean_dir_stack(struct dir_stack_T **stackptr)\n{\n    struct dir_stack_T  *ds_ptr;\n\n    while ((ds_ptr = *stackptr) != NULL)\n    {\n\t*stackptr = (*stackptr)->next;\n\tvim_free(ds_ptr->dirname);\n\tvim_free(ds_ptr);\n    }\n}\n\n/*\n * Check in which directory of the directory stack the given file can be\n * found.\n * Returns a pointer to the directory name or NULL if not found.\n * Cleans up intermediate directory entries.\n *\n * TODO: How to solve the following problem?\n * If we have this directory tree:\n *     ./\n *     ./aa\n *     ./aa/bb\n *     ./bb\n *     ./bb/x.c\n * and make says:\n *     making all in aa\n *     making all in bb\n *     x.c:9: Error\n * Then qf_push_dir thinks we are in ./aa/bb, but we are in ./bb.\n * qf_guess_filepath will return NULL.\n */\n    static char_u *\nqf_guess_filepath(qf_list_T *qfl, char_u *filename)\n{\n    struct dir_stack_T     *ds_ptr;\n    struct dir_stack_T     *ds_tmp;\n    char_u\t\t   *fullname;\n\n    // no dirs on the stack - there's nothing we can do\n    if (qfl->qf_dir_stack == NULL)\n\treturn NULL;\n\n    ds_ptr = qfl->qf_dir_stack->next;\n    fullname = NULL;\n    while (ds_ptr)\n    {\n\tvim_free(fullname);\n\tfullname = concat_fnames(ds_ptr->dirname, filename, TRUE);\n\n\t// If concat_fnames failed, just go on. The worst thing that can happen\n\t// is that we delete the entire stack.\n\tif ((fullname != NULL) && (mch_getperm(fullname) >= 0))\n\t    break;\n\n\tds_ptr = ds_ptr->next;\n    }\n\n    vim_free(fullname);\n\n    // clean up all dirs we already left\n    while (qfl->qf_dir_stack->next != ds_ptr)\n    {\n\tds_tmp = qfl->qf_dir_stack->next;\n\tqfl->qf_dir_stack->next = qfl->qf_dir_stack->next->next;\n\tvim_free(ds_tmp->dirname);\n\tvim_free(ds_tmp);\n    }\n\n    return ds_ptr == NULL ? NULL : ds_ptr->dirname;\n}\n\n/*\n * Returns TRUE if a quickfix/location list with the given identifier exists.\n */\n    static int\nqflist_valid(win_T *wp, int_u qf_id)\n{\n    qf_info_T\t*qi = &ql_info;\n    int\t\ti;\n\n    if (wp != NULL)\n    {\n\tif (!win_valid(wp))\n\t    return FALSE;\n\tqi = GET_LOC_LIST(wp);\t    // Location list\n\tif (qi == NULL)\n\t    return FALSE;\n    }\n\n    for (i = 0; i < qi->qf_listcount; ++i)\n\tif (qi->qf_lists[i].qf_id == qf_id)\n\t    return TRUE;\n\n    return FALSE;\n}\n\n/*\n * When loading a file from the quickfix, the autocommands may modify it.\n * This may invalidate the current quickfix entry.  This function checks\n * whether an entry is still present in the quickfix list.\n * Similar to location list.\n */\n    static int\nis_qf_entry_present(qf_list_T *qfl, qfline_T *qf_ptr)\n{\n    qfline_T\t*qfp;\n    int\t\ti;\n\n    // Search for the entry in the current list\n    FOR_ALL_QFL_ITEMS(qfl, qfp, i)\n\tif (qfp == qf_ptr)\n\t    break;\n\n    if (i > qfl->qf_count) // Entry is not found\n\treturn FALSE;\n\n    return TRUE;\n}\n\n/*\n * Get the next valid entry in the current quickfix/location list. The search\n * starts from the current entry.  Returns NULL on failure.\n */\n    static qfline_T *\nget_next_valid_entry(\n\tqf_list_T\t*qfl,\n\tqfline_T\t*qf_ptr,\n\tint\t\t*qf_index,\n\tint\t\tdir)\n{\n    int\t\t\tidx;\n    int\t\t\told_qf_fnum;\n\n    idx = *qf_index;\n    old_qf_fnum = qf_ptr->qf_fnum;\n\n    do\n    {\n\tif (idx == qfl->qf_count || qf_ptr->qf_next == NULL)\n\t    return NULL;\n\t++idx;\n\tqf_ptr = qf_ptr->qf_next;\n    } while ((!qfl->qf_nonevalid && !qf_ptr->qf_valid)\n\t    || (dir == FORWARD_FILE && qf_ptr->qf_fnum == old_qf_fnum));\n\n    *qf_index = idx;\n    return qf_ptr;\n}\n\n/*\n * Get the previous valid entry in the current quickfix/location list. The\n * search starts from the current entry.  Returns NULL on failure.\n */\n    static qfline_T *\nget_prev_valid_entry(\n\tqf_list_T\t*qfl,\n\tqfline_T\t*qf_ptr,\n\tint\t\t*qf_index,\n\tint\t\tdir)\n{\n    int\t\t\tidx;\n    int\t\t\told_qf_fnum;\n\n    idx = *qf_index;\n    old_qf_fnum = qf_ptr->qf_fnum;\n\n    do\n    {\n\tif (idx == 1 || qf_ptr->qf_prev == NULL)\n\t    return NULL;\n\t--idx;\n\tqf_ptr = qf_ptr->qf_prev;\n    } while ((!qfl->qf_nonevalid && !qf_ptr->qf_valid)\n\t    || (dir == BACKWARD_FILE && qf_ptr->qf_fnum == old_qf_fnum));\n\n    *qf_index = idx;\n    return qf_ptr;\n}\n\n/*\n * Get the n'th (errornr) previous/next valid entry from the current entry in\n * the quickfix list.\n *   dir == FORWARD or FORWARD_FILE: next valid entry\n *   dir == BACKWARD or BACKWARD_FILE: previous valid entry\n */\n    static qfline_T *\nget_nth_valid_entry(\n\tqf_list_T\t*qfl,\n\tint\t\terrornr,\n\tint\t\tdir,\n\tint\t\t*new_qfidx)\n{\n    qfline_T\t\t*qf_ptr = qfl->qf_ptr;\n    int\t\t\tqf_idx = qfl->qf_index;\n    qfline_T\t\t*prev_qf_ptr;\n    int\t\t\tprev_index;\n    char\t\t*err = e_no_more_items;\n\n    while (errornr--)\n    {\n\tprev_qf_ptr = qf_ptr;\n\tprev_index = qf_idx;\n\n\tif (dir == FORWARD || dir == FORWARD_FILE)\n\t    qf_ptr = get_next_valid_entry(qfl, qf_ptr, &qf_idx, dir);\n\telse\n\t    qf_ptr = get_prev_valid_entry(qfl, qf_ptr, &qf_idx, dir);\n\tif (qf_ptr == NULL)\n\t{\n\t    qf_ptr = prev_qf_ptr;\n\t    qf_idx = prev_index;\n\t    if (err != NULL)\n\t    {\n\t\temsg(_(err));\n\t\treturn NULL;\n\t    }\n\t    break;\n\t}\n\n\terr = NULL;\n    }\n\n    *new_qfidx = qf_idx;\n    return qf_ptr;\n}\n\n/*\n * Get n'th (errornr) quickfix entry from the current entry in the quickfix\n * list 'qfl'. Returns a pointer to the new entry and the index in 'new_qfidx'\n */\n    static qfline_T *\nget_nth_entry(qf_list_T *qfl, int errornr, int *new_qfidx)\n{\n    qfline_T\t*qf_ptr = qfl->qf_ptr;\n    int\t\tqf_idx = qfl->qf_index;\n\n    // New error number is less than the current error number\n    while (errornr < qf_idx && qf_idx > 1 && qf_ptr->qf_prev != NULL)\n    {\n\t--qf_idx;\n\tqf_ptr = qf_ptr->qf_prev;\n    }\n    // New error number is greater than the current error number\n    while (errornr > qf_idx && qf_idx < qfl->qf_count &&\n\t\t\t\t\t\tqf_ptr->qf_next != NULL)\n    {\n\t++qf_idx;\n\tqf_ptr = qf_ptr->qf_next;\n    }\n\n    *new_qfidx = qf_idx;\n    return qf_ptr;\n}\n\n/*\n * Get a entry specified by 'errornr' and 'dir' from the current\n * quickfix/location list. 'errornr' specifies the index of the entry and 'dir'\n * specifies the direction (FORWARD/BACKWARD/FORWARD_FILE/BACKWARD_FILE).\n * Returns a pointer to the entry and the index of the new entry is stored in\n * 'new_qfidx'.\n */\n    static qfline_T *\nqf_get_entry(\n\tqf_list_T\t*qfl,\n\tint\t\terrornr,\n\tint\t\tdir,\n\tint\t\t*new_qfidx)\n{\n    qfline_T\t*qf_ptr = qfl->qf_ptr;\n    int\t\tqfidx = qfl->qf_index;\n\n    if (dir != 0)    // next/prev valid entry\n\tqf_ptr = get_nth_valid_entry(qfl, errornr, dir, &qfidx);\n    else if (errornr != 0)\t// go to specified number\n\tqf_ptr = get_nth_entry(qfl, errornr, &qfidx);\n\n    *new_qfidx = qfidx;\n    return qf_ptr;\n}\n\n/*\n * Find a window displaying a Vim help file in the current tab page.\n */\n    static win_T *\nqf_find_help_win(void)\n{\n    win_T *wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (bt_help(wp->w_buffer))\n\t    return wp;\n\n    return NULL;\n}\n\n/*\n * Set the location list for the specified window to 'qi'.\n */\n    static void\nwin_set_loclist(win_T *wp, qf_info_T *qi)\n{\n    wp->w_llist = qi;\n    qi->qf_refcount++;\n}\n\n/*\n * Find a help window or open one. If 'newwin' is TRUE, then open a new help\n * window.\n */\n    static int\njump_to_help_window(qf_info_T *qi, int newwin, int *opened_window)\n{\n    win_T\t*wp;\n    int\t\tflags;\n\n    if (cmdmod.cmod_tab != 0 || newwin)\n\twp = NULL;\n    else\n\twp = qf_find_help_win();\n    if (wp != NULL && wp->w_buffer->b_nwindows > 0)\n\twin_enter(wp, TRUE);\n    else\n    {\n\t// Split off help window; put it at far top if no position\n\t// specified, the current window is vertically split and narrow.\n\tflags = WSP_HELP;\n\tif (cmdmod.cmod_split == 0 && curwin->w_width != Columns\n\t\t&& curwin->w_width < 80)\n\t    flags |= WSP_TOP;\n\t// If the user asks to open a new window, then copy the location list.\n\t// Otherwise, don't copy the location list.\n\tif (IS_LL_STACK(qi) && !newwin)\n\t    flags |= WSP_NEWLOC;\n\n\tif (win_split(0, flags) == FAIL)\n\t    return FAIL;\n\n\t*opened_window = TRUE;\n\n\tif (curwin->w_height < p_hh)\n\t    win_setheight((int)p_hh);\n\n\t// When using location list, the new window should use the supplied\n\t// location list. If the user asks to open a new window, then the new\n\t// window will get a copy of the location list.\n\tif (IS_LL_STACK(qi) && !newwin)\n\t    win_set_loclist(curwin, qi);\n    }\n\n    if (!p_im)\n\trestart_edit = 0;\t    // don't want insert mode in help file\n\n    return OK;\n}\n\n/*\n * Find a non-quickfix window using the given location list stack in the\n * current tabpage.\n * Returns NULL if a matching window is not found.\n */\n    static win_T *\nqf_find_win_with_loclist(qf_info_T *ll)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_llist == ll && !bt_quickfix(wp->w_buffer))\n\t    return wp;\n\n    return NULL;\n}\n\n/*\n * Find a window containing a normal buffer in the current tab page.\n */\n    static win_T *\nqf_find_win_with_normal_buf(void)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (bt_normal(wp->w_buffer))\n\t    return wp;\n\n    return NULL;\n}\n\n/*\n * Go to a window in any tabpage containing the specified file.  Returns TRUE\n * if successfully jumped to the window. Otherwise returns FALSE.\n */\n    static int\nqf_goto_tabwin_with_file(int fnum)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif (wp->w_buffer->b_fnum == fnum)\n\t{\n\t    goto_tabpage_win(tp, wp);\n\t    return TRUE;\n\t}\n\n    return FALSE;\n}\n\n/*\n * Create a new window to show a file above the quickfix window. Called when\n * only the quickfix window is present.\n */\n    static int\nqf_open_new_file_win(qf_info_T *ll_ref)\n{\n    int\t\tflags;\n\n    flags = WSP_ABOVE;\n    if (ll_ref != NULL)\n\tflags |= WSP_NEWLOC;\n    if (win_split(0, flags) == FAIL)\n\treturn FAIL;\t\t// not enough room for window\n    p_swb = empty_option;\t// don't split again\n    swb_flags = 0;\n    RESET_BINDING(curwin);\n    if (ll_ref != NULL)\n\t// The new window should use the location list from the\n\t// location list window\n\twin_set_loclist(curwin, ll_ref);\n    return OK;\n}\n\n/*\n * Go to a window that shows the right buffer. If the window is not found, go\n * to the window just above the location list window. This is used for opening\n * a file from a location window and not from a quickfix window. If some usable\n * window is previously found, then it is supplied in 'use_win'.\n */\n    static void\nqf_goto_win_with_ll_file(win_T *use_win, int qf_fnum, qf_info_T *ll_ref)\n{\n    win_T\t*win = use_win;\n\n    if (win == NULL)\n    {\n\t// Find the window showing the selected file in the current tab page.\n\tFOR_ALL_WINDOWS(win)\n\t    if (win->w_buffer->b_fnum == qf_fnum)\n\t\tbreak;\n\tif (win == NULL)\n\t{\n\t    // Find a previous usable window\n\t    win = curwin;\n\t    do\n\t    {\n\t\tif (bt_normal(win->w_buffer))\n\t\t    break;\n\t\tif (win->w_prev == NULL)\n\t\t    win = lastwin;\t// wrap around the top\n\t\telse\n\t\t    win = win->w_prev; // go to previous window\n\t    } while (win != curwin);\n\t}\n    }\n    win_goto(win);\n\n    // If the location list for the window is not set, then set it\n    // to the location list from the location window\n    if (win->w_llist == NULL && ll_ref != NULL)\n\twin_set_loclist(win, ll_ref);\n}\n\n/*\n * Go to a window that contains the specified buffer 'qf_fnum'. If a window is\n * not found, then go to the window just above the quickfix window. This is\n * used for opening a file from a quickfix window and not from a location\n * window.\n */\n    static void\nqf_goto_win_with_qfl_file(int qf_fnum)\n{\n    win_T\t*win;\n    win_T\t*altwin;\n\n    win = curwin;\n    altwin = NULL;\n    for (;;)\n    {\n\tif (win->w_buffer->b_fnum == qf_fnum)\n\t    break;\n\tif (win->w_prev == NULL)\n\t    win = lastwin;\t// wrap around the top\n\telse\n\t    win = win->w_prev;\t// go to previous window\n\n\tif (IS_QF_WINDOW(win))\n\t{\n\t    // Didn't find it, go to the window before the quickfix\n\t    // window, unless 'switchbuf' contains 'uselast': in this case we\n\t    // try to jump to the previously used window first.\n\t    if ((swb_flags & SWB_USELAST) && win_valid(prevwin))\n\t\twin = prevwin;\n\t    else if (altwin != NULL)\n\t\twin = altwin;\n\t    else if (curwin->w_prev != NULL)\n\t\twin = curwin->w_prev;\n\t    else\n\t\twin = curwin->w_next;\n\t    break;\n\t}\n\n\t// Remember a usable window.\n\tif (altwin == NULL && !win->w_p_pvw && bt_normal(win->w_buffer))\n\t    altwin = win;\n    }\n\n    win_goto(win);\n}\n\n/*\n * Find a suitable window for opening a file (qf_fnum) from the\n * quickfix/location list and jump to it.  If the file is already opened in a\n * window, jump to it. Otherwise open a new window to display the file. If\n * 'newwin' is TRUE, then always open a new window. This is called from either\n * a quickfix or a location list window.\n */\n    static int\nqf_jump_to_usable_window(int qf_fnum, int newwin, int *opened_window)\n{\n    win_T\t*usable_wp = NULL;\n    int\t\tusable_win = FALSE;\n    qf_info_T\t*ll_ref = NULL;\n\n    // If opening a new window, then don't use the location list referred by\n    // the current window.  Otherwise two windows will refer to the same\n    // location list.\n    if (!newwin)\n\tll_ref = curwin->w_llist_ref;\n\n    if (ll_ref != NULL)\n    {\n\t// Find a non-quickfix window with this location list\n\tusable_wp = qf_find_win_with_loclist(ll_ref);\n\tif (usable_wp != NULL)\n\t    usable_win = TRUE;\n    }\n\n    if (!usable_win)\n    {\n\t// Locate a window showing a normal buffer\n\twin_T\t*win = qf_find_win_with_normal_buf();\n\tif (win != NULL)\n\t    usable_win = TRUE;\n    }\n\n    // If no usable window is found and 'switchbuf' contains \"usetab\"\n    // then search in other tabs.\n    if (!usable_win && (swb_flags & SWB_USETAB))\n\tusable_win = qf_goto_tabwin_with_file(qf_fnum);\n\n    // If there is only one window and it is the quickfix window, create a\n    // new one above the quickfix window.\n    if ((ONE_WINDOW && bt_quickfix(curbuf)) || !usable_win || newwin)\n    {\n\tif (qf_open_new_file_win(ll_ref) != OK)\n\t    return FAIL;\n\t*opened_window = TRUE;\t// close it when fail\n    }\n    else\n    {\n\tif (curwin->w_llist_ref != NULL)\t// In a location window\n\t    qf_goto_win_with_ll_file(usable_wp, qf_fnum, ll_ref);\n\telse\t\t\t\t\t// In a quickfix window\n\t    qf_goto_win_with_qfl_file(qf_fnum);\n    }\n\n    return OK;\n}\n\n/*\n * Edit the selected file or help file.\n * Returns OK if successfully edited the file, FAIL on failing to open the\n * buffer and NOTDONE if the quickfix/location list was freed by an autocmd\n * when opening the buffer.\n */\n    static int\nqf_jump_edit_buffer(\n\tqf_info_T\t*qi,\n\tqfline_T\t*qf_ptr,\n\tint\t\tforceit,\n\tint\t\tprev_winid,\n\tint\t\t*opened_window)\n{\n    qf_list_T\t*qfl = qf_get_curlist(qi);\n    int\t\told_changedtick = qfl->qf_changedtick;\n    qfltype_T\tqfl_type = qfl->qfl_type;\n    int\t\tretval = OK;\n    int\t\told_qf_curlist = qi->qf_curlist;\n    int\t\tsave_qfid = qfl->qf_id;\n\n    if (qf_ptr->qf_type == 1)\n    {\n\t// Open help file (do_ecmd() will set b_help flag, readfile() will\n\t// set b_p_ro flag).\n\tif (!can_abandon(curbuf, forceit))\n\t{\n\t    no_write_message();\n\t    return FAIL;\n\t}\n\n\tretval = do_ecmd(qf_ptr->qf_fnum, NULL, NULL, NULL, (linenr_T)1,\n\t\tECMD_HIDE + ECMD_SET_HELP,\n\t\tprev_winid == curwin->w_id ? curwin : NULL);\n    }\n    else\n\tretval = buflist_getfile(qf_ptr->qf_fnum,\n\t\t(linenr_T)1, GETF_SETMARK | GETF_SWITCH, forceit);\n\n    // If a location list, check whether the associated window is still\n    // present.\n    if (qfl_type == QFLT_LOCATION)\n    {\n\twin_T\t*wp = win_id2wp(prev_winid);\n\n\tif (wp == NULL && curwin->w_llist != qi)\n\t{\n\t    emsg(_(e_current_window_was_closed));\n\t    *opened_window = FALSE;\n\t    return NOTDONE;\n\t}\n    }\n\n    if (qfl_type == QFLT_QUICKFIX && !qflist_valid(NULL, save_qfid))\n    {\n\temsg(_(e_current_quickfix_list_was_changed));\n\treturn NOTDONE;\n    }\n\n    // Check if the list was changed.  The pointers may happen to be identical,\n    // thus also check qf_changedtick.\n    if (old_qf_curlist != qi->qf_curlist\n\t    || old_changedtick != qfl->qf_changedtick\n\t    || !is_qf_entry_present(qfl, qf_ptr))\n    {\n\tif (qfl_type == QFLT_QUICKFIX)\n\t    emsg(_(e_current_quickfix_list_was_changed));\n\telse\n\t    emsg(_(e_current_location_list_was_changed));\n\treturn NOTDONE;\n    }\n\n    return retval;\n}\n\n/*\n * Go to the error line in the current file using either line/column number or\n * a search pattern.\n */\n    static void\nqf_jump_goto_line(\n\tlinenr_T\tqf_lnum,\n\tint\t\tqf_col,\n\tchar_u\t\tqf_viscol,\n\tchar_u\t\t*qf_pattern)\n{\n    linenr_T\t\ti;\n\n    if (qf_pattern == NULL)\n    {\n\t// Go to line with error, unless qf_lnum is 0.\n\ti = qf_lnum;\n\tif (i > 0)\n\t{\n\t    if (i > curbuf->b_ml.ml_line_count)\n\t\ti = curbuf->b_ml.ml_line_count;\n\t    curwin->w_cursor.lnum = i;\n\t}\n\tif (qf_col > 0)\n\t{\n\t    curwin->w_cursor.coladd = 0;\n\t    if (qf_viscol == TRUE)\n\t\tcoladvance(qf_col - 1);\n\t    else\n\t\tcurwin->w_cursor.col = qf_col - 1;\n\t    curwin->w_set_curswant = TRUE;\n\t    check_cursor();\n\t}\n\telse\n\t    beginline(BL_WHITE | BL_FIX);\n    }\n    else\n    {\n\tpos_T save_cursor;\n\n\t// Move the cursor to the first line in the buffer\n\tsave_cursor = curwin->w_cursor;\n\tcurwin->w_cursor.lnum = 0;\n\tif (!do_search(NULL, '/', '/', qf_pattern, (long)1, SEARCH_KEEP, NULL))\n\t    curwin->w_cursor = save_cursor;\n    }\n}\n\n/*\n * Display quickfix list index and size message\n */\n    static void\nqf_jump_print_msg(\n\tqf_info_T\t*qi,\n\tint\t\tqf_index,\n\tqfline_T\t*qf_ptr,\n\tbuf_T\t\t*old_curbuf,\n\tlinenr_T\told_lnum)\n{\n    linenr_T\t\ti;\n    int\t\t\tlen;\n\n    // Update the screen before showing the message, unless the screen\n    // scrolled up.\n    if (!msg_scrolled)\n\tupdate_topline_redraw();\n    sprintf((char *)IObuff, _(\"(%d of %d)%s%s: \"), qf_index,\n\t    qf_get_curlist(qi)->qf_count,\n\t    qf_ptr->qf_cleared ? _(\" (line deleted)\") : \"\",\n\t    (char *)qf_types(qf_ptr->qf_type, qf_ptr->qf_nr));\n    // Add the message, skipping leading whitespace and newlines.\n    len = (int)STRLEN(IObuff);\n    qf_fmt_text(skipwhite(qf_ptr->qf_text), IObuff + len, IOSIZE - len);\n\n    // Output the message.  Overwrite to avoid scrolling when the 'O'\n    // flag is present in 'shortmess'; But when not jumping, print the\n    // whole message.\n    i = msg_scroll;\n    if (curbuf == old_curbuf && curwin->w_cursor.lnum == old_lnum)\n\tmsg_scroll = TRUE;\n    else if (!msg_scrolled && shortmess(SHM_OVERALL))\n\tmsg_scroll = FALSE;\n    msg_attr_keep((char *)IObuff, 0, TRUE);\n    msg_scroll = i;\n}\n\n/*\n * Find a usable window for opening a file from the quickfix/location list. If\n * a window is not found then open a new window. If 'newwin' is TRUE, then open\n * a new window.\n * Returns OK if successfully jumped or opened a window. Returns FAIL if not\n * able to jump/open a window.  Returns NOTDONE if a file is not associated\n * with the entry.\n */\n    static int\nqf_jump_open_window(\n\tqf_info_T\t*qi,\n\tqfline_T\t*qf_ptr,\n\tint\t\tnewwin,\n\tint\t\t*opened_window)\n{\n    qf_list_T\t*qfl = qf_get_curlist(qi);\n    int\t\told_changedtick = qfl->qf_changedtick;\n    int\t\told_qf_curlist = qi->qf_curlist;\n    qfltype_T\tqfl_type = qfl->qfl_type;\n\n    // For \":helpgrep\" find a help window or open one.\n    if (qf_ptr->qf_type == 1 && (!bt_help(curwin->w_buffer)\n\t\t\t\t\t\t      || cmdmod.cmod_tab != 0))\n\tif (jump_to_help_window(qi, newwin, opened_window) == FAIL)\n\t    return FAIL;\n    if (old_qf_curlist != qi->qf_curlist\n\t    || old_changedtick != qfl->qf_changedtick\n\t    || !is_qf_entry_present(qfl, qf_ptr))\n    {\n\tif (qfl_type == QFLT_QUICKFIX)\n\t    emsg(_(e_current_quickfix_list_was_changed));\n\telse\n\t    emsg(_(e_current_location_list_was_changed));\n\treturn FAIL;\n    }\n\n    // If currently in the quickfix window, find another window to show the\n    // file in.\n    if (bt_quickfix(curbuf) && !*opened_window)\n    {\n\t// If there is no file specified, we don't know where to go.\n\t// But do advance, otherwise \":cn\" gets stuck.\n\tif (qf_ptr->qf_fnum == 0)\n\t    return NOTDONE;\n\n\tif (qf_jump_to_usable_window(qf_ptr->qf_fnum, newwin,\n\t\t\t\t\t\topened_window) == FAIL)\n\t    return FAIL;\n    }\n    if (old_qf_curlist != qi->qf_curlist\n\t    || old_changedtick != qfl->qf_changedtick\n\t    || !is_qf_entry_present(qfl, qf_ptr))\n    {\n\tif (qfl_type == QFLT_QUICKFIX)\n\t    emsg(_(e_current_quickfix_list_was_changed));\n\telse\n\t    emsg(_(e_current_location_list_was_changed));\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * Edit a selected file from the quickfix/location list and jump to a\n * particular line/column, adjust the folds and display a message about the\n * jump.\n * Returns OK on success and FAIL on failing to open the file/buffer.  Returns\n * NOTDONE if the quickfix/location list is freed by an autocmd when opening\n * the file.\n */\n    static int\nqf_jump_to_buffer(\n\tqf_info_T\t*qi,\n\tint\t\tqf_index,\n\tqfline_T\t*qf_ptr,\n\tint\t\tforceit,\n\tint\t\tprev_winid,\n\tint\t\t*opened_window,\n\tint\t\topenfold,\n\tint\t\tprint_message)\n{\n    buf_T\t*old_curbuf;\n    linenr_T\told_lnum;\n    int\t\tretval = OK;\n\n    // If there is a file name, read the wanted file if needed, and check\n    // autowrite etc.\n    old_curbuf = curbuf;\n    old_lnum = curwin->w_cursor.lnum;\n\n    if (qf_ptr->qf_fnum != 0)\n    {\n\tretval = qf_jump_edit_buffer(qi, qf_ptr, forceit, prev_winid,\n\t\t\t\t\t\topened_window);\n\tif (retval != OK)\n\t    return retval;\n    }\n\n    // When not switched to another buffer, still need to set pc mark\n    if (curbuf == old_curbuf)\n\tsetpcmark();\n\n    qf_jump_goto_line(qf_ptr->qf_lnum, qf_ptr->qf_col, qf_ptr->qf_viscol,\n\t    qf_ptr->qf_pattern);\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_QUICKFIX) && openfold)\n\tfoldOpenCursor();\n#endif\n    if (print_message)\n\tqf_jump_print_msg(qi, qf_index, qf_ptr, old_curbuf, old_lnum);\n\n    return retval;\n}\n\n/*\n * Jump to a quickfix line and try to use an existing window.\n */\n    void\nqf_jump(qf_info_T\t*qi,\n\tint\t\tdir,\n\tint\t\terrornr,\n\tint\t\tforceit)\n{\n    qf_jump_newwin(qi, dir, errornr, forceit, FALSE);\n}\n\n/*\n * Jump to a quickfix line.\n * If dir == 0 go to entry \"errornr\".\n * If dir == FORWARD go \"errornr\" valid entries forward.\n * If dir == BACKWARD go \"errornr\" valid entries backward.\n * If dir == FORWARD_FILE go \"errornr\" valid entries files backward.\n * If dir == BACKWARD_FILE go \"errornr\" valid entries files backward\n * else if \"errornr\" is zero, redisplay the same line\n * If 'forceit' is TRUE, then can discard changes to the current buffer.\n * If 'newwin' is TRUE, then open the file in a new window.\n */\n    static void\nqf_jump_newwin(qf_info_T\t*qi,\n\tint\t\tdir,\n\tint\t\terrornr,\n\tint\t\tforceit,\n\tint\t\tnewwin)\n{\n    qf_list_T\t\t*qfl;\n    qfline_T\t\t*qf_ptr;\n    qfline_T\t\t*old_qf_ptr;\n    int\t\t\tqf_index;\n    int\t\t\told_qf_index;\n    char_u\t\t*old_swb = p_swb;\n    unsigned\t\told_swb_flags = swb_flags;\n    int\t\t\tprev_winid;\n    int\t\t\topened_window = FALSE;\n    int\t\t\tprint_message = TRUE;\n    int\t\t\told_KeyTyped = KeyTyped; // getting file may reset it\n    int\t\t\tretval = OK;\n\n    if (qi == NULL)\n\tqi = &ql_info;\n\n    if (qf_stack_empty(qi) || qf_list_empty(qf_get_curlist(qi)))\n    {\n\temsg(_(e_no_errors));\n\treturn;\n    }\n\n    incr_quickfix_busy();\n\n    qfl = qf_get_curlist(qi);\n\n    qf_ptr = qfl->qf_ptr;\n    old_qf_ptr = qf_ptr;\n    qf_index = qfl->qf_index;\n    old_qf_index = qf_index;\n\n    qf_ptr = qf_get_entry(qfl, errornr, dir, &qf_index);\n    if (qf_ptr == NULL)\n    {\n\tqf_ptr = old_qf_ptr;\n\tqf_index = old_qf_index;\n\tgoto theend;\n    }\n\n    qfl->qf_index = qf_index;\n    qfl->qf_ptr = qf_ptr;\n    if (qf_win_pos_update(qi, old_qf_index))\n\t// No need to print the error message if it's visible in the error\n\t// window\n\tprint_message = FALSE;\n\n    prev_winid = curwin->w_id;\n\n    retval = qf_jump_open_window(qi, qf_ptr, newwin, &opened_window);\n    if (retval == FAIL)\n\tgoto failed;\n    if (retval == NOTDONE)\n\tgoto theend;\n\n    retval = qf_jump_to_buffer(qi, qf_index, qf_ptr, forceit, prev_winid,\n\t\t\t\t  &opened_window, old_KeyTyped, print_message);\n    if (retval == NOTDONE)\n    {\n\t// Quickfix/location list is freed by an autocmd\n\tqi = NULL;\n\tqf_ptr = NULL;\n    }\n\n    if (retval != OK)\n    {\n\tif (opened_window)\n\t    win_close(curwin, TRUE);    // Close opened window\n\tif (qf_ptr != NULL && qf_ptr->qf_fnum != 0)\n\t{\n\t    // Couldn't open file, so put index back where it was.  This could\n\t    // happen if the file was readonly and we changed something.\nfailed:\n\t    qf_ptr = old_qf_ptr;\n\t    qf_index = old_qf_index;\n\t}\n    }\ntheend:\n    if (qi != NULL)\n    {\n\tqfl->qf_ptr = qf_ptr;\n\tqfl->qf_index = qf_index;\n    }\n    if (p_swb != old_swb && p_swb == empty_option)\n    {\n\t// Restore old 'switchbuf' value, but not when an autocommand or\n\t// modeline has changed the value.\n\tp_swb = old_swb;\n\tswb_flags = old_swb_flags;\n    }\n    decr_quickfix_busy();\n}\n\n// Highlight attributes used for displaying entries from the quickfix list.\nstatic int\tqfFileAttr;\nstatic int\tqfSepAttr;\nstatic int\tqfLineAttr;\n\n/*\n * Display information about a single entry from the quickfix/location list.\n * Used by \":clist/:llist\" commands.\n * 'cursel' will be set to TRUE for the currently selected entry in the\n * quickfix list.\n */\n    static void\nqf_list_entry(qfline_T *qfp, int qf_idx, int cursel)\n{\n    char_u\t*fname;\n    buf_T\t*buf;\n    int\t\tfilter_entry;\n\n    fname = NULL;\n    if (qfp->qf_module != NULL && *qfp->qf_module != NUL)\n\tvim_snprintf((char *)IObuff, IOSIZE, \"%2d %s\", qf_idx,\n\t\t\t\t\t\t(char *)qfp->qf_module);\n    else {\n\tif (qfp->qf_fnum != 0\n\t\t&& (buf = buflist_findnr(qfp->qf_fnum)) != NULL)\n\t{\n\t    fname = buf->b_fname;\n\t    if (qfp->qf_type == 1)\t// :helpgrep\n\t\tfname = gettail(fname);\n\t}\n\tif (fname == NULL)\n\t    sprintf((char *)IObuff, \"%2d\", qf_idx);\n\telse\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%2d %s\",\n\t\t    qf_idx, (char *)fname);\n    }\n\n    // Support for filtering entries using :filter /pat/ clist\n    // Match against the module name, file name, search pattern and\n    // text of the entry.\n    filter_entry = TRUE;\n    if (qfp->qf_module != NULL && *qfp->qf_module != NUL)\n\tfilter_entry &= message_filtered(qfp->qf_module);\n    if (filter_entry && fname != NULL)\n\tfilter_entry &= message_filtered(fname);\n    if (filter_entry && qfp->qf_pattern != NULL)\n\tfilter_entry &= message_filtered(qfp->qf_pattern);\n    if (filter_entry)\n\tfilter_entry &= message_filtered(qfp->qf_text);\n    if (filter_entry)\n\treturn;\n\n    msg_putchar('\\n');\n    msg_outtrans_attr(IObuff, cursel ? HL_ATTR(HLF_QFL) : qfFileAttr);\n\n    if (qfp->qf_lnum != 0)\n\tmsg_puts_attr(\":\", qfSepAttr);\n    if (qfp->qf_lnum == 0)\n\tIObuff[0] = NUL;\n    else\n\tqf_range_text(qfp, IObuff, IOSIZE);\n    sprintf((char *)IObuff + STRLEN(IObuff), \"%s\",\n\t    (char *)qf_types(qfp->qf_type, qfp->qf_nr));\n    msg_puts_attr((char *)IObuff, qfLineAttr);\n    msg_puts_attr(\":\", qfSepAttr);\n    if (qfp->qf_pattern != NULL)\n    {\n\tqf_fmt_text(qfp->qf_pattern, IObuff, IOSIZE);\n\tmsg_puts((char *)IObuff);\n\tmsg_puts_attr(\":\", qfSepAttr);\n    }\n    msg_puts(\" \");\n\n    {\n\tchar_u *tbuf = IObuff;\n\tsize_t\ttbuflen = IOSIZE;\n\tsize_t\tlen = STRLEN(qfp->qf_text) + 3;\n\n\tif (len > IOSIZE)\n\t{\n\t    tbuf = alloc(len);\n\t    if (tbuf != NULL)\n\t\ttbuflen = len;\n\t    else\n\t\ttbuf = IObuff;\n\t}\n\n\t// Remove newlines and leading whitespace from the text.  For an\n\t// unrecognized line keep the indent, the compiler may mark a word\n\t// with ^^^^.\n\tqf_fmt_text((fname != NULL || qfp->qf_lnum != 0)\n\t\t\t\t    ? skipwhite(qfp->qf_text) : qfp->qf_text,\n\t\t\t\t    tbuf, (int)tbuflen);\n\tmsg_prt_line(tbuf, FALSE);\n\n\tif (tbuf != IObuff)\n\t    vim_free(tbuf);\n    }\n    out_flush();\t\t// show one line at a time\n}\n\n/*\n * \":clist\": list all errors\n * \":llist\": list all locations\n */\n    void\nqf_list(exarg_T *eap)\n{\n    qf_list_T\t*qfl;\n    qfline_T\t*qfp;\n    int\t\ti;\n    int\t\tidx1 = 1;\n    int\t\tidx2 = -1;\n    char_u\t*arg = eap->arg;\n    int\t\tplus = FALSE;\n    int\t\tall = eap->forceit;\t// if not :cl!, only show\n\t\t\t\t\t// recognised errors\n    qf_info_T\t*qi;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    if (qf_stack_empty(qi) || qf_list_empty(qf_get_curlist(qi)))\n    {\n\temsg(_(e_no_errors));\n\treturn;\n    }\n    if (*arg == '+')\n    {\n\t++arg;\n\tplus = TRUE;\n    }\n    if (!get_list_range(&arg, &idx1, &idx2) || *arg != NUL)\n    {\n\tsemsg(_(e_trailing_characters_str), arg);\n\treturn;\n    }\n    qfl = qf_get_curlist(qi);\n    if (plus)\n    {\n\ti = qfl->qf_index;\n\tidx2 = i + idx1;\n\tidx1 = i;\n    }\n    else\n    {\n\ti = qfl->qf_count;\n\tif (idx1 < 0)\n\t    idx1 = (-idx1 > i) ? 0 : idx1 + i + 1;\n\tif (idx2 < 0)\n\t    idx2 = (-idx2 > i) ? 0 : idx2 + i + 1;\n    }\n\n    // Shorten all the file names, so that it is easy to read\n    shorten_fnames(FALSE);\n\n    // Get the attributes for the different quickfix highlight items.  Note\n    // that this depends on syntax items defined in the qf.vim syntax file\n    qfFileAttr = syn_name2attr((char_u *)\"qfFileName\");\n    if (qfFileAttr == 0)\n\tqfFileAttr = HL_ATTR(HLF_D);\n    qfSepAttr = syn_name2attr((char_u *)\"qfSeparator\");\n    if (qfSepAttr == 0)\n\tqfSepAttr = HL_ATTR(HLF_D);\n    qfLineAttr = syn_name2attr((char_u *)\"qfLineNr\");\n    if (qfLineAttr == 0)\n\tqfLineAttr = HL_ATTR(HLF_N);\n\n    if (qfl->qf_nonevalid)\n\tall = TRUE;\n    FOR_ALL_QFL_ITEMS(qfl, qfp, i)\n    {\n\tif ((qfp->qf_valid || all) && idx1 <= i && i <= idx2)\n\t    qf_list_entry(qfp, i, i == qfl->qf_index);\n\n\tui_breakcheck();\n    }\n}\n\n/*\n * Remove newlines and leading whitespace from an error message.\n * Put the result in \"buf[bufsize]\".\n */\n    static void\nqf_fmt_text(char_u *text, char_u *buf, int bufsize)\n{\n    int\t\ti;\n    char_u\t*p = text;\n\n    for (i = 0; *p != NUL && i < bufsize - 1; ++i)\n    {\n\tif (*p == '\\n')\n\t{\n\t    buf[i] = ' ';\n\t    while (*++p != NUL)\n\t\tif (!VIM_ISWHITE(*p) && *p != '\\n')\n\t\t    break;\n\t}\n\telse\n\t    buf[i] = *p++;\n    }\n    buf[i] = NUL;\n}\n\n/*\n * Range information from lnum, col, end_lnum, and end_col.\n * Put the result in \"buf[bufsize]\".\n */\n    static void\nqf_range_text(qfline_T *qfp, char_u *buf, int bufsize)\n{\n    int len;\n    vim_snprintf((char *)buf, bufsize, \"%ld\", qfp->qf_lnum);\n    len = (int)STRLEN(buf);\n\n    if (qfp->qf_end_lnum > 0 && qfp->qf_lnum != qfp->qf_end_lnum)\n    {\n\tvim_snprintf((char *)buf + len, bufsize - len,\n\t\t\"-%ld\", qfp->qf_end_lnum);\n\tlen += (int)STRLEN(buf + len);\n    }\n    if (qfp->qf_col > 0)\n    {\n\tvim_snprintf((char *)buf + len, bufsize - len, \" col %d\", qfp->qf_col);\n\tlen += (int)STRLEN(buf + len);\n\tif (qfp->qf_end_col > 0 && qfp->qf_col != qfp->qf_end_col)\n\t{\n\t    vim_snprintf((char *)buf + len, bufsize - len,\n\t\t    \"-%d\", qfp->qf_end_col);\n\t    len += (int)STRLEN(buf + len);\n\t}\n    }\n    buf[len] = NUL;\n}\n\n/*\n * Display information (list number, list size and the title) about a\n * quickfix/location list.\n */\n    static void\nqf_msg(qf_info_T *qi, int which, char *lead)\n{\n    char   *title = (char *)qi->qf_lists[which].qf_title;\n    int    count = qi->qf_lists[which].qf_count;\n    char_u buf[IOSIZE];\n\n    vim_snprintf((char *)buf, IOSIZE, _(\"%serror list %d of %d; %d errors \"),\n\t    lead,\n\t    which + 1,\n\t    qi->qf_listcount,\n\t    count);\n\n    if (title != NULL)\n    {\n\tsize_t\tlen = STRLEN(buf);\n\n\tif (len < 34)\n\t{\n\t    vim_memset(buf + len, ' ', 34 - len);\n\t    buf[34] = NUL;\n\t}\n\tvim_strcat(buf, (char_u *)title, IOSIZE);\n    }\n    trunc_string(buf, buf, Columns - 1, IOSIZE);\n    msg((char *)buf);\n}\n\n/*\n * \":colder [count]\": Up in the quickfix stack.\n * \":cnewer [count]\": Down in the quickfix stack.\n * \":lolder [count]\": Up in the location list stack.\n * \":lnewer [count]\": Down in the location list stack.\n */\n    void\nqf_age(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    int\t\tcount;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    if (eap->addr_count != 0)\n\tcount = eap->line2;\n    else\n\tcount = 1;\n    while (count--)\n    {\n\tif (eap->cmdidx == CMD_colder || eap->cmdidx == CMD_lolder)\n\t{\n\t    if (qi->qf_curlist == 0)\n\t    {\n\t\temsg(_(e_at_bottom_of_quickfix_stack));\n\t\tbreak;\n\t    }\n\t    --qi->qf_curlist;\n\t}\n\telse\n\t{\n\t    if (qi->qf_curlist >= qi->qf_listcount - 1)\n\t    {\n\t\temsg(_(e_at_top_of_quickfix_stack));\n\t\tbreak;\n\t    }\n\t    ++qi->qf_curlist;\n\t}\n    }\n    qf_msg(qi, qi->qf_curlist, \"\");\n    qf_update_buffer(qi, NULL);\n}\n\n/*\n * Display the information about all the quickfix/location lists in the stack\n */\n    void\nqf_history(exarg_T *eap)\n{\n    qf_info_T\t*qi = qf_cmd_get_stack(eap, FALSE);\n    int\t\ti;\n\n    if (eap->addr_count > 0)\n    {\n\tif (qi == NULL)\n\t{\n\t    emsg(_(e_no_location_list));\n\t    return;\n\t}\n\n\t// Jump to the specified quickfix list\n\tif (eap->line2 > 0 && eap->line2 <= qi->qf_listcount)\n\t{\n\t    qi->qf_curlist = eap->line2 - 1;\n\t    qf_msg(qi, qi->qf_curlist, \"\");\n\t    qf_update_buffer(qi, NULL);\n\t}\n\telse\n\t    emsg(_(e_invalid_range));\n\n\treturn;\n    }\n\n    if (qf_stack_empty(qi))\n\tmsg(_(\"No entries\"));\n    else\n\tfor (i = 0; i < qi->qf_listcount; ++i)\n\t    qf_msg(qi, i, i == qi->qf_curlist ? \"> \" : \"  \");\n}\n\n/*\n * Free all the entries in the error list \"idx\". Note that other information\n * associated with the list like context and title are not freed.\n */\n    static void\nqf_free_items(qf_list_T *qfl)\n{\n    qfline_T\t*qfp;\n    qfline_T\t*qfpnext;\n    int\t\tstop = FALSE;\n\n    while (qfl->qf_count && qfl->qf_start != NULL)\n    {\n\tqfp = qfl->qf_start;\n\tqfpnext = qfp->qf_next;\n\tif (!stop)\n\t{\n\t    vim_free(qfp->qf_module);\n\t    vim_free(qfp->qf_text);\n\t    vim_free(qfp->qf_pattern);\n\t    stop = (qfp == qfpnext);\n\t    vim_free(qfp);\n\t    if (stop)\n\t\t// Somehow qf_count may have an incorrect value, set it to 1\n\t\t// to avoid crashing when it's wrong.\n\t\t// TODO: Avoid qf_count being incorrect.\n\t\tqfl->qf_count = 1;\n\t}\n\tqfl->qf_start = qfpnext;\n\t--qfl->qf_count;\n    }\n\n    qfl->qf_index = 0;\n    qfl->qf_start = NULL;\n    qfl->qf_last = NULL;\n    qfl->qf_ptr = NULL;\n    qfl->qf_nonevalid = TRUE;\n\n    qf_clean_dir_stack(&qfl->qf_dir_stack);\n    qfl->qf_directory = NULL;\n    qf_clean_dir_stack(&qfl->qf_file_stack);\n    qfl->qf_currfile = NULL;\n    qfl->qf_multiline = FALSE;\n    qfl->qf_multiignore = FALSE;\n    qfl->qf_multiscan = FALSE;\n}\n\n/*\n * Free error list \"idx\". Frees all the entries in the quickfix list,\n * associated context information and the title.\n */\n    static void\nqf_free(qf_list_T *qfl)\n{\n    qf_free_items(qfl);\n\n    VIM_CLEAR(qfl->qf_title);\n    free_tv(qfl->qf_ctx);\n    qfl->qf_ctx = NULL;\n    free_callback(&qfl->qf_qftf_cb);\n    qfl->qf_id = 0;\n    qfl->qf_changedtick = 0L;\n}\n\n/*\n * qf_mark_adjust: adjust marks\n */\n   void\nqf_mark_adjust(\n\twin_T\t*wp,\n\tlinenr_T\tline1,\n\tlinenr_T\tline2,\n\tlong\tamount,\n\tlong\tamount_after)\n{\n    int\t\ti;\n    qfline_T\t*qfp;\n    int\t\tidx;\n    qf_info_T\t*qi = &ql_info;\n    int\t\tfound_one = FALSE;\n    int\t\tbuf_has_flag = wp == NULL ? BUF_HAS_QF_ENTRY : BUF_HAS_LL_ENTRY;\n\n    if (!(curbuf->b_has_qf_entry & buf_has_flag))\n\treturn;\n    if (wp != NULL)\n    {\n\tif (wp->w_llist == NULL)\n\t    return;\n\tqi = wp->w_llist;\n    }\n\n    for (idx = 0; idx < qi->qf_listcount; ++idx)\n    {\n\tqf_list_T\t*qfl = qf_get_list(qi, idx);\n\n\tif (!qf_list_empty(qfl))\n\t    FOR_ALL_QFL_ITEMS(qfl, qfp, i)\n\t\tif (qfp->qf_fnum == curbuf->b_fnum)\n\t\t{\n\t\t    found_one = TRUE;\n\t\t    if (qfp->qf_lnum >= line1 && qfp->qf_lnum <= line2)\n\t\t    {\n\t\t\tif (amount == MAXLNUM)\n\t\t\t    qfp->qf_cleared = TRUE;\n\t\t\telse\n\t\t\t    qfp->qf_lnum += amount;\n\t\t    }\n\t\t    else if (amount_after && qfp->qf_lnum > line2)\n\t\t\tqfp->qf_lnum += amount_after;\n\t\t}\n    }\n\n    if (!found_one)\n\tcurbuf->b_has_qf_entry &= ~buf_has_flag;\n}\n\n/*\n * Make a nice message out of the error character and the error number:\n *  char    number\tmessage\n *  e or E    0\t\t\" error\"\n *  w or W    0\t\t\" warning\"\n *  i or I    0\t\t\" info\"\n *  n or N    0\t\t\" note\"\n *  0\t      0\t\t\"\"\n *  other     0\t\t\" c\"\n *  e or E    n\t\t\" error n\"\n *  w or W    n\t\t\" warning n\"\n *  i or I    n\t\t\" info n\"\n *  n or N    n\t\t\" note n\"\n *  0\t      n\t\t\" error n\"\n *  other     n\t\t\" c n\"\n *  1\t      x\t\t\"\"\t:helpgrep\n */\n    static char_u *\nqf_types(int c, int nr)\n{\n    static char_u\tbuf[20];\n    static char_u\tcc[3];\n    char_u\t\t*p;\n\n    if (c == 'W' || c == 'w')\n\tp = (char_u *)\" warning\";\n    else if (c == 'I' || c == 'i')\n\tp = (char_u *)\" info\";\n    else if (c == 'N' || c == 'n')\n\tp = (char_u *)\" note\";\n    else if (c == 'E' || c == 'e' || (c == 0 && nr > 0))\n\tp = (char_u *)\" error\";\n    else if (c == 0 || c == 1)\n\tp = (char_u *)\"\";\n    else\n    {\n\tcc[0] = ' ';\n\tcc[1] = c;\n\tcc[2] = NUL;\n\tp = cc;\n    }\n\n    if (nr <= 0)\n\treturn p;\n\n    sprintf((char *)buf, \"%s %3d\", (char *)p, nr);\n    return buf;\n}\n\n/*\n * When \"split\" is FALSE: Open the entry/result under the cursor.\n * When \"split\" is TRUE: Open the entry/result under the cursor in a new window.\n */\n    void\nqf_view_result(int split)\n{\n    qf_info_T   *qi = &ql_info;\n\n    if (IS_LL_WINDOW(curwin))\n\tqi = GET_LOC_LIST(curwin);\n\n    if (qf_list_empty(qf_get_curlist(qi)))\n    {\n\temsg(_(e_no_errors));\n\treturn;\n    }\n\n    if (split)\n    {\n\t// Open the selected entry in a new window\n\tqf_jump_newwin(qi, 0, (long)curwin->w_cursor.lnum, FALSE, TRUE);\n\tdo_cmdline_cmd((char_u *) \"clearjumps\");\n\treturn;\n    }\n\n    do_cmdline_cmd((char_u *)(IS_LL_WINDOW(curwin) ? \".ll\" : \".cc\"));\n}\n\n/*\n * \":cwindow\": open the quickfix window if we have errors to display,\n *\t       close it if not.\n * \":lwindow\": open the location list window if we have locations to display,\n *\t       close it if not.\n */\n    void\nex_cwindow(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    qf_list_T\t*qfl;\n    win_T\t*win;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    qfl = qf_get_curlist(qi);\n\n    // Look for an existing quickfix window.\n    win = qf_find_win(qi);\n\n    // If a quickfix window is open but we have no errors to display,\n    // close the window.  If a quickfix window is not open, then open\n    // it if we have errors; otherwise, leave it closed.\n    if (qf_stack_empty(qi)\n\t    || qfl->qf_nonevalid\n\t    || qf_list_empty(qfl))\n    {\n\tif (win != NULL)\n\t    ex_cclose(eap);\n    }\n    else if (win == NULL)\n\tex_copen(eap);\n}\n\n/*\n * \":cclose\": close the window showing the list of errors.\n * \":lclose\": close the window showing the location list\n */\n    void\nex_cclose(exarg_T *eap)\n{\n    win_T\t*win = NULL;\n    qf_info_T\t*qi;\n\n    if ((qi = qf_cmd_get_stack(eap, FALSE)) == NULL)\n\treturn;\n\n    // Find existing quickfix window and close it.\n    win = qf_find_win(qi);\n    if (win != NULL)\n\twin_close(win, FALSE);\n}\n\n/*\n * Set \"w:quickfix_title\" if \"qi\" has a title.\n */\n    static void\nqf_set_title_var(qf_list_T *qfl)\n{\n    if (qfl->qf_title != NULL)\n\tset_internal_string_var((char_u *)\"w:quickfix_title\", qfl->qf_title);\n}\n\n/*\n * Goto a quickfix or location list window (if present).\n * Returns OK if the window is found, FAIL otherwise.\n */\n    static int\nqf_goto_cwindow(qf_info_T *qi, int resize, int sz, int vertsplit)\n{\n    win_T\t*win;\n\n    win = qf_find_win(qi);\n    if (win == NULL)\n\treturn FAIL;\n\n    win_goto(win);\n    if (resize)\n    {\n\tif (vertsplit)\n\t{\n\t    if (sz != win->w_width)\n\t\twin_setwidth(sz);\n\t}\n\telse if (sz != win->w_height && win->w_height\n\t\t       + win->w_status_height + tabline_height() < cmdline_row)\n\t    win_setheight(sz);\n    }\n\n    return OK;\n}\n\n/*\n * Set options for the buffer in the quickfix or location list window.\n */\n    static void\nqf_set_cwindow_options(void)\n{\n    // switch off 'swapfile'\n    set_option_value_give_err((char_u *)\"swf\", 0L, NULL, OPT_LOCAL);\n    set_option_value_give_err((char_u *)\"bt\",\n\t\t\t\t\t  0L, (char_u *)\"quickfix\", OPT_LOCAL);\n    set_option_value_give_err((char_u *)\"bh\", 0L, (char_u *)\"hide\", OPT_LOCAL);\n    RESET_BINDING(curwin);\n#ifdef FEAT_DIFF\n    curwin->w_p_diff = FALSE;\n#endif\n#ifdef FEAT_FOLDING\n    set_option_value_give_err((char_u *)\"fdm\", 0L, (char_u *)\"manual\",\n\t    OPT_LOCAL);\n#endif\n}\n\n/*\n * Open a new quickfix or location list window, load the quickfix buffer and\n * set the appropriate options for the window.\n * Returns FAIL if the window could not be opened.\n */\n    static int\nqf_open_new_cwindow(qf_info_T *qi, int height)\n{\n    buf_T\t*qf_buf;\n    win_T\t*oldwin = curwin;\n    tabpage_T\t*prevtab = curtab;\n    int\t\tflags = 0;\n    win_T\t*win;\n\n    qf_buf = qf_find_buf(qi);\n\n    // The current window becomes the previous window afterwards.\n    win = curwin;\n\n    if (IS_QF_STACK(qi) && cmdmod.cmod_split == 0)\n\t// Create the new quickfix window at the very bottom, except when\n\t// :belowright or :aboveleft is used.\n\twin_goto(lastwin);\n    // Default is to open the window below the current window\n    if (cmdmod.cmod_split == 0)\n\tflags = WSP_BELOW;\n    flags |= WSP_NEWLOC;\n    if (win_split(height, flags) == FAIL)\n\treturn FAIL;\t\t// not enough room for window\n    RESET_BINDING(curwin);\n\n    if (IS_LL_STACK(qi))\n    {\n\t// For the location list window, create a reference to the\n\t// location list stack from the window 'win'.\n\tcurwin->w_llist_ref = qi;\n\tqi->qf_refcount++;\n    }\n\n    if (oldwin != curwin)\n\toldwin = NULL;  // don't store info when in another window\n    if (qf_buf != NULL)\n    {\n\t// Use the existing quickfix buffer\n\tif (do_ecmd(qf_buf->b_fnum, NULL, NULL, NULL, ECMD_ONE,\n\t\t    ECMD_HIDE + ECMD_OLDBUF + ECMD_NOWINENTER, oldwin) == FAIL)\n\t    return FAIL;\n    }\n    else\n    {\n\t// Create a new quickfix buffer\n\tif (do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE + ECMD_NOWINENTER,\n\t\t\t\t\t\t\t       oldwin) == FAIL)\n\t    return FAIL;\n\n\t// save the number of the new buffer\n\tqi->qf_bufnr = curbuf->b_fnum;\n    }\n\n    // Set the options for the quickfix buffer/window (if not already done)\n    // Do this even if the quickfix buffer was already present, as an autocmd\n    // might have previously deleted (:bdelete) the quickfix buffer.\n    if (!bt_quickfix(curbuf))\n\tqf_set_cwindow_options();\n\n    // Only set the height when still in the same tab page and there is no\n    // window to the side.\n    if (curtab == prevtab && curwin->w_width == Columns)\n\twin_setheight(height);\n    curwin->w_p_wfh = TRUE;\t    // set 'winfixheight'\n    if (win_valid(win))\n\tprevwin = win;\n\n    return OK;\n}\n\n/*\n * \":copen\": open a window that shows the list of errors.\n * \":lopen\": open a window that shows the location list.\n */\n    void\nex_copen(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    qf_list_T\t*qfl;\n    int\t\theight;\n    int\t\tstatus = FAIL;\n    int\t\tlnum;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    incr_quickfix_busy();\n\n    if (eap->addr_count != 0)\n\theight = eap->line2;\n    else\n\theight = QF_WINHEIGHT;\n\n    reset_VIsual_and_resel();\t\t\t// stop Visual mode\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    // Find an existing quickfix window, or open a new one.\n    if (cmdmod.cmod_tab == 0)\n\tstatus = qf_goto_cwindow(qi, eap->addr_count != 0, height,\n\t\t\t\t\t\tcmdmod.cmod_split & WSP_VERT);\n    if (status == FAIL)\n\tif (qf_open_new_cwindow(qi, height) == FAIL)\n\t{\n\t    decr_quickfix_busy();\n\t    return;\n\t}\n\n    qfl = qf_get_curlist(qi);\n    qf_set_title_var(qfl);\n    // Save the current index here, as updating the quickfix buffer may free\n    // the quickfix list\n    lnum = qfl->qf_index;\n\n    // Fill the buffer with the quickfix list.\n    qf_fill_buffer(qfl, curbuf, NULL, curwin->w_id);\n\n    decr_quickfix_busy();\n\n    curwin->w_cursor.lnum = lnum;\n    curwin->w_cursor.col = 0;\n    check_cursor();\n    update_topline();\t\t// scroll to show the line\n}\n\n/*\n * Move the cursor in the quickfix window to \"lnum\".\n */\n    static void\nqf_win_goto(win_T *win, linenr_T lnum)\n{\n    win_T\t*old_curwin = curwin;\n\n    curwin = win;\n    curbuf = win->w_buffer;\n    curwin->w_cursor.lnum = lnum;\n    curwin->w_cursor.col = 0;\n    curwin->w_cursor.coladd = 0;\n    curwin->w_curswant = 0;\n    update_topline();\t\t// scroll to show the line\n    redraw_later(UPD_VALID);\n    curwin->w_redr_status = TRUE;\t// update ruler\n    curwin = old_curwin;\n    curbuf = curwin->w_buffer;\n}\n\n/*\n * :cbottom/:lbottom commands.\n */\n    void\nex_cbottom(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    win_T\t*win;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    win = qf_find_win(qi);\n    if (win != NULL && win->w_cursor.lnum != win->w_buffer->b_ml.ml_line_count)\n\tqf_win_goto(win, win->w_buffer->b_ml.ml_line_count);\n}\n\n/*\n * Return the number of the current entry (line number in the quickfix\n * window).\n */\n     linenr_T\nqf_current_entry(win_T *wp)\n{\n    qf_info_T\t*qi = &ql_info;\n\n    if (IS_LL_WINDOW(wp))\n\t// In the location list window, use the referenced location list\n\tqi = wp->w_llist_ref;\n\n    return qf_get_curlist(qi)->qf_index;\n}\n\n/*\n * Update the cursor position in the quickfix window to the current error.\n * Return TRUE if there is a quickfix window.\n */\n    static int\nqf_win_pos_update(\n    qf_info_T\t*qi,\n    int\t\told_qf_index)\t// previous qf_index or zero\n{\n    win_T\t*win;\n    int\t\tqf_index = qf_get_curlist(qi)->qf_index;\n\n    // Put the cursor on the current error in the quickfix window, so that\n    // it's viewable.\n    win = qf_find_win(qi);\n    if (win != NULL\n\t    && qf_index <= win->w_buffer->b_ml.ml_line_count\n\t    && old_qf_index != qf_index)\n    {\n\tif (qf_index > old_qf_index)\n\t{\n\t    win->w_redraw_top = old_qf_index;\n\t    win->w_redraw_bot = qf_index;\n\t}\n\telse\n\t{\n\t    win->w_redraw_top = qf_index;\n\t    win->w_redraw_bot = old_qf_index;\n\t}\n\tqf_win_goto(win, qf_index);\n    }\n    return win != NULL;\n}\n\n/*\n * Check whether the given window is displaying the specified quickfix/location\n * stack.\n */\n    static int\nis_qf_win(win_T *win, qf_info_T *qi)\n{\n    // A window displaying the quickfix buffer will have the w_llist_ref field\n    // set to NULL.\n    // A window displaying a location list buffer will have the w_llist_ref\n    // pointing to the location list.\n    if (bt_quickfix(win->w_buffer))\n\tif ((IS_QF_STACK(qi) && win->w_llist_ref == NULL)\n\t\t|| (IS_LL_STACK(qi) && win->w_llist_ref == qi))\n\t    return TRUE;\n\n    return FALSE;\n}\n\n/*\n * Find a window displaying the quickfix/location stack 'qi' in the current tab\n * page.\n */\n    static win_T *\nqf_find_win(qf_info_T *qi)\n{\n    win_T\t*win;\n\n    FOR_ALL_WINDOWS(win)\n\tif (is_qf_win(win, qi))\n\t    return win;\n    return NULL;\n}\n\n/*\n * Find a quickfix buffer.\n * Searches in windows opened in all the tab pages.\n */\n    static buf_T *\nqf_find_buf(qf_info_T *qi)\n{\n    tabpage_T\t*tp;\n    win_T\t*win;\n\n    if (qi->qf_bufnr != INVALID_QFBUFNR)\n    {\n\tbuf_T\t*qfbuf;\n\tqfbuf = buflist_findnr(qi->qf_bufnr);\n\tif (qfbuf != NULL)\n\t    return qfbuf;\n\t// buffer is no longer present\n\tqi->qf_bufnr = INVALID_QFBUFNR;\n    }\n\n    FOR_ALL_TAB_WINDOWS(tp, win)\n\tif (is_qf_win(win, qi))\n\t    return win->w_buffer;\n\n    return NULL;\n}\n\n/*\n * Process the 'quickfixtextfunc' option value.\n * Returns OK or FAIL.\n */\n    int\nqf_process_qftf_option(void)\n{\n    return option_set_callback_func(p_qftf, &qftf_cb);\n}\n\n/*\n * Update the w:quickfix_title variable in the quickfix/location list window in\n * all the tab pages.\n */\n    static void\nqf_update_win_titlevar(qf_info_T *qi)\n{\n    qf_list_T\t*qfl = qf_get_curlist(qi);\n    tabpage_T\t*tp;\n    win_T\t*win;\n    win_T\t*save_curwin = curwin;\n\n    FOR_ALL_TAB_WINDOWS(tp, win)\n    {\n\tif (is_qf_win(win, qi))\n\t{\n\t    curwin = win;\n\t    qf_set_title_var(qfl);\n\t}\n    }\n    curwin = save_curwin;\n}\n\n/*\n * Find the quickfix buffer.  If it exists, update the contents.\n */\n    static void\nqf_update_buffer(qf_info_T *qi, qfline_T *old_last)\n{\n    buf_T\t*buf;\n    win_T\t*win;\n    aco_save_T\taco;\n\n    // Check if a buffer for the quickfix list exists.  Update it.\n    buf = qf_find_buf(qi);\n    if (buf != NULL)\n    {\n\tlinenr_T\told_line_count = buf->b_ml.ml_line_count;\n\tint\t\tqf_winid = 0;\n\n\tif (IS_LL_STACK(qi))\n\t{\n\t    if (curwin->w_llist == qi)\n\t\twin = curwin;\n\t    else\n\t    {\n\t\t// Find the file window (non-quickfix) with this location list\n\t\twin = qf_find_win_with_loclist(qi);\n\t\tif (win == NULL)\n\t\t    // File window is not found. Find the location list window.\n\t\t    win = qf_find_win(qi);\n\t\tif (win == NULL)\n\t\t    return;\n\t    }\n\t    qf_winid = win->w_id;\n\t}\n\n\tif (old_last == NULL)\n\t    // set curwin/curbuf to buf and save a few things\n\t    aucmd_prepbuf(&aco, buf);\n\n\tqf_update_win_titlevar(qi);\n\n\tqf_fill_buffer(qf_get_curlist(qi), buf, old_last, qf_winid);\n\t++CHANGEDTICK(buf);\n\n\tif (old_last == NULL)\n\t{\n\t    (void)qf_win_pos_update(qi, 0);\n\n\t    // restore curwin/curbuf and a few other things\n\t    aucmd_restbuf(&aco);\n\t}\n\n\t// Only redraw when added lines are visible.  This avoids flickering\n\t// when the added lines are not visible.\n\tif ((win = qf_find_win(qi)) != NULL && old_line_count < win->w_botline)\n\t    redraw_buf_later(buf, UPD_NOT_VALID);\n    }\n}\n\n/*\n * Add an error line to the quickfix buffer.\n */\n    static int\nqf_buf_add_line(\n\tbuf_T\t\t*buf,\t\t// quickfix window buffer\n\tlinenr_T\tlnum,\n\tqfline_T\t*qfp,\n\tchar_u\t\t*dirname,\n\tint\t\tfirst_bufline,\n\tchar_u\t\t*qftf_str)\n{\n    int\t\tlen;\n    buf_T\t*errbuf;\n\n    // If the 'quickfixtextfunc' function returned a non-empty custom string\n    // for this entry, then use it.\n    if (qftf_str != NULL && *qftf_str != NUL)\n\tvim_strncpy(IObuff, qftf_str, IOSIZE - 1);\n    else\n    {\n\tif (qfp->qf_module != NULL)\n\t{\n\t    vim_strncpy(IObuff, qfp->qf_module, IOSIZE - 1);\n\t    len = (int)STRLEN(IObuff);\n\t}\n\telse if (qfp->qf_fnum != 0\n\t\t&& (errbuf = buflist_findnr(qfp->qf_fnum)) != NULL\n\t\t&& errbuf->b_fname != NULL)\n\t{\n\t    if (qfp->qf_type == 1)\t// :helpgrep\n\t\tvim_strncpy(IObuff, gettail(errbuf->b_fname), IOSIZE - 1);\n\t    else\n\t    {\n\t\t// Shorten the file name if not done already.\n\t\t// For optimization, do this only for the first entry in a\n\t\t// buffer.\n\t\tif (first_bufline && (errbuf->b_sfname == NULL\n\t\t\t\t|| mch_isFullName(errbuf->b_sfname)))\n\t\t{\n\t\t    if (*dirname == NUL)\n\t\t\tmch_dirname(dirname, MAXPATHL);\n\t\t    shorten_buf_fname(errbuf, dirname, FALSE);\n\t\t}\n\t\tvim_strncpy(IObuff, errbuf->b_fname, IOSIZE - 1);\n\t    }\n\t    len = (int)STRLEN(IObuff);\n\t}\n\telse\n\t    len = 0;\n\n\tif (len < IOSIZE - 1)\n\t    IObuff[len++] = '|';\n\n\tif (qfp->qf_lnum > 0)\n\t{\n\t    qf_range_text(qfp, IObuff + len, IOSIZE - len);\n\t    len += (int)STRLEN(IObuff + len);\n\n\t    vim_snprintf((char *)IObuff + len, IOSIZE - len, \"%s\",\n\t\t    (char *)qf_types(qfp->qf_type, qfp->qf_nr));\n\t    len += (int)STRLEN(IObuff + len);\n\t}\n\telse if (qfp->qf_pattern != NULL)\n\t{\n\t    qf_fmt_text(qfp->qf_pattern, IObuff + len, IOSIZE - len);\n\t    len += (int)STRLEN(IObuff + len);\n\t}\n\tif (len < IOSIZE - 2)\n\t{\n\t    IObuff[len++] = '|';\n\t    IObuff[len++] = ' ';\n\t}\n\n\t// Remove newlines and leading whitespace from the text.\n\t// For an unrecognized line keep the indent, the compiler may\n\t// mark a word with ^^^^.\n\tqf_fmt_text(len > 3 ? skipwhite(qfp->qf_text) : qfp->qf_text,\n\t\tIObuff + len, IOSIZE - len);\n    }\n\n    if (ml_append_buf(buf, lnum, IObuff,\n\t\t(colnr_T)STRLEN(IObuff) + 1, FALSE) == FAIL)\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * Call the 'quickfixtextfunc' function to get the list of lines to display in\n * the quickfix window for the entries 'start_idx' to 'end_idx'.\n */\n    static list_T *\ncall_qftf_func(qf_list_T *qfl, int qf_winid, long start_idx, long end_idx)\n{\n    callback_T\t*cb = &qftf_cb;\n    list_T\t*qftf_list = NULL;\n\n    // If 'quickfixtextfunc' is set, then use the user-supplied function to get\n    // the text to display. Use the local value of 'quickfixtextfunc' if it is\n    // set.\n    if (qfl->qf_qftf_cb.cb_name != NULL)\n\tcb = &qfl->qf_qftf_cb;\n    if (cb->cb_name != NULL)\n    {\n\ttypval_T\targs[1];\n\tdict_T\t\t*d;\n\ttypval_T\trettv;\n\n\t// create the dict argument\n\tif ((d = dict_alloc_lock(VAR_FIXED)) == NULL)\n\t    return NULL;\n\tdict_add_number(d, \"quickfix\", (long)IS_QF_LIST(qfl));\n\tdict_add_number(d, \"winid\", (long)qf_winid);\n\tdict_add_number(d, \"id\", (long)qfl->qf_id);\n\tdict_add_number(d, \"start_idx\", start_idx);\n\tdict_add_number(d, \"end_idx\", end_idx);\n\t++d->dv_refcount;\n\targs[0].v_type = VAR_DICT;\n\targs[0].vval.v_dict = d;\n\n\tqftf_list = NULL;\n\tif (call_callback(cb, 0, &rettv, 1, args) != FAIL)\n\t{\n\t    if (rettv.v_type == VAR_LIST)\n\t    {\n\t\tqftf_list = rettv.vval.v_list;\n\t\tqftf_list->lv_refcount++;\n\t    }\n\t    clear_tv(&rettv);\n\t}\n\tdict_unref(d);\n    }\n\n    return qftf_list;\n}\n\n/*\n * Fill current buffer with quickfix errors, replacing any previous contents.\n * curbuf must be the quickfix buffer!\n * If \"old_last\" is not NULL append the items after this one.\n * When \"old_last\" is NULL then \"buf\" must equal \"curbuf\"!  Because\n * ml_delete() is used and autocommands will be triggered.\n */\n    static void\nqf_fill_buffer(qf_list_T *qfl, buf_T *buf, qfline_T *old_last, int qf_winid)\n{\n    linenr_T\tlnum;\n    qfline_T\t*qfp;\n    int\t\told_KeyTyped = KeyTyped;\n    list_T\t*qftf_list = NULL;\n    listitem_T\t*qftf_li = NULL;\n\n    if (old_last == NULL)\n    {\n\tif (buf != curbuf)\n\t{\n\t    internal_error(\"qf_fill_buffer()\");\n\t    return;\n\t}\n\n\t// delete all existing lines\n\twhile ((curbuf->b_ml.ml_flags & ML_EMPTY) == 0)\n\t    (void)ml_delete((linenr_T)1);\n    }\n\n    // Check if there is anything to display\n    if (qfl != NULL)\n    {\n\tchar_u\t\tdirname[MAXPATHL];\n\tint\t\tinvalid_val = FALSE;\n\tint\t\tprev_bufnr = -1;\n\n\t*dirname = NUL;\n\n\t// Add one line for each error\n\tif (old_last == NULL)\n\t{\n\t    qfp = qfl->qf_start;\n\t    lnum = 0;\n\t}\n\telse\n\t{\n\t    if (old_last->qf_next != NULL)\n\t\tqfp = old_last->qf_next;\n\t    else\n\t\tqfp = old_last;\n\t    lnum = buf->b_ml.ml_line_count;\n\t}\n\n\tqftf_list = call_qftf_func(qfl, qf_winid, (long)(lnum + 1),\n\t\t\t\t\t\t\t(long)qfl->qf_count);\n\tif (qftf_list != NULL)\n\t    qftf_li = qftf_list->lv_first;\n\n\twhile (lnum < qfl->qf_count)\n\t{\n\t    char_u\t*qftf_str = NULL;\n\n\t    // Use the text supplied by the user defined function (if any).\n\t    // If the returned value is not string, then ignore the rest\n\t    // of the returned values and use the default.\n\t    if (qftf_li != NULL && !invalid_val)\n\t    {\n\t\tqftf_str = tv_get_string_chk(&qftf_li->li_tv);\n\t\tif (qftf_str == NULL)\n\t\t    invalid_val = TRUE;\n\t    }\n\n\t    if (qf_buf_add_line(buf, lnum, qfp, dirname,\n\t\t\tprev_bufnr != qfp->qf_fnum, qftf_str) == FAIL)\n\t\tbreak;\n\n\t    prev_bufnr = qfp->qf_fnum;\n\t    ++lnum;\n\t    qfp = qfp->qf_next;\n\t    if (qfp == NULL)\n\t\tbreak;\n\n\t    if (qftf_li != NULL)\n\t\tqftf_li = qftf_li->li_next;\n\t}\n\n\tif (old_last == NULL)\n\t    // Delete the empty line which is now at the end\n\t    (void)ml_delete(lnum + 1);\n    }\n\n    // correct cursor position\n    check_lnums(TRUE);\n\n    if (old_last == NULL)\n    {\n\t// Set the 'filetype' to \"qf\" each time after filling the buffer.\n\t// This resembles reading a file into a buffer, it's more logical when\n\t// using autocommands.\n\t++curbuf_lock;\n\tset_option_value_give_err((char_u *)\"ft\",\n\t\t\t\t\t\t0L, (char_u *)\"qf\", OPT_LOCAL);\n\tcurbuf->b_p_ma = FALSE;\n\n\tkeep_filetype = TRUE;\t\t// don't detect 'filetype'\n\tapply_autocmds(EVENT_BUFREADPOST, (char_u *)\"quickfix\", NULL,\n\t\t\t\t\t\t\t       FALSE, curbuf);\n\tapply_autocmds(EVENT_BUFWINENTER, (char_u *)\"quickfix\", NULL,\n\t\t\t\t\t\t\t       FALSE, curbuf);\n\tkeep_filetype = FALSE;\n\t--curbuf_lock;\n\n\t// make sure it will be redrawn\n\tredraw_curbuf_later(UPD_NOT_VALID);\n    }\n\n    // Restore KeyTyped, setting 'filetype' may reset it.\n    KeyTyped = old_KeyTyped;\n}\n\n/*\n * For every change made to the quickfix list, update the changed tick.\n */\n    static void\nqf_list_changed(qf_list_T *qfl)\n{\n    qfl->qf_changedtick++;\n}\n\n/*\n * Return the quickfix/location list number with the given identifier.\n * Returns -1 if list is not found.\n */\n    static int\nqf_id2nr(qf_info_T *qi, int_u qfid)\n{\n    int\t\tqf_idx;\n\n    for (qf_idx = 0; qf_idx < qi->qf_listcount; qf_idx++)\n\tif (qi->qf_lists[qf_idx].qf_id == qfid)\n\t    return qf_idx;\n    return INVALID_QFIDX;\n}\n\n/*\n * If the current list is not \"save_qfid\" and we can find the list with that ID\n * then make it the current list.\n * This is used when autocommands may have changed the current list.\n * Returns OK if successfully restored the list. Returns FAIL if the list with\n * the specified identifier (save_qfid) is not found in the stack.\n */\n    static int\nqf_restore_list(qf_info_T *qi, int_u save_qfid)\n{\n    int curlist;\n\n    if (qf_get_curlist(qi)->qf_id != save_qfid)\n    {\n\tcurlist = qf_id2nr(qi, save_qfid);\n\tif (curlist < 0)\n\t    // list is not present\n\t    return FAIL;\n\tqi->qf_curlist = curlist;\n    }\n    return OK;\n}\n\n/*\n * Jump to the first entry if there is one.\n */\n    static void\nqf_jump_first(qf_info_T *qi, int_u save_qfid, int forceit)\n{\n    if (qf_restore_list(qi, save_qfid) == FAIL)\n\treturn;\n\n    // Autocommands might have cleared the list, check for that.\n    if (!qf_list_empty(qf_get_curlist(qi)))\n\tqf_jump(qi, 0, 0, forceit);\n}\n\n/*\n * Return TRUE when using \":vimgrep\" for \":grep\".\n */\n    int\ngrep_internal(cmdidx_T cmdidx)\n{\n    return ((cmdidx == CMD_grep\n\t\t|| cmdidx == CMD_lgrep\n\t\t|| cmdidx == CMD_grepadd\n\t\t|| cmdidx == CMD_lgrepadd)\n\t    && STRCMP(\"internal\",\n\t\t\t*curbuf->b_p_gp == NUL ? p_gp : curbuf->b_p_gp) == 0);\n}\n\n/*\n * Return the make/grep autocmd name.\n */\n    static char_u *\nmake_get_auname(cmdidx_T cmdidx)\n{\n    switch (cmdidx)\n    {\n\tcase CMD_make:\t    return (char_u *)\"make\";\n\tcase CMD_lmake:\t    return (char_u *)\"lmake\";\n\tcase CMD_grep:\t    return (char_u *)\"grep\";\n\tcase CMD_lgrep:\t    return (char_u *)\"lgrep\";\n\tcase CMD_grepadd:   return (char_u *)\"grepadd\";\n\tcase CMD_lgrepadd:  return (char_u *)\"lgrepadd\";\n\tdefault: return NULL;\n    }\n}\n\n/*\n * Return the name for the errorfile, in allocated memory.\n * Find a new unique name when 'makeef' contains \"##\".\n * Returns NULL for error.\n */\n    static char_u *\nget_mef_name(void)\n{\n    char_u\t*p;\n    char_u\t*name;\n    static int\tstart = -1;\n    static int\toff = 0;\n#ifdef HAVE_LSTAT\n    stat_T\tsb;\n#endif\n\n    if (*p_mef == NUL)\n    {\n\tname = vim_tempname('e', FALSE);\n\tif (name == NULL)\n\t    emsg(_(e_cant_get_temp_file_name));\n\treturn name;\n    }\n\n    for (p = p_mef; *p; ++p)\n\tif (p[0] == '#' && p[1] == '#')\n\t    break;\n\n    if (*p == NUL)\n\treturn vim_strsave(p_mef);\n\n    // Keep trying until the name doesn't exist yet.\n    for (;;)\n    {\n\tif (start == -1)\n\t    start = mch_get_pid();\n\telse\n\t    off += 19;\n\n\tname = alloc_id(STRLEN(p_mef) + 30, aid_qf_mef_name);\n\tif (name == NULL)\n\t    break;\n\tSTRCPY(name, p_mef);\n\tsprintf((char *)name + (p - p_mef), \"%d%d\", start, off);\n\tSTRCAT(name, p + 2);\n\tif (mch_getperm(name) < 0\n#ifdef HAVE_LSTAT\n\t\t    // Don't accept a symbolic link, it's a security risk.\n\t\t    && mch_lstat((char *)name, &sb) < 0\n#endif\n\t\t)\n\t    break;\n\tvim_free(name);\n    }\n    return name;\n}\n\n/*\n * Form the complete command line to invoke 'make'/'grep'. Quote the command\n * using 'shellquote' and append 'shellpipe'. Echo the fully formed command.\n */\n    static char_u *\nmake_get_fullcmd(char_u *makecmd, char_u *fname)\n{\n    char_u\t*cmd;\n    unsigned\tlen;\n\n    len = (unsigned)STRLEN(p_shq) * 2 + (unsigned)STRLEN(makecmd) + 1;\n    if (*p_sp != NUL)\n\tlen += (unsigned)STRLEN(p_sp) + (unsigned)STRLEN(fname) + 3;\n    cmd = alloc_id(len, aid_qf_makecmd);\n    if (cmd == NULL)\n\treturn NULL;\n    sprintf((char *)cmd, \"%s%s%s\", (char *)p_shq, (char *)makecmd,\n\t\t\t\t\t\t\t       (char *)p_shq);\n\n    // If 'shellpipe' empty: don't redirect to 'errorfile'.\n    if (*p_sp != NUL)\n\tappend_redir(cmd, len, p_sp, fname);\n\n    // Display the fully formed command.  Output a newline if there's something\n    // else than the :make command that was typed (in which case the cursor is\n    // in column 0).\n    if (msg_col == 0)\n\tmsg_didout = FALSE;\n    msg_start();\n    msg_puts(\":!\");\n    msg_outtrans(cmd);\t\t// show what we are doing\n\n    return cmd;\n}\n\n/*\n * Used for \":make\", \":lmake\", \":grep\", \":lgrep\", \":grepadd\", and \":lgrepadd\"\n */\n    void\nex_make(exarg_T *eap)\n{\n    char_u\t*fname;\n    char_u\t*cmd;\n    char_u\t*enc = NULL;\n    win_T\t*wp = NULL;\n    qf_info_T\t*qi = &ql_info;\n    int\t\tres;\n    char_u\t*au_name = NULL;\n    int_u\tsave_qfid;\n    char_u\t*errorformat = p_efm;\n    int\t\tnewlist = TRUE;\n\n    // Redirect \":grep\" to \":vimgrep\" if 'grepprg' is \"internal\".\n    if (grep_internal(eap->cmdidx))\n    {\n\tex_vimgrep(eap);\n\treturn;\n    }\n\n    au_name = make_get_auname(eap->cmdidx);\n    if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf))\n    {\n#ifdef FEAT_EVAL\n\tif (aborting())\n\t    return;\n#endif\n    }\n    enc = (*curbuf->b_p_menc != NUL) ? curbuf->b_p_menc : p_menc;\n\n    if (is_loclist_cmd(eap->cmdidx))\n\twp = curwin;\n\n    autowrite_all();\n    fname = get_mef_name();\n    if (fname == NULL)\n\treturn;\n    mch_remove(fname);\t    // in case it's not unique\n\n    cmd = make_get_fullcmd(eap->arg, fname);\n    if (cmd == NULL)\n    {\n\tvim_free(fname);\n\treturn;\n    }\n\n    // let the shell know if we are redirecting output or not\n    do_shell(cmd, *p_sp != NUL ? SHELL_DOOUT : 0);\n\n#ifdef AMIGA\n    out_flush();\n\t\t// read window status report and redraw before message\n    (void)char_avail();\n#endif\n\n    incr_quickfix_busy();\n\n    if (eap->cmdidx != CMD_make && eap->cmdidx != CMD_lmake)\n\terrorformat = p_gefm;\n    if (eap->cmdidx == CMD_grepadd || eap->cmdidx == CMD_lgrepadd)\n\tnewlist = FALSE;\n\n    res = qf_init(wp, fname, errorformat, newlist, qf_cmdtitle(*eap->cmdlinep),\n\t\t\t\t\t\t\t\t\tenc);\n    if (wp != NULL)\n    {\n\tqi = GET_LOC_LIST(wp);\n\tif (qi == NULL)\n\t    goto cleanup;\n    }\n    if (res >= 0)\n\tqf_list_changed(qf_get_curlist(qi));\n\n    // Remember the current quickfix list identifier, so that we can\n    // check for autocommands changing the current quickfix list.\n    save_qfid = qf_get_curlist(qi)->qf_id;\n    if (au_name != NULL)\n\tapply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf);\n    if (res > 0 && !eap->forceit && qflist_valid(wp, save_qfid))\n\t// display the first error\n\tqf_jump_first(qi, save_qfid, FALSE);\n\ncleanup:\n    decr_quickfix_busy();\n    mch_remove(fname);\n    vim_free(fname);\n    vim_free(cmd);\n}\n\n/*\n * Returns the number of entries in the current quickfix/location list.\n */\n    int\nqf_get_size(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n\n    if ((qi = qf_cmd_get_stack(eap, FALSE)) == NULL)\n\treturn 0;\n    return qf_get_curlist(qi)->qf_count;\n}\n\n/*\n * Returns the number of valid entries in the current quickfix/location list.\n */\n    int\nqf_get_valid_size(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    qf_list_T\t*qfl;\n    qfline_T\t*qfp;\n    int\t\ti, sz = 0;\n    int\t\tprev_fnum = 0;\n\n    if ((qi = qf_cmd_get_stack(eap, FALSE)) == NULL)\n\treturn 0;\n\n    qfl = qf_get_curlist(qi);\n    FOR_ALL_QFL_ITEMS(qfl, qfp, i)\n    {\n\tif (qfp->qf_valid)\n\t{\n\t    if (eap->cmdidx == CMD_cdo || eap->cmdidx == CMD_ldo)\n\t\tsz++;\t// Count all valid entries\n\t    else if (qfp->qf_fnum > 0 && qfp->qf_fnum != prev_fnum)\n\t    {\n\t\t// Count the number of files\n\t\tsz++;\n\t\tprev_fnum = qfp->qf_fnum;\n\t    }\n\t}\n    }\n\n    return sz;\n}\n\n/*\n * Returns the current index of the quickfix/location list.\n * Returns 0 if there is an error.\n */\n    int\nqf_get_cur_idx(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n\n    if ((qi = qf_cmd_get_stack(eap, FALSE)) == NULL)\n\treturn 0;\n\n    return qf_get_curlist(qi)->qf_index;\n}\n\n/*\n * Returns the current index in the quickfix/location list (counting only valid\n * entries). If no valid entries are in the list, then returns 1.\n */\n    int\nqf_get_cur_valid_idx(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    qf_list_T\t*qfl;\n    qfline_T\t*qfp;\n    int\t\ti, eidx = 0;\n    int\t\tprev_fnum = 0;\n\n    if ((qi = qf_cmd_get_stack(eap, FALSE)) == NULL)\n\treturn 1;\n\n    qfl = qf_get_curlist(qi);\n    qfp = qfl->qf_start;\n\n    // check if the list has valid errors\n    if (!qf_list_has_valid_entries(qfl))\n\treturn 1;\n\n    for (i = 1; i <= qfl->qf_index && qfp!= NULL; i++, qfp = qfp->qf_next)\n    {\n\tif (qfp->qf_valid)\n\t{\n\t    if (eap->cmdidx == CMD_cfdo || eap->cmdidx == CMD_lfdo)\n\t    {\n\t\tif (qfp->qf_fnum > 0 && qfp->qf_fnum != prev_fnum)\n\t\t{\n\t\t    // Count the number of files\n\t\t    eidx++;\n\t\t    prev_fnum = qfp->qf_fnum;\n\t\t}\n\t    }\n\t    else\n\t\teidx++;\n\t}\n    }\n\n    return eidx ? eidx : 1;\n}\n\n/*\n * Get the 'n'th valid error entry in the quickfix or location list.\n * Used by :cdo, :ldo, :cfdo and :lfdo commands.\n * For :cdo and :ldo returns the 'n'th valid error entry.\n * For :cfdo and :lfdo returns the 'n'th valid file entry.\n */\n    static int\nqf_get_nth_valid_entry(qf_list_T *qfl, int n, int fdo)\n{\n    qfline_T\t*qfp;\n    int\t\ti, eidx;\n    int\t\tprev_fnum = 0;\n\n    // check if the list has valid errors\n    if (!qf_list_has_valid_entries(qfl))\n\treturn 1;\n\n    eidx = 0;\n    FOR_ALL_QFL_ITEMS(qfl, qfp, i)\n    {\n\tif (qfp->qf_valid)\n\t{\n\t    if (fdo)\n\t    {\n\t\tif (qfp->qf_fnum > 0 && qfp->qf_fnum != prev_fnum)\n\t\t{\n\t\t    // Count the number of files\n\t\t    eidx++;\n\t\t    prev_fnum = qfp->qf_fnum;\n\t\t}\n\t    }\n\t    else\n\t\teidx++;\n\t}\n\n\tif (eidx == n)\n\t    break;\n    }\n\n    if (i <= qfl->qf_count)\n\treturn i;\n    else\n\treturn 1;\n}\n\n/*\n * \":cc\", \":crewind\", \":cfirst\" and \":clast\".\n * \":ll\", \":lrewind\", \":lfirst\" and \":llast\".\n * \":cdo\", \":ldo\", \":cfdo\" and \":lfdo\"\n */\n    void\nex_cc(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    int\t\terrornr;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    if (eap->addr_count > 0)\n\terrornr = (int)eap->line2;\n    else\n    {\n\tswitch (eap->cmdidx)\n\t{\n\t    case CMD_cc: case CMD_ll:\n\t\terrornr = 0;\n\t\tbreak;\n\t    case CMD_crewind: case CMD_lrewind: case CMD_cfirst:\n\t    case CMD_lfirst:\n\t\terrornr = 1;\n\t\tbreak;\n\t    default:\n\t\terrornr = 32767;\n\t}\n    }\n\n    // For cdo and ldo commands, jump to the nth valid error.\n    // For cfdo and lfdo commands, jump to the nth valid file entry.\n    if (eap->cmdidx == CMD_cdo || eap->cmdidx == CMD_ldo\n\t    || eap->cmdidx == CMD_cfdo || eap->cmdidx == CMD_lfdo)\n\terrornr = qf_get_nth_valid_entry(qf_get_curlist(qi),\n\t\teap->addr_count > 0 ? (int)eap->line1 : 1,\n\t\teap->cmdidx == CMD_cfdo || eap->cmdidx == CMD_lfdo);\n\n    qf_jump(qi, 0, errornr, eap->forceit);\n}\n\n/*\n * \":cnext\", \":cnfile\", \":cNext\" and \":cprevious\".\n * \":lnext\", \":lNext\", \":lprevious\", \":lnfile\", \":lNfile\" and \":lpfile\".\n * Also, used by \":cdo\", \":ldo\", \":cfdo\" and \":lfdo\" commands.\n */\n    void\nex_cnext(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    int\t\terrornr;\n    int\t\tdir;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    if (eap->addr_count > 0\n\t    && (eap->cmdidx != CMD_cdo && eap->cmdidx != CMD_ldo\n\t\t&& eap->cmdidx != CMD_cfdo && eap->cmdidx != CMD_lfdo))\n\terrornr = (int)eap->line2;\n    else\n\terrornr = 1;\n\n    // Depending on the command jump to either next or previous entry/file.\n    switch (eap->cmdidx)\n    {\n\tcase CMD_cnext: case CMD_lnext: case CMD_cdo: case CMD_ldo:\n\t    dir = FORWARD;\n\t    break;\n\tcase CMD_cprevious: case CMD_lprevious: case CMD_cNext:\n\tcase CMD_lNext:\n\t    dir = BACKWARD;\n\t    break;\n\tcase CMD_cnfile: case CMD_lnfile: case CMD_cfdo: case CMD_lfdo:\n\t    dir = FORWARD_FILE;\n\t    break;\n\tcase CMD_cpfile: case CMD_lpfile: case CMD_cNfile: case CMD_lNfile:\n\t    dir = BACKWARD_FILE;\n\t    break;\n\tdefault:\n\t    dir = FORWARD;\n\t    break;\n    }\n\n    qf_jump(qi, dir, errornr, eap->forceit);\n}\n\n/*\n * Find the first entry in the quickfix list 'qfl' from buffer 'bnr'.\n * The index of the entry is stored in 'errornr'.\n * Returns NULL if an entry is not found.\n */\n    static qfline_T *\nqf_find_first_entry_in_buf(qf_list_T *qfl, int bnr, int *errornr)\n{\n    qfline_T\t*qfp = NULL;\n    int\t\tidx = 0;\n\n    // Find the first entry in this file\n    FOR_ALL_QFL_ITEMS(qfl, qfp, idx)\n\tif (qfp->qf_fnum == bnr)\n\t    break;\n\n    *errornr = idx;\n    return qfp;\n}\n\n/*\n * Find the first quickfix entry on the same line as 'entry'. Updates 'errornr'\n * with the error number for the first entry. Assumes the entries are sorted in\n * the quickfix list by line number.\n */\n    static qfline_T *\nqf_find_first_entry_on_line(qfline_T *entry, int *errornr)\n{\n    while (!got_int\n\t    && entry->qf_prev != NULL\n\t    && entry->qf_fnum == entry->qf_prev->qf_fnum\n\t    && entry->qf_lnum == entry->qf_prev->qf_lnum)\n    {\n\tentry = entry->qf_prev;\n\t--*errornr;\n    }\n\n    return entry;\n}\n\n/*\n * Find the last quickfix entry on the same line as 'entry'. Updates 'errornr'\n * with the error number for the last entry. Assumes the entries are sorted in\n * the quickfix list by line number.\n */\n    static qfline_T *\nqf_find_last_entry_on_line(qfline_T *entry, int *errornr)\n{\n    while (!got_int &&\n\t    entry->qf_next != NULL\n\t    && entry->qf_fnum == entry->qf_next->qf_fnum\n\t    && entry->qf_lnum == entry->qf_next->qf_lnum)\n    {\n\tentry = entry->qf_next;\n\t++*errornr;\n    }\n\n    return entry;\n}\n\n/*\n * Returns TRUE if the specified quickfix entry is\n *   after the given line (linewise is TRUE)\n *   or after the line and column.\n */\n    static int\nqf_entry_after_pos(qfline_T *qfp, pos_T *pos, int linewise)\n{\n    if (linewise)\n\treturn qfp->qf_lnum > pos->lnum;\n    else\n\treturn (qfp->qf_lnum > pos->lnum ||\n\t\t(qfp->qf_lnum == pos->lnum && qfp->qf_col > pos->col));\n}\n\n/*\n * Returns TRUE if the specified quickfix entry is\n *   before the given line (linewise is TRUE)\n *   or before the line and column.\n */\n    static int\nqf_entry_before_pos(qfline_T *qfp, pos_T *pos, int linewise)\n{\n    if (linewise)\n\treturn qfp->qf_lnum < pos->lnum;\n    else\n\treturn (qfp->qf_lnum < pos->lnum ||\n\t\t(qfp->qf_lnum == pos->lnum && qfp->qf_col < pos->col));\n}\n\n/*\n * Returns TRUE if the specified quickfix entry is\n *   on or after the given line (linewise is TRUE)\n *   or on or after the line and column.\n */\n    static int\nqf_entry_on_or_after_pos(qfline_T *qfp, pos_T *pos, int linewise)\n{\n    if (linewise)\n\treturn qfp->qf_lnum >= pos->lnum;\n    else\n\treturn (qfp->qf_lnum > pos->lnum ||\n\t\t(qfp->qf_lnum == pos->lnum && qfp->qf_col >= pos->col));\n}\n\n/*\n * Returns TRUE if the specified quickfix entry is\n *   on or before the given line (linewise is TRUE)\n *   or on or before the line and column.\n */\n    static int\nqf_entry_on_or_before_pos(qfline_T *qfp, pos_T *pos, int linewise)\n{\n    if (linewise)\n\treturn qfp->qf_lnum <= pos->lnum;\n    else\n\treturn (qfp->qf_lnum < pos->lnum ||\n\t\t(qfp->qf_lnum == pos->lnum && qfp->qf_col <= pos->col));\n}\n\n/*\n * Find the first quickfix entry after position 'pos' in buffer 'bnr'.\n * If 'linewise' is TRUE, returns the entry after the specified line and treats\n * multiple entries on a single line as one. Otherwise returns the entry after\n * the specified line and column.\n * 'qfp' points to the very first entry in the buffer and 'errornr' is the\n * index of the very first entry in the quickfix list.\n * Returns NULL if an entry is not found after 'pos'.\n */\n    static qfline_T *\nqf_find_entry_after_pos(\n\tint\t\tbnr,\n\tpos_T\t\t*pos,\n\tint\t\tlinewise,\n\tqfline_T\t*qfp,\n\tint\t\t*errornr)\n{\n    if (qf_entry_after_pos(qfp, pos, linewise))\n\t// First entry is after position 'pos'\n\treturn qfp;\n\n    // Find the entry just before or at the position 'pos'\n    while (qfp->qf_next != NULL\n\t    && qfp->qf_next->qf_fnum == bnr\n\t    && qf_entry_on_or_before_pos(qfp->qf_next, pos, linewise))\n    {\n\tqfp = qfp->qf_next;\n\t++*errornr;\n    }\n\n    if (qfp->qf_next == NULL || qfp->qf_next->qf_fnum != bnr)\n\t// No entries found after position 'pos'\n\treturn NULL;\n\n    // Use the entry just after position 'pos'\n    qfp = qfp->qf_next;\n    ++*errornr;\n\n    return qfp;\n}\n\n/*\n * Find the first quickfix entry before position 'pos' in buffer 'bnr'.\n * If 'linewise' is TRUE, returns the entry before the specified line and\n * treats multiple entries on a single line as one. Otherwise returns the entry\n * before the specified line and column.\n * 'qfp' points to the very first entry in the buffer and 'errornr' is the\n * index of the very first entry in the quickfix list.\n * Returns NULL if an entry is not found before 'pos'.\n */\n    static qfline_T *\nqf_find_entry_before_pos(\n\tint\t\tbnr,\n\tpos_T\t\t*pos,\n\tint\t\tlinewise,\n\tqfline_T\t*qfp,\n\tint\t\t*errornr)\n{\n    // Find the entry just before the position 'pos'\n    while (qfp->qf_next != NULL\n\t    && qfp->qf_next->qf_fnum == bnr\n\t    && qf_entry_before_pos(qfp->qf_next, pos, linewise))\n    {\n\tqfp = qfp->qf_next;\n\t++*errornr;\n    }\n\n    if (qf_entry_on_or_after_pos(qfp, pos, linewise))\n\treturn NULL;\n\n    if (linewise)\n\t// If multiple entries are on the same line, then use the first entry\n\tqfp = qf_find_first_entry_on_line(qfp, errornr);\n\n    return qfp;\n}\n\n/*\n * Find a quickfix entry in 'qfl' closest to position 'pos' in buffer 'bnr' in\n * the direction 'dir'.\n */\n    static qfline_T *\nqf_find_closest_entry(\n\tqf_list_T\t*qfl,\n\tint\t\tbnr,\n\tpos_T\t\t*pos,\n\tint\t\tdir,\n\tint\t\tlinewise,\n\tint\t\t*errornr)\n{\n    qfline_T\t*qfp;\n\n    *errornr = 0;\n\n    // Find the first entry in this file\n    qfp = qf_find_first_entry_in_buf(qfl, bnr, errornr);\n    if (qfp == NULL)\n\treturn NULL;\t\t// no entry in this file\n\n    if (dir == FORWARD)\n\tqfp = qf_find_entry_after_pos(bnr, pos, linewise, qfp, errornr);\n    else\n\tqfp = qf_find_entry_before_pos(bnr, pos, linewise, qfp, errornr);\n\n    return qfp;\n}\n\n/*\n * Get the nth quickfix entry below the specified entry.  Searches forward in\n * the list. If linewise is TRUE, then treat multiple entries on a single line\n * as one.\n */\n    static void\nqf_get_nth_below_entry(qfline_T *entry_arg, int n, int linewise, int *errornr)\n{\n    qfline_T *entry = entry_arg;\n\n    while (n-- > 0 && !got_int)\n    {\n\tint\t\tfirst_errornr = *errornr;\n\n\tif (linewise)\n\t    // Treat all the entries on the same line in this file as one\n\t    entry = qf_find_last_entry_on_line(entry, errornr);\n\n\tif (entry->qf_next == NULL\n\t\t|| entry->qf_next->qf_fnum != entry->qf_fnum)\n\t{\n\t    if (linewise)\n\t\t*errornr = first_errornr;\n\t    break;\n\t}\n\n\tentry = entry->qf_next;\n\t++*errornr;\n    }\n}\n\n/*\n * Get the nth quickfix entry above the specified entry.  Searches backwards in\n * the list. If linewise is TRUE, then treat multiple entries on a single line\n * as one.\n */\n    static void\nqf_get_nth_above_entry(qfline_T *entry, int n, int linewise, int *errornr)\n{\n    while (n-- > 0 && !got_int)\n    {\n\tif (entry->qf_prev == NULL\n\t\t|| entry->qf_prev->qf_fnum != entry->qf_fnum)\n\t    break;\n\n\tentry = entry->qf_prev;\n\t--*errornr;\n\n\t// If multiple entries are on the same line, then use the first entry\n\tif (linewise)\n\t    entry = qf_find_first_entry_on_line(entry, errornr);\n    }\n}\n\n/*\n * Find the n'th quickfix entry adjacent to position 'pos' in buffer 'bnr' in\n * the specified direction.  Returns the error number in the quickfix list or 0\n * if an entry is not found.\n */\n    static int\nqf_find_nth_adj_entry(\n\tqf_list_T\t*qfl,\n\tint\t\tbnr,\n\tpos_T\t\t*pos,\n\tint\t\tn,\n\tint\t\tdir,\n\tint\t\tlinewise)\n{\n    qfline_T\t*adj_entry;\n    int\t\terrornr;\n\n    // Find an entry closest to the specified position\n    adj_entry = qf_find_closest_entry(qfl, bnr, pos, dir, linewise, &errornr);\n    if (adj_entry == NULL)\n\treturn 0;\n\n    if (--n > 0)\n    {\n\t// Go to the n'th entry in the current buffer\n\tif (dir == FORWARD)\n\t    qf_get_nth_below_entry(adj_entry, n, linewise, &errornr);\n\telse\n\t    qf_get_nth_above_entry(adj_entry, n, linewise, &errornr);\n    }\n\n    return errornr;\n}\n\n/*\n * Jump to a quickfix entry in the current file nearest to the current line or\n * current line/col.\n * \":cabove\", \":cbelow\", \":labove\", \":lbelow\", \":cafter\", \":cbefore\",\n * \":lafter\" and \":lbefore\" commands\n */\n    void\nex_cbelow(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    qf_list_T\t*qfl;\n    int\t\tdir;\n    int\t\tbuf_has_flag;\n    int\t\terrornr = 0;\n    pos_T\tpos;\n\n    if (eap->addr_count > 0 && eap->line2 <= 0)\n    {\n\temsg(_(e_invalid_range));\n\treturn;\n    }\n\n    // Check whether the current buffer has any quickfix entries\n    if (eap->cmdidx == CMD_cabove || eap->cmdidx == CMD_cbelow\n\t    || eap->cmdidx == CMD_cbefore || eap->cmdidx == CMD_cafter)\n\tbuf_has_flag = BUF_HAS_QF_ENTRY;\n    else\n\tbuf_has_flag = BUF_HAS_LL_ENTRY;\n    if (!(curbuf->b_has_qf_entry & buf_has_flag))\n    {\n\temsg(_(e_no_errors));\n\treturn;\n    }\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    qfl = qf_get_curlist(qi);\n    // check if the list has valid errors\n    if (!qf_list_has_valid_entries(qfl))\n    {\n\temsg(_(e_no_errors));\n\treturn;\n    }\n\n    if (eap->cmdidx == CMD_cbelow\n\t    || eap->cmdidx == CMD_lbelow\n\t    || eap->cmdidx == CMD_cafter\n\t    || eap->cmdidx == CMD_lafter)\n\t// Forward motion commands\n\tdir = FORWARD;\n    else\n\tdir = BACKWARD;\n\n    pos = curwin->w_cursor;\n    // A quickfix entry column number is 1 based whereas cursor column\n    // number is 0 based. Adjust the column number.\n    pos.col++;\n    errornr = qf_find_nth_adj_entry(qfl, curbuf->b_fnum, &pos,\n\t\t\t\teap->addr_count > 0 ? eap->line2 : 0, dir,\n\t\t\t\teap->cmdidx == CMD_cbelow\n\t\t\t\t\t|| eap->cmdidx == CMD_lbelow\n\t\t\t\t\t|| eap->cmdidx == CMD_cabove\n\t\t\t\t\t|| eap->cmdidx == CMD_labove);\n\n    if (errornr > 0)\n\tqf_jump(qi, 0, errornr, FALSE);\n    else\n\temsg(_(e_no_more_items));\n}\n\n/*\n * Return the autocmd name for the :cfile Ex commands\n */\n    static char_u *\ncfile_get_auname(cmdidx_T cmdidx)\n{\n    switch (cmdidx)\n    {\n\tcase CMD_cfile:\t    return (char_u *)\"cfile\";\n\tcase CMD_cgetfile:  return (char_u *)\"cgetfile\";\n\tcase CMD_caddfile:  return (char_u *)\"caddfile\";\n\tcase CMD_lfile:\t    return (char_u *)\"lfile\";\n\tcase CMD_lgetfile:  return (char_u *)\"lgetfile\";\n\tcase CMD_laddfile:  return (char_u *)\"laddfile\";\n\tdefault:\t    return NULL;\n    }\n}\n\n/*\n * \":cfile\"/\":cgetfile\"/\":caddfile\" commands.\n * \":lfile\"/\":lgetfile\"/\":laddfile\" commands.\n */\n    void\nex_cfile(exarg_T *eap)\n{\n    char_u\t*enc = NULL;\n    win_T\t*wp = NULL;\n    qf_info_T\t*qi = &ql_info;\n    char_u\t*au_name = NULL;\n    int_u\tsave_qfid = 0;\t\t// init for gcc\n    int\t\tres;\n\n    au_name = cfile_get_auname(eap->cmdidx);\n    if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n\t\t\t\t\t\t\tNULL, FALSE, curbuf))\n    {\n#ifdef FEAT_EVAL\n\tif (aborting())\n\t    return;\n#endif\n    }\n\n    enc = (*curbuf->b_p_menc != NUL) ? curbuf->b_p_menc : p_menc;\n#ifdef FEAT_BROWSE\n    if (cmdmod.cmod_flags & CMOD_BROWSE)\n    {\n\tchar_u *browse_file = do_browse(0, (char_u *)_(\"Error file\"), eap->arg,\n\t\t\t\t   NULL, NULL,\n\t\t\t\t   (char_u *)_(BROWSE_FILTER_ALL_FILES), NULL);\n\tif (browse_file == NULL)\n\t    return;\n\tset_string_option_direct((char_u *)\"ef\", -1, browse_file, OPT_FREE, 0);\n\tvim_free(browse_file);\n    }\n    else\n#endif\n    if (*eap->arg != NUL)\n\tset_string_option_direct((char_u *)\"ef\", -1, eap->arg, OPT_FREE, 0);\n\n    if (is_loclist_cmd(eap->cmdidx))\n\twp = curwin;\n\n    incr_quickfix_busy();\n\n    // This function is used by the :cfile, :cgetfile and :caddfile\n    // commands.\n    // :cfile always creates a new quickfix list and jumps to the\n    // first error.\n    // :cgetfile creates a new quickfix list but doesn't jump to the\n    // first error.\n    // :caddfile adds to an existing quickfix list. If there is no\n    // quickfix list then a new list is created.\n    res = qf_init(wp, p_ef, p_efm, (eap->cmdidx != CMD_caddfile\n\t\t\t&& eap->cmdidx != CMD_laddfile),\n\t\t\tqf_cmdtitle(*eap->cmdlinep), enc);\n    if (wp != NULL)\n    {\n\tqi = GET_LOC_LIST(wp);\n\tif (qi == NULL)\n\t{\n\t    decr_quickfix_busy();\n\t    return;\n\t}\n    }\n    if (res >= 0)\n\tqf_list_changed(qf_get_curlist(qi));\n    save_qfid = qf_get_curlist(qi)->qf_id;\n    if (au_name != NULL)\n\tapply_autocmds(EVENT_QUICKFIXCMDPOST, au_name, NULL, FALSE, curbuf);\n\n    // Jump to the first error for a new list and if autocmds didn't\n    // free the list.\n    if (res > 0 && (eap->cmdidx == CMD_cfile || eap->cmdidx == CMD_lfile)\n\t    && qflist_valid(wp, save_qfid))\n\t// display the first error\n\tqf_jump_first(qi, save_qfid, eap->forceit);\n\n    decr_quickfix_busy();\n}\n\n/*\n * Return the vimgrep autocmd name.\n */\n    static char_u *\nvgr_get_auname(cmdidx_T cmdidx)\n{\n    switch (cmdidx)\n    {\n\tcase CMD_vimgrep:     return (char_u *)\"vimgrep\";\n\tcase CMD_lvimgrep:    return (char_u *)\"lvimgrep\";\n\tcase CMD_vimgrepadd:  return (char_u *)\"vimgrepadd\";\n\tcase CMD_lvimgrepadd: return (char_u *)\"lvimgrepadd\";\n\tcase CMD_grep:\t      return (char_u *)\"grep\";\n\tcase CMD_lgrep:\t      return (char_u *)\"lgrep\";\n\tcase CMD_grepadd:     return (char_u *)\"grepadd\";\n\tcase CMD_lgrepadd:    return (char_u *)\"lgrepadd\";\n\tdefault: return NULL;\n    }\n}\n\n/*\n * Initialize the regmatch used by vimgrep for pattern \"s\".\n */\n    static void\nvgr_init_regmatch(regmmatch_T *regmatch, char_u *s)\n{\n    // Get the search pattern: either white-separated or enclosed in //\n    regmatch->regprog = NULL;\n\n    if (s == NULL || *s == NUL)\n    {\n\t// Pattern is empty, use last search pattern.\n\tif (last_search_pat() == NULL)\n\t{\n\t    emsg(_(e_no_previous_regular_expression));\n\t    return;\n\t}\n\tregmatch->regprog = vim_regcomp(last_search_pat(), RE_MAGIC);\n    }\n    else\n\tregmatch->regprog = vim_regcomp(s, RE_MAGIC);\n\n    regmatch->rmm_ic = p_ic;\n    regmatch->rmm_maxcol = 0;\n}\n\n/*\n * Display a file name when vimgrep is running.\n */\n    static void\nvgr_display_fname(char_u *fname)\n{\n    char_u\t*p;\n\n    msg_start();\n    p = msg_strtrunc(fname, TRUE);\n    if (p == NULL)\n\tmsg_outtrans(fname);\n    else\n    {\n\tmsg_outtrans(p);\n\tvim_free(p);\n    }\n    msg_clr_eos();\n    msg_didout = FALSE;\t    // overwrite this message\n    msg_nowait = TRUE;\t    // don't wait for this message\n    msg_col = 0;\n    out_flush();\n}\n\n/*\n * Load a dummy buffer to search for a pattern using vimgrep.\n */\n    static buf_T *\nvgr_load_dummy_buf(\n\tchar_u *fname,\n\tchar_u *dirname_start,\n\tchar_u *dirname_now)\n{\n    int\t\tsave_mls;\n#if defined(FEAT_SYN_HL)\n    char_u\t*save_ei = NULL;\n#endif\n    buf_T\t*buf;\n\n#if defined(FEAT_SYN_HL)\n    // Don't do Filetype autocommands to avoid loading syntax and\n    // indent scripts, a great speed improvement.\n    save_ei = au_event_disable(\",Filetype\");\n#endif\n    // Don't use modelines here, it's useless.\n    save_mls = p_mls;\n    p_mls = 0;\n\n    // Load file into a buffer, so that 'fileencoding' is detected,\n    // autocommands applied, etc.\n    buf = load_dummy_buffer(fname, dirname_start, dirname_now);\n\n    p_mls = save_mls;\n#if defined(FEAT_SYN_HL)\n    au_event_restore(save_ei);\n#endif\n\n    return buf;\n}\n\n/*\n * Check whether a quickfix/location list is valid. Autocmds may remove or\n * change a quickfix list when vimgrep is running. If the list is not found,\n * create a new list.\n */\n    static int\nvgr_qflist_valid(\n\twin_T\t    *wp,\n\tqf_info_T   *qi,\n\tint_u\t    qfid,\n\tchar_u\t    *title)\n{\n    // Verify that the quickfix/location list was not freed by an autocmd\n    if (!qflist_valid(wp, qfid))\n    {\n\tif (wp != NULL)\n\t{\n\t    // An autocmd has freed the location list.\n\t    emsg(_(e_current_location_list_was_changed));\n\t    return FALSE;\n\t}\n\telse\n\t{\n\t    // Quickfix list is not found, create a new one.\n\t    qf_new_list(qi, title);\n\t    return TRUE;\n\t}\n    }\n\n    if (qf_restore_list(qi, qfid) == FAIL)\n\treturn FALSE;\n\n    return TRUE;\n}\n\n/*\n * Search for a pattern in all the lines in a buffer and add the matching lines\n * to a quickfix list.\n */\n    static int\nvgr_match_buflines(\n\tqf_list_T   *qfl,\n\tchar_u\t    *fname,\n\tbuf_T\t    *buf,\n\tchar_u\t    *spat,\n\tregmmatch_T *regmatch,\n\tlong\t    *tomatch,\n\tint\t    duplicate_name,\n\tint\t    flags)\n{\n    int\t\tfound_match = FALSE;\n    long\tlnum;\n    colnr_T\tcol;\n    int\t\tpat_len = (int)STRLEN(spat);\n\n    for (lnum = 1; lnum <= buf->b_ml.ml_line_count && *tomatch > 0; ++lnum)\n    {\n\tcol = 0;\n\tif (!(flags & VGR_FUZZY))\n\t{\n\t    // Regular expression match\n\t    while (vim_regexec_multi(regmatch, curwin, buf, lnum,\n\t\t\tcol, NULL) > 0)\n\t    {\n\t\t// Pass the buffer number so that it gets used even for a\n\t\t// dummy buffer, unless duplicate_name is set, then the\n\t\t// buffer will be wiped out below.\n\t\tif (qf_add_entry(qfl,\n\t\t\t    NULL,\t// dir\n\t\t\t    fname,\n\t\t\t    NULL,\n\t\t\t    duplicate_name ? 0 : buf->b_fnum,\n\t\t\t    ml_get_buf(buf,\n\t\t\t\tregmatch->startpos[0].lnum + lnum, FALSE),\n\t\t\t    regmatch->startpos[0].lnum + lnum,\n\t\t\t    regmatch->endpos[0].lnum + lnum,\n\t\t\t    regmatch->startpos[0].col + 1,\n\t\t\t    regmatch->endpos[0].col + 1,\n\t\t\t    FALSE,\t// vis_col\n\t\t\t    NULL,\t// search pattern\n\t\t\t    0,\t\t// nr\n\t\t\t    0,\t\t// type\n\t\t\t    TRUE\t// valid\n\t\t\t    ) == QF_FAIL)\n\t\t{\n\t\t    got_int = TRUE;\n\t\t    break;\n\t\t}\n\t\tfound_match = TRUE;\n\t\tif (--*tomatch == 0)\n\t\t    break;\n\t\tif ((flags & VGR_GLOBAL) == 0\n\t\t\t|| regmatch->endpos[0].lnum > 0)\n\t\t    break;\n\t\tcol = regmatch->endpos[0].col\n\t\t    + (col == regmatch->endpos[0].col);\n\t\tif (col > (colnr_T)STRLEN(ml_get_buf(buf, lnum, FALSE)))\n\t\t    break;\n\t    }\n\t}\n\telse\n\t{\n\t    char_u  *str = ml_get_buf(buf, lnum, FALSE);\n\t    int\t    score;\n\t    int_u   matches[MAX_FUZZY_MATCHES];\n\t    int_u   sz = ARRAY_LENGTH(matches);\n\n\t    // Fuzzy string match\n\t    while (fuzzy_match(str + col, spat, FALSE, &score, matches, sz) > 0)\n\t    {\n\t\t// Pass the buffer number so that it gets used even for a\n\t\t// dummy buffer, unless duplicate_name is set, then the\n\t\t// buffer will be wiped out below.\n\t\tif (qf_add_entry(qfl,\n\t\t\t    NULL,\t// dir\n\t\t\t    fname,\n\t\t\t    NULL,\n\t\t\t    duplicate_name ? 0 : buf->b_fnum,\n\t\t\t    str,\n\t\t\t    lnum,\n\t\t\t    0,\n\t\t\t    matches[0] + col + 1,\n\t\t\t    0,\n\t\t\t    FALSE,\t// vis_col\n\t\t\t    NULL,\t// search pattern\n\t\t\t    0,\t\t// nr\n\t\t\t    0,\t\t// type\n\t\t\t    TRUE\t// valid\n\t\t\t    ) == QF_FAIL)\n\t\t{\n\t\t    got_int = TRUE;\n\t\t    break;\n\t\t}\n\t\tfound_match = TRUE;\n\t\tif (--*tomatch == 0)\n\t\t    break;\n\t\tif ((flags & VGR_GLOBAL) == 0)\n\t\t    break;\n\t\tcol = matches[pat_len - 1] + col + 1;\n\t\tif (col > (colnr_T)STRLEN(str))\n\t\t    break;\n\t    }\n\t}\n\tline_breakcheck();\n\tif (got_int)\n\t    break;\n    }\n\n    return found_match;\n}\n\n/*\n * Jump to the first match and update the directory.\n */\n    static void\nvgr_jump_to_match(\n\tqf_info_T   *qi,\n\tint\t    forceit,\n\tint\t    *redraw_for_dummy,\n\tbuf_T\t    *first_match_buf,\n\tchar_u\t    *target_dir)\n{\n    buf_T\t*buf;\n\n    buf = curbuf;\n    qf_jump(qi, 0, 0, forceit);\n    if (buf != curbuf)\n\t// If we jumped to another buffer redrawing will already be\n\t// taken care of.\n\t*redraw_for_dummy = FALSE;\n\n    // Jump to the directory used after loading the buffer.\n    if (curbuf == first_match_buf && target_dir != NULL)\n    {\n\texarg_T ea;\n\n\tCLEAR_FIELD(ea);\n\tea.arg = target_dir;\n\tea.cmdidx = CMD_lcd;\n\tex_cd(&ea);\n    }\n}\n\n/*\n * :vimgrep command arguments\n */\ntypedef struct\n{\n    long\ttomatch;\t// maximum number of matches to find\n    char_u\t*spat;\t\t// search pattern\n    int\t\tflags;\t\t// search modifier\n    char_u\t**fnames;\t// list of files to search\n    int\t\tfcount;\t\t// number of files\n    regmmatch_T\tregmatch;\t// compiled search pattern\n    char_u\t*qf_title;\t// quickfix list title\n} vgr_args_T;\n\n/*\n * Process :vimgrep command arguments. The command syntax is:\n *\n *\t:{count}vimgrep /{pattern}/[g][j] {file} ...\n */\n    static int\nvgr_process_args(\n\texarg_T\t\t*eap,\n\tvgr_args_T\t*args)\n{\n    char_u\t*p;\n\n    vim_memset(args, 0, sizeof(*args));\n\n    args->regmatch.regprog = NULL;\n    args->qf_title = vim_strsave(qf_cmdtitle(*eap->cmdlinep));\n\n    if (eap->addr_count > 0)\n\targs->tomatch = eap->line2;\n    else\n\targs->tomatch = MAXLNUM;\n\n    // Get the search pattern: either white-separated or enclosed in //\n    p = skip_vimgrep_pat(eap->arg, &args->spat, &args->flags);\n    if (p == NULL)\n    {\n\temsg(_(e_invalid_search_pattern_or_delimiter));\n\treturn FAIL;\n    }\n\n    vgr_init_regmatch(&args->regmatch, args->spat);\n    if (args->regmatch.regprog == NULL)\n\treturn FAIL;\n\n    p = skipwhite(p);\n    if (*p == NUL)\n    {\n\temsg(_(e_file_name_missing_or_invalid_pattern));\n\treturn FAIL;\n    }\n\n    // Parse the list of arguments, wildcards have already been expanded.\n    if ((get_arglist_exp(p, &args->fcount, &args->fnames, TRUE) == FAIL) ||\n\targs->fcount == 0)\n    {\n\temsg(_(e_no_match));\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * Return TRUE if \"buf\" had an existing swap file, the current swap file does\n * not end in \".swp\".\n */\n    static int\nexisting_swapfile(buf_T *buf)\n{\n    if (buf->b_ml.ml_mfp != NULL && buf->b_ml.ml_mfp->mf_fname != NULL)\n    {\n\tchar_u *fname = buf->b_ml.ml_mfp->mf_fname;\n\tsize_t len = STRLEN(fname);\n\n\treturn fname[len - 1] != 'p' || fname[len - 2] != 'w';\n    }\n    return FALSE;\n}\n\n/*\n * Search for a pattern in a list of files and populate the quickfix list with\n * the matches.\n */\n    static int\nvgr_process_files(\n\twin_T\t\t*wp,\n\tqf_info_T\t*qi,\n\tvgr_args_T\t*cmd_args,\n\tint\t\t*redraw_for_dummy,\n\tbuf_T\t\t**first_match_buf,\n\tchar_u\t\t**target_dir)\n{\n    int\t\tstatus = FAIL;\n    int_u\tsave_qfid = qf_get_curlist(qi)->qf_id;\n    time_t\tseconds = 0;\n    char_u\t*fname;\n    int\t\tfi;\n    buf_T\t*buf;\n    int\t\tduplicate_name = FALSE;\n    int\t\tusing_dummy;\n    char_u\t*dirname_start = NULL;\n    char_u\t*dirname_now = NULL;\n    int\t\tfound_match;\n    aco_save_T\taco;\n\n    dirname_start = alloc_id(MAXPATHL, aid_qf_dirname_start);\n    dirname_now = alloc_id(MAXPATHL, aid_qf_dirname_now);\n    if (dirname_start == NULL || dirname_now == NULL)\n\tgoto theend;\n\n    // Remember the current directory, because a BufRead autocommand that does\n    // \":lcd %:p:h\" changes the meaning of short path names.\n    mch_dirname(dirname_start, MAXPATHL);\n\n    seconds = (time_t)0;\n    for (fi = 0; fi < cmd_args->fcount && !got_int && cmd_args->tomatch > 0;\n\t\t\t\t\t\t\t\t\t++fi)\n    {\n\tfname = shorten_fname1(cmd_args->fnames[fi]);\n\tif (time(NULL) > seconds)\n\t{\n\t    // Display the file name every second or so, show the user we are\n\t    // working on it.\n\t    seconds = time(NULL);\n\t    vgr_display_fname(fname);\n\t}\n\n\tbuf = buflist_findname_exp(cmd_args->fnames[fi]);\n\tif (buf == NULL || buf->b_ml.ml_mfp == NULL)\n\t{\n\t    // Remember that a buffer with this name already exists.\n\t    duplicate_name = (buf != NULL);\n\t    using_dummy = TRUE;\n\t    *redraw_for_dummy = TRUE;\n\n\t    buf = vgr_load_dummy_buf(fname, dirname_start, dirname_now);\n\t}\n\telse\n\t    // Use existing, loaded buffer.\n\t    using_dummy = FALSE;\n\n\t// Check whether the quickfix list is still valid. When loading a\n\t// buffer above, autocommands might have changed the quickfix list.\n\tif (!vgr_qflist_valid(wp, qi, save_qfid, cmd_args->qf_title))\n\t    goto theend;\n\n\tsave_qfid = qf_get_curlist(qi)->qf_id;\n\n\tif (buf == NULL)\n\t{\n\t    if (!got_int)\n\t\tsmsg(_(\"Cannot open file \\\"%s\\\"\"), fname);\n\t}\n\telse\n\t{\n\t    // Try for a match in all lines of the buffer.\n\t    // For \":1vimgrep\" look for first match only.\n\t    found_match = vgr_match_buflines(qf_get_curlist(qi),\n\t\t    fname, buf, cmd_args->spat, &cmd_args->regmatch,\n\t\t    &cmd_args->tomatch, duplicate_name, cmd_args->flags);\n\n\t    if (using_dummy)\n\t    {\n\t\tif (found_match && *first_match_buf == NULL)\n\t\t    *first_match_buf = buf;\n\t\tif (duplicate_name)\n\t\t{\n\t\t    // Never keep a dummy buffer if there is another buffer\n\t\t    // with the same name.\n\t\t    wipe_dummy_buffer(buf, dirname_start);\n\t\t    buf = NULL;\n\t\t}\n\t\telse if ((cmdmod.cmod_flags & CMOD_HIDE) == 0\n\t\t\t    || buf->b_p_bh[0] == 'u'\t// \"unload\"\n\t\t\t    || buf->b_p_bh[0] == 'w'\t// \"wipe\"\n\t\t\t    || buf->b_p_bh[0] == 'd')\t// \"delete\"\n\t\t{\n\t\t    // When no match was found we don't need to remember the\n\t\t    // buffer, wipe it out.  If there was a match and it\n\t\t    // wasn't the first one or we won't jump there: only\n\t\t    // unload the buffer.\n\t\t    // Ignore 'hidden' here, because it may lead to having too\n\t\t    // many swap files.\n\t\t    if (!found_match)\n\t\t    {\n\t\t\twipe_dummy_buffer(buf, dirname_start);\n\t\t\tbuf = NULL;\n\t\t    }\n\t\t    else if (buf != *first_match_buf\n\t\t\t\t\t|| (cmd_args->flags & VGR_NOJUMP)\n\t\t\t\t\t|| existing_swapfile(buf))\n\t\t    {\n\t\t\tunload_dummy_buffer(buf, dirname_start);\n\t\t\t// Keeping the buffer, remove the dummy flag.\n\t\t\tbuf->b_flags &= ~BF_DUMMY;\n\t\t\tbuf = NULL;\n\t\t    }\n\t\t}\n\n\t\tif (buf != NULL)\n\t\t{\n\t\t    // Keeping the buffer, remove the dummy flag.\n\t\t    buf->b_flags &= ~BF_DUMMY;\n\n\t\t    // If the buffer is still loaded we need to use the\n\t\t    // directory we jumped to below.\n\t\t    if (buf == *first_match_buf\n\t\t\t    && *target_dir == NULL\n\t\t\t    && STRCMP(dirname_start, dirname_now) != 0)\n\t\t\t*target_dir = vim_strsave(dirname_now);\n\n\t\t    // The buffer is still loaded, the Filetype autocommands\n\t\t    // need to be done now, in that buffer.  And the modelines\n\t\t    // need to be done (again).  But not the window-local\n\t\t    // options!\n\t\t    aucmd_prepbuf(&aco, buf);\n#if defined(FEAT_SYN_HL)\n\t\t    apply_autocmds(EVENT_FILETYPE, buf->b_p_ft,\n\t\t\t\t\t\t     buf->b_fname, TRUE, buf);\n#endif\n\t\t    do_modelines(OPT_NOWIN);\n\t\t    aucmd_restbuf(&aco);\n\t\t}\n\t    }\n\t}\n    }\n\n    status = OK;\n\ntheend:\n    vim_free(dirname_now);\n    vim_free(dirname_start);\n    return status;\n}\n\n/*\n * \":vimgrep {pattern} file(s)\"\n * \":vimgrepadd {pattern} file(s)\"\n * \":lvimgrep {pattern} file(s)\"\n * \":lvimgrepadd {pattern} file(s)\"\n */\n    void\nex_vimgrep(exarg_T *eap)\n{\n    vgr_args_T\targs;\n    qf_info_T\t*qi;\n    qf_list_T\t*qfl;\n    int_u\tsave_qfid;\n    win_T\t*wp = NULL;\n    int\t\tredraw_for_dummy = FALSE;\n    buf_T\t*first_match_buf = NULL;\n    char_u\t*target_dir = NULL;\n    char_u\t*au_name =  NULL;\n    int\t\tstatus;\n\n    au_name = vgr_get_auname(eap->cmdidx);\n    if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf))\n    {\n#ifdef FEAT_EVAL\n\tif (aborting())\n\t    return;\n#endif\n    }\n\n    qi = qf_cmd_get_or_alloc_stack(eap, &wp);\n    if (qi == NULL)\n\treturn;\n\n    if (vgr_process_args(eap, &args) == FAIL)\n\tgoto theend;\n\n    if ((eap->cmdidx != CMD_grepadd && eap->cmdidx != CMD_lgrepadd\n\t\t&& eap->cmdidx != CMD_vimgrepadd\n\t\t&& eap->cmdidx != CMD_lvimgrepadd)\n\t\t\t\t\t|| qf_stack_empty(qi))\n\t// make place for a new list\n\tqf_new_list(qi, args.qf_title);\n\n    incr_quickfix_busy();\n\n    status = vgr_process_files(wp, qi, &args, &redraw_for_dummy,\n\t\t\t\t\t\t&first_match_buf, &target_dir);\n    if (status != OK)\n    {\n\tFreeWild(args.fcount, args.fnames);\n\tdecr_quickfix_busy();\n\tgoto theend;\n    }\n\n    FreeWild(args.fcount, args.fnames);\n\n    qfl = qf_get_curlist(qi);\n    qfl->qf_nonevalid = FALSE;\n    qfl->qf_ptr = qfl->qf_start;\n    qfl->qf_index = 1;\n    qf_list_changed(qfl);\n\n    qf_update_buffer(qi, NULL);\n\n    // Remember the current quickfix list identifier, so that we can check for\n    // autocommands changing the current quickfix list.\n    save_qfid = qf_get_curlist(qi)->qf_id;\n\n    if (au_name != NULL)\n\tapply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf);\n    // The QuickFixCmdPost autocmd may free the quickfix list. Check the list\n    // is still valid.\n    if (!qflist_valid(wp, save_qfid)\n\t    || qf_restore_list(qi, save_qfid) == FAIL)\n    {\n\tdecr_quickfix_busy();\n\tgoto theend;\n    }\n\n    // Jump to first match.\n    if (!qf_list_empty(qf_get_curlist(qi)))\n    {\n\tif ((args.flags & VGR_NOJUMP) == 0)\n\t    vgr_jump_to_match(qi, eap->forceit, &redraw_for_dummy,\n\t\t    first_match_buf, target_dir);\n    }\n    else\n\tsemsg(_(e_no_match_str_2), args.spat);\n\n    decr_quickfix_busy();\n\n    // If we loaded a dummy buffer into the current window, the autocommands\n    // may have messed up things, need to redraw and recompute folds.\n    if (redraw_for_dummy)\n    {\n#ifdef FEAT_FOLDING\n\tfoldUpdateAll(curwin);\n#else\n\tredraw_later(UPD_NOT_VALID);\n#endif\n    }\n\ntheend:\n    vim_free(args.qf_title);\n    vim_free(target_dir);\n    vim_regfree(args.regmatch.regprog);\n}\n\n/*\n * Restore current working directory to \"dirname_start\" if they differ, taking\n * into account whether it is set locally or globally.\n */\n    static void\nrestore_start_dir(char_u *dirname_start)\n{\n    char_u *dirname_now = alloc(MAXPATHL);\n\n    if (NULL != dirname_now)\n    {\n\tmch_dirname(dirname_now, MAXPATHL);\n\tif (STRCMP(dirname_start, dirname_now) != 0)\n\t{\n\t    // If the directory has changed, change it back by building up an\n\t    // appropriate ex command and executing it.\n\t    exarg_T ea;\n\n\t    CLEAR_FIELD(ea);\n\t    ea.arg = dirname_start;\n\t    ea.cmdidx = (curwin->w_localdir == NULL) ? CMD_cd : CMD_lcd;\n\t    ex_cd(&ea);\n\t}\n\tvim_free(dirname_now);\n    }\n}\n\n/*\n * Load file \"fname\" into a dummy buffer and return the buffer pointer,\n * placing the directory resulting from the buffer load into the\n * \"resulting_dir\" pointer. \"resulting_dir\" must be allocated by the caller\n * prior to calling this function. Restores directory to \"dirname_start\" prior\n * to returning, if autocmds or the 'autochdir' option have changed it.\n *\n * If creating the dummy buffer does not fail, must call unload_dummy_buffer()\n * or wipe_dummy_buffer() later!\n *\n * Returns NULL if it fails.\n */\n    static buf_T *\nload_dummy_buffer(\n    char_u\t*fname,\n    char_u\t*dirname_start,  // in: old directory\n    char_u\t*resulting_dir)  // out: new directory\n{\n    buf_T\t*newbuf;\n    bufref_T\tnewbufref;\n    bufref_T\tnewbuf_to_wipe;\n    int\t\tfailed = TRUE;\n    aco_save_T\taco;\n    int\t\treadfile_result;\n\n    // Allocate a buffer without putting it in the buffer list.\n    newbuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);\n    if (newbuf == NULL)\n\treturn NULL;\n    set_bufref(&newbufref, newbuf);\n\n    // Init the options.\n    buf_copy_options(newbuf, BCO_ENTER | BCO_NOHELP);\n\n    // need to open the memfile before putting the buffer in a window\n    if (ml_open(newbuf) == OK)\n    {\n\t// Make sure this buffer isn't wiped out by autocommands.\n\t++newbuf->b_locked;\n\n\t// set curwin/curbuf to buf and save a few things\n\taucmd_prepbuf(&aco, newbuf);\n\n\t// Need to set the filename for autocommands.\n\t(void)setfname(curbuf, fname, NULL, FALSE);\n\n\t// Create swap file now to avoid the ATTENTION message.\n\tcheck_need_swap(TRUE);\n\n\t// Remove the \"dummy\" flag, otherwise autocommands may not\n\t// work.\n\tcurbuf->b_flags &= ~BF_DUMMY;\n\n\tnewbuf_to_wipe.br_buf = NULL;\n\treadfile_result = readfile(fname, NULL,\n\t\t    (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM,\n\t\t    NULL, READ_NEW | READ_DUMMY);\n\t--newbuf->b_locked;\n\tif (readfile_result == OK\n\t\t&& !got_int\n\t\t&& !(curbuf->b_flags & BF_NEW))\n\t{\n\t    failed = FALSE;\n\t    if (curbuf != newbuf)\n\t    {\n\t\t// Bloody autocommands changed the buffer!  Can happen when\n\t\t// using netrw and editing a remote file.  Use the current\n\t\t// buffer instead, delete the dummy one after restoring the\n\t\t// window stuff.\n\t\tset_bufref(&newbuf_to_wipe, newbuf);\n\t\tnewbuf = curbuf;\n\t    }\n\t}\n\n\t// restore curwin/curbuf and a few other things\n\taucmd_restbuf(&aco);\n\tif (newbuf_to_wipe.br_buf != NULL && bufref_valid(&newbuf_to_wipe))\n\t    wipe_buffer(newbuf_to_wipe.br_buf, FALSE);\n\n\t// Add back the \"dummy\" flag, otherwise buflist_findname_stat() won't\n\t// skip it.\n\tnewbuf->b_flags |= BF_DUMMY;\n    }\n\n    // When autocommands/'autochdir' option changed directory: go back.\n    // Let the caller know what the resulting dir was first, in case it is\n    // important.\n    mch_dirname(resulting_dir, MAXPATHL);\n    restore_start_dir(dirname_start);\n\n    if (!bufref_valid(&newbufref))\n\treturn NULL;\n    if (failed)\n    {\n\twipe_dummy_buffer(newbuf, dirname_start);\n\treturn NULL;\n    }\n    return newbuf;\n}\n\n/*\n * Wipe out the dummy buffer that load_dummy_buffer() created. Restores\n * directory to \"dirname_start\" prior to returning, if autocmds or the\n * 'autochdir' option have changed it.\n */\n    static void\nwipe_dummy_buffer(buf_T *buf, char_u *dirname_start)\n{\n    // If any autocommand opened a window on the dummy buffer, close that\n    // window.  If we can't close them all then give up.\n    while (buf->b_nwindows > 0)\n    {\n\tint\t    did_one = FALSE;\n\twin_T\t    *wp;\n\n\tif (firstwin->w_next != NULL)\n\t    FOR_ALL_WINDOWS(wp)\n\t\tif (wp->w_buffer == buf)\n\t\t{\n\t\t    if (win_close(wp, FALSE) == OK)\n\t\t\tdid_one = TRUE;\n\t\t    break;\n\t\t}\n\tif (!did_one)\n\t    return;\n    }\n\n    if (curbuf != buf && buf->b_nwindows == 0)\t// safety check\n    {\n#if defined(FEAT_EVAL)\n\tcleanup_T   cs;\n\n\t// Reset the error/interrupt/exception state here so that aborting()\n\t// returns FALSE when wiping out the buffer.  Otherwise it doesn't\n\t// work when got_int is set.\n\tenter_cleanup(&cs);\n#endif\n\n\twipe_buffer(buf, TRUE);\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n\t// When autocommands/'autochdir' option changed directory: go back.\n\trestore_start_dir(dirname_start);\n    }\n}\n\n/*\n * Unload the dummy buffer that load_dummy_buffer() created. Restores\n * directory to \"dirname_start\" prior to returning, if autocmds or the\n * 'autochdir' option have changed it.\n */\n    static void\nunload_dummy_buffer(buf_T *buf, char_u *dirname_start)\n{\n    if (curbuf != buf)\t\t// safety check\n    {\n\tclose_buffer(NULL, buf, DOBUF_UNLOAD, FALSE, TRUE);\n\n\t// When autocommands/'autochdir' option changed directory: go back.\n\trestore_start_dir(dirname_start);\n    }\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Copy the specified quickfix entry items into a new dict and append the dict\n * to 'list'.  Returns OK on success.\n */\n    static int\nget_qfline_items(qfline_T *qfp, list_T *list)\n{\n    int\t\tbufnum;\n    dict_T\t*dict;\n    char_u\tbuf[2];\n\n    // Handle entries with a non-existing buffer number.\n    bufnum = qfp->qf_fnum;\n    if (bufnum != 0 && (buflist_findnr(bufnum) == NULL))\n\tbufnum = 0;\n\n    if ((dict = dict_alloc()) == NULL)\n\treturn FAIL;\n    if (list_append_dict(list, dict) == FAIL)\n\treturn FAIL;\n\n    buf[0] = qfp->qf_type;\n    buf[1] = NUL;\n    if (dict_add_number(dict, \"bufnr\", (long)bufnum) == FAIL\n\t    || dict_add_number(dict, \"lnum\",     (long)qfp->qf_lnum) == FAIL\n\t    || dict_add_number(dict, \"end_lnum\", (long)qfp->qf_end_lnum) == FAIL\n\t    || dict_add_number(dict, \"col\",      (long)qfp->qf_col) == FAIL\n\t    || dict_add_number(dict, \"end_col\",  (long)qfp->qf_end_col) == FAIL\n\t    || dict_add_number(dict, \"vcol\",     (long)qfp->qf_viscol) == FAIL\n\t    || dict_add_number(dict, \"nr\",       (long)qfp->qf_nr) == FAIL\n\t    || dict_add_string(dict, \"module\", qfp->qf_module) == FAIL\n\t    || dict_add_string(dict, \"pattern\", qfp->qf_pattern) == FAIL\n\t    || dict_add_string(dict, \"text\", qfp->qf_text) == FAIL\n\t    || dict_add_string(dict, \"type\", buf) == FAIL\n\t    || dict_add_number(dict, \"valid\", (long)qfp->qf_valid) == FAIL)\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * Add each quickfix error to list \"list\" as a dictionary.\n * If qf_idx is -1, use the current list. Otherwise, use the specified list.\n * If eidx is not 0, then return only the specified entry. Otherwise return\n * all the entries.\n */\n    static int\nget_errorlist(\n\tqf_info_T\t*qi_arg,\n\twin_T\t\t*wp,\n\tint\t\tqf_idx,\n\tint\t\teidx,\n\tlist_T\t\t*list)\n{\n    qf_info_T\t*qi = qi_arg;\n    qf_list_T\t*qfl;\n    qfline_T\t*qfp;\n    int\t\ti;\n\n    if (qi == NULL)\n    {\n\tqi = &ql_info;\n\tif (wp != NULL)\n\t{\n\t    qi = GET_LOC_LIST(wp);\n\t    if (qi == NULL)\n\t\treturn FAIL;\n\t}\n    }\n\n    if (eidx < 0)\n\treturn OK;\n\n    if (qf_idx == INVALID_QFIDX)\n\tqf_idx = qi->qf_curlist;\n\n    if (qf_idx >= qi->qf_listcount)\n\treturn FAIL;\n\n    qfl = qf_get_list(qi, qf_idx);\n    if (qf_list_empty(qfl))\n\treturn FAIL;\n\n    FOR_ALL_QFL_ITEMS(qfl, qfp, i)\n    {\n\tif (eidx > 0)\n\t{\n\t    if (eidx == i)\n\t\treturn get_qfline_items(qfp, list);\n\t}\n\telse if (get_qfline_items(qfp, list) == FAIL)\n\t    return FAIL;\n    }\n\n    return OK;\n}\n\n// Flags used by getqflist()/getloclist() to determine which fields to return.\nenum {\n    QF_GETLIST_NONE\t= 0x0,\n    QF_GETLIST_TITLE\t= 0x1,\n    QF_GETLIST_ITEMS\t= 0x2,\n    QF_GETLIST_NR\t= 0x4,\n    QF_GETLIST_WINID\t= 0x8,\n    QF_GETLIST_CONTEXT\t= 0x10,\n    QF_GETLIST_ID\t= 0x20,\n    QF_GETLIST_IDX\t= 0x40,\n    QF_GETLIST_SIZE\t= 0x80,\n    QF_GETLIST_TICK\t= 0x100,\n    QF_GETLIST_FILEWINID\t= 0x200,\n    QF_GETLIST_QFBUFNR\t= 0x400,\n    QF_GETLIST_QFTF\t= 0x800,\n    QF_GETLIST_ALL\t= 0xFFF,\n};\n\n/*\n * Parse text from 'di' and return the quickfix list items.\n * Existing quickfix lists are not modified.\n */\n    static int\nqf_get_list_from_lines(dict_T *what, dictitem_T *di, dict_T *retdict)\n{\n    int\t\tstatus = FAIL;\n    qf_info_T\t*qi;\n    char_u\t*errorformat = p_efm;\n    dictitem_T\t*efm_di;\n    list_T\t*l;\n\n    // Only a List value is supported\n    if (di->di_tv.v_type == VAR_LIST && di->di_tv.vval.v_list != NULL)\n    {\n\t// If errorformat is supplied then use it, otherwise use the 'efm'\n\t// option setting\n\tif ((efm_di = dict_find(what, (char_u *)\"efm\", -1)) != NULL)\n\t{\n\t    if (efm_di->di_tv.v_type != VAR_STRING ||\n\t\t    efm_di->di_tv.vval.v_string == NULL)\n\t\treturn FAIL;\n\t    errorformat = efm_di->di_tv.vval.v_string;\n\t}\n\n\tl = list_alloc();\n\tif (l == NULL)\n\t    return FAIL;\n\n\tqi = qf_alloc_stack(QFLT_INTERNAL);\n\tif (qi != NULL)\n\t{\n\t    if (qf_init_ext(qi, 0, NULL, NULL, &di->di_tv, errorformat,\n\t\t\tTRUE, (linenr_T)0, (linenr_T)0, NULL, NULL) > 0)\n\t    {\n\t\t(void)get_errorlist(qi, NULL, 0, 0, l);\n\t\tqf_free(&qi->qf_lists[0]);\n\t    }\n\t    free(qi);\n\t}\n\tdict_add_list(retdict, \"items\", l);\n\tstatus = OK;\n    }\n\n    return status;\n}\n\n/*\n * Return the quickfix/location list window identifier in the current tabpage.\n */\n    static int\nqf_winid(qf_info_T *qi)\n{\n    win_T\t*win;\n\n    // The quickfix window can be opened even if the quickfix list is not set\n    // using \":copen\". This is not true for location lists.\n    if (qi == NULL)\n\treturn 0;\n    win = qf_find_win(qi);\n    if (win != NULL)\n\treturn win->w_id;\n    return 0;\n}\n\n/*\n * Returns the number of the buffer displayed in the quickfix/location list\n * window. If there is no buffer associated with the list or the buffer is\n * wiped out, then returns 0.\n */\n    static int\nqf_getprop_qfbufnr(qf_info_T *qi, dict_T *retdict)\n{\n    int\tbufnum = 0;\n\n    if (qi != NULL && buflist_findnr(qi->qf_bufnr) != NULL)\n\tbufnum = qi->qf_bufnr;\n\n    return dict_add_number(retdict, \"qfbufnr\", bufnum);\n}\n\n/*\n * Convert the keys in 'what' to quickfix list property flags.\n */\n    static int\nqf_getprop_keys2flags(dict_T *what, int loclist)\n{\n    int\t\tflags = QF_GETLIST_NONE;\n\n    if (dict_has_key(what, \"all\"))\n    {\n\tflags |= QF_GETLIST_ALL;\n\tif (!loclist)\n\t    // File window ID is applicable only to location list windows\n\t    flags &= ~ QF_GETLIST_FILEWINID;\n    }\n\n    if (dict_has_key(what, \"title\"))\n\tflags |= QF_GETLIST_TITLE;\n\n    if (dict_has_key(what, \"nr\"))\n\tflags |= QF_GETLIST_NR;\n\n    if (dict_has_key(what, \"winid\"))\n\tflags |= QF_GETLIST_WINID;\n\n    if (dict_has_key(what, \"context\"))\n\tflags |= QF_GETLIST_CONTEXT;\n\n    if (dict_has_key(what, \"id\"))\n\tflags |= QF_GETLIST_ID;\n\n    if (dict_has_key(what, \"items\"))\n\tflags |= QF_GETLIST_ITEMS;\n\n    if (dict_has_key(what, \"idx\"))\n\tflags |= QF_GETLIST_IDX;\n\n    if (dict_has_key(what, \"size\"))\n\tflags |= QF_GETLIST_SIZE;\n\n    if (dict_has_key(what, \"changedtick\"))\n\tflags |= QF_GETLIST_TICK;\n\n    if (loclist && dict_has_key(what, \"filewinid\"))\n\tflags |= QF_GETLIST_FILEWINID;\n\n    if (dict_has_key(what, \"qfbufnr\"))\n\tflags |= QF_GETLIST_QFBUFNR;\n\n    if (dict_has_key(what, \"quickfixtextfunc\"))\n\tflags |= QF_GETLIST_QFTF;\n\n    return flags;\n}\n\n/*\n * Return the quickfix list index based on 'nr' or 'id' in 'what'.\n * If 'nr' and 'id' are not present in 'what' then return the current\n * quickfix list index.\n * If 'nr' is zero then return the current quickfix list index.\n * If 'nr' is '$' then return the last quickfix list index.\n * If 'id' is present then return the index of the quickfix list with that id.\n * If 'id' is zero then return the quickfix list index specified by 'nr'.\n * Return -1, if quickfix list is not present or if the stack is empty.\n */\n    static int\nqf_getprop_qfidx(qf_info_T *qi, dict_T *what)\n{\n    int\t\tqf_idx;\n    dictitem_T\t*di;\n\n    qf_idx = qi->qf_curlist;\t// default is the current list\n    if ((di = dict_find(what, (char_u *)\"nr\", -1)) != NULL)\n    {\n\t// Use the specified quickfix/location list\n\tif (di->di_tv.v_type == VAR_NUMBER)\n\t{\n\t    // for zero use the current list\n\t    if (di->di_tv.vval.v_number != 0)\n\t    {\n\t\tqf_idx = di->di_tv.vval.v_number - 1;\n\t\tif (qf_idx < 0 || qf_idx >= qi->qf_listcount)\n\t\t    qf_idx = INVALID_QFIDX;\n\t    }\n\t}\n\telse if (di->di_tv.v_type == VAR_STRING\n\t\t&& di->di_tv.vval.v_string != NULL\n\t\t&& STRCMP(di->di_tv.vval.v_string, \"$\") == 0)\n\t    // Get the last quickfix list number\n\t    qf_idx = qi->qf_listcount - 1;\n\telse\n\t    qf_idx = INVALID_QFIDX;\n    }\n\n    if ((di = dict_find(what, (char_u *)\"id\", -1)) != NULL)\n    {\n\t// Look for a list with the specified id\n\tif (di->di_tv.v_type == VAR_NUMBER)\n\t{\n\t    // For zero, use the current list or the list specified by 'nr'\n\t    if (di->di_tv.vval.v_number != 0)\n\t\tqf_idx = qf_id2nr(qi, di->di_tv.vval.v_number);\n\t}\n\telse\n\t    qf_idx = INVALID_QFIDX;\n    }\n\n    return qf_idx;\n}\n\n/*\n * Return default values for quickfix list properties in retdict.\n */\n    static int\nqf_getprop_defaults(qf_info_T *qi, int flags, int locstack, dict_T *retdict)\n{\n    int\t\tstatus = OK;\n\n    if (flags & QF_GETLIST_TITLE)\n\tstatus = dict_add_string(retdict, \"title\", (char_u *)\"\");\n    if ((status == OK) && (flags & QF_GETLIST_ITEMS))\n    {\n\tlist_T\t*l = list_alloc();\n\tif (l != NULL)\n\t    status = dict_add_list(retdict, \"items\", l);\n\telse\n\t    status = FAIL;\n    }\n    if ((status == OK) && (flags & QF_GETLIST_NR))\n\tstatus = dict_add_number(retdict, \"nr\", 0);\n    if ((status == OK) && (flags & QF_GETLIST_WINID))\n\tstatus = dict_add_number(retdict, \"winid\", qf_winid(qi));\n    if ((status == OK) && (flags & QF_GETLIST_CONTEXT))\n\tstatus = dict_add_string(retdict, \"context\", (char_u *)\"\");\n    if ((status == OK) && (flags & QF_GETLIST_ID))\n\tstatus = dict_add_number(retdict, \"id\", 0);\n    if ((status == OK) && (flags & QF_GETLIST_IDX))\n\tstatus = dict_add_number(retdict, \"idx\", 0);\n    if ((status == OK) && (flags & QF_GETLIST_SIZE))\n\tstatus = dict_add_number(retdict, \"size\", 0);\n    if ((status == OK) && (flags & QF_GETLIST_TICK))\n\tstatus = dict_add_number(retdict, \"changedtick\", 0);\n    if ((status == OK) && locstack && (flags & QF_GETLIST_FILEWINID))\n\tstatus = dict_add_number(retdict, \"filewinid\", 0);\n    if ((status == OK) && (flags & QF_GETLIST_QFBUFNR))\n\tstatus = qf_getprop_qfbufnr(qi, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_QFTF))\n\tstatus = dict_add_string(retdict, \"quickfixtextfunc\", (char_u *)\"\");\n\n    return status;\n}\n\n/*\n * Return the quickfix list title as 'title' in retdict\n */\n    static int\nqf_getprop_title(qf_list_T *qfl, dict_T *retdict)\n{\n    return dict_add_string(retdict, \"title\", qfl->qf_title);\n}\n\n/*\n * Returns the identifier of the window used to display files from a location\n * list.  If there is no associated window, then returns 0. Useful only when\n * called from a location list window.\n */\n    static int\nqf_getprop_filewinid(win_T *wp, qf_info_T *qi, dict_T *retdict)\n{\n    int winid = 0;\n\n    if (wp != NULL && IS_LL_WINDOW(wp))\n    {\n\twin_T\t*ll_wp = qf_find_win_with_loclist(qi);\n\tif (ll_wp != NULL)\n\t    winid = ll_wp->w_id;\n    }\n\n    return dict_add_number(retdict, \"filewinid\", winid);\n}\n\n/*\n * Return the quickfix list items/entries as 'items' in retdict.\n * If eidx is not 0, then return the item at the specified index.\n */\n    static int\nqf_getprop_items(qf_info_T *qi, int qf_idx, int eidx, dict_T *retdict)\n{\n    int\t\tstatus = OK;\n    list_T\t*l = list_alloc();\n    if (l != NULL)\n    {\n\t(void)get_errorlist(qi, NULL, qf_idx, eidx, l);\n\tdict_add_list(retdict, \"items\", l);\n    }\n    else\n\tstatus = FAIL;\n\n    return status;\n}\n\n/*\n * Return the quickfix list context (if any) as 'context' in retdict.\n */\n    static int\nqf_getprop_ctx(qf_list_T *qfl, dict_T *retdict)\n{\n    int\t\tstatus;\n    dictitem_T\t*di;\n\n    if (qfl->qf_ctx != NULL)\n    {\n\tdi = dictitem_alloc((char_u *)\"context\");\n\tif (di != NULL)\n\t{\n\t    copy_tv(qfl->qf_ctx, &di->di_tv);\n\t    status = dict_add(retdict, di);\n\t    if (status == FAIL)\n\t\tdictitem_free(di);\n\t}\n\telse\n\t    status = FAIL;\n    }\n    else\n\tstatus = dict_add_string(retdict, \"context\", (char_u *)\"\");\n\n    return status;\n}\n\n/*\n * Return the current quickfix list index as 'idx' in retdict.\n * If a specific entry index (eidx) is supplied, then use that.\n */\n    static int\nqf_getprop_idx(qf_list_T *qfl, int eidx, dict_T *retdict)\n{\n    if (eidx == 0)\n    {\n\teidx = qfl->qf_index;\n\tif (qf_list_empty(qfl))\n\t    // For empty lists, current index is set to 0\n\t    eidx = 0;\n    }\n    return dict_add_number(retdict, \"idx\", eidx);\n}\n\n/*\n * Return the 'quickfixtextfunc' function of a quickfix/location list\n */\n    static int\nqf_getprop_qftf(qf_list_T *qfl, dict_T *retdict)\n{\n    int\t\tstatus;\n\n    if (qfl->qf_qftf_cb.cb_name != NULL)\n    {\n\ttypval_T\ttv;\n\n\tput_callback(&qfl->qf_qftf_cb, &tv);\n\tstatus = dict_add_tv(retdict, \"quickfixtextfunc\", &tv);\n\tclear_tv(&tv);\n    }\n    else\n\tstatus = dict_add_string(retdict, \"quickfixtextfunc\", (char_u *)\"\");\n\n    return status;\n}\n\n/*\n * Return quickfix/location list details (title) as a\n * dictionary. 'what' contains the details to return. If 'list_idx' is -1,\n * then current list is used. Otherwise the specified list is used.\n */\n    static int\nqf_get_properties(win_T *wp, dict_T *what, dict_T *retdict)\n{\n    qf_info_T\t*qi = &ql_info;\n    qf_list_T\t*qfl;\n    int\t\tstatus = OK;\n    int\t\tqf_idx = INVALID_QFIDX;\n    int\t\teidx = 0;\n    dictitem_T\t*di;\n    int\t\tflags = QF_GETLIST_NONE;\n\n    if ((di = dict_find(what, (char_u *)\"lines\", -1)) != NULL)\n\treturn qf_get_list_from_lines(what, di, retdict);\n\n    if (wp != NULL)\n\tqi = GET_LOC_LIST(wp);\n\n    flags = qf_getprop_keys2flags(what, (wp != NULL));\n\n    if (!qf_stack_empty(qi))\n\tqf_idx = qf_getprop_qfidx(qi, what);\n\n    // List is not present or is empty\n    if (qf_stack_empty(qi) || qf_idx == INVALID_QFIDX)\n\treturn qf_getprop_defaults(qi, flags, wp != NULL, retdict);\n\n    qfl = qf_get_list(qi, qf_idx);\n\n    // If an entry index is specified, use that\n    if ((di = dict_find(what, (char_u *)\"idx\", -1)) != NULL)\n    {\n\tif (di->di_tv.v_type != VAR_NUMBER)\n\t    return FAIL;\n\teidx = di->di_tv.vval.v_number;\n    }\n\n    if (flags & QF_GETLIST_TITLE)\n\tstatus = qf_getprop_title(qfl, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_NR))\n\tstatus = dict_add_number(retdict, \"nr\", qf_idx + 1);\n    if ((status == OK) && (flags & QF_GETLIST_WINID))\n\tstatus = dict_add_number(retdict, \"winid\", qf_winid(qi));\n    if ((status == OK) && (flags & QF_GETLIST_ITEMS))\n\tstatus = qf_getprop_items(qi, qf_idx, eidx, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_CONTEXT))\n\tstatus = qf_getprop_ctx(qfl, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_ID))\n\tstatus = dict_add_number(retdict, \"id\", qfl->qf_id);\n    if ((status == OK) && (flags & QF_GETLIST_IDX))\n\tstatus = qf_getprop_idx(qfl, eidx, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_SIZE))\n\tstatus = dict_add_number(retdict, \"size\", qfl->qf_count);\n    if ((status == OK) && (flags & QF_GETLIST_TICK))\n\tstatus = dict_add_number(retdict, \"changedtick\", qfl->qf_changedtick);\n    if ((status == OK) && (wp != NULL) && (flags & QF_GETLIST_FILEWINID))\n\tstatus = qf_getprop_filewinid(wp, qi, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_QFBUFNR))\n\tstatus = qf_getprop_qfbufnr(qi, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_QFTF))\n\tstatus = qf_getprop_qftf(qfl, retdict);\n\n    return status;\n}\n\n/*\n * Add a new quickfix entry to list at 'qf_idx' in the stack 'qi' from the\n * items in the dict 'd'. If it is a valid error entry, then set 'valid_entry'\n * to TRUE.\n */\n    static int\nqf_add_entry_from_dict(\n\tqf_list_T\t*qfl,\n\tdict_T\t\t*d,\n\tint\t\tfirst_entry,\n\tint\t\t*valid_entry)\n{\n    static int\tdid_bufnr_emsg;\n    char_u\t*filename, *module, *pattern, *text, *type;\n    int\t\tbufnum, valid, status, col, end_col, vcol, nr;\n    long\tlnum, end_lnum;\n\n    if (first_entry)\n\tdid_bufnr_emsg = FALSE;\n\n    filename = dict_get_string(d, \"filename\", TRUE);\n    module = dict_get_string(d, \"module\", TRUE);\n    bufnum = (int)dict_get_number(d, \"bufnr\");\n    lnum = (int)dict_get_number(d, \"lnum\");\n    end_lnum = (int)dict_get_number(d, \"end_lnum\");\n    col = (int)dict_get_number(d, \"col\");\n    end_col = (int)dict_get_number(d, \"end_col\");\n    vcol = (int)dict_get_number(d, \"vcol\");\n    nr = (int)dict_get_number(d, \"nr\");\n    type = dict_get_string(d, \"type\", TRUE);\n    pattern = dict_get_string(d, \"pattern\", TRUE);\n    text = dict_get_string(d, \"text\", TRUE);\n    if (text == NULL)\n\ttext = vim_strsave((char_u *)\"\");\n\n    valid = TRUE;\n    if ((filename == NULL && bufnum == 0) || (lnum == 0 && pattern == NULL))\n\tvalid = FALSE;\n\n    // Mark entries with non-existing buffer number as not valid. Give the\n    // error message only once.\n    if (bufnum != 0 && (buflist_findnr(bufnum) == NULL))\n    {\n\tif (!did_bufnr_emsg)\n\t{\n\t    did_bufnr_emsg = TRUE;\n\t    semsg(_(e_buffer_nr_not_found), bufnum);\n\t}\n\tvalid = FALSE;\n\tbufnum = 0;\n    }\n\n    // If the 'valid' field is present it overrules the detected value.\n    if (dict_has_key(d, \"valid\"))\n\tvalid = (int)dict_get_bool(d, \"valid\", FALSE);\n\n    status =  qf_add_entry(qfl,\n\t\t\tNULL,\t\t// dir\n\t\t\tfilename,\n\t\t\tmodule,\n\t\t\tbufnum,\n\t\t\ttext,\n\t\t\tlnum,\n\t\t\tend_lnum,\n\t\t\tcol,\n\t\t\tend_col,\n\t\t\tvcol,\t\t// vis_col\n\t\t\tpattern,\t// search pattern\n\t\t\tnr,\n\t\t\ttype == NULL ? NUL : *type,\n\t\t\tvalid);\n\n    vim_free(filename);\n    vim_free(module);\n    vim_free(pattern);\n    vim_free(text);\n    vim_free(type);\n\n    if (valid)\n\t*valid_entry = TRUE;\n\n    return status;\n}\n\n/*\n * Add list of entries to quickfix/location list. Each list entry is\n * a dictionary with item information.\n */\n    static int\nqf_add_entries(\n\tqf_info_T\t*qi,\n\tint\t\tqf_idx,\n\tlist_T\t\t*list,\n\tchar_u\t\t*title,\n\tint\t\taction)\n{\n    qf_list_T\t*qfl = qf_get_list(qi, qf_idx);\n    listitem_T\t*li;\n    dict_T\t*d;\n    qfline_T\t*old_last = NULL;\n    int\t\tretval = OK;\n    int\t\tvalid_entry = FALSE;\n\n    if (action == ' ' || qf_idx == qi->qf_listcount)\n    {\n\t// make place for a new list\n\tqf_new_list(qi, title);\n\tqf_idx = qi->qf_curlist;\n\tqfl = qf_get_list(qi, qf_idx);\n    }\n    else if (action == 'a' && !qf_list_empty(qfl))\n\t// Adding to existing list, use last entry.\n\told_last = qfl->qf_last;\n    else if (action == 'r')\n    {\n\tqf_free_items(qfl);\n\tqf_store_title(qfl, title);\n    }\n\n    FOR_ALL_LIST_ITEMS(list, li)\n    {\n\tif (li->li_tv.v_type != VAR_DICT)\n\t    continue; // Skip non-dict items\n\n\td = li->li_tv.vval.v_dict;\n\tif (d == NULL)\n\t    continue;\n\n\tretval = qf_add_entry_from_dict(qfl, d, li == list->lv_first,\n\t\t\t\t\t\t\t\t&valid_entry);\n\tif (retval == QF_FAIL)\n\t    break;\n    }\n\n    // Check if any valid error entries are added to the list.\n    if (valid_entry)\n\tqfl->qf_nonevalid = FALSE;\n    else if (qfl->qf_index == 0)\n\t// no valid entry\n\tqfl->qf_nonevalid = TRUE;\n\n    // If not appending to the list, set the current error to the first entry\n    if (action != 'a')\n\tqfl->qf_ptr = qfl->qf_start;\n\n    // Update the current error index if not appending to the list or if the\n    // list was empty before and it is not empty now.\n    if ((action != 'a' || qfl->qf_index == 0) && !qf_list_empty(qfl))\n\tqfl->qf_index = 1;\n\n    // Don't update the cursor in quickfix window when appending entries\n    qf_update_buffer(qi, old_last);\n\n    return retval;\n}\n\n/*\n * Get the quickfix list index from 'nr' or 'id'\n */\n    static int\nqf_setprop_get_qfidx(\n\tqf_info_T\t*qi,\n\tdict_T\t\t*what,\n\tint\t\taction,\n\tint\t\t*newlist)\n{\n    dictitem_T\t*di;\n    int\t\tqf_idx = qi->qf_curlist;    // default is the current list\n\n    if ((di = dict_find(what, (char_u *)\"nr\", -1)) != NULL)\n    {\n\t// Use the specified quickfix/location list\n\tif (di->di_tv.v_type == VAR_NUMBER)\n\t{\n\t    // for zero use the current list\n\t    if (di->di_tv.vval.v_number != 0)\n\t\tqf_idx = di->di_tv.vval.v_number - 1;\n\n\t    if ((action == ' ' || action == 'a') && qf_idx == qi->qf_listcount)\n\t    {\n\t\t// When creating a new list, accept qf_idx pointing to the next\n\t\t// non-available list and add the new list at the end of the\n\t\t// stack.\n\t\t*newlist = TRUE;\n\t\tqf_idx = qf_stack_empty(qi) ? 0 : qi->qf_listcount - 1;\n\t    }\n\t    else if (qf_idx < 0 || qf_idx >= qi->qf_listcount)\n\t\treturn INVALID_QFIDX;\n\t    else if (action != ' ')\n\t\t*newlist = FALSE;\t// use the specified list\n\t}\n\telse if (di->di_tv.v_type == VAR_STRING\n\t\t&& di->di_tv.vval.v_string != NULL\n\t\t&& STRCMP(di->di_tv.vval.v_string, \"$\") == 0)\n\t{\n\t    if (!qf_stack_empty(qi))\n\t\tqf_idx = qi->qf_listcount - 1;\n\t    else if (*newlist)\n\t\tqf_idx = 0;\n\t    else\n\t\treturn INVALID_QFIDX;\n\t}\n\telse\n\t    return INVALID_QFIDX;\n    }\n\n    if (!*newlist && (di = dict_find(what, (char_u *)\"id\", -1)) != NULL)\n    {\n\t// Use the quickfix/location list with the specified id\n\tif (di->di_tv.v_type != VAR_NUMBER)\n\t    return INVALID_QFIDX;\n\n\treturn qf_id2nr(qi, di->di_tv.vval.v_number);\n    }\n\n    return qf_idx;\n}\n\n/*\n * Set the quickfix list title.\n */\n    static int\nqf_setprop_title(qf_info_T *qi, int qf_idx, dict_T *what, dictitem_T *di)\n{\n    qf_list_T\t*qfl = qf_get_list(qi, qf_idx);\n\n    if (di->di_tv.v_type != VAR_STRING)\n\treturn FAIL;\n\n    vim_free(qfl->qf_title);\n    qfl->qf_title = dict_get_string(what, \"title\", TRUE);\n    if (qf_idx == qi->qf_curlist)\n\tqf_update_win_titlevar(qi);\n\n    return OK;\n}\n\n/*\n * Set quickfix list items/entries.\n */\n    static int\nqf_setprop_items(qf_info_T *qi, int qf_idx, dictitem_T *di, int action)\n{\n    int\t\tretval = FAIL;\n    char_u\t*title_save;\n\n    if (di->di_tv.v_type != VAR_LIST)\n\treturn FAIL;\n\n    title_save = vim_strsave(qi->qf_lists[qf_idx].qf_title);\n    retval = qf_add_entries(qi, qf_idx, di->di_tv.vval.v_list,\n\t    title_save, action == ' ' ? 'a' : action);\n    vim_free(title_save);\n\n    return retval;\n}\n\n/*\n * Set quickfix list items/entries from a list of lines.\n */\n    static int\nqf_setprop_items_from_lines(\n\tqf_info_T\t*qi,\n\tint\t\tqf_idx,\n\tdict_T\t\t*what,\n\tdictitem_T\t*di,\n\tint\t\taction)\n{\n    char_u\t*errorformat = p_efm;\n    dictitem_T\t*efm_di;\n    int\t\tretval = FAIL;\n\n    // Use the user supplied errorformat settings (if present)\n    if ((efm_di = dict_find(what, (char_u *)\"efm\", -1)) != NULL)\n    {\n\tif (efm_di->di_tv.v_type != VAR_STRING ||\n\t\tefm_di->di_tv.vval.v_string == NULL)\n\t    return FAIL;\n\terrorformat = efm_di->di_tv.vval.v_string;\n    }\n\n    // Only a List value is supported\n    if (di->di_tv.v_type != VAR_LIST || di->di_tv.vval.v_list == NULL)\n\treturn FAIL;\n\n    if (action == 'r')\n\tqf_free_items(&qi->qf_lists[qf_idx]);\n    if (qf_init_ext(qi, qf_idx, NULL, NULL, &di->di_tv, errorformat,\n\t\tFALSE, (linenr_T)0, (linenr_T)0, NULL, NULL) >= 0)\n\tretval = OK;\n\n    return retval;\n}\n\n/*\n * Set quickfix list context.\n */\n    static int\nqf_setprop_context(qf_list_T *qfl, dictitem_T *di)\n{\n    typval_T\t*ctx;\n\n    free_tv(qfl->qf_ctx);\n    ctx =  alloc_tv();\n    if (ctx != NULL)\n\tcopy_tv(&di->di_tv, ctx);\n    qfl->qf_ctx = ctx;\n\n    return OK;\n}\n\n/*\n * Set the current index in the specified quickfix list\n */\n    static int\nqf_setprop_curidx(qf_info_T *qi, qf_list_T *qfl, dictitem_T *di)\n{\n    int\t\tdenote = FALSE;\n    int\t\tnewidx;\n    int\t\told_qfidx;\n    qfline_T\t*qf_ptr;\n\n    // If the specified index is '$', then use the last entry\n    if (di->di_tv.v_type == VAR_STRING\n\t    && di->di_tv.vval.v_string != NULL\n\t    && STRCMP(di->di_tv.vval.v_string, \"$\") == 0)\n\tnewidx = qfl->qf_count;\n    else\n    {\n\t// Otherwise use the specified index\n\tnewidx = tv_get_number_chk(&di->di_tv, &denote);\n\tif (denote)\n\t    return FAIL;\n    }\n\n    if (newidx < 1)\t\t// sanity check\n\treturn FAIL;\n    if (newidx > qfl->qf_count)\n\tnewidx = qfl->qf_count;\n\n    old_qfidx = qfl->qf_index;\n    qf_ptr = get_nth_entry(qfl, newidx, &newidx);\n    if (qf_ptr == NULL)\n\treturn FAIL;\n    qfl->qf_ptr = qf_ptr;\n    qfl->qf_index = newidx;\n\n    // If the current list is modified and it is displayed in the quickfix\n    // window, then Update it.\n    if (qf_get_curlist(qi)->qf_id == qfl->qf_id)\n\tqf_win_pos_update(qi, old_qfidx);\n\n    return OK;\n}\n\n/*\n * Set the current index in the specified quickfix list\n */\n    static int\nqf_setprop_qftf(qf_info_T *qi UNUSED, qf_list_T *qfl, dictitem_T *di)\n{\n    callback_T\tcb;\n\n    free_callback(&qfl->qf_qftf_cb);\n    cb = get_callback(&di->di_tv);\n    if (cb.cb_name != NULL && *cb.cb_name != NUL)\n\tset_callback(&qfl->qf_qftf_cb, &cb);\n\n    return OK;\n}\n\n/*\n * Set quickfix/location list properties (title, items, context).\n * Also used to add items from parsing a list of lines.\n * Used by the setqflist() and setloclist() Vim script functions.\n */\n    static int\nqf_set_properties(qf_info_T *qi, dict_T *what, int action, char_u *title)\n{\n    dictitem_T\t*di;\n    int\t\tretval = FAIL;\n    int\t\tqf_idx;\n    int\t\tnewlist = FALSE;\n    qf_list_T\t*qfl;\n\n    if (action == ' ' || qf_stack_empty(qi))\n\tnewlist = TRUE;\n\n    qf_idx = qf_setprop_get_qfidx(qi, what, action, &newlist);\n    if (qf_idx == INVALID_QFIDX)\t// List not found\n\treturn FAIL;\n\n    if (newlist)\n    {\n\tqi->qf_curlist = qf_idx;\n\tqf_new_list(qi, title);\n\tqf_idx = qi->qf_curlist;\n    }\n\n    qfl = qf_get_list(qi, qf_idx);\n    if ((di = dict_find(what, (char_u *)\"title\", -1)) != NULL)\n\tretval = qf_setprop_title(qi, qf_idx, what, di);\n    if ((di = dict_find(what, (char_u *)\"items\", -1)) != NULL)\n\tretval = qf_setprop_items(qi, qf_idx, di, action);\n    if ((di = dict_find(what, (char_u *)\"lines\", -1)) != NULL)\n\tretval = qf_setprop_items_from_lines(qi, qf_idx, what, di, action);\n    if ((di = dict_find(what, (char_u *)\"context\", -1)) != NULL)\n\tretval = qf_setprop_context(qfl, di);\n    if ((di = dict_find(what, (char_u *)\"idx\", -1)) != NULL)\n\tretval = qf_setprop_curidx(qi, qfl, di);\n    if ((di = dict_find(what, (char_u *)\"quickfixtextfunc\", -1)) != NULL)\n\tretval = qf_setprop_qftf(qi, qfl, di);\n\n    if (newlist || retval == OK)\n\tqf_list_changed(qfl);\n    if (newlist)\n\tqf_update_buffer(qi, NULL);\n\n    return retval;\n}\n\n/*\n * Free the entire quickfix/location list stack.\n * If the quickfix/location list window is open, then clear it.\n */\n    static void\nqf_free_stack(win_T *wp, qf_info_T *qi)\n{\n    win_T\t*qfwin = qf_find_win(qi);\n    win_T\t*llwin = NULL;\n\n    if (qfwin != NULL)\n    {\n\t// If the quickfix/location list window is open, then clear it\n\tif (qi->qf_curlist < qi->qf_listcount)\n\t    qf_free(qf_get_curlist(qi));\n\tqf_update_buffer(qi, NULL);\n    }\n\n    if (wp != NULL && IS_LL_WINDOW(wp))\n    {\n\t// If in the location list window, then use the non-location list\n\t// window with this location list (if present)\n\tllwin = qf_find_win_with_loclist(qi);\n\tif (llwin != NULL)\n\t    wp = llwin;\n    }\n\n    qf_free_all(wp);\n    if (wp == NULL)\n    {\n\t// quickfix list\n\tqi->qf_curlist = 0;\n\tqi->qf_listcount = 0;\n    }\n    else if (qfwin != NULL)\n    {\n\t// If the location list window is open, then create a new empty\n\t// location list\n\tqf_info_T *new_ll = qf_alloc_stack(QFLT_LOCATION);\n\n\tif (new_ll != NULL)\n\t{\n\t    new_ll->qf_bufnr = qfwin->w_buffer->b_fnum;\n\n\t    // first free the list reference in the location list window\n\t    ll_free_all(&qfwin->w_llist_ref);\n\n\t    qfwin->w_llist_ref = new_ll;\n\t    if (wp != qfwin)\n\t\twin_set_loclist(wp, new_ll);\n\t}\n    }\n}\n\n/*\n * Populate the quickfix list with the items supplied in the list\n * of dictionaries. \"title\" will be copied to w:quickfix_title.\n * \"action\" is 'a' for add, 'r' for replace.  Otherwise create a new list.\n * When \"what\" is not NULL then only set some properties.\n */\n    int\nset_errorlist(\n\twin_T\t*wp,\n\tlist_T\t*list,\n\tint\taction,\n\tchar_u\t*title,\n\tdict_T\t*what)\n{\n    qf_info_T\t*qi = &ql_info;\n    int\t\tretval = OK;\n\n    if (wp != NULL)\n    {\n\tqi = ll_get_or_alloc_list(wp);\n\tif (qi == NULL)\n\t    return FAIL;\n    }\n\n    if (action == 'f')\n    {\n\t// Free the entire quickfix or location list stack\n\tqf_free_stack(wp, qi);\n\treturn OK;\n    }\n\n    // A dict argument cannot be specified with a non-empty list argument\n    if (list->lv_len != 0 && what != NULL)\n    {\n\tsemsg(_(e_invalid_argument_str),\n\t\t\t _(\"cannot have both a list and a \\\"what\\\" argument\"));\n\treturn FAIL;\n    }\n\n    incr_quickfix_busy();\n\n    if (what != NULL)\n\tretval = qf_set_properties(qi, what, action, title);\n    else\n    {\n\tretval = qf_add_entries(qi, qi->qf_curlist, list, title, action);\n\tif (retval == OK)\n\t    qf_list_changed(qf_get_curlist(qi));\n    }\n\n    decr_quickfix_busy();\n\n    return retval;\n}\n\n/*\n * Mark the quickfix context and callback function as in use for all the lists\n * in a quickfix stack.\n */\n    static int\nmark_quickfix_ctx(qf_info_T *qi, int copyID)\n{\n    int\t\ti;\n    int\t\tabort = FALSE;\n    typval_T\t*ctx;\n    callback_T\t*cb;\n\n    for (i = 0; i < LISTCOUNT && !abort; ++i)\n    {\n\tctx = qi->qf_lists[i].qf_ctx;\n\tif (ctx != NULL && ctx->v_type != VAR_NUMBER\n\t\t&& ctx->v_type != VAR_STRING && ctx->v_type != VAR_FLOAT)\n\t    abort = abort || set_ref_in_item(ctx, copyID, NULL, NULL);\n\n\tcb = &qi->qf_lists[i].qf_qftf_cb;\n\tabort = abort || set_ref_in_callback(cb, copyID);\n    }\n\n    return abort;\n}\n\n/*\n * Mark the context of the quickfix list and the location lists (if present) as\n * \"in use\". So that garbage collection doesn't free the context.\n */\n    int\nset_ref_in_quickfix(int copyID)\n{\n    int\t\tabort = FALSE;\n    tabpage_T\t*tp;\n    win_T\t*win;\n\n    abort = mark_quickfix_ctx(&ql_info, copyID);\n    if (abort)\n\treturn abort;\n\n    abort = set_ref_in_callback(&qftf_cb, copyID);\n    if (abort)\n\treturn abort;\n\n    FOR_ALL_TAB_WINDOWS(tp, win)\n    {\n\tif (win->w_llist != NULL)\n\t{\n\t    abort = mark_quickfix_ctx(win->w_llist, copyID);\n\t    if (abort)\n\t\treturn abort;\n\t}\n\tif (IS_LL_WINDOW(win) && (win->w_llist_ref->qf_refcount == 1))\n\t{\n\t    // In a location list window and none of the other windows is\n\t    // referring to this location list. Mark the location list\n\t    // context as still in use.\n\t    abort = mark_quickfix_ctx(win->w_llist_ref, copyID);\n\t    if (abort)\n\t\treturn abort;\n\t}\n    }\n\n    return abort;\n}\n#endif\n\n/*\n * Return the autocmd name for the :cbuffer Ex commands\n */\n    static char_u *\ncbuffer_get_auname(cmdidx_T cmdidx)\n{\n    switch (cmdidx)\n    {\n\tcase CMD_cbuffer:\treturn (char_u *)\"cbuffer\";\n\tcase CMD_cgetbuffer:\treturn (char_u *)\"cgetbuffer\";\n\tcase CMD_caddbuffer:\treturn (char_u *)\"caddbuffer\";\n\tcase CMD_lbuffer:\treturn (char_u *)\"lbuffer\";\n\tcase CMD_lgetbuffer:\treturn (char_u *)\"lgetbuffer\";\n\tcase CMD_laddbuffer:\treturn (char_u *)\"laddbuffer\";\n\tdefault:\t\treturn NULL;\n    }\n}\n\n/*\n * Process and validate the arguments passed to the :cbuffer, :caddbuffer,\n * :cgetbuffer, :lbuffer, :laddbuffer, :lgetbuffer Ex commands.\n */\n    static int\ncbuffer_process_args(\n\texarg_T\t\t*eap,\n\tbuf_T\t\t**bufp,\n\tlinenr_T\t*line1,\n\tlinenr_T\t*line2)\n{\n    buf_T\t*buf = NULL;\n\n    if (*eap->arg == NUL)\n\tbuf = curbuf;\n    else if (*skipwhite(skipdigits(eap->arg)) == NUL)\n\tbuf = buflist_findnr(atoi((char *)eap->arg));\n\n    if (buf == NULL)\n    {\n\temsg(_(e_invalid_argument));\n\treturn FAIL;\n    }\n\n    if (buf->b_ml.ml_mfp == NULL)\n    {\n\temsg(_(e_buffer_is_not_loaded));\n\treturn FAIL;\n    }\n\n    if (eap->addr_count == 0)\n    {\n\teap->line1 = 1;\n\teap->line2 = buf->b_ml.ml_line_count;\n    }\n\n    if (eap->line1 < 1 || eap->line1 > buf->b_ml.ml_line_count\n\t    || eap->line2 < 1 || eap->line2 > buf->b_ml.ml_line_count)\n    {\n\temsg(_(e_invalid_range));\n\treturn FAIL;\n    }\n\n    *line1 = eap->line1;\n    *line2 = eap->line2;\n    *bufp = buf;\n\n    return OK;\n}\n\n/*\n * \":[range]cbuffer [bufnr]\" command.\n * \":[range]caddbuffer [bufnr]\" command.\n * \":[range]cgetbuffer [bufnr]\" command.\n * \":[range]lbuffer [bufnr]\" command.\n * \":[range]laddbuffer [bufnr]\" command.\n * \":[range]lgetbuffer [bufnr]\" command.\n */\n    void\nex_cbuffer(exarg_T *eap)\n{\n    buf_T\t*buf = NULL;\n    qf_info_T\t*qi;\n    char_u\t*au_name = NULL;\n    int\t\tres;\n    int_u\tsave_qfid;\n    win_T\t*wp = NULL;\n    char_u\t*qf_title;\n    linenr_T\tline1;\n    linenr_T\tline2;\n\n    au_name = cbuffer_get_auname(eap->cmdidx);\n    if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n\t\t\t\t\tcurbuf->b_fname, TRUE, curbuf))\n    {\n#ifdef FEAT_EVAL\n\tif (aborting())\n\t    return;\n#endif\n    }\n\n    // Must come after autocommands.\n    qi = qf_cmd_get_or_alloc_stack(eap, &wp);\n    if (qi == NULL)\n\treturn;\n\n    if (cbuffer_process_args(eap, &buf, &line1, &line2) == FAIL)\n\treturn;\n\n    qf_title = qf_cmdtitle(*eap->cmdlinep);\n\n    if (buf->b_sfname)\n    {\n\tvim_snprintf((char *)IObuff, IOSIZE, \"%s (%s)\",\n\t\t(char *)qf_title, (char *)buf->b_sfname);\n\tqf_title = IObuff;\n    }\n\n    incr_quickfix_busy();\n\n    res = qf_init_ext(qi, qi->qf_curlist, NULL, buf, NULL, p_efm,\n\t    (eap->cmdidx != CMD_caddbuffer\n\t     && eap->cmdidx != CMD_laddbuffer),\n\t    line1, line2,\n\t    qf_title, NULL);\n    if (qf_stack_empty(qi))\n    {\n\tdecr_quickfix_busy();\n\treturn;\n    }\n    if (res >= 0)\n\tqf_list_changed(qf_get_curlist(qi));\n\n    // Remember the current quickfix list identifier, so that we can\n    // check for autocommands changing the current quickfix list.\n    save_qfid = qf_get_curlist(qi)->qf_id;\n    if (au_name != NULL)\n    {\n\tbuf_T *curbuf_old = curbuf;\n\n\tapply_autocmds(EVENT_QUICKFIXCMDPOST, au_name, curbuf->b_fname,\n\t\t\t\t\t\t\t\tTRUE, curbuf);\n\tif (curbuf != curbuf_old)\n\t    // Autocommands changed buffer, don't jump now, \"qi\" may\n\t    // be invalid.\n\t    res = 0;\n    }\n    // Jump to the first error for a new list and if autocmds didn't\n    // free the list.\n    if (res > 0 && (eap->cmdidx == CMD_cbuffer ||\n\t\teap->cmdidx == CMD_lbuffer)\n\t    && qflist_valid(wp, save_qfid))\n\t// display the first error\n\tqf_jump_first(qi, save_qfid, eap->forceit);\n\n    decr_quickfix_busy();\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return the autocmd name for the :cexpr Ex commands.\n */\n    char_u *\ncexpr_get_auname(cmdidx_T cmdidx)\n{\n    switch (cmdidx)\n    {\n\tcase CMD_cexpr:\t    return (char_u *)\"cexpr\";\n\tcase CMD_cgetexpr:  return (char_u *)\"cgetexpr\";\n\tcase CMD_caddexpr:  return (char_u *)\"caddexpr\";\n\tcase CMD_lexpr:\t    return (char_u *)\"lexpr\";\n\tcase CMD_lgetexpr:  return (char_u *)\"lgetexpr\";\n\tcase CMD_laddexpr:  return (char_u *)\"laddexpr\";\n\tdefault:\t    return NULL;\n    }\n}\n\n    int\ntrigger_cexpr_autocmd(int cmdidx)\n{\n    char_u\t*au_name = cexpr_get_auname(cmdidx);\n\n    if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf))\n    {\n\tif (aborting())\n\t    return FAIL;\n    }\n    return OK;\n}\n\n    int\ncexpr_core(exarg_T *eap, typval_T *tv)\n{\n    qf_info_T\t*qi;\n    win_T\t*wp = NULL;\n\n    qi = qf_cmd_get_or_alloc_stack(eap, &wp);\n    if (qi == NULL)\n\treturn FAIL;\n\n    if ((tv->v_type == VAR_STRING && tv->vval.v_string != NULL)\n\t    || (tv->v_type == VAR_LIST && tv->vval.v_list != NULL))\n    {\n\tint\tres;\n\tint_u\tsave_qfid;\n\tchar_u\t*au_name = cexpr_get_auname(eap->cmdidx);\n\n\tincr_quickfix_busy();\n\tres = qf_init_ext(qi, qi->qf_curlist, NULL, NULL, tv, p_efm,\n\t\t\t(eap->cmdidx != CMD_caddexpr\n\t\t\t && eap->cmdidx != CMD_laddexpr),\n\t\t\t     (linenr_T)0, (linenr_T)0,\n\t\t\t     qf_cmdtitle(*eap->cmdlinep), NULL);\n\tif (qf_stack_empty(qi))\n\t{\n\t    decr_quickfix_busy();\n\t    return FAIL;\n\t}\n\tif (res >= 0)\n\t    qf_list_changed(qf_get_curlist(qi));\n\n\t// Remember the current quickfix list identifier, so that we can\n\t// check for autocommands changing the current quickfix list.\n\tsave_qfid = qf_get_curlist(qi)->qf_id;\n\tif (au_name != NULL)\n\t    apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,\n\t\t\t\t\t    curbuf->b_fname, TRUE, curbuf);\n\n\t// Jump to the first error for a new list and if autocmds didn't\n\t// free the list.\n\tif (res > 0 && (eap->cmdidx == CMD_cexpr || eap->cmdidx == CMD_lexpr)\n\t\t&& qflist_valid(wp, save_qfid))\n\t    // display the first error\n\t    qf_jump_first(qi, save_qfid, eap->forceit);\n\tdecr_quickfix_busy();\n\treturn OK;\n    }\n\n    emsg(_(e_string_or_list_expected));\n    return FAIL;\n}\n\n/*\n * \":cexpr {expr}\", \":cgetexpr {expr}\", \":caddexpr {expr}\" command.\n * \":lexpr {expr}\", \":lgetexpr {expr}\", \":laddexpr {expr}\" command.\n * Also: \":caddexpr\", \":cgetexpr\", \"laddexpr\" and \"laddexpr\".\n */\n    void\nex_cexpr(exarg_T *eap)\n{\n    typval_T\t*tv;\n\n    if (trigger_cexpr_autocmd(eap->cmdidx) == FAIL)\n\treturn;\n\n    // Evaluate the expression.  When the result is a string or a list we can\n    // use it to fill the errorlist.\n    tv = eval_expr(eap->arg, eap);\n    if (tv != NULL)\n    {\n\t(void)cexpr_core(eap, tv);\n\tfree_tv(tv);\n    }\n}\n#endif\n\n/*\n * Get the location list for \":lhelpgrep\"\n */\n    static qf_info_T *\nhgr_get_ll(int *new_ll)\n{\n    win_T\t*wp;\n    qf_info_T\t*qi;\n\n    // If the current window is a help window, then use it\n    if (bt_help(curwin->w_buffer))\n\twp = curwin;\n    else\n\t// Find an existing help window\n\twp = qf_find_help_win();\n\n    if (wp == NULL)\t    // Help window not found\n\tqi = NULL;\n    else\n\tqi = wp->w_llist;\n\n    if (qi == NULL)\n    {\n\t// Allocate a new location list for help text matches\n\tif ((qi = qf_alloc_stack(QFLT_LOCATION)) == NULL)\n\t    return NULL;\n\t*new_ll = TRUE;\n    }\n\n    return qi;\n}\n\n/*\n * Search for a pattern in a help file.\n */\n    static void\nhgr_search_file(\n\tqf_list_T *qfl,\n\tchar_u *fname,\n\tvimconv_T *p_vc,\n\tregmatch_T *p_regmatch)\n{\n    FILE\t*fd;\n    long\tlnum;\n\n    fd = mch_fopen((char *)fname, \"r\");\n    if (fd == NULL)\n\treturn;\n\n    lnum = 1;\n    while (!vim_fgets(IObuff, IOSIZE, fd) && !got_int)\n    {\n\tchar_u    *line = IObuff;\n\n\t// Convert a line if 'encoding' is not utf-8 and\n\t// the line contains a non-ASCII character.\n\tif (p_vc->vc_type != CONV_NONE && has_non_ascii(IObuff))\n\t{\n\t    line = string_convert(p_vc, IObuff, NULL);\n\t    if (line == NULL)\n\t\tline = IObuff;\n\t}\n\n\tif (vim_regexec(p_regmatch, line, (colnr_T)0))\n\t{\n\t    int\tl = (int)STRLEN(line);\n\n\t    // remove trailing CR, LF, spaces, etc.\n\t    while (l > 0 && line[l - 1] <= ' ')\n\t\tline[--l] = NUL;\n\n\t    if (qf_add_entry(qfl,\n\t\t\tNULL,\t// dir\n\t\t\tfname,\n\t\t\tNULL,\n\t\t\t0,\n\t\t\tline,\n\t\t\tlnum,\n\t\t\t0,\n\t\t\t(int)(p_regmatch->startp[0] - line)\n\t\t\t+ 1,\t// col\n\t\t\t(int)(p_regmatch->endp[0] - line)\n\t\t\t+ 1,\t// end_col\n\t\t\tFALSE,\t// vis_col\n\t\t\tNULL,\t// search pattern\n\t\t\t0,\t// nr\n\t\t\t1,\t// type\n\t\t\tTRUE\t// valid\n\t\t\t) == QF_FAIL)\n\t    {\n\t\tgot_int = TRUE;\n\t\tif (line != IObuff)\n\t\t    vim_free(line);\n\t\tbreak;\n\t    }\n\t}\n\tif (line != IObuff)\n\t    vim_free(line);\n\t++lnum;\n\tline_breakcheck();\n    }\n    fclose(fd);\n}\n\n/*\n * Search for a pattern in all the help files in the doc directory under\n * the given directory.\n */\n    static void\nhgr_search_files_in_dir(\n\tqf_list_T *qfl,\n\tchar_u *dirname,\n\tregmatch_T *p_regmatch,\n\tvimconv_T *p_vc\n#ifdef FEAT_MULTI_LANG\n\t, char_u *lang\n#endif\n\t)\n{\n    int\t\tfcount;\n    char_u\t**fnames;\n    int\t\tfi;\n\n    // Find all \"*.txt\" and \"*.??x\" files in the \"doc\" directory.\n    add_pathsep(dirname);\n    STRCAT(dirname, \"doc/*.\\\\(txt\\\\|??x\\\\)\");\n    if (gen_expand_wildcards(1, &dirname, &fcount,\n\t\t&fnames, EW_FILE|EW_SILENT) == OK\n\t    && fcount > 0)\n    {\n\tfor (fi = 0; fi < fcount && !got_int; ++fi)\n\t{\n#ifdef FEAT_MULTI_LANG\n\t    // Skip files for a different language.\n\t    if (lang != NULL\n\t\t    && STRNICMP(lang, fnames[fi]\n\t\t\t\t    + STRLEN(fnames[fi]) - 3, 2) != 0\n\t\t    && !(STRNICMP(lang, \"en\", 2) == 0\n\t\t\t&& STRNICMP(\"txt\", fnames[fi]\n\t\t\t    + STRLEN(fnames[fi]) - 3, 3) == 0))\n\t\tcontinue;\n#endif\n\n\t    hgr_search_file(qfl, fnames[fi], p_vc, p_regmatch);\n\t}\n\tFreeWild(fcount, fnames);\n    }\n}\n\n/*\n * Search for a pattern in all the help files in the 'runtimepath'\n * and add the matches to a quickfix list.\n * 'lang' is the language specifier.  If supplied, then only matches in the\n * specified language are found.\n */\n    static void\nhgr_search_in_rtp(qf_list_T *qfl, regmatch_T *p_regmatch, char_u *lang)\n{\n    char_u\t*p;\n\n    vimconv_T\tvc;\n\n    // Help files are in utf-8 or latin1, convert lines when 'encoding'\n    // differs.\n    vc.vc_type = CONV_NONE;\n    if (!enc_utf8)\n\tconvert_setup(&vc, (char_u *)\"utf-8\", p_enc);\n\n    // Go through all the directories in 'runtimepath'\n    p = p_rtp;\n    while (*p != NUL && !got_int)\n    {\n\tcopy_option_part(&p, NameBuff, MAXPATHL, \",\");\n\n\thgr_search_files_in_dir(qfl, NameBuff, p_regmatch, &vc\n#ifdef FEAT_MULTI_LANG\n\t\t, lang\n#endif\n\t\t);\n    }\n\n    if (vc.vc_type != CONV_NONE)\n\tconvert_setup(&vc, NULL, NULL);\n}\n\n/*\n * \":helpgrep {pattern}\"\n */\n    void\nex_helpgrep(exarg_T *eap)\n{\n    regmatch_T\tregmatch;\n    char_u\t*save_cpo;\n    int\t\tsave_cpo_allocated;\n    qf_info_T\t*qi = &ql_info;\n    int\t\tnew_qi = FALSE;\n    char_u\t*au_name =  NULL;\n    char_u\t*lang = NULL;\n    int\t\tupdated = FALSE;\n\n    switch (eap->cmdidx)\n    {\n\tcase CMD_helpgrep:  au_name = (char_u *)\"helpgrep\"; break;\n\tcase CMD_lhelpgrep: au_name = (char_u *)\"lhelpgrep\"; break;\n\tdefault: break;\n    }\n    if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf))\n    {\n#ifdef FEAT_EVAL\n\tif (aborting())\n\t    return;\n#endif\n    }\n\n    if (is_loclist_cmd(eap->cmdidx))\n    {\n\tqi = hgr_get_ll(&new_qi);\n\tif (qi == NULL)\n\t    return;\n    }\n\n    // Make 'cpoptions' empty, the 'l' flag should not be used here.\n    save_cpo = p_cpo;\n    save_cpo_allocated = is_option_allocated(\"cpo\");\n    p_cpo = empty_option;\n\n    incr_quickfix_busy();\n\n#ifdef FEAT_MULTI_LANG\n    // Check for a specified language\n    lang = check_help_lang(eap->arg);\n#endif\n    regmatch.regprog = vim_regcomp(eap->arg, RE_MAGIC + RE_STRING);\n    regmatch.rm_ic = FALSE;\n    if (regmatch.regprog != NULL)\n    {\n\tqf_list_T\t*qfl;\n\n\t// create a new quickfix list\n\tqf_new_list(qi, qf_cmdtitle(*eap->cmdlinep));\n\tqfl = qf_get_curlist(qi);\n\n\thgr_search_in_rtp(qfl, &regmatch, lang);\n\n\tvim_regfree(regmatch.regprog);\n\n\tqfl->qf_nonevalid = FALSE;\n\tqfl->qf_ptr = qfl->qf_start;\n\tqfl->qf_index = 1;\n\tqf_list_changed(qfl);\n\tupdated = TRUE;\n    }\n\n    if (p_cpo == empty_option)\n\tp_cpo = save_cpo;\n    else\n    {\n\t// Darn, some plugin changed the value.  If it's still empty it was\n\t// changed and restored, need to restore in the complicated way.\n\tif (*p_cpo == NUL)\n\t    set_option_value_give_err((char_u *)\"cpo\", 0L, save_cpo, 0);\n\tif (save_cpo_allocated)\n\t    free_string_option(save_cpo);\n    }\n\n    if (updated)\n\t// This may open a window and source scripts, do this after 'cpo' was\n\t// restored.\n\tqf_update_buffer(qi, NULL);\n\n    if (au_name != NULL)\n    {\n\tapply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf);\n\t// When adding a location list to an existing location list stack,\n\t// if the autocmd made the stack invalid, then just return.\n\tif (!new_qi && IS_LL_STACK(qi) && qf_find_win_with_loclist(qi) == NULL)\n\t{\n\t    decr_quickfix_busy();\n\t    return;\n\t}\n    }\n\n    // Jump to first match.\n    if (!qf_list_empty(qf_get_curlist(qi)))\n\tqf_jump(qi, 0, 0, FALSE);\n    else\n\tsemsg(_(e_no_match_str_2), eap->arg);\n\n    decr_quickfix_busy();\n\n    if (eap->cmdidx == CMD_lhelpgrep)\n    {\n\t// If the help window is not opened or if it already points to the\n\t// correct location list, then free the new location list.\n\tif (!bt_help(curwin->w_buffer) || curwin->w_llist == qi)\n\t{\n\t    if (new_qi)\n\t\tll_free_all(&qi);\n\t}\n\telse if (curwin->w_llist == NULL && new_qi)\n\t    // current window didn't have a location list associated with it\n\t    // before. Associate the new location list now.\n\t    curwin->w_llist = qi;\n    }\n}\n#endif // FEAT_QUICKFIX\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n# ifdef FEAT_QUICKFIX\n    static void\nget_qf_loc_list(int is_qf, win_T *wp, typval_T *what_arg, typval_T *rettv)\n{\n    if (what_arg->v_type == VAR_UNKNOWN)\n    {\n\tif (rettv_list_alloc(rettv) == OK)\n\t    if (is_qf || wp != NULL)\n\t\t(void)get_errorlist(NULL, wp, -1, 0, rettv->vval.v_list);\n    }\n    else\n    {\n\tif (rettv_dict_alloc(rettv) == OK)\n\t    if (is_qf || (wp != NULL))\n\t    {\n\t\tif (what_arg->v_type == VAR_DICT)\n\t\t{\n\t\t    dict_T\t*d = what_arg->vval.v_dict;\n\n\t\t    if (d != NULL)\n\t\t\tqf_get_properties(wp, d, rettv->vval.v_dict);\n\t\t}\n\t\telse\n\t\t    emsg(_(e_dictionary_required));\n\t    }\n    }\n}\n# endif\n\n/*\n * \"getloclist()\" function\n */\n    void\nf_getloclist(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n# ifdef FEAT_QUICKFIX\n    win_T\t*wp;\n\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_dict_arg(argvars, 1) == FAIL))\n\treturn;\n\n    wp = find_win_by_nr_or_id(&argvars[0]);\n    get_qf_loc_list(FALSE, wp, &argvars[1], rettv);\n# endif\n}\n\n/*\n * \"getqflist()\" function\n */\n    void\nf_getqflist(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n# ifdef FEAT_QUICKFIX\n    if (in_vim9script() && check_for_opt_dict_arg(argvars, 0) == FAIL)\n\treturn;\n\n    get_qf_loc_list(TRUE, NULL, &argvars[0], rettv);\n# endif\n}\n\n/*\n * Used by \"setqflist()\" and \"setloclist()\" functions\n */\n    static void\nset_qf_ll_list(\n    win_T\t*wp UNUSED,\n    typval_T\t*list_arg UNUSED,\n    typval_T\t*action_arg UNUSED,\n    typval_T\t*what_arg UNUSED,\n    typval_T\t*rettv)\n{\n# ifdef FEAT_QUICKFIX\n    char_u\t*act;\n    int\t\taction = 0;\n    static int\trecursive = 0;\n# endif\n\n    rettv->vval.v_number = -1;\n\n# ifdef FEAT_QUICKFIX\n    if (list_arg->v_type != VAR_LIST)\n\temsg(_(e_list_required));\n    else if (recursive != 0)\n\temsg(_(e_autocommand_caused_recursive_behavior));\n    else\n    {\n\tlist_T  *l = list_arg->vval.v_list;\n\tdict_T\t*what = NULL;\n\tint\tvalid_dict = TRUE;\n\n\tif (action_arg->v_type == VAR_STRING)\n\t{\n\t    act = tv_get_string_chk(action_arg);\n\t    if (act == NULL)\n\t\treturn;\t\t// type error; errmsg already given\n\t    if ((*act == 'a' || *act == 'r' || *act == ' ' || *act == 'f') &&\n\t\t    act[1] == NUL)\n\t\taction = *act;\n\t    else\n\t\tsemsg(_(e_invalid_action_str_1), act);\n\t}\n\telse if (action_arg->v_type == VAR_UNKNOWN)\n\t    action = ' ';\n\telse\n\t    emsg(_(e_string_required));\n\n\tif (action_arg->v_type != VAR_UNKNOWN\n\t\t&& what_arg->v_type != VAR_UNKNOWN)\n\t{\n\t    if (what_arg->v_type == VAR_DICT && what_arg->vval.v_dict != NULL)\n\t\twhat = what_arg->vval.v_dict;\n\t    else\n\t    {\n\t\temsg(_(e_dictionary_required));\n\t\tvalid_dict = FALSE;\n\t    }\n\t}\n\n\t++recursive;\n\tif (l != NULL && action && valid_dict\n\t\t    && set_errorlist(wp, l, action,\n\t\t     (char_u *)(wp == NULL ? \":setqflist()\" : \":setloclist()\"),\n\t\t     what) == OK)\n\t    rettv->vval.v_number = 0;\n\t--recursive;\n    }\n# endif\n}\n\n/*\n * \"setloclist()\" function\n */\n    void\nf_setloclist(typval_T *argvars, typval_T *rettv)\n{\n    win_T\t*win;\n\n    rettv->vval.v_number = -1;\n\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_list_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 2) == FAIL\n\t\t|| (argvars[2].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_dict_arg(argvars, 3) == FAIL)))\n\treturn;\n\n    win = find_win_by_nr_or_id(&argvars[0]);\n    if (win != NULL)\n\tset_qf_ll_list(win, &argvars[1], &argvars[2], &argvars[3], rettv);\n}\n\n/*\n * \"setqflist()\" function\n */\n    void\nf_setqflist(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script()\n\t    && (check_for_list_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 1) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_dict_arg(argvars, 2) == FAIL)))\n\treturn;\n\n    set_qf_ll_list(NULL, &argvars[0], &argvars[1], &argvars[2], rettv);\n}\n#endif\n", "\" Test for the quickfix feature.\n\nsource check.vim\nimport './vim9.vim' as v9\nCheckFeature quickfix\n\nsource screendump.vim\n\nset encoding=utf-8\n\nfunc s:setup_commands(cchar)\n  if a:cchar == 'c'\n    command! -nargs=* -bang Xlist <mods>clist<bang> <args>\n    command! -nargs=* Xgetexpr <mods>cgetexpr <args>\n    command! -nargs=* Xaddexpr <mods>caddexpr <args>\n    command! -nargs=* -count Xolder <mods><count>colder <args>\n    command! -nargs=* Xnewer <mods>cnewer <args>\n    command! -nargs=* Xopen <mods> copen <args>\n    command! -nargs=* Xwindow <mods>cwindow <args>\n    command! -nargs=* Xbottom <mods>cbottom <args>\n    command! -nargs=* Xclose <mods>cclose <args>\n    command! -nargs=* -bang Xfile <mods>cfile<bang> <args>\n    command! -nargs=* Xgetfile <mods>cgetfile <args>\n    command! -nargs=* Xaddfile <mods>caddfile <args>\n    command! -nargs=* -bang Xbuffer <mods>cbuffer<bang> <args>\n    command! -nargs=* Xgetbuffer <mods>cgetbuffer <args>\n    command! -nargs=* Xaddbuffer <mods>caddbuffer <args>\n    command! -nargs=* Xrewind <mods>crewind <args>\n    command! -count -nargs=* -bang Xnext <mods><count>cnext<bang> <args>\n    command! -count -nargs=* -bang Xprev <mods><count>cprev<bang> <args>\n    command! -nargs=* -bang Xfirst <mods>cfirst<bang> <args>\n    command! -nargs=* -bang Xlast <mods>clast<bang> <args>\n    command! -count -nargs=* -bang Xnfile <mods><count>cnfile<bang> <args>\n    command! -nargs=* -bang Xpfile <mods>cpfile<bang> <args>\n    command! -nargs=* Xexpr <mods>cexpr <args>\n    command! -count=999 -nargs=* Xvimgrep <mods> <count>vimgrep <args>\n    command! -nargs=* Xvimgrepadd <mods> vimgrepadd <args>\n    command! -nargs=* Xgrep <mods> grep <args>\n    command! -nargs=* Xgrepadd <mods> grepadd <args>\n    command! -nargs=* Xhelpgrep helpgrep <args>\n    command! -nargs=0 -count Xcc <count>cc\n    command! -count=1 -nargs=0 Xbelow <mods><count>cbelow\n    command! -count=1 -nargs=0 Xabove <mods><count>cabove\n    command! -count=1 -nargs=0 Xbefore <mods><count>cbefore\n    command! -count=1 -nargs=0 Xafter <mods><count>cafter\n    let g:Xgetlist = function('getqflist')\n    let g:Xsetlist = function('setqflist')\n    call setqflist([], 'f')\n  else\n    command! -nargs=* -bang Xlist <mods>llist<bang> <args>\n    command! -nargs=* Xgetexpr <mods>lgetexpr <args>\n    command! -nargs=* Xaddexpr <mods>laddexpr <args>\n    command! -nargs=* -count Xolder <mods><count>lolder <args>\n    command! -nargs=* Xnewer <mods>lnewer <args>\n    command! -nargs=* Xopen <mods> lopen <args>\n    command! -nargs=* Xwindow <mods>lwindow <args>\n    command! -nargs=* Xbottom <mods>lbottom <args>\n    command! -nargs=* Xclose <mods>lclose <args>\n    command! -nargs=* -bang Xfile <mods>lfile<bang> <args>\n    command! -nargs=* Xgetfile <mods>lgetfile <args>\n    command! -nargs=* Xaddfile <mods>laddfile <args>\n    command! -nargs=* -bang Xbuffer <mods>lbuffer<bang> <args>\n    command! -nargs=* Xgetbuffer <mods>lgetbuffer <args>\n    command! -nargs=* Xaddbuffer <mods>laddbuffer <args>\n    command! -nargs=* Xrewind <mods>lrewind <args>\n    command! -count -nargs=* -bang Xnext <mods><count>lnext<bang> <args>\n    command! -count -nargs=* -bang Xprev <mods><count>lprev<bang> <args>\n    command! -nargs=* -bang Xfirst <mods>lfirst<bang> <args>\n    command! -nargs=* -bang Xlast <mods>llast<bang> <args>\n    command! -count -nargs=* -bang Xnfile <mods><count>lnfile<bang> <args>\n    command! -nargs=* -bang Xpfile <mods>lpfile<bang> <args>\n    command! -nargs=* Xexpr <mods>lexpr <args>\n    command! -count=999 -nargs=* Xvimgrep <mods> <count>lvimgrep <args>\n    command! -nargs=* Xvimgrepadd <mods> lvimgrepadd <args>\n    command! -nargs=* Xgrep <mods> lgrep <args>\n    command! -nargs=* Xgrepadd <mods> lgrepadd <args>\n    command! -nargs=* Xhelpgrep lhelpgrep <args>\n    command! -nargs=0 -count Xcc <count>ll\n    command! -count=1 -nargs=0 Xbelow <mods><count>lbelow\n    command! -count=1 -nargs=0 Xabove <mods><count>labove\n    command! -count=1 -nargs=0 Xbefore <mods><count>lbefore\n    command! -count=1 -nargs=0 Xafter <mods><count>lafter\n    let g:Xgetlist = function('getloclist', [0])\n    let g:Xsetlist = function('setloclist', [0])\n    call setloclist(0, [], 'f')\n  endif\nendfunc\n\n\" This must be run before any error lists are created.\nfunc Test_AA_cc_no_errors()\n  call assert_fails('cc', 'E42:')\n  call assert_fails('ll', 'E42:')\nendfunc\n\n\" Tests for the :clist and :llist commands\nfunc XlistTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  if a:cchar == 'l'\n      call assert_fails('llist', 'E776:')\n  endif\n  \" With an empty list, command should return error\n  Xgetexpr []\n  silent! Xlist\n  call assert_true(v:errmsg ==# 'E42: No Errors')\n\n  \" Populate the list and then try\n  let lines =<< trim END\n    non-error 1\n    Xtestfile1:1:3:Line1\n    non-error 2\n    Xtestfile2:2:2:Line2\n    non-error| 3\n    Xtestfile3:3:1:Line3\n  END\n  Xgetexpr lines\n\n  \" List only valid entries\n  let l = split(execute('Xlist', ''), \"\\n\")\n  call assert_equal([' 2 Xtestfile1:1 col 3: Line1',\n\t\t   \\ ' 4 Xtestfile2:2 col 2: Line2',\n\t\t   \\ ' 6 Xtestfile3:3 col 1: Line3'], l)\n\n  \" List all the entries\n  let l = split(execute('Xlist!', ''), \"\\n\")\n  call assert_equal([' 1: non-error 1', ' 2 Xtestfile1:1 col 3: Line1',\n\t\t   \\ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2',\n\t\t   \\ ' 5: non-error| 3', ' 6 Xtestfile3:3 col 1: Line3'], l)\n\n  \" List a range of errors\n  let l = split(execute('Xlist 3,6', ''), \"\\n\")\n  call assert_equal([' 4 Xtestfile2:2 col 2: Line2',\n\t\t   \\ ' 6 Xtestfile3:3 col 1: Line3'], l)\n\n  let l = split(execute('Xlist! 3,4', ''), \"\\n\")\n  call assert_equal([' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)\n\n  let l = split(execute('Xlist -6,-4', ''), \"\\n\")\n  call assert_equal([' 2 Xtestfile1:1 col 3: Line1'], l)\n\n  let l = split(execute('Xlist! -5,-3', ''), \"\\n\")\n  call assert_equal([' 2 Xtestfile1:1 col 3: Line1',\n\t\t   \\ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)\n\n  \" Test for '+'\n  let l = split(execute('Xlist! +2', ''), \"\\n\")\n  call assert_equal([' 2 Xtestfile1:1 col 3: Line1',\n\t\t   \\ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)\n\n  \" Ranged entries\n  call g:Xsetlist([{'lnum':10,'text':'Line1'},\n\t      \\ {'lnum':20,'col':10,'text':'Line2'},\n\t      \\ {'lnum':30,'col':15,'end_col':20,'text':'Line3'},\n\t      \\ {'lnum':40,'end_lnum':45,'text':'Line4'},\n\t      \\ {'lnum':50,'end_lnum':55,'col':15,'text':'Line5'},\n\t      \\ {'lnum':60,'end_lnum':65,'col':25,'end_col':35,'text':'Line6'}])\n  let l = split(execute('Xlist', \"\"), \"\\n\")\n  call assert_equal([' 1:10: Line1',\n\t      \\ ' 2:20 col 10: Line2',\n\t      \\ ' 3:30 col 15-20: Line3',\n\t      \\ ' 4:40-45: Line4',\n\t      \\ ' 5:50-55 col 15: Line5',\n\t      \\ ' 6:60-65 col 25-35: Line6'], l)\n\n  \" Different types of errors\n  call g:Xsetlist([{'lnum':10,'col':5,'type':'W', 'text':'Warning','nr':11},\n\t      \\ {'lnum':20,'col':10,'type':'e','text':'Error','nr':22},\n\t      \\ {'lnum':30,'col':15,'type':'i','text':'Info','nr':33},\n\t      \\ {'lnum':40,'col':20,'type':'x', 'text':'Other','nr':44},\n\t      \\ {'lnum':50,'col':25,'type':\"\\<C-A>\",'text':'one','nr':55}])\n  let l = split(execute('Xlist', \"\"), \"\\n\")\n  call assert_equal([' 1:10 col 5 warning  11: Warning',\n\t      \\ ' 2:20 col 10 error  22: Error',\n\t      \\ ' 3:30 col 15 info  33: Info',\n\t      \\ ' 4:40 col 20 x  44: Other',\n\t      \\ ' 5:50 col 25  55: one'], l)\n\n  \" Test for module names, one needs to explicitly set `'valid':v:true` so\n  call g:Xsetlist([\n\t\\ {'lnum':10,'col':5,'type':'W','module':'Data.Text','text':'ModuleWarning','nr':11,'valid':v:true},\n\t\\ {'lnum':20,'col':10,'type':'W','module':'Data.Text','filename':'Data/Text.hs','text':'ModuleWarning','nr':22,'valid':v:true},\n\t\\ {'lnum':30,'col':15,'type':'W','filename':'Data/Text.hs','text':'FileWarning','nr':33,'valid':v:true}])\n  let l = split(execute('Xlist', \"\"), \"\\n\")\n  call assert_equal([' 1 Data.Text:10 col 5 warning  11: ModuleWarning',\n\t\\ ' 2 Data.Text:20 col 10 warning  22: ModuleWarning',\n\t\\ ' 3 Data/Text.hs:30 col 15 warning  33: FileWarning'], l)\n\n  \" Very long line should be displayed.\n  let text = 'Line' .. repeat('1234567890', 130)\n  let lines = ['Xtestfile9:2:9:' .. text]\n  Xgetexpr lines\n\n  let l = split(execute('Xlist', ''), \"\\n\")\n  call assert_equal([' 1 Xtestfile9:2 col 9: ' .. text] , l)\n\n  \" For help entries in the quickfix list, only the filename without directory\n  \" should be displayed\n  Xhelpgrep setqflist()\n  let l = split(execute('Xlist 1', ''), \"\\n\")\n  call assert_match('^ 1 [^\\\\/]\\{-}:', l[0])\n\n  \" Error cases\n  call assert_fails('Xlist abc', 'E488:')\nendfunc\n\nfunc Test_clist()\n  call XlistTests('c')\n  call XlistTests('l')\nendfunc\n\n\" Tests for the :colder, :cnewer, :lolder and :lnewer commands\n\" Note that this test assumes that a quickfix/location list is\n\" already set by the caller.\nfunc XageTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  if a:cchar == 'l'\n    \" No location list for the current window\n    call assert_fails('lolder', 'E776:')\n    call assert_fails('lnewer', 'E776:')\n  endif\n\n  let list = [{'bufnr': bufnr('%'), 'lnum': 1}]\n  call g:Xsetlist(list)\n\n  \" Jumping to a non existent list should return error\n  silent! Xolder 99\n  call assert_true(v:errmsg ==# 'E380: At bottom of quickfix stack')\n\n  silent! Xnewer 99\n  call assert_true(v:errmsg ==# 'E381: At top of quickfix stack')\n\n  \" Add three quickfix/location lists\n  Xgetexpr ['Xtestfile1:1:3:Line1']\n  Xgetexpr ['Xtestfile2:2:2:Line2']\n  Xgetexpr ['Xtestfile3:3:1:Line3']\n\n  \" Go back two lists\n  Xolder\n  let l = g:Xgetlist()\n  call assert_equal('Line2', l[0].text)\n\n  \" Go forward two lists\n  Xnewer\n  let l = g:Xgetlist()\n  call assert_equal('Line3', l[0].text)\n\n  \" Test for the optional count argument\n  Xolder 2\n  let l = g:Xgetlist()\n  call assert_equal('Line1', l[0].text)\n\n  Xnewer 2\n  let l = g:Xgetlist()\n  call assert_equal('Line3', l[0].text)\nendfunc\n\nfunc Test_cage()\n  call XageTests('c')\n  call XageTests('l')\nendfunc\n\n\" Tests for the :cwindow, :lwindow :cclose, :lclose, :copen and :lopen\n\" commands\nfunc XwindowTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Opening the location list window without any errors should fail\n  if a:cchar == 'l'\n      call assert_fails('lopen', 'E776:')\n      call assert_fails('lwindow', 'E776:')\n  endif\n\n  \" Create a list with no valid entries\n  Xgetexpr ['non-error 1', 'non-error 2', 'non-error 3']\n\n  \" Quickfix/Location window should not open with no valid errors\n  Xwindow\n  call assert_true(winnr('$') == 1)\n\n  \" Create a list with valid entries\n  let lines =<< trim END\n    Xtestfile1:1:3:Line1\n    Xtestfile2:2:2:Line2\n    Xtestfile3:3:1:Line3\n  END\n  Xgetexpr lines\n\n  \" Open the window\n  Xwindow\n  call assert_true(winnr('$') == 2 && winnr() == 2 &&\n\t\\ getline('.') ==# 'Xtestfile1|1 col 3| Line1')\n  redraw!\n\n  \" Close the window\n  Xclose\n  call assert_true(winnr('$') == 1)\n\n  \" Create a list with no valid entries\n  Xgetexpr ['non-error 1', 'non-error 2', 'non-error 3']\n\n  \" Open the window\n  Xopen 5\n  call assert_true(winnr('$') == 2 && getline('.') ==# '|| non-error 1'\n\t\t      \\  && winheight(0) == 5)\n\n  \" Opening the window again, should move the cursor to that window\n  wincmd t\n  Xopen 7\n  call assert_true(winnr('$') == 2 && winnr() == 2 &&\n\t\\ winheight(0) == 7 &&\n\t\\ getline('.') ==# '|| non-error 1')\n\n  \" :cnext in quickfix window should move to the next entry\n  Xnext\n  call assert_equal(2, g:Xgetlist({'idx' : 0}).idx)\n\n  \" Calling cwindow should close the quickfix window with no valid errors\n  Xwindow\n  call assert_true(winnr('$') == 1)\n\n  \" Specifying the width should adjust the width for a vertically split\n  \" quickfix window.\n  vert Xopen\n  call assert_equal(10, winwidth(0))\n  vert Xopen 12\n  call assert_equal(12, winwidth(0))\n  Xclose\n\n  \" Horizontally or vertically splitting the quickfix window should create a\n  \" normal window/buffer\n  Xopen\n  wincmd s\n  call assert_equal(0, getwininfo(win_getid())[0].quickfix)\n  call assert_equal(0, getwininfo(win_getid())[0].loclist)\n  call assert_notequal('quickfix', &buftype)\n  close\n  Xopen\n  wincmd v\n  call assert_equal(0, getwininfo(win_getid())[0].quickfix)\n  call assert_equal(0, getwininfo(win_getid())[0].loclist)\n  call assert_notequal('quickfix', &buftype)\n  close\n  Xopen\n  Xclose\n\n  if a:cchar == 'c'\n      \" Opening the quickfix window in multiple tab pages should reuse the\n      \" quickfix buffer\n      let lines =<< trim END\n        Xtestfile1:1:3:Line1\n        Xtestfile2:2:2:Line2\n        Xtestfile3:3:1:Line3\n      END\n      Xgetexpr lines\n      Xopen\n      let qfbufnum = bufnr('%')\n      tabnew\n      Xopen\n      call assert_equal(qfbufnum, bufnr('%'))\n      new | only | tabonly\n  endif\nendfunc\n\nfunc Test_cwindow()\n  call XwindowTests('c')\n  call XwindowTests('l')\nendfunc\n\nfunc Test_copenHeight()\n  copen\n  wincmd H\n  let height = winheight(0)\n  copen 10\n  call assert_equal(height, winheight(0))\n  quit\nendfunc\n\nfunc Test_copenHeight_tabline()\n  set tabline=foo showtabline=2\n  copen\n  wincmd H\n  let height = winheight(0)\n  copen 10\n  call assert_equal(height, winheight(0))\n  quit\n  set tabline& showtabline&\nendfunc\n\n\" Tests for the :cfile, :lfile, :caddfile, :laddfile, :cgetfile and :lgetfile\n\" commands.\nfunc XfileTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  let lines =<< trim END\n    Xtestfile1:700:10:Line 700\n    Xtestfile2:800:15:Line 800\n  END\n  call writefile(lines, 'Xqftestfile1')\n\n  enew!\n  Xfile Xqftestfile1\n  let l = g:Xgetlist()\n  call assert_true(len(l) == 2 &&\n\t\\ l[0].lnum == 700 && l[0].col == 10 && l[0].text ==# 'Line 700' &&\n\t\\ l[1].lnum == 800 && l[1].col == 15 && l[1].text ==# 'Line 800')\n\n  \" Test with a non existent file\n  call assert_fails('Xfile non_existent_file', 'E40:')\n\n  \" Run cfile/lfile from a modified buffer\n  enew!\n  silent! put ='Quickfix'\n  silent! Xfile Xqftestfile1\n  call assert_true(v:errmsg ==# 'E37: No write since last change (add ! to override)')\n\n  call writefile(['Xtestfile3:900:30:Line 900'], 'Xqftestfile1')\n  Xaddfile Xqftestfile1\n  let l = g:Xgetlist()\n  call assert_true(len(l) == 3 &&\n\t\\ l[2].lnum == 900 && l[2].col == 30 && l[2].text ==# 'Line 900')\n\n  let lines =<< trim END\n    Xtestfile1:222:77:Line 222\n    Xtestfile2:333:88:Line 333\n  END\n  call writefile(lines, 'Xqftestfile1')\n\n  enew!\n  Xgetfile Xqftestfile1\n  let l = g:Xgetlist()\n  call assert_true(len(l) == 2 &&\n\t\\ l[0].lnum == 222 && l[0].col == 77 && l[0].text ==# 'Line 222' &&\n\t\\ l[1].lnum == 333 && l[1].col == 88 && l[1].text ==# 'Line 333')\n\n  \" Test for a file with a long line and without a newline at the end\n  let text = repeat('x', 1024)\n  let t = 'a.txt:18:' . text\n  call writefile([t], 'Xqftestfile1', 'b')\n  silent! Xfile Xqftestfile1\n  call assert_equal(text, g:Xgetlist()[0].text)\n\n  call delete('Xqftestfile1')\nendfunc\n\nfunc Test_cfile()\n  call XfileTests('c')\n  call XfileTests('l')\nendfunc\n\n\" Tests for the :cbuffer, :lbuffer, :caddbuffer, :laddbuffer, :cgetbuffer and\n\" :lgetbuffer commands.\nfunc XbufferTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  enew!\n  let lines =<< trim END\n    Xtestfile7:700:10:Line 700\n    Xtestfile8:800:15:Line 800\n  END\n  silent! call setline(1, lines)\n  Xbuffer!\n  let l = g:Xgetlist()\n  call assert_true(len(l) == 2 &&\n\t\\ l[0].lnum == 700 && l[0].col == 10 && l[0].text ==# 'Line 700' &&\n\t\\ l[1].lnum == 800 && l[1].col == 15 && l[1].text ==# 'Line 800')\n\n  enew!\n  let lines =<< trim END\n    Xtestfile9:900:55:Line 900\n    Xtestfile10:950:66:Line 950\n  END\n  silent! call setline(1, lines)\n  Xgetbuffer\n  let l = g:Xgetlist()\n  call assert_true(len(l) == 2 &&\n\t\\ l[0].lnum == 900 && l[0].col == 55 && l[0].text ==# 'Line 900' &&\n\t\\ l[1].lnum == 950 && l[1].col == 66 && l[1].text ==# 'Line 950')\n\n  enew!\n  let lines =<< trim END\n    Xtestfile11:700:20:Line 700\n    Xtestfile12:750:25:Line 750\n  END\n  silent! call setline(1, lines)\n  Xaddbuffer\n  let l = g:Xgetlist()\n  call assert_true(len(l) == 4 &&\n\t\\ l[1].lnum == 950 && l[1].col == 66 && l[1].text ==# 'Line 950' &&\n\t\\ l[2].lnum == 700 && l[2].col == 20 && l[2].text ==# 'Line 700' &&\n\t\\ l[3].lnum == 750 && l[3].col == 25 && l[3].text ==# 'Line 750')\n  enew!\n\n  \" Check for invalid buffer\n  call assert_fails('Xbuffer 199', 'E474:')\n\n  \" Check for unloaded buffer\n  edit Xtestfile1\n  let bnr = bufnr('%')\n  enew!\n  call assert_fails('Xbuffer ' . bnr, 'E681:')\n\n  \" Check for invalid range\n  \" Using Xbuffer will not run the range check in the cbuffer/lbuffer\n  \" commands. So directly call the commands.\n  if (a:cchar == 'c')\n      call assert_fails('900,999cbuffer', 'E16:')\n  else\n      call assert_fails('900,999lbuffer', 'E16:')\n  endif\nendfunc\n\nfunc Test_cbuffer()\n  call XbufferTests('c')\n  call XbufferTests('l')\nendfunc\n\nfunc XexprTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call assert_fails('Xexpr 10', 'E777:')\nendfunc\n\nfunc Test_cexpr()\n  call XexprTests('c')\n  call XexprTests('l')\nendfunc\n\n\" Tests for :cnext, :cprev, :cfirst, :clast commands\nfunc Xtest_browse(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n  \" Jumping to first or next location list entry without any error should\n  \" result in failure\n  if a:cchar == 'c'\n    let err = 'E42:'\n    let cmd = '$cc'\n  else\n    let err = 'E776:'\n    let cmd = '$ll'\n  endif\n  call assert_fails('Xnext', err)\n  call assert_fails('Xprev', err)\n  call assert_fails('Xnfile', err)\n  call assert_fails('Xpfile', err)\n  call assert_fails(cmd, err)\n\n  Xexpr ''\n  call assert_fails(cmd, 'E42:')\n\n  call s:create_test_file('Xqftestfile1')\n  call s:create_test_file('Xqftestfile2')\n\n  let lines =<< trim END\n    Xqftestfile1:5:Line5\n    Xqftestfile1:6:Line6\n    Xqftestfile2:10:Line10\n    Xqftestfile2:11:Line11\n    RegularLine1\n    RegularLine2\n  END\n  Xgetexpr lines\n\n  Xfirst\n  call assert_fails('-5Xcc', 'E16:')\n  call assert_fails('Xprev', 'E553:')\n  call assert_fails('Xpfile', 'E553:')\n  Xnfile\n  call assert_equal('Xqftestfile2', @%)\n  call assert_equal(10, line('.'))\n  Xpfile\n  call assert_equal('Xqftestfile1', @%)\n  call assert_equal(6, line('.'))\n  5Xcc\n  call assert_equal(5, g:Xgetlist({'idx':0}).idx)\n  2Xcc\n  call assert_equal(2, g:Xgetlist({'idx':0}).idx)\n  if a:cchar == 'c'\n    cc\n  else\n    ll\n  endif\n  call assert_equal(2, g:Xgetlist({'idx':0}).idx)\n  10Xcc\n  call assert_equal(6, g:Xgetlist({'idx':0}).idx)\n  Xlast\n  Xprev\n  call assert_equal('Xqftestfile2', @%)\n  call assert_equal(11, line('.'))\n  call assert_fails('Xnext', 'E553:')\n  call assert_fails('Xnfile', 'E553:')\n  \" To process the range using quickfix list entries, directly use the\n  \" quickfix commands (don't use the user defined commands)\n  if a:cchar == 'c'\n    $cc\n  else\n    $ll\n  endif\n  call assert_equal(6, g:Xgetlist({'idx':0}).idx)\n  Xrewind\n  call assert_equal('Xqftestfile1', @%)\n  call assert_equal(5, line('.'))\n\n  10Xnext\n  call assert_equal('Xqftestfile2', @%)\n  call assert_equal(11, line('.'))\n  10Xprev\n  call assert_equal('Xqftestfile1', @%)\n  call assert_equal(5, line('.'))\n\n  \" Jumping to an error from the error window using cc command\n  let lines =<< trim END\n    Xqftestfile1:5:Line5\n    Xqftestfile1:6:Line6\n    Xqftestfile2:10:Line10\n    Xqftestfile2:11:Line11\n  END\n  Xgetexpr lines\n  Xopen\n  10Xcc\n  call assert_equal(11, line('.'))\n  call assert_equal('Xqftestfile2', @%)\n  Xopen\n  call cursor(2, 1)\n  if a:cchar == 'c'\n    .cc\n  else\n    .ll\n  endif\n  call assert_equal(6, line('.'))\n  call assert_equal('Xqftestfile1', @%)\n\n  \" Jumping to an error from the error window (when only the error window is\n  \" present)\n  Xopen | only\n  Xlast 1\n  call assert_equal(5, line('.'))\n  call assert_equal('Xqftestfile1', @%)\n\n  Xexpr \"\"\n  call assert_fails('Xnext', 'E42:')\n\n  call delete('Xqftestfile1')\n  call delete('Xqftestfile2')\n\n  \" Should be able to use next/prev with invalid entries\n  Xexpr \"\"\n  call assert_equal(0, g:Xgetlist({'idx' : 0}).idx)\n  call assert_equal(0, g:Xgetlist({'size' : 0}).size)\n  Xaddexpr ['foo', 'bar', 'baz', 'quux', 'sh|moo']\n  call assert_equal(5, g:Xgetlist({'size' : 0}).size)\n  Xlast\n  call assert_equal(5, g:Xgetlist({'idx' : 0}).idx)\n  Xfirst\n  call assert_equal(1, g:Xgetlist({'idx' : 0}).idx)\n  2Xnext\n  call assert_equal(3, g:Xgetlist({'idx' : 0}).idx)\nendfunc\n\nfunc Test_browse()\n  call Xtest_browse('c')\n  call Xtest_browse('l')\nendfunc\n\n\" Test for memory allocation failures\nfunc Xnomem_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call test_alloc_fail(GetAllocId('qf_dirname_start'), 0, 0)\n  call assert_fails('Xvimgrep vim runtest.vim', 'E342:')\n\n  call test_alloc_fail(GetAllocId('qf_dirname_now'), 0, 0)\n  call assert_fails('Xvimgrep vim runtest.vim', 'E342:')\n\n  call test_alloc_fail(GetAllocId('qf_namebuf'), 0, 0)\n  call assert_fails('Xfile runtest.vim', 'E342:')\n\n  call test_alloc_fail(GetAllocId('qf_errmsg'), 0, 0)\n  call assert_fails('Xfile runtest.vim', 'E342:')\n\n  call test_alloc_fail(GetAllocId('qf_pattern'), 0, 0)\n  call assert_fails('Xfile runtest.vim', 'E342:')\n\n  call test_alloc_fail(GetAllocId('qf_efm_fmtstr'), 0, 0)\n  set efm=%f\n  call assert_fails('Xexpr [\"Xfile1\"]', 'E342:')\n  set efm&\n\n  call test_alloc_fail(GetAllocId('qf_efm_fmtpart'), 0, 0)\n  set efm=%f:%l:%m,%f-%l-%m\n  call assert_fails('Xaddexpr [\"Xfile2\", \"Xfile3\"]', 'E342:')\n  set efm&\n\n  call test_alloc_fail(GetAllocId('qf_title'), 0, 0)\n  call assert_fails('Xexpr \"\"', 'E342:')\n  call assert_equal('', g:Xgetlist({'all': 1}).title)\n\n  call test_alloc_fail(GetAllocId('qf_mef_name'), 0, 0)\n  set makeef=Xtmp##.err\n  call assert_fails('Xgrep needle haystack', 'E342:')\n  set makeef&\n\n  call test_alloc_fail(GetAllocId('qf_qfline'), 0, 0)\n  call assert_fails('Xexpr \"Xfile1:10:Line10\"', 'E342:')\n\n  if a:cchar == 'l'\n    for id in ['qf_qfline', 'qf_qfinfo']\n      lgetexpr [\"Xfile1:10:L10\", \"Xfile2:20:L20\"]\n      call test_alloc_fail(GetAllocId(id), 0, 0)\n      call assert_fails('new', 'E342:')\n      call assert_equal(2, winnr('$'))\n      call assert_equal([], getloclist(0))\n      %bw!\n    endfor\n  endif\n\n  call test_alloc_fail(GetAllocId('qf_qfline'), 0, 0)\n  try\n    call assert_fails('Xvimgrep vim runtest.vim', 'E342:')\n  catch /^Vim:Interrupt$/\n  endtry\n\n  call test_alloc_fail(GetAllocId('qf_qfline'), 0, 0)\n  try\n    call assert_fails('Xvimgrep /vim/f runtest.vim', 'E342:')\n  catch /^Vim:Interrupt$/\n  endtry\n\n  let l = getqflist({\"lines\": [\"Xfile1:10:L10\"]})\n  call test_alloc_fail(GetAllocId('qf_qfline'), 0, 0)\n  call assert_fails('call g:Xsetlist(l.items)', 'E342:')\n\n  call test_alloc_fail(GetAllocId('qf_qfline'), 0, 0)\n  try\n    call assert_fails('Xhelpgrep quickfix', 'E342:')\n  catch /^Vim:Interrupt$/\n  endtry\n\n  call test_alloc_fail(GetAllocId('qf_qfinfo'), 0, 0)\n  call assert_fails('let l = g:Xgetlist({\"lines\": [\"Xfile1:10:L10\"]})', 'E342:')\n  call assert_equal(#{items: []}, l)\n\n  if a:cchar == 'l'\n    call setqflist([], 'f')\n    call setloclist(0, [], 'f')\n    call test_alloc_fail(GetAllocId('qf_qfinfo'), 0, 0)\n    call assert_fails('lhelpgrep quickfix', 'E342:')\n    call assert_equal([], getloclist(0))\n\n    call test_alloc_fail(GetAllocId('qf_qfinfo'), 0, 0)\n    call assert_fails('lvimgrep vim runtest.vim', 'E342:')\n\n    let l = getqflist({\"lines\": [\"Xfile1:10:L10\"]})\n    call test_alloc_fail(GetAllocId('qf_qfinfo'), 0, 0)\n    call assert_fails('call setloclist(0, l.items)', 'E342:')\n\n    call test_alloc_fail(GetAllocId('qf_qfinfo'), 0, 0)\n    call assert_fails('lbuffer', 'E342:')\n\n    call test_alloc_fail(GetAllocId('qf_qfinfo'), 0, 0)\n    call assert_fails('lexpr [\"Xfile1:10:L10\", \"Xfile2:20:L20\"]', 'E342:')\n\n    call test_alloc_fail(GetAllocId('qf_qfinfo'), 0, 0)\n    call assert_fails('lfile runtest.vim', 'E342:')\n  endif\n\n  call test_alloc_fail(GetAllocId('qf_dirstack'), 0, 0)\n  set efm=%DEntering\\ dir\\ %f,%f:%l:%m\n  call assert_fails('Xexpr [\"Entering dir abc\", \"abc.txt:1:Hello world\"]', 'E342:')\n  set efm&\n\n  call test_alloc_fail(GetAllocId('qf_dirstack'), 0, 0)\n  set efm=%+P[%f],(%l)%m\n  call assert_fails('Xexpr [\"[runtest.vim]\", \"(1)Hello\"]', 'E342:')\n  set efm&\n\n  call test_alloc_fail(GetAllocId('qf_multiline_pfx'), 0, 0)\n  set efm=%EError,%Cline\\ %l,%Z%m\n  call assert_fails('Xexpr [\"Error\", \"line 1\", \"msg\"]', 'E342:')\n  set efm&\n\n  call test_alloc_fail(GetAllocId('qf_makecmd'), 0, 0)\n  call assert_fails('Xgrep vim runtest.vim', 'E342:')\n\n  call test_alloc_fail(GetAllocId('qf_linebuf'), 0, 0)\n  call assert_fails('Xexpr repeat(\"a\", 8192)', 'E342:')\n\n  call test_alloc_fail(GetAllocId('qf_linebuf'), 0, 0)\n  call assert_fails('Xexpr [repeat(\"a\", 8192)]', 'E342:')\n\n  new\n  call setline(1, repeat('a', 8192))\n  call test_alloc_fail(GetAllocId('qf_linebuf'), 0, 0)\n  call assert_fails('Xbuffer', 'E342:')\n  %bw!\n\n  call writefile([repeat('a', 8192)], 'Xtest')\n  call test_alloc_fail(GetAllocId('qf_linebuf'), 0, 0)\n  call assert_fails('Xfile Xtest', 'E342:')\n  call delete('Xtest')\nendfunc\n\nfunc Test_nomem()\n  call Xnomem_tests('c')\n  call Xnomem_tests('l')\nendfunc\n\nfunc s:test_xhelpgrep(cchar)\n  call s:setup_commands(a:cchar)\n  Xhelpgrep quickfix\n  Xopen\n  if a:cchar == 'c'\n    let title_text = ':helpgrep quickfix'\n  else\n    let title_text = ':lhelpgrep quickfix'\n  endif\n  call assert_true(w:quickfix_title =~ title_text, w:quickfix_title)\n\n  \" Jumping to a help topic should open the help window\n  only\n  Xnext\n  call assert_true(&buftype == 'help')\n  call assert_true(winnr('$') == 2)\n  \" Jumping to the next match should reuse the help window\n  Xnext\n  call assert_true(&buftype == 'help')\n  call assert_true(winnr() == 1)\n  call assert_true(winnr('$') == 2)\n  \" Jumping to the next match from the quickfix window should reuse the help\n  \" window\n  Xopen\n  Xnext\n  call assert_true(&buftype == 'help')\n  call assert_true(winnr() == 1)\n  call assert_true(winnr('$') == 2)\n  call assert_match('|\\d\\+ col \\d\\+-\\d\\+|', getbufline(winbufnr(2), 1)[0])\n\n  \" This wipes out the buffer, make sure that doesn't cause trouble.\n  Xclose\n\n  \" When the current window is vertically split, jumping to a help match\n  \" should open the help window at the top.\n  only | enew\n  let w1 = win_getid()\n  vert new\n  let w2 = win_getid()\n  Xnext\n  let w3 = win_getid()\n  call assert_true(&buftype == 'help')\n  call assert_true(winnr() == 1)\n  \" See jump_to_help_window() for details\n  let w2_width = winwidth(w2)\n  if w2_width != &columns && w2_width < 80\n    call assert_equal(['col', [['leaf', w3],\n          \\ ['row', [['leaf', w2], ['leaf', w1]]]]], winlayout())\n  else\n    call assert_equal(['row', [['col', [['leaf', w3], ['leaf', w2]]],\n          \\ ['leaf', w1]]] , winlayout())\n  endif\n\n  new | only\n  set buftype=help\n  set modified\n  call assert_fails('Xnext', 'E37:')\n  set nomodified\n  new | only\n\n  if a:cchar == 'l'\n      \" When a help window is present, running :lhelpgrep should reuse the\n      \" help window and not the current window\n      new | only\n      call g:Xsetlist([], 'f')\n      help index.txt\n      wincmd w\n      lhelpgrep quickfix\n      call assert_equal(1, winnr())\n      call assert_notequal([], getloclist(1))\n      call assert_equal([], getloclist(2))\n  endif\n\n  new | only\n\n  \" Search for non existing help string\n  call assert_fails('Xhelpgrep a1b2c3', 'E480:')\n  \" Invalid regular expression\n  call assert_fails('Xhelpgrep \\@<!', 'E866:')\nendfunc\n\nfunc Test_helpgrep()\n  call s:test_xhelpgrep('c')\n  helpclose\n  call s:test_xhelpgrep('l')\nendfunc\n\ndef Test_helpgrep_vim9_restore_cpo()\n  assert_equal('aABceFs', &cpo)\n\n  var rtp_save = &rtp\n  var dir = 'Xruntime/after'\n  &rtp ..= ',' .. dir\n  mkdir(dir .. '/ftplugin', 'p')\n  writefile(['vim9script'], dir .. '/ftplugin/qf.vim')\n  filetype plugin on\n  silent helpgrep grail\n  cwindow\n  silent helpgrep grail\n\n  assert_equal('aABceFs', &cpo)\n  delete('Xruntime', 'rf')\n  &rtp = rtp_save\n  cclose\n  helpclose\nenddef\n\n\" When running the :helpgrep command, if an autocmd modifies the 'cpoptions'\n\" value, then Vim crashes. (issue fixed by 7.2b-004 and 8.2.4453)\nfunc Test_helpgrep_restore_cpo_aucmd()\n  let save_cpo = &cpo\n  augroup QF_Test\n    au!\n    autocmd BufNew * set cpo=acd\n  augroup END\n\n  helpgrep quickfix\n  call assert_equal('acd', &cpo)\n  %bw!\n\n  set cpo&vim\n  augroup QF_Test\n    au!\n    autocmd BufReadPost * set cpo=\n  augroup END\n\n  helpgrep buffer\n  call assert_equal('', &cpo)\n\n  augroup QF_Test\n    au!\n  augroup END\n  %bw!\n  let &cpo = save_cpo\nendfunc\n\ndef Test_vim9_cexpr()\n  var text = 'somefile:95:error'\n  cexpr text\n  var l = getqflist()\n  assert_equal(1, l->len())\n  assert_equal(95, l[0].lnum)\n  assert_equal('error', l[0].text)\n\n  text = 'somefile:77:warning'\n  caddexpr text\n  l = getqflist()\n  assert_equal(2, l->len())\n  assert_equal(77, l[1].lnum)\n  assert_equal('warning', l[1].text)\nenddef\n\nfunc Test_errortitle()\n  augroup QfBufWinEnter\n    au!\n    au BufWinEnter * :let g:a=get(w:, 'quickfix_title', 'NONE')\n  augroup END\n  copen\n  let a=[{'lnum': 308, 'bufnr': bufnr(''), 'col': 58, 'valid': 1, 'vcol': 0, 'nr': 0, 'type': '', 'pattern': '', 'text': '    au BufWinEnter * :let g:a=get(w:, ''quickfix_title'', ''NONE'')'}]\n  call setqflist(a)\n  call assert_equal(':setqflist()', g:a)\n  augroup QfBufWinEnter\n    au!\n  augroup END\n  augroup! QfBufWinEnter\nendfunc\n\nfunc Test_vimgreptitle()\n  augroup QfBufWinEnter\n    au!\n    au BufWinEnter * :let g:a=get(w:, 'quickfix_title', 'NONE')\n  augroup END\n  try\n    vimgrep /pattern/j file\n  catch /E480/\n  endtry\n  copen\n  call assert_equal(':    vimgrep /pattern/j file', g:a)\n  augroup QfBufWinEnter\n    au!\n  augroup END\n  augroup! QfBufWinEnter\nendfunc\n\nfunc Test_bufwinenter_once()\n  augroup QfBufWinEnter\n    au!\n    au BufWinEnter * let g:got_afile ..= 'got ' .. expand('<afile>')\n  augroup END\n  let g:got_afile = ''\n  copen\n  call assert_equal('got quickfix', g:got_afile)\n\n  cclose\n  unlet g:got_afile\n  augroup QfBufWinEnter\n    au!\n  augroup END\n  augroup! QfBufWinEnter\nendfunc\n\nfunc XqfTitleTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  Xgetexpr ['file:1:1:message']\n  let l = g:Xgetlist()\n  if a:cchar == 'c'\n    call setqflist(l, 'r')\n  else\n    call setloclist(0, l, 'r')\n  endif\n\n  Xopen\n  if a:cchar == 'c'\n    let title = ':setqflist()'\n  else\n    let title = ':setloclist()'\n  endif\n  call assert_equal(title, w:quickfix_title)\n  Xclose\nendfunc\n\n\" Tests for quickfix window's title\nfunc Test_qf_title()\n  call XqfTitleTests('c')\n  call XqfTitleTests('l')\nendfunc\n\n\" Tests for 'errorformat'\nfunc Test_efm()\n  let save_efm = &efm\n  set efm=%EEEE%m,%WWWW%m,%+CCCC%.%#,%-GGGG%.%#\n  cgetexpr ['WWWW', 'EEEE', 'CCCC']\n  let l = strtrans(string(map(getqflist(), '[v:val.text, v:val.valid]')))\n  call assert_equal(\"[['W', 1], ['E^@CCCC', 1]]\", l)\n  cgetexpr ['WWWW', 'GGGG', 'EEEE', 'CCCC']\n  let l = strtrans(string(map(getqflist(), '[v:val.text, v:val.valid]')))\n  call assert_equal(\"[['W', 1], ['E^@CCCC', 1]]\", l)\n  cgetexpr ['WWWW', 'GGGG', 'ZZZZ', 'EEEE', 'CCCC', 'YYYY']\n  let l = strtrans(string(map(getqflist(), '[v:val.text, v:val.valid]')))\n  call assert_equal(\"[['W', 1], ['ZZZZ', 0], ['E^@CCCC', 1], ['YYYY', 0]]\", l)\n  let &efm = save_efm\nendfunc\n\n\" This will test for problems in quickfix:\n\" A. incorrectly copying location lists which caused the location list to show\n\"    a different name than the file that was actually being displayed.\n\" B. not reusing the window for which the location list window is opened but\n\"    instead creating new windows.\n\" C. make sure that the location list window is not reused instead of the\n\"    window it belongs to.\n\"\n\" Set up the test environment:\nfunc ReadTestProtocol(name)\n  let base = substitute(a:name, '\\v^test://(.*)%(\\.[^.]+)?', '\\1', '')\n  let word = substitute(base, '\\v(.*)\\..*', '\\1', '')\n\n  setl modifiable\n  setl noreadonly\n  setl noswapfile\n  setl bufhidden=delete\n  %del _\n  \" For problem 2:\n  \" 'buftype' has to be set to reproduce the constant opening of new windows\n  setl buftype=nofile\n\n  call setline(1, word)\n\n  setl nomodified\n  setl nomodifiable\n  setl readonly\n  exe 'doautocmd BufRead ' . substitute(a:name, '\\v^test://(.*)', '\\1', '')\nendfunc\n\nfunc Test_locationlist()\n  enew\n\n  augroup testgroup\n    au!\n    autocmd BufReadCmd test://* call ReadTestProtocol(expand(\"<amatch>\"))\n  augroup END\n\n  let words = [ \"foo\", \"bar\", \"baz\", \"quux\", \"shmoo\", \"spam\", \"eggs\" ]\n\n  let qflist = []\n  for word in words\n    call add(qflist, {'filename': 'test://' . word . '.txt', 'text': 'file ' . word . '.txt', })\n    \" NOTE: problem 1:\n    \" intentionally not setting 'lnum' so that the quickfix entries are not\n    \" valid\n    eval qflist->setloclist(0, ' ')\n  endfor\n\n  \" Test A\n  lrewind\n  enew\n  lopen\n  4lnext\n  vert split\n  wincmd L\n  lopen\n  wincmd p\n  lnext\n  let fileName = expand(\"%\")\n  wincmd p\n  let locationListFileName = substitute(getline(line('.')), '\\([^|]*\\)|.*', '\\1', '')\n  let fileName = substitute(fileName, '\\\\', '/', 'g')\n  let locationListFileName = substitute(locationListFileName, '\\\\', '/', 'g')\n  call assert_equal(\"test://bar.txt\", fileName)\n  call assert_equal(\"test://bar.txt\", locationListFileName)\n\n  wincmd n | only\n\n  \" Test B:\n  lrewind\n  lopen\n  2\n  exe \"normal \\<CR>\"\n  wincmd p\n  3\n  exe \"normal \\<CR>\"\n  wincmd p\n  4\n  exe \"normal \\<CR>\"\n  call assert_equal(2, winnr('$'))\n  wincmd n | only\n\n  \" Test C:\n  lrewind\n  lopen\n  \" Let's move the location list window to the top to check whether it (the\n  \" first window found) will be reused when we try to open new windows:\n  wincmd K\n  2\n  exe \"normal \\<CR>\"\n  wincmd p\n  3\n  exe \"normal \\<CR>\"\n  wincmd p\n  4\n  exe \"normal \\<CR>\"\n  1wincmd w\n  call assert_equal('quickfix', &buftype)\n  2wincmd w\n  let bufferName = expand(\"%\")\n  let bufferName = substitute(bufferName, '\\\\', '/', 'g')\n  call assert_equal('test://quux.txt', bufferName)\n\n  wincmd n | only\n\n  augroup! testgroup\nendfunc\n\nfunc Test_locationlist_curwin_was_closed()\n  augroup testgroup\n    au!\n    autocmd BufReadCmd test_curwin.txt call R(expand(\"<amatch>\"))\n  augroup END\n\n  func! R(n)\n    quit\n  endfunc\n\n  new\n  let q = []\n  call add(q, {'filename': 'test_curwin.txt' })\n  call setloclist(0, q)\n  call assert_fails('lrewind', 'E924:')\n\n  augroup! testgroup\n  delfunc R\nendfunc\n\nfunc Test_locationlist_cross_tab_jump()\n  call writefile(['loclistfoo'], 'loclistfoo')\n  call writefile(['loclistbar'], 'loclistbar')\n  set switchbuf=usetab\n\n  edit loclistfoo\n  tabedit loclistbar\n  silent lgrep loclistfoo loclist*\n  call assert_equal(1, tabpagenr())\n\n  enew | only | tabonly\n  set switchbuf&vim\n  call delete('loclistfoo')\n  call delete('loclistbar')\nendfunc\n\n\" More tests for 'errorformat'\nfunc Test_efm1()\n  \" The 'errorformat' setting is different on non-Unix systems.\n  \" This test works only on Unix-like systems.\n  CheckUnix\n\n  let l =<< trim [DATA]\n    \"Xtestfile\", line 4.12: 1506-045 (S) Undeclared identifier fd_set.\n    \ufeff\"Xtestfile\", line 6 col 19; this is an error\n    gcc -c -DHAVE_CONFIsing-prototypes -I/usr/X11R6/include  version.c\n    Xtestfile:9: parse error before `asd'\n    make: *** [vim] Error 1\n    in file \"Xtestfile\" linenr 10: there is an error\n\n    2 returned\n    \"Xtestfile\", line 11 col 1; this is an error\n    \"Xtestfile\", line 12 col 2; this is another error\n    \"Xtestfile\", line 14:10; this is an error in column 10\n    =Xtestfile=, line 15:10; this is another error, but in vcol 10 this time\n    \"Xtestfile\", linenr 16: yet another problem\n    Error in \"Xtestfile\" at line 17:\n    x should be a dot\n    \txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 17\n                ^\n    Error in \"Xtestfile\" at line 18:\n    x should be a dot\n    \txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 18\n    .............^\n    Error in \"Xtestfile\" at line 19:\n    x should be a dot\n    \txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 19\n    --------------^\n    Error in \"Xtestfile\" at line 20:\n    x should be a dot\n    \txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 20\n    \t       ^\n\n    Does anyone know what is the problem and how to correction it?\n    \"Xtestfile\", line 21 col 9: What is the title of the quickfix window?\n    \"Xtestfile\", line 22 col 9: What is the title of the quickfix window?\n  [DATA]\n\n  call writefile(l, 'Xerrorfile1')\n  call writefile(l[:-2], 'Xerrorfile2')\n\n  let m =<< [DATA]\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  2\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  3\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  4\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  5\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  6\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  7\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  8\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  9\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 10\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 11\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 12\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 13\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 14\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 15\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 16\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 17\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 18\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 19\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 20\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 21\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 22\n[DATA]\n  call writefile(m, 'Xtestfile')\n\n  let save_efm = &efm\n  set efm+==%f=\\\\,\\ line\\ %l%*\\\\D%v%*[^\\ ]\\ %m\n  set efm^=%AError\\ in\\ \\\"%f\\\"\\ at\\ line\\ %l:,%Z%p^,%C%m\n\n  exe 'cf Xerrorfile2'\n  clast\n  copen\n  call assert_equal(':cf Xerrorfile2', w:quickfix_title)\n  wincmd p\n\n  exe 'cf Xerrorfile1'\n  call assert_equal([4, 12], [line('.'), col('.')])\n  cn\n  call assert_equal([6, 19], [line('.'), col('.')])\n  cn\n  call assert_equal([9, 2], [line('.'), col('.')])\n  cn\n  call assert_equal([10, 2], [line('.'), col('.')])\n  cn\n  call assert_equal([11, 1], [line('.'), col('.')])\n  cn\n  call assert_equal([12, 2], [line('.'), col('.')])\n  cn\n  call assert_equal([14, 10], [line('.'), col('.')])\n  cn\n  call assert_equal([15, 3, 10], [line('.'), col('.'), virtcol('.')])\n  cn\n  call assert_equal([16, 2], [line('.'), col('.')])\n  cn\n  call assert_equal([17, 6], [line('.'), col('.')])\n  cn\n  call assert_equal([18, 7], [line('.'), col('.')])\n  cn\n  call assert_equal([19, 8], [line('.'), col('.')])\n  cn\n  call assert_equal([20, 9], [line('.'), col('.')])\n  clast\n  cprev\n  cprev\n  wincmd w\n  call assert_equal(':cf Xerrorfile1', w:quickfix_title)\n  wincmd p\n\n  let &efm = save_efm\n  call delete('Xerrorfile1')\n  call delete('Xerrorfile2')\n  call delete('Xtestfile')\nendfunc\n\n\" Test for quickfix directory stack support\nfunc s:dir_stack_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  let save_efm=&efm\n  set efm=%DEntering\\ dir\\ '%f',%f:%l:%m,%XLeaving\\ dir\\ '%f'\n\n  let lines =<< trim END\n    Entering dir 'dir1/a'\n    habits2.txt:1:Nine Healthy Habits\n    Entering dir 'b'\n    habits3.txt:2:0 Hours of television\n    habits2.txt:7:5 Small meals\n    Entering dir 'dir1/c'\n    habits4.txt:3:1 Hour of exercise\n    Leaving dir 'dir1/c'\n    Leaving dir 'dir1/a'\n    habits1.txt:4:2 Liters of water\n    Entering dir 'dir2'\n    habits5.txt:5:3 Cups of hot green tea\n    Leaving dir 'dir2'\n  END\n\n  Xexpr \"\"\n  for l in lines\n      Xaddexpr l\n  endfor\n\n  let qf = g:Xgetlist()\n\n  call assert_equal('dir1/a/habits2.txt', bufname(qf[1].bufnr))\n  call assert_equal(1, qf[1].lnum)\n  call assert_equal('dir1/a/b/habits3.txt', bufname(qf[3].bufnr))\n  call assert_equal(2, qf[3].lnum)\n  call assert_equal('dir1/a/habits2.txt', bufname(qf[4].bufnr))\n  call assert_equal(7, qf[4].lnum)\n  call assert_equal('dir1/c/habits4.txt', bufname(qf[6].bufnr))\n  call assert_equal(3, qf[6].lnum)\n  call assert_equal('habits1.txt', bufname(qf[9].bufnr))\n  call assert_equal(4, qf[9].lnum)\n  call assert_equal('dir2/habits5.txt', bufname(qf[11].bufnr))\n  call assert_equal(5, qf[11].lnum)\n\n  let &efm=save_efm\nendfunc\n\n\" Tests for %D and %X errorformat options\nfunc Test_efm_dirstack()\n  \" Create the directory stack and files\n  call mkdir('dir1')\n  call mkdir('dir1/a')\n  call mkdir('dir1/a/b')\n  call mkdir('dir1/c')\n  call mkdir('dir2')\n\n  let lines =<< trim END\n    Nine Healthy Habits\n    0 Hours of television\n    1 Hour of exercise\n    2 Liters of water\n    3 Cups of hot green tea\n    4 Short mental breaks\n    5 Small meals\n    6 AM wake up time\n    7 Minutes of laughter\n    8 Hours of sleep (at least)\n    9 PM end of the day and off to bed\n  END\n  call writefile(lines, 'habits1.txt')\n  call writefile(lines, 'dir1/a/habits2.txt')\n  call writefile(lines, 'dir1/a/b/habits3.txt')\n  call writefile(lines, 'dir1/c/habits4.txt')\n  call writefile(lines, 'dir2/habits5.txt')\n\n  call s:dir_stack_tests('c')\n  call s:dir_stack_tests('l')\n\n  call delete('dir1', 'rf')\n  call delete('dir2', 'rf')\n  call delete('habits1.txt')\nendfunc\n\n\" Test for resync after continuing an ignored message\nfunc Xefm_ignore_continuations(cchar)\n  call s:setup_commands(a:cchar)\n\n  let save_efm = &efm\n\n  let &efm =\n\t\\ '%Eerror %m %l,' .\n\t\\ '%-Wignored %m %l,' .\n\t\\ '%+Cmore ignored %m %l,' .\n\t\\ '%Zignored end'\n  let lines =<< trim END\n    ignored warning 1\n    more ignored continuation 2\n    ignored end\n    error resync 4\n  END\n  Xgetexpr lines\n  let l = map(g:Xgetlist(), '[v:val.text, v:val.valid, v:val.lnum, v:val.type]')\n  call assert_equal([['resync', 1, 4, 'E']], l)\n\n  let &efm = save_efm\nendfunc\n\nfunc Test_efm_ignore_continuations()\n  call Xefm_ignore_continuations('c')\n  call Xefm_ignore_continuations('l')\nendfunc\n\n\" Tests for invalid error format specifies\nfunc Xinvalid_efm_Tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  let save_efm = &efm\n\n  set efm=%f:%l:%m,%f:%f:%l:%m\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E372:')\n\n  set efm=%f:%l:%m,%f:%l:%r:%m\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E373:')\n\n  set efm=%f:%l:%m,%O:%f:%l:%m\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E373:')\n\n  set efm=%f:%l:%m,%f:%l:%*[^a-z\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E374:')\n\n  set efm=%f:%l:%m,%f:%l:%*c\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E375:')\n\n  set efm=%f:%l:%m,%L%M%N\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E376:')\n\n  set efm=%f:%l:%m,%f:%l:%m:%R\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E377:')\n\n  \" Invalid regular expression\n  set efm=%\\\\%%k\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E867:')\n\n  set efm=\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E378:')\n\n  \" Empty directory name. When there is an error in parsing new entries, make\n  \" sure the previous quickfix list is made the current list.\n  set efm&\n  cexpr [\"one\", \"two\"]\n  let qf_id = getqflist(#{id: 0}).id\n  set efm=%DEntering\\ dir\\ abc,%f:%l:%m\n  call assert_fails('Xexpr [\"Entering dir abc\", \"abc.txt:1:Hello world\"]', 'E379:')\n  call assert_equal(qf_id, getqflist(#{id: 0}).id)\n\n  let &efm = save_efm\nendfunc\n\nfunc Test_invalid_efm()\n  call Xinvalid_efm_Tests('c')\n  call Xinvalid_efm_Tests('l')\nendfunc\n\n\" TODO:\n\" Add tests for the following formats in 'errorformat'\n\"\t%r  %O\nfunc Test_efm2()\n  let save_efm = &efm\n\n  \" Test for %s format in efm\n  set efm=%f:%s\n  cexpr 'Xtestfile:Line search text'\n  let l = getqflist()\n  call assert_equal('^\\VLine search text\\$', l[0].pattern)\n  call assert_equal(0, l[0].lnum)\n\n  let l = split(execute('clist', ''), \"\\n\")\n  call assert_equal([' 1 Xtestfile:^\\VLine search text\\$:  '], l)\n\n  \" Test for a long line\n  cexpr 'Xtestfile:' . repeat('a', 1026)\n  let l = getqflist()\n  call assert_equal('^\\V' . repeat('a', 1019) . '\\$', l[0].pattern)\n\n  \" Test for %P, %Q and %t format specifiers\n  let lines =<< trim [DATA]\n    [Xtestfile1]\n    (1,17)  error: ';' missing\n    (21,2)  warning: variable 'z' not defined\n    (67,3)  error: end of file found before string ended\n    --\n\n    [Xtestfile2]\n    --\n\n    [Xtestfile3]\n    NEW compiler v1.1\n    (2,2)   warning: variable 'x' not defined\n    (67,3)  warning: 's' already defined\n    --\n  [DATA]\n\n  set efm=%+P[%f]%r,(%l\\\\,%c)%*[\\ ]%t%*[^:]:\\ %m,%+Q--%r\n  \" To exercise the push/pop file functionality in quickfix, the test files\n  \" need to be created.\n  call writefile(['Line1'], 'Xtestfile1')\n  call writefile(['Line2'], 'Xtestfile2')\n  call writefile(['Line3'], 'Xtestfile3')\n  cexpr \"\"\n  for l in lines\n      caddexpr l\n  endfor\n  let l = getqflist()\n  call assert_equal(12, len(l))\n  call assert_equal(21, l[2].lnum)\n  call assert_equal(2, l[2].col)\n  call assert_equal('w', l[2].type)\n  call assert_equal('e', l[3].type)\n  call delete('Xtestfile1')\n  call delete('Xtestfile2')\n  call delete('Xtestfile3')\n\n  \" Test for %P, %Q with non-existing files\n  cexpr lines\n  let l = getqflist()\n  call assert_equal(14, len(l))\n  call assert_equal('[Xtestfile1]', l[0].text)\n  call assert_equal('[Xtestfile2]', l[6].text)\n  call assert_equal('[Xtestfile3]', l[9].text)\n\n  \" Tests for %E, %C and %Z format specifiers\n  let lines =<< trim [DATA]\n    Error 275\n    line 42\n    column 3\n    ' ' expected after '--'\n  [DATA]\n\n  set efm=%EError\\ %n,%Cline\\ %l,%Ccolumn\\ %c,%Z%m\n  cgetexpr lines\n  let l = getqflist()\n  call assert_equal(275, l[0].nr)\n  call assert_equal(42, l[0].lnum)\n  call assert_equal(3, l[0].col)\n  call assert_equal('E', l[0].type)\n  call assert_equal(\"\\n' ' expected after '--'\", l[0].text)\n\n  \" Test for %>\n  let lines =<< trim [DATA]\n    Error in line 147 of foo.c:\n    unknown variable 'i'\n  [DATA]\n\n  set efm=unknown\\ variable\\ %m,%E%>Error\\ in\\ line\\ %l\\ of\\ %f:,%Z%m\n  cgetexpr lines\n  let l = getqflist()\n  call assert_equal(147, l[0].lnum)\n  call assert_equal('E', l[0].type)\n  call assert_equal(\"\\nunknown variable 'i'\", l[0].text)\n\n  \" Test for %A, %C and other formats\n  let lines =<< trim [DATA]\n    ==============================================================\n    FAIL: testGetTypeIdCachesResult (dbfacadeTest.DjsDBFacadeTest)\n    --------------------------------------------------------------\n    Traceback (most recent call last):\n      File \"unittests/dbfacadeTest.py\", line 89, in testFoo\n        self.assertEquals(34, dtid)\n      File \"/usr/lib/python2.2/unittest.py\", line 286, in\n     failUnlessEqual\n        raise self.failureException, \\\\\n    W:AssertionError: 34 != 33\n  \n    --------------------------------------------------------------\n    Ran 27 tests in 0.063s\n  [DATA]\n\n  set efm=%C\\ %.%#,%A\\ \\ File\\ \\\"%f\\\"\\\\,\\ line\\ %l%.%#,%Z%[%^\\ ]%\\\\@=%t:%m\n  cgetexpr lines\n  let l = getqflist()\n  call assert_equal(8, len(l))\n  call assert_equal(89, l[4].lnum)\n  call assert_equal(1, l[4].valid)\n  call assert_equal('unittests/dbfacadeTest.py', bufname(l[4].bufnr))\n  call assert_equal('W', l[4].type)\n\n  \" Test for %o\n  set efm=%f(%o):%l\\ %m\n  cgetexpr ['Xotestfile(Language.PureScript.Types):20 Error']\n  call writefile(['Line1'], 'Xotestfile')\n  let l = getqflist()\n  call assert_equal(1, len(l), string(l))\n  call assert_equal('Language.PureScript.Types', l[0].module)\n  copen\n  call assert_equal('Language.PureScript.Types|20| Error', getline(1))\n  call feedkeys(\"\\<CR>\", 'xn')\n  call assert_equal('Xotestfile', expand('%:t'))\n  cclose\n  bd\n  call delete(\"Xotestfile\")\n\n  \" Test for a long module name\n  cexpr 'Xtest(' . repeat('m', 1026) . '):15 message'\n  let l = getqflist()\n  call assert_equal(repeat('m', 1024), l[0].module)\n  call assert_equal(15, l[0].lnum)\n  call assert_equal('message', l[0].text)\n\n  \" The following sequence of commands used to crash Vim\n  set efm=%W%m\n  cgetexpr ['msg1']\n  let l = getqflist()\n  call assert_equal(1, len(l), string(l))\n  call assert_equal('msg1', l[0].text)\n  set efm=%C%m\n  lexpr 'msg2'\n  let l = getloclist(0)\n  call assert_equal(1, len(l), string(l))\n  call assert_equal('msg2', l[0].text)\n  lopen\n  call setqflist([], 'r')\n  caddbuf\n  let l = getqflist()\n  call assert_equal(1, len(l), string(l))\n  call assert_equal('|| msg2', l[0].text)\n\n  \" When matching error lines, case should be ignored. Test for this.\n  set noignorecase\n  let l=getqflist({'lines' : ['Xtest:FOO10:Line 20'], 'efm':'%f:foo%l:%m'})\n  call assert_equal(10, l.items[0].lnum)\n  call assert_equal('Line 20', l.items[0].text)\n  set ignorecase&\n\n  new | only\n  let &efm = save_efm\nendfunc\n\n\" Test for '%t' (error type) field in 'efm'\nfunc Test_efm_error_type()\n  let save_efm = &efm\n\n  \" error type\n  set efm=%f:%l:%t:%m\n  let lines =<< trim END\n    Xfile1:10:E:msg1\n    Xfile1:20:W:msg2\n    Xfile1:30:I:msg3\n    Xfile1:40:N:msg4\n    Xfile1:50:R:msg5\n  END\n  cexpr lines\n  let output = split(execute('clist'), \"\\n\")\n  call assert_equal([\n        \\ ' 1 Xfile1:10 error: msg1',\n        \\ ' 2 Xfile1:20 warning: msg2',\n        \\ ' 3 Xfile1:30 info: msg3',\n        \\ ' 4 Xfile1:40 note: msg4',\n        \\ ' 5 Xfile1:50 R: msg5'], output)\n\n  \" error type and a error number\n  set efm=%f:%l:%t:%n:%m\n  let lines =<< trim END\n    Xfile1:10:E:2:msg1\n    Xfile1:20:W:4:msg2\n    Xfile1:30:I:6:msg3\n    Xfile1:40:N:8:msg4\n    Xfile1:50:R:3:msg5\n  END\n  cexpr lines\n  let output = split(execute('clist'), \"\\n\")\n  call assert_equal([\n        \\ ' 1 Xfile1:10 error   2: msg1',\n        \\ ' 2 Xfile1:20 warning   4: msg2',\n        \\ ' 3 Xfile1:30 info   6: msg3',\n        \\ ' 4 Xfile1:40 note   8: msg4',\n        \\ ' 5 Xfile1:50 R   3: msg5'], output)\n  let &efm = save_efm\nendfunc\n\n\" Test for end_lnum ('%e') and end_col ('%k') fields in 'efm'\nfunc Test_efm_end_lnum_col()\n  let save_efm = &efm\n\n  \" single line\n  set efm=%f:%l-%e:%c-%k:%t:%m\n  cexpr [\"Xfile1:10-20:1-2:E:msg1\", \"Xfile1:20-30:2-3:W:msg2\",]\n  let output = split(execute('clist'), \"\\n\")\n  call assert_equal([\n        \\ ' 1 Xfile1:10-20 col 1-2 error: msg1',\n        \\ ' 2 Xfile1:20-30 col 2-3 warning: msg2'], output)\n\n  \" multiple lines\n  set efm=%A%n)%m,%Z%f:%l-%e:%c-%k\n  let lines =<< trim END\n    1)msg1\n    Xfile1:14-24:1-2\n    2)msg2\n    Xfile1:24-34:3-4\n  END\n  cexpr lines\n  let output = split(execute('clist'), \"\\n\")\n  call assert_equal([\n        \\ ' 1 Xfile1:14-24 col 1-2 error   1: msg1',\n        \\ ' 2 Xfile1:24-34 col 3-4 error   2: msg2'], output)\n  let &efm = save_efm\nendfunc\n\nfunc XquickfixChangedByAutocmd(cchar)\n  call s:setup_commands(a:cchar)\n  if a:cchar == 'c'\n    let ErrorNr = 'E925'\n    func! ReadFunc()\n      colder\n      cgetexpr []\n    endfunc\n  else\n    let ErrorNr = 'E926'\n    func! ReadFunc()\n      lolder\n      lgetexpr []\n    endfunc\n  endif\n\n  augroup QF_Test\n    au!\n    autocmd BufReadCmd test_changed.txt call ReadFunc()\n  augroup END\n\n  new | only\n  let words = [ \"a\", \"b\" ]\n  let qflist = []\n  for word in words\n    call add(qflist, {'filename': 'test_changed.txt'})\n    call g:Xsetlist(qflist, ' ')\n  endfor\n  call assert_fails('Xrewind', ErrorNr . ':')\n\n  augroup QF_Test\n    au!\n  augroup END\n\n  if a:cchar == 'c'\n    cexpr [\"Xtest1:1:Line\"]\n    cwindow\n    only\n    augroup QF_Test\n      au!\n      autocmd WinEnter * call setqflist([], 'f')\n    augroup END\n    call assert_fails('exe \"normal \\<CR>\"', 'E925:')\n    augroup QF_Test\n      au!\n    augroup END\n  endif\n  %bw!\nendfunc\n\nfunc Test_quickfix_was_changed_by_autocmd()\n  call XquickfixChangedByAutocmd('c')\n  call XquickfixChangedByAutocmd('l')\nendfunc\n\nfunc Test_setloclist_in_autocommand()\n  call writefile(['test1', 'test2'], 'Xfile')\n  edit Xfile\n  let s:bufnr = bufnr()\n  call setloclist(1,\n        \\ [{'bufnr' : s:bufnr, 'lnum' : 1, 'text' : 'test1'},\n        \\  {'bufnr' : s:bufnr, 'lnum' : 2, 'text' : 'test2'}])\n\n  augroup Test_LocList\n    au!\n    autocmd BufEnter * call setloclist(1,\n          \\ [{'bufnr' : s:bufnr, 'lnum' : 1, 'text' : 'test1'},\n          \\  {'bufnr' : s:bufnr, 'lnum' : 2, 'text' : 'test2'}], 'r')\n  augroup END\n\n  lopen\n  call assert_fails('exe \"normal j\\<CR>\"', 'E926:')\n\n  augroup Test_LocList\n    au!\n  augroup END\n  call delete('Xfile')\nendfunc\n\nfunc Test_caddbuffer_to_empty()\n  helpgr quickfix\n  call setqflist([], 'r')\n  cad\n  try\n    cn\n  catch\n    \" number of matches is unknown\n    call assert_true(v:exception =~ 'E553:')\n  endtry\n  quit!\nendfunc\n\nfunc Test_cgetexpr_works()\n  \" this must not crash Vim\n  cgetexpr [$x]\n  lgetexpr [$x]\nendfunc\n\n\" Tests for the setqflist() and setloclist() functions\nfunc SetXlistTests(cchar, bnum)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([{'bufnr': a:bnum, 'lnum': 1},\n\t      \\  {'bufnr': a:bnum, 'lnum': 2, 'end_lnum': 3, 'col': 4, 'end_col': 5}])\n  let l = g:Xgetlist()\n  call assert_equal(2, len(l))\n  call assert_equal(2, l[1].lnum)\n  call assert_equal(3, l[1].end_lnum)\n  call assert_equal(4, l[1].col)\n  call assert_equal(5, l[1].end_col)\n\n  Xnext\n  call g:Xsetlist([{'bufnr': a:bnum, 'lnum': 3}], 'a')\n  let l = g:Xgetlist()\n  call assert_equal(3, len(l))\n  Xnext\n  call assert_equal(3, line('.'))\n\n  \" Appending entries to the list should not change the cursor position\n  \" in the quickfix window\n  Xwindow\n  1\n  call g:Xsetlist([{'bufnr': a:bnum, 'lnum': 4},\n\t      \\  {'bufnr': a:bnum, 'lnum': 5}], 'a')\n  call assert_equal(1, line('.'))\n  close\n\n  call g:Xsetlist([{'bufnr': a:bnum, 'lnum': 3},\n\t      \\  {'bufnr': a:bnum, 'lnum': 4},\n\t      \\  {'bufnr': a:bnum, 'lnum': 5}], 'r')\n  let l = g:Xgetlist()\n  call assert_equal(3, len(l))\n  call assert_equal(5, l[2].lnum)\n\n  call g:Xsetlist([])\n  let l = g:Xgetlist()\n  call assert_equal(0, len(l))\n\n  \" Tests for setting the 'valid' flag\n  call g:Xsetlist([{'bufnr':a:bnum, 'lnum':4, 'valid':0}])\n  Xwindow\n  call assert_equal(1, winnr('$'))\n  let l = g:Xgetlist()\n  call g:Xsetlist(l)\n  call assert_equal(0, g:Xgetlist()[0].valid)\n  \" Adding a non-valid entry should not mark the list as having valid entries\n  call g:Xsetlist([{'bufnr':a:bnum, 'lnum':5, 'valid':0}], 'a')\n  Xwindow\n  call assert_equal(1, winnr('$'))\n\n  \" :cnext/:cprev should still work even with invalid entries in the list\n  let l = [{'bufnr' : a:bnum, 'lnum' : 1, 'text' : '1', 'valid' : 0},\n\t      \\ {'bufnr' : a:bnum, 'lnum' : 2, 'text' : '2', 'valid' : 0}]\n  call g:Xsetlist(l)\n  Xnext\n  call assert_equal(2, g:Xgetlist({'idx' : 0}).idx)\n  Xprev\n  call assert_equal(1, g:Xgetlist({'idx' : 0}).idx)\n  \" :cnext/:cprev should still work after appending invalid entries to an\n  \" empty list\n  call g:Xsetlist([])\n  call g:Xsetlist(l, 'a')\n  Xnext\n  call assert_equal(2, g:Xgetlist({'idx' : 0}).idx)\n  Xprev\n  call assert_equal(1, g:Xgetlist({'idx' : 0}).idx)\n\n  call g:Xsetlist([{'text':'Text1', 'valid':1}])\n  Xwindow\n  call assert_equal(2, winnr('$'))\n  Xclose\n  let save_efm = &efm\n  set efm=%m\n  Xgetexpr 'TestMessage'\n  let l = g:Xgetlist()\n  call g:Xsetlist(l)\n  call assert_equal(1, g:Xgetlist()[0].valid)\n  let &efm = save_efm\n\n  \" Error cases:\n  \" Refer to a non-existing buffer and pass a non-dictionary type\n  call assert_fails(\"call g:Xsetlist([{'bufnr':998, 'lnum':4},\" .\n\t      \\ \" {'bufnr':999, 'lnum':5}])\", 'E92:')\n  call g:Xsetlist([[1, 2,3]])\n  call assert_equal(0, len(g:Xgetlist()))\n  call assert_fails('call g:Xsetlist([], [])', 'E928:')\n  call g:Xsetlist([test_null_dict()])\n  call assert_equal([], g:Xgetlist())\nendfunc\n\nfunc Test_setqflist()\n  new Xtestfile | only\n  let bnum = bufnr('%')\n  call setline(1, range(1,5))\n\n  call SetXlistTests('c', bnum)\n  call SetXlistTests('l', bnum)\n\n  enew!\n  call delete('Xtestfile')\nendfunc\n\nfunc Xlist_empty_middle(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" create three quickfix lists\n  let @/ = 'Test_'\n  Xvimgrep // test_quickfix.vim\n  let testlen = len(g:Xgetlist())\n  call assert_true(testlen > 0)\n  Xvimgrep empty test_quickfix.vim\n  call assert_true(len(g:Xgetlist()) > 0)\n  Xvimgrep matches test_quickfix.vim\n  let matchlen = len(g:Xgetlist())\n  call assert_true(matchlen > 0)\n  Xolder\n  \" make the middle list empty\n  call g:Xsetlist([], 'r')\n  call assert_true(len(g:Xgetlist()) == 0)\n  Xolder\n  call assert_equal(testlen, len(g:Xgetlist()))\n  Xnewer\n  Xnewer\n  call assert_equal(matchlen, len(g:Xgetlist()))\nendfunc\n\nfunc Test_setqflist_empty_middle()\n  call Xlist_empty_middle('c')\n  call Xlist_empty_middle('l')\nendfunc\n\nfunc Xlist_empty_older(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" create three quickfix lists\n  Xvimgrep one test_quickfix.vim\n  let onelen = len(g:Xgetlist())\n  call assert_true(onelen > 0)\n  Xvimgrep two test_quickfix.vim\n  let twolen = len(g:Xgetlist())\n  call assert_true(twolen > 0)\n  Xvimgrep three test_quickfix.vim\n  let threelen = len(g:Xgetlist())\n  call assert_true(threelen > 0)\n  Xolder 2\n  \" make the first list empty, check the others didn't change\n  call g:Xsetlist([], 'r')\n  call assert_true(len(g:Xgetlist()) == 0)\n  Xnewer\n  call assert_equal(twolen, len(g:Xgetlist()))\n  Xnewer\n  call assert_equal(threelen, len(g:Xgetlist()))\nendfunc\n\nfunc Test_setqflist_empty_older()\n  call Xlist_empty_older('c')\n  call Xlist_empty_older('l')\nendfunc\n\nfunc XquickfixSetListWithAct(cchar)\n  call s:setup_commands(a:cchar)\n\n  let list1 = [{'filename': 'fnameA', 'text': 'A'},\n          \\    {'filename': 'fnameB', 'text': 'B'}]\n  let list2 = [{'filename': 'fnameC', 'text': 'C'},\n          \\    {'filename': 'fnameD', 'text': 'D'},\n          \\    {'filename': 'fnameE', 'text': 'E'}]\n\n  \" {action} is unspecified.  Same as specifying ' '.\n  new | only\n  silent! Xnewer 99\n  call g:Xsetlist(list1)\n  call g:Xsetlist(list2)\n  let li = g:Xgetlist()\n  call assert_equal(3, len(li))\n  call assert_equal('C', li[0]['text'])\n  call assert_equal('D', li[1]['text'])\n  call assert_equal('E', li[2]['text'])\n  silent! Xolder\n  let li = g:Xgetlist()\n  call assert_equal(2, len(li))\n  call assert_equal('A', li[0]['text'])\n  call assert_equal('B', li[1]['text'])\n\n  \" {action} is specified ' '.\n  new | only\n  silent! Xnewer 99\n  call g:Xsetlist(list1)\n  call g:Xsetlist(list2, ' ')\n  let li = g:Xgetlist()\n  call assert_equal(3, len(li))\n  call assert_equal('C', li[0]['text'])\n  call assert_equal('D', li[1]['text'])\n  call assert_equal('E', li[2]['text'])\n  silent! Xolder\n  let li = g:Xgetlist()\n  call assert_equal(2, len(li))\n  call assert_equal('A', li[0]['text'])\n  call assert_equal('B', li[1]['text'])\n\n  \" {action} is specified 'a'.\n  new | only\n  silent! Xnewer 99\n  call g:Xsetlist(list1)\n  call g:Xsetlist(list2, 'a')\n  let li = g:Xgetlist()\n  call assert_equal(5, len(li))\n  call assert_equal('A', li[0]['text'])\n  call assert_equal('B', li[1]['text'])\n  call assert_equal('C', li[2]['text'])\n  call assert_equal('D', li[3]['text'])\n  call assert_equal('E', li[4]['text'])\n\n  \" {action} is specified 'r'.\n  new | only\n  silent! Xnewer 99\n  call g:Xsetlist(list1)\n  call g:Xsetlist(list2, 'r')\n  let li = g:Xgetlist()\n  call assert_equal(3, len(li))\n  call assert_equal('C', li[0]['text'])\n  call assert_equal('D', li[1]['text'])\n  call assert_equal('E', li[2]['text'])\n\n  \" Test for wrong value.\n  new | only\n  call assert_fails(\"call g:Xsetlist(0)\", 'E714:')\n  call assert_fails(\"call g:Xsetlist(list1, '')\", 'E927:')\n  call assert_fails(\"call g:Xsetlist(list1, 'aa')\", 'E927:')\n  call assert_fails(\"call g:Xsetlist(list1, ' a')\", 'E927:')\n  call assert_fails(\"call g:Xsetlist(list1, 0)\", 'E928:')\nendfunc\n\nfunc Test_setqflist_invalid_nr()\n  \" The following command used to crash Vim\n  eval []->setqflist(' ', {'nr' : $XXX_DOES_NOT_EXIST})\nendfunc\n\nfunc Test_setqflist_user_sets_buftype()\n  call setqflist([{'text': 'foo'}, {'text': 'bar'}])\n  set buftype=quickfix\n  call setqflist([], 'a')\n  enew\nendfunc\n\nfunc Test_quickfix_set_list_with_act()\n  call XquickfixSetListWithAct('c')\n  call XquickfixSetListWithAct('l')\nendfunc\n\nfunc XLongLinesTests(cchar)\n  let l = g:Xgetlist()\n\n  call assert_equal(4, len(l))\n  call assert_equal(1, l[0].lnum)\n  call assert_equal(1, l[0].col)\n  call assert_equal(1975, len(l[0].text))\n  call assert_equal(2, l[1].lnum)\n  call assert_equal(1, l[1].col)\n  call assert_equal(4070, len(l[1].text))\n  call assert_equal(3, l[2].lnum)\n  call assert_equal(1, l[2].col)\n  call assert_equal(4070, len(l[2].text))\n  call assert_equal(4, l[3].lnum)\n  call assert_equal(1, l[3].col)\n  call assert_equal(10, len(l[3].text))\n\n  call g:Xsetlist([], 'r')\nendfunc\n\nfunc s:long_lines_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  let testfile = 'samples/quickfix.txt'\n\n  \" file\n  exe 'Xgetfile' testfile\n  call XLongLinesTests(a:cchar)\n\n  \" list\n  Xexpr readfile(testfile)\n  call XLongLinesTests(a:cchar)\n\n  \" string\n  Xexpr join(readfile(testfile), \"\\n\")\n  call XLongLinesTests(a:cchar)\n\n  \" buffer\n  exe 'edit' testfile\n  exe 'Xbuffer' bufnr('%')\n  call XLongLinesTests(a:cchar)\nendfunc\n\nfunc Test_long_lines()\n  call s:long_lines_tests('c')\n  call s:long_lines_tests('l')\nendfunc\n\nfunc Test_cgetfile_on_long_lines()\n  \" Problematic values if the line is longer than 4096 bytes.  Then 1024 bytes\n  \" are read at a time.\n  for len in [4078, 4079, 4080, 5102, 5103, 5104, 6126, 6127, 6128, 7150, 7151, 7152]\n    let lines =<< trim END\n      /tmp/file1:1:1:aaa\n      /tmp/file2:1:1:%s\n      /tmp/file3:1:1:bbb\n      /tmp/file4:1:1:ccc\n    END\n    let lines[1] = substitute(lines[1], '%s', repeat('x', len), '')\n    call writefile(lines, 'Xcqetfile.txt')\n    cgetfile Xcqetfile.txt\n    call assert_equal(4, getqflist(#{size: v:true}).size, 'with length ' .. len)\n  endfor\n  call delete('Xcqetfile.txt')\nendfunc\n\nfunc s:create_test_file(filename)\n  let l = []\n  for i in range(1, 20)\n      call add(l, 'Line' . i)\n  endfor\n  call writefile(l, a:filename)\nendfunc\n\nfunc Test_switchbuf()\n  call s:create_test_file('Xqftestfile1')\n  call s:create_test_file('Xqftestfile2')\n  call s:create_test_file('Xqftestfile3')\n\n  new | only\n  edit Xqftestfile1\n  let file1_winid = win_getid()\n  new Xqftestfile2\n  let file2_winid = win_getid()\n  let lines =<< trim END\n    Xqftestfile1:5:Line5\n    Xqftestfile1:6:Line6\n    Xqftestfile2:10:Line10\n    Xqftestfile2:11:Line11\n    Xqftestfile3:15:Line15\n    Xqftestfile3:16:Line16\n  END\n  cgetexpr lines\n\n  new\n  let winid = win_getid()\n  cfirst | cnext\n  call assert_equal(winid, win_getid())\n  2cnext\n  call assert_equal(winid, win_getid())\n  2cnext\n  call assert_equal(winid, win_getid())\n\n  \" Test for 'switchbuf' set to search for files in windows in the current\n  \" tabpage and jump to an existing window (if present)\n  set switchbuf=useopen\n  enew\n  cfirst | cnext\n  call assert_equal(file1_winid, win_getid())\n  2cnext\n  call assert_equal(file2_winid, win_getid())\n  2cnext\n  call assert_equal(file2_winid, win_getid())\n\n  \" Test for 'switchbuf' set to search for files in tabpages and jump to an\n  \" existing tabpage (if present)\n  enew | only\n  set switchbuf=usetab\n  tabedit Xqftestfile1\n  tabedit Xqftestfile2\n  tabedit Xqftestfile3\n  tabfirst\n  cfirst | cnext\n  call assert_equal(2, tabpagenr())\n  2cnext\n  call assert_equal(3, tabpagenr())\n  6cnext\n  call assert_equal(4, tabpagenr())\n  2cpfile\n  call assert_equal(2, tabpagenr())\n  2cnfile\n  call assert_equal(4, tabpagenr())\n  tabfirst | tabonly | enew\n\n  \" Test for 'switchbuf' set to open a new window for every file\n  set switchbuf=split\n  cfirst | cnext\n  call assert_equal(1, winnr('$'))\n  cnext | cnext\n  call assert_equal(2, winnr('$'))\n  cnext | cnext\n  call assert_equal(3, winnr('$'))\n\n  \" Test for 'switchbuf' set to open a new tabpage for every file\n  set switchbuf=newtab\n  enew | only\n  cfirst | cnext\n  call assert_equal(1, tabpagenr('$'))\n  cnext | cnext\n  call assert_equal(2, tabpagenr('$'))\n  cnext | cnext\n  call assert_equal(3, tabpagenr('$'))\n  tabfirst | enew | tabonly | only\n\n  set switchbuf=uselast\n  split\n  let last_winid = win_getid()\n  copen\n  exe \"normal 1G\\<CR>\"\n  call assert_equal(last_winid, win_getid())\n  enew | only\n\n  \" With an empty 'switchbuf', jumping to a quickfix entry should open the\n  \" file in an existing window (if present)\n  set switchbuf=\n  edit Xqftestfile1\n  let file1_winid = win_getid()\n  new Xqftestfile2\n  let file2_winid = win_getid()\n  copen\n  exe \"normal 1G\\<CR>\"\n  call assert_equal(file1_winid, win_getid())\n  copen\n  exe \"normal 3G\\<CR>\"\n  call assert_equal(file2_winid, win_getid())\n  copen | only\n  exe \"normal 5G\\<CR>\"\n  call assert_equal(2, winnr('$'))\n  call assert_equal(1, bufwinnr('Xqftestfile3'))\n\n  \" If only quickfix window is open in the current tabpage, jumping to an\n  \" entry with 'switchbuf' set to 'usetab' should search in other tabpages.\n  enew | only\n  set switchbuf=usetab\n  tabedit Xqftestfile1\n  tabedit Xqftestfile2\n  tabedit Xqftestfile3\n  tabfirst\n  copen | only\n  clast\n  call assert_equal(4, tabpagenr())\n  tabfirst | tabonly | enew | only\n\n  \" Jumping to a file that is not present in any of the tabpages and the\n  \" current tabpage doesn't have any usable windows, should open it in a new\n  \" window in the current tabpage.\n  copen | only\n  cfirst\n  call assert_equal(1, tabpagenr())\n  call assert_equal('Xqftestfile1', @%)\n\n  \" If opening a file changes 'switchbuf', then the new value should be\n  \" retained.\n  set modeline&vim\n  call writefile([\"vim: switchbuf=split\"], 'Xqftestfile1')\n  enew | only\n  set switchbuf&vim\n  cexpr \"Xqftestfile1:1:10\"\n  call assert_equal('split', &switchbuf)\n  call writefile([\"vim: switchbuf=usetab\"], 'Xqftestfile1')\n  enew | only\n  set switchbuf=useopen\n  cexpr \"Xqftestfile1:1:10\"\n  call assert_equal('usetab', &switchbuf)\n  call writefile([\"vim: switchbuf&vim\"], 'Xqftestfile1')\n  enew | only\n  set switchbuf=useopen\n  cexpr \"Xqftestfile1:1:10\"\n  call assert_equal('', &switchbuf)\n\n  call delete('Xqftestfile1')\n  call delete('Xqftestfile2')\n  call delete('Xqftestfile3')\n  set switchbuf&vim\n\n  enew | only\nendfunc\n\nfunc Xadjust_qflnum(cchar)\n  call s:setup_commands(a:cchar)\n\n  enew | only\n\n  let fname = 'Xqftestfile' . a:cchar\n  call s:create_test_file(fname)\n  exe 'edit ' . fname\n\n  Xgetexpr [fname . ':5:Line5',\n\t      \\ fname . ':10:Line10',\n\t      \\ fname . ':15:Line15',\n\t      \\ fname . ':20:Line20']\n\n  6,14delete\n  call append(6, ['Buffer', 'Window'])\n\n  let l = g:Xgetlist()\n  call assert_equal(5, l[0].lnum)\n  call assert_equal(6, l[2].lnum)\n  call assert_equal(13, l[3].lnum)\n\n  \" If a file doesn't have any quickfix entries, then deleting lines in the\n  \" file should not update the quickfix list\n  call g:Xsetlist([], 'f')\n  1,2delete\n  call assert_equal([], g:Xgetlist())\n\n  enew!\n  call delete(fname)\nendfunc\n\nfunc Test_adjust_lnum()\n  call setloclist(0, [])\n  call Xadjust_qflnum('c')\n  call setqflist([])\n  call Xadjust_qflnum('l')\nendfunc\n\n\" Tests for the :grep/:lgrep and :grepadd/:lgrepadd commands\nfunc s:test_xgrep(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" The following lines are used for the grep test. Don't remove.\n  \" Grep_Test_Text: Match 1\n  \" Grep_Test_Text: Match 2\n  \" GrepAdd_Test_Text: Match 1\n  \" GrepAdd_Test_Text: Match 2\n  enew! | only\n  set makeef&vim\n  silent Xgrep Grep_Test_Text: test_quickfix.vim\n  call assert_true(len(g:Xgetlist()) == 5)\n  Xopen\n  call assert_true(w:quickfix_title =~ '^:grep')\n  Xclose\n  enew\n  set makeef=Temp_File_##\n  silent Xgrepadd GrepAdd_Test_Text: test_quickfix.vim\n  call assert_true(len(g:Xgetlist()) == 9)\n\n  \" Try with 'grepprg' set to 'internal'\n  set grepprg=internal\n  silent Xgrep Grep_Test_Text: test_quickfix.vim\n  silent Xgrepadd GrepAdd_Test_Text: test_quickfix.vim\n  call assert_true(len(g:Xgetlist()) == 9)\n  set grepprg&vim\n\n  call writefile(['Vim'], 'XtestTempFile')\n  set makeef=XtestTempFile\n  silent Xgrep Grep_Test_Text: test_quickfix.vim\n  call assert_equal(5, len(g:Xgetlist()))\n  call assert_false(filereadable('XtestTempFile'))\n  set makeef&vim\nendfunc\n\nfunc Test_grep()\n  \" The grepprg may not be set on non-Unix systems\n  CheckUnix\n\n  call s:test_xgrep('c')\n  call s:test_xgrep('l')\nendfunc\n\nfunc Test_two_windows()\n  \" Use one 'errorformat' for two windows.  Add an expression to each of them,\n  \" make sure they each keep their own state.\n  set efm=%DEntering\\ dir\\ '%f',%f:%l:%m,%XLeaving\\ dir\\ '%f'\n  call mkdir('Xone/a', 'p')\n  call mkdir('Xtwo/a', 'p')\n  let lines = ['1', '2', 'one one one', '4', 'two two two', '6', '7']\n  call writefile(lines, 'Xone/a/one.txt')\n  call writefile(lines, 'Xtwo/a/two.txt')\n\n  new one\n  let one_id = win_getid()\n  lexpr \"\"\n  new two\n  let two_id = win_getid()\n  lexpr \"\"\n\n  laddexpr \"Entering dir 'Xtwo/a'\"\n  call win_gotoid(one_id)\n  laddexpr \"Entering dir 'Xone/a'\"\n  call win_gotoid(two_id)\n  laddexpr 'two.txt:5:two two two'\n  call win_gotoid(one_id)\n  laddexpr 'one.txt:3:one one one'\n\n  let loc_one = getloclist(one_id)\n  call assert_equal('Xone/a/one.txt', bufname(loc_one[1].bufnr))\n  call assert_equal(3, loc_one[1].lnum)\n\n  let loc_two = getloclist(two_id)\n  call assert_equal('Xtwo/a/two.txt', bufname(loc_two[1].bufnr))\n  call assert_equal(5, loc_two[1].lnum)\n\n  call win_gotoid(one_id)\n  bwipe!\n  call win_gotoid(two_id)\n  bwipe!\n  call delete('Xone', 'rf')\n  call delete('Xtwo', 'rf')\nendfunc\n\nfunc XbottomTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Calling lbottom without any errors should fail\n  if a:cchar == 'l'\n      call assert_fails('lbottom', 'E776:')\n  endif\n\n  call g:Xsetlist([{'filename': 'foo', 'lnum': 42}])\n  Xopen\n  let wid = win_getid()\n  call assert_equal(1, line('.'))\n  wincmd w\n  call g:Xsetlist([{'filename': 'var', 'lnum': 24}], 'a')\n  Xbottom\n  call win_gotoid(wid)\n  call assert_equal(2, line('.'))\n  Xclose\nendfunc\n\n\" Tests for the :cbottom and :lbottom commands\nfunc Test_cbottom()\n  call XbottomTests('c')\n  call XbottomTests('l')\nendfunc\n\nfunc HistoryTest(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" clear all lists after the first one, then replace the first one.\n  call g:Xsetlist([])\n  call assert_fails('Xolder 99', 'E380:')\n  let entry = {'filename': 'foo', 'lnum': 42}\n  call g:Xsetlist([entry], 'r')\n  call g:Xsetlist([entry, entry])\n  call g:Xsetlist([entry, entry, entry])\n  let res = split(execute(a:cchar . 'hist'), \"\\n\")\n  call assert_equal(3, len(res))\n  let common = 'errors     :set' . (a:cchar == 'c' ? 'qf' : 'loc') . 'list()'\n  call assert_equal('  error list 1 of 3; 1 ' . common, res[0])\n  call assert_equal('  error list 2 of 3; 2 ' . common, res[1])\n  call assert_equal('> error list 3 of 3; 3 ' . common, res[2])\n\n  \" Test for changing the quickfix lists\n  call assert_equal(3, g:Xgetlist({'nr' : 0}).nr)\n  exe '1' . a:cchar . 'hist'\n  call assert_equal(1, g:Xgetlist({'nr' : 0}).nr)\n  exe '3' . a:cchar . 'hist'\n  call assert_equal(3, g:Xgetlist({'nr' : 0}).nr)\n  call assert_fails('-2' . a:cchar . 'hist', 'E16:')\n  call assert_fails('4' . a:cchar . 'hist', 'E16:')\n\n  call g:Xsetlist([], 'f')\n  let l = split(execute(a:cchar . 'hist'), \"\\n\")\n  call assert_equal('No entries', l[0])\n  if a:cchar == 'c'\n    call assert_fails('4chist', 'E16:')\n  else\n    call assert_fails('4lhist', 'E776:')\n  endif\n\n  \" An empty list should still show the stack history\n  call g:Xsetlist([])\n  let res = split(execute(a:cchar . 'hist'), \"\\n\")\n  call assert_equal('> error list 1 of 1; 0 ' . common, res[0])\n\n  call g:Xsetlist([], 'f')\nendfunc\n\nfunc Test_history()\n  call HistoryTest('c')\n  call HistoryTest('l')\nendfunc\n\nfunc Test_duplicate_buf()\n  \" make sure we can get the highest buffer number\n  edit DoesNotExist\n  edit DoesNotExist2\n  let last_buffer = bufnr(\"$\")\n\n  \" make sure only one buffer is created\n  call writefile(['this one', 'that one'], 'Xgrepthis')\n  vimgrep one Xgrepthis\n  vimgrep one Xgrepthis\n  call assert_equal(last_buffer + 1, bufnr(\"$\"))\n\n  call delete('Xgrepthis')\nendfunc\n\n\" Quickfix/Location list set/get properties tests\nfunc Xproperty_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Error cases\n  call assert_fails('call g:Xgetlist(99)', 'E715:')\n  call assert_fails('call g:Xsetlist(99)', 'E714:')\n  call assert_fails('call g:Xsetlist([], \"a\", [])', 'E715:')\n\n  \" Set and get the title\n  call g:Xsetlist([])\n  Xopen\n  wincmd p\n  call g:Xsetlist([{'filename':'foo', 'lnum':27}])\n  let s = g:Xsetlist([], 'a', {'title' : 'Sample'})\n  call assert_equal(0, s)\n  let d = g:Xgetlist({\"title\":1})\n  call assert_equal('Sample', d.title)\n  \" Try setting title to a non-string value\n  call assert_equal(-1, g:Xsetlist([], 'a', {'title' : ['Test']}))\n  call assert_equal('Sample', g:Xgetlist({\"title\":1}).title)\n\n  Xopen\n  call assert_equal('Sample', w:quickfix_title)\n  Xclose\n\n  \" Tests for action argument\n  silent! Xolder 999\n  let qfnr = g:Xgetlist({'all':1}).nr\n  call g:Xsetlist([], 'r', {'title' : 'N1'})\n  call assert_equal('N1', g:Xgetlist({'all':1}).title)\n  call g:Xsetlist([], ' ', {'title' : 'N2'})\n  call assert_equal(qfnr + 1, g:Xgetlist({'all':1}).nr)\n\n  let res = g:Xgetlist({'nr': 0})\n  call assert_equal(qfnr + 1, res.nr)\n  call assert_equal(['nr'], keys(res))\n\n  call g:Xsetlist([], ' ', {'title' : 'N3'})\n  call assert_equal('N2', g:Xgetlist({'nr':2, 'title':1}).title)\n\n  \" Changing the title of an earlier quickfix list\n  call g:Xsetlist([], 'r', {'title' : 'NewTitle', 'nr' : 2})\n  call assert_equal('NewTitle', g:Xgetlist({'nr':2, 'title':1}).title)\n\n  \" Changing the title of an invalid quickfix list\n  call assert_equal(-1, g:Xsetlist([], ' ',\n        \\ {'title' : 'SomeTitle', 'nr' : 99}))\n  call assert_equal(-1, g:Xsetlist([], ' ',\n        \\ {'title' : 'SomeTitle', 'nr' : 'abc'}))\n\n  if a:cchar == 'c'\n    copen\n    call assert_equal({'winid':win_getid()}, getqflist({'winid':1}))\n    cclose\n  endif\n\n  \" Invalid arguments\n  call assert_fails('call g:Xgetlist([])', 'E715:')\n  call assert_fails('call g:Xsetlist([], \"a\", [])', 'E715:')\n  let s = g:Xsetlist([], 'a', {'abc':1})\n  call assert_equal(-1, s)\n\n  call assert_equal({}, g:Xgetlist({'abc':1}))\n  call assert_equal('', g:Xgetlist({'nr':99, 'title':1}).title)\n  call assert_equal('', g:Xgetlist({'nr':[], 'title':1}).title)\n\n  if a:cchar == 'l'\n    call assert_equal({}, getloclist(99, {'title': 1}))\n  endif\n\n  \" Context related tests\n  let s = g:Xsetlist([], 'a', {'context':[1,2,3]})\n  call assert_equal(0, s)\n  call test_garbagecollect_now()\n  let d = g:Xgetlist({'context':1})\n  call assert_equal([1,2,3], d.context)\n  call g:Xsetlist([], 'a', {'context':{'color':'green'}})\n  let d = g:Xgetlist({'context':1})\n  call assert_equal({'color':'green'}, d.context)\n  call g:Xsetlist([], 'a', {'context':\"Context info\"})\n  let d = g:Xgetlist({'context':1})\n  call assert_equal(\"Context info\", d.context)\n  call g:Xsetlist([], 'a', {'context':246})\n  let d = g:Xgetlist({'context':1})\n  call assert_equal(246, d.context)\n  \" set other Vim data types as context\n  call g:Xsetlist([], 'a', {'context' : test_null_blob()})\n  if has('channel')\n    call g:Xsetlist([], 'a', {'context' : test_null_channel()})\n  endif\n  if has('job')\n    call g:Xsetlist([], 'a', {'context' : test_null_job()})\n  endif\n  call g:Xsetlist([], 'a', {'context' : test_null_function()})\n  call g:Xsetlist([], 'a', {'context' : test_null_partial()})\n  call g:Xsetlist([], 'a', {'context' : ''})\n  call test_garbagecollect_now()\n  if a:cchar == 'l'\n    \" Test for copying context across two different location lists\n    new | only\n    let w1_id = win_getid()\n    let l = [1]\n    call setloclist(0, [], 'a', {'context':l})\n    new\n    let w2_id = win_getid()\n    call add(l, 2)\n    call assert_equal([1, 2], getloclist(w1_id, {'context':1}).context)\n    call assert_equal([1, 2], getloclist(w2_id, {'context':1}).context)\n    unlet! l\n    call assert_equal([1, 2], getloclist(w2_id, {'context':1}).context)\n    only\n    call setloclist(0, [], 'f')\n    call assert_equal('', getloclist(0, {'context':1}).context)\n  endif\n\n  \" Test for changing the context of previous quickfix lists\n  call g:Xsetlist([], 'f')\n  Xexpr \"One\"\n  Xexpr \"Two\"\n  Xexpr \"Three\"\n  call g:Xsetlist([], 'r', {'context' : [1], 'nr' : 1})\n  call g:Xsetlist([], 'a', {'context' : [2], 'nr' : 2})\n  \" Also, check for setting the context using quickfix list number zero.\n  call g:Xsetlist([], 'r', {'context' : [3], 'nr' : 0})\n  call test_garbagecollect_now()\n  let l = g:Xgetlist({'nr' : 1, 'context' : 1})\n  call assert_equal([1], l.context)\n  let l = g:Xgetlist({'nr' : 2, 'context' : 1})\n  call assert_equal([2], l.context)\n  let l = g:Xgetlist({'nr' : 3, 'context' : 1})\n  call assert_equal([3], l.context)\n\n  \" Test for changing the context through reference and for garbage\n  \" collection of quickfix context\n  let l = [\"red\"]\n  call g:Xsetlist([], ' ', {'context' : l})\n  call add(l, \"blue\")\n  let x = g:Xgetlist({'context' : 1})\n  call add(x.context, \"green\")\n  call assert_equal([\"red\", \"blue\", \"green\"], l)\n  call assert_equal([\"red\", \"blue\", \"green\"], x.context)\n  unlet l\n  call test_garbagecollect_now()\n  let m = g:Xgetlist({'context' : 1})\n  call assert_equal([\"red\", \"blue\", \"green\"], m.context)\n\n  \" Test for setting/getting items\n  Xexpr \"\"\n  let qfprev = g:Xgetlist({'nr':0})\n  let s = g:Xsetlist([], ' ', {'title':'Green',\n        \\ 'items' : [{'filename':'F1', 'lnum':10}]})\n  call assert_equal(0, s)\n  let qfcur = g:Xgetlist({'nr':0})\n  call assert_true(qfcur.nr == qfprev.nr + 1)\n  let l = g:Xgetlist({'items':1})\n  call assert_equal('F1', bufname(l.items[0].bufnr))\n  call assert_equal(10, l.items[0].lnum)\n  call g:Xsetlist([], 'a', {'items' : [{'filename':'F2', 'lnum':20},\n        \\  {'filename':'F2', 'lnum':30}]})\n  let l = g:Xgetlist({'items':1})\n  call assert_equal('F2', bufname(l.items[2].bufnr))\n  call assert_equal(30, l.items[2].lnum)\n  call g:Xsetlist([], 'r', {'items' : [{'filename':'F3', 'lnum':40}]})\n  let l = g:Xgetlist({'items':1})\n  call assert_equal('F3', bufname(l.items[0].bufnr))\n  call assert_equal(40, l.items[0].lnum)\n  call g:Xsetlist([], 'r', {'items' : []})\n  let l = g:Xgetlist({'items':1})\n  call assert_equal(0, len(l.items))\n\n  call g:Xsetlist([], 'r', {'title' : 'TestTitle'})\n  call g:Xsetlist([], 'r', {'items' : [{'filename' : 'F1', 'lnum' : 10, 'text' : 'L10'}]})\n  call g:Xsetlist([], 'r', {'items' : [{'filename' : 'F1', 'lnum' : 10, 'text' : 'L10'}]})\n  call assert_equal('TestTitle', g:Xgetlist({'title' : 1}).title)\n\n  \" Test for getting id of window associated with a location list window\n  if a:cchar == 'l'\n    only\n    call assert_equal(0, g:Xgetlist({'all' : 1}).filewinid)\n    let wid = win_getid()\n    Xopen\n    call assert_equal(wid, g:Xgetlist({'filewinid' : 1}).filewinid)\n    wincmd w\n    call assert_equal(0, g:Xgetlist({'filewinid' : 1}).filewinid)\n    only\n  endif\n\n  \" The following used to crash Vim with address sanitizer\n  call g:Xsetlist([], 'f')\n  call g:Xsetlist([], 'a', {'items' : [{'filename':'F1', 'lnum':10}]})\n  call assert_equal(10, g:Xgetlist({'items':1}).items[0].lnum)\n\n  \" Try setting the items using a string\n  call assert_equal(-1, g:Xsetlist([], ' ', {'items' : 'Test'}))\n\n  \" Save and restore the quickfix stack\n  call g:Xsetlist([], 'f')\n  call assert_equal(0, g:Xgetlist({'nr':'$'}).nr)\n  Xexpr \"File1:10:Line1\"\n  Xexpr \"File2:20:Line2\"\n  Xexpr \"File3:30:Line3\"\n  let last_qf = g:Xgetlist({'nr':'$'}).nr\n  call assert_equal(3, last_qf)\n  let qstack = []\n  for i in range(1, last_qf)\n    let qstack = add(qstack, g:Xgetlist({'nr':i, 'all':1}))\n  endfor\n  call g:Xsetlist([], 'f')\n  for i in range(len(qstack))\n    call g:Xsetlist([], ' ', qstack[i])\n  endfor\n  call assert_equal(3, g:Xgetlist({'nr':'$'}).nr)\n  call assert_equal(10, g:Xgetlist({'nr':1, 'items':1}).items[0].lnum)\n  call assert_equal(20, g:Xgetlist({'nr':2, 'items':1}).items[0].lnum)\n  call assert_equal(30, g:Xgetlist({'nr':3, 'items':1}).items[0].lnum)\n  call g:Xsetlist([], 'f')\n\n  \" Swap two quickfix lists\n  Xexpr \"File1:10:Line10\"\n  Xexpr \"File2:20:Line20\"\n  Xexpr \"File3:30:Line30\"\n  call g:Xsetlist([], 'r', {'nr':1,'title':'Colors','context':['Colors']})\n  call g:Xsetlist([], 'r', {'nr':2,'title':'Fruits','context':['Fruits']})\n  let l1=g:Xgetlist({'nr':1,'all':1})\n  let l2=g:Xgetlist({'nr':2,'all':1})\n  let save_id = l1.id\n  let l1.id=l2.id\n  let l2.id=save_id\n  call g:Xsetlist([], 'r', l1)\n  call g:Xsetlist([], 'r', l2)\n  let newl1=g:Xgetlist({'nr':1,'all':1})\n  let newl2=g:Xgetlist({'nr':2,'all':1})\n  call assert_equal('Fruits', newl1.title)\n  call assert_equal(['Fruits'], newl1.context)\n  call assert_equal('Line20', newl1.items[0].text)\n  call assert_equal('Colors', newl2.title)\n  call assert_equal(['Colors'], newl2.context)\n  call assert_equal('Line10', newl2.items[0].text)\n  call g:Xsetlist([], 'f')\n\n  \" Cannot specify both a non-empty list argument and a dict argument\n  call assert_fails(\"call g:Xsetlist([{}], ' ', {})\", 'E475:')\nendfunc\n\nfunc Test_qf_property()\n  call Xproperty_tests('c')\n  call Xproperty_tests('l')\nendfunc\n\n\" Test for setting the current index in the location/quickfix list\nfunc Xtest_setqfidx(cchar)\n  call s:setup_commands(a:cchar)\n\n  Xgetexpr \"F1:10:1:Line1\\nF2:20:2:Line2\\nF3:30:3:Line3\"\n  Xgetexpr \"F4:10:1:Line1\\nF5:20:2:Line2\\nF6:30:3:Line3\"\n  Xgetexpr \"F7:10:1:Line1\\nF8:20:2:Line2\\nF9:30:3:Line3\"\n\n  call g:Xsetlist([], 'a', {'nr' : 3, 'idx' : 2})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'idx' : 2})\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : 3})\n  Xolder 2\n  Xopen\n  call assert_equal(3, line('.'))\n  Xnewer\n  call assert_equal(2, line('.'))\n  Xnewer\n  call assert_equal(2, line('.'))\n  \" Update the current index with the quickfix window open\n  wincmd w\n  call g:Xsetlist([], 'a', {'nr' : 3, 'idx' : 3})\n  Xopen\n  call assert_equal(3, line('.'))\n  Xclose\n\n  \" Set the current index to the last entry\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : '$'})\n  call assert_equal(3, g:Xgetlist({'nr' : 1, 'idx' : 0}).idx)\n  \" A large value should set the index to the last index\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : 1})\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : 999})\n  call assert_equal(3, g:Xgetlist({'nr' : 1, 'idx' : 0}).idx)\n  \" Invalid index values\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : -1})\n  call assert_equal(3, g:Xgetlist({'nr' : 1, 'idx' : 0}).idx)\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : 0})\n  call assert_equal(3, g:Xgetlist({'nr' : 1, 'idx' : 0}).idx)\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : 'xx'})\n  call assert_equal(3, g:Xgetlist({'nr' : 1, 'idx' : 0}).idx)\n  call assert_fails(\"call g:Xsetlist([], 'a', {'nr':1, 'idx':[]})\", 'E745:')\n\n  call g:Xsetlist([], 'f')\n  new | only\nendfunc\n\nfunc Test_setqfidx()\n  call Xtest_setqfidx('c')\n  call Xtest_setqfidx('l')\nendfunc\n\n\" Tests for the QuickFixCmdPre/QuickFixCmdPost autocommands\nfunc QfAutoCmdHandler(loc, cmd)\n  call add(g:acmds, a:loc . a:cmd)\nendfunc\n\nfunc Test_Autocmd()\n  autocmd QuickFixCmdPre * call QfAutoCmdHandler('pre', expand('<amatch>'))\n  autocmd QuickFixCmdPost * call QfAutoCmdHandler('post', expand('<amatch>'))\n\n  let g:acmds = []\n  cexpr \"F1:10:Line 10\"\n  caddexpr \"F1:20:Line 20\"\n  cgetexpr \"F1:30:Line 30\"\n  cexpr \"\"\n  caddexpr \"\"\n  cgetexpr \"\"\n  silent! cexpr non_existing_func()\n  silent! caddexpr non_existing_func()\n  silent! cgetexpr non_existing_func()\n  let l =<< trim END\n    precexpr\n    postcexpr\n    precaddexpr\n    postcaddexpr\n    precgetexpr\n    postcgetexpr\n    precexpr\n    postcexpr\n    precaddexpr\n    postcaddexpr\n    precgetexpr\n    postcgetexpr\n    precexpr\n    precaddexpr\n    precgetexpr\n  END\n  call assert_equal(l, g:acmds)\n\n  let g:acmds = []\n  enew! | call append(0, \"F2:10:Line 10\")\n  cbuffer!\n  enew! | call append(0, \"F2:20:Line 20\")\n  cgetbuffer\n  enew! | call append(0, \"F2:30:Line 30\")\n  caddbuffer\n  new\n  let bnum = bufnr('%')\n  bunload\n  exe 'silent! cbuffer! ' . bnum\n  exe 'silent! cgetbuffer ' . bnum\n  exe 'silent! caddbuffer ' . bnum\n  enew!\n  let l =<< trim END\n    precbuffer\n    postcbuffer\n    precgetbuffer\n    postcgetbuffer\n    precaddbuffer\n    postcaddbuffer\n    precbuffer\n    precgetbuffer\n    precaddbuffer\n  END\n  call assert_equal(l, g:acmds)\n\n  call writefile(['Xtest:1:Line1'], 'Xtest')\n  call writefile([], 'Xempty')\n  let g:acmds = []\n  cfile Xtest\n  caddfile Xtest\n  cgetfile Xtest\n  cfile Xempty\n  caddfile Xempty\n  cgetfile Xempty\n  silent! cfile do_not_exist\n  silent! caddfile do_not_exist\n  silent! cgetfile do_not_exist\n  let l =<< trim END\n    precfile\n    postcfile\n    precaddfile\n    postcaddfile\n    precgetfile\n    postcgetfile\n    precfile\n    postcfile\n    precaddfile\n    postcaddfile\n    precgetfile\n    postcgetfile\n    precfile\n    postcfile\n    precaddfile\n    postcaddfile\n    precgetfile\n    postcgetfile\n  END\n  call assert_equal(l, g:acmds)\n\n  let g:acmds = []\n  helpgrep quickfix\n  silent! helpgrep non_existing_help_topic\n  vimgrep test Xtest\n  vimgrepadd test Xtest\n  silent! vimgrep non_existing_test Xtest\n  silent! vimgrepadd non_existing_test Xtest\n  set makeprg=\n  silent! make\n  set makeprg&\n  let l =<< trim END\n    prehelpgrep\n    posthelpgrep\n    prehelpgrep\n    posthelpgrep\n    previmgrep\n    postvimgrep\n    previmgrepadd\n    postvimgrepadd\n    previmgrep\n    postvimgrep\n    previmgrepadd\n    postvimgrepadd\n    premake\n    postmake\n  END\n  call assert_equal(l, g:acmds)\n\n  if has('unix')\n    \" Run this test only on Unix-like systems. The grepprg may not be set on\n    \" non-Unix systems.\n    \" The following lines are used for the grep test. Don't remove.\n    \" Grep_Autocmd_Text: Match 1\n    \" GrepAdd_Autocmd_Text: Match 2\n    let g:acmds = []\n    silent grep Grep_Autocmd_Text test_quickfix.vim\n    silent grepadd GrepAdd_Autocmd_Text test_quickfix.vim\n    silent grep abc123def Xtest\n    silent grepadd abc123def Xtest\n    set grepprg=internal\n    silent grep Grep_Autocmd_Text test_quickfix.vim\n    silent grepadd GrepAdd_Autocmd_Text test_quickfix.vim\n    silent lgrep Grep_Autocmd_Text test_quickfix.vim\n    silent lgrepadd GrepAdd_Autocmd_Text test_quickfix.vim\n    set grepprg&vim\n    let l =<< trim END\n      pregrep\n      postgrep\n      pregrepadd\n      postgrepadd\n      pregrep\n      postgrep\n      pregrepadd\n      postgrepadd\n      pregrep\n      postgrep\n      pregrepadd\n      postgrepadd\n      prelgrep\n      postlgrep\n      prelgrepadd\n      postlgrepadd\n    END\n    call assert_equal(l, g:acmds)\n  endif\n\n  call delete('Xtest')\n  call delete('Xempty')\n  au! QuickFixCmdPre\n  au! QuickFixCmdPost\nendfunc\n\nfunc Test_Autocmd_Exception()\n  set efm=%m\n  lgetexpr '?'\n\n  try\n    call DoesNotExit()\n  catch\n    lgetexpr '1'\n  finally\n    lgetexpr '1'\n  endtry\n\n  call assert_equal('1', getloclist(0)[0].text)\n\n  set efm&vim\nendfunc\n\nfunc Test_caddbuffer_wrong()\n  \" This used to cause a memory access in freed memory.\n  let save_efm = &efm\n  set efm=%EEEE%m,%WWWW,%+CCCC%>%#,%GGGG%.#\n  cgetexpr ['WWWW', 'EEEE', 'CCCC']\n  let &efm = save_efm\n  caddbuffer\n  bwipe!\nendfunc\n\nfunc Test_caddexpr_wrong()\n  \" This used to cause a memory access in freed memory.\n  cbuffer\n  cbuffer\n  copen\n  let save_efm = &efm\n  set efm=%\n  call assert_fails('caddexpr \"\"', 'E376:')\n  let &efm = save_efm\nendfunc\n\nfunc Test_dirstack_cleanup()\n  \" This used to cause a memory access in freed memory.\n  let save_efm = &efm\n  lexpr '0'\n  lopen\n  fun X(c)\n    let save_efm=&efm\n    set efm=%D%f\n    if a:c == 'c'\n      caddexpr '::'\n    else\n      laddexpr ':0:0'\n    endif\n    let &efm=save_efm\n  endfun\n  call X('c')\n  call X('l')\n  call setqflist([], 'r')\n  caddbuffer\n  let &efm = save_efm\nendfunc\n\n\" Tests for jumping to entries from the location list window and quickfix\n\" window\nfunc Test_cwindow_jump()\n  set efm=%f%%%l%%%m\n  lgetexpr [\"F1%10%Line 10\", \"F2%20%Line 20\", \"F3%30%Line 30\"]\n  lopen | only\n  lfirst\n  call assert_true(winnr('$') == 2)\n  call assert_true(winnr() == 1)\n  \" Location list for the new window should be set\n  call assert_true(getloclist(0)[2].text == 'Line 30')\n\n  \" Open a scratch buffer\n  \" Open a new window and create a location list\n  \" Open the location list window and close the other window\n  \" Jump to an entry.\n  \" Should create a new window and jump to the entry. The scratch buffer\n  \" should not be used.\n  enew | only\n  set buftype=nofile\n  below new\n  lgetexpr [\"F1%10%Line 10\", \"F2%20%Line 20\", \"F3%30%Line 30\"]\n  lopen\n  2wincmd c\n  lnext\n  call assert_true(winnr('$') == 3)\n  call assert_true(winnr() == 2)\n\n  \" Open two windows with two different location lists\n  \" Open the location list window and close the previous window\n  \" Jump to an entry in the location list window\n  \" Should open the file in the first window and not set the location list.\n  enew | only\n  lgetexpr [\"F1%5%Line 5\"]\n  below new\n  lgetexpr [\"F1%10%Line 10\", \"F2%20%Line 20\", \"F3%30%Line 30\"]\n  lopen\n  2wincmd c\n  lnext\n  call assert_true(winnr() == 1)\n  call assert_true(getloclist(0)[0].text == 'Line 5')\n\n  enew | only\n  cgetexpr [\"F1%10%Line 10\", \"F2%20%Line 20\", \"F3%30%Line 30\"]\n  copen\n  cnext\n  call assert_true(winnr('$') == 2)\n  call assert_true(winnr() == 1)\n\n  \" open the quickfix buffer in two windows and jump to an entry. Should open\n  \" the file in the first quickfix window.\n  enew | only\n  copen\n  let bnum = bufnr('')\n  exe 'sbuffer ' . bnum\n  wincmd b\n  cfirst\n  call assert_equal(2, winnr())\n  call assert_equal('F1', @%)\n  enew | only\n  exe 'sb' bnum\n  exe 'botright sb' bnum\n  wincmd t\n  clast\n  call assert_equal(2, winnr())\n  call assert_equal('quickfix', getwinvar(1, '&buftype'))\n  call assert_equal('quickfix', getwinvar(3, '&buftype'))\n\n  \" Jumping to a file from the location list window should find a usable\n  \" window by wrapping around the window list.\n  enew | only\n  call setloclist(0, [], 'f')\n  new | new\n  lgetexpr [\"F1%10%Line 10\", \"F2%20%Line 20\", \"F3%30%Line 30\"]\n  lopen\n  1close\n  call assert_equal(0, getloclist(3, {'id' : 0}).id)\n  lnext\n  call assert_equal(3, winnr())\n  call assert_equal(getloclist(1, {'id' : 0}).id, getloclist(3, {'id' : 0}).id)\n\n  enew | only\n  set efm&vim\nendfunc\n\nfunc Test_cwindow_highlight()\n  CheckScreendump\n\n  let lines =<< trim END\n    call setline(1, ['some', 'text', 'with', 'matches'])\n    write XCwindow\n    vimgrep e XCwindow\n    redraw\n    cwindow 4\n  END\n  call writefile(lines, 'XtestCwindow')\n  let buf = RunVimInTerminal('-S XtestCwindow', #{rows: 12})\n  call VerifyScreenDump(buf, 'Test_quickfix_cwindow_1', {})\n\n  call term_sendkeys(buf, \":cnext\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_quickfix_cwindow_2', {})\n\n  call term_sendkeys(buf, \"\\<C-W>j:set cursorline\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_quickfix_cwindow_3', {})\n\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_quickfix_cwindow_4', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XtestCwindow')\n  call delete('XCwindow')\nendfunc\n\nfunc XvimgrepTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  let lines =<< trim END\n    Editor:VIM vim\n    Editor:Emacs EmAcS\n    Editor:Notepad NOTEPAD\n  END\n  call writefile(lines, 'Xtestfile1')\n  call writefile(['Linux', 'macOS', 'MS-Windows'], 'Xtestfile2')\n\n  \" Error cases\n  call assert_fails('Xvimgrep /abc *', 'E682:')\n\n  let @/=''\n  call assert_fails('Xvimgrep // *', 'E35:')\n\n  call assert_fails('Xvimgrep abc', 'E683:')\n  call assert_fails('Xvimgrep a1b2c3 Xtestfile1', 'E480:')\n  call assert_fails('Xvimgrep pat Xa1b2c3', 'E480:')\n\n  Xexpr \"\"\n  Xvimgrepadd Notepad Xtestfile1\n  Xvimgrepadd macOS Xtestfile2\n  let l = g:Xgetlist()\n  call assert_equal(2, len(l))\n  call assert_equal('Editor:Notepad NOTEPAD', l[0].text)\n\n  10Xvimgrep #\\cvim#g Xtestfile?\n  let l = g:Xgetlist()\n  call assert_equal(2, len(l))\n  call assert_equal(8, l[0].col)\n  call assert_equal(11, l[0].end_col)\n  call assert_equal(12, l[1].col)\n  call assert_equal(15, l[1].end_col)\n\n  1Xvimgrep ?Editor? Xtestfile*\n  let l = g:Xgetlist()\n  call assert_equal(1, len(l))\n  call assert_equal('Editor:VIM vim', l[0].text)\n\n  edit +3 Xtestfile2\n  Xvimgrep +\\cemacs+j Xtestfile1\n  let l = g:Xgetlist()\n  call assert_equal('Xtestfile2', @%)\n  call assert_equal('Editor:Emacs EmAcS', l[0].text)\n\n  \" Test for unloading a buffer after vimgrep searched the buffer\n  %bwipe\n  Xvimgrep /Editor/j Xtestfile*\n  call assert_equal(0, getbufinfo('Xtestfile1')[0].loaded)\n  call assert_equal([], getbufinfo('Xtestfile2'))\n\n  \" Test for opening the dummy buffer used by vimgrep in a window. The new\n  \" window should be closed\n  %bw!\n  augroup QF_Test\n    au!\n    autocmd BufReadPre * exe \"sb \" .. expand(\"<abuf>\")\n  augroup END\n  call assert_fails(\"Xvimgrep /sublime/ Xtestfile1\", 'E480:')\n  call assert_equal(1, winnr('$'))\n  augroup QF_Test\n    au!\n  augroup END\n\n  call delete('Xtestfile1')\n  call delete('Xtestfile2')\nendfunc\n\n\" Tests for the :vimgrep command\nfunc Test_vimgrep()\n  call XvimgrepTests('c')\n  call XvimgrepTests('l')\nendfunc\n\nfunc Test_vimgrep_wildcards_expanded_once()\n  new X[id-01] file.txt\n  call setline(1, 'some text to search for')\n  vimgrep text %\n  bwipe!\nendfunc\n\n\" Test for incsearch highlighting of the :vimgrep pattern\n\" This test used to cause \"E315: ml_get: invalid lnum\" errors.\nfunc Test_vimgrep_incsearch()\n  enew\n  set incsearch\n  call test_override(\"char_avail\", 1)\n\n  call feedkeys(\":2vimgrep assert test_quickfix.vim test_cdo.vim\\<CR>\", \"ntx\")\n  let l = getqflist()\n  call assert_equal(2, len(l))\n\n  call test_override(\"ALL\", 0)\n  set noincsearch\nendfunc\n\n\" Test vimgrep with the last search pattern not set\nfunc Test_vimgrep_with_no_last_search_pat()\n  let lines =<< trim [SCRIPT]\n    call assert_fails('vimgrep // *', 'E35:')\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n  call delete('Xscript')\n  call delete('Xresult')\nendfunc\n\n\" Test vimgrep without swap file\nfunc Test_vimgrep_without_swap_file()\n  let lines =<< trim [SCRIPT]\n    vimgrep grep test_c*\n    call writefile(['done'], 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '--clean -n -S Xscript Xscript')\n    call assert_equal(['done'], readfile('Xresult'))\n  endif\n  call delete('Xscript')\n  call delete('Xresult')\nendfunc\n\nfunc Test_vimgrep_existing_swapfile()\n  call writefile(['match apple with apple'], 'Xapple')\n  call writefile(['swapfile'], '.Xapple.swp')\n  let g:foundSwap = 0\n  let g:ignoreSwapExists = 1\n  augroup grep\n    au SwapExists * let foundSwap = 1 | let v:swapchoice = 'e'\n  augroup END\n  vimgrep apple Xapple\n  call assert_equal(1, g:foundSwap)\n  call assert_match('.Xapple.swo', swapname(''))\n\n  call delete('Xapple')\n  call delete('.Xapple.swp')\n  augroup grep\n    au! SwapExists\n  augroup END\n  unlet g:ignoreSwapExists\nendfunc\n\nfunc XfreeTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  enew | only\n\n  \" Deleting the quickfix stack should work even When the current list is\n  \" somewhere in the middle of the stack\n  Xexpr ['Xfile1:10:10:Line 10', 'Xfile1:15:15:Line 15']\n  Xexpr ['Xfile2:20:20:Line 20', 'Xfile2:25:25:Line 25']\n  Xexpr ['Xfile3:30:30:Line 30', 'Xfile3:35:35:Line 35']\n  Xolder\n  call g:Xsetlist([], 'f')\n  call assert_equal(0, len(g:Xgetlist()))\n\n  \" After deleting the stack, adding a new list should create a stack with a\n  \" single list.\n  Xexpr ['Xfile1:10:10:Line 10', 'Xfile1:15:15:Line 15']\n  call assert_equal(1, g:Xgetlist({'all':1}).nr)\n\n  \" Deleting the stack from a quickfix window should update/clear the\n  \" quickfix/location list window.\n  Xexpr ['Xfile1:10:10:Line 10', 'Xfile1:15:15:Line 15']\n  Xexpr ['Xfile2:20:20:Line 20', 'Xfile2:25:25:Line 25']\n  Xexpr ['Xfile3:30:30:Line 30', 'Xfile3:35:35:Line 35']\n  Xolder\n  Xwindow\n  call g:Xsetlist([], 'f')\n  call assert_equal(2, winnr('$'))\n  call assert_equal(1, line('$'))\n  Xclose\n\n  \" Deleting the stack from a non-quickfix window should update/clear the\n  \" quickfix/location list window.\n  Xexpr ['Xfile1:10:10:Line 10', 'Xfile1:15:15:Line 15']\n  Xexpr ['Xfile2:20:20:Line 20', 'Xfile2:25:25:Line 25']\n  Xexpr ['Xfile3:30:30:Line 30', 'Xfile3:35:35:Line 35']\n  Xolder\n  Xwindow\n  wincmd p\n  call g:Xsetlist([], 'f')\n  call assert_equal(0, len(g:Xgetlist()))\n  wincmd p\n  call assert_equal(2, winnr('$'))\n  call assert_equal(1, line('$'))\n\n  \" After deleting the location list stack, if the location list window is\n  \" opened, then a new location list should be created. So opening the\n  \" location list window again should not create a new window.\n  if a:cchar == 'l'\n      lexpr ['Xfile1:10:10:Line 10', 'Xfile1:15:15:Line 15']\n      wincmd p\n      lopen\n      call assert_equal(2, winnr('$'))\n  endif\n  Xclose\nendfunc\n\n\" Tests for the quickfix free functionality\nfunc Test_qf_free()\n  call XfreeTests('c')\n  call XfreeTests('l')\nendfunc\n\n\" Test for buffer overflow when parsing lines and adding new entries to\n\" the quickfix list.\nfunc Test_bufoverflow()\n  set efm=%f:%l:%m\n  cgetexpr ['File1:100:' . repeat('x', 1025)]\n\n  set efm=%+GCompiler:\\ %.%#,%f:%l:%m\n  cgetexpr ['Compiler: ' . repeat('a', 1015), 'File1:10:Hello World']\n\n  set efm=%DEntering\\ directory\\ %f,%f:%l:%m\n  let lines =<< trim eval END\n    Entering directory $\"{repeat('a', 1006)}\"\n    File1:10:Hello World\n  END\n  cgetexpr lines\n  set efm&vim\nendfunc\n\n\" Tests for getting the quickfix stack size\nfunc XsizeTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n  call assert_equal(0, g:Xgetlist({'nr':'$'}).nr)\n  call assert_equal('', g:Xgetlist({'nr':'$', 'all':1}).title)\n  call assert_equal(0, g:Xgetlist({'nr':0}).nr)\n\n  Xexpr \"File1:10:Line1\"\n  Xexpr \"File2:20:Line2\"\n  Xexpr \"File3:30:Line3\"\n  Xolder | Xolder\n  call assert_equal(3, g:Xgetlist({'nr':'$'}).nr)\n  call g:Xsetlist([], 'f')\n\n  Xexpr \"File1:10:Line1\"\n  Xexpr \"File2:20:Line2\"\n  Xexpr \"File3:30:Line3\"\n  Xolder | Xolder\n  call g:Xsetlist([], 'a', {'nr':'$', 'title':'Compiler'})\n  call assert_equal('Compiler', g:Xgetlist({'nr':3, 'all':1}).title)\nendfunc\n\nfunc Test_Qf_Size()\n  call XsizeTests('c')\n  call XsizeTests('l')\nendfunc\n\nfunc Test_cclose_from_copen()\n    augroup QF_Test\n\tau!\n        au FileType qf :call assert_fails(':cclose', 'E788:')\n    augroup END\n    copen\n    augroup QF_Test\n\tau!\n    augroup END\n    augroup! QF_Test\nendfunc\n\nfunc Test_cclose_in_autocmd()\n  \" Problem is only triggered if \"starting\" is zero, so that the OptionsSet\n  \" event will be triggered.\n  call test_override('starting', 1)\n  augroup QF_Test\n    au!\n    au FileType qf :call assert_fails(':cclose', 'E788:')\n  augroup END\n  copen\n  augroup QF_Test\n    au!\n  augroup END\n  augroup! QF_Test\n  call test_override('starting', 0)\nendfunc\n\n\" Check that \":file\" without an argument is possible even when \"curbuf_lock\"\n\" is set.\nfunc Test_file_from_copen()\n  \" Works without argument.\n  augroup QF_Test\n    au!\n    au FileType qf file\n  augroup END\n  copen\n\n  augroup QF_Test\n    au!\n  augroup END\n  cclose\n\n  \" Fails with argument.\n  augroup QF_Test\n    au!\n    au FileType qf call assert_fails(':file foo', 'E788:')\n  augroup END\n  copen\n  augroup QF_Test\n    au!\n  augroup END\n  cclose\n\n  augroup! QF_Test\nendfunc\n\nfunc Test_resize_from_copen()\n  augroup QF_Test\n    au!\n    au FileType qf resize 5\n  augroup END\n  try\n    \" This should succeed without any exception.  No other buffers are\n    \" involved in the autocmd.\n    copen\n  finally\n    augroup QF_Test\n      au!\n    augroup END\n    augroup! QF_Test\n  endtry\nendfunc\n\nfunc Test_vimgrep_with_textlock()\n  new\n\n  \" Simple way to execute something with \"textlock\" set.\n  \" Check that vimgrep without jumping can be executed.\n  au InsertCharPre * vimgrep /RunTheTest/j runtest.vim\n  normal ax\n  let qflist = getqflist()\n  call assert_true(len(qflist) > 0)\n  call assert_match('RunTheTest', qflist[0].text)\n  call setqflist([], 'r')\n  au! InsertCharPre\n\n  \" Check that vimgrepadd without jumping can be executed.\n  au InsertCharPre * vimgrepadd /RunTheTest/j runtest.vim\n  normal ax\n  let qflist = getqflist()\n  call assert_true(len(qflist) > 0)\n  call assert_match('RunTheTest', qflist[0].text)\n  call setqflist([], 'r')\n  au! InsertCharPre\n\n  \" Check that lvimgrep without jumping can be executed.\n  au InsertCharPre * lvimgrep /RunTheTest/j runtest.vim\n  normal ax\n  let qflist = getloclist(0)\n  call assert_true(len(qflist) > 0)\n  call assert_match('RunTheTest', qflist[0].text)\n  call setloclist(0, [], 'r')\n  au! InsertCharPre\n\n  \" Check that lvimgrepadd without jumping can be executed.\n  au InsertCharPre * lvimgrepadd /RunTheTest/j runtest.vim\n  normal ax\n  let qflist = getloclist(0)\n  call assert_true(len(qflist) > 0)\n  call assert_match('RunTheTest', qflist[0].text)\n  call setloclist(0, [], 'r')\n  au! InsertCharPre\n\n  \" trying to jump will give an error\n  au InsertCharPre * vimgrep /RunTheTest/ runtest.vim\n  call assert_fails('normal ax', 'E565:')\n  au! InsertCharPre\n\n  au InsertCharPre * vimgrepadd /RunTheTest/ runtest.vim\n  call assert_fails('normal ax', 'E565:')\n  au! InsertCharPre\n\n  au InsertCharPre * lvimgrep /RunTheTest/ runtest.vim\n  call assert_fails('normal ax', 'E565:')\n  au! InsertCharPre\n\n  au InsertCharPre * lvimgrepadd /RunTheTest/ runtest.vim\n  call assert_fails('normal ax', 'E565:')\n  au! InsertCharPre\n\n  bwipe!\nendfunc\n\n\" Tests for the quickfix buffer b:changedtick variable\nfunc Xchangedtick_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  new | only\n\n  Xexpr \"\" | Xexpr \"\" | Xexpr \"\"\n\n  Xopen\n  Xolder\n  Xolder\n  Xaddexpr \"F1:10:Line10\"\n  Xaddexpr \"F2:20:Line20\"\n  call g:Xsetlist([{\"filename\":\"F3\", \"lnum\":30, \"text\":\"Line30\"}], 'a')\n  call g:Xsetlist([], 'f')\n  call assert_equal(8, getbufvar('%', 'changedtick'))\n  Xclose\nendfunc\n\nfunc Test_changedtick()\n  call Xchangedtick_tests('c')\n  call Xchangedtick_tests('l')\nendfunc\n\n\" Tests for parsing an expression using setqflist()\nfunc Xsetexpr_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  let t = [\"File1:10:Line10\", \"File1:20:Line20\"]\n  call g:Xsetlist([], ' ', {'lines' : t})\n  call g:Xsetlist([], 'a', {'lines' : [\"File1:30:Line30\"]})\n\n  let l = g:Xgetlist()\n  call assert_equal(3, len(l))\n  call assert_equal(20, l[1].lnum)\n  call assert_equal('Line30', l[2].text)\n  call g:Xsetlist([], 'r', {'lines' : [\"File2:5:Line5\"]})\n  let l = g:Xgetlist()\n  call assert_equal(1, len(l))\n  call assert_equal('Line5', l[0].text)\n  call assert_equal(-1, g:Xsetlist([], 'a', {'lines' : 10}))\n  call assert_equal(-1, g:Xsetlist([], 'a', {'lines' : \"F1:10:L10\"}))\n\n  call g:Xsetlist([], 'f')\n  \" Add entries to multiple lists\n  call g:Xsetlist([], 'a', {'nr' : 1, 'lines' : [\"File1:10:Line10\"]})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'lines' : [\"File2:20:Line20\"]})\n  call g:Xsetlist([], 'a', {'nr' : 1, 'lines' : [\"File1:15:Line15\"]})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'lines' : [\"File2:25:Line25\"]})\n  call assert_equal('Line15', g:Xgetlist({'nr':1, 'items':1}).items[1].text)\n  call assert_equal('Line25', g:Xgetlist({'nr':2, 'items':1}).items[1].text)\n\n  \" Adding entries using a custom efm\n  set efm&\n  call g:Xsetlist([], ' ', {'efm' : '%f#%l#%m',\n\t\t\t\t\\ 'lines' : [\"F1#10#L10\", \"F2#20#L20\"]})\n  call assert_equal(20, g:Xgetlist({'items':1}).items[1].lnum)\n  call g:Xsetlist([], 'a', {'efm' : '%f#%l#%m', 'lines' : [\"F3:30:L30\"]})\n  call assert_equal('F3:30:L30', g:Xgetlist({'items':1}).items[2].text)\n  call assert_equal(20, g:Xgetlist({'items':1}).items[1].lnum)\n  call assert_equal(-1, g:Xsetlist([], 'a', {'efm' : [],\n\t\t\t\t\\ 'lines' : ['F1:10:L10']}))\nendfunc\n\nfunc Test_setexpr()\n  call Xsetexpr_tests('c')\n  call Xsetexpr_tests('l')\nendfunc\n\n\" Tests for per quickfix/location list directory stack\nfunc Xmultidirstack_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n  Xexpr \"\" | Xexpr \"\"\n\n  call g:Xsetlist([], 'a', {'nr' : 1, 'lines' : [\"Entering dir 'Xone/a'\"]})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'lines' : [\"Entering dir 'Xtwo/a'\"]})\n  call g:Xsetlist([], 'a', {'nr' : 1, 'lines' : [\"one.txt:3:one one one\"]})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'lines' : [\"two.txt:5:two two two\"]})\n\n  let l1 = g:Xgetlist({'nr':1, 'items':1})\n  let l2 = g:Xgetlist({'nr':2, 'items':1})\n  call assert_equal('Xone/a/one.txt', bufname(l1.items[1].bufnr))\n  call assert_equal(3, l1.items[1].lnum)\n  call assert_equal('Xtwo/a/two.txt', bufname(l2.items[1].bufnr))\n  call assert_equal(5, l2.items[1].lnum)\nendfunc\n\nfunc Test_multidirstack()\n  call mkdir('Xone/a', 'p')\n  call mkdir('Xtwo/a', 'p')\n  let lines = ['1', '2', 'one one one', '4', 'two two two', '6', '7']\n  call writefile(lines, 'Xone/a/one.txt')\n  call writefile(lines, 'Xtwo/a/two.txt')\n  let save_efm = &efm\n  set efm=%DEntering\\ dir\\ '%f',%f:%l:%m,%XLeaving\\ dir\\ '%f'\n\n  call Xmultidirstack_tests('c')\n  call Xmultidirstack_tests('l')\n\n  let &efm = save_efm\n  call delete('Xone', 'rf')\n  call delete('Xtwo', 'rf')\nendfunc\n\n\" Tests for per quickfix/location list file stack\nfunc Xmultifilestack_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n  Xexpr \"\" | Xexpr \"\"\n\n  call g:Xsetlist([], 'a', {'nr' : 1, 'lines' : [\"[one.txt]\"]})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'lines' : [\"[two.txt]\"]})\n  call g:Xsetlist([], 'a', {'nr' : 1, 'lines' : [\"(3,5) one one one\"]})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'lines' : [\"(5,9) two two two\"]})\n\n  let l1 = g:Xgetlist({'nr':1, 'items':1})\n  let l2 = g:Xgetlist({'nr':2, 'items':1})\n  call assert_equal('one.txt', bufname(l1.items[1].bufnr))\n  call assert_equal(3, l1.items[1].lnum)\n  call assert_equal('two.txt', bufname(l2.items[1].bufnr))\n  call assert_equal(5, l2.items[1].lnum)\n\n  \" Test for start of a new error line in the same line where a previous\n  \" error line ends with a file stack.\n  let efm_val = 'Error\\ l%l\\ in\\ %f,'\n  let efm_val .= '%-P%>(%f%r,Error\\ l%l\\ in\\ %m,%-Q)%r'\n  let lines =<< trim END\n    (one.txt\n    Error l4 in one.txt\n    ) (two.txt\n    Error l6 in two.txt\n    )\n    Error l8 in one.txt\n  END\n  let l = g:Xgetlist({'lines': lines, 'efm' : efm_val})\n  call assert_equal(3, len(l.items))\n  call assert_equal('one.txt', bufname(l.items[0].bufnr))\n  call assert_equal(4, l.items[0].lnum)\n  call assert_equal('one.txt', l.items[0].text)\n  call assert_equal('two.txt', bufname(l.items[1].bufnr))\n  call assert_equal(6, l.items[1].lnum)\n  call assert_equal('two.txt', l.items[1].text)\n  call assert_equal('one.txt', bufname(l.items[2].bufnr))\n  call assert_equal(8, l.items[2].lnum)\n  call assert_equal('', l.items[2].text)\nendfunc\n\nfunc Test_multifilestack()\n  let lines = ['1', '2', 'one one one', '4', 'two two two', '6', '7']\n  call writefile(lines, 'one.txt')\n  call writefile(lines, 'two.txt')\n  let save_efm = &efm\n  set efm=%+P[%f],(%l\\\\,%c)\\ %m,%-Q\n\n  call Xmultifilestack_tests('c')\n  call Xmultifilestack_tests('l')\n\n  let &efm = save_efm\n  call delete('one.txt')\n  call delete('two.txt')\nendfunc\n\n\" Tests for per buffer 'efm' setting\nfunc Test_perbuf_efm()\n  call writefile([\"File1-10-Line10\"], 'one.txt')\n  call writefile([\"File2#20#Line20\"], 'two.txt')\n  set efm=%f#%l#%m\n  new | only\n  new\n  setlocal efm=%f-%l-%m\n  cfile one.txt\n  wincmd w\n  caddfile two.txt\n\n  let l = getqflist()\n  call assert_equal(10, l[0].lnum)\n  call assert_equal('Line20', l[1].text)\n\n  set efm&\n  new | only\n  call delete('one.txt')\n  call delete('two.txt')\nendfunc\n\n\" Open multiple help windows using \":lhelpgrep\n\" This test used to crash Vim\nfunc Test_Multi_LL_Help()\n  new | only\n  lhelpgrep window\n  lopen\n  e#\n  lhelpgrep buffer\n  call assert_equal(3, winnr('$'))\n  call assert_true(len(getloclist(1)) != 0)\n  call assert_true(len(getloclist(2)) != 0)\n  new | only\nendfunc\n\n\" Tests for adding new quickfix lists using setqflist()\nfunc XaddQf_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Create a new list using ' ' for action\n  call g:Xsetlist([], 'f')\n  call g:Xsetlist([], ' ', {'title' : 'Test1'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(1, l.nr)\n  call assert_equal('Test1', l.title)\n\n  \" Create a new list using ' ' for action and '$' for 'nr'\n  call g:Xsetlist([], 'f')\n  call g:Xsetlist([], ' ', {'title' : 'Test2', 'nr' : '$'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(1, l.nr)\n  call assert_equal('Test2', l.title)\n\n  \" Create a new list using 'a' for action\n  call g:Xsetlist([], 'f')\n  call g:Xsetlist([], 'a', {'title' : 'Test3'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(1, l.nr)\n  call assert_equal('Test3', l.title)\n\n  \" Create a new list using 'a' for action and '$' for 'nr'\n  call g:Xsetlist([], 'f')\n  call g:Xsetlist([], 'a', {'title' : 'Test3', 'nr' : '$'})\n  call g:Xsetlist([], 'a', {'title' : 'Test4'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(1, l.nr)\n  call assert_equal('Test4', l.title)\n\n  \" Adding a quickfix list should remove all the lists following the current\n  \" list.\n  Xexpr \"\" | Xexpr \"\" | Xexpr \"\"\n  silent! 10Xolder\n  call g:Xsetlist([], ' ', {'title' : 'Test5'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(2, l.nr)\n  call assert_equal('Test5', l.title)\n\n  \" Add a quickfix list using '$' as the list number.\n  let lastqf = g:Xgetlist({'nr':'$'}).nr\n  silent! 99Xolder\n  call g:Xsetlist([], ' ', {'nr' : '$', 'title' : 'Test6'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(lastqf + 1, l.nr)\n  call assert_equal('Test6', l.title)\n\n  \" Add a quickfix list using 'nr' set to one more than the quickfix\n  \" list size.\n  let lastqf = g:Xgetlist({'nr':'$'}).nr\n  silent! 99Xolder\n  call g:Xsetlist([], ' ', {'nr' : lastqf + 1, 'title' : 'Test7'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(lastqf + 1, l.nr)\n  call assert_equal('Test7', l.title)\n\n  \" Add a quickfix list to a stack with 10 lists using 'nr' set to '$'\n  exe repeat('Xexpr \"\" |', 9) . 'Xexpr \"\"'\n  silent! 99Xolder\n  call g:Xsetlist([], ' ', {'nr' : '$', 'title' : 'Test8'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(10, l.nr)\n  call assert_equal('Test8', l.title)\n\n  \" Add a quickfix list using 'nr' set to a value greater than 10\n  call assert_equal(-1, g:Xsetlist([], ' ', {'nr' : 12, 'title' : 'Test9'}))\n\n  \" Try adding a quickfix list with 'nr' set to a value greater than the\n  \" quickfix list size but less than 10.\n  call g:Xsetlist([], 'f')\n  Xexpr \"\" | Xexpr \"\" | Xexpr \"\"\n  silent! 99Xolder\n  call assert_equal(-1, g:Xsetlist([], ' ', {'nr' : 8, 'title' : 'Test10'}))\n\n  \" Add a quickfix list using 'nr' set to a some string or list\n  call assert_equal(-1, g:Xsetlist([], ' ', {'nr' : [1,2], 'title' : 'Test11'}))\nendfunc\n\nfunc Test_add_qf()\n  call XaddQf_tests('c')\n  call XaddQf_tests('l')\nendfunc\n\n\" Test for getting the quickfix list items from some text without modifying\n\" the quickfix stack\nfunc XgetListFromLines(cchar)\n  call s:setup_commands(a:cchar)\n  call g:Xsetlist([], 'f')\n\n  let l = g:Xgetlist({'lines' : [\"File2:20:Line20\", \"File2:30:Line30\"]}).items\n  call assert_equal(2, len(l))\n  call assert_equal(30, l[1].lnum)\n\n  call assert_equal({}, g:Xgetlist({'lines' : 10}))\n  call assert_equal({}, g:Xgetlist({'lines' : 'File1:10:Line10'}))\n  call assert_equal([], g:Xgetlist({'lines' : []}).items)\n  call assert_equal([], g:Xgetlist({'lines' : [10, 20]}).items)\n\n  \" Parse text using a custom efm\n  set efm&\n  let l = g:Xgetlist({'lines':['File3#30#Line30'], 'efm' : '%f#%l#%m'}).items\n  call assert_equal('Line30', l[0].text)\n  let l = g:Xgetlist({'lines':['File3:30:Line30'], 'efm' : '%f-%l-%m'}).items\n  call assert_equal('File3:30:Line30', l[0].text)\n  let l = g:Xgetlist({'lines':['File3:30:Line30'], 'efm' : [1,2]})\n  call assert_equal({}, l)\n  call assert_fails(\"call g:Xgetlist({'lines':['abc'], 'efm':'%2'})\", 'E376:')\n  call assert_fails(\"call g:Xgetlist({'lines':['abc'], 'efm':''})\", 'E378:')\n\n  \" Make sure that the quickfix stack is not modified\n  call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\nendfunc\n\nfunc Test_get_list_from_lines()\n  call XgetListFromLines('c')\n  call XgetListFromLines('l')\nendfunc\n\n\" Tests for the quickfix list id\nfunc Xqfid_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n  call assert_equal(0, g:Xgetlist({'id':0}).id)\n  Xexpr ''\n  let start_id = g:Xgetlist({'id' : 0}).id\n  Xexpr '' | Xexpr ''\n  Xolder\n  call assert_equal(start_id, g:Xgetlist({'id':0, 'nr':1}).id)\n  call assert_equal(start_id + 1, g:Xgetlist({'id':0, 'nr':0}).id)\n  call assert_equal(start_id + 2, g:Xgetlist({'id':0, 'nr':'$'}).id)\n  call assert_equal(0, g:Xgetlist({'id':0, 'nr':99}).id)\n  call assert_equal(2, g:Xgetlist({'id':start_id + 1, 'nr':0}).nr)\n  call assert_equal(0, g:Xgetlist({'id':99, 'nr':0}).id)\n  call assert_equal(0, g:Xgetlist({'id':\"abc\", 'nr':0}).id)\n\n  call g:Xsetlist([], 'a', {'id':start_id, 'context':[1,2]})\n  call assert_equal([1,2], g:Xgetlist({'nr':1, 'context':1}).context)\n  call g:Xsetlist([], 'a', {'id':start_id+1, 'lines':['F1:10:L10']})\n  call assert_equal('L10', g:Xgetlist({'nr':2, 'items':1}).items[0].text)\n  call assert_equal(-1, g:Xsetlist([], 'a', {'id':999, 'title':'Vim'}))\n  call assert_equal(-1, g:Xsetlist([], 'a', {'id':'abc', 'title':'Vim'}))\n\n  let qfid = g:Xgetlist({'id':0, 'nr':0})\n  call g:Xsetlist([], 'f')\n  call assert_equal(0, g:Xgetlist({'id':qfid, 'nr':0}).id)\nendfunc\n\nfunc Test_qf_id()\n  call Xqfid_tests('c')\n  call Xqfid_tests('l')\nendfunc\n\nfunc Xqfjump_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call writefile([\"Line1\\tFoo\", \"Line2\"], 'F1')\n  call writefile([\"Line1\\tBar\", \"Line2\"], 'F2')\n  call writefile([\"Line1\\tBaz\", \"Line2\"], 'F3')\n\n  call g:Xsetlist([], 'f')\n\n  \" Tests for\n  \"   Jumping to a line using a pattern\n  \"   Jumping to a column greater than the last column in a line\n  \"   Jumping to a line greater than the last line in the file\n  let l = []\n  for i in range(1, 7)\n    call add(l, {})\n  endfor\n  let l[0].filename='F1'\n  let l[0].pattern='Line1'\n  let l[1].filename='F2'\n  let l[1].pattern='Line1'\n  let l[2].filename='F3'\n  let l[2].pattern='Line1'\n  let l[3].filename='F3'\n  let l[3].lnum=1\n  let l[3].col=9\n  let l[3].vcol=1\n  let l[4].filename='F3'\n  let l[4].lnum=99\n  let l[5].filename='F3'\n  let l[5].lnum=1\n  let l[5].col=99\n  let l[5].vcol=1\n  let l[6].filename='F3'\n  let l[6].pattern='abcxyz'\n\n  call g:Xsetlist([], ' ', {'items' : l})\n  Xopen | only\n  2Xnext\n  call assert_equal(3, g:Xgetlist({'idx' : 0}).idx)\n  call assert_equal('F3', @%)\n  Xnext\n  call assert_equal(7, col('.'))\n  Xnext\n  call assert_equal(2, line('.'))\n  Xnext\n  call assert_equal(9, col('.'))\n  2\n  Xnext\n  call assert_equal(2, line('.'))\n\n  if a:cchar == 'l'\n    \" When jumping to a location list entry in the location list window and\n    \" no usable windows are available, then a new window should be opened.\n    enew! | new | only\n    call g:Xsetlist([], 'f')\n    setlocal buftype=nofile\n    new\n    let lines =<< trim END\n      F1:1:1:Line1\n      F1:2:2:Line2\n      F2:1:1:Line1\n      F2:2:2:Line2\n      F3:1:1:Line1\n      F3:2:2:Line2\n    END\n    call g:Xsetlist([], ' ', {'lines': lines})\n    Xopen\n    let winid = win_getid()\n    wincmd p\n    close\n    call win_gotoid(winid)\n    Xnext\n    call assert_equal(3, winnr('$'))\n    call assert_equal(1, winnr())\n    call assert_equal(2, line('.'))\n\n    \" When jumping to an entry in the location list window and the window\n    \" associated with the location list is not present and a window containing\n    \" the file is already present, then that window should be used.\n    close\n    belowright new\n    call g:Xsetlist([], 'f')\n    edit F3\n    call win_gotoid(winid)\n    Xlast\n    call assert_equal(3, winnr())\n    call assert_equal(6, g:Xgetlist({'size' : 1}).size)\n    call assert_equal(winid, g:Xgetlist({'winid' : 1}).winid)\n  endif\n\n  \" Cleanup\n  enew!\n  new | only\n\n  call delete('F1')\n  call delete('F2')\n  call delete('F3')\nendfunc\n\nfunc Test_qfjump()\n  call Xqfjump_tests('c')\n  call Xqfjump_tests('l')\nendfunc\n\n\" Tests for the getqflist() and getloclist() functions when the list is not\n\" present or is empty\nfunc Xgetlist_empty_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Empty quickfix stack\n  call g:Xsetlist([], 'f')\n  call assert_equal('', g:Xgetlist({'context' : 0}).context)\n  call assert_equal(0, g:Xgetlist({'id' : 0}).id)\n  call assert_equal(0, g:Xgetlist({'idx' : 0}).idx)\n  call assert_equal([], g:Xgetlist({'items' : 0}).items)\n  call assert_equal(0, g:Xgetlist({'nr' : 0}).nr)\n  call assert_equal(0, g:Xgetlist({'size' : 0}).size)\n  call assert_equal('', g:Xgetlist({'title' : 0}).title)\n  call assert_equal(0, g:Xgetlist({'winid' : 0}).winid)\n  call assert_equal(0, g:Xgetlist({'changedtick' : 0}).changedtick)\n  if a:cchar == 'c'\n    call assert_equal({'context' : '', 'id' : 0, 'idx' : 0,\n\t\t  \\ 'items' : [], 'nr' : 0, 'size' : 0, 'qfbufnr' : 0,\n\t\t  \\ 'title' : '', 'winid' : 0, 'changedtick': 0,\n                  \\ 'quickfixtextfunc' : ''}, g:Xgetlist({'all' : 0}))\n  else\n    call assert_equal({'context' : '', 'id' : 0, 'idx' : 0,\n\t\t\\ 'items' : [], 'nr' : 0, 'size' : 0, 'title' : '',\n\t\t\\ 'winid' : 0, 'changedtick': 0, 'filewinid' : 0,\n\t\t\\ 'qfbufnr' : 0, 'quickfixtextfunc' : ''},\n\t\t\\ g:Xgetlist({'all' : 0}))\n  endif\n\n  \" Quickfix window with empty stack\n  silent! Xopen\n  let qfwinid = (a:cchar == 'c') ? win_getid() : 0\n  let qfbufnr = (a:cchar == 'c') ? bufnr('') : 0\n  call assert_equal(qfwinid, g:Xgetlist({'winid' : 0}).winid)\n  Xclose\n\n  \" Empty quickfix list\n  Xexpr \"\"\n  call assert_equal('', g:Xgetlist({'context' : 0}).context)\n  call assert_notequal(0, g:Xgetlist({'id' : 0}).id)\n  call assert_equal(0, g:Xgetlist({'idx' : 0}).idx)\n  call assert_equal([], g:Xgetlist({'items' : 0}).items)\n  call assert_notequal(0, g:Xgetlist({'nr' : 0}).nr)\n  call assert_equal(0, g:Xgetlist({'size' : 0}).size)\n  call assert_notequal('', g:Xgetlist({'title' : 0}).title)\n  call assert_equal(0, g:Xgetlist({'winid' : 0}).winid)\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  let qfid = g:Xgetlist({'id' : 0}).id\n  call g:Xsetlist([], 'f')\n\n  \" Non-existing quickfix identifier\n  call assert_equal('', g:Xgetlist({'id' : qfid, 'context' : 0}).context)\n  call assert_equal(0, g:Xgetlist({'id' : qfid}).id)\n  call assert_equal(0, g:Xgetlist({'id' : qfid, 'idx' : 0}).idx)\n  call assert_equal([], g:Xgetlist({'id' : qfid, 'items' : 0}).items)\n  call assert_equal(0, g:Xgetlist({'id' : qfid, 'nr' : 0}).nr)\n  call assert_equal(0, g:Xgetlist({'id' : qfid, 'size' : 0}).size)\n  call assert_equal('', g:Xgetlist({'id' : qfid, 'title' : 0}).title)\n  call assert_equal(0, g:Xgetlist({'id' : qfid, 'winid' : 0}).winid)\n  call assert_equal(0, g:Xgetlist({'id' : qfid, 'changedtick' : 0}).changedtick)\n  if a:cchar == 'c'\n    call assert_equal({'context' : '', 'id' : 0, 'idx' : 0, 'items' : [],\n\t\t\\ 'nr' : 0, 'size' : 0, 'title' : '', 'winid' : 0,\n\t\t\\ 'qfbufnr' : qfbufnr, 'quickfixtextfunc' : '',\n\t\t\\ 'changedtick' : 0}, g:Xgetlist({'id' : qfid, 'all' : 0}))\n  else\n    call assert_equal({'context' : '', 'id' : 0, 'idx' : 0, 'items' : [],\n\t\t\\ 'nr' : 0, 'size' : 0, 'title' : '', 'winid' : 0,\n\t\t\\ 'changedtick' : 0, 'filewinid' : 0, 'qfbufnr' : 0,\n                \\ 'quickfixtextfunc' : ''},\n\t\t\\ g:Xgetlist({'id' : qfid, 'all' : 0}))\n  endif\n\n  \" Non-existing quickfix list number\n  call assert_equal('', g:Xgetlist({'nr' : 5, 'context' : 0}).context)\n  call assert_equal(0, g:Xgetlist({'nr' : 5}).nr)\n  call assert_equal(0, g:Xgetlist({'nr' : 5, 'idx' : 0}).idx)\n  call assert_equal([], g:Xgetlist({'nr' : 5, 'items' : 0}).items)\n  call assert_equal(0, g:Xgetlist({'nr' : 5, 'id' : 0}).id)\n  call assert_equal(0, g:Xgetlist({'nr' : 5, 'size' : 0}).size)\n  call assert_equal('', g:Xgetlist({'nr' : 5, 'title' : 0}).title)\n  call assert_equal(0, g:Xgetlist({'nr' : 5, 'winid' : 0}).winid)\n  call assert_equal(0, g:Xgetlist({'nr' : 5, 'changedtick' : 0}).changedtick)\n  if a:cchar == 'c'\n    call assert_equal({'context' : '', 'id' : 0, 'idx' : 0, 'items' : [],\n\t\t\\ 'nr' : 0, 'size' : 0, 'title' : '', 'winid' : 0,\n\t\t\\ 'changedtick' : 0, 'qfbufnr' : qfbufnr,\n                \\ 'quickfixtextfunc' : ''}, g:Xgetlist({'nr' : 5, 'all' : 0}))\n  else\n    call assert_equal({'context' : '', 'id' : 0, 'idx' : 0, 'items' : [],\n\t\t\\ 'nr' : 0, 'size' : 0, 'title' : '', 'winid' : 0,\n\t\t\\ 'changedtick' : 0, 'filewinid' : 0, 'qfbufnr' : 0,\n                \\ 'quickfixtextfunc' : ''}, g:Xgetlist({'nr' : 5, 'all' : 0}))\n  endif\nendfunc\n\nfunc Test_getqflist()\n  call Xgetlist_empty_tests('c')\n  call Xgetlist_empty_tests('l')\nendfunc\n\nfunc Test_getqflist_invalid_nr()\n  \" The following commands used to crash Vim\n  cexpr \"\"\n  call getqflist({'nr' : $XXX_DOES_NOT_EXIST_XXX})\n\n  \" Cleanup\n  call setqflist([], 'r')\nendfunc\n\n\" Tests for the quickfix/location list changedtick\nfunc Xqftick_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n\n  Xexpr \"F1:10:Line10\"\n  let qfid = g:Xgetlist({'id' : 0}).id\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n  Xaddexpr \"F2:20:Line20\\nF2:21:Line21\"\n  call assert_equal(2, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call g:Xsetlist([], 'a', {'lines' : [\"F3:30:Line30\", \"F3:31:Line31\"]})\n  call assert_equal(3, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call g:Xsetlist([], 'r', {'lines' : [\"F4:40:Line40\"]})\n  call assert_equal(4, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call g:Xsetlist([], 'a', {'title' : 'New Title'})\n  call assert_equal(5, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  enew!\n  call append(0, [\"F5:50:L50\", \"F6:60:L60\"])\n  Xaddbuffer\n  call assert_equal(6, g:Xgetlist({'changedtick' : 0}).changedtick)\n  enew!\n\n  call g:Xsetlist([], 'a', {'context' : {'bus' : 'pci'}})\n  call assert_equal(7, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call g:Xsetlist([{'filename' : 'F7', 'lnum' : 10, 'text' : 'L7'},\n\t      \\ {'filename' : 'F7', 'lnum' : 11, 'text' : 'L11'}], 'a')\n  call assert_equal(8, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call g:Xsetlist([{'filename' : 'F7', 'lnum' : 10, 'text' : 'L7'},\n\t      \\ {'filename' : 'F7', 'lnum' : 11, 'text' : 'L11'}], ' ')\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call g:Xsetlist([{'filename' : 'F7', 'lnum' : 10, 'text' : 'L7'},\n\t      \\ {'filename' : 'F7', 'lnum' : 11, 'text' : 'L11'}], 'r')\n  call assert_equal(2, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  call writefile([\"F8:80:L80\", \"F8:81:L81\"], \"Xone\")\n  Xfile Xone\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n  Xaddfile Xone\n  call assert_equal(2, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  \" Test case for updating a non-current quickfix list\n  call g:Xsetlist([], 'f')\n  Xexpr \"F1:1:L1\"\n  Xexpr \"F2:2:L2\"\n  call g:Xsetlist([], 'a', {'nr' : 1, \"lines\" : [\"F10:10:L10\"]})\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call assert_equal(2, g:Xgetlist({'nr' : 1, 'changedtick' : 0}).changedtick)\n\n  call delete(\"Xone\")\nendfunc\n\nfunc Test_qf_tick()\n  call Xqftick_tests('c')\n  call Xqftick_tests('l')\nendfunc\n\n\" Test helpgrep with lang specifier\nfunc Xtest_helpgrep_with_lang_specifier(cchar)\n  call s:setup_commands(a:cchar)\n  Xhelpgrep Vim@en\n  call assert_equal('help', &filetype)\n  call assert_notequal(0, g:Xgetlist({'nr' : '$'}).nr)\n  new | only\nendfunc\n\nfunc Test_helpgrep_with_lang_specifier()\n  call Xtest_helpgrep_with_lang_specifier('c')\n  call Xtest_helpgrep_with_lang_specifier('l')\nendfunc\n\n\" The following test used to crash Vim.\n\" Open the location list window and close the regular window associated with\n\" the location list. When the garbage collection runs now, it incorrectly\n\" marks the location list context as not in use and frees the context.\nfunc Test_ll_window_ctx()\n  call setloclist(0, [], 'f')\n  call setloclist(0, [], 'a', {'context' : []})\n  lopen | only\n  call test_garbagecollect_now()\n  echo getloclist(0, {'context' : 1}).context\n  enew | only\nendfunc\n\n\" The following test used to crash vim\nfunc Test_lfile_crash()\n  sp Xtest\n  au QuickFixCmdPre * bw\n  call assert_fails('lfile', 'E40:')\n  au! QuickFixCmdPre\nendfunc\n\n\" The following test used to crash vim\nfunc Test_lbuffer_crash()\n  sv Xtest\n  augroup QF_Test\n    au!\n    au QuickFixCmdPre,QuickFixCmdPost,BufEnter,BufLeave * bw\n  augroup END\n  lbuffer\n  augroup QF_Test\n    au!\n  augroup END\nendfunc\n\n\" The following test used to crash vim\nfunc Test_lexpr_crash()\n  augroup QF_Test\n    au!\n    au QuickFixCmdPre,QuickFixCmdPost,BufEnter,BufLeave * call setloclist(0, [], 'f')\n  augroup END\n  lexpr \"\"\n  augroup QF_Test\n    au!\n  augroup END\n\n  enew | only\n  augroup QF_Test\n    au!\n    au BufNew * call setloclist(0, [], 'f')\n  augroup END\n  lexpr 'x:1:x'\n  augroup QF_Test\n    au!\n  augroup END\n\n  enew | only\n  lexpr ''\n  lopen\n  augroup QF_Test\n    au!\n    au FileType * call setloclist(0, [], 'f')\n  augroup END\n  lexpr ''\n  augroup QF_Test\n    au!\n  augroup END\nendfunc\n\n\" The following test used to crash Vim\nfunc Test_lvimgrep_crash()\n  sv Xtest\n  augroup QF_Test\n    au!\n    au QuickFixCmdPre,QuickFixCmdPost,BufEnter,BufLeave * call setloclist(0, [], 'f')\n  augroup END\n  lvimgrep quickfix test_quickfix.vim\n  augroup QF_Test\n    au!\n  augroup END\n\n  new | only\n  augroup QF_Test\n    au!\n    au BufEnter * call setloclist(0, [], 'r')\n  augroup END\n  call assert_fails('lvimgrep Test_lvimgrep_crash *', 'E926:')\n  augroup QF_Test\n    au!\n  augroup END\n\n  enew | only\nendfunc\n\nfunc Test_lvimgrep_crash2()\n  au BufNewFile x sfind\n  call assert_fails('lvimgrep x x', 'E471:')\n  call assert_fails('lvimgrep x x x', 'E471:')\n\n  au! BufNewFile\nendfunc\n\n\" Test for the position of the quickfix and location list window\nfunc Test_qfwin_pos()\n  \" Open two windows\n  new | only\n  new\n  cexpr ['F1:10:L10']\n  copen\n  \" Quickfix window should be the bottom most window\n  call assert_equal(3, winnr())\n  close\n  \" Open at the very top\n  wincmd t\n  topleft copen\n  call assert_equal(1, winnr())\n  close\n  \" open left of the current window\n  wincmd t\n  below new\n  leftabove copen\n  call assert_equal(2, winnr())\n  close\n  \" open right of the current window\n  rightbelow copen\n  call assert_equal(3, winnr())\n  close\nendfunc\n\n\" Tests for quickfix/location lists changed by autocommands when\n\" :vimgrep/:lvimgrep commands are running.\nfunc Test_vimgrep_autocmd()\n  call setqflist([], 'f')\n  call writefile(['stars'], 'Xtest1.txt')\n  call writefile(['stars'], 'Xtest2.txt')\n\n  \" Test 1:\n  \" When searching for a pattern using :vimgrep, if the quickfix list is\n  \" changed by an autocmd, the results should be added to the correct quickfix\n  \" list.\n  autocmd BufRead Xtest2.txt cexpr '' | cexpr ''\n  silent vimgrep stars Xtest*.txt\n  call assert_equal(1, getqflist({'nr' : 0}).nr)\n  call assert_equal(3, getqflist({'nr' : '$'}).nr)\n  call assert_equal('Xtest2.txt', bufname(getqflist()[1].bufnr))\n  au! BufRead Xtest2.txt\n\n  \" Test 2:\n  \" When searching for a pattern using :vimgrep, if the quickfix list is\n  \" freed, then a error should be given.\n  silent! %bwipe!\n  call setqflist([], 'f')\n  autocmd BufRead Xtest2.txt for i in range(10) | cexpr '' | endfor\n  call assert_fails('vimgrep stars Xtest*.txt', 'E925:')\n  au! BufRead Xtest2.txt\n\n  \" Test 3:\n  \" When searching for a pattern using :lvimgrep, if the location list is\n  \" freed, then the command should error out.\n  silent! %bwipe!\n  let g:save_winid = win_getid()\n  autocmd BufRead Xtest2.txt call setloclist(g:save_winid, [], 'f')\n  call assert_fails('lvimgrep stars Xtest*.txt', 'E926:')\n  au! BufRead Xtest2.txt\n\n  call delete('Xtest1.txt')\n  call delete('Xtest2.txt')\n  call setqflist([], 'f')\nendfunc\n\n\" Test for an autocmd changing the current directory when running vimgrep\nfunc Xvimgrep_autocmd_cd(cchar)\n  call s:setup_commands(a:cchar)\n\n  %bwipe\n  let save_cwd = getcwd()\n\n  augroup QF_Test\n    au!\n    autocmd BufRead * silent cd %:p:h\n  augroup END\n\n  10Xvimgrep /vim/ Xdir/**\n  let l = g:Xgetlist()\n  call assert_equal('f1.txt', bufname(l[0].bufnr))\n  call assert_equal('f2.txt', fnamemodify(bufname(l[2].bufnr), ':t'))\n\n  augroup QF_Test\n    au!\n  augroup END\n\n  exe 'cd ' . save_cwd\nendfunc\n\nfunc Test_vimgrep_autocmd_cd()\n  call mkdir('Xdir/a', 'p')\n  call mkdir('Xdir/b', 'p')\n  call writefile(['a_L1_vim', 'a_L2_vim'], 'Xdir/a/f1.txt')\n  call writefile(['b_L1_vim', 'b_L2_vim'], 'Xdir/b/f2.txt')\n  call Xvimgrep_autocmd_cd('c')\n  call Xvimgrep_autocmd_cd('l')\n  %bwipe\n  call delete('Xdir', 'rf')\nendfunc\n\n\" The following test used to crash Vim\nfunc Test_lhelpgrep_autocmd()\n  lhelpgrep quickfix\n  augroup QF_Test\n    au!\n    autocmd QuickFixCmdPost * call setloclist(0, [], 'f')\n  augroup END\n  lhelpgrep buffer\n  call assert_equal('help', &filetype)\n  call assert_equal(0, getloclist(0, {'nr' : '$'}).nr)\n  lhelpgrep tabpage\n  call assert_equal('help', &filetype)\n  call assert_equal(1, getloclist(0, {'nr' : '$'}).nr)\n  augroup QF_Test\n    au!\n  augroup END\n\n  new | only\n  augroup QF_Test\n    au!\n    au BufEnter * call setqflist([], 'f')\n  augroup END\n  call assert_fails('helpgrep quickfix', 'E925:')\n  \" run the test with a help window already open\n  help\n  wincmd w\n  call assert_fails('helpgrep quickfix', 'E925:')\n  augroup QF_Test\n    au!\n  augroup END\n\n  new | only\n  augroup QF_Test\n    au!\n    au BufEnter * call setqflist([], 'r')\n  augroup END\n  call assert_fails('helpgrep quickfix', 'E925:')\n  augroup QF_Test\n    au!\n  augroup END\n\n  new | only\n  augroup QF_Test\n    au!\n    au BufEnter * call setloclist(0, [], 'r')\n  augroup END\n  call assert_fails('lhelpgrep quickfix', 'E926:')\n  augroup QF_Test\n    au!\n  augroup END\n\n  \" Replace the contents of a help window location list when it is still in\n  \" use.\n  new | only\n  lhelpgrep quickfix\n  wincmd w\n  augroup QF_Test\n    au!\n    autocmd WinEnter * call setloclist(0, [], 'r')\n  augroup END\n  call assert_fails('lhelpgrep win_getid', 'E926:')\n  augroup QF_Test\n    au!\n  augroup END\n\n  %bw!\nendfunc\n\n\" The following test used to crash Vim\nfunc Test_lhelpgrep_autocmd_free_loclist()\n  %bw!\n  lhelpgrep quickfix\n  wincmd w\n  augroup QF_Test\n    au!\n    autocmd WinEnter * call setloclist(0, [], 'f')\n  augroup END\n  lhelpgrep win_getid\n  wincmd w\n  wincmd w\n  wincmd w\n  augroup QF_Test\n    au!\n  augroup END\n  %bw!\nendfunc\n\n\" Test for shortening/simplifying the file name when opening the\n\" quickfix window or when displaying the quickfix list\nfunc Test_shorten_fname()\n  CheckUnix\n  %bwipe\n  \" Create a quickfix list with an absolute path filename\n  let fname = getcwd() . '/test_quickfix.vim'\n  call setqflist([], ' ', {'lines':[fname . \":20:Line20\"], 'efm':'%f:%l:%m'})\n  call assert_equal(fname, bufname('test_quickfix.vim'))\n  \" Opening the quickfix window should simplify the file path\n  cwindow\n  call assert_equal('test_quickfix.vim', bufname('test_quickfix.vim'))\n  cclose\n  %bwipe\n  \" Create a quickfix list with an absolute path filename\n  call setqflist([], ' ', {'lines':[fname . \":20:Line20\"], 'efm':'%f:%l:%m'})\n  call assert_equal(fname, bufname('test_quickfix.vim'))\n  \" Displaying the quickfix list should simplify the file path\n  silent! clist\n  call assert_equal('test_quickfix.vim', bufname('test_quickfix.vim'))\n  \" Add a few entries for the same file with different paths and check whether\n  \" the buffer name is shortened\n  %bwipe\n  call setqflist([], 'f')\n  call setqflist([{'filename' : 'test_quickfix.vim', 'lnum' : 10},\n        \\ {'filename' : '../testdir/test_quickfix.vim', 'lnum' : 20},\n        \\ {'filename' : fname, 'lnum' : 30}], ' ')\n  copen\n  call assert_equal(['test_quickfix.vim|10| ',\n        \\ 'test_quickfix.vim|20| ',\n        \\ 'test_quickfix.vim|30| '], getline(1, '$'))\n  cclose\nendfunc\n\n\" Quickfix title tests\n\" In the below tests, 'exe \"cmd\"' is used to invoke the quickfix commands.\n\" Otherwise due to indentation, the title is set with spaces at the beginning\n\" of the command.\nfunc Test_qftitle()\n  call writefile([\"F1:1:Line1\"], 'Xerr')\n\n  \" :cexpr\n  exe \"cexpr readfile('Xerr')\"\n  call assert_equal(\":cexpr readfile('Xerr')\", getqflist({'title' : 1}).title)\n\n  \" :cgetexpr\n  exe \"cgetexpr readfile('Xerr')\"\n  call assert_equal(\":cgetexpr readfile('Xerr')\",\n\t\t\t\t\t\\ getqflist({'title' : 1}).title)\n\n  \" :caddexpr\n  call setqflist([], 'f')\n  exe \"caddexpr readfile('Xerr')\"\n  call assert_equal(\":caddexpr readfile('Xerr')\",\n\t\t\t\t\t\\ getqflist({'title' : 1}).title)\n\n  \" :cbuffer\n  new Xerr\n  exe \"cbuffer\"\n  call assert_equal(':cbuffer (Xerr)', getqflist({'title' : 1}).title)\n\n  \" :cgetbuffer\n  edit Xerr\n  exe \"cgetbuffer\"\n  call assert_equal(':cgetbuffer (Xerr)', getqflist({'title' : 1}).title)\n\n  \" :caddbuffer\n  call setqflist([], 'f')\n  edit Xerr\n  exe \"caddbuffer\"\n  call assert_equal(':caddbuffer (Xerr)', getqflist({'title' : 1}).title)\n\n  \" :cfile\n  exe \"cfile Xerr\"\n  call assert_equal(':cfile Xerr', getqflist({'title' : 1}).title)\n\n  \" :cgetfile\n  exe \"cgetfile Xerr\"\n  call assert_equal(':cgetfile Xerr', getqflist({'title' : 1}).title)\n\n  \" :caddfile\n  call setqflist([], 'f')\n  exe \"caddfile Xerr\"\n  call assert_equal(':caddfile Xerr', getqflist({'title' : 1}).title)\n\n  \" :grep\n  set grepprg=internal\n  exe \"grep F1 Xerr\"\n  call assert_equal(':grep F1 Xerr', getqflist({'title' : 1}).title)\n\n  \" :grepadd\n  call setqflist([], 'f')\n  exe \"grepadd F1 Xerr\"\n  call assert_equal(':grepadd F1 Xerr', getqflist({'title' : 1}).title)\n  set grepprg&vim\n\n  \" :vimgrep\n  exe \"vimgrep F1 Xerr\"\n  call assert_equal(':vimgrep F1 Xerr', getqflist({'title' : 1}).title)\n\n  \" :vimgrepadd\n  call setqflist([], 'f')\n  exe \"vimgrepadd F1 Xerr\"\n  call assert_equal(':vimgrepadd F1 Xerr', getqflist({'title' : 1}).title)\n\n  call setqflist(['F1:10:L10'], ' ')\n  call assert_equal(':setqflist()', getqflist({'title' : 1}).title)\n\n  call setqflist([], 'f')\n  call setqflist(['F1:10:L10'], 'a')\n  call assert_equal(':setqflist()', getqflist({'title' : 1}).title)\n\n  call setqflist([], 'f')\n  call setqflist(['F1:10:L10'], 'r')\n  call assert_equal(':setqflist()', getqflist({'title' : 1}).title)\n\n  close\n  call delete('Xerr')\n\n  call setqflist([], ' ', {'title' : 'Errors'})\n  copen\n  call assert_equal('Errors', w:quickfix_title)\n  call setqflist([], 'r', {'items' : [{'filename' : 'a.c', 'lnum' : 10}]})\n  call assert_equal('Errors', w:quickfix_title)\n  cclose\n\n  \" Switching to another quickfix list in one tab page should update the\n  \" quickfix window title and statusline in all the other tab pages also\n  call setqflist([], 'f')\n  %bw!\n  cgetexpr ['file_one:1:1: error in the first quickfix list']\n  call setqflist([], 'a', {'title': 'first quickfix list'})\n  cgetexpr ['file_two:2:1: error in the second quickfix list']\n  call setqflist([], 'a', {'title': 'second quickfix list'})\n  copen\n  wincmd t\n  tabnew two\n  copen\n  wincmd t\n  colder\n  call assert_equal('first quickfix list', gettabwinvar(1, 2, 'quickfix_title'))\n  call assert_equal('first quickfix list', gettabwinvar(2, 2, 'quickfix_title'))\n  call assert_equal(1, tabpagewinnr(1))\n  call assert_equal(1, tabpagewinnr(2))\n  tabnew\n  call setqflist([], 'a', {'title': 'new quickfix title'})\n  call assert_equal('new quickfix title', gettabwinvar(1, 2, 'quickfix_title'))\n  call assert_equal('new quickfix title', gettabwinvar(2, 2, 'quickfix_title'))\n  %bw!\nendfunc\n\nfunc Test_lbuffer_with_bwipe()\n  new\n  new\n  augroup nasty\n    au QuickFixCmdPre,QuickFixCmdPost,BufEnter,BufLeave * bwipe\n  augroup END\n  lbuffer\n  augroup nasty\n    au!\n  augroup END\nendfunc\n\n\" Test for an autocmd freeing the quickfix/location list when cexpr/lexpr is\n\" running\nfunc Xexpr_acmd_freelist(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" This was using freed memory (but with what events?)\n  augroup nasty\n    au QuickFixCmdPre,QuickFixCmdPost,BufEnter,BufLeave * call g:Xsetlist([], 'f')\n  augroup END\n  Xexpr \"x\"\n  augroup nasty\n    au!\n  augroup END\nendfunc\n\nfunc Test_cexpr_acmd_freelist()\n  call Xexpr_acmd_freelist('c')\n  call Xexpr_acmd_freelist('l')\nendfunc\n\n\" Test for commands that create a new quickfix/location list and jump to the\n\" first error automatically.\nfunc Xjumpto_first_error_test(cchar)\n  call s:setup_commands(a:cchar)\n\n  call s:create_test_file('Xtestfile1')\n  call s:create_test_file('Xtestfile2')\n  let l = ['Xtestfile1:2:Line2', 'Xtestfile2:4:Line4']\n\n  \" Test for cexpr/lexpr\n  enew\n  Xexpr l\n  call assert_equal('Xtestfile1', @%)\n  call assert_equal(2, line('.'))\n\n  \" Test for cfile/lfile\n  enew\n  call writefile(l, 'Xerr')\n  Xfile Xerr\n  call assert_equal('Xtestfile1', @%)\n  call assert_equal(2, line('.'))\n\n  \" Test for cbuffer/lbuffer\n  edit Xerr\n  Xbuffer\n  call assert_equal('Xtestfile1', @%)\n  call assert_equal(2, line('.'))\n\n  call delete('Xerr')\n  call delete('Xtestfile1')\n  call delete('Xtestfile2')\nendfunc\n\nfunc Test_jumpto_first_error()\n  call Xjumpto_first_error_test('c')\n  call Xjumpto_first_error_test('l')\nendfunc\n\n\" Test for a quickfix autocmd changing the quickfix/location list before\n\" jumping to the first error in the new list.\nfunc Xautocmd_changelist(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Test for cfile/lfile\n  call s:create_test_file('Xtestfile1')\n  call s:create_test_file('Xtestfile2')\n  Xexpr 'Xtestfile1:2:Line2'\n  autocmd QuickFixCmdPost * Xolder\n  call writefile(['Xtestfile2:4:Line4'], 'Xerr')\n  Xfile Xerr\n  call assert_equal('Xtestfile2', @%)\n  call assert_equal(4, line('.'))\n  autocmd! QuickFixCmdPost\n\n  \" Test for cbuffer/lbuffer\n  call g:Xsetlist([], 'f')\n  Xexpr 'Xtestfile1:2:Line2'\n  autocmd QuickFixCmdPost * Xolder\n  call writefile(['Xtestfile2:4:Line4'], 'Xerr')\n  edit Xerr\n  Xbuffer\n  call assert_equal('Xtestfile2', @%)\n  call assert_equal(4, line('.'))\n  autocmd! QuickFixCmdPost\n\n  \" Test for cexpr/lexpr\n  call g:Xsetlist([], 'f')\n  Xexpr 'Xtestfile1:2:Line2'\n  autocmd QuickFixCmdPost * Xolder\n  Xexpr 'Xtestfile2:4:Line4'\n  call assert_equal('Xtestfile2', @%)\n  call assert_equal(4, line('.'))\n  autocmd! QuickFixCmdPost\n\n  \" The grepprg may not be set on non-Unix systems\n  if has('unix')\n    \" Test for grep/lgrep\n    call g:Xsetlist([], 'f')\n    Xexpr 'Xtestfile1:2:Line2'\n    autocmd QuickFixCmdPost * Xolder\n    silent Xgrep Line5 Xtestfile2\n    call assert_equal('Xtestfile2', @%)\n    call assert_equal(5, line('.'))\n    autocmd! QuickFixCmdPost\n  endif\n\n  \" Test for vimgrep/lvimgrep\n  call g:Xsetlist([], 'f')\n  Xexpr 'Xtestfile1:2:Line2'\n  autocmd QuickFixCmdPost * Xolder\n  silent Xvimgrep Line5 Xtestfile2\n  call assert_equal('Xtestfile2', @%)\n  call assert_equal(5, line('.'))\n  autocmd! QuickFixCmdPost\n\n  \" Test for autocommands clearing the quickfix list before jumping to the\n  \" first error. This should not result in an error\n  autocmd QuickFixCmdPost * call g:Xsetlist([], 'r')\n  let v:errmsg = ''\n  \" Test for cfile/lfile\n  Xfile Xerr\n  call assert_true(v:errmsg !~# 'E42:')\n  \" Test for cbuffer/lbuffer\n  edit Xerr\n  Xbuffer\n  call assert_true(v:errmsg !~# 'E42:')\n  \" Test for cexpr/lexpr\n  Xexpr 'Xtestfile2:4:Line4'\n  call assert_true(v:errmsg !~# 'E42:')\n  \" Test for grep/lgrep\n  \" The grepprg may not be set on non-Unix systems\n  if has('unix')\n    silent Xgrep Line5 Xtestfile2\n    call assert_true(v:errmsg !~# 'E42:')\n  endif\n  \" Test for vimgrep/lvimgrep\n  call assert_fails('silent Xvimgrep Line5 Xtestfile2', 'E480:')\n  autocmd! QuickFixCmdPost\n\n  call delete('Xerr')\n  call delete('Xtestfile1')\n  call delete('Xtestfile2')\nendfunc\n\nfunc Test_autocmd_changelist()\n  call Xautocmd_changelist('c')\n  call Xautocmd_changelist('l')\nendfunc\n\n\" Tests for the ':filter /pat/ clist' command\nfunc Test_filter_clist()\n  cexpr ['Xfile1:10:10:Line 10', 'Xfile2:15:15:Line 15']\n  call assert_equal([' 2 Xfile2:15 col 15: Line 15'],\n\t\t\t\\ split(execute('filter /Line 15/ clist'), \"\\n\"))\n  call assert_equal([' 1 Xfile1:10 col 10: Line 10'],\n\t\t\t\\ split(execute('filter /Xfile1/ clist'), \"\\n\"))\n  call assert_equal([], split(execute('filter /abc/ clist'), \"\\n\"))\n\n  call setqflist([{'module' : 'abc', 'pattern' : 'pat1'},\n\t\t\t\\ {'module' : 'pqr', 'pattern' : 'pat2'}], ' ')\n  call assert_equal([' 2 pqr:pat2:  '],\n\t\t\t\\ split(execute('filter /pqr/ clist'), \"\\n\"))\n  call assert_equal([' 1 abc:pat1:  '],\n\t\t\t\\ split(execute('filter /pat1/ clist'), \"\\n\"))\nendfunc\n\n\" Tests for the \"CTRL-W <CR>\" command.\nfunc Xview_result_split_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Test that \"CTRL-W <CR>\" in a qf/ll window fails with empty list.\n  call g:Xsetlist([])\n  Xopen\n  let l:win_count = winnr('$')\n  call assert_fails('execute \"normal! \\<C-W>\\<CR>\"', 'E42:')\n  call assert_equal(l:win_count, winnr('$'))\n  Xclose\nendfunc\n\nfunc Test_view_result_split()\n  call Xview_result_split_tests('c')\n  call Xview_result_split_tests('l')\nendfunc\n\n\" Test that :cc sets curswant\nfunc Test_curswant()\n  helpgrep quickfix\n  normal! llll\n  1cc\n  call assert_equal(getcurpos()[4], virtcol('.'))\n  cclose | helpclose\nendfunc\n\n\" Test for opening a file from the quickfix window using CTRL-W <Enter>\n\" doesn't leave an empty buffer around.\nfunc Test_splitview()\n  call s:create_test_file('Xtestfile1')\n  call s:create_test_file('Xtestfile2')\n  new | only\n  let last_bufnr = bufnr('Test_sv_1', 1)\n  let l = ['Xtestfile1:2:Line2', 'Xtestfile2:4:Line4']\n  cgetexpr l\n  copen\n  let numbufs = len(getbufinfo())\n  exe \"normal \\<C-W>\\<CR>\"\n  copen\n  exe \"normal j\\<C-W>\\<CR>\"\n  \" Make sure new empty buffers are not created\n  call assert_equal(numbufs, len(getbufinfo()))\n  \" Creating a new buffer should use the next available buffer number\n  call assert_equal(last_bufnr + 4, bufnr(\"Test_sv_2\", 1))\n  bwipe Test_sv_1\n  bwipe Test_sv_2\n  new | only\n\n  \" When split opening files from location list window, make sure that two\n  \" windows doesn't refer to the same location list\n  lgetexpr l\n  let locid = getloclist(0, {'id' : 0}).id\n  lopen\n  exe \"normal \\<C-W>\\<CR>\"\n  call assert_notequal(locid, getloclist(0, {'id' : 0}).id)\n  call assert_equal(0, getloclist(0, {'winid' : 0}).winid)\n  new | only\n\n  \" When split opening files from a helpgrep location list window, a new help\n  \" window should be opened with a copy of the location list.\n  lhelpgrep window\n  let locid = getloclist(0, {'id' : 0}).id\n  lwindow\n  exe \"normal j\\<C-W>\\<CR>\"\n  call assert_notequal(locid, getloclist(0, {'id' : 0}).id)\n  call assert_equal(0, getloclist(0, {'winid' : 0}).winid)\n  new | only\n\n  \" Using :split or :vsplit from a quickfix window should behave like a :new\n  \" or a :vnew command\n  copen\n  split\n  call assert_equal(3, winnr('$'))\n  let l = getwininfo()\n  call assert_equal([0, 0, 1], [l[0].quickfix, l[1].quickfix, l[2].quickfix])\n  close\n  copen\n  vsplit\n  let l = getwininfo()\n  call assert_equal([0, 0, 1], [l[0].quickfix, l[1].quickfix, l[2].quickfix])\n  new | only\n\n  call delete('Xtestfile1')\n  call delete('Xtestfile2')\nendfunc\n\n\" Test for parsing entries using visual screen column\nfunc Test_viscol()\n  enew\n  call writefile([\"Col1\\tCol2\\tCol3\"], 'Xfile1')\n  edit Xfile1\n\n  \" Use byte offset for column number\n  set efm&\n  cexpr \"Xfile1:1:5:XX\\nXfile1:1:9:YY\\nXfile1:1:20:ZZ\"\n  call assert_equal([5, 8], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([9, 12], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([14, 20], [col('.'), virtcol('.')])\n\n  \" Use screen column offset for column number\n  set efm=%f:%l:%v:%m\n  cexpr \"Xfile1:1:8:XX\\nXfile1:1:12:YY\\nXfile1:1:20:ZZ\"\n  call assert_equal([5, 8], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([9, 12], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([14, 20], [col('.'), virtcol('.')])\n  cexpr \"Xfile1:1:6:XX\\nXfile1:1:15:YY\\nXfile1:1:24:ZZ\"\n  call assert_equal([5, 8], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([10, 16], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([14, 20], [col('.'), virtcol('.')])\n\n  enew\n  call writefile([\"Col1\\t\u00e4\u00fc\\t\u00f6\u00df\\tCol4\"], 'Xfile1')\n\n  \" Use byte offset for column number\n  set efm&\n  cexpr \"Xfile1:1:8:XX\\nXfile1:1:11:YY\\nXfile1:1:16:ZZ\"\n  call assert_equal([8, 10], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([11, 17], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([16, 25], [col('.'), virtcol('.')])\n\n  \" Use screen column offset for column number\n  set efm=%f:%l:%v:%m\n  cexpr \"Xfile1:1:10:XX\\nXfile1:1:17:YY\\nXfile1:1:25:ZZ\"\n  call assert_equal([8, 10], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([11, 17], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([16, 25], [col('.'), virtcol('.')])\n\n  \" Use screen column number with a multi-line error message\n  enew\n  call writefile([\"\u00e0 test\"], 'Xfile1')\n  set efm=%E===\\ %f\\ ===,%C%l:%v,%Z%m\n  cexpr [\"=== Xfile1 ===\", \"1:3\", \"errormsg\"]\n  call assert_equal('Xfile1', @%)\n  call assert_equal([0, 1, 4, 0], getpos('.'))\n\n  \" Repeat previous test with byte offset %c: ensure that fix to issue #7145\n  \" does not break this\n  set efm=%E===\\ %f\\ ===,%C%l:%c,%Z%m\n  cexpr [\"=== Xfile1 ===\", \"1:3\", \"errormsg\"]\n  call assert_equal('Xfile1', @%)\n  call assert_equal([0, 1, 3, 0], getpos('.'))\n\n  enew | only\n  set efm&\n  call delete('Xfile1')\nendfunc\n\n\" Test for the quickfix window buffer\nfunc Xqfbuf_test(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Quickfix buffer should be reused across closing and opening a quickfix\n  \" window\n  Xexpr \"F1:10:Line10\"\n  Xopen\n  let qfbnum = bufnr('')\n  Xclose\n  \" Even after the quickfix window is closed, the buffer should be loaded\n  call assert_true(bufloaded(qfbnum))\n  call assert_true(qfbnum, g:Xgetlist({'qfbufnr' : 0}).qfbufnr)\n  Xopen\n  \" Buffer should be reused when opening the window again\n  call assert_equal(qfbnum, bufnr(''))\n  Xclose\n\n  \" When quickfix buffer is wiped out, getqflist() should return 0\n  %bw!\n  Xexpr \"\"\n  Xopen\n  bw!\n  call assert_equal(0, g:Xgetlist({'qfbufnr': 0}).qfbufnr)\n\n  if a:cchar == 'l'\n    %bwipe\n    \" For a location list, when both the file window and the location list\n    \" window for the list are closed, then the buffer should be freed.\n    new | only\n    lexpr \"F1:10:Line10\"\n    let wid = win_getid()\n    lopen\n    let qfbnum = bufnr('')\n    call assert_match(qfbnum . ' %a-  \"\\[Location List]\"', execute('ls'))\n    close\n    \" When the location list window is closed, the buffer name should not\n    \" change to 'Quickfix List'\n    call assert_match(qfbnum . 'u h-  \"\\[Location List]\"', execute('ls!'))\n    call assert_true(bufloaded(qfbnum))\n\n    \" After deleting a location list buffer using \":bdelete\", opening the\n    \" location list window should mark the buffer as a location list buffer.\n    exe \"bdelete \" . qfbnum\n    lopen\n    call assert_equal(\"quickfix\", &buftype)\n    call assert_equal(1, getwininfo(win_getid(winnr()))[0].loclist)\n    call assert_equal(wid, getloclist(0, {'filewinid' : 0}).filewinid)\n    call assert_false(&swapfile)\n    lclose\n\n    \" When the location list is cleared for the window, the buffer should be\n    \" removed\n    call setloclist(0, [], 'f')\n    call assert_false(bufexists(qfbnum))\n    call assert_equal(0, getloclist(0, {'qfbufnr' : 0}).qfbufnr)\n\n    \" When the location list is freed with the location list window open, the\n    \" location list buffer should not be lost. It should be reused when the\n    \" location list is again populated.\n    lexpr \"F1:10:Line10\"\n    lopen\n    let wid = win_getid()\n    let qfbnum = bufnr('')\n    wincmd p\n    call setloclist(0, [], 'f')\n    lexpr \"F1:10:Line10\"\n    lopen\n    call assert_equal(wid, win_getid())\n    call assert_equal(qfbnum, bufnr(''))\n    lclose\n\n    \" When the window with the location list is closed, the buffer should be\n    \" removed\n    new | only\n    call assert_false(bufexists(qfbnum))\n  endif\nendfunc\n\nfunc Test_qfbuf()\n  call Xqfbuf_test('c')\n  call Xqfbuf_test('l')\nendfunc\n\n\" If there is an autocmd to use only one window, then opening the location\n\" list window used to crash Vim.\nfunc Test_winonly_autocmd()\n  call s:create_test_file('Xtest1')\n  \" Autocmd to show only one Vim window at a time\n  autocmd WinEnter * only\n  new\n  \" Load the location list\n  lexpr \"Xtest1:5:Line5\\nXtest1:10:Line10\\nXtest1:15:Line15\"\n  let loclistid = getloclist(0, {'id' : 0}).id\n  \" Open the location list window. Only this window will be shown and the file\n  \" window is closed.\n  lopen\n  call assert_equal(loclistid, getloclist(0, {'id' : 0}).id)\n  \" Jump to an entry in the location list and make sure that the cursor is\n  \" positioned correctly.\n  ll 3\n  call assert_equal(loclistid, getloclist(0, {'id' : 0}).id)\n  call assert_equal('Xtest1', @%)\n  call assert_equal(15, line('.'))\n  \" Cleanup\n  autocmd! WinEnter\n  new | only\n  call delete('Xtest1')\nendfunc\n\n\" Test to make sure that an empty quickfix buffer is not reused for loading\n\" a normal buffer.\nfunc Test_empty_qfbuf()\n  enew | only\n  call writefile([\"Test\"], 'Xfile1')\n  call setqflist([], 'f')\n  copen | only\n  let qfbuf = bufnr('')\n  edit Xfile1\n  call assert_notequal(qfbuf, bufnr(''))\n  enew\n  call delete('Xfile1')\nendfunc\n\n\" Test for the :cbelow, :cabove, :lbelow and :labove commands.\n\" And for the :cafter, :cbefore, :lafter and :lbefore commands.\nfunc Xtest_below(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" No quickfix/location list\n  call assert_fails('Xbelow', 'E42:')\n  call assert_fails('Xabove', 'E42:')\n  call assert_fails('Xbefore', 'E42:')\n  call assert_fails('Xafter', 'E42:')\n\n  \" Empty quickfix/location list\n  call g:Xsetlist([])\n  call assert_fails('Xbelow', 'E42:')\n  call assert_fails('Xabove', 'E42:')\n  call assert_fails('Xbefore', 'E42:')\n  call assert_fails('Xafter', 'E42:')\n\n  call s:create_test_file('X1')\n  call s:create_test_file('X2')\n  call s:create_test_file('X3')\n  call s:create_test_file('X4')\n\n  \" Invalid entries\n  edit X1\n  call g:Xsetlist([\"E1\", \"E2\"])\n  call assert_fails('Xbelow', 'E42:')\n  call assert_fails('Xabove', 'E42:')\n  call assert_fails('3Xbelow', 'E42:')\n  call assert_fails('4Xabove', 'E42:')\n  call assert_fails('Xbefore', 'E42:')\n  call assert_fails('Xafter', 'E42:')\n  call assert_fails('3Xbefore', 'E42:')\n  call assert_fails('4Xafter', 'E42:')\n\n  \" Test the commands with various arguments\n  Xexpr [\"X1:5:3:L5\", \"X2:5:2:L5\", \"X2:10:3:L10\", \"X2:15:4:L15\", \"X3:3:5:L3\"]\n  edit +7 X2\n  Xabove\n  call assert_equal(['X2', 5], [@%, line('.')])\n  call assert_fails('Xabove', 'E553:')\n  normal 7G\n  Xbefore\n  call assert_equal(['X2', 5, 2], [@%, line('.'), col('.')])\n  call assert_fails('Xbefore', 'E553:')\n\n  normal 2j\n  Xbelow\n  call assert_equal(['X2', 10], [@%, line('.')])\n  normal 7G\n  Xafter\n  call assert_equal(['X2', 10, 3], [@%, line('.'), col('.')])\n\n  \" Last error in this file\n  Xbelow 99\n  call assert_equal(['X2', 15], [@%, line('.')])\n  call assert_fails('Xbelow', 'E553:')\n  normal gg\n  Xafter 99\n  call assert_equal(['X2', 15, 4], [@%, line('.'), col('.')])\n  call assert_fails('Xafter', 'E553:')\n\n  \" First error in this file\n  Xabove 99\n  call assert_equal(['X2', 5], [@%, line('.')])\n  call assert_fails('Xabove', 'E553:')\n  normal G\n  Xbefore 99\n  call assert_equal(['X2', 5, 2], [@%, line('.'), col('.')])\n  call assert_fails('Xbefore', 'E553:')\n\n  normal gg\n  Xbelow 2\n  call assert_equal(['X2', 10], [@%, line('.')])\n  normal gg\n  Xafter 2\n  call assert_equal(['X2', 10, 3], [@%, line('.'), col('.')])\n\n  normal G\n  Xabove 2\n  call assert_equal(['X2', 10], [@%, line('.')])\n  normal G\n  Xbefore 2\n  call assert_equal(['X2', 10, 3], [@%, line('.'), col('.')])\n\n  edit X4\n  call assert_fails('Xabove', 'E42:')\n  call assert_fails('Xbelow', 'E42:')\n  call assert_fails('Xbefore', 'E42:')\n  call assert_fails('Xafter', 'E42:')\n  if a:cchar == 'l'\n    \" If a buffer has location list entries from some other window but not\n    \" from the current window, then the commands should fail.\n    edit X1 | split | call setloclist(0, [], 'f')\n    call assert_fails('Xabove', 'E776:')\n    call assert_fails('Xbelow', 'E776:')\n    call assert_fails('Xbefore', 'E776:')\n    call assert_fails('Xafter', 'E776:')\n    close\n  endif\n\n  \" Test for lines with multiple quickfix entries\n  let lines =<< trim END\n    X1:5:L5\n    X2:5:1:L5_1\n    X2:5:2:L5_2\n    X2:5:3:L5_3\n    X2:10:1:L10_1\n    X2:10:2:L10_2\n    X2:10:3:L10_3\n    X2:15:1:L15_1\n    X2:15:2:L15_2\n    X2:15:3:L15_3\n    X3:3:L3\n  END\n  Xexpr lines\n  edit +1 X2\n  Xbelow 2\n  call assert_equal(['X2', 10, 1], [@%, line('.'), col('.')])\n  normal 1G\n  Xafter 2\n  call assert_equal(['X2', 5, 2], [@%, line('.'), col('.')])\n\n  normal gg\n  Xbelow 99\n  call assert_equal(['X2', 15, 1], [@%, line('.'), col('.')])\n  normal gg\n  Xafter 99\n  call assert_equal(['X2', 15, 3], [@%, line('.'), col('.')])\n\n  normal G\n  Xabove 2\n  call assert_equal(['X2', 10, 1], [@%, line('.'), col('.')])\n  normal G\n  Xbefore 2\n  call assert_equal(['X2', 15, 2], [@%, line('.'), col('.')])\n\n  normal G\n  Xabove 99\n  call assert_equal(['X2', 5, 1], [@%, line('.'), col('.')])\n  normal G\n  Xbefore 99\n  call assert_equal(['X2', 5, 1], [@%, line('.'), col('.')])\n\n  normal 10G\n  Xabove\n  call assert_equal(['X2', 5, 1], [@%, line('.'), col('.')])\n  normal 10G$\n  2Xbefore\n  call assert_equal(['X2', 10, 2], [@%, line('.'), col('.')])\n\n  normal 10G\n  Xbelow\n  call assert_equal(['X2', 15, 1], [@%, line('.'), col('.')])\n  normal 9G\n  5Xafter\n  call assert_equal(['X2', 15, 2], [@%, line('.'), col('.')])\n\n  \" Invalid range\n  if a:cchar == 'c'\n    call assert_fails('-2cbelow', 'E16:')\n    call assert_fails('-2cafter', 'E16:')\n  else\n    call assert_fails('-2lbelow', 'E16:')\n    call assert_fails('-2lafter', 'E16:')\n  endif\n\n  call delete('X1')\n  call delete('X2')\n  call delete('X3')\n  call delete('X4')\nendfunc\n\nfunc Test_cbelow()\n  call Xtest_below('c')\n  call Xtest_below('l')\nendfunc\n\nfunc Test_quickfix_count()\n  let commands =<< trim END\n    cNext\n    cNfile\n    cabove\n    cbelow\n    cfirst\n    clast\n    cnewer\n    cnext\n    cnfile\n    colder\n    cprevious\n    crewind\n    lNext\n    lNfile\n    labove\n    lbelow\n    lfirst\n    llast\n    lnewer\n    lnext\n    lnfile\n    lolder\n    lprevious\n    lrewind\n  END\n  for cmd in commands\n    call assert_fails('-1' .. cmd, 'E16:')\n    call assert_fails('.' .. cmd, 'E16:')\n    call assert_fails('%' .. cmd, 'E16:')\n    call assert_fails('$' .. cmd, 'E16:')\n  endfor\nendfunc\n\n\" Test for aborting quickfix commands using QuickFixCmdPre\nfunc Xtest_qfcmd_abort(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n\n  \" cexpr/lexpr\n  let e = ''\n  try\n    Xexpr [\"F1:10:Line10\", \"F2:20:Line20\"]\n  catch /.*/\n    let e = v:exception\n  endtry\n  call assert_equal('AbortCmd', e)\n  call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\n\n  \" cfile/lfile\n  call writefile([\"F1:10:Line10\", \"F2:20:Line20\"], 'Xfile1')\n  let e = ''\n  try\n    Xfile Xfile1\n  catch /.*/\n    let e = v:exception\n  endtry\n  call assert_equal('AbortCmd', e)\n  call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\n  call delete('Xfile1')\n\n  \" cgetbuffer/lgetbuffer\n  enew!\n  call append(0, [\"F1:10:Line10\", \"F2:20:Line20\"])\n  let e = ''\n  try\n    Xgetbuffer\n  catch /.*/\n    let e = v:exception\n  endtry\n  call assert_equal('AbortCmd', e)\n  call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\n  enew!\n\n  \" vimgrep/lvimgrep\n  let e = ''\n  try\n    Xvimgrep /func/ test_quickfix.vim\n  catch /.*/\n    let e = v:exception\n  endtry\n  call assert_equal('AbortCmd', e)\n  call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\n\n  \" helpgrep/lhelpgrep\n  let e = ''\n  try\n    Xhelpgrep quickfix\n  catch /.*/\n    let e = v:exception\n  endtry\n  call assert_equal('AbortCmd', e)\n  call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\n\n  \" grep/lgrep\n  if has('unix')\n    let e = ''\n    try\n      silent Xgrep func test_quickfix.vim\n    catch /.*/\n      let e = v:exception\n    endtry\n    call assert_equal('AbortCmd', e)\n    call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\n  endif\nendfunc\n\nfunc Test_qfcmd_abort()\n  augroup QF_Test\n    au!\n    autocmd  QuickFixCmdPre * throw \"AbortCmd\"\n  augroup END\n\n  call Xtest_qfcmd_abort('c')\n  call Xtest_qfcmd_abort('l')\n\n  augroup QF_Test\n    au!\n  augroup END\nendfunc\n\n\" Test for using a file in one of the parent directories.\nfunc Test_search_in_dirstack()\n  call mkdir('Xtestdir/a/b/c', 'p')\n  let save_cwd = getcwd()\n  call writefile([\"X1_L1\", \"X1_L2\"], 'Xtestdir/Xfile1')\n  call writefile([\"X2_L1\", \"X2_L2\"], 'Xtestdir/a/Xfile2')\n  call writefile([\"X3_L1\", \"X3_L2\"], 'Xtestdir/a/b/Xfile3')\n  call writefile([\"X4_L1\", \"X4_L2\"], 'Xtestdir/a/b/c/Xfile4')\n\n  let lines = \"Entering dir Xtestdir\\n\" .\n\t      \\ \"Entering dir a\\n\" .\n\t      \\ \"Entering dir b\\n\" .\n\t      \\ \"Xfile2:2:X2_L2\\n\" .\n\t      \\ \"Leaving dir a\\n\" .\n\t      \\ \"Xfile1:2:X1_L2\\n\" .\n\t      \\ \"Xfile3:1:X3_L1\\n\" .\n\t      \\ \"Entering dir c\\n\" .\n\t      \\ \"Xfile4:2:X4_L2\\n\" .\n\t      \\ \"Leaving dir c\\n\"\n  set efm=%DEntering\\ dir\\ %f,%XLeaving\\ dir\\ %f,%f:%l:%m\n  cexpr lines .. \"Leaving dir Xtestdir|\\n\" | let next = 1\n  call assert_equal(11, getqflist({'size' : 0}).size)\n  call assert_equal(4, getqflist({'idx' : 0}).idx)\n  call assert_equal('X2_L2', getline('.'))\n  call assert_equal(1, next)\n  cnext\n  call assert_equal(6, getqflist({'idx' : 0}).idx)\n  call assert_equal('X1_L2', getline('.'))\n  cnext\n  call assert_equal(7, getqflist({'idx' : 0}).idx)\n  call assert_equal(1, line('$'))\n  call assert_equal('', getline(1))\n  cnext\n  call assert_equal(9, getqflist({'idx' : 0}).idx)\n  call assert_equal(1, line('$'))\n  call assert_equal('', getline(1))\n\n  set efm&\n  exe 'cd ' . save_cwd\n  call delete('Xtestdir', 'rf')\nendfunc\n\n\" Test for :cquit\nfunc Test_cquit()\n  \" Exit Vim with a non-zero value\n  if RunVim([], [\"cquit 7\"], '')\n    call assert_equal(7, v:shell_error)\n  endif\n\n  if RunVim([], [\"50cquit\"], '')\n    call assert_equal(50, v:shell_error)\n  endif\n\n  \" Exit Vim with default value\n  if RunVim([], [\"cquit\"], '')\n    call assert_equal(1, v:shell_error)\n  endif\n\n  \" Exit Vim with zero value\n  if RunVim([], [\"cquit 0\"], '')\n    call assert_equal(0, v:shell_error)\n  endif\n\n  \" Exit Vim with negative value\n  call assert_fails('-3cquit', 'E16:')\nendfunc\n\n\" Test for getting a specific item from a quickfix list\nfunc Xtest_getqflist_by_idx(cchar)\n  call s:setup_commands(a:cchar)\n  \" Empty list\n  call assert_equal([], g:Xgetlist({'idx' : 1, 'items' : 0}).items)\n  Xexpr ['F1:10:L10', 'F1:20:L20']\n  let l = g:Xgetlist({'idx' : 2, 'items' : 0}).items\n  call assert_equal(bufnr('F1'), l[0].bufnr)\n  call assert_equal(20, l[0].lnum)\n  call assert_equal('L20', l[0].text)\n  call assert_equal([], g:Xgetlist({'idx' : -1, 'items' : 0}).items)\n  call assert_equal([], g:Xgetlist({'idx' : 3, 'items' : 0}).items)\n  call assert_equal({}, g:Xgetlist(#{idx: \"abc\"}))\n  %bwipe!\nendfunc\n\nfunc Test_getqflist_by_idx()\n  call Xtest_getqflist_by_idx('c')\n  call Xtest_getqflist_by_idx('l')\nendfunc\n\n\" Test for the 'quickfixtextfunc' setting\nfunc Tqfexpr(info)\n  if a:info.quickfix\n    let qfl = getqflist({'id' : a:info.id, 'items' : 1}).items\n  else\n    let qfl = getloclist(a:info.winid, {'id' : a:info.id, 'items' : 1}).items\n  endif\n\n  let l = []\n  for idx in range(a:info.start_idx - 1, a:info.end_idx - 1)\n    let e = qfl[idx]\n    let s = ''\n    if e.bufnr != 0\n      let bname = bufname(e.bufnr)\n      let s ..= fnamemodify(bname, ':.')\n    endif\n    let s ..= '-'\n    let s ..= 'L' .. string(e.lnum) .. 'C' .. string(e.col) .. '-'\n    let s ..= e.text\n    call add(l, s)\n  endfor\n\n  return l\nendfunc\n\nfunc Xtest_qftextfunc(cchar)\n  call s:setup_commands(a:cchar)\n\n  set efm=%f:%l:%c:%m\n  set quickfixtextfunc=Tqfexpr\n  call assert_equal('Tqfexpr', &quickfixtextfunc)\n  call assert_equal('',\n        \\ g:Xgetlist({'quickfixtextfunc' : 1}).quickfixtextfunc)\n  call g:Xsetlist([\n        \\ { 'filename': 'F1', 'lnum': 10, 'col': 2,\n        \\   'end_col': 7, 'text': 'green'},\n        \\ { 'filename': 'F1', 'lnum': 20, 'end_lnum': 25, 'col': 4,\n        \\   'end_col': 8, 'text': 'blue'},\n        \\ ])\n\n  Xwindow\n  call assert_equal('F1-L10C2-green', getline(1))\n  call assert_equal('F1-L20C4-blue', getline(2))\n  Xclose\n  set quickfixtextfunc&vim\n  Xwindow\n  call assert_equal('F1|10 col 2-7| green', getline(1))\n  call assert_equal('F1|20-25 col 4-8| blue', getline(2))\n  Xclose\n\n  set efm=%f:%l:%c:%m\n  set quickfixtextfunc=Tqfexpr\n  \" Update the list with only the cwindow\n  Xwindow\n  only\n  call g:Xsetlist([\n        \\ { 'filename': 'F2', 'lnum': 20, 'col': 2,\n        \\   'end_col': 7, 'text': 'red'}\n        \\ ])\n  call assert_equal(['F2-L20C2-red'], getline(1, '$'))\n  new\n  Xclose\n  set efm&\n  set quickfixtextfunc&\n\n  \" Test for per list 'quickfixtextfunc' setting\n  func PerQfText(info)\n    if a:info.quickfix\n      let qfl = getqflist({'id' : a:info.id, 'items' : 1}).items\n    else\n      let qfl = getloclist(a:info.winid, {'id' : a:info.id, 'items' : 1}).items\n    endif\n    if empty(qfl)\n      return []\n    endif\n    let l = []\n    for idx in range(a:info.start_idx - 1, a:info.end_idx - 1)\n      call add(l, 'Line ' .. qfl[idx].lnum .. ', Col ' .. qfl[idx].col)\n    endfor\n    return l\n  endfunc\n  set quickfixtextfunc=Tqfexpr\n  call g:Xsetlist([], ' ', {'quickfixtextfunc' : \"PerQfText\"})\n  Xaddexpr ['F1:10:2:green', 'F1:20:4:blue']\n  Xwindow\n  call assert_equal('Line 10, Col 2', getline(1))\n  call assert_equal('Line 20, Col 4', getline(2))\n  Xclose\n  call assert_equal(function('PerQfText'),\n        \\ g:Xgetlist({'quickfixtextfunc' : 1}).quickfixtextfunc)\n  \" Add entries to the list when the quickfix buffer is hidden\n  Xaddexpr ['F1:30:6:red']\n  Xwindow\n  call assert_equal('Line 30, Col 6', getline(3))\n  Xclose\n  call g:Xsetlist([], 'r', {'quickfixtextfunc' : ''})\n  call assert_equal('', g:Xgetlist({'quickfixtextfunc' : 1}).quickfixtextfunc)\n  set quickfixtextfunc&\n  delfunc PerQfText\n\n  \" Non-existing function\n  set quickfixtextfunc=Tabc\n  call assert_fails(\"Xexpr ['F1:10:2:green', 'F1:20:4:blue']\", 'E117:')\n  call assert_fails(\"Xwindow\", 'E117:')\n  Xclose\n  set quickfixtextfunc&\n\n  \" set option to a non-function\n  set quickfixtextfunc=[10,\\ 20]\n  call assert_fails(\"Xexpr ['F1:10:2:green', 'F1:20:4:blue']\", 'E117:')\n  call assert_fails(\"Xwindow\", 'E117:')\n  Xclose\n  set quickfixtextfunc&\n\n  \" set option to a function with different set of arguments\n  func Xqftext(a, b, c)\n    return a:a .. a:b .. a:c\n  endfunc\n  set quickfixtextfunc=Xqftext\n  call assert_fails(\"Xexpr ['F1:10:2:green', 'F1:20:4:blue']\", 'E119:')\n  call assert_fails(\"Xwindow\", 'E119:')\n  Xclose\n\n  \" set option to a function that returns a list with non-strings\n  func Xqftext2(d)\n    return ['one', [], 'two']\n  endfunc\n  set quickfixtextfunc=Xqftext2\n  call assert_fails(\"Xexpr ['F1:10:2:green', 'F1:20:4:blue', 'F1:30:6:red']\",\n                                                                  \\ 'E730:')\n  call assert_fails('Xwindow', 'E730:')\n  call assert_equal(['one', 'F1|20 col 4| blue', 'F1|30 col 6| red'],\n        \\ getline(1, '$'))\n  Xclose\n\n  set quickfixtextfunc&\n  delfunc Xqftext\n  delfunc Xqftext2\n\n  \" set the global option to a lambda function\n  set quickfixtextfunc={d\\ ->\\ map(g:Xgetlist({'id'\\ :\\ d.id,\\ 'items'\\ :\\ 1}).items[d.start_idx-1:d.end_idx-1],\\ 'v:val.text')}\n  Xexpr ['F1:10:2:green', 'F1:20:4:blue']\n  Xwindow\n  call assert_equal(['green', 'blue'], getline(1, '$'))\n  Xclose\n  call assert_equal(\"{d -> map(g:Xgetlist({'id' : d.id, 'items' : 1}).items[d.start_idx-1:d.end_idx-1], 'v:val.text')}\", &quickfixtextfunc)\n  set quickfixtextfunc&\n\n  \" use a lambda function that returns an empty list\n  set quickfixtextfunc={d\\ ->\\ []}\n  Xexpr ['F1:10:2:green', 'F1:20:4:blue']\n  Xwindow\n  call assert_equal(['F1|10 col 2| green', 'F1|20 col 4| blue'],\n        \\ getline(1, '$'))\n  Xclose\n  set quickfixtextfunc&\n\n  \" use a lambda function that returns a list with empty strings\n  set quickfixtextfunc={d\\ ->\\ ['',\\ '']}\n  Xexpr ['F1:10:2:green', 'F1:20:4:blue']\n  Xwindow\n  call assert_equal(['F1|10 col 2| green', 'F1|20 col 4| blue'],\n        \\ getline(1, '$'))\n  Xclose\n  set quickfixtextfunc&\n\n  \" set the per-quickfix list text function to a lambda function\n  call g:Xsetlist([], ' ',\n        \\ {'quickfixtextfunc' :\n        \\   {d -> map(g:Xgetlist({'id' : d.id, 'items' : 1}).items[d.start_idx-1:d.end_idx-1],\n        \\ \"'Line ' .. v:val.lnum .. ', Col ' .. v:val.col\")}})\n  Xaddexpr ['F1:10:2:green', 'F1:20:4:blue']\n  Xwindow\n  call assert_equal('Line 10, Col 2', getline(1))\n  call assert_equal('Line 20, Col 4', getline(2))\n  Xclose\n  call assert_match(\"function('<lambda>\\\\d\\\\+')\", string(g:Xgetlist({'quickfixtextfunc' : 1}).quickfixtextfunc))\n  call g:Xsetlist([], 'f')\nendfunc\n\nfunc Test_qftextfunc()\n  call Xtest_qftextfunc('c')\n  call Xtest_qftextfunc('l')\nendfunc\n\nfunc Test_qftextfunc_callback()\n  let lines =<< trim END\n    set efm=%f:%l:%c:%m\n\n    #\" Test for using a function name\n    LET &qftf = 'g:Tqfexpr'\n    cexpr \"F0:0:0:L0\"\n    copen\n    call assert_equal('F0-L0C0-L0', getline(1))\n    cclose\n\n    #\" Test for using a function()\n    set qftf=function('g:Tqfexpr')\n    cexpr \"F1:1:1:L1\"\n    copen\n    call assert_equal('F1-L1C1-L1', getline(1))\n    cclose\n\n    #\" Using a funcref variable to set 'quickfixtextfunc'\n    VAR Fn = function('g:Tqfexpr')\n    LET &qftf = Fn\n    cexpr \"F2:2:2:L2\"\n    copen\n    call assert_equal('F2-L2C2-L2', getline(1))\n    cclose\n\n    #\" Using string(funcref_variable) to set 'quickfixtextfunc'\n    LET Fn = function('g:Tqfexpr')\n    LET &qftf = string(Fn)\n    cexpr \"F3:3:3:L3\"\n    copen\n    call assert_equal('F3-L3C3-L3', getline(1))\n    cclose\n\n    #\" Test for using a funcref()\n    set qftf=funcref('g:Tqfexpr')\n    cexpr \"F4:4:4:L4\"\n    copen\n    call assert_equal('F4-L4C4-L4', getline(1))\n    cclose\n\n    #\" Using a funcref variable to set 'quickfixtextfunc'\n    LET Fn = funcref('g:Tqfexpr')\n    LET &qftf = Fn\n    cexpr \"F5:5:5:L5\"\n    copen\n    call assert_equal('F5-L5C5-L5', getline(1))\n    cclose\n\n    #\" Using a string(funcref_variable) to set 'quickfixtextfunc'\n    LET Fn = funcref('g:Tqfexpr')\n    LET &qftf = string(Fn)\n    cexpr \"F5:5:5:L5\"\n    copen\n    call assert_equal('F5-L5C5-L5', getline(1))\n    cclose\n\n    #\" Test for using a lambda function with set\n    VAR optval = \"LSTART a LMIDDLE g:Tqfexpr(a) LEND\"\n    LET optval = substitute(optval, ' ', '\\\\ ', 'g')\n    exe \"set qftf=\" .. optval\n    cexpr \"F6:6:6:L6\"\n    copen\n    call assert_equal('F6-L6C6-L6', getline(1))\n    cclose\n\n    #\" Set 'quickfixtextfunc' to a lambda expression\n    LET &qftf = LSTART a LMIDDLE g:Tqfexpr(a) LEND\n    cexpr \"F7:7:7:L7\"\n    copen\n    call assert_equal('F7-L7C7-L7', getline(1))\n    cclose\n\n    #\" Set 'quickfixtextfunc' to string(lambda_expression)\n    LET &qftf = \"LSTART a LMIDDLE g:Tqfexpr(a) LEND\"\n    cexpr \"F8:8:8:L8\"\n    copen\n    call assert_equal('F8-L8C8-L8', getline(1))\n    cclose\n\n    #\" Set 'quickfixtextfunc' to a variable with a lambda expression\n    VAR Lambda = LSTART a LMIDDLE g:Tqfexpr(a) LEND\n    LET &qftf = Lambda\n    cexpr \"F9:9:9:L9\"\n    copen\n    call assert_equal('F9-L9C9-L9', getline(1))\n    cclose\n\n    #\" Set 'quickfixtextfunc' to a string(variable with a lambda expression)\n    LET Lambda = LSTART a LMIDDLE g:Tqfexpr(a) LEND\n    LET &qftf = string(Lambda)\n    cexpr \"F9:9:9:L9\"\n    copen\n    call assert_equal('F9-L9C9-L9', getline(1))\n    cclose\n  END\n  call v9.CheckLegacyAndVim9Success(lines)\n\n  \" Test for using a script-local function name\n  func s:TqfFunc2(info)\n    let g:TqfFunc2Args = [a:info.start_idx, a:info.end_idx]\n    return ''\n  endfunc\n  let g:TqfFunc2Args = []\n  set quickfixtextfunc=s:TqfFunc2\n  cexpr \"F10:10:10:L10\"\n  cclose\n  call assert_equal([1, 1], g:TqfFunc2Args)\n\n  let &quickfixtextfunc = 's:TqfFunc2'\n  cexpr \"F11:11:11:L11\"\n  cclose\n  call assert_equal([1, 1], g:TqfFunc2Args)\n  delfunc s:TqfFunc2\n\n  \" set 'quickfixtextfunc' to a partial with dict. This used to cause a crash.\n  func SetQftfFunc()\n    let params = {'qftf': function('g:DictQftfFunc')}\n    let &quickfixtextfunc = params.qftf\n  endfunc\n  func g:DictQftfFunc(_) dict\n  endfunc\n  call SetQftfFunc()\n  new\n  call SetQftfFunc()\n  bw\n  call test_garbagecollect_now()\n  new\n  set qftf=\n  wincmd w\n  set qftf=\n  :%bw!\n\n  \" set per-quickfix list 'quickfixtextfunc' to a partial with dict. This used\n  \" to cause a crash.\n  let &qftf = ''\n  func SetLocalQftfFunc()\n    let params = {'qftf': function('g:DictQftfFunc')}\n    call setqflist([], 'a', {'quickfixtextfunc' : params.qftf})\n  endfunc\n  call SetLocalQftfFunc()\n  call test_garbagecollect_now()\n  call setqflist([], 'a', {'quickfixtextfunc' : ''})\n  delfunc g:DictQftfFunc\n  delfunc SetQftfFunc\n  delfunc SetLocalQftfFunc\n  set efm&\nendfunc\n\n\" Test for updating a location list for some other window and check that\n\" 'qftextfunc' uses the correct location list.\nfunc Test_qftextfunc_other_loclist()\n  %bw!\n  call setloclist(0, [], 'f')\n\n  \" create a window and a location list for it and open the location list\n  \" window\n  lexpr ['F1:10:12:one', 'F1:20:14:two']\n  let w1_id = win_getid()\n  call setloclist(0, [], ' ',\n        \\ {'lines': ['F1:10:12:one', 'F1:20:14:two'],\n        \\  'quickfixtextfunc':\n        \\    {d -> map(getloclist(d.winid, {'id' : d.id,\n        \\                'items' : 1}).items[d.start_idx-1:d.end_idx-1],\n        \\          \"'Line ' .. v:val.lnum .. ', Col ' .. v:val.col\")}})\n  lwindow\n  let w2_id = win_getid()\n\n  \" create another window and a location list for it and open the location\n  \" list window\n  topleft new\n  let w3_id = win_getid()\n  call setloclist(0, [], ' ',\n        \\ {'lines': ['F2:30:32:eleven', 'F2:40:34:twelve'],\n        \\  'quickfixtextfunc':\n        \\    {d -> map(getloclist(d.winid, {'id' : d.id,\n        \\                'items' : 1}).items[d.start_idx-1:d.end_idx-1],\n        \\          \"'Ligne ' .. v:val.lnum .. ', Colonne ' .. v:val.col\")}})\n  lwindow\n  let w4_id = win_getid()\n\n  topleft new\n  lexpr ['F3:50:52:green', 'F3:60:54:blue']\n  let w5_id = win_getid()\n\n  \" change the location list for some other window\n  call setloclist(0, [], 'r', {'lines': ['F3:55:56:aaa', 'F3:57:58:bbb']})\n  call setloclist(w1_id, [], 'r', {'lines': ['F1:62:63:bbb', 'F1:64:65:ccc']})\n  call setloclist(w3_id, [], 'r', {'lines': ['F2:76:77:ddd', 'F2:78:79:eee']})\n  call assert_equal(['Line 62, Col 63', 'Line 64, Col 65'],\n        \\ getbufline(winbufnr(w2_id), 1, '$'))\n  call assert_equal(['Ligne 76, Colonne 77', 'Ligne 78, Colonne 79'],\n        \\ getbufline(winbufnr(w4_id), 1, '$'))\n  call setloclist(w2_id, [], 'r', {'lines': ['F1:32:33:fff', 'F1:34:35:ggg']})\n  call setloclist(w4_id, [], 'r', {'lines': ['F2:46:47:hhh', 'F2:48:49:jjj']})\n  call assert_equal(['Line 32, Col 33', 'Line 34, Col 35'],\n        \\ getbufline(winbufnr(w2_id), 1, '$'))\n  call assert_equal(['Ligne 46, Colonne 47', 'Ligne 48, Colonne 49'],\n        \\ getbufline(winbufnr(w4_id), 1, '$'))\n\n  call win_gotoid(w5_id)\n  lwindow\n  call assert_equal(['F3|55 col 56| aaa', 'F3|57 col 58| bbb'],\n        \\ getline(1, '$'))\n  %bw!\nendfunc\n\n\" Running :lhelpgrep command more than once in a help window, doesn't jump to\n\" the help topic\nfunc Test_lhelpgrep_from_help_window()\n  call mkdir('Xtestdir/doc', 'p')\n  call writefile(['window'], 'Xtestdir/doc/a.txt')\n  call writefile(['buffer'], 'Xtestdir/doc/b.txt')\n  let save_rtp = &rtp\n  let &rtp = 'Xtestdir'\n  lhelpgrep window\n  lhelpgrep buffer\n  call assert_equal('b.txt', fnamemodify(@%, \":p:t\"))\n  lhelpgrep window\n  call assert_equal('a.txt', fnamemodify(@%, \":p:t\"))\n  let &rtp = save_rtp\n  call delete('Xtestdir', 'rf')\n  new | only!\nendfunc\n\n\" Test for the crash fixed by 7.3.715\nfunc Test_setloclist_crash()\n  %bw!\n  let g:BufNum = bufnr()\n  augroup QF_Test\n    au!\n    au BufUnload * call setloclist(0, [{'bufnr':g:BufNum, 'lnum':1, 'col':1, 'text': 'tango down'}])\n  augroup END\n\n  try\n    lvimgrep /.*/ *.mak\n  catch /E926:/\n  endtry\n  call assert_equal('tango down', getloclist(0, {'items' : 0}).items[0].text)\n  call assert_equal(1, getloclist(0, {'size' : 0}).size)\n\n  augroup QF_Test\n    au!\n  augroup END\n  unlet g:BufNum\n  %bw!\nendfunc\n\n\" Test for adding an invalid entry with the quickfix window open and making\n\" sure that the window contents are not changed\nfunc Test_add_invalid_entry_with_qf_window()\n  call setqflist([], 'f')\n  cexpr \"Xfile1:10:aa\"\n  copen\n  call setqflist(['bb'], 'a')\n  call assert_equal(1, line('$'))\n  call assert_equal(['Xfile1|10| aa'], getline(1, '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': 0    , 'bufnr': bufnr('Xfile1') , 'col': 0   , 'end_col': 0    , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                                          , 'bufnr': bufnr('Xfile1') , 'col': 0                     , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10| aa']               , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': 0    , 'bufnr': bufnr('Xfile1') , 'col': 0   , 'end_col': 0    , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                       , 'end_lnum': 0    , 'bufnr': bufnr('Xfile1') , 'col': 0   , 'end_col': 0    , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10| aa']               , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': 0    , 'bufnr': bufnr('Xfile1') , 'col': 0   , 'end_col': 0    , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                       , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 0   , 'end_col': -456 , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10| aa']               , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 0   , 'end_col': -456 , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                       , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': 0    , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10 col 666| aa']       , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': 0    , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                       , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': -456 , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10 col 666| aa']       , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': -456 , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                       , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': 222  , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10 col 666-222| aa']   , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': 222  , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                       , 'end_lnum': 6 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': 222  , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10-6 col 666-222| aa'] , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': 6 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': 222  , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n  cclose\nendfunc\n\n\" Test for very weird problem: autocommand causes a failure, resulting opening\n\" the quickfix window to fail. This still splits the window, but otherwise\n\" should not mess up buffers.\nfunc Test_quickfix_window_fails_to_open()\n  CheckScreendump\n\n  let lines =<< trim END\n      anything\n      try\n        anything\n      endtry\n  END\n  call writefile(lines, 'XquickfixFails')\n\n  let lines =<< trim END\n      split XquickfixFails\n      silent vimgrep anything %\n      normal o\n      au BufLeave * ++once source XquickfixFails\n      \" This will trigger the autocommand, which causes an error, what follows\n      \" is aborted but the window was already split.\n      silent! cwindow\n  END\n  call writefile(lines, 'XtestWinFails')\n  let buf = RunVimInTerminal('-S XtestWinFails', #{rows: 13})\n  call VerifyScreenDump(buf, 'Test_quickfix_window_fails', {})\n\n  \" clean up\n  call term_sendkeys(buf, \":bwipe!\\<CR>\")\n  call term_wait(buf)\n  call StopVimInTerminal(buf)\n  call delete('XtestWinFails')\n  call delete('XquickfixFails')\nendfunc\n\n\" Test for updating the quickfix buffer whenever the associated quickfix list\n\" is changed.\nfunc Xqfbuf_update(cchar)\n  call s:setup_commands(a:cchar)\n\n  Xexpr \"F1:1:line1\"\n  Xopen\n  call assert_equal(['F1|1| line1'], getline(1, '$'))\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  \" Test setqflist() using the 'lines' key in 'what'\n  \" add a new entry\n  call g:Xsetlist([], 'a', {'lines' : ['F2:2: line2']})\n  call assert_equal(['F1|1| line1', 'F2|2| line2'], getline(1, '$'))\n  call assert_equal(2, g:Xgetlist({'changedtick' : 0}).changedtick)\n  \" replace all the entries with a single entry\n  call g:Xsetlist([], 'r', {'lines' : ['F3:3: line3']})\n  call assert_equal(['F3|3| line3'], getline(1, '$'))\n  call assert_equal(3, g:Xgetlist({'changedtick' : 0}).changedtick)\n  \" remove all the entries\n  call g:Xsetlist([], 'r', {'lines' : []})\n  call assert_equal([''], getline(1, '$'))\n  call assert_equal(4, g:Xgetlist({'changedtick' : 0}).changedtick)\n  \" add a new list\n  call g:Xsetlist([], ' ', {'lines' : ['F4:4: line4']})\n  call assert_equal(['F4|4| line4'], getline(1, '$'))\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  \" Test setqflist() using the 'items' key in 'what'\n  \" add a new entry\n  call g:Xsetlist([], 'a', {'items' : [{'filename' : 'F5', 'lnum' : 5, 'text' : 'line5'}]})\n  call assert_equal(['F4|4| line4', 'F5|5| line5'], getline(1, '$'))\n  call assert_equal(2, g:Xgetlist({'changedtick' : 0}).changedtick)\n  \" replace all the entries with a single entry\n  call g:Xsetlist([], 'r', {'items' : [{'filename' : 'F6', 'lnum' : 6, 'text' : 'line6'}]})\n  call assert_equal(['F6|6| line6'], getline(1, '$'))\n  call assert_equal(3, g:Xgetlist({'changedtick' : 0}).changedtick)\n  \" remove all the entries\n  call g:Xsetlist([], 'r', {'items' : []})\n  call assert_equal([''], getline(1, '$'))\n  call assert_equal(4, g:Xgetlist({'changedtick' : 0}).changedtick)\n  \" add a new list\n  call g:Xsetlist([], ' ', {'items' : [{'filename' : 'F7', 'lnum' : 7, 'text' : 'line7'}]})\n  call assert_equal(['F7|7| line7'], getline(1, '$'))\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  call g:Xsetlist([], ' ', {})\n  call assert_equal([''], getline(1, '$'))\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  Xclose\nendfunc\n\nfunc Test_qfbuf_update()\n  call Xqfbuf_update('c')\n  call Xqfbuf_update('l')\nendfunc\n\nfunc Test_vimgrep_noswapfile()\n  set noswapfile\n  call writefile(['one', 'two', 'three'], 'Xgreppie')\n  vimgrep two Xgreppie\n  call assert_equal('two', getline('.'))\n\n  call delete('Xgreppie')\n  set swapfile\nendfunc\n\n\" Test for the :vimgrep 'f' flag (fuzzy match)\nfunc Xvimgrep_fuzzy_match(cchar)\n  call s:setup_commands(a:cchar)\n\n  Xvimgrep /three one/f Xfile*\n  let l = g:Xgetlist()\n  call assert_equal(2, len(l))\n  call assert_equal(['Xfile1', 1, 9, 'one two three'],\n        \\ [bufname(l[0].bufnr), l[0].lnum, l[0].col, l[0].text])\n  call assert_equal(['Xfile2', 2, 1, 'three one two'],\n        \\ [bufname(l[1].bufnr), l[1].lnum, l[1].col, l[1].text])\n\n  Xvimgrep /the/f Xfile*\n  let l = g:Xgetlist()\n  call assert_equal(3, len(l))\n  call assert_equal(['Xfile1', 1, 9, 'one two three'],\n        \\ [bufname(l[0].bufnr), l[0].lnum, l[0].col, l[0].text])\n  call assert_equal(['Xfile2', 2, 1, 'three one two'],\n        \\ [bufname(l[1].bufnr), l[1].lnum, l[1].col, l[1].text])\n  call assert_equal(['Xfile2', 4, 4, 'aaathreeaaa'],\n        \\ [bufname(l[2].bufnr), l[2].lnum, l[2].col, l[2].text])\n\n  Xvimgrep /aaa/fg Xfile*\n  let l = g:Xgetlist()\n  call assert_equal(4, len(l))\n  call assert_equal(['Xfile1', 2, 1, 'aaaaaa'],\n        \\ [bufname(l[0].bufnr), l[0].lnum, l[0].col, l[0].text])\n  call assert_equal(['Xfile1', 2, 4, 'aaaaaa'],\n        \\ [bufname(l[1].bufnr), l[1].lnum, l[1].col, l[1].text])\n  call assert_equal(['Xfile2', 4, 1, 'aaathreeaaa'],\n        \\ [bufname(l[2].bufnr), l[2].lnum, l[2].col, l[2].text])\n  call assert_equal(['Xfile2', 4, 9, 'aaathreeaaa'],\n        \\ [bufname(l[3].bufnr), l[3].lnum, l[3].col, l[3].text])\n\n  call assert_fails('Xvimgrep /xyz/fg Xfile*', 'E480:')\nendfunc\n\nfunc Test_vimgrep_fuzzy_match()\n  call writefile(['one two three', 'aaaaaa'], 'Xfile1')\n  call writefile(['one', 'three one two', 'two', 'aaathreeaaa'], 'Xfile2')\n  call Xvimgrep_fuzzy_match('c')\n  call Xvimgrep_fuzzy_match('l')\n  call delete('Xfile1')\n  call delete('Xfile2')\nendfunc\n\nfunc Test_locationlist_open_in_newtab()\n  call s:create_test_file('Xqftestfile1')\n  call s:create_test_file('Xqftestfile2')\n  call s:create_test_file('Xqftestfile3')\n\n  %bwipe!\n\n  let lines =<< trim END\n    Xqftestfile1:5:Line5\n    Xqftestfile2:10:Line10\n    Xqftestfile3:16:Line16\n  END\n  lgetexpr lines\n\n  silent! llast\n  call assert_equal(1, tabpagenr('$'))\n  call assert_equal('Xqftestfile3', bufname())\n\n  set switchbuf=newtab\n\n  silent! lfirst\n  call assert_equal(2, tabpagenr('$'))\n  call assert_equal('Xqftestfile1', bufname())\n\n  silent! lnext\n  call assert_equal(3, tabpagenr('$'))\n  call assert_equal('Xqftestfile2', bufname())\n\n  call delete('Xqftestfile1')\n  call delete('Xqftestfile2')\n  call delete('Xqftestfile3')\n  set switchbuf&vim\n\n  %bwipe!\nendfunc\n\n\" Test for win_gettype() in quickfix and location list windows\nfunc Test_win_gettype()\n  copen\n  call assert_equal(\"quickfix\", win_gettype())\n  let wid = win_getid()\n  wincmd p\n  call assert_equal(\"quickfix\", win_gettype(wid))\n  cclose\n  lexpr ''\n  lopen\n  call assert_equal(\"loclist\", win_gettype())\n  let wid = win_getid()\n  wincmd p\n  call assert_equal(\"loclist\", win_gettype(wid))\n  lclose\nendfunc\n\nfun Test_vimgrep_nomatch()\n  call XexprTests('c')\n  call g:Xsetlist([{'lnum':10,'text':'Line1'}])\n  copen\n  if has(\"win32\")\n    call assert_fails('vimgrep foo *.zzz', 'E479:')\n    let expected = [{'lnum': 10, 'bufnr': 0, 'end_lnum': 0, 'pattern': '', 'valid': 0, 'vcol': 0, 'nr': 0, 'module': '', 'type': '', 'end_col': 0, 'col': 0, 'text': 'Line1'}]\n  else\n    call assert_fails('vimgrep foo *.zzz', 'E480:')\n    let expected = []\n  endif\n  call assert_equal(expected, getqflist())\n  cclose\nendfunc\n\n\" Test for opening the quickfix window in two tab pages and then closing one\n\" of the quickfix windows. This should not make the quickfix buffer unlisted.\n\" (github issue #9300).\nfunc Test_two_qf_windows()\n  cexpr \"F1:1:line1\"\n  copen\n  tabnew\n  copen\n  call assert_true(&buflisted)\n  cclose\n  tabfirst\n  call assert_true(&buflisted)\n  let bnum = bufnr()\n  cclose\n  \" if all the quickfix windows are closed, then buffer should be unlisted.\n  call assert_false(buflisted(bnum))\n  %bw!\n\n  \" Repeat the test for a location list\n  lexpr \"F2:2:line2\"\n  lopen\n  let bnum = bufnr()\n  tabnew\n  exe \"buffer\" bnum\n  tabfirst\n  lclose\n  tablast\n  call assert_true(buflisted(bnum))\n  tabclose\n  lopen\n  call assert_true(buflisted(bnum))\n  lclose\n  call assert_false(buflisted(bnum))\n  %bw!\nendfunc\n\n\" Weird sequence of commands that caused entering a wiped-out buffer\nfunc Test_lopen_bwipe()\n  func R()\n    silent! tab lopen\n    e x\n    silent! lfile\n  endfunc\n\n  cal R()\n  cal R()\n  cal R()\n  bw!\n  delfunc R\nendfunc\n\n\" Another sequence of commands that caused all buffers to be wiped out\nfunc Test_lopen_bwipe_all()\n  let lines =<< trim END\n    func R()\n      silent! tab lopen\n      e foo\n      silent! lfile\n    endfunc\n    cal R()\n    exe \"norm \\<C-W>\\<C-V>0\"\n    cal R()\n    bwipe\n\n    call writefile(['done'], 'Xresult')\n    qall!\n  END\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '-u NONE -n -X -Z -e -m -s -S Xscript')\n    call assert_equal(['done'], readfile('Xresult'))\n  endif\n\n  call delete('Xscript')\n  call delete('Xresult')\nendfunc\n\n\" Test for calling setqflist() function recursively\nfunc Test_recursive_setqflist()\n  augroup QF_Test\n    au!\n    autocmd BufWinEnter quickfix call setqflist([], 'r')\n  augroup END\n\n  copen\n  call assert_fails(\"call setqflist([], 'a')\", 'E952:')\n\n  augroup QF_Test\n    au!\n  augroup END\n  %bw!\nendfunc\n\n\" Test for failure to create a new window when selecting a file from the\n\" quickfix window\nfunc Test_cwindow_newwin_fails()\n  cgetexpr [\"Xfile1:10:L10\", \"Xfile1:20:L20\"]\n  cwindow\n  only\n  let qf_wid = win_getid()\n  \" create the maximum number of scratch windows\n  let hor_win_count = (&lines - 1)/2\n  let hor_split_count = hor_win_count - 1\n  for s in range(1, hor_split_count) | new | set buftype=nofile | endfor\n  call win_gotoid(qf_wid)\n  call assert_fails('exe \"normal \\<CR>\"', 'E36:')\n  %bw!\nendfunc\n\n\" Test for updating the location list when only the location list window is\n\" present and the corresponding file window is closed.\nfunc Test_loclist_update_with_llwin_only()\n  %bw!\n  new\n  wincmd w\n  lexpr [\"Xfile1:1:Line1\"]\n  lopen\n  wincmd p\n  close\n  call setloclist(2, [], 'r', {'lines': [\"Xtest2:2:Line2\"]})\n  call assert_equal(['Xtest2|2| Line2'], getbufline(winbufnr(2), 1, '$'))\n  %bw!\nendfunc\n\n\" Test for getting the quickfix list after a buffer with an error is wiped out\nfunc Test_getqflist_wiped_out_buffer()\n  %bw!\n  cexpr [\"Xtest1:34:Wiped out\"]\n  let bnum = bufnr('Xtest1')\n  call assert_equal(bnum, getqflist()[0].bufnr)\n  bw Xtest1\n  call assert_equal(0, getqflist()[0].bufnr)\n  %bw!\nendfunc\n\n\" Test for the status message that is displayed when opening a new quickfix\n\" list\nfunc Test_qflist_statusmsg()\n  cexpr \"1\\n2\"\n  cexpr \"1\\n2\\n3\\ntest_quickfix.vim:1:msg\"\n  call assert_equal('(4 of 4): msg', v:statusmsg)\n  call setqflist([], 'f')\n  %bw!\n\n  \" When creating a new quickfix list, if an autocmd changes the quickfix list\n  \" in the stack, then an error message should be displayed.\n  augroup QF_Test\n    au!\n    au BufEnter test_quickfix.vim colder\n  augroup END\n  cexpr \"1\\n2\"\n  call assert_fails('cexpr \"1\\n2\\n3\\ntest_quickfix.vim:1:msg\"', 'E925:')\n  call setqflist([], 'f')\n  augroup QF_Test\n    au!\n  augroup END\n  %bw!\n\n  augroup QF_Test\n    au!\n    au BufEnter test_quickfix.vim caddexpr \"4\"\n  augroup END\n  call assert_fails('cexpr \"1\\n2\\n3\\ntest_quickfix.vim:1:msg\"', 'E925:')\n  call setqflist([], 'f')\n  augroup QF_Test\n    au!\n  augroup END\n  %bw!\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * quickfix.c: functions for quickfix mode, using a file with error messages\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n\nstruct dir_stack_T\n{\n    struct dir_stack_T\t*next;\n    char_u\t\t*dirname;\n};\n\n/*\n * For each error the next struct is allocated and linked in a list.\n */\ntypedef struct qfline_S qfline_T;\nstruct qfline_S\n{\n    qfline_T\t*qf_next;\t// pointer to next error in the list\n    qfline_T\t*qf_prev;\t// pointer to previous error in the list\n    linenr_T\tqf_lnum;\t// line number where the error occurred\n    linenr_T\tqf_end_lnum;\t// line number when the error has range or zero\n    int\t\tqf_fnum;\t// file number for the line\n    int\t\tqf_col;\t\t// column where the error occurred\n    int\t\tqf_end_col;\t// column when the error has range or zero\n    int\t\tqf_nr;\t\t// error number\n    char_u\t*qf_module;\t// module name for this error\n    char_u\t*qf_pattern;\t// search pattern for the error\n    char_u\t*qf_text;\t// description of the error\n    char_u\tqf_viscol;\t// set to TRUE if qf_col and qf_end_col is\n\t\t\t\t// screen column\n    char_u\tqf_cleared;\t// set to TRUE if line has been deleted\n    char_u\tqf_type;\t// type of the error (mostly 'E'); 1 for\n\t\t\t\t// :helpgrep\n    char_u\tqf_valid;\t// valid error message detected\n};\n\n/*\n * There is a stack of error lists.\n */\n#define LISTCOUNT   10\n#define INVALID_QFIDX (-1)\n#define INVALID_QFBUFNR (0)\n\n/*\n * Quickfix list type.\n */\ntypedef enum\n{\n    QFLT_QUICKFIX, // Quickfix list - global list\n    QFLT_LOCATION, // Location list - per window list\n    QFLT_INTERNAL  // Internal - Temporary list used by getqflist()/getloclist()\n} qfltype_T;\n\n/*\n * Quickfix/Location list definition\n * Contains a list of entries (qfline_T). qf_start points to the first entry\n * and qf_last points to the last entry. qf_count contains the list size.\n *\n * Usually the list contains one or more entries. But an empty list can be\n * created using setqflist()/setloclist() with a title and/or user context\n * information and entries can be added later using setqflist()/setloclist().\n */\ntypedef struct qf_list_S\n{\n    int_u\tqf_id;\t\t// Unique identifier for this list\n    qfltype_T\tqfl_type;\n    qfline_T\t*qf_start;\t// pointer to the first error\n    qfline_T\t*qf_last;\t// pointer to the last error\n    qfline_T\t*qf_ptr;\t// pointer to the current error\n    int\t\tqf_count;\t// number of errors (0 means empty list)\n    int\t\tqf_index;\t// current index in the error list\n    int\t\tqf_nonevalid;\t// TRUE if not a single valid entry found\n    char_u\t*qf_title;\t// title derived from the command that created\n\t\t\t\t// the error list or set by setqflist\n    typval_T\t*qf_ctx;\t// context set by setqflist/setloclist\n    callback_T  qf_qftf_cb;\t// 'quickfixtextfunc' callback function\n\n    struct dir_stack_T\t*qf_dir_stack;\n    char_u\t\t*qf_directory;\n    struct dir_stack_T\t*qf_file_stack;\n    char_u\t\t*qf_currfile;\n    int\t\t\tqf_multiline;\n    int\t\t\tqf_multiignore;\n    int\t\t\tqf_multiscan;\n    long\t\tqf_changedtick;\n} qf_list_T;\n\n/*\n * Quickfix/Location list stack definition\n * Contains a list of quickfix/location lists (qf_list_T)\n */\nstruct qf_info_S\n{\n    // Count of references to this list. Used only for location lists.\n    // When a location list window reference this list, qf_refcount\n    // will be 2. Otherwise, qf_refcount will be 1. When qf_refcount\n    // reaches 0, the list is freed.\n    int\t\tqf_refcount;\n    int\t\tqf_listcount;\t    // current number of lists\n    int\t\tqf_curlist;\t    // current error list\n    qf_list_T\tqf_lists[LISTCOUNT];\n    qfltype_T\tqfl_type;\t    // type of list\n    int\t\tqf_bufnr;\t    // quickfix window buffer number\n};\n\nstatic qf_info_T ql_info;\t// global quickfix list\nstatic int_u last_qf_id = 0;\t// Last used quickfix list id\n\n#define FMT_PATTERNS 13\t\t// maximum number of % recognized\n\n/*\n * Structure used to hold the info of one part of 'errorformat'\n */\ntypedef struct efm_S efm_T;\nstruct efm_S\n{\n    regprog_T\t    *prog;\t// pre-formatted part of 'errorformat'\n    efm_T\t    *next;\t// pointer to next (NULL if last)\n    char_u\t    addr[FMT_PATTERNS]; // indices of used % patterns\n    char_u\t    prefix;\t// prefix of this format line:\n\t\t\t\t//   'D' enter directory\n\t\t\t\t//   'X' leave directory\n\t\t\t\t//   'A' start of multi-line message\n\t\t\t\t//   'E' error message\n\t\t\t\t//   'W' warning message\n\t\t\t\t//   'I' informational message\n\t\t\t\t//   'N' note message\n\t\t\t\t//   'C' continuation line\n\t\t\t\t//   'Z' end of multi-line message\n\t\t\t\t//   'G' general, unspecific message\n\t\t\t\t//   'P' push file (partial) message\n\t\t\t\t//   'Q' pop/quit file (partial) message\n\t\t\t\t//   'O' overread (partial) message\n    char_u\t    flags;\t// additional flags given in prefix\n\t\t\t\t//   '-' do not include this line\n\t\t\t\t//   '+' include whole line in message\n    int\t\t    conthere;\t// %> used\n};\n\n// List of location lists to be deleted.\n// Used to delay the deletion of locations lists by autocmds.\ntypedef struct qf_delq_S\n{\n    struct qf_delq_S\t*next;\n    qf_info_T\t\t*qi;\n} qf_delq_T;\nstatic qf_delq_T *qf_delq_head = NULL;\n\n// Counter to prevent autocmds from freeing up location lists when they are\n// still being used.\nstatic int\tquickfix_busy = 0;\n\nstatic efm_T\t*fmt_start = NULL; // cached across qf_parse_line() calls\n\n// callback function for 'quickfixtextfunc'\nstatic callback_T qftf_cb;\n\nstatic void\tqf_new_list(qf_info_T *qi, char_u *qf_title);\nstatic int\tqf_add_entry(qf_list_T *qfl, char_u *dir, char_u *fname, char_u *module, int bufnum, char_u *mesg, long lnum, long end_lnum, int col, int end_col, int vis_col, char_u *pattern, int nr, int type, int valid);\nstatic void\tqf_free(qf_list_T *qfl);\nstatic char_u\t*qf_types(int, int);\nstatic int\tqf_get_fnum(qf_list_T *qfl, char_u *, char_u *);\nstatic char_u\t*qf_push_dir(char_u *, struct dir_stack_T **, int is_file_stack);\nstatic char_u\t*qf_pop_dir(struct dir_stack_T **);\nstatic char_u\t*qf_guess_filepath(qf_list_T *qfl, char_u *);\nstatic void\tqf_jump_newwin(qf_info_T *qi, int dir, int errornr, int forceit, int newwin);\nstatic void\tqf_fmt_text(char_u *text, char_u *buf, int bufsize);\nstatic void\tqf_range_text(qfline_T *qfp, char_u *buf, int bufsize);\nstatic int\tqf_win_pos_update(qf_info_T *qi, int old_qf_index);\nstatic win_T\t*qf_find_win(qf_info_T *qi);\nstatic buf_T\t*qf_find_buf(qf_info_T *qi);\nstatic void\tqf_update_buffer(qf_info_T *qi, qfline_T *old_last);\nstatic void\tqf_fill_buffer(qf_list_T *qfl, buf_T *buf, qfline_T *old_last, int qf_winid);\nstatic buf_T\t*load_dummy_buffer(char_u *fname, char_u *dirname_start, char_u *resulting_dir);\nstatic void\twipe_dummy_buffer(buf_T *buf, char_u *dirname_start);\nstatic void\tunload_dummy_buffer(buf_T *buf, char_u *dirname_start);\nstatic qf_info_T *ll_get_or_alloc_list(win_T *);\n\n// Quickfix window check helper macro\n#define IS_QF_WINDOW(wp) (bt_quickfix((wp)->w_buffer) && (wp)->w_llist_ref == NULL)\n// Location list window check helper macro\n#define IS_LL_WINDOW(wp) (bt_quickfix((wp)->w_buffer) && (wp)->w_llist_ref != NULL)\n\n// Quickfix and location list stack check helper macros\n#define IS_QF_STACK(qi)\t\t((qi)->qfl_type == QFLT_QUICKFIX)\n#define IS_LL_STACK(qi)\t\t((qi)->qfl_type == QFLT_LOCATION)\n#define IS_QF_LIST(qfl)\t\t((qfl)->qfl_type == QFLT_QUICKFIX)\n#define IS_LL_LIST(qfl)\t\t((qfl)->qfl_type == QFLT_LOCATION)\n\n/*\n * Return location list for window 'wp'\n * For location list window, return the referenced location list\n */\n#define GET_LOC_LIST(wp) (IS_LL_WINDOW(wp) ? (wp)->w_llist_ref : (wp)->w_llist)\n\n// Macro to loop through all the items in a quickfix list\n// Quickfix item index starts from 1, so i below starts at 1\n#define FOR_ALL_QFL_ITEMS(qfl, qfp, i) \\\n\t\t    for ((i) = 1, (qfp) = (qfl)->qf_start; \\\n\t\t\t    !got_int && (i) <= (qfl)->qf_count && (qfp) != NULL; \\\n\t\t\t    ++(i), (qfp) = (qfp)->qf_next)\n\n/*\n * Looking up a buffer can be slow if there are many.  Remember the last one\n * to make this a lot faster if there are multiple matches in the same file.\n */\nstatic char_u   *qf_last_bufname = NULL;\nstatic bufref_T  qf_last_bufref = {NULL, 0, 0};\n\n/*\n * Maximum number of bytes allowed per line while reading a errorfile.\n */\n#define LINE_MAXLEN 4096\n\n/*\n * Patterns used.  Keep in sync with qf_parse_fmt[].\n */\nstatic struct fmtpattern\n{\n    char_u\tconvchar;\n    char\t*pattern;\n} fmt_pat[FMT_PATTERNS] =\n    {\n\t{'f', \".\\\\+\"},\t    // only used when at end\n\t{'n', \"\\\\d\\\\+\"},\t// 1\n\t{'l', \"\\\\d\\\\+\"},\t// 2\n\t{'e', \"\\\\d\\\\+\"},\t// 3\n\t{'c', \"\\\\d\\\\+\"},\t// 4\n\t{'k', \"\\\\d\\\\+\"},\t// 5\n\t{'t', \".\"},\t\t// 6\n#define FMT_PATTERN_M 7\n\t{'m', \".\\\\+\"},\t\t// 7\n#define FMT_PATTERN_R 8\n\t{'r', \".*\"},\t\t// 8\n\t{'p', \"[- \t.]*\"},\t// 9\n\t{'v', \"\\\\d\\\\+\"},\t// 10\n\t{'s', \".\\\\+\"},\t\t// 11\n\t{'o', \".\\\\+\"}\t\t// 12\n    };\n\n/*\n * Convert an errorformat pattern to a regular expression pattern.\n * See fmt_pat definition above for the list of supported patterns.  The\n * pattern specifier is supplied in \"efmpat\".  The converted pattern is stored\n * in \"regpat\".  Returns a pointer to the location after the pattern.\n */\n    static char_u *\nefmpat_to_regpat(\n\tchar_u\t*efmpat,\n\tchar_u\t*regpat,\n\tefm_T\t*efminfo,\n\tint\tidx,\n\tint\tround)\n{\n    char_u\t*srcptr;\n\n    if (efminfo->addr[idx])\n    {\n\t// Each errorformat pattern can occur only once\n\tsemsg(_(e_too_many_chr_in_format_string), *efmpat);\n\treturn NULL;\n    }\n    if ((idx && idx < FMT_PATTERN_R\n\t\t&& vim_strchr((char_u *)\"DXOPQ\", efminfo->prefix) != NULL)\n\t    || (idx == FMT_PATTERN_R\n\t\t&& vim_strchr((char_u *)\"OPQ\", efminfo->prefix) == NULL))\n    {\n\tsemsg(_(e_unexpected_chr_in_format_str), *efmpat);\n\treturn NULL;\n    }\n    efminfo->addr[idx] = (char_u)++round;\n    *regpat++ = '\\\\';\n    *regpat++ = '(';\n#ifdef BACKSLASH_IN_FILENAME\n    if (*efmpat == 'f')\n    {\n\t// Also match \"c:\" in the file name, even when\n\t// checking for a colon next: \"%f:\".\n\t// \"\\%(\\a:\\)\\=\"\n\tSTRCPY(regpat, \"\\\\%(\\\\a:\\\\)\\\\=\");\n\tregpat += 10;\n    }\n#endif\n    if (*efmpat == 'f' && efmpat[1] != NUL)\n    {\n\tif (efmpat[1] != '\\\\' && efmpat[1] != '%')\n\t{\n\t    // A file name may contain spaces, but this isn't\n\t    // in \"\\f\".  For \"%f:%l:%m\" there may be a \":\" in\n\t    // the file name.  Use \".\\{-1,}x\" instead (x is\n\t    // the next character), the requirement that :999:\n\t    // follows should work.\n\t    STRCPY(regpat, \".\\\\{-1,}\");\n\t    regpat += 7;\n\t}\n\telse\n\t{\n\t    // File name followed by '\\\\' or '%': include as\n\t    // many file name chars as possible.\n\t    STRCPY(regpat, \"\\\\f\\\\+\");\n\t    regpat += 4;\n\t}\n    }\n    else\n    {\n\tsrcptr = (char_u *)fmt_pat[idx].pattern;\n\twhile ((*regpat = *srcptr++) != NUL)\n\t    ++regpat;\n    }\n    *regpat++ = '\\\\';\n    *regpat++ = ')';\n\n    return regpat;\n}\n\n/*\n * Convert a scanf like format in 'errorformat' to a regular expression.\n * Returns a pointer to the location after the pattern.\n */\n    static char_u *\nscanf_fmt_to_regpat(\n\tchar_u\t**pefmp,\n\tchar_u\t*efm,\n\tint\tlen,\n\tchar_u\t*regpat)\n{\n    char_u\t*efmp = *pefmp;\n\n    if (*efmp == '[' || *efmp == '\\\\')\n    {\n\tif ((*regpat++ = *efmp) == '[')\t// %*[^a-z0-9] etc.\n\t{\n\t    if (efmp[1] == '^')\n\t\t*regpat++ = *++efmp;\n\t    if (efmp < efm + len)\n\t    {\n\t\t*regpat++ = *++efmp;\t    // could be ']'\n\t\twhile (efmp < efm + len\n\t\t\t&& (*regpat++ = *++efmp) != ']')\n\t\t    // skip ;\n\t\tif (efmp == efm + len)\n\t\t{\n\t\t    emsg(_(e_missing_rsb_in_format_string));\n\t\t    return NULL;\n\t\t}\n\t    }\n\t}\n\telse if (efmp < efm + len)\t// %*\\D, %*\\s etc.\n\t    *regpat++ = *++efmp;\n\t*regpat++ = '\\\\';\n\t*regpat++ = '+';\n    }\n    else\n    {\n\t// TODO: scanf()-like: %*ud, %*3c, %*f, ... ?\n\tsemsg(_(e_unsupported_chr_in_format_string), *efmp);\n\treturn NULL;\n    }\n\n    *pefmp = efmp;\n\n    return regpat;\n}\n\n/*\n * Analyze/parse an errorformat prefix.\n */\n    static char_u *\nefm_analyze_prefix(char_u *efmp, efm_T *efminfo)\n{\n    if (vim_strchr((char_u *)\"+-\", *efmp) != NULL)\n\tefminfo->flags = *efmp++;\n    if (vim_strchr((char_u *)\"DXAEWINCZGOPQ\", *efmp) != NULL)\n\tefminfo->prefix = *efmp;\n    else\n    {\n\tsemsg(_(e_invalid_chr_in_format_string_prefix), *efmp);\n\treturn NULL;\n    }\n\n    return efmp;\n}\n\n/*\n * Converts a 'errorformat' string part in 'efm' to a regular expression\n * pattern.  The resulting regex pattern is returned in \"regpat\". Additional\n * information about the 'erroformat' pattern is returned in \"fmt_ptr\".\n * Returns OK or FAIL.\n */\n    static int\nefm_to_regpat(\n\tchar_u\t*efm,\n\tint\tlen,\n\tefm_T\t*fmt_ptr,\n\tchar_u\t*regpat)\n{\n    char_u\t*ptr;\n    char_u\t*efmp;\n    int\t\tround;\n    int\t\tidx = 0;\n\n    // Build a regexp pattern for a 'errorformat' option part\n    ptr = regpat;\n    *ptr++ = '^';\n    round = 0;\n    for (efmp = efm; efmp < efm + len; ++efmp)\n    {\n\tif (*efmp == '%')\n\t{\n\t    ++efmp;\n\t    for (idx = 0; idx < FMT_PATTERNS; ++idx)\n\t\tif (fmt_pat[idx].convchar == *efmp)\n\t\t    break;\n\t    if (idx < FMT_PATTERNS)\n\t    {\n\t\tptr = efmpat_to_regpat(efmp, ptr, fmt_ptr, idx, round);\n\t\tif (ptr == NULL)\n\t\t    return FAIL;\n\t\tround++;\n\t    }\n\t    else if (*efmp == '*')\n\t    {\n\t\t++efmp;\n\t\tptr = scanf_fmt_to_regpat(&efmp, efm, len, ptr);\n\t\tif (ptr == NULL)\n\t\t    return FAIL;\n\t    }\n\t    else if (vim_strchr((char_u *)\"%\\\\.^$~[\", *efmp) != NULL)\n\t\t*ptr++ = *efmp;\t\t// regexp magic characters\n\t    else if (*efmp == '#')\n\t\t*ptr++ = '*';\n\t    else if (*efmp == '>')\n\t\tfmt_ptr->conthere = TRUE;\n\t    else if (efmp == efm + 1)\t\t// analyse prefix\n\t    {\n\t\t// prefix is allowed only at the beginning of the errorformat\n\t\t// option part\n\t\tefmp = efm_analyze_prefix(efmp, fmt_ptr);\n\t\tif (efmp == NULL)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\tsemsg(_(e_invalid_chr_in_format_string), *efmp);\n\t\treturn FAIL;\n\t    }\n\t}\n\telse\t\t\t// copy normal character\n\t{\n\t    if (*efmp == '\\\\' && efmp + 1 < efm + len)\n\t\t++efmp;\n\t    else if (vim_strchr((char_u *)\".*^$~[\", *efmp) != NULL)\n\t\t*ptr++ = '\\\\';\t// escape regexp atoms\n\t    if (*efmp)\n\t\t*ptr++ = *efmp;\n\t}\n    }\n    *ptr++ = '$';\n    *ptr = NUL;\n\n    return OK;\n}\n\n/*\n * Free the 'errorformat' information list\n */\n    static void\nfree_efm_list(efm_T **efm_first)\n{\n    efm_T *efm_ptr;\n\n    for (efm_ptr = *efm_first; efm_ptr != NULL; efm_ptr = *efm_first)\n    {\n\t*efm_first = efm_ptr->next;\n\tvim_regfree(efm_ptr->prog);\n\tvim_free(efm_ptr);\n    }\n    fmt_start = NULL;\n}\n\n/*\n * Compute the size of the buffer used to convert a 'errorformat' pattern into\n * a regular expression pattern.\n */\n    static int\nefm_regpat_bufsz(char_u *efm)\n{\n    int sz;\n    int i;\n\n    sz = (FMT_PATTERNS * 3) + ((int)STRLEN(efm) << 2);\n    for (i = FMT_PATTERNS; i > 0; )\n\tsz += (int)STRLEN(fmt_pat[--i].pattern);\n#ifdef BACKSLASH_IN_FILENAME\n    sz += 12; // \"%f\" can become twelve chars longer (see efm_to_regpat)\n#else\n    sz += 2; // \"%f\" can become two chars longer\n#endif\n\n    return sz;\n}\n\n/*\n * Return the length of a 'errorformat' option part (separated by \",\").\n */\n    static int\nefm_option_part_len(char_u *efm)\n{\n    int len;\n\n    for (len = 0; efm[len] != NUL && efm[len] != ','; ++len)\n\tif (efm[len] == '\\\\' && efm[len + 1] != NUL)\n\t    ++len;\n\n    return len;\n}\n\n/*\n * Parse the 'errorformat' option. Multiple parts in the 'errorformat' option\n * are parsed and converted to regular expressions. Returns information about\n * the parsed 'errorformat' option.\n */\n    static efm_T *\nparse_efm_option(char_u *efm)\n{\n    efm_T\t*fmt_ptr = NULL;\n    efm_T\t*fmt_first = NULL;\n    efm_T\t*fmt_last = NULL;\n    char_u\t*fmtstr = NULL;\n    int\t\tlen;\n    int\t\tsz;\n\n    // Each part of the format string is copied and modified from errorformat\n    // to regex prog.  Only a few % characters are allowed.\n\n    // Get some space to modify the format string into.\n    sz = efm_regpat_bufsz(efm);\n    if ((fmtstr = alloc_id(sz, aid_qf_efm_fmtstr)) == NULL)\n\tgoto parse_efm_error;\n\n    while (efm[0] != NUL)\n    {\n\t// Allocate a new eformat structure and put it at the end of the list\n\tfmt_ptr = ALLOC_CLEAR_ONE_ID(efm_T, aid_qf_efm_fmtpart);\n\tif (fmt_ptr == NULL)\n\t    goto parse_efm_error;\n\tif (fmt_first == NULL)\t    // first one\n\t    fmt_first = fmt_ptr;\n\telse\n\t    fmt_last->next = fmt_ptr;\n\tfmt_last = fmt_ptr;\n\n\t// Isolate one part in the 'errorformat' option\n\tlen = efm_option_part_len(efm);\n\n\tif (efm_to_regpat(efm, len, fmt_ptr, fmtstr) == FAIL)\n\t    goto parse_efm_error;\n\tif ((fmt_ptr->prog = vim_regcomp(fmtstr, RE_MAGIC + RE_STRING)) == NULL)\n\t    goto parse_efm_error;\n\t// Advance to next part\n\tefm = skip_to_option_part(efm + len);\t// skip comma and spaces\n    }\n\n    if (fmt_first == NULL)\t// nothing found\n\temsg(_(e_errorformat_contains_no_pattern));\n\n    goto parse_efm_end;\n\nparse_efm_error:\n    free_efm_list(&fmt_first);\n\nparse_efm_end:\n    vim_free(fmtstr);\n\n    return fmt_first;\n}\n\nenum {\n    QF_FAIL = 0,\n    QF_OK = 1,\n    QF_END_OF_INPUT = 2,\n    QF_NOMEM = 3,\n    QF_IGNORE_LINE = 4,\n    QF_MULTISCAN = 5,\n};\n\n/*\n * State information used to parse lines and add entries to a quickfix/location\n * list.\n */\ntypedef struct {\n    char_u\t*linebuf;\n    int\t\tlinelen;\n    char_u\t*growbuf;\n    int\t\tgrowbufsiz;\n    FILE\t*fd;\n    typval_T\t*tv;\n    char_u\t*p_str;\n    listitem_T\t*p_li;\n    buf_T\t*buf;\n    linenr_T\tbuflnum;\n    linenr_T\tlnumlast;\n    vimconv_T\tvc;\n} qfstate_T;\n\n/*\n * Allocate more memory for the line buffer used for parsing lines.\n */\n    static char_u *\nqf_grow_linebuf(qfstate_T *state, int newsz)\n{\n    char_u\t*p;\n\n    // If the line exceeds LINE_MAXLEN exclude the last\n    // byte since it's not a NL character.\n    state->linelen = newsz > LINE_MAXLEN ? LINE_MAXLEN - 1 : newsz;\n    if (state->growbuf == NULL)\n    {\n\tstate->growbuf = alloc_id(state->linelen + 1, aid_qf_linebuf);\n\tif (state->growbuf == NULL)\n\t    return NULL;\n\tstate->growbufsiz = state->linelen;\n    }\n    else if (state->linelen > state->growbufsiz)\n    {\n\tif ((p = vim_realloc(state->growbuf, state->linelen + 1)) == NULL)\n\t    return NULL;\n\tstate->growbuf = p;\n\tstate->growbufsiz = state->linelen;\n    }\n    return state->growbuf;\n}\n\n/*\n * Get the next string (separated by newline) from state->p_str.\n */\n    static int\nqf_get_next_str_line(qfstate_T *state)\n{\n    // Get the next line from the supplied string\n    char_u\t*p_str = state->p_str;\n    char_u\t*p;\n    int\t\tlen;\n\n    if (*p_str == NUL) // Reached the end of the string\n\treturn QF_END_OF_INPUT;\n\n    p = vim_strchr(p_str, '\\n');\n    if (p != NULL)\n\tlen = (int)(p - p_str) + 1;\n    else\n\tlen = (int)STRLEN(p_str);\n\n    if (len > IOSIZE - 2)\n    {\n\tstate->linebuf = qf_grow_linebuf(state, len);\n\tif (state->linebuf == NULL)\n\t    return QF_NOMEM;\n    }\n    else\n    {\n\tstate->linebuf = IObuff;\n\tstate->linelen = len;\n    }\n    vim_strncpy(state->linebuf, p_str, state->linelen);\n\n    // Increment using len in order to discard the rest of the\n    // line if it exceeds LINE_MAXLEN.\n    p_str += len;\n    state->p_str = p_str;\n\n    return QF_OK;\n}\n\n/*\n * Get the next string from the List item state->p_li.\n */\n    static int\nqf_get_next_list_line(qfstate_T *state)\n{\n    listitem_T\t*p_li = state->p_li;\n    int\t\tlen;\n\n    while (p_li != NULL\n\t    && (p_li->li_tv.v_type != VAR_STRING\n\t\t|| p_li->li_tv.vval.v_string == NULL))\n\tp_li = p_li->li_next;\t// Skip non-string items\n\n    if (p_li == NULL)\t\t// End of the list\n    {\n\tstate->p_li = NULL;\n\treturn QF_END_OF_INPUT;\n    }\n\n    len = (int)STRLEN(p_li->li_tv.vval.v_string);\n    if (len > IOSIZE - 2)\n    {\n\tstate->linebuf = qf_grow_linebuf(state, len);\n\tif (state->linebuf == NULL)\n\t    return QF_NOMEM;\n    }\n    else\n    {\n\tstate->linebuf = IObuff;\n\tstate->linelen = len;\n    }\n\n    vim_strncpy(state->linebuf, p_li->li_tv.vval.v_string, state->linelen);\n\n    state->p_li = p_li->li_next;\t// next item\n    return QF_OK;\n}\n\n/*\n * Get the next string from state->buf.\n */\n    static int\nqf_get_next_buf_line(qfstate_T *state)\n{\n    char_u\t*p_buf = NULL;\n    int\t\tlen;\n\n    // Get the next line from the supplied buffer\n    if (state->buflnum > state->lnumlast)\n\treturn QF_END_OF_INPUT;\n\n    p_buf = ml_get_buf(state->buf, state->buflnum, FALSE);\n    state->buflnum += 1;\n\n    len = (int)STRLEN(p_buf);\n    if (len > IOSIZE - 2)\n    {\n\tstate->linebuf = qf_grow_linebuf(state, len);\n\tif (state->linebuf == NULL)\n\t    return QF_NOMEM;\n    }\n    else\n    {\n\tstate->linebuf = IObuff;\n\tstate->linelen = len;\n    }\n    vim_strncpy(state->linebuf, p_buf, state->linelen);\n\n    return QF_OK;\n}\n\n/*\n * Get the next string from file state->fd.\n */\n    static int\nqf_get_next_file_line(qfstate_T *state)\n{\n    int\t    discard;\n    int\t    growbuflen;\n\n    if (fgets((char *)IObuff, IOSIZE, state->fd) == NULL)\n\treturn QF_END_OF_INPUT;\n\n    discard = FALSE;\n    state->linelen = (int)STRLEN(IObuff);\n    if (state->linelen == IOSIZE - 1 && !(IObuff[state->linelen - 1] == '\\n'))\n    {\n\t// The current line exceeds IObuff, continue reading using\n\t// growbuf until EOL or LINE_MAXLEN bytes is read.\n\tif (state->growbuf == NULL)\n\t{\n\t    state->growbufsiz = 2 * (IOSIZE - 1);\n\t    state->growbuf = alloc_id(state->growbufsiz, aid_qf_linebuf);\n\t    if (state->growbuf == NULL)\n\t\treturn QF_NOMEM;\n\t}\n\n\t// Copy the read part of the line, excluding null-terminator\n\tmemcpy(state->growbuf, IObuff, IOSIZE - 1);\n\tgrowbuflen = state->linelen;\n\n\tfor (;;)\n\t{\n\t    char_u\t*p;\n\n\t    if (fgets((char *)state->growbuf + growbuflen,\n\t\t\tstate->growbufsiz - growbuflen, state->fd) == NULL)\n\t\tbreak;\n\t    state->linelen = (int)STRLEN(state->growbuf + growbuflen);\n\t    growbuflen += state->linelen;\n\t    if ((state->growbuf)[growbuflen - 1] == '\\n')\n\t\tbreak;\n\t    if (state->growbufsiz == LINE_MAXLEN)\n\t    {\n\t\tdiscard = TRUE;\n\t\tbreak;\n\t    }\n\n\t    state->growbufsiz = 2 * state->growbufsiz < LINE_MAXLEN\n\t\t? 2 * state->growbufsiz : LINE_MAXLEN;\n\t    if ((p = vim_realloc(state->growbuf, state->growbufsiz)) == NULL)\n\t\treturn QF_NOMEM;\n\t    state->growbuf = p;\n\t}\n\n\twhile (discard)\n\t{\n\t    // The current line is longer than LINE_MAXLEN, continue\n\t    // reading but discard everything until EOL or EOF is\n\t    // reached.\n\t    if (fgets((char *)IObuff, IOSIZE, state->fd) == NULL\n\t\t    || (int)STRLEN(IObuff) < IOSIZE - 1\n\t\t    || IObuff[IOSIZE - 2] == '\\n')\n\t\tbreak;\n\t}\n\n\tstate->linebuf = state->growbuf;\n\tstate->linelen = growbuflen;\n    }\n    else\n\tstate->linebuf = IObuff;\n\n    // Convert a line if it contains a non-ASCII character.\n    if (state->vc.vc_type != CONV_NONE && has_non_ascii(state->linebuf))\n    {\n\tchar_u\t*line;\n\n\tline = string_convert(&state->vc, state->linebuf, &state->linelen);\n\tif (line != NULL)\n\t{\n\t    if (state->linelen < IOSIZE)\n\t    {\n\t\tSTRCPY(state->linebuf, line);\n\t\tvim_free(line);\n\t    }\n\t    else\n\t    {\n\t\tvim_free(state->growbuf);\n\t\tstate->linebuf = state->growbuf = line;\n\t\tstate->growbufsiz = state->linelen < LINE_MAXLEN\n\t\t\t\t\t\t? state->linelen : LINE_MAXLEN;\n\t    }\n\t}\n    }\n\n    return QF_OK;\n}\n\n/*\n * Get the next string from a file/buffer/list/string.\n */\n    static int\nqf_get_nextline(qfstate_T *state)\n{\n    int status = QF_FAIL;\n\n    if (state->fd == NULL)\n    {\n\tif (state->tv != NULL)\n\t{\n\t    if (state->tv->v_type == VAR_STRING)\n\t\t// Get the next line from the supplied string\n\t\tstatus = qf_get_next_str_line(state);\n\t    else if (state->tv->v_type == VAR_LIST)\n\t\t// Get the next line from the supplied list\n\t\tstatus = qf_get_next_list_line(state);\n\t}\n\telse\n\t    // Get the next line from the supplied buffer\n\t    status = qf_get_next_buf_line(state);\n    }\n    else\n\t// Get the next line from the supplied file\n\tstatus = qf_get_next_file_line(state);\n\n    if (status != QF_OK)\n\treturn status;\n\n    // remove newline/CR from the line\n    if (state->linelen > 0 && state->linebuf[state->linelen - 1] == '\\n')\n    {\n\tstate->linebuf[state->linelen - 1] = NUL;\n#ifdef USE_CRNL\n\tif (state->linelen > 1 && state->linebuf[state->linelen - 2] == '\\r')\n\t    state->linebuf[state->linelen - 2] = NUL;\n#endif\n    }\n\n    remove_bom(state->linebuf);\n\n    return QF_OK;\n}\n\ntypedef struct {\n    char_u\t*namebuf;\n    char_u\t*module;\n    char_u\t*errmsg;\n    int\t\terrmsglen;\n    long\tlnum;\n    long\tend_lnum;\n    int\t\tcol;\n    int\t\tend_col;\n    char_u\tuse_viscol;\n    char_u\t*pattern;\n    int\t\tenr;\n    int\t\ttype;\n    int\t\tvalid;\n} qffields_T;\n\n/*\n * Parse the match for filename ('%f') pattern in regmatch.\n * Return the matched value in \"fields->namebuf\".\n */\n    static int\nqf_parse_fmt_f(regmatch_T *rmp, int midx, qffields_T *fields, int prefix)\n{\n    int c;\n\n    if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL)\n\treturn QF_FAIL;\n\n    // Expand ~/file and $HOME/file to full path.\n    c = *rmp->endp[midx];\n    *rmp->endp[midx] = NUL;\n    expand_env(rmp->startp[midx], fields->namebuf, CMDBUFFSIZE);\n    *rmp->endp[midx] = c;\n\n    // For separate filename patterns (%O, %P and %Q), the specified file\n    // should exist.\n    if (vim_strchr((char_u *)\"OPQ\", prefix) != NULL\n\t    && mch_getperm(fields->namebuf) == -1)\n\treturn QF_FAIL;\n\n    return QF_OK;\n}\n\n/*\n * Parse the match for error number ('%n') pattern in regmatch.\n * Return the matched value in \"fields->enr\".\n */\n    static int\nqf_parse_fmt_n(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->enr = (int)atol((char *)rmp->startp[midx]);\n    return QF_OK;\n}\n\n/*\n * Parse the match for line number ('%l') pattern in regmatch.\n * Return the matched value in \"fields->lnum\".\n */\n    static int\nqf_parse_fmt_l(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->lnum = atol((char *)rmp->startp[midx]);\n    return QF_OK;\n}\n\n/*\n * Parse the match for end line number ('%e') pattern in regmatch.\n * Return the matched value in \"fields->end_lnum\".\n */\n    static int\nqf_parse_fmt_e(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->end_lnum = atol((char *)rmp->startp[midx]);\n    return QF_OK;\n}\n\n/*\n * Parse the match for column number ('%c') pattern in regmatch.\n * Return the matched value in \"fields->col\".\n */\n    static int\nqf_parse_fmt_c(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->col = (int)atol((char *)rmp->startp[midx]);\n    return QF_OK;\n}\n\n/*\n * Parse the match for end column number ('%k') pattern in regmatch.\n * Return the matched value in \"fields->end_col\".\n */\n    static int\nqf_parse_fmt_k(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->end_col = (int)atol((char *)rmp->startp[midx]);\n    return QF_OK;\n}\n\n/*\n * Parse the match for error type ('%t') pattern in regmatch.\n * Return the matched value in \"fields->type\".\n */\n    static int\nqf_parse_fmt_t(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->type = *rmp->startp[midx];\n    return QF_OK;\n}\n\n/*\n * Copy a non-error line into the error string.  Return the matched line in\n * \"fields->errmsg\".\n */\n    static int\ncopy_nonerror_line(char_u *linebuf, int linelen, qffields_T *fields)\n{\n    char_u\t*p;\n\n    if (linelen >= fields->errmsglen)\n    {\n\t// linelen + null terminator\n\tif ((p = vim_realloc(fields->errmsg, linelen + 1)) == NULL)\n\t    return QF_NOMEM;\n\tfields->errmsg = p;\n\tfields->errmsglen = linelen + 1;\n    }\n    // copy whole line to error message\n    vim_strncpy(fields->errmsg, linebuf, linelen);\n\n    return QF_OK;\n}\n\n/*\n * Parse the match for error message ('%m') pattern in regmatch.\n * Return the matched value in \"fields->errmsg\".\n */\n    static int\nqf_parse_fmt_m(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    char_u\t*p;\n    int\t\tlen;\n\n    if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL)\n\treturn QF_FAIL;\n    len = (int)(rmp->endp[midx] - rmp->startp[midx]);\n    if (len >= fields->errmsglen)\n    {\n\t// len + null terminator\n\tif ((p = vim_realloc(fields->errmsg, len + 1)) == NULL)\n\t    return QF_NOMEM;\n\tfields->errmsg = p;\n\tfields->errmsglen = len + 1;\n    }\n    vim_strncpy(fields->errmsg, rmp->startp[midx], len);\n    return QF_OK;\n}\n\n/*\n * Parse the match for rest of a single-line file message ('%r') pattern.\n * Return the matched value in \"tail\".\n */\n    static int\nqf_parse_fmt_r(regmatch_T *rmp, int midx, char_u **tail)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    *tail = rmp->startp[midx];\n    return QF_OK;\n}\n\n/*\n * Parse the match for the pointer line ('%p') pattern in regmatch.\n * Return the matched value in \"fields->col\".\n */\n    static int\nqf_parse_fmt_p(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    char_u\t*match_ptr;\n\n    if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->col = 0;\n    for (match_ptr = rmp->startp[midx]; match_ptr != rmp->endp[midx];\n\t\t\t\t\t\t\t\t++match_ptr)\n    {\n\t++fields->col;\n\tif (*match_ptr == TAB)\n\t{\n\t    fields->col += 7;\n\t    fields->col -= fields->col % 8;\n\t}\n    }\n    ++fields->col;\n    fields->use_viscol = TRUE;\n    return QF_OK;\n}\n\n/*\n * Parse the match for the virtual column number ('%v') pattern in regmatch.\n * Return the matched value in \"fields->col\".\n */\n    static int\nqf_parse_fmt_v(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->col = (int)atol((char *)rmp->startp[midx]);\n    fields->use_viscol = TRUE;\n    return QF_OK;\n}\n\n/*\n * Parse the match for the search text ('%s') pattern in regmatch.\n * Return the matched value in \"fields->pattern\".\n */\n    static int\nqf_parse_fmt_s(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    int\t\tlen;\n\n    if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL)\n\treturn QF_FAIL;\n    len = (int)(rmp->endp[midx] - rmp->startp[midx]);\n    if (len > CMDBUFFSIZE - 5)\n\tlen = CMDBUFFSIZE - 5;\n    STRCPY(fields->pattern, \"^\\\\V\");\n    STRNCAT(fields->pattern, rmp->startp[midx], len);\n    fields->pattern[len + 3] = '\\\\';\n    fields->pattern[len + 4] = '$';\n    fields->pattern[len + 5] = NUL;\n    return QF_OK;\n}\n\n/*\n * Parse the match for the module ('%o') pattern in regmatch.\n * Return the matched value in \"fields->module\".\n */\n    static int\nqf_parse_fmt_o(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    int\t\tlen;\n\n    if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL)\n\treturn QF_FAIL;\n    len = (int)(rmp->endp[midx] - rmp->startp[midx]);\n    if (len > CMDBUFFSIZE)\n\tlen = CMDBUFFSIZE;\n    STRNCAT(fields->module, rmp->startp[midx], len);\n    return QF_OK;\n}\n\n/*\n * 'errorformat' format pattern parser functions.\n * The '%f' and '%r' formats are parsed differently from other formats.\n * See qf_parse_match() for details.\n * Keep in sync with fmt_pat[].\n */\nstatic int (*qf_parse_fmt[FMT_PATTERNS])(regmatch_T *, int, qffields_T *) =\n{\n    NULL, // %f\n    qf_parse_fmt_n,\n    qf_parse_fmt_l,\n    qf_parse_fmt_e,\n    qf_parse_fmt_c,\n    qf_parse_fmt_k,\n    qf_parse_fmt_t,\n    qf_parse_fmt_m,\n    NULL, // %r\n    qf_parse_fmt_p,\n    qf_parse_fmt_v,\n    qf_parse_fmt_s,\n    qf_parse_fmt_o\n};\n\n/*\n * Parse the error format pattern matches in \"regmatch\" and set the values in\n * \"fields\".  fmt_ptr contains the 'efm' format specifiers/prefixes that have a\n * match.  Returns QF_OK if all the matches are successfully parsed. On\n * failure, returns QF_FAIL or QF_NOMEM.\n */\n    static int\nqf_parse_match(\n\tchar_u\t\t*linebuf,\n\tint\t\tlinelen,\n\tefm_T\t\t*fmt_ptr,\n\tregmatch_T\t*regmatch,\n\tqffields_T\t*fields,\n\tint\t\tqf_multiline,\n\tint\t\tqf_multiscan,\n\tchar_u\t\t**tail)\n{\n    int\t\tidx = fmt_ptr->prefix;\n    int\t\ti;\n    int\t\tmidx;\n    int\t\tstatus;\n\n    if ((idx == 'C' || idx == 'Z') && !qf_multiline)\n\treturn QF_FAIL;\n    if (vim_strchr((char_u *)\"EWIN\", idx) != NULL)\n\tfields->type = idx;\n    else\n\tfields->type = 0;\n\n    // Extract error message data from matched line.\n    // We check for an actual submatch, because \"\\[\" and \"\\]\" in\n    // the 'errorformat' may cause the wrong submatch to be used.\n    for (i = 0; i < FMT_PATTERNS; i++)\n    {\n\tstatus = QF_OK;\n\tmidx = (int)fmt_ptr->addr[i];\n\tif (i == 0 && midx > 0)\t\t\t\t// %f\n\t    status = qf_parse_fmt_f(regmatch, midx, fields, idx);\n\telse if (i == FMT_PATTERN_M)\n\t{\n\t    if (fmt_ptr->flags == '+' && !qf_multiscan)\t// %+\n\t\tstatus = copy_nonerror_line(linebuf, linelen, fields);\n\t    else if (midx > 0)\t\t\t\t// %m\n\t\tstatus = qf_parse_fmt_m(regmatch, midx, fields);\n\t}\n\telse if (i == FMT_PATTERN_R && midx > 0)\t// %r\n\t    status = qf_parse_fmt_r(regmatch, midx, tail);\n\telse if (midx > 0)\t\t\t\t// others\n\t    status = (qf_parse_fmt[i])(regmatch, midx, fields);\n\n\tif (status != QF_OK)\n\t    return status;\n    }\n\n    return QF_OK;\n}\n\n/*\n * Parse an error line in 'linebuf' using a single error format string in\n * 'fmt_ptr->prog' and return the matching values in 'fields'.\n * Returns QF_OK if the efm format matches completely and the fields are\n * successfully copied. Otherwise returns QF_FAIL or QF_NOMEM.\n */\n    static int\nqf_parse_get_fields(\n\tchar_u\t\t*linebuf,\n\tint\t\tlinelen,\n\tefm_T\t\t*fmt_ptr,\n\tqffields_T\t*fields,\n\tint\t\tqf_multiline,\n\tint\t\tqf_multiscan,\n\tchar_u\t\t**tail)\n{\n    regmatch_T\tregmatch;\n    int\t\tstatus = QF_FAIL;\n    int\t\tr;\n\n    if (qf_multiscan &&\n\t\tvim_strchr((char_u *)\"OPQ\", fmt_ptr->prefix) == NULL)\n\treturn QF_FAIL;\n\n    fields->namebuf[0] = NUL;\n    fields->module[0] = NUL;\n    fields->pattern[0] = NUL;\n    if (!qf_multiscan)\n\tfields->errmsg[0] = NUL;\n    fields->lnum = 0;\n    fields->end_lnum = 0;\n    fields->col = 0;\n    fields->end_col = 0;\n    fields->use_viscol = FALSE;\n    fields->enr = -1;\n    fields->type = 0;\n    *tail = NULL;\n\n    // Always ignore case when looking for a matching error.\n    regmatch.rm_ic = TRUE;\n    regmatch.regprog = fmt_ptr->prog;\n    r = vim_regexec(&regmatch, linebuf, (colnr_T)0);\n    fmt_ptr->prog = regmatch.regprog;\n    if (r)\n\tstatus = qf_parse_match(linebuf, linelen, fmt_ptr, &regmatch,\n\t\tfields, qf_multiline, qf_multiscan, tail);\n\n    return status;\n}\n\n/*\n * Parse directory error format prefixes (%D and %X).\n * Push and pop directories from the directory stack when scanning directory\n * names.\n */\n    static int\nqf_parse_dir_pfx(int idx, qffields_T *fields, qf_list_T *qfl)\n{\n    if (idx == 'D')\t\t\t\t// enter directory\n    {\n\tif (*fields->namebuf == NUL)\n\t{\n\t    emsg(_(e_missing_or_empty_directory_name));\n\t    return QF_FAIL;\n\t}\n\tqfl->qf_directory =\n\t    qf_push_dir(fields->namebuf, &qfl->qf_dir_stack, FALSE);\n\tif (qfl->qf_directory == NULL)\n\t    return QF_FAIL;\n    }\n    else if (idx == 'X')\t\t\t// leave directory\n\tqfl->qf_directory = qf_pop_dir(&qfl->qf_dir_stack);\n\n    return QF_OK;\n}\n\n/*\n * Parse global file name error format prefixes (%O, %P and %Q).\n */\n    static int\nqf_parse_file_pfx(\n\tint idx,\n\tqffields_T *fields,\n\tqf_list_T *qfl,\n\tchar_u *tail)\n{\n    fields->valid = FALSE;\n    if (*fields->namebuf == NUL || mch_getperm(fields->namebuf) >= 0)\n    {\n\tif (*fields->namebuf && idx == 'P')\n\t    qfl->qf_currfile =\n\t\tqf_push_dir(fields->namebuf, &qfl->qf_file_stack, TRUE);\n\telse if (idx == 'Q')\n\t    qfl->qf_currfile = qf_pop_dir(&qfl->qf_file_stack);\n\t*fields->namebuf = NUL;\n\tif (tail && *tail)\n\t{\n\t    STRMOVE(IObuff, skipwhite(tail));\n\t    qfl->qf_multiscan = TRUE;\n\t    return QF_MULTISCAN;\n\t}\n    }\n\n    return QF_OK;\n}\n\n/*\n * Parse a non-error line (a line which doesn't match any of the error\n * format in 'efm').\n */\n    static int\nqf_parse_line_nomatch(char_u *linebuf, int linelen, qffields_T *fields)\n{\n    fields->namebuf[0] = NUL;\t// no match found, remove file name\n    fields->lnum = 0;\t\t// don't jump to this line\n    fields->valid = FALSE;\n\n    return copy_nonerror_line(linebuf, linelen, fields);\n}\n\n/*\n * Parse multi-line error format prefixes (%C and %Z)\n */\n    static int\nqf_parse_multiline_pfx(\n\tint idx,\n\tqf_list_T *qfl,\n\tqffields_T *fields)\n{\n    char_u\t\t*ptr;\n    int\t\t\tlen;\n\n    if (!qfl->qf_multiignore)\n    {\n\tqfline_T *qfprev = qfl->qf_last;\n\n\tif (qfprev == NULL)\n\t    return QF_FAIL;\n\tif (*fields->errmsg && !qfl->qf_multiignore)\n\t{\n\t    len = (int)STRLEN(qfprev->qf_text);\n\t    ptr = alloc_id(len + STRLEN(fields->errmsg) + 2,\n\t\t\t\t\t\taid_qf_multiline_pfx);\n\t    if (ptr == NULL)\n\t\treturn QF_FAIL;\n\t    STRCPY(ptr, qfprev->qf_text);\n\t    vim_free(qfprev->qf_text);\n\t    qfprev->qf_text = ptr;\n\t    *(ptr += len) = '\\n';\n\t    STRCPY(++ptr, fields->errmsg);\n\t}\n\tif (qfprev->qf_nr == -1)\n\t    qfprev->qf_nr = fields->enr;\n\tif (vim_isprintc(fields->type) && !qfprev->qf_type)\n\t    // only printable chars allowed\n\t    qfprev->qf_type = fields->type;\n\n\tif (!qfprev->qf_lnum)\n\t    qfprev->qf_lnum = fields->lnum;\n\tif (!qfprev->qf_end_lnum)\n\t    qfprev->qf_end_lnum = fields->end_lnum;\n\tif (!qfprev->qf_col)\n\t{\n\t    qfprev->qf_col = fields->col;\n\t    qfprev->qf_viscol = fields->use_viscol;\n\t}\n\tif (!qfprev->qf_end_col)\n\t    qfprev->qf_end_col = fields->end_col;\n\tif (!qfprev->qf_fnum)\n\t    qfprev->qf_fnum = qf_get_fnum(qfl,\n\t\t    qfl->qf_directory,\n\t\t    *fields->namebuf || qfl->qf_directory != NULL\n\t\t    ? fields->namebuf\n\t\t    : qfl->qf_currfile != NULL && fields->valid\n\t\t    ? qfl->qf_currfile : 0);\n    }\n    if (idx == 'Z')\n\tqfl->qf_multiline = qfl->qf_multiignore = FALSE;\n    line_breakcheck();\n\n    return QF_IGNORE_LINE;\n}\n\n/*\n * Parse a line and get the quickfix fields.\n * Return the QF_ status.\n */\n    static int\nqf_parse_line(\n\tqf_list_T\t*qfl,\n\tchar_u\t\t*linebuf,\n\tint\t\tlinelen,\n\tefm_T\t\t*fmt_first,\n\tqffields_T\t*fields)\n{\n    efm_T\t\t*fmt_ptr;\n    int\t\t\tidx = 0;\n    char_u\t\t*tail = NULL;\n    int\t\t\tstatus;\n\nrestofline:\n    // If there was no %> item start at the first pattern\n    if (fmt_start == NULL)\n\tfmt_ptr = fmt_first;\n    else\n    {\n\t// Otherwise start from the last used pattern\n\tfmt_ptr = fmt_start;\n\tfmt_start = NULL;\n    }\n\n    // Try to match each part of 'errorformat' until we find a complete\n    // match or no match.\n    fields->valid = TRUE;\n    for ( ; fmt_ptr != NULL; fmt_ptr = fmt_ptr->next)\n    {\n\tidx = fmt_ptr->prefix;\n\tstatus = qf_parse_get_fields(linebuf, linelen, fmt_ptr, fields,\n\t\t\t\tqfl->qf_multiline, qfl->qf_multiscan, &tail);\n\tif (status == QF_NOMEM)\n\t    return status;\n\tif (status == QF_OK)\n\t    break;\n    }\n    qfl->qf_multiscan = FALSE;\n\n    if (fmt_ptr == NULL || idx == 'D' || idx == 'X')\n    {\n\tif (fmt_ptr != NULL)\n\t{\n\t    // 'D' and 'X' directory specifiers\n\t    status = qf_parse_dir_pfx(idx, fields, qfl);\n\t    if (status != QF_OK)\n\t\treturn status;\n\t}\n\n\tstatus = qf_parse_line_nomatch(linebuf, linelen, fields);\n\tif (status != QF_OK)\n\t    return status;\n\n\tif (fmt_ptr == NULL)\n\t    qfl->qf_multiline = qfl->qf_multiignore = FALSE;\n    }\n    else if (fmt_ptr != NULL)\n    {\n\t// honor %> item\n\tif (fmt_ptr->conthere)\n\t    fmt_start = fmt_ptr;\n\n\tif (vim_strchr((char_u *)\"AEWIN\", idx) != NULL)\n\t{\n\t    qfl->qf_multiline = TRUE;\t// start of a multi-line message\n\t    qfl->qf_multiignore = FALSE;// reset continuation\n\t}\n\telse if (vim_strchr((char_u *)\"CZ\", idx) != NULL)\n\t{\t\t\t\t// continuation of multi-line msg\n\t    status = qf_parse_multiline_pfx(idx, qfl, fields);\n\t    if (status != QF_OK)\n\t\treturn status;\n\t}\n\telse if (vim_strchr((char_u *)\"OPQ\", idx) != NULL)\n\t{\t\t\t\t// global file names\n\t    status = qf_parse_file_pfx(idx, fields, qfl, tail);\n\t    if (status == QF_MULTISCAN)\n\t\tgoto restofline;\n\t}\n\tif (fmt_ptr->flags == '-')\t// generally exclude this line\n\t{\n\t    if (qfl->qf_multiline)\n\t\t// also exclude continuation lines\n\t\tqfl->qf_multiignore = TRUE;\n\t    return QF_IGNORE_LINE;\n\t}\n    }\n\n    return QF_OK;\n}\n\n/*\n * Returns TRUE if the specified quickfix/location stack is empty\n */\n    static int\nqf_stack_empty(qf_info_T *qi)\n{\n    return qi == NULL || qi->qf_listcount <= 0;\n}\n\n/*\n * Returns TRUE if the specified quickfix/location list is empty.\n */\n    static int\nqf_list_empty(qf_list_T *qfl)\n{\n    return qfl == NULL || qfl->qf_count <= 0;\n}\n\n/*\n * Returns TRUE if the specified quickfix/location list is not empty and\n * has valid entries.\n */\n    static int\nqf_list_has_valid_entries(qf_list_T *qfl)\n{\n    return !qf_list_empty(qfl) && !qfl->qf_nonevalid;\n}\n\n/*\n * Return a pointer to a list in the specified quickfix stack\n */\n    static qf_list_T *\nqf_get_list(qf_info_T *qi, int idx)\n{\n    return &qi->qf_lists[idx];\n}\n\n/*\n * Allocate the fields used for parsing lines and populating a quickfix list.\n */\n    static int\nqf_alloc_fields(qffields_T *pfields)\n{\n    pfields->namebuf = alloc_id(CMDBUFFSIZE + 1, aid_qf_namebuf);\n    pfields->module = alloc_id(CMDBUFFSIZE + 1, aid_qf_module);\n    pfields->errmsglen = CMDBUFFSIZE + 1;\n    pfields->errmsg = alloc_id(pfields->errmsglen, aid_qf_errmsg);\n    pfields->pattern = alloc_id(CMDBUFFSIZE + 1, aid_qf_pattern);\n    if (pfields->namebuf == NULL || pfields->errmsg == NULL\n\t\t|| pfields->pattern == NULL || pfields->module == NULL)\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * Free the fields used for parsing lines and populating a quickfix list.\n */\n    static void\nqf_free_fields(qffields_T *pfields)\n{\n    vim_free(pfields->namebuf);\n    vim_free(pfields->module);\n    vim_free(pfields->errmsg);\n    vim_free(pfields->pattern);\n}\n\n/*\n * Setup the state information used for parsing lines and populating a\n * quickfix list.\n */\n    static int\nqf_setup_state(\n\tqfstate_T\t*pstate,\n\tchar_u\t\t*enc,\n\tchar_u\t\t*efile,\n\ttypval_T\t*tv,\n\tbuf_T\t\t*buf,\n\tlinenr_T\tlnumfirst,\n\tlinenr_T\tlnumlast)\n{\n    pstate->vc.vc_type = CONV_NONE;\n    if (enc != NULL && *enc != NUL)\n\tconvert_setup(&pstate->vc, enc, p_enc);\n\n    if (efile != NULL && (pstate->fd = mch_fopen((char *)efile, \"r\")) == NULL)\n    {\n\tsemsg(_(e_cant_open_errorfile_str), efile);\n\treturn FAIL;\n    }\n\n    if (tv != NULL)\n    {\n\tif (tv->v_type == VAR_STRING)\n\t    pstate->p_str = tv->vval.v_string;\n\telse if (tv->v_type == VAR_LIST)\n\t    pstate->p_li = tv->vval.v_list->lv_first;\n\tpstate->tv = tv;\n    }\n    pstate->buf = buf;\n    pstate->buflnum = lnumfirst;\n    pstate->lnumlast = lnumlast;\n\n    return OK;\n}\n\n/*\n * Cleanup the state information used for parsing lines and populating a\n * quickfix list.\n */\n    static void\nqf_cleanup_state(qfstate_T *pstate)\n{\n    if (pstate->fd != NULL)\n\tfclose(pstate->fd);\n\n    vim_free(pstate->growbuf);\n    if (pstate->vc.vc_type != CONV_NONE)\n\tconvert_setup(&pstate->vc, NULL, NULL);\n}\n\n/*\n * Process the next line from a file/buffer/list/string and add it\n * to the quickfix list 'qfl'.\n */\n    static int\nqf_init_process_nextline(\n\tqf_list_T\t*qfl,\n\tefm_T\t\t*fmt_first,\n\tqfstate_T\t*state,\n\tqffields_T\t*fields)\n{\n    int\t\t    status;\n\n    // Get the next line from a file/buffer/list/string\n    status = qf_get_nextline(state);\n    if (status != QF_OK)\n\treturn status;\n\n    status = qf_parse_line(qfl, state->linebuf, state->linelen,\n\t    fmt_first, fields);\n    if (status != QF_OK)\n\treturn status;\n\n    return qf_add_entry(qfl,\n\t\tqfl->qf_directory,\n\t\t(*fields->namebuf || qfl->qf_directory != NULL)\n\t\t? fields->namebuf\n\t\t: ((qfl->qf_currfile != NULL && fields->valid)\n\t\t    ? qfl->qf_currfile : (char_u *)NULL),\n\t\tfields->module,\n\t\t0,\n\t\tfields->errmsg,\n\t\tfields->lnum,\n\t\tfields->end_lnum,\n\t\tfields->col,\n\t\tfields->end_col,\n\t\tfields->use_viscol,\n\t\tfields->pattern,\n\t\tfields->enr,\n\t\tfields->type,\n\t\tfields->valid);\n}\n\n/*\n * Read the errorfile \"efile\" into memory, line by line, building the error\n * list.\n * Alternative: when \"efile\" is NULL read errors from buffer \"buf\".\n * Alternative: when \"tv\" is not NULL get errors from the string or list.\n * Always use 'errorformat' from \"buf\" if there is a local value.\n * Then \"lnumfirst\" and \"lnumlast\" specify the range of lines to use.\n * Set the title of the list to \"qf_title\".\n * Return -1 for error, number of errors for success.\n */\n    static int\nqf_init_ext(\n    qf_info_T\t    *qi,\n    int\t\t    qf_idx,\n    char_u\t    *efile,\n    buf_T\t    *buf,\n    typval_T\t    *tv,\n    char_u\t    *errorformat,\n    int\t\t    newlist,\t\t// TRUE: start a new error list\n    linenr_T\t    lnumfirst,\t\t// first line number to use\n    linenr_T\t    lnumlast,\t\t// last line number to use\n    char_u\t    *qf_title,\n    char_u\t    *enc)\n{\n    qf_list_T\t    *qfl;\n    qfstate_T\t    state;\n    qffields_T\t    fields;\n    qfline_T\t    *old_last = NULL;\n    int\t\t    adding = FALSE;\n    static efm_T    *fmt_first = NULL;\n    char_u\t    *efm;\n    static char_u   *last_efm = NULL;\n    int\t\t    retval = -1;\t// default: return error flag\n    int\t\t    status;\n\n    // Do not used the cached buffer, it may have been wiped out.\n    VIM_CLEAR(qf_last_bufname);\n\n    CLEAR_FIELD(state);\n    CLEAR_FIELD(fields);\n    if ((qf_alloc_fields(&fields) == FAIL) ||\n\t\t(qf_setup_state(&state, enc, efile, tv, buf,\n\t\t\t\t\tlnumfirst, lnumlast) == FAIL))\n\tgoto qf_init_end;\n\n    if (newlist || qf_idx == qi->qf_listcount)\n    {\n\t// make place for a new list\n\tqf_new_list(qi, qf_title);\n\tqf_idx = qi->qf_curlist;\n\tqfl = qf_get_list(qi, qf_idx);\n    }\n    else\n    {\n\t// Adding to existing list, use last entry.\n\tadding = TRUE;\n\tqfl = qf_get_list(qi, qf_idx);\n\tif (!qf_list_empty(qfl))\n\t    old_last = qfl->qf_last;\n    }\n\n    // Use the local value of 'errorformat' if it's set.\n    if (errorformat == p_efm && tv == NULL && *buf->b_p_efm != NUL)\n\tefm = buf->b_p_efm;\n    else\n\tefm = errorformat;\n\n    // If the errorformat didn't change between calls, then reuse the\n    // previously parsed values.\n    if (last_efm == NULL || (STRCMP(last_efm, efm) != 0))\n    {\n\t// free the previously parsed data\n\tVIM_CLEAR(last_efm);\n\tfree_efm_list(&fmt_first);\n\n\t// parse the current 'efm'\n\tfmt_first = parse_efm_option(efm);\n\tif (fmt_first != NULL)\n\t    last_efm = vim_strsave(efm);\n    }\n\n    if (fmt_first == NULL)\t// nothing found\n\tgoto error2;\n\n    // got_int is reset here, because it was probably set when killing the\n    // \":make\" command, but we still want to read the errorfile then.\n    got_int = FALSE;\n\n    // Read the lines in the error file one by one.\n    // Try to recognize one of the error formats in each line.\n    while (!got_int)\n    {\n\tstatus = qf_init_process_nextline(qfl, fmt_first, &state, &fields);\n\tif (status == QF_NOMEM)\t\t// memory alloc failure\n\t    goto qf_init_end;\n\tif (status == QF_END_OF_INPUT)\t// end of input\n\t    break;\n\tif (status == QF_FAIL)\n\t    goto error2;\n\n\tline_breakcheck();\n    }\n    if (state.fd == NULL || !ferror(state.fd))\n    {\n\tif (qfl->qf_index == 0)\n\t{\n\t    // no valid entry found\n\t    qfl->qf_ptr = qfl->qf_start;\n\t    qfl->qf_index = 1;\n\t    qfl->qf_nonevalid = TRUE;\n\t}\n\telse\n\t{\n\t    qfl->qf_nonevalid = FALSE;\n\t    if (qfl->qf_ptr == NULL)\n\t\tqfl->qf_ptr = qfl->qf_start;\n\t}\n\t// return number of matches\n\tretval = qfl->qf_count;\n\tgoto qf_init_end;\n    }\n    emsg(_(e_error_while_reading_errorfile));\nerror2:\n    if (!adding)\n    {\n\t// Error when creating a new list. Free the new list\n\tqf_free(qfl);\n\tqi->qf_listcount--;\n\tif (qi->qf_curlist > 0)\n\t    --qi->qf_curlist;\n    }\nqf_init_end:\n    if (qf_idx == qi->qf_curlist)\n\tqf_update_buffer(qi, old_last);\n    qf_cleanup_state(&state);\n    qf_free_fields(&fields);\n\n    return retval;\n}\n\n/*\n * Read the errorfile \"efile\" into memory, line by line, building the error\n * list. Set the error list's title to qf_title.\n * Return -1 for error, number of errors for success.\n */\n    int\nqf_init(win_T\t    *wp,\n\tchar_u\t    *efile,\n\tchar_u\t    *errorformat,\n\tint\t    newlist,\t\t// TRUE: start a new error list\n\tchar_u\t    *qf_title,\n\tchar_u\t    *enc)\n{\n    qf_info_T\t    *qi = &ql_info;\n\n    if (wp != NULL)\n    {\n\tqi = ll_get_or_alloc_list(wp);\n\tif (qi == NULL)\n\t    return FAIL;\n    }\n\n    return qf_init_ext(qi, qi->qf_curlist, efile, curbuf, NULL, errorformat,\n\t    newlist, (linenr_T)0, (linenr_T)0, qf_title, enc);\n}\n\n/*\n * Set the title of the specified quickfix list. Frees the previous title.\n * Prepends ':' to the title.\n */\n    static void\nqf_store_title(qf_list_T *qfl, char_u *title)\n{\n    VIM_CLEAR(qfl->qf_title);\n\n    if (title != NULL)\n    {\n\tchar_u *p = alloc_id(STRLEN(title) + 2, aid_qf_title);\n\n\tqfl->qf_title = p;\n\tif (p != NULL)\n\t    STRCPY(p, title);\n    }\n}\n\n/*\n * The title of a quickfix/location list is set, by default, to the command\n * that created the quickfix list with the \":\" prefix.\n * Create a quickfix list title string by prepending \":\" to a user command.\n * Returns a pointer to a static buffer with the title.\n */\n    static char_u *\nqf_cmdtitle(char_u *cmd)\n{\n    static char_u qftitle_str[IOSIZE];\n\n    vim_snprintf((char *)qftitle_str, IOSIZE, \":%s\", (char *)cmd);\n    return qftitle_str;\n}\n\n/*\n * Return a pointer to the current list in the specified quickfix stack\n */\n    static qf_list_T *\nqf_get_curlist(qf_info_T *qi)\n{\n    return qf_get_list(qi, qi->qf_curlist);\n}\n\n/*\n * Prepare for adding a new quickfix list. If the current list is in the\n * middle of the stack, then all the following lists are freed and then\n * the new list is added.\n */\n    static void\nqf_new_list(qf_info_T *qi, char_u *qf_title)\n{\n    int\t\ti;\n    qf_list_T\t*qfl;\n\n    // If the current entry is not the last entry, delete entries beyond\n    // the current entry.  This makes it possible to browse in a tree-like\n    // way with \":grep\".\n    while (qi->qf_listcount > qi->qf_curlist + 1)\n\tqf_free(&qi->qf_lists[--qi->qf_listcount]);\n\n    // When the stack is full, remove to oldest entry\n    // Otherwise, add a new entry.\n    if (qi->qf_listcount == LISTCOUNT)\n    {\n\tqf_free(&qi->qf_lists[0]);\n\tfor (i = 1; i < LISTCOUNT; ++i)\n\t    qi->qf_lists[i - 1] = qi->qf_lists[i];\n\tqi->qf_curlist = LISTCOUNT - 1;\n    }\n    else\n\tqi->qf_curlist = qi->qf_listcount++;\n    qfl = qf_get_curlist(qi);\n    CLEAR_POINTER(qfl);\n    qf_store_title(qfl, qf_title);\n    qfl->qfl_type = qi->qfl_type;\n    qfl->qf_id = ++last_qf_id;\n}\n\n/*\n * Queue location list stack delete request.\n */\n    static void\nlocstack_queue_delreq(qf_info_T *qi)\n{\n    qf_delq_T\t*q;\n\n    q = ALLOC_ONE(qf_delq_T);\n    if (q != NULL)\n    {\n\tq->qi = qi;\n\tq->next = qf_delq_head;\n\tqf_delq_head = q;\n    }\n}\n\n/*\n * Return the global quickfix stack window buffer number.\n */\n    int\nqf_stack_get_bufnr(void)\n{\n    return ql_info.qf_bufnr;\n}\n\n/*\n * Wipe the quickfix window buffer (if present) for the specified\n * quickfix/location list.\n */\n    static void\nwipe_qf_buffer(qf_info_T *qi)\n{\n    buf_T\t*qfbuf;\n\n    if (qi->qf_bufnr != INVALID_QFBUFNR)\n    {\n\tqfbuf = buflist_findnr(qi->qf_bufnr);\n\tif (qfbuf != NULL && qfbuf->b_nwindows == 0)\n\t{\n\t    // If the quickfix buffer is not loaded in any window, then\n\t    // wipe the buffer.\n\t    close_buffer(NULL, qfbuf, DOBUF_WIPE, FALSE, FALSE);\n\t    qi->qf_bufnr = INVALID_QFBUFNR;\n\t}\n    }\n}\n\n/*\n * Free a location list stack\n */\n    static void\nll_free_all(qf_info_T **pqi)\n{\n    int\t\ti;\n    qf_info_T\t*qi;\n\n    qi = *pqi;\n    if (qi == NULL)\n\treturn;\n    *pqi = NULL;\t// Remove reference to this list\n\n    // If the location list is still in use, then queue the delete request\n    // to be processed later.\n    if (quickfix_busy > 0)\n    {\n\tlocstack_queue_delreq(qi);\n\treturn;\n    }\n\n    qi->qf_refcount--;\n    if (qi->qf_refcount < 1)\n    {\n\t// No references to this location list.\n\t// If the quickfix window buffer is loaded, then wipe it\n\twipe_qf_buffer(qi);\n\n\tfor (i = 0; i < qi->qf_listcount; ++i)\n\t    qf_free(qf_get_list(qi, i));\n\tvim_free(qi);\n    }\n}\n\n/*\n * Free all the quickfix/location lists in the stack.\n */\n    void\nqf_free_all(win_T *wp)\n{\n    int\t\ti;\n    qf_info_T\t*qi = &ql_info;\n\n    if (wp != NULL)\n    {\n\t// location list\n\tll_free_all(&wp->w_llist);\n\tll_free_all(&wp->w_llist_ref);\n    }\n    else\n\t// quickfix list\n\tfor (i = 0; i < qi->qf_listcount; ++i)\n\t    qf_free(qf_get_list(qi, i));\n}\n\n/*\n * Delay freeing of location list stacks when the quickfix code is running.\n * Used to avoid problems with autocmds freeing location list stacks when the\n * quickfix code is still referencing the stack.\n * Must always call decr_quickfix_busy() exactly once after this.\n */\n    static void\nincr_quickfix_busy(void)\n{\n    quickfix_busy++;\n}\n\n/*\n * Safe to free location list stacks. Process any delayed delete requests.\n */\n    static void\ndecr_quickfix_busy(void)\n{\n    if (--quickfix_busy == 0)\n    {\n\t// No longer referencing the location lists. Process all the pending\n\t// delete requests.\n\twhile (qf_delq_head != NULL)\n\t{\n\t    qf_delq_T\t*q = qf_delq_head;\n\n\t    qf_delq_head = q->next;\n\t    ll_free_all(&q->qi);\n\t    vim_free(q);\n\t}\n    }\n#ifdef ABORT_ON_INTERNAL_ERROR\n    if (quickfix_busy < 0)\n    {\n\temsg(\"quickfix_busy has become negative\");\n\tabort();\n    }\n#endif\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\ncheck_quickfix_busy(void)\n{\n    if (quickfix_busy != 0)\n    {\n\tsemsg(\"quickfix_busy not zero on exit: %ld\", (long)quickfix_busy);\n# ifdef ABORT_ON_INTERNAL_ERROR\n\tabort();\n# endif\n    }\n}\n#endif\n\n/*\n * Add an entry to the end of the list of errors.\n * Returns QF_OK on success or QF_FAIL on a memory allocation failure.\n */\n    static int\nqf_add_entry(\n    qf_list_T\t*qfl,\t\t// quickfix list entry\n    char_u\t*dir,\t\t// optional directory name\n    char_u\t*fname,\t\t// file name or NULL\n    char_u\t*module,\t// module name or NULL\n    int\t\tbufnum,\t\t// buffer number or zero\n    char_u\t*mesg,\t\t// message\n    long\tlnum,\t\t// line number\n    long\tend_lnum,\t// line number for end\n    int\t\tcol,\t\t// column\n    int\t\tend_col,\t// column for end\n    int\t\tvis_col,\t// using visual column\n    char_u\t*pattern,\t// search pattern\n    int\t\tnr,\t\t// error number\n    int\t\ttype,\t\t// type character\n    int\t\tvalid)\t\t// valid entry\n{\n    qfline_T\t*qfp;\n    qfline_T\t**lastp;\t// pointer to qf_last or NULL\n\n    if ((qfp = ALLOC_ONE_ID(qfline_T, aid_qf_qfline)) == NULL)\n\treturn QF_FAIL;\n    if (bufnum != 0)\n    {\n\tbuf_T *buf = buflist_findnr(bufnum);\n\n\tqfp->qf_fnum = bufnum;\n\tif (buf != NULL)\n\t    buf->b_has_qf_entry |=\n\t\tIS_QF_LIST(qfl) ? BUF_HAS_QF_ENTRY : BUF_HAS_LL_ENTRY;\n    }\n    else\n\tqfp->qf_fnum = qf_get_fnum(qfl, dir, fname);\n    if ((qfp->qf_text = vim_strsave(mesg)) == NULL)\n    {\n\tvim_free(qfp);\n\treturn QF_FAIL;\n    }\n    qfp->qf_lnum = lnum;\n    qfp->qf_end_lnum = end_lnum;\n    qfp->qf_col = col;\n    qfp->qf_end_col = end_col;\n    qfp->qf_viscol = vis_col;\n    if (pattern == NULL || *pattern == NUL)\n\tqfp->qf_pattern = NULL;\n    else if ((qfp->qf_pattern = vim_strsave(pattern)) == NULL)\n    {\n\tvim_free(qfp->qf_text);\n\tvim_free(qfp);\n\treturn QF_FAIL;\n    }\n    if (module == NULL || *module == NUL)\n\tqfp->qf_module = NULL;\n    else if ((qfp->qf_module = vim_strsave(module)) == NULL)\n    {\n\tvim_free(qfp->qf_text);\n\tvim_free(qfp->qf_pattern);\n\tvim_free(qfp);\n\treturn QF_FAIL;\n    }\n    qfp->qf_nr = nr;\n    if (type != 1 && !vim_isprintc(type)) // only printable chars allowed\n\ttype = 0;\n    qfp->qf_type = type;\n    qfp->qf_valid = valid;\n\n    lastp = &qfl->qf_last;\n    if (qf_list_empty(qfl))\t\t// first element in the list\n    {\n\tqfl->qf_start = qfp;\n\tqfl->qf_ptr = qfp;\n\tqfl->qf_index = 0;\n\tqfp->qf_prev = NULL;\n    }\n    else\n    {\n\tqfp->qf_prev = *lastp;\n\t(*lastp)->qf_next = qfp;\n    }\n    qfp->qf_next = NULL;\n    qfp->qf_cleared = FALSE;\n    *lastp = qfp;\n    ++qfl->qf_count;\n    if (qfl->qf_index == 0 && qfp->qf_valid)\t// first valid entry\n    {\n\tqfl->qf_index = qfl->qf_count;\n\tqfl->qf_ptr = qfp;\n    }\n\n    return QF_OK;\n}\n\n/*\n * Allocate a new quickfix/location list stack\n */\n    static qf_info_T *\nqf_alloc_stack(qfltype_T qfltype)\n{\n    qf_info_T *qi;\n\n    qi = ALLOC_CLEAR_ONE_ID(qf_info_T, aid_qf_qfinfo);\n    if (qi != NULL)\n    {\n\tqi->qf_refcount++;\n\tqi->qfl_type = qfltype;\n\tqi->qf_bufnr = INVALID_QFBUFNR;\n    }\n    return qi;\n}\n\n/*\n * Return the location list stack for window 'wp'.\n * If not present, allocate a location list stack\n */\n    static qf_info_T *\nll_get_or_alloc_list(win_T *wp)\n{\n    if (IS_LL_WINDOW(wp))\n\t// For a location list window, use the referenced location list\n\treturn wp->w_llist_ref;\n\n    // For a non-location list window, w_llist_ref should not point to a\n    // location list.\n    ll_free_all(&wp->w_llist_ref);\n\n    if (wp->w_llist == NULL)\n\twp->w_llist = qf_alloc_stack(QFLT_LOCATION);\t// new location list\n    return wp->w_llist;\n}\n\n/*\n * Get the quickfix/location list stack to use for the specified Ex command.\n * For a location list command, returns the stack for the current window.  If\n * the location list is not found, then returns NULL and prints an error\n * message if 'print_emsg' is TRUE.\n */\n    static qf_info_T *\nqf_cmd_get_stack(exarg_T *eap, int print_emsg)\n{\n    qf_info_T\t*qi = &ql_info;\n\n    if (is_loclist_cmd(eap->cmdidx))\n    {\n\tqi = GET_LOC_LIST(curwin);\n\tif (qi == NULL)\n\t{\n\t    if (print_emsg)\n\t\temsg(_(e_no_location_list));\n\t    return NULL;\n\t}\n    }\n\n    return qi;\n}\n\n/*\n * Get the quickfix/location list stack to use for the specified Ex command.\n * For a location list command, returns the stack for the current window.\n * If the location list is not present, then allocates a new one.\n * Returns NULL if the allocation fails.  For a location list command, sets\n * 'pwinp' to curwin.\n */\n    static qf_info_T *\nqf_cmd_get_or_alloc_stack(exarg_T *eap, win_T **pwinp)\n{\n    qf_info_T\t*qi = &ql_info;\n\n    if (is_loclist_cmd(eap->cmdidx))\n    {\n\tqi = ll_get_or_alloc_list(curwin);\n\tif (qi == NULL)\n\t    return NULL;\n\t*pwinp = curwin;\n    }\n\n    return qi;\n}\n\n/*\n * Copy location list entries from 'from_qfl' to 'to_qfl'.\n */\n    static int\ncopy_loclist_entries(qf_list_T *from_qfl, qf_list_T *to_qfl)\n{\n    int\t\ti;\n    qfline_T    *from_qfp;\n    qfline_T    *prevp;\n\n    // copy all the location entries in this list\n    FOR_ALL_QFL_ITEMS(from_qfl, from_qfp, i)\n    {\n\tif (qf_add_entry(to_qfl,\n\t\t    NULL,\n\t\t    NULL,\n\t\t    from_qfp->qf_module,\n\t\t    0,\n\t\t    from_qfp->qf_text,\n\t\t    from_qfp->qf_lnum,\n\t\t    from_qfp->qf_end_lnum,\n\t\t    from_qfp->qf_col,\n\t\t    from_qfp->qf_end_col,\n\t\t    from_qfp->qf_viscol,\n\t\t    from_qfp->qf_pattern,\n\t\t    from_qfp->qf_nr,\n\t\t    0,\n\t\t    from_qfp->qf_valid) == QF_FAIL)\n\t    return FAIL;\n\n\t// qf_add_entry() will not set the qf_num field, as the\n\t// directory and file names are not supplied. So the qf_fnum\n\t// field is copied here.\n\tprevp = to_qfl->qf_last;\n\tprevp->qf_fnum = from_qfp->qf_fnum;\t// file number\n\tprevp->qf_type = from_qfp->qf_type;\t// error type\n\tif (from_qfl->qf_ptr == from_qfp)\n\t    to_qfl->qf_ptr = prevp;\t\t// current location\n    }\n\n    return OK;\n}\n\n/*\n * Copy the specified location list 'from_qfl' to 'to_qfl'.\n */\n    static int\ncopy_loclist(qf_list_T *from_qfl, qf_list_T *to_qfl)\n{\n    // Some of the fields are populated by qf_add_entry()\n    to_qfl->qfl_type = from_qfl->qfl_type;\n    to_qfl->qf_nonevalid = from_qfl->qf_nonevalid;\n    to_qfl->qf_count = 0;\n    to_qfl->qf_index = 0;\n    to_qfl->qf_start = NULL;\n    to_qfl->qf_last = NULL;\n    to_qfl->qf_ptr = NULL;\n    if (from_qfl->qf_title != NULL)\n\tto_qfl->qf_title = vim_strsave(from_qfl->qf_title);\n    else\n\tto_qfl->qf_title = NULL;\n    if (from_qfl->qf_ctx != NULL)\n    {\n\tto_qfl->qf_ctx = alloc_tv();\n\tif (to_qfl->qf_ctx != NULL)\n\t    copy_tv(from_qfl->qf_ctx, to_qfl->qf_ctx);\n    }\n    else\n\tto_qfl->qf_ctx = NULL;\n    if (from_qfl->qf_qftf_cb.cb_name != NULL)\n\tcopy_callback(&to_qfl->qf_qftf_cb, &from_qfl->qf_qftf_cb);\n    else\n\tto_qfl->qf_qftf_cb.cb_name = NULL;\n\n    if (from_qfl->qf_count)\n\tif (copy_loclist_entries(from_qfl, to_qfl) == FAIL)\n\t    return FAIL;\n\n    to_qfl->qf_index = from_qfl->qf_index;\t// current index in the list\n\n    // Assign a new ID for the location list\n    to_qfl->qf_id = ++last_qf_id;\n    to_qfl->qf_changedtick = 0L;\n\n    // When no valid entries are present in the list, qf_ptr points to\n    // the first item in the list\n    if (to_qfl->qf_nonevalid)\n    {\n\tto_qfl->qf_ptr = to_qfl->qf_start;\n\tto_qfl->qf_index = 1;\n    }\n\n    return OK;\n}\n\n/*\n * Copy the location list stack 'from' window to 'to' window.\n */\n    void\ncopy_loclist_stack(win_T *from, win_T *to)\n{\n    qf_info_T\t*qi;\n    int\t\tidx;\n\n    // When copying from a location list window, copy the referenced\n    // location list. For other windows, copy the location list for\n    // that window.\n    if (IS_LL_WINDOW(from))\n\tqi = from->w_llist_ref;\n    else\n\tqi = from->w_llist;\n\n    if (qi == NULL)\t\t    // no location list to copy\n\treturn;\n\n    // allocate a new location list\n    if ((to->w_llist = qf_alloc_stack(QFLT_LOCATION)) == NULL)\n\treturn;\n\n    to->w_llist->qf_listcount = qi->qf_listcount;\n\n    // Copy the location lists one at a time\n    for (idx = 0; idx < qi->qf_listcount; ++idx)\n    {\n\tto->w_llist->qf_curlist = idx;\n\n\tif (copy_loclist(qf_get_list(qi, idx),\n\t\t\tqf_get_list(to->w_llist, idx)) == FAIL)\n\t{\n\t    qf_free_all(to);\n\t    return;\n\t}\n    }\n\n    to->w_llist->qf_curlist = qi->qf_curlist;\t// current list\n}\n\n/*\n * Get buffer number for file \"directory/fname\".\n * Also sets the b_has_qf_entry flag.\n */\n    static int\nqf_get_fnum(qf_list_T *qfl, char_u *directory, char_u *fname)\n{\n    char_u\t*ptr = NULL;\n    buf_T\t*buf;\n    char_u\t*bufname;\n\n    if (fname == NULL || *fname == NUL)\t\t// no file name\n\treturn 0;\n\n#ifdef VMS\n    vms_remove_version(fname);\n#endif\n#ifdef BACKSLASH_IN_FILENAME\n    if (directory != NULL)\n\tslash_adjust(directory);\n    slash_adjust(fname);\n#endif\n    if (directory != NULL && !vim_isAbsName(fname)\n\t    && (ptr = concat_fnames(directory, fname, TRUE)) != NULL)\n    {\n\t// Here we check if the file really exists.\n\t// This should normally be true, but if make works without\n\t// \"leaving directory\"-messages we might have missed a\n\t// directory change.\n\tif (mch_getperm(ptr) < 0)\n\t{\n\t    vim_free(ptr);\n\t    directory = qf_guess_filepath(qfl, fname);\n\t    if (directory)\n\t\tptr = concat_fnames(directory, fname, TRUE);\n\t    else\n\t\tptr = vim_strsave(fname);\n\t}\n\t// Use concatenated directory name and file name\n\tbufname = ptr;\n    }\n    else\n\tbufname = fname;\n\n    if (qf_last_bufname != NULL && STRCMP(bufname, qf_last_bufname) == 0\n\t    && bufref_valid(&qf_last_bufref))\n    {\n\tbuf = qf_last_bufref.br_buf;\n\tvim_free(ptr);\n    }\n    else\n    {\n\tvim_free(qf_last_bufname);\n\tbuf = buflist_new(bufname, NULL, (linenr_T)0, BLN_NOOPT);\n\tif (bufname == ptr)\n\t    qf_last_bufname = bufname;\n\telse\n\t    qf_last_bufname = vim_strsave(bufname);\n\tset_bufref(&qf_last_bufref, buf);\n    }\n    if (buf == NULL)\n\treturn 0;\n\n    buf->b_has_qf_entry =\n\t\t\tIS_QF_LIST(qfl) ? BUF_HAS_QF_ENTRY : BUF_HAS_LL_ENTRY;\n    return buf->b_fnum;\n}\n\n/*\n * Push dirbuf onto the directory stack and return pointer to actual dir or\n * NULL on error.\n */\n    static char_u *\nqf_push_dir(char_u *dirbuf, struct dir_stack_T **stackptr, int is_file_stack)\n{\n    struct dir_stack_T  *ds_new;\n    struct dir_stack_T  *ds_ptr;\n\n    // allocate new stack element and hook it in\n    ds_new = ALLOC_ONE_ID(struct dir_stack_T, aid_qf_dirstack);\n    if (ds_new == NULL)\n\treturn NULL;\n\n    ds_new->next = *stackptr;\n    *stackptr = ds_new;\n\n    // store directory on the stack\n    if (vim_isAbsName(dirbuf)\n\t    || (*stackptr)->next == NULL\n\t    || is_file_stack)\n\t(*stackptr)->dirname = vim_strsave(dirbuf);\n    else\n    {\n\t// Okay we don't have an absolute path.\n\t// dirbuf must be a subdir of one of the directories on the stack.\n\t// Let's search...\n\tds_new = (*stackptr)->next;\n\t(*stackptr)->dirname = NULL;\n\twhile (ds_new)\n\t{\n\t    vim_free((*stackptr)->dirname);\n\t    (*stackptr)->dirname = concat_fnames(ds_new->dirname, dirbuf,\n\t\t    TRUE);\n\t    if (mch_isdir((*stackptr)->dirname) == TRUE)\n\t\tbreak;\n\n\t    ds_new = ds_new->next;\n\t}\n\n\t// clean up all dirs we already left\n\twhile ((*stackptr)->next != ds_new)\n\t{\n\t    ds_ptr = (*stackptr)->next;\n\t    (*stackptr)->next = (*stackptr)->next->next;\n\t    vim_free(ds_ptr->dirname);\n\t    vim_free(ds_ptr);\n\t}\n\n\t// Nothing found -> it must be on top level\n\tif (ds_new == NULL)\n\t{\n\t    vim_free((*stackptr)->dirname);\n\t    (*stackptr)->dirname = vim_strsave(dirbuf);\n\t}\n    }\n\n    if ((*stackptr)->dirname != NULL)\n\treturn (*stackptr)->dirname;\n    else\n    {\n\tds_ptr = *stackptr;\n\t*stackptr = (*stackptr)->next;\n\tvim_free(ds_ptr);\n\treturn NULL;\n    }\n}\n\n/*\n * pop dirbuf from the directory stack and return previous directory or NULL if\n * stack is empty\n */\n    static char_u *\nqf_pop_dir(struct dir_stack_T **stackptr)\n{\n    struct dir_stack_T  *ds_ptr;\n\n    // TODO: Should we check if dirbuf is the directory on top of the stack?\n    // What to do if it isn't?\n\n    // pop top element and free it\n    if (*stackptr != NULL)\n    {\n\tds_ptr = *stackptr;\n\t*stackptr = (*stackptr)->next;\n\tvim_free(ds_ptr->dirname);\n\tvim_free(ds_ptr);\n    }\n\n    // return NEW top element as current dir or NULL if stack is empty\n    return *stackptr ? (*stackptr)->dirname : NULL;\n}\n\n/*\n * clean up directory stack\n */\n    static void\nqf_clean_dir_stack(struct dir_stack_T **stackptr)\n{\n    struct dir_stack_T  *ds_ptr;\n\n    while ((ds_ptr = *stackptr) != NULL)\n    {\n\t*stackptr = (*stackptr)->next;\n\tvim_free(ds_ptr->dirname);\n\tvim_free(ds_ptr);\n    }\n}\n\n/*\n * Check in which directory of the directory stack the given file can be\n * found.\n * Returns a pointer to the directory name or NULL if not found.\n * Cleans up intermediate directory entries.\n *\n * TODO: How to solve the following problem?\n * If we have this directory tree:\n *     ./\n *     ./aa\n *     ./aa/bb\n *     ./bb\n *     ./bb/x.c\n * and make says:\n *     making all in aa\n *     making all in bb\n *     x.c:9: Error\n * Then qf_push_dir thinks we are in ./aa/bb, but we are in ./bb.\n * qf_guess_filepath will return NULL.\n */\n    static char_u *\nqf_guess_filepath(qf_list_T *qfl, char_u *filename)\n{\n    struct dir_stack_T     *ds_ptr;\n    struct dir_stack_T     *ds_tmp;\n    char_u\t\t   *fullname;\n\n    // no dirs on the stack - there's nothing we can do\n    if (qfl->qf_dir_stack == NULL)\n\treturn NULL;\n\n    ds_ptr = qfl->qf_dir_stack->next;\n    fullname = NULL;\n    while (ds_ptr)\n    {\n\tvim_free(fullname);\n\tfullname = concat_fnames(ds_ptr->dirname, filename, TRUE);\n\n\t// If concat_fnames failed, just go on. The worst thing that can happen\n\t// is that we delete the entire stack.\n\tif ((fullname != NULL) && (mch_getperm(fullname) >= 0))\n\t    break;\n\n\tds_ptr = ds_ptr->next;\n    }\n\n    vim_free(fullname);\n\n    // clean up all dirs we already left\n    while (qfl->qf_dir_stack->next != ds_ptr)\n    {\n\tds_tmp = qfl->qf_dir_stack->next;\n\tqfl->qf_dir_stack->next = qfl->qf_dir_stack->next->next;\n\tvim_free(ds_tmp->dirname);\n\tvim_free(ds_tmp);\n    }\n\n    return ds_ptr == NULL ? NULL : ds_ptr->dirname;\n}\n\n/*\n * Returns TRUE if a quickfix/location list with the given identifier exists.\n */\n    static int\nqflist_valid(win_T *wp, int_u qf_id)\n{\n    qf_info_T\t*qi = &ql_info;\n    int\t\ti;\n\n    if (wp != NULL)\n    {\n\tif (!win_valid(wp))\n\t    return FALSE;\n\tqi = GET_LOC_LIST(wp);\t    // Location list\n\tif (qi == NULL)\n\t    return FALSE;\n    }\n\n    for (i = 0; i < qi->qf_listcount; ++i)\n\tif (qi->qf_lists[i].qf_id == qf_id)\n\t    return TRUE;\n\n    return FALSE;\n}\n\n/*\n * When loading a file from the quickfix, the autocommands may modify it.\n * This may invalidate the current quickfix entry.  This function checks\n * whether an entry is still present in the quickfix list.\n * Similar to location list.\n */\n    static int\nis_qf_entry_present(qf_list_T *qfl, qfline_T *qf_ptr)\n{\n    qfline_T\t*qfp;\n    int\t\ti;\n\n    // Search for the entry in the current list\n    FOR_ALL_QFL_ITEMS(qfl, qfp, i)\n\tif (qfp == qf_ptr)\n\t    break;\n\n    if (i > qfl->qf_count) // Entry is not found\n\treturn FALSE;\n\n    return TRUE;\n}\n\n/*\n * Get the next valid entry in the current quickfix/location list. The search\n * starts from the current entry.  Returns NULL on failure.\n */\n    static qfline_T *\nget_next_valid_entry(\n\tqf_list_T\t*qfl,\n\tqfline_T\t*qf_ptr,\n\tint\t\t*qf_index,\n\tint\t\tdir)\n{\n    int\t\t\tidx;\n    int\t\t\told_qf_fnum;\n\n    idx = *qf_index;\n    old_qf_fnum = qf_ptr->qf_fnum;\n\n    do\n    {\n\tif (idx == qfl->qf_count || qf_ptr->qf_next == NULL)\n\t    return NULL;\n\t++idx;\n\tqf_ptr = qf_ptr->qf_next;\n    } while ((!qfl->qf_nonevalid && !qf_ptr->qf_valid)\n\t    || (dir == FORWARD_FILE && qf_ptr->qf_fnum == old_qf_fnum));\n\n    *qf_index = idx;\n    return qf_ptr;\n}\n\n/*\n * Get the previous valid entry in the current quickfix/location list. The\n * search starts from the current entry.  Returns NULL on failure.\n */\n    static qfline_T *\nget_prev_valid_entry(\n\tqf_list_T\t*qfl,\n\tqfline_T\t*qf_ptr,\n\tint\t\t*qf_index,\n\tint\t\tdir)\n{\n    int\t\t\tidx;\n    int\t\t\told_qf_fnum;\n\n    idx = *qf_index;\n    old_qf_fnum = qf_ptr->qf_fnum;\n\n    do\n    {\n\tif (idx == 1 || qf_ptr->qf_prev == NULL)\n\t    return NULL;\n\t--idx;\n\tqf_ptr = qf_ptr->qf_prev;\n    } while ((!qfl->qf_nonevalid && !qf_ptr->qf_valid)\n\t    || (dir == BACKWARD_FILE && qf_ptr->qf_fnum == old_qf_fnum));\n\n    *qf_index = idx;\n    return qf_ptr;\n}\n\n/*\n * Get the n'th (errornr) previous/next valid entry from the current entry in\n * the quickfix list.\n *   dir == FORWARD or FORWARD_FILE: next valid entry\n *   dir == BACKWARD or BACKWARD_FILE: previous valid entry\n */\n    static qfline_T *\nget_nth_valid_entry(\n\tqf_list_T\t*qfl,\n\tint\t\terrornr,\n\tint\t\tdir,\n\tint\t\t*new_qfidx)\n{\n    qfline_T\t\t*qf_ptr = qfl->qf_ptr;\n    int\t\t\tqf_idx = qfl->qf_index;\n    qfline_T\t\t*prev_qf_ptr;\n    int\t\t\tprev_index;\n    char\t\t*err = e_no_more_items;\n\n    while (errornr--)\n    {\n\tprev_qf_ptr = qf_ptr;\n\tprev_index = qf_idx;\n\n\tif (dir == FORWARD || dir == FORWARD_FILE)\n\t    qf_ptr = get_next_valid_entry(qfl, qf_ptr, &qf_idx, dir);\n\telse\n\t    qf_ptr = get_prev_valid_entry(qfl, qf_ptr, &qf_idx, dir);\n\tif (qf_ptr == NULL)\n\t{\n\t    qf_ptr = prev_qf_ptr;\n\t    qf_idx = prev_index;\n\t    if (err != NULL)\n\t    {\n\t\temsg(_(err));\n\t\treturn NULL;\n\t    }\n\t    break;\n\t}\n\n\terr = NULL;\n    }\n\n    *new_qfidx = qf_idx;\n    return qf_ptr;\n}\n\n/*\n * Get n'th (errornr) quickfix entry from the current entry in the quickfix\n * list 'qfl'. Returns a pointer to the new entry and the index in 'new_qfidx'\n */\n    static qfline_T *\nget_nth_entry(qf_list_T *qfl, int errornr, int *new_qfidx)\n{\n    qfline_T\t*qf_ptr = qfl->qf_ptr;\n    int\t\tqf_idx = qfl->qf_index;\n\n    // New error number is less than the current error number\n    while (errornr < qf_idx && qf_idx > 1 && qf_ptr->qf_prev != NULL)\n    {\n\t--qf_idx;\n\tqf_ptr = qf_ptr->qf_prev;\n    }\n    // New error number is greater than the current error number\n    while (errornr > qf_idx && qf_idx < qfl->qf_count &&\n\t\t\t\t\t\tqf_ptr->qf_next != NULL)\n    {\n\t++qf_idx;\n\tqf_ptr = qf_ptr->qf_next;\n    }\n\n    *new_qfidx = qf_idx;\n    return qf_ptr;\n}\n\n/*\n * Get a entry specified by 'errornr' and 'dir' from the current\n * quickfix/location list. 'errornr' specifies the index of the entry and 'dir'\n * specifies the direction (FORWARD/BACKWARD/FORWARD_FILE/BACKWARD_FILE).\n * Returns a pointer to the entry and the index of the new entry is stored in\n * 'new_qfidx'.\n */\n    static qfline_T *\nqf_get_entry(\n\tqf_list_T\t*qfl,\n\tint\t\terrornr,\n\tint\t\tdir,\n\tint\t\t*new_qfidx)\n{\n    qfline_T\t*qf_ptr = qfl->qf_ptr;\n    int\t\tqfidx = qfl->qf_index;\n\n    if (dir != 0)    // next/prev valid entry\n\tqf_ptr = get_nth_valid_entry(qfl, errornr, dir, &qfidx);\n    else if (errornr != 0)\t// go to specified number\n\tqf_ptr = get_nth_entry(qfl, errornr, &qfidx);\n\n    *new_qfidx = qfidx;\n    return qf_ptr;\n}\n\n/*\n * Find a window displaying a Vim help file in the current tab page.\n */\n    static win_T *\nqf_find_help_win(void)\n{\n    win_T *wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (bt_help(wp->w_buffer))\n\t    return wp;\n\n    return NULL;\n}\n\n/*\n * Set the location list for the specified window to 'qi'.\n */\n    static void\nwin_set_loclist(win_T *wp, qf_info_T *qi)\n{\n    wp->w_llist = qi;\n    qi->qf_refcount++;\n}\n\n/*\n * Find a help window or open one. If 'newwin' is TRUE, then open a new help\n * window.\n */\n    static int\njump_to_help_window(qf_info_T *qi, int newwin, int *opened_window)\n{\n    win_T\t*wp;\n    int\t\tflags;\n\n    if (cmdmod.cmod_tab != 0 || newwin)\n\twp = NULL;\n    else\n\twp = qf_find_help_win();\n    if (wp != NULL && wp->w_buffer->b_nwindows > 0)\n\twin_enter(wp, TRUE);\n    else\n    {\n\t// Split off help window; put it at far top if no position\n\t// specified, the current window is vertically split and narrow.\n\tflags = WSP_HELP;\n\tif (cmdmod.cmod_split == 0 && curwin->w_width != Columns\n\t\t&& curwin->w_width < 80)\n\t    flags |= WSP_TOP;\n\t// If the user asks to open a new window, then copy the location list.\n\t// Otherwise, don't copy the location list.\n\tif (IS_LL_STACK(qi) && !newwin)\n\t    flags |= WSP_NEWLOC;\n\n\tif (win_split(0, flags) == FAIL)\n\t    return FAIL;\n\n\t*opened_window = TRUE;\n\n\tif (curwin->w_height < p_hh)\n\t    win_setheight((int)p_hh);\n\n\t// When using location list, the new window should use the supplied\n\t// location list. If the user asks to open a new window, then the new\n\t// window will get a copy of the location list.\n\tif (IS_LL_STACK(qi) && !newwin)\n\t    win_set_loclist(curwin, qi);\n    }\n\n    if (!p_im)\n\trestart_edit = 0;\t    // don't want insert mode in help file\n\n    return OK;\n}\n\n/*\n * Find a non-quickfix window using the given location list stack in the\n * current tabpage.\n * Returns NULL if a matching window is not found.\n */\n    static win_T *\nqf_find_win_with_loclist(qf_info_T *ll)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_llist == ll && !bt_quickfix(wp->w_buffer))\n\t    return wp;\n\n    return NULL;\n}\n\n/*\n * Find a window containing a normal buffer in the current tab page.\n */\n    static win_T *\nqf_find_win_with_normal_buf(void)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (bt_normal(wp->w_buffer))\n\t    return wp;\n\n    return NULL;\n}\n\n/*\n * Go to a window in any tabpage containing the specified file.  Returns TRUE\n * if successfully jumped to the window. Otherwise returns FALSE.\n */\n    static int\nqf_goto_tabwin_with_file(int fnum)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif (wp->w_buffer->b_fnum == fnum)\n\t{\n\t    goto_tabpage_win(tp, wp);\n\t    return TRUE;\n\t}\n\n    return FALSE;\n}\n\n/*\n * Create a new window to show a file above the quickfix window. Called when\n * only the quickfix window is present.\n */\n    static int\nqf_open_new_file_win(qf_info_T *ll_ref)\n{\n    int\t\tflags;\n\n    flags = WSP_ABOVE;\n    if (ll_ref != NULL)\n\tflags |= WSP_NEWLOC;\n    if (win_split(0, flags) == FAIL)\n\treturn FAIL;\t\t// not enough room for window\n    p_swb = empty_option;\t// don't split again\n    swb_flags = 0;\n    RESET_BINDING(curwin);\n    if (ll_ref != NULL)\n\t// The new window should use the location list from the\n\t// location list window\n\twin_set_loclist(curwin, ll_ref);\n    return OK;\n}\n\n/*\n * Go to a window that shows the right buffer. If the window is not found, go\n * to the window just above the location list window. This is used for opening\n * a file from a location window and not from a quickfix window. If some usable\n * window is previously found, then it is supplied in 'use_win'.\n */\n    static void\nqf_goto_win_with_ll_file(win_T *use_win, int qf_fnum, qf_info_T *ll_ref)\n{\n    win_T\t*win = use_win;\n\n    if (win == NULL)\n    {\n\t// Find the window showing the selected file in the current tab page.\n\tFOR_ALL_WINDOWS(win)\n\t    if (win->w_buffer->b_fnum == qf_fnum)\n\t\tbreak;\n\tif (win == NULL)\n\t{\n\t    // Find a previous usable window\n\t    win = curwin;\n\t    do\n\t    {\n\t\tif (bt_normal(win->w_buffer))\n\t\t    break;\n\t\tif (win->w_prev == NULL)\n\t\t    win = lastwin;\t// wrap around the top\n\t\telse\n\t\t    win = win->w_prev; // go to previous window\n\t    } while (win != curwin);\n\t}\n    }\n    win_goto(win);\n\n    // If the location list for the window is not set, then set it\n    // to the location list from the location window\n    if (win->w_llist == NULL && ll_ref != NULL)\n\twin_set_loclist(win, ll_ref);\n}\n\n/*\n * Go to a window that contains the specified buffer 'qf_fnum'. If a window is\n * not found, then go to the window just above the quickfix window. This is\n * used for opening a file from a quickfix window and not from a location\n * window.\n */\n    static void\nqf_goto_win_with_qfl_file(int qf_fnum)\n{\n    win_T\t*win;\n    win_T\t*altwin;\n\n    win = curwin;\n    altwin = NULL;\n    for (;;)\n    {\n\tif (win->w_buffer->b_fnum == qf_fnum)\n\t    break;\n\tif (win->w_prev == NULL)\n\t    win = lastwin;\t// wrap around the top\n\telse\n\t    win = win->w_prev;\t// go to previous window\n\n\tif (IS_QF_WINDOW(win))\n\t{\n\t    // Didn't find it, go to the window before the quickfix\n\t    // window, unless 'switchbuf' contains 'uselast': in this case we\n\t    // try to jump to the previously used window first.\n\t    if ((swb_flags & SWB_USELAST) && win_valid(prevwin))\n\t\twin = prevwin;\n\t    else if (altwin != NULL)\n\t\twin = altwin;\n\t    else if (curwin->w_prev != NULL)\n\t\twin = curwin->w_prev;\n\t    else\n\t\twin = curwin->w_next;\n\t    break;\n\t}\n\n\t// Remember a usable window.\n\tif (altwin == NULL && !win->w_p_pvw && bt_normal(win->w_buffer))\n\t    altwin = win;\n    }\n\n    win_goto(win);\n}\n\n/*\n * Find a suitable window for opening a file (qf_fnum) from the\n * quickfix/location list and jump to it.  If the file is already opened in a\n * window, jump to it. Otherwise open a new window to display the file. If\n * 'newwin' is TRUE, then always open a new window. This is called from either\n * a quickfix or a location list window.\n */\n    static int\nqf_jump_to_usable_window(int qf_fnum, int newwin, int *opened_window)\n{\n    win_T\t*usable_wp = NULL;\n    int\t\tusable_win = FALSE;\n    qf_info_T\t*ll_ref = NULL;\n\n    // If opening a new window, then don't use the location list referred by\n    // the current window.  Otherwise two windows will refer to the same\n    // location list.\n    if (!newwin)\n\tll_ref = curwin->w_llist_ref;\n\n    if (ll_ref != NULL)\n    {\n\t// Find a non-quickfix window with this location list\n\tusable_wp = qf_find_win_with_loclist(ll_ref);\n\tif (usable_wp != NULL)\n\t    usable_win = TRUE;\n    }\n\n    if (!usable_win)\n    {\n\t// Locate a window showing a normal buffer\n\twin_T\t*win = qf_find_win_with_normal_buf();\n\tif (win != NULL)\n\t    usable_win = TRUE;\n    }\n\n    // If no usable window is found and 'switchbuf' contains \"usetab\"\n    // then search in other tabs.\n    if (!usable_win && (swb_flags & SWB_USETAB))\n\tusable_win = qf_goto_tabwin_with_file(qf_fnum);\n\n    // If there is only one window and it is the quickfix window, create a\n    // new one above the quickfix window.\n    if ((ONE_WINDOW && bt_quickfix(curbuf)) || !usable_win || newwin)\n    {\n\tif (qf_open_new_file_win(ll_ref) != OK)\n\t    return FAIL;\n\t*opened_window = TRUE;\t// close it when fail\n    }\n    else\n    {\n\tif (curwin->w_llist_ref != NULL)\t// In a location window\n\t    qf_goto_win_with_ll_file(usable_wp, qf_fnum, ll_ref);\n\telse\t\t\t\t\t// In a quickfix window\n\t    qf_goto_win_with_qfl_file(qf_fnum);\n    }\n\n    return OK;\n}\n\n/*\n * Edit the selected file or help file.\n * Returns OK if successfully edited the file, FAIL on failing to open the\n * buffer and NOTDONE if the quickfix/location list was freed by an autocmd\n * when opening the buffer.\n */\n    static int\nqf_jump_edit_buffer(\n\tqf_info_T\t*qi,\n\tqfline_T\t*qf_ptr,\n\tint\t\tforceit,\n\tint\t\tprev_winid,\n\tint\t\t*opened_window)\n{\n    qf_list_T\t*qfl = qf_get_curlist(qi);\n    int\t\told_changedtick = qfl->qf_changedtick;\n    qfltype_T\tqfl_type = qfl->qfl_type;\n    int\t\tretval = OK;\n    int\t\told_qf_curlist = qi->qf_curlist;\n    int\t\tsave_qfid = qfl->qf_id;\n\n    if (qf_ptr->qf_type == 1)\n    {\n\t// Open help file (do_ecmd() will set b_help flag, readfile() will\n\t// set b_p_ro flag).\n\tif (!can_abandon(curbuf, forceit))\n\t{\n\t    no_write_message();\n\t    return FAIL;\n\t}\n\n\tretval = do_ecmd(qf_ptr->qf_fnum, NULL, NULL, NULL, (linenr_T)1,\n\t\tECMD_HIDE + ECMD_SET_HELP,\n\t\tprev_winid == curwin->w_id ? curwin : NULL);\n    }\n    else\n\tretval = buflist_getfile(qf_ptr->qf_fnum,\n\t\t(linenr_T)1, GETF_SETMARK | GETF_SWITCH, forceit);\n\n    // If a location list, check whether the associated window is still\n    // present.\n    if (qfl_type == QFLT_LOCATION)\n    {\n\twin_T\t*wp = win_id2wp(prev_winid);\n\n\tif (wp == NULL && curwin->w_llist != qi)\n\t{\n\t    emsg(_(e_current_window_was_closed));\n\t    *opened_window = FALSE;\n\t    return NOTDONE;\n\t}\n    }\n\n    if (qfl_type == QFLT_QUICKFIX && !qflist_valid(NULL, save_qfid))\n    {\n\temsg(_(e_current_quickfix_list_was_changed));\n\treturn NOTDONE;\n    }\n\n    // Check if the list was changed.  The pointers may happen to be identical,\n    // thus also check qf_changedtick.\n    if (old_qf_curlist != qi->qf_curlist\n\t    || old_changedtick != qfl->qf_changedtick\n\t    || !is_qf_entry_present(qfl, qf_ptr))\n    {\n\tif (qfl_type == QFLT_QUICKFIX)\n\t    emsg(_(e_current_quickfix_list_was_changed));\n\telse\n\t    emsg(_(e_current_location_list_was_changed));\n\treturn NOTDONE;\n    }\n\n    return retval;\n}\n\n/*\n * Go to the error line in the current file using either line/column number or\n * a search pattern.\n */\n    static void\nqf_jump_goto_line(\n\tlinenr_T\tqf_lnum,\n\tint\t\tqf_col,\n\tchar_u\t\tqf_viscol,\n\tchar_u\t\t*qf_pattern)\n{\n    linenr_T\t\ti;\n\n    if (qf_pattern == NULL)\n    {\n\t// Go to line with error, unless qf_lnum is 0.\n\ti = qf_lnum;\n\tif (i > 0)\n\t{\n\t    if (i > curbuf->b_ml.ml_line_count)\n\t\ti = curbuf->b_ml.ml_line_count;\n\t    curwin->w_cursor.lnum = i;\n\t}\n\tif (qf_col > 0)\n\t{\n\t    curwin->w_cursor.coladd = 0;\n\t    if (qf_viscol == TRUE)\n\t\tcoladvance(qf_col - 1);\n\t    else\n\t\tcurwin->w_cursor.col = qf_col - 1;\n\t    curwin->w_set_curswant = TRUE;\n\t    check_cursor();\n\t}\n\telse\n\t    beginline(BL_WHITE | BL_FIX);\n    }\n    else\n    {\n\tpos_T save_cursor;\n\n\t// Move the cursor to the first line in the buffer\n\tsave_cursor = curwin->w_cursor;\n\tcurwin->w_cursor.lnum = 0;\n\tif (!do_search(NULL, '/', '/', qf_pattern, (long)1, SEARCH_KEEP, NULL))\n\t    curwin->w_cursor = save_cursor;\n    }\n}\n\n/*\n * Display quickfix list index and size message\n */\n    static void\nqf_jump_print_msg(\n\tqf_info_T\t*qi,\n\tint\t\tqf_index,\n\tqfline_T\t*qf_ptr,\n\tbuf_T\t\t*old_curbuf,\n\tlinenr_T\told_lnum)\n{\n    linenr_T\t\ti;\n    int\t\t\tlen;\n\n    // Update the screen before showing the message, unless the screen\n    // scrolled up.\n    if (!msg_scrolled)\n\tupdate_topline_redraw();\n    sprintf((char *)IObuff, _(\"(%d of %d)%s%s: \"), qf_index,\n\t    qf_get_curlist(qi)->qf_count,\n\t    qf_ptr->qf_cleared ? _(\" (line deleted)\") : \"\",\n\t    (char *)qf_types(qf_ptr->qf_type, qf_ptr->qf_nr));\n    // Add the message, skipping leading whitespace and newlines.\n    len = (int)STRLEN(IObuff);\n    qf_fmt_text(skipwhite(qf_ptr->qf_text), IObuff + len, IOSIZE - len);\n\n    // Output the message.  Overwrite to avoid scrolling when the 'O'\n    // flag is present in 'shortmess'; But when not jumping, print the\n    // whole message.\n    i = msg_scroll;\n    if (curbuf == old_curbuf && curwin->w_cursor.lnum == old_lnum)\n\tmsg_scroll = TRUE;\n    else if (!msg_scrolled && shortmess(SHM_OVERALL))\n\tmsg_scroll = FALSE;\n    msg_attr_keep((char *)IObuff, 0, TRUE);\n    msg_scroll = i;\n}\n\n/*\n * Find a usable window for opening a file from the quickfix/location list. If\n * a window is not found then open a new window. If 'newwin' is TRUE, then open\n * a new window.\n * Returns OK if successfully jumped or opened a window. Returns FAIL if not\n * able to jump/open a window.  Returns NOTDONE if a file is not associated\n * with the entry.\n */\n    static int\nqf_jump_open_window(\n\tqf_info_T\t*qi,\n\tqfline_T\t*qf_ptr,\n\tint\t\tnewwin,\n\tint\t\t*opened_window)\n{\n    qf_list_T\t*qfl = qf_get_curlist(qi);\n    int\t\told_changedtick = qfl->qf_changedtick;\n    int\t\told_qf_curlist = qi->qf_curlist;\n    qfltype_T\tqfl_type = qfl->qfl_type;\n\n    // For \":helpgrep\" find a help window or open one.\n    if (qf_ptr->qf_type == 1 && (!bt_help(curwin->w_buffer)\n\t\t\t\t\t\t      || cmdmod.cmod_tab != 0))\n\tif (jump_to_help_window(qi, newwin, opened_window) == FAIL)\n\t    return FAIL;\n    if (old_qf_curlist != qi->qf_curlist\n\t    || old_changedtick != qfl->qf_changedtick\n\t    || !is_qf_entry_present(qfl, qf_ptr))\n    {\n\tif (qfl_type == QFLT_QUICKFIX)\n\t    emsg(_(e_current_quickfix_list_was_changed));\n\telse\n\t    emsg(_(e_current_location_list_was_changed));\n\treturn FAIL;\n    }\n\n    // If currently in the quickfix window, find another window to show the\n    // file in.\n    if (bt_quickfix(curbuf) && !*opened_window)\n    {\n\t// If there is no file specified, we don't know where to go.\n\t// But do advance, otherwise \":cn\" gets stuck.\n\tif (qf_ptr->qf_fnum == 0)\n\t    return NOTDONE;\n\n\tif (qf_jump_to_usable_window(qf_ptr->qf_fnum, newwin,\n\t\t\t\t\t\topened_window) == FAIL)\n\t    return FAIL;\n    }\n    if (old_qf_curlist != qi->qf_curlist\n\t    || old_changedtick != qfl->qf_changedtick\n\t    || !is_qf_entry_present(qfl, qf_ptr))\n    {\n\tif (qfl_type == QFLT_QUICKFIX)\n\t    emsg(_(e_current_quickfix_list_was_changed));\n\telse\n\t    emsg(_(e_current_location_list_was_changed));\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * Edit a selected file from the quickfix/location list and jump to a\n * particular line/column, adjust the folds and display a message about the\n * jump.\n * Returns OK on success and FAIL on failing to open the file/buffer.  Returns\n * NOTDONE if the quickfix/location list is freed by an autocmd when opening\n * the file.\n */\n    static int\nqf_jump_to_buffer(\n\tqf_info_T\t*qi,\n\tint\t\tqf_index,\n\tqfline_T\t*qf_ptr,\n\tint\t\tforceit,\n\tint\t\tprev_winid,\n\tint\t\t*opened_window,\n\tint\t\topenfold,\n\tint\t\tprint_message)\n{\n    buf_T\t*old_curbuf;\n    linenr_T\told_lnum;\n    int\t\tretval = OK;\n\n    // If there is a file name, read the wanted file if needed, and check\n    // autowrite etc.\n    old_curbuf = curbuf;\n    old_lnum = curwin->w_cursor.lnum;\n\n    if (qf_ptr->qf_fnum != 0)\n    {\n\tretval = qf_jump_edit_buffer(qi, qf_ptr, forceit, prev_winid,\n\t\t\t\t\t\topened_window);\n\tif (retval != OK)\n\t    return retval;\n    }\n\n    // When not switched to another buffer, still need to set pc mark\n    if (curbuf == old_curbuf)\n\tsetpcmark();\n\n    qf_jump_goto_line(qf_ptr->qf_lnum, qf_ptr->qf_col, qf_ptr->qf_viscol,\n\t    qf_ptr->qf_pattern);\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_QUICKFIX) && openfold)\n\tfoldOpenCursor();\n#endif\n    if (print_message)\n\tqf_jump_print_msg(qi, qf_index, qf_ptr, old_curbuf, old_lnum);\n\n    return retval;\n}\n\n/*\n * Jump to a quickfix line and try to use an existing window.\n */\n    void\nqf_jump(qf_info_T\t*qi,\n\tint\t\tdir,\n\tint\t\terrornr,\n\tint\t\tforceit)\n{\n    qf_jump_newwin(qi, dir, errornr, forceit, FALSE);\n}\n\n/*\n * Jump to a quickfix line.\n * If dir == 0 go to entry \"errornr\".\n * If dir == FORWARD go \"errornr\" valid entries forward.\n * If dir == BACKWARD go \"errornr\" valid entries backward.\n * If dir == FORWARD_FILE go \"errornr\" valid entries files backward.\n * If dir == BACKWARD_FILE go \"errornr\" valid entries files backward\n * else if \"errornr\" is zero, redisplay the same line\n * If 'forceit' is TRUE, then can discard changes to the current buffer.\n * If 'newwin' is TRUE, then open the file in a new window.\n */\n    static void\nqf_jump_newwin(qf_info_T\t*qi,\n\tint\t\tdir,\n\tint\t\terrornr,\n\tint\t\tforceit,\n\tint\t\tnewwin)\n{\n    qf_list_T\t\t*qfl;\n    qfline_T\t\t*qf_ptr;\n    qfline_T\t\t*old_qf_ptr;\n    int\t\t\tqf_index;\n    int\t\t\told_qf_index;\n    char_u\t\t*old_swb = p_swb;\n    unsigned\t\told_swb_flags = swb_flags;\n    int\t\t\tprev_winid;\n    int\t\t\topened_window = FALSE;\n    int\t\t\tprint_message = TRUE;\n    int\t\t\told_KeyTyped = KeyTyped; // getting file may reset it\n    int\t\t\tretval = OK;\n\n    if (qi == NULL)\n\tqi = &ql_info;\n\n    if (qf_stack_empty(qi) || qf_list_empty(qf_get_curlist(qi)))\n    {\n\temsg(_(e_no_errors));\n\treturn;\n    }\n\n    incr_quickfix_busy();\n\n    qfl = qf_get_curlist(qi);\n\n    qf_ptr = qfl->qf_ptr;\n    old_qf_ptr = qf_ptr;\n    qf_index = qfl->qf_index;\n    old_qf_index = qf_index;\n\n    qf_ptr = qf_get_entry(qfl, errornr, dir, &qf_index);\n    if (qf_ptr == NULL)\n    {\n\tqf_ptr = old_qf_ptr;\n\tqf_index = old_qf_index;\n\tgoto theend;\n    }\n\n    qfl->qf_index = qf_index;\n    qfl->qf_ptr = qf_ptr;\n    if (qf_win_pos_update(qi, old_qf_index))\n\t// No need to print the error message if it's visible in the error\n\t// window\n\tprint_message = FALSE;\n\n    prev_winid = curwin->w_id;\n\n    retval = qf_jump_open_window(qi, qf_ptr, newwin, &opened_window);\n    if (retval == FAIL)\n\tgoto failed;\n    if (retval == NOTDONE)\n\tgoto theend;\n\n    retval = qf_jump_to_buffer(qi, qf_index, qf_ptr, forceit, prev_winid,\n\t\t\t\t  &opened_window, old_KeyTyped, print_message);\n    if (retval == NOTDONE)\n    {\n\t// Quickfix/location list is freed by an autocmd\n\tqi = NULL;\n\tqf_ptr = NULL;\n    }\n\n    if (retval != OK)\n    {\n\tif (opened_window)\n\t    win_close(curwin, TRUE);    // Close opened window\n\tif (qf_ptr != NULL && qf_ptr->qf_fnum != 0)\n\t{\n\t    // Couldn't open file, so put index back where it was.  This could\n\t    // happen if the file was readonly and we changed something.\nfailed:\n\t    qf_ptr = old_qf_ptr;\n\t    qf_index = old_qf_index;\n\t}\n    }\ntheend:\n    if (qi != NULL)\n    {\n\tqfl->qf_ptr = qf_ptr;\n\tqfl->qf_index = qf_index;\n    }\n    if (p_swb != old_swb && p_swb == empty_option)\n    {\n\t// Restore old 'switchbuf' value, but not when an autocommand or\n\t// modeline has changed the value.\n\tp_swb = old_swb;\n\tswb_flags = old_swb_flags;\n    }\n    decr_quickfix_busy();\n}\n\n// Highlight attributes used for displaying entries from the quickfix list.\nstatic int\tqfFileAttr;\nstatic int\tqfSepAttr;\nstatic int\tqfLineAttr;\n\n/*\n * Display information about a single entry from the quickfix/location list.\n * Used by \":clist/:llist\" commands.\n * 'cursel' will be set to TRUE for the currently selected entry in the\n * quickfix list.\n */\n    static void\nqf_list_entry(qfline_T *qfp, int qf_idx, int cursel)\n{\n    char_u\t*fname;\n    buf_T\t*buf;\n    int\t\tfilter_entry;\n\n    fname = NULL;\n    if (qfp->qf_module != NULL && *qfp->qf_module != NUL)\n\tvim_snprintf((char *)IObuff, IOSIZE, \"%2d %s\", qf_idx,\n\t\t\t\t\t\t(char *)qfp->qf_module);\n    else {\n\tif (qfp->qf_fnum != 0\n\t\t&& (buf = buflist_findnr(qfp->qf_fnum)) != NULL)\n\t{\n\t    fname = buf->b_fname;\n\t    if (qfp->qf_type == 1)\t// :helpgrep\n\t\tfname = gettail(fname);\n\t}\n\tif (fname == NULL)\n\t    sprintf((char *)IObuff, \"%2d\", qf_idx);\n\telse\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%2d %s\",\n\t\t    qf_idx, (char *)fname);\n    }\n\n    // Support for filtering entries using :filter /pat/ clist\n    // Match against the module name, file name, search pattern and\n    // text of the entry.\n    filter_entry = TRUE;\n    if (qfp->qf_module != NULL && *qfp->qf_module != NUL)\n\tfilter_entry &= message_filtered(qfp->qf_module);\n    if (filter_entry && fname != NULL)\n\tfilter_entry &= message_filtered(fname);\n    if (filter_entry && qfp->qf_pattern != NULL)\n\tfilter_entry &= message_filtered(qfp->qf_pattern);\n    if (filter_entry)\n\tfilter_entry &= message_filtered(qfp->qf_text);\n    if (filter_entry)\n\treturn;\n\n    msg_putchar('\\n');\n    msg_outtrans_attr(IObuff, cursel ? HL_ATTR(HLF_QFL) : qfFileAttr);\n\n    if (qfp->qf_lnum != 0)\n\tmsg_puts_attr(\":\", qfSepAttr);\n    if (qfp->qf_lnum == 0)\n\tIObuff[0] = NUL;\n    else\n\tqf_range_text(qfp, IObuff, IOSIZE);\n    sprintf((char *)IObuff + STRLEN(IObuff), \"%s\",\n\t    (char *)qf_types(qfp->qf_type, qfp->qf_nr));\n    msg_puts_attr((char *)IObuff, qfLineAttr);\n    msg_puts_attr(\":\", qfSepAttr);\n    if (qfp->qf_pattern != NULL)\n    {\n\tqf_fmt_text(qfp->qf_pattern, IObuff, IOSIZE);\n\tmsg_puts((char *)IObuff);\n\tmsg_puts_attr(\":\", qfSepAttr);\n    }\n    msg_puts(\" \");\n\n    {\n\tchar_u *tbuf = IObuff;\n\tsize_t\ttbuflen = IOSIZE;\n\tsize_t\tlen = STRLEN(qfp->qf_text) + 3;\n\n\tif (len > IOSIZE)\n\t{\n\t    tbuf = alloc(len);\n\t    if (tbuf != NULL)\n\t\ttbuflen = len;\n\t    else\n\t\ttbuf = IObuff;\n\t}\n\n\t// Remove newlines and leading whitespace from the text.  For an\n\t// unrecognized line keep the indent, the compiler may mark a word\n\t// with ^^^^.\n\tqf_fmt_text((fname != NULL || qfp->qf_lnum != 0)\n\t\t\t\t    ? skipwhite(qfp->qf_text) : qfp->qf_text,\n\t\t\t\t    tbuf, (int)tbuflen);\n\tmsg_prt_line(tbuf, FALSE);\n\n\tif (tbuf != IObuff)\n\t    vim_free(tbuf);\n    }\n    out_flush();\t\t// show one line at a time\n}\n\n/*\n * \":clist\": list all errors\n * \":llist\": list all locations\n */\n    void\nqf_list(exarg_T *eap)\n{\n    qf_list_T\t*qfl;\n    qfline_T\t*qfp;\n    int\t\ti;\n    int\t\tidx1 = 1;\n    int\t\tidx2 = -1;\n    char_u\t*arg = eap->arg;\n    int\t\tplus = FALSE;\n    int\t\tall = eap->forceit;\t// if not :cl!, only show\n\t\t\t\t\t// recognised errors\n    qf_info_T\t*qi;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    if (qf_stack_empty(qi) || qf_list_empty(qf_get_curlist(qi)))\n    {\n\temsg(_(e_no_errors));\n\treturn;\n    }\n    if (*arg == '+')\n    {\n\t++arg;\n\tplus = TRUE;\n    }\n    if (!get_list_range(&arg, &idx1, &idx2) || *arg != NUL)\n    {\n\tsemsg(_(e_trailing_characters_str), arg);\n\treturn;\n    }\n    qfl = qf_get_curlist(qi);\n    if (plus)\n    {\n\ti = qfl->qf_index;\n\tidx2 = i + idx1;\n\tidx1 = i;\n    }\n    else\n    {\n\ti = qfl->qf_count;\n\tif (idx1 < 0)\n\t    idx1 = (-idx1 > i) ? 0 : idx1 + i + 1;\n\tif (idx2 < 0)\n\t    idx2 = (-idx2 > i) ? 0 : idx2 + i + 1;\n    }\n\n    // Shorten all the file names, so that it is easy to read\n    shorten_fnames(FALSE);\n\n    // Get the attributes for the different quickfix highlight items.  Note\n    // that this depends on syntax items defined in the qf.vim syntax file\n    qfFileAttr = syn_name2attr((char_u *)\"qfFileName\");\n    if (qfFileAttr == 0)\n\tqfFileAttr = HL_ATTR(HLF_D);\n    qfSepAttr = syn_name2attr((char_u *)\"qfSeparator\");\n    if (qfSepAttr == 0)\n\tqfSepAttr = HL_ATTR(HLF_D);\n    qfLineAttr = syn_name2attr((char_u *)\"qfLineNr\");\n    if (qfLineAttr == 0)\n\tqfLineAttr = HL_ATTR(HLF_N);\n\n    if (qfl->qf_nonevalid)\n\tall = TRUE;\n    FOR_ALL_QFL_ITEMS(qfl, qfp, i)\n    {\n\tif ((qfp->qf_valid || all) && idx1 <= i && i <= idx2)\n\t    qf_list_entry(qfp, i, i == qfl->qf_index);\n\n\tui_breakcheck();\n    }\n}\n\n/*\n * Remove newlines and leading whitespace from an error message.\n * Put the result in \"buf[bufsize]\".\n */\n    static void\nqf_fmt_text(char_u *text, char_u *buf, int bufsize)\n{\n    int\t\ti;\n    char_u\t*p = text;\n\n    for (i = 0; *p != NUL && i < bufsize - 1; ++i)\n    {\n\tif (*p == '\\n')\n\t{\n\t    buf[i] = ' ';\n\t    while (*++p != NUL)\n\t\tif (!VIM_ISWHITE(*p) && *p != '\\n')\n\t\t    break;\n\t}\n\telse\n\t    buf[i] = *p++;\n    }\n    buf[i] = NUL;\n}\n\n/*\n * Range information from lnum, col, end_lnum, and end_col.\n * Put the result in \"buf[bufsize]\".\n */\n    static void\nqf_range_text(qfline_T *qfp, char_u *buf, int bufsize)\n{\n    int len;\n    vim_snprintf((char *)buf, bufsize, \"%ld\", qfp->qf_lnum);\n    len = (int)STRLEN(buf);\n\n    if (qfp->qf_end_lnum > 0 && qfp->qf_lnum != qfp->qf_end_lnum)\n    {\n\tvim_snprintf((char *)buf + len, bufsize - len,\n\t\t\"-%ld\", qfp->qf_end_lnum);\n\tlen += (int)STRLEN(buf + len);\n    }\n    if (qfp->qf_col > 0)\n    {\n\tvim_snprintf((char *)buf + len, bufsize - len, \" col %d\", qfp->qf_col);\n\tlen += (int)STRLEN(buf + len);\n\tif (qfp->qf_end_col > 0 && qfp->qf_col != qfp->qf_end_col)\n\t{\n\t    vim_snprintf((char *)buf + len, bufsize - len,\n\t\t    \"-%d\", qfp->qf_end_col);\n\t    len += (int)STRLEN(buf + len);\n\t}\n    }\n    buf[len] = NUL;\n}\n\n/*\n * Display information (list number, list size and the title) about a\n * quickfix/location list.\n */\n    static void\nqf_msg(qf_info_T *qi, int which, char *lead)\n{\n    char   *title = (char *)qi->qf_lists[which].qf_title;\n    int    count = qi->qf_lists[which].qf_count;\n    char_u buf[IOSIZE];\n\n    vim_snprintf((char *)buf, IOSIZE, _(\"%serror list %d of %d; %d errors \"),\n\t    lead,\n\t    which + 1,\n\t    qi->qf_listcount,\n\t    count);\n\n    if (title != NULL)\n    {\n\tsize_t\tlen = STRLEN(buf);\n\n\tif (len < 34)\n\t{\n\t    vim_memset(buf + len, ' ', 34 - len);\n\t    buf[34] = NUL;\n\t}\n\tvim_strcat(buf, (char_u *)title, IOSIZE);\n    }\n    trunc_string(buf, buf, Columns - 1, IOSIZE);\n    msg((char *)buf);\n}\n\n/*\n * \":colder [count]\": Up in the quickfix stack.\n * \":cnewer [count]\": Down in the quickfix stack.\n * \":lolder [count]\": Up in the location list stack.\n * \":lnewer [count]\": Down in the location list stack.\n */\n    void\nqf_age(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    int\t\tcount;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    if (eap->addr_count != 0)\n\tcount = eap->line2;\n    else\n\tcount = 1;\n    while (count--)\n    {\n\tif (eap->cmdidx == CMD_colder || eap->cmdidx == CMD_lolder)\n\t{\n\t    if (qi->qf_curlist == 0)\n\t    {\n\t\temsg(_(e_at_bottom_of_quickfix_stack));\n\t\tbreak;\n\t    }\n\t    --qi->qf_curlist;\n\t}\n\telse\n\t{\n\t    if (qi->qf_curlist >= qi->qf_listcount - 1)\n\t    {\n\t\temsg(_(e_at_top_of_quickfix_stack));\n\t\tbreak;\n\t    }\n\t    ++qi->qf_curlist;\n\t}\n    }\n    qf_msg(qi, qi->qf_curlist, \"\");\n    qf_update_buffer(qi, NULL);\n}\n\n/*\n * Display the information about all the quickfix/location lists in the stack\n */\n    void\nqf_history(exarg_T *eap)\n{\n    qf_info_T\t*qi = qf_cmd_get_stack(eap, FALSE);\n    int\t\ti;\n\n    if (eap->addr_count > 0)\n    {\n\tif (qi == NULL)\n\t{\n\t    emsg(_(e_no_location_list));\n\t    return;\n\t}\n\n\t// Jump to the specified quickfix list\n\tif (eap->line2 > 0 && eap->line2 <= qi->qf_listcount)\n\t{\n\t    qi->qf_curlist = eap->line2 - 1;\n\t    qf_msg(qi, qi->qf_curlist, \"\");\n\t    qf_update_buffer(qi, NULL);\n\t}\n\telse\n\t    emsg(_(e_invalid_range));\n\n\treturn;\n    }\n\n    if (qf_stack_empty(qi))\n\tmsg(_(\"No entries\"));\n    else\n\tfor (i = 0; i < qi->qf_listcount; ++i)\n\t    qf_msg(qi, i, i == qi->qf_curlist ? \"> \" : \"  \");\n}\n\n/*\n * Free all the entries in the error list \"idx\". Note that other information\n * associated with the list like context and title are not freed.\n */\n    static void\nqf_free_items(qf_list_T *qfl)\n{\n    qfline_T\t*qfp;\n    qfline_T\t*qfpnext;\n    int\t\tstop = FALSE;\n\n    while (qfl->qf_count && qfl->qf_start != NULL)\n    {\n\tqfp = qfl->qf_start;\n\tqfpnext = qfp->qf_next;\n\tif (!stop)\n\t{\n\t    vim_free(qfp->qf_module);\n\t    vim_free(qfp->qf_text);\n\t    vim_free(qfp->qf_pattern);\n\t    stop = (qfp == qfpnext);\n\t    vim_free(qfp);\n\t    if (stop)\n\t\t// Somehow qf_count may have an incorrect value, set it to 1\n\t\t// to avoid crashing when it's wrong.\n\t\t// TODO: Avoid qf_count being incorrect.\n\t\tqfl->qf_count = 1;\n\t}\n\tqfl->qf_start = qfpnext;\n\t--qfl->qf_count;\n    }\n\n    qfl->qf_index = 0;\n    qfl->qf_start = NULL;\n    qfl->qf_last = NULL;\n    qfl->qf_ptr = NULL;\n    qfl->qf_nonevalid = TRUE;\n\n    qf_clean_dir_stack(&qfl->qf_dir_stack);\n    qfl->qf_directory = NULL;\n    qf_clean_dir_stack(&qfl->qf_file_stack);\n    qfl->qf_currfile = NULL;\n    qfl->qf_multiline = FALSE;\n    qfl->qf_multiignore = FALSE;\n    qfl->qf_multiscan = FALSE;\n}\n\n/*\n * Free error list \"idx\". Frees all the entries in the quickfix list,\n * associated context information and the title.\n */\n    static void\nqf_free(qf_list_T *qfl)\n{\n    qf_free_items(qfl);\n\n    VIM_CLEAR(qfl->qf_title);\n    free_tv(qfl->qf_ctx);\n    qfl->qf_ctx = NULL;\n    free_callback(&qfl->qf_qftf_cb);\n    qfl->qf_id = 0;\n    qfl->qf_changedtick = 0L;\n}\n\n/*\n * qf_mark_adjust: adjust marks\n */\n   void\nqf_mark_adjust(\n\twin_T\t*wp,\n\tlinenr_T\tline1,\n\tlinenr_T\tline2,\n\tlong\tamount,\n\tlong\tamount_after)\n{\n    int\t\ti;\n    qfline_T\t*qfp;\n    int\t\tidx;\n    qf_info_T\t*qi = &ql_info;\n    int\t\tfound_one = FALSE;\n    int\t\tbuf_has_flag = wp == NULL ? BUF_HAS_QF_ENTRY : BUF_HAS_LL_ENTRY;\n\n    if (!(curbuf->b_has_qf_entry & buf_has_flag))\n\treturn;\n    if (wp != NULL)\n    {\n\tif (wp->w_llist == NULL)\n\t    return;\n\tqi = wp->w_llist;\n    }\n\n    for (idx = 0; idx < qi->qf_listcount; ++idx)\n    {\n\tqf_list_T\t*qfl = qf_get_list(qi, idx);\n\n\tif (!qf_list_empty(qfl))\n\t    FOR_ALL_QFL_ITEMS(qfl, qfp, i)\n\t\tif (qfp->qf_fnum == curbuf->b_fnum)\n\t\t{\n\t\t    found_one = TRUE;\n\t\t    if (qfp->qf_lnum >= line1 && qfp->qf_lnum <= line2)\n\t\t    {\n\t\t\tif (amount == MAXLNUM)\n\t\t\t    qfp->qf_cleared = TRUE;\n\t\t\telse\n\t\t\t    qfp->qf_lnum += amount;\n\t\t    }\n\t\t    else if (amount_after && qfp->qf_lnum > line2)\n\t\t\tqfp->qf_lnum += amount_after;\n\t\t}\n    }\n\n    if (!found_one)\n\tcurbuf->b_has_qf_entry &= ~buf_has_flag;\n}\n\n/*\n * Make a nice message out of the error character and the error number:\n *  char    number\tmessage\n *  e or E    0\t\t\" error\"\n *  w or W    0\t\t\" warning\"\n *  i or I    0\t\t\" info\"\n *  n or N    0\t\t\" note\"\n *  0\t      0\t\t\"\"\n *  other     0\t\t\" c\"\n *  e or E    n\t\t\" error n\"\n *  w or W    n\t\t\" warning n\"\n *  i or I    n\t\t\" info n\"\n *  n or N    n\t\t\" note n\"\n *  0\t      n\t\t\" error n\"\n *  other     n\t\t\" c n\"\n *  1\t      x\t\t\"\"\t:helpgrep\n */\n    static char_u *\nqf_types(int c, int nr)\n{\n    static char_u\tbuf[20];\n    static char_u\tcc[3];\n    char_u\t\t*p;\n\n    if (c == 'W' || c == 'w')\n\tp = (char_u *)\" warning\";\n    else if (c == 'I' || c == 'i')\n\tp = (char_u *)\" info\";\n    else if (c == 'N' || c == 'n')\n\tp = (char_u *)\" note\";\n    else if (c == 'E' || c == 'e' || (c == 0 && nr > 0))\n\tp = (char_u *)\" error\";\n    else if (c == 0 || c == 1)\n\tp = (char_u *)\"\";\n    else\n    {\n\tcc[0] = ' ';\n\tcc[1] = c;\n\tcc[2] = NUL;\n\tp = cc;\n    }\n\n    if (nr <= 0)\n\treturn p;\n\n    sprintf((char *)buf, \"%s %3d\", (char *)p, nr);\n    return buf;\n}\n\n/*\n * When \"split\" is FALSE: Open the entry/result under the cursor.\n * When \"split\" is TRUE: Open the entry/result under the cursor in a new window.\n */\n    void\nqf_view_result(int split)\n{\n    qf_info_T   *qi = &ql_info;\n\n    if (IS_LL_WINDOW(curwin))\n\tqi = GET_LOC_LIST(curwin);\n\n    if (qf_list_empty(qf_get_curlist(qi)))\n    {\n\temsg(_(e_no_errors));\n\treturn;\n    }\n\n    if (split)\n    {\n\t// Open the selected entry in a new window\n\tqf_jump_newwin(qi, 0, (long)curwin->w_cursor.lnum, FALSE, TRUE);\n\tdo_cmdline_cmd((char_u *) \"clearjumps\");\n\treturn;\n    }\n\n    do_cmdline_cmd((char_u *)(IS_LL_WINDOW(curwin) ? \".ll\" : \".cc\"));\n}\n\n/*\n * \":cwindow\": open the quickfix window if we have errors to display,\n *\t       close it if not.\n * \":lwindow\": open the location list window if we have locations to display,\n *\t       close it if not.\n */\n    void\nex_cwindow(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    qf_list_T\t*qfl;\n    win_T\t*win;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    qfl = qf_get_curlist(qi);\n\n    // Look for an existing quickfix window.\n    win = qf_find_win(qi);\n\n    // If a quickfix window is open but we have no errors to display,\n    // close the window.  If a quickfix window is not open, then open\n    // it if we have errors; otherwise, leave it closed.\n    if (qf_stack_empty(qi)\n\t    || qfl->qf_nonevalid\n\t    || qf_list_empty(qfl))\n    {\n\tif (win != NULL)\n\t    ex_cclose(eap);\n    }\n    else if (win == NULL)\n\tex_copen(eap);\n}\n\n/*\n * \":cclose\": close the window showing the list of errors.\n * \":lclose\": close the window showing the location list\n */\n    void\nex_cclose(exarg_T *eap)\n{\n    win_T\t*win = NULL;\n    qf_info_T\t*qi;\n\n    if ((qi = qf_cmd_get_stack(eap, FALSE)) == NULL)\n\treturn;\n\n    // Find existing quickfix window and close it.\n    win = qf_find_win(qi);\n    if (win != NULL)\n\twin_close(win, FALSE);\n}\n\n/*\n * Set \"w:quickfix_title\" if \"qi\" has a title.\n */\n    static void\nqf_set_title_var(qf_list_T *qfl)\n{\n    if (qfl->qf_title != NULL)\n\tset_internal_string_var((char_u *)\"w:quickfix_title\", qfl->qf_title);\n}\n\n/*\n * Goto a quickfix or location list window (if present).\n * Returns OK if the window is found, FAIL otherwise.\n */\n    static int\nqf_goto_cwindow(qf_info_T *qi, int resize, int sz, int vertsplit)\n{\n    win_T\t*win;\n\n    win = qf_find_win(qi);\n    if (win == NULL)\n\treturn FAIL;\n\n    win_goto(win);\n    if (resize)\n    {\n\tif (vertsplit)\n\t{\n\t    if (sz != win->w_width)\n\t\twin_setwidth(sz);\n\t}\n\telse if (sz != win->w_height && win->w_height\n\t\t       + win->w_status_height + tabline_height() < cmdline_row)\n\t    win_setheight(sz);\n    }\n\n    return OK;\n}\n\n/*\n * Set options for the buffer in the quickfix or location list window.\n */\n    static void\nqf_set_cwindow_options(void)\n{\n    // switch off 'swapfile'\n    set_option_value_give_err((char_u *)\"swf\", 0L, NULL, OPT_LOCAL);\n    set_option_value_give_err((char_u *)\"bt\",\n\t\t\t\t\t  0L, (char_u *)\"quickfix\", OPT_LOCAL);\n    set_option_value_give_err((char_u *)\"bh\", 0L, (char_u *)\"hide\", OPT_LOCAL);\n    RESET_BINDING(curwin);\n#ifdef FEAT_DIFF\n    curwin->w_p_diff = FALSE;\n#endif\n#ifdef FEAT_FOLDING\n    set_option_value_give_err((char_u *)\"fdm\", 0L, (char_u *)\"manual\",\n\t    OPT_LOCAL);\n#endif\n}\n\n/*\n * Open a new quickfix or location list window, load the quickfix buffer and\n * set the appropriate options for the window.\n * Returns FAIL if the window could not be opened.\n */\n    static int\nqf_open_new_cwindow(qf_info_T *qi, int height)\n{\n    buf_T\t*qf_buf;\n    win_T\t*oldwin = curwin;\n    tabpage_T\t*prevtab = curtab;\n    int\t\tflags = 0;\n    win_T\t*win;\n\n    qf_buf = qf_find_buf(qi);\n\n    // The current window becomes the previous window afterwards.\n    win = curwin;\n\n    if (IS_QF_STACK(qi) && cmdmod.cmod_split == 0)\n\t// Create the new quickfix window at the very bottom, except when\n\t// :belowright or :aboveleft is used.\n\twin_goto(lastwin);\n    // Default is to open the window below the current window\n    if (cmdmod.cmod_split == 0)\n\tflags = WSP_BELOW;\n    flags |= WSP_NEWLOC;\n    if (win_split(height, flags) == FAIL)\n\treturn FAIL;\t\t// not enough room for window\n    RESET_BINDING(curwin);\n\n    if (IS_LL_STACK(qi))\n    {\n\t// For the location list window, create a reference to the\n\t// location list stack from the window 'win'.\n\tcurwin->w_llist_ref = qi;\n\tqi->qf_refcount++;\n    }\n\n    if (oldwin != curwin)\n\toldwin = NULL;  // don't store info when in another window\n    if (qf_buf != NULL)\n    {\n\t// Use the existing quickfix buffer\n\tif (do_ecmd(qf_buf->b_fnum, NULL, NULL, NULL, ECMD_ONE,\n\t\t    ECMD_HIDE + ECMD_OLDBUF + ECMD_NOWINENTER, oldwin) == FAIL)\n\t    return FAIL;\n    }\n    else\n    {\n\t// Create a new quickfix buffer\n\tif (do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE + ECMD_NOWINENTER,\n\t\t\t\t\t\t\t       oldwin) == FAIL)\n\t    return FAIL;\n\n\t// save the number of the new buffer\n\tqi->qf_bufnr = curbuf->b_fnum;\n    }\n\n    // Set the options for the quickfix buffer/window (if not already done)\n    // Do this even if the quickfix buffer was already present, as an autocmd\n    // might have previously deleted (:bdelete) the quickfix buffer.\n    if (!bt_quickfix(curbuf))\n\tqf_set_cwindow_options();\n\n    // Only set the height when still in the same tab page and there is no\n    // window to the side.\n    if (curtab == prevtab && curwin->w_width == Columns)\n\twin_setheight(height);\n    curwin->w_p_wfh = TRUE;\t    // set 'winfixheight'\n    if (win_valid(win))\n\tprevwin = win;\n\n    return OK;\n}\n\n/*\n * \":copen\": open a window that shows the list of errors.\n * \":lopen\": open a window that shows the location list.\n */\n    void\nex_copen(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    qf_list_T\t*qfl;\n    int\t\theight;\n    int\t\tstatus = FAIL;\n    int\t\tlnum;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    incr_quickfix_busy();\n\n    if (eap->addr_count != 0)\n\theight = eap->line2;\n    else\n\theight = QF_WINHEIGHT;\n\n    reset_VIsual_and_resel();\t\t\t// stop Visual mode\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    // Find an existing quickfix window, or open a new one.\n    if (cmdmod.cmod_tab == 0)\n\tstatus = qf_goto_cwindow(qi, eap->addr_count != 0, height,\n\t\t\t\t\t\tcmdmod.cmod_split & WSP_VERT);\n    if (status == FAIL)\n\tif (qf_open_new_cwindow(qi, height) == FAIL)\n\t{\n\t    decr_quickfix_busy();\n\t    return;\n\t}\n\n    qfl = qf_get_curlist(qi);\n    qf_set_title_var(qfl);\n    // Save the current index here, as updating the quickfix buffer may free\n    // the quickfix list\n    lnum = qfl->qf_index;\n\n    // Fill the buffer with the quickfix list.\n    qf_fill_buffer(qfl, curbuf, NULL, curwin->w_id);\n\n    decr_quickfix_busy();\n\n    curwin->w_cursor.lnum = lnum;\n    curwin->w_cursor.col = 0;\n    check_cursor();\n    update_topline();\t\t// scroll to show the line\n}\n\n/*\n * Move the cursor in the quickfix window to \"lnum\".\n */\n    static void\nqf_win_goto(win_T *win, linenr_T lnum)\n{\n    win_T\t*old_curwin = curwin;\n\n    curwin = win;\n    curbuf = win->w_buffer;\n    curwin->w_cursor.lnum = lnum;\n    curwin->w_cursor.col = 0;\n    curwin->w_cursor.coladd = 0;\n    curwin->w_curswant = 0;\n    update_topline();\t\t// scroll to show the line\n    redraw_later(UPD_VALID);\n    curwin->w_redr_status = TRUE;\t// update ruler\n    curwin = old_curwin;\n    curbuf = curwin->w_buffer;\n}\n\n/*\n * :cbottom/:lbottom commands.\n */\n    void\nex_cbottom(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    win_T\t*win;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    win = qf_find_win(qi);\n    if (win != NULL && win->w_cursor.lnum != win->w_buffer->b_ml.ml_line_count)\n\tqf_win_goto(win, win->w_buffer->b_ml.ml_line_count);\n}\n\n/*\n * Return the number of the current entry (line number in the quickfix\n * window).\n */\n     linenr_T\nqf_current_entry(win_T *wp)\n{\n    qf_info_T\t*qi = &ql_info;\n\n    if (IS_LL_WINDOW(wp))\n\t// In the location list window, use the referenced location list\n\tqi = wp->w_llist_ref;\n\n    return qf_get_curlist(qi)->qf_index;\n}\n\n/*\n * Update the cursor position in the quickfix window to the current error.\n * Return TRUE if there is a quickfix window.\n */\n    static int\nqf_win_pos_update(\n    qf_info_T\t*qi,\n    int\t\told_qf_index)\t// previous qf_index or zero\n{\n    win_T\t*win;\n    int\t\tqf_index = qf_get_curlist(qi)->qf_index;\n\n    // Put the cursor on the current error in the quickfix window, so that\n    // it's viewable.\n    win = qf_find_win(qi);\n    if (win != NULL\n\t    && qf_index <= win->w_buffer->b_ml.ml_line_count\n\t    && old_qf_index != qf_index)\n    {\n\tif (qf_index > old_qf_index)\n\t{\n\t    win->w_redraw_top = old_qf_index;\n\t    win->w_redraw_bot = qf_index;\n\t}\n\telse\n\t{\n\t    win->w_redraw_top = qf_index;\n\t    win->w_redraw_bot = old_qf_index;\n\t}\n\tqf_win_goto(win, qf_index);\n    }\n    return win != NULL;\n}\n\n/*\n * Check whether the given window is displaying the specified quickfix/location\n * stack.\n */\n    static int\nis_qf_win(win_T *win, qf_info_T *qi)\n{\n    // A window displaying the quickfix buffer will have the w_llist_ref field\n    // set to NULL.\n    // A window displaying a location list buffer will have the w_llist_ref\n    // pointing to the location list.\n    if (bt_quickfix(win->w_buffer))\n\tif ((IS_QF_STACK(qi) && win->w_llist_ref == NULL)\n\t\t|| (IS_LL_STACK(qi) && win->w_llist_ref == qi))\n\t    return TRUE;\n\n    return FALSE;\n}\n\n/*\n * Find a window displaying the quickfix/location stack 'qi' in the current tab\n * page.\n */\n    static win_T *\nqf_find_win(qf_info_T *qi)\n{\n    win_T\t*win;\n\n    FOR_ALL_WINDOWS(win)\n\tif (is_qf_win(win, qi))\n\t    return win;\n    return NULL;\n}\n\n/*\n * Find a quickfix buffer.\n * Searches in windows opened in all the tab pages.\n */\n    static buf_T *\nqf_find_buf(qf_info_T *qi)\n{\n    tabpage_T\t*tp;\n    win_T\t*win;\n\n    if (qi->qf_bufnr != INVALID_QFBUFNR)\n    {\n\tbuf_T\t*qfbuf;\n\tqfbuf = buflist_findnr(qi->qf_bufnr);\n\tif (qfbuf != NULL)\n\t    return qfbuf;\n\t// buffer is no longer present\n\tqi->qf_bufnr = INVALID_QFBUFNR;\n    }\n\n    FOR_ALL_TAB_WINDOWS(tp, win)\n\tif (is_qf_win(win, qi))\n\t    return win->w_buffer;\n\n    return NULL;\n}\n\n/*\n * Process the 'quickfixtextfunc' option value.\n * Returns OK or FAIL.\n */\n    int\nqf_process_qftf_option(void)\n{\n    return option_set_callback_func(p_qftf, &qftf_cb);\n}\n\n/*\n * Update the w:quickfix_title variable in the quickfix/location list window in\n * all the tab pages.\n */\n    static void\nqf_update_win_titlevar(qf_info_T *qi)\n{\n    qf_list_T\t*qfl = qf_get_curlist(qi);\n    tabpage_T\t*tp;\n    win_T\t*win;\n    win_T\t*save_curwin = curwin;\n\n    FOR_ALL_TAB_WINDOWS(tp, win)\n    {\n\tif (is_qf_win(win, qi))\n\t{\n\t    curwin = win;\n\t    qf_set_title_var(qfl);\n\t}\n    }\n    curwin = save_curwin;\n}\n\n/*\n * Find the quickfix buffer.  If it exists, update the contents.\n */\n    static void\nqf_update_buffer(qf_info_T *qi, qfline_T *old_last)\n{\n    buf_T\t*buf;\n    win_T\t*win;\n    aco_save_T\taco;\n\n    // Check if a buffer for the quickfix list exists.  Update it.\n    buf = qf_find_buf(qi);\n    if (buf != NULL)\n    {\n\tlinenr_T\told_line_count = buf->b_ml.ml_line_count;\n\tint\t\tqf_winid = 0;\n\n\tif (IS_LL_STACK(qi))\n\t{\n\t    if (curwin->w_llist == qi)\n\t\twin = curwin;\n\t    else\n\t    {\n\t\t// Find the file window (non-quickfix) with this location list\n\t\twin = qf_find_win_with_loclist(qi);\n\t\tif (win == NULL)\n\t\t    // File window is not found. Find the location list window.\n\t\t    win = qf_find_win(qi);\n\t\tif (win == NULL)\n\t\t    return;\n\t    }\n\t    qf_winid = win->w_id;\n\t}\n\n\tif (old_last == NULL)\n\t    // set curwin/curbuf to buf and save a few things\n\t    aucmd_prepbuf(&aco, buf);\n\n\tqf_update_win_titlevar(qi);\n\n\tqf_fill_buffer(qf_get_curlist(qi), buf, old_last, qf_winid);\n\t++CHANGEDTICK(buf);\n\n\tif (old_last == NULL)\n\t{\n\t    (void)qf_win_pos_update(qi, 0);\n\n\t    // restore curwin/curbuf and a few other things\n\t    aucmd_restbuf(&aco);\n\t}\n\n\t// Only redraw when added lines are visible.  This avoids flickering\n\t// when the added lines are not visible.\n\tif ((win = qf_find_win(qi)) != NULL && old_line_count < win->w_botline)\n\t    redraw_buf_later(buf, UPD_NOT_VALID);\n    }\n}\n\n/*\n * Add an error line to the quickfix buffer.\n */\n    static int\nqf_buf_add_line(\n\tbuf_T\t\t*buf,\t\t// quickfix window buffer\n\tlinenr_T\tlnum,\n\tqfline_T\t*qfp,\n\tchar_u\t\t*dirname,\n\tint\t\tfirst_bufline,\n\tchar_u\t\t*qftf_str)\n{\n    int\t\tlen;\n    buf_T\t*errbuf;\n\n    // If the 'quickfixtextfunc' function returned a non-empty custom string\n    // for this entry, then use it.\n    if (qftf_str != NULL && *qftf_str != NUL)\n\tvim_strncpy(IObuff, qftf_str, IOSIZE - 1);\n    else\n    {\n\tif (qfp->qf_module != NULL)\n\t{\n\t    vim_strncpy(IObuff, qfp->qf_module, IOSIZE - 1);\n\t    len = (int)STRLEN(IObuff);\n\t}\n\telse if (qfp->qf_fnum != 0\n\t\t&& (errbuf = buflist_findnr(qfp->qf_fnum)) != NULL\n\t\t&& errbuf->b_fname != NULL)\n\t{\n\t    if (qfp->qf_type == 1)\t// :helpgrep\n\t\tvim_strncpy(IObuff, gettail(errbuf->b_fname), IOSIZE - 1);\n\t    else\n\t    {\n\t\t// Shorten the file name if not done already.\n\t\t// For optimization, do this only for the first entry in a\n\t\t// buffer.\n\t\tif (first_bufline && (errbuf->b_sfname == NULL\n\t\t\t\t|| mch_isFullName(errbuf->b_sfname)))\n\t\t{\n\t\t    if (*dirname == NUL)\n\t\t\tmch_dirname(dirname, MAXPATHL);\n\t\t    shorten_buf_fname(errbuf, dirname, FALSE);\n\t\t}\n\t\tvim_strncpy(IObuff, errbuf->b_fname, IOSIZE - 1);\n\t    }\n\t    len = (int)STRLEN(IObuff);\n\t}\n\telse\n\t    len = 0;\n\n\tif (len < IOSIZE - 1)\n\t    IObuff[len++] = '|';\n\n\tif (qfp->qf_lnum > 0)\n\t{\n\t    qf_range_text(qfp, IObuff + len, IOSIZE - len);\n\t    len += (int)STRLEN(IObuff + len);\n\n\t    vim_snprintf((char *)IObuff + len, IOSIZE - len, \"%s\",\n\t\t    (char *)qf_types(qfp->qf_type, qfp->qf_nr));\n\t    len += (int)STRLEN(IObuff + len);\n\t}\n\telse if (qfp->qf_pattern != NULL)\n\t{\n\t    qf_fmt_text(qfp->qf_pattern, IObuff + len, IOSIZE - len);\n\t    len += (int)STRLEN(IObuff + len);\n\t}\n\tif (len < IOSIZE - 2)\n\t{\n\t    IObuff[len++] = '|';\n\t    IObuff[len++] = ' ';\n\t}\n\n\t// Remove newlines and leading whitespace from the text.\n\t// For an unrecognized line keep the indent, the compiler may\n\t// mark a word with ^^^^.\n\tqf_fmt_text(len > 3 ? skipwhite(qfp->qf_text) : qfp->qf_text,\n\t\tIObuff + len, IOSIZE - len);\n    }\n\n    if (ml_append_buf(buf, lnum, IObuff,\n\t\t(colnr_T)STRLEN(IObuff) + 1, FALSE) == FAIL)\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * Call the 'quickfixtextfunc' function to get the list of lines to display in\n * the quickfix window for the entries 'start_idx' to 'end_idx'.\n */\n    static list_T *\ncall_qftf_func(qf_list_T *qfl, int qf_winid, long start_idx, long end_idx)\n{\n    callback_T\t*cb = &qftf_cb;\n    list_T\t*qftf_list = NULL;\n    static int\trecursive = FALSE;\n\n    if (recursive)\n\treturn NULL;  // this doesn't work properly recursively\n    recursive = TRUE;\n\n    // If 'quickfixtextfunc' is set, then use the user-supplied function to get\n    // the text to display. Use the local value of 'quickfixtextfunc' if it is\n    // set.\n    if (qfl->qf_qftf_cb.cb_name != NULL)\n\tcb = &qfl->qf_qftf_cb;\n    if (cb->cb_name != NULL)\n    {\n\ttypval_T\targs[1];\n\tdict_T\t\t*d;\n\ttypval_T\trettv;\n\n\t// create the dict argument\n\tif ((d = dict_alloc_lock(VAR_FIXED)) == NULL)\n\t{\n\t    recursive = FALSE;\n\t    return NULL;\n\t}\n\tdict_add_number(d, \"quickfix\", (long)IS_QF_LIST(qfl));\n\tdict_add_number(d, \"winid\", (long)qf_winid);\n\tdict_add_number(d, \"id\", (long)qfl->qf_id);\n\tdict_add_number(d, \"start_idx\", start_idx);\n\tdict_add_number(d, \"end_idx\", end_idx);\n\t++d->dv_refcount;\n\targs[0].v_type = VAR_DICT;\n\targs[0].vval.v_dict = d;\n\n\tqftf_list = NULL;\n\tif (call_callback(cb, 0, &rettv, 1, args) != FAIL)\n\t{\n\t    if (rettv.v_type == VAR_LIST)\n\t    {\n\t\tqftf_list = rettv.vval.v_list;\n\t\tqftf_list->lv_refcount++;\n\t    }\n\t    clear_tv(&rettv);\n\t}\n\tdict_unref(d);\n    }\n\n    recursive = FALSE;\n    return qftf_list;\n}\n\n/*\n * Fill current buffer with quickfix errors, replacing any previous contents.\n * curbuf must be the quickfix buffer!\n * If \"old_last\" is not NULL append the items after this one.\n * When \"old_last\" is NULL then \"buf\" must equal \"curbuf\"!  Because\n * ml_delete() is used and autocommands will be triggered.\n */\n    static void\nqf_fill_buffer(qf_list_T *qfl, buf_T *buf, qfline_T *old_last, int qf_winid)\n{\n    linenr_T\tlnum;\n    qfline_T\t*qfp;\n    int\t\told_KeyTyped = KeyTyped;\n    list_T\t*qftf_list = NULL;\n    listitem_T\t*qftf_li = NULL;\n\n    if (old_last == NULL)\n    {\n\tif (buf != curbuf)\n\t{\n\t    internal_error(\"qf_fill_buffer()\");\n\t    return;\n\t}\n\n\t// delete all existing lines\n\twhile ((curbuf->b_ml.ml_flags & ML_EMPTY) == 0)\n\t    (void)ml_delete((linenr_T)1);\n    }\n\n    // Check if there is anything to display\n    if (qfl != NULL)\n    {\n\tchar_u\t\tdirname[MAXPATHL];\n\tint\t\tinvalid_val = FALSE;\n\tint\t\tprev_bufnr = -1;\n\n\t*dirname = NUL;\n\n\t// Add one line for each error\n\tif (old_last == NULL)\n\t{\n\t    qfp = qfl->qf_start;\n\t    lnum = 0;\n\t}\n\telse\n\t{\n\t    if (old_last->qf_next != NULL)\n\t\tqfp = old_last->qf_next;\n\t    else\n\t\tqfp = old_last;\n\t    lnum = buf->b_ml.ml_line_count;\n\t}\n\n\tqftf_list = call_qftf_func(qfl, qf_winid, (long)(lnum + 1),\n\t\t\t\t\t\t\t(long)qfl->qf_count);\n\tif (qftf_list != NULL)\n\t    qftf_li = qftf_list->lv_first;\n\n\twhile (lnum < qfl->qf_count)\n\t{\n\t    char_u\t*qftf_str = NULL;\n\n\t    // Use the text supplied by the user defined function (if any).\n\t    // If the returned value is not string, then ignore the rest\n\t    // of the returned values and use the default.\n\t    if (qftf_li != NULL && !invalid_val)\n\t    {\n\t\tqftf_str = tv_get_string_chk(&qftf_li->li_tv);\n\t\tif (qftf_str == NULL)\n\t\t    invalid_val = TRUE;\n\t    }\n\n\t    if (qf_buf_add_line(buf, lnum, qfp, dirname,\n\t\t\tprev_bufnr != qfp->qf_fnum, qftf_str) == FAIL)\n\t\tbreak;\n\n\t    prev_bufnr = qfp->qf_fnum;\n\t    ++lnum;\n\t    qfp = qfp->qf_next;\n\t    if (qfp == NULL)\n\t\tbreak;\n\n\t    if (qftf_li != NULL)\n\t\tqftf_li = qftf_li->li_next;\n\t}\n\n\tif (old_last == NULL)\n\t    // Delete the empty line which is now at the end\n\t    (void)ml_delete(lnum + 1);\n    }\n\n    // correct cursor position\n    check_lnums(TRUE);\n\n    if (old_last == NULL)\n    {\n\t// Set the 'filetype' to \"qf\" each time after filling the buffer.\n\t// This resembles reading a file into a buffer, it's more logical when\n\t// using autocommands.\n\t++curbuf_lock;\n\tset_option_value_give_err((char_u *)\"ft\",\n\t\t\t\t\t\t0L, (char_u *)\"qf\", OPT_LOCAL);\n\tcurbuf->b_p_ma = FALSE;\n\n\tkeep_filetype = TRUE;\t\t// don't detect 'filetype'\n\tapply_autocmds(EVENT_BUFREADPOST, (char_u *)\"quickfix\", NULL,\n\t\t\t\t\t\t\t       FALSE, curbuf);\n\tapply_autocmds(EVENT_BUFWINENTER, (char_u *)\"quickfix\", NULL,\n\t\t\t\t\t\t\t       FALSE, curbuf);\n\tkeep_filetype = FALSE;\n\t--curbuf_lock;\n\n\t// make sure it will be redrawn\n\tredraw_curbuf_later(UPD_NOT_VALID);\n    }\n\n    // Restore KeyTyped, setting 'filetype' may reset it.\n    KeyTyped = old_KeyTyped;\n}\n\n/*\n * For every change made to the quickfix list, update the changed tick.\n */\n    static void\nqf_list_changed(qf_list_T *qfl)\n{\n    qfl->qf_changedtick++;\n}\n\n/*\n * Return the quickfix/location list number with the given identifier.\n * Returns -1 if list is not found.\n */\n    static int\nqf_id2nr(qf_info_T *qi, int_u qfid)\n{\n    int\t\tqf_idx;\n\n    for (qf_idx = 0; qf_idx < qi->qf_listcount; qf_idx++)\n\tif (qi->qf_lists[qf_idx].qf_id == qfid)\n\t    return qf_idx;\n    return INVALID_QFIDX;\n}\n\n/*\n * If the current list is not \"save_qfid\" and we can find the list with that ID\n * then make it the current list.\n * This is used when autocommands may have changed the current list.\n * Returns OK if successfully restored the list. Returns FAIL if the list with\n * the specified identifier (save_qfid) is not found in the stack.\n */\n    static int\nqf_restore_list(qf_info_T *qi, int_u save_qfid)\n{\n    int curlist;\n\n    if (qf_get_curlist(qi)->qf_id != save_qfid)\n    {\n\tcurlist = qf_id2nr(qi, save_qfid);\n\tif (curlist < 0)\n\t    // list is not present\n\t    return FAIL;\n\tqi->qf_curlist = curlist;\n    }\n    return OK;\n}\n\n/*\n * Jump to the first entry if there is one.\n */\n    static void\nqf_jump_first(qf_info_T *qi, int_u save_qfid, int forceit)\n{\n    if (qf_restore_list(qi, save_qfid) == FAIL)\n\treturn;\n\n    // Autocommands might have cleared the list, check for that.\n    if (!qf_list_empty(qf_get_curlist(qi)))\n\tqf_jump(qi, 0, 0, forceit);\n}\n\n/*\n * Return TRUE when using \":vimgrep\" for \":grep\".\n */\n    int\ngrep_internal(cmdidx_T cmdidx)\n{\n    return ((cmdidx == CMD_grep\n\t\t|| cmdidx == CMD_lgrep\n\t\t|| cmdidx == CMD_grepadd\n\t\t|| cmdidx == CMD_lgrepadd)\n\t    && STRCMP(\"internal\",\n\t\t\t*curbuf->b_p_gp == NUL ? p_gp : curbuf->b_p_gp) == 0);\n}\n\n/*\n * Return the make/grep autocmd name.\n */\n    static char_u *\nmake_get_auname(cmdidx_T cmdidx)\n{\n    switch (cmdidx)\n    {\n\tcase CMD_make:\t    return (char_u *)\"make\";\n\tcase CMD_lmake:\t    return (char_u *)\"lmake\";\n\tcase CMD_grep:\t    return (char_u *)\"grep\";\n\tcase CMD_lgrep:\t    return (char_u *)\"lgrep\";\n\tcase CMD_grepadd:   return (char_u *)\"grepadd\";\n\tcase CMD_lgrepadd:  return (char_u *)\"lgrepadd\";\n\tdefault: return NULL;\n    }\n}\n\n/*\n * Return the name for the errorfile, in allocated memory.\n * Find a new unique name when 'makeef' contains \"##\".\n * Returns NULL for error.\n */\n    static char_u *\nget_mef_name(void)\n{\n    char_u\t*p;\n    char_u\t*name;\n    static int\tstart = -1;\n    static int\toff = 0;\n#ifdef HAVE_LSTAT\n    stat_T\tsb;\n#endif\n\n    if (*p_mef == NUL)\n    {\n\tname = vim_tempname('e', FALSE);\n\tif (name == NULL)\n\t    emsg(_(e_cant_get_temp_file_name));\n\treturn name;\n    }\n\n    for (p = p_mef; *p; ++p)\n\tif (p[0] == '#' && p[1] == '#')\n\t    break;\n\n    if (*p == NUL)\n\treturn vim_strsave(p_mef);\n\n    // Keep trying until the name doesn't exist yet.\n    for (;;)\n    {\n\tif (start == -1)\n\t    start = mch_get_pid();\n\telse\n\t    off += 19;\n\n\tname = alloc_id(STRLEN(p_mef) + 30, aid_qf_mef_name);\n\tif (name == NULL)\n\t    break;\n\tSTRCPY(name, p_mef);\n\tsprintf((char *)name + (p - p_mef), \"%d%d\", start, off);\n\tSTRCAT(name, p + 2);\n\tif (mch_getperm(name) < 0\n#ifdef HAVE_LSTAT\n\t\t    // Don't accept a symbolic link, it's a security risk.\n\t\t    && mch_lstat((char *)name, &sb) < 0\n#endif\n\t\t)\n\t    break;\n\tvim_free(name);\n    }\n    return name;\n}\n\n/*\n * Form the complete command line to invoke 'make'/'grep'. Quote the command\n * using 'shellquote' and append 'shellpipe'. Echo the fully formed command.\n */\n    static char_u *\nmake_get_fullcmd(char_u *makecmd, char_u *fname)\n{\n    char_u\t*cmd;\n    unsigned\tlen;\n\n    len = (unsigned)STRLEN(p_shq) * 2 + (unsigned)STRLEN(makecmd) + 1;\n    if (*p_sp != NUL)\n\tlen += (unsigned)STRLEN(p_sp) + (unsigned)STRLEN(fname) + 3;\n    cmd = alloc_id(len, aid_qf_makecmd);\n    if (cmd == NULL)\n\treturn NULL;\n    sprintf((char *)cmd, \"%s%s%s\", (char *)p_shq, (char *)makecmd,\n\t\t\t\t\t\t\t       (char *)p_shq);\n\n    // If 'shellpipe' empty: don't redirect to 'errorfile'.\n    if (*p_sp != NUL)\n\tappend_redir(cmd, len, p_sp, fname);\n\n    // Display the fully formed command.  Output a newline if there's something\n    // else than the :make command that was typed (in which case the cursor is\n    // in column 0).\n    if (msg_col == 0)\n\tmsg_didout = FALSE;\n    msg_start();\n    msg_puts(\":!\");\n    msg_outtrans(cmd);\t\t// show what we are doing\n\n    return cmd;\n}\n\n/*\n * Used for \":make\", \":lmake\", \":grep\", \":lgrep\", \":grepadd\", and \":lgrepadd\"\n */\n    void\nex_make(exarg_T *eap)\n{\n    char_u\t*fname;\n    char_u\t*cmd;\n    char_u\t*enc = NULL;\n    win_T\t*wp = NULL;\n    qf_info_T\t*qi = &ql_info;\n    int\t\tres;\n    char_u\t*au_name = NULL;\n    int_u\tsave_qfid;\n    char_u\t*errorformat = p_efm;\n    int\t\tnewlist = TRUE;\n\n    // Redirect \":grep\" to \":vimgrep\" if 'grepprg' is \"internal\".\n    if (grep_internal(eap->cmdidx))\n    {\n\tex_vimgrep(eap);\n\treturn;\n    }\n\n    au_name = make_get_auname(eap->cmdidx);\n    if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf))\n    {\n#ifdef FEAT_EVAL\n\tif (aborting())\n\t    return;\n#endif\n    }\n    enc = (*curbuf->b_p_menc != NUL) ? curbuf->b_p_menc : p_menc;\n\n    if (is_loclist_cmd(eap->cmdidx))\n\twp = curwin;\n\n    autowrite_all();\n    fname = get_mef_name();\n    if (fname == NULL)\n\treturn;\n    mch_remove(fname);\t    // in case it's not unique\n\n    cmd = make_get_fullcmd(eap->arg, fname);\n    if (cmd == NULL)\n    {\n\tvim_free(fname);\n\treturn;\n    }\n\n    // let the shell know if we are redirecting output or not\n    do_shell(cmd, *p_sp != NUL ? SHELL_DOOUT : 0);\n\n#ifdef AMIGA\n    out_flush();\n\t\t// read window status report and redraw before message\n    (void)char_avail();\n#endif\n\n    incr_quickfix_busy();\n\n    if (eap->cmdidx != CMD_make && eap->cmdidx != CMD_lmake)\n\terrorformat = p_gefm;\n    if (eap->cmdidx == CMD_grepadd || eap->cmdidx == CMD_lgrepadd)\n\tnewlist = FALSE;\n\n    res = qf_init(wp, fname, errorformat, newlist, qf_cmdtitle(*eap->cmdlinep),\n\t\t\t\t\t\t\t\t\tenc);\n    if (wp != NULL)\n    {\n\tqi = GET_LOC_LIST(wp);\n\tif (qi == NULL)\n\t    goto cleanup;\n    }\n    if (res >= 0)\n\tqf_list_changed(qf_get_curlist(qi));\n\n    // Remember the current quickfix list identifier, so that we can\n    // check for autocommands changing the current quickfix list.\n    save_qfid = qf_get_curlist(qi)->qf_id;\n    if (au_name != NULL)\n\tapply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf);\n    if (res > 0 && !eap->forceit && qflist_valid(wp, save_qfid))\n\t// display the first error\n\tqf_jump_first(qi, save_qfid, FALSE);\n\ncleanup:\n    decr_quickfix_busy();\n    mch_remove(fname);\n    vim_free(fname);\n    vim_free(cmd);\n}\n\n/*\n * Returns the number of entries in the current quickfix/location list.\n */\n    int\nqf_get_size(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n\n    if ((qi = qf_cmd_get_stack(eap, FALSE)) == NULL)\n\treturn 0;\n    return qf_get_curlist(qi)->qf_count;\n}\n\n/*\n * Returns the number of valid entries in the current quickfix/location list.\n */\n    int\nqf_get_valid_size(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    qf_list_T\t*qfl;\n    qfline_T\t*qfp;\n    int\t\ti, sz = 0;\n    int\t\tprev_fnum = 0;\n\n    if ((qi = qf_cmd_get_stack(eap, FALSE)) == NULL)\n\treturn 0;\n\n    qfl = qf_get_curlist(qi);\n    FOR_ALL_QFL_ITEMS(qfl, qfp, i)\n    {\n\tif (qfp->qf_valid)\n\t{\n\t    if (eap->cmdidx == CMD_cdo || eap->cmdidx == CMD_ldo)\n\t\tsz++;\t// Count all valid entries\n\t    else if (qfp->qf_fnum > 0 && qfp->qf_fnum != prev_fnum)\n\t    {\n\t\t// Count the number of files\n\t\tsz++;\n\t\tprev_fnum = qfp->qf_fnum;\n\t    }\n\t}\n    }\n\n    return sz;\n}\n\n/*\n * Returns the current index of the quickfix/location list.\n * Returns 0 if there is an error.\n */\n    int\nqf_get_cur_idx(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n\n    if ((qi = qf_cmd_get_stack(eap, FALSE)) == NULL)\n\treturn 0;\n\n    return qf_get_curlist(qi)->qf_index;\n}\n\n/*\n * Returns the current index in the quickfix/location list (counting only valid\n * entries). If no valid entries are in the list, then returns 1.\n */\n    int\nqf_get_cur_valid_idx(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    qf_list_T\t*qfl;\n    qfline_T\t*qfp;\n    int\t\ti, eidx = 0;\n    int\t\tprev_fnum = 0;\n\n    if ((qi = qf_cmd_get_stack(eap, FALSE)) == NULL)\n\treturn 1;\n\n    qfl = qf_get_curlist(qi);\n    qfp = qfl->qf_start;\n\n    // check if the list has valid errors\n    if (!qf_list_has_valid_entries(qfl))\n\treturn 1;\n\n    for (i = 1; i <= qfl->qf_index && qfp!= NULL; i++, qfp = qfp->qf_next)\n    {\n\tif (qfp->qf_valid)\n\t{\n\t    if (eap->cmdidx == CMD_cfdo || eap->cmdidx == CMD_lfdo)\n\t    {\n\t\tif (qfp->qf_fnum > 0 && qfp->qf_fnum != prev_fnum)\n\t\t{\n\t\t    // Count the number of files\n\t\t    eidx++;\n\t\t    prev_fnum = qfp->qf_fnum;\n\t\t}\n\t    }\n\t    else\n\t\teidx++;\n\t}\n    }\n\n    return eidx ? eidx : 1;\n}\n\n/*\n * Get the 'n'th valid error entry in the quickfix or location list.\n * Used by :cdo, :ldo, :cfdo and :lfdo commands.\n * For :cdo and :ldo returns the 'n'th valid error entry.\n * For :cfdo and :lfdo returns the 'n'th valid file entry.\n */\n    static int\nqf_get_nth_valid_entry(qf_list_T *qfl, int n, int fdo)\n{\n    qfline_T\t*qfp;\n    int\t\ti, eidx;\n    int\t\tprev_fnum = 0;\n\n    // check if the list has valid errors\n    if (!qf_list_has_valid_entries(qfl))\n\treturn 1;\n\n    eidx = 0;\n    FOR_ALL_QFL_ITEMS(qfl, qfp, i)\n    {\n\tif (qfp->qf_valid)\n\t{\n\t    if (fdo)\n\t    {\n\t\tif (qfp->qf_fnum > 0 && qfp->qf_fnum != prev_fnum)\n\t\t{\n\t\t    // Count the number of files\n\t\t    eidx++;\n\t\t    prev_fnum = qfp->qf_fnum;\n\t\t}\n\t    }\n\t    else\n\t\teidx++;\n\t}\n\n\tif (eidx == n)\n\t    break;\n    }\n\n    if (i <= qfl->qf_count)\n\treturn i;\n    else\n\treturn 1;\n}\n\n/*\n * \":cc\", \":crewind\", \":cfirst\" and \":clast\".\n * \":ll\", \":lrewind\", \":lfirst\" and \":llast\".\n * \":cdo\", \":ldo\", \":cfdo\" and \":lfdo\"\n */\n    void\nex_cc(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    int\t\terrornr;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    if (eap->addr_count > 0)\n\terrornr = (int)eap->line2;\n    else\n    {\n\tswitch (eap->cmdidx)\n\t{\n\t    case CMD_cc: case CMD_ll:\n\t\terrornr = 0;\n\t\tbreak;\n\t    case CMD_crewind: case CMD_lrewind: case CMD_cfirst:\n\t    case CMD_lfirst:\n\t\terrornr = 1;\n\t\tbreak;\n\t    default:\n\t\terrornr = 32767;\n\t}\n    }\n\n    // For cdo and ldo commands, jump to the nth valid error.\n    // For cfdo and lfdo commands, jump to the nth valid file entry.\n    if (eap->cmdidx == CMD_cdo || eap->cmdidx == CMD_ldo\n\t    || eap->cmdidx == CMD_cfdo || eap->cmdidx == CMD_lfdo)\n\terrornr = qf_get_nth_valid_entry(qf_get_curlist(qi),\n\t\teap->addr_count > 0 ? (int)eap->line1 : 1,\n\t\teap->cmdidx == CMD_cfdo || eap->cmdidx == CMD_lfdo);\n\n    qf_jump(qi, 0, errornr, eap->forceit);\n}\n\n/*\n * \":cnext\", \":cnfile\", \":cNext\" and \":cprevious\".\n * \":lnext\", \":lNext\", \":lprevious\", \":lnfile\", \":lNfile\" and \":lpfile\".\n * Also, used by \":cdo\", \":ldo\", \":cfdo\" and \":lfdo\" commands.\n */\n    void\nex_cnext(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    int\t\terrornr;\n    int\t\tdir;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    if (eap->addr_count > 0\n\t    && (eap->cmdidx != CMD_cdo && eap->cmdidx != CMD_ldo\n\t\t&& eap->cmdidx != CMD_cfdo && eap->cmdidx != CMD_lfdo))\n\terrornr = (int)eap->line2;\n    else\n\terrornr = 1;\n\n    // Depending on the command jump to either next or previous entry/file.\n    switch (eap->cmdidx)\n    {\n\tcase CMD_cnext: case CMD_lnext: case CMD_cdo: case CMD_ldo:\n\t    dir = FORWARD;\n\t    break;\n\tcase CMD_cprevious: case CMD_lprevious: case CMD_cNext:\n\tcase CMD_lNext:\n\t    dir = BACKWARD;\n\t    break;\n\tcase CMD_cnfile: case CMD_lnfile: case CMD_cfdo: case CMD_lfdo:\n\t    dir = FORWARD_FILE;\n\t    break;\n\tcase CMD_cpfile: case CMD_lpfile: case CMD_cNfile: case CMD_lNfile:\n\t    dir = BACKWARD_FILE;\n\t    break;\n\tdefault:\n\t    dir = FORWARD;\n\t    break;\n    }\n\n    qf_jump(qi, dir, errornr, eap->forceit);\n}\n\n/*\n * Find the first entry in the quickfix list 'qfl' from buffer 'bnr'.\n * The index of the entry is stored in 'errornr'.\n * Returns NULL if an entry is not found.\n */\n    static qfline_T *\nqf_find_first_entry_in_buf(qf_list_T *qfl, int bnr, int *errornr)\n{\n    qfline_T\t*qfp = NULL;\n    int\t\tidx = 0;\n\n    // Find the first entry in this file\n    FOR_ALL_QFL_ITEMS(qfl, qfp, idx)\n\tif (qfp->qf_fnum == bnr)\n\t    break;\n\n    *errornr = idx;\n    return qfp;\n}\n\n/*\n * Find the first quickfix entry on the same line as 'entry'. Updates 'errornr'\n * with the error number for the first entry. Assumes the entries are sorted in\n * the quickfix list by line number.\n */\n    static qfline_T *\nqf_find_first_entry_on_line(qfline_T *entry, int *errornr)\n{\n    while (!got_int\n\t    && entry->qf_prev != NULL\n\t    && entry->qf_fnum == entry->qf_prev->qf_fnum\n\t    && entry->qf_lnum == entry->qf_prev->qf_lnum)\n    {\n\tentry = entry->qf_prev;\n\t--*errornr;\n    }\n\n    return entry;\n}\n\n/*\n * Find the last quickfix entry on the same line as 'entry'. Updates 'errornr'\n * with the error number for the last entry. Assumes the entries are sorted in\n * the quickfix list by line number.\n */\n    static qfline_T *\nqf_find_last_entry_on_line(qfline_T *entry, int *errornr)\n{\n    while (!got_int &&\n\t    entry->qf_next != NULL\n\t    && entry->qf_fnum == entry->qf_next->qf_fnum\n\t    && entry->qf_lnum == entry->qf_next->qf_lnum)\n    {\n\tentry = entry->qf_next;\n\t++*errornr;\n    }\n\n    return entry;\n}\n\n/*\n * Returns TRUE if the specified quickfix entry is\n *   after the given line (linewise is TRUE)\n *   or after the line and column.\n */\n    static int\nqf_entry_after_pos(qfline_T *qfp, pos_T *pos, int linewise)\n{\n    if (linewise)\n\treturn qfp->qf_lnum > pos->lnum;\n    else\n\treturn (qfp->qf_lnum > pos->lnum ||\n\t\t(qfp->qf_lnum == pos->lnum && qfp->qf_col > pos->col));\n}\n\n/*\n * Returns TRUE if the specified quickfix entry is\n *   before the given line (linewise is TRUE)\n *   or before the line and column.\n */\n    static int\nqf_entry_before_pos(qfline_T *qfp, pos_T *pos, int linewise)\n{\n    if (linewise)\n\treturn qfp->qf_lnum < pos->lnum;\n    else\n\treturn (qfp->qf_lnum < pos->lnum ||\n\t\t(qfp->qf_lnum == pos->lnum && qfp->qf_col < pos->col));\n}\n\n/*\n * Returns TRUE if the specified quickfix entry is\n *   on or after the given line (linewise is TRUE)\n *   or on or after the line and column.\n */\n    static int\nqf_entry_on_or_after_pos(qfline_T *qfp, pos_T *pos, int linewise)\n{\n    if (linewise)\n\treturn qfp->qf_lnum >= pos->lnum;\n    else\n\treturn (qfp->qf_lnum > pos->lnum ||\n\t\t(qfp->qf_lnum == pos->lnum && qfp->qf_col >= pos->col));\n}\n\n/*\n * Returns TRUE if the specified quickfix entry is\n *   on or before the given line (linewise is TRUE)\n *   or on or before the line and column.\n */\n    static int\nqf_entry_on_or_before_pos(qfline_T *qfp, pos_T *pos, int linewise)\n{\n    if (linewise)\n\treturn qfp->qf_lnum <= pos->lnum;\n    else\n\treturn (qfp->qf_lnum < pos->lnum ||\n\t\t(qfp->qf_lnum == pos->lnum && qfp->qf_col <= pos->col));\n}\n\n/*\n * Find the first quickfix entry after position 'pos' in buffer 'bnr'.\n * If 'linewise' is TRUE, returns the entry after the specified line and treats\n * multiple entries on a single line as one. Otherwise returns the entry after\n * the specified line and column.\n * 'qfp' points to the very first entry in the buffer and 'errornr' is the\n * index of the very first entry in the quickfix list.\n * Returns NULL if an entry is not found after 'pos'.\n */\n    static qfline_T *\nqf_find_entry_after_pos(\n\tint\t\tbnr,\n\tpos_T\t\t*pos,\n\tint\t\tlinewise,\n\tqfline_T\t*qfp,\n\tint\t\t*errornr)\n{\n    if (qf_entry_after_pos(qfp, pos, linewise))\n\t// First entry is after position 'pos'\n\treturn qfp;\n\n    // Find the entry just before or at the position 'pos'\n    while (qfp->qf_next != NULL\n\t    && qfp->qf_next->qf_fnum == bnr\n\t    && qf_entry_on_or_before_pos(qfp->qf_next, pos, linewise))\n    {\n\tqfp = qfp->qf_next;\n\t++*errornr;\n    }\n\n    if (qfp->qf_next == NULL || qfp->qf_next->qf_fnum != bnr)\n\t// No entries found after position 'pos'\n\treturn NULL;\n\n    // Use the entry just after position 'pos'\n    qfp = qfp->qf_next;\n    ++*errornr;\n\n    return qfp;\n}\n\n/*\n * Find the first quickfix entry before position 'pos' in buffer 'bnr'.\n * If 'linewise' is TRUE, returns the entry before the specified line and\n * treats multiple entries on a single line as one. Otherwise returns the entry\n * before the specified line and column.\n * 'qfp' points to the very first entry in the buffer and 'errornr' is the\n * index of the very first entry in the quickfix list.\n * Returns NULL if an entry is not found before 'pos'.\n */\n    static qfline_T *\nqf_find_entry_before_pos(\n\tint\t\tbnr,\n\tpos_T\t\t*pos,\n\tint\t\tlinewise,\n\tqfline_T\t*qfp,\n\tint\t\t*errornr)\n{\n    // Find the entry just before the position 'pos'\n    while (qfp->qf_next != NULL\n\t    && qfp->qf_next->qf_fnum == bnr\n\t    && qf_entry_before_pos(qfp->qf_next, pos, linewise))\n    {\n\tqfp = qfp->qf_next;\n\t++*errornr;\n    }\n\n    if (qf_entry_on_or_after_pos(qfp, pos, linewise))\n\treturn NULL;\n\n    if (linewise)\n\t// If multiple entries are on the same line, then use the first entry\n\tqfp = qf_find_first_entry_on_line(qfp, errornr);\n\n    return qfp;\n}\n\n/*\n * Find a quickfix entry in 'qfl' closest to position 'pos' in buffer 'bnr' in\n * the direction 'dir'.\n */\n    static qfline_T *\nqf_find_closest_entry(\n\tqf_list_T\t*qfl,\n\tint\t\tbnr,\n\tpos_T\t\t*pos,\n\tint\t\tdir,\n\tint\t\tlinewise,\n\tint\t\t*errornr)\n{\n    qfline_T\t*qfp;\n\n    *errornr = 0;\n\n    // Find the first entry in this file\n    qfp = qf_find_first_entry_in_buf(qfl, bnr, errornr);\n    if (qfp == NULL)\n\treturn NULL;\t\t// no entry in this file\n\n    if (dir == FORWARD)\n\tqfp = qf_find_entry_after_pos(bnr, pos, linewise, qfp, errornr);\n    else\n\tqfp = qf_find_entry_before_pos(bnr, pos, linewise, qfp, errornr);\n\n    return qfp;\n}\n\n/*\n * Get the nth quickfix entry below the specified entry.  Searches forward in\n * the list. If linewise is TRUE, then treat multiple entries on a single line\n * as one.\n */\n    static void\nqf_get_nth_below_entry(qfline_T *entry_arg, int n, int linewise, int *errornr)\n{\n    qfline_T *entry = entry_arg;\n\n    while (n-- > 0 && !got_int)\n    {\n\tint\t\tfirst_errornr = *errornr;\n\n\tif (linewise)\n\t    // Treat all the entries on the same line in this file as one\n\t    entry = qf_find_last_entry_on_line(entry, errornr);\n\n\tif (entry->qf_next == NULL\n\t\t|| entry->qf_next->qf_fnum != entry->qf_fnum)\n\t{\n\t    if (linewise)\n\t\t*errornr = first_errornr;\n\t    break;\n\t}\n\n\tentry = entry->qf_next;\n\t++*errornr;\n    }\n}\n\n/*\n * Get the nth quickfix entry above the specified entry.  Searches backwards in\n * the list. If linewise is TRUE, then treat multiple entries on a single line\n * as one.\n */\n    static void\nqf_get_nth_above_entry(qfline_T *entry, int n, int linewise, int *errornr)\n{\n    while (n-- > 0 && !got_int)\n    {\n\tif (entry->qf_prev == NULL\n\t\t|| entry->qf_prev->qf_fnum != entry->qf_fnum)\n\t    break;\n\n\tentry = entry->qf_prev;\n\t--*errornr;\n\n\t// If multiple entries are on the same line, then use the first entry\n\tif (linewise)\n\t    entry = qf_find_first_entry_on_line(entry, errornr);\n    }\n}\n\n/*\n * Find the n'th quickfix entry adjacent to position 'pos' in buffer 'bnr' in\n * the specified direction.  Returns the error number in the quickfix list or 0\n * if an entry is not found.\n */\n    static int\nqf_find_nth_adj_entry(\n\tqf_list_T\t*qfl,\n\tint\t\tbnr,\n\tpos_T\t\t*pos,\n\tint\t\tn,\n\tint\t\tdir,\n\tint\t\tlinewise)\n{\n    qfline_T\t*adj_entry;\n    int\t\terrornr;\n\n    // Find an entry closest to the specified position\n    adj_entry = qf_find_closest_entry(qfl, bnr, pos, dir, linewise, &errornr);\n    if (adj_entry == NULL)\n\treturn 0;\n\n    if (--n > 0)\n    {\n\t// Go to the n'th entry in the current buffer\n\tif (dir == FORWARD)\n\t    qf_get_nth_below_entry(adj_entry, n, linewise, &errornr);\n\telse\n\t    qf_get_nth_above_entry(adj_entry, n, linewise, &errornr);\n    }\n\n    return errornr;\n}\n\n/*\n * Jump to a quickfix entry in the current file nearest to the current line or\n * current line/col.\n * \":cabove\", \":cbelow\", \":labove\", \":lbelow\", \":cafter\", \":cbefore\",\n * \":lafter\" and \":lbefore\" commands\n */\n    void\nex_cbelow(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    qf_list_T\t*qfl;\n    int\t\tdir;\n    int\t\tbuf_has_flag;\n    int\t\terrornr = 0;\n    pos_T\tpos;\n\n    if (eap->addr_count > 0 && eap->line2 <= 0)\n    {\n\temsg(_(e_invalid_range));\n\treturn;\n    }\n\n    // Check whether the current buffer has any quickfix entries\n    if (eap->cmdidx == CMD_cabove || eap->cmdidx == CMD_cbelow\n\t    || eap->cmdidx == CMD_cbefore || eap->cmdidx == CMD_cafter)\n\tbuf_has_flag = BUF_HAS_QF_ENTRY;\n    else\n\tbuf_has_flag = BUF_HAS_LL_ENTRY;\n    if (!(curbuf->b_has_qf_entry & buf_has_flag))\n    {\n\temsg(_(e_no_errors));\n\treturn;\n    }\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    qfl = qf_get_curlist(qi);\n    // check if the list has valid errors\n    if (!qf_list_has_valid_entries(qfl))\n    {\n\temsg(_(e_no_errors));\n\treturn;\n    }\n\n    if (eap->cmdidx == CMD_cbelow\n\t    || eap->cmdidx == CMD_lbelow\n\t    || eap->cmdidx == CMD_cafter\n\t    || eap->cmdidx == CMD_lafter)\n\t// Forward motion commands\n\tdir = FORWARD;\n    else\n\tdir = BACKWARD;\n\n    pos = curwin->w_cursor;\n    // A quickfix entry column number is 1 based whereas cursor column\n    // number is 0 based. Adjust the column number.\n    pos.col++;\n    errornr = qf_find_nth_adj_entry(qfl, curbuf->b_fnum, &pos,\n\t\t\t\teap->addr_count > 0 ? eap->line2 : 0, dir,\n\t\t\t\teap->cmdidx == CMD_cbelow\n\t\t\t\t\t|| eap->cmdidx == CMD_lbelow\n\t\t\t\t\t|| eap->cmdidx == CMD_cabove\n\t\t\t\t\t|| eap->cmdidx == CMD_labove);\n\n    if (errornr > 0)\n\tqf_jump(qi, 0, errornr, FALSE);\n    else\n\temsg(_(e_no_more_items));\n}\n\n/*\n * Return the autocmd name for the :cfile Ex commands\n */\n    static char_u *\ncfile_get_auname(cmdidx_T cmdidx)\n{\n    switch (cmdidx)\n    {\n\tcase CMD_cfile:\t    return (char_u *)\"cfile\";\n\tcase CMD_cgetfile:  return (char_u *)\"cgetfile\";\n\tcase CMD_caddfile:  return (char_u *)\"caddfile\";\n\tcase CMD_lfile:\t    return (char_u *)\"lfile\";\n\tcase CMD_lgetfile:  return (char_u *)\"lgetfile\";\n\tcase CMD_laddfile:  return (char_u *)\"laddfile\";\n\tdefault:\t    return NULL;\n    }\n}\n\n/*\n * \":cfile\"/\":cgetfile\"/\":caddfile\" commands.\n * \":lfile\"/\":lgetfile\"/\":laddfile\" commands.\n */\n    void\nex_cfile(exarg_T *eap)\n{\n    char_u\t*enc = NULL;\n    win_T\t*wp = NULL;\n    qf_info_T\t*qi = &ql_info;\n    char_u\t*au_name = NULL;\n    int_u\tsave_qfid = 0;\t\t// init for gcc\n    int\t\tres;\n\n    au_name = cfile_get_auname(eap->cmdidx);\n    if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n\t\t\t\t\t\t\tNULL, FALSE, curbuf))\n    {\n#ifdef FEAT_EVAL\n\tif (aborting())\n\t    return;\n#endif\n    }\n\n    enc = (*curbuf->b_p_menc != NUL) ? curbuf->b_p_menc : p_menc;\n#ifdef FEAT_BROWSE\n    if (cmdmod.cmod_flags & CMOD_BROWSE)\n    {\n\tchar_u *browse_file = do_browse(0, (char_u *)_(\"Error file\"), eap->arg,\n\t\t\t\t   NULL, NULL,\n\t\t\t\t   (char_u *)_(BROWSE_FILTER_ALL_FILES), NULL);\n\tif (browse_file == NULL)\n\t    return;\n\tset_string_option_direct((char_u *)\"ef\", -1, browse_file, OPT_FREE, 0);\n\tvim_free(browse_file);\n    }\n    else\n#endif\n    if (*eap->arg != NUL)\n\tset_string_option_direct((char_u *)\"ef\", -1, eap->arg, OPT_FREE, 0);\n\n    if (is_loclist_cmd(eap->cmdidx))\n\twp = curwin;\n\n    incr_quickfix_busy();\n\n    // This function is used by the :cfile, :cgetfile and :caddfile\n    // commands.\n    // :cfile always creates a new quickfix list and jumps to the\n    // first error.\n    // :cgetfile creates a new quickfix list but doesn't jump to the\n    // first error.\n    // :caddfile adds to an existing quickfix list. If there is no\n    // quickfix list then a new list is created.\n    res = qf_init(wp, p_ef, p_efm, (eap->cmdidx != CMD_caddfile\n\t\t\t&& eap->cmdidx != CMD_laddfile),\n\t\t\tqf_cmdtitle(*eap->cmdlinep), enc);\n    if (wp != NULL)\n    {\n\tqi = GET_LOC_LIST(wp);\n\tif (qi == NULL)\n\t{\n\t    decr_quickfix_busy();\n\t    return;\n\t}\n    }\n    if (res >= 0)\n\tqf_list_changed(qf_get_curlist(qi));\n    save_qfid = qf_get_curlist(qi)->qf_id;\n    if (au_name != NULL)\n\tapply_autocmds(EVENT_QUICKFIXCMDPOST, au_name, NULL, FALSE, curbuf);\n\n    // Jump to the first error for a new list and if autocmds didn't\n    // free the list.\n    if (res > 0 && (eap->cmdidx == CMD_cfile || eap->cmdidx == CMD_lfile)\n\t    && qflist_valid(wp, save_qfid))\n\t// display the first error\n\tqf_jump_first(qi, save_qfid, eap->forceit);\n\n    decr_quickfix_busy();\n}\n\n/*\n * Return the vimgrep autocmd name.\n */\n    static char_u *\nvgr_get_auname(cmdidx_T cmdidx)\n{\n    switch (cmdidx)\n    {\n\tcase CMD_vimgrep:     return (char_u *)\"vimgrep\";\n\tcase CMD_lvimgrep:    return (char_u *)\"lvimgrep\";\n\tcase CMD_vimgrepadd:  return (char_u *)\"vimgrepadd\";\n\tcase CMD_lvimgrepadd: return (char_u *)\"lvimgrepadd\";\n\tcase CMD_grep:\t      return (char_u *)\"grep\";\n\tcase CMD_lgrep:\t      return (char_u *)\"lgrep\";\n\tcase CMD_grepadd:     return (char_u *)\"grepadd\";\n\tcase CMD_lgrepadd:    return (char_u *)\"lgrepadd\";\n\tdefault: return NULL;\n    }\n}\n\n/*\n * Initialize the regmatch used by vimgrep for pattern \"s\".\n */\n    static void\nvgr_init_regmatch(regmmatch_T *regmatch, char_u *s)\n{\n    // Get the search pattern: either white-separated or enclosed in //\n    regmatch->regprog = NULL;\n\n    if (s == NULL || *s == NUL)\n    {\n\t// Pattern is empty, use last search pattern.\n\tif (last_search_pat() == NULL)\n\t{\n\t    emsg(_(e_no_previous_regular_expression));\n\t    return;\n\t}\n\tregmatch->regprog = vim_regcomp(last_search_pat(), RE_MAGIC);\n    }\n    else\n\tregmatch->regprog = vim_regcomp(s, RE_MAGIC);\n\n    regmatch->rmm_ic = p_ic;\n    regmatch->rmm_maxcol = 0;\n}\n\n/*\n * Display a file name when vimgrep is running.\n */\n    static void\nvgr_display_fname(char_u *fname)\n{\n    char_u\t*p;\n\n    msg_start();\n    p = msg_strtrunc(fname, TRUE);\n    if (p == NULL)\n\tmsg_outtrans(fname);\n    else\n    {\n\tmsg_outtrans(p);\n\tvim_free(p);\n    }\n    msg_clr_eos();\n    msg_didout = FALSE;\t    // overwrite this message\n    msg_nowait = TRUE;\t    // don't wait for this message\n    msg_col = 0;\n    out_flush();\n}\n\n/*\n * Load a dummy buffer to search for a pattern using vimgrep.\n */\n    static buf_T *\nvgr_load_dummy_buf(\n\tchar_u *fname,\n\tchar_u *dirname_start,\n\tchar_u *dirname_now)\n{\n    int\t\tsave_mls;\n#if defined(FEAT_SYN_HL)\n    char_u\t*save_ei = NULL;\n#endif\n    buf_T\t*buf;\n\n#if defined(FEAT_SYN_HL)\n    // Don't do Filetype autocommands to avoid loading syntax and\n    // indent scripts, a great speed improvement.\n    save_ei = au_event_disable(\",Filetype\");\n#endif\n    // Don't use modelines here, it's useless.\n    save_mls = p_mls;\n    p_mls = 0;\n\n    // Load file into a buffer, so that 'fileencoding' is detected,\n    // autocommands applied, etc.\n    buf = load_dummy_buffer(fname, dirname_start, dirname_now);\n\n    p_mls = save_mls;\n#if defined(FEAT_SYN_HL)\n    au_event_restore(save_ei);\n#endif\n\n    return buf;\n}\n\n/*\n * Check whether a quickfix/location list is valid. Autocmds may remove or\n * change a quickfix list when vimgrep is running. If the list is not found,\n * create a new list.\n */\n    static int\nvgr_qflist_valid(\n\twin_T\t    *wp,\n\tqf_info_T   *qi,\n\tint_u\t    qfid,\n\tchar_u\t    *title)\n{\n    // Verify that the quickfix/location list was not freed by an autocmd\n    if (!qflist_valid(wp, qfid))\n    {\n\tif (wp != NULL)\n\t{\n\t    // An autocmd has freed the location list.\n\t    emsg(_(e_current_location_list_was_changed));\n\t    return FALSE;\n\t}\n\telse\n\t{\n\t    // Quickfix list is not found, create a new one.\n\t    qf_new_list(qi, title);\n\t    return TRUE;\n\t}\n    }\n\n    if (qf_restore_list(qi, qfid) == FAIL)\n\treturn FALSE;\n\n    return TRUE;\n}\n\n/*\n * Search for a pattern in all the lines in a buffer and add the matching lines\n * to a quickfix list.\n */\n    static int\nvgr_match_buflines(\n\tqf_list_T   *qfl,\n\tchar_u\t    *fname,\n\tbuf_T\t    *buf,\n\tchar_u\t    *spat,\n\tregmmatch_T *regmatch,\n\tlong\t    *tomatch,\n\tint\t    duplicate_name,\n\tint\t    flags)\n{\n    int\t\tfound_match = FALSE;\n    long\tlnum;\n    colnr_T\tcol;\n    int\t\tpat_len = (int)STRLEN(spat);\n\n    for (lnum = 1; lnum <= buf->b_ml.ml_line_count && *tomatch > 0; ++lnum)\n    {\n\tcol = 0;\n\tif (!(flags & VGR_FUZZY))\n\t{\n\t    // Regular expression match\n\t    while (vim_regexec_multi(regmatch, curwin, buf, lnum,\n\t\t\tcol, NULL) > 0)\n\t    {\n\t\t// Pass the buffer number so that it gets used even for a\n\t\t// dummy buffer, unless duplicate_name is set, then the\n\t\t// buffer will be wiped out below.\n\t\tif (qf_add_entry(qfl,\n\t\t\t    NULL,\t// dir\n\t\t\t    fname,\n\t\t\t    NULL,\n\t\t\t    duplicate_name ? 0 : buf->b_fnum,\n\t\t\t    ml_get_buf(buf,\n\t\t\t\tregmatch->startpos[0].lnum + lnum, FALSE),\n\t\t\t    regmatch->startpos[0].lnum + lnum,\n\t\t\t    regmatch->endpos[0].lnum + lnum,\n\t\t\t    regmatch->startpos[0].col + 1,\n\t\t\t    regmatch->endpos[0].col + 1,\n\t\t\t    FALSE,\t// vis_col\n\t\t\t    NULL,\t// search pattern\n\t\t\t    0,\t\t// nr\n\t\t\t    0,\t\t// type\n\t\t\t    TRUE\t// valid\n\t\t\t    ) == QF_FAIL)\n\t\t{\n\t\t    got_int = TRUE;\n\t\t    break;\n\t\t}\n\t\tfound_match = TRUE;\n\t\tif (--*tomatch == 0)\n\t\t    break;\n\t\tif ((flags & VGR_GLOBAL) == 0\n\t\t\t|| regmatch->endpos[0].lnum > 0)\n\t\t    break;\n\t\tcol = regmatch->endpos[0].col\n\t\t    + (col == regmatch->endpos[0].col);\n\t\tif (col > (colnr_T)STRLEN(ml_get_buf(buf, lnum, FALSE)))\n\t\t    break;\n\t    }\n\t}\n\telse\n\t{\n\t    char_u  *str = ml_get_buf(buf, lnum, FALSE);\n\t    int\t    score;\n\t    int_u   matches[MAX_FUZZY_MATCHES];\n\t    int_u   sz = ARRAY_LENGTH(matches);\n\n\t    // Fuzzy string match\n\t    while (fuzzy_match(str + col, spat, FALSE, &score, matches, sz) > 0)\n\t    {\n\t\t// Pass the buffer number so that it gets used even for a\n\t\t// dummy buffer, unless duplicate_name is set, then the\n\t\t// buffer will be wiped out below.\n\t\tif (qf_add_entry(qfl,\n\t\t\t    NULL,\t// dir\n\t\t\t    fname,\n\t\t\t    NULL,\n\t\t\t    duplicate_name ? 0 : buf->b_fnum,\n\t\t\t    str,\n\t\t\t    lnum,\n\t\t\t    0,\n\t\t\t    matches[0] + col + 1,\n\t\t\t    0,\n\t\t\t    FALSE,\t// vis_col\n\t\t\t    NULL,\t// search pattern\n\t\t\t    0,\t\t// nr\n\t\t\t    0,\t\t// type\n\t\t\t    TRUE\t// valid\n\t\t\t    ) == QF_FAIL)\n\t\t{\n\t\t    got_int = TRUE;\n\t\t    break;\n\t\t}\n\t\tfound_match = TRUE;\n\t\tif (--*tomatch == 0)\n\t\t    break;\n\t\tif ((flags & VGR_GLOBAL) == 0)\n\t\t    break;\n\t\tcol = matches[pat_len - 1] + col + 1;\n\t\tif (col > (colnr_T)STRLEN(str))\n\t\t    break;\n\t    }\n\t}\n\tline_breakcheck();\n\tif (got_int)\n\t    break;\n    }\n\n    return found_match;\n}\n\n/*\n * Jump to the first match and update the directory.\n */\n    static void\nvgr_jump_to_match(\n\tqf_info_T   *qi,\n\tint\t    forceit,\n\tint\t    *redraw_for_dummy,\n\tbuf_T\t    *first_match_buf,\n\tchar_u\t    *target_dir)\n{\n    buf_T\t*buf;\n\n    buf = curbuf;\n    qf_jump(qi, 0, 0, forceit);\n    if (buf != curbuf)\n\t// If we jumped to another buffer redrawing will already be\n\t// taken care of.\n\t*redraw_for_dummy = FALSE;\n\n    // Jump to the directory used after loading the buffer.\n    if (curbuf == first_match_buf && target_dir != NULL)\n    {\n\texarg_T ea;\n\n\tCLEAR_FIELD(ea);\n\tea.arg = target_dir;\n\tea.cmdidx = CMD_lcd;\n\tex_cd(&ea);\n    }\n}\n\n/*\n * :vimgrep command arguments\n */\ntypedef struct\n{\n    long\ttomatch;\t// maximum number of matches to find\n    char_u\t*spat;\t\t// search pattern\n    int\t\tflags;\t\t// search modifier\n    char_u\t**fnames;\t// list of files to search\n    int\t\tfcount;\t\t// number of files\n    regmmatch_T\tregmatch;\t// compiled search pattern\n    char_u\t*qf_title;\t// quickfix list title\n} vgr_args_T;\n\n/*\n * Process :vimgrep command arguments. The command syntax is:\n *\n *\t:{count}vimgrep /{pattern}/[g][j] {file} ...\n */\n    static int\nvgr_process_args(\n\texarg_T\t\t*eap,\n\tvgr_args_T\t*args)\n{\n    char_u\t*p;\n\n    vim_memset(args, 0, sizeof(*args));\n\n    args->regmatch.regprog = NULL;\n    args->qf_title = vim_strsave(qf_cmdtitle(*eap->cmdlinep));\n\n    if (eap->addr_count > 0)\n\targs->tomatch = eap->line2;\n    else\n\targs->tomatch = MAXLNUM;\n\n    // Get the search pattern: either white-separated or enclosed in //\n    p = skip_vimgrep_pat(eap->arg, &args->spat, &args->flags);\n    if (p == NULL)\n    {\n\temsg(_(e_invalid_search_pattern_or_delimiter));\n\treturn FAIL;\n    }\n\n    vgr_init_regmatch(&args->regmatch, args->spat);\n    if (args->regmatch.regprog == NULL)\n\treturn FAIL;\n\n    p = skipwhite(p);\n    if (*p == NUL)\n    {\n\temsg(_(e_file_name_missing_or_invalid_pattern));\n\treturn FAIL;\n    }\n\n    // Parse the list of arguments, wildcards have already been expanded.\n    if ((get_arglist_exp(p, &args->fcount, &args->fnames, TRUE) == FAIL) ||\n\targs->fcount == 0)\n    {\n\temsg(_(e_no_match));\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * Return TRUE if \"buf\" had an existing swap file, the current swap file does\n * not end in \".swp\".\n */\n    static int\nexisting_swapfile(buf_T *buf)\n{\n    if (buf->b_ml.ml_mfp != NULL && buf->b_ml.ml_mfp->mf_fname != NULL)\n    {\n\tchar_u *fname = buf->b_ml.ml_mfp->mf_fname;\n\tsize_t len = STRLEN(fname);\n\n\treturn fname[len - 1] != 'p' || fname[len - 2] != 'w';\n    }\n    return FALSE;\n}\n\n/*\n * Search for a pattern in a list of files and populate the quickfix list with\n * the matches.\n */\n    static int\nvgr_process_files(\n\twin_T\t\t*wp,\n\tqf_info_T\t*qi,\n\tvgr_args_T\t*cmd_args,\n\tint\t\t*redraw_for_dummy,\n\tbuf_T\t\t**first_match_buf,\n\tchar_u\t\t**target_dir)\n{\n    int\t\tstatus = FAIL;\n    int_u\tsave_qfid = qf_get_curlist(qi)->qf_id;\n    time_t\tseconds = 0;\n    char_u\t*fname;\n    int\t\tfi;\n    buf_T\t*buf;\n    int\t\tduplicate_name = FALSE;\n    int\t\tusing_dummy;\n    char_u\t*dirname_start = NULL;\n    char_u\t*dirname_now = NULL;\n    int\t\tfound_match;\n    aco_save_T\taco;\n\n    dirname_start = alloc_id(MAXPATHL, aid_qf_dirname_start);\n    dirname_now = alloc_id(MAXPATHL, aid_qf_dirname_now);\n    if (dirname_start == NULL || dirname_now == NULL)\n\tgoto theend;\n\n    // Remember the current directory, because a BufRead autocommand that does\n    // \":lcd %:p:h\" changes the meaning of short path names.\n    mch_dirname(dirname_start, MAXPATHL);\n\n    seconds = (time_t)0;\n    for (fi = 0; fi < cmd_args->fcount && !got_int && cmd_args->tomatch > 0;\n\t\t\t\t\t\t\t\t\t++fi)\n    {\n\tfname = shorten_fname1(cmd_args->fnames[fi]);\n\tif (time(NULL) > seconds)\n\t{\n\t    // Display the file name every second or so, show the user we are\n\t    // working on it.\n\t    seconds = time(NULL);\n\t    vgr_display_fname(fname);\n\t}\n\n\tbuf = buflist_findname_exp(cmd_args->fnames[fi]);\n\tif (buf == NULL || buf->b_ml.ml_mfp == NULL)\n\t{\n\t    // Remember that a buffer with this name already exists.\n\t    duplicate_name = (buf != NULL);\n\t    using_dummy = TRUE;\n\t    *redraw_for_dummy = TRUE;\n\n\t    buf = vgr_load_dummy_buf(fname, dirname_start, dirname_now);\n\t}\n\telse\n\t    // Use existing, loaded buffer.\n\t    using_dummy = FALSE;\n\n\t// Check whether the quickfix list is still valid. When loading a\n\t// buffer above, autocommands might have changed the quickfix list.\n\tif (!vgr_qflist_valid(wp, qi, save_qfid, cmd_args->qf_title))\n\t    goto theend;\n\n\tsave_qfid = qf_get_curlist(qi)->qf_id;\n\n\tif (buf == NULL)\n\t{\n\t    if (!got_int)\n\t\tsmsg(_(\"Cannot open file \\\"%s\\\"\"), fname);\n\t}\n\telse\n\t{\n\t    // Try for a match in all lines of the buffer.\n\t    // For \":1vimgrep\" look for first match only.\n\t    found_match = vgr_match_buflines(qf_get_curlist(qi),\n\t\t    fname, buf, cmd_args->spat, &cmd_args->regmatch,\n\t\t    &cmd_args->tomatch, duplicate_name, cmd_args->flags);\n\n\t    if (using_dummy)\n\t    {\n\t\tif (found_match && *first_match_buf == NULL)\n\t\t    *first_match_buf = buf;\n\t\tif (duplicate_name)\n\t\t{\n\t\t    // Never keep a dummy buffer if there is another buffer\n\t\t    // with the same name.\n\t\t    wipe_dummy_buffer(buf, dirname_start);\n\t\t    buf = NULL;\n\t\t}\n\t\telse if ((cmdmod.cmod_flags & CMOD_HIDE) == 0\n\t\t\t    || buf->b_p_bh[0] == 'u'\t// \"unload\"\n\t\t\t    || buf->b_p_bh[0] == 'w'\t// \"wipe\"\n\t\t\t    || buf->b_p_bh[0] == 'd')\t// \"delete\"\n\t\t{\n\t\t    // When no match was found we don't need to remember the\n\t\t    // buffer, wipe it out.  If there was a match and it\n\t\t    // wasn't the first one or we won't jump there: only\n\t\t    // unload the buffer.\n\t\t    // Ignore 'hidden' here, because it may lead to having too\n\t\t    // many swap files.\n\t\t    if (!found_match)\n\t\t    {\n\t\t\twipe_dummy_buffer(buf, dirname_start);\n\t\t\tbuf = NULL;\n\t\t    }\n\t\t    else if (buf != *first_match_buf\n\t\t\t\t\t|| (cmd_args->flags & VGR_NOJUMP)\n\t\t\t\t\t|| existing_swapfile(buf))\n\t\t    {\n\t\t\tunload_dummy_buffer(buf, dirname_start);\n\t\t\t// Keeping the buffer, remove the dummy flag.\n\t\t\tbuf->b_flags &= ~BF_DUMMY;\n\t\t\tbuf = NULL;\n\t\t    }\n\t\t}\n\n\t\tif (buf != NULL)\n\t\t{\n\t\t    // Keeping the buffer, remove the dummy flag.\n\t\t    buf->b_flags &= ~BF_DUMMY;\n\n\t\t    // If the buffer is still loaded we need to use the\n\t\t    // directory we jumped to below.\n\t\t    if (buf == *first_match_buf\n\t\t\t    && *target_dir == NULL\n\t\t\t    && STRCMP(dirname_start, dirname_now) != 0)\n\t\t\t*target_dir = vim_strsave(dirname_now);\n\n\t\t    // The buffer is still loaded, the Filetype autocommands\n\t\t    // need to be done now, in that buffer.  And the modelines\n\t\t    // need to be done (again).  But not the window-local\n\t\t    // options!\n\t\t    aucmd_prepbuf(&aco, buf);\n#if defined(FEAT_SYN_HL)\n\t\t    apply_autocmds(EVENT_FILETYPE, buf->b_p_ft,\n\t\t\t\t\t\t     buf->b_fname, TRUE, buf);\n#endif\n\t\t    do_modelines(OPT_NOWIN);\n\t\t    aucmd_restbuf(&aco);\n\t\t}\n\t    }\n\t}\n    }\n\n    status = OK;\n\ntheend:\n    vim_free(dirname_now);\n    vim_free(dirname_start);\n    return status;\n}\n\n/*\n * \":vimgrep {pattern} file(s)\"\n * \":vimgrepadd {pattern} file(s)\"\n * \":lvimgrep {pattern} file(s)\"\n * \":lvimgrepadd {pattern} file(s)\"\n */\n    void\nex_vimgrep(exarg_T *eap)\n{\n    vgr_args_T\targs;\n    qf_info_T\t*qi;\n    qf_list_T\t*qfl;\n    int_u\tsave_qfid;\n    win_T\t*wp = NULL;\n    int\t\tredraw_for_dummy = FALSE;\n    buf_T\t*first_match_buf = NULL;\n    char_u\t*target_dir = NULL;\n    char_u\t*au_name =  NULL;\n    int\t\tstatus;\n\n    au_name = vgr_get_auname(eap->cmdidx);\n    if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf))\n    {\n#ifdef FEAT_EVAL\n\tif (aborting())\n\t    return;\n#endif\n    }\n\n    qi = qf_cmd_get_or_alloc_stack(eap, &wp);\n    if (qi == NULL)\n\treturn;\n\n    if (vgr_process_args(eap, &args) == FAIL)\n\tgoto theend;\n\n    if ((eap->cmdidx != CMD_grepadd && eap->cmdidx != CMD_lgrepadd\n\t\t&& eap->cmdidx != CMD_vimgrepadd\n\t\t&& eap->cmdidx != CMD_lvimgrepadd)\n\t\t\t\t\t|| qf_stack_empty(qi))\n\t// make place for a new list\n\tqf_new_list(qi, args.qf_title);\n\n    incr_quickfix_busy();\n\n    status = vgr_process_files(wp, qi, &args, &redraw_for_dummy,\n\t\t\t\t\t\t&first_match_buf, &target_dir);\n    if (status != OK)\n    {\n\tFreeWild(args.fcount, args.fnames);\n\tdecr_quickfix_busy();\n\tgoto theend;\n    }\n\n    FreeWild(args.fcount, args.fnames);\n\n    qfl = qf_get_curlist(qi);\n    qfl->qf_nonevalid = FALSE;\n    qfl->qf_ptr = qfl->qf_start;\n    qfl->qf_index = 1;\n    qf_list_changed(qfl);\n\n    qf_update_buffer(qi, NULL);\n\n    // Remember the current quickfix list identifier, so that we can check for\n    // autocommands changing the current quickfix list.\n    save_qfid = qf_get_curlist(qi)->qf_id;\n\n    if (au_name != NULL)\n\tapply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf);\n    // The QuickFixCmdPost autocmd may free the quickfix list. Check the list\n    // is still valid.\n    if (!qflist_valid(wp, save_qfid)\n\t    || qf_restore_list(qi, save_qfid) == FAIL)\n    {\n\tdecr_quickfix_busy();\n\tgoto theend;\n    }\n\n    // Jump to first match.\n    if (!qf_list_empty(qf_get_curlist(qi)))\n    {\n\tif ((args.flags & VGR_NOJUMP) == 0)\n\t    vgr_jump_to_match(qi, eap->forceit, &redraw_for_dummy,\n\t\t    first_match_buf, target_dir);\n    }\n    else\n\tsemsg(_(e_no_match_str_2), args.spat);\n\n    decr_quickfix_busy();\n\n    // If we loaded a dummy buffer into the current window, the autocommands\n    // may have messed up things, need to redraw and recompute folds.\n    if (redraw_for_dummy)\n    {\n#ifdef FEAT_FOLDING\n\tfoldUpdateAll(curwin);\n#else\n\tredraw_later(UPD_NOT_VALID);\n#endif\n    }\n\ntheend:\n    vim_free(args.qf_title);\n    vim_free(target_dir);\n    vim_regfree(args.regmatch.regprog);\n}\n\n/*\n * Restore current working directory to \"dirname_start\" if they differ, taking\n * into account whether it is set locally or globally.\n */\n    static void\nrestore_start_dir(char_u *dirname_start)\n{\n    char_u *dirname_now = alloc(MAXPATHL);\n\n    if (NULL != dirname_now)\n    {\n\tmch_dirname(dirname_now, MAXPATHL);\n\tif (STRCMP(dirname_start, dirname_now) != 0)\n\t{\n\t    // If the directory has changed, change it back by building up an\n\t    // appropriate ex command and executing it.\n\t    exarg_T ea;\n\n\t    CLEAR_FIELD(ea);\n\t    ea.arg = dirname_start;\n\t    ea.cmdidx = (curwin->w_localdir == NULL) ? CMD_cd : CMD_lcd;\n\t    ex_cd(&ea);\n\t}\n\tvim_free(dirname_now);\n    }\n}\n\n/*\n * Load file \"fname\" into a dummy buffer and return the buffer pointer,\n * placing the directory resulting from the buffer load into the\n * \"resulting_dir\" pointer. \"resulting_dir\" must be allocated by the caller\n * prior to calling this function. Restores directory to \"dirname_start\" prior\n * to returning, if autocmds or the 'autochdir' option have changed it.\n *\n * If creating the dummy buffer does not fail, must call unload_dummy_buffer()\n * or wipe_dummy_buffer() later!\n *\n * Returns NULL if it fails.\n */\n    static buf_T *\nload_dummy_buffer(\n    char_u\t*fname,\n    char_u\t*dirname_start,  // in: old directory\n    char_u\t*resulting_dir)  // out: new directory\n{\n    buf_T\t*newbuf;\n    bufref_T\tnewbufref;\n    bufref_T\tnewbuf_to_wipe;\n    int\t\tfailed = TRUE;\n    aco_save_T\taco;\n    int\t\treadfile_result;\n\n    // Allocate a buffer without putting it in the buffer list.\n    newbuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);\n    if (newbuf == NULL)\n\treturn NULL;\n    set_bufref(&newbufref, newbuf);\n\n    // Init the options.\n    buf_copy_options(newbuf, BCO_ENTER | BCO_NOHELP);\n\n    // need to open the memfile before putting the buffer in a window\n    if (ml_open(newbuf) == OK)\n    {\n\t// Make sure this buffer isn't wiped out by autocommands.\n\t++newbuf->b_locked;\n\n\t// set curwin/curbuf to buf and save a few things\n\taucmd_prepbuf(&aco, newbuf);\n\n\t// Need to set the filename for autocommands.\n\t(void)setfname(curbuf, fname, NULL, FALSE);\n\n\t// Create swap file now to avoid the ATTENTION message.\n\tcheck_need_swap(TRUE);\n\n\t// Remove the \"dummy\" flag, otherwise autocommands may not\n\t// work.\n\tcurbuf->b_flags &= ~BF_DUMMY;\n\n\tnewbuf_to_wipe.br_buf = NULL;\n\treadfile_result = readfile(fname, NULL,\n\t\t    (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM,\n\t\t    NULL, READ_NEW | READ_DUMMY);\n\t--newbuf->b_locked;\n\tif (readfile_result == OK\n\t\t&& !got_int\n\t\t&& !(curbuf->b_flags & BF_NEW))\n\t{\n\t    failed = FALSE;\n\t    if (curbuf != newbuf)\n\t    {\n\t\t// Bloody autocommands changed the buffer!  Can happen when\n\t\t// using netrw and editing a remote file.  Use the current\n\t\t// buffer instead, delete the dummy one after restoring the\n\t\t// window stuff.\n\t\tset_bufref(&newbuf_to_wipe, newbuf);\n\t\tnewbuf = curbuf;\n\t    }\n\t}\n\n\t// restore curwin/curbuf and a few other things\n\taucmd_restbuf(&aco);\n\tif (newbuf_to_wipe.br_buf != NULL && bufref_valid(&newbuf_to_wipe))\n\t    wipe_buffer(newbuf_to_wipe.br_buf, FALSE);\n\n\t// Add back the \"dummy\" flag, otherwise buflist_findname_stat() won't\n\t// skip it.\n\tnewbuf->b_flags |= BF_DUMMY;\n    }\n\n    // When autocommands/'autochdir' option changed directory: go back.\n    // Let the caller know what the resulting dir was first, in case it is\n    // important.\n    mch_dirname(resulting_dir, MAXPATHL);\n    restore_start_dir(dirname_start);\n\n    if (!bufref_valid(&newbufref))\n\treturn NULL;\n    if (failed)\n    {\n\twipe_dummy_buffer(newbuf, dirname_start);\n\treturn NULL;\n    }\n    return newbuf;\n}\n\n/*\n * Wipe out the dummy buffer that load_dummy_buffer() created. Restores\n * directory to \"dirname_start\" prior to returning, if autocmds or the\n * 'autochdir' option have changed it.\n */\n    static void\nwipe_dummy_buffer(buf_T *buf, char_u *dirname_start)\n{\n    // If any autocommand opened a window on the dummy buffer, close that\n    // window.  If we can't close them all then give up.\n    while (buf->b_nwindows > 0)\n    {\n\tint\t    did_one = FALSE;\n\twin_T\t    *wp;\n\n\tif (firstwin->w_next != NULL)\n\t    FOR_ALL_WINDOWS(wp)\n\t\tif (wp->w_buffer == buf)\n\t\t{\n\t\t    if (win_close(wp, FALSE) == OK)\n\t\t\tdid_one = TRUE;\n\t\t    break;\n\t\t}\n\tif (!did_one)\n\t    return;\n    }\n\n    if (curbuf != buf && buf->b_nwindows == 0)\t// safety check\n    {\n#if defined(FEAT_EVAL)\n\tcleanup_T   cs;\n\n\t// Reset the error/interrupt/exception state here so that aborting()\n\t// returns FALSE when wiping out the buffer.  Otherwise it doesn't\n\t// work when got_int is set.\n\tenter_cleanup(&cs);\n#endif\n\n\twipe_buffer(buf, TRUE);\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n\t// When autocommands/'autochdir' option changed directory: go back.\n\trestore_start_dir(dirname_start);\n    }\n}\n\n/*\n * Unload the dummy buffer that load_dummy_buffer() created. Restores\n * directory to \"dirname_start\" prior to returning, if autocmds or the\n * 'autochdir' option have changed it.\n */\n    static void\nunload_dummy_buffer(buf_T *buf, char_u *dirname_start)\n{\n    if (curbuf != buf)\t\t// safety check\n    {\n\tclose_buffer(NULL, buf, DOBUF_UNLOAD, FALSE, TRUE);\n\n\t// When autocommands/'autochdir' option changed directory: go back.\n\trestore_start_dir(dirname_start);\n    }\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Copy the specified quickfix entry items into a new dict and append the dict\n * to 'list'.  Returns OK on success.\n */\n    static int\nget_qfline_items(qfline_T *qfp, list_T *list)\n{\n    int\t\tbufnum;\n    dict_T\t*dict;\n    char_u\tbuf[2];\n\n    // Handle entries with a non-existing buffer number.\n    bufnum = qfp->qf_fnum;\n    if (bufnum != 0 && (buflist_findnr(bufnum) == NULL))\n\tbufnum = 0;\n\n    if ((dict = dict_alloc()) == NULL)\n\treturn FAIL;\n    if (list_append_dict(list, dict) == FAIL)\n\treturn FAIL;\n\n    buf[0] = qfp->qf_type;\n    buf[1] = NUL;\n    if (dict_add_number(dict, \"bufnr\", (long)bufnum) == FAIL\n\t    || dict_add_number(dict, \"lnum\",     (long)qfp->qf_lnum) == FAIL\n\t    || dict_add_number(dict, \"end_lnum\", (long)qfp->qf_end_lnum) == FAIL\n\t    || dict_add_number(dict, \"col\",      (long)qfp->qf_col) == FAIL\n\t    || dict_add_number(dict, \"end_col\",  (long)qfp->qf_end_col) == FAIL\n\t    || dict_add_number(dict, \"vcol\",     (long)qfp->qf_viscol) == FAIL\n\t    || dict_add_number(dict, \"nr\",       (long)qfp->qf_nr) == FAIL\n\t    || dict_add_string(dict, \"module\", qfp->qf_module) == FAIL\n\t    || dict_add_string(dict, \"pattern\", qfp->qf_pattern) == FAIL\n\t    || dict_add_string(dict, \"text\", qfp->qf_text) == FAIL\n\t    || dict_add_string(dict, \"type\", buf) == FAIL\n\t    || dict_add_number(dict, \"valid\", (long)qfp->qf_valid) == FAIL)\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * Add each quickfix error to list \"list\" as a dictionary.\n * If qf_idx is -1, use the current list. Otherwise, use the specified list.\n * If eidx is not 0, then return only the specified entry. Otherwise return\n * all the entries.\n */\n    static int\nget_errorlist(\n\tqf_info_T\t*qi_arg,\n\twin_T\t\t*wp,\n\tint\t\tqf_idx,\n\tint\t\teidx,\n\tlist_T\t\t*list)\n{\n    qf_info_T\t*qi = qi_arg;\n    qf_list_T\t*qfl;\n    qfline_T\t*qfp;\n    int\t\ti;\n\n    if (qi == NULL)\n    {\n\tqi = &ql_info;\n\tif (wp != NULL)\n\t{\n\t    qi = GET_LOC_LIST(wp);\n\t    if (qi == NULL)\n\t\treturn FAIL;\n\t}\n    }\n\n    if (eidx < 0)\n\treturn OK;\n\n    if (qf_idx == INVALID_QFIDX)\n\tqf_idx = qi->qf_curlist;\n\n    if (qf_idx >= qi->qf_listcount)\n\treturn FAIL;\n\n    qfl = qf_get_list(qi, qf_idx);\n    if (qf_list_empty(qfl))\n\treturn FAIL;\n\n    FOR_ALL_QFL_ITEMS(qfl, qfp, i)\n    {\n\tif (eidx > 0)\n\t{\n\t    if (eidx == i)\n\t\treturn get_qfline_items(qfp, list);\n\t}\n\telse if (get_qfline_items(qfp, list) == FAIL)\n\t    return FAIL;\n    }\n\n    return OK;\n}\n\n// Flags used by getqflist()/getloclist() to determine which fields to return.\nenum {\n    QF_GETLIST_NONE\t= 0x0,\n    QF_GETLIST_TITLE\t= 0x1,\n    QF_GETLIST_ITEMS\t= 0x2,\n    QF_GETLIST_NR\t= 0x4,\n    QF_GETLIST_WINID\t= 0x8,\n    QF_GETLIST_CONTEXT\t= 0x10,\n    QF_GETLIST_ID\t= 0x20,\n    QF_GETLIST_IDX\t= 0x40,\n    QF_GETLIST_SIZE\t= 0x80,\n    QF_GETLIST_TICK\t= 0x100,\n    QF_GETLIST_FILEWINID\t= 0x200,\n    QF_GETLIST_QFBUFNR\t= 0x400,\n    QF_GETLIST_QFTF\t= 0x800,\n    QF_GETLIST_ALL\t= 0xFFF,\n};\n\n/*\n * Parse text from 'di' and return the quickfix list items.\n * Existing quickfix lists are not modified.\n */\n    static int\nqf_get_list_from_lines(dict_T *what, dictitem_T *di, dict_T *retdict)\n{\n    int\t\tstatus = FAIL;\n    qf_info_T\t*qi;\n    char_u\t*errorformat = p_efm;\n    dictitem_T\t*efm_di;\n    list_T\t*l;\n\n    // Only a List value is supported\n    if (di->di_tv.v_type == VAR_LIST && di->di_tv.vval.v_list != NULL)\n    {\n\t// If errorformat is supplied then use it, otherwise use the 'efm'\n\t// option setting\n\tif ((efm_di = dict_find(what, (char_u *)\"efm\", -1)) != NULL)\n\t{\n\t    if (efm_di->di_tv.v_type != VAR_STRING ||\n\t\t    efm_di->di_tv.vval.v_string == NULL)\n\t\treturn FAIL;\n\t    errorformat = efm_di->di_tv.vval.v_string;\n\t}\n\n\tl = list_alloc();\n\tif (l == NULL)\n\t    return FAIL;\n\n\tqi = qf_alloc_stack(QFLT_INTERNAL);\n\tif (qi != NULL)\n\t{\n\t    if (qf_init_ext(qi, 0, NULL, NULL, &di->di_tv, errorformat,\n\t\t\tTRUE, (linenr_T)0, (linenr_T)0, NULL, NULL) > 0)\n\t    {\n\t\t(void)get_errorlist(qi, NULL, 0, 0, l);\n\t\tqf_free(&qi->qf_lists[0]);\n\t    }\n\t    free(qi);\n\t}\n\tdict_add_list(retdict, \"items\", l);\n\tstatus = OK;\n    }\n\n    return status;\n}\n\n/*\n * Return the quickfix/location list window identifier in the current tabpage.\n */\n    static int\nqf_winid(qf_info_T *qi)\n{\n    win_T\t*win;\n\n    // The quickfix window can be opened even if the quickfix list is not set\n    // using \":copen\". This is not true for location lists.\n    if (qi == NULL)\n\treturn 0;\n    win = qf_find_win(qi);\n    if (win != NULL)\n\treturn win->w_id;\n    return 0;\n}\n\n/*\n * Returns the number of the buffer displayed in the quickfix/location list\n * window. If there is no buffer associated with the list or the buffer is\n * wiped out, then returns 0.\n */\n    static int\nqf_getprop_qfbufnr(qf_info_T *qi, dict_T *retdict)\n{\n    int\tbufnum = 0;\n\n    if (qi != NULL && buflist_findnr(qi->qf_bufnr) != NULL)\n\tbufnum = qi->qf_bufnr;\n\n    return dict_add_number(retdict, \"qfbufnr\", bufnum);\n}\n\n/*\n * Convert the keys in 'what' to quickfix list property flags.\n */\n    static int\nqf_getprop_keys2flags(dict_T *what, int loclist)\n{\n    int\t\tflags = QF_GETLIST_NONE;\n\n    if (dict_has_key(what, \"all\"))\n    {\n\tflags |= QF_GETLIST_ALL;\n\tif (!loclist)\n\t    // File window ID is applicable only to location list windows\n\t    flags &= ~ QF_GETLIST_FILEWINID;\n    }\n\n    if (dict_has_key(what, \"title\"))\n\tflags |= QF_GETLIST_TITLE;\n\n    if (dict_has_key(what, \"nr\"))\n\tflags |= QF_GETLIST_NR;\n\n    if (dict_has_key(what, \"winid\"))\n\tflags |= QF_GETLIST_WINID;\n\n    if (dict_has_key(what, \"context\"))\n\tflags |= QF_GETLIST_CONTEXT;\n\n    if (dict_has_key(what, \"id\"))\n\tflags |= QF_GETLIST_ID;\n\n    if (dict_has_key(what, \"items\"))\n\tflags |= QF_GETLIST_ITEMS;\n\n    if (dict_has_key(what, \"idx\"))\n\tflags |= QF_GETLIST_IDX;\n\n    if (dict_has_key(what, \"size\"))\n\tflags |= QF_GETLIST_SIZE;\n\n    if (dict_has_key(what, \"changedtick\"))\n\tflags |= QF_GETLIST_TICK;\n\n    if (loclist && dict_has_key(what, \"filewinid\"))\n\tflags |= QF_GETLIST_FILEWINID;\n\n    if (dict_has_key(what, \"qfbufnr\"))\n\tflags |= QF_GETLIST_QFBUFNR;\n\n    if (dict_has_key(what, \"quickfixtextfunc\"))\n\tflags |= QF_GETLIST_QFTF;\n\n    return flags;\n}\n\n/*\n * Return the quickfix list index based on 'nr' or 'id' in 'what'.\n * If 'nr' and 'id' are not present in 'what' then return the current\n * quickfix list index.\n * If 'nr' is zero then return the current quickfix list index.\n * If 'nr' is '$' then return the last quickfix list index.\n * If 'id' is present then return the index of the quickfix list with that id.\n * If 'id' is zero then return the quickfix list index specified by 'nr'.\n * Return -1, if quickfix list is not present or if the stack is empty.\n */\n    static int\nqf_getprop_qfidx(qf_info_T *qi, dict_T *what)\n{\n    int\t\tqf_idx;\n    dictitem_T\t*di;\n\n    qf_idx = qi->qf_curlist;\t// default is the current list\n    if ((di = dict_find(what, (char_u *)\"nr\", -1)) != NULL)\n    {\n\t// Use the specified quickfix/location list\n\tif (di->di_tv.v_type == VAR_NUMBER)\n\t{\n\t    // for zero use the current list\n\t    if (di->di_tv.vval.v_number != 0)\n\t    {\n\t\tqf_idx = di->di_tv.vval.v_number - 1;\n\t\tif (qf_idx < 0 || qf_idx >= qi->qf_listcount)\n\t\t    qf_idx = INVALID_QFIDX;\n\t    }\n\t}\n\telse if (di->di_tv.v_type == VAR_STRING\n\t\t&& di->di_tv.vval.v_string != NULL\n\t\t&& STRCMP(di->di_tv.vval.v_string, \"$\") == 0)\n\t    // Get the last quickfix list number\n\t    qf_idx = qi->qf_listcount - 1;\n\telse\n\t    qf_idx = INVALID_QFIDX;\n    }\n\n    if ((di = dict_find(what, (char_u *)\"id\", -1)) != NULL)\n    {\n\t// Look for a list with the specified id\n\tif (di->di_tv.v_type == VAR_NUMBER)\n\t{\n\t    // For zero, use the current list or the list specified by 'nr'\n\t    if (di->di_tv.vval.v_number != 0)\n\t\tqf_idx = qf_id2nr(qi, di->di_tv.vval.v_number);\n\t}\n\telse\n\t    qf_idx = INVALID_QFIDX;\n    }\n\n    return qf_idx;\n}\n\n/*\n * Return default values for quickfix list properties in retdict.\n */\n    static int\nqf_getprop_defaults(qf_info_T *qi, int flags, int locstack, dict_T *retdict)\n{\n    int\t\tstatus = OK;\n\n    if (flags & QF_GETLIST_TITLE)\n\tstatus = dict_add_string(retdict, \"title\", (char_u *)\"\");\n    if ((status == OK) && (flags & QF_GETLIST_ITEMS))\n    {\n\tlist_T\t*l = list_alloc();\n\tif (l != NULL)\n\t    status = dict_add_list(retdict, \"items\", l);\n\telse\n\t    status = FAIL;\n    }\n    if ((status == OK) && (flags & QF_GETLIST_NR))\n\tstatus = dict_add_number(retdict, \"nr\", 0);\n    if ((status == OK) && (flags & QF_GETLIST_WINID))\n\tstatus = dict_add_number(retdict, \"winid\", qf_winid(qi));\n    if ((status == OK) && (flags & QF_GETLIST_CONTEXT))\n\tstatus = dict_add_string(retdict, \"context\", (char_u *)\"\");\n    if ((status == OK) && (flags & QF_GETLIST_ID))\n\tstatus = dict_add_number(retdict, \"id\", 0);\n    if ((status == OK) && (flags & QF_GETLIST_IDX))\n\tstatus = dict_add_number(retdict, \"idx\", 0);\n    if ((status == OK) && (flags & QF_GETLIST_SIZE))\n\tstatus = dict_add_number(retdict, \"size\", 0);\n    if ((status == OK) && (flags & QF_GETLIST_TICK))\n\tstatus = dict_add_number(retdict, \"changedtick\", 0);\n    if ((status == OK) && locstack && (flags & QF_GETLIST_FILEWINID))\n\tstatus = dict_add_number(retdict, \"filewinid\", 0);\n    if ((status == OK) && (flags & QF_GETLIST_QFBUFNR))\n\tstatus = qf_getprop_qfbufnr(qi, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_QFTF))\n\tstatus = dict_add_string(retdict, \"quickfixtextfunc\", (char_u *)\"\");\n\n    return status;\n}\n\n/*\n * Return the quickfix list title as 'title' in retdict\n */\n    static int\nqf_getprop_title(qf_list_T *qfl, dict_T *retdict)\n{\n    return dict_add_string(retdict, \"title\", qfl->qf_title);\n}\n\n/*\n * Returns the identifier of the window used to display files from a location\n * list.  If there is no associated window, then returns 0. Useful only when\n * called from a location list window.\n */\n    static int\nqf_getprop_filewinid(win_T *wp, qf_info_T *qi, dict_T *retdict)\n{\n    int winid = 0;\n\n    if (wp != NULL && IS_LL_WINDOW(wp))\n    {\n\twin_T\t*ll_wp = qf_find_win_with_loclist(qi);\n\tif (ll_wp != NULL)\n\t    winid = ll_wp->w_id;\n    }\n\n    return dict_add_number(retdict, \"filewinid\", winid);\n}\n\n/*\n * Return the quickfix list items/entries as 'items' in retdict.\n * If eidx is not 0, then return the item at the specified index.\n */\n    static int\nqf_getprop_items(qf_info_T *qi, int qf_idx, int eidx, dict_T *retdict)\n{\n    int\t\tstatus = OK;\n    list_T\t*l = list_alloc();\n    if (l != NULL)\n    {\n\t(void)get_errorlist(qi, NULL, qf_idx, eidx, l);\n\tdict_add_list(retdict, \"items\", l);\n    }\n    else\n\tstatus = FAIL;\n\n    return status;\n}\n\n/*\n * Return the quickfix list context (if any) as 'context' in retdict.\n */\n    static int\nqf_getprop_ctx(qf_list_T *qfl, dict_T *retdict)\n{\n    int\t\tstatus;\n    dictitem_T\t*di;\n\n    if (qfl->qf_ctx != NULL)\n    {\n\tdi = dictitem_alloc((char_u *)\"context\");\n\tif (di != NULL)\n\t{\n\t    copy_tv(qfl->qf_ctx, &di->di_tv);\n\t    status = dict_add(retdict, di);\n\t    if (status == FAIL)\n\t\tdictitem_free(di);\n\t}\n\telse\n\t    status = FAIL;\n    }\n    else\n\tstatus = dict_add_string(retdict, \"context\", (char_u *)\"\");\n\n    return status;\n}\n\n/*\n * Return the current quickfix list index as 'idx' in retdict.\n * If a specific entry index (eidx) is supplied, then use that.\n */\n    static int\nqf_getprop_idx(qf_list_T *qfl, int eidx, dict_T *retdict)\n{\n    if (eidx == 0)\n    {\n\teidx = qfl->qf_index;\n\tif (qf_list_empty(qfl))\n\t    // For empty lists, current index is set to 0\n\t    eidx = 0;\n    }\n    return dict_add_number(retdict, \"idx\", eidx);\n}\n\n/*\n * Return the 'quickfixtextfunc' function of a quickfix/location list\n */\n    static int\nqf_getprop_qftf(qf_list_T *qfl, dict_T *retdict)\n{\n    int\t\tstatus;\n\n    if (qfl->qf_qftf_cb.cb_name != NULL)\n    {\n\ttypval_T\ttv;\n\n\tput_callback(&qfl->qf_qftf_cb, &tv);\n\tstatus = dict_add_tv(retdict, \"quickfixtextfunc\", &tv);\n\tclear_tv(&tv);\n    }\n    else\n\tstatus = dict_add_string(retdict, \"quickfixtextfunc\", (char_u *)\"\");\n\n    return status;\n}\n\n/*\n * Return quickfix/location list details (title) as a\n * dictionary. 'what' contains the details to return. If 'list_idx' is -1,\n * then current list is used. Otherwise the specified list is used.\n */\n    static int\nqf_get_properties(win_T *wp, dict_T *what, dict_T *retdict)\n{\n    qf_info_T\t*qi = &ql_info;\n    qf_list_T\t*qfl;\n    int\t\tstatus = OK;\n    int\t\tqf_idx = INVALID_QFIDX;\n    int\t\teidx = 0;\n    dictitem_T\t*di;\n    int\t\tflags = QF_GETLIST_NONE;\n\n    if ((di = dict_find(what, (char_u *)\"lines\", -1)) != NULL)\n\treturn qf_get_list_from_lines(what, di, retdict);\n\n    if (wp != NULL)\n\tqi = GET_LOC_LIST(wp);\n\n    flags = qf_getprop_keys2flags(what, (wp != NULL));\n\n    if (!qf_stack_empty(qi))\n\tqf_idx = qf_getprop_qfidx(qi, what);\n\n    // List is not present or is empty\n    if (qf_stack_empty(qi) || qf_idx == INVALID_QFIDX)\n\treturn qf_getprop_defaults(qi, flags, wp != NULL, retdict);\n\n    qfl = qf_get_list(qi, qf_idx);\n\n    // If an entry index is specified, use that\n    if ((di = dict_find(what, (char_u *)\"idx\", -1)) != NULL)\n    {\n\tif (di->di_tv.v_type != VAR_NUMBER)\n\t    return FAIL;\n\teidx = di->di_tv.vval.v_number;\n    }\n\n    if (flags & QF_GETLIST_TITLE)\n\tstatus = qf_getprop_title(qfl, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_NR))\n\tstatus = dict_add_number(retdict, \"nr\", qf_idx + 1);\n    if ((status == OK) && (flags & QF_GETLIST_WINID))\n\tstatus = dict_add_number(retdict, \"winid\", qf_winid(qi));\n    if ((status == OK) && (flags & QF_GETLIST_ITEMS))\n\tstatus = qf_getprop_items(qi, qf_idx, eidx, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_CONTEXT))\n\tstatus = qf_getprop_ctx(qfl, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_ID))\n\tstatus = dict_add_number(retdict, \"id\", qfl->qf_id);\n    if ((status == OK) && (flags & QF_GETLIST_IDX))\n\tstatus = qf_getprop_idx(qfl, eidx, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_SIZE))\n\tstatus = dict_add_number(retdict, \"size\", qfl->qf_count);\n    if ((status == OK) && (flags & QF_GETLIST_TICK))\n\tstatus = dict_add_number(retdict, \"changedtick\", qfl->qf_changedtick);\n    if ((status == OK) && (wp != NULL) && (flags & QF_GETLIST_FILEWINID))\n\tstatus = qf_getprop_filewinid(wp, qi, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_QFBUFNR))\n\tstatus = qf_getprop_qfbufnr(qi, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_QFTF))\n\tstatus = qf_getprop_qftf(qfl, retdict);\n\n    return status;\n}\n\n/*\n * Add a new quickfix entry to list at 'qf_idx' in the stack 'qi' from the\n * items in the dict 'd'. If it is a valid error entry, then set 'valid_entry'\n * to TRUE.\n */\n    static int\nqf_add_entry_from_dict(\n\tqf_list_T\t*qfl,\n\tdict_T\t\t*d,\n\tint\t\tfirst_entry,\n\tint\t\t*valid_entry)\n{\n    static int\tdid_bufnr_emsg;\n    char_u\t*filename, *module, *pattern, *text, *type;\n    int\t\tbufnum, valid, status, col, end_col, vcol, nr;\n    long\tlnum, end_lnum;\n\n    if (first_entry)\n\tdid_bufnr_emsg = FALSE;\n\n    filename = dict_get_string(d, \"filename\", TRUE);\n    module = dict_get_string(d, \"module\", TRUE);\n    bufnum = (int)dict_get_number(d, \"bufnr\");\n    lnum = (int)dict_get_number(d, \"lnum\");\n    end_lnum = (int)dict_get_number(d, \"end_lnum\");\n    col = (int)dict_get_number(d, \"col\");\n    end_col = (int)dict_get_number(d, \"end_col\");\n    vcol = (int)dict_get_number(d, \"vcol\");\n    nr = (int)dict_get_number(d, \"nr\");\n    type = dict_get_string(d, \"type\", TRUE);\n    pattern = dict_get_string(d, \"pattern\", TRUE);\n    text = dict_get_string(d, \"text\", TRUE);\n    if (text == NULL)\n\ttext = vim_strsave((char_u *)\"\");\n\n    valid = TRUE;\n    if ((filename == NULL && bufnum == 0) || (lnum == 0 && pattern == NULL))\n\tvalid = FALSE;\n\n    // Mark entries with non-existing buffer number as not valid. Give the\n    // error message only once.\n    if (bufnum != 0 && (buflist_findnr(bufnum) == NULL))\n    {\n\tif (!did_bufnr_emsg)\n\t{\n\t    did_bufnr_emsg = TRUE;\n\t    semsg(_(e_buffer_nr_not_found), bufnum);\n\t}\n\tvalid = FALSE;\n\tbufnum = 0;\n    }\n\n    // If the 'valid' field is present it overrules the detected value.\n    if (dict_has_key(d, \"valid\"))\n\tvalid = (int)dict_get_bool(d, \"valid\", FALSE);\n\n    status =  qf_add_entry(qfl,\n\t\t\tNULL,\t\t// dir\n\t\t\tfilename,\n\t\t\tmodule,\n\t\t\tbufnum,\n\t\t\ttext,\n\t\t\tlnum,\n\t\t\tend_lnum,\n\t\t\tcol,\n\t\t\tend_col,\n\t\t\tvcol,\t\t// vis_col\n\t\t\tpattern,\t// search pattern\n\t\t\tnr,\n\t\t\ttype == NULL ? NUL : *type,\n\t\t\tvalid);\n\n    vim_free(filename);\n    vim_free(module);\n    vim_free(pattern);\n    vim_free(text);\n    vim_free(type);\n\n    if (valid)\n\t*valid_entry = TRUE;\n\n    return status;\n}\n\n/*\n * Add list of entries to quickfix/location list. Each list entry is\n * a dictionary with item information.\n */\n    static int\nqf_add_entries(\n\tqf_info_T\t*qi,\n\tint\t\tqf_idx,\n\tlist_T\t\t*list,\n\tchar_u\t\t*title,\n\tint\t\taction)\n{\n    qf_list_T\t*qfl = qf_get_list(qi, qf_idx);\n    listitem_T\t*li;\n    dict_T\t*d;\n    qfline_T\t*old_last = NULL;\n    int\t\tretval = OK;\n    int\t\tvalid_entry = FALSE;\n\n    if (action == ' ' || qf_idx == qi->qf_listcount)\n    {\n\t// make place for a new list\n\tqf_new_list(qi, title);\n\tqf_idx = qi->qf_curlist;\n\tqfl = qf_get_list(qi, qf_idx);\n    }\n    else if (action == 'a' && !qf_list_empty(qfl))\n\t// Adding to existing list, use last entry.\n\told_last = qfl->qf_last;\n    else if (action == 'r')\n    {\n\tqf_free_items(qfl);\n\tqf_store_title(qfl, title);\n    }\n\n    FOR_ALL_LIST_ITEMS(list, li)\n    {\n\tif (li->li_tv.v_type != VAR_DICT)\n\t    continue; // Skip non-dict items\n\n\td = li->li_tv.vval.v_dict;\n\tif (d == NULL)\n\t    continue;\n\n\tretval = qf_add_entry_from_dict(qfl, d, li == list->lv_first,\n\t\t\t\t\t\t\t\t&valid_entry);\n\tif (retval == QF_FAIL)\n\t    break;\n    }\n\n    // Check if any valid error entries are added to the list.\n    if (valid_entry)\n\tqfl->qf_nonevalid = FALSE;\n    else if (qfl->qf_index == 0)\n\t// no valid entry\n\tqfl->qf_nonevalid = TRUE;\n\n    // If not appending to the list, set the current error to the first entry\n    if (action != 'a')\n\tqfl->qf_ptr = qfl->qf_start;\n\n    // Update the current error index if not appending to the list or if the\n    // list was empty before and it is not empty now.\n    if ((action != 'a' || qfl->qf_index == 0) && !qf_list_empty(qfl))\n\tqfl->qf_index = 1;\n\n    // Don't update the cursor in quickfix window when appending entries\n    qf_update_buffer(qi, old_last);\n\n    return retval;\n}\n\n/*\n * Get the quickfix list index from 'nr' or 'id'\n */\n    static int\nqf_setprop_get_qfidx(\n\tqf_info_T\t*qi,\n\tdict_T\t\t*what,\n\tint\t\taction,\n\tint\t\t*newlist)\n{\n    dictitem_T\t*di;\n    int\t\tqf_idx = qi->qf_curlist;    // default is the current list\n\n    if ((di = dict_find(what, (char_u *)\"nr\", -1)) != NULL)\n    {\n\t// Use the specified quickfix/location list\n\tif (di->di_tv.v_type == VAR_NUMBER)\n\t{\n\t    // for zero use the current list\n\t    if (di->di_tv.vval.v_number != 0)\n\t\tqf_idx = di->di_tv.vval.v_number - 1;\n\n\t    if ((action == ' ' || action == 'a') && qf_idx == qi->qf_listcount)\n\t    {\n\t\t// When creating a new list, accept qf_idx pointing to the next\n\t\t// non-available list and add the new list at the end of the\n\t\t// stack.\n\t\t*newlist = TRUE;\n\t\tqf_idx = qf_stack_empty(qi) ? 0 : qi->qf_listcount - 1;\n\t    }\n\t    else if (qf_idx < 0 || qf_idx >= qi->qf_listcount)\n\t\treturn INVALID_QFIDX;\n\t    else if (action != ' ')\n\t\t*newlist = FALSE;\t// use the specified list\n\t}\n\telse if (di->di_tv.v_type == VAR_STRING\n\t\t&& di->di_tv.vval.v_string != NULL\n\t\t&& STRCMP(di->di_tv.vval.v_string, \"$\") == 0)\n\t{\n\t    if (!qf_stack_empty(qi))\n\t\tqf_idx = qi->qf_listcount - 1;\n\t    else if (*newlist)\n\t\tqf_idx = 0;\n\t    else\n\t\treturn INVALID_QFIDX;\n\t}\n\telse\n\t    return INVALID_QFIDX;\n    }\n\n    if (!*newlist && (di = dict_find(what, (char_u *)\"id\", -1)) != NULL)\n    {\n\t// Use the quickfix/location list with the specified id\n\tif (di->di_tv.v_type != VAR_NUMBER)\n\t    return INVALID_QFIDX;\n\n\treturn qf_id2nr(qi, di->di_tv.vval.v_number);\n    }\n\n    return qf_idx;\n}\n\n/*\n * Set the quickfix list title.\n */\n    static int\nqf_setprop_title(qf_info_T *qi, int qf_idx, dict_T *what, dictitem_T *di)\n{\n    qf_list_T\t*qfl = qf_get_list(qi, qf_idx);\n\n    if (di->di_tv.v_type != VAR_STRING)\n\treturn FAIL;\n\n    vim_free(qfl->qf_title);\n    qfl->qf_title = dict_get_string(what, \"title\", TRUE);\n    if (qf_idx == qi->qf_curlist)\n\tqf_update_win_titlevar(qi);\n\n    return OK;\n}\n\n/*\n * Set quickfix list items/entries.\n */\n    static int\nqf_setprop_items(qf_info_T *qi, int qf_idx, dictitem_T *di, int action)\n{\n    int\t\tretval = FAIL;\n    char_u\t*title_save;\n\n    if (di->di_tv.v_type != VAR_LIST)\n\treturn FAIL;\n\n    title_save = vim_strsave(qi->qf_lists[qf_idx].qf_title);\n    retval = qf_add_entries(qi, qf_idx, di->di_tv.vval.v_list,\n\t    title_save, action == ' ' ? 'a' : action);\n    vim_free(title_save);\n\n    return retval;\n}\n\n/*\n * Set quickfix list items/entries from a list of lines.\n */\n    static int\nqf_setprop_items_from_lines(\n\tqf_info_T\t*qi,\n\tint\t\tqf_idx,\n\tdict_T\t\t*what,\n\tdictitem_T\t*di,\n\tint\t\taction)\n{\n    char_u\t*errorformat = p_efm;\n    dictitem_T\t*efm_di;\n    int\t\tretval = FAIL;\n\n    // Use the user supplied errorformat settings (if present)\n    if ((efm_di = dict_find(what, (char_u *)\"efm\", -1)) != NULL)\n    {\n\tif (efm_di->di_tv.v_type != VAR_STRING ||\n\t\tefm_di->di_tv.vval.v_string == NULL)\n\t    return FAIL;\n\terrorformat = efm_di->di_tv.vval.v_string;\n    }\n\n    // Only a List value is supported\n    if (di->di_tv.v_type != VAR_LIST || di->di_tv.vval.v_list == NULL)\n\treturn FAIL;\n\n    if (action == 'r')\n\tqf_free_items(&qi->qf_lists[qf_idx]);\n    if (qf_init_ext(qi, qf_idx, NULL, NULL, &di->di_tv, errorformat,\n\t\tFALSE, (linenr_T)0, (linenr_T)0, NULL, NULL) >= 0)\n\tretval = OK;\n\n    return retval;\n}\n\n/*\n * Set quickfix list context.\n */\n    static int\nqf_setprop_context(qf_list_T *qfl, dictitem_T *di)\n{\n    typval_T\t*ctx;\n\n    free_tv(qfl->qf_ctx);\n    ctx =  alloc_tv();\n    if (ctx != NULL)\n\tcopy_tv(&di->di_tv, ctx);\n    qfl->qf_ctx = ctx;\n\n    return OK;\n}\n\n/*\n * Set the current index in the specified quickfix list\n */\n    static int\nqf_setprop_curidx(qf_info_T *qi, qf_list_T *qfl, dictitem_T *di)\n{\n    int\t\tdenote = FALSE;\n    int\t\tnewidx;\n    int\t\told_qfidx;\n    qfline_T\t*qf_ptr;\n\n    // If the specified index is '$', then use the last entry\n    if (di->di_tv.v_type == VAR_STRING\n\t    && di->di_tv.vval.v_string != NULL\n\t    && STRCMP(di->di_tv.vval.v_string, \"$\") == 0)\n\tnewidx = qfl->qf_count;\n    else\n    {\n\t// Otherwise use the specified index\n\tnewidx = tv_get_number_chk(&di->di_tv, &denote);\n\tif (denote)\n\t    return FAIL;\n    }\n\n    if (newidx < 1)\t\t// sanity check\n\treturn FAIL;\n    if (newidx > qfl->qf_count)\n\tnewidx = qfl->qf_count;\n\n    old_qfidx = qfl->qf_index;\n    qf_ptr = get_nth_entry(qfl, newidx, &newidx);\n    if (qf_ptr == NULL)\n\treturn FAIL;\n    qfl->qf_ptr = qf_ptr;\n    qfl->qf_index = newidx;\n\n    // If the current list is modified and it is displayed in the quickfix\n    // window, then Update it.\n    if (qf_get_curlist(qi)->qf_id == qfl->qf_id)\n\tqf_win_pos_update(qi, old_qfidx);\n\n    return OK;\n}\n\n/*\n * Set the current index in the specified quickfix list\n */\n    static int\nqf_setprop_qftf(qf_info_T *qi UNUSED, qf_list_T *qfl, dictitem_T *di)\n{\n    callback_T\tcb;\n\n    free_callback(&qfl->qf_qftf_cb);\n    cb = get_callback(&di->di_tv);\n    if (cb.cb_name != NULL && *cb.cb_name != NUL)\n\tset_callback(&qfl->qf_qftf_cb, &cb);\n\n    return OK;\n}\n\n/*\n * Set quickfix/location list properties (title, items, context).\n * Also used to add items from parsing a list of lines.\n * Used by the setqflist() and setloclist() Vim script functions.\n */\n    static int\nqf_set_properties(qf_info_T *qi, dict_T *what, int action, char_u *title)\n{\n    dictitem_T\t*di;\n    int\t\tretval = FAIL;\n    int\t\tqf_idx;\n    int\t\tnewlist = FALSE;\n    qf_list_T\t*qfl;\n\n    if (action == ' ' || qf_stack_empty(qi))\n\tnewlist = TRUE;\n\n    qf_idx = qf_setprop_get_qfidx(qi, what, action, &newlist);\n    if (qf_idx == INVALID_QFIDX)\t// List not found\n\treturn FAIL;\n\n    if (newlist)\n    {\n\tqi->qf_curlist = qf_idx;\n\tqf_new_list(qi, title);\n\tqf_idx = qi->qf_curlist;\n    }\n\n    qfl = qf_get_list(qi, qf_idx);\n    if ((di = dict_find(what, (char_u *)\"title\", -1)) != NULL)\n\tretval = qf_setprop_title(qi, qf_idx, what, di);\n    if ((di = dict_find(what, (char_u *)\"items\", -1)) != NULL)\n\tretval = qf_setprop_items(qi, qf_idx, di, action);\n    if ((di = dict_find(what, (char_u *)\"lines\", -1)) != NULL)\n\tretval = qf_setprop_items_from_lines(qi, qf_idx, what, di, action);\n    if ((di = dict_find(what, (char_u *)\"context\", -1)) != NULL)\n\tretval = qf_setprop_context(qfl, di);\n    if ((di = dict_find(what, (char_u *)\"idx\", -1)) != NULL)\n\tretval = qf_setprop_curidx(qi, qfl, di);\n    if ((di = dict_find(what, (char_u *)\"quickfixtextfunc\", -1)) != NULL)\n\tretval = qf_setprop_qftf(qi, qfl, di);\n\n    if (newlist || retval == OK)\n\tqf_list_changed(qfl);\n    if (newlist)\n\tqf_update_buffer(qi, NULL);\n\n    return retval;\n}\n\n/*\n * Free the entire quickfix/location list stack.\n * If the quickfix/location list window is open, then clear it.\n */\n    static void\nqf_free_stack(win_T *wp, qf_info_T *qi)\n{\n    win_T\t*qfwin = qf_find_win(qi);\n    win_T\t*llwin = NULL;\n\n    if (qfwin != NULL)\n    {\n\t// If the quickfix/location list window is open, then clear it\n\tif (qi->qf_curlist < qi->qf_listcount)\n\t    qf_free(qf_get_curlist(qi));\n\tqf_update_buffer(qi, NULL);\n    }\n\n    if (wp != NULL && IS_LL_WINDOW(wp))\n    {\n\t// If in the location list window, then use the non-location list\n\t// window with this location list (if present)\n\tllwin = qf_find_win_with_loclist(qi);\n\tif (llwin != NULL)\n\t    wp = llwin;\n    }\n\n    qf_free_all(wp);\n    if (wp == NULL)\n    {\n\t// quickfix list\n\tqi->qf_curlist = 0;\n\tqi->qf_listcount = 0;\n    }\n    else if (qfwin != NULL)\n    {\n\t// If the location list window is open, then create a new empty\n\t// location list\n\tqf_info_T *new_ll = qf_alloc_stack(QFLT_LOCATION);\n\n\tif (new_ll != NULL)\n\t{\n\t    new_ll->qf_bufnr = qfwin->w_buffer->b_fnum;\n\n\t    // first free the list reference in the location list window\n\t    ll_free_all(&qfwin->w_llist_ref);\n\n\t    qfwin->w_llist_ref = new_ll;\n\t    if (wp != qfwin)\n\t\twin_set_loclist(wp, new_ll);\n\t}\n    }\n}\n\n/*\n * Populate the quickfix list with the items supplied in the list\n * of dictionaries. \"title\" will be copied to w:quickfix_title.\n * \"action\" is 'a' for add, 'r' for replace.  Otherwise create a new list.\n * When \"what\" is not NULL then only set some properties.\n */\n    int\nset_errorlist(\n\twin_T\t*wp,\n\tlist_T\t*list,\n\tint\taction,\n\tchar_u\t*title,\n\tdict_T\t*what)\n{\n    qf_info_T\t*qi = &ql_info;\n    int\t\tretval = OK;\n\n    if (wp != NULL)\n    {\n\tqi = ll_get_or_alloc_list(wp);\n\tif (qi == NULL)\n\t    return FAIL;\n    }\n\n    if (action == 'f')\n    {\n\t// Free the entire quickfix or location list stack\n\tqf_free_stack(wp, qi);\n\treturn OK;\n    }\n\n    // A dict argument cannot be specified with a non-empty list argument\n    if (list->lv_len != 0 && what != NULL)\n    {\n\tsemsg(_(e_invalid_argument_str),\n\t\t\t _(\"cannot have both a list and a \\\"what\\\" argument\"));\n\treturn FAIL;\n    }\n\n    incr_quickfix_busy();\n\n    if (what != NULL)\n\tretval = qf_set_properties(qi, what, action, title);\n    else\n    {\n\tretval = qf_add_entries(qi, qi->qf_curlist, list, title, action);\n\tif (retval == OK)\n\t    qf_list_changed(qf_get_curlist(qi));\n    }\n\n    decr_quickfix_busy();\n\n    return retval;\n}\n\n/*\n * Mark the quickfix context and callback function as in use for all the lists\n * in a quickfix stack.\n */\n    static int\nmark_quickfix_ctx(qf_info_T *qi, int copyID)\n{\n    int\t\ti;\n    int\t\tabort = FALSE;\n    typval_T\t*ctx;\n    callback_T\t*cb;\n\n    for (i = 0; i < LISTCOUNT && !abort; ++i)\n    {\n\tctx = qi->qf_lists[i].qf_ctx;\n\tif (ctx != NULL && ctx->v_type != VAR_NUMBER\n\t\t&& ctx->v_type != VAR_STRING && ctx->v_type != VAR_FLOAT)\n\t    abort = abort || set_ref_in_item(ctx, copyID, NULL, NULL);\n\n\tcb = &qi->qf_lists[i].qf_qftf_cb;\n\tabort = abort || set_ref_in_callback(cb, copyID);\n    }\n\n    return abort;\n}\n\n/*\n * Mark the context of the quickfix list and the location lists (if present) as\n * \"in use\". So that garbage collection doesn't free the context.\n */\n    int\nset_ref_in_quickfix(int copyID)\n{\n    int\t\tabort = FALSE;\n    tabpage_T\t*tp;\n    win_T\t*win;\n\n    abort = mark_quickfix_ctx(&ql_info, copyID);\n    if (abort)\n\treturn abort;\n\n    abort = set_ref_in_callback(&qftf_cb, copyID);\n    if (abort)\n\treturn abort;\n\n    FOR_ALL_TAB_WINDOWS(tp, win)\n    {\n\tif (win->w_llist != NULL)\n\t{\n\t    abort = mark_quickfix_ctx(win->w_llist, copyID);\n\t    if (abort)\n\t\treturn abort;\n\t}\n\tif (IS_LL_WINDOW(win) && (win->w_llist_ref->qf_refcount == 1))\n\t{\n\t    // In a location list window and none of the other windows is\n\t    // referring to this location list. Mark the location list\n\t    // context as still in use.\n\t    abort = mark_quickfix_ctx(win->w_llist_ref, copyID);\n\t    if (abort)\n\t\treturn abort;\n\t}\n    }\n\n    return abort;\n}\n#endif\n\n/*\n * Return the autocmd name for the :cbuffer Ex commands\n */\n    static char_u *\ncbuffer_get_auname(cmdidx_T cmdidx)\n{\n    switch (cmdidx)\n    {\n\tcase CMD_cbuffer:\treturn (char_u *)\"cbuffer\";\n\tcase CMD_cgetbuffer:\treturn (char_u *)\"cgetbuffer\";\n\tcase CMD_caddbuffer:\treturn (char_u *)\"caddbuffer\";\n\tcase CMD_lbuffer:\treturn (char_u *)\"lbuffer\";\n\tcase CMD_lgetbuffer:\treturn (char_u *)\"lgetbuffer\";\n\tcase CMD_laddbuffer:\treturn (char_u *)\"laddbuffer\";\n\tdefault:\t\treturn NULL;\n    }\n}\n\n/*\n * Process and validate the arguments passed to the :cbuffer, :caddbuffer,\n * :cgetbuffer, :lbuffer, :laddbuffer, :lgetbuffer Ex commands.\n */\n    static int\ncbuffer_process_args(\n\texarg_T\t\t*eap,\n\tbuf_T\t\t**bufp,\n\tlinenr_T\t*line1,\n\tlinenr_T\t*line2)\n{\n    buf_T\t*buf = NULL;\n\n    if (*eap->arg == NUL)\n\tbuf = curbuf;\n    else if (*skipwhite(skipdigits(eap->arg)) == NUL)\n\tbuf = buflist_findnr(atoi((char *)eap->arg));\n\n    if (buf == NULL)\n    {\n\temsg(_(e_invalid_argument));\n\treturn FAIL;\n    }\n\n    if (buf->b_ml.ml_mfp == NULL)\n    {\n\temsg(_(e_buffer_is_not_loaded));\n\treturn FAIL;\n    }\n\n    if (eap->addr_count == 0)\n    {\n\teap->line1 = 1;\n\teap->line2 = buf->b_ml.ml_line_count;\n    }\n\n    if (eap->line1 < 1 || eap->line1 > buf->b_ml.ml_line_count\n\t    || eap->line2 < 1 || eap->line2 > buf->b_ml.ml_line_count)\n    {\n\temsg(_(e_invalid_range));\n\treturn FAIL;\n    }\n\n    *line1 = eap->line1;\n    *line2 = eap->line2;\n    *bufp = buf;\n\n    return OK;\n}\n\n/*\n * \":[range]cbuffer [bufnr]\" command.\n * \":[range]caddbuffer [bufnr]\" command.\n * \":[range]cgetbuffer [bufnr]\" command.\n * \":[range]lbuffer [bufnr]\" command.\n * \":[range]laddbuffer [bufnr]\" command.\n * \":[range]lgetbuffer [bufnr]\" command.\n */\n    void\nex_cbuffer(exarg_T *eap)\n{\n    buf_T\t*buf = NULL;\n    qf_info_T\t*qi;\n    char_u\t*au_name = NULL;\n    int\t\tres;\n    int_u\tsave_qfid;\n    win_T\t*wp = NULL;\n    char_u\t*qf_title;\n    linenr_T\tline1;\n    linenr_T\tline2;\n\n    au_name = cbuffer_get_auname(eap->cmdidx);\n    if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n\t\t\t\t\tcurbuf->b_fname, TRUE, curbuf))\n    {\n#ifdef FEAT_EVAL\n\tif (aborting())\n\t    return;\n#endif\n    }\n\n    // Must come after autocommands.\n    qi = qf_cmd_get_or_alloc_stack(eap, &wp);\n    if (qi == NULL)\n\treturn;\n\n    if (cbuffer_process_args(eap, &buf, &line1, &line2) == FAIL)\n\treturn;\n\n    qf_title = qf_cmdtitle(*eap->cmdlinep);\n\n    if (buf->b_sfname)\n    {\n\tvim_snprintf((char *)IObuff, IOSIZE, \"%s (%s)\",\n\t\t(char *)qf_title, (char *)buf->b_sfname);\n\tqf_title = IObuff;\n    }\n\n    incr_quickfix_busy();\n\n    res = qf_init_ext(qi, qi->qf_curlist, NULL, buf, NULL, p_efm,\n\t    (eap->cmdidx != CMD_caddbuffer\n\t     && eap->cmdidx != CMD_laddbuffer),\n\t    line1, line2,\n\t    qf_title, NULL);\n    if (qf_stack_empty(qi))\n    {\n\tdecr_quickfix_busy();\n\treturn;\n    }\n    if (res >= 0)\n\tqf_list_changed(qf_get_curlist(qi));\n\n    // Remember the current quickfix list identifier, so that we can\n    // check for autocommands changing the current quickfix list.\n    save_qfid = qf_get_curlist(qi)->qf_id;\n    if (au_name != NULL)\n    {\n\tbuf_T *curbuf_old = curbuf;\n\n\tapply_autocmds(EVENT_QUICKFIXCMDPOST, au_name, curbuf->b_fname,\n\t\t\t\t\t\t\t\tTRUE, curbuf);\n\tif (curbuf != curbuf_old)\n\t    // Autocommands changed buffer, don't jump now, \"qi\" may\n\t    // be invalid.\n\t    res = 0;\n    }\n    // Jump to the first error for a new list and if autocmds didn't\n    // free the list.\n    if (res > 0 && (eap->cmdidx == CMD_cbuffer ||\n\t\teap->cmdidx == CMD_lbuffer)\n\t    && qflist_valid(wp, save_qfid))\n\t// display the first error\n\tqf_jump_first(qi, save_qfid, eap->forceit);\n\n    decr_quickfix_busy();\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return the autocmd name for the :cexpr Ex commands.\n */\n    char_u *\ncexpr_get_auname(cmdidx_T cmdidx)\n{\n    switch (cmdidx)\n    {\n\tcase CMD_cexpr:\t    return (char_u *)\"cexpr\";\n\tcase CMD_cgetexpr:  return (char_u *)\"cgetexpr\";\n\tcase CMD_caddexpr:  return (char_u *)\"caddexpr\";\n\tcase CMD_lexpr:\t    return (char_u *)\"lexpr\";\n\tcase CMD_lgetexpr:  return (char_u *)\"lgetexpr\";\n\tcase CMD_laddexpr:  return (char_u *)\"laddexpr\";\n\tdefault:\t    return NULL;\n    }\n}\n\n    int\ntrigger_cexpr_autocmd(int cmdidx)\n{\n    char_u\t*au_name = cexpr_get_auname(cmdidx);\n\n    if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf))\n    {\n\tif (aborting())\n\t    return FAIL;\n    }\n    return OK;\n}\n\n    int\ncexpr_core(exarg_T *eap, typval_T *tv)\n{\n    qf_info_T\t*qi;\n    win_T\t*wp = NULL;\n\n    qi = qf_cmd_get_or_alloc_stack(eap, &wp);\n    if (qi == NULL)\n\treturn FAIL;\n\n    if ((tv->v_type == VAR_STRING && tv->vval.v_string != NULL)\n\t    || (tv->v_type == VAR_LIST && tv->vval.v_list != NULL))\n    {\n\tint\tres;\n\tint_u\tsave_qfid;\n\tchar_u\t*au_name = cexpr_get_auname(eap->cmdidx);\n\n\tincr_quickfix_busy();\n\tres = qf_init_ext(qi, qi->qf_curlist, NULL, NULL, tv, p_efm,\n\t\t\t(eap->cmdidx != CMD_caddexpr\n\t\t\t && eap->cmdidx != CMD_laddexpr),\n\t\t\t     (linenr_T)0, (linenr_T)0,\n\t\t\t     qf_cmdtitle(*eap->cmdlinep), NULL);\n\tif (qf_stack_empty(qi))\n\t{\n\t    decr_quickfix_busy();\n\t    return FAIL;\n\t}\n\tif (res >= 0)\n\t    qf_list_changed(qf_get_curlist(qi));\n\n\t// Remember the current quickfix list identifier, so that we can\n\t// check for autocommands changing the current quickfix list.\n\tsave_qfid = qf_get_curlist(qi)->qf_id;\n\tif (au_name != NULL)\n\t    apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,\n\t\t\t\t\t    curbuf->b_fname, TRUE, curbuf);\n\n\t// Jump to the first error for a new list and if autocmds didn't\n\t// free the list.\n\tif (res > 0 && (eap->cmdidx == CMD_cexpr || eap->cmdidx == CMD_lexpr)\n\t\t&& qflist_valid(wp, save_qfid))\n\t    // display the first error\n\t    qf_jump_first(qi, save_qfid, eap->forceit);\n\tdecr_quickfix_busy();\n\treturn OK;\n    }\n\n    emsg(_(e_string_or_list_expected));\n    return FAIL;\n}\n\n/*\n * \":cexpr {expr}\", \":cgetexpr {expr}\", \":caddexpr {expr}\" command.\n * \":lexpr {expr}\", \":lgetexpr {expr}\", \":laddexpr {expr}\" command.\n * Also: \":caddexpr\", \":cgetexpr\", \"laddexpr\" and \"laddexpr\".\n */\n    void\nex_cexpr(exarg_T *eap)\n{\n    typval_T\t*tv;\n\n    if (trigger_cexpr_autocmd(eap->cmdidx) == FAIL)\n\treturn;\n\n    // Evaluate the expression.  When the result is a string or a list we can\n    // use it to fill the errorlist.\n    tv = eval_expr(eap->arg, eap);\n    if (tv != NULL)\n    {\n\t(void)cexpr_core(eap, tv);\n\tfree_tv(tv);\n    }\n}\n#endif\n\n/*\n * Get the location list for \":lhelpgrep\"\n */\n    static qf_info_T *\nhgr_get_ll(int *new_ll)\n{\n    win_T\t*wp;\n    qf_info_T\t*qi;\n\n    // If the current window is a help window, then use it\n    if (bt_help(curwin->w_buffer))\n\twp = curwin;\n    else\n\t// Find an existing help window\n\twp = qf_find_help_win();\n\n    if (wp == NULL)\t    // Help window not found\n\tqi = NULL;\n    else\n\tqi = wp->w_llist;\n\n    if (qi == NULL)\n    {\n\t// Allocate a new location list for help text matches\n\tif ((qi = qf_alloc_stack(QFLT_LOCATION)) == NULL)\n\t    return NULL;\n\t*new_ll = TRUE;\n    }\n\n    return qi;\n}\n\n/*\n * Search for a pattern in a help file.\n */\n    static void\nhgr_search_file(\n\tqf_list_T *qfl,\n\tchar_u *fname,\n\tvimconv_T *p_vc,\n\tregmatch_T *p_regmatch)\n{\n    FILE\t*fd;\n    long\tlnum;\n\n    fd = mch_fopen((char *)fname, \"r\");\n    if (fd == NULL)\n\treturn;\n\n    lnum = 1;\n    while (!vim_fgets(IObuff, IOSIZE, fd) && !got_int)\n    {\n\tchar_u    *line = IObuff;\n\n\t// Convert a line if 'encoding' is not utf-8 and\n\t// the line contains a non-ASCII character.\n\tif (p_vc->vc_type != CONV_NONE && has_non_ascii(IObuff))\n\t{\n\t    line = string_convert(p_vc, IObuff, NULL);\n\t    if (line == NULL)\n\t\tline = IObuff;\n\t}\n\n\tif (vim_regexec(p_regmatch, line, (colnr_T)0))\n\t{\n\t    int\tl = (int)STRLEN(line);\n\n\t    // remove trailing CR, LF, spaces, etc.\n\t    while (l > 0 && line[l - 1] <= ' ')\n\t\tline[--l] = NUL;\n\n\t    if (qf_add_entry(qfl,\n\t\t\tNULL,\t// dir\n\t\t\tfname,\n\t\t\tNULL,\n\t\t\t0,\n\t\t\tline,\n\t\t\tlnum,\n\t\t\t0,\n\t\t\t(int)(p_regmatch->startp[0] - line)\n\t\t\t+ 1,\t// col\n\t\t\t(int)(p_regmatch->endp[0] - line)\n\t\t\t+ 1,\t// end_col\n\t\t\tFALSE,\t// vis_col\n\t\t\tNULL,\t// search pattern\n\t\t\t0,\t// nr\n\t\t\t1,\t// type\n\t\t\tTRUE\t// valid\n\t\t\t) == QF_FAIL)\n\t    {\n\t\tgot_int = TRUE;\n\t\tif (line != IObuff)\n\t\t    vim_free(line);\n\t\tbreak;\n\t    }\n\t}\n\tif (line != IObuff)\n\t    vim_free(line);\n\t++lnum;\n\tline_breakcheck();\n    }\n    fclose(fd);\n}\n\n/*\n * Search for a pattern in all the help files in the doc directory under\n * the given directory.\n */\n    static void\nhgr_search_files_in_dir(\n\tqf_list_T *qfl,\n\tchar_u *dirname,\n\tregmatch_T *p_regmatch,\n\tvimconv_T *p_vc\n#ifdef FEAT_MULTI_LANG\n\t, char_u *lang\n#endif\n\t)\n{\n    int\t\tfcount;\n    char_u\t**fnames;\n    int\t\tfi;\n\n    // Find all \"*.txt\" and \"*.??x\" files in the \"doc\" directory.\n    add_pathsep(dirname);\n    STRCAT(dirname, \"doc/*.\\\\(txt\\\\|??x\\\\)\");\n    if (gen_expand_wildcards(1, &dirname, &fcount,\n\t\t&fnames, EW_FILE|EW_SILENT) == OK\n\t    && fcount > 0)\n    {\n\tfor (fi = 0; fi < fcount && !got_int; ++fi)\n\t{\n#ifdef FEAT_MULTI_LANG\n\t    // Skip files for a different language.\n\t    if (lang != NULL\n\t\t    && STRNICMP(lang, fnames[fi]\n\t\t\t\t    + STRLEN(fnames[fi]) - 3, 2) != 0\n\t\t    && !(STRNICMP(lang, \"en\", 2) == 0\n\t\t\t&& STRNICMP(\"txt\", fnames[fi]\n\t\t\t    + STRLEN(fnames[fi]) - 3, 3) == 0))\n\t\tcontinue;\n#endif\n\n\t    hgr_search_file(qfl, fnames[fi], p_vc, p_regmatch);\n\t}\n\tFreeWild(fcount, fnames);\n    }\n}\n\n/*\n * Search for a pattern in all the help files in the 'runtimepath'\n * and add the matches to a quickfix list.\n * 'lang' is the language specifier.  If supplied, then only matches in the\n * specified language are found.\n */\n    static void\nhgr_search_in_rtp(qf_list_T *qfl, regmatch_T *p_regmatch, char_u *lang)\n{\n    char_u\t*p;\n\n    vimconv_T\tvc;\n\n    // Help files are in utf-8 or latin1, convert lines when 'encoding'\n    // differs.\n    vc.vc_type = CONV_NONE;\n    if (!enc_utf8)\n\tconvert_setup(&vc, (char_u *)\"utf-8\", p_enc);\n\n    // Go through all the directories in 'runtimepath'\n    p = p_rtp;\n    while (*p != NUL && !got_int)\n    {\n\tcopy_option_part(&p, NameBuff, MAXPATHL, \",\");\n\n\thgr_search_files_in_dir(qfl, NameBuff, p_regmatch, &vc\n#ifdef FEAT_MULTI_LANG\n\t\t, lang\n#endif\n\t\t);\n    }\n\n    if (vc.vc_type != CONV_NONE)\n\tconvert_setup(&vc, NULL, NULL);\n}\n\n/*\n * \":helpgrep {pattern}\"\n */\n    void\nex_helpgrep(exarg_T *eap)\n{\n    regmatch_T\tregmatch;\n    char_u\t*save_cpo;\n    int\t\tsave_cpo_allocated;\n    qf_info_T\t*qi = &ql_info;\n    int\t\tnew_qi = FALSE;\n    char_u\t*au_name =  NULL;\n    char_u\t*lang = NULL;\n    int\t\tupdated = FALSE;\n\n    switch (eap->cmdidx)\n    {\n\tcase CMD_helpgrep:  au_name = (char_u *)\"helpgrep\"; break;\n\tcase CMD_lhelpgrep: au_name = (char_u *)\"lhelpgrep\"; break;\n\tdefault: break;\n    }\n    if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf))\n    {\n#ifdef FEAT_EVAL\n\tif (aborting())\n\t    return;\n#endif\n    }\n\n    if (is_loclist_cmd(eap->cmdidx))\n    {\n\tqi = hgr_get_ll(&new_qi);\n\tif (qi == NULL)\n\t    return;\n    }\n\n    // Make 'cpoptions' empty, the 'l' flag should not be used here.\n    save_cpo = p_cpo;\n    save_cpo_allocated = is_option_allocated(\"cpo\");\n    p_cpo = empty_option;\n\n    incr_quickfix_busy();\n\n#ifdef FEAT_MULTI_LANG\n    // Check for a specified language\n    lang = check_help_lang(eap->arg);\n#endif\n    regmatch.regprog = vim_regcomp(eap->arg, RE_MAGIC + RE_STRING);\n    regmatch.rm_ic = FALSE;\n    if (regmatch.regprog != NULL)\n    {\n\tqf_list_T\t*qfl;\n\n\t// create a new quickfix list\n\tqf_new_list(qi, qf_cmdtitle(*eap->cmdlinep));\n\tqfl = qf_get_curlist(qi);\n\n\thgr_search_in_rtp(qfl, &regmatch, lang);\n\n\tvim_regfree(regmatch.regprog);\n\n\tqfl->qf_nonevalid = FALSE;\n\tqfl->qf_ptr = qfl->qf_start;\n\tqfl->qf_index = 1;\n\tqf_list_changed(qfl);\n\tupdated = TRUE;\n    }\n\n    if (p_cpo == empty_option)\n\tp_cpo = save_cpo;\n    else\n    {\n\t// Darn, some plugin changed the value.  If it's still empty it was\n\t// changed and restored, need to restore in the complicated way.\n\tif (*p_cpo == NUL)\n\t    set_option_value_give_err((char_u *)\"cpo\", 0L, save_cpo, 0);\n\tif (save_cpo_allocated)\n\t    free_string_option(save_cpo);\n    }\n\n    if (updated)\n\t// This may open a window and source scripts, do this after 'cpo' was\n\t// restored.\n\tqf_update_buffer(qi, NULL);\n\n    if (au_name != NULL)\n    {\n\tapply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf);\n\t// When adding a location list to an existing location list stack,\n\t// if the autocmd made the stack invalid, then just return.\n\tif (!new_qi && IS_LL_STACK(qi) && qf_find_win_with_loclist(qi) == NULL)\n\t{\n\t    decr_quickfix_busy();\n\t    return;\n\t}\n    }\n\n    // Jump to first match.\n    if (!qf_list_empty(qf_get_curlist(qi)))\n\tqf_jump(qi, 0, 0, FALSE);\n    else\n\tsemsg(_(e_no_match_str_2), eap->arg);\n\n    decr_quickfix_busy();\n\n    if (eap->cmdidx == CMD_lhelpgrep)\n    {\n\t// If the help window is not opened or if it already points to the\n\t// correct location list, then free the new location list.\n\tif (!bt_help(curwin->w_buffer) || curwin->w_llist == qi)\n\t{\n\t    if (new_qi)\n\t\tll_free_all(&qi);\n\t}\n\telse if (curwin->w_llist == NULL && new_qi)\n\t    // current window didn't have a location list associated with it\n\t    // before. Associate the new location list now.\n\t    curwin->w_llist = qi;\n    }\n}\n#endif // FEAT_QUICKFIX\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n# ifdef FEAT_QUICKFIX\n    static void\nget_qf_loc_list(int is_qf, win_T *wp, typval_T *what_arg, typval_T *rettv)\n{\n    if (what_arg->v_type == VAR_UNKNOWN)\n    {\n\tif (rettv_list_alloc(rettv) == OK)\n\t    if (is_qf || wp != NULL)\n\t\t(void)get_errorlist(NULL, wp, -1, 0, rettv->vval.v_list);\n    }\n    else\n    {\n\tif (rettv_dict_alloc(rettv) == OK)\n\t    if (is_qf || (wp != NULL))\n\t    {\n\t\tif (what_arg->v_type == VAR_DICT)\n\t\t{\n\t\t    dict_T\t*d = what_arg->vval.v_dict;\n\n\t\t    if (d != NULL)\n\t\t\tqf_get_properties(wp, d, rettv->vval.v_dict);\n\t\t}\n\t\telse\n\t\t    emsg(_(e_dictionary_required));\n\t    }\n    }\n}\n# endif\n\n/*\n * \"getloclist()\" function\n */\n    void\nf_getloclist(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n# ifdef FEAT_QUICKFIX\n    win_T\t*wp;\n\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_dict_arg(argvars, 1) == FAIL))\n\treturn;\n\n    wp = find_win_by_nr_or_id(&argvars[0]);\n    get_qf_loc_list(FALSE, wp, &argvars[1], rettv);\n# endif\n}\n\n/*\n * \"getqflist()\" function\n */\n    void\nf_getqflist(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n# ifdef FEAT_QUICKFIX\n    if (in_vim9script() && check_for_opt_dict_arg(argvars, 0) == FAIL)\n\treturn;\n\n    get_qf_loc_list(TRUE, NULL, &argvars[0], rettv);\n# endif\n}\n\n/*\n * Used by \"setqflist()\" and \"setloclist()\" functions\n */\n    static void\nset_qf_ll_list(\n    win_T\t*wp UNUSED,\n    typval_T\t*list_arg UNUSED,\n    typval_T\t*action_arg UNUSED,\n    typval_T\t*what_arg UNUSED,\n    typval_T\t*rettv)\n{\n# ifdef FEAT_QUICKFIX\n    char_u\t*act;\n    int\t\taction = 0;\n    static int\trecursive = 0;\n# endif\n\n    rettv->vval.v_number = -1;\n\n# ifdef FEAT_QUICKFIX\n    if (list_arg->v_type != VAR_LIST)\n\temsg(_(e_list_required));\n    else if (recursive != 0)\n\temsg(_(e_autocommand_caused_recursive_behavior));\n    else\n    {\n\tlist_T  *l = list_arg->vval.v_list;\n\tdict_T\t*what = NULL;\n\tint\tvalid_dict = TRUE;\n\n\tif (action_arg->v_type == VAR_STRING)\n\t{\n\t    act = tv_get_string_chk(action_arg);\n\t    if (act == NULL)\n\t\treturn;\t\t// type error; errmsg already given\n\t    if ((*act == 'a' || *act == 'r' || *act == ' ' || *act == 'f') &&\n\t\t    act[1] == NUL)\n\t\taction = *act;\n\t    else\n\t\tsemsg(_(e_invalid_action_str_1), act);\n\t}\n\telse if (action_arg->v_type == VAR_UNKNOWN)\n\t    action = ' ';\n\telse\n\t    emsg(_(e_string_required));\n\n\tif (action_arg->v_type != VAR_UNKNOWN\n\t\t&& what_arg->v_type != VAR_UNKNOWN)\n\t{\n\t    if (what_arg->v_type == VAR_DICT && what_arg->vval.v_dict != NULL)\n\t\twhat = what_arg->vval.v_dict;\n\t    else\n\t    {\n\t\temsg(_(e_dictionary_required));\n\t\tvalid_dict = FALSE;\n\t    }\n\t}\n\n\t++recursive;\n\tif (l != NULL && action && valid_dict\n\t\t    && set_errorlist(wp, l, action,\n\t\t     (char_u *)(wp == NULL ? \":setqflist()\" : \":setloclist()\"),\n\t\t     what) == OK)\n\t    rettv->vval.v_number = 0;\n\t--recursive;\n    }\n# endif\n}\n\n/*\n * \"setloclist()\" function\n */\n    void\nf_setloclist(typval_T *argvars, typval_T *rettv)\n{\n    win_T\t*win;\n\n    rettv->vval.v_number = -1;\n\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_list_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 2) == FAIL\n\t\t|| (argvars[2].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_dict_arg(argvars, 3) == FAIL)))\n\treturn;\n\n    win = find_win_by_nr_or_id(&argvars[0]);\n    if (win != NULL)\n\tset_qf_ll_list(win, &argvars[1], &argvars[2], &argvars[3], rettv);\n}\n\n/*\n * \"setqflist()\" function\n */\n    void\nf_setqflist(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script()\n\t    && (check_for_list_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 1) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_dict_arg(argvars, 2) == FAIL)))\n\treturn;\n\n    set_qf_ll_list(NULL, &argvars[0], &argvars[1], &argvars[2], rettv);\n}\n#endif\n", "\" Test for the quickfix feature.\n\nsource check.vim\nimport './vim9.vim' as v9\nCheckFeature quickfix\n\nsource screendump.vim\n\nset encoding=utf-8\n\nfunc s:setup_commands(cchar)\n  if a:cchar == 'c'\n    command! -nargs=* -bang Xlist <mods>clist<bang> <args>\n    command! -nargs=* Xgetexpr <mods>cgetexpr <args>\n    command! -nargs=* Xaddexpr <mods>caddexpr <args>\n    command! -nargs=* -count Xolder <mods><count>colder <args>\n    command! -nargs=* Xnewer <mods>cnewer <args>\n    command! -nargs=* Xopen <mods> copen <args>\n    command! -nargs=* Xwindow <mods>cwindow <args>\n    command! -nargs=* Xbottom <mods>cbottom <args>\n    command! -nargs=* Xclose <mods>cclose <args>\n    command! -nargs=* -bang Xfile <mods>cfile<bang> <args>\n    command! -nargs=* Xgetfile <mods>cgetfile <args>\n    command! -nargs=* Xaddfile <mods>caddfile <args>\n    command! -nargs=* -bang Xbuffer <mods>cbuffer<bang> <args>\n    command! -nargs=* Xgetbuffer <mods>cgetbuffer <args>\n    command! -nargs=* Xaddbuffer <mods>caddbuffer <args>\n    command! -nargs=* Xrewind <mods>crewind <args>\n    command! -count -nargs=* -bang Xnext <mods><count>cnext<bang> <args>\n    command! -count -nargs=* -bang Xprev <mods><count>cprev<bang> <args>\n    command! -nargs=* -bang Xfirst <mods>cfirst<bang> <args>\n    command! -nargs=* -bang Xlast <mods>clast<bang> <args>\n    command! -count -nargs=* -bang Xnfile <mods><count>cnfile<bang> <args>\n    command! -nargs=* -bang Xpfile <mods>cpfile<bang> <args>\n    command! -nargs=* Xexpr <mods>cexpr <args>\n    command! -count=999 -nargs=* Xvimgrep <mods> <count>vimgrep <args>\n    command! -nargs=* Xvimgrepadd <mods> vimgrepadd <args>\n    command! -nargs=* Xgrep <mods> grep <args>\n    command! -nargs=* Xgrepadd <mods> grepadd <args>\n    command! -nargs=* Xhelpgrep helpgrep <args>\n    command! -nargs=0 -count Xcc <count>cc\n    command! -count=1 -nargs=0 Xbelow <mods><count>cbelow\n    command! -count=1 -nargs=0 Xabove <mods><count>cabove\n    command! -count=1 -nargs=0 Xbefore <mods><count>cbefore\n    command! -count=1 -nargs=0 Xafter <mods><count>cafter\n    let g:Xgetlist = function('getqflist')\n    let g:Xsetlist = function('setqflist')\n    call setqflist([], 'f')\n  else\n    command! -nargs=* -bang Xlist <mods>llist<bang> <args>\n    command! -nargs=* Xgetexpr <mods>lgetexpr <args>\n    command! -nargs=* Xaddexpr <mods>laddexpr <args>\n    command! -nargs=* -count Xolder <mods><count>lolder <args>\n    command! -nargs=* Xnewer <mods>lnewer <args>\n    command! -nargs=* Xopen <mods> lopen <args>\n    command! -nargs=* Xwindow <mods>lwindow <args>\n    command! -nargs=* Xbottom <mods>lbottom <args>\n    command! -nargs=* Xclose <mods>lclose <args>\n    command! -nargs=* -bang Xfile <mods>lfile<bang> <args>\n    command! -nargs=* Xgetfile <mods>lgetfile <args>\n    command! -nargs=* Xaddfile <mods>laddfile <args>\n    command! -nargs=* -bang Xbuffer <mods>lbuffer<bang> <args>\n    command! -nargs=* Xgetbuffer <mods>lgetbuffer <args>\n    command! -nargs=* Xaddbuffer <mods>laddbuffer <args>\n    command! -nargs=* Xrewind <mods>lrewind <args>\n    command! -count -nargs=* -bang Xnext <mods><count>lnext<bang> <args>\n    command! -count -nargs=* -bang Xprev <mods><count>lprev<bang> <args>\n    command! -nargs=* -bang Xfirst <mods>lfirst<bang> <args>\n    command! -nargs=* -bang Xlast <mods>llast<bang> <args>\n    command! -count -nargs=* -bang Xnfile <mods><count>lnfile<bang> <args>\n    command! -nargs=* -bang Xpfile <mods>lpfile<bang> <args>\n    command! -nargs=* Xexpr <mods>lexpr <args>\n    command! -count=999 -nargs=* Xvimgrep <mods> <count>lvimgrep <args>\n    command! -nargs=* Xvimgrepadd <mods> lvimgrepadd <args>\n    command! -nargs=* Xgrep <mods> lgrep <args>\n    command! -nargs=* Xgrepadd <mods> lgrepadd <args>\n    command! -nargs=* Xhelpgrep lhelpgrep <args>\n    command! -nargs=0 -count Xcc <count>ll\n    command! -count=1 -nargs=0 Xbelow <mods><count>lbelow\n    command! -count=1 -nargs=0 Xabove <mods><count>labove\n    command! -count=1 -nargs=0 Xbefore <mods><count>lbefore\n    command! -count=1 -nargs=0 Xafter <mods><count>lafter\n    let g:Xgetlist = function('getloclist', [0])\n    let g:Xsetlist = function('setloclist', [0])\n    call setloclist(0, [], 'f')\n  endif\nendfunc\n\n\" This must be run before any error lists are created.\nfunc Test_AA_cc_no_errors()\n  call assert_fails('cc', 'E42:')\n  call assert_fails('ll', 'E42:')\nendfunc\n\n\" Tests for the :clist and :llist commands\nfunc XlistTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  if a:cchar == 'l'\n      call assert_fails('llist', 'E776:')\n  endif\n  \" With an empty list, command should return error\n  Xgetexpr []\n  silent! Xlist\n  call assert_true(v:errmsg ==# 'E42: No Errors')\n\n  \" Populate the list and then try\n  let lines =<< trim END\n    non-error 1\n    Xtestfile1:1:3:Line1\n    non-error 2\n    Xtestfile2:2:2:Line2\n    non-error| 3\n    Xtestfile3:3:1:Line3\n  END\n  Xgetexpr lines\n\n  \" List only valid entries\n  let l = split(execute('Xlist', ''), \"\\n\")\n  call assert_equal([' 2 Xtestfile1:1 col 3: Line1',\n\t\t   \\ ' 4 Xtestfile2:2 col 2: Line2',\n\t\t   \\ ' 6 Xtestfile3:3 col 1: Line3'], l)\n\n  \" List all the entries\n  let l = split(execute('Xlist!', ''), \"\\n\")\n  call assert_equal([' 1: non-error 1', ' 2 Xtestfile1:1 col 3: Line1',\n\t\t   \\ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2',\n\t\t   \\ ' 5: non-error| 3', ' 6 Xtestfile3:3 col 1: Line3'], l)\n\n  \" List a range of errors\n  let l = split(execute('Xlist 3,6', ''), \"\\n\")\n  call assert_equal([' 4 Xtestfile2:2 col 2: Line2',\n\t\t   \\ ' 6 Xtestfile3:3 col 1: Line3'], l)\n\n  let l = split(execute('Xlist! 3,4', ''), \"\\n\")\n  call assert_equal([' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)\n\n  let l = split(execute('Xlist -6,-4', ''), \"\\n\")\n  call assert_equal([' 2 Xtestfile1:1 col 3: Line1'], l)\n\n  let l = split(execute('Xlist! -5,-3', ''), \"\\n\")\n  call assert_equal([' 2 Xtestfile1:1 col 3: Line1',\n\t\t   \\ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)\n\n  \" Test for '+'\n  let l = split(execute('Xlist! +2', ''), \"\\n\")\n  call assert_equal([' 2 Xtestfile1:1 col 3: Line1',\n\t\t   \\ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)\n\n  \" Ranged entries\n  call g:Xsetlist([{'lnum':10,'text':'Line1'},\n\t      \\ {'lnum':20,'col':10,'text':'Line2'},\n\t      \\ {'lnum':30,'col':15,'end_col':20,'text':'Line3'},\n\t      \\ {'lnum':40,'end_lnum':45,'text':'Line4'},\n\t      \\ {'lnum':50,'end_lnum':55,'col':15,'text':'Line5'},\n\t      \\ {'lnum':60,'end_lnum':65,'col':25,'end_col':35,'text':'Line6'}])\n  let l = split(execute('Xlist', \"\"), \"\\n\")\n  call assert_equal([' 1:10: Line1',\n\t      \\ ' 2:20 col 10: Line2',\n\t      \\ ' 3:30 col 15-20: Line3',\n\t      \\ ' 4:40-45: Line4',\n\t      \\ ' 5:50-55 col 15: Line5',\n\t      \\ ' 6:60-65 col 25-35: Line6'], l)\n\n  \" Different types of errors\n  call g:Xsetlist([{'lnum':10,'col':5,'type':'W', 'text':'Warning','nr':11},\n\t      \\ {'lnum':20,'col':10,'type':'e','text':'Error','nr':22},\n\t      \\ {'lnum':30,'col':15,'type':'i','text':'Info','nr':33},\n\t      \\ {'lnum':40,'col':20,'type':'x', 'text':'Other','nr':44},\n\t      \\ {'lnum':50,'col':25,'type':\"\\<C-A>\",'text':'one','nr':55}])\n  let l = split(execute('Xlist', \"\"), \"\\n\")\n  call assert_equal([' 1:10 col 5 warning  11: Warning',\n\t      \\ ' 2:20 col 10 error  22: Error',\n\t      \\ ' 3:30 col 15 info  33: Info',\n\t      \\ ' 4:40 col 20 x  44: Other',\n\t      \\ ' 5:50 col 25  55: one'], l)\n\n  \" Test for module names, one needs to explicitly set `'valid':v:true` so\n  call g:Xsetlist([\n\t\\ {'lnum':10,'col':5,'type':'W','module':'Data.Text','text':'ModuleWarning','nr':11,'valid':v:true},\n\t\\ {'lnum':20,'col':10,'type':'W','module':'Data.Text','filename':'Data/Text.hs','text':'ModuleWarning','nr':22,'valid':v:true},\n\t\\ {'lnum':30,'col':15,'type':'W','filename':'Data/Text.hs','text':'FileWarning','nr':33,'valid':v:true}])\n  let l = split(execute('Xlist', \"\"), \"\\n\")\n  call assert_equal([' 1 Data.Text:10 col 5 warning  11: ModuleWarning',\n\t\\ ' 2 Data.Text:20 col 10 warning  22: ModuleWarning',\n\t\\ ' 3 Data/Text.hs:30 col 15 warning  33: FileWarning'], l)\n\n  \" Very long line should be displayed.\n  let text = 'Line' .. repeat('1234567890', 130)\n  let lines = ['Xtestfile9:2:9:' .. text]\n  Xgetexpr lines\n\n  let l = split(execute('Xlist', ''), \"\\n\")\n  call assert_equal([' 1 Xtestfile9:2 col 9: ' .. text] , l)\n\n  \" For help entries in the quickfix list, only the filename without directory\n  \" should be displayed\n  Xhelpgrep setqflist()\n  let l = split(execute('Xlist 1', ''), \"\\n\")\n  call assert_match('^ 1 [^\\\\/]\\{-}:', l[0])\n\n  \" Error cases\n  call assert_fails('Xlist abc', 'E488:')\nendfunc\n\nfunc Test_clist()\n  call XlistTests('c')\n  call XlistTests('l')\nendfunc\n\n\" Tests for the :colder, :cnewer, :lolder and :lnewer commands\n\" Note that this test assumes that a quickfix/location list is\n\" already set by the caller.\nfunc XageTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  if a:cchar == 'l'\n    \" No location list for the current window\n    call assert_fails('lolder', 'E776:')\n    call assert_fails('lnewer', 'E776:')\n  endif\n\n  let list = [{'bufnr': bufnr('%'), 'lnum': 1}]\n  call g:Xsetlist(list)\n\n  \" Jumping to a non existent list should return error\n  silent! Xolder 99\n  call assert_true(v:errmsg ==# 'E380: At bottom of quickfix stack')\n\n  silent! Xnewer 99\n  call assert_true(v:errmsg ==# 'E381: At top of quickfix stack')\n\n  \" Add three quickfix/location lists\n  Xgetexpr ['Xtestfile1:1:3:Line1']\n  Xgetexpr ['Xtestfile2:2:2:Line2']\n  Xgetexpr ['Xtestfile3:3:1:Line3']\n\n  \" Go back two lists\n  Xolder\n  let l = g:Xgetlist()\n  call assert_equal('Line2', l[0].text)\n\n  \" Go forward two lists\n  Xnewer\n  let l = g:Xgetlist()\n  call assert_equal('Line3', l[0].text)\n\n  \" Test for the optional count argument\n  Xolder 2\n  let l = g:Xgetlist()\n  call assert_equal('Line1', l[0].text)\n\n  Xnewer 2\n  let l = g:Xgetlist()\n  call assert_equal('Line3', l[0].text)\nendfunc\n\nfunc Test_cage()\n  call XageTests('c')\n  call XageTests('l')\nendfunc\n\n\" Tests for the :cwindow, :lwindow :cclose, :lclose, :copen and :lopen\n\" commands\nfunc XwindowTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Opening the location list window without any errors should fail\n  if a:cchar == 'l'\n      call assert_fails('lopen', 'E776:')\n      call assert_fails('lwindow', 'E776:')\n  endif\n\n  \" Create a list with no valid entries\n  Xgetexpr ['non-error 1', 'non-error 2', 'non-error 3']\n\n  \" Quickfix/Location window should not open with no valid errors\n  Xwindow\n  call assert_true(winnr('$') == 1)\n\n  \" Create a list with valid entries\n  let lines =<< trim END\n    Xtestfile1:1:3:Line1\n    Xtestfile2:2:2:Line2\n    Xtestfile3:3:1:Line3\n  END\n  Xgetexpr lines\n\n  \" Open the window\n  Xwindow\n  call assert_true(winnr('$') == 2 && winnr() == 2 &&\n\t\\ getline('.') ==# 'Xtestfile1|1 col 3| Line1')\n  redraw!\n\n  \" Close the window\n  Xclose\n  call assert_true(winnr('$') == 1)\n\n  \" Create a list with no valid entries\n  Xgetexpr ['non-error 1', 'non-error 2', 'non-error 3']\n\n  \" Open the window\n  Xopen 5\n  call assert_true(winnr('$') == 2 && getline('.') ==# '|| non-error 1'\n\t\t      \\  && winheight(0) == 5)\n\n  \" Opening the window again, should move the cursor to that window\n  wincmd t\n  Xopen 7\n  call assert_true(winnr('$') == 2 && winnr() == 2 &&\n\t\\ winheight(0) == 7 &&\n\t\\ getline('.') ==# '|| non-error 1')\n\n  \" :cnext in quickfix window should move to the next entry\n  Xnext\n  call assert_equal(2, g:Xgetlist({'idx' : 0}).idx)\n\n  \" Calling cwindow should close the quickfix window with no valid errors\n  Xwindow\n  call assert_true(winnr('$') == 1)\n\n  \" Specifying the width should adjust the width for a vertically split\n  \" quickfix window.\n  vert Xopen\n  call assert_equal(10, winwidth(0))\n  vert Xopen 12\n  call assert_equal(12, winwidth(0))\n  Xclose\n\n  \" Horizontally or vertically splitting the quickfix window should create a\n  \" normal window/buffer\n  Xopen\n  wincmd s\n  call assert_equal(0, getwininfo(win_getid())[0].quickfix)\n  call assert_equal(0, getwininfo(win_getid())[0].loclist)\n  call assert_notequal('quickfix', &buftype)\n  close\n  Xopen\n  wincmd v\n  call assert_equal(0, getwininfo(win_getid())[0].quickfix)\n  call assert_equal(0, getwininfo(win_getid())[0].loclist)\n  call assert_notequal('quickfix', &buftype)\n  close\n  Xopen\n  Xclose\n\n  if a:cchar == 'c'\n      \" Opening the quickfix window in multiple tab pages should reuse the\n      \" quickfix buffer\n      let lines =<< trim END\n        Xtestfile1:1:3:Line1\n        Xtestfile2:2:2:Line2\n        Xtestfile3:3:1:Line3\n      END\n      Xgetexpr lines\n      Xopen\n      let qfbufnum = bufnr('%')\n      tabnew\n      Xopen\n      call assert_equal(qfbufnum, bufnr('%'))\n      new | only | tabonly\n  endif\nendfunc\n\nfunc Test_cwindow()\n  call XwindowTests('c')\n  call XwindowTests('l')\nendfunc\n\nfunc Test_copenHeight()\n  copen\n  wincmd H\n  let height = winheight(0)\n  copen 10\n  call assert_equal(height, winheight(0))\n  quit\nendfunc\n\nfunc Test_copenHeight_tabline()\n  set tabline=foo showtabline=2\n  copen\n  wincmd H\n  let height = winheight(0)\n  copen 10\n  call assert_equal(height, winheight(0))\n  quit\n  set tabline& showtabline&\nendfunc\n\n\" Tests for the :cfile, :lfile, :caddfile, :laddfile, :cgetfile and :lgetfile\n\" commands.\nfunc XfileTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  let lines =<< trim END\n    Xtestfile1:700:10:Line 700\n    Xtestfile2:800:15:Line 800\n  END\n  call writefile(lines, 'Xqftestfile1')\n\n  enew!\n  Xfile Xqftestfile1\n  let l = g:Xgetlist()\n  call assert_true(len(l) == 2 &&\n\t\\ l[0].lnum == 700 && l[0].col == 10 && l[0].text ==# 'Line 700' &&\n\t\\ l[1].lnum == 800 && l[1].col == 15 && l[1].text ==# 'Line 800')\n\n  \" Test with a non existent file\n  call assert_fails('Xfile non_existent_file', 'E40:')\n\n  \" Run cfile/lfile from a modified buffer\n  enew!\n  silent! put ='Quickfix'\n  silent! Xfile Xqftestfile1\n  call assert_true(v:errmsg ==# 'E37: No write since last change (add ! to override)')\n\n  call writefile(['Xtestfile3:900:30:Line 900'], 'Xqftestfile1')\n  Xaddfile Xqftestfile1\n  let l = g:Xgetlist()\n  call assert_true(len(l) == 3 &&\n\t\\ l[2].lnum == 900 && l[2].col == 30 && l[2].text ==# 'Line 900')\n\n  let lines =<< trim END\n    Xtestfile1:222:77:Line 222\n    Xtestfile2:333:88:Line 333\n  END\n  call writefile(lines, 'Xqftestfile1')\n\n  enew!\n  Xgetfile Xqftestfile1\n  let l = g:Xgetlist()\n  call assert_true(len(l) == 2 &&\n\t\\ l[0].lnum == 222 && l[0].col == 77 && l[0].text ==# 'Line 222' &&\n\t\\ l[1].lnum == 333 && l[1].col == 88 && l[1].text ==# 'Line 333')\n\n  \" Test for a file with a long line and without a newline at the end\n  let text = repeat('x', 1024)\n  let t = 'a.txt:18:' . text\n  call writefile([t], 'Xqftestfile1', 'b')\n  silent! Xfile Xqftestfile1\n  call assert_equal(text, g:Xgetlist()[0].text)\n\n  call delete('Xqftestfile1')\nendfunc\n\nfunc Test_cfile()\n  call XfileTests('c')\n  call XfileTests('l')\nendfunc\n\n\" Tests for the :cbuffer, :lbuffer, :caddbuffer, :laddbuffer, :cgetbuffer and\n\" :lgetbuffer commands.\nfunc XbufferTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  enew!\n  let lines =<< trim END\n    Xtestfile7:700:10:Line 700\n    Xtestfile8:800:15:Line 800\n  END\n  silent! call setline(1, lines)\n  Xbuffer!\n  let l = g:Xgetlist()\n  call assert_true(len(l) == 2 &&\n\t\\ l[0].lnum == 700 && l[0].col == 10 && l[0].text ==# 'Line 700' &&\n\t\\ l[1].lnum == 800 && l[1].col == 15 && l[1].text ==# 'Line 800')\n\n  enew!\n  let lines =<< trim END\n    Xtestfile9:900:55:Line 900\n    Xtestfile10:950:66:Line 950\n  END\n  silent! call setline(1, lines)\n  Xgetbuffer\n  let l = g:Xgetlist()\n  call assert_true(len(l) == 2 &&\n\t\\ l[0].lnum == 900 && l[0].col == 55 && l[0].text ==# 'Line 900' &&\n\t\\ l[1].lnum == 950 && l[1].col == 66 && l[1].text ==# 'Line 950')\n\n  enew!\n  let lines =<< trim END\n    Xtestfile11:700:20:Line 700\n    Xtestfile12:750:25:Line 750\n  END\n  silent! call setline(1, lines)\n  Xaddbuffer\n  let l = g:Xgetlist()\n  call assert_true(len(l) == 4 &&\n\t\\ l[1].lnum == 950 && l[1].col == 66 && l[1].text ==# 'Line 950' &&\n\t\\ l[2].lnum == 700 && l[2].col == 20 && l[2].text ==# 'Line 700' &&\n\t\\ l[3].lnum == 750 && l[3].col == 25 && l[3].text ==# 'Line 750')\n  enew!\n\n  \" Check for invalid buffer\n  call assert_fails('Xbuffer 199', 'E474:')\n\n  \" Check for unloaded buffer\n  edit Xtestfile1\n  let bnr = bufnr('%')\n  enew!\n  call assert_fails('Xbuffer ' . bnr, 'E681:')\n\n  \" Check for invalid range\n  \" Using Xbuffer will not run the range check in the cbuffer/lbuffer\n  \" commands. So directly call the commands.\n  if (a:cchar == 'c')\n      call assert_fails('900,999cbuffer', 'E16:')\n  else\n      call assert_fails('900,999lbuffer', 'E16:')\n  endif\nendfunc\n\nfunc Test_cbuffer()\n  call XbufferTests('c')\n  call XbufferTests('l')\nendfunc\n\nfunc XexprTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call assert_fails('Xexpr 10', 'E777:')\nendfunc\n\nfunc Test_cexpr()\n  call XexprTests('c')\n  call XexprTests('l')\nendfunc\n\n\" Tests for :cnext, :cprev, :cfirst, :clast commands\nfunc Xtest_browse(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n  \" Jumping to first or next location list entry without any error should\n  \" result in failure\n  if a:cchar == 'c'\n    let err = 'E42:'\n    let cmd = '$cc'\n  else\n    let err = 'E776:'\n    let cmd = '$ll'\n  endif\n  call assert_fails('Xnext', err)\n  call assert_fails('Xprev', err)\n  call assert_fails('Xnfile', err)\n  call assert_fails('Xpfile', err)\n  call assert_fails(cmd, err)\n\n  Xexpr ''\n  call assert_fails(cmd, 'E42:')\n\n  call s:create_test_file('Xqftestfile1')\n  call s:create_test_file('Xqftestfile2')\n\n  let lines =<< trim END\n    Xqftestfile1:5:Line5\n    Xqftestfile1:6:Line6\n    Xqftestfile2:10:Line10\n    Xqftestfile2:11:Line11\n    RegularLine1\n    RegularLine2\n  END\n  Xgetexpr lines\n\n  Xfirst\n  call assert_fails('-5Xcc', 'E16:')\n  call assert_fails('Xprev', 'E553:')\n  call assert_fails('Xpfile', 'E553:')\n  Xnfile\n  call assert_equal('Xqftestfile2', @%)\n  call assert_equal(10, line('.'))\n  Xpfile\n  call assert_equal('Xqftestfile1', @%)\n  call assert_equal(6, line('.'))\n  5Xcc\n  call assert_equal(5, g:Xgetlist({'idx':0}).idx)\n  2Xcc\n  call assert_equal(2, g:Xgetlist({'idx':0}).idx)\n  if a:cchar == 'c'\n    cc\n  else\n    ll\n  endif\n  call assert_equal(2, g:Xgetlist({'idx':0}).idx)\n  10Xcc\n  call assert_equal(6, g:Xgetlist({'idx':0}).idx)\n  Xlast\n  Xprev\n  call assert_equal('Xqftestfile2', @%)\n  call assert_equal(11, line('.'))\n  call assert_fails('Xnext', 'E553:')\n  call assert_fails('Xnfile', 'E553:')\n  \" To process the range using quickfix list entries, directly use the\n  \" quickfix commands (don't use the user defined commands)\n  if a:cchar == 'c'\n    $cc\n  else\n    $ll\n  endif\n  call assert_equal(6, g:Xgetlist({'idx':0}).idx)\n  Xrewind\n  call assert_equal('Xqftestfile1', @%)\n  call assert_equal(5, line('.'))\n\n  10Xnext\n  call assert_equal('Xqftestfile2', @%)\n  call assert_equal(11, line('.'))\n  10Xprev\n  call assert_equal('Xqftestfile1', @%)\n  call assert_equal(5, line('.'))\n\n  \" Jumping to an error from the error window using cc command\n  let lines =<< trim END\n    Xqftestfile1:5:Line5\n    Xqftestfile1:6:Line6\n    Xqftestfile2:10:Line10\n    Xqftestfile2:11:Line11\n  END\n  Xgetexpr lines\n  Xopen\n  10Xcc\n  call assert_equal(11, line('.'))\n  call assert_equal('Xqftestfile2', @%)\n  Xopen\n  call cursor(2, 1)\n  if a:cchar == 'c'\n    .cc\n  else\n    .ll\n  endif\n  call assert_equal(6, line('.'))\n  call assert_equal('Xqftestfile1', @%)\n\n  \" Jumping to an error from the error window (when only the error window is\n  \" present)\n  Xopen | only\n  Xlast 1\n  call assert_equal(5, line('.'))\n  call assert_equal('Xqftestfile1', @%)\n\n  Xexpr \"\"\n  call assert_fails('Xnext', 'E42:')\n\n  call delete('Xqftestfile1')\n  call delete('Xqftestfile2')\n\n  \" Should be able to use next/prev with invalid entries\n  Xexpr \"\"\n  call assert_equal(0, g:Xgetlist({'idx' : 0}).idx)\n  call assert_equal(0, g:Xgetlist({'size' : 0}).size)\n  Xaddexpr ['foo', 'bar', 'baz', 'quux', 'sh|moo']\n  call assert_equal(5, g:Xgetlist({'size' : 0}).size)\n  Xlast\n  call assert_equal(5, g:Xgetlist({'idx' : 0}).idx)\n  Xfirst\n  call assert_equal(1, g:Xgetlist({'idx' : 0}).idx)\n  2Xnext\n  call assert_equal(3, g:Xgetlist({'idx' : 0}).idx)\nendfunc\n\nfunc Test_browse()\n  call Xtest_browse('c')\n  call Xtest_browse('l')\nendfunc\n\n\" Test for memory allocation failures\nfunc Xnomem_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call test_alloc_fail(GetAllocId('qf_dirname_start'), 0, 0)\n  call assert_fails('Xvimgrep vim runtest.vim', 'E342:')\n\n  call test_alloc_fail(GetAllocId('qf_dirname_now'), 0, 0)\n  call assert_fails('Xvimgrep vim runtest.vim', 'E342:')\n\n  call test_alloc_fail(GetAllocId('qf_namebuf'), 0, 0)\n  call assert_fails('Xfile runtest.vim', 'E342:')\n\n  call test_alloc_fail(GetAllocId('qf_errmsg'), 0, 0)\n  call assert_fails('Xfile runtest.vim', 'E342:')\n\n  call test_alloc_fail(GetAllocId('qf_pattern'), 0, 0)\n  call assert_fails('Xfile runtest.vim', 'E342:')\n\n  call test_alloc_fail(GetAllocId('qf_efm_fmtstr'), 0, 0)\n  set efm=%f\n  call assert_fails('Xexpr [\"Xfile1\"]', 'E342:')\n  set efm&\n\n  call test_alloc_fail(GetAllocId('qf_efm_fmtpart'), 0, 0)\n  set efm=%f:%l:%m,%f-%l-%m\n  call assert_fails('Xaddexpr [\"Xfile2\", \"Xfile3\"]', 'E342:')\n  set efm&\n\n  call test_alloc_fail(GetAllocId('qf_title'), 0, 0)\n  call assert_fails('Xexpr \"\"', 'E342:')\n  call assert_equal('', g:Xgetlist({'all': 1}).title)\n\n  call test_alloc_fail(GetAllocId('qf_mef_name'), 0, 0)\n  set makeef=Xtmp##.err\n  call assert_fails('Xgrep needle haystack', 'E342:')\n  set makeef&\n\n  call test_alloc_fail(GetAllocId('qf_qfline'), 0, 0)\n  call assert_fails('Xexpr \"Xfile1:10:Line10\"', 'E342:')\n\n  if a:cchar == 'l'\n    for id in ['qf_qfline', 'qf_qfinfo']\n      lgetexpr [\"Xfile1:10:L10\", \"Xfile2:20:L20\"]\n      call test_alloc_fail(GetAllocId(id), 0, 0)\n      call assert_fails('new', 'E342:')\n      call assert_equal(2, winnr('$'))\n      call assert_equal([], getloclist(0))\n      %bw!\n    endfor\n  endif\n\n  call test_alloc_fail(GetAllocId('qf_qfline'), 0, 0)\n  try\n    call assert_fails('Xvimgrep vim runtest.vim', 'E342:')\n  catch /^Vim:Interrupt$/\n  endtry\n\n  call test_alloc_fail(GetAllocId('qf_qfline'), 0, 0)\n  try\n    call assert_fails('Xvimgrep /vim/f runtest.vim', 'E342:')\n  catch /^Vim:Interrupt$/\n  endtry\n\n  let l = getqflist({\"lines\": [\"Xfile1:10:L10\"]})\n  call test_alloc_fail(GetAllocId('qf_qfline'), 0, 0)\n  call assert_fails('call g:Xsetlist(l.items)', 'E342:')\n\n  call test_alloc_fail(GetAllocId('qf_qfline'), 0, 0)\n  try\n    call assert_fails('Xhelpgrep quickfix', 'E342:')\n  catch /^Vim:Interrupt$/\n  endtry\n\n  call test_alloc_fail(GetAllocId('qf_qfinfo'), 0, 0)\n  call assert_fails('let l = g:Xgetlist({\"lines\": [\"Xfile1:10:L10\"]})', 'E342:')\n  call assert_equal(#{items: []}, l)\n\n  if a:cchar == 'l'\n    call setqflist([], 'f')\n    call setloclist(0, [], 'f')\n    call test_alloc_fail(GetAllocId('qf_qfinfo'), 0, 0)\n    call assert_fails('lhelpgrep quickfix', 'E342:')\n    call assert_equal([], getloclist(0))\n\n    call test_alloc_fail(GetAllocId('qf_qfinfo'), 0, 0)\n    call assert_fails('lvimgrep vim runtest.vim', 'E342:')\n\n    let l = getqflist({\"lines\": [\"Xfile1:10:L10\"]})\n    call test_alloc_fail(GetAllocId('qf_qfinfo'), 0, 0)\n    call assert_fails('call setloclist(0, l.items)', 'E342:')\n\n    call test_alloc_fail(GetAllocId('qf_qfinfo'), 0, 0)\n    call assert_fails('lbuffer', 'E342:')\n\n    call test_alloc_fail(GetAllocId('qf_qfinfo'), 0, 0)\n    call assert_fails('lexpr [\"Xfile1:10:L10\", \"Xfile2:20:L20\"]', 'E342:')\n\n    call test_alloc_fail(GetAllocId('qf_qfinfo'), 0, 0)\n    call assert_fails('lfile runtest.vim', 'E342:')\n  endif\n\n  call test_alloc_fail(GetAllocId('qf_dirstack'), 0, 0)\n  set efm=%DEntering\\ dir\\ %f,%f:%l:%m\n  call assert_fails('Xexpr [\"Entering dir abc\", \"abc.txt:1:Hello world\"]', 'E342:')\n  set efm&\n\n  call test_alloc_fail(GetAllocId('qf_dirstack'), 0, 0)\n  set efm=%+P[%f],(%l)%m\n  call assert_fails('Xexpr [\"[runtest.vim]\", \"(1)Hello\"]', 'E342:')\n  set efm&\n\n  call test_alloc_fail(GetAllocId('qf_multiline_pfx'), 0, 0)\n  set efm=%EError,%Cline\\ %l,%Z%m\n  call assert_fails('Xexpr [\"Error\", \"line 1\", \"msg\"]', 'E342:')\n  set efm&\n\n  call test_alloc_fail(GetAllocId('qf_makecmd'), 0, 0)\n  call assert_fails('Xgrep vim runtest.vim', 'E342:')\n\n  call test_alloc_fail(GetAllocId('qf_linebuf'), 0, 0)\n  call assert_fails('Xexpr repeat(\"a\", 8192)', 'E342:')\n\n  call test_alloc_fail(GetAllocId('qf_linebuf'), 0, 0)\n  call assert_fails('Xexpr [repeat(\"a\", 8192)]', 'E342:')\n\n  new\n  call setline(1, repeat('a', 8192))\n  call test_alloc_fail(GetAllocId('qf_linebuf'), 0, 0)\n  call assert_fails('Xbuffer', 'E342:')\n  %bw!\n\n  call writefile([repeat('a', 8192)], 'Xtest')\n  call test_alloc_fail(GetAllocId('qf_linebuf'), 0, 0)\n  call assert_fails('Xfile Xtest', 'E342:')\n  call delete('Xtest')\nendfunc\n\nfunc Test_nomem()\n  call Xnomem_tests('c')\n  call Xnomem_tests('l')\nendfunc\n\nfunc s:test_xhelpgrep(cchar)\n  call s:setup_commands(a:cchar)\n  Xhelpgrep quickfix\n  Xopen\n  if a:cchar == 'c'\n    let title_text = ':helpgrep quickfix'\n  else\n    let title_text = ':lhelpgrep quickfix'\n  endif\n  call assert_true(w:quickfix_title =~ title_text, w:quickfix_title)\n\n  \" Jumping to a help topic should open the help window\n  only\n  Xnext\n  call assert_true(&buftype == 'help')\n  call assert_true(winnr('$') == 2)\n  \" Jumping to the next match should reuse the help window\n  Xnext\n  call assert_true(&buftype == 'help')\n  call assert_true(winnr() == 1)\n  call assert_true(winnr('$') == 2)\n  \" Jumping to the next match from the quickfix window should reuse the help\n  \" window\n  Xopen\n  Xnext\n  call assert_true(&buftype == 'help')\n  call assert_true(winnr() == 1)\n  call assert_true(winnr('$') == 2)\n  call assert_match('|\\d\\+ col \\d\\+-\\d\\+|', getbufline(winbufnr(2), 1)[0])\n\n  \" This wipes out the buffer, make sure that doesn't cause trouble.\n  Xclose\n\n  \" When the current window is vertically split, jumping to a help match\n  \" should open the help window at the top.\n  only | enew\n  let w1 = win_getid()\n  vert new\n  let w2 = win_getid()\n  Xnext\n  let w3 = win_getid()\n  call assert_true(&buftype == 'help')\n  call assert_true(winnr() == 1)\n  \" See jump_to_help_window() for details\n  let w2_width = winwidth(w2)\n  if w2_width != &columns && w2_width < 80\n    call assert_equal(['col', [['leaf', w3],\n          \\ ['row', [['leaf', w2], ['leaf', w1]]]]], winlayout())\n  else\n    call assert_equal(['row', [['col', [['leaf', w3], ['leaf', w2]]],\n          \\ ['leaf', w1]]] , winlayout())\n  endif\n\n  new | only\n  set buftype=help\n  set modified\n  call assert_fails('Xnext', 'E37:')\n  set nomodified\n  new | only\n\n  if a:cchar == 'l'\n      \" When a help window is present, running :lhelpgrep should reuse the\n      \" help window and not the current window\n      new | only\n      call g:Xsetlist([], 'f')\n      help index.txt\n      wincmd w\n      lhelpgrep quickfix\n      call assert_equal(1, winnr())\n      call assert_notequal([], getloclist(1))\n      call assert_equal([], getloclist(2))\n  endif\n\n  new | only\n\n  \" Search for non existing help string\n  call assert_fails('Xhelpgrep a1b2c3', 'E480:')\n  \" Invalid regular expression\n  call assert_fails('Xhelpgrep \\@<!', 'E866:')\nendfunc\n\nfunc Test_helpgrep()\n  call s:test_xhelpgrep('c')\n  helpclose\n  call s:test_xhelpgrep('l')\nendfunc\n\ndef Test_helpgrep_vim9_restore_cpo()\n  assert_equal('aABceFs', &cpo)\n\n  var rtp_save = &rtp\n  var dir = 'Xruntime/after'\n  &rtp ..= ',' .. dir\n  mkdir(dir .. '/ftplugin', 'p')\n  writefile(['vim9script'], dir .. '/ftplugin/qf.vim')\n  filetype plugin on\n  silent helpgrep grail\n  cwindow\n  silent helpgrep grail\n\n  assert_equal('aABceFs', &cpo)\n  delete('Xruntime', 'rf')\n  &rtp = rtp_save\n  cclose\n  helpclose\nenddef\n\n\" When running the :helpgrep command, if an autocmd modifies the 'cpoptions'\n\" value, then Vim crashes. (issue fixed by 7.2b-004 and 8.2.4453)\nfunc Test_helpgrep_restore_cpo_aucmd()\n  let save_cpo = &cpo\n  augroup QF_Test\n    au!\n    autocmd BufNew * set cpo=acd\n  augroup END\n\n  helpgrep quickfix\n  call assert_equal('acd', &cpo)\n  %bw!\n\n  set cpo&vim\n  augroup QF_Test\n    au!\n    autocmd BufReadPost * set cpo=\n  augroup END\n\n  helpgrep buffer\n  call assert_equal('', &cpo)\n\n  augroup QF_Test\n    au!\n  augroup END\n  %bw!\n  let &cpo = save_cpo\nendfunc\n\ndef Test_vim9_cexpr()\n  var text = 'somefile:95:error'\n  cexpr text\n  var l = getqflist()\n  assert_equal(1, l->len())\n  assert_equal(95, l[0].lnum)\n  assert_equal('error', l[0].text)\n\n  text = 'somefile:77:warning'\n  caddexpr text\n  l = getqflist()\n  assert_equal(2, l->len())\n  assert_equal(77, l[1].lnum)\n  assert_equal('warning', l[1].text)\nenddef\n\nfunc Test_errortitle()\n  augroup QfBufWinEnter\n    au!\n    au BufWinEnter * :let g:a=get(w:, 'quickfix_title', 'NONE')\n  augroup END\n  copen\n  let a=[{'lnum': 308, 'bufnr': bufnr(''), 'col': 58, 'valid': 1, 'vcol': 0, 'nr': 0, 'type': '', 'pattern': '', 'text': '    au BufWinEnter * :let g:a=get(w:, ''quickfix_title'', ''NONE'')'}]\n  call setqflist(a)\n  call assert_equal(':setqflist()', g:a)\n  augroup QfBufWinEnter\n    au!\n  augroup END\n  augroup! QfBufWinEnter\nendfunc\n\nfunc Test_vimgreptitle()\n  augroup QfBufWinEnter\n    au!\n    au BufWinEnter * :let g:a=get(w:, 'quickfix_title', 'NONE')\n  augroup END\n  try\n    vimgrep /pattern/j file\n  catch /E480/\n  endtry\n  copen\n  call assert_equal(':    vimgrep /pattern/j file', g:a)\n  augroup QfBufWinEnter\n    au!\n  augroup END\n  augroup! QfBufWinEnter\nendfunc\n\nfunc Test_bufwinenter_once()\n  augroup QfBufWinEnter\n    au!\n    au BufWinEnter * let g:got_afile ..= 'got ' .. expand('<afile>')\n  augroup END\n  let g:got_afile = ''\n  copen\n  call assert_equal('got quickfix', g:got_afile)\n\n  cclose\n  unlet g:got_afile\n  augroup QfBufWinEnter\n    au!\n  augroup END\n  augroup! QfBufWinEnter\nendfunc\n\nfunc XqfTitleTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  Xgetexpr ['file:1:1:message']\n  let l = g:Xgetlist()\n  if a:cchar == 'c'\n    call setqflist(l, 'r')\n  else\n    call setloclist(0, l, 'r')\n  endif\n\n  Xopen\n  if a:cchar == 'c'\n    let title = ':setqflist()'\n  else\n    let title = ':setloclist()'\n  endif\n  call assert_equal(title, w:quickfix_title)\n  Xclose\nendfunc\n\n\" Tests for quickfix window's title\nfunc Test_qf_title()\n  call XqfTitleTests('c')\n  call XqfTitleTests('l')\nendfunc\n\n\" Tests for 'errorformat'\nfunc Test_efm()\n  let save_efm = &efm\n  set efm=%EEEE%m,%WWWW%m,%+CCCC%.%#,%-GGGG%.%#\n  cgetexpr ['WWWW', 'EEEE', 'CCCC']\n  let l = strtrans(string(map(getqflist(), '[v:val.text, v:val.valid]')))\n  call assert_equal(\"[['W', 1], ['E^@CCCC', 1]]\", l)\n  cgetexpr ['WWWW', 'GGGG', 'EEEE', 'CCCC']\n  let l = strtrans(string(map(getqflist(), '[v:val.text, v:val.valid]')))\n  call assert_equal(\"[['W', 1], ['E^@CCCC', 1]]\", l)\n  cgetexpr ['WWWW', 'GGGG', 'ZZZZ', 'EEEE', 'CCCC', 'YYYY']\n  let l = strtrans(string(map(getqflist(), '[v:val.text, v:val.valid]')))\n  call assert_equal(\"[['W', 1], ['ZZZZ', 0], ['E^@CCCC', 1], ['YYYY', 0]]\", l)\n  let &efm = save_efm\nendfunc\n\n\" This will test for problems in quickfix:\n\" A. incorrectly copying location lists which caused the location list to show\n\"    a different name than the file that was actually being displayed.\n\" B. not reusing the window for which the location list window is opened but\n\"    instead creating new windows.\n\" C. make sure that the location list window is not reused instead of the\n\"    window it belongs to.\n\"\n\" Set up the test environment:\nfunc ReadTestProtocol(name)\n  let base = substitute(a:name, '\\v^test://(.*)%(\\.[^.]+)?', '\\1', '')\n  let word = substitute(base, '\\v(.*)\\..*', '\\1', '')\n\n  setl modifiable\n  setl noreadonly\n  setl noswapfile\n  setl bufhidden=delete\n  %del _\n  \" For problem 2:\n  \" 'buftype' has to be set to reproduce the constant opening of new windows\n  setl buftype=nofile\n\n  call setline(1, word)\n\n  setl nomodified\n  setl nomodifiable\n  setl readonly\n  exe 'doautocmd BufRead ' . substitute(a:name, '\\v^test://(.*)', '\\1', '')\nendfunc\n\nfunc Test_locationlist()\n  enew\n\n  augroup testgroup\n    au!\n    autocmd BufReadCmd test://* call ReadTestProtocol(expand(\"<amatch>\"))\n  augroup END\n\n  let words = [ \"foo\", \"bar\", \"baz\", \"quux\", \"shmoo\", \"spam\", \"eggs\" ]\n\n  let qflist = []\n  for word in words\n    call add(qflist, {'filename': 'test://' . word . '.txt', 'text': 'file ' . word . '.txt', })\n    \" NOTE: problem 1:\n    \" intentionally not setting 'lnum' so that the quickfix entries are not\n    \" valid\n    eval qflist->setloclist(0, ' ')\n  endfor\n\n  \" Test A\n  lrewind\n  enew\n  lopen\n  4lnext\n  vert split\n  wincmd L\n  lopen\n  wincmd p\n  lnext\n  let fileName = expand(\"%\")\n  wincmd p\n  let locationListFileName = substitute(getline(line('.')), '\\([^|]*\\)|.*', '\\1', '')\n  let fileName = substitute(fileName, '\\\\', '/', 'g')\n  let locationListFileName = substitute(locationListFileName, '\\\\', '/', 'g')\n  call assert_equal(\"test://bar.txt\", fileName)\n  call assert_equal(\"test://bar.txt\", locationListFileName)\n\n  wincmd n | only\n\n  \" Test B:\n  lrewind\n  lopen\n  2\n  exe \"normal \\<CR>\"\n  wincmd p\n  3\n  exe \"normal \\<CR>\"\n  wincmd p\n  4\n  exe \"normal \\<CR>\"\n  call assert_equal(2, winnr('$'))\n  wincmd n | only\n\n  \" Test C:\n  lrewind\n  lopen\n  \" Let's move the location list window to the top to check whether it (the\n  \" first window found) will be reused when we try to open new windows:\n  wincmd K\n  2\n  exe \"normal \\<CR>\"\n  wincmd p\n  3\n  exe \"normal \\<CR>\"\n  wincmd p\n  4\n  exe \"normal \\<CR>\"\n  1wincmd w\n  call assert_equal('quickfix', &buftype)\n  2wincmd w\n  let bufferName = expand(\"%\")\n  let bufferName = substitute(bufferName, '\\\\', '/', 'g')\n  call assert_equal('test://quux.txt', bufferName)\n\n  wincmd n | only\n\n  augroup! testgroup\nendfunc\n\nfunc Test_locationlist_curwin_was_closed()\n  augroup testgroup\n    au!\n    autocmd BufReadCmd test_curwin.txt call R(expand(\"<amatch>\"))\n  augroup END\n\n  func! R(n)\n    quit\n  endfunc\n\n  new\n  let q = []\n  call add(q, {'filename': 'test_curwin.txt' })\n  call setloclist(0, q)\n  call assert_fails('lrewind', 'E924:')\n\n  augroup! testgroup\n  delfunc R\nendfunc\n\nfunc Test_locationlist_cross_tab_jump()\n  call writefile(['loclistfoo'], 'loclistfoo')\n  call writefile(['loclistbar'], 'loclistbar')\n  set switchbuf=usetab\n\n  edit loclistfoo\n  tabedit loclistbar\n  silent lgrep loclistfoo loclist*\n  call assert_equal(1, tabpagenr())\n\n  enew | only | tabonly\n  set switchbuf&vim\n  call delete('loclistfoo')\n  call delete('loclistbar')\nendfunc\n\n\" More tests for 'errorformat'\nfunc Test_efm1()\n  \" The 'errorformat' setting is different on non-Unix systems.\n  \" This test works only on Unix-like systems.\n  CheckUnix\n\n  let l =<< trim [DATA]\n    \"Xtestfile\", line 4.12: 1506-045 (S) Undeclared identifier fd_set.\n    \ufeff\"Xtestfile\", line 6 col 19; this is an error\n    gcc -c -DHAVE_CONFIsing-prototypes -I/usr/X11R6/include  version.c\n    Xtestfile:9: parse error before `asd'\n    make: *** [vim] Error 1\n    in file \"Xtestfile\" linenr 10: there is an error\n\n    2 returned\n    \"Xtestfile\", line 11 col 1; this is an error\n    \"Xtestfile\", line 12 col 2; this is another error\n    \"Xtestfile\", line 14:10; this is an error in column 10\n    =Xtestfile=, line 15:10; this is another error, but in vcol 10 this time\n    \"Xtestfile\", linenr 16: yet another problem\n    Error in \"Xtestfile\" at line 17:\n    x should be a dot\n    \txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 17\n                ^\n    Error in \"Xtestfile\" at line 18:\n    x should be a dot\n    \txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 18\n    .............^\n    Error in \"Xtestfile\" at line 19:\n    x should be a dot\n    \txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 19\n    --------------^\n    Error in \"Xtestfile\" at line 20:\n    x should be a dot\n    \txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 20\n    \t       ^\n\n    Does anyone know what is the problem and how to correction it?\n    \"Xtestfile\", line 21 col 9: What is the title of the quickfix window?\n    \"Xtestfile\", line 22 col 9: What is the title of the quickfix window?\n  [DATA]\n\n  call writefile(l, 'Xerrorfile1')\n  call writefile(l[:-2], 'Xerrorfile2')\n\n  let m =<< [DATA]\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  2\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  3\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  4\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  5\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  6\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  7\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  8\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  9\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 10\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 11\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 12\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 13\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 14\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 15\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 16\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 17\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 18\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 19\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 20\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 21\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 22\n[DATA]\n  call writefile(m, 'Xtestfile')\n\n  let save_efm = &efm\n  set efm+==%f=\\\\,\\ line\\ %l%*\\\\D%v%*[^\\ ]\\ %m\n  set efm^=%AError\\ in\\ \\\"%f\\\"\\ at\\ line\\ %l:,%Z%p^,%C%m\n\n  exe 'cf Xerrorfile2'\n  clast\n  copen\n  call assert_equal(':cf Xerrorfile2', w:quickfix_title)\n  wincmd p\n\n  exe 'cf Xerrorfile1'\n  call assert_equal([4, 12], [line('.'), col('.')])\n  cn\n  call assert_equal([6, 19], [line('.'), col('.')])\n  cn\n  call assert_equal([9, 2], [line('.'), col('.')])\n  cn\n  call assert_equal([10, 2], [line('.'), col('.')])\n  cn\n  call assert_equal([11, 1], [line('.'), col('.')])\n  cn\n  call assert_equal([12, 2], [line('.'), col('.')])\n  cn\n  call assert_equal([14, 10], [line('.'), col('.')])\n  cn\n  call assert_equal([15, 3, 10], [line('.'), col('.'), virtcol('.')])\n  cn\n  call assert_equal([16, 2], [line('.'), col('.')])\n  cn\n  call assert_equal([17, 6], [line('.'), col('.')])\n  cn\n  call assert_equal([18, 7], [line('.'), col('.')])\n  cn\n  call assert_equal([19, 8], [line('.'), col('.')])\n  cn\n  call assert_equal([20, 9], [line('.'), col('.')])\n  clast\n  cprev\n  cprev\n  wincmd w\n  call assert_equal(':cf Xerrorfile1', w:quickfix_title)\n  wincmd p\n\n  let &efm = save_efm\n  call delete('Xerrorfile1')\n  call delete('Xerrorfile2')\n  call delete('Xtestfile')\nendfunc\n\n\" Test for quickfix directory stack support\nfunc s:dir_stack_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  let save_efm=&efm\n  set efm=%DEntering\\ dir\\ '%f',%f:%l:%m,%XLeaving\\ dir\\ '%f'\n\n  let lines =<< trim END\n    Entering dir 'dir1/a'\n    habits2.txt:1:Nine Healthy Habits\n    Entering dir 'b'\n    habits3.txt:2:0 Hours of television\n    habits2.txt:7:5 Small meals\n    Entering dir 'dir1/c'\n    habits4.txt:3:1 Hour of exercise\n    Leaving dir 'dir1/c'\n    Leaving dir 'dir1/a'\n    habits1.txt:4:2 Liters of water\n    Entering dir 'dir2'\n    habits5.txt:5:3 Cups of hot green tea\n    Leaving dir 'dir2'\n  END\n\n  Xexpr \"\"\n  for l in lines\n      Xaddexpr l\n  endfor\n\n  let qf = g:Xgetlist()\n\n  call assert_equal('dir1/a/habits2.txt', bufname(qf[1].bufnr))\n  call assert_equal(1, qf[1].lnum)\n  call assert_equal('dir1/a/b/habits3.txt', bufname(qf[3].bufnr))\n  call assert_equal(2, qf[3].lnum)\n  call assert_equal('dir1/a/habits2.txt', bufname(qf[4].bufnr))\n  call assert_equal(7, qf[4].lnum)\n  call assert_equal('dir1/c/habits4.txt', bufname(qf[6].bufnr))\n  call assert_equal(3, qf[6].lnum)\n  call assert_equal('habits1.txt', bufname(qf[9].bufnr))\n  call assert_equal(4, qf[9].lnum)\n  call assert_equal('dir2/habits5.txt', bufname(qf[11].bufnr))\n  call assert_equal(5, qf[11].lnum)\n\n  let &efm=save_efm\nendfunc\n\n\" Tests for %D and %X errorformat options\nfunc Test_efm_dirstack()\n  \" Create the directory stack and files\n  call mkdir('dir1')\n  call mkdir('dir1/a')\n  call mkdir('dir1/a/b')\n  call mkdir('dir1/c')\n  call mkdir('dir2')\n\n  let lines =<< trim END\n    Nine Healthy Habits\n    0 Hours of television\n    1 Hour of exercise\n    2 Liters of water\n    3 Cups of hot green tea\n    4 Short mental breaks\n    5 Small meals\n    6 AM wake up time\n    7 Minutes of laughter\n    8 Hours of sleep (at least)\n    9 PM end of the day and off to bed\n  END\n  call writefile(lines, 'habits1.txt')\n  call writefile(lines, 'dir1/a/habits2.txt')\n  call writefile(lines, 'dir1/a/b/habits3.txt')\n  call writefile(lines, 'dir1/c/habits4.txt')\n  call writefile(lines, 'dir2/habits5.txt')\n\n  call s:dir_stack_tests('c')\n  call s:dir_stack_tests('l')\n\n  call delete('dir1', 'rf')\n  call delete('dir2', 'rf')\n  call delete('habits1.txt')\nendfunc\n\n\" Test for resync after continuing an ignored message\nfunc Xefm_ignore_continuations(cchar)\n  call s:setup_commands(a:cchar)\n\n  let save_efm = &efm\n\n  let &efm =\n\t\\ '%Eerror %m %l,' .\n\t\\ '%-Wignored %m %l,' .\n\t\\ '%+Cmore ignored %m %l,' .\n\t\\ '%Zignored end'\n  let lines =<< trim END\n    ignored warning 1\n    more ignored continuation 2\n    ignored end\n    error resync 4\n  END\n  Xgetexpr lines\n  let l = map(g:Xgetlist(), '[v:val.text, v:val.valid, v:val.lnum, v:val.type]')\n  call assert_equal([['resync', 1, 4, 'E']], l)\n\n  let &efm = save_efm\nendfunc\n\nfunc Test_efm_ignore_continuations()\n  call Xefm_ignore_continuations('c')\n  call Xefm_ignore_continuations('l')\nendfunc\n\n\" Tests for invalid error format specifies\nfunc Xinvalid_efm_Tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  let save_efm = &efm\n\n  set efm=%f:%l:%m,%f:%f:%l:%m\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E372:')\n\n  set efm=%f:%l:%m,%f:%l:%r:%m\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E373:')\n\n  set efm=%f:%l:%m,%O:%f:%l:%m\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E373:')\n\n  set efm=%f:%l:%m,%f:%l:%*[^a-z\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E374:')\n\n  set efm=%f:%l:%m,%f:%l:%*c\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E375:')\n\n  set efm=%f:%l:%m,%L%M%N\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E376:')\n\n  set efm=%f:%l:%m,%f:%l:%m:%R\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E377:')\n\n  \" Invalid regular expression\n  set efm=%\\\\%%k\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E867:')\n\n  set efm=\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E378:')\n\n  \" Empty directory name. When there is an error in parsing new entries, make\n  \" sure the previous quickfix list is made the current list.\n  set efm&\n  cexpr [\"one\", \"two\"]\n  let qf_id = getqflist(#{id: 0}).id\n  set efm=%DEntering\\ dir\\ abc,%f:%l:%m\n  call assert_fails('Xexpr [\"Entering dir abc\", \"abc.txt:1:Hello world\"]', 'E379:')\n  call assert_equal(qf_id, getqflist(#{id: 0}).id)\n\n  let &efm = save_efm\nendfunc\n\nfunc Test_invalid_efm()\n  call Xinvalid_efm_Tests('c')\n  call Xinvalid_efm_Tests('l')\nendfunc\n\n\" TODO:\n\" Add tests for the following formats in 'errorformat'\n\"\t%r  %O\nfunc Test_efm2()\n  let save_efm = &efm\n\n  \" Test for %s format in efm\n  set efm=%f:%s\n  cexpr 'Xtestfile:Line search text'\n  let l = getqflist()\n  call assert_equal('^\\VLine search text\\$', l[0].pattern)\n  call assert_equal(0, l[0].lnum)\n\n  let l = split(execute('clist', ''), \"\\n\")\n  call assert_equal([' 1 Xtestfile:^\\VLine search text\\$:  '], l)\n\n  \" Test for a long line\n  cexpr 'Xtestfile:' . repeat('a', 1026)\n  let l = getqflist()\n  call assert_equal('^\\V' . repeat('a', 1019) . '\\$', l[0].pattern)\n\n  \" Test for %P, %Q and %t format specifiers\n  let lines =<< trim [DATA]\n    [Xtestfile1]\n    (1,17)  error: ';' missing\n    (21,2)  warning: variable 'z' not defined\n    (67,3)  error: end of file found before string ended\n    --\n\n    [Xtestfile2]\n    --\n\n    [Xtestfile3]\n    NEW compiler v1.1\n    (2,2)   warning: variable 'x' not defined\n    (67,3)  warning: 's' already defined\n    --\n  [DATA]\n\n  set efm=%+P[%f]%r,(%l\\\\,%c)%*[\\ ]%t%*[^:]:\\ %m,%+Q--%r\n  \" To exercise the push/pop file functionality in quickfix, the test files\n  \" need to be created.\n  call writefile(['Line1'], 'Xtestfile1')\n  call writefile(['Line2'], 'Xtestfile2')\n  call writefile(['Line3'], 'Xtestfile3')\n  cexpr \"\"\n  for l in lines\n      caddexpr l\n  endfor\n  let l = getqflist()\n  call assert_equal(12, len(l))\n  call assert_equal(21, l[2].lnum)\n  call assert_equal(2, l[2].col)\n  call assert_equal('w', l[2].type)\n  call assert_equal('e', l[3].type)\n  call delete('Xtestfile1')\n  call delete('Xtestfile2')\n  call delete('Xtestfile3')\n\n  \" Test for %P, %Q with non-existing files\n  cexpr lines\n  let l = getqflist()\n  call assert_equal(14, len(l))\n  call assert_equal('[Xtestfile1]', l[0].text)\n  call assert_equal('[Xtestfile2]', l[6].text)\n  call assert_equal('[Xtestfile3]', l[9].text)\n\n  \" Tests for %E, %C and %Z format specifiers\n  let lines =<< trim [DATA]\n    Error 275\n    line 42\n    column 3\n    ' ' expected after '--'\n  [DATA]\n\n  set efm=%EError\\ %n,%Cline\\ %l,%Ccolumn\\ %c,%Z%m\n  cgetexpr lines\n  let l = getqflist()\n  call assert_equal(275, l[0].nr)\n  call assert_equal(42, l[0].lnum)\n  call assert_equal(3, l[0].col)\n  call assert_equal('E', l[0].type)\n  call assert_equal(\"\\n' ' expected after '--'\", l[0].text)\n\n  \" Test for %>\n  let lines =<< trim [DATA]\n    Error in line 147 of foo.c:\n    unknown variable 'i'\n  [DATA]\n\n  set efm=unknown\\ variable\\ %m,%E%>Error\\ in\\ line\\ %l\\ of\\ %f:,%Z%m\n  cgetexpr lines\n  let l = getqflist()\n  call assert_equal(147, l[0].lnum)\n  call assert_equal('E', l[0].type)\n  call assert_equal(\"\\nunknown variable 'i'\", l[0].text)\n\n  \" Test for %A, %C and other formats\n  let lines =<< trim [DATA]\n    ==============================================================\n    FAIL: testGetTypeIdCachesResult (dbfacadeTest.DjsDBFacadeTest)\n    --------------------------------------------------------------\n    Traceback (most recent call last):\n      File \"unittests/dbfacadeTest.py\", line 89, in testFoo\n        self.assertEquals(34, dtid)\n      File \"/usr/lib/python2.2/unittest.py\", line 286, in\n     failUnlessEqual\n        raise self.failureException, \\\\\n    W:AssertionError: 34 != 33\n  \n    --------------------------------------------------------------\n    Ran 27 tests in 0.063s\n  [DATA]\n\n  set efm=%C\\ %.%#,%A\\ \\ File\\ \\\"%f\\\"\\\\,\\ line\\ %l%.%#,%Z%[%^\\ ]%\\\\@=%t:%m\n  cgetexpr lines\n  let l = getqflist()\n  call assert_equal(8, len(l))\n  call assert_equal(89, l[4].lnum)\n  call assert_equal(1, l[4].valid)\n  call assert_equal('unittests/dbfacadeTest.py', bufname(l[4].bufnr))\n  call assert_equal('W', l[4].type)\n\n  \" Test for %o\n  set efm=%f(%o):%l\\ %m\n  cgetexpr ['Xotestfile(Language.PureScript.Types):20 Error']\n  call writefile(['Line1'], 'Xotestfile')\n  let l = getqflist()\n  call assert_equal(1, len(l), string(l))\n  call assert_equal('Language.PureScript.Types', l[0].module)\n  copen\n  call assert_equal('Language.PureScript.Types|20| Error', getline(1))\n  call feedkeys(\"\\<CR>\", 'xn')\n  call assert_equal('Xotestfile', expand('%:t'))\n  cclose\n  bd\n  call delete(\"Xotestfile\")\n\n  \" Test for a long module name\n  cexpr 'Xtest(' . repeat('m', 1026) . '):15 message'\n  let l = getqflist()\n  call assert_equal(repeat('m', 1024), l[0].module)\n  call assert_equal(15, l[0].lnum)\n  call assert_equal('message', l[0].text)\n\n  \" The following sequence of commands used to crash Vim\n  set efm=%W%m\n  cgetexpr ['msg1']\n  let l = getqflist()\n  call assert_equal(1, len(l), string(l))\n  call assert_equal('msg1', l[0].text)\n  set efm=%C%m\n  lexpr 'msg2'\n  let l = getloclist(0)\n  call assert_equal(1, len(l), string(l))\n  call assert_equal('msg2', l[0].text)\n  lopen\n  call setqflist([], 'r')\n  caddbuf\n  let l = getqflist()\n  call assert_equal(1, len(l), string(l))\n  call assert_equal('|| msg2', l[0].text)\n\n  \" When matching error lines, case should be ignored. Test for this.\n  set noignorecase\n  let l=getqflist({'lines' : ['Xtest:FOO10:Line 20'], 'efm':'%f:foo%l:%m'})\n  call assert_equal(10, l.items[0].lnum)\n  call assert_equal('Line 20', l.items[0].text)\n  set ignorecase&\n\n  new | only\n  let &efm = save_efm\nendfunc\n\n\" Test for '%t' (error type) field in 'efm'\nfunc Test_efm_error_type()\n  let save_efm = &efm\n\n  \" error type\n  set efm=%f:%l:%t:%m\n  let lines =<< trim END\n    Xfile1:10:E:msg1\n    Xfile1:20:W:msg2\n    Xfile1:30:I:msg3\n    Xfile1:40:N:msg4\n    Xfile1:50:R:msg5\n  END\n  cexpr lines\n  let output = split(execute('clist'), \"\\n\")\n  call assert_equal([\n        \\ ' 1 Xfile1:10 error: msg1',\n        \\ ' 2 Xfile1:20 warning: msg2',\n        \\ ' 3 Xfile1:30 info: msg3',\n        \\ ' 4 Xfile1:40 note: msg4',\n        \\ ' 5 Xfile1:50 R: msg5'], output)\n\n  \" error type and a error number\n  set efm=%f:%l:%t:%n:%m\n  let lines =<< trim END\n    Xfile1:10:E:2:msg1\n    Xfile1:20:W:4:msg2\n    Xfile1:30:I:6:msg3\n    Xfile1:40:N:8:msg4\n    Xfile1:50:R:3:msg5\n  END\n  cexpr lines\n  let output = split(execute('clist'), \"\\n\")\n  call assert_equal([\n        \\ ' 1 Xfile1:10 error   2: msg1',\n        \\ ' 2 Xfile1:20 warning   4: msg2',\n        \\ ' 3 Xfile1:30 info   6: msg3',\n        \\ ' 4 Xfile1:40 note   8: msg4',\n        \\ ' 5 Xfile1:50 R   3: msg5'], output)\n  let &efm = save_efm\nendfunc\n\n\" Test for end_lnum ('%e') and end_col ('%k') fields in 'efm'\nfunc Test_efm_end_lnum_col()\n  let save_efm = &efm\n\n  \" single line\n  set efm=%f:%l-%e:%c-%k:%t:%m\n  cexpr [\"Xfile1:10-20:1-2:E:msg1\", \"Xfile1:20-30:2-3:W:msg2\",]\n  let output = split(execute('clist'), \"\\n\")\n  call assert_equal([\n        \\ ' 1 Xfile1:10-20 col 1-2 error: msg1',\n        \\ ' 2 Xfile1:20-30 col 2-3 warning: msg2'], output)\n\n  \" multiple lines\n  set efm=%A%n)%m,%Z%f:%l-%e:%c-%k\n  let lines =<< trim END\n    1)msg1\n    Xfile1:14-24:1-2\n    2)msg2\n    Xfile1:24-34:3-4\n  END\n  cexpr lines\n  let output = split(execute('clist'), \"\\n\")\n  call assert_equal([\n        \\ ' 1 Xfile1:14-24 col 1-2 error   1: msg1',\n        \\ ' 2 Xfile1:24-34 col 3-4 error   2: msg2'], output)\n  let &efm = save_efm\nendfunc\n\nfunc XquickfixChangedByAutocmd(cchar)\n  call s:setup_commands(a:cchar)\n  if a:cchar == 'c'\n    let ErrorNr = 'E925'\n    func! ReadFunc()\n      colder\n      cgetexpr []\n    endfunc\n  else\n    let ErrorNr = 'E926'\n    func! ReadFunc()\n      lolder\n      lgetexpr []\n    endfunc\n  endif\n\n  augroup QF_Test\n    au!\n    autocmd BufReadCmd test_changed.txt call ReadFunc()\n  augroup END\n\n  new | only\n  let words = [ \"a\", \"b\" ]\n  let qflist = []\n  for word in words\n    call add(qflist, {'filename': 'test_changed.txt'})\n    call g:Xsetlist(qflist, ' ')\n  endfor\n  call assert_fails('Xrewind', ErrorNr . ':')\n\n  augroup QF_Test\n    au!\n  augroup END\n\n  if a:cchar == 'c'\n    cexpr [\"Xtest1:1:Line\"]\n    cwindow\n    only\n    augroup QF_Test\n      au!\n      autocmd WinEnter * call setqflist([], 'f')\n    augroup END\n    call assert_fails('exe \"normal \\<CR>\"', 'E925:')\n    augroup QF_Test\n      au!\n    augroup END\n  endif\n  %bw!\nendfunc\n\nfunc Test_quickfix_was_changed_by_autocmd()\n  call XquickfixChangedByAutocmd('c')\n  call XquickfixChangedByAutocmd('l')\nendfunc\n\nfunc Test_setloclist_in_autocommand()\n  call writefile(['test1', 'test2'], 'Xfile')\n  edit Xfile\n  let s:bufnr = bufnr()\n  call setloclist(1,\n        \\ [{'bufnr' : s:bufnr, 'lnum' : 1, 'text' : 'test1'},\n        \\  {'bufnr' : s:bufnr, 'lnum' : 2, 'text' : 'test2'}])\n\n  augroup Test_LocList\n    au!\n    autocmd BufEnter * call setloclist(1,\n          \\ [{'bufnr' : s:bufnr, 'lnum' : 1, 'text' : 'test1'},\n          \\  {'bufnr' : s:bufnr, 'lnum' : 2, 'text' : 'test2'}], 'r')\n  augroup END\n\n  lopen\n  call assert_fails('exe \"normal j\\<CR>\"', 'E926:')\n\n  augroup Test_LocList\n    au!\n  augroup END\n  call delete('Xfile')\nendfunc\n\nfunc Test_caddbuffer_to_empty()\n  helpgr quickfix\n  call setqflist([], 'r')\n  cad\n  try\n    cn\n  catch\n    \" number of matches is unknown\n    call assert_true(v:exception =~ 'E553:')\n  endtry\n  quit!\nendfunc\n\nfunc Test_cgetexpr_works()\n  \" this must not crash Vim\n  cgetexpr [$x]\n  lgetexpr [$x]\nendfunc\n\n\" Tests for the setqflist() and setloclist() functions\nfunc SetXlistTests(cchar, bnum)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([{'bufnr': a:bnum, 'lnum': 1},\n\t      \\  {'bufnr': a:bnum, 'lnum': 2, 'end_lnum': 3, 'col': 4, 'end_col': 5}])\n  let l = g:Xgetlist()\n  call assert_equal(2, len(l))\n  call assert_equal(2, l[1].lnum)\n  call assert_equal(3, l[1].end_lnum)\n  call assert_equal(4, l[1].col)\n  call assert_equal(5, l[1].end_col)\n\n  Xnext\n  call g:Xsetlist([{'bufnr': a:bnum, 'lnum': 3}], 'a')\n  let l = g:Xgetlist()\n  call assert_equal(3, len(l))\n  Xnext\n  call assert_equal(3, line('.'))\n\n  \" Appending entries to the list should not change the cursor position\n  \" in the quickfix window\n  Xwindow\n  1\n  call g:Xsetlist([{'bufnr': a:bnum, 'lnum': 4},\n\t      \\  {'bufnr': a:bnum, 'lnum': 5}], 'a')\n  call assert_equal(1, line('.'))\n  close\n\n  call g:Xsetlist([{'bufnr': a:bnum, 'lnum': 3},\n\t      \\  {'bufnr': a:bnum, 'lnum': 4},\n\t      \\  {'bufnr': a:bnum, 'lnum': 5}], 'r')\n  let l = g:Xgetlist()\n  call assert_equal(3, len(l))\n  call assert_equal(5, l[2].lnum)\n\n  call g:Xsetlist([])\n  let l = g:Xgetlist()\n  call assert_equal(0, len(l))\n\n  \" Tests for setting the 'valid' flag\n  call g:Xsetlist([{'bufnr':a:bnum, 'lnum':4, 'valid':0}])\n  Xwindow\n  call assert_equal(1, winnr('$'))\n  let l = g:Xgetlist()\n  call g:Xsetlist(l)\n  call assert_equal(0, g:Xgetlist()[0].valid)\n  \" Adding a non-valid entry should not mark the list as having valid entries\n  call g:Xsetlist([{'bufnr':a:bnum, 'lnum':5, 'valid':0}], 'a')\n  Xwindow\n  call assert_equal(1, winnr('$'))\n\n  \" :cnext/:cprev should still work even with invalid entries in the list\n  let l = [{'bufnr' : a:bnum, 'lnum' : 1, 'text' : '1', 'valid' : 0},\n\t      \\ {'bufnr' : a:bnum, 'lnum' : 2, 'text' : '2', 'valid' : 0}]\n  call g:Xsetlist(l)\n  Xnext\n  call assert_equal(2, g:Xgetlist({'idx' : 0}).idx)\n  Xprev\n  call assert_equal(1, g:Xgetlist({'idx' : 0}).idx)\n  \" :cnext/:cprev should still work after appending invalid entries to an\n  \" empty list\n  call g:Xsetlist([])\n  call g:Xsetlist(l, 'a')\n  Xnext\n  call assert_equal(2, g:Xgetlist({'idx' : 0}).idx)\n  Xprev\n  call assert_equal(1, g:Xgetlist({'idx' : 0}).idx)\n\n  call g:Xsetlist([{'text':'Text1', 'valid':1}])\n  Xwindow\n  call assert_equal(2, winnr('$'))\n  Xclose\n  let save_efm = &efm\n  set efm=%m\n  Xgetexpr 'TestMessage'\n  let l = g:Xgetlist()\n  call g:Xsetlist(l)\n  call assert_equal(1, g:Xgetlist()[0].valid)\n  let &efm = save_efm\n\n  \" Error cases:\n  \" Refer to a non-existing buffer and pass a non-dictionary type\n  call assert_fails(\"call g:Xsetlist([{'bufnr':998, 'lnum':4},\" .\n\t      \\ \" {'bufnr':999, 'lnum':5}])\", 'E92:')\n  call g:Xsetlist([[1, 2,3]])\n  call assert_equal(0, len(g:Xgetlist()))\n  call assert_fails('call g:Xsetlist([], [])', 'E928:')\n  call g:Xsetlist([test_null_dict()])\n  call assert_equal([], g:Xgetlist())\nendfunc\n\nfunc Test_setqflist()\n  new Xtestfile | only\n  let bnum = bufnr('%')\n  call setline(1, range(1,5))\n\n  call SetXlistTests('c', bnum)\n  call SetXlistTests('l', bnum)\n\n  enew!\n  call delete('Xtestfile')\nendfunc\n\nfunc Xlist_empty_middle(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" create three quickfix lists\n  let @/ = 'Test_'\n  Xvimgrep // test_quickfix.vim\n  let testlen = len(g:Xgetlist())\n  call assert_true(testlen > 0)\n  Xvimgrep empty test_quickfix.vim\n  call assert_true(len(g:Xgetlist()) > 0)\n  Xvimgrep matches test_quickfix.vim\n  let matchlen = len(g:Xgetlist())\n  call assert_true(matchlen > 0)\n  Xolder\n  \" make the middle list empty\n  call g:Xsetlist([], 'r')\n  call assert_true(len(g:Xgetlist()) == 0)\n  Xolder\n  call assert_equal(testlen, len(g:Xgetlist()))\n  Xnewer\n  Xnewer\n  call assert_equal(matchlen, len(g:Xgetlist()))\nendfunc\n\nfunc Test_setqflist_empty_middle()\n  call Xlist_empty_middle('c')\n  call Xlist_empty_middle('l')\nendfunc\n\nfunc Xlist_empty_older(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" create three quickfix lists\n  Xvimgrep one test_quickfix.vim\n  let onelen = len(g:Xgetlist())\n  call assert_true(onelen > 0)\n  Xvimgrep two test_quickfix.vim\n  let twolen = len(g:Xgetlist())\n  call assert_true(twolen > 0)\n  Xvimgrep three test_quickfix.vim\n  let threelen = len(g:Xgetlist())\n  call assert_true(threelen > 0)\n  Xolder 2\n  \" make the first list empty, check the others didn't change\n  call g:Xsetlist([], 'r')\n  call assert_true(len(g:Xgetlist()) == 0)\n  Xnewer\n  call assert_equal(twolen, len(g:Xgetlist()))\n  Xnewer\n  call assert_equal(threelen, len(g:Xgetlist()))\nendfunc\n\nfunc Test_setqflist_empty_older()\n  call Xlist_empty_older('c')\n  call Xlist_empty_older('l')\nendfunc\n\nfunc XquickfixSetListWithAct(cchar)\n  call s:setup_commands(a:cchar)\n\n  let list1 = [{'filename': 'fnameA', 'text': 'A'},\n          \\    {'filename': 'fnameB', 'text': 'B'}]\n  let list2 = [{'filename': 'fnameC', 'text': 'C'},\n          \\    {'filename': 'fnameD', 'text': 'D'},\n          \\    {'filename': 'fnameE', 'text': 'E'}]\n\n  \" {action} is unspecified.  Same as specifying ' '.\n  new | only\n  silent! Xnewer 99\n  call g:Xsetlist(list1)\n  call g:Xsetlist(list2)\n  let li = g:Xgetlist()\n  call assert_equal(3, len(li))\n  call assert_equal('C', li[0]['text'])\n  call assert_equal('D', li[1]['text'])\n  call assert_equal('E', li[2]['text'])\n  silent! Xolder\n  let li = g:Xgetlist()\n  call assert_equal(2, len(li))\n  call assert_equal('A', li[0]['text'])\n  call assert_equal('B', li[1]['text'])\n\n  \" {action} is specified ' '.\n  new | only\n  silent! Xnewer 99\n  call g:Xsetlist(list1)\n  call g:Xsetlist(list2, ' ')\n  let li = g:Xgetlist()\n  call assert_equal(3, len(li))\n  call assert_equal('C', li[0]['text'])\n  call assert_equal('D', li[1]['text'])\n  call assert_equal('E', li[2]['text'])\n  silent! Xolder\n  let li = g:Xgetlist()\n  call assert_equal(2, len(li))\n  call assert_equal('A', li[0]['text'])\n  call assert_equal('B', li[1]['text'])\n\n  \" {action} is specified 'a'.\n  new | only\n  silent! Xnewer 99\n  call g:Xsetlist(list1)\n  call g:Xsetlist(list2, 'a')\n  let li = g:Xgetlist()\n  call assert_equal(5, len(li))\n  call assert_equal('A', li[0]['text'])\n  call assert_equal('B', li[1]['text'])\n  call assert_equal('C', li[2]['text'])\n  call assert_equal('D', li[3]['text'])\n  call assert_equal('E', li[4]['text'])\n\n  \" {action} is specified 'r'.\n  new | only\n  silent! Xnewer 99\n  call g:Xsetlist(list1)\n  call g:Xsetlist(list2, 'r')\n  let li = g:Xgetlist()\n  call assert_equal(3, len(li))\n  call assert_equal('C', li[0]['text'])\n  call assert_equal('D', li[1]['text'])\n  call assert_equal('E', li[2]['text'])\n\n  \" Test for wrong value.\n  new | only\n  call assert_fails(\"call g:Xsetlist(0)\", 'E714:')\n  call assert_fails(\"call g:Xsetlist(list1, '')\", 'E927:')\n  call assert_fails(\"call g:Xsetlist(list1, 'aa')\", 'E927:')\n  call assert_fails(\"call g:Xsetlist(list1, ' a')\", 'E927:')\n  call assert_fails(\"call g:Xsetlist(list1, 0)\", 'E928:')\nendfunc\n\nfunc Test_setqflist_invalid_nr()\n  \" The following command used to crash Vim\n  eval []->setqflist(' ', {'nr' : $XXX_DOES_NOT_EXIST})\nendfunc\n\nfunc Test_setqflist_user_sets_buftype()\n  call setqflist([{'text': 'foo'}, {'text': 'bar'}])\n  set buftype=quickfix\n  call setqflist([], 'a')\n  enew\nendfunc\n\nfunc Test_quickfix_set_list_with_act()\n  call XquickfixSetListWithAct('c')\n  call XquickfixSetListWithAct('l')\nendfunc\n\nfunc XLongLinesTests(cchar)\n  let l = g:Xgetlist()\n\n  call assert_equal(4, len(l))\n  call assert_equal(1, l[0].lnum)\n  call assert_equal(1, l[0].col)\n  call assert_equal(1975, len(l[0].text))\n  call assert_equal(2, l[1].lnum)\n  call assert_equal(1, l[1].col)\n  call assert_equal(4070, len(l[1].text))\n  call assert_equal(3, l[2].lnum)\n  call assert_equal(1, l[2].col)\n  call assert_equal(4070, len(l[2].text))\n  call assert_equal(4, l[3].lnum)\n  call assert_equal(1, l[3].col)\n  call assert_equal(10, len(l[3].text))\n\n  call g:Xsetlist([], 'r')\nendfunc\n\nfunc s:long_lines_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  let testfile = 'samples/quickfix.txt'\n\n  \" file\n  exe 'Xgetfile' testfile\n  call XLongLinesTests(a:cchar)\n\n  \" list\n  Xexpr readfile(testfile)\n  call XLongLinesTests(a:cchar)\n\n  \" string\n  Xexpr join(readfile(testfile), \"\\n\")\n  call XLongLinesTests(a:cchar)\n\n  \" buffer\n  exe 'edit' testfile\n  exe 'Xbuffer' bufnr('%')\n  call XLongLinesTests(a:cchar)\nendfunc\n\nfunc Test_long_lines()\n  call s:long_lines_tests('c')\n  call s:long_lines_tests('l')\nendfunc\n\nfunc Test_cgetfile_on_long_lines()\n  \" Problematic values if the line is longer than 4096 bytes.  Then 1024 bytes\n  \" are read at a time.\n  for len in [4078, 4079, 4080, 5102, 5103, 5104, 6126, 6127, 6128, 7150, 7151, 7152]\n    let lines =<< trim END\n      /tmp/file1:1:1:aaa\n      /tmp/file2:1:1:%s\n      /tmp/file3:1:1:bbb\n      /tmp/file4:1:1:ccc\n    END\n    let lines[1] = substitute(lines[1], '%s', repeat('x', len), '')\n    call writefile(lines, 'Xcqetfile.txt')\n    cgetfile Xcqetfile.txt\n    call assert_equal(4, getqflist(#{size: v:true}).size, 'with length ' .. len)\n  endfor\n  call delete('Xcqetfile.txt')\nendfunc\n\nfunc s:create_test_file(filename)\n  let l = []\n  for i in range(1, 20)\n      call add(l, 'Line' . i)\n  endfor\n  call writefile(l, a:filename)\nendfunc\n\nfunc Test_switchbuf()\n  call s:create_test_file('Xqftestfile1')\n  call s:create_test_file('Xqftestfile2')\n  call s:create_test_file('Xqftestfile3')\n\n  new | only\n  edit Xqftestfile1\n  let file1_winid = win_getid()\n  new Xqftestfile2\n  let file2_winid = win_getid()\n  let lines =<< trim END\n    Xqftestfile1:5:Line5\n    Xqftestfile1:6:Line6\n    Xqftestfile2:10:Line10\n    Xqftestfile2:11:Line11\n    Xqftestfile3:15:Line15\n    Xqftestfile3:16:Line16\n  END\n  cgetexpr lines\n\n  new\n  let winid = win_getid()\n  cfirst | cnext\n  call assert_equal(winid, win_getid())\n  2cnext\n  call assert_equal(winid, win_getid())\n  2cnext\n  call assert_equal(winid, win_getid())\n\n  \" Test for 'switchbuf' set to search for files in windows in the current\n  \" tabpage and jump to an existing window (if present)\n  set switchbuf=useopen\n  enew\n  cfirst | cnext\n  call assert_equal(file1_winid, win_getid())\n  2cnext\n  call assert_equal(file2_winid, win_getid())\n  2cnext\n  call assert_equal(file2_winid, win_getid())\n\n  \" Test for 'switchbuf' set to search for files in tabpages and jump to an\n  \" existing tabpage (if present)\n  enew | only\n  set switchbuf=usetab\n  tabedit Xqftestfile1\n  tabedit Xqftestfile2\n  tabedit Xqftestfile3\n  tabfirst\n  cfirst | cnext\n  call assert_equal(2, tabpagenr())\n  2cnext\n  call assert_equal(3, tabpagenr())\n  6cnext\n  call assert_equal(4, tabpagenr())\n  2cpfile\n  call assert_equal(2, tabpagenr())\n  2cnfile\n  call assert_equal(4, tabpagenr())\n  tabfirst | tabonly | enew\n\n  \" Test for 'switchbuf' set to open a new window for every file\n  set switchbuf=split\n  cfirst | cnext\n  call assert_equal(1, winnr('$'))\n  cnext | cnext\n  call assert_equal(2, winnr('$'))\n  cnext | cnext\n  call assert_equal(3, winnr('$'))\n\n  \" Test for 'switchbuf' set to open a new tabpage for every file\n  set switchbuf=newtab\n  enew | only\n  cfirst | cnext\n  call assert_equal(1, tabpagenr('$'))\n  cnext | cnext\n  call assert_equal(2, tabpagenr('$'))\n  cnext | cnext\n  call assert_equal(3, tabpagenr('$'))\n  tabfirst | enew | tabonly | only\n\n  set switchbuf=uselast\n  split\n  let last_winid = win_getid()\n  copen\n  exe \"normal 1G\\<CR>\"\n  call assert_equal(last_winid, win_getid())\n  enew | only\n\n  \" With an empty 'switchbuf', jumping to a quickfix entry should open the\n  \" file in an existing window (if present)\n  set switchbuf=\n  edit Xqftestfile1\n  let file1_winid = win_getid()\n  new Xqftestfile2\n  let file2_winid = win_getid()\n  copen\n  exe \"normal 1G\\<CR>\"\n  call assert_equal(file1_winid, win_getid())\n  copen\n  exe \"normal 3G\\<CR>\"\n  call assert_equal(file2_winid, win_getid())\n  copen | only\n  exe \"normal 5G\\<CR>\"\n  call assert_equal(2, winnr('$'))\n  call assert_equal(1, bufwinnr('Xqftestfile3'))\n\n  \" If only quickfix window is open in the current tabpage, jumping to an\n  \" entry with 'switchbuf' set to 'usetab' should search in other tabpages.\n  enew | only\n  set switchbuf=usetab\n  tabedit Xqftestfile1\n  tabedit Xqftestfile2\n  tabedit Xqftestfile3\n  tabfirst\n  copen | only\n  clast\n  call assert_equal(4, tabpagenr())\n  tabfirst | tabonly | enew | only\n\n  \" Jumping to a file that is not present in any of the tabpages and the\n  \" current tabpage doesn't have any usable windows, should open it in a new\n  \" window in the current tabpage.\n  copen | only\n  cfirst\n  call assert_equal(1, tabpagenr())\n  call assert_equal('Xqftestfile1', @%)\n\n  \" If opening a file changes 'switchbuf', then the new value should be\n  \" retained.\n  set modeline&vim\n  call writefile([\"vim: switchbuf=split\"], 'Xqftestfile1')\n  enew | only\n  set switchbuf&vim\n  cexpr \"Xqftestfile1:1:10\"\n  call assert_equal('split', &switchbuf)\n  call writefile([\"vim: switchbuf=usetab\"], 'Xqftestfile1')\n  enew | only\n  set switchbuf=useopen\n  cexpr \"Xqftestfile1:1:10\"\n  call assert_equal('usetab', &switchbuf)\n  call writefile([\"vim: switchbuf&vim\"], 'Xqftestfile1')\n  enew | only\n  set switchbuf=useopen\n  cexpr \"Xqftestfile1:1:10\"\n  call assert_equal('', &switchbuf)\n\n  call delete('Xqftestfile1')\n  call delete('Xqftestfile2')\n  call delete('Xqftestfile3')\n  set switchbuf&vim\n\n  enew | only\nendfunc\n\nfunc Xadjust_qflnum(cchar)\n  call s:setup_commands(a:cchar)\n\n  enew | only\n\n  let fname = 'Xqftestfile' . a:cchar\n  call s:create_test_file(fname)\n  exe 'edit ' . fname\n\n  Xgetexpr [fname . ':5:Line5',\n\t      \\ fname . ':10:Line10',\n\t      \\ fname . ':15:Line15',\n\t      \\ fname . ':20:Line20']\n\n  6,14delete\n  call append(6, ['Buffer', 'Window'])\n\n  let l = g:Xgetlist()\n  call assert_equal(5, l[0].lnum)\n  call assert_equal(6, l[2].lnum)\n  call assert_equal(13, l[3].lnum)\n\n  \" If a file doesn't have any quickfix entries, then deleting lines in the\n  \" file should not update the quickfix list\n  call g:Xsetlist([], 'f')\n  1,2delete\n  call assert_equal([], g:Xgetlist())\n\n  enew!\n  call delete(fname)\nendfunc\n\nfunc Test_adjust_lnum()\n  call setloclist(0, [])\n  call Xadjust_qflnum('c')\n  call setqflist([])\n  call Xadjust_qflnum('l')\nendfunc\n\n\" Tests for the :grep/:lgrep and :grepadd/:lgrepadd commands\nfunc s:test_xgrep(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" The following lines are used for the grep test. Don't remove.\n  \" Grep_Test_Text: Match 1\n  \" Grep_Test_Text: Match 2\n  \" GrepAdd_Test_Text: Match 1\n  \" GrepAdd_Test_Text: Match 2\n  enew! | only\n  set makeef&vim\n  silent Xgrep Grep_Test_Text: test_quickfix.vim\n  call assert_true(len(g:Xgetlist()) == 5)\n  Xopen\n  call assert_true(w:quickfix_title =~ '^:grep')\n  Xclose\n  enew\n  set makeef=Temp_File_##\n  silent Xgrepadd GrepAdd_Test_Text: test_quickfix.vim\n  call assert_true(len(g:Xgetlist()) == 9)\n\n  \" Try with 'grepprg' set to 'internal'\n  set grepprg=internal\n  silent Xgrep Grep_Test_Text: test_quickfix.vim\n  silent Xgrepadd GrepAdd_Test_Text: test_quickfix.vim\n  call assert_true(len(g:Xgetlist()) == 9)\n  set grepprg&vim\n\n  call writefile(['Vim'], 'XtestTempFile')\n  set makeef=XtestTempFile\n  silent Xgrep Grep_Test_Text: test_quickfix.vim\n  call assert_equal(5, len(g:Xgetlist()))\n  call assert_false(filereadable('XtestTempFile'))\n  set makeef&vim\nendfunc\n\nfunc Test_grep()\n  \" The grepprg may not be set on non-Unix systems\n  CheckUnix\n\n  call s:test_xgrep('c')\n  call s:test_xgrep('l')\nendfunc\n\nfunc Test_two_windows()\n  \" Use one 'errorformat' for two windows.  Add an expression to each of them,\n  \" make sure they each keep their own state.\n  set efm=%DEntering\\ dir\\ '%f',%f:%l:%m,%XLeaving\\ dir\\ '%f'\n  call mkdir('Xone/a', 'p')\n  call mkdir('Xtwo/a', 'p')\n  let lines = ['1', '2', 'one one one', '4', 'two two two', '6', '7']\n  call writefile(lines, 'Xone/a/one.txt')\n  call writefile(lines, 'Xtwo/a/two.txt')\n\n  new one\n  let one_id = win_getid()\n  lexpr \"\"\n  new two\n  let two_id = win_getid()\n  lexpr \"\"\n\n  laddexpr \"Entering dir 'Xtwo/a'\"\n  call win_gotoid(one_id)\n  laddexpr \"Entering dir 'Xone/a'\"\n  call win_gotoid(two_id)\n  laddexpr 'two.txt:5:two two two'\n  call win_gotoid(one_id)\n  laddexpr 'one.txt:3:one one one'\n\n  let loc_one = getloclist(one_id)\n  call assert_equal('Xone/a/one.txt', bufname(loc_one[1].bufnr))\n  call assert_equal(3, loc_one[1].lnum)\n\n  let loc_two = getloclist(two_id)\n  call assert_equal('Xtwo/a/two.txt', bufname(loc_two[1].bufnr))\n  call assert_equal(5, loc_two[1].lnum)\n\n  call win_gotoid(one_id)\n  bwipe!\n  call win_gotoid(two_id)\n  bwipe!\n  call delete('Xone', 'rf')\n  call delete('Xtwo', 'rf')\nendfunc\n\nfunc XbottomTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Calling lbottom without any errors should fail\n  if a:cchar == 'l'\n      call assert_fails('lbottom', 'E776:')\n  endif\n\n  call g:Xsetlist([{'filename': 'foo', 'lnum': 42}])\n  Xopen\n  let wid = win_getid()\n  call assert_equal(1, line('.'))\n  wincmd w\n  call g:Xsetlist([{'filename': 'var', 'lnum': 24}], 'a')\n  Xbottom\n  call win_gotoid(wid)\n  call assert_equal(2, line('.'))\n  Xclose\nendfunc\n\n\" Tests for the :cbottom and :lbottom commands\nfunc Test_cbottom()\n  call XbottomTests('c')\n  call XbottomTests('l')\nendfunc\n\nfunc HistoryTest(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" clear all lists after the first one, then replace the first one.\n  call g:Xsetlist([])\n  call assert_fails('Xolder 99', 'E380:')\n  let entry = {'filename': 'foo', 'lnum': 42}\n  call g:Xsetlist([entry], 'r')\n  call g:Xsetlist([entry, entry])\n  call g:Xsetlist([entry, entry, entry])\n  let res = split(execute(a:cchar . 'hist'), \"\\n\")\n  call assert_equal(3, len(res))\n  let common = 'errors     :set' . (a:cchar == 'c' ? 'qf' : 'loc') . 'list()'\n  call assert_equal('  error list 1 of 3; 1 ' . common, res[0])\n  call assert_equal('  error list 2 of 3; 2 ' . common, res[1])\n  call assert_equal('> error list 3 of 3; 3 ' . common, res[2])\n\n  \" Test for changing the quickfix lists\n  call assert_equal(3, g:Xgetlist({'nr' : 0}).nr)\n  exe '1' . a:cchar . 'hist'\n  call assert_equal(1, g:Xgetlist({'nr' : 0}).nr)\n  exe '3' . a:cchar . 'hist'\n  call assert_equal(3, g:Xgetlist({'nr' : 0}).nr)\n  call assert_fails('-2' . a:cchar . 'hist', 'E16:')\n  call assert_fails('4' . a:cchar . 'hist', 'E16:')\n\n  call g:Xsetlist([], 'f')\n  let l = split(execute(a:cchar . 'hist'), \"\\n\")\n  call assert_equal('No entries', l[0])\n  if a:cchar == 'c'\n    call assert_fails('4chist', 'E16:')\n  else\n    call assert_fails('4lhist', 'E776:')\n  endif\n\n  \" An empty list should still show the stack history\n  call g:Xsetlist([])\n  let res = split(execute(a:cchar . 'hist'), \"\\n\")\n  call assert_equal('> error list 1 of 1; 0 ' . common, res[0])\n\n  call g:Xsetlist([], 'f')\nendfunc\n\nfunc Test_history()\n  call HistoryTest('c')\n  call HistoryTest('l')\nendfunc\n\nfunc Test_duplicate_buf()\n  \" make sure we can get the highest buffer number\n  edit DoesNotExist\n  edit DoesNotExist2\n  let last_buffer = bufnr(\"$\")\n\n  \" make sure only one buffer is created\n  call writefile(['this one', 'that one'], 'Xgrepthis')\n  vimgrep one Xgrepthis\n  vimgrep one Xgrepthis\n  call assert_equal(last_buffer + 1, bufnr(\"$\"))\n\n  call delete('Xgrepthis')\nendfunc\n\n\" Quickfix/Location list set/get properties tests\nfunc Xproperty_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Error cases\n  call assert_fails('call g:Xgetlist(99)', 'E715:')\n  call assert_fails('call g:Xsetlist(99)', 'E714:')\n  call assert_fails('call g:Xsetlist([], \"a\", [])', 'E715:')\n\n  \" Set and get the title\n  call g:Xsetlist([])\n  Xopen\n  wincmd p\n  call g:Xsetlist([{'filename':'foo', 'lnum':27}])\n  let s = g:Xsetlist([], 'a', {'title' : 'Sample'})\n  call assert_equal(0, s)\n  let d = g:Xgetlist({\"title\":1})\n  call assert_equal('Sample', d.title)\n  \" Try setting title to a non-string value\n  call assert_equal(-1, g:Xsetlist([], 'a', {'title' : ['Test']}))\n  call assert_equal('Sample', g:Xgetlist({\"title\":1}).title)\n\n  Xopen\n  call assert_equal('Sample', w:quickfix_title)\n  Xclose\n\n  \" Tests for action argument\n  silent! Xolder 999\n  let qfnr = g:Xgetlist({'all':1}).nr\n  call g:Xsetlist([], 'r', {'title' : 'N1'})\n  call assert_equal('N1', g:Xgetlist({'all':1}).title)\n  call g:Xsetlist([], ' ', {'title' : 'N2'})\n  call assert_equal(qfnr + 1, g:Xgetlist({'all':1}).nr)\n\n  let res = g:Xgetlist({'nr': 0})\n  call assert_equal(qfnr + 1, res.nr)\n  call assert_equal(['nr'], keys(res))\n\n  call g:Xsetlist([], ' ', {'title' : 'N3'})\n  call assert_equal('N2', g:Xgetlist({'nr':2, 'title':1}).title)\n\n  \" Changing the title of an earlier quickfix list\n  call g:Xsetlist([], 'r', {'title' : 'NewTitle', 'nr' : 2})\n  call assert_equal('NewTitle', g:Xgetlist({'nr':2, 'title':1}).title)\n\n  \" Changing the title of an invalid quickfix list\n  call assert_equal(-1, g:Xsetlist([], ' ',\n        \\ {'title' : 'SomeTitle', 'nr' : 99}))\n  call assert_equal(-1, g:Xsetlist([], ' ',\n        \\ {'title' : 'SomeTitle', 'nr' : 'abc'}))\n\n  if a:cchar == 'c'\n    copen\n    call assert_equal({'winid':win_getid()}, getqflist({'winid':1}))\n    cclose\n  endif\n\n  \" Invalid arguments\n  call assert_fails('call g:Xgetlist([])', 'E715:')\n  call assert_fails('call g:Xsetlist([], \"a\", [])', 'E715:')\n  let s = g:Xsetlist([], 'a', {'abc':1})\n  call assert_equal(-1, s)\n\n  call assert_equal({}, g:Xgetlist({'abc':1}))\n  call assert_equal('', g:Xgetlist({'nr':99, 'title':1}).title)\n  call assert_equal('', g:Xgetlist({'nr':[], 'title':1}).title)\n\n  if a:cchar == 'l'\n    call assert_equal({}, getloclist(99, {'title': 1}))\n  endif\n\n  \" Context related tests\n  let s = g:Xsetlist([], 'a', {'context':[1,2,3]})\n  call assert_equal(0, s)\n  call test_garbagecollect_now()\n  let d = g:Xgetlist({'context':1})\n  call assert_equal([1,2,3], d.context)\n  call g:Xsetlist([], 'a', {'context':{'color':'green'}})\n  let d = g:Xgetlist({'context':1})\n  call assert_equal({'color':'green'}, d.context)\n  call g:Xsetlist([], 'a', {'context':\"Context info\"})\n  let d = g:Xgetlist({'context':1})\n  call assert_equal(\"Context info\", d.context)\n  call g:Xsetlist([], 'a', {'context':246})\n  let d = g:Xgetlist({'context':1})\n  call assert_equal(246, d.context)\n  \" set other Vim data types as context\n  call g:Xsetlist([], 'a', {'context' : test_null_blob()})\n  if has('channel')\n    call g:Xsetlist([], 'a', {'context' : test_null_channel()})\n  endif\n  if has('job')\n    call g:Xsetlist([], 'a', {'context' : test_null_job()})\n  endif\n  call g:Xsetlist([], 'a', {'context' : test_null_function()})\n  call g:Xsetlist([], 'a', {'context' : test_null_partial()})\n  call g:Xsetlist([], 'a', {'context' : ''})\n  call test_garbagecollect_now()\n  if a:cchar == 'l'\n    \" Test for copying context across two different location lists\n    new | only\n    let w1_id = win_getid()\n    let l = [1]\n    call setloclist(0, [], 'a', {'context':l})\n    new\n    let w2_id = win_getid()\n    call add(l, 2)\n    call assert_equal([1, 2], getloclist(w1_id, {'context':1}).context)\n    call assert_equal([1, 2], getloclist(w2_id, {'context':1}).context)\n    unlet! l\n    call assert_equal([1, 2], getloclist(w2_id, {'context':1}).context)\n    only\n    call setloclist(0, [], 'f')\n    call assert_equal('', getloclist(0, {'context':1}).context)\n  endif\n\n  \" Test for changing the context of previous quickfix lists\n  call g:Xsetlist([], 'f')\n  Xexpr \"One\"\n  Xexpr \"Two\"\n  Xexpr \"Three\"\n  call g:Xsetlist([], 'r', {'context' : [1], 'nr' : 1})\n  call g:Xsetlist([], 'a', {'context' : [2], 'nr' : 2})\n  \" Also, check for setting the context using quickfix list number zero.\n  call g:Xsetlist([], 'r', {'context' : [3], 'nr' : 0})\n  call test_garbagecollect_now()\n  let l = g:Xgetlist({'nr' : 1, 'context' : 1})\n  call assert_equal([1], l.context)\n  let l = g:Xgetlist({'nr' : 2, 'context' : 1})\n  call assert_equal([2], l.context)\n  let l = g:Xgetlist({'nr' : 3, 'context' : 1})\n  call assert_equal([3], l.context)\n\n  \" Test for changing the context through reference and for garbage\n  \" collection of quickfix context\n  let l = [\"red\"]\n  call g:Xsetlist([], ' ', {'context' : l})\n  call add(l, \"blue\")\n  let x = g:Xgetlist({'context' : 1})\n  call add(x.context, \"green\")\n  call assert_equal([\"red\", \"blue\", \"green\"], l)\n  call assert_equal([\"red\", \"blue\", \"green\"], x.context)\n  unlet l\n  call test_garbagecollect_now()\n  let m = g:Xgetlist({'context' : 1})\n  call assert_equal([\"red\", \"blue\", \"green\"], m.context)\n\n  \" Test for setting/getting items\n  Xexpr \"\"\n  let qfprev = g:Xgetlist({'nr':0})\n  let s = g:Xsetlist([], ' ', {'title':'Green',\n        \\ 'items' : [{'filename':'F1', 'lnum':10}]})\n  call assert_equal(0, s)\n  let qfcur = g:Xgetlist({'nr':0})\n  call assert_true(qfcur.nr == qfprev.nr + 1)\n  let l = g:Xgetlist({'items':1})\n  call assert_equal('F1', bufname(l.items[0].bufnr))\n  call assert_equal(10, l.items[0].lnum)\n  call g:Xsetlist([], 'a', {'items' : [{'filename':'F2', 'lnum':20},\n        \\  {'filename':'F2', 'lnum':30}]})\n  let l = g:Xgetlist({'items':1})\n  call assert_equal('F2', bufname(l.items[2].bufnr))\n  call assert_equal(30, l.items[2].lnum)\n  call g:Xsetlist([], 'r', {'items' : [{'filename':'F3', 'lnum':40}]})\n  let l = g:Xgetlist({'items':1})\n  call assert_equal('F3', bufname(l.items[0].bufnr))\n  call assert_equal(40, l.items[0].lnum)\n  call g:Xsetlist([], 'r', {'items' : []})\n  let l = g:Xgetlist({'items':1})\n  call assert_equal(0, len(l.items))\n\n  call g:Xsetlist([], 'r', {'title' : 'TestTitle'})\n  call g:Xsetlist([], 'r', {'items' : [{'filename' : 'F1', 'lnum' : 10, 'text' : 'L10'}]})\n  call g:Xsetlist([], 'r', {'items' : [{'filename' : 'F1', 'lnum' : 10, 'text' : 'L10'}]})\n  call assert_equal('TestTitle', g:Xgetlist({'title' : 1}).title)\n\n  \" Test for getting id of window associated with a location list window\n  if a:cchar == 'l'\n    only\n    call assert_equal(0, g:Xgetlist({'all' : 1}).filewinid)\n    let wid = win_getid()\n    Xopen\n    call assert_equal(wid, g:Xgetlist({'filewinid' : 1}).filewinid)\n    wincmd w\n    call assert_equal(0, g:Xgetlist({'filewinid' : 1}).filewinid)\n    only\n  endif\n\n  \" The following used to crash Vim with address sanitizer\n  call g:Xsetlist([], 'f')\n  call g:Xsetlist([], 'a', {'items' : [{'filename':'F1', 'lnum':10}]})\n  call assert_equal(10, g:Xgetlist({'items':1}).items[0].lnum)\n\n  \" Try setting the items using a string\n  call assert_equal(-1, g:Xsetlist([], ' ', {'items' : 'Test'}))\n\n  \" Save and restore the quickfix stack\n  call g:Xsetlist([], 'f')\n  call assert_equal(0, g:Xgetlist({'nr':'$'}).nr)\n  Xexpr \"File1:10:Line1\"\n  Xexpr \"File2:20:Line2\"\n  Xexpr \"File3:30:Line3\"\n  let last_qf = g:Xgetlist({'nr':'$'}).nr\n  call assert_equal(3, last_qf)\n  let qstack = []\n  for i in range(1, last_qf)\n    let qstack = add(qstack, g:Xgetlist({'nr':i, 'all':1}))\n  endfor\n  call g:Xsetlist([], 'f')\n  for i in range(len(qstack))\n    call g:Xsetlist([], ' ', qstack[i])\n  endfor\n  call assert_equal(3, g:Xgetlist({'nr':'$'}).nr)\n  call assert_equal(10, g:Xgetlist({'nr':1, 'items':1}).items[0].lnum)\n  call assert_equal(20, g:Xgetlist({'nr':2, 'items':1}).items[0].lnum)\n  call assert_equal(30, g:Xgetlist({'nr':3, 'items':1}).items[0].lnum)\n  call g:Xsetlist([], 'f')\n\n  \" Swap two quickfix lists\n  Xexpr \"File1:10:Line10\"\n  Xexpr \"File2:20:Line20\"\n  Xexpr \"File3:30:Line30\"\n  call g:Xsetlist([], 'r', {'nr':1,'title':'Colors','context':['Colors']})\n  call g:Xsetlist([], 'r', {'nr':2,'title':'Fruits','context':['Fruits']})\n  let l1=g:Xgetlist({'nr':1,'all':1})\n  let l2=g:Xgetlist({'nr':2,'all':1})\n  let save_id = l1.id\n  let l1.id=l2.id\n  let l2.id=save_id\n  call g:Xsetlist([], 'r', l1)\n  call g:Xsetlist([], 'r', l2)\n  let newl1=g:Xgetlist({'nr':1,'all':1})\n  let newl2=g:Xgetlist({'nr':2,'all':1})\n  call assert_equal('Fruits', newl1.title)\n  call assert_equal(['Fruits'], newl1.context)\n  call assert_equal('Line20', newl1.items[0].text)\n  call assert_equal('Colors', newl2.title)\n  call assert_equal(['Colors'], newl2.context)\n  call assert_equal('Line10', newl2.items[0].text)\n  call g:Xsetlist([], 'f')\n\n  \" Cannot specify both a non-empty list argument and a dict argument\n  call assert_fails(\"call g:Xsetlist([{}], ' ', {})\", 'E475:')\nendfunc\n\nfunc Test_qf_property()\n  call Xproperty_tests('c')\n  call Xproperty_tests('l')\nendfunc\n\n\" Test for setting the current index in the location/quickfix list\nfunc Xtest_setqfidx(cchar)\n  call s:setup_commands(a:cchar)\n\n  Xgetexpr \"F1:10:1:Line1\\nF2:20:2:Line2\\nF3:30:3:Line3\"\n  Xgetexpr \"F4:10:1:Line1\\nF5:20:2:Line2\\nF6:30:3:Line3\"\n  Xgetexpr \"F7:10:1:Line1\\nF8:20:2:Line2\\nF9:30:3:Line3\"\n\n  call g:Xsetlist([], 'a', {'nr' : 3, 'idx' : 2})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'idx' : 2})\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : 3})\n  Xolder 2\n  Xopen\n  call assert_equal(3, line('.'))\n  Xnewer\n  call assert_equal(2, line('.'))\n  Xnewer\n  call assert_equal(2, line('.'))\n  \" Update the current index with the quickfix window open\n  wincmd w\n  call g:Xsetlist([], 'a', {'nr' : 3, 'idx' : 3})\n  Xopen\n  call assert_equal(3, line('.'))\n  Xclose\n\n  \" Set the current index to the last entry\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : '$'})\n  call assert_equal(3, g:Xgetlist({'nr' : 1, 'idx' : 0}).idx)\n  \" A large value should set the index to the last index\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : 1})\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : 999})\n  call assert_equal(3, g:Xgetlist({'nr' : 1, 'idx' : 0}).idx)\n  \" Invalid index values\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : -1})\n  call assert_equal(3, g:Xgetlist({'nr' : 1, 'idx' : 0}).idx)\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : 0})\n  call assert_equal(3, g:Xgetlist({'nr' : 1, 'idx' : 0}).idx)\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : 'xx'})\n  call assert_equal(3, g:Xgetlist({'nr' : 1, 'idx' : 0}).idx)\n  call assert_fails(\"call g:Xsetlist([], 'a', {'nr':1, 'idx':[]})\", 'E745:')\n\n  call g:Xsetlist([], 'f')\n  new | only\nendfunc\n\nfunc Test_setqfidx()\n  call Xtest_setqfidx('c')\n  call Xtest_setqfidx('l')\nendfunc\n\n\" Tests for the QuickFixCmdPre/QuickFixCmdPost autocommands\nfunc QfAutoCmdHandler(loc, cmd)\n  call add(g:acmds, a:loc . a:cmd)\nendfunc\n\nfunc Test_Autocmd()\n  autocmd QuickFixCmdPre * call QfAutoCmdHandler('pre', expand('<amatch>'))\n  autocmd QuickFixCmdPost * call QfAutoCmdHandler('post', expand('<amatch>'))\n\n  let g:acmds = []\n  cexpr \"F1:10:Line 10\"\n  caddexpr \"F1:20:Line 20\"\n  cgetexpr \"F1:30:Line 30\"\n  cexpr \"\"\n  caddexpr \"\"\n  cgetexpr \"\"\n  silent! cexpr non_existing_func()\n  silent! caddexpr non_existing_func()\n  silent! cgetexpr non_existing_func()\n  let l =<< trim END\n    precexpr\n    postcexpr\n    precaddexpr\n    postcaddexpr\n    precgetexpr\n    postcgetexpr\n    precexpr\n    postcexpr\n    precaddexpr\n    postcaddexpr\n    precgetexpr\n    postcgetexpr\n    precexpr\n    precaddexpr\n    precgetexpr\n  END\n  call assert_equal(l, g:acmds)\n\n  let g:acmds = []\n  enew! | call append(0, \"F2:10:Line 10\")\n  cbuffer!\n  enew! | call append(0, \"F2:20:Line 20\")\n  cgetbuffer\n  enew! | call append(0, \"F2:30:Line 30\")\n  caddbuffer\n  new\n  let bnum = bufnr('%')\n  bunload\n  exe 'silent! cbuffer! ' . bnum\n  exe 'silent! cgetbuffer ' . bnum\n  exe 'silent! caddbuffer ' . bnum\n  enew!\n  let l =<< trim END\n    precbuffer\n    postcbuffer\n    precgetbuffer\n    postcgetbuffer\n    precaddbuffer\n    postcaddbuffer\n    precbuffer\n    precgetbuffer\n    precaddbuffer\n  END\n  call assert_equal(l, g:acmds)\n\n  call writefile(['Xtest:1:Line1'], 'Xtest')\n  call writefile([], 'Xempty')\n  let g:acmds = []\n  cfile Xtest\n  caddfile Xtest\n  cgetfile Xtest\n  cfile Xempty\n  caddfile Xempty\n  cgetfile Xempty\n  silent! cfile do_not_exist\n  silent! caddfile do_not_exist\n  silent! cgetfile do_not_exist\n  let l =<< trim END\n    precfile\n    postcfile\n    precaddfile\n    postcaddfile\n    precgetfile\n    postcgetfile\n    precfile\n    postcfile\n    precaddfile\n    postcaddfile\n    precgetfile\n    postcgetfile\n    precfile\n    postcfile\n    precaddfile\n    postcaddfile\n    precgetfile\n    postcgetfile\n  END\n  call assert_equal(l, g:acmds)\n\n  let g:acmds = []\n  helpgrep quickfix\n  silent! helpgrep non_existing_help_topic\n  vimgrep test Xtest\n  vimgrepadd test Xtest\n  silent! vimgrep non_existing_test Xtest\n  silent! vimgrepadd non_existing_test Xtest\n  set makeprg=\n  silent! make\n  set makeprg&\n  let l =<< trim END\n    prehelpgrep\n    posthelpgrep\n    prehelpgrep\n    posthelpgrep\n    previmgrep\n    postvimgrep\n    previmgrepadd\n    postvimgrepadd\n    previmgrep\n    postvimgrep\n    previmgrepadd\n    postvimgrepadd\n    premake\n    postmake\n  END\n  call assert_equal(l, g:acmds)\n\n  if has('unix')\n    \" Run this test only on Unix-like systems. The grepprg may not be set on\n    \" non-Unix systems.\n    \" The following lines are used for the grep test. Don't remove.\n    \" Grep_Autocmd_Text: Match 1\n    \" GrepAdd_Autocmd_Text: Match 2\n    let g:acmds = []\n    silent grep Grep_Autocmd_Text test_quickfix.vim\n    silent grepadd GrepAdd_Autocmd_Text test_quickfix.vim\n    silent grep abc123def Xtest\n    silent grepadd abc123def Xtest\n    set grepprg=internal\n    silent grep Grep_Autocmd_Text test_quickfix.vim\n    silent grepadd GrepAdd_Autocmd_Text test_quickfix.vim\n    silent lgrep Grep_Autocmd_Text test_quickfix.vim\n    silent lgrepadd GrepAdd_Autocmd_Text test_quickfix.vim\n    set grepprg&vim\n    let l =<< trim END\n      pregrep\n      postgrep\n      pregrepadd\n      postgrepadd\n      pregrep\n      postgrep\n      pregrepadd\n      postgrepadd\n      pregrep\n      postgrep\n      pregrepadd\n      postgrepadd\n      prelgrep\n      postlgrep\n      prelgrepadd\n      postlgrepadd\n    END\n    call assert_equal(l, g:acmds)\n  endif\n\n  call delete('Xtest')\n  call delete('Xempty')\n  au! QuickFixCmdPre\n  au! QuickFixCmdPost\nendfunc\n\nfunc Test_Autocmd_Exception()\n  set efm=%m\n  lgetexpr '?'\n\n  try\n    call DoesNotExit()\n  catch\n    lgetexpr '1'\n  finally\n    lgetexpr '1'\n  endtry\n\n  call assert_equal('1', getloclist(0)[0].text)\n\n  set efm&vim\nendfunc\n\nfunc Test_caddbuffer_wrong()\n  \" This used to cause a memory access in freed memory.\n  let save_efm = &efm\n  set efm=%EEEE%m,%WWWW,%+CCCC%>%#,%GGGG%.#\n  cgetexpr ['WWWW', 'EEEE', 'CCCC']\n  let &efm = save_efm\n  caddbuffer\n  bwipe!\nendfunc\n\nfunc Test_caddexpr_wrong()\n  \" This used to cause a memory access in freed memory.\n  cbuffer\n  cbuffer\n  copen\n  let save_efm = &efm\n  set efm=%\n  call assert_fails('caddexpr \"\"', 'E376:')\n  let &efm = save_efm\nendfunc\n\nfunc Test_dirstack_cleanup()\n  \" This used to cause a memory access in freed memory.\n  let save_efm = &efm\n  lexpr '0'\n  lopen\n  fun X(c)\n    let save_efm=&efm\n    set efm=%D%f\n    if a:c == 'c'\n      caddexpr '::'\n    else\n      laddexpr ':0:0'\n    endif\n    let &efm=save_efm\n  endfun\n  call X('c')\n  call X('l')\n  call setqflist([], 'r')\n  caddbuffer\n  let &efm = save_efm\nendfunc\n\n\" Tests for jumping to entries from the location list window and quickfix\n\" window\nfunc Test_cwindow_jump()\n  set efm=%f%%%l%%%m\n  lgetexpr [\"F1%10%Line 10\", \"F2%20%Line 20\", \"F3%30%Line 30\"]\n  lopen | only\n  lfirst\n  call assert_true(winnr('$') == 2)\n  call assert_true(winnr() == 1)\n  \" Location list for the new window should be set\n  call assert_true(getloclist(0)[2].text == 'Line 30')\n\n  \" Open a scratch buffer\n  \" Open a new window and create a location list\n  \" Open the location list window and close the other window\n  \" Jump to an entry.\n  \" Should create a new window and jump to the entry. The scratch buffer\n  \" should not be used.\n  enew | only\n  set buftype=nofile\n  below new\n  lgetexpr [\"F1%10%Line 10\", \"F2%20%Line 20\", \"F3%30%Line 30\"]\n  lopen\n  2wincmd c\n  lnext\n  call assert_true(winnr('$') == 3)\n  call assert_true(winnr() == 2)\n\n  \" Open two windows with two different location lists\n  \" Open the location list window and close the previous window\n  \" Jump to an entry in the location list window\n  \" Should open the file in the first window and not set the location list.\n  enew | only\n  lgetexpr [\"F1%5%Line 5\"]\n  below new\n  lgetexpr [\"F1%10%Line 10\", \"F2%20%Line 20\", \"F3%30%Line 30\"]\n  lopen\n  2wincmd c\n  lnext\n  call assert_true(winnr() == 1)\n  call assert_true(getloclist(0)[0].text == 'Line 5')\n\n  enew | only\n  cgetexpr [\"F1%10%Line 10\", \"F2%20%Line 20\", \"F3%30%Line 30\"]\n  copen\n  cnext\n  call assert_true(winnr('$') == 2)\n  call assert_true(winnr() == 1)\n\n  \" open the quickfix buffer in two windows and jump to an entry. Should open\n  \" the file in the first quickfix window.\n  enew | only\n  copen\n  let bnum = bufnr('')\n  exe 'sbuffer ' . bnum\n  wincmd b\n  cfirst\n  call assert_equal(2, winnr())\n  call assert_equal('F1', @%)\n  enew | only\n  exe 'sb' bnum\n  exe 'botright sb' bnum\n  wincmd t\n  clast\n  call assert_equal(2, winnr())\n  call assert_equal('quickfix', getwinvar(1, '&buftype'))\n  call assert_equal('quickfix', getwinvar(3, '&buftype'))\n\n  \" Jumping to a file from the location list window should find a usable\n  \" window by wrapping around the window list.\n  enew | only\n  call setloclist(0, [], 'f')\n  new | new\n  lgetexpr [\"F1%10%Line 10\", \"F2%20%Line 20\", \"F3%30%Line 30\"]\n  lopen\n  1close\n  call assert_equal(0, getloclist(3, {'id' : 0}).id)\n  lnext\n  call assert_equal(3, winnr())\n  call assert_equal(getloclist(1, {'id' : 0}).id, getloclist(3, {'id' : 0}).id)\n\n  enew | only\n  set efm&vim\nendfunc\n\nfunc Test_cwindow_highlight()\n  CheckScreendump\n\n  let lines =<< trim END\n    call setline(1, ['some', 'text', 'with', 'matches'])\n    write XCwindow\n    vimgrep e XCwindow\n    redraw\n    cwindow 4\n  END\n  call writefile(lines, 'XtestCwindow')\n  let buf = RunVimInTerminal('-S XtestCwindow', #{rows: 12})\n  call VerifyScreenDump(buf, 'Test_quickfix_cwindow_1', {})\n\n  call term_sendkeys(buf, \":cnext\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_quickfix_cwindow_2', {})\n\n  call term_sendkeys(buf, \"\\<C-W>j:set cursorline\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_quickfix_cwindow_3', {})\n\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_quickfix_cwindow_4', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XtestCwindow')\n  call delete('XCwindow')\nendfunc\n\nfunc XvimgrepTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  let lines =<< trim END\n    Editor:VIM vim\n    Editor:Emacs EmAcS\n    Editor:Notepad NOTEPAD\n  END\n  call writefile(lines, 'Xtestfile1')\n  call writefile(['Linux', 'macOS', 'MS-Windows'], 'Xtestfile2')\n\n  \" Error cases\n  call assert_fails('Xvimgrep /abc *', 'E682:')\n\n  let @/=''\n  call assert_fails('Xvimgrep // *', 'E35:')\n\n  call assert_fails('Xvimgrep abc', 'E683:')\n  call assert_fails('Xvimgrep a1b2c3 Xtestfile1', 'E480:')\n  call assert_fails('Xvimgrep pat Xa1b2c3', 'E480:')\n\n  Xexpr \"\"\n  Xvimgrepadd Notepad Xtestfile1\n  Xvimgrepadd macOS Xtestfile2\n  let l = g:Xgetlist()\n  call assert_equal(2, len(l))\n  call assert_equal('Editor:Notepad NOTEPAD', l[0].text)\n\n  10Xvimgrep #\\cvim#g Xtestfile?\n  let l = g:Xgetlist()\n  call assert_equal(2, len(l))\n  call assert_equal(8, l[0].col)\n  call assert_equal(11, l[0].end_col)\n  call assert_equal(12, l[1].col)\n  call assert_equal(15, l[1].end_col)\n\n  1Xvimgrep ?Editor? Xtestfile*\n  let l = g:Xgetlist()\n  call assert_equal(1, len(l))\n  call assert_equal('Editor:VIM vim', l[0].text)\n\n  edit +3 Xtestfile2\n  Xvimgrep +\\cemacs+j Xtestfile1\n  let l = g:Xgetlist()\n  call assert_equal('Xtestfile2', @%)\n  call assert_equal('Editor:Emacs EmAcS', l[0].text)\n\n  \" Test for unloading a buffer after vimgrep searched the buffer\n  %bwipe\n  Xvimgrep /Editor/j Xtestfile*\n  call assert_equal(0, getbufinfo('Xtestfile1')[0].loaded)\n  call assert_equal([], getbufinfo('Xtestfile2'))\n\n  \" Test for opening the dummy buffer used by vimgrep in a window. The new\n  \" window should be closed\n  %bw!\n  augroup QF_Test\n    au!\n    autocmd BufReadPre * exe \"sb \" .. expand(\"<abuf>\")\n  augroup END\n  call assert_fails(\"Xvimgrep /sublime/ Xtestfile1\", 'E480:')\n  call assert_equal(1, winnr('$'))\n  augroup QF_Test\n    au!\n  augroup END\n\n  call delete('Xtestfile1')\n  call delete('Xtestfile2')\nendfunc\n\n\" Tests for the :vimgrep command\nfunc Test_vimgrep()\n  call XvimgrepTests('c')\n  call XvimgrepTests('l')\nendfunc\n\nfunc Test_vimgrep_wildcards_expanded_once()\n  new X[id-01] file.txt\n  call setline(1, 'some text to search for')\n  vimgrep text %\n  bwipe!\nendfunc\n\n\" Test for incsearch highlighting of the :vimgrep pattern\n\" This test used to cause \"E315: ml_get: invalid lnum\" errors.\nfunc Test_vimgrep_incsearch()\n  enew\n  set incsearch\n  call test_override(\"char_avail\", 1)\n\n  call feedkeys(\":2vimgrep assert test_quickfix.vim test_cdo.vim\\<CR>\", \"ntx\")\n  let l = getqflist()\n  call assert_equal(2, len(l))\n\n  call test_override(\"ALL\", 0)\n  set noincsearch\nendfunc\n\n\" Test vimgrep with the last search pattern not set\nfunc Test_vimgrep_with_no_last_search_pat()\n  let lines =<< trim [SCRIPT]\n    call assert_fails('vimgrep // *', 'E35:')\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n  call delete('Xscript')\n  call delete('Xresult')\nendfunc\n\n\" Test vimgrep without swap file\nfunc Test_vimgrep_without_swap_file()\n  let lines =<< trim [SCRIPT]\n    vimgrep grep test_c*\n    call writefile(['done'], 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '--clean -n -S Xscript Xscript')\n    call assert_equal(['done'], readfile('Xresult'))\n  endif\n  call delete('Xscript')\n  call delete('Xresult')\nendfunc\n\nfunc Test_vimgrep_existing_swapfile()\n  call writefile(['match apple with apple'], 'Xapple')\n  call writefile(['swapfile'], '.Xapple.swp')\n  let g:foundSwap = 0\n  let g:ignoreSwapExists = 1\n  augroup grep\n    au SwapExists * let foundSwap = 1 | let v:swapchoice = 'e'\n  augroup END\n  vimgrep apple Xapple\n  call assert_equal(1, g:foundSwap)\n  call assert_match('.Xapple.swo', swapname(''))\n\n  call delete('Xapple')\n  call delete('.Xapple.swp')\n  augroup grep\n    au! SwapExists\n  augroup END\n  unlet g:ignoreSwapExists\nendfunc\n\nfunc XfreeTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  enew | only\n\n  \" Deleting the quickfix stack should work even When the current list is\n  \" somewhere in the middle of the stack\n  Xexpr ['Xfile1:10:10:Line 10', 'Xfile1:15:15:Line 15']\n  Xexpr ['Xfile2:20:20:Line 20', 'Xfile2:25:25:Line 25']\n  Xexpr ['Xfile3:30:30:Line 30', 'Xfile3:35:35:Line 35']\n  Xolder\n  call g:Xsetlist([], 'f')\n  call assert_equal(0, len(g:Xgetlist()))\n\n  \" After deleting the stack, adding a new list should create a stack with a\n  \" single list.\n  Xexpr ['Xfile1:10:10:Line 10', 'Xfile1:15:15:Line 15']\n  call assert_equal(1, g:Xgetlist({'all':1}).nr)\n\n  \" Deleting the stack from a quickfix window should update/clear the\n  \" quickfix/location list window.\n  Xexpr ['Xfile1:10:10:Line 10', 'Xfile1:15:15:Line 15']\n  Xexpr ['Xfile2:20:20:Line 20', 'Xfile2:25:25:Line 25']\n  Xexpr ['Xfile3:30:30:Line 30', 'Xfile3:35:35:Line 35']\n  Xolder\n  Xwindow\n  call g:Xsetlist([], 'f')\n  call assert_equal(2, winnr('$'))\n  call assert_equal(1, line('$'))\n  Xclose\n\n  \" Deleting the stack from a non-quickfix window should update/clear the\n  \" quickfix/location list window.\n  Xexpr ['Xfile1:10:10:Line 10', 'Xfile1:15:15:Line 15']\n  Xexpr ['Xfile2:20:20:Line 20', 'Xfile2:25:25:Line 25']\n  Xexpr ['Xfile3:30:30:Line 30', 'Xfile3:35:35:Line 35']\n  Xolder\n  Xwindow\n  wincmd p\n  call g:Xsetlist([], 'f')\n  call assert_equal(0, len(g:Xgetlist()))\n  wincmd p\n  call assert_equal(2, winnr('$'))\n  call assert_equal(1, line('$'))\n\n  \" After deleting the location list stack, if the location list window is\n  \" opened, then a new location list should be created. So opening the\n  \" location list window again should not create a new window.\n  if a:cchar == 'l'\n      lexpr ['Xfile1:10:10:Line 10', 'Xfile1:15:15:Line 15']\n      wincmd p\n      lopen\n      call assert_equal(2, winnr('$'))\n  endif\n  Xclose\nendfunc\n\n\" Tests for the quickfix free functionality\nfunc Test_qf_free()\n  call XfreeTests('c')\n  call XfreeTests('l')\nendfunc\n\n\" Test for buffer overflow when parsing lines and adding new entries to\n\" the quickfix list.\nfunc Test_bufoverflow()\n  set efm=%f:%l:%m\n  cgetexpr ['File1:100:' . repeat('x', 1025)]\n\n  set efm=%+GCompiler:\\ %.%#,%f:%l:%m\n  cgetexpr ['Compiler: ' . repeat('a', 1015), 'File1:10:Hello World']\n\n  set efm=%DEntering\\ directory\\ %f,%f:%l:%m\n  let lines =<< trim eval END\n    Entering directory $\"{repeat('a', 1006)}\"\n    File1:10:Hello World\n  END\n  cgetexpr lines\n  set efm&vim\nendfunc\n\n\" Tests for getting the quickfix stack size\nfunc XsizeTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n  call assert_equal(0, g:Xgetlist({'nr':'$'}).nr)\n  call assert_equal('', g:Xgetlist({'nr':'$', 'all':1}).title)\n  call assert_equal(0, g:Xgetlist({'nr':0}).nr)\n\n  Xexpr \"File1:10:Line1\"\n  Xexpr \"File2:20:Line2\"\n  Xexpr \"File3:30:Line3\"\n  Xolder | Xolder\n  call assert_equal(3, g:Xgetlist({'nr':'$'}).nr)\n  call g:Xsetlist([], 'f')\n\n  Xexpr \"File1:10:Line1\"\n  Xexpr \"File2:20:Line2\"\n  Xexpr \"File3:30:Line3\"\n  Xolder | Xolder\n  call g:Xsetlist([], 'a', {'nr':'$', 'title':'Compiler'})\n  call assert_equal('Compiler', g:Xgetlist({'nr':3, 'all':1}).title)\nendfunc\n\nfunc Test_Qf_Size()\n  call XsizeTests('c')\n  call XsizeTests('l')\nendfunc\n\nfunc Test_cclose_from_copen()\n    augroup QF_Test\n\tau!\n        au FileType qf :call assert_fails(':cclose', 'E788:')\n    augroup END\n    copen\n    augroup QF_Test\n\tau!\n    augroup END\n    augroup! QF_Test\nendfunc\n\nfunc Test_cclose_in_autocmd()\n  \" Problem is only triggered if \"starting\" is zero, so that the OptionsSet\n  \" event will be triggered.\n  call test_override('starting', 1)\n  augroup QF_Test\n    au!\n    au FileType qf :call assert_fails(':cclose', 'E788:')\n  augroup END\n  copen\n  augroup QF_Test\n    au!\n  augroup END\n  augroup! QF_Test\n  call test_override('starting', 0)\nendfunc\n\n\" Check that \":file\" without an argument is possible even when \"curbuf_lock\"\n\" is set.\nfunc Test_file_from_copen()\n  \" Works without argument.\n  augroup QF_Test\n    au!\n    au FileType qf file\n  augroup END\n  copen\n\n  augroup QF_Test\n    au!\n  augroup END\n  cclose\n\n  \" Fails with argument.\n  augroup QF_Test\n    au!\n    au FileType qf call assert_fails(':file foo', 'E788:')\n  augroup END\n  copen\n  augroup QF_Test\n    au!\n  augroup END\n  cclose\n\n  augroup! QF_Test\nendfunc\n\nfunc Test_resize_from_copen()\n  augroup QF_Test\n    au!\n    au FileType qf resize 5\n  augroup END\n  try\n    \" This should succeed without any exception.  No other buffers are\n    \" involved in the autocmd.\n    copen\n  finally\n    augroup QF_Test\n      au!\n    augroup END\n    augroup! QF_Test\n  endtry\nendfunc\n\nfunc Test_vimgrep_with_textlock()\n  new\n\n  \" Simple way to execute something with \"textlock\" set.\n  \" Check that vimgrep without jumping can be executed.\n  au InsertCharPre * vimgrep /RunTheTest/j runtest.vim\n  normal ax\n  let qflist = getqflist()\n  call assert_true(len(qflist) > 0)\n  call assert_match('RunTheTest', qflist[0].text)\n  call setqflist([], 'r')\n  au! InsertCharPre\n\n  \" Check that vimgrepadd without jumping can be executed.\n  au InsertCharPre * vimgrepadd /RunTheTest/j runtest.vim\n  normal ax\n  let qflist = getqflist()\n  call assert_true(len(qflist) > 0)\n  call assert_match('RunTheTest', qflist[0].text)\n  call setqflist([], 'r')\n  au! InsertCharPre\n\n  \" Check that lvimgrep without jumping can be executed.\n  au InsertCharPre * lvimgrep /RunTheTest/j runtest.vim\n  normal ax\n  let qflist = getloclist(0)\n  call assert_true(len(qflist) > 0)\n  call assert_match('RunTheTest', qflist[0].text)\n  call setloclist(0, [], 'r')\n  au! InsertCharPre\n\n  \" Check that lvimgrepadd without jumping can be executed.\n  au InsertCharPre * lvimgrepadd /RunTheTest/j runtest.vim\n  normal ax\n  let qflist = getloclist(0)\n  call assert_true(len(qflist) > 0)\n  call assert_match('RunTheTest', qflist[0].text)\n  call setloclist(0, [], 'r')\n  au! InsertCharPre\n\n  \" trying to jump will give an error\n  au InsertCharPre * vimgrep /RunTheTest/ runtest.vim\n  call assert_fails('normal ax', 'E565:')\n  au! InsertCharPre\n\n  au InsertCharPre * vimgrepadd /RunTheTest/ runtest.vim\n  call assert_fails('normal ax', 'E565:')\n  au! InsertCharPre\n\n  au InsertCharPre * lvimgrep /RunTheTest/ runtest.vim\n  call assert_fails('normal ax', 'E565:')\n  au! InsertCharPre\n\n  au InsertCharPre * lvimgrepadd /RunTheTest/ runtest.vim\n  call assert_fails('normal ax', 'E565:')\n  au! InsertCharPre\n\n  bwipe!\nendfunc\n\n\" Tests for the quickfix buffer b:changedtick variable\nfunc Xchangedtick_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  new | only\n\n  Xexpr \"\" | Xexpr \"\" | Xexpr \"\"\n\n  Xopen\n  Xolder\n  Xolder\n  Xaddexpr \"F1:10:Line10\"\n  Xaddexpr \"F2:20:Line20\"\n  call g:Xsetlist([{\"filename\":\"F3\", \"lnum\":30, \"text\":\"Line30\"}], 'a')\n  call g:Xsetlist([], 'f')\n  call assert_equal(8, getbufvar('%', 'changedtick'))\n  Xclose\nendfunc\n\nfunc Test_changedtick()\n  call Xchangedtick_tests('c')\n  call Xchangedtick_tests('l')\nendfunc\n\n\" Tests for parsing an expression using setqflist()\nfunc Xsetexpr_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  let t = [\"File1:10:Line10\", \"File1:20:Line20\"]\n  call g:Xsetlist([], ' ', {'lines' : t})\n  call g:Xsetlist([], 'a', {'lines' : [\"File1:30:Line30\"]})\n\n  let l = g:Xgetlist()\n  call assert_equal(3, len(l))\n  call assert_equal(20, l[1].lnum)\n  call assert_equal('Line30', l[2].text)\n  call g:Xsetlist([], 'r', {'lines' : [\"File2:5:Line5\"]})\n  let l = g:Xgetlist()\n  call assert_equal(1, len(l))\n  call assert_equal('Line5', l[0].text)\n  call assert_equal(-1, g:Xsetlist([], 'a', {'lines' : 10}))\n  call assert_equal(-1, g:Xsetlist([], 'a', {'lines' : \"F1:10:L10\"}))\n\n  call g:Xsetlist([], 'f')\n  \" Add entries to multiple lists\n  call g:Xsetlist([], 'a', {'nr' : 1, 'lines' : [\"File1:10:Line10\"]})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'lines' : [\"File2:20:Line20\"]})\n  call g:Xsetlist([], 'a', {'nr' : 1, 'lines' : [\"File1:15:Line15\"]})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'lines' : [\"File2:25:Line25\"]})\n  call assert_equal('Line15', g:Xgetlist({'nr':1, 'items':1}).items[1].text)\n  call assert_equal('Line25', g:Xgetlist({'nr':2, 'items':1}).items[1].text)\n\n  \" Adding entries using a custom efm\n  set efm&\n  call g:Xsetlist([], ' ', {'efm' : '%f#%l#%m',\n\t\t\t\t\\ 'lines' : [\"F1#10#L10\", \"F2#20#L20\"]})\n  call assert_equal(20, g:Xgetlist({'items':1}).items[1].lnum)\n  call g:Xsetlist([], 'a', {'efm' : '%f#%l#%m', 'lines' : [\"F3:30:L30\"]})\n  call assert_equal('F3:30:L30', g:Xgetlist({'items':1}).items[2].text)\n  call assert_equal(20, g:Xgetlist({'items':1}).items[1].lnum)\n  call assert_equal(-1, g:Xsetlist([], 'a', {'efm' : [],\n\t\t\t\t\\ 'lines' : ['F1:10:L10']}))\nendfunc\n\nfunc Test_setexpr()\n  call Xsetexpr_tests('c')\n  call Xsetexpr_tests('l')\nendfunc\n\n\" Tests for per quickfix/location list directory stack\nfunc Xmultidirstack_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n  Xexpr \"\" | Xexpr \"\"\n\n  call g:Xsetlist([], 'a', {'nr' : 1, 'lines' : [\"Entering dir 'Xone/a'\"]})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'lines' : [\"Entering dir 'Xtwo/a'\"]})\n  call g:Xsetlist([], 'a', {'nr' : 1, 'lines' : [\"one.txt:3:one one one\"]})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'lines' : [\"two.txt:5:two two two\"]})\n\n  let l1 = g:Xgetlist({'nr':1, 'items':1})\n  let l2 = g:Xgetlist({'nr':2, 'items':1})\n  call assert_equal('Xone/a/one.txt', bufname(l1.items[1].bufnr))\n  call assert_equal(3, l1.items[1].lnum)\n  call assert_equal('Xtwo/a/two.txt', bufname(l2.items[1].bufnr))\n  call assert_equal(5, l2.items[1].lnum)\nendfunc\n\nfunc Test_multidirstack()\n  call mkdir('Xone/a', 'p')\n  call mkdir('Xtwo/a', 'p')\n  let lines = ['1', '2', 'one one one', '4', 'two two two', '6', '7']\n  call writefile(lines, 'Xone/a/one.txt')\n  call writefile(lines, 'Xtwo/a/two.txt')\n  let save_efm = &efm\n  set efm=%DEntering\\ dir\\ '%f',%f:%l:%m,%XLeaving\\ dir\\ '%f'\n\n  call Xmultidirstack_tests('c')\n  call Xmultidirstack_tests('l')\n\n  let &efm = save_efm\n  call delete('Xone', 'rf')\n  call delete('Xtwo', 'rf')\nendfunc\n\n\" Tests for per quickfix/location list file stack\nfunc Xmultifilestack_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n  Xexpr \"\" | Xexpr \"\"\n\n  call g:Xsetlist([], 'a', {'nr' : 1, 'lines' : [\"[one.txt]\"]})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'lines' : [\"[two.txt]\"]})\n  call g:Xsetlist([], 'a', {'nr' : 1, 'lines' : [\"(3,5) one one one\"]})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'lines' : [\"(5,9) two two two\"]})\n\n  let l1 = g:Xgetlist({'nr':1, 'items':1})\n  let l2 = g:Xgetlist({'nr':2, 'items':1})\n  call assert_equal('one.txt', bufname(l1.items[1].bufnr))\n  call assert_equal(3, l1.items[1].lnum)\n  call assert_equal('two.txt', bufname(l2.items[1].bufnr))\n  call assert_equal(5, l2.items[1].lnum)\n\n  \" Test for start of a new error line in the same line where a previous\n  \" error line ends with a file stack.\n  let efm_val = 'Error\\ l%l\\ in\\ %f,'\n  let efm_val .= '%-P%>(%f%r,Error\\ l%l\\ in\\ %m,%-Q)%r'\n  let lines =<< trim END\n    (one.txt\n    Error l4 in one.txt\n    ) (two.txt\n    Error l6 in two.txt\n    )\n    Error l8 in one.txt\n  END\n  let l = g:Xgetlist({'lines': lines, 'efm' : efm_val})\n  call assert_equal(3, len(l.items))\n  call assert_equal('one.txt', bufname(l.items[0].bufnr))\n  call assert_equal(4, l.items[0].lnum)\n  call assert_equal('one.txt', l.items[0].text)\n  call assert_equal('two.txt', bufname(l.items[1].bufnr))\n  call assert_equal(6, l.items[1].lnum)\n  call assert_equal('two.txt', l.items[1].text)\n  call assert_equal('one.txt', bufname(l.items[2].bufnr))\n  call assert_equal(8, l.items[2].lnum)\n  call assert_equal('', l.items[2].text)\nendfunc\n\nfunc Test_multifilestack()\n  let lines = ['1', '2', 'one one one', '4', 'two two two', '6', '7']\n  call writefile(lines, 'one.txt')\n  call writefile(lines, 'two.txt')\n  let save_efm = &efm\n  set efm=%+P[%f],(%l\\\\,%c)\\ %m,%-Q\n\n  call Xmultifilestack_tests('c')\n  call Xmultifilestack_tests('l')\n\n  let &efm = save_efm\n  call delete('one.txt')\n  call delete('two.txt')\nendfunc\n\n\" Tests for per buffer 'efm' setting\nfunc Test_perbuf_efm()\n  call writefile([\"File1-10-Line10\"], 'one.txt')\n  call writefile([\"File2#20#Line20\"], 'two.txt')\n  set efm=%f#%l#%m\n  new | only\n  new\n  setlocal efm=%f-%l-%m\n  cfile one.txt\n  wincmd w\n  caddfile two.txt\n\n  let l = getqflist()\n  call assert_equal(10, l[0].lnum)\n  call assert_equal('Line20', l[1].text)\n\n  set efm&\n  new | only\n  call delete('one.txt')\n  call delete('two.txt')\nendfunc\n\n\" Open multiple help windows using \":lhelpgrep\n\" This test used to crash Vim\nfunc Test_Multi_LL_Help()\n  new | only\n  lhelpgrep window\n  lopen\n  e#\n  lhelpgrep buffer\n  call assert_equal(3, winnr('$'))\n  call assert_true(len(getloclist(1)) != 0)\n  call assert_true(len(getloclist(2)) != 0)\n  new | only\nendfunc\n\n\" Tests for adding new quickfix lists using setqflist()\nfunc XaddQf_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Create a new list using ' ' for action\n  call g:Xsetlist([], 'f')\n  call g:Xsetlist([], ' ', {'title' : 'Test1'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(1, l.nr)\n  call assert_equal('Test1', l.title)\n\n  \" Create a new list using ' ' for action and '$' for 'nr'\n  call g:Xsetlist([], 'f')\n  call g:Xsetlist([], ' ', {'title' : 'Test2', 'nr' : '$'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(1, l.nr)\n  call assert_equal('Test2', l.title)\n\n  \" Create a new list using 'a' for action\n  call g:Xsetlist([], 'f')\n  call g:Xsetlist([], 'a', {'title' : 'Test3'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(1, l.nr)\n  call assert_equal('Test3', l.title)\n\n  \" Create a new list using 'a' for action and '$' for 'nr'\n  call g:Xsetlist([], 'f')\n  call g:Xsetlist([], 'a', {'title' : 'Test3', 'nr' : '$'})\n  call g:Xsetlist([], 'a', {'title' : 'Test4'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(1, l.nr)\n  call assert_equal('Test4', l.title)\n\n  \" Adding a quickfix list should remove all the lists following the current\n  \" list.\n  Xexpr \"\" | Xexpr \"\" | Xexpr \"\"\n  silent! 10Xolder\n  call g:Xsetlist([], ' ', {'title' : 'Test5'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(2, l.nr)\n  call assert_equal('Test5', l.title)\n\n  \" Add a quickfix list using '$' as the list number.\n  let lastqf = g:Xgetlist({'nr':'$'}).nr\n  silent! 99Xolder\n  call g:Xsetlist([], ' ', {'nr' : '$', 'title' : 'Test6'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(lastqf + 1, l.nr)\n  call assert_equal('Test6', l.title)\n\n  \" Add a quickfix list using 'nr' set to one more than the quickfix\n  \" list size.\n  let lastqf = g:Xgetlist({'nr':'$'}).nr\n  silent! 99Xolder\n  call g:Xsetlist([], ' ', {'nr' : lastqf + 1, 'title' : 'Test7'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(lastqf + 1, l.nr)\n  call assert_equal('Test7', l.title)\n\n  \" Add a quickfix list to a stack with 10 lists using 'nr' set to '$'\n  exe repeat('Xexpr \"\" |', 9) . 'Xexpr \"\"'\n  silent! 99Xolder\n  call g:Xsetlist([], ' ', {'nr' : '$', 'title' : 'Test8'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(10, l.nr)\n  call assert_equal('Test8', l.title)\n\n  \" Add a quickfix list using 'nr' set to a value greater than 10\n  call assert_equal(-1, g:Xsetlist([], ' ', {'nr' : 12, 'title' : 'Test9'}))\n\n  \" Try adding a quickfix list with 'nr' set to a value greater than the\n  \" quickfix list size but less than 10.\n  call g:Xsetlist([], 'f')\n  Xexpr \"\" | Xexpr \"\" | Xexpr \"\"\n  silent! 99Xolder\n  call assert_equal(-1, g:Xsetlist([], ' ', {'nr' : 8, 'title' : 'Test10'}))\n\n  \" Add a quickfix list using 'nr' set to a some string or list\n  call assert_equal(-1, g:Xsetlist([], ' ', {'nr' : [1,2], 'title' : 'Test11'}))\nendfunc\n\nfunc Test_add_qf()\n  call XaddQf_tests('c')\n  call XaddQf_tests('l')\nendfunc\n\n\" Test for getting the quickfix list items from some text without modifying\n\" the quickfix stack\nfunc XgetListFromLines(cchar)\n  call s:setup_commands(a:cchar)\n  call g:Xsetlist([], 'f')\n\n  let l = g:Xgetlist({'lines' : [\"File2:20:Line20\", \"File2:30:Line30\"]}).items\n  call assert_equal(2, len(l))\n  call assert_equal(30, l[1].lnum)\n\n  call assert_equal({}, g:Xgetlist({'lines' : 10}))\n  call assert_equal({}, g:Xgetlist({'lines' : 'File1:10:Line10'}))\n  call assert_equal([], g:Xgetlist({'lines' : []}).items)\n  call assert_equal([], g:Xgetlist({'lines' : [10, 20]}).items)\n\n  \" Parse text using a custom efm\n  set efm&\n  let l = g:Xgetlist({'lines':['File3#30#Line30'], 'efm' : '%f#%l#%m'}).items\n  call assert_equal('Line30', l[0].text)\n  let l = g:Xgetlist({'lines':['File3:30:Line30'], 'efm' : '%f-%l-%m'}).items\n  call assert_equal('File3:30:Line30', l[0].text)\n  let l = g:Xgetlist({'lines':['File3:30:Line30'], 'efm' : [1,2]})\n  call assert_equal({}, l)\n  call assert_fails(\"call g:Xgetlist({'lines':['abc'], 'efm':'%2'})\", 'E376:')\n  call assert_fails(\"call g:Xgetlist({'lines':['abc'], 'efm':''})\", 'E378:')\n\n  \" Make sure that the quickfix stack is not modified\n  call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\nendfunc\n\nfunc Test_get_list_from_lines()\n  call XgetListFromLines('c')\n  call XgetListFromLines('l')\nendfunc\n\n\" Tests for the quickfix list id\nfunc Xqfid_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n  call assert_equal(0, g:Xgetlist({'id':0}).id)\n  Xexpr ''\n  let start_id = g:Xgetlist({'id' : 0}).id\n  Xexpr '' | Xexpr ''\n  Xolder\n  call assert_equal(start_id, g:Xgetlist({'id':0, 'nr':1}).id)\n  call assert_equal(start_id + 1, g:Xgetlist({'id':0, 'nr':0}).id)\n  call assert_equal(start_id + 2, g:Xgetlist({'id':0, 'nr':'$'}).id)\n  call assert_equal(0, g:Xgetlist({'id':0, 'nr':99}).id)\n  call assert_equal(2, g:Xgetlist({'id':start_id + 1, 'nr':0}).nr)\n  call assert_equal(0, g:Xgetlist({'id':99, 'nr':0}).id)\n  call assert_equal(0, g:Xgetlist({'id':\"abc\", 'nr':0}).id)\n\n  call g:Xsetlist([], 'a', {'id':start_id, 'context':[1,2]})\n  call assert_equal([1,2], g:Xgetlist({'nr':1, 'context':1}).context)\n  call g:Xsetlist([], 'a', {'id':start_id+1, 'lines':['F1:10:L10']})\n  call assert_equal('L10', g:Xgetlist({'nr':2, 'items':1}).items[0].text)\n  call assert_equal(-1, g:Xsetlist([], 'a', {'id':999, 'title':'Vim'}))\n  call assert_equal(-1, g:Xsetlist([], 'a', {'id':'abc', 'title':'Vim'}))\n\n  let qfid = g:Xgetlist({'id':0, 'nr':0})\n  call g:Xsetlist([], 'f')\n  call assert_equal(0, g:Xgetlist({'id':qfid, 'nr':0}).id)\nendfunc\n\nfunc Test_qf_id()\n  call Xqfid_tests('c')\n  call Xqfid_tests('l')\nendfunc\n\nfunc Xqfjump_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call writefile([\"Line1\\tFoo\", \"Line2\"], 'F1')\n  call writefile([\"Line1\\tBar\", \"Line2\"], 'F2')\n  call writefile([\"Line1\\tBaz\", \"Line2\"], 'F3')\n\n  call g:Xsetlist([], 'f')\n\n  \" Tests for\n  \"   Jumping to a line using a pattern\n  \"   Jumping to a column greater than the last column in a line\n  \"   Jumping to a line greater than the last line in the file\n  let l = []\n  for i in range(1, 7)\n    call add(l, {})\n  endfor\n  let l[0].filename='F1'\n  let l[0].pattern='Line1'\n  let l[1].filename='F2'\n  let l[1].pattern='Line1'\n  let l[2].filename='F3'\n  let l[2].pattern='Line1'\n  let l[3].filename='F3'\n  let l[3].lnum=1\n  let l[3].col=9\n  let l[3].vcol=1\n  let l[4].filename='F3'\n  let l[4].lnum=99\n  let l[5].filename='F3'\n  let l[5].lnum=1\n  let l[5].col=99\n  let l[5].vcol=1\n  let l[6].filename='F3'\n  let l[6].pattern='abcxyz'\n\n  call g:Xsetlist([], ' ', {'items' : l})\n  Xopen | only\n  2Xnext\n  call assert_equal(3, g:Xgetlist({'idx' : 0}).idx)\n  call assert_equal('F3', @%)\n  Xnext\n  call assert_equal(7, col('.'))\n  Xnext\n  call assert_equal(2, line('.'))\n  Xnext\n  call assert_equal(9, col('.'))\n  2\n  Xnext\n  call assert_equal(2, line('.'))\n\n  if a:cchar == 'l'\n    \" When jumping to a location list entry in the location list window and\n    \" no usable windows are available, then a new window should be opened.\n    enew! | new | only\n    call g:Xsetlist([], 'f')\n    setlocal buftype=nofile\n    new\n    let lines =<< trim END\n      F1:1:1:Line1\n      F1:2:2:Line2\n      F2:1:1:Line1\n      F2:2:2:Line2\n      F3:1:1:Line1\n      F3:2:2:Line2\n    END\n    call g:Xsetlist([], ' ', {'lines': lines})\n    Xopen\n    let winid = win_getid()\n    wincmd p\n    close\n    call win_gotoid(winid)\n    Xnext\n    call assert_equal(3, winnr('$'))\n    call assert_equal(1, winnr())\n    call assert_equal(2, line('.'))\n\n    \" When jumping to an entry in the location list window and the window\n    \" associated with the location list is not present and a window containing\n    \" the file is already present, then that window should be used.\n    close\n    belowright new\n    call g:Xsetlist([], 'f')\n    edit F3\n    call win_gotoid(winid)\n    Xlast\n    call assert_equal(3, winnr())\n    call assert_equal(6, g:Xgetlist({'size' : 1}).size)\n    call assert_equal(winid, g:Xgetlist({'winid' : 1}).winid)\n  endif\n\n  \" Cleanup\n  enew!\n  new | only\n\n  call delete('F1')\n  call delete('F2')\n  call delete('F3')\nendfunc\n\nfunc Test_qfjump()\n  call Xqfjump_tests('c')\n  call Xqfjump_tests('l')\nendfunc\n\n\" Tests for the getqflist() and getloclist() functions when the list is not\n\" present or is empty\nfunc Xgetlist_empty_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Empty quickfix stack\n  call g:Xsetlist([], 'f')\n  call assert_equal('', g:Xgetlist({'context' : 0}).context)\n  call assert_equal(0, g:Xgetlist({'id' : 0}).id)\n  call assert_equal(0, g:Xgetlist({'idx' : 0}).idx)\n  call assert_equal([], g:Xgetlist({'items' : 0}).items)\n  call assert_equal(0, g:Xgetlist({'nr' : 0}).nr)\n  call assert_equal(0, g:Xgetlist({'size' : 0}).size)\n  call assert_equal('', g:Xgetlist({'title' : 0}).title)\n  call assert_equal(0, g:Xgetlist({'winid' : 0}).winid)\n  call assert_equal(0, g:Xgetlist({'changedtick' : 0}).changedtick)\n  if a:cchar == 'c'\n    call assert_equal({'context' : '', 'id' : 0, 'idx' : 0,\n\t\t  \\ 'items' : [], 'nr' : 0, 'size' : 0, 'qfbufnr' : 0,\n\t\t  \\ 'title' : '', 'winid' : 0, 'changedtick': 0,\n                  \\ 'quickfixtextfunc' : ''}, g:Xgetlist({'all' : 0}))\n  else\n    call assert_equal({'context' : '', 'id' : 0, 'idx' : 0,\n\t\t\\ 'items' : [], 'nr' : 0, 'size' : 0, 'title' : '',\n\t\t\\ 'winid' : 0, 'changedtick': 0, 'filewinid' : 0,\n\t\t\\ 'qfbufnr' : 0, 'quickfixtextfunc' : ''},\n\t\t\\ g:Xgetlist({'all' : 0}))\n  endif\n\n  \" Quickfix window with empty stack\n  silent! Xopen\n  let qfwinid = (a:cchar == 'c') ? win_getid() : 0\n  let qfbufnr = (a:cchar == 'c') ? bufnr('') : 0\n  call assert_equal(qfwinid, g:Xgetlist({'winid' : 0}).winid)\n  Xclose\n\n  \" Empty quickfix list\n  Xexpr \"\"\n  call assert_equal('', g:Xgetlist({'context' : 0}).context)\n  call assert_notequal(0, g:Xgetlist({'id' : 0}).id)\n  call assert_equal(0, g:Xgetlist({'idx' : 0}).idx)\n  call assert_equal([], g:Xgetlist({'items' : 0}).items)\n  call assert_notequal(0, g:Xgetlist({'nr' : 0}).nr)\n  call assert_equal(0, g:Xgetlist({'size' : 0}).size)\n  call assert_notequal('', g:Xgetlist({'title' : 0}).title)\n  call assert_equal(0, g:Xgetlist({'winid' : 0}).winid)\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  let qfid = g:Xgetlist({'id' : 0}).id\n  call g:Xsetlist([], 'f')\n\n  \" Non-existing quickfix identifier\n  call assert_equal('', g:Xgetlist({'id' : qfid, 'context' : 0}).context)\n  call assert_equal(0, g:Xgetlist({'id' : qfid}).id)\n  call assert_equal(0, g:Xgetlist({'id' : qfid, 'idx' : 0}).idx)\n  call assert_equal([], g:Xgetlist({'id' : qfid, 'items' : 0}).items)\n  call assert_equal(0, g:Xgetlist({'id' : qfid, 'nr' : 0}).nr)\n  call assert_equal(0, g:Xgetlist({'id' : qfid, 'size' : 0}).size)\n  call assert_equal('', g:Xgetlist({'id' : qfid, 'title' : 0}).title)\n  call assert_equal(0, g:Xgetlist({'id' : qfid, 'winid' : 0}).winid)\n  call assert_equal(0, g:Xgetlist({'id' : qfid, 'changedtick' : 0}).changedtick)\n  if a:cchar == 'c'\n    call assert_equal({'context' : '', 'id' : 0, 'idx' : 0, 'items' : [],\n\t\t\\ 'nr' : 0, 'size' : 0, 'title' : '', 'winid' : 0,\n\t\t\\ 'qfbufnr' : qfbufnr, 'quickfixtextfunc' : '',\n\t\t\\ 'changedtick' : 0}, g:Xgetlist({'id' : qfid, 'all' : 0}))\n  else\n    call assert_equal({'context' : '', 'id' : 0, 'idx' : 0, 'items' : [],\n\t\t\\ 'nr' : 0, 'size' : 0, 'title' : '', 'winid' : 0,\n\t\t\\ 'changedtick' : 0, 'filewinid' : 0, 'qfbufnr' : 0,\n                \\ 'quickfixtextfunc' : ''},\n\t\t\\ g:Xgetlist({'id' : qfid, 'all' : 0}))\n  endif\n\n  \" Non-existing quickfix list number\n  call assert_equal('', g:Xgetlist({'nr' : 5, 'context' : 0}).context)\n  call assert_equal(0, g:Xgetlist({'nr' : 5}).nr)\n  call assert_equal(0, g:Xgetlist({'nr' : 5, 'idx' : 0}).idx)\n  call assert_equal([], g:Xgetlist({'nr' : 5, 'items' : 0}).items)\n  call assert_equal(0, g:Xgetlist({'nr' : 5, 'id' : 0}).id)\n  call assert_equal(0, g:Xgetlist({'nr' : 5, 'size' : 0}).size)\n  call assert_equal('', g:Xgetlist({'nr' : 5, 'title' : 0}).title)\n  call assert_equal(0, g:Xgetlist({'nr' : 5, 'winid' : 0}).winid)\n  call assert_equal(0, g:Xgetlist({'nr' : 5, 'changedtick' : 0}).changedtick)\n  if a:cchar == 'c'\n    call assert_equal({'context' : '', 'id' : 0, 'idx' : 0, 'items' : [],\n\t\t\\ 'nr' : 0, 'size' : 0, 'title' : '', 'winid' : 0,\n\t\t\\ 'changedtick' : 0, 'qfbufnr' : qfbufnr,\n                \\ 'quickfixtextfunc' : ''}, g:Xgetlist({'nr' : 5, 'all' : 0}))\n  else\n    call assert_equal({'context' : '', 'id' : 0, 'idx' : 0, 'items' : [],\n\t\t\\ 'nr' : 0, 'size' : 0, 'title' : '', 'winid' : 0,\n\t\t\\ 'changedtick' : 0, 'filewinid' : 0, 'qfbufnr' : 0,\n                \\ 'quickfixtextfunc' : ''}, g:Xgetlist({'nr' : 5, 'all' : 0}))\n  endif\nendfunc\n\nfunc Test_getqflist()\n  call Xgetlist_empty_tests('c')\n  call Xgetlist_empty_tests('l')\nendfunc\n\nfunc Test_getqflist_invalid_nr()\n  \" The following commands used to crash Vim\n  cexpr \"\"\n  call getqflist({'nr' : $XXX_DOES_NOT_EXIST_XXX})\n\n  \" Cleanup\n  call setqflist([], 'r')\nendfunc\n\n\" Tests for the quickfix/location list changedtick\nfunc Xqftick_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n\n  Xexpr \"F1:10:Line10\"\n  let qfid = g:Xgetlist({'id' : 0}).id\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n  Xaddexpr \"F2:20:Line20\\nF2:21:Line21\"\n  call assert_equal(2, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call g:Xsetlist([], 'a', {'lines' : [\"F3:30:Line30\", \"F3:31:Line31\"]})\n  call assert_equal(3, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call g:Xsetlist([], 'r', {'lines' : [\"F4:40:Line40\"]})\n  call assert_equal(4, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call g:Xsetlist([], 'a', {'title' : 'New Title'})\n  call assert_equal(5, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  enew!\n  call append(0, [\"F5:50:L50\", \"F6:60:L60\"])\n  Xaddbuffer\n  call assert_equal(6, g:Xgetlist({'changedtick' : 0}).changedtick)\n  enew!\n\n  call g:Xsetlist([], 'a', {'context' : {'bus' : 'pci'}})\n  call assert_equal(7, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call g:Xsetlist([{'filename' : 'F7', 'lnum' : 10, 'text' : 'L7'},\n\t      \\ {'filename' : 'F7', 'lnum' : 11, 'text' : 'L11'}], 'a')\n  call assert_equal(8, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call g:Xsetlist([{'filename' : 'F7', 'lnum' : 10, 'text' : 'L7'},\n\t      \\ {'filename' : 'F7', 'lnum' : 11, 'text' : 'L11'}], ' ')\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call g:Xsetlist([{'filename' : 'F7', 'lnum' : 10, 'text' : 'L7'},\n\t      \\ {'filename' : 'F7', 'lnum' : 11, 'text' : 'L11'}], 'r')\n  call assert_equal(2, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  call writefile([\"F8:80:L80\", \"F8:81:L81\"], \"Xone\")\n  Xfile Xone\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n  Xaddfile Xone\n  call assert_equal(2, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  \" Test case for updating a non-current quickfix list\n  call g:Xsetlist([], 'f')\n  Xexpr \"F1:1:L1\"\n  Xexpr \"F2:2:L2\"\n  call g:Xsetlist([], 'a', {'nr' : 1, \"lines\" : [\"F10:10:L10\"]})\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call assert_equal(2, g:Xgetlist({'nr' : 1, 'changedtick' : 0}).changedtick)\n\n  call delete(\"Xone\")\nendfunc\n\nfunc Test_qf_tick()\n  call Xqftick_tests('c')\n  call Xqftick_tests('l')\nendfunc\n\n\" Test helpgrep with lang specifier\nfunc Xtest_helpgrep_with_lang_specifier(cchar)\n  call s:setup_commands(a:cchar)\n  Xhelpgrep Vim@en\n  call assert_equal('help', &filetype)\n  call assert_notequal(0, g:Xgetlist({'nr' : '$'}).nr)\n  new | only\nendfunc\n\nfunc Test_helpgrep_with_lang_specifier()\n  call Xtest_helpgrep_with_lang_specifier('c')\n  call Xtest_helpgrep_with_lang_specifier('l')\nendfunc\n\n\" The following test used to crash Vim.\n\" Open the location list window and close the regular window associated with\n\" the location list. When the garbage collection runs now, it incorrectly\n\" marks the location list context as not in use and frees the context.\nfunc Test_ll_window_ctx()\n  call setloclist(0, [], 'f')\n  call setloclist(0, [], 'a', {'context' : []})\n  lopen | only\n  call test_garbagecollect_now()\n  echo getloclist(0, {'context' : 1}).context\n  enew | only\nendfunc\n\n\" The following test used to crash vim\nfunc Test_lfile_crash()\n  sp Xtest\n  au QuickFixCmdPre * bw\n  call assert_fails('lfile', 'E40:')\n  au! QuickFixCmdPre\nendfunc\n\n\" The following test used to crash vim\nfunc Test_lbuffer_crash()\n  sv Xtest\n  augroup QF_Test\n    au!\n    au QuickFixCmdPre,QuickFixCmdPost,BufEnter,BufLeave * bw\n  augroup END\n  lbuffer\n  augroup QF_Test\n    au!\n  augroup END\nendfunc\n\n\" The following test used to crash vim\nfunc Test_lexpr_crash()\n  augroup QF_Test\n    au!\n    au QuickFixCmdPre,QuickFixCmdPost,BufEnter,BufLeave * call setloclist(0, [], 'f')\n  augroup END\n  lexpr \"\"\n  augroup QF_Test\n    au!\n  augroup END\n\n  enew | only\n  augroup QF_Test\n    au!\n    au BufNew * call setloclist(0, [], 'f')\n  augroup END\n  lexpr 'x:1:x'\n  augroup QF_Test\n    au!\n  augroup END\n\n  enew | only\n  lexpr ''\n  lopen\n  augroup QF_Test\n    au!\n    au FileType * call setloclist(0, [], 'f')\n  augroup END\n  lexpr ''\n  augroup QF_Test\n    au!\n  augroup END\nendfunc\n\n\" The following test used to crash Vim\nfunc Test_lvimgrep_crash()\n  sv Xtest\n  augroup QF_Test\n    au!\n    au QuickFixCmdPre,QuickFixCmdPost,BufEnter,BufLeave * call setloclist(0, [], 'f')\n  augroup END\n  lvimgrep quickfix test_quickfix.vim\n  augroup QF_Test\n    au!\n  augroup END\n\n  new | only\n  augroup QF_Test\n    au!\n    au BufEnter * call setloclist(0, [], 'r')\n  augroup END\n  call assert_fails('lvimgrep Test_lvimgrep_crash *', 'E926:')\n  augroup QF_Test\n    au!\n  augroup END\n\n  enew | only\nendfunc\n\nfunc Test_lvimgrep_crash2()\n  au BufNewFile x sfind\n  call assert_fails('lvimgrep x x', 'E471:')\n  call assert_fails('lvimgrep x x x', 'E471:')\n\n  au! BufNewFile\nendfunc\n\n\" Test for the position of the quickfix and location list window\nfunc Test_qfwin_pos()\n  \" Open two windows\n  new | only\n  new\n  cexpr ['F1:10:L10']\n  copen\n  \" Quickfix window should be the bottom most window\n  call assert_equal(3, winnr())\n  close\n  \" Open at the very top\n  wincmd t\n  topleft copen\n  call assert_equal(1, winnr())\n  close\n  \" open left of the current window\n  wincmd t\n  below new\n  leftabove copen\n  call assert_equal(2, winnr())\n  close\n  \" open right of the current window\n  rightbelow copen\n  call assert_equal(3, winnr())\n  close\nendfunc\n\n\" Tests for quickfix/location lists changed by autocommands when\n\" :vimgrep/:lvimgrep commands are running.\nfunc Test_vimgrep_autocmd()\n  call setqflist([], 'f')\n  call writefile(['stars'], 'Xtest1.txt')\n  call writefile(['stars'], 'Xtest2.txt')\n\n  \" Test 1:\n  \" When searching for a pattern using :vimgrep, if the quickfix list is\n  \" changed by an autocmd, the results should be added to the correct quickfix\n  \" list.\n  autocmd BufRead Xtest2.txt cexpr '' | cexpr ''\n  silent vimgrep stars Xtest*.txt\n  call assert_equal(1, getqflist({'nr' : 0}).nr)\n  call assert_equal(3, getqflist({'nr' : '$'}).nr)\n  call assert_equal('Xtest2.txt', bufname(getqflist()[1].bufnr))\n  au! BufRead Xtest2.txt\n\n  \" Test 2:\n  \" When searching for a pattern using :vimgrep, if the quickfix list is\n  \" freed, then a error should be given.\n  silent! %bwipe!\n  call setqflist([], 'f')\n  autocmd BufRead Xtest2.txt for i in range(10) | cexpr '' | endfor\n  call assert_fails('vimgrep stars Xtest*.txt', 'E925:')\n  au! BufRead Xtest2.txt\n\n  \" Test 3:\n  \" When searching for a pattern using :lvimgrep, if the location list is\n  \" freed, then the command should error out.\n  silent! %bwipe!\n  let g:save_winid = win_getid()\n  autocmd BufRead Xtest2.txt call setloclist(g:save_winid, [], 'f')\n  call assert_fails('lvimgrep stars Xtest*.txt', 'E926:')\n  au! BufRead Xtest2.txt\n\n  call delete('Xtest1.txt')\n  call delete('Xtest2.txt')\n  call setqflist([], 'f')\nendfunc\n\n\" Test for an autocmd changing the current directory when running vimgrep\nfunc Xvimgrep_autocmd_cd(cchar)\n  call s:setup_commands(a:cchar)\n\n  %bwipe\n  let save_cwd = getcwd()\n\n  augroup QF_Test\n    au!\n    autocmd BufRead * silent cd %:p:h\n  augroup END\n\n  10Xvimgrep /vim/ Xdir/**\n  let l = g:Xgetlist()\n  call assert_equal('f1.txt', bufname(l[0].bufnr))\n  call assert_equal('f2.txt', fnamemodify(bufname(l[2].bufnr), ':t'))\n\n  augroup QF_Test\n    au!\n  augroup END\n\n  exe 'cd ' . save_cwd\nendfunc\n\nfunc Test_vimgrep_autocmd_cd()\n  call mkdir('Xdir/a', 'p')\n  call mkdir('Xdir/b', 'p')\n  call writefile(['a_L1_vim', 'a_L2_vim'], 'Xdir/a/f1.txt')\n  call writefile(['b_L1_vim', 'b_L2_vim'], 'Xdir/b/f2.txt')\n  call Xvimgrep_autocmd_cd('c')\n  call Xvimgrep_autocmd_cd('l')\n  %bwipe\n  call delete('Xdir', 'rf')\nendfunc\n\n\" The following test used to crash Vim\nfunc Test_lhelpgrep_autocmd()\n  lhelpgrep quickfix\n  augroup QF_Test\n    au!\n    autocmd QuickFixCmdPost * call setloclist(0, [], 'f')\n  augroup END\n  lhelpgrep buffer\n  call assert_equal('help', &filetype)\n  call assert_equal(0, getloclist(0, {'nr' : '$'}).nr)\n  lhelpgrep tabpage\n  call assert_equal('help', &filetype)\n  call assert_equal(1, getloclist(0, {'nr' : '$'}).nr)\n  augroup QF_Test\n    au!\n  augroup END\n\n  new | only\n  augroup QF_Test\n    au!\n    au BufEnter * call setqflist([], 'f')\n  augroup END\n  call assert_fails('helpgrep quickfix', 'E925:')\n  \" run the test with a help window already open\n  help\n  wincmd w\n  call assert_fails('helpgrep quickfix', 'E925:')\n  augroup QF_Test\n    au!\n  augroup END\n\n  new | only\n  augroup QF_Test\n    au!\n    au BufEnter * call setqflist([], 'r')\n  augroup END\n  call assert_fails('helpgrep quickfix', 'E925:')\n  augroup QF_Test\n    au!\n  augroup END\n\n  new | only\n  augroup QF_Test\n    au!\n    au BufEnter * call setloclist(0, [], 'r')\n  augroup END\n  call assert_fails('lhelpgrep quickfix', 'E926:')\n  augroup QF_Test\n    au!\n  augroup END\n\n  \" Replace the contents of a help window location list when it is still in\n  \" use.\n  new | only\n  lhelpgrep quickfix\n  wincmd w\n  augroup QF_Test\n    au!\n    autocmd WinEnter * call setloclist(0, [], 'r')\n  augroup END\n  call assert_fails('lhelpgrep win_getid', 'E926:')\n  augroup QF_Test\n    au!\n  augroup END\n\n  %bw!\nendfunc\n\n\" The following test used to crash Vim\nfunc Test_lhelpgrep_autocmd_free_loclist()\n  %bw!\n  lhelpgrep quickfix\n  wincmd w\n  augroup QF_Test\n    au!\n    autocmd WinEnter * call setloclist(0, [], 'f')\n  augroup END\n  lhelpgrep win_getid\n  wincmd w\n  wincmd w\n  wincmd w\n  augroup QF_Test\n    au!\n  augroup END\n  %bw!\nendfunc\n\n\" Test for shortening/simplifying the file name when opening the\n\" quickfix window or when displaying the quickfix list\nfunc Test_shorten_fname()\n  CheckUnix\n  %bwipe\n  \" Create a quickfix list with an absolute path filename\n  let fname = getcwd() . '/test_quickfix.vim'\n  call setqflist([], ' ', {'lines':[fname . \":20:Line20\"], 'efm':'%f:%l:%m'})\n  call assert_equal(fname, bufname('test_quickfix.vim'))\n  \" Opening the quickfix window should simplify the file path\n  cwindow\n  call assert_equal('test_quickfix.vim', bufname('test_quickfix.vim'))\n  cclose\n  %bwipe\n  \" Create a quickfix list with an absolute path filename\n  call setqflist([], ' ', {'lines':[fname . \":20:Line20\"], 'efm':'%f:%l:%m'})\n  call assert_equal(fname, bufname('test_quickfix.vim'))\n  \" Displaying the quickfix list should simplify the file path\n  silent! clist\n  call assert_equal('test_quickfix.vim', bufname('test_quickfix.vim'))\n  \" Add a few entries for the same file with different paths and check whether\n  \" the buffer name is shortened\n  %bwipe\n  call setqflist([], 'f')\n  call setqflist([{'filename' : 'test_quickfix.vim', 'lnum' : 10},\n        \\ {'filename' : '../testdir/test_quickfix.vim', 'lnum' : 20},\n        \\ {'filename' : fname, 'lnum' : 30}], ' ')\n  copen\n  call assert_equal(['test_quickfix.vim|10| ',\n        \\ 'test_quickfix.vim|20| ',\n        \\ 'test_quickfix.vim|30| '], getline(1, '$'))\n  cclose\nendfunc\n\n\" Quickfix title tests\n\" In the below tests, 'exe \"cmd\"' is used to invoke the quickfix commands.\n\" Otherwise due to indentation, the title is set with spaces at the beginning\n\" of the command.\nfunc Test_qftitle()\n  call writefile([\"F1:1:Line1\"], 'Xerr')\n\n  \" :cexpr\n  exe \"cexpr readfile('Xerr')\"\n  call assert_equal(\":cexpr readfile('Xerr')\", getqflist({'title' : 1}).title)\n\n  \" :cgetexpr\n  exe \"cgetexpr readfile('Xerr')\"\n  call assert_equal(\":cgetexpr readfile('Xerr')\",\n\t\t\t\t\t\\ getqflist({'title' : 1}).title)\n\n  \" :caddexpr\n  call setqflist([], 'f')\n  exe \"caddexpr readfile('Xerr')\"\n  call assert_equal(\":caddexpr readfile('Xerr')\",\n\t\t\t\t\t\\ getqflist({'title' : 1}).title)\n\n  \" :cbuffer\n  new Xerr\n  exe \"cbuffer\"\n  call assert_equal(':cbuffer (Xerr)', getqflist({'title' : 1}).title)\n\n  \" :cgetbuffer\n  edit Xerr\n  exe \"cgetbuffer\"\n  call assert_equal(':cgetbuffer (Xerr)', getqflist({'title' : 1}).title)\n\n  \" :caddbuffer\n  call setqflist([], 'f')\n  edit Xerr\n  exe \"caddbuffer\"\n  call assert_equal(':caddbuffer (Xerr)', getqflist({'title' : 1}).title)\n\n  \" :cfile\n  exe \"cfile Xerr\"\n  call assert_equal(':cfile Xerr', getqflist({'title' : 1}).title)\n\n  \" :cgetfile\n  exe \"cgetfile Xerr\"\n  call assert_equal(':cgetfile Xerr', getqflist({'title' : 1}).title)\n\n  \" :caddfile\n  call setqflist([], 'f')\n  exe \"caddfile Xerr\"\n  call assert_equal(':caddfile Xerr', getqflist({'title' : 1}).title)\n\n  \" :grep\n  set grepprg=internal\n  exe \"grep F1 Xerr\"\n  call assert_equal(':grep F1 Xerr', getqflist({'title' : 1}).title)\n\n  \" :grepadd\n  call setqflist([], 'f')\n  exe \"grepadd F1 Xerr\"\n  call assert_equal(':grepadd F1 Xerr', getqflist({'title' : 1}).title)\n  set grepprg&vim\n\n  \" :vimgrep\n  exe \"vimgrep F1 Xerr\"\n  call assert_equal(':vimgrep F1 Xerr', getqflist({'title' : 1}).title)\n\n  \" :vimgrepadd\n  call setqflist([], 'f')\n  exe \"vimgrepadd F1 Xerr\"\n  call assert_equal(':vimgrepadd F1 Xerr', getqflist({'title' : 1}).title)\n\n  call setqflist(['F1:10:L10'], ' ')\n  call assert_equal(':setqflist()', getqflist({'title' : 1}).title)\n\n  call setqflist([], 'f')\n  call setqflist(['F1:10:L10'], 'a')\n  call assert_equal(':setqflist()', getqflist({'title' : 1}).title)\n\n  call setqflist([], 'f')\n  call setqflist(['F1:10:L10'], 'r')\n  call assert_equal(':setqflist()', getqflist({'title' : 1}).title)\n\n  close\n  call delete('Xerr')\n\n  call setqflist([], ' ', {'title' : 'Errors'})\n  copen\n  call assert_equal('Errors', w:quickfix_title)\n  call setqflist([], 'r', {'items' : [{'filename' : 'a.c', 'lnum' : 10}]})\n  call assert_equal('Errors', w:quickfix_title)\n  cclose\n\n  \" Switching to another quickfix list in one tab page should update the\n  \" quickfix window title and statusline in all the other tab pages also\n  call setqflist([], 'f')\n  %bw!\n  cgetexpr ['file_one:1:1: error in the first quickfix list']\n  call setqflist([], 'a', {'title': 'first quickfix list'})\n  cgetexpr ['file_two:2:1: error in the second quickfix list']\n  call setqflist([], 'a', {'title': 'second quickfix list'})\n  copen\n  wincmd t\n  tabnew two\n  copen\n  wincmd t\n  colder\n  call assert_equal('first quickfix list', gettabwinvar(1, 2, 'quickfix_title'))\n  call assert_equal('first quickfix list', gettabwinvar(2, 2, 'quickfix_title'))\n  call assert_equal(1, tabpagewinnr(1))\n  call assert_equal(1, tabpagewinnr(2))\n  tabnew\n  call setqflist([], 'a', {'title': 'new quickfix title'})\n  call assert_equal('new quickfix title', gettabwinvar(1, 2, 'quickfix_title'))\n  call assert_equal('new quickfix title', gettabwinvar(2, 2, 'quickfix_title'))\n  %bw!\nendfunc\n\nfunc Test_lbuffer_with_bwipe()\n  new\n  new\n  augroup nasty\n    au QuickFixCmdPre,QuickFixCmdPost,BufEnter,BufLeave * bwipe\n  augroup END\n  lbuffer\n  augroup nasty\n    au!\n  augroup END\nendfunc\n\n\" Test for an autocmd freeing the quickfix/location list when cexpr/lexpr is\n\" running\nfunc Xexpr_acmd_freelist(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" This was using freed memory (but with what events?)\n  augroup nasty\n    au QuickFixCmdPre,QuickFixCmdPost,BufEnter,BufLeave * call g:Xsetlist([], 'f')\n  augroup END\n  Xexpr \"x\"\n  augroup nasty\n    au!\n  augroup END\nendfunc\n\nfunc Test_cexpr_acmd_freelist()\n  call Xexpr_acmd_freelist('c')\n  call Xexpr_acmd_freelist('l')\nendfunc\n\n\" Test for commands that create a new quickfix/location list and jump to the\n\" first error automatically.\nfunc Xjumpto_first_error_test(cchar)\n  call s:setup_commands(a:cchar)\n\n  call s:create_test_file('Xtestfile1')\n  call s:create_test_file('Xtestfile2')\n  let l = ['Xtestfile1:2:Line2', 'Xtestfile2:4:Line4']\n\n  \" Test for cexpr/lexpr\n  enew\n  Xexpr l\n  call assert_equal('Xtestfile1', @%)\n  call assert_equal(2, line('.'))\n\n  \" Test for cfile/lfile\n  enew\n  call writefile(l, 'Xerr')\n  Xfile Xerr\n  call assert_equal('Xtestfile1', @%)\n  call assert_equal(2, line('.'))\n\n  \" Test for cbuffer/lbuffer\n  edit Xerr\n  Xbuffer\n  call assert_equal('Xtestfile1', @%)\n  call assert_equal(2, line('.'))\n\n  call delete('Xerr')\n  call delete('Xtestfile1')\n  call delete('Xtestfile2')\nendfunc\n\nfunc Test_jumpto_first_error()\n  call Xjumpto_first_error_test('c')\n  call Xjumpto_first_error_test('l')\nendfunc\n\n\" Test for a quickfix autocmd changing the quickfix/location list before\n\" jumping to the first error in the new list.\nfunc Xautocmd_changelist(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Test for cfile/lfile\n  call s:create_test_file('Xtestfile1')\n  call s:create_test_file('Xtestfile2')\n  Xexpr 'Xtestfile1:2:Line2'\n  autocmd QuickFixCmdPost * Xolder\n  call writefile(['Xtestfile2:4:Line4'], 'Xerr')\n  Xfile Xerr\n  call assert_equal('Xtestfile2', @%)\n  call assert_equal(4, line('.'))\n  autocmd! QuickFixCmdPost\n\n  \" Test for cbuffer/lbuffer\n  call g:Xsetlist([], 'f')\n  Xexpr 'Xtestfile1:2:Line2'\n  autocmd QuickFixCmdPost * Xolder\n  call writefile(['Xtestfile2:4:Line4'], 'Xerr')\n  edit Xerr\n  Xbuffer\n  call assert_equal('Xtestfile2', @%)\n  call assert_equal(4, line('.'))\n  autocmd! QuickFixCmdPost\n\n  \" Test for cexpr/lexpr\n  call g:Xsetlist([], 'f')\n  Xexpr 'Xtestfile1:2:Line2'\n  autocmd QuickFixCmdPost * Xolder\n  Xexpr 'Xtestfile2:4:Line4'\n  call assert_equal('Xtestfile2', @%)\n  call assert_equal(4, line('.'))\n  autocmd! QuickFixCmdPost\n\n  \" The grepprg may not be set on non-Unix systems\n  if has('unix')\n    \" Test for grep/lgrep\n    call g:Xsetlist([], 'f')\n    Xexpr 'Xtestfile1:2:Line2'\n    autocmd QuickFixCmdPost * Xolder\n    silent Xgrep Line5 Xtestfile2\n    call assert_equal('Xtestfile2', @%)\n    call assert_equal(5, line('.'))\n    autocmd! QuickFixCmdPost\n  endif\n\n  \" Test for vimgrep/lvimgrep\n  call g:Xsetlist([], 'f')\n  Xexpr 'Xtestfile1:2:Line2'\n  autocmd QuickFixCmdPost * Xolder\n  silent Xvimgrep Line5 Xtestfile2\n  call assert_equal('Xtestfile2', @%)\n  call assert_equal(5, line('.'))\n  autocmd! QuickFixCmdPost\n\n  \" Test for autocommands clearing the quickfix list before jumping to the\n  \" first error. This should not result in an error\n  autocmd QuickFixCmdPost * call g:Xsetlist([], 'r')\n  let v:errmsg = ''\n  \" Test for cfile/lfile\n  Xfile Xerr\n  call assert_true(v:errmsg !~# 'E42:')\n  \" Test for cbuffer/lbuffer\n  edit Xerr\n  Xbuffer\n  call assert_true(v:errmsg !~# 'E42:')\n  \" Test for cexpr/lexpr\n  Xexpr 'Xtestfile2:4:Line4'\n  call assert_true(v:errmsg !~# 'E42:')\n  \" Test for grep/lgrep\n  \" The grepprg may not be set on non-Unix systems\n  if has('unix')\n    silent Xgrep Line5 Xtestfile2\n    call assert_true(v:errmsg !~# 'E42:')\n  endif\n  \" Test for vimgrep/lvimgrep\n  call assert_fails('silent Xvimgrep Line5 Xtestfile2', 'E480:')\n  autocmd! QuickFixCmdPost\n\n  call delete('Xerr')\n  call delete('Xtestfile1')\n  call delete('Xtestfile2')\nendfunc\n\nfunc Test_autocmd_changelist()\n  call Xautocmd_changelist('c')\n  call Xautocmd_changelist('l')\nendfunc\n\n\" Tests for the ':filter /pat/ clist' command\nfunc Test_filter_clist()\n  cexpr ['Xfile1:10:10:Line 10', 'Xfile2:15:15:Line 15']\n  call assert_equal([' 2 Xfile2:15 col 15: Line 15'],\n\t\t\t\\ split(execute('filter /Line 15/ clist'), \"\\n\"))\n  call assert_equal([' 1 Xfile1:10 col 10: Line 10'],\n\t\t\t\\ split(execute('filter /Xfile1/ clist'), \"\\n\"))\n  call assert_equal([], split(execute('filter /abc/ clist'), \"\\n\"))\n\n  call setqflist([{'module' : 'abc', 'pattern' : 'pat1'},\n\t\t\t\\ {'module' : 'pqr', 'pattern' : 'pat2'}], ' ')\n  call assert_equal([' 2 pqr:pat2:  '],\n\t\t\t\\ split(execute('filter /pqr/ clist'), \"\\n\"))\n  call assert_equal([' 1 abc:pat1:  '],\n\t\t\t\\ split(execute('filter /pat1/ clist'), \"\\n\"))\nendfunc\n\n\" Tests for the \"CTRL-W <CR>\" command.\nfunc Xview_result_split_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Test that \"CTRL-W <CR>\" in a qf/ll window fails with empty list.\n  call g:Xsetlist([])\n  Xopen\n  let l:win_count = winnr('$')\n  call assert_fails('execute \"normal! \\<C-W>\\<CR>\"', 'E42:')\n  call assert_equal(l:win_count, winnr('$'))\n  Xclose\nendfunc\n\nfunc Test_view_result_split()\n  call Xview_result_split_tests('c')\n  call Xview_result_split_tests('l')\nendfunc\n\n\" Test that :cc sets curswant\nfunc Test_curswant()\n  helpgrep quickfix\n  normal! llll\n  1cc\n  call assert_equal(getcurpos()[4], virtcol('.'))\n  cclose | helpclose\nendfunc\n\n\" Test for opening a file from the quickfix window using CTRL-W <Enter>\n\" doesn't leave an empty buffer around.\nfunc Test_splitview()\n  call s:create_test_file('Xtestfile1')\n  call s:create_test_file('Xtestfile2')\n  new | only\n  let last_bufnr = bufnr('Test_sv_1', 1)\n  let l = ['Xtestfile1:2:Line2', 'Xtestfile2:4:Line4']\n  cgetexpr l\n  copen\n  let numbufs = len(getbufinfo())\n  exe \"normal \\<C-W>\\<CR>\"\n  copen\n  exe \"normal j\\<C-W>\\<CR>\"\n  \" Make sure new empty buffers are not created\n  call assert_equal(numbufs, len(getbufinfo()))\n  \" Creating a new buffer should use the next available buffer number\n  call assert_equal(last_bufnr + 4, bufnr(\"Test_sv_2\", 1))\n  bwipe Test_sv_1\n  bwipe Test_sv_2\n  new | only\n\n  \" When split opening files from location list window, make sure that two\n  \" windows doesn't refer to the same location list\n  lgetexpr l\n  let locid = getloclist(0, {'id' : 0}).id\n  lopen\n  exe \"normal \\<C-W>\\<CR>\"\n  call assert_notequal(locid, getloclist(0, {'id' : 0}).id)\n  call assert_equal(0, getloclist(0, {'winid' : 0}).winid)\n  new | only\n\n  \" When split opening files from a helpgrep location list window, a new help\n  \" window should be opened with a copy of the location list.\n  lhelpgrep window\n  let locid = getloclist(0, {'id' : 0}).id\n  lwindow\n  exe \"normal j\\<C-W>\\<CR>\"\n  call assert_notequal(locid, getloclist(0, {'id' : 0}).id)\n  call assert_equal(0, getloclist(0, {'winid' : 0}).winid)\n  new | only\n\n  \" Using :split or :vsplit from a quickfix window should behave like a :new\n  \" or a :vnew command\n  copen\n  split\n  call assert_equal(3, winnr('$'))\n  let l = getwininfo()\n  call assert_equal([0, 0, 1], [l[0].quickfix, l[1].quickfix, l[2].quickfix])\n  close\n  copen\n  vsplit\n  let l = getwininfo()\n  call assert_equal([0, 0, 1], [l[0].quickfix, l[1].quickfix, l[2].quickfix])\n  new | only\n\n  call delete('Xtestfile1')\n  call delete('Xtestfile2')\nendfunc\n\n\" Test for parsing entries using visual screen column\nfunc Test_viscol()\n  enew\n  call writefile([\"Col1\\tCol2\\tCol3\"], 'Xfile1')\n  edit Xfile1\n\n  \" Use byte offset for column number\n  set efm&\n  cexpr \"Xfile1:1:5:XX\\nXfile1:1:9:YY\\nXfile1:1:20:ZZ\"\n  call assert_equal([5, 8], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([9, 12], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([14, 20], [col('.'), virtcol('.')])\n\n  \" Use screen column offset for column number\n  set efm=%f:%l:%v:%m\n  cexpr \"Xfile1:1:8:XX\\nXfile1:1:12:YY\\nXfile1:1:20:ZZ\"\n  call assert_equal([5, 8], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([9, 12], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([14, 20], [col('.'), virtcol('.')])\n  cexpr \"Xfile1:1:6:XX\\nXfile1:1:15:YY\\nXfile1:1:24:ZZ\"\n  call assert_equal([5, 8], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([10, 16], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([14, 20], [col('.'), virtcol('.')])\n\n  enew\n  call writefile([\"Col1\\t\u00e4\u00fc\\t\u00f6\u00df\\tCol4\"], 'Xfile1')\n\n  \" Use byte offset for column number\n  set efm&\n  cexpr \"Xfile1:1:8:XX\\nXfile1:1:11:YY\\nXfile1:1:16:ZZ\"\n  call assert_equal([8, 10], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([11, 17], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([16, 25], [col('.'), virtcol('.')])\n\n  \" Use screen column offset for column number\n  set efm=%f:%l:%v:%m\n  cexpr \"Xfile1:1:10:XX\\nXfile1:1:17:YY\\nXfile1:1:25:ZZ\"\n  call assert_equal([8, 10], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([11, 17], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([16, 25], [col('.'), virtcol('.')])\n\n  \" Use screen column number with a multi-line error message\n  enew\n  call writefile([\"\u00e0 test\"], 'Xfile1')\n  set efm=%E===\\ %f\\ ===,%C%l:%v,%Z%m\n  cexpr [\"=== Xfile1 ===\", \"1:3\", \"errormsg\"]\n  call assert_equal('Xfile1', @%)\n  call assert_equal([0, 1, 4, 0], getpos('.'))\n\n  \" Repeat previous test with byte offset %c: ensure that fix to issue #7145\n  \" does not break this\n  set efm=%E===\\ %f\\ ===,%C%l:%c,%Z%m\n  cexpr [\"=== Xfile1 ===\", \"1:3\", \"errormsg\"]\n  call assert_equal('Xfile1', @%)\n  call assert_equal([0, 1, 3, 0], getpos('.'))\n\n  enew | only\n  set efm&\n  call delete('Xfile1')\nendfunc\n\n\" Test for the quickfix window buffer\nfunc Xqfbuf_test(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Quickfix buffer should be reused across closing and opening a quickfix\n  \" window\n  Xexpr \"F1:10:Line10\"\n  Xopen\n  let qfbnum = bufnr('')\n  Xclose\n  \" Even after the quickfix window is closed, the buffer should be loaded\n  call assert_true(bufloaded(qfbnum))\n  call assert_true(qfbnum, g:Xgetlist({'qfbufnr' : 0}).qfbufnr)\n  Xopen\n  \" Buffer should be reused when opening the window again\n  call assert_equal(qfbnum, bufnr(''))\n  Xclose\n\n  \" When quickfix buffer is wiped out, getqflist() should return 0\n  %bw!\n  Xexpr \"\"\n  Xopen\n  bw!\n  call assert_equal(0, g:Xgetlist({'qfbufnr': 0}).qfbufnr)\n\n  if a:cchar == 'l'\n    %bwipe\n    \" For a location list, when both the file window and the location list\n    \" window for the list are closed, then the buffer should be freed.\n    new | only\n    lexpr \"F1:10:Line10\"\n    let wid = win_getid()\n    lopen\n    let qfbnum = bufnr('')\n    call assert_match(qfbnum . ' %a-  \"\\[Location List]\"', execute('ls'))\n    close\n    \" When the location list window is closed, the buffer name should not\n    \" change to 'Quickfix List'\n    call assert_match(qfbnum . 'u h-  \"\\[Location List]\"', execute('ls!'))\n    call assert_true(bufloaded(qfbnum))\n\n    \" After deleting a location list buffer using \":bdelete\", opening the\n    \" location list window should mark the buffer as a location list buffer.\n    exe \"bdelete \" . qfbnum\n    lopen\n    call assert_equal(\"quickfix\", &buftype)\n    call assert_equal(1, getwininfo(win_getid(winnr()))[0].loclist)\n    call assert_equal(wid, getloclist(0, {'filewinid' : 0}).filewinid)\n    call assert_false(&swapfile)\n    lclose\n\n    \" When the location list is cleared for the window, the buffer should be\n    \" removed\n    call setloclist(0, [], 'f')\n    call assert_false(bufexists(qfbnum))\n    call assert_equal(0, getloclist(0, {'qfbufnr' : 0}).qfbufnr)\n\n    \" When the location list is freed with the location list window open, the\n    \" location list buffer should not be lost. It should be reused when the\n    \" location list is again populated.\n    lexpr \"F1:10:Line10\"\n    lopen\n    let wid = win_getid()\n    let qfbnum = bufnr('')\n    wincmd p\n    call setloclist(0, [], 'f')\n    lexpr \"F1:10:Line10\"\n    lopen\n    call assert_equal(wid, win_getid())\n    call assert_equal(qfbnum, bufnr(''))\n    lclose\n\n    \" When the window with the location list is closed, the buffer should be\n    \" removed\n    new | only\n    call assert_false(bufexists(qfbnum))\n  endif\nendfunc\n\nfunc Test_qfbuf()\n  call Xqfbuf_test('c')\n  call Xqfbuf_test('l')\nendfunc\n\n\" If there is an autocmd to use only one window, then opening the location\n\" list window used to crash Vim.\nfunc Test_winonly_autocmd()\n  call s:create_test_file('Xtest1')\n  \" Autocmd to show only one Vim window at a time\n  autocmd WinEnter * only\n  new\n  \" Load the location list\n  lexpr \"Xtest1:5:Line5\\nXtest1:10:Line10\\nXtest1:15:Line15\"\n  let loclistid = getloclist(0, {'id' : 0}).id\n  \" Open the location list window. Only this window will be shown and the file\n  \" window is closed.\n  lopen\n  call assert_equal(loclistid, getloclist(0, {'id' : 0}).id)\n  \" Jump to an entry in the location list and make sure that the cursor is\n  \" positioned correctly.\n  ll 3\n  call assert_equal(loclistid, getloclist(0, {'id' : 0}).id)\n  call assert_equal('Xtest1', @%)\n  call assert_equal(15, line('.'))\n  \" Cleanup\n  autocmd! WinEnter\n  new | only\n  call delete('Xtest1')\nendfunc\n\n\" Test to make sure that an empty quickfix buffer is not reused for loading\n\" a normal buffer.\nfunc Test_empty_qfbuf()\n  enew | only\n  call writefile([\"Test\"], 'Xfile1')\n  call setqflist([], 'f')\n  copen | only\n  let qfbuf = bufnr('')\n  edit Xfile1\n  call assert_notequal(qfbuf, bufnr(''))\n  enew\n  call delete('Xfile1')\nendfunc\n\n\" Test for the :cbelow, :cabove, :lbelow and :labove commands.\n\" And for the :cafter, :cbefore, :lafter and :lbefore commands.\nfunc Xtest_below(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" No quickfix/location list\n  call assert_fails('Xbelow', 'E42:')\n  call assert_fails('Xabove', 'E42:')\n  call assert_fails('Xbefore', 'E42:')\n  call assert_fails('Xafter', 'E42:')\n\n  \" Empty quickfix/location list\n  call g:Xsetlist([])\n  call assert_fails('Xbelow', 'E42:')\n  call assert_fails('Xabove', 'E42:')\n  call assert_fails('Xbefore', 'E42:')\n  call assert_fails('Xafter', 'E42:')\n\n  call s:create_test_file('X1')\n  call s:create_test_file('X2')\n  call s:create_test_file('X3')\n  call s:create_test_file('X4')\n\n  \" Invalid entries\n  edit X1\n  call g:Xsetlist([\"E1\", \"E2\"])\n  call assert_fails('Xbelow', 'E42:')\n  call assert_fails('Xabove', 'E42:')\n  call assert_fails('3Xbelow', 'E42:')\n  call assert_fails('4Xabove', 'E42:')\n  call assert_fails('Xbefore', 'E42:')\n  call assert_fails('Xafter', 'E42:')\n  call assert_fails('3Xbefore', 'E42:')\n  call assert_fails('4Xafter', 'E42:')\n\n  \" Test the commands with various arguments\n  Xexpr [\"X1:5:3:L5\", \"X2:5:2:L5\", \"X2:10:3:L10\", \"X2:15:4:L15\", \"X3:3:5:L3\"]\n  edit +7 X2\n  Xabove\n  call assert_equal(['X2', 5], [@%, line('.')])\n  call assert_fails('Xabove', 'E553:')\n  normal 7G\n  Xbefore\n  call assert_equal(['X2', 5, 2], [@%, line('.'), col('.')])\n  call assert_fails('Xbefore', 'E553:')\n\n  normal 2j\n  Xbelow\n  call assert_equal(['X2', 10], [@%, line('.')])\n  normal 7G\n  Xafter\n  call assert_equal(['X2', 10, 3], [@%, line('.'), col('.')])\n\n  \" Last error in this file\n  Xbelow 99\n  call assert_equal(['X2', 15], [@%, line('.')])\n  call assert_fails('Xbelow', 'E553:')\n  normal gg\n  Xafter 99\n  call assert_equal(['X2', 15, 4], [@%, line('.'), col('.')])\n  call assert_fails('Xafter', 'E553:')\n\n  \" First error in this file\n  Xabove 99\n  call assert_equal(['X2', 5], [@%, line('.')])\n  call assert_fails('Xabove', 'E553:')\n  normal G\n  Xbefore 99\n  call assert_equal(['X2', 5, 2], [@%, line('.'), col('.')])\n  call assert_fails('Xbefore', 'E553:')\n\n  normal gg\n  Xbelow 2\n  call assert_equal(['X2', 10], [@%, line('.')])\n  normal gg\n  Xafter 2\n  call assert_equal(['X2', 10, 3], [@%, line('.'), col('.')])\n\n  normal G\n  Xabove 2\n  call assert_equal(['X2', 10], [@%, line('.')])\n  normal G\n  Xbefore 2\n  call assert_equal(['X2', 10, 3], [@%, line('.'), col('.')])\n\n  edit X4\n  call assert_fails('Xabove', 'E42:')\n  call assert_fails('Xbelow', 'E42:')\n  call assert_fails('Xbefore', 'E42:')\n  call assert_fails('Xafter', 'E42:')\n  if a:cchar == 'l'\n    \" If a buffer has location list entries from some other window but not\n    \" from the current window, then the commands should fail.\n    edit X1 | split | call setloclist(0, [], 'f')\n    call assert_fails('Xabove', 'E776:')\n    call assert_fails('Xbelow', 'E776:')\n    call assert_fails('Xbefore', 'E776:')\n    call assert_fails('Xafter', 'E776:')\n    close\n  endif\n\n  \" Test for lines with multiple quickfix entries\n  let lines =<< trim END\n    X1:5:L5\n    X2:5:1:L5_1\n    X2:5:2:L5_2\n    X2:5:3:L5_3\n    X2:10:1:L10_1\n    X2:10:2:L10_2\n    X2:10:3:L10_3\n    X2:15:1:L15_1\n    X2:15:2:L15_2\n    X2:15:3:L15_3\n    X3:3:L3\n  END\n  Xexpr lines\n  edit +1 X2\n  Xbelow 2\n  call assert_equal(['X2', 10, 1], [@%, line('.'), col('.')])\n  normal 1G\n  Xafter 2\n  call assert_equal(['X2', 5, 2], [@%, line('.'), col('.')])\n\n  normal gg\n  Xbelow 99\n  call assert_equal(['X2', 15, 1], [@%, line('.'), col('.')])\n  normal gg\n  Xafter 99\n  call assert_equal(['X2', 15, 3], [@%, line('.'), col('.')])\n\n  normal G\n  Xabove 2\n  call assert_equal(['X2', 10, 1], [@%, line('.'), col('.')])\n  normal G\n  Xbefore 2\n  call assert_equal(['X2', 15, 2], [@%, line('.'), col('.')])\n\n  normal G\n  Xabove 99\n  call assert_equal(['X2', 5, 1], [@%, line('.'), col('.')])\n  normal G\n  Xbefore 99\n  call assert_equal(['X2', 5, 1], [@%, line('.'), col('.')])\n\n  normal 10G\n  Xabove\n  call assert_equal(['X2', 5, 1], [@%, line('.'), col('.')])\n  normal 10G$\n  2Xbefore\n  call assert_equal(['X2', 10, 2], [@%, line('.'), col('.')])\n\n  normal 10G\n  Xbelow\n  call assert_equal(['X2', 15, 1], [@%, line('.'), col('.')])\n  normal 9G\n  5Xafter\n  call assert_equal(['X2', 15, 2], [@%, line('.'), col('.')])\n\n  \" Invalid range\n  if a:cchar == 'c'\n    call assert_fails('-2cbelow', 'E16:')\n    call assert_fails('-2cafter', 'E16:')\n  else\n    call assert_fails('-2lbelow', 'E16:')\n    call assert_fails('-2lafter', 'E16:')\n  endif\n\n  call delete('X1')\n  call delete('X2')\n  call delete('X3')\n  call delete('X4')\nendfunc\n\nfunc Test_cbelow()\n  call Xtest_below('c')\n  call Xtest_below('l')\nendfunc\n\nfunc Test_quickfix_count()\n  let commands =<< trim END\n    cNext\n    cNfile\n    cabove\n    cbelow\n    cfirst\n    clast\n    cnewer\n    cnext\n    cnfile\n    colder\n    cprevious\n    crewind\n    lNext\n    lNfile\n    labove\n    lbelow\n    lfirst\n    llast\n    lnewer\n    lnext\n    lnfile\n    lolder\n    lprevious\n    lrewind\n  END\n  for cmd in commands\n    call assert_fails('-1' .. cmd, 'E16:')\n    call assert_fails('.' .. cmd, 'E16:')\n    call assert_fails('%' .. cmd, 'E16:')\n    call assert_fails('$' .. cmd, 'E16:')\n  endfor\nendfunc\n\n\" Test for aborting quickfix commands using QuickFixCmdPre\nfunc Xtest_qfcmd_abort(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n\n  \" cexpr/lexpr\n  let e = ''\n  try\n    Xexpr [\"F1:10:Line10\", \"F2:20:Line20\"]\n  catch /.*/\n    let e = v:exception\n  endtry\n  call assert_equal('AbortCmd', e)\n  call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\n\n  \" cfile/lfile\n  call writefile([\"F1:10:Line10\", \"F2:20:Line20\"], 'Xfile1')\n  let e = ''\n  try\n    Xfile Xfile1\n  catch /.*/\n    let e = v:exception\n  endtry\n  call assert_equal('AbortCmd', e)\n  call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\n  call delete('Xfile1')\n\n  \" cgetbuffer/lgetbuffer\n  enew!\n  call append(0, [\"F1:10:Line10\", \"F2:20:Line20\"])\n  let e = ''\n  try\n    Xgetbuffer\n  catch /.*/\n    let e = v:exception\n  endtry\n  call assert_equal('AbortCmd', e)\n  call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\n  enew!\n\n  \" vimgrep/lvimgrep\n  let e = ''\n  try\n    Xvimgrep /func/ test_quickfix.vim\n  catch /.*/\n    let e = v:exception\n  endtry\n  call assert_equal('AbortCmd', e)\n  call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\n\n  \" helpgrep/lhelpgrep\n  let e = ''\n  try\n    Xhelpgrep quickfix\n  catch /.*/\n    let e = v:exception\n  endtry\n  call assert_equal('AbortCmd', e)\n  call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\n\n  \" grep/lgrep\n  if has('unix')\n    let e = ''\n    try\n      silent Xgrep func test_quickfix.vim\n    catch /.*/\n      let e = v:exception\n    endtry\n    call assert_equal('AbortCmd', e)\n    call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\n  endif\nendfunc\n\nfunc Test_qfcmd_abort()\n  augroup QF_Test\n    au!\n    autocmd  QuickFixCmdPre * throw \"AbortCmd\"\n  augroup END\n\n  call Xtest_qfcmd_abort('c')\n  call Xtest_qfcmd_abort('l')\n\n  augroup QF_Test\n    au!\n  augroup END\nendfunc\n\n\" Test for using a file in one of the parent directories.\nfunc Test_search_in_dirstack()\n  call mkdir('Xtestdir/a/b/c', 'p')\n  let save_cwd = getcwd()\n  call writefile([\"X1_L1\", \"X1_L2\"], 'Xtestdir/Xfile1')\n  call writefile([\"X2_L1\", \"X2_L2\"], 'Xtestdir/a/Xfile2')\n  call writefile([\"X3_L1\", \"X3_L2\"], 'Xtestdir/a/b/Xfile3')\n  call writefile([\"X4_L1\", \"X4_L2\"], 'Xtestdir/a/b/c/Xfile4')\n\n  let lines = \"Entering dir Xtestdir\\n\" .\n\t      \\ \"Entering dir a\\n\" .\n\t      \\ \"Entering dir b\\n\" .\n\t      \\ \"Xfile2:2:X2_L2\\n\" .\n\t      \\ \"Leaving dir a\\n\" .\n\t      \\ \"Xfile1:2:X1_L2\\n\" .\n\t      \\ \"Xfile3:1:X3_L1\\n\" .\n\t      \\ \"Entering dir c\\n\" .\n\t      \\ \"Xfile4:2:X4_L2\\n\" .\n\t      \\ \"Leaving dir c\\n\"\n  set efm=%DEntering\\ dir\\ %f,%XLeaving\\ dir\\ %f,%f:%l:%m\n  cexpr lines .. \"Leaving dir Xtestdir|\\n\" | let next = 1\n  call assert_equal(11, getqflist({'size' : 0}).size)\n  call assert_equal(4, getqflist({'idx' : 0}).idx)\n  call assert_equal('X2_L2', getline('.'))\n  call assert_equal(1, next)\n  cnext\n  call assert_equal(6, getqflist({'idx' : 0}).idx)\n  call assert_equal('X1_L2', getline('.'))\n  cnext\n  call assert_equal(7, getqflist({'idx' : 0}).idx)\n  call assert_equal(1, line('$'))\n  call assert_equal('', getline(1))\n  cnext\n  call assert_equal(9, getqflist({'idx' : 0}).idx)\n  call assert_equal(1, line('$'))\n  call assert_equal('', getline(1))\n\n  set efm&\n  exe 'cd ' . save_cwd\n  call delete('Xtestdir', 'rf')\nendfunc\n\n\" Test for :cquit\nfunc Test_cquit()\n  \" Exit Vim with a non-zero value\n  if RunVim([], [\"cquit 7\"], '')\n    call assert_equal(7, v:shell_error)\n  endif\n\n  if RunVim([], [\"50cquit\"], '')\n    call assert_equal(50, v:shell_error)\n  endif\n\n  \" Exit Vim with default value\n  if RunVim([], [\"cquit\"], '')\n    call assert_equal(1, v:shell_error)\n  endif\n\n  \" Exit Vim with zero value\n  if RunVim([], [\"cquit 0\"], '')\n    call assert_equal(0, v:shell_error)\n  endif\n\n  \" Exit Vim with negative value\n  call assert_fails('-3cquit', 'E16:')\nendfunc\n\n\" Test for getting a specific item from a quickfix list\nfunc Xtest_getqflist_by_idx(cchar)\n  call s:setup_commands(a:cchar)\n  \" Empty list\n  call assert_equal([], g:Xgetlist({'idx' : 1, 'items' : 0}).items)\n  Xexpr ['F1:10:L10', 'F1:20:L20']\n  let l = g:Xgetlist({'idx' : 2, 'items' : 0}).items\n  call assert_equal(bufnr('F1'), l[0].bufnr)\n  call assert_equal(20, l[0].lnum)\n  call assert_equal('L20', l[0].text)\n  call assert_equal([], g:Xgetlist({'idx' : -1, 'items' : 0}).items)\n  call assert_equal([], g:Xgetlist({'idx' : 3, 'items' : 0}).items)\n  call assert_equal({}, g:Xgetlist(#{idx: \"abc\"}))\n  %bwipe!\nendfunc\n\nfunc Test_getqflist_by_idx()\n  call Xtest_getqflist_by_idx('c')\n  call Xtest_getqflist_by_idx('l')\nendfunc\n\n\" Test for the 'quickfixtextfunc' setting\nfunc Tqfexpr(info)\n  if a:info.quickfix\n    let qfl = getqflist({'id' : a:info.id, 'items' : 1}).items\n  else\n    let qfl = getloclist(a:info.winid, {'id' : a:info.id, 'items' : 1}).items\n  endif\n\n  let l = []\n  for idx in range(a:info.start_idx - 1, a:info.end_idx - 1)\n    let e = qfl[idx]\n    let s = ''\n    if e.bufnr != 0\n      let bname = bufname(e.bufnr)\n      let s ..= fnamemodify(bname, ':.')\n    endif\n    let s ..= '-'\n    let s ..= 'L' .. string(e.lnum) .. 'C' .. string(e.col) .. '-'\n    let s ..= e.text\n    call add(l, s)\n  endfor\n\n  return l\nendfunc\n\nfunc Xtest_qftextfunc(cchar)\n  call s:setup_commands(a:cchar)\n\n  set efm=%f:%l:%c:%m\n  set quickfixtextfunc=Tqfexpr\n  call assert_equal('Tqfexpr', &quickfixtextfunc)\n  call assert_equal('',\n        \\ g:Xgetlist({'quickfixtextfunc' : 1}).quickfixtextfunc)\n  call g:Xsetlist([\n        \\ { 'filename': 'F1', 'lnum': 10, 'col': 2,\n        \\   'end_col': 7, 'text': 'green'},\n        \\ { 'filename': 'F1', 'lnum': 20, 'end_lnum': 25, 'col': 4,\n        \\   'end_col': 8, 'text': 'blue'},\n        \\ ])\n\n  Xwindow\n  call assert_equal('F1-L10C2-green', getline(1))\n  call assert_equal('F1-L20C4-blue', getline(2))\n  Xclose\n  set quickfixtextfunc&vim\n  Xwindow\n  call assert_equal('F1|10 col 2-7| green', getline(1))\n  call assert_equal('F1|20-25 col 4-8| blue', getline(2))\n  Xclose\n\n  set efm=%f:%l:%c:%m\n  set quickfixtextfunc=Tqfexpr\n  \" Update the list with only the cwindow\n  Xwindow\n  only\n  call g:Xsetlist([\n        \\ { 'filename': 'F2', 'lnum': 20, 'col': 2,\n        \\   'end_col': 7, 'text': 'red'}\n        \\ ])\n  call assert_equal(['F2-L20C2-red'], getline(1, '$'))\n  new\n  Xclose\n  set efm&\n  set quickfixtextfunc&\n\n  \" Test for per list 'quickfixtextfunc' setting\n  func PerQfText(info)\n    if a:info.quickfix\n      let qfl = getqflist({'id' : a:info.id, 'items' : 1}).items\n    else\n      let qfl = getloclist(a:info.winid, {'id' : a:info.id, 'items' : 1}).items\n    endif\n    if empty(qfl)\n      return []\n    endif\n    let l = []\n    for idx in range(a:info.start_idx - 1, a:info.end_idx - 1)\n      call add(l, 'Line ' .. qfl[idx].lnum .. ', Col ' .. qfl[idx].col)\n    endfor\n    return l\n  endfunc\n  set quickfixtextfunc=Tqfexpr\n  call g:Xsetlist([], ' ', {'quickfixtextfunc' : \"PerQfText\"})\n  Xaddexpr ['F1:10:2:green', 'F1:20:4:blue']\n  Xwindow\n  call assert_equal('Line 10, Col 2', getline(1))\n  call assert_equal('Line 20, Col 4', getline(2))\n  Xclose\n  call assert_equal(function('PerQfText'),\n        \\ g:Xgetlist({'quickfixtextfunc' : 1}).quickfixtextfunc)\n  \" Add entries to the list when the quickfix buffer is hidden\n  Xaddexpr ['F1:30:6:red']\n  Xwindow\n  call assert_equal('Line 30, Col 6', getline(3))\n  Xclose\n  call g:Xsetlist([], 'r', {'quickfixtextfunc' : ''})\n  call assert_equal('', g:Xgetlist({'quickfixtextfunc' : 1}).quickfixtextfunc)\n  set quickfixtextfunc&\n  delfunc PerQfText\n\n  \" Non-existing function\n  set quickfixtextfunc=Tabc\n  call assert_fails(\"Xexpr ['F1:10:2:green', 'F1:20:4:blue']\", 'E117:')\n  call assert_fails(\"Xwindow\", 'E117:')\n  Xclose\n  set quickfixtextfunc&\n\n  \" set option to a non-function\n  set quickfixtextfunc=[10,\\ 20]\n  call assert_fails(\"Xexpr ['F1:10:2:green', 'F1:20:4:blue']\", 'E117:')\n  call assert_fails(\"Xwindow\", 'E117:')\n  Xclose\n  set quickfixtextfunc&\n\n  \" set option to a function with different set of arguments\n  func Xqftext(a, b, c)\n    return a:a .. a:b .. a:c\n  endfunc\n  set quickfixtextfunc=Xqftext\n  call assert_fails(\"Xexpr ['F1:10:2:green', 'F1:20:4:blue']\", 'E119:')\n  call assert_fails(\"Xwindow\", 'E119:')\n  Xclose\n\n  \" set option to a function that returns a list with non-strings\n  func Xqftext2(d)\n    return ['one', [], 'two']\n  endfunc\n  set quickfixtextfunc=Xqftext2\n  call assert_fails(\"Xexpr ['F1:10:2:green', 'F1:20:4:blue', 'F1:30:6:red']\",\n                                                                  \\ 'E730:')\n  call assert_fails('Xwindow', 'E730:')\n  call assert_equal(['one', 'F1|20 col 4| blue', 'F1|30 col 6| red'],\n        \\ getline(1, '$'))\n  Xclose\n\n  set quickfixtextfunc&\n  delfunc Xqftext\n  delfunc Xqftext2\n\n  \" set the global option to a lambda function\n  set quickfixtextfunc={d\\ ->\\ map(g:Xgetlist({'id'\\ :\\ d.id,\\ 'items'\\ :\\ 1}).items[d.start_idx-1:d.end_idx-1],\\ 'v:val.text')}\n  Xexpr ['F1:10:2:green', 'F1:20:4:blue']\n  Xwindow\n  call assert_equal(['green', 'blue'], getline(1, '$'))\n  Xclose\n  call assert_equal(\"{d -> map(g:Xgetlist({'id' : d.id, 'items' : 1}).items[d.start_idx-1:d.end_idx-1], 'v:val.text')}\", &quickfixtextfunc)\n  set quickfixtextfunc&\n\n  \" use a lambda function that returns an empty list\n  set quickfixtextfunc={d\\ ->\\ []}\n  Xexpr ['F1:10:2:green', 'F1:20:4:blue']\n  Xwindow\n  call assert_equal(['F1|10 col 2| green', 'F1|20 col 4| blue'],\n        \\ getline(1, '$'))\n  Xclose\n  set quickfixtextfunc&\n\n  \" use a lambda function that returns a list with empty strings\n  set quickfixtextfunc={d\\ ->\\ ['',\\ '']}\n  Xexpr ['F1:10:2:green', 'F1:20:4:blue']\n  Xwindow\n  call assert_equal(['F1|10 col 2| green', 'F1|20 col 4| blue'],\n        \\ getline(1, '$'))\n  Xclose\n  set quickfixtextfunc&\n\n  \" set the per-quickfix list text function to a lambda function\n  call g:Xsetlist([], ' ',\n        \\ {'quickfixtextfunc' :\n        \\   {d -> map(g:Xgetlist({'id' : d.id, 'items' : 1}).items[d.start_idx-1:d.end_idx-1],\n        \\ \"'Line ' .. v:val.lnum .. ', Col ' .. v:val.col\")}})\n  Xaddexpr ['F1:10:2:green', 'F1:20:4:blue']\n  Xwindow\n  call assert_equal('Line 10, Col 2', getline(1))\n  call assert_equal('Line 20, Col 4', getline(2))\n  Xclose\n  call assert_match(\"function('<lambda>\\\\d\\\\+')\", string(g:Xgetlist({'quickfixtextfunc' : 1}).quickfixtextfunc))\n  call g:Xsetlist([], 'f')\nendfunc\n\nfunc Test_qftextfunc()\n  call Xtest_qftextfunc('c')\n  call Xtest_qftextfunc('l')\nendfunc\n\nfunc Test_qftextfunc_callback()\n  let lines =<< trim END\n    set efm=%f:%l:%c:%m\n\n    #\" Test for using a function name\n    LET &qftf = 'g:Tqfexpr'\n    cexpr \"F0:0:0:L0\"\n    copen\n    call assert_equal('F0-L0C0-L0', getline(1))\n    cclose\n\n    #\" Test for using a function()\n    set qftf=function('g:Tqfexpr')\n    cexpr \"F1:1:1:L1\"\n    copen\n    call assert_equal('F1-L1C1-L1', getline(1))\n    cclose\n\n    #\" Using a funcref variable to set 'quickfixtextfunc'\n    VAR Fn = function('g:Tqfexpr')\n    LET &qftf = Fn\n    cexpr \"F2:2:2:L2\"\n    copen\n    call assert_equal('F2-L2C2-L2', getline(1))\n    cclose\n\n    #\" Using string(funcref_variable) to set 'quickfixtextfunc'\n    LET Fn = function('g:Tqfexpr')\n    LET &qftf = string(Fn)\n    cexpr \"F3:3:3:L3\"\n    copen\n    call assert_equal('F3-L3C3-L3', getline(1))\n    cclose\n\n    #\" Test for using a funcref()\n    set qftf=funcref('g:Tqfexpr')\n    cexpr \"F4:4:4:L4\"\n    copen\n    call assert_equal('F4-L4C4-L4', getline(1))\n    cclose\n\n    #\" Using a funcref variable to set 'quickfixtextfunc'\n    LET Fn = funcref('g:Tqfexpr')\n    LET &qftf = Fn\n    cexpr \"F5:5:5:L5\"\n    copen\n    call assert_equal('F5-L5C5-L5', getline(1))\n    cclose\n\n    #\" Using a string(funcref_variable) to set 'quickfixtextfunc'\n    LET Fn = funcref('g:Tqfexpr')\n    LET &qftf = string(Fn)\n    cexpr \"F5:5:5:L5\"\n    copen\n    call assert_equal('F5-L5C5-L5', getline(1))\n    cclose\n\n    #\" Test for using a lambda function with set\n    VAR optval = \"LSTART a LMIDDLE g:Tqfexpr(a) LEND\"\n    LET optval = substitute(optval, ' ', '\\\\ ', 'g')\n    exe \"set qftf=\" .. optval\n    cexpr \"F6:6:6:L6\"\n    copen\n    call assert_equal('F6-L6C6-L6', getline(1))\n    cclose\n\n    #\" Set 'quickfixtextfunc' to a lambda expression\n    LET &qftf = LSTART a LMIDDLE g:Tqfexpr(a) LEND\n    cexpr \"F7:7:7:L7\"\n    copen\n    call assert_equal('F7-L7C7-L7', getline(1))\n    cclose\n\n    #\" Set 'quickfixtextfunc' to string(lambda_expression)\n    LET &qftf = \"LSTART a LMIDDLE g:Tqfexpr(a) LEND\"\n    cexpr \"F8:8:8:L8\"\n    copen\n    call assert_equal('F8-L8C8-L8', getline(1))\n    cclose\n\n    #\" Set 'quickfixtextfunc' to a variable with a lambda expression\n    VAR Lambda = LSTART a LMIDDLE g:Tqfexpr(a) LEND\n    LET &qftf = Lambda\n    cexpr \"F9:9:9:L9\"\n    copen\n    call assert_equal('F9-L9C9-L9', getline(1))\n    cclose\n\n    #\" Set 'quickfixtextfunc' to a string(variable with a lambda expression)\n    LET Lambda = LSTART a LMIDDLE g:Tqfexpr(a) LEND\n    LET &qftf = string(Lambda)\n    cexpr \"F9:9:9:L9\"\n    copen\n    call assert_equal('F9-L9C9-L9', getline(1))\n    cclose\n  END\n  call v9.CheckLegacyAndVim9Success(lines)\n\n  \" Test for using a script-local function name\n  func s:TqfFunc2(info)\n    let g:TqfFunc2Args = [a:info.start_idx, a:info.end_idx]\n    return ''\n  endfunc\n  let g:TqfFunc2Args = []\n  set quickfixtextfunc=s:TqfFunc2\n  cexpr \"F10:10:10:L10\"\n  cclose\n  call assert_equal([1, 1], g:TqfFunc2Args)\n\n  let &quickfixtextfunc = 's:TqfFunc2'\n  cexpr \"F11:11:11:L11\"\n  cclose\n  call assert_equal([1, 1], g:TqfFunc2Args)\n  delfunc s:TqfFunc2\n\n  \" set 'quickfixtextfunc' to a partial with dict. This used to cause a crash.\n  func SetQftfFunc()\n    let params = {'qftf': function('g:DictQftfFunc')}\n    let &quickfixtextfunc = params.qftf\n  endfunc\n  func g:DictQftfFunc(_) dict\n  endfunc\n  call SetQftfFunc()\n  new\n  call SetQftfFunc()\n  bw\n  call test_garbagecollect_now()\n  new\n  set qftf=\n  wincmd w\n  set qftf=\n  :%bw!\n\n  \" set per-quickfix list 'quickfixtextfunc' to a partial with dict. This used\n  \" to cause a crash.\n  let &qftf = ''\n  func SetLocalQftfFunc()\n    let params = {'qftf': function('g:DictQftfFunc')}\n    call setqflist([], 'a', {'quickfixtextfunc' : params.qftf})\n  endfunc\n  call SetLocalQftfFunc()\n  call test_garbagecollect_now()\n  call setqflist([], 'a', {'quickfixtextfunc' : ''})\n  delfunc g:DictQftfFunc\n  delfunc SetQftfFunc\n  delfunc SetLocalQftfFunc\n  set efm&\nendfunc\n\n\" Test for updating a location list for some other window and check that\n\" 'qftextfunc' uses the correct location list.\nfunc Test_qftextfunc_other_loclist()\n  %bw!\n  call setloclist(0, [], 'f')\n\n  \" create a window and a location list for it and open the location list\n  \" window\n  lexpr ['F1:10:12:one', 'F1:20:14:two']\n  let w1_id = win_getid()\n  call setloclist(0, [], ' ',\n        \\ {'lines': ['F1:10:12:one', 'F1:20:14:two'],\n        \\  'quickfixtextfunc':\n        \\    {d -> map(getloclist(d.winid, {'id' : d.id,\n        \\                'items' : 1}).items[d.start_idx-1:d.end_idx-1],\n        \\          \"'Line ' .. v:val.lnum .. ', Col ' .. v:val.col\")}})\n  lwindow\n  let w2_id = win_getid()\n\n  \" create another window and a location list for it and open the location\n  \" list window\n  topleft new\n  let w3_id = win_getid()\n  call setloclist(0, [], ' ',\n        \\ {'lines': ['F2:30:32:eleven', 'F2:40:34:twelve'],\n        \\  'quickfixtextfunc':\n        \\    {d -> map(getloclist(d.winid, {'id' : d.id,\n        \\                'items' : 1}).items[d.start_idx-1:d.end_idx-1],\n        \\          \"'Ligne ' .. v:val.lnum .. ', Colonne ' .. v:val.col\")}})\n  lwindow\n  let w4_id = win_getid()\n\n  topleft new\n  lexpr ['F3:50:52:green', 'F3:60:54:blue']\n  let w5_id = win_getid()\n\n  \" change the location list for some other window\n  call setloclist(0, [], 'r', {'lines': ['F3:55:56:aaa', 'F3:57:58:bbb']})\n  call setloclist(w1_id, [], 'r', {'lines': ['F1:62:63:bbb', 'F1:64:65:ccc']})\n  call setloclist(w3_id, [], 'r', {'lines': ['F2:76:77:ddd', 'F2:78:79:eee']})\n  call assert_equal(['Line 62, Col 63', 'Line 64, Col 65'],\n        \\ getbufline(winbufnr(w2_id), 1, '$'))\n  call assert_equal(['Ligne 76, Colonne 77', 'Ligne 78, Colonne 79'],\n        \\ getbufline(winbufnr(w4_id), 1, '$'))\n  call setloclist(w2_id, [], 'r', {'lines': ['F1:32:33:fff', 'F1:34:35:ggg']})\n  call setloclist(w4_id, [], 'r', {'lines': ['F2:46:47:hhh', 'F2:48:49:jjj']})\n  call assert_equal(['Line 32, Col 33', 'Line 34, Col 35'],\n        \\ getbufline(winbufnr(w2_id), 1, '$'))\n  call assert_equal(['Ligne 46, Colonne 47', 'Ligne 48, Colonne 49'],\n        \\ getbufline(winbufnr(w4_id), 1, '$'))\n\n  call win_gotoid(w5_id)\n  lwindow\n  call assert_equal(['F3|55 col 56| aaa', 'F3|57 col 58| bbb'],\n        \\ getline(1, '$'))\n  %bw!\nendfunc\n\n\" Running :lhelpgrep command more than once in a help window, doesn't jump to\n\" the help topic\nfunc Test_lhelpgrep_from_help_window()\n  call mkdir('Xtestdir/doc', 'p')\n  call writefile(['window'], 'Xtestdir/doc/a.txt')\n  call writefile(['buffer'], 'Xtestdir/doc/b.txt')\n  let save_rtp = &rtp\n  let &rtp = 'Xtestdir'\n  lhelpgrep window\n  lhelpgrep buffer\n  call assert_equal('b.txt', fnamemodify(@%, \":p:t\"))\n  lhelpgrep window\n  call assert_equal('a.txt', fnamemodify(@%, \":p:t\"))\n  let &rtp = save_rtp\n  call delete('Xtestdir', 'rf')\n  new | only!\nendfunc\n\n\" Test for the crash fixed by 7.3.715\nfunc Test_setloclist_crash()\n  %bw!\n  let g:BufNum = bufnr()\n  augroup QF_Test\n    au!\n    au BufUnload * call setloclist(0, [{'bufnr':g:BufNum, 'lnum':1, 'col':1, 'text': 'tango down'}])\n  augroup END\n\n  try\n    lvimgrep /.*/ *.mak\n  catch /E926:/\n  endtry\n  call assert_equal('tango down', getloclist(0, {'items' : 0}).items[0].text)\n  call assert_equal(1, getloclist(0, {'size' : 0}).size)\n\n  augroup QF_Test\n    au!\n  augroup END\n  unlet g:BufNum\n  %bw!\nendfunc\n\n\" Test for adding an invalid entry with the quickfix window open and making\n\" sure that the window contents are not changed\nfunc Test_add_invalid_entry_with_qf_window()\n  call setqflist([], 'f')\n  cexpr \"Xfile1:10:aa\"\n  copen\n  call setqflist(['bb'], 'a')\n  call assert_equal(1, line('$'))\n  call assert_equal(['Xfile1|10| aa'], getline(1, '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': 0    , 'bufnr': bufnr('Xfile1') , 'col': 0   , 'end_col': 0    , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                                          , 'bufnr': bufnr('Xfile1') , 'col': 0                     , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10| aa']               , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': 0    , 'bufnr': bufnr('Xfile1') , 'col': 0   , 'end_col': 0    , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                       , 'end_lnum': 0    , 'bufnr': bufnr('Xfile1') , 'col': 0   , 'end_col': 0    , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10| aa']               , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': 0    , 'bufnr': bufnr('Xfile1') , 'col': 0   , 'end_col': 0    , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                       , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 0   , 'end_col': -456 , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10| aa']               , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 0   , 'end_col': -456 , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                       , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': 0    , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10 col 666| aa']       , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': 0    , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                       , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': -456 , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10 col 666| aa']       , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': -456 , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                       , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': 222  , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10 col 666-222| aa']   , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': 222  , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                       , 'end_lnum': 6 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': 222  , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10-6 col 666-222| aa'] , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': 6 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': 222  , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n  cclose\nendfunc\n\n\" Test for very weird problem: autocommand causes a failure, resulting opening\n\" the quickfix window to fail. This still splits the window, but otherwise\n\" should not mess up buffers.\nfunc Test_quickfix_window_fails_to_open()\n  CheckScreendump\n\n  let lines =<< trim END\n      anything\n      try\n        anything\n      endtry\n  END\n  call writefile(lines, 'XquickfixFails')\n\n  let lines =<< trim END\n      split XquickfixFails\n      silent vimgrep anything %\n      normal o\n      au BufLeave * ++once source XquickfixFails\n      \" This will trigger the autocommand, which causes an error, what follows\n      \" is aborted but the window was already split.\n      silent! cwindow\n  END\n  call writefile(lines, 'XtestWinFails')\n  let buf = RunVimInTerminal('-S XtestWinFails', #{rows: 13})\n  call VerifyScreenDump(buf, 'Test_quickfix_window_fails', {})\n\n  \" clean up\n  call term_sendkeys(buf, \":bwipe!\\<CR>\")\n  call term_wait(buf)\n  call StopVimInTerminal(buf)\n  call delete('XtestWinFails')\n  call delete('XquickfixFails')\nendfunc\n\n\" Test for updating the quickfix buffer whenever the associated quickfix list\n\" is changed.\nfunc Xqfbuf_update(cchar)\n  call s:setup_commands(a:cchar)\n\n  Xexpr \"F1:1:line1\"\n  Xopen\n  call assert_equal(['F1|1| line1'], getline(1, '$'))\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  \" Test setqflist() using the 'lines' key in 'what'\n  \" add a new entry\n  call g:Xsetlist([], 'a', {'lines' : ['F2:2: line2']})\n  call assert_equal(['F1|1| line1', 'F2|2| line2'], getline(1, '$'))\n  call assert_equal(2, g:Xgetlist({'changedtick' : 0}).changedtick)\n  \" replace all the entries with a single entry\n  call g:Xsetlist([], 'r', {'lines' : ['F3:3: line3']})\n  call assert_equal(['F3|3| line3'], getline(1, '$'))\n  call assert_equal(3, g:Xgetlist({'changedtick' : 0}).changedtick)\n  \" remove all the entries\n  call g:Xsetlist([], 'r', {'lines' : []})\n  call assert_equal([''], getline(1, '$'))\n  call assert_equal(4, g:Xgetlist({'changedtick' : 0}).changedtick)\n  \" add a new list\n  call g:Xsetlist([], ' ', {'lines' : ['F4:4: line4']})\n  call assert_equal(['F4|4| line4'], getline(1, '$'))\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  \" Test setqflist() using the 'items' key in 'what'\n  \" add a new entry\n  call g:Xsetlist([], 'a', {'items' : [{'filename' : 'F5', 'lnum' : 5, 'text' : 'line5'}]})\n  call assert_equal(['F4|4| line4', 'F5|5| line5'], getline(1, '$'))\n  call assert_equal(2, g:Xgetlist({'changedtick' : 0}).changedtick)\n  \" replace all the entries with a single entry\n  call g:Xsetlist([], 'r', {'items' : [{'filename' : 'F6', 'lnum' : 6, 'text' : 'line6'}]})\n  call assert_equal(['F6|6| line6'], getline(1, '$'))\n  call assert_equal(3, g:Xgetlist({'changedtick' : 0}).changedtick)\n  \" remove all the entries\n  call g:Xsetlist([], 'r', {'items' : []})\n  call assert_equal([''], getline(1, '$'))\n  call assert_equal(4, g:Xgetlist({'changedtick' : 0}).changedtick)\n  \" add a new list\n  call g:Xsetlist([], ' ', {'items' : [{'filename' : 'F7', 'lnum' : 7, 'text' : 'line7'}]})\n  call assert_equal(['F7|7| line7'], getline(1, '$'))\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  call g:Xsetlist([], ' ', {})\n  call assert_equal([''], getline(1, '$'))\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  Xclose\nendfunc\n\nfunc Test_qfbuf_update()\n  call Xqfbuf_update('c')\n  call Xqfbuf_update('l')\nendfunc\n\nfunc Test_vimgrep_noswapfile()\n  set noswapfile\n  call writefile(['one', 'two', 'three'], 'Xgreppie')\n  vimgrep two Xgreppie\n  call assert_equal('two', getline('.'))\n\n  call delete('Xgreppie')\n  set swapfile\nendfunc\n\n\" Test for the :vimgrep 'f' flag (fuzzy match)\nfunc Xvimgrep_fuzzy_match(cchar)\n  call s:setup_commands(a:cchar)\n\n  Xvimgrep /three one/f Xfile*\n  let l = g:Xgetlist()\n  call assert_equal(2, len(l))\n  call assert_equal(['Xfile1', 1, 9, 'one two three'],\n        \\ [bufname(l[0].bufnr), l[0].lnum, l[0].col, l[0].text])\n  call assert_equal(['Xfile2', 2, 1, 'three one two'],\n        \\ [bufname(l[1].bufnr), l[1].lnum, l[1].col, l[1].text])\n\n  Xvimgrep /the/f Xfile*\n  let l = g:Xgetlist()\n  call assert_equal(3, len(l))\n  call assert_equal(['Xfile1', 1, 9, 'one two three'],\n        \\ [bufname(l[0].bufnr), l[0].lnum, l[0].col, l[0].text])\n  call assert_equal(['Xfile2', 2, 1, 'three one two'],\n        \\ [bufname(l[1].bufnr), l[1].lnum, l[1].col, l[1].text])\n  call assert_equal(['Xfile2', 4, 4, 'aaathreeaaa'],\n        \\ [bufname(l[2].bufnr), l[2].lnum, l[2].col, l[2].text])\n\n  Xvimgrep /aaa/fg Xfile*\n  let l = g:Xgetlist()\n  call assert_equal(4, len(l))\n  call assert_equal(['Xfile1', 2, 1, 'aaaaaa'],\n        \\ [bufname(l[0].bufnr), l[0].lnum, l[0].col, l[0].text])\n  call assert_equal(['Xfile1', 2, 4, 'aaaaaa'],\n        \\ [bufname(l[1].bufnr), l[1].lnum, l[1].col, l[1].text])\n  call assert_equal(['Xfile2', 4, 1, 'aaathreeaaa'],\n        \\ [bufname(l[2].bufnr), l[2].lnum, l[2].col, l[2].text])\n  call assert_equal(['Xfile2', 4, 9, 'aaathreeaaa'],\n        \\ [bufname(l[3].bufnr), l[3].lnum, l[3].col, l[3].text])\n\n  call assert_fails('Xvimgrep /xyz/fg Xfile*', 'E480:')\nendfunc\n\nfunc Test_vimgrep_fuzzy_match()\n  call writefile(['one two three', 'aaaaaa'], 'Xfile1')\n  call writefile(['one', 'three one two', 'two', 'aaathreeaaa'], 'Xfile2')\n  call Xvimgrep_fuzzy_match('c')\n  call Xvimgrep_fuzzy_match('l')\n  call delete('Xfile1')\n  call delete('Xfile2')\nendfunc\n\nfunc Test_locationlist_open_in_newtab()\n  call s:create_test_file('Xqftestfile1')\n  call s:create_test_file('Xqftestfile2')\n  call s:create_test_file('Xqftestfile3')\n\n  %bwipe!\n\n  let lines =<< trim END\n    Xqftestfile1:5:Line5\n    Xqftestfile2:10:Line10\n    Xqftestfile3:16:Line16\n  END\n  lgetexpr lines\n\n  silent! llast\n  call assert_equal(1, tabpagenr('$'))\n  call assert_equal('Xqftestfile3', bufname())\n\n  set switchbuf=newtab\n\n  silent! lfirst\n  call assert_equal(2, tabpagenr('$'))\n  call assert_equal('Xqftestfile1', bufname())\n\n  silent! lnext\n  call assert_equal(3, tabpagenr('$'))\n  call assert_equal('Xqftestfile2', bufname())\n\n  call delete('Xqftestfile1')\n  call delete('Xqftestfile2')\n  call delete('Xqftestfile3')\n  set switchbuf&vim\n\n  %bwipe!\nendfunc\n\n\" Test for win_gettype() in quickfix and location list windows\nfunc Test_win_gettype()\n  copen\n  call assert_equal(\"quickfix\", win_gettype())\n  let wid = win_getid()\n  wincmd p\n  call assert_equal(\"quickfix\", win_gettype(wid))\n  cclose\n  lexpr ''\n  lopen\n  call assert_equal(\"loclist\", win_gettype())\n  let wid = win_getid()\n  wincmd p\n  call assert_equal(\"loclist\", win_gettype(wid))\n  lclose\nendfunc\n\nfun Test_vimgrep_nomatch()\n  call XexprTests('c')\n  call g:Xsetlist([{'lnum':10,'text':'Line1'}])\n  copen\n  if has(\"win32\")\n    call assert_fails('vimgrep foo *.zzz', 'E479:')\n    let expected = [{'lnum': 10, 'bufnr': 0, 'end_lnum': 0, 'pattern': '', 'valid': 0, 'vcol': 0, 'nr': 0, 'module': '', 'type': '', 'end_col': 0, 'col': 0, 'text': 'Line1'}]\n  else\n    call assert_fails('vimgrep foo *.zzz', 'E480:')\n    let expected = []\n  endif\n  call assert_equal(expected, getqflist())\n  cclose\nendfunc\n\n\" Test for opening the quickfix window in two tab pages and then closing one\n\" of the quickfix windows. This should not make the quickfix buffer unlisted.\n\" (github issue #9300).\nfunc Test_two_qf_windows()\n  cexpr \"F1:1:line1\"\n  copen\n  tabnew\n  copen\n  call assert_true(&buflisted)\n  cclose\n  tabfirst\n  call assert_true(&buflisted)\n  let bnum = bufnr()\n  cclose\n  \" if all the quickfix windows are closed, then buffer should be unlisted.\n  call assert_false(buflisted(bnum))\n  %bw!\n\n  \" Repeat the test for a location list\n  lexpr \"F2:2:line2\"\n  lopen\n  let bnum = bufnr()\n  tabnew\n  exe \"buffer\" bnum\n  tabfirst\n  lclose\n  tablast\n  call assert_true(buflisted(bnum))\n  tabclose\n  lopen\n  call assert_true(buflisted(bnum))\n  lclose\n  call assert_false(buflisted(bnum))\n  %bw!\nendfunc\n\n\" Weird sequence of commands that caused entering a wiped-out buffer\nfunc Test_lopen_bwipe()\n  func R()\n    silent! tab lopen\n    e x\n    silent! lfile\n  endfunc\n\n  cal R()\n  cal R()\n  cal R()\n  bw!\n  delfunc R\nendfunc\n\n\" Another sequence of commands that caused all buffers to be wiped out\nfunc Test_lopen_bwipe_all()\n  let lines =<< trim END\n    func R()\n      silent! tab lopen\n      e foo\n      silent! lfile\n    endfunc\n    cal R()\n    exe \"norm \\<C-W>\\<C-V>0\"\n    cal R()\n    bwipe\n\n    call writefile(['done'], 'Xresult')\n    qall!\n  END\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '-u NONE -n -X -Z -e -m -s -S Xscript')\n    call assert_equal(['done'], readfile('Xresult'))\n  endif\n\n  call delete('Xscript')\n  call delete('Xresult')\nendfunc\n\n\" Test for calling setqflist() function recursively\nfunc Test_recursive_setqflist()\n  augroup QF_Test\n    au!\n    autocmd BufWinEnter quickfix call setqflist([], 'r')\n  augroup END\n\n  copen\n  call assert_fails(\"call setqflist([], 'a')\", 'E952:')\n\n  augroup QF_Test\n    au!\n  augroup END\n  %bw!\nendfunc\n\n\" Test for failure to create a new window when selecting a file from the\n\" quickfix window\nfunc Test_cwindow_newwin_fails()\n  cgetexpr [\"Xfile1:10:L10\", \"Xfile1:20:L20\"]\n  cwindow\n  only\n  let qf_wid = win_getid()\n  \" create the maximum number of scratch windows\n  let hor_win_count = (&lines - 1)/2\n  let hor_split_count = hor_win_count - 1\n  for s in range(1, hor_split_count) | new | set buftype=nofile | endfor\n  call win_gotoid(qf_wid)\n  call assert_fails('exe \"normal \\<CR>\"', 'E36:')\n  %bw!\nendfunc\n\n\" Test for updating the location list when only the location list window is\n\" present and the corresponding file window is closed.\nfunc Test_loclist_update_with_llwin_only()\n  %bw!\n  new\n  wincmd w\n  lexpr [\"Xfile1:1:Line1\"]\n  lopen\n  wincmd p\n  close\n  call setloclist(2, [], 'r', {'lines': [\"Xtest2:2:Line2\"]})\n  call assert_equal(['Xtest2|2| Line2'], getbufline(winbufnr(2), 1, '$'))\n  %bw!\nendfunc\n\n\" Test for getting the quickfix list after a buffer with an error is wiped out\nfunc Test_getqflist_wiped_out_buffer()\n  %bw!\n  cexpr [\"Xtest1:34:Wiped out\"]\n  let bnum = bufnr('Xtest1')\n  call assert_equal(bnum, getqflist()[0].bufnr)\n  bw Xtest1\n  call assert_equal(0, getqflist()[0].bufnr)\n  %bw!\nendfunc\n\n\" Test for the status message that is displayed when opening a new quickfix\n\" list\nfunc Test_qflist_statusmsg()\n  cexpr \"1\\n2\"\n  cexpr \"1\\n2\\n3\\ntest_quickfix.vim:1:msg\"\n  call assert_equal('(4 of 4): msg', v:statusmsg)\n  call setqflist([], 'f')\n  %bw!\n\n  \" When creating a new quickfix list, if an autocmd changes the quickfix list\n  \" in the stack, then an error message should be displayed.\n  augroup QF_Test\n    au!\n    au BufEnter test_quickfix.vim colder\n  augroup END\n  cexpr \"1\\n2\"\n  call assert_fails('cexpr \"1\\n2\\n3\\ntest_quickfix.vim:1:msg\"', 'E925:')\n  call setqflist([], 'f')\n  augroup QF_Test\n    au!\n  augroup END\n  %bw!\n\n  augroup QF_Test\n    au!\n    au BufEnter test_quickfix.vim caddexpr \"4\"\n  augroup END\n  call assert_fails('cexpr \"1\\n2\\n3\\ntest_quickfix.vim:1:msg\"', 'E925:')\n  call setqflist([], 'f')\n  augroup QF_Test\n    au!\n  augroup END\n  %bw!\nendfunc\n\nfunc Test_quickfixtextfunc_recursive()\n  func s:QFTfunc(o)\n    cgete '0'\n  endfunc\n  copen\n  let &quickfixtextfunc = 's:QFTfunc'\n  cex \"\"\n\n  let &quickfixtextfunc = ''\n  cclose\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/quickfix.c", "src/testdir/test_quickfix.vim", "src/version.c"], "buggy_code_start_loc": [4676, 6353, 733], "buggy_code_end_loc": [4713, 6353, 733], "fixing_code_start_loc": [4677, 6354, 734], "fixing_code_end_loc": [4723, 6367, 736], "type": "CWE-416", "message": "Use After Free in GitHub repository vim/vim prior to 9.0.0260.", "other": {"cve": {"id": "CVE-2022-2982", "sourceIdentifier": "security@huntr.dev", "published": "2022-08-25T20:15:09.650", "lastModified": "2023-05-03T12:16:10.477", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Use After Free in GitHub repository vim/vim prior to 9.0.0260."}, {"lang": "es", "value": "Un Uso De Memoria Previamente Liberada en el repositorio de GitHub vim/vim versiones anteriores a 9.0.0260."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 7.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.7}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0260", "matchCriteriaId": "1C0E934B-EC18-4EAE-9F1E-9831D77B4DFF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/d6c67629ed05aae436164eec474832daf8ba7420", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/53f53d9a-ba8a-4985-b7ba-23efbe6833be", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XWOJOA7PZZAMBI5GFTL6PWHXMWSDLUXL/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/d6c67629ed05aae436164eec474832daf8ba7420"}}