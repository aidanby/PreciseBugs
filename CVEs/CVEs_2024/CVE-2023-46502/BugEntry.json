{"buggy_code": ["/*\n * ====================================================================\n * Project:     openCRX/core, http://www.opencrx.org/\n * Description: AbstractMethod\n * Owner:       the original authors.\n * ====================================================================\n *\n * This software is published under the BSD license\n * as listed below.\n * \n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions \n * are met:\n * \n * * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * \n * * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in\n * the documentation and/or other materials provided with the\n * distribution.\n * \n * * Neither the name of the openCRX team nor the names of the contributors\n * to openCRX may be used to endorse or promote products derived\n * from this software without specific prior written permission\n * \n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n * CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n * \n * ------------------\n * \n * This product includes software developed by the Apache Software\n * Foundation (http://www.apache.org/).\n * \n * This product includes software developed by contributors to\n * openMDX (http://www.openmdx.org/)\n */\n\n/*\n * This source was originally published under net.sf.webdav.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage org.opencrx.application.uses.net.sf.webdav.methods;\n\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.TimeZone;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.opencrx.application.uses.net.sf.webdav.Lock;\nimport org.opencrx.application.uses.net.sf.webdav.RequestContext;\nimport org.opencrx.application.uses.net.sf.webdav.Resource;\nimport org.opencrx.application.uses.net.sf.webdav.WebDavStore;\nimport org.opencrx.application.uses.net.sf.webdav.WebdavStatus;\nimport org.opencrx.application.uses.net.sf.webdav.exceptions.LockFailedException;\nimport org.opencrx.application.uses.net.sf.webdav.fromcatalina.XMLWriter;\nimport org.openmdx.base.exception.ServiceException;\nimport org.openmdx.base.text.conversion.XMLEncoder;\n\npublic abstract class WebDavMethod {\n\n    /**\n     * Default depth is infite.\n     */\n    protected static final int INFINITY = 3;\n\n    /**\n     * Simple date format for the creation date ISO 8601 representation\n     * (partial).\n     */\n    protected static final ThreadLocal<SimpleDateFormat> CREATION_DATE_FORMAT = new ThreadLocal<SimpleDateFormat>(){\n\t\t@Override\n        protected SimpleDateFormat initialValue() {\n\t\t\tSimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\n\t\t\tformat.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n\t\t\treturn format;\n        }\n    };\n\n    /**\n     * Simple date format for the last modified date. (RFC 822 updated by RFC\n     * 1123)\n     */\n    protected static final ThreadLocal<SimpleDateFormat> LAST_MODIFIED_DATE_FORMAT = new ThreadLocal<SimpleDateFormat>(){\n\t\t@Override\n        protected SimpleDateFormat initialValue() {\n\t\t\tSimpleDateFormat format = new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss z\", Locale.US);\n\t\t\tformat.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n\t\t\treturn format;\n        }    \t    \t\n    };\n\n    /**\n     * size of the io-buffer\n     */\n    protected static int BUF_SIZE = 65536;\n\n    /**\n     * Default lock timeout value.\n     */\n    protected static final int DEFAULT_TIMEOUT = 3600;\n\n    /**\n     * Maximum lock timeout.\n     */\n    protected static final int MAX_TIMEOUT = 604800;\n\n    /**\n     * Boolean value to temporary lock resources (for method locks)\n     */\n    protected static final boolean TEMPORARY = true;\n\n    /**\n     * Timeout for temporary locks\n     */\n    protected static final int TEMP_TIMEOUT = 10;\n\n    /**\n     * To be implemented by concrete method.\n     * @param requestContext\n     * @param req\n     * @param resp\n     * @throws IOException\n     * @throws LockFailedException\n     */\n    public abstract void execute(\n    \tRequestContext requestContext \n    ) throws IOException, LockFailedException;\n    \n    /**\n     * Return the relative path associated with this servlet.\n     * \n     * @param request\n     *      The servlet request we are processing\n     */\n    protected String getRelativePath(\n    \tRequestContext requestContext\n    ) {\n    \tHttpServletRequest req = requestContext.getHttpServletRequest();\n    \treturn req.getServletPath();\n    }\n\n    protected String getRelativePath(\n    \tRequestContext requestContext,\n    \tString absolutePath\n    ) {\n    \tHttpServletRequest req = requestContext.getHttpServletRequest();\n    \tString contextPath = req.getContextPath();\n    \tint pos = absolutePath.indexOf(contextPath);\n    \treturn pos > 0 ?\n    \t\tabsolutePath.substring(pos + contextPath.length()) :\n    \t\t\tabsolutePath;\n    }\n    \t\n    /**\n     * creates the parent path from the given path by removing the last '/' and\n     * everything after that\n     * \n     * @param path\n     *      the path\n     * @return parent path\n     */\n    protected String getParentPath(\n    \tString path\n    ) {\n        int slash = path.lastIndexOf('/');\n        if (slash != -1) {\n            return path.substring(0, slash);\n        }\n        return null;\n    }\n\n    /**\n     * removes a / at the end of the path string, if present\n     * \n     * @param path\n     *      the path\n     * @return the path without trailing /\n     */\n    protected String getCleanPath(\n    \tString path\n    ) {\n        if (path.endsWith(\"/\") && path.length() > 1)\n            path = path.substring(0, path.length() - 1);\n        return path;\n    }\n\n    /**\n     * Return JAXP document builder instance.\n     */\n    protected DocumentBuilder getDocumentBuilder(\n    ) throws ServiceException {\n        DocumentBuilder documentBuilder = null;\n        DocumentBuilderFactory documentBuilderFactory = null;\n        try {\n            documentBuilderFactory = DocumentBuilderFactory.newInstance();\n            documentBuilderFactory.setNamespaceAware(true);\n            documentBuilder = documentBuilderFactory.newDocumentBuilder();\n        } catch (ParserConfigurationException e) {\n            throw new ServiceException(e);\n        }\n        return documentBuilder;\n    }\n\n    /**\n     * Reads the depth header from the request and returns it as a int.\n     * \n     * @param req\n     * @return the depth from the depth header\n     */\n    protected int getDepth(\n    \tRequestContext requestContext\n    ) {\n    \tHttpServletRequest req = requestContext.getHttpServletRequest();\n        int depth = 1; // default is 1\n        String depthStr = req.getHeader(\"Depth\");\n        if(depthStr != null) {\n        \ttry {\n        \t\tdepth = Integer.parseInt(depthStr);\n        \t} catch(Exception ignore) {}\n        }\n        return depth;\n    }\n\n    /**\n     * URL rewriter.\n     * \n     * @param path\n     *      Path which has to be rewritten\n     * @return the rewritten path\n     */\n    protected String encodeURL(\n    \tHttpServletResponse resp,\n    \tString path\n    ) {    \t\n    \tpath = path.replace(\"%\", \"%25\");\n   \t\tpath = path.replace(\" \", \"%20\");\n   \t\tpath = XMLEncoder.encode(path);\n   \t\treturn path;\n    }\n\n    protected String getHRef(\n    \tHttpServletRequest req,\n    \tString suffix,\n    \tboolean isCollection\n    ) {\n        String href = req.getContextPath();\n        if ((href.endsWith(\"/\")) && (suffix.startsWith(\"/\"))) {\n            href += suffix.substring(1);\n        }\n        else {\n            href += suffix;\n        }\n        if ((isCollection) && (!href.endsWith(\"/\"))) {\n            href += \"/\";\n        }\n        return href;\n    }\n    \n    /**\n     * Get the ETag associated with a resource.\n     * \n     * @param so\n     *      StoredObject to get resourceLength, lastModified and a hashCode of\n     *      StoredObject\n     * @return the ETag\n     */\n    protected String getETag(Resource so) {\n\n        Date lastModified = new Date();\n        if (so != null && so.getLastModified() != null) {        \t\n            lastModified = so.getLastModified();\n        }\n        return \"W/\\\"\" + Long.toString(lastModified.getTime()) + \"\\\"\";\n    }\n\n    protected String getVersion(\n    ) {\n    \treturn \"1, 2\";\n    }\n        \n    protected String[] getLockIdFromIfHeader(\n    \tRequestContext requestContext\n    ) {\n    \tHttpServletRequest req = requestContext.getHttpServletRequest();\n        String[] ids = new String[2];\n        String id = req.getHeader(\"If\");\n\n        if (id != null && !id.equals(\"\")) {\n            if (id.indexOf(\">)\") == id.lastIndexOf(\">)\")) {\n                id = id.substring(id.indexOf(\"(<\"), id.indexOf(\">)\"));\n\n                if (id.indexOf(\"locktoken:\") != -1) {\n                    id = id.substring(id.indexOf(':') + 1);\n                }\n                ids[0] = id;\n            } else {\n                String firstId = id.substring(id.indexOf(\"(<\"), id.indexOf(\">)\"));\n                if (firstId.indexOf(\"locktoken:\") != -1) {\n                    firstId = firstId.substring(firstId.indexOf(':') + 1);\n                }\n                ids[0] = firstId;\n\n                String secondId = id.substring(id.lastIndexOf(\"(<\"), id\n                        .lastIndexOf(\">)\"));\n                if (secondId.indexOf(\"locktoken:\") != -1) {\n                    secondId = secondId.substring(secondId.indexOf(':') + 1);\n                }\n                ids[1] = secondId;\n            }\n\n        } else {\n            ids = null;\n        }\n        return ids;\n    }\n\n    /**\n     * Get lock token.\n     * \n     * @param requestContext\n     * @return\n     */\n    protected String getLockIdFromLockTokenHeader(\n    \tRequestContext requestContext\n    ) {\n    \tHttpServletRequest req = requestContext.getHttpServletRequest();\n        String id = req.getHeader(\"Lock-Token\");\n        if (id != null) {\n            id = id.substring(id.indexOf(\":\") + 1, id.indexOf(\">\"));\n\n        }\n        return id;\n    }\n\n    /**\n     * Checks if locks on resources at the given path exists and if so checks\n     * the If-Header to make sure the If-Header corresponds to the locked\n     * resource. Returning true if no lock exists or the If-Header is\n     * corresponding to the locked resource\n     * \n     * @param req\n     *      Servlet request\n     * @param resp\n     *      Servlet response\n     * @param store\n     * @param path\n     *      path to the resource\n     * @return true if no lock on a resource with the given path exists or if\n     *  the If-Header corresponds to the locked resource\n     * @throws IOException\n     * @throws LockFailedException\n     */\n    protected boolean checkLocks(\n    \tRequestContext requestContext,\n        WebDavStore store, \n        String path\n    ) throws IOException, LockFailedException {\n        List<Lock> losByPath = store.getLocksByPath(requestContext, path);\n        for(Lock lo: losByPath) {\n            if(!Lock.SCOPE_SHARED.equals(lo.getScope())) {\n\t            // the resource is locked\n\t            String[] lockTokens = getLockIdFromIfHeader(requestContext);\n\t            String lockToken = null;\n\t            if (lockTokens != null)\n\t                lockToken = lockTokens[0];\n\t            else {\n\t                return false;\n\t            }\n\t            if(lockToken != null) {\n\t                if (!lockToken.equals(lo.getID())) {\n\t                    return false;\n\t                }\n\t            }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Send a multistatus element containing a complete error report to the\n     * client.\n     * \n     * @param req\n     *      Servlet request\n     * @param resp\n     *      Servlet response\n     * @param errorList\n     *      List of error to be displayed\n     */\n    protected void sendReport(\n    \tRequestContext requestContext,\n        Hashtable<String, Integer> errorList\n     ) throws IOException {\n    \tHttpServletResponse resp = requestContext.getHttpServletResponse();\n    \tHttpServletRequest req = requestContext.getHttpServletRequest();\n        resp.setStatus(WebdavStatus.SC_MULTI_STATUS);\n        String absoluteUri = req.getRequestURI();\n        // String relativePath = getRelativePath(req);\n        HashMap<String, String> namespaces = new HashMap<String, String>();\n        namespaces.put(\"DAV:\", \"D\");\n        XMLWriter writer = new XMLWriter(resp.getWriter(), namespaces);\n        writer.writeXMLHeader();\n        writer.writeElement(\"DAV::multistatus\", XMLWriter.OPENING);\n        Enumeration<String> pathList = errorList.keys();\n        while (pathList.hasMoreElements()) {\n            String errorPath = pathList.nextElement();\n            int errorCode = errorList.get(errorPath);\n            writer.writeElement(\"DAV::response\", XMLWriter.OPENING);\n            writer.writeElement(\"DAV::href\", XMLWriter.OPENING);\n            String toAppend = null;\n            if (absoluteUri.endsWith(errorPath)) {\n                toAppend = absoluteUri;\n            } else if (absoluteUri.contains(errorPath)) {\n                int endIndex = absoluteUri.indexOf(errorPath) + errorPath.length();\n                toAppend = absoluteUri.substring(0, endIndex);\n            }\n            if (!toAppend.startsWith(\"/\") && !toAppend.startsWith(\"http:\")) {\n                toAppend = \"/\" + toAppend;\n            }\n            writer.writeText(errorPath);\n            writer.writeElement(\"DAV::href\", XMLWriter.CLOSING);\n            writer.writeElement(\"DAV::status\", XMLWriter.OPENING);\n            writer.writeText(\"HTTP/1.1 \" + errorCode);\n            writer.writeElement(\"DAV::status\", XMLWriter.CLOSING);\n            writer.writeElement(\"DAV::response\", XMLWriter.CLOSING);\n        }\n        writer.writeElement(\"DAV::multistatus\", XMLWriter.CLOSING);\n        writer.sendData();\n    }\n\n    protected String getNullResourceMethodsAllowed(\n    ) {\n    \treturn NULL_RESOURCE_METHODS_ALLOWED;\n    }\n    \n    protected String getResourceMethodsAllowed(\n    ) {\n    \treturn RESOURCE_METHODS_ALLOWED;\n    }\n    \n    public String getFolderMethodsAllowed(\n    ) {\n    \treturn FOLDER_METHODS_ALLOWED;\n    }\n    \n    public String getDefaultMethodsAllowed(\n    ) {\n    \treturn DEFAULT_METHODS_ALLOWED;\n    }\n    \n    /**\n     * Determines the methods normally allowed for the resource.\n     * \n     * @param so\n     *      StoredObject representing the resource\n     * @return all allowed methods, separated by commas\n     */\n    protected String determineMethodsAllowed(\n    \tResource so\n    ) {\n        try {\n            if (so != null) {\n                if (so.isCollection()) {\n                    return this.getDefaultMethodsAllowed() + \", \" + this.getResourceMethodsAllowed() + \", \" + this.getFolderMethodsAllowed();\n                } else {\n                \treturn this.getDefaultMethodsAllowed() + \", \" + getResourceMethodsAllowed();\n                }\n            }\n        } catch (Exception e) {\n            // we do nothing, just return default allowed methods\n        }\n        return getDefaultMethodsAllowed();\n    }\n\n    //-----------------------------------------------------------------------\n    // Members\n    //-----------------------------------------------------------------------\n    private static final String NULL_RESOURCE_METHODS_ALLOWED = \"OPTIONS, MKCOL, PUT, PROPFIND, LOCK, UNLOCK\";\n    private static final String RESOURCE_METHODS_ALLOWED = \"OPTIONS, GET, HEAD, POST, DELETE, TRACE, PROPPATCH, COPY, MOVE, LOCK, UNLOCK, PROPFIND\";\n    private static final String FOLDER_METHODS_ALLOWED = \"PUT\";\n    private static final String DEFAULT_METHODS_ALLOWED = \"OPTIONS, MKCOL, PUT\";\n    \n}\n"], "fixing_code": ["/*\n * ====================================================================\n * Project:     openCRX/core, http://www.opencrx.org/\n * Description: AbstractMethod\n * Owner:       the original authors.\n * ====================================================================\n *\n * This software is published under the BSD license\n * as listed below.\n * \n * Redistribution and use in source and binary forms, with or without \n * modification, are permitted provided that the following conditions \n * are met:\n * \n * * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * \n * * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in\n * the documentation and/or other materials provided with the\n * distribution.\n * \n * * Neither the name of the openCRX team nor the names of the contributors\n * to openCRX may be used to endorse or promote products derived\n * from this software without specific prior written permission\n * \n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n * CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n * \n * ------------------\n * \n * This product includes software developed by the Apache Software\n * Foundation (http://www.apache.org/).\n * \n * This product includes software developed by contributors to\n * openMDX (http://www.openmdx.org/)\n */\n\n/*\n * This source was originally published under net.sf.webdav.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage org.opencrx.application.uses.net.sf.webdav.methods;\n\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.TimeZone;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.opencrx.application.uses.net.sf.webdav.Lock;\nimport org.opencrx.application.uses.net.sf.webdav.RequestContext;\nimport org.opencrx.application.uses.net.sf.webdav.Resource;\nimport org.opencrx.application.uses.net.sf.webdav.WebDavStore;\nimport org.opencrx.application.uses.net.sf.webdav.WebdavStatus;\nimport org.opencrx.application.uses.net.sf.webdav.exceptions.LockFailedException;\nimport org.opencrx.application.uses.net.sf.webdav.fromcatalina.XMLWriter;\nimport org.openmdx.base.exception.ServiceException;\nimport org.openmdx.base.text.conversion.XMLEncoder;\n\npublic abstract class WebDavMethod {\n\n    /**\n     * Default depth is infite.\n     */\n    protected static final int INFINITY = 3;\n\n    /**\n     * Simple date format for the creation date ISO 8601 representation\n     * (partial).\n     */\n    protected static final ThreadLocal<SimpleDateFormat> CREATION_DATE_FORMAT = new ThreadLocal<SimpleDateFormat>(){\n\t\t@Override\n        protected SimpleDateFormat initialValue() {\n\t\t\tSimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\n\t\t\tformat.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n\t\t\treturn format;\n        }\n    };\n\n    /**\n     * Simple date format for the last modified date. (RFC 822 updated by RFC\n     * 1123)\n     */\n    protected static final ThreadLocal<SimpleDateFormat> LAST_MODIFIED_DATE_FORMAT = new ThreadLocal<SimpleDateFormat>(){\n\t\t@Override\n        protected SimpleDateFormat initialValue() {\n\t\t\tSimpleDateFormat format = new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss z\", Locale.US);\n\t\t\tformat.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n\t\t\treturn format;\n        }    \t    \t\n    };\n\n    /**\n     * size of the io-buffer\n     */\n    protected static int BUF_SIZE = 65536;\n\n    /**\n     * Default lock timeout value.\n     */\n    protected static final int DEFAULT_TIMEOUT = 3600;\n\n    /**\n     * Maximum lock timeout.\n     */\n    protected static final int MAX_TIMEOUT = 604800;\n\n    /**\n     * Boolean value to temporary lock resources (for method locks)\n     */\n    protected static final boolean TEMPORARY = true;\n\n    /**\n     * Timeout for temporary locks\n     */\n    protected static final int TEMP_TIMEOUT = 10;\n\n    /**\n     * To be implemented by concrete method.\n     * @param requestContext\n     * @param req\n     * @param resp\n     * @throws IOException\n     * @throws LockFailedException\n     */\n    public abstract void execute(\n    \tRequestContext requestContext \n    ) throws IOException, LockFailedException;\n    \n    /**\n     * Return the relative path associated with this servlet.\n     * \n     * @param request\n     *      The servlet request we are processing\n     */\n    protected String getRelativePath(\n    \tRequestContext requestContext\n    ) {\n    \tHttpServletRequest req = requestContext.getHttpServletRequest();\n    \treturn req.getServletPath();\n    }\n\n    protected String getRelativePath(\n    \tRequestContext requestContext,\n    \tString absolutePath\n    ) {\n    \tHttpServletRequest req = requestContext.getHttpServletRequest();\n    \tString contextPath = req.getContextPath();\n    \tint pos = absolutePath.indexOf(contextPath);\n    \treturn pos > 0 ?\n    \t\tabsolutePath.substring(pos + contextPath.length()) :\n    \t\t\tabsolutePath;\n    }\n    \t\n    /**\n     * creates the parent path from the given path by removing the last '/' and\n     * everything after that\n     * \n     * @param path\n     *      the path\n     * @return parent path\n     */\n    protected String getParentPath(\n    \tString path\n    ) {\n        int slash = path.lastIndexOf('/');\n        if (slash != -1) {\n            return path.substring(0, slash);\n        }\n        return null;\n    }\n\n    /**\n     * removes a / at the end of the path string, if present\n     * \n     * @param path\n     *      the path\n     * @return the path without trailing /\n     */\n    protected String getCleanPath(\n    \tString path\n    ) {\n        if (path.endsWith(\"/\") && path.length() > 1)\n            path = path.substring(0, path.length() - 1);\n        return path;\n    }\n\n    /**\n     * Get XML document builder.\n     * \n     * @return\n     * @throws ServiceException\n     */\n    protected DocumentBuilder getDocumentBuilder(\n    ) throws ServiceException {\n        DocumentBuilder documentBuilder = null;\n        DocumentBuilderFactory documentBuilderFactory = null;\n        documentBuilderFactory = DocumentBuilderFactory.newInstance();\n        documentBuilderFactory.setNamespaceAware(true);\n        // Flags required to prevent XML eXternal Entity injection (XXE)\n        try {\n        \tdocumentBuilderFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n        } catch (ParserConfigurationException e) {\n            throw new ServiceException(e);\n        }\n        try {\n        \tdocumentBuilderFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        } catch (ParserConfigurationException e) {\n            throw new ServiceException(e);\n        }\n        try {\n        \tdocumentBuilderFactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n        } catch (ParserConfigurationException e) {\n            throw new ServiceException(e);\n        }\n        try {\n        \tdocumentBuilderFactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n        } catch (ParserConfigurationException e) {\n            throw new ServiceException(e);\n        }\n        try {\n        \tdocumentBuilder = documentBuilderFactory.newDocumentBuilder();\n        } catch (ParserConfigurationException e) {\n            throw new ServiceException(e);\n        }\n        return documentBuilder;\n    }\n\n    /**\n     * Reads the depth header from the request and returns it as a int.\n     * \n     * @param req\n     * @return the depth from the depth header\n     */\n    protected int getDepth(\n    \tRequestContext requestContext\n    ) {\n    \tHttpServletRequest req = requestContext.getHttpServletRequest();\n        int depth = 1; // default is 1\n        String depthStr = req.getHeader(\"Depth\");\n        if(depthStr != null) {\n        \ttry {\n        \t\tdepth = Integer.parseInt(depthStr);\n        \t} catch(Exception ignore) {}\n        }\n        return depth;\n    }\n\n    /**\n     * URL rewriter.\n     * \n     * @param path\n     *      Path which has to be rewritten\n     * @return the rewritten path\n     */\n    protected String encodeURL(\n    \tHttpServletResponse resp,\n    \tString path\n    ) {    \t\n    \tpath = path.replace(\"%\", \"%25\");\n   \t\tpath = path.replace(\" \", \"%20\");\n   \t\tpath = XMLEncoder.encode(path);\n   \t\treturn path;\n    }\n\n    protected String getHRef(\n    \tHttpServletRequest req,\n    \tString suffix,\n    \tboolean isCollection\n    ) {\n        String href = req.getContextPath();\n        if ((href.endsWith(\"/\")) && (suffix.startsWith(\"/\"))) {\n            href += suffix.substring(1);\n        }\n        else {\n            href += suffix;\n        }\n        if ((isCollection) && (!href.endsWith(\"/\"))) {\n            href += \"/\";\n        }\n        return href;\n    }\n    \n    /**\n     * Get the ETag associated with a resource.\n     * \n     * @param so\n     *      StoredObject to get resourceLength, lastModified and a hashCode of\n     *      StoredObject\n     * @return the ETag\n     */\n    protected String getETag(Resource so) {\n\n        Date lastModified = new Date();\n        if (so != null && so.getLastModified() != null) {        \t\n            lastModified = so.getLastModified();\n        }\n        return \"W/\\\"\" + Long.toString(lastModified.getTime()) + \"\\\"\";\n    }\n\n    protected String getVersion(\n    ) {\n    \treturn \"1, 2\";\n    }\n        \n    protected String[] getLockIdFromIfHeader(\n    \tRequestContext requestContext\n    ) {\n    \tHttpServletRequest req = requestContext.getHttpServletRequest();\n        String[] ids = new String[2];\n        String id = req.getHeader(\"If\");\n\n        if (id != null && !id.equals(\"\")) {\n            if (id.indexOf(\">)\") == id.lastIndexOf(\">)\")) {\n                id = id.substring(id.indexOf(\"(<\"), id.indexOf(\">)\"));\n\n                if (id.indexOf(\"locktoken:\") != -1) {\n                    id = id.substring(id.indexOf(':') + 1);\n                }\n                ids[0] = id;\n            } else {\n                String firstId = id.substring(id.indexOf(\"(<\"), id.indexOf(\">)\"));\n                if (firstId.indexOf(\"locktoken:\") != -1) {\n                    firstId = firstId.substring(firstId.indexOf(':') + 1);\n                }\n                ids[0] = firstId;\n\n                String secondId = id.substring(id.lastIndexOf(\"(<\"), id\n                        .lastIndexOf(\">)\"));\n                if (secondId.indexOf(\"locktoken:\") != -1) {\n                    secondId = secondId.substring(secondId.indexOf(':') + 1);\n                }\n                ids[1] = secondId;\n            }\n\n        } else {\n            ids = null;\n        }\n        return ids;\n    }\n\n    /**\n     * Get lock token.\n     * \n     * @param requestContext\n     * @return\n     */\n    protected String getLockIdFromLockTokenHeader(\n    \tRequestContext requestContext\n    ) {\n    \tHttpServletRequest req = requestContext.getHttpServletRequest();\n        String id = req.getHeader(\"Lock-Token\");\n        if (id != null) {\n            id = id.substring(id.indexOf(\":\") + 1, id.indexOf(\">\"));\n\n        }\n        return id;\n    }\n\n    /**\n     * Checks if locks on resources at the given path exists and if so checks\n     * the If-Header to make sure the If-Header corresponds to the locked\n     * resource. Returning true if no lock exists or the If-Header is\n     * corresponding to the locked resource\n     * \n     * @param req\n     *      Servlet request\n     * @param resp\n     *      Servlet response\n     * @param store\n     * @param path\n     *      path to the resource\n     * @return true if no lock on a resource with the given path exists or if\n     *  the If-Header corresponds to the locked resource\n     * @throws IOException\n     * @throws LockFailedException\n     */\n    protected boolean checkLocks(\n    \tRequestContext requestContext,\n        WebDavStore store, \n        String path\n    ) throws IOException, LockFailedException {\n        List<Lock> losByPath = store.getLocksByPath(requestContext, path);\n        for(Lock lo: losByPath) {\n            if(!Lock.SCOPE_SHARED.equals(lo.getScope())) {\n\t            // the resource is locked\n\t            String[] lockTokens = getLockIdFromIfHeader(requestContext);\n\t            String lockToken = null;\n\t            if (lockTokens != null)\n\t                lockToken = lockTokens[0];\n\t            else {\n\t                return false;\n\t            }\n\t            if(lockToken != null) {\n\t                if (!lockToken.equals(lo.getID())) {\n\t                    return false;\n\t                }\n\t            }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Send a multistatus element containing a complete error report to the\n     * client.\n     * \n     * @param req\n     *      Servlet request\n     * @param resp\n     *      Servlet response\n     * @param errorList\n     *      List of error to be displayed\n     */\n    protected void sendReport(\n    \tRequestContext requestContext,\n        Hashtable<String, Integer> errorList\n     ) throws IOException {\n    \tHttpServletResponse resp = requestContext.getHttpServletResponse();\n    \tHttpServletRequest req = requestContext.getHttpServletRequest();\n        resp.setStatus(WebdavStatus.SC_MULTI_STATUS);\n        String absoluteUri = req.getRequestURI();\n        // String relativePath = getRelativePath(req);\n        HashMap<String, String> namespaces = new HashMap<String, String>();\n        namespaces.put(\"DAV:\", \"D\");\n        XMLWriter writer = new XMLWriter(resp.getWriter(), namespaces);\n        writer.writeXMLHeader();\n        writer.writeElement(\"DAV::multistatus\", XMLWriter.OPENING);\n        Enumeration<String> pathList = errorList.keys();\n        while (pathList.hasMoreElements()) {\n            String errorPath = pathList.nextElement();\n            int errorCode = errorList.get(errorPath);\n            writer.writeElement(\"DAV::response\", XMLWriter.OPENING);\n            writer.writeElement(\"DAV::href\", XMLWriter.OPENING);\n            String toAppend = null;\n            if (absoluteUri.endsWith(errorPath)) {\n                toAppend = absoluteUri;\n            } else if (absoluteUri.contains(errorPath)) {\n                int endIndex = absoluteUri.indexOf(errorPath) + errorPath.length();\n                toAppend = absoluteUri.substring(0, endIndex);\n            }\n            if (!toAppend.startsWith(\"/\") && !toAppend.startsWith(\"http:\")) {\n                toAppend = \"/\" + toAppend;\n            }\n            writer.writeText(errorPath);\n            writer.writeElement(\"DAV::href\", XMLWriter.CLOSING);\n            writer.writeElement(\"DAV::status\", XMLWriter.OPENING);\n            writer.writeText(\"HTTP/1.1 \" + errorCode);\n            writer.writeElement(\"DAV::status\", XMLWriter.CLOSING);\n            writer.writeElement(\"DAV::response\", XMLWriter.CLOSING);\n        }\n        writer.writeElement(\"DAV::multistatus\", XMLWriter.CLOSING);\n        writer.sendData();\n    }\n\n    protected String getNullResourceMethodsAllowed(\n    ) {\n    \treturn NULL_RESOURCE_METHODS_ALLOWED;\n    }\n    \n    protected String getResourceMethodsAllowed(\n    ) {\n    \treturn RESOURCE_METHODS_ALLOWED;\n    }\n    \n    public String getFolderMethodsAllowed(\n    ) {\n    \treturn FOLDER_METHODS_ALLOWED;\n    }\n    \n    public String getDefaultMethodsAllowed(\n    ) {\n    \treturn DEFAULT_METHODS_ALLOWED;\n    }\n    \n    /**\n     * Determines the methods normally allowed for the resource.\n     * \n     * @param so\n     *      StoredObject representing the resource\n     * @return all allowed methods, separated by commas\n     */\n    protected String determineMethodsAllowed(\n    \tResource so\n    ) {\n        try {\n            if (so != null) {\n                if (so.isCollection()) {\n                    return this.getDefaultMethodsAllowed() + \", \" + this.getResourceMethodsAllowed() + \", \" + this.getFolderMethodsAllowed();\n                } else {\n                \treturn this.getDefaultMethodsAllowed() + \", \" + getResourceMethodsAllowed();\n                }\n            }\n        } catch (Exception e) {\n            // we do nothing, just return default allowed methods\n        }\n        return getDefaultMethodsAllowed();\n    }\n\n    //-----------------------------------------------------------------------\n    // Members\n    //-----------------------------------------------------------------------\n    private static final String NULL_RESOURCE_METHODS_ALLOWED = \"OPTIONS, MKCOL, PUT, PROPFIND, LOCK, UNLOCK\";\n    private static final String RESOURCE_METHODS_ALLOWED = \"OPTIONS, GET, HEAD, POST, DELETE, TRACE, PROPPATCH, COPY, MOVE, LOCK, UNLOCK, PROPFIND\";\n    private static final String FOLDER_METHODS_ALLOWED = \"PUT\";\n    private static final String DEFAULT_METHODS_ALLOWED = \"OPTIONS, MKCOL, PUT\";\n    \n}\n"], "filenames": ["core/src/main/java/org/opencrx/application/uses/net/sf/webdav/methods/WebDavMethod.java"], "buggy_code_start_loc": [224], "buggy_code_end_loc": [234], "fixing_code_start_loc": [224], "fixing_code_end_loc": [258], "type": "CWE-611", "message": "An issue in openCRX v.5.2.2 allows a remote attacker to read internal files and execute server side request forgery attack via insecure DocumentBuilderFactory.", "other": {"cve": {"id": "CVE-2023-46502", "sourceIdentifier": "cve@mitre.org", "published": "2023-10-30T23:15:08.857", "lastModified": "2023-11-06T20:15:07.887", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue in openCRX v.5.2.2 allows a remote attacker to read internal files and execute server side request forgery attack via insecure DocumentBuilderFactory."}, {"lang": "es", "value": "Un problema en openCRX v.5.2.2 permite a un atacante remoto leer archivos internos y ejecutar un ataque de server side request forgery a trav\u00e9s de DocumentBuilderFactory inseguro."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-611"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opencrx:opencrx:5.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "48588E81-A740-476B-9177-A08EF2430A28"}]}]}], "references": [{"url": "https://gist.github.com/spookhorror/9519fc66d3946e887e4a86c06ddbee0e", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/opencrx/opencrx/commit/ce7a71db0bb34ecbcb0e822d40598e410a48b399", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/opencrx/opencrx/commit/ce7a71db0bb34ecbcb0e822d40598e410a48b399"}}