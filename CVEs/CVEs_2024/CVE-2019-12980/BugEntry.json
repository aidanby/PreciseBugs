{"buggy_code": ["/*\n    Ming, an SWF output library\n    Copyright (C) 2002  Opaque Industries - http://www.opaque.net/\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\n/* $Id$ */\n\n#ifndef __C2MAN__\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/stat.h>\n#endif\n\n#ifndef WIN32\n#include <unistd.h>\n#endif\n\n#include \"libming.h\"\n#include \"input.h\"\n#include \"method.h\"\n#include \"error.h\"\n\n\nstruct SWFInput_s\n{\n\tvoid (*destroy)(SWFInput This);\n\tint (*getChar)(SWFInput This);\n\tint (*read)(SWFInput This, unsigned char* buffer, int count);\n\tvoid (*seek)(SWFInput This, long offset, int whence);\n\tint (*eof)(SWFInput This);\n\n\tint offset;\n\tint length;\n\tvoid *data;\n#if TRACK_ALLOCS\n\t/* memory node for garbage collection */\n\tmem_node *gcnode;\n#endif\n\tint buffer;\n\tint bufbits;\n};\n\nvoid\nSWFInput_byteAlign(SWFInput input)\n{\n\tif(input->bufbits > 0)\n\t{\n\t\tinput->bufbits = 0;\n\t\tinput->buffer = 0;\n\t}\n}\n\nint\nSWFInput_readBits(SWFInput input, int number)\n{\n\tint ret = input->buffer;\n\tif ( number == input->bufbits )\n\t{\n\t\tinput->bufbits = 0;\n\t\tinput->buffer = 0;\n\t\treturn ret;\n\t}\n\n\tif ( number > input->bufbits )\n\t{\n\t\tnumber -= input->bufbits;\n\n\t\twhile( number > 8 )\n\t\t{\n\t\t\tret <<= 8;\n\t\t\tret += SWFInput_getChar(input);\n\t\t\tnumber -= 8;\n\t\t}\n\t\t\n\t\tinput->buffer = SWFInput_getChar(input);\n\t\t\n\t\tif ( number > 0 )\n\t\t{\n\t\t\tret <<= number;\n\t\t\tinput->bufbits = 8-number;\n\t\t\tret += input->buffer >> (8-number);\n\t\t\tinput->buffer &= (1<<input->bufbits)-1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tret = input->buffer >> (input->bufbits-number);\n\tinput->bufbits -= number;\n\tinput->buffer &= (1<<input->bufbits)-1;\n//\tprintf(\"done: readBits(%i) numer < bufbits %i\\n\", number, ret);\n\treturn ret;\n}\n\nint \nSWFInput_readSBits(SWFInput input, int number)\n{\n\tint num = SWFInput_readBits(input, number);\n\n\tif ( num & (1<<(number-1)) )\n\t\treturn num - (1<<number);\n\telse\n\t\treturn num;\n}\n\nint\nSWFInput_getChar(SWFInput input)\n{\n\treturn input->getChar(input);\n}\n\n\nint\nSWFInput_getUInt16(SWFInput input)\n{\n\tint num = SWFInput_getChar(input);\n\tnum += SWFInput_getChar(input) << 8;\n\treturn num;\n}\n\n\nint\nSWFInput_getUInt16_BE(SWFInput input)\n{\n\tint num = SWFInput_getChar(input) << 8;\n\tnum += SWFInput_getChar(input);\n\treturn num;\n}\n\n\nint\nSWFInput_getSInt16(SWFInput input)\n{\n\tint num = SWFInput_getChar(input);\n\tnum += SWFInput_getChar(input) * 256;\n\treturn num;\n}\n\n\nunsigned long \nSWFInput_getUInt24_BE(SWFInput input)\n{\n\tunsigned long num = SWFInput_getChar(input) << 16;\n\tnum += SWFInput_getChar(input) << 8;\n\tnum += SWFInput_getChar(input);\n\treturn num;\n}\n\nunsigned long\nSWFInput_getUInt32(SWFInput input)\n{\n\tunsigned long num = SWFInput_getChar(input);\n\tnum += SWFInput_getChar(input) << 8;\n\tnum += SWFInput_getChar(input) << 16;\n\tnum += SWFInput_getChar(input) << 24;\n\treturn num;\n}\n\n\nunsigned long\nSWFInput_getUInt32_BE(SWFInput input)\n{\n\tunsigned long num = SWFInput_getChar(input) << 24;\n\tnum += SWFInput_getChar(input) << 16;\n\tnum += SWFInput_getChar(input) << 8;\n\tnum += SWFInput_getChar(input);\n\treturn num;\n}\n\n\nint\nSWFInput_read(SWFInput input, unsigned char* buffer, int count)\n{\n\treturn input->read(input, buffer, count);\n}\n\n\nvoid\nSWFInput_seek(SWFInput input, long offset, int whence)\n{\n\tinput->seek(input, offset, whence);\n}\n\n\nint\nSWFInput_length(SWFInput input)\n{\n\tint pos = SWFInput_tell(input);\n\n\tSWFInput_seek(input, 0, SEEK_END);\n\tSWFInput_seek(input, pos, SEEK_SET);\n\n\treturn input->length;\n}\n\n\nint\nSWFInput_eof(SWFInput input)\n{\n\treturn input->eof(input);\n}\n\n\nint\nSWFInput_tell(SWFInput input)\n{\n\treturn input->offset;\n}\n\n\nvoid\nSWFInput_rewind(SWFInput input)\n{\n\tSWFInput_seek(input, 0, SEEK_SET);\n}\n\n\nvoid\ndestroySWFInput(SWFInput input)\n{\n\tinput->destroy(input);\n}\n\n\nstatic void\nSWFInput_dtor(SWFInput input)\n{\n#if TRACK_ALLOCS\n\tming_gc_remove_node(input->gcnode);\n#endif\n\tfree(input);\n}\n\n\n/* SWFInput_file */\n\nstatic void\nSWFInput_file_seek(SWFInput input, long offset, int whence)\n{\n\tif ( fseek((FILE *)input->data, offset, whence) == -1 )\n\t{\n\t\tif ( errno == EBADF )\n\t\t\tSWF_error(\"This is not a seekable stream- use newSWFInput_stream instead\");\n\t\telse if ( errno == EINVAL )\n\t\t\tSWF_error(\"Invalid whence argument\");\n\t\telse\n\t\t\tSWF_error(\"Unknown error\");\n\t}\n\n\tif ( whence == SEEK_SET )\n\t\tinput->offset = offset;\n\n\telse if ( whence == SEEK_END )\n\t\tinput->offset = input->length - offset;\n\n\telse if ( whence == SEEK_CUR )\n\t\tinput->offset += offset;\n}\n\n\nstatic int\nSWFInput_file_eof(SWFInput input)\n{\n\treturn feof((FILE *)input->data);\n}\n\n\nstatic int\nSWFInput_file_getChar(SWFInput input)\n{\n\tint c = fgetc((FILE *)input->data);\n\n\tif ( c == EOF )\n\t\tinput->length = input->offset;\n\telse\n\t\t++input->offset;\n\n\treturn c;\n}\n\nstatic int SWFInput_file_read(SWFInput input, unsigned char *buffer, int count)\n{\tint len = fread(buffer, 1, count, (FILE *)input->data);\n\tinput->offset += len;\n\treturn len;\n}\n\nSWFInput\nnewSWFInput_file(FILE *f)\n{\n\tSWFInput input;\n\tstruct stat buf;\n\n\t/* XXX - doesn't check for validity of f.. */\n\n\tif ( fseek(f, 0, SEEK_CUR) == -1 )\n\t\treturn newSWFInput_stream(f);\n\n\tif ( fstat(fileno(f), &buf) == -1 )\n\t\tSWF_error(\"Couldn't fstat filehandle in newSWFInput_file\");;\n\n\tinput = (SWFInput) malloc(sizeof(struct SWFInput_s));\n\n\t/* If malloc failed, return NULL to signify this */\n\tif (NULL == input)\n\t\treturn NULL;\n\n\tinput->getChar = SWFInput_file_getChar;\n\tinput->destroy = SWFInput_dtor;\n\tinput->eof = SWFInput_file_eof;\n\tinput->seek = SWFInput_file_seek;\n\tinput->read = SWFInput_file_read;\n\tinput->data = f;\n\tinput->bufbits = 0;\n\tinput->buffer = 0;\n\tinput->offset = 0;\n\tinput->length = buf.st_size;\n\n#if TRACK_ALLOCS\n\tinput->gcnode = ming_gc_add_node(input, (dtorfunctype) destroySWFInput);\n#endif\n\n\treturn input;\n}\n\nstatic void SWFInput_dtor_close(SWFInput input)\n{\n\tfclose((FILE *)input->data);\n\tSWFInput_dtor(input);\n}\n\n\nSWFInput\nnewSWFInput_filename(const char *filename)\n{\n\tFILE *file;\n\tSWFInput input;\n\t\n\tfile = fopen(filename, \"rb\");\n\tif(file == NULL)\n\t{\n\t\tSWF_warn(\"newSWFInput_filename: %s: %s\\n\",\n\t\t\tfilename, strerror(errno));\n\t\treturn NULL;\n\t}\n\n\tinput = newSWFInput_file(file);\n\tif(input == NULL)\n\t\treturn NULL;\n\n\tinput->destroy = SWFInput_dtor_close;\n\treturn input;\n}\n\n\n/* SWFInput_buffer */\n\nstatic int\nSWFInput_buffer_getChar(SWFInput input)\n{\n\tif ( input->offset >= input->length )\n\t\treturn EOF;\n\telse\n\t\treturn ((unsigned char *)input->data)[input->offset++];\n}\n\n\nstatic int\nSWFInput_buffer_eof(SWFInput input)\n{\n\treturn input->offset >= input->length;\n}\n\n\nstatic int\nSWFInput_buffer_read(SWFInput input, unsigned char* buffer, int count)\n{\n\tif ( count > input->length - input->offset )\n\t\tcount = input->length - input->offset;\n\n\tmemcpy(buffer, (unsigned char*)input->data + input->offset, count);\n\tinput->offset += count;\n\n\treturn count;\n}\n\n\nstatic void\nSWFInput_buffer_seek(SWFInput input, long offset, int whence)\n{\n\tif ( whence == SEEK_CUR )\n\t{\n\t\tif ( offset >= 0 )\n\t\t\tinput->offset = min(input->length, input->offset + offset);\n\t\telse\n\t\t\tinput->offset = max(0, input->offset + offset);\n\t}\n\n\telse if ( whence == SEEK_END )\n\t\tinput->offset = max(0, input->length - offset);\n\n\telse if ( whence == SEEK_SET )\n\t\tinput->offset = min(input->length, offset);\n}\n\n\nSWFInput\nnewSWFInput_buffer(unsigned char* buffer, int length)\n{\n\tSWFInput input = (SWFInput) malloc(sizeof(struct SWFInput_s));\n\n\t/* If malloc failed, return NULL to signify this */\n\tif (NULL == input)\n\t\treturn NULL;\n\n\tinput->getChar = SWFInput_buffer_getChar;\n\tinput->destroy = SWFInput_dtor;\n\tinput->eof = SWFInput_buffer_eof;\n\tinput->read = SWFInput_buffer_read;\n\tinput->seek = SWFInput_buffer_seek;\n\tinput->data = buffer;\n\tinput->buffer = 0;\n\tinput->bufbits = 0;\n\tinput->offset = 0;\n\tinput->length = length;\n\n#if TRACK_ALLOCS\n\tinput->gcnode = ming_gc_add_node(input, (dtorfunctype) destroySWFInput);\n#endif\n\n\treturn input;\n}\n\n\nstatic void\nSWFInput_buffer_dtor(SWFInput input)\n{\n\tfree(input->data);\n#if TRACK_ALLOCS\n\tming_gc_remove_node(input->gcnode);\n#endif\n\tfree(input);\n}\n\n\n/* same as above but needs to be freed */\nSWFInput\nnewSWFInput_allocedBuffer(unsigned char *buffer, int length)\n{\n\tSWFInput input = newSWFInput_buffer(buffer, length);\n\tinput->destroy = SWFInput_buffer_dtor;\n#if TRACK_ALLOCS\n\tinput->gcnode = ming_gc_add_node(input, (dtorfunctype) destroySWFInput);\n#endif\n\treturn input;\n}\n\n/* same as above but copy buffer and  needs to be freed */\nSWFInput\nnewSWFInput_bufferCopy(unsigned char *buffer, int length)\n{\n\tSWFInput input;\n\tunsigned char *data = (unsigned char *)malloc(length);\n\tif(data == NULL)\n\t\treturn NULL;\n\n\tmemcpy(data, buffer, length);\n\tinput = newSWFInput_buffer(data, length);\n\tinput->destroy = SWFInput_buffer_dtor;\n#if TRACK_ALLOCS\n\tinput->gcnode = ming_gc_add_node(input, (dtorfunctype) destroySWFInput);\n#endif\n\treturn input;\n}\n\n\n\n\n/* SWFInput_stream */\n\n#define INPUTSTREAM_INCREMENT 32768\n#define MAX_INPUTSTREAM (32*1024*1024) // 32 mb\n\nstruct SWFInputStreamData\n{\n\tFILE *file;\n\tunsigned char *buffer;\n};\n\n\nstatic void\nSWFInput_stream_seek(SWFInput input, long offset, int whence)\n{\n\tint len, l, readOffset;\n\tstruct SWFInputStreamData *data;\n\n\tif ( whence == SEEK_CUR )\n\t\tinput->offset = input->offset + offset;\n\n\telse if ( whence == SEEK_SET )\n\t\tinput->offset = offset;\n\n\telse if ( whence == SEEK_END )\n\t{\n\t\t/* suck data until EOF */\n\t\t/* XXX - might want to put a limit on how much we suck (ha) */\n\n\t\twhile ( SWFInput_getChar(input) != EOF )\n\t\t\tif (input->length > MAX_INPUTSTREAM)\n\t\t\t\tbreak;\n\n\t\tinput->offset = input->length - offset;\n\t}\n\n\tif (input->offset < 0)\n\t\tinput->offset = 0;\n\n\tif ( input->offset < input->length )\n\t\treturn;\n\n\t/* now slurp up as much data as we need to get here */\n\n\tlen = (((input->offset - input->length)/INPUTSTREAM_INCREMENT)+1) * INPUTSTREAM_INCREMENT;\n\n\treadOffset = input->length;\n\tinput->length += len;\n\tdata = (struct SWFInputStreamData*) input->data;\n\n\tdata->buffer = (unsigned char*)realloc(data->buffer, sizeof(unsigned char) * (input->length + len));\n\n\tl=1; /* just to initialize to something */\n\twhile((len > 0) && (l > 0))\n\t{\n\t\tl = fread(data->buffer, sizeof(unsigned char), len, data->file);\n\t\tlen -= l;\n\t\treadOffset += l;\n\t}\n}\n\n\nstatic int\nSWFInput_stream_getChar(SWFInput input)\n{\n\tstruct SWFInputStreamData *data = (struct SWFInputStreamData *) input->data;\n\n\tif (input->offset >= MAX_INPUTSTREAM)\n\t\treturn EOF;\n\n\tif ( input->offset == input->length )\n\t{\n\t\t/* fetch from stream, save in buffer */\n\n\t\tFILE *f = data->file;\n\t\tint c = fgetc(f);\n\n\t\t++input->offset;\n\n\t\tif ( c != EOF )\n\t\t{\n\t\t\tif ( input->length % INPUTSTREAM_INCREMENT == 0 )\n\t\t\t{\n\t\t\t\tdata->buffer = (unsigned char*) realloc(data->buffer,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t sizeof(unsigned char) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (input->length + INPUTSTREAM_INCREMENT));\n\t\t\t}\n\n\t\t\tdata->buffer[input->length] = c;\n\t\t\t++input->length;\n\t\t}\n\n\t\treturn c;\n\t}\n\telse if ( input->offset < input->length )\n\t{\n\t\t/* fetch from buffer */\n\t\treturn data->buffer[input->offset++];\n\t}\n\telse\n\t\treturn EOF;\n}\n\n\nstatic int\nSWFInput_stream_read(SWFInput input, unsigned char* buffer, int count)\n{\n\tstruct SWFInputStreamData *data = (struct SWFInputStreamData *) input->data;\n\tint need = input->offset + count - input->length;\n\n\tif ( need > 0 )\n\t{\n\t\tint num;\n\n\t\tdata->buffer =\n\t\t\t(unsigned char*) realloc(data->buffer,\n\t\t\t\t\t\t\tsizeof(unsigned char) * INPUTSTREAM_INCREMENT *\n\t\t\t\t\t\t\t(((input->offset + count) / INPUTSTREAM_INCREMENT) + 1));\n\t\t\n\t\tnum = fread(data->buffer + input->length,\n\t\t\t\t\t\t\t\tsizeof(unsigned char), need, data->file);\n\n\t\tinput->length += num;\n\t}\n\n\tif ( count > input->length - input->offset )\n\t\tcount = input->length - input->offset;\n\n\tmemcpy(buffer, data->buffer + input->offset, count);\n\n\treturn count;\n}\n\n\n\n\nstatic void\nSWFInput_stream_dtor(SWFInput input)\n{\n\tfree(input->data);\n#if TRACK_ALLOCS\n\tming_gc_remove_node(input->gcnode);\n#endif\n\tfree(input);\n}\n\nstatic int SWFInput_stream_eof(SWFInput input)\n{\n\treturn ((input->offset >= input->length) ? feof((FILE *)input->data) : 0);\n}\n\nSWFInput\nnewSWFInput_stream(FILE* f)\n{\n\tSWFInput input = (SWFInput)malloc(sizeof(struct SWFInput_s));\n\tstruct SWFInputStreamData *data;\n\n\t/* If malloc failed, return NULL to signify this */\n\tif (NULL == input)\n\t\treturn NULL;\n\n\tdata = (struct SWFInputStreamData *)malloc(sizeof(struct SWFInputStreamData));\n\n\t/* If malloc failed, free memory allocated for input and return NULL to signify the failure */\n\tif (NULL == data)\n\t{\n\t\tfree(input);\n\t\treturn NULL;\n\t}\n\n\tinput->getChar = SWFInput_stream_getChar;\n\tinput->destroy = SWFInput_stream_dtor;\n\tinput->eof = SWFInput_stream_eof;\n\tinput->read = SWFInput_stream_read;\n\tinput->seek = SWFInput_stream_seek;\n\n\tinput->offset = 0;\n\tinput->length = 0;\n\tinput->buffer = 0;\n\tinput->bufbits = 0;\n\n\tdata->file = f;\n\tdata->buffer = NULL;\n\n\tinput->data = (void *)data;\n\n#if TRACK_ALLOCS\n\tinput->gcnode = ming_gc_add_node(input, (dtorfunctype) destroySWFInput);\n#endif\n\n\treturn input;\n}\n\n\nstruct SWFInputPtr\n{\n\tSWFInput input;\n\tunsigned int offset;\n};\n\nstatic int\nSWFInput_input_getChar(SWFInput input)\n{\n\tstruct SWFInputPtr *ptr;\n \tint old_offset, result;\n\n\tif ( input->offset >= input->length )\n\t\treturn EOF;\n\t\t\n\tptr = (struct SWFInputPtr *)input->data;\n\told_offset = SWFInput_tell(ptr->input);\n \n\tSWFInput_seek(ptr->input, ptr->offset + input->offset, SEEK_SET);\n\tresult = SWFInput_getChar(ptr->input);\n\tinput->offset++;\n\tSWFInput_seek(ptr->input, old_offset, SEEK_SET);\n\n\treturn result;\n}\n\n\nstatic void\nSWFInput_input_seek(SWFInput input, long offset, int whence)\n{\n\tif ( whence == SEEK_CUR )\n\t{\n\t\tif ( offset >= 0 )\n\t\t\tinput->offset = min(input->length, input->offset + offset);\n\t\telse\n\t\t\tinput->offset = max(0, input->offset + offset);\n\t}\n\n\telse if ( whence == SEEK_END )\n\t\tinput->offset = max(0, input->length - offset);\n\n\telse if ( whence == SEEK_SET )\n\t\tinput->offset = min(input->length, offset);\n}\n\n\nstatic int\nSWFInput_input_eof(SWFInput input)\n{\n\treturn input->offset >= input->length;\n}\n\nstatic void\nSWFInput_input_dtor(SWFInput input)\n{\n\tfree(input->data);\n#if TRACK_ALLOCS\n\tming_gc_remove_node(input->gcnode);\n#endif\n\tfree(input);\n}\n\n\nstatic int\nSWFInput_input_read(SWFInput input, unsigned char* buffer, int count)\n{\n\tint ret;\n\tstruct SWFInputPtr *ptr;\n\tint old_offset;\n\n\tif ( count > input->length - input->offset )\n\t\tcount = input->length - input->offset;\n\n\tptr = (struct SWFInputPtr *)input->data;\n        old_offset = SWFInput_tell(ptr->input);\n\tSWFInput_seek(ptr->input, ptr->offset + input->offset, SEEK_SET);\n\n\tret = SWFInput_read((SWFInput)ptr->input, buffer, count);\n\tif(ret != count)\n\t\tSWF_warn(\"SWFInput_input_read: ret %i, count %i\\n\", ret, count);\n\tinput->offset += count;\n\n\tSWFInput_seek(ptr->input, old_offset, SEEK_SET);\n\n\treturn count;\n}\n\nSWFInput\nnewSWFInput_input(SWFInput in, unsigned int length)\n{\n\tSWFInput input;\n\tstruct SWFInputPtr *data;\n\n\tif (in == NULL)\n\t\treturn NULL;\n\n\tinput = (SWFInput)malloc(sizeof(struct SWFInput_s));\n\n\t/* If malloc failed, return NULL to signify this */\n\tif (NULL == input)\n\t\treturn NULL;\n\n\tinput->getChar = SWFInput_input_getChar;\n\tinput->destroy = SWFInput_input_dtor;\n\tinput->eof = SWFInput_input_eof;\n\tinput->read = SWFInput_input_read;\n\tinput->seek = SWFInput_input_seek;\n\n\tdata = (struct SWFInputPtr *)malloc(sizeof(struct SWFInputPtr));\n\n\t/* If malloc failed, free memory allocated for input and return NULL to signify the failure */\n\tif (NULL == data)\n\t{\n\t\tfree(input);\n\t\treturn NULL;\n\t}\n\n\tdata->offset = SWFInput_tell(in);\n\tdata->input = in;\n\n\tinput->offset = 0;\n\tinput->length = length;\n\n\tinput->data = (void *)data;\n\tinput->buffer = 0;\n\tinput->bufbits = 0;\n#if TRACK_ALLOCS\n\tinput->gcnode = ming_gc_add_node(input, (dtorfunctype) destroySWFInput);\n#endif\n\n\treturn input;\n}\n/*\n * Local variables:\n * tab-width: 2\n * c-basic-offset: 2\n * End:\n */\n"], "fixing_code": ["/*\n    Ming, an SWF output library\n    Copyright (C) 2002  Opaque Industries - http://www.opaque.net/\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\n/* $Id$ */\n\n#ifndef __C2MAN__\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/stat.h>\n#endif\n\n#ifndef WIN32\n#include <unistd.h>\n#endif\n\n#include \"libming.h\"\n#include \"input.h\"\n#include \"method.h\"\n#include \"error.h\"\n\n\nstruct SWFInput_s\n{\n\tvoid (*destroy)(SWFInput This);\n\tint (*getChar)(SWFInput This);\n\tint (*read)(SWFInput This, unsigned char* buffer, int count);\n\tvoid (*seek)(SWFInput This, long offset, int whence);\n\tint (*eof)(SWFInput This);\n\n\tint offset;\n\tint length;\n\tvoid *data;\n#if TRACK_ALLOCS\n\t/* memory node for garbage collection */\n\tmem_node *gcnode;\n#endif\n\tint buffer;\n\tint bufbits;\n};\n\nvoid\nSWFInput_byteAlign(SWFInput input)\n{\n\tif(input->bufbits > 0)\n\t{\n\t\tinput->bufbits = 0;\n\t\tinput->buffer = 0;\n\t}\n}\n\nint\nSWFInput_readBits(SWFInput input, int number)\n{\n\tint ret = input->buffer;\n\tif ( number == input->bufbits )\n\t{\n\t\tinput->bufbits = 0;\n\t\tinput->buffer = 0;\n\t\treturn ret;\n\t}\n\n\tif ( number > input->bufbits )\n\t{\n\t\tnumber -= input->bufbits;\n\n\t\twhile( number > 8 )\n\t\t{\n\t\t\tret <<= 8;\n\t\t\tret += SWFInput_getChar(input);\n\t\t\tnumber -= 8;\n\t\t}\n\t\t\n\t\tinput->buffer = SWFInput_getChar(input);\n\t\t\n\t\tif ( number > 0 )\n\t\t{\n\t\t\tret <<= number;\n\t\t\tinput->bufbits = 8-number;\n\t\t\tret += input->buffer >> (8-number);\n\t\t\tinput->buffer &= (1<<input->bufbits)-1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tret = input->buffer >> (input->bufbits-number);\n\tinput->bufbits -= number;\n\tinput->buffer &= (1<<input->bufbits)-1;\n//\tprintf(\"done: readBits(%i) numer < bufbits %i\\n\", number, ret);\n\treturn ret;\n}\n\nint \nSWFInput_readSBits(SWFInput input, int number)\n{\n\tint num = SWFInput_readBits(input, number);\n\n\tif(number && num & (1<<(number-1)))\n\t\treturn num - (1<<number);\n\telse\n\t\treturn num;\n}\n\nint\nSWFInput_getChar(SWFInput input)\n{\n\treturn input->getChar(input);\n}\n\n\nint\nSWFInput_getUInt16(SWFInput input)\n{\n\tint num = SWFInput_getChar(input);\n\tnum += SWFInput_getChar(input) << 8;\n\treturn num;\n}\n\n\nint\nSWFInput_getUInt16_BE(SWFInput input)\n{\n\tint num = SWFInput_getChar(input) << 8;\n\tnum += SWFInput_getChar(input);\n\treturn num;\n}\n\n\nint\nSWFInput_getSInt16(SWFInput input)\n{\n\tint num = SWFInput_getChar(input);\n\tnum += SWFInput_getChar(input) * 256;\n\treturn num;\n}\n\n\nunsigned long \nSWFInput_getUInt24_BE(SWFInput input)\n{\n\tunsigned long num = SWFInput_getChar(input) << 16;\n\tnum += SWFInput_getChar(input) << 8;\n\tnum += SWFInput_getChar(input);\n\treturn num;\n}\n\nunsigned long\nSWFInput_getUInt32(SWFInput input)\n{\n\tunsigned long num = SWFInput_getChar(input);\n\tnum += SWFInput_getChar(input) << 8;\n\tnum += SWFInput_getChar(input) << 16;\n\tnum += SWFInput_getChar(input) << 24;\n\treturn num;\n}\n\n\nunsigned long\nSWFInput_getUInt32_BE(SWFInput input)\n{\n\tunsigned long num = SWFInput_getChar(input) << 24;\n\tnum += SWFInput_getChar(input) << 16;\n\tnum += SWFInput_getChar(input) << 8;\n\tnum += SWFInput_getChar(input);\n\treturn num;\n}\n\n\nint\nSWFInput_read(SWFInput input, unsigned char* buffer, int count)\n{\n\treturn input->read(input, buffer, count);\n}\n\n\nvoid\nSWFInput_seek(SWFInput input, long offset, int whence)\n{\n\tinput->seek(input, offset, whence);\n}\n\n\nint\nSWFInput_length(SWFInput input)\n{\n\tint pos = SWFInput_tell(input);\n\n\tSWFInput_seek(input, 0, SEEK_END);\n\tSWFInput_seek(input, pos, SEEK_SET);\n\n\treturn input->length;\n}\n\n\nint\nSWFInput_eof(SWFInput input)\n{\n\treturn input->eof(input);\n}\n\n\nint\nSWFInput_tell(SWFInput input)\n{\n\treturn input->offset;\n}\n\n\nvoid\nSWFInput_rewind(SWFInput input)\n{\n\tSWFInput_seek(input, 0, SEEK_SET);\n}\n\n\nvoid\ndestroySWFInput(SWFInput input)\n{\n\tinput->destroy(input);\n}\n\n\nstatic void\nSWFInput_dtor(SWFInput input)\n{\n#if TRACK_ALLOCS\n\tming_gc_remove_node(input->gcnode);\n#endif\n\tfree(input);\n}\n\n\n/* SWFInput_file */\n\nstatic void\nSWFInput_file_seek(SWFInput input, long offset, int whence)\n{\n\tif ( fseek((FILE *)input->data, offset, whence) == -1 )\n\t{\n\t\tif ( errno == EBADF )\n\t\t\tSWF_error(\"This is not a seekable stream- use newSWFInput_stream instead\");\n\t\telse if ( errno == EINVAL )\n\t\t\tSWF_error(\"Invalid whence argument\");\n\t\telse\n\t\t\tSWF_error(\"Unknown error\");\n\t}\n\n\tif ( whence == SEEK_SET )\n\t\tinput->offset = offset;\n\n\telse if ( whence == SEEK_END )\n\t\tinput->offset = input->length - offset;\n\n\telse if ( whence == SEEK_CUR )\n\t\tinput->offset += offset;\n}\n\n\nstatic int\nSWFInput_file_eof(SWFInput input)\n{\n\treturn feof((FILE *)input->data);\n}\n\n\nstatic int\nSWFInput_file_getChar(SWFInput input)\n{\n\tint c = fgetc((FILE *)input->data);\n\n\tif ( c == EOF )\n\t\tinput->length = input->offset;\n\telse\n\t\t++input->offset;\n\n\treturn c;\n}\n\nstatic int SWFInput_file_read(SWFInput input, unsigned char *buffer, int count)\n{\tint len = fread(buffer, 1, count, (FILE *)input->data);\n\tinput->offset += len;\n\treturn len;\n}\n\nSWFInput\nnewSWFInput_file(FILE *f)\n{\n\tSWFInput input;\n\tstruct stat buf;\n\n\t/* XXX - doesn't check for validity of f.. */\n\n\tif ( fseek(f, 0, SEEK_CUR) == -1 )\n\t\treturn newSWFInput_stream(f);\n\n\tif ( fstat(fileno(f), &buf) == -1 )\n\t\tSWF_error(\"Couldn't fstat filehandle in newSWFInput_file\");;\n\n\tinput = (SWFInput) malloc(sizeof(struct SWFInput_s));\n\n\t/* If malloc failed, return NULL to signify this */\n\tif (NULL == input)\n\t\treturn NULL;\n\n\tinput->getChar = SWFInput_file_getChar;\n\tinput->destroy = SWFInput_dtor;\n\tinput->eof = SWFInput_file_eof;\n\tinput->seek = SWFInput_file_seek;\n\tinput->read = SWFInput_file_read;\n\tinput->data = f;\n\tinput->bufbits = 0;\n\tinput->buffer = 0;\n\tinput->offset = 0;\n\tinput->length = buf.st_size;\n\n#if TRACK_ALLOCS\n\tinput->gcnode = ming_gc_add_node(input, (dtorfunctype) destroySWFInput);\n#endif\n\n\treturn input;\n}\n\nstatic void SWFInput_dtor_close(SWFInput input)\n{\n\tfclose((FILE *)input->data);\n\tSWFInput_dtor(input);\n}\n\n\nSWFInput\nnewSWFInput_filename(const char *filename)\n{\n\tFILE *file;\n\tSWFInput input;\n\t\n\tfile = fopen(filename, \"rb\");\n\tif(file == NULL)\n\t{\n\t\tSWF_warn(\"newSWFInput_filename: %s: %s\\n\",\n\t\t\tfilename, strerror(errno));\n\t\treturn NULL;\n\t}\n\n\tinput = newSWFInput_file(file);\n\tif(input == NULL)\n\t\treturn NULL;\n\n\tinput->destroy = SWFInput_dtor_close;\n\treturn input;\n}\n\n\n/* SWFInput_buffer */\n\nstatic int\nSWFInput_buffer_getChar(SWFInput input)\n{\n\tif ( input->offset >= input->length )\n\t\treturn EOF;\n\telse\n\t\treturn ((unsigned char *)input->data)[input->offset++];\n}\n\n\nstatic int\nSWFInput_buffer_eof(SWFInput input)\n{\n\treturn input->offset >= input->length;\n}\n\n\nstatic int\nSWFInput_buffer_read(SWFInput input, unsigned char* buffer, int count)\n{\n\tif ( count > input->length - input->offset )\n\t\tcount = input->length - input->offset;\n\n\tmemcpy(buffer, (unsigned char*)input->data + input->offset, count);\n\tinput->offset += count;\n\n\treturn count;\n}\n\n\nstatic void\nSWFInput_buffer_seek(SWFInput input, long offset, int whence)\n{\n\tif ( whence == SEEK_CUR )\n\t{\n\t\tif ( offset >= 0 )\n\t\t\tinput->offset = min(input->length, input->offset + offset);\n\t\telse\n\t\t\tinput->offset = max(0, input->offset + offset);\n\t}\n\n\telse if ( whence == SEEK_END )\n\t\tinput->offset = max(0, input->length - offset);\n\n\telse if ( whence == SEEK_SET )\n\t\tinput->offset = min(input->length, offset);\n}\n\n\nSWFInput\nnewSWFInput_buffer(unsigned char* buffer, int length)\n{\n\tSWFInput input = (SWFInput) malloc(sizeof(struct SWFInput_s));\n\n\t/* If malloc failed, return NULL to signify this */\n\tif (NULL == input)\n\t\treturn NULL;\n\n\tinput->getChar = SWFInput_buffer_getChar;\n\tinput->destroy = SWFInput_dtor;\n\tinput->eof = SWFInput_buffer_eof;\n\tinput->read = SWFInput_buffer_read;\n\tinput->seek = SWFInput_buffer_seek;\n\tinput->data = buffer;\n\tinput->buffer = 0;\n\tinput->bufbits = 0;\n\tinput->offset = 0;\n\tinput->length = length;\n\n#if TRACK_ALLOCS\n\tinput->gcnode = ming_gc_add_node(input, (dtorfunctype) destroySWFInput);\n#endif\n\n\treturn input;\n}\n\n\nstatic void\nSWFInput_buffer_dtor(SWFInput input)\n{\n\tfree(input->data);\n#if TRACK_ALLOCS\n\tming_gc_remove_node(input->gcnode);\n#endif\n\tfree(input);\n}\n\n\n/* same as above but needs to be freed */\nSWFInput\nnewSWFInput_allocedBuffer(unsigned char *buffer, int length)\n{\n\tSWFInput input = newSWFInput_buffer(buffer, length);\n\tinput->destroy = SWFInput_buffer_dtor;\n#if TRACK_ALLOCS\n\tinput->gcnode = ming_gc_add_node(input, (dtorfunctype) destroySWFInput);\n#endif\n\treturn input;\n}\n\n/* same as above but copy buffer and  needs to be freed */\nSWFInput\nnewSWFInput_bufferCopy(unsigned char *buffer, int length)\n{\n\tSWFInput input;\n\tunsigned char *data = (unsigned char *)malloc(length);\n\tif(data == NULL)\n\t\treturn NULL;\n\n\tmemcpy(data, buffer, length);\n\tinput = newSWFInput_buffer(data, length);\n\tinput->destroy = SWFInput_buffer_dtor;\n#if TRACK_ALLOCS\n\tinput->gcnode = ming_gc_add_node(input, (dtorfunctype) destroySWFInput);\n#endif\n\treturn input;\n}\n\n\n\n\n/* SWFInput_stream */\n\n#define INPUTSTREAM_INCREMENT 32768\n#define MAX_INPUTSTREAM (32*1024*1024) // 32 mb\n\nstruct SWFInputStreamData\n{\n\tFILE *file;\n\tunsigned char *buffer;\n};\n\n\nstatic void\nSWFInput_stream_seek(SWFInput input, long offset, int whence)\n{\n\tint len, l, readOffset;\n\tstruct SWFInputStreamData *data;\n\n\tif ( whence == SEEK_CUR )\n\t\tinput->offset = input->offset + offset;\n\n\telse if ( whence == SEEK_SET )\n\t\tinput->offset = offset;\n\n\telse if ( whence == SEEK_END )\n\t{\n\t\t/* suck data until EOF */\n\t\t/* XXX - might want to put a limit on how much we suck (ha) */\n\n\t\twhile ( SWFInput_getChar(input) != EOF )\n\t\t\tif (input->length > MAX_INPUTSTREAM)\n\t\t\t\tbreak;\n\n\t\tinput->offset = input->length - offset;\n\t}\n\n\tif (input->offset < 0)\n\t\tinput->offset = 0;\n\n\tif ( input->offset < input->length )\n\t\treturn;\n\n\t/* now slurp up as much data as we need to get here */\n\n\tlen = (((input->offset - input->length)/INPUTSTREAM_INCREMENT)+1) * INPUTSTREAM_INCREMENT;\n\n\treadOffset = input->length;\n\tinput->length += len;\n\tdata = (struct SWFInputStreamData*) input->data;\n\n\tdata->buffer = (unsigned char*)realloc(data->buffer, sizeof(unsigned char) * (input->length + len));\n\n\tl=1; /* just to initialize to something */\n\twhile((len > 0) && (l > 0))\n\t{\n\t\tl = fread(data->buffer, sizeof(unsigned char), len, data->file);\n\t\tlen -= l;\n\t\treadOffset += l;\n\t}\n}\n\n\nstatic int\nSWFInput_stream_getChar(SWFInput input)\n{\n\tstruct SWFInputStreamData *data = (struct SWFInputStreamData *) input->data;\n\n\tif (input->offset >= MAX_INPUTSTREAM)\n\t\treturn EOF;\n\n\tif ( input->offset == input->length )\n\t{\n\t\t/* fetch from stream, save in buffer */\n\n\t\tFILE *f = data->file;\n\t\tint c = fgetc(f);\n\n\t\t++input->offset;\n\n\t\tif ( c != EOF )\n\t\t{\n\t\t\tif ( input->length % INPUTSTREAM_INCREMENT == 0 )\n\t\t\t{\n\t\t\t\tdata->buffer = (unsigned char*) realloc(data->buffer,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t sizeof(unsigned char) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (input->length + INPUTSTREAM_INCREMENT));\n\t\t\t}\n\n\t\t\tdata->buffer[input->length] = c;\n\t\t\t++input->length;\n\t\t}\n\n\t\treturn c;\n\t}\n\telse if ( input->offset < input->length )\n\t{\n\t\t/* fetch from buffer */\n\t\treturn data->buffer[input->offset++];\n\t}\n\telse\n\t\treturn EOF;\n}\n\n\nstatic int\nSWFInput_stream_read(SWFInput input, unsigned char* buffer, int count)\n{\n\tstruct SWFInputStreamData *data = (struct SWFInputStreamData *) input->data;\n\tint need = input->offset + count - input->length;\n\n\tif ( need > 0 )\n\t{\n\t\tint num;\n\n\t\tdata->buffer =\n\t\t\t(unsigned char*) realloc(data->buffer,\n\t\t\t\t\t\t\tsizeof(unsigned char) * INPUTSTREAM_INCREMENT *\n\t\t\t\t\t\t\t(((input->offset + count) / INPUTSTREAM_INCREMENT) + 1));\n\t\t\n\t\tnum = fread(data->buffer + input->length,\n\t\t\t\t\t\t\t\tsizeof(unsigned char), need, data->file);\n\n\t\tinput->length += num;\n\t}\n\n\tif ( count > input->length - input->offset )\n\t\tcount = input->length - input->offset;\n\n\tmemcpy(buffer, data->buffer + input->offset, count);\n\n\treturn count;\n}\n\n\n\n\nstatic void\nSWFInput_stream_dtor(SWFInput input)\n{\n\tfree(input->data);\n#if TRACK_ALLOCS\n\tming_gc_remove_node(input->gcnode);\n#endif\n\tfree(input);\n}\n\nstatic int SWFInput_stream_eof(SWFInput input)\n{\n\treturn ((input->offset >= input->length) ? feof((FILE *)input->data) : 0);\n}\n\nSWFInput\nnewSWFInput_stream(FILE* f)\n{\n\tSWFInput input = (SWFInput)malloc(sizeof(struct SWFInput_s));\n\tstruct SWFInputStreamData *data;\n\n\t/* If malloc failed, return NULL to signify this */\n\tif (NULL == input)\n\t\treturn NULL;\n\n\tdata = (struct SWFInputStreamData *)malloc(sizeof(struct SWFInputStreamData));\n\n\t/* If malloc failed, free memory allocated for input and return NULL to signify the failure */\n\tif (NULL == data)\n\t{\n\t\tfree(input);\n\t\treturn NULL;\n\t}\n\n\tinput->getChar = SWFInput_stream_getChar;\n\tinput->destroy = SWFInput_stream_dtor;\n\tinput->eof = SWFInput_stream_eof;\n\tinput->read = SWFInput_stream_read;\n\tinput->seek = SWFInput_stream_seek;\n\n\tinput->offset = 0;\n\tinput->length = 0;\n\tinput->buffer = 0;\n\tinput->bufbits = 0;\n\n\tdata->file = f;\n\tdata->buffer = NULL;\n\n\tinput->data = (void *)data;\n\n#if TRACK_ALLOCS\n\tinput->gcnode = ming_gc_add_node(input, (dtorfunctype) destroySWFInput);\n#endif\n\n\treturn input;\n}\n\n\nstruct SWFInputPtr\n{\n\tSWFInput input;\n\tunsigned int offset;\n};\n\nstatic int\nSWFInput_input_getChar(SWFInput input)\n{\n\tstruct SWFInputPtr *ptr;\n \tint old_offset, result;\n\n\tif ( input->offset >= input->length )\n\t\treturn EOF;\n\t\t\n\tptr = (struct SWFInputPtr *)input->data;\n\told_offset = SWFInput_tell(ptr->input);\n \n\tSWFInput_seek(ptr->input, ptr->offset + input->offset, SEEK_SET);\n\tresult = SWFInput_getChar(ptr->input);\n\tinput->offset++;\n\tSWFInput_seek(ptr->input, old_offset, SEEK_SET);\n\n\treturn result;\n}\n\n\nstatic void\nSWFInput_input_seek(SWFInput input, long offset, int whence)\n{\n\tif ( whence == SEEK_CUR )\n\t{\n\t\tif ( offset >= 0 )\n\t\t\tinput->offset = min(input->length, input->offset + offset);\n\t\telse\n\t\t\tinput->offset = max(0, input->offset + offset);\n\t}\n\n\telse if ( whence == SEEK_END )\n\t\tinput->offset = max(0, input->length - offset);\n\n\telse if ( whence == SEEK_SET )\n\t\tinput->offset = min(input->length, offset);\n}\n\n\nstatic int\nSWFInput_input_eof(SWFInput input)\n{\n\treturn input->offset >= input->length;\n}\n\nstatic void\nSWFInput_input_dtor(SWFInput input)\n{\n\tfree(input->data);\n#if TRACK_ALLOCS\n\tming_gc_remove_node(input->gcnode);\n#endif\n\tfree(input);\n}\n\n\nstatic int\nSWFInput_input_read(SWFInput input, unsigned char* buffer, int count)\n{\n\tint ret;\n\tstruct SWFInputPtr *ptr;\n\tint old_offset;\n\n\tif ( count > input->length - input->offset )\n\t\tcount = input->length - input->offset;\n\n\tptr = (struct SWFInputPtr *)input->data;\n        old_offset = SWFInput_tell(ptr->input);\n\tSWFInput_seek(ptr->input, ptr->offset + input->offset, SEEK_SET);\n\n\tret = SWFInput_read((SWFInput)ptr->input, buffer, count);\n\tif(ret != count)\n\t\tSWF_warn(\"SWFInput_input_read: ret %i, count %i\\n\", ret, count);\n\tinput->offset += count;\n\n\tSWFInput_seek(ptr->input, old_offset, SEEK_SET);\n\n\treturn count;\n}\n\nSWFInput\nnewSWFInput_input(SWFInput in, unsigned int length)\n{\n\tSWFInput input;\n\tstruct SWFInputPtr *data;\n\n\tif (in == NULL)\n\t\treturn NULL;\n\n\tinput = (SWFInput)malloc(sizeof(struct SWFInput_s));\n\n\t/* If malloc failed, return NULL to signify this */\n\tif (NULL == input)\n\t\treturn NULL;\n\n\tinput->getChar = SWFInput_input_getChar;\n\tinput->destroy = SWFInput_input_dtor;\n\tinput->eof = SWFInput_input_eof;\n\tinput->read = SWFInput_input_read;\n\tinput->seek = SWFInput_input_seek;\n\n\tdata = (struct SWFInputPtr *)malloc(sizeof(struct SWFInputPtr));\n\n\t/* If malloc failed, free memory allocated for input and return NULL to signify the failure */\n\tif (NULL == data)\n\t{\n\t\tfree(input);\n\t\treturn NULL;\n\t}\n\n\tdata->offset = SWFInput_tell(in);\n\tdata->input = in;\n\n\tinput->offset = 0;\n\tinput->length = length;\n\n\tinput->data = (void *)data;\n\tinput->buffer = 0;\n\tinput->bufbits = 0;\n#if TRACK_ALLOCS\n\tinput->gcnode = ming_gc_add_node(input, (dtorfunctype) destroySWFInput);\n#endif\n\n\treturn input;\n}\n/*\n * Local variables:\n * tab-width: 2\n * c-basic-offset: 2\n * End:\n */\n"], "filenames": ["src/blocks/input.c"], "buggy_code_start_loc": [116], "buggy_code_end_loc": [117], "fixing_code_start_loc": [116], "fixing_code_end_loc": [117], "type": "CWE-190", "message": "In Ming (aka libming) 0.4.8, there is an integer overflow (caused by an out-of-range left shift) in the SWFInput_readSBits function in blocks/input.c. Remote attackers could leverage this vulnerability to cause a denial-of-service via a crafted swf file.", "other": {"cve": {"id": "CVE-2019-12980", "sourceIdentifier": "cve@mitre.org", "published": "2019-06-26T18:15:10.480", "lastModified": "2020-10-14T18:14:23.783", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Ming (aka libming) 0.4.8, there is an integer overflow (caused by an out-of-range left shift) in the SWFInput_readSBits function in blocks/input.c. Remote attackers could leverage this vulnerability to cause a denial-of-service via a crafted swf file."}, {"lang": "es", "value": "En Ming (aka libming) versi\u00f3n 0.4.8, hay un desbordamiento de enteros (causado por un desplazamiento izquierdo fuera de rango) en la funci\u00f3n SWFInput_readSBits en blocks/input.c. Los atacantes remotos podr\u00edan aprovechar esta vulnerabilidad para causar una denegaci\u00f3n de servicio a trav\u00e9s de un archivo swf dise\u00f1ado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libming:libming:0.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "DD92BC79-2548-4C6F-9BDD-26C12BDF68AC"}]}]}], "references": [{"url": "https://github.com/libming/libming/commit/a009a38dce1d9316cad1ab522b813b1d5ba4c62a", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/libming/libming/commit/a009a38dce1d9316cad1ab522b813b1d5ba4c62a"}}