{"buggy_code": ["pragma solidity ^0.5.0;\n\n/**\n * (E)t)h)e)x) Jackpot Contract \n *  This smart-contract is the part of Ethex Lottery fair game.\n *  See latest version at https://github.com/ethex-bet/ethex-contracts \n *  http://ethex.bet\n */\n\ncontract EthexJackpot {\n    mapping(uint256 => address payable) public tickets;\n    uint256 public numberEnd;\n    uint256 public firstNumber;\n    uint256 public dailyAmount;\n    uint256 public weeklyAmount;\n    uint256 public monthlyAmount;\n    uint256 public seasonalAmount;\n    bool public dailyProcessed;\n    bool public weeklyProcessed;\n    bool public monthlyProcessed;\n    bool public seasonalProcessed;\n    address payable private owner;\n    address public lotoAddress;\n    address payable public newVersionAddress;\n    EthexJackpot previousContract;\n    uint256 public dailyNumberStartPrev;\n    uint256 public weeklyNumberStartPrev;\n    uint256 public monthlyNumberStartPrev;\n    uint256 public seasonalNumberStartPrev;\n    uint256 public dailyStart;\n    uint256 public weeklyStart;\n    uint256 public monthlyStart;\n    uint256 public seasonalStart;\n    uint256 public dailyEnd;\n    uint256 public weeklyEnd;\n    uint256 public monthlyEnd;\n    uint256 public seasonalEnd;\n    uint256 public dailyNumberStart;\n    uint256 public weeklyNumberStart;\n    uint256 public monthlyNumberStart;\n    uint256 public seasonalNumberStart;\n    uint256 public dailyNumberEndPrev;\n    uint256 public weeklyNumberEndPrev;\n    uint256 public monthlyNumberEndPrev;\n    uint256 public seasonalNumberEndPrev;\n    \n    event Jackpot (\n        uint256 number,\n        uint256 count,\n        uint256 amount,\n        byte jackpotType\n    );\n    \n    event Ticket (\n        bytes16 indexed id,\n        uint256 number\n    );\n    \n    event SuperPrize (\n        uint256 amount,\n        address winner\n    );\n    \n    uint256 constant DAILY = 5000;\n    uint256 constant WEEKLY = 35000;\n    uint256 constant MONTHLY = 150000;\n    uint256 constant SEASONAL = 450000;\n    uint256 constant PRECISION = 1 ether;\n    uint256 constant DAILY_PART = 84;\n    uint256 constant WEEKLY_PART = 12;\n    uint256 constant MONTHLY_PART = 3;\n    \n    constructor() public payable {\n        owner = msg.sender;\n    }\n    \n    function() external payable {}\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    modifier onlyOwnerOrNewVersion {\n        require(msg.sender == owner || msg.sender == newVersionAddress);\n        _;\n    }\n    \n    modifier onlyLoto {\n        require(msg.sender == lotoAddress, \"Loto only\");\n        _;\n    }\n    \n    function migrate() external onlyOwnerOrNewVersion {\n        newVersionAddress.transfer(address(this).balance);\n    }\n\n    function registerTicket(bytes16 id, address payable gamer) external onlyLoto {\n        uint256 number = numberEnd + 1;\n        if (block.number >= dailyEnd) {\n            setDaily();\n            dailyNumberStart = number;\n        }\n        else\n            if (dailyNumberStart == dailyNumberStartPrev)\n                dailyNumberStart = number;\n        if (block.number >= weeklyEnd) {\n            setWeekly();\n            weeklyNumberStart = number;\n        }\n        else\n            if (weeklyNumberStart == weeklyNumberStartPrev)\n                weeklyNumberStart = number;\n        if (block.number >= monthlyEnd) {\n            setMonthly();\n            monthlyNumberStart = number;\n        }\n        else\n            if (monthlyNumberStart == monthlyNumberStartPrev)\n                monthlyNumberStart = number;\n        if (block.number >= seasonalEnd) {\n            setSeasonal();\n            seasonalNumberStart = number;\n        }\n        else\n            if (seasonalNumberStart == seasonalNumberStartPrev)\n                seasonalNumberStart = number;\n        numberEnd = number;\n        tickets[number] = gamer;\n        emit Ticket(id, number);\n    }\n    \n    function setLoto(address loto) external onlyOwner {\n        lotoAddress = loto;\n    }\n    \n    function setNewVersion(address payable newVersion) external onlyOwner {\n        newVersionAddress = newVersion;\n    }\n    \n    function payIn() external payable {\n        uint256 distributedAmount = dailyAmount + weeklyAmount + monthlyAmount + seasonalAmount;\n        if (distributedAmount < address(this).balance) {\n            uint256 amount = (address(this).balance - distributedAmount) / 4;\n            dailyAmount += amount;\n            weeklyAmount += amount;\n            monthlyAmount += amount;\n            seasonalAmount += amount;\n        }\n    }\n    \n    function settleJackpot() external {\n        if (block.number >= dailyEnd)\n            setDaily();\n        if (block.number >= weeklyEnd)\n            setWeekly();\n        if (block.number >= monthlyEnd)\n            setMonthly();\n        if (block.number >= seasonalEnd)\n            setSeasonal();\n        \n        if (block.number == dailyStart || (dailyStart < block.number - 256))\n            return;\n        \n        uint48 modulo = uint48(bytes6(blockhash(dailyStart) << 29));\n        \n        uint256 dailyPayAmount;\n        uint256 weeklyPayAmount;\n        uint256 monthlyPayAmount;\n        uint256 seasonalPayAmount;\n        uint256 dailyWin;\n        uint256 weeklyWin;\n        uint256 monthlyWin;\n        uint256 seasonalWin;\n        if (dailyProcessed == false) {\n            dailyPayAmount = dailyAmount * PRECISION / DAILY_PART / PRECISION;\n            dailyAmount -= dailyPayAmount;\n            dailyProcessed = true;\n            dailyWin = getNumber(dailyNumberStartPrev, dailyNumberEndPrev, modulo);\n            emit Jackpot(dailyWin, dailyNumberEndPrev - dailyNumberStartPrev + 1, dailyPayAmount, 0x01);\n        }\n        if (weeklyProcessed == false) {\n            weeklyPayAmount = weeklyAmount * PRECISION / WEEKLY_PART / PRECISION;\n            weeklyAmount -= weeklyPayAmount;\n            weeklyProcessed = true;\n            weeklyWin = getNumber(weeklyNumberStartPrev, weeklyNumberEndPrev, modulo);\n            emit Jackpot(weeklyWin, weeklyNumberEndPrev - weeklyNumberStartPrev + 1, weeklyPayAmount, 0x02);\n        }\n        if (monthlyProcessed == false) {\n            monthlyPayAmount = monthlyAmount * PRECISION / MONTHLY_PART / PRECISION;\n            monthlyAmount -= monthlyPayAmount;\n            monthlyProcessed = true;\n            monthlyWin = getNumber(monthlyNumberStartPrev, monthlyNumberEndPrev, modulo);\n            emit Jackpot(monthlyWin, monthlyNumberEndPrev - monthlyNumberStartPrev + 1, monthlyPayAmount, 0x04);\n        }\n        if (seasonalProcessed == false) {\n            seasonalPayAmount = seasonalAmount;\n            seasonalAmount -= seasonalPayAmount;\n            seasonalProcessed = true;\n            seasonalWin = getNumber(seasonalNumberStartPrev, seasonalNumberEndPrev, modulo);\n            emit Jackpot(seasonalWin, seasonalNumberEndPrev - seasonalNumberStartPrev + 1, seasonalPayAmount, 0x08);\n        }\n        if (dailyPayAmount > 0)\n            getAddress(dailyWin).transfer(dailyPayAmount);\n        if (weeklyPayAmount > 0)\n            getAddress(weeklyWin).transfer(weeklyPayAmount);\n        if (monthlyPayAmount > 0)\n            getAddress(monthlyWin).transfer(monthlyPayAmount);\n        if (seasonalPayAmount > 0)\n            getAddress(seasonalWin).transfer(seasonalPayAmount);\n    }\n    \n    function paySuperPrize(address payable winner) external onlyLoto {\n        uint256 superPrizeAmount = dailyAmount + weeklyAmount + monthlyAmount + seasonalAmount;\n        emit SuperPrize(superPrizeAmount, winner);\n        winner.transfer(superPrizeAmount);\n    }\n    \n    function loadTickets(address payable[] calldata addresses, uint256[] calldata numbers) external {\n        for (uint i = 0; i < addresses.length; i++)\n            tickets[numbers[i]] = addresses[i];\n    }\n    \n    function setOldVersion(address payable oldAddress) external onlyOwner {\n        previousContract = EthexJackpot(oldAddress);\n        dailyStart = previousContract.dailyStart();\n        dailyEnd = previousContract.dailyEnd();\n        dailyProcessed = previousContract.dailyProcessed();\n        weeklyStart = previousContract.weeklyStart();\n        weeklyEnd = previousContract.weeklyEnd();\n        weeklyProcessed = previousContract.weeklyProcessed();\n        monthlyStart = previousContract.monthlyStart();\n        monthlyEnd = previousContract.monthlyEnd();\n        monthlyProcessed = previousContract.monthlyProcessed();\n        seasonalStart = previousContract.seasonalStart();\n        seasonalEnd = previousContract.seasonalEnd();\n        seasonalProcessed = previousContract.seasonalProcessed();\n        dailyNumberStartPrev = previousContract.dailyNumberStartPrev();\n        weeklyNumberStartPrev = previousContract.weeklyNumberStartPrev();\n        monthlyNumberStartPrev = previousContract.monthlyNumberStartPrev();\n        seasonalNumberStartPrev = previousContract.seasonalNumberStartPrev();\n        dailyNumberStart = previousContract.dailyNumberStart();\n        weeklyNumberStart = previousContract.weeklyNumberStart();\n        monthlyNumberStart = previousContract.monthlyNumberStart();\n        seasonalNumberStart = previousContract.seasonalNumberStart();\n        dailyNumberEndPrev = previousContract.dailyNumberEndPrev();\n        weeklyNumberEndPrev = previousContract.weeklyNumberEndPrev();\n        monthlyNumberEndPrev = previousContract.monthlyNumberEndPrev();\n        seasonalNumberEndPrev = previousContract.seasonalNumberEndPrev();\n        numberEnd = previousContract.numberEnd();\n        dailyAmount = previousContract.dailyAmount();\n        weeklyAmount = previousContract.weeklyAmount();\n        monthlyAmount = previousContract.monthlyAmount();\n        seasonalAmount = previousContract.seasonalAmount();\n        firstNumber = numberEnd;\n        previousContract.migrate();\n    }\n    \n    function getAddress(uint256 number) public returns (address payable) {\n        if (number <= firstNumber)\n            return previousContract.getAddress(number);\n        return tickets[number];\n    }\n    \n    function setDaily() private {\n        dailyProcessed = dailyNumberEndPrev == numberEnd;\n        dailyStart = dailyEnd;\n        dailyEnd = dailyStart + DAILY;\n        dailyNumberStartPrev = dailyNumberStart;\n        dailyNumberEndPrev = numberEnd;\n    }\n    \n    function setWeekly() private {\n        weeklyProcessed = weeklyNumberEndPrev == numberEnd;\n        weeklyStart = weeklyEnd;\n        weeklyEnd = weeklyStart + WEEKLY;\n        weeklyNumberStartPrev = weeklyNumberStart;\n        weeklyNumberEndPrev = numberEnd;\n    }\n    \n    function setMonthly() private {\n        monthlyProcessed = monthlyNumberEndPrev == numberEnd;\n        monthlyStart = monthlyEnd;\n        monthlyEnd = monthlyStart + MONTHLY;\n        monthlyNumberStartPrev = monthlyNumberStart;\n        monthlyNumberEndPrev = numberEnd;\n    }\n    \n    function setSeasonal() private {\n        seasonalProcessed = seasonalNumberEndPrev == numberEnd;\n        seasonalStart = seasonalEnd;\n        seasonalEnd = seasonalStart + SEASONAL;\n        seasonalNumberStartPrev = seasonalNumberStart;\n        seasonalNumberEndPrev = numberEnd;\n    }\n    \n    function getNumber(uint256 startNumber, uint256 endNumber, uint48 modulo) pure private returns (uint256) {\n        return startNumber + modulo % (endNumber - startNumber + 1);\n    }\n}\n"], "fixing_code": ["pragma solidity ^0.5.0;\n\n/**\n * (E)t)h)e)x) Jackpot Contract \n *  This smart-contract is the part of Ethex Lottery fair game.\n *  See latest version at https://github.com/ethex-bet/ethex-contracts \n *  http://ethex.bet\n */\n\ncontract EthexJackpot {\n    mapping(uint256 => address payable) public tickets;\n    uint256 public numberEnd;\n    uint256 public firstNumber;\n    uint256 public dailyAmount;\n    uint256 public weeklyAmount;\n    uint256 public monthlyAmount;\n    uint256 public seasonalAmount;\n    bool public dailyProcessed;\n    bool public weeklyProcessed;\n    bool public monthlyProcessed;\n    bool public seasonalProcessed;\n    address payable private owner;\n    address public lotoAddress;\n    address payable public newVersionAddress;\n    EthexJackpot previousContract;\n    uint256 public dailyNumberStartPrev;\n    uint256 public weeklyNumberStartPrev;\n    uint256 public monthlyNumberStartPrev;\n    uint256 public seasonalNumberStartPrev;\n    uint256 public dailyStart;\n    uint256 public weeklyStart;\n    uint256 public monthlyStart;\n    uint256 public seasonalStart;\n    uint256 public dailyEnd;\n    uint256 public weeklyEnd;\n    uint256 public monthlyEnd;\n    uint256 public seasonalEnd;\n    uint256 public dailyNumberStart;\n    uint256 public weeklyNumberStart;\n    uint256 public monthlyNumberStart;\n    uint256 public seasonalNumberStart;\n    uint256 public dailyNumberEndPrev;\n    uint256 public weeklyNumberEndPrev;\n    uint256 public monthlyNumberEndPrev;\n    uint256 public seasonalNumberEndPrev;\n    \n    event Jackpot (\n        uint256 number,\n        uint256 count,\n        uint256 amount,\n        byte jackpotType\n    );\n    \n    event Ticket (\n        bytes16 indexed id,\n        uint256 number\n    );\n    \n    event SuperPrize (\n        uint256 amount,\n        address winner\n    );\n    \n    uint256 constant DAILY = 5000;\n    uint256 constant WEEKLY = 35000;\n    uint256 constant MONTHLY = 150000;\n    uint256 constant SEASONAL = 450000;\n    uint256 constant PRECISION = 1 ether;\n    uint256 constant DAILY_PART = 84;\n    uint256 constant WEEKLY_PART = 12;\n    uint256 constant MONTHLY_PART = 3;\n    \n    constructor() public payable {\n        owner = msg.sender;\n    }\n    \n    function() external payable {}\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    modifier onlyOwnerOrNewVersion {\n        require(msg.sender == owner || msg.sender == newVersionAddress);\n        _;\n    }\n    \n    modifier onlyLoto {\n        require(msg.sender == lotoAddress, \"Loto only\");\n        _;\n    }\n    \n    function migrate() external onlyOwnerOrNewVersion {\n        newVersionAddress.transfer(address(this).balance);\n    }\n\n    function registerTicket(bytes16 id, address payable gamer) external onlyLoto {\n        uint256 number = numberEnd + 1;\n        if (block.number >= dailyEnd) {\n            setDaily();\n            dailyNumberStart = number;\n        }\n        else\n            if (dailyNumberStart == dailyNumberStartPrev)\n                dailyNumberStart = number;\n        if (block.number >= weeklyEnd) {\n            setWeekly();\n            weeklyNumberStart = number;\n        }\n        else\n            if (weeklyNumberStart == weeklyNumberStartPrev)\n                weeklyNumberStart = number;\n        if (block.number >= monthlyEnd) {\n            setMonthly();\n            monthlyNumberStart = number;\n        }\n        else\n            if (monthlyNumberStart == monthlyNumberStartPrev)\n                monthlyNumberStart = number;\n        if (block.number >= seasonalEnd) {\n            setSeasonal();\n            seasonalNumberStart = number;\n        }\n        else\n            if (seasonalNumberStart == seasonalNumberStartPrev)\n                seasonalNumberStart = number;\n        numberEnd = number;\n        tickets[number] = gamer;\n        emit Ticket(id, number);\n    }\n    \n    function setLoto(address loto) external onlyOwner {\n        lotoAddress = loto;\n    }\n    \n    function setNewVersion(address payable newVersion) external onlyOwner {\n        newVersionAddress = newVersion;\n    }\n    \n    function payIn() external payable {\n        uint256 distributedAmount = dailyAmount + weeklyAmount + monthlyAmount + seasonalAmount;\n        if (distributedAmount < address(this).balance) {\n            uint256 amount = (address(this).balance - distributedAmount) / 4;\n            dailyAmount += amount;\n            weeklyAmount += amount;\n            monthlyAmount += amount;\n            seasonalAmount += amount;\n        }\n    }\n    \n    function settleJackpot() external {\n        if (block.number >= dailyEnd)\n            setDaily();\n        if (block.number >= weeklyEnd)\n            setWeekly();\n        if (block.number >= monthlyEnd)\n            setMonthly();\n        if (block.number >= seasonalEnd)\n            setSeasonal();\n        \n        if (block.number == dailyStart || (dailyStart < block.number - 256))\n            return;\n        \n        uint48 modulo = uint48(bytes6(blockhash(dailyStart) << 29));\n        \n        uint256 dailyPayAmount;\n        uint256 weeklyPayAmount;\n        uint256 monthlyPayAmount;\n        uint256 seasonalPayAmount;\n        uint256 dailyWin;\n        uint256 weeklyWin;\n        uint256 monthlyWin;\n        uint256 seasonalWin;\n        if (dailyProcessed == false) {\n            dailyPayAmount = dailyAmount * PRECISION / DAILY_PART / PRECISION;\n            dailyAmount -= dailyPayAmount;\n            dailyProcessed = true;\n            dailyWin = getNumber(dailyNumberStartPrev, dailyNumberEndPrev, modulo);\n            emit Jackpot(dailyWin, dailyNumberEndPrev - dailyNumberStartPrev + 1, dailyPayAmount, 0x01);\n        }\n        if (weeklyProcessed == false) {\n            weeklyPayAmount = weeklyAmount * PRECISION / WEEKLY_PART / PRECISION;\n            weeklyAmount -= weeklyPayAmount;\n            weeklyProcessed = true;\n            weeklyWin = getNumber(weeklyNumberStartPrev, weeklyNumberEndPrev, modulo);\n            emit Jackpot(weeklyWin, weeklyNumberEndPrev - weeklyNumberStartPrev + 1, weeklyPayAmount, 0x02);\n        }\n        if (monthlyProcessed == false) {\n            monthlyPayAmount = monthlyAmount * PRECISION / MONTHLY_PART / PRECISION;\n            monthlyAmount -= monthlyPayAmount;\n            monthlyProcessed = true;\n            monthlyWin = getNumber(monthlyNumberStartPrev, monthlyNumberEndPrev, modulo);\n            emit Jackpot(monthlyWin, monthlyNumberEndPrev - monthlyNumberStartPrev + 1, monthlyPayAmount, 0x04);\n        }\n        if (seasonalProcessed == false) {\n            seasonalPayAmount = seasonalAmount;\n            seasonalAmount -= seasonalPayAmount;\n            seasonalProcessed = true;\n            seasonalWin = getNumber(seasonalNumberStartPrev, seasonalNumberEndPrev, modulo);\n            emit Jackpot(seasonalWin, seasonalNumberEndPrev - seasonalNumberStartPrev + 1, seasonalPayAmount, 0x08);\n        }\n        if (dailyPayAmount > 0)\n            getAddress(dailyWin).transfer(dailyPayAmount);\n        if (weeklyPayAmount > 0)\n            getAddress(weeklyWin).transfer(weeklyPayAmount);\n        if (monthlyPayAmount > 0)\n            getAddress(monthlyWin).transfer(monthlyPayAmount);\n        if (seasonalPayAmount > 0)\n            getAddress(seasonalWin).transfer(seasonalPayAmount);\n    }\n\n    function paySuperPrize(address payable winner) external onlyLoto {\n        uint256 superPrizeAmount = dailyAmount + weeklyAmount + monthlyAmount + seasonalAmount;\n        dailyAmount = 0;\n        weeklyAmount = 0;\n        monthlyAmount = 0;\n        seasonalAmount = 0;\n        emit SuperPrize(superPrizeAmount, winner);\n        winner.transfer(superPrizeAmount);\n    }\n    \n    function setOldVersion(address payable oldAddress) external onlyOwner {\n        previousContract = EthexJackpot(oldAddress);\n        dailyStart = previousContract.dailyStart();\n        dailyEnd = previousContract.dailyEnd();\n        dailyProcessed = previousContract.dailyProcessed();\n        weeklyStart = previousContract.weeklyStart();\n        weeklyEnd = previousContract.weeklyEnd();\n        weeklyProcessed = previousContract.weeklyProcessed();\n        monthlyStart = previousContract.monthlyStart();\n        monthlyEnd = previousContract.monthlyEnd();\n        monthlyProcessed = previousContract.monthlyProcessed();\n        seasonalStart = previousContract.seasonalStart();\n        seasonalEnd = previousContract.seasonalEnd();\n        seasonalProcessed = previousContract.seasonalProcessed();\n        dailyNumberStartPrev = previousContract.dailyNumberStartPrev();\n        weeklyNumberStartPrev = previousContract.weeklyNumberStartPrev();\n        monthlyNumberStartPrev = previousContract.monthlyNumberStartPrev();\n        seasonalNumberStartPrev = previousContract.seasonalNumberStartPrev();\n        dailyNumberStart = previousContract.dailyNumberStart();\n        weeklyNumberStart = previousContract.weeklyNumberStart();\n        monthlyNumberStart = previousContract.monthlyNumberStart();\n        seasonalNumberStart = previousContract.seasonalNumberStart();\n        dailyNumberEndPrev = previousContract.dailyNumberEndPrev();\n        weeklyNumberEndPrev = previousContract.weeklyNumberEndPrev();\n        monthlyNumberEndPrev = previousContract.monthlyNumberEndPrev();\n        seasonalNumberEndPrev = previousContract.seasonalNumberEndPrev();\n        numberEnd = previousContract.numberEnd();\n        dailyAmount = previousContract.dailyAmount();\n        weeklyAmount = previousContract.weeklyAmount();\n        monthlyAmount = previousContract.monthlyAmount();\n        seasonalAmount = previousContract.seasonalAmount();\n        firstNumber = weeklyNumberStart;\n        for (uint256 i = firstNumber; i <= numberEnd; i++)\n            tickets[i] = previousContract.getAddress(i);\n        previousContract.migrate();\n    }\n    \n    function getAddress(uint256 number) public returns (address payable) {\n        if (number <= firstNumber)\n            return previousContract.getAddress(number);\n        return tickets[number];\n    }\n    \n    function setDaily() private {\n        dailyProcessed = dailyNumberEndPrev == numberEnd;\n        dailyStart = dailyEnd;\n        dailyEnd = dailyStart + DAILY;\n        dailyNumberStartPrev = dailyNumberStart;\n        dailyNumberEndPrev = numberEnd;\n    }\n    \n    function setWeekly() private {\n        weeklyProcessed = weeklyNumberEndPrev == numberEnd;\n        weeklyStart = weeklyEnd;\n        weeklyEnd = weeklyStart + WEEKLY;\n        weeklyNumberStartPrev = weeklyNumberStart;\n        weeklyNumberEndPrev = numberEnd;\n    }\n    \n    function setMonthly() private {\n        monthlyProcessed = monthlyNumberEndPrev == numberEnd;\n        monthlyStart = monthlyEnd;\n        monthlyEnd = monthlyStart + MONTHLY;\n        monthlyNumberStartPrev = monthlyNumberStart;\n        monthlyNumberEndPrev = numberEnd;\n    }\n    \n    function setSeasonal() private {\n        seasonalProcessed = seasonalNumberEndPrev == numberEnd;\n        seasonalStart = seasonalEnd;\n        seasonalEnd = seasonalStart + SEASONAL;\n        seasonalNumberStartPrev = seasonalNumberStart;\n        seasonalNumberEndPrev = numberEnd;\n    }\n    \n    function getNumber(uint256 startNumber, uint256 endNumber, uint48 modulo) pure private returns (uint256) {\n        return startNumber + modulo % (endNumber - startNumber + 1);\n    }\n}\n"], "filenames": ["EthexJackpot.sol"], "buggy_code_start_loc": [212], "buggy_code_end_loc": [256], "fixing_code_start_loc": [212], "fixing_code_end_loc": [257], "type": "CWE-284", "message": "A vulnerability was found in Ethex Contracts. It has been classified as critical. This affects an unknown part of the file EthexJackpot.sol of the component Monthly Jackpot Handler. The manipulation leads to improper access controls. It is possible to initiate the attack remotely. This product does not use versioning. This is why information about affected and unaffected releases are unavailable. The patch is named 6b8664b698d3d953e16c284fadc6caeb9e58e3db. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-248271.", "other": {"cve": {"id": "CVE-2019-25157", "sourceIdentifier": "cna@vuldb.com", "published": "2023-12-19T03:15:07.693", "lastModified": "2024-02-29T01:25:41.940", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A vulnerability was found in Ethex Contracts. It has been classified as critical. This affects an unknown part of the file EthexJackpot.sol of the component Monthly Jackpot Handler. The manipulation leads to improper access controls. It is possible to initiate the attack remotely. This product does not use versioning. This is why information about affected and unaffected releases are unavailable. The patch is named 6b8664b698d3d953e16c284fadc6caeb9e58e3db. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-248271."}, {"lang": "es", "value": "Se encontr\u00f3 una vulnerabilidad en Ethex Contracts. Ha sido clasificada como cr\u00edtica. Una parte desconocida del archivo EthexJackpot.sol del componente Monthly Jackpot Handler afecta a una parte desconocida. La manipulaci\u00f3n conduce a controles de acceso inadecuados. Es posible iniciar el ataque de forma remota. Este producto no utiliza versiones. Esta es la raz\u00f3n por la que la informaci\u00f3n sobre las versiones afectadas y no afectadas no est\u00e1 disponible. El parche se llama 6b8664b698d3d953e16c284fadc6caeb9e58e3db. Se recomienda aplicar un parche para solucionar este problema. El identificador asociado de esta vulnerabilidad es VDB-248271."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ethex:ethex_contracts:*:*:*:*:*:*:*:*", "versionEndExcluding": "2019.06.26", "matchCriteriaId": "2839EA05-27C3-44A1-95C7-14A1F20941A9"}]}]}], "references": [{"url": "https://bitcointalk.org/index.php?topic=5120151.msg50827730#msg50827730", "source": "cna@vuldb.com", "tags": ["Exploit"]}, {"url": "https://github.com/ethex-bet/ethex-contracts/commit/6b8664b698d3d953e16c284fadc6caeb9e58e3db", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://vuldb.com/?ctiid.248271", "source": "cna@vuldb.com", "tags": ["Permissions Required", "VDB Entry"]}, {"url": "https://vuldb.com/?id.248271", "source": "cna@vuldb.com", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/ethex-bet/ethex-contracts/commit/6b8664b698d3d953e16c284fadc6caeb9e58e3db"}}