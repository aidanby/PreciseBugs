{"buggy_code": ["use std::sync::Arc;\n\nuse chrono::{DateTime, Utc};\nuse poem::session::Session;\nuse poem::web::Data;\nuse poem::Request;\nuse poem_openapi::param::Path;\nuse poem_openapi::payload::Json;\nuse poem_openapi::{ApiResponse, Enum, Object, OpenApi};\nuse tokio::sync::Mutex;\nuse tracing::*;\nuse uuid::Uuid;\nuse warpgate_common::auth::{AuthCredential, AuthResult, AuthState, CredentialKind};\nuse warpgate_common::{Secret, WarpgateError};\nuse warpgate_core::Services;\n\nuse crate::common::{\n    authorize_session, endpoint_auth, get_auth_state_for_request, SessionAuthorization, SessionExt,\n};\nuse crate::session::SessionStore;\n\npub struct Api;\n\n#[derive(Object)]\nstruct LoginRequest {\n    username: String,\n    password: String,\n}\n\n#[derive(Object)]\nstruct OtpLoginRequest {\n    otp: String,\n}\n\n#[derive(Enum)]\nenum ApiAuthState {\n    NotStarted,\n    Failed,\n    PasswordNeeded,\n    OtpNeeded,\n    SsoNeeded,\n    WebUserApprovalNeeded,\n    PublicKeyNeeded,\n    Success,\n}\n\n#[derive(Object)]\nstruct LoginFailureResponse {\n    state: ApiAuthState,\n}\n\n#[derive(ApiResponse)]\nenum LoginResponse {\n    #[oai(status = 201)]\n    Success,\n\n    #[oai(status = 401)]\n    Failure(Json<LoginFailureResponse>),\n}\n\n#[derive(ApiResponse)]\nenum LogoutResponse {\n    #[oai(status = 201)]\n    Success,\n}\n\n#[derive(Object)]\nstruct AuthStateResponseInternal {\n    pub protocol: String,\n    pub address: Option<String>,\n    pub started: DateTime<Utc>,\n    pub state: ApiAuthState,\n    pub identification_string: String,\n}\n\n#[derive(ApiResponse)]\nenum AuthStateResponse {\n    #[oai(status = 200)]\n    Ok(Json<AuthStateResponseInternal>),\n    #[oai(status = 404)]\n    NotFound,\n}\n\nimpl From<AuthResult> for ApiAuthState {\n    fn from(state: AuthResult) -> Self {\n        match state {\n            AuthResult::Rejected => ApiAuthState::Failed,\n            AuthResult::Need(kinds) => match kinds.iter().next() {\n                Some(CredentialKind::Password) => ApiAuthState::PasswordNeeded,\n                Some(CredentialKind::Totp) => ApiAuthState::OtpNeeded,\n                Some(CredentialKind::Sso) => ApiAuthState::SsoNeeded,\n                Some(CredentialKind::WebUserApproval) => ApiAuthState::WebUserApprovalNeeded,\n                Some(CredentialKind::PublicKey) => ApiAuthState::PublicKeyNeeded,\n                None => ApiAuthState::Failed,\n            },\n            AuthResult::Accepted { .. } => ApiAuthState::Success,\n        }\n    }\n}\n\n#[OpenApi]\nimpl Api {\n    #[oai(path = \"/auth/login\", method = \"post\", operation_id = \"login\")]\n    async fn api_auth_login(\n        &self,\n        req: &Request,\n        session: &Session,\n        services: Data<&Services>,\n        body: Json<LoginRequest>,\n    ) -> poem::Result<LoginResponse> {\n        let mut auth_state_store = services.auth_state_store.lock().await;\n        let state_arc = match get_auth_state_for_request(\n            &body.username,\n            session,\n            &mut auth_state_store,\n        )\n        .await\n        {\n            Err(WarpgateError::UserNotFound) => {\n                return Ok(LoginResponse::Failure(Json(LoginFailureResponse {\n                    state: ApiAuthState::Failed,\n                })))\n            }\n            x => x,\n        }?;\n        let mut state = state_arc.lock().await;\n\n        let mut cp = services.config_provider.lock().await;\n\n        let password_cred = AuthCredential::Password(Secret::new(body.password.clone()));\n        if cp\n            .validate_credential(&body.username, &password_cred)\n            .await?\n        {\n            state.add_valid_credential(password_cred);\n        }\n\n        match state.verify() {\n            AuthResult::Accepted { username } => {\n                auth_state_store.complete(state.id()).await;\n                authorize_session(req, username).await?;\n                Ok(LoginResponse::Success)\n            }\n            x => {\n                error!(\"Auth rejected\");\n                Ok(LoginResponse::Failure(Json(LoginFailureResponse {\n                    state: x.into(),\n                })))\n            }\n        }\n    }\n\n    #[oai(path = \"/auth/otp\", method = \"post\", operation_id = \"otpLogin\")]\n    async fn api_auth_otp_login(\n        &self,\n        req: &Request,\n        session: &Session,\n        services: Data<&Services>,\n        body: Json<OtpLoginRequest>,\n    ) -> poem::Result<LoginResponse> {\n        let state_id = session.get_auth_state_id();\n\n        let mut auth_state_store = services.auth_state_store.lock().await;\n\n        let Some(state_arc) = state_id.and_then(|id| auth_state_store.get(&id.0)) else {\n            return Ok(LoginResponse::Failure(Json(LoginFailureResponse {\n                state: ApiAuthState::NotStarted,\n            })))\n        };\n\n        let mut state = state_arc.lock().await;\n\n        let mut cp = services.config_provider.lock().await;\n\n        let otp_cred = AuthCredential::Otp(body.otp.clone().into());\n        if cp.validate_credential(state.username(), &otp_cred).await? {\n            state.add_valid_credential(otp_cred);\n        }\n\n        match state.verify() {\n            AuthResult::Accepted { username } => {\n                auth_state_store.complete(state.id()).await;\n                authorize_session(req, username).await?;\n                Ok(LoginResponse::Success)\n            }\n            x => Ok(LoginResponse::Failure(Json(LoginFailureResponse {\n                state: x.into(),\n            }))),\n        }\n    }\n\n    #[oai(path = \"/auth/logout\", method = \"post\", operation_id = \"logout\")]\n    async fn api_auth_logout(\n        &self,\n        session: &Session,\n        session_middleware: Data<&Arc<Mutex<SessionStore>>>,\n    ) -> poem::Result<LogoutResponse> {\n        session_middleware.lock().await.remove_session(session);\n        session.clear();\n        info!(\"Logged out\");\n        Ok(LogoutResponse::Success)\n    }\n\n    #[oai(\n        path = \"/auth/state\",\n        method = \"get\",\n        operation_id = \"getDefaultAuthState\"\n    )]\n    async fn api_default_auth_state(\n        &self,\n        session: &Session,\n        services: Data<&Services>,\n    ) -> poem::Result<AuthStateResponse> {\n        let Some(state_id) = session.get_auth_state_id() else {\n            return Ok(AuthStateResponse::NotFound)\n        };\n        let store = services.auth_state_store.lock().await;\n        let Some(state_arc) = store.get(&state_id.0) else {\n            return Ok(AuthStateResponse::NotFound);\n        };\n        serialize_auth_state_inner(state_arc, *services).await\n    }\n\n    #[oai(\n        path = \"/auth/state\",\n        method = \"delete\",\n        operation_id = \"cancelDefaultAuth\"\n    )]\n    async fn api_cancel_default_auth(\n        &self,\n        session: &Session,\n        services: Data<&Services>,\n    ) -> poem::Result<AuthStateResponse> {\n        let Some(state_id) = session.get_auth_state_id() else {\n            return Ok(AuthStateResponse::NotFound)\n        };\n        let mut store = services.auth_state_store.lock().await;\n        let Some(state_arc) = store.get(&state_id.0) else {\n            return Ok(AuthStateResponse::NotFound);\n        };\n        state_arc.lock().await.reject();\n        store.complete(&state_id.0).await;\n        session.clear_auth_state();\n        serialize_auth_state_inner(state_arc, *services).await\n    }\n\n    #[oai(\n        path = \"/auth/state/:id\",\n        method = \"get\",\n        operation_id = \"get_auth_state\",\n        transform = \"endpoint_auth\"\n    )]\n    async fn api_auth_state(\n        &self,\n        services: Data<&Services>,\n        auth: Option<Data<&SessionAuthorization>>,\n        id: Path<Uuid>,\n    ) -> poem::Result<AuthStateResponse> {\n        let state_arc = get_auth_state(&id, &services, auth.map(|x| x.0)).await;\n        let Some(state_arc) = state_arc else {\n            return Ok(AuthStateResponse::NotFound);\n        };\n        serialize_auth_state_inner(state_arc, *services).await\n    }\n\n    #[oai(\n        path = \"/auth/state/:id/approve\",\n        method = \"post\",\n        operation_id = \"approve_auth\",\n        transform = \"endpoint_auth\"\n    )]\n    async fn api_approve_auth(\n        &self,\n        services: Data<&Services>,\n        auth: Option<Data<&SessionAuthorization>>,\n        id: Path<Uuid>,\n    ) -> poem::Result<AuthStateResponse> {\n        let Some(state_arc) = get_auth_state(&id, &services, auth.map(|x|x.0)).await else {\n            return Ok(AuthStateResponse::NotFound);\n        };\n\n        let auth_result = {\n            let mut state = state_arc.lock().await;\n            state.add_valid_credential(AuthCredential::WebUserApproval);\n            state.verify()\n        };\n\n        if let AuthResult::Accepted { .. } = auth_result {\n            services.auth_state_store.lock().await.complete(&id).await;\n        }\n        serialize_auth_state_inner(state_arc, *services).await\n    }\n\n    #[oai(\n        path = \"/auth/state/:id/reject\",\n        method = \"post\",\n        operation_id = \"reject_auth\",\n        transform = \"endpoint_auth\"\n    )]\n    async fn api_reject_auth(\n        &self,\n        services: Data<&Services>,\n        auth: Option<Data<&SessionAuthorization>>,\n        id: Path<Uuid>,\n    ) -> poem::Result<AuthStateResponse> {\n        let Some(state_arc) = get_auth_state(&id, &services, auth.map(|x|x.0)).await else {\n            return Ok(AuthStateResponse::NotFound);\n        };\n        state_arc.lock().await.reject();\n        services.auth_state_store.lock().await.complete(&id).await;\n        serialize_auth_state_inner(state_arc, *services).await\n    }\n}\n\nasync fn get_auth_state(\n    id: &Uuid,\n    services: &Services,\n    auth: Option<&SessionAuthorization>,\n) -> Option<Arc<Mutex<AuthState>>> {\n    let store = services.auth_state_store.lock().await;\n\n    let Some(auth) = auth else {\n        return None;\n    };\n\n    let SessionAuthorization::User(username) = auth else {\n        return None;\n    };\n\n    let Some(state_arc) = store.get(id) else {\n        return None;\n    };\n\n    {\n        let state = state_arc.lock().await;\n        if state.username() != username {\n            return None;\n        }\n    }\n\n    Some(state_arc)\n}\n\nasync fn serialize_auth_state_inner(\n    state_arc: Arc<Mutex<AuthState>>,\n    services: &Services,\n) -> poem::Result<AuthStateResponse> {\n    let state = state_arc.lock().await;\n\n    let session_state_store = services.state.lock().await;\n    let session_state = state\n        .session_id()\n        .and_then(|session_id| session_state_store.sessions.get(&session_id));\n\n    let peer_addr = match session_state {\n        Some(x) => x.lock().await.remote_address,\n        None => None,\n    };\n\n    Ok(AuthStateResponse::Ok(Json(AuthStateResponseInternal {\n        protocol: state.protocol().to_string(),\n        address: peer_addr.map(|x| x.ip().to_string()),\n        started: *state.started(),\n        state: state.verify().into(),\n        identification_string: state.identification_string().to_owned(),\n    })))\n}\n", "use std::sync::Arc;\nuse std::time::Duration;\n\nuse http::StatusCode;\nuse percent_encoding::{utf8_percent_encode, NON_ALPHANUMERIC};\nuse poem::session::Session;\nuse poem::web::{Data, Redirect};\nuse poem::{Endpoint, EndpointExt, FromRequest, IntoResponse, Request, Response};\nuse serde::{Deserialize, Serialize};\nuse tokio::sync::Mutex;\nuse uuid::Uuid;\nuse warpgate_common::auth::AuthState;\nuse warpgate_common::{ProtocolName, TargetOptions, WarpgateError};\nuse warpgate_core::{AuthStateStore, Services};\n\nuse crate::session::SessionStore;\n\npub const PROTOCOL_NAME: ProtocolName = \"HTTP\";\nstatic TARGET_SESSION_KEY: &str = \"target_name\";\nstatic AUTH_SESSION_KEY: &str = \"auth\";\nstatic AUTH_STATE_ID_SESSION_KEY: &str = \"auth_state_id\";\npub static SESSION_MAX_AGE: Duration = Duration::from_secs(60 * 30);\npub static COOKIE_MAX_AGE: Duration = Duration::from_secs(60 * 60 * 24);\npub static SESSION_COOKIE_NAME: &str = \"warpgate-http-session\";\n\npub trait SessionExt {\n    fn has_selected_target(&self) -> bool;\n    fn get_target_name(&self) -> Option<String>;\n    fn set_target_name(&self, target_name: String);\n    fn is_authenticated(&self) -> bool;\n    fn get_username(&self) -> Option<String>;\n    fn get_auth(&self) -> Option<SessionAuthorization>;\n    fn set_auth(&self, auth: SessionAuthorization);\n    fn get_auth_state_id(&self) -> Option<AuthStateId>;\n    fn clear_auth_state(&self);\n}\n\nimpl SessionExt for Session {\n    fn has_selected_target(&self) -> bool {\n        self.get_target_name().is_some()\n    }\n\n    fn get_target_name(&self) -> Option<String> {\n        self.get(TARGET_SESSION_KEY)\n    }\n\n    fn set_target_name(&self, target_name: String) {\n        self.set(TARGET_SESSION_KEY, target_name);\n    }\n\n    fn is_authenticated(&self) -> bool {\n        self.get_username().is_some()\n    }\n\n    fn get_username(&self) -> Option<String> {\n        self.get_auth().map(|x| x.username().to_owned())\n    }\n\n    fn get_auth(&self) -> Option<SessionAuthorization> {\n        self.get(AUTH_SESSION_KEY)\n    }\n\n    fn set_auth(&self, auth: SessionAuthorization) {\n        self.set(AUTH_SESSION_KEY, auth);\n    }\n\n    fn get_auth_state_id(&self) -> Option<AuthStateId> {\n        self.get(AUTH_STATE_ID_SESSION_KEY)\n    }\n\n    fn clear_auth_state(&self) {\n        self.remove(AUTH_STATE_ID_SESSION_KEY)\n    }\n}\n\n#[derive(Clone, Serialize, Deserialize)]\npub struct AuthStateId(pub Uuid);\n\n#[derive(Clone, Serialize, Deserialize)]\npub enum SessionAuthorization {\n    User(String),\n    Ticket {\n        username: String,\n        target_name: String,\n    },\n}\n\nimpl SessionAuthorization {\n    pub fn username(&self) -> &String {\n        match self {\n            SessionAuthorization::User(username) => username,\n            SessionAuthorization::Ticket { username, .. } => username,\n        }\n    }\n}\n\nasync fn is_user_admin(req: &Request, auth: &SessionAuthorization) -> poem::Result<bool> {\n    let services: Data<&Services> = <_>::from_request_without_body(req).await?;\n\n    let SessionAuthorization::User(username) = auth else {\n        return Ok(false)\n    };\n\n    let mut config_provider = services.config_provider.lock().await;\n    let targets = config_provider.list_targets().await?;\n    for target in targets {\n        if matches!(target.options, TargetOptions::WebAdmin(_))\n            && config_provider\n                .authorize_target(username, &target.name)\n                .await?\n        {\n            drop(config_provider);\n            return Ok(true);\n        }\n    }\n    Ok(false)\n}\n\npub fn endpoint_admin_auth<E: Endpoint + 'static>(e: E) -> impl Endpoint {\n    e.around(|ep, req| async move {\n        let auth: Data<&SessionAuthorization> = <_>::from_request_without_body(&req).await?;\n        if is_user_admin(&req, &auth).await? {\n            return Ok(ep.call(req).await?.into_response());\n        }\n        Err(poem::Error::from_status(StatusCode::UNAUTHORIZED))\n    })\n}\n\npub fn page_admin_auth<E: Endpoint + 'static>(e: E) -> impl Endpoint {\n    e.around(|ep, req| async move {\n        let auth: Data<&SessionAuthorization> = <_>::from_request_without_body(&req).await?;\n        let session: &Session = <_>::from_request_without_body(&req).await?;\n        if is_user_admin(&req, &auth).await? {\n            return Ok(ep.call(req).await?.into_response());\n        }\n        session.clear();\n        Ok(gateway_redirect(&req).into_response())\n    })\n}\n\npub async fn _inner_auth<E: Endpoint + 'static>(\n    ep: Arc<E>,\n    req: Request,\n) -> poem::Result<Option<E::Output>> {\n    let session: &Session = FromRequest::from_request_without_body(&req).await?;\n\n    Ok(match session.get_auth() {\n        Some(auth) => Some(ep.data(auth).call(req).await?),\n        _ => None,\n    })\n}\n\npub fn endpoint_auth<E: Endpoint + 'static>(e: E) -> impl Endpoint<Output = E::Output> {\n    e.around(|ep, req| async move {\n        _inner_auth(ep, req)\n            .await?\n            .ok_or_else(|| poem::Error::from_status(StatusCode::UNAUTHORIZED))\n    })\n}\n\npub fn page_auth<E: Endpoint + 'static>(e: E) -> impl Endpoint {\n    e.around(|ep, req| async move {\n        let err_resp = gateway_redirect(&req).into_response();\n        Ok(_inner_auth(ep, req)\n            .await?\n            .map(IntoResponse::into_response)\n            .unwrap_or(err_resp))\n    })\n}\n\npub fn gateway_redirect(req: &Request) -> Response {\n    let path = req\n        .original_uri()\n        .path_and_query()\n        .map(|p| p.to_string())\n        .unwrap_or_else(|| \"\".into());\n\n    let path = format!(\n        \"/@warpgate#/login?next={}\",\n        utf8_percent_encode(&path, NON_ALPHANUMERIC),\n    );\n\n    Redirect::temporary(path).into_response()\n}\n\npub async fn get_auth_state_for_request(\n    username: &str,\n    session: &Session,\n    store: &mut AuthStateStore,\n) -> Result<Arc<Mutex<AuthState>>, WarpgateError> {\n    if let Some(id) = session.get_auth_state_id() {\n        if !store.contains_key(&id.0) {\n            session.remove(AUTH_STATE_ID_SESSION_KEY)\n        }\n    }\n\n    match session.get_auth_state_id() {\n        Some(id) => Ok(store.get(&id.0).ok_or(WarpgateError::InconsistentState)?),\n        None => {\n            let (id, state) = store\n                .create(None, username, crate::common::PROTOCOL_NAME)\n                .await?;\n            session.set(AUTH_STATE_ID_SESSION_KEY, AuthStateId(id));\n            Ok(state)\n        }\n    }\n}\n\npub async fn authorize_session(req: &Request, username: String) -> poem::Result<()> {\n    let session_middleware: Data<&Arc<Mutex<SessionStore>>> =\n        <_>::from_request_without_body(req).await?;\n    let session: &Session = <_>::from_request_without_body(req).await?;\n\n    let server_handle = session_middleware\n        .lock()\n        .await\n        .create_handle_for(req)\n        .await?;\n    server_handle\n        .lock()\n        .await\n        .set_username(username.clone())\n        .await?;\n    session.set_auth(SessionAuthorization::User(username));\n\n    Ok(())\n}\n"], "fixing_code": ["use std::sync::Arc;\n\nuse chrono::{DateTime, Utc};\nuse poem::session::Session;\nuse poem::web::Data;\nuse poem::Request;\nuse poem_openapi::param::Path;\nuse poem_openapi::payload::Json;\nuse poem_openapi::{ApiResponse, Enum, Object, OpenApi};\nuse tokio::sync::Mutex;\nuse tracing::*;\nuse uuid::Uuid;\nuse warpgate_common::auth::{AuthCredential, AuthResult, AuthState, CredentialKind};\nuse warpgate_common::{Secret, WarpgateError};\nuse warpgate_core::Services;\n\nuse crate::common::{\n    authorize_session, endpoint_auth, get_auth_state_for_request, SessionAuthorization, SessionExt,\n};\nuse crate::session::SessionStore;\n\npub struct Api;\n\n#[derive(Object)]\nstruct LoginRequest {\n    username: String,\n    password: String,\n}\n\n#[derive(Object)]\nstruct OtpLoginRequest {\n    otp: String,\n}\n\n#[derive(Enum)]\nenum ApiAuthState {\n    NotStarted,\n    Failed,\n    PasswordNeeded,\n    OtpNeeded,\n    SsoNeeded,\n    WebUserApprovalNeeded,\n    PublicKeyNeeded,\n    Success,\n}\n\n#[derive(Object)]\nstruct LoginFailureResponse {\n    state: ApiAuthState,\n}\n\n#[derive(ApiResponse)]\nenum LoginResponse {\n    #[oai(status = 201)]\n    Success,\n\n    #[oai(status = 401)]\n    Failure(Json<LoginFailureResponse>),\n}\n\n#[derive(ApiResponse)]\nenum LogoutResponse {\n    #[oai(status = 201)]\n    Success,\n}\n\n#[derive(Object)]\nstruct AuthStateResponseInternal {\n    pub protocol: String,\n    pub address: Option<String>,\n    pub started: DateTime<Utc>,\n    pub state: ApiAuthState,\n    pub identification_string: String,\n}\n\n#[derive(ApiResponse)]\nenum AuthStateResponse {\n    #[oai(status = 200)]\n    Ok(Json<AuthStateResponseInternal>),\n    #[oai(status = 404)]\n    NotFound,\n}\n\nimpl From<AuthResult> for ApiAuthState {\n    fn from(state: AuthResult) -> Self {\n        match state {\n            AuthResult::Rejected => ApiAuthState::Failed,\n            AuthResult::Need(kinds) => match kinds.iter().next() {\n                Some(CredentialKind::Password) => ApiAuthState::PasswordNeeded,\n                Some(CredentialKind::Totp) => ApiAuthState::OtpNeeded,\n                Some(CredentialKind::Sso) => ApiAuthState::SsoNeeded,\n                Some(CredentialKind::WebUserApproval) => ApiAuthState::WebUserApprovalNeeded,\n                Some(CredentialKind::PublicKey) => ApiAuthState::PublicKeyNeeded,\n                None => ApiAuthState::Failed,\n            },\n            AuthResult::Accepted { .. } => ApiAuthState::Success,\n        }\n    }\n}\n\n#[OpenApi]\nimpl Api {\n    #[oai(path = \"/auth/login\", method = \"post\", operation_id = \"login\")]\n    async fn api_auth_login(\n        &self,\n        req: &Request,\n        session: &Session,\n        services: Data<&Services>,\n        body: Json<LoginRequest>,\n    ) -> poem::Result<LoginResponse> {\n        let mut auth_state_store = services.auth_state_store.lock().await;\n        let state_arc = match get_auth_state_for_request(\n            &body.username,\n            session,\n            &mut auth_state_store,\n        )\n        .await\n        {\n            Err(WarpgateError::UserNotFound) => {\n                return Ok(LoginResponse::Failure(Json(LoginFailureResponse {\n                    state: ApiAuthState::Failed,\n                })))\n            }\n            x => x,\n        }?;\n        let mut state = state_arc.lock().await;\n\n        let mut cp = services.config_provider.lock().await;\n\n        let password_cred = AuthCredential::Password(Secret::new(body.password.clone()));\n        if cp\n            .validate_credential(&state.username(), &password_cred)\n            .await?\n        {\n            state.add_valid_credential(password_cred);\n        }\n\n        match state.verify() {\n            AuthResult::Accepted { username } => {\n                auth_state_store.complete(state.id()).await;\n                authorize_session(req, username).await?;\n                Ok(LoginResponse::Success)\n            }\n            x => {\n                error!(\"Auth rejected\");\n                Ok(LoginResponse::Failure(Json(LoginFailureResponse {\n                    state: x.into(),\n                })))\n            }\n        }\n    }\n\n    #[oai(path = \"/auth/otp\", method = \"post\", operation_id = \"otpLogin\")]\n    async fn api_auth_otp_login(\n        &self,\n        req: &Request,\n        session: &Session,\n        services: Data<&Services>,\n        body: Json<OtpLoginRequest>,\n    ) -> poem::Result<LoginResponse> {\n        let state_id = session.get_auth_state_id();\n\n        let mut auth_state_store = services.auth_state_store.lock().await;\n\n        let Some(state_arc) = state_id.and_then(|id| auth_state_store.get(&id.0)) else {\n            return Ok(LoginResponse::Failure(Json(LoginFailureResponse {\n                state: ApiAuthState::NotStarted,\n            })))\n        };\n\n        let mut state = state_arc.lock().await;\n\n        let mut cp = services.config_provider.lock().await;\n\n        let otp_cred = AuthCredential::Otp(body.otp.clone().into());\n        if cp.validate_credential(state.username(), &otp_cred).await? {\n            state.add_valid_credential(otp_cred);\n        }\n\n        match state.verify() {\n            AuthResult::Accepted { username } => {\n                auth_state_store.complete(state.id()).await;\n                authorize_session(req, username).await?;\n                Ok(LoginResponse::Success)\n            }\n            x => Ok(LoginResponse::Failure(Json(LoginFailureResponse {\n                state: x.into(),\n            }))),\n        }\n    }\n\n    #[oai(path = \"/auth/logout\", method = \"post\", operation_id = \"logout\")]\n    async fn api_auth_logout(\n        &self,\n        session: &Session,\n        session_middleware: Data<&Arc<Mutex<SessionStore>>>,\n    ) -> poem::Result<LogoutResponse> {\n        session_middleware.lock().await.remove_session(session);\n        session.clear();\n        info!(\"Logged out\");\n        Ok(LogoutResponse::Success)\n    }\n\n    #[oai(\n        path = \"/auth/state\",\n        method = \"get\",\n        operation_id = \"getDefaultAuthState\"\n    )]\n    async fn api_default_auth_state(\n        &self,\n        session: &Session,\n        services: Data<&Services>,\n    ) -> poem::Result<AuthStateResponse> {\n        let Some(state_id) = session.get_auth_state_id() else {\n            return Ok(AuthStateResponse::NotFound)\n        };\n        let store = services.auth_state_store.lock().await;\n        let Some(state_arc) = store.get(&state_id.0) else {\n            return Ok(AuthStateResponse::NotFound);\n        };\n        serialize_auth_state_inner(state_arc, *services).await\n    }\n\n    #[oai(\n        path = \"/auth/state\",\n        method = \"delete\",\n        operation_id = \"cancelDefaultAuth\"\n    )]\n    async fn api_cancel_default_auth(\n        &self,\n        session: &Session,\n        services: Data<&Services>,\n    ) -> poem::Result<AuthStateResponse> {\n        let Some(state_id) = session.get_auth_state_id() else {\n            return Ok(AuthStateResponse::NotFound)\n        };\n        let mut store = services.auth_state_store.lock().await;\n        let Some(state_arc) = store.get(&state_id.0) else {\n            return Ok(AuthStateResponse::NotFound);\n        };\n        state_arc.lock().await.reject();\n        store.complete(&state_id.0).await;\n        session.clear_auth_state();\n        serialize_auth_state_inner(state_arc, *services).await\n    }\n\n    #[oai(\n        path = \"/auth/state/:id\",\n        method = \"get\",\n        operation_id = \"get_auth_state\",\n        transform = \"endpoint_auth\"\n    )]\n    async fn api_auth_state(\n        &self,\n        services: Data<&Services>,\n        auth: Option<Data<&SessionAuthorization>>,\n        id: Path<Uuid>,\n    ) -> poem::Result<AuthStateResponse> {\n        let state_arc = get_auth_state(&id, &services, auth.map(|x| x.0)).await;\n        let Some(state_arc) = state_arc else {\n            return Ok(AuthStateResponse::NotFound);\n        };\n        serialize_auth_state_inner(state_arc, *services).await\n    }\n\n    #[oai(\n        path = \"/auth/state/:id/approve\",\n        method = \"post\",\n        operation_id = \"approve_auth\",\n        transform = \"endpoint_auth\"\n    )]\n    async fn api_approve_auth(\n        &self,\n        services: Data<&Services>,\n        auth: Option<Data<&SessionAuthorization>>,\n        id: Path<Uuid>,\n    ) -> poem::Result<AuthStateResponse> {\n        let Some(state_arc) = get_auth_state(&id, &services, auth.map(|x|x.0)).await else {\n            return Ok(AuthStateResponse::NotFound);\n        };\n\n        let auth_result = {\n            let mut state = state_arc.lock().await;\n            state.add_valid_credential(AuthCredential::WebUserApproval);\n            state.verify()\n        };\n\n        if let AuthResult::Accepted { .. } = auth_result {\n            services.auth_state_store.lock().await.complete(&id).await;\n        }\n        serialize_auth_state_inner(state_arc, *services).await\n    }\n\n    #[oai(\n        path = \"/auth/state/:id/reject\",\n        method = \"post\",\n        operation_id = \"reject_auth\",\n        transform = \"endpoint_auth\"\n    )]\n    async fn api_reject_auth(\n        &self,\n        services: Data<&Services>,\n        auth: Option<Data<&SessionAuthorization>>,\n        id: Path<Uuid>,\n    ) -> poem::Result<AuthStateResponse> {\n        let Some(state_arc) = get_auth_state(&id, &services, auth.map(|x|x.0)).await else {\n            return Ok(AuthStateResponse::NotFound);\n        };\n        state_arc.lock().await.reject();\n        services.auth_state_store.lock().await.complete(&id).await;\n        serialize_auth_state_inner(state_arc, *services).await\n    }\n}\n\nasync fn get_auth_state(\n    id: &Uuid,\n    services: &Services,\n    auth: Option<&SessionAuthorization>,\n) -> Option<Arc<Mutex<AuthState>>> {\n    let store = services.auth_state_store.lock().await;\n\n    let Some(auth) = auth else {\n        return None;\n    };\n\n    let SessionAuthorization::User(username) = auth else {\n        return None;\n    };\n\n    let Some(state_arc) = store.get(id) else {\n        return None;\n    };\n\n    {\n        let state = state_arc.lock().await;\n        if state.username() != username {\n            return None;\n        }\n    }\n\n    Some(state_arc)\n}\n\nasync fn serialize_auth_state_inner(\n    state_arc: Arc<Mutex<AuthState>>,\n    services: &Services,\n) -> poem::Result<AuthStateResponse> {\n    let state = state_arc.lock().await;\n\n    let session_state_store = services.state.lock().await;\n    let session_state = state\n        .session_id()\n        .and_then(|session_id| session_state_store.sessions.get(&session_id));\n\n    let peer_addr = match session_state {\n        Some(x) => x.lock().await.remote_address,\n        None => None,\n    };\n\n    Ok(AuthStateResponse::Ok(Json(AuthStateResponseInternal {\n        protocol: state.protocol().to_string(),\n        address: peer_addr.map(|x| x.ip().to_string()),\n        started: *state.started(),\n        state: state.verify().into(),\n        identification_string: state.identification_string().to_owned(),\n    })))\n}\n", "use std::sync::Arc;\nuse std::time::Duration;\n\nuse http::StatusCode;\nuse percent_encoding::{utf8_percent_encode, NON_ALPHANUMERIC};\nuse poem::session::Session;\nuse poem::web::{Data, Redirect};\nuse poem::{Endpoint, EndpointExt, FromRequest, IntoResponse, Request, Response};\nuse serde::{Deserialize, Serialize};\nuse tokio::sync::Mutex;\nuse uuid::Uuid;\nuse warpgate_common::auth::AuthState;\nuse warpgate_common::{ProtocolName, TargetOptions, WarpgateError};\nuse warpgate_core::{AuthStateStore, Services};\n\nuse crate::session::SessionStore;\n\npub const PROTOCOL_NAME: ProtocolName = \"HTTP\";\nstatic TARGET_SESSION_KEY: &str = \"target_name\";\nstatic AUTH_SESSION_KEY: &str = \"auth\";\nstatic AUTH_STATE_ID_SESSION_KEY: &str = \"auth_state_id\";\npub static SESSION_MAX_AGE: Duration = Duration::from_secs(60 * 30);\npub static COOKIE_MAX_AGE: Duration = Duration::from_secs(60 * 60 * 24);\npub static SESSION_COOKIE_NAME: &str = \"warpgate-http-session\";\n\npub trait SessionExt {\n    fn has_selected_target(&self) -> bool;\n    fn get_target_name(&self) -> Option<String>;\n    fn set_target_name(&self, target_name: String);\n    fn is_authenticated(&self) -> bool;\n    fn get_username(&self) -> Option<String>;\n    fn get_auth(&self) -> Option<SessionAuthorization>;\n    fn set_auth(&self, auth: SessionAuthorization);\n    fn get_auth_state_id(&self) -> Option<AuthStateId>;\n    fn clear_auth_state(&self);\n}\n\nimpl SessionExt for Session {\n    fn has_selected_target(&self) -> bool {\n        self.get_target_name().is_some()\n    }\n\n    fn get_target_name(&self) -> Option<String> {\n        self.get(TARGET_SESSION_KEY)\n    }\n\n    fn set_target_name(&self, target_name: String) {\n        self.set(TARGET_SESSION_KEY, target_name);\n    }\n\n    fn is_authenticated(&self) -> bool {\n        self.get_username().is_some()\n    }\n\n    fn get_username(&self) -> Option<String> {\n        self.get_auth().map(|x| x.username().to_owned())\n    }\n\n    fn get_auth(&self) -> Option<SessionAuthorization> {\n        self.get(AUTH_SESSION_KEY)\n    }\n\n    fn set_auth(&self, auth: SessionAuthorization) {\n        self.set(AUTH_SESSION_KEY, auth);\n    }\n\n    fn get_auth_state_id(&self) -> Option<AuthStateId> {\n        self.get(AUTH_STATE_ID_SESSION_KEY)\n    }\n\n    fn clear_auth_state(&self) {\n        self.remove(AUTH_STATE_ID_SESSION_KEY)\n    }\n}\n\n#[derive(Clone, Serialize, Deserialize)]\npub struct AuthStateId(pub Uuid);\n\n#[derive(Clone, Serialize, Deserialize)]\npub enum SessionAuthorization {\n    User(String),\n    Ticket {\n        username: String,\n        target_name: String,\n    },\n}\n\nimpl SessionAuthorization {\n    pub fn username(&self) -> &String {\n        match self {\n            SessionAuthorization::User(username) => username,\n            SessionAuthorization::Ticket { username, .. } => username,\n        }\n    }\n}\n\nasync fn is_user_admin(req: &Request, auth: &SessionAuthorization) -> poem::Result<bool> {\n    let services: Data<&Services> = <_>::from_request_without_body(req).await?;\n\n    let SessionAuthorization::User(username) = auth else {\n        return Ok(false)\n    };\n\n    let mut config_provider = services.config_provider.lock().await;\n    let targets = config_provider.list_targets().await?;\n    for target in targets {\n        if matches!(target.options, TargetOptions::WebAdmin(_))\n            && config_provider\n                .authorize_target(username, &target.name)\n                .await?\n        {\n            drop(config_provider);\n            return Ok(true);\n        }\n    }\n    Ok(false)\n}\n\npub fn endpoint_admin_auth<E: Endpoint + 'static>(e: E) -> impl Endpoint {\n    e.around(|ep, req| async move {\n        let auth: Data<&SessionAuthorization> = <_>::from_request_without_body(&req).await?;\n        if is_user_admin(&req, &auth).await? {\n            return Ok(ep.call(req).await?.into_response());\n        }\n        Err(poem::Error::from_status(StatusCode::UNAUTHORIZED))\n    })\n}\n\npub fn page_admin_auth<E: Endpoint + 'static>(e: E) -> impl Endpoint {\n    e.around(|ep, req| async move {\n        let auth: Data<&SessionAuthorization> = <_>::from_request_without_body(&req).await?;\n        let session: &Session = <_>::from_request_without_body(&req).await?;\n        if is_user_admin(&req, &auth).await? {\n            return Ok(ep.call(req).await?.into_response());\n        }\n        session.clear();\n        Ok(gateway_redirect(&req).into_response())\n    })\n}\n\npub async fn _inner_auth<E: Endpoint + 'static>(\n    ep: Arc<E>,\n    req: Request,\n) -> poem::Result<Option<E::Output>> {\n    let session: &Session = FromRequest::from_request_without_body(&req).await?;\n\n    Ok(match session.get_auth() {\n        Some(auth) => Some(ep.data(auth).call(req).await?),\n        _ => None,\n    })\n}\n\npub fn endpoint_auth<E: Endpoint + 'static>(e: E) -> impl Endpoint<Output = E::Output> {\n    e.around(|ep, req| async move {\n        _inner_auth(ep, req)\n            .await?\n            .ok_or_else(|| poem::Error::from_status(StatusCode::UNAUTHORIZED))\n    })\n}\n\npub fn page_auth<E: Endpoint + 'static>(e: E) -> impl Endpoint {\n    e.around(|ep, req| async move {\n        let err_resp = gateway_redirect(&req).into_response();\n        Ok(_inner_auth(ep, req)\n            .await?\n            .map(IntoResponse::into_response)\n            .unwrap_or(err_resp))\n    })\n}\n\npub fn gateway_redirect(req: &Request) -> Response {\n    let path = req\n        .original_uri()\n        .path_and_query()\n        .map(|p| p.to_string())\n        .unwrap_or_else(|| \"\".into());\n\n    let path = format!(\n        \"/@warpgate#/login?next={}\",\n        utf8_percent_encode(&path, NON_ALPHANUMERIC),\n    );\n\n    Redirect::temporary(path).into_response()\n}\n\npub async fn get_auth_state_for_request(\n    username: &str,\n    session: &Session,\n    store: &mut AuthStateStore,\n) -> Result<Arc<Mutex<AuthState>>, WarpgateError> {\n    if let Some(id) = session.get_auth_state_id() {\n        if !store.contains_key(&id.0) {\n            session.remove(AUTH_STATE_ID_SESSION_KEY)\n        }\n    }\n\n    if let Some(id) = session.get_auth_state_id() {\n        let state = store.get(&id.0).ok_or(WarpgateError::InconsistentState)?;\n\n        let existing_matched = state.lock().await.username() == username;\n        if existing_matched {\n            return Ok(state);\n        }\n    }\n\n    let (id, state) = store\n        .create(None, username, crate::common::PROTOCOL_NAME)\n        .await?;\n    session.set(AUTH_STATE_ID_SESSION_KEY, AuthStateId(id));\n    Ok(state)\n}\n\npub async fn authorize_session(req: &Request, username: String) -> poem::Result<()> {\n    let session_middleware: Data<&Arc<Mutex<SessionStore>>> =\n        <_>::from_request_without_body(req).await?;\n    let session: &Session = <_>::from_request_without_body(req).await?;\n\n    let server_handle = session_middleware\n        .lock()\n        .await\n        .create_handle_for(req)\n        .await?;\n    server_handle\n        .lock()\n        .await\n        .set_username(username.clone())\n        .await?;\n    session.set_auth(SessionAuthorization::User(username));\n\n    Ok(())\n}\n"], "filenames": ["warpgate-protocol-http/src/api/auth.rs", "warpgate-protocol-http/src/common.rs"], "buggy_code_start_loc": [132, 197], "buggy_code_end_loc": [133, 207], "fixing_code_start_loc": [132, 197], "fixing_code_end_loc": [133, 211], "type": "CWE-863", "message": "Warpgate is an open source SSH, HTTPS and MySQL bastion host for Linux. In affected versions there is a privilege escalation vulnerability through a non-admin user's account. Limited users can impersonate another user's account if only single-factor authentication is configured. If a user knows an admin username, opens the login screen and attempts to authenticate with an incorrect password they can subsequently enter a valid non-admin username and password they will be logged in as the admin user. All installations prior to version 0.9.0 are affected. All users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-48712", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-24T17:15:08.453", "lastModified": "2023-11-30T20:26:37.460", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Warpgate is an open source SSH, HTTPS and MySQL bastion host for Linux. In affected versions there is a privilege escalation vulnerability through a non-admin user's account. Limited users can impersonate another user's account if only single-factor authentication is configured. If a user knows an admin username, opens the login screen and attempts to authenticate with an incorrect password they can subsequently enter a valid non-admin username and password they will be logged in as the admin user. All installations prior to version 0.9.0 are affected. All users are advised to upgrade. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "Warpgate es un host basti\u00f3n SSH, HTTPS y MySQL de c\u00f3digo abierto para Linux. En las versiones afectadas existe una vulnerabilidad de escalada de privilegios a trav\u00e9s de una cuenta de usuario que no es administrador. Los usuarios limitados pueden hacerse pasar por la cuenta de otro usuario si solo se configura la autenticaci\u00f3n de un solo factor. Si un usuario conoce un nombre de usuario de administrador, abre la pantalla de inicio de sesi\u00f3n e intenta autenticarse con una contrase\u00f1a incorrecta, posteriormente podr\u00e1 ingresar un nombre de usuario y una contrase\u00f1a v\u00e1lidos que no sean de administrador y iniciar\u00e1 sesi\u00f3n como usuario administrador. Todas las instalaciones anteriores a la versi\u00f3n 0.9.0 se ven afectadas. Se recomienda a todos los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:warpgate_project:warpgate:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.8.1", "matchCriteriaId": "598C2B38-2E7C-442E-8D61-5799221F6781"}]}]}], "references": [{"url": "https://github.com/warp-tech/warpgate/commit/e3b26b2699257b9482dce2e9157bd9b5e05d9c76", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/warp-tech/warpgate/security/advisories/GHSA-c94j-vqr5-3mxr", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/warp-tech/warpgate/commit/e3b26b2699257b9482dce2e9157bd9b5e05d9c76"}}