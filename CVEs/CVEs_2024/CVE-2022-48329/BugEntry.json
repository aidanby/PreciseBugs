{"buggy_code": ["<?php\nApp::uses('AppModel', 'Model');\nApp::uses('TmpFileTool', 'Tools');\n\n/**\n * @property Tag $Tag\n * @property Galaxy $Galaxy\n * @property GalaxyClusterRelation $GalaxyClusterRelation\n * @property GalaxyElement $GalaxyElement\n * @property SharingGroup $SharingGroup\n */\nclass GalaxyCluster extends AppModel\n{\n    public $useTable = 'galaxy_clusters';\n\n    public $recursive = -1;\n\n    public $actsAs = array(\n        'AuditLog',\n        'SysLogLogable.SysLogLogable' => array( // TODO Audit, logable\n            'userModel' => 'User',\n            'userKey' => 'user_id',\n            'change' => 'full'),\n        'Containable',\n    );\n\n    private $__assetCache = array();\n\n    public $validate = array(\n        'value' => array(\n            'stringNotEmpty' => array(\n                'rule' => array('stringNotEmpty')\n            )\n        ),\n        'uuid' => array(\n            'uuid' => array(\n                'rule' => 'uuid',\n                'message' => 'Please provide a valid RFC 4122 UUID'\n            ),\n            'unique' => array(\n                'rule' => 'isUnique',\n                'message' => 'The UUID provided is not unique',\n                'required' => 'create'\n            )\n        ),\n        'distribution' => array(\n            'rule' => array('inList', array('0', '1', '2', '3', '4')),\n            'message' => 'Options: Your organisation only, This community only, Connected communities, All communities, Sharing group',\n            'required' => true\n        ),\n        'published' => array(\n            'boolean' => array(\n                'rule' => array('boolean'),\n            ),\n        ),\n    );\n\n    public $belongsTo = array(\n        'Galaxy' => array(\n            'className' => 'Galaxy',\n            'foreignKey' => 'galaxy_id',\n        ),\n        'Tag' => array(\n            'foreignKey' => false,\n            'conditions' => array('GalaxyCluster.tag_name = Tag.name')\n        ),\n        'Org' => array(\n            'className' => 'Organisation',\n            'foreignKey' => 'org_id'\n        ),\n        'Orgc' => array(\n            'className' => 'Organisation',\n            'foreignKey' => 'orgc_id'\n        ),\n        'SharingGroup' => array(\n                'className' => 'SharingGroup',\n                'foreignKey' => 'sharing_group_id'\n        )\n    );\n\n    private $__clusterCache = array();\n    private $deletedClusterUUID;\n    public $bulkEntry = false;\n\n    public $hasMany = array(\n        'GalaxyElement' => array('dependent' => true),\n        'GalaxyClusterRelation' => array(\n            'className' => 'GalaxyClusterRelation',\n            'foreignKey' => 'galaxy_cluster_id',\n            'dependent' => true,\n        ),\n        'TargetingClusterRelation' => array(\n            'className' => 'GalaxyClusterRelation',\n            'foreignKey' => 'referenced_galaxy_cluster_id',\n        ),\n    );\n\n    public $validFormats = array(\n        'json' => array('json', 'JsonExport', 'json'),\n    );\n\n    public function beforeValidate($options = array())\n    {\n        $cluster = &$this->data['GalaxyCluster'];\n        if (!isset($cluster['description'])) {\n            $cluster['description'] = '';\n        }\n        if (isset($cluster['distribution']) && $cluster['distribution'] != 4) {\n            $cluster['sharing_group_id'] = null;\n        }\n        if (!isset($cluster['published'])) {\n            $cluster['published'] = false;\n        }\n        if (!isset($cluster['authors'])) {\n            $cluster['authors'] = '';\n        } elseif (is_array($cluster['authors'])) {\n            $cluster['authors'] = JsonTool::encode($cluster['authors']);\n        }\n        return true;\n    }\n\n    public function afterFind($results, $primary = false)\n    {\n        foreach ($results as $k => $result) {\n            if (isset($result[$this->alias]['authors'])) {\n                $results[$k][$this->alias]['authors'] = json_decode($result[$this->alias]['authors'], true);\n            }\n            if (isset($result[$this->alias]['distribution']) && $result[$this->alias]['distribution'] != 4) {\n                unset($results[$k]['SharingGroup']);\n            }\n            if (isset($result[$this->alias]['org_id']) && $result[$this->alias]['org_id'] == 0) {\n                if (isset($results[$k]['Org'])) {\n                    $results[$k]['Org'] = Organisation::GENERIC_MISP_ORGANISATION;\n                }\n            }\n            if (isset($result[$this->alias]['orgc_id']) && $result[$this->alias]['orgc_id'] == 0) {\n                if (isset($results[$k]['Orgc'])) {\n                    $results[$k]['Orgc'] = Organisation::GENERIC_MISP_ORGANISATION;\n                }\n            }\n\n            if (!empty($result['GalaxyClusterRelation'])) {\n                foreach ($result['GalaxyClusterRelation'] as $i => $relation) {\n                    if (isset($relation['distribution']) && $relation['distribution'] != 4) {\n                        unset($results[$k]['GalaxyClusterRelation'][$i]['SharingGroup']);\n                    }\n                }\n            }\n        }\n        return $results;\n    }\n\n    public function afterSave($created, $options = array())\n    {\n        // Update all relations IDs that are unknown but saved\n        if (!$this->bulkEntry) {\n            $cluster = $this->data[$this->alias];\n            $cluster = $this->fetchAndSetUUID($cluster);\n            $this->GalaxyClusterRelation->updateAll(\n                array('GalaxyClusterRelation.referenced_galaxy_cluster_id' => $cluster['id']),\n                array('GalaxyClusterRelation.referenced_galaxy_cluster_uuid' => $cluster['uuid'])\n            );\n        }\n    }\n\n    public function afterDelete()\n    {\n        // Remove all relations IDs now that the cluster is unknown\n        if (!empty($this->deletedClusterUUID)) {\n            $this->GalaxyClusterRelation->updateAll(\n                array('GalaxyClusterRelation.referenced_galaxy_cluster_id' => 0),\n                array('GalaxyClusterRelation.referenced_galaxy_cluster_uuid' => $this->deletedClusterUUID)\n            );\n            $this->GalaxyElement->deleteAll(array('GalaxyElement.galaxy_cluster_id' => $this->id));\n            $this->GalaxyClusterRelation->deleteAll(array('GalaxyClusterRelation.galaxy_cluster_uuid' => $this->deletedClusterUUID));\n        }\n    }\n\n    public function beforeDelete($cascade = true)\n    {\n        $cluster = $this->find('first', array(\n            'conditions' => array('id' => $this->id),\n            'fields' => array('uuid'),\n        ));\n        if (!empty($cluster)) {\n            $this->deletedClusterUUID = $cluster[$this->alias]['uuid'];\n        } else {\n            $this->deletedClusterUUID = null;\n        }\n    }\n\n    /**\n     * arrangeData Move linked data into the cluster model key\n     *\n     * @return array The arranged cluster\n     */\n    public function arrangeData($cluster)\n    {\n        $models = array('Galaxy', 'SharingGroup', 'GalaxyElement', 'GalaxyClusterRelation', 'Org', 'Orgc', 'TargetingClusterRelation');\n        foreach ($models as $model) {\n            if (isset($cluster[$model])) {\n                $cluster['GalaxyCluster'][$model] = $cluster[$model];\n                unset($cluster[$model]);\n            }\n        }\n        return $cluster;\n    }\n\n    public function generateMissingRelations()\n    {\n        $missingRelations = $this->GalaxyClusterRelation->find('column', [\n            'conditions' => ['referenced_galaxy_cluster_id' => 0],\n            'fields' => ['referenced_galaxy_cluster_uuid'],\n            'unique' => true,\n        ]);\n        if (empty($missingRelations)) {\n            return;\n        }\n        $ids = $this->find('list', [\n            'conditions' => ['uuid' => $missingRelations],\n            'fields' => ['uuid', 'id']\n        ]);\n        foreach ($ids as $uuid => $id) {\n            $this->GalaxyClusterRelation->updateAll(\n                ['referenced_galaxy_cluster_id' => $id],\n                ['referenced_galaxy_cluster_uuid' => $uuid]\n            );\n        }\n    }\n\n    public function fetchAndSetUUID($cluster)\n    {\n        if (!isset($cluster['uuid'])) {\n            $alias = $this->alias;\n            $tmp = $this->find('first', array(\n                'recursive' => -1,\n                'fields' => array(\"${alias}.id\", \"${alias}.uuid\"),\n                'conditions' => array(\"${alias}.id\" => $cluster['id'])\n            ));\n            $cluster['uuid'] = $tmp[$alias]['uuid'];\n        }\n        return $cluster;\n    }\n\n    /**\n     * saveCluster Respecting ACL saves a cluster, its elements, relations and set correct fields where applicable\n     *\n     * @param  array $user\n     * @param  array $cluster\n     * @param  bool $allowEdit redirects to the edit function\n     * @return array The errors if any\n     */\n    public function saveCluster(array $user, array $cluster, $allowEdit=false)\n    {\n        $errors = array();\n        if (!$user['Role']['perm_galaxy_editor'] && !$user['Role']['perm_site_admin']) {\n            $errors[] = __('Incorrect permission');\n            return $errors;\n        }\n        $galaxy = $this->Galaxy->find('first', array('conditions' => array(\n            'id' => $cluster['GalaxyCluster']['galaxy_id']\n        )));\n        if (empty($galaxy)) {\n            $errors[] = __('Galaxy not found');\n            return $errors;\n        } else {\n            $galaxy = $galaxy['Galaxy'];\n        }\n        unset($cluster['GalaxyCluster']['id']);\n        $cluster['GalaxyCluster']['locked'] = false;\n\n        if (isset($cluster['GalaxyCluster']['uuid'])) {\n            $this->GalaxyClusterBlocklist = ClassRegistry::init('GalaxyClusterBlocklist');\n            if ($this->GalaxyClusterBlocklist->checkIfBlocked($cluster['GalaxyCluster']['uuid'])) {\n                $errors[] = __('Blocked by blocklist');\n                return $errors;\n            }\n\n            // check if the uuid already exists\n            $existingGalaxyCluster = $this->find('first', array('conditions' => array('GalaxyCluster.uuid' => $cluster['GalaxyCluster']['uuid'])));\n            if ($existingGalaxyCluster) {\n                if ($existingGalaxyCluster['GalaxyCluster']['galaxy_id'] != $galaxy['id']) { // cluster already exists in another galaxy\n                    $errors[] = __('Cluster already exists in another galaxy');\n                    return $errors;\n                }\n                if (!$existingGalaxyCluster['GalaxyCluster']['default']) {\n                    $errors[] = __('Edit not allowed on default clusters');\n                    return $errors;\n                }\n                if (!$allowEdit) {\n                    $errors[] = __('Edit not allowed');\n                    return $errors;\n                }\n                $errors = $this->editCluster($user, $cluster);\n                return $errors;\n            }\n        } else {\n            $cluster['GalaxyCluster']['uuid'] = CakeText::uuid();\n        }\n        if (!isset($cluster['GalaxyCluster']['default'])) {\n            $cluster['GalaxyCluster']['default'] = false;\n        }\n        if (!isset($cluster['GalaxyCluster']['published'])) {\n            $cluster['GalaxyCluster']['published'] = false;\n        }\n        if (!isset($cluster['GalaxyCluster']['collection_uuid'])) {\n            $cluster['GalaxyCluster']['collection_uuid'] = '';\n        }\n        if (!empty($cluster['GalaxyCluster']['extends_uuid'])) {\n            $forkedCluster = $this->find('first', array('conditions' => array('GalaxyCluster.uuid' => $cluster['GalaxyCluster']['extends_uuid'])));\n            if (!empty($forkedCluster) && $forkedCluster['GalaxyCluster']['galaxy_id'] != $galaxy['id']) {\n                $errors[] = __('Cluster forks have to belong to the same galaxy as the parent');\n                return $errors;\n            }\n        } else {\n            $cluster['GalaxyCluster']['extends_version'] = null;\n        }\n        if (!isset($cluster['GalaxyCluster']['distribution'])) {\n            $cluster['GalaxyCluster']['distribution'] = Configure::read('MISP.default_event_distribution'); // use default event distribution\n        }\n        if ($cluster['GalaxyCluster']['distribution'] != 4) {\n            $cluster['GalaxyCluster']['sharing_group_id'] = null;\n        }\n\n        // In contrary to the capture context, we make sure the cluster belongs to the organisation initiating the save\n        $cluster['GalaxyCluster']['org_id'] = $user['Organisation']['id'];\n        $cluster['GalaxyCluster']['orgc_id'] = $user['Organisation']['id'];\n\n        if ($user['Role']['perm_sync']) {\n            if (isset($cluster['GalaxyCluster']['distribution']) && $cluster['GalaxyCluster']['distribution'] == 4 && !$this->SharingGroup->checkIfAuthorised($user, $cluster['GalaxyCluster']['sharing_group_id'])) {\n                $errors[] = __('The sync user has to have access to the sharing group in order to be able to edit it');\n                return $errors;\n            }\n        }\n\n        $cluster['GalaxyCluster']['type'] = $galaxy['type'];\n        if (!isset($cluster['GalaxyCluster']['version'])) {\n            $date = new DateTime();\n            $cluster['GalaxyCluster']['version'] = $date->getTimestamp();\n        }\n        $cluster['GalaxyCluster']['tag_name'] = sprintf('misp-galaxy:%s=\"%s\"', $galaxy['type'], $cluster['GalaxyCluster']['uuid']);\n        $this->create();\n        $saveSuccess = $this->save($cluster);\n        if ($saveSuccess) {\n            $savedCluster = $this->find('first', array(\n                'conditions' => array('id' =>  $this->id),\n                'recursive' => -1\n            ));\n\n            if (!empty($cluster['GalaxyCluster']['GalaxyElement'])) {\n                $elementsToSave = array();\n                foreach ($cluster['GalaxyCluster']['GalaxyElement'] as $element) { // transform cluster into Galaxy meta format\n                    $elementsToSave[$element['key']][] = $element['value'];\n                }\n                $this->GalaxyElement->updateElements(-1, $savedCluster['GalaxyCluster']['id'], $elementsToSave);\n            }\n            if (!empty($cluster['GalaxyCluster']['GalaxyClusterRelation'])) {\n                $this->GalaxyClusterRelation->saveRelations($user, $cluster['GalaxyCluster'], $cluster['GalaxyCluster']['GalaxyClusterRelation'], $captureTag=true);\n            }\n        } else {\n            foreach ($this->validationErrors as $validationError) {\n                $errors[] = $validationError[0];\n            }\n        }\n        return $errors;\n    }\n\n    /**\n     * editCluster Respecting ACL edits a cluster, its elements, relations and set correct fields where applicable\n     *\n     * @param  array $user\n     * @param  array $cluster\n     * @param  array $fieldList Only edit the fields provided\n     * @param  bool  $deleteOldElements Should already existing element be deleted or not\n     * @return array The errors if any\n     */\n    public function editCluster(array $user, array $cluster, array $fieldList = array(), $deleteOldElements=true)\n    {\n        $this->SharingGroup = ClassRegistry::init('SharingGroup');\n        $errors = array();\n        if (!$user['Role']['perm_galaxy_editor'] && !$user['Role']['perm_site_admin']) {\n            $errors[] = __('Incorrect permission');\n        }\n        if (isset($cluster['GalaxyCluster']['uuid'])) {\n            $existingCluster = $this->find('first', array('conditions' => array('GalaxyCluster.uuid' => $cluster['GalaxyCluster']['uuid'])));\n        } else {\n            $errors[] = __('UUID not provided');\n        }\n        if (empty($existingCluster)) {\n            $errors[] = __('Unkown UUID');\n        } else {\n            // For users that are of the creating org of the cluster, always allow the edit\n            // For users that are sync users, only allow the edit if the cluster is locked\n            if (\n                $existingCluster['GalaxyCluster']['orgc_id'] === $user['org_id'] ||\n                ($user['Role']['perm_sync'] && $existingCluster['GalaxyCluster']['locked']) || $user['Role']['perm_site_admin']\n            ) {\n                if ($user['Role']['perm_sync']) {\n                    if (\n                        isset($cluster['GalaxyCluster']['distribution']) && $cluster['GalaxyCluster']['distribution'] == 4 && !$this->SharingGroup->checkIfAuthorised($user, $cluster['GalaxyCluster']['sharing_group_id'])\n                    ) {\n                        $errors[] = array(__('Galaxy Cluster could not be saved: The sync user has to have access to the sharing group in order to be able to edit it.'));\n                    }\n                }\n            } else {\n                $errors[] = array(__('Galaxy Cluster could not be saved: The user used to edit the cluster is not authorised to do so. This can be caused by the user not being of the same organisation as the original creator of the cluster whilst also not being a site administrator.'));\n            }\n            $cluster['GalaxyCluster']['id'] = $existingCluster['GalaxyCluster']['id'];\n\n            if (empty($errors)) {\n                $date = new DateTime();\n                $cluster['GalaxyCluster']['version'] = $date->getTimestamp();\n                $cluster['GalaxyCluster']['default'] = false;\n                if (!isset($cluster['GalaxyCluster']['published'])) {\n                    $cluster['GalaxyCluster']['published'] = false;\n                }\n                if (isset($cluster['GalaxyCluster']['distribution']) && $cluster['GalaxyCluster']['distribution'] != 4) {\n                    $cluster['GalaxyCluster']['sharing_group_id'] = null;\n                }\n                if (empty($fieldList)) {\n                    $fieldList = array('value', 'description', 'version', 'source', 'authors', 'distribution', 'sharing_group_id', 'default', 'published');\n                }\n                $saveSuccess = $this->save($cluster, array('fieldList' => $fieldList));\n                if ($saveSuccess) {\n                    if (isset($cluster['GalaxyCluster']['GalaxyElement'])) {\n                        $elementsToSave = array();\n                        foreach ($cluster['GalaxyCluster']['GalaxyElement'] as $element) { // transform cluster into Galaxy meta format\n                            $elementsToSave[$element['key']][] = $element['value'];\n                        }\n                        $this->GalaxyElement->updateElements($cluster['GalaxyCluster']['id'], $cluster['GalaxyCluster']['id'], $elementsToSave, $delete=$deleteOldElements);\n                    }\n                    if (!empty($cluster['GalaxyCluster']['GalaxyClusterRelation'])) {\n                        $this->GalaxyClusterRelation->saveRelations($user, $cluster['GalaxyCluster'], $cluster['GalaxyCluster']['GalaxyClusterRelation'], $captureTag=true, $force=true);\n                    }\n                } else {\n                    foreach ($this->validationErrors as $validationError) {\n                        $errors[] = $validationError[0];\n                    }\n                }\n            }\n        }\n        return $errors;\n    }\n\n    /**\n     * publishRouter\n     *\n     * @param  array $user\n     * @param  mixed $cluster\n     * @param  int|null $passAlong The server id from which the publish is issued\n     * @return mixed The process id or the publish result depending on background jobs\n     */\n    public function publishRouter(array $user, $cluster, $passAlong=null)\n    {\n        if (Configure::read('MISP.background_jobs')) {\n            if (is_numeric($cluster)) {\n                $clusterId = $cluster;\n            } elseif (isset($cluster['GalaxyCluster'])) {\n                $clusterId = $cluster['GalaxyCluster']['id'];\n            } else {\n                return false;\n            }\n\n            /** @var Job $job */\n            $job = ClassRegistry::init('Job');\n            $jobId = $job->createJob(\n                'SYSTEM',\n                Job::WORKER_PRIO,\n                'publish_galaxy_clusters',\n                'Cluster ID: ' . $clusterId,\n                'Publishing.'\n            );\n\n            return $this->getBackgroundJobsTool()->enqueue(\n                BackgroundJobsTool::PRIO_QUEUE,\n                BackgroundJobsTool::CMD_EVENT,\n                [\n                    'publish_galaxy_clusters',\n                    $clusterId,\n                    $jobId,\n                    $user['id'],\n                    $passAlong\n                ],\n                true,\n                $jobId\n            );\n\n        } else {\n            $result = $this->publish($cluster, $passAlong=$passAlong);\n            return $result;\n        }\n    }\n\n    /**\n     * publish\n     *\n     * @param  mixed $cluster\n     * @param  int|null $passAlong The server id from which the publish is issued\n     * @return bool The success of the publish operation\n     */\n    public function publish($cluster, $passAlong=null)\n    {\n        if (is_numeric($cluster)) {\n            $clusterId = $cluster;\n        } elseif (isset($cluster['GalaxyCluster'])) {\n            $clusterId = $cluster['GalaxyCluster']['id'];\n        }\n        $this->id = $clusterId;\n        $saved = $this->saveField('published', True);\n        if ($saved['GalaxyCluster']['published']) {\n            $this->uploadClusterToServersRouter($clusterId);\n            return true;\n        }\n        return false;\n    }\n\n    public function unpublish($cluster)\n    {\n        if (is_numeric($cluster)) {\n            $this->id = $cluster;\n        } elseif (isset($cluster['GalaxyCluster'])) {\n            $this->id = $cluster['GalaxyCluster']['id'];\n        }\n        return $this->saveField('published', False);\n    }\n\n    /**\n     * deleteCluster Delete the cluster. Also creates an entry in the cluster blocklist when hard-deleting\n     *\n     * @param  int  $id\n     * @param  bool $hard\n     * @return bool\n     */\n    public function deleteCluster($id, $hard=false)\n    {\n        if ($hard) {\n            $cluster = $this->find('first', array('conditions' => array('id' => $id), 'recursive' => -1));\n            $this->GalaxyClusterBlocklist = ClassRegistry::init('GalaxyClusterBlocklist');\n            $this->GalaxyClusterBlocklist->create();\n            if (!empty($cluster['GalaxyCluster']['orgc_id'])) {\n                $orgc = $this->Orgc->find('first', array(\n                    'conditions' => array('Orgc.id' => $cluster['GalaxyCluster']['orgc_id']),\n                    'recursive' => -1,\n                    'fields' => array('Orgc.name')\n                ));\n            } else {\n                $orgc = ['Orgc' => ['name' => 'MISP']];\n            }\n            $this->GalaxyClusterBlocklist->save(array('cluster_uuid' => $cluster['GalaxyCluster']['uuid'], 'cluster_info' => $cluster['GalaxyCluster']['value'], 'cluster_orgc' => $orgc['Orgc']['name']));\n            $deleteResult = $this->delete($id, true);\n            return $deleteResult;\n        } else {\n            $version = (new DateTime())->getTimestamp();\n            return $this->save(array(\n                'id' => $id,\n                'published' => false,\n                'version' => $version,\n                'deleted' => true,\n            ), array('fieldList' => array('published', 'deleted', 'version')));\n        }\n    }\n\n    public function restoreCluster($id)\n    {\n        $version = (new DateTime())->getTimestamp();\n        return $this->save(array(\n            'id' => $id,\n            'published' => false,\n            'version' => $version,\n            'deleted' => false,\n        ), array('fieldList' => array('published', 'deleted', 'version')));\n    }\n\n    public function touchTimestamp($id)\n    {\n        $version = (new DateTime())->getTimestamp();\n        return $this->save(array(\n            'id' => $id,\n            'version' => $version,\n        ), array('fieldList' => array('version')));\n    }\n\n    /**\n     * wipe_default Delete all default galaxy clusters and their associations.\n     *  Relying on the cake's recursive deletion for the associations adds an non-negligible overhead.\n     *  Same for cake's before/afterDelete callbacks. We do it by hand to speed up the process\n     *\n     */\n    public function wipe_default()\n    {\n        $clusters = $this->find('all', [\n            'conditions' => ['default' => true],\n            'fields' => ['id', 'uuid']\n        ]);\n        $cluster_ids = Hash::extract($clusters, '{n}.GalaxyCluster.id');\n        $cluster_uuids = Hash::extract($clusters, '{n}.GalaxyCluster.uuid');\n        $relation_ids = $this->GalaxyClusterRelation->find('list', [\n            'conditions' => ['galaxy_cluster_id' => $cluster_ids],\n            'fields' => ['id']\n        ]);\n        $this->deleteAll(['GalaxyCluster.default' => true], false, false);\n        $this->GalaxyElement->deleteAll(['GalaxyElement.galaxy_cluster_id' => $cluster_ids], false, false);\n        $this->GalaxyClusterRelation->deleteAll(['GalaxyClusterRelation.galaxy_cluster_id' => $cluster_ids], false, false);\n        $this->GalaxyClusterRelation->updateAll(\n            ['GalaxyClusterRelation.referenced_galaxy_cluster_id' => 0],\n            ['GalaxyClusterRelation.referenced_galaxy_cluster_uuid' => $cluster_uuids] // For all default clusters being referenced\n        );\n        $this->GalaxyClusterRelation->GalaxyClusterRelationTag->deleteAll(['GalaxyClusterRelationTag.galaxy_cluster_relation_id' => $relation_ids], false, false);\n        $this->Log = ClassRegistry::init('Log');\n        $this->Log->createLogEntry('SYSTEM', 'wipe_default', 'GalaxyCluster', 0, \"Wiping default galaxy clusters\");\n\n    }\n\n    /**\n     * uploadClusterToServersRouter Upload the cluster to all remote servers\n     *\n     * @param  int $clusterId\n     * @param  int|null $passAlong The server id from which the publish is issued\n     * @return bool the upload result\n     */\n    private function uploadClusterToServersRouter($clusterId, $passAlong=null)\n    {\n        $clusterOrgcId = $this->find('first', array(\n            'conditions' => array('GalaxyCluster.id' => $clusterId),\n            'recursive' => -1,\n            'fields' => array('GalaxyCluster.orgc_id')\n        ));\n        $elevatedUser = array(\n            'Role' => array(\n                'perm_site_admin' => 1,\n                'perm_sync' => 1,\n                'perm_audit' => 0,\n            ),\n            'org_id' => $clusterOrgcId['GalaxyCluster']['orgc_id']\n        );\n        $cluster = $this->fetchGalaxyClusters($elevatedUser, array('minimal' => true, 'conditions' => array('id' => $clusterId)), $full=false);\n        if (empty($cluster)) {\n            return true;\n        }\n        $cluster = $cluster[0];\n\n        $this->Server = ClassRegistry::init('Server');\n        $conditions = array('push' => 1, 'push_galaxy_clusters' => 1); // Notice: Cluster will be pushed only for servers having both these conditions\n        if ($passAlong) {\n            $conditions[] = array('Server.id !=' => $passAlong);\n        }\n        $servers = $this->Server->find('all', array(\n            'conditions' => $conditions,\n            'order' => array('Server.priority ASC', 'Server.id ASC')\n        ));\n        // iterate over the servers and upload the event\n        if (empty($servers)) {\n            return true;\n        }\n        $uploaded = false;\n        foreach ($servers as $server) {\n            if ((!isset($server['Server']['internal']) || !$server['Server']['internal']) && $cluster['GalaxyCluster']['distribution'] < 2) {\n                continue;\n            }\n            $fakeSyncUser = array(\n                'id' => 0,\n                'email' => 'fakeSyncUser@user.test',\n                'org_id' => $server['Server']['remote_org_id'],\n                'Organisation' => array(\n                    'id' => $server['Server']['remote_org_id'],\n                    'name' => 'fakeSyncOrg',\n                ),\n                'Role' => array(\n                    'perm_site_admin' => 0,\n                    'perm_sync' => 1\n                )\n            );\n            $cluster = $this->fetchGalaxyClusters($fakeSyncUser, array('conditions' => array('GalaxyCluster.id' => $clusterId)), $full=true);\n            if (empty($cluster)) {\n                continue;\n            }\n            $cluster = $cluster[0];\n            $serverSync = new ServerSyncTool($server, $this->setupSyncRequest($server));\n            $result = $this->uploadClusterToServer($cluster, $server, $serverSync, $fakeSyncUser);\n            if ($result === 'Success') {\n                $uploaded = true;\n            }\n        }\n        return $uploaded;\n    }\n\n    public function unsetFieldsForExport($clusters)\n    {\n        foreach ($clusters as $k => $cluster) {\n            unset($clusters[$k]['GalaxyCluster']['galaxy_id']);\n            $modelsToUnset = array('GalaxyCluster', 'Galaxy', 'Org', 'Orgc');\n            foreach ($modelsToUnset as $modelName) {\n                unset($clusters[$k][$modelName]['id']);\n            }\n            $modelsToUnset = array('GalaxyClusterRelation', 'TargetingClusterRelation');\n            foreach ($modelsToUnset as $modelName) {\n                if (!empty($cluster['GalaxyCluster'][$modelName])) {\n                    foreach ($cluster['GalaxyCluster'][$modelName] as $i => $relation) {\n                        unset($clusters[$k]['GalaxyCluster'][$modelName][$i]['id']);\n                        unset($clusters[$k]['GalaxyCluster'][$modelName][$i]['galaxy_cluster_id']);\n                        unset($clusters[$k]['GalaxyCluster'][$modelName][$i]['referenced_galaxy_cluster_id']);\n                        if (isset($relation['Tag'])) {\n                            foreach ($relation['Tag'] as $j => $tags) {\n                                unset($clusters[$k]['GalaxyCluster'][$modelName][$i]['Tag'][$j]['id']);\n                                unset($clusters[$k]['GalaxyCluster'][$modelName][$i]['Tag'][$j]['org_id']);\n                                unset($clusters[$k]['GalaxyCluster'][$modelName][$i]['Tag'][$j]['user_id']);\n                            }\n                        }\n                    }\n                }\n            }\n            foreach ($cluster['GalaxyCluster']['GalaxyElement'] as $i => $element) {\n                unset($clusters[$k]['GalaxyCluster']['GalaxyElement'][$i]['id']);\n                unset($clusters[$k]['GalaxyCluster']['GalaxyElement'][$i]['galaxy_cluster_id']);\n            }\n        }\n        return $clusters;\n    }\n\n    /**\n     * Gets a cluster then save it.\n     *\n     * @param $user\n     * @param array $cluster Cluster to be saved\n     * @param bool  $fromPull If the current capture is performed from a PULL sync\n     * @param int   $orgId The organisation id that should own the cluster\n     * @param array $server The server for which to capture is ongoing\n     * @return array Result of the capture including successes, fails and errors\n     */\n    public function captureCluster($user, $cluster, $fromPull=false, $orgId=0, $server=false)\n    {\n        $results = array('success' => false, 'imported' => 0, 'ignored' => 0, 'failed' => 0, 'errors' => array());\n\n        if ($fromPull) {\n            $cluster['GalaxyCluster']['org_id'] = $orgId;\n        } else {\n            $cluster['GalaxyCluster']['org_id'] = $user['Organisation']['id'];\n        }\n\n        $this->GalaxyClusterBlocklist = ClassRegistry::init('GalaxyClusterBlocklist');\n        if ($this->GalaxyClusterBlocklist->checkIfBlocked($cluster['GalaxyCluster']['uuid'])) {\n            $results['errors'][] = __('Blocked by blocklist');\n            $results['ignored']++;\n            return $results;\n        }\n\n        if (!isset($cluster['GalaxyCluster']['orgc_id']) && !isset($cluster['Orgc'])) {\n            $cluster['GalaxyCluster']['orgc_id'] = $cluster['GalaxyCluster']['org_id'];\n        } else {\n            if (!isset($cluster['GalaxyCluster']['Orgc'])) {\n                if (isset($cluster['GalaxyCluster']['orgc_id']) && $cluster['GalaxyCluster']['orgc_id'] != $user['org_id'] && !$user['Role']['perm_sync'] && !$user['Role']['perm_site_admin']) {\n                    $cluster['GalaxyCluster']['orgc_id'] = $cluster['GalaxyCluster']['org_id']; // Only sync user can create cluster on behalf of other users\n                }\n            } else {\n                if ($cluster['GalaxyCluster']['Orgc']['uuid'] != $user['Organisation']['uuid'] && !$user['Role']['perm_sync'] && !$user['Role']['perm_site_admin']) {\n                    $cluster['GalaxyCluster']['orgc_id'] = $cluster['GalaxyCluster']['org_id']; // Only sync user can create cluster on behalf of other users\n                }\n            }\n            if (isset($cluster['GalaxyCluster']['orgc_id']) && $cluster['GalaxyCluster']['orgc_id'] != $user['org_id'] && !$user['Role']['perm_sync'] && !$user['Role']['perm_site_admin']) {\n                $cluster['GalaxyCluster']['orgc_id'] = $cluster['GalaxyCluster']['org_id']; // Only sync user can create cluster on behalf of other users\n            }\n        }\n\n        if (!Configure::check('MISP.enableOrgBlocklisting') || Configure::read('MISP.enableOrgBlocklisting') !== false) {\n            $this->OrgBlocklist = ClassRegistry::init('OrgBlocklist');\n            if (!isset($cluster['GalaxyCluster']['Orgc']['uuid'])) {\n                $orgc = $this->Orgc->find('first', array('conditions' => array('Orgc.id' => $cluster['GalaxyCluster']['orgc_id']), 'fields' => array('Orgc.uuid'), 'recursive' => -1));\n            } else {\n                $orgc = array('Orgc' => array('uuid' => $cluster['GalaxyCluster']['Orgc']['uuid']));\n            }\n            if ($cluster['GalaxyCluster']['orgc_id'] != 0 && $this->OrgBlocklist->hasAny(array('OrgBlocklist.org_uuid' => $orgc['Orgc']['uuid']))) {\n                $results['errors'][] = __('Organisation blocklisted (%s)', $orgc['Orgc']['uuid']);\n                $results['ignored']++;\n                return $results;\n            }\n        }\n\n        if ($cluster['GalaxyCluster']['default']) {\n            $results['errors'][] = __('Only non-default clusters can be saved');\n            $results['failed']++;\n            return $results;\n        }\n\n        $cluster = $this->captureOrganisationAndSG($cluster, 'GalaxyCluster', $user);\n        $existingGalaxyCluster = $this->find('first', array('conditions' => array(\n            'GalaxyCluster.uuid' => $cluster['GalaxyCluster']['uuid']\n        )));\n        $cluster['GalaxyCluster']['tag_name'] = sprintf('misp-galaxy:%s=\"%s\"', $cluster['GalaxyCluster']['type'], $cluster['GalaxyCluster']['uuid']);\n        if (!isset($cluster['GalaxyCluster']['distribution'])) {\n            $cluster['GalaxyCluster']['distribution'] = Configure::read('MISP.default_event_distribution'); // use default event distribution\n        }\n        if ($cluster['GalaxyCluster']['distribution'] != 4) {\n            $cluster['GalaxyCluster']['sharing_group_id'] = null;\n        }\n        if (!isset($cluster['GalaxyCluster']['published'])) {\n            $cluster['GalaxyCluster']['published'] = false;\n        }\n        if (empty($existingGalaxyCluster)) {\n            $galaxy = $this->Galaxy->captureGalaxy($user, $cluster['GalaxyCluster']['Galaxy']);\n            $cluster['GalaxyCluster']['galaxy_id'] = $galaxy['Galaxy']['id'];\n            unset($cluster['GalaxyCluster']['id']);\n            $this->create();\n            $saveSuccess = $this->save($cluster);\n        } else {\n            if (!$existingGalaxyCluster['GalaxyCluster']['locked'] && empty($server['Server']['internal'])) {\n                $results['errors'][] = __('Blocked an edit to an cluster that was created locally. This can happen if a synchronised cluster that was created on this instance was modified by an administrator on the remote side.');\n                $results['failed']++;\n                return $results;\n            }\n            if ($cluster['GalaxyCluster']['version'] > $existingGalaxyCluster['GalaxyCluster']['version']) {\n                $cluster['GalaxyCluster']['id'] = $existingGalaxyCluster['GalaxyCluster']['id'];\n                $saveSuccess = $this->save($cluster);\n            } else {\n                $results['errors'][] = __('Remote version is not newer than local one for cluster (%s)', $cluster['GalaxyCluster']['uuid']);\n                $results['ignored']++;\n                return $results;\n            }\n        }\n        if ($saveSuccess) {\n            $results['imported']++;\n            $savedCluster = $this->find('first', array(\n                'conditions' => array('uuid' =>  $cluster['GalaxyCluster']['uuid']),\n                'recursive' => -1\n            ));\n            if (!empty($cluster['GalaxyCluster']['GalaxyElement'])) {\n                $this->GalaxyElement->deleteAll(array('GalaxyElement.galaxy_cluster_id' => $savedCluster['GalaxyCluster']['id']));\n                $this->GalaxyElement->captureElements($user, $cluster['GalaxyCluster']['GalaxyElement'], $savedCluster['GalaxyCluster']['id']);\n            }\n            if (!empty($cluster['GalaxyCluster']['GalaxyClusterRelation'])) {\n                $this->GalaxyClusterRelation->deleteAll(array('GalaxyClusterRelation.galaxy_cluster_id' => $savedCluster['GalaxyCluster']['id']));\n                $saveResult = $this->GalaxyClusterRelation->captureRelations($user, $savedCluster, $cluster['GalaxyCluster']['GalaxyClusterRelation'], $fromPull=$fromPull);\n                if ($saveResult['failed'] > 0) {\n                    $results['errors'][] = __('Issues while capturing relations have been logged.');\n                }\n            }\n            if ($savedCluster['GalaxyCluster']['published']) {\n                $passAlong = isset($server['Server']['id']) ? $server['Server']['id'] : null;\n                $this->publishRouter($user, $savedCluster['GalaxyCluster']['id'], $passAlong);\n            }\n        } else {\n            $results['failed']++;\n            foreach ($this->validationErrors as $validationError) {\n                $results['errors'][] = $validationError[0];\n            }\n        }\n        $results['success'] = $results['imported'] > 0;\n        return $results;\n    }\n\n    public function captureOrganisationAndSG($element, $model, $user)\n    {\n        $this->Event = ClassRegistry::init('Event');\n        if (isset($element[$model]['distribution']) && $element[$model]['distribution'] == 4) {\n            $element[$model] = $this->Event->captureSGForElement($element[$model], $user);\n        }\n        // first we want to see how the creator organisation is encoded\n        // The options here are either by passing an organisation object along or simply passing a string along\n        if (isset($element[$model]['Orgc'])) {\n            $element[$model]['orgc_id'] = $this->Orgc->captureOrg($element[$model]['Orgc'], $user);\n            unset($element[$model]['Orgc']);\n        } else {\n            // Can't capture the Orgc, default to the current user\n            $element[$model]['orgc_id'] = $user['org_id'];\n        }\n        return $element;\n    }\n\n    /**\n     * @param array $user\n     * @param array $clusters\n     * @return void\n     */\n    public function attachExtendByInfo(array $user, array &$clusters)\n    {\n        if (empty($clusters)) {\n            return;\n        }\n\n        $clusterUuids = array_column(array_column($clusters, 'GalaxyCluster'), 'uuid');\n        $extensions = $this->fetchGalaxyClusters($user, [\n            'conditions' => ['extends_uuid' => $clusterUuids],\n        ]);\n        foreach ($clusters as &$cluster) {\n            $extendedBy = [];\n            foreach ($extensions as $extension) {\n                if ($cluster['GalaxyCluster']['uuid'] === $extension['GalaxyCluster']['extends_uuid']) {\n                    $extendedBy[] = $extension;\n                }\n            }\n            $cluster['GalaxyCluster']['extended_by'] = $extendedBy;\n        }\n    }\n\n    public function attachExtendFromInfo($user, $cluster)\n    {\n        if (!empty($cluster['GalaxyCluster']['extends_uuid'])) {\n            $extensions = $this->fetchGalaxyClusters($user, array('conditions' => array('uuid' => $cluster['GalaxyCluster']['extends_uuid'])));\n            if (!empty($extensions)) {\n                $cluster['GalaxyCluster']['extended_from'] = $extensions[0];\n            } else {\n                $cluster['GalaxyCluster']['extended_from'] = array();\n            }\n        }\n        return $cluster;\n    }\n\n    /* Return a list of all tags associated with the cluster specific cluster within the galaxy (or all clusters if $clusterValue is false)\n     * The counts are restricted to the event IDs that the user is allowed to see.\n    */\n    public function getTags($galaxyType, $clusterValue = false, $user)\n    {\n        $this->Event = ClassRegistry::init('Event');\n        $event_ids = $this->Event->fetchEventIds($user, [\n            'list' => true\n        ]);\n        $tags = $this->Event->EventTag->Tag->find('list', array(\n                'conditions' => array('name LIKE' => 'misp-galaxy:' . $galaxyType . '=\"' . ($clusterValue ? $clusterValue : '%') .'\"'),\n                'fields' => array('name', 'id'),\n        ));\n        $this->Event->EventTag->virtualFields['tag_count'] = 'COUNT(id)';\n        $tagCounts = $this->Event->EventTag->find('list', array(\n                'conditions' => array('EventTag.tag_id' => array_values($tags), 'EventTag.event_id' => $event_ids),\n                'fields' => array('EventTag.tag_id', 'EventTag.tag_count'),\n                'group' => array('EventTag.tag_id')\n        ));\n        foreach ($tags as $k => $v) {\n            if (isset($tagCounts[$v])) {\n                $tags[$k] = array('count' => $tagCounts[$v], 'tag_id' => $v);\n            } else {\n                unset($tags[$k]);\n            }\n        }\n        return $tags;\n    }\n\n    /**\n     * @param string|int $name Cluster name or ID\n     * @param array $user\n     * @return array|mixed\n     */\n    public function getCluster($name, $user)\n    {\n        if (isset($this->__clusterCache[$name])) {\n            return $this->__clusterCache[$name];\n        }\n        if (is_numeric($name)) {\n            $conditions = array('GalaxyCluster.id' => $name);\n        } else {\n            $isGalaxyTag = strpos($name, 'misp-galaxy:') === 0;\n            if (!$isGalaxyTag) {\n                return null;\n            }\n            $conditions = array('GalaxyCluster.tag_name' => $name);\n        }\n        $cluster = $this->fetchGalaxyClusters($user, array(\n            'conditions' => $conditions,\n            'first' => true\n        ), true);\n\n        if (!empty($cluster)) {\n            $cluster = $this->postprocess($cluster);\n        }\n        if (!empty($cluster) && $cluster['GalaxyCluster']['default']) { // only cache default clusters\n            $this->__clusterCache[$name] = $cluster;\n        }\n        return $cluster;\n    }\n\n    /**\n     * @param array $tagNames Cluster tag names with tag ID in key\n     * @param array $user\n     * @param bool $postProcess If true, self::postprocess method will be called.\n     * @param bool $fetchFullCluster\n     * @return array\n     */\n    public function getClustersByTags(array $tagNames, array $user, $postProcess = true, $fetchFullCluster = true, $fetchFullRelationship = false)\n    {\n        $options = [\n            'conditions' => ['GalaxyCluster.tag_name' => $tagNames],\n        ];\n        if (!$fetchFullCluster) {\n            $options['contain'] = ['Galaxy', 'GalaxyElement'];\n        }\n\n        $clusters = $this->fetchGalaxyClusters($user, $options, $fetchFullCluster, $fetchFullRelationship);\n\n        if (!empty($clusters) && $postProcess) {\n            $tagIds = array_change_key_case(array_flip($tagNames));\n            foreach ($clusters as $k => $cluster) {\n                $tagName = strtolower($cluster['GalaxyCluster']['tag_name']);\n                $clusters[$k] = $this->postprocess($cluster, $tagIds[$tagName] ?? null);\n            }\n        }\n\n        return $clusters;\n    }\n\n    public function buildConditions($user)\n    {\n        $conditions = array();\n        if (!$user['Role']['perm_site_admin']) {\n            $sgids = $this->SharingGroup->authorizedIds($user);\n            $alias = $this->alias;\n            $conditions['AND']['OR'] = array(\n                \"${alias}.org_id\" => $user['org_id'],\n                array(\n                    'AND' => array(\n                        \"${alias}.distribution >\" => 0,\n                        \"${alias}.distribution <\" => 4\n                    ),\n                ),\n                array(\n                    'AND' => array(\n                        \"${alias}.sharing_group_id\" => $sgids,\n                        \"${alias}.distribution\" => 4\n                    )\n                )\n            );\n        }\n        return $conditions;\n    }\n\n    /**\n     * fetchGalaxyClusters Very flexible, it's basically a replacement for find, with the addition that it restricts access based on user\n     *\n     * @param  mixed $user\n     * @param  mixed $options\n     * @param  bool  $full\n     * @return array\n     */\n    public function fetchGalaxyClusters(array $user, array $options, $full=false, $includeFullClusterRelationship=false)\n    {\n        $params = array(\n            'conditions' => $this->buildConditions($user),\n            'recursive' => -1\n        );\n        if ($full) {\n            $params['contain'] = array(\n                'Galaxy',\n                'GalaxyElement',\n                'GalaxyClusterRelation' => array(\n                    'conditions' => $this->GalaxyClusterRelation->buildConditions($user, false),\n                    'GalaxyClusterRelationTag',\n                    'SharingGroup',\n                ),\n                'Orgc',\n                'Org',\n                'SharingGroup'\n            );\n        }\n        if (!empty($includeFullClusterRelationship)) {\n            $params['contain']['GalaxyClusterRelation'][] = 'TargetCluster';\n        }\n        if (!empty($options['contain'])) {\n            $params['contain'] = $options['contain'];\n        }\n        if (isset($options['fields'])) {\n            $params['fields'] = $options['fields'];\n        }\n        if (isset($options['conditions'])) {\n            $params['conditions']['AND'][] = $options['conditions'];\n        }\n        if (isset($options['group'])) {\n            $params['group'] = $options['group'];\n        }\n        if (isset($options['order'])) {\n            $params['order'] = $options['order'];\n        }\n        if (isset($options['page'])) {\n            $params['page'] = $options['page'];\n        }\n        if (isset($options['limit'])) {\n            $params['limit'] = $options['limit'];\n        }\n        if (isset($options['list']) && $options['list']) {\n            return $this->find('list', $params);\n        }\n\n        if (isset($options['first']) && $options['first']) {\n            $clusters = $this->find('first', $params);\n        } else if (isset($options['count']) && $options['count']) {\n            return $this->find('count', $params);\n        } else {\n            $clusters = $this->find('all', $params);\n        }\n\n        if (empty($clusters)) {\n            return $clusters;\n        }\n\n        if (isset($options['first']) && $options['first']) {\n            $clusters = [$clusters];\n        }\n\n        if ($full) {\n            $clusterIds = array_column(array_column($clusters, 'GalaxyCluster'), 'id');\n            $targetingClusterRelations = $this->TargetingClusterRelation->fetchRelations($user, array(\n                'contain' => array(\n                    'GalaxyClusterRelationTag',\n                    'SharingGroup',\n                ),\n                'conditions' => array(\n                    'TargetingClusterRelation.referenced_galaxy_cluster_id' => $clusterIds,\n                )\n            ));\n\n            $tagsToFetch = Hash::extract($clusters, \"{n}.GalaxyClusterRelation.{n}.GalaxyClusterRelationTag.{n}.tag_id\");\n            $tagsToFetch = array_merge($tagsToFetch, Hash::extract($targetingClusterRelations, \"GalaxyClusterRelationTag.{n}.tag_id\"));\n\n            if (!empty($tagsToFetch)) {\n                $tags = $this->GalaxyClusterRelation->GalaxyClusterRelationTag->Tag->find('all', [\n                    'conditions' => ['id' => array_unique($tagsToFetch, SORT_REGULAR)],\n                    'recursive' => -1,\n                ]);\n                $tags = array_column(array_column($tags, 'Tag'), null, 'id');\n            } else {\n                $tags = [];\n            }\n\n            foreach ($targetingClusterRelations as $k => $targetingClusterRelation) {\n                if (!empty($targetingClusterRelation['GalaxyClusterRelationTag'])) {\n                    foreach ($targetingClusterRelation['GalaxyClusterRelationTag'] as $relationTag) {\n                        if (isset($tags[$relationTag['tag_id']])) {\n                            $targetingClusterRelation['TargetingClusterRelation']['Tag'][] = $tags[$relationTag['tag_id']];\n                        }\n                    }\n                }\n                unset($targetingClusterRelation['GalaxyClusterRelationTag']);\n                if (!empty($targetingClusterRelation['SharingGroup']['id'])) {\n                    $targetingClusterRelation['TargetingClusterRelation']['SharingGroup'] = $targetingClusterRelation['SharingGroup'];\n                }\n                if ($includeFullClusterRelationship) {\n                    $targetingClusterRelation['TargetingClusterRelation']['GalaxyCluster'] = $targetingClusterRelation['SourceCluster'];\n                }\n                $targetingClusterRelations[$k] = $targetingClusterRelation['TargetingClusterRelation'];\n            }\n        }\n\n        $this->Event = ClassRegistry::init('Event');\n        $sharingGroupData = $this->Event->__cacheSharingGroupData($user, true);\n        foreach ($clusters as $i => $cluster) {\n            if (!empty($cluster['GalaxyCluster']['sharing_group_id']) && isset($sharingGroupData[$cluster['GalaxyCluster']['sharing_group_id']])) {\n                $clusters[$i]['SharingGroup'] = $sharingGroupData[$cluster['GalaxyCluster']['sharing_group_id']];\n            }\n            if (isset($cluster['GalaxyClusterRelation'])) {\n                foreach ($cluster['GalaxyClusterRelation'] as $j => $relation) {\n                    if (!empty($relation['sharing_group_id']) && isset($sharingGroupData[$relation['sharing_group_id']])) {\n                        $clusters[$i]['GalaxyClusterRelation'][$j]['SharingGroup'] = $sharingGroupData[$relation['sharing_group_id']];\n                    }\n                    foreach ($relation['GalaxyClusterRelationTag'] as $relationTag) {\n                        if (isset($tags[$relationTag['tag_id']])) {\n                            $clusters[$i]['GalaxyClusterRelation'][$j]['Tag'][] = $tags[$relationTag['tag_id']];\n                        }\n                    }\n                    unset($clusters[$i]['GalaxyClusterRelation'][$j]['GalaxyClusterRelationTag']);\n                }\n            }\n            if ($full) {\n                foreach ($targetingClusterRelations as $targetingClusterRelation) {\n                    if ($targetingClusterRelation['referenced_galaxy_cluster_id'] == $cluster['GalaxyCluster']['id']) {\n                        $clusters[$i]['TargetingClusterRelation'][] = $targetingClusterRelation;\n                    }\n                }\n            }\n            $clusters[$i] = $this->arrangeData($clusters[$i]);\n        }\n\n        if (isset($options['first']) && $options['first']) {\n            return $clusters[0];\n        }\n\n        return $clusters;\n    }\n\n    public function restSearch(array $user, $returnFormat, $filters, $paramsOnly=false, $jobId = false, &$elementCounter = 0)\n    {\n        if (!isset($this->validFormats[$returnFormat][1])) {\n            throw new NotFoundException('Invalid output format.');\n        }\n        App::uses($this->validFormats[$returnFormat][1], 'Export');\n        $exportTool = new $this->validFormats[$returnFormat][1]();\n        $conditions = $this->buildFilterConditions($user, $filters);\n        $params = array(\n            'conditions' => $conditions,\n            'full' => !empty($filters['full']) ? $filters['full'] : (!empty($filters['minimal']) ? !$filters['minimal'] : true),\n            'minimal' => !empty($filters['minimal']) ? $filters['minimal'] : (!empty($filters['full']) ? !$filters['full'] : false),\n        );\n\n        if (isset($filters['limit'])) {\n            $params['limit'] = $filters['limit'];\n            if (!isset($filters['page'])) {\n                $filters['page'] = 1;\n            }\n        }\n        if (isset($filters['page'])) {\n            $params['page'] = $filters['page'];\n        }\n\n        $default_cluster_memory_coefficient = 80;\n        if ($params['full']) {\n            $default_cluster_memory_coefficient = 0.5; // Complete cluster can be massive\n        }\n        if ($params['minimal']) {\n            $default_cluster_memory_coefficient = 100;\n            $params['fields'] = array('uuid', 'version');\n        }\n\n        if ($paramsOnly) {\n            return $params;\n        }\n        if (method_exists($exportTool, 'modify_params')) {\n            $params = $exportTool->modify_params($user, $params);\n        }\n        $exportToolParams = array(\n            'user' => $user,\n            'params' => $params,\n            'returnFormat' => $returnFormat,\n            'scope' => 'GalaxyCluster',\n            'filters' => $filters\n        );\n        if (!empty($exportTool->additional_params)) {\n            $params = array_merge_recursive(\n                $params,\n                $exportTool->additional_params\n            );\n        }\n\n        $tmpfile = new TmpFileTool();\n        $tmpfile->write($exportTool->header($exportToolParams));\n        $loop = false;\n        if (empty($params['limit'])) {\n            $memory_in_mb = $this->convert_to_memory_limit_to_mb(ini_get('memory_limit'));\n            $memory_scaling_factor = $default_cluster_memory_coefficient / 10;\n            $params['limit'] = intval($memory_in_mb * $memory_scaling_factor);\n            $loop = true;\n            $params['page'] = 1;\n        }\n        $this->__iteratedFetch($user, $params, $loop, $tmpfile, $exportTool, $exportToolParams, $elementCounter);\n        $tmpfile->write($exportTool->footer($exportToolParams));\n        return $tmpfile;\n    }\n\n    private function __iteratedFetch($user, $params, $loop, TmpFileTool $tmpfile, $exportTool, $exportToolParams, &$elementCounter = 0)\n    {\n        $elementCounter = 0;\n        $separator = $exportTool->separator($exportToolParams);\n        do {\n            $results = $this->fetchGalaxyClusters($user, $params, $full=$params['full']);\n            if (empty($results)) {\n                break; // nothing found, skip rest\n            }\n            $resultCount = count($results);\n            $elementCounter += $resultCount;\n            foreach ($results as $cluster) {\n                $handlerResult = $exportTool->handler($cluster, $exportToolParams);\n                if ($handlerResult !== '') {\n                    $tmpfile->writeWithSeparator($handlerResult, $separator);\n                }\n            }\n            if ($resultCount < $params['limit']) {\n                break;\n            }\n            $params['page'] += 1;\n        } while ($loop);\n        return true;\n    }\n\n    public function buildFilterConditions($user, $filters)\n    {\n        $conditions = $this->buildConditions($user);\n        if (isset($filters['org_id'])) {\n            $this->Organisation = ClassRegistry::init('Organisation');\n            if (!is_array($filters['org_id'])) {\n                $filters['org_id'] = array($filters['org_id']);\n            }\n            foreach ($filters['org_id'] as $k => $org_id) {\n                if (Validation::uuid($org_id)) {\n                    $org = $this->Organisation->find('first', array('conditions' => array('Organisation.uuid' => $org_id), 'recursive' => -1, 'fields' => array('Organisation.id')));\n                    if (empty($org)) {\n                        $filters['org_id'][$k] = -1;\n                    } else {\n                        $filters['org_id'][$k] = $org['Organisation']['id'];\n                    }\n                }\n            }\n            $conditions['AND']['GalaxyCluster.org_id'] = $filters['org_id'];\n        }\n        if (isset($filters['orgc_id'])) {\n            $this->Organisation = ClassRegistry::init('Organisation');\n            if (!is_array($filters['orgc_id'])) {\n                $filters['orgc_id'] = array($filters['orgc_id']);\n            }\n            foreach ($filters['orgc_id'] as $k => $orgc_id) {\n                if (Validation::uuid($orgc_id)) {\n                    $org = $this->Organisation->find('first', array('conditions' => array('Organisation.uuid' => $orgc_id), 'recursive' => -1, 'fields' => array('Organisation.id')));\n                    if (empty($org)) {\n                        $filters['orgc_id'][$k] = -1;\n                    } else {\n                        $filters['orgc_id'][$k] = $org['Organisation']['id'];\n                    }\n                }\n            }\n            $conditions['AND']['GalaxyCluster.orgc_id'] = $filters['orgc_id'];\n        }\n\n        if (isset($filters['galaxy_uuid'])) {\n            $galaxyIds = $this->Galaxy->find('list', array(\n                'recursive' => -1,\n                'conditions' => array('Galaxy.uuid' => $filters['galaxy_uuid']),\n                'fields' => array('id')\n            ));\n            if (!empty($galaxyIds)) {\n                $filters['galaxy_id'] = array_values($galaxyIds);\n            } else {\n                $filters['galaxy_id'] = -1;\n            }\n        }\n\n        if (isset($filters['eventid'])) {\n            $clusterUUIDs = $this->getClusterUUIDsFromAttachedTags($user, $filters['eventid']);\n            if (!empty($clusterUUIDs)) {\n                $filters['uuid'] = array_values($clusterUUIDs);\n            } else {\n                $filters['uuid'] = -1;\n            }\n        }\n\n        if (isset($filters['elements'])) {\n            $matchingIDs = $this->GalaxyElement->getClusterIDsFromMatchingElements($user, $filters['elements']);\n            $filters['id'] = $matchingIDs;\n        }\n\n        $simpleParams = array(\n            'uuid', 'galaxy_id', 'version', 'distribution', 'type', 'value', 'default', 'extends_uuid', 'tag_name', 'published', 'id',\n        );\n        foreach ($simpleParams as $k => $simpleParam) {\n            if (isset($filters[$simpleParam])) {\n                $conditions['AND'][\"GalaxyCluster.${simpleParam}\"] = $filters[$simpleParam];\n            }\n        }\n\n        if (isset($filters['custom'])) {\n            $conditions['AND']['GalaxyCluster.default'] = !$filters['custom'];\n        }\n        return $conditions;\n    }\n\n    /**\n     * getClusterUUIDsFromAttachedTags Extract UUIDs from clusters contained in the provided event\n     *\n     * @param  array $user\n     * @param  int $eventId\n     * @return array list of cluster UUIDs\n     */\n    private function getClusterUUIDsFromAttachedTags(array $user, $eventId)\n    {\n        $models = array('Attribute', 'Event');\n        $clusterUUIDs = array();\n        foreach ($models as $model) {\n            $modelLower = strtolower($model);\n            $joinCondition2 = array('table' => \"${modelLower}_tags\",\n                'alias' => \"${model}Tag\",\n                'type' => 'inner',\n                'conditions' => array(\n                    \"Tag.id = ${model}Tag.tag_id\",\n                    \"${model}Tag.event_id\" => $eventId,\n                )\n            );\n            if ($model == 'Attribute') {\n                // We have to make sure users have access to the event/attributes\n                // Otherwise, they might enumerate and fetch tags from event/attributes they can't see\n                $this->Attribute = ClassRegistry::init('Attribute');\n                $attributes = $this->Attribute->fetchAttributes($user, array(\n                    'conditions' => array('Attribute.event_id' => $eventId),\n                    'fields' => array('Attribute.id'),\n                    'flatten' => 1\n                ));\n                if (!empty($attributes)) {\n                    $attributeIds = Hash::extract($attributes, '{n}.Attribute.id');\n                } else { // no attributes accessible\n                    $attributeIds = -1;\n                }\n                $joinCondition2['conditions'][\"${model}Tag.attribute_id\"] = $attributeIds;\n            }\n            $options = array(\n                'joins' => array(\n                    array('table' => 'tags',\n                        'alias' => 'Tag',\n                        'type' => 'inner',\n                        'conditions' => array(\n                            'GalaxyCluster.tag_name = Tag.name'\n                        )\n                    ),\n                    $joinCondition2\n                ),\n                'fields' => array('GalaxyCluster.uuid'),\n                'recursive' => -1,\n            );\n            $tmp = $this->find('list', $options);\n            $clusterUUIDs = array_merge($clusterUUIDs, array_values($tmp));\n        }\n        $clusterUUIDs = array_unique($clusterUUIDs);\n        return $clusterUUIDs;\n    }\n\n    /**\n     * Simple ACL-aware method to fetch a cluster by Id or UUID\n     *\n     * @param array $user\n     * @param int|string $clusterId Cluster ID or UUID\n     * @param bool $throwErrors\n     * @param bool $full\n     * @return array\n     */\n    public function fetchClusterById(array $user, $clusterId, $throwErrors=true, $full=false)\n    {\n        $alias = $this->alias;\n        if (Validation::uuid($clusterId)) {\n            $conditions = array(\"${alias}.uuid\" => $clusterId);\n        } elseif (is_numeric($clusterId)) {\n            $conditions = array(\"${alias}.id\" => $clusterId);\n        } else{\n            if ($throwErrors) {\n                throw new NotFoundException(__('Invalid galaxy cluster'));\n            }\n            return array();\n        }\n\n        return $this->fetchGalaxyClusters($user, ['conditions' => $conditions], $full=$full);\n    }\n\n\n    /**\n     * Fetches a cluster and checks if the user has the authorization to perform the requested operation\n     *\n     * @param  array $user\n     * @param  int|string|array $cluster\n     * @param  mixed $authorizations the requested actions to be performed on the cluster\n     * @param  bool  $throwErrors Should the function throws exception if users is not allowed to perform the action\n     * @param  bool  $full\n     * @return array The cluster or an error message\n     */\n    public function fetchIfAuthorized(array $user, $cluster, $authorizations, $throwErrors=true, $full=false)\n    {\n        $authorizations = is_array($authorizations) ? $authorizations : array($authorizations);\n        $possibleAuthorizations = array('view', 'edit', 'delete', 'publish');\n        if (!empty(array_diff($authorizations, $possibleAuthorizations))) {\n            throw new NotFoundException(__('Invalid authorization requested'));\n        }\n        if (isset($cluster['uuid'])) {\n            $cluster[$this->alias] = $cluster;\n        }\n        if (!isset($cluster[$this->alias]['uuid'])) {\n            $cluster = $this->fetchClusterById($user, $cluster, $throwErrors=$throwErrors, $full=$full);\n            if (empty($cluster)) {\n                $message = __('Invalid galaxy cluster');\n                if ($throwErrors) {\n                    throw new NotFoundException($message);\n                }\n                return array('authorized' => false, 'error' => $message);\n            }\n            $cluster = $cluster[0];\n        }\n        if ($user['Role']['perm_site_admin']) {\n            return $cluster;\n        }\n\n        if (in_array('view', $authorizations) && count($authorizations) === 1) {\n            return $cluster;\n        } else {\n            if (!$user['Role']['perm_galaxy_editor']) {\n                $message = __('You don\\'t have the permission to do that.');\n                if ($throwErrors) {\n                    throw new MethodNotAllowedException($message);\n                }\n                return array('authorized' => false, 'error' => $message);\n            }\n            if (in_array('edit', $authorizations) || in_array('delete', $authorizations)) {\n                if ($cluster[$this->alias]['orgc_id'] != $user['org_id']) {\n                    $message = __('Only the creator organisation can modify the galaxy cluster');\n                    if ($throwErrors) {\n                        throw new MethodNotAllowedException($message);\n                    }\n                    return array('authorized' => false, 'error' => $message);\n                }\n            }\n            if (in_array('publish', $authorizations)) {\n                if ($cluster[$this->alias]['orgc_id'] != $user['org_id'] && $user['Role']['perm_publish']) {\n                    $message = __('Only the creator organisation with publishing capabilities can publish the galaxy cluster');\n                    if ($throwErrors) {\n                        throw new MethodNotAllowedException($message);\n                    }\n                    return array('authorized' => false, 'error' => $message);\n                }\n            }\n            return $cluster;\n        }\n    }\n\n    /**\n     * @param array $user\n     * @param array $events\n     * @param bool $replace Remove galaxy cluster tags\n     * @return array\n     */\n    public function attachClustersToEventIndex(array $user, array $events, $replace = false)\n    {\n        $clusterTagNames = [];\n        foreach ($events as $event) {\n            foreach ($event['EventTag'] as $eventTag) {\n                if ($eventTag['Tag']['is_galaxy']) {\n                    $clusterTagNames[$eventTag['Tag']['id']] = $eventTag['Tag']['name'];\n                }\n            }\n        }\n\n        if (empty($clusterTagNames)) {\n            return $events;\n        }\n\n        $options = [\n            'conditions' => ['GalaxyCluster.tag_name' => $clusterTagNames],\n            'contain' => ['Galaxy', 'GalaxyElement'],\n        ];\n        $clusters = $this->fetchGalaxyClusters($user, $options);\n\n        $clustersByTagName = [];\n        foreach ($clusters as $cluster) {\n            $clustersByTagName[strtolower($cluster['GalaxyCluster']['tag_name'])] = $cluster;\n        }\n\n        foreach ($events as $k => $event) {\n            foreach ($event['EventTag'] as $k2 => $eventTag) {\n                if (!$eventTag['Tag']['is_galaxy']) {\n                    continue;\n                }\n                $tagName = strtolower($eventTag['Tag']['name']);\n                if (isset($clustersByTagName[$tagName])) {\n                    $cluster = $this->postprocess($clustersByTagName[$tagName], $eventTag['Tag']['id']);\n                    $cluster['GalaxyCluster']['local'] = $eventTag['local'];\n                    $cluster['GalaxyCluster']['relationship_type'] = $eventTag['relationship_type'];\n                    $events[$k]['GalaxyCluster'][] = $cluster['GalaxyCluster'];\n                    if ($replace) {\n                        unset($events[$k]['EventTag'][$k2]);\n                    }\n                }\n            }\n        }\n        return $events;\n    }\n\n    /**\n     * @param array $cluster\n     * @param int|null $tagId\n     * @return array\n     */\n    private function postprocess(array $cluster, $tagId = null)\n    {\n        $cluster = $this->arrangeData($cluster);\n\n        if (isset($cluster['GalaxyCluster']['GalaxyElement'])) {\n            $elements = array();\n            foreach ($cluster['GalaxyCluster']['GalaxyElement'] as $element) {\n                if (!isset($elements[$element['key']])) {\n                    $elements[$element['key']] = array($element['value']);\n                } else {\n                    $elements[$element['key']][] = $element['value'];\n                }\n            }\n            unset($cluster['GalaxyCluster']['GalaxyElement']);\n            $cluster['GalaxyCluster']['meta'] = $elements;\n        }\n\n        if ($tagId) {\n            $cluster['GalaxyCluster']['tag_id'] = $tagId;\n        } else {\n            $this->Tag = ClassRegistry::init('Tag');\n            $tag_id = $this->Tag->find(\n                'first',\n                array(\n                    'conditions' => array(\n                        'LOWER(Tag.name)' => strtolower($cluster['GalaxyCluster']['tag_name'])\n                    ),\n                    'recursive' => -1,\n                    'fields' => array('Tag.id')\n                )\n            );\n            if (!empty($tag_id)) {\n                $cluster['GalaxyCluster']['tag_id'] = $tag_id['Tag']['id'];\n            }\n        }\n\n        return $cluster;\n    }\n\n    public function getClusterTagsFromMeta($galaxyElements, $user)\n    {\n        // AND operator between cluster metas\n        $tmpResults = array();\n        foreach ($galaxyElements as $galaxyElementKey => $galaxyElementValue) {\n            $tmpResults[] = array_values($this->GalaxyElement->find('list', array(\n                'conditions' => array(\n                    'LOWER(GalaxyElement.key)' => strtolower($galaxyElementKey),\n                    'LOWER(GalaxyElement.value)' => strtolower($galaxyElementValue),\n                ),\n                'fields' => array('galaxy_cluster_id'),\n                'recursive' => -1\n            )));\n        }\n        $clusterTags = array();\n        if (!empty($tmpResults)) {\n            // Get all Clusters matching all conditions\n            $matchingClusters = $tmpResults[0];\n            array_shift($tmpResults);\n            foreach ($tmpResults as $tmpResult) {\n                $matchingClusters = array_intersect($matchingClusters, $tmpResult);\n            }\n            $clusterTags = $this->fetchGalaxyClusters($user, array(\n                'conditions' => array('id' => $matchingClusters),\n                'fields' => array('GalaxyCluster.tag_name'),\n                'list' => true,\n            ), $full=false);\n        }\n        return array_values($clusterTags);\n    }\n\n    public function getElligibleClustersToPush($user, $conditions=array(), $full=false)\n    {\n        $options = array(\n            'conditions' => array(\n                'GalaxyCluster.default' => 0,\n                'GalaxyCluster.published' => 1,\n            ),\n        );\n        $options['conditions'] = array_merge($options['conditions'], $conditions);\n        if (!$full) {\n            $options['fields'] = array('uuid', 'version');\n            $options['list'] = true;\n        }\n        $clusters = $this->fetchGalaxyClusters($user, $options, $full=$full);\n        return $clusters;\n    }\n\n    public function getElligibleLocalClustersToUpdate($user)\n    {\n        $options = array(\n            'conditions' => array(\n                'GalaxyCluster.default' => 0,\n                'GalaxyCluster.locked' => 1,\n            ),\n            'fields' => array('uuid', 'version'),\n            'list' => true,\n        );\n        $clusters = $this->fetchGalaxyClusters($user, $options, $full=false);\n        return $clusters;\n    }\n\n    /**\n     * @return string|bool The result of the upload. True if success, a string otherwise\n     * @throws Exception\n     */\n    public function uploadClusterToServer(array $cluster, array $server, ServerSyncTool $serverSync, array $user)\n    {\n        $cluster = $this->__prepareForPushToServer($cluster, $server);\n        if (is_numeric($cluster)) {\n            return $cluster;\n        }\n\n        try {\n            if (!$serverSync->isSupported(ServerSyncTool::PERM_SYNC) || !$serverSync->isSupported(ServerSyncTool::PERM_GALAXY_EDITOR)) {\n                return __('The remote user does not have the permission to manipulate galaxies - the upload of the galaxy clusters has been blocked.');\n            }\n            $serverSync->pushGalaxyCluster($cluster)->json();\n        } catch (Exception $e) {\n            $title = __('Uploading GalaxyCluster (%s) to Server (%s)', $cluster['GalaxyCluster']['id'], $server['Server']['id']);\n            $this->loadLog()->createLogEntry($user, 'push', 'GalaxyCluster', $cluster['GalaxyCluster']['id'], $title, $e->getMessage());\n\n            $this->logException(\"Could not push galaxy cluster to remote server {$serverSync->serverId()}\", $e);\n            return $e->getMessage();\n        }\n\n        return 'Success';\n    }\n\n    /**\n     * __prepareForPushToServer Check distribution and alter the cluster for sync\n     *\n     * @param  array $cluster\n     * @param  array $server\n     * @return array|int The cluster ready to be pushed\n     */\n    private function __prepareForPushToServer(array $cluster, array $server)\n    {\n        if ($cluster['GalaxyCluster']['distribution'] == 4) {\n            if (!empty($cluster['GalaxyCluster']['SharingGroup']['SharingGroupServer'])) {\n                $found = false;\n                foreach ($cluster['GalaxyCluster']['SharingGroup']['SharingGroupServer'] as $sgs) {\n                    if ($sgs['server_id'] == $server['Server']['id']) {\n                        $found = true;\n                    }\n                }\n                if (!$found) {\n                    return 403;\n                }\n            } elseif (empty($cluster['GalaxyCluster']['SharingGroup']['roaming'])) {\n                return 403;\n            }\n        }\n        $this->Event = ClassRegistry::init('Event');\n        if ($this->Event->checkDistributionForPush($cluster, $server, 'GalaxyCluster')) {\n            return $this->__updateClusterForSync($cluster, $server);\n        }\n        return 403;\n    }\n\n    /**\n     * __updateClusterForSync Cleanup the cluster and adapt data for sync\n     *\n     * @param  array $cluster\n     * @param  array $server\n     * @return array The cluster ready do be sync\n     */\n    private function __updateClusterForSync(array $cluster, array $server)\n    {\n        $this->Event = ClassRegistry::init('Event');\n        // cleanup the array from things we do not want to expose\n        foreach (array('org_id', 'orgc_id', 'id', 'galaxy_id') as $field) {\n            unset($cluster['GalaxyCluster'][$field]);\n        }\n        // Add the local server to the list of instances in the SG\n        if (isset($cluster['GalaxyCluster']['SharingGroup']) && isset($cluster['GalaxyCluster']['SharingGroup']['SharingGroupServer'])) {\n            foreach ($cluster['GalaxyCluster']['SharingGroup']['SharingGroupServer'] as &$s) {\n                if ($s['server_id'] == 0) {\n                    $s['Server'] = array(\n                        'id' => 0,\n                        'url' => $this->Event->__getAnnounceBaseurl(),\n                        'name' => $this->Event->__getAnnounceBaseurl()\n                    );\n                }\n            }\n        }\n        $cluster = $this->__prepareElementsForSync($cluster, $server);\n        $cluster = $this->__prepareRelationsForSync($cluster, $server);\n\n        // Downgrade the event from connected communities to community only\n        if (!$server['Server']['internal'] && $cluster['GalaxyCluster']['distribution'] == 2) {\n            $cluster['GalaxyCluster']['distribution'] = 1;\n        }\n        return $cluster;\n    }\n\n    private function __prepareElementsForSync($cluster, $server)\n    {\n        if (!empty($cluster['GalaxyCluster']['GalaxyElement'])) {\n            foreach ($cluster['GalaxyCluster']['GalaxyElement'] as $k => $element) {\n                $cluster['GalaxyCluster']['GalaxyElement'][$k] = $this->__updateElementForSync($element, $server);\n            }\n        }\n        return $cluster;\n    }\n\n    private function __prepareRelationsForSync($cluster, $server)\n    {\n        $this->Event = ClassRegistry::init('Event');\n        if (!empty($cluster['GalaxyCluster']['GalaxyClusterRelation'])) {\n            foreach ($cluster['GalaxyCluster']['GalaxyClusterRelation'] as $k => $relation) {\n                $cluster['GalaxyCluster']['GalaxyClusterRelation'][$k] = $this->__updateRelationsForSync($relation, $server);\n                if (empty($cluster['GalaxyCluster']['GalaxyClusterRelation'][$k])) {\n                    unset($cluster['GalaxyCluster']['GalaxyClusterRelation'][$k]);\n                } else {\n                    $cluster['GalaxyCluster']['GalaxyClusterRelation'][$k] = $this->Event->__removeNonExportableTags($cluster['GalaxyCluster']['GalaxyClusterRelation'][$k], 'GalaxyClusterRelation');\n                }\n            }\n            $cluster['GalaxyCluster']['GalaxyClusterRelation'] = array_values($cluster['GalaxyCluster']['GalaxyClusterRelation']);\n        }\n        return $cluster;\n    }\n\n    private function __updateElementForSync($element, $server)\n    {\n        unset($element['id']);\n        unset($element['galaxy_cluster_id']);\n        return $element;\n    }\n\n    private function __updateRelationsForSync($relation, $server)\n    {\n        // do not keep attributes that are private, nor cluster\n        if (!$server['Server']['internal'] && $relation['distribution'] < 2) {\n            return false;\n        }\n        // Downgrade the attribute from connected communities to community only\n        if (!$server['Server']['internal'] && $relation['distribution'] == 2) {\n            $relation['distribution'] = 1;\n        }\n\n        $this->Event = ClassRegistry::init('Event');\n        // If the attribute has a sharing group attached, make sure it can be transferred\n        if ($relation['distribution'] == 4) {\n            if (!$server['Server']['internal'] && $this->Event->checkDistributionForPush(array('GalaxyClusterRelation' => $relation), $server, 'GalaxyClusterRelation') === false) {\n                return false;\n            }\n            // Add the local server to the list of instances in the SG\n            if (!empty($relation['SharingGroup']['SharingGroupServer'])) {\n                foreach ($relation['SharingGroup']['SharingGroupServer'] as &$s) {\n                    if ($s['server_id'] == 0) {\n                        $s['Server'] = array(\n                            'id' => 0,\n                            'url' => $this->Event->__getAnnounceBaseurl(),\n                            'name' => $this->Event->__getAnnounceBaseurl()\n                        );\n                    }\n                }\n            }\n        }\n        unset($relation['id']);\n        unset($relation['galaxy_cluster_id']);\n        unset($relation['referenced_galaxy_cluster_id']);\n        return $relation;\n    }\n\n    /**\n     * pullGalaxyClusters\n     *\n     * @param array $user\n     * @param ServerSyncTool $serverSync\n     * @param string|int $technique The technique startegy used for pulling\n     *      allowed:\n     *          - int <event id>                    event containing the clusters to pulled\n     *          - string <full>                     pull everything\n     *          - string <update>                   pull updates of cluster present locally\n     *          - string <pull_relevant_clusters>   pull clusters based on tags present locally\n     * @return int The number of pulled clusters\n     * @throws HttpSocketHttpException\n     * @throws HttpSocketJsonException\n     */\n    public function pullGalaxyClusters(array $user, ServerSyncTool $serverSync, $technique = 'full')\n    {\n        $compatible = $serverSync->isSupported(ServerSyncTool::FEATURE_EDIT_OF_GALAXY_CLUSTER);\n        if (!$compatible) {\n            return 0;\n        }\n        $clusterIds = $this->getClusterIdListBasedOnPullTechnique($user, $technique, $serverSync);\n        $successes = 0;\n        // now process the $clusterIds to pull each of the events sequentially\n        if (!empty($clusterIds)) {\n            // download each cluster\n            foreach ($clusterIds as $clusterId) {\n                if ($this->__pullGalaxyCluster($clusterId, $serverSync, $user)) {\n                    $successes++;\n                }\n            }\n        }\n        return $successes;\n    }\n\n    /**\n     * getClusterIdListBasedOnPullTechnique Collect the list of remote cluster IDs to be pulled based on the technique\n     *\n     * @param  array $user\n     * @param  string|int $technique\n     * @param  ServerSyncTool $serverSync\n     * @return array cluster ID list to be pulled\n     */\n    private function getClusterIdListBasedOnPullTechnique(array $user, $technique, ServerSyncTool $serverSync)\n    {\n        $this->Server = ClassRegistry::init('Server');\n        try {\n            if (\"update\" === $technique) {\n                $localClustersToUpdate = $this->getElligibleLocalClustersToUpdate($user);\n                $clusterIds = $this->Server->getElligibleClusterIdsFromServerForPull($serverSync, $onlyUpdateLocalCluster = true, $elligibleClusters = $localClustersToUpdate);\n            } elseif (\"pull_relevant_clusters\" === $technique) {\n                // Fetch all local custom cluster tags then fetch their corresponding clusters on the remote end\n                $tagNames = $this->Tag->find('column', array(\n                    'conditions' => array(\n                        'Tag.is_custom_galaxy' => true\n                    ),\n                    'fields' => array('Tag.name'),\n                ));\n                $clusterUUIDs = array();\n                $re = '/^misp-galaxy:[^:=\"]+=\"(?<uuid>[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12})\"$/m';\n                foreach ($tagNames as $tagName) {\n                    preg_match($re, $tagName, $matches);\n                    if (isset($matches['uuid'])) {\n                        $clusterUUIDs[$matches['uuid']] = true;\n                    }\n                }\n                $localClustersToUpdate = $this->getElligibleLocalClustersToUpdate($user);\n                $conditions = array('uuid' => array_keys($clusterUUIDs));\n                $clusterIds = $this->Server->getElligibleClusterIdsFromServerForPull($serverSync, $onlyUpdateLocalCluster = false, $elligibleClusters = $localClustersToUpdate, $conditions = $conditions);\n            } elseif (is_numeric($technique)) {\n                $conditions = array('eventid' => $technique);\n                $clusterIds = $this->Server->getElligibleClusterIdsFromServerForPull($serverSync, $onlyUpdateLocalCluster = false, $elligibleClusters = array(), $conditions = $conditions);\n            } else {\n                $clusterIds = $this->Server->getElligibleClusterIdsFromServerForPull($serverSync, $onlyUpdateLocalCluster = false);\n            }\n        } catch (HttpSocketHttpException $e) {\n            if ($e->getCode() === 403) {\n                return array('error' => array(1, null));\n            } else {\n                $this->logException(\"Could not get eligible cluster IDs from server {$serverSync->serverId()} for pull.\", $e);\n                return array('error' => array(2, $e->getMessage()));\n            }\n        } catch (Exception $e) {\n            $this->logException(\"Could not get eligible cluster IDs from server {$serverSync->serverId()} for pull.\", $e);\n            return array('error' => array(2, $e->getMessage()));\n        }\n        return $clusterIds;\n    }\n\n    private function __pullGalaxyCluster($clusterId, ServerSyncTool $serverSync, array $user)\n    {\n        try {\n            $cluster = $serverSync->fetchGalaxyCluster($clusterId)->json();\n        } catch (Exception $e) {\n            $this->logException(\"Could not fetch galaxy cluster $clusterId from server {$serverSync->serverId()}\", $e);\n            return false;\n        }\n\n        $cluster = $this->updatePulledClusterBeforeInsert($cluster, $serverSync->server(), $user);\n        $result = $this->captureCluster($user, $cluster, $fromPull=true, $orgId=$serverSync->server()['Server']['org_id']);\n        return $result['success'];\n    }\n\n    private function updatePulledClusterBeforeInsert($cluster, $server, $user)\n    {\n        // The cluster came from a pull, so it should be locked and distribution should be adapted.\n        $cluster['GalaxyCluster']['locked'] = true;\n        if (!isset($cluster['GalaxyCluster']['distribution'])) {\n            $cluster['GalaxyCluster']['distribution'] = '1';\n        }\n\n        if (empty(Configure::read('MISP.host_org_id')) || !$server['Server']['internal'] || Configure::read('MISP.host_org_id') != $server['Server']['org_id']) {\n            switch ($cluster['GalaxyCluster']['distribution']) {\n                case 1:\n                    $cluster['GalaxyCluster']['distribution'] = 0; // if community only, downgrade to org only after pull\n                    break;\n                case 2:\n                    $cluster['GalaxyCluster']['distribution'] = 1; // if connected communities downgrade to community only\n                    break;\n            }\n\n            if (!empty($cluster['GalaxyCluster']['GalaxyClusterRelation'])) {\n                foreach ($cluster['GalaxyCluster']['GalaxyClusterRelation'] as $k => $relation) {\n                    switch ($relation['distribution']) {\n                        case 1:\n                            $cluster['GalaxyCluster']['GalaxyClusterRelation'][$k]['distribution'] = 0;\n                            break;\n                        case 2:\n                            $cluster['GalaxyCluster']['GalaxyClusterRelation'][$k]['distribution'] = 1;\n                            break;\n                    }\n                }\n            }\n        }\n        return $cluster;\n    }\n\n    public function attachClusterToRelations($user, $cluster, $both=true)\n    {\n        if (!empty($cluster['GalaxyCluster']['GalaxyClusterRelation'])) {\n            foreach ($cluster['GalaxyCluster']['GalaxyClusterRelation'] as $k => $relation) {\n                $conditions = array('conditions' => array('GalaxyCluster.uuid' => $relation['referenced_galaxy_cluster_uuid']));\n                $relatedCluster = $this->fetchGalaxyClusters($user, $conditions, false);\n                if (!empty($relatedCluster)) {\n                    $cluster['GalaxyCluster']['GalaxyClusterRelation'][$k]['GalaxyCluster'] = $relatedCluster[0]['GalaxyCluster'];\n                }\n            }\n        }\n        if ($both) {\n            if (!empty($cluster['GalaxyCluster']['TargetingClusterRelation'])) {\n                foreach ($cluster['GalaxyCluster']['TargetingClusterRelation'] as $k => $relation) {\n                    $conditions = array('conditions' => array('GalaxyCluster.uuid' => $relation['galaxy_cluster_uuid']));\n                    $relatedCluster = $this->fetchGalaxyClusters($user, $conditions, false);\n                    if (!empty($relatedCluster)) {\n                        $cluster['GalaxyCluster']['TargetingClusterRelation'][$k]['GalaxyCluster'] = $relatedCluster[0]['GalaxyCluster'];\n                    }\n                }\n            }\n        }\n        return $cluster;\n    }\n\n    public function cacheGalaxyClusterIDs($user)\n    {\n        if (isset($this->__assetCache['gcids'])) {\n            return $this->__assetCache['gcids'];\n        } else {\n            $gcids = $this->fetchGalaxyClusters($user, array(\n                'fields' => 'id',\n            ), false);\n            $alias = $this->alias;\n            $gcids = Hash::extract($gcids, \"{n}.${alias}.id\");\n            if (empty($gcids)) {\n                $gcids = array(-1);\n            }\n            $this->__assetCache['gcids'] = $gcids;\n            return $gcids;\n        }\n    }\n    public function cacheGalaxyClusterOwnerIDs($user)\n    {\n        if (isset($this->__assetCache['gcOwnerIds'])) {\n            return $this->__assetCache['gcOwnerIds'];\n        } else {\n            $gcOwnerIds = $this->fetchGalaxyClusters($user, array(\n                'fields' => 'id',\n                'conditions' => array(\n                    'org_id' => $user['org_id']\n                )\n            ), false);\n            $alias = $this->alias;\n            $gcOwnerIds = Hash::extract($gcOwnerIds, \"{n}.${alias}.id\");\n            if (empty($gcOwnerIds)) {\n                $gcOwnerIds = array(-1);\n            }\n            $this->__assetCache['gcOwnerIds'] = $gcOwnerIds;\n            return $gcOwnerIds;\n        }\n    }\n    public function getTagIdByClusterId($cluster_id)\n    {\n        $cluster = $this->find('first', [\n            'recursive' => -1,\n            'conditions' => ['GalaxyCluster.id' => $cluster_id],\n            'contain' => ['Tag']\n        ]);\n        return empty($cluster['Tag']['id']) ? false : $cluster['Tag']['id'];\n    }\n\n    public function getCyCatRelations($cluster)\n    {\n        $CyCatRelations = [];\n        if (empty(Configure::read('Plugin.CyCat_enable'))) {\n            return $CyCatRelations;\n        }\n        App::uses('SyncTool', 'Tools');\n        $cycatUrl = empty(Configure::read(\"Plugin.CyCat_url\")) ? 'https://api.cycat.org': Configure::read(\"Plugin.CyCat_url\");\n        $syncTool = new SyncTool();\n        if (empty($this->HttpSocket)) {\n            $this->HttpSocket = $syncTool->createHttpSocket();\n        }\n        $request = array(\n            'header' => array(\n                'Accept' => array('application/json'),\n                'MISP-version' => implode('.', $this->checkMISPVersion()),\n                'MISP-uuid' => Configure::read('MISP.uuid'),\n                'x-ground-truth' => 'Dogs are superior to cats'\n            )\n        );\n        $response = $this->HttpSocket->get($cycatUrl . '/lookup/' . $cluster['GalaxyCluster']['uuid'], array(), $request);\n        if ($response->code === '200') {\n            $response = $this->HttpSocket->get($cycatUrl . '/relationships/' . $cluster['GalaxyCluster']['uuid'], array(), $request);\n            if ($response->code === '200') {\n                $relationUUIDs = json_decode($response->body);\n                if (!empty($relationUUIDs)) {\n                    foreach ($relationUUIDs as $relationUUID) {\n                        $response = $this->HttpSocket->get($cycatUrl . '/lookup/' . $relationUUID, array(), $request);\n                        if ($response->code === '200') {\n                            $lookupResult = json_decode($response->body, true);\n                            $lookupResult['uuid'] = $relationUUID;\n                            $CyCatRelations[$relationUUID] = $lookupResult;\n                        }\n                    }\n                }\n            }\n        }\n        return $CyCatRelations;\n    }\n}\n", "<?php\nApp::uses('AppModel', 'Model');\nApp::uses('WorkflowGraphTool', 'Tools');\nApp::uses('Folder', 'Utility');\n\nclass WorkflowDuplicatedModuleIDException extends Exception {}\nclass TriggerNotFoundException extends Exception {}\nclass ModuleNotFoundException extends Exception {}\nclass WorkflowNotFoundException extends Exception {}\n\nclass Workflow extends AppModel\n{\n    public $recursive = -1;\n\n    public $actsAs = [\n        'AuditLog',\n        'Containable',\n        'SysLogLogable.SysLogLogable' => [\n            'roleModel' => 'Role',\n            'roleKey' => 'role_id',\n            'change' => 'full'\n        ],\n    ];\n\n    public $belongsTo = [\n    ];\n\n    public $validate = [\n        'value' => [\n            'stringNotEmpty' => [\n                'rule' => ['stringNotEmpty']\n            ]\n        ],\n        'uuid' => [\n            'uuid' => [\n                'rule' => 'uuid',\n                'message' => 'Please provide a valid RFC 4122 UUID'\n            ],\n            'unique' => [\n                'rule' => 'isUnique',\n                'message' => 'The UUID provided is not unique',\n                'required' => 'create'\n            ]\n        ],\n        'data' => [\n            'hasAcyclicGraph' => [\n                'rule' => ['hasAcyclicGraph'],\n                'message' => 'Cannot save a workflow containing a cycle',\n            ],\n            'hasOneTrigger' => [\n                'rule' => ['hasOneTrigger'],\n                'message' => 'Cannot save a workflow containing no or more than one trigger',\n            ],\n            'satisfiesMultipleConnectionCondition' => [\n                'rule' => ['satisfiesMultipleConnectionCondition'],\n                'message' => 'Cannot save a workflow having more than one connection per output',\n            ]\n        ]\n    ];\n\n    /** @var WorkflowGraphTool */\n    public $workflowGraphTool;\n    public $defaultContain = [\n    ];\n\n    private $loaded_modules = [];\n    private $loaded_classes = [];\n    private $error_while_loading = [];\n\n    private $module_initialized = false;\n    private $modules_enabled_by_default = ['generic-if', 'distribution-if', 'published-if', 'organisation-if', 'tag-if', 'concurrent-task', 'stop-execution', 'webhook', 'push-zmq'];\n\n    const CAPTURE_FIELDS_EDIT = ['name', 'description', 'timestamp', 'data', 'debug_enabled'];\n    const CAPTURE_FIELDS_ADD = ['uuid', 'name', 'description', 'timestamp', 'data', 'trigger_id', 'debug_enabled'];\n\n    const MODULE_ROOT_PATH = APP . 'Model/WorkflowModules/';\n    const CUSTOM_MODULE_ROOT_PATH = APP . 'Lib/WorkflowModules/';\n    const REDIS_KEY_WORKFLOW_NAMESPACE = 'workflow';\n    const REDIS_KEY_WORKFLOW_PER_TRIGGER = 'workflow:workflow_list:%s';\n    const REDIS_KEY_TRIGGER_PER_WORKFLOW = 'workflow:trigger_list:%s';\n    const REDIS_KEY_MODULES_ENABLED = 'workflow:modules_enabled';\n\n    public function __construct($id = false, $table = null, $ds = null)\n    {\n        parent::__construct($id, $table, $ds);\n        $this->workflowGraphTool = new WorkflowGraphTool();\n    }\n\n    public function beforeValidate($options = array())\n    {\n        parent::beforeValidate();\n        if (empty($this->data['Workflow']['uuid'])) {\n            $this->data['Workflow']['uuid'] = CakeText::uuid();\n        } else {\n            $this->data['Workflow']['uuid'] = strtolower($this->data['Workflow']['uuid']);\n        }\n        if (empty($this->data['Workflow']['data'])) {\n            $this->data['Workflow']['data'] = [];\n        }\n        if (empty($this->data['Workflow']['timestamp'])) {\n            $this->data['Workflow']['timestamp'] = time();\n        }\n        if (empty($this->data['Workflow']['description'])) {\n            $this->data['Workflow']['description'] = '';\n        }\n        return true;\n    }\n\n    public function afterFind($results, $primary = false)\n    {\n        foreach ($results as $k => $result) {\n            if (empty($result['Workflow']['data'])) {\n                $result['Workflow']['data'] = '{}';\n            }\n            $results[$k]['Workflow']['data'] = JsonTool::decode($result['Workflow']['data']);\n            if (!empty($result['Workflow']['id'])) {\n                $trigger_ids = $this->__getTriggersIDPerWorkflow((int) $result['Workflow']['id']);\n                $results[$k]['Workflow']['listening_triggers'] = $this->getModuleByID($trigger_ids);\n            }\n        }\n        return $results;\n    }\n\n    public function beforeSave($options = [])\n    {\n        if (is_array($this->data['Workflow']['data'])) {\n            $this->data['Workflow']['data'] = JsonTool::encode($this->data['Workflow']['data']);\n        }\n        return true;\n    }\n\n    public function afterSave($created, $options = [])\n    {\n        $this->updateListeningTriggers($this->data);\n    }\n\n    public function beforeDelete($cascade = true)\n    {\n        parent::beforeDelete($cascade);\n        $workflow = $this->find('first', [ // $this->data is empty in afterDelete?!\n            'recursive' => -1,\n            'conditions' => ['Workflow.id' => $this->id]\n        ]);\n        $workflow['Workflow']['data'] = []; // Make sure not trigger are listening\n        $this->workflowToDelete = $workflow;\n    }\n\n    public function afterDelete()\n    {\n        // $this->data is empty?!\n        parent::afterDelete();\n        $this->updateListeningTriggers($this->workflowToDelete);\n    }\n\n    public function enableDefaultModules()\n    {\n        $this->toggleModules($this->modules_enabled_by_default, true, false);\n    }\n\n    /**\n     * @param string $trigger_id\n     * @return bool\n     * @throws WorkflowDuplicatedModuleIDException\n     */\n    protected function checkTriggerEnabled($trigger_id)\n    {\n        static $enabled;\n\n        if ($enabled === null) {\n            $enabled = (bool)Configure::read('Plugin.Workflow_enable');\n        }\n        if (!$enabled) {\n            return false;\n        }\n\n        $settingName = \"Plugin.Workflow_triggers_$trigger_id\";\n        $module_disabled = empty(Configure::read($settingName));\n        if ($module_disabled) {\n            return false;\n        }\n\n        $filename = sprintf('Module_%s.php', preg_replace('/[^a-zA-Z0-9_]/', '_', Inflector::underscore($trigger_id)));\n        $module_config = $this->__getClassFromModuleFiles('trigger', [$filename], false)['classConfigs'];\n        return empty($module_config['disabled']);\n    }\n\n    protected function getEnabledModules(): array\n    {\n        try {\n            $redis = $this->setupRedisWithException();\n        } catch (Exception $e) {\n            return false;\n        }\n        $list = $redis->sMembers(Workflow::REDIS_KEY_MODULES_ENABLED);\n        return !empty($list) ? $list : [];\n    }\n\n    public function toggleModule($module_id, $enable, $is_trigger=false): bool\n    {\n        if (!empty($is_trigger)) {\n            $settingName = sprintf('Plugin.Workflow_triggers_%s', $module_id);\n            $server = ClassRegistry::init('Server');\n            return $server->serverSettingsSaveValue($settingName, !empty($enable), false);\n        } else {\n            try {\n                $redis = $this->setupRedisWithException();\n            } catch (Exception $e) {\n                return false;\n            }\n            if ($enable) {\n                $redis->sAdd(Workflow::REDIS_KEY_MODULES_ENABLED, $module_id);\n            } else {\n                $redis->sRem(Workflow::REDIS_KEY_MODULES_ENABLED, $module_id);\n            }\n        }\n        return true;\n    }\n\n    public function toggleDebug($workflow_id, $enable): bool\n    {\n        $workflow = $this->fetchWorkflow($workflow_id);\n        $workflow['Workflow']['debug_enabled'] = !empty($enable);\n        $result = $this->editWorkflow($workflow);\n        return empty($result['errrors']);\n    }\n\n    public function toggleModules($module_ids, $enable, $is_trigger=false): int\n    {\n        $enabled_count = 0;\n        foreach ($module_ids as $module_id) {\n            $enabled_count += $this->toggleModule($module_id, $enable, $is_trigger) ? 1 : 0;\n        }\n        return $enabled_count;\n    }\n\n    protected function checkTriggerListenedTo($trigger_id)\n    {\n        return !empty($this->__getWorkflowsIDPerTrigger($trigger_id));\n    }\n\n    public function rebuildRedis()\n    {\n        $redis = $this->setupRedisWithException();\n        $workflows = $this->fetchWorkflows();\n        $keys = $redis->keys(Workflow::REDIS_KEY_WORKFLOW_NAMESPACE . ':*');\n        $redis->delete($keys);\n        foreach ($workflows as $wokflow) {\n            $this->updateListeningTriggers($wokflow);\n        }\n    }\n\n    /**\n     * updateListeningTriggers \n     *  - Update the list of triggers that will be run this workflow\n     *  - Update the list of workflows that are run by their triggers\n     *  - Update the ordered list of workflows that are run by their triggers\n     *\n     * @param  array $workflow\n     */\n    public function updateListeningTriggers($workflow)\n    {\n        try {\n            $redis = $this->setupRedisWithException();\n        } catch (Exception $e) {\n            $this->logException('Failed to setup redis ', $e);\n            return false;\n        }\n        if (!is_array($workflow['Workflow']['data'])) {\n            $workflow['Workflow']['data'] = JsonTool::decode($workflow['Workflow']['data']);\n        }\n        $original_trigger_list_id = $this->__getTriggersIDPerWorkflow((int)$workflow['Workflow']['id']);\n        $new_node_trigger_list = $this->workflowGraphTool->extractTriggersFromWorkflow($workflow['Workflow']['data'], true);\n        $new_node_trigger_list_per_id = Hash::combine($new_node_trigger_list, '{n}.data.id', '{n}');\n        $new_trigger_list_id = array_keys($new_node_trigger_list_per_id);\n        $trigger_to_remove = array_diff($original_trigger_list_id, $new_trigger_list_id);\n        $trigger_to_add = array_diff($new_trigger_list_id, $original_trigger_list_id);\n        if (!empty($trigger_to_remove)) {\n            $pipeline = $redis->multi();\n            foreach ($trigger_to_remove as $trigger_id) {\n                $pipeline->sRem(sprintf(Workflow::REDIS_KEY_WORKFLOW_PER_TRIGGER, $trigger_id), $workflow['Workflow']['id']);\n                $pipeline->sRem(sprintf(Workflow::REDIS_KEY_TRIGGER_PER_WORKFLOW, $workflow['Workflow']['id']), $trigger_id);\n            }\n            $pipeline->exec();\n        }\n        if (!empty($trigger_to_add)) {\n            $pipeline = $redis->multi();\n            foreach ($trigger_to_add as $trigger_id) {\n                $pipeline->sAdd(sprintf(Workflow::REDIS_KEY_WORKFLOW_PER_TRIGGER, $trigger_id), $workflow['Workflow']['id']);\n                $pipeline->sAdd(sprintf(Workflow::REDIS_KEY_TRIGGER_PER_WORKFLOW, $workflow['Workflow']['id']), $trigger_id);\n            }\n            $pipeline->exec();\n        }\n    }\n\n    /**\n     * __getWorkflowsIDPerTrigger Get list of workflow IDs listening to the specified trigger\n     *\n     * @param  string $trigger_id\n     * @return bool|array\n     */\n    private function __getWorkflowsIDPerTrigger($trigger_id): array\n    {\n        try {\n            $redis = $this->setupRedisWithException();\n        } catch (Exception $e) {\n            return false;\n        }\n        $list = $redis->sMembers(sprintf(Workflow::REDIS_KEY_WORKFLOW_PER_TRIGGER, $trigger_id));\n        return !empty($list) ? $list : [];\n    }\n\n    /**\n     * __getTriggersIDPerWorkflow Get list of trigger name running to the specified workflow\n     *\n     * @param  int $workflow_id\n     * @return bool|array\n     */\n    private function __getTriggersIDPerWorkflow(int $workflow_id)\n    {\n        try {\n            $redis = $this->setupRedisWithException();\n        } catch (Exception $e) {\n            return false;\n        }\n        return $redis->sMembers(sprintf(Workflow::REDIS_KEY_TRIGGER_PER_WORKFLOW, $workflow_id));\n    }\n\n    public function getListeningWorkflowForTrigger(array $trigger): array\n    {\n        return array_map(function($id) {\n            return intval($id);\n        }, $this->__getWorkflowsIDPerTrigger($trigger['id']));\n    }\n\n    /**\n     * attachWorkflowToTriggers Collect the workflows listening to this trigger\n     *\n     * @param  array $triggers\n     * @return array\n     */\n    public function attachWorkflowToTriggers(array $triggers): array\n    {\n        $workflows = $this->fetchWorkflows([\n            'conditions' => [\n                'Workflow.trigger_id' => Hash::extract($triggers, '{n}.id'),\n            ],\n            'fields' => ['*'],\n        ]);\n        $workflows_per_trigger = Hash::combine($workflows, '{n}.Workflow.trigger_id', '{n}');\n        foreach ($triggers as $i => $trigger) {\n            if (!empty($workflows_per_trigger[$trigger['id']])) {\n                $triggers[$i]['Workflow'] = $workflows_per_trigger[$trigger['id']]['Workflow'];\n            }\n        }\n        return $triggers;\n    }\n\n    /**\n     * hasAcyclicGraph Return if the graph is acyclic or not\n     *\n     * @param array $graphData\n     * @return boolean\n     */\n    public function hasAcyclicGraph(array $workflow): bool\n    {\n        $graphData = !empty($workflow['Workflow']) ? $workflow['Workflow']['data'] : $workflow['data'];\n        $isAcyclic = $this->workflowGraphTool->isAcyclic($graphData);\n        return $isAcyclic;\n    }\n\n    /**\n     * hasOneTrigger Return if the graph contain more than one instance of the same trigger\n     *\n     * @param array $graphData\n     * @return boolean\n     */\n    public function hasOneTrigger(array $workflow): bool\n    {\n        $graphData = !empty($workflow['Workflow']) ? $workflow['Workflow']['data'] : $workflow['data'];\n        $triggers = $this->workflowGraphTool->extractTriggersFromWorkflow($graphData, true);\n        return count($triggers) == 1;\n    }\n\n    /**\n     * satisfiesMultipleConnectionCondition Return if the graph contain more than one instance of the same trigger\n     *\n     * @param array $graphData\n     * @return boolean\n     */\n    public function satisfiesMultipleConnectionCondition(array $workflow): bool\n    {\n        $graphData = !empty($workflow['Workflow']) ? $workflow['Workflow']['data'] : $workflow['data'];\n        $hasMultipleOutputConnection = $this->workflowGraphTool->hasMultipleOutputConnection($graphData);\n        return !$hasMultipleOutputConnection;\n    }\n\n    /**\n     * executeWorkflow\n     *\n     * @param int $workflow_id\n     * @param array $data\n     * @param array $blockingErrors\n     * @return array\n     */\n    public function executeWorkflow($workflow_id, array $data, array &$blockingErrors=[]): array\n    {\n        $this->loadAllWorkflowModules();\n\n        $workflow = $this->fetchWorkflow($workflow_id, true);\n        $graphData = !empty($workflow['Workflow']) ? $workflow['Workflow']['data'] : $workflow['data'];\n        $startNode = $this->workflowGraphTool->extractTriggerFromWorkflow($graphData, true);\n        $startNodeID = $startNode['id'];\n        $trigger_id = $startNode['data']['id'];\n        if ($startNode  == -1) {\n            $blockingErrors[] = __('Invalid start node `%s`', $startNodeID);\n            return false;\n        }\n\n        $triggerModule = $this->getModuleClassByType('trigger', $trigger_id, true);\n        if (!empty($triggerModule->disabled)) {\n            return true;\n        }\n        $result = $this->__runWorkflow($workflow, $triggerModule, $data, $startNodeID, $blockingErrors);\n        return $result;\n    }\n\n    /**\n     * executeWorkflowForTrigger\n     *\n     * @param string $trigger_id\n     * @param array $data\n     * @return bool\n     * @throws TriggerNotFoundException\n     */\n    public function executeWorkflowForTriggerRouter($trigger_id, array $data, array &$blockingErrors=[], array $logging=[]): bool\n    {\n        $this->loadAllWorkflowModules();\n\n        if (empty($this->loaded_modules['trigger'][$trigger_id])) {\n            throw new TriggerNotFoundException(__('Unknown trigger `%s`', $trigger_id));\n        }\n        $trigger = $this->loaded_modules['trigger'][$trigger_id];\n        if (!empty($trigger['disabled'])) {\n            return true;\n        }\n\n        if (empty($trigger['blocking'])) {\n            $this->Job = ClassRegistry::init('Job');\n            $jobId = $this->Job->createJob(\n                'SYSTEM',\n                Job::WORKER_PRIO,\n                'executeWorkflowForTrigger',\n                sprintf('Workflow for trigger `%s`', $trigger_id),\n                __('Executing non-blocking workflow for trigger `%s`', $trigger_id)\n            );\n            $this->Job->getBackgroundJobsTool()->enqueue(\n                BackgroundJobsTool::PRIO_QUEUE,\n                BackgroundJobsTool::CMD_WORKFLOW,\n                [\n                    'executeWorkflowForTrigger',\n                    $trigger_id,\n                    JsonTool::encode($data),\n                    JsonTool::encode($logging),\n                    $jobId\n                ],\n                true,\n                $jobId\n            );\n            return true;\n        } else {\n            $blockingPathExecutionSuccess = $this->executeWorkflowForTrigger($trigger_id, $data, $blockingErrors);\n            return $blockingPathExecutionSuccess;\n        }\n    }\n\n    /**\n     * executeWorkflowForTrigger\n     *\n     * @param string $trigger_id\n     * @param array $data\n     * @param array $errors\n     * @return boolean True if the execution for the blocking path was a success\n     * @throws TriggerNotFoundException\n     */\n    public function executeWorkflowForTrigger($trigger_id, array $data, array &$blockingErrors=[]): bool\n    {\n        $this->loadAllWorkflowModules();\n\n        $triggerModule = $this->getModuleClassByType('trigger', $trigger_id, true);\n        if (!empty($triggerModule->disabled)) {\n            return true;\n        }\n\n        $workflow = $this->fetchWorkflowByTrigger($trigger_id, true);\n        if (empty($workflow)) {\n            throw new WorkflowNotFoundException(__('Could not get workflow for trigger `%s`', $trigger_id));\n        }\n        $graphData = !empty($workflow['Workflow']) ? $workflow['Workflow']['data'] : $workflow['data'];\n        $startNodeID = $this->workflowGraphTool->getNodeIdForTrigger($graphData, $trigger_id);\n        if ($startNodeID  == -1) {\n            $blockingErrors[] = __('Invalid start node `%s`', $startNodeID);\n            return false;\n        }\n        $result = $this->__runWorkflow($workflow, $triggerModule, $data, $startNodeID, $blockingErrors);\n        return $result['success'];\n    }\n\n    /**\n     * runWorkflow\n     *\n     * @param array $workflow\n     * @param $triggerModule\n     * @param array $data\n     * @param int $startNodeID\n     * @return array\n     */\n    private function __runWorkflow(array $workflow, $triggerModule, array $data, $startNodeID, &$blockingErrors=[]): array\n    {\n        $this->Log = ClassRegistry::init('Log');\n        $message =  __('Started executing workflow for trigger `%s` (%s)', $triggerModule->id, $workflow['Workflow']['id']);\n        $this->Log->createLogEntry('SYSTEM', 'execute_workflow', 'Workflow', $workflow['Workflow']['id'], $message);\n        $this->__logToFile($workflow, $message);\n        $workflow = $this->__incrementWorkflowExecutionCount($workflow);\n        $walkResult = [];\n        $debugData = ['original' => $data];\n        $data = $this->__normalizeDataForTrigger($triggerModule, $data);\n        $debugData['normalized'] = $data;\n        $for_path = !empty($triggerModule->blocking) ? GraphWalker::PATH_TYPE_BLOCKING : GraphWalker::PATH_TYPE_NON_BLOCKING;\n        $this->sendRequestToDebugEndpoint($workflow, [], '/init?type=' . $for_path, $debugData);\n\n        $blockingPathExecutionSuccess = $this->walkGraph($workflow, $startNodeID, $for_path, $data, $blockingErrors, $walkResult);\n        $executionStoppedByStopModule = in_array('stop-execution', Hash::extract($walkResult, 'blocking_nodes.{n}.data.id'));\n        if (empty($blockingPathExecutionSuccess)) {\n            $message = __('Execution stopped. %s', PHP_EOL . implode(', ', $blockingErrors));\n            $this->logExecutionError($workflow, $message);\n        }\n        $outcomeText = 'failure';\n        if (!empty($blockingPathExecutionSuccess)) {\n            $outcomeText = 'success';\n        } else if ($executionStoppedByStopModule) {\n            $outcomeText = 'blocked';\n        }\n        $message =  __('Finished executing workflow for trigger `%s` (%s). Outcome: %s', $triggerModule->id, $workflow['Workflow']['id'], $outcomeText);\n\n        $this->Log->createLogEntry('SYSTEM', 'execute_workflow', 'Workflow', $workflow['Workflow']['id'], $message);\n        $this->__logToFile($workflow, $message);\n        $this->sendRequestToDebugEndpoint($workflow, [], '/end?outcome=' . $outcomeText, $walkResult);\n        return [\n            'outcomeText' => $outcomeText,\n            'walkResult' => $walkResult,\n            'success' => $blockingPathExecutionSuccess,\n        ];\n    }\n\n    /**\n     * walkGraph Walk the graph for the provided trigger and execute each nodes\n     *\n     * @param array $workflow The worflow to walk\n     * @param int $startNode The ID of the trigger to start from\n     * @param string|null $for_path If provided, execute the workflow for the provided path. If not provided, execute the worflow regardless of the path\n     * @param array $data\n     * @param array $errors\n     * @return boolean If all module returned a successful response\n     */\n    public function walkGraph(array $workflow, int $startNode, $for_path=null, array $data=[], array &$errors=[], array &$walkResult=[]): bool\n    {\n        $walkResult = [\n            'blocking_nodes' => [],\n            'executed_nodes' => [],\n            'blocked_paths' => [],\n        ];\n        $userForWorkflow = $this->getUserForWorkflow();\n        if (empty($userForWorkflow)) {\n            $errors[] = __('Could not find a valid user to run the workflow. Please set setting `MISP.host_org_id` or make sure a valid site_admin user exists.');\n            return false;\n        }\n        $roamingData = $this->workflowGraphTool->getRoamingData($userForWorkflow, $data, $workflow, $startNode);\n        $graphData = !empty($workflow['Workflow']) ? $workflow['Workflow']['data'] : $workflow['data'];\n        $graphWalker = $this->workflowGraphTool->getWalkerIterator($graphData, $this, $startNode, $for_path, $roamingData);\n        $preventExecutionForPaths = [];\n        foreach ($graphWalker as $graphNode) {\n            $node = $graphNode['node'];\n            $moduleClass = $this->getModuleClass($node);\n            foreach ($preventExecutionForPaths as $path_to_block) {\n                if ($path_to_block == array_slice($graphNode['path_list'], 0, count($path_to_block))) {\n                    $walkResult['blocked_paths'][] = $graphNode['path_list'];\n                    continue 2;\n                }\n            }\n            $nodeError = [];\n            $success = $this->executeNode($node, $roamingData, $nodeError);\n            $walkResult['executed_nodes'][] = $node;\n            if (empty($success)) {\n                $walkResult['blocking_nodes'][] = $node;\n                if (!empty($nodeError)) {\n                    $errors[] = __(\n                        'Node `%s` (%s) from Workflow `%s` (%s) returned the following error: %s',\n                        $node['data']['id'],\n                        $node['id'],\n                        $workflow['Workflow']['name'],\n                        $workflow['Workflow']['id'],\n                        implode(', ', $nodeError)\n                    );\n                }\n                if (!empty($moduleClass->blocking)) {\n                    return false; // Node stopped execution for any path. If a module is blocking and it failed, stop the walk\n                } else if ($graphNode['path_type'] == GraphWalker::PATH_TYPE_NON_BLOCKING) {\n                    $preventExecutionForPaths[] = $graphNode['path_list']; // Paths down the chain should not be executed\n                }\n            }\n        }\n        return true;\n    }\n\n    public function getUserForWorkflow(): array\n    {\n        $this->Organisation = ClassRegistry::init('Organisation');\n        $hostOrg = $this->Organisation->find('first', [\n            'recursive' => -1,\n            'conditions' => [\n                'id' => Configure::read('MISP.host_org_id')\n            ],\n        ]);\n        if (!empty($hostOrg)) {\n            $userForWorkflow = [\n                'email' => 'SYSTEM',\n                'id' => 0,\n                'org_id' => $hostOrg['Organisation']['id'],\n                'Role' => ['perm_site_admin' => 1],\n                'Organisation' => $hostOrg['Organisation']\n            ];\n        } else {\n            $this->User = ClassRegistry::init('User');\n            $userForWorkflow = $this->User->find('first', [\n                'recursive' => -1,\n                'conditions' => [\n                    'Role.perm_site_admin' => 1,\n                    'User.disabled' => 0\n                ],\n                'contain' => [\n                    'Organisation' => ['fields' => ['name']],\n                    'Role' => ['fields' => ['*']],\n                ],\n                'fields' => ['User.org_id', 'User.id', 'User.email'],\n            ]);\n            $userForWorkflow['Server'] = [];\n            $userForWorkflow = $this->User->rearrangeToAuthForm($userForWorkflow);\n        }\n        return $userForWorkflow;\n    }\n\n    public function executeNode(array $node, WorkflowRoamingData $roamingData, array &$errors=[]): bool\n    {\n        $roamingData->setCurrentNode($node['id']);\n        $moduleClass = $this->getModuleClass($node);\n        if (!empty($moduleClass->disabled)) {\n            $message = __('Could not execute disabled module `%s`.', $node['data']['id']);\n            $this->logExecutionError($roamingData->getWorkflow(), $message);\n            $errors[] = $message;\n            $this->sendRequestToDebugEndpoint($roamingData->getWorkflow(), $node, sprintf('/exec/%s?result=%s', $moduleClass->id, 'disabled_module'), $roamingData->getData());\n            return false;\n        }\n        if (!is_null($moduleClass)) {\n            try {\n                $success = $moduleClass->exec($node, $roamingData, $errors);\n            } catch (Exception $e) {\n                $message = __('Error while executing module %s. Error: %s', $node['data']['id'], $e->getMessage());\n                $this->logExecutionError($roamingData->getWorkflow(), $message);\n                $errors[] = $message;\n                $this->sendRequestToDebugEndpoint($roamingData->getWorkflow(), $node, sprintf('/exec/%s?result=%s&message=%s', $moduleClass->id, 'error', $e->getMessage()), $roamingData->getData());\n                return false;\n            }\n        } else {\n            $message = sprintf(__('Could not load class for module: %s'), $node['data']['id']);\n            $this->logExecutionError($roamingData->getWorkflow(), $message);\n            $errors[] = $message;\n            $this->sendRequestToDebugEndpoint($roamingData->getWorkflow(), $node, sprintf('/exec/%s?result=%s', $node['data']['id'], 'loading_error'), $roamingData->getData());\n            return false;\n        }\n        $this->sendRequestToDebugEndpoint($roamingData->getWorkflow(), $node, sprintf('/exec/%s?result=%s', $moduleClass->id, 'success'), $roamingData->getData());\n        return $success;\n    }\n\n    private function __normalizeDataForTrigger($triggerClass, array $data): array\n    {\n        if (method_exists($triggerClass, 'normalizeData')) {\n            return $triggerClass->normalizeData($data);\n        }\n        return $data;\n    }\n\n    private function digestExecutionResult(array $walkResult)\n    {\n        if (empty($walkResult['Nodes that stopped execution'])) {\n            return __('All nodes executed.');\n        }\n        $str = [];\n        foreach ($walkResult['Nodes that stopped execution'] as $node) {\n            $str[] = __('Node `%s` (%s) stopped execution.', $node['data']['id'], $node['id']);\n        }\n        return implode(', ', $str);\n    }\n\n    public function getModuleClass($node)\n    {\n        $this->loadAllWorkflowModules();\n        $moduleClass = $this->loaded_classes[$node['data']['module_type']][$node['data']['id']] ?? null;\n        return $moduleClass;\n    }\n\n    /**\n     * getModuleClassByType\n     *\n     * @param string $module_type\n     * @param string $id\n     * @param boolean $throwException\n     * @return\n     * @throws ModuleNotFoundException\n     */\n    public function getModuleClassByType($module_type, $id, $throwException=false)\n    {\n        $this->loadAllWorkflowModules();\n        $moduleClass = $this->loaded_classes[$module_type][$id] ?? null;\n        if (is_null($moduleClass) && !empty($throwException)) {\n            if ($module_type == 'trigger') {\n                throw new TriggerNotFoundException(__('Unknown module `%s` for module type `%s`', $id, $module_type));\n            } else {\n                throw new ModuleNotFoundException(__('Unknown module `%s` for module type `%s`', $id, $module_type));\n            }\n        }\n        return $moduleClass;\n    }\n\n    /**\n     * getModuleConfigByType\n     *\n     * @param string $module_type\n     * @param string $id\n     * @param boolean $throwException\n     * @return array\n     * @throws ModuleNotFoundException\n     */\n    public function getModuleConfigByType($module_type, $id, $throwException=false): ?array\n    {\n        $this->loadAllWorkflowModules();\n        $moduleConfig = $this->loaded_modules[$module_type][$id] ?? null;\n        if (is_null($moduleConfig) && !empty($throwException)) {\n            throw new ModuleNotFoundException(__('Unknown module `%s` for module type `%s`', $id, $module_type));\n        }\n        return $moduleConfig;\n    }\n\n    public function attachNotificationToModules(array $modules, array $workflow): array\n    {\n        $trigger_is_misp_core_format = false;\n        $trigger_is_blocking = false;\n        $trigger_id = $this->workflowGraphTool->extractTriggerFromWorkflow($workflow['Workflow']['data'], false);\n        if (!empty($trigger_id)) {\n            $triggerClass = $this->getModuleClassByType('trigger', $trigger_id, true);\n            $trigger_is_misp_core_format = !empty($triggerClass->misp_core_format);\n            $trigger_is_blocking = !empty($triggerClass->blocking);\n        }\n        foreach ($modules as $moduleType => $modulesByType) {\n            foreach ($modulesByType as $i => $module) {\n                $modules[$moduleType][$i]['notifications'] = !empty($module['notifications']) ? $module['notifications'] : [\n                    'error' => [],\n                    'warning' => [],\n                    'info' => [],\n                ];\n                if ($module['disabled']) {\n                    $modules[$moduleType][$i]['notifications']['error'][] = [\n                        'text' => __('Module disabled'),\n                        'description' => __('This module is disabled and thus will not be executed.'),\n                        'details' => [\n                            __('Disabled modules that are blocking will also stop the execution')\n                        ],\n                        '__show_in_sidebar' => false,\n                        '__show_in_node' => true,\n                    ];\n                }\n                if (!$trigger_is_blocking && !empty($module['blocking'])) {\n                    $modules[$moduleType][$i]['notifications']['warning'][] = [\n                        'text' => __('Blocking module might not work as intended'),\n                        'description' => __('This module is a blocking module for a non-blocking trigger.'),\n                        'details' => [\n                            __('The Blocking modules will be executed. However, it will not block the remaining of the execution')\n                        ],\n                        '__show_in_sidebar' => true,\n                        '__show_in_node' => true,\n                    ];\n                }\n                if ($moduleType != 'modules_trigger') {\n                    if (!$trigger_is_misp_core_format && !empty($module['expect_misp_core_format'])) {\n                        $modules[$moduleType][$i]['notifications']['warning'][] = [\n                            'text' => __('Potential data format issue'),\n                            'description' => __('This module might not work properly as it expect data compliant with the MISP core format.'),\n                            'details' => [\n                                __('This module expect data to be compliant with the MISP core format. However, the data passed by the trigger might not be under this format.')\n                            ],\n                            '__show_in_sidebar' => true,\n                            '__show_in_node' => true,\n                        ];\n                    }\n                }\n                if ($moduleType == 'modules_action') {\n                    $moduleClass = $this->getModuleClassByType('action', $module['id']);\n                    $diagnostic = $moduleClass->diagnostic();\n                    $modules[$moduleType][$i]['notifications'] = array_merge_recursive($modules[$moduleType][$i]['notifications'], $diagnostic);\n                }\n            }\n        }\n        return $modules;\n    }\n\n    public function loadAllWorkflowModules()\n    {\n        if ($this->module_initialized) {\n            return;\n        }\n        $phpModuleFiles = Workflow::__listPHPModuleFiles();\n        foreach ($phpModuleFiles as $type => $files) {\n            if ($type == 'custom') {\n                continue;\n            }\n            $classModuleFromFiles = $this->__getClassFromModuleFiles($type, $files, false);\n            foreach ($classModuleFromFiles['classConfigs'] as $i => $config) {\n                $classModuleFromFiles['classConfigs'][$i]['module_type'] = $type;\n            }\n            $this->loaded_modules[$type] = $classModuleFromFiles['classConfigs'];\n            $this->loaded_classes[$type] = $classModuleFromFiles['instancedClasses'];\n        }\n        // Load custom PHP modules from Lib\n        foreach ($phpModuleFiles['custom'] as $type => $files) {\n            $classModuleFromFiles = $this->__getClassFromModuleFiles($type, $files, true);\n            foreach ($classModuleFromFiles['classConfigs'] as $i => $config) {\n                $classModuleFromFiles['classConfigs'][$i]['module_type'] = $type;\n            }\n            $this->loaded_modules[$type] = array_merge($this->loaded_modules[$type], $classModuleFromFiles['classConfigs']);\n            $this->loaded_classes[$type] = array_merge($this->loaded_classes[$type], $classModuleFromFiles['instancedClasses']);\n        }\n        // Load module from misp-module service\n        $modules_from_service = $this->__getModulesFromModuleService() ?? [];\n        $misp_module_class = $this->__getClassForMispModule($modules_from_service);\n        $misp_module_configs = [];\n        foreach ($misp_module_class as $i => $module_class) {\n            $misp_module_configs[$i] = $module_class->getConfig();\n            $misp_module_configs[$i]['module_type'] = 'action';\n        }\n        $this->loaded_modules['action'] = array_merge($this->loaded_modules['action'], $misp_module_configs);\n        $this->loaded_classes['action'] = array_merge($this->loaded_classes['action'], $misp_module_class);\n        $this->__mergeGlobalConfigIntoLoadedModules();\n        $this->module_initialized = true;\n    }\n\n    private function __mergeGlobalConfigIntoLoadedModules()\n    {\n        foreach ($this->loaded_modules['trigger'] as &$trigger) {\n            $module_disabled = empty(Configure::read(sprintf('Plugin.Workflow_triggers_%s', $trigger['id'])));\n            $trigger['html_template'] = !empty($trigger['html_template']) ? $trigger['html_template'] : 'trigger';\n            $trigger['disabled'] = $module_disabled;\n            $this->loaded_classes['trigger'][$trigger['id']]->disabled = $module_disabled;\n            $this->loaded_classes['trigger'][$trigger['id']]->html_template = !empty($trigger['html_template']) ? $trigger['html_template'] : 'trigger';\n        }\n        $enabledModules = $this->getEnabledModules();\n        array_walk($this->loaded_modules['logic'], function (&$logic) use ($enabledModules) {\n            $module_disabled = !in_array($logic['id'], $enabledModules);\n            $logic['disabled'] = $module_disabled;\n            $this->loaded_classes['logic'][$logic['id']]->disabled = $module_disabled;\n        });\n        array_walk($this->loaded_modules['action'], function (&$action) use ($enabledModules) {\n            $module_disabled = !in_array($action['id'], $enabledModules);\n            $action['disabled'] = $module_disabled;\n            $this->loaded_classes['action'][$action['id']]->disabled = $module_disabled;\n        });\n\n    }\n\n    private function __getEnabledModulesFromModuleService()\n    {\n        if (empty($this->Module)) {\n            $this->Module = ClassRegistry::init('Module');\n        }\n        $enabledModules = $this->Module->getEnabledModules(null, 'Action');\n        $misp_module_config = empty($enabledModules) ? false : $enabledModules;\n        return $misp_module_config;\n    }\n\n    private function __getModulesFromModuleService()\n    {\n        if (empty($this->Module)) {\n            $this->Module = ClassRegistry::init('Module');\n        }\n        $modules = $this->Module->getModules('Action');\n        if (is_array($modules)) {\n            foreach ($modules as $i => $temp) {\n                if (!isset($temp['meta']['module-type']) || !in_array('action', $temp['meta']['module-type'])) {\n                    unset($modules[$i]);\n                }\n            }\n        }\n        return $modules;\n    }\n\n    private function __getClassForMispModule($misp_module_configs)\n    {\n        $filepathMispModule = sprintf('%s/%s', Workflow::MODULE_ROOT_PATH, 'Module_misp_module.php');\n        $className = 'Module_misp_module';\n        $reflection = null;\n        try {\n            require_once($filepathMispModule);\n            try {\n                $reflection = new \\ReflectionClass($className);\n            } catch (\\ReflectionException $e) {\n                return $e->getMessage();\n            }\n        } catch (Exception $e) {\n            return $e->getMessage();\n        }\n        $moduleClasses = [];\n        if (is_array($misp_module_configs)) {\n            foreach ($misp_module_configs as $moduleConfig) {\n                $mainClass = $reflection->newInstance($moduleConfig);\n                if ($mainClass->checkLoading() === 'The Factory Must Grow') {\n                    $moduleClasses[$mainClass->id] = $mainClass;\n                }\n            }\n        }\n        return $moduleClasses;\n    }\n\n    /**\n     * __listPHPModuleFiles List all PHP modules files\n     *\n     * @param boolean|array $targetDir If provided, will only collect files from that directory\n     * @return array\n     */\n    private static function __listPHPModuleFiles($targetDir=false): array\n    {\n        $dirs = ['trigger', 'logic', 'action'];\n        if (!empty($targetDir)) {\n            $dirs = $targetDir;\n        }\n        $files = [];\n        foreach ($dirs as $dir) {\n            $folder = new Folder(Workflow::MODULE_ROOT_PATH . $dir);\n            $filesInFolder = $folder->find('.*\\.php', true);\n            $files[$dir] = array_diff($filesInFolder, ['..', '.']);\n            if ($dir == 'action' || $dir == 'logic') { // No custom module for the triggers\n                $customFolder = new Folder(Workflow::CUSTOM_MODULE_ROOT_PATH . $dir);\n                $filesInCustomFolder = $customFolder->find('.*\\.php', true);\n                $files['custom'][$dir] = array_diff($filesInCustomFolder, ['..', '.']);\n            }\n        }\n        return $files;\n    }\n\n    private function __getClassFromModuleFiles($type, $files, $isCustom=false)\n    {\n        $instancedClasses = [];\n        $classConfigs = [];\n        foreach ($files as $filename) {\n            $filepath = sprintf('%s%s/%s', (!empty($isCustom) ? Workflow::CUSTOM_MODULE_ROOT_PATH : Workflow::MODULE_ROOT_PATH), $type, $filename);\n            $instancedClass = $this->__getClassFromModuleFile($filepath);\n            if (is_string($instancedClass)) {\n                $this->__logLoadingError($filename, $instancedClass);\n                $this->error_while_loading[$filename] = $instancedClass;\n                continue;\n            }\n            if (!empty($classConfigs[$instancedClass->id])) {\n                throw new WorkflowDuplicatedModuleIDException(__('Module %s has already been defined', $instancedClass->id));\n            }\n            $classConfigs[$instancedClass->id] = $instancedClass->getConfig();\n            $instancedClasses[$instancedClass->id] = $instancedClass;\n            if (!empty($isCustom)) {\n                $classConfigs[$instancedClass->id]['is_custom'] = true;\n                $instancedClasses[$instancedClass->id]->is_custom = true;\n            }\n        }\n        return [\n            'classConfigs' => $classConfigs,\n            'instancedClasses' => $instancedClasses,\n        ];\n    }\n\n    public function logExecutionError($workflow, $message)\n    {\n        $this->Log = ClassRegistry::init('Log');\n        $this->Log->createLogEntry('SYSTEM', 'execute_workflow', 'Workflow', $workflow['Workflow']['id'], $message);\n        $this->__logToFile($workflow, $message);\n    }\n\n    /**\n     * __logToFile Log to file\n     *\n     * @param array $workflow\n     * @param string $message\n     * @return void\n     */\n    private function __logToFile($workflow, $message)\n    {\n        $logEntry = sprintf('[%s] Workflow(%s:%s). %s' . PHP_EOL, date('Y-m-d H:i:s'), $workflow['Workflow']['trigger_id'], $workflow['Workflow']['id'], $message);\n        // file_put_contents(APP . 'tmp/logs/workflow-execution.log', $logEntry, FILE_APPEND | LOCK_EX);\n        FileAccessTool::writeToFile(APP . 'tmp/logs/workflow-execution.log', $logEntry, false, true);\n    }\n\n    private function __logLoadingError($filename, $error)\n    {\n        $this->Log = ClassRegistry::init('Log');\n        $message = __('Could not load module for file `%s`.', $filename);\n        $this->Log->createLogEntry('SYSTEM', 'load_module', 'Workflow', 0, $message, $error);\n    }\n\n    /**\n     * getProcessorClass\n     *\n     * @param  string $filePath\n     * @param  string $processorMainClassName\n     * @return object|string Object loading success, string containing the error if failure\n     */\n    private function __getClassFromModuleFile($filepath)\n    {\n        $className = explode('/', $filepath);\n        $className = str_replace('.php', '', $className[count($className)-1]);\n        try {\n            if (!@include_once($filepath)) {\n                $message = __('Could not load module for path %s. File does not exist.', $filepath);\n                $this->log($message, LOG_ERR);\n                return $message;\n            }\n            try {\n                $reflection = new \\ReflectionClass($className);\n            } catch (\\ReflectionException $e) {\n                $message = __('Could not load module for path %s. Could not instanciate class', $filepath);\n                $this->logException($message, $e);\n                return $message;\n            }\n            $mainClass = $reflection->newInstance();\n            if ($mainClass->checkLoading() === 'The Factory Must Grow') {\n                return $mainClass;\n            }\n        } catch (Exception $e) {\n            $message = __('Could not load module for path %s', $filepath);\n            $this->logException($message, $e);\n            return $message;\n        }\n    }\n\n    public function getModuleLoadingError(): array\n    {\n        return $this->error_while_loading;\n    }\n\n    public function getModulesByType($module_type=false): array\n    {\n        $this->loadAllWorkflowModules();\n\n        $modules_trigger = $this->loaded_modules['trigger'];\n        $modules_logic = $this->loaded_modules['logic'];\n        $modules_action = $this->loaded_modules['action'];\n\n        $this->__sortModulesByName($modules_trigger);\n        $this->__sortModulesByName($modules_logic);\n        $this->__sortModulesByName($modules_action);\n        $modules_trigger = array_values($modules_trigger);\n        $modules_logic = array_values($modules_logic);\n        $modules_action = array_values($modules_action);\n        $modules = [\n            'modules_trigger' => $modules_trigger,\n            'modules_logic' => $modules_logic,\n            'modules_action' => $modules_action,\n        ];\n        if (!empty($module_type)) {\n            if (!empty($modules['modules_' . $module_type])) {\n                return $modules['modules_' . $module_type];\n            } else {\n                return [];\n            }\n        }\n        return $modules;\n    }\n\n    private function __sortModulesByName(&$modules)\n    {\n        uasort($modules, function ($module1, $module2) {\n            if ($module1['name'] == $module2['name']) {\n                return 0;\n            }\n            return ($module1['name'] < $module2['name']) ? -1 : 1;\n        });\n    }\n\n    public function getModules(): array\n    {\n        $modulesByType = $this->getModulesByType();\n        return array_merge($modulesByType['modules_trigger'], $modulesByType['modules_logic'], $modulesByType['modules_action']);\n    }\n\n    /**\n     * getModules Return the module from the provided ID\n     *\n     * @param string|array $module_ids\n     * @return array\n     */\n    public function getModuleByID($module_ids): array\n    {\n        $returnAString = false;\n        if (!is_array($module_ids)) {\n            $returnAString = true;\n            $module_ids = [$module_ids];\n        }\n        $matchingModules = [];\n        $modules = $this->getModules();\n        foreach ($modules as $module) {\n            if (in_array($module['id'], $module_ids)) {\n                $matchingModules[] = $module;\n            }\n        }\n        if (empty($matchingModules)) {\n            return [];\n        }\n        return $returnAString ? $matchingModules[0] : $matchingModules;\n    }\n\n    private function __incrementWorkflowExecutionCount(array $workflow): array\n    {\n        $workflow['Workflow']['counter'] = intval($workflow['Workflow']['counter']) + 1;\n        $this->save($workflow, ['fieldList' => ['counter']]);\n        return $this->fetchWorkflow($workflow['Workflow']['id']);\n    }\n\n    /**\n     * fetchWorkflows\n     *\n     * @param  array $options\n     * @param  bool  $full\n     * @return array\n     */\n    public function fetchWorkflows(array $options = array(), $full = false)\n    {\n        $params = array(\n            'contain' => $this->defaultContain,\n            'recursive' => -1\n        );\n        if ($full) {\n            $params['recursive'] = 1;\n        }\n        if (isset($options['fields'])) {\n            $params['fields'] = $options['fields'];\n        }\n        if (isset($options['conditions'])) {\n            $params['conditions']['AND'][] = $options['conditions'];\n        }\n        if (isset($options['group'])) {\n            $params['group'] = !empty($options['group']) ? $options['group'] : false;\n        }\n        if (isset($options['contain'])) {\n            $params['contain'] = !empty($options['contain']) ? $options['contain'] : [];\n        }\n        if (isset($options['order'])) {\n            $params['order'] = !empty($options['order']) ? $options['order'] : [];\n        }\n        $workflows = $this->find('all', $params);\n        return $workflows;\n    }\n\n    /**\n     * fetchWorkflow\n     *\n     * @param  int|string $id\n     * @param  bool $throwErrors\n     * @throws NotFoundException\n     * @return array\n     */\n    public function fetchWorkflow($id, bool $throwErrors = true): array\n    {\n        $options = [];\n        if (is_numeric($id)) {\n            $options = ['conditions' => ['Workflow.id' => $id]];\n        } elseif (Validation::uuid($id)) {\n            $options = ['conditions' => ['Workflow.uuid' => $id]];\n        } else {\n            if ($throwErrors) {\n                throw new NotFoundException(__('Invalid workflow'));\n            }\n            return [];\n        }\n        $workflow = $this->fetchWorkflows($options);\n        if (empty($workflow)) {\n            if ($throwErrors) {\n                throw new NotFoundException(__('Invalid workflow'));\n            }\n            return [];\n        }\n        return $workflow[0];\n    }\n\n    /**\n     * fetchWorkflowByTrigger\n     *\n     * @param  int|string $trigger_id\n     * @param  bool $throwErrors\n     * @throws NotFoundException\n     * @return array\n     */\n    public function fetchWorkflowByTrigger($trigger_id, bool $throwErrors = true): array\n    {\n        $options = [\n            'conditions' => [\n                'Workflow.trigger_id' => $trigger_id,\n            ]\n        ];\n        $workflow = $this->fetchWorkflows($options);\n        if (empty($workflow)) {\n            if ($throwErrors) {\n                throw new NotFoundException(__('Invalid workflow'));\n            }\n            return [];\n        }\n        return $workflow[0];\n    }\n\n    /**\n     * addWorkflow Add a worflow\n     *\n     * @param  array $trigger\n     * @return array Any errors preventing the edition\n     */\n    public function addWorkflow(array $workflow): array\n    {\n        $errors = [];\n        $this->create();\n        $saved = $this->__saveAndReturnErrors($workflow, ['fieldList' => self::CAPTURE_FIELDS_ADD], $errors);\n        return [\n            'saved' => $saved,\n            'errors' => $errors,\n        ];\n    }\n\n    /**\n     * editWorkflow Edit a worflow\n     *\n     * @param  array $workflow\n     * @return array Any errors preventing the edition\n     */\n    public function editWorkflow(array $workflow): array\n    {\n        $errors = [];\n        if (!isset($workflow['Workflow']['uuid'])) {\n            $errors[] = __('Workflow doesn\\'t have an UUID');\n            return $errors;\n        }\n        $existingWorkflow = $this->fetchWorkflow($workflow['Workflow']['id']);\n        $workflow['Workflow']['id'] = $existingWorkflow['Workflow']['id'];\n        unset($workflow['Workflow']['timestamp']);\n        $saved = $this->__saveAndReturnErrors($workflow, ['fieldList' => self::CAPTURE_FIELDS_EDIT], $errors);\n        return [\n            'saved' => $saved,\n            'errors' => $errors,\n        ];\n    }\n\n    /**\n     * genGraphDataForTrigger Generate fake graph data under the drawflow format\n     *\n     * @param string $trigger_id\n     * @return array\n     */\n    public function genGraphDataForTrigger($trigger_id): array\n    {\n        if (empty($this->loaded_modules['trigger'][$trigger_id])) {\n            throw new TriggerNotFoundException(__('Unknown trigger `%s`', $trigger_id));\n        }\n        $module_config = $this->loaded_modules['trigger'][$trigger_id];\n        $data = [\n            1 => [\n                'class' => 'block-type-trigger',\n                'data' => $module_config,\n                'id' => 1,\n                'inputs' => [],\n                'outputs' => [\n                    'output_1' => [\n                        'connections' => []\n                    ],\n                ],\n                'pos_x' => 0,\n                'pos_y' => 0,\n                'typenode' => false,\n            ]\n        ];\n        return $data;\n    }\n\n    /**\n     * moduleSattelesExecution Executes a module using the provided configuration and returns back the result\n     *\n     * @param string $module_id\n     * @param string|array $input_data\n     * @param array $param_data\n     * @return array\n     */\n    public function moduleStatelessExecution(string $module_id, $input_data=[], array $param_data=[], bool $convert_data=true): array\n    {\n        $result = [];\n        $input_data = !empty($input_data) ? $input_data : [];\n        $data = $input_data;\n        if (!empty($convert_data)) {\n            $eventPublishTrigger = $this->getModuleClassByType('trigger', 'event-publish');\n            $data = $this->__normalizeDataForTrigger($eventPublishTrigger, $input_data);\n        }\n        $module_config = $this->getModuleByID($module_id);\n        $node = $this->genNodeFromConfig($module_config, $param_data);\n        $module_class = $this->getModuleClass($node);\n        $user_for_workflow = $this->getUserForWorkflow();\n        if (empty($user_for_workflow)) {\n            $result['error'][] = __('Could not find a valid user to run the workflow. Please set setting `MISP.host_org_id` or make sure a valid site_admin user exists.');\n            return $result;\n        }\n        $roaming_data = $this->workflowGraphTool->getRoamingData($user_for_workflow, $data);\n        $errors = [];\n        $success = $module_class->exec($node, $roaming_data, $errors);\n        $result['success'] = $success;\n        $result['errors'] = $errors;\n        return $result;\n    }\n\n    public function genNodeFromConfig(array $module_config, $indexed_params): array\n    {\n        $node = [\n            'id' => 1,\n            'name' => $module_config['name'],\n            'data' => [\n                'id' => $module_config['id'],\n                'name' => $module_config['name'],\n                'module_type' => $module_config['module_type'],\n                'module_version' => $module_config['version'],\n                'indexed_params' => $indexed_params,\n                'saved_filters' => $module_config['saved_filters'],\n                'module_data' => $module_config,\n            ],\n            'inputs' => [],\n            'outputs' => [],\n        ];\n        return $node;\n    }\n\n    /**\n     * hasPathWarnings\n     *\n     * @param array $graphData\n     * @param array $edges\n     * @return boolean\n     */\n    public function hasPathWarnings(array $graphData, array &$edges=[])\n    {\n        $startNodes = $this->workflowGraphTool->extractConcurrentTasksFromWorkflow($graphData, true);\n        $concurrentNodeIDs = Hash::extract($startNodes, '{n}.id');\n        $roamingData = $this->workflowGraphTool->getRoamingData();\n        foreach ($concurrentNodeIDs as $concurrentNodeID) {\n            $graphWalker = $this->workflowGraphTool->getWalkerIterator($graphData, $this, $concurrentNodeID, GraphWalker::PATH_TYPE_INCLUDE_LOGIC, $roamingData);\n            foreach ($graphWalker as $graphNode) {\n                $moduleClass = $this->getModuleClass($graphNode['node']);\n                if (!empty($moduleClass->blocking)) {\n                    $parsedPathList = GraphWalker::parsePathList($graphNode['path_list']);\n                    foreach ($parsedPathList as $pathEntry) {\n                        $edges[] = [\n                            $pathEntry['source_id'],\n                            $pathEntry['next_node_id'],\n                            __('This path leads to a blocking node from a non-blocking context'),\n                            $moduleClass->blocking,\n                            $moduleClass->id,\n                            $graphNode['node']['id'],\n                        ];\n                    }\n                }\n            }\n        }\n        return !empty($edges);\n    }\n\n    private function __saveAndReturnErrors($data, $saveOptions = [], &$errors = [])\n    {\n        $saveSuccess = $this->save($data, $saveOptions);\n        if (!$saveSuccess) {\n            foreach ($this->validationErrors as $validationError) {\n                $errors[] = $validationError[0];\n            }\n        } else {\n            if (!empty($saveSuccess['Workflow']['data'])) {\n                $saveSuccess['Workflow']['data'] = JsonTool::decode($saveSuccess['Workflow']['data']);\n            }\n        }\n        return $saveSuccess;\n    }\n\n    public function sendRequestToDebugEndpoint(array $workflow, array $node, $path='/', array $data=[])\n    {\n        $debug_url = Configure::read('Plugin.Workflow_debug_url');\n        if (empty($workflow['Workflow']['debug_enabled'])) {\n            return;\n        }\n        App::uses('HttpSocket', 'Network/Http');\n        $socket = new HttpSocket([\n            'timeout' => 5\n        ]);\n        $uri = sprintf('%s/%s%s', $debug_url, $workflow['Workflow']['trigger_id'], $path);\n        $dataToPost = [\n            'source' => [\n                'node_id' => $node['id'] ?? '',\n                'module_id' => $node['data']['id'] ?? '',\n                'filters' => $node['data']['saved_filters'] ?? '',\n                'parameters' => $node['data']['indexed_params'] ?? '',\n            ],\n            'timestamp' => date(\"c\"),\n            'data' => $data,\n        ];\n        $socket->post($uri, JsonTool::encode($dataToPost));\n    }\n    \n    public function getDotNotation($id)\n    {\n        App::uses('GraphvizDOTTool', 'Tools');\n        $workflow = $this->fetchWorkflow($id);\n        $dot = GraphvizDOTTool::dot($workflow['Workflow']['data']);\n        return $dot;\n    }\n    \n    public function getMermaid($id)\n    {\n        App::uses('MermaidFlowchartTool', 'Tools');\n        $workflow = $this->fetchWorkflow($id);\n        $mermaid = MermaidFlowchartTool::mermaid($workflow['Workflow']['data']);\n        return $mermaid;\n    }\n}\n", "<?php\n\n/**\n * Logs saves and deletes of any model\n *\n * Requires the following to work as intended :\n *\n * - \"Log\" model ( empty but for a order variable [created DESC]\n * - \"logs\" table with these fields required :\n * - id\t\t\t[int]\t\t\t:\n * - title\t\t[string]\t\t: automagically filled with the display field of the model that was modified.\n * - created\t[date/datetime] : filled by cake in normal way\n *\n * - actsAs = array(\"Logable\"); on models that should be logged\n *\n * Optional extra table fields for the \"logs\" table :\n *\n * - \"description\"\t[string] : Fill with a descriptive text of what, who and to which model/row :\n * \"Contact \"John Smith\"(34) added by User \"Administrator\"(1).\n *\n * or if u want more detail, add any combination of the following :\n *\n * - \"model\"    \t[string] : automagically filled with the class name of the model that generated the activity.\n * - \"model_id\"\t[int]\t: automagically filled with the primary key of the model that was modified.\n * - \"action\"   \t[string] : automagically filled with what action is made (add/edit/delete)\n * - \"user_id\"  \t[int]    : populated with the supplied user info. (May be renamed. See bellow.)\n * - \"change\"   \t[string] : depending on setting either :\n * [name (alek) => (Alek), age (28) => (29)] or [name, age]\n *\n * - \"version_id\"\t[int]\t: cooperates with RevisionBehavior to link the shadow table (thus linking to old data)\n *\n * Remember that Logable behavior needs to be added after RevisionBehavior. In fact, just put it last to be safe.\n *\n * Optionally register what user was responsible for the activity :\n *\n * - Supply configuration only if defaults are wrong. Example given with defaults :\n *\n * class Apple extends AppModel {\n * var $name = 'Apple';\n * var $actsAs = array('Logable' => array('userModel' => 'User', 'userKey' => 'user_id'));\n * [..]\n *\n * - In AppController (or single controller if only needed once) add these lines to beforeFilter :\n *\n * if (sizeof($this->uses) && $this->{$this->modelClass}->Behaviors->attached('Logable')) {\n * $this->{$this->modelClass}->setUserData($this->activeUser);\n * }\n *\n * This is not used any longer, as AuthComponent collect the user data instead.\n *\n * Where \"$activeUser\" should be an array in the standard format for the User model used :\n *\n * $activeUser = array( $UserModel->alias => array( $UserModel->primaryKey => 123, $UserModel->displayField => 'Alexander'));\n * // any other key is just ignored by this behaviour.\n *\n * @author Alexander Morland (alexander#maritimecolours.no)\n * @co-author Eskil Mjelva Saatvedt\n * @co-author Ronny Vindenes\n * @co-author Carl Erik Fyllingen\n * @contributor Miha\n * @category Behavior\n * @version 2.3\n * @modified 15.november 2011 by Eskil\n */\n\nclass LogableBehavior extends ModelBehavior {\n\n\tpublic $user = NULL;\n\n\tpublic $UserModel = false;\n\n\tpublic $settings = array();\n\n\tpublic $defaults = array(\n\t\t\t'enabled' => true,\n\t\t\t'userModel' => 'User',\n\t\t\t'userKey' => 'user_id',\n\t\t\t'change' => 'list',\n\t\t\t'description_ids' => true,\n\t\t\t'skip' => array(),\n\t\t\t'ignore' => array(),\n\t\t\t'classField' => 'model',\n\t\t\t'foreignKey' => 'model_id');\n\n\tpublic $schema = array();\n\n\t/**\n\t * Cake called intializer\n\t * Config options are :\n\t * userModel\t\t: 'User'. Class name of the user model you want to use (User by default), if you want to save User in log\n\t * userKey   \t\t: 'user_id'. The field for saving the user to (user_id by default).\n\t * change    \t\t: 'list' > [name, age]. Set to 'full' for [name (alek) => (Alek), age (28) => (29)]\n\t * description_ids\t: true. Set to false to not include model id and user id in the title field\n\t * skip  \t\t\t: array(). String array of actions to not log\n\t *\n\t * @param Object $Model\n\t * @param array $config\n\t */\n\tfunction setup(Model $Model, $config = array()) {\n\n\t\tif (!is_array($config)) {\n\t\t\t$config = array();\n\t\t}\n\t\t$this->settings[$Model->alias] = array_merge($this->defaults, $config);\n\t\t$this->settings[$Model->alias]['ignore'][] = $Model->primaryKey;\n\n\t\t$this->Log = ClassRegistry::init('Log');\n\t\tif ($this->settings[$Model->alias]['userModel'] != $Model->alias) {\n\t\t\t$this->UserModel = ClassRegistry::init($this->settings[$Model->alias]['userModel']);\n\t\t} else {\n\t\t\t$this->UserModel = $Model;\n\t\t}\n\t\t$this->schema = $this->Log->schema();\n\t\tApp::uses('AuthComponent', 'Controller/Component');\n\t\t$this->user[$this->settings[$Model->alias]['userModel']] = AuthComponent::user();\n\t}\n\n\tfunction settings(&$Model) {\n\n\t\treturn $this->settings[$Model->alias];\n\t}\n\n\tfunction enableLog(&$Model, $enable = null) {\n\n\t\tif ($enable !== null) {\n\t\t\t$this->settings[$Model->alias]['enabled'] = $enable;\n\t\t}\n\t\treturn $this->settings[$Model->alias]['enabled'];\n\t}\n\n\t/**\n\t * Useful for getting logs for a model, takes params to narrow find.\n\t * This method can actually also be used to find logs for all models or\n\t * even another model. Using no params will return all activities for\n\t * the models it is called from.\n\t *\n\t * Possible params :\n\t * 'model'\t\t: mixed  (NULL) String with className, NULL to get current or false to get everything\n\t * 'action'\t: string (NULL) String with action (add/edit/delete), NULL gets all\n\t * 'order'\t\t: string ('created DESC') String with custom order\n\t * 'conditions  : array  (array()) Add custom conditions\n\t * 'model_id'\t: int\t (NULL) Add a int\n\t *\n\t * (remember to use your own user key if you're not using 'user_id')\n\t * 'user_id'\t: int\t (NULL) Defaults to all users, supply id if you want for only one User\n\t *\n\t * @param Object $Model\n\t * @param array $params\n\t * @return array\n\t */\n\tfunction findLog(&$Model, $params = array()) {\n\n\t\t$defaults = array(\n\t\t\t\t$this->settings[$Model->alias]['classField'] => NULL,\n\t\t\t\t'action' => NULL,\n\t\t\t\t'order' => 'created DESC',\n\t\t\t\t$this->settings[$Model->alias]['userKey'] => NULL,\n\t\t\t\t'conditions' => array(),\n\t\t\t\t$this->settings[$Model->alias]['foreignKey'] => NULL,\n\t\t\t\t'fields' => array(),\n\t\t\t\t'limit' => 50);\n\t\t$params = array_merge($defaults, $params);\n\t\t$options = array(\n\t\t\t\t'order' => $params['order'],\n\t\t\t\t'conditions' => $params['conditions'],\n\t\t\t\t'fields' => $params['fields'],\n\t\t\t\t'limit' => $params['limit']);\n\t\tif ($params[$this->settings[$Model->alias]['classField']] === NULL) {\n\t\t\t$params[$this->settings[$Model->alias]['classField']] = $Model->alias;\n\t\t}\n\t\tif ($params[$this->settings[$Model->alias]['classField']]) {\n\t\t\tif (isset($this->schema[$this->settings[$Model->alias]['classField']])) {\n\t\t\t\t$options['conditions'][$this->settings[$Model->alias]['classField']] = $params[$this->settings[$Model->alias]['classField']];\n\t\t\t} else if (isset($this->schema['description'])) {\n\t\t\t\t$options['conditions']['description LIKE '] = $params[$this->settings[$Model->alias]['classField']] . '%';\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif ($params['action'] && isset($this->schema['action'])) {\n\t\t\t$options['conditions']['action'] = $params['action'];\n\t\t}\n\t\tif ($params[$this->settings[$Model->alias]['userKey']] && $this->UserModel && is_numeric($params[$this->settings[$Model->alias]['userKey']])) {\n\t\t\t$options['conditions'][$this->settings[$Model->alias]['userKey']] = $params[$this->settings[$Model->alias]['userKey']];\n\t\t}\n\t\tif ($params[$this->settings[$Model->alias]['foreignKey']] && is_numeric($params[$this->settings[$Model->alias]['foreignKey']])) {\n\t\t\t$options['conditions'][$this->settings[$Model->alias]['foreignKey']] = $params[$this->settings[$Model->alias]['foreignKey']];\n\t\t}\n\t\treturn $this->Log->find('all', $options);\n\t}\n\n\t/**\n\t * Get list of actions for one user.\n\t * Params for getting (one line) activity descriptions\n\t * and/or for just one model\n\t *\n\t * @example $this->Model->findUserActions(301,array('model' => 'BookTest'));\n\t * @example $this->Model->findUserActions(301,array('events' => true));\n\t * @example $this->Model->findUserActions(301,array('fields' => array('id','model'),'model' => 'BookTest');\n\t * @param Object $Model\n\t * @param int $user_id\n\t * @param array $params\n\t * @return array\n\t */\n\tfunction findUserActions(&$Model, $user_id, $params = array()) {\n\n\t\tif (!$this->UserModel) {\n\t\t\treturn NULL;\n\t\t}\n\t\t// if logged in user is asking for her own log, use the data we already have\n\t\tif (isset($this->user) && isset($this->user[$this->UserModel->alias][$this->UserModel->primaryKey]) && $user_id == $this->user[$this->UserModel->alias][$this->UserModel->primaryKey] && isset($this->user[$this->UserModel->alias][$this->UserModel->displayField])) {\n\t\t\t$username = $this->user[$this->UserModel->alias][$this->UserModel->displayField];\n\t\t} else {\n\t\t\t$this->UserModel->recursive = -1;\n\t\t\t$user = $this->UserModel->find(array(\n\t\t\t\t\t$this->UserModel->primaryKey => $user_id));\n\t\t\t$username = $user[$this->UserModel->alias][$this->UserModel->displayField];\n\t\t}\n\t\t$fields = array();\n\t\tif (isset($params['fields'])) {\n\t\t\tif (is_array($params['fields'])) {\n\t\t\t\t$fields = $params['fields'];\n\t\t\t} else {\n\t\t\t\t$fields = array(\n\t\t\t\t\t\t$params['fields']);\n\t\t\t}\n\t\t}\n\t\t$conditions = array(\n\t\t\t\t$this->settings[$Model->alias]['userKey'] => $user_id);\n\t\tif (isset($params[$this->settings[$Model->alias]['classField']])) {\n\t\t\t$conditions[$this->settings[$Model->alias]['classField']] = $params[$this->settings[$Model->alias]['classField']];\n\t\t}\n\t\t$data = $this->Log->find('all', array(\n\t\t\t\t'conditions' => $conditions,\n\t\t\t\t'recursive' => -1,\n\t\t\t\t'fields' => $fields));\n\t\tif (!isset($params['events']) || ( isset($params['events']) && $params['events'] == false )) {\n\t\t\treturn $data;\n\t\t}\n\t\t$result = array();\n\t\tforeach ( $data as $key => $row ) {\n\t\t\t$one = $row['Log'];\n\t\t\t$result[$key]['Log']['id'] = $one['id'];\n\t\t\t$result[$key]['Log']['event'] = $username;\n\t\t\t// have all the detail models and change as list :\n\t\t\tif (isset($one[$this->settings[$Model->alias]['classField']]) && isset($one['action']) && isset($one['change']) && isset($one[$this->settings[$Model->alias]['foreignKey']])) {\n\t\t\t\tif ($one['action'] == 'edit') {\n\t\t\t\t\t$result[$key]['Log']['event'] .= ' edited ' . $one['change'] . ' of ' . low($one[$this->settings[$Model->alias]['classField']]) . '(id ' . $one[$this->settings[$Model->alias]['foreignKey']] . ')';\n\n\t\t//\t' at '.$one['created'];\n\t\t\t\t} else if ($one['action'] == 'add') {\n\t\t\t\t\t$result[$key]['Log']['event'] .= ' added a ' . low($one[$this->settings[$Model->alias]['classField']]) . '(id ' . $one[$this->settings[$Model->alias]['foreignKey']] . ')';\n\t\t\t\t} else if ($one['action'] == 'delete') {\n\t\t\t\t\t$result[$key]['Log']['event'] .= ' deleted the ' . low($one[$this->settings[$Model->alias]['classField']]) . '(id ' . $one[$this->settings[$Model->alias]['foreignKey']] . ')';\n\t\t\t\t}\n\n\t\t\t} else if (isset($one[$this->settings[$Model->alias]['classField']]) && isset($one['action']) && isset($one[$this->settings[$Model->alias]['foreignKey']])) { // have model,model_id and action\n\t\t\t\tif ($one['action'] == 'edit') {\n\t\t\t\t\t$result[$key]['Log']['event'] .= ' edited ' . low($one[$this->settings[$Model->alias]['classField']]) . '(id ' . $one[$this->settings[$Model->alias]['foreignKey']] . ')';\n\n\t\t//\t' at '.$one['created'];\n\t\t\t\t} else if ($one['action'] == 'add') {\n\t\t\t\t\t$result[$key]['Log']['event'] .= ' added a ' . low($one[$this->settings[$Model->alias]['classField']]) . '(id ' . $one[$this->settings[$Model->alias]['foreignKey']] . ')';\n\t\t\t\t} else if ($one['action'] == 'delete') {\n\t\t\t\t\t$result[$key]['Log']['event'] .= ' deleted the ' . low($one[$this->settings[$Model->alias]['classField']]) . '(id ' . $one[$this->settings[$Model->alias]['foreignKey']] . ')';\n\t\t\t\t}\n\t\t\t} else { // only description field exist\n\t\t\t\t$result[$key]['Log']['event'] = $one['description'];\n\t\t\t}\n\n\t\t}\n\t\treturn $result;\n\t}\n\n\t/**\n\t * Use this to supply a model with the data of the logged in User.\n\t * Intended to be called in AppController::beforeFilter like this :\n\t *\n\t * if ($this->{$this->modelClass}->Behaviors->attached('Logable')) {\n\t * $this->{$this->modelClass}->setUserData($activeUser);/\n\t * }\n\t *\n\t * The $userData array is expected to look like the result of a\n\t * User::find(array('id'=>123));\n\t *\n\t * @param Object $Model\n\t * @param array $userData\n\t */\n\tfunction setUserData(&$Model, $userData = null) {\n\n\t\tif ($userData) {\n\t\t\t$this->user = $userData;\n\t\t}\n\t}\n\n\t/**\n\t * Used for logging custom actions that arent crud, like login or download.\n\t *\n\t * @example $this->Boat->customLog('ship', 66, array('title' => 'Titanic heads out'));\n\t * @param Object $Model\n\t * @param string $action name of action that is taking place (dont use the crud ones)\n\t * @param int $id  id of the logged item (ie model_id in logs table)\n\t * @param array $values optional other values for your logs table\n\t */\n\tfunction customLog(Model $Model, $action, $id, $values = array()) {\n\n\t\t$logData['Log'] = $values;\n\t\t/** @todo clean up $logData */\n\t\tif (isset($this->schema[$this->settings[$Model->alias]['foreignKey']]) && is_numeric($id)) {\n\t\t\t$logData['Log'][$this->settings[$Model->alias]['foreignKey']] = $id;\n\t\t}\n\t\t$title = NULL;\n\t\tif (isset($values['title'])) {\n\t\t\t$title = $values['title'];\n\t\t\tunset($logData['Log']['title']);\n\t\t}\n\t\t$logData['Log']['action'] = $action;\n\t\t$this->_saveLog($Model, $logData, $title);\n\t}\n\n\tfunction clearUserData(Model $Model) {\n\n\t\t$this->user = NULL;\n\t}\n\n\tfunction setUserIp(&$Model, $userIP = null) {\n\n\t\t$this->userIP = $userIP;\n\t}\n\n\tfunction beforeDelete(Model $Model, $cascade = true) {\n\n\t\tif (!$this->settings[$Model->alias]['enabled']) {\n\t\t\treturn true;\n\t\t}\n\t\tif (isset($this->settings[$Model->alias]['skip']['delete']) && $this->settings[$Model->alias]['skip']['delete']) {\n\t\t\treturn true;\n\t\t}\n\t\t$Model->recursive = -1;\n\t\t$Model->read();\n\t\treturn true;\n\t}\n\n\tfunction afterDelete(Model $Model) {\n\n\t\tif (!$this->settings[$Model->alias]['enabled']) {\n\t\t\treturn true;\n\t\t}\n\t\tif (isset($this->settings[$Model->alias]['skip']['delete']) && $this->settings[$Model->alias]['skip']['delete']) {\n\t\t\treturn true;\n\t\t}\n\t\t$logData = array();\n\t\tif (isset($this->schema['description'])) {\n\t\t\t$logData['Log']['description'] = $Model->alias;\n\t\t\tif (isset($Model->data[$Model->alias][$Model->displayField]) && $Model->displayField != $Model->primaryKey) {\n\t\t\t\t$logData['Log']['description'] .= ' \"' . $Model->data[$Model->alias][$Model->displayField] . '\"';\n\t\t\t}\n\t\t\tif ($this->settings[$Model->alias]['description_ids']) {\n\t\t\t\t$logData['Log']['description'] .= ' (' . $Model->id . ') ';\n\t\t\t}\n\t\t\t$logData['Log']['description'] .= __('deleted', true);\n\t\t}\n\t\t$logData['Log']['action'] = 'delete';\n\t\t$this->_saveLog($Model, $logData);\n\t}\n\n\tfunction beforeSave(Model $Model, $options = array()) {\n\n\t\tif (isset($this->schema['change']) && $Model->id) {\n\t\t\t$this->old = $Model->find('first', array(\n\t\t\t\t\t'conditions' => array(\n\t\t\t\t\t\t\t$Model->alias . '.' . $Model->primaryKey => $Model->id),\n\t\t\t\t\t'recursive' => -1));\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction afterSave(Model $Model, $created, $options = array()) {\n\n\t\tif (!$this->settings[$Model->alias]['enabled']) {\n\t\t\treturn true;\n\t\t}\n\t\tif (isset($this->settings[$Model->alias]['skip']['add']) && $this->settings[$Model->alias]['skip']['add'] && $created) {\n\t\t\treturn true;\n\t\t} else if (isset($this->settings[$Model->alias]['skip']['edit']) && $this->settings[$Model->alias]['skip']['edit'] && !$created) {\n\t\t\treturn true;\n\t\t}\n\t\t$keys = array_keys($Model->data[$Model->alias]);\n\t\t$diff = array_diff($keys, $this->settings[$Model->alias]['ignore']);\n\t\tif (sizeof($diff) == 0 && empty($Model->logableAction)) {\n\t\t\treturn false;\n\t\t}\n\t\tif ($Model->id) {\n\t\t\t$id = $Model->id;\n\t\t} else if ($Model->insertId) {\n\t\t\t$id = $Model->insertId;\n\t\t}\n\t\tif (isset($this->schema[$this->settings[$Model->alias]['foreignKey']])) {\n\t\t\t$logData['Log'][$this->settings[$Model->alias]['foreignKey']] = $id;\n\t\t}\n\t\tif (isset($this->schema['description'])) {\n\t\t\t$logData['Log']['description'] = $Model->alias . ' ';\n\t\t\tif (isset($Model->data[$Model->alias][$Model->displayField]) && $Model->displayField != $Model->primaryKey) {\n\t\t\t\t$logData['Log']['description'] .= '\"' . $Model->data[$Model->alias][$Model->displayField] . '\" ';\n\t\t\t}\n\n\t\t\tif ($this->settings[$Model->alias]['description_ids']) {\n\t\t\t\t$logData['Log']['description'] .= '(' . $id . ') ';\n\t\t\t}\n\n\t\t\tif ($created) {\n\t\t\t\t$logData['Log']['description'] .= __('added', true);\n\t\t\t} else {\n\t\t\t\t$logData['Log']['description'] .= __('updated', true);\n\t\t\t}\n\t\t}\n\t\tif (isset($this->schema['action'])) {\n\t\t\tif ($created) {\n\t\t\t\t$logData['Log']['action'] = 'add';\n\t\t\t} else {\n\t\t\t\t$logData['Log']['action'] = 'edit';\n\t\t\t}\n\n\t\t}\n\t\tif (isset($this->schema['change'])) {\n\t\t\t$logData['Log']['change'] = '';\n\t\t\t$db_fields = array_keys($Model->schema());\n\t\t\t$changed_fields = array();\n\t\t\tforeach ( $Model->data[$Model->alias] as $key => $value ) {\n\t\t\t\tif (isset($Model->data[$Model->alias][$Model->primaryKey]) && !empty($this->old) && isset($this->old[$Model->alias][$key])) {\n\t\t\t\t\t$old = $this->old[$Model->alias][$key];\n\t\t\t\t} else {\n\t\t\t\t\t$old = '';\n\t\t\t\t}\n\t\t\t\tif ($key != 'modified' && !in_array($key, $this->settings[$Model->alias]['ignore']) && $value != $old && in_array($key, $db_fields)) {\n\t\t\t\t    if ($key === 'authkey' && Configure::read('Security.do_not_log_authkeys')) {\n\t\t\t\t        $old = $value = '*****';\n                    }\n\n\t\t\t\t\tif ($this->settings[$Model->alias]['change'] == 'full') {\n\t\t\t\t\t\t$changed_fields[] = $key . ' (' . $old . ') => (' . $value . ')';\n\t\t\t\t\t} else if ($this->settings[$Model->alias]['change'] == 'serialize') {\n\t\t\t\t\t\t$changed_fields[$key] = array(\n\t\t\t\t\t\t\t\t'old' => $old,\n\t\t\t\t\t\t\t\t'value' => $value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$changed_fields[] = $key;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t$changes = sizeof($changed_fields);\n\t\t\tif ($changes == 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif ($this->settings[$Model->alias]['change'] == 'serialize') {\n\t\t\t\t$logData['Log']['change'] = serialize($changed_fields);\n\t\t\t} else {\n\t\t\t\t$logData['Log']['change'] = implode(', ', $changed_fields);\n\t\t\t}\n\t\t\t$logData['Log']['changes'] = $changes;\n\t\t}\n\t\t$this->_saveLog($Model, $logData);\n\t}\n\n\t/**\n\t * Does the actual saving of the Log model. Also adds the special field if possible.\n\t *\n\t * If model field in table, add the Model->alias\n\t * If action field is NOT in table, remove it from dataset\n\t * If the userKey field in table, add it to dataset\n\t * If userData is supplied to model, add it to the title\n\t *\n\t * @param Object $Model\n\t * @param array $logData\n\t */\n\tfunction _saveLog(&$Model, $logData, $title = null) {\n\n\t\tif ($title !== NULL) {\n\t\t\t$logData['Log']['title'] = $title;\n\t\t} else if ($Model->displayField == $Model->primaryKey) {\n\t\t\t$logData['Log']['title'] = $Model->alias . ' (' . $Model->id . ')';\n\t\t} else if (isset($Model->data[$Model->alias][$Model->displayField])) {\n\t\t\t$logData['Log']['title'] = $Model->data[$Model->alias][$Model->displayField];\n\t\t} else {\n\t\t\t$logData['Log']['title'] = $Model->field($Model->displayField);\n\t\t}\n\n\t\tif (isset($this->schema[$this->settings[$Model->alias]['classField']])) {\n\t\t\t// by miha nahtigal\n\t\t\t$logData['Log'][$this->settings[$Model->alias]['classField']] = $Model->name;\n\t\t}\n\n\t\tif (isset($this->schema[$this->settings[$Model->alias]['foreignKey']]) && !isset($logData['Log'][$this->settings[$Model->alias]['foreignKey']])) {\n\t\t\tif ($Model->id) {\n\t\t\t\t$logData['Log'][$this->settings[$Model->alias]['foreignKey']] = $Model->id;\n\t\t\t} else if ($Model->insertId) {\n\t\t\t\t$logData['Log'][$this->settings[$Model->alias]['foreignKey']] = $Model->insertId;\n\t\t\t}\n\t\t}\n\n\t\tif (!isset($this->schema['action'])) {\n\t\t\tunset($logData['Log']['action']);\n\t\t} else if (isset($Model->logableAction) && !empty($Model->logableAction)) {\n\t\t\t$logData['Log']['action'] = implode(',', $Model->logableAction); // . ' ' . $logData['Log']['action'];\n\t\t\tunset($Model->logableAction);\n\t\t}\n\n\t\tif (isset($this->schema['version_id']) && isset($Model->version_id)) {\n\t\t\t$logData['Log']['version_id'] = $Model->version_id;\n\t\t\tunset($Model->version_id);\n\t\t}\n\n\t\tif (isset($this->schema['ip']) && $this->userIP) {\n\t\t\t$logData['Log']['ip'] = $this->userIP;\n\t\t}\n\n\t\tif (isset($this->schema[$this->settings[$Model->alias]['userKey']]) && $this->user) {\n\t\t\t$logData['Log'][$this->settings[$Model->alias]['userKey']] = $this->user[$this->UserModel->alias][$this->UserModel->primaryKey];\n\t\t}\n\n\t\tif (isset($this->schema['description'])) {\n\t\t\tif ($this->user && $this->UserModel) {\n\t\t\t\t$logData['Log']['description'] .= ' by ' . $this->settings[$Model->alias]['userModel'] . ' \"' . $this->user[$this->UserModel->alias][$this->UserModel->displayField] . '\"';\n\t\t\t\tif ($this->settings[$Model->alias]['description_ids']) {\n\t\t\t\t\t$logData['Log']['description'] .= ' (' . $this->user[$this->UserModel->alias][$this->UserModel->primaryKey] . ')';\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// UserModel is active, but the data hasnt been set. Assume system action.\n\t\t\t\t$logData['Log']['description'] .= ' by System';\n\t\t\t}\n\t\t\t$logData['Log']['description'] .= '.';\n\t\t}\n\t\t$this->Log->create($logData);\n\t\t$this->Log->save(null, array(\n\t\t\t\t'validate' => false,\n\t\t\t\t'callbacks' => false));\n\t}\n}\n"], "fixing_code": ["<?php\nApp::uses('AppModel', 'Model');\nApp::uses('TmpFileTool', 'Tools');\n\n/**\n * @property Tag $Tag\n * @property Galaxy $Galaxy\n * @property GalaxyClusterRelation $GalaxyClusterRelation\n * @property GalaxyElement $GalaxyElement\n * @property SharingGroup $SharingGroup\n */\nclass GalaxyCluster extends AppModel\n{\n    public $useTable = 'galaxy_clusters';\n\n    public $recursive = -1;\n\n    public $actsAs = array(\n        'AuditLog',\n        'SysLogLogable.SysLogLogable' => array( // TODO Audit, logable\n            'userModel' => 'User',\n            'userKey' => 'user_id',\n            'change' => 'full'),\n        'Containable',\n    );\n\n    private $__assetCache = array();\n\n    public $validate = array(\n        'value' => array(\n            'stringNotEmpty' => array(\n                'rule' => array('stringNotEmpty')\n            )\n        ),\n        'uuid' => array(\n            'uuid' => array(\n                'rule' => 'uuid',\n                'message' => 'Please provide a valid RFC 4122 UUID'\n            ),\n            'unique' => array(\n                'rule' => 'isUnique',\n                'message' => 'The UUID provided is not unique',\n                'required' => 'create'\n            )\n        ),\n        'distribution' => array(\n            'rule' => array('inList', array('0', '1', '2', '3', '4')),\n            'message' => 'Options: Your organisation only, This community only, Connected communities, All communities, Sharing group',\n            'required' => true\n        ),\n        'published' => array(\n            'boolean' => array(\n                'rule' => array('boolean'),\n            ),\n        ),\n    );\n\n    public $belongsTo = array(\n        'Galaxy' => array(\n            'className' => 'Galaxy',\n            'foreignKey' => 'galaxy_id',\n        ),\n        'Tag' => array(\n            'foreignKey' => false,\n            'conditions' => array('GalaxyCluster.tag_name = Tag.name')\n        ),\n        'Org' => array(\n            'className' => 'Organisation',\n            'foreignKey' => 'org_id'\n        ),\n        'Orgc' => array(\n            'className' => 'Organisation',\n            'foreignKey' => 'orgc_id'\n        ),\n        'SharingGroup' => array(\n                'className' => 'SharingGroup',\n                'foreignKey' => 'sharing_group_id'\n        )\n    );\n\n    private $__clusterCache = array();\n    private $deletedClusterUUID;\n    public $bulkEntry = false;\n\n    public $hasMany = array(\n        'GalaxyElement' => array('dependent' => true),\n        'GalaxyClusterRelation' => array(\n            'className' => 'GalaxyClusterRelation',\n            'foreignKey' => 'galaxy_cluster_id',\n            'dependent' => true,\n        ),\n        'TargetingClusterRelation' => array(\n            'className' => 'GalaxyClusterRelation',\n            'foreignKey' => 'referenced_galaxy_cluster_id',\n        ),\n    );\n\n    public $validFormats = array(\n        'json' => array('json', 'JsonExport', 'json'),\n    );\n\n    public function beforeValidate($options = array())\n    {\n        $cluster = &$this->data['GalaxyCluster'];\n        if (!isset($cluster['description'])) {\n            $cluster['description'] = '';\n        }\n        if (isset($cluster['distribution']) && $cluster['distribution'] != 4) {\n            $cluster['sharing_group_id'] = null;\n        }\n        if (!isset($cluster['published'])) {\n            $cluster['published'] = false;\n        }\n        if (!isset($cluster['authors'])) {\n            $cluster['authors'] = '';\n        } elseif (is_array($cluster['authors'])) {\n            $cluster['authors'] = JsonTool::encode($cluster['authors']);\n        }\n        return true;\n    }\n\n    public function afterFind($results, $primary = false)\n    {\n        foreach ($results as $k => $result) {\n            if (isset($result[$this->alias]['authors'])) {\n                $results[$k][$this->alias]['authors'] = json_decode($result[$this->alias]['authors'], true);\n            }\n            if (isset($result[$this->alias]['distribution']) && $result[$this->alias]['distribution'] != 4) {\n                unset($results[$k]['SharingGroup']);\n            }\n            if (isset($result[$this->alias]['org_id']) && $result[$this->alias]['org_id'] == 0) {\n                if (isset($results[$k]['Org'])) {\n                    $results[$k]['Org'] = Organisation::GENERIC_MISP_ORGANISATION;\n                }\n            }\n            if (isset($result[$this->alias]['orgc_id']) && $result[$this->alias]['orgc_id'] == 0) {\n                if (isset($results[$k]['Orgc'])) {\n                    $results[$k]['Orgc'] = Organisation::GENERIC_MISP_ORGANISATION;\n                }\n            }\n\n            if (!empty($result['GalaxyClusterRelation'])) {\n                foreach ($result['GalaxyClusterRelation'] as $i => $relation) {\n                    if (isset($relation['distribution']) && $relation['distribution'] != 4) {\n                        unset($results[$k]['GalaxyClusterRelation'][$i]['SharingGroup']);\n                    }\n                }\n            }\n        }\n        return $results;\n    }\n\n    public function afterSave($created, $options = array())\n    {\n        // Update all relations IDs that are unknown but saved\n        if (!$this->bulkEntry) {\n            $cluster = $this->data[$this->alias];\n            $cluster = $this->fetchAndSetUUID($cluster);\n            $this->GalaxyClusterRelation->updateAll(\n                array('GalaxyClusterRelation.referenced_galaxy_cluster_id' => $cluster['id']),\n                array('GalaxyClusterRelation.referenced_galaxy_cluster_uuid' => $cluster['uuid'])\n            );\n        }\n    }\n\n    public function afterDelete()\n    {\n        // Remove all relations IDs now that the cluster is unknown\n        if (!empty($this->deletedClusterUUID)) {\n            $this->GalaxyClusterRelation->updateAll(\n                array('GalaxyClusterRelation.referenced_galaxy_cluster_id' => 0),\n                array('GalaxyClusterRelation.referenced_galaxy_cluster_uuid' => $this->deletedClusterUUID)\n            );\n            $this->GalaxyElement->deleteAll(array('GalaxyElement.galaxy_cluster_id' => $this->id));\n            $this->GalaxyClusterRelation->deleteAll(array('GalaxyClusterRelation.galaxy_cluster_uuid' => $this->deletedClusterUUID));\n        }\n    }\n\n    public function beforeDelete($cascade = true)\n    {\n        $cluster = $this->find('first', array(\n            'conditions' => array('id' => $this->id),\n            'fields' => array('uuid'),\n        ));\n        if (!empty($cluster)) {\n            $this->deletedClusterUUID = $cluster[$this->alias]['uuid'];\n        } else {\n            $this->deletedClusterUUID = null;\n        }\n    }\n\n    /**\n     * arrangeData Move linked data into the cluster model key\n     *\n     * @return array The arranged cluster\n     */\n    public function arrangeData($cluster)\n    {\n        $models = array('Galaxy', 'SharingGroup', 'GalaxyElement', 'GalaxyClusterRelation', 'Org', 'Orgc', 'TargetingClusterRelation');\n        foreach ($models as $model) {\n            if (isset($cluster[$model])) {\n                $cluster['GalaxyCluster'][$model] = $cluster[$model];\n                unset($cluster[$model]);\n            }\n        }\n        return $cluster;\n    }\n\n    public function generateMissingRelations()\n    {\n        $missingRelations = $this->GalaxyClusterRelation->find('column', [\n            'conditions' => ['referenced_galaxy_cluster_id' => 0],\n            'fields' => ['referenced_galaxy_cluster_uuid'],\n            'unique' => true,\n        ]);\n        if (empty($missingRelations)) {\n            return;\n        }\n        $ids = $this->find('list', [\n            'conditions' => ['uuid' => $missingRelations],\n            'fields' => ['uuid', 'id']\n        ]);\n        foreach ($ids as $uuid => $id) {\n            $this->GalaxyClusterRelation->updateAll(\n                ['referenced_galaxy_cluster_id' => $id],\n                ['referenced_galaxy_cluster_uuid' => $uuid]\n            );\n        }\n    }\n\n    public function fetchAndSetUUID($cluster)\n    {\n        if (!isset($cluster['uuid'])) {\n            $alias = $this->alias;\n            $tmp = $this->find('first', array(\n                'recursive' => -1,\n                'fields' => array(\"${alias}.id\", \"${alias}.uuid\"),\n                'conditions' => array(\"${alias}.id\" => $cluster['id'])\n            ));\n            $cluster['uuid'] = $tmp[$alias]['uuid'];\n        }\n        return $cluster;\n    }\n\n    /**\n     * saveCluster Respecting ACL saves a cluster, its elements, relations and set correct fields where applicable\n     *\n     * @param  array $user\n     * @param  array $cluster\n     * @param  bool $allowEdit redirects to the edit function\n     * @return array The errors if any\n     */\n    public function saveCluster(array $user, array $cluster, $allowEdit=false)\n    {\n        $errors = array();\n        if (!$user['Role']['perm_galaxy_editor'] && !$user['Role']['perm_site_admin']) {\n            $errors[] = __('Incorrect permission');\n            return $errors;\n        }\n        $galaxy = $this->Galaxy->find('first', array('conditions' => array(\n            'id' => $cluster['GalaxyCluster']['galaxy_id']\n        )));\n        if (empty($galaxy)) {\n            $errors[] = __('Galaxy not found');\n            return $errors;\n        } else {\n            $galaxy = $galaxy['Galaxy'];\n        }\n        unset($cluster['GalaxyCluster']['id']);\n        $cluster['GalaxyCluster']['locked'] = false;\n\n        if (isset($cluster['GalaxyCluster']['uuid'])) {\n            $this->GalaxyClusterBlocklist = ClassRegistry::init('GalaxyClusterBlocklist');\n            if ($this->GalaxyClusterBlocklist->checkIfBlocked($cluster['GalaxyCluster']['uuid'])) {\n                $errors[] = __('Blocked by blocklist');\n                return $errors;\n            }\n\n            // check if the uuid already exists\n            $existingGalaxyCluster = $this->find('first', array('conditions' => array('GalaxyCluster.uuid' => $cluster['GalaxyCluster']['uuid'])));\n            if ($existingGalaxyCluster) {\n                if ($existingGalaxyCluster['GalaxyCluster']['galaxy_id'] != $galaxy['id']) { // cluster already exists in another galaxy\n                    $errors[] = __('Cluster already exists in another galaxy');\n                    return $errors;\n                }\n                if (!$existingGalaxyCluster['GalaxyCluster']['default']) {\n                    $errors[] = __('Edit not allowed on default clusters');\n                    return $errors;\n                }\n                if (!$allowEdit) {\n                    $errors[] = __('Edit not allowed');\n                    return $errors;\n                }\n                $errors = $this->editCluster($user, $cluster);\n                return $errors;\n            }\n        } else {\n            $cluster['GalaxyCluster']['uuid'] = CakeText::uuid();\n        }\n        if (!isset($cluster['GalaxyCluster']['default'])) {\n            $cluster['GalaxyCluster']['default'] = false;\n        }\n        if (!isset($cluster['GalaxyCluster']['published'])) {\n            $cluster['GalaxyCluster']['published'] = false;\n        }\n        if (!isset($cluster['GalaxyCluster']['collection_uuid'])) {\n            $cluster['GalaxyCluster']['collection_uuid'] = '';\n        }\n        if (!empty($cluster['GalaxyCluster']['extends_uuid'])) {\n            $forkedCluster = $this->find('first', array('conditions' => array('GalaxyCluster.uuid' => $cluster['GalaxyCluster']['extends_uuid'])));\n            if (!empty($forkedCluster) && $forkedCluster['GalaxyCluster']['galaxy_id'] != $galaxy['id']) {\n                $errors[] = __('Cluster forks have to belong to the same galaxy as the parent');\n                return $errors;\n            }\n        } else {\n            $cluster['GalaxyCluster']['extends_version'] = null;\n        }\n        if (!isset($cluster['GalaxyCluster']['distribution'])) {\n            $cluster['GalaxyCluster']['distribution'] = Configure::read('MISP.default_event_distribution'); // use default event distribution\n        }\n        if ($cluster['GalaxyCluster']['distribution'] != 4) {\n            $cluster['GalaxyCluster']['sharing_group_id'] = null;\n        }\n\n        // In contrary to the capture context, we make sure the cluster belongs to the organisation initiating the save\n        $cluster['GalaxyCluster']['org_id'] = $user['Organisation']['id'];\n        $cluster['GalaxyCluster']['orgc_id'] = $user['Organisation']['id'];\n\n        if ($user['Role']['perm_sync']) {\n            if (isset($cluster['GalaxyCluster']['distribution']) && $cluster['GalaxyCluster']['distribution'] == 4 && !$this->SharingGroup->checkIfAuthorised($user, $cluster['GalaxyCluster']['sharing_group_id'])) {\n                $errors[] = __('The sync user has to have access to the sharing group in order to be able to edit it');\n                return $errors;\n            }\n        }\n\n        $cluster['GalaxyCluster']['type'] = $galaxy['type'];\n        if (!isset($cluster['GalaxyCluster']['version'])) {\n            $date = new DateTime();\n            $cluster['GalaxyCluster']['version'] = $date->getTimestamp();\n        }\n        $cluster['GalaxyCluster']['tag_name'] = sprintf('misp-galaxy:%s=\"%s\"', $galaxy['type'], $cluster['GalaxyCluster']['uuid']);\n        $this->create();\n        $saveSuccess = $this->save($cluster);\n        if ($saveSuccess) {\n            $savedCluster = $this->find('first', array(\n                'conditions' => array('id' =>  $this->id),\n                'recursive' => -1\n            ));\n\n            if (!empty($cluster['GalaxyCluster']['GalaxyElement'])) {\n                $elementsToSave = array();\n                foreach ($cluster['GalaxyCluster']['GalaxyElement'] as $element) { // transform cluster into Galaxy meta format\n                    $elementsToSave[$element['key']][] = $element['value'];\n                }\n                $this->GalaxyElement->updateElements(-1, $savedCluster['GalaxyCluster']['id'], $elementsToSave);\n            }\n            if (!empty($cluster['GalaxyCluster']['GalaxyClusterRelation'])) {\n                $this->GalaxyClusterRelation->saveRelations($user, $cluster['GalaxyCluster'], $cluster['GalaxyCluster']['GalaxyClusterRelation'], $captureTag=true);\n            }\n        } else {\n            foreach ($this->validationErrors as $validationError) {\n                $errors[] = $validationError[0];\n            }\n        }\n        return $errors;\n    }\n\n    /**\n     * editCluster Respecting ACL edits a cluster, its elements, relations and set correct fields where applicable\n     *\n     * @param  array $user\n     * @param  array $cluster\n     * @param  array $fieldList Only edit the fields provided\n     * @param  bool  $deleteOldElements Should already existing element be deleted or not\n     * @return array The errors if any\n     */\n    public function editCluster(array $user, array $cluster, array $fieldList = array(), $deleteOldElements=true)\n    {\n        $this->SharingGroup = ClassRegistry::init('SharingGroup');\n        $errors = array();\n        if (!$user['Role']['perm_galaxy_editor'] && !$user['Role']['perm_site_admin']) {\n            $errors[] = __('Incorrect permission');\n        }\n        if (isset($cluster['GalaxyCluster']['uuid'])) {\n            $existingCluster = $this->find('first', array('conditions' => array('GalaxyCluster.uuid' => $cluster['GalaxyCluster']['uuid'])));\n        } else {\n            $errors[] = __('UUID not provided');\n        }\n        if (empty($existingCluster)) {\n            $errors[] = __('Unkown UUID');\n        } else {\n            // For users that are of the creating org of the cluster, always allow the edit\n            // For users that are sync users, only allow the edit if the cluster is locked\n            if (\n                $existingCluster['GalaxyCluster']['orgc_id'] === $user['org_id'] ||\n                ($user['Role']['perm_sync'] && $existingCluster['GalaxyCluster']['locked']) || $user['Role']['perm_site_admin']\n            ) {\n                if ($user['Role']['perm_sync']) {\n                    if (\n                        isset($cluster['GalaxyCluster']['distribution']) && $cluster['GalaxyCluster']['distribution'] == 4 && !$this->SharingGroup->checkIfAuthorised($user, $cluster['GalaxyCluster']['sharing_group_id'])\n                    ) {\n                        $errors[] = array(__('Galaxy Cluster could not be saved: The sync user has to have access to the sharing group in order to be able to edit it.'));\n                    }\n                }\n            } else {\n                $errors[] = array(__('Galaxy Cluster could not be saved: The user used to edit the cluster is not authorised to do so. This can be caused by the user not being of the same organisation as the original creator of the cluster whilst also not being a site administrator.'));\n            }\n            $cluster['GalaxyCluster']['id'] = $existingCluster['GalaxyCluster']['id'];\n\n            if (empty($errors)) {\n                $date = new DateTime();\n                $cluster['GalaxyCluster']['version'] = $date->getTimestamp();\n                $cluster['GalaxyCluster']['default'] = false;\n                if (!isset($cluster['GalaxyCluster']['published'])) {\n                    $cluster['GalaxyCluster']['published'] = false;\n                }\n                if (isset($cluster['GalaxyCluster']['distribution']) && $cluster['GalaxyCluster']['distribution'] != 4) {\n                    $cluster['GalaxyCluster']['sharing_group_id'] = null;\n                }\n                if (empty($fieldList)) {\n                    $fieldList = array('value', 'description', 'version', 'source', 'authors', 'distribution', 'sharing_group_id', 'default', 'published');\n                }\n                $saveSuccess = $this->save($cluster, array('fieldList' => $fieldList));\n                if ($saveSuccess) {\n                    if (isset($cluster['GalaxyCluster']['GalaxyElement'])) {\n                        $elementsToSave = array();\n                        foreach ($cluster['GalaxyCluster']['GalaxyElement'] as $element) { // transform cluster into Galaxy meta format\n                            $elementsToSave[$element['key']][] = $element['value'];\n                        }\n                        $this->GalaxyElement->updateElements($cluster['GalaxyCluster']['id'], $cluster['GalaxyCluster']['id'], $elementsToSave, $delete=$deleteOldElements);\n                    }\n                    if (!empty($cluster['GalaxyCluster']['GalaxyClusterRelation'])) {\n                        $this->GalaxyClusterRelation->saveRelations($user, $cluster['GalaxyCluster'], $cluster['GalaxyCluster']['GalaxyClusterRelation'], $captureTag=true, $force=true);\n                    }\n                } else {\n                    foreach ($this->validationErrors as $validationError) {\n                        $errors[] = $validationError[0];\n                    }\n                }\n            }\n        }\n        return $errors;\n    }\n\n    /**\n     * publishRouter\n     *\n     * @param  array $user\n     * @param  mixed $cluster\n     * @param  int|null $passAlong The server id from which the publish is issued\n     * @return mixed The process id or the publish result depending on background jobs\n     */\n    public function publishRouter(array $user, $cluster, $passAlong=null)\n    {\n        if (Configure::read('MISP.background_jobs')) {\n            if (is_numeric($cluster)) {\n                $clusterId = $cluster;\n            } elseif (isset($cluster['GalaxyCluster'])) {\n                $clusterId = $cluster['GalaxyCluster']['id'];\n            } else {\n                return false;\n            }\n\n            /** @var Job $job */\n            $job = ClassRegistry::init('Job');\n            $jobId = $job->createJob(\n                'SYSTEM',\n                Job::WORKER_PRIO,\n                'publish_galaxy_clusters',\n                'Cluster ID: ' . $clusterId,\n                'Publishing.'\n            );\n\n            return $this->getBackgroundJobsTool()->enqueue(\n                BackgroundJobsTool::PRIO_QUEUE,\n                BackgroundJobsTool::CMD_EVENT,\n                [\n                    'publish_galaxy_clusters',\n                    $clusterId,\n                    $jobId,\n                    $user['id'],\n                    $passAlong\n                ],\n                true,\n                $jobId\n            );\n\n        } else {\n            $result = $this->publish($cluster, $passAlong=$passAlong);\n            return $result;\n        }\n    }\n\n    /**\n     * publish\n     *\n     * @param  mixed $cluster\n     * @param  int|null $passAlong The server id from which the publish is issued\n     * @return bool The success of the publish operation\n     */\n    public function publish($cluster, $passAlong=null)\n    {\n        if (is_numeric($cluster)) {\n            $clusterId = $cluster;\n        } elseif (isset($cluster['GalaxyCluster'])) {\n            $clusterId = $cluster['GalaxyCluster']['id'];\n        }\n        $this->id = $clusterId;\n        $saved = $this->saveField('published', True);\n        if ($saved['GalaxyCluster']['published']) {\n            $this->uploadClusterToServersRouter($clusterId);\n            return true;\n        }\n        return false;\n    }\n\n    public function unpublish($cluster)\n    {\n        if (is_numeric($cluster)) {\n            $this->id = $cluster;\n        } elseif (isset($cluster['GalaxyCluster'])) {\n            $this->id = $cluster['GalaxyCluster']['id'];\n        }\n        return $this->saveField('published', False);\n    }\n\n    /**\n     * deleteCluster Delete the cluster. Also creates an entry in the cluster blocklist when hard-deleting\n     *\n     * @param  int  $id\n     * @param  bool $hard\n     * @return bool\n     */\n    public function deleteCluster($id, $hard=false)\n    {\n        if ($hard) {\n            $cluster = $this->find('first', array('conditions' => array('id' => $id), 'recursive' => -1));\n            $this->GalaxyClusterBlocklist = ClassRegistry::init('GalaxyClusterBlocklist');\n            $this->GalaxyClusterBlocklist->create();\n            if (!empty($cluster['GalaxyCluster']['orgc_id'])) {\n                $orgc = $this->Orgc->find('first', array(\n                    'conditions' => array('Orgc.id' => $cluster['GalaxyCluster']['orgc_id']),\n                    'recursive' => -1,\n                    'fields' => array('Orgc.name')\n                ));\n            } else {\n                $orgc = ['Orgc' => ['name' => 'MISP']];\n            }\n            $this->GalaxyClusterBlocklist->save(array('cluster_uuid' => $cluster['GalaxyCluster']['uuid'], 'cluster_info' => $cluster['GalaxyCluster']['value'], 'cluster_orgc' => $orgc['Orgc']['name']));\n            $deleteResult = $this->delete($id, true);\n            return $deleteResult;\n        } else {\n            $version = (new DateTime())->getTimestamp();\n            return $this->save(array(\n                'id' => $id,\n                'published' => false,\n                'version' => $version,\n                'deleted' => true,\n            ), array('fieldList' => array('published', 'deleted', 'version')));\n        }\n    }\n\n    public function restoreCluster($id)\n    {\n        $version = (new DateTime())->getTimestamp();\n        return $this->save(array(\n            'id' => $id,\n            'published' => false,\n            'version' => $version,\n            'deleted' => false,\n        ), array('fieldList' => array('published', 'deleted', 'version')));\n    }\n\n    public function touchTimestamp($id)\n    {\n        $version = (new DateTime())->getTimestamp();\n        return $this->save(array(\n            'id' => $id,\n            'version' => $version,\n        ), array('fieldList' => array('version')));\n    }\n\n    /**\n     * wipe_default Delete all default galaxy clusters and their associations.\n     *  Relying on the cake's recursive deletion for the associations adds an non-negligible overhead.\n     *  Same for cake's before/afterDelete callbacks. We do it by hand to speed up the process\n     *\n     */\n    public function wipe_default()\n    {\n        $clusters = $this->find('all', [\n            'conditions' => ['default' => true],\n            'fields' => ['id', 'uuid']\n        ]);\n        $cluster_ids = Hash::extract($clusters, '{n}.GalaxyCluster.id');\n        $cluster_uuids = Hash::extract($clusters, '{n}.GalaxyCluster.uuid');\n        $relation_ids = $this->GalaxyClusterRelation->find('list', [\n            'conditions' => ['galaxy_cluster_id' => $cluster_ids],\n            'fields' => ['id']\n        ]);\n        $this->deleteAll(['GalaxyCluster.default' => true], false, false);\n        $this->GalaxyElement->deleteAll(['GalaxyElement.galaxy_cluster_id' => $cluster_ids], false, false);\n        $this->GalaxyClusterRelation->deleteAll(['GalaxyClusterRelation.galaxy_cluster_id' => $cluster_ids], false, false);\n        $this->GalaxyClusterRelation->updateAll(\n            ['GalaxyClusterRelation.referenced_galaxy_cluster_id' => 0],\n            ['GalaxyClusterRelation.referenced_galaxy_cluster_uuid' => $cluster_uuids] // For all default clusters being referenced\n        );\n        $this->GalaxyClusterRelation->GalaxyClusterRelationTag->deleteAll(['GalaxyClusterRelationTag.galaxy_cluster_relation_id' => $relation_ids], false, false);\n        $this->Log = ClassRegistry::init('Log');\n        $this->Log->createLogEntry('SYSTEM', 'wipe_default', 'GalaxyCluster', 0, \"Wiping default galaxy clusters\");\n\n    }\n\n    /**\n     * uploadClusterToServersRouter Upload the cluster to all remote servers\n     *\n     * @param  int $clusterId\n     * @param  int|null $passAlong The server id from which the publish is issued\n     * @return bool the upload result\n     */\n    private function uploadClusterToServersRouter($clusterId, $passAlong=null)\n    {\n        $clusterOrgcId = $this->find('first', array(\n            'conditions' => array('GalaxyCluster.id' => $clusterId),\n            'recursive' => -1,\n            'fields' => array('GalaxyCluster.orgc_id')\n        ));\n        $elevatedUser = array(\n            'Role' => array(\n                'perm_site_admin' => 1,\n                'perm_sync' => 1,\n                'perm_audit' => 0,\n            ),\n            'org_id' => $clusterOrgcId['GalaxyCluster']['orgc_id']\n        );\n        $cluster = $this->fetchGalaxyClusters($elevatedUser, array('minimal' => true, 'conditions' => array('id' => $clusterId)), $full=false);\n        if (empty($cluster)) {\n            return true;\n        }\n        $cluster = $cluster[0];\n\n        $this->Server = ClassRegistry::init('Server');\n        $conditions = array('push' => 1, 'push_galaxy_clusters' => 1); // Notice: Cluster will be pushed only for servers having both these conditions\n        if ($passAlong) {\n            $conditions[] = array('Server.id !=' => $passAlong);\n        }\n        $servers = $this->Server->find('all', array(\n            'conditions' => $conditions,\n            'order' => array('Server.priority ASC', 'Server.id ASC')\n        ));\n        // iterate over the servers and upload the event\n        if (empty($servers)) {\n            return true;\n        }\n        $uploaded = false;\n        foreach ($servers as $server) {\n            if ((!isset($server['Server']['internal']) || !$server['Server']['internal']) && $cluster['GalaxyCluster']['distribution'] < 2) {\n                continue;\n            }\n            $fakeSyncUser = array(\n                'id' => 0,\n                'email' => 'fakeSyncUser@user.test',\n                'org_id' => $server['Server']['remote_org_id'],\n                'Organisation' => array(\n                    'id' => $server['Server']['remote_org_id'],\n                    'name' => 'fakeSyncOrg',\n                ),\n                'Role' => array(\n                    'perm_site_admin' => 0,\n                    'perm_sync' => 1\n                )\n            );\n            $cluster = $this->fetchGalaxyClusters($fakeSyncUser, array('conditions' => array('GalaxyCluster.id' => $clusterId)), $full=true);\n            if (empty($cluster)) {\n                continue;\n            }\n            $cluster = $cluster[0];\n            $serverSync = new ServerSyncTool($server, $this->setupSyncRequest($server));\n            $result = $this->uploadClusterToServer($cluster, $server, $serverSync, $fakeSyncUser);\n            if ($result === 'Success') {\n                $uploaded = true;\n            }\n        }\n        return $uploaded;\n    }\n\n    public function unsetFieldsForExport($clusters)\n    {\n        foreach ($clusters as $k => $cluster) {\n            unset($clusters[$k]['GalaxyCluster']['galaxy_id']);\n            $modelsToUnset = array('GalaxyCluster', 'Galaxy', 'Org', 'Orgc');\n            foreach ($modelsToUnset as $modelName) {\n                unset($clusters[$k][$modelName]['id']);\n            }\n            $modelsToUnset = array('GalaxyClusterRelation', 'TargetingClusterRelation');\n            foreach ($modelsToUnset as $modelName) {\n                if (!empty($cluster['GalaxyCluster'][$modelName])) {\n                    foreach ($cluster['GalaxyCluster'][$modelName] as $i => $relation) {\n                        unset($clusters[$k]['GalaxyCluster'][$modelName][$i]['id']);\n                        unset($clusters[$k]['GalaxyCluster'][$modelName][$i]['galaxy_cluster_id']);\n                        unset($clusters[$k]['GalaxyCluster'][$modelName][$i]['referenced_galaxy_cluster_id']);\n                        if (isset($relation['Tag'])) {\n                            foreach ($relation['Tag'] as $j => $tags) {\n                                unset($clusters[$k]['GalaxyCluster'][$modelName][$i]['Tag'][$j]['id']);\n                                unset($clusters[$k]['GalaxyCluster'][$modelName][$i]['Tag'][$j]['org_id']);\n                                unset($clusters[$k]['GalaxyCluster'][$modelName][$i]['Tag'][$j]['user_id']);\n                            }\n                        }\n                    }\n                }\n            }\n            foreach ($cluster['GalaxyCluster']['GalaxyElement'] as $i => $element) {\n                unset($clusters[$k]['GalaxyCluster']['GalaxyElement'][$i]['id']);\n                unset($clusters[$k]['GalaxyCluster']['GalaxyElement'][$i]['galaxy_cluster_id']);\n            }\n        }\n        return $clusters;\n    }\n\n    /**\n     * Gets a cluster then save it.\n     *\n     * @param $user\n     * @param array $cluster Cluster to be saved\n     * @param bool  $fromPull If the current capture is performed from a PULL sync\n     * @param int   $orgId The organisation id that should own the cluster\n     * @param array $server The server for which to capture is ongoing\n     * @return array Result of the capture including successes, fails and errors\n     */\n    public function captureCluster($user, $cluster, $fromPull=false, $orgId=0, $server=false)\n    {\n        $results = array('success' => false, 'imported' => 0, 'ignored' => 0, 'failed' => 0, 'errors' => array());\n\n        if ($fromPull) {\n            $cluster['GalaxyCluster']['org_id'] = $orgId;\n        } else {\n            $cluster['GalaxyCluster']['org_id'] = $user['Organisation']['id'];\n        }\n\n        $this->GalaxyClusterBlocklist = ClassRegistry::init('GalaxyClusterBlocklist');\n        if ($this->GalaxyClusterBlocklist->checkIfBlocked($cluster['GalaxyCluster']['uuid'])) {\n            $results['errors'][] = __('Blocked by blocklist');\n            $results['ignored']++;\n            return $results;\n        }\n\n        if (!isset($cluster['GalaxyCluster']['orgc_id']) && !isset($cluster['Orgc'])) {\n            $cluster['GalaxyCluster']['orgc_id'] = $cluster['GalaxyCluster']['org_id'];\n        } else {\n            if (!isset($cluster['GalaxyCluster']['Orgc'])) {\n                if (isset($cluster['GalaxyCluster']['orgc_id']) && $cluster['GalaxyCluster']['orgc_id'] != $user['org_id'] && !$user['Role']['perm_sync'] && !$user['Role']['perm_site_admin']) {\n                    $cluster['GalaxyCluster']['orgc_id'] = $cluster['GalaxyCluster']['org_id']; // Only sync user can create cluster on behalf of other users\n                }\n            } else {\n                if ($cluster['GalaxyCluster']['Orgc']['uuid'] != $user['Organisation']['uuid'] && !$user['Role']['perm_sync'] && !$user['Role']['perm_site_admin']) {\n                    $cluster['GalaxyCluster']['orgc_id'] = $cluster['GalaxyCluster']['org_id']; // Only sync user can create cluster on behalf of other users\n                }\n            }\n            if (isset($cluster['GalaxyCluster']['orgc_id']) && $cluster['GalaxyCluster']['orgc_id'] != $user['org_id'] && !$user['Role']['perm_sync'] && !$user['Role']['perm_site_admin']) {\n                $cluster['GalaxyCluster']['orgc_id'] = $cluster['GalaxyCluster']['org_id']; // Only sync user can create cluster on behalf of other users\n            }\n        }\n\n        if (!Configure::check('MISP.enableOrgBlocklisting') || Configure::read('MISP.enableOrgBlocklisting') !== false) {\n            $this->OrgBlocklist = ClassRegistry::init('OrgBlocklist');\n            if (!isset($cluster['GalaxyCluster']['Orgc']['uuid'])) {\n                $orgc = $this->Orgc->find('first', array('conditions' => array('Orgc.id' => $cluster['GalaxyCluster']['orgc_id']), 'fields' => array('Orgc.uuid'), 'recursive' => -1));\n            } else {\n                $orgc = array('Orgc' => array('uuid' => $cluster['GalaxyCluster']['Orgc']['uuid']));\n            }\n            if ($cluster['GalaxyCluster']['orgc_id'] != 0 && $this->OrgBlocklist->hasAny(array('OrgBlocklist.org_uuid' => $orgc['Orgc']['uuid']))) {\n                $results['errors'][] = __('Organisation blocklisted (%s)', $orgc['Orgc']['uuid']);\n                $results['ignored']++;\n                return $results;\n            }\n        }\n\n        if ($cluster['GalaxyCluster']['default']) {\n            $results['errors'][] = __('Only non-default clusters can be saved');\n            $results['failed']++;\n            return $results;\n        }\n\n        $cluster = $this->captureOrganisationAndSG($cluster, 'GalaxyCluster', $user);\n        $existingGalaxyCluster = $this->find('first', array('conditions' => array(\n            'GalaxyCluster.uuid' => $cluster['GalaxyCluster']['uuid']\n        )));\n        $cluster['GalaxyCluster']['tag_name'] = sprintf('misp-galaxy:%s=\"%s\"', $cluster['GalaxyCluster']['type'], $cluster['GalaxyCluster']['uuid']);\n        if (!isset($cluster['GalaxyCluster']['distribution'])) {\n            $cluster['GalaxyCluster']['distribution'] = Configure::read('MISP.default_event_distribution'); // use default event distribution\n        }\n        if ($cluster['GalaxyCluster']['distribution'] != 4) {\n            $cluster['GalaxyCluster']['sharing_group_id'] = null;\n        }\n        if (!isset($cluster['GalaxyCluster']['published'])) {\n            $cluster['GalaxyCluster']['published'] = false;\n        }\n        if (empty($existingGalaxyCluster)) {\n            $galaxy = $this->Galaxy->captureGalaxy($user, $cluster['GalaxyCluster']['Galaxy']);\n            $cluster['GalaxyCluster']['galaxy_id'] = $galaxy['Galaxy']['id'];\n            unset($cluster['GalaxyCluster']['id']);\n            $this->create();\n            $saveSuccess = $this->save($cluster);\n        } else {\n            if (!$existingGalaxyCluster['GalaxyCluster']['locked'] && empty($server['Server']['internal'])) {\n                $results['errors'][] = __('Blocked an edit to an cluster that was created locally. This can happen if a synchronised cluster that was created on this instance was modified by an administrator on the remote side.');\n                $results['failed']++;\n                return $results;\n            }\n            if ($cluster['GalaxyCluster']['version'] > $existingGalaxyCluster['GalaxyCluster']['version']) {\n                $cluster['GalaxyCluster']['id'] = $existingGalaxyCluster['GalaxyCluster']['id'];\n                $saveSuccess = $this->save($cluster);\n            } else {\n                $results['errors'][] = __('Remote version is not newer than local one for cluster (%s)', $cluster['GalaxyCluster']['uuid']);\n                $results['ignored']++;\n                return $results;\n            }\n        }\n        if ($saveSuccess) {\n            $results['imported']++;\n            $savedCluster = $this->find('first', array(\n                'conditions' => array('uuid' =>  $cluster['GalaxyCluster']['uuid']),\n                'recursive' => -1\n            ));\n            if (!empty($cluster['GalaxyCluster']['GalaxyElement'])) {\n                $this->GalaxyElement->deleteAll(array('GalaxyElement.galaxy_cluster_id' => $savedCluster['GalaxyCluster']['id']));\n                $this->GalaxyElement->captureElements($user, $cluster['GalaxyCluster']['GalaxyElement'], $savedCluster['GalaxyCluster']['id']);\n            }\n            if (!empty($cluster['GalaxyCluster']['GalaxyClusterRelation'])) {\n                $this->GalaxyClusterRelation->deleteAll(array('GalaxyClusterRelation.galaxy_cluster_id' => $savedCluster['GalaxyCluster']['id']));\n                $saveResult = $this->GalaxyClusterRelation->captureRelations($user, $savedCluster, $cluster['GalaxyCluster']['GalaxyClusterRelation'], $fromPull=$fromPull);\n                if ($saveResult['failed'] > 0) {\n                    $results['errors'][] = __('Issues while capturing relations have been logged.');\n                }\n            }\n            if ($savedCluster['GalaxyCluster']['published']) {\n                $passAlong = isset($server['Server']['id']) ? $server['Server']['id'] : null;\n                $this->publishRouter($user, $savedCluster['GalaxyCluster']['id'], $passAlong);\n            }\n        } else {\n            $results['failed']++;\n            foreach ($this->validationErrors as $validationError) {\n                $results['errors'][] = $validationError[0];\n            }\n        }\n        $results['success'] = $results['imported'] > 0;\n        return $results;\n    }\n\n    public function captureOrganisationAndSG($element, $model, $user)\n    {\n        $this->Event = ClassRegistry::init('Event');\n        if (isset($element[$model]['distribution']) && $element[$model]['distribution'] == 4) {\n            $element[$model] = $this->Event->captureSGForElement($element[$model], $user);\n        }\n        // first we want to see how the creator organisation is encoded\n        // The options here are either by passing an organisation object along or simply passing a string along\n        if (isset($element[$model]['Orgc'])) {\n            $element[$model]['orgc_id'] = $this->Orgc->captureOrg($element[$model]['Orgc'], $user);\n            unset($element[$model]['Orgc']);\n        } else {\n            // Can't capture the Orgc, default to the current user\n            $element[$model]['orgc_id'] = $user['org_id'];\n        }\n        return $element;\n    }\n\n    /**\n     * @param array $user\n     * @param array $clusters\n     * @return void\n     */\n    public function attachExtendByInfo(array $user, array &$clusters)\n    {\n        if (empty($clusters)) {\n            return;\n        }\n\n        $clusterUuids = array_column(array_column($clusters, 'GalaxyCluster'), 'uuid');\n        $extensions = $this->fetchGalaxyClusters($user, [\n            'conditions' => ['extends_uuid' => $clusterUuids],\n        ]);\n        foreach ($clusters as &$cluster) {\n            $extendedBy = [];\n            foreach ($extensions as $extension) {\n                if ($cluster['GalaxyCluster']['uuid'] === $extension['GalaxyCluster']['extends_uuid']) {\n                    $extendedBy[] = $extension;\n                }\n            }\n            $cluster['GalaxyCluster']['extended_by'] = $extendedBy;\n        }\n    }\n\n    public function attachExtendFromInfo($user, $cluster)\n    {\n        if (!empty($cluster['GalaxyCluster']['extends_uuid'])) {\n            $extensions = $this->fetchGalaxyClusters($user, array('conditions' => array('uuid' => $cluster['GalaxyCluster']['extends_uuid'])));\n            if (!empty($extensions)) {\n                $cluster['GalaxyCluster']['extended_from'] = $extensions[0];\n            } else {\n                $cluster['GalaxyCluster']['extended_from'] = array();\n            }\n        }\n        return $cluster;\n    }\n\n    /* Return a list of all tags associated with the cluster specific cluster within the galaxy (or all clusters if $clusterValue is false)\n     * The counts are restricted to the event IDs that the user is allowed to see.\n    */\n    public function getTags($galaxyType, $clusterValue = false, $user)\n    {\n        $this->Event = ClassRegistry::init('Event');\n        $event_ids = $this->Event->fetchEventIds($user, [\n            'list' => true\n        ]);\n        $tags = $this->Event->EventTag->Tag->find('list', array(\n                'conditions' => array('name LIKE' => 'misp-galaxy:' . $galaxyType . '=\"' . ($clusterValue ? $clusterValue : '%') .'\"'),\n                'fields' => array('name', 'id'),\n        ));\n        $this->Event->EventTag->virtualFields['tag_count'] = 'COUNT(id)';\n        $tagCounts = $this->Event->EventTag->find('list', array(\n                'conditions' => array('EventTag.tag_id' => array_values($tags), 'EventTag.event_id' => $event_ids),\n                'fields' => array('EventTag.tag_id', 'EventTag.tag_count'),\n                'group' => array('EventTag.tag_id')\n        ));\n        foreach ($tags as $k => $v) {\n            if (isset($tagCounts[$v])) {\n                $tags[$k] = array('count' => $tagCounts[$v], 'tag_id' => $v);\n            } else {\n                unset($tags[$k]);\n            }\n        }\n        return $tags;\n    }\n\n    /**\n     * @param string|int $name Cluster name or ID\n     * @param array $user\n     * @return array|mixed\n     */\n    public function getCluster($name, $user)\n    {\n        if (isset($this->__clusterCache[$name])) {\n            return $this->__clusterCache[$name];\n        }\n        if (is_numeric($name)) {\n            $conditions = array('GalaxyCluster.id' => $name);\n        } else {\n            $isGalaxyTag = strpos($name, 'misp-galaxy:') === 0;\n            if (!$isGalaxyTag) {\n                return null;\n            }\n            $conditions = array('GalaxyCluster.tag_name' => $name);\n        }\n        $cluster = $this->fetchGalaxyClusters($user, array(\n            'conditions' => $conditions,\n            'first' => true\n        ), true);\n\n        if (!empty($cluster)) {\n            $cluster = $this->postprocess($cluster);\n        }\n        if (!empty($cluster) && $cluster['GalaxyCluster']['default']) { // only cache default clusters\n            $this->__clusterCache[$name] = $cluster;\n        }\n        return $cluster;\n    }\n\n    /**\n     * @param array $tagNames Cluster tag names with tag ID in key\n     * @param array $user\n     * @param bool $postProcess If true, self::postprocess method will be called.\n     * @param bool $fetchFullCluster\n     * @return array\n     */\n    public function getClustersByTags(array $tagNames, array $user, $postProcess = true, $fetchFullCluster = true, $fetchFullRelationship = false)\n    {\n        $options = [\n            'conditions' => ['GalaxyCluster.tag_name' => $tagNames],\n        ];\n        if (!$fetchFullCluster) {\n            $options['contain'] = ['Galaxy', 'GalaxyElement'];\n        }\n\n        $clusters = $this->fetchGalaxyClusters($user, $options, $fetchFullCluster, $fetchFullRelationship);\n\n        if (!empty($clusters) && $postProcess) {\n            $tagIds = array_change_key_case(array_flip($tagNames));\n            foreach ($clusters as $k => $cluster) {\n                $tagName = strtolower($cluster['GalaxyCluster']['tag_name']);\n                $clusters[$k] = $this->postprocess($cluster, $tagIds[$tagName] ?? null);\n            }\n        }\n\n        return $clusters;\n    }\n\n    public function buildConditions($user)\n    {\n        $conditions = array();\n        if (!$user['Role']['perm_site_admin']) {\n            $sgids = $this->SharingGroup->authorizedIds($user);\n            $alias = $this->alias;\n            $conditions['AND']['OR'] = array(\n                \"${alias}.org_id\" => $user['org_id'],\n                array(\n                    'AND' => array(\n                        \"${alias}.distribution >\" => 0,\n                        \"${alias}.distribution <\" => 4\n                    ),\n                ),\n                array(\n                    'AND' => array(\n                        \"${alias}.sharing_group_id\" => $sgids,\n                        \"${alias}.distribution\" => 4\n                    )\n                )\n            );\n        }\n        return $conditions;\n    }\n\n    /**\n     * fetchGalaxyClusters Very flexible, it's basically a replacement for find, with the addition that it restricts access based on user\n     *\n     * @param  mixed $user\n     * @param  mixed $options\n     * @param  bool  $full\n     * @return array\n     */\n    public function fetchGalaxyClusters(array $user, array $options, $full=false, $includeFullClusterRelationship=false)\n    {\n        $params = array(\n            'conditions' => $this->buildConditions($user),\n            'recursive' => -1\n        );\n        if ($full) {\n            $params['contain'] = array(\n                'Galaxy',\n                'GalaxyElement',\n                'GalaxyClusterRelation' => array(\n                    'conditions' => $this->GalaxyClusterRelation->buildConditions($user, false),\n                    'GalaxyClusterRelationTag',\n                    'SharingGroup',\n                ),\n                'Orgc',\n                'Org',\n                'SharingGroup'\n            );\n        }\n        if (!empty($includeFullClusterRelationship)) {\n            $params['contain']['GalaxyClusterRelation'][] = 'TargetCluster';\n        }\n        if (!empty($options['contain'])) {\n            $params['contain'] = $options['contain'];\n        }\n        if (isset($options['fields'])) {\n            $params['fields'] = $options['fields'];\n        }\n        if (isset($options['conditions'])) {\n            $params['conditions']['AND'][] = $options['conditions'];\n        }\n        if (isset($options['group'])) {\n            $params['group'] = $options['group'];\n        }\n        if (!empty($options['order'])) {\n            $options['order'] = $this->findOrder(\n                $options['order'],\n                'GalaxyCluster',\n                ['id', 'event_id', 'version', 'type', 'value', 'distribution', 'orgc_id', 'org_id', 'tag_name', 'galaxy_id']\n            );\n        }\n        if (isset($options['page'])) {\n            $params['page'] = $options['page'];\n        }\n        if (isset($options['limit'])) {\n            $params['limit'] = $options['limit'];\n        }\n        if (isset($options['list']) && $options['list']) {\n            return $this->find('list', $params);\n        }\n\n        if (isset($options['first']) && $options['first']) {\n            $clusters = $this->find('first', $params);\n        } else if (isset($options['count']) && $options['count']) {\n            return $this->find('count', $params);\n        } else {\n            $clusters = $this->find('all', $params);\n        }\n\n        if (empty($clusters)) {\n            return $clusters;\n        }\n\n        if (isset($options['first']) && $options['first']) {\n            $clusters = [$clusters];\n        }\n\n        if ($full) {\n            $clusterIds = array_column(array_column($clusters, 'GalaxyCluster'), 'id');\n            $targetingClusterRelations = $this->TargetingClusterRelation->fetchRelations($user, array(\n                'contain' => array(\n                    'GalaxyClusterRelationTag',\n                    'SharingGroup',\n                ),\n                'conditions' => array(\n                    'TargetingClusterRelation.referenced_galaxy_cluster_id' => $clusterIds,\n                )\n            ));\n\n            $tagsToFetch = Hash::extract($clusters, \"{n}.GalaxyClusterRelation.{n}.GalaxyClusterRelationTag.{n}.tag_id\");\n            $tagsToFetch = array_merge($tagsToFetch, Hash::extract($targetingClusterRelations, \"GalaxyClusterRelationTag.{n}.tag_id\"));\n\n            if (!empty($tagsToFetch)) {\n                $tags = $this->GalaxyClusterRelation->GalaxyClusterRelationTag->Tag->find('all', [\n                    'conditions' => ['id' => array_unique($tagsToFetch, SORT_REGULAR)],\n                    'recursive' => -1,\n                ]);\n                $tags = array_column(array_column($tags, 'Tag'), null, 'id');\n            } else {\n                $tags = [];\n            }\n\n            foreach ($targetingClusterRelations as $k => $targetingClusterRelation) {\n                if (!empty($targetingClusterRelation['GalaxyClusterRelationTag'])) {\n                    foreach ($targetingClusterRelation['GalaxyClusterRelationTag'] as $relationTag) {\n                        if (isset($tags[$relationTag['tag_id']])) {\n                            $targetingClusterRelation['TargetingClusterRelation']['Tag'][] = $tags[$relationTag['tag_id']];\n                        }\n                    }\n                }\n                unset($targetingClusterRelation['GalaxyClusterRelationTag']);\n                if (!empty($targetingClusterRelation['SharingGroup']['id'])) {\n                    $targetingClusterRelation['TargetingClusterRelation']['SharingGroup'] = $targetingClusterRelation['SharingGroup'];\n                }\n                if ($includeFullClusterRelationship) {\n                    $targetingClusterRelation['TargetingClusterRelation']['GalaxyCluster'] = $targetingClusterRelation['SourceCluster'];\n                }\n                $targetingClusterRelations[$k] = $targetingClusterRelation['TargetingClusterRelation'];\n            }\n        }\n\n        $this->Event = ClassRegistry::init('Event');\n        $sharingGroupData = $this->Event->__cacheSharingGroupData($user, true);\n        foreach ($clusters as $i => $cluster) {\n            if (!empty($cluster['GalaxyCluster']['sharing_group_id']) && isset($sharingGroupData[$cluster['GalaxyCluster']['sharing_group_id']])) {\n                $clusters[$i]['SharingGroup'] = $sharingGroupData[$cluster['GalaxyCluster']['sharing_group_id']];\n            }\n            if (isset($cluster['GalaxyClusterRelation'])) {\n                foreach ($cluster['GalaxyClusterRelation'] as $j => $relation) {\n                    if (!empty($relation['sharing_group_id']) && isset($sharingGroupData[$relation['sharing_group_id']])) {\n                        $clusters[$i]['GalaxyClusterRelation'][$j]['SharingGroup'] = $sharingGroupData[$relation['sharing_group_id']];\n                    }\n                    foreach ($relation['GalaxyClusterRelationTag'] as $relationTag) {\n                        if (isset($tags[$relationTag['tag_id']])) {\n                            $clusters[$i]['GalaxyClusterRelation'][$j]['Tag'][] = $tags[$relationTag['tag_id']];\n                        }\n                    }\n                    unset($clusters[$i]['GalaxyClusterRelation'][$j]['GalaxyClusterRelationTag']);\n                }\n            }\n            if ($full) {\n                foreach ($targetingClusterRelations as $targetingClusterRelation) {\n                    if ($targetingClusterRelation['referenced_galaxy_cluster_id'] == $cluster['GalaxyCluster']['id']) {\n                        $clusters[$i]['TargetingClusterRelation'][] = $targetingClusterRelation;\n                    }\n                }\n            }\n            $clusters[$i] = $this->arrangeData($clusters[$i]);\n        }\n\n        if (isset($options['first']) && $options['first']) {\n            return $clusters[0];\n        }\n\n        return $clusters;\n    }\n\n    public function restSearch(array $user, $returnFormat, $filters, $paramsOnly=false, $jobId = false, &$elementCounter = 0)\n    {\n        if (!isset($this->validFormats[$returnFormat][1])) {\n            throw new NotFoundException('Invalid output format.');\n        }\n        App::uses($this->validFormats[$returnFormat][1], 'Export');\n        $exportTool = new $this->validFormats[$returnFormat][1]();\n        $conditions = $this->buildFilterConditions($user, $filters);\n        $params = array(\n            'conditions' => $conditions,\n            'full' => !empty($filters['full']) ? $filters['full'] : (!empty($filters['minimal']) ? !$filters['minimal'] : true),\n            'minimal' => !empty($filters['minimal']) ? $filters['minimal'] : (!empty($filters['full']) ? !$filters['full'] : false),\n        );\n\n        if (isset($filters['limit'])) {\n            $params['limit'] = $filters['limit'];\n            if (!isset($filters['page'])) {\n                $filters['page'] = 1;\n            }\n        }\n        if (isset($filters['page'])) {\n            $params['page'] = $filters['page'];\n        }\n\n        $default_cluster_memory_coefficient = 80;\n        if ($params['full']) {\n            $default_cluster_memory_coefficient = 0.5; // Complete cluster can be massive\n        }\n        if ($params['minimal']) {\n            $default_cluster_memory_coefficient = 100;\n            $params['fields'] = array('uuid', 'version');\n        }\n\n        if ($paramsOnly) {\n            return $params;\n        }\n        if (method_exists($exportTool, 'modify_params')) {\n            $params = $exportTool->modify_params($user, $params);\n        }\n        $exportToolParams = array(\n            'user' => $user,\n            'params' => $params,\n            'returnFormat' => $returnFormat,\n            'scope' => 'GalaxyCluster',\n            'filters' => $filters\n        );\n        if (!empty($exportTool->additional_params)) {\n            $params = array_merge_recursive(\n                $params,\n                $exportTool->additional_params\n            );\n        }\n\n        $tmpfile = new TmpFileTool();\n        $tmpfile->write($exportTool->header($exportToolParams));\n        $loop = false;\n        if (empty($params['limit'])) {\n            $memory_in_mb = $this->convert_to_memory_limit_to_mb(ini_get('memory_limit'));\n            $memory_scaling_factor = $default_cluster_memory_coefficient / 10;\n            $params['limit'] = intval($memory_in_mb * $memory_scaling_factor);\n            $loop = true;\n            $params['page'] = 1;\n        }\n        $this->__iteratedFetch($user, $params, $loop, $tmpfile, $exportTool, $exportToolParams, $elementCounter);\n        $tmpfile->write($exportTool->footer($exportToolParams));\n        return $tmpfile;\n    }\n\n    private function __iteratedFetch($user, $params, $loop, TmpFileTool $tmpfile, $exportTool, $exportToolParams, &$elementCounter = 0)\n    {\n        $elementCounter = 0;\n        $separator = $exportTool->separator($exportToolParams);\n        do {\n            $results = $this->fetchGalaxyClusters($user, $params, $full=$params['full']);\n            if (empty($results)) {\n                break; // nothing found, skip rest\n            }\n            $resultCount = count($results);\n            $elementCounter += $resultCount;\n            foreach ($results as $cluster) {\n                $handlerResult = $exportTool->handler($cluster, $exportToolParams);\n                if ($handlerResult !== '') {\n                    $tmpfile->writeWithSeparator($handlerResult, $separator);\n                }\n            }\n            if ($resultCount < $params['limit']) {\n                break;\n            }\n            $params['page'] += 1;\n        } while ($loop);\n        return true;\n    }\n\n    public function buildFilterConditions($user, $filters)\n    {\n        $conditions = $this->buildConditions($user);\n        if (isset($filters['org_id'])) {\n            $this->Organisation = ClassRegistry::init('Organisation');\n            if (!is_array($filters['org_id'])) {\n                $filters['org_id'] = array($filters['org_id']);\n            }\n            foreach ($filters['org_id'] as $k => $org_id) {\n                if (Validation::uuid($org_id)) {\n                    $org = $this->Organisation->find('first', array('conditions' => array('Organisation.uuid' => $org_id), 'recursive' => -1, 'fields' => array('Organisation.id')));\n                    if (empty($org)) {\n                        $filters['org_id'][$k] = -1;\n                    } else {\n                        $filters['org_id'][$k] = $org['Organisation']['id'];\n                    }\n                }\n            }\n            $conditions['AND']['GalaxyCluster.org_id'] = $filters['org_id'];\n        }\n        if (isset($filters['orgc_id'])) {\n            $this->Organisation = ClassRegistry::init('Organisation');\n            if (!is_array($filters['orgc_id'])) {\n                $filters['orgc_id'] = array($filters['orgc_id']);\n            }\n            foreach ($filters['orgc_id'] as $k => $orgc_id) {\n                if (Validation::uuid($orgc_id)) {\n                    $org = $this->Organisation->find('first', array('conditions' => array('Organisation.uuid' => $orgc_id), 'recursive' => -1, 'fields' => array('Organisation.id')));\n                    if (empty($org)) {\n                        $filters['orgc_id'][$k] = -1;\n                    } else {\n                        $filters['orgc_id'][$k] = $org['Organisation']['id'];\n                    }\n                }\n            }\n            $conditions['AND']['GalaxyCluster.orgc_id'] = $filters['orgc_id'];\n        }\n\n        if (isset($filters['galaxy_uuid'])) {\n            $galaxyIds = $this->Galaxy->find('list', array(\n                'recursive' => -1,\n                'conditions' => array('Galaxy.uuid' => $filters['galaxy_uuid']),\n                'fields' => array('id')\n            ));\n            if (!empty($galaxyIds)) {\n                $filters['galaxy_id'] = array_values($galaxyIds);\n            } else {\n                $filters['galaxy_id'] = -1;\n            }\n        }\n\n        if (isset($filters['eventid'])) {\n            $clusterUUIDs = $this->getClusterUUIDsFromAttachedTags($user, $filters['eventid']);\n            if (!empty($clusterUUIDs)) {\n                $filters['uuid'] = array_values($clusterUUIDs);\n            } else {\n                $filters['uuid'] = -1;\n            }\n        }\n\n        if (isset($filters['elements'])) {\n            $matchingIDs = $this->GalaxyElement->getClusterIDsFromMatchingElements($user, $filters['elements']);\n            $filters['id'] = $matchingIDs;\n        }\n\n        $simpleParams = array(\n            'uuid', 'galaxy_id', 'version', 'distribution', 'type', 'value', 'default', 'extends_uuid', 'tag_name', 'published', 'id',\n        );\n        foreach ($simpleParams as $k => $simpleParam) {\n            if (isset($filters[$simpleParam])) {\n                $conditions['AND'][\"GalaxyCluster.${simpleParam}\"] = $filters[$simpleParam];\n            }\n        }\n\n        if (isset($filters['custom'])) {\n            $conditions['AND']['GalaxyCluster.default'] = !$filters['custom'];\n        }\n        return $conditions;\n    }\n\n    /**\n     * getClusterUUIDsFromAttachedTags Extract UUIDs from clusters contained in the provided event\n     *\n     * @param  array $user\n     * @param  int $eventId\n     * @return array list of cluster UUIDs\n     */\n    private function getClusterUUIDsFromAttachedTags(array $user, $eventId)\n    {\n        $models = array('Attribute', 'Event');\n        $clusterUUIDs = array();\n        foreach ($models as $model) {\n            $modelLower = strtolower($model);\n            $joinCondition2 = array('table' => \"${modelLower}_tags\",\n                'alias' => \"${model}Tag\",\n                'type' => 'inner',\n                'conditions' => array(\n                    \"Tag.id = ${model}Tag.tag_id\",\n                    \"${model}Tag.event_id\" => $eventId,\n                )\n            );\n            if ($model == 'Attribute') {\n                // We have to make sure users have access to the event/attributes\n                // Otherwise, they might enumerate and fetch tags from event/attributes they can't see\n                $this->Attribute = ClassRegistry::init('Attribute');\n                $attributes = $this->Attribute->fetchAttributes($user, array(\n                    'conditions' => array('Attribute.event_id' => $eventId),\n                    'fields' => array('Attribute.id'),\n                    'flatten' => 1\n                ));\n                if (!empty($attributes)) {\n                    $attributeIds = Hash::extract($attributes, '{n}.Attribute.id');\n                } else { // no attributes accessible\n                    $attributeIds = -1;\n                }\n                $joinCondition2['conditions'][\"${model}Tag.attribute_id\"] = $attributeIds;\n            }\n            $options = array(\n                'joins' => array(\n                    array('table' => 'tags',\n                        'alias' => 'Tag',\n                        'type' => 'inner',\n                        'conditions' => array(\n                            'GalaxyCluster.tag_name = Tag.name'\n                        )\n                    ),\n                    $joinCondition2\n                ),\n                'fields' => array('GalaxyCluster.uuid'),\n                'recursive' => -1,\n            );\n            $tmp = $this->find('list', $options);\n            $clusterUUIDs = array_merge($clusterUUIDs, array_values($tmp));\n        }\n        $clusterUUIDs = array_unique($clusterUUIDs);\n        return $clusterUUIDs;\n    }\n\n    /**\n     * Simple ACL-aware method to fetch a cluster by Id or UUID\n     *\n     * @param array $user\n     * @param int|string $clusterId Cluster ID or UUID\n     * @param bool $throwErrors\n     * @param bool $full\n     * @return array\n     */\n    public function fetchClusterById(array $user, $clusterId, $throwErrors=true, $full=false)\n    {\n        $alias = $this->alias;\n        if (Validation::uuid($clusterId)) {\n            $conditions = array(\"${alias}.uuid\" => $clusterId);\n        } elseif (is_numeric($clusterId)) {\n            $conditions = array(\"${alias}.id\" => $clusterId);\n        } else{\n            if ($throwErrors) {\n                throw new NotFoundException(__('Invalid galaxy cluster'));\n            }\n            return array();\n        }\n\n        return $this->fetchGalaxyClusters($user, ['conditions' => $conditions], $full=$full);\n    }\n\n\n    /**\n     * Fetches a cluster and checks if the user has the authorization to perform the requested operation\n     *\n     * @param  array $user\n     * @param  int|string|array $cluster\n     * @param  mixed $authorizations the requested actions to be performed on the cluster\n     * @param  bool  $throwErrors Should the function throws exception if users is not allowed to perform the action\n     * @param  bool  $full\n     * @return array The cluster or an error message\n     */\n    public function fetchIfAuthorized(array $user, $cluster, $authorizations, $throwErrors=true, $full=false)\n    {\n        $authorizations = is_array($authorizations) ? $authorizations : array($authorizations);\n        $possibleAuthorizations = array('view', 'edit', 'delete', 'publish');\n        if (!empty(array_diff($authorizations, $possibleAuthorizations))) {\n            throw new NotFoundException(__('Invalid authorization requested'));\n        }\n        if (isset($cluster['uuid'])) {\n            $cluster[$this->alias] = $cluster;\n        }\n        if (!isset($cluster[$this->alias]['uuid'])) {\n            $cluster = $this->fetchClusterById($user, $cluster, $throwErrors=$throwErrors, $full=$full);\n            if (empty($cluster)) {\n                $message = __('Invalid galaxy cluster');\n                if ($throwErrors) {\n                    throw new NotFoundException($message);\n                }\n                return array('authorized' => false, 'error' => $message);\n            }\n            $cluster = $cluster[0];\n        }\n        if ($user['Role']['perm_site_admin']) {\n            return $cluster;\n        }\n\n        if (in_array('view', $authorizations) && count($authorizations) === 1) {\n            return $cluster;\n        } else {\n            if (!$user['Role']['perm_galaxy_editor']) {\n                $message = __('You don\\'t have the permission to do that.');\n                if ($throwErrors) {\n                    throw new MethodNotAllowedException($message);\n                }\n                return array('authorized' => false, 'error' => $message);\n            }\n            if (in_array('edit', $authorizations) || in_array('delete', $authorizations)) {\n                if ($cluster[$this->alias]['orgc_id'] != $user['org_id']) {\n                    $message = __('Only the creator organisation can modify the galaxy cluster');\n                    if ($throwErrors) {\n                        throw new MethodNotAllowedException($message);\n                    }\n                    return array('authorized' => false, 'error' => $message);\n                }\n            }\n            if (in_array('publish', $authorizations)) {\n                if ($cluster[$this->alias]['orgc_id'] != $user['org_id'] && $user['Role']['perm_publish']) {\n                    $message = __('Only the creator organisation with publishing capabilities can publish the galaxy cluster');\n                    if ($throwErrors) {\n                        throw new MethodNotAllowedException($message);\n                    }\n                    return array('authorized' => false, 'error' => $message);\n                }\n            }\n            return $cluster;\n        }\n    }\n\n    /**\n     * @param array $user\n     * @param array $events\n     * @param bool $replace Remove galaxy cluster tags\n     * @return array\n     */\n    public function attachClustersToEventIndex(array $user, array $events, $replace = false)\n    {\n        $clusterTagNames = [];\n        foreach ($events as $event) {\n            foreach ($event['EventTag'] as $eventTag) {\n                if ($eventTag['Tag']['is_galaxy']) {\n                    $clusterTagNames[$eventTag['Tag']['id']] = $eventTag['Tag']['name'];\n                }\n            }\n        }\n\n        if (empty($clusterTagNames)) {\n            return $events;\n        }\n\n        $options = [\n            'conditions' => ['GalaxyCluster.tag_name' => $clusterTagNames],\n            'contain' => ['Galaxy', 'GalaxyElement'],\n        ];\n        $clusters = $this->fetchGalaxyClusters($user, $options);\n\n        $clustersByTagName = [];\n        foreach ($clusters as $cluster) {\n            $clustersByTagName[strtolower($cluster['GalaxyCluster']['tag_name'])] = $cluster;\n        }\n\n        foreach ($events as $k => $event) {\n            foreach ($event['EventTag'] as $k2 => $eventTag) {\n                if (!$eventTag['Tag']['is_galaxy']) {\n                    continue;\n                }\n                $tagName = strtolower($eventTag['Tag']['name']);\n                if (isset($clustersByTagName[$tagName])) {\n                    $cluster = $this->postprocess($clustersByTagName[$tagName], $eventTag['Tag']['id']);\n                    $cluster['GalaxyCluster']['local'] = $eventTag['local'];\n                    $cluster['GalaxyCluster']['relationship_type'] = $eventTag['relationship_type'];\n                    $events[$k]['GalaxyCluster'][] = $cluster['GalaxyCluster'];\n                    if ($replace) {\n                        unset($events[$k]['EventTag'][$k2]);\n                    }\n                }\n            }\n        }\n        return $events;\n    }\n\n    /**\n     * @param array $cluster\n     * @param int|null $tagId\n     * @return array\n     */\n    private function postprocess(array $cluster, $tagId = null)\n    {\n        $cluster = $this->arrangeData($cluster);\n\n        if (isset($cluster['GalaxyCluster']['GalaxyElement'])) {\n            $elements = array();\n            foreach ($cluster['GalaxyCluster']['GalaxyElement'] as $element) {\n                if (!isset($elements[$element['key']])) {\n                    $elements[$element['key']] = array($element['value']);\n                } else {\n                    $elements[$element['key']][] = $element['value'];\n                }\n            }\n            unset($cluster['GalaxyCluster']['GalaxyElement']);\n            $cluster['GalaxyCluster']['meta'] = $elements;\n        }\n\n        if ($tagId) {\n            $cluster['GalaxyCluster']['tag_id'] = $tagId;\n        } else {\n            $this->Tag = ClassRegistry::init('Tag');\n            $tag_id = $this->Tag->find(\n                'first',\n                array(\n                    'conditions' => array(\n                        'LOWER(Tag.name)' => strtolower($cluster['GalaxyCluster']['tag_name'])\n                    ),\n                    'recursive' => -1,\n                    'fields' => array('Tag.id')\n                )\n            );\n            if (!empty($tag_id)) {\n                $cluster['GalaxyCluster']['tag_id'] = $tag_id['Tag']['id'];\n            }\n        }\n\n        return $cluster;\n    }\n\n    public function getClusterTagsFromMeta($galaxyElements, $user)\n    {\n        // AND operator between cluster metas\n        $tmpResults = array();\n        foreach ($galaxyElements as $galaxyElementKey => $galaxyElementValue) {\n            $tmpResults[] = array_values($this->GalaxyElement->find('list', array(\n                'conditions' => array(\n                    'LOWER(GalaxyElement.key)' => strtolower($galaxyElementKey),\n                    'LOWER(GalaxyElement.value)' => strtolower($galaxyElementValue),\n                ),\n                'fields' => array('galaxy_cluster_id'),\n                'recursive' => -1\n            )));\n        }\n        $clusterTags = array();\n        if (!empty($tmpResults)) {\n            // Get all Clusters matching all conditions\n            $matchingClusters = $tmpResults[0];\n            array_shift($tmpResults);\n            foreach ($tmpResults as $tmpResult) {\n                $matchingClusters = array_intersect($matchingClusters, $tmpResult);\n            }\n            $clusterTags = $this->fetchGalaxyClusters($user, array(\n                'conditions' => array('id' => $matchingClusters),\n                'fields' => array('GalaxyCluster.tag_name'),\n                'list' => true,\n            ), $full=false);\n        }\n        return array_values($clusterTags);\n    }\n\n    public function getElligibleClustersToPush($user, $conditions=array(), $full=false)\n    {\n        $options = array(\n            'conditions' => array(\n                'GalaxyCluster.default' => 0,\n                'GalaxyCluster.published' => 1,\n            ),\n        );\n        $options['conditions'] = array_merge($options['conditions'], $conditions);\n        if (!$full) {\n            $options['fields'] = array('uuid', 'version');\n            $options['list'] = true;\n        }\n        $clusters = $this->fetchGalaxyClusters($user, $options, $full=$full);\n        return $clusters;\n    }\n\n    public function getElligibleLocalClustersToUpdate($user)\n    {\n        $options = array(\n            'conditions' => array(\n                'GalaxyCluster.default' => 0,\n                'GalaxyCluster.locked' => 1,\n            ),\n            'fields' => array('uuid', 'version'),\n            'list' => true,\n        );\n        $clusters = $this->fetchGalaxyClusters($user, $options, $full=false);\n        return $clusters;\n    }\n\n    /**\n     * @return string|bool The result of the upload. True if success, a string otherwise\n     * @throws Exception\n     */\n    public function uploadClusterToServer(array $cluster, array $server, ServerSyncTool $serverSync, array $user)\n    {\n        $cluster = $this->__prepareForPushToServer($cluster, $server);\n        if (is_numeric($cluster)) {\n            return $cluster;\n        }\n\n        try {\n            if (!$serverSync->isSupported(ServerSyncTool::PERM_SYNC) || !$serverSync->isSupported(ServerSyncTool::PERM_GALAXY_EDITOR)) {\n                return __('The remote user does not have the permission to manipulate galaxies - the upload of the galaxy clusters has been blocked.');\n            }\n            $serverSync->pushGalaxyCluster($cluster)->json();\n        } catch (Exception $e) {\n            $title = __('Uploading GalaxyCluster (%s) to Server (%s)', $cluster['GalaxyCluster']['id'], $server['Server']['id']);\n            $this->loadLog()->createLogEntry($user, 'push', 'GalaxyCluster', $cluster['GalaxyCluster']['id'], $title, $e->getMessage());\n\n            $this->logException(\"Could not push galaxy cluster to remote server {$serverSync->serverId()}\", $e);\n            return $e->getMessage();\n        }\n\n        return 'Success';\n    }\n\n    /**\n     * __prepareForPushToServer Check distribution and alter the cluster for sync\n     *\n     * @param  array $cluster\n     * @param  array $server\n     * @return array|int The cluster ready to be pushed\n     */\n    private function __prepareForPushToServer(array $cluster, array $server)\n    {\n        if ($cluster['GalaxyCluster']['distribution'] == 4) {\n            if (!empty($cluster['GalaxyCluster']['SharingGroup']['SharingGroupServer'])) {\n                $found = false;\n                foreach ($cluster['GalaxyCluster']['SharingGroup']['SharingGroupServer'] as $sgs) {\n                    if ($sgs['server_id'] == $server['Server']['id']) {\n                        $found = true;\n                    }\n                }\n                if (!$found) {\n                    return 403;\n                }\n            } elseif (empty($cluster['GalaxyCluster']['SharingGroup']['roaming'])) {\n                return 403;\n            }\n        }\n        $this->Event = ClassRegistry::init('Event');\n        if ($this->Event->checkDistributionForPush($cluster, $server, 'GalaxyCluster')) {\n            return $this->__updateClusterForSync($cluster, $server);\n        }\n        return 403;\n    }\n\n    /**\n     * __updateClusterForSync Cleanup the cluster and adapt data for sync\n     *\n     * @param  array $cluster\n     * @param  array $server\n     * @return array The cluster ready do be sync\n     */\n    private function __updateClusterForSync(array $cluster, array $server)\n    {\n        $this->Event = ClassRegistry::init('Event');\n        // cleanup the array from things we do not want to expose\n        foreach (array('org_id', 'orgc_id', 'id', 'galaxy_id') as $field) {\n            unset($cluster['GalaxyCluster'][$field]);\n        }\n        // Add the local server to the list of instances in the SG\n        if (isset($cluster['GalaxyCluster']['SharingGroup']) && isset($cluster['GalaxyCluster']['SharingGroup']['SharingGroupServer'])) {\n            foreach ($cluster['GalaxyCluster']['SharingGroup']['SharingGroupServer'] as &$s) {\n                if ($s['server_id'] == 0) {\n                    $s['Server'] = array(\n                        'id' => 0,\n                        'url' => $this->Event->__getAnnounceBaseurl(),\n                        'name' => $this->Event->__getAnnounceBaseurl()\n                    );\n                }\n            }\n        }\n        $cluster = $this->__prepareElementsForSync($cluster, $server);\n        $cluster = $this->__prepareRelationsForSync($cluster, $server);\n\n        // Downgrade the event from connected communities to community only\n        if (!$server['Server']['internal'] && $cluster['GalaxyCluster']['distribution'] == 2) {\n            $cluster['GalaxyCluster']['distribution'] = 1;\n        }\n        return $cluster;\n    }\n\n    private function __prepareElementsForSync($cluster, $server)\n    {\n        if (!empty($cluster['GalaxyCluster']['GalaxyElement'])) {\n            foreach ($cluster['GalaxyCluster']['GalaxyElement'] as $k => $element) {\n                $cluster['GalaxyCluster']['GalaxyElement'][$k] = $this->__updateElementForSync($element, $server);\n            }\n        }\n        return $cluster;\n    }\n\n    private function __prepareRelationsForSync($cluster, $server)\n    {\n        $this->Event = ClassRegistry::init('Event');\n        if (!empty($cluster['GalaxyCluster']['GalaxyClusterRelation'])) {\n            foreach ($cluster['GalaxyCluster']['GalaxyClusterRelation'] as $k => $relation) {\n                $cluster['GalaxyCluster']['GalaxyClusterRelation'][$k] = $this->__updateRelationsForSync($relation, $server);\n                if (empty($cluster['GalaxyCluster']['GalaxyClusterRelation'][$k])) {\n                    unset($cluster['GalaxyCluster']['GalaxyClusterRelation'][$k]);\n                } else {\n                    $cluster['GalaxyCluster']['GalaxyClusterRelation'][$k] = $this->Event->__removeNonExportableTags($cluster['GalaxyCluster']['GalaxyClusterRelation'][$k], 'GalaxyClusterRelation');\n                }\n            }\n            $cluster['GalaxyCluster']['GalaxyClusterRelation'] = array_values($cluster['GalaxyCluster']['GalaxyClusterRelation']);\n        }\n        return $cluster;\n    }\n\n    private function __updateElementForSync($element, $server)\n    {\n        unset($element['id']);\n        unset($element['galaxy_cluster_id']);\n        return $element;\n    }\n\n    private function __updateRelationsForSync($relation, $server)\n    {\n        // do not keep attributes that are private, nor cluster\n        if (!$server['Server']['internal'] && $relation['distribution'] < 2) {\n            return false;\n        }\n        // Downgrade the attribute from connected communities to community only\n        if (!$server['Server']['internal'] && $relation['distribution'] == 2) {\n            $relation['distribution'] = 1;\n        }\n\n        $this->Event = ClassRegistry::init('Event');\n        // If the attribute has a sharing group attached, make sure it can be transferred\n        if ($relation['distribution'] == 4) {\n            if (!$server['Server']['internal'] && $this->Event->checkDistributionForPush(array('GalaxyClusterRelation' => $relation), $server, 'GalaxyClusterRelation') === false) {\n                return false;\n            }\n            // Add the local server to the list of instances in the SG\n            if (!empty($relation['SharingGroup']['SharingGroupServer'])) {\n                foreach ($relation['SharingGroup']['SharingGroupServer'] as &$s) {\n                    if ($s['server_id'] == 0) {\n                        $s['Server'] = array(\n                            'id' => 0,\n                            'url' => $this->Event->__getAnnounceBaseurl(),\n                            'name' => $this->Event->__getAnnounceBaseurl()\n                        );\n                    }\n                }\n            }\n        }\n        unset($relation['id']);\n        unset($relation['galaxy_cluster_id']);\n        unset($relation['referenced_galaxy_cluster_id']);\n        return $relation;\n    }\n\n    /**\n     * pullGalaxyClusters\n     *\n     * @param array $user\n     * @param ServerSyncTool $serverSync\n     * @param string|int $technique The technique startegy used for pulling\n     *      allowed:\n     *          - int <event id>                    event containing the clusters to pulled\n     *          - string <full>                     pull everything\n     *          - string <update>                   pull updates of cluster present locally\n     *          - string <pull_relevant_clusters>   pull clusters based on tags present locally\n     * @return int The number of pulled clusters\n     * @throws HttpSocketHttpException\n     * @throws HttpSocketJsonException\n     */\n    public function pullGalaxyClusters(array $user, ServerSyncTool $serverSync, $technique = 'full')\n    {\n        $compatible = $serverSync->isSupported(ServerSyncTool::FEATURE_EDIT_OF_GALAXY_CLUSTER);\n        if (!$compatible) {\n            return 0;\n        }\n        $clusterIds = $this->getClusterIdListBasedOnPullTechnique($user, $technique, $serverSync);\n        $successes = 0;\n        // now process the $clusterIds to pull each of the events sequentially\n        if (!empty($clusterIds)) {\n            // download each cluster\n            foreach ($clusterIds as $clusterId) {\n                if ($this->__pullGalaxyCluster($clusterId, $serverSync, $user)) {\n                    $successes++;\n                }\n            }\n        }\n        return $successes;\n    }\n\n    /**\n     * getClusterIdListBasedOnPullTechnique Collect the list of remote cluster IDs to be pulled based on the technique\n     *\n     * @param  array $user\n     * @param  string|int $technique\n     * @param  ServerSyncTool $serverSync\n     * @return array cluster ID list to be pulled\n     */\n    private function getClusterIdListBasedOnPullTechnique(array $user, $technique, ServerSyncTool $serverSync)\n    {\n        $this->Server = ClassRegistry::init('Server');\n        try {\n            if (\"update\" === $technique) {\n                $localClustersToUpdate = $this->getElligibleLocalClustersToUpdate($user);\n                $clusterIds = $this->Server->getElligibleClusterIdsFromServerForPull($serverSync, $onlyUpdateLocalCluster = true, $elligibleClusters = $localClustersToUpdate);\n            } elseif (\"pull_relevant_clusters\" === $technique) {\n                // Fetch all local custom cluster tags then fetch their corresponding clusters on the remote end\n                $tagNames = $this->Tag->find('column', array(\n                    'conditions' => array(\n                        'Tag.is_custom_galaxy' => true\n                    ),\n                    'fields' => array('Tag.name'),\n                ));\n                $clusterUUIDs = array();\n                $re = '/^misp-galaxy:[^:=\"]+=\"(?<uuid>[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12})\"$/m';\n                foreach ($tagNames as $tagName) {\n                    preg_match($re, $tagName, $matches);\n                    if (isset($matches['uuid'])) {\n                        $clusterUUIDs[$matches['uuid']] = true;\n                    }\n                }\n                $localClustersToUpdate = $this->getElligibleLocalClustersToUpdate($user);\n                $conditions = array('uuid' => array_keys($clusterUUIDs));\n                $clusterIds = $this->Server->getElligibleClusterIdsFromServerForPull($serverSync, $onlyUpdateLocalCluster = false, $elligibleClusters = $localClustersToUpdate, $conditions = $conditions);\n            } elseif (is_numeric($technique)) {\n                $conditions = array('eventid' => $technique);\n                $clusterIds = $this->Server->getElligibleClusterIdsFromServerForPull($serverSync, $onlyUpdateLocalCluster = false, $elligibleClusters = array(), $conditions = $conditions);\n            } else {\n                $clusterIds = $this->Server->getElligibleClusterIdsFromServerForPull($serverSync, $onlyUpdateLocalCluster = false);\n            }\n        } catch (HttpSocketHttpException $e) {\n            if ($e->getCode() === 403) {\n                return array('error' => array(1, null));\n            } else {\n                $this->logException(\"Could not get eligible cluster IDs from server {$serverSync->serverId()} for pull.\", $e);\n                return array('error' => array(2, $e->getMessage()));\n            }\n        } catch (Exception $e) {\n            $this->logException(\"Could not get eligible cluster IDs from server {$serverSync->serverId()} for pull.\", $e);\n            return array('error' => array(2, $e->getMessage()));\n        }\n        return $clusterIds;\n    }\n\n    private function __pullGalaxyCluster($clusterId, ServerSyncTool $serverSync, array $user)\n    {\n        try {\n            $cluster = $serverSync->fetchGalaxyCluster($clusterId)->json();\n        } catch (Exception $e) {\n            $this->logException(\"Could not fetch galaxy cluster $clusterId from server {$serverSync->serverId()}\", $e);\n            return false;\n        }\n\n        $cluster = $this->updatePulledClusterBeforeInsert($cluster, $serverSync->server(), $user);\n        $result = $this->captureCluster($user, $cluster, $fromPull=true, $orgId=$serverSync->server()['Server']['org_id']);\n        return $result['success'];\n    }\n\n    private function updatePulledClusterBeforeInsert($cluster, $server, $user)\n    {\n        // The cluster came from a pull, so it should be locked and distribution should be adapted.\n        $cluster['GalaxyCluster']['locked'] = true;\n        if (!isset($cluster['GalaxyCluster']['distribution'])) {\n            $cluster['GalaxyCluster']['distribution'] = '1';\n        }\n\n        if (empty(Configure::read('MISP.host_org_id')) || !$server['Server']['internal'] || Configure::read('MISP.host_org_id') != $server['Server']['org_id']) {\n            switch ($cluster['GalaxyCluster']['distribution']) {\n                case 1:\n                    $cluster['GalaxyCluster']['distribution'] = 0; // if community only, downgrade to org only after pull\n                    break;\n                case 2:\n                    $cluster['GalaxyCluster']['distribution'] = 1; // if connected communities downgrade to community only\n                    break;\n            }\n\n            if (!empty($cluster['GalaxyCluster']['GalaxyClusterRelation'])) {\n                foreach ($cluster['GalaxyCluster']['GalaxyClusterRelation'] as $k => $relation) {\n                    switch ($relation['distribution']) {\n                        case 1:\n                            $cluster['GalaxyCluster']['GalaxyClusterRelation'][$k]['distribution'] = 0;\n                            break;\n                        case 2:\n                            $cluster['GalaxyCluster']['GalaxyClusterRelation'][$k]['distribution'] = 1;\n                            break;\n                    }\n                }\n            }\n        }\n        return $cluster;\n    }\n\n    public function attachClusterToRelations($user, $cluster, $both=true)\n    {\n        if (!empty($cluster['GalaxyCluster']['GalaxyClusterRelation'])) {\n            foreach ($cluster['GalaxyCluster']['GalaxyClusterRelation'] as $k => $relation) {\n                $conditions = array('conditions' => array('GalaxyCluster.uuid' => $relation['referenced_galaxy_cluster_uuid']));\n                $relatedCluster = $this->fetchGalaxyClusters($user, $conditions, false);\n                if (!empty($relatedCluster)) {\n                    $cluster['GalaxyCluster']['GalaxyClusterRelation'][$k]['GalaxyCluster'] = $relatedCluster[0]['GalaxyCluster'];\n                }\n            }\n        }\n        if ($both) {\n            if (!empty($cluster['GalaxyCluster']['TargetingClusterRelation'])) {\n                foreach ($cluster['GalaxyCluster']['TargetingClusterRelation'] as $k => $relation) {\n                    $conditions = array('conditions' => array('GalaxyCluster.uuid' => $relation['galaxy_cluster_uuid']));\n                    $relatedCluster = $this->fetchGalaxyClusters($user, $conditions, false);\n                    if (!empty($relatedCluster)) {\n                        $cluster['GalaxyCluster']['TargetingClusterRelation'][$k]['GalaxyCluster'] = $relatedCluster[0]['GalaxyCluster'];\n                    }\n                }\n            }\n        }\n        return $cluster;\n    }\n\n    public function cacheGalaxyClusterIDs($user)\n    {\n        if (isset($this->__assetCache['gcids'])) {\n            return $this->__assetCache['gcids'];\n        } else {\n            $gcids = $this->fetchGalaxyClusters($user, array(\n                'fields' => 'id',\n            ), false);\n            $alias = $this->alias;\n            $gcids = Hash::extract($gcids, \"{n}.${alias}.id\");\n            if (empty($gcids)) {\n                $gcids = array(-1);\n            }\n            $this->__assetCache['gcids'] = $gcids;\n            return $gcids;\n        }\n    }\n    public function cacheGalaxyClusterOwnerIDs($user)\n    {\n        if (isset($this->__assetCache['gcOwnerIds'])) {\n            return $this->__assetCache['gcOwnerIds'];\n        } else {\n            $gcOwnerIds = $this->fetchGalaxyClusters($user, array(\n                'fields' => 'id',\n                'conditions' => array(\n                    'org_id' => $user['org_id']\n                )\n            ), false);\n            $alias = $this->alias;\n            $gcOwnerIds = Hash::extract($gcOwnerIds, \"{n}.${alias}.id\");\n            if (empty($gcOwnerIds)) {\n                $gcOwnerIds = array(-1);\n            }\n            $this->__assetCache['gcOwnerIds'] = $gcOwnerIds;\n            return $gcOwnerIds;\n        }\n    }\n    public function getTagIdByClusterId($cluster_id)\n    {\n        $cluster = $this->find('first', [\n            'recursive' => -1,\n            'conditions' => ['GalaxyCluster.id' => $cluster_id],\n            'contain' => ['Tag']\n        ]);\n        return empty($cluster['Tag']['id']) ? false : $cluster['Tag']['id'];\n    }\n\n    public function getCyCatRelations($cluster)\n    {\n        $CyCatRelations = [];\n        if (empty(Configure::read('Plugin.CyCat_enable'))) {\n            return $CyCatRelations;\n        }\n        App::uses('SyncTool', 'Tools');\n        $cycatUrl = empty(Configure::read(\"Plugin.CyCat_url\")) ? 'https://api.cycat.org': Configure::read(\"Plugin.CyCat_url\");\n        $syncTool = new SyncTool();\n        if (empty($this->HttpSocket)) {\n            $this->HttpSocket = $syncTool->createHttpSocket();\n        }\n        $request = array(\n            'header' => array(\n                'Accept' => array('application/json'),\n                'MISP-version' => implode('.', $this->checkMISPVersion()),\n                'MISP-uuid' => Configure::read('MISP.uuid'),\n                'x-ground-truth' => 'Dogs are superior to cats'\n            )\n        );\n        $response = $this->HttpSocket->get($cycatUrl . '/lookup/' . $cluster['GalaxyCluster']['uuid'], array(), $request);\n        if ($response->code === '200') {\n            $response = $this->HttpSocket->get($cycatUrl . '/relationships/' . $cluster['GalaxyCluster']['uuid'], array(), $request);\n            if ($response->code === '200') {\n                $relationUUIDs = json_decode($response->body);\n                if (!empty($relationUUIDs)) {\n                    foreach ($relationUUIDs as $relationUUID) {\n                        $response = $this->HttpSocket->get($cycatUrl . '/lookup/' . $relationUUID, array(), $request);\n                        if ($response->code === '200') {\n                            $lookupResult = json_decode($response->body, true);\n                            $lookupResult['uuid'] = $relationUUID;\n                            $CyCatRelations[$relationUUID] = $lookupResult;\n                        }\n                    }\n                }\n            }\n        }\n        return $CyCatRelations;\n    }\n}\n", "<?php\nApp::uses('AppModel', 'Model');\nApp::uses('WorkflowGraphTool', 'Tools');\nApp::uses('Folder', 'Utility');\n\nclass WorkflowDuplicatedModuleIDException extends Exception {}\nclass TriggerNotFoundException extends Exception {}\nclass ModuleNotFoundException extends Exception {}\nclass WorkflowNotFoundException extends Exception {}\n\nclass Workflow extends AppModel\n{\n    public $recursive = -1;\n\n    public $actsAs = [\n        'AuditLog',\n        'Containable',\n        'SysLogLogable.SysLogLogable' => [\n            'roleModel' => 'Role',\n            'roleKey' => 'role_id',\n            'change' => 'full'\n        ],\n    ];\n\n    public $belongsTo = [\n    ];\n\n    public $validate = [\n        'value' => [\n            'stringNotEmpty' => [\n                'rule' => ['stringNotEmpty']\n            ]\n        ],\n        'uuid' => [\n            'uuid' => [\n                'rule' => 'uuid',\n                'message' => 'Please provide a valid RFC 4122 UUID'\n            ],\n            'unique' => [\n                'rule' => 'isUnique',\n                'message' => 'The UUID provided is not unique',\n                'required' => 'create'\n            ]\n        ],\n        'data' => [\n            'hasAcyclicGraph' => [\n                'rule' => ['hasAcyclicGraph'],\n                'message' => 'Cannot save a workflow containing a cycle',\n            ],\n            'hasOneTrigger' => [\n                'rule' => ['hasOneTrigger'],\n                'message' => 'Cannot save a workflow containing no or more than one trigger',\n            ],\n            'satisfiesMultipleConnectionCondition' => [\n                'rule' => ['satisfiesMultipleConnectionCondition'],\n                'message' => 'Cannot save a workflow having more than one connection per output',\n            ]\n        ]\n    ];\n\n    /** @var WorkflowGraphTool */\n    public $workflowGraphTool;\n    public $defaultContain = [\n    ];\n\n    private $loaded_modules = [];\n    private $loaded_classes = [];\n    private $error_while_loading = [];\n\n    private $module_initialized = false;\n    private $modules_enabled_by_default = ['generic-if', 'distribution-if', 'published-if', 'organisation-if', 'tag-if', 'concurrent-task', 'stop-execution', 'webhook', 'push-zmq'];\n\n    const CAPTURE_FIELDS_EDIT = ['name', 'description', 'timestamp', 'data', 'debug_enabled'];\n    const CAPTURE_FIELDS_ADD = ['uuid', 'name', 'description', 'timestamp', 'data', 'trigger_id', 'debug_enabled'];\n\n    const MODULE_ROOT_PATH = APP . 'Model/WorkflowModules/';\n    const CUSTOM_MODULE_ROOT_PATH = APP . 'Lib/WorkflowModules/';\n    const REDIS_KEY_WORKFLOW_NAMESPACE = 'workflow';\n    const REDIS_KEY_WORKFLOW_PER_TRIGGER = 'workflow:workflow_list:%s';\n    const REDIS_KEY_TRIGGER_PER_WORKFLOW = 'workflow:trigger_list:%s';\n    const REDIS_KEY_MODULES_ENABLED = 'workflow:modules_enabled';\n\n    public function __construct($id = false, $table = null, $ds = null)\n    {\n        parent::__construct($id, $table, $ds);\n        $this->workflowGraphTool = new WorkflowGraphTool();\n    }\n\n    public function beforeValidate($options = array())\n    {\n        parent::beforeValidate();\n        if (empty($this->data['Workflow']['uuid'])) {\n            $this->data['Workflow']['uuid'] = CakeText::uuid();\n        } else {\n            $this->data['Workflow']['uuid'] = strtolower($this->data['Workflow']['uuid']);\n        }\n        if (empty($this->data['Workflow']['data'])) {\n            $this->data['Workflow']['data'] = [];\n        }\n        if (empty($this->data['Workflow']['timestamp'])) {\n            $this->data['Workflow']['timestamp'] = time();\n        }\n        if (empty($this->data['Workflow']['description'])) {\n            $this->data['Workflow']['description'] = '';\n        }\n        return true;\n    }\n\n    public function afterFind($results, $primary = false)\n    {\n        foreach ($results as $k => $result) {\n            if (empty($result['Workflow']['data'])) {\n                $result['Workflow']['data'] = '{}';\n            }\n            $results[$k]['Workflow']['data'] = JsonTool::decode($result['Workflow']['data']);\n            if (!empty($result['Workflow']['id'])) {\n                $trigger_ids = $this->__getTriggersIDPerWorkflow((int) $result['Workflow']['id']);\n                $results[$k]['Workflow']['listening_triggers'] = $this->getModuleByID($trigger_ids);\n            }\n        }\n        return $results;\n    }\n\n    public function beforeSave($options = [])\n    {\n        if (is_array($this->data['Workflow']['data'])) {\n            $this->data['Workflow']['data'] = JsonTool::encode($this->data['Workflow']['data']);\n        }\n        return true;\n    }\n\n    public function afterSave($created, $options = [])\n    {\n        $this->updateListeningTriggers($this->data);\n    }\n\n    public function beforeDelete($cascade = true)\n    {\n        parent::beforeDelete($cascade);\n        $workflow = $this->find('first', [ // $this->data is empty in afterDelete?!\n            'recursive' => -1,\n            'conditions' => ['Workflow.id' => $this->id]\n        ]);\n        $workflow['Workflow']['data'] = []; // Make sure not trigger are listening\n        $this->workflowToDelete = $workflow;\n    }\n\n    public function afterDelete()\n    {\n        // $this->data is empty?!\n        parent::afterDelete();\n        $this->updateListeningTriggers($this->workflowToDelete);\n    }\n\n    public function enableDefaultModules()\n    {\n        $this->toggleModules($this->modules_enabled_by_default, true, false);\n    }\n\n    /**\n     * @param string $trigger_id\n     * @return bool\n     * @throws WorkflowDuplicatedModuleIDException\n     */\n    protected function checkTriggerEnabled($trigger_id)\n    {\n        static $enabled;\n\n        if ($enabled === null) {\n            $enabled = (bool)Configure::read('Plugin.Workflow_enable');\n        }\n        if (!$enabled) {\n            return false;\n        }\n\n        $settingName = \"Plugin.Workflow_triggers_$trigger_id\";\n        $module_disabled = empty(Configure::read($settingName));\n        if ($module_disabled) {\n            return false;\n        }\n\n        $filename = sprintf('Module_%s.php', preg_replace('/[^a-zA-Z0-9_]/', '_', Inflector::underscore($trigger_id)));\n        $module_config = $this->__getClassFromModuleFiles('trigger', [$filename], false)['classConfigs'];\n        return empty($module_config['disabled']);\n    }\n\n    protected function getEnabledModules(): array\n    {\n        try {\n            $redis = $this->setupRedisWithException();\n        } catch (Exception $e) {\n            return false;\n        }\n        $list = $redis->sMembers(Workflow::REDIS_KEY_MODULES_ENABLED);\n        return !empty($list) ? $list : [];\n    }\n\n    public function toggleModule($module_id, $enable, $is_trigger=false): bool\n    {\n        if (!empty($is_trigger)) {\n            $settingName = sprintf('Plugin.Workflow_triggers_%s', $module_id);\n            $server = ClassRegistry::init('Server');\n            return $server->serverSettingsSaveValue($settingName, !empty($enable), false);\n        } else {\n            try {\n                $redis = $this->setupRedisWithException();\n            } catch (Exception $e) {\n                return false;\n            }\n            if ($enable) {\n                $redis->sAdd(Workflow::REDIS_KEY_MODULES_ENABLED, $module_id);\n            } else {\n                $redis->sRem(Workflow::REDIS_KEY_MODULES_ENABLED, $module_id);\n            }\n        }\n        return true;\n    }\n\n    public function toggleDebug($workflow_id, $enable): bool\n    {\n        $workflow = $this->fetchWorkflow($workflow_id);\n        $workflow['Workflow']['debug_enabled'] = !empty($enable);\n        $result = $this->editWorkflow($workflow);\n        return empty($result['errrors']);\n    }\n\n    public function toggleModules($module_ids, $enable, $is_trigger=false): int\n    {\n        $enabled_count = 0;\n        foreach ($module_ids as $module_id) {\n            $enabled_count += $this->toggleModule($module_id, $enable, $is_trigger) ? 1 : 0;\n        }\n        return $enabled_count;\n    }\n\n    protected function checkTriggerListenedTo($trigger_id)\n    {\n        return !empty($this->__getWorkflowsIDPerTrigger($trigger_id));\n    }\n\n    public function rebuildRedis()\n    {\n        $redis = $this->setupRedisWithException();\n        $workflows = $this->fetchWorkflows();\n        $keys = $redis->keys(Workflow::REDIS_KEY_WORKFLOW_NAMESPACE . ':*');\n        $redis->delete($keys);\n        foreach ($workflows as $wokflow) {\n            $this->updateListeningTriggers($wokflow);\n        }\n    }\n\n    /**\n     * updateListeningTriggers \n     *  - Update the list of triggers that will be run this workflow\n     *  - Update the list of workflows that are run by their triggers\n     *  - Update the ordered list of workflows that are run by their triggers\n     *\n     * @param  array $workflow\n     */\n    public function updateListeningTriggers($workflow)\n    {\n        try {\n            $redis = $this->setupRedisWithException();\n        } catch (Exception $e) {\n            $this->logException('Failed to setup redis ', $e);\n            return false;\n        }\n        if (!is_array($workflow['Workflow']['data'])) {\n            $workflow['Workflow']['data'] = JsonTool::decode($workflow['Workflow']['data']);\n        }\n        $original_trigger_list_id = $this->__getTriggersIDPerWorkflow((int)$workflow['Workflow']['id']);\n        $new_node_trigger_list = $this->workflowGraphTool->extractTriggersFromWorkflow($workflow['Workflow']['data'], true);\n        $new_node_trigger_list_per_id = Hash::combine($new_node_trigger_list, '{n}.data.id', '{n}');\n        $new_trigger_list_id = array_keys($new_node_trigger_list_per_id);\n        $trigger_to_remove = array_diff($original_trigger_list_id, $new_trigger_list_id);\n        $trigger_to_add = array_diff($new_trigger_list_id, $original_trigger_list_id);\n        if (!empty($trigger_to_remove)) {\n            $pipeline = $redis->multi();\n            foreach ($trigger_to_remove as $trigger_id) {\n                $pipeline->sRem(sprintf(Workflow::REDIS_KEY_WORKFLOW_PER_TRIGGER, $trigger_id), $workflow['Workflow']['id']);\n                $pipeline->sRem(sprintf(Workflow::REDIS_KEY_TRIGGER_PER_WORKFLOW, $workflow['Workflow']['id']), $trigger_id);\n            }\n            $pipeline->exec();\n        }\n        if (!empty($trigger_to_add)) {\n            $pipeline = $redis->multi();\n            foreach ($trigger_to_add as $trigger_id) {\n                $pipeline->sAdd(sprintf(Workflow::REDIS_KEY_WORKFLOW_PER_TRIGGER, $trigger_id), $workflow['Workflow']['id']);\n                $pipeline->sAdd(sprintf(Workflow::REDIS_KEY_TRIGGER_PER_WORKFLOW, $workflow['Workflow']['id']), $trigger_id);\n            }\n            $pipeline->exec();\n        }\n    }\n\n    /**\n     * __getWorkflowsIDPerTrigger Get list of workflow IDs listening to the specified trigger\n     *\n     * @param  string $trigger_id\n     * @return bool|array\n     */\n    private function __getWorkflowsIDPerTrigger($trigger_id): array\n    {\n        try {\n            $redis = $this->setupRedisWithException();\n        } catch (Exception $e) {\n            return false;\n        }\n        $list = $redis->sMembers(sprintf(Workflow::REDIS_KEY_WORKFLOW_PER_TRIGGER, $trigger_id));\n        return !empty($list) ? $list : [];\n    }\n\n    /**\n     * __getTriggersIDPerWorkflow Get list of trigger name running to the specified workflow\n     *\n     * @param  int $workflow_id\n     * @return bool|array\n     */\n    private function __getTriggersIDPerWorkflow(int $workflow_id)\n    {\n        try {\n            $redis = $this->setupRedisWithException();\n        } catch (Exception $e) {\n            return false;\n        }\n        return $redis->sMembers(sprintf(Workflow::REDIS_KEY_TRIGGER_PER_WORKFLOW, $workflow_id));\n    }\n\n    public function getListeningWorkflowForTrigger(array $trigger): array\n    {\n        return array_map(function($id) {\n            return intval($id);\n        }, $this->__getWorkflowsIDPerTrigger($trigger['id']));\n    }\n\n    /**\n     * attachWorkflowToTriggers Collect the workflows listening to this trigger\n     *\n     * @param  array $triggers\n     * @return array\n     */\n    public function attachWorkflowToTriggers(array $triggers): array\n    {\n        $workflows = $this->fetchWorkflows([\n            'conditions' => [\n                'Workflow.trigger_id' => Hash::extract($triggers, '{n}.id'),\n            ],\n            'fields' => ['*'],\n        ]);\n        $workflows_per_trigger = Hash::combine($workflows, '{n}.Workflow.trigger_id', '{n}');\n        foreach ($triggers as $i => $trigger) {\n            if (!empty($workflows_per_trigger[$trigger['id']])) {\n                $triggers[$i]['Workflow'] = $workflows_per_trigger[$trigger['id']]['Workflow'];\n            }\n        }\n        return $triggers;\n    }\n\n    /**\n     * hasAcyclicGraph Return if the graph is acyclic or not\n     *\n     * @param array $graphData\n     * @return boolean\n     */\n    public function hasAcyclicGraph(array $workflow): bool\n    {\n        $graphData = !empty($workflow['Workflow']) ? $workflow['Workflow']['data'] : $workflow['data'];\n        $isAcyclic = $this->workflowGraphTool->isAcyclic($graphData);\n        return $isAcyclic;\n    }\n\n    /**\n     * hasOneTrigger Return if the graph contain more than one instance of the same trigger\n     *\n     * @param array $graphData\n     * @return boolean\n     */\n    public function hasOneTrigger(array $workflow): bool\n    {\n        $graphData = !empty($workflow['Workflow']) ? $workflow['Workflow']['data'] : $workflow['data'];\n        $triggers = $this->workflowGraphTool->extractTriggersFromWorkflow($graphData, true);\n        return count($triggers) == 1;\n    }\n\n    /**\n     * satisfiesMultipleConnectionCondition Return if the graph contain more than one instance of the same trigger\n     *\n     * @param array $graphData\n     * @return boolean\n     */\n    public function satisfiesMultipleConnectionCondition(array $workflow): bool\n    {\n        $graphData = !empty($workflow['Workflow']) ? $workflow['Workflow']['data'] : $workflow['data'];\n        $hasMultipleOutputConnection = $this->workflowGraphTool->hasMultipleOutputConnection($graphData);\n        return !$hasMultipleOutputConnection;\n    }\n\n    /**\n     * executeWorkflow\n     *\n     * @param int $workflow_id\n     * @param array $data\n     * @param array $blockingErrors\n     * @return array\n     */\n    public function executeWorkflow($workflow_id, array $data, array &$blockingErrors=[]): array\n    {\n        $this->loadAllWorkflowModules();\n\n        $workflow = $this->fetchWorkflow($workflow_id, true);\n        $graphData = !empty($workflow['Workflow']) ? $workflow['Workflow']['data'] : $workflow['data'];\n        $startNode = $this->workflowGraphTool->extractTriggerFromWorkflow($graphData, true);\n        $startNodeID = $startNode['id'];\n        $trigger_id = $startNode['data']['id'];\n        if ($startNode  == -1) {\n            $blockingErrors[] = __('Invalid start node `%s`', $startNodeID);\n            return false;\n        }\n\n        $triggerModule = $this->getModuleClassByType('trigger', $trigger_id, true);\n        if (!empty($triggerModule->disabled)) {\n            return true;\n        }\n        $result = $this->__runWorkflow($workflow, $triggerModule, $data, $startNodeID, $blockingErrors);\n        return $result;\n    }\n\n    /**\n     * executeWorkflowForTrigger\n     *\n     * @param string $trigger_id\n     * @param array $data\n     * @return bool\n     * @throws TriggerNotFoundException\n     */\n    public function executeWorkflowForTriggerRouter($trigger_id, array $data, array &$blockingErrors=[], array $logging=[]): bool\n    {\n        $this->loadAllWorkflowModules();\n\n        if (empty($this->loaded_modules['trigger'][$trigger_id])) {\n            throw new TriggerNotFoundException(__('Unknown trigger `%s`', $trigger_id));\n        }\n        $trigger = $this->loaded_modules['trigger'][$trigger_id];\n        if (!empty($trigger['disabled'])) {\n            return true;\n        }\n\n        if (empty($trigger['blocking'])) {\n            $this->Job = ClassRegistry::init('Job');\n            $jobId = $this->Job->createJob(\n                'SYSTEM',\n                Job::WORKER_PRIO,\n                'executeWorkflowForTrigger',\n                sprintf('Workflow for trigger `%s`', $trigger_id),\n                __('Executing non-blocking workflow for trigger `%s`', $trigger_id)\n            );\n            $this->Job->getBackgroundJobsTool()->enqueue(\n                BackgroundJobsTool::PRIO_QUEUE,\n                BackgroundJobsTool::CMD_WORKFLOW,\n                [\n                    'executeWorkflowForTrigger',\n                    $trigger_id,\n                    JsonTool::encode($data),\n                    JsonTool::encode($logging),\n                    $jobId\n                ],\n                true,\n                $jobId\n            );\n            return true;\n        } else {\n            $blockingPathExecutionSuccess = $this->executeWorkflowForTrigger($trigger_id, $data, $blockingErrors);\n            return $blockingPathExecutionSuccess;\n        }\n    }\n\n    /**\n     * executeWorkflowForTrigger\n     *\n     * @param string $trigger_id\n     * @param array $data\n     * @param array $errors\n     * @return boolean True if the execution for the blocking path was a success\n     * @throws TriggerNotFoundException\n     */\n    public function executeWorkflowForTrigger($trigger_id, array $data, array &$blockingErrors=[]): bool\n    {\n        $this->loadAllWorkflowModules();\n\n        $triggerModule = $this->getModuleClassByType('trigger', $trigger_id, true);\n        if (!empty($triggerModule->disabled)) {\n            return true;\n        }\n\n        $workflow = $this->fetchWorkflowByTrigger($trigger_id, true);\n        if (empty($workflow)) {\n            throw new WorkflowNotFoundException(__('Could not get workflow for trigger `%s`', $trigger_id));\n        }\n        $graphData = !empty($workflow['Workflow']) ? $workflow['Workflow']['data'] : $workflow['data'];\n        $startNodeID = $this->workflowGraphTool->getNodeIdForTrigger($graphData, $trigger_id);\n        if ($startNodeID  == -1) {\n            $blockingErrors[] = __('Invalid start node `%s`', $startNodeID);\n            return false;\n        }\n        $result = $this->__runWorkflow($workflow, $triggerModule, $data, $startNodeID, $blockingErrors);\n        return $result['success'];\n    }\n\n    /**\n     * runWorkflow\n     *\n     * @param array $workflow\n     * @param $triggerModule\n     * @param array $data\n     * @param int $startNodeID\n     * @return array\n     */\n    private function __runWorkflow(array $workflow, $triggerModule, array $data, $startNodeID, &$blockingErrors=[]): array\n    {\n        $this->Log = ClassRegistry::init('Log');\n        $message =  __('Started executing workflow for trigger `%s` (%s)', $triggerModule->id, $workflow['Workflow']['id']);\n        $this->Log->createLogEntry('SYSTEM', 'execute_workflow', 'Workflow', $workflow['Workflow']['id'], $message);\n        $this->__logToFile($workflow, $message);\n        $workflow = $this->__incrementWorkflowExecutionCount($workflow);\n        $walkResult = [];\n        $debugData = ['original' => $data];\n        $data = $this->__normalizeDataForTrigger($triggerModule, $data);\n        $debugData['normalized'] = $data;\n        $for_path = !empty($triggerModule->blocking) ? GraphWalker::PATH_TYPE_BLOCKING : GraphWalker::PATH_TYPE_NON_BLOCKING;\n        $this->sendRequestToDebugEndpoint($workflow, [], '/init?type=' . $for_path, $debugData);\n\n        $blockingPathExecutionSuccess = $this->walkGraph($workflow, $startNodeID, $for_path, $data, $blockingErrors, $walkResult);\n        $executionStoppedByStopModule = in_array('stop-execution', Hash::extract($walkResult, 'blocking_nodes.{n}.data.id'));\n        if (empty($blockingPathExecutionSuccess)) {\n            $message = __('Execution stopped. %s', PHP_EOL . implode(', ', $blockingErrors));\n            $this->logExecutionError($workflow, $message);\n        }\n        $outcomeText = 'failure';\n        if (!empty($blockingPathExecutionSuccess)) {\n            $outcomeText = 'success';\n        } else if ($executionStoppedByStopModule) {\n            $outcomeText = 'blocked';\n        }\n        $message =  __('Finished executing workflow for trigger `%s` (%s). Outcome: %s', $triggerModule->id, $workflow['Workflow']['id'], $outcomeText);\n\n        $this->Log->createLogEntry('SYSTEM', 'execute_workflow', 'Workflow', $workflow['Workflow']['id'], $message);\n        $this->__logToFile($workflow, $message);\n        $this->sendRequestToDebugEndpoint($workflow, [], '/end?outcome=' . $outcomeText, $walkResult);\n        return [\n            'outcomeText' => $outcomeText,\n            'walkResult' => $walkResult,\n            'success' => $blockingPathExecutionSuccess,\n        ];\n    }\n\n    /**\n     * walkGraph Walk the graph for the provided trigger and execute each nodes\n     *\n     * @param array $workflow The worflow to walk\n     * @param int $startNode The ID of the trigger to start from\n     * @param string|null $for_path If provided, execute the workflow for the provided path. If not provided, execute the worflow regardless of the path\n     * @param array $data\n     * @param array $errors\n     * @return boolean If all module returned a successful response\n     */\n    public function walkGraph(array $workflow, int $startNode, $for_path=null, array $data=[], array &$errors=[], array &$walkResult=[]): bool\n    {\n        $walkResult = [\n            'blocking_nodes' => [],\n            'executed_nodes' => [],\n            'blocked_paths' => [],\n        ];\n        $userForWorkflow = $this->getUserForWorkflow();\n        if (empty($userForWorkflow)) {\n            $errors[] = __('Could not find a valid user to run the workflow. Please set setting `MISP.host_org_id` or make sure a valid site_admin user exists.');\n            return false;\n        }\n        $roamingData = $this->workflowGraphTool->getRoamingData($userForWorkflow, $data, $workflow, $startNode);\n        $graphData = !empty($workflow['Workflow']) ? $workflow['Workflow']['data'] : $workflow['data'];\n        $graphWalker = $this->workflowGraphTool->getWalkerIterator($graphData, $this, $startNode, $for_path, $roamingData);\n        $preventExecutionForPaths = [];\n        foreach ($graphWalker as $graphNode) {\n            $node = $graphNode['node'];\n            $moduleClass = $this->getModuleClass($node);\n            foreach ($preventExecutionForPaths as $path_to_block) {\n                if ($path_to_block == array_slice($graphNode['path_list'], 0, count($path_to_block))) {\n                    $walkResult['blocked_paths'][] = $graphNode['path_list'];\n                    continue 2;\n                }\n            }\n            $nodeError = [];\n            $success = $this->executeNode($node, $roamingData, $nodeError);\n            $walkResult['executed_nodes'][] = $node;\n            if (empty($success)) {\n                $walkResult['blocking_nodes'][] = $node;\n                if (!empty($nodeError)) {\n                    $errors[] = __(\n                        'Node `%s` (%s) from Workflow `%s` (%s) returned the following error: %s',\n                        $node['data']['id'],\n                        $node['id'],\n                        $workflow['Workflow']['name'],\n                        $workflow['Workflow']['id'],\n                        implode(', ', $nodeError)\n                    );\n                }\n                if (!empty($moduleClass->blocking)) {\n                    return false; // Node stopped execution for any path. If a module is blocking and it failed, stop the walk\n                } else if ($graphNode['path_type'] == GraphWalker::PATH_TYPE_NON_BLOCKING) {\n                    $preventExecutionForPaths[] = $graphNode['path_list']; // Paths down the chain should not be executed\n                }\n            }\n        }\n        return true;\n    }\n\n    public function getUserForWorkflow(): array\n    {\n        $this->Organisation = ClassRegistry::init('Organisation');\n        $hostOrg = $this->Organisation->find('first', [\n            'recursive' => -1,\n            'conditions' => [\n                'id' => Configure::read('MISP.host_org_id')\n            ],\n        ]);\n        if (!empty($hostOrg)) {\n            $userForWorkflow = [\n                'email' => 'SYSTEM',\n                'id' => 0,\n                'org_id' => $hostOrg['Organisation']['id'],\n                'Role' => ['perm_site_admin' => 1],\n                'Organisation' => $hostOrg['Organisation']\n            ];\n        } else {\n            $this->User = ClassRegistry::init('User');\n            $userForWorkflow = $this->User->find('first', [\n                'recursive' => -1,\n                'conditions' => [\n                    'Role.perm_site_admin' => 1,\n                    'User.disabled' => 0\n                ],\n                'contain' => [\n                    'Organisation' => ['fields' => ['name']],\n                    'Role' => ['fields' => ['*']],\n                ],\n                'fields' => ['User.org_id', 'User.id', 'User.email'],\n            ]);\n            $userForWorkflow['Server'] = [];\n            $userForWorkflow = $this->User->rearrangeToAuthForm($userForWorkflow);\n        }\n        return $userForWorkflow;\n    }\n\n    public function executeNode(array $node, WorkflowRoamingData $roamingData, array &$errors=[]): bool\n    {\n        $roamingData->setCurrentNode($node['id']);\n        $moduleClass = $this->getModuleClass($node);\n        if (!empty($moduleClass->disabled)) {\n            $message = __('Could not execute disabled module `%s`.', $node['data']['id']);\n            $this->logExecutionError($roamingData->getWorkflow(), $message);\n            $errors[] = $message;\n            $this->sendRequestToDebugEndpoint($roamingData->getWorkflow(), $node, sprintf('/exec/%s?result=%s', $moduleClass->id, 'disabled_module'), $roamingData->getData());\n            return false;\n        }\n        if (!is_null($moduleClass)) {\n            try {\n                $success = $moduleClass->exec($node, $roamingData, $errors);\n            } catch (Exception $e) {\n                $message = __('Error while executing module %s. Error: %s', $node['data']['id'], $e->getMessage());\n                $this->logExecutionError($roamingData->getWorkflow(), $message);\n                $errors[] = $message;\n                $this->sendRequestToDebugEndpoint($roamingData->getWorkflow(), $node, sprintf('/exec/%s?result=%s&message=%s', $moduleClass->id, 'error', $e->getMessage()), $roamingData->getData());\n                return false;\n            }\n        } else {\n            $message = sprintf(__('Could not load class for module: %s'), $node['data']['id']);\n            $this->logExecutionError($roamingData->getWorkflow(), $message);\n            $errors[] = $message;\n            $this->sendRequestToDebugEndpoint($roamingData->getWorkflow(), $node, sprintf('/exec/%s?result=%s', $node['data']['id'], 'loading_error'), $roamingData->getData());\n            return false;\n        }\n        $this->sendRequestToDebugEndpoint($roamingData->getWorkflow(), $node, sprintf('/exec/%s?result=%s', $moduleClass->id, 'success'), $roamingData->getData());\n        return $success;\n    }\n\n    private function __normalizeDataForTrigger($triggerClass, array $data): array\n    {\n        if (method_exists($triggerClass, 'normalizeData')) {\n            return $triggerClass->normalizeData($data);\n        }\n        return $data;\n    }\n\n    private function digestExecutionResult(array $walkResult)\n    {\n        if (empty($walkResult['Nodes that stopped execution'])) {\n            return __('All nodes executed.');\n        }\n        $str = [];\n        foreach ($walkResult['Nodes that stopped execution'] as $node) {\n            $str[] = __('Node `%s` (%s) stopped execution.', $node['data']['id'], $node['id']);\n        }\n        return implode(', ', $str);\n    }\n\n    public function getModuleClass($node)\n    {\n        $this->loadAllWorkflowModules();\n        $moduleClass = $this->loaded_classes[$node['data']['module_type']][$node['data']['id']] ?? null;\n        return $moduleClass;\n    }\n\n    /**\n     * getModuleClassByType\n     *\n     * @param string $module_type\n     * @param string $id\n     * @param boolean $throwException\n     * @return\n     * @throws ModuleNotFoundException\n     */\n    public function getModuleClassByType($module_type, $id, $throwException=false)\n    {\n        $this->loadAllWorkflowModules();\n        $moduleClass = $this->loaded_classes[$module_type][$id] ?? null;\n        if (is_null($moduleClass) && !empty($throwException)) {\n            if ($module_type == 'trigger') {\n                throw new TriggerNotFoundException(__('Unknown module `%s` for module type `%s`', $id, $module_type));\n            } else {\n                throw new ModuleNotFoundException(__('Unknown module `%s` for module type `%s`', $id, $module_type));\n            }\n        }\n        return $moduleClass;\n    }\n\n    /**\n     * getModuleConfigByType\n     *\n     * @param string $module_type\n     * @param string $id\n     * @param boolean $throwException\n     * @return array\n     * @throws ModuleNotFoundException\n     */\n    public function getModuleConfigByType($module_type, $id, $throwException=false): ?array\n    {\n        $this->loadAllWorkflowModules();\n        $moduleConfig = $this->loaded_modules[$module_type][$id] ?? null;\n        if (is_null($moduleConfig) && !empty($throwException)) {\n            throw new ModuleNotFoundException(__('Unknown module `%s` for module type `%s`', $id, $module_type));\n        }\n        return $moduleConfig;\n    }\n\n    public function attachNotificationToModules(array $modules, array $workflow): array\n    {\n        $trigger_is_misp_core_format = false;\n        $trigger_is_blocking = false;\n        $trigger_id = $this->workflowGraphTool->extractTriggerFromWorkflow($workflow['Workflow']['data'], false);\n        if (!empty($trigger_id)) {\n            $triggerClass = $this->getModuleClassByType('trigger', $trigger_id, true);\n            $trigger_is_misp_core_format = !empty($triggerClass->misp_core_format);\n            $trigger_is_blocking = !empty($triggerClass->blocking);\n        }\n        foreach ($modules as $moduleType => $modulesByType) {\n            foreach ($modulesByType as $i => $module) {\n                $modules[$moduleType][$i]['notifications'] = !empty($module['notifications']) ? $module['notifications'] : [\n                    'error' => [],\n                    'warning' => [],\n                    'info' => [],\n                ];\n                if ($module['disabled']) {\n                    $modules[$moduleType][$i]['notifications']['error'][] = [\n                        'text' => __('Module disabled'),\n                        'description' => __('This module is disabled and thus will not be executed.'),\n                        'details' => [\n                            __('Disabled modules that are blocking will also stop the execution')\n                        ],\n                        '__show_in_sidebar' => false,\n                        '__show_in_node' => true,\n                    ];\n                }\n                if (!$trigger_is_blocking && !empty($module['blocking'])) {\n                    $modules[$moduleType][$i]['notifications']['warning'][] = [\n                        'text' => __('Blocking module might not work as intended'),\n                        'description' => __('This module is a blocking module for a non-blocking trigger.'),\n                        'details' => [\n                            __('The Blocking modules will be executed. However, it will not block the remaining of the execution')\n                        ],\n                        '__show_in_sidebar' => true,\n                        '__show_in_node' => true,\n                    ];\n                }\n                if ($moduleType != 'modules_trigger') {\n                    if (!$trigger_is_misp_core_format && !empty($module['expect_misp_core_format'])) {\n                        $modules[$moduleType][$i]['notifications']['warning'][] = [\n                            'text' => __('Potential data format issue'),\n                            'description' => __('This module might not work properly as it expect data compliant with the MISP core format.'),\n                            'details' => [\n                                __('This module expect data to be compliant with the MISP core format. However, the data passed by the trigger might not be under this format.')\n                            ],\n                            '__show_in_sidebar' => true,\n                            '__show_in_node' => true,\n                        ];\n                    }\n                }\n                if ($moduleType == 'modules_action') {\n                    $moduleClass = $this->getModuleClassByType('action', $module['id']);\n                    $diagnostic = $moduleClass->diagnostic();\n                    $modules[$moduleType][$i]['notifications'] = array_merge_recursive($modules[$moduleType][$i]['notifications'], $diagnostic);\n                }\n            }\n        }\n        return $modules;\n    }\n\n    public function loadAllWorkflowModules()\n    {\n        if ($this->module_initialized) {\n            return;\n        }\n        $phpModuleFiles = Workflow::__listPHPModuleFiles();\n        foreach ($phpModuleFiles as $type => $files) {\n            if ($type == 'custom') {\n                continue;\n            }\n            $classModuleFromFiles = $this->__getClassFromModuleFiles($type, $files, false);\n            foreach ($classModuleFromFiles['classConfigs'] as $i => $config) {\n                $classModuleFromFiles['classConfigs'][$i]['module_type'] = $type;\n            }\n            $this->loaded_modules[$type] = $classModuleFromFiles['classConfigs'];\n            $this->loaded_classes[$type] = $classModuleFromFiles['instancedClasses'];\n        }\n        // Load custom PHP modules from Lib\n        foreach ($phpModuleFiles['custom'] as $type => $files) {\n            $classModuleFromFiles = $this->__getClassFromModuleFiles($type, $files, true);\n            foreach ($classModuleFromFiles['classConfigs'] as $i => $config) {\n                $classModuleFromFiles['classConfigs'][$i]['module_type'] = $type;\n            }\n            $this->loaded_modules[$type] = array_merge($this->loaded_modules[$type], $classModuleFromFiles['classConfigs']);\n            $this->loaded_classes[$type] = array_merge($this->loaded_classes[$type], $classModuleFromFiles['instancedClasses']);\n        }\n        // Load module from misp-module service\n        $modules_from_service = $this->__getModulesFromModuleService() ?? [];\n        $misp_module_class = $this->__getClassForMispModule($modules_from_service);\n        $misp_module_configs = [];\n        foreach ($misp_module_class as $i => $module_class) {\n            $misp_module_configs[$i] = $module_class->getConfig();\n            $misp_module_configs[$i]['module_type'] = 'action';\n        }\n        $this->loaded_modules['action'] = array_merge($this->loaded_modules['action'], $misp_module_configs);\n        $this->loaded_classes['action'] = array_merge($this->loaded_classes['action'], $misp_module_class);\n        $this->__mergeGlobalConfigIntoLoadedModules();\n        $this->module_initialized = true;\n    }\n\n    private function __mergeGlobalConfigIntoLoadedModules()\n    {\n        foreach ($this->loaded_modules['trigger'] as &$trigger) {\n            $module_disabled = empty(Configure::read(sprintf('Plugin.Workflow_triggers_%s', $trigger['id'])));\n            $trigger['html_template'] = !empty($trigger['html_template']) ? $trigger['html_template'] : 'trigger';\n            $trigger['disabled'] = $module_disabled;\n            $this->loaded_classes['trigger'][$trigger['id']]->disabled = $module_disabled;\n            $this->loaded_classes['trigger'][$trigger['id']]->html_template = !empty($trigger['html_template']) ? $trigger['html_template'] : 'trigger';\n        }\n        $enabledModules = $this->getEnabledModules();\n        array_walk($this->loaded_modules['logic'], function (&$logic) use ($enabledModules) {\n            $module_disabled = !in_array($logic['id'], $enabledModules);\n            $logic['disabled'] = $module_disabled;\n            $this->loaded_classes['logic'][$logic['id']]->disabled = $module_disabled;\n        });\n        array_walk($this->loaded_modules['action'], function (&$action) use ($enabledModules) {\n            $module_disabled = !in_array($action['id'], $enabledModules);\n            $action['disabled'] = $module_disabled;\n            $this->loaded_classes['action'][$action['id']]->disabled = $module_disabled;\n        });\n\n    }\n\n    private function __getEnabledModulesFromModuleService()\n    {\n        if (empty($this->Module)) {\n            $this->Module = ClassRegistry::init('Module');\n        }\n        $enabledModules = $this->Module->getEnabledModules(null, 'Action');\n        $misp_module_config = empty($enabledModules) ? false : $enabledModules;\n        return $misp_module_config;\n    }\n\n    private function __getModulesFromModuleService()\n    {\n        if (empty($this->Module)) {\n            $this->Module = ClassRegistry::init('Module');\n        }\n        $modules = $this->Module->getModules('Action');\n        if (is_array($modules)) {\n            foreach ($modules as $i => $temp) {\n                if (!isset($temp['meta']['module-type']) || !in_array('action', $temp['meta']['module-type'])) {\n                    unset($modules[$i]);\n                }\n            }\n        }\n        return $modules;\n    }\n\n    private function __getClassForMispModule($misp_module_configs)\n    {\n        $filepathMispModule = sprintf('%s/%s', Workflow::MODULE_ROOT_PATH, 'Module_misp_module.php');\n        $className = 'Module_misp_module';\n        $reflection = null;\n        try {\n            require_once($filepathMispModule);\n            try {\n                $reflection = new \\ReflectionClass($className);\n            } catch (\\ReflectionException $e) {\n                return $e->getMessage();\n            }\n        } catch (Exception $e) {\n            return $e->getMessage();\n        }\n        $moduleClasses = [];\n        if (is_array($misp_module_configs)) {\n            foreach ($misp_module_configs as $moduleConfig) {\n                $mainClass = $reflection->newInstance($moduleConfig);\n                if ($mainClass->checkLoading() === 'The Factory Must Grow') {\n                    $moduleClasses[$mainClass->id] = $mainClass;\n                }\n            }\n        }\n        return $moduleClasses;\n    }\n\n    /**\n     * __listPHPModuleFiles List all PHP modules files\n     *\n     * @param boolean|array $targetDir If provided, will only collect files from that directory\n     * @return array\n     */\n    private static function __listPHPModuleFiles($targetDir=false): array\n    {\n        $dirs = ['trigger', 'logic', 'action'];\n        if (!empty($targetDir)) {\n            $dirs = $targetDir;\n        }\n        $files = [];\n        foreach ($dirs as $dir) {\n            $folder = new Folder(Workflow::MODULE_ROOT_PATH . $dir);\n            $filesInFolder = $folder->find('.*\\.php', true);\n            $files[$dir] = array_diff($filesInFolder, ['..', '.']);\n            if ($dir == 'action' || $dir == 'logic') { // No custom module for the triggers\n                $customFolder = new Folder(Workflow::CUSTOM_MODULE_ROOT_PATH . $dir);\n                $filesInCustomFolder = $customFolder->find('.*\\.php', true);\n                $files['custom'][$dir] = array_diff($filesInCustomFolder, ['..', '.']);\n            }\n        }\n        return $files;\n    }\n\n    private function __getClassFromModuleFiles($type, $files, $isCustom=false)\n    {\n        $instancedClasses = [];\n        $classConfigs = [];\n        foreach ($files as $filename) {\n            $filepath = sprintf('%s%s/%s', (!empty($isCustom) ? Workflow::CUSTOM_MODULE_ROOT_PATH : Workflow::MODULE_ROOT_PATH), $type, $filename);\n            $instancedClass = $this->__getClassFromModuleFile($filepath);\n            if (is_string($instancedClass)) {\n                $this->__logLoadingError($filename, $instancedClass);\n                $this->error_while_loading[$filename] = $instancedClass;\n                continue;\n            }\n            if (!empty($classConfigs[$instancedClass->id])) {\n                throw new WorkflowDuplicatedModuleIDException(__('Module %s has already been defined', $instancedClass->id));\n            }\n            $classConfigs[$instancedClass->id] = $instancedClass->getConfig();\n            $instancedClasses[$instancedClass->id] = $instancedClass;\n            if (!empty($isCustom)) {\n                $classConfigs[$instancedClass->id]['is_custom'] = true;\n                $instancedClasses[$instancedClass->id]->is_custom = true;\n            }\n        }\n        return [\n            'classConfigs' => $classConfigs,\n            'instancedClasses' => $instancedClasses,\n        ];\n    }\n\n    public function logExecutionError($workflow, $message)\n    {\n        $this->Log = ClassRegistry::init('Log');\n        $this->Log->createLogEntry('SYSTEM', 'execute_workflow', 'Workflow', $workflow['Workflow']['id'], $message);\n        $this->__logToFile($workflow, $message);\n    }\n\n    /**\n     * __logToFile Log to file\n     *\n     * @param array $workflow\n     * @param string $message\n     * @return void\n     */\n    private function __logToFile($workflow, $message)\n    {\n        $logEntry = sprintf('[%s] Workflow(%s:%s). %s' . PHP_EOL, date('Y-m-d H:i:s'), $workflow['Workflow']['trigger_id'], $workflow['Workflow']['id'], $message);\n        // file_put_contents(APP . 'tmp/logs/workflow-execution.log', $logEntry, FILE_APPEND | LOCK_EX);\n        FileAccessTool::writeToFile(APP . 'tmp/logs/workflow-execution.log', $logEntry, false, true);\n    }\n\n    private function __logLoadingError($filename, $error)\n    {\n        $this->Log = ClassRegistry::init('Log');\n        $message = __('Could not load module for file `%s`.', $filename);\n        $this->Log->createLogEntry('SYSTEM', 'load_module', 'Workflow', 0, $message, $error);\n    }\n\n    /**\n     * getProcessorClass\n     *\n     * @param  string $filePath\n     * @param  string $processorMainClassName\n     * @return object|string Object loading success, string containing the error if failure\n     */\n    private function __getClassFromModuleFile($filepath)\n    {\n        $className = explode('/', $filepath);\n        $className = str_replace('.php', '', $className[count($className)-1]);\n        try {\n            if (!@include_once($filepath)) {\n                $message = __('Could not load module for path %s. File does not exist.', $filepath);\n                $this->log($message, LOG_ERR);\n                return $message;\n            }\n            try {\n                $reflection = new \\ReflectionClass($className);\n            } catch (\\ReflectionException $e) {\n                $message = __('Could not load module for path %s. Could not instanciate class', $filepath);\n                $this->logException($message, $e);\n                return $message;\n            }\n            $mainClass = $reflection->newInstance();\n            if ($mainClass->checkLoading() === 'The Factory Must Grow') {\n                return $mainClass;\n            }\n        } catch (Exception $e) {\n            $message = __('Could not load module for path %s', $filepath);\n            $this->logException($message, $e);\n            return $message;\n        }\n    }\n\n    public function getModuleLoadingError(): array\n    {\n        return $this->error_while_loading;\n    }\n\n    public function getModulesByType($module_type=false): array\n    {\n        $this->loadAllWorkflowModules();\n\n        $modules_trigger = $this->loaded_modules['trigger'];\n        $modules_logic = $this->loaded_modules['logic'];\n        $modules_action = $this->loaded_modules['action'];\n\n        $this->__sortModulesByName($modules_trigger);\n        $this->__sortModulesByName($modules_logic);\n        $this->__sortModulesByName($modules_action);\n        $modules_trigger = array_values($modules_trigger);\n        $modules_logic = array_values($modules_logic);\n        $modules_action = array_values($modules_action);\n        $modules = [\n            'modules_trigger' => $modules_trigger,\n            'modules_logic' => $modules_logic,\n            'modules_action' => $modules_action,\n        ];\n        if (!empty($module_type)) {\n            if (!empty($modules['modules_' . $module_type])) {\n                return $modules['modules_' . $module_type];\n            } else {\n                return [];\n            }\n        }\n        return $modules;\n    }\n\n    private function __sortModulesByName(&$modules)\n    {\n        uasort($modules, function ($module1, $module2) {\n            if ($module1['name'] == $module2['name']) {\n                return 0;\n            }\n            return ($module1['name'] < $module2['name']) ? -1 : 1;\n        });\n    }\n\n    public function getModules(): array\n    {\n        $modulesByType = $this->getModulesByType();\n        return array_merge($modulesByType['modules_trigger'], $modulesByType['modules_logic'], $modulesByType['modules_action']);\n    }\n\n    /**\n     * getModules Return the module from the provided ID\n     *\n     * @param string|array $module_ids\n     * @return array\n     */\n    public function getModuleByID($module_ids): array\n    {\n        $returnAString = false;\n        if (!is_array($module_ids)) {\n            $returnAString = true;\n            $module_ids = [$module_ids];\n        }\n        $matchingModules = [];\n        $modules = $this->getModules();\n        foreach ($modules as $module) {\n            if (in_array($module['id'], $module_ids)) {\n                $matchingModules[] = $module;\n            }\n        }\n        if (empty($matchingModules)) {\n            return [];\n        }\n        return $returnAString ? $matchingModules[0] : $matchingModules;\n    }\n\n    private function __incrementWorkflowExecutionCount(array $workflow): array\n    {\n        $workflow['Workflow']['counter'] = intval($workflow['Workflow']['counter']) + 1;\n        $this->save($workflow, ['fieldList' => ['counter']]);\n        return $this->fetchWorkflow($workflow['Workflow']['id']);\n    }\n\n    /**\n     * fetchWorkflows\n     *\n     * @param  array $options\n     * @param  bool  $full\n     * @return array\n     */\n    public function fetchWorkflows(array $options = array(), $full = false)\n    {\n        $params = array(\n            'contain' => $this->defaultContain,\n            'recursive' => -1\n        );\n        if ($full) {\n            $params['recursive'] = 1;\n        }\n        if (isset($options['fields'])) {\n            $params['fields'] = $options['fields'];\n        }\n        if (isset($options['conditions'])) {\n            $params['conditions']['AND'][] = $options['conditions'];\n        }\n        if (isset($options['group'])) {\n            $params['group'] = !empty($options['group']) ? $options['group'] : false;\n        }\n        if (isset($options['contain'])) {\n            $params['contain'] = !empty($options['contain']) ? $options['contain'] : [];\n        }\n\n        $params['order'] = [];\n        if (!empty($options['order'])) {\n            $options['order'] = $this->findOrder(\n                $options['order'],\n                'Workflow',\n                ['id', 'name', 'timestmap', 'trigger_id', 'counter']\n            );\n        }\n\n        $workflows = $this->find('all', $params);\n        return $workflows;\n    }\n\n    /**\n     * fetchWorkflow\n     *\n     * @param  int|string $id\n     * @param  bool $throwErrors\n     * @throws NotFoundException\n     * @return array\n     */\n    public function fetchWorkflow($id, bool $throwErrors = true): array\n    {\n        $options = [];\n        if (is_numeric($id)) {\n            $options = ['conditions' => ['Workflow.id' => $id]];\n        } elseif (Validation::uuid($id)) {\n            $options = ['conditions' => ['Workflow.uuid' => $id]];\n        } else {\n            if ($throwErrors) {\n                throw new NotFoundException(__('Invalid workflow'));\n            }\n            return [];\n        }\n        $workflow = $this->fetchWorkflows($options);\n        if (empty($workflow)) {\n            if ($throwErrors) {\n                throw new NotFoundException(__('Invalid workflow'));\n            }\n            return [];\n        }\n        return $workflow[0];\n    }\n\n    /**\n     * fetchWorkflowByTrigger\n     *\n     * @param  int|string $trigger_id\n     * @param  bool $throwErrors\n     * @throws NotFoundException\n     * @return array\n     */\n    public function fetchWorkflowByTrigger($trigger_id, bool $throwErrors = true): array\n    {\n        $options = [\n            'conditions' => [\n                'Workflow.trigger_id' => $trigger_id,\n            ]\n        ];\n        $workflow = $this->fetchWorkflows($options);\n        if (empty($workflow)) {\n            if ($throwErrors) {\n                throw new NotFoundException(__('Invalid workflow'));\n            }\n            return [];\n        }\n        return $workflow[0];\n    }\n\n    /**\n     * addWorkflow Add a worflow\n     *\n     * @param  array $trigger\n     * @return array Any errors preventing the edition\n     */\n    public function addWorkflow(array $workflow): array\n    {\n        $errors = [];\n        $this->create();\n        $saved = $this->__saveAndReturnErrors($workflow, ['fieldList' => self::CAPTURE_FIELDS_ADD], $errors);\n        return [\n            'saved' => $saved,\n            'errors' => $errors,\n        ];\n    }\n\n    /**\n     * editWorkflow Edit a worflow\n     *\n     * @param  array $workflow\n     * @return array Any errors preventing the edition\n     */\n    public function editWorkflow(array $workflow): array\n    {\n        $errors = [];\n        if (!isset($workflow['Workflow']['uuid'])) {\n            $errors[] = __('Workflow doesn\\'t have an UUID');\n            return $errors;\n        }\n        $existingWorkflow = $this->fetchWorkflow($workflow['Workflow']['id']);\n        $workflow['Workflow']['id'] = $existingWorkflow['Workflow']['id'];\n        unset($workflow['Workflow']['timestamp']);\n        $saved = $this->__saveAndReturnErrors($workflow, ['fieldList' => self::CAPTURE_FIELDS_EDIT], $errors);\n        return [\n            'saved' => $saved,\n            'errors' => $errors,\n        ];\n    }\n\n    /**\n     * genGraphDataForTrigger Generate fake graph data under the drawflow format\n     *\n     * @param string $trigger_id\n     * @return array\n     */\n    public function genGraphDataForTrigger($trigger_id): array\n    {\n        if (empty($this->loaded_modules['trigger'][$trigger_id])) {\n            throw new TriggerNotFoundException(__('Unknown trigger `%s`', $trigger_id));\n        }\n        $module_config = $this->loaded_modules['trigger'][$trigger_id];\n        $data = [\n            1 => [\n                'class' => 'block-type-trigger',\n                'data' => $module_config,\n                'id' => 1,\n                'inputs' => [],\n                'outputs' => [\n                    'output_1' => [\n                        'connections' => []\n                    ],\n                ],\n                'pos_x' => 0,\n                'pos_y' => 0,\n                'typenode' => false,\n            ]\n        ];\n        return $data;\n    }\n\n    /**\n     * moduleSattelesExecution Executes a module using the provided configuration and returns back the result\n     *\n     * @param string $module_id\n     * @param string|array $input_data\n     * @param array $param_data\n     * @return array\n     */\n    public function moduleStatelessExecution(string $module_id, $input_data=[], array $param_data=[], bool $convert_data=true): array\n    {\n        $result = [];\n        $input_data = !empty($input_data) ? $input_data : [];\n        $data = $input_data;\n        if (!empty($convert_data)) {\n            $eventPublishTrigger = $this->getModuleClassByType('trigger', 'event-publish');\n            $data = $this->__normalizeDataForTrigger($eventPublishTrigger, $input_data);\n        }\n        $module_config = $this->getModuleByID($module_id);\n        $node = $this->genNodeFromConfig($module_config, $param_data);\n        $module_class = $this->getModuleClass($node);\n        $user_for_workflow = $this->getUserForWorkflow();\n        if (empty($user_for_workflow)) {\n            $result['error'][] = __('Could not find a valid user to run the workflow. Please set setting `MISP.host_org_id` or make sure a valid site_admin user exists.');\n            return $result;\n        }\n        $roaming_data = $this->workflowGraphTool->getRoamingData($user_for_workflow, $data);\n        $errors = [];\n        $success = $module_class->exec($node, $roaming_data, $errors);\n        $result['success'] = $success;\n        $result['errors'] = $errors;\n        return $result;\n    }\n\n    public function genNodeFromConfig(array $module_config, $indexed_params): array\n    {\n        $node = [\n            'id' => 1,\n            'name' => $module_config['name'],\n            'data' => [\n                'id' => $module_config['id'],\n                'name' => $module_config['name'],\n                'module_type' => $module_config['module_type'],\n                'module_version' => $module_config['version'],\n                'indexed_params' => $indexed_params,\n                'saved_filters' => $module_config['saved_filters'],\n                'module_data' => $module_config,\n            ],\n            'inputs' => [],\n            'outputs' => [],\n        ];\n        return $node;\n    }\n\n    /**\n     * hasPathWarnings\n     *\n     * @param array $graphData\n     * @param array $edges\n     * @return boolean\n     */\n    public function hasPathWarnings(array $graphData, array &$edges=[])\n    {\n        $startNodes = $this->workflowGraphTool->extractConcurrentTasksFromWorkflow($graphData, true);\n        $concurrentNodeIDs = Hash::extract($startNodes, '{n}.id');\n        $roamingData = $this->workflowGraphTool->getRoamingData();\n        foreach ($concurrentNodeIDs as $concurrentNodeID) {\n            $graphWalker = $this->workflowGraphTool->getWalkerIterator($graphData, $this, $concurrentNodeID, GraphWalker::PATH_TYPE_INCLUDE_LOGIC, $roamingData);\n            foreach ($graphWalker as $graphNode) {\n                $moduleClass = $this->getModuleClass($graphNode['node']);\n                if (!empty($moduleClass->blocking)) {\n                    $parsedPathList = GraphWalker::parsePathList($graphNode['path_list']);\n                    foreach ($parsedPathList as $pathEntry) {\n                        $edges[] = [\n                            $pathEntry['source_id'],\n                            $pathEntry['next_node_id'],\n                            __('This path leads to a blocking node from a non-blocking context'),\n                            $moduleClass->blocking,\n                            $moduleClass->id,\n                            $graphNode['node']['id'],\n                        ];\n                    }\n                }\n            }\n        }\n        return !empty($edges);\n    }\n\n    private function __saveAndReturnErrors($data, $saveOptions = [], &$errors = [])\n    {\n        $saveSuccess = $this->save($data, $saveOptions);\n        if (!$saveSuccess) {\n            foreach ($this->validationErrors as $validationError) {\n                $errors[] = $validationError[0];\n            }\n        } else {\n            if (!empty($saveSuccess['Workflow']['data'])) {\n                $saveSuccess['Workflow']['data'] = JsonTool::decode($saveSuccess['Workflow']['data']);\n            }\n        }\n        return $saveSuccess;\n    }\n\n    public function sendRequestToDebugEndpoint(array $workflow, array $node, $path='/', array $data=[])\n    {\n        $debug_url = Configure::read('Plugin.Workflow_debug_url');\n        if (empty($workflow['Workflow']['debug_enabled'])) {\n            return;\n        }\n        App::uses('HttpSocket', 'Network/Http');\n        $socket = new HttpSocket([\n            'timeout' => 5\n        ]);\n        $uri = sprintf('%s/%s%s', $debug_url, $workflow['Workflow']['trigger_id'], $path);\n        $dataToPost = [\n            'source' => [\n                'node_id' => $node['id'] ?? '',\n                'module_id' => $node['data']['id'] ?? '',\n                'filters' => $node['data']['saved_filters'] ?? '',\n                'parameters' => $node['data']['indexed_params'] ?? '',\n            ],\n            'timestamp' => date(\"c\"),\n            'data' => $data,\n        ];\n        $socket->post($uri, JsonTool::encode($dataToPost));\n    }\n    \n    public function getDotNotation($id)\n    {\n        App::uses('GraphvizDOTTool', 'Tools');\n        $workflow = $this->fetchWorkflow($id);\n        $dot = GraphvizDOTTool::dot($workflow['Workflow']['data']);\n        return $dot;\n    }\n    \n    public function getMermaid($id)\n    {\n        App::uses('MermaidFlowchartTool', 'Tools');\n        $workflow = $this->fetchWorkflow($id);\n        $mermaid = MermaidFlowchartTool::mermaid($workflow['Workflow']['data']);\n        return $mermaid;\n    }\n}\n", "<?php\n\n/**\n * Logs saves and deletes of any model\n *\n * Requires the following to work as intended :\n *\n * - \"Log\" model ( empty but for a order variable [created DESC]\n * - \"logs\" table with these fields required :\n * - id\t\t\t[int]\t\t\t:\n * - title\t\t[string]\t\t: automagically filled with the display field of the model that was modified.\n * - created\t[date/datetime] : filled by cake in normal way\n *\n * - actsAs = array(\"Logable\"); on models that should be logged\n *\n * Optional extra table fields for the \"logs\" table :\n *\n * - \"description\"\t[string] : Fill with a descriptive text of what, who and to which model/row :\n * \"Contact \"John Smith\"(34) added by User \"Administrator\"(1).\n *\n * or if u want more detail, add any combination of the following :\n *\n * - \"model\"    \t[string] : automagically filled with the class name of the model that generated the activity.\n * - \"model_id\"\t[int]\t: automagically filled with the primary key of the model that was modified.\n * - \"action\"   \t[string] : automagically filled with what action is made (add/edit/delete)\n * - \"user_id\"  \t[int]    : populated with the supplied user info. (May be renamed. See bellow.)\n * - \"change\"   \t[string] : depending on setting either :\n * [name (alek) => (Alek), age (28) => (29)] or [name, age]\n *\n * - \"version_id\"\t[int]\t: cooperates with RevisionBehavior to link the shadow table (thus linking to old data)\n *\n * Remember that Logable behavior needs to be added after RevisionBehavior. In fact, just put it last to be safe.\n *\n * Optionally register what user was responsible for the activity :\n *\n * - Supply configuration only if defaults are wrong. Example given with defaults :\n *\n * class Apple extends AppModel {\n * var $name = 'Apple';\n * var $actsAs = array('Logable' => array('userModel' => 'User', 'userKey' => 'user_id'));\n * [..]\n *\n * - In AppController (or single controller if only needed once) add these lines to beforeFilter :\n *\n * if (sizeof($this->uses) && $this->{$this->modelClass}->Behaviors->attached('Logable')) {\n * $this->{$this->modelClass}->setUserData($this->activeUser);\n * }\n *\n * This is not used any longer, as AuthComponent collect the user data instead.\n *\n * Where \"$activeUser\" should be an array in the standard format for the User model used :\n *\n * $activeUser = array( $UserModel->alias => array( $UserModel->primaryKey => 123, $UserModel->displayField => 'Alexander'));\n * // any other key is just ignored by this behaviour.\n *\n * @author Alexander Morland (alexander#maritimecolours.no)\n * @co-author Eskil Mjelva Saatvedt\n * @co-author Ronny Vindenes\n * @co-author Carl Erik Fyllingen\n * @contributor Miha\n * @category Behavior\n * @version 2.3\n * @modified 15.november 2011 by Eskil\n */\n\nclass LogableBehavior extends ModelBehavior {\n\n\tpublic $user = NULL;\n\n\tpublic $UserModel = false;\n\n\tpublic $settings = array();\n\n\tpublic $defaults = array(\n\t\t\t'enabled' => true,\n\t\t\t'userModel' => 'User',\n\t\t\t'userKey' => 'user_id',\n\t\t\t'change' => 'list',\n\t\t\t'description_ids' => true,\n\t\t\t'skip' => array(),\n\t\t\t'ignore' => array(),\n\t\t\t'classField' => 'model',\n\t\t\t'foreignKey' => 'model_id');\n\n\tpublic $schema = array();\n\n\t/**\n\t * Cake called intializer\n\t * Config options are :\n\t * userModel\t\t: 'User'. Class name of the user model you want to use (User by default), if you want to save User in log\n\t * userKey   \t\t: 'user_id'. The field for saving the user to (user_id by default).\n\t * change    \t\t: 'list' > [name, age]. Set to 'full' for [name (alek) => (Alek), age (28) => (29)]\n\t * description_ids\t: true. Set to false to not include model id and user id in the title field\n\t * skip  \t\t\t: array(). String array of actions to not log\n\t *\n\t * @param Object $Model\n\t * @param array $config\n\t */\n\tfunction setup(Model $Model, $config = array()) {\n\n\t\tif (!is_array($config)) {\n\t\t\t$config = array();\n\t\t}\n\t\t$this->settings[$Model->alias] = array_merge($this->defaults, $config);\n\t\t$this->settings[$Model->alias]['ignore'][] = $Model->primaryKey;\n\n\t\t$this->Log = ClassRegistry::init('Log');\n\t\tif ($this->settings[$Model->alias]['userModel'] != $Model->alias) {\n\t\t\t$this->UserModel = ClassRegistry::init($this->settings[$Model->alias]['userModel']);\n\t\t} else {\n\t\t\t$this->UserModel = $Model;\n\t\t}\n\t\t$this->schema = $this->Log->schema();\n\t\tApp::uses('AuthComponent', 'Controller/Component');\n\t\t$this->user[$this->settings[$Model->alias]['userModel']] = AuthComponent::user();\n\t}\n\n\tfunction settings(&$Model) {\n\n\t\treturn $this->settings[$Model->alias];\n\t}\n\n\tfunction enableLog(&$Model, $enable = null) {\n\n\t\tif ($enable !== null) {\n\t\t\t$this->settings[$Model->alias]['enabled'] = $enable;\n\t\t}\n\t\treturn $this->settings[$Model->alias]['enabled'];\n\t}\n\n\t/**\n\t * Useful for getting logs for a model, takes params to narrow find.\n\t * This method can actually also be used to find logs for all models or\n\t * even another model. Using no params will return all activities for\n\t * the models it is called from.\n\t *\n\t * Possible params :\n\t * 'model'\t\t: mixed  (NULL) String with className, NULL to get current or false to get everything\n\t * 'action'\t: string (NULL) String with action (add/edit/delete), NULL gets all\n\t * 'order'\t\t: string ('created DESC') String with custom order\n\t * 'conditions  : array  (array()) Add custom conditions\n\t * 'model_id'\t: int\t (NULL) Add a int\n\t *\n\t * (remember to use your own user key if you're not using 'user_id')\n\t * 'user_id'\t: int\t (NULL) Defaults to all users, supply id if you want for only one User\n\t *\n\t * @param Object $Model\n\t * @param array $params\n\t * @return array\n\t */\n\tfunction findLog(&$Model, $params = array()) {\n\n\t\t$defaults = array(\n\t\t\t\t$this->settings[$Model->alias]['classField'] => NULL,\n\t\t\t\t'action' => NULL,\n\t\t\t\t'order' => 'created DESC',\n\t\t\t\t$this->settings[$Model->alias]['userKey'] => NULL,\n\t\t\t\t'conditions' => array(),\n\t\t\t\t$this->settings[$Model->alias]['foreignKey'] => NULL,\n\t\t\t\t'fields' => array(),\n\t\t\t\t'limit' => 50);\n\t\t$params = array_merge($defaults, $params);\n\t\t$options = array(\n\t\t\t\t'conditions' => $params['conditions'],\n\t\t\t\t'fields' => $params['fields'],\n\t\t\t\t'limit' => $params['limit']\n\t\t);\n\t\tif (!empty($options['order'])) {\n\t\t\t$options['order'] = $Model->findOrder(\n\t\t\t\t$options['order'],\n\t\t\t\t'Attribute',\n\t\t\t\t['id', 'action', 'model_id', 'model', 'ip', 'org', 'email']\n\t\t\t);\n\t\t}\n\t\tif ($params[$this->settings[$Model->alias]['classField']] === NULL) {\n\t\t\t$params[$this->settings[$Model->alias]['classField']] = $Model->alias;\n\t\t}\n\t\tif ($params[$this->settings[$Model->alias]['classField']]) {\n\t\t\tif (isset($this->schema[$this->settings[$Model->alias]['classField']])) {\n\t\t\t\t$options['conditions'][$this->settings[$Model->alias]['classField']] = $params[$this->settings[$Model->alias]['classField']];\n\t\t\t} else if (isset($this->schema['description'])) {\n\t\t\t\t$options['conditions']['description LIKE '] = $params[$this->settings[$Model->alias]['classField']] . '%';\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif ($params['action'] && isset($this->schema['action'])) {\n\t\t\t$options['conditions']['action'] = $params['action'];\n\t\t}\n\t\tif ($params[$this->settings[$Model->alias]['userKey']] && $this->UserModel && is_numeric($params[$this->settings[$Model->alias]['userKey']])) {\n\t\t\t$options['conditions'][$this->settings[$Model->alias]['userKey']] = $params[$this->settings[$Model->alias]['userKey']];\n\t\t}\n\t\tif ($params[$this->settings[$Model->alias]['foreignKey']] && is_numeric($params[$this->settings[$Model->alias]['foreignKey']])) {\n\t\t\t$options['conditions'][$this->settings[$Model->alias]['foreignKey']] = $params[$this->settings[$Model->alias]['foreignKey']];\n\t\t}\n\t\treturn $this->Log->find('all', $options);\n\t}\n\n\t/**\n\t * Get list of actions for one user.\n\t * Params for getting (one line) activity descriptions\n\t * and/or for just one model\n\t *\n\t * @example $this->Model->findUserActions(301,array('model' => 'BookTest'));\n\t * @example $this->Model->findUserActions(301,array('events' => true));\n\t * @example $this->Model->findUserActions(301,array('fields' => array('id','model'),'model' => 'BookTest');\n\t * @param Object $Model\n\t * @param int $user_id\n\t * @param array $params\n\t * @return array\n\t */\n\tfunction findUserActions(&$Model, $user_id, $params = array()) {\n\n\t\tif (!$this->UserModel) {\n\t\t\treturn NULL;\n\t\t}\n\t\t// if logged in user is asking for her own log, use the data we already have\n\t\tif (isset($this->user) && isset($this->user[$this->UserModel->alias][$this->UserModel->primaryKey]) && $user_id == $this->user[$this->UserModel->alias][$this->UserModel->primaryKey] && isset($this->user[$this->UserModel->alias][$this->UserModel->displayField])) {\n\t\t\t$username = $this->user[$this->UserModel->alias][$this->UserModel->displayField];\n\t\t} else {\n\t\t\t$this->UserModel->recursive = -1;\n\t\t\t$user = $this->UserModel->find(array(\n\t\t\t\t\t$this->UserModel->primaryKey => $user_id));\n\t\t\t$username = $user[$this->UserModel->alias][$this->UserModel->displayField];\n\t\t}\n\t\t$fields = array();\n\t\tif (isset($params['fields'])) {\n\t\t\tif (is_array($params['fields'])) {\n\t\t\t\t$fields = $params['fields'];\n\t\t\t} else {\n\t\t\t\t$fields = array(\n\t\t\t\t\t\t$params['fields']);\n\t\t\t}\n\t\t}\n\t\t$conditions = array(\n\t\t\t\t$this->settings[$Model->alias]['userKey'] => $user_id);\n\t\tif (isset($params[$this->settings[$Model->alias]['classField']])) {\n\t\t\t$conditions[$this->settings[$Model->alias]['classField']] = $params[$this->settings[$Model->alias]['classField']];\n\t\t}\n\t\t$data = $this->Log->find('all', array(\n\t\t\t\t'conditions' => $conditions,\n\t\t\t\t'recursive' => -1,\n\t\t\t\t'fields' => $fields));\n\t\tif (!isset($params['events']) || ( isset($params['events']) && $params['events'] == false )) {\n\t\t\treturn $data;\n\t\t}\n\t\t$result = array();\n\t\tforeach ( $data as $key => $row ) {\n\t\t\t$one = $row['Log'];\n\t\t\t$result[$key]['Log']['id'] = $one['id'];\n\t\t\t$result[$key]['Log']['event'] = $username;\n\t\t\t// have all the detail models and change as list :\n\t\t\tif (isset($one[$this->settings[$Model->alias]['classField']]) && isset($one['action']) && isset($one['change']) && isset($one[$this->settings[$Model->alias]['foreignKey']])) {\n\t\t\t\tif ($one['action'] == 'edit') {\n\t\t\t\t\t$result[$key]['Log']['event'] .= ' edited ' . $one['change'] . ' of ' . low($one[$this->settings[$Model->alias]['classField']]) . '(id ' . $one[$this->settings[$Model->alias]['foreignKey']] . ')';\n\n\t\t//\t' at '.$one['created'];\n\t\t\t\t} else if ($one['action'] == 'add') {\n\t\t\t\t\t$result[$key]['Log']['event'] .= ' added a ' . low($one[$this->settings[$Model->alias]['classField']]) . '(id ' . $one[$this->settings[$Model->alias]['foreignKey']] . ')';\n\t\t\t\t} else if ($one['action'] == 'delete') {\n\t\t\t\t\t$result[$key]['Log']['event'] .= ' deleted the ' . low($one[$this->settings[$Model->alias]['classField']]) . '(id ' . $one[$this->settings[$Model->alias]['foreignKey']] . ')';\n\t\t\t\t}\n\n\t\t\t} else if (isset($one[$this->settings[$Model->alias]['classField']]) && isset($one['action']) && isset($one[$this->settings[$Model->alias]['foreignKey']])) { // have model,model_id and action\n\t\t\t\tif ($one['action'] == 'edit') {\n\t\t\t\t\t$result[$key]['Log']['event'] .= ' edited ' . low($one[$this->settings[$Model->alias]['classField']]) . '(id ' . $one[$this->settings[$Model->alias]['foreignKey']] . ')';\n\n\t\t//\t' at '.$one['created'];\n\t\t\t\t} else if ($one['action'] == 'add') {\n\t\t\t\t\t$result[$key]['Log']['event'] .= ' added a ' . low($one[$this->settings[$Model->alias]['classField']]) . '(id ' . $one[$this->settings[$Model->alias]['foreignKey']] . ')';\n\t\t\t\t} else if ($one['action'] == 'delete') {\n\t\t\t\t\t$result[$key]['Log']['event'] .= ' deleted the ' . low($one[$this->settings[$Model->alias]['classField']]) . '(id ' . $one[$this->settings[$Model->alias]['foreignKey']] . ')';\n\t\t\t\t}\n\t\t\t} else { // only description field exist\n\t\t\t\t$result[$key]['Log']['event'] = $one['description'];\n\t\t\t}\n\n\t\t}\n\t\treturn $result;\n\t}\n\n\t/**\n\t * Use this to supply a model with the data of the logged in User.\n\t * Intended to be called in AppController::beforeFilter like this :\n\t *\n\t * if ($this->{$this->modelClass}->Behaviors->attached('Logable')) {\n\t * $this->{$this->modelClass}->setUserData($activeUser);/\n\t * }\n\t *\n\t * The $userData array is expected to look like the result of a\n\t * User::find(array('id'=>123));\n\t *\n\t * @param Object $Model\n\t * @param array $userData\n\t */\n\tfunction setUserData(&$Model, $userData = null) {\n\n\t\tif ($userData) {\n\t\t\t$this->user = $userData;\n\t\t}\n\t}\n\n\t/**\n\t * Used for logging custom actions that arent crud, like login or download.\n\t *\n\t * @example $this->Boat->customLog('ship', 66, array('title' => 'Titanic heads out'));\n\t * @param Object $Model\n\t * @param string $action name of action that is taking place (dont use the crud ones)\n\t * @param int $id  id of the logged item (ie model_id in logs table)\n\t * @param array $values optional other values for your logs table\n\t */\n\tfunction customLog(Model $Model, $action, $id, $values = array()) {\n\n\t\t$logData['Log'] = $values;\n\t\t/** @todo clean up $logData */\n\t\tif (isset($this->schema[$this->settings[$Model->alias]['foreignKey']]) && is_numeric($id)) {\n\t\t\t$logData['Log'][$this->settings[$Model->alias]['foreignKey']] = $id;\n\t\t}\n\t\t$title = NULL;\n\t\tif (isset($values['title'])) {\n\t\t\t$title = $values['title'];\n\t\t\tunset($logData['Log']['title']);\n\t\t}\n\t\t$logData['Log']['action'] = $action;\n\t\t$this->_saveLog($Model, $logData, $title);\n\t}\n\n\tfunction clearUserData(Model $Model) {\n\n\t\t$this->user = NULL;\n\t}\n\n\tfunction setUserIp(&$Model, $userIP = null) {\n\n\t\t$this->userIP = $userIP;\n\t}\n\n\tfunction beforeDelete(Model $Model, $cascade = true) {\n\n\t\tif (!$this->settings[$Model->alias]['enabled']) {\n\t\t\treturn true;\n\t\t}\n\t\tif (isset($this->settings[$Model->alias]['skip']['delete']) && $this->settings[$Model->alias]['skip']['delete']) {\n\t\t\treturn true;\n\t\t}\n\t\t$Model->recursive = -1;\n\t\t$Model->read();\n\t\treturn true;\n\t}\n\n\tfunction afterDelete(Model $Model) {\n\n\t\tif (!$this->settings[$Model->alias]['enabled']) {\n\t\t\treturn true;\n\t\t}\n\t\tif (isset($this->settings[$Model->alias]['skip']['delete']) && $this->settings[$Model->alias]['skip']['delete']) {\n\t\t\treturn true;\n\t\t}\n\t\t$logData = array();\n\t\tif (isset($this->schema['description'])) {\n\t\t\t$logData['Log']['description'] = $Model->alias;\n\t\t\tif (isset($Model->data[$Model->alias][$Model->displayField]) && $Model->displayField != $Model->primaryKey) {\n\t\t\t\t$logData['Log']['description'] .= ' \"' . $Model->data[$Model->alias][$Model->displayField] . '\"';\n\t\t\t}\n\t\t\tif ($this->settings[$Model->alias]['description_ids']) {\n\t\t\t\t$logData['Log']['description'] .= ' (' . $Model->id . ') ';\n\t\t\t}\n\t\t\t$logData['Log']['description'] .= __('deleted', true);\n\t\t}\n\t\t$logData['Log']['action'] = 'delete';\n\t\t$this->_saveLog($Model, $logData);\n\t}\n\n\tfunction beforeSave(Model $Model, $options = array()) {\n\n\t\tif (isset($this->schema['change']) && $Model->id) {\n\t\t\t$this->old = $Model->find('first', array(\n\t\t\t\t\t'conditions' => array(\n\t\t\t\t\t\t\t$Model->alias . '.' . $Model->primaryKey => $Model->id),\n\t\t\t\t\t'recursive' => -1));\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction afterSave(Model $Model, $created, $options = array()) {\n\n\t\tif (!$this->settings[$Model->alias]['enabled']) {\n\t\t\treturn true;\n\t\t}\n\t\tif (isset($this->settings[$Model->alias]['skip']['add']) && $this->settings[$Model->alias]['skip']['add'] && $created) {\n\t\t\treturn true;\n\t\t} else if (isset($this->settings[$Model->alias]['skip']['edit']) && $this->settings[$Model->alias]['skip']['edit'] && !$created) {\n\t\t\treturn true;\n\t\t}\n\t\t$keys = array_keys($Model->data[$Model->alias]);\n\t\t$diff = array_diff($keys, $this->settings[$Model->alias]['ignore']);\n\t\tif (sizeof($diff) == 0 && empty($Model->logableAction)) {\n\t\t\treturn false;\n\t\t}\n\t\tif ($Model->id) {\n\t\t\t$id = $Model->id;\n\t\t} else if ($Model->insertId) {\n\t\t\t$id = $Model->insertId;\n\t\t}\n\t\tif (isset($this->schema[$this->settings[$Model->alias]['foreignKey']])) {\n\t\t\t$logData['Log'][$this->settings[$Model->alias]['foreignKey']] = $id;\n\t\t}\n\t\tif (isset($this->schema['description'])) {\n\t\t\t$logData['Log']['description'] = $Model->alias . ' ';\n\t\t\tif (isset($Model->data[$Model->alias][$Model->displayField]) && $Model->displayField != $Model->primaryKey) {\n\t\t\t\t$logData['Log']['description'] .= '\"' . $Model->data[$Model->alias][$Model->displayField] . '\" ';\n\t\t\t}\n\n\t\t\tif ($this->settings[$Model->alias]['description_ids']) {\n\t\t\t\t$logData['Log']['description'] .= '(' . $id . ') ';\n\t\t\t}\n\n\t\t\tif ($created) {\n\t\t\t\t$logData['Log']['description'] .= __('added', true);\n\t\t\t} else {\n\t\t\t\t$logData['Log']['description'] .= __('updated', true);\n\t\t\t}\n\t\t}\n\t\tif (isset($this->schema['action'])) {\n\t\t\tif ($created) {\n\t\t\t\t$logData['Log']['action'] = 'add';\n\t\t\t} else {\n\t\t\t\t$logData['Log']['action'] = 'edit';\n\t\t\t}\n\n\t\t}\n\t\tif (isset($this->schema['change'])) {\n\t\t\t$logData['Log']['change'] = '';\n\t\t\t$db_fields = array_keys($Model->schema());\n\t\t\t$changed_fields = array();\n\t\t\tforeach ( $Model->data[$Model->alias] as $key => $value ) {\n\t\t\t\tif (isset($Model->data[$Model->alias][$Model->primaryKey]) && !empty($this->old) && isset($this->old[$Model->alias][$key])) {\n\t\t\t\t\t$old = $this->old[$Model->alias][$key];\n\t\t\t\t} else {\n\t\t\t\t\t$old = '';\n\t\t\t\t}\n\t\t\t\tif ($key != 'modified' && !in_array($key, $this->settings[$Model->alias]['ignore']) && $value != $old && in_array($key, $db_fields)) {\n\t\t\t\t    if ($key === 'authkey' && Configure::read('Security.do_not_log_authkeys')) {\n\t\t\t\t        $old = $value = '*****';\n                    }\n\n\t\t\t\t\tif ($this->settings[$Model->alias]['change'] == 'full') {\n\t\t\t\t\t\t$changed_fields[] = $key . ' (' . $old . ') => (' . $value . ')';\n\t\t\t\t\t} else if ($this->settings[$Model->alias]['change'] == 'serialize') {\n\t\t\t\t\t\t$changed_fields[$key] = array(\n\t\t\t\t\t\t\t\t'old' => $old,\n\t\t\t\t\t\t\t\t'value' => $value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$changed_fields[] = $key;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t$changes = sizeof($changed_fields);\n\t\t\tif ($changes == 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif ($this->settings[$Model->alias]['change'] == 'serialize') {\n\t\t\t\t$logData['Log']['change'] = serialize($changed_fields);\n\t\t\t} else {\n\t\t\t\t$logData['Log']['change'] = implode(', ', $changed_fields);\n\t\t\t}\n\t\t\t$logData['Log']['changes'] = $changes;\n\t\t}\n\t\t$this->_saveLog($Model, $logData);\n\t}\n\n\t/**\n\t * Does the actual saving of the Log model. Also adds the special field if possible.\n\t *\n\t * If model field in table, add the Model->alias\n\t * If action field is NOT in table, remove it from dataset\n\t * If the userKey field in table, add it to dataset\n\t * If userData is supplied to model, add it to the title\n\t *\n\t * @param Object $Model\n\t * @param array $logData\n\t */\n\tfunction _saveLog(&$Model, $logData, $title = null) {\n\n\t\tif ($title !== NULL) {\n\t\t\t$logData['Log']['title'] = $title;\n\t\t} else if ($Model->displayField == $Model->primaryKey) {\n\t\t\t$logData['Log']['title'] = $Model->alias . ' (' . $Model->id . ')';\n\t\t} else if (isset($Model->data[$Model->alias][$Model->displayField])) {\n\t\t\t$logData['Log']['title'] = $Model->data[$Model->alias][$Model->displayField];\n\t\t} else {\n\t\t\t$logData['Log']['title'] = $Model->field($Model->displayField);\n\t\t}\n\n\t\tif (isset($this->schema[$this->settings[$Model->alias]['classField']])) {\n\t\t\t// by miha nahtigal\n\t\t\t$logData['Log'][$this->settings[$Model->alias]['classField']] = $Model->name;\n\t\t}\n\n\t\tif (isset($this->schema[$this->settings[$Model->alias]['foreignKey']]) && !isset($logData['Log'][$this->settings[$Model->alias]['foreignKey']])) {\n\t\t\tif ($Model->id) {\n\t\t\t\t$logData['Log'][$this->settings[$Model->alias]['foreignKey']] = $Model->id;\n\t\t\t} else if ($Model->insertId) {\n\t\t\t\t$logData['Log'][$this->settings[$Model->alias]['foreignKey']] = $Model->insertId;\n\t\t\t}\n\t\t}\n\n\t\tif (!isset($this->schema['action'])) {\n\t\t\tunset($logData['Log']['action']);\n\t\t} else if (isset($Model->logableAction) && !empty($Model->logableAction)) {\n\t\t\t$logData['Log']['action'] = implode(',', $Model->logableAction); // . ' ' . $logData['Log']['action'];\n\t\t\tunset($Model->logableAction);\n\t\t}\n\n\t\tif (isset($this->schema['version_id']) && isset($Model->version_id)) {\n\t\t\t$logData['Log']['version_id'] = $Model->version_id;\n\t\t\tunset($Model->version_id);\n\t\t}\n\n\t\tif (isset($this->schema['ip']) && $this->userIP) {\n\t\t\t$logData['Log']['ip'] = $this->userIP;\n\t\t}\n\n\t\tif (isset($this->schema[$this->settings[$Model->alias]['userKey']]) && $this->user) {\n\t\t\t$logData['Log'][$this->settings[$Model->alias]['userKey']] = $this->user[$this->UserModel->alias][$this->UserModel->primaryKey];\n\t\t}\n\n\t\tif (isset($this->schema['description'])) {\n\t\t\tif ($this->user && $this->UserModel) {\n\t\t\t\t$logData['Log']['description'] .= ' by ' . $this->settings[$Model->alias]['userModel'] . ' \"' . $this->user[$this->UserModel->alias][$this->UserModel->displayField] . '\"';\n\t\t\t\tif ($this->settings[$Model->alias]['description_ids']) {\n\t\t\t\t\t$logData['Log']['description'] .= ' (' . $this->user[$this->UserModel->alias][$this->UserModel->primaryKey] . ')';\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// UserModel is active, but the data hasnt been set. Assume system action.\n\t\t\t\t$logData['Log']['description'] .= ' by System';\n\t\t\t}\n\t\t\t$logData['Log']['description'] .= '.';\n\t\t}\n\t\t$this->Log->create($logData);\n\t\t$this->Log->save(null, array(\n\t\t\t\t'validate' => false,\n\t\t\t\t'callbacks' => false));\n\t}\n}\n"], "filenames": ["app/Model/GalaxyCluster.php", "app/Model/Workflow.php", "app/Plugin/Assets/models/behaviors/LogableBehavior.php"], "buggy_code_start_loc": [1066, 1159, 164], "buggy_code_end_loc": [1068, 1162, 168], "fixing_code_start_loc": [1066, 1159, 163], "fixing_code_end_loc": [1072, 1169, 175], "type": "CWE-755", "message": "MISP before 2.4.166 unsafely allows users to use the order parameter, related to app/Model/Attribute.php, app/Model/GalaxyCluster.php, app/Model/Workflow.php, and app/Plugin/Assets/models/behaviors/LogableBehavior.php.", "other": {"cve": {"id": "CVE-2022-48329", "sourceIdentifier": "cve@mitre.org", "published": "2023-02-20T04:15:11.227", "lastModified": "2023-02-28T20:12:34.603", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "MISP before 2.4.166 unsafely allows users to use the order parameter, related to app/Model/Attribute.php, app/Model/GalaxyCluster.php, app/Model/Workflow.php, and app/Plugin/Assets/models/behaviors/LogableBehavior.php."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-755"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:misp:misp:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.4.166", "matchCriteriaId": "9FC3E95B-CFD0-4FA8-9A8C-F99445142F7A"}]}]}], "references": [{"url": "https://github.com/MISP/MISP/commit/a73c1c461bc6f8a048eae92b5e99823afd892d1e", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/MISP/MISP/commit/afbe08d256d609eee5195c5b0003cfb723ae7af1", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/MISP/MISP/compare/v2.4.165...v2.4.166", "source": "cve@mitre.org", "tags": ["Release Notes"]}]}, "github_commit_url": "https://github.com/MISP/MISP/commit/a73c1c461bc6f8a048eae92b5e99823afd892d1e"}}