{"buggy_code": ["/*\nCopyright (c) 2007-2013. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n%{\n\n\n#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <stddef.h>\n\n\n#include <yara/integers.h>\n#include <yara/utils.h>\n#include <yara/strutils.h>\n#include <yara/compiler.h>\n#include <yara/object.h>\n#include <yara/sizedstr.h>\n#include <yara/exec.h>\n#include <yara/error.h>\n#include <yara/mem.h>\n#include <yara/lexer.h>\n#include <yara/parser.h>\n\n\n#define YYERROR_VERBOSE\n\n#define YYMALLOC yr_malloc\n#define YYFREE yr_free\n\n#define INTEGER_SET_ENUMERATION   1\n#define INTEGER_SET_RANGE         2\n\n#define ERROR_IF(x) \\\n    if (x) \\\n    { \\\n      yyerror(yyscanner, compiler, NULL); \\\n      YYERROR; \\\n    } \\\n\n\n#define CHECK_TYPE(expression, expected_type, op) \\\n    if (((expression.type) & (expected_type)) == 0) \\\n    { \\\n      switch(expression.type) \\\n      { \\\n        case EXPRESSION_TYPE_INTEGER: \\\n          yr_compiler_set_error_extra_info( \\\n              compiler, \"wrong type \\\"integer\\\" for \" op \" operator\"); \\\n          break; \\\n        case EXPRESSION_TYPE_FLOAT: \\\n          yr_compiler_set_error_extra_info( \\\n              compiler, \"wrong type \\\"float\\\" for \" op \" operator\"); \\\n          break; \\\n        case EXPRESSION_TYPE_STRING: \\\n          yr_compiler_set_error_extra_info( \\\n              compiler, \"wrong type \\\"string\\\" for \" op \" operator\"); \\\n          break; \\\n        case EXPRESSION_TYPE_BOOLEAN: \\\n          yr_compiler_set_error_extra_info( \\\n              compiler, \"wrong type \\\"boolean\\\" for \" op \" operator\"); \\\n          break; \\\n      } \\\n      compiler->last_result = ERROR_WRONG_TYPE; \\\n      yyerror(yyscanner, compiler, NULL); \\\n      YYERROR; \\\n    }\n%}\n\n\n%expect 1   // expect 1 shift/reduce conflicts\n\n// Uncomment this line to print parsing information that can be useful to\n// debug YARA's grammar.\n\n// %debug\n\n%name-prefix=\"yara_yy\"\n%pure-parser\n%parse-param {void *yyscanner}\n%parse-param {YR_COMPILER* compiler}\n%lex-param {yyscan_t yyscanner}\n%lex-param {YR_COMPILER* compiler}\n\n%token _DOT_DOT_\n%token _RULE_\n%token _PRIVATE_\n%token _GLOBAL_\n%token _META_\n%token <string> _STRINGS_\n%token _CONDITION_\n%token <c_string> _IDENTIFIER_\n%token <c_string> _STRING_IDENTIFIER_\n%token <c_string> _STRING_COUNT_\n%token <c_string> _STRING_OFFSET_\n%token <c_string> _STRING_LENGTH_\n%token <c_string> _STRING_IDENTIFIER_WITH_WILDCARD_\n%token <integer> _NUMBER_\n%token <double_> _DOUBLE_\n%token <integer> _INTEGER_FUNCTION_\n%token <sized_string> _TEXT_STRING_\n%token <sized_string> _HEX_STRING_\n%token <sized_string> _REGEXP_\n%token _ASCII_\n%token _WIDE_\n%token _NOCASE_\n%token _FULLWORD_\n%token _AT_\n%token _FILESIZE_\n%token _ENTRYPOINT_\n%token _ALL_\n%token _ANY_\n%token _IN_\n%token _OF_\n%token _FOR_\n%token _THEM_\n%token _MATCHES_\n%token _CONTAINS_\n%token _IMPORT_\n\n%token _TRUE_\n%token _FALSE_\n\n%left _OR_\n%left _AND_\n%left '|'\n%left '^'\n%left '&'\n%left _EQ_ _NEQ_\n%left _LT_ _LE_ _GT_ _GE_\n%left _SHIFT_LEFT_ _SHIFT_RIGHT_\n%left '+' '-'\n%left '*' '\\\\' '%'\n%right _NOT_ '~' UNARY_MINUS\n\n%type <rule>   rule\n\n%type <string> strings\n%type <string> string_declaration\n%type <string> string_declarations\n\n%type <meta> meta\n%type <meta> meta_declaration\n%type <meta> meta_declarations\n\n%type <c_string> tags\n%type <c_string> tag_list\n\n%type <integer> string_modifier\n%type <integer> string_modifiers\n\n%type <integer> integer_set\n\n%type <integer> rule_modifier\n%type <integer> rule_modifiers\n\n\n%type <expression> primary_expression\n%type <expression> boolean_expression\n%type <expression> expression\n%type <expression> identifier\n%type <expression> regexp\n\n%type <c_string> arguments\n%type <c_string> arguments_list\n\n%destructor { yr_free($$); } _IDENTIFIER_\n%destructor { yr_free($$); } _STRING_COUNT_\n%destructor { yr_free($$); } _STRING_OFFSET_\n%destructor { yr_free($$); } _STRING_LENGTH_\n%destructor { yr_free($$); } _STRING_IDENTIFIER_\n%destructor { yr_free($$); } _STRING_IDENTIFIER_WITH_WILDCARD_\n%destructor { yr_free($$); } _TEXT_STRING_\n%destructor { yr_free($$); } _HEX_STRING_\n%destructor { yr_free($$); } _REGEXP_\n\n%union {\n  EXPRESSION      expression;\n  SIZED_STRING*   sized_string;\n  char*           c_string;\n  int64_t         integer;\n  double          double_;\n  YR_STRING*      string;\n  YR_META*        meta;\n  YR_RULE*        rule;\n}\n\n\n%%\n\nrules\n    : /* empty */\n    | rules rule\n    | rules import\n    | rules error rule      /* on error skip until next rule..*/\n    | rules error import    /* .. or import statement */\n    | rules error \"include\" /* .. or include statement */\n    ;\n\n\nimport\n    : _IMPORT_ _TEXT_STRING_\n      {\n        int result = yr_parser_reduce_import(yyscanner, $2);\n\n        yr_free($2);\n\n        ERROR_IF(result != ERROR_SUCCESS);\n      }\n    ;\n\n\nrule\n    : rule_modifiers _RULE_ _IDENTIFIER_\n      {\n        YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(\n            yyscanner, (int32_t) $1, $3);\n\n        ERROR_IF(rule == NULL);\n\n        $<rule>$ = rule;\n      }\n      tags '{' meta strings\n      {\n        YR_RULE* rule = $<rule>4; // rule created in phase 1\n\n        rule->tags = $5;\n        rule->metas = $7;\n        rule->strings = $8;\n      }\n      condition '}'\n      {\n        YR_RULE* rule = $<rule>4; // rule created in phase 1\n\n        compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(\n            yyscanner, rule);\n\n        yr_free($3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    ;\n\n\nmeta\n    : /* empty */\n      {\n        $$ = NULL;\n      }\n    | _META_ ':' meta_declarations\n      {\n        // Each rule have a list of meta-data info, consisting in a\n        // sequence of YR_META structures. The last YR_META structure does\n        // not represent a real meta-data, it's just a end-of-list marker\n        // identified by a specific type (META_TYPE_NULL). Here we\n        // write the end-of-list marker.\n\n        YR_META null_meta;\n\n        memset(&null_meta, 0xFF, sizeof(YR_META));\n        null_meta.type = META_TYPE_NULL;\n\n        compiler->last_result = yr_arena_write_data(\n            compiler->metas_arena,\n            &null_meta,\n            sizeof(YR_META),\n            NULL);\n\n        $$ = $3;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    ;\n\n\nstrings\n    : /* empty */\n      {\n        $$ = NULL;\n      }\n    | _STRINGS_ ':' string_declarations\n      {\n        // Each rule have a list of strings, consisting in a sequence\n        // of YR_STRING structures. The last YR_STRING structure does not\n        // represent a real string, it's just a end-of-list marker\n        // identified by a specific flag (STRING_FLAGS_NULL). Here we\n        // write the end-of-list marker.\n\n        YR_STRING null_string;\n\n        memset(&null_string, 0xFF, sizeof(YR_STRING));\n        null_string.g_flags = STRING_GFLAGS_NULL;\n\n        compiler->last_result = yr_arena_write_data(\n            compiler->strings_arena,\n            &null_string,\n            sizeof(YR_STRING),\n            NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$ = $3;\n      }\n    ;\n\n\ncondition\n    : _CONDITION_ ':' boolean_expression\n    ;\n\n\nrule_modifiers\n    : /* empty */                      { $$ = 0;  }\n    | rule_modifiers rule_modifier     { $$ = $1 | $2; }\n    ;\n\n\nrule_modifier\n    : _PRIVATE_      { $$ = RULE_GFLAGS_PRIVATE; }\n    | _GLOBAL_       { $$ = RULE_GFLAGS_GLOBAL; }\n    ;\n\n\ntags\n    : /* empty */\n      {\n        $$ = NULL;\n      }\n    | ':' tag_list\n      {\n        // Tags list is represented in the arena as a sequence\n        // of null-terminated strings, the sequence ends with an\n        // additional null character. Here we write the ending null\n        //character. Example: tag1\\0tag2\\0tag3\\0\\0\n\n        compiler->last_result = yr_arena_write_string(\n            yyget_extra(yyscanner)->sz_arena, \"\", NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$ = $2;\n      }\n    ;\n\n\ntag_list\n    : _IDENTIFIER_\n      {\n        char* identifier;\n\n        compiler->last_result = yr_arena_write_string(\n            yyget_extra(yyscanner)->sz_arena, $1, &identifier);\n\n        yr_free($1);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$ = identifier;\n      }\n    | tag_list _IDENTIFIER_\n      {\n        char* tag_name = $1;\n        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;\n\n        while (tag_length > 0)\n        {\n          if (strcmp(tag_name, $2) == 0)\n          {\n            yr_compiler_set_error_extra_info(compiler, tag_name);\n            compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;\n            break;\n          }\n\n          tag_name = (char*) yr_arena_next_address(\n              yyget_extra(yyscanner)->sz_arena,\n              tag_name,\n              tag_length + 1);\n\n          tag_length = tag_name != NULL ? strlen(tag_name) : 0;\n        }\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_arena_write_string(\n              yyget_extra(yyscanner)->sz_arena, $2, NULL);\n\n        yr_free($2);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$ = $1;\n      }\n    ;\n\n\n\nmeta_declarations\n    : meta_declaration                    {  $$ = $1; }\n    | meta_declarations meta_declaration  {  $$ = $1; }\n    ;\n\n\nmeta_declaration\n    : _IDENTIFIER_ '=' _TEXT_STRING_\n      {\n        SIZED_STRING* sized_string = $3;\n\n        $$ = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_STRING,\n            $1,\n            sized_string->c_string,\n            0);\n\n        yr_free($1);\n        yr_free($3);\n\n        ERROR_IF($$ == NULL);\n      }\n    | _IDENTIFIER_ '=' _NUMBER_\n      {\n        $$ = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_INTEGER,\n            $1,\n            NULL,\n            $3);\n\n        yr_free($1);\n\n        ERROR_IF($$ == NULL);\n      }\n    | _IDENTIFIER_ '=' '-' _NUMBER_\n      {\n        $$ = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_INTEGER,\n            $1,\n            NULL,\n            -$4);\n\n        yr_free($1);\n\n        ERROR_IF($$ == NULL);\n      }\n    | _IDENTIFIER_ '=' _TRUE_\n      {\n        $$ = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_BOOLEAN,\n            $1,\n            NULL,\n            TRUE);\n\n        yr_free($1);\n\n        ERROR_IF($$ == NULL);\n      }\n    | _IDENTIFIER_ '=' _FALSE_\n      {\n        $$ = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_BOOLEAN,\n            $1,\n            NULL,\n            FALSE);\n\n        yr_free($1);\n\n        ERROR_IF($$ == NULL);\n      }\n    ;\n\n\nstring_declarations\n    : string_declaration                      { $$ = $1; }\n    | string_declarations string_declaration  { $$ = $1; }\n    ;\n\n\nstring_declaration\n    : _STRING_IDENTIFIER_ '='\n      {\n        compiler->error_line = yyget_lineno(yyscanner);\n      }\n      _TEXT_STRING_ string_modifiers\n      {\n        $$ = yr_parser_reduce_string_declaration(\n            yyscanner, (int32_t) $5, $1, $4);\n\n        yr_free($1);\n        yr_free($4);\n\n        ERROR_IF($$ == NULL);\n        compiler->error_line = 0;\n      }\n    | _STRING_IDENTIFIER_ '='\n      {\n        compiler->error_line = yyget_lineno(yyscanner);\n      }\n      _REGEXP_ string_modifiers\n      {\n        $$ = yr_parser_reduce_string_declaration(\n            yyscanner, (int32_t) $5 | STRING_GFLAGS_REGEXP, $1, $4);\n\n        yr_free($1);\n        yr_free($4);\n\n        ERROR_IF($$ == NULL);\n\n        compiler->error_line = 0;\n      }\n    | _STRING_IDENTIFIER_ '=' _HEX_STRING_\n      {\n        $$ = yr_parser_reduce_string_declaration(\n            yyscanner, STRING_GFLAGS_HEXADECIMAL, $1, $3);\n\n        yr_free($1);\n        yr_free($3);\n\n        ERROR_IF($$ == NULL);\n      }\n    ;\n\n\nstring_modifiers\n    : /* empty */                         { $$ = 0; }\n    | string_modifiers string_modifier    { $$ = $1 | $2; }\n    ;\n\n\nstring_modifier\n    : _WIDE_        { $$ = STRING_GFLAGS_WIDE; }\n    | _ASCII_       { $$ = STRING_GFLAGS_ASCII; }\n    | _NOCASE_      { $$ = STRING_GFLAGS_NO_CASE; }\n    | _FULLWORD_    { $$ = STRING_GFLAGS_FULL_WORD; }\n    ;\n\n\nidentifier\n    : _IDENTIFIER_\n      {\n        int var_index = yr_parser_lookup_loop_variable(yyscanner, $1);\n\n        if (var_index >= 0)\n        {\n          compiler->last_result = yr_parser_emit_with_arg(\n              yyscanner,\n              OP_PUSH_M,\n              LOOP_LOCAL_VARS * var_index,\n              NULL,\n              NULL);\n\n          $$.type = EXPRESSION_TYPE_INTEGER;\n          $$.value.integer = UNDEFINED;\n          $$.identifier = compiler->loop_identifier[var_index];\n        }\n        else\n        {\n          // Search for identifier within the global namespace, where the\n          // externals variables reside.\n\n          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(\n              compiler->objects_table, $1, NULL);\n\n          if (object == NULL)\n          {\n            // If not found, search within the current namespace.\n            char* ns = compiler->current_namespace->name;\n\n            object = (YR_OBJECT*) yr_hash_table_lookup(\n                compiler->objects_table, $1, ns);\n          }\n\n          if (object != NULL)\n          {\n            char* id;\n\n            compiler->last_result = yr_arena_write_string(\n                compiler->sz_arena, $1, &id);\n\n            if (compiler->last_result == ERROR_SUCCESS)\n              compiler->last_result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_OBJ_LOAD,\n                  id,\n                  NULL,\n                  NULL);\n\n            $$.type = EXPRESSION_TYPE_OBJECT;\n            $$.value.object = object;\n            $$.identifier = object->identifier;\n          }\n          else\n          {\n            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(\n                compiler->rules_table,\n                $1,\n                compiler->current_namespace->name);\n\n            if (rule != NULL)\n            {\n              compiler->last_result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_PUSH_RULE,\n                  rule,\n                  NULL,\n                  NULL);\n\n              $$.type = EXPRESSION_TYPE_BOOLEAN;\n              $$.value.integer = UNDEFINED;\n              $$.identifier = rule->identifier;\n            }\n            else\n            {\n              yr_compiler_set_error_extra_info(compiler, $1);\n              compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;\n            }\n          }\n        }\n\n        yr_free($1);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    | identifier '.' _IDENTIFIER_\n      {\n        YR_OBJECT* field = NULL;\n\n        if ($1.type == EXPRESSION_TYPE_OBJECT &&\n            $1.value.object->type == OBJECT_TYPE_STRUCTURE)\n        {\n          field = yr_object_lookup_field($1.value.object, $3);\n\n          if (field != NULL)\n          {\n            char* ident;\n\n            compiler->last_result = yr_arena_write_string(\n              compiler->sz_arena, $3, &ident);\n\n            if (compiler->last_result == ERROR_SUCCESS)\n              compiler->last_result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_OBJ_FIELD,\n                  ident,\n                  NULL,\n                  NULL);\n\n            $$.type = EXPRESSION_TYPE_OBJECT;\n            $$.value.object = field;\n            $$.identifier = field->identifier;\n          }\n          else\n          {\n            yr_compiler_set_error_extra_info(compiler, $3);\n            compiler->last_result = ERROR_INVALID_FIELD_NAME;\n          }\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, $1.identifier);\n\n          compiler->last_result = ERROR_NOT_A_STRUCTURE;\n        }\n\n        yr_free($3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    | identifier '[' primary_expression ']'\n      {\n        YR_OBJECT_ARRAY* array;\n        YR_OBJECT_DICTIONARY* dict;\n\n        if ($1.type == EXPRESSION_TYPE_OBJECT &&\n            $1.value.object->type == OBJECT_TYPE_ARRAY)\n        {\n          if ($3.type != EXPRESSION_TYPE_INTEGER)\n          {\n            yr_compiler_set_error_extra_info(\n                compiler, \"array indexes must be of integer type\");\n            compiler->last_result = ERROR_WRONG_TYPE;\n          }\n\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_INDEX_ARRAY, NULL);\n\n          array = (YR_OBJECT_ARRAY*) $1.value.object;\n\n          $$.type = EXPRESSION_TYPE_OBJECT;\n          $$.value.object = array->prototype_item;\n          $$.identifier = array->identifier;\n        }\n        else if ($1.type == EXPRESSION_TYPE_OBJECT &&\n                 $1.value.object->type == OBJECT_TYPE_DICTIONARY)\n        {\n          if ($3.type != EXPRESSION_TYPE_STRING)\n          {\n            yr_compiler_set_error_extra_info(\n                compiler, \"dictionary keys must be of string type\");\n            compiler->last_result = ERROR_WRONG_TYPE;\n          }\n\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_LOOKUP_DICT, NULL);\n\n          dict = (YR_OBJECT_DICTIONARY*) $1.value.object;\n\n          $$.type = EXPRESSION_TYPE_OBJECT;\n          $$.value.object = dict->prototype_item;\n          $$.identifier = dict->identifier;\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, $1.identifier);\n\n          compiler->last_result = ERROR_NOT_INDEXABLE;\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n\n    | identifier '(' arguments ')'\n      {\n        YR_OBJECT_FUNCTION* function;\n        char* args_fmt;\n\n        if ($1.type == EXPRESSION_TYPE_OBJECT &&\n            $1.value.object->type == OBJECT_TYPE_FUNCTION)\n        {\n          compiler->last_result = yr_parser_check_types(\n              compiler, (YR_OBJECT_FUNCTION*) $1.value.object, $3);\n\n          if (compiler->last_result == ERROR_SUCCESS)\n            compiler->last_result = yr_arena_write_string(\n              compiler->sz_arena, $3, &args_fmt);\n\n          if (compiler->last_result == ERROR_SUCCESS)\n            compiler->last_result = yr_parser_emit_with_arg_reloc(\n                yyscanner,\n                OP_CALL,\n                args_fmt,\n                NULL,\n                NULL);\n\n          function = (YR_OBJECT_FUNCTION*) $1.value.object;\n\n          $$.type = EXPRESSION_TYPE_OBJECT;\n          $$.value.object = function->return_obj;\n          $$.identifier = function->identifier;\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, $1.identifier);\n\n          compiler->last_result = ERROR_NOT_A_FUNCTION;\n        }\n\n        yr_free($3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    ;\n\n\narguments\n    : /* empty */     { $$ = yr_strdup(\"\"); }\n    | arguments_list  { $$ = $1; }\n\n\narguments_list\n    : expression\n      {\n        $$ = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);\n\n        switch($1.type)\n        {\n          case EXPRESSION_TYPE_INTEGER:\n            strlcpy($$, \"i\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_FLOAT:\n            strlcpy($$, \"f\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_BOOLEAN:\n            strlcpy($$, \"b\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_STRING:\n            strlcpy($$, \"s\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_REGEXP:\n            strlcpy($$, \"r\", MAX_FUNCTION_ARGS);\n            break;\n        }\n\n        ERROR_IF($$ == NULL);\n      }\n    | arguments_list ',' expression\n      {\n        if (strlen($1) == MAX_FUNCTION_ARGS)\n        {\n          compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;\n        }\n        else\n        {\n          switch($3.type)\n          {\n            case EXPRESSION_TYPE_INTEGER:\n              strlcat($1, \"i\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_FLOAT:\n              strlcat($1, \"f\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_BOOLEAN:\n              strlcat($1, \"b\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_STRING:\n              strlcat($1, \"s\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_REGEXP:\n              strlcat($1, \"r\", MAX_FUNCTION_ARGS);\n              break;\n          }\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$ = $1;\n      }\n    ;\n\n\nregexp\n    : _REGEXP_\n      {\n        SIZED_STRING* sized_string = $1;\n        RE* re;\n        RE_ERROR error;\n\n        int re_flags = 0;\n\n        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)\n          re_flags |= RE_FLAGS_NO_CASE;\n\n        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)\n          re_flags |= RE_FLAGS_DOT_ALL;\n\n        compiler->last_result = yr_re_compile(\n            sized_string->c_string,\n            re_flags,\n            compiler->re_code_arena,\n            &re,\n            &error);\n\n        yr_free($1);\n\n        if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)\n          yr_compiler_set_error_extra_info(compiler, error.message);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_PUSH,\n              re->root_node->forward_code,\n              NULL,\n              NULL);\n\n        yr_re_destroy(re);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_REGEXP;\n      }\n    ;\n\n\nboolean_expression\n    : expression\n      {\n        if ($1.type == EXPRESSION_TYPE_STRING)\n        {\n          if ($1.value.sized_string != NULL)\n          {\n            yywarning(yyscanner,\n              \"Using literal string \\\"%s\\\" in a boolean operation.\",\n              $1.value.sized_string->c_string);\n          }\n\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_STR_TO_BOOL, NULL);\n\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n        }\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    ;\n\nexpression\n    : _TRUE_\n      {\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | _FALSE_\n      {\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 0, NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | primary_expression _MATCHES_ regexp\n      {\n        CHECK_TYPE($1, EXPRESSION_TYPE_STRING, \"matches\");\n        CHECK_TYPE($3, EXPRESSION_TYPE_REGEXP, \"matches\");\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_emit(\n              yyscanner,\n              OP_MATCHES,\n              NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | primary_expression _CONTAINS_ primary_expression\n      {\n        CHECK_TYPE($1, EXPRESSION_TYPE_STRING, \"contains\");\n        CHECK_TYPE($3, EXPRESSION_TYPE_STRING, \"contains\");\n\n        compiler->last_result = yr_parser_emit(\n            yyscanner, OP_CONTAINS, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | _STRING_IDENTIFIER_\n      {\n        int result = yr_parser_reduce_string_identifier(\n            yyscanner,\n            $1,\n            OP_FOUND,\n            UNDEFINED);\n\n        yr_free($1);\n\n        ERROR_IF(result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | _STRING_IDENTIFIER_ _AT_ primary_expression\n      {\n        CHECK_TYPE($3, EXPRESSION_TYPE_INTEGER, \"at\");\n\n        compiler->last_result = yr_parser_reduce_string_identifier(\n            yyscanner, $1, OP_FOUND_AT, $3.value.integer);\n\n        yr_free($1);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | _STRING_IDENTIFIER_ _IN_ range\n      {\n        compiler->last_result = yr_parser_reduce_string_identifier(\n            yyscanner, $1, OP_FOUND_IN, UNDEFINED);\n\n        yr_free($1);\n\n        ERROR_IF(compiler->last_result!= ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | _FOR_ for_expression error\n      {\n        compiler->loop_depth--;\n        compiler->loop_identifier[compiler->loop_depth] = NULL;\n      }\n    | _FOR_ for_expression _IDENTIFIER_ _IN_\n      {\n        int var_index;\n\n        if (compiler->loop_depth == MAX_LOOP_NESTING)\n          compiler->last_result = \\\n              ERROR_LOOP_NESTING_LIMIT_EXCEEDED;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        var_index = yr_parser_lookup_loop_variable(\n            yyscanner, $3);\n\n        if (var_index >= 0)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, $3);\n\n          compiler->last_result = \\\n              ERROR_DUPLICATED_LOOP_IDENTIFIER;\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        // Push end-of-list marker\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n      integer_set ':'\n      {\n        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n        uint8_t* addr;\n\n        // Clear counter for number of expressions evaluating\n        // to TRUE.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);\n\n        // Clear iterations counter\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);\n\n        if ($6 == INTEGER_SET_ENUMERATION)\n        {\n          // Pop the first integer\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset, &addr, NULL);\n        }\n        else // INTEGER_SET_RANGE\n        {\n          // Pop higher bound of set range\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);\n\n          // Pop lower bound of set range\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset, NULL, NULL);\n        }\n\n        compiler->loop_address[compiler->loop_depth] = addr;\n        compiler->loop_identifier[compiler->loop_depth] = $3;\n        compiler->loop_depth++;\n      }\n      '(' boolean_expression ')'\n      {\n        int mem_offset;\n\n        compiler->loop_depth--;\n        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n\n        // The value at the top of the stack is the result of\n        // evaluating the boolean expression, so it could be\n        // 0, 1 or UNDEFINED. Add this value to a counter\n        // keeping the number of expressions evaluating to true.\n        // If the value is UNDEFINED instruction OP_ADD_M\n        // does nothing.\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);\n\n        // Increment iterations counter\n        yr_parser_emit_with_arg(\n            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);\n\n        if ($6 == INTEGER_SET_ENUMERATION)\n        {\n          yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_JNUNDEF,\n              compiler->loop_address[compiler->loop_depth],\n              NULL,\n              NULL);\n        }\n        else // INTEGER_SET_RANGE\n        {\n          // Increment lower bound of integer set\n          yr_parser_emit_with_arg(\n              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);\n\n          // Push lower bound of integer set\n          yr_parser_emit_with_arg(\n              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);\n\n          // Push higher bound of integer set\n          yr_parser_emit_with_arg(\n              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);\n\n          // Compare higher bound with lower bound, do loop again\n          // if lower bound is still lower or equal than higher bound\n          yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_JLE,\n              compiler->loop_address[compiler->loop_depth],\n              NULL,\n              NULL);\n\n          yr_parser_emit(yyscanner, OP_POP, NULL);\n          yr_parser_emit(yyscanner, OP_POP, NULL);\n        }\n\n        // Pop end-of-list marker.\n        yr_parser_emit(yyscanner, OP_POP, NULL);\n\n        // At this point the loop quantifier (any, all, 1, 2,..)\n        // is at the top of the stack. Check if the quantifier\n        // is undefined (meaning \"all\") and replace it with the\n        // iterations counter in that case.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);\n\n        // Compare the loop quantifier with the number of\n        // expressions evaluating to TRUE.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit(yyscanner, OP_INT_LE, NULL);\n\n        compiler->loop_identifier[compiler->loop_depth] = NULL;\n        yr_free($3);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | _FOR_ for_expression _OF_ string_set ':'\n      {\n        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n        uint8_t* addr;\n\n        if (compiler->loop_depth == MAX_LOOP_NESTING)\n          compiler->last_result = \\\n            ERROR_LOOP_NESTING_LIMIT_EXCEEDED;\n\n        if (compiler->loop_for_of_mem_offset != -1)\n          compiler->last_result = \\\n            ERROR_NESTED_FOR_OF_LOOP;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);\n\n        // Pop the first string.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_POP_M, mem_offset, &addr, NULL);\n\n        compiler->loop_for_of_mem_offset = mem_offset;\n        compiler->loop_address[compiler->loop_depth] = addr;\n        compiler->loop_identifier[compiler->loop_depth] = NULL;\n        compiler->loop_depth++;\n      }\n      '(' boolean_expression ')'\n      {\n        int mem_offset;\n\n        compiler->loop_depth--;\n        compiler->loop_for_of_mem_offset = -1;\n\n        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n\n        // Increment counter by the value returned by the\n        // boolean expression (0 or 1). If the boolean expression\n        // returned UNDEFINED the OP_ADD_M won't do anything.\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);\n\n        // Increment iterations counter.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);\n\n        // If next string is not undefined, go back to the\n        // beginning of the loop.\n        yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JNUNDEF,\n            compiler->loop_address[compiler->loop_depth],\n            NULL,\n            NULL);\n\n        // Pop end-of-list marker.\n        yr_parser_emit(yyscanner, OP_POP, NULL);\n\n        // At this point the loop quantifier (any, all, 1, 2,..)\n        // is at top of the stack. Check if the quantifier is\n        // undefined (meaning \"all\") and replace it with the\n        // iterations counter in that case.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);\n\n        // Compare the loop quantifier with the number of\n        // expressions evaluating to TRUE.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit(yyscanner, OP_INT_LE, NULL);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n\n      }\n    | for_expression _OF_ string_set\n      {\n        yr_parser_emit(yyscanner, OP_OF, NULL);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | _NOT_ boolean_expression\n      {\n        yr_parser_emit(yyscanner, OP_NOT, NULL);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | boolean_expression _AND_\n      {\n        YR_FIXUP* fixup;\n        void* jmp_destination_addr;\n\n        compiler->last_result = yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JFALSE,\n            0,          // still don't know the jump destination\n            NULL,\n            &jmp_destination_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        // create a fixup entry for the jump and push it in the stack\n        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n        if (fixup == NULL)\n          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup->address = jmp_destination_addr;\n        fixup->next = compiler->fixup_stack_head;\n        compiler->fixup_stack_head = fixup;\n      }\n      boolean_expression\n      {\n        YR_FIXUP* fixup;\n        uint8_t* and_addr;\n\n        // Ensure that we have at least two consecutive bytes in the arena's\n        // current page, one for the AND opcode and one for opcode following the\n        // AND. This is necessary because we need to compute the address for the\n        // opcode following the AND, and we don't want the AND in one page and\n        // the following opcode in another page.\n\n        compiler->last_result = yr_arena_reserve_memory(\n            compiler->code_arena, 2);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        // Now we know the jump destination, which is the address of the\n        // instruction following the AND. Let's fixup the jump address.\n\n        fixup = compiler->fixup_stack_head;\n\n        // We know that the AND opcode and the following one are within the same\n        // page, so we can compute the address for the opcode following the AND\n        // by simply adding one to its address.\n\n        *(void**)(fixup->address) = (void*)(and_addr + 1);\n\n        compiler->fixup_stack_head = fixup->next;\n        yr_free(fixup);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | boolean_expression _OR_\n      {\n        YR_FIXUP* fixup;\n        void* jmp_destination_addr;\n\n        compiler->last_result = yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JTRUE,\n            0,         // still don't know the jump destination\n            NULL,\n            &jmp_destination_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n        if (fixup == NULL)\n          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup->address = jmp_destination_addr;\n        fixup->next = compiler->fixup_stack_head;\n        compiler->fixup_stack_head = fixup;\n      }\n      boolean_expression\n      {\n        YR_FIXUP* fixup;\n        uint8_t* or_addr;\n\n        // Ensure that we have at least two consecutive bytes in the arena's\n        // current page, one for the OR opcode and one for opcode following the\n        // OR. This is necessary because we need to compute the address for the\n        // opcode following the OR, and we don't want the OR in one page and\n        // the following opcode in another page.\n\n        compiler->last_result = yr_arena_reserve_memory(\n            compiler->code_arena, 2);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        // Now we know the jump destination, which is the address of the\n        // instruction following the OP_OR. Let's fixup the jump address.\n\n        fixup = compiler->fixup_stack_head;\n\n        // We know that the OR opcode and the following one are within the same\n        // page, so we can compute the address for the opcode following the OR\n        // by simply adding one to its address.\n\n        *(void**)(fixup->address) = (void*)(or_addr + 1);\n\n        compiler->fixup_stack_head = fixup->next;\n        yr_free(fixup);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | primary_expression _LT_ primary_expression\n      {\n        compiler->last_result = yr_parser_reduce_operation(\n            yyscanner, \"<\", $1, $3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | primary_expression _GT_ primary_expression\n      {\n        compiler->last_result = yr_parser_reduce_operation(\n            yyscanner, \">\", $1, $3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | primary_expression _LE_ primary_expression\n      {\n        compiler->last_result = yr_parser_reduce_operation(\n            yyscanner, \"<=\", $1, $3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | primary_expression _GE_ primary_expression\n      {\n        compiler->last_result = yr_parser_reduce_operation(\n            yyscanner, \">=\", $1, $3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | primary_expression _EQ_ primary_expression\n      {\n        compiler->last_result = yr_parser_reduce_operation(\n            yyscanner, \"==\", $1, $3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | primary_expression _NEQ_ primary_expression\n      {\n        compiler->last_result = yr_parser_reduce_operation(\n            yyscanner, \"!=\", $1, $3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | primary_expression\n      {\n        $$ = $1;\n      }\n    |'(' expression ')'\n      {\n        $$ = $2;\n      }\n    ;\n\n\ninteger_set\n    : '(' integer_enumeration ')'  { $$ = INTEGER_SET_ENUMERATION; }\n    | range                        { $$ = INTEGER_SET_RANGE; }\n    ;\n\n\nrange\n    : '(' primary_expression _DOT_DOT_  primary_expression ')'\n      {\n        if ($2.type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for range's lower bound\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n        }\n\n        if ($4.type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for range's upper bound\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    ;\n\n\ninteger_enumeration\n    : primary_expression\n      {\n        if ($1.type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for enumeration item\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    | integer_enumeration ',' primary_expression\n      {\n        if ($3.type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for enumeration item\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    ;\n\n\nstring_set\n    : '('\n      {\n        // Push end-of-list marker\n        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n      }\n      string_enumeration ')'\n    | _THEM_\n      {\n        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n        yr_parser_emit_pushes_for_strings(yyscanner, \"$*\");\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    ;\n\n\nstring_enumeration\n    : string_enumeration_item\n    | string_enumeration ',' string_enumeration_item\n    ;\n\n\nstring_enumeration_item\n    : _STRING_IDENTIFIER_\n      {\n        yr_parser_emit_pushes_for_strings(yyscanner, $1);\n        yr_free($1);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    | _STRING_IDENTIFIER_WITH_WILDCARD_\n      {\n        yr_parser_emit_pushes_for_strings(yyscanner, $1);\n        yr_free($1);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    ;\n\n\nfor_expression\n    : primary_expression\n    | _ALL_\n      {\n        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n      }\n    | _ANY_\n      {\n        yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);\n      }\n    ;\n\n\nprimary_expression\n    : '(' primary_expression ')'\n      {\n        $$ = $2;\n      }\n    | _FILESIZE_\n      {\n        compiler->last_result = yr_parser_emit(\n            yyscanner, OP_FILESIZE, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = UNDEFINED;\n      }\n    | _ENTRYPOINT_\n      {\n        yywarning(yyscanner,\n            \"Using deprecated \\\"entrypoint\\\" keyword. Use the \\\"entry_point\\\" \"\n            \"function from PE module instead.\");\n\n        compiler->last_result = yr_parser_emit(\n            yyscanner, OP_ENTRYPOINT, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = UNDEFINED;\n      }\n    | _INTEGER_FUNCTION_ '(' primary_expression ')'\n      {\n        CHECK_TYPE($3, EXPRESSION_TYPE_INTEGER, \"intXXXX or uintXXXX\");\n\n        // _INTEGER_FUNCTION_ could be any of int8, int16, int32, uint8,\n        // uint32, etc. $1 contains an index that added to OP_READ_INT results\n        // in the proper OP_INTXX opcode.\n\n        compiler->last_result = yr_parser_emit(\n            yyscanner, (uint8_t) (OP_READ_INT + $1), NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = UNDEFINED;\n      }\n    | _NUMBER_\n      {\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, $1, NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = $1;\n      }\n    | _DOUBLE_\n      {\n        compiler->last_result = yr_parser_emit_with_arg_double(\n            yyscanner, OP_PUSH, $1, NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_FLOAT;\n      }\n    | _TEXT_STRING_\n      {\n        SIZED_STRING* sized_string;\n\n        compiler->last_result = yr_arena_write_data(\n            compiler->sz_arena,\n            $1,\n            $1->length + sizeof(SIZED_STRING),\n            (void**) &sized_string);\n\n        yr_free($1);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_PUSH,\n              sized_string,\n              NULL,\n              NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_STRING;\n        $$.value.sized_string = sized_string;\n      }\n    | _STRING_COUNT_\n      {\n        compiler->last_result = yr_parser_reduce_string_identifier(\n            yyscanner, $1, OP_COUNT, UNDEFINED);\n\n        yr_free($1);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = UNDEFINED;\n      }\n    | _STRING_OFFSET_ '[' primary_expression ']'\n      {\n        compiler->last_result = yr_parser_reduce_string_identifier(\n            yyscanner, $1, OP_OFFSET, UNDEFINED);\n\n        yr_free($1);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = UNDEFINED;\n      }\n    | _STRING_OFFSET_\n      {\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_reduce_string_identifier(\n              yyscanner, $1, OP_OFFSET, UNDEFINED);\n\n        yr_free($1);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = UNDEFINED;\n      }\n    | _STRING_LENGTH_ '[' primary_expression ']'\n      {\n        compiler->last_result = yr_parser_reduce_string_identifier(\n            yyscanner, $1, OP_LENGTH, UNDEFINED);\n\n        yr_free($1);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = UNDEFINED;\n      }\n    | _STRING_LENGTH_\n      {\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_reduce_string_identifier(\n              yyscanner, $1, OP_LENGTH, UNDEFINED);\n\n        yr_free($1);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = UNDEFINED;\n      }\n    | identifier\n      {\n        if ($1.type == EXPRESSION_TYPE_INTEGER)  // loop identifier\n        {\n          $$.type = EXPRESSION_TYPE_INTEGER;\n          $$.value.integer = UNDEFINED;\n        }\n        else if ($1.type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier\n        {\n          $$.type = EXPRESSION_TYPE_BOOLEAN;\n          $$.value.integer = UNDEFINED;\n        }\n        else if ($1.type == EXPRESSION_TYPE_OBJECT)\n        {\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_OBJ_VALUE, NULL);\n\n          switch($1.value.object->type)\n          {\n            case OBJECT_TYPE_INTEGER:\n              $$.type = EXPRESSION_TYPE_INTEGER;\n              $$.value.integer = UNDEFINED;\n              break;\n            case OBJECT_TYPE_FLOAT:\n              $$.type = EXPRESSION_TYPE_FLOAT;\n              break;\n            case OBJECT_TYPE_STRING:\n              $$.type = EXPRESSION_TYPE_STRING;\n              $$.value.sized_string = NULL;\n              break;\n            default:\n              yr_compiler_set_error_extra_info_fmt(\n                  compiler,\n                  \"wrong usage of identifier \\\"%s\\\"\",\n                  $1.identifier);\n              compiler->last_result = ERROR_WRONG_TYPE;\n          }\n        }\n        else\n        {\n          assert(FALSE);\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    | '-' primary_expression %prec UNARY_MINUS\n      {\n        CHECK_TYPE($2, EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, \"-\");\n\n        if ($2.type == EXPRESSION_TYPE_INTEGER)\n        {\n          $$.type = EXPRESSION_TYPE_INTEGER;\n          $$.value.integer = ($2.value.integer == UNDEFINED) ?\n              UNDEFINED : -($2.value.integer);\n          compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);\n        }\n        else if ($2.type == EXPRESSION_TYPE_FLOAT)\n        {\n          $$.type = EXPRESSION_TYPE_FLOAT;\n          compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    | primary_expression '+' primary_expression\n      {\n        compiler->last_result = yr_parser_reduce_operation(\n            yyscanner, \"+\", $1, $3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ($1.type == EXPRESSION_TYPE_INTEGER &&\n            $3.type == EXPRESSION_TYPE_INTEGER)\n        {\n          $$.value.integer = OPERATION(+, $1.value.integer, $3.value.integer);\n          $$.type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n          $$.type = EXPRESSION_TYPE_FLOAT;\n        }\n      }\n    | primary_expression '-' primary_expression\n      {\n        compiler->last_result = yr_parser_reduce_operation(\n            yyscanner, \"-\", $1, $3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ($1.type == EXPRESSION_TYPE_INTEGER &&\n            $3.type == EXPRESSION_TYPE_INTEGER)\n        {\n          $$.value.integer = OPERATION(-, $1.value.integer, $3.value.integer);\n          $$.type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n          $$.type = EXPRESSION_TYPE_FLOAT;\n        }\n      }\n    | primary_expression '*' primary_expression\n      {\n        compiler->last_result = yr_parser_reduce_operation(\n            yyscanner, \"*\", $1, $3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ($1.type == EXPRESSION_TYPE_INTEGER &&\n            $3.type == EXPRESSION_TYPE_INTEGER)\n        {\n          $$.value.integer = OPERATION(*, $1.value.integer, $3.value.integer);\n          $$.type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n          $$.type = EXPRESSION_TYPE_FLOAT;\n        }\n      }\n    | primary_expression '\\\\' primary_expression\n      {\n        compiler->last_result = yr_parser_reduce_operation(\n            yyscanner, \"\\\\\", $1, $3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ($1.type == EXPRESSION_TYPE_INTEGER &&\n            $3.type == EXPRESSION_TYPE_INTEGER)\n        {\n          if ($3.value.integer != 0)\n          {\n            $$.value.integer = OPERATION(/, $1.value.integer, $3.value.integer);\n            $$.type = EXPRESSION_TYPE_INTEGER;\n          }\n          else\n          {\n            compiler->last_result = ERROR_DIVISION_BY_ZERO;\n            ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n          }\n        }\n        else\n        {\n          $$.type = EXPRESSION_TYPE_FLOAT;\n        }\n      }\n    | primary_expression '%' primary_expression\n      {\n        CHECK_TYPE($1, EXPRESSION_TYPE_INTEGER, \"%\");\n        CHECK_TYPE($3, EXPRESSION_TYPE_INTEGER, \"%\");\n\n        yr_parser_emit(yyscanner, OP_MOD, NULL);\n\n        if ($3.value.integer != 0)\n        {\n          $$.value.integer = OPERATION(%, $1.value.integer, $3.value.integer);\n          $$.type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n          compiler->last_result = ERROR_DIVISION_BY_ZERO;\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n        }\n      }\n    | primary_expression '^' primary_expression\n      {\n        CHECK_TYPE($1, EXPRESSION_TYPE_INTEGER, \"^\");\n        CHECK_TYPE($3, EXPRESSION_TYPE_INTEGER, \"^\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = OPERATION(^, $1.value.integer, $3.value.integer);\n      }\n    | primary_expression '&' primary_expression\n      {\n        CHECK_TYPE($1, EXPRESSION_TYPE_INTEGER, \"^\");\n        CHECK_TYPE($3, EXPRESSION_TYPE_INTEGER, \"^\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = OPERATION(&, $1.value.integer, $3.value.integer);\n      }\n    | primary_expression '|' primary_expression\n      {\n        CHECK_TYPE($1, EXPRESSION_TYPE_INTEGER, \"|\");\n        CHECK_TYPE($3, EXPRESSION_TYPE_INTEGER, \"|\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = OPERATION(|, $1.value.integer, $3.value.integer);\n      }\n    | '~' primary_expression\n      {\n        CHECK_TYPE($2, EXPRESSION_TYPE_INTEGER, \"~\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = ($2.value.integer == UNDEFINED) ?\n            UNDEFINED : ~($2.value.integer);\n      }\n    | primary_expression _SHIFT_LEFT_ primary_expression\n      {\n        CHECK_TYPE($1, EXPRESSION_TYPE_INTEGER, \"<<\");\n        CHECK_TYPE($3, EXPRESSION_TYPE_INTEGER, \"<<\");\n\n        yr_parser_emit(yyscanner, OP_SHL, NULL);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = OPERATION(<<, $1.value.integer, $3.value.integer);\n      }\n    | primary_expression _SHIFT_RIGHT_ primary_expression\n      {\n        CHECK_TYPE($1, EXPRESSION_TYPE_INTEGER, \">>\");\n        CHECK_TYPE($3, EXPRESSION_TYPE_INTEGER, \">>\");\n\n        yr_parser_emit(yyscanner, OP_SHR, NULL);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = OPERATION(>>, $1.value.integer, $3.value.integer);\n      }\n    | regexp\n      {\n        $$ = $1;\n      }\n    ;\n\n%%\n"], "fixing_code": ["/*\nCopyright (c) 2007-2013. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n%{\n\n\n#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <stddef.h>\n\n\n#include <yara/integers.h>\n#include <yara/utils.h>\n#include <yara/strutils.h>\n#include <yara/compiler.h>\n#include <yara/object.h>\n#include <yara/sizedstr.h>\n#include <yara/exec.h>\n#include <yara/error.h>\n#include <yara/mem.h>\n#include <yara/lexer.h>\n#include <yara/parser.h>\n\n\n#define YYERROR_VERBOSE\n\n#define YYMALLOC yr_malloc\n#define YYFREE yr_free\n\n#define INTEGER_SET_ENUMERATION   1\n#define INTEGER_SET_RANGE         2\n\n#define ERROR_IF(x) \\\n    if (x) \\\n    { \\\n      yyerror(yyscanner, compiler, NULL); \\\n      YYERROR; \\\n    } \\\n\n\n#define CHECK_TYPE(expression, expected_type, op) \\\n    if (((expression.type) & (expected_type)) == 0) \\\n    { \\\n      switch(expression.type) \\\n      { \\\n        case EXPRESSION_TYPE_INTEGER: \\\n          yr_compiler_set_error_extra_info( \\\n              compiler, \"wrong type \\\"integer\\\" for \" op \" operator\"); \\\n          break; \\\n        case EXPRESSION_TYPE_FLOAT: \\\n          yr_compiler_set_error_extra_info( \\\n              compiler, \"wrong type \\\"float\\\" for \" op \" operator\"); \\\n          break; \\\n        case EXPRESSION_TYPE_STRING: \\\n          yr_compiler_set_error_extra_info( \\\n              compiler, \"wrong type \\\"string\\\" for \" op \" operator\"); \\\n          break; \\\n        case EXPRESSION_TYPE_BOOLEAN: \\\n          yr_compiler_set_error_extra_info( \\\n              compiler, \"wrong type \\\"boolean\\\" for \" op \" operator\"); \\\n          break; \\\n      } \\\n      compiler->last_result = ERROR_WRONG_TYPE; \\\n      yyerror(yyscanner, compiler, NULL); \\\n      YYERROR; \\\n    }\n%}\n\n\n%expect 1   // expect 1 shift/reduce conflicts\n\n// Uncomment this line to print parsing information that can be useful to\n// debug YARA's grammar.\n\n// %debug\n\n%name-prefix=\"yara_yy\"\n%pure-parser\n%parse-param {void *yyscanner}\n%parse-param {YR_COMPILER* compiler}\n%lex-param {yyscan_t yyscanner}\n%lex-param {YR_COMPILER* compiler}\n\n%token _DOT_DOT_\n%token _RULE_\n%token _PRIVATE_\n%token _GLOBAL_\n%token _META_\n%token <string> _STRINGS_\n%token _CONDITION_\n%token <c_string> _IDENTIFIER_\n%token <c_string> _STRING_IDENTIFIER_\n%token <c_string> _STRING_COUNT_\n%token <c_string> _STRING_OFFSET_\n%token <c_string> _STRING_LENGTH_\n%token <c_string> _STRING_IDENTIFIER_WITH_WILDCARD_\n%token <integer> _NUMBER_\n%token <double_> _DOUBLE_\n%token <integer> _INTEGER_FUNCTION_\n%token <sized_string> _TEXT_STRING_\n%token <sized_string> _HEX_STRING_\n%token <sized_string> _REGEXP_\n%token _ASCII_\n%token _WIDE_\n%token _NOCASE_\n%token _FULLWORD_\n%token _AT_\n%token _FILESIZE_\n%token _ENTRYPOINT_\n%token _ALL_\n%token _ANY_\n%token _IN_\n%token _OF_\n%token _FOR_\n%token _THEM_\n%token _MATCHES_\n%token _CONTAINS_\n%token _IMPORT_\n\n%token _TRUE_\n%token _FALSE_\n\n%left _OR_\n%left _AND_\n%left '|'\n%left '^'\n%left '&'\n%left _EQ_ _NEQ_\n%left _LT_ _LE_ _GT_ _GE_\n%left _SHIFT_LEFT_ _SHIFT_RIGHT_\n%left '+' '-'\n%left '*' '\\\\' '%'\n%right _NOT_ '~' UNARY_MINUS\n\n%type <rule>   rule\n\n%type <string> strings\n%type <string> string_declaration\n%type <string> string_declarations\n\n%type <meta> meta\n%type <meta> meta_declaration\n%type <meta> meta_declarations\n\n%type <c_string> tags\n%type <c_string> tag_list\n\n%type <integer> string_modifier\n%type <integer> string_modifiers\n\n%type <integer> integer_set\n\n%type <integer> rule_modifier\n%type <integer> rule_modifiers\n\n\n%type <expression> primary_expression\n%type <expression> boolean_expression\n%type <expression> expression\n%type <expression> identifier\n%type <expression> regexp\n\n%type <c_string> arguments\n%type <c_string> arguments_list\n\n%destructor { yr_free($$); } _IDENTIFIER_\n%destructor { yr_free($$); } _STRING_COUNT_\n%destructor { yr_free($$); } _STRING_OFFSET_\n%destructor { yr_free($$); } _STRING_LENGTH_\n%destructor { yr_free($$); } _STRING_IDENTIFIER_\n%destructor { yr_free($$); } _STRING_IDENTIFIER_WITH_WILDCARD_\n%destructor { yr_free($$); } _TEXT_STRING_\n%destructor { yr_free($$); } _HEX_STRING_\n%destructor { yr_free($$); } _REGEXP_\n\n%union {\n  EXPRESSION      expression;\n  SIZED_STRING*   sized_string;\n  char*           c_string;\n  int64_t         integer;\n  double          double_;\n  YR_STRING*      string;\n  YR_META*        meta;\n  YR_RULE*        rule;\n}\n\n\n%%\n\nrules\n    : /* empty */\n    | rules rule\n    | rules import\n    | rules error rule      /* on error skip until next rule..*/\n    | rules error import    /* .. or import statement */\n    | rules error \"include\" /* .. or include statement */\n    ;\n\n\nimport\n    : _IMPORT_ _TEXT_STRING_\n      {\n        int result = yr_parser_reduce_import(yyscanner, $2);\n\n        yr_free($2);\n\n        ERROR_IF(result != ERROR_SUCCESS);\n      }\n    ;\n\n\nrule\n    : rule_modifiers _RULE_ _IDENTIFIER_\n      {\n        YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(\n            yyscanner, (int32_t) $1, $3);\n\n        ERROR_IF(rule == NULL);\n\n        $<rule>$ = rule;\n      }\n      tags '{' meta strings\n      {\n        YR_RULE* rule = $<rule>4; // rule created in phase 1\n\n        rule->tags = $5;\n        rule->metas = $7;\n        rule->strings = $8;\n      }\n      condition '}'\n      {\n        YR_RULE* rule = $<rule>4; // rule created in phase 1\n\n        compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(\n            yyscanner, rule);\n\n        yr_free($3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    ;\n\n\nmeta\n    : /* empty */\n      {\n        $$ = NULL;\n      }\n    | _META_ ':' meta_declarations\n      {\n        // Each rule have a list of meta-data info, consisting in a\n        // sequence of YR_META structures. The last YR_META structure does\n        // not represent a real meta-data, it's just a end-of-list marker\n        // identified by a specific type (META_TYPE_NULL). Here we\n        // write the end-of-list marker.\n\n        YR_META null_meta;\n\n        memset(&null_meta, 0xFF, sizeof(YR_META));\n        null_meta.type = META_TYPE_NULL;\n\n        compiler->last_result = yr_arena_write_data(\n            compiler->metas_arena,\n            &null_meta,\n            sizeof(YR_META),\n            NULL);\n\n        $$ = $3;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    ;\n\n\nstrings\n    : /* empty */\n      {\n        $$ = NULL;\n      }\n    | _STRINGS_ ':' string_declarations\n      {\n        // Each rule have a list of strings, consisting in a sequence\n        // of YR_STRING structures. The last YR_STRING structure does not\n        // represent a real string, it's just a end-of-list marker\n        // identified by a specific flag (STRING_FLAGS_NULL). Here we\n        // write the end-of-list marker.\n\n        YR_STRING null_string;\n\n        memset(&null_string, 0xFF, sizeof(YR_STRING));\n        null_string.g_flags = STRING_GFLAGS_NULL;\n\n        compiler->last_result = yr_arena_write_data(\n            compiler->strings_arena,\n            &null_string,\n            sizeof(YR_STRING),\n            NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$ = $3;\n      }\n    ;\n\n\ncondition\n    : _CONDITION_ ':' boolean_expression\n    ;\n\n\nrule_modifiers\n    : /* empty */                      { $$ = 0;  }\n    | rule_modifiers rule_modifier     { $$ = $1 | $2; }\n    ;\n\n\nrule_modifier\n    : _PRIVATE_      { $$ = RULE_GFLAGS_PRIVATE; }\n    | _GLOBAL_       { $$ = RULE_GFLAGS_GLOBAL; }\n    ;\n\n\ntags\n    : /* empty */\n      {\n        $$ = NULL;\n      }\n    | ':' tag_list\n      {\n        // Tags list is represented in the arena as a sequence\n        // of null-terminated strings, the sequence ends with an\n        // additional null character. Here we write the ending null\n        //character. Example: tag1\\0tag2\\0tag3\\0\\0\n\n        compiler->last_result = yr_arena_write_string(\n            yyget_extra(yyscanner)->sz_arena, \"\", NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$ = $2;\n      }\n    ;\n\n\ntag_list\n    : _IDENTIFIER_\n      {\n        char* identifier;\n\n        compiler->last_result = yr_arena_write_string(\n            yyget_extra(yyscanner)->sz_arena, $1, &identifier);\n\n        yr_free($1);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$ = identifier;\n      }\n    | tag_list _IDENTIFIER_\n      {\n        char* tag_name = $1;\n        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;\n\n        while (tag_length > 0)\n        {\n          if (strcmp(tag_name, $2) == 0)\n          {\n            yr_compiler_set_error_extra_info(compiler, tag_name);\n            compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;\n            break;\n          }\n\n          tag_name = (char*) yr_arena_next_address(\n              yyget_extra(yyscanner)->sz_arena,\n              tag_name,\n              tag_length + 1);\n\n          tag_length = tag_name != NULL ? strlen(tag_name) : 0;\n        }\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_arena_write_string(\n              yyget_extra(yyscanner)->sz_arena, $2, NULL);\n\n        yr_free($2);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$ = $1;\n      }\n    ;\n\n\n\nmeta_declarations\n    : meta_declaration                    {  $$ = $1; }\n    | meta_declarations meta_declaration  {  $$ = $1; }\n    ;\n\n\nmeta_declaration\n    : _IDENTIFIER_ '=' _TEXT_STRING_\n      {\n        SIZED_STRING* sized_string = $3;\n\n        $$ = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_STRING,\n            $1,\n            sized_string->c_string,\n            0);\n\n        yr_free($1);\n        yr_free($3);\n\n        ERROR_IF($$ == NULL);\n      }\n    | _IDENTIFIER_ '=' _NUMBER_\n      {\n        $$ = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_INTEGER,\n            $1,\n            NULL,\n            $3);\n\n        yr_free($1);\n\n        ERROR_IF($$ == NULL);\n      }\n    | _IDENTIFIER_ '=' '-' _NUMBER_\n      {\n        $$ = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_INTEGER,\n            $1,\n            NULL,\n            -$4);\n\n        yr_free($1);\n\n        ERROR_IF($$ == NULL);\n      }\n    | _IDENTIFIER_ '=' _TRUE_\n      {\n        $$ = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_BOOLEAN,\n            $1,\n            NULL,\n            TRUE);\n\n        yr_free($1);\n\n        ERROR_IF($$ == NULL);\n      }\n    | _IDENTIFIER_ '=' _FALSE_\n      {\n        $$ = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_BOOLEAN,\n            $1,\n            NULL,\n            FALSE);\n\n        yr_free($1);\n\n        ERROR_IF($$ == NULL);\n      }\n    ;\n\n\nstring_declarations\n    : string_declaration                      { $$ = $1; }\n    | string_declarations string_declaration  { $$ = $1; }\n    ;\n\n\nstring_declaration\n    : _STRING_IDENTIFIER_ '='\n      {\n        compiler->error_line = yyget_lineno(yyscanner);\n      }\n      _TEXT_STRING_ string_modifiers\n      {\n        $$ = yr_parser_reduce_string_declaration(\n            yyscanner, (int32_t) $5, $1, $4);\n\n        yr_free($1);\n        yr_free($4);\n\n        ERROR_IF($$ == NULL);\n        compiler->error_line = 0;\n      }\n    | _STRING_IDENTIFIER_ '='\n      {\n        compiler->error_line = yyget_lineno(yyscanner);\n      }\n      _REGEXP_ string_modifiers\n      {\n        $$ = yr_parser_reduce_string_declaration(\n            yyscanner, (int32_t) $5 | STRING_GFLAGS_REGEXP, $1, $4);\n\n        yr_free($1);\n        yr_free($4);\n\n        ERROR_IF($$ == NULL);\n\n        compiler->error_line = 0;\n      }\n    | _STRING_IDENTIFIER_ '=' _HEX_STRING_\n      {\n        $$ = yr_parser_reduce_string_declaration(\n            yyscanner, STRING_GFLAGS_HEXADECIMAL, $1, $3);\n\n        yr_free($1);\n        yr_free($3);\n\n        ERROR_IF($$ == NULL);\n      }\n    ;\n\n\nstring_modifiers\n    : /* empty */                         { $$ = 0; }\n    | string_modifiers string_modifier    { $$ = $1 | $2; }\n    ;\n\n\nstring_modifier\n    : _WIDE_        { $$ = STRING_GFLAGS_WIDE; }\n    | _ASCII_       { $$ = STRING_GFLAGS_ASCII; }\n    | _NOCASE_      { $$ = STRING_GFLAGS_NO_CASE; }\n    | _FULLWORD_    { $$ = STRING_GFLAGS_FULL_WORD; }\n    ;\n\n\nidentifier\n    : _IDENTIFIER_\n      {\n        int var_index = yr_parser_lookup_loop_variable(yyscanner, $1);\n\n        if (var_index >= 0)\n        {\n          compiler->last_result = yr_parser_emit_with_arg(\n              yyscanner,\n              OP_PUSH_M,\n              LOOP_LOCAL_VARS * var_index,\n              NULL,\n              NULL);\n\n          $$.type = EXPRESSION_TYPE_INTEGER;\n          $$.value.integer = UNDEFINED;\n          $$.identifier = compiler->loop_identifier[var_index];\n        }\n        else\n        {\n          // Search for identifier within the global namespace, where the\n          // externals variables reside.\n\n          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(\n              compiler->objects_table, $1, NULL);\n\n          if (object == NULL)\n          {\n            // If not found, search within the current namespace.\n            char* ns = compiler->current_namespace->name;\n\n            object = (YR_OBJECT*) yr_hash_table_lookup(\n                compiler->objects_table, $1, ns);\n          }\n\n          if (object != NULL)\n          {\n            char* id;\n\n            compiler->last_result = yr_arena_write_string(\n                compiler->sz_arena, $1, &id);\n\n            if (compiler->last_result == ERROR_SUCCESS)\n              compiler->last_result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_OBJ_LOAD,\n                  id,\n                  NULL,\n                  NULL);\n\n            $$.type = EXPRESSION_TYPE_OBJECT;\n            $$.value.object = object;\n            $$.identifier = object->identifier;\n          }\n          else\n          {\n            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(\n                compiler->rules_table,\n                $1,\n                compiler->current_namespace->name);\n\n            if (rule != NULL)\n            {\n              compiler->last_result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_PUSH_RULE,\n                  rule,\n                  NULL,\n                  NULL);\n\n              $$.type = EXPRESSION_TYPE_BOOLEAN;\n              $$.value.integer = UNDEFINED;\n              $$.identifier = rule->identifier;\n            }\n            else\n            {\n              yr_compiler_set_error_extra_info(compiler, $1);\n              compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;\n            }\n          }\n        }\n\n        yr_free($1);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    | identifier '.' _IDENTIFIER_\n      {\n        YR_OBJECT* field = NULL;\n\n        if ($1.type == EXPRESSION_TYPE_OBJECT &&\n            $1.value.object->type == OBJECT_TYPE_STRUCTURE)\n        {\n          field = yr_object_lookup_field($1.value.object, $3);\n\n          if (field != NULL)\n          {\n            char* ident;\n\n            compiler->last_result = yr_arena_write_string(\n              compiler->sz_arena, $3, &ident);\n\n            if (compiler->last_result == ERROR_SUCCESS)\n              compiler->last_result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_OBJ_FIELD,\n                  ident,\n                  NULL,\n                  NULL);\n\n            $$.type = EXPRESSION_TYPE_OBJECT;\n            $$.value.object = field;\n            $$.identifier = field->identifier;\n          }\n          else\n          {\n            yr_compiler_set_error_extra_info(compiler, $3);\n            compiler->last_result = ERROR_INVALID_FIELD_NAME;\n          }\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, $1.identifier);\n\n          compiler->last_result = ERROR_NOT_A_STRUCTURE;\n        }\n\n        yr_free($3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    | identifier '[' primary_expression ']'\n      {\n        YR_OBJECT_ARRAY* array;\n        YR_OBJECT_DICTIONARY* dict;\n\n        if ($1.type == EXPRESSION_TYPE_OBJECT &&\n            $1.value.object->type == OBJECT_TYPE_ARRAY)\n        {\n          if ($3.type != EXPRESSION_TYPE_INTEGER)\n          {\n            yr_compiler_set_error_extra_info(\n                compiler, \"array indexes must be of integer type\");\n            compiler->last_result = ERROR_WRONG_TYPE;\n          }\n\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_INDEX_ARRAY, NULL);\n\n          array = (YR_OBJECT_ARRAY*) $1.value.object;\n\n          $$.type = EXPRESSION_TYPE_OBJECT;\n          $$.value.object = array->prototype_item;\n          $$.identifier = array->identifier;\n        }\n        else if ($1.type == EXPRESSION_TYPE_OBJECT &&\n                 $1.value.object->type == OBJECT_TYPE_DICTIONARY)\n        {\n          if ($3.type != EXPRESSION_TYPE_STRING)\n          {\n            yr_compiler_set_error_extra_info(\n                compiler, \"dictionary keys must be of string type\");\n            compiler->last_result = ERROR_WRONG_TYPE;\n          }\n\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_LOOKUP_DICT, NULL);\n\n          dict = (YR_OBJECT_DICTIONARY*) $1.value.object;\n\n          $$.type = EXPRESSION_TYPE_OBJECT;\n          $$.value.object = dict->prototype_item;\n          $$.identifier = dict->identifier;\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, $1.identifier);\n\n          compiler->last_result = ERROR_NOT_INDEXABLE;\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n\n    | identifier '(' arguments ')'\n      {\n        YR_OBJECT_FUNCTION* function;\n        char* args_fmt;\n\n        if ($1.type == EXPRESSION_TYPE_OBJECT &&\n            $1.value.object->type == OBJECT_TYPE_FUNCTION)\n        {\n          compiler->last_result = yr_parser_check_types(\n              compiler, (YR_OBJECT_FUNCTION*) $1.value.object, $3);\n\n          if (compiler->last_result == ERROR_SUCCESS)\n            compiler->last_result = yr_arena_write_string(\n              compiler->sz_arena, $3, &args_fmt);\n\n          if (compiler->last_result == ERROR_SUCCESS)\n            compiler->last_result = yr_parser_emit_with_arg_reloc(\n                yyscanner,\n                OP_CALL,\n                args_fmt,\n                NULL,\n                NULL);\n\n          function = (YR_OBJECT_FUNCTION*) $1.value.object;\n\n          $$.type = EXPRESSION_TYPE_OBJECT;\n          $$.value.object = function->return_obj;\n          $$.identifier = function->identifier;\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, $1.identifier);\n\n          compiler->last_result = ERROR_NOT_A_FUNCTION;\n        }\n\n        yr_free($3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    ;\n\n\narguments\n    : /* empty */     { $$ = yr_strdup(\"\"); }\n    | arguments_list  { $$ = $1; }\n\n\narguments_list\n    : expression\n      {\n        $$ = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);\n\n        switch($1.type)\n        {\n          case EXPRESSION_TYPE_INTEGER:\n            strlcpy($$, \"i\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_FLOAT:\n            strlcpy($$, \"f\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_BOOLEAN:\n            strlcpy($$, \"b\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_STRING:\n            strlcpy($$, \"s\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_REGEXP:\n            strlcpy($$, \"r\", MAX_FUNCTION_ARGS);\n            break;\n        }\n\n        ERROR_IF($$ == NULL);\n      }\n    | arguments_list ',' expression\n      {\n        if (strlen($1) == MAX_FUNCTION_ARGS)\n        {\n          compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;\n        }\n        else\n        {\n          switch($3.type)\n          {\n            case EXPRESSION_TYPE_INTEGER:\n              strlcat($1, \"i\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_FLOAT:\n              strlcat($1, \"f\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_BOOLEAN:\n              strlcat($1, \"b\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_STRING:\n              strlcat($1, \"s\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_REGEXP:\n              strlcat($1, \"r\", MAX_FUNCTION_ARGS);\n              break;\n          }\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$ = $1;\n      }\n    ;\n\n\nregexp\n    : _REGEXP_\n      {\n        SIZED_STRING* sized_string = $1;\n        RE* re;\n        RE_ERROR error;\n\n        int re_flags = 0;\n\n        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)\n          re_flags |= RE_FLAGS_NO_CASE;\n\n        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)\n          re_flags |= RE_FLAGS_DOT_ALL;\n\n        compiler->last_result = yr_re_compile(\n            sized_string->c_string,\n            re_flags,\n            compiler->re_code_arena,\n            &re,\n            &error);\n\n        yr_free($1);\n\n        if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)\n          yr_compiler_set_error_extra_info(compiler, error.message);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_PUSH,\n              re->root_node->forward_code,\n              NULL,\n              NULL);\n\n        yr_re_destroy(re);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_REGEXP;\n      }\n    ;\n\n\nboolean_expression\n    : expression\n      {\n        if ($1.type == EXPRESSION_TYPE_STRING)\n        {\n          if ($1.value.sized_string != NULL)\n          {\n            yywarning(yyscanner,\n              \"Using literal string \\\"%s\\\" in a boolean operation.\",\n              $1.value.sized_string->c_string);\n          }\n\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_STR_TO_BOOL, NULL);\n\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n        }\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    ;\n\nexpression\n    : _TRUE_\n      {\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | _FALSE_\n      {\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 0, NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | primary_expression _MATCHES_ regexp\n      {\n        CHECK_TYPE($1, EXPRESSION_TYPE_STRING, \"matches\");\n        CHECK_TYPE($3, EXPRESSION_TYPE_REGEXP, \"matches\");\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_emit(\n              yyscanner,\n              OP_MATCHES,\n              NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | primary_expression _CONTAINS_ primary_expression\n      {\n        CHECK_TYPE($1, EXPRESSION_TYPE_STRING, \"contains\");\n        CHECK_TYPE($3, EXPRESSION_TYPE_STRING, \"contains\");\n\n        compiler->last_result = yr_parser_emit(\n            yyscanner, OP_CONTAINS, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | _STRING_IDENTIFIER_\n      {\n        int result = yr_parser_reduce_string_identifier(\n            yyscanner,\n            $1,\n            OP_FOUND,\n            UNDEFINED);\n\n        yr_free($1);\n\n        ERROR_IF(result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | _STRING_IDENTIFIER_ _AT_ primary_expression\n      {\n        CHECK_TYPE($3, EXPRESSION_TYPE_INTEGER, \"at\");\n\n        compiler->last_result = yr_parser_reduce_string_identifier(\n            yyscanner, $1, OP_FOUND_AT, $3.value.integer);\n\n        yr_free($1);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | _STRING_IDENTIFIER_ _IN_ range\n      {\n        compiler->last_result = yr_parser_reduce_string_identifier(\n            yyscanner, $1, OP_FOUND_IN, UNDEFINED);\n\n        yr_free($1);\n\n        ERROR_IF(compiler->last_result!= ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | _FOR_ for_expression error\n      {\n        if (compiler->loop_depth > 0)\n        {\n          compiler->loop_depth--;\n          compiler->loop_identifier[compiler->loop_depth] = NULL;\n        }\n      }\n    | _FOR_ for_expression _IDENTIFIER_ _IN_\n      {\n        int var_index;\n\n        if (compiler->loop_depth == MAX_LOOP_NESTING)\n          compiler->last_result = \\\n              ERROR_LOOP_NESTING_LIMIT_EXCEEDED;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        var_index = yr_parser_lookup_loop_variable(\n            yyscanner, $3);\n\n        if (var_index >= 0)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, $3);\n\n          compiler->last_result = \\\n              ERROR_DUPLICATED_LOOP_IDENTIFIER;\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        // Push end-of-list marker\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n      integer_set ':'\n      {\n        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n        uint8_t* addr;\n\n        // Clear counter for number of expressions evaluating\n        // to TRUE.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);\n\n        // Clear iterations counter\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);\n\n        if ($6 == INTEGER_SET_ENUMERATION)\n        {\n          // Pop the first integer\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset, &addr, NULL);\n        }\n        else // INTEGER_SET_RANGE\n        {\n          // Pop higher bound of set range\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);\n\n          // Pop lower bound of set range\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset, NULL, NULL);\n        }\n\n        compiler->loop_address[compiler->loop_depth] = addr;\n        compiler->loop_identifier[compiler->loop_depth] = $3;\n        compiler->loop_depth++;\n      }\n      '(' boolean_expression ')'\n      {\n        int mem_offset;\n\n        compiler->loop_depth--;\n        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n\n        // The value at the top of the stack is the result of\n        // evaluating the boolean expression, so it could be\n        // 0, 1 or UNDEFINED. Add this value to a counter\n        // keeping the number of expressions evaluating to true.\n        // If the value is UNDEFINED instruction OP_ADD_M\n        // does nothing.\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);\n\n        // Increment iterations counter\n        yr_parser_emit_with_arg(\n            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);\n\n        if ($6 == INTEGER_SET_ENUMERATION)\n        {\n          yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_JNUNDEF,\n              compiler->loop_address[compiler->loop_depth],\n              NULL,\n              NULL);\n        }\n        else // INTEGER_SET_RANGE\n        {\n          // Increment lower bound of integer set\n          yr_parser_emit_with_arg(\n              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);\n\n          // Push lower bound of integer set\n          yr_parser_emit_with_arg(\n              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);\n\n          // Push higher bound of integer set\n          yr_parser_emit_with_arg(\n              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);\n\n          // Compare higher bound with lower bound, do loop again\n          // if lower bound is still lower or equal than higher bound\n          yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_JLE,\n              compiler->loop_address[compiler->loop_depth],\n              NULL,\n              NULL);\n\n          yr_parser_emit(yyscanner, OP_POP, NULL);\n          yr_parser_emit(yyscanner, OP_POP, NULL);\n        }\n\n        // Pop end-of-list marker.\n        yr_parser_emit(yyscanner, OP_POP, NULL);\n\n        // At this point the loop quantifier (any, all, 1, 2,..)\n        // is at the top of the stack. Check if the quantifier\n        // is undefined (meaning \"all\") and replace it with the\n        // iterations counter in that case.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);\n\n        // Compare the loop quantifier with the number of\n        // expressions evaluating to TRUE.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit(yyscanner, OP_INT_LE, NULL);\n\n        compiler->loop_identifier[compiler->loop_depth] = NULL;\n        yr_free($3);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | _FOR_ for_expression _OF_ string_set ':'\n      {\n        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n        uint8_t* addr;\n\n        if (compiler->loop_depth == MAX_LOOP_NESTING)\n          compiler->last_result = \\\n            ERROR_LOOP_NESTING_LIMIT_EXCEEDED;\n\n        if (compiler->loop_for_of_mem_offset != -1)\n          compiler->last_result = \\\n            ERROR_NESTED_FOR_OF_LOOP;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);\n\n        // Pop the first string.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_POP_M, mem_offset, &addr, NULL);\n\n        compiler->loop_for_of_mem_offset = mem_offset;\n        compiler->loop_address[compiler->loop_depth] = addr;\n        compiler->loop_identifier[compiler->loop_depth] = NULL;\n        compiler->loop_depth++;\n      }\n      '(' boolean_expression ')'\n      {\n        int mem_offset;\n\n        compiler->loop_depth--;\n        compiler->loop_for_of_mem_offset = -1;\n\n        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n\n        // Increment counter by the value returned by the\n        // boolean expression (0 or 1). If the boolean expression\n        // returned UNDEFINED the OP_ADD_M won't do anything.\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);\n\n        // Increment iterations counter.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);\n\n        // If next string is not undefined, go back to the\n        // beginning of the loop.\n        yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JNUNDEF,\n            compiler->loop_address[compiler->loop_depth],\n            NULL,\n            NULL);\n\n        // Pop end-of-list marker.\n        yr_parser_emit(yyscanner, OP_POP, NULL);\n\n        // At this point the loop quantifier (any, all, 1, 2,..)\n        // is at top of the stack. Check if the quantifier is\n        // undefined (meaning \"all\") and replace it with the\n        // iterations counter in that case.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);\n\n        // Compare the loop quantifier with the number of\n        // expressions evaluating to TRUE.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit(yyscanner, OP_INT_LE, NULL);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n\n      }\n    | for_expression _OF_ string_set\n      {\n        yr_parser_emit(yyscanner, OP_OF, NULL);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | _NOT_ boolean_expression\n      {\n        yr_parser_emit(yyscanner, OP_NOT, NULL);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | boolean_expression _AND_\n      {\n        YR_FIXUP* fixup;\n        void* jmp_destination_addr;\n\n        compiler->last_result = yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JFALSE,\n            0,          // still don't know the jump destination\n            NULL,\n            &jmp_destination_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        // create a fixup entry for the jump and push it in the stack\n        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n        if (fixup == NULL)\n          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup->address = jmp_destination_addr;\n        fixup->next = compiler->fixup_stack_head;\n        compiler->fixup_stack_head = fixup;\n      }\n      boolean_expression\n      {\n        YR_FIXUP* fixup;\n        uint8_t* and_addr;\n\n        // Ensure that we have at least two consecutive bytes in the arena's\n        // current page, one for the AND opcode and one for opcode following the\n        // AND. This is necessary because we need to compute the address for the\n        // opcode following the AND, and we don't want the AND in one page and\n        // the following opcode in another page.\n\n        compiler->last_result = yr_arena_reserve_memory(\n            compiler->code_arena, 2);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        // Now we know the jump destination, which is the address of the\n        // instruction following the AND. Let's fixup the jump address.\n\n        fixup = compiler->fixup_stack_head;\n\n        // We know that the AND opcode and the following one are within the same\n        // page, so we can compute the address for the opcode following the AND\n        // by simply adding one to its address.\n\n        *(void**)(fixup->address) = (void*)(and_addr + 1);\n\n        compiler->fixup_stack_head = fixup->next;\n        yr_free(fixup);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | boolean_expression _OR_\n      {\n        YR_FIXUP* fixup;\n        void* jmp_destination_addr;\n\n        compiler->last_result = yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JTRUE,\n            0,         // still don't know the jump destination\n            NULL,\n            &jmp_destination_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n        if (fixup == NULL)\n          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup->address = jmp_destination_addr;\n        fixup->next = compiler->fixup_stack_head;\n        compiler->fixup_stack_head = fixup;\n      }\n      boolean_expression\n      {\n        YR_FIXUP* fixup;\n        uint8_t* or_addr;\n\n        // Ensure that we have at least two consecutive bytes in the arena's\n        // current page, one for the OR opcode and one for opcode following the\n        // OR. This is necessary because we need to compute the address for the\n        // opcode following the OR, and we don't want the OR in one page and\n        // the following opcode in another page.\n\n        compiler->last_result = yr_arena_reserve_memory(\n            compiler->code_arena, 2);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        // Now we know the jump destination, which is the address of the\n        // instruction following the OP_OR. Let's fixup the jump address.\n\n        fixup = compiler->fixup_stack_head;\n\n        // We know that the OR opcode and the following one are within the same\n        // page, so we can compute the address for the opcode following the OR\n        // by simply adding one to its address.\n\n        *(void**)(fixup->address) = (void*)(or_addr + 1);\n\n        compiler->fixup_stack_head = fixup->next;\n        yr_free(fixup);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | primary_expression _LT_ primary_expression\n      {\n        compiler->last_result = yr_parser_reduce_operation(\n            yyscanner, \"<\", $1, $3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | primary_expression _GT_ primary_expression\n      {\n        compiler->last_result = yr_parser_reduce_operation(\n            yyscanner, \">\", $1, $3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | primary_expression _LE_ primary_expression\n      {\n        compiler->last_result = yr_parser_reduce_operation(\n            yyscanner, \"<=\", $1, $3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | primary_expression _GE_ primary_expression\n      {\n        compiler->last_result = yr_parser_reduce_operation(\n            yyscanner, \">=\", $1, $3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | primary_expression _EQ_ primary_expression\n      {\n        compiler->last_result = yr_parser_reduce_operation(\n            yyscanner, \"==\", $1, $3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | primary_expression _NEQ_ primary_expression\n      {\n        compiler->last_result = yr_parser_reduce_operation(\n            yyscanner, \"!=\", $1, $3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_BOOLEAN;\n      }\n    | primary_expression\n      {\n        $$ = $1;\n      }\n    |'(' expression ')'\n      {\n        $$ = $2;\n      }\n    ;\n\n\ninteger_set\n    : '(' integer_enumeration ')'  { $$ = INTEGER_SET_ENUMERATION; }\n    | range                        { $$ = INTEGER_SET_RANGE; }\n    ;\n\n\nrange\n    : '(' primary_expression _DOT_DOT_  primary_expression ')'\n      {\n        if ($2.type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for range's lower bound\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n        }\n\n        if ($4.type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for range's upper bound\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    ;\n\n\ninteger_enumeration\n    : primary_expression\n      {\n        if ($1.type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for enumeration item\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    | integer_enumeration ',' primary_expression\n      {\n        if ($3.type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for enumeration item\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    ;\n\n\nstring_set\n    : '('\n      {\n        // Push end-of-list marker\n        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n      }\n      string_enumeration ')'\n    | _THEM_\n      {\n        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n        yr_parser_emit_pushes_for_strings(yyscanner, \"$*\");\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    ;\n\n\nstring_enumeration\n    : string_enumeration_item\n    | string_enumeration ',' string_enumeration_item\n    ;\n\n\nstring_enumeration_item\n    : _STRING_IDENTIFIER_\n      {\n        yr_parser_emit_pushes_for_strings(yyscanner, $1);\n        yr_free($1);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    | _STRING_IDENTIFIER_WITH_WILDCARD_\n      {\n        yr_parser_emit_pushes_for_strings(yyscanner, $1);\n        yr_free($1);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    ;\n\n\nfor_expression\n    : primary_expression\n    | _ALL_\n      {\n        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n      }\n    | _ANY_\n      {\n        yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);\n      }\n    ;\n\n\nprimary_expression\n    : '(' primary_expression ')'\n      {\n        $$ = $2;\n      }\n    | _FILESIZE_\n      {\n        compiler->last_result = yr_parser_emit(\n            yyscanner, OP_FILESIZE, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = UNDEFINED;\n      }\n    | _ENTRYPOINT_\n      {\n        yywarning(yyscanner,\n            \"Using deprecated \\\"entrypoint\\\" keyword. Use the \\\"entry_point\\\" \"\n            \"function from PE module instead.\");\n\n        compiler->last_result = yr_parser_emit(\n            yyscanner, OP_ENTRYPOINT, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = UNDEFINED;\n      }\n    | _INTEGER_FUNCTION_ '(' primary_expression ')'\n      {\n        CHECK_TYPE($3, EXPRESSION_TYPE_INTEGER, \"intXXXX or uintXXXX\");\n\n        // _INTEGER_FUNCTION_ could be any of int8, int16, int32, uint8,\n        // uint32, etc. $1 contains an index that added to OP_READ_INT results\n        // in the proper OP_INTXX opcode.\n\n        compiler->last_result = yr_parser_emit(\n            yyscanner, (uint8_t) (OP_READ_INT + $1), NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = UNDEFINED;\n      }\n    | _NUMBER_\n      {\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, $1, NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = $1;\n      }\n    | _DOUBLE_\n      {\n        compiler->last_result = yr_parser_emit_with_arg_double(\n            yyscanner, OP_PUSH, $1, NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_FLOAT;\n      }\n    | _TEXT_STRING_\n      {\n        SIZED_STRING* sized_string;\n\n        compiler->last_result = yr_arena_write_data(\n            compiler->sz_arena,\n            $1,\n            $1->length + sizeof(SIZED_STRING),\n            (void**) &sized_string);\n\n        yr_free($1);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_PUSH,\n              sized_string,\n              NULL,\n              NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_STRING;\n        $$.value.sized_string = sized_string;\n      }\n    | _STRING_COUNT_\n      {\n        compiler->last_result = yr_parser_reduce_string_identifier(\n            yyscanner, $1, OP_COUNT, UNDEFINED);\n\n        yr_free($1);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = UNDEFINED;\n      }\n    | _STRING_OFFSET_ '[' primary_expression ']'\n      {\n        compiler->last_result = yr_parser_reduce_string_identifier(\n            yyscanner, $1, OP_OFFSET, UNDEFINED);\n\n        yr_free($1);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = UNDEFINED;\n      }\n    | _STRING_OFFSET_\n      {\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_reduce_string_identifier(\n              yyscanner, $1, OP_OFFSET, UNDEFINED);\n\n        yr_free($1);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = UNDEFINED;\n      }\n    | _STRING_LENGTH_ '[' primary_expression ']'\n      {\n        compiler->last_result = yr_parser_reduce_string_identifier(\n            yyscanner, $1, OP_LENGTH, UNDEFINED);\n\n        yr_free($1);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = UNDEFINED;\n      }\n    | _STRING_LENGTH_\n      {\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_reduce_string_identifier(\n              yyscanner, $1, OP_LENGTH, UNDEFINED);\n\n        yr_free($1);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = UNDEFINED;\n      }\n    | identifier\n      {\n        if ($1.type == EXPRESSION_TYPE_INTEGER)  // loop identifier\n        {\n          $$.type = EXPRESSION_TYPE_INTEGER;\n          $$.value.integer = UNDEFINED;\n        }\n        else if ($1.type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier\n        {\n          $$.type = EXPRESSION_TYPE_BOOLEAN;\n          $$.value.integer = UNDEFINED;\n        }\n        else if ($1.type == EXPRESSION_TYPE_OBJECT)\n        {\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_OBJ_VALUE, NULL);\n\n          switch($1.value.object->type)\n          {\n            case OBJECT_TYPE_INTEGER:\n              $$.type = EXPRESSION_TYPE_INTEGER;\n              $$.value.integer = UNDEFINED;\n              break;\n            case OBJECT_TYPE_FLOAT:\n              $$.type = EXPRESSION_TYPE_FLOAT;\n              break;\n            case OBJECT_TYPE_STRING:\n              $$.type = EXPRESSION_TYPE_STRING;\n              $$.value.sized_string = NULL;\n              break;\n            default:\n              yr_compiler_set_error_extra_info_fmt(\n                  compiler,\n                  \"wrong usage of identifier \\\"%s\\\"\",\n                  $1.identifier);\n              compiler->last_result = ERROR_WRONG_TYPE;\n          }\n        }\n        else\n        {\n          assert(FALSE);\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    | '-' primary_expression %prec UNARY_MINUS\n      {\n        CHECK_TYPE($2, EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, \"-\");\n\n        if ($2.type == EXPRESSION_TYPE_INTEGER)\n        {\n          $$.type = EXPRESSION_TYPE_INTEGER;\n          $$.value.integer = ($2.value.integer == UNDEFINED) ?\n              UNDEFINED : -($2.value.integer);\n          compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);\n        }\n        else if ($2.type == EXPRESSION_TYPE_FLOAT)\n        {\n          $$.type = EXPRESSION_TYPE_FLOAT;\n          compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n    | primary_expression '+' primary_expression\n      {\n        compiler->last_result = yr_parser_reduce_operation(\n            yyscanner, \"+\", $1, $3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ($1.type == EXPRESSION_TYPE_INTEGER &&\n            $3.type == EXPRESSION_TYPE_INTEGER)\n        {\n          $$.value.integer = OPERATION(+, $1.value.integer, $3.value.integer);\n          $$.type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n          $$.type = EXPRESSION_TYPE_FLOAT;\n        }\n      }\n    | primary_expression '-' primary_expression\n      {\n        compiler->last_result = yr_parser_reduce_operation(\n            yyscanner, \"-\", $1, $3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ($1.type == EXPRESSION_TYPE_INTEGER &&\n            $3.type == EXPRESSION_TYPE_INTEGER)\n        {\n          $$.value.integer = OPERATION(-, $1.value.integer, $3.value.integer);\n          $$.type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n          $$.type = EXPRESSION_TYPE_FLOAT;\n        }\n      }\n    | primary_expression '*' primary_expression\n      {\n        compiler->last_result = yr_parser_reduce_operation(\n            yyscanner, \"*\", $1, $3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ($1.type == EXPRESSION_TYPE_INTEGER &&\n            $3.type == EXPRESSION_TYPE_INTEGER)\n        {\n          $$.value.integer = OPERATION(*, $1.value.integer, $3.value.integer);\n          $$.type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n          $$.type = EXPRESSION_TYPE_FLOAT;\n        }\n      }\n    | primary_expression '\\\\' primary_expression\n      {\n        compiler->last_result = yr_parser_reduce_operation(\n            yyscanner, \"\\\\\", $1, $3);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ($1.type == EXPRESSION_TYPE_INTEGER &&\n            $3.type == EXPRESSION_TYPE_INTEGER)\n        {\n          if ($3.value.integer != 0)\n          {\n            $$.value.integer = OPERATION(/, $1.value.integer, $3.value.integer);\n            $$.type = EXPRESSION_TYPE_INTEGER;\n          }\n          else\n          {\n            compiler->last_result = ERROR_DIVISION_BY_ZERO;\n            ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n          }\n        }\n        else\n        {\n          $$.type = EXPRESSION_TYPE_FLOAT;\n        }\n      }\n    | primary_expression '%' primary_expression\n      {\n        CHECK_TYPE($1, EXPRESSION_TYPE_INTEGER, \"%\");\n        CHECK_TYPE($3, EXPRESSION_TYPE_INTEGER, \"%\");\n\n        yr_parser_emit(yyscanner, OP_MOD, NULL);\n\n        if ($3.value.integer != 0)\n        {\n          $$.value.integer = OPERATION(%, $1.value.integer, $3.value.integer);\n          $$.type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n          compiler->last_result = ERROR_DIVISION_BY_ZERO;\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n        }\n      }\n    | primary_expression '^' primary_expression\n      {\n        CHECK_TYPE($1, EXPRESSION_TYPE_INTEGER, \"^\");\n        CHECK_TYPE($3, EXPRESSION_TYPE_INTEGER, \"^\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = OPERATION(^, $1.value.integer, $3.value.integer);\n      }\n    | primary_expression '&' primary_expression\n      {\n        CHECK_TYPE($1, EXPRESSION_TYPE_INTEGER, \"^\");\n        CHECK_TYPE($3, EXPRESSION_TYPE_INTEGER, \"^\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = OPERATION(&, $1.value.integer, $3.value.integer);\n      }\n    | primary_expression '|' primary_expression\n      {\n        CHECK_TYPE($1, EXPRESSION_TYPE_INTEGER, \"|\");\n        CHECK_TYPE($3, EXPRESSION_TYPE_INTEGER, \"|\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = OPERATION(|, $1.value.integer, $3.value.integer);\n      }\n    | '~' primary_expression\n      {\n        CHECK_TYPE($2, EXPRESSION_TYPE_INTEGER, \"~\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = ($2.value.integer == UNDEFINED) ?\n            UNDEFINED : ~($2.value.integer);\n      }\n    | primary_expression _SHIFT_LEFT_ primary_expression\n      {\n        CHECK_TYPE($1, EXPRESSION_TYPE_INTEGER, \"<<\");\n        CHECK_TYPE($3, EXPRESSION_TYPE_INTEGER, \"<<\");\n\n        yr_parser_emit(yyscanner, OP_SHL, NULL);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = OPERATION(<<, $1.value.integer, $3.value.integer);\n      }\n    | primary_expression _SHIFT_RIGHT_ primary_expression\n      {\n        CHECK_TYPE($1, EXPRESSION_TYPE_INTEGER, \">>\");\n        CHECK_TYPE($3, EXPRESSION_TYPE_INTEGER, \">>\");\n\n        yr_parser_emit(yyscanner, OP_SHR, NULL);\n\n        $$.type = EXPRESSION_TYPE_INTEGER;\n        $$.value.integer = OPERATION(>>, $1.value.integer, $3.value.integer);\n      }\n    | regexp\n      {\n        $$ = $1;\n      }\n    ;\n\n%%\n"], "filenames": ["libyara/grammar.y"], "buggy_code_start_loc": [1020], "buggy_code_end_loc": [1022], "fixing_code_start_loc": [1020], "fixing_code_end_loc": [1025], "type": "CWE-416", "message": "libyara/grammar.y in YARA 3.5.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted rule that is mishandled in the yr_compiler_destroy function.", "other": {"cve": {"id": "CVE-2017-5924", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-03T05:59:00.737", "lastModified": "2017-05-02T01:59:02.937", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "libyara/grammar.y in YARA 3.5.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted rule that is mishandled in the yr_compiler_destroy function."}, {"lang": "es", "value": "libyara/grammar.y en YARA 3.5.0 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (uso despu\u00e9s de liberaci\u00f3n de memoria y ca\u00edda de la aplicaci\u00f3n) a trav\u00e9s de una regla manipulada que no se maneja correctamente en la funci\u00f3n yr_compiler_destroy."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:virustotal:yara:3.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "0254F781-4B89-4557-8F17-1F228A3A8216"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/98075", "source": "cve@mitre.org"}, {"url": "https://github.com/VirusTotal/yara/commit/7f02eca670f29c00a1d2c305e96febae6ce5d37b", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/VirusTotal/yara/issues/593", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/VirusTotal/yara/commit/7f02eca670f29c00a1d2c305e96febae6ce5d37b"}}