{"buggy_code": ["/*--------------------------------------------------------------------------\n *  Copyright 2011 Taro L. Saito\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *--------------------------------------------------------------------------*/\n//--------------------------------------\n// snappy-java Project\n//\n// Snappy.java\n// Since: 2011/03/29\n//\n// $URL$\n// $Author$\n//--------------------------------------\npackage org.xerial.snappy;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URL;\nimport java.nio.Buffer;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.util.Properties;\n\n/**\n * Snappy API for data compression/decompression\n * <p/>\n * Note: if the native libraries cannot be loaded, an ExceptionInInitializerError\n * will be thrown at first use of this class.\n *\n * @author Taro L. Saito\n */\npublic class Snappy\n{\n    static {\n        init();\n    }\n\n    /**\n     * An instance of SnappyNative\n     */\n    private static SnappyApi impl;\n\n    /**\n     * Clean up a temporary file (native lib) generated by snappy-java.\n     * General users do not need to call this method, since the native library extracted in snappy-java\n     * is deleted upon JVM termination (vie deleteOnExit()).\n     * This method is useful when using a J2EE container, which will restart servlet containers multiple times without\n     * restarting JVM.\n     */\n    public static void cleanUp()\n    {\n        SnappyLoader.cleanUpExtractedNativeLib();\n        SnappyLoader.setSnappyApi(null);\n    }\n\n    static void init() {\n        try {\n            impl = SnappyLoader.loadSnappyApi();\n        }\n        catch (Exception e) {\n            throw new ExceptionInInitializerError(e);\n        }\n    }\n\n    /**\n     * Copy bytes from source to destination\n     *\n     * @param src pointer to the source array\n     * @param offset byte offset in the source array\n     * @param byteLength the number of bytes to copy\n     * @param dest pointer to the destination array\n     * @param dest_offset byte offset in the destination array\n     * @throws IOException\n     */\n    public static void arrayCopy(Object src, int offset, int byteLength, Object dest, int dest_offset)\n            throws IOException\n    {\n        impl.arrayCopy(src, offset, byteLength, dest, dest_offset);\n    }\n\n    /**\n     * High-level API for compressing the input byte array. This method performs\n     * array copy to generate the result. If you want to reduce the memory copy\n     * cost, use {@link #compress(byte[], int, int, byte[], int)} or\n     * {@link #compress(ByteBuffer, ByteBuffer)}.\n     *\n     * @param input the input data\n     * @return the compressed byte array\n     * @throws IOException\n     */\n    public static byte[] compress(byte[] input)\n            throws IOException\n    {\n        return rawCompress(input, input.length);\n    }\n\n    /**\n     * Compress the input buffer content in [inputOffset,\n     * ...inputOffset+inputLength) then output to the specified output buffer.\n     *\n     * @param input\n     * @param inputOffset\n     * @param inputLength\n     * @param output\n     * @param outputOffset\n     * @return byte size of the compressed data\n     * @throws IOException when failed to access the input/output buffer\n     */\n    public static int compress(byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset)\n            throws IOException\n    {\n        return rawCompress(input, inputOffset, inputLength, output, outputOffset);\n    }\n\n    /**\n     * Compress the content in the given input buffer. After the compression,\n     * you can retrieve the compressed data from the output buffer [pos() ...\n     * limit()) (compressed data size = limit() - pos() = remaining())\n     *\n     * @param uncompressed buffer[pos() ... limit()) containing the input data\n     * @param compressed output of the compressed data. Uses range [pos()..].\n     * @return byte size of the compressed data.\n     * @throws SnappyError when the input is not a direct buffer\n     */\n    public static int compress(ByteBuffer uncompressed, ByteBuffer compressed)\n            throws IOException\n    {\n\n        if (!uncompressed.isDirect()) {\n            throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, \"input is not a direct buffer\");\n        }\n        if (!compressed.isDirect()) {\n            throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, \"destination is not a direct buffer\");\n        }\n\n        // input: uncompressed[pos(), limit())\n        // output: compressed\n        int uPos = uncompressed.position();\n        int uLen = uncompressed.remaining();\n        int cPos = compressed.position();\n        int compressedSize = impl.rawCompress(uncompressed, uPos, uLen, compressed,\n                cPos);\n\n        //         pos  limit\n        // [ ......BBBBBBB.........]\n        ((Buffer) compressed).limit(cPos + compressedSize);\n\n        return compressedSize;\n    }\n\n    /**\n     * Compress the input char array\n     *\n     * @param input\n     * @return the compressed data\n     */\n    public static byte[] compress(char[] input)\n            throws IOException\n    {\n        return rawCompress(input, input.length * 2); // char uses 2 bytes\n    }\n\n    /**\n     * Compress the input double array\n     *\n     * @param input\n     * @return the compressed data\n     */\n    public static byte[] compress(double[] input)\n            throws IOException\n    {\n        return rawCompress(input, input.length * 8); // double uses 8 bytes\n    }\n\n    /**\n     * Compress the input float array\n     *\n     * @param input\n     * @return the compressed data\n     */\n    public static byte[] compress(float[] input)\n            throws IOException\n    {\n        return rawCompress(input, input.length * 4); // float uses 4 bytes\n    }\n\n    /**\n     * Compress the input int array\n     *\n     * @param input\n     * @return the compressed data\n     */\n    public static byte[] compress(int[] input)\n            throws IOException\n    {\n        return rawCompress(input, input.length * 4); // int uses 4 bytes\n    }\n\n    /**\n     * Compress the input long array\n     *\n     * @param input\n     * @return the compressed data\n     */\n    public static byte[] compress(long[] input)\n            throws IOException\n    {\n        return rawCompress(input, input.length * 8); // long uses 8 bytes\n    }\n\n    /**\n     * Compress the input short array\n     *\n     * @param input\n     * @return the compressed data\n     */\n    public static byte[] compress(short[] input)\n            throws IOException\n    {\n        return rawCompress(input, input.length * 2); // short uses 2 bytes\n    }\n\n    /**\n     * Compress the input String\n     *\n     * @param s\n     * @return the compressed data\n     * @throws IOException\n     */\n    public static byte[] compress(String s)\n            throws IOException\n    {\n        try {\n            return compress(s, \"UTF-8\");\n        }\n        catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"UTF-8 encoder is not found\");\n        }\n    }\n\n    /**\n     * Compress the input string using the given encoding\n     *\n     * @param s\n     * @param encoding\n     * @return the compressed data\n     * @throws UnsupportedEncodingException\n     * @throws IOException\n     */\n    public static byte[] compress(String s, String encoding)\n            throws UnsupportedEncodingException, IOException\n    {\n        byte[] data = s.getBytes(encoding);\n        return compress(data);\n    }\n\n    /**\n     * Compress the input string using the given encoding\n     *\n     * @param s\n     * @param encoding\n     * @return the compressed data\n     * @throws UnsupportedEncodingException\n     * @throws IOException\n     */\n    public static byte[] compress(String s, Charset encoding)\n            throws IOException\n    {\n        byte[] data = s.getBytes(encoding);\n        return compress(data);\n    }\n\n    /**\n     * Get the native library version of the snappy\n     *\n     * @return native library version\n     */\n    public static String getNativeLibraryVersion()\n    {\n        URL versionFile = SnappyLoader.class.getResource(\"/org/xerial/snappy/VERSION\");\n\n        String version = \"unknown\";\n        try {\n            if (versionFile != null) {\n                InputStream in = null;\n                try {\n                    Properties versionData = new Properties();\n                    in = versionFile.openStream();\n                    versionData.load(in);\n                    version = versionData.getProperty(\"version\", version);\n                    if (version.equals(\"unknown\")) {\n                        version = versionData.getProperty(\"SNAPPY_VERSION\", version);\n                    }\n                    version = version.trim().replaceAll(\"[^0-9\\\\.]\", \"\");\n                }\n                finally {\n                    if(in != null) {\n                        in.close();\n                    }\n                }\n            }\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n        return version;\n    }\n\n    /**\n     * Returns true iff the contents of compressed buffer [offset,\n     * offset+length) can be uncompressed successfully. Does not return the\n     * uncompressed data. Takes time proportional to the input length, but is\n     * usually at least a factor of four faster than actual decompression.\n     */\n    public static boolean isValidCompressedBuffer(byte[] input, int offset, int length)\n            throws IOException\n    {\n        if (input == null) {\n            throw new NullPointerException(\"input is null\");\n        }\n        return impl.isValidCompressedBuffer(input, offset, length);\n    }\n\n    /**\n     * Returns true iff the contents of compressed buffer [offset,\n     * offset+length) can be uncompressed successfully. Does not return the\n     * uncompressed data. Takes time proportional to the input length, but is\n     * usually at least a factor of four faster than actual decompression.\n     */\n    public static boolean isValidCompressedBuffer(byte[] input)\n            throws IOException\n    {\n        return isValidCompressedBuffer(input, 0, input.length);\n    }\n\n    /**\n     * Returns true iff the contents of compressed buffer [pos() ... limit())\n     * can be uncompressed successfully. Does not return the uncompressed data.\n     * Takes time proportional to the input length, but is usually at least a\n     * factor of four faster than actual decompression.\n     */\n    public static boolean isValidCompressedBuffer(ByteBuffer compressed)\n            throws IOException\n    {\n        return impl.isValidCompressedBuffer(compressed, compressed.position(),\n                compressed.remaining());\n    }\n\n    /**\n     * Returns true iff the contents of compressed buffer [offset,\n     * offset+length) can be uncompressed successfully. Does not return the\n     * uncompressed data. Takes time proportional to the input length, but is\n     * usually at least a factor of four faster than actual decompression.\n     */\n    public static boolean isValidCompressedBuffer(long inputAddr, long offset, long length)\n            throws IOException\n    {\n        return impl.isValidCompressedBuffer(inputAddr, offset, length);\n    }\n\n    /**\n     * Get the maximum byte size needed for compressing data of the given byte\n     * size.\n     *\n     * @param byteSize byte size of the data to compress\n     * @return maximum byte size of the compressed data\n     */\n    public static int maxCompressedLength(int byteSize)\n    {\n        return impl.maxCompressedLength(byteSize);\n    }\n\n    /**\n     * Zero-copy compress using memory addresses.\n     *\n     * @param inputAddr input memory address\n     * @param inputSize input byte size\n     * @param destAddr destination address of the compressed data\n     * @return the compressed data size\n     * @throws IOException\n     */\n    public static long rawCompress(long inputAddr, long inputSize, long destAddr)\n            throws IOException\n    {\n        return impl.rawCompress(inputAddr, inputSize, destAddr);\n    }\n\n    /**\n     * Zero-copy decompress using memory addresses.\n     *\n     * @param inputAddr input memory address\n     * @param inputSize input byte size\n     * @param destAddr destination address of the uncompressed data\n     * @return the uncompressed data size\n     * @throws IOException\n     */\n    public static long rawUncompress(long inputAddr, long inputSize, long destAddr)\n            throws IOException\n    {\n        return impl.rawUncompress(inputAddr, inputSize, destAddr);\n    }\n\n    /**\n     * Compress the input data and produce a byte array of the uncompressed data\n     *\n     * @param data input array. The input MUST be an array type\n     * @param byteSize the input byte size\n     * @return compressed data\n     */\n    public static byte[] rawCompress(Object data, int byteSize)\n            throws IOException\n    {\n        byte[] buf = new byte[Snappy.maxCompressedLength(byteSize)];\n        int compressedByteSize = impl.rawCompress(data, 0, byteSize, buf, 0);\n        byte[] result = new byte[compressedByteSize];\n        System.arraycopy(buf, 0, result, 0, compressedByteSize);\n        return result;\n    }\n\n    /**\n     * Compress the input buffer [offset,... ,offset+length) contents, then\n     * write the compressed data to the output buffer[offset, ...)\n     *\n     * @param input input array. This MUST be a primitive array type\n     * @param inputOffset byte offset at the output array\n     * @param inputLength byte length of the input data\n     * @param output output array. This MUST be a primitive array type\n     * @param outputOffset byte offset at the output array\n     * @return byte size of the compressed data\n     * @throws IOException\n     */\n    public static int rawCompress(Object input, int inputOffset, int inputLength, byte[] output, int outputOffset)\n            throws IOException\n    {\n        if (input == null || output == null) {\n            throw new NullPointerException(\"input or output is null\");\n        }\n\n        int compressedSize = impl\n                .rawCompress(input, inputOffset, inputLength, output, outputOffset);\n        return compressedSize;\n    }\n\n    /**\n     * Uncompress the content in the input buffer. The uncompressed data is\n     * written to the output buffer.\n     * <p/>\n     * Note that if you pass the wrong data or the range [inputOffset,\n     * inputOffset + inputLength) that cannot be uncompressed, your JVM might\n     * crash due to the access violation exception issued in the native code\n     * written in C++. To avoid this type of crash, use\n     * {@link #isValidCompressedBuffer(byte[], int, int)} first.\n     *\n     * @param input input byte array\n     * @param inputOffset byte offset in the input byte array\n     * @param inputLength byte length of the input data\n     * @param output output buffer, MUST be a primitive type array\n     * @param outputOffset byte offset in the output buffer\n     * @return the byte size of the uncompressed data\n     * @throws IOException when failed to uncompress the input data\n     */\n    public static int rawUncompress(byte[] input, int inputOffset, int inputLength, Object output, int outputOffset)\n            throws IOException\n    {\n        if (input == null || output == null) {\n            throw new NullPointerException(\"input or output is null\");\n        }\n        return impl.rawUncompress(input, inputOffset, inputLength, output, outputOffset);\n    }\n\n    /**\n     * High-level API for uncompressing the input byte array.\n     *\n     * @param input\n     * @return the uncompressed byte array\n     * @throws IOException\n     */\n    public static byte[] uncompress(byte[] input)\n            throws IOException\n    {\n        byte[] result = new byte[Snappy.uncompressedLength(input)];\n        Snappy.uncompress(input, 0, input.length, result, 0);\n        return result;\n    }\n\n    /**\n     * Uncompress the content in the input buffer. The uncompressed data is\n     * written to the output buffer.\n     * <p/>\n     * Note that if you pass the wrong data or the range [inputOffset,\n     * inputOffset + inputLength) that cannot be uncompressed, your JVM might\n     * crash due to the access violation exception issued in the native code\n     * written in C++. To avoid this type of crash, use\n     * {@link #isValidCompressedBuffer(byte[], int, int)} first.\n     *\n     * @param input\n     * @param inputOffset\n     * @param inputLength\n     * @param output\n     * @param outputOffset\n     * @return the byte size of the uncompressed data\n     * @throws IOException\n     */\n    public static int uncompress(byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset)\n            throws IOException\n    {\n        return rawUncompress(input, inputOffset, inputLength, output, outputOffset);\n    }\n\n    /**\n     * Uncompress the content in the input buffer. The result is dumped to the\n     * specified output buffer.\n     * <p/>\n     * Note that if you pass the wrong data or the range [pos(), limit()) that\n     * cannot be uncompressed, your JVM might crash due to the access violation\n     * exception issued in the native code written in C++. To avoid this type of\n     * crash, use {@link #isValidCompressedBuffer(ByteBuffer)} first.\n     *\n     * @param compressed buffer[pos() ... limit()) containing the input data\n     * @param uncompressed output of the the uncompressed data. It uses buffer[pos()..]\n     * @return uncompressed data size\n     * @throws IOException when failed to uncompress the given input\n     * @throws SnappyError when the input is not a direct buffer\n     */\n    public static int uncompress(ByteBuffer compressed, ByteBuffer uncompressed)\n            throws IOException\n    {\n\n        if (!compressed.isDirect()) {\n            throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, \"input is not a direct buffer\");\n        }\n        if (!uncompressed.isDirect()) {\n            throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, \"destination is not a direct buffer\");\n        }\n\n        int cPos = compressed.position();\n        int cLen = compressed.remaining();\n        int uPos = uncompressed.position();\n\n        //         pos  limit\n        // [ ......UUUUUU.........]\n        int decompressedSize = impl.rawUncompress(compressed, cPos, cLen, uncompressed,\n                uPos);\n        uncompressed.limit(uPos + decompressedSize);\n\n        return decompressedSize;\n    }\n\n    /**\n     * Uncompress the input data as char array\n     *\n     * @param input\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static char[] uncompressCharArray(byte[] input)\n            throws IOException\n    {\n        return uncompressCharArray(input, 0, input.length);\n    }\n\n    /**\n     * Uncompress the input[offset, .., offset+length) as a char array\n     *\n     * @param input\n     * @param offset\n     * @param length\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static char[] uncompressCharArray(byte[] input, int offset, int length)\n            throws IOException\n    {\n        int uncompressedLength = Snappy.uncompressedLength(input, offset, length);\n        char[] result = new char[uncompressedLength / 2];\n        impl.rawUncompress(input, offset, length, result, 0);\n        return result;\n    }\n\n    /**\n     * Uncompress the input as a double array\n     *\n     * @param input\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static double[] uncompressDoubleArray(byte[] input)\n            throws IOException\n    {\n        return uncompressDoubleArray(input, 0, input.length);\n    }\n\n    /**\n     * Uncompress the input as a double array\n     *\n     * @param input\n     * @param offset\n     * @param length\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static double[] uncompressDoubleArray(byte[] input, int offset, int length)\n            throws IOException\n    {\n        int uncompressedLength = Snappy.uncompressedLength(input, offset, length);\n        double[] result = new double[uncompressedLength / 8];\n        impl.rawUncompress(input, offset, length, result, 0);\n        return result;\n    }\n\n    /**\n     * Get the uncompressed byte size of the given compressed input. This\n     * operation takes O(1) time.\n     *\n     * @param input\n     * @return uncompressed byte size of the the given input data\n     * @throws IOException when failed to uncompress the given input. The error code is\n     * {@link SnappyErrorCode#PARSING_ERROR}\n     */\n    public static int uncompressedLength(byte[] input)\n            throws IOException\n    {\n        return impl.uncompressedLength(input, 0, input.length);\n    }\n\n    /**\n     * Get the uncompressed byte size of the given compressed input. This\n     * operation takes O(1) time.\n     *\n     * @param input\n     * @param offset\n     * @param length\n     * @return uncompressed byte size of the the given input data\n     * @throws IOException when failed to uncompress the given input. The error code is\n     * {@link SnappyErrorCode#PARSING_ERROR}\n     */\n    public static int uncompressedLength(byte[] input, int offset, int length)\n            throws IOException\n    {\n        if (input == null) {\n            throw new NullPointerException(\"input is null\");\n        }\n\n        return impl.uncompressedLength(input, offset, length);\n    }\n\n    /**\n     * Get the uncompressed byte size of the given compressed input. This\n     * operation takes O(1) time.\n     *\n     * @param compressed input data [pos() ... limit())\n     * @return uncompressed byte length of the given input\n     * @throws IOException when failed to uncompress the given input. The error code is\n     * {@link SnappyErrorCode#PARSING_ERROR}\n     * @throws SnappyError when the input is not a direct buffer\n     */\n    public static int uncompressedLength(ByteBuffer compressed)\n            throws IOException\n    {\n        if (!compressed.isDirect()) {\n            throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, \"input is not a direct buffer\");\n        }\n\n        return impl.uncompressedLength(compressed, compressed.position(), compressed.remaining());\n    }\n\n    /**\n     * Get the uncompressed byte size of the given compressed input. This operation takes O(1) time.\n     *\n     * @param inputAddr compressed data address\n     * @param len byte length of the input\n     * @return uncompressed byte length of the given input\n     * @throws IOException when failed to uncompress the given input. The error code is\n     * {@link SnappyErrorCode#PARSING_ERROR}\n     */\n    public static long uncompressedLength(long inputAddr, long len)\n            throws IOException\n    {\n        return impl.uncompressedLength(inputAddr, len);\n    }\n\n    /**\n     * Uncompress the input as a float array\n     *\n     * @param input\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static float[] uncompressFloatArray(byte[] input)\n            throws IOException\n    {\n        return uncompressFloatArray(input, 0, input.length);\n    }\n\n    /**\n     * Uncompress the input[offset, offset+length) as a float array\n     *\n     * @param input\n     * @param offset\n     * @param length\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static float[] uncompressFloatArray(byte[] input, int offset, int length)\n            throws IOException\n    {\n        int uncompressedLength = Snappy.uncompressedLength(input, offset, length);\n        float[] result = new float[uncompressedLength / 4];\n        impl.rawUncompress(input, offset, length, result, 0);\n        return result;\n    }\n\n    /**\n     * Uncompress the input data as an int array\n     *\n     * @param input\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static int[] uncompressIntArray(byte[] input)\n            throws IOException\n    {\n        return uncompressIntArray(input, 0, input.length);\n    }\n\n    /**\n     * Uncompress the input[offset, offset+length) as an int array\n     *\n     * @param input\n     * @param offset\n     * @param length\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static int[] uncompressIntArray(byte[] input, int offset, int length)\n            throws IOException\n    {\n        int uncompressedLength = Snappy.uncompressedLength(input, offset, length);\n        int[] result = new int[uncompressedLength / 4];\n        impl.rawUncompress(input, offset, length, result, 0);\n        return result;\n    }\n\n    /**\n     * Uncompress the input data as a long array\n     *\n     * @param input\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static long[] uncompressLongArray(byte[] input)\n            throws IOException\n    {\n        return uncompressLongArray(input, 0, input.length);\n    }\n\n    /**\n     * Uncompress the input[offset, offset+length) as a long array\n     *\n     * @param input\n     * @param offset\n     * @param length\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static long[] uncompressLongArray(byte[] input, int offset, int length)\n            throws IOException\n    {\n        int uncompressedLength = Snappy.uncompressedLength(input, offset, length);\n        long[] result = new long[uncompressedLength / 8];\n        impl.rawUncompress(input, offset, length, result, 0);\n        return result;\n    }\n\n    /**\n     * Uncompress the input as a short array\n     *\n     * @param input\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static short[] uncompressShortArray(byte[] input)\n            throws IOException\n    {\n        return uncompressShortArray(input, 0, input.length);\n    }\n\n    /**\n     * Uncompress the input[offset, offset+length) as a short array\n     *\n     * @param input\n     * @param offset\n     * @param length\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static short[] uncompressShortArray(byte[] input, int offset, int length)\n            throws IOException\n    {\n        int uncompressedLength = Snappy.uncompressedLength(input, offset, length);\n        short[] result = new short[uncompressedLength / 2];\n        impl.rawUncompress(input, offset, length, result, 0);\n        return result;\n    }\n\n    /**\n     * Uncompress the input as a String\n     *\n     * @param input\n     * @return the uncompressed dasta\n     * @throws IOException\n     */\n    public static String uncompressString(byte[] input)\n            throws IOException\n    {\n        try {\n            return uncompressString(input, \"UTF-8\");\n        }\n        catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"UTF-8 decoder is not found\");\n        }\n    }\n\n    /**\n     * Uncompress the input[offset, offset+length) as a String\n     *\n     * @param input\n     * @param offset\n     * @param length\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static String uncompressString(byte[] input, int offset, int length)\n            throws IOException\n    {\n        try {\n            return uncompressString(input, offset, length, \"UTF-8\");\n        }\n        catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"UTF-8 decoder is not found\");\n        }\n    }\n\n    /**\n     * Uncompress the input[offset, offset+length) as a String of the given\n     * encoding\n     *\n     * @param input\n     * @param offset\n     * @param length\n     * @param encoding\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static String uncompressString(byte[] input, int offset, int length, String encoding)\n            throws IOException,\n            UnsupportedEncodingException\n    {\n        byte[] uncompressed = new byte[uncompressedLength(input, offset, length)];\n        uncompress(input, offset, length, uncompressed, 0);\n        return new String(uncompressed, encoding);\n    }\n\n    /**\n     * Uncompress the input[offset, offset+length) as a String of the given\n     * encoding\n     *\n     * @param input\n     * @param offset\n     * @param length\n     * @param encoding\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static String uncompressString(byte[] input, int offset, int length, Charset encoding)\n            throws IOException,\n            UnsupportedEncodingException\n    {\n        byte[] uncompressed = new byte[uncompressedLength(input, offset, length)];\n        uncompress(input, offset, length, uncompressed, 0);\n        return new String(uncompressed, encoding);\n    }\n\n    /**\n     * Uncompress the input as a String of the given encoding\n     *\n     * @param input\n     * @param encoding\n     * @return the uncompressed data\n     * @throws IOException\n     * @throws UnsupportedEncodingException\n     */\n    public static String uncompressString(byte[] input, String encoding)\n            throws IOException,\n            UnsupportedEncodingException\n    {\n        byte[] uncompressed = uncompress(input);\n        return new String(uncompressed, encoding);\n    }\n\n    /**\n     * Uncompress the input as a String of the given encoding\n     *\n     * @param input\n     * @param encoding\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static String uncompressString(byte[] input, Charset encoding)\n            throws IOException,\n            UnsupportedEncodingException\n    {\n        byte[] uncompressed = uncompress(input);\n        return new String(uncompressed, encoding);\n    }\n}\n", "/*--------------------------------------------------------------------------\n *  Copyright 2011 Taro L. Saito\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *--------------------------------------------------------------------------*/\n//--------------------------------------\n// snappy-java Project\n//\n// SnappyTest.java\n// Since: 2011/03/30\n//\n// $URL$ \n// $Author$\n//--------------------------------------\npackage org.xerial.snappy;\n\nimport static org.junit.Assert.*;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\n\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.xerial.util.log.Logger;\n\npublic class SnappyTest\n{\n    private static Logger _logger = Logger.getLogger(SnappyTest.class);\n\n    @Test\n    public void getVersion()\n            throws Exception\n    {\n        String version = Snappy.getNativeLibraryVersion();\n        _logger.debug(\"version: \" + version);\n    }\n\n    @Test\n    public void directBufferCheck()\n            throws Exception\n    {\n\n        try {\n            ByteBuffer src = ByteBuffer.allocate(1024);\n            src.put(\"hello world\".getBytes());\n            src.flip();\n            ByteBuffer dest = ByteBuffer.allocate(1024);\n            int maxCompressedLen = Snappy.compress(src, dest);\n        }\n        catch (SnappyError e) {\n            Assert.assertTrue(e.errorCode == SnappyErrorCode.NOT_A_DIRECT_BUFFER);\n            return;\n        }\n\n        fail(\"shouldn't reach here\");\n    }\n\n    @Test\n    public void directBuffer()\n            throws Exception\n    {\n\n        StringBuilder s = new StringBuilder();\n        for (int i = 0; i < 20; ++i) {\n            s.append(\"Hello world!\");\n        }\n        String origStr = s.toString();\n        byte[] orig = origStr.getBytes();\n        int BUFFER_SIZE = orig.length;\n        ByteBuffer src = ByteBuffer.allocateDirect(orig.length);\n        src.put(orig);\n        src.flip();\n        _logger.debug(\"input size: \" + src.remaining());\n        int maxCompressedLen = Snappy.maxCompressedLength(src.remaining());\n        _logger.debug(\"max compressed length:\" + maxCompressedLen);\n\n        ByteBuffer compressed = ByteBuffer.allocateDirect(maxCompressedLen);\n        int compressedSize = Snappy.compress(src, compressed);\n        _logger.debug(\"compressed length: \" + compressedSize);\n\n        assertTrue(Snappy.isValidCompressedBuffer(compressed));\n\n        assertEquals(0, src.position());\n        assertEquals(orig.length, src.remaining());\n        assertEquals(orig.length, src.limit());\n\n        assertEquals(0, compressed.position());\n        assertEquals(compressedSize, compressed.limit());\n        assertEquals(compressedSize, compressed.remaining());\n\n        int uncompressedLen = Snappy.uncompressedLength(compressed);\n        _logger.debug(\"uncompressed length: \" + uncompressedLen);\n        ByteBuffer extract = ByteBuffer.allocateDirect(uncompressedLen);\n        int uncompressedLen2 = Snappy.uncompress(compressed, extract);\n        assertEquals(uncompressedLen, uncompressedLen2);\n        assertEquals(uncompressedLen, extract.remaining());\n\n        byte[] b = new byte[uncompressedLen];\n        extract.get(b);\n        String decompressed = new String(b);\n        _logger.debug(decompressed);\n\n        assertEquals(origStr, decompressed);\n    }\n\n    @Test\n    public void bufferOffset()\n            throws Exception\n    {\n\n        String m = \"ACCAGGGGGGGGGGGGGGGGGGGGATAGATATTTCCCGAGATATTTTATATAAAAAAA\";\n        byte[] orig = m.getBytes();\n        final int offset = 100;\n        ByteBuffer input = ByteBuffer.allocateDirect(orig.length + offset);\n        input.position(offset);\n        input.put(orig);\n        input.flip();\n        input.position(offset);\n\n        // compress\n        int maxCompressedLength = Snappy.maxCompressedLength(input.remaining());\n        final int offset2 = 40;\n        ByteBuffer compressed = ByteBuffer.allocateDirect(maxCompressedLength + offset2);\n        compressed.position(offset2);\n        Snappy.compress(input, compressed);\n        assertTrue(Snappy.isValidCompressedBuffer(compressed));\n\n        // uncompress\n        final int offset3 = 80;\n        int uncompressedLength = Snappy.uncompressedLength(compressed);\n        ByteBuffer uncompressed = ByteBuffer.allocateDirect(uncompressedLength + offset3);\n        uncompressed.position(offset3);\n        Snappy.uncompress(compressed, uncompressed);\n        assertEquals(offset3, uncompressed.position());\n        assertEquals(offset3 + uncompressedLength, uncompressed.limit());\n        assertEquals(uncompressedLength, uncompressed.remaining());\n\n        // extract string\n        byte[] recovered = new byte[uncompressedLength];\n        uncompressed.get(recovered);\n        String m2 = new String(recovered);\n\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void byteArrayCompress()\n            throws Exception\n    {\n\n        String m = \"ACCAGGGGGGGGGGGGGGGGGGGGATAGATATTTCCCGAGATATTTTATATAAAAAAA\";\n        byte[] input = m.getBytes();\n        byte[] output = new byte[Snappy.maxCompressedLength(input.length)];\n        int compressedSize = Snappy.compress(input, 0, input.length, output, 0);\n        byte[] uncompressed = new byte[input.length];\n\n        assertTrue(Snappy.isValidCompressedBuffer(output, 0, compressedSize));\n        int uncompressedSize = Snappy.uncompress(output, 0, compressedSize, uncompressed, 0);\n        String m2 = new String(uncompressed);\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void rangeCheck()\n            throws Exception\n    {\n        String m = \"ACCAGGGGGGGGGGGGGGGGGGGGATAGATATTTCCCGAGATATTTTATATAAAAAAA\";\n        byte[] input = m.getBytes();\n        byte[] output = new byte[Snappy.maxCompressedLength(input.length)];\n        int compressedSize = Snappy.compress(input, 0, input.length, output, 0);\n\n        assertTrue(Snappy.isValidCompressedBuffer(output, 0, compressedSize));\n        // Intentionally set an invalid range\n        assertFalse(Snappy.isValidCompressedBuffer(output, 0, compressedSize + 1));\n        assertFalse(Snappy.isValidCompressedBuffer(output, 1, compressedSize));\n\n        // Test the ByteBuffer API\n        ByteBuffer bin = ByteBuffer.allocateDirect(input.length);\n        bin.put(input);\n        bin.flip();\n        ByteBuffer bout = ByteBuffer.allocateDirect(Snappy.maxCompressedLength(bin.remaining()));\n        int compressedSize2 = Snappy.compress(bin, bout);\n        assertEquals(compressedSize, compressedSize2);\n\n        assertTrue(Snappy.isValidCompressedBuffer(bout));\n        // Intentionally set an invalid range\n        bout.limit(bout.limit() + 1);\n        assertFalse(Snappy.isValidCompressedBuffer(bout));\n        bout.limit(bout.limit() - 1);\n        bout.position(1);\n        assertFalse(Snappy.isValidCompressedBuffer(bout));\n    }\n\n    @Test\n    public void highLevelAPI()\n            throws Exception\n    {\n\n        String m = \"Hello! 01234 ACGDSFSDFJ World. FDSDF02394234 fdsfda03924\";\n        byte[] input = m.getBytes();\n        byte[] output = Snappy.compress(input);\n\n        byte[] uncompressed = Snappy.uncompress(output);\n        String m2 = new String(uncompressed);\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void lowLevelAPI()\n            throws Exception\n    {\n\n        String m = \"Hello! 01234 ACGDSFSDFJ World. FDSDF02394234 fdsfda03924\";\n        byte[] input = m.getBytes();\n        byte[] output = Snappy.rawCompress(input, input.length);\n\n        byte[] uncompressed = Snappy.uncompress(output);\n        String m2 = new String(uncompressed);\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void simpleUsage()\n            throws Exception\n    {\n\n        String input = \"Hello snappy-java! Snappy-java is a JNI-based wrapper\"\n                + \" for using Snappy from Google (written in C++), a fast compresser/decompresser.\";\n        byte[] compressed = Snappy.compress(input.getBytes(\"UTF-8\"));\n        byte[] uncompressed = Snappy.uncompress(compressed);\n        String result = new String(uncompressed, \"UTF-8\");\n        _logger.debug(result);\n    }\n\n    @Test\n    public void floatArray()\n            throws Exception\n    {\n        float[] data = new float[] {1.0f, -0.3f, 1.3f, 234.4f, 34};\n        byte[] compressed = Snappy.compress(data);\n        float[] result = Snappy.uncompressFloatArray(compressed);\n        assertArrayEquals(data, result, 0.0f);\n    }\n\n    @Test\n    public void doubleArray()\n            throws Exception\n    {\n        double[] data = new double[] {1.0, -0.3, 1.3, 234.4, 34};\n        byte[] compressed = Snappy.compress(data);\n        double[] result = Snappy.uncompressDoubleArray(compressed);\n        assertArrayEquals(data, result, 0.0f);\n    }\n\n    @Test\n    public void longArray()\n            throws Exception\n    {\n        long[] data = new long[] {2, 3, 15, 4234, 43251531412342342L, 23423422342L};\n        byte[] compressed = Snappy.compress(data);\n        long[] result = Snappy.uncompressLongArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void shortArray()\n            throws Exception\n    {\n        short[] data = new short[] {432, -32267, 1, 3, 34, 43, 34, Short.MAX_VALUE, -1};\n        byte[] compressed = Snappy.compress(data);\n        short[] result = Snappy.uncompressShortArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void intArray()\n            throws Exception\n    {\n        int[] data = new int[] {432, -32267, 1, 3, 34, 43, 34, Short.MAX_VALUE, -1, Integer.MAX_VALUE, 3424, 43};\n        byte[] compressed = Snappy.compress(data);\n        int[] result = Snappy.uncompressIntArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void charArray()\n            throws Exception\n    {\n        char[] data = new char[] {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '!'};\n        byte[] compressed = Snappy.compress(data);\n        char[] result = Snappy.uncompressCharArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void string()\n            throws Exception\n    {\n        String s = \"Hello Snappy! Snappy! Snappy!\";\n        byte[] compressed = Snappy.compress(s);\n        String uncompressedString = Snappy.uncompressString(compressed);\n        assertEquals(s, uncompressedString);\n    }\n\n    @Test\n    public void isValidCompressedData()\n            throws Exception\n    {\n\n        byte[] b = new byte[] {(byte) 91, (byte) 34, (byte) 80, (byte) 73, (byte) 34, (byte) 93};\n\n        assertFalse(Snappy.isValidCompressedBuffer(b));\n\n        try {\n            byte[] uncompressed = Snappy.uncompress(b);\n            fail(\"cannot reach here since the input is invalid data\");\n        }\n        catch (IOException e) {\n            _logger.debug(e);\n        }\n    }\n\n    /*\n\n    Tests happy cases for SnappyInputStream.read method\n    - {0}\n     */\n    @Test\n    public void isValidChunkLengthForSnappyInputStreamIn()\n            throws Exception {\n        byte[] data = {0};\n        SnappyInputStream in = new SnappyInputStream(new ByteArrayInputStream(data));\n        byte[] out = new byte[50];\n        in.read(out);\n    }\n\n    /*\n    Tests sad cases for SnappyInputStream.read method\n    - Expects a java.lang.NegativeArraySizeException catched into a SnappyError\n    - {-126, 'S', 'N', 'A', 'P', 'P', 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0,(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff}\n     */\n    @Test(expected = SnappyError.class)\n    public void isInvalidChunkLengthForSnappyInputStreamInNegative()\n            throws Exception {\n        byte[] data = {-126, 'S', 'N', 'A', 'P', 'P', 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0,(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff};\n        SnappyInputStream in = new SnappyInputStream(new ByteArrayInputStream(data));\n        byte[] out = new byte[50];\n        in.read(out);\n    }\n\n    /*\n    Tests sad cases for SnappyInputStream.read method\n    - Expects a java.lang.OutOfMemoryError\n    - {-126, 'S', 'N', 'A', 'P', 'P', 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0,(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff}\n     */\n    @Test(expected = SnappyError.class)\n    public void isInvalidChunkLengthForSnappyInputStreamOutOfMemory()\n            throws Exception {\n        byte[] data = {-126, 'S', 'N', 'A', 'P', 'P', 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0, (byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff};\n        SnappyInputStream in = new SnappyInputStream(new ByteArrayInputStream(data));\n        byte[] out = new byte[50];\n        try {\n            in.read(out);\n        } catch (Exception ignored) {\n            // Exception here will be catched\n            // But OutOfMemoryError will not be caught, and will still be thrown\n        }\n    }\n\n    /*\n    Tests happy cases for BitShuffle.shuffle method\n    - double: 0, 10\n    - float: 0, 10\n    - int: 0, 10\n    - long: 0, 10\n    - short: 0, 10\n    */\n    @Test\n    public void isValidArrayInputLengthForBitShuffleShuffle()\n            throws Exception\n    {\n        byte[] b = BitShuffle.shuffle(new double[0]);\n        byte[] c = BitShuffle.shuffle(new float[0]);\n        byte[] d = BitShuffle.shuffle(new int[0]);\n        byte[] e = BitShuffle.shuffle(new long[0]);\n        byte[] f = BitShuffle.shuffle(new short[0]);\n        byte[] n = BitShuffle.shuffle(new double[10]);\n        byte[] o = BitShuffle.shuffle(new float[10]);\n        byte[] p = BitShuffle.shuffle(new int[10]);\n        byte[] q = BitShuffle.shuffle(new long[10]);\n        byte[] r = BitShuffle.shuffle(new short[10]);\n    }\n\n    /*\n    Tests sad cases for BitShuffle.shuffle method\n    - Allocate a buffer whose byte size will be a bit larger than Integer.MAX_VALUE\n    - double: 8\n    - float: 4\n    - int: 4\n    - long: 8\n    - short: 2\n     */\n    @Test(expected = SnappyError.class)\n    public void isTooLargeDoubleArrayInputLengthForBitShuffleShuffle() throws Exception {\n        BitShuffle.shuffle(new double[Integer.MAX_VALUE / 8 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeFloatArrayInputLengthForBitShuffleShuffle() throws Exception {\n        BitShuffle.shuffle(new float[Integer.MAX_VALUE / 4 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeIntArrayInputLengthForBitShuffleShuffle() throws Exception {\n        BitShuffle.shuffle(new float[Integer.MAX_VALUE / 4 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeLongArrayInputLengthForBitShuffleShuffle() throws Exception {\n        BitShuffle.shuffle(new long[Integer.MAX_VALUE / 8 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeShortArrayInputLengthForBitShuffleShuffle() throws Exception {\n        BitShuffle.shuffle(new short[Integer.MAX_VALUE / 2 + 1]);\n\n    }\n}\n"], "fixing_code": ["/*--------------------------------------------------------------------------\n *  Copyright 2011 Taro L. Saito\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *--------------------------------------------------------------------------*/\n//--------------------------------------\n// snappy-java Project\n//\n// Snappy.java\n// Since: 2011/03/29\n//\n// $URL$\n// $Author$\n//--------------------------------------\npackage org.xerial.snappy;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URL;\nimport java.nio.Buffer;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.util.Properties;\n\n/**\n * Snappy API for data compression/decompression\n * <p/>\n * Note: if the native libraries cannot be loaded, an ExceptionInInitializerError\n * will be thrown at first use of this class.\n *\n * @author Taro L. Saito\n */\npublic class Snappy\n{\n    static {\n        init();\n    }\n\n    /**\n     * An instance of SnappyNative\n     */\n    private static SnappyApi impl;\n\n    /**\n     * Clean up a temporary file (native lib) generated by snappy-java.\n     * General users do not need to call this method, since the native library extracted in snappy-java\n     * is deleted upon JVM termination (vie deleteOnExit()).\n     * This method is useful when using a J2EE container, which will restart servlet containers multiple times without\n     * restarting JVM.\n     */\n    public static void cleanUp()\n    {\n        SnappyLoader.cleanUpExtractedNativeLib();\n        SnappyLoader.setSnappyApi(null);\n    }\n\n    static void init() {\n        try {\n            impl = SnappyLoader.loadSnappyApi();\n        }\n        catch (Exception e) {\n            throw new ExceptionInInitializerError(e);\n        }\n    }\n\n    /**\n     * Copy bytes from source to destination\n     *\n     * @param src pointer to the source array\n     * @param offset byte offset in the source array\n     * @param byteLength the number of bytes to copy\n     * @param dest pointer to the destination array\n     * @param dest_offset byte offset in the destination array\n     * @throws IOException\n     */\n    public static void arrayCopy(Object src, int offset, int byteLength, Object dest, int dest_offset)\n            throws IOException\n    {\n        impl.arrayCopy(src, offset, byteLength, dest, dest_offset);\n    }\n\n    /**\n     * High-level API for compressing the input byte array. This method performs\n     * array copy to generate the result. If you want to reduce the memory copy\n     * cost, use {@link #compress(byte[], int, int, byte[], int)} or\n     * {@link #compress(ByteBuffer, ByteBuffer)}.\n     *\n     * @param input the input data\n     * @return the compressed byte array\n     * @throws IOException\n     */\n    public static byte[] compress(byte[] input)\n            throws IOException\n    {\n        return rawCompress(input, input.length);\n    }\n\n    /**\n     * Compress the input buffer content in [inputOffset,\n     * ...inputOffset+inputLength) then output to the specified output buffer.\n     *\n     * @param input\n     * @param inputOffset\n     * @param inputLength\n     * @param output\n     * @param outputOffset\n     * @return byte size of the compressed data\n     * @throws IOException when failed to access the input/output buffer\n     */\n    public static int compress(byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset)\n            throws IOException\n    {\n        return rawCompress(input, inputOffset, inputLength, output, outputOffset);\n    }\n\n    /**\n     * Compress the content in the given input buffer. After the compression,\n     * you can retrieve the compressed data from the output buffer [pos() ...\n     * limit()) (compressed data size = limit() - pos() = remaining())\n     *\n     * @param uncompressed buffer[pos() ... limit()) containing the input data\n     * @param compressed output of the compressed data. Uses range [pos()..].\n     * @return byte size of the compressed data.\n     * @throws SnappyError when the input is not a direct buffer\n     */\n    public static int compress(ByteBuffer uncompressed, ByteBuffer compressed)\n            throws IOException\n    {\n\n        if (!uncompressed.isDirect()) {\n            throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, \"input is not a direct buffer\");\n        }\n        if (!compressed.isDirect()) {\n            throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, \"destination is not a direct buffer\");\n        }\n\n        // input: uncompressed[pos(), limit())\n        // output: compressed\n        int uPos = uncompressed.position();\n        int uLen = uncompressed.remaining();\n        int cPos = compressed.position();\n        int compressedSize = impl.rawCompress(uncompressed, uPos, uLen, compressed,\n                cPos);\n\n        //         pos  limit\n        // [ ......BBBBBBB.........]\n        ((Buffer) compressed).limit(cPos + compressedSize);\n\n        return compressedSize;\n    }\n\n    /**\n     * Compress the input char array\n     *\n     * @param input\n     * @return the compressed data\n     */\n    public static byte[] compress(char[] input)\n            throws IOException\n    {\n        int byteSize = input.length * 2;\n        if (byteSize < input.length) {\n            throw new SnappyError(SnappyErrorCode.TOO_LARGE_INPUT, \"input array size is too large: \" + input.length);\n        }\n        return rawCompress(input, byteSize); // char uses 2 bytes\n    }\n\n    /**\n     * Compress the input double array\n     *\n     * @param input\n     * @return the compressed data\n     */\n    public static byte[] compress(double[] input)\n            throws IOException\n    {\n        int byteSize = input.length * 8;\n        if (byteSize < input.length) {\n            throw new SnappyError(SnappyErrorCode.TOO_LARGE_INPUT, \"input array size is too large: \" + input.length);\n        }\n        return rawCompress(input, byteSize); // double uses 8 bytes\n    }\n\n    /**\n     * Compress the input float array\n     *\n     * @param input\n     * @return the compressed data\n     */\n    public static byte[] compress(float[] input)\n            throws IOException\n    {\n        int byteSize = input.length * 4;\n        if (byteSize < input.length) {\n            throw new SnappyError(SnappyErrorCode.TOO_LARGE_INPUT, \"input array size is too large: \" + input.length);\n        }\n        return rawCompress(input, byteSize); // float uses 4 bytes\n    }\n\n    /**\n     * Compress the input int array\n     *\n     * @param input\n     * @return the compressed data\n     */\n    public static byte[] compress(int[] input)\n            throws IOException\n    {\n        int byteSize = input.length * 4;\n        if (byteSize < input.length) {\n            throw new SnappyError(SnappyErrorCode.TOO_LARGE_INPUT, \"input array size is too large: \" + input.length);\n        }\n        return rawCompress(input, byteSize); // int uses 4 bytes\n    }\n\n    /**\n     * Compress the input long array\n     *\n     * @param input\n     * @return the compressed data\n     */\n    public static byte[] compress(long[] input)\n            throws IOException\n    {\n        int byteSize = input.length * 8;\n        if (byteSize < input.length) {\n            throw new SnappyError(SnappyErrorCode.TOO_LARGE_INPUT, \"input array size is too large: \" + input.length);\n        }\n        return rawCompress(input, byteSize); // long uses 8 bytes\n    }\n\n    /**\n     * Compress the input short array\n     *\n     * @param input\n     * @return the compressed data\n     */\n    public static byte[] compress(short[] input)\n            throws IOException\n    {\n        int byteSize = input.length * 2;\n        if (byteSize < input.length) {\n            throw new SnappyError(SnappyErrorCode.TOO_LARGE_INPUT, \"input array size is too large: \" + input.length);\n        }\n        return rawCompress(input, byteSize); // short uses 2 bytes\n    }\n\n    /**\n     * Compress the input String\n     *\n     * @param s\n     * @return the compressed data\n     * @throws IOException\n     */\n    public static byte[] compress(String s)\n            throws IOException\n    {\n        try {\n            return compress(s, \"UTF-8\");\n        }\n        catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"UTF-8 encoder is not found\");\n        }\n    }\n\n    /**\n     * Compress the input string using the given encoding\n     *\n     * @param s\n     * @param encoding\n     * @return the compressed data\n     * @throws UnsupportedEncodingException\n     * @throws IOException\n     */\n    public static byte[] compress(String s, String encoding)\n            throws UnsupportedEncodingException, IOException\n    {\n        byte[] data = s.getBytes(encoding);\n        return compress(data);\n    }\n\n    /**\n     * Compress the input string using the given encoding\n     *\n     * @param s\n     * @param encoding\n     * @return the compressed data\n     * @throws UnsupportedEncodingException\n     * @throws IOException\n     */\n    public static byte[] compress(String s, Charset encoding)\n            throws IOException\n    {\n        byte[] data = s.getBytes(encoding);\n        return compress(data);\n    }\n\n    /**\n     * Get the native library version of the snappy\n     *\n     * @return native library version\n     */\n    public static String getNativeLibraryVersion()\n    {\n        URL versionFile = SnappyLoader.class.getResource(\"/org/xerial/snappy/VERSION\");\n\n        String version = \"unknown\";\n        try {\n            if (versionFile != null) {\n                InputStream in = null;\n                try {\n                    Properties versionData = new Properties();\n                    in = versionFile.openStream();\n                    versionData.load(in);\n                    version = versionData.getProperty(\"version\", version);\n                    if (version.equals(\"unknown\")) {\n                        version = versionData.getProperty(\"SNAPPY_VERSION\", version);\n                    }\n                    version = version.trim().replaceAll(\"[^0-9\\\\.]\", \"\");\n                }\n                finally {\n                    if(in != null) {\n                        in.close();\n                    }\n                }\n            }\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n        return version;\n    }\n\n    /**\n     * Returns true iff the contents of compressed buffer [offset,\n     * offset+length) can be uncompressed successfully. Does not return the\n     * uncompressed data. Takes time proportional to the input length, but is\n     * usually at least a factor of four faster than actual decompression.\n     */\n    public static boolean isValidCompressedBuffer(byte[] input, int offset, int length)\n            throws IOException\n    {\n        if (input == null) {\n            throw new NullPointerException(\"input is null\");\n        }\n        return impl.isValidCompressedBuffer(input, offset, length);\n    }\n\n    /**\n     * Returns true iff the contents of compressed buffer [offset,\n     * offset+length) can be uncompressed successfully. Does not return the\n     * uncompressed data. Takes time proportional to the input length, but is\n     * usually at least a factor of four faster than actual decompression.\n     */\n    public static boolean isValidCompressedBuffer(byte[] input)\n            throws IOException\n    {\n        return isValidCompressedBuffer(input, 0, input.length);\n    }\n\n    /**\n     * Returns true iff the contents of compressed buffer [pos() ... limit())\n     * can be uncompressed successfully. Does not return the uncompressed data.\n     * Takes time proportional to the input length, but is usually at least a\n     * factor of four faster than actual decompression.\n     */\n    public static boolean isValidCompressedBuffer(ByteBuffer compressed)\n            throws IOException\n    {\n        return impl.isValidCompressedBuffer(compressed, compressed.position(),\n                compressed.remaining());\n    }\n\n    /**\n     * Returns true iff the contents of compressed buffer [offset,\n     * offset+length) can be uncompressed successfully. Does not return the\n     * uncompressed data. Takes time proportional to the input length, but is\n     * usually at least a factor of four faster than actual decompression.\n     */\n    public static boolean isValidCompressedBuffer(long inputAddr, long offset, long length)\n            throws IOException\n    {\n        return impl.isValidCompressedBuffer(inputAddr, offset, length);\n    }\n\n    /**\n     * Get the maximum byte size needed for compressing data of the given byte\n     * size.\n     *\n     * @param byteSize byte size of the data to compress\n     * @return maximum byte size of the compressed data\n     */\n    public static int maxCompressedLength(int byteSize)\n    {\n        return impl.maxCompressedLength(byteSize);\n    }\n\n    /**\n     * Zero-copy compress using memory addresses.\n     *\n     * @param inputAddr input memory address\n     * @param inputSize input byte size\n     * @param destAddr destination address of the compressed data\n     * @return the compressed data size\n     * @throws IOException\n     */\n    public static long rawCompress(long inputAddr, long inputSize, long destAddr)\n            throws IOException\n    {\n        return impl.rawCompress(inputAddr, inputSize, destAddr);\n    }\n\n    /**\n     * Zero-copy decompress using memory addresses.\n     *\n     * @param inputAddr input memory address\n     * @param inputSize input byte size\n     * @param destAddr destination address of the uncompressed data\n     * @return the uncompressed data size\n     * @throws IOException\n     */\n    public static long rawUncompress(long inputAddr, long inputSize, long destAddr)\n            throws IOException\n    {\n        return impl.rawUncompress(inputAddr, inputSize, destAddr);\n    }\n\n    /**\n     * Compress the input data and produce a byte array of the uncompressed data\n     *\n     * @param data input array. The input MUST be an array type\n     * @param byteSize the input byte size\n     * @return compressed data\n     */\n    public static byte[] rawCompress(Object data, int byteSize)\n            throws IOException\n    {\n        byte[] buf = new byte[Snappy.maxCompressedLength(byteSize)];\n        int compressedByteSize = impl.rawCompress(data, 0, byteSize, buf, 0);\n        byte[] result = new byte[compressedByteSize];\n        System.arraycopy(buf, 0, result, 0, compressedByteSize);\n        return result;\n    }\n\n    /**\n     * Compress the input buffer [offset,... ,offset+length) contents, then\n     * write the compressed data to the output buffer[offset, ...)\n     *\n     * @param input input array. This MUST be a primitive array type\n     * @param inputOffset byte offset at the output array\n     * @param inputLength byte length of the input data\n     * @param output output array. This MUST be a primitive array type\n     * @param outputOffset byte offset at the output array\n     * @return byte size of the compressed data\n     * @throws IOException\n     */\n    public static int rawCompress(Object input, int inputOffset, int inputLength, byte[] output, int outputOffset)\n            throws IOException\n    {\n        if (input == null || output == null) {\n            throw new NullPointerException(\"input or output is null\");\n        }\n\n        int compressedSize = impl\n                .rawCompress(input, inputOffset, inputLength, output, outputOffset);\n        return compressedSize;\n    }\n\n    /**\n     * Uncompress the content in the input buffer. The uncompressed data is\n     * written to the output buffer.\n     * <p/>\n     * Note that if you pass the wrong data or the range [inputOffset,\n     * inputOffset + inputLength) that cannot be uncompressed, your JVM might\n     * crash due to the access violation exception issued in the native code\n     * written in C++. To avoid this type of crash, use\n     * {@link #isValidCompressedBuffer(byte[], int, int)} first.\n     *\n     * @param input input byte array\n     * @param inputOffset byte offset in the input byte array\n     * @param inputLength byte length of the input data\n     * @param output output buffer, MUST be a primitive type array\n     * @param outputOffset byte offset in the output buffer\n     * @return the byte size of the uncompressed data\n     * @throws IOException when failed to uncompress the input data\n     */\n    public static int rawUncompress(byte[] input, int inputOffset, int inputLength, Object output, int outputOffset)\n            throws IOException\n    {\n        if (input == null || output == null) {\n            throw new NullPointerException(\"input or output is null\");\n        }\n        return impl.rawUncompress(input, inputOffset, inputLength, output, outputOffset);\n    }\n\n    /**\n     * High-level API for uncompressing the input byte array.\n     *\n     * @param input\n     * @return the uncompressed byte array\n     * @throws IOException\n     */\n    public static byte[] uncompress(byte[] input)\n            throws IOException\n    {\n        byte[] result = new byte[Snappy.uncompressedLength(input)];\n        Snappy.uncompress(input, 0, input.length, result, 0);\n        return result;\n    }\n\n    /**\n     * Uncompress the content in the input buffer. The uncompressed data is\n     * written to the output buffer.\n     * <p/>\n     * Note that if you pass the wrong data or the range [inputOffset,\n     * inputOffset + inputLength) that cannot be uncompressed, your JVM might\n     * crash due to the access violation exception issued in the native code\n     * written in C++. To avoid this type of crash, use\n     * {@link #isValidCompressedBuffer(byte[], int, int)} first.\n     *\n     * @param input\n     * @param inputOffset\n     * @param inputLength\n     * @param output\n     * @param outputOffset\n     * @return the byte size of the uncompressed data\n     * @throws IOException\n     */\n    public static int uncompress(byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset)\n            throws IOException\n    {\n        return rawUncompress(input, inputOffset, inputLength, output, outputOffset);\n    }\n\n    /**\n     * Uncompress the content in the input buffer. The result is dumped to the\n     * specified output buffer.\n     * <p/>\n     * Note that if you pass the wrong data or the range [pos(), limit()) that\n     * cannot be uncompressed, your JVM might crash due to the access violation\n     * exception issued in the native code written in C++. To avoid this type of\n     * crash, use {@link #isValidCompressedBuffer(ByteBuffer)} first.\n     *\n     * @param compressed buffer[pos() ... limit()) containing the input data\n     * @param uncompressed output of the the uncompressed data. It uses buffer[pos()..]\n     * @return uncompressed data size\n     * @throws IOException when failed to uncompress the given input\n     * @throws SnappyError when the input is not a direct buffer\n     */\n    public static int uncompress(ByteBuffer compressed, ByteBuffer uncompressed)\n            throws IOException\n    {\n\n        if (!compressed.isDirect()) {\n            throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, \"input is not a direct buffer\");\n        }\n        if (!uncompressed.isDirect()) {\n            throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, \"destination is not a direct buffer\");\n        }\n\n        int cPos = compressed.position();\n        int cLen = compressed.remaining();\n        int uPos = uncompressed.position();\n\n        //         pos  limit\n        // [ ......UUUUUU.........]\n        int decompressedSize = impl.rawUncompress(compressed, cPos, cLen, uncompressed,\n                uPos);\n        uncompressed.limit(uPos + decompressedSize);\n\n        return decompressedSize;\n    }\n\n    /**\n     * Uncompress the input data as char array\n     *\n     * @param input\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static char[] uncompressCharArray(byte[] input)\n            throws IOException\n    {\n        return uncompressCharArray(input, 0, input.length);\n    }\n\n    /**\n     * Uncompress the input[offset, .., offset+length) as a char array\n     *\n     * @param input\n     * @param offset\n     * @param length\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static char[] uncompressCharArray(byte[] input, int offset, int length)\n            throws IOException\n    {\n        int uncompressedLength = Snappy.uncompressedLength(input, offset, length);\n        char[] result = new char[uncompressedLength / 2];\n        impl.rawUncompress(input, offset, length, result, 0);\n        return result;\n    }\n\n    /**\n     * Uncompress the input as a double array\n     *\n     * @param input\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static double[] uncompressDoubleArray(byte[] input)\n            throws IOException\n    {\n        return uncompressDoubleArray(input, 0, input.length);\n    }\n\n    /**\n     * Uncompress the input as a double array\n     *\n     * @param input\n     * @param offset\n     * @param length\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static double[] uncompressDoubleArray(byte[] input, int offset, int length)\n            throws IOException\n    {\n        int uncompressedLength = Snappy.uncompressedLength(input, offset, length);\n        double[] result = new double[uncompressedLength / 8];\n        impl.rawUncompress(input, offset, length, result, 0);\n        return result;\n    }\n\n    /**\n     * Get the uncompressed byte size of the given compressed input. This\n     * operation takes O(1) time.\n     *\n     * @param input\n     * @return uncompressed byte size of the the given input data\n     * @throws IOException when failed to uncompress the given input. The error code is\n     * {@link SnappyErrorCode#PARSING_ERROR}\n     */\n    public static int uncompressedLength(byte[] input)\n            throws IOException\n    {\n        return impl.uncompressedLength(input, 0, input.length);\n    }\n\n    /**\n     * Get the uncompressed byte size of the given compressed input. This\n     * operation takes O(1) time.\n     *\n     * @param input\n     * @param offset\n     * @param length\n     * @return uncompressed byte size of the the given input data\n     * @throws IOException when failed to uncompress the given input. The error code is\n     * {@link SnappyErrorCode#PARSING_ERROR}\n     */\n    public static int uncompressedLength(byte[] input, int offset, int length)\n            throws IOException\n    {\n        if (input == null) {\n            throw new NullPointerException(\"input is null\");\n        }\n\n        return impl.uncompressedLength(input, offset, length);\n    }\n\n    /**\n     * Get the uncompressed byte size of the given compressed input. This\n     * operation takes O(1) time.\n     *\n     * @param compressed input data [pos() ... limit())\n     * @return uncompressed byte length of the given input\n     * @throws IOException when failed to uncompress the given input. The error code is\n     * {@link SnappyErrorCode#PARSING_ERROR}\n     * @throws SnappyError when the input is not a direct buffer\n     */\n    public static int uncompressedLength(ByteBuffer compressed)\n            throws IOException\n    {\n        if (!compressed.isDirect()) {\n            throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, \"input is not a direct buffer\");\n        }\n\n        return impl.uncompressedLength(compressed, compressed.position(), compressed.remaining());\n    }\n\n    /**\n     * Get the uncompressed byte size of the given compressed input. This operation takes O(1) time.\n     *\n     * @param inputAddr compressed data address\n     * @param len byte length of the input\n     * @return uncompressed byte length of the given input\n     * @throws IOException when failed to uncompress the given input. The error code is\n     * {@link SnappyErrorCode#PARSING_ERROR}\n     */\n    public static long uncompressedLength(long inputAddr, long len)\n            throws IOException\n    {\n        return impl.uncompressedLength(inputAddr, len);\n    }\n\n    /**\n     * Uncompress the input as a float array\n     *\n     * @param input\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static float[] uncompressFloatArray(byte[] input)\n            throws IOException\n    {\n        return uncompressFloatArray(input, 0, input.length);\n    }\n\n    /**\n     * Uncompress the input[offset, offset+length) as a float array\n     *\n     * @param input\n     * @param offset\n     * @param length\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static float[] uncompressFloatArray(byte[] input, int offset, int length)\n            throws IOException\n    {\n        int uncompressedLength = Snappy.uncompressedLength(input, offset, length);\n        float[] result = new float[uncompressedLength / 4];\n        impl.rawUncompress(input, offset, length, result, 0);\n        return result;\n    }\n\n    /**\n     * Uncompress the input data as an int array\n     *\n     * @param input\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static int[] uncompressIntArray(byte[] input)\n            throws IOException\n    {\n        return uncompressIntArray(input, 0, input.length);\n    }\n\n    /**\n     * Uncompress the input[offset, offset+length) as an int array\n     *\n     * @param input\n     * @param offset\n     * @param length\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static int[] uncompressIntArray(byte[] input, int offset, int length)\n            throws IOException\n    {\n        int uncompressedLength = Snappy.uncompressedLength(input, offset, length);\n        int[] result = new int[uncompressedLength / 4];\n        impl.rawUncompress(input, offset, length, result, 0);\n        return result;\n    }\n\n    /**\n     * Uncompress the input data as a long array\n     *\n     * @param input\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static long[] uncompressLongArray(byte[] input)\n            throws IOException\n    {\n        return uncompressLongArray(input, 0, input.length);\n    }\n\n    /**\n     * Uncompress the input[offset, offset+length) as a long array\n     *\n     * @param input\n     * @param offset\n     * @param length\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static long[] uncompressLongArray(byte[] input, int offset, int length)\n            throws IOException\n    {\n        int uncompressedLength = Snappy.uncompressedLength(input, offset, length);\n        long[] result = new long[uncompressedLength / 8];\n        impl.rawUncompress(input, offset, length, result, 0);\n        return result;\n    }\n\n    /**\n     * Uncompress the input as a short array\n     *\n     * @param input\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static short[] uncompressShortArray(byte[] input)\n            throws IOException\n    {\n        return uncompressShortArray(input, 0, input.length);\n    }\n\n    /**\n     * Uncompress the input[offset, offset+length) as a short array\n     *\n     * @param input\n     * @param offset\n     * @param length\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static short[] uncompressShortArray(byte[] input, int offset, int length)\n            throws IOException\n    {\n        int uncompressedLength = Snappy.uncompressedLength(input, offset, length);\n        short[] result = new short[uncompressedLength / 2];\n        impl.rawUncompress(input, offset, length, result, 0);\n        return result;\n    }\n\n    /**\n     * Uncompress the input as a String\n     *\n     * @param input\n     * @return the uncompressed dasta\n     * @throws IOException\n     */\n    public static String uncompressString(byte[] input)\n            throws IOException\n    {\n        try {\n            return uncompressString(input, \"UTF-8\");\n        }\n        catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"UTF-8 decoder is not found\");\n        }\n    }\n\n    /**\n     * Uncompress the input[offset, offset+length) as a String\n     *\n     * @param input\n     * @param offset\n     * @param length\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static String uncompressString(byte[] input, int offset, int length)\n            throws IOException\n    {\n        try {\n            return uncompressString(input, offset, length, \"UTF-8\");\n        }\n        catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"UTF-8 decoder is not found\");\n        }\n    }\n\n    /**\n     * Uncompress the input[offset, offset+length) as a String of the given\n     * encoding\n     *\n     * @param input\n     * @param offset\n     * @param length\n     * @param encoding\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static String uncompressString(byte[] input, int offset, int length, String encoding)\n            throws IOException,\n            UnsupportedEncodingException\n    {\n        byte[] uncompressed = new byte[uncompressedLength(input, offset, length)];\n        uncompress(input, offset, length, uncompressed, 0);\n        return new String(uncompressed, encoding);\n    }\n\n    /**\n     * Uncompress the input[offset, offset+length) as a String of the given\n     * encoding\n     *\n     * @param input\n     * @param offset\n     * @param length\n     * @param encoding\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static String uncompressString(byte[] input, int offset, int length, Charset encoding)\n            throws IOException,\n            UnsupportedEncodingException\n    {\n        byte[] uncompressed = new byte[uncompressedLength(input, offset, length)];\n        uncompress(input, offset, length, uncompressed, 0);\n        return new String(uncompressed, encoding);\n    }\n\n    /**\n     * Uncompress the input as a String of the given encoding\n     *\n     * @param input\n     * @param encoding\n     * @return the uncompressed data\n     * @throws IOException\n     * @throws UnsupportedEncodingException\n     */\n    public static String uncompressString(byte[] input, String encoding)\n            throws IOException,\n            UnsupportedEncodingException\n    {\n        byte[] uncompressed = uncompress(input);\n        return new String(uncompressed, encoding);\n    }\n\n    /**\n     * Uncompress the input as a String of the given encoding\n     *\n     * @param input\n     * @param encoding\n     * @return the uncompressed data\n     * @throws IOException\n     */\n    public static String uncompressString(byte[] input, Charset encoding)\n            throws IOException,\n            UnsupportedEncodingException\n    {\n        byte[] uncompressed = uncompress(input);\n        return new String(uncompressed, encoding);\n    }\n}\n", "/*--------------------------------------------------------------------------\n *  Copyright 2011 Taro L. Saito\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *--------------------------------------------------------------------------*/\n//--------------------------------------\n// snappy-java Project\n//\n// SnappyTest.java\n// Since: 2011/03/30\n//\n// $URL$\n// $Author$\n//--------------------------------------\npackage org.xerial.snappy;\n\nimport static org.junit.Assert.*;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\n\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.xerial.util.log.Logger;\n\npublic class SnappyTest\n{\n    private static Logger _logger = Logger.getLogger(SnappyTest.class);\n\n    @Test\n    public void getVersion()\n            throws Exception\n    {\n        String version = Snappy.getNativeLibraryVersion();\n        _logger.debug(\"version: \" + version);\n    }\n\n    @Test\n    public void directBufferCheck()\n            throws Exception\n    {\n\n        try {\n            ByteBuffer src = ByteBuffer.allocate(1024);\n            src.put(\"hello world\".getBytes());\n            src.flip();\n            ByteBuffer dest = ByteBuffer.allocate(1024);\n            int maxCompressedLen = Snappy.compress(src, dest);\n        }\n        catch (SnappyError e) {\n            Assert.assertTrue(e.errorCode == SnappyErrorCode.NOT_A_DIRECT_BUFFER);\n            return;\n        }\n\n        fail(\"shouldn't reach here\");\n    }\n\n    @Test\n    public void directBuffer()\n            throws Exception\n    {\n\n        StringBuilder s = new StringBuilder();\n        for (int i = 0; i < 20; ++i) {\n            s.append(\"Hello world!\");\n        }\n        String origStr = s.toString();\n        byte[] orig = origStr.getBytes();\n        int BUFFER_SIZE = orig.length;\n        ByteBuffer src = ByteBuffer.allocateDirect(orig.length);\n        src.put(orig);\n        src.flip();\n        _logger.debug(\"input size: \" + src.remaining());\n        int maxCompressedLen = Snappy.maxCompressedLength(src.remaining());\n        _logger.debug(\"max compressed length:\" + maxCompressedLen);\n\n        ByteBuffer compressed = ByteBuffer.allocateDirect(maxCompressedLen);\n        int compressedSize = Snappy.compress(src, compressed);\n        _logger.debug(\"compressed length: \" + compressedSize);\n\n        assertTrue(Snappy.isValidCompressedBuffer(compressed));\n\n        assertEquals(0, src.position());\n        assertEquals(orig.length, src.remaining());\n        assertEquals(orig.length, src.limit());\n\n        assertEquals(0, compressed.position());\n        assertEquals(compressedSize, compressed.limit());\n        assertEquals(compressedSize, compressed.remaining());\n\n        int uncompressedLen = Snappy.uncompressedLength(compressed);\n        _logger.debug(\"uncompressed length: \" + uncompressedLen);\n        ByteBuffer extract = ByteBuffer.allocateDirect(uncompressedLen);\n        int uncompressedLen2 = Snappy.uncompress(compressed, extract);\n        assertEquals(uncompressedLen, uncompressedLen2);\n        assertEquals(uncompressedLen, extract.remaining());\n\n        byte[] b = new byte[uncompressedLen];\n        extract.get(b);\n        String decompressed = new String(b);\n        _logger.debug(decompressed);\n\n        assertEquals(origStr, decompressed);\n    }\n\n    @Test\n    public void bufferOffset()\n            throws Exception\n    {\n\n        String m = \"ACCAGGGGGGGGGGGGGGGGGGGGATAGATATTTCCCGAGATATTTTATATAAAAAAA\";\n        byte[] orig = m.getBytes();\n        final int offset = 100;\n        ByteBuffer input = ByteBuffer.allocateDirect(orig.length + offset);\n        input.position(offset);\n        input.put(orig);\n        input.flip();\n        input.position(offset);\n\n        // compress\n        int maxCompressedLength = Snappy.maxCompressedLength(input.remaining());\n        final int offset2 = 40;\n        ByteBuffer compressed = ByteBuffer.allocateDirect(maxCompressedLength + offset2);\n        compressed.position(offset2);\n        Snappy.compress(input, compressed);\n        assertTrue(Snappy.isValidCompressedBuffer(compressed));\n\n        // uncompress\n        final int offset3 = 80;\n        int uncompressedLength = Snappy.uncompressedLength(compressed);\n        ByteBuffer uncompressed = ByteBuffer.allocateDirect(uncompressedLength + offset3);\n        uncompressed.position(offset3);\n        Snappy.uncompress(compressed, uncompressed);\n        assertEquals(offset3, uncompressed.position());\n        assertEquals(offset3 + uncompressedLength, uncompressed.limit());\n        assertEquals(uncompressedLength, uncompressed.remaining());\n\n        // extract string\n        byte[] recovered = new byte[uncompressedLength];\n        uncompressed.get(recovered);\n        String m2 = new String(recovered);\n\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void byteArrayCompress()\n            throws Exception\n    {\n\n        String m = \"ACCAGGGGGGGGGGGGGGGGGGGGATAGATATTTCCCGAGATATTTTATATAAAAAAA\";\n        byte[] input = m.getBytes();\n        byte[] output = new byte[Snappy.maxCompressedLength(input.length)];\n        int compressedSize = Snappy.compress(input, 0, input.length, output, 0);\n        byte[] uncompressed = new byte[input.length];\n\n        assertTrue(Snappy.isValidCompressedBuffer(output, 0, compressedSize));\n        int uncompressedSize = Snappy.uncompress(output, 0, compressedSize, uncompressed, 0);\n        String m2 = new String(uncompressed);\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void rangeCheck()\n            throws Exception\n    {\n        String m = \"ACCAGGGGGGGGGGGGGGGGGGGGATAGATATTTCCCGAGATATTTTATATAAAAAAA\";\n        byte[] input = m.getBytes();\n        byte[] output = new byte[Snappy.maxCompressedLength(input.length)];\n        int compressedSize = Snappy.compress(input, 0, input.length, output, 0);\n\n        assertTrue(Snappy.isValidCompressedBuffer(output, 0, compressedSize));\n        // Intentionally set an invalid range\n        assertFalse(Snappy.isValidCompressedBuffer(output, 0, compressedSize + 1));\n        assertFalse(Snappy.isValidCompressedBuffer(output, 1, compressedSize));\n\n        // Test the ByteBuffer API\n        ByteBuffer bin = ByteBuffer.allocateDirect(input.length);\n        bin.put(input);\n        bin.flip();\n        ByteBuffer bout = ByteBuffer.allocateDirect(Snappy.maxCompressedLength(bin.remaining()));\n        int compressedSize2 = Snappy.compress(bin, bout);\n        assertEquals(compressedSize, compressedSize2);\n\n        assertTrue(Snappy.isValidCompressedBuffer(bout));\n        // Intentionally set an invalid range\n        bout.limit(bout.limit() + 1);\n        assertFalse(Snappy.isValidCompressedBuffer(bout));\n        bout.limit(bout.limit() - 1);\n        bout.position(1);\n        assertFalse(Snappy.isValidCompressedBuffer(bout));\n    }\n\n    @Test\n    public void highLevelAPI()\n            throws Exception\n    {\n\n        String m = \"Hello! 01234 ACGDSFSDFJ World. FDSDF02394234 fdsfda03924\";\n        byte[] input = m.getBytes();\n        byte[] output = Snappy.compress(input);\n\n        byte[] uncompressed = Snappy.uncompress(output);\n        String m2 = new String(uncompressed);\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void lowLevelAPI()\n            throws Exception\n    {\n\n        String m = \"Hello! 01234 ACGDSFSDFJ World. FDSDF02394234 fdsfda03924\";\n        byte[] input = m.getBytes();\n        byte[] output = Snappy.rawCompress(input, input.length);\n\n        byte[] uncompressed = Snappy.uncompress(output);\n        String m2 = new String(uncompressed);\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void simpleUsage()\n            throws Exception\n    {\n\n        String input = \"Hello snappy-java! Snappy-java is a JNI-based wrapper\"\n                + \" for using Snappy from Google (written in C++), a fast compresser/decompresser.\";\n        byte[] compressed = Snappy.compress(input.getBytes(\"UTF-8\"));\n        byte[] uncompressed = Snappy.uncompress(compressed);\n        String result = new String(uncompressed, \"UTF-8\");\n        _logger.debug(result);\n    }\n\n    @Test\n    public void floatArray()\n            throws Exception\n    {\n        float[] data = new float[] {1.0f, -0.3f, 1.3f, 234.4f, 34};\n        byte[] compressed = Snappy.compress(data);\n        float[] result = Snappy.uncompressFloatArray(compressed);\n        assertArrayEquals(data, result, 0.0f);\n    }\n\n    @Test\n    public void doubleArray()\n            throws Exception\n    {\n        double[] data = new double[] {1.0, -0.3, 1.3, 234.4, 34};\n        byte[] compressed = Snappy.compress(data);\n        double[] result = Snappy.uncompressDoubleArray(compressed);\n        assertArrayEquals(data, result, 0.0f);\n    }\n\n    @Test\n    public void longArray()\n            throws Exception\n    {\n        long[] data = new long[] {2, 3, 15, 4234, 43251531412342342L, 23423422342L};\n        byte[] compressed = Snappy.compress(data);\n        long[] result = Snappy.uncompressLongArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void shortArray()\n            throws Exception\n    {\n        short[] data = new short[] {432, -32267, 1, 3, 34, 43, 34, Short.MAX_VALUE, -1};\n        byte[] compressed = Snappy.compress(data);\n        short[] result = Snappy.uncompressShortArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void intArray()\n            throws Exception\n    {\n        int[] data = new int[] {432, -32267, 1, 3, 34, 43, 34, Short.MAX_VALUE, -1, Integer.MAX_VALUE, 3424, 43};\n        byte[] compressed = Snappy.compress(data);\n        int[] result = Snappy.uncompressIntArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void charArray()\n            throws Exception\n    {\n        char[] data = new char[] {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '!'};\n        byte[] compressed = Snappy.compress(data);\n        char[] result = Snappy.uncompressCharArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void string()\n            throws Exception\n    {\n        String s = \"Hello Snappy! Snappy! Snappy!\";\n        byte[] compressed = Snappy.compress(s);\n        String uncompressedString = Snappy.uncompressString(compressed);\n        assertEquals(s, uncompressedString);\n    }\n\n    @Test\n    public void isValidCompressedData()\n            throws Exception\n    {\n\n        byte[] b = new byte[] {(byte) 91, (byte) 34, (byte) 80, (byte) 73, (byte) 34, (byte) 93};\n\n        assertFalse(Snappy.isValidCompressedBuffer(b));\n\n        try {\n            byte[] uncompressed = Snappy.uncompress(b);\n            fail(\"cannot reach here since the input is invalid data\");\n        }\n        catch (IOException e) {\n            _logger.debug(e);\n        }\n    }\n\n\n    /*\n    Tests happy cases for SnappyInputStream.read method\n    - {0}\n     */\n    @Test\n    public void isValidChunkLengthForSnappyInputStreamIn()\n            throws Exception {\n        byte[] data = {0};\n        SnappyInputStream in = new SnappyInputStream(new ByteArrayInputStream(data));\n        byte[] out = new byte[50];\n        in.read(out);\n    }\n\n    /*\n    Tests sad cases for SnappyInputStream.read method\n    - Expects a java.lang.NegativeArraySizeException catched into a SnappyError\n    - {-126, 'S', 'N', 'A', 'P', 'P', 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0,(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff}\n     */\n    @Test(expected = SnappyError.class)\n    public void isInvalidChunkLengthForSnappyInputStreamInNegative()\n            throws Exception {\n        byte[] data = {-126, 'S', 'N', 'A', 'P', 'P', 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0,(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff};\n        SnappyInputStream in = new SnappyInputStream(new ByteArrayInputStream(data));\n        byte[] out = new byte[50];\n        in.read(out);\n    }\n\n    /*\n    Tests sad cases for SnappyInputStream.read method\n    - Expects a java.lang.OutOfMemoryError\n    - {-126, 'S', 'N', 'A', 'P', 'P', 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0,(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff}\n     */\n    @Test(expected = SnappyError.class)\n    public void isInvalidChunkLengthForSnappyInputStreamOutOfMemory()\n            throws Exception {\n        byte[] data = {-126, 'S', 'N', 'A', 'P', 'P', 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0, (byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff};\n        SnappyInputStream in = new SnappyInputStream(new ByteArrayInputStream(data));\n        byte[] out = new byte[50];\n        try {\n            in.read(out);\n        } catch (Exception ignored) {\n            // Exception here will be catched\n            // But OutOfMemoryError will not be caught, and will still be thrown\n        }\n    }\n\n    /*\n    Tests happy cases for BitShuffle.shuffle method\n    - double: 0, 10\n    - float: 0, 10\n    - int: 0, 10\n    - long: 0, 10\n    - short: 0, 10\n     */\n    @Test\n    public void isValidArrayInputLength()\n            throws Exception {\n        byte[] a = Snappy.compress(new char[0]);\n        byte[] b = Snappy.compress(new double[0]);\n        byte[] c = Snappy.compress(new float[0]);\n        byte[] d = Snappy.compress(new int[0]);\n        byte[] e = Snappy.compress(new long[0]);\n        byte[] f = Snappy.compress(new short[0]);\n        byte[] g = Snappy.compress(new char[10]);\n        byte[] h = Snappy.compress(new double[10]);\n        byte[] i = Snappy.compress(new float[10]);\n        byte[] j = Snappy.compress(new int[10]);\n        byte[] k = Snappy.compress(new long[10]);\n        byte[] l = Snappy.compress(new short[10]);\n    }\n\n    /*\n    Tests sad cases for Snappy.compress\n    - Allocate a buffer whose byte size will be a bit larger than Integer.MAX_VALUE\n    - char\n    - double\n    - float\n    - int\n    - long\n    - short\n     */\n    @Test(expected = SnappyError.class)\n    public void isTooLargeDoubleArrayInputLength() throws Exception {\n        Snappy.compress(new double[Integer.MAX_VALUE / 8 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeCharArrayInputLength() throws Exception {\n        Snappy.compress(new char[Integer.MAX_VALUE / 2 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeFloatArrayInputLength() throws Exception {\n        Snappy.compress(new float[Integer.MAX_VALUE / 4 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeIntArrayInputLength() throws Exception {\n        Snappy.compress(new int[Integer.MAX_VALUE / 4 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeLongArrayInputLength() throws Exception {\n        Snappy.compress(new long[Integer.MAX_VALUE / 8 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeShortArrayInputLength() throws Exception {\n        Snappy.compress(new short[Integer.MAX_VALUE / 2 + 1]);\n    }\n\n    /*\n    Tests happy cases for Snappy.compress\n    - char: 0, 10\n    */\n    @Test\n    public void isValidArrayInputLengthForBitShuffleShuffle()\n            throws Exception\n    {\n        byte[] b = BitShuffle.shuffle(new double[0]);\n        byte[] c = BitShuffle.shuffle(new float[0]);\n        byte[] d = BitShuffle.shuffle(new int[0]);\n        byte[] e = BitShuffle.shuffle(new long[0]);\n        byte[] f = BitShuffle.shuffle(new short[0]);\n        byte[] n = BitShuffle.shuffle(new double[10]);\n        byte[] o = BitShuffle.shuffle(new float[10]);\n        byte[] p = BitShuffle.shuffle(new int[10]);\n        byte[] q = BitShuffle.shuffle(new long[10]);\n        byte[] r = BitShuffle.shuffle(new short[10]);\n    }\n\n    /*\n    Tests sad cases for BitShuffle.shuffle method\n    - Allocate a buffer whose byte size will be a bit larger than Integer.MAX_VALUE\n    - double: 8\n    - float: 4\n    - int: 4\n    - long: 8\n    - short: 2\n     */\n    @Test(expected = SnappyError.class)\n    public void isTooLargeDoubleArrayInputLengthForBitShuffleShuffle() throws Exception {\n        BitShuffle.shuffle(new double[Integer.MAX_VALUE / 8 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeFloatArrayInputLengthForBitShuffleShuffle() throws Exception {\n        BitShuffle.shuffle(new float[Integer.MAX_VALUE / 4 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeIntArrayInputLengthForBitShuffleShuffle() throws Exception {\n        BitShuffle.shuffle(new float[Integer.MAX_VALUE / 4 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeLongArrayInputLengthForBitShuffleShuffle() throws Exception {\n        BitShuffle.shuffle(new long[Integer.MAX_VALUE / 8 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeShortArrayInputLengthForBitShuffleShuffle() throws Exception {\n        BitShuffle.shuffle(new short[Integer.MAX_VALUE / 2 + 1]);\n\n\n    }\n}\n"], "filenames": ["src/main/java/org/xerial/snappy/Snappy.java", "src/test/java/org/xerial/snappy/SnappyTest.java"], "buggy_code_start_loc": [172, 22], "buggy_code_end_loc": [233, 437], "fixing_code_start_loc": [172, 22], "fixing_code_end_loc": [257, 500], "type": "CWE-190", "message": "snappy-java is a fast compressor/decompressor for Java. Due to unchecked multiplications, an integer overflow may occur in versions prior to 1.1.10.1, causing an unrecoverable fatal error.\n\nThe function `compress(char[] input)` in the file `Snappy.java` receives an array of characters and compresses it. It does so by multiplying the length by 2 and passing it to the rawCompress` function.\n\nSince the length is not tested, the multiplication by two can cause an integer overflow and become negative. The rawCompress function then uses the received length and passes it to the natively compiled maxCompressedLength function, using the returned value to allocate a byte array.\n\nSince the maxCompressedLength function treats the length as an unsigned integer, it doesn\u2019t care that it is negative, and it returns a valid value, which is casted to a signed integer by the Java engine. If the result is negative, a `java.lang.NegativeArraySizeException` exception will be raised while trying to allocate the array `buf`. On the other side, if the result is positive, the `buf` array will successfully be allocated, but its size might be too small to use for the compression, causing a fatal Access Violation error.\n\nThe same issue exists also when using the `compress` functions that receive double, float, int, long and short, each using a different multiplier that may cause the same issue. The issue most likely won\u2019t occur when using a byte array, since creating a byte array of size 0x80000000 (or any other negative value) is impossible in the first place.\n\nVersion 1.1.10.1 contains a patch for this issue.", "other": {"cve": {"id": "CVE-2023-34454", "sourceIdentifier": "security-advisories@github.com", "published": "2023-06-15T17:15:09.873", "lastModified": "2023-06-27T16:04:04.517", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "snappy-java is a fast compressor/decompressor for Java. Due to unchecked multiplications, an integer overflow may occur in versions prior to 1.1.10.1, causing an unrecoverable fatal error.\n\nThe function `compress(char[] input)` in the file `Snappy.java` receives an array of characters and compresses it. It does so by multiplying the length by 2 and passing it to the rawCompress` function.\n\nSince the length is not tested, the multiplication by two can cause an integer overflow and become negative. The rawCompress function then uses the received length and passes it to the natively compiled maxCompressedLength function, using the returned value to allocate a byte array.\n\nSince the maxCompressedLength function treats the length as an unsigned integer, it doesn\u2019t care that it is negative, and it returns a valid value, which is casted to a signed integer by the Java engine. If the result is negative, a `java.lang.NegativeArraySizeException` exception will be raised while trying to allocate the array `buf`. On the other side, if the result is positive, the `buf` array will successfully be allocated, but its size might be too small to use for the compression, causing a fatal Access Violation error.\n\nThe same issue exists also when using the `compress` functions that receive double, float, int, long and short, each using a different multiplier that may cause the same issue. The issue most likely won\u2019t occur when using a byte array, since creating a byte array of size 0x80000000 (or any other negative value) is impossible in the first place.\n\nVersion 1.1.10.1 contains a patch for this issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xerial:snappy-java:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.10.1", "matchCriteriaId": "11C2E65C-E284-478A-8D65-351AF645472B"}]}]}], "references": [{"url": "https://github.com/xerial/snappy-java/blob/05c39b2ca9b5b7b39611529cc302d3d796329611/src/main/java/org/xerial/snappy/Snappy.java#L169", "source": "security-advisories@github.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/xerial/snappy-java/blob/05c39b2ca9b5b7b39611529cc302d3d796329611/src/main/java/org/xerial/snappy/Snappy.java#L422", "source": "security-advisories@github.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/xerial/snappy-java/blob/master/src/main/java/org/xerial/snappy/Snappy.java", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Product"]}, {"url": "https://github.com/xerial/snappy-java/commit/d0042551e4a3509a725038eb9b2ad1f683674d94", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/xerial/snappy-java/security/advisories/GHSA-fjpj-2g6w-x25r", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/xerial/snappy-java/commit/d0042551e4a3509a725038eb9b2ad1f683674d94"}}