{"buggy_code": ["// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)\n//\n// This file is provided under a dual BSD/GPLv2 license.  When using or\n// redistributing this file, you may do so under either license.\n//\n// Copyright(c) 2018 Intel Corporation. All rights reserved.\n//\n// Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>\n//\n// Generic IPC layer that can work over MMIO and SPI/I2C. PHY layer provided\n// by platform driver code.\n//\n\n#include <linux/mutex.h>\n#include <linux/types.h>\n\n#include \"sof-priv.h\"\n#include \"ops.h\"\n\nstatic void ipc_trace_message(struct snd_sof_dev *sdev, u32 msg_id);\nstatic void ipc_stream_message(struct snd_sof_dev *sdev, u32 msg_cmd);\n\n/*\n * IPC message Tx/Rx message handling.\n */\n\n/* SOF generic IPC data */\nstruct snd_sof_ipc {\n\tstruct snd_sof_dev *sdev;\n\n\t/* protects messages and the disable flag */\n\tstruct mutex tx_mutex;\n\t/* disables further sending of ipc's */\n\tbool disable_ipc_tx;\n\n\tstruct snd_sof_ipc_msg msg;\n};\n\nstruct sof_ipc_ctrl_data_params {\n\tsize_t msg_bytes;\n\tsize_t hdr_bytes;\n\tsize_t pl_size;\n\tsize_t elems;\n\tu32 num_msg;\n\tu8 *src;\n\tu8 *dst;\n};\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_VERBOSE_IPC)\nstatic void ipc_log_header(struct device *dev, u8 *text, u32 cmd)\n{\n\tu8 *str;\n\tu8 *str2 = NULL;\n\tu32 glb;\n\tu32 type;\n\n\tglb = cmd & SOF_GLB_TYPE_MASK;\n\ttype = cmd & SOF_CMD_TYPE_MASK;\n\n\tswitch (glb) {\n\tcase SOF_IPC_GLB_REPLY:\n\t\tstr = \"GLB_REPLY\"; break;\n\tcase SOF_IPC_GLB_COMPOUND:\n\t\tstr = \"GLB_COMPOUND\"; break;\n\tcase SOF_IPC_GLB_TPLG_MSG:\n\t\tstr = \"GLB_TPLG_MSG\";\n\t\tswitch (type) {\n\t\tcase SOF_IPC_TPLG_COMP_NEW:\n\t\t\tstr2 = \"COMP_NEW\"; break;\n\t\tcase SOF_IPC_TPLG_COMP_FREE:\n\t\t\tstr2 = \"COMP_FREE\"; break;\n\t\tcase SOF_IPC_TPLG_COMP_CONNECT:\n\t\t\tstr2 = \"COMP_CONNECT\"; break;\n\t\tcase SOF_IPC_TPLG_PIPE_NEW:\n\t\t\tstr2 = \"PIPE_NEW\"; break;\n\t\tcase SOF_IPC_TPLG_PIPE_FREE:\n\t\t\tstr2 = \"PIPE_FREE\"; break;\n\t\tcase SOF_IPC_TPLG_PIPE_CONNECT:\n\t\t\tstr2 = \"PIPE_CONNECT\"; break;\n\t\tcase SOF_IPC_TPLG_PIPE_COMPLETE:\n\t\t\tstr2 = \"PIPE_COMPLETE\"; break;\n\t\tcase SOF_IPC_TPLG_BUFFER_NEW:\n\t\t\tstr2 = \"BUFFER_NEW\"; break;\n\t\tcase SOF_IPC_TPLG_BUFFER_FREE:\n\t\t\tstr2 = \"BUFFER_FREE\"; break;\n\t\tdefault:\n\t\t\tstr2 = \"unknown type\"; break;\n\t\t}\n\t\tbreak;\n\tcase SOF_IPC_GLB_PM_MSG:\n\t\tstr = \"GLB_PM_MSG\";\n\t\tswitch (type) {\n\t\tcase SOF_IPC_PM_CTX_SAVE:\n\t\t\tstr2 = \"CTX_SAVE\"; break;\n\t\tcase SOF_IPC_PM_CTX_RESTORE:\n\t\t\tstr2 = \"CTX_RESTORE\"; break;\n\t\tcase SOF_IPC_PM_CTX_SIZE:\n\t\t\tstr2 = \"CTX_SIZE\"; break;\n\t\tcase SOF_IPC_PM_CLK_SET:\n\t\t\tstr2 = \"CLK_SET\"; break;\n\t\tcase SOF_IPC_PM_CLK_GET:\n\t\t\tstr2 = \"CLK_GET\"; break;\n\t\tcase SOF_IPC_PM_CLK_REQ:\n\t\t\tstr2 = \"CLK_REQ\"; break;\n\t\tcase SOF_IPC_PM_CORE_ENABLE:\n\t\t\tstr2 = \"CORE_ENABLE\"; break;\n\t\tdefault:\n\t\t\tstr2 = \"unknown type\"; break;\n\t\t}\n\t\tbreak;\n\tcase SOF_IPC_GLB_COMP_MSG:\n\t\tstr = \"GLB_COMP_MSG\";\n\t\tswitch (type) {\n\t\tcase SOF_IPC_COMP_SET_VALUE:\n\t\t\tstr2 = \"SET_VALUE\"; break;\n\t\tcase SOF_IPC_COMP_GET_VALUE:\n\t\t\tstr2 = \"GET_VALUE\"; break;\n\t\tcase SOF_IPC_COMP_SET_DATA:\n\t\t\tstr2 = \"SET_DATA\"; break;\n\t\tcase SOF_IPC_COMP_GET_DATA:\n\t\t\tstr2 = \"GET_DATA\"; break;\n\t\tdefault:\n\t\t\tstr2 = \"unknown type\"; break;\n\t\t}\n\t\tbreak;\n\tcase SOF_IPC_GLB_STREAM_MSG:\n\t\tstr = \"GLB_STREAM_MSG\";\n\t\tswitch (type) {\n\t\tcase SOF_IPC_STREAM_PCM_PARAMS:\n\t\t\tstr2 = \"PCM_PARAMS\"; break;\n\t\tcase SOF_IPC_STREAM_PCM_PARAMS_REPLY:\n\t\t\tstr2 = \"PCM_REPLY\"; break;\n\t\tcase SOF_IPC_STREAM_PCM_FREE:\n\t\t\tstr2 = \"PCM_FREE\"; break;\n\t\tcase SOF_IPC_STREAM_TRIG_START:\n\t\t\tstr2 = \"TRIG_START\"; break;\n\t\tcase SOF_IPC_STREAM_TRIG_STOP:\n\t\t\tstr2 = \"TRIG_STOP\"; break;\n\t\tcase SOF_IPC_STREAM_TRIG_PAUSE:\n\t\t\tstr2 = \"TRIG_PAUSE\"; break;\n\t\tcase SOF_IPC_STREAM_TRIG_RELEASE:\n\t\t\tstr2 = \"TRIG_RELEASE\"; break;\n\t\tcase SOF_IPC_STREAM_TRIG_DRAIN:\n\t\t\tstr2 = \"TRIG_DRAIN\"; break;\n\t\tcase SOF_IPC_STREAM_TRIG_XRUN:\n\t\t\tstr2 = \"TRIG_XRUN\"; break;\n\t\tcase SOF_IPC_STREAM_POSITION:\n\t\t\tstr2 = \"POSITION\"; break;\n\t\tcase SOF_IPC_STREAM_VORBIS_PARAMS:\n\t\t\tstr2 = \"VORBIS_PARAMS\"; break;\n\t\tcase SOF_IPC_STREAM_VORBIS_FREE:\n\t\t\tstr2 = \"VORBIS_FREE\"; break;\n\t\tdefault:\n\t\t\tstr2 = \"unknown type\"; break;\n\t\t}\n\t\tbreak;\n\tcase SOF_IPC_FW_READY:\n\t\tstr = \"FW_READY\"; break;\n\tcase SOF_IPC_GLB_DAI_MSG:\n\t\tstr = \"GLB_DAI_MSG\";\n\t\tswitch (type) {\n\t\tcase SOF_IPC_DAI_CONFIG:\n\t\t\tstr2 = \"CONFIG\"; break;\n\t\tcase SOF_IPC_DAI_LOOPBACK:\n\t\t\tstr2 = \"LOOPBACK\"; break;\n\t\tdefault:\n\t\t\tstr2 = \"unknown type\"; break;\n\t\t}\n\t\tbreak;\n\tcase SOF_IPC_GLB_TRACE_MSG:\n\t\tstr = \"GLB_TRACE_MSG\"; break;\n\tcase SOF_IPC_GLB_TEST_MSG:\n\t\tstr = \"GLB_TEST_MSG\";\n\t\tswitch (type) {\n\t\tcase SOF_IPC_TEST_IPC_FLOOD:\n\t\t\tstr2 = \"IPC_FLOOD\"; break;\n\t\tdefault:\n\t\t\tstr2 = \"unknown type\"; break;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tstr = \"unknown GLB command\"; break;\n\t}\n\n\tif (str2)\n\t\tdev_dbg(dev, \"%s: 0x%x: %s: %s\\n\", text, cmd, str, str2);\n\telse\n\t\tdev_dbg(dev, \"%s: 0x%x: %s\\n\", text, cmd, str);\n}\n#else\nstatic inline void ipc_log_header(struct device *dev, u8 *text, u32 cmd)\n{\n\tif ((cmd & SOF_GLB_TYPE_MASK) != SOF_IPC_GLB_TRACE_MSG)\n\t\tdev_dbg(dev, \"%s: 0x%x\\n\", text, cmd);\n}\n#endif\n\n/* wait for IPC message reply */\nstatic int tx_wait_done(struct snd_sof_ipc *ipc, struct snd_sof_ipc_msg *msg,\n\t\t\tvoid *reply_data)\n{\n\tstruct snd_sof_dev *sdev = ipc->sdev;\n\tstruct sof_ipc_cmd_hdr *hdr = msg->msg_data;\n\tint ret;\n\n\t/* wait for DSP IPC completion */\n\tret = wait_event_timeout(msg->waitq, msg->ipc_complete,\n\t\t\t\t msecs_to_jiffies(sdev->ipc_timeout));\n\n\tif (ret == 0) {\n\t\tdev_err(sdev->dev, \"error: ipc timed out for 0x%x size %d\\n\",\n\t\t\thdr->cmd, hdr->size);\n\t\tsnd_sof_dsp_dbg_dump(ipc->sdev, SOF_DBG_REGS | SOF_DBG_MBOX);\n\t\tsnd_sof_ipc_dump(ipc->sdev);\n\t\tsnd_sof_trace_notify_for_error(ipc->sdev);\n\t\tret = -ETIMEDOUT;\n\t} else {\n\t\t/* copy the data returned from DSP */\n\t\tret = msg->reply_error;\n\t\tif (msg->reply_size)\n\t\t\tmemcpy(reply_data, msg->reply_data, msg->reply_size);\n\t\tif (ret < 0)\n\t\t\tdev_err(sdev->dev, \"error: ipc error for 0x%x size %zu\\n\",\n\t\t\t\thdr->cmd, msg->reply_size);\n\t\telse\n\t\t\tipc_log_header(sdev->dev, \"ipc tx succeeded\", hdr->cmd);\n\t}\n\n\treturn ret;\n}\n\n/* send IPC message from host to DSP */\nstatic int sof_ipc_tx_message_unlocked(struct snd_sof_ipc *ipc, u32 header,\n\t\t\t\t       void *msg_data, size_t msg_bytes,\n\t\t\t\t       void *reply_data, size_t reply_bytes)\n{\n\tstruct snd_sof_dev *sdev = ipc->sdev;\n\tstruct snd_sof_ipc_msg *msg;\n\tint ret;\n\n\tif (ipc->disable_ipc_tx)\n\t\treturn -ENODEV;\n\n\t/*\n\t * The spin-lock is also still needed to protect message objects against\n\t * other atomic contexts.\n\t */\n\tspin_lock_irq(&sdev->ipc_lock);\n\n\t/* initialise the message */\n\tmsg = &ipc->msg;\n\n\tmsg->header = header;\n\tmsg->msg_size = msg_bytes;\n\tmsg->reply_size = reply_bytes;\n\tmsg->reply_error = 0;\n\n\t/* attach any data */\n\tif (msg_bytes)\n\t\tmemcpy(msg->msg_data, msg_data, msg_bytes);\n\n\tsdev->msg = msg;\n\n\tret = snd_sof_dsp_send_msg(sdev, msg);\n\t/* Next reply that we receive will be related to this message */\n\tif (!ret)\n\t\tmsg->ipc_complete = false;\n\n\tspin_unlock_irq(&sdev->ipc_lock);\n\n\tif (ret < 0) {\n\t\t/* So far IPC TX never fails, consider making the above void */\n\t\tdev_err_ratelimited(sdev->dev,\n\t\t\t\t    \"error: ipc tx failed with error %d\\n\",\n\t\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\tipc_log_header(sdev->dev, \"ipc tx\", msg->header);\n\n\t/* now wait for completion */\n\tif (!ret)\n\t\tret = tx_wait_done(ipc, msg, reply_data);\n\n\treturn ret;\n}\n\n/* send IPC message from host to DSP */\nint sof_ipc_tx_message(struct snd_sof_ipc *ipc, u32 header,\n\t\t       void *msg_data, size_t msg_bytes, void *reply_data,\n\t\t       size_t reply_bytes)\n{\n\tint ret;\n\n\tif (msg_bytes > SOF_IPC_MSG_MAX_SIZE ||\n\t    reply_bytes > SOF_IPC_MSG_MAX_SIZE)\n\t\treturn -ENOBUFS;\n\n\t/* Serialise IPC TX */\n\tmutex_lock(&ipc->tx_mutex);\n\n\tret = sof_ipc_tx_message_unlocked(ipc, header, msg_data, msg_bytes,\n\t\t\t\t\t  reply_data, reply_bytes);\n\n\tmutex_unlock(&ipc->tx_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(sof_ipc_tx_message);\n\n/* handle reply message from DSP */\nint snd_sof_ipc_reply(struct snd_sof_dev *sdev, u32 msg_id)\n{\n\tstruct snd_sof_ipc_msg *msg = &sdev->ipc->msg;\n\n\tif (msg->ipc_complete) {\n\t\tdev_err(sdev->dev, \"error: no reply expected, received 0x%x\",\n\t\t\tmsg_id);\n\t\treturn -EINVAL;\n\t}\n\n\t/* wake up and return the error if we have waiters on this message ? */\n\tmsg->ipc_complete = true;\n\twake_up(&msg->waitq);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_sof_ipc_reply);\n\n/* DSP firmware has sent host a message  */\nvoid snd_sof_ipc_msgs_rx(struct snd_sof_dev *sdev)\n{\n\tstruct sof_ipc_cmd_hdr hdr;\n\tu32 cmd, type;\n\tint err = 0;\n\n\t/* read back header */\n\tsnd_sof_ipc_msg_data(sdev, NULL, &hdr, sizeof(hdr));\n\tipc_log_header(sdev->dev, \"ipc rx\", hdr.cmd);\n\n\tcmd = hdr.cmd & SOF_GLB_TYPE_MASK;\n\ttype = hdr.cmd & SOF_CMD_TYPE_MASK;\n\n\t/* check message type */\n\tswitch (cmd) {\n\tcase SOF_IPC_GLB_REPLY:\n\t\tdev_err(sdev->dev, \"error: ipc reply unknown\\n\");\n\t\tbreak;\n\tcase SOF_IPC_FW_READY:\n\t\t/* check for FW boot completion */\n\t\tif (!sdev->boot_complete) {\n\t\t\terr = sof_ops(sdev)->fw_ready(sdev, cmd);\n\t\t\tif (err < 0) {\n\t\t\t\t/*\n\t\t\t\t * this indicates a mismatch in ABI\n\t\t\t\t * between the driver and fw\n\t\t\t\t */\n\t\t\t\tdev_err(sdev->dev, \"error: ABI mismatch %d\\n\",\n\t\t\t\t\terr);\n\t\t\t} else {\n\t\t\t\t/* firmware boot completed OK */\n\t\t\t\tsdev->boot_complete = true;\n\t\t\t}\n\n\t\t\t/* wake up firmware loader */\n\t\t\twake_up(&sdev->boot_wait);\n\t\t}\n\t\tbreak;\n\tcase SOF_IPC_GLB_COMPOUND:\n\tcase SOF_IPC_GLB_TPLG_MSG:\n\tcase SOF_IPC_GLB_PM_MSG:\n\tcase SOF_IPC_GLB_COMP_MSG:\n\t\tbreak;\n\tcase SOF_IPC_GLB_STREAM_MSG:\n\t\t/* need to pass msg id into the function */\n\t\tipc_stream_message(sdev, hdr.cmd);\n\t\tbreak;\n\tcase SOF_IPC_GLB_TRACE_MSG:\n\t\tipc_trace_message(sdev, type);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(sdev->dev, \"error: unknown DSP message 0x%x\\n\", cmd);\n\t\tbreak;\n\t}\n\n\tipc_log_header(sdev->dev, \"ipc rx done\", hdr.cmd);\n}\nEXPORT_SYMBOL(snd_sof_ipc_msgs_rx);\n\n/*\n * IPC trace mechanism.\n */\n\nstatic void ipc_trace_message(struct snd_sof_dev *sdev, u32 msg_id)\n{\n\tstruct sof_ipc_dma_trace_posn posn;\n\n\tswitch (msg_id) {\n\tcase SOF_IPC_TRACE_DMA_POSITION:\n\t\t/* read back full message */\n\t\tsnd_sof_ipc_msg_data(sdev, NULL, &posn, sizeof(posn));\n\t\tsnd_sof_trace_update_pos(sdev, &posn);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(sdev->dev, \"error: unhandled trace message %x\\n\",\n\t\t\tmsg_id);\n\t\tbreak;\n\t}\n}\n\n/*\n * IPC stream position.\n */\n\nstatic void ipc_period_elapsed(struct snd_sof_dev *sdev, u32 msg_id)\n{\n\tstruct snd_sof_pcm_stream *stream;\n\tstruct sof_ipc_stream_posn posn;\n\tstruct snd_sof_pcm *spcm;\n\tint direction;\n\n\tspcm = snd_sof_find_spcm_comp(sdev, msg_id, &direction);\n\tif (!spcm) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"error: period elapsed for unknown stream, msg_id %d\\n\",\n\t\t\tmsg_id);\n\t\treturn;\n\t}\n\n\tstream = &spcm->stream[direction];\n\tsnd_sof_ipc_msg_data(sdev, stream->substream, &posn, sizeof(posn));\n\n\tdev_dbg(sdev->dev, \"posn : host 0x%llx dai 0x%llx wall 0x%llx\\n\",\n\t\tposn.host_posn, posn.dai_posn, posn.wallclock);\n\n\tmemcpy(&stream->posn, &posn, sizeof(posn));\n\n\t/* only inform ALSA for period_wakeup mode */\n\tif (!stream->substream->runtime->no_period_wakeup)\n\t\tsnd_sof_pcm_period_elapsed(stream->substream);\n}\n\n/* DSP notifies host of an XRUN within FW */\nstatic void ipc_xrun(struct snd_sof_dev *sdev, u32 msg_id)\n{\n\tstruct snd_sof_pcm_stream *stream;\n\tstruct sof_ipc_stream_posn posn;\n\tstruct snd_sof_pcm *spcm;\n\tint direction;\n\n\tspcm = snd_sof_find_spcm_comp(sdev, msg_id, &direction);\n\tif (!spcm) {\n\t\tdev_err(sdev->dev, \"error: XRUN for unknown stream, msg_id %d\\n\",\n\t\t\tmsg_id);\n\t\treturn;\n\t}\n\n\tstream = &spcm->stream[direction];\n\tsnd_sof_ipc_msg_data(sdev, stream->substream, &posn, sizeof(posn));\n\n\tdev_dbg(sdev->dev,  \"posn XRUN: host %llx comp %d size %d\\n\",\n\t\tposn.host_posn, posn.xrun_comp_id, posn.xrun_size);\n\n#if defined(CONFIG_SND_SOC_SOF_DEBUG_XRUN_STOP)\n\t/* stop PCM on XRUN - used for pipeline debug */\n\tmemcpy(&stream->posn, &posn, sizeof(posn));\n\tsnd_pcm_stop_xrun(stream->substream);\n#endif\n}\n\n/* stream notifications from DSP FW */\nstatic void ipc_stream_message(struct snd_sof_dev *sdev, u32 msg_cmd)\n{\n\t/* get msg cmd type and msd id */\n\tu32 msg_type = msg_cmd & SOF_CMD_TYPE_MASK;\n\tu32 msg_id = SOF_IPC_MESSAGE_ID(msg_cmd);\n\n\tswitch (msg_type) {\n\tcase SOF_IPC_STREAM_POSITION:\n\t\tipc_period_elapsed(sdev, msg_id);\n\t\tbreak;\n\tcase SOF_IPC_STREAM_TRIG_XRUN:\n\t\tipc_xrun(sdev, msg_id);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(sdev->dev, \"error: unhandled stream message %x\\n\",\n\t\t\tmsg_id);\n\t\tbreak;\n\t}\n}\n\n/* get stream position IPC - use faster MMIO method if available on platform */\nint snd_sof_ipc_stream_posn(struct snd_sof_dev *sdev,\n\t\t\t    struct snd_sof_pcm *spcm, int direction,\n\t\t\t    struct sof_ipc_stream_posn *posn)\n{\n\tstruct sof_ipc_stream stream;\n\tint err;\n\n\t/* read position via slower IPC */\n\tstream.hdr.size = sizeof(stream);\n\tstream.hdr.cmd = SOF_IPC_GLB_STREAM_MSG | SOF_IPC_STREAM_POSITION;\n\tstream.comp_id = spcm->stream[direction].comp_id;\n\n\t/* send IPC to the DSP */\n\terr = sof_ipc_tx_message(sdev->ipc,\n\t\t\t\t stream.hdr.cmd, &stream, sizeof(stream), &posn,\n\t\t\t\t sizeof(*posn));\n\tif (err < 0) {\n\t\tdev_err(sdev->dev, \"error: failed to get stream %d position\\n\",\n\t\t\tstream.comp_id);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_sof_ipc_stream_posn);\n\nstatic int sof_get_ctrl_copy_params(enum sof_ipc_ctrl_type ctrl_type,\n\t\t\t\t    struct sof_ipc_ctrl_data *src,\n\t\t\t\t    struct sof_ipc_ctrl_data *dst,\n\t\t\t\t    struct sof_ipc_ctrl_data_params *sparams)\n{\n\tswitch (ctrl_type) {\n\tcase SOF_CTRL_TYPE_VALUE_CHAN_GET:\n\tcase SOF_CTRL_TYPE_VALUE_CHAN_SET:\n\t\tsparams->src = (u8 *)src->chanv;\n\t\tsparams->dst = (u8 *)dst->chanv;\n\t\tbreak;\n\tcase SOF_CTRL_TYPE_VALUE_COMP_GET:\n\tcase SOF_CTRL_TYPE_VALUE_COMP_SET:\n\t\tsparams->src = (u8 *)src->compv;\n\t\tsparams->dst = (u8 *)dst->compv;\n\t\tbreak;\n\tcase SOF_CTRL_TYPE_DATA_GET:\n\tcase SOF_CTRL_TYPE_DATA_SET:\n\t\tsparams->src = (u8 *)src->data->data;\n\t\tsparams->dst = (u8 *)dst->data->data;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t/* calculate payload size and number of messages */\n\tsparams->pl_size = SOF_IPC_MSG_MAX_SIZE - sparams->hdr_bytes;\n\tsparams->num_msg = DIV_ROUND_UP(sparams->msg_bytes, sparams->pl_size);\n\n\treturn 0;\n}\n\nstatic int sof_set_get_large_ctrl_data(struct snd_sof_dev *sdev,\n\t\t\t\t       struct sof_ipc_ctrl_data *cdata,\n\t\t\t\t       struct sof_ipc_ctrl_data_params *sparams,\n\t\t\t\t       bool send)\n{\n\tstruct sof_ipc_ctrl_data *partdata;\n\tsize_t send_bytes;\n\tsize_t offset = 0;\n\tsize_t msg_bytes;\n\tsize_t pl_size;\n\tint err;\n\tint i;\n\n\t/* allocate max ipc size because we have at least one */\n\tpartdata = kzalloc(SOF_IPC_MSG_MAX_SIZE, GFP_KERNEL);\n\tif (!partdata)\n\t\treturn -ENOMEM;\n\n\tif (send)\n\t\terr = sof_get_ctrl_copy_params(cdata->type, cdata, partdata,\n\t\t\t\t\t       sparams);\n\telse\n\t\terr = sof_get_ctrl_copy_params(cdata->type, partdata, cdata,\n\t\t\t\t\t       sparams);\n\tif (err < 0)\n\t\treturn err;\n\n\tmsg_bytes = sparams->msg_bytes;\n\tpl_size = sparams->pl_size;\n\n\t/* copy the header data */\n\tmemcpy(partdata, cdata, sparams->hdr_bytes);\n\n\t/* Serialise IPC TX */\n\tmutex_lock(&sdev->ipc->tx_mutex);\n\n\t/* copy the payload data in a loop */\n\tfor (i = 0; i < sparams->num_msg; i++) {\n\t\tsend_bytes = min(msg_bytes, pl_size);\n\t\tpartdata->num_elems = send_bytes;\n\t\tpartdata->rhdr.hdr.size = sparams->hdr_bytes + send_bytes;\n\t\tpartdata->msg_index = i;\n\t\tmsg_bytes -= send_bytes;\n\t\tpartdata->elems_remaining = msg_bytes;\n\n\t\tif (send)\n\t\t\tmemcpy(sparams->dst, sparams->src + offset, send_bytes);\n\n\t\terr = sof_ipc_tx_message_unlocked(sdev->ipc,\n\t\t\t\t\t\t  partdata->rhdr.hdr.cmd,\n\t\t\t\t\t\t  partdata,\n\t\t\t\t\t\t  partdata->rhdr.hdr.size,\n\t\t\t\t\t\t  partdata,\n\t\t\t\t\t\t  partdata->rhdr.hdr.size);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tif (!send)\n\t\t\tmemcpy(sparams->dst + offset, sparams->src, send_bytes);\n\n\t\toffset += pl_size;\n\t}\n\n\tmutex_unlock(&sdev->ipc->tx_mutex);\n\n\tkfree(partdata);\n\treturn err;\n}\n\n/*\n * IPC get()/set() for kcontrols.\n */\nint snd_sof_ipc_set_get_comp_data(struct snd_sof_ipc *ipc,\n\t\t\t\t  struct snd_sof_control *scontrol,\n\t\t\t\t  u32 ipc_cmd,\n\t\t\t\t  enum sof_ipc_ctrl_type ctrl_type,\n\t\t\t\t  enum sof_ipc_ctrl_cmd ctrl_cmd,\n\t\t\t\t  bool send)\n{\n\tstruct sof_ipc_ctrl_data *cdata = scontrol->control_data;\n\tstruct snd_sof_dev *sdev = ipc->sdev;\n\tstruct sof_ipc_fw_ready *ready = &sdev->fw_ready;\n\tstruct sof_ipc_fw_version *v = &ready->version;\n\tstruct sof_ipc_ctrl_data_params sparams;\n\tsize_t send_bytes;\n\tint err;\n\n\t/* read or write firmware volume */\n\tif (scontrol->readback_offset != 0) {\n\t\t/* write/read value header via mmaped region */\n\t\tsend_bytes = sizeof(struct sof_ipc_ctrl_value_chan) *\n\t\tcdata->num_elems;\n\t\tif (send)\n\t\t\tsnd_sof_dsp_block_write(sdev, sdev->mmio_bar,\n\t\t\t\t\t\tscontrol->readback_offset,\n\t\t\t\t\t\tcdata->chanv, send_bytes);\n\n\t\telse\n\t\t\tsnd_sof_dsp_block_read(sdev, sdev->mmio_bar,\n\t\t\t\t\t       scontrol->readback_offset,\n\t\t\t\t\t       cdata->chanv, send_bytes);\n\t\treturn 0;\n\t}\n\n\tcdata->rhdr.hdr.cmd = SOF_IPC_GLB_COMP_MSG | ipc_cmd;\n\tcdata->cmd = ctrl_cmd;\n\tcdata->type = ctrl_type;\n\tcdata->comp_id = scontrol->comp_id;\n\tcdata->msg_index = 0;\n\n\t/* calculate header and data size */\n\tswitch (cdata->type) {\n\tcase SOF_CTRL_TYPE_VALUE_CHAN_GET:\n\tcase SOF_CTRL_TYPE_VALUE_CHAN_SET:\n\t\tsparams.msg_bytes = scontrol->num_channels *\n\t\t\tsizeof(struct sof_ipc_ctrl_value_chan);\n\t\tsparams.hdr_bytes = sizeof(struct sof_ipc_ctrl_data);\n\t\tsparams.elems = scontrol->num_channels;\n\t\tbreak;\n\tcase SOF_CTRL_TYPE_VALUE_COMP_GET:\n\tcase SOF_CTRL_TYPE_VALUE_COMP_SET:\n\t\tsparams.msg_bytes = scontrol->num_channels *\n\t\t\tsizeof(struct sof_ipc_ctrl_value_comp);\n\t\tsparams.hdr_bytes = sizeof(struct sof_ipc_ctrl_data);\n\t\tsparams.elems = scontrol->num_channels;\n\t\tbreak;\n\tcase SOF_CTRL_TYPE_DATA_GET:\n\tcase SOF_CTRL_TYPE_DATA_SET:\n\t\tsparams.msg_bytes = cdata->data->size;\n\t\tsparams.hdr_bytes = sizeof(struct sof_ipc_ctrl_data) +\n\t\t\tsizeof(struct sof_abi_hdr);\n\t\tsparams.elems = cdata->data->size;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tcdata->rhdr.hdr.size = sparams.msg_bytes + sparams.hdr_bytes;\n\tcdata->num_elems = sparams.elems;\n\tcdata->elems_remaining = 0;\n\n\t/* send normal size ipc in one part */\n\tif (cdata->rhdr.hdr.size <= SOF_IPC_MSG_MAX_SIZE) {\n\t\terr = sof_ipc_tx_message(sdev->ipc, cdata->rhdr.hdr.cmd, cdata,\n\t\t\t\t\t cdata->rhdr.hdr.size, cdata,\n\t\t\t\t\t cdata->rhdr.hdr.size);\n\n\t\tif (err < 0)\n\t\t\tdev_err(sdev->dev, \"error: set/get ctrl ipc comp %d\\n\",\n\t\t\t\tcdata->comp_id);\n\n\t\treturn err;\n\t}\n\n\t/* data is bigger than max ipc size, chop into smaller pieces */\n\tdev_dbg(sdev->dev, \"large ipc size %u, control size %u\\n\",\n\t\tcdata->rhdr.hdr.size, scontrol->size);\n\n\t/* large messages is only supported from ABI 3.3.0 onwards */\n\tif (v->abi_version < SOF_ABI_VER(3, 3, 0)) {\n\t\tdev_err(sdev->dev, \"error: incompatible FW ABI version\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = sof_set_get_large_ctrl_data(sdev, cdata, &sparams, send);\n\n\tif (err < 0)\n\t\tdev_err(sdev->dev, \"error: set/get large ctrl ipc comp %d\\n\",\n\t\t\tcdata->comp_id);\n\n\treturn err;\n}\nEXPORT_SYMBOL(snd_sof_ipc_set_get_comp_data);\n\n/*\n * IPC layer enumeration.\n */\n\nint snd_sof_dsp_mailbox_init(struct snd_sof_dev *sdev, u32 dspbox,\n\t\t\t     size_t dspbox_size, u32 hostbox,\n\t\t\t     size_t hostbox_size)\n{\n\tsdev->dsp_box.offset = dspbox;\n\tsdev->dsp_box.size = dspbox_size;\n\tsdev->host_box.offset = hostbox;\n\tsdev->host_box.size = hostbox_size;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_sof_dsp_mailbox_init);\n\nint snd_sof_ipc_valid(struct snd_sof_dev *sdev)\n{\n\tstruct sof_ipc_fw_ready *ready = &sdev->fw_ready;\n\tstruct sof_ipc_fw_version *v = &ready->version;\n\n\tdev_info(sdev->dev,\n\t\t \"Firmware info: version %d:%d:%d-%s\\n\",  v->major, v->minor,\n\t\t v->micro, v->tag);\n\tdev_info(sdev->dev,\n\t\t \"Firmware: ABI %d:%d:%d Kernel ABI %d:%d:%d\\n\",\n\t\t SOF_ABI_VERSION_MAJOR(v->abi_version),\n\t\t SOF_ABI_VERSION_MINOR(v->abi_version),\n\t\t SOF_ABI_VERSION_PATCH(v->abi_version),\n\t\t SOF_ABI_MAJOR, SOF_ABI_MINOR, SOF_ABI_PATCH);\n\n\tif (SOF_ABI_VERSION_INCOMPATIBLE(SOF_ABI_VERSION, v->abi_version)) {\n\t\tdev_err(sdev->dev, \"error: incompatible FW ABI version\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (v->abi_version > SOF_ABI_VERSION) {\n\t\tif (!IS_ENABLED(CONFIG_SND_SOC_SOF_STRICT_ABI_CHECKS)) {\n\t\t\tdev_warn(sdev->dev, \"warn: FW ABI is more recent than kernel\\n\");\n\t\t} else {\n\t\t\tdev_err(sdev->dev, \"error: FW ABI is more recent than kernel\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (ready->flags & SOF_IPC_INFO_BUILD) {\n\t\tdev_info(sdev->dev,\n\t\t\t \"Firmware debug build %d on %s-%s - options:\\n\"\n\t\t\t \" GDB: %s\\n\"\n\t\t\t \" lock debug: %s\\n\"\n\t\t\t \" lock vdebug: %s\\n\",\n\t\t\t v->build, v->date, v->time,\n\t\t\t (ready->flags & SOF_IPC_INFO_GDB) ?\n\t\t\t\t\"enabled\" : \"disabled\",\n\t\t\t (ready->flags & SOF_IPC_INFO_LOCKS) ?\n\t\t\t\t\"enabled\" : \"disabled\",\n\t\t\t (ready->flags & SOF_IPC_INFO_LOCKSV) ?\n\t\t\t\t\"enabled\" : \"disabled\");\n\t}\n\n\t/* copy the fw_version into debugfs at first boot */\n\tmemcpy(&sdev->fw_version, v, sizeof(*v));\n\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_sof_ipc_valid);\n\nstruct snd_sof_ipc *snd_sof_ipc_init(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_ipc *ipc;\n\tstruct snd_sof_ipc_msg *msg;\n\n\t/* check if mandatory ops required for ipc are defined */\n\tif (!sof_ops(sdev)->fw_ready) {\n\t\tdev_err(sdev->dev, \"error: ipc mandatory ops not defined\\n\");\n\t\treturn NULL;\n\t}\n\n\tipc = devm_kzalloc(sdev->dev, sizeof(*ipc), GFP_KERNEL);\n\tif (!ipc)\n\t\treturn NULL;\n\n\tmutex_init(&ipc->tx_mutex);\n\tipc->sdev = sdev;\n\tmsg = &ipc->msg;\n\n\t/* indicate that we aren't sending a message ATM */\n\tmsg->ipc_complete = true;\n\n\t/* pre-allocate message data */\n\tmsg->msg_data = devm_kzalloc(sdev->dev, SOF_IPC_MSG_MAX_SIZE,\n\t\t\t\t     GFP_KERNEL);\n\tif (!msg->msg_data)\n\t\treturn NULL;\n\n\tmsg->reply_data = devm_kzalloc(sdev->dev, SOF_IPC_MSG_MAX_SIZE,\n\t\t\t\t       GFP_KERNEL);\n\tif (!msg->reply_data)\n\t\treturn NULL;\n\n\tinit_waitqueue_head(&msg->waitq);\n\n\treturn ipc;\n}\nEXPORT_SYMBOL(snd_sof_ipc_init);\n\nvoid snd_sof_ipc_free(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_ipc *ipc = sdev->ipc;\n\n\t/* disable sending of ipc's */\n\tmutex_lock(&ipc->tx_mutex);\n\tipc->disable_ipc_tx = true;\n\tmutex_unlock(&ipc->tx_mutex);\n}\nEXPORT_SYMBOL(snd_sof_ipc_free);\n"], "fixing_code": ["// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)\n//\n// This file is provided under a dual BSD/GPLv2 license.  When using or\n// redistributing this file, you may do so under either license.\n//\n// Copyright(c) 2018 Intel Corporation. All rights reserved.\n//\n// Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>\n//\n// Generic IPC layer that can work over MMIO and SPI/I2C. PHY layer provided\n// by platform driver code.\n//\n\n#include <linux/mutex.h>\n#include <linux/types.h>\n\n#include \"sof-priv.h\"\n#include \"ops.h\"\n\nstatic void ipc_trace_message(struct snd_sof_dev *sdev, u32 msg_id);\nstatic void ipc_stream_message(struct snd_sof_dev *sdev, u32 msg_cmd);\n\n/*\n * IPC message Tx/Rx message handling.\n */\n\n/* SOF generic IPC data */\nstruct snd_sof_ipc {\n\tstruct snd_sof_dev *sdev;\n\n\t/* protects messages and the disable flag */\n\tstruct mutex tx_mutex;\n\t/* disables further sending of ipc's */\n\tbool disable_ipc_tx;\n\n\tstruct snd_sof_ipc_msg msg;\n};\n\nstruct sof_ipc_ctrl_data_params {\n\tsize_t msg_bytes;\n\tsize_t hdr_bytes;\n\tsize_t pl_size;\n\tsize_t elems;\n\tu32 num_msg;\n\tu8 *src;\n\tu8 *dst;\n};\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_VERBOSE_IPC)\nstatic void ipc_log_header(struct device *dev, u8 *text, u32 cmd)\n{\n\tu8 *str;\n\tu8 *str2 = NULL;\n\tu32 glb;\n\tu32 type;\n\n\tglb = cmd & SOF_GLB_TYPE_MASK;\n\ttype = cmd & SOF_CMD_TYPE_MASK;\n\n\tswitch (glb) {\n\tcase SOF_IPC_GLB_REPLY:\n\t\tstr = \"GLB_REPLY\"; break;\n\tcase SOF_IPC_GLB_COMPOUND:\n\t\tstr = \"GLB_COMPOUND\"; break;\n\tcase SOF_IPC_GLB_TPLG_MSG:\n\t\tstr = \"GLB_TPLG_MSG\";\n\t\tswitch (type) {\n\t\tcase SOF_IPC_TPLG_COMP_NEW:\n\t\t\tstr2 = \"COMP_NEW\"; break;\n\t\tcase SOF_IPC_TPLG_COMP_FREE:\n\t\t\tstr2 = \"COMP_FREE\"; break;\n\t\tcase SOF_IPC_TPLG_COMP_CONNECT:\n\t\t\tstr2 = \"COMP_CONNECT\"; break;\n\t\tcase SOF_IPC_TPLG_PIPE_NEW:\n\t\t\tstr2 = \"PIPE_NEW\"; break;\n\t\tcase SOF_IPC_TPLG_PIPE_FREE:\n\t\t\tstr2 = \"PIPE_FREE\"; break;\n\t\tcase SOF_IPC_TPLG_PIPE_CONNECT:\n\t\t\tstr2 = \"PIPE_CONNECT\"; break;\n\t\tcase SOF_IPC_TPLG_PIPE_COMPLETE:\n\t\t\tstr2 = \"PIPE_COMPLETE\"; break;\n\t\tcase SOF_IPC_TPLG_BUFFER_NEW:\n\t\t\tstr2 = \"BUFFER_NEW\"; break;\n\t\tcase SOF_IPC_TPLG_BUFFER_FREE:\n\t\t\tstr2 = \"BUFFER_FREE\"; break;\n\t\tdefault:\n\t\t\tstr2 = \"unknown type\"; break;\n\t\t}\n\t\tbreak;\n\tcase SOF_IPC_GLB_PM_MSG:\n\t\tstr = \"GLB_PM_MSG\";\n\t\tswitch (type) {\n\t\tcase SOF_IPC_PM_CTX_SAVE:\n\t\t\tstr2 = \"CTX_SAVE\"; break;\n\t\tcase SOF_IPC_PM_CTX_RESTORE:\n\t\t\tstr2 = \"CTX_RESTORE\"; break;\n\t\tcase SOF_IPC_PM_CTX_SIZE:\n\t\t\tstr2 = \"CTX_SIZE\"; break;\n\t\tcase SOF_IPC_PM_CLK_SET:\n\t\t\tstr2 = \"CLK_SET\"; break;\n\t\tcase SOF_IPC_PM_CLK_GET:\n\t\t\tstr2 = \"CLK_GET\"; break;\n\t\tcase SOF_IPC_PM_CLK_REQ:\n\t\t\tstr2 = \"CLK_REQ\"; break;\n\t\tcase SOF_IPC_PM_CORE_ENABLE:\n\t\t\tstr2 = \"CORE_ENABLE\"; break;\n\t\tdefault:\n\t\t\tstr2 = \"unknown type\"; break;\n\t\t}\n\t\tbreak;\n\tcase SOF_IPC_GLB_COMP_MSG:\n\t\tstr = \"GLB_COMP_MSG\";\n\t\tswitch (type) {\n\t\tcase SOF_IPC_COMP_SET_VALUE:\n\t\t\tstr2 = \"SET_VALUE\"; break;\n\t\tcase SOF_IPC_COMP_GET_VALUE:\n\t\t\tstr2 = \"GET_VALUE\"; break;\n\t\tcase SOF_IPC_COMP_SET_DATA:\n\t\t\tstr2 = \"SET_DATA\"; break;\n\t\tcase SOF_IPC_COMP_GET_DATA:\n\t\t\tstr2 = \"GET_DATA\"; break;\n\t\tdefault:\n\t\t\tstr2 = \"unknown type\"; break;\n\t\t}\n\t\tbreak;\n\tcase SOF_IPC_GLB_STREAM_MSG:\n\t\tstr = \"GLB_STREAM_MSG\";\n\t\tswitch (type) {\n\t\tcase SOF_IPC_STREAM_PCM_PARAMS:\n\t\t\tstr2 = \"PCM_PARAMS\"; break;\n\t\tcase SOF_IPC_STREAM_PCM_PARAMS_REPLY:\n\t\t\tstr2 = \"PCM_REPLY\"; break;\n\t\tcase SOF_IPC_STREAM_PCM_FREE:\n\t\t\tstr2 = \"PCM_FREE\"; break;\n\t\tcase SOF_IPC_STREAM_TRIG_START:\n\t\t\tstr2 = \"TRIG_START\"; break;\n\t\tcase SOF_IPC_STREAM_TRIG_STOP:\n\t\t\tstr2 = \"TRIG_STOP\"; break;\n\t\tcase SOF_IPC_STREAM_TRIG_PAUSE:\n\t\t\tstr2 = \"TRIG_PAUSE\"; break;\n\t\tcase SOF_IPC_STREAM_TRIG_RELEASE:\n\t\t\tstr2 = \"TRIG_RELEASE\"; break;\n\t\tcase SOF_IPC_STREAM_TRIG_DRAIN:\n\t\t\tstr2 = \"TRIG_DRAIN\"; break;\n\t\tcase SOF_IPC_STREAM_TRIG_XRUN:\n\t\t\tstr2 = \"TRIG_XRUN\"; break;\n\t\tcase SOF_IPC_STREAM_POSITION:\n\t\t\tstr2 = \"POSITION\"; break;\n\t\tcase SOF_IPC_STREAM_VORBIS_PARAMS:\n\t\t\tstr2 = \"VORBIS_PARAMS\"; break;\n\t\tcase SOF_IPC_STREAM_VORBIS_FREE:\n\t\t\tstr2 = \"VORBIS_FREE\"; break;\n\t\tdefault:\n\t\t\tstr2 = \"unknown type\"; break;\n\t\t}\n\t\tbreak;\n\tcase SOF_IPC_FW_READY:\n\t\tstr = \"FW_READY\"; break;\n\tcase SOF_IPC_GLB_DAI_MSG:\n\t\tstr = \"GLB_DAI_MSG\";\n\t\tswitch (type) {\n\t\tcase SOF_IPC_DAI_CONFIG:\n\t\t\tstr2 = \"CONFIG\"; break;\n\t\tcase SOF_IPC_DAI_LOOPBACK:\n\t\t\tstr2 = \"LOOPBACK\"; break;\n\t\tdefault:\n\t\t\tstr2 = \"unknown type\"; break;\n\t\t}\n\t\tbreak;\n\tcase SOF_IPC_GLB_TRACE_MSG:\n\t\tstr = \"GLB_TRACE_MSG\"; break;\n\tcase SOF_IPC_GLB_TEST_MSG:\n\t\tstr = \"GLB_TEST_MSG\";\n\t\tswitch (type) {\n\t\tcase SOF_IPC_TEST_IPC_FLOOD:\n\t\t\tstr2 = \"IPC_FLOOD\"; break;\n\t\tdefault:\n\t\t\tstr2 = \"unknown type\"; break;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tstr = \"unknown GLB command\"; break;\n\t}\n\n\tif (str2)\n\t\tdev_dbg(dev, \"%s: 0x%x: %s: %s\\n\", text, cmd, str, str2);\n\telse\n\t\tdev_dbg(dev, \"%s: 0x%x: %s\\n\", text, cmd, str);\n}\n#else\nstatic inline void ipc_log_header(struct device *dev, u8 *text, u32 cmd)\n{\n\tif ((cmd & SOF_GLB_TYPE_MASK) != SOF_IPC_GLB_TRACE_MSG)\n\t\tdev_dbg(dev, \"%s: 0x%x\\n\", text, cmd);\n}\n#endif\n\n/* wait for IPC message reply */\nstatic int tx_wait_done(struct snd_sof_ipc *ipc, struct snd_sof_ipc_msg *msg,\n\t\t\tvoid *reply_data)\n{\n\tstruct snd_sof_dev *sdev = ipc->sdev;\n\tstruct sof_ipc_cmd_hdr *hdr = msg->msg_data;\n\tint ret;\n\n\t/* wait for DSP IPC completion */\n\tret = wait_event_timeout(msg->waitq, msg->ipc_complete,\n\t\t\t\t msecs_to_jiffies(sdev->ipc_timeout));\n\n\tif (ret == 0) {\n\t\tdev_err(sdev->dev, \"error: ipc timed out for 0x%x size %d\\n\",\n\t\t\thdr->cmd, hdr->size);\n\t\tsnd_sof_dsp_dbg_dump(ipc->sdev, SOF_DBG_REGS | SOF_DBG_MBOX);\n\t\tsnd_sof_ipc_dump(ipc->sdev);\n\t\tsnd_sof_trace_notify_for_error(ipc->sdev);\n\t\tret = -ETIMEDOUT;\n\t} else {\n\t\t/* copy the data returned from DSP */\n\t\tret = msg->reply_error;\n\t\tif (msg->reply_size)\n\t\t\tmemcpy(reply_data, msg->reply_data, msg->reply_size);\n\t\tif (ret < 0)\n\t\t\tdev_err(sdev->dev, \"error: ipc error for 0x%x size %zu\\n\",\n\t\t\t\thdr->cmd, msg->reply_size);\n\t\telse\n\t\t\tipc_log_header(sdev->dev, \"ipc tx succeeded\", hdr->cmd);\n\t}\n\n\treturn ret;\n}\n\n/* send IPC message from host to DSP */\nstatic int sof_ipc_tx_message_unlocked(struct snd_sof_ipc *ipc, u32 header,\n\t\t\t\t       void *msg_data, size_t msg_bytes,\n\t\t\t\t       void *reply_data, size_t reply_bytes)\n{\n\tstruct snd_sof_dev *sdev = ipc->sdev;\n\tstruct snd_sof_ipc_msg *msg;\n\tint ret;\n\n\tif (ipc->disable_ipc_tx)\n\t\treturn -ENODEV;\n\n\t/*\n\t * The spin-lock is also still needed to protect message objects against\n\t * other atomic contexts.\n\t */\n\tspin_lock_irq(&sdev->ipc_lock);\n\n\t/* initialise the message */\n\tmsg = &ipc->msg;\n\n\tmsg->header = header;\n\tmsg->msg_size = msg_bytes;\n\tmsg->reply_size = reply_bytes;\n\tmsg->reply_error = 0;\n\n\t/* attach any data */\n\tif (msg_bytes)\n\t\tmemcpy(msg->msg_data, msg_data, msg_bytes);\n\n\tsdev->msg = msg;\n\n\tret = snd_sof_dsp_send_msg(sdev, msg);\n\t/* Next reply that we receive will be related to this message */\n\tif (!ret)\n\t\tmsg->ipc_complete = false;\n\n\tspin_unlock_irq(&sdev->ipc_lock);\n\n\tif (ret < 0) {\n\t\t/* So far IPC TX never fails, consider making the above void */\n\t\tdev_err_ratelimited(sdev->dev,\n\t\t\t\t    \"error: ipc tx failed with error %d\\n\",\n\t\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\tipc_log_header(sdev->dev, \"ipc tx\", msg->header);\n\n\t/* now wait for completion */\n\tif (!ret)\n\t\tret = tx_wait_done(ipc, msg, reply_data);\n\n\treturn ret;\n}\n\n/* send IPC message from host to DSP */\nint sof_ipc_tx_message(struct snd_sof_ipc *ipc, u32 header,\n\t\t       void *msg_data, size_t msg_bytes, void *reply_data,\n\t\t       size_t reply_bytes)\n{\n\tint ret;\n\n\tif (msg_bytes > SOF_IPC_MSG_MAX_SIZE ||\n\t    reply_bytes > SOF_IPC_MSG_MAX_SIZE)\n\t\treturn -ENOBUFS;\n\n\t/* Serialise IPC TX */\n\tmutex_lock(&ipc->tx_mutex);\n\n\tret = sof_ipc_tx_message_unlocked(ipc, header, msg_data, msg_bytes,\n\t\t\t\t\t  reply_data, reply_bytes);\n\n\tmutex_unlock(&ipc->tx_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(sof_ipc_tx_message);\n\n/* handle reply message from DSP */\nint snd_sof_ipc_reply(struct snd_sof_dev *sdev, u32 msg_id)\n{\n\tstruct snd_sof_ipc_msg *msg = &sdev->ipc->msg;\n\n\tif (msg->ipc_complete) {\n\t\tdev_err(sdev->dev, \"error: no reply expected, received 0x%x\",\n\t\t\tmsg_id);\n\t\treturn -EINVAL;\n\t}\n\n\t/* wake up and return the error if we have waiters on this message ? */\n\tmsg->ipc_complete = true;\n\twake_up(&msg->waitq);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_sof_ipc_reply);\n\n/* DSP firmware has sent host a message  */\nvoid snd_sof_ipc_msgs_rx(struct snd_sof_dev *sdev)\n{\n\tstruct sof_ipc_cmd_hdr hdr;\n\tu32 cmd, type;\n\tint err = 0;\n\n\t/* read back header */\n\tsnd_sof_ipc_msg_data(sdev, NULL, &hdr, sizeof(hdr));\n\tipc_log_header(sdev->dev, \"ipc rx\", hdr.cmd);\n\n\tcmd = hdr.cmd & SOF_GLB_TYPE_MASK;\n\ttype = hdr.cmd & SOF_CMD_TYPE_MASK;\n\n\t/* check message type */\n\tswitch (cmd) {\n\tcase SOF_IPC_GLB_REPLY:\n\t\tdev_err(sdev->dev, \"error: ipc reply unknown\\n\");\n\t\tbreak;\n\tcase SOF_IPC_FW_READY:\n\t\t/* check for FW boot completion */\n\t\tif (!sdev->boot_complete) {\n\t\t\terr = sof_ops(sdev)->fw_ready(sdev, cmd);\n\t\t\tif (err < 0) {\n\t\t\t\t/*\n\t\t\t\t * this indicates a mismatch in ABI\n\t\t\t\t * between the driver and fw\n\t\t\t\t */\n\t\t\t\tdev_err(sdev->dev, \"error: ABI mismatch %d\\n\",\n\t\t\t\t\terr);\n\t\t\t} else {\n\t\t\t\t/* firmware boot completed OK */\n\t\t\t\tsdev->boot_complete = true;\n\t\t\t}\n\n\t\t\t/* wake up firmware loader */\n\t\t\twake_up(&sdev->boot_wait);\n\t\t}\n\t\tbreak;\n\tcase SOF_IPC_GLB_COMPOUND:\n\tcase SOF_IPC_GLB_TPLG_MSG:\n\tcase SOF_IPC_GLB_PM_MSG:\n\tcase SOF_IPC_GLB_COMP_MSG:\n\t\tbreak;\n\tcase SOF_IPC_GLB_STREAM_MSG:\n\t\t/* need to pass msg id into the function */\n\t\tipc_stream_message(sdev, hdr.cmd);\n\t\tbreak;\n\tcase SOF_IPC_GLB_TRACE_MSG:\n\t\tipc_trace_message(sdev, type);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(sdev->dev, \"error: unknown DSP message 0x%x\\n\", cmd);\n\t\tbreak;\n\t}\n\n\tipc_log_header(sdev->dev, \"ipc rx done\", hdr.cmd);\n}\nEXPORT_SYMBOL(snd_sof_ipc_msgs_rx);\n\n/*\n * IPC trace mechanism.\n */\n\nstatic void ipc_trace_message(struct snd_sof_dev *sdev, u32 msg_id)\n{\n\tstruct sof_ipc_dma_trace_posn posn;\n\n\tswitch (msg_id) {\n\tcase SOF_IPC_TRACE_DMA_POSITION:\n\t\t/* read back full message */\n\t\tsnd_sof_ipc_msg_data(sdev, NULL, &posn, sizeof(posn));\n\t\tsnd_sof_trace_update_pos(sdev, &posn);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(sdev->dev, \"error: unhandled trace message %x\\n\",\n\t\t\tmsg_id);\n\t\tbreak;\n\t}\n}\n\n/*\n * IPC stream position.\n */\n\nstatic void ipc_period_elapsed(struct snd_sof_dev *sdev, u32 msg_id)\n{\n\tstruct snd_sof_pcm_stream *stream;\n\tstruct sof_ipc_stream_posn posn;\n\tstruct snd_sof_pcm *spcm;\n\tint direction;\n\n\tspcm = snd_sof_find_spcm_comp(sdev, msg_id, &direction);\n\tif (!spcm) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"error: period elapsed for unknown stream, msg_id %d\\n\",\n\t\t\tmsg_id);\n\t\treturn;\n\t}\n\n\tstream = &spcm->stream[direction];\n\tsnd_sof_ipc_msg_data(sdev, stream->substream, &posn, sizeof(posn));\n\n\tdev_dbg(sdev->dev, \"posn : host 0x%llx dai 0x%llx wall 0x%llx\\n\",\n\t\tposn.host_posn, posn.dai_posn, posn.wallclock);\n\n\tmemcpy(&stream->posn, &posn, sizeof(posn));\n\n\t/* only inform ALSA for period_wakeup mode */\n\tif (!stream->substream->runtime->no_period_wakeup)\n\t\tsnd_sof_pcm_period_elapsed(stream->substream);\n}\n\n/* DSP notifies host of an XRUN within FW */\nstatic void ipc_xrun(struct snd_sof_dev *sdev, u32 msg_id)\n{\n\tstruct snd_sof_pcm_stream *stream;\n\tstruct sof_ipc_stream_posn posn;\n\tstruct snd_sof_pcm *spcm;\n\tint direction;\n\n\tspcm = snd_sof_find_spcm_comp(sdev, msg_id, &direction);\n\tif (!spcm) {\n\t\tdev_err(sdev->dev, \"error: XRUN for unknown stream, msg_id %d\\n\",\n\t\t\tmsg_id);\n\t\treturn;\n\t}\n\n\tstream = &spcm->stream[direction];\n\tsnd_sof_ipc_msg_data(sdev, stream->substream, &posn, sizeof(posn));\n\n\tdev_dbg(sdev->dev,  \"posn XRUN: host %llx comp %d size %d\\n\",\n\t\tposn.host_posn, posn.xrun_comp_id, posn.xrun_size);\n\n#if defined(CONFIG_SND_SOC_SOF_DEBUG_XRUN_STOP)\n\t/* stop PCM on XRUN - used for pipeline debug */\n\tmemcpy(&stream->posn, &posn, sizeof(posn));\n\tsnd_pcm_stop_xrun(stream->substream);\n#endif\n}\n\n/* stream notifications from DSP FW */\nstatic void ipc_stream_message(struct snd_sof_dev *sdev, u32 msg_cmd)\n{\n\t/* get msg cmd type and msd id */\n\tu32 msg_type = msg_cmd & SOF_CMD_TYPE_MASK;\n\tu32 msg_id = SOF_IPC_MESSAGE_ID(msg_cmd);\n\n\tswitch (msg_type) {\n\tcase SOF_IPC_STREAM_POSITION:\n\t\tipc_period_elapsed(sdev, msg_id);\n\t\tbreak;\n\tcase SOF_IPC_STREAM_TRIG_XRUN:\n\t\tipc_xrun(sdev, msg_id);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(sdev->dev, \"error: unhandled stream message %x\\n\",\n\t\t\tmsg_id);\n\t\tbreak;\n\t}\n}\n\n/* get stream position IPC - use faster MMIO method if available on platform */\nint snd_sof_ipc_stream_posn(struct snd_sof_dev *sdev,\n\t\t\t    struct snd_sof_pcm *spcm, int direction,\n\t\t\t    struct sof_ipc_stream_posn *posn)\n{\n\tstruct sof_ipc_stream stream;\n\tint err;\n\n\t/* read position via slower IPC */\n\tstream.hdr.size = sizeof(stream);\n\tstream.hdr.cmd = SOF_IPC_GLB_STREAM_MSG | SOF_IPC_STREAM_POSITION;\n\tstream.comp_id = spcm->stream[direction].comp_id;\n\n\t/* send IPC to the DSP */\n\terr = sof_ipc_tx_message(sdev->ipc,\n\t\t\t\t stream.hdr.cmd, &stream, sizeof(stream), &posn,\n\t\t\t\t sizeof(*posn));\n\tif (err < 0) {\n\t\tdev_err(sdev->dev, \"error: failed to get stream %d position\\n\",\n\t\t\tstream.comp_id);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_sof_ipc_stream_posn);\n\nstatic int sof_get_ctrl_copy_params(enum sof_ipc_ctrl_type ctrl_type,\n\t\t\t\t    struct sof_ipc_ctrl_data *src,\n\t\t\t\t    struct sof_ipc_ctrl_data *dst,\n\t\t\t\t    struct sof_ipc_ctrl_data_params *sparams)\n{\n\tswitch (ctrl_type) {\n\tcase SOF_CTRL_TYPE_VALUE_CHAN_GET:\n\tcase SOF_CTRL_TYPE_VALUE_CHAN_SET:\n\t\tsparams->src = (u8 *)src->chanv;\n\t\tsparams->dst = (u8 *)dst->chanv;\n\t\tbreak;\n\tcase SOF_CTRL_TYPE_VALUE_COMP_GET:\n\tcase SOF_CTRL_TYPE_VALUE_COMP_SET:\n\t\tsparams->src = (u8 *)src->compv;\n\t\tsparams->dst = (u8 *)dst->compv;\n\t\tbreak;\n\tcase SOF_CTRL_TYPE_DATA_GET:\n\tcase SOF_CTRL_TYPE_DATA_SET:\n\t\tsparams->src = (u8 *)src->data->data;\n\t\tsparams->dst = (u8 *)dst->data->data;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t/* calculate payload size and number of messages */\n\tsparams->pl_size = SOF_IPC_MSG_MAX_SIZE - sparams->hdr_bytes;\n\tsparams->num_msg = DIV_ROUND_UP(sparams->msg_bytes, sparams->pl_size);\n\n\treturn 0;\n}\n\nstatic int sof_set_get_large_ctrl_data(struct snd_sof_dev *sdev,\n\t\t\t\t       struct sof_ipc_ctrl_data *cdata,\n\t\t\t\t       struct sof_ipc_ctrl_data_params *sparams,\n\t\t\t\t       bool send)\n{\n\tstruct sof_ipc_ctrl_data *partdata;\n\tsize_t send_bytes;\n\tsize_t offset = 0;\n\tsize_t msg_bytes;\n\tsize_t pl_size;\n\tint err;\n\tint i;\n\n\t/* allocate max ipc size because we have at least one */\n\tpartdata = kzalloc(SOF_IPC_MSG_MAX_SIZE, GFP_KERNEL);\n\tif (!partdata)\n\t\treturn -ENOMEM;\n\n\tif (send)\n\t\terr = sof_get_ctrl_copy_params(cdata->type, cdata, partdata,\n\t\t\t\t\t       sparams);\n\telse\n\t\terr = sof_get_ctrl_copy_params(cdata->type, partdata, cdata,\n\t\t\t\t\t       sparams);\n\tif (err < 0) {\n\t\tkfree(partdata);\n\t\treturn err;\n\t}\n\n\tmsg_bytes = sparams->msg_bytes;\n\tpl_size = sparams->pl_size;\n\n\t/* copy the header data */\n\tmemcpy(partdata, cdata, sparams->hdr_bytes);\n\n\t/* Serialise IPC TX */\n\tmutex_lock(&sdev->ipc->tx_mutex);\n\n\t/* copy the payload data in a loop */\n\tfor (i = 0; i < sparams->num_msg; i++) {\n\t\tsend_bytes = min(msg_bytes, pl_size);\n\t\tpartdata->num_elems = send_bytes;\n\t\tpartdata->rhdr.hdr.size = sparams->hdr_bytes + send_bytes;\n\t\tpartdata->msg_index = i;\n\t\tmsg_bytes -= send_bytes;\n\t\tpartdata->elems_remaining = msg_bytes;\n\n\t\tif (send)\n\t\t\tmemcpy(sparams->dst, sparams->src + offset, send_bytes);\n\n\t\terr = sof_ipc_tx_message_unlocked(sdev->ipc,\n\t\t\t\t\t\t  partdata->rhdr.hdr.cmd,\n\t\t\t\t\t\t  partdata,\n\t\t\t\t\t\t  partdata->rhdr.hdr.size,\n\t\t\t\t\t\t  partdata,\n\t\t\t\t\t\t  partdata->rhdr.hdr.size);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tif (!send)\n\t\t\tmemcpy(sparams->dst + offset, sparams->src, send_bytes);\n\n\t\toffset += pl_size;\n\t}\n\n\tmutex_unlock(&sdev->ipc->tx_mutex);\n\n\tkfree(partdata);\n\treturn err;\n}\n\n/*\n * IPC get()/set() for kcontrols.\n */\nint snd_sof_ipc_set_get_comp_data(struct snd_sof_ipc *ipc,\n\t\t\t\t  struct snd_sof_control *scontrol,\n\t\t\t\t  u32 ipc_cmd,\n\t\t\t\t  enum sof_ipc_ctrl_type ctrl_type,\n\t\t\t\t  enum sof_ipc_ctrl_cmd ctrl_cmd,\n\t\t\t\t  bool send)\n{\n\tstruct sof_ipc_ctrl_data *cdata = scontrol->control_data;\n\tstruct snd_sof_dev *sdev = ipc->sdev;\n\tstruct sof_ipc_fw_ready *ready = &sdev->fw_ready;\n\tstruct sof_ipc_fw_version *v = &ready->version;\n\tstruct sof_ipc_ctrl_data_params sparams;\n\tsize_t send_bytes;\n\tint err;\n\n\t/* read or write firmware volume */\n\tif (scontrol->readback_offset != 0) {\n\t\t/* write/read value header via mmaped region */\n\t\tsend_bytes = sizeof(struct sof_ipc_ctrl_value_chan) *\n\t\tcdata->num_elems;\n\t\tif (send)\n\t\t\tsnd_sof_dsp_block_write(sdev, sdev->mmio_bar,\n\t\t\t\t\t\tscontrol->readback_offset,\n\t\t\t\t\t\tcdata->chanv, send_bytes);\n\n\t\telse\n\t\t\tsnd_sof_dsp_block_read(sdev, sdev->mmio_bar,\n\t\t\t\t\t       scontrol->readback_offset,\n\t\t\t\t\t       cdata->chanv, send_bytes);\n\t\treturn 0;\n\t}\n\n\tcdata->rhdr.hdr.cmd = SOF_IPC_GLB_COMP_MSG | ipc_cmd;\n\tcdata->cmd = ctrl_cmd;\n\tcdata->type = ctrl_type;\n\tcdata->comp_id = scontrol->comp_id;\n\tcdata->msg_index = 0;\n\n\t/* calculate header and data size */\n\tswitch (cdata->type) {\n\tcase SOF_CTRL_TYPE_VALUE_CHAN_GET:\n\tcase SOF_CTRL_TYPE_VALUE_CHAN_SET:\n\t\tsparams.msg_bytes = scontrol->num_channels *\n\t\t\tsizeof(struct sof_ipc_ctrl_value_chan);\n\t\tsparams.hdr_bytes = sizeof(struct sof_ipc_ctrl_data);\n\t\tsparams.elems = scontrol->num_channels;\n\t\tbreak;\n\tcase SOF_CTRL_TYPE_VALUE_COMP_GET:\n\tcase SOF_CTRL_TYPE_VALUE_COMP_SET:\n\t\tsparams.msg_bytes = scontrol->num_channels *\n\t\t\tsizeof(struct sof_ipc_ctrl_value_comp);\n\t\tsparams.hdr_bytes = sizeof(struct sof_ipc_ctrl_data);\n\t\tsparams.elems = scontrol->num_channels;\n\t\tbreak;\n\tcase SOF_CTRL_TYPE_DATA_GET:\n\tcase SOF_CTRL_TYPE_DATA_SET:\n\t\tsparams.msg_bytes = cdata->data->size;\n\t\tsparams.hdr_bytes = sizeof(struct sof_ipc_ctrl_data) +\n\t\t\tsizeof(struct sof_abi_hdr);\n\t\tsparams.elems = cdata->data->size;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tcdata->rhdr.hdr.size = sparams.msg_bytes + sparams.hdr_bytes;\n\tcdata->num_elems = sparams.elems;\n\tcdata->elems_remaining = 0;\n\n\t/* send normal size ipc in one part */\n\tif (cdata->rhdr.hdr.size <= SOF_IPC_MSG_MAX_SIZE) {\n\t\terr = sof_ipc_tx_message(sdev->ipc, cdata->rhdr.hdr.cmd, cdata,\n\t\t\t\t\t cdata->rhdr.hdr.size, cdata,\n\t\t\t\t\t cdata->rhdr.hdr.size);\n\n\t\tif (err < 0)\n\t\t\tdev_err(sdev->dev, \"error: set/get ctrl ipc comp %d\\n\",\n\t\t\t\tcdata->comp_id);\n\n\t\treturn err;\n\t}\n\n\t/* data is bigger than max ipc size, chop into smaller pieces */\n\tdev_dbg(sdev->dev, \"large ipc size %u, control size %u\\n\",\n\t\tcdata->rhdr.hdr.size, scontrol->size);\n\n\t/* large messages is only supported from ABI 3.3.0 onwards */\n\tif (v->abi_version < SOF_ABI_VER(3, 3, 0)) {\n\t\tdev_err(sdev->dev, \"error: incompatible FW ABI version\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = sof_set_get_large_ctrl_data(sdev, cdata, &sparams, send);\n\n\tif (err < 0)\n\t\tdev_err(sdev->dev, \"error: set/get large ctrl ipc comp %d\\n\",\n\t\t\tcdata->comp_id);\n\n\treturn err;\n}\nEXPORT_SYMBOL(snd_sof_ipc_set_get_comp_data);\n\n/*\n * IPC layer enumeration.\n */\n\nint snd_sof_dsp_mailbox_init(struct snd_sof_dev *sdev, u32 dspbox,\n\t\t\t     size_t dspbox_size, u32 hostbox,\n\t\t\t     size_t hostbox_size)\n{\n\tsdev->dsp_box.offset = dspbox;\n\tsdev->dsp_box.size = dspbox_size;\n\tsdev->host_box.offset = hostbox;\n\tsdev->host_box.size = hostbox_size;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_sof_dsp_mailbox_init);\n\nint snd_sof_ipc_valid(struct snd_sof_dev *sdev)\n{\n\tstruct sof_ipc_fw_ready *ready = &sdev->fw_ready;\n\tstruct sof_ipc_fw_version *v = &ready->version;\n\n\tdev_info(sdev->dev,\n\t\t \"Firmware info: version %d:%d:%d-%s\\n\",  v->major, v->minor,\n\t\t v->micro, v->tag);\n\tdev_info(sdev->dev,\n\t\t \"Firmware: ABI %d:%d:%d Kernel ABI %d:%d:%d\\n\",\n\t\t SOF_ABI_VERSION_MAJOR(v->abi_version),\n\t\t SOF_ABI_VERSION_MINOR(v->abi_version),\n\t\t SOF_ABI_VERSION_PATCH(v->abi_version),\n\t\t SOF_ABI_MAJOR, SOF_ABI_MINOR, SOF_ABI_PATCH);\n\n\tif (SOF_ABI_VERSION_INCOMPATIBLE(SOF_ABI_VERSION, v->abi_version)) {\n\t\tdev_err(sdev->dev, \"error: incompatible FW ABI version\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (v->abi_version > SOF_ABI_VERSION) {\n\t\tif (!IS_ENABLED(CONFIG_SND_SOC_SOF_STRICT_ABI_CHECKS)) {\n\t\t\tdev_warn(sdev->dev, \"warn: FW ABI is more recent than kernel\\n\");\n\t\t} else {\n\t\t\tdev_err(sdev->dev, \"error: FW ABI is more recent than kernel\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (ready->flags & SOF_IPC_INFO_BUILD) {\n\t\tdev_info(sdev->dev,\n\t\t\t \"Firmware debug build %d on %s-%s - options:\\n\"\n\t\t\t \" GDB: %s\\n\"\n\t\t\t \" lock debug: %s\\n\"\n\t\t\t \" lock vdebug: %s\\n\",\n\t\t\t v->build, v->date, v->time,\n\t\t\t (ready->flags & SOF_IPC_INFO_GDB) ?\n\t\t\t\t\"enabled\" : \"disabled\",\n\t\t\t (ready->flags & SOF_IPC_INFO_LOCKS) ?\n\t\t\t\t\"enabled\" : \"disabled\",\n\t\t\t (ready->flags & SOF_IPC_INFO_LOCKSV) ?\n\t\t\t\t\"enabled\" : \"disabled\");\n\t}\n\n\t/* copy the fw_version into debugfs at first boot */\n\tmemcpy(&sdev->fw_version, v, sizeof(*v));\n\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_sof_ipc_valid);\n\nstruct snd_sof_ipc *snd_sof_ipc_init(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_ipc *ipc;\n\tstruct snd_sof_ipc_msg *msg;\n\n\t/* check if mandatory ops required for ipc are defined */\n\tif (!sof_ops(sdev)->fw_ready) {\n\t\tdev_err(sdev->dev, \"error: ipc mandatory ops not defined\\n\");\n\t\treturn NULL;\n\t}\n\n\tipc = devm_kzalloc(sdev->dev, sizeof(*ipc), GFP_KERNEL);\n\tif (!ipc)\n\t\treturn NULL;\n\n\tmutex_init(&ipc->tx_mutex);\n\tipc->sdev = sdev;\n\tmsg = &ipc->msg;\n\n\t/* indicate that we aren't sending a message ATM */\n\tmsg->ipc_complete = true;\n\n\t/* pre-allocate message data */\n\tmsg->msg_data = devm_kzalloc(sdev->dev, SOF_IPC_MSG_MAX_SIZE,\n\t\t\t\t     GFP_KERNEL);\n\tif (!msg->msg_data)\n\t\treturn NULL;\n\n\tmsg->reply_data = devm_kzalloc(sdev->dev, SOF_IPC_MSG_MAX_SIZE,\n\t\t\t\t       GFP_KERNEL);\n\tif (!msg->reply_data)\n\t\treturn NULL;\n\n\tinit_waitqueue_head(&msg->waitq);\n\n\treturn ipc;\n}\nEXPORT_SYMBOL(snd_sof_ipc_init);\n\nvoid snd_sof_ipc_free(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_ipc *ipc = sdev->ipc;\n\n\t/* disable sending of ipc's */\n\tmutex_lock(&ipc->tx_mutex);\n\tipc->disable_ipc_tx = true;\n\tmutex_unlock(&ipc->tx_mutex);\n}\nEXPORT_SYMBOL(snd_sof_ipc_free);\n"], "filenames": ["sound/soc/sof/ipc.c"], "buggy_code_start_loc": [575], "buggy_code_end_loc": [576], "fixing_code_start_loc": [575], "fixing_code_end_loc": [579], "type": "CWE-401", "message": "A memory leak in the sof_set_get_large_ctrl_data() function in sound/soc/sof/ipc.c in the Linux kernel through 5.3.9 allows attackers to cause a denial of service (memory consumption) by triggering sof_get_ctrl_copy_params() failures, aka CID-45c1380358b1.", "other": {"cve": {"id": "CVE-2019-18811", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-07T16:15:11.563", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A memory leak in the sof_set_get_large_ctrl_data() function in sound/soc/sof/ipc.c in the Linux kernel through 5.3.9 allows attackers to cause a denial of service (memory consumption) by triggering sof_get_ctrl_copy_params() failures, aka CID-45c1380358b1."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n sof_set_get_large_ctrl_data() en el archivo sound/soc/sof/ipc.c en el kernel de Linux versiones hasta 5.3.9, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria) mediante la activaci\u00f3n de fallos de la funci\u00f3n sof_get_ctrl_copy_params(), tambi\u00e9n se conoce como CID-45c1380358b1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.3.9", "matchCriteriaId": "3D729DA7-EC0B-4D1C-9F5B-BA9E7B7AF272"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/45c1380358b12bf2d1db20a5874e9544f56b34ab", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LYIFGYEDQXP5DVJQQUARQRK2PXKBKQGY/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YWWOOJKZ4NQYN4RMFIVJ3ZIXKJJI3MKP/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4284-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/45c1380358b12bf2d1db20a5874e9544f56b34ab"}}