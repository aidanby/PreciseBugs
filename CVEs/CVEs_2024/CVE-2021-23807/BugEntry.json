{"buggy_code": ["var hasExcape = /~/\nvar escapeMatcher = /~[01]/g\nfunction escapeReplacer (m) {\n  switch (m) {\n    case '~1': return '/'\n    case '~0': return '~'\n  }\n  throw new Error('Invalid tilde escape: ' + m)\n}\n\nfunction untilde (str) {\n  if (!hasExcape.test(str)) return str\n  return str.replace(escapeMatcher, escapeReplacer)\n}\n\nfunction setter (obj, pointer, value) {\n  var part\n  var hasNextPart\n\n  if (pointer[1] === 'constructor' && pointer[2] === 'prototype') return obj\n  if (pointer[1] === '__proto__') return obj\n\n  for (var p = 1, len = pointer.length; p < len;) {\n    part = untilde(pointer[p++])\n    hasNextPart = len > p\n\n    if (typeof obj[part] === 'undefined') {\n      // support setting of /-\n      if (Array.isArray(obj) && part === '-') {\n        part = obj.length\n      }\n\n      // support nested objects/array when setting values\n      if (hasNextPart) {\n        if ((pointer[p] !== '' && pointer[p] < Infinity) || pointer[p] === '-') obj[part] = []\n        else obj[part] = {}\n      }\n    }\n\n    if (!hasNextPart) break\n    obj = obj[part]\n  }\n\n  var oldValue = obj[part]\n  if (value === undefined) delete obj[part]\n  else obj[part] = value\n  return oldValue\n}\n\nfunction compilePointer (pointer) {\n  if (typeof pointer === 'string') {\n    pointer = pointer.split('/')\n    if (pointer[0] === '') return pointer\n    throw new Error('Invalid JSON pointer.')\n  } else if (Array.isArray(pointer)) {\n    return pointer\n  }\n\n  throw new Error('Invalid JSON pointer.')\n}\n\nfunction get (obj, pointer) {\n  if (typeof obj !== 'object') throw new Error('Invalid input object.')\n  pointer = compilePointer(pointer)\n  var len = pointer.length\n  if (len === 1) return obj\n\n  for (var p = 1; p < len;) {\n    obj = obj[untilde(pointer[p++])]\n    if (len === p) return obj\n    if (typeof obj !== 'object') return undefined\n  }\n}\n\nfunction set (obj, pointer, value) {\n  if (typeof obj !== 'object') throw new Error('Invalid input object.')\n  pointer = compilePointer(pointer)\n  if (pointer.length === 0) throw new Error('Invalid JSON pointer for set.')\n  return setter(obj, pointer, value)\n}\n\nfunction compile (pointer) {\n  var compiled = compilePointer(pointer)\n  return {\n    get: function (object) {\n      return get(object, compiled)\n    },\n    set: function (object, value) {\n      return set(object, compiled, value)\n    }\n  }\n}\n\nexports.get = get\nexports.set = set\nexports.compile = compile\n", "var assert = require('assert')\nvar jsonpointer = require('./jsonpointer')\n\nvar obj = {\n  a: 1,\n  b: {\n    c: 2\n  },\n  d: {\n    e: [{ a: 3 }, { b: 4 }, { c: 5 }]\n  }\n}\n\nassert.equal(jsonpointer.get(obj, '/a'), 1)\nassert.equal(jsonpointer.get(obj, '/b/c'), 2)\nassert.equal(jsonpointer.get(obj, '/d/e/0/a'), 3)\nassert.equal(jsonpointer.get(obj, '/d/e/1/b'), 4)\nassert.equal(jsonpointer.get(obj, '/d/e/2/c'), 5)\n\n// set returns old value\nassert.equal(jsonpointer.set(obj, '/a', 2), 1)\nassert.equal(jsonpointer.set(obj, '/b/c', 3), 2)\nassert.equal(jsonpointer.set(obj, '/d/e/0/a', 4), 3)\nassert.equal(jsonpointer.set(obj, '/d/e/1/b', 5), 4)\nassert.equal(jsonpointer.set(obj, '/d/e/2/c', 6), 5)\n\n// set nested properties\nassert.equal(jsonpointer.set(obj, '/f/g/h/i', 6), undefined)\nassert.equal(jsonpointer.get(obj, '/f/g/h/i'), 6)\n\n// set an array\nassert.equal(jsonpointer.set(obj, '/f/g/h/foo/-', 'test'), undefined)\nvar arr = jsonpointer.get(obj, '/f/g/h/foo')\nassert(Array.isArray(arr), 'set /- creates an array.')\nassert.equal(arr[0], 'test')\n\nassert.equal(jsonpointer.get(obj, '/a'), 2)\nassert.equal(jsonpointer.get(obj, '/b/c'), 3)\nassert.equal(jsonpointer.get(obj, '/d/e/0/a'), 4)\nassert.equal(jsonpointer.get(obj, '/d/e/1/b'), 5)\nassert.equal(jsonpointer.get(obj, '/d/e/2/c'), 6)\n\n// can set `null` as a value\nassert.equal(jsonpointer.set(obj, '/f/g/h/foo/0', null), 'test')\nassert.strictEqual(jsonpointer.get(obj, '/f/g/h/foo/0'), null)\nassert.equal(jsonpointer.set(obj, '/b/c', null), 3)\nassert.strictEqual(jsonpointer.get(obj, '/b/c'), null)\n\nassert.equal(jsonpointer.get(obj, ''), obj)\nassert.throws(function () { jsonpointer.get(obj, 'a') }, validateError)\nassert.throws(function () { jsonpointer.get(obj, 'a/') }, validateError)\n\n// can unset values with `undefined`\njsonpointer.set(obj, '/a', undefined)\nassert.strictEqual(jsonpointer.get(obj, '/a'), undefined)\njsonpointer.set(obj, '/d/e/1', undefined)\nassert.strictEqual(jsonpointer.get(obj, '/d/e/1'), undefined)\n\n// returns `undefined` when path extends beyond any existing objects\nassert.strictEqual(jsonpointer.get(obj, '/x/y/z'), undefined)\n\nfunction validateError (err) {\n  if ((err instanceof Error) && /Invalid JSON pointer/.test(err.message)) {\n    return true\n  }\n}\n\nvar complexKeys = {\n  'a/b': {\n    c: 1\n  },\n  d: {\n    'e/f': 2\n  },\n  '~1': 3,\n  '01': 4\n}\n\nassert.equal(jsonpointer.get(complexKeys, '/a~1b/c'), 1)\nassert.equal(jsonpointer.get(complexKeys, '/d/e~1f'), 2)\nassert.equal(jsonpointer.get(complexKeys, '/~01'), 3)\nassert.equal(jsonpointer.get(complexKeys, '/01'), 4)\nassert.equal(jsonpointer.get(complexKeys, '/a/b/c'), null)\nassert.equal(jsonpointer.get(complexKeys, '/~1'), null)\n\n// draft-ietf-appsawg-json-pointer-08 has special array rules\nvar ary = ['zero', 'one', 'two']\nassert.equal(jsonpointer.get(ary, '/01'), null)\n\nassert.equal(jsonpointer.set(ary, '/-', 'three'), null)\nassert.equal(ary[3], 'three')\n\n// Examples from the draft:\nvar example = {\n  foo: ['bar', 'baz'],\n  '': 0,\n  'a/b': 1,\n  'c%d': 2,\n  'e^f': 3,\n  'g|h': 4,\n  'i\\\\j': 5,\n  'k\\'l': 6,\n  ' ': 7,\n  'm~n': 8\n}\n\nassert.equal(jsonpointer.get(example, ''), example)\nvar ans = jsonpointer.get(example, '/foo')\nassert.equal(ans.length, 2)\nassert.equal(ans[0], 'bar')\nassert.equal(ans[1], 'baz')\nassert.equal(jsonpointer.get(example, '/foo/0'), 'bar')\nassert.equal(jsonpointer.get(example, '/'), 0)\nassert.equal(jsonpointer.get(example, '/a~1b'), 1)\nassert.equal(jsonpointer.get(example, '/c%d'), 2)\nassert.equal(jsonpointer.get(example, '/e^f'), 3)\nassert.equal(jsonpointer.get(example, '/g|h'), 4)\nassert.equal(jsonpointer.get(example, '/i\\\\j'), 5)\nassert.equal(jsonpointer.get(example, '/k\\'l'), 6)\nassert.equal(jsonpointer.get(example, '/ '), 7)\nassert.equal(jsonpointer.get(example, '/m~0n'), 8)\n\n// jsonpointer.compile(path)\nvar a = { foo: 'bar' }\nvar pointer = jsonpointer.compile('/foo')\nassert.equal(pointer.get(a), 'bar')\nassert.equal(pointer.set(a, 'test'), 'bar')\nassert.equal(pointer.get(a), 'test')\nassert.deepEqual(a, { foo: 'test' })\n\nvar b = {}\njsonpointer.set({}, '/constructor/prototype/boo', 'polluted')\nassert(!b.boo, 'should not boo')\n\nvar c = {}\njsonpointer.set({}, '/__proto__/boo', 'polluted')\nassert(!c.boo, 'should not boo')\n\nconsole.log('All tests pass.')\n"], "fixing_code": ["var hasExcape = /~/\nvar escapeMatcher = /~[01]/g\nfunction escapeReplacer (m) {\n  switch (m) {\n    case '~1': return '/'\n    case '~0': return '~'\n  }\n  throw new Error('Invalid tilde escape: ' + m)\n}\n\nfunction untilde (str) {\n  if (!hasExcape.test(str)) return str\n  return str.replace(escapeMatcher, escapeReplacer)\n}\n\nfunction setter (obj, pointer, value) {\n  var part\n  var hasNextPart\n\n  for (var p = 1, len = pointer.length; p < len;) {\n    if (pointer[p] === 'constructor' || pointer[p] === 'prototype' || pointer[p] === '__proto__') return obj\n\n    part = untilde(pointer[p++])\n    hasNextPart = len > p\n\n    if (typeof obj[part] === 'undefined') {\n      // support setting of /-\n      if (Array.isArray(obj) && part === '-') {\n        part = obj.length\n      }\n\n      // support nested objects/array when setting values\n      if (hasNextPart) {\n        if ((pointer[p] !== '' && pointer[p] < Infinity) || pointer[p] === '-') obj[part] = []\n        else obj[part] = {}\n      }\n    }\n\n    if (!hasNextPart) break\n    obj = obj[part]\n  }\n\n  var oldValue = obj[part]\n  if (value === undefined) delete obj[part]\n  else obj[part] = value\n  return oldValue\n}\n\nfunction compilePointer (pointer) {\n  if (typeof pointer === 'string') {\n    pointer = pointer.split('/')\n    if (pointer[0] === '') return pointer\n    throw new Error('Invalid JSON pointer.')\n  } else if (Array.isArray(pointer)) {\n    for (const part of pointer) {\n      if (typeof part !== 'string' && typeof part !== 'number') {\n        throw new Error('Invalid JSON pointer. Must be of type string or number.')\n      }\n    }\n    return pointer\n  }\n\n  throw new Error('Invalid JSON pointer.')\n}\n\nfunction get (obj, pointer) {\n  if (typeof obj !== 'object') throw new Error('Invalid input object.')\n  pointer = compilePointer(pointer)\n  var len = pointer.length\n  if (len === 1) return obj\n\n  for (var p = 1; p < len;) {\n    obj = obj[untilde(pointer[p++])]\n    if (len === p) return obj\n    if (typeof obj !== 'object') return undefined\n  }\n}\n\nfunction set (obj, pointer, value) {\n  if (typeof obj !== 'object') throw new Error('Invalid input object.')\n  pointer = compilePointer(pointer)\n  if (pointer.length === 0) throw new Error('Invalid JSON pointer for set.')\n  return setter(obj, pointer, value)\n}\n\nfunction compile (pointer) {\n  var compiled = compilePointer(pointer)\n  return {\n    get: function (object) {\n      return get(object, compiled)\n    },\n    set: function (object, value) {\n      return set(object, compiled, value)\n    }\n  }\n}\n\nexports.get = get\nexports.set = set\nexports.compile = compile\n", "var assert = require('assert')\nvar jsonpointer = require('./jsonpointer')\n\nvar obj = {\n  a: 1,\n  b: {\n    c: 2\n  },\n  d: {\n    e: [{ a: 3 }, { b: 4 }, { c: 5 }]\n  }\n}\n\nassert.equal(jsonpointer.get(obj, '/a'), 1)\nassert.equal(jsonpointer.get(obj, '/b/c'), 2)\nassert.equal(jsonpointer.get(obj, '/d/e/0/a'), 3)\nassert.equal(jsonpointer.get(obj, '/d/e/1/b'), 4)\nassert.equal(jsonpointer.get(obj, '/d/e/2/c'), 5)\n\n// set returns old value\nassert.equal(jsonpointer.set(obj, '/a', 2), 1)\nassert.equal(jsonpointer.set(obj, '/b/c', 3), 2)\nassert.equal(jsonpointer.set(obj, '/d/e/0/a', 4), 3)\nassert.equal(jsonpointer.set(obj, '/d/e/1/b', 5), 4)\nassert.equal(jsonpointer.set(obj, '/d/e/2/c', 6), 5)\n\n// set nested properties\nassert.equal(jsonpointer.set(obj, '/f/g/h/i', 6), undefined)\nassert.equal(jsonpointer.get(obj, '/f/g/h/i'), 6)\n\n// set an array\nassert.equal(jsonpointer.set(obj, '/f/g/h/foo/-', 'test'), undefined)\nvar arr = jsonpointer.get(obj, '/f/g/h/foo')\nassert(Array.isArray(arr), 'set /- creates an array.')\nassert.equal(arr[0], 'test')\n\nassert.equal(jsonpointer.get(obj, '/a'), 2)\nassert.equal(jsonpointer.get(obj, '/b/c'), 3)\nassert.equal(jsonpointer.get(obj, '/d/e/0/a'), 4)\nassert.equal(jsonpointer.get(obj, '/d/e/1/b'), 5)\nassert.equal(jsonpointer.get(obj, '/d/e/2/c'), 6)\n\n// can set `null` as a value\nassert.equal(jsonpointer.set(obj, '/f/g/h/foo/0', null), 'test')\nassert.strictEqual(jsonpointer.get(obj, '/f/g/h/foo/0'), null)\nassert.equal(jsonpointer.set(obj, '/b/c', null), 3)\nassert.strictEqual(jsonpointer.get(obj, '/b/c'), null)\n\nassert.equal(jsonpointer.get(obj, ''), obj)\nassert.throws(function () { jsonpointer.get(obj, 'a') }, validateError)\nassert.throws(function () { jsonpointer.get(obj, 'a/') }, validateError)\n\n// can unset values with `undefined`\njsonpointer.set(obj, '/a', undefined)\nassert.strictEqual(jsonpointer.get(obj, '/a'), undefined)\njsonpointer.set(obj, '/d/e/1', undefined)\nassert.strictEqual(jsonpointer.get(obj, '/d/e/1'), undefined)\n\n// returns `undefined` when path extends beyond any existing objects\nassert.strictEqual(jsonpointer.get(obj, '/x/y/z'), undefined)\n\nfunction validateError (err) {\n  if ((err instanceof Error) && /Invalid JSON pointer/.test(err.message)) {\n    return true\n  }\n}\n\nvar complexKeys = {\n  'a/b': {\n    c: 1\n  },\n  d: {\n    'e/f': 2\n  },\n  '~1': 3,\n  '01': 4\n}\n\nassert.equal(jsonpointer.get(complexKeys, '/a~1b/c'), 1)\nassert.equal(jsonpointer.get(complexKeys, '/d/e~1f'), 2)\nassert.equal(jsonpointer.get(complexKeys, '/~01'), 3)\nassert.equal(jsonpointer.get(complexKeys, '/01'), 4)\nassert.equal(jsonpointer.get(complexKeys, '/a/b/c'), null)\nassert.equal(jsonpointer.get(complexKeys, '/~1'), null)\n\n// draft-ietf-appsawg-json-pointer-08 has special array rules\nvar ary = ['zero', 'one', 'two']\nassert.equal(jsonpointer.get(ary, '/01'), null)\n\nassert.equal(jsonpointer.set(ary, '/-', 'three'), null)\nassert.equal(ary[3], 'three')\n\n// Examples from the draft:\nvar example = {\n  foo: ['bar', 'baz'],\n  '': 0,\n  'a/b': 1,\n  'c%d': 2,\n  'e^f': 3,\n  'g|h': 4,\n  'i\\\\j': 5,\n  'k\\'l': 6,\n  ' ': 7,\n  'm~n': 8\n}\n\nassert.equal(jsonpointer.get(example, ''), example)\nvar ans = jsonpointer.get(example, '/foo')\nassert.equal(ans.length, 2)\nassert.equal(ans[0], 'bar')\nassert.equal(ans[1], 'baz')\nassert.equal(jsonpointer.get(example, '/foo/0'), 'bar')\nassert.equal(jsonpointer.get(example, '/'), 0)\nassert.equal(jsonpointer.get(example, '/a~1b'), 1)\nassert.equal(jsonpointer.get(example, '/c%d'), 2)\nassert.equal(jsonpointer.get(example, '/e^f'), 3)\nassert.equal(jsonpointer.get(example, '/g|h'), 4)\nassert.equal(jsonpointer.get(example, '/i\\\\j'), 5)\nassert.equal(jsonpointer.get(example, '/k\\'l'), 6)\nassert.equal(jsonpointer.get(example, '/ '), 7)\nassert.equal(jsonpointer.get(example, '/m~0n'), 8)\n\n// jsonpointer.compile(path)\nvar a = { foo: 'bar' }\nvar pointer = jsonpointer.compile('/foo')\nassert.equal(pointer.get(a), 'bar')\nassert.equal(pointer.set(a, 'test'), 'bar')\nassert.equal(pointer.get(a), 'test')\nassert.deepEqual(a, { foo: 'test' })\n\nvar b = {}\njsonpointer.set({}, '/constructor/prototype/boo', 'polluted')\nassert(!b.boo, 'should not boo')\n\nvar c = {}\njsonpointer.set({}, '/__proto__/boo', 'polluted')\nassert(!c.boo, 'should not boo')\n\nvar d = {}\njsonpointer.set({}, '/foo/__proto__/boo', 'polluted')\nassert(!d.boo, 'should not boo')\n\njsonpointer.set({}, '/foo/__proto__/__proto__/boo', 'polluted')\nassert(!d.boo, 'should not boo')\n\nvar e = {}\njsonpointer.set({}, '/foo/constructor/prototype/boo', 'polluted')\nassert(!e.boo, 'should not boo')\n\njsonpointer.set({}, '/foo/constructor/constructor/prototype/boo', 'polluted')\nassert(!e.boo, 'should not boo')\n\nassert.throws(function () { jsonpointer.set({}, [['__proto__'], 'boo'], 'polluted')}, validateError)\nassert.throws(function () { jsonpointer.set({}, [[['__proto__']], 'boo'], 'polluted')}, validateError)\nassert.throws(function () { jsonpointer.set({}, [['__proto__'], ['__proto__'], 'boo'], 'polluted')}, validateError)\nassert.throws(function () { jsonpointer.set({}, [[['__proto__']], [['__proto__']], 'boo'], 'polluted')}, validateError)\nassert.throws(function () { jsonpointer.set({}, [['__proto__'], ['__proto__'], ['__proto__'], 'boo'], 'polluted')}, validateError)\nassert.throws(function () { jsonpointer.set({}, [['foo'], ['__proto__'], 'boo'], 'polluted')}, validateError)\nassert.throws(function () { jsonpointer.set({}, [['foo'], ['__proto__'], ['__proto__'], 'boo'], 'polluted')}, validateError)\nassert.throws(function () { jsonpointer.set({}, [['constructor'], ['prototype'], 'boo'], 'polluted')}, validateError)\nassert.throws(function () { jsonpointer.set({}, [['constructor'], ['constructor'], ['prototype'], 'boo'], 'polluted')}, validateError)\n\nconsole.log('All tests pass.')\n"], "filenames": ["jsonpointer.js", "test.js"], "buggy_code_start_loc": [20, 138], "buggy_code_end_loc": [55, 138], "fixing_code_start_loc": [20, 139], "fixing_code_end_loc": [60, 163], "type": "CWE-843", "message": "This affects the package jsonpointer before 5.0.0. A type confusion vulnerability can lead to a bypass of a previous Prototype Pollution fix when the pointer components are arrays.", "other": {"cve": {"id": "CVE-2021-23807", "sourceIdentifier": "report@snyk.io", "published": "2021-11-03T18:15:08.230", "lastModified": "2021-11-05T18:08:28.487", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package jsonpointer before 5.0.0. A type confusion vulnerability can lead to a bypass of a previous Prototype Pollution fix when the pointer components are arrays."}, {"lang": "es", "value": "Esto afecta al paquete jsonpointer versiones anteriores a 5.0.0. Una vulnerabilidad de confusi\u00f3n de tipo puede conllevar a una omisi\u00f3n de una correcci\u00f3n anterior de Contaminaci\u00f3n de Prototipos cuando los componentes de los punteros son matrices"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-843"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jsonpointer_project:jsonpointer:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "5.0.0", "matchCriteriaId": "9BFA123B-3852-4DD3-B0CE-FB58D0523294"}]}]}], "references": [{"url": "https://github.com/janl/node-jsonpointer/commit/a0345f3550cd9c4d89f33b126390202b89510ad4", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/janl/node-jsonpointer/pull/51", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARSNPM-1910273", "source": "report@snyk.io", "tags": ["Exploit", "Mitigation", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://snyk.io/vuln/SNYK-JS-JSONPOINTER-1577288", "source": "report@snyk.io", "tags": ["Exploit", "Mitigation", "Patch", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/janl/node-jsonpointer/commit/a0345f3550cd9c4d89f33b126390202b89510ad4"}}