{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Management Component Transport Protocol (MCTP) - device implementation.\n *\n * Copyright (c) 2021 Code Construct\n * Copyright (c) 2021 Google\n */\n\n#include <linux/if_arp.h>\n#include <linux/if_link.h>\n#include <linux/mctp.h>\n#include <linux/netdevice.h>\n#include <linux/rcupdate.h>\n#include <linux/rtnetlink.h>\n\n#include <net/addrconf.h>\n#include <net/netlink.h>\n#include <net/mctp.h>\n#include <net/mctpdevice.h>\n#include <net/sock.h>\n\nstruct mctp_dump_cb {\n\tint h;\n\tint idx;\n\tsize_t a_idx;\n};\n\n/* unlocked: caller must hold rcu_read_lock.\n * Returned mctp_dev has its refcount incremented, or NULL if unset.\n */\nstruct mctp_dev *__mctp_dev_get(const struct net_device *dev)\n{\n\tstruct mctp_dev *mdev = rcu_dereference(dev->mctp_ptr);\n\n\t/* RCU guarantees that any mdev is still live.\n\t * Zero refcount implies a pending free, return NULL.\n\t */\n\tif (mdev)\n\t\tif (!refcount_inc_not_zero(&mdev->refs))\n\t\t\treturn NULL;\n\treturn mdev;\n}\n\n/* Returned mctp_dev does not have refcount incremented. The returned pointer\n * remains live while rtnl_lock is held, as that prevents mctp_unregister()\n */\nstruct mctp_dev *mctp_dev_get_rtnl(const struct net_device *dev)\n{\n\treturn rtnl_dereference(dev->mctp_ptr);\n}\n\nstatic int mctp_addrinfo_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ifaddrmsg))\n\t\t+ nla_total_size(1) // IFA_LOCAL\n\t\t+ nla_total_size(1) // IFA_ADDRESS\n\t\t;\n}\n\n/* flag should be NLM_F_MULTI for dump calls */\nstatic int mctp_fill_addrinfo(struct sk_buff *skb,\n\t\t\t      struct mctp_dev *mdev, mctp_eid_t eid,\n\t\t\t      int msg_type, u32 portid, u32 seq, int flag)\n{\n\tstruct ifaddrmsg *hdr;\n\tstruct nlmsghdr *nlh;\n\n\tnlh = nlmsg_put(skb, portid, seq,\n\t\t\tmsg_type, sizeof(*hdr), flag);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\thdr = nlmsg_data(nlh);\n\thdr->ifa_family = AF_MCTP;\n\thdr->ifa_prefixlen = 0;\n\thdr->ifa_flags = 0;\n\thdr->ifa_scope = 0;\n\thdr->ifa_index = mdev->dev->ifindex;\n\n\tif (nla_put_u8(skb, IFA_LOCAL, eid))\n\t\tgoto cancel;\n\n\tif (nla_put_u8(skb, IFA_ADDRESS, eid))\n\t\tgoto cancel;\n\n\tnlmsg_end(skb, nlh);\n\n\treturn 0;\n\ncancel:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int mctp_dump_dev_addrinfo(struct mctp_dev *mdev, struct sk_buff *skb,\n\t\t\t\t  struct netlink_callback *cb)\n{\n\tstruct mctp_dump_cb *mcb = (void *)cb->ctx;\n\tu32 portid, seq;\n\tint rc = 0;\n\n\tportid = NETLINK_CB(cb->skb).portid;\n\tseq = cb->nlh->nlmsg_seq;\n\tfor (; mcb->a_idx < mdev->num_addrs; mcb->a_idx++) {\n\t\trc = mctp_fill_addrinfo(skb, mdev, mdev->addrs[mcb->a_idx],\n\t\t\t\t\tRTM_NEWADDR, portid, seq, NLM_F_MULTI);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int mctp_dump_addrinfo(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct mctp_dump_cb *mcb = (void *)cb->ctx;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct hlist_head *head;\n\tstruct net_device *dev;\n\tstruct ifaddrmsg *hdr;\n\tstruct mctp_dev *mdev;\n\tint ifindex;\n\tint idx = 0, rc;\n\n\thdr = nlmsg_data(cb->nlh);\n\t// filter by ifindex if requested\n\tifindex = hdr->ifa_index;\n\n\trcu_read_lock();\n\tfor (; mcb->h < NETDEV_HASHENTRIES; mcb->h++, mcb->idx = 0) {\n\t\tidx = 0;\n\t\thead = &net->dev_index_head[mcb->h];\n\t\thlist_for_each_entry_rcu(dev, head, index_hlist) {\n\t\t\tif (idx >= mcb->idx &&\n\t\t\t    (ifindex == 0 || ifindex == dev->ifindex)) {\n\t\t\t\tmdev = __mctp_dev_get(dev);\n\t\t\t\tif (mdev) {\n\t\t\t\t\trc = mctp_dump_dev_addrinfo(mdev,\n\t\t\t\t\t\t\t\t    skb, cb);\n\t\t\t\t\tmctp_dev_put(mdev);\n\t\t\t\t\t// Error indicates full buffer, this\n\t\t\t\t\t// callback will get retried.\n\t\t\t\t\tif (rc < 0)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tidx++;\n\t\t\t// reset for next iteration\n\t\t\tmcb->a_idx = 0;\n\t\t}\n\t}\nout:\n\trcu_read_unlock();\n\tmcb->idx = idx;\n\n\treturn skb->len;\n}\n\nstatic void mctp_addr_notify(struct mctp_dev *mdev, mctp_eid_t eid, int msg_type,\n\t\t\t     struct sk_buff *req_skb, struct nlmsghdr *req_nlh)\n{\n\tu32 portid = NETLINK_CB(req_skb).portid;\n\tstruct net *net = dev_net(mdev->dev);\n\tstruct sk_buff *skb;\n\tint rc = -ENOBUFS;\n\n\tskb = nlmsg_new(mctp_addrinfo_size(), GFP_KERNEL);\n\tif (!skb)\n\t\tgoto out;\n\n\trc = mctp_fill_addrinfo(skb, mdev, eid, msg_type,\n\t\t\t\tportid, req_nlh->nlmsg_seq, 0);\n\tif (rc < 0) {\n\t\tWARN_ON_ONCE(rc == -EMSGSIZE);\n\t\tgoto out;\n\t}\n\n\trtnl_notify(skb, net, portid, RTNLGRP_MCTP_IFADDR, req_nlh, GFP_KERNEL);\n\treturn;\nout:\n\tkfree_skb(skb);\n\trtnl_set_sk_err(net, RTNLGRP_MCTP_IFADDR, rc);\n}\n\nstatic const struct nla_policy ifa_mctp_policy[IFA_MAX + 1] = {\n\t[IFA_ADDRESS]\t\t= { .type = NLA_U8 },\n\t[IFA_LOCAL]\t\t= { .type = NLA_U8 },\n};\n\nstatic int mctp_rtm_newaddr(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tb[IFA_MAX + 1];\n\tstruct net_device *dev;\n\tstruct mctp_addr *addr;\n\tstruct mctp_dev *mdev;\n\tstruct ifaddrmsg *ifm;\n\tunsigned long flags;\n\tu8 *tmp_addrs;\n\tint rc;\n\n\trc = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, ifa_mctp_policy,\n\t\t\t extack);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tifm = nlmsg_data(nlh);\n\n\tif (tb[IFA_LOCAL])\n\t\taddr = nla_data(tb[IFA_LOCAL]);\n\telse if (tb[IFA_ADDRESS])\n\t\taddr = nla_data(tb[IFA_ADDRESS]);\n\telse\n\t\treturn -EINVAL;\n\n\t/* find device */\n\tdev = __dev_get_by_index(net, ifm->ifa_index);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmdev = mctp_dev_get_rtnl(dev);\n\tif (!mdev)\n\t\treturn -ENODEV;\n\n\tif (!mctp_address_unicast(addr->s_addr))\n\t\treturn -EINVAL;\n\n\t/* Prevent duplicates. Under RTNL so don't need to lock for reading */\n\tif (memchr(mdev->addrs, addr->s_addr, mdev->num_addrs))\n\t\treturn -EEXIST;\n\n\ttmp_addrs = kmalloc(mdev->num_addrs + 1, GFP_KERNEL);\n\tif (!tmp_addrs)\n\t\treturn -ENOMEM;\n\tmemcpy(tmp_addrs, mdev->addrs, mdev->num_addrs);\n\ttmp_addrs[mdev->num_addrs] = addr->s_addr;\n\n\t/* Lock to write */\n\tspin_lock_irqsave(&mdev->addrs_lock, flags);\n\tmdev->num_addrs++;\n\tswap(mdev->addrs, tmp_addrs);\n\tspin_unlock_irqrestore(&mdev->addrs_lock, flags);\n\n\tkfree(tmp_addrs);\n\n\tmctp_addr_notify(mdev, addr->s_addr, RTM_NEWADDR, skb, nlh);\n\tmctp_route_add_local(mdev, addr->s_addr);\n\n\treturn 0;\n}\n\nstatic int mctp_rtm_deladdr(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tb[IFA_MAX + 1];\n\tstruct net_device *dev;\n\tstruct mctp_addr *addr;\n\tstruct mctp_dev *mdev;\n\tstruct ifaddrmsg *ifm;\n\tunsigned long flags;\n\tu8 *pos;\n\tint rc;\n\n\trc = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, ifa_mctp_policy,\n\t\t\t extack);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tifm = nlmsg_data(nlh);\n\n\tif (tb[IFA_LOCAL])\n\t\taddr = nla_data(tb[IFA_LOCAL]);\n\telse if (tb[IFA_ADDRESS])\n\t\taddr = nla_data(tb[IFA_ADDRESS]);\n\telse\n\t\treturn -EINVAL;\n\n\t/* find device */\n\tdev = __dev_get_by_index(net, ifm->ifa_index);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmdev = mctp_dev_get_rtnl(dev);\n\tif (!mdev)\n\t\treturn -ENODEV;\n\n\tpos = memchr(mdev->addrs, addr->s_addr, mdev->num_addrs);\n\tif (!pos)\n\t\treturn -ENOENT;\n\n\trc = mctp_route_remove_local(mdev, addr->s_addr);\n\t// we can ignore -ENOENT in the case a route was already removed\n\tif (rc < 0 && rc != -ENOENT)\n\t\treturn rc;\n\n\tspin_lock_irqsave(&mdev->addrs_lock, flags);\n\tmemmove(pos, pos + 1, mdev->num_addrs - 1 - (pos - mdev->addrs));\n\tmdev->num_addrs--;\n\tspin_unlock_irqrestore(&mdev->addrs_lock, flags);\n\n\tmctp_addr_notify(mdev, addr->s_addr, RTM_DELADDR, skb, nlh);\n\n\treturn 0;\n}\n\nvoid mctp_dev_hold(struct mctp_dev *mdev)\n{\n\trefcount_inc(&mdev->refs);\n}\n\nvoid mctp_dev_put(struct mctp_dev *mdev)\n{\n\tif (mdev && refcount_dec_and_test(&mdev->refs)) {\n\t\tdev_put(mdev->dev);\n\t\tkfree_rcu(mdev, rcu);\n\t}\n}\n\nvoid mctp_dev_release_key(struct mctp_dev *dev, struct mctp_sk_key *key)\n\t__must_hold(&key->lock)\n{\n\tif (!dev)\n\t\treturn;\n\tif (dev->ops && dev->ops->release_flow)\n\t\tdev->ops->release_flow(dev, key);\n\tkey->dev = NULL;\n\tmctp_dev_put(dev);\n}\n\nvoid mctp_dev_set_key(struct mctp_dev *dev, struct mctp_sk_key *key)\n\t__must_hold(&key->lock)\n{\n\tmctp_dev_hold(dev);\n\tkey->dev = dev;\n}\n\nstatic struct mctp_dev *mctp_add_dev(struct net_device *dev)\n{\n\tstruct mctp_dev *mdev;\n\n\tASSERT_RTNL();\n\n\tmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\n\tif (!mdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock_init(&mdev->addrs_lock);\n\n\tmdev->net = mctp_default_net(dev_net(dev));\n\n\t/* associate to net_device */\n\trefcount_set(&mdev->refs, 1);\n\trcu_assign_pointer(dev->mctp_ptr, mdev);\n\n\tdev_hold(dev);\n\tmdev->dev = dev;\n\n\treturn mdev;\n}\n\nstatic int mctp_fill_link_af(struct sk_buff *skb,\n\t\t\t     const struct net_device *dev, u32 ext_filter_mask)\n{\n\tstruct mctp_dev *mdev;\n\n\tmdev = mctp_dev_get_rtnl(dev);\n\tif (!mdev)\n\t\treturn -ENODATA;\n\tif (nla_put_u32(skb, IFLA_MCTP_NET, mdev->net))\n\t\treturn -EMSGSIZE;\n\treturn 0;\n}\n\nstatic size_t mctp_get_link_af_size(const struct net_device *dev,\n\t\t\t\t    u32 ext_filter_mask)\n{\n\tstruct mctp_dev *mdev;\n\tunsigned int ret;\n\n\t/* caller holds RCU */\n\tmdev = __mctp_dev_get(dev);\n\tif (!mdev)\n\t\treturn 0;\n\tret = nla_total_size(4); /* IFLA_MCTP_NET */\n\tmctp_dev_put(mdev);\n\treturn ret;\n}\n\nstatic const struct nla_policy ifla_af_mctp_policy[IFLA_MCTP_MAX + 1] = {\n\t[IFLA_MCTP_NET]\t\t= { .type = NLA_U32 },\n};\n\nstatic int mctp_set_link_af(struct net_device *dev, const struct nlattr *attr,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[IFLA_MCTP_MAX + 1];\n\tstruct mctp_dev *mdev;\n\tint rc;\n\n\trc = nla_parse_nested(tb, IFLA_MCTP_MAX, attr, ifla_af_mctp_policy,\n\t\t\t      NULL);\n\tif (rc)\n\t\treturn rc;\n\n\tmdev = mctp_dev_get_rtnl(dev);\n\tif (!mdev)\n\t\treturn 0;\n\n\tif (tb[IFLA_MCTP_NET])\n\t\tWRITE_ONCE(mdev->net, nla_get_u32(tb[IFLA_MCTP_NET]));\n\n\treturn 0;\n}\n\n/* Matches netdev types that should have MCTP handling */\nstatic bool mctp_known(struct net_device *dev)\n{\n\t/* only register specific types (inc. NONE for TUN devices) */\n\treturn dev->type == ARPHRD_MCTP ||\n\t\t   dev->type == ARPHRD_LOOPBACK ||\n\t\t   dev->type == ARPHRD_NONE;\n}\n\nstatic void mctp_unregister(struct net_device *dev)\n{\n\tstruct mctp_dev *mdev;\n\n\tmdev = mctp_dev_get_rtnl(dev);\n\tif (mdev && !mctp_known(dev)) {\n\t\t// Sanity check, should match what was set in mctp_register\n\t\tnetdev_warn(dev, \"%s: BUG mctp_ptr set for unknown type %d\",\n\t\t\t    __func__, dev->type);\n\t\treturn;\n\t}\n\tif (!mdev)\n\t\treturn;\n\n\tRCU_INIT_POINTER(mdev->dev->mctp_ptr, NULL);\n\n\tmctp_route_remove_dev(mdev);\n\tmctp_neigh_remove_dev(mdev);\n\tkfree(mdev->addrs);\n\n\tmctp_dev_put(mdev);\n}\n\nstatic int mctp_register(struct net_device *dev)\n{\n\tstruct mctp_dev *mdev;\n\n\t/* Already registered? */\n\tmdev = rtnl_dereference(dev->mctp_ptr);\n\n\tif (mdev) {\n\t\tif (!mctp_known(dev))\n\t\t\tnetdev_warn(dev, \"%s: BUG mctp_ptr set for unknown type %d\",\n\t\t\t\t    __func__, dev->type);\n\t\treturn 0;\n\t}\n\n\t/* only register specific types */\n\tif (!mctp_known(dev))\n\t\treturn 0;\n\n\tmdev = mctp_add_dev(dev);\n\tif (IS_ERR(mdev))\n\t\treturn PTR_ERR(mdev);\n\n\treturn 0;\n}\n\nstatic int mctp_dev_notify(struct notifier_block *this, unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tint rc;\n\n\tswitch (event) {\n\tcase NETDEV_REGISTER:\n\t\trc = mctp_register(dev);\n\t\tif (rc)\n\t\t\treturn notifier_from_errno(rc);\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\t\tmctp_unregister(dev);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic int mctp_register_netdevice(struct net_device *dev,\n\t\t\t\t   const struct mctp_netdev_ops *ops)\n{\n\tstruct mctp_dev *mdev;\n\n\tmdev = mctp_add_dev(dev);\n\tif (IS_ERR(mdev))\n\t\treturn PTR_ERR(mdev);\n\n\tmdev->ops = ops;\n\n\treturn register_netdevice(dev);\n}\n\nint mctp_register_netdev(struct net_device *dev,\n\t\t\t const struct mctp_netdev_ops *ops)\n{\n\tint rc;\n\n\trtnl_lock();\n\trc = mctp_register_netdevice(dev, ops);\n\trtnl_unlock();\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(mctp_register_netdev);\n\nvoid mctp_unregister_netdev(struct net_device *dev)\n{\n\tunregister_netdev(dev);\n}\nEXPORT_SYMBOL_GPL(mctp_unregister_netdev);\n\nstatic struct rtnl_af_ops mctp_af_ops = {\n\t.family = AF_MCTP,\n\t.fill_link_af = mctp_fill_link_af,\n\t.get_link_af_size = mctp_get_link_af_size,\n\t.set_link_af = mctp_set_link_af,\n};\n\nstatic struct notifier_block mctp_dev_nb = {\n\t.notifier_call = mctp_dev_notify,\n\t.priority = ADDRCONF_NOTIFY_PRIORITY,\n};\n\nvoid __init mctp_device_init(void)\n{\n\tregister_netdevice_notifier(&mctp_dev_nb);\n\n\trtnl_register_module(THIS_MODULE, PF_MCTP, RTM_GETADDR,\n\t\t\t     NULL, mctp_dump_addrinfo, 0);\n\trtnl_register_module(THIS_MODULE, PF_MCTP, RTM_NEWADDR,\n\t\t\t     mctp_rtm_newaddr, NULL, 0);\n\trtnl_register_module(THIS_MODULE, PF_MCTP, RTM_DELADDR,\n\t\t\t     mctp_rtm_deladdr, NULL, 0);\n\trtnl_af_register(&mctp_af_ops);\n}\n\nvoid __exit mctp_device_exit(void)\n{\n\trtnl_af_unregister(&mctp_af_ops);\n\trtnl_unregister(PF_MCTP, RTM_DELADDR);\n\trtnl_unregister(PF_MCTP, RTM_NEWADDR);\n\trtnl_unregister(PF_MCTP, RTM_GETADDR);\n\n\tunregister_netdevice_notifier(&mctp_dev_nb);\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Management Component Transport Protocol (MCTP) - device implementation.\n *\n * Copyright (c) 2021 Code Construct\n * Copyright (c) 2021 Google\n */\n\n#include <linux/if_arp.h>\n#include <linux/if_link.h>\n#include <linux/mctp.h>\n#include <linux/netdevice.h>\n#include <linux/rcupdate.h>\n#include <linux/rtnetlink.h>\n\n#include <net/addrconf.h>\n#include <net/netlink.h>\n#include <net/mctp.h>\n#include <net/mctpdevice.h>\n#include <net/sock.h>\n\nstruct mctp_dump_cb {\n\tint h;\n\tint idx;\n\tsize_t a_idx;\n};\n\n/* unlocked: caller must hold rcu_read_lock.\n * Returned mctp_dev has its refcount incremented, or NULL if unset.\n */\nstruct mctp_dev *__mctp_dev_get(const struct net_device *dev)\n{\n\tstruct mctp_dev *mdev = rcu_dereference(dev->mctp_ptr);\n\n\t/* RCU guarantees that any mdev is still live.\n\t * Zero refcount implies a pending free, return NULL.\n\t */\n\tif (mdev)\n\t\tif (!refcount_inc_not_zero(&mdev->refs))\n\t\t\treturn NULL;\n\treturn mdev;\n}\n\n/* Returned mctp_dev does not have refcount incremented. The returned pointer\n * remains live while rtnl_lock is held, as that prevents mctp_unregister()\n */\nstruct mctp_dev *mctp_dev_get_rtnl(const struct net_device *dev)\n{\n\treturn rtnl_dereference(dev->mctp_ptr);\n}\n\nstatic int mctp_addrinfo_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ifaddrmsg))\n\t\t+ nla_total_size(1) // IFA_LOCAL\n\t\t+ nla_total_size(1) // IFA_ADDRESS\n\t\t;\n}\n\n/* flag should be NLM_F_MULTI for dump calls */\nstatic int mctp_fill_addrinfo(struct sk_buff *skb,\n\t\t\t      struct mctp_dev *mdev, mctp_eid_t eid,\n\t\t\t      int msg_type, u32 portid, u32 seq, int flag)\n{\n\tstruct ifaddrmsg *hdr;\n\tstruct nlmsghdr *nlh;\n\n\tnlh = nlmsg_put(skb, portid, seq,\n\t\t\tmsg_type, sizeof(*hdr), flag);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\thdr = nlmsg_data(nlh);\n\thdr->ifa_family = AF_MCTP;\n\thdr->ifa_prefixlen = 0;\n\thdr->ifa_flags = 0;\n\thdr->ifa_scope = 0;\n\thdr->ifa_index = mdev->dev->ifindex;\n\n\tif (nla_put_u8(skb, IFA_LOCAL, eid))\n\t\tgoto cancel;\n\n\tif (nla_put_u8(skb, IFA_ADDRESS, eid))\n\t\tgoto cancel;\n\n\tnlmsg_end(skb, nlh);\n\n\treturn 0;\n\ncancel:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int mctp_dump_dev_addrinfo(struct mctp_dev *mdev, struct sk_buff *skb,\n\t\t\t\t  struct netlink_callback *cb)\n{\n\tstruct mctp_dump_cb *mcb = (void *)cb->ctx;\n\tu32 portid, seq;\n\tint rc = 0;\n\n\tportid = NETLINK_CB(cb->skb).portid;\n\tseq = cb->nlh->nlmsg_seq;\n\tfor (; mcb->a_idx < mdev->num_addrs; mcb->a_idx++) {\n\t\trc = mctp_fill_addrinfo(skb, mdev, mdev->addrs[mcb->a_idx],\n\t\t\t\t\tRTM_NEWADDR, portid, seq, NLM_F_MULTI);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int mctp_dump_addrinfo(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct mctp_dump_cb *mcb = (void *)cb->ctx;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct hlist_head *head;\n\tstruct net_device *dev;\n\tstruct ifaddrmsg *hdr;\n\tstruct mctp_dev *mdev;\n\tint ifindex;\n\tint idx = 0, rc;\n\n\thdr = nlmsg_data(cb->nlh);\n\t// filter by ifindex if requested\n\tifindex = hdr->ifa_index;\n\n\trcu_read_lock();\n\tfor (; mcb->h < NETDEV_HASHENTRIES; mcb->h++, mcb->idx = 0) {\n\t\tidx = 0;\n\t\thead = &net->dev_index_head[mcb->h];\n\t\thlist_for_each_entry_rcu(dev, head, index_hlist) {\n\t\t\tif (idx >= mcb->idx &&\n\t\t\t    (ifindex == 0 || ifindex == dev->ifindex)) {\n\t\t\t\tmdev = __mctp_dev_get(dev);\n\t\t\t\tif (mdev) {\n\t\t\t\t\trc = mctp_dump_dev_addrinfo(mdev,\n\t\t\t\t\t\t\t\t    skb, cb);\n\t\t\t\t\tmctp_dev_put(mdev);\n\t\t\t\t\t// Error indicates full buffer, this\n\t\t\t\t\t// callback will get retried.\n\t\t\t\t\tif (rc < 0)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tidx++;\n\t\t\t// reset for next iteration\n\t\t\tmcb->a_idx = 0;\n\t\t}\n\t}\nout:\n\trcu_read_unlock();\n\tmcb->idx = idx;\n\n\treturn skb->len;\n}\n\nstatic void mctp_addr_notify(struct mctp_dev *mdev, mctp_eid_t eid, int msg_type,\n\t\t\t     struct sk_buff *req_skb, struct nlmsghdr *req_nlh)\n{\n\tu32 portid = NETLINK_CB(req_skb).portid;\n\tstruct net *net = dev_net(mdev->dev);\n\tstruct sk_buff *skb;\n\tint rc = -ENOBUFS;\n\n\tskb = nlmsg_new(mctp_addrinfo_size(), GFP_KERNEL);\n\tif (!skb)\n\t\tgoto out;\n\n\trc = mctp_fill_addrinfo(skb, mdev, eid, msg_type,\n\t\t\t\tportid, req_nlh->nlmsg_seq, 0);\n\tif (rc < 0) {\n\t\tWARN_ON_ONCE(rc == -EMSGSIZE);\n\t\tgoto out;\n\t}\n\n\trtnl_notify(skb, net, portid, RTNLGRP_MCTP_IFADDR, req_nlh, GFP_KERNEL);\n\treturn;\nout:\n\tkfree_skb(skb);\n\trtnl_set_sk_err(net, RTNLGRP_MCTP_IFADDR, rc);\n}\n\nstatic const struct nla_policy ifa_mctp_policy[IFA_MAX + 1] = {\n\t[IFA_ADDRESS]\t\t= { .type = NLA_U8 },\n\t[IFA_LOCAL]\t\t= { .type = NLA_U8 },\n};\n\nstatic int mctp_rtm_newaddr(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tb[IFA_MAX + 1];\n\tstruct net_device *dev;\n\tstruct mctp_addr *addr;\n\tstruct mctp_dev *mdev;\n\tstruct ifaddrmsg *ifm;\n\tunsigned long flags;\n\tu8 *tmp_addrs;\n\tint rc;\n\n\trc = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, ifa_mctp_policy,\n\t\t\t extack);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tifm = nlmsg_data(nlh);\n\n\tif (tb[IFA_LOCAL])\n\t\taddr = nla_data(tb[IFA_LOCAL]);\n\telse if (tb[IFA_ADDRESS])\n\t\taddr = nla_data(tb[IFA_ADDRESS]);\n\telse\n\t\treturn -EINVAL;\n\n\t/* find device */\n\tdev = __dev_get_by_index(net, ifm->ifa_index);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmdev = mctp_dev_get_rtnl(dev);\n\tif (!mdev)\n\t\treturn -ENODEV;\n\n\tif (!mctp_address_unicast(addr->s_addr))\n\t\treturn -EINVAL;\n\n\t/* Prevent duplicates. Under RTNL so don't need to lock for reading */\n\tif (memchr(mdev->addrs, addr->s_addr, mdev->num_addrs))\n\t\treturn -EEXIST;\n\n\ttmp_addrs = kmalloc(mdev->num_addrs + 1, GFP_KERNEL);\n\tif (!tmp_addrs)\n\t\treturn -ENOMEM;\n\tmemcpy(tmp_addrs, mdev->addrs, mdev->num_addrs);\n\ttmp_addrs[mdev->num_addrs] = addr->s_addr;\n\n\t/* Lock to write */\n\tspin_lock_irqsave(&mdev->addrs_lock, flags);\n\tmdev->num_addrs++;\n\tswap(mdev->addrs, tmp_addrs);\n\tspin_unlock_irqrestore(&mdev->addrs_lock, flags);\n\n\tkfree(tmp_addrs);\n\n\tmctp_addr_notify(mdev, addr->s_addr, RTM_NEWADDR, skb, nlh);\n\tmctp_route_add_local(mdev, addr->s_addr);\n\n\treturn 0;\n}\n\nstatic int mctp_rtm_deladdr(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tb[IFA_MAX + 1];\n\tstruct net_device *dev;\n\tstruct mctp_addr *addr;\n\tstruct mctp_dev *mdev;\n\tstruct ifaddrmsg *ifm;\n\tunsigned long flags;\n\tu8 *pos;\n\tint rc;\n\n\trc = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, ifa_mctp_policy,\n\t\t\t extack);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tifm = nlmsg_data(nlh);\n\n\tif (tb[IFA_LOCAL])\n\t\taddr = nla_data(tb[IFA_LOCAL]);\n\telse if (tb[IFA_ADDRESS])\n\t\taddr = nla_data(tb[IFA_ADDRESS]);\n\telse\n\t\treturn -EINVAL;\n\n\t/* find device */\n\tdev = __dev_get_by_index(net, ifm->ifa_index);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmdev = mctp_dev_get_rtnl(dev);\n\tif (!mdev)\n\t\treturn -ENODEV;\n\n\tpos = memchr(mdev->addrs, addr->s_addr, mdev->num_addrs);\n\tif (!pos)\n\t\treturn -ENOENT;\n\n\trc = mctp_route_remove_local(mdev, addr->s_addr);\n\t// we can ignore -ENOENT in the case a route was already removed\n\tif (rc < 0 && rc != -ENOENT)\n\t\treturn rc;\n\n\tspin_lock_irqsave(&mdev->addrs_lock, flags);\n\tmemmove(pos, pos + 1, mdev->num_addrs - 1 - (pos - mdev->addrs));\n\tmdev->num_addrs--;\n\tspin_unlock_irqrestore(&mdev->addrs_lock, flags);\n\n\tmctp_addr_notify(mdev, addr->s_addr, RTM_DELADDR, skb, nlh);\n\n\treturn 0;\n}\n\nvoid mctp_dev_hold(struct mctp_dev *mdev)\n{\n\trefcount_inc(&mdev->refs);\n}\n\nvoid mctp_dev_put(struct mctp_dev *mdev)\n{\n\tif (mdev && refcount_dec_and_test(&mdev->refs)) {\n\t\tkfree(mdev->addrs);\n\t\tdev_put(mdev->dev);\n\t\tkfree_rcu(mdev, rcu);\n\t}\n}\n\nvoid mctp_dev_release_key(struct mctp_dev *dev, struct mctp_sk_key *key)\n\t__must_hold(&key->lock)\n{\n\tif (!dev)\n\t\treturn;\n\tif (dev->ops && dev->ops->release_flow)\n\t\tdev->ops->release_flow(dev, key);\n\tkey->dev = NULL;\n\tmctp_dev_put(dev);\n}\n\nvoid mctp_dev_set_key(struct mctp_dev *dev, struct mctp_sk_key *key)\n\t__must_hold(&key->lock)\n{\n\tmctp_dev_hold(dev);\n\tkey->dev = dev;\n}\n\nstatic struct mctp_dev *mctp_add_dev(struct net_device *dev)\n{\n\tstruct mctp_dev *mdev;\n\n\tASSERT_RTNL();\n\n\tmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\n\tif (!mdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock_init(&mdev->addrs_lock);\n\n\tmdev->net = mctp_default_net(dev_net(dev));\n\n\t/* associate to net_device */\n\trefcount_set(&mdev->refs, 1);\n\trcu_assign_pointer(dev->mctp_ptr, mdev);\n\n\tdev_hold(dev);\n\tmdev->dev = dev;\n\n\treturn mdev;\n}\n\nstatic int mctp_fill_link_af(struct sk_buff *skb,\n\t\t\t     const struct net_device *dev, u32 ext_filter_mask)\n{\n\tstruct mctp_dev *mdev;\n\n\tmdev = mctp_dev_get_rtnl(dev);\n\tif (!mdev)\n\t\treturn -ENODATA;\n\tif (nla_put_u32(skb, IFLA_MCTP_NET, mdev->net))\n\t\treturn -EMSGSIZE;\n\treturn 0;\n}\n\nstatic size_t mctp_get_link_af_size(const struct net_device *dev,\n\t\t\t\t    u32 ext_filter_mask)\n{\n\tstruct mctp_dev *mdev;\n\tunsigned int ret;\n\n\t/* caller holds RCU */\n\tmdev = __mctp_dev_get(dev);\n\tif (!mdev)\n\t\treturn 0;\n\tret = nla_total_size(4); /* IFLA_MCTP_NET */\n\tmctp_dev_put(mdev);\n\treturn ret;\n}\n\nstatic const struct nla_policy ifla_af_mctp_policy[IFLA_MCTP_MAX + 1] = {\n\t[IFLA_MCTP_NET]\t\t= { .type = NLA_U32 },\n};\n\nstatic int mctp_set_link_af(struct net_device *dev, const struct nlattr *attr,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[IFLA_MCTP_MAX + 1];\n\tstruct mctp_dev *mdev;\n\tint rc;\n\n\trc = nla_parse_nested(tb, IFLA_MCTP_MAX, attr, ifla_af_mctp_policy,\n\t\t\t      NULL);\n\tif (rc)\n\t\treturn rc;\n\n\tmdev = mctp_dev_get_rtnl(dev);\n\tif (!mdev)\n\t\treturn 0;\n\n\tif (tb[IFLA_MCTP_NET])\n\t\tWRITE_ONCE(mdev->net, nla_get_u32(tb[IFLA_MCTP_NET]));\n\n\treturn 0;\n}\n\n/* Matches netdev types that should have MCTP handling */\nstatic bool mctp_known(struct net_device *dev)\n{\n\t/* only register specific types (inc. NONE for TUN devices) */\n\treturn dev->type == ARPHRD_MCTP ||\n\t\t   dev->type == ARPHRD_LOOPBACK ||\n\t\t   dev->type == ARPHRD_NONE;\n}\n\nstatic void mctp_unregister(struct net_device *dev)\n{\n\tstruct mctp_dev *mdev;\n\n\tmdev = mctp_dev_get_rtnl(dev);\n\tif (mdev && !mctp_known(dev)) {\n\t\t// Sanity check, should match what was set in mctp_register\n\t\tnetdev_warn(dev, \"%s: BUG mctp_ptr set for unknown type %d\",\n\t\t\t    __func__, dev->type);\n\t\treturn;\n\t}\n\tif (!mdev)\n\t\treturn;\n\n\tRCU_INIT_POINTER(mdev->dev->mctp_ptr, NULL);\n\n\tmctp_route_remove_dev(mdev);\n\tmctp_neigh_remove_dev(mdev);\n\n\tmctp_dev_put(mdev);\n}\n\nstatic int mctp_register(struct net_device *dev)\n{\n\tstruct mctp_dev *mdev;\n\n\t/* Already registered? */\n\tmdev = rtnl_dereference(dev->mctp_ptr);\n\n\tif (mdev) {\n\t\tif (!mctp_known(dev))\n\t\t\tnetdev_warn(dev, \"%s: BUG mctp_ptr set for unknown type %d\",\n\t\t\t\t    __func__, dev->type);\n\t\treturn 0;\n\t}\n\n\t/* only register specific types */\n\tif (!mctp_known(dev))\n\t\treturn 0;\n\n\tmdev = mctp_add_dev(dev);\n\tif (IS_ERR(mdev))\n\t\treturn PTR_ERR(mdev);\n\n\treturn 0;\n}\n\nstatic int mctp_dev_notify(struct notifier_block *this, unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tint rc;\n\n\tswitch (event) {\n\tcase NETDEV_REGISTER:\n\t\trc = mctp_register(dev);\n\t\tif (rc)\n\t\t\treturn notifier_from_errno(rc);\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\t\tmctp_unregister(dev);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic int mctp_register_netdevice(struct net_device *dev,\n\t\t\t\t   const struct mctp_netdev_ops *ops)\n{\n\tstruct mctp_dev *mdev;\n\n\tmdev = mctp_add_dev(dev);\n\tif (IS_ERR(mdev))\n\t\treturn PTR_ERR(mdev);\n\n\tmdev->ops = ops;\n\n\treturn register_netdevice(dev);\n}\n\nint mctp_register_netdev(struct net_device *dev,\n\t\t\t const struct mctp_netdev_ops *ops)\n{\n\tint rc;\n\n\trtnl_lock();\n\trc = mctp_register_netdevice(dev, ops);\n\trtnl_unlock();\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(mctp_register_netdev);\n\nvoid mctp_unregister_netdev(struct net_device *dev)\n{\n\tunregister_netdev(dev);\n}\nEXPORT_SYMBOL_GPL(mctp_unregister_netdev);\n\nstatic struct rtnl_af_ops mctp_af_ops = {\n\t.family = AF_MCTP,\n\t.fill_link_af = mctp_fill_link_af,\n\t.get_link_af_size = mctp_get_link_af_size,\n\t.set_link_af = mctp_set_link_af,\n};\n\nstatic struct notifier_block mctp_dev_nb = {\n\t.notifier_call = mctp_dev_notify,\n\t.priority = ADDRCONF_NOTIFY_PRIORITY,\n};\n\nvoid __init mctp_device_init(void)\n{\n\tregister_netdevice_notifier(&mctp_dev_nb);\n\n\trtnl_register_module(THIS_MODULE, PF_MCTP, RTM_GETADDR,\n\t\t\t     NULL, mctp_dump_addrinfo, 0);\n\trtnl_register_module(THIS_MODULE, PF_MCTP, RTM_NEWADDR,\n\t\t\t     mctp_rtm_newaddr, NULL, 0);\n\trtnl_register_module(THIS_MODULE, PF_MCTP, RTM_DELADDR,\n\t\t\t     mctp_rtm_deladdr, NULL, 0);\n\trtnl_af_register(&mctp_af_ops);\n}\n\nvoid __exit mctp_device_exit(void)\n{\n\trtnl_af_unregister(&mctp_af_ops);\n\trtnl_unregister(PF_MCTP, RTM_DELADDR);\n\trtnl_unregister(PF_MCTP, RTM_NEWADDR);\n\trtnl_unregister(PF_MCTP, RTM_GETADDR);\n\n\tunregister_netdevice_notifier(&mctp_dev_nb);\n}\n"], "filenames": ["net/mctp/device.c"], "buggy_code_start_loc": [315], "buggy_code_end_loc": [445], "fixing_code_start_loc": [316], "fixing_code_end_loc": [444], "type": "CWE-416", "message": "A flaw was found in the MCTP protocol in the Linux kernel. The function mctp_unregister() reclaims the device's relevant resource when a netcard detaches. However, a running routine may be unaware of this and cause the use-after-free of the mdev->addrs object, potentially leading to a denial of service.", "other": {"cve": {"id": "CVE-2023-3439", "sourceIdentifier": "patrick@puiterwijk.org", "published": "2023-06-28T21:15:10.517", "lastModified": "2023-07-06T21:39:33.310", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in the MCTP protocol in the Linux kernel. The function mctp_unregister() reclaims the device's relevant resource when a netcard detaches. However, a running routine may be unaware of this and cause the use-after-free of the mdev->addrs object, potentially leading to a denial of service."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "patrick@puiterwijk.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.18", "matchCriteriaId": "FE93544F-B946-47CF-9697-FBF3484FCB92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.18:rc1:*:*:*:*:*:*", "matchCriteriaId": "6AD94161-84BB-42E6-9882-4FC0C42E9FC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.18:rc2:*:*:*:*:*:*", "matchCriteriaId": "7AB06DDF-3C2B-416D-B448-E990D8FF67A9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.18:rc3:*:*:*:*:*:*", "matchCriteriaId": "EAE6C6C5-4D21-4C04-897C-70CBBB3D7B91"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.18:rc4:*:*:*:*:*:*", "matchCriteriaId": "DA5F085D-52F3-4EE2-8353-455D1A6FE073"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2023/07/02/1", "source": "patrick@puiterwijk.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2217915", "source": "patrick@puiterwijk.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/b561275d633bcd8e0e8055ab86f1a13df75a0269", "source": "patrick@puiterwijk.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/b561275d633bcd8e0e8055ab86f1a13df75a0269"}}