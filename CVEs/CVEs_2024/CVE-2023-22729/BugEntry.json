{"buggy_code": ["<?php\n\nnamespace SilverStripe\\Control;\n\nuse SilverStripe\\CMS\\Model\\SiteTree;\nuse SilverStripe\\Control\\Middleware\\CanonicalURLMiddleware;\nuse SilverStripe\\Control\\Middleware\\HTTPMiddlewareAware;\nuse SilverStripe\\Core\\Config\\Configurable;\nuse SilverStripe\\Core\\Environment;\nuse SilverStripe\\Core\\Extensible;\nuse SilverStripe\\Core\\Injector\\Injectable;\nuse SilverStripe\\Core\\Injector\\Injector;\nuse SilverStripe\\Core\\Kernel;\nuse SilverStripe\\Core\\Path;\nuse SilverStripe\\Dev\\Deprecation;\nuse SilverStripe\\Versioned\\Versioned;\nuse SilverStripe\\View\\Requirements;\nuse SilverStripe\\View\\Requirements_Backend;\nuse SilverStripe\\View\\TemplateGlobalProvider;\n\n/**\n * Director is responsible for processing URLs, and providing environment information.\n *\n * The most important part of director is {@link Director::handleRequest()}, which is passed an HTTPRequest and will\n * execute the appropriate controller.\n *\n * @see Director::handleRequest()\n * @see Director::$rules\n * @skipUpgrade\n */\nclass Director implements TemplateGlobalProvider\n{\n    use Configurable;\n    use Extensible;\n    use Injectable;\n    use HTTPMiddlewareAware;\n\n    /**\n     * Specifies this url is relative to the base.\n     *\n     * @var string\n     */\n    const BASE = 'BASE';\n\n    /**\n     * Specifies this url is relative to the site root.\n     *\n     * @var string\n     */\n    const ROOT = 'ROOT';\n\n    /**\n     * specifies this url is relative to the current request.\n     *\n     * @var string\n     */\n    const REQUEST = 'REQUEST';\n\n    /**\n     * @config\n     * @var array\n     */\n    private static $rules = [];\n\n    /**\n     * Set current page\n     *\n     * @internal\n     * @var SiteTree\n     */\n    private static $current_page;\n\n    /**\n     * @config\n     * @var string\n     */\n    private static $alternate_base_folder;\n\n    /**\n     * Override PUBLIC_DIR. Set to a non-null value to override.\n     * Setting to an empty string will disable public dir.\n     *\n     * @config\n     * @var bool|null\n     */\n    private static $alternate_public_dir = null;\n\n    /**\n     * Base url to populate if cannot be determined otherwise.\n     * Supports back-ticked vars; E.g. '`SS_BASE_URL`'\n     *\n     * @config\n     * @var string\n     */\n    private static $default_base_url = '`SS_BASE_URL`';\n\n    public function __construct()\n    {\n    }\n\n    /**\n     * Test a URL request, returning a response object. This method is a wrapper around\n     * Director::handleRequest() to assist with functional testing. It will execute the URL given, and\n     * return the result as an HTTPResponse object.\n     *\n     * @param string $url The URL to visit.\n     * @param array $postVars The $_POST & $_FILES variables.\n     * @param array|Session $session The {@link Session} object representing the current session.\n     * By passing the same object to multiple  calls of Director::test(), you can simulate a persisted\n     * session.\n     * @param string $httpMethod The HTTP method, such as GET or POST.  It will default to POST if\n     * postVars is set, GET otherwise. Overwritten by $postVars['_method'] if present.\n     * @param string $body The HTTP body.\n     * @param array $headers HTTP headers with key-value pairs.\n     * @param array|Cookie_Backend $cookies to populate $_COOKIE.\n     * @param HTTPRequest $request The {@see SS_HTTP_Request} object generated as a part of this request.\n     *\n     * @return HTTPResponse\n     *\n     * @throws HTTPResponse_Exception\n     */\n    public static function test(\n        $url,\n        $postVars = [],\n        $session = [],\n        $httpMethod = null,\n        $body = null,\n        $headers = [],\n        $cookies = [],\n        &$request = null\n    ) {\n        return static::mockRequest(\n            function (HTTPRequest $request) {\n                return Director::singleton()->handleRequest($request);\n            },\n            $url,\n            $postVars,\n            $session,\n            $httpMethod,\n            $body,\n            $headers,\n            $cookies,\n            $request\n        );\n    }\n\n    /**\n     * Mock a request, passing this to the given callback, before resetting.\n     *\n     * @param callable $callback Action to pass the HTTPRequst object\n     * @param string $url The URL to build\n     * @param array $postVars The $_POST & $_FILES variables.\n     * @param array|Session $session The {@link Session} object representing the current session.\n     * By passing the same object to multiple  calls of Director::test(), you can simulate a persisted\n     * session.\n     * @param string $httpMethod The HTTP method, such as GET or POST.  It will default to POST if\n     * postVars is set, GET otherwise. Overwritten by $postVars['_method'] if present.\n     * @param string $body The HTTP body.\n     * @param array $headers HTTP headers with key-value pairs.\n     * @param array|Cookie_Backend $cookies to populate $_COOKIE.\n     * @param HTTPRequest $request The {@see SS_HTTP_Request} object generated as a part of this request.\n     * @return mixed Result of callback\n     */\n    public static function mockRequest(\n        $callback,\n        $url,\n        $postVars = [],\n        $session = [],\n        $httpMethod = null,\n        $body = null,\n        $headers = [],\n        $cookies = [],\n        &$request = null\n    ) {\n        // Build list of cleanup promises\n        $finally = [];\n\n        /** @var Kernel $kernel */\n        $kernel = Injector::inst()->get(Kernel::class);\n        $kernel->nest();\n        $finally[] = function () use ($kernel) {\n            $kernel->activate();\n        };\n\n        // backup existing vars, and create new vars\n        $existingVars = Environment::getVariables();\n        $finally[] = function () use ($existingVars) {\n            Environment::setVariables($existingVars);\n        };\n        $newVars = $existingVars;\n\n        // These are needed so that calling Director::test() does not muck with whoever is calling it.\n        // Really, it's some inappropriate coupling and should be resolved by making less use of statics.\n        if (class_exists(Versioned::class)) {\n            $oldReadingMode = Versioned::get_reading_mode();\n            $finally[] = function () use ($oldReadingMode) {\n                Versioned::set_reading_mode($oldReadingMode);\n            };\n        }\n\n        // Default httpMethod\n        $newVars['_SERVER']['REQUEST_METHOD'] = $httpMethod ?: ($postVars ? \"POST\" : \"GET\");\n        $newVars['_POST'] = (array)$postVars;\n\n        // Setup session\n        if ($session instanceof Session) {\n            // Note: If passing $session as object, ensure that changes are written back\n            // This is important for classes such as FunctionalTest which emulate cross-request persistence\n            $newVars['_SESSION'] = $sessionArray = $session->getAll() ?: [];\n            $finally[] = function () use ($session, $sessionArray) {\n                if (isset($_SESSION)) {\n                    // Set new / updated keys\n                    foreach ($_SESSION as $key => $value) {\n                        $session->set($key, $value);\n                    }\n                    // Unset removed keys\n                    foreach (array_diff_key($sessionArray ?? [], $_SESSION) as $key => $value) {\n                        $session->clear($key);\n                    }\n                }\n            };\n        } else {\n            $newVars['_SESSION'] = $session ?: [];\n        }\n\n        // Setup cookies\n        $cookieJar = $cookies instanceof Cookie_Backend\n            ? $cookies\n            : Injector::inst()->createWithArgs(Cookie_Backend::class, [$cookies ?: []]);\n        $newVars['_COOKIE'] = $cookieJar->getAll(false);\n        Cookie::config()->update('report_errors', false);\n        Injector::inst()->registerService($cookieJar, Cookie_Backend::class);\n\n        // Backup requirements\n        $existingRequirementsBackend = Requirements::backend();\n        Requirements::set_backend(Requirements_Backend::create());\n        $finally[] = function () use ($existingRequirementsBackend) {\n            Requirements::set_backend($existingRequirementsBackend);\n        };\n\n        // Strip any hash\n        $url = strtok($url ?? '', '#');\n\n        // Handle absolute URLs\n        // If a port is mentioned in the absolute URL, be sure to add that into the HTTP host\n        $urlHostPort = static::parseHost($url);\n        if ($urlHostPort) {\n            $newVars['_SERVER']['HTTP_HOST'] = $urlHostPort;\n        }\n\n        // Ensure URL is properly made relative.\n        // Example: url passed is \"/ss31/my-page\" (prefixed with BASE_URL), this should be changed to \"my-page\"\n        $url = self::makeRelative($url);\n        if (strpos($url ?? '', '?') !== false) {\n            list($url, $getVarsEncoded) = explode('?', $url ?? '', 2);\n            parse_str($getVarsEncoded ?? '', $newVars['_GET']);\n        } else {\n            $newVars['_GET'] = [];\n        }\n        $newVars['_SERVER']['REQUEST_URI'] = Director::baseURL() . ltrim($url ?? '', '/');\n        $newVars['_REQUEST'] = array_merge($newVars['_GET'], $newVars['_POST']);\n\n        // Normalise vars\n        $newVars = HTTPRequestBuilder::cleanEnvironment($newVars);\n\n        // Create new request\n        $request = HTTPRequestBuilder::createFromVariables($newVars, $body, ltrim($url ?? '', '/'));\n        if ($headers) {\n            foreach ($headers as $k => $v) {\n                $request->addHeader($k, $v);\n            }\n        }\n\n        // Apply new vars to environment\n        Environment::setVariables($newVars);\n\n        try {\n            // Normal request handling\n            return call_user_func($callback, $request);\n        } finally {\n            // Restore state in reverse order to assignment\n            foreach (array_reverse($finally) as $callback) {\n                call_user_func($callback);\n            }\n        }\n    }\n\n    /**\n     * Process the given URL, creating the appropriate controller and executing it.\n     *\n     * Request processing is handled as follows:\n     * - Director::handleRequest($request) checks each of the Director rules and identifies a controller\n     *   to handle this request.\n     * - Controller::handleRequest($request) is then called.  This will find a rule to handle the URL,\n     *   and call the rule handling method.\n     * - RequestHandler::handleRequest($request) is recursively called whenever a rule handling method\n     *   returns a RequestHandler object.\n     *\n     * In addition to request processing, Director will manage the session, and perform the output of\n     * the actual response to the browser.\n     *\n     * @param HTTPRequest $request\n     * @return HTTPResponse\n     * @throws HTTPResponse_Exception\n     */\n    public function handleRequest(HTTPRequest $request)\n    {\n        Injector::inst()->registerService($request, HTTPRequest::class);\n\n        $rules = Director::config()->uninherited('rules');\n\n        $this->extend('updateRules', $rules);\n\n        // Default handler - mo URL rules matched, so return a 404 error.\n        $handler = function () {\n            return new HTTPResponse('No URL rule was matched', 404);\n        };\n\n        foreach ($rules as $pattern => $controllerOptions) {\n            // Match pattern\n            $arguments = $request->match($pattern, true);\n            if ($arguments == false) {\n                continue;\n            }\n\n            // Normalise route rule\n            if (is_string($controllerOptions)) {\n                if (substr($controllerOptions ?? '', 0, 2) == '->') {\n                    $controllerOptions = ['Redirect' => substr($controllerOptions ?? '', 2)];\n                } else {\n                    $controllerOptions = ['Controller' => $controllerOptions];\n                }\n            }\n            $request->setRouteParams($controllerOptions);\n\n            // controllerOptions provide some default arguments\n            $arguments = array_merge($controllerOptions, $arguments);\n\n            // Pop additional tokens from the tokenizer if necessary\n            if (isset($controllerOptions['_PopTokeniser'])) {\n                $request->shift($controllerOptions['_PopTokeniser']);\n            }\n\n            // Handler for redirection\n            if (isset($arguments['Redirect'])) {\n                $handler = function () use ($arguments) {\n                    // Redirection\n                    $response = new HTTPResponse();\n                    $response->redirect(static::absoluteURL($arguments['Redirect']));\n                    return $response;\n                };\n                break;\n            }\n\n            // Handler for constructing and calling a controller\n            $handler = function (HTTPRequest $request) use ($arguments) {\n                try {\n                    /** @var RequestHandler $controllerObj */\n                    $controllerObj = Injector::inst()->create($arguments['Controller']);\n                    return $controllerObj->handleRequest($request);\n                } catch (HTTPResponse_Exception $responseException) {\n                    return $responseException->getResponse();\n                }\n            };\n            break;\n        }\n\n        // Call the handler with the configured middlewares\n        $response = $this->callMiddleware($request, $handler);\n\n        // Note that if a different request was previously registered, this will now be lost\n        // In these cases it's better to use Kernel::nest() prior to kicking off a nested request\n        Injector::inst()->unregisterNamedObject(HTTPRequest::class);\n\n        return $response;\n    }\n\n    /**\n     * Returns indication whether the manifest cache has been flushed\n     * in the beginning of the current request.\n     *\n     * That could mean the current active request has `?flush` parameter.\n     * Another possibility is a race condition when the current request\n     * hits the server in between another request `?flush` authorisation\n     * and a redirect to the actual flush.\n     *\n     * @return bool\n     *\n     * @deprecated 4.12.0 Use Kernel::isFlushed instead\n     */\n    public static function isManifestFlushed()\n    {\n        Deprecation::notice('4.12.0', 'Use Kernel::isFlushed instead');\n        $kernel = Injector::inst()->get(Kernel::class);\n\n        // Only CoreKernel implements this method at the moment\n        // Introducing it to the Kernel interface is a breaking change\n        if (method_exists($kernel, 'isFlushed')) {\n            return $kernel->isFlushed();\n        }\n\n        $classManifest = $kernel->getClassLoader()->getManifest();\n        return $classManifest->isFlushed();\n    }\n\n    /**\n     * Return the {@link SiteTree} object that is currently being viewed. If there is no SiteTree\n     * object to return, then this will return the current controller.\n     *\n     * @return SiteTree|Controller\n     */\n    public static function get_current_page()\n    {\n        return self::$current_page ? self::$current_page : Controller::curr();\n    }\n\n    /**\n     * Set the currently active {@link SiteTree} object that is being used to respond to the request.\n     *\n     * @param SiteTree $page\n     */\n    public static function set_current_page($page)\n    {\n        self::$current_page = $page;\n    }\n\n    /**\n     * Converts the given path or url into an absolute url. This method follows the below rules:\n     * - Absolute urls (e.g. `http://localhost`) are not modified\n     * - Relative urls (e.g. `//localhost`) have current protocol added (`http://localhost`)\n     * - Absolute paths (e.g. `/base/about-us`) are resolved by adding the current protocol and host (`http://localhost/base/about-us`)\n     * - Relative paths (e.g. `about-us/staff`) must be resolved using one of three methods, disambiguated via the $relativeParent argument:\n     *     - BASE - Append this path to the base url (i.e. behaves as though `<base>` tag is provided in a html document). This is the default.\n     *     - REQUEST - Resolve this path to the current url (i.e. behaves as though no `<base>` tag is provided in a html document)\n     *     - ROOT - Treat this as though it was an absolute path, and append it to the protocol and hostname.\n     *\n     * @param string $url The url or path to resolve to absolute url.\n     * @param string $relativeParent Disambiguation method to use for evaluating relative paths\n     * @return string The absolute url\n     */\n    public static function absoluteURL($url, $relativeParent = self::BASE)\n    {\n        if (is_bool($relativeParent)) {\n            // Deprecate old boolean second parameter\n            Deprecation::notice('5.0', 'Director::absoluteURL takes an explicit parent for relative url');\n            $relativeParent = $relativeParent ? self::BASE : self::REQUEST;\n        }\n\n        // Check if there is already a protocol given\n        if (preg_match('/^http(s?):\\/\\//', $url ?? '')) {\n            return $url;\n        }\n\n        // Absolute urls without protocol are added\n        // E.g. //google.com -> http://google.com\n        if (strpos($url ?? '', '//') === 0) {\n            return self::protocol() . substr($url ?? '', 2);\n        }\n\n        // Determine method for mapping the parent to this relative url\n        if ($relativeParent === self::ROOT || self::is_root_relative_url($url)) {\n            // Root relative urls always should be evaluated relative to the root\n            $parent = self::protocolAndHost();\n        } elseif ($relativeParent === self::REQUEST) {\n            // Request relative urls rely on the REQUEST_URI param (old default behaviour)\n            if (!isset($_SERVER['REQUEST_URI'])) {\n                return false;\n            }\n            $parent = dirname($_SERVER['REQUEST_URI'] . 'x');\n        } else {\n            // Default to respecting site base_url\n            $parent = self::absoluteBaseURL();\n        }\n\n        // Map empty urls to relative slash and join to base\n        if (empty($url) || $url === '.' || $url === './') {\n            $url = '/';\n        }\n        return Controller::join_links($parent, $url);\n    }\n\n    /**\n     * Return only host (and optional port) part of a url\n     *\n     * @param string $url\n     * @return string|null Hostname, and optional port, or null if not a valid host\n     */\n    protected static function parseHost($url)\n    {\n        // Get base hostname\n        $host = parse_url($url ?? '', PHP_URL_HOST);\n        if (!$host) {\n            return null;\n        }\n\n        // Include port\n        $port = parse_url($url ?? '', PHP_URL_PORT);\n        if ($port) {\n            $host .= ':' . $port;\n        }\n\n        return $host;\n    }\n\n    /**\n     * Validate user and password in URL, disallowing slashes\n     *\n     * @param string $url\n     * @return bool\n     */\n    protected static function validateUserAndPass($url)\n    {\n        $parsedURL = parse_url($url ?? '');\n\n        // Validate user (disallow slashes)\n        if (!empty($parsedURL['user']) && strstr($parsedURL['user'] ?? '', '\\\\')) {\n            return false;\n        }\n        if (!empty($parsedURL['pass']) && strstr($parsedURL['pass'] ?? '', '\\\\')) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * A helper to determine the current hostname used to access the site.\n     * The following are used to determine the host (in order)\n     *  - Director.alternate_base_url (if it contains a domain name)\n     *  - Trusted proxy headers\n     *  - HTTP Host header\n     *  - SS_BASE_URL env var\n     *  - SERVER_NAME\n     *  - gethostname()\n     *\n     * @param HTTPRequest $request\n     * @return string Host name, including port (if present)\n     */\n    public static function host(HTTPRequest $request = null)\n    {\n        // Check if overridden by alternate_base_url\n        if ($baseURL = self::config()->get('alternate_base_url')) {\n            $baseURL = Injector::inst()->convertServiceProperty($baseURL);\n            $host = static::parseHost($baseURL);\n            if ($host) {\n                return $host;\n            }\n        }\n\n        $request = static::currentRequest($request);\n        if ($request && ($host = $request->getHeader('Host'))) {\n            return $host;\n        }\n\n        // Check given header\n        if (isset($_SERVER['HTTP_HOST'])) {\n            return $_SERVER['HTTP_HOST'];\n        }\n\n        // Check base url\n        if ($baseURL = self::config()->uninherited('default_base_url')) {\n            $baseURL = Injector::inst()->convertServiceProperty($baseURL);\n            $host = static::parseHost($baseURL);\n            if ($host) {\n                return $host;\n            }\n        }\n\n        // Fail over to server_name (least reliable)\n        return isset($_SERVER['SERVER_NAME']) ? $_SERVER['SERVER_NAME'] : gethostname();\n    }\n\n    /**\n     * Return port used for the base URL.\n     * Note, this will be null if not specified, in which case you should assume the default\n     * port for the current protocol.\n     *\n     * @param HTTPRequest $request\n     * @return int|null\n     */\n    public static function port(HTTPRequest $request = null)\n    {\n        $host = static::host($request);\n        return (int)parse_url($host ?? '', PHP_URL_PORT) ?: null;\n    }\n\n    /**\n     * Return host name without port\n     *\n     * @param HTTPRequest|null $request\n     * @return string|null\n     */\n    public static function hostName(HTTPRequest $request = null)\n    {\n        $host = static::host($request);\n        return parse_url($host ?? '', PHP_URL_HOST) ?: null;\n    }\n\n    /**\n     * Returns the domain part of the URL 'http://www.mysite.com'. Returns FALSE is this environment\n     * variable isn't set.\n     *\n     * @param HTTPRequest $request\n     * @return bool|string\n     */\n    public static function protocolAndHost(HTTPRequest $request = null)\n    {\n        return static::protocol($request) . static::host($request);\n    }\n\n    /**\n     * Return the current protocol that the site is running under.\n     *\n     * @param HTTPRequest $request\n     * @return string\n     */\n    public static function protocol(HTTPRequest $request = null)\n    {\n        return (self::is_https($request)) ? 'https://' : 'http://';\n    }\n\n    /**\n     * Return whether the site is running as under HTTPS.\n     *\n     * @param HTTPRequest $request\n     * @return bool\n     */\n    public static function is_https(HTTPRequest $request = null)\n    {\n        // Check override from alternate_base_url\n        if ($baseURL = self::config()->uninherited('alternate_base_url')) {\n            $baseURL = Injector::inst()->convertServiceProperty($baseURL);\n            $protocol = parse_url($baseURL ?? '', PHP_URL_SCHEME);\n            if ($protocol) {\n                return $protocol === 'https';\n            }\n        }\n\n        // Check the current request\n        $request = static::currentRequest($request);\n        if ($request && ($scheme = $request->getScheme())) {\n            return $scheme === 'https';\n        }\n\n        // Check default_base_url\n        if ($baseURL = self::config()->uninherited('default_base_url')) {\n            $baseURL = Injector::inst()->convertServiceProperty($baseURL);\n            $protocol = parse_url($baseURL ?? '', PHP_URL_SCHEME);\n            if ($protocol) {\n                return $protocol === 'https';\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Return the root-relative url for the baseurl\n     *\n     * @return string Root-relative url with trailing slash.\n     */\n    public static function baseURL()\n    {\n        // Check override base_url\n        $alternate = self::config()->get('alternate_base_url');\n        if ($alternate) {\n            $alternate = Injector::inst()->convertServiceProperty($alternate);\n            return rtrim(parse_url($alternate ?? '', PHP_URL_PATH) ?? '', '/') . '/';\n        }\n\n        // Get env base url\n        $baseURL = rtrim(BASE_URL, '/') . '/';\n\n        // Check if BASE_SCRIPT_URL is defined\n        // e.g. `index.php/`\n        if (defined('BASE_SCRIPT_URL')) {\n            return $baseURL . BASE_SCRIPT_URL;\n        }\n\n        return $baseURL;\n    }\n\n    /**\n     * Returns the root filesystem folder for the site. It will be automatically calculated unless\n     * it is overridden with {@link setBaseFolder()}.\n     *\n     * @return string\n     */\n    public static function baseFolder()\n    {\n        $alternate = Director::config()->uninherited('alternate_base_folder');\n        return $alternate ?: BASE_PATH;\n    }\n\n    /**\n     * Check if using a separate public dir, and if so return this directory\n     * name.\n     *\n     * This will be removed in 5.0 and fixed to 'public'\n     *\n     * @return string\n     */\n    public static function publicDir()\n    {\n        $alternate = self::config()->uninherited('alternate_public_dir');\n        if (isset($alternate)) {\n            return $alternate;\n        }\n        return PUBLIC_DIR;\n    }\n\n    /**\n     * Gets the webroot of the project, which may be a subfolder of {@see baseFolder()}\n     *\n     * @return string\n     */\n    public static function publicFolder()\n    {\n        $folder = self::baseFolder();\n        $publicDir = self::publicDir();\n        if ($publicDir) {\n            return Path::join($folder, $publicDir);\n        }\n\n        return $folder;\n    }\n\n    /**\n     * Turns an absolute URL or folder into one that's relative to the root of the site. This is useful\n     * when turning a URL into a filesystem reference, or vice versa.\n     *\n     * Note: You should check {@link Director::is_site_url()} if making an untrusted url relative prior\n     * to calling this function.\n     *\n     * @param string $url Accepts both a URL or a filesystem path.\n     * @return string\n     */\n    public static function makeRelative($url)\n    {\n        // Allow for the accidental inclusion whitespace and // in the URL\n        $url = preg_replace('#([^:])//#', '\\\\1/', trim($url ?? ''));\n\n        // If using a real url, remove protocol / hostname / auth / port\n        if (preg_match('#^(?<protocol>https?:)?//(?<hostpart>[^/]*)(?<url>(/.*)?)$#i', $url ?? '', $matches)) {\n            $url = $matches['url'];\n        }\n\n        // Empty case\n        if (trim($url ?? '', '\\\\/') === '') {\n            return '';\n        }\n\n        // Remove base folder or url\n        foreach ([self::publicFolder(), self::baseFolder(), self::baseURL()] as $base) {\n            // Ensure single / doesn't break comparison (unless it would make base empty)\n            $base = rtrim($base ?? '', '\\\\/') ?: $base;\n            if (stripos($url ?? '', $base ?? '') === 0) {\n                return ltrim(substr($url ?? '', strlen($base ?? '')), '\\\\/');\n            }\n        }\n\n        // Nothing matched, fall back to returning the original URL\n        return $url;\n    }\n\n    /**\n     * Returns true if a given path is absolute. Works under both *nix and windows systems.\n     *\n     * @param string $path\n     *\n     * @return bool\n     */\n    public static function is_absolute($path)\n    {\n        if (empty($path)) {\n            return false;\n        }\n        if ($path[0] == '/' || $path[0] == '\\\\') {\n            return true;\n        }\n        return preg_match('/^[a-zA-Z]:[\\\\\\\\\\/]/', $path ?? '') == 1;\n    }\n\n    /**\n     * Determine if the url is root relative (i.e. starts with /, but not with //) SilverStripe\n     * considers root relative urls as a subset of relative urls.\n     *\n     * @param string $url\n     *\n     * @return bool\n     */\n    public static function is_root_relative_url($url)\n    {\n        return strpos($url ?? '', '/') === 0 && strpos($url ?? '', '//') !== 0;\n    }\n\n    /**\n     * Checks if a given URL is absolute (e.g. starts with 'http://' etc.). URLs beginning with \"//\"\n     * are treated as absolute, as browsers take this to mean the same protocol as currently being used.\n     *\n     * Useful to check before redirecting based on a URL from user submissions through $_GET or $_POST,\n     * and avoid phishing attacks by redirecting to an attackers server.\n     *\n     * Note: Can't solely rely on PHP's parse_url() , since it is not intended to work with relative URLs\n     * or for security purposes. filter_var($url, FILTER_VALIDATE_URL) has similar problems.\n     *\n     * @param string $url\n     *\n     * @return bool\n     */\n    public static function is_absolute_url($url)\n    {\n        // Strip off the query and fragment parts of the URL before checking\n        if (($queryPosition = strpos($url ?? '', '?')) !== false) {\n            $url = substr($url ?? '', 0, $queryPosition - 1);\n        }\n        if (($hashPosition = strpos($url ?? '', '#')) !== false) {\n            $url = substr($url ?? '', 0, $hashPosition - 1);\n        }\n        $colonPosition = strpos($url ?? '', ':');\n        $slashPosition = strpos($url ?? '', '/');\n        return (\n            // Base check for existence of a host on a compliant URL\n            parse_url($url ?? '', PHP_URL_HOST)\n            // Check for more than one leading slash without a protocol.\n            // While not a RFC compliant absolute URL, it is completed to a valid URL by some browsers,\n            // and hence a potential security risk. Single leading slashes are not an issue though.\n            || preg_match('%^\\s*/{2,}%', $url ?? '')\n            || (\n                // If a colon is found, check if it's part of a valid scheme definition\n                // (meaning its not preceded by a slash).\n                $colonPosition !== false\n                && ($slashPosition === false || $colonPosition < $slashPosition)\n            )\n        );\n    }\n\n    /**\n     * Checks if a given URL is relative (or root relative) by checking {@link is_absolute_url()}.\n     *\n     * @param string $url\n     *\n     * @return bool\n     */\n    public static function is_relative_url($url)\n    {\n        return !static::is_absolute_url($url);\n    }\n\n    /**\n     * Checks if the given URL is belonging to this \"site\" (not an external link). That's the case if\n     * the URL is relative, as defined by {@link is_relative_url()}, or if the host matches\n     * {@link protocolAndHost()}.\n     *\n     * Useful to check before redirecting based on a URL from user submissions through $_GET or $_POST,\n     * and avoid phishing attacks by redirecting to an attackers server.\n     *\n     * Provides an extension point to allow extra checks on the URL to allow some external URLs,\n     * e.g. links on secondary domains that point to the same CMS, or subsite domains.\n     *\n     * @param string $url\n     *\n     * @return bool\n     */\n    public static function is_site_url($url)\n    {\n        // Validate user and password\n        if (!static::validateUserAndPass($url)) {\n            return false;\n        }\n\n        // Validate host[:port]\n        $urlHost = static::parseHost($url);\n        if ($urlHost && $urlHost === static::host()) {\n            return true;\n        }\n\n        // Allow extensions to weigh in\n        $isSiteUrl = false;\n        static::singleton()->extend('updateIsSiteUrl', $isSiteUrl, $url);\n        if ($isSiteUrl) {\n            return true;\n        }\n\n        // Relative urls always are site urls\n        return self::is_relative_url($url);\n    }\n\n    /**\n     * Given a filesystem reference relative to the site root, return the full file-system path.\n     *\n     * @param string $file\n     *\n     * @return string\n     */\n    public static function getAbsFile($file)\n    {\n        // If already absolute\n        if (self::is_absolute($file)) {\n            return $file;\n        }\n\n        // If path is relative to public folder search there first\n        if (self::publicDir()) {\n            $path = Path::join(self::publicFolder(), $file);\n            if (file_exists($path ?? '')) {\n                return $path;\n            }\n        }\n\n        // Default to base folder\n        return Path::join(self::baseFolder(), $file);\n    }\n\n    /**\n     * Returns true if the given file exists. Filename should be relative to the site root.\n     *\n     * @param $file\n     *\n     * @return bool\n     */\n    public static function fileExists($file)\n    {\n        // replace any appended query-strings, e.g. /path/to/foo.php?bar=1 to /path/to/foo.php\n        $file = preg_replace('/([^\\?]*)?.*/', '$1', $file ?? '');\n        return file_exists(Director::getAbsFile($file) ?? '');\n    }\n\n    /**\n     * Returns the Absolute URL of the site root.\n     *\n     * @return string\n     */\n    public static function absoluteBaseURL()\n    {\n        return self::absoluteURL(\n            self::baseURL(),\n            self::ROOT\n        );\n    }\n\n    /**\n     * Returns the Absolute URL of the site root, embedding the current basic-auth credentials into\n     * the URL.\n     *\n     * @param HTTPRequest|null $request\n     * @return string\n     */\n    public static function absoluteBaseURLWithAuth(HTTPRequest $request = null)\n    {\n        // Detect basic auth\n        $login = '';\n        if ($request) {\n            $user = $request->getHeader('PHP_AUTH_USER');\n            if ($user) {\n                $password = $request->getHeader('PHP_AUTH_PW');\n                $login = sprintf(\"%s:%s@\", $user, $password);\n            }\n        }\n\n        return Director::protocol($request) . $login . static::host($request) . Director::baseURL();\n    }\n\n    /**\n     * Skip any further processing and immediately respond with a redirect to the passed URL.\n     *\n     * @param string $destURL\n     * @throws HTTPResponse_Exception\n     */\n    protected static function force_redirect($destURL)\n    {\n        // Redirect to installer\n        $response = new HTTPResponse();\n        $response->redirect($destURL, 301);\n        throw new HTTPResponse_Exception($response);\n    }\n\n    /**\n     * Force the site to run on SSL.\n     *\n     * To use, call from _config.php. For example:\n     * <code>\n     * if (Director::isLive()) Director::forceSSL();\n     * </code>\n     *\n     * If you don't want your entire site to be on SSL, you can pass an array of PCRE regular expression\n     * patterns for matching relative URLs. For example:\n     * <code>\n     * if (Director::isLive()) Director::forceSSL(array('/^admin/', '/^Security/'));\n     * </code>\n     *\n     * If you want certain parts of your site protected under a different domain, you can specify\n     * the domain as an argument:\n     * <code>\n     * if (Director::isLive()) Director::forceSSL(array('/^admin/', '/^Security/'), 'secure.mysite.com');\n     * </code>\n     *\n     * Note that the session data will be lost when moving from HTTP to HTTPS. It is your responsibility\n     * to ensure that this won't cause usability problems.\n     *\n     * CAUTION: This does not respect the site environment mode. You should check this\n     * as per the above examples using Director::isLive() or Director::isTest() for example.\n     *\n     * @param array $patterns Array of regex patterns to match URLs that should be HTTPS.\n     * @param string $secureDomain Secure domain to redirect to. Defaults to the current domain.\n     * Can include port number.\n     * @param HTTPRequest|null $request Request object to check\n     */\n    public static function forceSSL($patterns = null, $secureDomain = null, HTTPRequest $request = null)\n    {\n        $handler = CanonicalURLMiddleware::singleton()->setForceSSL(true);\n        if ($patterns) {\n            $handler->setForceSSLPatterns($patterns);\n        }\n        if ($secureDomain) {\n            $handler->setForceSSLDomain($secureDomain);\n        }\n        $handler->throwRedirectIfNeeded($request);\n    }\n\n    /**\n     * Force a redirect to a domain starting with \"www.\"\n     *\n     * @param HTTPRequest $request\n     */\n    public static function forceWWW(HTTPRequest $request = null)\n    {\n        $handler = CanonicalURLMiddleware::singleton()->setForceWWW(true);\n        $handler->throwRedirectIfNeeded($request);\n    }\n\n    /**\n     * Checks if the current HTTP-Request is an \"Ajax-Request\" by checking for a custom header set by\n     * jQuery or whether a manually set request-parameter 'ajax' is present.\n     *\n     * Note that if you plan to use this to alter your HTTP response on a cached page,\n     * you should add X-Requested-With to the Vary header.\n     *\n     * @param HTTPRequest $request\n     * @return bool\n     */\n    public static function is_ajax(HTTPRequest $request = null)\n    {\n        $request = self::currentRequest($request);\n        if ($request) {\n            return $request->isAjax();\n        }\n\n        return (\n            isset($_REQUEST['ajax']) ||\n            (isset($_SERVER['HTTP_X_REQUESTED_WITH']) && $_SERVER['HTTP_X_REQUESTED_WITH'] == \"XMLHttpRequest\")\n        );\n    }\n\n    /**\n     * Returns true if this script is being run from the command line rather than the web server.\n     *\n     * @return bool\n     */\n    public static function is_cli()\n    {\n        return Environment::isCli();\n    }\n\n    /**\n     * Can also be checked with {@link Director::isDev()}, {@link Director::isTest()}, and\n     * {@link Director::isLive()}.\n     *\n     * @return string\n     */\n    public static function get_environment_type()\n    {\n        /** @var Kernel $kernel */\n        $kernel = Injector::inst()->get(Kernel::class);\n        return $kernel->getEnvironment();\n    }\n\n\n    /**\n     * Returns the session environment override\n     *\n     * @internal This method is not a part of public API and will be deleted without a deprecation warning\n     *\n     * @param HTTPRequest $request\n     *\n     * @return string|null null if not overridden, otherwise the actual value\n     */\n    public static function get_session_environment_type(HTTPRequest $request = null)\n    {\n        $request = static::currentRequest($request);\n\n        if (!$request) {\n            return null;\n        }\n\n        $session = $request->getSession();\n\n        if (!empty($session->get('isDev'))) {\n            return Kernel::DEV;\n        } elseif (!empty($session->get('isTest'))) {\n            return Kernel::TEST;\n        }\n    }\n\n    /**\n     * This function will return true if the site is in a live environment. For information about\n     * environment types, see {@link Director::set_environment_type()}.\n     *\n     * @return bool\n     */\n    public static function isLive()\n    {\n        return self::get_environment_type() === 'live';\n    }\n\n    /**\n     * This function will return true if the site is in a development environment. For information about\n     * environment types, see {@link Director::set_environment_type()}.\n     *\n     * @return bool\n     */\n    public static function isDev()\n    {\n        return self::get_environment_type() === 'dev';\n    }\n\n    /**\n     * This function will return true if the site is in a test environment. For information about\n     * environment types, see {@link Director::set_environment_type()}.\n     *\n     * @return bool\n     */\n    public static function isTest()\n    {\n        return self::get_environment_type() === 'test';\n    }\n\n    /**\n     * Returns an array of strings of the method names of methods on the call that should be exposed\n     * as global variables in the templates.\n     *\n     * @return array\n     */\n    public static function get_template_global_variables()\n    {\n        return [\n            'absoluteBaseURL',\n            'baseURL',\n            'isDev',\n            'isTest',\n            'isLive',\n            'is_ajax',\n            'isAjax' => 'is_ajax',\n            'BaseHref' => 'absoluteBaseURL',    //@deprecated 3.0\n        ];\n    }\n\n    /**\n     * Helper to validate or check the current request object\n     *\n     * @param HTTPRequest $request\n     * @return HTTPRequest Request object if one is both current and valid\n     */\n    protected static function currentRequest(HTTPRequest $request = null)\n    {\n        // Ensure we only use a registered HTTPRequest and don't\n        // incidentally construct a singleton\n        if (!$request && Injector::inst()->has(HTTPRequest::class)) {\n            $request = Injector::inst()->get(HTTPRequest::class);\n        }\n        return $request;\n    }\n}\n", "<?php\n\nnamespace SilverStripe\\Control\\Tests;\n\nuse SilverStripe\\Control\\Cookie_Backend;\nuse SilverStripe\\Control\\Director;\nuse SilverStripe\\Control\\HTTPRequest;\nuse SilverStripe\\Control\\HTTPResponse;\nuse SilverStripe\\Control\\HTTPResponse_Exception;\nuse SilverStripe\\Control\\Middleware\\CanonicalURLMiddleware;\nuse SilverStripe\\Control\\Middleware\\RequestHandlerMiddlewareAdapter;\nuse SilverStripe\\Control\\Middleware\\TrustedProxyMiddleware;\nuse SilverStripe\\Control\\RequestProcessor;\nuse SilverStripe\\Control\\Tests\\DirectorTest\\TestController;\nuse SilverStripe\\Core\\Config\\Config;\nuse SilverStripe\\Core\\Injector\\Injector;\nuse SilverStripe\\Core\\Environment;\nuse SilverStripe\\Core\\Kernel;\nuse SilverStripe\\Dev\\SapphireTest;\n\n/**\n * @todo test Director::alternateBaseFolder()\n */\nclass DirectorTest extends SapphireTest\n{\n    protected static $extra_controllers = [\n        TestController::class,\n    ];\n\n    private $originalEnvType;\n\n    protected function setUp(): void\n    {\n        parent::setUp();\n        Director::config()->set('alternate_base_url', 'http://www.mysite.com:9090/');\n\n        $this->originalEnvType = Environment::getEnv('SS_ENVIRONMENT_TYPE');\n\n        // Ensure redirects enabled on all environments and global state doesn't affect the tests\n        CanonicalURLMiddleware::singleton()\n            ->setForceSSL(null)\n            ->setForceSSLDomain(null)\n            ->setForceSSLPatterns([])\n            ->setForceWWW(null)\n            ->setEnabledEnvs(true);\n        $this->expectedRedirect = null;\n    }\n\n    protected function tearDown(): void\n    {\n        Environment::setEnv('SS_ENVIRONMENT_TYPE', $this->originalEnvType);\n        parent::tearDown();\n    }\n\n    protected function getExtraRoutes()\n    {\n        $rules = parent::getExtraRoutes();\n\n        $rules['DirectorTestRule/$Action/$ID/$OtherID'] = TestController::class;\n        $rules['en-nz/$Action/$ID/$OtherID'] = [\n            'Controller' => TestController::class,\n            'Locale' => 'en_NZ',\n        ];\n        return $rules;\n    }\n\n    protected function setUpRoutes()\n    {\n        // Don't merge with any existing rules\n        Director::config()->set('rules', $this->getExtraRoutes());\n    }\n\n    public function testFileExists()\n    {\n        $tempFileName = 'DirectorTest_testFileExists.tmp';\n        $tempFilePath = TEMP_PATH . DIRECTORY_SEPARATOR . $tempFileName;\n\n        // create temp file\n        file_put_contents($tempFilePath ?? '', '');\n\n        $this->assertTrue(\n            Director::fileExists($tempFilePath),\n            'File exist check with absolute path'\n        );\n\n        $this->assertTrue(\n            Director::fileExists($tempFilePath . '?queryparams=1&foo[bar]=bar'),\n            'File exist check with query params ignored'\n        );\n\n        unlink($tempFilePath ?? '');\n    }\n\n    public function testAbsoluteURL()\n    {\n        Director::config()->set('alternate_base_url', 'http://www.mysite.com:9090/mysite/');\n        $_SERVER['REQUEST_URI'] = \"http://www.mysite.com:9090/mysite/sub-page/\";\n\n        //test empty / local urls\n        foreach (['', './', '.'] as $url) {\n            $this->assertEquals(\"http://www.mysite.com:9090/mysite/\", Director::absoluteURL($url, Director::BASE));\n            $this->assertEquals(\"http://www.mysite.com:9090/\", Director::absoluteURL($url, Director::ROOT));\n            $this->assertEquals(\"http://www.mysite.com:9090/mysite/sub-page/\", Director::absoluteURL($url, Director::REQUEST));\n        }\n\n        // Test site root url\n        $this->assertEquals(\"http://www.mysite.com:9090/\", Director::absoluteURL('/'));\n\n        // Test Director::BASE\n        $this->assertEquals('http://www.mysite.com:9090/', Director::absoluteURL('http://www.mysite.com:9090/', Director::BASE));\n        $this->assertEquals('http://www.mytest.com', Director::absoluteURL('http://www.mytest.com', Director::BASE));\n        $this->assertEquals(\"http://www.mysite.com:9090/test\", Director::absoluteURL(\"http://www.mysite.com:9090/test\", Director::BASE));\n        $this->assertEquals(\"http://www.mysite.com:9090/root\", Director::absoluteURL(\"/root\", Director::BASE));\n        $this->assertEquals(\"http://www.mysite.com:9090/root/url\", Director::absoluteURL(\"/root/url\", Director::BASE));\n\n        // Test Director::ROOT\n        $this->assertEquals('http://www.mysite.com:9090/', Director::absoluteURL('http://www.mysite.com:9090/', Director::ROOT));\n        $this->assertEquals('http://www.mytest.com', Director::absoluteURL('http://www.mytest.com', Director::ROOT));\n        $this->assertEquals(\"http://www.mysite.com:9090/test\", Director::absoluteURL(\"http://www.mysite.com:9090/test\", Director::ROOT));\n        $this->assertEquals(\"http://www.mysite.com:9090/root\", Director::absoluteURL(\"/root\", Director::ROOT));\n        $this->assertEquals(\"http://www.mysite.com:9090/root/url\", Director::absoluteURL(\"/root/url\", Director::ROOT));\n\n        // Test Director::REQUEST\n        $this->assertEquals('http://www.mysite.com:9090/', Director::absoluteURL('http://www.mysite.com:9090/', Director::REQUEST));\n        $this->assertEquals('http://www.mytest.com', Director::absoluteURL('http://www.mytest.com', Director::REQUEST));\n        $this->assertEquals(\"http://www.mysite.com:9090/test\", Director::absoluteURL(\"http://www.mysite.com:9090/test\", Director::REQUEST));\n        $this->assertEquals(\"http://www.mysite.com:9090/root\", Director::absoluteURL(\"/root\", Director::REQUEST));\n        $this->assertEquals(\"http://www.mysite.com:9090/root/url\", Director::absoluteURL(\"/root/url\", Director::REQUEST));\n\n        // Test evaluating relative urls relative to base (default)\n        $this->assertEquals(\"http://www.mysite.com:9090/mysite/test\", Director::absoluteURL(\"test\"));\n        $this->assertEquals(\"http://www.mysite.com:9090/mysite/test/url\", Director::absoluteURL(\"test/url\"));\n        $this->assertEquals(\"http://www.mysite.com:9090/mysite/test\", Director::absoluteURL(\"test\", Director::BASE));\n        $this->assertEquals(\"http://www.mysite.com:9090/mysite/test/url\", Director::absoluteURL(\"test/url\", Director::BASE));\n\n        // Test evaluating relative urls relative to root\n        $this->assertEquals(\"http://www.mysite.com:9090/test\", Director::absoluteURL(\"test\", Director::ROOT));\n        $this->assertEquals(\"http://www.mysite.com:9090/test/url\", Director::absoluteURL(\"test/url\", Director::ROOT));\n\n        // Test relative to requested page\n        $this->assertEquals(\"http://www.mysite.com:9090/mysite/sub-page/test\", Director::absoluteURL(\"test\", Director::REQUEST));\n        $this->assertEquals(\"http://www.mysite.com:9090/mysite/sub-page/test/url\", Director::absoluteURL(\"test/url\", Director::REQUEST));\n\n        // Test that javascript links are not left intact\n        $this->assertStringStartsNotWith('javascript', Director::absoluteURL('javascript:alert(\"attack\")'));\n        $this->assertStringStartsNotWith('alert', Director::absoluteURL('javascript:alert(\"attack\")'));\n        $this->assertStringStartsNotWith('javascript', Director::absoluteURL('alert(\"attack\")'));\n        $this->assertStringStartsNotWith('alert', Director::absoluteURL('alert(\"attack\")'));\n    }\n\n    public function testAlternativeBaseURL()\n    {\n        // relative base URLs - you should end them in a /\n        Director::config()->set('alternate_base_url', '/relativebase/');\n        $_SERVER['HTTP_HOST'] = 'www.somesite.com';\n        $_SERVER['REQUEST_URI'] = \"/relativebase/sub-page/\";\n\n        $this->assertEquals('/relativebase/', Director::baseURL());\n        $this->assertEquals('http://www.somesite.com/relativebase/', Director::absoluteBaseURL());\n        $this->assertEquals(\n            'http://www.somesite.com/relativebase/subfolder/test',\n            Director::absoluteURL('subfolder/test')\n        );\n\n        // absolute base URLS with subdirectory - You should end them in a /\n        Director::config()->set('alternate_base_url', 'http://www.example.org/relativebase/');\n        $_SERVER['REQUEST_URI'] = \"http://www.example.org/relativebase/sub-page/\";\n        $this->assertEquals('/relativebase/', Director::baseURL()); // Non-absolute url\n        $this->assertEquals('http://www.example.org/relativebase/', Director::absoluteBaseURL());\n        $this->assertEquals('http://www.example.org/relativebase/sub-page/', Director::absoluteURL('', Director::REQUEST));\n        $this->assertEquals('http://www.example.org/relativebase/', Director::absoluteURL('', Director::BASE));\n        $this->assertEquals('http://www.example.org/', Director::absoluteURL('', Director::ROOT));\n        $this->assertEquals(\n            'http://www.example.org/relativebase/sub-page/subfolder/test',\n            Director::absoluteURL('subfolder/test', Director::REQUEST)\n        );\n        $this->assertEquals(\n            'http://www.example.org/subfolder/test',\n            Director::absoluteURL('subfolder/test', Director::ROOT)\n        );\n        $this->assertEquals(\n            'http://www.example.org/relativebase/subfolder/test',\n            Director::absoluteURL('subfolder/test', Director::BASE)\n        );\n\n        // absolute base URLs - you should end them in a /\n        Director::config()->set('alternate_base_url', 'http://www.example.org/');\n        $_SERVER['REQUEST_URI'] = \"http://www.example.org/sub-page/\";\n        $this->assertEquals('/', Director::baseURL()); // Non-absolute url\n        $this->assertEquals('http://www.example.org/', Director::absoluteBaseURL());\n        $this->assertEquals('http://www.example.org/sub-page/', Director::absoluteURL('', Director::REQUEST));\n        $this->assertEquals('http://www.example.org/', Director::absoluteURL('', Director::BASE));\n        $this->assertEquals('http://www.example.org/', Director::absoluteURL('', Director::ROOT));\n        $this->assertEquals(\n            'http://www.example.org/sub-page/subfolder/test',\n            Director::absoluteURL('subfolder/test', Director::REQUEST)\n        );\n        $this->assertEquals(\n            'http://www.example.org/subfolder/test',\n            Director::absoluteURL('subfolder/test', Director::ROOT)\n        );\n        $this->assertEquals(\n            'http://www.example.org/subfolder/test',\n            Director::absoluteURL('subfolder/test', Director::BASE)\n        );\n    }\n\n    /**\n     * Tests that {@link Director::is_absolute()} works under different environment types\n     * @dataProvider provideAbsolutePaths\n     */\n    public function testIsAbsolute($path, $result)\n    {\n        $this->assertEquals($result, Director::is_absolute($path));\n    }\n\n    public function provideAbsolutePaths()\n    {\n        return [\n            ['C:/something', true],\n            ['d:\\\\', true],\n            ['e/', false],\n            ['s:/directory', true],\n            ['/var/www', true],\n            ['\\\\Something', true],\n            ['something/c:', false],\n            ['folder', false],\n            ['a/c:/', false],\n        ];\n    }\n\n    public function testIsAbsoluteUrl()\n    {\n        $this->assertTrue(Director::is_absolute_url('http://test.com/testpage'));\n        $this->assertTrue(Director::is_absolute_url('ftp://test.com'));\n        $this->assertFalse(Director::is_absolute_url('test.com/testpage'));\n        $this->assertFalse(Director::is_absolute_url('/relative'));\n        $this->assertFalse(Director::is_absolute_url('relative'));\n        $this->assertFalse(Director::is_absolute_url(\"/relative/?url=http://foo.com\"));\n        $this->assertFalse(Director::is_absolute_url(\"/relative/#http://foo.com\"));\n        $this->assertTrue(Director::is_absolute_url(\"https://test.com/?url=http://foo.com\"));\n        $this->assertTrue(Director::is_absolute_url(\"trickparseurl:http://test.com\"));\n        $this->assertTrue(Director::is_absolute_url('//test.com'));\n        $this->assertTrue(Director::is_absolute_url('/////test.com'));\n        $this->assertTrue(Director::is_absolute_url('  ///test.com'));\n        $this->assertTrue(Director::is_absolute_url('http:test.com'));\n        $this->assertTrue(Director::is_absolute_url('//http://test.com'));\n    }\n\n    public function testHostPortParts()\n    {\n        $this->assertEquals('www.mysite.com:9090', Director::host());\n        $this->assertEquals('www.mysite.com', Director::hostName());\n        $this->assertEquals('9090', Director::port());\n    }\n\n    public function testIsRelativeUrl()\n    {\n        $this->assertFalse(Director::is_relative_url('http://test.com'));\n        $this->assertFalse(Director::is_relative_url('https://test.com'));\n        $this->assertFalse(Director::is_relative_url('   https://test.com/testpage   '));\n        $this->assertTrue(Director::is_relative_url('test.com/testpage'));\n        $this->assertFalse(Director::is_relative_url('ftp://test.com'));\n        $this->assertTrue(Director::is_relative_url('/relative'));\n        $this->assertTrue(Director::is_relative_url('relative'));\n        $this->assertTrue(Director::is_relative_url('/relative/?url=http://test.com'));\n        $this->assertTrue(Director::is_relative_url('/relative/#=http://test.com'));\n    }\n\n    /**\n     * @return array\n     */\n    public function providerMakeRelative()\n    {\n        return [\n            // Resilience to slash position\n            [\n                'http://www.mysite.com:9090/base/folder',\n                'http://www.mysite.com:9090/base/folder',\n                ''\n            ],\n            [\n                'http://www.mysite.com:9090/base/folder',\n                'http://www.mysite.com:9090/base/folder/',\n                ''\n            ],\n            [\n                'http://www.mysite.com:9090/base/folder/',\n                'http://www.mysite.com:9090/base/folder',\n                ''\n            ],\n            [\n                'http://www.mysite.com:9090/',\n                'http://www.mysite.com:9090/',\n                ''\n            ],\n            [\n                'http://www.mysite.com:9090/',\n                'http://www.mysite.com',\n                ''\n            ],\n            [\n                'http://www.mysite.com',\n                'http://www.mysite.com:9090/',\n                ''\n            ],\n            [\n                'http://www.mysite.com:9090/base/folder',\n                'http://www.mysite.com:9090/base/folder/page',\n                'page'\n            ],\n            [\n                'http://www.mysite.com:9090/',\n                'http://www.mysite.com:9090/page/',\n                'page/'\n            ],\n            // Parsing protocol safely\n            [\n                'http://www.mysite.com:9090/base/folder',\n                'https://www.mysite.com:9090/base/folder',\n                ''\n            ],\n            [\n                'https://www.mysite.com:9090/base/folder',\n                'http://www.mysite.com:9090/base/folder/testpage',\n                'testpage'\n            ],\n            [\n                'http://www.mysite.com:9090/base/folder',\n                '//www.mysite.com:9090/base/folder/testpage',\n                'testpage'\n            ],\n            // Dirty input\n            [\n                'http://www.mysite.com:9090/base/folder',\n                '    https://www.mysite.com:9090/base/folder/testpage    ',\n                'testpage'\n            ],\n            [\n                'http://www.mysite.com:9090/base/folder',\n                '//www.mysite.com:9090/base//folder/testpage//subpage',\n                'testpage/subpage'\n            ],\n            // Non-http protocol isn't modified\n            [\n                'http://www.mysite.com:9090/base/folder',\n                'ftp://test.com',\n                'ftp://test.com'\n            ],\n            // Alternate hostnames are redirected\n            [\n                'https://www.mysite.com:9090/base/folder',\n                'http://mysite.com:9090/base/folder/testpage',\n                'testpage'\n            ],\n            [\n                'http://www.otherdomain.com/base/folder',\n                '//www.mysite.com:9090/base/folder/testpage',\n                'testpage'\n            ],\n            // Base folder is found\n            [\n                'http://www.mysite.com:9090/base/folder',\n                BASE_PATH . '/some/file.txt',\n                'some/file.txt',\n            ],\n            // public folder is found\n            [\n                'http://www.mysite.com:9090/base/folder',\n                PUBLIC_PATH . '/some/file.txt',\n                'some/file.txt',\n            ],\n            // querystring is protected\n            [\n                'http://www.mysite.com:9090/base/folder',\n                '//www.mysite.com:9090/base//folder/testpage//subpage?args=hello',\n                'testpage/subpage?args=hello'\n            ],\n            [\n                'http://www.mysite.com:9090/base/folder',\n                '//www.mysite.com:9090/base//folder/?args=hello',\n                '?args=hello'\n            ],\n        ];\n    }\n\n    /**\n     * @dataProvider providerMakeRelative\n     * @param string $baseURL Site base URL\n     * @param string $requestURL Request URL\n     * @param string $relativeURL Expected relative URL\n     */\n    public function testMakeRelative($baseURL, $requestURL, $relativeURL)\n    {\n        Director::config()->set('alternate_base_url', $baseURL);\n        $actualRelative = Director::makeRelative($requestURL);\n        $this->assertEquals(\n            $relativeURL,\n            $actualRelative,\n            \"Expected relativeURL of {$requestURL} to be {$relativeURL}\"\n        );\n    }\n\n    /**\n     * Mostly tested by {@link testIsRelativeUrl()},\n     * just adding the host name matching aspect here.\n     */\n    public function testIsSiteUrl()\n    {\n        $this->assertFalse(Director::is_site_url(\"http://test.com\"));\n        $this->assertTrue(Director::is_site_url(Director::absoluteBaseURL()));\n        $this->assertFalse(Director::is_site_url(\"http://test.com?url=\" . Director::absoluteBaseURL()));\n        $this->assertFalse(Director::is_site_url(\"http://test.com?url=\" . urlencode(Director::absoluteBaseURL() ?? '')));\n        $this->assertFalse(Director::is_site_url(\"//test.com?url=\" . Director::absoluteBaseURL()));\n        $this->assertFalse(Director::is_site_url('http://google.com\\@test.com'));\n        $this->assertFalse(Director::is_site_url('http://google.com/@test.com'));\n        $this->assertFalse(Director::is_site_url('http://google.com:pass\\@test.com'));\n        $this->assertFalse(Director::is_site_url('http://google.com:pass/@test.com'));\n    }\n\n    /**\n     * Tests isDev, isTest, isLive cannot be set from querystring\n     */\n    public function testQueryIsEnvironment()\n    {\n        if (!isset($_SESSION)) {\n            $_SESSION = [];\n        }\n        // Reset\n        unset($_SESSION['isDev']);\n        unset($_SESSION['isLive']);\n        unset($_GET['isTest']);\n        unset($_GET['isDev']);\n\n        /** @var Kernel $kernel */\n        $kernel = Injector::inst()->get(Kernel::class);\n        $kernel->setEnvironment(null);\n        Environment::setEnv('SS_ENVIRONMENT_TYPE', Kernel::LIVE);\n\n        $this->assertTrue(Director::isLive());\n\n        // Test isDev=1\n        $_GET['isDev'] = '1';\n        $this->assertFalse(Director::isDev());\n        $this->assertFalse(Director::isTest());\n        $this->assertTrue(Director::isLive());\n\n        // Test persistence\n        unset($_GET['isDev']);\n        $this->assertFalse(Director::isDev());\n        $this->assertFalse(Director::isTest());\n        $this->assertTrue(Director::isLive());\n\n        // Test change to isTest\n        $_GET['isTest'] = '1';\n        $this->assertFalse(Director::isDev());\n        $this->assertFalse(Director::isTest());\n        $this->assertTrue(Director::isLive());\n\n        // Test persistence\n        unset($_GET['isTest']);\n        $this->assertFalse(Director::isDev());\n        $this->assertFalse(Director::isTest());\n        $this->assertTrue(Director::isLive());\n    }\n\n    public function testResetGlobalsAfterTestRequest()\n    {\n        $_GET = ['somekey' => 'getvalue'];\n        $_POST = ['somekey' => 'postvalue'];\n        $_COOKIE = ['somekey' => 'cookievalue'];\n\n        $cookies = Injector::inst()->createWithArgs(\n            Cookie_Backend::class,\n            [['somekey' => 'sometestcookievalue']]\n        );\n\n        Director::test(\n            'errorpage?somekey=sometestgetvalue',\n            ['somekey' => 'sometestpostvalue'],\n            null,\n            null,\n            null,\n            null,\n            $cookies\n        );\n\n        $this->assertEquals(\n            'getvalue',\n            $_GET['somekey'],\n            '$_GET reset to original value after Director::test()'\n        );\n        $this->assertEquals(\n            'postvalue',\n            $_POST['somekey'],\n            '$_POST reset to original value after Director::test()'\n        );\n        $this->assertEquals(\n            'cookievalue',\n            $_COOKIE['somekey'],\n            '$_COOKIE reset to original value after Director::test()'\n        );\n    }\n\n    public function providerTestTestRequestCarriesGlobals()\n    {\n        $tests = [];\n        $fixture = ['somekey' => 'sometestvalue'];\n        foreach (['get', 'post'] as $method) {\n            foreach (['return%sValue', 'returnRequestValue', 'returnCookieValue'] as $testfunction) {\n                $url = 'TestController/' . sprintf($testfunction ?? '', ucfirst($method ?? ''))\n                    . '?' . http_build_query($fixture ?? []);\n                $tests[] = [$url, $fixture, $method];\n            }\n        }\n        return $tests;\n    }\n\n    /**\n     * @dataProvider providerTestTestRequestCarriesGlobals\n     * @param $url\n     * @param $fixture\n     * @param $method\n     */\n    public function testTestRequestCarriesGlobals($url, $fixture, $method)\n    {\n        $getresponse = Director::test(\n            $url,\n            $fixture,\n            null,\n            strtoupper($method ?? ''),\n            null,\n            null,\n            Injector::inst()->createWithArgs(Cookie_Backend::class, [$fixture])\n        );\n\n        $this->assertInstanceOf(HTTPResponse::class, $getresponse, 'Director::test() returns HTTPResponse');\n        $this->assertEquals($fixture['somekey'], $getresponse->getBody(), \"Director::test({$url}, {$method})\");\n    }\n\n    /**\n     * Tests that additional parameters specified in the routing table are\n     * saved in the request\n     */\n    public function testRouteParams()\n    {\n        /** @var HTTPRequest $request */\n        Director::test('en-nz/myaction/myid/myotherid', null, null, null, null, null, null, $request);\n\n        $this->assertEquals(\n            [\n                'Controller' => TestController::class,\n                'Action' => 'myaction',\n                'ID' => 'myid',\n                'OtherID' => 'myotherid',\n                'Locale' => 'en_NZ'\n            ],\n            $request->params()\n        );\n    }\n\n    public function testForceWWW()\n    {\n        $this->expectExceptionRedirect('http://www.mysite.com:9090/some-url');\n        Director::mockRequest(function ($request) {\n            Injector::inst()->registerService($request, HTTPRequest::class);\n            Director::forceWWW();\n        }, 'http://mysite.com:9090/some-url');\n    }\n\n    public function testPromisedForceWWW()\n    {\n        Director::forceWWW();\n\n        // Flag is set but not redirected yet\n        $middleware = CanonicalURLMiddleware::singleton();\n        $this->assertTrue($middleware->getForceWWW());\n\n        // Middleware forces the redirection eventually\n        /** @var HTTPResponse $response */\n        $response = Director::mockRequest(function ($request) use ($middleware) {\n            return $middleware->process($request, function ($request) {\n                return null;\n            });\n        }, 'http://mysite.com:9090/some-url');\n\n        // Middleware returns non-exception redirect\n        $this->assertEquals('http://www.mysite.com:9090/some-url', $response->getHeader('Location'));\n        $this->assertEquals(301, $response->getStatusCode());\n    }\n\n    public function testForceSSLProtectsEntireSite()\n    {\n        $this->expectExceptionRedirect('https://www.mysite.com:9090/some-url');\n        Director::mockRequest(function ($request) {\n            Injector::inst()->registerService($request, HTTPRequest::class);\n            Director::forceSSL();\n        }, 'http://www.mysite.com:9090/some-url');\n    }\n\n    public function testPromisedForceSSL()\n    {\n        Director::forceSSL();\n\n        // Flag is set but not redirected yet\n        $middleware = CanonicalURLMiddleware::singleton();\n        $this->assertTrue($middleware->getForceSSL());\n\n        // Middleware forces the redirection eventually\n        /** @var HTTPResponse $response */\n        $response = Director::mockRequest(function ($request) use ($middleware) {\n            return $middleware->process($request, function ($request) {\n                return null;\n            });\n        }, 'http://www.mysite.com:9090/some-url');\n\n        // Middleware returns non-exception redirect\n        $this->assertInstanceOf(HTTPResponse::class, $response);\n        $this->assertEquals('https://www.mysite.com:9090/some-url', $response->getHeader('Location'));\n        $this->assertEquals(301, $response->getStatusCode());\n    }\n\n    public function testForceSSLOnTopLevelPagePattern()\n    {\n        // Expect admin to trigger redirect\n        $this->expectExceptionRedirect('https://www.mysite.com:9090/admin');\n        Director::mockRequest(function (HTTPRequest $request) {\n            Injector::inst()->registerService($request, HTTPRequest::class);\n            Director::forceSSL(['/^admin/']);\n        }, 'http://www.mysite.com:9090/admin');\n    }\n\n    public function testForceSSLOnSubPagesPattern()\n    {\n        // Expect to redirect to security login page\n        $this->expectExceptionRedirect('https://www.mysite.com:9090/Security/login');\n        Director::mockRequest(function (HTTPRequest $request) {\n            Injector::inst()->registerService($request, HTTPRequest::class);\n            Director::forceSSL(['/^Security/']);\n        }, 'http://www.mysite.com:9090/Security/login');\n    }\n\n    public function testForceSSLWithPatternDoesNotMatchOtherPages()\n    {\n        // Not on same url should not trigger redirect\n        $response = Director::mockRequest(function (HTTPRequest $request) {\n            Injector::inst()->registerService($request, HTTPRequest::class);\n            Director::forceSSL(['/^admin/']);\n        }, 'http://www.mysite.com:9090/normal-page');\n        $this->assertNull($response, 'Non-matching patterns do not trigger redirect');\n\n        // nested url should not triger redirect either\n        $response = Director::mockRequest(function (HTTPRequest $request) {\n            Injector::inst()->registerService($request, HTTPRequest::class);\n            Director::forceSSL(['/^admin/', '/^Security/']);\n        }, 'http://www.mysite.com:9090/just-another-page/sub-url');\n        $this->assertNull($response, 'Non-matching patterns do not trigger redirect');\n    }\n\n    public function testForceSSLAlternateDomain()\n    {\n        // Ensure that forceSSL throws the appropriate exception\n        $this->expectExceptionRedirect('https://secure.mysite.com/admin');\n        Director::mockRequest(function (HTTPRequest $request) {\n            Injector::inst()->registerService($request, HTTPRequest::class);\n            return Director::forceSSL(['/^admin/'], 'secure.mysite.com');\n        }, 'http://www.mysite.com:9090/admin');\n    }\n\n    public function testForceSSLAlternateDomainWithPort()\n    {\n        // Ensure that forceSSL throws the appropriate exception\n        $this->expectExceptionRedirect('https://secure.mysite.com:81/admin');\n        Director::mockRequest(function (HTTPRequest $request) {\n            Injector::inst()->registerService($request, HTTPRequest::class);\n            return Director::forceSSL(['/^admin/'], 'secure.mysite.com:81');\n        }, 'http://www.mysite.com:9090/admin');\n    }\n\n    /**\n     * Test that combined forceWWW and forceSSL combine safely\n     */\n    public function testForceSSLandForceWWW()\n    {\n        Director::forceWWW();\n        Director::forceSSL();\n\n        // Flag is set but not redirected yet\n        $middleware = CanonicalURLMiddleware::singleton();\n        $this->assertTrue($middleware->getForceWWW());\n        $this->assertTrue($middleware->getForceSSL());\n\n        // Middleware forces the redirection eventually\n        /** @var HTTPResponse $response */\n        $response = Director::mockRequest(function ($request) use ($middleware) {\n            return $middleware->process($request, function ($request) {\n                return null;\n            });\n        }, 'http://mysite.com:9090/some-url');\n\n        // Middleware returns non-exception redirect\n        $this->assertEquals('https://www.mysite.com:9090/some-url', $response->getHeader('Location'));\n        $this->assertEquals(301, $response->getStatusCode());\n    }\n\n    /**\n     * Set url to redirect to\n     *\n     * @var string\n     */\n    protected $expectedRedirect = null;\n\n    /**\n     * Expects this test to throw a HTTPResponse_Exception with the given redirect\n     *\n     * @param string $url\n     */\n    protected function expectExceptionRedirect($url)\n    {\n        $this->expectedRedirect = $url;\n    }\n\n    protected function runTest()\n    {\n        try {\n            $result = parent::runTest();\n            if ($this->expectedRedirect) {\n                $this->fail(\"Expected to redirect to {$this->expectedRedirect} but no redirect found\");\n            }\n            return $result;\n        } catch (HTTPResponse_Exception $exception) {\n            // Check URL\n            if ($this->expectedRedirect) {\n                $url = $exception->getResponse()->getHeader('Location');\n                $this->assertEquals($this->expectedRedirect, $url, \"Expected to redirect to {$this->expectedRedirect}\");\n                return null;\n            } else {\n                throw $exception;\n            }\n        }\n    }\n\n    public function testUnmatchedRequestReturns404()\n    {\n        // Remove non-tested rules\n        $this->assertEquals(404, Director::test('no-route')->getStatusCode());\n    }\n\n    public function testIsHttps()\n    {\n        // Trust all IPs for this test\n        /** @var TrustedProxyMiddleware $trustedProxyMiddleware */\n        $trustedProxyMiddleware\n            = Injector::inst()->get(TrustedProxyMiddleware::class);\n        $trustedProxyMiddleware->setTrustedProxyIPs('*');\n\n        // Clear alternate_base_url for this test\n        Director::config()->remove('alternate_base_url');\n\n        // nothing available\n        $headers = [\n            'HTTP_X_FORWARDED_PROTOCOL', 'HTTPS', 'SSL'\n        ];\n        foreach ($headers as $header) {\n            if (isset($_SERVER[$header])) {\n                unset($_SERVER['HTTP_X_FORWARDED_PROTOCOL']);\n            }\n        }\n\n        $this->assertEquals(\n            'no',\n            Director::test('TestController/returnIsSSL')->getBody()\n        );\n\n        $this->assertEquals(\n            'yes',\n            Director::test(\n                'TestController/returnIsSSL',\n                null,\n                null,\n                null,\n                null,\n                ['X-Forwarded-Protocol' => 'https']\n            )->getBody()\n        );\n\n        $this->assertEquals(\n            'no',\n            Director::test(\n                'TestController/returnIsSSL',\n                null,\n                null,\n                null,\n                null,\n                ['X-Forwarded-Protocol' => 'http']\n            )->getBody()\n        );\n\n        $this->assertEquals(\n            'no',\n            Director::test(\n                'TestController/returnIsSSL',\n                null,\n                null,\n                null,\n                null,\n                ['X-Forwarded-Protocol' => 'ftp']\n            )->getBody()\n        );\n\n        // https via HTTPS\n        $_SERVER['HTTPS'] = 'true';\n        $this->assertEquals(\n            'yes',\n            Director::test('TestController/returnIsSSL')->getBody()\n        );\n\n        $_SERVER['HTTPS'] = '1';\n        $this->assertEquals(\n            'yes',\n            Director::test('TestController/returnIsSSL')->getBody()\n        );\n\n        $_SERVER['HTTPS'] = 'off';\n        $this->assertEquals(\n            'no',\n            Director::test('TestController/returnIsSSL')->getBody()\n        );\n\n        // https via SSL\n        $_SERVER['SSL'] = '';\n        $this->assertEquals(\n            'yes',\n            Director::test('TestController/returnIsSSL')->getBody()\n        );\n    }\n\n    public function testTestIgnoresHashes()\n    {\n        //test that hashes are ignored\n        $url = \"TestController/returnGetValue?somekey=key\";\n        $hash = \"#test\";\n        /** @var HTTPRequest $request */\n        $response = Director::test($url . $hash, null, null, null, null, null, null, $request);\n        $this->assertFalse($response->isError());\n        $this->assertEquals('key', $response->getBody());\n        $this->assertEquals($request->getURL(true), $url);\n\n        //test encoded hashes are accepted\n        $url = \"TestController/returnGetValue?somekey=test%23key\";\n        $response = Director::test($url, null, null, null, null, null, null, $request);\n        $this->assertFalse($response->isError());\n        $this->assertEquals('test#key', $response->getBody());\n        $this->assertEquals($request->getURL(true), $url);\n    }\n\n    public function testRequestFilterInDirectorTest()\n    {\n        $filter = new DirectorTest\\TestRequestFilter;\n\n        $processor = new RequestProcessor([$filter]);\n\n        $middlewares = Director::singleton()->getMiddlewares();\n        $middlewares['RequestProcessorMiddleware'] = $processor;\n        Director::singleton()->setMiddlewares($middlewares);\n\n        $response = Director::test('some-dummy-url');\n        $this->assertEquals(404, $response->getStatusCode());\n\n        $this->assertEquals(1, $filter->preCalls);\n        $this->assertEquals(1, $filter->postCalls);\n\n        $filter->failPost = true;\n\n        $response = Director::test('some-dummy-url');\n        $this->assertEquals(500, $response->getStatusCode());\n        $this->assertEquals(_t(Director::class . '.REQUEST_ABORTED', 'Request aborted'), $response->getBody());\n\n        $this->assertEquals(2, $filter->preCalls);\n        $this->assertEquals(2, $filter->postCalls);\n\n        $filter->failPre = true;\n\n        $response = Director::test('some-dummy-url');\n        $this->assertEquals(400, $response->getStatusCode());\n        $this->assertEquals(_t(Director::class . '.INVALID_REQUEST', 'Invalid request'), $response->getBody());\n\n        $this->assertEquals(3, $filter->preCalls);\n\n        // preCall 'true' will trigger an exception and prevent post call execution\n        $this->assertEquals(2, $filter->postCalls);\n    }\n\n    public function testGlobalMiddleware()\n    {\n        $middleware = new DirectorTest\\TestMiddleware;\n        Director::singleton()->setMiddlewares([$middleware]);\n\n        $response = Director::test('some-dummy-url');\n        $this->assertEquals(404, $response->getStatusCode());\n\n        // Both triggered\n        $this->assertEquals(1, $middleware->preCalls);\n        $this->assertEquals(1, $middleware->postCalls);\n\n        $middleware->failPost = true;\n\n        $response = Director::test('some-dummy-url');\n        $this->assertEquals(500, $response->getStatusCode());\n\n        // Both triggered\n        $this->assertEquals(2, $middleware->preCalls);\n        $this->assertEquals(2, $middleware->postCalls);\n\n        $middleware->failPre = true;\n\n        $response = Director::test('some-dummy-url');\n        $this->assertEquals(400, $response->getStatusCode());\n\n        // Pre triggered, post not\n        $this->assertEquals(3, $middleware->preCalls);\n        $this->assertEquals(2, $middleware->postCalls);\n    }\n\n    public function testRouteSpecificMiddleware()\n    {\n        // Inject adapter in place of controller\n        $specificMiddleware = new DirectorTest\\TestMiddleware;\n        Injector::inst()->registerService($specificMiddleware, 'SpecificMiddleware');\n\n        // Register adapter as factory for creating this controller\n        Config::modify()->merge(\n            Injector::class,\n            'ControllerWithMiddleware',\n            [\n                'class' => RequestHandlerMiddlewareAdapter::class,\n                'constructor' => [\n                    '%$' . TestController::class\n                ],\n                'properties' => [\n                    'Middlewares' => [\n                        '%$SpecificMiddleware',\n                    ],\n                ],\n            ]\n        );\n\n        // Global middleware\n        $middleware = new DirectorTest\\TestMiddleware;\n        Director::singleton()->setMiddlewares([$middleware]);\n\n        // URL rules, one of which has a specific middleware\n        Config::modify()->set(\n            Director::class,\n            'rules',\n            [\n                'url-one' => TestController::class,\n                'url-two' => [\n                    'Controller' => 'ControllerWithMiddleware',\n                ],\n            ]\n        );\n\n        // URL without a route-specific middleware\n        Director::test('url-one');\n\n        // Only the global middleware triggered\n        $this->assertEquals(1, $middleware->preCalls);\n        $this->assertEquals(0, $specificMiddleware->postCalls);\n\n        Director::test('url-two');\n\n        // Both triggered on the url with the specific middleware applied\n        $this->assertEquals(2, $middleware->preCalls);\n        $this->assertEquals(1, $specificMiddleware->postCalls);\n    }\n\n    /**\n     * If using phpdbg it returns itself instead of \"cli\" from php_sapi_name()\n     */\n    public function testIsCli()\n    {\n        $this->assertTrue(Director::is_cli(), 'is_cli should be true for PHP CLI and phpdbg');\n    }\n\n    public function testMockRequest()\n    {\n        Director::config()->set('alternate_base_url', 'http://www.mysite.com:9090/some-subdir/');\n\n        // Can handle root-relative $url\n        Director::mockRequest(function (HTTPRequest $request) {\n            $this->assertEquals('some-page/nested', $request->getURL());\n            $this->assertEquals(1, $request->getVar('query'));\n            $this->assertEquals('/some-subdir/some-page/nested', $_SERVER['REQUEST_URI']);\n        }, '/some-subdir/some-page/nested?query=1');\n\n        // Can handle absolute $url\n        Director::mockRequest(function (HTTPRequest $request) {\n            $this->assertEquals('some-page/nested', $request->getURL());\n            $this->assertEquals(1, $request->getVar('query'));\n            $this->assertEquals('/some-subdir/some-page/nested', $_SERVER['REQUEST_URI']);\n        }, 'http://www.mysite.com:9090/some-subdir/some-page/nested?query=1');\n\n        // Can handle relative $url\n        Director::mockRequest(function (HTTPRequest $request) {\n            $this->assertEquals('some-page/nested', $request->getURL());\n            $this->assertEquals(1, $request->getVar('query'));\n            $this->assertEquals('/some-subdir/some-page/nested', $_SERVER['REQUEST_URI']);\n        }, 'some-page/nested?query=1');\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace SilverStripe\\Control;\n\nuse SilverStripe\\CMS\\Model\\SiteTree;\nuse SilverStripe\\Control\\Middleware\\CanonicalURLMiddleware;\nuse SilverStripe\\Control\\Middleware\\HTTPMiddlewareAware;\nuse SilverStripe\\Core\\Config\\Configurable;\nuse SilverStripe\\Core\\Environment;\nuse SilverStripe\\Core\\Extensible;\nuse SilverStripe\\Core\\Injector\\Injectable;\nuse SilverStripe\\Core\\Injector\\Injector;\nuse SilverStripe\\Core\\Kernel;\nuse SilverStripe\\Core\\Path;\nuse SilverStripe\\Dev\\Deprecation;\nuse SilverStripe\\Versioned\\Versioned;\nuse SilverStripe\\View\\Requirements;\nuse SilverStripe\\View\\Requirements_Backend;\nuse SilverStripe\\View\\TemplateGlobalProvider;\n\n/**\n * Director is responsible for processing URLs, and providing environment information.\n *\n * The most important part of director is {@link Director::handleRequest()}, which is passed an HTTPRequest and will\n * execute the appropriate controller.\n *\n * @see Director::handleRequest()\n * @see Director::$rules\n * @skipUpgrade\n */\nclass Director implements TemplateGlobalProvider\n{\n    use Configurable;\n    use Extensible;\n    use Injectable;\n    use HTTPMiddlewareAware;\n\n    /**\n     * Specifies this url is relative to the base.\n     *\n     * @var string\n     */\n    const BASE = 'BASE';\n\n    /**\n     * Specifies this url is relative to the site root.\n     *\n     * @var string\n     */\n    const ROOT = 'ROOT';\n\n    /**\n     * specifies this url is relative to the current request.\n     *\n     * @var string\n     */\n    const REQUEST = 'REQUEST';\n\n    /**\n     * @config\n     * @var array\n     */\n    private static $rules = [];\n\n    /**\n     * Set current page\n     *\n     * @internal\n     * @var SiteTree\n     */\n    private static $current_page;\n\n    /**\n     * @config\n     * @var string\n     */\n    private static $alternate_base_folder;\n\n    /**\n     * Override PUBLIC_DIR. Set to a non-null value to override.\n     * Setting to an empty string will disable public dir.\n     *\n     * @config\n     * @var bool|null\n     */\n    private static $alternate_public_dir = null;\n\n    /**\n     * Base url to populate if cannot be determined otherwise.\n     * Supports back-ticked vars; E.g. '`SS_BASE_URL`'\n     *\n     * @config\n     * @var string\n     */\n    private static $default_base_url = '`SS_BASE_URL`';\n\n    public function __construct()\n    {\n    }\n\n    /**\n     * Test a URL request, returning a response object. This method is a wrapper around\n     * Director::handleRequest() to assist with functional testing. It will execute the URL given, and\n     * return the result as an HTTPResponse object.\n     *\n     * @param string $url The URL to visit.\n     * @param array $postVars The $_POST & $_FILES variables.\n     * @param array|Session $session The {@link Session} object representing the current session.\n     * By passing the same object to multiple  calls of Director::test(), you can simulate a persisted\n     * session.\n     * @param string $httpMethod The HTTP method, such as GET or POST.  It will default to POST if\n     * postVars is set, GET otherwise. Overwritten by $postVars['_method'] if present.\n     * @param string $body The HTTP body.\n     * @param array $headers HTTP headers with key-value pairs.\n     * @param array|Cookie_Backend $cookies to populate $_COOKIE.\n     * @param HTTPRequest $request The {@see SS_HTTP_Request} object generated as a part of this request.\n     *\n     * @return HTTPResponse\n     *\n     * @throws HTTPResponse_Exception\n     */\n    public static function test(\n        $url,\n        $postVars = [],\n        $session = [],\n        $httpMethod = null,\n        $body = null,\n        $headers = [],\n        $cookies = [],\n        &$request = null\n    ) {\n        return static::mockRequest(\n            function (HTTPRequest $request) {\n                return Director::singleton()->handleRequest($request);\n            },\n            $url,\n            $postVars,\n            $session,\n            $httpMethod,\n            $body,\n            $headers,\n            $cookies,\n            $request\n        );\n    }\n\n    /**\n     * Mock a request, passing this to the given callback, before resetting.\n     *\n     * @param callable $callback Action to pass the HTTPRequst object\n     * @param string $url The URL to build\n     * @param array $postVars The $_POST & $_FILES variables.\n     * @param array|Session $session The {@link Session} object representing the current session.\n     * By passing the same object to multiple  calls of Director::test(), you can simulate a persisted\n     * session.\n     * @param string $httpMethod The HTTP method, such as GET or POST.  It will default to POST if\n     * postVars is set, GET otherwise. Overwritten by $postVars['_method'] if present.\n     * @param string $body The HTTP body.\n     * @param array $headers HTTP headers with key-value pairs.\n     * @param array|Cookie_Backend $cookies to populate $_COOKIE.\n     * @param HTTPRequest $request The {@see SS_HTTP_Request} object generated as a part of this request.\n     * @return mixed Result of callback\n     */\n    public static function mockRequest(\n        $callback,\n        $url,\n        $postVars = [],\n        $session = [],\n        $httpMethod = null,\n        $body = null,\n        $headers = [],\n        $cookies = [],\n        &$request = null\n    ) {\n        // Build list of cleanup promises\n        $finally = [];\n\n        /** @var Kernel $kernel */\n        $kernel = Injector::inst()->get(Kernel::class);\n        $kernel->nest();\n        $finally[] = function () use ($kernel) {\n            $kernel->activate();\n        };\n\n        // backup existing vars, and create new vars\n        $existingVars = Environment::getVariables();\n        $finally[] = function () use ($existingVars) {\n            Environment::setVariables($existingVars);\n        };\n        $newVars = $existingVars;\n\n        // These are needed so that calling Director::test() does not muck with whoever is calling it.\n        // Really, it's some inappropriate coupling and should be resolved by making less use of statics.\n        if (class_exists(Versioned::class)) {\n            $oldReadingMode = Versioned::get_reading_mode();\n            $finally[] = function () use ($oldReadingMode) {\n                Versioned::set_reading_mode($oldReadingMode);\n            };\n        }\n\n        // Default httpMethod\n        $newVars['_SERVER']['REQUEST_METHOD'] = $httpMethod ?: ($postVars ? \"POST\" : \"GET\");\n        $newVars['_POST'] = (array)$postVars;\n\n        // Setup session\n        if ($session instanceof Session) {\n            // Note: If passing $session as object, ensure that changes are written back\n            // This is important for classes such as FunctionalTest which emulate cross-request persistence\n            $newVars['_SESSION'] = $sessionArray = $session->getAll() ?: [];\n            $finally[] = function () use ($session, $sessionArray) {\n                if (isset($_SESSION)) {\n                    // Set new / updated keys\n                    foreach ($_SESSION as $key => $value) {\n                        $session->set($key, $value);\n                    }\n                    // Unset removed keys\n                    foreach (array_diff_key($sessionArray ?? [], $_SESSION) as $key => $value) {\n                        $session->clear($key);\n                    }\n                }\n            };\n        } else {\n            $newVars['_SESSION'] = $session ?: [];\n        }\n\n        // Setup cookies\n        $cookieJar = $cookies instanceof Cookie_Backend\n            ? $cookies\n            : Injector::inst()->createWithArgs(Cookie_Backend::class, [$cookies ?: []]);\n        $newVars['_COOKIE'] = $cookieJar->getAll(false);\n        Cookie::config()->update('report_errors', false);\n        Injector::inst()->registerService($cookieJar, Cookie_Backend::class);\n\n        // Backup requirements\n        $existingRequirementsBackend = Requirements::backend();\n        Requirements::set_backend(Requirements_Backend::create());\n        $finally[] = function () use ($existingRequirementsBackend) {\n            Requirements::set_backend($existingRequirementsBackend);\n        };\n\n        // Strip any hash\n        $url = strtok($url ?? '', '#');\n\n        // Handle absolute URLs\n        // If a port is mentioned in the absolute URL, be sure to add that into the HTTP host\n        $urlHostPort = static::parseHost($url);\n        if ($urlHostPort) {\n            $newVars['_SERVER']['HTTP_HOST'] = $urlHostPort;\n        }\n\n        // Ensure URL is properly made relative.\n        // Example: url passed is \"/ss31/my-page\" (prefixed with BASE_URL), this should be changed to \"my-page\"\n        $url = self::makeRelative($url);\n        if (strpos($url ?? '', '?') !== false) {\n            list($url, $getVarsEncoded) = explode('?', $url ?? '', 2);\n            parse_str($getVarsEncoded ?? '', $newVars['_GET']);\n        } else {\n            $newVars['_GET'] = [];\n        }\n        $newVars['_SERVER']['REQUEST_URI'] = Director::baseURL() . ltrim($url ?? '', '/');\n        $newVars['_REQUEST'] = array_merge($newVars['_GET'], $newVars['_POST']);\n\n        // Normalise vars\n        $newVars = HTTPRequestBuilder::cleanEnvironment($newVars);\n\n        // Create new request\n        $request = HTTPRequestBuilder::createFromVariables($newVars, $body, ltrim($url ?? '', '/'));\n        if ($headers) {\n            foreach ($headers as $k => $v) {\n                $request->addHeader($k, $v);\n            }\n        }\n\n        // Apply new vars to environment\n        Environment::setVariables($newVars);\n\n        try {\n            // Normal request handling\n            return call_user_func($callback, $request);\n        } finally {\n            // Restore state in reverse order to assignment\n            foreach (array_reverse($finally) as $callback) {\n                call_user_func($callback);\n            }\n        }\n    }\n\n    /**\n     * Process the given URL, creating the appropriate controller and executing it.\n     *\n     * Request processing is handled as follows:\n     * - Director::handleRequest($request) checks each of the Director rules and identifies a controller\n     *   to handle this request.\n     * - Controller::handleRequest($request) is then called.  This will find a rule to handle the URL,\n     *   and call the rule handling method.\n     * - RequestHandler::handleRequest($request) is recursively called whenever a rule handling method\n     *   returns a RequestHandler object.\n     *\n     * In addition to request processing, Director will manage the session, and perform the output of\n     * the actual response to the browser.\n     *\n     * @param HTTPRequest $request\n     * @return HTTPResponse\n     * @throws HTTPResponse_Exception\n     */\n    public function handleRequest(HTTPRequest $request)\n    {\n        Injector::inst()->registerService($request, HTTPRequest::class);\n\n        $rules = Director::config()->uninherited('rules');\n\n        $this->extend('updateRules', $rules);\n\n        // Default handler - mo URL rules matched, so return a 404 error.\n        $handler = function () {\n            return new HTTPResponse('No URL rule was matched', 404);\n        };\n\n        foreach ($rules as $pattern => $controllerOptions) {\n            // Match pattern\n            $arguments = $request->match($pattern, true);\n            if ($arguments == false) {\n                continue;\n            }\n\n            // Normalise route rule\n            if (is_string($controllerOptions)) {\n                if (substr($controllerOptions ?? '', 0, 2) == '->') {\n                    $controllerOptions = ['Redirect' => substr($controllerOptions ?? '', 2)];\n                } else {\n                    $controllerOptions = ['Controller' => $controllerOptions];\n                }\n            }\n            $request->setRouteParams($controllerOptions);\n\n            // controllerOptions provide some default arguments\n            $arguments = array_merge($controllerOptions, $arguments);\n\n            // Pop additional tokens from the tokenizer if necessary\n            if (isset($controllerOptions['_PopTokeniser'])) {\n                $request->shift($controllerOptions['_PopTokeniser']);\n            }\n\n            // Handler for redirection\n            if (isset($arguments['Redirect'])) {\n                $handler = function () use ($arguments) {\n                    // Redirection\n                    $response = new HTTPResponse();\n                    $response->redirect(static::absoluteURL($arguments['Redirect']));\n                    return $response;\n                };\n                break;\n            }\n\n            // Handler for constructing and calling a controller\n            $handler = function (HTTPRequest $request) use ($arguments) {\n                try {\n                    /** @var RequestHandler $controllerObj */\n                    $controllerObj = Injector::inst()->create($arguments['Controller']);\n                    return $controllerObj->handleRequest($request);\n                } catch (HTTPResponse_Exception $responseException) {\n                    return $responseException->getResponse();\n                }\n            };\n            break;\n        }\n\n        // Call the handler with the configured middlewares\n        $response = $this->callMiddleware($request, $handler);\n\n        // Note that if a different request was previously registered, this will now be lost\n        // In these cases it's better to use Kernel::nest() prior to kicking off a nested request\n        Injector::inst()->unregisterNamedObject(HTTPRequest::class);\n\n        return $response;\n    }\n\n    /**\n     * Returns indication whether the manifest cache has been flushed\n     * in the beginning of the current request.\n     *\n     * That could mean the current active request has `?flush` parameter.\n     * Another possibility is a race condition when the current request\n     * hits the server in between another request `?flush` authorisation\n     * and a redirect to the actual flush.\n     *\n     * @return bool\n     *\n     * @deprecated 4.12.0 Use Kernel::isFlushed instead\n     */\n    public static function isManifestFlushed()\n    {\n        Deprecation::notice('4.12.0', 'Use Kernel::isFlushed instead');\n        $kernel = Injector::inst()->get(Kernel::class);\n\n        // Only CoreKernel implements this method at the moment\n        // Introducing it to the Kernel interface is a breaking change\n        if (method_exists($kernel, 'isFlushed')) {\n            return $kernel->isFlushed();\n        }\n\n        $classManifest = $kernel->getClassLoader()->getManifest();\n        return $classManifest->isFlushed();\n    }\n\n    /**\n     * Return the {@link SiteTree} object that is currently being viewed. If there is no SiteTree\n     * object to return, then this will return the current controller.\n     *\n     * @return SiteTree|Controller\n     */\n    public static function get_current_page()\n    {\n        return self::$current_page ? self::$current_page : Controller::curr();\n    }\n\n    /**\n     * Set the currently active {@link SiteTree} object that is being used to respond to the request.\n     *\n     * @param SiteTree $page\n     */\n    public static function set_current_page($page)\n    {\n        self::$current_page = $page;\n    }\n\n    /**\n     * Converts the given path or url into an absolute url. This method follows the below rules:\n     * - Absolute urls (e.g. `http://localhost`) are not modified\n     * - Relative urls (e.g. `//localhost`) have current protocol added (`http://localhost`)\n     * - Absolute paths (e.g. `/base/about-us`) are resolved by adding the current protocol and host (`http://localhost/base/about-us`)\n     * - Relative paths (e.g. `about-us/staff`) must be resolved using one of three methods, disambiguated via the $relativeParent argument:\n     *     - BASE - Append this path to the base url (i.e. behaves as though `<base>` tag is provided in a html document). This is the default.\n     *     - REQUEST - Resolve this path to the current url (i.e. behaves as though no `<base>` tag is provided in a html document)\n     *     - ROOT - Treat this as though it was an absolute path, and append it to the protocol and hostname.\n     *\n     * @param string $url The url or path to resolve to absolute url.\n     * @param string $relativeParent Disambiguation method to use for evaluating relative paths\n     * @return string The absolute url\n     */\n    public static function absoluteURL($url, $relativeParent = self::BASE)\n    {\n        if (is_bool($relativeParent)) {\n            // Deprecate old boolean second parameter\n            Deprecation::notice('5.0', 'Director::absoluteURL takes an explicit parent for relative url');\n            $relativeParent = $relativeParent ? self::BASE : self::REQUEST;\n        }\n\n        // Check if there is already a protocol given\n        if (preg_match('/^http(s?):\\/\\//', $url ?? '')) {\n            return $url;\n        }\n\n        // Absolute urls without protocol are added\n        // E.g. //google.com -> http://google.com\n        if (strpos($url ?? '', '//') === 0) {\n            return self::protocol() . substr($url ?? '', 2);\n        }\n\n        // Determine method for mapping the parent to this relative url\n        if ($relativeParent === self::ROOT || self::is_root_relative_url($url)) {\n            // Root relative urls always should be evaluated relative to the root\n            $parent = self::protocolAndHost();\n        } elseif ($relativeParent === self::REQUEST) {\n            // Request relative urls rely on the REQUEST_URI param (old default behaviour)\n            if (!isset($_SERVER['REQUEST_URI'])) {\n                return false;\n            }\n            $parent = dirname($_SERVER['REQUEST_URI'] . 'x');\n        } else {\n            // Default to respecting site base_url\n            $parent = self::absoluteBaseURL();\n        }\n\n        // Map empty urls to relative slash and join to base\n        if (empty($url) || $url === '.' || $url === './') {\n            $url = '/';\n        }\n        return Controller::join_links($parent, $url);\n    }\n\n    /**\n     * Return only host (and optional port) part of a url\n     *\n     * @param string $url\n     * @return string|null Hostname, and optional port, or null if not a valid host\n     */\n    protected static function parseHost($url)\n    {\n        // Get base hostname\n        $host = parse_url($url ?? '', PHP_URL_HOST);\n        if (!$host) {\n            return null;\n        }\n\n        // Include port\n        $port = parse_url($url ?? '', PHP_URL_PORT);\n        if ($port) {\n            $host .= ':' . $port;\n        }\n\n        return $host;\n    }\n\n    /**\n     * Validate user and password in URL, disallowing slashes\n     *\n     * @param string $url\n     * @return bool\n     */\n    protected static function validateUserAndPass($url)\n    {\n        $parsedURL = parse_url($url ?? '');\n\n        // Validate user (disallow slashes)\n        if (!empty($parsedURL['user']) && strstr($parsedURL['user'] ?? '', '\\\\')) {\n            return false;\n        }\n        if (!empty($parsedURL['pass']) && strstr($parsedURL['pass'] ?? '', '\\\\')) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * A helper to determine the current hostname used to access the site.\n     * The following are used to determine the host (in order)\n     *  - Director.alternate_base_url (if it contains a domain name)\n     *  - Trusted proxy headers\n     *  - HTTP Host header\n     *  - SS_BASE_URL env var\n     *  - SERVER_NAME\n     *  - gethostname()\n     *\n     * @param HTTPRequest $request\n     * @return string Host name, including port (if present)\n     */\n    public static function host(HTTPRequest $request = null)\n    {\n        // Check if overridden by alternate_base_url\n        if ($baseURL = self::config()->get('alternate_base_url')) {\n            $baseURL = Injector::inst()->convertServiceProperty($baseURL);\n            $host = static::parseHost($baseURL);\n            if ($host) {\n                return $host;\n            }\n        }\n\n        $request = static::currentRequest($request);\n        if ($request && ($host = $request->getHeader('Host'))) {\n            return $host;\n        }\n\n        // Check given header\n        if (isset($_SERVER['HTTP_HOST'])) {\n            return $_SERVER['HTTP_HOST'];\n        }\n\n        // Check base url\n        if ($baseURL = self::config()->uninherited('default_base_url')) {\n            $baseURL = Injector::inst()->convertServiceProperty($baseURL);\n            $host = static::parseHost($baseURL);\n            if ($host) {\n                return $host;\n            }\n        }\n\n        // Fail over to server_name (least reliable)\n        return isset($_SERVER['SERVER_NAME']) ? $_SERVER['SERVER_NAME'] : gethostname();\n    }\n\n    /**\n     * Return port used for the base URL.\n     * Note, this will be null if not specified, in which case you should assume the default\n     * port for the current protocol.\n     *\n     * @param HTTPRequest $request\n     * @return int|null\n     */\n    public static function port(HTTPRequest $request = null)\n    {\n        $host = static::host($request);\n        return (int)parse_url($host ?? '', PHP_URL_PORT) ?: null;\n    }\n\n    /**\n     * Return host name without port\n     *\n     * @param HTTPRequest|null $request\n     * @return string|null\n     */\n    public static function hostName(HTTPRequest $request = null)\n    {\n        $host = static::host($request);\n        return parse_url($host ?? '', PHP_URL_HOST) ?: null;\n    }\n\n    /**\n     * Returns the domain part of the URL 'http://www.mysite.com'. Returns FALSE is this environment\n     * variable isn't set.\n     *\n     * @param HTTPRequest $request\n     * @return bool|string\n     */\n    public static function protocolAndHost(HTTPRequest $request = null)\n    {\n        return static::protocol($request) . static::host($request);\n    }\n\n    /**\n     * Return the current protocol that the site is running under.\n     *\n     * @param HTTPRequest $request\n     * @return string\n     */\n    public static function protocol(HTTPRequest $request = null)\n    {\n        return (self::is_https($request)) ? 'https://' : 'http://';\n    }\n\n    /**\n     * Return whether the site is running as under HTTPS.\n     *\n     * @param HTTPRequest $request\n     * @return bool\n     */\n    public static function is_https(HTTPRequest $request = null)\n    {\n        // Check override from alternate_base_url\n        if ($baseURL = self::config()->uninherited('alternate_base_url')) {\n            $baseURL = Injector::inst()->convertServiceProperty($baseURL);\n            $protocol = parse_url($baseURL ?? '', PHP_URL_SCHEME);\n            if ($protocol) {\n                return $protocol === 'https';\n            }\n        }\n\n        // Check the current request\n        $request = static::currentRequest($request);\n        if ($request && ($scheme = $request->getScheme())) {\n            return $scheme === 'https';\n        }\n\n        // Check default_base_url\n        if ($baseURL = self::config()->uninherited('default_base_url')) {\n            $baseURL = Injector::inst()->convertServiceProperty($baseURL);\n            $protocol = parse_url($baseURL ?? '', PHP_URL_SCHEME);\n            if ($protocol) {\n                return $protocol === 'https';\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Return the root-relative url for the baseurl\n     *\n     * @return string Root-relative url with trailing slash.\n     */\n    public static function baseURL()\n    {\n        // Check override base_url\n        $alternate = self::config()->get('alternate_base_url');\n        if ($alternate) {\n            $alternate = Injector::inst()->convertServiceProperty($alternate);\n            return rtrim(parse_url($alternate ?? '', PHP_URL_PATH) ?? '', '/') . '/';\n        }\n\n        // Get env base url\n        $baseURL = rtrim(BASE_URL, '/') . '/';\n\n        // Check if BASE_SCRIPT_URL is defined\n        // e.g. `index.php/`\n        if (defined('BASE_SCRIPT_URL')) {\n            return $baseURL . BASE_SCRIPT_URL;\n        }\n\n        return $baseURL;\n    }\n\n    /**\n     * Returns the root filesystem folder for the site. It will be automatically calculated unless\n     * it is overridden with {@link setBaseFolder()}.\n     *\n     * @return string\n     */\n    public static function baseFolder()\n    {\n        $alternate = Director::config()->uninherited('alternate_base_folder');\n        return $alternate ?: BASE_PATH;\n    }\n\n    /**\n     * Check if using a separate public dir, and if so return this directory\n     * name.\n     *\n     * This will be removed in 5.0 and fixed to 'public'\n     *\n     * @return string\n     */\n    public static function publicDir()\n    {\n        $alternate = self::config()->uninherited('alternate_public_dir');\n        if (isset($alternate)) {\n            return $alternate;\n        }\n        return PUBLIC_DIR;\n    }\n\n    /**\n     * Gets the webroot of the project, which may be a subfolder of {@see baseFolder()}\n     *\n     * @return string\n     */\n    public static function publicFolder()\n    {\n        $folder = self::baseFolder();\n        $publicDir = self::publicDir();\n        if ($publicDir) {\n            return Path::join($folder, $publicDir);\n        }\n\n        return $folder;\n    }\n\n    /**\n     * Turns an absolute URL or folder into one that's relative to the root of the site. This is useful\n     * when turning a URL into a filesystem reference, or vice versa.\n     *\n     * Note: You should check {@link Director::is_site_url()} if making an untrusted url relative prior\n     * to calling this function.\n     *\n     * @param string $url Accepts both a URL or a filesystem path.\n     * @return string\n     */\n    public static function makeRelative($url)\n    {\n        // Allow for the accidental inclusion whitespace and // in the URL\n        $url = preg_replace('#([^:])//#', '\\\\1/', trim($url ?? ''));\n\n        // If using a real url, remove protocol / hostname / auth / port\n        if (preg_match('#^(?<protocol>https?:)?//(?<hostpart>[^/]*)(?<url>(/.*)?)$#i', $url ?? '', $matches)) {\n            $url = $matches['url'];\n        }\n\n        // Empty case\n        if (trim($url ?? '', '\\\\/') === '') {\n            return '';\n        }\n\n        // Remove base folder or url\n        foreach ([self::publicFolder(), self::baseFolder(), self::baseURL()] as $base) {\n            // Ensure single / doesn't break comparison (unless it would make base empty)\n            $base = rtrim($base ?? '', '\\\\/') ?: $base;\n            if (stripos($url ?? '', $base ?? '') === 0) {\n                return ltrim(substr($url ?? '', strlen($base ?? '')), '\\\\/');\n            }\n        }\n\n        // Nothing matched, fall back to returning the original URL\n        return $url;\n    }\n\n    /**\n     * Returns true if a given path is absolute. Works under both *nix and windows systems.\n     *\n     * @param string $path\n     *\n     * @return bool\n     */\n    public static function is_absolute($path)\n    {\n        if (empty($path)) {\n            return false;\n        }\n        if ($path[0] == '/' || $path[0] == '\\\\') {\n            return true;\n        }\n        return preg_match('/^[a-zA-Z]:[\\\\\\\\\\/]/', $path ?? '') == 1;\n    }\n\n    /**\n     * Determine if the url is root relative (i.e. starts with /, but not with //) SilverStripe\n     * considers root relative urls as a subset of relative urls.\n     *\n     * @param string $url\n     *\n     * @return bool\n     */\n    public static function is_root_relative_url($url)\n    {\n        return strpos($url ?? '', '/') === 0 && strpos($url ?? '', '//') !== 0;\n    }\n\n    /**\n     * Checks if a given URL is absolute (e.g. starts with 'http://' etc.). URLs beginning with \"//\"\n     * are treated as absolute, as browsers take this to mean the same protocol as currently being used.\n     *\n     * Useful to check before redirecting based on a URL from user submissions through $_GET or $_POST,\n     * and avoid phishing attacks by redirecting to an attackers server.\n     *\n     * Note: Can't solely rely on PHP's parse_url() , since it is not intended to work with relative URLs\n     * or for security purposes. filter_var($url, FILTER_VALIDATE_URL) has similar problems.\n     *\n     * @param string $url\n     *\n     * @return bool\n     */\n    public static function is_absolute_url($url)\n    {\n        // Strip off the query and fragment parts of the URL before checking\n        if (($queryPosition = strpos($url ?? '', '?')) !== false) {\n            $url = substr($url ?? '', 0, $queryPosition - 1);\n        }\n        if (($hashPosition = strpos($url ?? '', '#')) !== false) {\n            $url = substr($url ?? '', 0, $hashPosition - 1);\n        }\n        $colonPosition = strpos($url ?? '', ':');\n        $slashPosition = strpos($url ?? '', '/');\n        return (\n            // Base check for existence of a host on a compliant URL\n            parse_url($url ?? '', PHP_URL_HOST)\n            // Check for more than one leading slash (forward or backward) without a protocol.\n            // While not a RFC compliant absolute URL, it is completed to a valid URL by some browsers,\n            // and hence a potential security risk. Single leading slashes are not an issue though.\n            // Note: Need 4 backslashes to have a single non-escaped backslash for regex.\n            || preg_match('%^\\s*(\\\\\\\\|/){2,}%', $url ?? '')\n            || (\n                // If a colon is found, check if it's part of a valid scheme definition\n                // (meaning its not preceded by a slash).\n                $colonPosition !== false\n                && ($slashPosition === false || $colonPosition < $slashPosition)\n            )\n        );\n    }\n\n    /**\n     * Checks if a given URL is relative (or root relative) by checking {@link is_absolute_url()}.\n     *\n     * @param string $url\n     *\n     * @return bool\n     */\n    public static function is_relative_url($url)\n    {\n        return !static::is_absolute_url($url);\n    }\n\n    /**\n     * Checks if the given URL is belonging to this \"site\" (not an external link). That's the case if\n     * the URL is relative, as defined by {@link is_relative_url()}, or if the host matches\n     * {@link protocolAndHost()}.\n     *\n     * Useful to check before redirecting based on a URL from user submissions through $_GET or $_POST,\n     * and avoid phishing attacks by redirecting to an attackers server.\n     *\n     * Provides an extension point to allow extra checks on the URL to allow some external URLs,\n     * e.g. links on secondary domains that point to the same CMS, or subsite domains.\n     *\n     * @param string $url\n     *\n     * @return bool\n     */\n    public static function is_site_url($url)\n    {\n        // Validate user and password\n        if (!static::validateUserAndPass($url)) {\n            return false;\n        }\n\n        // Validate host[:port]\n        $urlHost = static::parseHost($url);\n        if ($urlHost && $urlHost === static::host()) {\n            return true;\n        }\n\n        // Allow extensions to weigh in\n        $isSiteUrl = false;\n        static::singleton()->extend('updateIsSiteUrl', $isSiteUrl, $url);\n        if ($isSiteUrl) {\n            return true;\n        }\n\n        // Relative urls always are site urls\n        return self::is_relative_url($url);\n    }\n\n    /**\n     * Given a filesystem reference relative to the site root, return the full file-system path.\n     *\n     * @param string $file\n     *\n     * @return string\n     */\n    public static function getAbsFile($file)\n    {\n        // If already absolute\n        if (self::is_absolute($file)) {\n            return $file;\n        }\n\n        // If path is relative to public folder search there first\n        if (self::publicDir()) {\n            $path = Path::join(self::publicFolder(), $file);\n            if (file_exists($path ?? '')) {\n                return $path;\n            }\n        }\n\n        // Default to base folder\n        return Path::join(self::baseFolder(), $file);\n    }\n\n    /**\n     * Returns true if the given file exists. Filename should be relative to the site root.\n     *\n     * @param $file\n     *\n     * @return bool\n     */\n    public static function fileExists($file)\n    {\n        // replace any appended query-strings, e.g. /path/to/foo.php?bar=1 to /path/to/foo.php\n        $file = preg_replace('/([^\\?]*)?.*/', '$1', $file ?? '');\n        return file_exists(Director::getAbsFile($file) ?? '');\n    }\n\n    /**\n     * Returns the Absolute URL of the site root.\n     *\n     * @return string\n     */\n    public static function absoluteBaseURL()\n    {\n        return self::absoluteURL(\n            self::baseURL(),\n            self::ROOT\n        );\n    }\n\n    /**\n     * Returns the Absolute URL of the site root, embedding the current basic-auth credentials into\n     * the URL.\n     *\n     * @param HTTPRequest|null $request\n     * @return string\n     */\n    public static function absoluteBaseURLWithAuth(HTTPRequest $request = null)\n    {\n        // Detect basic auth\n        $login = '';\n        if ($request) {\n            $user = $request->getHeader('PHP_AUTH_USER');\n            if ($user) {\n                $password = $request->getHeader('PHP_AUTH_PW');\n                $login = sprintf(\"%s:%s@\", $user, $password);\n            }\n        }\n\n        return Director::protocol($request) . $login . static::host($request) . Director::baseURL();\n    }\n\n    /**\n     * Skip any further processing and immediately respond with a redirect to the passed URL.\n     *\n     * @param string $destURL\n     * @throws HTTPResponse_Exception\n     */\n    protected static function force_redirect($destURL)\n    {\n        // Redirect to installer\n        $response = new HTTPResponse();\n        $response->redirect($destURL, 301);\n        throw new HTTPResponse_Exception($response);\n    }\n\n    /**\n     * Force the site to run on SSL.\n     *\n     * To use, call from _config.php. For example:\n     * <code>\n     * if (Director::isLive()) Director::forceSSL();\n     * </code>\n     *\n     * If you don't want your entire site to be on SSL, you can pass an array of PCRE regular expression\n     * patterns for matching relative URLs. For example:\n     * <code>\n     * if (Director::isLive()) Director::forceSSL(array('/^admin/', '/^Security/'));\n     * </code>\n     *\n     * If you want certain parts of your site protected under a different domain, you can specify\n     * the domain as an argument:\n     * <code>\n     * if (Director::isLive()) Director::forceSSL(array('/^admin/', '/^Security/'), 'secure.mysite.com');\n     * </code>\n     *\n     * Note that the session data will be lost when moving from HTTP to HTTPS. It is your responsibility\n     * to ensure that this won't cause usability problems.\n     *\n     * CAUTION: This does not respect the site environment mode. You should check this\n     * as per the above examples using Director::isLive() or Director::isTest() for example.\n     *\n     * @param array $patterns Array of regex patterns to match URLs that should be HTTPS.\n     * @param string $secureDomain Secure domain to redirect to. Defaults to the current domain.\n     * Can include port number.\n     * @param HTTPRequest|null $request Request object to check\n     */\n    public static function forceSSL($patterns = null, $secureDomain = null, HTTPRequest $request = null)\n    {\n        $handler = CanonicalURLMiddleware::singleton()->setForceSSL(true);\n        if ($patterns) {\n            $handler->setForceSSLPatterns($patterns);\n        }\n        if ($secureDomain) {\n            $handler->setForceSSLDomain($secureDomain);\n        }\n        $handler->throwRedirectIfNeeded($request);\n    }\n\n    /**\n     * Force a redirect to a domain starting with \"www.\"\n     *\n     * @param HTTPRequest $request\n     */\n    public static function forceWWW(HTTPRequest $request = null)\n    {\n        $handler = CanonicalURLMiddleware::singleton()->setForceWWW(true);\n        $handler->throwRedirectIfNeeded($request);\n    }\n\n    /**\n     * Checks if the current HTTP-Request is an \"Ajax-Request\" by checking for a custom header set by\n     * jQuery or whether a manually set request-parameter 'ajax' is present.\n     *\n     * Note that if you plan to use this to alter your HTTP response on a cached page,\n     * you should add X-Requested-With to the Vary header.\n     *\n     * @param HTTPRequest $request\n     * @return bool\n     */\n    public static function is_ajax(HTTPRequest $request = null)\n    {\n        $request = self::currentRequest($request);\n        if ($request) {\n            return $request->isAjax();\n        }\n\n        return (\n            isset($_REQUEST['ajax']) ||\n            (isset($_SERVER['HTTP_X_REQUESTED_WITH']) && $_SERVER['HTTP_X_REQUESTED_WITH'] == \"XMLHttpRequest\")\n        );\n    }\n\n    /**\n     * Returns true if this script is being run from the command line rather than the web server.\n     *\n     * @return bool\n     */\n    public static function is_cli()\n    {\n        return Environment::isCli();\n    }\n\n    /**\n     * Can also be checked with {@link Director::isDev()}, {@link Director::isTest()}, and\n     * {@link Director::isLive()}.\n     *\n     * @return string\n     */\n    public static function get_environment_type()\n    {\n        /** @var Kernel $kernel */\n        $kernel = Injector::inst()->get(Kernel::class);\n        return $kernel->getEnvironment();\n    }\n\n\n    /**\n     * Returns the session environment override\n     *\n     * @internal This method is not a part of public API and will be deleted without a deprecation warning\n     *\n     * @param HTTPRequest $request\n     *\n     * @return string|null null if not overridden, otherwise the actual value\n     */\n    public static function get_session_environment_type(HTTPRequest $request = null)\n    {\n        $request = static::currentRequest($request);\n\n        if (!$request) {\n            return null;\n        }\n\n        $session = $request->getSession();\n\n        if (!empty($session->get('isDev'))) {\n            return Kernel::DEV;\n        } elseif (!empty($session->get('isTest'))) {\n            return Kernel::TEST;\n        }\n    }\n\n    /**\n     * This function will return true if the site is in a live environment. For information about\n     * environment types, see {@link Director::set_environment_type()}.\n     *\n     * @return bool\n     */\n    public static function isLive()\n    {\n        return self::get_environment_type() === 'live';\n    }\n\n    /**\n     * This function will return true if the site is in a development environment. For information about\n     * environment types, see {@link Director::set_environment_type()}.\n     *\n     * @return bool\n     */\n    public static function isDev()\n    {\n        return self::get_environment_type() === 'dev';\n    }\n\n    /**\n     * This function will return true if the site is in a test environment. For information about\n     * environment types, see {@link Director::set_environment_type()}.\n     *\n     * @return bool\n     */\n    public static function isTest()\n    {\n        return self::get_environment_type() === 'test';\n    }\n\n    /**\n     * Returns an array of strings of the method names of methods on the call that should be exposed\n     * as global variables in the templates.\n     *\n     * @return array\n     */\n    public static function get_template_global_variables()\n    {\n        return [\n            'absoluteBaseURL',\n            'baseURL',\n            'isDev',\n            'isTest',\n            'isLive',\n            'is_ajax',\n            'isAjax' => 'is_ajax',\n            'BaseHref' => 'absoluteBaseURL',    //@deprecated 3.0\n        ];\n    }\n\n    /**\n     * Helper to validate or check the current request object\n     *\n     * @param HTTPRequest $request\n     * @return HTTPRequest Request object if one is both current and valid\n     */\n    protected static function currentRequest(HTTPRequest $request = null)\n    {\n        // Ensure we only use a registered HTTPRequest and don't\n        // incidentally construct a singleton\n        if (!$request && Injector::inst()->has(HTTPRequest::class)) {\n            $request = Injector::inst()->get(HTTPRequest::class);\n        }\n        return $request;\n    }\n}\n", "<?php\n\nnamespace SilverStripe\\Control\\Tests;\n\nuse SilverStripe\\Control\\Cookie_Backend;\nuse SilverStripe\\Control\\Director;\nuse SilverStripe\\Control\\HTTPRequest;\nuse SilverStripe\\Control\\HTTPResponse;\nuse SilverStripe\\Control\\HTTPResponse_Exception;\nuse SilverStripe\\Control\\Middleware\\CanonicalURLMiddleware;\nuse SilverStripe\\Control\\Middleware\\RequestHandlerMiddlewareAdapter;\nuse SilverStripe\\Control\\Middleware\\TrustedProxyMiddleware;\nuse SilverStripe\\Control\\RequestProcessor;\nuse SilverStripe\\Control\\Tests\\DirectorTest\\TestController;\nuse SilverStripe\\Core\\Config\\Config;\nuse SilverStripe\\Core\\Injector\\Injector;\nuse SilverStripe\\Core\\Environment;\nuse SilverStripe\\Core\\Kernel;\nuse SilverStripe\\Dev\\SapphireTest;\n\n/**\n * @todo test Director::alternateBaseFolder()\n */\nclass DirectorTest extends SapphireTest\n{\n    protected static $extra_controllers = [\n        TestController::class,\n    ];\n\n    private $originalEnvType;\n\n    protected function setUp(): void\n    {\n        parent::setUp();\n        Director::config()->set('alternate_base_url', 'http://www.mysite.com:9090/');\n\n        $this->originalEnvType = Environment::getEnv('SS_ENVIRONMENT_TYPE');\n\n        // Ensure redirects enabled on all environments and global state doesn't affect the tests\n        CanonicalURLMiddleware::singleton()\n            ->setForceSSL(null)\n            ->setForceSSLDomain(null)\n            ->setForceSSLPatterns([])\n            ->setForceWWW(null)\n            ->setEnabledEnvs(true);\n        $this->expectedRedirect = null;\n    }\n\n    protected function tearDown(): void\n    {\n        Environment::setEnv('SS_ENVIRONMENT_TYPE', $this->originalEnvType);\n        parent::tearDown();\n    }\n\n    protected function getExtraRoutes()\n    {\n        $rules = parent::getExtraRoutes();\n\n        $rules['DirectorTestRule/$Action/$ID/$OtherID'] = TestController::class;\n        $rules['en-nz/$Action/$ID/$OtherID'] = [\n            'Controller' => TestController::class,\n            'Locale' => 'en_NZ',\n        ];\n        return $rules;\n    }\n\n    protected function setUpRoutes()\n    {\n        // Don't merge with any existing rules\n        Director::config()->set('rules', $this->getExtraRoutes());\n    }\n\n    public function testFileExists()\n    {\n        $tempFileName = 'DirectorTest_testFileExists.tmp';\n        $tempFilePath = TEMP_PATH . DIRECTORY_SEPARATOR . $tempFileName;\n\n        // create temp file\n        file_put_contents($tempFilePath ?? '', '');\n\n        $this->assertTrue(\n            Director::fileExists($tempFilePath),\n            'File exist check with absolute path'\n        );\n\n        $this->assertTrue(\n            Director::fileExists($tempFilePath . '?queryparams=1&foo[bar]=bar'),\n            'File exist check with query params ignored'\n        );\n\n        unlink($tempFilePath ?? '');\n    }\n\n    public function testAbsoluteURL()\n    {\n        Director::config()->set('alternate_base_url', 'http://www.mysite.com:9090/mysite/');\n        $_SERVER['REQUEST_URI'] = \"http://www.mysite.com:9090/mysite/sub-page/\";\n\n        //test empty / local urls\n        foreach (['', './', '.'] as $url) {\n            $this->assertEquals(\"http://www.mysite.com:9090/mysite/\", Director::absoluteURL($url, Director::BASE));\n            $this->assertEquals(\"http://www.mysite.com:9090/\", Director::absoluteURL($url, Director::ROOT));\n            $this->assertEquals(\"http://www.mysite.com:9090/mysite/sub-page/\", Director::absoluteURL($url, Director::REQUEST));\n        }\n\n        // Test site root url\n        $this->assertEquals(\"http://www.mysite.com:9090/\", Director::absoluteURL('/'));\n\n        // Test Director::BASE\n        $this->assertEquals('http://www.mysite.com:9090/', Director::absoluteURL('http://www.mysite.com:9090/', Director::BASE));\n        $this->assertEquals('http://www.mytest.com', Director::absoluteURL('http://www.mytest.com', Director::BASE));\n        $this->assertEquals(\"http://www.mysite.com:9090/test\", Director::absoluteURL(\"http://www.mysite.com:9090/test\", Director::BASE));\n        $this->assertEquals(\"http://www.mysite.com:9090/root\", Director::absoluteURL(\"/root\", Director::BASE));\n        $this->assertEquals(\"http://www.mysite.com:9090/root/url\", Director::absoluteURL(\"/root/url\", Director::BASE));\n\n        // Test Director::ROOT\n        $this->assertEquals('http://www.mysite.com:9090/', Director::absoluteURL('http://www.mysite.com:9090/', Director::ROOT));\n        $this->assertEquals('http://www.mytest.com', Director::absoluteURL('http://www.mytest.com', Director::ROOT));\n        $this->assertEquals(\"http://www.mysite.com:9090/test\", Director::absoluteURL(\"http://www.mysite.com:9090/test\", Director::ROOT));\n        $this->assertEquals(\"http://www.mysite.com:9090/root\", Director::absoluteURL(\"/root\", Director::ROOT));\n        $this->assertEquals(\"http://www.mysite.com:9090/root/url\", Director::absoluteURL(\"/root/url\", Director::ROOT));\n\n        // Test Director::REQUEST\n        $this->assertEquals('http://www.mysite.com:9090/', Director::absoluteURL('http://www.mysite.com:9090/', Director::REQUEST));\n        $this->assertEquals('http://www.mytest.com', Director::absoluteURL('http://www.mytest.com', Director::REQUEST));\n        $this->assertEquals(\"http://www.mysite.com:9090/test\", Director::absoluteURL(\"http://www.mysite.com:9090/test\", Director::REQUEST));\n        $this->assertEquals(\"http://www.mysite.com:9090/root\", Director::absoluteURL(\"/root\", Director::REQUEST));\n        $this->assertEquals(\"http://www.mysite.com:9090/root/url\", Director::absoluteURL(\"/root/url\", Director::REQUEST));\n\n        // Test evaluating relative urls relative to base (default)\n        $this->assertEquals(\"http://www.mysite.com:9090/mysite/test\", Director::absoluteURL(\"test\"));\n        $this->assertEquals(\"http://www.mysite.com:9090/mysite/test/url\", Director::absoluteURL(\"test/url\"));\n        $this->assertEquals(\"http://www.mysite.com:9090/mysite/test\", Director::absoluteURL(\"test\", Director::BASE));\n        $this->assertEquals(\"http://www.mysite.com:9090/mysite/test/url\", Director::absoluteURL(\"test/url\", Director::BASE));\n\n        // Test evaluating relative urls relative to root\n        $this->assertEquals(\"http://www.mysite.com:9090/test\", Director::absoluteURL(\"test\", Director::ROOT));\n        $this->assertEquals(\"http://www.mysite.com:9090/test/url\", Director::absoluteURL(\"test/url\", Director::ROOT));\n\n        // Test relative to requested page\n        $this->assertEquals(\"http://www.mysite.com:9090/mysite/sub-page/test\", Director::absoluteURL(\"test\", Director::REQUEST));\n        $this->assertEquals(\"http://www.mysite.com:9090/mysite/sub-page/test/url\", Director::absoluteURL(\"test/url\", Director::REQUEST));\n\n        // Test that javascript links are not left intact\n        $this->assertStringStartsNotWith('javascript', Director::absoluteURL('javascript:alert(\"attack\")'));\n        $this->assertStringStartsNotWith('alert', Director::absoluteURL('javascript:alert(\"attack\")'));\n        $this->assertStringStartsNotWith('javascript', Director::absoluteURL('alert(\"attack\")'));\n        $this->assertStringStartsNotWith('alert', Director::absoluteURL('alert(\"attack\")'));\n    }\n\n    public function testAlternativeBaseURL()\n    {\n        // relative base URLs - you should end them in a /\n        Director::config()->set('alternate_base_url', '/relativebase/');\n        $_SERVER['HTTP_HOST'] = 'www.somesite.com';\n        $_SERVER['REQUEST_URI'] = \"/relativebase/sub-page/\";\n\n        $this->assertEquals('/relativebase/', Director::baseURL());\n        $this->assertEquals('http://www.somesite.com/relativebase/', Director::absoluteBaseURL());\n        $this->assertEquals(\n            'http://www.somesite.com/relativebase/subfolder/test',\n            Director::absoluteURL('subfolder/test')\n        );\n\n        // absolute base URLS with subdirectory - You should end them in a /\n        Director::config()->set('alternate_base_url', 'http://www.example.org/relativebase/');\n        $_SERVER['REQUEST_URI'] = \"http://www.example.org/relativebase/sub-page/\";\n        $this->assertEquals('/relativebase/', Director::baseURL()); // Non-absolute url\n        $this->assertEquals('http://www.example.org/relativebase/', Director::absoluteBaseURL());\n        $this->assertEquals('http://www.example.org/relativebase/sub-page/', Director::absoluteURL('', Director::REQUEST));\n        $this->assertEquals('http://www.example.org/relativebase/', Director::absoluteURL('', Director::BASE));\n        $this->assertEquals('http://www.example.org/', Director::absoluteURL('', Director::ROOT));\n        $this->assertEquals(\n            'http://www.example.org/relativebase/sub-page/subfolder/test',\n            Director::absoluteURL('subfolder/test', Director::REQUEST)\n        );\n        $this->assertEquals(\n            'http://www.example.org/subfolder/test',\n            Director::absoluteURL('subfolder/test', Director::ROOT)\n        );\n        $this->assertEquals(\n            'http://www.example.org/relativebase/subfolder/test',\n            Director::absoluteURL('subfolder/test', Director::BASE)\n        );\n\n        // absolute base URLs - you should end them in a /\n        Director::config()->set('alternate_base_url', 'http://www.example.org/');\n        $_SERVER['REQUEST_URI'] = \"http://www.example.org/sub-page/\";\n        $this->assertEquals('/', Director::baseURL()); // Non-absolute url\n        $this->assertEquals('http://www.example.org/', Director::absoluteBaseURL());\n        $this->assertEquals('http://www.example.org/sub-page/', Director::absoluteURL('', Director::REQUEST));\n        $this->assertEquals('http://www.example.org/', Director::absoluteURL('', Director::BASE));\n        $this->assertEquals('http://www.example.org/', Director::absoluteURL('', Director::ROOT));\n        $this->assertEquals(\n            'http://www.example.org/sub-page/subfolder/test',\n            Director::absoluteURL('subfolder/test', Director::REQUEST)\n        );\n        $this->assertEquals(\n            'http://www.example.org/subfolder/test',\n            Director::absoluteURL('subfolder/test', Director::ROOT)\n        );\n        $this->assertEquals(\n            'http://www.example.org/subfolder/test',\n            Director::absoluteURL('subfolder/test', Director::BASE)\n        );\n    }\n\n    /**\n     * Tests that {@link Director::is_absolute()} works under different environment types\n     * @dataProvider provideAbsolutePaths\n     */\n    public function testIsAbsolute($path, $result)\n    {\n        $this->assertEquals($result, Director::is_absolute($path));\n    }\n\n    public function provideAbsolutePaths()\n    {\n        return [\n            ['C:/something', true],\n            ['d:\\\\', true],\n            ['e/', false],\n            ['s:/directory', true],\n            ['/var/www', true],\n            ['\\\\Something', true],\n            ['something/c:', false],\n            ['folder', false],\n            ['a/c:/', false],\n        ];\n    }\n\n    public function testIsAbsoluteUrl()\n    {\n        $this->assertTrue(Director::is_absolute_url('http://test.com/testpage'));\n        $this->assertTrue(Director::is_absolute_url('https:/\\\\test.com'));\n        $this->assertTrue(Director::is_absolute_url('https:\\\\/test.com'));\n        $this->assertTrue(Director::is_absolute_url('https:\\\\\\\\test.com'));\n        $this->assertTrue(Director::is_absolute_url('ftp://test.com'));\n        $this->assertFalse(Director::is_absolute_url('test.com/testpage'));\n        $this->assertFalse(Director::is_absolute_url('/relative'));\n        $this->assertFalse(Director::is_absolute_url('relative'));\n        $this->assertFalse(Director::is_absolute_url(\"/relative/?url=http://foo.com\"));\n        $this->assertFalse(Director::is_absolute_url(\"/relative/#http://foo.com\"));\n        $this->assertTrue(Director::is_absolute_url(\"https://test.com/?url=http://foo.com\"));\n        $this->assertTrue(Director::is_absolute_url(\"trickparseurl:http://test.com\"));\n        $this->assertTrue(Director::is_absolute_url('//test.com'));\n        $this->assertTrue(Director::is_absolute_url('\\\\/\\\\/test.com'));\n        $this->assertTrue(Director::is_absolute_url('\\/\\/test.com'));\n        $this->assertTrue(Director::is_absolute_url('/\\\\test.com'));\n        $this->assertTrue(Director::is_absolute_url('\\\\\\\\test.com'));\n        $this->assertFalse(Director::is_absolute_url('\\\\test.com'));\n        $this->assertTrue(Director::is_absolute_url('/////test.com'));\n        $this->assertTrue(Director::is_absolute_url('  ///test.com'));\n        $this->assertTrue(Director::is_absolute_url('http:test.com'));\n        $this->assertTrue(Director::is_absolute_url('//http://test.com'));\n    }\n\n    public function testHostPortParts()\n    {\n        $this->assertEquals('www.mysite.com:9090', Director::host());\n        $this->assertEquals('www.mysite.com', Director::hostName());\n        $this->assertEquals('9090', Director::port());\n    }\n\n    public function testIsRelativeUrl()\n    {\n        $this->assertFalse(Director::is_relative_url('http://test.com'));\n        $this->assertFalse(Director::is_relative_url('https://test.com'));\n        $this->assertFalse(Director::is_relative_url('https:/\\\\test.com'));\n        $this->assertFalse(Director::is_relative_url('https:\\\\/test.com'));\n        $this->assertFalse(Director::is_relative_url('https:\\\\\\\\test.com'));\n        $this->assertFalse(Director::is_relative_url('   https://test.com/testpage   '));\n        $this->assertTrue(Director::is_relative_url('test.com/testpage'));\n        $this->assertFalse(Director::is_relative_url('//test.com'));\n        $this->assertFalse(Director::is_relative_url('\\\\/\\\\/test.com'));\n        $this->assertFalse(Director::is_relative_url('\\/\\/test.com'));\n        $this->assertFalse(Director::is_relative_url('/\\\\test.com'));\n        $this->assertFalse(Director::is_relative_url('\\\\\\\\test.com'));\n        $this->assertTrue(Director::is_relative_url('\\\\test.com'));\n        $this->assertFalse(Director::is_relative_url('ftp://test.com'));\n        $this->assertTrue(Director::is_relative_url('/relative'));\n        $this->assertTrue(Director::is_relative_url('relative'));\n        $this->assertTrue(Director::is_relative_url('/relative/?url=http://test.com'));\n        $this->assertTrue(Director::is_relative_url('/relative/#=http://test.com'));\n    }\n\n    /**\n     * @return array\n     */\n    public function providerMakeRelative()\n    {\n        return [\n            // Resilience to slash position\n            [\n                'http://www.mysite.com:9090/base/folder',\n                'http://www.mysite.com:9090/base/folder',\n                ''\n            ],\n            [\n                'http://www.mysite.com:9090/base/folder',\n                'http://www.mysite.com:9090/base/folder/',\n                ''\n            ],\n            [\n                'http://www.mysite.com:9090/base/folder/',\n                'http://www.mysite.com:9090/base/folder',\n                ''\n            ],\n            [\n                'http://www.mysite.com:9090/',\n                'http://www.mysite.com:9090/',\n                ''\n            ],\n            [\n                'http://www.mysite.com:9090/',\n                'http://www.mysite.com',\n                ''\n            ],\n            [\n                'http://www.mysite.com',\n                'http://www.mysite.com:9090/',\n                ''\n            ],\n            [\n                'http://www.mysite.com:9090/base/folder',\n                'http://www.mysite.com:9090/base/folder/page',\n                'page'\n            ],\n            [\n                'http://www.mysite.com:9090/',\n                'http://www.mysite.com:9090/page/',\n                'page/'\n            ],\n            // Parsing protocol safely\n            [\n                'http://www.mysite.com:9090/base/folder',\n                'https://www.mysite.com:9090/base/folder',\n                ''\n            ],\n            [\n                'https://www.mysite.com:9090/base/folder',\n                'http://www.mysite.com:9090/base/folder/testpage',\n                'testpage'\n            ],\n            [\n                'http://www.mysite.com:9090/base/folder',\n                '//www.mysite.com:9090/base/folder/testpage',\n                'testpage'\n            ],\n            // Dirty input\n            [\n                'http://www.mysite.com:9090/base/folder',\n                '    https://www.mysite.com:9090/base/folder/testpage    ',\n                'testpage'\n            ],\n            [\n                'http://www.mysite.com:9090/base/folder',\n                '//www.mysite.com:9090/base//folder/testpage//subpage',\n                'testpage/subpage'\n            ],\n            // Non-http protocol isn't modified\n            [\n                'http://www.mysite.com:9090/base/folder',\n                'ftp://test.com',\n                'ftp://test.com'\n            ],\n            // Alternate hostnames are redirected\n            [\n                'https://www.mysite.com:9090/base/folder',\n                'http://mysite.com:9090/base/folder/testpage',\n                'testpage'\n            ],\n            [\n                'http://www.otherdomain.com/base/folder',\n                '//www.mysite.com:9090/base/folder/testpage',\n                'testpage'\n            ],\n            // Base folder is found\n            [\n                'http://www.mysite.com:9090/base/folder',\n                BASE_PATH . '/some/file.txt',\n                'some/file.txt',\n            ],\n            // public folder is found\n            [\n                'http://www.mysite.com:9090/base/folder',\n                PUBLIC_PATH . '/some/file.txt',\n                'some/file.txt',\n            ],\n            // querystring is protected\n            [\n                'http://www.mysite.com:9090/base/folder',\n                '//www.mysite.com:9090/base//folder/testpage//subpage?args=hello',\n                'testpage/subpage?args=hello'\n            ],\n            [\n                'http://www.mysite.com:9090/base/folder',\n                '//www.mysite.com:9090/base//folder/?args=hello',\n                '?args=hello'\n            ],\n        ];\n    }\n\n    /**\n     * @dataProvider providerMakeRelative\n     * @param string $baseURL Site base URL\n     * @param string $requestURL Request URL\n     * @param string $relativeURL Expected relative URL\n     */\n    public function testMakeRelative($baseURL, $requestURL, $relativeURL)\n    {\n        Director::config()->set('alternate_base_url', $baseURL);\n        $actualRelative = Director::makeRelative($requestURL);\n        $this->assertEquals(\n            $relativeURL,\n            $actualRelative,\n            \"Expected relativeURL of {$requestURL} to be {$relativeURL}\"\n        );\n    }\n\n    public function testIsSiteUrl()\n    {\n        $this->assertFalse(Director::is_site_url('http://test.com'));\n        $this->assertTrue(Director::is_site_url('/relative-path'));\n        $this->assertTrue(Director::is_site_url('relative-path'));\n        $this->assertTrue(Director::is_site_url(Director::absoluteBaseURL()));\n        $this->assertFalse(Director::is_site_url('http://test.com?url=' . Director::absoluteBaseURL()));\n        $this->assertFalse(Director::is_site_url('http://test.com?url=' . urlencode(Director::absoluteBaseURL() ?? '')));\n        $this->assertFalse(Director::is_site_url('http:\\\\\\\\test.com'));\n        $this->assertFalse(Director::is_site_url('http:\\\\\\\\test.com?url=' . Director::absoluteBaseURL()));\n        $this->assertFalse(Director::is_site_url('http:\\\\\\\\test.com?url=' . urlencode(Director::absoluteBaseURL() ?? '')));\n        $this->assertFalse(Director::is_site_url('http:\\\\/test.com'));\n        $this->assertFalse(Director::is_site_url('http:\\\\/test.com?url=' . Director::absoluteBaseURL()));\n        $this->assertFalse(Director::is_site_url('http:\\\\/test.com?url=' . urlencode(Director::absoluteBaseURL() ?? '')));\n        $this->assertFalse(Director::is_site_url('//test.com'));\n        $this->assertFalse(Director::is_site_url('//test.com?url=' . Director::absoluteBaseURL()));\n        $this->assertFalse(Director::is_site_url('\\\\/\\\\/test.com'));\n        $this->assertFalse(Director::is_site_url('\\\\/\\\\/test.com?url=' . Director::absoluteBaseURL()));\n        $this->assertFalse(Director::is_site_url('\\/\\/test.com'));\n        $this->assertFalse(Director::is_site_url('\\/\\/test.com?url=' . Director::absoluteBaseURL()));\n        $this->assertFalse(Director::is_site_url('\\\\/test.com'));\n        $this->assertFalse(Director::is_site_url('\\\\/test.com?url=' . Director::absoluteBaseURL()));\n        $this->assertFalse(Director::is_site_url('/\\\\test.com'));\n        $this->assertFalse(Director::is_site_url('/\\\\test.com?url=' . Director::absoluteBaseURL()));\n        $this->assertFalse(Director::is_site_url('\\\\\\\\test.com'));\n        $this->assertFalse(Director::is_site_url('\\\\\\\\test.com?url=' . Director::absoluteBaseURL()));\n        $this->assertTrue(Director::is_site_url('\\\\test.com'));\n        $this->assertTrue(Director::is_site_url('\\\\test.com?url=' . Director::absoluteBaseURL()));\n        $this->assertFalse(Director::is_site_url('http://google.com\\@test.com'));\n        $this->assertFalse(Director::is_site_url('http://google.com/@test.com'));\n        $this->assertFalse(Director::is_site_url('http://google.com:pass\\@test.com'));\n        $this->assertFalse(Director::is_site_url('http://google.com:pass/@test.com'));\n    }\n\n    /**\n     * Tests isDev, isTest, isLive cannot be set from querystring\n     */\n    public function testQueryIsEnvironment()\n    {\n        if (!isset($_SESSION)) {\n            $_SESSION = [];\n        }\n        // Reset\n        unset($_SESSION['isDev']);\n        unset($_SESSION['isLive']);\n        unset($_GET['isTest']);\n        unset($_GET['isDev']);\n\n        /** @var Kernel $kernel */\n        $kernel = Injector::inst()->get(Kernel::class);\n        $kernel->setEnvironment(null);\n        Environment::setEnv('SS_ENVIRONMENT_TYPE', Kernel::LIVE);\n\n        $this->assertTrue(Director::isLive());\n\n        // Test isDev=1\n        $_GET['isDev'] = '1';\n        $this->assertFalse(Director::isDev());\n        $this->assertFalse(Director::isTest());\n        $this->assertTrue(Director::isLive());\n\n        // Test persistence\n        unset($_GET['isDev']);\n        $this->assertFalse(Director::isDev());\n        $this->assertFalse(Director::isTest());\n        $this->assertTrue(Director::isLive());\n\n        // Test change to isTest\n        $_GET['isTest'] = '1';\n        $this->assertFalse(Director::isDev());\n        $this->assertFalse(Director::isTest());\n        $this->assertTrue(Director::isLive());\n\n        // Test persistence\n        unset($_GET['isTest']);\n        $this->assertFalse(Director::isDev());\n        $this->assertFalse(Director::isTest());\n        $this->assertTrue(Director::isLive());\n    }\n\n    public function testResetGlobalsAfterTestRequest()\n    {\n        $_GET = ['somekey' => 'getvalue'];\n        $_POST = ['somekey' => 'postvalue'];\n        $_COOKIE = ['somekey' => 'cookievalue'];\n\n        $cookies = Injector::inst()->createWithArgs(\n            Cookie_Backend::class,\n            [['somekey' => 'sometestcookievalue']]\n        );\n\n        Director::test(\n            'errorpage?somekey=sometestgetvalue',\n            ['somekey' => 'sometestpostvalue'],\n            null,\n            null,\n            null,\n            null,\n            $cookies\n        );\n\n        $this->assertEquals(\n            'getvalue',\n            $_GET['somekey'],\n            '$_GET reset to original value after Director::test()'\n        );\n        $this->assertEquals(\n            'postvalue',\n            $_POST['somekey'],\n            '$_POST reset to original value after Director::test()'\n        );\n        $this->assertEquals(\n            'cookievalue',\n            $_COOKIE['somekey'],\n            '$_COOKIE reset to original value after Director::test()'\n        );\n    }\n\n    public function providerTestTestRequestCarriesGlobals()\n    {\n        $tests = [];\n        $fixture = ['somekey' => 'sometestvalue'];\n        foreach (['get', 'post'] as $method) {\n            foreach (['return%sValue', 'returnRequestValue', 'returnCookieValue'] as $testfunction) {\n                $url = 'TestController/' . sprintf($testfunction ?? '', ucfirst($method ?? ''))\n                    . '?' . http_build_query($fixture ?? []);\n                $tests[] = [$url, $fixture, $method];\n            }\n        }\n        return $tests;\n    }\n\n    /**\n     * @dataProvider providerTestTestRequestCarriesGlobals\n     * @param $url\n     * @param $fixture\n     * @param $method\n     */\n    public function testTestRequestCarriesGlobals($url, $fixture, $method)\n    {\n        $getresponse = Director::test(\n            $url,\n            $fixture,\n            null,\n            strtoupper($method ?? ''),\n            null,\n            null,\n            Injector::inst()->createWithArgs(Cookie_Backend::class, [$fixture])\n        );\n\n        $this->assertInstanceOf(HTTPResponse::class, $getresponse, 'Director::test() returns HTTPResponse');\n        $this->assertEquals($fixture['somekey'], $getresponse->getBody(), \"Director::test({$url}, {$method})\");\n    }\n\n    /**\n     * Tests that additional parameters specified in the routing table are\n     * saved in the request\n     */\n    public function testRouteParams()\n    {\n        /** @var HTTPRequest $request */\n        Director::test('en-nz/myaction/myid/myotherid', null, null, null, null, null, null, $request);\n\n        $this->assertEquals(\n            [\n                'Controller' => TestController::class,\n                'Action' => 'myaction',\n                'ID' => 'myid',\n                'OtherID' => 'myotherid',\n                'Locale' => 'en_NZ'\n            ],\n            $request->params()\n        );\n    }\n\n    public function testForceWWW()\n    {\n        $this->expectExceptionRedirect('http://www.mysite.com:9090/some-url');\n        Director::mockRequest(function ($request) {\n            Injector::inst()->registerService($request, HTTPRequest::class);\n            Director::forceWWW();\n        }, 'http://mysite.com:9090/some-url');\n    }\n\n    public function testPromisedForceWWW()\n    {\n        Director::forceWWW();\n\n        // Flag is set but not redirected yet\n        $middleware = CanonicalURLMiddleware::singleton();\n        $this->assertTrue($middleware->getForceWWW());\n\n        // Middleware forces the redirection eventually\n        /** @var HTTPResponse $response */\n        $response = Director::mockRequest(function ($request) use ($middleware) {\n            return $middleware->process($request, function ($request) {\n                return null;\n            });\n        }, 'http://mysite.com:9090/some-url');\n\n        // Middleware returns non-exception redirect\n        $this->assertEquals('http://www.mysite.com:9090/some-url', $response->getHeader('Location'));\n        $this->assertEquals(301, $response->getStatusCode());\n    }\n\n    public function testForceSSLProtectsEntireSite()\n    {\n        $this->expectExceptionRedirect('https://www.mysite.com:9090/some-url');\n        Director::mockRequest(function ($request) {\n            Injector::inst()->registerService($request, HTTPRequest::class);\n            Director::forceSSL();\n        }, 'http://www.mysite.com:9090/some-url');\n    }\n\n    public function testPromisedForceSSL()\n    {\n        Director::forceSSL();\n\n        // Flag is set but not redirected yet\n        $middleware = CanonicalURLMiddleware::singleton();\n        $this->assertTrue($middleware->getForceSSL());\n\n        // Middleware forces the redirection eventually\n        /** @var HTTPResponse $response */\n        $response = Director::mockRequest(function ($request) use ($middleware) {\n            return $middleware->process($request, function ($request) {\n                return null;\n            });\n        }, 'http://www.mysite.com:9090/some-url');\n\n        // Middleware returns non-exception redirect\n        $this->assertInstanceOf(HTTPResponse::class, $response);\n        $this->assertEquals('https://www.mysite.com:9090/some-url', $response->getHeader('Location'));\n        $this->assertEquals(301, $response->getStatusCode());\n    }\n\n    public function testForceSSLOnTopLevelPagePattern()\n    {\n        // Expect admin to trigger redirect\n        $this->expectExceptionRedirect('https://www.mysite.com:9090/admin');\n        Director::mockRequest(function (HTTPRequest $request) {\n            Injector::inst()->registerService($request, HTTPRequest::class);\n            Director::forceSSL(['/^admin/']);\n        }, 'http://www.mysite.com:9090/admin');\n    }\n\n    public function testForceSSLOnSubPagesPattern()\n    {\n        // Expect to redirect to security login page\n        $this->expectExceptionRedirect('https://www.mysite.com:9090/Security/login');\n        Director::mockRequest(function (HTTPRequest $request) {\n            Injector::inst()->registerService($request, HTTPRequest::class);\n            Director::forceSSL(['/^Security/']);\n        }, 'http://www.mysite.com:9090/Security/login');\n    }\n\n    public function testForceSSLWithPatternDoesNotMatchOtherPages()\n    {\n        // Not on same url should not trigger redirect\n        $response = Director::mockRequest(function (HTTPRequest $request) {\n            Injector::inst()->registerService($request, HTTPRequest::class);\n            Director::forceSSL(['/^admin/']);\n        }, 'http://www.mysite.com:9090/normal-page');\n        $this->assertNull($response, 'Non-matching patterns do not trigger redirect');\n\n        // nested url should not triger redirect either\n        $response = Director::mockRequest(function (HTTPRequest $request) {\n            Injector::inst()->registerService($request, HTTPRequest::class);\n            Director::forceSSL(['/^admin/', '/^Security/']);\n        }, 'http://www.mysite.com:9090/just-another-page/sub-url');\n        $this->assertNull($response, 'Non-matching patterns do not trigger redirect');\n    }\n\n    public function testForceSSLAlternateDomain()\n    {\n        // Ensure that forceSSL throws the appropriate exception\n        $this->expectExceptionRedirect('https://secure.mysite.com/admin');\n        Director::mockRequest(function (HTTPRequest $request) {\n            Injector::inst()->registerService($request, HTTPRequest::class);\n            return Director::forceSSL(['/^admin/'], 'secure.mysite.com');\n        }, 'http://www.mysite.com:9090/admin');\n    }\n\n    public function testForceSSLAlternateDomainWithPort()\n    {\n        // Ensure that forceSSL throws the appropriate exception\n        $this->expectExceptionRedirect('https://secure.mysite.com:81/admin');\n        Director::mockRequest(function (HTTPRequest $request) {\n            Injector::inst()->registerService($request, HTTPRequest::class);\n            return Director::forceSSL(['/^admin/'], 'secure.mysite.com:81');\n        }, 'http://www.mysite.com:9090/admin');\n    }\n\n    /**\n     * Test that combined forceWWW and forceSSL combine safely\n     */\n    public function testForceSSLandForceWWW()\n    {\n        Director::forceWWW();\n        Director::forceSSL();\n\n        // Flag is set but not redirected yet\n        $middleware = CanonicalURLMiddleware::singleton();\n        $this->assertTrue($middleware->getForceWWW());\n        $this->assertTrue($middleware->getForceSSL());\n\n        // Middleware forces the redirection eventually\n        /** @var HTTPResponse $response */\n        $response = Director::mockRequest(function ($request) use ($middleware) {\n            return $middleware->process($request, function ($request) {\n                return null;\n            });\n        }, 'http://mysite.com:9090/some-url');\n\n        // Middleware returns non-exception redirect\n        $this->assertEquals('https://www.mysite.com:9090/some-url', $response->getHeader('Location'));\n        $this->assertEquals(301, $response->getStatusCode());\n    }\n\n    /**\n     * Set url to redirect to\n     *\n     * @var string\n     */\n    protected $expectedRedirect = null;\n\n    /**\n     * Expects this test to throw a HTTPResponse_Exception with the given redirect\n     *\n     * @param string $url\n     */\n    protected function expectExceptionRedirect($url)\n    {\n        $this->expectedRedirect = $url;\n    }\n\n    protected function runTest()\n    {\n        try {\n            $result = parent::runTest();\n            if ($this->expectedRedirect) {\n                $this->fail(\"Expected to redirect to {$this->expectedRedirect} but no redirect found\");\n            }\n            return $result;\n        } catch (HTTPResponse_Exception $exception) {\n            // Check URL\n            if ($this->expectedRedirect) {\n                $url = $exception->getResponse()->getHeader('Location');\n                $this->assertEquals($this->expectedRedirect, $url, \"Expected to redirect to {$this->expectedRedirect}\");\n                return null;\n            } else {\n                throw $exception;\n            }\n        }\n    }\n\n    public function testUnmatchedRequestReturns404()\n    {\n        // Remove non-tested rules\n        $this->assertEquals(404, Director::test('no-route')->getStatusCode());\n    }\n\n    public function testIsHttps()\n    {\n        // Trust all IPs for this test\n        /** @var TrustedProxyMiddleware $trustedProxyMiddleware */\n        $trustedProxyMiddleware\n            = Injector::inst()->get(TrustedProxyMiddleware::class);\n        $trustedProxyMiddleware->setTrustedProxyIPs('*');\n\n        // Clear alternate_base_url for this test\n        Director::config()->remove('alternate_base_url');\n\n        // nothing available\n        $headers = [\n            'HTTP_X_FORWARDED_PROTOCOL', 'HTTPS', 'SSL'\n        ];\n        foreach ($headers as $header) {\n            if (isset($_SERVER[$header])) {\n                unset($_SERVER['HTTP_X_FORWARDED_PROTOCOL']);\n            }\n        }\n\n        $this->assertEquals(\n            'no',\n            Director::test('TestController/returnIsSSL')->getBody()\n        );\n\n        $this->assertEquals(\n            'yes',\n            Director::test(\n                'TestController/returnIsSSL',\n                null,\n                null,\n                null,\n                null,\n                ['X-Forwarded-Protocol' => 'https']\n            )->getBody()\n        );\n\n        $this->assertEquals(\n            'no',\n            Director::test(\n                'TestController/returnIsSSL',\n                null,\n                null,\n                null,\n                null,\n                ['X-Forwarded-Protocol' => 'http']\n            )->getBody()\n        );\n\n        $this->assertEquals(\n            'no',\n            Director::test(\n                'TestController/returnIsSSL',\n                null,\n                null,\n                null,\n                null,\n                ['X-Forwarded-Protocol' => 'ftp']\n            )->getBody()\n        );\n\n        // https via HTTPS\n        $_SERVER['HTTPS'] = 'true';\n        $this->assertEquals(\n            'yes',\n            Director::test('TestController/returnIsSSL')->getBody()\n        );\n\n        $_SERVER['HTTPS'] = '1';\n        $this->assertEquals(\n            'yes',\n            Director::test('TestController/returnIsSSL')->getBody()\n        );\n\n        $_SERVER['HTTPS'] = 'off';\n        $this->assertEquals(\n            'no',\n            Director::test('TestController/returnIsSSL')->getBody()\n        );\n\n        // https via SSL\n        $_SERVER['SSL'] = '';\n        $this->assertEquals(\n            'yes',\n            Director::test('TestController/returnIsSSL')->getBody()\n        );\n    }\n\n    public function testTestIgnoresHashes()\n    {\n        //test that hashes are ignored\n        $url = \"TestController/returnGetValue?somekey=key\";\n        $hash = \"#test\";\n        /** @var HTTPRequest $request */\n        $response = Director::test($url . $hash, null, null, null, null, null, null, $request);\n        $this->assertFalse($response->isError());\n        $this->assertEquals('key', $response->getBody());\n        $this->assertEquals($request->getURL(true), $url);\n\n        //test encoded hashes are accepted\n        $url = \"TestController/returnGetValue?somekey=test%23key\";\n        $response = Director::test($url, null, null, null, null, null, null, $request);\n        $this->assertFalse($response->isError());\n        $this->assertEquals('test#key', $response->getBody());\n        $this->assertEquals($request->getURL(true), $url);\n    }\n\n    public function testRequestFilterInDirectorTest()\n    {\n        $filter = new DirectorTest\\TestRequestFilter;\n\n        $processor = new RequestProcessor([$filter]);\n\n        $middlewares = Director::singleton()->getMiddlewares();\n        $middlewares['RequestProcessorMiddleware'] = $processor;\n        Director::singleton()->setMiddlewares($middlewares);\n\n        $response = Director::test('some-dummy-url');\n        $this->assertEquals(404, $response->getStatusCode());\n\n        $this->assertEquals(1, $filter->preCalls);\n        $this->assertEquals(1, $filter->postCalls);\n\n        $filter->failPost = true;\n\n        $response = Director::test('some-dummy-url');\n        $this->assertEquals(500, $response->getStatusCode());\n        $this->assertEquals(_t(Director::class . '.REQUEST_ABORTED', 'Request aborted'), $response->getBody());\n\n        $this->assertEquals(2, $filter->preCalls);\n        $this->assertEquals(2, $filter->postCalls);\n\n        $filter->failPre = true;\n\n        $response = Director::test('some-dummy-url');\n        $this->assertEquals(400, $response->getStatusCode());\n        $this->assertEquals(_t(Director::class . '.INVALID_REQUEST', 'Invalid request'), $response->getBody());\n\n        $this->assertEquals(3, $filter->preCalls);\n\n        // preCall 'true' will trigger an exception and prevent post call execution\n        $this->assertEquals(2, $filter->postCalls);\n    }\n\n    public function testGlobalMiddleware()\n    {\n        $middleware = new DirectorTest\\TestMiddleware;\n        Director::singleton()->setMiddlewares([$middleware]);\n\n        $response = Director::test('some-dummy-url');\n        $this->assertEquals(404, $response->getStatusCode());\n\n        // Both triggered\n        $this->assertEquals(1, $middleware->preCalls);\n        $this->assertEquals(1, $middleware->postCalls);\n\n        $middleware->failPost = true;\n\n        $response = Director::test('some-dummy-url');\n        $this->assertEquals(500, $response->getStatusCode());\n\n        // Both triggered\n        $this->assertEquals(2, $middleware->preCalls);\n        $this->assertEquals(2, $middleware->postCalls);\n\n        $middleware->failPre = true;\n\n        $response = Director::test('some-dummy-url');\n        $this->assertEquals(400, $response->getStatusCode());\n\n        // Pre triggered, post not\n        $this->assertEquals(3, $middleware->preCalls);\n        $this->assertEquals(2, $middleware->postCalls);\n    }\n\n    public function testRouteSpecificMiddleware()\n    {\n        // Inject adapter in place of controller\n        $specificMiddleware = new DirectorTest\\TestMiddleware;\n        Injector::inst()->registerService($specificMiddleware, 'SpecificMiddleware');\n\n        // Register adapter as factory for creating this controller\n        Config::modify()->merge(\n            Injector::class,\n            'ControllerWithMiddleware',\n            [\n                'class' => RequestHandlerMiddlewareAdapter::class,\n                'constructor' => [\n                    '%$' . TestController::class\n                ],\n                'properties' => [\n                    'Middlewares' => [\n                        '%$SpecificMiddleware',\n                    ],\n                ],\n            ]\n        );\n\n        // Global middleware\n        $middleware = new DirectorTest\\TestMiddleware;\n        Director::singleton()->setMiddlewares([$middleware]);\n\n        // URL rules, one of which has a specific middleware\n        Config::modify()->set(\n            Director::class,\n            'rules',\n            [\n                'url-one' => TestController::class,\n                'url-two' => [\n                    'Controller' => 'ControllerWithMiddleware',\n                ],\n            ]\n        );\n\n        // URL without a route-specific middleware\n        Director::test('url-one');\n\n        // Only the global middleware triggered\n        $this->assertEquals(1, $middleware->preCalls);\n        $this->assertEquals(0, $specificMiddleware->postCalls);\n\n        Director::test('url-two');\n\n        // Both triggered on the url with the specific middleware applied\n        $this->assertEquals(2, $middleware->preCalls);\n        $this->assertEquals(1, $specificMiddleware->postCalls);\n    }\n\n    /**\n     * If using phpdbg it returns itself instead of \"cli\" from php_sapi_name()\n     */\n    public function testIsCli()\n    {\n        $this->assertTrue(Director::is_cli(), 'is_cli should be true for PHP CLI and phpdbg');\n    }\n\n    public function testMockRequest()\n    {\n        Director::config()->set('alternate_base_url', 'http://www.mysite.com:9090/some-subdir/');\n\n        // Can handle root-relative $url\n        Director::mockRequest(function (HTTPRequest $request) {\n            $this->assertEquals('some-page/nested', $request->getURL());\n            $this->assertEquals(1, $request->getVar('query'));\n            $this->assertEquals('/some-subdir/some-page/nested', $_SERVER['REQUEST_URI']);\n        }, '/some-subdir/some-page/nested?query=1');\n\n        // Can handle absolute $url\n        Director::mockRequest(function (HTTPRequest $request) {\n            $this->assertEquals('some-page/nested', $request->getURL());\n            $this->assertEquals(1, $request->getVar('query'));\n            $this->assertEquals('/some-subdir/some-page/nested', $_SERVER['REQUEST_URI']);\n        }, 'http://www.mysite.com:9090/some-subdir/some-page/nested?query=1');\n\n        // Can handle relative $url\n        Director::mockRequest(function (HTTPRequest $request) {\n            $this->assertEquals('some-page/nested', $request->getURL());\n            $this->assertEquals(1, $request->getVar('query'));\n            $this->assertEquals('/some-subdir/some-page/nested', $_SERVER['REQUEST_URI']);\n        }, 'some-page/nested?query=1');\n    }\n}\n"], "filenames": ["src/Control/Director.php", "tests/php/Control/DirectorTest.php"], "buggy_code_start_loc": [825, 234], "buggy_code_end_loc": [829, 415], "fixing_code_start_loc": [825, 235], "fixing_code_end_loc": [830, 449], "type": "CWE-601", "message": "Silverstripe Framework is the Model-View-Controller framework that powers the Silverstripe content management system. Prior to version 4.12.15, an attacker can display a link to a third party website on a login screen by convincing a legitimate content author to follow a specially crafted link. Users should upgrade to Silverstripe Framework 4.12.15 or above to address the issue.", "other": {"cve": {"id": "CVE-2023-22729", "sourceIdentifier": "security-advisories@github.com", "published": "2023-04-26T15:15:08.887", "lastModified": "2023-05-04T20:13:00.437", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Silverstripe Framework is the Model-View-Controller framework that powers the Silverstripe content management system. Prior to version 4.12.15, an attacker can display a link to a third party website on a login screen by convincing a legitimate content author to follow a specially crafted link. Users should upgrade to Silverstripe Framework 4.12.15 or above to address the issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:silverstripe:framework:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.12.5", "matchCriteriaId": "12AC8517-3E73-4583-BD9E-E9D129DEDAF8"}]}]}], "references": [{"url": "https://github.com/silverstripe/silverstripe-framework/commit/1a5bb4cbece1721203977910b8ecd8b79c18dc77", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/silverstripe/silverstripe-framework/security/advisories/GHSA-fw84-xgm8-9jmv", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/silverstripe/silverstripe-framework/commit/1a5bb4cbece1721203977910b8ecd8b79c18dc77"}}