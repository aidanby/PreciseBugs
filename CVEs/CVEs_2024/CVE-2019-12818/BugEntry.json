{"buggy_code": ["/*\n * Copyright (C) 2011  Intel Corporation. All rights reserved.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#define pr_fmt(fmt) \"llcp: %s: \" fmt, __func__\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/nfc.h>\n\n#include <net/nfc/nfc.h>\n\n#include \"nfc.h\"\n#include \"llcp.h\"\n\nstatic u8 llcp_tlv_length[LLCP_TLV_MAX] = {\n\t0,\n\t1, /* VERSION */\n\t2, /* MIUX */\n\t2, /* WKS */\n\t1, /* LTO */\n\t1, /* RW */\n\t0, /* SN */\n\t1, /* OPT */\n\t0, /* SDREQ */\n\t2, /* SDRES */\n\n};\n\nstatic u8 llcp_tlv8(u8 *tlv, u8 type)\n{\n\tif (tlv[0] != type || tlv[1] != llcp_tlv_length[tlv[0]])\n\t\treturn 0;\n\n\treturn tlv[2];\n}\n\nstatic u16 llcp_tlv16(u8 *tlv, u8 type)\n{\n\tif (tlv[0] != type || tlv[1] != llcp_tlv_length[tlv[0]])\n\t\treturn 0;\n\n\treturn be16_to_cpu(*((__be16 *)(tlv + 2)));\n}\n\n\nstatic u8 llcp_tlv_version(u8 *tlv)\n{\n\treturn llcp_tlv8(tlv, LLCP_TLV_VERSION);\n}\n\nstatic u16 llcp_tlv_miux(u8 *tlv)\n{\n\treturn llcp_tlv16(tlv, LLCP_TLV_MIUX) & 0x7ff;\n}\n\nstatic u16 llcp_tlv_wks(u8 *tlv)\n{\n\treturn llcp_tlv16(tlv, LLCP_TLV_WKS);\n}\n\nstatic u16 llcp_tlv_lto(u8 *tlv)\n{\n\treturn llcp_tlv8(tlv, LLCP_TLV_LTO);\n}\n\nstatic u8 llcp_tlv_opt(u8 *tlv)\n{\n\treturn llcp_tlv8(tlv, LLCP_TLV_OPT);\n}\n\nstatic u8 llcp_tlv_rw(u8 *tlv)\n{\n\treturn llcp_tlv8(tlv, LLCP_TLV_RW) & 0xf;\n}\n\nu8 *nfc_llcp_build_tlv(u8 type, u8 *value, u8 value_length, u8 *tlv_length)\n{\n\tu8 *tlv, length;\n\n\tpr_debug(\"type %d\\n\", type);\n\n\tif (type >= LLCP_TLV_MAX)\n\t\treturn NULL;\n\n\tlength = llcp_tlv_length[type];\n\tif (length == 0 && value_length == 0)\n\t\treturn NULL;\n\telse if (length == 0)\n\t\tlength = value_length;\n\n\t*tlv_length = 2 + length;\n\ttlv = kzalloc(2 + length, GFP_KERNEL);\n\tif (tlv == NULL)\n\t\treturn tlv;\n\n\ttlv[0] = type;\n\ttlv[1] = length;\n\tmemcpy(tlv + 2, value, length);\n\n\treturn tlv;\n}\n\nstruct nfc_llcp_sdp_tlv *nfc_llcp_build_sdres_tlv(u8 tid, u8 sap)\n{\n\tstruct nfc_llcp_sdp_tlv *sdres;\n\tu8 value[2];\n\n\tsdres = kzalloc(sizeof(struct nfc_llcp_sdp_tlv), GFP_KERNEL);\n\tif (sdres == NULL)\n\t\treturn NULL;\n\n\tvalue[0] = tid;\n\tvalue[1] = sap;\n\n\tsdres->tlv = nfc_llcp_build_tlv(LLCP_TLV_SDRES, value, 2,\n\t\t\t\t\t&sdres->tlv_len);\n\tif (sdres->tlv == NULL) {\n\t\tkfree(sdres);\n\t\treturn NULL;\n\t}\n\n\tsdres->tid = tid;\n\tsdres->sap = sap;\n\n\tINIT_HLIST_NODE(&sdres->node);\n\n\treturn sdres;\n}\n\nstruct nfc_llcp_sdp_tlv *nfc_llcp_build_sdreq_tlv(u8 tid, char *uri,\n\t\t\t\t\t\t  size_t uri_len)\n{\n\tstruct nfc_llcp_sdp_tlv *sdreq;\n\n\tpr_debug(\"uri: %s, len: %zu\\n\", uri, uri_len);\n\n\t/* sdreq->tlv_len is u8, takes uri_len, + 3 for header, + 1 for NULL */\n\tif (WARN_ON_ONCE(uri_len > U8_MAX - 4))\n\t\treturn NULL;\n\n\tsdreq = kzalloc(sizeof(struct nfc_llcp_sdp_tlv), GFP_KERNEL);\n\tif (sdreq == NULL)\n\t\treturn NULL;\n\n\tsdreq->tlv_len = uri_len + 3;\n\n\tif (uri[uri_len - 1] == 0)\n\t\tsdreq->tlv_len--;\n\n\tsdreq->tlv = kzalloc(sdreq->tlv_len + 1, GFP_KERNEL);\n\tif (sdreq->tlv == NULL) {\n\t\tkfree(sdreq);\n\t\treturn NULL;\n\t}\n\n\tsdreq->tlv[0] = LLCP_TLV_SDREQ;\n\tsdreq->tlv[1] = sdreq->tlv_len - 2;\n\tsdreq->tlv[2] = tid;\n\n\tsdreq->tid = tid;\n\tsdreq->uri = sdreq->tlv + 3;\n\tmemcpy(sdreq->uri, uri, uri_len);\n\n\tsdreq->time = jiffies;\n\n\tINIT_HLIST_NODE(&sdreq->node);\n\n\treturn sdreq;\n}\n\nvoid nfc_llcp_free_sdp_tlv(struct nfc_llcp_sdp_tlv *sdp)\n{\n\tkfree(sdp->tlv);\n\tkfree(sdp);\n}\n\nvoid nfc_llcp_free_sdp_tlv_list(struct hlist_head *head)\n{\n\tstruct nfc_llcp_sdp_tlv *sdp;\n\tstruct hlist_node *n;\n\n\thlist_for_each_entry_safe(sdp, n, head, node) {\n\t\thlist_del(&sdp->node);\n\n\t\tnfc_llcp_free_sdp_tlv(sdp);\n\t}\n}\n\nint nfc_llcp_parse_gb_tlv(struct nfc_llcp_local *local,\n\t\t\t  u8 *tlv_array, u16 tlv_array_len)\n{\n\tu8 *tlv = tlv_array, type, length, offset = 0;\n\n\tpr_debug(\"TLV array length %d\\n\", tlv_array_len);\n\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\twhile (offset < tlv_array_len) {\n\t\ttype = tlv[0];\n\t\tlength = tlv[1];\n\n\t\tpr_debug(\"type 0x%x length %d\\n\", type, length);\n\n\t\tswitch (type) {\n\t\tcase LLCP_TLV_VERSION:\n\t\t\tlocal->remote_version = llcp_tlv_version(tlv);\n\t\t\tbreak;\n\t\tcase LLCP_TLV_MIUX:\n\t\t\tlocal->remote_miu = llcp_tlv_miux(tlv) + 128;\n\t\t\tbreak;\n\t\tcase LLCP_TLV_WKS:\n\t\t\tlocal->remote_wks = llcp_tlv_wks(tlv);\n\t\t\tbreak;\n\t\tcase LLCP_TLV_LTO:\n\t\t\tlocal->remote_lto = llcp_tlv_lto(tlv) * 10;\n\t\t\tbreak;\n\t\tcase LLCP_TLV_OPT:\n\t\t\tlocal->remote_opt = llcp_tlv_opt(tlv);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Invalid gt tlv value 0x%x\\n\", type);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset += length + 2;\n\t\ttlv += length + 2;\n\t}\n\n\tpr_debug(\"version 0x%x miu %d lto %d opt 0x%x wks 0x%x\\n\",\n\t\t local->remote_version, local->remote_miu,\n\t\t local->remote_lto, local->remote_opt,\n\t\t local->remote_wks);\n\n\treturn 0;\n}\n\nint nfc_llcp_parse_connection_tlv(struct nfc_llcp_sock *sock,\n\t\t\t\t  u8 *tlv_array, u16 tlv_array_len)\n{\n\tu8 *tlv = tlv_array, type, length, offset = 0;\n\n\tpr_debug(\"TLV array length %d\\n\", tlv_array_len);\n\n\tif (sock == NULL)\n\t\treturn -ENOTCONN;\n\n\twhile (offset < tlv_array_len) {\n\t\ttype = tlv[0];\n\t\tlength = tlv[1];\n\n\t\tpr_debug(\"type 0x%x length %d\\n\", type, length);\n\n\t\tswitch (type) {\n\t\tcase LLCP_TLV_MIUX:\n\t\t\tsock->remote_miu = llcp_tlv_miux(tlv) + 128;\n\t\t\tbreak;\n\t\tcase LLCP_TLV_RW:\n\t\t\tsock->remote_rw = llcp_tlv_rw(tlv);\n\t\t\tbreak;\n\t\tcase LLCP_TLV_SN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Invalid gt tlv value 0x%x\\n\", type);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset += length + 2;\n\t\ttlv += length + 2;\n\t}\n\n\tpr_debug(\"sock %p rw %d miu %d\\n\", sock,\n\t\t sock->remote_rw, sock->remote_miu);\n\n\treturn 0;\n}\n\nstatic struct sk_buff *llcp_add_header(struct sk_buff *pdu,\n\t\t\t\t       u8 dsap, u8 ssap, u8 ptype)\n{\n\tu8 header[2];\n\n\tpr_debug(\"ptype 0x%x dsap 0x%x ssap 0x%x\\n\", ptype, dsap, ssap);\n\n\theader[0] = (u8)((dsap << 2) | (ptype >> 2));\n\theader[1] = (u8)((ptype << 6) | ssap);\n\n\tpr_debug(\"header 0x%x 0x%x\\n\", header[0], header[1]);\n\n\tskb_put_data(pdu, header, LLCP_HEADER_SIZE);\n\n\treturn pdu;\n}\n\nstatic struct sk_buff *llcp_add_tlv(struct sk_buff *pdu, u8 *tlv,\n\t\t\t\t    u8 tlv_length)\n{\n\t/* XXX Add an skb length check */\n\n\tif (tlv == NULL)\n\t\treturn NULL;\n\n\tskb_put_data(pdu, tlv, tlv_length);\n\n\treturn pdu;\n}\n\nstatic struct sk_buff *llcp_allocate_pdu(struct nfc_llcp_sock *sock,\n\t\t\t\t\t u8 cmd, u16 size)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tif (sock->ssap == 0)\n\t\treturn NULL;\n\n\tskb = nfc_alloc_send_skb(sock->dev, &sock->sk, MSG_DONTWAIT,\n\t\t\t\t size + LLCP_HEADER_SIZE, &err);\n\tif (skb == NULL) {\n\t\tpr_err(\"Could not allocate PDU\\n\");\n\t\treturn NULL;\n\t}\n\n\tskb = llcp_add_header(skb, sock->dsap, sock->ssap, cmd);\n\n\treturn skb;\n}\n\nint nfc_llcp_send_disconnect(struct nfc_llcp_sock *sock)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\n\tpr_debug(\"Sending DISC\\n\");\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tdev = sock->dev;\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_DISC, 0);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\treturn 0;\n}\n\nint nfc_llcp_send_symm(struct nfc_dev *dev)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_llcp_local *local;\n\tu16 size = 0;\n\n\tpr_debug(\"Sending SYMM\\n\");\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tsize += LLCP_HEADER_SIZE;\n\tsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\n\tskb = llcp_add_header(skb, 0, 0, LLCP_PDU_SYMM);\n\n\t__net_timestamp(skb);\n\n\tnfc_llcp_send_to_raw_sock(local, skb, NFC_DIRECTION_TX);\n\n\treturn nfc_data_exchange(dev, local->target_idx, skb,\n\t\t\t\t nfc_llcp_recv, local);\n}\n\nint nfc_llcp_send_connect(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sk_buff *skb;\n\tu8 *service_name_tlv = NULL, service_name_tlv_length;\n\tu8 *miux_tlv = NULL, miux_tlv_length;\n\tu8 *rw_tlv = NULL, rw_tlv_length, rw;\n\tint err;\n\tu16 size = 0;\n\t__be16 miux;\n\n\tpr_debug(\"Sending CONNECT\\n\");\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tif (sock->service_name != NULL) {\n\t\tservice_name_tlv = nfc_llcp_build_tlv(LLCP_TLV_SN,\n\t\t\t\t\t\t      sock->service_name,\n\t\t\t\t\t\t      sock->service_name_len,\n\t\t\t\t\t\t      &service_name_tlv_length);\n\t\tsize += service_name_tlv_length;\n\t}\n\n\t/* If the socket parameters are not set, use the local ones */\n\tmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\n\t\tlocal->miux : sock->miux;\n\trw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\n\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n\t\t\t\t      &miux_tlv_length);\n\tsize += miux_tlv_length;\n\n\trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n\tsize += rw_tlv_length;\n\n\tpr_debug(\"SKB size %d SN length %zu\\n\", size, sock->service_name_len);\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_CONNECT, size);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\n\tllcp_add_tlv(skb, service_name_tlv, service_name_tlv_length);\n\tllcp_add_tlv(skb, miux_tlv, miux_tlv_length);\n\tllcp_add_tlv(skb, rw_tlv, rw_tlv_length);\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\terr = 0;\n\nerror_tlv:\n\tif (err)\n\t\tpr_err(\"error %d\\n\", err);\n\n\tkfree(service_name_tlv);\n\tkfree(miux_tlv);\n\tkfree(rw_tlv);\n\n\treturn err;\n}\n\nint nfc_llcp_send_cc(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sk_buff *skb;\n\tu8 *miux_tlv = NULL, miux_tlv_length;\n\tu8 *rw_tlv = NULL, rw_tlv_length, rw;\n\tint err;\n\tu16 size = 0;\n\t__be16 miux;\n\n\tpr_debug(\"Sending CC\\n\");\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\t/* If the socket parameters are not set, use the local ones */\n\tmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\n\t\tlocal->miux : sock->miux;\n\trw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\n\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n\t\t\t\t      &miux_tlv_length);\n\tsize += miux_tlv_length;\n\n\trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n\tsize += rw_tlv_length;\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\n\tllcp_add_tlv(skb, miux_tlv, miux_tlv_length);\n\tllcp_add_tlv(skb, rw_tlv, rw_tlv_length);\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\terr = 0;\n\nerror_tlv:\n\tif (err)\n\t\tpr_err(\"error %d\\n\", err);\n\n\tkfree(miux_tlv);\n\tkfree(rw_tlv);\n\n\treturn err;\n}\n\nstatic struct sk_buff *nfc_llcp_allocate_snl(struct nfc_llcp_local *local,\n\t\t\t\t\t     size_t tlv_length)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_dev *dev;\n\tu16 size = 0;\n\n\tif (local == NULL)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tdev = local->dev;\n\tif (dev == NULL)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tsize += LLCP_HEADER_SIZE;\n\tsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\tsize += tlv_length;\n\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\n\tskb = llcp_add_header(skb, LLCP_SAP_SDP, LLCP_SAP_SDP, LLCP_PDU_SNL);\n\n\treturn skb;\n}\n\nint nfc_llcp_send_snl_sdres(struct nfc_llcp_local *local,\n\t\t\t    struct hlist_head *tlv_list, size_t tlvs_len)\n{\n\tstruct nfc_llcp_sdp_tlv *sdp;\n\tstruct hlist_node *n;\n\tstruct sk_buff *skb;\n\n\tskb = nfc_llcp_allocate_snl(local, tlvs_len);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\thlist_for_each_entry_safe(sdp, n, tlv_list, node) {\n\t\tskb_put_data(skb, sdp->tlv, sdp->tlv_len);\n\n\t\thlist_del(&sdp->node);\n\n\t\tnfc_llcp_free_sdp_tlv(sdp);\n\t}\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\treturn 0;\n}\n\nint nfc_llcp_send_snl_sdreq(struct nfc_llcp_local *local,\n\t\t\t    struct hlist_head *tlv_list, size_t tlvs_len)\n{\n\tstruct nfc_llcp_sdp_tlv *sdreq;\n\tstruct hlist_node *n;\n\tstruct sk_buff *skb;\n\n\tskb = nfc_llcp_allocate_snl(local, tlvs_len);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tmutex_lock(&local->sdreq_lock);\n\n\tif (hlist_empty(&local->pending_sdreqs))\n\t\tmod_timer(&local->sdreq_timer,\n\t\t\t  jiffies + msecs_to_jiffies(3 * local->remote_lto));\n\n\thlist_for_each_entry_safe(sdreq, n, tlv_list, node) {\n\t\tpr_debug(\"tid %d for %s\\n\", sdreq->tid, sdreq->uri);\n\n\t\tskb_put_data(skb, sdreq->tlv, sdreq->tlv_len);\n\n\t\thlist_del(&sdreq->node);\n\n\t\thlist_add_head(&sdreq->node, &local->pending_sdreqs);\n\t}\n\n\tmutex_unlock(&local->sdreq_lock);\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\treturn 0;\n}\n\nint nfc_llcp_send_dm(struct nfc_llcp_local *local, u8 ssap, u8 dsap, u8 reason)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_dev *dev;\n\tu16 size = 1; /* Reason code */\n\n\tpr_debug(\"Sending DM reason 0x%x\\n\", reason);\n\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tdev = local->dev;\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\tsize += LLCP_HEADER_SIZE;\n\tsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\n\tskb = llcp_add_header(skb, dsap, ssap, LLCP_PDU_DM);\n\n\tskb_put_data(skb, &reason, 1);\n\n\tskb_queue_head(&local->tx_queue, skb);\n\n\treturn 0;\n}\n\nint nfc_llcp_send_i_frame(struct nfc_llcp_sock *sock,\n\t\t\t  struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *pdu;\n\tstruct sock *sk = &sock->sk;\n\tstruct nfc_llcp_local *local;\n\tsize_t frag_len = 0, remaining_len;\n\tu8 *msg_data, *msg_ptr;\n\tu16 remote_miu;\n\n\tpr_debug(\"Send I frame len %zd\\n\", len);\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\t/* Remote is ready but has not acknowledged our frames */\n\tif((sock->remote_ready &&\n\t    skb_queue_len(&sock->tx_pending_queue) >= sock->remote_rw &&\n\t    skb_queue_len(&sock->tx_queue) >= 2 * sock->remote_rw)) {\n\t\tpr_err(\"Pending queue is full %d frames\\n\",\n\t\t       skb_queue_len(&sock->tx_pending_queue));\n\t\treturn -ENOBUFS;\n\t}\n\n\t/* Remote is not ready and we've been queueing enough frames */\n\tif ((!sock->remote_ready &&\n\t     skb_queue_len(&sock->tx_queue) >= 2 * sock->remote_rw)) {\n\t\tpr_err(\"Tx queue is full %d frames\\n\",\n\t\t       skb_queue_len(&sock->tx_queue));\n\t\treturn -ENOBUFS;\n\t}\n\n\tmsg_data = kmalloc(len, GFP_USER | __GFP_NOWARN);\n\tif (msg_data == NULL)\n\t\treturn -ENOMEM;\n\n\tif (memcpy_from_msg(msg_data, msg, len)) {\n\t\tkfree(msg_data);\n\t\treturn -EFAULT;\n\t}\n\n\tremaining_len = len;\n\tmsg_ptr = msg_data;\n\n\tdo {\n\t\tremote_miu = sock->remote_miu > LLCP_MAX_MIU ?\n\t\t\t\tLLCP_DEFAULT_MIU : sock->remote_miu;\n\n\t\tfrag_len = min_t(size_t, remote_miu, remaining_len);\n\n\t\tpr_debug(\"Fragment %zd bytes remaining %zd\",\n\t\t\t frag_len, remaining_len);\n\n\t\tpdu = llcp_allocate_pdu(sock, LLCP_PDU_I,\n\t\t\t\t\tfrag_len + LLCP_SEQUENCE_SIZE);\n\t\tif (pdu == NULL) {\n\t\t\tkfree(msg_data);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tskb_put(pdu, LLCP_SEQUENCE_SIZE);\n\n\t\tif (likely(frag_len > 0))\n\t\t\tskb_put_data(pdu, msg_ptr, frag_len);\n\n\t\tskb_queue_tail(&sock->tx_queue, pdu);\n\n\t\tlock_sock(sk);\n\n\t\tnfc_llcp_queue_i_frames(sock);\n\n\t\trelease_sock(sk);\n\n\t\tremaining_len -= frag_len;\n\t\tmsg_ptr += frag_len;\n\t} while (remaining_len > 0);\n\n\tkfree(msg_data);\n\n\treturn len;\n}\n\nint nfc_llcp_send_ui_frame(struct nfc_llcp_sock *sock, u8 ssap, u8 dsap,\n\t\t\t   struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *pdu;\n\tstruct nfc_llcp_local *local;\n\tsize_t frag_len = 0, remaining_len;\n\tu8 *msg_ptr, *msg_data;\n\tu16 remote_miu;\n\tint err;\n\n\tpr_debug(\"Send UI frame len %zd\\n\", len);\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tmsg_data = kmalloc(len, GFP_USER | __GFP_NOWARN);\n\tif (msg_data == NULL)\n\t\treturn -ENOMEM;\n\n\tif (memcpy_from_msg(msg_data, msg, len)) {\n\t\tkfree(msg_data);\n\t\treturn -EFAULT;\n\t}\n\n\tremaining_len = len;\n\tmsg_ptr = msg_data;\n\n\tdo {\n\t\tremote_miu = sock->remote_miu > LLCP_MAX_MIU ?\n\t\t\t\tlocal->remote_miu : sock->remote_miu;\n\n\t\tfrag_len = min_t(size_t, remote_miu, remaining_len);\n\n\t\tpr_debug(\"Fragment %zd bytes remaining %zd\",\n\t\t\t frag_len, remaining_len);\n\n\t\tpdu = nfc_alloc_send_skb(sock->dev, &sock->sk, 0,\n\t\t\t\t\t frag_len + LLCP_HEADER_SIZE, &err);\n\t\tif (pdu == NULL) {\n\t\t\tpr_err(\"Could not allocate PDU (error=%d)\\n\", err);\n\t\t\tlen -= remaining_len;\n\t\t\tif (len == 0)\n\t\t\t\tlen = err;\n\t\t\tbreak;\n\t\t}\n\n\t\tpdu = llcp_add_header(pdu, dsap, ssap, LLCP_PDU_UI);\n\n\t\tif (likely(frag_len > 0))\n\t\t\tskb_put_data(pdu, msg_ptr, frag_len);\n\n\t\t/* No need to check for the peer RW for UI frames */\n\t\tskb_queue_tail(&local->tx_queue, pdu);\n\n\t\tremaining_len -= frag_len;\n\t\tmsg_ptr += frag_len;\n\t} while (remaining_len > 0);\n\n\tkfree(msg_data);\n\n\treturn len;\n}\n\nint nfc_llcp_send_rr(struct nfc_llcp_sock *sock)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_llcp_local *local;\n\n\tpr_debug(\"Send rr nr %d\\n\", sock->recv_n);\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_RR, LLCP_SEQUENCE_SIZE);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tskb_put(skb, LLCP_SEQUENCE_SIZE);\n\n\tskb->data[2] = sock->recv_n;\n\n\tskb_queue_head(&local->tx_queue, skb);\n\n\treturn 0;\n}\n", "/*\n * Copyright (C) 2011  Intel Corporation. All rights reserved.\n * Copyright (C) 2014 Marvell International Ltd.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#define pr_fmt(fmt) \"llcp: %s: \" fmt, __func__\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/nfc.h>\n\n#include \"nfc.h\"\n#include \"llcp.h\"\n\nstatic u8 llcp_magic[3] = {0x46, 0x66, 0x6d};\n\nstatic LIST_HEAD(llcp_devices);\n\nstatic void nfc_llcp_rx_skb(struct nfc_llcp_local *local, struct sk_buff *skb);\n\nvoid nfc_llcp_sock_link(struct llcp_sock_list *l, struct sock *sk)\n{\n\twrite_lock(&l->lock);\n\tsk_add_node(sk, &l->head);\n\twrite_unlock(&l->lock);\n}\n\nvoid nfc_llcp_sock_unlink(struct llcp_sock_list *l, struct sock *sk)\n{\n\twrite_lock(&l->lock);\n\tsk_del_node_init(sk);\n\twrite_unlock(&l->lock);\n}\n\nvoid nfc_llcp_socket_remote_param_init(struct nfc_llcp_sock *sock)\n{\n\tsock->remote_rw = LLCP_DEFAULT_RW;\n\tsock->remote_miu = LLCP_MAX_MIU + 1;\n}\n\nstatic void nfc_llcp_socket_purge(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local = sock->local;\n\tstruct sk_buff *s, *tmp;\n\n\tpr_debug(\"%p\\n\", &sock->sk);\n\n\tskb_queue_purge(&sock->tx_queue);\n\tskb_queue_purge(&sock->tx_pending_queue);\n\n\tif (local == NULL)\n\t\treturn;\n\n\t/* Search for local pending SKBs that are related to this socket */\n\tskb_queue_walk_safe(&local->tx_queue, s, tmp) {\n\t\tif (s->sk != &sock->sk)\n\t\t\tcontinue;\n\n\t\tskb_unlink(s, &local->tx_queue);\n\t\tkfree_skb(s);\n\t}\n}\n\nstatic void nfc_llcp_socket_release(struct nfc_llcp_local *local, bool device,\n\t\t\t\t    int err)\n{\n\tstruct sock *sk;\n\tstruct hlist_node *tmp;\n\tstruct nfc_llcp_sock *llcp_sock;\n\n\tskb_queue_purge(&local->tx_queue);\n\n\twrite_lock(&local->sockets.lock);\n\n\tsk_for_each_safe(sk, tmp, &local->sockets.head) {\n\t\tllcp_sock = nfc_llcp_sock(sk);\n\n\t\tbh_lock_sock(sk);\n\n\t\tnfc_llcp_socket_purge(llcp_sock);\n\n\t\tif (sk->sk_state == LLCP_CONNECTED)\n\t\t\tnfc_put_device(llcp_sock->dev);\n\n\t\tif (sk->sk_state == LLCP_LISTEN) {\n\t\t\tstruct nfc_llcp_sock *lsk, *n;\n\t\t\tstruct sock *accept_sk;\n\n\t\t\tlist_for_each_entry_safe(lsk, n,\n\t\t\t\t\t\t &llcp_sock->accept_queue,\n\t\t\t\t\t\t accept_queue) {\n\t\t\t\taccept_sk = &lsk->sk;\n\t\t\t\tbh_lock_sock(accept_sk);\n\n\t\t\t\tnfc_llcp_accept_unlink(accept_sk);\n\n\t\t\t\tif (err)\n\t\t\t\t\taccept_sk->sk_err = err;\n\t\t\t\taccept_sk->sk_state = LLCP_CLOSED;\n\t\t\t\taccept_sk->sk_state_change(sk);\n\n\t\t\t\tbh_unlock_sock(accept_sk);\n\t\t\t}\n\t\t}\n\n\t\tif (err)\n\t\t\tsk->sk_err = err;\n\t\tsk->sk_state = LLCP_CLOSED;\n\t\tsk->sk_state_change(sk);\n\n\t\tbh_unlock_sock(sk);\n\n\t\tsk_del_node_init(sk);\n\t}\n\n\twrite_unlock(&local->sockets.lock);\n\n\t/* If we still have a device, we keep the RAW sockets alive */\n\tif (device == true)\n\t\treturn;\n\n\twrite_lock(&local->raw_sockets.lock);\n\n\tsk_for_each_safe(sk, tmp, &local->raw_sockets.head) {\n\t\tllcp_sock = nfc_llcp_sock(sk);\n\n\t\tbh_lock_sock(sk);\n\n\t\tnfc_llcp_socket_purge(llcp_sock);\n\n\t\tif (err)\n\t\t\tsk->sk_err = err;\n\t\tsk->sk_state = LLCP_CLOSED;\n\t\tsk->sk_state_change(sk);\n\n\t\tbh_unlock_sock(sk);\n\n\t\tsk_del_node_init(sk);\n\t}\n\n\twrite_unlock(&local->raw_sockets.lock);\n}\n\nstruct nfc_llcp_local *nfc_llcp_local_get(struct nfc_llcp_local *local)\n{\n\tkref_get(&local->ref);\n\n\treturn local;\n}\n\nstatic void local_cleanup(struct nfc_llcp_local *local)\n{\n\tnfc_llcp_socket_release(local, false, ENXIO);\n\tdel_timer_sync(&local->link_timer);\n\tskb_queue_purge(&local->tx_queue);\n\tcancel_work_sync(&local->tx_work);\n\tcancel_work_sync(&local->rx_work);\n\tcancel_work_sync(&local->timeout_work);\n\tkfree_skb(local->rx_pending);\n\tdel_timer_sync(&local->sdreq_timer);\n\tcancel_work_sync(&local->sdreq_timeout_work);\n\tnfc_llcp_free_sdp_tlv_list(&local->pending_sdreqs);\n}\n\nstatic void local_release(struct kref *ref)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = container_of(ref, struct nfc_llcp_local, ref);\n\n\tlist_del(&local->list);\n\tlocal_cleanup(local);\n\tkfree(local);\n}\n\nint nfc_llcp_local_put(struct nfc_llcp_local *local)\n{\n\tif (local == NULL)\n\t\treturn 0;\n\n\treturn kref_put(&local->ref, local_release);\n}\n\nstatic struct nfc_llcp_sock *nfc_llcp_sock_get(struct nfc_llcp_local *local,\n\t\t\t\t\t       u8 ssap, u8 dsap)\n{\n\tstruct sock *sk;\n\tstruct nfc_llcp_sock *llcp_sock, *tmp_sock;\n\n\tpr_debug(\"ssap dsap %d %d\\n\", ssap, dsap);\n\n\tif (ssap == 0 && dsap == 0)\n\t\treturn NULL;\n\n\tread_lock(&local->sockets.lock);\n\n\tllcp_sock = NULL;\n\n\tsk_for_each(sk, &local->sockets.head) {\n\t\ttmp_sock = nfc_llcp_sock(sk);\n\n\t\tif (tmp_sock->ssap == ssap && tmp_sock->dsap == dsap) {\n\t\t\tllcp_sock = tmp_sock;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tread_unlock(&local->sockets.lock);\n\n\tif (llcp_sock == NULL)\n\t\treturn NULL;\n\n\tsock_hold(&llcp_sock->sk);\n\n\treturn llcp_sock;\n}\n\nstatic void nfc_llcp_sock_put(struct nfc_llcp_sock *sock)\n{\n\tsock_put(&sock->sk);\n}\n\nstatic void nfc_llcp_timeout_work(struct work_struct *work)\n{\n\tstruct nfc_llcp_local *local = container_of(work, struct nfc_llcp_local,\n\t\t\t\t\t\t    timeout_work);\n\n\tnfc_dep_link_down(local->dev);\n}\n\nstatic void nfc_llcp_symm_timer(struct timer_list *t)\n{\n\tstruct nfc_llcp_local *local = from_timer(local, t, link_timer);\n\n\tpr_err(\"SYMM timeout\\n\");\n\n\tschedule_work(&local->timeout_work);\n}\n\nstatic void nfc_llcp_sdreq_timeout_work(struct work_struct *work)\n{\n\tunsigned long time;\n\tHLIST_HEAD(nl_sdres_list);\n\tstruct hlist_node *n;\n\tstruct nfc_llcp_sdp_tlv *sdp;\n\tstruct nfc_llcp_local *local = container_of(work, struct nfc_llcp_local,\n\t\t\t\t\t\t    sdreq_timeout_work);\n\n\tmutex_lock(&local->sdreq_lock);\n\n\ttime = jiffies - msecs_to_jiffies(3 * local->remote_lto);\n\n\thlist_for_each_entry_safe(sdp, n, &local->pending_sdreqs, node) {\n\t\tif (time_after(sdp->time, time))\n\t\t\tcontinue;\n\n\t\tsdp->sap = LLCP_SDP_UNBOUND;\n\n\t\thlist_del(&sdp->node);\n\n\t\thlist_add_head(&sdp->node, &nl_sdres_list);\n\t}\n\n\tif (!hlist_empty(&local->pending_sdreqs))\n\t\tmod_timer(&local->sdreq_timer,\n\t\t\t  jiffies + msecs_to_jiffies(3 * local->remote_lto));\n\n\tmutex_unlock(&local->sdreq_lock);\n\n\tif (!hlist_empty(&nl_sdres_list))\n\t\tnfc_genl_llc_send_sdres(local->dev, &nl_sdres_list);\n}\n\nstatic void nfc_llcp_sdreq_timer(struct timer_list *t)\n{\n\tstruct nfc_llcp_local *local = from_timer(local, t, sdreq_timer);\n\n\tschedule_work(&local->sdreq_timeout_work);\n}\n\nstruct nfc_llcp_local *nfc_llcp_find_local(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlist_for_each_entry(local, &llcp_devices, list)\n\t\tif (local->dev == dev)\n\t\t\treturn local;\n\n\tpr_debug(\"No device found\\n\");\n\n\treturn NULL;\n}\n\nstatic char *wks[] = {\n\tNULL,\n\tNULL, /* SDP */\n\t\"urn:nfc:sn:ip\",\n\t\"urn:nfc:sn:obex\",\n\t\"urn:nfc:sn:snep\",\n};\n\nstatic int nfc_llcp_wks_sap(char *service_name, size_t service_name_len)\n{\n\tint sap, num_wks;\n\n\tpr_debug(\"%s\\n\", service_name);\n\n\tif (service_name == NULL)\n\t\treturn -EINVAL;\n\n\tnum_wks = ARRAY_SIZE(wks);\n\n\tfor (sap = 0; sap < num_wks; sap++) {\n\t\tif (wks[sap] == NULL)\n\t\t\tcontinue;\n\n\t\tif (strncmp(wks[sap], service_name, service_name_len) == 0)\n\t\t\treturn sap;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic\nstruct nfc_llcp_sock *nfc_llcp_sock_from_sn(struct nfc_llcp_local *local,\n\t\t\t\t\t    u8 *sn, size_t sn_len)\n{\n\tstruct sock *sk;\n\tstruct nfc_llcp_sock *llcp_sock, *tmp_sock;\n\n\tpr_debug(\"sn %zd %p\\n\", sn_len, sn);\n\n\tif (sn == NULL || sn_len == 0)\n\t\treturn NULL;\n\n\tread_lock(&local->sockets.lock);\n\n\tllcp_sock = NULL;\n\n\tsk_for_each(sk, &local->sockets.head) {\n\t\ttmp_sock = nfc_llcp_sock(sk);\n\n\t\tpr_debug(\"llcp sock %p\\n\", tmp_sock);\n\n\t\tif (tmp_sock->sk.sk_type == SOCK_STREAM &&\n\t\t    tmp_sock->sk.sk_state != LLCP_LISTEN)\n\t\t\tcontinue;\n\n\t\tif (tmp_sock->sk.sk_type == SOCK_DGRAM &&\n\t\t    tmp_sock->sk.sk_state != LLCP_BOUND)\n\t\t\tcontinue;\n\n\t\tif (tmp_sock->service_name == NULL ||\n\t\t    tmp_sock->service_name_len == 0)\n\t\t\tcontinue;\n\n\t\tif (tmp_sock->service_name_len != sn_len)\n\t\t\tcontinue;\n\n\t\tif (memcmp(sn, tmp_sock->service_name, sn_len) == 0) {\n\t\t\tllcp_sock = tmp_sock;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tread_unlock(&local->sockets.lock);\n\n\tpr_debug(\"Found llcp sock %p\\n\", llcp_sock);\n\n\treturn llcp_sock;\n}\n\nu8 nfc_llcp_get_sdp_ssap(struct nfc_llcp_local *local,\n\t\t\t struct nfc_llcp_sock *sock)\n{\n\tmutex_lock(&local->sdp_lock);\n\n\tif (sock->service_name != NULL && sock->service_name_len > 0) {\n\t\tint ssap = nfc_llcp_wks_sap(sock->service_name,\n\t\t\t\t\t    sock->service_name_len);\n\n\t\tif (ssap > 0) {\n\t\t\tpr_debug(\"WKS %d\\n\", ssap);\n\n\t\t\t/* This is a WKS, let's check if it's free */\n\t\t\tif (local->local_wks & BIT(ssap)) {\n\t\t\t\tmutex_unlock(&local->sdp_lock);\n\n\t\t\t\treturn LLCP_SAP_MAX;\n\t\t\t}\n\n\t\t\tset_bit(ssap, &local->local_wks);\n\t\t\tmutex_unlock(&local->sdp_lock);\n\n\t\t\treturn ssap;\n\t\t}\n\n\t\t/*\n\t\t * Check if there already is a non WKS socket bound\n\t\t * to this service name.\n\t\t */\n\t\tif (nfc_llcp_sock_from_sn(local, sock->service_name,\n\t\t\t\t\t  sock->service_name_len) != NULL) {\n\t\t\tmutex_unlock(&local->sdp_lock);\n\n\t\t\treturn LLCP_SAP_MAX;\n\t\t}\n\n\t\tmutex_unlock(&local->sdp_lock);\n\n\t\treturn LLCP_SDP_UNBOUND;\n\n\t} else if (sock->ssap != 0 && sock->ssap < LLCP_WKS_NUM_SAP) {\n\t\tif (!test_bit(sock->ssap, &local->local_wks)) {\n\t\t\tset_bit(sock->ssap, &local->local_wks);\n\t\t\tmutex_unlock(&local->sdp_lock);\n\n\t\t\treturn sock->ssap;\n\t\t}\n\t}\n\n\tmutex_unlock(&local->sdp_lock);\n\n\treturn LLCP_SAP_MAX;\n}\n\nu8 nfc_llcp_get_local_ssap(struct nfc_llcp_local *local)\n{\n\tu8 local_ssap;\n\n\tmutex_lock(&local->sdp_lock);\n\n\tlocal_ssap = find_first_zero_bit(&local->local_sap, LLCP_LOCAL_NUM_SAP);\n\tif (local_ssap == LLCP_LOCAL_NUM_SAP) {\n\t\tmutex_unlock(&local->sdp_lock);\n\t\treturn LLCP_SAP_MAX;\n\t}\n\n\tset_bit(local_ssap, &local->local_sap);\n\n\tmutex_unlock(&local->sdp_lock);\n\n\treturn local_ssap + LLCP_LOCAL_SAP_OFFSET;\n}\n\nvoid nfc_llcp_put_ssap(struct nfc_llcp_local *local, u8 ssap)\n{\n\tu8 local_ssap;\n\tunsigned long *sdp;\n\n\tif (ssap < LLCP_WKS_NUM_SAP) {\n\t\tlocal_ssap = ssap;\n\t\tsdp = &local->local_wks;\n\t} else if (ssap < LLCP_LOCAL_NUM_SAP) {\n\t\tatomic_t *client_cnt;\n\n\t\tlocal_ssap = ssap - LLCP_WKS_NUM_SAP;\n\t\tsdp = &local->local_sdp;\n\t\tclient_cnt = &local->local_sdp_cnt[local_ssap];\n\n\t\tpr_debug(\"%d clients\\n\", atomic_read(client_cnt));\n\n\t\tmutex_lock(&local->sdp_lock);\n\n\t\tif (atomic_dec_and_test(client_cnt)) {\n\t\t\tstruct nfc_llcp_sock *l_sock;\n\n\t\t\tpr_debug(\"No more clients for SAP %d\\n\", ssap);\n\n\t\t\tclear_bit(local_ssap, sdp);\n\n\t\t\t/* Find the listening sock and set it back to UNBOUND */\n\t\t\tl_sock = nfc_llcp_sock_get(local, ssap, LLCP_SAP_SDP);\n\t\t\tif (l_sock) {\n\t\t\t\tl_sock->ssap = LLCP_SDP_UNBOUND;\n\t\t\t\tnfc_llcp_sock_put(l_sock);\n\t\t\t}\n\t\t}\n\n\t\tmutex_unlock(&local->sdp_lock);\n\n\t\treturn;\n\t} else if (ssap < LLCP_MAX_SAP) {\n\t\tlocal_ssap = ssap - LLCP_LOCAL_NUM_SAP;\n\t\tsdp = &local->local_sap;\n\t} else {\n\t\treturn;\n\t}\n\n\tmutex_lock(&local->sdp_lock);\n\n\tclear_bit(local_ssap, sdp);\n\n\tmutex_unlock(&local->sdp_lock);\n}\n\nstatic u8 nfc_llcp_reserve_sdp_ssap(struct nfc_llcp_local *local)\n{\n\tu8 ssap;\n\n\tmutex_lock(&local->sdp_lock);\n\n\tssap = find_first_zero_bit(&local->local_sdp, LLCP_SDP_NUM_SAP);\n\tif (ssap == LLCP_SDP_NUM_SAP) {\n\t\tmutex_unlock(&local->sdp_lock);\n\n\t\treturn LLCP_SAP_MAX;\n\t}\n\n\tpr_debug(\"SDP ssap %d\\n\", LLCP_WKS_NUM_SAP + ssap);\n\n\tset_bit(ssap, &local->local_sdp);\n\n\tmutex_unlock(&local->sdp_lock);\n\n\treturn LLCP_WKS_NUM_SAP + ssap;\n}\n\nstatic int nfc_llcp_build_gb(struct nfc_llcp_local *local)\n{\n\tu8 *gb_cur, *version_tlv, version, version_length;\n\tu8 *lto_tlv, lto_length;\n\tu8 *wks_tlv, wks_length;\n\tu8 *miux_tlv, miux_length;\n\t__be16 wks = cpu_to_be16(local->local_wks);\n\tu8 gb_len = 0;\n\tint ret = 0;\n\n\tversion = LLCP_VERSION_11;\n\tversion_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,\n\t\t\t\t\t 1, &version_length);\n\tgb_len += version_length;\n\n\tlto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);\n\tgb_len += lto_length;\n\n\tpr_debug(\"Local wks 0x%lx\\n\", local->local_wks);\n\twks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);\n\tgb_len += wks_length;\n\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,\n\t\t\t\t      &miux_length);\n\tgb_len += miux_length;\n\n\tgb_len += ARRAY_SIZE(llcp_magic);\n\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tgb_cur = local->gb;\n\n\tmemcpy(gb_cur, llcp_magic, ARRAY_SIZE(llcp_magic));\n\tgb_cur += ARRAY_SIZE(llcp_magic);\n\n\tmemcpy(gb_cur, version_tlv, version_length);\n\tgb_cur += version_length;\n\n\tmemcpy(gb_cur, lto_tlv, lto_length);\n\tgb_cur += lto_length;\n\n\tmemcpy(gb_cur, wks_tlv, wks_length);\n\tgb_cur += wks_length;\n\n\tmemcpy(gb_cur, miux_tlv, miux_length);\n\tgb_cur += miux_length;\n\n\tlocal->gb_len = gb_len;\n\nout:\n\tkfree(version_tlv);\n\tkfree(lto_tlv);\n\tkfree(wks_tlv);\n\tkfree(miux_tlv);\n\n\treturn ret;\n}\n\nu8 *nfc_llcp_general_bytes(struct nfc_dev *dev, size_t *general_bytes_len)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\t*general_bytes_len = 0;\n\t\treturn NULL;\n\t}\n\n\tnfc_llcp_build_gb(local);\n\n\t*general_bytes_len = local->gb_len;\n\n\treturn local->gb;\n}\n\nint nfc_llcp_set_remote_gb(struct nfc_dev *dev, u8 *gb, u8 gb_len)\n{\n\tstruct nfc_llcp_local *local;\n\n\tif (gb_len < 3 || gb_len > NFC_MAX_GT_LEN)\n\t\treturn -EINVAL;\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tpr_err(\"No LLCP device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmemset(local->remote_gb, 0, NFC_MAX_GT_LEN);\n\tmemcpy(local->remote_gb, gb, gb_len);\n\tlocal->remote_gb_len = gb_len;\n\n\tif (memcmp(local->remote_gb, llcp_magic, 3)) {\n\t\tpr_err(\"MAC does not support LLCP\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn nfc_llcp_parse_gb_tlv(local,\n\t\t\t\t     &local->remote_gb[3],\n\t\t\t\t     local->remote_gb_len - 3);\n}\n\nstatic u8 nfc_llcp_dsap(struct sk_buff *pdu)\n{\n\treturn (pdu->data[0] & 0xfc) >> 2;\n}\n\nstatic u8 nfc_llcp_ptype(struct sk_buff *pdu)\n{\n\treturn ((pdu->data[0] & 0x03) << 2) | ((pdu->data[1] & 0xc0) >> 6);\n}\n\nstatic u8 nfc_llcp_ssap(struct sk_buff *pdu)\n{\n\treturn pdu->data[1] & 0x3f;\n}\n\nstatic u8 nfc_llcp_ns(struct sk_buff *pdu)\n{\n\treturn pdu->data[2] >> 4;\n}\n\nstatic u8 nfc_llcp_nr(struct sk_buff *pdu)\n{\n\treturn pdu->data[2] & 0xf;\n}\n\nstatic void nfc_llcp_set_nrns(struct nfc_llcp_sock *sock, struct sk_buff *pdu)\n{\n\tpdu->data[2] = (sock->send_n << 4) | (sock->recv_n);\n\tsock->send_n = (sock->send_n + 1) % 16;\n\tsock->recv_ack_n = (sock->recv_n - 1) % 16;\n}\n\nvoid nfc_llcp_send_to_raw_sock(struct nfc_llcp_local *local,\n\t\t\t       struct sk_buff *skb, u8 direction)\n{\n\tstruct sk_buff *skb_copy = NULL, *nskb;\n\tstruct sock *sk;\n\tu8 *data;\n\n\tread_lock(&local->raw_sockets.lock);\n\n\tsk_for_each(sk, &local->raw_sockets.head) {\n\t\tif (sk->sk_state != LLCP_BOUND)\n\t\t\tcontinue;\n\n\t\tif (skb_copy == NULL) {\n\t\t\tskb_copy = __pskb_copy_fclone(skb, NFC_RAW_HEADER_SIZE,\n\t\t\t\t\t\t      GFP_ATOMIC, true);\n\n\t\t\tif (skb_copy == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tdata = skb_push(skb_copy, NFC_RAW_HEADER_SIZE);\n\n\t\t\tdata[0] = local->dev ? local->dev->idx : 0xFF;\n\t\t\tdata[1] = direction & 0x01;\n\t\t\tdata[1] |= (RAW_PAYLOAD_LLCP << 1);\n\t\t}\n\n\t\tnskb = skb_clone(skb_copy, GFP_ATOMIC);\n\t\tif (!nskb)\n\t\t\tcontinue;\n\n\t\tif (sock_queue_rcv_skb(sk, nskb))\n\t\t\tkfree_skb(nskb);\n\t}\n\n\tread_unlock(&local->raw_sockets.lock);\n\n\tkfree_skb(skb_copy);\n}\n\nstatic void nfc_llcp_tx_work(struct work_struct *work)\n{\n\tstruct nfc_llcp_local *local = container_of(work, struct nfc_llcp_local,\n\t\t\t\t\t\t    tx_work);\n\tstruct sk_buff *skb;\n\tstruct sock *sk;\n\tstruct nfc_llcp_sock *llcp_sock;\n\n\tskb = skb_dequeue(&local->tx_queue);\n\tif (skb != NULL) {\n\t\tsk = skb->sk;\n\t\tllcp_sock = nfc_llcp_sock(sk);\n\n\t\tif (llcp_sock == NULL && nfc_llcp_ptype(skb) == LLCP_PDU_I) {\n\t\t\tkfree_skb(skb);\n\t\t\tnfc_llcp_send_symm(local->dev);\n\t\t} else if (llcp_sock && !llcp_sock->remote_ready) {\n\t\t\tskb_queue_head(&local->tx_queue, skb);\n\t\t\tnfc_llcp_send_symm(local->dev);\n\t\t} else {\n\t\t\tstruct sk_buff *copy_skb = NULL;\n\t\t\tu8 ptype = nfc_llcp_ptype(skb);\n\t\t\tint ret;\n\n\t\t\tpr_debug(\"Sending pending skb\\n\");\n\t\t\tprint_hex_dump_debug(\"LLCP Tx: \", DUMP_PREFIX_OFFSET,\n\t\t\t\t\t     16, 1, skb->data, skb->len, true);\n\n\t\t\tif (ptype == LLCP_PDU_DISC && sk != NULL &&\n\t\t\t    sk->sk_state == LLCP_DISCONNECTING) {\n\t\t\t\tnfc_llcp_sock_unlink(&local->sockets, sk);\n\t\t\t\tsock_orphan(sk);\n\t\t\t\tsock_put(sk);\n\t\t\t}\n\n\t\t\tif (ptype == LLCP_PDU_I)\n\t\t\t\tcopy_skb = skb_copy(skb, GFP_ATOMIC);\n\n\t\t\t__net_timestamp(skb);\n\n\t\t\tnfc_llcp_send_to_raw_sock(local, skb,\n\t\t\t\t\t\t  NFC_DIRECTION_TX);\n\n\t\t\tret = nfc_data_exchange(local->dev, local->target_idx,\n\t\t\t\t\t\tskb, nfc_llcp_recv, local);\n\n\t\t\tif (ret) {\n\t\t\t\tkfree_skb(copy_skb);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (ptype == LLCP_PDU_I && copy_skb)\n\t\t\t\tskb_queue_tail(&llcp_sock->tx_pending_queue,\n\t\t\t\t\t       copy_skb);\n\t\t}\n\t} else {\n\t\tnfc_llcp_send_symm(local->dev);\n\t}\n\nout:\n\tmod_timer(&local->link_timer,\n\t\t  jiffies + msecs_to_jiffies(2 * local->remote_lto));\n}\n\nstatic struct nfc_llcp_sock *nfc_llcp_connecting_sock_get(struct nfc_llcp_local *local,\n\t\t\t\t\t\t\t  u8 ssap)\n{\n\tstruct sock *sk;\n\tstruct nfc_llcp_sock *llcp_sock;\n\n\tread_lock(&local->connecting_sockets.lock);\n\n\tsk_for_each(sk, &local->connecting_sockets.head) {\n\t\tllcp_sock = nfc_llcp_sock(sk);\n\n\t\tif (llcp_sock->ssap == ssap) {\n\t\t\tsock_hold(&llcp_sock->sk);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tllcp_sock = NULL;\n\nout:\n\tread_unlock(&local->connecting_sockets.lock);\n\n\treturn llcp_sock;\n}\n\nstatic struct nfc_llcp_sock *nfc_llcp_sock_get_sn(struct nfc_llcp_local *local,\n\t\t\t\t\t\t  u8 *sn, size_t sn_len)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\n\tllcp_sock = nfc_llcp_sock_from_sn(local, sn, sn_len);\n\n\tif (llcp_sock == NULL)\n\t\treturn NULL;\n\n\tsock_hold(&llcp_sock->sk);\n\n\treturn llcp_sock;\n}\n\nstatic u8 *nfc_llcp_connect_sn(struct sk_buff *skb, size_t *sn_len)\n{\n\tu8 *tlv = &skb->data[2], type, length;\n\tsize_t tlv_array_len = skb->len - LLCP_HEADER_SIZE, offset = 0;\n\n\twhile (offset < tlv_array_len) {\n\t\ttype = tlv[0];\n\t\tlength = tlv[1];\n\n\t\tpr_debug(\"type 0x%x length %d\\n\", type, length);\n\n\t\tif (type == LLCP_TLV_SN) {\n\t\t\t*sn_len = length;\n\t\t\treturn &tlv[2];\n\t\t}\n\n\t\toffset += length + 2;\n\t\ttlv += length + 2;\n\t}\n\n\treturn NULL;\n}\n\nstatic void nfc_llcp_recv_ui(struct nfc_llcp_local *local,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct nfc_llcp_ui_cb *ui_cb;\n\tu8 dsap, ssap;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tui_cb = nfc_llcp_ui_skb_cb(skb);\n\tui_cb->dsap = dsap;\n\tui_cb->ssap = ssap;\n\n\tpr_debug(\"%d %d\\n\", dsap, ssap);\n\n\t/* We're looking for a bound socket, not a client one */\n\tllcp_sock = nfc_llcp_sock_get(local, dsap, LLCP_SAP_SDP);\n\tif (llcp_sock == NULL || llcp_sock->sk.sk_type != SOCK_DGRAM)\n\t\treturn;\n\n\t/* There is no sequence with UI frames */\n\tskb_pull(skb, LLCP_HEADER_SIZE);\n\tif (!sock_queue_rcv_skb(&llcp_sock->sk, skb)) {\n\t\t/*\n\t\t * UI frames will be freed from the socket layer, so we\n\t\t * need to keep them alive until someone receives them.\n\t\t */\n\t\tskb_get(skb);\n\t} else {\n\t\tpr_err(\"Receive queue is full\\n\");\n\t}\n\n\tnfc_llcp_sock_put(llcp_sock);\n}\n\nstatic void nfc_llcp_recv_connect(struct nfc_llcp_local *local,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct sock *new_sk, *parent;\n\tstruct nfc_llcp_sock *sock, *new_sock;\n\tu8 dsap, ssap, reason;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tpr_debug(\"%d %d\\n\", dsap, ssap);\n\n\tif (dsap != LLCP_SAP_SDP) {\n\t\tsock = nfc_llcp_sock_get(local, dsap, LLCP_SAP_SDP);\n\t\tif (sock == NULL || sock->sk.sk_state != LLCP_LISTEN) {\n\t\t\treason = LLCP_DM_NOBOUND;\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\tu8 *sn;\n\t\tsize_t sn_len;\n\n\t\tsn = nfc_llcp_connect_sn(skb, &sn_len);\n\t\tif (sn == NULL) {\n\t\t\treason = LLCP_DM_NOBOUND;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tpr_debug(\"Service name length %zu\\n\", sn_len);\n\n\t\tsock = nfc_llcp_sock_get_sn(local, sn, sn_len);\n\t\tif (sock == NULL) {\n\t\t\treason = LLCP_DM_NOBOUND;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tlock_sock(&sock->sk);\n\n\tparent = &sock->sk;\n\n\tif (sk_acceptq_is_full(parent)) {\n\t\treason = LLCP_DM_REJ;\n\t\trelease_sock(&sock->sk);\n\t\tsock_put(&sock->sk);\n\t\tgoto fail;\n\t}\n\n\tif (sock->ssap == LLCP_SDP_UNBOUND) {\n\t\tu8 ssap = nfc_llcp_reserve_sdp_ssap(local);\n\n\t\tpr_debug(\"First client, reserving %d\\n\", ssap);\n\n\t\tif (ssap == LLCP_SAP_MAX) {\n\t\t\treason = LLCP_DM_REJ;\n\t\t\trelease_sock(&sock->sk);\n\t\t\tsock_put(&sock->sk);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tsock->ssap = ssap;\n\t}\n\n\tnew_sk = nfc_llcp_sock_alloc(NULL, parent->sk_type, GFP_ATOMIC, 0);\n\tif (new_sk == NULL) {\n\t\treason = LLCP_DM_REJ;\n\t\trelease_sock(&sock->sk);\n\t\tsock_put(&sock->sk);\n\t\tgoto fail;\n\t}\n\n\tnew_sock = nfc_llcp_sock(new_sk);\n\tnew_sock->dev = local->dev;\n\tnew_sock->local = nfc_llcp_local_get(local);\n\tnew_sock->rw = sock->rw;\n\tnew_sock->miux = sock->miux;\n\tnew_sock->nfc_protocol = sock->nfc_protocol;\n\tnew_sock->dsap = ssap;\n\tnew_sock->target_idx = local->target_idx;\n\tnew_sock->parent = parent;\n\tnew_sock->ssap = sock->ssap;\n\tif (sock->ssap < LLCP_LOCAL_NUM_SAP && sock->ssap >= LLCP_WKS_NUM_SAP) {\n\t\tatomic_t *client_count;\n\n\t\tpr_debug(\"reserved_ssap %d for %p\\n\", sock->ssap, new_sock);\n\n\t\tclient_count =\n\t\t\t&local->local_sdp_cnt[sock->ssap - LLCP_WKS_NUM_SAP];\n\n\t\tatomic_inc(client_count);\n\t\tnew_sock->reserved_ssap = sock->ssap;\n\t}\n\n\tnfc_llcp_parse_connection_tlv(new_sock, &skb->data[LLCP_HEADER_SIZE],\n\t\t\t\t      skb->len - LLCP_HEADER_SIZE);\n\n\tpr_debug(\"new sock %p sk %p\\n\", new_sock, &new_sock->sk);\n\n\tnfc_llcp_sock_link(&local->sockets, new_sk);\n\n\tnfc_llcp_accept_enqueue(&sock->sk, new_sk);\n\n\tnfc_get_device(local->dev->idx);\n\n\tnew_sk->sk_state = LLCP_CONNECTED;\n\n\t/* Wake the listening processes */\n\tparent->sk_data_ready(parent);\n\n\t/* Send CC */\n\tnfc_llcp_send_cc(new_sock);\n\n\trelease_sock(&sock->sk);\n\tsock_put(&sock->sk);\n\n\treturn;\n\nfail:\n\t/* Send DM */\n\tnfc_llcp_send_dm(local, dsap, ssap, reason);\n}\n\nint nfc_llcp_queue_i_frames(struct nfc_llcp_sock *sock)\n{\n\tint nr_frames = 0;\n\tstruct nfc_llcp_local *local = sock->local;\n\n\tpr_debug(\"Remote ready %d tx queue len %d remote rw %d\",\n\t\t sock->remote_ready, skb_queue_len(&sock->tx_pending_queue),\n\t\t sock->remote_rw);\n\n\t/* Try to queue some I frames for transmission */\n\twhile (sock->remote_ready &&\n\t       skb_queue_len(&sock->tx_pending_queue) < sock->remote_rw) {\n\t\tstruct sk_buff *pdu;\n\n\t\tpdu = skb_dequeue(&sock->tx_queue);\n\t\tif (pdu == NULL)\n\t\t\tbreak;\n\n\t\t/* Update N(S)/N(R) */\n\t\tnfc_llcp_set_nrns(sock, pdu);\n\n\t\tskb_queue_tail(&local->tx_queue, pdu);\n\t\tnr_frames++;\n\t}\n\n\treturn nr_frames;\n}\n\nstatic void nfc_llcp_recv_hdlc(struct nfc_llcp_local *local,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct sock *sk;\n\tu8 dsap, ssap, ptype, ns, nr;\n\n\tptype = nfc_llcp_ptype(skb);\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\tns = nfc_llcp_ns(skb);\n\tnr = nfc_llcp_nr(skb);\n\n\tpr_debug(\"%d %d R %d S %d\\n\", dsap, ssap, nr, ns);\n\n\tllcp_sock = nfc_llcp_sock_get(local, dsap, ssap);\n\tif (llcp_sock == NULL) {\n\t\tnfc_llcp_send_dm(local, dsap, ssap, LLCP_DM_NOCONN);\n\t\treturn;\n\t}\n\n\tsk = &llcp_sock->sk;\n\tlock_sock(sk);\n\tif (sk->sk_state == LLCP_CLOSED) {\n\t\trelease_sock(sk);\n\t\tnfc_llcp_sock_put(llcp_sock);\n\t}\n\n\t/* Pass the payload upstream */\n\tif (ptype == LLCP_PDU_I) {\n\t\tpr_debug(\"I frame, queueing on %p\\n\", &llcp_sock->sk);\n\n\t\tif (ns == llcp_sock->recv_n)\n\t\t\tllcp_sock->recv_n = (llcp_sock->recv_n + 1) % 16;\n\t\telse\n\t\t\tpr_err(\"Received out of sequence I PDU\\n\");\n\n\t\tskb_pull(skb, LLCP_HEADER_SIZE + LLCP_SEQUENCE_SIZE);\n\t\tif (!sock_queue_rcv_skb(&llcp_sock->sk, skb)) {\n\t\t\t/*\n\t\t\t * I frames will be freed from the socket layer, so we\n\t\t\t * need to keep them alive until someone receives them.\n\t\t\t */\n\t\t\tskb_get(skb);\n\t\t} else {\n\t\t\tpr_err(\"Receive queue is full\\n\");\n\t\t}\n\t}\n\n\t/* Remove skbs from the pending queue */\n\tif (llcp_sock->send_ack_n != nr) {\n\t\tstruct sk_buff *s, *tmp;\n\t\tu8 n;\n\n\t\tllcp_sock->send_ack_n = nr;\n\n\t\t/* Remove and free all skbs until ns == nr */\n\t\tskb_queue_walk_safe(&llcp_sock->tx_pending_queue, s, tmp) {\n\t\t\tn = nfc_llcp_ns(s);\n\n\t\t\tskb_unlink(s, &llcp_sock->tx_pending_queue);\n\t\t\tkfree_skb(s);\n\n\t\t\tif (n == nr)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Re-queue the remaining skbs for transmission */\n\t\tskb_queue_reverse_walk_safe(&llcp_sock->tx_pending_queue,\n\t\t\t\t\t    s, tmp) {\n\t\t\tskb_unlink(s, &llcp_sock->tx_pending_queue);\n\t\t\tskb_queue_head(&local->tx_queue, s);\n\t\t}\n\t}\n\n\tif (ptype == LLCP_PDU_RR)\n\t\tllcp_sock->remote_ready = true;\n\telse if (ptype == LLCP_PDU_RNR)\n\t\tllcp_sock->remote_ready = false;\n\n\tif (nfc_llcp_queue_i_frames(llcp_sock) == 0 && ptype == LLCP_PDU_I)\n\t\tnfc_llcp_send_rr(llcp_sock);\n\n\trelease_sock(sk);\n\tnfc_llcp_sock_put(llcp_sock);\n}\n\nstatic void nfc_llcp_recv_disc(struct nfc_llcp_local *local,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct sock *sk;\n\tu8 dsap, ssap;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tif ((dsap == 0) && (ssap == 0)) {\n\t\tpr_debug(\"Connection termination\");\n\t\tnfc_dep_link_down(local->dev);\n\t\treturn;\n\t}\n\n\tllcp_sock = nfc_llcp_sock_get(local, dsap, ssap);\n\tif (llcp_sock == NULL) {\n\t\tnfc_llcp_send_dm(local, dsap, ssap, LLCP_DM_NOCONN);\n\t\treturn;\n\t}\n\n\tsk = &llcp_sock->sk;\n\tlock_sock(sk);\n\n\tnfc_llcp_socket_purge(llcp_sock);\n\n\tif (sk->sk_state == LLCP_CLOSED) {\n\t\trelease_sock(sk);\n\t\tnfc_llcp_sock_put(llcp_sock);\n\t}\n\n\tif (sk->sk_state == LLCP_CONNECTED) {\n\t\tnfc_put_device(local->dev);\n\t\tsk->sk_state = LLCP_CLOSED;\n\t\tsk->sk_state_change(sk);\n\t}\n\n\tnfc_llcp_send_dm(local, dsap, ssap, LLCP_DM_DISC);\n\n\trelease_sock(sk);\n\tnfc_llcp_sock_put(llcp_sock);\n}\n\nstatic void nfc_llcp_recv_cc(struct nfc_llcp_local *local, struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct sock *sk;\n\tu8 dsap, ssap;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tllcp_sock = nfc_llcp_connecting_sock_get(local, dsap);\n\tif (llcp_sock == NULL) {\n\t\tpr_err(\"Invalid CC\\n\");\n\t\tnfc_llcp_send_dm(local, dsap, ssap, LLCP_DM_NOCONN);\n\n\t\treturn;\n\t}\n\n\tsk = &llcp_sock->sk;\n\n\t/* Unlink from connecting and link to the client array */\n\tnfc_llcp_sock_unlink(&local->connecting_sockets, sk);\n\tnfc_llcp_sock_link(&local->sockets, sk);\n\tllcp_sock->dsap = ssap;\n\n\tnfc_llcp_parse_connection_tlv(llcp_sock, &skb->data[LLCP_HEADER_SIZE],\n\t\t\t\t      skb->len - LLCP_HEADER_SIZE);\n\n\tsk->sk_state = LLCP_CONNECTED;\n\tsk->sk_state_change(sk);\n\n\tnfc_llcp_sock_put(llcp_sock);\n}\n\nstatic void nfc_llcp_recv_dm(struct nfc_llcp_local *local, struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct sock *sk;\n\tu8 dsap, ssap, reason;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\treason = skb->data[2];\n\n\tpr_debug(\"%d %d reason %d\\n\", ssap, dsap, reason);\n\n\tswitch (reason) {\n\tcase LLCP_DM_NOBOUND:\n\tcase LLCP_DM_REJ:\n\t\tllcp_sock = nfc_llcp_connecting_sock_get(local, dsap);\n\t\tbreak;\n\n\tdefault:\n\t\tllcp_sock = nfc_llcp_sock_get(local, dsap, ssap);\n\t\tbreak;\n\t}\n\n\tif (llcp_sock == NULL) {\n\t\tpr_debug(\"Already closed\\n\");\n\t\treturn;\n\t}\n\n\tsk = &llcp_sock->sk;\n\n\tsk->sk_err = ENXIO;\n\tsk->sk_state = LLCP_CLOSED;\n\tsk->sk_state_change(sk);\n\n\tnfc_llcp_sock_put(llcp_sock);\n}\n\nstatic void nfc_llcp_recv_snl(struct nfc_llcp_local *local,\n\t\t\t      struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tu8 dsap, ssap, *tlv, type, length, tid, sap;\n\tu16 tlv_len, offset;\n\tchar *service_name;\n\tsize_t service_name_len;\n\tstruct nfc_llcp_sdp_tlv *sdp;\n\tHLIST_HEAD(llc_sdres_list);\n\tsize_t sdres_tlvs_len;\n\tHLIST_HEAD(nl_sdres_list);\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tpr_debug(\"%d %d\\n\", dsap, ssap);\n\n\tif (dsap != LLCP_SAP_SDP || ssap != LLCP_SAP_SDP) {\n\t\tpr_err(\"Wrong SNL SAP\\n\");\n\t\treturn;\n\t}\n\n\ttlv = &skb->data[LLCP_HEADER_SIZE];\n\ttlv_len = skb->len - LLCP_HEADER_SIZE;\n\toffset = 0;\n\tsdres_tlvs_len = 0;\n\n\twhile (offset < tlv_len) {\n\t\ttype = tlv[0];\n\t\tlength = tlv[1];\n\n\t\tswitch (type) {\n\t\tcase LLCP_TLV_SDREQ:\n\t\t\ttid = tlv[2];\n\t\t\tservice_name = (char *) &tlv[3];\n\t\t\tservice_name_len = length - 1;\n\n\t\t\tpr_debug(\"Looking for %.16s\\n\", service_name);\n\n\t\t\tif (service_name_len == strlen(\"urn:nfc:sn:sdp\") &&\n\t\t\t    !strncmp(service_name, \"urn:nfc:sn:sdp\",\n\t\t\t\t     service_name_len)) {\n\t\t\t\tsap = 1;\n\t\t\t\tgoto add_snl;\n\t\t\t}\n\n\t\t\tllcp_sock = nfc_llcp_sock_from_sn(local, service_name,\n\t\t\t\t\t\t\t  service_name_len);\n\t\t\tif (!llcp_sock) {\n\t\t\t\tsap = 0;\n\t\t\t\tgoto add_snl;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We found a socket but its ssap has not been reserved\n\t\t\t * yet. We need to assign it for good and send a reply.\n\t\t\t * The ssap will be freed when the socket is closed.\n\t\t\t */\n\t\t\tif (llcp_sock->ssap == LLCP_SDP_UNBOUND) {\n\t\t\t\tatomic_t *client_count;\n\n\t\t\t\tsap = nfc_llcp_reserve_sdp_ssap(local);\n\n\t\t\t\tpr_debug(\"Reserving %d\\n\", sap);\n\n\t\t\t\tif (sap == LLCP_SAP_MAX) {\n\t\t\t\t\tsap = 0;\n\t\t\t\t\tgoto add_snl;\n\t\t\t\t}\n\n\t\t\t\tclient_count =\n\t\t\t\t\t&local->local_sdp_cnt[sap -\n\t\t\t\t\t\t\t      LLCP_WKS_NUM_SAP];\n\n\t\t\t\tatomic_inc(client_count);\n\n\t\t\t\tllcp_sock->ssap = sap;\n\t\t\t\tllcp_sock->reserved_ssap = sap;\n\t\t\t} else {\n\t\t\t\tsap = llcp_sock->ssap;\n\t\t\t}\n\n\t\t\tpr_debug(\"%p %d\\n\", llcp_sock, sap);\n\nadd_snl:\n\t\t\tsdp = nfc_llcp_build_sdres_tlv(tid, sap);\n\t\t\tif (sdp == NULL)\n\t\t\t\tgoto exit;\n\n\t\t\tsdres_tlvs_len += sdp->tlv_len;\n\t\t\thlist_add_head(&sdp->node, &llc_sdres_list);\n\t\t\tbreak;\n\n\t\tcase LLCP_TLV_SDRES:\n\t\t\tmutex_lock(&local->sdreq_lock);\n\n\t\t\tpr_debug(\"LLCP_TLV_SDRES: searching tid %d\\n\", tlv[2]);\n\n\t\t\thlist_for_each_entry(sdp, &local->pending_sdreqs, node) {\n\t\t\t\tif (sdp->tid != tlv[2])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tsdp->sap = tlv[3];\n\n\t\t\t\tpr_debug(\"Found: uri=%s, sap=%d\\n\",\n\t\t\t\t\t sdp->uri, sdp->sap);\n\n\t\t\t\thlist_del(&sdp->node);\n\n\t\t\t\thlist_add_head(&sdp->node, &nl_sdres_list);\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmutex_unlock(&local->sdreq_lock);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"Invalid SNL tlv value 0x%x\\n\", type);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset += length + 2;\n\t\ttlv += length + 2;\n\t}\n\nexit:\n\tif (!hlist_empty(&nl_sdres_list))\n\t\tnfc_genl_llc_send_sdres(local->dev, &nl_sdres_list);\n\n\tif (!hlist_empty(&llc_sdres_list))\n\t\tnfc_llcp_send_snl_sdres(local, &llc_sdres_list, sdres_tlvs_len);\n}\n\nstatic void nfc_llcp_recv_agf(struct nfc_llcp_local *local, struct sk_buff *skb)\n{\n\tu8 ptype;\n\tu16 pdu_len;\n\tstruct sk_buff *new_skb;\n\n\tif (skb->len <= LLCP_HEADER_SIZE) {\n\t\tpr_err(\"Malformed AGF PDU\\n\");\n\t\treturn;\n\t}\n\n\tskb_pull(skb, LLCP_HEADER_SIZE);\n\n\twhile (skb->len > LLCP_AGF_PDU_HEADER_SIZE) {\n\t\tpdu_len = skb->data[0] << 8 | skb->data[1];\n\n\t\tskb_pull(skb, LLCP_AGF_PDU_HEADER_SIZE);\n\n\t\tif (pdu_len < LLCP_HEADER_SIZE || pdu_len > skb->len) {\n\t\t\tpr_err(\"Malformed AGF PDU\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tptype = nfc_llcp_ptype(skb);\n\n\t\tif (ptype == LLCP_PDU_SYMM || ptype == LLCP_PDU_AGF)\n\t\t\tgoto next;\n\n\t\tnew_skb = nfc_alloc_recv_skb(pdu_len, GFP_KERNEL);\n\t\tif (new_skb == NULL) {\n\t\t\tpr_err(\"Could not allocate PDU\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tskb_put_data(new_skb, skb->data, pdu_len);\n\n\t\tnfc_llcp_rx_skb(local, new_skb);\n\n\t\tkfree_skb(new_skb);\nnext:\n\t\tskb_pull(skb, pdu_len);\n\t}\n}\n\nstatic void nfc_llcp_rx_skb(struct nfc_llcp_local *local, struct sk_buff *skb)\n{\n\tu8 dsap, ssap, ptype;\n\n\tptype = nfc_llcp_ptype(skb);\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tpr_debug(\"ptype 0x%x dsap 0x%x ssap 0x%x\\n\", ptype, dsap, ssap);\n\n\tif (ptype != LLCP_PDU_SYMM)\n\t\tprint_hex_dump_debug(\"LLCP Rx: \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\t     skb->data, skb->len, true);\n\n\tswitch (ptype) {\n\tcase LLCP_PDU_SYMM:\n\t\tpr_debug(\"SYMM\\n\");\n\t\tbreak;\n\n\tcase LLCP_PDU_UI:\n\t\tpr_debug(\"UI\\n\");\n\t\tnfc_llcp_recv_ui(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_CONNECT:\n\t\tpr_debug(\"CONNECT\\n\");\n\t\tnfc_llcp_recv_connect(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_DISC:\n\t\tpr_debug(\"DISC\\n\");\n\t\tnfc_llcp_recv_disc(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_CC:\n\t\tpr_debug(\"CC\\n\");\n\t\tnfc_llcp_recv_cc(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_DM:\n\t\tpr_debug(\"DM\\n\");\n\t\tnfc_llcp_recv_dm(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_SNL:\n\t\tpr_debug(\"SNL\\n\");\n\t\tnfc_llcp_recv_snl(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_I:\n\tcase LLCP_PDU_RR:\n\tcase LLCP_PDU_RNR:\n\t\tpr_debug(\"I frame\\n\");\n\t\tnfc_llcp_recv_hdlc(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_AGF:\n\t\tpr_debug(\"AGF frame\\n\");\n\t\tnfc_llcp_recv_agf(local, skb);\n\t\tbreak;\n\t}\n}\n\nstatic void nfc_llcp_rx_work(struct work_struct *work)\n{\n\tstruct nfc_llcp_local *local = container_of(work, struct nfc_llcp_local,\n\t\t\t\t\t\t    rx_work);\n\tstruct sk_buff *skb;\n\n\tskb = local->rx_pending;\n\tif (skb == NULL) {\n\t\tpr_debug(\"No pending SKB\\n\");\n\t\treturn;\n\t}\n\n\t__net_timestamp(skb);\n\n\tnfc_llcp_send_to_raw_sock(local, skb, NFC_DIRECTION_RX);\n\n\tnfc_llcp_rx_skb(local, skb);\n\n\tschedule_work(&local->tx_work);\n\tkfree_skb(local->rx_pending);\n\tlocal->rx_pending = NULL;\n}\n\nstatic void __nfc_llcp_recv(struct nfc_llcp_local *local, struct sk_buff *skb)\n{\n\tlocal->rx_pending = skb;\n\tdel_timer(&local->link_timer);\n\tschedule_work(&local->rx_work);\n}\n\nvoid nfc_llcp_recv(void *data, struct sk_buff *skb, int err)\n{\n\tstruct nfc_llcp_local *local = (struct nfc_llcp_local *) data;\n\n\tpr_debug(\"Received an LLCP PDU\\n\");\n\tif (err < 0) {\n\t\tpr_err(\"err %d\\n\", err);\n\t\treturn;\n\t}\n\n\t__nfc_llcp_recv(local, skb);\n}\n\nint nfc_llcp_data_received(struct nfc_dev *dev, struct sk_buff *skb)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tkfree_skb(skb);\n\t\treturn -ENODEV;\n\t}\n\n\t__nfc_llcp_recv(local, skb);\n\n\treturn 0;\n}\n\nvoid nfc_llcp_mac_is_down(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn;\n\n\tlocal->remote_miu = LLCP_DEFAULT_MIU;\n\tlocal->remote_lto = LLCP_DEFAULT_LTO;\n\n\t/* Close and purge all existing sockets */\n\tnfc_llcp_socket_release(local, true, 0);\n}\n\nvoid nfc_llcp_mac_is_up(struct nfc_dev *dev, u32 target_idx,\n\t\t\tu8 comm_mode, u8 rf_mode)\n{\n\tstruct nfc_llcp_local *local;\n\n\tpr_debug(\"rf mode %d\\n\", rf_mode);\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn;\n\n\tlocal->target_idx = target_idx;\n\tlocal->comm_mode = comm_mode;\n\tlocal->rf_mode = rf_mode;\n\n\tif (rf_mode == NFC_RF_INITIATOR) {\n\t\tpr_debug(\"Queueing Tx work\\n\");\n\n\t\tschedule_work(&local->tx_work);\n\t} else {\n\t\tmod_timer(&local->link_timer,\n\t\t\t  jiffies + msecs_to_jiffies(local->remote_lto));\n\t}\n}\n\nint nfc_llcp_register_device(struct nfc_dev *ndev)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = kzalloc(sizeof(struct nfc_llcp_local), GFP_KERNEL);\n\tif (local == NULL)\n\t\treturn -ENOMEM;\n\n\tlocal->dev = ndev;\n\tINIT_LIST_HEAD(&local->list);\n\tkref_init(&local->ref);\n\tmutex_init(&local->sdp_lock);\n\ttimer_setup(&local->link_timer, nfc_llcp_symm_timer, 0);\n\n\tskb_queue_head_init(&local->tx_queue);\n\tINIT_WORK(&local->tx_work, nfc_llcp_tx_work);\n\n\tlocal->rx_pending = NULL;\n\tINIT_WORK(&local->rx_work, nfc_llcp_rx_work);\n\n\tINIT_WORK(&local->timeout_work, nfc_llcp_timeout_work);\n\n\trwlock_init(&local->sockets.lock);\n\trwlock_init(&local->connecting_sockets.lock);\n\trwlock_init(&local->raw_sockets.lock);\n\n\tlocal->lto = 150; /* 1500 ms */\n\tlocal->rw = LLCP_MAX_RW;\n\tlocal->miux = cpu_to_be16(LLCP_MAX_MIUX);\n\tlocal->local_wks = 0x1; /* LLC Link Management */\n\n\tnfc_llcp_build_gb(local);\n\n\tlocal->remote_miu = LLCP_DEFAULT_MIU;\n\tlocal->remote_lto = LLCP_DEFAULT_LTO;\n\n\tmutex_init(&local->sdreq_lock);\n\tINIT_HLIST_HEAD(&local->pending_sdreqs);\n\ttimer_setup(&local->sdreq_timer, nfc_llcp_sdreq_timer, 0);\n\tINIT_WORK(&local->sdreq_timeout_work, nfc_llcp_sdreq_timeout_work);\n\n\tlist_add(&local->list, &llcp_devices);\n\n\treturn 0;\n}\n\nvoid nfc_llcp_unregister_device(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local = nfc_llcp_find_local(dev);\n\n\tif (local == NULL) {\n\t\tpr_debug(\"No such device\\n\");\n\t\treturn;\n\t}\n\n\tlocal_cleanup(local);\n\n\tnfc_llcp_local_put(local);\n}\n\nint __init nfc_llcp_init(void)\n{\n\treturn nfc_llcp_sock_init();\n}\n\nvoid nfc_llcp_exit(void)\n{\n\tnfc_llcp_sock_exit();\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2011  Intel Corporation. All rights reserved.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#define pr_fmt(fmt) \"llcp: %s: \" fmt, __func__\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/nfc.h>\n\n#include <net/nfc/nfc.h>\n\n#include \"nfc.h\"\n#include \"llcp.h\"\n\nstatic u8 llcp_tlv_length[LLCP_TLV_MAX] = {\n\t0,\n\t1, /* VERSION */\n\t2, /* MIUX */\n\t2, /* WKS */\n\t1, /* LTO */\n\t1, /* RW */\n\t0, /* SN */\n\t1, /* OPT */\n\t0, /* SDREQ */\n\t2, /* SDRES */\n\n};\n\nstatic u8 llcp_tlv8(u8 *tlv, u8 type)\n{\n\tif (tlv[0] != type || tlv[1] != llcp_tlv_length[tlv[0]])\n\t\treturn 0;\n\n\treturn tlv[2];\n}\n\nstatic u16 llcp_tlv16(u8 *tlv, u8 type)\n{\n\tif (tlv[0] != type || tlv[1] != llcp_tlv_length[tlv[0]])\n\t\treturn 0;\n\n\treturn be16_to_cpu(*((__be16 *)(tlv + 2)));\n}\n\n\nstatic u8 llcp_tlv_version(u8 *tlv)\n{\n\treturn llcp_tlv8(tlv, LLCP_TLV_VERSION);\n}\n\nstatic u16 llcp_tlv_miux(u8 *tlv)\n{\n\treturn llcp_tlv16(tlv, LLCP_TLV_MIUX) & 0x7ff;\n}\n\nstatic u16 llcp_tlv_wks(u8 *tlv)\n{\n\treturn llcp_tlv16(tlv, LLCP_TLV_WKS);\n}\n\nstatic u16 llcp_tlv_lto(u8 *tlv)\n{\n\treturn llcp_tlv8(tlv, LLCP_TLV_LTO);\n}\n\nstatic u8 llcp_tlv_opt(u8 *tlv)\n{\n\treturn llcp_tlv8(tlv, LLCP_TLV_OPT);\n}\n\nstatic u8 llcp_tlv_rw(u8 *tlv)\n{\n\treturn llcp_tlv8(tlv, LLCP_TLV_RW) & 0xf;\n}\n\nu8 *nfc_llcp_build_tlv(u8 type, u8 *value, u8 value_length, u8 *tlv_length)\n{\n\tu8 *tlv, length;\n\n\tpr_debug(\"type %d\\n\", type);\n\n\tif (type >= LLCP_TLV_MAX)\n\t\treturn NULL;\n\n\tlength = llcp_tlv_length[type];\n\tif (length == 0 && value_length == 0)\n\t\treturn NULL;\n\telse if (length == 0)\n\t\tlength = value_length;\n\n\t*tlv_length = 2 + length;\n\ttlv = kzalloc(2 + length, GFP_KERNEL);\n\tif (tlv == NULL)\n\t\treturn tlv;\n\n\ttlv[0] = type;\n\ttlv[1] = length;\n\tmemcpy(tlv + 2, value, length);\n\n\treturn tlv;\n}\n\nstruct nfc_llcp_sdp_tlv *nfc_llcp_build_sdres_tlv(u8 tid, u8 sap)\n{\n\tstruct nfc_llcp_sdp_tlv *sdres;\n\tu8 value[2];\n\n\tsdres = kzalloc(sizeof(struct nfc_llcp_sdp_tlv), GFP_KERNEL);\n\tif (sdres == NULL)\n\t\treturn NULL;\n\n\tvalue[0] = tid;\n\tvalue[1] = sap;\n\n\tsdres->tlv = nfc_llcp_build_tlv(LLCP_TLV_SDRES, value, 2,\n\t\t\t\t\t&sdres->tlv_len);\n\tif (sdres->tlv == NULL) {\n\t\tkfree(sdres);\n\t\treturn NULL;\n\t}\n\n\tsdres->tid = tid;\n\tsdres->sap = sap;\n\n\tINIT_HLIST_NODE(&sdres->node);\n\n\treturn sdres;\n}\n\nstruct nfc_llcp_sdp_tlv *nfc_llcp_build_sdreq_tlv(u8 tid, char *uri,\n\t\t\t\t\t\t  size_t uri_len)\n{\n\tstruct nfc_llcp_sdp_tlv *sdreq;\n\n\tpr_debug(\"uri: %s, len: %zu\\n\", uri, uri_len);\n\n\t/* sdreq->tlv_len is u8, takes uri_len, + 3 for header, + 1 for NULL */\n\tif (WARN_ON_ONCE(uri_len > U8_MAX - 4))\n\t\treturn NULL;\n\n\tsdreq = kzalloc(sizeof(struct nfc_llcp_sdp_tlv), GFP_KERNEL);\n\tif (sdreq == NULL)\n\t\treturn NULL;\n\n\tsdreq->tlv_len = uri_len + 3;\n\n\tif (uri[uri_len - 1] == 0)\n\t\tsdreq->tlv_len--;\n\n\tsdreq->tlv = kzalloc(sdreq->tlv_len + 1, GFP_KERNEL);\n\tif (sdreq->tlv == NULL) {\n\t\tkfree(sdreq);\n\t\treturn NULL;\n\t}\n\n\tsdreq->tlv[0] = LLCP_TLV_SDREQ;\n\tsdreq->tlv[1] = sdreq->tlv_len - 2;\n\tsdreq->tlv[2] = tid;\n\n\tsdreq->tid = tid;\n\tsdreq->uri = sdreq->tlv + 3;\n\tmemcpy(sdreq->uri, uri, uri_len);\n\n\tsdreq->time = jiffies;\n\n\tINIT_HLIST_NODE(&sdreq->node);\n\n\treturn sdreq;\n}\n\nvoid nfc_llcp_free_sdp_tlv(struct nfc_llcp_sdp_tlv *sdp)\n{\n\tkfree(sdp->tlv);\n\tkfree(sdp);\n}\n\nvoid nfc_llcp_free_sdp_tlv_list(struct hlist_head *head)\n{\n\tstruct nfc_llcp_sdp_tlv *sdp;\n\tstruct hlist_node *n;\n\n\thlist_for_each_entry_safe(sdp, n, head, node) {\n\t\thlist_del(&sdp->node);\n\n\t\tnfc_llcp_free_sdp_tlv(sdp);\n\t}\n}\n\nint nfc_llcp_parse_gb_tlv(struct nfc_llcp_local *local,\n\t\t\t  u8 *tlv_array, u16 tlv_array_len)\n{\n\tu8 *tlv = tlv_array, type, length, offset = 0;\n\n\tpr_debug(\"TLV array length %d\\n\", tlv_array_len);\n\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\twhile (offset < tlv_array_len) {\n\t\ttype = tlv[0];\n\t\tlength = tlv[1];\n\n\t\tpr_debug(\"type 0x%x length %d\\n\", type, length);\n\n\t\tswitch (type) {\n\t\tcase LLCP_TLV_VERSION:\n\t\t\tlocal->remote_version = llcp_tlv_version(tlv);\n\t\t\tbreak;\n\t\tcase LLCP_TLV_MIUX:\n\t\t\tlocal->remote_miu = llcp_tlv_miux(tlv) + 128;\n\t\t\tbreak;\n\t\tcase LLCP_TLV_WKS:\n\t\t\tlocal->remote_wks = llcp_tlv_wks(tlv);\n\t\t\tbreak;\n\t\tcase LLCP_TLV_LTO:\n\t\t\tlocal->remote_lto = llcp_tlv_lto(tlv) * 10;\n\t\t\tbreak;\n\t\tcase LLCP_TLV_OPT:\n\t\t\tlocal->remote_opt = llcp_tlv_opt(tlv);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Invalid gt tlv value 0x%x\\n\", type);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset += length + 2;\n\t\ttlv += length + 2;\n\t}\n\n\tpr_debug(\"version 0x%x miu %d lto %d opt 0x%x wks 0x%x\\n\",\n\t\t local->remote_version, local->remote_miu,\n\t\t local->remote_lto, local->remote_opt,\n\t\t local->remote_wks);\n\n\treturn 0;\n}\n\nint nfc_llcp_parse_connection_tlv(struct nfc_llcp_sock *sock,\n\t\t\t\t  u8 *tlv_array, u16 tlv_array_len)\n{\n\tu8 *tlv = tlv_array, type, length, offset = 0;\n\n\tpr_debug(\"TLV array length %d\\n\", tlv_array_len);\n\n\tif (sock == NULL)\n\t\treturn -ENOTCONN;\n\n\twhile (offset < tlv_array_len) {\n\t\ttype = tlv[0];\n\t\tlength = tlv[1];\n\n\t\tpr_debug(\"type 0x%x length %d\\n\", type, length);\n\n\t\tswitch (type) {\n\t\tcase LLCP_TLV_MIUX:\n\t\t\tsock->remote_miu = llcp_tlv_miux(tlv) + 128;\n\t\t\tbreak;\n\t\tcase LLCP_TLV_RW:\n\t\t\tsock->remote_rw = llcp_tlv_rw(tlv);\n\t\t\tbreak;\n\t\tcase LLCP_TLV_SN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Invalid gt tlv value 0x%x\\n\", type);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset += length + 2;\n\t\ttlv += length + 2;\n\t}\n\n\tpr_debug(\"sock %p rw %d miu %d\\n\", sock,\n\t\t sock->remote_rw, sock->remote_miu);\n\n\treturn 0;\n}\n\nstatic struct sk_buff *llcp_add_header(struct sk_buff *pdu,\n\t\t\t\t       u8 dsap, u8 ssap, u8 ptype)\n{\n\tu8 header[2];\n\n\tpr_debug(\"ptype 0x%x dsap 0x%x ssap 0x%x\\n\", ptype, dsap, ssap);\n\n\theader[0] = (u8)((dsap << 2) | (ptype >> 2));\n\theader[1] = (u8)((ptype << 6) | ssap);\n\n\tpr_debug(\"header 0x%x 0x%x\\n\", header[0], header[1]);\n\n\tskb_put_data(pdu, header, LLCP_HEADER_SIZE);\n\n\treturn pdu;\n}\n\nstatic struct sk_buff *llcp_add_tlv(struct sk_buff *pdu, u8 *tlv,\n\t\t\t\t    u8 tlv_length)\n{\n\t/* XXX Add an skb length check */\n\n\tif (tlv == NULL)\n\t\treturn NULL;\n\n\tskb_put_data(pdu, tlv, tlv_length);\n\n\treturn pdu;\n}\n\nstatic struct sk_buff *llcp_allocate_pdu(struct nfc_llcp_sock *sock,\n\t\t\t\t\t u8 cmd, u16 size)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tif (sock->ssap == 0)\n\t\treturn NULL;\n\n\tskb = nfc_alloc_send_skb(sock->dev, &sock->sk, MSG_DONTWAIT,\n\t\t\t\t size + LLCP_HEADER_SIZE, &err);\n\tif (skb == NULL) {\n\t\tpr_err(\"Could not allocate PDU\\n\");\n\t\treturn NULL;\n\t}\n\n\tskb = llcp_add_header(skb, sock->dsap, sock->ssap, cmd);\n\n\treturn skb;\n}\n\nint nfc_llcp_send_disconnect(struct nfc_llcp_sock *sock)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\n\tpr_debug(\"Sending DISC\\n\");\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tdev = sock->dev;\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_DISC, 0);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\treturn 0;\n}\n\nint nfc_llcp_send_symm(struct nfc_dev *dev)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_llcp_local *local;\n\tu16 size = 0;\n\n\tpr_debug(\"Sending SYMM\\n\");\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tsize += LLCP_HEADER_SIZE;\n\tsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\n\tskb = llcp_add_header(skb, 0, 0, LLCP_PDU_SYMM);\n\n\t__net_timestamp(skb);\n\n\tnfc_llcp_send_to_raw_sock(local, skb, NFC_DIRECTION_TX);\n\n\treturn nfc_data_exchange(dev, local->target_idx, skb,\n\t\t\t\t nfc_llcp_recv, local);\n}\n\nint nfc_llcp_send_connect(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sk_buff *skb;\n\tu8 *service_name_tlv = NULL, service_name_tlv_length;\n\tu8 *miux_tlv = NULL, miux_tlv_length;\n\tu8 *rw_tlv = NULL, rw_tlv_length, rw;\n\tint err;\n\tu16 size = 0;\n\t__be16 miux;\n\n\tpr_debug(\"Sending CONNECT\\n\");\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tif (sock->service_name != NULL) {\n\t\tservice_name_tlv = nfc_llcp_build_tlv(LLCP_TLV_SN,\n\t\t\t\t\t\t      sock->service_name,\n\t\t\t\t\t\t      sock->service_name_len,\n\t\t\t\t\t\t      &service_name_tlv_length);\n\t\tif (!service_name_tlv) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error_tlv;\n\t\t}\n\t\tsize += service_name_tlv_length;\n\t}\n\n\t/* If the socket parameters are not set, use the local ones */\n\tmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\n\t\tlocal->miux : sock->miux;\n\trw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\n\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n\t\t\t\t      &miux_tlv_length);\n\tif (!miux_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += miux_tlv_length;\n\n\trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n\tif (!rw_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += rw_tlv_length;\n\n\tpr_debug(\"SKB size %d SN length %zu\\n\", size, sock->service_name_len);\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_CONNECT, size);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\n\tllcp_add_tlv(skb, service_name_tlv, service_name_tlv_length);\n\tllcp_add_tlv(skb, miux_tlv, miux_tlv_length);\n\tllcp_add_tlv(skb, rw_tlv, rw_tlv_length);\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\terr = 0;\n\nerror_tlv:\n\tif (err)\n\t\tpr_err(\"error %d\\n\", err);\n\n\tkfree(service_name_tlv);\n\tkfree(miux_tlv);\n\tkfree(rw_tlv);\n\n\treturn err;\n}\n\nint nfc_llcp_send_cc(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sk_buff *skb;\n\tu8 *miux_tlv = NULL, miux_tlv_length;\n\tu8 *rw_tlv = NULL, rw_tlv_length, rw;\n\tint err;\n\tu16 size = 0;\n\t__be16 miux;\n\n\tpr_debug(\"Sending CC\\n\");\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\t/* If the socket parameters are not set, use the local ones */\n\tmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\n\t\tlocal->miux : sock->miux;\n\trw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\n\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n\t\t\t\t      &miux_tlv_length);\n\tif (!miux_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += miux_tlv_length;\n\n\trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n\tif (!rw_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += rw_tlv_length;\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\n\tllcp_add_tlv(skb, miux_tlv, miux_tlv_length);\n\tllcp_add_tlv(skb, rw_tlv, rw_tlv_length);\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\terr = 0;\n\nerror_tlv:\n\tif (err)\n\t\tpr_err(\"error %d\\n\", err);\n\n\tkfree(miux_tlv);\n\tkfree(rw_tlv);\n\n\treturn err;\n}\n\nstatic struct sk_buff *nfc_llcp_allocate_snl(struct nfc_llcp_local *local,\n\t\t\t\t\t     size_t tlv_length)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_dev *dev;\n\tu16 size = 0;\n\n\tif (local == NULL)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tdev = local->dev;\n\tif (dev == NULL)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tsize += LLCP_HEADER_SIZE;\n\tsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\tsize += tlv_length;\n\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\n\tskb = llcp_add_header(skb, LLCP_SAP_SDP, LLCP_SAP_SDP, LLCP_PDU_SNL);\n\n\treturn skb;\n}\n\nint nfc_llcp_send_snl_sdres(struct nfc_llcp_local *local,\n\t\t\t    struct hlist_head *tlv_list, size_t tlvs_len)\n{\n\tstruct nfc_llcp_sdp_tlv *sdp;\n\tstruct hlist_node *n;\n\tstruct sk_buff *skb;\n\n\tskb = nfc_llcp_allocate_snl(local, tlvs_len);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\thlist_for_each_entry_safe(sdp, n, tlv_list, node) {\n\t\tskb_put_data(skb, sdp->tlv, sdp->tlv_len);\n\n\t\thlist_del(&sdp->node);\n\n\t\tnfc_llcp_free_sdp_tlv(sdp);\n\t}\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\treturn 0;\n}\n\nint nfc_llcp_send_snl_sdreq(struct nfc_llcp_local *local,\n\t\t\t    struct hlist_head *tlv_list, size_t tlvs_len)\n{\n\tstruct nfc_llcp_sdp_tlv *sdreq;\n\tstruct hlist_node *n;\n\tstruct sk_buff *skb;\n\n\tskb = nfc_llcp_allocate_snl(local, tlvs_len);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tmutex_lock(&local->sdreq_lock);\n\n\tif (hlist_empty(&local->pending_sdreqs))\n\t\tmod_timer(&local->sdreq_timer,\n\t\t\t  jiffies + msecs_to_jiffies(3 * local->remote_lto));\n\n\thlist_for_each_entry_safe(sdreq, n, tlv_list, node) {\n\t\tpr_debug(\"tid %d for %s\\n\", sdreq->tid, sdreq->uri);\n\n\t\tskb_put_data(skb, sdreq->tlv, sdreq->tlv_len);\n\n\t\thlist_del(&sdreq->node);\n\n\t\thlist_add_head(&sdreq->node, &local->pending_sdreqs);\n\t}\n\n\tmutex_unlock(&local->sdreq_lock);\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\treturn 0;\n}\n\nint nfc_llcp_send_dm(struct nfc_llcp_local *local, u8 ssap, u8 dsap, u8 reason)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_dev *dev;\n\tu16 size = 1; /* Reason code */\n\n\tpr_debug(\"Sending DM reason 0x%x\\n\", reason);\n\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tdev = local->dev;\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\tsize += LLCP_HEADER_SIZE;\n\tsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\n\tskb = llcp_add_header(skb, dsap, ssap, LLCP_PDU_DM);\n\n\tskb_put_data(skb, &reason, 1);\n\n\tskb_queue_head(&local->tx_queue, skb);\n\n\treturn 0;\n}\n\nint nfc_llcp_send_i_frame(struct nfc_llcp_sock *sock,\n\t\t\t  struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *pdu;\n\tstruct sock *sk = &sock->sk;\n\tstruct nfc_llcp_local *local;\n\tsize_t frag_len = 0, remaining_len;\n\tu8 *msg_data, *msg_ptr;\n\tu16 remote_miu;\n\n\tpr_debug(\"Send I frame len %zd\\n\", len);\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\t/* Remote is ready but has not acknowledged our frames */\n\tif((sock->remote_ready &&\n\t    skb_queue_len(&sock->tx_pending_queue) >= sock->remote_rw &&\n\t    skb_queue_len(&sock->tx_queue) >= 2 * sock->remote_rw)) {\n\t\tpr_err(\"Pending queue is full %d frames\\n\",\n\t\t       skb_queue_len(&sock->tx_pending_queue));\n\t\treturn -ENOBUFS;\n\t}\n\n\t/* Remote is not ready and we've been queueing enough frames */\n\tif ((!sock->remote_ready &&\n\t     skb_queue_len(&sock->tx_queue) >= 2 * sock->remote_rw)) {\n\t\tpr_err(\"Tx queue is full %d frames\\n\",\n\t\t       skb_queue_len(&sock->tx_queue));\n\t\treturn -ENOBUFS;\n\t}\n\n\tmsg_data = kmalloc(len, GFP_USER | __GFP_NOWARN);\n\tif (msg_data == NULL)\n\t\treturn -ENOMEM;\n\n\tif (memcpy_from_msg(msg_data, msg, len)) {\n\t\tkfree(msg_data);\n\t\treturn -EFAULT;\n\t}\n\n\tremaining_len = len;\n\tmsg_ptr = msg_data;\n\n\tdo {\n\t\tremote_miu = sock->remote_miu > LLCP_MAX_MIU ?\n\t\t\t\tLLCP_DEFAULT_MIU : sock->remote_miu;\n\n\t\tfrag_len = min_t(size_t, remote_miu, remaining_len);\n\n\t\tpr_debug(\"Fragment %zd bytes remaining %zd\",\n\t\t\t frag_len, remaining_len);\n\n\t\tpdu = llcp_allocate_pdu(sock, LLCP_PDU_I,\n\t\t\t\t\tfrag_len + LLCP_SEQUENCE_SIZE);\n\t\tif (pdu == NULL) {\n\t\t\tkfree(msg_data);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tskb_put(pdu, LLCP_SEQUENCE_SIZE);\n\n\t\tif (likely(frag_len > 0))\n\t\t\tskb_put_data(pdu, msg_ptr, frag_len);\n\n\t\tskb_queue_tail(&sock->tx_queue, pdu);\n\n\t\tlock_sock(sk);\n\n\t\tnfc_llcp_queue_i_frames(sock);\n\n\t\trelease_sock(sk);\n\n\t\tremaining_len -= frag_len;\n\t\tmsg_ptr += frag_len;\n\t} while (remaining_len > 0);\n\n\tkfree(msg_data);\n\n\treturn len;\n}\n\nint nfc_llcp_send_ui_frame(struct nfc_llcp_sock *sock, u8 ssap, u8 dsap,\n\t\t\t   struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *pdu;\n\tstruct nfc_llcp_local *local;\n\tsize_t frag_len = 0, remaining_len;\n\tu8 *msg_ptr, *msg_data;\n\tu16 remote_miu;\n\tint err;\n\n\tpr_debug(\"Send UI frame len %zd\\n\", len);\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tmsg_data = kmalloc(len, GFP_USER | __GFP_NOWARN);\n\tif (msg_data == NULL)\n\t\treturn -ENOMEM;\n\n\tif (memcpy_from_msg(msg_data, msg, len)) {\n\t\tkfree(msg_data);\n\t\treturn -EFAULT;\n\t}\n\n\tremaining_len = len;\n\tmsg_ptr = msg_data;\n\n\tdo {\n\t\tremote_miu = sock->remote_miu > LLCP_MAX_MIU ?\n\t\t\t\tlocal->remote_miu : sock->remote_miu;\n\n\t\tfrag_len = min_t(size_t, remote_miu, remaining_len);\n\n\t\tpr_debug(\"Fragment %zd bytes remaining %zd\",\n\t\t\t frag_len, remaining_len);\n\n\t\tpdu = nfc_alloc_send_skb(sock->dev, &sock->sk, 0,\n\t\t\t\t\t frag_len + LLCP_HEADER_SIZE, &err);\n\t\tif (pdu == NULL) {\n\t\t\tpr_err(\"Could not allocate PDU (error=%d)\\n\", err);\n\t\t\tlen -= remaining_len;\n\t\t\tif (len == 0)\n\t\t\t\tlen = err;\n\t\t\tbreak;\n\t\t}\n\n\t\tpdu = llcp_add_header(pdu, dsap, ssap, LLCP_PDU_UI);\n\n\t\tif (likely(frag_len > 0))\n\t\t\tskb_put_data(pdu, msg_ptr, frag_len);\n\n\t\t/* No need to check for the peer RW for UI frames */\n\t\tskb_queue_tail(&local->tx_queue, pdu);\n\n\t\tremaining_len -= frag_len;\n\t\tmsg_ptr += frag_len;\n\t} while (remaining_len > 0);\n\n\tkfree(msg_data);\n\n\treturn len;\n}\n\nint nfc_llcp_send_rr(struct nfc_llcp_sock *sock)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_llcp_local *local;\n\n\tpr_debug(\"Send rr nr %d\\n\", sock->recv_n);\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_RR, LLCP_SEQUENCE_SIZE);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tskb_put(skb, LLCP_SEQUENCE_SIZE);\n\n\tskb->data[2] = sock->recv_n;\n\n\tskb_queue_head(&local->tx_queue, skb);\n\n\treturn 0;\n}\n", "/*\n * Copyright (C) 2011  Intel Corporation. All rights reserved.\n * Copyright (C) 2014 Marvell International Ltd.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#define pr_fmt(fmt) \"llcp: %s: \" fmt, __func__\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/nfc.h>\n\n#include \"nfc.h\"\n#include \"llcp.h\"\n\nstatic u8 llcp_magic[3] = {0x46, 0x66, 0x6d};\n\nstatic LIST_HEAD(llcp_devices);\n\nstatic void nfc_llcp_rx_skb(struct nfc_llcp_local *local, struct sk_buff *skb);\n\nvoid nfc_llcp_sock_link(struct llcp_sock_list *l, struct sock *sk)\n{\n\twrite_lock(&l->lock);\n\tsk_add_node(sk, &l->head);\n\twrite_unlock(&l->lock);\n}\n\nvoid nfc_llcp_sock_unlink(struct llcp_sock_list *l, struct sock *sk)\n{\n\twrite_lock(&l->lock);\n\tsk_del_node_init(sk);\n\twrite_unlock(&l->lock);\n}\n\nvoid nfc_llcp_socket_remote_param_init(struct nfc_llcp_sock *sock)\n{\n\tsock->remote_rw = LLCP_DEFAULT_RW;\n\tsock->remote_miu = LLCP_MAX_MIU + 1;\n}\n\nstatic void nfc_llcp_socket_purge(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local = sock->local;\n\tstruct sk_buff *s, *tmp;\n\n\tpr_debug(\"%p\\n\", &sock->sk);\n\n\tskb_queue_purge(&sock->tx_queue);\n\tskb_queue_purge(&sock->tx_pending_queue);\n\n\tif (local == NULL)\n\t\treturn;\n\n\t/* Search for local pending SKBs that are related to this socket */\n\tskb_queue_walk_safe(&local->tx_queue, s, tmp) {\n\t\tif (s->sk != &sock->sk)\n\t\t\tcontinue;\n\n\t\tskb_unlink(s, &local->tx_queue);\n\t\tkfree_skb(s);\n\t}\n}\n\nstatic void nfc_llcp_socket_release(struct nfc_llcp_local *local, bool device,\n\t\t\t\t    int err)\n{\n\tstruct sock *sk;\n\tstruct hlist_node *tmp;\n\tstruct nfc_llcp_sock *llcp_sock;\n\n\tskb_queue_purge(&local->tx_queue);\n\n\twrite_lock(&local->sockets.lock);\n\n\tsk_for_each_safe(sk, tmp, &local->sockets.head) {\n\t\tllcp_sock = nfc_llcp_sock(sk);\n\n\t\tbh_lock_sock(sk);\n\n\t\tnfc_llcp_socket_purge(llcp_sock);\n\n\t\tif (sk->sk_state == LLCP_CONNECTED)\n\t\t\tnfc_put_device(llcp_sock->dev);\n\n\t\tif (sk->sk_state == LLCP_LISTEN) {\n\t\t\tstruct nfc_llcp_sock *lsk, *n;\n\t\t\tstruct sock *accept_sk;\n\n\t\t\tlist_for_each_entry_safe(lsk, n,\n\t\t\t\t\t\t &llcp_sock->accept_queue,\n\t\t\t\t\t\t accept_queue) {\n\t\t\t\taccept_sk = &lsk->sk;\n\t\t\t\tbh_lock_sock(accept_sk);\n\n\t\t\t\tnfc_llcp_accept_unlink(accept_sk);\n\n\t\t\t\tif (err)\n\t\t\t\t\taccept_sk->sk_err = err;\n\t\t\t\taccept_sk->sk_state = LLCP_CLOSED;\n\t\t\t\taccept_sk->sk_state_change(sk);\n\n\t\t\t\tbh_unlock_sock(accept_sk);\n\t\t\t}\n\t\t}\n\n\t\tif (err)\n\t\t\tsk->sk_err = err;\n\t\tsk->sk_state = LLCP_CLOSED;\n\t\tsk->sk_state_change(sk);\n\n\t\tbh_unlock_sock(sk);\n\n\t\tsk_del_node_init(sk);\n\t}\n\n\twrite_unlock(&local->sockets.lock);\n\n\t/* If we still have a device, we keep the RAW sockets alive */\n\tif (device == true)\n\t\treturn;\n\n\twrite_lock(&local->raw_sockets.lock);\n\n\tsk_for_each_safe(sk, tmp, &local->raw_sockets.head) {\n\t\tllcp_sock = nfc_llcp_sock(sk);\n\n\t\tbh_lock_sock(sk);\n\n\t\tnfc_llcp_socket_purge(llcp_sock);\n\n\t\tif (err)\n\t\t\tsk->sk_err = err;\n\t\tsk->sk_state = LLCP_CLOSED;\n\t\tsk->sk_state_change(sk);\n\n\t\tbh_unlock_sock(sk);\n\n\t\tsk_del_node_init(sk);\n\t}\n\n\twrite_unlock(&local->raw_sockets.lock);\n}\n\nstruct nfc_llcp_local *nfc_llcp_local_get(struct nfc_llcp_local *local)\n{\n\tkref_get(&local->ref);\n\n\treturn local;\n}\n\nstatic void local_cleanup(struct nfc_llcp_local *local)\n{\n\tnfc_llcp_socket_release(local, false, ENXIO);\n\tdel_timer_sync(&local->link_timer);\n\tskb_queue_purge(&local->tx_queue);\n\tcancel_work_sync(&local->tx_work);\n\tcancel_work_sync(&local->rx_work);\n\tcancel_work_sync(&local->timeout_work);\n\tkfree_skb(local->rx_pending);\n\tdel_timer_sync(&local->sdreq_timer);\n\tcancel_work_sync(&local->sdreq_timeout_work);\n\tnfc_llcp_free_sdp_tlv_list(&local->pending_sdreqs);\n}\n\nstatic void local_release(struct kref *ref)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = container_of(ref, struct nfc_llcp_local, ref);\n\n\tlist_del(&local->list);\n\tlocal_cleanup(local);\n\tkfree(local);\n}\n\nint nfc_llcp_local_put(struct nfc_llcp_local *local)\n{\n\tif (local == NULL)\n\t\treturn 0;\n\n\treturn kref_put(&local->ref, local_release);\n}\n\nstatic struct nfc_llcp_sock *nfc_llcp_sock_get(struct nfc_llcp_local *local,\n\t\t\t\t\t       u8 ssap, u8 dsap)\n{\n\tstruct sock *sk;\n\tstruct nfc_llcp_sock *llcp_sock, *tmp_sock;\n\n\tpr_debug(\"ssap dsap %d %d\\n\", ssap, dsap);\n\n\tif (ssap == 0 && dsap == 0)\n\t\treturn NULL;\n\n\tread_lock(&local->sockets.lock);\n\n\tllcp_sock = NULL;\n\n\tsk_for_each(sk, &local->sockets.head) {\n\t\ttmp_sock = nfc_llcp_sock(sk);\n\n\t\tif (tmp_sock->ssap == ssap && tmp_sock->dsap == dsap) {\n\t\t\tllcp_sock = tmp_sock;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tread_unlock(&local->sockets.lock);\n\n\tif (llcp_sock == NULL)\n\t\treturn NULL;\n\n\tsock_hold(&llcp_sock->sk);\n\n\treturn llcp_sock;\n}\n\nstatic void nfc_llcp_sock_put(struct nfc_llcp_sock *sock)\n{\n\tsock_put(&sock->sk);\n}\n\nstatic void nfc_llcp_timeout_work(struct work_struct *work)\n{\n\tstruct nfc_llcp_local *local = container_of(work, struct nfc_llcp_local,\n\t\t\t\t\t\t    timeout_work);\n\n\tnfc_dep_link_down(local->dev);\n}\n\nstatic void nfc_llcp_symm_timer(struct timer_list *t)\n{\n\tstruct nfc_llcp_local *local = from_timer(local, t, link_timer);\n\n\tpr_err(\"SYMM timeout\\n\");\n\n\tschedule_work(&local->timeout_work);\n}\n\nstatic void nfc_llcp_sdreq_timeout_work(struct work_struct *work)\n{\n\tunsigned long time;\n\tHLIST_HEAD(nl_sdres_list);\n\tstruct hlist_node *n;\n\tstruct nfc_llcp_sdp_tlv *sdp;\n\tstruct nfc_llcp_local *local = container_of(work, struct nfc_llcp_local,\n\t\t\t\t\t\t    sdreq_timeout_work);\n\n\tmutex_lock(&local->sdreq_lock);\n\n\ttime = jiffies - msecs_to_jiffies(3 * local->remote_lto);\n\n\thlist_for_each_entry_safe(sdp, n, &local->pending_sdreqs, node) {\n\t\tif (time_after(sdp->time, time))\n\t\t\tcontinue;\n\n\t\tsdp->sap = LLCP_SDP_UNBOUND;\n\n\t\thlist_del(&sdp->node);\n\n\t\thlist_add_head(&sdp->node, &nl_sdres_list);\n\t}\n\n\tif (!hlist_empty(&local->pending_sdreqs))\n\t\tmod_timer(&local->sdreq_timer,\n\t\t\t  jiffies + msecs_to_jiffies(3 * local->remote_lto));\n\n\tmutex_unlock(&local->sdreq_lock);\n\n\tif (!hlist_empty(&nl_sdres_list))\n\t\tnfc_genl_llc_send_sdres(local->dev, &nl_sdres_list);\n}\n\nstatic void nfc_llcp_sdreq_timer(struct timer_list *t)\n{\n\tstruct nfc_llcp_local *local = from_timer(local, t, sdreq_timer);\n\n\tschedule_work(&local->sdreq_timeout_work);\n}\n\nstruct nfc_llcp_local *nfc_llcp_find_local(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlist_for_each_entry(local, &llcp_devices, list)\n\t\tif (local->dev == dev)\n\t\t\treturn local;\n\n\tpr_debug(\"No device found\\n\");\n\n\treturn NULL;\n}\n\nstatic char *wks[] = {\n\tNULL,\n\tNULL, /* SDP */\n\t\"urn:nfc:sn:ip\",\n\t\"urn:nfc:sn:obex\",\n\t\"urn:nfc:sn:snep\",\n};\n\nstatic int nfc_llcp_wks_sap(char *service_name, size_t service_name_len)\n{\n\tint sap, num_wks;\n\n\tpr_debug(\"%s\\n\", service_name);\n\n\tif (service_name == NULL)\n\t\treturn -EINVAL;\n\n\tnum_wks = ARRAY_SIZE(wks);\n\n\tfor (sap = 0; sap < num_wks; sap++) {\n\t\tif (wks[sap] == NULL)\n\t\t\tcontinue;\n\n\t\tif (strncmp(wks[sap], service_name, service_name_len) == 0)\n\t\t\treturn sap;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic\nstruct nfc_llcp_sock *nfc_llcp_sock_from_sn(struct nfc_llcp_local *local,\n\t\t\t\t\t    u8 *sn, size_t sn_len)\n{\n\tstruct sock *sk;\n\tstruct nfc_llcp_sock *llcp_sock, *tmp_sock;\n\n\tpr_debug(\"sn %zd %p\\n\", sn_len, sn);\n\n\tif (sn == NULL || sn_len == 0)\n\t\treturn NULL;\n\n\tread_lock(&local->sockets.lock);\n\n\tllcp_sock = NULL;\n\n\tsk_for_each(sk, &local->sockets.head) {\n\t\ttmp_sock = nfc_llcp_sock(sk);\n\n\t\tpr_debug(\"llcp sock %p\\n\", tmp_sock);\n\n\t\tif (tmp_sock->sk.sk_type == SOCK_STREAM &&\n\t\t    tmp_sock->sk.sk_state != LLCP_LISTEN)\n\t\t\tcontinue;\n\n\t\tif (tmp_sock->sk.sk_type == SOCK_DGRAM &&\n\t\t    tmp_sock->sk.sk_state != LLCP_BOUND)\n\t\t\tcontinue;\n\n\t\tif (tmp_sock->service_name == NULL ||\n\t\t    tmp_sock->service_name_len == 0)\n\t\t\tcontinue;\n\n\t\tif (tmp_sock->service_name_len != sn_len)\n\t\t\tcontinue;\n\n\t\tif (memcmp(sn, tmp_sock->service_name, sn_len) == 0) {\n\t\t\tllcp_sock = tmp_sock;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tread_unlock(&local->sockets.lock);\n\n\tpr_debug(\"Found llcp sock %p\\n\", llcp_sock);\n\n\treturn llcp_sock;\n}\n\nu8 nfc_llcp_get_sdp_ssap(struct nfc_llcp_local *local,\n\t\t\t struct nfc_llcp_sock *sock)\n{\n\tmutex_lock(&local->sdp_lock);\n\n\tif (sock->service_name != NULL && sock->service_name_len > 0) {\n\t\tint ssap = nfc_llcp_wks_sap(sock->service_name,\n\t\t\t\t\t    sock->service_name_len);\n\n\t\tif (ssap > 0) {\n\t\t\tpr_debug(\"WKS %d\\n\", ssap);\n\n\t\t\t/* This is a WKS, let's check if it's free */\n\t\t\tif (local->local_wks & BIT(ssap)) {\n\t\t\t\tmutex_unlock(&local->sdp_lock);\n\n\t\t\t\treturn LLCP_SAP_MAX;\n\t\t\t}\n\n\t\t\tset_bit(ssap, &local->local_wks);\n\t\t\tmutex_unlock(&local->sdp_lock);\n\n\t\t\treturn ssap;\n\t\t}\n\n\t\t/*\n\t\t * Check if there already is a non WKS socket bound\n\t\t * to this service name.\n\t\t */\n\t\tif (nfc_llcp_sock_from_sn(local, sock->service_name,\n\t\t\t\t\t  sock->service_name_len) != NULL) {\n\t\t\tmutex_unlock(&local->sdp_lock);\n\n\t\t\treturn LLCP_SAP_MAX;\n\t\t}\n\n\t\tmutex_unlock(&local->sdp_lock);\n\n\t\treturn LLCP_SDP_UNBOUND;\n\n\t} else if (sock->ssap != 0 && sock->ssap < LLCP_WKS_NUM_SAP) {\n\t\tif (!test_bit(sock->ssap, &local->local_wks)) {\n\t\t\tset_bit(sock->ssap, &local->local_wks);\n\t\t\tmutex_unlock(&local->sdp_lock);\n\n\t\t\treturn sock->ssap;\n\t\t}\n\t}\n\n\tmutex_unlock(&local->sdp_lock);\n\n\treturn LLCP_SAP_MAX;\n}\n\nu8 nfc_llcp_get_local_ssap(struct nfc_llcp_local *local)\n{\n\tu8 local_ssap;\n\n\tmutex_lock(&local->sdp_lock);\n\n\tlocal_ssap = find_first_zero_bit(&local->local_sap, LLCP_LOCAL_NUM_SAP);\n\tif (local_ssap == LLCP_LOCAL_NUM_SAP) {\n\t\tmutex_unlock(&local->sdp_lock);\n\t\treturn LLCP_SAP_MAX;\n\t}\n\n\tset_bit(local_ssap, &local->local_sap);\n\n\tmutex_unlock(&local->sdp_lock);\n\n\treturn local_ssap + LLCP_LOCAL_SAP_OFFSET;\n}\n\nvoid nfc_llcp_put_ssap(struct nfc_llcp_local *local, u8 ssap)\n{\n\tu8 local_ssap;\n\tunsigned long *sdp;\n\n\tif (ssap < LLCP_WKS_NUM_SAP) {\n\t\tlocal_ssap = ssap;\n\t\tsdp = &local->local_wks;\n\t} else if (ssap < LLCP_LOCAL_NUM_SAP) {\n\t\tatomic_t *client_cnt;\n\n\t\tlocal_ssap = ssap - LLCP_WKS_NUM_SAP;\n\t\tsdp = &local->local_sdp;\n\t\tclient_cnt = &local->local_sdp_cnt[local_ssap];\n\n\t\tpr_debug(\"%d clients\\n\", atomic_read(client_cnt));\n\n\t\tmutex_lock(&local->sdp_lock);\n\n\t\tif (atomic_dec_and_test(client_cnt)) {\n\t\t\tstruct nfc_llcp_sock *l_sock;\n\n\t\t\tpr_debug(\"No more clients for SAP %d\\n\", ssap);\n\n\t\t\tclear_bit(local_ssap, sdp);\n\n\t\t\t/* Find the listening sock and set it back to UNBOUND */\n\t\t\tl_sock = nfc_llcp_sock_get(local, ssap, LLCP_SAP_SDP);\n\t\t\tif (l_sock) {\n\t\t\t\tl_sock->ssap = LLCP_SDP_UNBOUND;\n\t\t\t\tnfc_llcp_sock_put(l_sock);\n\t\t\t}\n\t\t}\n\n\t\tmutex_unlock(&local->sdp_lock);\n\n\t\treturn;\n\t} else if (ssap < LLCP_MAX_SAP) {\n\t\tlocal_ssap = ssap - LLCP_LOCAL_NUM_SAP;\n\t\tsdp = &local->local_sap;\n\t} else {\n\t\treturn;\n\t}\n\n\tmutex_lock(&local->sdp_lock);\n\n\tclear_bit(local_ssap, sdp);\n\n\tmutex_unlock(&local->sdp_lock);\n}\n\nstatic u8 nfc_llcp_reserve_sdp_ssap(struct nfc_llcp_local *local)\n{\n\tu8 ssap;\n\n\tmutex_lock(&local->sdp_lock);\n\n\tssap = find_first_zero_bit(&local->local_sdp, LLCP_SDP_NUM_SAP);\n\tif (ssap == LLCP_SDP_NUM_SAP) {\n\t\tmutex_unlock(&local->sdp_lock);\n\n\t\treturn LLCP_SAP_MAX;\n\t}\n\n\tpr_debug(\"SDP ssap %d\\n\", LLCP_WKS_NUM_SAP + ssap);\n\n\tset_bit(ssap, &local->local_sdp);\n\n\tmutex_unlock(&local->sdp_lock);\n\n\treturn LLCP_WKS_NUM_SAP + ssap;\n}\n\nstatic int nfc_llcp_build_gb(struct nfc_llcp_local *local)\n{\n\tu8 *gb_cur, version, version_length;\n\tu8 lto_length, wks_length, miux_length;\n\tu8 *version_tlv = NULL, *lto_tlv = NULL,\n\t   *wks_tlv = NULL, *miux_tlv = NULL;\n\t__be16 wks = cpu_to_be16(local->local_wks);\n\tu8 gb_len = 0;\n\tint ret = 0;\n\n\tversion = LLCP_VERSION_11;\n\tversion_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,\n\t\t\t\t\t 1, &version_length);\n\tif (!version_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgb_len += version_length;\n\n\tlto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);\n\tif (!lto_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgb_len += lto_length;\n\n\tpr_debug(\"Local wks 0x%lx\\n\", local->local_wks);\n\twks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);\n\tif (!wks_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgb_len += wks_length;\n\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,\n\t\t\t\t      &miux_length);\n\tif (!miux_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgb_len += miux_length;\n\n\tgb_len += ARRAY_SIZE(llcp_magic);\n\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tgb_cur = local->gb;\n\n\tmemcpy(gb_cur, llcp_magic, ARRAY_SIZE(llcp_magic));\n\tgb_cur += ARRAY_SIZE(llcp_magic);\n\n\tmemcpy(gb_cur, version_tlv, version_length);\n\tgb_cur += version_length;\n\n\tmemcpy(gb_cur, lto_tlv, lto_length);\n\tgb_cur += lto_length;\n\n\tmemcpy(gb_cur, wks_tlv, wks_length);\n\tgb_cur += wks_length;\n\n\tmemcpy(gb_cur, miux_tlv, miux_length);\n\tgb_cur += miux_length;\n\n\tlocal->gb_len = gb_len;\n\nout:\n\tkfree(version_tlv);\n\tkfree(lto_tlv);\n\tkfree(wks_tlv);\n\tkfree(miux_tlv);\n\n\treturn ret;\n}\n\nu8 *nfc_llcp_general_bytes(struct nfc_dev *dev, size_t *general_bytes_len)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\t*general_bytes_len = 0;\n\t\treturn NULL;\n\t}\n\n\tnfc_llcp_build_gb(local);\n\n\t*general_bytes_len = local->gb_len;\n\n\treturn local->gb;\n}\n\nint nfc_llcp_set_remote_gb(struct nfc_dev *dev, u8 *gb, u8 gb_len)\n{\n\tstruct nfc_llcp_local *local;\n\n\tif (gb_len < 3 || gb_len > NFC_MAX_GT_LEN)\n\t\treturn -EINVAL;\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tpr_err(\"No LLCP device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmemset(local->remote_gb, 0, NFC_MAX_GT_LEN);\n\tmemcpy(local->remote_gb, gb, gb_len);\n\tlocal->remote_gb_len = gb_len;\n\n\tif (memcmp(local->remote_gb, llcp_magic, 3)) {\n\t\tpr_err(\"MAC does not support LLCP\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn nfc_llcp_parse_gb_tlv(local,\n\t\t\t\t     &local->remote_gb[3],\n\t\t\t\t     local->remote_gb_len - 3);\n}\n\nstatic u8 nfc_llcp_dsap(struct sk_buff *pdu)\n{\n\treturn (pdu->data[0] & 0xfc) >> 2;\n}\n\nstatic u8 nfc_llcp_ptype(struct sk_buff *pdu)\n{\n\treturn ((pdu->data[0] & 0x03) << 2) | ((pdu->data[1] & 0xc0) >> 6);\n}\n\nstatic u8 nfc_llcp_ssap(struct sk_buff *pdu)\n{\n\treturn pdu->data[1] & 0x3f;\n}\n\nstatic u8 nfc_llcp_ns(struct sk_buff *pdu)\n{\n\treturn pdu->data[2] >> 4;\n}\n\nstatic u8 nfc_llcp_nr(struct sk_buff *pdu)\n{\n\treturn pdu->data[2] & 0xf;\n}\n\nstatic void nfc_llcp_set_nrns(struct nfc_llcp_sock *sock, struct sk_buff *pdu)\n{\n\tpdu->data[2] = (sock->send_n << 4) | (sock->recv_n);\n\tsock->send_n = (sock->send_n + 1) % 16;\n\tsock->recv_ack_n = (sock->recv_n - 1) % 16;\n}\n\nvoid nfc_llcp_send_to_raw_sock(struct nfc_llcp_local *local,\n\t\t\t       struct sk_buff *skb, u8 direction)\n{\n\tstruct sk_buff *skb_copy = NULL, *nskb;\n\tstruct sock *sk;\n\tu8 *data;\n\n\tread_lock(&local->raw_sockets.lock);\n\n\tsk_for_each(sk, &local->raw_sockets.head) {\n\t\tif (sk->sk_state != LLCP_BOUND)\n\t\t\tcontinue;\n\n\t\tif (skb_copy == NULL) {\n\t\t\tskb_copy = __pskb_copy_fclone(skb, NFC_RAW_HEADER_SIZE,\n\t\t\t\t\t\t      GFP_ATOMIC, true);\n\n\t\t\tif (skb_copy == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tdata = skb_push(skb_copy, NFC_RAW_HEADER_SIZE);\n\n\t\t\tdata[0] = local->dev ? local->dev->idx : 0xFF;\n\t\t\tdata[1] = direction & 0x01;\n\t\t\tdata[1] |= (RAW_PAYLOAD_LLCP << 1);\n\t\t}\n\n\t\tnskb = skb_clone(skb_copy, GFP_ATOMIC);\n\t\tif (!nskb)\n\t\t\tcontinue;\n\n\t\tif (sock_queue_rcv_skb(sk, nskb))\n\t\t\tkfree_skb(nskb);\n\t}\n\n\tread_unlock(&local->raw_sockets.lock);\n\n\tkfree_skb(skb_copy);\n}\n\nstatic void nfc_llcp_tx_work(struct work_struct *work)\n{\n\tstruct nfc_llcp_local *local = container_of(work, struct nfc_llcp_local,\n\t\t\t\t\t\t    tx_work);\n\tstruct sk_buff *skb;\n\tstruct sock *sk;\n\tstruct nfc_llcp_sock *llcp_sock;\n\n\tskb = skb_dequeue(&local->tx_queue);\n\tif (skb != NULL) {\n\t\tsk = skb->sk;\n\t\tllcp_sock = nfc_llcp_sock(sk);\n\n\t\tif (llcp_sock == NULL && nfc_llcp_ptype(skb) == LLCP_PDU_I) {\n\t\t\tkfree_skb(skb);\n\t\t\tnfc_llcp_send_symm(local->dev);\n\t\t} else if (llcp_sock && !llcp_sock->remote_ready) {\n\t\t\tskb_queue_head(&local->tx_queue, skb);\n\t\t\tnfc_llcp_send_symm(local->dev);\n\t\t} else {\n\t\t\tstruct sk_buff *copy_skb = NULL;\n\t\t\tu8 ptype = nfc_llcp_ptype(skb);\n\t\t\tint ret;\n\n\t\t\tpr_debug(\"Sending pending skb\\n\");\n\t\t\tprint_hex_dump_debug(\"LLCP Tx: \", DUMP_PREFIX_OFFSET,\n\t\t\t\t\t     16, 1, skb->data, skb->len, true);\n\n\t\t\tif (ptype == LLCP_PDU_DISC && sk != NULL &&\n\t\t\t    sk->sk_state == LLCP_DISCONNECTING) {\n\t\t\t\tnfc_llcp_sock_unlink(&local->sockets, sk);\n\t\t\t\tsock_orphan(sk);\n\t\t\t\tsock_put(sk);\n\t\t\t}\n\n\t\t\tif (ptype == LLCP_PDU_I)\n\t\t\t\tcopy_skb = skb_copy(skb, GFP_ATOMIC);\n\n\t\t\t__net_timestamp(skb);\n\n\t\t\tnfc_llcp_send_to_raw_sock(local, skb,\n\t\t\t\t\t\t  NFC_DIRECTION_TX);\n\n\t\t\tret = nfc_data_exchange(local->dev, local->target_idx,\n\t\t\t\t\t\tskb, nfc_llcp_recv, local);\n\n\t\t\tif (ret) {\n\t\t\t\tkfree_skb(copy_skb);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (ptype == LLCP_PDU_I && copy_skb)\n\t\t\t\tskb_queue_tail(&llcp_sock->tx_pending_queue,\n\t\t\t\t\t       copy_skb);\n\t\t}\n\t} else {\n\t\tnfc_llcp_send_symm(local->dev);\n\t}\n\nout:\n\tmod_timer(&local->link_timer,\n\t\t  jiffies + msecs_to_jiffies(2 * local->remote_lto));\n}\n\nstatic struct nfc_llcp_sock *nfc_llcp_connecting_sock_get(struct nfc_llcp_local *local,\n\t\t\t\t\t\t\t  u8 ssap)\n{\n\tstruct sock *sk;\n\tstruct nfc_llcp_sock *llcp_sock;\n\n\tread_lock(&local->connecting_sockets.lock);\n\n\tsk_for_each(sk, &local->connecting_sockets.head) {\n\t\tllcp_sock = nfc_llcp_sock(sk);\n\n\t\tif (llcp_sock->ssap == ssap) {\n\t\t\tsock_hold(&llcp_sock->sk);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tllcp_sock = NULL;\n\nout:\n\tread_unlock(&local->connecting_sockets.lock);\n\n\treturn llcp_sock;\n}\n\nstatic struct nfc_llcp_sock *nfc_llcp_sock_get_sn(struct nfc_llcp_local *local,\n\t\t\t\t\t\t  u8 *sn, size_t sn_len)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\n\tllcp_sock = nfc_llcp_sock_from_sn(local, sn, sn_len);\n\n\tif (llcp_sock == NULL)\n\t\treturn NULL;\n\n\tsock_hold(&llcp_sock->sk);\n\n\treturn llcp_sock;\n}\n\nstatic u8 *nfc_llcp_connect_sn(struct sk_buff *skb, size_t *sn_len)\n{\n\tu8 *tlv = &skb->data[2], type, length;\n\tsize_t tlv_array_len = skb->len - LLCP_HEADER_SIZE, offset = 0;\n\n\twhile (offset < tlv_array_len) {\n\t\ttype = tlv[0];\n\t\tlength = tlv[1];\n\n\t\tpr_debug(\"type 0x%x length %d\\n\", type, length);\n\n\t\tif (type == LLCP_TLV_SN) {\n\t\t\t*sn_len = length;\n\t\t\treturn &tlv[2];\n\t\t}\n\n\t\toffset += length + 2;\n\t\ttlv += length + 2;\n\t}\n\n\treturn NULL;\n}\n\nstatic void nfc_llcp_recv_ui(struct nfc_llcp_local *local,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct nfc_llcp_ui_cb *ui_cb;\n\tu8 dsap, ssap;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tui_cb = nfc_llcp_ui_skb_cb(skb);\n\tui_cb->dsap = dsap;\n\tui_cb->ssap = ssap;\n\n\tpr_debug(\"%d %d\\n\", dsap, ssap);\n\n\t/* We're looking for a bound socket, not a client one */\n\tllcp_sock = nfc_llcp_sock_get(local, dsap, LLCP_SAP_SDP);\n\tif (llcp_sock == NULL || llcp_sock->sk.sk_type != SOCK_DGRAM)\n\t\treturn;\n\n\t/* There is no sequence with UI frames */\n\tskb_pull(skb, LLCP_HEADER_SIZE);\n\tif (!sock_queue_rcv_skb(&llcp_sock->sk, skb)) {\n\t\t/*\n\t\t * UI frames will be freed from the socket layer, so we\n\t\t * need to keep them alive until someone receives them.\n\t\t */\n\t\tskb_get(skb);\n\t} else {\n\t\tpr_err(\"Receive queue is full\\n\");\n\t}\n\n\tnfc_llcp_sock_put(llcp_sock);\n}\n\nstatic void nfc_llcp_recv_connect(struct nfc_llcp_local *local,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct sock *new_sk, *parent;\n\tstruct nfc_llcp_sock *sock, *new_sock;\n\tu8 dsap, ssap, reason;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tpr_debug(\"%d %d\\n\", dsap, ssap);\n\n\tif (dsap != LLCP_SAP_SDP) {\n\t\tsock = nfc_llcp_sock_get(local, dsap, LLCP_SAP_SDP);\n\t\tif (sock == NULL || sock->sk.sk_state != LLCP_LISTEN) {\n\t\t\treason = LLCP_DM_NOBOUND;\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\tu8 *sn;\n\t\tsize_t sn_len;\n\n\t\tsn = nfc_llcp_connect_sn(skb, &sn_len);\n\t\tif (sn == NULL) {\n\t\t\treason = LLCP_DM_NOBOUND;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tpr_debug(\"Service name length %zu\\n\", sn_len);\n\n\t\tsock = nfc_llcp_sock_get_sn(local, sn, sn_len);\n\t\tif (sock == NULL) {\n\t\t\treason = LLCP_DM_NOBOUND;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tlock_sock(&sock->sk);\n\n\tparent = &sock->sk;\n\n\tif (sk_acceptq_is_full(parent)) {\n\t\treason = LLCP_DM_REJ;\n\t\trelease_sock(&sock->sk);\n\t\tsock_put(&sock->sk);\n\t\tgoto fail;\n\t}\n\n\tif (sock->ssap == LLCP_SDP_UNBOUND) {\n\t\tu8 ssap = nfc_llcp_reserve_sdp_ssap(local);\n\n\t\tpr_debug(\"First client, reserving %d\\n\", ssap);\n\n\t\tif (ssap == LLCP_SAP_MAX) {\n\t\t\treason = LLCP_DM_REJ;\n\t\t\trelease_sock(&sock->sk);\n\t\t\tsock_put(&sock->sk);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tsock->ssap = ssap;\n\t}\n\n\tnew_sk = nfc_llcp_sock_alloc(NULL, parent->sk_type, GFP_ATOMIC, 0);\n\tif (new_sk == NULL) {\n\t\treason = LLCP_DM_REJ;\n\t\trelease_sock(&sock->sk);\n\t\tsock_put(&sock->sk);\n\t\tgoto fail;\n\t}\n\n\tnew_sock = nfc_llcp_sock(new_sk);\n\tnew_sock->dev = local->dev;\n\tnew_sock->local = nfc_llcp_local_get(local);\n\tnew_sock->rw = sock->rw;\n\tnew_sock->miux = sock->miux;\n\tnew_sock->nfc_protocol = sock->nfc_protocol;\n\tnew_sock->dsap = ssap;\n\tnew_sock->target_idx = local->target_idx;\n\tnew_sock->parent = parent;\n\tnew_sock->ssap = sock->ssap;\n\tif (sock->ssap < LLCP_LOCAL_NUM_SAP && sock->ssap >= LLCP_WKS_NUM_SAP) {\n\t\tatomic_t *client_count;\n\n\t\tpr_debug(\"reserved_ssap %d for %p\\n\", sock->ssap, new_sock);\n\n\t\tclient_count =\n\t\t\t&local->local_sdp_cnt[sock->ssap - LLCP_WKS_NUM_SAP];\n\n\t\tatomic_inc(client_count);\n\t\tnew_sock->reserved_ssap = sock->ssap;\n\t}\n\n\tnfc_llcp_parse_connection_tlv(new_sock, &skb->data[LLCP_HEADER_SIZE],\n\t\t\t\t      skb->len - LLCP_HEADER_SIZE);\n\n\tpr_debug(\"new sock %p sk %p\\n\", new_sock, &new_sock->sk);\n\n\tnfc_llcp_sock_link(&local->sockets, new_sk);\n\n\tnfc_llcp_accept_enqueue(&sock->sk, new_sk);\n\n\tnfc_get_device(local->dev->idx);\n\n\tnew_sk->sk_state = LLCP_CONNECTED;\n\n\t/* Wake the listening processes */\n\tparent->sk_data_ready(parent);\n\n\t/* Send CC */\n\tnfc_llcp_send_cc(new_sock);\n\n\trelease_sock(&sock->sk);\n\tsock_put(&sock->sk);\n\n\treturn;\n\nfail:\n\t/* Send DM */\n\tnfc_llcp_send_dm(local, dsap, ssap, reason);\n}\n\nint nfc_llcp_queue_i_frames(struct nfc_llcp_sock *sock)\n{\n\tint nr_frames = 0;\n\tstruct nfc_llcp_local *local = sock->local;\n\n\tpr_debug(\"Remote ready %d tx queue len %d remote rw %d\",\n\t\t sock->remote_ready, skb_queue_len(&sock->tx_pending_queue),\n\t\t sock->remote_rw);\n\n\t/* Try to queue some I frames for transmission */\n\twhile (sock->remote_ready &&\n\t       skb_queue_len(&sock->tx_pending_queue) < sock->remote_rw) {\n\t\tstruct sk_buff *pdu;\n\n\t\tpdu = skb_dequeue(&sock->tx_queue);\n\t\tif (pdu == NULL)\n\t\t\tbreak;\n\n\t\t/* Update N(S)/N(R) */\n\t\tnfc_llcp_set_nrns(sock, pdu);\n\n\t\tskb_queue_tail(&local->tx_queue, pdu);\n\t\tnr_frames++;\n\t}\n\n\treturn nr_frames;\n}\n\nstatic void nfc_llcp_recv_hdlc(struct nfc_llcp_local *local,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct sock *sk;\n\tu8 dsap, ssap, ptype, ns, nr;\n\n\tptype = nfc_llcp_ptype(skb);\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\tns = nfc_llcp_ns(skb);\n\tnr = nfc_llcp_nr(skb);\n\n\tpr_debug(\"%d %d R %d S %d\\n\", dsap, ssap, nr, ns);\n\n\tllcp_sock = nfc_llcp_sock_get(local, dsap, ssap);\n\tif (llcp_sock == NULL) {\n\t\tnfc_llcp_send_dm(local, dsap, ssap, LLCP_DM_NOCONN);\n\t\treturn;\n\t}\n\n\tsk = &llcp_sock->sk;\n\tlock_sock(sk);\n\tif (sk->sk_state == LLCP_CLOSED) {\n\t\trelease_sock(sk);\n\t\tnfc_llcp_sock_put(llcp_sock);\n\t}\n\n\t/* Pass the payload upstream */\n\tif (ptype == LLCP_PDU_I) {\n\t\tpr_debug(\"I frame, queueing on %p\\n\", &llcp_sock->sk);\n\n\t\tif (ns == llcp_sock->recv_n)\n\t\t\tllcp_sock->recv_n = (llcp_sock->recv_n + 1) % 16;\n\t\telse\n\t\t\tpr_err(\"Received out of sequence I PDU\\n\");\n\n\t\tskb_pull(skb, LLCP_HEADER_SIZE + LLCP_SEQUENCE_SIZE);\n\t\tif (!sock_queue_rcv_skb(&llcp_sock->sk, skb)) {\n\t\t\t/*\n\t\t\t * I frames will be freed from the socket layer, so we\n\t\t\t * need to keep them alive until someone receives them.\n\t\t\t */\n\t\t\tskb_get(skb);\n\t\t} else {\n\t\t\tpr_err(\"Receive queue is full\\n\");\n\t\t}\n\t}\n\n\t/* Remove skbs from the pending queue */\n\tif (llcp_sock->send_ack_n != nr) {\n\t\tstruct sk_buff *s, *tmp;\n\t\tu8 n;\n\n\t\tllcp_sock->send_ack_n = nr;\n\n\t\t/* Remove and free all skbs until ns == nr */\n\t\tskb_queue_walk_safe(&llcp_sock->tx_pending_queue, s, tmp) {\n\t\t\tn = nfc_llcp_ns(s);\n\n\t\t\tskb_unlink(s, &llcp_sock->tx_pending_queue);\n\t\t\tkfree_skb(s);\n\n\t\t\tif (n == nr)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Re-queue the remaining skbs for transmission */\n\t\tskb_queue_reverse_walk_safe(&llcp_sock->tx_pending_queue,\n\t\t\t\t\t    s, tmp) {\n\t\t\tskb_unlink(s, &llcp_sock->tx_pending_queue);\n\t\t\tskb_queue_head(&local->tx_queue, s);\n\t\t}\n\t}\n\n\tif (ptype == LLCP_PDU_RR)\n\t\tllcp_sock->remote_ready = true;\n\telse if (ptype == LLCP_PDU_RNR)\n\t\tllcp_sock->remote_ready = false;\n\n\tif (nfc_llcp_queue_i_frames(llcp_sock) == 0 && ptype == LLCP_PDU_I)\n\t\tnfc_llcp_send_rr(llcp_sock);\n\n\trelease_sock(sk);\n\tnfc_llcp_sock_put(llcp_sock);\n}\n\nstatic void nfc_llcp_recv_disc(struct nfc_llcp_local *local,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct sock *sk;\n\tu8 dsap, ssap;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tif ((dsap == 0) && (ssap == 0)) {\n\t\tpr_debug(\"Connection termination\");\n\t\tnfc_dep_link_down(local->dev);\n\t\treturn;\n\t}\n\n\tllcp_sock = nfc_llcp_sock_get(local, dsap, ssap);\n\tif (llcp_sock == NULL) {\n\t\tnfc_llcp_send_dm(local, dsap, ssap, LLCP_DM_NOCONN);\n\t\treturn;\n\t}\n\n\tsk = &llcp_sock->sk;\n\tlock_sock(sk);\n\n\tnfc_llcp_socket_purge(llcp_sock);\n\n\tif (sk->sk_state == LLCP_CLOSED) {\n\t\trelease_sock(sk);\n\t\tnfc_llcp_sock_put(llcp_sock);\n\t}\n\n\tif (sk->sk_state == LLCP_CONNECTED) {\n\t\tnfc_put_device(local->dev);\n\t\tsk->sk_state = LLCP_CLOSED;\n\t\tsk->sk_state_change(sk);\n\t}\n\n\tnfc_llcp_send_dm(local, dsap, ssap, LLCP_DM_DISC);\n\n\trelease_sock(sk);\n\tnfc_llcp_sock_put(llcp_sock);\n}\n\nstatic void nfc_llcp_recv_cc(struct nfc_llcp_local *local, struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct sock *sk;\n\tu8 dsap, ssap;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tllcp_sock = nfc_llcp_connecting_sock_get(local, dsap);\n\tif (llcp_sock == NULL) {\n\t\tpr_err(\"Invalid CC\\n\");\n\t\tnfc_llcp_send_dm(local, dsap, ssap, LLCP_DM_NOCONN);\n\n\t\treturn;\n\t}\n\n\tsk = &llcp_sock->sk;\n\n\t/* Unlink from connecting and link to the client array */\n\tnfc_llcp_sock_unlink(&local->connecting_sockets, sk);\n\tnfc_llcp_sock_link(&local->sockets, sk);\n\tllcp_sock->dsap = ssap;\n\n\tnfc_llcp_parse_connection_tlv(llcp_sock, &skb->data[LLCP_HEADER_SIZE],\n\t\t\t\t      skb->len - LLCP_HEADER_SIZE);\n\n\tsk->sk_state = LLCP_CONNECTED;\n\tsk->sk_state_change(sk);\n\n\tnfc_llcp_sock_put(llcp_sock);\n}\n\nstatic void nfc_llcp_recv_dm(struct nfc_llcp_local *local, struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct sock *sk;\n\tu8 dsap, ssap, reason;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\treason = skb->data[2];\n\n\tpr_debug(\"%d %d reason %d\\n\", ssap, dsap, reason);\n\n\tswitch (reason) {\n\tcase LLCP_DM_NOBOUND:\n\tcase LLCP_DM_REJ:\n\t\tllcp_sock = nfc_llcp_connecting_sock_get(local, dsap);\n\t\tbreak;\n\n\tdefault:\n\t\tllcp_sock = nfc_llcp_sock_get(local, dsap, ssap);\n\t\tbreak;\n\t}\n\n\tif (llcp_sock == NULL) {\n\t\tpr_debug(\"Already closed\\n\");\n\t\treturn;\n\t}\n\n\tsk = &llcp_sock->sk;\n\n\tsk->sk_err = ENXIO;\n\tsk->sk_state = LLCP_CLOSED;\n\tsk->sk_state_change(sk);\n\n\tnfc_llcp_sock_put(llcp_sock);\n}\n\nstatic void nfc_llcp_recv_snl(struct nfc_llcp_local *local,\n\t\t\t      struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tu8 dsap, ssap, *tlv, type, length, tid, sap;\n\tu16 tlv_len, offset;\n\tchar *service_name;\n\tsize_t service_name_len;\n\tstruct nfc_llcp_sdp_tlv *sdp;\n\tHLIST_HEAD(llc_sdres_list);\n\tsize_t sdres_tlvs_len;\n\tHLIST_HEAD(nl_sdres_list);\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tpr_debug(\"%d %d\\n\", dsap, ssap);\n\n\tif (dsap != LLCP_SAP_SDP || ssap != LLCP_SAP_SDP) {\n\t\tpr_err(\"Wrong SNL SAP\\n\");\n\t\treturn;\n\t}\n\n\ttlv = &skb->data[LLCP_HEADER_SIZE];\n\ttlv_len = skb->len - LLCP_HEADER_SIZE;\n\toffset = 0;\n\tsdres_tlvs_len = 0;\n\n\twhile (offset < tlv_len) {\n\t\ttype = tlv[0];\n\t\tlength = tlv[1];\n\n\t\tswitch (type) {\n\t\tcase LLCP_TLV_SDREQ:\n\t\t\ttid = tlv[2];\n\t\t\tservice_name = (char *) &tlv[3];\n\t\t\tservice_name_len = length - 1;\n\n\t\t\tpr_debug(\"Looking for %.16s\\n\", service_name);\n\n\t\t\tif (service_name_len == strlen(\"urn:nfc:sn:sdp\") &&\n\t\t\t    !strncmp(service_name, \"urn:nfc:sn:sdp\",\n\t\t\t\t     service_name_len)) {\n\t\t\t\tsap = 1;\n\t\t\t\tgoto add_snl;\n\t\t\t}\n\n\t\t\tllcp_sock = nfc_llcp_sock_from_sn(local, service_name,\n\t\t\t\t\t\t\t  service_name_len);\n\t\t\tif (!llcp_sock) {\n\t\t\t\tsap = 0;\n\t\t\t\tgoto add_snl;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We found a socket but its ssap has not been reserved\n\t\t\t * yet. We need to assign it for good and send a reply.\n\t\t\t * The ssap will be freed when the socket is closed.\n\t\t\t */\n\t\t\tif (llcp_sock->ssap == LLCP_SDP_UNBOUND) {\n\t\t\t\tatomic_t *client_count;\n\n\t\t\t\tsap = nfc_llcp_reserve_sdp_ssap(local);\n\n\t\t\t\tpr_debug(\"Reserving %d\\n\", sap);\n\n\t\t\t\tif (sap == LLCP_SAP_MAX) {\n\t\t\t\t\tsap = 0;\n\t\t\t\t\tgoto add_snl;\n\t\t\t\t}\n\n\t\t\t\tclient_count =\n\t\t\t\t\t&local->local_sdp_cnt[sap -\n\t\t\t\t\t\t\t      LLCP_WKS_NUM_SAP];\n\n\t\t\t\tatomic_inc(client_count);\n\n\t\t\t\tllcp_sock->ssap = sap;\n\t\t\t\tllcp_sock->reserved_ssap = sap;\n\t\t\t} else {\n\t\t\t\tsap = llcp_sock->ssap;\n\t\t\t}\n\n\t\t\tpr_debug(\"%p %d\\n\", llcp_sock, sap);\n\nadd_snl:\n\t\t\tsdp = nfc_llcp_build_sdres_tlv(tid, sap);\n\t\t\tif (sdp == NULL)\n\t\t\t\tgoto exit;\n\n\t\t\tsdres_tlvs_len += sdp->tlv_len;\n\t\t\thlist_add_head(&sdp->node, &llc_sdres_list);\n\t\t\tbreak;\n\n\t\tcase LLCP_TLV_SDRES:\n\t\t\tmutex_lock(&local->sdreq_lock);\n\n\t\t\tpr_debug(\"LLCP_TLV_SDRES: searching tid %d\\n\", tlv[2]);\n\n\t\t\thlist_for_each_entry(sdp, &local->pending_sdreqs, node) {\n\t\t\t\tif (sdp->tid != tlv[2])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tsdp->sap = tlv[3];\n\n\t\t\t\tpr_debug(\"Found: uri=%s, sap=%d\\n\",\n\t\t\t\t\t sdp->uri, sdp->sap);\n\n\t\t\t\thlist_del(&sdp->node);\n\n\t\t\t\thlist_add_head(&sdp->node, &nl_sdres_list);\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmutex_unlock(&local->sdreq_lock);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"Invalid SNL tlv value 0x%x\\n\", type);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset += length + 2;\n\t\ttlv += length + 2;\n\t}\n\nexit:\n\tif (!hlist_empty(&nl_sdres_list))\n\t\tnfc_genl_llc_send_sdres(local->dev, &nl_sdres_list);\n\n\tif (!hlist_empty(&llc_sdres_list))\n\t\tnfc_llcp_send_snl_sdres(local, &llc_sdres_list, sdres_tlvs_len);\n}\n\nstatic void nfc_llcp_recv_agf(struct nfc_llcp_local *local, struct sk_buff *skb)\n{\n\tu8 ptype;\n\tu16 pdu_len;\n\tstruct sk_buff *new_skb;\n\n\tif (skb->len <= LLCP_HEADER_SIZE) {\n\t\tpr_err(\"Malformed AGF PDU\\n\");\n\t\treturn;\n\t}\n\n\tskb_pull(skb, LLCP_HEADER_SIZE);\n\n\twhile (skb->len > LLCP_AGF_PDU_HEADER_SIZE) {\n\t\tpdu_len = skb->data[0] << 8 | skb->data[1];\n\n\t\tskb_pull(skb, LLCP_AGF_PDU_HEADER_SIZE);\n\n\t\tif (pdu_len < LLCP_HEADER_SIZE || pdu_len > skb->len) {\n\t\t\tpr_err(\"Malformed AGF PDU\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tptype = nfc_llcp_ptype(skb);\n\n\t\tif (ptype == LLCP_PDU_SYMM || ptype == LLCP_PDU_AGF)\n\t\t\tgoto next;\n\n\t\tnew_skb = nfc_alloc_recv_skb(pdu_len, GFP_KERNEL);\n\t\tif (new_skb == NULL) {\n\t\t\tpr_err(\"Could not allocate PDU\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tskb_put_data(new_skb, skb->data, pdu_len);\n\n\t\tnfc_llcp_rx_skb(local, new_skb);\n\n\t\tkfree_skb(new_skb);\nnext:\n\t\tskb_pull(skb, pdu_len);\n\t}\n}\n\nstatic void nfc_llcp_rx_skb(struct nfc_llcp_local *local, struct sk_buff *skb)\n{\n\tu8 dsap, ssap, ptype;\n\n\tptype = nfc_llcp_ptype(skb);\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tpr_debug(\"ptype 0x%x dsap 0x%x ssap 0x%x\\n\", ptype, dsap, ssap);\n\n\tif (ptype != LLCP_PDU_SYMM)\n\t\tprint_hex_dump_debug(\"LLCP Rx: \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\t     skb->data, skb->len, true);\n\n\tswitch (ptype) {\n\tcase LLCP_PDU_SYMM:\n\t\tpr_debug(\"SYMM\\n\");\n\t\tbreak;\n\n\tcase LLCP_PDU_UI:\n\t\tpr_debug(\"UI\\n\");\n\t\tnfc_llcp_recv_ui(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_CONNECT:\n\t\tpr_debug(\"CONNECT\\n\");\n\t\tnfc_llcp_recv_connect(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_DISC:\n\t\tpr_debug(\"DISC\\n\");\n\t\tnfc_llcp_recv_disc(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_CC:\n\t\tpr_debug(\"CC\\n\");\n\t\tnfc_llcp_recv_cc(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_DM:\n\t\tpr_debug(\"DM\\n\");\n\t\tnfc_llcp_recv_dm(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_SNL:\n\t\tpr_debug(\"SNL\\n\");\n\t\tnfc_llcp_recv_snl(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_I:\n\tcase LLCP_PDU_RR:\n\tcase LLCP_PDU_RNR:\n\t\tpr_debug(\"I frame\\n\");\n\t\tnfc_llcp_recv_hdlc(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_AGF:\n\t\tpr_debug(\"AGF frame\\n\");\n\t\tnfc_llcp_recv_agf(local, skb);\n\t\tbreak;\n\t}\n}\n\nstatic void nfc_llcp_rx_work(struct work_struct *work)\n{\n\tstruct nfc_llcp_local *local = container_of(work, struct nfc_llcp_local,\n\t\t\t\t\t\t    rx_work);\n\tstruct sk_buff *skb;\n\n\tskb = local->rx_pending;\n\tif (skb == NULL) {\n\t\tpr_debug(\"No pending SKB\\n\");\n\t\treturn;\n\t}\n\n\t__net_timestamp(skb);\n\n\tnfc_llcp_send_to_raw_sock(local, skb, NFC_DIRECTION_RX);\n\n\tnfc_llcp_rx_skb(local, skb);\n\n\tschedule_work(&local->tx_work);\n\tkfree_skb(local->rx_pending);\n\tlocal->rx_pending = NULL;\n}\n\nstatic void __nfc_llcp_recv(struct nfc_llcp_local *local, struct sk_buff *skb)\n{\n\tlocal->rx_pending = skb;\n\tdel_timer(&local->link_timer);\n\tschedule_work(&local->rx_work);\n}\n\nvoid nfc_llcp_recv(void *data, struct sk_buff *skb, int err)\n{\n\tstruct nfc_llcp_local *local = (struct nfc_llcp_local *) data;\n\n\tpr_debug(\"Received an LLCP PDU\\n\");\n\tif (err < 0) {\n\t\tpr_err(\"err %d\\n\", err);\n\t\treturn;\n\t}\n\n\t__nfc_llcp_recv(local, skb);\n}\n\nint nfc_llcp_data_received(struct nfc_dev *dev, struct sk_buff *skb)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tkfree_skb(skb);\n\t\treturn -ENODEV;\n\t}\n\n\t__nfc_llcp_recv(local, skb);\n\n\treturn 0;\n}\n\nvoid nfc_llcp_mac_is_down(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn;\n\n\tlocal->remote_miu = LLCP_DEFAULT_MIU;\n\tlocal->remote_lto = LLCP_DEFAULT_LTO;\n\n\t/* Close and purge all existing sockets */\n\tnfc_llcp_socket_release(local, true, 0);\n}\n\nvoid nfc_llcp_mac_is_up(struct nfc_dev *dev, u32 target_idx,\n\t\t\tu8 comm_mode, u8 rf_mode)\n{\n\tstruct nfc_llcp_local *local;\n\n\tpr_debug(\"rf mode %d\\n\", rf_mode);\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn;\n\n\tlocal->target_idx = target_idx;\n\tlocal->comm_mode = comm_mode;\n\tlocal->rf_mode = rf_mode;\n\n\tif (rf_mode == NFC_RF_INITIATOR) {\n\t\tpr_debug(\"Queueing Tx work\\n\");\n\n\t\tschedule_work(&local->tx_work);\n\t} else {\n\t\tmod_timer(&local->link_timer,\n\t\t\t  jiffies + msecs_to_jiffies(local->remote_lto));\n\t}\n}\n\nint nfc_llcp_register_device(struct nfc_dev *ndev)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = kzalloc(sizeof(struct nfc_llcp_local), GFP_KERNEL);\n\tif (local == NULL)\n\t\treturn -ENOMEM;\n\n\tlocal->dev = ndev;\n\tINIT_LIST_HEAD(&local->list);\n\tkref_init(&local->ref);\n\tmutex_init(&local->sdp_lock);\n\ttimer_setup(&local->link_timer, nfc_llcp_symm_timer, 0);\n\n\tskb_queue_head_init(&local->tx_queue);\n\tINIT_WORK(&local->tx_work, nfc_llcp_tx_work);\n\n\tlocal->rx_pending = NULL;\n\tINIT_WORK(&local->rx_work, nfc_llcp_rx_work);\n\n\tINIT_WORK(&local->timeout_work, nfc_llcp_timeout_work);\n\n\trwlock_init(&local->sockets.lock);\n\trwlock_init(&local->connecting_sockets.lock);\n\trwlock_init(&local->raw_sockets.lock);\n\n\tlocal->lto = 150; /* 1500 ms */\n\tlocal->rw = LLCP_MAX_RW;\n\tlocal->miux = cpu_to_be16(LLCP_MAX_MIUX);\n\tlocal->local_wks = 0x1; /* LLC Link Management */\n\n\tnfc_llcp_build_gb(local);\n\n\tlocal->remote_miu = LLCP_DEFAULT_MIU;\n\tlocal->remote_lto = LLCP_DEFAULT_LTO;\n\n\tmutex_init(&local->sdreq_lock);\n\tINIT_HLIST_HEAD(&local->pending_sdreqs);\n\ttimer_setup(&local->sdreq_timer, nfc_llcp_sdreq_timer, 0);\n\tINIT_WORK(&local->sdreq_timeout_work, nfc_llcp_sdreq_timeout_work);\n\n\tlist_add(&local->list, &llcp_devices);\n\n\treturn 0;\n}\n\nvoid nfc_llcp_unregister_device(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local = nfc_llcp_find_local(dev);\n\n\tif (local == NULL) {\n\t\tpr_debug(\"No such device\\n\");\n\t\treturn;\n\t}\n\n\tlocal_cleanup(local);\n\n\tnfc_llcp_local_put(local);\n}\n\nint __init nfc_llcp_init(void)\n{\n\treturn nfc_llcp_sock_init();\n}\n\nvoid nfc_llcp_exit(void)\n{\n\tnfc_llcp_sock_exit();\n}\n"], "filenames": ["net/nfc/llcp_commands.c", "net/nfc/llcp_core.c"], "buggy_code_start_loc": [421, 535], "buggy_code_end_loc": [489, 556], "fixing_code_start_loc": [422, 535], "fixing_code_end_loc": [510, 573], "type": "CWE-476", "message": "An issue was discovered in the Linux kernel before 4.20.15. The nfc_llcp_build_tlv function in net/nfc/llcp_commands.c may return NULL. If the caller does not check for this, it will trigger a NULL pointer dereference. This will cause denial of service. This affects nfc_llcp_build_gb in net/nfc/llcp_core.c.", "other": {"cve": {"id": "CVE-2019-12818", "sourceIdentifier": "cve@mitre.org", "published": "2019-06-14T02:29:00.253", "lastModified": "2019-06-18T15:15:12.373", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel before 4.20.15. The nfc_llcp_build_tlv function in net/nfc/llcp_commands.c may return NULL. If the caller does not check for this, it will trigger a NULL pointer dereference. This will cause denial of service. This affects nfc_llcp_build_gb in net/nfc/llcp_core.c."}, {"lang": "es", "value": "Fue encontrado un problema en el kernel de Linux anterior a versi\u00f3n 4.20.15. La funci\u00f3n nfc_llcp_build_tlv en el archivo net/nfc/llcp_commands.c puede devolver NULL. Si la persona que llama no comprueba esto, se desencadenar\u00e1 una desreferencia de puntero NULL. Esto causar\u00e1 la denegaci\u00f3n de servicio. Esto afecta a la funci\u00f3n nfc_llcp_build_gb en el archivo net/nfc/llcp_core.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.20.15", "matchCriteriaId": "17FD7E7A-B760-45E7-8E36-87FD598DFD43"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-06/msg00039.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-06/msg00040.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-06/msg00048.html", "source": "cve@mitre.org"}, {"url": "http://packetstormsecurity.com/files/154245/Kernel-Live-Patch-Security-Notice-LSN-0054-1.html", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/108776", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=58bdd544e2933a21a51eecf17c3f5f94038261b5", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/58bdd544e2933a21a51eecf17c3f5f94038261b5", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20190710-0002/", "source": "cve@mitre.org"}, {"url": "https://support.f5.com/csp/article/K91444306", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4094-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4118-1/", "source": "cve@mitre.org"}, {"url": "https://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.20.15", "source": "cve@mitre.org", "tags": ["Mailing List", "Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/58bdd544e2933a21a51eecf17c3f5f94038261b5"}}