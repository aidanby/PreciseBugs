{"buggy_code": ["/*\n *  linux/fs/ioctl.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n#include <linux/syscalls.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/falloc.h>\n#include \"internal.h\"\n\n#include <asm/ioctls.h>\n\n/* So that the fiemap access checks can't overflow on 32 bit machines. */\n#define FIEMAP_MAX_EXTENTS\t(UINT_MAX / sizeof(struct fiemap_extent))\n\n/**\n * vfs_ioctl - call filesystem specific ioctl methods\n * @filp:\topen file to invoke ioctl method on\n * @cmd:\tioctl command to execute\n * @arg:\tcommand-specific argument for ioctl\n *\n * Invokes filesystem specific ->unlocked_ioctl, if one exists; otherwise\n * returns -ENOTTY.\n *\n * Returns 0 on success, -errno on error.\n */\nlong vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tint error = -ENOTTY;\n\n\tif (!filp->f_op->unlocked_ioctl)\n\t\tgoto out;\n\n\terror = filp->f_op->unlocked_ioctl(filp, cmd, arg);\n\tif (error == -ENOIOCTLCMD)\n\t\terror = -ENOTTY;\n out:\n\treturn error;\n}\n\nstatic int ioctl_fibmap(struct file *filp, int __user *p)\n{\n\tstruct address_space *mapping = filp->f_mapping;\n\tint res, block;\n\n\t/* do we support this mess? */\n\tif (!mapping->a_ops->bmap)\n\t\treturn -EINVAL;\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\tres = get_user(block, p);\n\tif (res)\n\t\treturn res;\n\tres = mapping->a_ops->bmap(mapping, block);\n\treturn put_user(res, p);\n}\n\n/**\n * fiemap_fill_next_extent - Fiemap helper function\n * @fieinfo:\tFiemap context passed into ->fiemap\n * @logical:\tExtent logical start offset, in bytes\n * @phys:\tExtent physical start offset, in bytes\n * @len:\tExtent length, in bytes\n * @flags:\tFIEMAP_EXTENT flags that describe this extent\n *\n * Called from file system ->fiemap callback. Will populate extent\n * info as passed in via arguments and copy to user memory. On\n * success, extent count on fieinfo is incremented.\n *\n * Returns 0 on success, -errno on error, 1 if this was the last\n * extent that will fit in user array.\n */\n#define SET_UNKNOWN_FLAGS\t(FIEMAP_EXTENT_DELALLOC)\n#define SET_NO_UNMOUNTED_IO_FLAGS\t(FIEMAP_EXTENT_DATA_ENCRYPTED)\n#define SET_NOT_ALIGNED_FLAGS\t(FIEMAP_EXTENT_DATA_TAIL|FIEMAP_EXTENT_DATA_INLINE)\nint fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical,\n\t\t\t    u64 phys, u64 len, u32 flags)\n{\n\tstruct fiemap_extent extent;\n\tstruct fiemap_extent __user *dest = fieinfo->fi_extents_start;\n\n\t/* only count the extents */\n\tif (fieinfo->fi_extents_max == 0) {\n\t\tfieinfo->fi_extents_mapped++;\n\t\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n\t}\n\n\tif (fieinfo->fi_extents_mapped >= fieinfo->fi_extents_max)\n\t\treturn 1;\n\n\tif (flags & SET_UNKNOWN_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_UNKNOWN;\n\tif (flags & SET_NO_UNMOUNTED_IO_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\tif (flags & SET_NOT_ALIGNED_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_NOT_ALIGNED;\n\n\tmemset(&extent, 0, sizeof(extent));\n\textent.fe_logical = logical;\n\textent.fe_physical = phys;\n\textent.fe_length = len;\n\textent.fe_flags = flags;\n\n\tdest += fieinfo->fi_extents_mapped;\n\tif (copy_to_user(dest, &extent, sizeof(extent)))\n\t\treturn -EFAULT;\n\n\tfieinfo->fi_extents_mapped++;\n\tif (fieinfo->fi_extents_mapped == fieinfo->fi_extents_max)\n\t\treturn 1;\n\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n}\nEXPORT_SYMBOL(fiemap_fill_next_extent);\n\n/**\n * fiemap_check_flags - check validity of requested flags for fiemap\n * @fieinfo:\tFiemap context passed into ->fiemap\n * @fs_flags:\tSet of fiemap flags that the file system understands\n *\n * Called from file system ->fiemap callback. This will compute the\n * intersection of valid fiemap flags and those that the fs supports. That\n * value is then compared against the user supplied flags. In case of bad user\n * flags, the invalid values will be written into the fieinfo structure, and\n * -EBADR is returned, which tells ioctl_fiemap() to return those values to\n * userspace. For this reason, a return code of -EBADR should be preserved.\n *\n * Returns 0 on success, -EBADR on bad flags.\n */\nint fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags)\n{\n\tu32 incompat_flags;\n\n\tincompat_flags = fieinfo->fi_flags & ~(FIEMAP_FLAGS_COMPAT & fs_flags);\n\tif (incompat_flags) {\n\t\tfieinfo->fi_flags = incompat_flags;\n\t\treturn -EBADR;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(fiemap_check_flags);\n\nstatic int fiemap_check_ranges(struct super_block *sb,\n\t\t\t       u64 start, u64 len, u64 *new_len)\n{\n\tu64 maxbytes = (u64) sb->s_maxbytes;\n\n\t*new_len = len;\n\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\tif (start > maxbytes)\n\t\treturn -EFBIG;\n\n\t/*\n\t * Shrink request scope to what the fs can actually handle.\n\t */\n\tif (len > maxbytes || (maxbytes - len) < start)\n\t\t*new_len = maxbytes - start;\n\n\treturn 0;\n}\n\nstatic int ioctl_fiemap(struct file *filp, unsigned long arg)\n{\n\tstruct fiemap fiemap;\n\tstruct fiemap __user *ufiemap = (struct fiemap __user *) arg;\n\tstruct fiemap_extent_info fieinfo = { 0, };\n\tstruct inode *inode = file_inode(filp);\n\tstruct super_block *sb = inode->i_sb;\n\tu64 len;\n\tint error;\n\n\tif (!inode->i_op->fiemap)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&fiemap, ufiemap, sizeof(fiemap)))\n\t\treturn -EFAULT;\n\n\tif (fiemap.fm_extent_count > FIEMAP_MAX_EXTENTS)\n\t\treturn -EINVAL;\n\n\terror = fiemap_check_ranges(sb, fiemap.fm_start, fiemap.fm_length,\n\t\t\t\t    &len);\n\tif (error)\n\t\treturn error;\n\n\tfieinfo.fi_flags = fiemap.fm_flags;\n\tfieinfo.fi_extents_max = fiemap.fm_extent_count;\n\tfieinfo.fi_extents_start = ufiemap->fm_extents;\n\n\tif (fiemap.fm_extent_count != 0 &&\n\t    !access_ok(VERIFY_WRITE, fieinfo.fi_extents_start,\n\t\t       fieinfo.fi_extents_max * sizeof(struct fiemap_extent)))\n\t\treturn -EFAULT;\n\n\tif (fieinfo.fi_flags & FIEMAP_FLAG_SYNC)\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\n\terror = inode->i_op->fiemap(inode, &fieinfo, fiemap.fm_start, len);\n\tfiemap.fm_flags = fieinfo.fi_flags;\n\tfiemap.fm_mapped_extents = fieinfo.fi_extents_mapped;\n\tif (copy_to_user(ufiemap, &fiemap, sizeof(fiemap)))\n\t\terror = -EFAULT;\n\n\treturn error;\n}\n\nstatic long ioctl_file_clone(struct file *dst_file, unsigned long srcfd,\n\t\t\t     u64 off, u64 olen, u64 destoff)\n{\n\tstruct fd src_file = fdget(srcfd);\n\tint ret;\n\n\tif (!src_file.file)\n\t\treturn -EBADF;\n\tret = vfs_clone_file_range(src_file.file, off, dst_file, destoff, olen);\n\tfdput(src_file);\n\treturn ret;\n}\n\nstatic long ioctl_file_clone_range(struct file *file, void __user *argp)\n{\n\tstruct file_clone_range args;\n\n\tif (copy_from_user(&args, argp, sizeof(args)))\n\t\treturn -EFAULT;\n\treturn ioctl_file_clone(file, args.src_fd, args.src_offset,\n\t\t\t\targs.src_length, args.dest_offset);\n}\n\n#ifdef CONFIG_BLOCK\n\nstatic inline sector_t logical_to_blk(struct inode *inode, loff_t offset)\n{\n\treturn (offset >> inode->i_blkbits);\n}\n\nstatic inline loff_t blk_to_logical(struct inode *inode, sector_t blk)\n{\n\treturn (blk << inode->i_blkbits);\n}\n\n/**\n * __generic_block_fiemap - FIEMAP for block based inodes (no locking)\n * @inode: the inode to map\n * @fieinfo: the fiemap info struct that will be passed back to userspace\n * @start: where to start mapping in the inode\n * @len: how much space to map\n * @get_block: the fs's get_block function\n *\n * This does FIEMAP for block based inodes.  Basically it will just loop\n * through get_block until we hit the number of extents we want to map, or we\n * go past the end of the file and hit a hole.\n *\n * If it is possible to have data blocks beyond a hole past @inode->i_size, then\n * please do not use this function, it will stop at the first unmapped block\n * beyond i_size.\n *\n * If you use this function directly, you need to do your own locking. Use\n * generic_block_fiemap if you want the locking done for you.\n */\n\nint __generic_block_fiemap(struct inode *inode,\n\t\t\t   struct fiemap_extent_info *fieinfo, loff_t start,\n\t\t\t   loff_t len, get_block_t *get_block)\n{\n\tstruct buffer_head map_bh;\n\tsector_t start_blk, last_blk;\n\tloff_t isize = i_size_read(inode);\n\tu64 logical = 0, phys = 0, size = 0;\n\tu32 flags = FIEMAP_EXTENT_MERGED;\n\tbool past_eof = false, whole_file = false;\n\tint ret = 0;\n\n\tret = fiemap_check_flags(fieinfo, FIEMAP_FLAG_SYNC);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Either the i_mutex or other appropriate locking needs to be held\n\t * since we expect isize to not change at all through the duration of\n\t * this call.\n\t */\n\tif (len >= isize) {\n\t\twhole_file = true;\n\t\tlen = isize;\n\t}\n\n\t/*\n\t * Some filesystems can't deal with being asked to map less than\n\t * blocksize, so make sure our len is at least block length.\n\t */\n\tif (logical_to_blk(inode, len) == 0)\n\t\tlen = blk_to_logical(inode, 1);\n\n\tstart_blk = logical_to_blk(inode, start);\n\tlast_blk = logical_to_blk(inode, start + len - 1);\n\n\tdo {\n\t\t/*\n\t\t * we set b_size to the total size we want so it will map as\n\t\t * many contiguous blocks as possible at once\n\t\t */\n\t\tmemset(&map_bh, 0, sizeof(struct buffer_head));\n\t\tmap_bh.b_size = len;\n\n\t\tret = get_block(inode, start_blk, &map_bh, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t/* HOLE */\n\t\tif (!buffer_mapped(&map_bh)) {\n\t\t\tstart_blk++;\n\n\t\t\t/*\n\t\t\t * We want to handle the case where there is an\n\t\t\t * allocated block at the front of the file, and then\n\t\t\t * nothing but holes up to the end of the file properly,\n\t\t\t * to make sure that extent at the front gets properly\n\t\t\t * marked with FIEMAP_EXTENT_LAST\n\t\t\t */\n\t\t\tif (!past_eof &&\n\t\t\t    blk_to_logical(inode, start_blk) >= isize)\n\t\t\t\tpast_eof = 1;\n\n\t\t\t/*\n\t\t\t * First hole after going past the EOF, this is our\n\t\t\t * last extent\n\t\t\t */\n\t\t\tif (past_eof && size) {\n\t\t\t\tflags = FIEMAP_EXTENT_MERGED|FIEMAP_EXTENT_LAST;\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size,\n\t\t\t\t\t\t\t      flags);\n\t\t\t} else if (size) {\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size, flags);\n\t\t\t\tsize = 0;\n\t\t\t}\n\n\t\t\t/* if we have holes up to/past EOF then we're done */\n\t\t\tif (start_blk > last_blk || past_eof || ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We have gone over the length of what we wanted to\n\t\t\t * map, and it wasn't the entire file, so add the extent\n\t\t\t * we got last time and exit.\n\t\t\t *\n\t\t\t * This is for the case where say we want to map all the\n\t\t\t * way up to the second to the last block in a file, but\n\t\t\t * the last block is a hole, making the second to last\n\t\t\t * block FIEMAP_EXTENT_LAST.  In this case we want to\n\t\t\t * see if there is a hole after the second to last block\n\t\t\t * so we can mark it properly.  If we found data after\n\t\t\t * we exceeded the length we were requesting, then we\n\t\t\t * are good to go, just add the extent to the fieinfo\n\t\t\t * and break\n\t\t\t */\n\t\t\tif (start_blk > last_blk && !whole_file) {\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size,\n\t\t\t\t\t\t\t      flags);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if size != 0 then we know we already have an extent\n\t\t\t * to add, so add it.\n\t\t\t */\n\t\t\tif (size) {\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size,\n\t\t\t\t\t\t\t      flags);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlogical = blk_to_logical(inode, start_blk);\n\t\t\tphys = blk_to_logical(inode, map_bh.b_blocknr);\n\t\t\tsize = map_bh.b_size;\n\t\t\tflags = FIEMAP_EXTENT_MERGED;\n\n\t\t\tstart_blk += logical_to_blk(inode, size);\n\n\t\t\t/*\n\t\t\t * If we are past the EOF, then we need to make sure as\n\t\t\t * soon as we find a hole that the last extent we found\n\t\t\t * is marked with FIEMAP_EXTENT_LAST\n\t\t\t */\n\t\t\tif (!past_eof && logical + size >= isize)\n\t\t\t\tpast_eof = true;\n\t\t}\n\t\tcond_resched();\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t} while (1);\n\n\t/* If ret is 1 then we just hit the end of the extent array */\n\tif (ret == 1)\n\t\tret = 0;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(__generic_block_fiemap);\n\n/**\n * generic_block_fiemap - FIEMAP for block based inodes\n * @inode: The inode to map\n * @fieinfo: The mapping information\n * @start: The initial block to map\n * @len: The length of the extect to attempt to map\n * @get_block: The block mapping function for the fs\n *\n * Calls __generic_block_fiemap to map the inode, after taking\n * the inode's mutex lock.\n */\n\nint generic_block_fiemap(struct inode *inode,\n\t\t\t struct fiemap_extent_info *fieinfo, u64 start,\n\t\t\t u64 len, get_block_t *get_block)\n{\n\tint ret;\n\tinode_lock(inode);\n\tret = __generic_block_fiemap(inode, fieinfo, start, len, get_block);\n\tinode_unlock(inode);\n\treturn ret;\n}\nEXPORT_SYMBOL(generic_block_fiemap);\n\n#endif  /*  CONFIG_BLOCK  */\n\n/*\n * This provides compatibility with legacy XFS pre-allocation ioctls\n * which predate the fallocate syscall.\n *\n * Only the l_start, l_len and l_whence fields of the 'struct space_resv'\n * are used here, rest are ignored.\n */\nint ioctl_preallocate(struct file *filp, void __user *argp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct space_resv sr;\n\n\tif (copy_from_user(&sr, argp, sizeof(sr)))\n\t\treturn -EFAULT;\n\n\tswitch (sr.l_whence) {\n\tcase SEEK_SET:\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tsr.l_start += filp->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tsr.l_start += i_size_read(inode);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn vfs_fallocate(filp, FALLOC_FL_KEEP_SIZE, sr.l_start, sr.l_len);\n}\n\nstatic int file_ioctl(struct file *filp, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint __user *p = (int __user *)arg;\n\n\tswitch (cmd) {\n\tcase FIBMAP:\n\t\treturn ioctl_fibmap(filp, p);\n\tcase FIONREAD:\n\t\treturn put_user(i_size_read(inode) - filp->f_pos, p);\n\tcase FS_IOC_RESVSP:\n\tcase FS_IOC_RESVSP64:\n\t\treturn ioctl_preallocate(filp, p);\n\t}\n\n\treturn vfs_ioctl(filp, cmd, arg);\n}\n\nstatic int ioctl_fionbio(struct file *filp, int __user *argp)\n{\n\tunsigned int flag;\n\tint on, error;\n\n\terror = get_user(on, argp);\n\tif (error)\n\t\treturn error;\n\tflag = O_NONBLOCK;\n#ifdef __sparc__\n\t/* SunOS compatibility item. */\n\tif (O_NONBLOCK != O_NDELAY)\n\t\tflag |= O_NDELAY;\n#endif\n\tspin_lock(&filp->f_lock);\n\tif (on)\n\t\tfilp->f_flags |= flag;\n\telse\n\t\tfilp->f_flags &= ~flag;\n\tspin_unlock(&filp->f_lock);\n\treturn error;\n}\n\nstatic int ioctl_fioasync(unsigned int fd, struct file *filp,\n\t\t\t  int __user *argp)\n{\n\tunsigned int flag;\n\tint on, error;\n\n\terror = get_user(on, argp);\n\tif (error)\n\t\treturn error;\n\tflag = on ? FASYNC : 0;\n\n\t/* Did FASYNC state change ? */\n\tif ((flag ^ filp->f_flags) & FASYNC) {\n\t\tif (filp->f_op->fasync)\n\t\t\t/* fasync() adjusts filp->f_flags */\n\t\t\terror = filp->f_op->fasync(fd, filp, on);\n\t\telse\n\t\t\terror = -ENOTTY;\n\t}\n\treturn error < 0 ? error : 0;\n}\n\nstatic int ioctl_fsfreeze(struct file *filp)\n{\n\tstruct super_block *sb = file_inode(filp)->i_sb;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* If filesystem doesn't support freeze feature, return. */\n\tif (sb->s_op->freeze_fs == NULL && sb->s_op->freeze_super == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Freeze */\n\tif (sb->s_op->freeze_super)\n\t\treturn sb->s_op->freeze_super(sb);\n\treturn freeze_super(sb);\n}\n\nstatic int ioctl_fsthaw(struct file *filp)\n{\n\tstruct super_block *sb = file_inode(filp)->i_sb;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* Thaw */\n\tif (sb->s_op->thaw_super)\n\t\treturn sb->s_op->thaw_super(sb);\n\treturn thaw_super(sb);\n}\n\nstatic long ioctl_file_dedupe_range(struct file *file, void __user *arg)\n{\n\tstruct file_dedupe_range __user *argp = arg;\n\tstruct file_dedupe_range *same = NULL;\n\tint ret;\n\tunsigned long size;\n\tu16 count;\n\n\tif (get_user(count, &argp->dest_count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tsize = offsetof(struct file_dedupe_range __user, info[count]);\n\n\tsame = memdup_user(argp, size);\n\tif (IS_ERR(same)) {\n\t\tret = PTR_ERR(same);\n\t\tsame = NULL;\n\t\tgoto out;\n\t}\n\n\tret = vfs_dedupe_file_range(file, same);\n\tif (ret)\n\t\tgoto out;\n\n\tret = copy_to_user(argp, same, size);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tkfree(same);\n\treturn ret;\n}\n\n/*\n * When you add any new common ioctls to the switches above and below\n * please update compat_sys_ioctl() too.\n *\n * do_vfs_ioctl() is not for drivers and not intended to be EXPORT_SYMBOL()'d.\n * It's just a simple helper for sys_ioctl and compat_sys_ioctl.\n */\nint do_vfs_ioctl(struct file *filp, unsigned int fd, unsigned int cmd,\n\t     unsigned long arg)\n{\n\tint error = 0;\n\tint __user *argp = (int __user *)arg;\n\tstruct inode *inode = file_inode(filp);\n\n\tswitch (cmd) {\n\tcase FIOCLEX:\n\t\tset_close_on_exec(fd, 1);\n\t\tbreak;\n\n\tcase FIONCLEX:\n\t\tset_close_on_exec(fd, 0);\n\t\tbreak;\n\n\tcase FIONBIO:\n\t\terror = ioctl_fionbio(filp, argp);\n\t\tbreak;\n\n\tcase FIOASYNC:\n\t\terror = ioctl_fioasync(fd, filp, argp);\n\t\tbreak;\n\n\tcase FIOQSIZE:\n\t\tif (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode) ||\n\t\t    S_ISLNK(inode->i_mode)) {\n\t\t\tloff_t res = inode_get_bytes(inode);\n\t\t\terror = copy_to_user(argp, &res, sizeof(res)) ?\n\t\t\t\t\t-EFAULT : 0;\n\t\t} else\n\t\t\terror = -ENOTTY;\n\t\tbreak;\n\n\tcase FIFREEZE:\n\t\terror = ioctl_fsfreeze(filp);\n\t\tbreak;\n\n\tcase FITHAW:\n\t\terror = ioctl_fsthaw(filp);\n\t\tbreak;\n\n\tcase FS_IOC_FIEMAP:\n\t\treturn ioctl_fiemap(filp, arg);\n\n\tcase FIGETBSZ:\n\t\treturn put_user(inode->i_sb->s_blocksize, argp);\n\n\tcase FICLONE:\n\t\treturn ioctl_file_clone(filp, arg, 0, 0, 0);\n\n\tcase FICLONERANGE:\n\t\treturn ioctl_file_clone_range(filp, argp);\n\n\tcase FIDEDUPERANGE:\n\t\treturn ioctl_file_dedupe_range(filp, argp);\n\n\tdefault:\n\t\tif (S_ISREG(inode->i_mode))\n\t\t\terror = file_ioctl(filp, cmd, arg);\n\t\telse\n\t\t\terror = vfs_ioctl(filp, cmd, arg);\n\t\tbreak;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)\n{\n\tint error;\n\tstruct fd f = fdget(fd);\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\terror = security_file_ioctl(f.file, cmd, arg);\n\tif (!error)\n\t\terror = do_vfs_ioctl(f.file, fd, cmd, arg);\n\tfdput(f);\n\treturn error;\n}\n"], "fixing_code": ["/*\n *  linux/fs/ioctl.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n#include <linux/syscalls.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/falloc.h>\n#include \"internal.h\"\n\n#include <asm/ioctls.h>\n\n/* So that the fiemap access checks can't overflow on 32 bit machines. */\n#define FIEMAP_MAX_EXTENTS\t(UINT_MAX / sizeof(struct fiemap_extent))\n\n/**\n * vfs_ioctl - call filesystem specific ioctl methods\n * @filp:\topen file to invoke ioctl method on\n * @cmd:\tioctl command to execute\n * @arg:\tcommand-specific argument for ioctl\n *\n * Invokes filesystem specific ->unlocked_ioctl, if one exists; otherwise\n * returns -ENOTTY.\n *\n * Returns 0 on success, -errno on error.\n */\nlong vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tint error = -ENOTTY;\n\n\tif (!filp->f_op->unlocked_ioctl)\n\t\tgoto out;\n\n\terror = filp->f_op->unlocked_ioctl(filp, cmd, arg);\n\tif (error == -ENOIOCTLCMD)\n\t\terror = -ENOTTY;\n out:\n\treturn error;\n}\n\nstatic int ioctl_fibmap(struct file *filp, int __user *p)\n{\n\tstruct address_space *mapping = filp->f_mapping;\n\tint res, block;\n\n\t/* do we support this mess? */\n\tif (!mapping->a_ops->bmap)\n\t\treturn -EINVAL;\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\tres = get_user(block, p);\n\tif (res)\n\t\treturn res;\n\tres = mapping->a_ops->bmap(mapping, block);\n\treturn put_user(res, p);\n}\n\n/**\n * fiemap_fill_next_extent - Fiemap helper function\n * @fieinfo:\tFiemap context passed into ->fiemap\n * @logical:\tExtent logical start offset, in bytes\n * @phys:\tExtent physical start offset, in bytes\n * @len:\tExtent length, in bytes\n * @flags:\tFIEMAP_EXTENT flags that describe this extent\n *\n * Called from file system ->fiemap callback. Will populate extent\n * info as passed in via arguments and copy to user memory. On\n * success, extent count on fieinfo is incremented.\n *\n * Returns 0 on success, -errno on error, 1 if this was the last\n * extent that will fit in user array.\n */\n#define SET_UNKNOWN_FLAGS\t(FIEMAP_EXTENT_DELALLOC)\n#define SET_NO_UNMOUNTED_IO_FLAGS\t(FIEMAP_EXTENT_DATA_ENCRYPTED)\n#define SET_NOT_ALIGNED_FLAGS\t(FIEMAP_EXTENT_DATA_TAIL|FIEMAP_EXTENT_DATA_INLINE)\nint fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical,\n\t\t\t    u64 phys, u64 len, u32 flags)\n{\n\tstruct fiemap_extent extent;\n\tstruct fiemap_extent __user *dest = fieinfo->fi_extents_start;\n\n\t/* only count the extents */\n\tif (fieinfo->fi_extents_max == 0) {\n\t\tfieinfo->fi_extents_mapped++;\n\t\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n\t}\n\n\tif (fieinfo->fi_extents_mapped >= fieinfo->fi_extents_max)\n\t\treturn 1;\n\n\tif (flags & SET_UNKNOWN_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_UNKNOWN;\n\tif (flags & SET_NO_UNMOUNTED_IO_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\tif (flags & SET_NOT_ALIGNED_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_NOT_ALIGNED;\n\n\tmemset(&extent, 0, sizeof(extent));\n\textent.fe_logical = logical;\n\textent.fe_physical = phys;\n\textent.fe_length = len;\n\textent.fe_flags = flags;\n\n\tdest += fieinfo->fi_extents_mapped;\n\tif (copy_to_user(dest, &extent, sizeof(extent)))\n\t\treturn -EFAULT;\n\n\tfieinfo->fi_extents_mapped++;\n\tif (fieinfo->fi_extents_mapped == fieinfo->fi_extents_max)\n\t\treturn 1;\n\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n}\nEXPORT_SYMBOL(fiemap_fill_next_extent);\n\n/**\n * fiemap_check_flags - check validity of requested flags for fiemap\n * @fieinfo:\tFiemap context passed into ->fiemap\n * @fs_flags:\tSet of fiemap flags that the file system understands\n *\n * Called from file system ->fiemap callback. This will compute the\n * intersection of valid fiemap flags and those that the fs supports. That\n * value is then compared against the user supplied flags. In case of bad user\n * flags, the invalid values will be written into the fieinfo structure, and\n * -EBADR is returned, which tells ioctl_fiemap() to return those values to\n * userspace. For this reason, a return code of -EBADR should be preserved.\n *\n * Returns 0 on success, -EBADR on bad flags.\n */\nint fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags)\n{\n\tu32 incompat_flags;\n\n\tincompat_flags = fieinfo->fi_flags & ~(FIEMAP_FLAGS_COMPAT & fs_flags);\n\tif (incompat_flags) {\n\t\tfieinfo->fi_flags = incompat_flags;\n\t\treturn -EBADR;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(fiemap_check_flags);\n\nstatic int fiemap_check_ranges(struct super_block *sb,\n\t\t\t       u64 start, u64 len, u64 *new_len)\n{\n\tu64 maxbytes = (u64) sb->s_maxbytes;\n\n\t*new_len = len;\n\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\tif (start > maxbytes)\n\t\treturn -EFBIG;\n\n\t/*\n\t * Shrink request scope to what the fs can actually handle.\n\t */\n\tif (len > maxbytes || (maxbytes - len) < start)\n\t\t*new_len = maxbytes - start;\n\n\treturn 0;\n}\n\nstatic int ioctl_fiemap(struct file *filp, unsigned long arg)\n{\n\tstruct fiemap fiemap;\n\tstruct fiemap __user *ufiemap = (struct fiemap __user *) arg;\n\tstruct fiemap_extent_info fieinfo = { 0, };\n\tstruct inode *inode = file_inode(filp);\n\tstruct super_block *sb = inode->i_sb;\n\tu64 len;\n\tint error;\n\n\tif (!inode->i_op->fiemap)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&fiemap, ufiemap, sizeof(fiemap)))\n\t\treturn -EFAULT;\n\n\tif (fiemap.fm_extent_count > FIEMAP_MAX_EXTENTS)\n\t\treturn -EINVAL;\n\n\terror = fiemap_check_ranges(sb, fiemap.fm_start, fiemap.fm_length,\n\t\t\t\t    &len);\n\tif (error)\n\t\treturn error;\n\n\tfieinfo.fi_flags = fiemap.fm_flags;\n\tfieinfo.fi_extents_max = fiemap.fm_extent_count;\n\tfieinfo.fi_extents_start = ufiemap->fm_extents;\n\n\tif (fiemap.fm_extent_count != 0 &&\n\t    !access_ok(VERIFY_WRITE, fieinfo.fi_extents_start,\n\t\t       fieinfo.fi_extents_max * sizeof(struct fiemap_extent)))\n\t\treturn -EFAULT;\n\n\tif (fieinfo.fi_flags & FIEMAP_FLAG_SYNC)\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\n\terror = inode->i_op->fiemap(inode, &fieinfo, fiemap.fm_start, len);\n\tfiemap.fm_flags = fieinfo.fi_flags;\n\tfiemap.fm_mapped_extents = fieinfo.fi_extents_mapped;\n\tif (copy_to_user(ufiemap, &fiemap, sizeof(fiemap)))\n\t\terror = -EFAULT;\n\n\treturn error;\n}\n\nstatic long ioctl_file_clone(struct file *dst_file, unsigned long srcfd,\n\t\t\t     u64 off, u64 olen, u64 destoff)\n{\n\tstruct fd src_file = fdget(srcfd);\n\tint ret;\n\n\tif (!src_file.file)\n\t\treturn -EBADF;\n\tret = vfs_clone_file_range(src_file.file, off, dst_file, destoff, olen);\n\tfdput(src_file);\n\treturn ret;\n}\n\nstatic long ioctl_file_clone_range(struct file *file, void __user *argp)\n{\n\tstruct file_clone_range args;\n\n\tif (copy_from_user(&args, argp, sizeof(args)))\n\t\treturn -EFAULT;\n\treturn ioctl_file_clone(file, args.src_fd, args.src_offset,\n\t\t\t\targs.src_length, args.dest_offset);\n}\n\n#ifdef CONFIG_BLOCK\n\nstatic inline sector_t logical_to_blk(struct inode *inode, loff_t offset)\n{\n\treturn (offset >> inode->i_blkbits);\n}\n\nstatic inline loff_t blk_to_logical(struct inode *inode, sector_t blk)\n{\n\treturn (blk << inode->i_blkbits);\n}\n\n/**\n * __generic_block_fiemap - FIEMAP for block based inodes (no locking)\n * @inode: the inode to map\n * @fieinfo: the fiemap info struct that will be passed back to userspace\n * @start: where to start mapping in the inode\n * @len: how much space to map\n * @get_block: the fs's get_block function\n *\n * This does FIEMAP for block based inodes.  Basically it will just loop\n * through get_block until we hit the number of extents we want to map, or we\n * go past the end of the file and hit a hole.\n *\n * If it is possible to have data blocks beyond a hole past @inode->i_size, then\n * please do not use this function, it will stop at the first unmapped block\n * beyond i_size.\n *\n * If you use this function directly, you need to do your own locking. Use\n * generic_block_fiemap if you want the locking done for you.\n */\n\nint __generic_block_fiemap(struct inode *inode,\n\t\t\t   struct fiemap_extent_info *fieinfo, loff_t start,\n\t\t\t   loff_t len, get_block_t *get_block)\n{\n\tstruct buffer_head map_bh;\n\tsector_t start_blk, last_blk;\n\tloff_t isize = i_size_read(inode);\n\tu64 logical = 0, phys = 0, size = 0;\n\tu32 flags = FIEMAP_EXTENT_MERGED;\n\tbool past_eof = false, whole_file = false;\n\tint ret = 0;\n\n\tret = fiemap_check_flags(fieinfo, FIEMAP_FLAG_SYNC);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Either the i_mutex or other appropriate locking needs to be held\n\t * since we expect isize to not change at all through the duration of\n\t * this call.\n\t */\n\tif (len >= isize) {\n\t\twhole_file = true;\n\t\tlen = isize;\n\t}\n\n\t/*\n\t * Some filesystems can't deal with being asked to map less than\n\t * blocksize, so make sure our len is at least block length.\n\t */\n\tif (logical_to_blk(inode, len) == 0)\n\t\tlen = blk_to_logical(inode, 1);\n\n\tstart_blk = logical_to_blk(inode, start);\n\tlast_blk = logical_to_blk(inode, start + len - 1);\n\n\tdo {\n\t\t/*\n\t\t * we set b_size to the total size we want so it will map as\n\t\t * many contiguous blocks as possible at once\n\t\t */\n\t\tmemset(&map_bh, 0, sizeof(struct buffer_head));\n\t\tmap_bh.b_size = len;\n\n\t\tret = get_block(inode, start_blk, &map_bh, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t/* HOLE */\n\t\tif (!buffer_mapped(&map_bh)) {\n\t\t\tstart_blk++;\n\n\t\t\t/*\n\t\t\t * We want to handle the case where there is an\n\t\t\t * allocated block at the front of the file, and then\n\t\t\t * nothing but holes up to the end of the file properly,\n\t\t\t * to make sure that extent at the front gets properly\n\t\t\t * marked with FIEMAP_EXTENT_LAST\n\t\t\t */\n\t\t\tif (!past_eof &&\n\t\t\t    blk_to_logical(inode, start_blk) >= isize)\n\t\t\t\tpast_eof = 1;\n\n\t\t\t/*\n\t\t\t * First hole after going past the EOF, this is our\n\t\t\t * last extent\n\t\t\t */\n\t\t\tif (past_eof && size) {\n\t\t\t\tflags = FIEMAP_EXTENT_MERGED|FIEMAP_EXTENT_LAST;\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size,\n\t\t\t\t\t\t\t      flags);\n\t\t\t} else if (size) {\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size, flags);\n\t\t\t\tsize = 0;\n\t\t\t}\n\n\t\t\t/* if we have holes up to/past EOF then we're done */\n\t\t\tif (start_blk > last_blk || past_eof || ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We have gone over the length of what we wanted to\n\t\t\t * map, and it wasn't the entire file, so add the extent\n\t\t\t * we got last time and exit.\n\t\t\t *\n\t\t\t * This is for the case where say we want to map all the\n\t\t\t * way up to the second to the last block in a file, but\n\t\t\t * the last block is a hole, making the second to last\n\t\t\t * block FIEMAP_EXTENT_LAST.  In this case we want to\n\t\t\t * see if there is a hole after the second to last block\n\t\t\t * so we can mark it properly.  If we found data after\n\t\t\t * we exceeded the length we were requesting, then we\n\t\t\t * are good to go, just add the extent to the fieinfo\n\t\t\t * and break\n\t\t\t */\n\t\t\tif (start_blk > last_blk && !whole_file) {\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size,\n\t\t\t\t\t\t\t      flags);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if size != 0 then we know we already have an extent\n\t\t\t * to add, so add it.\n\t\t\t */\n\t\t\tif (size) {\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size,\n\t\t\t\t\t\t\t      flags);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlogical = blk_to_logical(inode, start_blk);\n\t\t\tphys = blk_to_logical(inode, map_bh.b_blocknr);\n\t\t\tsize = map_bh.b_size;\n\t\t\tflags = FIEMAP_EXTENT_MERGED;\n\n\t\t\tstart_blk += logical_to_blk(inode, size);\n\n\t\t\t/*\n\t\t\t * If we are past the EOF, then we need to make sure as\n\t\t\t * soon as we find a hole that the last extent we found\n\t\t\t * is marked with FIEMAP_EXTENT_LAST\n\t\t\t */\n\t\t\tif (!past_eof && logical + size >= isize)\n\t\t\t\tpast_eof = true;\n\t\t}\n\t\tcond_resched();\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t} while (1);\n\n\t/* If ret is 1 then we just hit the end of the extent array */\n\tif (ret == 1)\n\t\tret = 0;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(__generic_block_fiemap);\n\n/**\n * generic_block_fiemap - FIEMAP for block based inodes\n * @inode: The inode to map\n * @fieinfo: The mapping information\n * @start: The initial block to map\n * @len: The length of the extect to attempt to map\n * @get_block: The block mapping function for the fs\n *\n * Calls __generic_block_fiemap to map the inode, after taking\n * the inode's mutex lock.\n */\n\nint generic_block_fiemap(struct inode *inode,\n\t\t\t struct fiemap_extent_info *fieinfo, u64 start,\n\t\t\t u64 len, get_block_t *get_block)\n{\n\tint ret;\n\tinode_lock(inode);\n\tret = __generic_block_fiemap(inode, fieinfo, start, len, get_block);\n\tinode_unlock(inode);\n\treturn ret;\n}\nEXPORT_SYMBOL(generic_block_fiemap);\n\n#endif  /*  CONFIG_BLOCK  */\n\n/*\n * This provides compatibility with legacy XFS pre-allocation ioctls\n * which predate the fallocate syscall.\n *\n * Only the l_start, l_len and l_whence fields of the 'struct space_resv'\n * are used here, rest are ignored.\n */\nint ioctl_preallocate(struct file *filp, void __user *argp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct space_resv sr;\n\n\tif (copy_from_user(&sr, argp, sizeof(sr)))\n\t\treturn -EFAULT;\n\n\tswitch (sr.l_whence) {\n\tcase SEEK_SET:\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tsr.l_start += filp->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tsr.l_start += i_size_read(inode);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn vfs_fallocate(filp, FALLOC_FL_KEEP_SIZE, sr.l_start, sr.l_len);\n}\n\nstatic int file_ioctl(struct file *filp, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint __user *p = (int __user *)arg;\n\n\tswitch (cmd) {\n\tcase FIBMAP:\n\t\treturn ioctl_fibmap(filp, p);\n\tcase FIONREAD:\n\t\treturn put_user(i_size_read(inode) - filp->f_pos, p);\n\tcase FS_IOC_RESVSP:\n\tcase FS_IOC_RESVSP64:\n\t\treturn ioctl_preallocate(filp, p);\n\t}\n\n\treturn vfs_ioctl(filp, cmd, arg);\n}\n\nstatic int ioctl_fionbio(struct file *filp, int __user *argp)\n{\n\tunsigned int flag;\n\tint on, error;\n\n\terror = get_user(on, argp);\n\tif (error)\n\t\treturn error;\n\tflag = O_NONBLOCK;\n#ifdef __sparc__\n\t/* SunOS compatibility item. */\n\tif (O_NONBLOCK != O_NDELAY)\n\t\tflag |= O_NDELAY;\n#endif\n\tspin_lock(&filp->f_lock);\n\tif (on)\n\t\tfilp->f_flags |= flag;\n\telse\n\t\tfilp->f_flags &= ~flag;\n\tspin_unlock(&filp->f_lock);\n\treturn error;\n}\n\nstatic int ioctl_fioasync(unsigned int fd, struct file *filp,\n\t\t\t  int __user *argp)\n{\n\tunsigned int flag;\n\tint on, error;\n\n\terror = get_user(on, argp);\n\tif (error)\n\t\treturn error;\n\tflag = on ? FASYNC : 0;\n\n\t/* Did FASYNC state change ? */\n\tif ((flag ^ filp->f_flags) & FASYNC) {\n\t\tif (filp->f_op->fasync)\n\t\t\t/* fasync() adjusts filp->f_flags */\n\t\t\terror = filp->f_op->fasync(fd, filp, on);\n\t\telse\n\t\t\terror = -ENOTTY;\n\t}\n\treturn error < 0 ? error : 0;\n}\n\nstatic int ioctl_fsfreeze(struct file *filp)\n{\n\tstruct super_block *sb = file_inode(filp)->i_sb;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* If filesystem doesn't support freeze feature, return. */\n\tif (sb->s_op->freeze_fs == NULL && sb->s_op->freeze_super == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Freeze */\n\tif (sb->s_op->freeze_super)\n\t\treturn sb->s_op->freeze_super(sb);\n\treturn freeze_super(sb);\n}\n\nstatic int ioctl_fsthaw(struct file *filp)\n{\n\tstruct super_block *sb = file_inode(filp)->i_sb;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* Thaw */\n\tif (sb->s_op->thaw_super)\n\t\treturn sb->s_op->thaw_super(sb);\n\treturn thaw_super(sb);\n}\n\nstatic long ioctl_file_dedupe_range(struct file *file, void __user *arg)\n{\n\tstruct file_dedupe_range __user *argp = arg;\n\tstruct file_dedupe_range *same = NULL;\n\tint ret;\n\tunsigned long size;\n\tu16 count;\n\n\tif (get_user(count, &argp->dest_count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tsize = offsetof(struct file_dedupe_range __user, info[count]);\n\n\tsame = memdup_user(argp, size);\n\tif (IS_ERR(same)) {\n\t\tret = PTR_ERR(same);\n\t\tsame = NULL;\n\t\tgoto out;\n\t}\n\n\tsame->dest_count = count;\n\tret = vfs_dedupe_file_range(file, same);\n\tif (ret)\n\t\tgoto out;\n\n\tret = copy_to_user(argp, same, size);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tkfree(same);\n\treturn ret;\n}\n\n/*\n * When you add any new common ioctls to the switches above and below\n * please update compat_sys_ioctl() too.\n *\n * do_vfs_ioctl() is not for drivers and not intended to be EXPORT_SYMBOL()'d.\n * It's just a simple helper for sys_ioctl and compat_sys_ioctl.\n */\nint do_vfs_ioctl(struct file *filp, unsigned int fd, unsigned int cmd,\n\t     unsigned long arg)\n{\n\tint error = 0;\n\tint __user *argp = (int __user *)arg;\n\tstruct inode *inode = file_inode(filp);\n\n\tswitch (cmd) {\n\tcase FIOCLEX:\n\t\tset_close_on_exec(fd, 1);\n\t\tbreak;\n\n\tcase FIONCLEX:\n\t\tset_close_on_exec(fd, 0);\n\t\tbreak;\n\n\tcase FIONBIO:\n\t\terror = ioctl_fionbio(filp, argp);\n\t\tbreak;\n\n\tcase FIOASYNC:\n\t\terror = ioctl_fioasync(fd, filp, argp);\n\t\tbreak;\n\n\tcase FIOQSIZE:\n\t\tif (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode) ||\n\t\t    S_ISLNK(inode->i_mode)) {\n\t\t\tloff_t res = inode_get_bytes(inode);\n\t\t\terror = copy_to_user(argp, &res, sizeof(res)) ?\n\t\t\t\t\t-EFAULT : 0;\n\t\t} else\n\t\t\terror = -ENOTTY;\n\t\tbreak;\n\n\tcase FIFREEZE:\n\t\terror = ioctl_fsfreeze(filp);\n\t\tbreak;\n\n\tcase FITHAW:\n\t\terror = ioctl_fsthaw(filp);\n\t\tbreak;\n\n\tcase FS_IOC_FIEMAP:\n\t\treturn ioctl_fiemap(filp, arg);\n\n\tcase FIGETBSZ:\n\t\treturn put_user(inode->i_sb->s_blocksize, argp);\n\n\tcase FICLONE:\n\t\treturn ioctl_file_clone(filp, arg, 0, 0, 0);\n\n\tcase FICLONERANGE:\n\t\treturn ioctl_file_clone_range(filp, argp);\n\n\tcase FIDEDUPERANGE:\n\t\treturn ioctl_file_dedupe_range(filp, argp);\n\n\tdefault:\n\t\tif (S_ISREG(inode->i_mode))\n\t\t\terror = file_ioctl(filp, cmd, arg);\n\t\telse\n\t\t\terror = vfs_ioctl(filp, cmd, arg);\n\t\tbreak;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)\n{\n\tint error;\n\tstruct fd f = fdget(fd);\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\terror = security_file_ioctl(f.file, cmd, arg);\n\tif (!error)\n\t\terror = do_vfs_ioctl(f.file, fd, cmd, arg);\n\tfdput(f);\n\treturn error;\n}\n"], "filenames": ["fs/ioctl.c"], "buggy_code_start_loc": [592], "buggy_code_end_loc": [592], "fixing_code_start_loc": [593], "fixing_code_end_loc": [594], "type": "CWE-119", "message": "Race condition in the ioctl_file_dedupe_range function in fs/ioctl.c in the Linux kernel through 4.7 allows local users to cause a denial of service (heap-based buffer overflow) or possibly gain privileges by changing a certain count value, aka a \"double fetch\" vulnerability.", "other": {"cve": {"id": "CVE-2016-6516", "sourceIdentifier": "cve@mitre.org", "published": "2016-08-06T20:59:15.893", "lastModified": "2016-11-28T20:33:32.783", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Race condition in the ioctl_file_dedupe_range function in fs/ioctl.c in the Linux kernel through 4.7 allows local users to cause a denial of service (heap-based buffer overflow) or possibly gain privileges by changing a certain count value, aka a \"double fetch\" vulnerability."}, {"lang": "es", "value": "Condici\u00f3n de carrera en la funci\u00f3n ioctl_file_dedupe_range en fs/ioctl.c en el kernel de Linux hasta la versi\u00f3n 4.7 permite a usuarios locales provocar una denegaci\u00f3n de servicio (desbordamiento de b\u00fafer basado en memoria din\u00e1mica) o posiblemente obtener privilegios cambiando un cierto valor de recuento, tambi\u00e9n conocido como una vulnerabilidad de \"doble recuperaci\u00f3n\"."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.4, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}, {"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.7", "matchCriteriaId": "6AF8F457-8A21-4907-BB5E-6193D0DAD885"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=10eec60ce79187686e052092e5383c99b4420a20", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/07/31/6", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "http://www.securityfocus.com/bid/92259", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1362457", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/10eec60ce79187686e052092e5383c99b4420a20", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/10eec60ce79187686e052092e5383c99b4420a20"}}