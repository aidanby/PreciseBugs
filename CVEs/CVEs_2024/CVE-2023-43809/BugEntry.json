{"buggy_code": ["package ssh\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/log\"\n\t\"github.com/charmbracelet/soft-serve/server/backend\"\n\t\"github.com/charmbracelet/soft-serve/server/config\"\n\t\"github.com/charmbracelet/soft-serve/server/db\"\n\t\"github.com/charmbracelet/soft-serve/server/proto\"\n\t\"github.com/charmbracelet/soft-serve/server/ssh/cmd\"\n\t\"github.com/charmbracelet/soft-serve/server/sshutils\"\n\t\"github.com/charmbracelet/soft-serve/server/store\"\n\t\"github.com/charmbracelet/ssh\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promauto\"\n\t\"github.com/spf13/cobra\"\n)\n\n// ContextMiddleware adds the config, backend, and logger to the session context.\nfunc ContextMiddleware(cfg *config.Config, dbx *db.DB, datastore store.Store, be *backend.Backend, logger *log.Logger) func(ssh.Handler) ssh.Handler {\n\treturn func(sh ssh.Handler) ssh.Handler {\n\t\treturn func(s ssh.Session) {\n\t\t\ts.Context().SetValue(sshutils.ContextKeySession, s)\n\t\t\ts.Context().SetValue(config.ContextKey, cfg)\n\t\t\ts.Context().SetValue(db.ContextKey, dbx)\n\t\t\ts.Context().SetValue(store.ContextKey, datastore)\n\t\t\ts.Context().SetValue(backend.ContextKey, be)\n\t\t\ts.Context().SetValue(log.ContextKey, logger.WithPrefix(\"ssh\"))\n\t\t\tsh(s)\n\t\t}\n\t}\n}\n\nvar cliCommandCounter = promauto.NewCounterVec(prometheus.CounterOpts{\n\tNamespace: \"soft_serve\",\n\tSubsystem: \"cli\",\n\tName:      \"commands_total\",\n\tHelp:      \"Total times each command was called\",\n}, []string{\"command\"})\n\n// CommandMiddleware handles git commands and CLI commands.\n// This middleware must be run after the ContextMiddleware.\nfunc CommandMiddleware(sh ssh.Handler) ssh.Handler {\n\treturn func(s ssh.Session) {\n\t\tfunc() {\n\t\t\t_, _, ptyReq := s.Pty()\n\t\t\tif ptyReq {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tctx := s.Context()\n\t\t\tcfg := config.FromContext(ctx)\n\n\t\t\targs := s.Command()\n\t\t\tcliCommandCounter.WithLabelValues(cmd.CommandName(args)).Inc()\n\t\t\trootCmd := &cobra.Command{\n\t\t\t\tShort:        \"Soft Serve is a self-hostable Git server for the command line.\",\n\t\t\t\tSilenceUsage: true,\n\t\t\t}\n\t\t\trootCmd.CompletionOptions.DisableDefaultCmd = true\n\n\t\t\trootCmd.SetUsageTemplate(cmd.UsageTemplate)\n\t\t\trootCmd.SetUsageFunc(cmd.UsageFunc)\n\t\t\trootCmd.AddCommand(\n\t\t\t\tcmd.GitUploadPackCommand(),\n\t\t\t\tcmd.GitUploadArchiveCommand(),\n\t\t\t\tcmd.GitReceivePackCommand(),\n\t\t\t\tcmd.RepoCommand(),\n\t\t\t\tcmd.SettingsCommand(),\n\t\t\t\tcmd.UserCommand(),\n\t\t\t\tcmd.InfoCommand(),\n\t\t\t\tcmd.PubkeyCommand(),\n\t\t\t\tcmd.SetUsernameCommand(),\n\t\t\t\tcmd.JWTCommand(),\n\t\t\t\tcmd.TokenCommand(),\n\t\t\t)\n\n\t\t\tif cfg.LFS.Enabled {\n\t\t\t\trootCmd.AddCommand(\n\t\t\t\t\tcmd.GitLFSAuthenticateCommand(),\n\t\t\t\t)\n\n\t\t\t\tif cfg.LFS.SSHEnabled {\n\t\t\t\t\trootCmd.AddCommand(\n\t\t\t\t\t\tcmd.GitLFSTransfer(),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trootCmd.SetArgs(args)\n\t\t\tif len(args) == 0 {\n\t\t\t\t// otherwise it'll default to os.Args, which is not what we want.\n\t\t\t\trootCmd.SetArgs([]string{\"--help\"})\n\t\t\t}\n\t\t\trootCmd.SetIn(s)\n\t\t\trootCmd.SetOut(s)\n\t\t\trootCmd.SetErr(s.Stderr())\n\t\t\trootCmd.SetContext(ctx)\n\n\t\t\tif err := rootCmd.ExecuteContext(ctx); err != nil {\n\t\t\t\ts.Exit(1) // nolint: errcheck\n\t\t\t\treturn\n\t\t\t}\n\t\t}()\n\t\tsh(s)\n\t}\n}\n\n// LoggingMiddleware logs the ssh connection and command.\nfunc LoggingMiddleware(sh ssh.Handler) ssh.Handler {\n\treturn func(s ssh.Session) {\n\t\tctx := s.Context()\n\t\tlogger := log.FromContext(ctx).WithPrefix(\"ssh\")\n\t\tct := time.Now()\n\t\thpk := sshutils.MarshalAuthorizedKey(s.PublicKey())\n\t\tptyReq, _, isPty := s.Pty()\n\t\taddr := s.RemoteAddr().String()\n\t\tuser := proto.UserFromContext(ctx)\n\t\tlogArgs := []interface{}{\n\t\t\t\"addr\",\n\t\t\taddr,\n\t\t\t\"cmd\",\n\t\t\ts.Command(),\n\t\t}\n\n\t\tif user != nil {\n\t\t\tlogArgs = append([]interface{}{\n\t\t\t\t\"username\",\n\t\t\t\tuser.Username(),\n\t\t\t}, logArgs...)\n\t\t}\n\n\t\tif isPty {\n\t\t\tlogArgs = []interface{}{\n\t\t\t\t\"term\", ptyReq.Term,\n\t\t\t\t\"width\", ptyReq.Window.Width,\n\t\t\t\t\"height\", ptyReq.Window.Height,\n\t\t\t}\n\t\t}\n\n\t\tif config.IsVerbose() {\n\t\t\tlogArgs = append(logArgs,\n\t\t\t\t\"key\", hpk,\n\t\t\t\t\"envs\", s.Environ(),\n\t\t\t)\n\t\t}\n\n\t\tmsg := fmt.Sprintf(\"user %q\", s.User())\n\t\tlogger.Debug(msg+\" connected\", logArgs...)\n\t\tsh(s)\n\t\tlogger.Debug(msg+\" disconnected\", append(logArgs, \"duration\", time.Since(ct))...)\n\t}\n}\n", "package ssh\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/keygen\"\n\t\"github.com/charmbracelet/log\"\n\t\"github.com/charmbracelet/soft-serve/server/backend\"\n\t\"github.com/charmbracelet/soft-serve/server/config\"\n\t\"github.com/charmbracelet/soft-serve/server/db\"\n\t\"github.com/charmbracelet/soft-serve/server/proto\"\n\t\"github.com/charmbracelet/soft-serve/server/store\"\n\t\"github.com/charmbracelet/ssh\"\n\t\"github.com/charmbracelet/wish\"\n\tbm \"github.com/charmbracelet/wish/bubbletea\"\n\trm \"github.com/charmbracelet/wish/recover\"\n\t\"github.com/muesli/termenv\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promauto\"\n\tgossh \"golang.org/x/crypto/ssh\"\n)\n\nvar (\n\tpublicKeyCounter = promauto.NewCounterVec(prometheus.CounterOpts{\n\t\tNamespace: \"soft_serve\",\n\t\tSubsystem: \"ssh\",\n\t\tName:      \"public_key_auth_total\",\n\t\tHelp:      \"The total number of public key auth requests\",\n\t}, []string{\"allowed\"})\n\n\tkeyboardInteractiveCounter = promauto.NewCounterVec(prometheus.CounterOpts{\n\t\tNamespace: \"soft_serve\",\n\t\tSubsystem: \"ssh\",\n\t\tName:      \"keyboard_interactive_auth_total\",\n\t\tHelp:      \"The total number of keyboard interactive auth requests\",\n\t}, []string{\"allowed\"})\n)\n\n// SSHServer is a SSH server that implements the git protocol.\ntype SSHServer struct { // nolint: revive\n\tsrv    *ssh.Server\n\tcfg    *config.Config\n\tbe     *backend.Backend\n\tctx    context.Context\n\tlogger *log.Logger\n}\n\n// NewSSHServer returns a new SSHServer.\nfunc NewSSHServer(ctx context.Context) (*SSHServer, error) {\n\tcfg := config.FromContext(ctx)\n\tlogger := log.FromContext(ctx).WithPrefix(\"ssh\")\n\tdbx := db.FromContext(ctx)\n\tdatastore := store.FromContext(ctx)\n\tbe := backend.FromContext(ctx)\n\n\tvar err error\n\ts := &SSHServer{\n\t\tcfg:    cfg,\n\t\tctx:    ctx,\n\t\tbe:     be,\n\t\tlogger: logger,\n\t}\n\n\tmw := []wish.Middleware{\n\t\trm.MiddlewareWithLogger(\n\t\t\tlogger,\n\t\t\t// BubbleTea middleware.\n\t\t\tbm.MiddlewareWithProgramHandler(SessionHandler, termenv.ANSI256),\n\t\t\t// CLI middleware.\n\t\t\tCommandMiddleware,\n\t\t\t// Logging middleware.\n\t\t\tLoggingMiddleware,\n\t\t\t// Context middleware.\n\t\t\tContextMiddleware(cfg, dbx, datastore, be, logger),\n\t\t),\n\t}\n\n\ts.srv, err = wish.NewServer(\n\t\tssh.PublicKeyAuth(s.PublicKeyHandler),\n\t\tssh.KeyboardInteractiveAuth(s.KeyboardInteractiveHandler),\n\t\twish.WithAddress(cfg.SSH.ListenAddr),\n\t\twish.WithHostKeyPath(cfg.SSH.KeyPath),\n\t\twish.WithMiddleware(mw...),\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif cfg.SSH.MaxTimeout > 0 {\n\t\ts.srv.MaxTimeout = time.Duration(cfg.SSH.MaxTimeout) * time.Second\n\t}\n\n\tif cfg.SSH.IdleTimeout > 0 {\n\t\ts.srv.IdleTimeout = time.Duration(cfg.SSH.IdleTimeout) * time.Second\n\t}\n\n\t// Create client ssh key\n\tif _, err := os.Stat(cfg.SSH.ClientKeyPath); err != nil && os.IsNotExist(err) {\n\t\t_, err := keygen.New(cfg.SSH.ClientKeyPath, keygen.WithKeyType(keygen.Ed25519), keygen.WithWrite())\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"client ssh key: %w\", err)\n\t\t}\n\t}\n\n\treturn s, nil\n}\n\n// ListenAndServe starts the SSH server.\nfunc (s *SSHServer) ListenAndServe() error {\n\treturn s.srv.ListenAndServe()\n}\n\n// Serve starts the SSH server on the given net.Listener.\nfunc (s *SSHServer) Serve(l net.Listener) error {\n\treturn s.srv.Serve(l)\n}\n\n// Close closes the SSH server.\nfunc (s *SSHServer) Close() error {\n\treturn s.srv.Close()\n}\n\n// Shutdown gracefully shuts down the SSH server.\nfunc (s *SSHServer) Shutdown(ctx context.Context) error {\n\treturn s.srv.Shutdown(ctx)\n}\n\n// PublicKeyAuthHandler handles public key authentication.\nfunc (s *SSHServer) PublicKeyHandler(ctx ssh.Context, pk ssh.PublicKey) (allowed bool) {\n\tif pk == nil {\n\t\treturn false\n\t}\n\n\tdefer func(allowed *bool) {\n\t\tpublicKeyCounter.WithLabelValues(strconv.FormatBool(*allowed)).Inc()\n\t}(&allowed)\n\n\tuser, _ := s.be.UserByPublicKey(ctx, pk)\n\tif user != nil {\n\t\tctx.SetValue(proto.ContextKeyUser, user)\n\t\tallowed = true\n\t}\n\n\treturn\n}\n\n// KeyboardInteractiveHandler handles keyboard interactive authentication.\n// This is used after all public key authentication has failed.\nfunc (s *SSHServer) KeyboardInteractiveHandler(ctx ssh.Context, _ gossh.KeyboardInteractiveChallenge) bool {\n\tac := s.be.AllowKeyless(ctx)\n\tkeyboardInteractiveCounter.WithLabelValues(strconv.FormatBool(ac)).Inc()\n\treturn ac\n}\n"], "fixing_code": ["package ssh\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/log\"\n\t\"github.com/charmbracelet/soft-serve/server/backend\"\n\t\"github.com/charmbracelet/soft-serve/server/config\"\n\t\"github.com/charmbracelet/soft-serve/server/db\"\n\t\"github.com/charmbracelet/soft-serve/server/proto\"\n\t\"github.com/charmbracelet/soft-serve/server/ssh/cmd\"\n\t\"github.com/charmbracelet/soft-serve/server/sshutils\"\n\t\"github.com/charmbracelet/soft-serve/server/store\"\n\t\"github.com/charmbracelet/ssh\"\n\t\"github.com/charmbracelet/wish\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promauto\"\n\t\"github.com/spf13/cobra\"\n\tgossh \"golang.org/x/crypto/ssh\"\n)\n\n// ErrPermissionDenied is returned when a user is not allowed connect.\nvar ErrPermissionDenied = fmt.Errorf(\"permission denied\")\n\n// AuthenticationMiddleware handles authentication.\nfunc AuthenticationMiddleware(sh ssh.Handler) ssh.Handler {\n\treturn func(s ssh.Session) {\n\t\t// XXX: The authentication key is set in the context but gossh doesn't\n\t\t// validate the authentication. We need to verify that the _last_ key\n\t\t// that was approved is the one that's being used.\n\n\t\tpk := s.PublicKey()\n\t\tif pk != nil {\n\t\t\t// There is no public key stored in the context, public-key auth\n\t\t\t// was never requested, skip\n\t\t\tperms := s.Permissions().Permissions\n\t\t\tif perms == nil {\n\t\t\t\twish.Fatalln(s, ErrPermissionDenied)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Check if the key is the same as the one we have in context\n\t\t\tfp := perms.Extensions[\"pubkey-fp\"]\n\t\t\tif fp != gossh.FingerprintSHA256(pk) {\n\t\t\t\twish.Fatalln(s, ErrPermissionDenied)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tsh(s)\n\t}\n}\n\n// ContextMiddleware adds the config, backend, and logger to the session context.\nfunc ContextMiddleware(cfg *config.Config, dbx *db.DB, datastore store.Store, be *backend.Backend, logger *log.Logger) func(ssh.Handler) ssh.Handler {\n\treturn func(sh ssh.Handler) ssh.Handler {\n\t\treturn func(s ssh.Session) {\n\t\t\ts.Context().SetValue(sshutils.ContextKeySession, s)\n\t\t\ts.Context().SetValue(config.ContextKey, cfg)\n\t\t\ts.Context().SetValue(db.ContextKey, dbx)\n\t\t\ts.Context().SetValue(store.ContextKey, datastore)\n\t\t\ts.Context().SetValue(backend.ContextKey, be)\n\t\t\ts.Context().SetValue(log.ContextKey, logger.WithPrefix(\"ssh\"))\n\t\t\tsh(s)\n\t\t}\n\t}\n}\n\nvar cliCommandCounter = promauto.NewCounterVec(prometheus.CounterOpts{\n\tNamespace: \"soft_serve\",\n\tSubsystem: \"cli\",\n\tName:      \"commands_total\",\n\tHelp:      \"Total times each command was called\",\n}, []string{\"command\"})\n\n// CommandMiddleware handles git commands and CLI commands.\n// This middleware must be run after the ContextMiddleware.\nfunc CommandMiddleware(sh ssh.Handler) ssh.Handler {\n\treturn func(s ssh.Session) {\n\t\tfunc() {\n\t\t\t_, _, ptyReq := s.Pty()\n\t\t\tif ptyReq {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tctx := s.Context()\n\t\t\tcfg := config.FromContext(ctx)\n\n\t\t\targs := s.Command()\n\t\t\tcliCommandCounter.WithLabelValues(cmd.CommandName(args)).Inc()\n\t\t\trootCmd := &cobra.Command{\n\t\t\t\tShort:        \"Soft Serve is a self-hostable Git server for the command line.\",\n\t\t\t\tSilenceUsage: true,\n\t\t\t}\n\t\t\trootCmd.CompletionOptions.DisableDefaultCmd = true\n\n\t\t\trootCmd.SetUsageTemplate(cmd.UsageTemplate)\n\t\t\trootCmd.SetUsageFunc(cmd.UsageFunc)\n\t\t\trootCmd.AddCommand(\n\t\t\t\tcmd.GitUploadPackCommand(),\n\t\t\t\tcmd.GitUploadArchiveCommand(),\n\t\t\t\tcmd.GitReceivePackCommand(),\n\t\t\t\tcmd.RepoCommand(),\n\t\t\t\tcmd.SettingsCommand(),\n\t\t\t\tcmd.UserCommand(),\n\t\t\t\tcmd.InfoCommand(),\n\t\t\t\tcmd.PubkeyCommand(),\n\t\t\t\tcmd.SetUsernameCommand(),\n\t\t\t\tcmd.JWTCommand(),\n\t\t\t\tcmd.TokenCommand(),\n\t\t\t)\n\n\t\t\tif cfg.LFS.Enabled {\n\t\t\t\trootCmd.AddCommand(\n\t\t\t\t\tcmd.GitLFSAuthenticateCommand(),\n\t\t\t\t)\n\n\t\t\t\tif cfg.LFS.SSHEnabled {\n\t\t\t\t\trootCmd.AddCommand(\n\t\t\t\t\t\tcmd.GitLFSTransfer(),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trootCmd.SetArgs(args)\n\t\t\tif len(args) == 0 {\n\t\t\t\t// otherwise it'll default to os.Args, which is not what we want.\n\t\t\t\trootCmd.SetArgs([]string{\"--help\"})\n\t\t\t}\n\t\t\trootCmd.SetIn(s)\n\t\t\trootCmd.SetOut(s)\n\t\t\trootCmd.SetErr(s.Stderr())\n\t\t\trootCmd.SetContext(ctx)\n\n\t\t\tif err := rootCmd.ExecuteContext(ctx); err != nil {\n\t\t\t\ts.Exit(1) // nolint: errcheck\n\t\t\t\treturn\n\t\t\t}\n\t\t}()\n\t\tsh(s)\n\t}\n}\n\n// LoggingMiddleware logs the ssh connection and command.\nfunc LoggingMiddleware(sh ssh.Handler) ssh.Handler {\n\treturn func(s ssh.Session) {\n\t\tctx := s.Context()\n\t\tlogger := log.FromContext(ctx).WithPrefix(\"ssh\")\n\t\tct := time.Now()\n\t\thpk := sshutils.MarshalAuthorizedKey(s.PublicKey())\n\t\tptyReq, _, isPty := s.Pty()\n\t\taddr := s.RemoteAddr().String()\n\t\tuser := proto.UserFromContext(ctx)\n\t\tlogArgs := []interface{}{\n\t\t\t\"addr\",\n\t\t\taddr,\n\t\t\t\"cmd\",\n\t\t\ts.Command(),\n\t\t}\n\n\t\tif user != nil {\n\t\t\tlogArgs = append([]interface{}{\n\t\t\t\t\"username\",\n\t\t\t\tuser.Username(),\n\t\t\t}, logArgs...)\n\t\t}\n\n\t\tif isPty {\n\t\t\tlogArgs = []interface{}{\n\t\t\t\t\"term\", ptyReq.Term,\n\t\t\t\t\"width\", ptyReq.Window.Width,\n\t\t\t\t\"height\", ptyReq.Window.Height,\n\t\t\t}\n\t\t}\n\n\t\tif config.IsVerbose() {\n\t\t\tlogArgs = append(logArgs,\n\t\t\t\t\"key\", hpk,\n\t\t\t\t\"envs\", s.Environ(),\n\t\t\t)\n\t\t}\n\n\t\tmsg := fmt.Sprintf(\"user %q\", s.User())\n\t\tlogger.Debug(msg+\" connected\", logArgs...)\n\t\tsh(s)\n\t\tlogger.Debug(msg+\" disconnected\", append(logArgs, \"duration\", time.Since(ct))...)\n\t}\n}\n", "package ssh\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/keygen\"\n\t\"github.com/charmbracelet/log\"\n\t\"github.com/charmbracelet/soft-serve/server/backend\"\n\t\"github.com/charmbracelet/soft-serve/server/config\"\n\t\"github.com/charmbracelet/soft-serve/server/db\"\n\t\"github.com/charmbracelet/soft-serve/server/proto\"\n\t\"github.com/charmbracelet/soft-serve/server/store\"\n\t\"github.com/charmbracelet/ssh\"\n\t\"github.com/charmbracelet/wish\"\n\tbm \"github.com/charmbracelet/wish/bubbletea\"\n\trm \"github.com/charmbracelet/wish/recover\"\n\t\"github.com/muesli/termenv\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promauto\"\n\tgossh \"golang.org/x/crypto/ssh\"\n)\n\nvar (\n\tpublicKeyCounter = promauto.NewCounterVec(prometheus.CounterOpts{\n\t\tNamespace: \"soft_serve\",\n\t\tSubsystem: \"ssh\",\n\t\tName:      \"public_key_auth_total\",\n\t\tHelp:      \"The total number of public key auth requests\",\n\t}, []string{\"allowed\"})\n\n\tkeyboardInteractiveCounter = promauto.NewCounterVec(prometheus.CounterOpts{\n\t\tNamespace: \"soft_serve\",\n\t\tSubsystem: \"ssh\",\n\t\tName:      \"keyboard_interactive_auth_total\",\n\t\tHelp:      \"The total number of keyboard interactive auth requests\",\n\t}, []string{\"allowed\"})\n)\n\n// SSHServer is a SSH server that implements the git protocol.\ntype SSHServer struct { // nolint: revive\n\tsrv    *ssh.Server\n\tcfg    *config.Config\n\tbe     *backend.Backend\n\tctx    context.Context\n\tlogger *log.Logger\n}\n\n// NewSSHServer returns a new SSHServer.\nfunc NewSSHServer(ctx context.Context) (*SSHServer, error) {\n\tcfg := config.FromContext(ctx)\n\tlogger := log.FromContext(ctx).WithPrefix(\"ssh\")\n\tdbx := db.FromContext(ctx)\n\tdatastore := store.FromContext(ctx)\n\tbe := backend.FromContext(ctx)\n\n\tvar err error\n\ts := &SSHServer{\n\t\tcfg:    cfg,\n\t\tctx:    ctx,\n\t\tbe:     be,\n\t\tlogger: logger,\n\t}\n\n\tmw := []wish.Middleware{\n\t\trm.MiddlewareWithLogger(\n\t\t\tlogger,\n\t\t\t// BubbleTea middleware.\n\t\t\tbm.MiddlewareWithProgramHandler(SessionHandler, termenv.ANSI256),\n\t\t\t// CLI middleware.\n\t\t\tCommandMiddleware,\n\t\t\t// Logging middleware.\n\t\t\tLoggingMiddleware,\n\t\t\t// Context middleware.\n\t\t\tContextMiddleware(cfg, dbx, datastore, be, logger),\n\t\t\t// Authentication middleware.\n\t\t\t// gossh.PublicKeyHandler doesn't guarantee that the public key\n\t\t\t// is in fact the one used for authentication, so we need to\n\t\t\t// check it again here.\n\t\t\tAuthenticationMiddleware,\n\t\t),\n\t}\n\n\ts.srv, err = wish.NewServer(\n\t\tssh.PublicKeyAuth(s.PublicKeyHandler),\n\t\tssh.KeyboardInteractiveAuth(s.KeyboardInteractiveHandler),\n\t\twish.WithAddress(cfg.SSH.ListenAddr),\n\t\twish.WithHostKeyPath(cfg.SSH.KeyPath),\n\t\twish.WithMiddleware(mw...),\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif config.IsDebug() {\n\t\ts.srv.ServerConfigCallback = func(ctx ssh.Context) *gossh.ServerConfig {\n\t\t\treturn &gossh.ServerConfig{\n\t\t\t\tAuthLogCallback: func(conn gossh.ConnMetadata, method string, err error) {\n\t\t\t\t\tlogger.Debug(\"authentication\", \"user\", conn.User(), \"method\", method, \"err\", err)\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tif cfg.SSH.MaxTimeout > 0 {\n\t\ts.srv.MaxTimeout = time.Duration(cfg.SSH.MaxTimeout) * time.Second\n\t}\n\n\tif cfg.SSH.IdleTimeout > 0 {\n\t\ts.srv.IdleTimeout = time.Duration(cfg.SSH.IdleTimeout) * time.Second\n\t}\n\n\t// Create client ssh key\n\tif _, err := os.Stat(cfg.SSH.ClientKeyPath); err != nil && os.IsNotExist(err) {\n\t\t_, err := keygen.New(cfg.SSH.ClientKeyPath, keygen.WithKeyType(keygen.Ed25519), keygen.WithWrite())\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"client ssh key: %w\", err)\n\t\t}\n\t}\n\n\treturn s, nil\n}\n\n// ListenAndServe starts the SSH server.\nfunc (s *SSHServer) ListenAndServe() error {\n\treturn s.srv.ListenAndServe()\n}\n\n// Serve starts the SSH server on the given net.Listener.\nfunc (s *SSHServer) Serve(l net.Listener) error {\n\treturn s.srv.Serve(l)\n}\n\n// Close closes the SSH server.\nfunc (s *SSHServer) Close() error {\n\treturn s.srv.Close()\n}\n\n// Shutdown gracefully shuts down the SSH server.\nfunc (s *SSHServer) Shutdown(ctx context.Context) error {\n\treturn s.srv.Shutdown(ctx)\n}\n\nfunc initializePermissions(ctx ssh.Context) {\n\tperms := ctx.Permissions()\n\tif perms == nil || perms.Permissions == nil {\n\t\tperms = &ssh.Permissions{Permissions: &gossh.Permissions{}}\n\t}\n\tif perms.Extensions == nil {\n\t\tperms.Extensions = make(map[string]string)\n\t}\n\tif perms.Permissions.Extensions == nil {\n\t\tperms.Permissions.Extensions = make(map[string]string)\n\t}\n}\n\n// PublicKeyAuthHandler handles public key authentication.\nfunc (s *SSHServer) PublicKeyHandler(ctx ssh.Context, pk ssh.PublicKey) (allowed bool) {\n\tif pk == nil {\n\t\treturn false\n\t}\n\n\tdefer func(allowed *bool) {\n\t\tpublicKeyCounter.WithLabelValues(strconv.FormatBool(*allowed)).Inc()\n\t}(&allowed)\n\n\tuser, _ := s.be.UserByPublicKey(ctx, pk)\n\tif user != nil {\n\t\tctx.SetValue(proto.ContextKeyUser, user)\n\t\tallowed = true\n\n\t\t// XXX: store the first \"approved\" public-key fingerprint in the\n\t\t// permissions block to use for authentication later.\n\t\tinitializePermissions(ctx)\n\t\tperms := ctx.Permissions()\n\n\t\t// Set the public key fingerprint to be used for authentication.\n\t\tperms.Extensions[\"pubkey-fp\"] = gossh.FingerprintSHA256(pk)\n\t\tctx.SetValue(ssh.ContextKeyPermissions, perms)\n\t}\n\n\treturn\n}\n\n// KeyboardInteractiveHandler handles keyboard interactive authentication.\n// This is used after all public key authentication has failed.\nfunc (s *SSHServer) KeyboardInteractiveHandler(ctx ssh.Context, _ gossh.KeyboardInteractiveChallenge) bool {\n\tac := s.be.AllowKeyless(ctx)\n\tkeyboardInteractiveCounter.WithLabelValues(strconv.FormatBool(ac)).Inc()\n\n\t// If we're allowing keyless access, reset the public key fingerprint\n\tif ac {\n\t\tinitializePermissions(ctx)\n\t\tperms := ctx.Permissions()\n\n\t\t// XXX: reset the public-key fingerprint. This is used to validate the\n\t\t// public key being used to authenticate.\n\t\tperms.Extensions[\"pubkey-fp\"] = \"\"\n\t\tctx.SetValue(ssh.ContextKeyPermissions, perms)\n\t}\n\treturn ac\n}\n"], "filenames": ["server/ssh/middleware.go", "server/ssh/ssh.go"], "buggy_code_start_loc": [15, 79], "buggy_code_end_loc": [19, 156], "fixing_code_start_loc": [16, 80], "fixing_code_end_loc": [54, 205], "type": "CWE-287", "message": "Soft Serve is a self-hostable Git server for the command line. Prior to version 0.6.2, a security vulnerability in Soft Serve could allow an unauthenticated, remote attacker to bypass public key authentication when keyboard-interactive SSH authentication is active, through the `allow-keyless` setting, and the public key requires additional client-side verification for example using FIDO2 or GPG. This is due to insufficient validation procedures of the public key step during SSH request handshake, granting unauthorized access if the keyboard-interaction mode is utilized. An attacker could exploit this vulnerability by presenting manipulated SSH requests using keyboard-interactive authentication mode. This could potentially result in unauthorized access to the Soft Serve. Users should upgrade to the latest Soft Serve version `v0.6.2` to receive the patch for this issue. To workaround this vulnerability without upgrading, users can temporarily disable Keyboard-Interactive SSH Authentication using the `allow-keyless` setting.", "other": {"cve": {"id": "CVE-2023-43809", "sourceIdentifier": "security-advisories@github.com", "published": "2023-10-04T21:15:10.280", "lastModified": "2023-10-10T20:12:47.170", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Soft Serve is a self-hostable Git server for the command line. Prior to version 0.6.2, a security vulnerability in Soft Serve could allow an unauthenticated, remote attacker to bypass public key authentication when keyboard-interactive SSH authentication is active, through the `allow-keyless` setting, and the public key requires additional client-side verification for example using FIDO2 or GPG. This is due to insufficient validation procedures of the public key step during SSH request handshake, granting unauthorized access if the keyboard-interaction mode is utilized. An attacker could exploit this vulnerability by presenting manipulated SSH requests using keyboard-interactive authentication mode. This could potentially result in unauthorized access to the Soft Serve. Users should upgrade to the latest Soft Serve version `v0.6.2` to receive the patch for this issue. To workaround this vulnerability without upgrading, users can temporarily disable Keyboard-Interactive SSH Authentication using the `allow-keyless` setting."}, {"lang": "es", "value": "Soft Serve es un servidor Git autohospedable para la l\u00ednea de comandos. Antes de la versi\u00f3n 0.6.2, una vulnerabilidad de seguridad en Soft Serve podr\u00eda permitir a un atacante remoto no autenticado eludir la autenticaci\u00f3n de clave p\u00fablica cuando la autenticaci\u00f3n SSH interactiva con teclado est\u00e1 activa, a trav\u00e9s de la configuraci\u00f3n \"allow-keyless\", y la clave p\u00fablica requiere verificaci\u00f3n adicional del lado del cliente, por ejemplo, utilizando FIDO2 o GPG. Esto se debe a procedimientos de validaci\u00f3n insuficientes del paso de la clave p\u00fablica durante el protocolo de enlace de solicitud SSH, lo que otorga acceso no autorizado si se utiliza el modo de interacci\u00f3n con el teclado. Un atacante podr\u00eda aprovechar esta vulnerabilidad presentando solicitudes SSH manipuladas utilizando el modo de autenticaci\u00f3n interactivo con teclado. Potencialmente, esto podr\u00eda resultar en un acceso no autorizado al Soft Serve. Los usuarios deben actualizar a la \u00faltima versi\u00f3n de Soft Serve `v0.6.2` para recibir el parche para este problema. Como workaround esta vulnerabilidad sin realizar una actualizaci\u00f3n, los usuarios pueden desactivar temporalmente la autenticaci\u00f3n SSH interactiva con teclado utilizando la configuraci\u00f3n \"allow-keyless\"."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:charm:soft_serve:*:*:*:*:*:go:*:*", "versionEndExcluding": "0.6.2", "matchCriteriaId": "962411DB-9A36-4D48-B5E5-BAC38703E87D"}]}]}], "references": [{"url": "https://github.com/charmbracelet/soft-serve/commit/407c4ec72d1006cee1ff8c1775e5bcc091c2bc89", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/charmbracelet/soft-serve/issues/389", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking"]}, {"url": "https://github.com/charmbracelet/soft-serve/releases/tag/v0.6.2", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/charmbracelet/soft-serve/security/advisories/GHSA-mc97-99j4-vm2v", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/charmbracelet/soft-serve/commit/407c4ec72d1006cee1ff8c1775e5bcc091c2bc89"}}