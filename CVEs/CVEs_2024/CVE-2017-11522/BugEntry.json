{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            PPPP   N   N   GGGG                              %\n%                            P   P  NN  N  G                                  %\n%                            PPPP   N N N  G  GG                              %\n%                            P      N  NN  G   G                              %\n%                            P      N   N   GGG                               %\n%                                                                             %\n%                                                                             %\n%              Read/Write Portable Network Graphics Image Format              %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                           Glenn Randers-Pehrson                             %\n%                               November 1997                                 %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\n#define IM\n\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/histogram.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/layer.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/MagickCore.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/utility.h\"\n#if defined(MAGICKCORE_PNG_DELEGATE)\n\n/* Suppress libpng pedantic warnings that were added in\n * libpng-1.2.41 and libpng-1.4.0.  If you are working on\n * migration to libpng-1.5, remove these defines and then\n * fix any code that generates warnings.\n */\n/* #define PNG_DEPRECATED   Use of this function is deprecated */\n/* #define PNG_USE_RESULT   The result of this function must be checked */\n/* #define PNG_NORETURN     This function does not return */\n/* #define PNG_ALLOCATED    The result of the function is new memory */\n/* #define PNG_DEPSTRUCT    Access to this struct member is deprecated */\n\n/* PNG_PTR_NORETURN does not work on some platforms, in libpng-1.5.x */\n#define PNG_PTR_NORETURN\n\n#include \"png.h\"\n#include \"zlib.h\"\n\f\n/* ImageMagick differences */\n#define first_scene scene\n\n#if PNG_LIBPNG_VER > 10011\n/*\n  Optional declarations. Define or undefine them as you like.\n*/\n/* #define PNG_DEBUG -- turning this on breaks VisualC compiling */\n\n/*\n  Features under construction.  Define these to work on them.\n*/\n#undef MNG_OBJECT_BUFFERS\n#undef MNG_BASI_SUPPORTED\n#define MNG_COALESCE_LAYERS /* In 5.4.4, this interfered with MMAP'ed files. */\n#define MNG_INSERT_LAYERS   /* Troublesome, but seem to work as of 5.4.4 */\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n#  define JNG_SUPPORTED /* Not finished as of 5.5.2.  See \"To do\" comments. */\n#endif\n#if !defined(RGBColorMatchExact)\n#define IsPNGColorEqual(color,target) \\\n       (((color).red == (target).red) && \\\n        ((color).green == (target).green) && \\\n        ((color).blue == (target).blue))\n#endif\n\n/* Table of recognized sRGB ICC profiles */\nstruct sRGB_info_struct\n{\n    png_uint_32 len;\n    png_uint_32 crc;\n    png_byte intent;\n};\n\nconst struct sRGB_info_struct sRGB_info[] =\n{\n    /* ICC v2 perceptual sRGB_IEC61966-2-1_black_scaled.icc */\n    { 3048, 0x3b8772b9UL, 0},\n\n    /* ICC v2 relative sRGB_IEC61966-2-1_no_black_scaling.icc */\n    { 3052, 0x427ebb21UL, 1},\n\n    /* ICC v4 perceptual sRGB_v4_ICC_preference_displayclass.icc */\n    {60988, 0x306fd8aeUL, 0},\n\n    /* ICC v4 perceptual sRGB_v4_ICC_preference.icc perceptual */\n     {60960, 0xbbef7812UL, 0},\n\n    /* HP? sRGB v2 media-relative sRGB_IEC61966-2-1_noBPC.icc */\n     { 3024, 0x5d5129ceUL, 1},\n\n     /* HP-Microsoft sRGB v2 perceptual */\n     { 3144, 0x182ea552UL, 0},\n\n     /* HP-Microsoft sRGB v2 media-relative */\n     { 3144, 0xf29e526dUL, 1},\n\n     /* Facebook's \"2012/01/25 03:41:57\", 524, \"TINYsRGB.icc\" */\n     {  524, 0xd4938c39UL, 0},\n\n     /* \"2012/11/28 22:35:21\", 3212, \"Argyll_sRGB.icm\") */\n     { 3212, 0x034af5a1UL, 0},\n\n     /* Not recognized */\n     {    0, 0x00000000UL, 0},\n};\n\n/* Macros for left-bit-replication to ensure that pixels\n * and PixelInfos all have the same image->depth, and for use\n * in PNG8 quantization.\n */\n\n/* LBR01: Replicate top bit */\n\n#define LBR01PacketRed(pixelpacket) \\\n     (pixelpacket).red=(ScaleQuantumToChar((pixelpacket).red) < 0x10 ? \\\n        0 : QuantumRange);\n\n#define LBR01PacketGreen(pixelpacket) \\\n     (pixelpacket).green=(ScaleQuantumToChar((pixelpacket).green) < 0x10 ? \\\n        0 : QuantumRange);\n\n#define LBR01PacketBlue(pixelpacket) \\\n     (pixelpacket).blue=(ScaleQuantumToChar((pixelpacket).blue) < 0x10 ? \\\n        0 : QuantumRange);\n\n#define LBR01PacketAlpha(pixelpacket) \\\n     (pixelpacket).alpha=(ScaleQuantumToChar((pixelpacket).alpha) < 0x10 ? \\\n        0 : QuantumRange);\n\n#define LBR01PacketRGB(pixelpacket) \\\n        { \\\n        LBR01PacketRed((pixelpacket)); \\\n        LBR01PacketGreen((pixelpacket)); \\\n        LBR01PacketBlue((pixelpacket)); \\\n        }\n\n#define LBR01PacketRGBO(pixelpacket) \\\n        { \\\n        LBR01PacketRGB((pixelpacket)); \\\n        LBR01PacketAlpha((pixelpacket)); \\\n        }\n\n#define LBR01PixelRed(pixel) \\\n        (SetPixelRed(image, \\\n        ScaleQuantumToChar(GetPixelRed(image,(pixel))) < 0x10 ? \\\n        0 : QuantumRange,(pixel)));\n\n#define LBR01PixelGreen(pixel) \\\n        (SetPixelGreen(image, \\\n        ScaleQuantumToChar(GetPixelGreen(image,(pixel))) < 0x10 ? \\\n        0 : QuantumRange,(pixel)));\n\n#define LBR01PixelBlue(pixel) \\\n        (SetPixelBlue(image, \\\n        ScaleQuantumToChar(GetPixelBlue(image,(pixel))) < 0x10 ? \\\n        0 : QuantumRange,(pixel)));\n\n#define LBR01PixelAlpha(pixel) \\\n        (SetPixelAlpha(image, \\\n        ScaleQuantumToChar(GetPixelAlpha(image,(pixel))) < 0x10 ? \\\n        0 : QuantumRange,(pixel)));\n\n#define LBR01PixelRGB(pixel) \\\n        { \\\n        LBR01PixelRed((pixel)); \\\n        LBR01PixelGreen((pixel)); \\\n        LBR01PixelBlue((pixel)); \\\n        }\n\n#define LBR01PixelRGBA(pixel) \\\n        { \\\n        LBR01PixelRGB((pixel)); \\\n        LBR01PixelAlpha((pixel)); \\\n        }\n\n/* LBR02: Replicate top 2 bits */\n\n#define LBR02PacketRed(pixelpacket) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar((pixelpacket).red) & 0xc0; \\\n     (pixelpacket).red=ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 2) | (lbr_bits >> 4) | (lbr_bits >> 6))); \\\n   }\n#define LBR02PacketGreen(pixelpacket) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar((pixelpacket).green) & 0xc0; \\\n     (pixelpacket).green=ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 2) | (lbr_bits >> 4) | (lbr_bits >> 6))); \\\n   }\n#define LBR02PacketBlue(pixelpacket) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar((pixelpacket).blue) & 0xc0; \\\n     (pixelpacket).blue=ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 2) | (lbr_bits >> 4) | (lbr_bits >> 6))); \\\n   }\n#define LBR02PacketAlpha(pixelpacket) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar((pixelpacket).alpha) & 0xc0; \\\n     (pixelpacket).alpha=ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 2) | (lbr_bits >> 4) | (lbr_bits >> 6))); \\\n   }\n\n#define LBR02PacketRGB(pixelpacket) \\\n        { \\\n        LBR02PacketRed((pixelpacket)); \\\n        LBR02PacketGreen((pixelpacket)); \\\n        LBR02PacketBlue((pixelpacket)); \\\n        }\n\n#define LBR02PacketRGBO(pixelpacket) \\\n        { \\\n        LBR02PacketRGB((pixelpacket)); \\\n        LBR02PacketAlpha((pixelpacket)); \\\n        }\n\n#define LBR02PixelRed(pixel) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar(GetPixelRed(image,(pixel))) \\\n       & 0xc0; \\\n     SetPixelRed(image, ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 2) | (lbr_bits >> 4) | (lbr_bits >> 6))), \\\n       (pixel)); \\\n   }\n#define LBR02PixelGreen(pixel) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar(GetPixelGreen(image,(pixel)))\\\n       & 0xc0; \\\n     SetPixelGreen(image, ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 2) | (lbr_bits >> 4) | (lbr_bits >> 6))), \\\n       (pixel)); \\\n   }\n#define LBR02PixelBlue(pixel) \\\n   { \\\n     unsigned char lbr_bits= \\\n       ScaleQuantumToChar(GetPixelBlue(image,(pixel))) & 0xc0; \\\n     SetPixelBlue(image, ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 2) | (lbr_bits >> 4) | (lbr_bits >> 6))), \\\n       (pixel)); \\\n   }\n#define LBR02PixelAlpha(pixel) \\\n   { \\\n     unsigned char lbr_bits= \\\n       ScaleQuantumToChar(GetPixelAlpha(image,(pixel))) & 0xc0; \\\n     SetPixelAlpha(image, ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 2) | (lbr_bits >> 4) | (lbr_bits >> 6))), \\\n       (pixel) ); \\\n   }\n\n#define LBR02PixelRGB(pixel) \\\n        { \\\n        LBR02PixelRed((pixel)); \\\n        LBR02PixelGreen((pixel)); \\\n        LBR02PixelBlue((pixel)); \\\n        }\n\n#define LBR02PixelRGBA(pixel) \\\n        { \\\n        LBR02PixelRGB((pixel)); \\\n        LBR02PixelAlpha((pixel)); \\\n        }\n\n/* LBR03: Replicate top 3 bits (only used with opaque pixels during\n   PNG8 quantization) */\n\n#define LBR03PacketRed(pixelpacket) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar((pixelpacket).red) & 0xe0; \\\n     (pixelpacket).red=ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 3) | (lbr_bits >> 6))); \\\n   }\n#define LBR03PacketGreen(pixelpacket) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar((pixelpacket).green) & 0xe0; \\\n     (pixelpacket).green=ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 3) | (lbr_bits >> 6))); \\\n   }\n#define LBR03PacketBlue(pixelpacket) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar((pixelpacket).blue) & 0xe0; \\\n     (pixelpacket).blue=ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 3) | (lbr_bits >> 6))); \\\n   }\n\n#define LBR03PacketRGB(pixelpacket) \\\n        { \\\n        LBR03PacketRed((pixelpacket)); \\\n        LBR03PacketGreen((pixelpacket)); \\\n        LBR03PacketBlue((pixelpacket)); \\\n        }\n\n#define LBR03PixelRed(pixel) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar(GetPixelRed(image,(pixel))) \\\n       & 0xe0; \\\n     SetPixelRed(image, ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 3) | (lbr_bits >> 6))), (pixel)); \\\n   }\n#define LBR03Green(pixel) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar(GetPixelGreen(image,(pixel)))\\\n       & 0xe0; \\\n     SetPixelGreen(image, ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 3) | (lbr_bits >> 6))), (pixel)); \\\n   }\n#define LBR03Blue(pixel) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar(GetPixelBlue(image,(pixel))) \\\n       & 0xe0; \\\n     SetPixelBlue(image, ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 3) | (lbr_bits >> 6))), (pixel)); \\\n   }\n\n#define LBR03RGB(pixel) \\\n        { \\\n        LBR03PixelRed((pixel)); \\\n        LBR03Green((pixel)); \\\n        LBR03Blue((pixel)); \\\n        }\n\n/* LBR04: Replicate top 4 bits */\n\n#define LBR04PacketRed(pixelpacket) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar((pixelpacket).red) & 0xf0; \\\n     (pixelpacket).red=ScaleCharToQuantum((lbr_bits | (lbr_bits >> 4))); \\\n   }\n#define LBR04PacketGreen(pixelpacket) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar((pixelpacket).green) & 0xf0; \\\n     (pixelpacket).green=ScaleCharToQuantum((lbr_bits | (lbr_bits >> 4))); \\\n   }\n#define LBR04PacketBlue(pixelpacket) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar((pixelpacket).blue) & 0xf0; \\\n     (pixelpacket).blue=ScaleCharToQuantum((lbr_bits | (lbr_bits >> 4))); \\\n   }\n#define LBR04PacketAlpha(pixelpacket) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar((pixelpacket).alpha) & 0xf0; \\\n     (pixelpacket).alpha=ScaleCharToQuantum((lbr_bits | (lbr_bits >> 4))); \\\n   }\n\n#define LBR04PacketRGB(pixelpacket) \\\n        { \\\n        LBR04PacketRed((pixelpacket)); \\\n        LBR04PacketGreen((pixelpacket)); \\\n        LBR04PacketBlue((pixelpacket)); \\\n        }\n\n#define LBR04PacketRGBO(pixelpacket) \\\n        { \\\n        LBR04PacketRGB((pixelpacket)); \\\n        LBR04PacketAlpha((pixelpacket)); \\\n        }\n\n#define LBR04PixelRed(pixel) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar(GetPixelRed(image,(pixel))) \\\n       & 0xf0; \\\n     SetPixelRed(image,\\\n       ScaleCharToQuantum((lbr_bits | (lbr_bits >> 4))), (pixel)); \\\n   }\n#define LBR04PixelGreen(pixel) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar(GetPixelGreen(image,(pixel)))\\\n       & 0xf0; \\\n     SetPixelGreen(image,\\\n       ScaleCharToQuantum((lbr_bits | (lbr_bits >> 4))), (pixel)); \\\n   }\n#define LBR04PixelBlue(pixel) \\\n   { \\\n     unsigned char lbr_bits= \\\n       ScaleQuantumToChar(GetPixelBlue(image,(pixel))) & 0xf0; \\\n     SetPixelBlue(image,\\\n       ScaleCharToQuantum((lbr_bits | (lbr_bits >> 4))), (pixel)); \\\n   }\n#define LBR04PixelAlpha(pixel) \\\n   { \\\n     unsigned char lbr_bits= \\\n       ScaleQuantumToChar(GetPixelAlpha(image,(pixel))) & 0xf0; \\\n     SetPixelAlpha(image,\\\n       ScaleCharToQuantum((lbr_bits | (lbr_bits >> 4))), (pixel)); \\\n   }\n\n#define LBR04PixelRGB(pixel) \\\n        { \\\n        LBR04PixelRed((pixel)); \\\n        LBR04PixelGreen((pixel)); \\\n        LBR04PixelBlue((pixel)); \\\n        }\n\n#define LBR04PixelRGBA(pixel) \\\n        { \\\n        LBR04PixelRGB((pixel)); \\\n        LBR04PixelAlpha((pixel)); \\\n        }\n\n/*\n  Establish thread safety.\n  setjmp/longjmp is claimed to be safe on these platforms:\n  setjmp/longjmp is alleged to be unsafe on these platforms:\n*/\n#ifdef PNG_SETJMP_SUPPORTED\n# ifndef IMPNG_SETJMP_IS_THREAD_SAFE\n#   define IMPNG_SETJMP_NOT_THREAD_SAFE\n# endif\n\n# ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\nstatic SemaphoreInfo\n  *ping_semaphore = (SemaphoreInfo *) NULL;\n# endif\n#endif\n\n/*\n  This temporary until I set up malloc'ed object attributes array.\n  Recompile with MNG_MAX_OBJECTS=65536L to avoid this limit but\n  waste more memory.\n*/\n#define MNG_MAX_OBJECTS 256\n\n/*\n  If this not defined, spec is interpreted strictly.  If it is\n  defined, an attempt will be made to recover from some errors,\n  including\n      o global PLTE too short\n*/\n#undef MNG_LOOSE\n\n/*\n  Don't try to define PNG_MNG_FEATURES_SUPPORTED here.  Make sure\n  it's defined in libpng/pngconf.h, version 1.0.9 or later.  It won't work\n  with earlier versions of libpng.  From libpng-1.0.3a to libpng-1.0.8,\n  PNG_READ|WRITE_EMPTY_PLTE were used but those have been deprecated in\n  libpng in favor of PNG_MNG_FEATURES_SUPPORTED, so we set them here.\n  PNG_MNG_FEATURES_SUPPORTED is disabled by default in libpng-1.0.9 and\n  will be enabled by default in libpng-1.2.0.\n*/\n#ifdef PNG_MNG_FEATURES_SUPPORTED\n#  ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n#    define PNG_READ_EMPTY_PLTE_SUPPORTED\n#  endif\n#  ifndef PNG_WRITE_EMPTY_PLTE_SUPPORTED\n#    define PNG_WRITE_EMPTY_PLTE_SUPPORTED\n#  endif\n#endif\n\n/*\n  Maximum valid size_t in PNG/MNG chunks is (2^31)-1\n  This macro is only defined in libpng-1.0.3 and later.\n  Previously it was PNG_MAX_UINT but that was deprecated in libpng-1.2.6\n*/\n#ifndef PNG_UINT_31_MAX\n#define PNG_UINT_31_MAX (png_uint_32) 0x7fffffffL\n#endif\n\n/*\n  Constant strings for known chunk types.  If you need to add a chunk,\n  add a string holding the name here.   To make the code more\n  portable, we use ASCII numbers like this, not characters.\n*/\n\nstatic const png_byte mng_MHDR[5]={ 77,  72,  68,  82, (png_byte) '\\0'};\nstatic const png_byte mng_BACK[5]={ 66,  65,  67,  75, (png_byte) '\\0'};\nstatic const png_byte mng_BASI[5]={ 66,  65,  83,  73, (png_byte) '\\0'};\nstatic const png_byte mng_CLIP[5]={ 67,  76,  73,  80, (png_byte) '\\0'};\nstatic const png_byte mng_CLON[5]={ 67,  76,  79,  78, (png_byte) '\\0'};\nstatic const png_byte mng_DEFI[5]={ 68,  69,  70,  73, (png_byte) '\\0'};\nstatic const png_byte mng_DHDR[5]={ 68,  72,  68,  82, (png_byte) '\\0'};\nstatic const png_byte mng_DISC[5]={ 68,  73,  83,  67, (png_byte) '\\0'};\nstatic const png_byte mng_ENDL[5]={ 69,  78,  68,  76, (png_byte) '\\0'};\nstatic const png_byte mng_FRAM[5]={ 70,  82,  65,  77, (png_byte) '\\0'};\nstatic const png_byte mng_IEND[5]={ 73,  69,  78,  68, (png_byte) '\\0'};\nstatic const png_byte mng_IHDR[5]={ 73,  72,  68,  82, (png_byte) '\\0'};\nstatic const png_byte mng_JHDR[5]={ 74,  72,  68,  82, (png_byte) '\\0'};\nstatic const png_byte mng_LOOP[5]={ 76,  79,  79,  80, (png_byte) '\\0'};\nstatic const png_byte mng_MAGN[5]={ 77,  65,  71,  78, (png_byte) '\\0'};\nstatic const png_byte mng_MEND[5]={ 77,  69,  78,  68, (png_byte) '\\0'};\nstatic const png_byte mng_MOVE[5]={ 77,  79,  86,  69, (png_byte) '\\0'};\nstatic const png_byte mng_PAST[5]={ 80,  65,  83,  84, (png_byte) '\\0'};\nstatic const png_byte mng_PLTE[5]={ 80,  76,  84,  69, (png_byte) '\\0'};\nstatic const png_byte mng_SAVE[5]={ 83,  65,  86,  69, (png_byte) '\\0'};\nstatic const png_byte mng_SEEK[5]={ 83,  69,  69,  75, (png_byte) '\\0'};\nstatic const png_byte mng_SHOW[5]={ 83,  72,  79,  87, (png_byte) '\\0'};\nstatic const png_byte mng_TERM[5]={ 84,  69,  82,  77, (png_byte) '\\0'};\nstatic const png_byte mng_bKGD[5]={ 98,  75,  71,  68, (png_byte) '\\0'};\nstatic const png_byte mng_caNv[5]={ 99,  97,  78, 118, (png_byte) '\\0'};\nstatic const png_byte mng_cHRM[5]={ 99,  72,  82,  77, (png_byte) '\\0'};\nstatic const png_byte mng_eXIf[5]={101,  88,  73, 102, (png_byte) '\\0'};\nstatic const png_byte mng_gAMA[5]={103,  65,  77,  65, (png_byte) '\\0'};\nstatic const png_byte mng_iCCP[5]={105,  67,  67,  80, (png_byte) '\\0'};\nstatic const png_byte mng_nEED[5]={110,  69,  69,  68, (png_byte) '\\0'};\nstatic const png_byte mng_pHYg[5]={112,  72,  89, 103, (png_byte) '\\0'};\nstatic const png_byte mng_vpAg[5]={118, 112,  65, 103, (png_byte) '\\0'};\nstatic const png_byte mng_pHYs[5]={112,  72,  89, 115, (png_byte) '\\0'};\nstatic const png_byte mng_sBIT[5]={115,  66,  73,  84, (png_byte) '\\0'};\nstatic const png_byte mng_sRGB[5]={115,  82,  71,  66, (png_byte) '\\0'};\nstatic const png_byte mng_tRNS[5]={116,  82,  78,  83, (png_byte) '\\0'};\n\n#if defined(JNG_SUPPORTED)\nstatic const png_byte mng_IDAT[5]={ 73,  68,  65,  84, (png_byte) '\\0'};\nstatic const png_byte mng_JDAT[5]={ 74,  68,  65,  84, (png_byte) '\\0'};\nstatic const png_byte mng_JDAA[5]={ 74,  68,  65,  65, (png_byte) '\\0'};\nstatic const png_byte mng_JdAA[5]={ 74, 100,  65,  65, (png_byte) '\\0'};\nstatic const png_byte mng_JSEP[5]={ 74,  83,  69,  80, (png_byte) '\\0'};\nstatic const png_byte mng_oFFs[5]={111,  70,  70, 115, (png_byte) '\\0'};\n#endif\n\n#if 0\n/* Other known chunks that are not yet supported by ImageMagick: */\nstatic const png_byte mng_hIST[5]={104,  73,  83,  84, (png_byte) '\\0'};\nstatic const png_byte mng_iTXt[5]={105,  84,  88, 116, (png_byte) '\\0'};\nstatic const png_byte mng_sPLT[5]={115,  80,  76,  84, (png_byte) '\\0'};\nstatic const png_byte mng_sTER[5]={115,  84,  69,  82, (png_byte) '\\0'};\nstatic const png_byte mng_tEXt[5]={116,  69,  88, 116, (png_byte) '\\0'};\nstatic const png_byte mng_tIME[5]={116,  73,  77,  69, (png_byte) '\\0'};\nstatic const png_byte mng_zTXt[5]={122,  84,  88, 116, (png_byte) '\\0'};\n#endif\n\ntypedef struct _MngBox\n{\n  long\n    left,\n    right,\n    top,\n    bottom;\n} MngBox;\n\ntypedef struct _MngPair\n{\n  volatile long\n    a,\n    b;\n} MngPair;\n\n#ifdef MNG_OBJECT_BUFFERS\ntypedef struct _MngBuffer\n{\n\n  size_t\n    height,\n    width;\n\n  Image\n    *image;\n\n  png_color\n    plte[256];\n\n  int\n    reference_count;\n\n  unsigned char\n    alpha_sample_depth,\n    compression_method,\n    color_type,\n    concrete,\n    filter_method,\n    frozen,\n    image_type,\n    interlace_method,\n    pixel_sample_depth,\n    plte_length,\n    sample_depth,\n    viewable;\n} MngBuffer;\n#endif\n\ntypedef struct _MngInfo\n{\n\n#ifdef MNG_OBJECT_BUFFERS\n  MngBuffer\n    *ob[MNG_MAX_OBJECTS];\n#endif\n\n  Image *\n    image;\n\n  RectangleInfo\n    page;\n\n  int\n    adjoin,\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n    bytes_in_read_buffer,\n    found_empty_plte,\n#endif\n    equal_backgrounds,\n    equal_chrms,\n    equal_gammas,\n#if defined(PNG_WRITE_EMPTY_PLTE_SUPPORTED) || \\\n    defined(PNG_MNG_FEATURES_SUPPORTED)\n    equal_palettes,\n#endif\n    equal_physs,\n    equal_srgbs,\n    framing_mode,\n    have_global_bkgd,\n    have_global_chrm,\n    have_global_gama,\n    have_global_phys,\n    have_global_sbit,\n    have_global_srgb,\n    have_saved_bkgd_index,\n    have_write_global_chrm,\n    have_write_global_gama,\n    have_write_global_plte,\n    have_write_global_srgb,\n    need_fram,\n    object_id,\n    old_framing_mode,\n    saved_bkgd_index;\n\n  int\n    new_number_colors;\n\n  ssize_t\n    image_found,\n    loop_count[256],\n    loop_iteration[256],\n    scenes_found,\n    x_off[MNG_MAX_OBJECTS],\n    y_off[MNG_MAX_OBJECTS];\n\n  MngBox\n    clip,\n    frame,\n    image_box,\n    object_clip[MNG_MAX_OBJECTS];\n\n  unsigned char\n    /* These flags could be combined into one byte */\n    exists[MNG_MAX_OBJECTS],\n    frozen[MNG_MAX_OBJECTS],\n    loop_active[256],\n    invisible[MNG_MAX_OBJECTS],\n    viewable[MNG_MAX_OBJECTS];\n\n  MagickOffsetType\n    loop_jump[256];\n\n  png_colorp\n    global_plte;\n\n  png_color_8\n    global_sbit;\n\n  png_byte\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n    read_buffer[8],\n#endif\n    global_trns[256];\n\n  float\n    global_gamma;\n\n  ChromaticityInfo\n    global_chrm;\n\n  RenderingIntent\n    global_srgb_intent;\n\n  unsigned long\n    delay,\n    global_plte_length,\n    global_trns_length,\n    global_x_pixels_per_unit,\n    global_y_pixels_per_unit,\n    mng_width,\n    mng_height,\n    ticks_per_second;\n\n  MagickBooleanType\n    need_blob;\n\n  unsigned int\n    IsPalette,\n    global_phys_unit_type,\n    basi_warning,\n    clon_warning,\n    dhdr_warning,\n    jhdr_warning,\n    magn_warning,\n    past_warning,\n    phyg_warning,\n    phys_warning,\n    sbit_warning,\n    show_warning,\n    mng_type,\n    write_mng,\n    write_png_colortype,\n    write_png_depth,\n    write_png_compression_level,\n    write_png_compression_strategy,\n    write_png_compression_filter,\n    write_png8,\n    write_png24,\n    write_png32,\n    write_png48,\n    write_png64;\n\n#ifdef MNG_BASI_SUPPORTED\n  unsigned long\n    basi_width,\n    basi_height;\n\n  unsigned int\n    basi_depth,\n    basi_color_type,\n    basi_compression_method,\n    basi_filter_type,\n    basi_interlace_method,\n    basi_red,\n    basi_green,\n    basi_blue,\n    basi_alpha,\n    basi_viewable;\n#endif\n\n  png_uint_16\n    magn_first,\n    magn_last,\n    magn_mb,\n    magn_ml,\n    magn_mr,\n    magn_mt,\n    magn_mx,\n    magn_my,\n    magn_methx,\n    magn_methy;\n\n  PixelInfo\n    mng_global_bkgd;\n\n  /* Added at version 6.6.6-7 */\n  MagickBooleanType\n    ping_exclude_bKGD,\n    ping_exclude_cHRM,\n    ping_exclude_date,\n    ping_exclude_eXIf,\n    ping_exclude_EXIF,\n    ping_exclude_gAMA,\n    ping_exclude_iCCP,\n    /* ping_exclude_iTXt, */\n    ping_exclude_oFFs,\n    ping_exclude_pHYs,\n    ping_exclude_sRGB,\n    ping_exclude_tEXt,\n    ping_exclude_tRNS,\n    ping_exclude_vpAg,\n    ping_exclude_caNv,\n    ping_exclude_zCCP, /* hex-encoded iCCP */\n    ping_exclude_zTXt,\n    ping_preserve_colormap,\n  /* Added at version 6.8.5-7 */\n    ping_preserve_iCCP,\n  /* Added at version 6.8.9-9 */\n    ping_exclude_tIME;\n\n} MngInfo;\n#endif /* VER */\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePNGImage(const ImageInfo *,Image *,ExceptionInfo *);\n\nstatic MagickBooleanType\n  WriteMNGImage(const ImageInfo *,Image *,ExceptionInfo *);\n\n#if defined(JNG_SUPPORTED)\nstatic MagickBooleanType\n  WriteJNGImage(const ImageInfo *,Image *,ExceptionInfo *);\n#endif\n\n#if PNG_LIBPNG_VER > 10011\n\n\n#if (MAGICKCORE_QUANTUM_DEPTH >= 16)\nstatic MagickBooleanType\nLosslessReduceDepthOK(Image *image,ExceptionInfo *exception)\n{\n    /* Reduce bit depth if it can be reduced losslessly from 16+ to 8.\n     *\n     * This is true if the high byte and the next highest byte of\n     * each sample of the image, the colormap, and the background color\n     * are equal to each other.  We check this by seeing if the samples\n     * are unchanged when we scale them down to 8 and back up to Quantum.\n     *\n     * We don't use the method GetImageDepth() because it doesn't check\n     * background and doesn't handle PseudoClass specially.\n     */\n\n#define QuantumToCharToQuantumEqQuantum(quantum) \\\n ((ScaleCharToQuantum((unsigned char) ScaleQuantumToChar(quantum))) == quantum)\n\n    MagickBooleanType\n      ok_to_reduce=MagickFalse;\n\n    if (image->depth >= 16)\n      {\n\n        const Quantum\n          *p;\n\n        ok_to_reduce=\n           QuantumToCharToQuantumEqQuantum(image->background_color.red) &&\n           QuantumToCharToQuantumEqQuantum(image->background_color.green) &&\n           QuantumToCharToQuantumEqQuantum(image->background_color.blue) ?\n           MagickTrue : MagickFalse;\n\n        if (ok_to_reduce != MagickFalse && image->storage_class == PseudoClass)\n          {\n            int indx;\n\n            for (indx=0; indx < (ssize_t) image->colors; indx++)\n              {\n                ok_to_reduce=(\n                   QuantumToCharToQuantumEqQuantum(\n                   image->colormap[indx].red) &&\n                   QuantumToCharToQuantumEqQuantum(\n                   image->colormap[indx].green) &&\n                   QuantumToCharToQuantumEqQuantum(\n                   image->colormap[indx].blue)) ?\n                   MagickTrue : MagickFalse;\n\n                if (ok_to_reduce == MagickFalse)\n                   break;\n              }\n          }\n\n        if ((ok_to_reduce != MagickFalse) &&\n            (image->storage_class != PseudoClass))\n          {\n            ssize_t\n              y;\n\n            register ssize_t\n              x;\n\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n\n              if (p == (const Quantum *) NULL)\n                {\n                  ok_to_reduce = MagickFalse;\n                  break;\n                }\n\n              for (x=(ssize_t) image->columns-1; x >= 0; x--)\n              {\n                ok_to_reduce=\n                   QuantumToCharToQuantumEqQuantum(GetPixelRed(image,p)) &&\n                   QuantumToCharToQuantumEqQuantum(GetPixelGreen(image,p)) &&\n                   QuantumToCharToQuantumEqQuantum(GetPixelBlue(image,p)) ?\n                   MagickTrue : MagickFalse;\n\n                if (ok_to_reduce == MagickFalse)\n                  break;\n\n                p+=GetPixelChannels(image);\n              }\n              if (x >= 0)\n                break;\n            }\n          }\n\n        if (ok_to_reduce != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    OK to reduce PNG bit depth to 8 without loss of info\");\n          }\n        else\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Not OK to reduce PNG bit depth to 8 without losing info\");\n          }\n      }\n\n    return ok_to_reduce;\n}\n#endif /* MAGICKCORE_QUANTUM_DEPTH >= 16 */\n\nstatic const char* PngColorTypeToString(const unsigned int color_type)\n{\n  const char\n    *result = \"Unknown\";\n\n  switch (color_type)\n    {\n    case PNG_COLOR_TYPE_GRAY:\n      result = \"Gray\";\n      break;\n    case PNG_COLOR_TYPE_GRAY_ALPHA:\n      result = \"Gray+Alpha\";\n      break;\n    case PNG_COLOR_TYPE_PALETTE:\n      result = \"Palette\";\n      break;\n    case PNG_COLOR_TYPE_RGB:\n      result = \"RGB\";\n      break;\n    case PNG_COLOR_TYPE_RGB_ALPHA:\n      result = \"RGB+Alpha\";\n      break;\n    }\n\n  return result;\n}\n\nstatic int\nMagick_RenderingIntent_to_PNG_RenderingIntent(const RenderingIntent intent)\n{\n  switch (intent)\n  {\n    case PerceptualIntent:\n       return 0;\n\n    case RelativeIntent:\n       return 1;\n\n    case SaturationIntent:\n       return 2;\n\n    case AbsoluteIntent:\n       return 3;\n\n    default:\n       return -1;\n  }\n}\n\nstatic RenderingIntent\nMagick_RenderingIntent_from_PNG_RenderingIntent(const int ping_intent)\n{\n  switch (ping_intent)\n  {\n    case 0:\n      return PerceptualIntent;\n\n    case 1:\n      return RelativeIntent;\n\n    case 2:\n      return SaturationIntent;\n\n    case 3:\n      return AbsoluteIntent;\n\n    default:\n      return UndefinedIntent;\n    }\n}\n\nstatic const char *\nMagick_RenderingIntentString_from_PNG_RenderingIntent(const int ping_intent)\n{\n  switch (ping_intent)\n  {\n    case 0:\n      return \"Perceptual Intent\";\n\n    case 1:\n      return \"Relative Intent\";\n\n    case 2:\n      return \"Saturation Intent\";\n\n    case 3:\n      return \"Absolute Intent\";\n\n    default:\n      return \"Undefined Intent\";\n    }\n}\n\nstatic const char *\nMagick_ColorType_from_PNG_ColorType(const int ping_colortype)\n{\n  switch (ping_colortype)\n  {\n    case 0:\n      return \"Grayscale\";\n\n    case 2:\n      return \"Truecolor\";\n\n    case 3:\n      return \"Indexed\";\n\n    case 4:\n      return \"GrayAlpha\";\n\n    case 6:\n      return \"RGBA\";\n\n    default:\n      return \"UndefinedColorType\";\n    }\n}\n\n#endif /* PNG_LIBPNG_VER > 10011 */\n#endif /* MAGICKCORE_PNG_DELEGATE */\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s M N G                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsMNG() returns MagickTrue if the image format type, identified by the\n%  magick string, is MNG.\n%\n%  The format of the IsMNG method is:\n%\n%      MagickBooleanType IsMNG(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n%\n*/\nstatic MagickBooleanType IsMNG(const unsigned char *magick,const size_t length)\n{\n  if (length < 8)\n    return(MagickFalse);\n\n  if (memcmp(magick,\"\\212MNG\\r\\n\\032\\n\",8) == 0)\n    return(MagickTrue);\n\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s J N G                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsJNG() returns MagickTrue if the image format type, identified by the\n%  magick string, is JNG.\n%\n%  The format of the IsJNG method is:\n%\n%      MagickBooleanType IsJNG(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n%\n*/\nstatic MagickBooleanType IsJNG(const unsigned char *magick,const size_t length)\n{\n  if (length < 8)\n    return(MagickFalse);\n\n  if (memcmp(magick,\"\\213JNG\\r\\n\\032\\n\",8) == 0)\n    return(MagickTrue);\n\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s P N G                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsPNG() returns MagickTrue if the image format type, identified by the\n%  magick string, is PNG.\n%\n%  The format of the IsPNG method is:\n%\n%      MagickBooleanType IsPNG(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsPNG(const unsigned char *magick,const size_t length)\n{\n  if (length < 8)\n    return(MagickFalse);\n\n  if (memcmp(magick,\"\\211PNG\\r\\n\\032\\n\",8) == 0)\n    return(MagickTrue);\n\n  return(MagickFalse);\n}\n\f\n#if defined(MAGICKCORE_PNG_DELEGATE)\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n#if (PNG_LIBPNG_VER > 10011)\nstatic size_t WriteBlobMSBULong(Image *image,const size_t value)\n{\n  unsigned char\n    buffer[4];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  buffer[0]=(unsigned char) (value >> 24);\n  buffer[1]=(unsigned char) (value >> 16);\n  buffer[2]=(unsigned char) (value >> 8);\n  buffer[3]=(unsigned char) value;\n  return((size_t) WriteBlob(image,4,buffer));\n}\n\nstatic void PNGLong(png_bytep p,png_uint_32 value)\n{\n  *p++=(png_byte) ((value >> 24) & 0xff);\n  *p++=(png_byte) ((value >> 16) & 0xff);\n  *p++=(png_byte) ((value >> 8) & 0xff);\n  *p++=(png_byte) (value & 0xff);\n}\n\nstatic void PNGsLong(png_bytep p,png_int_32 value)\n{\n  *p++=(png_byte) ((value >> 24) & 0xff);\n  *p++=(png_byte) ((value >> 16) & 0xff);\n  *p++=(png_byte) ((value >> 8) & 0xff);\n  *p++=(png_byte) (value & 0xff);\n}\n\nstatic void PNGShort(png_bytep p,png_uint_16 value)\n{\n  *p++=(png_byte) ((value >> 8) & 0xff);\n  *p++=(png_byte) (value & 0xff);\n}\n\nstatic void PNGType(png_bytep p,const png_byte *type)\n{\n  (void) CopyMagickMemory(p,type,4*sizeof(png_byte));\n}\n\nstatic void LogPNGChunk(MagickBooleanType logging, const png_byte *type,\n   size_t length)\n{\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Writing %c%c%c%c chunk, length: %.20g\",\n      type[0],type[1],type[2],type[3],(double) length);\n}\n#endif /* PNG_LIBPNG_VER > 10011 */\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\n#if PNG_LIBPNG_VER > 10011\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P N G I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPNGImage() reads a Portable Network Graphics (PNG) or\n%  Multiple-image Network Graphics (MNG) image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image or set of images.\n%\n%  MNG support written by Glenn Randers-Pehrson, glennrp@image...\n%\n%  The format of the ReadPNGImage method is:\n%\n%     Image *ReadPNGImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n%  To do, more or less in chronological order (as of version 5.5.2,\n%   November 26, 2002 -- glennrp -- see also \"To do\" under WriteMNGImage):\n%\n%    Get 16-bit cheap transparency working.\n%\n%    (At this point, PNG decoding is supposed to be in full MNG-LC compliance)\n%\n%    Preserve all unknown and not-yet-handled known chunks found in input\n%    PNG file and copy them into output PNG files according to the PNG\n%    copying rules.\n%\n%    (At this point, PNG encoding should be in full MNG compliance)\n%\n%    Provide options for choice of background to use when the MNG BACK\n%    chunk is not present or is not mandatory (i.e., leave transparent,\n%    user specified, MNG BACK, PNG bKGD)\n%\n%    Implement LOOP/ENDL [done, but could do discretionary loops more\n%    efficiently by linking in the duplicate frames.].\n%\n%    Decode and act on the MHDR simplicity profile (offer option to reject\n%    files or attempt to process them anyway when the profile isn't LC or VLC).\n%\n%    Upgrade to full MNG without Delta-PNG.\n%\n%        o  BACK [done a while ago except for background image ID]\n%        o  MOVE [done 15 May 1999]\n%        o  CLIP [done 15 May 1999]\n%        o  DISC [done 19 May 1999]\n%        o  SAVE [partially done 19 May 1999 (marks objects frozen)]\n%        o  SEEK [partially done 19 May 1999 (discard function only)]\n%        o  SHOW\n%        o  PAST\n%        o  BASI\n%        o  MNG-level tEXt/iTXt/zTXt\n%        o  pHYg\n%        o  pHYs\n%        o  sBIT\n%        o  bKGD\n%        o  iTXt (wait for libpng implementation).\n%\n%    Use the scene signature to discover when an identical scene is\n%    being reused, and just point to the original image->exception instead\n%    of storing another set of pixels.  This not specific to MNG\n%    but could be applied generally.\n%\n%    Upgrade to full MNG with Delta-PNG.\n%\n%    JNG tEXt/iTXt/zTXt\n%\n%    We will not attempt to read files containing the CgBI chunk.\n%    They are really Xcode files meant for display on the iPhone.\n%    These are not valid PNG files and it is impossible to recover\n%    the original PNG from files that have been converted to Xcode-PNG,\n%    since irretrievable loss of color data has occurred due to the\n%    use of premultiplied alpha.\n*/\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n/*\n  This the function that does the actual reading of data.  It is\n  the same as the one supplied in libpng, except that it receives the\n  datastream from the ReadBlob() function instead of standard input.\n*/\nstatic void png_get_data(png_structp png_ptr,png_bytep data,png_size_t length)\n{\n  Image\n    *image;\n\n  image=(Image *) png_get_io_ptr(png_ptr);\n  if (length != 0)\n    {\n      png_size_t\n        check;\n\n      check=(png_size_t) ReadBlob(image,(size_t) length,data);\n      if (check != length)\n        {\n          char\n            msg[MagickPathExtent];\n\n          (void) FormatLocaleString(msg,MagickPathExtent,\n            \"Expected %.20g bytes; found %.20g bytes\",(double) length,\n            (double) check);\n          png_warning(png_ptr,msg);\n          png_error(png_ptr,\"Read Exception\");\n        }\n    }\n}\n\n#if !defined(PNG_READ_EMPTY_PLTE_SUPPORTED) && \\\n    !defined(PNG_MNG_FEATURES_SUPPORTED)\n/* We use mng_get_data() instead of png_get_data() if we have a libpng\n * older than libpng-1.0.3a, which was the first to allow the empty\n * PLTE, or a newer libpng in which PNG_MNG_FEATURES_SUPPORTED was\n * ifdef'ed out.  Earlier versions would crash if the bKGD chunk was\n * encountered after an empty PLTE, so we have to look ahead for bKGD\n * chunks and remove them from the datastream that is passed to libpng,\n * and store their contents for later use.\n */\nstatic void mng_get_data(png_structp png_ptr,png_bytep data,png_size_t length)\n{\n  MngInfo\n    *mng_info;\n\n  Image\n    *image;\n\n  png_size_t\n    check;\n\n  register ssize_t\n    i;\n\n  i=0;\n  mng_info=(MngInfo *) png_get_io_ptr(png_ptr);\n  image=(Image *) mng_info->image;\n  while (mng_info->bytes_in_read_buffer && length)\n  {\n    data[i]=mng_info->read_buffer[i];\n    mng_info->bytes_in_read_buffer--;\n    length--;\n    i++;\n  }\n  if (length != 0)\n    {\n      check=(png_size_t) ReadBlob(image,(size_t) length,(char *) data);\n\n      if (check != length)\n        png_error(png_ptr,\"Read Exception\");\n\n      if (length == 4)\n        {\n          if ((data[0] == 0) && (data[1] == 0) && (data[2] == 0) &&\n              (data[3] == 0))\n            {\n              check=(png_size_t) ReadBlob(image,(size_t) length,\n                (char *) mng_info->read_buffer);\n              mng_info->read_buffer[4]=0;\n              mng_info->bytes_in_read_buffer=4;\n              if (memcmp(mng_info->read_buffer,mng_PLTE,4) == 0)\n                mng_info->found_empty_plte=MagickTrue;\n              if (memcmp(mng_info->read_buffer,mng_IEND,4) == 0)\n                {\n                  mng_info->found_empty_plte=MagickFalse;\n                  mng_info->have_saved_bkgd_index=MagickFalse;\n                }\n            }\n\n          if ((data[0] == 0) && (data[1] == 0) && (data[2] == 0) &&\n              (data[3] == 1))\n            {\n              check=(png_size_t) ReadBlob(image,(size_t) length,\n                (char *) mng_info->read_buffer);\n              mng_info->read_buffer[4]=0;\n              mng_info->bytes_in_read_buffer=4;\n              if (memcmp(mng_info->read_buffer,mng_bKGD,4) == 0)\n                if (mng_info->found_empty_plte)\n                  {\n                    /*\n                      Skip the bKGD data byte and CRC.\n                    */\n                    check=(png_size_t)\n                      ReadBlob(image,5,(char *) mng_info->read_buffer);\n                    check=(png_size_t) ReadBlob(image,(size_t) length,\n                      (char *) mng_info->read_buffer);\n                    mng_info->saved_bkgd_index=mng_info->read_buffer[0];\n                    mng_info->have_saved_bkgd_index=MagickTrue;\n                    mng_info->bytes_in_read_buffer=0;\n                  }\n            }\n        }\n    }\n}\n#endif\n\nstatic void png_put_data(png_structp png_ptr,png_bytep data,png_size_t length)\n{\n  Image\n    *image;\n\n  image=(Image *) png_get_io_ptr(png_ptr);\n  if (length != 0)\n    {\n      png_size_t\n        check;\n\n      check=(png_size_t) WriteBlob(image,(size_t) length,data);\n\n      if (check != length)\n        png_error(png_ptr,\"WriteBlob Failed\");\n    }\n}\n\nstatic void png_flush_data(png_structp png_ptr)\n{\n  (void) png_ptr;\n}\n\n#ifdef PNG_WRITE_EMPTY_PLTE_SUPPORTED\nstatic int PalettesAreEqual(Image *a,Image *b)\n{\n  ssize_t\n    i;\n\n  if ((a == (Image *) NULL) || (b == (Image *) NULL))\n    return((int) MagickFalse);\n\n  if (a->storage_class != PseudoClass || b->storage_class != PseudoClass)\n    return((int) MagickFalse);\n\n  if (a->colors != b->colors)\n    return((int) MagickFalse);\n\n  for (i=0; i < (ssize_t) a->colors; i++)\n  {\n    if ((a->colormap[i].red != b->colormap[i].red) ||\n        (a->colormap[i].green != b->colormap[i].green) ||\n        (a->colormap[i].blue != b->colormap[i].blue))\n      return((int) MagickFalse);\n  }\n\n  return((int) MagickTrue);\n}\n#endif\n\nstatic void MngInfoDiscardObject(MngInfo *mng_info,int i)\n{\n  if (i && (i < MNG_MAX_OBJECTS) && (mng_info != (MngInfo *) NULL) &&\n      mng_info->exists[i] && !mng_info->frozen[i])\n    {\n#ifdef MNG_OBJECT_BUFFERS\n      if (mng_info->ob[i] != (MngBuffer *) NULL)\n        {\n          if (mng_info->ob[i]->reference_count > 0)\n            mng_info->ob[i]->reference_count--;\n\n          if (mng_info->ob[i]->reference_count == 0)\n            {\n              if (mng_info->ob[i]->image != (Image *) NULL)\n                mng_info->ob[i]->image=DestroyImage(mng_info->ob[i]->image);\n\n              mng_info->ob[i]=DestroyString(mng_info->ob[i]);\n            }\n        }\n      mng_info->ob[i]=(MngBuffer *) NULL;\n#endif\n      mng_info->exists[i]=MagickFalse;\n      mng_info->invisible[i]=MagickFalse;\n      mng_info->viewable[i]=MagickFalse;\n      mng_info->frozen[i]=MagickFalse;\n      mng_info->x_off[i]=0;\n      mng_info->y_off[i]=0;\n      mng_info->object_clip[i].left=0;\n      mng_info->object_clip[i].right=(ssize_t) PNG_UINT_31_MAX;\n      mng_info->object_clip[i].top=0;\n      mng_info->object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX;\n    }\n}\n\nstatic MngInfo *MngInfoFreeStruct(MngInfo *mng_info)\n{\n  register ssize_t\n    i;\n\n  if (mng_info == (MngInfo *) NULL)\n    return((MngInfo *) NULL);\n\n  for (i=1; i < MNG_MAX_OBJECTS; i++)\n    MngInfoDiscardObject(mng_info,i);\n\n  if (mng_info->global_plte != (png_colorp) NULL)\n    mng_info->global_plte=(png_colorp)\n      RelinquishMagickMemory(mng_info->global_plte);\n\n  return((MngInfo *) RelinquishMagickMemory(mng_info));\n}\n\nstatic MngBox mng_minimum_box(MngBox box1,MngBox box2)\n{\n  MngBox\n    box;\n\n  box=box1;\n  if (box.left < box2.left)\n    box.left=box2.left;\n\n  if (box.top < box2.top)\n    box.top=box2.top;\n\n  if (box.right > box2.right)\n    box.right=box2.right;\n\n  if (box.bottom > box2.bottom)\n    box.bottom=box2.bottom;\n\n  return box;\n}\n\nstatic MngBox mng_read_box(MngBox previous_box,char delta_type,\n  unsigned char *p)\n{\n   MngBox\n      box;\n\n  /*\n    Read clipping boundaries from DEFI, CLIP, FRAM, or PAST chunk.\n  */\n  box.left=(long) (((png_uint_32) p[0] << 24) | ((png_uint_32) p[1] << 16) |\n    ((png_uint_32) p[2] << 8) | (png_uint_32) p[3]);\n  box.right=(long) (((png_uint_32) p[4]  << 24) | ((png_uint_32) p[5] << 16) |\n    ((png_uint_32) p[6] << 8) | (png_uint_32) p[7]);\n  box.top=(long) (((png_uint_32) p[8]  << 24) | ((png_uint_32) p[9] << 16) |\n    ((png_uint_32) p[10] << 8) | (png_uint_32) p[11]);\n  box.bottom=(long) (((png_uint_32) p[12] << 24) | ((png_uint_32) p[13] << 16) |\n    ((png_uint_32) p[14] << 8) | (png_uint_32) p[15]);\n  if (delta_type != 0)\n    {\n      box.left+=previous_box.left;\n      box.right+=previous_box.right;\n      box.top+=previous_box.top;\n      box.bottom+=previous_box.bottom;\n    }\n\n  return(box);\n}\n\nstatic MngPair mng_read_pair(MngPair previous_pair,int delta_type,\n  unsigned char *p)\n{\n  MngPair\n    pair;\n\n  /*\n    Read two ssize_t's from CLON, MOVE or PAST chunk\n  */\n  pair.a=(long) (((png_uint_32) p[0] << 24) | ((png_uint_32) p[1] << 16) |\n    ((png_uint_32) p[2] << 8) | (png_uint_32) p[3]);\n  pair.b=(long) (((png_uint_32) p[4] << 24) | ((png_uint_32) p[5] << 16) |\n    ((png_uint_32) p[6] << 8) | (png_uint_32) p[7]);\n  if (delta_type != 0)\n    {\n      pair.a+=previous_pair.a;\n      pair.b+=previous_pair.b;\n    }\n\n  return(pair);\n}\n\nstatic long mng_get_long(unsigned char *p)\n{\n  return ((long) (((png_uint_32) p[0] << 24) | ((png_uint_32) p[1] << 16) |\n    ((png_uint_32) p[2] << 8) | (png_uint_32) p[3]));\n}\n\ntypedef struct _PNGErrorInfo\n{\n  Image\n    *image;\n\n  ExceptionInfo\n    *exception;\n} PNGErrorInfo;\n\nstatic void MagickPNGErrorHandler(png_struct *ping,png_const_charp message)\n{\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  PNGErrorInfo\n    *error_info;\n\n  error_info=(PNGErrorInfo *) png_get_error_ptr(ping);\n  image=error_info->image;\n  exception=error_info->exception;\n\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  libpng-%s error: %s\", png_get_libpng_ver(NULL),message);\n\n  (void) ThrowMagickException(exception,GetMagickModule(),CoderError,message,\n    \"`%s'\",image->filename);\n\n#if (PNG_LIBPNG_VER < 10500)\n  /* A warning about deprecated use of jmpbuf here is unavoidable if you\n   * are building with libpng-1.4.x and can be ignored.\n   */\n  longjmp(ping->jmpbuf,1);\n#else\n  png_longjmp(ping,1);\n#endif\n}\n\nstatic void MagickPNGWarningHandler(png_struct *ping,png_const_charp message)\n{\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  PNGErrorInfo\n    *error_info;\n\n  if (LocaleCompare(message, \"Missing PLTE before tRNS\") == 0)\n    png_error(ping, message);\n\n  error_info=(PNGErrorInfo *) png_get_error_ptr(ping);\n  image=error_info->image;\n  exception=error_info->exception;\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  libpng-%s warning: %s\", png_get_libpng_ver(NULL),message);\n\n  (void) ThrowMagickException(exception,GetMagickModule(),CoderWarning,\n    message,\"`%s'\",image->filename);\n}\n\n#ifdef PNG_USER_MEM_SUPPORTED\n#if PNG_LIBPNG_VER >= 10400\nstatic png_voidp Magick_png_malloc(png_structp png_ptr,png_alloc_size_t size)\n#else\nstatic png_voidp Magick_png_malloc(png_structp png_ptr,png_size_t size)\n#endif\n{\n  (void) png_ptr;\n  return((png_voidp) AcquireMagickMemory((size_t) size));\n}\n\n/*\n  Free a pointer.  It is removed from the list at the same time.\n*/\nstatic png_free_ptr Magick_png_free(png_structp png_ptr,png_voidp ptr)\n{\n  (void) png_ptr;\n  ptr=RelinquishMagickMemory(ptr);\n  return((png_free_ptr) NULL);\n}\n#endif\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic int\nMagick_png_read_raw_profile(png_struct *ping,Image *image,\n   const ImageInfo *image_info, png_textp text,int ii,ExceptionInfo *exception)\n{\n  register ssize_t\n    i;\n\n  register unsigned char\n    *dp;\n\n  register png_charp\n    sp;\n\n  png_uint_32\n    length,\n    nibbles;\n\n  StringInfo\n    *profile;\n\n  const unsigned char\n    unhex[103]={0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                 0,0,0,0,0,0,0,0,0,1, 2,3,4,5,6,7,8,9,0,0,\n                 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,10,11,12,\n                 13,14,15};\n\n  sp=text[ii].text+1;\n  /* look for newline */\n  while (*sp != '\\n')\n     sp++;\n\n  /* look for length */\n  while (*sp == '\\0' || *sp == ' ' || *sp == '\\n')\n     sp++;\n\n  length=(png_uint_32) StringToLong(sp);\n\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      length: %lu\",(unsigned long) length);\n\n  while (*sp != ' ' && *sp != '\\n')\n     sp++;\n\n  /* allocate space */\n  if (length == 0)\n  {\n    png_warning(ping,\"invalid profile length\");\n    return(MagickFalse);\n  }\n\n  profile=BlobToStringInfo((const void *) NULL,length);\n\n  if (profile == (StringInfo *) NULL)\n  {\n    png_warning(ping, \"unable to copy profile\");\n    return(MagickFalse);\n  }\n\n  /* copy profile, skipping white space and column 1 \"=\" signs */\n  dp=GetStringInfoDatum(profile);\n  nibbles=length*2;\n\n  for (i=0; i < (ssize_t) nibbles; i++)\n  {\n    while (*sp < '0' || (*sp > '9' && *sp < 'a') || *sp > 'f')\n    {\n      if (*sp == '\\0')\n        {\n          png_warning(ping, \"ran out of profile data\");\n          profile=DestroyStringInfo(profile);\n          return(MagickFalse);\n        }\n      sp++;\n    }\n\n    if (i%2 == 0)\n      *dp=(unsigned char) (16*unhex[(int) *sp++]);\n\n    else\n      (*dp++)+=unhex[(int) *sp++];\n  }\n  /*\n    We have already read \"Raw profile type.\n  */\n  (void) SetImageProfile(image,&text[ii].key[17],profile,exception);\n  profile=DestroyStringInfo(profile);\n\n  if (image_info->verbose)\n    (void) printf(\" Found a generic profile, type %s\\n\",&text[ii].key[17]);\n\n  return MagickTrue;\n}\n\n#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)\n\nstatic int read_user_chunk_callback(png_struct *ping, png_unknown_chunkp chunk)\n{\n  Image\n    *image;\n\n\n  /* The unknown chunk structure contains the chunk data:\n     png_byte name[5];\n     png_byte *data;\n     png_size_t size;\n\n     Note that libpng has already taken care of the CRC handling.\n\n     Returns one of the following:\n         return(-n);  chunk had an error\n         return(0);  did not recognize\n         return(n);  success\n  */\n\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n     \"    read_user_chunk: found %c%c%c%c chunk\",\n       chunk->name[0],chunk->name[1],chunk->name[2],chunk->name[3]);\n\n  if (chunk->name[0]  == 101 &&\n      (chunk->name[1] ==  88 || chunk->name[1] == 120 ) &&\n      chunk->name[2] ==   73 &&\n      chunk-> name[3] == 102)\n    {\n      /* process eXIf or exIf chunk */\n\n      PNGErrorInfo\n        *error_info;\n\n      StringInfo\n        *profile;\n\n      unsigned char\n        *p;\n\n      png_byte\n        *s;\n\n      size_t\n        i;\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \" recognized eXIf chunk\");\n\n      image=(Image *) png_get_user_chunk_ptr(ping);\n\n      error_info=(PNGErrorInfo *) png_get_error_ptr(ping);\n\n      profile=BlobToStringInfo((const void *) NULL,chunk->size+6);\n\n      if (profile == (StringInfo *) NULL)\n        {\n          (void) ThrowMagickException(error_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n            image->filename);\n          return(-1);\n        }\n      p=GetStringInfoDatum(profile);\n\n      if (*p != 'E')\n        {\n          /* Initialize profile with \"Exif\\0\\0\" if it is not\n             already present by accident\n          */\n          *p++ ='E';\n          *p++ ='x';\n          *p++ ='i';\n          *p++ ='f';\n          *p++ ='\\0';\n          *p++ ='\\0';\n        }\n      else\n        {\n          if (p[1] != 'x' || p[2] != 'i' || p[3] != 'f' ||\n              p[4] != '\\0' || p[5] != '\\0')\n            {\n              /* Chunk is malformed */\n              profile=DestroyStringInfo(profile);\n              return(-1);\n            }\n         }\n\n      /* copy chunk->data to profile */\n      s=chunk->data;\n      for (i=0; i<chunk->size; i++)\n        *p++ = *s++;\n\n      error_info=(PNGErrorInfo *) png_get_error_ptr(ping);\n      (void) SetImageProfile(image,\"exif\",profile,\n        error_info->exception);\n\n      profile=DestroyStringInfo(profile);\n\n      return(1);\n    }\n\n  /* vpAg (deprecated, replaced by caNv) */\n  if (chunk->name[0] == 118 &&\n      chunk->name[1] == 112 &&\n      chunk->name[2] ==  65 &&\n      chunk->name[3] == 103)\n    {\n      /* recognized vpAg */\n\n      if (chunk->size != 9)\n        return(-1); /* Error return */\n\n      if (chunk->data[8] != 0)\n        return(0);  /* ImageMagick requires pixel units */\n\n      image=(Image *) png_get_user_chunk_ptr(ping);\n\n      image->page.width=(size_t) (((png_uint_32) chunk->data[0] << 24) |\n        ((png_uint_32) chunk->data[1] << 16) |\n        ((png_uint_32) chunk->data[2] << 8) |\n        (png_uint_32) chunk->data[3]);\n      image->page.height=(size_t) (((png_uint_32) chunk->data[4] << 24) |\n        ((png_uint_32) chunk->data[5] << 16) |\n        ((png_uint_32) chunk->data[6] << 8) |\n        (png_uint_32) chunk->data[7]);\n\n      return(1);\n    }\n\n  /* caNv */\n  if (chunk->name[0] ==  99 &&\n      chunk->name[1] ==  97 &&\n      chunk->name[2] ==  78 &&\n      chunk->name[3] == 118)\n    {\n      /* recognized caNv */\n\n      if (chunk->size != 16)\n        return(-1); /* Error return */\n\n      image=(Image *) png_get_user_chunk_ptr(ping);\n\n      image->page.width=(size_t) (((png_uint_32) chunk->data[0] << 24) |\n        ((png_uint_32) chunk->data[1] << 16) |\n        ((png_uint_32) chunk->data[2] << 8) | (png_uint_32) chunk->data[3]);\n      image->page.height=(size_t) (((png_uint_32) chunk->data[4] << 24) |\n        ((png_uint_32) chunk->data[5] << 16) |\n        ((png_uint_32) chunk->data[6] << 8) | (png_uint_32) chunk->data[7]);\n      image->page.x=(ssize_t) (((png_uint_32) chunk->data[8] << 24) |\n        ((png_uint_32) chunk->data[9] << 16) |\n        ((png_uint_32) chunk->data[10] << 8) | (png_uint_32) chunk->data[11]);\n      image->page.y=(ssize_t) (((png_uint_32) chunk->data[12] << 24) |\n        ((png_uint_32) chunk->data[13] << 16) |\n        ((png_uint_32) chunk->data[14] << 8) | (png_uint_32) chunk->data[15]);\n\n      return(1);\n    }\n\n  return(0); /* Did not recognize */\n}\n#endif /* PNG_UNKNOWN_CHUNKS_SUPPORTED */\n\n#if defined(PNG_tIME_SUPPORTED)\nstatic void read_tIME_chunk(Image *image,png_struct *ping,png_info *info,\n  ExceptionInfo *exception)\n{\n  png_timep\n    time;\n\n  if (png_get_tIME(ping,info,&time))\n    {\n      char\n        timestamp[21];\n\n      FormatLocaleString(timestamp,21,\"%04d-%02d-%02dT%02d:%02d:%02dZ\",\n        time->year,time->month,time->day,time->hour,time->minute,time->second);\n      SetImageProperty(image,\"png:tIME\",timestamp,exception);\n    }\n}\n#endif\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d O n e P N G I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadOnePNGImage() reads a Portable Network Graphics (PNG) image file\n%  (minus the 8-byte signature)  and returns it.  It allocates the memory\n%  necessary for the new Image structure and returns a pointer to the new\n%  image.\n%\n%  The format of the ReadOnePNGImage method is:\n%\n%      Image *ReadOnePNGImage(MngInfo *mng_info, const ImageInfo *image_info,\n%         ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o mng_info: Specifies a pointer to a MngInfo structure.\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadOnePNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  /* Read one PNG image */\n\n  /* To do: Read the tEXt/Creation Time chunk into the date:create property */\n\n  Image\n    *image;\n\n  char\n    im_vers[32],\n    libpng_runv[32],\n    libpng_vers[32],\n    zlib_runv[32],\n    zlib_vers[32];\n\n  int\n    intent, /* \"PNG Rendering intent\", which is ICC intent + 1 */\n    num_raw_profiles,\n    num_text,\n    num_text_total,\n    num_passes,\n    number_colors,\n    pass,\n    ping_bit_depth,\n    ping_color_type,\n    ping_file_depth,\n    ping_interlace_method,\n    ping_compression_method,\n    ping_filter_method,\n    ping_num_trans,\n    unit_type;\n\n  double\n    file_gamma;\n\n  MagickBooleanType\n    logging,\n    ping_found_cHRM,\n    ping_found_gAMA,\n    ping_found_iCCP,\n    ping_found_sRGB,\n    ping_found_sRGB_cHRM,\n    ping_preserve_iCCP,\n    status;\n\n  MemoryInfo\n    *volatile pixel_info;\n\n  PixelInfo\n    transparent_color;\n\n  PNGErrorInfo\n    error_info;\n\n  png_bytep\n     ping_trans_alpha;\n\n  png_color_16p\n     ping_background,\n     ping_trans_color;\n\n  png_info\n    *end_info,\n    *ping_info;\n\n  png_struct\n    *ping;\n\n  png_textp\n    text;\n\n  png_uint_32\n    ping_height,\n    ping_width,\n    x_resolution,\n    y_resolution;\n\n  QuantumInfo\n    *volatile quantum_info;\n\n  ssize_t\n    ping_rowbytes,\n    y;\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  size_t\n    length,\n    row_offset;\n\n  ssize_t\n    j;\n\n  unsigned char\n    *ping_pixels;\n\n#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED\n  png_byte unused_chunks[]=\n  {\n    104,  73,  83,  84, (png_byte) '\\0',   /* hIST */\n    105,  84,  88, 116, (png_byte) '\\0',   /* iTXt */\n    112,  67,  65,  76, (png_byte) '\\0',   /* pCAL */\n    115,  67,  65,  76, (png_byte) '\\0',   /* sCAL */\n    115,  80,  76,  84, (png_byte) '\\0',   /* sPLT */\n#if !defined(PNG_tIME_SUPPORTED)\n    116,  73,  77,  69, (png_byte) '\\0',   /* tIME */\n#endif\n#ifdef PNG_APNG_SUPPORTED /* libpng was built with APNG patch; */\n                          /* ignore the APNG chunks */\n     97,  99,  84,  76, (png_byte) '\\0',   /* acTL */\n    102,  99,  84,  76, (png_byte) '\\0',   /* fcTL */\n    102, 100,  65,  84, (png_byte) '\\0',   /* fdAT */\n#endif\n  };\n#endif\n\n  /* Define these outside of the following \"if logging()\" block so they will\n   * show in debuggers.\n   */\n  *im_vers='\\0';\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibVersionText,32);\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibAddendum,32);\n\n  *libpng_vers='\\0';\n  (void) ConcatenateMagickString(libpng_vers,\n         PNG_LIBPNG_VER_STRING,32);\n  *libpng_runv='\\0';\n  (void) ConcatenateMagickString(libpng_runv,\n         png_get_libpng_ver(NULL),32);\n\n  *zlib_vers='\\0';\n  (void) ConcatenateMagickString(zlib_vers,\n         ZLIB_VERSION,32);\n  *zlib_runv='\\0';\n  (void) ConcatenateMagickString(zlib_runv,\n         zlib_version,32);\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"  Enter ReadOnePNGImage()\\n\"\n       \"    IM version     = %s\\n\"\n       \"    Libpng version = %s\",\n       im_vers, libpng_vers);\n\n  if (logging != MagickFalse)\n  {\n    if (LocaleCompare(libpng_vers,libpng_runv) != 0)\n    {\n   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n        libpng_runv);\n    }\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    Zlib version   = %s\",\n        zlib_vers);\n    if (LocaleCompare(zlib_vers,zlib_runv) != 0)\n    {\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n        zlib_runv);\n    }\n  }\n\n#if (PNG_LIBPNG_VER < 10200)\n  if (image_info->verbose)\n    printf(\"Your PNG library (libpng-%s) is rather old.\\n\",\n       PNG_LIBPNG_VER_STRING);\n#endif\n\n#if (PNG_LIBPNG_VER >= 10400)\n#  ifndef  PNG_TRANSFORM_GRAY_TO_RGB    /* Added at libpng-1.4.0beta67 */\n  if (image_info->verbose)\n    {\n      printf(\"Your PNG library (libpng-%s) is an old beta version.\\n\",\n           PNG_LIBPNG_VER_STRING);\n      printf(\"Please update it.\\n\");\n    }\n#  endif\n#endif\n\n\n  quantum_info = (QuantumInfo *) NULL;\n  image=mng_info->image;\n\n  if (logging != MagickFalse)\n  {\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"    Before reading:\\n\"\n       \"      image->alpha_trait=%d\"\n       \"      image->rendering_intent=%d\\n\"\n       \"      image->colorspace=%d\\n\"\n       \"      image->gamma=%f\",\n       (int) image->alpha_trait, (int) image->rendering_intent,\n       (int) image->colorspace, image->gamma);\n  }\n  intent=\n    Magick_RenderingIntent_to_PNG_RenderingIntent(image->rendering_intent);\n\n  /* Set to an out-of-range color unless tRNS chunk is present */\n  transparent_color.red=65537;\n  transparent_color.green=65537;\n  transparent_color.blue=65537;\n  transparent_color.alpha=65537;\n\n  number_colors=0;\n  num_text = 0;\n  num_text_total = 0;\n  num_raw_profiles = 0;\n\n  ping_found_cHRM = MagickFalse;\n  ping_found_gAMA = MagickFalse;\n  ping_found_iCCP = MagickFalse;\n  ping_found_sRGB = MagickFalse;\n  ping_found_sRGB_cHRM = MagickFalse;\n  ping_preserve_iCCP = MagickFalse;\n\n\n  /*\n    Allocate the PNG structures\n  */\n#ifdef PNG_USER_MEM_SUPPORTED\n error_info.image=image;\n error_info.exception=exception;\n ping=png_create_read_struct_2(PNG_LIBPNG_VER_STRING,&error_info,\n   MagickPNGErrorHandler,MagickPNGWarningHandler, NULL,\n   (png_malloc_ptr) Magick_png_malloc,(png_free_ptr) Magick_png_free);\n#else\n  ping=png_create_read_struct(PNG_LIBPNG_VER_STRING,&error_info,\n    MagickPNGErrorHandler,MagickPNGWarningHandler);\n#endif\n  if (ping == (png_struct *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  ping_info=png_create_info_struct(ping);\n\n  if (ping_info == (png_info *) NULL)\n    {\n      png_destroy_read_struct(&ping,(png_info **) NULL,(png_info **) NULL);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n\n  end_info=png_create_info_struct(ping);\n\n  if (end_info == (png_info *) NULL)\n    {\n      png_destroy_read_struct(&ping,&ping_info,(png_info **) NULL);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n\n  pixel_info=(MemoryInfo *) NULL;\n\n  if (setjmp(png_jmpbuf(ping)))\n    {\n      /*\n        PNG image is corrupt.\n      */\n      png_destroy_read_struct(&ping,&ping_info,&end_info);\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n      UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n      if (pixel_info != (MemoryInfo *) NULL)\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n\n      if (quantum_info != (QuantumInfo *) NULL)\n        quantum_info=DestroyQuantumInfo(quantum_info);\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  exit ReadOnePNGImage() with error.\");\n\n      return(GetFirstImageInList(image));\n    }\n\n  /* {  For navigation to end of SETJMP-protected block.  Within this\n   *    block, use png_error() instead of Throwing an Exception, to ensure\n   *    that libpng is able to clean up, and that the semaphore is unlocked.\n   */\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  LockSemaphoreInfo(ping_semaphore);\n#endif\n\n#ifdef PNG_BENIGN_ERRORS_SUPPORTED\n  /* Allow benign errors */\n  png_set_benign_errors(ping, 1);\n#endif\n\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n  /* Reject images with too many rows or columns */\n  png_set_user_limits(ping,\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(WidthResource)),\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(HeightResource)));\n#endif /* PNG_SET_USER_LIMITS_SUPPORTED */\n\n  /*\n    Prepare PNG for reading.\n  */\n\n  mng_info->image_found++;\n  png_set_sig_bytes(ping,8);\n\n  if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n    {\n#if defined(PNG_MNG_FEATURES_SUPPORTED)\n      (void) png_permit_mng_features(ping,PNG_ALL_MNG_FEATURES);\n      png_set_read_fn(ping,image,png_get_data);\n#else\n#if defined(PNG_READ_EMPTY_PLTE_SUPPORTED)\n      png_permit_empty_plte(ping,MagickTrue);\n      png_set_read_fn(ping,image,png_get_data);\n#else\n      mng_info->image=image;\n      mng_info->bytes_in_read_buffer=0;\n      mng_info->found_empty_plte=MagickFalse;\n      mng_info->have_saved_bkgd_index=MagickFalse;\n      png_set_read_fn(ping,mng_info,mng_get_data);\n#endif\n#endif\n    }\n\n  else\n    png_set_read_fn(ping,image,png_get_data);\n\n  {\n    const char\n      *value;\n\n    value=GetImageOption(image_info,\"profile:skip\");\n\n    if (IsOptionMember(\"ICC\",value) == MagickFalse)\n    {\n\n       value=GetImageOption(image_info,\"png:preserve-iCCP\");\n\n       if (value == NULL)\n          value=GetImageArtifact(image,\"png:preserve-iCCP\");\n\n       if (value != NULL)\n          ping_preserve_iCCP=MagickTrue;\n\n#if defined(PNG_SKIP_sRGB_CHECK_PROFILE) && defined(PNG_SET_OPTION_SUPPORTED)\n       /* Don't let libpng check for ICC/sRGB profile because we're going\n        * to do that anyway.  This feature was added at libpng-1.6.12.\n        * If logging, go ahead and check and issue a warning as appropriate.\n        */\n       if (logging == MagickFalse)\n          png_set_option(ping, PNG_SKIP_sRGB_CHECK_PROFILE, PNG_OPTION_ON);\n#endif\n    }\n#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)\n    else\n    {\n       png_set_keep_unknown_chunks(ping, 1, (png_bytep) mng_iCCP, 1);\n    }\n#endif\n  }\n#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)\n  /* Ignore unused chunks and all unknown chunks except for eXIf,\n     caNv, and vpAg */\n# if PNG_LIBPNG_VER < 10700 /* Avoid libpng16 warning */\n  png_set_keep_unknown_chunks(ping, 2, NULL, 0);\n# else\n  png_set_keep_unknown_chunks(ping, 1, NULL, 0);\n# endif\n  png_set_keep_unknown_chunks(ping, 2, (png_bytep) mng_eXIf, 1);\n  png_set_keep_unknown_chunks(ping, 2, (png_bytep) mng_caNv, 1);\n  png_set_keep_unknown_chunks(ping, 2, (png_bytep) mng_vpAg, 1);\n  png_set_keep_unknown_chunks(ping, 1, unused_chunks,\n     (int)sizeof(unused_chunks)/5);\n  /* Callback for other unknown chunks */\n  png_set_read_user_chunk_fn(ping, image, read_user_chunk_callback);\n#endif\n\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n#  if (PNG_LIBPNG_VER >= 10400)\n    /* Limit the size of the chunk storage cache used for sPLT, text,\n     * and unknown chunks.\n     */\n    png_set_chunk_cache_max(ping, 32767);\n#  endif\n#endif\n\n#ifdef PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED\n    /* Disable new libpng-1.5.10 feature */\n    png_set_check_for_invalid_index (ping, 0);\n#endif\n\n#if (PNG_LIBPNG_VER < 10400)\n#  if defined(PNG_USE_PNGGCCRD) && defined(PNG_ASSEMBLER_CODE_SUPPORTED) && \\\n   (PNG_LIBPNG_VER >= 10200) && (PNG_LIBPNG_VER < 10220) && defined(__i386__)\n  /* Disable thread-unsafe features of pnggccrd */\n  if (png_access_version_number() >= 10200)\n  {\n    png_uint_32 mmx_disable_mask=0;\n    png_uint_32 asm_flags;\n\n    mmx_disable_mask |= ( PNG_ASM_FLAG_MMX_READ_COMBINE_ROW  \\\n                        | PNG_ASM_FLAG_MMX_READ_FILTER_SUB   \\\n                        | PNG_ASM_FLAG_MMX_READ_FILTER_AVG   \\\n                        | PNG_ASM_FLAG_MMX_READ_FILTER_PAETH );\n    asm_flags=png_get_asm_flags(ping);\n    png_set_asm_flags(ping, asm_flags & ~mmx_disable_mask);\n  }\n#  endif\n#endif\n\n  png_read_info(ping,ping_info);\n\n  png_get_IHDR(ping,ping_info,&ping_width,&ping_height,\n               &ping_bit_depth,&ping_color_type,\n               &ping_interlace_method,&ping_compression_method,\n               &ping_filter_method);\n\n  ping_file_depth = ping_bit_depth;\n\n  /* Swap bytes if requested */\n  if (ping_file_depth == 16)\n  {\n     const char\n       *value;\n\n     value=GetImageOption(image_info,\"png:swap-bytes\");\n\n     if (value == NULL)\n        value=GetImageArtifact(image,\"png:swap-bytes\");\n\n     if (value != NULL)\n        png_set_swap(ping);\n  }\n\n  /* Save bit-depth and color-type in case we later want to write a PNG00 */\n  {\n      char\n        msg[MagickPathExtent];\n\n      (void) FormatLocaleString(msg,MagickPathExtent,\"%d\",\n         (int) ping_color_type);\n      (void) SetImageProperty(image,\"png:IHDR.color-type-orig\",msg,exception);\n\n      (void) FormatLocaleString(msg,MagickPathExtent,\"%d\",\n         (int) ping_bit_depth);\n      (void) SetImageProperty(image,\"png:IHDR.bit-depth-orig\",msg,exception);\n  }\n\n  (void) png_get_tRNS(ping, ping_info, &ping_trans_alpha, &ping_num_trans,\n                      &ping_trans_color);\n\n  (void) png_get_bKGD(ping, ping_info, &ping_background);\n\n  if (ping_bit_depth < 8)\n    {\n       png_set_packing(ping);\n       ping_bit_depth = 8;\n    }\n\n  image->depth=ping_bit_depth;\n  image->depth=GetImageQuantumDepth(image,MagickFalse);\n  image->interlace=ping_interlace_method != 0 ? PNGInterlace : NoInterlace;\n\n  if (((int) ping_color_type == PNG_COLOR_TYPE_GRAY) ||\n      ((int) ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA))\n    {\n      image->rendering_intent=UndefinedIntent;\n      intent=Magick_RenderingIntent_to_PNG_RenderingIntent(UndefinedIntent);\n      (void) ResetMagickMemory(&image->chromaticity,0,\n        sizeof(image->chromaticity));\n    }\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG width: %.20g, height: %.20g\\n\"\n        \"    PNG color_type: %d, bit_depth: %d\\n\"\n        \"    PNG compression_method: %d\\n\"\n        \"    PNG interlace_method: %d, filter_method: %d\",\n        (double) ping_width, (double) ping_height,\n        ping_color_type, ping_bit_depth,\n        ping_compression_method,\n        ping_interlace_method,ping_filter_method);\n\n    }\n\n  if (png_get_valid(ping,ping_info, PNG_INFO_iCCP))\n    {\n      ping_found_iCCP=MagickTrue;\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Found PNG iCCP chunk.\");\n    }\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_gAMA))\n    {\n      ping_found_gAMA=MagickTrue;\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Found PNG gAMA chunk.\");\n    }\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_cHRM))\n    {\n      ping_found_cHRM=MagickTrue;\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Found PNG cHRM chunk.\");\n    }\n\n  if (ping_found_iCCP != MagickTrue && png_get_valid(ping,ping_info,\n      PNG_INFO_sRGB))\n    {\n      ping_found_sRGB=MagickTrue;\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Found PNG sRGB chunk.\");\n    }\n\n#ifdef PNG_READ_iCCP_SUPPORTED\n    if (ping_found_iCCP !=MagickTrue &&\n      ping_found_sRGB != MagickTrue &&\n      png_get_valid(ping,ping_info, PNG_INFO_iCCP))\n    {\n      ping_found_iCCP=MagickTrue;\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Found PNG iCCP chunk.\");\n    }\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_iCCP))\n    {\n      int\n        compression;\n\n#if (PNG_LIBPNG_VER < 10500)\n      png_charp\n        info;\n#else\n      png_bytep\n        info;\n#endif\n\n      png_charp\n        name;\n\n      png_uint_32\n        profile_length;\n\n      (void) png_get_iCCP(ping,ping_info,&name,(int *) &compression,&info,\n        &profile_length);\n\n      if (profile_length != 0)\n        {\n          StringInfo\n            *profile;\n\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Reading PNG iCCP chunk.\");\n\n          profile=BlobToStringInfo(info,profile_length);\n\n          if (profile == (StringInfo *) NULL)\n          {\n            png_warning(ping, \"ICC profile is NULL\");\n            profile=DestroyStringInfo(profile);\n          }\n          else\n          {\n            if (ping_preserve_iCCP == MagickFalse)\n            {\n                 int\n                   icheck,\n                   got_crc=0;\n\n\n                 png_uint_32\n                   length,\n                   profile_crc=0;\n\n                 unsigned char\n                   *data;\n\n                 length=(png_uint_32) GetStringInfoLength(profile);\n\n                 for (icheck=0; sRGB_info[icheck].len > 0; icheck++)\n                 {\n                   if (length == sRGB_info[icheck].len)\n                   {\n                     if (got_crc == 0)\n                     {\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Got a %lu-byte ICC profile (potentially sRGB)\",\n                         (unsigned long) length);\n\n                       data=GetStringInfoDatum(profile);\n                       profile_crc=crc32(0,data,length);\n\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"      with crc=%8x\",(unsigned int) profile_crc);\n                       got_crc++;\n                     }\n\n                     if (profile_crc == sRGB_info[icheck].crc)\n                     {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"      It is sRGB with rendering intent = %s\",\n                        Magick_RenderingIntentString_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent));\n                        if (image->rendering_intent==UndefinedIntent)\n                        {\n                          image->rendering_intent=\n                          Magick_RenderingIntent_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent);\n                        }\n                        break;\n                     }\n                   }\n                 }\n                 if (sRGB_info[icheck].len == 0)\n                 {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"    Got %lu-byte ICC profile not recognized as sRGB\",\n                        (unsigned long) length);\n                    (void) SetImageProfile(image,\"icc\",profile,exception);\n                 }\n            }\n            else /* Preserve-iCCP */\n            {\n                    (void) SetImageProfile(image,\"icc\",profile,exception);\n            }\n\n            profile=DestroyStringInfo(profile);\n          }\n      }\n    }\n#endif\n\n#if defined(PNG_READ_sRGB_SUPPORTED)\n  {\n    if (ping_found_iCCP==MagickFalse && png_get_valid(ping,ping_info,\n        PNG_INFO_sRGB))\n    {\n      if (png_get_sRGB(ping,ping_info,&intent))\n      {\n        if (image->rendering_intent == UndefinedIntent)\n          image->rendering_intent=\n             Magick_RenderingIntent_from_PNG_RenderingIntent (intent);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Reading PNG sRGB chunk: rendering_intent: %d\",intent);\n      }\n    }\n\n    else if (mng_info->have_global_srgb)\n      {\n        if (image->rendering_intent == UndefinedIntent)\n          image->rendering_intent=\n            Magick_RenderingIntent_from_PNG_RenderingIntent\n            (mng_info->global_srgb_intent);\n      }\n  }\n#endif\n\n\n  {\n     if (!png_get_gAMA(ping,ping_info,&file_gamma))\n       if (mng_info->have_global_gama)\n         png_set_gAMA(ping,ping_info,mng_info->global_gamma);\n\n     if (png_get_gAMA(ping,ping_info,&file_gamma))\n       {\n         image->gamma=(float) file_gamma;\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Reading PNG gAMA chunk: gamma: %f\",file_gamma);\n       }\n  }\n\n  if (!png_get_valid(ping,ping_info,PNG_INFO_cHRM))\n    {\n      if (mng_info->have_global_chrm != MagickFalse)\n        {\n          (void) png_set_cHRM(ping,ping_info,\n            mng_info->global_chrm.white_point.x,\n            mng_info->global_chrm.white_point.y,\n            mng_info->global_chrm.red_primary.x,\n            mng_info->global_chrm.red_primary.y,\n            mng_info->global_chrm.green_primary.x,\n            mng_info->global_chrm.green_primary.y,\n            mng_info->global_chrm.blue_primary.x,\n            mng_info->global_chrm.blue_primary.y);\n        }\n    }\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_cHRM))\n    {\n      (void) png_get_cHRM(ping,ping_info,\n        &image->chromaticity.white_point.x,\n        &image->chromaticity.white_point.y,\n        &image->chromaticity.red_primary.x,\n        &image->chromaticity.red_primary.y,\n        &image->chromaticity.green_primary.x,\n        &image->chromaticity.green_primary.y,\n        &image->chromaticity.blue_primary.x,\n        &image->chromaticity.blue_primary.y);\n\n       ping_found_cHRM=MagickTrue;\n\n       if (image->chromaticity.red_primary.x>0.6399f &&\n           image->chromaticity.red_primary.x<0.6401f &&\n           image->chromaticity.red_primary.y>0.3299f &&\n           image->chromaticity.red_primary.y<0.3301f &&\n           image->chromaticity.green_primary.x>0.2999f &&\n           image->chromaticity.green_primary.x<0.3001f &&\n           image->chromaticity.green_primary.y>0.5999f &&\n           image->chromaticity.green_primary.y<0.6001f &&\n           image->chromaticity.blue_primary.x>0.1499f &&\n           image->chromaticity.blue_primary.x<0.1501f &&\n           image->chromaticity.blue_primary.y>0.0599f &&\n           image->chromaticity.blue_primary.y<0.0601f &&\n           image->chromaticity.white_point.x>0.3126f &&\n           image->chromaticity.white_point.x<0.3128f &&\n           image->chromaticity.white_point.y>0.3289f &&\n           image->chromaticity.white_point.y<0.3291f)\n          ping_found_sRGB_cHRM=MagickTrue;\n    }\n\n  if (image->rendering_intent != UndefinedIntent)\n    {\n      if (ping_found_sRGB != MagickTrue &&\n          (ping_found_gAMA != MagickTrue ||\n          (image->gamma > .45 && image->gamma < .46)) &&\n          (ping_found_cHRM != MagickTrue ||\n          ping_found_sRGB_cHRM != MagickFalse) &&\n          ping_found_iCCP != MagickTrue)\n      {\n         png_set_sRGB(ping,ping_info,\n            Magick_RenderingIntent_to_PNG_RenderingIntent\n            (image->rendering_intent));\n         file_gamma=1.000f/2.200f;\n         ping_found_sRGB=MagickTrue;\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"    Setting sRGB as if in input\");\n      }\n    }\n\n#if defined(PNG_oFFs_SUPPORTED)\n  if (png_get_valid(ping,ping_info,PNG_INFO_oFFs))\n    {\n      image->page.x=(ssize_t) png_get_x_offset_pixels(ping, ping_info);\n      image->page.y=(ssize_t) png_get_y_offset_pixels(ping, ping_info);\n\n      if (logging != MagickFalse)\n        if (image->page.x || image->page.y)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Reading PNG oFFs chunk: x: %.20g, y: %.20g.\",(double)\n            image->page.x,(double) image->page.y);\n    }\n#endif\n#if defined(PNG_pHYs_SUPPORTED)\n  if (!png_get_valid(ping,ping_info,PNG_INFO_pHYs))\n    {\n      if (mng_info->have_global_phys)\n        {\n          png_set_pHYs(ping,ping_info,\n                       mng_info->global_x_pixels_per_unit,\n                       mng_info->global_y_pixels_per_unit,\n                       mng_info->global_phys_unit_type);\n        }\n    }\n\n  x_resolution=0;\n  y_resolution=0;\n  unit_type=0;\n  if (png_get_valid(ping,ping_info,PNG_INFO_pHYs))\n    {\n      /*\n        Set image resolution.\n      */\n      (void) png_get_pHYs(ping,ping_info,&x_resolution,&y_resolution,\n        &unit_type);\n      image->resolution.x=(double) x_resolution;\n      image->resolution.y=(double) y_resolution;\n\n      if (unit_type == PNG_RESOLUTION_METER)\n        {\n          image->units=PixelsPerCentimeterResolution;\n          image->resolution.x=(double) x_resolution/100.0;\n          image->resolution.y=(double) y_resolution/100.0;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Reading PNG pHYs chunk: xres: %.20g, yres: %.20g, units: %d.\",\n          (double) x_resolution,(double) y_resolution,unit_type);\n    }\n#endif\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_PLTE))\n    {\n      png_colorp\n        palette;\n\n      (void) png_get_PLTE(ping,ping_info,&palette,&number_colors);\n\n      if ((number_colors == 0) &&\n          ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE))\n        {\n          if (mng_info->global_plte_length)\n            {\n              png_set_PLTE(ping,ping_info,mng_info->global_plte,\n                (int) mng_info->global_plte_length);\n\n              if (!png_get_valid(ping,ping_info,PNG_INFO_tRNS))\n              {\n                if (mng_info->global_trns_length)\n                  {\n                    png_warning(ping,\n                      \"global tRNS has more entries than global PLTE\");\n                  }\n                else\n                  {\n                     png_set_tRNS(ping,ping_info,mng_info->global_trns,\n                       (int) mng_info->global_trns_length,NULL);\n                  }\n               }\n#ifdef PNG_READ_bKGD_SUPPORTED\n              if (\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n                   mng_info->have_saved_bkgd_index ||\n#endif\n                   png_get_valid(ping,ping_info,PNG_INFO_bKGD))\n                    {\n                      png_color_16\n                         background;\n\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n                      if (mng_info->have_saved_bkgd_index)\n                        background.index=mng_info->saved_bkgd_index;\n#endif\n                      if (png_get_valid(ping, ping_info, PNG_INFO_bKGD))\n                        background.index=ping_background->index;\n\n                      background.red=(png_uint_16)\n                        mng_info->global_plte[background.index].red;\n\n                      background.green=(png_uint_16)\n                        mng_info->global_plte[background.index].green;\n\n                      background.blue=(png_uint_16)\n                        mng_info->global_plte[background.index].blue;\n\n                      background.gray=(png_uint_16)\n                        mng_info->global_plte[background.index].green;\n\n                      png_set_bKGD(ping,ping_info,&background);\n                    }\n#endif\n                }\n              else\n                png_error(ping,\"No global PLTE in file\");\n            }\n        }\n\n#ifdef PNG_READ_bKGD_SUPPORTED\n  if (mng_info->have_global_bkgd &&\n          (!png_get_valid(ping,ping_info,PNG_INFO_bKGD)))\n      image->background_color=mng_info->mng_global_bkgd;\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_bKGD))\n    {\n      unsigned int\n        bkgd_scale;\n\n      /* Set image background color.\n       * Scale background components to 16-bit, then scale\n       * to quantum depth\n       */\n\n        bkgd_scale = 1;\n\n        if (ping_file_depth == 1)\n           bkgd_scale = 255;\n\n        else if (ping_file_depth == 2)\n           bkgd_scale = 85;\n\n        else if (ping_file_depth == 4)\n           bkgd_scale = 17;\n\n        if (ping_file_depth <= 8)\n           bkgd_scale *= 257;\n\n        ping_background->red *= bkgd_scale;\n        ping_background->green *= bkgd_scale;\n        ping_background->blue *= bkgd_scale;\n\n        if (logging != MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"    Reading PNG bKGD chunk, raw ping_background=(%d,%d,%d)\\n\"\n                 \"    bkgd_scale=%d.  ping_background=(%d,%d,%d)\",\n                 ping_background->red,ping_background->green,\n                 ping_background->blue,\n                 bkgd_scale,ping_background->red,\n                 ping_background->green,ping_background->blue);\n          }\n\n        image->background_color.red=\n            ScaleShortToQuantum(ping_background->red);\n\n        image->background_color.green=\n            ScaleShortToQuantum(ping_background->green);\n\n        image->background_color.blue=\n          ScaleShortToQuantum(ping_background->blue);\n\n        image->background_color.alpha=OpaqueAlpha;\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    image->background_color=(%.20g,%.20g,%.20g).\",\n            (double) image->background_color.red,\n            (double) image->background_color.green,\n            (double) image->background_color.blue);\n    }\n#endif /* PNG_READ_bKGD_SUPPORTED */\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_tRNS))\n    {\n      /*\n        Image has a tRNS chunk.\n      */\n      int\n        max_sample;\n\n      size_t\n        one = 1;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Reading PNG tRNS chunk.\");\n\n      max_sample = (int) ((one << ping_file_depth) - 1);\n\n      if ((ping_color_type == PNG_COLOR_TYPE_GRAY &&\n          (int)ping_trans_color->gray > max_sample) ||\n          (ping_color_type == PNG_COLOR_TYPE_RGB &&\n          ((int)ping_trans_color->red > max_sample ||\n          (int)ping_trans_color->green > max_sample ||\n          (int)ping_trans_color->blue > max_sample)))\n        {\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Ignoring PNG tRNS chunk with out-of-range sample.\");\n          png_free_data(ping, ping_info, PNG_FREE_TRNS, 0);\n          png_set_invalid(ping,ping_info,PNG_INFO_tRNS);\n          image->alpha_trait=UndefinedPixelTrait;\n        }\n      else\n        {\n          int\n            scale_to_short;\n\n          scale_to_short = 65535L/((1UL << ping_file_depth)-1);\n\n          /* Scale transparent_color to short */\n          transparent_color.red= scale_to_short*ping_trans_color->red;\n          transparent_color.green= scale_to_short*ping_trans_color->green;\n          transparent_color.blue= scale_to_short*ping_trans_color->blue;\n          transparent_color.alpha= scale_to_short*ping_trans_color->gray;\n\n          if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n            {\n              if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Raw tRNS graylevel = %d, scaled graylevel = %d.\",\n                  (int) ping_trans_color->gray,(int) transparent_color.alpha);\n\n              }\n              transparent_color.red=transparent_color.alpha;\n              transparent_color.green=transparent_color.alpha;\n              transparent_color.blue=transparent_color.alpha;\n            }\n        }\n    }\n#if defined(PNG_READ_sBIT_SUPPORTED)\n  if (mng_info->have_global_sbit)\n    {\n      if (!png_get_valid(ping,ping_info,PNG_INFO_sBIT))\n        png_set_sBIT(ping,ping_info,&mng_info->global_sbit);\n    }\n#endif\n  num_passes=png_set_interlace_handling(ping);\n\n  png_read_update_info(ping,ping_info);\n\n  ping_rowbytes=png_get_rowbytes(ping,ping_info);\n\n  /*\n    Initialize image structure.\n  */\n  mng_info->image_box.left=0;\n  mng_info->image_box.right=(ssize_t) ping_width;\n  mng_info->image_box.top=0;\n  mng_info->image_box.bottom=(ssize_t) ping_height;\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=ping_width;\n      mng_info->mng_height=ping_height;\n      mng_info->frame=mng_info->image_box;\n      mng_info->clip=mng_info->image_box;\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  image->compression=ZipCompression;\n  image->columns=ping_width;\n  image->rows=ping_height;\n\n  if (((int) ping_color_type == PNG_COLOR_TYPE_GRAY) ||\n      ((int) ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA))\n    {\n      double\n        image_gamma = image->gamma;\n\n      (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"    image->gamma=%f\",(float) image_gamma);\n\n      if (image_gamma > 0.75)\n        {\n          /* Set image->rendering_intent to Undefined,\n           * image->colorspace to GRAY, and reset image->chromaticity.\n           */\n          image->intensity = Rec709LuminancePixelIntensityMethod;\n          SetImageColorspace(image,GRAYColorspace,exception);\n        }\n      else\n        {\n          RenderingIntent\n            save_rendering_intent = image->rendering_intent;\n          ChromaticityInfo\n            save_chromaticity = image->chromaticity;\n\n          SetImageColorspace(image,GRAYColorspace,exception);\n          image->rendering_intent = save_rendering_intent;\n          image->chromaticity = save_chromaticity;\n        }\n\n      image->gamma = image_gamma;\n    }\n\n  (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    image->colorspace=%d\",(int) image->colorspace);\n\n  if (((int) ping_color_type == PNG_COLOR_TYPE_PALETTE) ||\n      ((int) ping_bit_depth < 16 &&\n      (int) ping_color_type == PNG_COLOR_TYPE_GRAY))\n    {\n      size_t\n        one;\n\n      image->storage_class=PseudoClass;\n      one=1;\n      image->colors=one << ping_file_depth;\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n      if (image->colors > 256)\n        image->colors=256;\n#else\n      if (image->colors > 65536L)\n        image->colors=65536L;\n#endif\n      if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        {\n          png_colorp\n            palette;\n\n          (void) png_get_PLTE(ping,ping_info,&palette,&number_colors);\n          image->colors=(size_t) number_colors;\n\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Reading PNG PLTE chunk: number_colors: %d.\",number_colors);\n        }\n    }\n\n  if (image->storage_class == PseudoClass)\n    {\n      /*\n        Initialize image colormap.\n      */\n      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n        png_error(ping,\"Memory allocation failed\");\n\n      if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        {\n          png_colorp\n            palette;\n\n          (void) png_get_PLTE(ping,ping_info,&palette,&number_colors);\n\n          for (i=0; i < (ssize_t) number_colors; i++)\n          {\n            image->colormap[i].red=ScaleCharToQuantum(palette[i].red);\n            image->colormap[i].green=ScaleCharToQuantum(palette[i].green);\n            image->colormap[i].blue=ScaleCharToQuantum(palette[i].blue);\n          }\n\n          for ( ; i < (ssize_t) image->colors; i++)\n          {\n            image->colormap[i].red=0;\n            image->colormap[i].green=0;\n            image->colormap[i].blue=0;\n          }\n        }\n\n      else\n        {\n          Quantum\n            scale;\n\n          scale = (Quantum) (65535.0/((1UL << ping_file_depth)-1.0));\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n          scale = ScaleShortToQuantum(scale);\n#endif\n\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            image->colormap[i].red=(Quantum) (i*scale);\n            image->colormap[i].green=(Quantum) (i*scale);\n            image->colormap[i].blue=(Quantum) (i*scale);\n          }\n       }\n    }\n\n   /* Set some properties for reporting by \"identify\" */\n    {\n      char\n        msg[MagickPathExtent];\n\n     /* encode ping_width, ping_height, ping_file_depth, ping_color_type,\n        ping_interlace_method in value */\n\n     (void) FormatLocaleString(msg,MagickPathExtent,\n         \"%d, %d\",(int) ping_width, (int) ping_height);\n     (void) SetImageProperty(image,\"png:IHDR.width,height\",msg,exception);\n\n     (void) FormatLocaleString(msg,MagickPathExtent,\"%d\",\n        (int) ping_file_depth);\n     (void) SetImageProperty(image,\"png:IHDR.bit_depth\",msg,exception);\n\n     (void) FormatLocaleString(msg,MagickPathExtent,\"%d (%s)\",\n         (int) ping_color_type,\n         Magick_ColorType_from_PNG_ColorType((int)ping_color_type));\n     (void) SetImageProperty(image,\"png:IHDR.color_type\",msg,exception);\n\n     if (ping_interlace_method == 0)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\"%d (Not interlaced)\",\n            (int) ping_interlace_method);\n       }\n     else if (ping_interlace_method == 1)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\"%d (Adam7 method)\",\n            (int) ping_interlace_method);\n       }\n     else\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\"%d (Unknown method)\",\n            (int) ping_interlace_method);\n       }\n       (void) SetImageProperty(image,\"png:IHDR.interlace_method\",\n         msg,exception);\n\n     if (number_colors != 0)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\"%d\",\n            (int) number_colors);\n         (void) SetImageProperty(image,\"png:PLTE.number_colors\",msg,\n            exception);\n       }\n   }\n#if defined(PNG_tIME_SUPPORTED)\n   read_tIME_chunk(image,ping,ping_info,exception);\n#endif\n\n\n  /*\n    Read image scanlines.\n  */\n  if (image->delay != 0)\n    mng_info->scenes_found++;\n\n  if ((mng_info->mng_type == 0 && (image->ping != MagickFalse)) || (\n      (image_info->number_scenes != 0) && (mng_info->scenes_found > (ssize_t)\n      (image_info->first_scene+image_info->number_scenes))))\n    {\n      /* This happens later in non-ping decodes */\n      if (png_get_valid(ping,ping_info,PNG_INFO_tRNS))\n        image->storage_class=DirectClass;\n      image->alpha_trait=\n        (((int) ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA) ||\n         ((int) ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA) ||\n         (png_get_valid(ping,ping_info,PNG_INFO_tRNS))) ?\n        BlendPixelTrait : UndefinedPixelTrait;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Skipping PNG image data for scene %.20g\",(double)\n          mng_info->scenes_found-1);\n      png_destroy_read_struct(&ping,&ping_info,&end_info);\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n      UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  exit ReadOnePNGImage().\");\n\n      return(image);\n    }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading PNG IDAT chunk(s)\");\n\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (num_passes > 1)\n    pixel_info=AcquireVirtualMemory(image->rows,ping_rowbytes*\n      sizeof(*ping_pixels));\n  else\n    pixel_info=AcquireVirtualMemory(ping_rowbytes,sizeof(*ping_pixels));\n\n  if (pixel_info == (MemoryInfo *) NULL)\n    png_error(ping,\"Memory allocation failed\");\n  ping_pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Converting PNG pixels to pixel packets\");\n  /*\n    Convert PNG pixels to pixel packets.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n\n  if (quantum_info == (QuantumInfo *) NULL)\n     png_error(ping,\"Failed to allocate quantum_info\");\n\n  (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n\n  {\n\n   MagickBooleanType\n     found_transparent_pixel;\n\n  found_transparent_pixel=MagickFalse;\n\n  if (image->storage_class == DirectClass)\n    {\n      for (pass=0; pass < num_passes; pass++)\n      {\n        /*\n          Convert image to DirectClass pixel packets.\n        */\n        image->alpha_trait=\n            (((int) ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA) ||\n            ((int) ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA) ||\n            (png_get_valid(ping,ping_info,PNG_INFO_tRNS))) ?\n            BlendPixelTrait : UndefinedPixelTrait;\n\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          if (num_passes > 1)\n            row_offset=ping_rowbytes*y;\n\n          else\n            row_offset=0;\n\n          png_read_row(ping,ping_pixels+row_offset,NULL);\n\n          if (pass < num_passes-1)\n            continue;\n\n          q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n          if (q == (Quantum *) NULL)\n            break;\n\n          if ((int) ping_color_type == PNG_COLOR_TYPE_GRAY)\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              GrayQuantum,ping_pixels+row_offset,exception);\n\n          else if ((int) ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              GrayAlphaQuantum,ping_pixels+row_offset,exception);\n\n          else if ((int) ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              RGBAQuantum,ping_pixels+row_offset,exception);\n\n          else if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              IndexQuantum,ping_pixels+row_offset,exception);\n\n          else /* ping_color_type == PNG_COLOR_TYPE_RGB */\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              RGBQuantum,ping_pixels+row_offset,exception);\n\n          if (found_transparent_pixel == MagickFalse)\n            {\n              /* Is there a transparent pixel in the row? */\n              if (y== 0 && logging != MagickFalse)\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Looking for cheap transparent pixel\");\n\n              for (x=(ssize_t) image->columns-1; x >= 0; x--)\n              {\n                if ((ping_color_type == PNG_COLOR_TYPE_RGBA ||\n                    ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA) &&\n                   (GetPixelAlpha(image,q) != OpaqueAlpha))\n                  {\n                    if (logging != MagickFalse)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"    ...got one.\");\n\n                    found_transparent_pixel = MagickTrue;\n                    break;\n                  }\n                if ((ping_color_type == PNG_COLOR_TYPE_RGB ||\n                    ping_color_type == PNG_COLOR_TYPE_GRAY) &&\n                    (ScaleQuantumToShort(GetPixelRed(image,q)) ==\n                    transparent_color.red &&\n                    ScaleQuantumToShort(GetPixelGreen(image,q)) ==\n                    transparent_color.green &&\n                    ScaleQuantumToShort(GetPixelBlue(image,q)) ==\n                    transparent_color.blue))\n                  {\n                    if (logging != MagickFalse)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"    ...got one.\");\n                    found_transparent_pixel = MagickTrue;\n                    break;\n                  }\n                q+=GetPixelChannels(image);\n              }\n            }\n\n          if (num_passes == 1)\n            {\n              status=SetImageProgress(image,LoadImageTag,\n                  (MagickOffsetType) y, image->rows);\n\n              if (status == MagickFalse)\n                break;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n        }\n\n        if (num_passes != 1)\n          {\n            status=SetImageProgress(image,LoadImageTag,pass,num_passes);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    }\n\n  else /* image->storage_class != DirectClass */\n\n    for (pass=0; pass < num_passes; pass++)\n    {\n      Quantum\n        *quantum_scanline;\n\n      register Quantum\n        *r;\n\n      /*\n        Convert grayscale image to PseudoClass pixel packets.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Converting grayscale pixels to pixel packets\");\n\n      image->alpha_trait=ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ?\n        BlendPixelTrait : UndefinedPixelTrait;\n\n      quantum_scanline=(Quantum *) AcquireQuantumMemory(image->columns,\n        (image->alpha_trait  == BlendPixelTrait?  2 : 1)*\n        sizeof(*quantum_scanline));\n\n      if (quantum_scanline == (Quantum *) NULL)\n        png_error(ping,\"Memory allocation failed\");\n\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        Quantum\n           alpha;\n\n        if (num_passes > 1)\n          row_offset=ping_rowbytes*y;\n\n        else\n          row_offset=0;\n\n        png_read_row(ping,ping_pixels+row_offset,NULL);\n\n        if (pass < num_passes-1)\n          continue;\n\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n\n        if (q == (Quantum *) NULL)\n          break;\n\n        p=ping_pixels+row_offset;\n        r=quantum_scanline;\n\n        switch (ping_bit_depth)\n        {\n          case 8:\n          {\n\n            if (ping_color_type == 4)\n              for (x=(ssize_t) image->columns-1; x >= 0; x--)\n              {\n                *r++=*p++;\n\n                alpha=ScaleCharToQuantum((unsigned char)*p++);\n\n                SetPixelAlpha(image,alpha,q);\n\n                if (alpha != OpaqueAlpha)\n                  found_transparent_pixel = MagickTrue;\n\n                q+=GetPixelChannels(image);\n              }\n\n            else\n              for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                *r++=*p++;\n\n            break;\n          }\n\n          case 16:\n          {\n            for (x=(ssize_t) image->columns-1; x >= 0; x--)\n            {\n#if (MAGICKCORE_QUANTUM_DEPTH >= 16)\n              unsigned short\n                quantum;\n\n              if (image->colors > 256)\n                quantum=(((unsigned int) *p++) << 8);\n\n              else\n                quantum=0;\n\n              quantum|=(*p++);\n              *r=ScaleShortToQuantum(quantum);\n              r++;\n\n              if (ping_color_type == 4)\n                {\n                  if (image->colors > 256)\n                    quantum=(((unsigned int) *p++) << 8);\n                  else\n                    quantum=0;\n\n                  quantum|=(*p++);\n\n                  alpha=ScaleShortToQuantum(quantum);\n                  SetPixelAlpha(image,alpha,q);\n\n                  if (alpha != OpaqueAlpha)\n                    found_transparent_pixel = MagickTrue;\n\n                  q+=GetPixelChannels(image);\n                }\n\n#else /* MAGICKCORE_QUANTUM_DEPTH == 8 */\n              *r++=(*p++);\n              p++; /* strip low byte */\n\n              if (ping_color_type == 4)\n                {\n                  SetPixelAlpha(image,*p++,q);\n\n                  if (GetPixelAlpha(image,q) != OpaqueAlpha)\n                    found_transparent_pixel = MagickTrue;\n\n                  p++;\n                  q+=GetPixelChannels(image);\n                }\n#endif\n            }\n\n            break;\n          }\n\n          default:\n            break;\n        }\n\n        /*\n          Transfer image scanline.\n        */\n        r=quantum_scanline;\n\n        q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          SetPixelIndex(image,*r++,q);\n          q+=GetPixelChannels(image);\n        }\n\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n\n        if (num_passes == 1)\n          {\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n\n            if (status == MagickFalse)\n              break;\n          }\n      }\n\n      if (num_passes != 1)\n        {\n          status=SetImageProgress(image,LoadImageTag,pass,num_passes);\n\n          if (status == MagickFalse)\n            break;\n        }\n\n      quantum_scanline=(Quantum *) RelinquishMagickMemory(quantum_scanline);\n    }\n\n    image->alpha_trait=found_transparent_pixel ? BlendPixelTrait :\n      UndefinedPixelTrait;\n\n    if (logging != MagickFalse)\n      {\n        if (found_transparent_pixel != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Found transparent pixel\");\n        else\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    No transparent pixel was found\");\n\n            ping_color_type&=0x03;\n          }\n      }\n    }\n\n  quantum_info=DestroyQuantumInfo(quantum_info);\n\n  if (image->storage_class == PseudoClass)\n    {\n      PixelTrait\n        alpha_trait;\n\n      alpha_trait=image->alpha_trait;\n      image->alpha_trait=UndefinedPixelTrait;\n      (void) SyncImage(image,exception);\n      image->alpha_trait=alpha_trait;\n    }\n\n  png_read_end(ping,end_info);\n\n  if (logging != MagickFalse)\n  {\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"  image->storage_class=%d\\n\",(int) image->storage_class);\n  }\n\n  if (image_info->number_scenes != 0 && mng_info->scenes_found-1 <\n      (ssize_t) image_info->first_scene && image->delay != 0)\n    {\n      png_destroy_read_struct(&ping,&ping_info,&end_info);\n      pixel_info=RelinquishVirtualMemory(pixel_info);\n      image->colors=2;\n      (void) SetImageBackgroundColor(image,exception);\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n      UnlockSemaphoreInfo(ping_semaphore);\n#endif\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  exit ReadOnePNGImage() early.\");\n      return(image);\n    }\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_tRNS))\n    {\n      ClassType\n        storage_class;\n\n      /*\n        Image has a transparent background.\n      */\n      storage_class=image->storage_class;\n      image->alpha_trait=BlendPixelTrait;\n\n/* Balfour fix from imagemagick discourse server, 5 Feb 2010 */\n\n      if (storage_class == PseudoClass)\n        {\n          if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n            {\n              for (x=0; x < ping_num_trans; x++)\n              {\n                 image->colormap[x].alpha_trait=BlendPixelTrait;\n                 image->colormap[x].alpha =\n                   ScaleCharToQuantum((unsigned char)ping_trans_alpha[x]);\n              }\n            }\n\n          else if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n            {\n              for (x=0; x < (int) image->colors; x++)\n              {\n                 if (ScaleQuantumToShort(image->colormap[x].red) ==\n                     transparent_color.alpha)\n                 {\n                    image->colormap[x].alpha_trait=BlendPixelTrait;\n                    image->colormap[x].alpha = (Quantum) TransparentAlpha;\n                 }\n              }\n            }\n          (void) SyncImage(image,exception);\n        }\n\n#if 1 /* Should have already been done above, but glennrp problem P10\n       * needs this.\n       */\n      else\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            image->storage_class=storage_class;\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (q == (Quantum *) NULL)\n              break;\n\n\n            /* Caution: on a Q8 build, this does not distinguish between\n             * 16-bit colors that differ only in the low byte\n             */\n            for (x=(ssize_t) image->columns-1; x >= 0; x--)\n            {\n              if (ScaleQuantumToShort(GetPixelRed(image,q)) ==\n                  transparent_color.red &&\n                  ScaleQuantumToShort(GetPixelGreen(image,q)) ==\n                  transparent_color.green &&\n                  ScaleQuantumToShort(GetPixelBlue(image,q)) ==\n                  transparent_color.blue)\n                {\n                  SetPixelAlpha(image,TransparentAlpha,q);\n                }\n\n#if 0 /* I have not found a case where this is needed. */\n              else\n                {\n                  SetPixelAlpha(image,q)=(Quantum) OpaqueAlpha;\n                }\n#endif\n\n              q+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n#endif\n\n      image->storage_class=DirectClass;\n    }\n\n  for (j = 0; j < 2; j++)\n  {\n    if (j == 0)\n      status = png_get_text(ping,ping_info,&text,&num_text) != 0 ?\n          MagickTrue : MagickFalse;\n    else\n      status = png_get_text(ping,end_info,&text,&num_text) != 0 ?\n          MagickTrue : MagickFalse;\n\n    if (status != MagickFalse)\n      for (i=0; i < (ssize_t) num_text; i++)\n      {\n        /* Check for a profile */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Reading PNG text chunk\");\n\n        if (strlen(text[i].key) > 16 &&\n            memcmp(text[i].key, \"Raw profile type \",17) == 0)\n          {\n            const char\n              *value;\n\n            value=GetImageOption(image_info,\"profile:skip\");\n\n            if (IsOptionMember(text[i].key+17,value) == MagickFalse)\n            {\n               (void) Magick_png_read_raw_profile(ping,image,image_info,text,\n                  (int) i,exception);\n               num_raw_profiles++;\n               if (logging != MagickFalse)\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Read raw profile %s\",text[i].key+17);\n            }\n            else\n            {\n               if (logging != MagickFalse)\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Skipping raw profile %s\",text[i].key+17);\n            }\n          }\n\n        else\n          {\n            char\n              *value;\n\n            length=text[i].text_length;\n            value=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n              sizeof(*value));\n            if (value == (char *) NULL)\n              {\n                png_error(ping,\"Memory allocation failed\");\n                break;\n              }\n            *value='\\0';\n            (void) ConcatenateMagickString(value,text[i].text,length+2);\n\n            /* Don't save \"density\" or \"units\" property if we have a pHYs\n             * chunk\n             */\n            if (!png_get_valid(ping,ping_info,PNG_INFO_pHYs) ||\n                (LocaleCompare(text[i].key,\"density\") != 0 &&\n                LocaleCompare(text[i].key,\"units\") != 0))\n               (void) SetImageProperty(image,text[i].key,value,exception);\n\n            if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      length: %lu\\n\"\n                \"      Keyword: %s\",\n                (unsigned long) length,\n                text[i].key);\n            }\n\n            value=DestroyString(value);\n          }\n      }\n    num_text_total += num_text;\n  }\n\n#ifdef MNG_OBJECT_BUFFERS\n  /*\n    Store the object if necessary.\n  */\n  if (object_id && !mng_info->frozen[object_id])\n    {\n      if (mng_info->ob[object_id] == (MngBuffer *) NULL)\n        {\n          /*\n            create a new object buffer.\n          */\n          mng_info->ob[object_id]=(MngBuffer *)\n            AcquireMagickMemory(sizeof(MngBuffer));\n\n          if (mng_info->ob[object_id] != (MngBuffer *) NULL)\n            {\n              mng_info->ob[object_id]->image=(Image *) NULL;\n              mng_info->ob[object_id]->reference_count=1;\n            }\n        }\n\n      if ((mng_info->ob[object_id] == (MngBuffer *) NULL) ||\n          mng_info->ob[object_id]->frozen)\n        {\n          if (mng_info->ob[object_id] == (MngBuffer *) NULL)\n             png_error(ping,\"Memory allocation failed\");\n\n          if (mng_info->ob[object_id]->frozen)\n            png_error(ping,\"Cannot overwrite frozen MNG object buffer\");\n        }\n\n      else\n        {\n\n          if (mng_info->ob[object_id]->image != (Image *) NULL)\n            mng_info->ob[object_id]->image=DestroyImage\n                (mng_info->ob[object_id]->image);\n\n          mng_info->ob[object_id]->image=CloneImage(image,0,0,MagickTrue,\n            exception);\n\n          if (mng_info->ob[object_id]->image != (Image *) NULL)\n            mng_info->ob[object_id]->image->file=(FILE *) NULL;\n\n          else\n            png_error(ping, \"Cloning image for object buffer failed\");\n\n          if (ping_width > 250000L || ping_height > 250000L)\n             png_error(ping,\"PNG Image dimensions are too large.\");\n\n          mng_info->ob[object_id]->width=ping_width;\n          mng_info->ob[object_id]->height=ping_height;\n          mng_info->ob[object_id]->color_type=ping_color_type;\n          mng_info->ob[object_id]->sample_depth=ping_bit_depth;\n          mng_info->ob[object_id]->interlace_method=ping_interlace_method;\n          mng_info->ob[object_id]->compression_method=\n             ping_compression_method;\n          mng_info->ob[object_id]->filter_method=ping_filter_method;\n\n          if (png_get_valid(ping,ping_info,PNG_INFO_PLTE))\n            {\n              png_colorp\n                plte;\n\n              /*\n                Copy the PLTE to the object buffer.\n              */\n              png_get_PLTE(ping,ping_info,&plte,&number_colors);\n              mng_info->ob[object_id]->plte_length=number_colors;\n\n              for (i=0; i < number_colors; i++)\n              {\n                mng_info->ob[object_id]->plte[i]=plte[i];\n              }\n            }\n\n          else\n              mng_info->ob[object_id]->plte_length=0;\n        }\n    }\n#endif\n\n   /* Set image->alpha_trait to MagickTrue if the input colortype supports\n    * alpha or if a valid tRNS chunk is present, no matter whether there\n    * is actual transparency present.\n    */\n    image->alpha_trait=(((int) ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA) ||\n        ((int) ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA) ||\n        (png_get_valid(ping,ping_info,PNG_INFO_tRNS))) ?\n        BlendPixelTrait : UndefinedPixelTrait;\n\n#if 0  /* I'm not sure what's wrong here but it does not work. */\n    if (image->alpha_trait != UndefinedPixelTrait)\n    {\n      if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n        (void) SetImageType(image,GrayscaleAlphaType,exception);\n\n      else if (ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        (void) SetImageType(image,PaletteAlphaType,exception);\n\n      else\n        (void) SetImageType(image,TrueColorAlphaType,exception);\n    }\n\n    else\n    {\n      if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n        (void) SetImageType(image,GrayscaleType,exception);\n\n      else if (ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        (void) SetImageType(image,PaletteType,exception);\n\n      else\n        (void) SetImageType(image,TrueColorType,exception);\n    }\n#endif\n\n   /* Set more properties for identify to retrieve */\n   {\n     char\n       msg[MagickPathExtent];\n\n     if (num_text_total != 0)\n       {\n         /* libpng doesn't tell us whether they were tEXt, zTXt, or iTXt */\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"%d tEXt/zTXt/iTXt chunks were found\", num_text_total);\n         (void) SetImageProperty(image,\"png:text\",msg,\n                exception);\n       }\n\n     if (num_raw_profiles != 0)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"%d were found\", num_raw_profiles);\n         (void) SetImageProperty(image,\"png:text-encoded profiles\",msg,\n                exception);\n       }\n\n     /* cHRM chunk: */\n     if (ping_found_cHRM != MagickFalse)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\"%s\",\n            \"chunk was found (see Chromaticity, above)\");\n         (void) SetImageProperty(image,\"png:cHRM\",msg,\n                exception);\n       }\n\n     /* bKGD chunk: */\n     if (png_get_valid(ping,ping_info,PNG_INFO_bKGD))\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\"%s\",\n            \"chunk was found (see Background color, above)\");\n         (void) SetImageProperty(image,\"png:bKGD\",msg,\n                exception);\n       }\n\n     (void) FormatLocaleString(msg,MagickPathExtent,\"%s\",\n        \"chunk was found\");\n\n#if defined(PNG_iCCP_SUPPORTED)\n     /* iCCP chunk: */\n     if (ping_found_iCCP != MagickFalse)\n        (void) SetImageProperty(image,\"png:iCCP\",msg,\n                exception);\n#endif\n\n     if (png_get_valid(ping,ping_info,PNG_INFO_tRNS))\n        (void) SetImageProperty(image,\"png:tRNS\",msg,\n                exception);\n\n#if defined(PNG_sRGB_SUPPORTED)\n     /* sRGB chunk: */\n     if (ping_found_sRGB != MagickFalse)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"intent=%d (%s)\",\n            (int) intent,\n            Magick_RenderingIntentString_from_PNG_RenderingIntent(intent));\n         (void) SetImageProperty(image,\"png:sRGB\",msg,\n                 exception);\n       }\n#endif\n\n     /* gAMA chunk: */\n     if (ping_found_gAMA != MagickFalse)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"gamma=%.8g (See Gamma, above)\",\n            file_gamma);\n         (void) SetImageProperty(image,\"png:gAMA\",msg,\n                exception);\n       }\n\n#if defined(PNG_pHYs_SUPPORTED)\n     /* pHYs chunk: */\n     if (png_get_valid(ping,ping_info,PNG_INFO_pHYs))\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"x_res=%.10g, y_res=%.10g, units=%d\",\n            (double) x_resolution,(double) y_resolution, unit_type);\n         (void) SetImageProperty(image,\"png:pHYs\",msg,\n                exception);\n       }\n#endif\n\n#if defined(PNG_oFFs_SUPPORTED)\n     /* oFFs chunk: */\n     if (png_get_valid(ping,ping_info,PNG_INFO_oFFs))\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"x_off=%.20g, y_off=%.20g\",\n            (double) image->page.x,(double) image->page.y);\n         (void) SetImageProperty(image,\"png:oFFs\",msg,\n                exception);\n       }\n#endif\n\n#if defined(PNG_tIME_SUPPORTED)\n     read_tIME_chunk(image,ping,end_info,exception);\n#endif\n\n     /* caNv chunk: */\n     if ((image->page.width != 0 && image->page.width != image->columns) ||\n         (image->page.height != 0 && image->page.height != image->rows) ||\n         (image->page.x != 0 || image->page.y != 0))\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"width=%.20g, height=%.20g, x_offset=%.20g, y_offset=%.20g\",\n            (double) image->page.width,(double) image->page.height,\n            (double) image->page.x,(double) image->page.y);\n         (void) SetImageProperty(image,\"png:caNv\",msg,\n                exception);\n       }\n\n     /* vpAg chunk: */\n     if ((image->page.width != 0 && image->page.width != image->columns) ||\n         (image->page.height != 0 && image->page.height != image->rows))\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"width=%.20g, height=%.20g\",\n            (double) image->page.width,(double) image->page.height);\n         (void) SetImageProperty(image,\"png:vpAg\",msg,\n                exception);\n       }\n   }\n\n  /*\n    Relinquish resources.\n  */\n  png_destroy_read_struct(&ping,&ping_info,&end_info);\n\n  pixel_info=RelinquishVirtualMemory(pixel_info);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOnePNGImage()\");\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n  /* }  for navigation to beginning of SETJMP-protected block, revert to\n   *    Throwing an Exception when an error occurs.\n   */\n\n  return(image);\n\n/* end of reading one PNG image */\n}\n\nstatic Image *ReadPNGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    logging,\n    status;\n\n  MngInfo\n    *mng_info;\n\n  char\n    magic_number[MagickPathExtent];\n\n  ssize_t\n    count;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\"Enter ReadPNGImage()\");\n  image=AcquireImage(image_info,exception);\n  mng_info=(MngInfo *) NULL;\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n\n  if (status == MagickFalse)\n    ThrowReaderException(FileOpenError,\"UnableToOpenFile\");\n\n  /*\n    Verify PNG signature.\n  */\n  count=ReadBlob(image,8,(unsigned char *) magic_number);\n\n  if (count < 8 || memcmp(magic_number,\"\\211PNG\\r\\n\\032\\n\",8) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  /*\n     Verify that file size large enough to contain a PNG datastream.\n  */\n  if (GetBlobSize(image) < 61)\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n\n  /*\n    Allocate a MngInfo structure.\n  */\n  mng_info=(MngInfo *) AcquireMagickMemory(sizeof(MngInfo));\n\n  if (mng_info == (MngInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /*\n    Initialize members of the MngInfo structure.\n  */\n  (void) ResetMagickMemory(mng_info,0,sizeof(MngInfo));\n  mng_info->image=image;\n\n  image=ReadOnePNGImage(mng_info,image_info,exception);\n  mng_info=MngInfoFreeStruct(mng_info);\n\n  if (image == (Image *) NULL)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"exit ReadPNGImage() with error\");\n\n      return((Image *) NULL);\n    }\n\n  (void) CloseBlob(image);\n\n  if ((image->columns == 0) || (image->rows == 0))\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"exit ReadPNGImage() with error.\");\n\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n\n  if ((IssRGBColorspace(image->colorspace) != MagickFalse) &&\n      ((image->gamma < .45) || (image->gamma > .46)) &&\n           !(image->chromaticity.red_primary.x>0.6399f &&\n           image->chromaticity.red_primary.x<0.6401f &&\n           image->chromaticity.red_primary.y>0.3299f &&\n           image->chromaticity.red_primary.y<0.3301f &&\n           image->chromaticity.green_primary.x>0.2999f &&\n           image->chromaticity.green_primary.x<0.3001f &&\n           image->chromaticity.green_primary.y>0.5999f &&\n           image->chromaticity.green_primary.y<0.6001f &&\n           image->chromaticity.blue_primary.x>0.1499f &&\n           image->chromaticity.blue_primary.x<0.1501f &&\n           image->chromaticity.blue_primary.y>0.0599f &&\n           image->chromaticity.blue_primary.y<0.0601f &&\n           image->chromaticity.white_point.x>0.3126f &&\n           image->chromaticity.white_point.x<0.3128f &&\n           image->chromaticity.white_point.y>0.3289f &&\n           image->chromaticity.white_point.y<0.3291f))\n    {\n       SetImageColorspace(image,RGBColorspace,exception);\n    }\n\n  if (logging != MagickFalse)\n    {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  page.w: %.20g, page.h: %.20g,page.x: %.20g, page.y: %.20g.\",\n               (double) image->page.width,(double) image->page.height,\n               (double) image->page.x,(double) image->page.y);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  image->colorspace: %d\", (int) image->colorspace);\n    }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"exit ReadPNGImage()\");\n\n  return(image);\n}\n\n\n\n#if defined(JNG_SUPPORTED)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d O n e J N G I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadOneJNGImage() reads a JPEG Network Graphics (JNG) image file\n%  (minus the 8-byte signature)  and returns it.  It allocates the memory\n%  necessary for the new Image structure and returns a pointer to the new\n%  image.\n%\n%  JNG support written by Glenn Randers-Pehrson, glennrp@image...\n%\n%  The format of the ReadOneJNGImage method is:\n%\n%      Image *ReadOneJNGImage(MngInfo *mng_info, const ImageInfo *image_info,\n%         ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o mng_info: Specifies a pointer to a MngInfo structure.\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadOneJNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  Image\n    *alpha_image,\n    *color_image,\n    *image,\n    *jng_image;\n\n  ImageInfo\n    *alpha_image_info,\n    *color_image_info;\n\n  MagickBooleanType\n    logging;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    status;\n\n  png_uint_32\n    jng_height,\n    jng_width;\n\n  png_byte\n    jng_color_type,\n    jng_image_sample_depth,\n    jng_image_compression_method,\n    jng_image_interlace_method,\n    jng_alpha_sample_depth,\n    jng_alpha_compression_method,\n    jng_alpha_filter_method,\n    jng_alpha_interlace_method;\n\n  register const Quantum\n    *s;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  unsigned int\n    read_JSEP,\n    reading_idat;\n\n  size_t\n    length;\n\n  jng_alpha_compression_method=0;\n  jng_alpha_sample_depth=8;\n  jng_color_type=0;\n  jng_height=0;\n  jng_width=0;\n  alpha_image=(Image *) NULL;\n  color_image=(Image *) NULL;\n  alpha_image_info=(ImageInfo *) NULL;\n  color_image_info=(ImageInfo *) NULL;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneJNGImage()\");\n\n  image=mng_info->image;\n\n  if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n    {\n      /*\n        Allocate next image structure.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  AcquireNextImage()\");\n\n      AcquireNextImage(image_info,image,exception);\n\n      if (GetNextImageInList(image) == (Image *) NULL)\n        return(DestroyImageList(image));\n\n      image=SyncNextImageInList(image);\n    }\n  mng_info->image=image;\n\n  /*\n    Signature bytes have already been read.\n  */\n\n  read_JSEP=MagickFalse;\n  reading_idat=MagickFalse;\n  for (;;)\n  {\n    char\n      type[MagickPathExtent];\n\n    unsigned char\n      *chunk;\n\n    unsigned int\n      count;\n\n    /*\n      Read a new JNG chunk.\n    */\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      2*GetBlobSize(image));\n\n    if (status == MagickFalse)\n      break;\n\n    type[0]='\\0';\n    (void) ConcatenateMagickString(type,\"errr\",MagickPathExtent);\n    length=ReadBlobMSBLong(image);\n    count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);\n\n    if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      {\n        if (color_image != (Image *) NULL)\n          color_image=DestroyImage(color_image);\n        if (color_image_info != (ImageInfo *) NULL)\n          color_image_info=DestroyImageInfo(color_image_info);\n        ThrowReaderException(CorruptImageError,\"CorruptImage\");\n      }\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n\n    if (length != 0)\n      {\n        if (length > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));\n\n        if (chunk == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        for (i=0; i < (ssize_t) length; i++)\n        {\n          int\n            c;\n\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            break;\n          chunk[i]=(unsigned char) c;\n        }\n\n        p=chunk;\n      }\n\n    (void) ReadBlobMSBLong(image);  /* read crc word */\n\n    if (memcmp(type,mng_JHDR,4) == 0)\n      {\n        if (length == 16)\n          {\n            jng_width=(png_uint_32) (((png_uint_32) p[0] << 24) |\n              ((png_uint_32) p[1] << 16) | ((png_uint_32) p[2] << 8) |\n              (png_uint_32) p[3]);\n            jng_height=(png_uint_32) (((png_uint_32) p[4] << 24) |\n              ((png_uint_32) p[5] << 16) | ((png_uint_32) p[6] << 8) |\n              (png_uint_32) p[7]);\n            if ((jng_width == 0) || (jng_height == 0))\n              ThrowReaderException(CorruptImageError,\n                \"NegativeOrZeroImageSize\");\n            jng_color_type=p[8];\n            jng_image_sample_depth=p[9];\n            jng_image_compression_method=p[10];\n            jng_image_interlace_method=p[11];\n\n            image->interlace=jng_image_interlace_method != 0 ? PNGInterlace :\n              NoInterlace;\n\n            jng_alpha_sample_depth=p[12];\n            jng_alpha_compression_method=p[13];\n            jng_alpha_filter_method=p[14];\n            jng_alpha_interlace_method=p[15];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_width:      %16lu,    jng_height:     %16lu\\n\"\n                  \"    jng_color_type: %16d,     jng_image_sample_depth: %3d\\n\"\n                  \"    jng_image_compression_method:%3d\",\n                  (unsigned long) jng_width, (unsigned long) jng_height,\n                  jng_color_type, jng_image_sample_depth,\n                  jng_image_compression_method);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_image_interlace_method:  %3d\"\n                  \"    jng_alpha_sample_depth:      %3d\",\n                  jng_image_interlace_method,\n                  jng_alpha_sample_depth);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_alpha_compression_method:%3d\\n\"\n                  \"    jng_alpha_filter_method:     %3d\\n\"\n                  \"    jng_alpha_interlace_method:  %3d\",\n                  jng_alpha_compression_method,\n                  jng_alpha_filter_method,\n                  jng_alpha_interlace_method);\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n\n    if ((reading_idat == MagickFalse) && (read_JSEP == MagickFalse) &&\n        ((memcmp(type,mng_JDAT,4) == 0) || (memcmp(type,mng_JdAA,4) == 0) ||\n         (memcmp(type,mng_IDAT,4) == 0) || (memcmp(type,mng_JDAA,4) == 0)))\n      {\n        /*\n           o create color_image\n           o open color_blob, attached to color_image\n           o if (color type has alpha)\n               open alpha_blob, attached to alpha_image\n        */\n\n        color_image_info=(ImageInfo *)AcquireMagickMemory(sizeof(ImageInfo));\n\n        if (color_image_info == (ImageInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        GetImageInfo(color_image_info);\n        color_image=AcquireImage(color_image_info,exception);\n\n        if (color_image == (Image *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Creating color_blob.\");\n\n        (void) AcquireUniqueFilename(color_image->filename);\n        status=OpenBlob(color_image_info,color_image,WriteBinaryBlobMode,\n          exception);\n\n        if (status == MagickFalse)\n          {\n            color_image=DestroyImage(color_image);\n            return(DestroyImageList(image));\n          }\n\n        if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n          {\n            alpha_image_info=(ImageInfo *)\n              AcquireMagickMemory(sizeof(ImageInfo));\n\n            if (alpha_image_info == (ImageInfo *) NULL)\n              {\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            GetImageInfo(alpha_image_info);\n            alpha_image=AcquireImage(alpha_image_info,exception);\n\n            if (alpha_image == (Image *) NULL)\n              {\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Creating alpha_blob.\");\n\n            (void) AcquireUniqueFilename(alpha_image->filename);\n            status=OpenBlob(alpha_image_info,alpha_image,WriteBinaryBlobMode,\n              exception);\n\n            if (status == MagickFalse)\n              {\n                alpha_image=DestroyImage(alpha_image);\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                return(DestroyImageList(image));\n              }\n\n            if (jng_alpha_compression_method == 0)\n              {\n                unsigned char\n                  data[18];\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Writing IHDR chunk to alpha_blob.\");\n\n                (void) WriteBlob(alpha_image,8,(const unsigned char *)\n                  \"\\211PNG\\r\\n\\032\\n\");\n\n                (void) WriteBlobMSBULong(alpha_image,13L);\n                PNGType(data,mng_IHDR);\n                LogPNGChunk(logging,mng_IHDR,13L);\n                PNGLong(data+4,jng_width);\n                PNGLong(data+8,jng_height);\n                data[12]=jng_alpha_sample_depth;\n                data[13]=0; /* color_type gray */\n                data[14]=0; /* compression method 0 */\n                data[15]=0; /* filter_method 0 */\n                data[16]=0; /* interlace_method 0 */\n                (void) WriteBlob(alpha_image,17,data);\n                (void) WriteBlobMSBULong(alpha_image,crc32(0,data,17));\n              }\n          }\n        reading_idat=MagickTrue;\n      }\n\n    if (memcmp(type,mng_JDAT,4) == 0)\n      {\n        /* Copy chunk to color_image->blob */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Copying JDAT chunk data to color_blob.\");\n\n        if (length != 0)\n          {\n            (void) WriteBlob(color_image,length,chunk);\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n          }\n\n        continue;\n      }\n\n    if (memcmp(type,mng_IDAT,4) == 0)\n      {\n        png_byte\n           data[5];\n\n        /* Copy IDAT header and chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying IDAT chunk data to alpha_blob.\");\n\n            (void) WriteBlobMSBULong(alpha_image,(size_t) length);\n            PNGType(data,mng_IDAT);\n            LogPNGChunk(logging,mng_IDAT,length);\n            (void) WriteBlob(alpha_image,4,data);\n            (void) WriteBlob(alpha_image,length,chunk);\n            (void) WriteBlobMSBULong(alpha_image,\n              crc32(crc32(0,data,4),chunk,(uInt) length));\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if ((memcmp(type,mng_JDAA,4) == 0) || (memcmp(type,mng_JdAA,4) == 0))\n      {\n        /* Copy chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying JDAA chunk data to alpha_blob.\");\n\n            (void) WriteBlob(alpha_image,length,chunk);\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_JSEP,4) == 0)\n      {\n        read_JSEP=MagickTrue;\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_bKGD,4) == 0)\n      {\n        if (length == 2)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=image->background_color.red;\n            image->background_color.blue=image->background_color.red;\n          }\n\n        if (length == 6)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=ScaleCharToQuantum(p[3]);\n            image->background_color.blue=ScaleCharToQuantum(p[5]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_gAMA,4) == 0)\n      {\n        if (length == 4)\n          image->gamma=((float) mng_get_long(p))*0.00001;\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_cHRM,4) == 0)\n      {\n        if (length == 32)\n          {\n            image->chromaticity.white_point.x=0.00001*mng_get_long(p);\n            image->chromaticity.white_point.y=0.00001*mng_get_long(&p[4]);\n            image->chromaticity.red_primary.x=0.00001*mng_get_long(&p[8]);\n            image->chromaticity.red_primary.y=0.00001*mng_get_long(&p[12]);\n            image->chromaticity.green_primary.x=0.00001*mng_get_long(&p[16]);\n            image->chromaticity.green_primary.y=0.00001*mng_get_long(&p[20]);\n            image->chromaticity.blue_primary.x=0.00001*mng_get_long(&p[24]);\n            image->chromaticity.blue_primary.y=0.00001*mng_get_long(&p[28]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_sRGB,4) == 0)\n      {\n        if (length == 1)\n          {\n            image->rendering_intent=\n              Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n            image->gamma=1.000f/2.200f;\n            image->chromaticity.red_primary.x=0.6400f;\n            image->chromaticity.red_primary.y=0.3300f;\n            image->chromaticity.green_primary.x=0.3000f;\n            image->chromaticity.green_primary.y=0.6000f;\n            image->chromaticity.blue_primary.x=0.1500f;\n            image->chromaticity.blue_primary.y=0.0600f;\n            image->chromaticity.white_point.x=0.3127f;\n            image->chromaticity.white_point.y=0.3290f;\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_oFFs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->page.x=(ssize_t) mng_get_long(p);\n            image->page.y=(ssize_t) mng_get_long(&p[4]);\n\n            if ((int) p[8] != 0)\n              {\n                image->page.x/=10000;\n                image->page.y/=10000;\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_pHYs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->resolution.x=(double) mng_get_long(p);\n            image->resolution.y=(double) mng_get_long(&p[4]);\n            if ((int) p[8] == PNG_RESOLUTION_METER)\n              {\n                image->units=PixelsPerCentimeterResolution;\n                image->resolution.x=image->resolution.x/100.0f;\n                image->resolution.y=image->resolution.y/100.0f;\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n#if 0\n    if (memcmp(type,mng_iCCP,4) == 0)\n      {\n        /* To do: */\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n#endif\n\n    if (length != 0)\n      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n    if (memcmp(type,mng_IEND,4))\n      continue;\n\n    break;\n  }\n\n\n  /* IEND found */\n\n  /*\n    Finish up reading image data:\n\n       o read main image from color_blob.\n\n       o close color_blob.\n\n       o if (color_type has alpha)\n            if alpha_encoding is PNG\n               read secondary image from alpha_blob via ReadPNG\n            if alpha_encoding is JPEG\n               read secondary image from alpha_blob via ReadJPEG\n\n       o close alpha_blob.\n\n       o copy intensity of secondary image into\n         alpha samples of main image.\n\n       o destroy the secondary image.\n  */\n\n  if (color_image_info == (ImageInfo *) NULL)\n    {\n      assert(color_image == (Image *) NULL);\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  if (color_image == (Image *) NULL)\n    {\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  (void) SeekBlob(color_image,0,SEEK_SET);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading jng_image from color_blob.\");\n\n  assert(color_image_info != (ImageInfo *) NULL);\n  (void) FormatLocaleString(color_image_info->filename,MagickPathExtent,\"%s\",\n    color_image->filename);\n\n  color_image_info->ping=MagickFalse;   /* To do: avoid this */\n  jng_image=ReadImage(color_image_info,exception);\n\n  (void) RelinquishUniqueFileResource(color_image->filename);\n  color_image=DestroyImage(color_image);\n  color_image_info=DestroyImageInfo(color_image_info);\n\n  if (jng_image == (Image *) NULL)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Copying jng_image pixels to main image.\");\n\n  image->rows=jng_height;\n  image->columns=jng_width;\n\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    s=GetVirtualPixels(jng_image,0,y,image->columns,1,exception);\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    for (x=(ssize_t) image->columns; x != 0; x--)\n    {\n      SetPixelRed(image,GetPixelRed(jng_image,s),q);\n      SetPixelGreen(image,GetPixelGreen(jng_image,s),q);\n      SetPixelBlue(image,GetPixelBlue(jng_image,s),q);\n      q+=GetPixelChannels(image);\n      s+=GetPixelChannels(jng_image);\n    }\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n\n  jng_image=DestroyImage(jng_image);\n\n  if (image_info->ping == MagickFalse)\n    {\n     if (jng_color_type >= 12)\n       {\n         if (jng_alpha_compression_method == 0)\n           {\n             png_byte\n               data[5];\n             (void) WriteBlobMSBULong(alpha_image,0x00000000L);\n             PNGType(data,mng_IEND);\n             LogPNGChunk(logging,mng_IEND,0L);\n             (void) WriteBlob(alpha_image,4,data);\n             (void) WriteBlobMSBULong(alpha_image,crc32(0,data,4));\n           }\n\n         (void) CloseBlob(alpha_image);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Reading alpha from alpha_blob.\");\n\n         (void) FormatLocaleString(alpha_image_info->filename,MagickPathExtent,\n           \"%s\",alpha_image->filename);\n\n         jng_image=ReadImage(alpha_image_info,exception);\n\n         if (jng_image != (Image *) NULL)\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             s=GetVirtualPixels(jng_image,0,y,image->columns,1,\n               exception);\n             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (image->alpha_trait != UndefinedPixelTrait)\n               for (x=(ssize_t) image->columns; x != 0; x--)\n               {\n                  SetPixelAlpha(image,GetPixelRed(jng_image,s),q);\n                  q+=GetPixelChannels(image);\n                  s+=GetPixelChannels(jng_image);\n               }\n\n             else\n               for (x=(ssize_t) image->columns; x != 0; x--)\n               {\n                  SetPixelAlpha(image,GetPixelRed(jng_image,s),q);\n                  if (GetPixelAlpha(image,q) != OpaqueAlpha)\n                    image->alpha_trait=BlendPixelTrait;\n                  q+=GetPixelChannels(image);\n                  s+=GetPixelChannels(jng_image);\n               }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n           }\n         (void) RelinquishUniqueFileResource(alpha_image->filename);\n         alpha_image=DestroyImage(alpha_image);\n         alpha_image_info=DestroyImageInfo(alpha_image_info);\n         if (jng_image != (Image *) NULL)\n           jng_image=DestroyImage(jng_image);\n       }\n    }\n\n  /* Read the JNG image.  */\n\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=jng_width;\n      mng_info->mng_height=jng_height;\n    }\n\n  if (image->page.width == 0 && image->page.height == 0)\n    {\n      image->page.width=jng_width;\n      image->page.height=jng_height;\n    }\n\n  if (image->page.x == 0 && image->page.y == 0)\n    {\n      image->page.x=mng_info->x_off[mng_info->object_id];\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  mng_info->image_found++;\n  status=SetImageProgress(image,LoadImagesTag,2*TellBlob(image),\n    2*GetBlobSize(image));\n\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage()\");\n\n  return(image);\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d J N G I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadJNGImage() reads a JPEG Network Graphics (JNG) image file\n%  (including the 8-byte signature)  and returns it.  It allocates the memory\n%  necessary for the new Image structure and returns a pointer to the new\n%  image.\n%\n%  JNG support written by Glenn Randers-Pehrson, glennrp@image...\n%\n%  The format of the ReadJNGImage method is:\n%\n%      Image *ReadJNGImage(const ImageInfo *image_info, ExceptionInfo\n%         *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic Image *ReadJNGImage(const ImageInfo *image_info,\n                ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    logging,\n    status;\n\n  MngInfo\n    *mng_info;\n\n  char\n    magic_number[MagickPathExtent];\n\n  size_t\n    count;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n     image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\"Enter ReadJNGImage()\");\n  image=AcquireImage(image_info,exception);\n  mng_info=(MngInfo *) NULL;\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n\n  if (status == MagickFalse)\n    return((Image *) NULL);\n\n  if (LocaleCompare(image_info->magick,\"JNG\") != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  /* Verify JNG signature.  */\n\n  count=(size_t) ReadBlob(image,8,(unsigned char *) magic_number);\n\n  if (count < 8 || memcmp(magic_number,\"\\213JNG\\r\\n\\032\\n\",8) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  /*\n     Verify that file size large enough to contain a JNG datastream.\n  */\n  if (GetBlobSize(image) < 147)\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n\n  /* Allocate a MngInfo structure.  */\n\n  mng_info=(MngInfo *) AcquireMagickMemory(sizeof(*mng_info));\n\n  if (mng_info == (MngInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* Initialize members of the MngInfo structure.  */\n\n  (void) ResetMagickMemory(mng_info,0,sizeof(MngInfo));\n\n  mng_info->image=image;\n  image=ReadOneJNGImage(mng_info,image_info,exception);\n  mng_info=MngInfoFreeStruct(mng_info);\n\n  if (image == (Image *) NULL)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"exit ReadJNGImage() with error\");\n\n      return((Image *) NULL);\n    }\n  (void) CloseBlob(image);\n\n  if (image->columns == 0 || image->rows == 0)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"exit ReadJNGImage() with error\");\n\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"exit ReadJNGImage()\");\n\n  return(image);\n}\n#endif\n\nstatic Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,\n     ExceptionInfo *exception)\n{\n  char\n    page_geometry[MagickPathExtent];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    logging;\n\n  volatile int\n    first_mng_object,\n    object_id,\n    term_chunk_found,\n    skip_to_iend;\n\n  volatile ssize_t\n    image_count=0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MngBox\n    default_fb,\n    fb,\n    previous_fb;\n\n#if defined(MNG_INSERT_LAYERS)\n  PixelInfo\n    mng_background_color;\n#endif\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  ssize_t\n    loop_level;\n\n  volatile short\n    skipping_loop;\n\n#if defined(MNG_INSERT_LAYERS)\n  unsigned int\n    mandatory_back=0;\n#endif\n\n  volatile unsigned int\n#ifdef MNG_OBJECT_BUFFERS\n    mng_background_object=0,\n#endif\n    mng_type=0;   /* 0: PNG or JNG; 1: MNG; 2: MNG-LC; 3: MNG-VLC */\n\n  size_t\n    default_frame_timeout,\n    frame_timeout,\n#if defined(MNG_INSERT_LAYERS)\n    image_height,\n    image_width,\n#endif\n    length;\n\n  /* These delays are all measured in image ticks_per_second,\n   * not in MNG ticks_per_second\n   */\n  volatile size_t\n    default_frame_delay,\n    final_delay,\n    final_image_delay,\n    frame_delay,\n#if defined(MNG_INSERT_LAYERS)\n    insert_layers,\n#endif\n    mng_iterations=1,\n    simplicity=0,\n    subframe_height=0,\n    subframe_width=0;\n\n  previous_fb.top=0;\n  previous_fb.bottom=0;\n  previous_fb.left=0;\n  previous_fb.right=0;\n  default_fb.top=0;\n  default_fb.bottom=0;\n  default_fb.left=0;\n  default_fb.right=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneMNGImage()\");\n\n  image=mng_info->image;\n\n  if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n    {\n      char\n        magic_number[MagickPathExtent];\n\n      /* Verify MNG signature.  */\n      count=(size_t) ReadBlob(image,8,(unsigned char *) magic_number);\n      if (memcmp(magic_number,\"\\212MNG\\r\\n\\032\\n\",8) != 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n      /* Initialize some nonzero members of the MngInfo structure.  */\n      for (i=0; i < MNG_MAX_OBJECTS; i++)\n      {\n        mng_info->object_clip[i].right=(ssize_t) PNG_UINT_31_MAX;\n        mng_info->object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX;\n      }\n      mng_info->exists[0]=MagickTrue;\n    }\n\n  skipping_loop=(-1);\n  first_mng_object=MagickTrue;\n  mng_type=0;\n#if defined(MNG_INSERT_LAYERS)\n  insert_layers=MagickFalse; /* should be False during convert or mogrify */\n#endif\n  default_frame_delay=0;\n  default_frame_timeout=0;\n  frame_delay=0;\n  final_delay=1;\n  mng_info->ticks_per_second=1UL*image->ticks_per_second;\n  object_id=0;\n  skip_to_iend=MagickFalse;\n  term_chunk_found=MagickFalse;\n  mng_info->framing_mode=1;\n#if defined(MNG_INSERT_LAYERS)\n  mandatory_back=MagickFalse;\n#endif\n#if defined(MNG_INSERT_LAYERS)\n  mng_background_color=image->background_color;\n#endif\n  default_fb=mng_info->frame;\n  previous_fb=mng_info->frame;\n  do\n  {\n    char\n      type[MagickPathExtent];\n\n    if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n      {\n        unsigned char\n          *chunk;\n\n        /*\n          Read a new chunk.\n        */\n        type[0]='\\0';\n        (void) ConcatenateMagickString(type,\"errr\",MagickPathExtent);\n        length=ReadBlobMSBLong(image);\n        count=(size_t) ReadBlob(image,4,(unsigned char *) type);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  Reading MNG chunk type %c%c%c%c, length: %.20g\",\n           type[0],type[1],type[2],type[3],(double) length);\n\n        if (length > PNG_UINT_31_MAX)\n          {\n            status=MagickFalse;\n            break;\n          }\n\n        if (count == 0)\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n        p=NULL;\n        chunk=(unsigned char *) NULL;\n\n        if (length != 0)\n          {\n            if (length > GetBlobSize(image))\n              ThrowReaderException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));\n\n            if (chunk == (unsigned char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n            for (i=0; i < (ssize_t) length; i++)\n            {\n              int\n                c;\n\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                break;\n              chunk[i]=(unsigned char) c;\n            }\n\n            p=chunk;\n          }\n\n        (void) ReadBlobMSBLong(image);  /* read crc word */\n\n#if !defined(JNG_SUPPORTED)\n        if (memcmp(type,mng_JHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->jhdr_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"JNGCompressNotSupported\",\"`%s'\",image->filename);\n\n            mng_info->jhdr_warning++;\n          }\n#endif\n        if (memcmp(type,mng_DHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->dhdr_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"DeltaPNGNotSupported\",\"`%s'\",image->filename);\n\n            mng_info->dhdr_warning++;\n          }\n        if (memcmp(type,mng_MEND,4) == 0)\n          break;\n\n        if (skip_to_iend)\n          {\n            if (memcmp(type,mng_IEND,4) == 0)\n              skip_to_iend=MagickFalse;\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Skip to IEND.\");\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MHDR,4) == 0)\n          {\n            if (length != 28)\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n              }\n\n            mng_info->mng_width=(unsigned long) (((png_uint_32) p[0] << 24) |\n              ((png_uint_32) p[1] << 16) | ((png_uint_32) p[2] << 8) |\n              (png_uint_32) p[3]);\n            mng_info->mng_height=(unsigned long) (((png_uint_32) p[4] << 24) |\n              ((png_uint_32) p[5] << 16) | ((png_uint_32) p[6] << 8) |\n              (png_uint_32) p[7]);\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG width: %.20g\",(double) mng_info->mng_width);\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG height: %.20g\",(double) mng_info->mng_height);\n              }\n\n            p+=8;\n            mng_info->ticks_per_second=(size_t) mng_get_long(p);\n\n            if (mng_info->ticks_per_second == 0)\n              default_frame_delay=0;\n\n            else\n              default_frame_delay=1UL*image->ticks_per_second/\n                mng_info->ticks_per_second;\n\n            frame_delay=default_frame_delay;\n            simplicity=0;\n\n            p+=16;\n            simplicity=(size_t) mng_get_long(p);\n\n            mng_type=1;    /* Full MNG */\n\n            if ((simplicity != 0) && ((simplicity | 11) == 11))\n              mng_type=2; /* LC */\n\n            if ((simplicity != 0) && ((simplicity | 9) == 9))\n              mng_type=3; /* VLC */\n\n#if defined(MNG_INSERT_LAYERS)\n            if (mng_type != 3)\n              insert_layers=MagickTrue;\n#endif\n            if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n              {\n                /* Allocate next image structure.  */\n                AcquireNextImage(image_info,image,exception);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return((Image *) NULL);\n\n                image=SyncNextImageInList(image);\n                mng_info->image=image;\n              }\n\n            if ((mng_info->mng_width > 65535L) ||\n                (mng_info->mng_height > 65535L))\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(ImageError,\"WidthOrHeightExceedsLimit\");\n              }\n\n            (void) FormatLocaleString(page_geometry,MagickPathExtent,\n              \"%.20gx%.20g+0+0\",(double) mng_info->mng_width,(double)\n              mng_info->mng_height);\n\n            mng_info->frame.left=0;\n            mng_info->frame.right=(ssize_t) mng_info->mng_width;\n            mng_info->frame.top=0;\n            mng_info->frame.bottom=(ssize_t) mng_info->mng_height;\n            mng_info->clip=default_fb=previous_fb=mng_info->frame;\n\n            for (i=0; i < MNG_MAX_OBJECTS; i++)\n              mng_info->object_clip[i]=mng_info->frame;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_TERM,4) == 0)\n          {\n            int\n              repeat=0;\n\n            if (length != 0)\n              repeat=p[0];\n\n            if (repeat == 3 && length > 8)\n              {\n                final_delay=(png_uint_32) mng_get_long(&p[2]);\n                mng_iterations=(png_uint_32) mng_get_long(&p[6]);\n\n                if (mng_iterations == PNG_UINT_31_MAX)\n                  mng_iterations=0;\n\n                image->iterations=mng_iterations;\n                term_chunk_found=MagickTrue;\n              }\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    repeat=%d,  final_delay=%.20g,  iterations=%.20g\",\n                  repeat,(double) final_delay, (double) image->iterations);\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_DEFI,4) == 0)\n          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"DEFI chunk found in MNG-VLC datastream\",\"`%s'\",\n                image->filename);\n\n            if (length < 2)\n              {\n                if (chunk)\n                  chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n              }\n\n            object_id=(p[0] << 8) | p[1];\n\n            if (mng_type == 2 && object_id != 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"Nonzero object_id in MNG-LC datastream\",\"`%s'\",\n                image->filename);\n\n            if (object_id > MNG_MAX_OBJECTS)\n              {\n                /*\n                  Instead of using a warning we should allocate a larger\n                  MngInfo structure and continue.\n                */\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  CoderError,\"object id too large\",\"`%s'\",image->filename);\n                object_id=MNG_MAX_OBJECTS;\n              }\n\n            if (mng_info->exists[object_id])\n              if (mng_info->frozen[object_id])\n                {\n                  chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                  (void) ThrowMagickException(exception,\n                    GetMagickModule(),CoderError,\n                    \"DEFI cannot redefine a frozen MNG object\",\"`%s'\",\n                    image->filename);\n                  continue;\n                }\n\n            mng_info->exists[object_id]=MagickTrue;\n\n            if (length > 2)\n              mng_info->invisible[object_id]=p[2];\n\n            /*\n              Extract object offset info.\n            */\n            if (length > 11)\n              {\n                mng_info->x_off[object_id]=(ssize_t)\n                  (((png_uint_32) p[4] << 24) | ((png_uint_32) p[5] << 16) |\n                  ((png_uint_32) p[6] << 8) | (png_uint_32) p[7]);\n                mng_info->y_off[object_id]=(ssize_t)\n                  (((png_uint_32) p[8] << 24) | ((png_uint_32) p[9] << 16) |\n                  ((png_uint_32) p[10] << 8) | (png_uint_32) p[11]);\n                if (logging != MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"  x_off[%d]: %.20g,  y_off[%d]: %.20g\",\n                      object_id,(double) mng_info->x_off[object_id],\n                      object_id,(double) mng_info->y_off[object_id]);\n                  }\n              }\n\n            /*\n              Extract object clipping info.\n            */\n            if (length > 27)\n              mng_info->object_clip[object_id]=mng_read_box(mng_info->frame,0,\n                &p[12]);\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_bKGD,4) == 0)\n          {\n            mng_info->have_global_bkgd=MagickFalse;\n\n            if (length > 5)\n              {\n                mng_info->mng_global_bkgd.red=\n                  ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\n                mng_info->mng_global_bkgd.green=\n                  ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\n                mng_info->mng_global_bkgd.blue=\n                  ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\n                mng_info->have_global_bkgd=MagickTrue;\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_BACK,4) == 0)\n          {\n#if defined(MNG_INSERT_LAYERS)\n            if (length > 6)\n              mandatory_back=p[6];\n\n            else\n              mandatory_back=0;\n\n            if (mandatory_back && length > 5)\n              {\n                mng_background_color.red=\n                    ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\n                mng_background_color.green=\n                    ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\n                mng_background_color.blue=\n                    ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\n                mng_background_color.alpha=OpaqueAlpha;\n              }\n\n#ifdef MNG_OBJECT_BUFFERS\n            if (length > 8)\n              mng_background_object=(p[7] << 8) | p[8];\n#endif\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_PLTE,4) == 0)\n          {\n            /* Read global PLTE.  */\n\n            if (length && (length < 769))\n              {\n                if (mng_info->global_plte == (png_colorp) NULL)\n                  mng_info->global_plte=(png_colorp) AcquireQuantumMemory(256,\n                    sizeof(*mng_info->global_plte));\n\n                for (i=0; i < (ssize_t) (length/3); i++)\n                {\n                  mng_info->global_plte[i].red=p[3*i];\n                  mng_info->global_plte[i].green=p[3*i+1];\n                  mng_info->global_plte[i].blue=p[3*i+2];\n                }\n\n                mng_info->global_plte_length=(unsigned int) (length/3);\n              }\n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n            {\n              mng_info->global_plte[i].red=i;\n              mng_info->global_plte[i].green=i;\n              mng_info->global_plte[i].blue=i;\n            }\n\n            if (length != 0)\n              mng_info->global_plte_length=256;\n#endif\n            else\n              mng_info->global_plte_length=0;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_tRNS,4) == 0)\n          {\n            /* read global tRNS */\n\n            if (length > 0 && length < 257)\n              for (i=0; i < (ssize_t) length; i++)\n                mng_info->global_trns[i]=p[i];\n\n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n              mng_info->global_trns[i]=255;\n#endif\n            mng_info->global_trns_length=(unsigned int) length;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_gAMA,4) == 0)\n          {\n            if (length == 4)\n              {\n                ssize_t\n                  igamma;\n\n                igamma=mng_get_long(p);\n                mng_info->global_gamma=((float) igamma)*0.00001;\n                mng_info->have_global_gama=MagickTrue;\n              }\n\n            else\n              mng_info->have_global_gama=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_cHRM,4) == 0)\n          {\n            /* Read global cHRM */\n\n            if (length == 32)\n              {\n                mng_info->global_chrm.white_point.x=0.00001*mng_get_long(p);\n                mng_info->global_chrm.white_point.y=0.00001*mng_get_long(&p[4]);\n                mng_info->global_chrm.red_primary.x=0.00001*mng_get_long(&p[8]);\n                mng_info->global_chrm.red_primary.y=0.00001*\n                  mng_get_long(&p[12]);\n                mng_info->global_chrm.green_primary.x=0.00001*\n                  mng_get_long(&p[16]);\n                mng_info->global_chrm.green_primary.y=0.00001*\n                  mng_get_long(&p[20]);\n                mng_info->global_chrm.blue_primary.x=0.00001*\n                  mng_get_long(&p[24]);\n                mng_info->global_chrm.blue_primary.y=0.00001*\n                  mng_get_long(&p[28]);\n                mng_info->have_global_chrm=MagickTrue;\n              }\n            else\n              mng_info->have_global_chrm=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_sRGB,4) == 0)\n          {\n            /*\n              Read global sRGB.\n            */\n            if (length != 0)\n              {\n                mng_info->global_srgb_intent=\n                  Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n                mng_info->have_global_srgb=MagickTrue;\n              }\n            else\n              mng_info->have_global_srgb=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_iCCP,4) == 0)\n          {\n            /* To do: */\n\n            /*\n              Read global iCCP.\n            */\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_FRAM,4) == 0)\n          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"FRAM chunk found in MNG-VLC datastream\",\"`%s'\",\n                image->filename);\n\n            if ((mng_info->framing_mode == 2) || (mng_info->framing_mode == 4))\n              image->delay=frame_delay;\n\n            frame_delay=default_frame_delay;\n            frame_timeout=default_frame_timeout;\n            fb=default_fb;\n\n            if (length != 0)\n              if (p[0])\n                mng_info->framing_mode=p[0];\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Framing_mode=%d\",mng_info->framing_mode);\n\n            if (length > 6)\n              {\n                /* Note the delay and frame clipping boundaries.  */\n\n                p++; /* framing mode */\n\n                while (*p && ((p-chunk) < (ssize_t) length))\n                  p++;  /* frame name */\n\n                p++;  /* frame name terminator */\n\n                if ((p-chunk) < (ssize_t) (length-4))\n                  {\n                    int\n                      change_delay,\n                      change_timeout,\n                      change_clipping;\n\n                    change_delay=(*p++);\n                    change_timeout=(*p++);\n                    change_clipping=(*p++);\n                    p++; /* change_sync */\n\n                    if (change_delay && ((p-chunk) < (ssize_t) (length-4)))\n                      {\n                        frame_delay=1UL*image->ticks_per_second*\n                          mng_get_long(p);\n\n                        if (mng_info->ticks_per_second != 0)\n                          frame_delay/=mng_info->ticks_per_second;\n\n                        else\n                          frame_delay=PNG_UINT_31_MAX;\n\n                        if (change_delay == 2)\n                          default_frame_delay=frame_delay;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Framing_delay=%.20g\",(double) frame_delay);\n                      }\n\n                    if (change_timeout && ((p-chunk) < (ssize_t) (length-4)))\n                      {\n                        frame_timeout=1UL*image->ticks_per_second*\n                          mng_get_long(p);\n\n                        if (mng_info->ticks_per_second != 0)\n                          frame_timeout/=mng_info->ticks_per_second;\n\n                        else\n                          frame_timeout=PNG_UINT_31_MAX;\n\n                        if (change_timeout == 2)\n                          default_frame_timeout=frame_timeout;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Framing_timeout=%.20g\",(double) frame_timeout);\n                      }\n\n                    if (change_clipping && ((p-chunk) < (ssize_t) (length-16)))\n                      {\n                        fb=mng_read_box(previous_fb,(char) p[0],&p[1]);\n                        p+=16;\n                        previous_fb=fb;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Frame_clip: L=%.20g R=%.20g T=%.20g B=%.20g\",\n                            (double) fb.left,(double) fb.right,(double) fb.top,\n                            (double) fb.bottom);\n\n                        if (change_clipping == 2)\n                          default_fb=fb;\n                      }\n                  }\n              }\n            mng_info->clip=fb;\n            mng_info->clip=mng_minimum_box(fb,mng_info->frame);\n\n            subframe_width=(size_t) (mng_info->clip.right\n               -mng_info->clip.left);\n\n            subframe_height=(size_t) (mng_info->clip.bottom\n               -mng_info->clip.top);\n            /*\n              Insert a background layer behind the frame if framing_mode is 4.\n            */\n#if defined(MNG_INSERT_LAYERS)\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"   subframe_width=%.20g, subframe_height=%.20g\",(double)\n                subframe_width,(double) subframe_height);\n\n            if (insert_layers && (mng_info->framing_mode == 4) &&\n                (subframe_width) && (subframe_height))\n              {\n                /* Allocate next image structure.  */\n                if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n                  {\n                    AcquireNextImage(image_info,image,exception);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n\n                mng_info->image=image;\n\n                if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\n                image->columns=subframe_width;\n                image->rows=subframe_height;\n                image->page.width=subframe_width;\n                image->page.height=subframe_height;\n                image->page.x=mng_info->clip.left;\n                image->page.y=mng_info->clip.top;\n                image->background_color=mng_background_color;\n                image->alpha_trait=UndefinedPixelTrait;\n                image->delay=0;\n                (void) SetImageBackgroundColor(image,exception);\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Insert backgd layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                    (double) mng_info->clip.left,\n                    (double) mng_info->clip.right,\n                    (double) mng_info->clip.top,\n                    (double) mng_info->clip.bottom);\n              }\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_CLIP,4) == 0)\n          {\n            unsigned int\n              first_object,\n              last_object;\n\n            /*\n              Read CLIP.\n            */\n            if (length > 3)\n              {\n                first_object=(p[0] << 8) | p[1];\n                last_object=(p[2] << 8) | p[3];\n                p+=4;\n\n                for (i=(int) first_object; i <= (int) last_object; i++)\n                {\n                  if ((i < 0) || (i >= MNG_MAX_OBJECTS))\n                    continue;\n\n                  if (mng_info->exists[i] && !mng_info->frozen[i])\n                    {\n                      MngBox\n                        box;\n\n                      box=mng_info->object_clip[i];\n                      if ((p-chunk) < (ssize_t) (length-17))\n                        mng_info->object_clip[i]=\n                           mng_read_box(box,(char) p[0],&p[1]);\n                    }\n                }\n\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_SAVE,4) == 0)\n          {\n            for (i=1; i < MNG_MAX_OBJECTS; i++)\n              if (mng_info->exists[i])\n                {\n                 mng_info->frozen[i]=MagickTrue;\n#ifdef MNG_OBJECT_BUFFERS\n                 if (mng_info->ob[i] != (MngBuffer *) NULL)\n                    mng_info->ob[i]->frozen=MagickTrue;\n#endif\n                }\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if ((memcmp(type,mng_DISC,4) == 0) || (memcmp(type,mng_SEEK,4) == 0))\n          {\n            /* Read DISC or SEEK.  */\n\n            if ((length == 0) || !memcmp(type,mng_SEEK,4))\n              {\n                for (i=1; i < MNG_MAX_OBJECTS; i++)\n                  MngInfoDiscardObject(mng_info,i);\n              }\n\n            else\n              {\n                register ssize_t\n                  j;\n\n                for (j=1; j < (ssize_t) length; j+=2)\n                {\n                  i=p[j-1] << 8 | p[j];\n                  MngInfoDiscardObject(mng_info,i);\n                }\n              }\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MOVE,4) == 0)\n          {\n            size_t\n              first_object,\n              last_object;\n\n            /* read MOVE */\n\n            if (length > 3)\n            {\n              first_object=(p[0] << 8) | p[1];\n              last_object=(p[2] << 8) | p[3];\n              p+=4;\n\n              for (i=(ssize_t) first_object; i <= (ssize_t) last_object; i++)\n              {\n                if ((i < 0) || (i >= MNG_MAX_OBJECTS))\n                  continue;\n\n                if (mng_info->exists[i] && !mng_info->frozen[i] &&\n                    (p-chunk) < (ssize_t) (length-8))\n                  {\n                    MngPair\n                      new_pair;\n\n                    MngPair\n                      old_pair;\n\n                    old_pair.a=mng_info->x_off[i];\n                    old_pair.b=mng_info->y_off[i];\n                    new_pair=mng_read_pair(old_pair,(int) p[0],&p[1]);\n                    mng_info->x_off[i]=new_pair.a;\n                    mng_info->y_off[i]=new_pair.b;\n                  }\n              }\n            }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_LOOP,4) == 0)\n          {\n            ssize_t loop_iters=1;\n            if (length > 4)\n              {\n                loop_level=chunk[0];\n                mng_info->loop_active[loop_level]=1;  /* mark loop active */\n\n                /* Record starting point.  */\n                loop_iters=mng_get_long(&chunk[1]);\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  LOOP level %.20g has %.20g iterations \",\n                    (double) loop_level, (double) loop_iters);\n\n                if (loop_iters == 0)\n                  skipping_loop=loop_level;\n\n                else\n                  {\n                    mng_info->loop_jump[loop_level]=TellBlob(image);\n                    mng_info->loop_count[loop_level]=loop_iters;\n                  }\n\n                mng_info->loop_iteration[loop_level]=0;\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_ENDL,4) == 0)\n          {\n            if (length > 0)\n              {\n                loop_level=chunk[0];\n\n                if (skipping_loop > 0)\n                  {\n                    if (skipping_loop == loop_level)\n                      {\n                        /*\n                          Found end of zero-iteration loop.\n                        */\n                        skipping_loop=(-1);\n                        mng_info->loop_active[loop_level]=0;\n                      }\n                  }\n\n                else\n                  {\n                    if (mng_info->loop_active[loop_level] == 1)\n                      {\n                        mng_info->loop_count[loop_level]--;\n                        mng_info->loop_iteration[loop_level]++;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  ENDL: LOOP level %.20g has %.20g remaining iters\",\n                            (double) loop_level,(double)\n                            mng_info->loop_count[loop_level]);\n\n                        if (mng_info->loop_count[loop_level] != 0)\n                          {\n                            offset=\n                              SeekBlob(image,mng_info->loop_jump[loop_level],\n                              SEEK_SET);\n\n                            if (offset < 0)\n                              {\n                                chunk=(unsigned char *) RelinquishMagickMemory(\n                                  chunk);\n                                ThrowReaderException(CorruptImageError,\n                                  \"ImproperImageHeader\");\n                              }\n                          }\n\n                        else\n                          {\n                            short\n                              last_level;\n\n                            /*\n                              Finished loop.\n                            */\n                            mng_info->loop_active[loop_level]=0;\n                            last_level=(-1);\n                            for (i=0; i < loop_level; i++)\n                              if (mng_info->loop_active[i] == 1)\n                                last_level=(short) i;\n                            loop_level=last_level;\n                          }\n                      }\n                  }\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_CLON,4) == 0)\n          {\n            if (mng_info->clon_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"CLON is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->clon_warning++;\n          }\n\n        if (memcmp(type,mng_MAGN,4) == 0)\n          {\n            png_uint_16\n              magn_first,\n              magn_last,\n              magn_mb,\n              magn_ml,\n              magn_mr,\n              magn_mt,\n              magn_mx,\n              magn_my,\n              magn_methx,\n              magn_methy;\n\n            if (length > 1)\n              magn_first=(p[0] << 8) | p[1];\n\n            else\n              magn_first=0;\n\n            if (length > 3)\n              magn_last=(p[2] << 8) | p[3];\n\n            else\n              magn_last=magn_first;\n#ifndef MNG_OBJECT_BUFFERS\n            if (magn_first || magn_last)\n              if (mng_info->magn_warning == 0)\n                {\n                  (void) ThrowMagickException(exception,\n                     GetMagickModule(),CoderError,\n                     \"MAGN is not implemented yet for nonzero objects\",\n                     \"`%s'\",image->filename);\n\n                   mng_info->magn_warning++;\n                }\n#endif\n            if (length > 4)\n              magn_methx=p[4];\n\n            else\n              magn_methx=0;\n\n            if (length > 6)\n              magn_mx=(p[5] << 8) | p[6];\n\n            else\n              magn_mx=1;\n\n            if (magn_mx == 0)\n              magn_mx=1;\n\n            if (length > 8)\n              magn_my=(p[7] << 8) | p[8];\n\n            else\n              magn_my=magn_mx;\n\n            if (magn_my == 0)\n              magn_my=1;\n\n            if (length > 10)\n              magn_ml=(p[9] << 8) | p[10];\n\n            else\n              magn_ml=magn_mx;\n\n            if (magn_ml == 0)\n              magn_ml=1;\n\n            if (length > 12)\n              magn_mr=(p[11] << 8) | p[12];\n\n            else\n              magn_mr=magn_mx;\n\n            if (magn_mr == 0)\n              magn_mr=1;\n\n            if (length > 14)\n              magn_mt=(p[13] << 8) | p[14];\n\n            else\n              magn_mt=magn_my;\n\n            if (magn_mt == 0)\n              magn_mt=1;\n\n            if (length > 16)\n              magn_mb=(p[15] << 8) | p[16];\n\n            else\n              magn_mb=magn_my;\n\n            if (magn_mb == 0)\n              magn_mb=1;\n\n            if (length > 17)\n              magn_methy=p[17];\n\n            else\n              magn_methy=magn_methx;\n\n\n            if (magn_methx > 5 || magn_methy > 5)\n              if (mng_info->magn_warning == 0)\n                {\n                  (void) ThrowMagickException(exception,\n                     GetMagickModule(),CoderError,\n                     \"Unknown MAGN method in MNG datastream\",\"`%s'\",\n                     image->filename);\n\n                   mng_info->magn_warning++;\n                }\n#ifdef MNG_OBJECT_BUFFERS\n          /* Magnify existing objects in the range magn_first to magn_last */\n#endif\n            if (magn_first == 0 || magn_last == 0)\n              {\n                /* Save the magnification factors for object 0 */\n                mng_info->magn_mb=magn_mb;\n                mng_info->magn_ml=magn_ml;\n                mng_info->magn_mr=magn_mr;\n                mng_info->magn_mt=magn_mt;\n                mng_info->magn_mx=magn_mx;\n                mng_info->magn_my=magn_my;\n                mng_info->magn_methx=magn_methx;\n                mng_info->magn_methy=magn_methy;\n              }\n          }\n\n        if (memcmp(type,mng_PAST,4) == 0)\n          {\n            if (mng_info->past_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"PAST is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->past_warning++;\n          }\n\n        if (memcmp(type,mng_SHOW,4) == 0)\n          {\n            if (mng_info->show_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"SHOW is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->show_warning++;\n          }\n\n        if (memcmp(type,mng_sBIT,4) == 0)\n          {\n            if (length < 4)\n              mng_info->have_global_sbit=MagickFalse;\n\n            else\n              {\n                mng_info->global_sbit.gray=p[0];\n                mng_info->global_sbit.red=p[0];\n                mng_info->global_sbit.green=p[1];\n                mng_info->global_sbit.blue=p[2];\n                mng_info->global_sbit.alpha=p[3];\n                mng_info->have_global_sbit=MagickTrue;\n             }\n          }\n        if (memcmp(type,mng_pHYs,4) == 0)\n          {\n            if (length > 8)\n              {\n                mng_info->global_x_pixels_per_unit=\n                    (size_t) mng_get_long(p);\n                mng_info->global_y_pixels_per_unit=\n                    (size_t) mng_get_long(&p[4]);\n                mng_info->global_phys_unit_type=p[8];\n                mng_info->have_global_phys=MagickTrue;\n              }\n\n            else\n              mng_info->have_global_phys=MagickFalse;\n          }\n        if (memcmp(type,mng_pHYg,4) == 0)\n          {\n            if (mng_info->phyg_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"pHYg is not implemented.\",\"`%s'\",image->filename);\n\n            mng_info->phyg_warning++;\n          }\n        if (memcmp(type,mng_BASI,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->basi_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"BASI is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->basi_warning++;\n#ifdef MNG_BASI_SUPPORTED\n            basi_width=(unsigned long) (((png_uint_32) p[0] << 24) |\n              ((png_uint_32) p[1] << 16) | ((png_uint_32) p[2] << 8) |\n              (png_uint_32) p[3]);\n            basi_height=(unsigned long) (((png_uint_32) p[4] << 24) |\n              ((png_uint_32) p[5] << 16) | ((png_uint_32) p[6] << 8) |\n              (png_uint_32) p[7]);\n            basi_color_type=p[8];\n            basi_compression_method=p[9];\n            basi_filter_type=p[10];\n            basi_interlace_method=p[11];\n            if (length > 11)\n              basi_red=((png_uint_32) p[12] << 8) & (png_uint_32) p[13];\n\n            else\n              basi_red=0;\n\n            if (length > 13)\n              basi_green=((png_uint_32) p[14] << 8) & (png_uint_32) p[15];\n\n            else\n              basi_green=0;\n\n            if (length > 15)\n              basi_blue=((png_uint_32) p[16] << 8) & (png_uint_32) p[17];\n\n            else\n              basi_blue=0;\n\n            if (length > 17)\n              basi_alpha=((png_uint_32) p[18] << 8) & (png_uint_32) p[19];\n\n            else\n              {\n                if (basi_sample_depth == 16)\n                  basi_alpha=65535L;\n                else\n                  basi_alpha=255;\n              }\n\n            if (length > 19)\n              basi_viewable=p[20];\n\n            else\n              basi_viewable=0;\n\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_IHDR,4)\n#if defined(JNG_SUPPORTED)\n            && memcmp(type,mng_JHDR,4)\n#endif\n            )\n          {\n            /* Not an IHDR or JHDR chunk */\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n/* Process IHDR */\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Processing %c%c%c%c chunk\",type[0],type[1],type[2],type[3]);\n\n        mng_info->exists[object_id]=MagickTrue;\n        mng_info->viewable[object_id]=MagickTrue;\n\n        if (mng_info->invisible[object_id])\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Skipping invisible object\");\n\n            skip_to_iend=MagickTrue;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n#if defined(MNG_INSERT_LAYERS)\n        if (length < 8)\n          {\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          }\n\n        image_width=(size_t) mng_get_long(p);\n        image_height=(size_t) mng_get_long(&p[4]);\n#endif\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        /*\n          Insert a transparent background layer behind the entire animation\n          if it is not full screen.\n        */\n#if defined(MNG_INSERT_LAYERS)\n        if (insert_layers && mng_type && first_mng_object)\n          {\n            if ((mng_info->clip.left > 0) || (mng_info->clip.top > 0) ||\n                (image_width < mng_info->mng_width) ||\n                (mng_info->clip.right < (ssize_t) mng_info->mng_width) ||\n                (image_height < mng_info->mng_height) ||\n                (mng_info->clip.bottom < (ssize_t) mng_info->mng_height))\n              {\n                if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n                  {\n                    /*\n                      Allocate next image structure.\n                    */\n                    AcquireNextImage(image_info,image,exception);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n                mng_info->image=image;\n\n                if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\n                /* Make a background rectangle.  */\n\n                image->delay=0;\n                image->columns=mng_info->mng_width;\n                image->rows=mng_info->mng_height;\n                image->page.width=mng_info->mng_width;\n                image->page.height=mng_info->mng_height;\n                image->page.x=0;\n                image->page.y=0;\n                image->background_color=mng_background_color;\n                (void) SetImageBackgroundColor(image,exception);\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Inserted transparent background layer, W=%.20g, H=%.20g\",\n                    (double) mng_info->mng_width,(double) mng_info->mng_height);\n              }\n          }\n        /*\n          Insert a background layer behind the upcoming image if\n          framing_mode is 3, and we haven't already inserted one.\n        */\n        if (insert_layers && (mng_info->framing_mode == 3) &&\n                (subframe_width) && (subframe_height) && (simplicity == 0 ||\n                (simplicity & 0x08)))\n          {\n            if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n            {\n              /*\n                Allocate next image structure.\n              */\n              AcquireNextImage(image_info,image,exception);\n\n              if (GetNextImageInList(image) == (Image *) NULL)\n                return(DestroyImageList(image));\n\n              image=SyncNextImageInList(image);\n            }\n\n            mng_info->image=image;\n\n            if (term_chunk_found)\n              {\n                image->start_loop=MagickTrue;\n                image->iterations=mng_iterations;\n                term_chunk_found=MagickFalse;\n              }\n\n            else\n                image->start_loop=MagickFalse;\n\n            image->delay=0;\n            image->columns=subframe_width;\n            image->rows=subframe_height;\n            image->page.width=subframe_width;\n            image->page.height=subframe_height;\n            image->page.x=mng_info->clip.left;\n            image->page.y=mng_info->clip.top;\n            image->background_color=mng_background_color;\n            image->alpha_trait=UndefinedPixelTrait;\n            (void) SetImageBackgroundColor(image,exception);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Insert background layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                (double) mng_info->clip.left,(double) mng_info->clip.right,\n                (double) mng_info->clip.top,(double) mng_info->clip.bottom);\n          }\n#endif /* MNG_INSERT_LAYERS */\n        first_mng_object=MagickFalse;\n\n        if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n          {\n            /*\n              Allocate next image structure.\n            */\n            AcquireNextImage(image_info,image,exception);\n\n            if (GetNextImageInList(image) == (Image *) NULL)\n              return(DestroyImageList(image));\n\n            image=SyncNextImageInList(image);\n          }\n        mng_info->image=image;\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n\n        if (status == MagickFalse)\n          break;\n\n        if (term_chunk_found)\n          {\n            image->start_loop=MagickTrue;\n            term_chunk_found=MagickFalse;\n          }\n\n        else\n            image->start_loop=MagickFalse;\n\n        if (mng_info->framing_mode == 1 || mng_info->framing_mode == 3)\n          {\n            image->delay=frame_delay;\n            frame_delay=default_frame_delay;\n          }\n\n        else\n          image->delay=0;\n\n        image->page.width=mng_info->mng_width;\n        image->page.height=mng_info->mng_height;\n        image->page.x=mng_info->x_off[object_id];\n        image->page.y=mng_info->y_off[object_id];\n        image->iterations=mng_iterations;\n\n        /*\n          Seek back to the beginning of the IHDR or JHDR chunk's length field.\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Seeking back to beginning of %c%c%c%c chunk\",type[0],type[1],\n            type[2],type[3]);\n\n        offset=SeekBlob(image,-((ssize_t) length+12),SEEK_CUR);\n\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n\n    mng_info->image=image;\n    mng_info->mng_type=mng_type;\n    mng_info->object_id=object_id;\n\n    if (memcmp(type,mng_IHDR,4) == 0)\n      image=ReadOnePNGImage(mng_info,image_info,exception);\n\n#if defined(JNG_SUPPORTED)\n    else\n      image=ReadOneJNGImage(mng_info,image_info,exception);\n#endif\n\n    if (image == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"exit ReadJNGImage() with error\");\n\n        return((Image *) NULL);\n      }\n\n    if (image->columns == 0 || image->rows == 0)\n      {\n        (void) CloseBlob(image);\n        return(DestroyImageList(image));\n      }\n\n    mng_info->image=image;\n\n    if (mng_type)\n      {\n        MngBox\n          crop_box;\n\n        if (mng_info->magn_methx || mng_info->magn_methy)\n          {\n            png_uint_32\n               magnified_height,\n               magnified_width;\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Processing MNG MAGN chunk\");\n\n            if (mng_info->magn_methx == 1)\n              {\n                magnified_width=mng_info->magn_ml;\n\n                if (image->columns > 1)\n                   magnified_width += mng_info->magn_mr;\n\n                if (image->columns > 2)\n                   magnified_width += (png_uint_32)\n                      ((image->columns-2)*(mng_info->magn_mx));\n              }\n\n            else\n              {\n                magnified_width=(png_uint_32) image->columns;\n\n                if (image->columns > 1)\n                   magnified_width += mng_info->magn_ml-1;\n\n                if (image->columns > 2)\n                   magnified_width += mng_info->magn_mr-1;\n\n                if (image->columns > 3)\n                   magnified_width += (png_uint_32)\n                      ((image->columns-3)*(mng_info->magn_mx-1));\n              }\n\n            if (mng_info->magn_methy == 1)\n              {\n                magnified_height=mng_info->magn_mt;\n\n                if (image->rows > 1)\n                   magnified_height += mng_info->magn_mb;\n\n                if (image->rows > 2)\n                   magnified_height += (png_uint_32)\n                      ((image->rows-2)*(mng_info->magn_my));\n              }\n\n            else\n              {\n                magnified_height=(png_uint_32) image->rows;\n\n                if (image->rows > 1)\n                   magnified_height += mng_info->magn_mt-1;\n\n                if (image->rows > 2)\n                   magnified_height += mng_info->magn_mb-1;\n\n                if (image->rows > 3)\n                   magnified_height += (png_uint_32)\n                      ((image->rows-3)*(mng_info->magn_my-1));\n              }\n\n            if (magnified_height > image->rows ||\n                magnified_width > image->columns)\n              {\n                Image\n                  *large_image;\n\n                int\n                  yy;\n\n                Quantum\n                  *next,\n                  *prev;\n\n                png_uint_16\n                  magn_methx,\n                  magn_methy;\n\n                ssize_t\n                  m,\n                  y;\n\n                register Quantum\n                  *n,\n                  *q;\n\n                register ssize_t\n                  x;\n\n                /* Allocate next image structure.  */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Allocate magnified image\");\n\n                AcquireNextImage(image_info,image,exception);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return(DestroyImageList(image));\n\n                large_image=SyncNextImageInList(image);\n\n                large_image->columns=magnified_width;\n                large_image->rows=magnified_height;\n\n                magn_methx=mng_info->magn_methx;\n                magn_methy=mng_info->magn_methy;\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n#define QM unsigned short\n                if (magn_methx != 1 || magn_methy != 1)\n                  {\n                  /*\n                     Scale pixels to unsigned shorts to prevent\n                     overflow of intermediate values of interpolations\n                  */\n                     for (y=0; y < (ssize_t) image->rows; y++)\n                     {\n                       q=GetAuthenticPixels(image,0,y,image->columns,1,\n                          exception);\n\n                       for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                       {\n                          SetPixelRed(image,ScaleQuantumToShort(\n                            GetPixelRed(image,q)),q);\n                          SetPixelGreen(image,ScaleQuantumToShort(\n                            GetPixelGreen(image,q)),q);\n                          SetPixelBlue(image,ScaleQuantumToShort(\n                            GetPixelBlue(image,q)),q);\n                          SetPixelAlpha(image,ScaleQuantumToShort(\n                            GetPixelAlpha(image,q)),q);\n                          q+=GetPixelChannels(image);\n                       }\n\n                       if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                         break;\n                     }\n                  }\n#else\n#define QM Quantum\n#endif\n\n                if (image->alpha_trait != UndefinedPixelTrait)\n                   (void) SetImageBackgroundColor(large_image,exception);\n\n                else\n                  {\n                    large_image->background_color.alpha=OpaqueAlpha;\n                    (void) SetImageBackgroundColor(large_image,exception);\n\n                    if (magn_methx == 4)\n                      magn_methx=2;\n\n                    if (magn_methx == 5)\n                      magn_methx=3;\n\n                    if (magn_methy == 4)\n                      magn_methy=2;\n\n                    if (magn_methy == 5)\n                      magn_methy=3;\n                  }\n\n                /* magnify the rows into the right side of the large image */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Magnify the rows to %.20g\",\n                    (double) large_image->rows);\n                m=(ssize_t) mng_info->magn_mt;\n                yy=0;\n                length=(size_t) GetPixelChannels(image)*image->columns;\n                next=(Quantum *) AcquireQuantumMemory(length,sizeof(*next));\n                prev=(Quantum *) AcquireQuantumMemory(length,sizeof(*prev));\n\n                if ((prev == (Quantum *) NULL) ||\n                    (next == (Quantum *) NULL))\n                  {\n                     image=DestroyImageList(image);\n                     ThrowReaderException(ResourceLimitError,\n                       \"MemoryAllocationFailed\");\n                  }\n\n                n=GetAuthenticPixels(image,0,0,image->columns,1,exception);\n                (void) CopyMagickMemory(next,n,length);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n                {\n                  if (y == 0)\n                    m=(ssize_t) mng_info->magn_mt;\n\n                  else if (magn_methy > 1 && y == (ssize_t) image->rows-2)\n                    m=(ssize_t) mng_info->magn_mb;\n\n                  else if (magn_methy <= 1 && y == (ssize_t) image->rows-1)\n                    m=(ssize_t) mng_info->magn_mb;\n\n                  else if (magn_methy > 1 && y == (ssize_t) image->rows-1)\n                    m=1;\n\n                  else\n                    m=(ssize_t) mng_info->magn_my;\n\n                  n=prev;\n                  prev=next;\n                  next=n;\n\n                  if (y < (ssize_t) image->rows-1)\n                    {\n                      n=GetAuthenticPixels(image,0,y+1,image->columns,1,\n                          exception);\n                      (void) CopyMagickMemory(next,n,length);\n                    }\n\n                  for (i=0; i < m; i++, yy++)\n                  {\n                    register Quantum\n                      *pixels;\n\n                    assert(yy < (ssize_t) large_image->rows);\n                    pixels=prev;\n                    n=next;\n                    q=GetAuthenticPixels(large_image,0,yy,large_image->columns,\n                      1,exception);\n                    q+=(large_image->columns-image->columns)*\n                      GetPixelChannels(large_image);\n\n                    for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                    {\n                      /* To do: get color as function of indexes[x] */\n                      /*\n                      if (image->storage_class == PseudoClass)\n                        {\n                        }\n                      */\n\n                      if (magn_methy <= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRed(large_image,GetPixelRed(image,pixels),q);\n                          SetPixelGreen(large_image,GetPixelGreen(image,\n                             pixels),q);\n                          SetPixelBlue(large_image,GetPixelBlue(image,\n                             pixels),q);\n                          SetPixelAlpha(large_image,GetPixelAlpha(image,\n                             pixels),q);\n                        }\n\n                      else if (magn_methy == 2 || magn_methy == 4)\n                        {\n                          if (i == 0)\n                            {\n                              SetPixelRed(large_image,GetPixelRed(image,\n                                 pixels),q);\n                              SetPixelGreen(large_image,GetPixelGreen(image,\n                                 pixels),q);\n                              SetPixelBlue(large_image,GetPixelBlue(image,\n                                 pixels),q);\n                              SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                 pixels),q);\n                            }\n\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(large_image,((QM) (((ssize_t)\n                                 (2*i*(GetPixelRed(image,n)\n                                 -GetPixelRed(image,pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelRed(image,pixels)))),q);\n                              SetPixelGreen(large_image,((QM) (((ssize_t)\n                                 (2*i*(GetPixelGreen(image,n)\n                                 -GetPixelGreen(image,pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelGreen(image,pixels)))),q);\n                              SetPixelBlue(large_image,((QM) (((ssize_t)\n                                 (2*i*(GetPixelBlue(image,n)\n                                 -GetPixelBlue(image,pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelBlue(image,pixels)))),q);\n\n                              if (image->alpha_trait != UndefinedPixelTrait)\n                                 SetPixelAlpha(large_image, ((QM) (((ssize_t)\n                                    (2*i*(GetPixelAlpha(image,n)\n                                    -GetPixelAlpha(image,pixels)+m))\n                                    /((ssize_t) (m*2))+\n                                   GetPixelAlpha(image,pixels)))),q);\n                            }\n\n                          if (magn_methy == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i <= ((m+1) << 1))\n                                 SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                    pixels),q);\n                              else\n                                 SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                    n),q);\n                            }\n                        }\n\n                      else /* if (magn_methy == 3 || magn_methy == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n                          {\n                             SetPixelRed(large_image,GetPixelRed(image,\n                                    pixels),q);\n                             SetPixelGreen(large_image,GetPixelGreen(image,\n                                    pixels),q);\n                             SetPixelBlue(large_image,GetPixelBlue(image,\n                                    pixels),q);\n                             SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                    pixels),q);\n                          }\n\n                          else\n                          {\n                             SetPixelRed(large_image,GetPixelRed(image,n),q);\n                             SetPixelGreen(large_image,GetPixelGreen(image,n),\n                                    q);\n                             SetPixelBlue(large_image,GetPixelBlue(image,n),\n                                    q);\n                             SetPixelAlpha(large_image,GetPixelAlpha(image,n),\n                                    q);\n                          }\n\n                          if (magn_methy == 5)\n                            {\n                              SetPixelAlpha(large_image,(QM) (((ssize_t) (2*i*\n                                 (GetPixelAlpha(image,n)\n                                 -GetPixelAlpha(image,pixels))\n                                 +m))/((ssize_t) (m*2))\n                                 +GetPixelAlpha(image,pixels)),q);\n                            }\n                        }\n                      n+=GetPixelChannels(image);\n                      q+=GetPixelChannels(large_image);\n                      pixels+=GetPixelChannels(image);\n                    } /* x */\n\n                    if (SyncAuthenticPixels(large_image,exception) == 0)\n                      break;\n\n                  } /* i */\n                } /* y */\n\n                prev=(Quantum *) RelinquishMagickMemory(prev);\n                next=(Quantum *) RelinquishMagickMemory(next);\n\n                length=image->columns;\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Delete original image\");\n\n                DeleteImageFromList(&image);\n\n                image=large_image;\n\n                mng_info->image=image;\n\n                /* magnify the columns */\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Magnify the columns to %.20g\",\n                    (double) image->columns);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n                {\n                  register Quantum\n                    *pixels;\n\n                  q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n                  pixels=q+(image->columns-length)*GetPixelChannels(image);\n                  n=pixels+GetPixelChannels(image);\n\n                  for (x=(ssize_t) (image->columns-length);\n                    x < (ssize_t) image->columns; x++)\n                  {\n                    /* To do: Rewrite using Get/Set***PixelChannel() */\n\n                    if (x == (ssize_t) (image->columns-length))\n                      m=(ssize_t) mng_info->magn_ml;\n\n                    else if (magn_methx > 1 && x == (ssize_t) image->columns-2)\n                      m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx <= 1 &&\n                        x == (ssize_t) image->columns-1)\n                      m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx > 1 && x == (ssize_t) image->columns-1)\n                      m=1;\n\n                    else\n                      m=(ssize_t) mng_info->magn_mx;\n\n                    for (i=0; i < m; i++)\n                    {\n                      if (magn_methx <= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRed(image,GetPixelRed(image,pixels),q);\n                          SetPixelGreen(image,GetPixelGreen(image,pixels),q);\n                          SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n                          SetPixelAlpha(image,GetPixelAlpha(image,pixels),q);\n                        }\n\n                      else if (magn_methx == 2 || magn_methx == 4)\n                        {\n                          if (i == 0)\n                          {\n                            SetPixelRed(image,GetPixelRed(image,pixels),q);\n                            SetPixelGreen(image,GetPixelGreen(image,pixels),q);\n                            SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n                            SetPixelAlpha(image,GetPixelAlpha(image,pixels),q);\n                          }\n\n                          /* To do: Rewrite using Get/Set***PixelChannel() */\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(image,(QM) ((2*i*(\n                                 GetPixelRed(image,n)\n                                 -GetPixelRed(image,pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelRed(image,pixels)),q);\n\n                              SetPixelGreen(image,(QM) ((2*i*(\n                                 GetPixelGreen(image,n)\n                                 -GetPixelGreen(image,pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelGreen(image,pixels)),q);\n\n                              SetPixelBlue(image,(QM) ((2*i*(\n                                 GetPixelBlue(image,n)\n                                 -GetPixelBlue(image,pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelBlue(image,pixels)),q);\n                              if (image->alpha_trait != UndefinedPixelTrait)\n                                 SetPixelAlpha(image,(QM) ((2*i*(\n                                   GetPixelAlpha(image,n)\n                                   -GetPixelAlpha(image,pixels))+m)\n                                   /((ssize_t) (m*2))+\n                                   GetPixelAlpha(image,pixels)),q);\n                            }\n\n                          if (magn_methx == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i <= ((m+1) << 1))\n                              {\n                                 SetPixelAlpha(image,\n                                   GetPixelAlpha(image,pixels)+0,q);\n                              }\n                              else\n                              {\n                                 SetPixelAlpha(image,\n                                   GetPixelAlpha(image,n)+0,q);\n                              }\n                            }\n                        }\n\n                      else /* if (magn_methx == 3 || magn_methx == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n                          {\n                             SetPixelRed(image,GetPixelRed(image,pixels),q);\n                             SetPixelGreen(image,GetPixelGreen(image,\n                                 pixels),q);\n                             SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n                             SetPixelAlpha(image,GetPixelAlpha(image,\n                                 pixels),q);\n                          }\n\n                          else\n                          {\n                             SetPixelRed(image,GetPixelRed(image,n),q);\n                             SetPixelGreen(image,GetPixelGreen(image,n),q);\n                             SetPixelBlue(image,GetPixelBlue(image,n),q);\n                             SetPixelAlpha(image,GetPixelAlpha(image,n),q);\n                          }\n\n                          if (magn_methx == 5)\n                            {\n                              /* Interpolate */\n                              SetPixelAlpha(image,\n                                 (QM) ((2*i*( GetPixelAlpha(image,n)\n                                 -GetPixelAlpha(image,pixels))+m)/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelAlpha(image,pixels)),q);\n                            }\n                        }\n                      q+=GetPixelChannels(image);\n                    }\n                    n+=GetPixelChannels(image);\n                  }\n\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                    break;\n                }\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n              if (magn_methx != 1 || magn_methy != 1)\n                {\n                /*\n                   Rescale pixels to Quantum\n                */\n                   for (y=0; y < (ssize_t) image->rows; y++)\n                   {\n                     q=GetAuthenticPixels(image,0,y,image->columns,1,\n                       exception);\n\n                     for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                     {\n                        SetPixelRed(image,ScaleShortToQuantum(\n                          GetPixelRed(image,q)),q);\n                        SetPixelGreen(image,ScaleShortToQuantum(\n                          GetPixelGreen(image,q)),q);\n                        SetPixelBlue(image,ScaleShortToQuantum(\n                          GetPixelBlue(image,q)),q);\n                        SetPixelAlpha(image,ScaleShortToQuantum(\n                          GetPixelAlpha(image,q)),q);\n                        q+=GetPixelChannels(image);\n                     }\n\n                     if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                       break;\n                   }\n                }\n#endif\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Finished MAGN processing\");\n              }\n          }\n\n        /*\n          Crop_box is with respect to the upper left corner of the MNG.\n        */\n        crop_box.left=mng_info->image_box.left+mng_info->x_off[object_id];\n        crop_box.right=mng_info->image_box.right+mng_info->x_off[object_id];\n        crop_box.top=mng_info->image_box.top+mng_info->y_off[object_id];\n        crop_box.bottom=mng_info->image_box.bottom+mng_info->y_off[object_id];\n        crop_box=mng_minimum_box(crop_box,mng_info->clip);\n        crop_box=mng_minimum_box(crop_box,mng_info->frame);\n        crop_box=mng_minimum_box(crop_box,mng_info->object_clip[object_id]);\n        if ((crop_box.left != (mng_info->image_box.left\n            +mng_info->x_off[object_id])) ||\n            (crop_box.right != (mng_info->image_box.right\n            +mng_info->x_off[object_id])) ||\n            (crop_box.top != (mng_info->image_box.top\n            +mng_info->y_off[object_id])) ||\n            (crop_box.bottom != (mng_info->image_box.bottom\n            +mng_info->y_off[object_id])))\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Crop the PNG image\");\n\n            if ((crop_box.left < crop_box.right) &&\n                (crop_box.top < crop_box.bottom))\n              {\n                Image\n                  *im;\n\n                RectangleInfo\n                  crop_info;\n\n                /*\n                  Crop_info is with respect to the upper left corner of\n                  the image.\n                */\n                crop_info.x=(crop_box.left-mng_info->x_off[object_id]);\n                crop_info.y=(crop_box.top-mng_info->y_off[object_id]);\n                crop_info.width=(size_t) (crop_box.right-crop_box.left);\n                crop_info.height=(size_t) (crop_box.bottom-crop_box.top);\n                image->page.width=image->columns;\n                image->page.height=image->rows;\n                image->page.x=0;\n                image->page.y=0;\n                im=CropImage(image,&crop_info,exception);\n\n                if (im != (Image *) NULL)\n                  {\n                    image->columns=im->columns;\n                    image->rows=im->rows;\n                    im=DestroyImage(im);\n                    image->page.width=image->columns;\n                    image->page.height=image->rows;\n                    image->page.x=crop_box.left;\n                    image->page.y=crop_box.top;\n                  }\n              }\n\n            else\n              {\n                /*\n                  No pixels in crop area.  The MNG spec still requires\n                  a layer, though, so make a single transparent pixel in\n                  the top left corner.\n                */\n                image->columns=1;\n                image->rows=1;\n                image->colors=2;\n                (void) SetImageBackgroundColor(image,exception);\n                image->page.width=1;\n                image->page.height=1;\n                image->page.x=0;\n                image->page.y=0;\n              }\n          }\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n        image=mng_info->image;\n#endif\n      }\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n      /* PNG does not handle depths greater than 16 so reduce it even\n       * if lossy.\n       */\n      if (image->depth > 16)\n         image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 8)\n      if (image->depth > 8)\n        {\n          /* To do: fill low byte properly */\n          image->depth=16;\n        }\n\n      if (LosslessReduceDepthOK(image,exception) != MagickFalse)\n         image->depth = 8;\n#endif\n\n      if (image_info->number_scenes != 0)\n        {\n          if (mng_info->scenes_found >\n             (ssize_t) (image_info->first_scene+image_info->number_scenes))\n            break;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Finished reading image datastream.\");\n\n  } while (LocaleCompare(image_info->magick,\"MNG\") == 0);\n\n  (void) CloseBlob(image);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Finished reading all image datastreams.\");\n\n#if defined(MNG_INSERT_LAYERS)\n  if (insert_layers && !mng_info->image_found && (mng_info->mng_width) &&\n       (mng_info->mng_height))\n    {\n      /*\n        Insert a background layer if nothing else was found.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  No images found.  Inserting a background layer.\");\n\n      if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n        {\n          /*\n            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image,exception);\n          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n              if (logging != MagickFalse)\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Allocation failed, returning NULL.\");\n\n              return(DestroyImageList(image));;\n            }\n          image=SyncNextImageInList(image);\n        }\n      image->columns=mng_info->mng_width;\n      image->rows=mng_info->mng_height;\n      image->page.width=mng_info->mng_width;\n      image->page.height=mng_info->mng_height;\n      image->page.x=0;\n      image->page.y=0;\n      image->background_color=mng_background_color;\n      image->alpha_trait=UndefinedPixelTrait;\n\n      if (image_info->ping == MagickFalse)\n        (void) SetImageBackgroundColor(image,exception);\n\n      mng_info->image_found++;\n    }\n#endif\n  image->iterations=mng_iterations;\n\n  if (mng_iterations == 1)\n    image->start_loop=MagickTrue;\n\n  while (GetPreviousImageInList(image) != (Image *) NULL)\n  {\n    image_count++;\n    if (image_count > 10*mng_info->image_found)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  No beginning\");\n\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CoderError,\"Linked list is corrupted, beginning of list not found\",\n          \"`%s'\",image_info->filename);\n\n        return(DestroyImageList(image));\n      }\n\n    image=GetPreviousImageInList(image);\n\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Corrupt list\");\n\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CoderError,\"Linked list is corrupted; next_image is NULL\",\"`%s'\",\n          image_info->filename);\n      }\n  }\n\n  if (mng_info->ticks_per_second && mng_info->image_found > 1 &&\n             GetNextImageInList(image) ==\n     (Image *) NULL)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  First image null\");\n\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CoderError,\"image->next for first image is NULL but shouldn't be.\",\n        \"`%s'\",image_info->filename);\n    }\n\n  if (mng_info->image_found == 0)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  No visible images found.\");\n\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CoderError,\"No visible images in file\",\"`%s'\",image_info->filename);\n\n      return(DestroyImageList(image));\n    }\n\n  if (mng_info->ticks_per_second)\n    final_delay=1UL*MagickMax(image->ticks_per_second,1L)*\n            final_delay/mng_info->ticks_per_second;\n\n  else\n    image->start_loop=MagickTrue;\n\n  /* Find final nonzero image delay */\n  final_image_delay=0;\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n    {\n      if (image->delay)\n        final_image_delay=image->delay;\n\n      image=GetNextImageInList(image);\n    }\n\n  if (final_delay < final_image_delay)\n    final_delay=final_image_delay;\n\n  image->delay=final_delay;\n\n  if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  image->delay=%.20g, final_delay=%.20g\",(double) image->delay,\n        (double) final_delay);\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Before coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    scene 0 delay=%.20g\",(double) image->delay);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene %.20g delay=%.20g\",(double) scene++,\n          (double) image->delay);\n      }\n    }\n\n  image=GetFirstImageInList(image);\n#ifdef MNG_COALESCE_LAYERS\n  if (insert_layers)\n    {\n      Image\n        *next_image,\n        *next;\n\n      size_t\n        scene;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Coalesce Images\");\n\n      scene=image->scene;\n      next_image=CoalesceImages(image,exception);\n\n      if (next_image == (Image *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n      image=DestroyImageList(image);\n      image=next_image;\n\n      for (next=image; next != (Image *) NULL; next=next_image)\n      {\n         next->page.width=mng_info->mng_width;\n         next->page.height=mng_info->mng_height;\n         next->page.x=0;\n         next->page.y=0;\n         next->scene=scene++;\n         next_image=GetNextImageInList(next);\n\n         if (next_image == (Image *) NULL)\n           break;\n\n         if (next->delay == 0)\n           {\n             scene--;\n             next_image->previous=GetPreviousImageInList(next);\n             if (GetPreviousImageInList(next) == (Image *) NULL)\n               image=next_image;\n             else\n               next->previous->next=next_image;\n             next=DestroyImage(next);\n           }\n      }\n    }\n#endif\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n      image=GetNextImageInList(image);\n\n  image->dispose=BackgroundDispose;\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  After coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    scene 0 delay=%.20g dispose=%.20g\",(double) image->delay,\n        (double) image->dispose);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene %.20g delay=%.20g dispose=%.20g\",(double) scene++,\n          (double) image->delay,(double) image->dispose);\n      }\n   }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneMNGImage();\");\n\n  return(image);\n}\n\nstatic Image *ReadMNGImage(const ImageInfo *image_info,\n     ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    logging,\n    status;\n\n  MngInfo\n    *mng_info;\n\n  /* Open image file.  */\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n     image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\"Enter ReadMNGImage()\");\n  image=AcquireImage(image_info,exception);\n  mng_info=(MngInfo *) NULL;\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n\n  if (status == MagickFalse)\n    return((Image *) NULL);\n\n  /* Allocate a MngInfo structure.  */\n\n  mng_info=(MngInfo *) AcquireMagickMemory(sizeof(MngInfo));\n\n  if (mng_info == (MngInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* Initialize members of the MngInfo structure.  */\n\n  (void) ResetMagickMemory(mng_info,0,sizeof(MngInfo));\n  mng_info->image=image;\n  image=ReadOneMNGImage(mng_info,image_info,exception);\n  mng_info=MngInfoFreeStruct(mng_info);\n\n  if (image == (Image *) NULL)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"exit ReadMNGImage() with error\");\n\n      return((Image *) NULL);\n    }\n  (void) CloseBlob(image);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"exit ReadMNGImage()\");\n\n  return(GetFirstImageInList(image));\n}\n#else /* PNG_LIBPNG_VER > 10011 */\nstatic Image *ReadPNGImage(const ImageInfo *image_info,\n   ExceptionInfo *exception)\n{\n  printf(\"Your PNG library is too old: You have libpng-%s\\n\",\n     PNG_LIBPNG_VER_STRING);\n\n  (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n    \"PNG library is too old\",\"`%s'\",image_info->filename);\n\n  return(Image *) NULL;\n}\n\nstatic Image *ReadMNGImage(const ImageInfo *image_info,\n   ExceptionInfo *exception)\n{\n  return(ReadPNGImage(image_info,exception));\n}\n#endif /* PNG_LIBPNG_VER > 10011 */\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P N G I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPNGImage() adds properties for the PNG image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterPNGImage method is:\n%\n%      size_t RegisterPNGImage(void)\n%\n*/\nModuleExport size_t RegisterPNGImage(void)\n{\n  char\n    version[MagickPathExtent];\n\n  MagickInfo\n    *entry;\n\n  static const char\n    *PNGNote=\n    {\n      \"See http://www.libpng.org/ for details about the PNG format.\"\n    },\n\n    *JNGNote=\n    {\n      \"See http://www.libpng.org/pub/mng/ for details about the JNG\\n\"\n      \"format.\"\n    },\n\n    *MNGNote=\n    {\n      \"See http://www.libpng.org/pub/mng/ for details about the MNG\\n\"\n      \"format.\"\n    };\n\n  *version='\\0';\n\n#if defined(PNG_LIBPNG_VER_STRING)\n  (void) ConcatenateMagickString(version,\"libpng \",MagickPathExtent);\n  (void) ConcatenateMagickString(version,PNG_LIBPNG_VER_STRING,\n   MagickPathExtent);\n\n  if (LocaleCompare(PNG_LIBPNG_VER_STRING,png_get_header_ver(NULL)) != 0)\n    {\n      (void) ConcatenateMagickString(version,\",\",MagickPathExtent);\n      (void) ConcatenateMagickString(version,png_get_libpng_ver(NULL),\n            MagickPathExtent);\n    }\n#endif\n\n  entry=AcquireMagickInfo(\"PNG\",\"MNG\",\"Multiple-image Network Graphics\");\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n\n#if defined(MAGICKCORE_PNG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadMNGImage;\n  entry->encoder=(EncodeImageHandler *) WriteMNGImage;\n#endif\n\n  entry->magick=(IsImageFormatHandler *) IsMNG;\n\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n\n  entry->mime_type=ConstantString(\"video/x-mng\");\n  entry->note=ConstantString(MNGNote);\n  (void) RegisterMagickInfo(entry);\n\n  entry=AcquireMagickInfo(\"PNG\",\"PNG\",\"Portable Network Graphics\");\n\n#if defined(MAGICKCORE_PNG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadPNGImage;\n  entry->encoder=(EncodeImageHandler *) WritePNGImage;\n#endif\n\n  entry->magick=(IsImageFormatHandler *) IsPNG;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->mime_type=ConstantString(\"image/png\");\n\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n\n  entry->note=ConstantString(PNGNote);\n  (void) RegisterMagickInfo(entry);\n\n  entry=AcquireMagickInfo(\"PNG\",\"PNG8\",\n    \"8-bit indexed with optional binary transparency\");\n\n#if defined(MAGICKCORE_PNG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadPNGImage;\n  entry->encoder=(EncodeImageHandler *) WritePNGImage;\n#endif\n\n  entry->magick=(IsImageFormatHandler *) IsPNG;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->mime_type=ConstantString(\"image/png\");\n  (void) RegisterMagickInfo(entry);\n\n  entry=AcquireMagickInfo(\"PNG\",\"PNG24\",\n    \"opaque or binary transparent 24-bit RGB\");\n  *version='\\0';\n\n#if defined(ZLIB_VERSION)\n  (void) ConcatenateMagickString(version,\"zlib \",MagickPathExtent);\n  (void) ConcatenateMagickString(version,ZLIB_VERSION,MagickPathExtent);\n\n  if (LocaleCompare(ZLIB_VERSION,zlib_version) != 0)\n    {\n      (void) ConcatenateMagickString(version,\",\",MagickPathExtent);\n      (void) ConcatenateMagickString(version,zlib_version,MagickPathExtent);\n    }\n#endif\n\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n\n#if defined(MAGICKCORE_PNG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadPNGImage;\n  entry->encoder=(EncodeImageHandler *) WritePNGImage;\n#endif\n\n  entry->magick=(IsImageFormatHandler *) IsPNG;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->mime_type=ConstantString(\"image/png\");\n  (void) RegisterMagickInfo(entry);\n\n  entry=AcquireMagickInfo(\"PNG\",\"PNG32\",\"opaque or transparent 32-bit RGBA\");\n\n#if defined(MAGICKCORE_PNG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadPNGImage;\n  entry->encoder=(EncodeImageHandler *) WritePNGImage;\n#endif\n\n  entry->magick=(IsImageFormatHandler *) IsPNG;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->mime_type=ConstantString(\"image/png\");\n  (void) RegisterMagickInfo(entry);\n\n  entry=AcquireMagickInfo(\"PNG\",\"PNG48\",\n    \"opaque or binary transparent 48-bit RGB\");\n\n#if defined(MAGICKCORE_PNG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadPNGImage;\n  entry->encoder=(EncodeImageHandler *) WritePNGImage;\n#endif\n\n  entry->magick=(IsImageFormatHandler *) IsPNG;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->mime_type=ConstantString(\"image/png\");\n  (void) RegisterMagickInfo(entry);\n\n  entry=AcquireMagickInfo(\"PNG\",\"PNG64\",\"opaque or transparent 64-bit RGBA\");\n\n#if defined(MAGICKCORE_PNG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadPNGImage;\n  entry->encoder=(EncodeImageHandler *) WritePNGImage;\n#endif\n\n  entry->magick=(IsImageFormatHandler *) IsPNG;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->mime_type=ConstantString(\"image/png\");\n  (void) RegisterMagickInfo(entry);\n\n  entry=AcquireMagickInfo(\"PNG\",\"PNG00\",\n    \"PNG inheriting bit-depth, color-type from original, if possible\");\n\n#if defined(MAGICKCORE_PNG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadPNGImage;\n  entry->encoder=(EncodeImageHandler *) WritePNGImage;\n#endif\n\n  entry->magick=(IsImageFormatHandler *) IsPNG;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->mime_type=ConstantString(\"image/png\");\n  (void) RegisterMagickInfo(entry);\n\n  entry=AcquireMagickInfo(\"PNG\",\"JNG\",\"JPEG Network Graphics\");\n\n#if defined(JNG_SUPPORTED)\n#if defined(MAGICKCORE_PNG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJNGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJNGImage;\n#endif\n#endif\n\n  entry->magick=(IsImageFormatHandler *) IsJNG;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->mime_type=ConstantString(\"image/x-jng\");\n  entry->note=ConstantString(JNGNote);\n  (void) RegisterMagickInfo(entry);\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  ping_semaphore=AcquireSemaphoreInfo();\n#endif\n\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P N G I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPNGImage() removes format registrations made by the\n%  PNG module from the list of supported formats.\n%\n%  The format of the UnregisterPNGImage method is:\n%\n%      UnregisterPNGImage(void)\n%\n*/\nModuleExport void UnregisterPNGImage(void)\n{\n  (void) UnregisterMagickInfo(\"MNG\");\n  (void) UnregisterMagickInfo(\"PNG\");\n  (void) UnregisterMagickInfo(\"PNG8\");\n  (void) UnregisterMagickInfo(\"PNG24\");\n  (void) UnregisterMagickInfo(\"PNG32\");\n  (void) UnregisterMagickInfo(\"PNG48\");\n  (void) UnregisterMagickInfo(\"PNG64\");\n  (void) UnregisterMagickInfo(\"PNG00\");\n  (void) UnregisterMagickInfo(\"JNG\");\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  if (ping_semaphore != (SemaphoreInfo *) NULL)\n    RelinquishSemaphoreInfo(&ping_semaphore);\n#endif\n}\n\f\n#if defined(MAGICKCORE_PNG_DELEGATE)\n#if PNG_LIBPNG_VER > 10011\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e M N G I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteMNGImage() writes an image in the Portable Network Graphics\n%  Group's \"Multiple-image Network Graphics\" encoded image format.\n%\n%  MNG support written by Glenn Randers-Pehrson, glennrp@image...\n%\n%  The format of the WriteMNGImage method is:\n%\n%      MagickBooleanType WriteMNGImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n%  To do (as of version 5.5.2, November 26, 2002 -- glennrp -- see also\n%    \"To do\" under ReadPNGImage):\n%\n%    Preserve all unknown and not-yet-handled known chunks found in input\n%    PNG file and copy them  into output PNG files according to the PNG\n%    copying rules.\n%\n%    Write the iCCP chunk at MNG level when (icc profile length > 0)\n%\n%    Improve selection of color type (use indexed-colour or indexed-colour\n%    with tRNS when 256 or fewer unique RGBA values are present).\n%\n%    Figure out what to do with \"dispose=<restore-to-previous>\" (dispose == 3)\n%    This will be complicated if we limit ourselves to generating MNG-LC\n%    files.  For now we ignore disposal method 3 and simply overlay the next\n%    image on it.\n%\n%    Check for identical PLTE's or PLTE/tRNS combinations and use a\n%    global MNG PLTE or PLTE/tRNS combination when appropriate.\n%    [mostly done 15 June 1999 but still need to take care of tRNS]\n%\n%    Check for identical sRGB and replace with a global sRGB (and remove\n%    gAMA/cHRM if sRGB is found; check for identical gAMA/cHRM and\n%    replace with global gAMA/cHRM (or with sRGB if appropriate; replace\n%    local gAMA/cHRM with local sRGB if appropriate).\n%\n%    Check for identical sBIT chunks and write global ones.\n%\n%    Provide option to skip writing the signature tEXt chunks.\n%\n%    Use signatures to detect identical objects and reuse the first\n%    instance of such objects instead of writing duplicate objects.\n%\n%    Use a smaller-than-32k value of compression window size when\n%    appropriate.\n%\n%    Encode JNG datastreams.  Mostly done as of 5.5.2; need to write\n%    ancillary text chunks and save profiles.\n%\n%    Provide an option to force LC files (to ensure exact framing rate)\n%    instead of VLC.\n%\n%    Provide an option to force VLC files instead of LC, even when offsets\n%    are present.  This will involve expanding the embedded images with a\n%    transparent region at the top and/or left.\n*/\n\nstatic void\nMagick_png_write_raw_profile(const ImageInfo *image_info,png_struct *ping,\n   png_info *ping_info, unsigned char *profile_type, unsigned char\n   *profile_description, unsigned char *profile_data, png_uint_32 length)\n{\n   png_textp\n     text;\n\n   register ssize_t\n     i;\n\n   unsigned char\n     *sp;\n\n   png_charp\n     dp;\n\n   png_uint_32\n     allocated_length,\n     description_length;\n\n   unsigned char\n     hex[16]={'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};\n\n   if (LocaleNCompare((char *) profile_type+1, \"ng-chunk-\",9) == 0)\n      return;\n\n   if (image_info->verbose)\n     {\n       (void) printf(\"writing raw profile: type=%s, length=%.20g\\n\",\n         (char *) profile_type, (double) length);\n     }\n\n#if PNG_LIBPNG_VER >= 10400\n   text=(png_textp) png_malloc(ping,(png_alloc_size_t) sizeof(png_text));\n#else\n   text=(png_textp) png_malloc(ping,(png_size_t) sizeof(png_text));\n#endif\n   description_length=(png_uint_32) strlen((const char *) profile_description);\n   allocated_length=(png_uint_32) (length*2 + (length >> 5) + 20\n      + description_length);\n#if PNG_LIBPNG_VER >= 10400\n   text[0].text=(png_charp) png_malloc(ping,\n      (png_alloc_size_t) allocated_length);\n   text[0].key=(png_charp) png_malloc(ping, (png_alloc_size_t) 80);\n#else\n   text[0].text=(png_charp) png_malloc(ping, (png_size_t) allocated_length);\n   text[0].key=(png_charp) png_malloc(ping, (png_size_t) 80);\n#endif\n   text[0].key[0]='\\0';\n   (void) ConcatenateMagickString(text[0].key,\n      \"Raw profile type \",MagickPathExtent);\n   (void) ConcatenateMagickString(text[0].key,(const char *) profile_type,62);\n   sp=profile_data;\n   dp=text[0].text;\n   *dp++='\\n';\n   (void) CopyMagickString(dp,(const char *) profile_description,\n     allocated_length);\n   dp+=description_length;\n   *dp++='\\n';\n   (void) FormatLocaleString(dp,allocated_length-\n     (png_size_t) (dp-text[0].text),\"%8lu \",(unsigned long) length);\n   dp+=8;\n\n   for (i=0; i < (ssize_t) length; i++)\n   {\n     if (i%36 == 0)\n       *dp++='\\n';\n     *(dp++)=(char) hex[((*sp >> 4) & 0x0f)];\n     *(dp++)=(char) hex[((*sp++ ) & 0x0f)];\n   }\n\n   *dp++='\\n';\n   *dp='\\0';\n   text[0].text_length=(png_size_t) (dp-text[0].text);\n   text[0].compression=image_info->compression == NoCompression ||\n     (image_info->compression == UndefinedCompression &&\n     text[0].text_length < 128) ? -1 : 0;\n\n   if (text[0].text_length <= allocated_length)\n     png_set_text(ping,ping_info,text,1);\n\n   png_free(ping,text[0].text);\n   png_free(ping,text[0].key);\n   png_free(ping,text);\n}\n\nstatic MagickBooleanType Magick_png_write_chunk_from_profile(Image *image,\n  const char *string, MagickBooleanType logging)\n{\n  char\n    *name;\n\n  const StringInfo\n    *profile;\n\n  unsigned char\n    *data;\n\n  png_uint_32 length;\n\n  ResetImageProfileIterator(image);\n\n  for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n  {\n    profile=GetImageProfile(image,name);\n\n    if (profile != (const StringInfo *) NULL)\n      {\n        StringInfo\n          *ping_profile;\n\n        if (LocaleNCompare(name,string,11) == 0)\n          {\n            if (logging != MagickFalse)\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Found %s profile\",name);\n\n            ping_profile=CloneStringInfo(profile);\n            data=GetStringInfoDatum(ping_profile),\n            length=(png_uint_32) GetStringInfoLength(ping_profile);\n            data[4]=data[3];\n            data[3]=data[2];\n            data[2]=data[1];\n            data[1]=data[0];\n            (void) WriteBlobMSBULong(image,length-5);  /* data length */\n            (void) WriteBlob(image,length-1,data+1);\n            (void) WriteBlobMSBULong(image,crc32(0,data+1,(uInt) length-1));\n            ping_profile=DestroyStringInfo(ping_profile);\n          }\n      }\n\n      name=GetNextImageProfile(image);\n   }\n\n   return(MagickTrue);\n}\n\nstatic inline MagickBooleanType Magick_png_color_equal(const Image *image,\n  const Quantum *p, const PixelInfo *q)\n{\n  MagickRealType\n    value;\n\n  value=(MagickRealType) p[image->channel_map[RedPixelChannel].offset];\n  if (AbsolutePixelValue(value-q->red) >= MagickEpsilon)\n    return(MagickFalse);\n  value=(MagickRealType) p[image->channel_map[GreenPixelChannel].offset];\n  if (AbsolutePixelValue(value-q->green) >= MagickEpsilon)\n    return(MagickFalse);\n  value=(MagickRealType) p[image->channel_map[BluePixelChannel].offset];\n  if (AbsolutePixelValue(value-q->blue) >= MagickEpsilon)\n    return(MagickFalse);\n\n  return(MagickTrue);\n}\n\n#if defined(PNG_tIME_SUPPORTED)\nstatic void write_tIME_chunk(Image *image,png_struct *ping,png_info *info,\n  const char *date,ExceptionInfo *exception)\n{\n  unsigned int\n    day,\n    hour,\n    minute,\n    month,\n    second,\n    year;\n\n  png_time\n    ptime;\n\n  time_t\n    ttime;\n\n  if (date != (const char *) NULL)\n    {\n      if (sscanf(date,\"%d-%d-%dT%d:%d:%dZ\",&year,&month,&day,&hour,&minute,\n          &second) != 6)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"Invalid date format specified for png:tIME\",\"`%s'\",\n            image->filename);\n          return;\n        }\n      ptime.year=(png_uint_16) year;\n      ptime.month=(png_byte) month;\n      ptime.day=(png_byte) day;\n      ptime.hour=(png_byte) hour;\n      ptime.minute=(png_byte) minute;\n      ptime.second=(png_byte) second;\n    }\n  else\n  {\n    time(&ttime);\n    png_convert_from_time_t(&ptime,ttime);\n  }\n  png_set_tIME(ping,info,&ptime);\n}\n#endif\n\n/* Write one PNG image */\nstatic MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,\n  const ImageInfo *IMimage_info,Image *IMimage,ExceptionInfo *exception)\n{\n  char\n    im_vers[32],\n    libpng_runv[32],\n    libpng_vers[32],\n    zlib_runv[32],\n    zlib_vers[32];\n\n  Image\n    *image;\n\n  ImageInfo\n    *image_info;\n\n  char\n    s[2];\n\n  const char\n    *name,\n    *property,\n    *value;\n\n  const StringInfo\n    *profile;\n\n  int\n    num_passes,\n    pass,\n    ping_wrote_caNv;\n\n  png_byte\n     ping_trans_alpha[256];\n\n  png_color\n     palette[257];\n\n  png_color_16\n    ping_background,\n    ping_trans_color;\n\n  png_info\n    *ping_info;\n\n  png_struct\n    *ping;\n\n  png_uint_32\n    ping_height,\n    ping_width;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    image_matte,\n    logging,\n    matte,\n\n    ping_have_blob,\n    ping_have_cheap_transparency,\n    ping_have_color,\n    ping_have_non_bw,\n    ping_have_PLTE,\n    ping_have_bKGD,\n    ping_have_eXIf,\n    ping_have_iCCP,\n    ping_have_pHYs,\n    ping_have_sRGB,\n    ping_have_tRNS,\n\n    ping_exclude_bKGD,\n    ping_exclude_cHRM,\n    ping_exclude_date,\n    /* ping_exclude_EXIF, */\n    ping_exclude_eXIf,\n    ping_exclude_gAMA,\n    ping_exclude_iCCP,\n    /* ping_exclude_iTXt, */\n    ping_exclude_oFFs,\n    ping_exclude_pHYs,\n    ping_exclude_sRGB,\n    ping_exclude_tEXt,\n    ping_exclude_tIME,\n    /* ping_exclude_tRNS, */\n    ping_exclude_vpAg,\n    ping_exclude_caNv,\n    ping_exclude_zCCP, /* hex-encoded iCCP */\n    ping_exclude_zTXt,\n\n    ping_preserve_colormap,\n    ping_preserve_iCCP,\n    ping_need_colortype_warning,\n\n    status,\n    tried_332,\n    tried_333,\n    tried_444;\n\n  MemoryInfo\n    *volatile pixel_info;\n\n  QuantumInfo\n    *quantum_info;\n\n  PNGErrorInfo\n    error_info;\n\n  register ssize_t\n    i,\n    x;\n\n  unsigned char\n    *ping_pixels;\n\n  volatile int\n    image_colors,\n    ping_bit_depth,\n    ping_color_type,\n    ping_interlace_method,\n    ping_compression_method,\n    ping_filter_method,\n    ping_num_trans;\n\n  volatile size_t\n    image_depth,\n    old_bit_depth;\n\n  size_t\n    quality,\n    rowbytes,\n    save_image_depth;\n\n  int\n    j,\n    number_colors,\n    number_opaque,\n    number_semitransparent,\n    number_transparent,\n    ping_pHYs_unit_type;\n\n  png_uint_32\n    ping_pHYs_x_resolution,\n    ping_pHYs_y_resolution;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter WriteOnePNGImage()\");\n\n  image = CloneImage(IMimage,0,0,MagickFalse,exception);\n  image_info=(ImageInfo *) CloneImageInfo(IMimage_info);\n  if (image_info == (ImageInfo *) NULL)\n     ThrowWriterException(ResourceLimitError, \"MemoryAllocationFailed\");\n\n  /* Define these outside of the following \"if logging()\" block so they will\n   * show in debuggers.\n   */\n  *im_vers='\\0';\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibVersionText,MagickPathExtent);\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibAddendum,MagickPathExtent);\n\n  *libpng_vers='\\0';\n  (void) ConcatenateMagickString(libpng_vers,\n         PNG_LIBPNG_VER_STRING,32);\n  *libpng_runv='\\0';\n  (void) ConcatenateMagickString(libpng_runv,\n         png_get_libpng_ver(NULL),32);\n\n  *zlib_vers='\\0';\n  (void) ConcatenateMagickString(zlib_vers,\n         ZLIB_VERSION,32);\n  *zlib_runv='\\0';\n  (void) ConcatenateMagickString(zlib_runv,\n         zlib_version,32);\n\n  if (logging != MagickFalse)\n    {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    IM version     = %s\",\n           im_vers);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    Libpng version = %s\",\n           libpng_vers);\n       if (LocaleCompare(libpng_vers,libpng_runv) != 0)\n       {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n           libpng_runv);\n       }\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    Zlib version   = %s\",\n           zlib_vers);\n       if (LocaleCompare(zlib_vers,zlib_runv) != 0)\n       {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n           zlib_runv);\n       }\n    }\n\n  /* Initialize some stuff */\n  ping_bit_depth=0,\n  ping_color_type=0,\n  ping_interlace_method=0,\n  ping_compression_method=0,\n  ping_filter_method=0,\n  ping_num_trans = 0;\n\n  ping_background.red = 0;\n  ping_background.green = 0;\n  ping_background.blue = 0;\n  ping_background.gray = 0;\n  ping_background.index = 0;\n\n  ping_trans_color.red=0;\n  ping_trans_color.green=0;\n  ping_trans_color.blue=0;\n  ping_trans_color.gray=0;\n\n  ping_pHYs_unit_type = 0;\n  ping_pHYs_x_resolution = 0;\n  ping_pHYs_y_resolution = 0;\n\n  ping_have_blob=MagickFalse;\n  ping_have_cheap_transparency=MagickFalse;\n  ping_have_color=MagickTrue;\n  ping_have_non_bw=MagickTrue;\n  ping_have_PLTE=MagickFalse;\n  ping_have_bKGD=MagickFalse;\n  ping_have_eXIf=MagickTrue;\n  ping_have_iCCP=MagickFalse;\n  ping_have_pHYs=MagickFalse;\n  ping_have_sRGB=MagickFalse;\n  ping_have_tRNS=MagickFalse;\n\n  ping_exclude_bKGD=mng_info->ping_exclude_bKGD;\n  ping_exclude_caNv=mng_info->ping_exclude_caNv;\n  ping_exclude_cHRM=mng_info->ping_exclude_cHRM;\n  ping_exclude_date=mng_info->ping_exclude_date;\n  ping_exclude_eXIf=mng_info->ping_exclude_eXIf;\n  ping_exclude_gAMA=mng_info->ping_exclude_gAMA;\n  ping_exclude_iCCP=mng_info->ping_exclude_iCCP;\n  /* ping_exclude_iTXt=mng_info->ping_exclude_iTXt; */\n  ping_exclude_oFFs=mng_info->ping_exclude_oFFs;\n  ping_exclude_pHYs=mng_info->ping_exclude_pHYs;\n  ping_exclude_sRGB=mng_info->ping_exclude_sRGB;\n  ping_exclude_tEXt=mng_info->ping_exclude_tEXt;\n  ping_exclude_tIME=mng_info->ping_exclude_tIME;\n  /* ping_exclude_tRNS=mng_info->ping_exclude_tRNS; */\n  ping_exclude_vpAg=mng_info->ping_exclude_vpAg;\n  ping_exclude_zCCP=mng_info->ping_exclude_zCCP; /* hex-encoded iCCP in zTXt */\n  ping_exclude_zTXt=mng_info->ping_exclude_zTXt;\n\n  ping_preserve_colormap = mng_info->ping_preserve_colormap;\n  ping_preserve_iCCP = mng_info->ping_preserve_iCCP;\n  ping_need_colortype_warning = MagickFalse;\n\n  /* Recognize the ICC sRGB profile and convert it to the sRGB chunk,\n   * i.e., eliminate the ICC profile and set image->rendering_intent.\n   * Note that this will not involve any changes to the actual pixels\n   * but merely passes information to applications that read the resulting\n   * PNG image.\n   *\n   * To do: recognize other variants of the sRGB profile, using the CRC to\n   * verify all recognized variants including the 7 already known.\n   *\n   * Work around libpng16+ rejecting some \"known invalid sRGB profiles\".\n   *\n   * Use something other than image->rendering_intent to record the fact\n   * that the sRGB profile was found.\n   *\n   * Record the ICC version (currently v2 or v4) of the incoming sRGB ICC\n   * profile.  Record the Blackpoint Compensation, if any.\n   */\n   if (ping_exclude_sRGB == MagickFalse && ping_preserve_iCCP == MagickFalse)\n   {\n      char\n        *name;\n\n      const StringInfo\n        *profile;\n\n      ResetImageProfileIterator(image);\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        profile=GetImageProfile(image,name);\n\n        if (profile != (StringInfo *) NULL)\n          {\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0))\n\n             {\n                 int\n                   icheck,\n                   got_crc=0;\n\n\n                 png_uint_32\n                   length,\n                   profile_crc=0;\n\n                 unsigned char\n                   *data;\n\n                 length=(png_uint_32) GetStringInfoLength(profile);\n\n                 for (icheck=0; sRGB_info[icheck].len > 0; icheck++)\n                 {\n                   if (length == sRGB_info[icheck].len)\n                   {\n                     if (got_crc == 0)\n                     {\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Got a %lu-byte ICC profile (potentially sRGB)\",\n                         (unsigned long) length);\n\n                       data=GetStringInfoDatum(profile);\n                       profile_crc=crc32(0,data,length);\n\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"      with crc=%8x\",(unsigned int) profile_crc);\n                       got_crc++;\n                     }\n\n                     if (profile_crc == sRGB_info[icheck].crc)\n                     {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"      It is sRGB with rendering intent = %s\",\n                        Magick_RenderingIntentString_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent));\n                        if (image->rendering_intent==UndefinedIntent)\n                        {\n                          image->rendering_intent=\n                          Magick_RenderingIntent_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent);\n                        }\n                        ping_exclude_iCCP = MagickTrue;\n                        ping_exclude_zCCP = MagickTrue;\n                        ping_have_sRGB = MagickTrue;\n                        break;\n                     }\n                   }\n                 }\n                 if (sRGB_info[icheck].len == 0)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"    Got %lu-byte ICC profile not recognized as sRGB\",\n                        (unsigned long) length);\n              }\n          }\n        name=GetNextImageProfile(image);\n      }\n  }\n\n  number_opaque = 0;\n  number_semitransparent = 0;\n  number_transparent = 0;\n\n  if (logging != MagickFalse)\n    {\n      if (image->storage_class == UndefinedClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=UndefinedClass\");\n      if (image->storage_class == DirectClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=DirectClass\");\n      if (image->storage_class == PseudoClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=PseudoClass\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(), image->taint ?\n          \"    image->taint=MagickTrue\":\n          \"    image->taint=MagickFalse\");\n    }\n\n  if (image->storage_class == PseudoClass &&\n     (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32 ||\n     mng_info->write_png48 || mng_info->write_png64 ||\n     (mng_info->write_png_colortype != 1 &&\n     mng_info->write_png_colortype != 5)))\n    {\n      (void) SyncImage(image,exception);\n      image->storage_class = DirectClass;\n    }\n\n  if (ping_preserve_colormap == MagickFalse)\n    {\n      if (image->storage_class != PseudoClass && image->colormap != NULL)\n        {\n          /* Free the bogus colormap; it can cause trouble later */\n           if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Freeing bogus colormap\");\n           (void) RelinquishMagickMemory(image->colormap);\n           image->colormap=NULL;\n        }\n    }\n\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n\n  /*\n    Sometimes we get PseudoClass images whose RGB values don't match\n    the colors in the colormap.  This code syncs the RGB values.\n  */\n  if (image->depth <= 8 && image->taint && image->storage_class == PseudoClass)\n     (void) SyncImage(image,exception);\n\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n  if (image->depth > 8)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Reducing PNG bit depth to 8 since this is a Q8 build.\");\n\n      image->depth=8;\n    }\n#endif\n\n  /* Respect the -depth option */\n  if (image->depth < 4)\n    {\n       register Quantum\n         *r;\n\n       if (image->depth > 2)\n         {\n           /* Scale to 4-bit */\n           LBR04PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR04PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR04PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n       else if (image->depth > 1)\n         {\n           /* Scale to 2-bit */\n           LBR02PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR02PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR02PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n       else\n         {\n           /* Scale to 1-bit */\n           LBR01PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR01PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR01PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n    }\n\n  /* To do: set to next higher multiple of 8 */\n  if (image->depth < 8)\n     image->depth=8;\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n  /* PNG does not handle depths greater than 16 so reduce it even\n   * if lossy\n   */\n  if (image->depth > 8)\n      image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 8)\n  if (image->depth > 8)\n    {\n      /* To do: fill low byte properly */\n      image->depth=16;\n    }\n\n  if (image->depth == 16 && mng_info->write_png_depth != 16)\n    if (mng_info->write_png8 ||\n        LosslessReduceDepthOK(image,exception) != MagickFalse)\n      image->depth = 8;\n#endif\n\n  image_colors = (int) image->colors;\n  number_opaque = (int) image->colors;\n  number_transparent = 0;\n  number_semitransparent = 0;\n\n  if (mng_info->write_png_colortype &&\n     (mng_info->write_png_colortype > 4 || (mng_info->write_png_depth >= 8 &&\n     mng_info->write_png_colortype < 4 &&\n     image->alpha_trait == UndefinedPixelTrait)))\n  {\n     /* Avoid the expensive BUILD_PALETTE operation if we're sure that we\n      * are not going to need the result.\n      */\n     if (mng_info->write_png_colortype == 1 ||\n        mng_info->write_png_colortype == 5)\n       ping_have_color=MagickFalse;\n\n     if (image->alpha_trait != UndefinedPixelTrait)\n       {\n         number_transparent = 2;\n         number_semitransparent = 1;\n       }\n  }\n\n  if (mng_info->write_png_colortype < 7)\n  {\n  /* BUILD_PALETTE\n   *\n   * Normally we run this just once, but in the case of writing PNG8\n   * we reduce the transparency to binary and run again, then if there\n   * are still too many colors we reduce to a simple 4-4-4-1, then 3-3-3-1\n   * RGBA palette and run again, and then to a simple 3-3-2-1 RGBA\n   * palette.  Then (To do) we take care of a final reduction that is only\n   * needed if there are still 256 colors present and one of them has both\n   * transparent and opaque instances.\n   */\n\n  tried_332 = MagickFalse;\n  tried_333 = MagickFalse;\n  tried_444 = MagickFalse;\n\n  for (j=0; j<6; j++)\n  {\n    /*\n     * Sometimes we get DirectClass images that have 256 colors or fewer.\n     * This code will build a colormap.\n     *\n     * Also, sometimes we get PseudoClass images with an out-of-date\n     * colormap.  This code will replace the colormap with a new one.\n     * Sometimes we get PseudoClass images that have more than 256 colors.\n     * This code will delete the colormap and change the image to\n     * DirectClass.\n     *\n     * If image->alpha_trait is MagickFalse, we ignore the alpha channel\n     * even though it sometimes contains left-over non-opaque values.\n     *\n     * Also we gather some information (number of opaque, transparent,\n     * and semitransparent pixels, and whether the image has any non-gray\n     * pixels or only black-and-white pixels) that we might need later.\n     *\n     * Even if the user wants to force GrayAlpha or RGBA (colortype 4 or 6)\n     * we need to check for bogus non-opaque values, at least.\n     */\n\n   int\n     n;\n\n   PixelInfo\n     opaque[260],\n     semitransparent[260],\n     transparent[260];\n\n   register const Quantum\n     *s;\n\n   register Quantum\n     *q,\n     *r;\n\n   if (logging != MagickFalse)\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"    Enter BUILD_PALETTE:\");\n\n   if (logging != MagickFalse)\n     {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->columns=%.20g\",(double) image->columns);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->rows=%.20g\",(double) image->rows);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->alpha_trait=%.20g\",(double) image->alpha_trait);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->depth=%.20g\",(double) image->depth);\n\n       if (image->storage_class == PseudoClass && image->colormap != NULL)\n       {\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      Original colormap:\");\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"        i    (red,green,blue,alpha)\");\n\n         for (i=0; i < 256; i++)\n         {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"        %d    (%d,%d,%d,%d)\",\n                    (int) i,\n                    (int) image->colormap[i].red,\n                    (int) image->colormap[i].green,\n                    (int) image->colormap[i].blue,\n                    (int) image->colormap[i].alpha);\n         }\n\n         for (i=image->colors - 10; i < (ssize_t) image->colors; i++)\n         {\n           if (i > 255)\n             {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"        %d    (%d,%d,%d,%d)\",\n                    (int) i,\n                    (int) image->colormap[i].red,\n                    (int) image->colormap[i].green,\n                    (int) image->colormap[i].blue,\n                    (int) image->colormap[i].alpha);\n             }\n         }\n       }\n\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"      image->colors=%d\",(int) image->colors);\n\n       if (image->colors == 0)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"        (zero means unknown)\");\n\n       if (ping_preserve_colormap == MagickFalse)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"      Regenerate the colormap\");\n     }\n\n     image_colors=0;\n     number_opaque = 0;\n     number_semitransparent = 0;\n     number_transparent = 0;\n\n     for (y=0; y < (ssize_t) image->rows; y++)\n     {\n       q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n       if (q == (Quantum *) NULL)\n         break;\n\n       for (x=0; x < (ssize_t) image->columns; x++)\n       {\n           if (image->alpha_trait == UndefinedPixelTrait ||\n              GetPixelAlpha(image,q) == OpaqueAlpha)\n             {\n               if (number_opaque < 259)\n                 {\n                   if (number_opaque == 0)\n                     {\n                       GetPixelInfoPixel(image, q, opaque);\n                       opaque[0].alpha=OpaqueAlpha;\n                       number_opaque=1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_opaque; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,opaque+i))\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_opaque && number_opaque < 259)\n                     {\n                       number_opaque++;\n                       GetPixelInfoPixel(image, q, opaque+i);\n                       opaque[i].alpha=OpaqueAlpha;\n                     }\n                 }\n             }\n           else if (GetPixelAlpha(image,q) == TransparentAlpha)\n             {\n               if (number_transparent < 259)\n                 {\n                   if (number_transparent == 0)\n                     {\n                       GetPixelInfoPixel(image, q, transparent);\n                       ping_trans_color.red=(unsigned short)\n                         GetPixelRed(image,q);\n                       ping_trans_color.green=(unsigned short)\n                         GetPixelGreen(image,q);\n                       ping_trans_color.blue=(unsigned short)\n                         GetPixelBlue(image,q);\n                       ping_trans_color.gray=(unsigned short)\n                         GetPixelGray(image,q);\n                       number_transparent = 1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_transparent; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,transparent+i))\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_transparent &&\n                       number_transparent < 259)\n                     {\n                       number_transparent++;\n                       GetPixelInfoPixel(image,q,transparent+i);\n                     }\n                 }\n             }\n           else\n             {\n               if (number_semitransparent < 259)\n                 {\n                   if (number_semitransparent == 0)\n                     {\n                       GetPixelInfoPixel(image,q,semitransparent);\n                       number_semitransparent = 1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_semitransparent; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,semitransparent+i)\n                           && GetPixelAlpha(image,q) ==\n                           semitransparent[i].alpha)\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_semitransparent &&\n                       number_semitransparent < 259)\n                     {\n                       number_semitransparent++;\n                       GetPixelInfoPixel(image, q, semitransparent+i);\n                     }\n                 }\n             }\n           q+=GetPixelChannels(image);\n        }\n     }\n\n     if (mng_info->write_png8 == MagickFalse &&\n         ping_exclude_bKGD == MagickFalse)\n       {\n         /* Add the background color to the palette, if it\n          * isn't already there.\n          */\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      Check colormap for background (%d,%d,%d)\",\n                  (int) image->background_color.red,\n                  (int) image->background_color.green,\n                  (int) image->background_color.blue);\n            }\n          for (i=0; i<number_opaque; i++)\n          {\n             if (opaque[i].red == image->background_color.red &&\n                 opaque[i].green == image->background_color.green &&\n                 opaque[i].blue == image->background_color.blue)\n               break;\n          }\n          if (number_opaque < 259 && i == number_opaque)\n            {\n               opaque[i] = image->background_color;\n               ping_background.index = i;\n               number_opaque++;\n               if (logging != MagickFalse)\n                 {\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"      background_color index is %d\",(int) i);\n                 }\n\n            }\n          else if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      No room in the colormap to add background color\");\n       }\n\n     image_colors=number_opaque+number_transparent+number_semitransparent;\n\n     if (logging != MagickFalse)\n       {\n         if (image_colors > 256)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      image has more than 256 colors\");\n\n         else\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      image has %d colors\",image_colors);\n       }\n\n     if (ping_preserve_colormap != MagickFalse)\n       break;\n\n     if (mng_info->write_png_colortype != 7) /* We won't need this info */\n       {\n         ping_have_color=MagickFalse;\n         ping_have_non_bw=MagickFalse;\n\n         if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n         {\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"incompatible colorspace\");\n           ping_have_color=MagickTrue;\n           ping_have_non_bw=MagickTrue;\n         }\n\n         if(image_colors > 256)\n           {\n             for (y=0; y < (ssize_t) image->rows; y++)\n             {\n               q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n               if (q == (Quantum *) NULL)\n                 break;\n\n               s=q;\n               for (x=0; x < (ssize_t) image->columns; x++)\n               {\n                 if (GetPixelRed(image,s) != GetPixelGreen(image,s) ||\n                     GetPixelRed(image,s) != GetPixelBlue(image,s))\n                   {\n                      ping_have_color=MagickTrue;\n                      ping_have_non_bw=MagickTrue;\n                      break;\n                   }\n                 s+=GetPixelChannels(image);\n               }\n\n               if (ping_have_color != MagickFalse)\n                 break;\n\n               /* Worst case is black-and-white; we are looking at every\n                * pixel twice.\n                */\n\n               if (ping_have_non_bw == MagickFalse)\n                 {\n                   s=q;\n                   for (x=0; x < (ssize_t) image->columns; x++)\n                   {\n                     if (GetPixelRed(image,s) != 0 &&\n                         GetPixelRed(image,s) != QuantumRange)\n                       {\n                         ping_have_non_bw=MagickTrue;\n                         break;\n                       }\n                     s+=GetPixelChannels(image);\n                   }\n               }\n             }\n           }\n       }\n\n     if (image_colors < 257)\n       {\n         PixelInfo\n           colormap[260];\n\n         /*\n          * Initialize image colormap.\n          */\n\n         if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      Sort the new colormap\");\n\n        /* Sort palette, transparent first */;\n\n         n = 0;\n\n         for (i=0; i<number_transparent; i++)\n            colormap[n++] = transparent[i];\n\n         for (i=0; i<number_semitransparent; i++)\n            colormap[n++] = semitransparent[i];\n\n         for (i=0; i<number_opaque; i++)\n            colormap[n++] = opaque[i];\n\n         ping_background.index +=\n           (number_transparent + number_semitransparent);\n\n         /* image_colors < 257; search the colormap instead of the pixels\n          * to get ping_have_color and ping_have_non_bw\n          */\n         for (i=0; i<n; i++)\n         {\n           if (ping_have_color == MagickFalse)\n             {\n                if (colormap[i].red != colormap[i].green ||\n                    colormap[i].red != colormap[i].blue)\n                  {\n                     ping_have_color=MagickTrue;\n                     ping_have_non_bw=MagickTrue;\n                     break;\n                  }\n              }\n\n           if (ping_have_non_bw == MagickFalse)\n             {\n               if (colormap[i].red != 0 && colormap[i].red != QuantumRange)\n                   ping_have_non_bw=MagickTrue;\n             }\n          }\n\n        if ((mng_info->ping_exclude_tRNS == MagickFalse ||\n            (number_transparent == 0 && number_semitransparent == 0)) &&\n            (((mng_info->write_png_colortype-1) ==\n            PNG_COLOR_TYPE_PALETTE) ||\n            (mng_info->write_png_colortype == 0)))\n          {\n            if (logging != MagickFalse)\n              {\n                if (n !=  (ssize_t) image_colors)\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"   image_colors (%d) and n (%d)  don't match\",\n                   image_colors, n);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      AcquireImageColormap\");\n              }\n\n            image->colors = image_colors;\n\n            if (AcquireImageColormap(image,image_colors,exception) ==\n                MagickFalse)\n               ThrowWriterException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");\n\n            for (i=0; i< (ssize_t) image_colors; i++)\n               image->colormap[i] = colormap[i];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"      image->colors=%d (%d)\",\n                      (int) image->colors, image_colors);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"      Update the pixel indexes\");\n              }\n\n            /* Sync the pixel indices with the new colormap */\n\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n              if (q == (Quantum *) NULL)\n                break;\n\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                for (i=0; i< (ssize_t) image_colors; i++)\n                {\n                  if ((image->alpha_trait == UndefinedPixelTrait ||\n                      image->colormap[i].alpha == GetPixelAlpha(image,q)) &&\n                      image->colormap[i].red == GetPixelRed(image,q) &&\n                      image->colormap[i].green == GetPixelGreen(image,q) &&\n                      image->colormap[i].blue == GetPixelBlue(image,q))\n                  {\n                    SetPixelIndex(image,i,q);\n                    break;\n                  }\n                }\n                q+=GetPixelChannels(image);\n              }\n\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                 break;\n            }\n          }\n       }\n\n     if (logging != MagickFalse)\n       {\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      image->colors=%d\", (int) image->colors);\n\n         if (image->colormap != NULL)\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"       i     (red,green,blue,alpha)\");\n\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               if (i < 300 || i >= (ssize_t) image->colors - 10)\n                 {\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"       %d     (%d,%d,%d,%d)\",\n                        (int) i,\n                        (int) image->colormap[i].red,\n                        (int) image->colormap[i].green,\n                        (int) image->colormap[i].blue,\n                        (int) image->colormap[i].alpha);\n                 }\n             }\n           }\n\n           if (number_transparent < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_transparent     = %d\",\n                   number_transparent);\n           else\n\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_transparent     > 256\");\n\n           if (number_opaque < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_opaque          = %d\",\n                   number_opaque);\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_opaque          > 256\");\n\n           if (number_semitransparent < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_semitransparent = %d\",\n                   number_semitransparent);\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_semitransparent > 256\");\n\n           if (ping_have_non_bw == MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      All pixels and the background are black or white\");\n\n           else if (ping_have_color == MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      All pixels and the background are gray\");\n\n           else\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      At least one pixel or the background is non-gray\");\n\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Exit BUILD_PALETTE:\");\n       }\n\n   if (mng_info->write_png8 == MagickFalse)\n      break;\n\n   /* Make any reductions necessary for the PNG8 format */\n    if (image_colors <= 256 &&\n        image_colors != 0 && image->colormap != NULL &&\n        number_semitransparent == 0 &&\n        number_transparent <= 1)\n      break;\n\n    /* PNG8 can't have semitransparent colors so we threshold the\n     * opacity to 0 or OpaqueOpacity, and PNG8 can only have one\n     * transparent color so if more than one is transparent we merge\n     * them into image->background_color.\n     */\n    if (number_semitransparent != 0 || number_transparent > 1)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Thresholding the alpha channel to binary\");\n\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n          if (r == (Quantum *) NULL)\n            break;\n\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n              if (GetPixelAlpha(image,r) < OpaqueAlpha/2)\n                {\n                  SetPixelViaPixelInfo(image,&image->background_color,r);\n                  SetPixelAlpha(image,TransparentAlpha,r);\n                }\n              else\n                  SetPixelAlpha(image,OpaqueAlpha,r);\n              r+=GetPixelChannels(image);\n          }\n\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n\n          if (image_colors != 0 && image_colors <= 256 &&\n             image->colormap != NULL)\n            for (i=0; i<image_colors; i++)\n                image->colormap[i].alpha =\n                    (image->colormap[i].alpha > TransparentAlpha/2 ?\n                    TransparentAlpha : OpaqueAlpha);\n        }\n      continue;\n    }\n\n    /* PNG8 can't have more than 256 colors so we quantize the pixels and\n     * background color to the 4-4-4-1, 3-3-3-1 or 3-3-2-1 palette.  If the\n     * image is mostly gray, the 4-4-4-1 palette is likely to end up with 256\n     * colors or less.\n     */\n    if (tried_444 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 4-4-4\");\n\n        tried_444 = MagickTrue;\n\n        LBR04PacketRGB(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 4-4-4\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR04PixelRGB(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 4-4-4\");\n\n          for (i=0; i<image_colors; i++)\n          {\n            LBR04PacketRGB(image->colormap[i]);\n          }\n        }\n        continue;\n      }\n\n    if (tried_333 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 3-3-3\");\n\n        tried_333 = MagickTrue;\n\n        LBR03PacketRGB(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 3-3-3-1\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR03RGB(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 3-3-3-1\");\n          for (i=0; i<image_colors; i++)\n          {\n              LBR03PacketRGB(image->colormap[i]);\n          }\n        }\n        continue;\n      }\n\n    if (tried_332 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 3-3-2\");\n\n        tried_332 = MagickTrue;\n\n        /* Red and green were already done so we only quantize the blue\n         * channel\n         */\n\n        LBR02PacketBlue(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 3-3-2-1\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR02PixelBlue(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 3-3-2-1\");\n          for (i=0; i<image_colors; i++)\n          {\n              LBR02PacketBlue(image->colormap[i]);\n          }\n      }\n      continue;\n    }\n\n    if (image_colors == 0 || image_colors > 256)\n    {\n      /* Take care of special case with 256 opaque colors + 1 transparent\n       * color.  We don't need to quantize to 2-3-2-1; we only need to\n       * eliminate one color, so we'll merge the two darkest red\n       * colors (0x49, 0, 0) -> (0x24, 0, 0).\n       */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Merging two dark red background colors to 3-3-2-1\");\n\n      if (ScaleQuantumToChar(image->background_color.red) == 0x49 &&\n          ScaleQuantumToChar(image->background_color.green) == 0x00 &&\n          ScaleQuantumToChar(image->background_color.blue) == 0x00)\n      {\n         image->background_color.red=ScaleCharToQuantum(0x24);\n      }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Merging two dark red pixel colors to 3-3-2-1\");\n\n      if (image->colormap == NULL)\n      {\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n          if (r == (Quantum *) NULL)\n            break;\n\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (ScaleQuantumToChar(GetPixelRed(image,r)) == 0x49 &&\n                ScaleQuantumToChar(GetPixelGreen(image,r)) == 0x00 &&\n                ScaleQuantumToChar(GetPixelBlue(image,r)) == 0x00 &&\n                GetPixelAlpha(image,r) == OpaqueAlpha)\n              {\n                SetPixelRed(image,ScaleCharToQuantum(0x24),r);\n              }\n            r+=GetPixelChannels(image);\n          }\n\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n\n        }\n      }\n\n      else\n      {\n         for (i=0; i<image_colors; i++)\n         {\n            if (ScaleQuantumToChar(image->colormap[i].red) == 0x49 &&\n                ScaleQuantumToChar(image->colormap[i].green) == 0x00 &&\n                ScaleQuantumToChar(image->colormap[i].blue) == 0x00)\n            {\n               image->colormap[i].red=ScaleCharToQuantum(0x24);\n            }\n         }\n      }\n    }\n  }\n  }\n  /* END OF BUILD_PALETTE */\n\n  /* If we are excluding the tRNS chunk and there is transparency,\n   * then we must write a Gray-Alpha (color-type 4) or RGBA (color-type 6)\n   * PNG.\n   */\n  if (mng_info->ping_exclude_tRNS != MagickFalse &&\n     (number_transparent != 0 || number_semitransparent != 0))\n    {\n      unsigned int colortype=mng_info->write_png_colortype;\n\n      if (ping_have_color == MagickFalse)\n        mng_info->write_png_colortype = 5;\n\n      else\n        mng_info->write_png_colortype = 7;\n\n      if (colortype != 0 &&\n         mng_info->write_png_colortype != colortype)\n        ping_need_colortype_warning=MagickTrue;\n\n    }\n\n  /* See if cheap transparency is possible.  It is only possible\n   * when there is a single transparent color, no semitransparent\n   * color, and no opaque color that has the same RGB components\n   * as the transparent color.  We only need this information if\n   * we are writing a PNG with colortype 0 or 2, and we have not\n   * excluded the tRNS chunk.\n   */\n  if (number_transparent == 1 &&\n      mng_info->write_png_colortype < 4)\n    {\n       ping_have_cheap_transparency = MagickTrue;\n\n       if (number_semitransparent != 0)\n         ping_have_cheap_transparency = MagickFalse;\n\n       else if (image_colors == 0 || image_colors > 256 ||\n           image->colormap == NULL)\n         {\n           register const Quantum\n             *q;\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             q=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n             if (q == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                 if (GetPixelAlpha(image,q) != TransparentAlpha &&\n                     (unsigned short) GetPixelRed(image,q) ==\n                                     ping_trans_color.red &&\n                     (unsigned short) GetPixelGreen(image,q) ==\n                                     ping_trans_color.green &&\n                     (unsigned short) GetPixelBlue(image,q) ==\n                                     ping_trans_color.blue)\n                   {\n                     ping_have_cheap_transparency = MagickFalse;\n                     break;\n                   }\n\n                 q+=GetPixelChannels(image);\n             }\n\n             if (ping_have_cheap_transparency == MagickFalse)\n                break;\n           }\n         }\n       else\n         {\n            /* Assuming that image->colormap[0] is the one transparent color\n             * and that all others are opaque.\n             */\n            if (image_colors > 1)\n              for (i=1; i<image_colors; i++)\n                if (image->colormap[i].red == image->colormap[0].red &&\n                    image->colormap[i].green == image->colormap[0].green &&\n                    image->colormap[i].blue == image->colormap[0].blue)\n                  {\n                     ping_have_cheap_transparency = MagickFalse;\n                     break;\n                  }\n         }\n\n       if (logging != MagickFalse)\n         {\n           if (ping_have_cheap_transparency == MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"   Cheap transparency is not possible.\");\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"   Cheap transparency is possible.\");\n         }\n     }\n  else\n    ping_have_cheap_transparency = MagickFalse;\n\n  image_depth=image->depth;\n\n  quantum_info = (QuantumInfo *) NULL;\n  number_colors=0;\n  image_colors=(int) image->colors;\n  image_matte=image->alpha_trait !=\n        UndefinedPixelTrait ? MagickTrue : MagickFalse;\n\n  if (mng_info->write_png_colortype < 5)\n    mng_info->IsPalette=image->storage_class == PseudoClass &&\n      image_colors <= 256 && image->colormap != NULL;\n  else\n    mng_info->IsPalette = MagickFalse;\n\n  if ((mng_info->write_png_colortype == 4 || mng_info->write_png8) &&\n     (image->colors == 0 || image->colormap == NULL))\n    {\n      image_info=DestroyImageInfo(image_info);\n      image=DestroyImage(image);\n      (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          \"Cannot write PNG8 or color-type 3; colormap is NULL\",\n          \"`%s'\",IMimage->filename);\n      return(MagickFalse);\n    }\n\n  /*\n    Allocate the PNG structures\n  */\n#ifdef PNG_USER_MEM_SUPPORTED\n error_info.image=image;\n error_info.exception=exception;\n  ping=png_create_write_struct_2(PNG_LIBPNG_VER_STRING,&error_info,\n    MagickPNGErrorHandler,MagickPNGWarningHandler,(void *) NULL,\n    (png_malloc_ptr) Magick_png_malloc,(png_free_ptr) Magick_png_free);\n\n#else\n  ping=png_create_write_struct(PNG_LIBPNG_VER_STRING,&error_info,\n    MagickPNGErrorHandler,MagickPNGWarningHandler);\n\n#endif\n  if (ping == (png_struct *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  ping_info=png_create_info_struct(ping);\n\n  if (ping_info == (png_info *) NULL)\n    {\n      png_destroy_write_struct(&ping,(png_info **) NULL);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n\n  png_set_write_fn(ping,image,png_put_data,png_flush_data);\n  pixel_info=(MemoryInfo *) NULL;\n\n  if (setjmp(png_jmpbuf(ping)))\n    {\n      /*\n        PNG write failed.\n      */\n#ifdef PNG_DEBUG\n     if (image_info->verbose)\n        (void) printf(\"PNG write has failed.\\n\");\n#endif\n      png_destroy_write_struct(&ping,&ping_info);\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n      UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n      if (pixel_info != (MemoryInfo *) NULL)\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n\n      if (quantum_info != (QuantumInfo *) NULL)\n        quantum_info=DestroyQuantumInfo(quantum_info);\n\n      if (ping_have_blob != MagickFalse)\n          (void) CloseBlob(image);\n      image_info=DestroyImageInfo(image_info);\n      image=DestroyImage(image);\n      return(MagickFalse);\n    }\n\n  /* {  For navigation to end of SETJMP-protected block.  Within this\n   *    block, use png_error() instead of Throwing an Exception, to ensure\n   *    that libpng is able to clean up, and that the semaphore is unlocked.\n   */\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  LockSemaphoreInfo(ping_semaphore);\n#endif\n\n#ifdef PNG_BENIGN_ERRORS_SUPPORTED\n  /* Allow benign errors */\n  png_set_benign_errors(ping, 1);\n#endif\n\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n  /* Reject images with too many rows or columns */\n  png_set_user_limits(ping,\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(WidthResource)),\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(HeightResource)));\n#endif /* PNG_SET_USER_LIMITS_SUPPORTED */\n\n  /*\n    Prepare PNG for writing.\n  */\n\n#if defined(PNG_MNG_FEATURES_SUPPORTED)\n  if (mng_info->write_mng)\n  {\n     (void) png_permit_mng_features(ping,PNG_ALL_MNG_FEATURES);\n# ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED\n     /* Disable new libpng-1.5.10 feature when writing a MNG because\n      * zero-length PLTE is OK\n      */\n     png_set_check_for_invalid_index (ping, 0);\n# endif\n  }\n\n#else\n# ifdef PNG_WRITE_EMPTY_PLTE_SUPPORTED\n  if (mng_info->write_mng)\n     png_permit_empty_plte(ping,MagickTrue);\n\n# endif\n#endif\n\n  x=0;\n\n  ping_width=(png_uint_32) image->columns;\n  ping_height=(png_uint_32) image->rows;\n\n  if (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32)\n     image_depth=8;\n\n  if (mng_info->write_png48 || mng_info->write_png64)\n     image_depth=16;\n\n  if (mng_info->write_png_depth != 0)\n     image_depth=mng_info->write_png_depth;\n\n  /* Adjust requested depth to next higher valid depth if necessary */\n  if (image_depth > 8)\n     image_depth=16;\n\n  if ((image_depth > 4) && (image_depth < 8))\n     image_depth=8;\n\n  if (image_depth == 3)\n     image_depth=4;\n\n  if (logging != MagickFalse)\n    {\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    width=%.20g\",(double) ping_width);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    height=%.20g\",(double) ping_height);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_matte=%.20g\",(double) image->alpha_trait);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image->depth=%.20g\",(double) image->depth);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Tentative ping_bit_depth=%.20g\",(double) image_depth);\n    }\n\n  save_image_depth=image_depth;\n  ping_bit_depth=(png_byte) save_image_depth;\n\n\n#if defined(PNG_pHYs_SUPPORTED)\n  if (ping_exclude_pHYs == MagickFalse)\n  {\n  if ((image->resolution.x != 0) && (image->resolution.y != 0) &&\n      (!mng_info->write_mng || !mng_info->equal_physs))\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Setting up pHYs chunk\");\n\n      if (image->units == PixelsPerInchResolution)\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_METER;\n          ping_pHYs_x_resolution=\n             (png_uint_32) ((100.0*image->resolution.x+0.5)/2.54);\n          ping_pHYs_y_resolution=\n             (png_uint_32) ((100.0*image->resolution.y+0.5)/2.54);\n        }\n\n      else if (image->units == PixelsPerCentimeterResolution)\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_METER;\n          ping_pHYs_x_resolution=(png_uint_32) (100.0*image->resolution.x+0.5);\n          ping_pHYs_y_resolution=(png_uint_32) (100.0*image->resolution.y+0.5);\n        }\n\n      else\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_UNKNOWN;\n          ping_pHYs_x_resolution=(png_uint_32) image->resolution.x;\n          ping_pHYs_y_resolution=(png_uint_32) image->resolution.y;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Set up PNG pHYs chunk: xres: %.20g, yres: %.20g, units: %d.\",\n          (double) ping_pHYs_x_resolution,(double) ping_pHYs_y_resolution,\n          (int) ping_pHYs_unit_type);\n       ping_have_pHYs = MagickTrue;\n    }\n  }\n#endif\n\n  if (ping_exclude_bKGD == MagickFalse)\n  {\n  if ((!mng_info->adjoin || !mng_info->equal_backgrounds))\n    {\n       unsigned int\n         mask;\n\n       mask=0xffff;\n       if (ping_bit_depth == 8)\n          mask=0x00ff;\n\n       if (ping_bit_depth == 4)\n          mask=0x000f;\n\n       if (ping_bit_depth == 2)\n          mask=0x0003;\n\n       if (ping_bit_depth == 1)\n          mask=0x0001;\n\n       ping_background.red=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.red) & mask);\n\n       ping_background.green=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.green) & mask);\n\n       ping_background.blue=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.blue) & mask);\n\n       ping_background.gray=(png_uint_16) ping_background.green;\n    }\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Setting up bKGD chunk (1)\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"      background_color index is %d\",\n          (int) ping_background.index);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    ping_bit_depth=%d\",ping_bit_depth);\n    }\n\n  ping_have_bKGD = MagickTrue;\n  }\n\n  /*\n    Select the color type.\n  */\n  matte=image_matte;\n  old_bit_depth=0;\n\n  if (mng_info->IsPalette && mng_info->write_png8)\n    {\n      /* To do: make this a function cause it's used twice, except\n         for reducing the sample depth from 8. */\n\n      number_colors=image_colors;\n\n      ping_have_tRNS=MagickFalse;\n\n      /*\n        Set image palette.\n      */\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Setting up PLTE chunk with %d colors (%d)\",\n            number_colors, image_colors);\n\n      for (i=0; i < (ssize_t) number_colors; i++)\n      {\n        palette[i].red=ScaleQuantumToChar(image->colormap[i].red);\n        palette[i].green=ScaleQuantumToChar(image->colormap[i].green);\n        palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n#if MAGICKCORE_QUANTUM_DEPTH == 8\n            \"    %3ld (%3d,%3d,%3d)\",\n#else\n            \"    %5ld (%5d,%5d,%5d)\",\n#endif\n            (long) i,palette[i].red,palette[i].green,palette[i].blue);\n\n      }\n\n      ping_have_PLTE=MagickTrue;\n      image_depth=ping_bit_depth;\n      ping_num_trans=0;\n\n      if (matte != MagickFalse)\n      {\n          /*\n            Identify which colormap entry is transparent.\n          */\n          assert(number_colors <= 256);\n          assert(image->colormap != NULL);\n\n          for (i=0; i < (ssize_t) number_transparent; i++)\n             ping_trans_alpha[i]=0;\n\n\n          ping_num_trans=(unsigned short) (number_transparent +\n             number_semitransparent);\n\n          if (ping_num_trans == 0)\n             ping_have_tRNS=MagickFalse;\n\n          else\n             ping_have_tRNS=MagickTrue;\n      }\n\n      if (ping_exclude_bKGD == MagickFalse)\n      {\n       /*\n        * Identify which colormap entry is the background color.\n        */\n\n        for (i=0; i < (ssize_t) MagickMax(1L*number_colors-1L,1L); i++)\n          if (IsPNGColorEqual(ping_background,image->colormap[i]))\n            break;\n\n        ping_background.index=(png_byte) i;\n\n        if (logging != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"      background_color index is %d\",\n                 (int) ping_background.index);\n          }\n      }\n    } /* end of write_png8 */\n\n  else if (mng_info->write_png_colortype == 1)\n    {\n      image_matte=MagickFalse;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;\n    }\n\n  else if (mng_info->write_png24 || mng_info->write_png48 ||\n      mng_info->write_png_colortype == 3)\n    {\n      image_matte=MagickFalse;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n    }\n\n  else if (mng_info->write_png32 || mng_info->write_png64 ||\n      mng_info->write_png_colortype == 7)\n    {\n      image_matte=MagickTrue;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;\n    }\n\n  else /* mng_info->write_pngNN not specified */\n    {\n      image_depth=ping_bit_depth;\n\n      if (mng_info->write_png_colortype != 0)\n        {\n          ping_color_type=(png_byte) mng_info->write_png_colortype-1;\n\n          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||\n              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            image_matte=MagickTrue;\n\n          else\n            image_matte=MagickFalse;\n\n          if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"   PNG colortype %d was specified:\",(int) ping_color_type);\n        }\n\n      else /* write_png_colortype not specified */\n        {\n          if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Selecting PNG colortype:\");\n\n          ping_color_type=(png_byte) ((matte != MagickFalse)?\n            PNG_COLOR_TYPE_RGB_ALPHA:PNG_COLOR_TYPE_RGB);\n\n          if (image_info->type == TrueColorType)\n            {\n              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n              image_matte=MagickFalse;\n            }\n\n          if (image_info->type == TrueColorAlphaType)\n            {\n              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;\n              image_matte=MagickTrue;\n            }\n\n          if (image_info->type == PaletteType ||\n              image_info->type == PaletteAlphaType)\n            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n          if (mng_info->write_png_colortype == 0 &&\n             image_info->type == UndefinedType)\n            {\n              if (ping_have_color == MagickFalse)\n                {\n                  if (image_matte == MagickFalse)\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;\n                      image_matte=MagickFalse;\n                    }\n\n                  else\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY_ALPHA;\n                      image_matte=MagickTrue;\n                    }\n                }\n              else\n                {\n                  if (image_matte == MagickFalse)\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n                      image_matte=MagickFalse;\n                    }\n\n                  else\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGBA;\n                      image_matte=MagickTrue;\n                    }\n                 }\n            }\n\n        }\n\n      if (logging != MagickFalse)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"    Selected PNG colortype=%d\",ping_color_type);\n\n      if (ping_bit_depth < 8)\n        {\n          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||\n              ping_color_type == PNG_COLOR_TYPE_RGB ||\n              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            ping_bit_depth=8;\n        }\n\n      old_bit_depth=ping_bit_depth;\n\n      if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n        {\n          if (image->alpha_trait == UndefinedPixelTrait &&\n               ping_have_non_bw == MagickFalse)\n             ping_bit_depth=1;\n        }\n\n      if (ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        {\n           size_t one = 1;\n           ping_bit_depth=1;\n\n           if (image->colors == 0)\n           {\n              /* DO SOMETHING */\n                png_error(ping,\"image has 0 colors\");\n           }\n\n           while ((int) (one << ping_bit_depth) < (ssize_t) image_colors)\n             ping_bit_depth <<= 1;\n        }\n\n      if (logging != MagickFalse)\n         {\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Number of colors: %.20g\",(double) image_colors);\n\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Tentative PNG bit depth: %d\",ping_bit_depth);\n         }\n\n      if (ping_bit_depth < (int) mng_info->write_png_depth)\n         ping_bit_depth = mng_info->write_png_depth;\n    }\n\n  image_depth=ping_bit_depth;\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Tentative PNG color type: %s (%.20g)\",\n        PngColorTypeToString(ping_color_type),\n        (double) ping_color_type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_info->type: %.20g\",(double) image_info->type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_depth: %.20g\",(double) image_depth);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\n        \"    image->depth: %.20g\",(double) image->depth);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    ping_bit_depth: %.20g\",(double) ping_bit_depth);\n    }\n\n  if (matte != MagickFalse)\n    {\n      if (mng_info->IsPalette)\n        {\n          if (mng_info->write_png_colortype == 0)\n            {\n              ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;\n\n              if (ping_have_color != MagickFalse)\n                 ping_color_type=PNG_COLOR_TYPE_RGBA;\n            }\n\n          /*\n           * Determine if there is any transparent color.\n          */\n          if (number_transparent + number_semitransparent == 0)\n            {\n              /*\n                No transparent pixels are present.  Change 4 or 6 to 0 or 2.\n              */\n\n              image_matte=MagickFalse;\n\n              if (mng_info->write_png_colortype == 0)\n                ping_color_type&=0x03;\n            }\n\n          else\n            {\n              unsigned int\n                mask;\n\n              mask=0xffff;\n\n              if (ping_bit_depth == 8)\n                 mask=0x00ff;\n\n              if (ping_bit_depth == 4)\n                 mask=0x000f;\n\n              if (ping_bit_depth == 2)\n                 mask=0x0003;\n\n              if (ping_bit_depth == 1)\n                 mask=0x0001;\n\n              ping_trans_color.red=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].red) & mask);\n\n              ping_trans_color.green=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].green) & mask);\n\n              ping_trans_color.blue=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].blue) & mask);\n\n              ping_trans_color.gray=(png_uint_16)\n                (ScaleQuantumToShort(GetPixelInfoIntensity(image,\n                   image->colormap)) & mask);\n\n              ping_trans_color.index=(png_byte) 0;\n\n              ping_have_tRNS=MagickTrue;\n            }\n\n          if (ping_have_tRNS != MagickFalse)\n            {\n              /*\n               * Determine if there is one and only one transparent color\n               * and if so if it is fully transparent.\n               */\n              if (ping_have_cheap_transparency == MagickFalse)\n                ping_have_tRNS=MagickFalse;\n            }\n\n          if (ping_have_tRNS != MagickFalse)\n            {\n              if (mng_info->write_png_colortype == 0)\n                ping_color_type &= 0x03;  /* changes 4 or 6 to 0 or 2 */\n\n              if (image_depth == 8)\n                {\n                  ping_trans_color.red&=0xff;\n                  ping_trans_color.green&=0xff;\n                  ping_trans_color.blue&=0xff;\n                  ping_trans_color.gray&=0xff;\n                }\n            }\n        }\n      else\n        {\n          if (image_depth == 8)\n            {\n              ping_trans_color.red&=0xff;\n              ping_trans_color.green&=0xff;\n              ping_trans_color.blue&=0xff;\n              ping_trans_color.gray&=0xff;\n            }\n        }\n    }\n\n    matte=image_matte;\n\n    if (ping_have_tRNS != MagickFalse)\n      image_matte=MagickFalse;\n\n    if ((mng_info->IsPalette) &&\n        mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE &&\n        ping_have_color == MagickFalse &&\n        (image_matte == MagickFalse || image_depth >= 8))\n      {\n        size_t one=1;\n\n        if (image_matte != MagickFalse)\n          ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;\n\n        else if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_GRAY_ALPHA)\n          {\n            ping_color_type=PNG_COLOR_TYPE_GRAY;\n\n            if (save_image_depth == 16 && image_depth == 8)\n              {\n                if (logging != MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Scaling ping_trans_color (0)\");\n                  }\n                    ping_trans_color.gray*=0x0101;\n              }\n          }\n\n        if (image_depth > MAGICKCORE_QUANTUM_DEPTH)\n          image_depth=MAGICKCORE_QUANTUM_DEPTH;\n\n        if ((image_colors == 0) ||\n             ((ssize_t) (image_colors-1) > (ssize_t) MaxColormapSize))\n          image_colors=(int) (one << image_depth);\n\n        if (image_depth > 8)\n          ping_bit_depth=16;\n\n        else\n          {\n            ping_bit_depth=8;\n            if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n              {\n                if(!mng_info->write_png_depth)\n                  {\n                    ping_bit_depth=1;\n\n                    while ((int) (one << ping_bit_depth)\n                        < (ssize_t) image_colors)\n                      ping_bit_depth <<= 1;\n                  }\n              }\n\n            else if (ping_color_type ==\n                PNG_COLOR_TYPE_GRAY && image_colors < 17 &&\n                mng_info->IsPalette)\n              {\n              /* Check if grayscale is reducible */\n\n                int\n                  depth_4_ok=MagickTrue,\n                  depth_2_ok=MagickTrue,\n                  depth_1_ok=MagickTrue;\n\n                for (i=0; i < (ssize_t) image_colors; i++)\n                {\n                   unsigned char\n                     intensity;\n\n                   intensity=ScaleQuantumToChar(image->colormap[i].red);\n\n                   if ((intensity & 0x0f) != ((intensity & 0xf0) >> 4))\n                     depth_4_ok=depth_2_ok=depth_1_ok=MagickFalse;\n                   else if ((intensity & 0x03) != ((intensity & 0x0c) >> 2))\n                     depth_2_ok=depth_1_ok=MagickFalse;\n                   else if ((intensity & 0x01) != ((intensity & 0x02) >> 1))\n                     depth_1_ok=MagickFalse;\n                }\n\n                if (depth_1_ok && mng_info->write_png_depth <= 1)\n                  ping_bit_depth=1;\n\n                else if (depth_2_ok && mng_info->write_png_depth <= 2)\n                  ping_bit_depth=2;\n\n                else if (depth_4_ok && mng_info->write_png_depth <= 4)\n                  ping_bit_depth=4;\n              }\n          }\n\n          image_depth=ping_bit_depth;\n      }\n\n    else\n\n      if (mng_info->IsPalette)\n      {\n        number_colors=image_colors;\n\n        if (image_depth <= 8)\n          {\n            /*\n              Set image palette.\n            */\n            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n            if (!(mng_info->have_write_global_plte && matte == MagickFalse))\n              {\n                for (i=0; i < (ssize_t) number_colors; i++)\n                {\n                  palette[i].red=ScaleQuantumToChar(image->colormap[i].red);\n                  palette[i].green=\n                    ScaleQuantumToChar(image->colormap[i].green);\n                  palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);\n                }\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Setting up PLTE chunk with %d colors\",\n                    number_colors);\n\n                ping_have_PLTE=MagickTrue;\n              }\n\n            /* color_type is PNG_COLOR_TYPE_PALETTE */\n            if (mng_info->write_png_depth == 0)\n              {\n                size_t\n                  one;\n\n                ping_bit_depth=1;\n                one=1;\n\n                while ((one << ping_bit_depth) < (size_t) number_colors)\n                  ping_bit_depth <<= 1;\n              }\n\n            ping_num_trans=0;\n\n            if (matte != MagickFalse)\n              {\n                /*\n                 * Set up trans_colors array.\n                 */\n                assert(number_colors <= 256);\n\n                ping_num_trans=(unsigned short) (number_transparent +\n                  number_semitransparent);\n\n                if (ping_num_trans == 0)\n                  ping_have_tRNS=MagickFalse;\n\n                else\n                  {\n                    if (logging != MagickFalse)\n                      {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Scaling ping_trans_color (1)\");\n                      }\n                    ping_have_tRNS=MagickTrue;\n\n                    for (i=0; i < ping_num_trans; i++)\n                    {\n                       ping_trans_alpha[i]= (png_byte)\n                         ScaleQuantumToChar(image->colormap[i].alpha);\n                    }\n                  }\n              }\n          }\n      }\n\n    else\n      {\n\n        if (image_depth < 8)\n          image_depth=8;\n\n        if ((save_image_depth == 16) && (image_depth == 8))\n          {\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Scaling ping_trans_color from (%d,%d,%d)\",\n                  (int) ping_trans_color.red,\n                  (int) ping_trans_color.green,\n                  (int) ping_trans_color.blue);\n              }\n\n            ping_trans_color.red*=0x0101;\n            ping_trans_color.green*=0x0101;\n            ping_trans_color.blue*=0x0101;\n            ping_trans_color.gray*=0x0101;\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    to (%d,%d,%d)\",\n                  (int) ping_trans_color.red,\n                  (int) ping_trans_color.green,\n                  (int) ping_trans_color.blue);\n              }\n          }\n      }\n\n    if (ping_bit_depth <  (ssize_t) mng_info->write_png_depth)\n         ping_bit_depth =  (ssize_t) mng_info->write_png_depth;\n\n    /*\n      Adjust background and transparency samples in sub-8-bit grayscale files.\n    */\n    if (ping_bit_depth < 8 && ping_color_type ==\n        PNG_COLOR_TYPE_GRAY)\n      {\n         png_uint_16\n           maxval;\n\n         size_t\n           one=1;\n\n         maxval=(png_uint_16) ((one << ping_bit_depth)-1);\n\n         if (ping_exclude_bKGD == MagickFalse)\n         {\n\n         ping_background.gray=(png_uint_16) ((maxval/65535.)*\n           (ScaleQuantumToShort(((GetPixelInfoIntensity(image,\n           &image->background_color))) +.5)));\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Setting up bKGD chunk (2)\");\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      background_color index is %d\",\n             (int) ping_background.index);\n\n         ping_have_bKGD = MagickTrue;\n         }\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Scaling ping_trans_color.gray from %d\",\n             (int)ping_trans_color.gray);\n\n         ping_trans_color.gray=(png_uint_16) ((maxval/255.)*(\n           ping_trans_color.gray)+.5);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      to %d\", (int)ping_trans_color.gray);\n      }\n\n  if (ping_exclude_bKGD == MagickFalse)\n  {\n    if (mng_info->IsPalette && (int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n      {\n        /*\n           Identify which colormap entry is the background color.\n        */\n\n        number_colors=image_colors;\n\n        for (i=0; i < (ssize_t) MagickMax(1L*number_colors,1L); i++)\n          if (IsPNGColorEqual(image->background_color,image->colormap[i]))\n            break;\n\n        ping_background.index=(png_byte) i;\n\n        if (logging != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Setting up bKGD chunk with index=%d\",(int) i);\n          }\n\n        if (i < (ssize_t) number_colors)\n          {\n            ping_have_bKGD = MagickTrue;\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"     background   =(%d,%d,%d)\",\n                        (int) ping_background.red,\n                        (int) ping_background.green,\n                        (int) ping_background.blue);\n              }\n          }\n\n        else  /* Can't happen */\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      No room in PLTE to add bKGD color\");\n            ping_have_bKGD = MagickFalse;\n          }\n      }\n  }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    PNG color type: %s (%d)\", PngColorTypeToString(ping_color_type),\n      ping_color_type);\n  /*\n    Initialize compression level and filtering.\n  */\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Setting up deflate compression\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Compression buffer size: 32768\");\n    }\n\n  png_set_compression_buffer_size(ping,32768L);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Compression mem level: 9\");\n\n  png_set_compression_mem_level(ping, 9);\n\n  /* Untangle the \"-quality\" setting:\n\n     Undefined is 0; the default is used.\n     Default is 75\n\n     10's digit:\n\n        0 or omitted: Use Z_HUFFMAN_ONLY strategy with the\n           zlib default compression level\n\n        1-9: the zlib compression level\n\n     1's digit:\n\n        0-4: the PNG filter method\n\n        5:   libpng adaptive filtering if compression level > 5\n             libpng filter type \"none\" if compression level <= 5\n                or if image is grayscale or palette\n\n        6:   libpng adaptive filtering\n\n        7:   \"LOCO\" filtering (intrapixel differing) if writing\n             a MNG, otherwise \"none\".  Did not work in IM-6.7.0-9\n             and earlier because of a missing \"else\".\n\n        8:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), adaptive\n             filtering. Unused prior to IM-6.7.0-10, was same as 6\n\n        9:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), no PNG filters\n             Unused prior to IM-6.7.0-10, was same as 6\n\n    Note that using the -quality option, not all combinations of\n    PNG filter type, zlib compression level, and zlib compression\n    strategy are possible.  This will be addressed soon in a\n    release that accomodates \"-define png:compression-strategy\", etc.\n\n   */\n\n  quality=image_info->quality == UndefinedCompressionQuality ? 75UL :\n     image_info->quality;\n\n  if (quality <= 9)\n    {\n      if (mng_info->write_png_compression_strategy == 0)\n        mng_info->write_png_compression_strategy = Z_HUFFMAN_ONLY+1;\n    }\n\n  else if (mng_info->write_png_compression_level == 0)\n    {\n      int\n        level;\n\n      level=(int) MagickMin((ssize_t) quality/10,9);\n\n      mng_info->write_png_compression_level = level+1;\n    }\n\n  if (mng_info->write_png_compression_strategy == 0)\n    {\n        if ((quality %10) == 8 || (quality %10) == 9)\n#ifdef Z_RLE  /* Z_RLE was added to zlib-1.2.0 */\n          mng_info->write_png_compression_strategy=Z_RLE+1;\n#else\n          mng_info->write_png_compression_strategy = Z_DEFAULT_STRATEGY+1;\n#endif\n    }\n\n  if (mng_info->write_png_compression_filter == 0)\n        mng_info->write_png_compression_filter=((int) quality % 10) + 1;\n\n  if (logging != MagickFalse)\n    {\n        if (mng_info->write_png_compression_level)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Compression level:    %d\",\n            (int) mng_info->write_png_compression_level-1);\n\n        if (mng_info->write_png_compression_strategy)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Compression strategy: %d\",\n            (int) mng_info->write_png_compression_strategy-1);\n\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Setting up filtering\");\n\n        if (mng_info->write_png_compression_filter == 6)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: ADAPTIVE\");\n        else if (mng_info->write_png_compression_filter == 0 ||\n                 mng_info->write_png_compression_filter == 1)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: NONE\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: %d\",\n            (int) mng_info->write_png_compression_filter-1);\n    }\n\n  if (mng_info->write_png_compression_level != 0)\n    png_set_compression_level(ping,mng_info->write_png_compression_level-1);\n\n  if (mng_info->write_png_compression_filter == 6)\n    {\n      if (((int) ping_color_type == PNG_COLOR_TYPE_GRAY) ||\n         ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE) ||\n         (quality < 50))\n        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n      else\n        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);\n     }\n  else if (mng_info->write_png_compression_filter == 7 ||\n      mng_info->write_png_compression_filter == 10)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);\n\n  else if (mng_info->write_png_compression_filter == 8)\n    {\n#if defined(PNG_MNG_FEATURES_SUPPORTED) && defined(PNG_INTRAPIXEL_DIFFERENCING)\n      if (mng_info->write_mng)\n      {\n         if (((int) ping_color_type == PNG_COLOR_TYPE_RGB) ||\n             ((int) ping_color_type == PNG_COLOR_TYPE_RGBA))\n        ping_filter_method=PNG_INTRAPIXEL_DIFFERENCING;\n      }\n#endif\n      png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n    }\n\n  else if (mng_info->write_png_compression_filter == 9)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n\n  else if (mng_info->write_png_compression_filter != 0)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,\n       mng_info->write_png_compression_filter-1);\n\n  if (mng_info->write_png_compression_strategy != 0)\n    png_set_compression_strategy(ping,\n       mng_info->write_png_compression_strategy-1);\n\n  ping_interlace_method=image_info->interlace != NoInterlace;\n\n  if (mng_info->write_mng)\n    png_set_sig_bytes(ping,8);\n\n  /* Bail out if cannot meet defined png:bit-depth or png:color-type */\n\n  if (mng_info->write_png_colortype != 0)\n    {\n     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY)\n       if (ping_have_color != MagickFalse)\n         {\n           ping_color_type = PNG_COLOR_TYPE_RGB;\n\n           if (ping_bit_depth < 8)\n             ping_bit_depth=8;\n         }\n\n     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY_ALPHA)\n       if (ping_have_color != MagickFalse)\n         ping_color_type = PNG_COLOR_TYPE_RGB_ALPHA;\n    }\n\n  if (ping_need_colortype_warning != MagickFalse ||\n     ((mng_info->write_png_depth &&\n     (int) mng_info->write_png_depth != ping_bit_depth) ||\n     (mng_info->write_png_colortype &&\n     ((int) mng_info->write_png_colortype-1 != ping_color_type &&\n      mng_info->write_png_colortype != 7 &&\n      !(mng_info->write_png_colortype == 5 && ping_color_type == 0)))))\n    {\n      if (logging != MagickFalse)\n        {\n          if (ping_need_colortype_warning != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  Image has transparency but tRNS chunk was excluded\");\n            }\n\n          if (mng_info->write_png_depth)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Defined png:bit-depth=%u, Computed depth=%u\",\n                  mng_info->write_png_depth,\n                  ping_bit_depth);\n            }\n\n          if (mng_info->write_png_colortype)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Defined png:color-type=%u, Computed color type=%u\",\n                  mng_info->write_png_colortype-1,\n                  ping_color_type);\n            }\n        }\n\n      png_warning(ping,\n        \"Cannot write image with defined png:bit-depth or png:color-type.\");\n    }\n\n  if (image_matte != MagickFalse && image->alpha_trait == UndefinedPixelTrait)\n    {\n      /* Add an opaque matte channel */\n      image->alpha_trait = BlendPixelTrait;\n      (void) SetImageAlpha(image,OpaqueAlpha,exception);\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Added an opaque matte channel\");\n    }\n\n  if (number_transparent != 0 || number_semitransparent != 0)\n    {\n      if (ping_color_type < 4)\n        {\n           ping_have_tRNS=MagickTrue;\n           if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Setting ping_have_tRNS=MagickTrue.\");\n        }\n    }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Writing PNG header chunks\");\n\n  png_set_IHDR(ping,ping_info,ping_width,ping_height,\n               ping_bit_depth,ping_color_type,\n               ping_interlace_method,ping_compression_method,\n               ping_filter_method);\n\n  if (ping_color_type == 3 && ping_have_PLTE != MagickFalse)\n    {\n      png_set_PLTE(ping,ping_info,palette,number_colors);\n\n      if (logging != MagickFalse)\n        {\n          for (i=0; i< (ssize_t) number_colors; i++)\n          {\n            if (i < ping_num_trans)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"     PLTE[%d] = (%d,%d,%d), tRNS[%d] = (%d)\",\n                      (int) i,\n                      (int) palette[i].red,\n                      (int) palette[i].green,\n                      (int) palette[i].blue,\n                      (int) i,\n                      (int) ping_trans_alpha[i]);\n             else\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"     PLTE[%d] = (%d,%d,%d)\",\n                      (int) i,\n                      (int) palette[i].red,\n                      (int) palette[i].green,\n                      (int) palette[i].blue);\n           }\n         }\n    }\n\n  /* Only write the iCCP chunk if we are not writing the sRGB chunk. */\n  if (ping_exclude_sRGB != MagickFalse ||\n     (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n  {\n    if ((ping_exclude_tEXt == MagickFalse ||\n       ping_exclude_zTXt == MagickFalse) &&\n       (ping_exclude_iCCP == MagickFalse || ping_exclude_zCCP == MagickFalse))\n    {\n      ResetImageProfileIterator(image);\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        profile=GetImageProfile(image,name);\n\n        if (profile != (StringInfo *) NULL)\n          {\n#ifdef PNG_WRITE_iCCP_SUPPORTED\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0))\n              {\n                ping_have_iCCP = MagickTrue;\n                if (ping_exclude_iCCP == MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Setting up iCCP chunk\");\n\n                    png_set_iCCP(ping,ping_info,(png_charp) name,0,\n#if (PNG_LIBPNG_VER < 10500)\n                    (png_charp) GetStringInfoDatum(profile),\n#else\n                    (const png_byte *) GetStringInfoDatum(profile),\n#endif\n                    (png_uint_32) GetStringInfoLength(profile));\n                  }\n                else\n                  {\n                    /* Do not write hex-encoded ICC chunk */\n                       name=GetNextImageProfile(image);\n                       continue;\n                  }\n              }\n#endif /* WRITE_iCCP */\n\n            if (LocaleCompare(name,\"exif\") == 0)\n              {\n                   /* Do not write hex-encoded ICC chunk; we will\n                      write it later as an eXIf chunk */\n                   name=GetNextImageProfile(image);\n                   continue;\n              }\n\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  Setting up zTXt chunk with uuencoded %s profile\",\n                 name);\n              Magick_png_write_raw_profile(image_info,ping,ping_info,\n                (unsigned char *) name,(unsigned char *) name,\n                GetStringInfoDatum(profile),\n                (png_uint_32) GetStringInfoLength(profile));\n          }\n        name=GetNextImageProfile(image);\n      }\n    }\n  }\n\n#if defined(PNG_WRITE_sRGB_SUPPORTED)\n  if ((mng_info->have_write_global_srgb == 0) &&\n      ping_have_iCCP != MagickTrue &&\n      (ping_have_sRGB != MagickFalse ||\n      png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n    {\n      if (ping_exclude_sRGB == MagickFalse)\n        {\n          /*\n            Note image rendering intent.\n          */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Setting up sRGB chunk\");\n\n          (void) png_set_sRGB(ping,ping_info,(\n            Magick_RenderingIntent_to_PNG_RenderingIntent(\n              image->rendering_intent)));\n\n          ping_have_sRGB = MagickTrue;\n        }\n    }\n\n  if ((!mng_info->write_mng) || (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n#endif\n    {\n      if (ping_exclude_gAMA == MagickFalse &&\n          ping_have_iCCP == MagickFalse &&\n          ping_have_sRGB == MagickFalse &&\n          (ping_exclude_sRGB == MagickFalse ||\n          (image->gamma < .45 || image->gamma > .46)))\n      {\n      if ((mng_info->have_write_global_gama == 0) && (image->gamma != 0.0))\n        {\n          /*\n            Note image gamma.\n            To do: check for cHRM+gAMA == sRGB, and write sRGB instead.\n          */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Setting up gAMA chunk\");\n\n          png_set_gAMA(ping,ping_info,image->gamma);\n        }\n      }\n\n      if (ping_exclude_cHRM == MagickFalse && ping_have_sRGB == MagickFalse)\n        {\n          if ((mng_info->have_write_global_chrm == 0) &&\n              (image->chromaticity.red_primary.x != 0.0))\n            {\n              /*\n                Note image chromaticity.\n                Note: if cHRM+gAMA == sRGB write sRGB instead.\n              */\n               PrimaryInfo\n                 bp,\n                 gp,\n                 rp,\n                 wp;\n\n               wp=image->chromaticity.white_point;\n               rp=image->chromaticity.red_primary;\n               gp=image->chromaticity.green_primary;\n               bp=image->chromaticity.blue_primary;\n\n               if (logging != MagickFalse)\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Setting up cHRM chunk\");\n\n               png_set_cHRM(ping,ping_info,wp.x,wp.y,rp.x,rp.y,gp.x,gp.y,\n                   bp.x,bp.y);\n           }\n        }\n    }\n\n  if (ping_exclude_bKGD == MagickFalse)\n    {\n      if (ping_have_bKGD != MagickFalse)\n        {\n          png_set_bKGD(ping,ping_info,&ping_background);\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Setting up bKGD chunk\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      background color = (%d,%d,%d)\",\n                        (int) ping_background.red,\n                        (int) ping_background.green,\n                        (int) ping_background.blue);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      index = %d, gray=%d\",\n                        (int) ping_background.index,\n                        (int) ping_background.gray);\n            }\n         }\n    }\n\n  if (ping_exclude_pHYs == MagickFalse)\n    {\n      if (ping_have_pHYs != MagickFalse)\n        {\n          png_set_pHYs(ping,ping_info,\n             ping_pHYs_x_resolution,\n             ping_pHYs_y_resolution,\n             ping_pHYs_unit_type);\n\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Setting up pHYs chunk\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      x_resolution=%lu\",\n                   (unsigned long) ping_pHYs_x_resolution);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      y_resolution=%lu\",\n                   (unsigned long) ping_pHYs_y_resolution);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      unit_type=%lu\",\n                   (unsigned long) ping_pHYs_unit_type);\n            }\n        }\n    }\n\n#if defined(PNG_tIME_SUPPORTED)\n  if (ping_exclude_tIME == MagickFalse)\n    {\n      const char\n        *timestamp;\n\n      if (image->taint == MagickFalse)\n        {\n          timestamp=GetImageOption(image_info,\"png:tIME\");\n\n          if (timestamp == (const char *) NULL)\n            timestamp=GetImageProperty(image,\"png:tIME\",exception);\n        }\n\n      else\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Reset tIME in tainted image\");\n\n          timestamp=GetImageProperty(image,\"date:modify\",exception);\n        }\n\n      if (timestamp != (const char *) NULL)\n          write_tIME_chunk(image,ping,ping_info,timestamp,exception);\n    }\n#endif\n\n  if (mng_info->need_blob != MagickFalse)\n  {\n    if (OpenBlob(image_info,image,WriteBinaryBlobMode,exception) ==\n       MagickFalse)\n       png_error(ping,\"WriteBlob Failed\");\n\n     ping_have_blob=MagickTrue;\n  }\n\n  png_write_info_before_PLTE(ping, ping_info);\n\n  if (ping_have_tRNS != MagickFalse && ping_color_type < 4)\n    {\n      if (logging != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Calling png_set_tRNS with num_trans=%d\",ping_num_trans);\n        }\n\n      if (ping_color_type == 3)\n         (void) png_set_tRNS(ping, ping_info,\n                ping_trans_alpha,\n                ping_num_trans,\n                NULL);\n\n      else\n        {\n           (void) png_set_tRNS(ping, ping_info,\n                  NULL,\n                  0,\n                  &ping_trans_color);\n\n           if (logging != MagickFalse)\n             {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"     tRNS color   =(%d,%d,%d)\",\n                       (int) ping_trans_color.red,\n                       (int) ping_trans_color.green,\n                       (int) ping_trans_color.blue);\n             }\n         }\n    }\n\n  /* write any png-chunk-b profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-b\",logging);\n\n  png_write_info(ping,ping_info);\n\n  /* write any PNG-chunk-m profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-m\",logging);\n\n  ping_wrote_caNv = MagickFalse;\n\n  /* write caNv chunk */\n  if (ping_exclude_caNv == MagickFalse)\n    {\n      if ((image->page.width != 0 && image->page.width != image->columns) ||\n          (image->page.height != 0 && image->page.height != image->rows) ||\n          image->page.x != 0 || image->page.y != 0)\n        {\n          unsigned char\n            chunk[20];\n\n          (void) WriteBlobMSBULong(image,16L);  /* data length=8 */\n          PNGType(chunk,mng_caNv);\n          LogPNGChunk(logging,mng_caNv,16L);\n          PNGLong(chunk+4,(png_uint_32) image->page.width);\n          PNGLong(chunk+8,(png_uint_32) image->page.height);\n          PNGsLong(chunk+12,(png_int_32) image->page.x);\n          PNGsLong(chunk+16,(png_int_32) image->page.y);\n          (void) WriteBlob(image,20,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,20));\n          ping_wrote_caNv = MagickTrue;\n        }\n    }\n\n#if defined(PNG_oFFs_SUPPORTED)\n  if (ping_exclude_oFFs == MagickFalse && ping_wrote_caNv == MagickFalse)\n    {\n      if (image->page.x || image->page.y)\n        {\n           png_set_oFFs(ping,ping_info,(png_int_32) image->page.x,\n              (png_int_32) image->page.y, 0);\n\n           if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"    Setting up oFFs chunk with x=%d, y=%d, units=0\",\n                 (int) image->page.x, (int) image->page.y);\n        }\n    }\n#endif\n\n  /* write vpAg chunk (deprecated, replaced by caNv) */\n  if (ping_exclude_vpAg == MagickFalse && ping_wrote_caNv == MagickFalse)\n    {\n      if ((image->page.width != 0 && image->page.width != image->columns) ||\n          (image->page.height != 0 && image->page.height != image->rows))\n        {\n          unsigned char\n            chunk[14];\n\n          (void) WriteBlobMSBULong(image,9L);  /* data length=8 */\n          PNGType(chunk,mng_vpAg);\n          LogPNGChunk(logging,mng_vpAg,9L);\n          PNGLong(chunk+4,(png_uint_32) image->page.width);\n          PNGLong(chunk+8,(png_uint_32) image->page.height);\n          chunk[12]=0;   /* unit = pixels */\n          (void) WriteBlob(image,13,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,13));\n        }\n    }\n\n#if (PNG_LIBPNG_VER == 10206)\n    /* avoid libpng-1.2.6 bug by setting PNG_HAVE_IDAT flag */\n#define PNG_HAVE_IDAT               0x04\n    ping->mode |= PNG_HAVE_IDAT;\n#undef PNG_HAVE_IDAT\n#endif\n\n  png_set_packing(ping);\n  /*\n    Allocate memory.\n  */\n  rowbytes=image->columns;\n  if (image_depth > 8)\n    rowbytes*=2;\n  switch (ping_color_type)\n    {\n      case PNG_COLOR_TYPE_RGB:\n        rowbytes*=3;\n        break;\n\n      case PNG_COLOR_TYPE_GRAY_ALPHA:\n        rowbytes*=2;\n        break;\n\n      case PNG_COLOR_TYPE_RGBA:\n        rowbytes*=4;\n        break;\n\n      default:\n        break;\n    }\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Writing PNG image data\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Allocating %.20g bytes of memory for pixels\",(double) rowbytes);\n    }\n  pixel_info=AcquireVirtualMemory(rowbytes,sizeof(*ping_pixels));\n  if (pixel_info == (MemoryInfo *) NULL)\n    png_error(ping,\"Allocation of memory for pixels failed\");\n  ping_pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n\n  /*\n    Initialize image scanlines.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    png_error(ping,\"Memory allocation for quantum_info failed\");\n  quantum_info->format=UndefinedQuantumFormat;\n  SetQuantumDepth(image,quantum_info,image_depth);\n  (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n  num_passes=png_set_interlace_handling(ping);\n\n  if ((!mng_info->write_png8 && !mng_info->write_png24 &&\n       !mng_info->write_png48 && !mng_info->write_png64 &&\n       !mng_info->write_png32) &&\n       (mng_info->IsPalette ||\n       (image_info->type == BilevelType)) &&\n       image_matte == MagickFalse &&\n       ping_have_non_bw == MagickFalse)\n    {\n      /* Palette, Bilevel, or Opaque Monochrome */\n      register const Quantum\n        *p;\n\n      SetQuantumDepth(image,quantum_info,8);\n      for (pass=0; pass < num_passes; pass++)\n      {\n        /*\n          Convert PseudoClass image to a PNG monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          if (logging != MagickFalse && y == 0)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"    Writing row of pixels (0)\");\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n\n          if (p == (const Quantum *) NULL)\n            break;\n\n          if (mng_info->IsPalette)\n            {\n              (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                quantum_info,GrayQuantum,ping_pixels,exception);\n              if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_PALETTE &&\n                  mng_info->write_png_depth &&\n                  mng_info->write_png_depth != old_bit_depth)\n                {\n                  /* Undo pixel scaling */\n                  for (i=0; i < (ssize_t) image->columns; i++)\n                     *(ping_pixels+i)=(unsigned char) (*(ping_pixels+i)\n                     >> (8-old_bit_depth));\n                }\n            }\n\n          else\n            {\n              (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                quantum_info,RedQuantum,ping_pixels,exception);\n            }\n\n          if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE)\n            for (i=0; i < (ssize_t) image->columns; i++)\n               *(ping_pixels+i)=(unsigned char) ((*(ping_pixels+i) > 127) ?\n                      255 : 0);\n\n          if (logging != MagickFalse && y == 0)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Writing row of pixels (1)\");\n\n          png_write_row(ping,ping_pixels);\n\n          status=SetImageProgress(image,SaveImageTag,\n              (MagickOffsetType) (pass * image->rows + y),\n              num_passes * image->rows);\n\n          if (status == MagickFalse)\n            break;\n        }\n      }\n    }\n\n  else   /* Not Palette, Bilevel, or Opaque Monochrome */\n    {\n      if ((!mng_info->write_png8 && !mng_info->write_png24 &&\n          !mng_info->write_png48 && !mng_info->write_png64 &&\n          !mng_info->write_png32) && (image_matte != MagickFalse ||\n          (ping_bit_depth >= MAGICKCORE_QUANTUM_DEPTH)) &&\n          (mng_info->IsPalette) && ping_have_color == MagickFalse)\n        {\n          register const Quantum\n            *p;\n\n          for (pass=0; pass < num_passes; pass++)\n          {\n\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n\n            if (p == (const Quantum *) NULL)\n              break;\n\n            if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n              {\n                if (mng_info->IsPalette)\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,GrayQuantum,ping_pixels,exception);\n\n                else\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RedQuantum,ping_pixels,exception);\n\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"    Writing GRAY PNG pixels (2)\");\n              }\n\n            else /* PNG_COLOR_TYPE_GRAY_ALPHA */\n              {\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Writing GRAY_ALPHA PNG pixels (2)\");\n\n                (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,GrayAlphaQuantum,ping_pixels,exception);\n              }\n\n            if (logging != MagickFalse && y == 0)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Writing row of pixels (2)\");\n\n            png_write_row(ping,ping_pixels);\n\n            status=SetImageProgress(image,SaveImageTag,\n              (MagickOffsetType) (pass * image->rows + y),\n              num_passes * image->rows);\n\n            if (status == MagickFalse)\n              break;\n            }\n          }\n        }\n\n      else\n        {\n          register const Quantum\n            *p;\n\n          for (pass=0; pass < num_passes; pass++)\n          {\n            if ((image_depth > 8) ||\n                mng_info->write_png24 ||\n                mng_info->write_png32 ||\n                mng_info->write_png48 ||\n                mng_info->write_png64 ||\n                (!mng_info->write_png8 && !mng_info->IsPalette))\n            {\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n                if (p == (const Quantum *) NULL)\n                  break;\n\n                if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n                  {\n                    if (image->storage_class == DirectClass)\n                      (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                        quantum_info,RedQuantum,ping_pixels,exception);\n\n                    else\n                      (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                        quantum_info,GrayQuantum,ping_pixels,exception);\n                  }\n\n                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n                  {\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                      quantum_info,GrayAlphaQuantum,ping_pixels,\n                      exception);\n\n                    if (logging != MagickFalse && y == 0)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"    Writing GRAY_ALPHA PNG pixels (3)\");\n                  }\n\n                else if (image_matte != MagickFalse)\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RGBAQuantum,ping_pixels,exception);\n\n                else\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RGBQuantum,ping_pixels,exception);\n\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"    Writing row of pixels (3)\");\n\n                png_write_row(ping,ping_pixels);\n\n                status=SetImageProgress(image,SaveImageTag,\n                  (MagickOffsetType) (pass * image->rows + y),\n                  num_passes * image->rows);\n\n                if (status == MagickFalse)\n                  break;\n              }\n            }\n\n          else\n            /* not ((image_depth > 8) ||\n                mng_info->write_png24 || mng_info->write_png32 ||\n                mng_info->write_png48 || mng_info->write_png64 ||\n                (!mng_info->write_png8 && !mng_info->IsPalette))\n             */\n            {\n              if ((ping_color_type != PNG_COLOR_TYPE_GRAY) &&\n                  (ping_color_type != PNG_COLOR_TYPE_GRAY_ALPHA))\n                {\n                  if (logging != MagickFalse)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"  pass %d, Image Is not GRAY or GRAY_ALPHA\",pass);\n\n                  SetQuantumDepth(image,quantum_info,8);\n                  image_depth=8;\n                }\n\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  pass %d, Image Is RGB, 16-bit GRAY, or GRAY_ALPHA\",\n                    pass);\n\n                p=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n                if (p == (const Quantum *) NULL)\n                  break;\n\n                if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n                  {\n                    SetQuantumDepth(image,quantum_info,image->depth);\n\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                       quantum_info,GrayQuantum,ping_pixels,exception);\n                  }\n\n                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n                  {\n                    if (logging != MagickFalse && y == 0)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"  Writing GRAY_ALPHA PNG pixels (4)\");\n\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                         quantum_info,GrayAlphaQuantum,ping_pixels,\n                         exception);\n                  }\n\n                else\n                  {\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                      quantum_info,IndexQuantum,ping_pixels,exception);\n\n                    if (logging != MagickFalse && y <= 2)\n                    {\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Writing row of non-gray pixels (4)\");\n\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  ping_pixels[0]=%d,ping_pixels[1]=%d\",\n                          (int)ping_pixels[0],(int)ping_pixels[1]);\n                    }\n                  }\n                png_write_row(ping,ping_pixels);\n\n                status=SetImageProgress(image,SaveImageTag,\n                  (MagickOffsetType) (pass * image->rows + y),\n                  num_passes * image->rows);\n\n                if (status == MagickFalse)\n                  break;\n              }\n            }\n          }\n        }\n    }\n\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Wrote PNG image data\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Width: %.20g\",(double) ping_width);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Height: %.20g\",(double) ping_height);\n\n      if (mng_info->write_png_depth)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Defined png:bit-depth: %d\",mng_info->write_png_depth);\n        }\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG bit-depth written: %d\",ping_bit_depth);\n\n      if (mng_info->write_png_colortype)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Defined png:color-type: %d\",mng_info->write_png_colortype-1);\n        }\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG color-type written: %d\",ping_color_type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG Interlace method: %d\",ping_interlace_method);\n    }\n  /*\n    Generate text chunks after IDAT.\n  */\n  if (ping_exclude_tEXt == MagickFalse || ping_exclude_zTXt == MagickFalse)\n  {\n    ResetImagePropertyIterator(image);\n    property=GetNextImageProperty(image);\n    while (property != (const char *) NULL)\n    {\n      png_textp\n        text;\n\n      value=GetImageProperty(image,property,exception);\n\n      /* Don't write any \"png:\" or \"jpeg:\" properties; those are just for\n       * \"identify\" or for passing through to another JPEG\n       */\n      if ((LocaleNCompare(property,\"png:\",4) != 0 &&\n           LocaleNCompare(property,\"jpeg:\",5) != 0) &&\n\n\n          /* Suppress density and units if we wrote a pHYs chunk */\n          (ping_exclude_pHYs != MagickFalse      ||\n          LocaleCompare(property,\"density\") != 0 ||\n          LocaleCompare(property,\"units\") != 0) &&\n\n          /* Suppress the IM-generated Date:create and Date:modify */\n          (ping_exclude_date == MagickFalse      ||\n          LocaleNCompare(property, \"Date:\",5) != 0))\n        {\n        if (value != (const char *) NULL)\n          {\n\n#if PNG_LIBPNG_VER >= 10400\n            text=(png_textp) png_malloc(ping,\n                 (png_alloc_size_t) sizeof(png_text));\n#else\n            text=(png_textp) png_malloc(ping,(png_size_t) sizeof(png_text));\n#endif\n            text[0].key=(char *) property;\n            text[0].text=(char *) value;\n            text[0].text_length=strlen(value);\n\n            if (ping_exclude_tEXt != MagickFalse)\n               text[0].compression=PNG_TEXT_COMPRESSION_zTXt;\n\n            else if (ping_exclude_zTXt != MagickFalse)\n               text[0].compression=PNG_TEXT_COMPRESSION_NONE;\n\n            else\n            {\n               text[0].compression=image_info->compression == NoCompression ||\n                 (image_info->compression == UndefinedCompression &&\n                 text[0].text_length < 128) ? PNG_TEXT_COMPRESSION_NONE :\n                 PNG_TEXT_COMPRESSION_zTXt ;\n            }\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Setting up text chunk\");\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    keyword: '%s'\",text[0].key);\n              }\n\n            png_set_text(ping,ping_info,text,1);\n            png_free(ping,text);\n          }\n        }\n      property=GetNextImageProperty(image);\n    }\n  }\n\n  /* write any PNG-chunk-e profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-e\",logging);\n\n  /* write exIf profile */\n  if (ping_have_eXIf != MagickFalse && ping_exclude_eXIf == MagickFalse)\n    {\n      char\n        *name;\n\n      ResetImageProfileIterator(image);\n\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        if (LocaleCompare(name,\"exif\") == 0)\n          {\n            const StringInfo\n              *profile;\n\n            profile=GetImageProfile(image,name);\n\n            if (profile != (StringInfo *) NULL)\n              {\n                png_uint_32\n                  length;\n\n                unsigned char\n                  chunk[4],\n                  *data;\n\n               StringInfo\n                 *ping_profile;\n\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Have eXIf profile\");\n\n               ping_profile=CloneStringInfo(profile);\n               data=GetStringInfoDatum(ping_profile),\n               length=(png_uint_32) GetStringInfoLength(ping_profile);\n\n               PNGType(chunk,mng_eXIf);\n               if (length < 7)\n                 {\n                   ping_profile=DestroyStringInfo(ping_profile);\n                   break;  /* otherwise crashes */\n                 }\n\n               /* skip the \"Exif\\0\\0\" JFIF Exif Header ID */\n               length -= 6;\n\n               LogPNGChunk(logging,chunk,length);\n               (void) WriteBlobMSBULong(image,length);\n               (void) WriteBlob(image,4,chunk);\n               (void) WriteBlob(image,length,data+6);\n               (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),\n                 data+6, (uInt) length));\n               ping_profile=DestroyStringInfo(ping_profile);\n               break;\n             }\n         }\n       name=GetNextImageProfile(image);\n     }\n  }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Writing PNG end info\");\n\n  png_write_end(ping,ping_info);\n\n  if (mng_info->need_fram && (int) image->dispose == BackgroundDispose)\n    {\n      if (mng_info->page.x || mng_info->page.y ||\n          (ping_width != mng_info->page.width) ||\n          (ping_height != mng_info->page.height))\n        {\n          unsigned char\n            chunk[32];\n\n          /*\n            Write FRAM 4 with clipping boundaries followed by FRAM 1.\n          */\n          (void) WriteBlobMSBULong(image,27L);  /* data length=27 */\n          PNGType(chunk,mng_FRAM);\n          LogPNGChunk(logging,mng_FRAM,27L);\n          chunk[4]=4;\n          chunk[5]=0;  /* frame name separator (no name) */\n          chunk[6]=1;  /* flag for changing delay, for next frame only */\n          chunk[7]=0;  /* flag for changing frame timeout */\n          chunk[8]=1;  /* flag for changing frame clipping for next frame */\n          chunk[9]=0;  /* flag for changing frame sync_id */\n          PNGLong(chunk+10,(png_uint_32) (0L)); /* temporary 0 delay */\n          chunk[14]=0; /* clipping boundaries delta type */\n          PNGLong(chunk+15,(png_uint_32) (mng_info->page.x)); /* left cb */\n          PNGLong(chunk+19,\n             (png_uint_32) (mng_info->page.x + ping_width));\n          PNGLong(chunk+23,(png_uint_32) (mng_info->page.y)); /* top cb */\n          PNGLong(chunk+27,\n             (png_uint_32) (mng_info->page.y + ping_height));\n          (void) WriteBlob(image,31,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,31));\n          mng_info->old_framing_mode=4;\n          mng_info->framing_mode=1;\n        }\n\n      else\n        mng_info->framing_mode=3;\n    }\n  if (mng_info->write_mng && !mng_info->need_fram &&\n      ((int) image->dispose == 3))\n     png_error(ping, \"Cannot convert GIF with disposal method 3 to MNG-LC\");\n\n  /*\n    Free PNG resources.\n  */\n\n  png_destroy_write_struct(&ping,&ping_info);\n\n  pixel_info=RelinquishVirtualMemory(pixel_info);\n\n  if (ping_have_blob != MagickFalse)\n     (void) CloseBlob(image);\n\n  image_info=DestroyImageInfo(image_info);\n  image=DestroyImage(image);\n\n  /* Store bit depth actually written */\n  s[0]=(char) ping_bit_depth;\n  s[1]='\\0';\n\n  (void) SetImageProperty(IMimage,\"png:bit-depth-written\",s,exception);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit WriteOnePNGImage()\");\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n   /* }  for navigation to beginning of SETJMP-protected block. Revert to\n    *    Throwing an Exception when an error occurs.\n    */\n\n  return(MagickTrue);\n/*  End write one PNG image */\n\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P N G I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePNGImage() writes a Portable Network Graphics (PNG) or\n%  Multiple-image Network Graphics (MNG) image file.\n%\n%  MNG support written by Glenn Randers-Pehrson, glennrp@image...\n%\n%  The format of the WritePNGImage method is:\n%\n%      MagickBooleanType WritePNGImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n%  Returns MagickTrue on success, MagickFalse on failure.\n%\n%  Communicating with the PNG encoder:\n%\n%  While the datastream written is always in PNG format and normally would\n%  be given the \"png\" file extension, this method also writes the following\n%  pseudo-formats which are subsets of png:\n%\n%    o PNG8:    An 8-bit indexed PNG datastream is written.  If the image has\n%               a depth greater than 8, the depth is reduced. If transparency\n%               is present, the tRNS chunk must only have values 0 and 255\n%               (i.e., transparency is binary: fully opaque or fully\n%               transparent).  If other values are present they will be\n%               50%-thresholded to binary transparency.  If more than 256\n%               colors are present, they will be quantized to the 4-4-4-1,\n%               3-3-3-1, or 3-3-2-1 palette.  The underlying RGB color\n%               of any resulting fully-transparent pixels is changed to\n%               the image's background color.\n%\n%               If you want better quantization or dithering of the colors\n%               or alpha than that, you need to do it before calling the\n%               PNG encoder. The pixels contain 8-bit indices even if\n%               they could be represented with 1, 2, or 4 bits.  Grayscale\n%               images will be written as indexed PNG files even though the\n%               PNG grayscale type might be slightly more efficient.  Please\n%               note that writing to the PNG8 format may result in loss\n%               of color and alpha data.\n%\n%    o PNG24:   An 8-bit per sample RGB PNG datastream is written.  The tRNS\n%               chunk can be present to convey binary transparency by naming\n%               one of the colors as transparent.  The only loss incurred\n%               is reduction of sample depth to 8.  If the image has more\n%               than one transparent color, has semitransparent pixels, or\n%               has an opaque pixel with the same RGB components as the\n%               transparent color, an image is not written.\n%\n%    o PNG32:   An 8-bit per sample RGBA PNG is written.  Partial\n%               transparency is permitted, i.e., the alpha sample for\n%               each pixel can have any value from 0 to 255. The alpha\n%               channel is present even if the image is fully opaque.\n%               The only loss in data is the reduction of the sample depth\n%               to 8.\n%\n%    o PNG48:   A 16-bit per sample RGB PNG datastream is written.  The tRNS\n%               chunk can be present to convey binary transparency by naming\n%               one of the colors as transparent.  If the image has more\n%               than one transparent color, has semitransparent pixels, or\n%               has an opaque pixel with the same RGB components as the\n%               transparent color, an image is not written.\n%\n%    o PNG64:   A 16-bit per sample RGBA PNG is written.  Partial\n%               transparency is permitted, i.e., the alpha sample for\n%               each pixel can have any value from 0 to 65535. The alpha\n%               channel is present even if the image is fully opaque.\n%\n%    o PNG00:   A PNG that inherits its colortype and bit-depth from the input\n%               image, if the input was a PNG, is written.  If these values\n%               cannot be found, or if the pixels have been changed in a way\n%               that makes this impossible, then \"PNG00\" falls back to the\n%               regular \"PNG\" format.\n%\n%    o -define: For more precise control of the PNG output, you can use the\n%               Image options \"png:bit-depth\" and \"png:color-type\".  These\n%               can be set from the commandline with \"-define\" and also\n%               from the application programming interfaces.  The options\n%               are case-independent and are converted to lowercase before\n%               being passed to this encoder.\n%\n%               png:color-type can be 0, 2, 3, 4, or 6.\n%\n%               When png:color-type is 0 (Grayscale), png:bit-depth can\n%               be 1, 2, 4, 8, or 16.\n%\n%               When png:color-type is 2 (RGB), png:bit-depth can\n%               be 8 or 16.\n%\n%               When png:color-type is 3 (Indexed), png:bit-depth can\n%               be 1, 2, 4, or 8.  This refers to the number of bits\n%               used to store the index.  The color samples always have\n%               bit-depth 8 in indexed PNG files.\n%\n%               When png:color-type is 4 (Gray-Matte) or 6 (RGB-Matte),\n%               png:bit-depth can be 8 or 16.\n%\n%               If the image cannot be written without loss with the\n%               requested bit-depth and color-type, a PNG file will not\n%               be written, a warning will be issued, and the encoder will\n%               return MagickFalse.\n%\n%  Since image encoders should not be responsible for the \"heavy lifting\",\n%  the user should make sure that ImageMagick has already reduced the\n%  image depth and number of colors and limit transparency to binary\n%  transparency prior to attempting to write the image with depth, color,\n%  or transparency limitations.\n%\n%  Note that another definition, \"png:bit-depth-written\" exists, but it\n%  is not intended for external use.  It is only used internally by the\n%  PNG encoder to inform the JNG encoder of the depth of the alpha channel.\n%\n%  It is possible to request that the PNG encoder write previously-formatted\n%  ancillary chunks in the output PNG file, using the \"-profile\" commandline\n%  option as shown below or by setting the profile via a programming\n%  interface:\n%\n%     -profile PNG-chunk-x:<file>\n%\n%  where x is a location flag and <file> is a file containing the chunk\n%  name in the first 4 bytes, then a colon (\":\"), followed by the chunk data.\n%  This encoder will compute the chunk length and CRC, so those must not\n%  be included in the file.\n%\n%  \"x\" can be \"b\" (before PLTE), \"m\" (middle, i.e., between PLTE and IDAT),\n%  or \"e\" (end, i.e., after IDAT).  If you want to write multiple chunks\n%  of the same type, then add a short unique string after the \"x\" to prevent\n%  subsequent profiles from overwriting the preceding ones, e.g.,\n%\n%     -profile PNG-chunk-b01:file01 -profile PNG-chunk-b02:file02\n%\n%  As of version 6.6.6 the following optimizations are always done:\n%\n%   o  32-bit depth is reduced to 16.\n%   o  16-bit depth is reduced to 8 if all pixels contain samples whose\n%      high byte and low byte are identical.\n%   o  Palette is sorted to remove unused entries and to put a\n%      transparent color first, if BUILD_PNG_PALETTE is defined.\n%   o  Opaque matte channel is removed when writing an indexed PNG.\n%   o  Grayscale images are reduced to 1, 2, or 4 bit depth if\n%      this can be done without loss and a larger bit depth N was not\n%      requested via the \"-define png:bit-depth=N\" option.\n%   o  If matte channel is present but only one transparent color is\n%      present, RGB+tRNS is written instead of RGBA\n%   o  Opaque matte channel is removed (or added, if color-type 4 or 6\n%      was requested when converting an opaque image).\n%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\nstatic MagickBooleanType WritePNGImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    excluding,\n    logging,\n    status;\n\n  MngInfo\n    *mng_info;\n\n  const char\n    *value;\n\n  int\n    source;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\"Enter WritePNGImage()\");\n  /*\n    Allocate a MngInfo structure.\n  */\n  mng_info=(MngInfo *) AcquireMagickMemory(sizeof(MngInfo));\n\n  if (mng_info == (MngInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /*\n    Initialize members of the MngInfo structure.\n  */\n  (void) ResetMagickMemory(mng_info,0,sizeof(MngInfo));\n  mng_info->image=image;\n  mng_info->equal_backgrounds=MagickTrue;\n\n  /* See if user has requested a specific PNG subformat */\n\n  mng_info->write_png8=LocaleCompare(image_info->magick,\"PNG8\") == 0;\n  mng_info->write_png24=LocaleCompare(image_info->magick,\"PNG24\") == 0;\n  mng_info->write_png32=LocaleCompare(image_info->magick,\"PNG32\") == 0;\n  mng_info->write_png48=LocaleCompare(image_info->magick,\"PNG48\") == 0;\n  mng_info->write_png64=LocaleCompare(image_info->magick,\"PNG64\") == 0;\n\n  value=GetImageOption(image_info,\"png:format\");\n\n  if (value != (char *) NULL || LocaleCompare(image_info->magick,\"PNG00\") == 0)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"  Format=%s\",value);\n\n      mng_info->write_png8 = MagickFalse;\n      mng_info->write_png24 = MagickFalse;\n      mng_info->write_png32 = MagickFalse;\n      mng_info->write_png48 = MagickFalse;\n      mng_info->write_png64 = MagickFalse;\n\n      if (LocaleCompare(value,\"png8\") == 0)\n        mng_info->write_png8 = MagickTrue;\n\n      else if (LocaleCompare(value,\"png24\") == 0)\n        mng_info->write_png24 = MagickTrue;\n\n      else if (LocaleCompare(value,\"png32\") == 0)\n        mng_info->write_png32 = MagickTrue;\n\n      else if (LocaleCompare(value,\"png48\") == 0)\n        mng_info->write_png48 = MagickTrue;\n\n      else if (LocaleCompare(value,\"png64\") == 0)\n        mng_info->write_png64 = MagickTrue;\n\n      else if ((LocaleCompare(value,\"png00\") == 0) ||\n         LocaleCompare(image_info->magick,\"PNG00\") == 0)\n        {\n          /* Retrieve png:IHDR.bit-depth-orig and png:IHDR.color-type-orig. */\n          value=GetImageProperty(image,\"png:IHDR.bit-depth-orig\",exception);\n\n          if (value != (char *) NULL)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  png00 inherited bit depth=%s\",value);\n\n              if (LocaleCompare(value,\"1\") == 0)\n                mng_info->write_png_depth = 1;\n\n              else if (LocaleCompare(value,\"2\") == 0)\n                mng_info->write_png_depth = 2;\n\n              else if (LocaleCompare(value,\"4\") == 0)\n                mng_info->write_png_depth = 4;\n\n              else if (LocaleCompare(value,\"8\") == 0)\n                mng_info->write_png_depth = 8;\n\n              else if (LocaleCompare(value,\"16\") == 0)\n                mng_info->write_png_depth = 16;\n            }\n\n          value=GetImageProperty(image,\"png:IHDR.color-type-orig\",exception);\n\n          if (value != (char *) NULL)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  png00 inherited color type=%s\",value);\n\n              if (LocaleCompare(value,\"0\") == 0)\n                mng_info->write_png_colortype = 1;\n\n              else if (LocaleCompare(value,\"2\") == 0)\n                mng_info->write_png_colortype = 3;\n\n              else if (LocaleCompare(value,\"3\") == 0)\n                mng_info->write_png_colortype = 4;\n\n              else if (LocaleCompare(value,\"4\") == 0)\n                mng_info->write_png_colortype = 5;\n\n              else if (LocaleCompare(value,\"6\") == 0)\n                mng_info->write_png_colortype = 7;\n            }\n        }\n    }\n\n  if (mng_info->write_png8)\n    {\n      mng_info->write_png_colortype = /* 3 */ 4;\n      mng_info->write_png_depth = 8;\n      image->depth = 8;\n    }\n\n  if (mng_info->write_png24)\n    {\n      mng_info->write_png_colortype = /* 2 */ 3;\n      mng_info->write_png_depth = 8;\n      image->depth = 8;\n\n      if (image->alpha_trait != UndefinedPixelTrait)\n        (void) SetImageType(image,TrueColorAlphaType,exception);\n\n      else\n        (void) SetImageType(image,TrueColorType,exception);\n\n      (void) SyncImage(image,exception);\n    }\n\n  if (mng_info->write_png32)\n    {\n      mng_info->write_png_colortype = /* 6 */  7;\n      mng_info->write_png_depth = 8;\n      image->depth = 8;\n      image->alpha_trait = BlendPixelTrait;\n\n      (void) SetImageType(image,TrueColorAlphaType,exception);\n      (void) SyncImage(image,exception);\n    }\n\n  if (mng_info->write_png48)\n    {\n      mng_info->write_png_colortype = /* 2 */ 3;\n      mng_info->write_png_depth = 16;\n      image->depth = 16;\n\n      if (image->alpha_trait != UndefinedPixelTrait)\n        (void) SetImageType(image,TrueColorAlphaType,exception);\n\n      else\n        (void) SetImageType(image,TrueColorType,exception);\n\n      (void) SyncImage(image,exception);\n    }\n\n  if (mng_info->write_png64)\n    {\n      mng_info->write_png_colortype = /* 6 */  7;\n      mng_info->write_png_depth = 16;\n      image->depth = 16;\n      image->alpha_trait = BlendPixelTrait;\n\n      (void) SetImageType(image,TrueColorAlphaType,exception);\n      (void) SyncImage(image,exception);\n    }\n\n  value=GetImageOption(image_info,\"png:bit-depth\");\n\n  if (value != (char *) NULL)\n    {\n      if (LocaleCompare(value,\"1\") == 0)\n        mng_info->write_png_depth = 1;\n\n      else if (LocaleCompare(value,\"2\") == 0)\n        mng_info->write_png_depth = 2;\n\n      else if (LocaleCompare(value,\"4\") == 0)\n        mng_info->write_png_depth = 4;\n\n      else if (LocaleCompare(value,\"8\") == 0)\n        mng_info->write_png_depth = 8;\n\n      else if (LocaleCompare(value,\"16\") == 0)\n        mng_info->write_png_depth = 16;\n\n      else\n        (void) ThrowMagickException(exception,\n             GetMagickModule(),CoderWarning,\n             \"ignoring invalid defined png:bit-depth\",\n             \"=%s\",value);\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  png:bit-depth=%d was defined.\\n\",mng_info->write_png_depth);\n    }\n\n  value=GetImageOption(image_info,\"png:color-type\");\n\n  if (value != (char *) NULL)\n    {\n      /* We must store colortype+1 because 0 is a valid colortype */\n      if (LocaleCompare(value,\"0\") == 0)\n        mng_info->write_png_colortype = 1;\n\n      else if (LocaleCompare(value,\"1\") == 0)\n        mng_info->write_png_colortype = 2;\n\n      else if (LocaleCompare(value,\"2\") == 0)\n        mng_info->write_png_colortype = 3;\n\n      else if (LocaleCompare(value,\"3\") == 0)\n        mng_info->write_png_colortype = 4;\n\n      else if (LocaleCompare(value,\"4\") == 0)\n        mng_info->write_png_colortype = 5;\n\n      else if (LocaleCompare(value,\"6\") == 0)\n        mng_info->write_png_colortype = 7;\n\n      else\n        (void) ThrowMagickException(exception,\n             GetMagickModule(),CoderWarning,\n             \"ignoring invalid defined png:color-type\",\n             \"=%s\",value);\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  png:color-type=%d was defined.\\n\",\n          mng_info->write_png_colortype-1);\n    }\n\n  /* Check for chunks to be excluded:\n   *\n   * The default is to not exclude any known chunks except for any\n   * listed in the \"unused_chunks\" array, above.\n   *\n   * Chunks can be listed for exclusion via a \"png:exclude-chunk\"\n   * define (in the image properties or in the image artifacts)\n   * or via a mng_info member.  For convenience, in addition\n   * to or instead of a comma-separated list of chunks, the\n   * \"exclude-chunk\" string can be simply \"all\" or \"none\".\n   *\n   * The exclude-chunk define takes priority over the mng_info.\n   *\n   * A \"png:include-chunk\" define takes  priority over both the\n   * mng_info and the \"png:exclude-chunk\" define.  Like the\n   * \"exclude-chunk\" string, it can define \"all\" or \"none\" as\n   * well as a comma-separated list.  Chunks that are unknown to\n   * ImageMagick are always excluded, regardless of their \"copy-safe\"\n   * status according to the PNG specification, and even if they\n   * appear in the \"include-chunk\" list. Such defines appearing among\n   * the image options take priority over those found among the image\n   * artifacts.\n   *\n   * Finally, all chunks listed in the \"unused_chunks\" array are\n   * automatically excluded, regardless of the other instructions\n   * or lack thereof.\n   *\n   * if you exclude sRGB but not gAMA (recommended), then sRGB chunk\n   * will not be written and the gAMA chunk will only be written if it\n   * is not between .45 and .46, or approximately (1.0/2.2).\n   *\n   * If you exclude tRNS and the image has transparency, the colortype\n   * is forced to be 4 or 6 (GRAY_ALPHA or RGB_ALPHA).\n   *\n   * The -strip option causes StripImage() to set the png:include-chunk\n   * artifact to \"none,trns,gama\".\n   */\n\n  mng_info->ping_exclude_bKGD=MagickFalse;\n  mng_info->ping_exclude_caNv=MagickFalse;\n  mng_info->ping_exclude_cHRM=MagickFalse;\n  mng_info->ping_exclude_date=MagickFalse;\n  mng_info->ping_exclude_eXIf=MagickFalse;\n  mng_info->ping_exclude_EXIF=MagickFalse; /* hex-encoded EXIF in zTXt */\n  mng_info->ping_exclude_gAMA=MagickFalse;\n  mng_info->ping_exclude_iCCP=MagickFalse;\n  /* mng_info->ping_exclude_iTXt=MagickFalse; */\n  mng_info->ping_exclude_oFFs=MagickFalse;\n  mng_info->ping_exclude_pHYs=MagickFalse;\n  mng_info->ping_exclude_sRGB=MagickFalse;\n  mng_info->ping_exclude_tEXt=MagickFalse;\n  mng_info->ping_exclude_tIME=MagickFalse;\n  mng_info->ping_exclude_tRNS=MagickFalse;\n  mng_info->ping_exclude_vpAg=MagickFalse;\n  mng_info->ping_exclude_zCCP=MagickFalse; /* hex-encoded iCCP in zTXt */\n  mng_info->ping_exclude_zTXt=MagickFalse;\n\n  mng_info->ping_preserve_colormap=MagickFalse;\n\n  value=GetImageOption(image_info,\"png:preserve-colormap\");\n  if (value == NULL)\n     value=GetImageArtifact(image,\"png:preserve-colormap\");\n  if (value != NULL)\n     mng_info->ping_preserve_colormap=MagickTrue;\n\n  mng_info->ping_preserve_iCCP=MagickFalse;\n\n  value=GetImageOption(image_info,\"png:preserve-iCCP\");\n  if (value == NULL)\n     value=GetImageArtifact(image,\"png:preserve-iCCP\");\n  if (value != NULL)\n     mng_info->ping_preserve_iCCP=MagickTrue;\n\n  /* These compression-level, compression-strategy, and compression-filter\n   * defines take precedence over values from the -quality option.\n   */\n  value=GetImageOption(image_info,\"png:compression-level\");\n  if (value == NULL)\n     value=GetImageArtifact(image,\"png:compression-level\");\n  if (value != NULL)\n  {\n      /* We have to add 1 to everything because 0 is a valid input,\n       * and we want to use 0 (the default) to mean undefined.\n       */\n      if (LocaleCompare(value,\"0\") == 0)\n        mng_info->write_png_compression_level = 1;\n\n      else if (LocaleCompare(value,\"1\") == 0)\n        mng_info->write_png_compression_level = 2;\n\n      else if (LocaleCompare(value,\"2\") == 0)\n        mng_info->write_png_compression_level = 3;\n\n      else if (LocaleCompare(value,\"3\") == 0)\n        mng_info->write_png_compression_level = 4;\n\n      else if (LocaleCompare(value,\"4\") == 0)\n        mng_info->write_png_compression_level = 5;\n\n      else if (LocaleCompare(value,\"5\") == 0)\n        mng_info->write_png_compression_level = 6;\n\n      else if (LocaleCompare(value,\"6\") == 0)\n        mng_info->write_png_compression_level = 7;\n\n      else if (LocaleCompare(value,\"7\") == 0)\n        mng_info->write_png_compression_level = 8;\n\n      else if (LocaleCompare(value,\"8\") == 0)\n        mng_info->write_png_compression_level = 9;\n\n      else if (LocaleCompare(value,\"9\") == 0)\n        mng_info->write_png_compression_level = 10;\n\n      else\n        (void) ThrowMagickException(exception,\n             GetMagickModule(),CoderWarning,\n             \"ignoring invalid defined png:compression-level\",\n             \"=%s\",value);\n    }\n\n  value=GetImageOption(image_info,\"png:compression-strategy\");\n  if (value == NULL)\n     value=GetImageArtifact(image,\"png:compression-strategy\");\n  if (value != NULL)\n  {\n      if (LocaleCompare(value,\"0\") == 0)\n        mng_info->write_png_compression_strategy = Z_DEFAULT_STRATEGY+1;\n\n      else if (LocaleCompare(value,\"1\") == 0)\n        mng_info->write_png_compression_strategy = Z_FILTERED+1;\n\n      else if (LocaleCompare(value,\"2\") == 0)\n        mng_info->write_png_compression_strategy = Z_HUFFMAN_ONLY+1;\n\n      else if (LocaleCompare(value,\"3\") == 0)\n#ifdef Z_RLE  /* Z_RLE was added to zlib-1.2.0 */\n        mng_info->write_png_compression_strategy = Z_RLE+1;\n#else\n        mng_info->write_png_compression_strategy = Z_DEFAULT_STRATEGY+1;\n#endif\n\n      else if (LocaleCompare(value,\"4\") == 0)\n#ifdef Z_FIXED  /* Z_FIXED was added to zlib-1.2.2.2 */\n        mng_info->write_png_compression_strategy = Z_FIXED+1;\n#else\n        mng_info->write_png_compression_strategy = Z_DEFAULT_STRATEGY+1;\n#endif\n\n      else\n        (void) ThrowMagickException(exception,\n             GetMagickModule(),CoderWarning,\n             \"ignoring invalid defined png:compression-strategy\",\n             \"=%s\",value);\n    }\n\n  value=GetImageOption(image_info,\"png:compression-filter\");\n  if (value == NULL)\n     value=GetImageArtifact(image,\"png:compression-filter\");\n  if (value != NULL)\n  {\n      /* To do: combinations of filters allowed by libpng\n       * masks 0x08 through 0xf8\n       *\n       * Implement this as a comma-separated list of 0,1,2,3,4,5\n       * where 5 is a special case meaning PNG_ALL_FILTERS.\n       */\n\n      if (LocaleCompare(value,\"0\") == 0)\n        mng_info->write_png_compression_filter = 1;\n\n      else if (LocaleCompare(value,\"1\") == 0)\n        mng_info->write_png_compression_filter = 2;\n\n      else if (LocaleCompare(value,\"2\") == 0)\n        mng_info->write_png_compression_filter = 3;\n\n      else if (LocaleCompare(value,\"3\") == 0)\n        mng_info->write_png_compression_filter = 4;\n\n      else if (LocaleCompare(value,\"4\") == 0)\n        mng_info->write_png_compression_filter = 5;\n\n      else if (LocaleCompare(value,\"5\") == 0)\n        mng_info->write_png_compression_filter = 6;\n\n      else\n        (void) ThrowMagickException(exception,\n             GetMagickModule(),CoderWarning,\n             \"ignoring invalid defined png:compression-filter\",\n             \"=%s\",value);\n  }\n\n  for (source=0; source<8; source++)\n  {\n    value = NULL;\n\n    if (source == 0)\n      value=GetImageOption(image_info,\"png:exclude-chunks\");\n\n    if (source == 1)\n      value=GetImageArtifact(image,\"png:exclude-chunks\");\n\n    if (source == 2)\n      value=GetImageOption(image_info,\"png:exclude-chunk\");\n\n    if (source == 3)\n      value=GetImageArtifact(image,\"png:exclude-chunk\");\n\n    if (source == 4)\n      value=GetImageOption(image_info,\"png:include-chunks\");\n\n    if (source == 5)\n      value=GetImageArtifact(image,\"png:include-chunks\");\n\n    if (source == 6)\n      value=GetImageOption(image_info,\"png:include-chunk\");\n\n    if (source == 7)\n      value=GetImageArtifact(image,\"png:include-chunk\");\n\n    if (value == NULL)\n       continue;\n\n    if (source < 4)\n      excluding = MagickTrue;\n    else\n      excluding = MagickFalse;\n\n    if (logging != MagickFalse)\n      {\n        if (source == 0 || source == 2)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  png:exclude-chunk=%s found in image options.\\n\", value);\n        else if (source == 1 || source == 3)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  png:exclude-chunk=%s found in image artifacts.\\n\", value);\n        else if (source == 4 || source == 6)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  png:include-chunk=%s found in image options.\\n\", value);\n        else /* if (source == 5 || source == 7) */\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  png:include-chunk=%s found in image artifacts.\\n\", value);\n      }\n\n    if (IsOptionMember(\"all\",value) != MagickFalse)\n      {\n        mng_info->ping_exclude_bKGD=excluding;\n        mng_info->ping_exclude_caNv=excluding;\n        mng_info->ping_exclude_cHRM=excluding;\n        mng_info->ping_exclude_date=excluding;\n        mng_info->ping_exclude_EXIF=excluding;\n        mng_info->ping_exclude_eXIf=excluding;\n        mng_info->ping_exclude_gAMA=excluding;\n        mng_info->ping_exclude_iCCP=excluding;\n        /* mng_info->ping_exclude_iTXt=excluding; */\n        mng_info->ping_exclude_oFFs=excluding;\n        mng_info->ping_exclude_pHYs=excluding;\n        mng_info->ping_exclude_sRGB=excluding;\n        mng_info->ping_exclude_tEXt=excluding;\n        mng_info->ping_exclude_tIME=excluding;\n        mng_info->ping_exclude_tRNS=excluding;\n        mng_info->ping_exclude_vpAg=excluding;\n        mng_info->ping_exclude_zCCP=excluding;\n        mng_info->ping_exclude_zTXt=excluding;\n      }\n\n    if (IsOptionMember(\"none\",value) != MagickFalse)\n      {\n        mng_info->ping_exclude_bKGD=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_caNv=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_cHRM=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_date=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_eXIf=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_EXIF=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_gAMA=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_iCCP=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        /* mng_info->ping_exclude_iTXt=!excluding; */\n        mng_info->ping_exclude_oFFs=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_pHYs=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_sRGB=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_tEXt=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_tIME=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_tRNS=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_vpAg=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_zCCP=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_zTXt=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n      }\n\n    if (IsOptionMember(\"bkgd\",value) != MagickFalse)\n      mng_info->ping_exclude_bKGD=excluding;\n\n    if (IsOptionMember(\"caNv\",value) != MagickFalse)\n      mng_info->ping_exclude_caNv=excluding;\n\n    if (IsOptionMember(\"chrm\",value) != MagickFalse)\n      mng_info->ping_exclude_cHRM=excluding;\n\n    if (IsOptionMember(\"date\",value) != MagickFalse)\n      mng_info->ping_exclude_date=excluding;\n\n    if (IsOptionMember(\"exif\",value) != MagickFalse)\n      {\n        mng_info->ping_exclude_EXIF=excluding;\n        mng_info->ping_exclude_eXIf=excluding;\n      }\n\n    if (IsOptionMember(\"gama\",value) != MagickFalse)\n      mng_info->ping_exclude_gAMA=excluding;\n\n    if (IsOptionMember(\"iccp\",value) != MagickFalse)\n      mng_info->ping_exclude_iCCP=excluding;\n\n#if 0\n    if (IsOptionMember(\"itxt\",value) != MagickFalse)\n      mng_info->ping_exclude_iTXt=excluding;\n#endif\n\n    if (IsOptionMember(\"offs\",value) != MagickFalse)\n      mng_info->ping_exclude_oFFs=excluding;\n\n    if (IsOptionMember(\"phys\",value) != MagickFalse)\n      mng_info->ping_exclude_pHYs=excluding;\n\n    if (IsOptionMember(\"srgb\",value) != MagickFalse)\n      mng_info->ping_exclude_sRGB=excluding;\n\n    if (IsOptionMember(\"text\",value) != MagickFalse)\n      mng_info->ping_exclude_tEXt=excluding;\n\n    if (IsOptionMember(\"time\",value) != MagickFalse)\n      mng_info->ping_exclude_tIME=excluding;\n\n    if (IsOptionMember(\"trns\",value) != MagickFalse)\n      mng_info->ping_exclude_tRNS=excluding;\n\n    if (IsOptionMember(\"vpag\",value) != MagickFalse)\n      mng_info->ping_exclude_vpAg=excluding;\n\n    if (IsOptionMember(\"zccp\",value) != MagickFalse)\n      mng_info->ping_exclude_zCCP=excluding;\n\n    if (IsOptionMember(\"ztxt\",value) != MagickFalse)\n      mng_info->ping_exclude_zTXt=excluding;\n  }\n\n  if (logging != MagickFalse)\n  {\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Chunks to be excluded from the output png:\");\n    if (mng_info->ping_exclude_bKGD != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    bKGD\");\n    if (mng_info->ping_exclude_caNv != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    caNv\");\n    if (mng_info->ping_exclude_cHRM != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    cHRM\");\n    if (mng_info->ping_exclude_date != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    date\");\n    if (mng_info->ping_exclude_EXIF != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    EXIF\");\n    if (mng_info->ping_exclude_eXIf != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    eXIf\");\n    if (mng_info->ping_exclude_gAMA != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    gAMA\");\n    if (mng_info->ping_exclude_iCCP != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    iCCP\");\n#if 0\n    if (mng_info->ping_exclude_iTXt != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    iTXt\");\n#endif\n\n    if (mng_info->ping_exclude_oFFs != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    oFFs\");\n    if (mng_info->ping_exclude_pHYs != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    pHYs\");\n    if (mng_info->ping_exclude_sRGB != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    sRGB\");\n    if (mng_info->ping_exclude_tEXt != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    tEXt\");\n    if (mng_info->ping_exclude_tIME != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    tIME\");\n    if (mng_info->ping_exclude_tRNS != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    tRNS\");\n    if (mng_info->ping_exclude_vpAg != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    vpAg\");\n    if (mng_info->ping_exclude_zCCP != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    zCCP\");\n    if (mng_info->ping_exclude_zTXt != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    zTXt\");\n  }\n\n  mng_info->need_blob = MagickTrue;\n\n  status=WriteOnePNGImage(mng_info,image_info,image,exception);\n\n  mng_info=MngInfoFreeStruct(mng_info);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"exit WritePNGImage()\");\n\n  return(status);\n}\n\n#if defined(JNG_SUPPORTED)\n\n/* Write one JNG image */\nstatic MagickBooleanType WriteOneJNGImage(MngInfo *mng_info,\n   const ImageInfo *image_info,Image *image,ExceptionInfo *exception)\n{\n  Image\n    *jpeg_image;\n\n  ImageInfo\n    *jpeg_image_info;\n\n  MagickBooleanType\n    logging,\n    status;\n\n  size_t\n    length;\n\n  unsigned char\n    *blob,\n    chunk[80],\n    *p;\n\n  unsigned int\n    jng_alpha_compression_method,\n    jng_alpha_sample_depth,\n    jng_color_type,\n    transparent;\n\n  size_t\n    jng_alpha_quality,\n    jng_quality;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter WriteOneJNGImage()\");\n\n  blob=(unsigned char *) NULL;\n  jpeg_image=(Image *) NULL;\n  jpeg_image_info=(ImageInfo *) NULL;\n  length=0;\n\n  status=MagickTrue;\n  transparent=image_info->type==GrayscaleAlphaType ||\n     image_info->type==TrueColorAlphaType ||\n     image->alpha_trait != UndefinedPixelTrait;\n\n  jng_alpha_sample_depth = 0;\n\n  jng_quality=image_info->quality == 0UL ? 75UL : image_info->quality%1000;\n\n  jng_alpha_compression_method=image->compression==JPEGCompression? 8 : 0;\n\n  jng_alpha_quality=image_info->quality == 0UL ? 75UL :\n      image_info->quality;\n\n  if (jng_alpha_quality >= 1000)\n    jng_alpha_quality /= 1000;\n\n  length=0;\n\n  if (transparent != 0)\n    {\n      jng_color_type=14;\n\n      /* Create JPEG blob, image, and image_info */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Creating jpeg_image_info for alpha.\");\n\n      jpeg_image_info=(ImageInfo *) CloneImageInfo(image_info);\n\n      if (jpeg_image_info == (ImageInfo *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Creating jpeg_image.\");\n\n      jpeg_image=SeparateImage(image,AlphaChannel,exception);\n      if (jpeg_image == (Image *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      (void) CopyMagickString(jpeg_image->magick,\"JPEG\",MagickPathExtent);\n      jpeg_image->alpha_trait=UndefinedPixelTrait;\n      jpeg_image->quality=jng_alpha_quality;\n      jpeg_image_info->type=GrayscaleType;\n      (void) SetImageType(jpeg_image,GrayscaleType,exception);\n      (void) AcquireUniqueFilename(jpeg_image->filename);\n      (void) FormatLocaleString(jpeg_image_info->filename,MagickPathExtent,\n        \"%s\",jpeg_image->filename);\n    }\n  else\n    {\n      jng_alpha_compression_method=0;\n      jng_color_type=10;\n      jng_alpha_sample_depth=0;\n    }\n\n  /* To do: check bit depth of PNG alpha channel */\n\n  /* Check if image is grayscale. */\n  if (image_info->type != TrueColorAlphaType && image_info->type !=\n    TrueColorType && SetImageGray(image,exception))\n    jng_color_type-=2;\n\n  if (logging != MagickFalse)\n    {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    JNG Quality           = %d\",(int) jng_quality);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    JNG Color Type        = %d\",jng_color_type);\n        if (transparent != 0)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    JNG Alpha Compression = %d\",jng_alpha_compression_method);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    JNG Alpha Depth       = %d\",jng_alpha_sample_depth);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    JNG Alpha Quality     = %d\",(int) jng_alpha_quality);\n          }\n    }\n\n  if (transparent != 0)\n    {\n      if (jng_alpha_compression_method==0)\n        {\n          const char\n            *value;\n\n          /* Encode alpha as a grayscale PNG blob */\n          status=OpenBlob(jpeg_image_info,jpeg_image,WriteBinaryBlobMode,\n            exception);\n          if (status == MagickFalse)\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Creating PNG blob.\");\n\n          (void) CopyMagickString(jpeg_image_info->magick,\"PNG\",\n             MagickPathExtent);\n          (void) CopyMagickString(jpeg_image->magick,\"PNG\",MagickPathExtent);\n          jpeg_image_info->interlace=NoInterlace;\n\n          /* Exclude all ancillary chunks */\n          (void) SetImageArtifact(jpeg_image,\"png:exclude-chunks\",\"all\");\n\n          blob=(unsigned char *) ImageToBlob(jpeg_image_info,jpeg_image,\n            &length,exception);\n\n          /* Retrieve sample depth used */\n          value=GetImageProperty(jpeg_image,\"png:bit-depth-written\",exception);\n          if (value != (char *) NULL)\n            jng_alpha_sample_depth= (unsigned int) value[0];\n        }\n      else\n        {\n          /* Encode alpha as a grayscale JPEG blob */\n\n          status=OpenBlob(jpeg_image_info,jpeg_image,WriteBinaryBlobMode,\n            exception);\n          if (status == MagickFalse)\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n          (void) CopyMagickString(jpeg_image_info->magick,\"JPEG\",\n            MagickPathExtent);\n          (void) CopyMagickString(jpeg_image->magick,\"JPEG\",MagickPathExtent);\n          jpeg_image_info->interlace=NoInterlace;\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Creating blob.\");\n          blob=(unsigned char *) ImageToBlob(jpeg_image_info,\n             jpeg_image,&length,\n           exception);\n          jng_alpha_sample_depth=8;\n\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Successfully read jpeg_image into a blob, length=%.20g.\",\n              (double) length);\n\n        }\n      /* Destroy JPEG image and image_info */\n      jpeg_image=DestroyImage(jpeg_image);\n      (void) RelinquishUniqueFileResource(jpeg_image_info->filename);\n      jpeg_image_info=DestroyImageInfo(jpeg_image_info);\n    }\n\n  /* Write JHDR chunk */\n  (void) WriteBlobMSBULong(image,16L);  /* chunk data length=16 */\n  PNGType(chunk,mng_JHDR);\n  LogPNGChunk(logging,mng_JHDR,16L);\n  PNGLong(chunk+4,(png_uint_32) image->columns);\n  PNGLong(chunk+8,(png_uint_32) image->rows);\n  chunk[12]=jng_color_type;\n  chunk[13]=8;  /* sample depth */\n  chunk[14]=8; /*jng_image_compression_method */\n  chunk[15]=(unsigned char) (image_info->interlace == NoInterlace ? 0 : 8);\n  chunk[16]=jng_alpha_sample_depth;\n  chunk[17]=jng_alpha_compression_method;\n  chunk[18]=0; /*jng_alpha_filter_method */\n  chunk[19]=0; /*jng_alpha_interlace_method */\n  (void) WriteBlob(image,20,chunk);\n  (void) WriteBlobMSBULong(image,crc32(0,chunk,20));\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG width:%15lu\",(unsigned long) image->columns);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG height:%14lu\",(unsigned long) image->rows);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG color type:%10d\",jng_color_type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG sample depth:%8d\",8);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG compression:%9d\",8);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG interlace:%11d\",0);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG alpha depth:%9d\",jng_alpha_sample_depth);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG alpha compression:%3d\",jng_alpha_compression_method);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG alpha filter:%8d\",0);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG alpha interlace:%5d\",0);\n    }\n\n  /* Write any JNG-chunk-b profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"JNG-chunk-b\",logging);\n\n  /*\n     Write leading ancillary chunks\n  */\n\n  if (transparent != 0)\n  {\n    /*\n      Write JNG bKGD chunk\n    */\n\n    unsigned char\n      blue,\n      green,\n      red;\n\n    ssize_t\n      num_bytes;\n\n    if (jng_color_type == 8 || jng_color_type == 12)\n      num_bytes=6L;\n    else\n      num_bytes=10L;\n    (void) WriteBlobMSBULong(image,(size_t) (num_bytes-4L));\n    PNGType(chunk,mng_bKGD);\n    LogPNGChunk(logging,mng_bKGD,(size_t) (num_bytes-4L));\n    red=ScaleQuantumToChar(image->background_color.red);\n    green=ScaleQuantumToChar(image->background_color.green);\n    blue=ScaleQuantumToChar(image->background_color.blue);\n    *(chunk+4)=0;\n    *(chunk+5)=red;\n    *(chunk+6)=0;\n    *(chunk+7)=green;\n    *(chunk+8)=0;\n    *(chunk+9)=blue;\n    (void) WriteBlob(image,(size_t) num_bytes,chunk);\n    (void) WriteBlobMSBULong(image,crc32(0,chunk,(uInt) num_bytes));\n  }\n\n  if ((image->colorspace == sRGBColorspace || image->rendering_intent))\n    {\n      /*\n        Write JNG sRGB chunk\n      */\n      (void) WriteBlobMSBULong(image,1L);\n      PNGType(chunk,mng_sRGB);\n      LogPNGChunk(logging,mng_sRGB,1L);\n\n      if (image->rendering_intent != UndefinedIntent)\n        chunk[4]=(unsigned char)\n          Magick_RenderingIntent_to_PNG_RenderingIntent(\n          (image->rendering_intent));\n\n      else\n        chunk[4]=(unsigned char)\n          Magick_RenderingIntent_to_PNG_RenderingIntent(\n          (PerceptualIntent));\n\n      (void) WriteBlob(image,5,chunk);\n      (void) WriteBlobMSBULong(image,crc32(0,chunk,5));\n    }\n  else\n    {\n      if (image->gamma != 0.0)\n        {\n          /*\n             Write JNG gAMA chunk\n          */\n          (void) WriteBlobMSBULong(image,4L);\n          PNGType(chunk,mng_gAMA);\n          LogPNGChunk(logging,mng_gAMA,4L);\n          PNGLong(chunk+4,(png_uint_32) (100000*image->gamma+0.5));\n          (void) WriteBlob(image,8,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,8));\n        }\n\n      if ((mng_info->equal_chrms == MagickFalse) &&\n          (image->chromaticity.red_primary.x != 0.0))\n        {\n          PrimaryInfo\n            primary;\n\n          /*\n             Write JNG cHRM chunk\n          */\n          (void) WriteBlobMSBULong(image,32L);\n          PNGType(chunk,mng_cHRM);\n          LogPNGChunk(logging,mng_cHRM,32L);\n          primary=image->chromaticity.white_point;\n          PNGLong(chunk+4,(png_uint_32) (100000*primary.x+0.5));\n          PNGLong(chunk+8,(png_uint_32) (100000*primary.y+0.5));\n          primary=image->chromaticity.red_primary;\n          PNGLong(chunk+12,(png_uint_32) (100000*primary.x+0.5));\n          PNGLong(chunk+16,(png_uint_32) (100000*primary.y+0.5));\n          primary=image->chromaticity.green_primary;\n          PNGLong(chunk+20,(png_uint_32) (100000*primary.x+0.5));\n          PNGLong(chunk+24,(png_uint_32) (100000*primary.y+0.5));\n          primary=image->chromaticity.blue_primary;\n          PNGLong(chunk+28,(png_uint_32) (100000*primary.x+0.5));\n          PNGLong(chunk+32,(png_uint_32) (100000*primary.y+0.5));\n          (void) WriteBlob(image,36,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,36));\n        }\n    }\n\n  if (image->resolution.x && image->resolution.y && !mng_info->equal_physs)\n    {\n      /*\n         Write JNG pHYs chunk\n      */\n      (void) WriteBlobMSBULong(image,9L);\n      PNGType(chunk,mng_pHYs);\n      LogPNGChunk(logging,mng_pHYs,9L);\n      if (image->units == PixelsPerInchResolution)\n        {\n          PNGLong(chunk+4,(png_uint_32)\n            (image->resolution.x*100.0/2.54+0.5));\n\n          PNGLong(chunk+8,(png_uint_32)\n            (image->resolution.y*100.0/2.54+0.5));\n\n          chunk[12]=1;\n        }\n\n      else\n        {\n          if (image->units == PixelsPerCentimeterResolution)\n            {\n              PNGLong(chunk+4,(png_uint_32)\n                (image->resolution.x*100.0+0.5));\n\n              PNGLong(chunk+8,(png_uint_32)\n                (image->resolution.y*100.0+0.5));\n\n              chunk[12]=1;\n            }\n\n          else\n            {\n              PNGLong(chunk+4,(png_uint_32) (image->resolution.x+0.5));\n              PNGLong(chunk+8,(png_uint_32) (image->resolution.y+0.5));\n              chunk[12]=0;\n            }\n        }\n      (void) WriteBlob(image,13,chunk);\n      (void) WriteBlobMSBULong(image,crc32(0,chunk,13));\n    }\n\n  if (mng_info->write_mng == 0 && (image->page.x || image->page.y))\n    {\n      /*\n         Write JNG oFFs chunk\n      */\n      (void) WriteBlobMSBULong(image,9L);\n      PNGType(chunk,mng_oFFs);\n      LogPNGChunk(logging,mng_oFFs,9L);\n      PNGsLong(chunk+4,(ssize_t) (image->page.x));\n      PNGsLong(chunk+8,(ssize_t) (image->page.y));\n      chunk[12]=0;\n      (void) WriteBlob(image,13,chunk);\n      (void) WriteBlobMSBULong(image,crc32(0,chunk,13));\n    }\n  if (mng_info->write_mng == 0 && (image->page.width || image->page.height))\n    {\n       (void) WriteBlobMSBULong(image,9L);  /* data length=8 */\n       PNGType(chunk,mng_vpAg);\n       LogPNGChunk(logging,mng_vpAg,9L);\n       PNGLong(chunk+4,(png_uint_32) image->page.width);\n       PNGLong(chunk+8,(png_uint_32) image->page.height);\n       chunk[12]=0;   /* unit = pixels */\n       (void) WriteBlob(image,13,chunk);\n       (void) WriteBlobMSBULong(image,crc32(0,chunk,13));\n    }\n\n  if (transparent != 0)\n    {\n      if (jng_alpha_compression_method==0)\n        {\n          register ssize_t\n            i;\n\n          size_t\n            len;\n\n          /* Write IDAT chunk header */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Write IDAT chunks from blob, length=%.20g.\",(double)\n              length);\n\n          /* Copy IDAT chunks */\n          len=0;\n          p=blob+8;\n          for (i=8; i<(ssize_t) length; i+=len+12)\n          {\n            len=(((unsigned int) *(p    ) & 0xff) << 24) +\n                (((unsigned int) *(p + 1) & 0xff) << 16) +\n                (((unsigned int) *(p + 2) & 0xff) <<  8) +\n                (((unsigned int) *(p + 3) & 0xff)      ) ;\n            p+=4;\n\n            if (*(p)==73 && *(p+1)==68 && *(p+2)==65 && *(p+3)==84) /* IDAT */\n              {\n                /* Found an IDAT chunk. */\n                (void) WriteBlobMSBULong(image,len);\n                LogPNGChunk(logging,mng_IDAT,len);\n                (void) WriteBlob(image,len+4,p);\n                (void) WriteBlobMSBULong(image, crc32(0,p,(uInt) len+4));\n              }\n\n            else\n              {\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Skipping %c%c%c%c chunk, length=%.20g.\",\n                    *(p),*(p+1),*(p+2),*(p+3),(double) len);\n              }\n            p+=(8+len);\n          }\n        }\n      else if (length != 0)\n        {\n          /* Write JDAA chunk header */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Write JDAA chunk, length=%.20g.\",(double) length);\n          (void) WriteBlobMSBULong(image,(size_t) length);\n          PNGType(chunk,mng_JDAA);\n          LogPNGChunk(logging,mng_JDAA,length);\n          /* Write JDAT chunk(s) data */\n          (void) WriteBlob(image,4,chunk);\n          (void) WriteBlob(image,length,blob);\n          (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),blob,\n             (uInt) length));\n        }\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n    }\n\n  /* Encode image as a JPEG blob */\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Creating jpeg_image_info.\");\n  jpeg_image_info=(ImageInfo *) CloneImageInfo(image_info);\n  if (jpeg_image_info == (ImageInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Creating jpeg_image.\");\n\n  jpeg_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (jpeg_image == (Image *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) CopyMagickString(jpeg_image->magick,\"JPEG\",MagickPathExtent);\n\n  (void) AcquireUniqueFilename(jpeg_image->filename);\n  (void) FormatLocaleString(jpeg_image_info->filename,MagickPathExtent,\"%s\",\n    jpeg_image->filename);\n\n  status=OpenBlob(jpeg_image_info,jpeg_image,WriteBinaryBlobMode,\n    exception);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Created jpeg_image, %.20g x %.20g.\",(double) jpeg_image->columns,\n      (double) jpeg_image->rows);\n\n  if (status == MagickFalse)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  if (jng_color_type == 8 || jng_color_type == 12)\n    jpeg_image_info->type=GrayscaleType;\n\n  jpeg_image_info->quality=jng_quality;\n  jpeg_image->quality=jng_quality;\n  (void) CopyMagickString(jpeg_image_info->magick,\"JPEG\",MagickPathExtent);\n  (void) CopyMagickString(jpeg_image->magick,\"JPEG\",MagickPathExtent);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Creating blob.\");\n\n  blob=(unsigned char *) ImageToBlob(jpeg_image_info,jpeg_image,&length,\n    exception);\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Successfully read jpeg_image into a blob, length=%.20g.\",\n        (double) length);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Write JDAT chunk, length=%.20g.\",(double) length);\n    }\n\n  /* Write JDAT chunk(s) */\n  (void) WriteBlobMSBULong(image,(size_t) length);\n  PNGType(chunk,mng_JDAT);\n  LogPNGChunk(logging,mng_JDAT,length);\n  (void) WriteBlob(image,4,chunk);\n  (void) WriteBlob(image,length,blob);\n  (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),blob,(uInt) length));\n\n  jpeg_image=DestroyImage(jpeg_image);\n  (void) RelinquishUniqueFileResource(jpeg_image_info->filename);\n  jpeg_image_info=DestroyImageInfo(jpeg_image_info);\n  blob=(unsigned char *) RelinquishMagickMemory(blob);\n\n  /* Write any JNG-chunk-e profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"JNG-chunk-e\",logging);\n\n  /* Write IEND chunk */\n  (void) WriteBlobMSBULong(image,0L);\n  PNGType(chunk,mng_IEND);\n  LogPNGChunk(logging,mng_IEND,0);\n  (void) WriteBlob(image,4,chunk);\n  (void) WriteBlobMSBULong(image,crc32(0,chunk,4));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit WriteOneJNGImage()\");\n\n  return(status);\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e J N G I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteJNGImage() writes a JPEG Network Graphics (JNG) image file.\n%\n%  JNG support written by Glenn Randers-Pehrson, glennrp@image...\n%\n%  The format of the WriteJNGImage method is:\n%\n%      MagickBooleanType WriteJNGImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\nstatic MagickBooleanType WriteJNGImage(const ImageInfo *image_info,\n  Image *image, ExceptionInfo *exception)\n{\n  MagickBooleanType\n    logging,\n    status;\n\n  MngInfo\n    *mng_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\"Enter WriteJNGImage()\");\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if ((image->columns > 65535UL) || (image->rows > 65535UL))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n\n  /*\n    Allocate a MngInfo structure.\n  */\n  mng_info=(MngInfo *) AcquireMagickMemory(sizeof(MngInfo));\n  if (mng_info == (MngInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Initialize members of the MngInfo structure.\n  */\n  (void) ResetMagickMemory(mng_info,0,sizeof(MngInfo));\n  mng_info->image=image;\n\n  (void) WriteBlob(image,8,(const unsigned char *) \"\\213JNG\\r\\n\\032\\n\");\n\n  status=WriteOneJNGImage(mng_info,image_info,image,exception);\n  mng_info=MngInfoFreeStruct(mng_info);\n  (void) CloseBlob(image);\n\n  (void) CatchImageException(image);\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"exit WriteJNGImage()\");\n  return(status);\n}\n#endif\n\nstatic MagickBooleanType WriteMNGImage(const ImageInfo *image_info,\n  Image *image, ExceptionInfo *exception)\n{\n  Image\n    *next_image;\n\n  MagickBooleanType\n    status;\n\n  volatile MagickBooleanType\n    logging;\n\n  MngInfo\n    *mng_info;\n\n  int\n    image_count,\n    need_iterations,\n    need_matte;\n\n  volatile int\n#if defined(PNG_WRITE_EMPTY_PLTE_SUPPORTED) || \\\n    defined(PNG_MNG_FEATURES_SUPPORTED)\n    need_local_plte,\n#endif\n    all_images_are_gray,\n    need_defi,\n    use_global_plte;\n\n  register ssize_t\n    i;\n\n  unsigned char\n    chunk[800];\n\n  volatile unsigned int\n    write_jng,\n    write_mng;\n\n  volatile size_t\n    scene;\n\n  size_t\n    final_delay=0,\n    initial_delay;\n\n#if (PNG_LIBPNG_VER < 10200)\n    if (image_info->verbose)\n      printf(\"Your PNG library (libpng-%s) is rather old.\\n\",\n         PNG_LIBPNG_VER_STRING);\n#endif\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\"Enter WriteMNGImage()\");\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n\n  /*\n    Allocate a MngInfo structure.\n  */\n  mng_info=(MngInfo *) AcquireMagickMemory(sizeof(MngInfo));\n  if (mng_info == (MngInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Initialize members of the MngInfo structure.\n  */\n  (void) ResetMagickMemory(mng_info,0,sizeof(MngInfo));\n  mng_info->image=image;\n  write_mng=LocaleCompare(image_info->magick,\"MNG\") == 0;\n\n  /*\n   * See if user has requested a specific PNG subformat to be used\n   * for all of the PNGs in the MNG being written, e.g.,\n   *\n   *    convert *.png png8:animation.mng\n   *\n   * To do: check -define png:bit_depth and png:color_type as well,\n   * or perhaps use mng:bit_depth and mng:color_type instead for\n   * global settings.\n   */\n\n  mng_info->write_png8=LocaleCompare(image_info->magick,\"PNG8\") == 0;\n  mng_info->write_png24=LocaleCompare(image_info->magick,\"PNG24\") == 0;\n  mng_info->write_png32=LocaleCompare(image_info->magick,\"PNG32\") == 0;\n\n  write_jng=MagickFalse;\n  if (image_info->compression == JPEGCompression)\n    write_jng=MagickTrue;\n\n  mng_info->adjoin=image_info->adjoin &&\n    (GetNextImageInList(image) != (Image *) NULL) && write_mng;\n\n  if (logging != MagickFalse)\n    {\n      /* Log some info about the input */\n      Image\n        *p;\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Checking input image(s)\\n\"\n        \"    Image_info depth: %.20g,    Type: %d\",\n        (double) image_info->depth, image_info->type);\n\n      scene=0;\n      for (p=image; p != (Image *) NULL; p=GetNextImageInList(p))\n      {\n\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"    Scene: %.20g\\n,   Image depth: %.20g\",\n           (double) scene++, (double) p->depth);\n\n        if (p->alpha_trait != UndefinedPixelTrait)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      Matte: True\");\n\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      Matte: False\");\n\n        if (p->storage_class == PseudoClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      Storage class: PseudoClass\");\n\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      Storage class: DirectClass\");\n\n        if (p->colors)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      Number of colors: %.20g\",(double) p->colors);\n\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      Number of colors: unspecified\");\n\n        if (mng_info->adjoin == MagickFalse)\n          break;\n      }\n    }\n\n  use_global_plte=MagickFalse;\n  all_images_are_gray=MagickFalse;\n#ifdef PNG_WRITE_EMPTY_PLTE_SUPPORTED\n  need_local_plte=MagickTrue;\n#endif\n  need_defi=MagickFalse;\n  need_matte=MagickFalse;\n  mng_info->framing_mode=1;\n  mng_info->old_framing_mode=1;\n\n  if (write_mng)\n      if (image_info->page != (char *) NULL)\n        {\n          /*\n            Determine image bounding box.\n          */\n          SetGeometry(image,&mng_info->page);\n          (void) ParseMetaGeometry(image_info->page,&mng_info->page.x,\n            &mng_info->page.y,&mng_info->page.width,&mng_info->page.height);\n        }\n  if (write_mng)\n    {\n      unsigned int\n        need_geom;\n\n      unsigned short\n        red,\n        green,\n        blue;\n\n      const char *\n        option;\n\n      mng_info->page=image->page;\n      need_geom=MagickTrue;\n      if (mng_info->page.width || mng_info->page.height)\n         need_geom=MagickFalse;\n      /*\n        Check all the scenes.\n      */\n      initial_delay=image->delay;\n      need_iterations=MagickFalse;\n      mng_info->equal_chrms=image->chromaticity.red_primary.x != 0.0;\n      mng_info->equal_physs=MagickTrue,\n      mng_info->equal_gammas=MagickTrue;\n      mng_info->equal_srgbs=MagickTrue;\n      mng_info->equal_backgrounds=MagickTrue;\n      image_count=0;\n#if defined(PNG_WRITE_EMPTY_PLTE_SUPPORTED) || \\\n    defined(PNG_MNG_FEATURES_SUPPORTED)\n      all_images_are_gray=MagickTrue;\n      mng_info->equal_palettes=MagickFalse;\n      need_local_plte=MagickFalse;\n#endif\n      for (next_image=image; next_image != (Image *) NULL; )\n      {\n        if (need_geom)\n          {\n            if ((next_image->columns+next_image->page.x) > mng_info->page.width)\n              mng_info->page.width=next_image->columns+next_image->page.x;\n\n            if ((next_image->rows+next_image->page.y) > mng_info->page.height)\n              mng_info->page.height=next_image->rows+next_image->page.y;\n          }\n\n        if (next_image->page.x || next_image->page.y)\n          need_defi=MagickTrue;\n\n        if (next_image->alpha_trait != UndefinedPixelTrait)\n          need_matte=MagickTrue;\n\n        if ((int) next_image->dispose >= BackgroundDispose)\n          if ((next_image->alpha_trait != UndefinedPixelTrait) ||\n               next_image->page.x || next_image->page.y ||\n              ((next_image->columns < mng_info->page.width) &&\n               (next_image->rows < mng_info->page.height)))\n            mng_info->need_fram=MagickTrue;\n\n        if (next_image->iterations)\n          need_iterations=MagickTrue;\n\n        final_delay=next_image->delay;\n\n        if (final_delay != initial_delay || final_delay > 1UL*\n           next_image->ticks_per_second)\n          mng_info->need_fram=1;\n\n#if defined(PNG_WRITE_EMPTY_PLTE_SUPPORTED) || \\\n    defined(PNG_MNG_FEATURES_SUPPORTED)\n        /*\n          check for global palette possibility.\n        */\n        if (image->alpha_trait != UndefinedPixelTrait)\n           need_local_plte=MagickTrue;\n\n        if (need_local_plte == 0)\n          {\n            if (SetImageGray(image,exception) == MagickFalse)\n              all_images_are_gray=MagickFalse;\n            mng_info->equal_palettes=PalettesAreEqual(image,next_image);\n            if (use_global_plte == 0)\n              use_global_plte=mng_info->equal_palettes;\n            need_local_plte=!mng_info->equal_palettes;\n          }\n#endif\n        if (GetNextImageInList(next_image) != (Image *) NULL)\n          {\n            if (next_image->background_color.red !=\n                next_image->next->background_color.red ||\n                next_image->background_color.green !=\n                next_image->next->background_color.green ||\n                next_image->background_color.blue !=\n                next_image->next->background_color.blue)\n              mng_info->equal_backgrounds=MagickFalse;\n\n            if (next_image->gamma != next_image->next->gamma)\n              mng_info->equal_gammas=MagickFalse;\n\n            if (next_image->rendering_intent !=\n                next_image->next->rendering_intent)\n              mng_info->equal_srgbs=MagickFalse;\n\n            if ((next_image->units != next_image->next->units) ||\n                (next_image->resolution.x != next_image->next->resolution.x) ||\n                (next_image->resolution.y != next_image->next->resolution.y))\n              mng_info->equal_physs=MagickFalse;\n\n            if (mng_info->equal_chrms)\n              {\n                if (next_image->chromaticity.red_primary.x !=\n                    next_image->next->chromaticity.red_primary.x ||\n                    next_image->chromaticity.red_primary.y !=\n                    next_image->next->chromaticity.red_primary.y ||\n                    next_image->chromaticity.green_primary.x !=\n                    next_image->next->chromaticity.green_primary.x ||\n                    next_image->chromaticity.green_primary.y !=\n                    next_image->next->chromaticity.green_primary.y ||\n                    next_image->chromaticity.blue_primary.x !=\n                    next_image->next->chromaticity.blue_primary.x ||\n                    next_image->chromaticity.blue_primary.y !=\n                    next_image->next->chromaticity.blue_primary.y ||\n                    next_image->chromaticity.white_point.x !=\n                    next_image->next->chromaticity.white_point.x ||\n                    next_image->chromaticity.white_point.y !=\n                    next_image->next->chromaticity.white_point.y)\n                  mng_info->equal_chrms=MagickFalse;\n              }\n          }\n        image_count++;\n        next_image=GetNextImageInList(next_image);\n      }\n      if (image_count < 2)\n        {\n          mng_info->equal_backgrounds=MagickFalse;\n          mng_info->equal_chrms=MagickFalse;\n          mng_info->equal_gammas=MagickFalse;\n          mng_info->equal_srgbs=MagickFalse;\n          mng_info->equal_physs=MagickFalse;\n          use_global_plte=MagickFalse;\n#ifdef PNG_WRITE_EMPTY_PLTE_SUPPORTED\n          need_local_plte=MagickTrue;\n#endif\n          need_iterations=MagickFalse;\n        }\n\n     if (mng_info->need_fram == MagickFalse)\n       {\n         /*\n           Only certain framing rates 100/n are exactly representable without\n           the FRAM chunk but we'll allow some slop in VLC files\n         */\n         if (final_delay == 0)\n           {\n             if (need_iterations != MagickFalse)\n               {\n                 /*\n                   It's probably a GIF with loop; don't run it *too* fast.\n                 */\n                 if (mng_info->adjoin)\n                   {\n                     final_delay=10;\n                     (void) ThrowMagickException(exception,GetMagickModule(),\n                       CoderWarning,\n                       \"input has zero delay between all frames; assuming\",\n                       \" 10 cs `%s'\",\"\");\n                   }\n               }\n             else\n               mng_info->ticks_per_second=0;\n           }\n         if (final_delay != 0)\n           mng_info->ticks_per_second=(png_uint_32)\n              (image->ticks_per_second/final_delay);\n         if (final_delay > 50)\n           mng_info->ticks_per_second=2;\n\n         if (final_delay > 75)\n           mng_info->ticks_per_second=1;\n\n         if (final_delay > 125)\n           mng_info->need_fram=MagickTrue;\n\n         if (need_defi && final_delay > 2 && (final_delay != 4) &&\n            (final_delay != 5) && (final_delay != 10) && (final_delay != 20) &&\n            (final_delay != 25) && (final_delay != 50) &&\n            (final_delay != (size_t) image->ticks_per_second))\n           mng_info->need_fram=MagickTrue;  /* make it exact; cannot be VLC */\n       }\n\n     if (mng_info->need_fram != MagickFalse)\n        mng_info->ticks_per_second=image->ticks_per_second;\n     /*\n        If pseudocolor, we should also check to see if all the\n        palettes are identical and write a global PLTE if they are.\n        ../glennrp Feb 99.\n     */\n     /*\n        Write the MNG version 1.0 signature and MHDR chunk.\n     */\n     (void) WriteBlob(image,8,(const unsigned char *) \"\\212MNG\\r\\n\\032\\n\");\n     (void) WriteBlobMSBULong(image,28L);  /* chunk data length=28 */\n     PNGType(chunk,mng_MHDR);\n     LogPNGChunk(logging,mng_MHDR,28L);\n     PNGLong(chunk+4,(png_uint_32) mng_info->page.width);\n     PNGLong(chunk+8,(png_uint_32) mng_info->page.height);\n     PNGLong(chunk+12,mng_info->ticks_per_second);\n     PNGLong(chunk+16,0L);  /* layer count=unknown */\n     PNGLong(chunk+20,0L);  /* frame count=unknown */\n     PNGLong(chunk+24,0L);  /* play time=unknown   */\n     if (write_jng)\n       {\n         if (need_matte)\n           {\n             if (need_defi || mng_info->need_fram || use_global_plte)\n               PNGLong(chunk+28,27L);    /* simplicity=LC+JNG */\n\n             else\n               PNGLong(chunk+28,25L);    /* simplicity=VLC+JNG */\n           }\n\n         else\n           {\n             if (need_defi || mng_info->need_fram || use_global_plte)\n               PNGLong(chunk+28,19L);  /* simplicity=LC+JNG, no transparency */\n\n             else\n               PNGLong(chunk+28,17L);  /* simplicity=VLC+JNG, no transparency */\n           }\n       }\n\n     else\n       {\n         if (need_matte)\n           {\n             if (need_defi || mng_info->need_fram || use_global_plte)\n               PNGLong(chunk+28,11L);    /* simplicity=LC */\n\n             else\n               PNGLong(chunk+28,9L);    /* simplicity=VLC */\n           }\n\n         else\n           {\n             if (need_defi || mng_info->need_fram || use_global_plte)\n               PNGLong(chunk+28,3L);    /* simplicity=LC, no transparency */\n\n             else\n               PNGLong(chunk+28,1L);    /* simplicity=VLC, no transparency */\n           }\n       }\n     (void) WriteBlob(image,32,chunk);\n     (void) WriteBlobMSBULong(image,crc32(0,chunk,32));\n     option=GetImageOption(image_info,\"mng:need-cacheoff\");\n     if (option != (const char *) NULL)\n       {\n         size_t\n           length;\n         /*\n           Write \"nEED CACHEOFF\" to turn playback caching off for streaming MNG.\n         */\n         PNGType(chunk,mng_nEED);\n         length=CopyMagickString((char *) chunk+4,\"CACHEOFF\",20);\n         (void) WriteBlobMSBULong(image,(size_t) length);\n         LogPNGChunk(logging,mng_nEED,(size_t) length);\n         length+=4;\n         (void) WriteBlob(image,length,chunk);\n         (void) WriteBlobMSBULong(image,crc32(0,chunk,(uInt) length));\n       }\n     if ((GetPreviousImageInList(image) == (Image *) NULL) &&\n         (GetNextImageInList(image) != (Image *) NULL) &&\n         (image->iterations != 1))\n       {\n         /*\n           Write MNG TERM chunk\n         */\n         (void) WriteBlobMSBULong(image,10L);  /* data length=10 */\n         PNGType(chunk,mng_TERM);\n         LogPNGChunk(logging,mng_TERM,10L);\n         chunk[4]=3;  /* repeat animation */\n         chunk[5]=0;  /* show last frame when done */\n         PNGLong(chunk+6,(png_uint_32) (mng_info->ticks_per_second*\n            final_delay/MagickMax(image->ticks_per_second,1)));\n\n         if (image->iterations == 0)\n           PNGLong(chunk+10,PNG_UINT_31_MAX);\n\n         else\n           PNGLong(chunk+10,(png_uint_32) image->iterations);\n\n         if (logging != MagickFalse)\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"     TERM delay: %.20g\",(double) (mng_info->ticks_per_second*\n              final_delay/MagickMax(image->ticks_per_second,1)));\n\n             if (image->iterations == 0)\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"     TERM iterations: %.20g\",(double) PNG_UINT_31_MAX);\n\n             else\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"     Image iterations: %.20g\",(double) image->iterations);\n           }\n         (void) WriteBlob(image,14,chunk);\n         (void) WriteBlobMSBULong(image,crc32(0,chunk,14));\n       }\n     /*\n       To do: check for cHRM+gAMA == sRGB, and write sRGB instead.\n     */\n     if ((image->colorspace == sRGBColorspace || image->rendering_intent) &&\n          mng_info->equal_srgbs)\n       {\n         /*\n           Write MNG sRGB chunk\n         */\n         (void) WriteBlobMSBULong(image,1L);\n         PNGType(chunk,mng_sRGB);\n         LogPNGChunk(logging,mng_sRGB,1L);\n\n         if (image->rendering_intent != UndefinedIntent)\n           chunk[4]=(unsigned char)\n             Magick_RenderingIntent_to_PNG_RenderingIntent(\n             (image->rendering_intent));\n\n         else\n           chunk[4]=(unsigned char)\n             Magick_RenderingIntent_to_PNG_RenderingIntent(\n               (PerceptualIntent));\n\n         (void) WriteBlob(image,5,chunk);\n         (void) WriteBlobMSBULong(image,crc32(0,chunk,5));\n         mng_info->have_write_global_srgb=MagickTrue;\n       }\n\n     else\n       {\n         if (image->gamma && mng_info->equal_gammas)\n           {\n             /*\n                Write MNG gAMA chunk\n             */\n             (void) WriteBlobMSBULong(image,4L);\n             PNGType(chunk,mng_gAMA);\n             LogPNGChunk(logging,mng_gAMA,4L);\n             PNGLong(chunk+4,(png_uint_32) (100000*image->gamma+0.5));\n             (void) WriteBlob(image,8,chunk);\n             (void) WriteBlobMSBULong(image,crc32(0,chunk,8));\n             mng_info->have_write_global_gama=MagickTrue;\n           }\n         if (mng_info->equal_chrms)\n           {\n             PrimaryInfo\n               primary;\n\n             /*\n                Write MNG cHRM chunk\n             */\n             (void) WriteBlobMSBULong(image,32L);\n             PNGType(chunk,mng_cHRM);\n             LogPNGChunk(logging,mng_cHRM,32L);\n             primary=image->chromaticity.white_point;\n             PNGLong(chunk+4,(png_uint_32) (100000*primary.x+0.5));\n             PNGLong(chunk+8,(png_uint_32) (100000*primary.y+0.5));\n             primary=image->chromaticity.red_primary;\n             PNGLong(chunk+12,(png_uint_32) (100000*primary.x+0.5));\n             PNGLong(chunk+16,(png_uint_32) (100000*primary.y+0.5));\n             primary=image->chromaticity.green_primary;\n             PNGLong(chunk+20,(png_uint_32) (100000*primary.x+0.5));\n             PNGLong(chunk+24,(png_uint_32) (100000*primary.y+0.5));\n             primary=image->chromaticity.blue_primary;\n             PNGLong(chunk+28,(png_uint_32) (100000*primary.x+0.5));\n             PNGLong(chunk+32,(png_uint_32) (100000*primary.y+0.5));\n             (void) WriteBlob(image,36,chunk);\n             (void) WriteBlobMSBULong(image,crc32(0,chunk,36));\n             mng_info->have_write_global_chrm=MagickTrue;\n           }\n       }\n     if (image->resolution.x && image->resolution.y && mng_info->equal_physs)\n       {\n         /*\n            Write MNG pHYs chunk\n         */\n         (void) WriteBlobMSBULong(image,9L);\n         PNGType(chunk,mng_pHYs);\n         LogPNGChunk(logging,mng_pHYs,9L);\n\n         if (image->units == PixelsPerInchResolution)\n           {\n             PNGLong(chunk+4,(png_uint_32)\n               (image->resolution.x*100.0/2.54+0.5));\n\n             PNGLong(chunk+8,(png_uint_32)\n               (image->resolution.y*100.0/2.54+0.5));\n\n             chunk[12]=1;\n           }\n\n         else\n           {\n             if (image->units == PixelsPerCentimeterResolution)\n               {\n                 PNGLong(chunk+4,(png_uint_32)\n                   (image->resolution.x*100.0+0.5));\n\n                 PNGLong(chunk+8,(png_uint_32)\n                   (image->resolution.y*100.0+0.5));\n\n                 chunk[12]=1;\n               }\n\n             else\n               {\n                 PNGLong(chunk+4,(png_uint_32) (image->resolution.x+0.5));\n                 PNGLong(chunk+8,(png_uint_32) (image->resolution.y+0.5));\n                 chunk[12]=0;\n               }\n           }\n         (void) WriteBlob(image,13,chunk);\n         (void) WriteBlobMSBULong(image,crc32(0,chunk,13));\n       }\n     /*\n       Write MNG BACK chunk and global bKGD chunk, if the image is transparent\n       or does not cover the entire frame.\n     */\n     if (write_mng && ((image->alpha_trait != UndefinedPixelTrait) ||\n         image->page.x > 0 || image->page.y > 0 || (image->page.width &&\n         (image->page.width+image->page.x < mng_info->page.width))\n         || (image->page.height && (image->page.height+image->page.y\n         < mng_info->page.height))))\n       {\n         (void) WriteBlobMSBULong(image,6L);\n         PNGType(chunk,mng_BACK);\n         LogPNGChunk(logging,mng_BACK,6L);\n         red=ScaleQuantumToShort(image->background_color.red);\n         green=ScaleQuantumToShort(image->background_color.green);\n         blue=ScaleQuantumToShort(image->background_color.blue);\n         PNGShort(chunk+4,red);\n         PNGShort(chunk+6,green);\n         PNGShort(chunk+8,blue);\n         (void) WriteBlob(image,10,chunk);\n         (void) WriteBlobMSBULong(image,crc32(0,chunk,10));\n         if (mng_info->equal_backgrounds)\n           {\n             (void) WriteBlobMSBULong(image,6L);\n             PNGType(chunk,mng_bKGD);\n             LogPNGChunk(logging,mng_bKGD,6L);\n             (void) WriteBlob(image,10,chunk);\n             (void) WriteBlobMSBULong(image,crc32(0,chunk,10));\n           }\n       }\n\n#ifdef PNG_WRITE_EMPTY_PLTE_SUPPORTED\n     if ((need_local_plte == MagickFalse) &&\n         (image->storage_class == PseudoClass) &&\n         (all_images_are_gray == MagickFalse))\n       {\n         size_t\n           data_length;\n\n         /*\n           Write MNG PLTE chunk\n         */\n         data_length=3*image->colors;\n         (void) WriteBlobMSBULong(image,data_length);\n         PNGType(chunk,mng_PLTE);\n         LogPNGChunk(logging,mng_PLTE,data_length);\n\n         for (i=0; i < (ssize_t) image->colors; i++)\n         {\n           chunk[4+i*3]=(unsigned char) (ScaleQuantumToChar(\n             image->colormap[i].red) & 0xff);\n           chunk[5+i*3]=(unsigned char) (ScaleQuantumToChar(\n             image->colormap[i].green) & 0xff);\n           chunk[6+i*3]=(unsigned char) (ScaleQuantumToChar(\n             image->colormap[i].blue) & 0xff);\n         }\n\n         (void) WriteBlob(image,data_length+4,chunk);\n         (void) WriteBlobMSBULong(image,crc32(0,chunk,(uInt) (data_length+4)));\n         mng_info->have_write_global_plte=MagickTrue;\n       }\n#endif\n    }\n  scene=0;\n  mng_info->delay=0;\n#if defined(PNG_WRITE_EMPTY_PLTE_SUPPORTED) || \\\n    defined(PNG_MNG_FEATURES_SUPPORTED)\n  mng_info->equal_palettes=MagickFalse;\n#endif\n  do\n  {\n    if (mng_info->adjoin)\n    {\n#if defined(PNG_WRITE_EMPTY_PLTE_SUPPORTED) || \\\n    defined(PNG_MNG_FEATURES_SUPPORTED)\n    /*\n      If we aren't using a global palette for the entire MNG, check to\n      see if we can use one for two or more consecutive images.\n    */\n    if (need_local_plte && use_global_plte && !all_images_are_gray)\n      {\n        if (mng_info->IsPalette)\n          {\n            /*\n              When equal_palettes is true, this image has the same palette\n              as the previous PseudoClass image\n            */\n            mng_info->have_write_global_plte=mng_info->equal_palettes;\n            mng_info->equal_palettes=PalettesAreEqual(image,image->next);\n            if (mng_info->equal_palettes && !mng_info->have_write_global_plte)\n              {\n                /*\n                  Write MNG PLTE chunk\n                */\n                size_t\n                  data_length;\n\n                data_length=3*image->colors;\n                (void) WriteBlobMSBULong(image,data_length);\n                PNGType(chunk,mng_PLTE);\n                LogPNGChunk(logging,mng_PLTE,data_length);\n\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  chunk[4+i*3]=ScaleQuantumToChar(image->colormap[i].red);\n                  chunk[5+i*3]=ScaleQuantumToChar(image->colormap[i].green);\n                  chunk[6+i*3]=ScaleQuantumToChar(image->colormap[i].blue);\n                }\n\n                (void) WriteBlob(image,data_length+4,chunk);\n                (void) WriteBlobMSBULong(image,crc32(0,chunk,\n                   (uInt) (data_length+4)));\n                mng_info->have_write_global_plte=MagickTrue;\n              }\n          }\n        else\n          mng_info->have_write_global_plte=MagickFalse;\n      }\n#endif\n    if (need_defi)\n      {\n        ssize_t\n          previous_x,\n          previous_y;\n\n        if (scene)\n          {\n            previous_x=mng_info->page.x;\n            previous_y=mng_info->page.y;\n          }\n        else\n          {\n            previous_x=0;\n            previous_y=0;\n          }\n        mng_info->page=image->page;\n        if ((mng_info->page.x !=  previous_x) ||\n            (mng_info->page.y != previous_y))\n          {\n             (void) WriteBlobMSBULong(image,12L);  /* data length=12 */\n             PNGType(chunk,mng_DEFI);\n             LogPNGChunk(logging,mng_DEFI,12L);\n             chunk[4]=0; /* object 0 MSB */\n             chunk[5]=0; /* object 0 LSB */\n             chunk[6]=0; /* visible  */\n             chunk[7]=0; /* abstract */\n             PNGLong(chunk+8,(png_uint_32) mng_info->page.x);\n             PNGLong(chunk+12,(png_uint_32) mng_info->page.y);\n             (void) WriteBlob(image,16,chunk);\n             (void) WriteBlobMSBULong(image,crc32(0,chunk,16));\n          }\n      }\n    }\n\n   mng_info->write_mng=write_mng;\n\n   if ((int) image->dispose >= 3)\n     mng_info->framing_mode=3;\n\n   if (mng_info->need_fram && mng_info->adjoin &&\n       ((image->delay != mng_info->delay) ||\n        (mng_info->framing_mode != mng_info->old_framing_mode)))\n     {\n       if (image->delay == mng_info->delay)\n         {\n           /*\n             Write a MNG FRAM chunk with the new framing mode.\n           */\n           (void) WriteBlobMSBULong(image,1L);  /* data length=1 */\n           PNGType(chunk,mng_FRAM);\n           LogPNGChunk(logging,mng_FRAM,1L);\n           chunk[4]=(unsigned char) mng_info->framing_mode;\n           (void) WriteBlob(image,5,chunk);\n           (void) WriteBlobMSBULong(image,crc32(0,chunk,5));\n         }\n       else\n         {\n           /*\n             Write a MNG FRAM chunk with the delay.\n           */\n           (void) WriteBlobMSBULong(image,10L);  /* data length=10 */\n           PNGType(chunk,mng_FRAM);\n           LogPNGChunk(logging,mng_FRAM,10L);\n           chunk[4]=(unsigned char) mng_info->framing_mode;\n           chunk[5]=0;  /* frame name separator (no name) */\n           chunk[6]=2;  /* flag for changing default delay */\n           chunk[7]=0;  /* flag for changing frame timeout */\n           chunk[8]=0;  /* flag for changing frame clipping */\n           chunk[9]=0;  /* flag for changing frame sync_id */\n           PNGLong(chunk+10,(png_uint_32)\n             ((mng_info->ticks_per_second*\n             image->delay)/MagickMax(image->ticks_per_second,1)));\n           (void) WriteBlob(image,14,chunk);\n           (void) WriteBlobMSBULong(image,crc32(0,chunk,14));\n           mng_info->delay=(png_uint_32) image->delay;\n         }\n       mng_info->old_framing_mode=mng_info->framing_mode;\n     }\n\n#if defined(JNG_SUPPORTED)\n   if (image_info->compression == JPEGCompression)\n     {\n       ImageInfo\n         *write_info;\n\n       if (logging != MagickFalse)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  Writing JNG object.\");\n       /* To do: specify the desired alpha compression method. */\n       write_info=CloneImageInfo(image_info);\n       write_info->compression=UndefinedCompression;\n       status=WriteOneJNGImage(mng_info,write_info,image,exception);\n       write_info=DestroyImageInfo(write_info);\n     }\n   else\n#endif\n     {\n       if (logging != MagickFalse)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  Writing PNG object.\");\n\n       mng_info->need_blob = MagickFalse;\n       mng_info->ping_preserve_colormap = MagickFalse;\n\n       /* We don't want any ancillary chunks written */\n       mng_info->ping_exclude_bKGD=MagickTrue;\n       mng_info->ping_exclude_caNv=MagickTrue;\n       mng_info->ping_exclude_cHRM=MagickTrue;\n       mng_info->ping_exclude_date=MagickTrue;\n       mng_info->ping_exclude_EXIF=MagickTrue;\n       mng_info->ping_exclude_gAMA=MagickTrue;\n       mng_info->ping_exclude_iCCP=MagickTrue;\n       /* mng_info->ping_exclude_iTXt=MagickTrue; */\n       mng_info->ping_exclude_oFFs=MagickTrue;\n       mng_info->ping_exclude_pHYs=MagickTrue;\n       mng_info->ping_exclude_sRGB=MagickTrue;\n       mng_info->ping_exclude_tEXt=MagickTrue;\n       mng_info->ping_exclude_tRNS=MagickTrue;\n       mng_info->ping_exclude_vpAg=MagickTrue;\n       mng_info->ping_exclude_zCCP=MagickTrue;\n       mng_info->ping_exclude_zTXt=MagickTrue;\n\n       status=WriteOnePNGImage(mng_info,image_info,image,exception);\n     }\n\n    if (status == MagickFalse)\n      {\n        mng_info=MngInfoFreeStruct(mng_info);\n        (void) CloseBlob(image);\n        return(MagickFalse);\n      }\n    (void) CatchImageException(image);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n\n    if (status == MagickFalse)\n      break;\n\n  } while (mng_info->adjoin);\n\n  if (write_mng)\n    {\n      while (GetPreviousImageInList(image) != (Image *) NULL)\n        image=GetPreviousImageInList(image);\n      /*\n        Write the MEND chunk.\n      */\n      (void) WriteBlobMSBULong(image,0x00000000L);\n      PNGType(chunk,mng_MEND);\n      LogPNGChunk(logging,mng_MEND,0L);\n      (void) WriteBlob(image,4,chunk);\n      (void) WriteBlobMSBULong(image,crc32(0,chunk,4));\n    }\n  /*\n    Relinquish resources.\n  */\n  (void) CloseBlob(image);\n  mng_info=MngInfoFreeStruct(mng_info);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"exit WriteMNGImage()\");\n\n  return(MagickTrue);\n}\n#else /* PNG_LIBPNG_VER > 10011 */\n\nstatic MagickBooleanType WritePNGImage(const ImageInfo *image_info,\n  Image *image)\n{\n  (void) image;\n  printf(\"Your PNG library is too old: You have libpng-%s\\n\",\n     PNG_LIBPNG_VER_STRING);\n\n  ThrowBinaryException(CoderError,\"PNG library is too old\",\n     image_info->filename);\n}\n\nstatic MagickBooleanType WriteMNGImage(const ImageInfo *image_info,\n  Image *image)\n{\n  return(WritePNGImage(image_info,image));\n}\n#endif /* PNG_LIBPNG_VER > 10011 */\n#endif\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            PPPP   N   N   GGGG                              %\n%                            P   P  NN  N  G                                  %\n%                            PPPP   N N N  G  GG                              %\n%                            P      N  NN  G   G                              %\n%                            P      N   N   GGG                               %\n%                                                                             %\n%                                                                             %\n%              Read/Write Portable Network Graphics Image Format              %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                           Glenn Randers-Pehrson                             %\n%                               November 1997                                 %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\n#define IM\n\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/histogram.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/layer.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/MagickCore.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/utility.h\"\n#if defined(MAGICKCORE_PNG_DELEGATE)\n\n/* Suppress libpng pedantic warnings that were added in\n * libpng-1.2.41 and libpng-1.4.0.  If you are working on\n * migration to libpng-1.5, remove these defines and then\n * fix any code that generates warnings.\n */\n/* #define PNG_DEPRECATED   Use of this function is deprecated */\n/* #define PNG_USE_RESULT   The result of this function must be checked */\n/* #define PNG_NORETURN     This function does not return */\n/* #define PNG_ALLOCATED    The result of the function is new memory */\n/* #define PNG_DEPSTRUCT    Access to this struct member is deprecated */\n\n/* PNG_PTR_NORETURN does not work on some platforms, in libpng-1.5.x */\n#define PNG_PTR_NORETURN\n\n#include \"png.h\"\n#include \"zlib.h\"\n\f\n/* ImageMagick differences */\n#define first_scene scene\n\n#if PNG_LIBPNG_VER > 10011\n/*\n  Optional declarations. Define or undefine them as you like.\n*/\n/* #define PNG_DEBUG -- turning this on breaks VisualC compiling */\n\n/*\n  Features under construction.  Define these to work on them.\n*/\n#undef MNG_OBJECT_BUFFERS\n#undef MNG_BASI_SUPPORTED\n#define MNG_COALESCE_LAYERS /* In 5.4.4, this interfered with MMAP'ed files. */\n#define MNG_INSERT_LAYERS   /* Troublesome, but seem to work as of 5.4.4 */\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n#  define JNG_SUPPORTED /* Not finished as of 5.5.2.  See \"To do\" comments. */\n#endif\n#if !defined(RGBColorMatchExact)\n#define IsPNGColorEqual(color,target) \\\n       (((color).red == (target).red) && \\\n        ((color).green == (target).green) && \\\n        ((color).blue == (target).blue))\n#endif\n\n/* Table of recognized sRGB ICC profiles */\nstruct sRGB_info_struct\n{\n    png_uint_32 len;\n    png_uint_32 crc;\n    png_byte intent;\n};\n\nconst struct sRGB_info_struct sRGB_info[] =\n{\n    /* ICC v2 perceptual sRGB_IEC61966-2-1_black_scaled.icc */\n    { 3048, 0x3b8772b9UL, 0},\n\n    /* ICC v2 relative sRGB_IEC61966-2-1_no_black_scaling.icc */\n    { 3052, 0x427ebb21UL, 1},\n\n    /* ICC v4 perceptual sRGB_v4_ICC_preference_displayclass.icc */\n    {60988, 0x306fd8aeUL, 0},\n\n    /* ICC v4 perceptual sRGB_v4_ICC_preference.icc perceptual */\n     {60960, 0xbbef7812UL, 0},\n\n    /* HP? sRGB v2 media-relative sRGB_IEC61966-2-1_noBPC.icc */\n     { 3024, 0x5d5129ceUL, 1},\n\n     /* HP-Microsoft sRGB v2 perceptual */\n     { 3144, 0x182ea552UL, 0},\n\n     /* HP-Microsoft sRGB v2 media-relative */\n     { 3144, 0xf29e526dUL, 1},\n\n     /* Facebook's \"2012/01/25 03:41:57\", 524, \"TINYsRGB.icc\" */\n     {  524, 0xd4938c39UL, 0},\n\n     /* \"2012/11/28 22:35:21\", 3212, \"Argyll_sRGB.icm\") */\n     { 3212, 0x034af5a1UL, 0},\n\n     /* Not recognized */\n     {    0, 0x00000000UL, 0},\n};\n\n/* Macros for left-bit-replication to ensure that pixels\n * and PixelInfos all have the same image->depth, and for use\n * in PNG8 quantization.\n */\n\n/* LBR01: Replicate top bit */\n\n#define LBR01PacketRed(pixelpacket) \\\n     (pixelpacket).red=(ScaleQuantumToChar((pixelpacket).red) < 0x10 ? \\\n        0 : QuantumRange);\n\n#define LBR01PacketGreen(pixelpacket) \\\n     (pixelpacket).green=(ScaleQuantumToChar((pixelpacket).green) < 0x10 ? \\\n        0 : QuantumRange);\n\n#define LBR01PacketBlue(pixelpacket) \\\n     (pixelpacket).blue=(ScaleQuantumToChar((pixelpacket).blue) < 0x10 ? \\\n        0 : QuantumRange);\n\n#define LBR01PacketAlpha(pixelpacket) \\\n     (pixelpacket).alpha=(ScaleQuantumToChar((pixelpacket).alpha) < 0x10 ? \\\n        0 : QuantumRange);\n\n#define LBR01PacketRGB(pixelpacket) \\\n        { \\\n        LBR01PacketRed((pixelpacket)); \\\n        LBR01PacketGreen((pixelpacket)); \\\n        LBR01PacketBlue((pixelpacket)); \\\n        }\n\n#define LBR01PacketRGBO(pixelpacket) \\\n        { \\\n        LBR01PacketRGB((pixelpacket)); \\\n        LBR01PacketAlpha((pixelpacket)); \\\n        }\n\n#define LBR01PixelRed(pixel) \\\n        (SetPixelRed(image, \\\n        ScaleQuantumToChar(GetPixelRed(image,(pixel))) < 0x10 ? \\\n        0 : QuantumRange,(pixel)));\n\n#define LBR01PixelGreen(pixel) \\\n        (SetPixelGreen(image, \\\n        ScaleQuantumToChar(GetPixelGreen(image,(pixel))) < 0x10 ? \\\n        0 : QuantumRange,(pixel)));\n\n#define LBR01PixelBlue(pixel) \\\n        (SetPixelBlue(image, \\\n        ScaleQuantumToChar(GetPixelBlue(image,(pixel))) < 0x10 ? \\\n        0 : QuantumRange,(pixel)));\n\n#define LBR01PixelAlpha(pixel) \\\n        (SetPixelAlpha(image, \\\n        ScaleQuantumToChar(GetPixelAlpha(image,(pixel))) < 0x10 ? \\\n        0 : QuantumRange,(pixel)));\n\n#define LBR01PixelRGB(pixel) \\\n        { \\\n        LBR01PixelRed((pixel)); \\\n        LBR01PixelGreen((pixel)); \\\n        LBR01PixelBlue((pixel)); \\\n        }\n\n#define LBR01PixelRGBA(pixel) \\\n        { \\\n        LBR01PixelRGB((pixel)); \\\n        LBR01PixelAlpha((pixel)); \\\n        }\n\n/* LBR02: Replicate top 2 bits */\n\n#define LBR02PacketRed(pixelpacket) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar((pixelpacket).red) & 0xc0; \\\n     (pixelpacket).red=ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 2) | (lbr_bits >> 4) | (lbr_bits >> 6))); \\\n   }\n#define LBR02PacketGreen(pixelpacket) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar((pixelpacket).green) & 0xc0; \\\n     (pixelpacket).green=ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 2) | (lbr_bits >> 4) | (lbr_bits >> 6))); \\\n   }\n#define LBR02PacketBlue(pixelpacket) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar((pixelpacket).blue) & 0xc0; \\\n     (pixelpacket).blue=ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 2) | (lbr_bits >> 4) | (lbr_bits >> 6))); \\\n   }\n#define LBR02PacketAlpha(pixelpacket) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar((pixelpacket).alpha) & 0xc0; \\\n     (pixelpacket).alpha=ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 2) | (lbr_bits >> 4) | (lbr_bits >> 6))); \\\n   }\n\n#define LBR02PacketRGB(pixelpacket) \\\n        { \\\n        LBR02PacketRed((pixelpacket)); \\\n        LBR02PacketGreen((pixelpacket)); \\\n        LBR02PacketBlue((pixelpacket)); \\\n        }\n\n#define LBR02PacketRGBO(pixelpacket) \\\n        { \\\n        LBR02PacketRGB((pixelpacket)); \\\n        LBR02PacketAlpha((pixelpacket)); \\\n        }\n\n#define LBR02PixelRed(pixel) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar(GetPixelRed(image,(pixel))) \\\n       & 0xc0; \\\n     SetPixelRed(image, ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 2) | (lbr_bits >> 4) | (lbr_bits >> 6))), \\\n       (pixel)); \\\n   }\n#define LBR02PixelGreen(pixel) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar(GetPixelGreen(image,(pixel)))\\\n       & 0xc0; \\\n     SetPixelGreen(image, ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 2) | (lbr_bits >> 4) | (lbr_bits >> 6))), \\\n       (pixel)); \\\n   }\n#define LBR02PixelBlue(pixel) \\\n   { \\\n     unsigned char lbr_bits= \\\n       ScaleQuantumToChar(GetPixelBlue(image,(pixel))) & 0xc0; \\\n     SetPixelBlue(image, ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 2) | (lbr_bits >> 4) | (lbr_bits >> 6))), \\\n       (pixel)); \\\n   }\n#define LBR02PixelAlpha(pixel) \\\n   { \\\n     unsigned char lbr_bits= \\\n       ScaleQuantumToChar(GetPixelAlpha(image,(pixel))) & 0xc0; \\\n     SetPixelAlpha(image, ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 2) | (lbr_bits >> 4) | (lbr_bits >> 6))), \\\n       (pixel) ); \\\n   }\n\n#define LBR02PixelRGB(pixel) \\\n        { \\\n        LBR02PixelRed((pixel)); \\\n        LBR02PixelGreen((pixel)); \\\n        LBR02PixelBlue((pixel)); \\\n        }\n\n#define LBR02PixelRGBA(pixel) \\\n        { \\\n        LBR02PixelRGB((pixel)); \\\n        LBR02PixelAlpha((pixel)); \\\n        }\n\n/* LBR03: Replicate top 3 bits (only used with opaque pixels during\n   PNG8 quantization) */\n\n#define LBR03PacketRed(pixelpacket) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar((pixelpacket).red) & 0xe0; \\\n     (pixelpacket).red=ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 3) | (lbr_bits >> 6))); \\\n   }\n#define LBR03PacketGreen(pixelpacket) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar((pixelpacket).green) & 0xe0; \\\n     (pixelpacket).green=ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 3) | (lbr_bits >> 6))); \\\n   }\n#define LBR03PacketBlue(pixelpacket) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar((pixelpacket).blue) & 0xe0; \\\n     (pixelpacket).blue=ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 3) | (lbr_bits >> 6))); \\\n   }\n\n#define LBR03PacketRGB(pixelpacket) \\\n        { \\\n        LBR03PacketRed((pixelpacket)); \\\n        LBR03PacketGreen((pixelpacket)); \\\n        LBR03PacketBlue((pixelpacket)); \\\n        }\n\n#define LBR03PixelRed(pixel) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar(GetPixelRed(image,(pixel))) \\\n       & 0xe0; \\\n     SetPixelRed(image, ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 3) | (lbr_bits >> 6))), (pixel)); \\\n   }\n#define LBR03Green(pixel) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar(GetPixelGreen(image,(pixel)))\\\n       & 0xe0; \\\n     SetPixelGreen(image, ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 3) | (lbr_bits >> 6))), (pixel)); \\\n   }\n#define LBR03Blue(pixel) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar(GetPixelBlue(image,(pixel))) \\\n       & 0xe0; \\\n     SetPixelBlue(image, ScaleCharToQuantum( \\\n       (lbr_bits | (lbr_bits >> 3) | (lbr_bits >> 6))), (pixel)); \\\n   }\n\n#define LBR03RGB(pixel) \\\n        { \\\n        LBR03PixelRed((pixel)); \\\n        LBR03Green((pixel)); \\\n        LBR03Blue((pixel)); \\\n        }\n\n/* LBR04: Replicate top 4 bits */\n\n#define LBR04PacketRed(pixelpacket) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar((pixelpacket).red) & 0xf0; \\\n     (pixelpacket).red=ScaleCharToQuantum((lbr_bits | (lbr_bits >> 4))); \\\n   }\n#define LBR04PacketGreen(pixelpacket) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar((pixelpacket).green) & 0xf0; \\\n     (pixelpacket).green=ScaleCharToQuantum((lbr_bits | (lbr_bits >> 4))); \\\n   }\n#define LBR04PacketBlue(pixelpacket) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar((pixelpacket).blue) & 0xf0; \\\n     (pixelpacket).blue=ScaleCharToQuantum((lbr_bits | (lbr_bits >> 4))); \\\n   }\n#define LBR04PacketAlpha(pixelpacket) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar((pixelpacket).alpha) & 0xf0; \\\n     (pixelpacket).alpha=ScaleCharToQuantum((lbr_bits | (lbr_bits >> 4))); \\\n   }\n\n#define LBR04PacketRGB(pixelpacket) \\\n        { \\\n        LBR04PacketRed((pixelpacket)); \\\n        LBR04PacketGreen((pixelpacket)); \\\n        LBR04PacketBlue((pixelpacket)); \\\n        }\n\n#define LBR04PacketRGBO(pixelpacket) \\\n        { \\\n        LBR04PacketRGB((pixelpacket)); \\\n        LBR04PacketAlpha((pixelpacket)); \\\n        }\n\n#define LBR04PixelRed(pixel) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar(GetPixelRed(image,(pixel))) \\\n       & 0xf0; \\\n     SetPixelRed(image,\\\n       ScaleCharToQuantum((lbr_bits | (lbr_bits >> 4))), (pixel)); \\\n   }\n#define LBR04PixelGreen(pixel) \\\n   { \\\n     unsigned char lbr_bits=ScaleQuantumToChar(GetPixelGreen(image,(pixel)))\\\n       & 0xf0; \\\n     SetPixelGreen(image,\\\n       ScaleCharToQuantum((lbr_bits | (lbr_bits >> 4))), (pixel)); \\\n   }\n#define LBR04PixelBlue(pixel) \\\n   { \\\n     unsigned char lbr_bits= \\\n       ScaleQuantumToChar(GetPixelBlue(image,(pixel))) & 0xf0; \\\n     SetPixelBlue(image,\\\n       ScaleCharToQuantum((lbr_bits | (lbr_bits >> 4))), (pixel)); \\\n   }\n#define LBR04PixelAlpha(pixel) \\\n   { \\\n     unsigned char lbr_bits= \\\n       ScaleQuantumToChar(GetPixelAlpha(image,(pixel))) & 0xf0; \\\n     SetPixelAlpha(image,\\\n       ScaleCharToQuantum((lbr_bits | (lbr_bits >> 4))), (pixel)); \\\n   }\n\n#define LBR04PixelRGB(pixel) \\\n        { \\\n        LBR04PixelRed((pixel)); \\\n        LBR04PixelGreen((pixel)); \\\n        LBR04PixelBlue((pixel)); \\\n        }\n\n#define LBR04PixelRGBA(pixel) \\\n        { \\\n        LBR04PixelRGB((pixel)); \\\n        LBR04PixelAlpha((pixel)); \\\n        }\n\n/*\n  Establish thread safety.\n  setjmp/longjmp is claimed to be safe on these platforms:\n  setjmp/longjmp is alleged to be unsafe on these platforms:\n*/\n#ifdef PNG_SETJMP_SUPPORTED\n# ifndef IMPNG_SETJMP_IS_THREAD_SAFE\n#   define IMPNG_SETJMP_NOT_THREAD_SAFE\n# endif\n\n# ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\nstatic SemaphoreInfo\n  *ping_semaphore = (SemaphoreInfo *) NULL;\n# endif\n#endif\n\n/*\n  This temporary until I set up malloc'ed object attributes array.\n  Recompile with MNG_MAX_OBJECTS=65536L to avoid this limit but\n  waste more memory.\n*/\n#define MNG_MAX_OBJECTS 256\n\n/*\n  If this not defined, spec is interpreted strictly.  If it is\n  defined, an attempt will be made to recover from some errors,\n  including\n      o global PLTE too short\n*/\n#undef MNG_LOOSE\n\n/*\n  Don't try to define PNG_MNG_FEATURES_SUPPORTED here.  Make sure\n  it's defined in libpng/pngconf.h, version 1.0.9 or later.  It won't work\n  with earlier versions of libpng.  From libpng-1.0.3a to libpng-1.0.8,\n  PNG_READ|WRITE_EMPTY_PLTE were used but those have been deprecated in\n  libpng in favor of PNG_MNG_FEATURES_SUPPORTED, so we set them here.\n  PNG_MNG_FEATURES_SUPPORTED is disabled by default in libpng-1.0.9 and\n  will be enabled by default in libpng-1.2.0.\n*/\n#ifdef PNG_MNG_FEATURES_SUPPORTED\n#  ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n#    define PNG_READ_EMPTY_PLTE_SUPPORTED\n#  endif\n#  ifndef PNG_WRITE_EMPTY_PLTE_SUPPORTED\n#    define PNG_WRITE_EMPTY_PLTE_SUPPORTED\n#  endif\n#endif\n\n/*\n  Maximum valid size_t in PNG/MNG chunks is (2^31)-1\n  This macro is only defined in libpng-1.0.3 and later.\n  Previously it was PNG_MAX_UINT but that was deprecated in libpng-1.2.6\n*/\n#ifndef PNG_UINT_31_MAX\n#define PNG_UINT_31_MAX (png_uint_32) 0x7fffffffL\n#endif\n\n/*\n  Constant strings for known chunk types.  If you need to add a chunk,\n  add a string holding the name here.   To make the code more\n  portable, we use ASCII numbers like this, not characters.\n*/\n\nstatic const png_byte mng_MHDR[5]={ 77,  72,  68,  82, (png_byte) '\\0'};\nstatic const png_byte mng_BACK[5]={ 66,  65,  67,  75, (png_byte) '\\0'};\nstatic const png_byte mng_BASI[5]={ 66,  65,  83,  73, (png_byte) '\\0'};\nstatic const png_byte mng_CLIP[5]={ 67,  76,  73,  80, (png_byte) '\\0'};\nstatic const png_byte mng_CLON[5]={ 67,  76,  79,  78, (png_byte) '\\0'};\nstatic const png_byte mng_DEFI[5]={ 68,  69,  70,  73, (png_byte) '\\0'};\nstatic const png_byte mng_DHDR[5]={ 68,  72,  68,  82, (png_byte) '\\0'};\nstatic const png_byte mng_DISC[5]={ 68,  73,  83,  67, (png_byte) '\\0'};\nstatic const png_byte mng_ENDL[5]={ 69,  78,  68,  76, (png_byte) '\\0'};\nstatic const png_byte mng_FRAM[5]={ 70,  82,  65,  77, (png_byte) '\\0'};\nstatic const png_byte mng_IEND[5]={ 73,  69,  78,  68, (png_byte) '\\0'};\nstatic const png_byte mng_IHDR[5]={ 73,  72,  68,  82, (png_byte) '\\0'};\nstatic const png_byte mng_JHDR[5]={ 74,  72,  68,  82, (png_byte) '\\0'};\nstatic const png_byte mng_LOOP[5]={ 76,  79,  79,  80, (png_byte) '\\0'};\nstatic const png_byte mng_MAGN[5]={ 77,  65,  71,  78, (png_byte) '\\0'};\nstatic const png_byte mng_MEND[5]={ 77,  69,  78,  68, (png_byte) '\\0'};\nstatic const png_byte mng_MOVE[5]={ 77,  79,  86,  69, (png_byte) '\\0'};\nstatic const png_byte mng_PAST[5]={ 80,  65,  83,  84, (png_byte) '\\0'};\nstatic const png_byte mng_PLTE[5]={ 80,  76,  84,  69, (png_byte) '\\0'};\nstatic const png_byte mng_SAVE[5]={ 83,  65,  86,  69, (png_byte) '\\0'};\nstatic const png_byte mng_SEEK[5]={ 83,  69,  69,  75, (png_byte) '\\0'};\nstatic const png_byte mng_SHOW[5]={ 83,  72,  79,  87, (png_byte) '\\0'};\nstatic const png_byte mng_TERM[5]={ 84,  69,  82,  77, (png_byte) '\\0'};\nstatic const png_byte mng_bKGD[5]={ 98,  75,  71,  68, (png_byte) '\\0'};\nstatic const png_byte mng_caNv[5]={ 99,  97,  78, 118, (png_byte) '\\0'};\nstatic const png_byte mng_cHRM[5]={ 99,  72,  82,  77, (png_byte) '\\0'};\nstatic const png_byte mng_eXIf[5]={101,  88,  73, 102, (png_byte) '\\0'};\nstatic const png_byte mng_gAMA[5]={103,  65,  77,  65, (png_byte) '\\0'};\nstatic const png_byte mng_iCCP[5]={105,  67,  67,  80, (png_byte) '\\0'};\nstatic const png_byte mng_nEED[5]={110,  69,  69,  68, (png_byte) '\\0'};\nstatic const png_byte mng_pHYg[5]={112,  72,  89, 103, (png_byte) '\\0'};\nstatic const png_byte mng_vpAg[5]={118, 112,  65, 103, (png_byte) '\\0'};\nstatic const png_byte mng_pHYs[5]={112,  72,  89, 115, (png_byte) '\\0'};\nstatic const png_byte mng_sBIT[5]={115,  66,  73,  84, (png_byte) '\\0'};\nstatic const png_byte mng_sRGB[5]={115,  82,  71,  66, (png_byte) '\\0'};\nstatic const png_byte mng_tRNS[5]={116,  82,  78,  83, (png_byte) '\\0'};\n\n#if defined(JNG_SUPPORTED)\nstatic const png_byte mng_IDAT[5]={ 73,  68,  65,  84, (png_byte) '\\0'};\nstatic const png_byte mng_JDAT[5]={ 74,  68,  65,  84, (png_byte) '\\0'};\nstatic const png_byte mng_JDAA[5]={ 74,  68,  65,  65, (png_byte) '\\0'};\nstatic const png_byte mng_JdAA[5]={ 74, 100,  65,  65, (png_byte) '\\0'};\nstatic const png_byte mng_JSEP[5]={ 74,  83,  69,  80, (png_byte) '\\0'};\nstatic const png_byte mng_oFFs[5]={111,  70,  70, 115, (png_byte) '\\0'};\n#endif\n\n#if 0\n/* Other known chunks that are not yet supported by ImageMagick: */\nstatic const png_byte mng_hIST[5]={104,  73,  83,  84, (png_byte) '\\0'};\nstatic const png_byte mng_iTXt[5]={105,  84,  88, 116, (png_byte) '\\0'};\nstatic const png_byte mng_sPLT[5]={115,  80,  76,  84, (png_byte) '\\0'};\nstatic const png_byte mng_sTER[5]={115,  84,  69,  82, (png_byte) '\\0'};\nstatic const png_byte mng_tEXt[5]={116,  69,  88, 116, (png_byte) '\\0'};\nstatic const png_byte mng_tIME[5]={116,  73,  77,  69, (png_byte) '\\0'};\nstatic const png_byte mng_zTXt[5]={122,  84,  88, 116, (png_byte) '\\0'};\n#endif\n\ntypedef struct _MngBox\n{\n  long\n    left,\n    right,\n    top,\n    bottom;\n} MngBox;\n\ntypedef struct _MngPair\n{\n  volatile long\n    a,\n    b;\n} MngPair;\n\n#ifdef MNG_OBJECT_BUFFERS\ntypedef struct _MngBuffer\n{\n\n  size_t\n    height,\n    width;\n\n  Image\n    *image;\n\n  png_color\n    plte[256];\n\n  int\n    reference_count;\n\n  unsigned char\n    alpha_sample_depth,\n    compression_method,\n    color_type,\n    concrete,\n    filter_method,\n    frozen,\n    image_type,\n    interlace_method,\n    pixel_sample_depth,\n    plte_length,\n    sample_depth,\n    viewable;\n} MngBuffer;\n#endif\n\ntypedef struct _MngInfo\n{\n\n#ifdef MNG_OBJECT_BUFFERS\n  MngBuffer\n    *ob[MNG_MAX_OBJECTS];\n#endif\n\n  Image *\n    image;\n\n  RectangleInfo\n    page;\n\n  int\n    adjoin,\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n    bytes_in_read_buffer,\n    found_empty_plte,\n#endif\n    equal_backgrounds,\n    equal_chrms,\n    equal_gammas,\n#if defined(PNG_WRITE_EMPTY_PLTE_SUPPORTED) || \\\n    defined(PNG_MNG_FEATURES_SUPPORTED)\n    equal_palettes,\n#endif\n    equal_physs,\n    equal_srgbs,\n    framing_mode,\n    have_global_bkgd,\n    have_global_chrm,\n    have_global_gama,\n    have_global_phys,\n    have_global_sbit,\n    have_global_srgb,\n    have_saved_bkgd_index,\n    have_write_global_chrm,\n    have_write_global_gama,\n    have_write_global_plte,\n    have_write_global_srgb,\n    need_fram,\n    object_id,\n    old_framing_mode,\n    saved_bkgd_index;\n\n  int\n    new_number_colors;\n\n  ssize_t\n    image_found,\n    loop_count[256],\n    loop_iteration[256],\n    scenes_found,\n    x_off[MNG_MAX_OBJECTS],\n    y_off[MNG_MAX_OBJECTS];\n\n  MngBox\n    clip,\n    frame,\n    image_box,\n    object_clip[MNG_MAX_OBJECTS];\n\n  unsigned char\n    /* These flags could be combined into one byte */\n    exists[MNG_MAX_OBJECTS],\n    frozen[MNG_MAX_OBJECTS],\n    loop_active[256],\n    invisible[MNG_MAX_OBJECTS],\n    viewable[MNG_MAX_OBJECTS];\n\n  MagickOffsetType\n    loop_jump[256];\n\n  png_colorp\n    global_plte;\n\n  png_color_8\n    global_sbit;\n\n  png_byte\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n    read_buffer[8],\n#endif\n    global_trns[256];\n\n  float\n    global_gamma;\n\n  ChromaticityInfo\n    global_chrm;\n\n  RenderingIntent\n    global_srgb_intent;\n\n  unsigned long\n    delay,\n    global_plte_length,\n    global_trns_length,\n    global_x_pixels_per_unit,\n    global_y_pixels_per_unit,\n    mng_width,\n    mng_height,\n    ticks_per_second;\n\n  MagickBooleanType\n    need_blob;\n\n  unsigned int\n    IsPalette,\n    global_phys_unit_type,\n    basi_warning,\n    clon_warning,\n    dhdr_warning,\n    jhdr_warning,\n    magn_warning,\n    past_warning,\n    phyg_warning,\n    phys_warning,\n    sbit_warning,\n    show_warning,\n    mng_type,\n    write_mng,\n    write_png_colortype,\n    write_png_depth,\n    write_png_compression_level,\n    write_png_compression_strategy,\n    write_png_compression_filter,\n    write_png8,\n    write_png24,\n    write_png32,\n    write_png48,\n    write_png64;\n\n#ifdef MNG_BASI_SUPPORTED\n  unsigned long\n    basi_width,\n    basi_height;\n\n  unsigned int\n    basi_depth,\n    basi_color_type,\n    basi_compression_method,\n    basi_filter_type,\n    basi_interlace_method,\n    basi_red,\n    basi_green,\n    basi_blue,\n    basi_alpha,\n    basi_viewable;\n#endif\n\n  png_uint_16\n    magn_first,\n    magn_last,\n    magn_mb,\n    magn_ml,\n    magn_mr,\n    magn_mt,\n    magn_mx,\n    magn_my,\n    magn_methx,\n    magn_methy;\n\n  PixelInfo\n    mng_global_bkgd;\n\n  /* Added at version 6.6.6-7 */\n  MagickBooleanType\n    ping_exclude_bKGD,\n    ping_exclude_cHRM,\n    ping_exclude_date,\n    ping_exclude_eXIf,\n    ping_exclude_EXIF,\n    ping_exclude_gAMA,\n    ping_exclude_iCCP,\n    /* ping_exclude_iTXt, */\n    ping_exclude_oFFs,\n    ping_exclude_pHYs,\n    ping_exclude_sRGB,\n    ping_exclude_tEXt,\n    ping_exclude_tRNS,\n    ping_exclude_vpAg,\n    ping_exclude_caNv,\n    ping_exclude_zCCP, /* hex-encoded iCCP */\n    ping_exclude_zTXt,\n    ping_preserve_colormap,\n  /* Added at version 6.8.5-7 */\n    ping_preserve_iCCP,\n  /* Added at version 6.8.9-9 */\n    ping_exclude_tIME;\n\n} MngInfo;\n#endif /* VER */\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePNGImage(const ImageInfo *,Image *,ExceptionInfo *);\n\nstatic MagickBooleanType\n  WriteMNGImage(const ImageInfo *,Image *,ExceptionInfo *);\n\n#if defined(JNG_SUPPORTED)\nstatic MagickBooleanType\n  WriteJNGImage(const ImageInfo *,Image *,ExceptionInfo *);\n#endif\n\n#if PNG_LIBPNG_VER > 10011\n\n\n#if (MAGICKCORE_QUANTUM_DEPTH >= 16)\nstatic MagickBooleanType\nLosslessReduceDepthOK(Image *image,ExceptionInfo *exception)\n{\n    /* Reduce bit depth if it can be reduced losslessly from 16+ to 8.\n     *\n     * This is true if the high byte and the next highest byte of\n     * each sample of the image, the colormap, and the background color\n     * are equal to each other.  We check this by seeing if the samples\n     * are unchanged when we scale them down to 8 and back up to Quantum.\n     *\n     * We don't use the method GetImageDepth() because it doesn't check\n     * background and doesn't handle PseudoClass specially.\n     */\n\n#define QuantumToCharToQuantumEqQuantum(quantum) \\\n ((ScaleCharToQuantum((unsigned char) ScaleQuantumToChar(quantum))) == quantum)\n\n    MagickBooleanType\n      ok_to_reduce=MagickFalse;\n\n    if (image->depth >= 16)\n      {\n\n        const Quantum\n          *p;\n\n        ok_to_reduce=\n           QuantumToCharToQuantumEqQuantum(image->background_color.red) &&\n           QuantumToCharToQuantumEqQuantum(image->background_color.green) &&\n           QuantumToCharToQuantumEqQuantum(image->background_color.blue) ?\n           MagickTrue : MagickFalse;\n\n        if (ok_to_reduce != MagickFalse && image->storage_class == PseudoClass)\n          {\n            int indx;\n\n            for (indx=0; indx < (ssize_t) image->colors; indx++)\n              {\n                ok_to_reduce=(\n                   QuantumToCharToQuantumEqQuantum(\n                   image->colormap[indx].red) &&\n                   QuantumToCharToQuantumEqQuantum(\n                   image->colormap[indx].green) &&\n                   QuantumToCharToQuantumEqQuantum(\n                   image->colormap[indx].blue)) ?\n                   MagickTrue : MagickFalse;\n\n                if (ok_to_reduce == MagickFalse)\n                   break;\n              }\n          }\n\n        if ((ok_to_reduce != MagickFalse) &&\n            (image->storage_class != PseudoClass))\n          {\n            ssize_t\n              y;\n\n            register ssize_t\n              x;\n\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n\n              if (p == (const Quantum *) NULL)\n                {\n                  ok_to_reduce = MagickFalse;\n                  break;\n                }\n\n              for (x=(ssize_t) image->columns-1; x >= 0; x--)\n              {\n                ok_to_reduce=\n                   QuantumToCharToQuantumEqQuantum(GetPixelRed(image,p)) &&\n                   QuantumToCharToQuantumEqQuantum(GetPixelGreen(image,p)) &&\n                   QuantumToCharToQuantumEqQuantum(GetPixelBlue(image,p)) ?\n                   MagickTrue : MagickFalse;\n\n                if (ok_to_reduce == MagickFalse)\n                  break;\n\n                p+=GetPixelChannels(image);\n              }\n              if (x >= 0)\n                break;\n            }\n          }\n\n        if (ok_to_reduce != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    OK to reduce PNG bit depth to 8 without loss of info\");\n          }\n        else\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Not OK to reduce PNG bit depth to 8 without losing info\");\n          }\n      }\n\n    return ok_to_reduce;\n}\n#endif /* MAGICKCORE_QUANTUM_DEPTH >= 16 */\n\nstatic const char* PngColorTypeToString(const unsigned int color_type)\n{\n  const char\n    *result = \"Unknown\";\n\n  switch (color_type)\n    {\n    case PNG_COLOR_TYPE_GRAY:\n      result = \"Gray\";\n      break;\n    case PNG_COLOR_TYPE_GRAY_ALPHA:\n      result = \"Gray+Alpha\";\n      break;\n    case PNG_COLOR_TYPE_PALETTE:\n      result = \"Palette\";\n      break;\n    case PNG_COLOR_TYPE_RGB:\n      result = \"RGB\";\n      break;\n    case PNG_COLOR_TYPE_RGB_ALPHA:\n      result = \"RGB+Alpha\";\n      break;\n    }\n\n  return result;\n}\n\nstatic int\nMagick_RenderingIntent_to_PNG_RenderingIntent(const RenderingIntent intent)\n{\n  switch (intent)\n  {\n    case PerceptualIntent:\n       return 0;\n\n    case RelativeIntent:\n       return 1;\n\n    case SaturationIntent:\n       return 2;\n\n    case AbsoluteIntent:\n       return 3;\n\n    default:\n       return -1;\n  }\n}\n\nstatic RenderingIntent\nMagick_RenderingIntent_from_PNG_RenderingIntent(const int ping_intent)\n{\n  switch (ping_intent)\n  {\n    case 0:\n      return PerceptualIntent;\n\n    case 1:\n      return RelativeIntent;\n\n    case 2:\n      return SaturationIntent;\n\n    case 3:\n      return AbsoluteIntent;\n\n    default:\n      return UndefinedIntent;\n    }\n}\n\nstatic const char *\nMagick_RenderingIntentString_from_PNG_RenderingIntent(const int ping_intent)\n{\n  switch (ping_intent)\n  {\n    case 0:\n      return \"Perceptual Intent\";\n\n    case 1:\n      return \"Relative Intent\";\n\n    case 2:\n      return \"Saturation Intent\";\n\n    case 3:\n      return \"Absolute Intent\";\n\n    default:\n      return \"Undefined Intent\";\n    }\n}\n\nstatic const char *\nMagick_ColorType_from_PNG_ColorType(const int ping_colortype)\n{\n  switch (ping_colortype)\n  {\n    case 0:\n      return \"Grayscale\";\n\n    case 2:\n      return \"Truecolor\";\n\n    case 3:\n      return \"Indexed\";\n\n    case 4:\n      return \"GrayAlpha\";\n\n    case 6:\n      return \"RGBA\";\n\n    default:\n      return \"UndefinedColorType\";\n    }\n}\n\n#endif /* PNG_LIBPNG_VER > 10011 */\n#endif /* MAGICKCORE_PNG_DELEGATE */\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s M N G                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsMNG() returns MagickTrue if the image format type, identified by the\n%  magick string, is MNG.\n%\n%  The format of the IsMNG method is:\n%\n%      MagickBooleanType IsMNG(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n%\n*/\nstatic MagickBooleanType IsMNG(const unsigned char *magick,const size_t length)\n{\n  if (length < 8)\n    return(MagickFalse);\n\n  if (memcmp(magick,\"\\212MNG\\r\\n\\032\\n\",8) == 0)\n    return(MagickTrue);\n\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s J N G                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsJNG() returns MagickTrue if the image format type, identified by the\n%  magick string, is JNG.\n%\n%  The format of the IsJNG method is:\n%\n%      MagickBooleanType IsJNG(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n%\n*/\nstatic MagickBooleanType IsJNG(const unsigned char *magick,const size_t length)\n{\n  if (length < 8)\n    return(MagickFalse);\n\n  if (memcmp(magick,\"\\213JNG\\r\\n\\032\\n\",8) == 0)\n    return(MagickTrue);\n\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s P N G                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsPNG() returns MagickTrue if the image format type, identified by the\n%  magick string, is PNG.\n%\n%  The format of the IsPNG method is:\n%\n%      MagickBooleanType IsPNG(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsPNG(const unsigned char *magick,const size_t length)\n{\n  if (length < 8)\n    return(MagickFalse);\n\n  if (memcmp(magick,\"\\211PNG\\r\\n\\032\\n\",8) == 0)\n    return(MagickTrue);\n\n  return(MagickFalse);\n}\n\f\n#if defined(MAGICKCORE_PNG_DELEGATE)\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n#if (PNG_LIBPNG_VER > 10011)\nstatic size_t WriteBlobMSBULong(Image *image,const size_t value)\n{\n  unsigned char\n    buffer[4];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  buffer[0]=(unsigned char) (value >> 24);\n  buffer[1]=(unsigned char) (value >> 16);\n  buffer[2]=(unsigned char) (value >> 8);\n  buffer[3]=(unsigned char) value;\n  return((size_t) WriteBlob(image,4,buffer));\n}\n\nstatic void PNGLong(png_bytep p,png_uint_32 value)\n{\n  *p++=(png_byte) ((value >> 24) & 0xff);\n  *p++=(png_byte) ((value >> 16) & 0xff);\n  *p++=(png_byte) ((value >> 8) & 0xff);\n  *p++=(png_byte) (value & 0xff);\n}\n\nstatic void PNGsLong(png_bytep p,png_int_32 value)\n{\n  *p++=(png_byte) ((value >> 24) & 0xff);\n  *p++=(png_byte) ((value >> 16) & 0xff);\n  *p++=(png_byte) ((value >> 8) & 0xff);\n  *p++=(png_byte) (value & 0xff);\n}\n\nstatic void PNGShort(png_bytep p,png_uint_16 value)\n{\n  *p++=(png_byte) ((value >> 8) & 0xff);\n  *p++=(png_byte) (value & 0xff);\n}\n\nstatic void PNGType(png_bytep p,const png_byte *type)\n{\n  (void) CopyMagickMemory(p,type,4*sizeof(png_byte));\n}\n\nstatic void LogPNGChunk(MagickBooleanType logging, const png_byte *type,\n   size_t length)\n{\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Writing %c%c%c%c chunk, length: %.20g\",\n      type[0],type[1],type[2],type[3],(double) length);\n}\n#endif /* PNG_LIBPNG_VER > 10011 */\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\n#if PNG_LIBPNG_VER > 10011\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P N G I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPNGImage() reads a Portable Network Graphics (PNG) or\n%  Multiple-image Network Graphics (MNG) image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image or set of images.\n%\n%  MNG support written by Glenn Randers-Pehrson, glennrp@image...\n%\n%  The format of the ReadPNGImage method is:\n%\n%     Image *ReadPNGImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n%  To do, more or less in chronological order (as of version 5.5.2,\n%   November 26, 2002 -- glennrp -- see also \"To do\" under WriteMNGImage):\n%\n%    Get 16-bit cheap transparency working.\n%\n%    (At this point, PNG decoding is supposed to be in full MNG-LC compliance)\n%\n%    Preserve all unknown and not-yet-handled known chunks found in input\n%    PNG file and copy them into output PNG files according to the PNG\n%    copying rules.\n%\n%    (At this point, PNG encoding should be in full MNG compliance)\n%\n%    Provide options for choice of background to use when the MNG BACK\n%    chunk is not present or is not mandatory (i.e., leave transparent,\n%    user specified, MNG BACK, PNG bKGD)\n%\n%    Implement LOOP/ENDL [done, but could do discretionary loops more\n%    efficiently by linking in the duplicate frames.].\n%\n%    Decode and act on the MHDR simplicity profile (offer option to reject\n%    files or attempt to process them anyway when the profile isn't LC or VLC).\n%\n%    Upgrade to full MNG without Delta-PNG.\n%\n%        o  BACK [done a while ago except for background image ID]\n%        o  MOVE [done 15 May 1999]\n%        o  CLIP [done 15 May 1999]\n%        o  DISC [done 19 May 1999]\n%        o  SAVE [partially done 19 May 1999 (marks objects frozen)]\n%        o  SEEK [partially done 19 May 1999 (discard function only)]\n%        o  SHOW\n%        o  PAST\n%        o  BASI\n%        o  MNG-level tEXt/iTXt/zTXt\n%        o  pHYg\n%        o  pHYs\n%        o  sBIT\n%        o  bKGD\n%        o  iTXt (wait for libpng implementation).\n%\n%    Use the scene signature to discover when an identical scene is\n%    being reused, and just point to the original image->exception instead\n%    of storing another set of pixels.  This not specific to MNG\n%    but could be applied generally.\n%\n%    Upgrade to full MNG with Delta-PNG.\n%\n%    JNG tEXt/iTXt/zTXt\n%\n%    We will not attempt to read files containing the CgBI chunk.\n%    They are really Xcode files meant for display on the iPhone.\n%    These are not valid PNG files and it is impossible to recover\n%    the original PNG from files that have been converted to Xcode-PNG,\n%    since irretrievable loss of color data has occurred due to the\n%    use of premultiplied alpha.\n*/\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n/*\n  This the function that does the actual reading of data.  It is\n  the same as the one supplied in libpng, except that it receives the\n  datastream from the ReadBlob() function instead of standard input.\n*/\nstatic void png_get_data(png_structp png_ptr,png_bytep data,png_size_t length)\n{\n  Image\n    *image;\n\n  image=(Image *) png_get_io_ptr(png_ptr);\n  if (length != 0)\n    {\n      png_size_t\n        check;\n\n      check=(png_size_t) ReadBlob(image,(size_t) length,data);\n      if (check != length)\n        {\n          char\n            msg[MagickPathExtent];\n\n          (void) FormatLocaleString(msg,MagickPathExtent,\n            \"Expected %.20g bytes; found %.20g bytes\",(double) length,\n            (double) check);\n          png_warning(png_ptr,msg);\n          png_error(png_ptr,\"Read Exception\");\n        }\n    }\n}\n\n#if !defined(PNG_READ_EMPTY_PLTE_SUPPORTED) && \\\n    !defined(PNG_MNG_FEATURES_SUPPORTED)\n/* We use mng_get_data() instead of png_get_data() if we have a libpng\n * older than libpng-1.0.3a, which was the first to allow the empty\n * PLTE, or a newer libpng in which PNG_MNG_FEATURES_SUPPORTED was\n * ifdef'ed out.  Earlier versions would crash if the bKGD chunk was\n * encountered after an empty PLTE, so we have to look ahead for bKGD\n * chunks and remove them from the datastream that is passed to libpng,\n * and store their contents for later use.\n */\nstatic void mng_get_data(png_structp png_ptr,png_bytep data,png_size_t length)\n{\n  MngInfo\n    *mng_info;\n\n  Image\n    *image;\n\n  png_size_t\n    check;\n\n  register ssize_t\n    i;\n\n  i=0;\n  mng_info=(MngInfo *) png_get_io_ptr(png_ptr);\n  image=(Image *) mng_info->image;\n  while (mng_info->bytes_in_read_buffer && length)\n  {\n    data[i]=mng_info->read_buffer[i];\n    mng_info->bytes_in_read_buffer--;\n    length--;\n    i++;\n  }\n  if (length != 0)\n    {\n      check=(png_size_t) ReadBlob(image,(size_t) length,(char *) data);\n\n      if (check != length)\n        png_error(png_ptr,\"Read Exception\");\n\n      if (length == 4)\n        {\n          if ((data[0] == 0) && (data[1] == 0) && (data[2] == 0) &&\n              (data[3] == 0))\n            {\n              check=(png_size_t) ReadBlob(image,(size_t) length,\n                (char *) mng_info->read_buffer);\n              mng_info->read_buffer[4]=0;\n              mng_info->bytes_in_read_buffer=4;\n              if (memcmp(mng_info->read_buffer,mng_PLTE,4) == 0)\n                mng_info->found_empty_plte=MagickTrue;\n              if (memcmp(mng_info->read_buffer,mng_IEND,4) == 0)\n                {\n                  mng_info->found_empty_plte=MagickFalse;\n                  mng_info->have_saved_bkgd_index=MagickFalse;\n                }\n            }\n\n          if ((data[0] == 0) && (data[1] == 0) && (data[2] == 0) &&\n              (data[3] == 1))\n            {\n              check=(png_size_t) ReadBlob(image,(size_t) length,\n                (char *) mng_info->read_buffer);\n              mng_info->read_buffer[4]=0;\n              mng_info->bytes_in_read_buffer=4;\n              if (memcmp(mng_info->read_buffer,mng_bKGD,4) == 0)\n                if (mng_info->found_empty_plte)\n                  {\n                    /*\n                      Skip the bKGD data byte and CRC.\n                    */\n                    check=(png_size_t)\n                      ReadBlob(image,5,(char *) mng_info->read_buffer);\n                    check=(png_size_t) ReadBlob(image,(size_t) length,\n                      (char *) mng_info->read_buffer);\n                    mng_info->saved_bkgd_index=mng_info->read_buffer[0];\n                    mng_info->have_saved_bkgd_index=MagickTrue;\n                    mng_info->bytes_in_read_buffer=0;\n                  }\n            }\n        }\n    }\n}\n#endif\n\nstatic void png_put_data(png_structp png_ptr,png_bytep data,png_size_t length)\n{\n  Image\n    *image;\n\n  image=(Image *) png_get_io_ptr(png_ptr);\n  if (length != 0)\n    {\n      png_size_t\n        check;\n\n      check=(png_size_t) WriteBlob(image,(size_t) length,data);\n\n      if (check != length)\n        png_error(png_ptr,\"WriteBlob Failed\");\n    }\n}\n\nstatic void png_flush_data(png_structp png_ptr)\n{\n  (void) png_ptr;\n}\n\n#ifdef PNG_WRITE_EMPTY_PLTE_SUPPORTED\nstatic int PalettesAreEqual(Image *a,Image *b)\n{\n  ssize_t\n    i;\n\n  if ((a == (Image *) NULL) || (b == (Image *) NULL))\n    return((int) MagickFalse);\n\n  if (a->storage_class != PseudoClass || b->storage_class != PseudoClass)\n    return((int) MagickFalse);\n\n  if (a->colors != b->colors)\n    return((int) MagickFalse);\n\n  for (i=0; i < (ssize_t) a->colors; i++)\n  {\n    if ((a->colormap[i].red != b->colormap[i].red) ||\n        (a->colormap[i].green != b->colormap[i].green) ||\n        (a->colormap[i].blue != b->colormap[i].blue))\n      return((int) MagickFalse);\n  }\n\n  return((int) MagickTrue);\n}\n#endif\n\nstatic void MngInfoDiscardObject(MngInfo *mng_info,int i)\n{\n  if (i && (i < MNG_MAX_OBJECTS) && (mng_info != (MngInfo *) NULL) &&\n      mng_info->exists[i] && !mng_info->frozen[i])\n    {\n#ifdef MNG_OBJECT_BUFFERS\n      if (mng_info->ob[i] != (MngBuffer *) NULL)\n        {\n          if (mng_info->ob[i]->reference_count > 0)\n            mng_info->ob[i]->reference_count--;\n\n          if (mng_info->ob[i]->reference_count == 0)\n            {\n              if (mng_info->ob[i]->image != (Image *) NULL)\n                mng_info->ob[i]->image=DestroyImage(mng_info->ob[i]->image);\n\n              mng_info->ob[i]=DestroyString(mng_info->ob[i]);\n            }\n        }\n      mng_info->ob[i]=(MngBuffer *) NULL;\n#endif\n      mng_info->exists[i]=MagickFalse;\n      mng_info->invisible[i]=MagickFalse;\n      mng_info->viewable[i]=MagickFalse;\n      mng_info->frozen[i]=MagickFalse;\n      mng_info->x_off[i]=0;\n      mng_info->y_off[i]=0;\n      mng_info->object_clip[i].left=0;\n      mng_info->object_clip[i].right=(ssize_t) PNG_UINT_31_MAX;\n      mng_info->object_clip[i].top=0;\n      mng_info->object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX;\n    }\n}\n\nstatic MngInfo *MngInfoFreeStruct(MngInfo *mng_info)\n{\n  register ssize_t\n    i;\n\n  if (mng_info == (MngInfo *) NULL)\n    return((MngInfo *) NULL);\n\n  for (i=1; i < MNG_MAX_OBJECTS; i++)\n    MngInfoDiscardObject(mng_info,i);\n\n  if (mng_info->global_plte != (png_colorp) NULL)\n    mng_info->global_plte=(png_colorp)\n      RelinquishMagickMemory(mng_info->global_plte);\n\n  return((MngInfo *) RelinquishMagickMemory(mng_info));\n}\n\nstatic MngBox mng_minimum_box(MngBox box1,MngBox box2)\n{\n  MngBox\n    box;\n\n  box=box1;\n  if (box.left < box2.left)\n    box.left=box2.left;\n\n  if (box.top < box2.top)\n    box.top=box2.top;\n\n  if (box.right > box2.right)\n    box.right=box2.right;\n\n  if (box.bottom > box2.bottom)\n    box.bottom=box2.bottom;\n\n  return box;\n}\n\nstatic MngBox mng_read_box(MngBox previous_box,char delta_type,\n  unsigned char *p)\n{\n   MngBox\n      box;\n\n  /*\n    Read clipping boundaries from DEFI, CLIP, FRAM, or PAST chunk.\n  */\n  box.left=(long) (((png_uint_32) p[0] << 24) | ((png_uint_32) p[1] << 16) |\n    ((png_uint_32) p[2] << 8) | (png_uint_32) p[3]);\n  box.right=(long) (((png_uint_32) p[4]  << 24) | ((png_uint_32) p[5] << 16) |\n    ((png_uint_32) p[6] << 8) | (png_uint_32) p[7]);\n  box.top=(long) (((png_uint_32) p[8]  << 24) | ((png_uint_32) p[9] << 16) |\n    ((png_uint_32) p[10] << 8) | (png_uint_32) p[11]);\n  box.bottom=(long) (((png_uint_32) p[12] << 24) | ((png_uint_32) p[13] << 16) |\n    ((png_uint_32) p[14] << 8) | (png_uint_32) p[15]);\n  if (delta_type != 0)\n    {\n      box.left+=previous_box.left;\n      box.right+=previous_box.right;\n      box.top+=previous_box.top;\n      box.bottom+=previous_box.bottom;\n    }\n\n  return(box);\n}\n\nstatic MngPair mng_read_pair(MngPair previous_pair,int delta_type,\n  unsigned char *p)\n{\n  MngPair\n    pair;\n\n  /*\n    Read two ssize_t's from CLON, MOVE or PAST chunk\n  */\n  pair.a=(long) (((png_uint_32) p[0] << 24) | ((png_uint_32) p[1] << 16) |\n    ((png_uint_32) p[2] << 8) | (png_uint_32) p[3]);\n  pair.b=(long) (((png_uint_32) p[4] << 24) | ((png_uint_32) p[5] << 16) |\n    ((png_uint_32) p[6] << 8) | (png_uint_32) p[7]);\n  if (delta_type != 0)\n    {\n      pair.a+=previous_pair.a;\n      pair.b+=previous_pair.b;\n    }\n\n  return(pair);\n}\n\nstatic long mng_get_long(unsigned char *p)\n{\n  return ((long) (((png_uint_32) p[0] << 24) | ((png_uint_32) p[1] << 16) |\n    ((png_uint_32) p[2] << 8) | (png_uint_32) p[3]));\n}\n\ntypedef struct _PNGErrorInfo\n{\n  Image\n    *image;\n\n  ExceptionInfo\n    *exception;\n} PNGErrorInfo;\n\nstatic void MagickPNGErrorHandler(png_struct *ping,png_const_charp message)\n{\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  PNGErrorInfo\n    *error_info;\n\n  error_info=(PNGErrorInfo *) png_get_error_ptr(ping);\n  image=error_info->image;\n  exception=error_info->exception;\n\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  libpng-%s error: %s\", png_get_libpng_ver(NULL),message);\n\n  (void) ThrowMagickException(exception,GetMagickModule(),CoderError,message,\n    \"`%s'\",image->filename);\n\n#if (PNG_LIBPNG_VER < 10500)\n  /* A warning about deprecated use of jmpbuf here is unavoidable if you\n   * are building with libpng-1.4.x and can be ignored.\n   */\n  longjmp(ping->jmpbuf,1);\n#else\n  png_longjmp(ping,1);\n#endif\n}\n\nstatic void MagickPNGWarningHandler(png_struct *ping,png_const_charp message)\n{\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  PNGErrorInfo\n    *error_info;\n\n  if (LocaleCompare(message, \"Missing PLTE before tRNS\") == 0)\n    png_error(ping, message);\n\n  error_info=(PNGErrorInfo *) png_get_error_ptr(ping);\n  image=error_info->image;\n  exception=error_info->exception;\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  libpng-%s warning: %s\", png_get_libpng_ver(NULL),message);\n\n  (void) ThrowMagickException(exception,GetMagickModule(),CoderWarning,\n    message,\"`%s'\",image->filename);\n}\n\n#ifdef PNG_USER_MEM_SUPPORTED\n#if PNG_LIBPNG_VER >= 10400\nstatic png_voidp Magick_png_malloc(png_structp png_ptr,png_alloc_size_t size)\n#else\nstatic png_voidp Magick_png_malloc(png_structp png_ptr,png_size_t size)\n#endif\n{\n  (void) png_ptr;\n  return((png_voidp) AcquireMagickMemory((size_t) size));\n}\n\n/*\n  Free a pointer.  It is removed from the list at the same time.\n*/\nstatic png_free_ptr Magick_png_free(png_structp png_ptr,png_voidp ptr)\n{\n  (void) png_ptr;\n  ptr=RelinquishMagickMemory(ptr);\n  return((png_free_ptr) NULL);\n}\n#endif\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic int\nMagick_png_read_raw_profile(png_struct *ping,Image *image,\n   const ImageInfo *image_info, png_textp text,int ii,ExceptionInfo *exception)\n{\n  register ssize_t\n    i;\n\n  register unsigned char\n    *dp;\n\n  register png_charp\n    sp;\n\n  png_uint_32\n    length,\n    nibbles;\n\n  StringInfo\n    *profile;\n\n  const unsigned char\n    unhex[103]={0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                 0,0,0,0,0,0,0,0,0,1, 2,3,4,5,6,7,8,9,0,0,\n                 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,10,11,12,\n                 13,14,15};\n\n  sp=text[ii].text+1;\n  /* look for newline */\n  while (*sp != '\\n')\n     sp++;\n\n  /* look for length */\n  while (*sp == '\\0' || *sp == ' ' || *sp == '\\n')\n     sp++;\n\n  length=(png_uint_32) StringToLong(sp);\n\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      length: %lu\",(unsigned long) length);\n\n  while (*sp != ' ' && *sp != '\\n')\n     sp++;\n\n  /* allocate space */\n  if (length == 0)\n  {\n    png_warning(ping,\"invalid profile length\");\n    return(MagickFalse);\n  }\n\n  profile=BlobToStringInfo((const void *) NULL,length);\n\n  if (profile == (StringInfo *) NULL)\n  {\n    png_warning(ping, \"unable to copy profile\");\n    return(MagickFalse);\n  }\n\n  /* copy profile, skipping white space and column 1 \"=\" signs */\n  dp=GetStringInfoDatum(profile);\n  nibbles=length*2;\n\n  for (i=0; i < (ssize_t) nibbles; i++)\n  {\n    while (*sp < '0' || (*sp > '9' && *sp < 'a') || *sp > 'f')\n    {\n      if (*sp == '\\0')\n        {\n          png_warning(ping, \"ran out of profile data\");\n          profile=DestroyStringInfo(profile);\n          return(MagickFalse);\n        }\n      sp++;\n    }\n\n    if (i%2 == 0)\n      *dp=(unsigned char) (16*unhex[(int) *sp++]);\n\n    else\n      (*dp++)+=unhex[(int) *sp++];\n  }\n  /*\n    We have already read \"Raw profile type.\n  */\n  (void) SetImageProfile(image,&text[ii].key[17],profile,exception);\n  profile=DestroyStringInfo(profile);\n\n  if (image_info->verbose)\n    (void) printf(\" Found a generic profile, type %s\\n\",&text[ii].key[17]);\n\n  return MagickTrue;\n}\n\n#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)\n\nstatic int read_user_chunk_callback(png_struct *ping, png_unknown_chunkp chunk)\n{\n  Image\n    *image;\n\n\n  /* The unknown chunk structure contains the chunk data:\n     png_byte name[5];\n     png_byte *data;\n     png_size_t size;\n\n     Note that libpng has already taken care of the CRC handling.\n\n     Returns one of the following:\n         return(-n);  chunk had an error\n         return(0);  did not recognize\n         return(n);  success\n  */\n\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n     \"    read_user_chunk: found %c%c%c%c chunk\",\n       chunk->name[0],chunk->name[1],chunk->name[2],chunk->name[3]);\n\n  if (chunk->name[0]  == 101 &&\n      (chunk->name[1] ==  88 || chunk->name[1] == 120 ) &&\n      chunk->name[2] ==   73 &&\n      chunk-> name[3] == 102)\n    {\n      /* process eXIf or exIf chunk */\n\n      PNGErrorInfo\n        *error_info;\n\n      StringInfo\n        *profile;\n\n      unsigned char\n        *p;\n\n      png_byte\n        *s;\n\n      size_t\n        i;\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \" recognized eXIf chunk\");\n\n      image=(Image *) png_get_user_chunk_ptr(ping);\n\n      error_info=(PNGErrorInfo *) png_get_error_ptr(ping);\n\n      profile=BlobToStringInfo((const void *) NULL,chunk->size+6);\n\n      if (profile == (StringInfo *) NULL)\n        {\n          (void) ThrowMagickException(error_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n            image->filename);\n          return(-1);\n        }\n      p=GetStringInfoDatum(profile);\n\n      if (*p != 'E')\n        {\n          /* Initialize profile with \"Exif\\0\\0\" if it is not\n             already present by accident\n          */\n          *p++ ='E';\n          *p++ ='x';\n          *p++ ='i';\n          *p++ ='f';\n          *p++ ='\\0';\n          *p++ ='\\0';\n        }\n      else\n        {\n          if (p[1] != 'x' || p[2] != 'i' || p[3] != 'f' ||\n              p[4] != '\\0' || p[5] != '\\0')\n            {\n              /* Chunk is malformed */\n              profile=DestroyStringInfo(profile);\n              return(-1);\n            }\n         }\n\n      /* copy chunk->data to profile */\n      s=chunk->data;\n      for (i=0; i<chunk->size; i++)\n        *p++ = *s++;\n\n      error_info=(PNGErrorInfo *) png_get_error_ptr(ping);\n      (void) SetImageProfile(image,\"exif\",profile,\n        error_info->exception);\n\n      profile=DestroyStringInfo(profile);\n\n      return(1);\n    }\n\n  /* vpAg (deprecated, replaced by caNv) */\n  if (chunk->name[0] == 118 &&\n      chunk->name[1] == 112 &&\n      chunk->name[2] ==  65 &&\n      chunk->name[3] == 103)\n    {\n      /* recognized vpAg */\n\n      if (chunk->size != 9)\n        return(-1); /* Error return */\n\n      if (chunk->data[8] != 0)\n        return(0);  /* ImageMagick requires pixel units */\n\n      image=(Image *) png_get_user_chunk_ptr(ping);\n\n      image->page.width=(size_t) (((png_uint_32) chunk->data[0] << 24) |\n        ((png_uint_32) chunk->data[1] << 16) |\n        ((png_uint_32) chunk->data[2] << 8) |\n        (png_uint_32) chunk->data[3]);\n      image->page.height=(size_t) (((png_uint_32) chunk->data[4] << 24) |\n        ((png_uint_32) chunk->data[5] << 16) |\n        ((png_uint_32) chunk->data[6] << 8) |\n        (png_uint_32) chunk->data[7]);\n\n      return(1);\n    }\n\n  /* caNv */\n  if (chunk->name[0] ==  99 &&\n      chunk->name[1] ==  97 &&\n      chunk->name[2] ==  78 &&\n      chunk->name[3] == 118)\n    {\n      /* recognized caNv */\n\n      if (chunk->size != 16)\n        return(-1); /* Error return */\n\n      image=(Image *) png_get_user_chunk_ptr(ping);\n\n      image->page.width=(size_t) (((png_uint_32) chunk->data[0] << 24) |\n        ((png_uint_32) chunk->data[1] << 16) |\n        ((png_uint_32) chunk->data[2] << 8) | (png_uint_32) chunk->data[3]);\n      image->page.height=(size_t) (((png_uint_32) chunk->data[4] << 24) |\n        ((png_uint_32) chunk->data[5] << 16) |\n        ((png_uint_32) chunk->data[6] << 8) | (png_uint_32) chunk->data[7]);\n      image->page.x=(ssize_t) (((png_uint_32) chunk->data[8] << 24) |\n        ((png_uint_32) chunk->data[9] << 16) |\n        ((png_uint_32) chunk->data[10] << 8) | (png_uint_32) chunk->data[11]);\n      image->page.y=(ssize_t) (((png_uint_32) chunk->data[12] << 24) |\n        ((png_uint_32) chunk->data[13] << 16) |\n        ((png_uint_32) chunk->data[14] << 8) | (png_uint_32) chunk->data[15]);\n\n      return(1);\n    }\n\n  return(0); /* Did not recognize */\n}\n#endif /* PNG_UNKNOWN_CHUNKS_SUPPORTED */\n\n#if defined(PNG_tIME_SUPPORTED)\nstatic void read_tIME_chunk(Image *image,png_struct *ping,png_info *info,\n  ExceptionInfo *exception)\n{\n  png_timep\n    time;\n\n  if (png_get_tIME(ping,info,&time))\n    {\n      char\n        timestamp[21];\n\n      FormatLocaleString(timestamp,21,\"%04d-%02d-%02dT%02d:%02d:%02dZ\",\n        time->year,time->month,time->day,time->hour,time->minute,time->second);\n      SetImageProperty(image,\"png:tIME\",timestamp,exception);\n    }\n}\n#endif\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d O n e P N G I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadOnePNGImage() reads a Portable Network Graphics (PNG) image file\n%  (minus the 8-byte signature)  and returns it.  It allocates the memory\n%  necessary for the new Image structure and returns a pointer to the new\n%  image.\n%\n%  The format of the ReadOnePNGImage method is:\n%\n%      Image *ReadOnePNGImage(MngInfo *mng_info, const ImageInfo *image_info,\n%         ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o mng_info: Specifies a pointer to a MngInfo structure.\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadOnePNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  /* Read one PNG image */\n\n  /* To do: Read the tEXt/Creation Time chunk into the date:create property */\n\n  Image\n    *image;\n\n  char\n    im_vers[32],\n    libpng_runv[32],\n    libpng_vers[32],\n    zlib_runv[32],\n    zlib_vers[32];\n\n  int\n    intent, /* \"PNG Rendering intent\", which is ICC intent + 1 */\n    num_raw_profiles,\n    num_text,\n    num_text_total,\n    num_passes,\n    number_colors,\n    pass,\n    ping_bit_depth,\n    ping_color_type,\n    ping_file_depth,\n    ping_interlace_method,\n    ping_compression_method,\n    ping_filter_method,\n    ping_num_trans,\n    unit_type;\n\n  double\n    file_gamma;\n\n  MagickBooleanType\n    logging,\n    ping_found_cHRM,\n    ping_found_gAMA,\n    ping_found_iCCP,\n    ping_found_sRGB,\n    ping_found_sRGB_cHRM,\n    ping_preserve_iCCP,\n    status;\n\n  MemoryInfo\n    *volatile pixel_info;\n\n  PixelInfo\n    transparent_color;\n\n  PNGErrorInfo\n    error_info;\n\n  png_bytep\n     ping_trans_alpha;\n\n  png_color_16p\n     ping_background,\n     ping_trans_color;\n\n  png_info\n    *end_info,\n    *ping_info;\n\n  png_struct\n    *ping;\n\n  png_textp\n    text;\n\n  png_uint_32\n    ping_height,\n    ping_width,\n    x_resolution,\n    y_resolution;\n\n  QuantumInfo\n    *volatile quantum_info;\n\n  ssize_t\n    ping_rowbytes,\n    y;\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  size_t\n    length,\n    row_offset;\n\n  ssize_t\n    j;\n\n  unsigned char\n    *ping_pixels;\n\n#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED\n  png_byte unused_chunks[]=\n  {\n    104,  73,  83,  84, (png_byte) '\\0',   /* hIST */\n    105,  84,  88, 116, (png_byte) '\\0',   /* iTXt */\n    112,  67,  65,  76, (png_byte) '\\0',   /* pCAL */\n    115,  67,  65,  76, (png_byte) '\\0',   /* sCAL */\n    115,  80,  76,  84, (png_byte) '\\0',   /* sPLT */\n#if !defined(PNG_tIME_SUPPORTED)\n    116,  73,  77,  69, (png_byte) '\\0',   /* tIME */\n#endif\n#ifdef PNG_APNG_SUPPORTED /* libpng was built with APNG patch; */\n                          /* ignore the APNG chunks */\n     97,  99,  84,  76, (png_byte) '\\0',   /* acTL */\n    102,  99,  84,  76, (png_byte) '\\0',   /* fcTL */\n    102, 100,  65,  84, (png_byte) '\\0',   /* fdAT */\n#endif\n  };\n#endif\n\n  /* Define these outside of the following \"if logging()\" block so they will\n   * show in debuggers.\n   */\n  *im_vers='\\0';\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibVersionText,32);\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibAddendum,32);\n\n  *libpng_vers='\\0';\n  (void) ConcatenateMagickString(libpng_vers,\n         PNG_LIBPNG_VER_STRING,32);\n  *libpng_runv='\\0';\n  (void) ConcatenateMagickString(libpng_runv,\n         png_get_libpng_ver(NULL),32);\n\n  *zlib_vers='\\0';\n  (void) ConcatenateMagickString(zlib_vers,\n         ZLIB_VERSION,32);\n  *zlib_runv='\\0';\n  (void) ConcatenateMagickString(zlib_runv,\n         zlib_version,32);\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"  Enter ReadOnePNGImage()\\n\"\n       \"    IM version     = %s\\n\"\n       \"    Libpng version = %s\",\n       im_vers, libpng_vers);\n\n  if (logging != MagickFalse)\n  {\n    if (LocaleCompare(libpng_vers,libpng_runv) != 0)\n    {\n   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n        libpng_runv);\n    }\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    Zlib version   = %s\",\n        zlib_vers);\n    if (LocaleCompare(zlib_vers,zlib_runv) != 0)\n    {\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n        zlib_runv);\n    }\n  }\n\n#if (PNG_LIBPNG_VER < 10200)\n  if (image_info->verbose)\n    printf(\"Your PNG library (libpng-%s) is rather old.\\n\",\n       PNG_LIBPNG_VER_STRING);\n#endif\n\n#if (PNG_LIBPNG_VER >= 10400)\n#  ifndef  PNG_TRANSFORM_GRAY_TO_RGB    /* Added at libpng-1.4.0beta67 */\n  if (image_info->verbose)\n    {\n      printf(\"Your PNG library (libpng-%s) is an old beta version.\\n\",\n           PNG_LIBPNG_VER_STRING);\n      printf(\"Please update it.\\n\");\n    }\n#  endif\n#endif\n\n\n  quantum_info = (QuantumInfo *) NULL;\n  image=mng_info->image;\n\n  if (logging != MagickFalse)\n  {\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"    Before reading:\\n\"\n       \"      image->alpha_trait=%d\"\n       \"      image->rendering_intent=%d\\n\"\n       \"      image->colorspace=%d\\n\"\n       \"      image->gamma=%f\",\n       (int) image->alpha_trait, (int) image->rendering_intent,\n       (int) image->colorspace, image->gamma);\n  }\n  intent=\n    Magick_RenderingIntent_to_PNG_RenderingIntent(image->rendering_intent);\n\n  /* Set to an out-of-range color unless tRNS chunk is present */\n  transparent_color.red=65537;\n  transparent_color.green=65537;\n  transparent_color.blue=65537;\n  transparent_color.alpha=65537;\n\n  number_colors=0;\n  num_text = 0;\n  num_text_total = 0;\n  num_raw_profiles = 0;\n\n  ping_found_cHRM = MagickFalse;\n  ping_found_gAMA = MagickFalse;\n  ping_found_iCCP = MagickFalse;\n  ping_found_sRGB = MagickFalse;\n  ping_found_sRGB_cHRM = MagickFalse;\n  ping_preserve_iCCP = MagickFalse;\n\n\n  /*\n    Allocate the PNG structures\n  */\n#ifdef PNG_USER_MEM_SUPPORTED\n error_info.image=image;\n error_info.exception=exception;\n ping=png_create_read_struct_2(PNG_LIBPNG_VER_STRING,&error_info,\n   MagickPNGErrorHandler,MagickPNGWarningHandler, NULL,\n   (png_malloc_ptr) Magick_png_malloc,(png_free_ptr) Magick_png_free);\n#else\n  ping=png_create_read_struct(PNG_LIBPNG_VER_STRING,&error_info,\n    MagickPNGErrorHandler,MagickPNGWarningHandler);\n#endif\n  if (ping == (png_struct *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  ping_info=png_create_info_struct(ping);\n\n  if (ping_info == (png_info *) NULL)\n    {\n      png_destroy_read_struct(&ping,(png_info **) NULL,(png_info **) NULL);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n\n  end_info=png_create_info_struct(ping);\n\n  if (end_info == (png_info *) NULL)\n    {\n      png_destroy_read_struct(&ping,&ping_info,(png_info **) NULL);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n\n  pixel_info=(MemoryInfo *) NULL;\n\n  if (setjmp(png_jmpbuf(ping)))\n    {\n      /*\n        PNG image is corrupt.\n      */\n      png_destroy_read_struct(&ping,&ping_info,&end_info);\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n      UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n      if (pixel_info != (MemoryInfo *) NULL)\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n\n      if (quantum_info != (QuantumInfo *) NULL)\n        quantum_info=DestroyQuantumInfo(quantum_info);\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  exit ReadOnePNGImage() with error.\");\n\n      return(GetFirstImageInList(image));\n    }\n\n  /* {  For navigation to end of SETJMP-protected block.  Within this\n   *    block, use png_error() instead of Throwing an Exception, to ensure\n   *    that libpng is able to clean up, and that the semaphore is unlocked.\n   */\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  LockSemaphoreInfo(ping_semaphore);\n#endif\n\n#ifdef PNG_BENIGN_ERRORS_SUPPORTED\n  /* Allow benign errors */\n  png_set_benign_errors(ping, 1);\n#endif\n\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n  /* Reject images with too many rows or columns */\n  png_set_user_limits(ping,\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(WidthResource)),\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(HeightResource)));\n#endif /* PNG_SET_USER_LIMITS_SUPPORTED */\n\n  /*\n    Prepare PNG for reading.\n  */\n\n  mng_info->image_found++;\n  png_set_sig_bytes(ping,8);\n\n  if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n    {\n#if defined(PNG_MNG_FEATURES_SUPPORTED)\n      (void) png_permit_mng_features(ping,PNG_ALL_MNG_FEATURES);\n      png_set_read_fn(ping,image,png_get_data);\n#else\n#if defined(PNG_READ_EMPTY_PLTE_SUPPORTED)\n      png_permit_empty_plte(ping,MagickTrue);\n      png_set_read_fn(ping,image,png_get_data);\n#else\n      mng_info->image=image;\n      mng_info->bytes_in_read_buffer=0;\n      mng_info->found_empty_plte=MagickFalse;\n      mng_info->have_saved_bkgd_index=MagickFalse;\n      png_set_read_fn(ping,mng_info,mng_get_data);\n#endif\n#endif\n    }\n\n  else\n    png_set_read_fn(ping,image,png_get_data);\n\n  {\n    const char\n      *value;\n\n    value=GetImageOption(image_info,\"profile:skip\");\n\n    if (IsOptionMember(\"ICC\",value) == MagickFalse)\n    {\n\n       value=GetImageOption(image_info,\"png:preserve-iCCP\");\n\n       if (value == NULL)\n          value=GetImageArtifact(image,\"png:preserve-iCCP\");\n\n       if (value != NULL)\n          ping_preserve_iCCP=MagickTrue;\n\n#if defined(PNG_SKIP_sRGB_CHECK_PROFILE) && defined(PNG_SET_OPTION_SUPPORTED)\n       /* Don't let libpng check for ICC/sRGB profile because we're going\n        * to do that anyway.  This feature was added at libpng-1.6.12.\n        * If logging, go ahead and check and issue a warning as appropriate.\n        */\n       if (logging == MagickFalse)\n          png_set_option(ping, PNG_SKIP_sRGB_CHECK_PROFILE, PNG_OPTION_ON);\n#endif\n    }\n#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)\n    else\n    {\n       png_set_keep_unknown_chunks(ping, 1, (png_bytep) mng_iCCP, 1);\n    }\n#endif\n  }\n#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)\n  /* Ignore unused chunks and all unknown chunks except for eXIf,\n     caNv, and vpAg */\n# if PNG_LIBPNG_VER < 10700 /* Avoid libpng16 warning */\n  png_set_keep_unknown_chunks(ping, 2, NULL, 0);\n# else\n  png_set_keep_unknown_chunks(ping, 1, NULL, 0);\n# endif\n  png_set_keep_unknown_chunks(ping, 2, (png_bytep) mng_eXIf, 1);\n  png_set_keep_unknown_chunks(ping, 2, (png_bytep) mng_caNv, 1);\n  png_set_keep_unknown_chunks(ping, 2, (png_bytep) mng_vpAg, 1);\n  png_set_keep_unknown_chunks(ping, 1, unused_chunks,\n     (int)sizeof(unused_chunks)/5);\n  /* Callback for other unknown chunks */\n  png_set_read_user_chunk_fn(ping, image, read_user_chunk_callback);\n#endif\n\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n#  if (PNG_LIBPNG_VER >= 10400)\n    /* Limit the size of the chunk storage cache used for sPLT, text,\n     * and unknown chunks.\n     */\n    png_set_chunk_cache_max(ping, 32767);\n#  endif\n#endif\n\n#ifdef PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED\n    /* Disable new libpng-1.5.10 feature */\n    png_set_check_for_invalid_index (ping, 0);\n#endif\n\n#if (PNG_LIBPNG_VER < 10400)\n#  if defined(PNG_USE_PNGGCCRD) && defined(PNG_ASSEMBLER_CODE_SUPPORTED) && \\\n   (PNG_LIBPNG_VER >= 10200) && (PNG_LIBPNG_VER < 10220) && defined(__i386__)\n  /* Disable thread-unsafe features of pnggccrd */\n  if (png_access_version_number() >= 10200)\n  {\n    png_uint_32 mmx_disable_mask=0;\n    png_uint_32 asm_flags;\n\n    mmx_disable_mask |= ( PNG_ASM_FLAG_MMX_READ_COMBINE_ROW  \\\n                        | PNG_ASM_FLAG_MMX_READ_FILTER_SUB   \\\n                        | PNG_ASM_FLAG_MMX_READ_FILTER_AVG   \\\n                        | PNG_ASM_FLAG_MMX_READ_FILTER_PAETH );\n    asm_flags=png_get_asm_flags(ping);\n    png_set_asm_flags(ping, asm_flags & ~mmx_disable_mask);\n  }\n#  endif\n#endif\n\n  png_read_info(ping,ping_info);\n\n  png_get_IHDR(ping,ping_info,&ping_width,&ping_height,\n               &ping_bit_depth,&ping_color_type,\n               &ping_interlace_method,&ping_compression_method,\n               &ping_filter_method);\n\n  ping_file_depth = ping_bit_depth;\n\n  /* Swap bytes if requested */\n  if (ping_file_depth == 16)\n  {\n     const char\n       *value;\n\n     value=GetImageOption(image_info,\"png:swap-bytes\");\n\n     if (value == NULL)\n        value=GetImageArtifact(image,\"png:swap-bytes\");\n\n     if (value != NULL)\n        png_set_swap(ping);\n  }\n\n  /* Save bit-depth and color-type in case we later want to write a PNG00 */\n  {\n      char\n        msg[MagickPathExtent];\n\n      (void) FormatLocaleString(msg,MagickPathExtent,\"%d\",\n         (int) ping_color_type);\n      (void) SetImageProperty(image,\"png:IHDR.color-type-orig\",msg,exception);\n\n      (void) FormatLocaleString(msg,MagickPathExtent,\"%d\",\n         (int) ping_bit_depth);\n      (void) SetImageProperty(image,\"png:IHDR.bit-depth-orig\",msg,exception);\n  }\n\n  (void) png_get_tRNS(ping, ping_info, &ping_trans_alpha, &ping_num_trans,\n                      &ping_trans_color);\n\n  (void) png_get_bKGD(ping, ping_info, &ping_background);\n\n  if (ping_bit_depth < 8)\n    {\n       png_set_packing(ping);\n       ping_bit_depth = 8;\n    }\n\n  image->depth=ping_bit_depth;\n  image->depth=GetImageQuantumDepth(image,MagickFalse);\n  image->interlace=ping_interlace_method != 0 ? PNGInterlace : NoInterlace;\n\n  if (((int) ping_color_type == PNG_COLOR_TYPE_GRAY) ||\n      ((int) ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA))\n    {\n      image->rendering_intent=UndefinedIntent;\n      intent=Magick_RenderingIntent_to_PNG_RenderingIntent(UndefinedIntent);\n      (void) ResetMagickMemory(&image->chromaticity,0,\n        sizeof(image->chromaticity));\n    }\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG width: %.20g, height: %.20g\\n\"\n        \"    PNG color_type: %d, bit_depth: %d\\n\"\n        \"    PNG compression_method: %d\\n\"\n        \"    PNG interlace_method: %d, filter_method: %d\",\n        (double) ping_width, (double) ping_height,\n        ping_color_type, ping_bit_depth,\n        ping_compression_method,\n        ping_interlace_method,ping_filter_method);\n\n    }\n\n  if (png_get_valid(ping,ping_info, PNG_INFO_iCCP))\n    {\n      ping_found_iCCP=MagickTrue;\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Found PNG iCCP chunk.\");\n    }\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_gAMA))\n    {\n      ping_found_gAMA=MagickTrue;\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Found PNG gAMA chunk.\");\n    }\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_cHRM))\n    {\n      ping_found_cHRM=MagickTrue;\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Found PNG cHRM chunk.\");\n    }\n\n  if (ping_found_iCCP != MagickTrue && png_get_valid(ping,ping_info,\n      PNG_INFO_sRGB))\n    {\n      ping_found_sRGB=MagickTrue;\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Found PNG sRGB chunk.\");\n    }\n\n#ifdef PNG_READ_iCCP_SUPPORTED\n    if (ping_found_iCCP !=MagickTrue &&\n      ping_found_sRGB != MagickTrue &&\n      png_get_valid(ping,ping_info, PNG_INFO_iCCP))\n    {\n      ping_found_iCCP=MagickTrue;\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Found PNG iCCP chunk.\");\n    }\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_iCCP))\n    {\n      int\n        compression;\n\n#if (PNG_LIBPNG_VER < 10500)\n      png_charp\n        info;\n#else\n      png_bytep\n        info;\n#endif\n\n      png_charp\n        name;\n\n      png_uint_32\n        profile_length;\n\n      (void) png_get_iCCP(ping,ping_info,&name,(int *) &compression,&info,\n        &profile_length);\n\n      if (profile_length != 0)\n        {\n          StringInfo\n            *profile;\n\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Reading PNG iCCP chunk.\");\n\n          profile=BlobToStringInfo(info,profile_length);\n\n          if (profile == (StringInfo *) NULL)\n          {\n            png_warning(ping, \"ICC profile is NULL\");\n            profile=DestroyStringInfo(profile);\n          }\n          else\n          {\n            if (ping_preserve_iCCP == MagickFalse)\n            {\n                 int\n                   icheck,\n                   got_crc=0;\n\n\n                 png_uint_32\n                   length,\n                   profile_crc=0;\n\n                 unsigned char\n                   *data;\n\n                 length=(png_uint_32) GetStringInfoLength(profile);\n\n                 for (icheck=0; sRGB_info[icheck].len > 0; icheck++)\n                 {\n                   if (length == sRGB_info[icheck].len)\n                   {\n                     if (got_crc == 0)\n                     {\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Got a %lu-byte ICC profile (potentially sRGB)\",\n                         (unsigned long) length);\n\n                       data=GetStringInfoDatum(profile);\n                       profile_crc=crc32(0,data,length);\n\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"      with crc=%8x\",(unsigned int) profile_crc);\n                       got_crc++;\n                     }\n\n                     if (profile_crc == sRGB_info[icheck].crc)\n                     {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"      It is sRGB with rendering intent = %s\",\n                        Magick_RenderingIntentString_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent));\n                        if (image->rendering_intent==UndefinedIntent)\n                        {\n                          image->rendering_intent=\n                          Magick_RenderingIntent_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent);\n                        }\n                        break;\n                     }\n                   }\n                 }\n                 if (sRGB_info[icheck].len == 0)\n                 {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"    Got %lu-byte ICC profile not recognized as sRGB\",\n                        (unsigned long) length);\n                    (void) SetImageProfile(image,\"icc\",profile,exception);\n                 }\n            }\n            else /* Preserve-iCCP */\n            {\n                    (void) SetImageProfile(image,\"icc\",profile,exception);\n            }\n\n            profile=DestroyStringInfo(profile);\n          }\n      }\n    }\n#endif\n\n#if defined(PNG_READ_sRGB_SUPPORTED)\n  {\n    if (ping_found_iCCP==MagickFalse && png_get_valid(ping,ping_info,\n        PNG_INFO_sRGB))\n    {\n      if (png_get_sRGB(ping,ping_info,&intent))\n      {\n        if (image->rendering_intent == UndefinedIntent)\n          image->rendering_intent=\n             Magick_RenderingIntent_from_PNG_RenderingIntent (intent);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Reading PNG sRGB chunk: rendering_intent: %d\",intent);\n      }\n    }\n\n    else if (mng_info->have_global_srgb)\n      {\n        if (image->rendering_intent == UndefinedIntent)\n          image->rendering_intent=\n            Magick_RenderingIntent_from_PNG_RenderingIntent\n            (mng_info->global_srgb_intent);\n      }\n  }\n#endif\n\n\n  {\n     if (!png_get_gAMA(ping,ping_info,&file_gamma))\n       if (mng_info->have_global_gama)\n         png_set_gAMA(ping,ping_info,mng_info->global_gamma);\n\n     if (png_get_gAMA(ping,ping_info,&file_gamma))\n       {\n         image->gamma=(float) file_gamma;\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Reading PNG gAMA chunk: gamma: %f\",file_gamma);\n       }\n  }\n\n  if (!png_get_valid(ping,ping_info,PNG_INFO_cHRM))\n    {\n      if (mng_info->have_global_chrm != MagickFalse)\n        {\n          (void) png_set_cHRM(ping,ping_info,\n            mng_info->global_chrm.white_point.x,\n            mng_info->global_chrm.white_point.y,\n            mng_info->global_chrm.red_primary.x,\n            mng_info->global_chrm.red_primary.y,\n            mng_info->global_chrm.green_primary.x,\n            mng_info->global_chrm.green_primary.y,\n            mng_info->global_chrm.blue_primary.x,\n            mng_info->global_chrm.blue_primary.y);\n        }\n    }\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_cHRM))\n    {\n      (void) png_get_cHRM(ping,ping_info,\n        &image->chromaticity.white_point.x,\n        &image->chromaticity.white_point.y,\n        &image->chromaticity.red_primary.x,\n        &image->chromaticity.red_primary.y,\n        &image->chromaticity.green_primary.x,\n        &image->chromaticity.green_primary.y,\n        &image->chromaticity.blue_primary.x,\n        &image->chromaticity.blue_primary.y);\n\n       ping_found_cHRM=MagickTrue;\n\n       if (image->chromaticity.red_primary.x>0.6399f &&\n           image->chromaticity.red_primary.x<0.6401f &&\n           image->chromaticity.red_primary.y>0.3299f &&\n           image->chromaticity.red_primary.y<0.3301f &&\n           image->chromaticity.green_primary.x>0.2999f &&\n           image->chromaticity.green_primary.x<0.3001f &&\n           image->chromaticity.green_primary.y>0.5999f &&\n           image->chromaticity.green_primary.y<0.6001f &&\n           image->chromaticity.blue_primary.x>0.1499f &&\n           image->chromaticity.blue_primary.x<0.1501f &&\n           image->chromaticity.blue_primary.y>0.0599f &&\n           image->chromaticity.blue_primary.y<0.0601f &&\n           image->chromaticity.white_point.x>0.3126f &&\n           image->chromaticity.white_point.x<0.3128f &&\n           image->chromaticity.white_point.y>0.3289f &&\n           image->chromaticity.white_point.y<0.3291f)\n          ping_found_sRGB_cHRM=MagickTrue;\n    }\n\n  if (image->rendering_intent != UndefinedIntent)\n    {\n      if (ping_found_sRGB != MagickTrue &&\n          (ping_found_gAMA != MagickTrue ||\n          (image->gamma > .45 && image->gamma < .46)) &&\n          (ping_found_cHRM != MagickTrue ||\n          ping_found_sRGB_cHRM != MagickFalse) &&\n          ping_found_iCCP != MagickTrue)\n      {\n         png_set_sRGB(ping,ping_info,\n            Magick_RenderingIntent_to_PNG_RenderingIntent\n            (image->rendering_intent));\n         file_gamma=1.000f/2.200f;\n         ping_found_sRGB=MagickTrue;\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"    Setting sRGB as if in input\");\n      }\n    }\n\n#if defined(PNG_oFFs_SUPPORTED)\n  if (png_get_valid(ping,ping_info,PNG_INFO_oFFs))\n    {\n      image->page.x=(ssize_t) png_get_x_offset_pixels(ping, ping_info);\n      image->page.y=(ssize_t) png_get_y_offset_pixels(ping, ping_info);\n\n      if (logging != MagickFalse)\n        if (image->page.x || image->page.y)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Reading PNG oFFs chunk: x: %.20g, y: %.20g.\",(double)\n            image->page.x,(double) image->page.y);\n    }\n#endif\n#if defined(PNG_pHYs_SUPPORTED)\n  if (!png_get_valid(ping,ping_info,PNG_INFO_pHYs))\n    {\n      if (mng_info->have_global_phys)\n        {\n          png_set_pHYs(ping,ping_info,\n                       mng_info->global_x_pixels_per_unit,\n                       mng_info->global_y_pixels_per_unit,\n                       mng_info->global_phys_unit_type);\n        }\n    }\n\n  x_resolution=0;\n  y_resolution=0;\n  unit_type=0;\n  if (png_get_valid(ping,ping_info,PNG_INFO_pHYs))\n    {\n      /*\n        Set image resolution.\n      */\n      (void) png_get_pHYs(ping,ping_info,&x_resolution,&y_resolution,\n        &unit_type);\n      image->resolution.x=(double) x_resolution;\n      image->resolution.y=(double) y_resolution;\n\n      if (unit_type == PNG_RESOLUTION_METER)\n        {\n          image->units=PixelsPerCentimeterResolution;\n          image->resolution.x=(double) x_resolution/100.0;\n          image->resolution.y=(double) y_resolution/100.0;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Reading PNG pHYs chunk: xres: %.20g, yres: %.20g, units: %d.\",\n          (double) x_resolution,(double) y_resolution,unit_type);\n    }\n#endif\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_PLTE))\n    {\n      png_colorp\n        palette;\n\n      (void) png_get_PLTE(ping,ping_info,&palette,&number_colors);\n\n      if ((number_colors == 0) &&\n          ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE))\n        {\n          if (mng_info->global_plte_length)\n            {\n              png_set_PLTE(ping,ping_info,mng_info->global_plte,\n                (int) mng_info->global_plte_length);\n\n              if (!png_get_valid(ping,ping_info,PNG_INFO_tRNS))\n              {\n                if (mng_info->global_trns_length)\n                  {\n                    png_warning(ping,\n                      \"global tRNS has more entries than global PLTE\");\n                  }\n                else\n                  {\n                     png_set_tRNS(ping,ping_info,mng_info->global_trns,\n                       (int) mng_info->global_trns_length,NULL);\n                  }\n               }\n#ifdef PNG_READ_bKGD_SUPPORTED\n              if (\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n                   mng_info->have_saved_bkgd_index ||\n#endif\n                   png_get_valid(ping,ping_info,PNG_INFO_bKGD))\n                    {\n                      png_color_16\n                         background;\n\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n                      if (mng_info->have_saved_bkgd_index)\n                        background.index=mng_info->saved_bkgd_index;\n#endif\n                      if (png_get_valid(ping, ping_info, PNG_INFO_bKGD))\n                        background.index=ping_background->index;\n\n                      background.red=(png_uint_16)\n                        mng_info->global_plte[background.index].red;\n\n                      background.green=(png_uint_16)\n                        mng_info->global_plte[background.index].green;\n\n                      background.blue=(png_uint_16)\n                        mng_info->global_plte[background.index].blue;\n\n                      background.gray=(png_uint_16)\n                        mng_info->global_plte[background.index].green;\n\n                      png_set_bKGD(ping,ping_info,&background);\n                    }\n#endif\n                }\n              else\n                png_error(ping,\"No global PLTE in file\");\n            }\n        }\n\n#ifdef PNG_READ_bKGD_SUPPORTED\n  if (mng_info->have_global_bkgd &&\n          (!png_get_valid(ping,ping_info,PNG_INFO_bKGD)))\n      image->background_color=mng_info->mng_global_bkgd;\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_bKGD))\n    {\n      unsigned int\n        bkgd_scale;\n\n      /* Set image background color.\n       * Scale background components to 16-bit, then scale\n       * to quantum depth\n       */\n\n        bkgd_scale = 1;\n\n        if (ping_file_depth == 1)\n           bkgd_scale = 255;\n\n        else if (ping_file_depth == 2)\n           bkgd_scale = 85;\n\n        else if (ping_file_depth == 4)\n           bkgd_scale = 17;\n\n        if (ping_file_depth <= 8)\n           bkgd_scale *= 257;\n\n        ping_background->red *= bkgd_scale;\n        ping_background->green *= bkgd_scale;\n        ping_background->blue *= bkgd_scale;\n\n        if (logging != MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"    Reading PNG bKGD chunk, raw ping_background=(%d,%d,%d)\\n\"\n                 \"    bkgd_scale=%d.  ping_background=(%d,%d,%d)\",\n                 ping_background->red,ping_background->green,\n                 ping_background->blue,\n                 bkgd_scale,ping_background->red,\n                 ping_background->green,ping_background->blue);\n          }\n\n        image->background_color.red=\n            ScaleShortToQuantum(ping_background->red);\n\n        image->background_color.green=\n            ScaleShortToQuantum(ping_background->green);\n\n        image->background_color.blue=\n          ScaleShortToQuantum(ping_background->blue);\n\n        image->background_color.alpha=OpaqueAlpha;\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    image->background_color=(%.20g,%.20g,%.20g).\",\n            (double) image->background_color.red,\n            (double) image->background_color.green,\n            (double) image->background_color.blue);\n    }\n#endif /* PNG_READ_bKGD_SUPPORTED */\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_tRNS))\n    {\n      /*\n        Image has a tRNS chunk.\n      */\n      int\n        max_sample;\n\n      size_t\n        one = 1;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Reading PNG tRNS chunk.\");\n\n      max_sample = (int) ((one << ping_file_depth) - 1);\n\n      if ((ping_color_type == PNG_COLOR_TYPE_GRAY &&\n          (int)ping_trans_color->gray > max_sample) ||\n          (ping_color_type == PNG_COLOR_TYPE_RGB &&\n          ((int)ping_trans_color->red > max_sample ||\n          (int)ping_trans_color->green > max_sample ||\n          (int)ping_trans_color->blue > max_sample)))\n        {\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Ignoring PNG tRNS chunk with out-of-range sample.\");\n          png_free_data(ping, ping_info, PNG_FREE_TRNS, 0);\n          png_set_invalid(ping,ping_info,PNG_INFO_tRNS);\n          image->alpha_trait=UndefinedPixelTrait;\n        }\n      else\n        {\n          int\n            scale_to_short;\n\n          scale_to_short = 65535L/((1UL << ping_file_depth)-1);\n\n          /* Scale transparent_color to short */\n          transparent_color.red= scale_to_short*ping_trans_color->red;\n          transparent_color.green= scale_to_short*ping_trans_color->green;\n          transparent_color.blue= scale_to_short*ping_trans_color->blue;\n          transparent_color.alpha= scale_to_short*ping_trans_color->gray;\n\n          if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n            {\n              if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Raw tRNS graylevel = %d, scaled graylevel = %d.\",\n                  (int) ping_trans_color->gray,(int) transparent_color.alpha);\n\n              }\n              transparent_color.red=transparent_color.alpha;\n              transparent_color.green=transparent_color.alpha;\n              transparent_color.blue=transparent_color.alpha;\n            }\n        }\n    }\n#if defined(PNG_READ_sBIT_SUPPORTED)\n  if (mng_info->have_global_sbit)\n    {\n      if (!png_get_valid(ping,ping_info,PNG_INFO_sBIT))\n        png_set_sBIT(ping,ping_info,&mng_info->global_sbit);\n    }\n#endif\n  num_passes=png_set_interlace_handling(ping);\n\n  png_read_update_info(ping,ping_info);\n\n  ping_rowbytes=png_get_rowbytes(ping,ping_info);\n\n  /*\n    Initialize image structure.\n  */\n  mng_info->image_box.left=0;\n  mng_info->image_box.right=(ssize_t) ping_width;\n  mng_info->image_box.top=0;\n  mng_info->image_box.bottom=(ssize_t) ping_height;\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=ping_width;\n      mng_info->mng_height=ping_height;\n      mng_info->frame=mng_info->image_box;\n      mng_info->clip=mng_info->image_box;\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  image->compression=ZipCompression;\n  image->columns=ping_width;\n  image->rows=ping_height;\n\n  if (((int) ping_color_type == PNG_COLOR_TYPE_GRAY) ||\n      ((int) ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA))\n    {\n      double\n        image_gamma = image->gamma;\n\n      (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"    image->gamma=%f\",(float) image_gamma);\n\n      if (image_gamma > 0.75)\n        {\n          /* Set image->rendering_intent to Undefined,\n           * image->colorspace to GRAY, and reset image->chromaticity.\n           */\n          image->intensity = Rec709LuminancePixelIntensityMethod;\n          SetImageColorspace(image,GRAYColorspace,exception);\n        }\n      else\n        {\n          RenderingIntent\n            save_rendering_intent = image->rendering_intent;\n          ChromaticityInfo\n            save_chromaticity = image->chromaticity;\n\n          SetImageColorspace(image,GRAYColorspace,exception);\n          image->rendering_intent = save_rendering_intent;\n          image->chromaticity = save_chromaticity;\n        }\n\n      image->gamma = image_gamma;\n    }\n\n  (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    image->colorspace=%d\",(int) image->colorspace);\n\n  if (((int) ping_color_type == PNG_COLOR_TYPE_PALETTE) ||\n      ((int) ping_bit_depth < 16 &&\n      (int) ping_color_type == PNG_COLOR_TYPE_GRAY))\n    {\n      size_t\n        one;\n\n      image->storage_class=PseudoClass;\n      one=1;\n      image->colors=one << ping_file_depth;\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n      if (image->colors > 256)\n        image->colors=256;\n#else\n      if (image->colors > 65536L)\n        image->colors=65536L;\n#endif\n      if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        {\n          png_colorp\n            palette;\n\n          (void) png_get_PLTE(ping,ping_info,&palette,&number_colors);\n          image->colors=(size_t) number_colors;\n\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Reading PNG PLTE chunk: number_colors: %d.\",number_colors);\n        }\n    }\n\n  if (image->storage_class == PseudoClass)\n    {\n      /*\n        Initialize image colormap.\n      */\n      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n        png_error(ping,\"Memory allocation failed\");\n\n      if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        {\n          png_colorp\n            palette;\n\n          (void) png_get_PLTE(ping,ping_info,&palette,&number_colors);\n\n          for (i=0; i < (ssize_t) number_colors; i++)\n          {\n            image->colormap[i].red=ScaleCharToQuantum(palette[i].red);\n            image->colormap[i].green=ScaleCharToQuantum(palette[i].green);\n            image->colormap[i].blue=ScaleCharToQuantum(palette[i].blue);\n          }\n\n          for ( ; i < (ssize_t) image->colors; i++)\n          {\n            image->colormap[i].red=0;\n            image->colormap[i].green=0;\n            image->colormap[i].blue=0;\n          }\n        }\n\n      else\n        {\n          Quantum\n            scale;\n\n          scale = (Quantum) (65535.0/((1UL << ping_file_depth)-1.0));\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n          scale = ScaleShortToQuantum(scale);\n#endif\n\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            image->colormap[i].red=(Quantum) (i*scale);\n            image->colormap[i].green=(Quantum) (i*scale);\n            image->colormap[i].blue=(Quantum) (i*scale);\n          }\n       }\n    }\n\n   /* Set some properties for reporting by \"identify\" */\n    {\n      char\n        msg[MagickPathExtent];\n\n     /* encode ping_width, ping_height, ping_file_depth, ping_color_type,\n        ping_interlace_method in value */\n\n     (void) FormatLocaleString(msg,MagickPathExtent,\n         \"%d, %d\",(int) ping_width, (int) ping_height);\n     (void) SetImageProperty(image,\"png:IHDR.width,height\",msg,exception);\n\n     (void) FormatLocaleString(msg,MagickPathExtent,\"%d\",\n        (int) ping_file_depth);\n     (void) SetImageProperty(image,\"png:IHDR.bit_depth\",msg,exception);\n\n     (void) FormatLocaleString(msg,MagickPathExtent,\"%d (%s)\",\n         (int) ping_color_type,\n         Magick_ColorType_from_PNG_ColorType((int)ping_color_type));\n     (void) SetImageProperty(image,\"png:IHDR.color_type\",msg,exception);\n\n     if (ping_interlace_method == 0)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\"%d (Not interlaced)\",\n            (int) ping_interlace_method);\n       }\n     else if (ping_interlace_method == 1)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\"%d (Adam7 method)\",\n            (int) ping_interlace_method);\n       }\n     else\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\"%d (Unknown method)\",\n            (int) ping_interlace_method);\n       }\n       (void) SetImageProperty(image,\"png:IHDR.interlace_method\",\n         msg,exception);\n\n     if (number_colors != 0)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\"%d\",\n            (int) number_colors);\n         (void) SetImageProperty(image,\"png:PLTE.number_colors\",msg,\n            exception);\n       }\n   }\n#if defined(PNG_tIME_SUPPORTED)\n   read_tIME_chunk(image,ping,ping_info,exception);\n#endif\n\n\n  /*\n    Read image scanlines.\n  */\n  if (image->delay != 0)\n    mng_info->scenes_found++;\n\n  if ((mng_info->mng_type == 0 && (image->ping != MagickFalse)) || (\n      (image_info->number_scenes != 0) && (mng_info->scenes_found > (ssize_t)\n      (image_info->first_scene+image_info->number_scenes))))\n    {\n      /* This happens later in non-ping decodes */\n      if (png_get_valid(ping,ping_info,PNG_INFO_tRNS))\n        image->storage_class=DirectClass;\n      image->alpha_trait=\n        (((int) ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA) ||\n         ((int) ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA) ||\n         (png_get_valid(ping,ping_info,PNG_INFO_tRNS))) ?\n        BlendPixelTrait : UndefinedPixelTrait;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Skipping PNG image data for scene %.20g\",(double)\n          mng_info->scenes_found-1);\n      png_destroy_read_struct(&ping,&ping_info,&end_info);\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n      UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  exit ReadOnePNGImage().\");\n\n      return(image);\n    }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading PNG IDAT chunk(s)\");\n\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (num_passes > 1)\n    pixel_info=AcquireVirtualMemory(image->rows,ping_rowbytes*\n      sizeof(*ping_pixels));\n  else\n    pixel_info=AcquireVirtualMemory(ping_rowbytes,sizeof(*ping_pixels));\n\n  if (pixel_info == (MemoryInfo *) NULL)\n    png_error(ping,\"Memory allocation failed\");\n  ping_pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Converting PNG pixels to pixel packets\");\n  /*\n    Convert PNG pixels to pixel packets.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n\n  if (quantum_info == (QuantumInfo *) NULL)\n     png_error(ping,\"Failed to allocate quantum_info\");\n\n  (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n\n  {\n\n   MagickBooleanType\n     found_transparent_pixel;\n\n  found_transparent_pixel=MagickFalse;\n\n  if (image->storage_class == DirectClass)\n    {\n      for (pass=0; pass < num_passes; pass++)\n      {\n        /*\n          Convert image to DirectClass pixel packets.\n        */\n        image->alpha_trait=\n            (((int) ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA) ||\n            ((int) ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA) ||\n            (png_get_valid(ping,ping_info,PNG_INFO_tRNS))) ?\n            BlendPixelTrait : UndefinedPixelTrait;\n\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          if (num_passes > 1)\n            row_offset=ping_rowbytes*y;\n\n          else\n            row_offset=0;\n\n          png_read_row(ping,ping_pixels+row_offset,NULL);\n\n          if (pass < num_passes-1)\n            continue;\n\n          q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n          if (q == (Quantum *) NULL)\n            break;\n\n          if ((int) ping_color_type == PNG_COLOR_TYPE_GRAY)\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              GrayQuantum,ping_pixels+row_offset,exception);\n\n          else if ((int) ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              GrayAlphaQuantum,ping_pixels+row_offset,exception);\n\n          else if ((int) ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              RGBAQuantum,ping_pixels+row_offset,exception);\n\n          else if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              IndexQuantum,ping_pixels+row_offset,exception);\n\n          else /* ping_color_type == PNG_COLOR_TYPE_RGB */\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              RGBQuantum,ping_pixels+row_offset,exception);\n\n          if (found_transparent_pixel == MagickFalse)\n            {\n              /* Is there a transparent pixel in the row? */\n              if (y== 0 && logging != MagickFalse)\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Looking for cheap transparent pixel\");\n\n              for (x=(ssize_t) image->columns-1; x >= 0; x--)\n              {\n                if ((ping_color_type == PNG_COLOR_TYPE_RGBA ||\n                    ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA) &&\n                   (GetPixelAlpha(image,q) != OpaqueAlpha))\n                  {\n                    if (logging != MagickFalse)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"    ...got one.\");\n\n                    found_transparent_pixel = MagickTrue;\n                    break;\n                  }\n                if ((ping_color_type == PNG_COLOR_TYPE_RGB ||\n                    ping_color_type == PNG_COLOR_TYPE_GRAY) &&\n                    (ScaleQuantumToShort(GetPixelRed(image,q)) ==\n                    transparent_color.red &&\n                    ScaleQuantumToShort(GetPixelGreen(image,q)) ==\n                    transparent_color.green &&\n                    ScaleQuantumToShort(GetPixelBlue(image,q)) ==\n                    transparent_color.blue))\n                  {\n                    if (logging != MagickFalse)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"    ...got one.\");\n                    found_transparent_pixel = MagickTrue;\n                    break;\n                  }\n                q+=GetPixelChannels(image);\n              }\n            }\n\n          if (num_passes == 1)\n            {\n              status=SetImageProgress(image,LoadImageTag,\n                  (MagickOffsetType) y, image->rows);\n\n              if (status == MagickFalse)\n                break;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n        }\n\n        if (num_passes != 1)\n          {\n            status=SetImageProgress(image,LoadImageTag,pass,num_passes);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    }\n\n  else /* image->storage_class != DirectClass */\n\n    for (pass=0; pass < num_passes; pass++)\n    {\n      Quantum\n        *quantum_scanline;\n\n      register Quantum\n        *r;\n\n      /*\n        Convert grayscale image to PseudoClass pixel packets.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Converting grayscale pixels to pixel packets\");\n\n      image->alpha_trait=ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ?\n        BlendPixelTrait : UndefinedPixelTrait;\n\n      quantum_scanline=(Quantum *) AcquireQuantumMemory(image->columns,\n        (image->alpha_trait  == BlendPixelTrait?  2 : 1)*\n        sizeof(*quantum_scanline));\n\n      if (quantum_scanline == (Quantum *) NULL)\n        png_error(ping,\"Memory allocation failed\");\n\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        Quantum\n           alpha;\n\n        if (num_passes > 1)\n          row_offset=ping_rowbytes*y;\n\n        else\n          row_offset=0;\n\n        png_read_row(ping,ping_pixels+row_offset,NULL);\n\n        if (pass < num_passes-1)\n          continue;\n\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n\n        if (q == (Quantum *) NULL)\n          break;\n\n        p=ping_pixels+row_offset;\n        r=quantum_scanline;\n\n        switch (ping_bit_depth)\n        {\n          case 8:\n          {\n\n            if (ping_color_type == 4)\n              for (x=(ssize_t) image->columns-1; x >= 0; x--)\n              {\n                *r++=*p++;\n\n                alpha=ScaleCharToQuantum((unsigned char)*p++);\n\n                SetPixelAlpha(image,alpha,q);\n\n                if (alpha != OpaqueAlpha)\n                  found_transparent_pixel = MagickTrue;\n\n                q+=GetPixelChannels(image);\n              }\n\n            else\n              for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                *r++=*p++;\n\n            break;\n          }\n\n          case 16:\n          {\n            for (x=(ssize_t) image->columns-1; x >= 0; x--)\n            {\n#if (MAGICKCORE_QUANTUM_DEPTH >= 16)\n              unsigned short\n                quantum;\n\n              if (image->colors > 256)\n                quantum=(((unsigned int) *p++) << 8);\n\n              else\n                quantum=0;\n\n              quantum|=(*p++);\n              *r=ScaleShortToQuantum(quantum);\n              r++;\n\n              if (ping_color_type == 4)\n                {\n                  if (image->colors > 256)\n                    quantum=(((unsigned int) *p++) << 8);\n                  else\n                    quantum=0;\n\n                  quantum|=(*p++);\n\n                  alpha=ScaleShortToQuantum(quantum);\n                  SetPixelAlpha(image,alpha,q);\n\n                  if (alpha != OpaqueAlpha)\n                    found_transparent_pixel = MagickTrue;\n\n                  q+=GetPixelChannels(image);\n                }\n\n#else /* MAGICKCORE_QUANTUM_DEPTH == 8 */\n              *r++=(*p++);\n              p++; /* strip low byte */\n\n              if (ping_color_type == 4)\n                {\n                  SetPixelAlpha(image,*p++,q);\n\n                  if (GetPixelAlpha(image,q) != OpaqueAlpha)\n                    found_transparent_pixel = MagickTrue;\n\n                  p++;\n                  q+=GetPixelChannels(image);\n                }\n#endif\n            }\n\n            break;\n          }\n\n          default:\n            break;\n        }\n\n        /*\n          Transfer image scanline.\n        */\n        r=quantum_scanline;\n\n        q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          SetPixelIndex(image,*r++,q);\n          q+=GetPixelChannels(image);\n        }\n\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n\n        if (num_passes == 1)\n          {\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n\n            if (status == MagickFalse)\n              break;\n          }\n      }\n\n      if (num_passes != 1)\n        {\n          status=SetImageProgress(image,LoadImageTag,pass,num_passes);\n\n          if (status == MagickFalse)\n            break;\n        }\n\n      quantum_scanline=(Quantum *) RelinquishMagickMemory(quantum_scanline);\n    }\n\n    image->alpha_trait=found_transparent_pixel ? BlendPixelTrait :\n      UndefinedPixelTrait;\n\n    if (logging != MagickFalse)\n      {\n        if (found_transparent_pixel != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Found transparent pixel\");\n        else\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    No transparent pixel was found\");\n\n            ping_color_type&=0x03;\n          }\n      }\n    }\n\n  quantum_info=DestroyQuantumInfo(quantum_info);\n\n  if (image->storage_class == PseudoClass)\n    {\n      PixelTrait\n        alpha_trait;\n\n      alpha_trait=image->alpha_trait;\n      image->alpha_trait=UndefinedPixelTrait;\n      (void) SyncImage(image,exception);\n      image->alpha_trait=alpha_trait;\n    }\n\n  png_read_end(ping,end_info);\n\n  if (logging != MagickFalse)\n  {\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"  image->storage_class=%d\\n\",(int) image->storage_class);\n  }\n\n  if (image_info->number_scenes != 0 && mng_info->scenes_found-1 <\n      (ssize_t) image_info->first_scene && image->delay != 0)\n    {\n      png_destroy_read_struct(&ping,&ping_info,&end_info);\n      pixel_info=RelinquishVirtualMemory(pixel_info);\n      image->colors=2;\n      (void) SetImageBackgroundColor(image,exception);\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n      UnlockSemaphoreInfo(ping_semaphore);\n#endif\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  exit ReadOnePNGImage() early.\");\n      return(image);\n    }\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_tRNS))\n    {\n      ClassType\n        storage_class;\n\n      /*\n        Image has a transparent background.\n      */\n      storage_class=image->storage_class;\n      image->alpha_trait=BlendPixelTrait;\n\n/* Balfour fix from imagemagick discourse server, 5 Feb 2010 */\n\n      if (storage_class == PseudoClass)\n        {\n          if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n            {\n              for (x=0; x < ping_num_trans; x++)\n              {\n                 image->colormap[x].alpha_trait=BlendPixelTrait;\n                 image->colormap[x].alpha =\n                   ScaleCharToQuantum((unsigned char)ping_trans_alpha[x]);\n              }\n            }\n\n          else if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n            {\n              for (x=0; x < (int) image->colors; x++)\n              {\n                 if (ScaleQuantumToShort(image->colormap[x].red) ==\n                     transparent_color.alpha)\n                 {\n                    image->colormap[x].alpha_trait=BlendPixelTrait;\n                    image->colormap[x].alpha = (Quantum) TransparentAlpha;\n                 }\n              }\n            }\n          (void) SyncImage(image,exception);\n        }\n\n#if 1 /* Should have already been done above, but glennrp problem P10\n       * needs this.\n       */\n      else\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            image->storage_class=storage_class;\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (q == (Quantum *) NULL)\n              break;\n\n\n            /* Caution: on a Q8 build, this does not distinguish between\n             * 16-bit colors that differ only in the low byte\n             */\n            for (x=(ssize_t) image->columns-1; x >= 0; x--)\n            {\n              if (ScaleQuantumToShort(GetPixelRed(image,q)) ==\n                  transparent_color.red &&\n                  ScaleQuantumToShort(GetPixelGreen(image,q)) ==\n                  transparent_color.green &&\n                  ScaleQuantumToShort(GetPixelBlue(image,q)) ==\n                  transparent_color.blue)\n                {\n                  SetPixelAlpha(image,TransparentAlpha,q);\n                }\n\n#if 0 /* I have not found a case where this is needed. */\n              else\n                {\n                  SetPixelAlpha(image,q)=(Quantum) OpaqueAlpha;\n                }\n#endif\n\n              q+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n#endif\n\n      image->storage_class=DirectClass;\n    }\n\n  for (j = 0; j < 2; j++)\n  {\n    if (j == 0)\n      status = png_get_text(ping,ping_info,&text,&num_text) != 0 ?\n          MagickTrue : MagickFalse;\n    else\n      status = png_get_text(ping,end_info,&text,&num_text) != 0 ?\n          MagickTrue : MagickFalse;\n\n    if (status != MagickFalse)\n      for (i=0; i < (ssize_t) num_text; i++)\n      {\n        /* Check for a profile */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Reading PNG text chunk\");\n\n        if (strlen(text[i].key) > 16 &&\n            memcmp(text[i].key, \"Raw profile type \",17) == 0)\n          {\n            const char\n              *value;\n\n            value=GetImageOption(image_info,\"profile:skip\");\n\n            if (IsOptionMember(text[i].key+17,value) == MagickFalse)\n            {\n               (void) Magick_png_read_raw_profile(ping,image,image_info,text,\n                  (int) i,exception);\n               num_raw_profiles++;\n               if (logging != MagickFalse)\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Read raw profile %s\",text[i].key+17);\n            }\n            else\n            {\n               if (logging != MagickFalse)\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Skipping raw profile %s\",text[i].key+17);\n            }\n          }\n\n        else\n          {\n            char\n              *value;\n\n            length=text[i].text_length;\n            value=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n              sizeof(*value));\n            if (value == (char *) NULL)\n              {\n                png_error(ping,\"Memory allocation failed\");\n                break;\n              }\n            *value='\\0';\n            (void) ConcatenateMagickString(value,text[i].text,length+2);\n\n            /* Don't save \"density\" or \"units\" property if we have a pHYs\n             * chunk\n             */\n            if (!png_get_valid(ping,ping_info,PNG_INFO_pHYs) ||\n                (LocaleCompare(text[i].key,\"density\") != 0 &&\n                LocaleCompare(text[i].key,\"units\") != 0))\n               (void) SetImageProperty(image,text[i].key,value,exception);\n\n            if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      length: %lu\\n\"\n                \"      Keyword: %s\",\n                (unsigned long) length,\n                text[i].key);\n            }\n\n            value=DestroyString(value);\n          }\n      }\n    num_text_total += num_text;\n  }\n\n#ifdef MNG_OBJECT_BUFFERS\n  /*\n    Store the object if necessary.\n  */\n  if (object_id && !mng_info->frozen[object_id])\n    {\n      if (mng_info->ob[object_id] == (MngBuffer *) NULL)\n        {\n          /*\n            create a new object buffer.\n          */\n          mng_info->ob[object_id]=(MngBuffer *)\n            AcquireMagickMemory(sizeof(MngBuffer));\n\n          if (mng_info->ob[object_id] != (MngBuffer *) NULL)\n            {\n              mng_info->ob[object_id]->image=(Image *) NULL;\n              mng_info->ob[object_id]->reference_count=1;\n            }\n        }\n\n      if ((mng_info->ob[object_id] == (MngBuffer *) NULL) ||\n          mng_info->ob[object_id]->frozen)\n        {\n          if (mng_info->ob[object_id] == (MngBuffer *) NULL)\n             png_error(ping,\"Memory allocation failed\");\n\n          if (mng_info->ob[object_id]->frozen)\n            png_error(ping,\"Cannot overwrite frozen MNG object buffer\");\n        }\n\n      else\n        {\n\n          if (mng_info->ob[object_id]->image != (Image *) NULL)\n            mng_info->ob[object_id]->image=DestroyImage\n                (mng_info->ob[object_id]->image);\n\n          mng_info->ob[object_id]->image=CloneImage(image,0,0,MagickTrue,\n            exception);\n\n          if (mng_info->ob[object_id]->image != (Image *) NULL)\n            mng_info->ob[object_id]->image->file=(FILE *) NULL;\n\n          else\n            png_error(ping, \"Cloning image for object buffer failed\");\n\n          if (ping_width > 250000L || ping_height > 250000L)\n             png_error(ping,\"PNG Image dimensions are too large.\");\n\n          mng_info->ob[object_id]->width=ping_width;\n          mng_info->ob[object_id]->height=ping_height;\n          mng_info->ob[object_id]->color_type=ping_color_type;\n          mng_info->ob[object_id]->sample_depth=ping_bit_depth;\n          mng_info->ob[object_id]->interlace_method=ping_interlace_method;\n          mng_info->ob[object_id]->compression_method=\n             ping_compression_method;\n          mng_info->ob[object_id]->filter_method=ping_filter_method;\n\n          if (png_get_valid(ping,ping_info,PNG_INFO_PLTE))\n            {\n              png_colorp\n                plte;\n\n              /*\n                Copy the PLTE to the object buffer.\n              */\n              png_get_PLTE(ping,ping_info,&plte,&number_colors);\n              mng_info->ob[object_id]->plte_length=number_colors;\n\n              for (i=0; i < number_colors; i++)\n              {\n                mng_info->ob[object_id]->plte[i]=plte[i];\n              }\n            }\n\n          else\n              mng_info->ob[object_id]->plte_length=0;\n        }\n    }\n#endif\n\n   /* Set image->alpha_trait to MagickTrue if the input colortype supports\n    * alpha or if a valid tRNS chunk is present, no matter whether there\n    * is actual transparency present.\n    */\n    image->alpha_trait=(((int) ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA) ||\n        ((int) ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA) ||\n        (png_get_valid(ping,ping_info,PNG_INFO_tRNS))) ?\n        BlendPixelTrait : UndefinedPixelTrait;\n\n#if 0  /* I'm not sure what's wrong here but it does not work. */\n    if (image->alpha_trait != UndefinedPixelTrait)\n    {\n      if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n        (void) SetImageType(image,GrayscaleAlphaType,exception);\n\n      else if (ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        (void) SetImageType(image,PaletteAlphaType,exception);\n\n      else\n        (void) SetImageType(image,TrueColorAlphaType,exception);\n    }\n\n    else\n    {\n      if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n        (void) SetImageType(image,GrayscaleType,exception);\n\n      else if (ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        (void) SetImageType(image,PaletteType,exception);\n\n      else\n        (void) SetImageType(image,TrueColorType,exception);\n    }\n#endif\n\n   /* Set more properties for identify to retrieve */\n   {\n     char\n       msg[MagickPathExtent];\n\n     if (num_text_total != 0)\n       {\n         /* libpng doesn't tell us whether they were tEXt, zTXt, or iTXt */\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"%d tEXt/zTXt/iTXt chunks were found\", num_text_total);\n         (void) SetImageProperty(image,\"png:text\",msg,\n                exception);\n       }\n\n     if (num_raw_profiles != 0)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"%d were found\", num_raw_profiles);\n         (void) SetImageProperty(image,\"png:text-encoded profiles\",msg,\n                exception);\n       }\n\n     /* cHRM chunk: */\n     if (ping_found_cHRM != MagickFalse)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\"%s\",\n            \"chunk was found (see Chromaticity, above)\");\n         (void) SetImageProperty(image,\"png:cHRM\",msg,\n                exception);\n       }\n\n     /* bKGD chunk: */\n     if (png_get_valid(ping,ping_info,PNG_INFO_bKGD))\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\"%s\",\n            \"chunk was found (see Background color, above)\");\n         (void) SetImageProperty(image,\"png:bKGD\",msg,\n                exception);\n       }\n\n     (void) FormatLocaleString(msg,MagickPathExtent,\"%s\",\n        \"chunk was found\");\n\n#if defined(PNG_iCCP_SUPPORTED)\n     /* iCCP chunk: */\n     if (ping_found_iCCP != MagickFalse)\n        (void) SetImageProperty(image,\"png:iCCP\",msg,\n                exception);\n#endif\n\n     if (png_get_valid(ping,ping_info,PNG_INFO_tRNS))\n        (void) SetImageProperty(image,\"png:tRNS\",msg,\n                exception);\n\n#if defined(PNG_sRGB_SUPPORTED)\n     /* sRGB chunk: */\n     if (ping_found_sRGB != MagickFalse)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"intent=%d (%s)\",\n            (int) intent,\n            Magick_RenderingIntentString_from_PNG_RenderingIntent(intent));\n         (void) SetImageProperty(image,\"png:sRGB\",msg,\n                 exception);\n       }\n#endif\n\n     /* gAMA chunk: */\n     if (ping_found_gAMA != MagickFalse)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"gamma=%.8g (See Gamma, above)\",\n            file_gamma);\n         (void) SetImageProperty(image,\"png:gAMA\",msg,\n                exception);\n       }\n\n#if defined(PNG_pHYs_SUPPORTED)\n     /* pHYs chunk: */\n     if (png_get_valid(ping,ping_info,PNG_INFO_pHYs))\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"x_res=%.10g, y_res=%.10g, units=%d\",\n            (double) x_resolution,(double) y_resolution, unit_type);\n         (void) SetImageProperty(image,\"png:pHYs\",msg,\n                exception);\n       }\n#endif\n\n#if defined(PNG_oFFs_SUPPORTED)\n     /* oFFs chunk: */\n     if (png_get_valid(ping,ping_info,PNG_INFO_oFFs))\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"x_off=%.20g, y_off=%.20g\",\n            (double) image->page.x,(double) image->page.y);\n         (void) SetImageProperty(image,\"png:oFFs\",msg,\n                exception);\n       }\n#endif\n\n#if defined(PNG_tIME_SUPPORTED)\n     read_tIME_chunk(image,ping,end_info,exception);\n#endif\n\n     /* caNv chunk: */\n     if ((image->page.width != 0 && image->page.width != image->columns) ||\n         (image->page.height != 0 && image->page.height != image->rows) ||\n         (image->page.x != 0 || image->page.y != 0))\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"width=%.20g, height=%.20g, x_offset=%.20g, y_offset=%.20g\",\n            (double) image->page.width,(double) image->page.height,\n            (double) image->page.x,(double) image->page.y);\n         (void) SetImageProperty(image,\"png:caNv\",msg,\n                exception);\n       }\n\n     /* vpAg chunk: */\n     if ((image->page.width != 0 && image->page.width != image->columns) ||\n         (image->page.height != 0 && image->page.height != image->rows))\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"width=%.20g, height=%.20g\",\n            (double) image->page.width,(double) image->page.height);\n         (void) SetImageProperty(image,\"png:vpAg\",msg,\n                exception);\n       }\n   }\n\n  /*\n    Relinquish resources.\n  */\n  png_destroy_read_struct(&ping,&ping_info,&end_info);\n\n  pixel_info=RelinquishVirtualMemory(pixel_info);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOnePNGImage()\");\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n  /* }  for navigation to beginning of SETJMP-protected block, revert to\n   *    Throwing an Exception when an error occurs.\n   */\n\n  return(image);\n\n/* end of reading one PNG image */\n}\n\nstatic Image *ReadPNGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    logging,\n    status;\n\n  MngInfo\n    *mng_info;\n\n  char\n    magic_number[MagickPathExtent];\n\n  ssize_t\n    count;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\"Enter ReadPNGImage()\");\n  image=AcquireImage(image_info,exception);\n  mng_info=(MngInfo *) NULL;\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n\n  if (status == MagickFalse)\n    ThrowReaderException(FileOpenError,\"UnableToOpenFile\");\n\n  /*\n    Verify PNG signature.\n  */\n  count=ReadBlob(image,8,(unsigned char *) magic_number);\n\n  if (count < 8 || memcmp(magic_number,\"\\211PNG\\r\\n\\032\\n\",8) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  /*\n     Verify that file size large enough to contain a PNG datastream.\n  */\n  if (GetBlobSize(image) < 61)\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n\n  /*\n    Allocate a MngInfo structure.\n  */\n  mng_info=(MngInfo *) AcquireMagickMemory(sizeof(MngInfo));\n\n  if (mng_info == (MngInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /*\n    Initialize members of the MngInfo structure.\n  */\n  (void) ResetMagickMemory(mng_info,0,sizeof(MngInfo));\n  mng_info->image=image;\n\n  image=ReadOnePNGImage(mng_info,image_info,exception);\n  mng_info=MngInfoFreeStruct(mng_info);\n\n  if (image == (Image *) NULL)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"exit ReadPNGImage() with error\");\n\n      return((Image *) NULL);\n    }\n\n  (void) CloseBlob(image);\n\n  if ((image->columns == 0) || (image->rows == 0))\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"exit ReadPNGImage() with error.\");\n\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n\n  if ((IssRGBColorspace(image->colorspace) != MagickFalse) &&\n      ((image->gamma < .45) || (image->gamma > .46)) &&\n           !(image->chromaticity.red_primary.x>0.6399f &&\n           image->chromaticity.red_primary.x<0.6401f &&\n           image->chromaticity.red_primary.y>0.3299f &&\n           image->chromaticity.red_primary.y<0.3301f &&\n           image->chromaticity.green_primary.x>0.2999f &&\n           image->chromaticity.green_primary.x<0.3001f &&\n           image->chromaticity.green_primary.y>0.5999f &&\n           image->chromaticity.green_primary.y<0.6001f &&\n           image->chromaticity.blue_primary.x>0.1499f &&\n           image->chromaticity.blue_primary.x<0.1501f &&\n           image->chromaticity.blue_primary.y>0.0599f &&\n           image->chromaticity.blue_primary.y<0.0601f &&\n           image->chromaticity.white_point.x>0.3126f &&\n           image->chromaticity.white_point.x<0.3128f &&\n           image->chromaticity.white_point.y>0.3289f &&\n           image->chromaticity.white_point.y<0.3291f))\n    {\n       SetImageColorspace(image,RGBColorspace,exception);\n    }\n\n  if (logging != MagickFalse)\n    {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  page.w: %.20g, page.h: %.20g,page.x: %.20g, page.y: %.20g.\",\n               (double) image->page.width,(double) image->page.height,\n               (double) image->page.x,(double) image->page.y);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  image->colorspace: %d\", (int) image->colorspace);\n    }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"exit ReadPNGImage()\");\n\n  return(image);\n}\n\n\n\n#if defined(JNG_SUPPORTED)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d O n e J N G I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadOneJNGImage() reads a JPEG Network Graphics (JNG) image file\n%  (minus the 8-byte signature)  and returns it.  It allocates the memory\n%  necessary for the new Image structure and returns a pointer to the new\n%  image.\n%\n%  JNG support written by Glenn Randers-Pehrson, glennrp@image...\n%\n%  The format of the ReadOneJNGImage method is:\n%\n%      Image *ReadOneJNGImage(MngInfo *mng_info, const ImageInfo *image_info,\n%         ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o mng_info: Specifies a pointer to a MngInfo structure.\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadOneJNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  Image\n    *alpha_image,\n    *color_image,\n    *image,\n    *jng_image;\n\n  ImageInfo\n    *alpha_image_info,\n    *color_image_info;\n\n  MagickBooleanType\n    logging;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    status;\n\n  png_uint_32\n    jng_height,\n    jng_width;\n\n  png_byte\n    jng_color_type,\n    jng_image_sample_depth,\n    jng_image_compression_method,\n    jng_image_interlace_method,\n    jng_alpha_sample_depth,\n    jng_alpha_compression_method,\n    jng_alpha_filter_method,\n    jng_alpha_interlace_method;\n\n  register const Quantum\n    *s;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  unsigned int\n    read_JSEP,\n    reading_idat;\n\n  size_t\n    length;\n\n  jng_alpha_compression_method=0;\n  jng_alpha_sample_depth=8;\n  jng_color_type=0;\n  jng_height=0;\n  jng_width=0;\n  alpha_image=(Image *) NULL;\n  color_image=(Image *) NULL;\n  alpha_image_info=(ImageInfo *) NULL;\n  color_image_info=(ImageInfo *) NULL;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneJNGImage()\");\n\n  image=mng_info->image;\n\n  if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n    {\n      /*\n        Allocate next image structure.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  AcquireNextImage()\");\n\n      AcquireNextImage(image_info,image,exception);\n\n      if (GetNextImageInList(image) == (Image *) NULL)\n        return(DestroyImageList(image));\n\n      image=SyncNextImageInList(image);\n    }\n  mng_info->image=image;\n\n  /*\n    Signature bytes have already been read.\n  */\n\n  read_JSEP=MagickFalse;\n  reading_idat=MagickFalse;\n  for (;;)\n  {\n    char\n      type[MagickPathExtent];\n\n    unsigned char\n      *chunk;\n\n    unsigned int\n      count;\n\n    /*\n      Read a new JNG chunk.\n    */\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      2*GetBlobSize(image));\n\n    if (status == MagickFalse)\n      break;\n\n    type[0]='\\0';\n    (void) ConcatenateMagickString(type,\"errr\",MagickPathExtent);\n    length=ReadBlobMSBLong(image);\n    count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);\n\n    if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      {\n        if (color_image != (Image *) NULL)\n          color_image=DestroyImage(color_image);\n        if (color_image_info != (ImageInfo *) NULL)\n          color_image_info=DestroyImageInfo(color_image_info);\n        ThrowReaderException(CorruptImageError,\"CorruptImage\");\n      }\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n\n    if (length != 0)\n      {\n        if (length > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));\n\n        if (chunk == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        for (i=0; i < (ssize_t) length; i++)\n        {\n          int\n            c;\n\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            break;\n          chunk[i]=(unsigned char) c;\n        }\n\n        p=chunk;\n      }\n\n    (void) ReadBlobMSBLong(image);  /* read crc word */\n\n    if (memcmp(type,mng_JHDR,4) == 0)\n      {\n        if (length == 16)\n          {\n            jng_width=(png_uint_32) (((png_uint_32) p[0] << 24) |\n              ((png_uint_32) p[1] << 16) | ((png_uint_32) p[2] << 8) |\n              (png_uint_32) p[3]);\n            jng_height=(png_uint_32) (((png_uint_32) p[4] << 24) |\n              ((png_uint_32) p[5] << 16) | ((png_uint_32) p[6] << 8) |\n              (png_uint_32) p[7]);\n            if ((jng_width == 0) || (jng_height == 0))\n              ThrowReaderException(CorruptImageError,\n                \"NegativeOrZeroImageSize\");\n            jng_color_type=p[8];\n            jng_image_sample_depth=p[9];\n            jng_image_compression_method=p[10];\n            jng_image_interlace_method=p[11];\n\n            image->interlace=jng_image_interlace_method != 0 ? PNGInterlace :\n              NoInterlace;\n\n            jng_alpha_sample_depth=p[12];\n            jng_alpha_compression_method=p[13];\n            jng_alpha_filter_method=p[14];\n            jng_alpha_interlace_method=p[15];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_width:      %16lu,    jng_height:     %16lu\\n\"\n                  \"    jng_color_type: %16d,     jng_image_sample_depth: %3d\\n\"\n                  \"    jng_image_compression_method:%3d\",\n                  (unsigned long) jng_width, (unsigned long) jng_height,\n                  jng_color_type, jng_image_sample_depth,\n                  jng_image_compression_method);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_image_interlace_method:  %3d\"\n                  \"    jng_alpha_sample_depth:      %3d\",\n                  jng_image_interlace_method,\n                  jng_alpha_sample_depth);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_alpha_compression_method:%3d\\n\"\n                  \"    jng_alpha_filter_method:     %3d\\n\"\n                  \"    jng_alpha_interlace_method:  %3d\",\n                  jng_alpha_compression_method,\n                  jng_alpha_filter_method,\n                  jng_alpha_interlace_method);\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n\n    if ((reading_idat == MagickFalse) && (read_JSEP == MagickFalse) &&\n        ((memcmp(type,mng_JDAT,4) == 0) || (memcmp(type,mng_JdAA,4) == 0) ||\n         (memcmp(type,mng_IDAT,4) == 0) || (memcmp(type,mng_JDAA,4) == 0)))\n      {\n        /*\n           o create color_image\n           o open color_blob, attached to color_image\n           o if (color type has alpha)\n               open alpha_blob, attached to alpha_image\n        */\n\n        color_image_info=(ImageInfo *)AcquireMagickMemory(sizeof(ImageInfo));\n\n        if (color_image_info == (ImageInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        GetImageInfo(color_image_info);\n        color_image=AcquireImage(color_image_info,exception);\n\n        if (color_image == (Image *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Creating color_blob.\");\n\n        (void) AcquireUniqueFilename(color_image->filename);\n        status=OpenBlob(color_image_info,color_image,WriteBinaryBlobMode,\n          exception);\n\n        if (status == MagickFalse)\n          {\n            color_image=DestroyImage(color_image);\n            return(DestroyImageList(image));\n          }\n\n        if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n          {\n            alpha_image_info=(ImageInfo *)\n              AcquireMagickMemory(sizeof(ImageInfo));\n\n            if (alpha_image_info == (ImageInfo *) NULL)\n              {\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            GetImageInfo(alpha_image_info);\n            alpha_image=AcquireImage(alpha_image_info,exception);\n\n            if (alpha_image == (Image *) NULL)\n              {\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Creating alpha_blob.\");\n\n            (void) AcquireUniqueFilename(alpha_image->filename);\n            status=OpenBlob(alpha_image_info,alpha_image,WriteBinaryBlobMode,\n              exception);\n\n            if (status == MagickFalse)\n              {\n                alpha_image=DestroyImage(alpha_image);\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                return(DestroyImageList(image));\n              }\n\n            if (jng_alpha_compression_method == 0)\n              {\n                unsigned char\n                  data[18];\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Writing IHDR chunk to alpha_blob.\");\n\n                (void) WriteBlob(alpha_image,8,(const unsigned char *)\n                  \"\\211PNG\\r\\n\\032\\n\");\n\n                (void) WriteBlobMSBULong(alpha_image,13L);\n                PNGType(data,mng_IHDR);\n                LogPNGChunk(logging,mng_IHDR,13L);\n                PNGLong(data+4,jng_width);\n                PNGLong(data+8,jng_height);\n                data[12]=jng_alpha_sample_depth;\n                data[13]=0; /* color_type gray */\n                data[14]=0; /* compression method 0 */\n                data[15]=0; /* filter_method 0 */\n                data[16]=0; /* interlace_method 0 */\n                (void) WriteBlob(alpha_image,17,data);\n                (void) WriteBlobMSBULong(alpha_image,crc32(0,data,17));\n              }\n          }\n        reading_idat=MagickTrue;\n      }\n\n    if (memcmp(type,mng_JDAT,4) == 0)\n      {\n        /* Copy chunk to color_image->blob */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Copying JDAT chunk data to color_blob.\");\n\n        if (length != 0)\n          {\n            (void) WriteBlob(color_image,length,chunk);\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n          }\n\n        continue;\n      }\n\n    if (memcmp(type,mng_IDAT,4) == 0)\n      {\n        png_byte\n           data[5];\n\n        /* Copy IDAT header and chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying IDAT chunk data to alpha_blob.\");\n\n            (void) WriteBlobMSBULong(alpha_image,(size_t) length);\n            PNGType(data,mng_IDAT);\n            LogPNGChunk(logging,mng_IDAT,length);\n            (void) WriteBlob(alpha_image,4,data);\n            (void) WriteBlob(alpha_image,length,chunk);\n            (void) WriteBlobMSBULong(alpha_image,\n              crc32(crc32(0,data,4),chunk,(uInt) length));\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if ((memcmp(type,mng_JDAA,4) == 0) || (memcmp(type,mng_JdAA,4) == 0))\n      {\n        /* Copy chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying JDAA chunk data to alpha_blob.\");\n\n            (void) WriteBlob(alpha_image,length,chunk);\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_JSEP,4) == 0)\n      {\n        read_JSEP=MagickTrue;\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_bKGD,4) == 0)\n      {\n        if (length == 2)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=image->background_color.red;\n            image->background_color.blue=image->background_color.red;\n          }\n\n        if (length == 6)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=ScaleCharToQuantum(p[3]);\n            image->background_color.blue=ScaleCharToQuantum(p[5]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_gAMA,4) == 0)\n      {\n        if (length == 4)\n          image->gamma=((float) mng_get_long(p))*0.00001;\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_cHRM,4) == 0)\n      {\n        if (length == 32)\n          {\n            image->chromaticity.white_point.x=0.00001*mng_get_long(p);\n            image->chromaticity.white_point.y=0.00001*mng_get_long(&p[4]);\n            image->chromaticity.red_primary.x=0.00001*mng_get_long(&p[8]);\n            image->chromaticity.red_primary.y=0.00001*mng_get_long(&p[12]);\n            image->chromaticity.green_primary.x=0.00001*mng_get_long(&p[16]);\n            image->chromaticity.green_primary.y=0.00001*mng_get_long(&p[20]);\n            image->chromaticity.blue_primary.x=0.00001*mng_get_long(&p[24]);\n            image->chromaticity.blue_primary.y=0.00001*mng_get_long(&p[28]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_sRGB,4) == 0)\n      {\n        if (length == 1)\n          {\n            image->rendering_intent=\n              Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n            image->gamma=1.000f/2.200f;\n            image->chromaticity.red_primary.x=0.6400f;\n            image->chromaticity.red_primary.y=0.3300f;\n            image->chromaticity.green_primary.x=0.3000f;\n            image->chromaticity.green_primary.y=0.6000f;\n            image->chromaticity.blue_primary.x=0.1500f;\n            image->chromaticity.blue_primary.y=0.0600f;\n            image->chromaticity.white_point.x=0.3127f;\n            image->chromaticity.white_point.y=0.3290f;\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_oFFs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->page.x=(ssize_t) mng_get_long(p);\n            image->page.y=(ssize_t) mng_get_long(&p[4]);\n\n            if ((int) p[8] != 0)\n              {\n                image->page.x/=10000;\n                image->page.y/=10000;\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_pHYs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->resolution.x=(double) mng_get_long(p);\n            image->resolution.y=(double) mng_get_long(&p[4]);\n            if ((int) p[8] == PNG_RESOLUTION_METER)\n              {\n                image->units=PixelsPerCentimeterResolution;\n                image->resolution.x=image->resolution.x/100.0f;\n                image->resolution.y=image->resolution.y/100.0f;\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n#if 0\n    if (memcmp(type,mng_iCCP,4) == 0)\n      {\n        /* To do: */\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n#endif\n\n    if (length != 0)\n      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n    if (memcmp(type,mng_IEND,4))\n      continue;\n\n    break;\n  }\n\n\n  /* IEND found */\n\n  /*\n    Finish up reading image data:\n\n       o read main image from color_blob.\n\n       o close color_blob.\n\n       o if (color_type has alpha)\n            if alpha_encoding is PNG\n               read secondary image from alpha_blob via ReadPNG\n            if alpha_encoding is JPEG\n               read secondary image from alpha_blob via ReadJPEG\n\n       o close alpha_blob.\n\n       o copy intensity of secondary image into\n         alpha samples of main image.\n\n       o destroy the secondary image.\n  */\n\n  if (color_image_info == (ImageInfo *) NULL)\n    {\n      assert(color_image == (Image *) NULL);\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  if (color_image == (Image *) NULL)\n    {\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  (void) SeekBlob(color_image,0,SEEK_SET);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading jng_image from color_blob.\");\n\n  assert(color_image_info != (ImageInfo *) NULL);\n  (void) FormatLocaleString(color_image_info->filename,MagickPathExtent,\"%s\",\n    color_image->filename);\n\n  color_image_info->ping=MagickFalse;   /* To do: avoid this */\n  jng_image=ReadImage(color_image_info,exception);\n\n  (void) RelinquishUniqueFileResource(color_image->filename);\n  color_image=DestroyImage(color_image);\n  color_image_info=DestroyImageInfo(color_image_info);\n\n  if (jng_image == (Image *) NULL)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Copying jng_image pixels to main image.\");\n\n  image->rows=jng_height;\n  image->columns=jng_width;\n\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    s=GetVirtualPixels(jng_image,0,y,image->columns,1,exception);\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    for (x=(ssize_t) image->columns; x != 0; x--)\n    {\n      SetPixelRed(image,GetPixelRed(jng_image,s),q);\n      SetPixelGreen(image,GetPixelGreen(jng_image,s),q);\n      SetPixelBlue(image,GetPixelBlue(jng_image,s),q);\n      q+=GetPixelChannels(image);\n      s+=GetPixelChannels(jng_image);\n    }\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n\n  jng_image=DestroyImage(jng_image);\n\n  if (image_info->ping == MagickFalse)\n    {\n     if (jng_color_type >= 12)\n       {\n         if (jng_alpha_compression_method == 0)\n           {\n             png_byte\n               data[5];\n             (void) WriteBlobMSBULong(alpha_image,0x00000000L);\n             PNGType(data,mng_IEND);\n             LogPNGChunk(logging,mng_IEND,0L);\n             (void) WriteBlob(alpha_image,4,data);\n             (void) WriteBlobMSBULong(alpha_image,crc32(0,data,4));\n           }\n\n         (void) CloseBlob(alpha_image);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Reading alpha from alpha_blob.\");\n\n         (void) FormatLocaleString(alpha_image_info->filename,MagickPathExtent,\n           \"%s\",alpha_image->filename);\n\n         jng_image=ReadImage(alpha_image_info,exception);\n\n         if (jng_image != (Image *) NULL)\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             s=GetVirtualPixels(jng_image,0,y,image->columns,1,\n               exception);\n             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (image->alpha_trait != UndefinedPixelTrait)\n               for (x=(ssize_t) image->columns; x != 0; x--)\n               {\n                  SetPixelAlpha(image,GetPixelRed(jng_image,s),q);\n                  q+=GetPixelChannels(image);\n                  s+=GetPixelChannels(jng_image);\n               }\n\n             else\n               for (x=(ssize_t) image->columns; x != 0; x--)\n               {\n                  SetPixelAlpha(image,GetPixelRed(jng_image,s),q);\n                  if (GetPixelAlpha(image,q) != OpaqueAlpha)\n                    image->alpha_trait=BlendPixelTrait;\n                  q+=GetPixelChannels(image);\n                  s+=GetPixelChannels(jng_image);\n               }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n           }\n         (void) RelinquishUniqueFileResource(alpha_image->filename);\n         alpha_image=DestroyImage(alpha_image);\n         alpha_image_info=DestroyImageInfo(alpha_image_info);\n         if (jng_image != (Image *) NULL)\n           jng_image=DestroyImage(jng_image);\n       }\n    }\n\n  /* Read the JNG image.  */\n\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=jng_width;\n      mng_info->mng_height=jng_height;\n    }\n\n  if (image->page.width == 0 && image->page.height == 0)\n    {\n      image->page.width=jng_width;\n      image->page.height=jng_height;\n    }\n\n  if (image->page.x == 0 && image->page.y == 0)\n    {\n      image->page.x=mng_info->x_off[mng_info->object_id];\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  mng_info->image_found++;\n  status=SetImageProgress(image,LoadImagesTag,2*TellBlob(image),\n    2*GetBlobSize(image));\n\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage()\");\n\n  return(image);\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d J N G I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadJNGImage() reads a JPEG Network Graphics (JNG) image file\n%  (including the 8-byte signature)  and returns it.  It allocates the memory\n%  necessary for the new Image structure and returns a pointer to the new\n%  image.\n%\n%  JNG support written by Glenn Randers-Pehrson, glennrp@image...\n%\n%  The format of the ReadJNGImage method is:\n%\n%      Image *ReadJNGImage(const ImageInfo *image_info, ExceptionInfo\n%         *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic Image *ReadJNGImage(const ImageInfo *image_info,\n                ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    logging,\n    status;\n\n  MngInfo\n    *mng_info;\n\n  char\n    magic_number[MagickPathExtent];\n\n  size_t\n    count;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n     image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\"Enter ReadJNGImage()\");\n  image=AcquireImage(image_info,exception);\n  mng_info=(MngInfo *) NULL;\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n\n  if (status == MagickFalse)\n    return((Image *) NULL);\n\n  if (LocaleCompare(image_info->magick,\"JNG\") != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  /* Verify JNG signature.  */\n\n  count=(size_t) ReadBlob(image,8,(unsigned char *) magic_number);\n\n  if (count < 8 || memcmp(magic_number,\"\\213JNG\\r\\n\\032\\n\",8) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  /*\n     Verify that file size large enough to contain a JNG datastream.\n  */\n  if (GetBlobSize(image) < 147)\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n\n  /* Allocate a MngInfo structure.  */\n\n  mng_info=(MngInfo *) AcquireMagickMemory(sizeof(*mng_info));\n\n  if (mng_info == (MngInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* Initialize members of the MngInfo structure.  */\n\n  (void) ResetMagickMemory(mng_info,0,sizeof(MngInfo));\n\n  mng_info->image=image;\n  image=ReadOneJNGImage(mng_info,image_info,exception);\n  mng_info=MngInfoFreeStruct(mng_info);\n\n  if (image == (Image *) NULL)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"exit ReadJNGImage() with error\");\n\n      return((Image *) NULL);\n    }\n  (void) CloseBlob(image);\n\n  if (image->columns == 0 || image->rows == 0)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"exit ReadJNGImage() with error\");\n\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"exit ReadJNGImage()\");\n\n  return(image);\n}\n#endif\n\nstatic Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,\n     ExceptionInfo *exception)\n{\n  char\n    page_geometry[MagickPathExtent];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    logging;\n\n  volatile int\n    first_mng_object,\n    object_id,\n    term_chunk_found,\n    skip_to_iend;\n\n  volatile ssize_t\n    image_count=0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MngBox\n    default_fb,\n    fb,\n    previous_fb;\n\n#if defined(MNG_INSERT_LAYERS)\n  PixelInfo\n    mng_background_color;\n#endif\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  ssize_t\n    loop_level;\n\n  volatile short\n    skipping_loop;\n\n#if defined(MNG_INSERT_LAYERS)\n  unsigned int\n    mandatory_back=0;\n#endif\n\n  volatile unsigned int\n#ifdef MNG_OBJECT_BUFFERS\n    mng_background_object=0,\n#endif\n    mng_type=0;   /* 0: PNG or JNG; 1: MNG; 2: MNG-LC; 3: MNG-VLC */\n\n  size_t\n    default_frame_timeout,\n    frame_timeout,\n#if defined(MNG_INSERT_LAYERS)\n    image_height,\n    image_width,\n#endif\n    length;\n\n  /* These delays are all measured in image ticks_per_second,\n   * not in MNG ticks_per_second\n   */\n  volatile size_t\n    default_frame_delay,\n    final_delay,\n    final_image_delay,\n    frame_delay,\n#if defined(MNG_INSERT_LAYERS)\n    insert_layers,\n#endif\n    mng_iterations=1,\n    simplicity=0,\n    subframe_height=0,\n    subframe_width=0;\n\n  previous_fb.top=0;\n  previous_fb.bottom=0;\n  previous_fb.left=0;\n  previous_fb.right=0;\n  default_fb.top=0;\n  default_fb.bottom=0;\n  default_fb.left=0;\n  default_fb.right=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneMNGImage()\");\n\n  image=mng_info->image;\n\n  if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n    {\n      char\n        magic_number[MagickPathExtent];\n\n      /* Verify MNG signature.  */\n      count=(size_t) ReadBlob(image,8,(unsigned char *) magic_number);\n      if (memcmp(magic_number,\"\\212MNG\\r\\n\\032\\n\",8) != 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n      /* Initialize some nonzero members of the MngInfo structure.  */\n      for (i=0; i < MNG_MAX_OBJECTS; i++)\n      {\n        mng_info->object_clip[i].right=(ssize_t) PNG_UINT_31_MAX;\n        mng_info->object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX;\n      }\n      mng_info->exists[0]=MagickTrue;\n    }\n\n  skipping_loop=(-1);\n  first_mng_object=MagickTrue;\n  mng_type=0;\n#if defined(MNG_INSERT_LAYERS)\n  insert_layers=MagickFalse; /* should be False during convert or mogrify */\n#endif\n  default_frame_delay=0;\n  default_frame_timeout=0;\n  frame_delay=0;\n  final_delay=1;\n  mng_info->ticks_per_second=1UL*image->ticks_per_second;\n  object_id=0;\n  skip_to_iend=MagickFalse;\n  term_chunk_found=MagickFalse;\n  mng_info->framing_mode=1;\n#if defined(MNG_INSERT_LAYERS)\n  mandatory_back=MagickFalse;\n#endif\n#if defined(MNG_INSERT_LAYERS)\n  mng_background_color=image->background_color;\n#endif\n  default_fb=mng_info->frame;\n  previous_fb=mng_info->frame;\n  do\n  {\n    char\n      type[MagickPathExtent];\n\n    if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n      {\n        unsigned char\n          *chunk;\n\n        /*\n          Read a new chunk.\n        */\n        type[0]='\\0';\n        (void) ConcatenateMagickString(type,\"errr\",MagickPathExtent);\n        length=ReadBlobMSBLong(image);\n        count=(size_t) ReadBlob(image,4,(unsigned char *) type);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  Reading MNG chunk type %c%c%c%c, length: %.20g\",\n           type[0],type[1],type[2],type[3],(double) length);\n\n        if (length > PNG_UINT_31_MAX)\n          {\n            status=MagickFalse;\n            break;\n          }\n\n        if (count == 0)\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n        p=NULL;\n        chunk=(unsigned char *) NULL;\n\n        if (length != 0)\n          {\n            if (length > GetBlobSize(image))\n              ThrowReaderException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));\n\n            if (chunk == (unsigned char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n            for (i=0; i < (ssize_t) length; i++)\n            {\n              int\n                c;\n\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                break;\n              chunk[i]=(unsigned char) c;\n            }\n\n            p=chunk;\n          }\n\n        (void) ReadBlobMSBLong(image);  /* read crc word */\n\n#if !defined(JNG_SUPPORTED)\n        if (memcmp(type,mng_JHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->jhdr_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"JNGCompressNotSupported\",\"`%s'\",image->filename);\n\n            mng_info->jhdr_warning++;\n          }\n#endif\n        if (memcmp(type,mng_DHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->dhdr_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"DeltaPNGNotSupported\",\"`%s'\",image->filename);\n\n            mng_info->dhdr_warning++;\n          }\n        if (memcmp(type,mng_MEND,4) == 0)\n          break;\n\n        if (skip_to_iend)\n          {\n            if (memcmp(type,mng_IEND,4) == 0)\n              skip_to_iend=MagickFalse;\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Skip to IEND.\");\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MHDR,4) == 0)\n          {\n            if (length != 28)\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n              }\n\n            mng_info->mng_width=(unsigned long) (((png_uint_32) p[0] << 24) |\n              ((png_uint_32) p[1] << 16) | ((png_uint_32) p[2] << 8) |\n              (png_uint_32) p[3]);\n            mng_info->mng_height=(unsigned long) (((png_uint_32) p[4] << 24) |\n              ((png_uint_32) p[5] << 16) | ((png_uint_32) p[6] << 8) |\n              (png_uint_32) p[7]);\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG width: %.20g\",(double) mng_info->mng_width);\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG height: %.20g\",(double) mng_info->mng_height);\n              }\n\n            p+=8;\n            mng_info->ticks_per_second=(size_t) mng_get_long(p);\n\n            if (mng_info->ticks_per_second == 0)\n              default_frame_delay=0;\n\n            else\n              default_frame_delay=1UL*image->ticks_per_second/\n                mng_info->ticks_per_second;\n\n            frame_delay=default_frame_delay;\n            simplicity=0;\n\n            p+=16;\n            simplicity=(size_t) mng_get_long(p);\n\n            mng_type=1;    /* Full MNG */\n\n            if ((simplicity != 0) && ((simplicity | 11) == 11))\n              mng_type=2; /* LC */\n\n            if ((simplicity != 0) && ((simplicity | 9) == 9))\n              mng_type=3; /* VLC */\n\n#if defined(MNG_INSERT_LAYERS)\n            if (mng_type != 3)\n              insert_layers=MagickTrue;\n#endif\n            if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n              {\n                /* Allocate next image structure.  */\n                AcquireNextImage(image_info,image,exception);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return((Image *) NULL);\n\n                image=SyncNextImageInList(image);\n                mng_info->image=image;\n              }\n\n            if ((mng_info->mng_width > 65535L) ||\n                (mng_info->mng_height > 65535L))\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(ImageError,\"WidthOrHeightExceedsLimit\");\n              }\n\n            (void) FormatLocaleString(page_geometry,MagickPathExtent,\n              \"%.20gx%.20g+0+0\",(double) mng_info->mng_width,(double)\n              mng_info->mng_height);\n\n            mng_info->frame.left=0;\n            mng_info->frame.right=(ssize_t) mng_info->mng_width;\n            mng_info->frame.top=0;\n            mng_info->frame.bottom=(ssize_t) mng_info->mng_height;\n            mng_info->clip=default_fb=previous_fb=mng_info->frame;\n\n            for (i=0; i < MNG_MAX_OBJECTS; i++)\n              mng_info->object_clip[i]=mng_info->frame;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_TERM,4) == 0)\n          {\n            int\n              repeat=0;\n\n            if (length != 0)\n              repeat=p[0];\n\n            if (repeat == 3 && length > 8)\n              {\n                final_delay=(png_uint_32) mng_get_long(&p[2]);\n                mng_iterations=(png_uint_32) mng_get_long(&p[6]);\n\n                if (mng_iterations == PNG_UINT_31_MAX)\n                  mng_iterations=0;\n\n                image->iterations=mng_iterations;\n                term_chunk_found=MagickTrue;\n              }\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    repeat=%d,  final_delay=%.20g,  iterations=%.20g\",\n                  repeat,(double) final_delay, (double) image->iterations);\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_DEFI,4) == 0)\n          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"DEFI chunk found in MNG-VLC datastream\",\"`%s'\",\n                image->filename);\n\n            if (length < 2)\n              {\n                if (chunk)\n                  chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n              }\n\n            object_id=(p[0] << 8) | p[1];\n\n            if (mng_type == 2 && object_id != 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"Nonzero object_id in MNG-LC datastream\",\"`%s'\",\n                image->filename);\n\n            if (object_id > MNG_MAX_OBJECTS)\n              {\n                /*\n                  Instead of using a warning we should allocate a larger\n                  MngInfo structure and continue.\n                */\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  CoderError,\"object id too large\",\"`%s'\",image->filename);\n                object_id=MNG_MAX_OBJECTS;\n              }\n\n            if (mng_info->exists[object_id])\n              if (mng_info->frozen[object_id])\n                {\n                  chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                  (void) ThrowMagickException(exception,\n                    GetMagickModule(),CoderError,\n                    \"DEFI cannot redefine a frozen MNG object\",\"`%s'\",\n                    image->filename);\n                  continue;\n                }\n\n            mng_info->exists[object_id]=MagickTrue;\n\n            if (length > 2)\n              mng_info->invisible[object_id]=p[2];\n\n            /*\n              Extract object offset info.\n            */\n            if (length > 11)\n              {\n                mng_info->x_off[object_id]=(ssize_t)\n                  (((png_uint_32) p[4] << 24) | ((png_uint_32) p[5] << 16) |\n                  ((png_uint_32) p[6] << 8) | (png_uint_32) p[7]);\n                mng_info->y_off[object_id]=(ssize_t)\n                  (((png_uint_32) p[8] << 24) | ((png_uint_32) p[9] << 16) |\n                  ((png_uint_32) p[10] << 8) | (png_uint_32) p[11]);\n                if (logging != MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"  x_off[%d]: %.20g,  y_off[%d]: %.20g\",\n                      object_id,(double) mng_info->x_off[object_id],\n                      object_id,(double) mng_info->y_off[object_id]);\n                  }\n              }\n\n            /*\n              Extract object clipping info.\n            */\n            if (length > 27)\n              mng_info->object_clip[object_id]=mng_read_box(mng_info->frame,0,\n                &p[12]);\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_bKGD,4) == 0)\n          {\n            mng_info->have_global_bkgd=MagickFalse;\n\n            if (length > 5)\n              {\n                mng_info->mng_global_bkgd.red=\n                  ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\n                mng_info->mng_global_bkgd.green=\n                  ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\n                mng_info->mng_global_bkgd.blue=\n                  ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\n                mng_info->have_global_bkgd=MagickTrue;\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_BACK,4) == 0)\n          {\n#if defined(MNG_INSERT_LAYERS)\n            if (length > 6)\n              mandatory_back=p[6];\n\n            else\n              mandatory_back=0;\n\n            if (mandatory_back && length > 5)\n              {\n                mng_background_color.red=\n                    ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\n                mng_background_color.green=\n                    ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\n                mng_background_color.blue=\n                    ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\n                mng_background_color.alpha=OpaqueAlpha;\n              }\n\n#ifdef MNG_OBJECT_BUFFERS\n            if (length > 8)\n              mng_background_object=(p[7] << 8) | p[8];\n#endif\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_PLTE,4) == 0)\n          {\n            /* Read global PLTE.  */\n\n            if (length && (length < 769))\n              {\n                if (mng_info->global_plte == (png_colorp) NULL)\n                  mng_info->global_plte=(png_colorp) AcquireQuantumMemory(256,\n                    sizeof(*mng_info->global_plte));\n\n                for (i=0; i < (ssize_t) (length/3); i++)\n                {\n                  mng_info->global_plte[i].red=p[3*i];\n                  mng_info->global_plte[i].green=p[3*i+1];\n                  mng_info->global_plte[i].blue=p[3*i+2];\n                }\n\n                mng_info->global_plte_length=(unsigned int) (length/3);\n              }\n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n            {\n              mng_info->global_plte[i].red=i;\n              mng_info->global_plte[i].green=i;\n              mng_info->global_plte[i].blue=i;\n            }\n\n            if (length != 0)\n              mng_info->global_plte_length=256;\n#endif\n            else\n              mng_info->global_plte_length=0;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_tRNS,4) == 0)\n          {\n            /* read global tRNS */\n\n            if (length > 0 && length < 257)\n              for (i=0; i < (ssize_t) length; i++)\n                mng_info->global_trns[i]=p[i];\n\n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n              mng_info->global_trns[i]=255;\n#endif\n            mng_info->global_trns_length=(unsigned int) length;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_gAMA,4) == 0)\n          {\n            if (length == 4)\n              {\n                ssize_t\n                  igamma;\n\n                igamma=mng_get_long(p);\n                mng_info->global_gamma=((float) igamma)*0.00001;\n                mng_info->have_global_gama=MagickTrue;\n              }\n\n            else\n              mng_info->have_global_gama=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_cHRM,4) == 0)\n          {\n            /* Read global cHRM */\n\n            if (length == 32)\n              {\n                mng_info->global_chrm.white_point.x=0.00001*mng_get_long(p);\n                mng_info->global_chrm.white_point.y=0.00001*mng_get_long(&p[4]);\n                mng_info->global_chrm.red_primary.x=0.00001*mng_get_long(&p[8]);\n                mng_info->global_chrm.red_primary.y=0.00001*\n                  mng_get_long(&p[12]);\n                mng_info->global_chrm.green_primary.x=0.00001*\n                  mng_get_long(&p[16]);\n                mng_info->global_chrm.green_primary.y=0.00001*\n                  mng_get_long(&p[20]);\n                mng_info->global_chrm.blue_primary.x=0.00001*\n                  mng_get_long(&p[24]);\n                mng_info->global_chrm.blue_primary.y=0.00001*\n                  mng_get_long(&p[28]);\n                mng_info->have_global_chrm=MagickTrue;\n              }\n            else\n              mng_info->have_global_chrm=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_sRGB,4) == 0)\n          {\n            /*\n              Read global sRGB.\n            */\n            if (length != 0)\n              {\n                mng_info->global_srgb_intent=\n                  Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n                mng_info->have_global_srgb=MagickTrue;\n              }\n            else\n              mng_info->have_global_srgb=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_iCCP,4) == 0)\n          {\n            /* To do: */\n\n            /*\n              Read global iCCP.\n            */\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_FRAM,4) == 0)\n          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"FRAM chunk found in MNG-VLC datastream\",\"`%s'\",\n                image->filename);\n\n            if ((mng_info->framing_mode == 2) || (mng_info->framing_mode == 4))\n              image->delay=frame_delay;\n\n            frame_delay=default_frame_delay;\n            frame_timeout=default_frame_timeout;\n            fb=default_fb;\n\n            if (length != 0)\n              if (p[0])\n                mng_info->framing_mode=p[0];\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Framing_mode=%d\",mng_info->framing_mode);\n\n            if (length > 6)\n              {\n                /* Note the delay and frame clipping boundaries.  */\n\n                p++; /* framing mode */\n\n                while (*p && ((p-chunk) < (ssize_t) length))\n                  p++;  /* frame name */\n\n                p++;  /* frame name terminator */\n\n                if ((p-chunk) < (ssize_t) (length-4))\n                  {\n                    int\n                      change_delay,\n                      change_timeout,\n                      change_clipping;\n\n                    change_delay=(*p++);\n                    change_timeout=(*p++);\n                    change_clipping=(*p++);\n                    p++; /* change_sync */\n\n                    if (change_delay && ((p-chunk) < (ssize_t) (length-4)))\n                      {\n                        frame_delay=1UL*image->ticks_per_second*\n                          mng_get_long(p);\n\n                        if (mng_info->ticks_per_second != 0)\n                          frame_delay/=mng_info->ticks_per_second;\n\n                        else\n                          frame_delay=PNG_UINT_31_MAX;\n\n                        if (change_delay == 2)\n                          default_frame_delay=frame_delay;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Framing_delay=%.20g\",(double) frame_delay);\n                      }\n\n                    if (change_timeout && ((p-chunk) < (ssize_t) (length-4)))\n                      {\n                        frame_timeout=1UL*image->ticks_per_second*\n                          mng_get_long(p);\n\n                        if (mng_info->ticks_per_second != 0)\n                          frame_timeout/=mng_info->ticks_per_second;\n\n                        else\n                          frame_timeout=PNG_UINT_31_MAX;\n\n                        if (change_timeout == 2)\n                          default_frame_timeout=frame_timeout;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Framing_timeout=%.20g\",(double) frame_timeout);\n                      }\n\n                    if (change_clipping && ((p-chunk) < (ssize_t) (length-16)))\n                      {\n                        fb=mng_read_box(previous_fb,(char) p[0],&p[1]);\n                        p+=16;\n                        previous_fb=fb;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Frame_clip: L=%.20g R=%.20g T=%.20g B=%.20g\",\n                            (double) fb.left,(double) fb.right,(double) fb.top,\n                            (double) fb.bottom);\n\n                        if (change_clipping == 2)\n                          default_fb=fb;\n                      }\n                  }\n              }\n            mng_info->clip=fb;\n            mng_info->clip=mng_minimum_box(fb,mng_info->frame);\n\n            subframe_width=(size_t) (mng_info->clip.right\n               -mng_info->clip.left);\n\n            subframe_height=(size_t) (mng_info->clip.bottom\n               -mng_info->clip.top);\n            /*\n              Insert a background layer behind the frame if framing_mode is 4.\n            */\n#if defined(MNG_INSERT_LAYERS)\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"   subframe_width=%.20g, subframe_height=%.20g\",(double)\n                subframe_width,(double) subframe_height);\n\n            if (insert_layers && (mng_info->framing_mode == 4) &&\n                (subframe_width) && (subframe_height))\n              {\n                /* Allocate next image structure.  */\n                if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n                  {\n                    AcquireNextImage(image_info,image,exception);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n\n                mng_info->image=image;\n\n                if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\n                image->columns=subframe_width;\n                image->rows=subframe_height;\n                image->page.width=subframe_width;\n                image->page.height=subframe_height;\n                image->page.x=mng_info->clip.left;\n                image->page.y=mng_info->clip.top;\n                image->background_color=mng_background_color;\n                image->alpha_trait=UndefinedPixelTrait;\n                image->delay=0;\n                (void) SetImageBackgroundColor(image,exception);\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Insert backgd layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                    (double) mng_info->clip.left,\n                    (double) mng_info->clip.right,\n                    (double) mng_info->clip.top,\n                    (double) mng_info->clip.bottom);\n              }\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_CLIP,4) == 0)\n          {\n            unsigned int\n              first_object,\n              last_object;\n\n            /*\n              Read CLIP.\n            */\n            if (length > 3)\n              {\n                first_object=(p[0] << 8) | p[1];\n                last_object=(p[2] << 8) | p[3];\n                p+=4;\n\n                for (i=(int) first_object; i <= (int) last_object; i++)\n                {\n                  if ((i < 0) || (i >= MNG_MAX_OBJECTS))\n                    continue;\n\n                  if (mng_info->exists[i] && !mng_info->frozen[i])\n                    {\n                      MngBox\n                        box;\n\n                      box=mng_info->object_clip[i];\n                      if ((p-chunk) < (ssize_t) (length-17))\n                        mng_info->object_clip[i]=\n                           mng_read_box(box,(char) p[0],&p[1]);\n                    }\n                }\n\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_SAVE,4) == 0)\n          {\n            for (i=1; i < MNG_MAX_OBJECTS; i++)\n              if (mng_info->exists[i])\n                {\n                 mng_info->frozen[i]=MagickTrue;\n#ifdef MNG_OBJECT_BUFFERS\n                 if (mng_info->ob[i] != (MngBuffer *) NULL)\n                    mng_info->ob[i]->frozen=MagickTrue;\n#endif\n                }\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if ((memcmp(type,mng_DISC,4) == 0) || (memcmp(type,mng_SEEK,4) == 0))\n          {\n            /* Read DISC or SEEK.  */\n\n            if ((length == 0) || !memcmp(type,mng_SEEK,4))\n              {\n                for (i=1; i < MNG_MAX_OBJECTS; i++)\n                  MngInfoDiscardObject(mng_info,i);\n              }\n\n            else\n              {\n                register ssize_t\n                  j;\n\n                for (j=1; j < (ssize_t) length; j+=2)\n                {\n                  i=p[j-1] << 8 | p[j];\n                  MngInfoDiscardObject(mng_info,i);\n                }\n              }\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MOVE,4) == 0)\n          {\n            size_t\n              first_object,\n              last_object;\n\n            /* read MOVE */\n\n            if (length > 3)\n            {\n              first_object=(p[0] << 8) | p[1];\n              last_object=(p[2] << 8) | p[3];\n              p+=4;\n\n              for (i=(ssize_t) first_object; i <= (ssize_t) last_object; i++)\n              {\n                if ((i < 0) || (i >= MNG_MAX_OBJECTS))\n                  continue;\n\n                if (mng_info->exists[i] && !mng_info->frozen[i] &&\n                    (p-chunk) < (ssize_t) (length-8))\n                  {\n                    MngPair\n                      new_pair;\n\n                    MngPair\n                      old_pair;\n\n                    old_pair.a=mng_info->x_off[i];\n                    old_pair.b=mng_info->y_off[i];\n                    new_pair=mng_read_pair(old_pair,(int) p[0],&p[1]);\n                    mng_info->x_off[i]=new_pair.a;\n                    mng_info->y_off[i]=new_pair.b;\n                  }\n              }\n            }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_LOOP,4) == 0)\n          {\n            ssize_t loop_iters=1;\n            if (length > 4)\n              {\n                loop_level=chunk[0];\n                mng_info->loop_active[loop_level]=1;  /* mark loop active */\n\n                /* Record starting point.  */\n                loop_iters=mng_get_long(&chunk[1]);\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  LOOP level %.20g has %.20g iterations \",\n                    (double) loop_level, (double) loop_iters);\n\n                if (loop_iters == 0)\n                  skipping_loop=loop_level;\n\n                else\n                  {\n                    mng_info->loop_jump[loop_level]=TellBlob(image);\n                    mng_info->loop_count[loop_level]=loop_iters;\n                  }\n\n                mng_info->loop_iteration[loop_level]=0;\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_ENDL,4) == 0)\n          {\n            if (length > 0)\n              {\n                loop_level=chunk[0];\n\n                if (skipping_loop > 0)\n                  {\n                    if (skipping_loop == loop_level)\n                      {\n                        /*\n                          Found end of zero-iteration loop.\n                        */\n                        skipping_loop=(-1);\n                        mng_info->loop_active[loop_level]=0;\n                      }\n                  }\n\n                else\n                  {\n                    if (mng_info->loop_active[loop_level] == 1)\n                      {\n                        mng_info->loop_count[loop_level]--;\n                        mng_info->loop_iteration[loop_level]++;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  ENDL: LOOP level %.20g has %.20g remaining iters\",\n                            (double) loop_level,(double)\n                            mng_info->loop_count[loop_level]);\n\n                        if (mng_info->loop_count[loop_level] != 0)\n                          {\n                            offset=\n                              SeekBlob(image,mng_info->loop_jump[loop_level],\n                              SEEK_SET);\n\n                            if (offset < 0)\n                              {\n                                chunk=(unsigned char *) RelinquishMagickMemory(\n                                  chunk);\n                                ThrowReaderException(CorruptImageError,\n                                  \"ImproperImageHeader\");\n                              }\n                          }\n\n                        else\n                          {\n                            short\n                              last_level;\n\n                            /*\n                              Finished loop.\n                            */\n                            mng_info->loop_active[loop_level]=0;\n                            last_level=(-1);\n                            for (i=0; i < loop_level; i++)\n                              if (mng_info->loop_active[i] == 1)\n                                last_level=(short) i;\n                            loop_level=last_level;\n                          }\n                      }\n                  }\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_CLON,4) == 0)\n          {\n            if (mng_info->clon_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"CLON is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->clon_warning++;\n          }\n\n        if (memcmp(type,mng_MAGN,4) == 0)\n          {\n            png_uint_16\n              magn_first,\n              magn_last,\n              magn_mb,\n              magn_ml,\n              magn_mr,\n              magn_mt,\n              magn_mx,\n              magn_my,\n              magn_methx,\n              magn_methy;\n\n            if (length > 1)\n              magn_first=(p[0] << 8) | p[1];\n\n            else\n              magn_first=0;\n\n            if (length > 3)\n              magn_last=(p[2] << 8) | p[3];\n\n            else\n              magn_last=magn_first;\n#ifndef MNG_OBJECT_BUFFERS\n            if (magn_first || magn_last)\n              if (mng_info->magn_warning == 0)\n                {\n                  (void) ThrowMagickException(exception,\n                     GetMagickModule(),CoderError,\n                     \"MAGN is not implemented yet for nonzero objects\",\n                     \"`%s'\",image->filename);\n\n                   mng_info->magn_warning++;\n                }\n#endif\n            if (length > 4)\n              magn_methx=p[4];\n\n            else\n              magn_methx=0;\n\n            if (length > 6)\n              magn_mx=(p[5] << 8) | p[6];\n\n            else\n              magn_mx=1;\n\n            if (magn_mx == 0)\n              magn_mx=1;\n\n            if (length > 8)\n              magn_my=(p[7] << 8) | p[8];\n\n            else\n              magn_my=magn_mx;\n\n            if (magn_my == 0)\n              magn_my=1;\n\n            if (length > 10)\n              magn_ml=(p[9] << 8) | p[10];\n\n            else\n              magn_ml=magn_mx;\n\n            if (magn_ml == 0)\n              magn_ml=1;\n\n            if (length > 12)\n              magn_mr=(p[11] << 8) | p[12];\n\n            else\n              magn_mr=magn_mx;\n\n            if (magn_mr == 0)\n              magn_mr=1;\n\n            if (length > 14)\n              magn_mt=(p[13] << 8) | p[14];\n\n            else\n              magn_mt=magn_my;\n\n            if (magn_mt == 0)\n              magn_mt=1;\n\n            if (length > 16)\n              magn_mb=(p[15] << 8) | p[16];\n\n            else\n              magn_mb=magn_my;\n\n            if (magn_mb == 0)\n              magn_mb=1;\n\n            if (length > 17)\n              magn_methy=p[17];\n\n            else\n              magn_methy=magn_methx;\n\n\n            if (magn_methx > 5 || magn_methy > 5)\n              if (mng_info->magn_warning == 0)\n                {\n                  (void) ThrowMagickException(exception,\n                     GetMagickModule(),CoderError,\n                     \"Unknown MAGN method in MNG datastream\",\"`%s'\",\n                     image->filename);\n\n                   mng_info->magn_warning++;\n                }\n#ifdef MNG_OBJECT_BUFFERS\n          /* Magnify existing objects in the range magn_first to magn_last */\n#endif\n            if (magn_first == 0 || magn_last == 0)\n              {\n                /* Save the magnification factors for object 0 */\n                mng_info->magn_mb=magn_mb;\n                mng_info->magn_ml=magn_ml;\n                mng_info->magn_mr=magn_mr;\n                mng_info->magn_mt=magn_mt;\n                mng_info->magn_mx=magn_mx;\n                mng_info->magn_my=magn_my;\n                mng_info->magn_methx=magn_methx;\n                mng_info->magn_methy=magn_methy;\n              }\n          }\n\n        if (memcmp(type,mng_PAST,4) == 0)\n          {\n            if (mng_info->past_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"PAST is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->past_warning++;\n          }\n\n        if (memcmp(type,mng_SHOW,4) == 0)\n          {\n            if (mng_info->show_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"SHOW is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->show_warning++;\n          }\n\n        if (memcmp(type,mng_sBIT,4) == 0)\n          {\n            if (length < 4)\n              mng_info->have_global_sbit=MagickFalse;\n\n            else\n              {\n                mng_info->global_sbit.gray=p[0];\n                mng_info->global_sbit.red=p[0];\n                mng_info->global_sbit.green=p[1];\n                mng_info->global_sbit.blue=p[2];\n                mng_info->global_sbit.alpha=p[3];\n                mng_info->have_global_sbit=MagickTrue;\n             }\n          }\n        if (memcmp(type,mng_pHYs,4) == 0)\n          {\n            if (length > 8)\n              {\n                mng_info->global_x_pixels_per_unit=\n                    (size_t) mng_get_long(p);\n                mng_info->global_y_pixels_per_unit=\n                    (size_t) mng_get_long(&p[4]);\n                mng_info->global_phys_unit_type=p[8];\n                mng_info->have_global_phys=MagickTrue;\n              }\n\n            else\n              mng_info->have_global_phys=MagickFalse;\n          }\n        if (memcmp(type,mng_pHYg,4) == 0)\n          {\n            if (mng_info->phyg_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"pHYg is not implemented.\",\"`%s'\",image->filename);\n\n            mng_info->phyg_warning++;\n          }\n        if (memcmp(type,mng_BASI,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->basi_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"BASI is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->basi_warning++;\n#ifdef MNG_BASI_SUPPORTED\n            basi_width=(unsigned long) (((png_uint_32) p[0] << 24) |\n              ((png_uint_32) p[1] << 16) | ((png_uint_32) p[2] << 8) |\n              (png_uint_32) p[3]);\n            basi_height=(unsigned long) (((png_uint_32) p[4] << 24) |\n              ((png_uint_32) p[5] << 16) | ((png_uint_32) p[6] << 8) |\n              (png_uint_32) p[7]);\n            basi_color_type=p[8];\n            basi_compression_method=p[9];\n            basi_filter_type=p[10];\n            basi_interlace_method=p[11];\n            if (length > 11)\n              basi_red=((png_uint_32) p[12] << 8) & (png_uint_32) p[13];\n\n            else\n              basi_red=0;\n\n            if (length > 13)\n              basi_green=((png_uint_32) p[14] << 8) & (png_uint_32) p[15];\n\n            else\n              basi_green=0;\n\n            if (length > 15)\n              basi_blue=((png_uint_32) p[16] << 8) & (png_uint_32) p[17];\n\n            else\n              basi_blue=0;\n\n            if (length > 17)\n              basi_alpha=((png_uint_32) p[18] << 8) & (png_uint_32) p[19];\n\n            else\n              {\n                if (basi_sample_depth == 16)\n                  basi_alpha=65535L;\n                else\n                  basi_alpha=255;\n              }\n\n            if (length > 19)\n              basi_viewable=p[20];\n\n            else\n              basi_viewable=0;\n\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_IHDR,4)\n#if defined(JNG_SUPPORTED)\n            && memcmp(type,mng_JHDR,4)\n#endif\n            )\n          {\n            /* Not an IHDR or JHDR chunk */\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n/* Process IHDR */\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Processing %c%c%c%c chunk\",type[0],type[1],type[2],type[3]);\n\n        mng_info->exists[object_id]=MagickTrue;\n        mng_info->viewable[object_id]=MagickTrue;\n\n        if (mng_info->invisible[object_id])\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Skipping invisible object\");\n\n            skip_to_iend=MagickTrue;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n#if defined(MNG_INSERT_LAYERS)\n        if (length < 8)\n          {\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          }\n\n        image_width=(size_t) mng_get_long(p);\n        image_height=(size_t) mng_get_long(&p[4]);\n#endif\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        /*\n          Insert a transparent background layer behind the entire animation\n          if it is not full screen.\n        */\n#if defined(MNG_INSERT_LAYERS)\n        if (insert_layers && mng_type && first_mng_object)\n          {\n            if ((mng_info->clip.left > 0) || (mng_info->clip.top > 0) ||\n                (image_width < mng_info->mng_width) ||\n                (mng_info->clip.right < (ssize_t) mng_info->mng_width) ||\n                (image_height < mng_info->mng_height) ||\n                (mng_info->clip.bottom < (ssize_t) mng_info->mng_height))\n              {\n                if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n                  {\n                    /*\n                      Allocate next image structure.\n                    */\n                    AcquireNextImage(image_info,image,exception);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n                mng_info->image=image;\n\n                if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\n                /* Make a background rectangle.  */\n\n                image->delay=0;\n                image->columns=mng_info->mng_width;\n                image->rows=mng_info->mng_height;\n                image->page.width=mng_info->mng_width;\n                image->page.height=mng_info->mng_height;\n                image->page.x=0;\n                image->page.y=0;\n                image->background_color=mng_background_color;\n                (void) SetImageBackgroundColor(image,exception);\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Inserted transparent background layer, W=%.20g, H=%.20g\",\n                    (double) mng_info->mng_width,(double) mng_info->mng_height);\n              }\n          }\n        /*\n          Insert a background layer behind the upcoming image if\n          framing_mode is 3, and we haven't already inserted one.\n        */\n        if (insert_layers && (mng_info->framing_mode == 3) &&\n                (subframe_width) && (subframe_height) && (simplicity == 0 ||\n                (simplicity & 0x08)))\n          {\n            if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n            {\n              /*\n                Allocate next image structure.\n              */\n              AcquireNextImage(image_info,image,exception);\n\n              if (GetNextImageInList(image) == (Image *) NULL)\n                return(DestroyImageList(image));\n\n              image=SyncNextImageInList(image);\n            }\n\n            mng_info->image=image;\n\n            if (term_chunk_found)\n              {\n                image->start_loop=MagickTrue;\n                image->iterations=mng_iterations;\n                term_chunk_found=MagickFalse;\n              }\n\n            else\n                image->start_loop=MagickFalse;\n\n            image->delay=0;\n            image->columns=subframe_width;\n            image->rows=subframe_height;\n            image->page.width=subframe_width;\n            image->page.height=subframe_height;\n            image->page.x=mng_info->clip.left;\n            image->page.y=mng_info->clip.top;\n            image->background_color=mng_background_color;\n            image->alpha_trait=UndefinedPixelTrait;\n            (void) SetImageBackgroundColor(image,exception);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Insert background layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                (double) mng_info->clip.left,(double) mng_info->clip.right,\n                (double) mng_info->clip.top,(double) mng_info->clip.bottom);\n          }\n#endif /* MNG_INSERT_LAYERS */\n        first_mng_object=MagickFalse;\n\n        if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n          {\n            /*\n              Allocate next image structure.\n            */\n            AcquireNextImage(image_info,image,exception);\n\n            if (GetNextImageInList(image) == (Image *) NULL)\n              return(DestroyImageList(image));\n\n            image=SyncNextImageInList(image);\n          }\n        mng_info->image=image;\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n\n        if (status == MagickFalse)\n          break;\n\n        if (term_chunk_found)\n          {\n            image->start_loop=MagickTrue;\n            term_chunk_found=MagickFalse;\n          }\n\n        else\n            image->start_loop=MagickFalse;\n\n        if (mng_info->framing_mode == 1 || mng_info->framing_mode == 3)\n          {\n            image->delay=frame_delay;\n            frame_delay=default_frame_delay;\n          }\n\n        else\n          image->delay=0;\n\n        image->page.width=mng_info->mng_width;\n        image->page.height=mng_info->mng_height;\n        image->page.x=mng_info->x_off[object_id];\n        image->page.y=mng_info->y_off[object_id];\n        image->iterations=mng_iterations;\n\n        /*\n          Seek back to the beginning of the IHDR or JHDR chunk's length field.\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Seeking back to beginning of %c%c%c%c chunk\",type[0],type[1],\n            type[2],type[3]);\n\n        offset=SeekBlob(image,-((ssize_t) length+12),SEEK_CUR);\n\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n\n    mng_info->image=image;\n    mng_info->mng_type=mng_type;\n    mng_info->object_id=object_id;\n\n    if (memcmp(type,mng_IHDR,4) == 0)\n      image=ReadOnePNGImage(mng_info,image_info,exception);\n\n#if defined(JNG_SUPPORTED)\n    else\n      image=ReadOneJNGImage(mng_info,image_info,exception);\n#endif\n\n    if (image == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"exit ReadJNGImage() with error\");\n\n        return((Image *) NULL);\n      }\n\n    if (image->columns == 0 || image->rows == 0)\n      {\n        (void) CloseBlob(image);\n        return(DestroyImageList(image));\n      }\n\n    mng_info->image=image;\n\n    if (mng_type)\n      {\n        MngBox\n          crop_box;\n\n        if (mng_info->magn_methx || mng_info->magn_methy)\n          {\n            png_uint_32\n               magnified_height,\n               magnified_width;\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Processing MNG MAGN chunk\");\n\n            if (mng_info->magn_methx == 1)\n              {\n                magnified_width=mng_info->magn_ml;\n\n                if (image->columns > 1)\n                   magnified_width += mng_info->magn_mr;\n\n                if (image->columns > 2)\n                   magnified_width += (png_uint_32)\n                      ((image->columns-2)*(mng_info->magn_mx));\n              }\n\n            else\n              {\n                magnified_width=(png_uint_32) image->columns;\n\n                if (image->columns > 1)\n                   magnified_width += mng_info->magn_ml-1;\n\n                if (image->columns > 2)\n                   magnified_width += mng_info->magn_mr-1;\n\n                if (image->columns > 3)\n                   magnified_width += (png_uint_32)\n                      ((image->columns-3)*(mng_info->magn_mx-1));\n              }\n\n            if (mng_info->magn_methy == 1)\n              {\n                magnified_height=mng_info->magn_mt;\n\n                if (image->rows > 1)\n                   magnified_height += mng_info->magn_mb;\n\n                if (image->rows > 2)\n                   magnified_height += (png_uint_32)\n                      ((image->rows-2)*(mng_info->magn_my));\n              }\n\n            else\n              {\n                magnified_height=(png_uint_32) image->rows;\n\n                if (image->rows > 1)\n                   magnified_height += mng_info->magn_mt-1;\n\n                if (image->rows > 2)\n                   magnified_height += mng_info->magn_mb-1;\n\n                if (image->rows > 3)\n                   magnified_height += (png_uint_32)\n                      ((image->rows-3)*(mng_info->magn_my-1));\n              }\n\n            if (magnified_height > image->rows ||\n                magnified_width > image->columns)\n              {\n                Image\n                  *large_image;\n\n                int\n                  yy;\n\n                Quantum\n                  *next,\n                  *prev;\n\n                png_uint_16\n                  magn_methx,\n                  magn_methy;\n\n                ssize_t\n                  m,\n                  y;\n\n                register Quantum\n                  *n,\n                  *q;\n\n                register ssize_t\n                  x;\n\n                /* Allocate next image structure.  */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Allocate magnified image\");\n\n                AcquireNextImage(image_info,image,exception);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return(DestroyImageList(image));\n\n                large_image=SyncNextImageInList(image);\n\n                large_image->columns=magnified_width;\n                large_image->rows=magnified_height;\n\n                magn_methx=mng_info->magn_methx;\n                magn_methy=mng_info->magn_methy;\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n#define QM unsigned short\n                if (magn_methx != 1 || magn_methy != 1)\n                  {\n                  /*\n                     Scale pixels to unsigned shorts to prevent\n                     overflow of intermediate values of interpolations\n                  */\n                     for (y=0; y < (ssize_t) image->rows; y++)\n                     {\n                       q=GetAuthenticPixels(image,0,y,image->columns,1,\n                          exception);\n\n                       for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                       {\n                          SetPixelRed(image,ScaleQuantumToShort(\n                            GetPixelRed(image,q)),q);\n                          SetPixelGreen(image,ScaleQuantumToShort(\n                            GetPixelGreen(image,q)),q);\n                          SetPixelBlue(image,ScaleQuantumToShort(\n                            GetPixelBlue(image,q)),q);\n                          SetPixelAlpha(image,ScaleQuantumToShort(\n                            GetPixelAlpha(image,q)),q);\n                          q+=GetPixelChannels(image);\n                       }\n\n                       if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                         break;\n                     }\n                  }\n#else\n#define QM Quantum\n#endif\n\n                if (image->alpha_trait != UndefinedPixelTrait)\n                   (void) SetImageBackgroundColor(large_image,exception);\n\n                else\n                  {\n                    large_image->background_color.alpha=OpaqueAlpha;\n                    (void) SetImageBackgroundColor(large_image,exception);\n\n                    if (magn_methx == 4)\n                      magn_methx=2;\n\n                    if (magn_methx == 5)\n                      magn_methx=3;\n\n                    if (magn_methy == 4)\n                      magn_methy=2;\n\n                    if (magn_methy == 5)\n                      magn_methy=3;\n                  }\n\n                /* magnify the rows into the right side of the large image */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Magnify the rows to %.20g\",\n                    (double) large_image->rows);\n                m=(ssize_t) mng_info->magn_mt;\n                yy=0;\n                length=(size_t) GetPixelChannels(image)*image->columns;\n                next=(Quantum *) AcquireQuantumMemory(length,sizeof(*next));\n                prev=(Quantum *) AcquireQuantumMemory(length,sizeof(*prev));\n\n                if ((prev == (Quantum *) NULL) ||\n                    (next == (Quantum *) NULL))\n                  {\n                     image=DestroyImageList(image);\n                     ThrowReaderException(ResourceLimitError,\n                       \"MemoryAllocationFailed\");\n                  }\n\n                n=GetAuthenticPixels(image,0,0,image->columns,1,exception);\n                (void) CopyMagickMemory(next,n,length);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n                {\n                  if (y == 0)\n                    m=(ssize_t) mng_info->magn_mt;\n\n                  else if (magn_methy > 1 && y == (ssize_t) image->rows-2)\n                    m=(ssize_t) mng_info->magn_mb;\n\n                  else if (magn_methy <= 1 && y == (ssize_t) image->rows-1)\n                    m=(ssize_t) mng_info->magn_mb;\n\n                  else if (magn_methy > 1 && y == (ssize_t) image->rows-1)\n                    m=1;\n\n                  else\n                    m=(ssize_t) mng_info->magn_my;\n\n                  n=prev;\n                  prev=next;\n                  next=n;\n\n                  if (y < (ssize_t) image->rows-1)\n                    {\n                      n=GetAuthenticPixels(image,0,y+1,image->columns,1,\n                          exception);\n                      (void) CopyMagickMemory(next,n,length);\n                    }\n\n                  for (i=0; i < m; i++, yy++)\n                  {\n                    register Quantum\n                      *pixels;\n\n                    assert(yy < (ssize_t) large_image->rows);\n                    pixels=prev;\n                    n=next;\n                    q=GetAuthenticPixels(large_image,0,yy,large_image->columns,\n                      1,exception);\n                    q+=(large_image->columns-image->columns)*\n                      GetPixelChannels(large_image);\n\n                    for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                    {\n                      /* To do: get color as function of indexes[x] */\n                      /*\n                      if (image->storage_class == PseudoClass)\n                        {\n                        }\n                      */\n\n                      if (magn_methy <= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRed(large_image,GetPixelRed(image,pixels),q);\n                          SetPixelGreen(large_image,GetPixelGreen(image,\n                             pixels),q);\n                          SetPixelBlue(large_image,GetPixelBlue(image,\n                             pixels),q);\n                          SetPixelAlpha(large_image,GetPixelAlpha(image,\n                             pixels),q);\n                        }\n\n                      else if (magn_methy == 2 || magn_methy == 4)\n                        {\n                          if (i == 0)\n                            {\n                              SetPixelRed(large_image,GetPixelRed(image,\n                                 pixels),q);\n                              SetPixelGreen(large_image,GetPixelGreen(image,\n                                 pixels),q);\n                              SetPixelBlue(large_image,GetPixelBlue(image,\n                                 pixels),q);\n                              SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                 pixels),q);\n                            }\n\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(large_image,((QM) (((ssize_t)\n                                 (2*i*(GetPixelRed(image,n)\n                                 -GetPixelRed(image,pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelRed(image,pixels)))),q);\n                              SetPixelGreen(large_image,((QM) (((ssize_t)\n                                 (2*i*(GetPixelGreen(image,n)\n                                 -GetPixelGreen(image,pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelGreen(image,pixels)))),q);\n                              SetPixelBlue(large_image,((QM) (((ssize_t)\n                                 (2*i*(GetPixelBlue(image,n)\n                                 -GetPixelBlue(image,pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelBlue(image,pixels)))),q);\n\n                              if (image->alpha_trait != UndefinedPixelTrait)\n                                 SetPixelAlpha(large_image, ((QM) (((ssize_t)\n                                    (2*i*(GetPixelAlpha(image,n)\n                                    -GetPixelAlpha(image,pixels)+m))\n                                    /((ssize_t) (m*2))+\n                                   GetPixelAlpha(image,pixels)))),q);\n                            }\n\n                          if (magn_methy == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i <= ((m+1) << 1))\n                                 SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                    pixels),q);\n                              else\n                                 SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                    n),q);\n                            }\n                        }\n\n                      else /* if (magn_methy == 3 || magn_methy == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n                          {\n                             SetPixelRed(large_image,GetPixelRed(image,\n                                    pixels),q);\n                             SetPixelGreen(large_image,GetPixelGreen(image,\n                                    pixels),q);\n                             SetPixelBlue(large_image,GetPixelBlue(image,\n                                    pixels),q);\n                             SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                    pixels),q);\n                          }\n\n                          else\n                          {\n                             SetPixelRed(large_image,GetPixelRed(image,n),q);\n                             SetPixelGreen(large_image,GetPixelGreen(image,n),\n                                    q);\n                             SetPixelBlue(large_image,GetPixelBlue(image,n),\n                                    q);\n                             SetPixelAlpha(large_image,GetPixelAlpha(image,n),\n                                    q);\n                          }\n\n                          if (magn_methy == 5)\n                            {\n                              SetPixelAlpha(large_image,(QM) (((ssize_t) (2*i*\n                                 (GetPixelAlpha(image,n)\n                                 -GetPixelAlpha(image,pixels))\n                                 +m))/((ssize_t) (m*2))\n                                 +GetPixelAlpha(image,pixels)),q);\n                            }\n                        }\n                      n+=GetPixelChannels(image);\n                      q+=GetPixelChannels(large_image);\n                      pixels+=GetPixelChannels(image);\n                    } /* x */\n\n                    if (SyncAuthenticPixels(large_image,exception) == 0)\n                      break;\n\n                  } /* i */\n                } /* y */\n\n                prev=(Quantum *) RelinquishMagickMemory(prev);\n                next=(Quantum *) RelinquishMagickMemory(next);\n\n                length=image->columns;\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Delete original image\");\n\n                DeleteImageFromList(&image);\n\n                image=large_image;\n\n                mng_info->image=image;\n\n                /* magnify the columns */\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Magnify the columns to %.20g\",\n                    (double) image->columns);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n                {\n                  register Quantum\n                    *pixels;\n\n                  q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n                  pixels=q+(image->columns-length)*GetPixelChannels(image);\n                  n=pixels+GetPixelChannels(image);\n\n                  for (x=(ssize_t) (image->columns-length);\n                    x < (ssize_t) image->columns; x++)\n                  {\n                    /* To do: Rewrite using Get/Set***PixelChannel() */\n\n                    if (x == (ssize_t) (image->columns-length))\n                      m=(ssize_t) mng_info->magn_ml;\n\n                    else if (magn_methx > 1 && x == (ssize_t) image->columns-2)\n                      m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx <= 1 &&\n                        x == (ssize_t) image->columns-1)\n                      m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx > 1 && x == (ssize_t) image->columns-1)\n                      m=1;\n\n                    else\n                      m=(ssize_t) mng_info->magn_mx;\n\n                    for (i=0; i < m; i++)\n                    {\n                      if (magn_methx <= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRed(image,GetPixelRed(image,pixels),q);\n                          SetPixelGreen(image,GetPixelGreen(image,pixels),q);\n                          SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n                          SetPixelAlpha(image,GetPixelAlpha(image,pixels),q);\n                        }\n\n                      else if (magn_methx == 2 || magn_methx == 4)\n                        {\n                          if (i == 0)\n                          {\n                            SetPixelRed(image,GetPixelRed(image,pixels),q);\n                            SetPixelGreen(image,GetPixelGreen(image,pixels),q);\n                            SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n                            SetPixelAlpha(image,GetPixelAlpha(image,pixels),q);\n                          }\n\n                          /* To do: Rewrite using Get/Set***PixelChannel() */\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(image,(QM) ((2*i*(\n                                 GetPixelRed(image,n)\n                                 -GetPixelRed(image,pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelRed(image,pixels)),q);\n\n                              SetPixelGreen(image,(QM) ((2*i*(\n                                 GetPixelGreen(image,n)\n                                 -GetPixelGreen(image,pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelGreen(image,pixels)),q);\n\n                              SetPixelBlue(image,(QM) ((2*i*(\n                                 GetPixelBlue(image,n)\n                                 -GetPixelBlue(image,pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelBlue(image,pixels)),q);\n                              if (image->alpha_trait != UndefinedPixelTrait)\n                                 SetPixelAlpha(image,(QM) ((2*i*(\n                                   GetPixelAlpha(image,n)\n                                   -GetPixelAlpha(image,pixels))+m)\n                                   /((ssize_t) (m*2))+\n                                   GetPixelAlpha(image,pixels)),q);\n                            }\n\n                          if (magn_methx == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i <= ((m+1) << 1))\n                              {\n                                 SetPixelAlpha(image,\n                                   GetPixelAlpha(image,pixels)+0,q);\n                              }\n                              else\n                              {\n                                 SetPixelAlpha(image,\n                                   GetPixelAlpha(image,n)+0,q);\n                              }\n                            }\n                        }\n\n                      else /* if (magn_methx == 3 || magn_methx == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n                          {\n                             SetPixelRed(image,GetPixelRed(image,pixels),q);\n                             SetPixelGreen(image,GetPixelGreen(image,\n                                 pixels),q);\n                             SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n                             SetPixelAlpha(image,GetPixelAlpha(image,\n                                 pixels),q);\n                          }\n\n                          else\n                          {\n                             SetPixelRed(image,GetPixelRed(image,n),q);\n                             SetPixelGreen(image,GetPixelGreen(image,n),q);\n                             SetPixelBlue(image,GetPixelBlue(image,n),q);\n                             SetPixelAlpha(image,GetPixelAlpha(image,n),q);\n                          }\n\n                          if (magn_methx == 5)\n                            {\n                              /* Interpolate */\n                              SetPixelAlpha(image,\n                                 (QM) ((2*i*( GetPixelAlpha(image,n)\n                                 -GetPixelAlpha(image,pixels))+m)/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelAlpha(image,pixels)),q);\n                            }\n                        }\n                      q+=GetPixelChannels(image);\n                    }\n                    n+=GetPixelChannels(image);\n                  }\n\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                    break;\n                }\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n              if (magn_methx != 1 || magn_methy != 1)\n                {\n                /*\n                   Rescale pixels to Quantum\n                */\n                   for (y=0; y < (ssize_t) image->rows; y++)\n                   {\n                     q=GetAuthenticPixels(image,0,y,image->columns,1,\n                       exception);\n\n                     for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                     {\n                        SetPixelRed(image,ScaleShortToQuantum(\n                          GetPixelRed(image,q)),q);\n                        SetPixelGreen(image,ScaleShortToQuantum(\n                          GetPixelGreen(image,q)),q);\n                        SetPixelBlue(image,ScaleShortToQuantum(\n                          GetPixelBlue(image,q)),q);\n                        SetPixelAlpha(image,ScaleShortToQuantum(\n                          GetPixelAlpha(image,q)),q);\n                        q+=GetPixelChannels(image);\n                     }\n\n                     if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                       break;\n                   }\n                }\n#endif\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Finished MAGN processing\");\n              }\n          }\n\n        /*\n          Crop_box is with respect to the upper left corner of the MNG.\n        */\n        crop_box.left=mng_info->image_box.left+mng_info->x_off[object_id];\n        crop_box.right=mng_info->image_box.right+mng_info->x_off[object_id];\n        crop_box.top=mng_info->image_box.top+mng_info->y_off[object_id];\n        crop_box.bottom=mng_info->image_box.bottom+mng_info->y_off[object_id];\n        crop_box=mng_minimum_box(crop_box,mng_info->clip);\n        crop_box=mng_minimum_box(crop_box,mng_info->frame);\n        crop_box=mng_minimum_box(crop_box,mng_info->object_clip[object_id]);\n        if ((crop_box.left != (mng_info->image_box.left\n            +mng_info->x_off[object_id])) ||\n            (crop_box.right != (mng_info->image_box.right\n            +mng_info->x_off[object_id])) ||\n            (crop_box.top != (mng_info->image_box.top\n            +mng_info->y_off[object_id])) ||\n            (crop_box.bottom != (mng_info->image_box.bottom\n            +mng_info->y_off[object_id])))\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Crop the PNG image\");\n\n            if ((crop_box.left < crop_box.right) &&\n                (crop_box.top < crop_box.bottom))\n              {\n                Image\n                  *im;\n\n                RectangleInfo\n                  crop_info;\n\n                /*\n                  Crop_info is with respect to the upper left corner of\n                  the image.\n                */\n                crop_info.x=(crop_box.left-mng_info->x_off[object_id]);\n                crop_info.y=(crop_box.top-mng_info->y_off[object_id]);\n                crop_info.width=(size_t) (crop_box.right-crop_box.left);\n                crop_info.height=(size_t) (crop_box.bottom-crop_box.top);\n                image->page.width=image->columns;\n                image->page.height=image->rows;\n                image->page.x=0;\n                image->page.y=0;\n                im=CropImage(image,&crop_info,exception);\n\n                if (im != (Image *) NULL)\n                  {\n                    image->columns=im->columns;\n                    image->rows=im->rows;\n                    im=DestroyImage(im);\n                    image->page.width=image->columns;\n                    image->page.height=image->rows;\n                    image->page.x=crop_box.left;\n                    image->page.y=crop_box.top;\n                  }\n              }\n\n            else\n              {\n                /*\n                  No pixels in crop area.  The MNG spec still requires\n                  a layer, though, so make a single transparent pixel in\n                  the top left corner.\n                */\n                image->columns=1;\n                image->rows=1;\n                image->colors=2;\n                (void) SetImageBackgroundColor(image,exception);\n                image->page.width=1;\n                image->page.height=1;\n                image->page.x=0;\n                image->page.y=0;\n              }\n          }\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n        image=mng_info->image;\n#endif\n      }\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n      /* PNG does not handle depths greater than 16 so reduce it even\n       * if lossy.\n       */\n      if (image->depth > 16)\n         image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 8)\n      if (image->depth > 8)\n        {\n          /* To do: fill low byte properly */\n          image->depth=16;\n        }\n\n      if (LosslessReduceDepthOK(image,exception) != MagickFalse)\n         image->depth = 8;\n#endif\n\n      if (image_info->number_scenes != 0)\n        {\n          if (mng_info->scenes_found >\n             (ssize_t) (image_info->first_scene+image_info->number_scenes))\n            break;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Finished reading image datastream.\");\n\n  } while (LocaleCompare(image_info->magick,\"MNG\") == 0);\n\n  (void) CloseBlob(image);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Finished reading all image datastreams.\");\n\n#if defined(MNG_INSERT_LAYERS)\n  if (insert_layers && !mng_info->image_found && (mng_info->mng_width) &&\n       (mng_info->mng_height))\n    {\n      /*\n        Insert a background layer if nothing else was found.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  No images found.  Inserting a background layer.\");\n\n      if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n        {\n          /*\n            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image,exception);\n          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n              if (logging != MagickFalse)\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Allocation failed, returning NULL.\");\n\n              return(DestroyImageList(image));;\n            }\n          image=SyncNextImageInList(image);\n        }\n      image->columns=mng_info->mng_width;\n      image->rows=mng_info->mng_height;\n      image->page.width=mng_info->mng_width;\n      image->page.height=mng_info->mng_height;\n      image->page.x=0;\n      image->page.y=0;\n      image->background_color=mng_background_color;\n      image->alpha_trait=UndefinedPixelTrait;\n\n      if (image_info->ping == MagickFalse)\n        (void) SetImageBackgroundColor(image,exception);\n\n      mng_info->image_found++;\n    }\n#endif\n  image->iterations=mng_iterations;\n\n  if (mng_iterations == 1)\n    image->start_loop=MagickTrue;\n\n  while (GetPreviousImageInList(image) != (Image *) NULL)\n  {\n    image_count++;\n    if (image_count > 10*mng_info->image_found)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  No beginning\");\n\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CoderError,\"Linked list is corrupted, beginning of list not found\",\n          \"`%s'\",image_info->filename);\n\n        return(DestroyImageList(image));\n      }\n\n    image=GetPreviousImageInList(image);\n\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Corrupt list\");\n\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CoderError,\"Linked list is corrupted; next_image is NULL\",\"`%s'\",\n          image_info->filename);\n      }\n  }\n\n  if (mng_info->ticks_per_second && mng_info->image_found > 1 &&\n             GetNextImageInList(image) ==\n     (Image *) NULL)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  First image null\");\n\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CoderError,\"image->next for first image is NULL but shouldn't be.\",\n        \"`%s'\",image_info->filename);\n    }\n\n  if (mng_info->image_found == 0)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  No visible images found.\");\n\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CoderError,\"No visible images in file\",\"`%s'\",image_info->filename);\n\n      return(DestroyImageList(image));\n    }\n\n  if (mng_info->ticks_per_second)\n    final_delay=1UL*MagickMax(image->ticks_per_second,1L)*\n            final_delay/mng_info->ticks_per_second;\n\n  else\n    image->start_loop=MagickTrue;\n\n  /* Find final nonzero image delay */\n  final_image_delay=0;\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n    {\n      if (image->delay)\n        final_image_delay=image->delay;\n\n      image=GetNextImageInList(image);\n    }\n\n  if (final_delay < final_image_delay)\n    final_delay=final_image_delay;\n\n  image->delay=final_delay;\n\n  if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  image->delay=%.20g, final_delay=%.20g\",(double) image->delay,\n        (double) final_delay);\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Before coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    scene 0 delay=%.20g\",(double) image->delay);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene %.20g delay=%.20g\",(double) scene++,\n          (double) image->delay);\n      }\n    }\n\n  image=GetFirstImageInList(image);\n#ifdef MNG_COALESCE_LAYERS\n  if (insert_layers)\n    {\n      Image\n        *next_image,\n        *next;\n\n      size_t\n        scene;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Coalesce Images\");\n\n      scene=image->scene;\n      next_image=CoalesceImages(image,exception);\n\n      if (next_image == (Image *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n      image=DestroyImageList(image);\n      image=next_image;\n\n      for (next=image; next != (Image *) NULL; next=next_image)\n      {\n         next->page.width=mng_info->mng_width;\n         next->page.height=mng_info->mng_height;\n         next->page.x=0;\n         next->page.y=0;\n         next->scene=scene++;\n         next_image=GetNextImageInList(next);\n\n         if (next_image == (Image *) NULL)\n           break;\n\n         if (next->delay == 0)\n           {\n             scene--;\n             next_image->previous=GetPreviousImageInList(next);\n             if (GetPreviousImageInList(next) == (Image *) NULL)\n               image=next_image;\n             else\n               next->previous->next=next_image;\n             next=DestroyImage(next);\n           }\n      }\n    }\n#endif\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n      image=GetNextImageInList(image);\n\n  image->dispose=BackgroundDispose;\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  After coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    scene 0 delay=%.20g dispose=%.20g\",(double) image->delay,\n        (double) image->dispose);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene %.20g delay=%.20g dispose=%.20g\",(double) scene++,\n          (double) image->delay,(double) image->dispose);\n      }\n   }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneMNGImage();\");\n\n  return(image);\n}\n\nstatic Image *ReadMNGImage(const ImageInfo *image_info,\n     ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    logging,\n    status;\n\n  MngInfo\n    *mng_info;\n\n  /* Open image file.  */\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n     image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\"Enter ReadMNGImage()\");\n  image=AcquireImage(image_info,exception);\n  mng_info=(MngInfo *) NULL;\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n\n  if (status == MagickFalse)\n    return((Image *) NULL);\n\n  /* Allocate a MngInfo structure.  */\n\n  mng_info=(MngInfo *) AcquireMagickMemory(sizeof(MngInfo));\n\n  if (mng_info == (MngInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* Initialize members of the MngInfo structure.  */\n\n  (void) ResetMagickMemory(mng_info,0,sizeof(MngInfo));\n  mng_info->image=image;\n  image=ReadOneMNGImage(mng_info,image_info,exception);\n  mng_info=MngInfoFreeStruct(mng_info);\n\n  if (image == (Image *) NULL)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"exit ReadMNGImage() with error\");\n\n      return((Image *) NULL);\n    }\n  (void) CloseBlob(image);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"exit ReadMNGImage()\");\n\n  return(GetFirstImageInList(image));\n}\n#else /* PNG_LIBPNG_VER > 10011 */\nstatic Image *ReadPNGImage(const ImageInfo *image_info,\n   ExceptionInfo *exception)\n{\n  printf(\"Your PNG library is too old: You have libpng-%s\\n\",\n     PNG_LIBPNG_VER_STRING);\n\n  (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n    \"PNG library is too old\",\"`%s'\",image_info->filename);\n\n  return(Image *) NULL;\n}\n\nstatic Image *ReadMNGImage(const ImageInfo *image_info,\n   ExceptionInfo *exception)\n{\n  return(ReadPNGImage(image_info,exception));\n}\n#endif /* PNG_LIBPNG_VER > 10011 */\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P N G I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPNGImage() adds properties for the PNG image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterPNGImage method is:\n%\n%      size_t RegisterPNGImage(void)\n%\n*/\nModuleExport size_t RegisterPNGImage(void)\n{\n  char\n    version[MagickPathExtent];\n\n  MagickInfo\n    *entry;\n\n  static const char\n    *PNGNote=\n    {\n      \"See http://www.libpng.org/ for details about the PNG format.\"\n    },\n\n    *JNGNote=\n    {\n      \"See http://www.libpng.org/pub/mng/ for details about the JNG\\n\"\n      \"format.\"\n    },\n\n    *MNGNote=\n    {\n      \"See http://www.libpng.org/pub/mng/ for details about the MNG\\n\"\n      \"format.\"\n    };\n\n  *version='\\0';\n\n#if defined(PNG_LIBPNG_VER_STRING)\n  (void) ConcatenateMagickString(version,\"libpng \",MagickPathExtent);\n  (void) ConcatenateMagickString(version,PNG_LIBPNG_VER_STRING,\n   MagickPathExtent);\n\n  if (LocaleCompare(PNG_LIBPNG_VER_STRING,png_get_header_ver(NULL)) != 0)\n    {\n      (void) ConcatenateMagickString(version,\",\",MagickPathExtent);\n      (void) ConcatenateMagickString(version,png_get_libpng_ver(NULL),\n            MagickPathExtent);\n    }\n#endif\n\n  entry=AcquireMagickInfo(\"PNG\",\"MNG\",\"Multiple-image Network Graphics\");\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n\n#if defined(MAGICKCORE_PNG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadMNGImage;\n  entry->encoder=(EncodeImageHandler *) WriteMNGImage;\n#endif\n\n  entry->magick=(IsImageFormatHandler *) IsMNG;\n\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n\n  entry->mime_type=ConstantString(\"video/x-mng\");\n  entry->note=ConstantString(MNGNote);\n  (void) RegisterMagickInfo(entry);\n\n  entry=AcquireMagickInfo(\"PNG\",\"PNG\",\"Portable Network Graphics\");\n\n#if defined(MAGICKCORE_PNG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadPNGImage;\n  entry->encoder=(EncodeImageHandler *) WritePNGImage;\n#endif\n\n  entry->magick=(IsImageFormatHandler *) IsPNG;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->mime_type=ConstantString(\"image/png\");\n\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n\n  entry->note=ConstantString(PNGNote);\n  (void) RegisterMagickInfo(entry);\n\n  entry=AcquireMagickInfo(\"PNG\",\"PNG8\",\n    \"8-bit indexed with optional binary transparency\");\n\n#if defined(MAGICKCORE_PNG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadPNGImage;\n  entry->encoder=(EncodeImageHandler *) WritePNGImage;\n#endif\n\n  entry->magick=(IsImageFormatHandler *) IsPNG;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->mime_type=ConstantString(\"image/png\");\n  (void) RegisterMagickInfo(entry);\n\n  entry=AcquireMagickInfo(\"PNG\",\"PNG24\",\n    \"opaque or binary transparent 24-bit RGB\");\n  *version='\\0';\n\n#if defined(ZLIB_VERSION)\n  (void) ConcatenateMagickString(version,\"zlib \",MagickPathExtent);\n  (void) ConcatenateMagickString(version,ZLIB_VERSION,MagickPathExtent);\n\n  if (LocaleCompare(ZLIB_VERSION,zlib_version) != 0)\n    {\n      (void) ConcatenateMagickString(version,\",\",MagickPathExtent);\n      (void) ConcatenateMagickString(version,zlib_version,MagickPathExtent);\n    }\n#endif\n\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n\n#if defined(MAGICKCORE_PNG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadPNGImage;\n  entry->encoder=(EncodeImageHandler *) WritePNGImage;\n#endif\n\n  entry->magick=(IsImageFormatHandler *) IsPNG;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->mime_type=ConstantString(\"image/png\");\n  (void) RegisterMagickInfo(entry);\n\n  entry=AcquireMagickInfo(\"PNG\",\"PNG32\",\"opaque or transparent 32-bit RGBA\");\n\n#if defined(MAGICKCORE_PNG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadPNGImage;\n  entry->encoder=(EncodeImageHandler *) WritePNGImage;\n#endif\n\n  entry->magick=(IsImageFormatHandler *) IsPNG;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->mime_type=ConstantString(\"image/png\");\n  (void) RegisterMagickInfo(entry);\n\n  entry=AcquireMagickInfo(\"PNG\",\"PNG48\",\n    \"opaque or binary transparent 48-bit RGB\");\n\n#if defined(MAGICKCORE_PNG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadPNGImage;\n  entry->encoder=(EncodeImageHandler *) WritePNGImage;\n#endif\n\n  entry->magick=(IsImageFormatHandler *) IsPNG;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->mime_type=ConstantString(\"image/png\");\n  (void) RegisterMagickInfo(entry);\n\n  entry=AcquireMagickInfo(\"PNG\",\"PNG64\",\"opaque or transparent 64-bit RGBA\");\n\n#if defined(MAGICKCORE_PNG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadPNGImage;\n  entry->encoder=(EncodeImageHandler *) WritePNGImage;\n#endif\n\n  entry->magick=(IsImageFormatHandler *) IsPNG;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->mime_type=ConstantString(\"image/png\");\n  (void) RegisterMagickInfo(entry);\n\n  entry=AcquireMagickInfo(\"PNG\",\"PNG00\",\n    \"PNG inheriting bit-depth, color-type from original, if possible\");\n\n#if defined(MAGICKCORE_PNG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadPNGImage;\n  entry->encoder=(EncodeImageHandler *) WritePNGImage;\n#endif\n\n  entry->magick=(IsImageFormatHandler *) IsPNG;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->mime_type=ConstantString(\"image/png\");\n  (void) RegisterMagickInfo(entry);\n\n  entry=AcquireMagickInfo(\"PNG\",\"JNG\",\"JPEG Network Graphics\");\n\n#if defined(JNG_SUPPORTED)\n#if defined(MAGICKCORE_PNG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJNGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJNGImage;\n#endif\n#endif\n\n  entry->magick=(IsImageFormatHandler *) IsJNG;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->mime_type=ConstantString(\"image/x-jng\");\n  entry->note=ConstantString(JNGNote);\n  (void) RegisterMagickInfo(entry);\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  ping_semaphore=AcquireSemaphoreInfo();\n#endif\n\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P N G I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPNGImage() removes format registrations made by the\n%  PNG module from the list of supported formats.\n%\n%  The format of the UnregisterPNGImage method is:\n%\n%      UnregisterPNGImage(void)\n%\n*/\nModuleExport void UnregisterPNGImage(void)\n{\n  (void) UnregisterMagickInfo(\"MNG\");\n  (void) UnregisterMagickInfo(\"PNG\");\n  (void) UnregisterMagickInfo(\"PNG8\");\n  (void) UnregisterMagickInfo(\"PNG24\");\n  (void) UnregisterMagickInfo(\"PNG32\");\n  (void) UnregisterMagickInfo(\"PNG48\");\n  (void) UnregisterMagickInfo(\"PNG64\");\n  (void) UnregisterMagickInfo(\"PNG00\");\n  (void) UnregisterMagickInfo(\"JNG\");\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  if (ping_semaphore != (SemaphoreInfo *) NULL)\n    RelinquishSemaphoreInfo(&ping_semaphore);\n#endif\n}\n\f\n#if defined(MAGICKCORE_PNG_DELEGATE)\n#if PNG_LIBPNG_VER > 10011\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e M N G I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteMNGImage() writes an image in the Portable Network Graphics\n%  Group's \"Multiple-image Network Graphics\" encoded image format.\n%\n%  MNG support written by Glenn Randers-Pehrson, glennrp@image...\n%\n%  The format of the WriteMNGImage method is:\n%\n%      MagickBooleanType WriteMNGImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n%  To do (as of version 5.5.2, November 26, 2002 -- glennrp -- see also\n%    \"To do\" under ReadPNGImage):\n%\n%    Preserve all unknown and not-yet-handled known chunks found in input\n%    PNG file and copy them  into output PNG files according to the PNG\n%    copying rules.\n%\n%    Write the iCCP chunk at MNG level when (icc profile length > 0)\n%\n%    Improve selection of color type (use indexed-colour or indexed-colour\n%    with tRNS when 256 or fewer unique RGBA values are present).\n%\n%    Figure out what to do with \"dispose=<restore-to-previous>\" (dispose == 3)\n%    This will be complicated if we limit ourselves to generating MNG-LC\n%    files.  For now we ignore disposal method 3 and simply overlay the next\n%    image on it.\n%\n%    Check for identical PLTE's or PLTE/tRNS combinations and use a\n%    global MNG PLTE or PLTE/tRNS combination when appropriate.\n%    [mostly done 15 June 1999 but still need to take care of tRNS]\n%\n%    Check for identical sRGB and replace with a global sRGB (and remove\n%    gAMA/cHRM if sRGB is found; check for identical gAMA/cHRM and\n%    replace with global gAMA/cHRM (or with sRGB if appropriate; replace\n%    local gAMA/cHRM with local sRGB if appropriate).\n%\n%    Check for identical sBIT chunks and write global ones.\n%\n%    Provide option to skip writing the signature tEXt chunks.\n%\n%    Use signatures to detect identical objects and reuse the first\n%    instance of such objects instead of writing duplicate objects.\n%\n%    Use a smaller-than-32k value of compression window size when\n%    appropriate.\n%\n%    Encode JNG datastreams.  Mostly done as of 5.5.2; need to write\n%    ancillary text chunks and save profiles.\n%\n%    Provide an option to force LC files (to ensure exact framing rate)\n%    instead of VLC.\n%\n%    Provide an option to force VLC files instead of LC, even when offsets\n%    are present.  This will involve expanding the embedded images with a\n%    transparent region at the top and/or left.\n*/\n\nstatic void\nMagick_png_write_raw_profile(const ImageInfo *image_info,png_struct *ping,\n   png_info *ping_info, unsigned char *profile_type, unsigned char\n   *profile_description, unsigned char *profile_data, png_uint_32 length)\n{\n   png_textp\n     text;\n\n   register ssize_t\n     i;\n\n   unsigned char\n     *sp;\n\n   png_charp\n     dp;\n\n   png_uint_32\n     allocated_length,\n     description_length;\n\n   unsigned char\n     hex[16]={'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};\n\n   if (LocaleNCompare((char *) profile_type+1, \"ng-chunk-\",9) == 0)\n      return;\n\n   if (image_info->verbose)\n     {\n       (void) printf(\"writing raw profile: type=%s, length=%.20g\\n\",\n         (char *) profile_type, (double) length);\n     }\n\n#if PNG_LIBPNG_VER >= 10400\n   text=(png_textp) png_malloc(ping,(png_alloc_size_t) sizeof(png_text));\n#else\n   text=(png_textp) png_malloc(ping,(png_size_t) sizeof(png_text));\n#endif\n   description_length=(png_uint_32) strlen((const char *) profile_description);\n   allocated_length=(png_uint_32) (length*2 + (length >> 5) + 20\n      + description_length);\n#if PNG_LIBPNG_VER >= 10400\n   text[0].text=(png_charp) png_malloc(ping,\n      (png_alloc_size_t) allocated_length);\n   text[0].key=(png_charp) png_malloc(ping, (png_alloc_size_t) 80);\n#else\n   text[0].text=(png_charp) png_malloc(ping, (png_size_t) allocated_length);\n   text[0].key=(png_charp) png_malloc(ping, (png_size_t) 80);\n#endif\n   text[0].key[0]='\\0';\n   (void) ConcatenateMagickString(text[0].key,\n      \"Raw profile type \",MagickPathExtent);\n   (void) ConcatenateMagickString(text[0].key,(const char *) profile_type,62);\n   sp=profile_data;\n   dp=text[0].text;\n   *dp++='\\n';\n   (void) CopyMagickString(dp,(const char *) profile_description,\n     allocated_length);\n   dp+=description_length;\n   *dp++='\\n';\n   (void) FormatLocaleString(dp,allocated_length-\n     (png_size_t) (dp-text[0].text),\"%8lu \",(unsigned long) length);\n   dp+=8;\n\n   for (i=0; i < (ssize_t) length; i++)\n   {\n     if (i%36 == 0)\n       *dp++='\\n';\n     *(dp++)=(char) hex[((*sp >> 4) & 0x0f)];\n     *(dp++)=(char) hex[((*sp++ ) & 0x0f)];\n   }\n\n   *dp++='\\n';\n   *dp='\\0';\n   text[0].text_length=(png_size_t) (dp-text[0].text);\n   text[0].compression=image_info->compression == NoCompression ||\n     (image_info->compression == UndefinedCompression &&\n     text[0].text_length < 128) ? -1 : 0;\n\n   if (text[0].text_length <= allocated_length)\n     png_set_text(ping,ping_info,text,1);\n\n   png_free(ping,text[0].text);\n   png_free(ping,text[0].key);\n   png_free(ping,text);\n}\n\nstatic MagickBooleanType Magick_png_write_chunk_from_profile(Image *image,\n  const char *string, MagickBooleanType logging)\n{\n  char\n    *name;\n\n  const StringInfo\n    *profile;\n\n  unsigned char\n    *data;\n\n  png_uint_32 length;\n\n  ResetImageProfileIterator(image);\n\n  for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n  {\n    profile=GetImageProfile(image,name);\n\n    if (profile != (const StringInfo *) NULL)\n      {\n        StringInfo\n          *ping_profile;\n\n        if (LocaleNCompare(name,string,11) == 0)\n          {\n            if (logging != MagickFalse)\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Found %s profile\",name);\n\n            ping_profile=CloneStringInfo(profile);\n            data=GetStringInfoDatum(ping_profile),\n            length=(png_uint_32) GetStringInfoLength(ping_profile);\n            data[4]=data[3];\n            data[3]=data[2];\n            data[2]=data[1];\n            data[1]=data[0];\n            (void) WriteBlobMSBULong(image,length-5);  /* data length */\n            (void) WriteBlob(image,length-1,data+1);\n            (void) WriteBlobMSBULong(image,crc32(0,data+1,(uInt) length-1));\n            ping_profile=DestroyStringInfo(ping_profile);\n          }\n      }\n\n      name=GetNextImageProfile(image);\n   }\n\n   return(MagickTrue);\n}\n\nstatic inline MagickBooleanType Magick_png_color_equal(const Image *image,\n  const Quantum *p, const PixelInfo *q)\n{\n  MagickRealType\n    value;\n\n  value=(MagickRealType) p[image->channel_map[RedPixelChannel].offset];\n  if (AbsolutePixelValue(value-q->red) >= MagickEpsilon)\n    return(MagickFalse);\n  value=(MagickRealType) p[image->channel_map[GreenPixelChannel].offset];\n  if (AbsolutePixelValue(value-q->green) >= MagickEpsilon)\n    return(MagickFalse);\n  value=(MagickRealType) p[image->channel_map[BluePixelChannel].offset];\n  if (AbsolutePixelValue(value-q->blue) >= MagickEpsilon)\n    return(MagickFalse);\n\n  return(MagickTrue);\n}\n\n#if defined(PNG_tIME_SUPPORTED)\nstatic void write_tIME_chunk(Image *image,png_struct *ping,png_info *info,\n  const char *date,ExceptionInfo *exception)\n{\n  unsigned int\n    day,\n    hour,\n    minute,\n    month,\n    second,\n    year;\n\n  png_time\n    ptime;\n\n  time_t\n    ttime;\n\n  if (date != (const char *) NULL)\n    {\n      if (sscanf(date,\"%d-%d-%dT%d:%d:%dZ\",&year,&month,&day,&hour,&minute,\n          &second) != 6)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"Invalid date format specified for png:tIME\",\"`%s'\",\n            image->filename);\n          return;\n        }\n      ptime.year=(png_uint_16) year;\n      ptime.month=(png_byte) month;\n      ptime.day=(png_byte) day;\n      ptime.hour=(png_byte) hour;\n      ptime.minute=(png_byte) minute;\n      ptime.second=(png_byte) second;\n    }\n  else\n  {\n    time(&ttime);\n    png_convert_from_time_t(&ptime,ttime);\n  }\n  png_set_tIME(ping,info,&ptime);\n}\n#endif\n\n/* Write one PNG image */\nstatic MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,\n  const ImageInfo *IMimage_info,Image *IMimage,ExceptionInfo *exception)\n{\n  char\n    im_vers[32],\n    libpng_runv[32],\n    libpng_vers[32],\n    zlib_runv[32],\n    zlib_vers[32];\n\n  Image\n    *image;\n\n  ImageInfo\n    *image_info;\n\n  char\n    s[2];\n\n  const char\n    *name,\n    *property,\n    *value;\n\n  const StringInfo\n    *profile;\n\n  int\n    num_passes,\n    pass,\n    ping_wrote_caNv;\n\n  png_byte\n     ping_trans_alpha[256];\n\n  png_color\n     palette[257];\n\n  png_color_16\n    ping_background,\n    ping_trans_color;\n\n  png_info\n    *ping_info;\n\n  png_struct\n    *ping;\n\n  png_uint_32\n    ping_height,\n    ping_width;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    image_matte,\n    logging,\n    matte,\n\n    ping_have_blob,\n    ping_have_cheap_transparency,\n    ping_have_color,\n    ping_have_non_bw,\n    ping_have_PLTE,\n    ping_have_bKGD,\n    ping_have_eXIf,\n    ping_have_iCCP,\n    ping_have_pHYs,\n    ping_have_sRGB,\n    ping_have_tRNS,\n\n    ping_exclude_bKGD,\n    ping_exclude_cHRM,\n    ping_exclude_date,\n    /* ping_exclude_EXIF, */\n    ping_exclude_eXIf,\n    ping_exclude_gAMA,\n    ping_exclude_iCCP,\n    /* ping_exclude_iTXt, */\n    ping_exclude_oFFs,\n    ping_exclude_pHYs,\n    ping_exclude_sRGB,\n    ping_exclude_tEXt,\n    ping_exclude_tIME,\n    /* ping_exclude_tRNS, */\n    ping_exclude_vpAg,\n    ping_exclude_caNv,\n    ping_exclude_zCCP, /* hex-encoded iCCP */\n    ping_exclude_zTXt,\n\n    ping_preserve_colormap,\n    ping_preserve_iCCP,\n    ping_need_colortype_warning,\n\n    status,\n    tried_332,\n    tried_333,\n    tried_444;\n\n  MemoryInfo\n    *volatile pixel_info;\n\n  QuantumInfo\n    *quantum_info;\n\n  PNGErrorInfo\n    error_info;\n\n  register ssize_t\n    i,\n    x;\n\n  unsigned char\n    *ping_pixels;\n\n  volatile int\n    image_colors,\n    ping_bit_depth,\n    ping_color_type,\n    ping_interlace_method,\n    ping_compression_method,\n    ping_filter_method,\n    ping_num_trans;\n\n  volatile size_t\n    image_depth,\n    old_bit_depth;\n\n  size_t\n    quality,\n    rowbytes,\n    save_image_depth;\n\n  int\n    j,\n    number_colors,\n    number_opaque,\n    number_semitransparent,\n    number_transparent,\n    ping_pHYs_unit_type;\n\n  png_uint_32\n    ping_pHYs_x_resolution,\n    ping_pHYs_y_resolution;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter WriteOnePNGImage()\");\n\n  image = CloneImage(IMimage,0,0,MagickFalse,exception);\n  if (image == (Image *) NULL)\n    return(MagickFalse);\n  image_info=(ImageInfo *) CloneImageInfo(IMimage_info);\n  if (image_info == (ImageInfo *) NULL)\n    ThrowWriterException(ResourceLimitError, \"MemoryAllocationFailed\");\n\n  /* Define these outside of the following \"if logging()\" block so they will\n   * show in debuggers.\n   */\n  *im_vers='\\0';\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibVersionText,MagickPathExtent);\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibAddendum,MagickPathExtent);\n\n  *libpng_vers='\\0';\n  (void) ConcatenateMagickString(libpng_vers,\n         PNG_LIBPNG_VER_STRING,32);\n  *libpng_runv='\\0';\n  (void) ConcatenateMagickString(libpng_runv,\n         png_get_libpng_ver(NULL),32);\n\n  *zlib_vers='\\0';\n  (void) ConcatenateMagickString(zlib_vers,\n         ZLIB_VERSION,32);\n  *zlib_runv='\\0';\n  (void) ConcatenateMagickString(zlib_runv,\n         zlib_version,32);\n\n  if (logging != MagickFalse)\n    {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    IM version     = %s\",\n           im_vers);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    Libpng version = %s\",\n           libpng_vers);\n       if (LocaleCompare(libpng_vers,libpng_runv) != 0)\n       {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n           libpng_runv);\n       }\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    Zlib version   = %s\",\n           zlib_vers);\n       if (LocaleCompare(zlib_vers,zlib_runv) != 0)\n       {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n           zlib_runv);\n       }\n    }\n\n  /* Initialize some stuff */\n  ping_bit_depth=0,\n  ping_color_type=0,\n  ping_interlace_method=0,\n  ping_compression_method=0,\n  ping_filter_method=0,\n  ping_num_trans = 0;\n\n  ping_background.red = 0;\n  ping_background.green = 0;\n  ping_background.blue = 0;\n  ping_background.gray = 0;\n  ping_background.index = 0;\n\n  ping_trans_color.red=0;\n  ping_trans_color.green=0;\n  ping_trans_color.blue=0;\n  ping_trans_color.gray=0;\n\n  ping_pHYs_unit_type = 0;\n  ping_pHYs_x_resolution = 0;\n  ping_pHYs_y_resolution = 0;\n\n  ping_have_blob=MagickFalse;\n  ping_have_cheap_transparency=MagickFalse;\n  ping_have_color=MagickTrue;\n  ping_have_non_bw=MagickTrue;\n  ping_have_PLTE=MagickFalse;\n  ping_have_bKGD=MagickFalse;\n  ping_have_eXIf=MagickTrue;\n  ping_have_iCCP=MagickFalse;\n  ping_have_pHYs=MagickFalse;\n  ping_have_sRGB=MagickFalse;\n  ping_have_tRNS=MagickFalse;\n\n  ping_exclude_bKGD=mng_info->ping_exclude_bKGD;\n  ping_exclude_caNv=mng_info->ping_exclude_caNv;\n  ping_exclude_cHRM=mng_info->ping_exclude_cHRM;\n  ping_exclude_date=mng_info->ping_exclude_date;\n  ping_exclude_eXIf=mng_info->ping_exclude_eXIf;\n  ping_exclude_gAMA=mng_info->ping_exclude_gAMA;\n  ping_exclude_iCCP=mng_info->ping_exclude_iCCP;\n  /* ping_exclude_iTXt=mng_info->ping_exclude_iTXt; */\n  ping_exclude_oFFs=mng_info->ping_exclude_oFFs;\n  ping_exclude_pHYs=mng_info->ping_exclude_pHYs;\n  ping_exclude_sRGB=mng_info->ping_exclude_sRGB;\n  ping_exclude_tEXt=mng_info->ping_exclude_tEXt;\n  ping_exclude_tIME=mng_info->ping_exclude_tIME;\n  /* ping_exclude_tRNS=mng_info->ping_exclude_tRNS; */\n  ping_exclude_vpAg=mng_info->ping_exclude_vpAg;\n  ping_exclude_zCCP=mng_info->ping_exclude_zCCP; /* hex-encoded iCCP in zTXt */\n  ping_exclude_zTXt=mng_info->ping_exclude_zTXt;\n\n  ping_preserve_colormap = mng_info->ping_preserve_colormap;\n  ping_preserve_iCCP = mng_info->ping_preserve_iCCP;\n  ping_need_colortype_warning = MagickFalse;\n\n  /* Recognize the ICC sRGB profile and convert it to the sRGB chunk,\n   * i.e., eliminate the ICC profile and set image->rendering_intent.\n   * Note that this will not involve any changes to the actual pixels\n   * but merely passes information to applications that read the resulting\n   * PNG image.\n   *\n   * To do: recognize other variants of the sRGB profile, using the CRC to\n   * verify all recognized variants including the 7 already known.\n   *\n   * Work around libpng16+ rejecting some \"known invalid sRGB profiles\".\n   *\n   * Use something other than image->rendering_intent to record the fact\n   * that the sRGB profile was found.\n   *\n   * Record the ICC version (currently v2 or v4) of the incoming sRGB ICC\n   * profile.  Record the Blackpoint Compensation, if any.\n   */\n   if (ping_exclude_sRGB == MagickFalse && ping_preserve_iCCP == MagickFalse)\n   {\n      char\n        *name;\n\n      const StringInfo\n        *profile;\n\n      ResetImageProfileIterator(image);\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        profile=GetImageProfile(image,name);\n\n        if (profile != (StringInfo *) NULL)\n          {\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0))\n\n             {\n                 int\n                   icheck,\n                   got_crc=0;\n\n\n                 png_uint_32\n                   length,\n                   profile_crc=0;\n\n                 unsigned char\n                   *data;\n\n                 length=(png_uint_32) GetStringInfoLength(profile);\n\n                 for (icheck=0; sRGB_info[icheck].len > 0; icheck++)\n                 {\n                   if (length == sRGB_info[icheck].len)\n                   {\n                     if (got_crc == 0)\n                     {\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Got a %lu-byte ICC profile (potentially sRGB)\",\n                         (unsigned long) length);\n\n                       data=GetStringInfoDatum(profile);\n                       profile_crc=crc32(0,data,length);\n\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"      with crc=%8x\",(unsigned int) profile_crc);\n                       got_crc++;\n                     }\n\n                     if (profile_crc == sRGB_info[icheck].crc)\n                     {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"      It is sRGB with rendering intent = %s\",\n                        Magick_RenderingIntentString_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent));\n                        if (image->rendering_intent==UndefinedIntent)\n                        {\n                          image->rendering_intent=\n                          Magick_RenderingIntent_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent);\n                        }\n                        ping_exclude_iCCP = MagickTrue;\n                        ping_exclude_zCCP = MagickTrue;\n                        ping_have_sRGB = MagickTrue;\n                        break;\n                     }\n                   }\n                 }\n                 if (sRGB_info[icheck].len == 0)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"    Got %lu-byte ICC profile not recognized as sRGB\",\n                        (unsigned long) length);\n              }\n          }\n        name=GetNextImageProfile(image);\n      }\n  }\n\n  number_opaque = 0;\n  number_semitransparent = 0;\n  number_transparent = 0;\n\n  if (logging != MagickFalse)\n    {\n      if (image->storage_class == UndefinedClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=UndefinedClass\");\n      if (image->storage_class == DirectClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=DirectClass\");\n      if (image->storage_class == PseudoClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=PseudoClass\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(), image->taint ?\n          \"    image->taint=MagickTrue\":\n          \"    image->taint=MagickFalse\");\n    }\n\n  if (image->storage_class == PseudoClass &&\n     (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32 ||\n     mng_info->write_png48 || mng_info->write_png64 ||\n     (mng_info->write_png_colortype != 1 &&\n     mng_info->write_png_colortype != 5)))\n    {\n      (void) SyncImage(image,exception);\n      image->storage_class = DirectClass;\n    }\n\n  if (ping_preserve_colormap == MagickFalse)\n    {\n      if (image->storage_class != PseudoClass && image->colormap != NULL)\n        {\n          /* Free the bogus colormap; it can cause trouble later */\n           if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Freeing bogus colormap\");\n           (void) RelinquishMagickMemory(image->colormap);\n           image->colormap=NULL;\n        }\n    }\n\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n\n  /*\n    Sometimes we get PseudoClass images whose RGB values don't match\n    the colors in the colormap.  This code syncs the RGB values.\n  */\n  if (image->depth <= 8 && image->taint && image->storage_class == PseudoClass)\n     (void) SyncImage(image,exception);\n\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n  if (image->depth > 8)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Reducing PNG bit depth to 8 since this is a Q8 build.\");\n\n      image->depth=8;\n    }\n#endif\n\n  /* Respect the -depth option */\n  if (image->depth < 4)\n    {\n       register Quantum\n         *r;\n\n       if (image->depth > 2)\n         {\n           /* Scale to 4-bit */\n           LBR04PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR04PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR04PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n       else if (image->depth > 1)\n         {\n           /* Scale to 2-bit */\n           LBR02PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR02PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR02PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n       else\n         {\n           /* Scale to 1-bit */\n           LBR01PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR01PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR01PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n    }\n\n  /* To do: set to next higher multiple of 8 */\n  if (image->depth < 8)\n     image->depth=8;\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n  /* PNG does not handle depths greater than 16 so reduce it even\n   * if lossy\n   */\n  if (image->depth > 8)\n      image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 8)\n  if (image->depth > 8)\n    {\n      /* To do: fill low byte properly */\n      image->depth=16;\n    }\n\n  if (image->depth == 16 && mng_info->write_png_depth != 16)\n    if (mng_info->write_png8 ||\n        LosslessReduceDepthOK(image,exception) != MagickFalse)\n      image->depth = 8;\n#endif\n\n  image_colors = (int) image->colors;\n  number_opaque = (int) image->colors;\n  number_transparent = 0;\n  number_semitransparent = 0;\n\n  if (mng_info->write_png_colortype &&\n     (mng_info->write_png_colortype > 4 || (mng_info->write_png_depth >= 8 &&\n     mng_info->write_png_colortype < 4 &&\n     image->alpha_trait == UndefinedPixelTrait)))\n  {\n     /* Avoid the expensive BUILD_PALETTE operation if we're sure that we\n      * are not going to need the result.\n      */\n     if (mng_info->write_png_colortype == 1 ||\n        mng_info->write_png_colortype == 5)\n       ping_have_color=MagickFalse;\n\n     if (image->alpha_trait != UndefinedPixelTrait)\n       {\n         number_transparent = 2;\n         number_semitransparent = 1;\n       }\n  }\n\n  if (mng_info->write_png_colortype < 7)\n  {\n  /* BUILD_PALETTE\n   *\n   * Normally we run this just once, but in the case of writing PNG8\n   * we reduce the transparency to binary and run again, then if there\n   * are still too many colors we reduce to a simple 4-4-4-1, then 3-3-3-1\n   * RGBA palette and run again, and then to a simple 3-3-2-1 RGBA\n   * palette.  Then (To do) we take care of a final reduction that is only\n   * needed if there are still 256 colors present and one of them has both\n   * transparent and opaque instances.\n   */\n\n  tried_332 = MagickFalse;\n  tried_333 = MagickFalse;\n  tried_444 = MagickFalse;\n\n  for (j=0; j<6; j++)\n  {\n    /*\n     * Sometimes we get DirectClass images that have 256 colors or fewer.\n     * This code will build a colormap.\n     *\n     * Also, sometimes we get PseudoClass images with an out-of-date\n     * colormap.  This code will replace the colormap with a new one.\n     * Sometimes we get PseudoClass images that have more than 256 colors.\n     * This code will delete the colormap and change the image to\n     * DirectClass.\n     *\n     * If image->alpha_trait is MagickFalse, we ignore the alpha channel\n     * even though it sometimes contains left-over non-opaque values.\n     *\n     * Also we gather some information (number of opaque, transparent,\n     * and semitransparent pixels, and whether the image has any non-gray\n     * pixels or only black-and-white pixels) that we might need later.\n     *\n     * Even if the user wants to force GrayAlpha or RGBA (colortype 4 or 6)\n     * we need to check for bogus non-opaque values, at least.\n     */\n\n   int\n     n;\n\n   PixelInfo\n     opaque[260],\n     semitransparent[260],\n     transparent[260];\n\n   register const Quantum\n     *s;\n\n   register Quantum\n     *q,\n     *r;\n\n   if (logging != MagickFalse)\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"    Enter BUILD_PALETTE:\");\n\n   if (logging != MagickFalse)\n     {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->columns=%.20g\",(double) image->columns);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->rows=%.20g\",(double) image->rows);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->alpha_trait=%.20g\",(double) image->alpha_trait);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->depth=%.20g\",(double) image->depth);\n\n       if (image->storage_class == PseudoClass && image->colormap != NULL)\n       {\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      Original colormap:\");\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"        i    (red,green,blue,alpha)\");\n\n         for (i=0; i < 256; i++)\n         {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"        %d    (%d,%d,%d,%d)\",\n                    (int) i,\n                    (int) image->colormap[i].red,\n                    (int) image->colormap[i].green,\n                    (int) image->colormap[i].blue,\n                    (int) image->colormap[i].alpha);\n         }\n\n         for (i=image->colors - 10; i < (ssize_t) image->colors; i++)\n         {\n           if (i > 255)\n             {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"        %d    (%d,%d,%d,%d)\",\n                    (int) i,\n                    (int) image->colormap[i].red,\n                    (int) image->colormap[i].green,\n                    (int) image->colormap[i].blue,\n                    (int) image->colormap[i].alpha);\n             }\n         }\n       }\n\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"      image->colors=%d\",(int) image->colors);\n\n       if (image->colors == 0)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"        (zero means unknown)\");\n\n       if (ping_preserve_colormap == MagickFalse)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"      Regenerate the colormap\");\n     }\n\n     image_colors=0;\n     number_opaque = 0;\n     number_semitransparent = 0;\n     number_transparent = 0;\n\n     for (y=0; y < (ssize_t) image->rows; y++)\n     {\n       q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n       if (q == (Quantum *) NULL)\n         break;\n\n       for (x=0; x < (ssize_t) image->columns; x++)\n       {\n           if (image->alpha_trait == UndefinedPixelTrait ||\n              GetPixelAlpha(image,q) == OpaqueAlpha)\n             {\n               if (number_opaque < 259)\n                 {\n                   if (number_opaque == 0)\n                     {\n                       GetPixelInfoPixel(image, q, opaque);\n                       opaque[0].alpha=OpaqueAlpha;\n                       number_opaque=1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_opaque; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,opaque+i))\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_opaque && number_opaque < 259)\n                     {\n                       number_opaque++;\n                       GetPixelInfoPixel(image, q, opaque+i);\n                       opaque[i].alpha=OpaqueAlpha;\n                     }\n                 }\n             }\n           else if (GetPixelAlpha(image,q) == TransparentAlpha)\n             {\n               if (number_transparent < 259)\n                 {\n                   if (number_transparent == 0)\n                     {\n                       GetPixelInfoPixel(image, q, transparent);\n                       ping_trans_color.red=(unsigned short)\n                         GetPixelRed(image,q);\n                       ping_trans_color.green=(unsigned short)\n                         GetPixelGreen(image,q);\n                       ping_trans_color.blue=(unsigned short)\n                         GetPixelBlue(image,q);\n                       ping_trans_color.gray=(unsigned short)\n                         GetPixelGray(image,q);\n                       number_transparent = 1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_transparent; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,transparent+i))\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_transparent &&\n                       number_transparent < 259)\n                     {\n                       number_transparent++;\n                       GetPixelInfoPixel(image,q,transparent+i);\n                     }\n                 }\n             }\n           else\n             {\n               if (number_semitransparent < 259)\n                 {\n                   if (number_semitransparent == 0)\n                     {\n                       GetPixelInfoPixel(image,q,semitransparent);\n                       number_semitransparent = 1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_semitransparent; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,semitransparent+i)\n                           && GetPixelAlpha(image,q) ==\n                           semitransparent[i].alpha)\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_semitransparent &&\n                       number_semitransparent < 259)\n                     {\n                       number_semitransparent++;\n                       GetPixelInfoPixel(image, q, semitransparent+i);\n                     }\n                 }\n             }\n           q+=GetPixelChannels(image);\n        }\n     }\n\n     if (mng_info->write_png8 == MagickFalse &&\n         ping_exclude_bKGD == MagickFalse)\n       {\n         /* Add the background color to the palette, if it\n          * isn't already there.\n          */\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      Check colormap for background (%d,%d,%d)\",\n                  (int) image->background_color.red,\n                  (int) image->background_color.green,\n                  (int) image->background_color.blue);\n            }\n          for (i=0; i<number_opaque; i++)\n          {\n             if (opaque[i].red == image->background_color.red &&\n                 opaque[i].green == image->background_color.green &&\n                 opaque[i].blue == image->background_color.blue)\n               break;\n          }\n          if (number_opaque < 259 && i == number_opaque)\n            {\n               opaque[i] = image->background_color;\n               ping_background.index = i;\n               number_opaque++;\n               if (logging != MagickFalse)\n                 {\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"      background_color index is %d\",(int) i);\n                 }\n\n            }\n          else if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      No room in the colormap to add background color\");\n       }\n\n     image_colors=number_opaque+number_transparent+number_semitransparent;\n\n     if (logging != MagickFalse)\n       {\n         if (image_colors > 256)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      image has more than 256 colors\");\n\n         else\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      image has %d colors\",image_colors);\n       }\n\n     if (ping_preserve_colormap != MagickFalse)\n       break;\n\n     if (mng_info->write_png_colortype != 7) /* We won't need this info */\n       {\n         ping_have_color=MagickFalse;\n         ping_have_non_bw=MagickFalse;\n\n         if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n         {\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"incompatible colorspace\");\n           ping_have_color=MagickTrue;\n           ping_have_non_bw=MagickTrue;\n         }\n\n         if(image_colors > 256)\n           {\n             for (y=0; y < (ssize_t) image->rows; y++)\n             {\n               q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n               if (q == (Quantum *) NULL)\n                 break;\n\n               s=q;\n               for (x=0; x < (ssize_t) image->columns; x++)\n               {\n                 if (GetPixelRed(image,s) != GetPixelGreen(image,s) ||\n                     GetPixelRed(image,s) != GetPixelBlue(image,s))\n                   {\n                      ping_have_color=MagickTrue;\n                      ping_have_non_bw=MagickTrue;\n                      break;\n                   }\n                 s+=GetPixelChannels(image);\n               }\n\n               if (ping_have_color != MagickFalse)\n                 break;\n\n               /* Worst case is black-and-white; we are looking at every\n                * pixel twice.\n                */\n\n               if (ping_have_non_bw == MagickFalse)\n                 {\n                   s=q;\n                   for (x=0; x < (ssize_t) image->columns; x++)\n                   {\n                     if (GetPixelRed(image,s) != 0 &&\n                         GetPixelRed(image,s) != QuantumRange)\n                       {\n                         ping_have_non_bw=MagickTrue;\n                         break;\n                       }\n                     s+=GetPixelChannels(image);\n                   }\n               }\n             }\n           }\n       }\n\n     if (image_colors < 257)\n       {\n         PixelInfo\n           colormap[260];\n\n         /*\n          * Initialize image colormap.\n          */\n\n         if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      Sort the new colormap\");\n\n        /* Sort palette, transparent first */;\n\n         n = 0;\n\n         for (i=0; i<number_transparent; i++)\n            colormap[n++] = transparent[i];\n\n         for (i=0; i<number_semitransparent; i++)\n            colormap[n++] = semitransparent[i];\n\n         for (i=0; i<number_opaque; i++)\n            colormap[n++] = opaque[i];\n\n         ping_background.index +=\n           (number_transparent + number_semitransparent);\n\n         /* image_colors < 257; search the colormap instead of the pixels\n          * to get ping_have_color and ping_have_non_bw\n          */\n         for (i=0; i<n; i++)\n         {\n           if (ping_have_color == MagickFalse)\n             {\n                if (colormap[i].red != colormap[i].green ||\n                    colormap[i].red != colormap[i].blue)\n                  {\n                     ping_have_color=MagickTrue;\n                     ping_have_non_bw=MagickTrue;\n                     break;\n                  }\n              }\n\n           if (ping_have_non_bw == MagickFalse)\n             {\n               if (colormap[i].red != 0 && colormap[i].red != QuantumRange)\n                   ping_have_non_bw=MagickTrue;\n             }\n          }\n\n        if ((mng_info->ping_exclude_tRNS == MagickFalse ||\n            (number_transparent == 0 && number_semitransparent == 0)) &&\n            (((mng_info->write_png_colortype-1) ==\n            PNG_COLOR_TYPE_PALETTE) ||\n            (mng_info->write_png_colortype == 0)))\n          {\n            if (logging != MagickFalse)\n              {\n                if (n !=  (ssize_t) image_colors)\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"   image_colors (%d) and n (%d)  don't match\",\n                   image_colors, n);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      AcquireImageColormap\");\n              }\n\n            image->colors = image_colors;\n\n            if (AcquireImageColormap(image,image_colors,exception) ==\n                MagickFalse)\n               ThrowWriterException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");\n\n            for (i=0; i< (ssize_t) image_colors; i++)\n               image->colormap[i] = colormap[i];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"      image->colors=%d (%d)\",\n                      (int) image->colors, image_colors);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"      Update the pixel indexes\");\n              }\n\n            /* Sync the pixel indices with the new colormap */\n\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n              if (q == (Quantum *) NULL)\n                break;\n\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                for (i=0; i< (ssize_t) image_colors; i++)\n                {\n                  if ((image->alpha_trait == UndefinedPixelTrait ||\n                      image->colormap[i].alpha == GetPixelAlpha(image,q)) &&\n                      image->colormap[i].red == GetPixelRed(image,q) &&\n                      image->colormap[i].green == GetPixelGreen(image,q) &&\n                      image->colormap[i].blue == GetPixelBlue(image,q))\n                  {\n                    SetPixelIndex(image,i,q);\n                    break;\n                  }\n                }\n                q+=GetPixelChannels(image);\n              }\n\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                 break;\n            }\n          }\n       }\n\n     if (logging != MagickFalse)\n       {\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      image->colors=%d\", (int) image->colors);\n\n         if (image->colormap != NULL)\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"       i     (red,green,blue,alpha)\");\n\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               if (i < 300 || i >= (ssize_t) image->colors - 10)\n                 {\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"       %d     (%d,%d,%d,%d)\",\n                        (int) i,\n                        (int) image->colormap[i].red,\n                        (int) image->colormap[i].green,\n                        (int) image->colormap[i].blue,\n                        (int) image->colormap[i].alpha);\n                 }\n             }\n           }\n\n           if (number_transparent < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_transparent     = %d\",\n                   number_transparent);\n           else\n\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_transparent     > 256\");\n\n           if (number_opaque < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_opaque          = %d\",\n                   number_opaque);\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_opaque          > 256\");\n\n           if (number_semitransparent < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_semitransparent = %d\",\n                   number_semitransparent);\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_semitransparent > 256\");\n\n           if (ping_have_non_bw == MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      All pixels and the background are black or white\");\n\n           else if (ping_have_color == MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      All pixels and the background are gray\");\n\n           else\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      At least one pixel or the background is non-gray\");\n\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Exit BUILD_PALETTE:\");\n       }\n\n   if (mng_info->write_png8 == MagickFalse)\n      break;\n\n   /* Make any reductions necessary for the PNG8 format */\n    if (image_colors <= 256 &&\n        image_colors != 0 && image->colormap != NULL &&\n        number_semitransparent == 0 &&\n        number_transparent <= 1)\n      break;\n\n    /* PNG8 can't have semitransparent colors so we threshold the\n     * opacity to 0 or OpaqueOpacity, and PNG8 can only have one\n     * transparent color so if more than one is transparent we merge\n     * them into image->background_color.\n     */\n    if (number_semitransparent != 0 || number_transparent > 1)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Thresholding the alpha channel to binary\");\n\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n          if (r == (Quantum *) NULL)\n            break;\n\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n              if (GetPixelAlpha(image,r) < OpaqueAlpha/2)\n                {\n                  SetPixelViaPixelInfo(image,&image->background_color,r);\n                  SetPixelAlpha(image,TransparentAlpha,r);\n                }\n              else\n                  SetPixelAlpha(image,OpaqueAlpha,r);\n              r+=GetPixelChannels(image);\n          }\n\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n\n          if (image_colors != 0 && image_colors <= 256 &&\n             image->colormap != NULL)\n            for (i=0; i<image_colors; i++)\n                image->colormap[i].alpha =\n                    (image->colormap[i].alpha > TransparentAlpha/2 ?\n                    TransparentAlpha : OpaqueAlpha);\n        }\n      continue;\n    }\n\n    /* PNG8 can't have more than 256 colors so we quantize the pixels and\n     * background color to the 4-4-4-1, 3-3-3-1 or 3-3-2-1 palette.  If the\n     * image is mostly gray, the 4-4-4-1 palette is likely to end up with 256\n     * colors or less.\n     */\n    if (tried_444 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 4-4-4\");\n\n        tried_444 = MagickTrue;\n\n        LBR04PacketRGB(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 4-4-4\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR04PixelRGB(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 4-4-4\");\n\n          for (i=0; i<image_colors; i++)\n          {\n            LBR04PacketRGB(image->colormap[i]);\n          }\n        }\n        continue;\n      }\n\n    if (tried_333 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 3-3-3\");\n\n        tried_333 = MagickTrue;\n\n        LBR03PacketRGB(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 3-3-3-1\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR03RGB(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 3-3-3-1\");\n          for (i=0; i<image_colors; i++)\n          {\n              LBR03PacketRGB(image->colormap[i]);\n          }\n        }\n        continue;\n      }\n\n    if (tried_332 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 3-3-2\");\n\n        tried_332 = MagickTrue;\n\n        /* Red and green were already done so we only quantize the blue\n         * channel\n         */\n\n        LBR02PacketBlue(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 3-3-2-1\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR02PixelBlue(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 3-3-2-1\");\n          for (i=0; i<image_colors; i++)\n          {\n              LBR02PacketBlue(image->colormap[i]);\n          }\n      }\n      continue;\n    }\n\n    if (image_colors == 0 || image_colors > 256)\n    {\n      /* Take care of special case with 256 opaque colors + 1 transparent\n       * color.  We don't need to quantize to 2-3-2-1; we only need to\n       * eliminate one color, so we'll merge the two darkest red\n       * colors (0x49, 0, 0) -> (0x24, 0, 0).\n       */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Merging two dark red background colors to 3-3-2-1\");\n\n      if (ScaleQuantumToChar(image->background_color.red) == 0x49 &&\n          ScaleQuantumToChar(image->background_color.green) == 0x00 &&\n          ScaleQuantumToChar(image->background_color.blue) == 0x00)\n      {\n         image->background_color.red=ScaleCharToQuantum(0x24);\n      }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Merging two dark red pixel colors to 3-3-2-1\");\n\n      if (image->colormap == NULL)\n      {\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n          if (r == (Quantum *) NULL)\n            break;\n\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (ScaleQuantumToChar(GetPixelRed(image,r)) == 0x49 &&\n                ScaleQuantumToChar(GetPixelGreen(image,r)) == 0x00 &&\n                ScaleQuantumToChar(GetPixelBlue(image,r)) == 0x00 &&\n                GetPixelAlpha(image,r) == OpaqueAlpha)\n              {\n                SetPixelRed(image,ScaleCharToQuantum(0x24),r);\n              }\n            r+=GetPixelChannels(image);\n          }\n\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n\n        }\n      }\n\n      else\n      {\n         for (i=0; i<image_colors; i++)\n         {\n            if (ScaleQuantumToChar(image->colormap[i].red) == 0x49 &&\n                ScaleQuantumToChar(image->colormap[i].green) == 0x00 &&\n                ScaleQuantumToChar(image->colormap[i].blue) == 0x00)\n            {\n               image->colormap[i].red=ScaleCharToQuantum(0x24);\n            }\n         }\n      }\n    }\n  }\n  }\n  /* END OF BUILD_PALETTE */\n\n  /* If we are excluding the tRNS chunk and there is transparency,\n   * then we must write a Gray-Alpha (color-type 4) or RGBA (color-type 6)\n   * PNG.\n   */\n  if (mng_info->ping_exclude_tRNS != MagickFalse &&\n     (number_transparent != 0 || number_semitransparent != 0))\n    {\n      unsigned int colortype=mng_info->write_png_colortype;\n\n      if (ping_have_color == MagickFalse)\n        mng_info->write_png_colortype = 5;\n\n      else\n        mng_info->write_png_colortype = 7;\n\n      if (colortype != 0 &&\n         mng_info->write_png_colortype != colortype)\n        ping_need_colortype_warning=MagickTrue;\n\n    }\n\n  /* See if cheap transparency is possible.  It is only possible\n   * when there is a single transparent color, no semitransparent\n   * color, and no opaque color that has the same RGB components\n   * as the transparent color.  We only need this information if\n   * we are writing a PNG with colortype 0 or 2, and we have not\n   * excluded the tRNS chunk.\n   */\n  if (number_transparent == 1 &&\n      mng_info->write_png_colortype < 4)\n    {\n       ping_have_cheap_transparency = MagickTrue;\n\n       if (number_semitransparent != 0)\n         ping_have_cheap_transparency = MagickFalse;\n\n       else if (image_colors == 0 || image_colors > 256 ||\n           image->colormap == NULL)\n         {\n           register const Quantum\n             *q;\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             q=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n             if (q == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                 if (GetPixelAlpha(image,q) != TransparentAlpha &&\n                     (unsigned short) GetPixelRed(image,q) ==\n                                     ping_trans_color.red &&\n                     (unsigned short) GetPixelGreen(image,q) ==\n                                     ping_trans_color.green &&\n                     (unsigned short) GetPixelBlue(image,q) ==\n                                     ping_trans_color.blue)\n                   {\n                     ping_have_cheap_transparency = MagickFalse;\n                     break;\n                   }\n\n                 q+=GetPixelChannels(image);\n             }\n\n             if (ping_have_cheap_transparency == MagickFalse)\n                break;\n           }\n         }\n       else\n         {\n            /* Assuming that image->colormap[0] is the one transparent color\n             * and that all others are opaque.\n             */\n            if (image_colors > 1)\n              for (i=1; i<image_colors; i++)\n                if (image->colormap[i].red == image->colormap[0].red &&\n                    image->colormap[i].green == image->colormap[0].green &&\n                    image->colormap[i].blue == image->colormap[0].blue)\n                  {\n                     ping_have_cheap_transparency = MagickFalse;\n                     break;\n                  }\n         }\n\n       if (logging != MagickFalse)\n         {\n           if (ping_have_cheap_transparency == MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"   Cheap transparency is not possible.\");\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"   Cheap transparency is possible.\");\n         }\n     }\n  else\n    ping_have_cheap_transparency = MagickFalse;\n\n  image_depth=image->depth;\n\n  quantum_info = (QuantumInfo *) NULL;\n  number_colors=0;\n  image_colors=(int) image->colors;\n  image_matte=image->alpha_trait !=\n        UndefinedPixelTrait ? MagickTrue : MagickFalse;\n\n  if (mng_info->write_png_colortype < 5)\n    mng_info->IsPalette=image->storage_class == PseudoClass &&\n      image_colors <= 256 && image->colormap != NULL;\n  else\n    mng_info->IsPalette = MagickFalse;\n\n  if ((mng_info->write_png_colortype == 4 || mng_info->write_png8) &&\n     (image->colors == 0 || image->colormap == NULL))\n    {\n      image_info=DestroyImageInfo(image_info);\n      image=DestroyImage(image);\n      (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          \"Cannot write PNG8 or color-type 3; colormap is NULL\",\n          \"`%s'\",IMimage->filename);\n      return(MagickFalse);\n    }\n\n  /*\n    Allocate the PNG structures\n  */\n#ifdef PNG_USER_MEM_SUPPORTED\n error_info.image=image;\n error_info.exception=exception;\n  ping=png_create_write_struct_2(PNG_LIBPNG_VER_STRING,&error_info,\n    MagickPNGErrorHandler,MagickPNGWarningHandler,(void *) NULL,\n    (png_malloc_ptr) Magick_png_malloc,(png_free_ptr) Magick_png_free);\n\n#else\n  ping=png_create_write_struct(PNG_LIBPNG_VER_STRING,&error_info,\n    MagickPNGErrorHandler,MagickPNGWarningHandler);\n\n#endif\n  if (ping == (png_struct *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  ping_info=png_create_info_struct(ping);\n\n  if (ping_info == (png_info *) NULL)\n    {\n      png_destroy_write_struct(&ping,(png_info **) NULL);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n\n  png_set_write_fn(ping,image,png_put_data,png_flush_data);\n  pixel_info=(MemoryInfo *) NULL;\n\n  if (setjmp(png_jmpbuf(ping)))\n    {\n      /*\n        PNG write failed.\n      */\n#ifdef PNG_DEBUG\n     if (image_info->verbose)\n        (void) printf(\"PNG write has failed.\\n\");\n#endif\n      png_destroy_write_struct(&ping,&ping_info);\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n      UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n      if (pixel_info != (MemoryInfo *) NULL)\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n\n      if (quantum_info != (QuantumInfo *) NULL)\n        quantum_info=DestroyQuantumInfo(quantum_info);\n\n      if (ping_have_blob != MagickFalse)\n          (void) CloseBlob(image);\n      image_info=DestroyImageInfo(image_info);\n      image=DestroyImage(image);\n      return(MagickFalse);\n    }\n\n  /* {  For navigation to end of SETJMP-protected block.  Within this\n   *    block, use png_error() instead of Throwing an Exception, to ensure\n   *    that libpng is able to clean up, and that the semaphore is unlocked.\n   */\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  LockSemaphoreInfo(ping_semaphore);\n#endif\n\n#ifdef PNG_BENIGN_ERRORS_SUPPORTED\n  /* Allow benign errors */\n  png_set_benign_errors(ping, 1);\n#endif\n\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n  /* Reject images with too many rows or columns */\n  png_set_user_limits(ping,\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(WidthResource)),\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(HeightResource)));\n#endif /* PNG_SET_USER_LIMITS_SUPPORTED */\n\n  /*\n    Prepare PNG for writing.\n  */\n\n#if defined(PNG_MNG_FEATURES_SUPPORTED)\n  if (mng_info->write_mng)\n  {\n     (void) png_permit_mng_features(ping,PNG_ALL_MNG_FEATURES);\n# ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED\n     /* Disable new libpng-1.5.10 feature when writing a MNG because\n      * zero-length PLTE is OK\n      */\n     png_set_check_for_invalid_index (ping, 0);\n# endif\n  }\n\n#else\n# ifdef PNG_WRITE_EMPTY_PLTE_SUPPORTED\n  if (mng_info->write_mng)\n     png_permit_empty_plte(ping,MagickTrue);\n\n# endif\n#endif\n\n  x=0;\n\n  ping_width=(png_uint_32) image->columns;\n  ping_height=(png_uint_32) image->rows;\n\n  if (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32)\n     image_depth=8;\n\n  if (mng_info->write_png48 || mng_info->write_png64)\n     image_depth=16;\n\n  if (mng_info->write_png_depth != 0)\n     image_depth=mng_info->write_png_depth;\n\n  /* Adjust requested depth to next higher valid depth if necessary */\n  if (image_depth > 8)\n     image_depth=16;\n\n  if ((image_depth > 4) && (image_depth < 8))\n     image_depth=8;\n\n  if (image_depth == 3)\n     image_depth=4;\n\n  if (logging != MagickFalse)\n    {\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    width=%.20g\",(double) ping_width);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    height=%.20g\",(double) ping_height);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_matte=%.20g\",(double) image->alpha_trait);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image->depth=%.20g\",(double) image->depth);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Tentative ping_bit_depth=%.20g\",(double) image_depth);\n    }\n\n  save_image_depth=image_depth;\n  ping_bit_depth=(png_byte) save_image_depth;\n\n\n#if defined(PNG_pHYs_SUPPORTED)\n  if (ping_exclude_pHYs == MagickFalse)\n  {\n  if ((image->resolution.x != 0) && (image->resolution.y != 0) &&\n      (!mng_info->write_mng || !mng_info->equal_physs))\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Setting up pHYs chunk\");\n\n      if (image->units == PixelsPerInchResolution)\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_METER;\n          ping_pHYs_x_resolution=\n             (png_uint_32) ((100.0*image->resolution.x+0.5)/2.54);\n          ping_pHYs_y_resolution=\n             (png_uint_32) ((100.0*image->resolution.y+0.5)/2.54);\n        }\n\n      else if (image->units == PixelsPerCentimeterResolution)\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_METER;\n          ping_pHYs_x_resolution=(png_uint_32) (100.0*image->resolution.x+0.5);\n          ping_pHYs_y_resolution=(png_uint_32) (100.0*image->resolution.y+0.5);\n        }\n\n      else\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_UNKNOWN;\n          ping_pHYs_x_resolution=(png_uint_32) image->resolution.x;\n          ping_pHYs_y_resolution=(png_uint_32) image->resolution.y;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Set up PNG pHYs chunk: xres: %.20g, yres: %.20g, units: %d.\",\n          (double) ping_pHYs_x_resolution,(double) ping_pHYs_y_resolution,\n          (int) ping_pHYs_unit_type);\n       ping_have_pHYs = MagickTrue;\n    }\n  }\n#endif\n\n  if (ping_exclude_bKGD == MagickFalse)\n  {\n  if ((!mng_info->adjoin || !mng_info->equal_backgrounds))\n    {\n       unsigned int\n         mask;\n\n       mask=0xffff;\n       if (ping_bit_depth == 8)\n          mask=0x00ff;\n\n       if (ping_bit_depth == 4)\n          mask=0x000f;\n\n       if (ping_bit_depth == 2)\n          mask=0x0003;\n\n       if (ping_bit_depth == 1)\n          mask=0x0001;\n\n       ping_background.red=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.red) & mask);\n\n       ping_background.green=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.green) & mask);\n\n       ping_background.blue=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.blue) & mask);\n\n       ping_background.gray=(png_uint_16) ping_background.green;\n    }\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Setting up bKGD chunk (1)\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"      background_color index is %d\",\n          (int) ping_background.index);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    ping_bit_depth=%d\",ping_bit_depth);\n    }\n\n  ping_have_bKGD = MagickTrue;\n  }\n\n  /*\n    Select the color type.\n  */\n  matte=image_matte;\n  old_bit_depth=0;\n\n  if (mng_info->IsPalette && mng_info->write_png8)\n    {\n      /* To do: make this a function cause it's used twice, except\n         for reducing the sample depth from 8. */\n\n      number_colors=image_colors;\n\n      ping_have_tRNS=MagickFalse;\n\n      /*\n        Set image palette.\n      */\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Setting up PLTE chunk with %d colors (%d)\",\n            number_colors, image_colors);\n\n      for (i=0; i < (ssize_t) number_colors; i++)\n      {\n        palette[i].red=ScaleQuantumToChar(image->colormap[i].red);\n        palette[i].green=ScaleQuantumToChar(image->colormap[i].green);\n        palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n#if MAGICKCORE_QUANTUM_DEPTH == 8\n            \"    %3ld (%3d,%3d,%3d)\",\n#else\n            \"    %5ld (%5d,%5d,%5d)\",\n#endif\n            (long) i,palette[i].red,palette[i].green,palette[i].blue);\n\n      }\n\n      ping_have_PLTE=MagickTrue;\n      image_depth=ping_bit_depth;\n      ping_num_trans=0;\n\n      if (matte != MagickFalse)\n      {\n          /*\n            Identify which colormap entry is transparent.\n          */\n          assert(number_colors <= 256);\n          assert(image->colormap != NULL);\n\n          for (i=0; i < (ssize_t) number_transparent; i++)\n             ping_trans_alpha[i]=0;\n\n\n          ping_num_trans=(unsigned short) (number_transparent +\n             number_semitransparent);\n\n          if (ping_num_trans == 0)\n             ping_have_tRNS=MagickFalse;\n\n          else\n             ping_have_tRNS=MagickTrue;\n      }\n\n      if (ping_exclude_bKGD == MagickFalse)\n      {\n       /*\n        * Identify which colormap entry is the background color.\n        */\n\n        for (i=0; i < (ssize_t) MagickMax(1L*number_colors-1L,1L); i++)\n          if (IsPNGColorEqual(ping_background,image->colormap[i]))\n            break;\n\n        ping_background.index=(png_byte) i;\n\n        if (logging != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"      background_color index is %d\",\n                 (int) ping_background.index);\n          }\n      }\n    } /* end of write_png8 */\n\n  else if (mng_info->write_png_colortype == 1)\n    {\n      image_matte=MagickFalse;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;\n    }\n\n  else if (mng_info->write_png24 || mng_info->write_png48 ||\n      mng_info->write_png_colortype == 3)\n    {\n      image_matte=MagickFalse;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n    }\n\n  else if (mng_info->write_png32 || mng_info->write_png64 ||\n      mng_info->write_png_colortype == 7)\n    {\n      image_matte=MagickTrue;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;\n    }\n\n  else /* mng_info->write_pngNN not specified */\n    {\n      image_depth=ping_bit_depth;\n\n      if (mng_info->write_png_colortype != 0)\n        {\n          ping_color_type=(png_byte) mng_info->write_png_colortype-1;\n\n          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||\n              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            image_matte=MagickTrue;\n\n          else\n            image_matte=MagickFalse;\n\n          if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"   PNG colortype %d was specified:\",(int) ping_color_type);\n        }\n\n      else /* write_png_colortype not specified */\n        {\n          if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Selecting PNG colortype:\");\n\n          ping_color_type=(png_byte) ((matte != MagickFalse)?\n            PNG_COLOR_TYPE_RGB_ALPHA:PNG_COLOR_TYPE_RGB);\n\n          if (image_info->type == TrueColorType)\n            {\n              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n              image_matte=MagickFalse;\n            }\n\n          if (image_info->type == TrueColorAlphaType)\n            {\n              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;\n              image_matte=MagickTrue;\n            }\n\n          if (image_info->type == PaletteType ||\n              image_info->type == PaletteAlphaType)\n            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n          if (mng_info->write_png_colortype == 0 &&\n             image_info->type == UndefinedType)\n            {\n              if (ping_have_color == MagickFalse)\n                {\n                  if (image_matte == MagickFalse)\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;\n                      image_matte=MagickFalse;\n                    }\n\n                  else\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY_ALPHA;\n                      image_matte=MagickTrue;\n                    }\n                }\n              else\n                {\n                  if (image_matte == MagickFalse)\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n                      image_matte=MagickFalse;\n                    }\n\n                  else\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGBA;\n                      image_matte=MagickTrue;\n                    }\n                 }\n            }\n\n        }\n\n      if (logging != MagickFalse)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"    Selected PNG colortype=%d\",ping_color_type);\n\n      if (ping_bit_depth < 8)\n        {\n          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||\n              ping_color_type == PNG_COLOR_TYPE_RGB ||\n              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            ping_bit_depth=8;\n        }\n\n      old_bit_depth=ping_bit_depth;\n\n      if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n        {\n          if (image->alpha_trait == UndefinedPixelTrait &&\n               ping_have_non_bw == MagickFalse)\n             ping_bit_depth=1;\n        }\n\n      if (ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        {\n           size_t one = 1;\n           ping_bit_depth=1;\n\n           if (image->colors == 0)\n           {\n              /* DO SOMETHING */\n                png_error(ping,\"image has 0 colors\");\n           }\n\n           while ((int) (one << ping_bit_depth) < (ssize_t) image_colors)\n             ping_bit_depth <<= 1;\n        }\n\n      if (logging != MagickFalse)\n         {\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Number of colors: %.20g\",(double) image_colors);\n\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Tentative PNG bit depth: %d\",ping_bit_depth);\n         }\n\n      if (ping_bit_depth < (int) mng_info->write_png_depth)\n         ping_bit_depth = mng_info->write_png_depth;\n    }\n\n  image_depth=ping_bit_depth;\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Tentative PNG color type: %s (%.20g)\",\n        PngColorTypeToString(ping_color_type),\n        (double) ping_color_type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_info->type: %.20g\",(double) image_info->type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_depth: %.20g\",(double) image_depth);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\n        \"    image->depth: %.20g\",(double) image->depth);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    ping_bit_depth: %.20g\",(double) ping_bit_depth);\n    }\n\n  if (matte != MagickFalse)\n    {\n      if (mng_info->IsPalette)\n        {\n          if (mng_info->write_png_colortype == 0)\n            {\n              ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;\n\n              if (ping_have_color != MagickFalse)\n                 ping_color_type=PNG_COLOR_TYPE_RGBA;\n            }\n\n          /*\n           * Determine if there is any transparent color.\n          */\n          if (number_transparent + number_semitransparent == 0)\n            {\n              /*\n                No transparent pixels are present.  Change 4 or 6 to 0 or 2.\n              */\n\n              image_matte=MagickFalse;\n\n              if (mng_info->write_png_colortype == 0)\n                ping_color_type&=0x03;\n            }\n\n          else\n            {\n              unsigned int\n                mask;\n\n              mask=0xffff;\n\n              if (ping_bit_depth == 8)\n                 mask=0x00ff;\n\n              if (ping_bit_depth == 4)\n                 mask=0x000f;\n\n              if (ping_bit_depth == 2)\n                 mask=0x0003;\n\n              if (ping_bit_depth == 1)\n                 mask=0x0001;\n\n              ping_trans_color.red=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].red) & mask);\n\n              ping_trans_color.green=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].green) & mask);\n\n              ping_trans_color.blue=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].blue) & mask);\n\n              ping_trans_color.gray=(png_uint_16)\n                (ScaleQuantumToShort(GetPixelInfoIntensity(image,\n                   image->colormap)) & mask);\n\n              ping_trans_color.index=(png_byte) 0;\n\n              ping_have_tRNS=MagickTrue;\n            }\n\n          if (ping_have_tRNS != MagickFalse)\n            {\n              /*\n               * Determine if there is one and only one transparent color\n               * and if so if it is fully transparent.\n               */\n              if (ping_have_cheap_transparency == MagickFalse)\n                ping_have_tRNS=MagickFalse;\n            }\n\n          if (ping_have_tRNS != MagickFalse)\n            {\n              if (mng_info->write_png_colortype == 0)\n                ping_color_type &= 0x03;  /* changes 4 or 6 to 0 or 2 */\n\n              if (image_depth == 8)\n                {\n                  ping_trans_color.red&=0xff;\n                  ping_trans_color.green&=0xff;\n                  ping_trans_color.blue&=0xff;\n                  ping_trans_color.gray&=0xff;\n                }\n            }\n        }\n      else\n        {\n          if (image_depth == 8)\n            {\n              ping_trans_color.red&=0xff;\n              ping_trans_color.green&=0xff;\n              ping_trans_color.blue&=0xff;\n              ping_trans_color.gray&=0xff;\n            }\n        }\n    }\n\n    matte=image_matte;\n\n    if (ping_have_tRNS != MagickFalse)\n      image_matte=MagickFalse;\n\n    if ((mng_info->IsPalette) &&\n        mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE &&\n        ping_have_color == MagickFalse &&\n        (image_matte == MagickFalse || image_depth >= 8))\n      {\n        size_t one=1;\n\n        if (image_matte != MagickFalse)\n          ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;\n\n        else if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_GRAY_ALPHA)\n          {\n            ping_color_type=PNG_COLOR_TYPE_GRAY;\n\n            if (save_image_depth == 16 && image_depth == 8)\n              {\n                if (logging != MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Scaling ping_trans_color (0)\");\n                  }\n                    ping_trans_color.gray*=0x0101;\n              }\n          }\n\n        if (image_depth > MAGICKCORE_QUANTUM_DEPTH)\n          image_depth=MAGICKCORE_QUANTUM_DEPTH;\n\n        if ((image_colors == 0) ||\n             ((ssize_t) (image_colors-1) > (ssize_t) MaxColormapSize))\n          image_colors=(int) (one << image_depth);\n\n        if (image_depth > 8)\n          ping_bit_depth=16;\n\n        else\n          {\n            ping_bit_depth=8;\n            if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n              {\n                if(!mng_info->write_png_depth)\n                  {\n                    ping_bit_depth=1;\n\n                    while ((int) (one << ping_bit_depth)\n                        < (ssize_t) image_colors)\n                      ping_bit_depth <<= 1;\n                  }\n              }\n\n            else if (ping_color_type ==\n                PNG_COLOR_TYPE_GRAY && image_colors < 17 &&\n                mng_info->IsPalette)\n              {\n              /* Check if grayscale is reducible */\n\n                int\n                  depth_4_ok=MagickTrue,\n                  depth_2_ok=MagickTrue,\n                  depth_1_ok=MagickTrue;\n\n                for (i=0; i < (ssize_t) image_colors; i++)\n                {\n                   unsigned char\n                     intensity;\n\n                   intensity=ScaleQuantumToChar(image->colormap[i].red);\n\n                   if ((intensity & 0x0f) != ((intensity & 0xf0) >> 4))\n                     depth_4_ok=depth_2_ok=depth_1_ok=MagickFalse;\n                   else if ((intensity & 0x03) != ((intensity & 0x0c) >> 2))\n                     depth_2_ok=depth_1_ok=MagickFalse;\n                   else if ((intensity & 0x01) != ((intensity & 0x02) >> 1))\n                     depth_1_ok=MagickFalse;\n                }\n\n                if (depth_1_ok && mng_info->write_png_depth <= 1)\n                  ping_bit_depth=1;\n\n                else if (depth_2_ok && mng_info->write_png_depth <= 2)\n                  ping_bit_depth=2;\n\n                else if (depth_4_ok && mng_info->write_png_depth <= 4)\n                  ping_bit_depth=4;\n              }\n          }\n\n          image_depth=ping_bit_depth;\n      }\n\n    else\n\n      if (mng_info->IsPalette)\n      {\n        number_colors=image_colors;\n\n        if (image_depth <= 8)\n          {\n            /*\n              Set image palette.\n            */\n            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n            if (!(mng_info->have_write_global_plte && matte == MagickFalse))\n              {\n                for (i=0; i < (ssize_t) number_colors; i++)\n                {\n                  palette[i].red=ScaleQuantumToChar(image->colormap[i].red);\n                  palette[i].green=\n                    ScaleQuantumToChar(image->colormap[i].green);\n                  palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);\n                }\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Setting up PLTE chunk with %d colors\",\n                    number_colors);\n\n                ping_have_PLTE=MagickTrue;\n              }\n\n            /* color_type is PNG_COLOR_TYPE_PALETTE */\n            if (mng_info->write_png_depth == 0)\n              {\n                size_t\n                  one;\n\n                ping_bit_depth=1;\n                one=1;\n\n                while ((one << ping_bit_depth) < (size_t) number_colors)\n                  ping_bit_depth <<= 1;\n              }\n\n            ping_num_trans=0;\n\n            if (matte != MagickFalse)\n              {\n                /*\n                 * Set up trans_colors array.\n                 */\n                assert(number_colors <= 256);\n\n                ping_num_trans=(unsigned short) (number_transparent +\n                  number_semitransparent);\n\n                if (ping_num_trans == 0)\n                  ping_have_tRNS=MagickFalse;\n\n                else\n                  {\n                    if (logging != MagickFalse)\n                      {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Scaling ping_trans_color (1)\");\n                      }\n                    ping_have_tRNS=MagickTrue;\n\n                    for (i=0; i < ping_num_trans; i++)\n                    {\n                       ping_trans_alpha[i]= (png_byte)\n                         ScaleQuantumToChar(image->colormap[i].alpha);\n                    }\n                  }\n              }\n          }\n      }\n\n    else\n      {\n\n        if (image_depth < 8)\n          image_depth=8;\n\n        if ((save_image_depth == 16) && (image_depth == 8))\n          {\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Scaling ping_trans_color from (%d,%d,%d)\",\n                  (int) ping_trans_color.red,\n                  (int) ping_trans_color.green,\n                  (int) ping_trans_color.blue);\n              }\n\n            ping_trans_color.red*=0x0101;\n            ping_trans_color.green*=0x0101;\n            ping_trans_color.blue*=0x0101;\n            ping_trans_color.gray*=0x0101;\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    to (%d,%d,%d)\",\n                  (int) ping_trans_color.red,\n                  (int) ping_trans_color.green,\n                  (int) ping_trans_color.blue);\n              }\n          }\n      }\n\n    if (ping_bit_depth <  (ssize_t) mng_info->write_png_depth)\n         ping_bit_depth =  (ssize_t) mng_info->write_png_depth;\n\n    /*\n      Adjust background and transparency samples in sub-8-bit grayscale files.\n    */\n    if (ping_bit_depth < 8 && ping_color_type ==\n        PNG_COLOR_TYPE_GRAY)\n      {\n         png_uint_16\n           maxval;\n\n         size_t\n           one=1;\n\n         maxval=(png_uint_16) ((one << ping_bit_depth)-1);\n\n         if (ping_exclude_bKGD == MagickFalse)\n         {\n\n         ping_background.gray=(png_uint_16) ((maxval/65535.)*\n           (ScaleQuantumToShort(((GetPixelInfoIntensity(image,\n           &image->background_color))) +.5)));\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Setting up bKGD chunk (2)\");\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      background_color index is %d\",\n             (int) ping_background.index);\n\n         ping_have_bKGD = MagickTrue;\n         }\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Scaling ping_trans_color.gray from %d\",\n             (int)ping_trans_color.gray);\n\n         ping_trans_color.gray=(png_uint_16) ((maxval/255.)*(\n           ping_trans_color.gray)+.5);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      to %d\", (int)ping_trans_color.gray);\n      }\n\n  if (ping_exclude_bKGD == MagickFalse)\n  {\n    if (mng_info->IsPalette && (int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n      {\n        /*\n           Identify which colormap entry is the background color.\n        */\n\n        number_colors=image_colors;\n\n        for (i=0; i < (ssize_t) MagickMax(1L*number_colors,1L); i++)\n          if (IsPNGColorEqual(image->background_color,image->colormap[i]))\n            break;\n\n        ping_background.index=(png_byte) i;\n\n        if (logging != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Setting up bKGD chunk with index=%d\",(int) i);\n          }\n\n        if (i < (ssize_t) number_colors)\n          {\n            ping_have_bKGD = MagickTrue;\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"     background   =(%d,%d,%d)\",\n                        (int) ping_background.red,\n                        (int) ping_background.green,\n                        (int) ping_background.blue);\n              }\n          }\n\n        else  /* Can't happen */\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      No room in PLTE to add bKGD color\");\n            ping_have_bKGD = MagickFalse;\n          }\n      }\n  }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    PNG color type: %s (%d)\", PngColorTypeToString(ping_color_type),\n      ping_color_type);\n  /*\n    Initialize compression level and filtering.\n  */\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Setting up deflate compression\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Compression buffer size: 32768\");\n    }\n\n  png_set_compression_buffer_size(ping,32768L);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Compression mem level: 9\");\n\n  png_set_compression_mem_level(ping, 9);\n\n  /* Untangle the \"-quality\" setting:\n\n     Undefined is 0; the default is used.\n     Default is 75\n\n     10's digit:\n\n        0 or omitted: Use Z_HUFFMAN_ONLY strategy with the\n           zlib default compression level\n\n        1-9: the zlib compression level\n\n     1's digit:\n\n        0-4: the PNG filter method\n\n        5:   libpng adaptive filtering if compression level > 5\n             libpng filter type \"none\" if compression level <= 5\n                or if image is grayscale or palette\n\n        6:   libpng adaptive filtering\n\n        7:   \"LOCO\" filtering (intrapixel differing) if writing\n             a MNG, otherwise \"none\".  Did not work in IM-6.7.0-9\n             and earlier because of a missing \"else\".\n\n        8:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), adaptive\n             filtering. Unused prior to IM-6.7.0-10, was same as 6\n\n        9:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), no PNG filters\n             Unused prior to IM-6.7.0-10, was same as 6\n\n    Note that using the -quality option, not all combinations of\n    PNG filter type, zlib compression level, and zlib compression\n    strategy are possible.  This will be addressed soon in a\n    release that accomodates \"-define png:compression-strategy\", etc.\n\n   */\n\n  quality=image_info->quality == UndefinedCompressionQuality ? 75UL :\n     image_info->quality;\n\n  if (quality <= 9)\n    {\n      if (mng_info->write_png_compression_strategy == 0)\n        mng_info->write_png_compression_strategy = Z_HUFFMAN_ONLY+1;\n    }\n\n  else if (mng_info->write_png_compression_level == 0)\n    {\n      int\n        level;\n\n      level=(int) MagickMin((ssize_t) quality/10,9);\n\n      mng_info->write_png_compression_level = level+1;\n    }\n\n  if (mng_info->write_png_compression_strategy == 0)\n    {\n        if ((quality %10) == 8 || (quality %10) == 9)\n#ifdef Z_RLE  /* Z_RLE was added to zlib-1.2.0 */\n          mng_info->write_png_compression_strategy=Z_RLE+1;\n#else\n          mng_info->write_png_compression_strategy = Z_DEFAULT_STRATEGY+1;\n#endif\n    }\n\n  if (mng_info->write_png_compression_filter == 0)\n        mng_info->write_png_compression_filter=((int) quality % 10) + 1;\n\n  if (logging != MagickFalse)\n    {\n        if (mng_info->write_png_compression_level)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Compression level:    %d\",\n            (int) mng_info->write_png_compression_level-1);\n\n        if (mng_info->write_png_compression_strategy)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Compression strategy: %d\",\n            (int) mng_info->write_png_compression_strategy-1);\n\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Setting up filtering\");\n\n        if (mng_info->write_png_compression_filter == 6)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: ADAPTIVE\");\n        else if (mng_info->write_png_compression_filter == 0 ||\n                 mng_info->write_png_compression_filter == 1)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: NONE\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: %d\",\n            (int) mng_info->write_png_compression_filter-1);\n    }\n\n  if (mng_info->write_png_compression_level != 0)\n    png_set_compression_level(ping,mng_info->write_png_compression_level-1);\n\n  if (mng_info->write_png_compression_filter == 6)\n    {\n      if (((int) ping_color_type == PNG_COLOR_TYPE_GRAY) ||\n         ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE) ||\n         (quality < 50))\n        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n      else\n        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);\n     }\n  else if (mng_info->write_png_compression_filter == 7 ||\n      mng_info->write_png_compression_filter == 10)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);\n\n  else if (mng_info->write_png_compression_filter == 8)\n    {\n#if defined(PNG_MNG_FEATURES_SUPPORTED) && defined(PNG_INTRAPIXEL_DIFFERENCING)\n      if (mng_info->write_mng)\n      {\n         if (((int) ping_color_type == PNG_COLOR_TYPE_RGB) ||\n             ((int) ping_color_type == PNG_COLOR_TYPE_RGBA))\n        ping_filter_method=PNG_INTRAPIXEL_DIFFERENCING;\n      }\n#endif\n      png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n    }\n\n  else if (mng_info->write_png_compression_filter == 9)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n\n  else if (mng_info->write_png_compression_filter != 0)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,\n       mng_info->write_png_compression_filter-1);\n\n  if (mng_info->write_png_compression_strategy != 0)\n    png_set_compression_strategy(ping,\n       mng_info->write_png_compression_strategy-1);\n\n  ping_interlace_method=image_info->interlace != NoInterlace;\n\n  if (mng_info->write_mng)\n    png_set_sig_bytes(ping,8);\n\n  /* Bail out if cannot meet defined png:bit-depth or png:color-type */\n\n  if (mng_info->write_png_colortype != 0)\n    {\n     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY)\n       if (ping_have_color != MagickFalse)\n         {\n           ping_color_type = PNG_COLOR_TYPE_RGB;\n\n           if (ping_bit_depth < 8)\n             ping_bit_depth=8;\n         }\n\n     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY_ALPHA)\n       if (ping_have_color != MagickFalse)\n         ping_color_type = PNG_COLOR_TYPE_RGB_ALPHA;\n    }\n\n  if (ping_need_colortype_warning != MagickFalse ||\n     ((mng_info->write_png_depth &&\n     (int) mng_info->write_png_depth != ping_bit_depth) ||\n     (mng_info->write_png_colortype &&\n     ((int) mng_info->write_png_colortype-1 != ping_color_type &&\n      mng_info->write_png_colortype != 7 &&\n      !(mng_info->write_png_colortype == 5 && ping_color_type == 0)))))\n    {\n      if (logging != MagickFalse)\n        {\n          if (ping_need_colortype_warning != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  Image has transparency but tRNS chunk was excluded\");\n            }\n\n          if (mng_info->write_png_depth)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Defined png:bit-depth=%u, Computed depth=%u\",\n                  mng_info->write_png_depth,\n                  ping_bit_depth);\n            }\n\n          if (mng_info->write_png_colortype)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Defined png:color-type=%u, Computed color type=%u\",\n                  mng_info->write_png_colortype-1,\n                  ping_color_type);\n            }\n        }\n\n      png_warning(ping,\n        \"Cannot write image with defined png:bit-depth or png:color-type.\");\n    }\n\n  if (image_matte != MagickFalse && image->alpha_trait == UndefinedPixelTrait)\n    {\n      /* Add an opaque matte channel */\n      image->alpha_trait = BlendPixelTrait;\n      (void) SetImageAlpha(image,OpaqueAlpha,exception);\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Added an opaque matte channel\");\n    }\n\n  if (number_transparent != 0 || number_semitransparent != 0)\n    {\n      if (ping_color_type < 4)\n        {\n           ping_have_tRNS=MagickTrue;\n           if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Setting ping_have_tRNS=MagickTrue.\");\n        }\n    }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Writing PNG header chunks\");\n\n  png_set_IHDR(ping,ping_info,ping_width,ping_height,\n               ping_bit_depth,ping_color_type,\n               ping_interlace_method,ping_compression_method,\n               ping_filter_method);\n\n  if (ping_color_type == 3 && ping_have_PLTE != MagickFalse)\n    {\n      png_set_PLTE(ping,ping_info,palette,number_colors);\n\n      if (logging != MagickFalse)\n        {\n          for (i=0; i< (ssize_t) number_colors; i++)\n          {\n            if (i < ping_num_trans)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"     PLTE[%d] = (%d,%d,%d), tRNS[%d] = (%d)\",\n                      (int) i,\n                      (int) palette[i].red,\n                      (int) palette[i].green,\n                      (int) palette[i].blue,\n                      (int) i,\n                      (int) ping_trans_alpha[i]);\n             else\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"     PLTE[%d] = (%d,%d,%d)\",\n                      (int) i,\n                      (int) palette[i].red,\n                      (int) palette[i].green,\n                      (int) palette[i].blue);\n           }\n         }\n    }\n\n  /* Only write the iCCP chunk if we are not writing the sRGB chunk. */\n  if (ping_exclude_sRGB != MagickFalse ||\n     (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n  {\n    if ((ping_exclude_tEXt == MagickFalse ||\n       ping_exclude_zTXt == MagickFalse) &&\n       (ping_exclude_iCCP == MagickFalse || ping_exclude_zCCP == MagickFalse))\n    {\n      ResetImageProfileIterator(image);\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        profile=GetImageProfile(image,name);\n\n        if (profile != (StringInfo *) NULL)\n          {\n#ifdef PNG_WRITE_iCCP_SUPPORTED\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0))\n              {\n                ping_have_iCCP = MagickTrue;\n                if (ping_exclude_iCCP == MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Setting up iCCP chunk\");\n\n                    png_set_iCCP(ping,ping_info,(png_charp) name,0,\n#if (PNG_LIBPNG_VER < 10500)\n                    (png_charp) GetStringInfoDatum(profile),\n#else\n                    (const png_byte *) GetStringInfoDatum(profile),\n#endif\n                    (png_uint_32) GetStringInfoLength(profile));\n                  }\n                else\n                  {\n                    /* Do not write hex-encoded ICC chunk */\n                       name=GetNextImageProfile(image);\n                       continue;\n                  }\n              }\n#endif /* WRITE_iCCP */\n\n            if (LocaleCompare(name,\"exif\") == 0)\n              {\n                   /* Do not write hex-encoded ICC chunk; we will\n                      write it later as an eXIf chunk */\n                   name=GetNextImageProfile(image);\n                   continue;\n              }\n\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  Setting up zTXt chunk with uuencoded %s profile\",\n                 name);\n              Magick_png_write_raw_profile(image_info,ping,ping_info,\n                (unsigned char *) name,(unsigned char *) name,\n                GetStringInfoDatum(profile),\n                (png_uint_32) GetStringInfoLength(profile));\n          }\n        name=GetNextImageProfile(image);\n      }\n    }\n  }\n\n#if defined(PNG_WRITE_sRGB_SUPPORTED)\n  if ((mng_info->have_write_global_srgb == 0) &&\n      ping_have_iCCP != MagickTrue &&\n      (ping_have_sRGB != MagickFalse ||\n      png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n    {\n      if (ping_exclude_sRGB == MagickFalse)\n        {\n          /*\n            Note image rendering intent.\n          */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Setting up sRGB chunk\");\n\n          (void) png_set_sRGB(ping,ping_info,(\n            Magick_RenderingIntent_to_PNG_RenderingIntent(\n              image->rendering_intent)));\n\n          ping_have_sRGB = MagickTrue;\n        }\n    }\n\n  if ((!mng_info->write_mng) || (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n#endif\n    {\n      if (ping_exclude_gAMA == MagickFalse &&\n          ping_have_iCCP == MagickFalse &&\n          ping_have_sRGB == MagickFalse &&\n          (ping_exclude_sRGB == MagickFalse ||\n          (image->gamma < .45 || image->gamma > .46)))\n      {\n      if ((mng_info->have_write_global_gama == 0) && (image->gamma != 0.0))\n        {\n          /*\n            Note image gamma.\n            To do: check for cHRM+gAMA == sRGB, and write sRGB instead.\n          */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Setting up gAMA chunk\");\n\n          png_set_gAMA(ping,ping_info,image->gamma);\n        }\n      }\n\n      if (ping_exclude_cHRM == MagickFalse && ping_have_sRGB == MagickFalse)\n        {\n          if ((mng_info->have_write_global_chrm == 0) &&\n              (image->chromaticity.red_primary.x != 0.0))\n            {\n              /*\n                Note image chromaticity.\n                Note: if cHRM+gAMA == sRGB write sRGB instead.\n              */\n               PrimaryInfo\n                 bp,\n                 gp,\n                 rp,\n                 wp;\n\n               wp=image->chromaticity.white_point;\n               rp=image->chromaticity.red_primary;\n               gp=image->chromaticity.green_primary;\n               bp=image->chromaticity.blue_primary;\n\n               if (logging != MagickFalse)\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Setting up cHRM chunk\");\n\n               png_set_cHRM(ping,ping_info,wp.x,wp.y,rp.x,rp.y,gp.x,gp.y,\n                   bp.x,bp.y);\n           }\n        }\n    }\n\n  if (ping_exclude_bKGD == MagickFalse)\n    {\n      if (ping_have_bKGD != MagickFalse)\n        {\n          png_set_bKGD(ping,ping_info,&ping_background);\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Setting up bKGD chunk\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      background color = (%d,%d,%d)\",\n                        (int) ping_background.red,\n                        (int) ping_background.green,\n                        (int) ping_background.blue);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      index = %d, gray=%d\",\n                        (int) ping_background.index,\n                        (int) ping_background.gray);\n            }\n         }\n    }\n\n  if (ping_exclude_pHYs == MagickFalse)\n    {\n      if (ping_have_pHYs != MagickFalse)\n        {\n          png_set_pHYs(ping,ping_info,\n             ping_pHYs_x_resolution,\n             ping_pHYs_y_resolution,\n             ping_pHYs_unit_type);\n\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Setting up pHYs chunk\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      x_resolution=%lu\",\n                   (unsigned long) ping_pHYs_x_resolution);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      y_resolution=%lu\",\n                   (unsigned long) ping_pHYs_y_resolution);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      unit_type=%lu\",\n                   (unsigned long) ping_pHYs_unit_type);\n            }\n        }\n    }\n\n#if defined(PNG_tIME_SUPPORTED)\n  if (ping_exclude_tIME == MagickFalse)\n    {\n      const char\n        *timestamp;\n\n      if (image->taint == MagickFalse)\n        {\n          timestamp=GetImageOption(image_info,\"png:tIME\");\n\n          if (timestamp == (const char *) NULL)\n            timestamp=GetImageProperty(image,\"png:tIME\",exception);\n        }\n\n      else\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Reset tIME in tainted image\");\n\n          timestamp=GetImageProperty(image,\"date:modify\",exception);\n        }\n\n      if (timestamp != (const char *) NULL)\n          write_tIME_chunk(image,ping,ping_info,timestamp,exception);\n    }\n#endif\n\n  if (mng_info->need_blob != MagickFalse)\n  {\n    if (OpenBlob(image_info,image,WriteBinaryBlobMode,exception) ==\n       MagickFalse)\n       png_error(ping,\"WriteBlob Failed\");\n\n     ping_have_blob=MagickTrue;\n  }\n\n  png_write_info_before_PLTE(ping, ping_info);\n\n  if (ping_have_tRNS != MagickFalse && ping_color_type < 4)\n    {\n      if (logging != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Calling png_set_tRNS with num_trans=%d\",ping_num_trans);\n        }\n\n      if (ping_color_type == 3)\n         (void) png_set_tRNS(ping, ping_info,\n                ping_trans_alpha,\n                ping_num_trans,\n                NULL);\n\n      else\n        {\n           (void) png_set_tRNS(ping, ping_info,\n                  NULL,\n                  0,\n                  &ping_trans_color);\n\n           if (logging != MagickFalse)\n             {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"     tRNS color   =(%d,%d,%d)\",\n                       (int) ping_trans_color.red,\n                       (int) ping_trans_color.green,\n                       (int) ping_trans_color.blue);\n             }\n         }\n    }\n\n  /* write any png-chunk-b profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-b\",logging);\n\n  png_write_info(ping,ping_info);\n\n  /* write any PNG-chunk-m profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-m\",logging);\n\n  ping_wrote_caNv = MagickFalse;\n\n  /* write caNv chunk */\n  if (ping_exclude_caNv == MagickFalse)\n    {\n      if ((image->page.width != 0 && image->page.width != image->columns) ||\n          (image->page.height != 0 && image->page.height != image->rows) ||\n          image->page.x != 0 || image->page.y != 0)\n        {\n          unsigned char\n            chunk[20];\n\n          (void) WriteBlobMSBULong(image,16L);  /* data length=8 */\n          PNGType(chunk,mng_caNv);\n          LogPNGChunk(logging,mng_caNv,16L);\n          PNGLong(chunk+4,(png_uint_32) image->page.width);\n          PNGLong(chunk+8,(png_uint_32) image->page.height);\n          PNGsLong(chunk+12,(png_int_32) image->page.x);\n          PNGsLong(chunk+16,(png_int_32) image->page.y);\n          (void) WriteBlob(image,20,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,20));\n          ping_wrote_caNv = MagickTrue;\n        }\n    }\n\n#if defined(PNG_oFFs_SUPPORTED)\n  if (ping_exclude_oFFs == MagickFalse && ping_wrote_caNv == MagickFalse)\n    {\n      if (image->page.x || image->page.y)\n        {\n           png_set_oFFs(ping,ping_info,(png_int_32) image->page.x,\n              (png_int_32) image->page.y, 0);\n\n           if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"    Setting up oFFs chunk with x=%d, y=%d, units=0\",\n                 (int) image->page.x, (int) image->page.y);\n        }\n    }\n#endif\n\n  /* write vpAg chunk (deprecated, replaced by caNv) */\n  if (ping_exclude_vpAg == MagickFalse && ping_wrote_caNv == MagickFalse)\n    {\n      if ((image->page.width != 0 && image->page.width != image->columns) ||\n          (image->page.height != 0 && image->page.height != image->rows))\n        {\n          unsigned char\n            chunk[14];\n\n          (void) WriteBlobMSBULong(image,9L);  /* data length=8 */\n          PNGType(chunk,mng_vpAg);\n          LogPNGChunk(logging,mng_vpAg,9L);\n          PNGLong(chunk+4,(png_uint_32) image->page.width);\n          PNGLong(chunk+8,(png_uint_32) image->page.height);\n          chunk[12]=0;   /* unit = pixels */\n          (void) WriteBlob(image,13,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,13));\n        }\n    }\n\n#if (PNG_LIBPNG_VER == 10206)\n    /* avoid libpng-1.2.6 bug by setting PNG_HAVE_IDAT flag */\n#define PNG_HAVE_IDAT               0x04\n    ping->mode |= PNG_HAVE_IDAT;\n#undef PNG_HAVE_IDAT\n#endif\n\n  png_set_packing(ping);\n  /*\n    Allocate memory.\n  */\n  rowbytes=image->columns;\n  if (image_depth > 8)\n    rowbytes*=2;\n  switch (ping_color_type)\n    {\n      case PNG_COLOR_TYPE_RGB:\n        rowbytes*=3;\n        break;\n\n      case PNG_COLOR_TYPE_GRAY_ALPHA:\n        rowbytes*=2;\n        break;\n\n      case PNG_COLOR_TYPE_RGBA:\n        rowbytes*=4;\n        break;\n\n      default:\n        break;\n    }\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Writing PNG image data\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Allocating %.20g bytes of memory for pixels\",(double) rowbytes);\n    }\n  pixel_info=AcquireVirtualMemory(rowbytes,sizeof(*ping_pixels));\n  if (pixel_info == (MemoryInfo *) NULL)\n    png_error(ping,\"Allocation of memory for pixels failed\");\n  ping_pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n\n  /*\n    Initialize image scanlines.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    png_error(ping,\"Memory allocation for quantum_info failed\");\n  quantum_info->format=UndefinedQuantumFormat;\n  SetQuantumDepth(image,quantum_info,image_depth);\n  (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n  num_passes=png_set_interlace_handling(ping);\n\n  if ((!mng_info->write_png8 && !mng_info->write_png24 &&\n       !mng_info->write_png48 && !mng_info->write_png64 &&\n       !mng_info->write_png32) &&\n       (mng_info->IsPalette ||\n       (image_info->type == BilevelType)) &&\n       image_matte == MagickFalse &&\n       ping_have_non_bw == MagickFalse)\n    {\n      /* Palette, Bilevel, or Opaque Monochrome */\n      register const Quantum\n        *p;\n\n      SetQuantumDepth(image,quantum_info,8);\n      for (pass=0; pass < num_passes; pass++)\n      {\n        /*\n          Convert PseudoClass image to a PNG monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          if (logging != MagickFalse && y == 0)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"    Writing row of pixels (0)\");\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n\n          if (p == (const Quantum *) NULL)\n            break;\n\n          if (mng_info->IsPalette)\n            {\n              (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                quantum_info,GrayQuantum,ping_pixels,exception);\n              if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_PALETTE &&\n                  mng_info->write_png_depth &&\n                  mng_info->write_png_depth != old_bit_depth)\n                {\n                  /* Undo pixel scaling */\n                  for (i=0; i < (ssize_t) image->columns; i++)\n                     *(ping_pixels+i)=(unsigned char) (*(ping_pixels+i)\n                     >> (8-old_bit_depth));\n                }\n            }\n\n          else\n            {\n              (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                quantum_info,RedQuantum,ping_pixels,exception);\n            }\n\n          if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE)\n            for (i=0; i < (ssize_t) image->columns; i++)\n               *(ping_pixels+i)=(unsigned char) ((*(ping_pixels+i) > 127) ?\n                      255 : 0);\n\n          if (logging != MagickFalse && y == 0)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Writing row of pixels (1)\");\n\n          png_write_row(ping,ping_pixels);\n\n          status=SetImageProgress(image,SaveImageTag,\n              (MagickOffsetType) (pass * image->rows + y),\n              num_passes * image->rows);\n\n          if (status == MagickFalse)\n            break;\n        }\n      }\n    }\n\n  else   /* Not Palette, Bilevel, or Opaque Monochrome */\n    {\n      if ((!mng_info->write_png8 && !mng_info->write_png24 &&\n          !mng_info->write_png48 && !mng_info->write_png64 &&\n          !mng_info->write_png32) && (image_matte != MagickFalse ||\n          (ping_bit_depth >= MAGICKCORE_QUANTUM_DEPTH)) &&\n          (mng_info->IsPalette) && ping_have_color == MagickFalse)\n        {\n          register const Quantum\n            *p;\n\n          for (pass=0; pass < num_passes; pass++)\n          {\n\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n\n            if (p == (const Quantum *) NULL)\n              break;\n\n            if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n              {\n                if (mng_info->IsPalette)\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,GrayQuantum,ping_pixels,exception);\n\n                else\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RedQuantum,ping_pixels,exception);\n\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"    Writing GRAY PNG pixels (2)\");\n              }\n\n            else /* PNG_COLOR_TYPE_GRAY_ALPHA */\n              {\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Writing GRAY_ALPHA PNG pixels (2)\");\n\n                (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,GrayAlphaQuantum,ping_pixels,exception);\n              }\n\n            if (logging != MagickFalse && y == 0)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Writing row of pixels (2)\");\n\n            png_write_row(ping,ping_pixels);\n\n            status=SetImageProgress(image,SaveImageTag,\n              (MagickOffsetType) (pass * image->rows + y),\n              num_passes * image->rows);\n\n            if (status == MagickFalse)\n              break;\n            }\n          }\n        }\n\n      else\n        {\n          register const Quantum\n            *p;\n\n          for (pass=0; pass < num_passes; pass++)\n          {\n            if ((image_depth > 8) ||\n                mng_info->write_png24 ||\n                mng_info->write_png32 ||\n                mng_info->write_png48 ||\n                mng_info->write_png64 ||\n                (!mng_info->write_png8 && !mng_info->IsPalette))\n            {\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n                if (p == (const Quantum *) NULL)\n                  break;\n\n                if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n                  {\n                    if (image->storage_class == DirectClass)\n                      (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                        quantum_info,RedQuantum,ping_pixels,exception);\n\n                    else\n                      (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                        quantum_info,GrayQuantum,ping_pixels,exception);\n                  }\n\n                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n                  {\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                      quantum_info,GrayAlphaQuantum,ping_pixels,\n                      exception);\n\n                    if (logging != MagickFalse && y == 0)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"    Writing GRAY_ALPHA PNG pixels (3)\");\n                  }\n\n                else if (image_matte != MagickFalse)\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RGBAQuantum,ping_pixels,exception);\n\n                else\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RGBQuantum,ping_pixels,exception);\n\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"    Writing row of pixels (3)\");\n\n                png_write_row(ping,ping_pixels);\n\n                status=SetImageProgress(image,SaveImageTag,\n                  (MagickOffsetType) (pass * image->rows + y),\n                  num_passes * image->rows);\n\n                if (status == MagickFalse)\n                  break;\n              }\n            }\n\n          else\n            /* not ((image_depth > 8) ||\n                mng_info->write_png24 || mng_info->write_png32 ||\n                mng_info->write_png48 || mng_info->write_png64 ||\n                (!mng_info->write_png8 && !mng_info->IsPalette))\n             */\n            {\n              if ((ping_color_type != PNG_COLOR_TYPE_GRAY) &&\n                  (ping_color_type != PNG_COLOR_TYPE_GRAY_ALPHA))\n                {\n                  if (logging != MagickFalse)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"  pass %d, Image Is not GRAY or GRAY_ALPHA\",pass);\n\n                  SetQuantumDepth(image,quantum_info,8);\n                  image_depth=8;\n                }\n\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  pass %d, Image Is RGB, 16-bit GRAY, or GRAY_ALPHA\",\n                    pass);\n\n                p=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n                if (p == (const Quantum *) NULL)\n                  break;\n\n                if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n                  {\n                    SetQuantumDepth(image,quantum_info,image->depth);\n\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                       quantum_info,GrayQuantum,ping_pixels,exception);\n                  }\n\n                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n                  {\n                    if (logging != MagickFalse && y == 0)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"  Writing GRAY_ALPHA PNG pixels (4)\");\n\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                         quantum_info,GrayAlphaQuantum,ping_pixels,\n                         exception);\n                  }\n\n                else\n                  {\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                      quantum_info,IndexQuantum,ping_pixels,exception);\n\n                    if (logging != MagickFalse && y <= 2)\n                    {\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Writing row of non-gray pixels (4)\");\n\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  ping_pixels[0]=%d,ping_pixels[1]=%d\",\n                          (int)ping_pixels[0],(int)ping_pixels[1]);\n                    }\n                  }\n                png_write_row(ping,ping_pixels);\n\n                status=SetImageProgress(image,SaveImageTag,\n                  (MagickOffsetType) (pass * image->rows + y),\n                  num_passes * image->rows);\n\n                if (status == MagickFalse)\n                  break;\n              }\n            }\n          }\n        }\n    }\n\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Wrote PNG image data\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Width: %.20g\",(double) ping_width);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Height: %.20g\",(double) ping_height);\n\n      if (mng_info->write_png_depth)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Defined png:bit-depth: %d\",mng_info->write_png_depth);\n        }\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG bit-depth written: %d\",ping_bit_depth);\n\n      if (mng_info->write_png_colortype)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Defined png:color-type: %d\",mng_info->write_png_colortype-1);\n        }\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG color-type written: %d\",ping_color_type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG Interlace method: %d\",ping_interlace_method);\n    }\n  /*\n    Generate text chunks after IDAT.\n  */\n  if (ping_exclude_tEXt == MagickFalse || ping_exclude_zTXt == MagickFalse)\n  {\n    ResetImagePropertyIterator(image);\n    property=GetNextImageProperty(image);\n    while (property != (const char *) NULL)\n    {\n      png_textp\n        text;\n\n      value=GetImageProperty(image,property,exception);\n\n      /* Don't write any \"png:\" or \"jpeg:\" properties; those are just for\n       * \"identify\" or for passing through to another JPEG\n       */\n      if ((LocaleNCompare(property,\"png:\",4) != 0 &&\n           LocaleNCompare(property,\"jpeg:\",5) != 0) &&\n\n\n          /* Suppress density and units if we wrote a pHYs chunk */\n          (ping_exclude_pHYs != MagickFalse      ||\n          LocaleCompare(property,\"density\") != 0 ||\n          LocaleCompare(property,\"units\") != 0) &&\n\n          /* Suppress the IM-generated Date:create and Date:modify */\n          (ping_exclude_date == MagickFalse      ||\n          LocaleNCompare(property, \"Date:\",5) != 0))\n        {\n        if (value != (const char *) NULL)\n          {\n\n#if PNG_LIBPNG_VER >= 10400\n            text=(png_textp) png_malloc(ping,\n                 (png_alloc_size_t) sizeof(png_text));\n#else\n            text=(png_textp) png_malloc(ping,(png_size_t) sizeof(png_text));\n#endif\n            text[0].key=(char *) property;\n            text[0].text=(char *) value;\n            text[0].text_length=strlen(value);\n\n            if (ping_exclude_tEXt != MagickFalse)\n               text[0].compression=PNG_TEXT_COMPRESSION_zTXt;\n\n            else if (ping_exclude_zTXt != MagickFalse)\n               text[0].compression=PNG_TEXT_COMPRESSION_NONE;\n\n            else\n            {\n               text[0].compression=image_info->compression == NoCompression ||\n                 (image_info->compression == UndefinedCompression &&\n                 text[0].text_length < 128) ? PNG_TEXT_COMPRESSION_NONE :\n                 PNG_TEXT_COMPRESSION_zTXt ;\n            }\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Setting up text chunk\");\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    keyword: '%s'\",text[0].key);\n              }\n\n            png_set_text(ping,ping_info,text,1);\n            png_free(ping,text);\n          }\n        }\n      property=GetNextImageProperty(image);\n    }\n  }\n\n  /* write any PNG-chunk-e profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-e\",logging);\n\n  /* write exIf profile */\n  if (ping_have_eXIf != MagickFalse && ping_exclude_eXIf == MagickFalse)\n    {\n      char\n        *name;\n\n      ResetImageProfileIterator(image);\n\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        if (LocaleCompare(name,\"exif\") == 0)\n          {\n            const StringInfo\n              *profile;\n\n            profile=GetImageProfile(image,name);\n\n            if (profile != (StringInfo *) NULL)\n              {\n                png_uint_32\n                  length;\n\n                unsigned char\n                  chunk[4],\n                  *data;\n\n               StringInfo\n                 *ping_profile;\n\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Have eXIf profile\");\n\n               ping_profile=CloneStringInfo(profile);\n               data=GetStringInfoDatum(ping_profile),\n               length=(png_uint_32) GetStringInfoLength(ping_profile);\n\n               PNGType(chunk,mng_eXIf);\n               if (length < 7)\n                 {\n                   ping_profile=DestroyStringInfo(ping_profile);\n                   break;  /* otherwise crashes */\n                 }\n\n               /* skip the \"Exif\\0\\0\" JFIF Exif Header ID */\n               length -= 6;\n\n               LogPNGChunk(logging,chunk,length);\n               (void) WriteBlobMSBULong(image,length);\n               (void) WriteBlob(image,4,chunk);\n               (void) WriteBlob(image,length,data+6);\n               (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),\n                 data+6, (uInt) length));\n               ping_profile=DestroyStringInfo(ping_profile);\n               break;\n             }\n         }\n       name=GetNextImageProfile(image);\n     }\n  }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Writing PNG end info\");\n\n  png_write_end(ping,ping_info);\n\n  if (mng_info->need_fram && (int) image->dispose == BackgroundDispose)\n    {\n      if (mng_info->page.x || mng_info->page.y ||\n          (ping_width != mng_info->page.width) ||\n          (ping_height != mng_info->page.height))\n        {\n          unsigned char\n            chunk[32];\n\n          /*\n            Write FRAM 4 with clipping boundaries followed by FRAM 1.\n          */\n          (void) WriteBlobMSBULong(image,27L);  /* data length=27 */\n          PNGType(chunk,mng_FRAM);\n          LogPNGChunk(logging,mng_FRAM,27L);\n          chunk[4]=4;\n          chunk[5]=0;  /* frame name separator (no name) */\n          chunk[6]=1;  /* flag for changing delay, for next frame only */\n          chunk[7]=0;  /* flag for changing frame timeout */\n          chunk[8]=1;  /* flag for changing frame clipping for next frame */\n          chunk[9]=0;  /* flag for changing frame sync_id */\n          PNGLong(chunk+10,(png_uint_32) (0L)); /* temporary 0 delay */\n          chunk[14]=0; /* clipping boundaries delta type */\n          PNGLong(chunk+15,(png_uint_32) (mng_info->page.x)); /* left cb */\n          PNGLong(chunk+19,\n             (png_uint_32) (mng_info->page.x + ping_width));\n          PNGLong(chunk+23,(png_uint_32) (mng_info->page.y)); /* top cb */\n          PNGLong(chunk+27,\n             (png_uint_32) (mng_info->page.y + ping_height));\n          (void) WriteBlob(image,31,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,31));\n          mng_info->old_framing_mode=4;\n          mng_info->framing_mode=1;\n        }\n\n      else\n        mng_info->framing_mode=3;\n    }\n  if (mng_info->write_mng && !mng_info->need_fram &&\n      ((int) image->dispose == 3))\n     png_error(ping, \"Cannot convert GIF with disposal method 3 to MNG-LC\");\n\n  /*\n    Free PNG resources.\n  */\n\n  png_destroy_write_struct(&ping,&ping_info);\n\n  pixel_info=RelinquishVirtualMemory(pixel_info);\n\n  if (ping_have_blob != MagickFalse)\n     (void) CloseBlob(image);\n\n  image_info=DestroyImageInfo(image_info);\n  image=DestroyImage(image);\n\n  /* Store bit depth actually written */\n  s[0]=(char) ping_bit_depth;\n  s[1]='\\0';\n\n  (void) SetImageProperty(IMimage,\"png:bit-depth-written\",s,exception);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit WriteOnePNGImage()\");\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n   /* }  for navigation to beginning of SETJMP-protected block. Revert to\n    *    Throwing an Exception when an error occurs.\n    */\n\n  return(MagickTrue);\n/*  End write one PNG image */\n\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P N G I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePNGImage() writes a Portable Network Graphics (PNG) or\n%  Multiple-image Network Graphics (MNG) image file.\n%\n%  MNG support written by Glenn Randers-Pehrson, glennrp@image...\n%\n%  The format of the WritePNGImage method is:\n%\n%      MagickBooleanType WritePNGImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n%  Returns MagickTrue on success, MagickFalse on failure.\n%\n%  Communicating with the PNG encoder:\n%\n%  While the datastream written is always in PNG format and normally would\n%  be given the \"png\" file extension, this method also writes the following\n%  pseudo-formats which are subsets of png:\n%\n%    o PNG8:    An 8-bit indexed PNG datastream is written.  If the image has\n%               a depth greater than 8, the depth is reduced. If transparency\n%               is present, the tRNS chunk must only have values 0 and 255\n%               (i.e., transparency is binary: fully opaque or fully\n%               transparent).  If other values are present they will be\n%               50%-thresholded to binary transparency.  If more than 256\n%               colors are present, they will be quantized to the 4-4-4-1,\n%               3-3-3-1, or 3-3-2-1 palette.  The underlying RGB color\n%               of any resulting fully-transparent pixels is changed to\n%               the image's background color.\n%\n%               If you want better quantization or dithering of the colors\n%               or alpha than that, you need to do it before calling the\n%               PNG encoder. The pixels contain 8-bit indices even if\n%               they could be represented with 1, 2, or 4 bits.  Grayscale\n%               images will be written as indexed PNG files even though the\n%               PNG grayscale type might be slightly more efficient.  Please\n%               note that writing to the PNG8 format may result in loss\n%               of color and alpha data.\n%\n%    o PNG24:   An 8-bit per sample RGB PNG datastream is written.  The tRNS\n%               chunk can be present to convey binary transparency by naming\n%               one of the colors as transparent.  The only loss incurred\n%               is reduction of sample depth to 8.  If the image has more\n%               than one transparent color, has semitransparent pixels, or\n%               has an opaque pixel with the same RGB components as the\n%               transparent color, an image is not written.\n%\n%    o PNG32:   An 8-bit per sample RGBA PNG is written.  Partial\n%               transparency is permitted, i.e., the alpha sample for\n%               each pixel can have any value from 0 to 255. The alpha\n%               channel is present even if the image is fully opaque.\n%               The only loss in data is the reduction of the sample depth\n%               to 8.\n%\n%    o PNG48:   A 16-bit per sample RGB PNG datastream is written.  The tRNS\n%               chunk can be present to convey binary transparency by naming\n%               one of the colors as transparent.  If the image has more\n%               than one transparent color, has semitransparent pixels, or\n%               has an opaque pixel with the same RGB components as the\n%               transparent color, an image is not written.\n%\n%    o PNG64:   A 16-bit per sample RGBA PNG is written.  Partial\n%               transparency is permitted, i.e., the alpha sample for\n%               each pixel can have any value from 0 to 65535. The alpha\n%               channel is present even if the image is fully opaque.\n%\n%    o PNG00:   A PNG that inherits its colortype and bit-depth from the input\n%               image, if the input was a PNG, is written.  If these values\n%               cannot be found, or if the pixels have been changed in a way\n%               that makes this impossible, then \"PNG00\" falls back to the\n%               regular \"PNG\" format.\n%\n%    o -define: For more precise control of the PNG output, you can use the\n%               Image options \"png:bit-depth\" and \"png:color-type\".  These\n%               can be set from the commandline with \"-define\" and also\n%               from the application programming interfaces.  The options\n%               are case-independent and are converted to lowercase before\n%               being passed to this encoder.\n%\n%               png:color-type can be 0, 2, 3, 4, or 6.\n%\n%               When png:color-type is 0 (Grayscale), png:bit-depth can\n%               be 1, 2, 4, 8, or 16.\n%\n%               When png:color-type is 2 (RGB), png:bit-depth can\n%               be 8 or 16.\n%\n%               When png:color-type is 3 (Indexed), png:bit-depth can\n%               be 1, 2, 4, or 8.  This refers to the number of bits\n%               used to store the index.  The color samples always have\n%               bit-depth 8 in indexed PNG files.\n%\n%               When png:color-type is 4 (Gray-Matte) or 6 (RGB-Matte),\n%               png:bit-depth can be 8 or 16.\n%\n%               If the image cannot be written without loss with the\n%               requested bit-depth and color-type, a PNG file will not\n%               be written, a warning will be issued, and the encoder will\n%               return MagickFalse.\n%\n%  Since image encoders should not be responsible for the \"heavy lifting\",\n%  the user should make sure that ImageMagick has already reduced the\n%  image depth and number of colors and limit transparency to binary\n%  transparency prior to attempting to write the image with depth, color,\n%  or transparency limitations.\n%\n%  Note that another definition, \"png:bit-depth-written\" exists, but it\n%  is not intended for external use.  It is only used internally by the\n%  PNG encoder to inform the JNG encoder of the depth of the alpha channel.\n%\n%  It is possible to request that the PNG encoder write previously-formatted\n%  ancillary chunks in the output PNG file, using the \"-profile\" commandline\n%  option as shown below or by setting the profile via a programming\n%  interface:\n%\n%     -profile PNG-chunk-x:<file>\n%\n%  where x is a location flag and <file> is a file containing the chunk\n%  name in the first 4 bytes, then a colon (\":\"), followed by the chunk data.\n%  This encoder will compute the chunk length and CRC, so those must not\n%  be included in the file.\n%\n%  \"x\" can be \"b\" (before PLTE), \"m\" (middle, i.e., between PLTE and IDAT),\n%  or \"e\" (end, i.e., after IDAT).  If you want to write multiple chunks\n%  of the same type, then add a short unique string after the \"x\" to prevent\n%  subsequent profiles from overwriting the preceding ones, e.g.,\n%\n%     -profile PNG-chunk-b01:file01 -profile PNG-chunk-b02:file02\n%\n%  As of version 6.6.6 the following optimizations are always done:\n%\n%   o  32-bit depth is reduced to 16.\n%   o  16-bit depth is reduced to 8 if all pixels contain samples whose\n%      high byte and low byte are identical.\n%   o  Palette is sorted to remove unused entries and to put a\n%      transparent color first, if BUILD_PNG_PALETTE is defined.\n%   o  Opaque matte channel is removed when writing an indexed PNG.\n%   o  Grayscale images are reduced to 1, 2, or 4 bit depth if\n%      this can be done without loss and a larger bit depth N was not\n%      requested via the \"-define png:bit-depth=N\" option.\n%   o  If matte channel is present but only one transparent color is\n%      present, RGB+tRNS is written instead of RGBA\n%   o  Opaque matte channel is removed (or added, if color-type 4 or 6\n%      was requested when converting an opaque image).\n%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\nstatic MagickBooleanType WritePNGImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    excluding,\n    logging,\n    status;\n\n  MngInfo\n    *mng_info;\n\n  const char\n    *value;\n\n  int\n    source;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\"Enter WritePNGImage()\");\n  /*\n    Allocate a MngInfo structure.\n  */\n  mng_info=(MngInfo *) AcquireMagickMemory(sizeof(MngInfo));\n\n  if (mng_info == (MngInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /*\n    Initialize members of the MngInfo structure.\n  */\n  (void) ResetMagickMemory(mng_info,0,sizeof(MngInfo));\n  mng_info->image=image;\n  mng_info->equal_backgrounds=MagickTrue;\n\n  /* See if user has requested a specific PNG subformat */\n\n  mng_info->write_png8=LocaleCompare(image_info->magick,\"PNG8\") == 0;\n  mng_info->write_png24=LocaleCompare(image_info->magick,\"PNG24\") == 0;\n  mng_info->write_png32=LocaleCompare(image_info->magick,\"PNG32\") == 0;\n  mng_info->write_png48=LocaleCompare(image_info->magick,\"PNG48\") == 0;\n  mng_info->write_png64=LocaleCompare(image_info->magick,\"PNG64\") == 0;\n\n  value=GetImageOption(image_info,\"png:format\");\n\n  if (value != (char *) NULL || LocaleCompare(image_info->magick,\"PNG00\") == 0)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"  Format=%s\",value);\n\n      mng_info->write_png8 = MagickFalse;\n      mng_info->write_png24 = MagickFalse;\n      mng_info->write_png32 = MagickFalse;\n      mng_info->write_png48 = MagickFalse;\n      mng_info->write_png64 = MagickFalse;\n\n      if (LocaleCompare(value,\"png8\") == 0)\n        mng_info->write_png8 = MagickTrue;\n\n      else if (LocaleCompare(value,\"png24\") == 0)\n        mng_info->write_png24 = MagickTrue;\n\n      else if (LocaleCompare(value,\"png32\") == 0)\n        mng_info->write_png32 = MagickTrue;\n\n      else if (LocaleCompare(value,\"png48\") == 0)\n        mng_info->write_png48 = MagickTrue;\n\n      else if (LocaleCompare(value,\"png64\") == 0)\n        mng_info->write_png64 = MagickTrue;\n\n      else if ((LocaleCompare(value,\"png00\") == 0) ||\n         LocaleCompare(image_info->magick,\"PNG00\") == 0)\n        {\n          /* Retrieve png:IHDR.bit-depth-orig and png:IHDR.color-type-orig. */\n          value=GetImageProperty(image,\"png:IHDR.bit-depth-orig\",exception);\n\n          if (value != (char *) NULL)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  png00 inherited bit depth=%s\",value);\n\n              if (LocaleCompare(value,\"1\") == 0)\n                mng_info->write_png_depth = 1;\n\n              else if (LocaleCompare(value,\"2\") == 0)\n                mng_info->write_png_depth = 2;\n\n              else if (LocaleCompare(value,\"4\") == 0)\n                mng_info->write_png_depth = 4;\n\n              else if (LocaleCompare(value,\"8\") == 0)\n                mng_info->write_png_depth = 8;\n\n              else if (LocaleCompare(value,\"16\") == 0)\n                mng_info->write_png_depth = 16;\n            }\n\n          value=GetImageProperty(image,\"png:IHDR.color-type-orig\",exception);\n\n          if (value != (char *) NULL)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  png00 inherited color type=%s\",value);\n\n              if (LocaleCompare(value,\"0\") == 0)\n                mng_info->write_png_colortype = 1;\n\n              else if (LocaleCompare(value,\"2\") == 0)\n                mng_info->write_png_colortype = 3;\n\n              else if (LocaleCompare(value,\"3\") == 0)\n                mng_info->write_png_colortype = 4;\n\n              else if (LocaleCompare(value,\"4\") == 0)\n                mng_info->write_png_colortype = 5;\n\n              else if (LocaleCompare(value,\"6\") == 0)\n                mng_info->write_png_colortype = 7;\n            }\n        }\n    }\n\n  if (mng_info->write_png8)\n    {\n      mng_info->write_png_colortype = /* 3 */ 4;\n      mng_info->write_png_depth = 8;\n      image->depth = 8;\n    }\n\n  if (mng_info->write_png24)\n    {\n      mng_info->write_png_colortype = /* 2 */ 3;\n      mng_info->write_png_depth = 8;\n      image->depth = 8;\n\n      if (image->alpha_trait != UndefinedPixelTrait)\n        (void) SetImageType(image,TrueColorAlphaType,exception);\n\n      else\n        (void) SetImageType(image,TrueColorType,exception);\n\n      (void) SyncImage(image,exception);\n    }\n\n  if (mng_info->write_png32)\n    {\n      mng_info->write_png_colortype = /* 6 */  7;\n      mng_info->write_png_depth = 8;\n      image->depth = 8;\n      image->alpha_trait = BlendPixelTrait;\n\n      (void) SetImageType(image,TrueColorAlphaType,exception);\n      (void) SyncImage(image,exception);\n    }\n\n  if (mng_info->write_png48)\n    {\n      mng_info->write_png_colortype = /* 2 */ 3;\n      mng_info->write_png_depth = 16;\n      image->depth = 16;\n\n      if (image->alpha_trait != UndefinedPixelTrait)\n        (void) SetImageType(image,TrueColorAlphaType,exception);\n\n      else\n        (void) SetImageType(image,TrueColorType,exception);\n\n      (void) SyncImage(image,exception);\n    }\n\n  if (mng_info->write_png64)\n    {\n      mng_info->write_png_colortype = /* 6 */  7;\n      mng_info->write_png_depth = 16;\n      image->depth = 16;\n      image->alpha_trait = BlendPixelTrait;\n\n      (void) SetImageType(image,TrueColorAlphaType,exception);\n      (void) SyncImage(image,exception);\n    }\n\n  value=GetImageOption(image_info,\"png:bit-depth\");\n\n  if (value != (char *) NULL)\n    {\n      if (LocaleCompare(value,\"1\") == 0)\n        mng_info->write_png_depth = 1;\n\n      else if (LocaleCompare(value,\"2\") == 0)\n        mng_info->write_png_depth = 2;\n\n      else if (LocaleCompare(value,\"4\") == 0)\n        mng_info->write_png_depth = 4;\n\n      else if (LocaleCompare(value,\"8\") == 0)\n        mng_info->write_png_depth = 8;\n\n      else if (LocaleCompare(value,\"16\") == 0)\n        mng_info->write_png_depth = 16;\n\n      else\n        (void) ThrowMagickException(exception,\n             GetMagickModule(),CoderWarning,\n             \"ignoring invalid defined png:bit-depth\",\n             \"=%s\",value);\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  png:bit-depth=%d was defined.\\n\",mng_info->write_png_depth);\n    }\n\n  value=GetImageOption(image_info,\"png:color-type\");\n\n  if (value != (char *) NULL)\n    {\n      /* We must store colortype+1 because 0 is a valid colortype */\n      if (LocaleCompare(value,\"0\") == 0)\n        mng_info->write_png_colortype = 1;\n\n      else if (LocaleCompare(value,\"1\") == 0)\n        mng_info->write_png_colortype = 2;\n\n      else if (LocaleCompare(value,\"2\") == 0)\n        mng_info->write_png_colortype = 3;\n\n      else if (LocaleCompare(value,\"3\") == 0)\n        mng_info->write_png_colortype = 4;\n\n      else if (LocaleCompare(value,\"4\") == 0)\n        mng_info->write_png_colortype = 5;\n\n      else if (LocaleCompare(value,\"6\") == 0)\n        mng_info->write_png_colortype = 7;\n\n      else\n        (void) ThrowMagickException(exception,\n             GetMagickModule(),CoderWarning,\n             \"ignoring invalid defined png:color-type\",\n             \"=%s\",value);\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  png:color-type=%d was defined.\\n\",\n          mng_info->write_png_colortype-1);\n    }\n\n  /* Check for chunks to be excluded:\n   *\n   * The default is to not exclude any known chunks except for any\n   * listed in the \"unused_chunks\" array, above.\n   *\n   * Chunks can be listed for exclusion via a \"png:exclude-chunk\"\n   * define (in the image properties or in the image artifacts)\n   * or via a mng_info member.  For convenience, in addition\n   * to or instead of a comma-separated list of chunks, the\n   * \"exclude-chunk\" string can be simply \"all\" or \"none\".\n   *\n   * The exclude-chunk define takes priority over the mng_info.\n   *\n   * A \"png:include-chunk\" define takes  priority over both the\n   * mng_info and the \"png:exclude-chunk\" define.  Like the\n   * \"exclude-chunk\" string, it can define \"all\" or \"none\" as\n   * well as a comma-separated list.  Chunks that are unknown to\n   * ImageMagick are always excluded, regardless of their \"copy-safe\"\n   * status according to the PNG specification, and even if they\n   * appear in the \"include-chunk\" list. Such defines appearing among\n   * the image options take priority over those found among the image\n   * artifacts.\n   *\n   * Finally, all chunks listed in the \"unused_chunks\" array are\n   * automatically excluded, regardless of the other instructions\n   * or lack thereof.\n   *\n   * if you exclude sRGB but not gAMA (recommended), then sRGB chunk\n   * will not be written and the gAMA chunk will only be written if it\n   * is not between .45 and .46, or approximately (1.0/2.2).\n   *\n   * If you exclude tRNS and the image has transparency, the colortype\n   * is forced to be 4 or 6 (GRAY_ALPHA or RGB_ALPHA).\n   *\n   * The -strip option causes StripImage() to set the png:include-chunk\n   * artifact to \"none,trns,gama\".\n   */\n\n  mng_info->ping_exclude_bKGD=MagickFalse;\n  mng_info->ping_exclude_caNv=MagickFalse;\n  mng_info->ping_exclude_cHRM=MagickFalse;\n  mng_info->ping_exclude_date=MagickFalse;\n  mng_info->ping_exclude_eXIf=MagickFalse;\n  mng_info->ping_exclude_EXIF=MagickFalse; /* hex-encoded EXIF in zTXt */\n  mng_info->ping_exclude_gAMA=MagickFalse;\n  mng_info->ping_exclude_iCCP=MagickFalse;\n  /* mng_info->ping_exclude_iTXt=MagickFalse; */\n  mng_info->ping_exclude_oFFs=MagickFalse;\n  mng_info->ping_exclude_pHYs=MagickFalse;\n  mng_info->ping_exclude_sRGB=MagickFalse;\n  mng_info->ping_exclude_tEXt=MagickFalse;\n  mng_info->ping_exclude_tIME=MagickFalse;\n  mng_info->ping_exclude_tRNS=MagickFalse;\n  mng_info->ping_exclude_vpAg=MagickFalse;\n  mng_info->ping_exclude_zCCP=MagickFalse; /* hex-encoded iCCP in zTXt */\n  mng_info->ping_exclude_zTXt=MagickFalse;\n\n  mng_info->ping_preserve_colormap=MagickFalse;\n\n  value=GetImageOption(image_info,\"png:preserve-colormap\");\n  if (value == NULL)\n     value=GetImageArtifact(image,\"png:preserve-colormap\");\n  if (value != NULL)\n     mng_info->ping_preserve_colormap=MagickTrue;\n\n  mng_info->ping_preserve_iCCP=MagickFalse;\n\n  value=GetImageOption(image_info,\"png:preserve-iCCP\");\n  if (value == NULL)\n     value=GetImageArtifact(image,\"png:preserve-iCCP\");\n  if (value != NULL)\n     mng_info->ping_preserve_iCCP=MagickTrue;\n\n  /* These compression-level, compression-strategy, and compression-filter\n   * defines take precedence over values from the -quality option.\n   */\n  value=GetImageOption(image_info,\"png:compression-level\");\n  if (value == NULL)\n     value=GetImageArtifact(image,\"png:compression-level\");\n  if (value != NULL)\n  {\n      /* We have to add 1 to everything because 0 is a valid input,\n       * and we want to use 0 (the default) to mean undefined.\n       */\n      if (LocaleCompare(value,\"0\") == 0)\n        mng_info->write_png_compression_level = 1;\n\n      else if (LocaleCompare(value,\"1\") == 0)\n        mng_info->write_png_compression_level = 2;\n\n      else if (LocaleCompare(value,\"2\") == 0)\n        mng_info->write_png_compression_level = 3;\n\n      else if (LocaleCompare(value,\"3\") == 0)\n        mng_info->write_png_compression_level = 4;\n\n      else if (LocaleCompare(value,\"4\") == 0)\n        mng_info->write_png_compression_level = 5;\n\n      else if (LocaleCompare(value,\"5\") == 0)\n        mng_info->write_png_compression_level = 6;\n\n      else if (LocaleCompare(value,\"6\") == 0)\n        mng_info->write_png_compression_level = 7;\n\n      else if (LocaleCompare(value,\"7\") == 0)\n        mng_info->write_png_compression_level = 8;\n\n      else if (LocaleCompare(value,\"8\") == 0)\n        mng_info->write_png_compression_level = 9;\n\n      else if (LocaleCompare(value,\"9\") == 0)\n        mng_info->write_png_compression_level = 10;\n\n      else\n        (void) ThrowMagickException(exception,\n             GetMagickModule(),CoderWarning,\n             \"ignoring invalid defined png:compression-level\",\n             \"=%s\",value);\n    }\n\n  value=GetImageOption(image_info,\"png:compression-strategy\");\n  if (value == NULL)\n     value=GetImageArtifact(image,\"png:compression-strategy\");\n  if (value != NULL)\n  {\n      if (LocaleCompare(value,\"0\") == 0)\n        mng_info->write_png_compression_strategy = Z_DEFAULT_STRATEGY+1;\n\n      else if (LocaleCompare(value,\"1\") == 0)\n        mng_info->write_png_compression_strategy = Z_FILTERED+1;\n\n      else if (LocaleCompare(value,\"2\") == 0)\n        mng_info->write_png_compression_strategy = Z_HUFFMAN_ONLY+1;\n\n      else if (LocaleCompare(value,\"3\") == 0)\n#ifdef Z_RLE  /* Z_RLE was added to zlib-1.2.0 */\n        mng_info->write_png_compression_strategy = Z_RLE+1;\n#else\n        mng_info->write_png_compression_strategy = Z_DEFAULT_STRATEGY+1;\n#endif\n\n      else if (LocaleCompare(value,\"4\") == 0)\n#ifdef Z_FIXED  /* Z_FIXED was added to zlib-1.2.2.2 */\n        mng_info->write_png_compression_strategy = Z_FIXED+1;\n#else\n        mng_info->write_png_compression_strategy = Z_DEFAULT_STRATEGY+1;\n#endif\n\n      else\n        (void) ThrowMagickException(exception,\n             GetMagickModule(),CoderWarning,\n             \"ignoring invalid defined png:compression-strategy\",\n             \"=%s\",value);\n    }\n\n  value=GetImageOption(image_info,\"png:compression-filter\");\n  if (value == NULL)\n     value=GetImageArtifact(image,\"png:compression-filter\");\n  if (value != NULL)\n  {\n      /* To do: combinations of filters allowed by libpng\n       * masks 0x08 through 0xf8\n       *\n       * Implement this as a comma-separated list of 0,1,2,3,4,5\n       * where 5 is a special case meaning PNG_ALL_FILTERS.\n       */\n\n      if (LocaleCompare(value,\"0\") == 0)\n        mng_info->write_png_compression_filter = 1;\n\n      else if (LocaleCompare(value,\"1\") == 0)\n        mng_info->write_png_compression_filter = 2;\n\n      else if (LocaleCompare(value,\"2\") == 0)\n        mng_info->write_png_compression_filter = 3;\n\n      else if (LocaleCompare(value,\"3\") == 0)\n        mng_info->write_png_compression_filter = 4;\n\n      else if (LocaleCompare(value,\"4\") == 0)\n        mng_info->write_png_compression_filter = 5;\n\n      else if (LocaleCompare(value,\"5\") == 0)\n        mng_info->write_png_compression_filter = 6;\n\n      else\n        (void) ThrowMagickException(exception,\n             GetMagickModule(),CoderWarning,\n             \"ignoring invalid defined png:compression-filter\",\n             \"=%s\",value);\n  }\n\n  for (source=0; source<8; source++)\n  {\n    value = NULL;\n\n    if (source == 0)\n      value=GetImageOption(image_info,\"png:exclude-chunks\");\n\n    if (source == 1)\n      value=GetImageArtifact(image,\"png:exclude-chunks\");\n\n    if (source == 2)\n      value=GetImageOption(image_info,\"png:exclude-chunk\");\n\n    if (source == 3)\n      value=GetImageArtifact(image,\"png:exclude-chunk\");\n\n    if (source == 4)\n      value=GetImageOption(image_info,\"png:include-chunks\");\n\n    if (source == 5)\n      value=GetImageArtifact(image,\"png:include-chunks\");\n\n    if (source == 6)\n      value=GetImageOption(image_info,\"png:include-chunk\");\n\n    if (source == 7)\n      value=GetImageArtifact(image,\"png:include-chunk\");\n\n    if (value == NULL)\n       continue;\n\n    if (source < 4)\n      excluding = MagickTrue;\n    else\n      excluding = MagickFalse;\n\n    if (logging != MagickFalse)\n      {\n        if (source == 0 || source == 2)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  png:exclude-chunk=%s found in image options.\\n\", value);\n        else if (source == 1 || source == 3)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  png:exclude-chunk=%s found in image artifacts.\\n\", value);\n        else if (source == 4 || source == 6)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  png:include-chunk=%s found in image options.\\n\", value);\n        else /* if (source == 5 || source == 7) */\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  png:include-chunk=%s found in image artifacts.\\n\", value);\n      }\n\n    if (IsOptionMember(\"all\",value) != MagickFalse)\n      {\n        mng_info->ping_exclude_bKGD=excluding;\n        mng_info->ping_exclude_caNv=excluding;\n        mng_info->ping_exclude_cHRM=excluding;\n        mng_info->ping_exclude_date=excluding;\n        mng_info->ping_exclude_EXIF=excluding;\n        mng_info->ping_exclude_eXIf=excluding;\n        mng_info->ping_exclude_gAMA=excluding;\n        mng_info->ping_exclude_iCCP=excluding;\n        /* mng_info->ping_exclude_iTXt=excluding; */\n        mng_info->ping_exclude_oFFs=excluding;\n        mng_info->ping_exclude_pHYs=excluding;\n        mng_info->ping_exclude_sRGB=excluding;\n        mng_info->ping_exclude_tEXt=excluding;\n        mng_info->ping_exclude_tIME=excluding;\n        mng_info->ping_exclude_tRNS=excluding;\n        mng_info->ping_exclude_vpAg=excluding;\n        mng_info->ping_exclude_zCCP=excluding;\n        mng_info->ping_exclude_zTXt=excluding;\n      }\n\n    if (IsOptionMember(\"none\",value) != MagickFalse)\n      {\n        mng_info->ping_exclude_bKGD=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_caNv=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_cHRM=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_date=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_eXIf=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_EXIF=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_gAMA=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_iCCP=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        /* mng_info->ping_exclude_iTXt=!excluding; */\n        mng_info->ping_exclude_oFFs=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_pHYs=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_sRGB=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_tEXt=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_tIME=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_tRNS=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_vpAg=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_zCCP=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_zTXt=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n      }\n\n    if (IsOptionMember(\"bkgd\",value) != MagickFalse)\n      mng_info->ping_exclude_bKGD=excluding;\n\n    if (IsOptionMember(\"caNv\",value) != MagickFalse)\n      mng_info->ping_exclude_caNv=excluding;\n\n    if (IsOptionMember(\"chrm\",value) != MagickFalse)\n      mng_info->ping_exclude_cHRM=excluding;\n\n    if (IsOptionMember(\"date\",value) != MagickFalse)\n      mng_info->ping_exclude_date=excluding;\n\n    if (IsOptionMember(\"exif\",value) != MagickFalse)\n      {\n        mng_info->ping_exclude_EXIF=excluding;\n        mng_info->ping_exclude_eXIf=excluding;\n      }\n\n    if (IsOptionMember(\"gama\",value) != MagickFalse)\n      mng_info->ping_exclude_gAMA=excluding;\n\n    if (IsOptionMember(\"iccp\",value) != MagickFalse)\n      mng_info->ping_exclude_iCCP=excluding;\n\n#if 0\n    if (IsOptionMember(\"itxt\",value) != MagickFalse)\n      mng_info->ping_exclude_iTXt=excluding;\n#endif\n\n    if (IsOptionMember(\"offs\",value) != MagickFalse)\n      mng_info->ping_exclude_oFFs=excluding;\n\n    if (IsOptionMember(\"phys\",value) != MagickFalse)\n      mng_info->ping_exclude_pHYs=excluding;\n\n    if (IsOptionMember(\"srgb\",value) != MagickFalse)\n      mng_info->ping_exclude_sRGB=excluding;\n\n    if (IsOptionMember(\"text\",value) != MagickFalse)\n      mng_info->ping_exclude_tEXt=excluding;\n\n    if (IsOptionMember(\"time\",value) != MagickFalse)\n      mng_info->ping_exclude_tIME=excluding;\n\n    if (IsOptionMember(\"trns\",value) != MagickFalse)\n      mng_info->ping_exclude_tRNS=excluding;\n\n    if (IsOptionMember(\"vpag\",value) != MagickFalse)\n      mng_info->ping_exclude_vpAg=excluding;\n\n    if (IsOptionMember(\"zccp\",value) != MagickFalse)\n      mng_info->ping_exclude_zCCP=excluding;\n\n    if (IsOptionMember(\"ztxt\",value) != MagickFalse)\n      mng_info->ping_exclude_zTXt=excluding;\n  }\n\n  if (logging != MagickFalse)\n  {\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Chunks to be excluded from the output png:\");\n    if (mng_info->ping_exclude_bKGD != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    bKGD\");\n    if (mng_info->ping_exclude_caNv != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    caNv\");\n    if (mng_info->ping_exclude_cHRM != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    cHRM\");\n    if (mng_info->ping_exclude_date != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    date\");\n    if (mng_info->ping_exclude_EXIF != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    EXIF\");\n    if (mng_info->ping_exclude_eXIf != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    eXIf\");\n    if (mng_info->ping_exclude_gAMA != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    gAMA\");\n    if (mng_info->ping_exclude_iCCP != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    iCCP\");\n#if 0\n    if (mng_info->ping_exclude_iTXt != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    iTXt\");\n#endif\n\n    if (mng_info->ping_exclude_oFFs != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    oFFs\");\n    if (mng_info->ping_exclude_pHYs != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    pHYs\");\n    if (mng_info->ping_exclude_sRGB != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    sRGB\");\n    if (mng_info->ping_exclude_tEXt != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    tEXt\");\n    if (mng_info->ping_exclude_tIME != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    tIME\");\n    if (mng_info->ping_exclude_tRNS != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    tRNS\");\n    if (mng_info->ping_exclude_vpAg != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    vpAg\");\n    if (mng_info->ping_exclude_zCCP != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    zCCP\");\n    if (mng_info->ping_exclude_zTXt != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    zTXt\");\n  }\n\n  mng_info->need_blob = MagickTrue;\n\n  status=WriteOnePNGImage(mng_info,image_info,image,exception);\n\n  mng_info=MngInfoFreeStruct(mng_info);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"exit WritePNGImage()\");\n\n  return(status);\n}\n\n#if defined(JNG_SUPPORTED)\n\n/* Write one JNG image */\nstatic MagickBooleanType WriteOneJNGImage(MngInfo *mng_info,\n   const ImageInfo *image_info,Image *image,ExceptionInfo *exception)\n{\n  Image\n    *jpeg_image;\n\n  ImageInfo\n    *jpeg_image_info;\n\n  MagickBooleanType\n    logging,\n    status;\n\n  size_t\n    length;\n\n  unsigned char\n    *blob,\n    chunk[80],\n    *p;\n\n  unsigned int\n    jng_alpha_compression_method,\n    jng_alpha_sample_depth,\n    jng_color_type,\n    transparent;\n\n  size_t\n    jng_alpha_quality,\n    jng_quality;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter WriteOneJNGImage()\");\n\n  blob=(unsigned char *) NULL;\n  jpeg_image=(Image *) NULL;\n  jpeg_image_info=(ImageInfo *) NULL;\n  length=0;\n\n  status=MagickTrue;\n  transparent=image_info->type==GrayscaleAlphaType ||\n     image_info->type==TrueColorAlphaType ||\n     image->alpha_trait != UndefinedPixelTrait;\n\n  jng_alpha_sample_depth = 0;\n\n  jng_quality=image_info->quality == 0UL ? 75UL : image_info->quality%1000;\n\n  jng_alpha_compression_method=image->compression==JPEGCompression? 8 : 0;\n\n  jng_alpha_quality=image_info->quality == 0UL ? 75UL :\n      image_info->quality;\n\n  if (jng_alpha_quality >= 1000)\n    jng_alpha_quality /= 1000;\n\n  length=0;\n\n  if (transparent != 0)\n    {\n      jng_color_type=14;\n\n      /* Create JPEG blob, image, and image_info */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Creating jpeg_image_info for alpha.\");\n\n      jpeg_image_info=(ImageInfo *) CloneImageInfo(image_info);\n\n      if (jpeg_image_info == (ImageInfo *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Creating jpeg_image.\");\n\n      jpeg_image=SeparateImage(image,AlphaChannel,exception);\n      if (jpeg_image == (Image *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      (void) CopyMagickString(jpeg_image->magick,\"JPEG\",MagickPathExtent);\n      jpeg_image->alpha_trait=UndefinedPixelTrait;\n      jpeg_image->quality=jng_alpha_quality;\n      jpeg_image_info->type=GrayscaleType;\n      (void) SetImageType(jpeg_image,GrayscaleType,exception);\n      (void) AcquireUniqueFilename(jpeg_image->filename);\n      (void) FormatLocaleString(jpeg_image_info->filename,MagickPathExtent,\n        \"%s\",jpeg_image->filename);\n    }\n  else\n    {\n      jng_alpha_compression_method=0;\n      jng_color_type=10;\n      jng_alpha_sample_depth=0;\n    }\n\n  /* To do: check bit depth of PNG alpha channel */\n\n  /* Check if image is grayscale. */\n  if (image_info->type != TrueColorAlphaType && image_info->type !=\n    TrueColorType && SetImageGray(image,exception))\n    jng_color_type-=2;\n\n  if (logging != MagickFalse)\n    {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    JNG Quality           = %d\",(int) jng_quality);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    JNG Color Type        = %d\",jng_color_type);\n        if (transparent != 0)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    JNG Alpha Compression = %d\",jng_alpha_compression_method);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    JNG Alpha Depth       = %d\",jng_alpha_sample_depth);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    JNG Alpha Quality     = %d\",(int) jng_alpha_quality);\n          }\n    }\n\n  if (transparent != 0)\n    {\n      if (jng_alpha_compression_method==0)\n        {\n          const char\n            *value;\n\n          /* Encode alpha as a grayscale PNG blob */\n          status=OpenBlob(jpeg_image_info,jpeg_image,WriteBinaryBlobMode,\n            exception);\n          if (status == MagickFalse)\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Creating PNG blob.\");\n\n          (void) CopyMagickString(jpeg_image_info->magick,\"PNG\",\n             MagickPathExtent);\n          (void) CopyMagickString(jpeg_image->magick,\"PNG\",MagickPathExtent);\n          jpeg_image_info->interlace=NoInterlace;\n\n          /* Exclude all ancillary chunks */\n          (void) SetImageArtifact(jpeg_image,\"png:exclude-chunks\",\"all\");\n\n          blob=(unsigned char *) ImageToBlob(jpeg_image_info,jpeg_image,\n            &length,exception);\n\n          /* Retrieve sample depth used */\n          value=GetImageProperty(jpeg_image,\"png:bit-depth-written\",exception);\n          if (value != (char *) NULL)\n            jng_alpha_sample_depth= (unsigned int) value[0];\n        }\n      else\n        {\n          /* Encode alpha as a grayscale JPEG blob */\n\n          status=OpenBlob(jpeg_image_info,jpeg_image,WriteBinaryBlobMode,\n            exception);\n          if (status == MagickFalse)\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n          (void) CopyMagickString(jpeg_image_info->magick,\"JPEG\",\n            MagickPathExtent);\n          (void) CopyMagickString(jpeg_image->magick,\"JPEG\",MagickPathExtent);\n          jpeg_image_info->interlace=NoInterlace;\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Creating blob.\");\n          blob=(unsigned char *) ImageToBlob(jpeg_image_info,\n             jpeg_image,&length,\n           exception);\n          jng_alpha_sample_depth=8;\n\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Successfully read jpeg_image into a blob, length=%.20g.\",\n              (double) length);\n\n        }\n      /* Destroy JPEG image and image_info */\n      jpeg_image=DestroyImage(jpeg_image);\n      (void) RelinquishUniqueFileResource(jpeg_image_info->filename);\n      jpeg_image_info=DestroyImageInfo(jpeg_image_info);\n    }\n\n  /* Write JHDR chunk */\n  (void) WriteBlobMSBULong(image,16L);  /* chunk data length=16 */\n  PNGType(chunk,mng_JHDR);\n  LogPNGChunk(logging,mng_JHDR,16L);\n  PNGLong(chunk+4,(png_uint_32) image->columns);\n  PNGLong(chunk+8,(png_uint_32) image->rows);\n  chunk[12]=jng_color_type;\n  chunk[13]=8;  /* sample depth */\n  chunk[14]=8; /*jng_image_compression_method */\n  chunk[15]=(unsigned char) (image_info->interlace == NoInterlace ? 0 : 8);\n  chunk[16]=jng_alpha_sample_depth;\n  chunk[17]=jng_alpha_compression_method;\n  chunk[18]=0; /*jng_alpha_filter_method */\n  chunk[19]=0; /*jng_alpha_interlace_method */\n  (void) WriteBlob(image,20,chunk);\n  (void) WriteBlobMSBULong(image,crc32(0,chunk,20));\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG width:%15lu\",(unsigned long) image->columns);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG height:%14lu\",(unsigned long) image->rows);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG color type:%10d\",jng_color_type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG sample depth:%8d\",8);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG compression:%9d\",8);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG interlace:%11d\",0);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG alpha depth:%9d\",jng_alpha_sample_depth);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG alpha compression:%3d\",jng_alpha_compression_method);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG alpha filter:%8d\",0);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG alpha interlace:%5d\",0);\n    }\n\n  /* Write any JNG-chunk-b profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"JNG-chunk-b\",logging);\n\n  /*\n     Write leading ancillary chunks\n  */\n\n  if (transparent != 0)\n  {\n    /*\n      Write JNG bKGD chunk\n    */\n\n    unsigned char\n      blue,\n      green,\n      red;\n\n    ssize_t\n      num_bytes;\n\n    if (jng_color_type == 8 || jng_color_type == 12)\n      num_bytes=6L;\n    else\n      num_bytes=10L;\n    (void) WriteBlobMSBULong(image,(size_t) (num_bytes-4L));\n    PNGType(chunk,mng_bKGD);\n    LogPNGChunk(logging,mng_bKGD,(size_t) (num_bytes-4L));\n    red=ScaleQuantumToChar(image->background_color.red);\n    green=ScaleQuantumToChar(image->background_color.green);\n    blue=ScaleQuantumToChar(image->background_color.blue);\n    *(chunk+4)=0;\n    *(chunk+5)=red;\n    *(chunk+6)=0;\n    *(chunk+7)=green;\n    *(chunk+8)=0;\n    *(chunk+9)=blue;\n    (void) WriteBlob(image,(size_t) num_bytes,chunk);\n    (void) WriteBlobMSBULong(image,crc32(0,chunk,(uInt) num_bytes));\n  }\n\n  if ((image->colorspace == sRGBColorspace || image->rendering_intent))\n    {\n      /*\n        Write JNG sRGB chunk\n      */\n      (void) WriteBlobMSBULong(image,1L);\n      PNGType(chunk,mng_sRGB);\n      LogPNGChunk(logging,mng_sRGB,1L);\n\n      if (image->rendering_intent != UndefinedIntent)\n        chunk[4]=(unsigned char)\n          Magick_RenderingIntent_to_PNG_RenderingIntent(\n          (image->rendering_intent));\n\n      else\n        chunk[4]=(unsigned char)\n          Magick_RenderingIntent_to_PNG_RenderingIntent(\n          (PerceptualIntent));\n\n      (void) WriteBlob(image,5,chunk);\n      (void) WriteBlobMSBULong(image,crc32(0,chunk,5));\n    }\n  else\n    {\n      if (image->gamma != 0.0)\n        {\n          /*\n             Write JNG gAMA chunk\n          */\n          (void) WriteBlobMSBULong(image,4L);\n          PNGType(chunk,mng_gAMA);\n          LogPNGChunk(logging,mng_gAMA,4L);\n          PNGLong(chunk+4,(png_uint_32) (100000*image->gamma+0.5));\n          (void) WriteBlob(image,8,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,8));\n        }\n\n      if ((mng_info->equal_chrms == MagickFalse) &&\n          (image->chromaticity.red_primary.x != 0.0))\n        {\n          PrimaryInfo\n            primary;\n\n          /*\n             Write JNG cHRM chunk\n          */\n          (void) WriteBlobMSBULong(image,32L);\n          PNGType(chunk,mng_cHRM);\n          LogPNGChunk(logging,mng_cHRM,32L);\n          primary=image->chromaticity.white_point;\n          PNGLong(chunk+4,(png_uint_32) (100000*primary.x+0.5));\n          PNGLong(chunk+8,(png_uint_32) (100000*primary.y+0.5));\n          primary=image->chromaticity.red_primary;\n          PNGLong(chunk+12,(png_uint_32) (100000*primary.x+0.5));\n          PNGLong(chunk+16,(png_uint_32) (100000*primary.y+0.5));\n          primary=image->chromaticity.green_primary;\n          PNGLong(chunk+20,(png_uint_32) (100000*primary.x+0.5));\n          PNGLong(chunk+24,(png_uint_32) (100000*primary.y+0.5));\n          primary=image->chromaticity.blue_primary;\n          PNGLong(chunk+28,(png_uint_32) (100000*primary.x+0.5));\n          PNGLong(chunk+32,(png_uint_32) (100000*primary.y+0.5));\n          (void) WriteBlob(image,36,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,36));\n        }\n    }\n\n  if (image->resolution.x && image->resolution.y && !mng_info->equal_physs)\n    {\n      /*\n         Write JNG pHYs chunk\n      */\n      (void) WriteBlobMSBULong(image,9L);\n      PNGType(chunk,mng_pHYs);\n      LogPNGChunk(logging,mng_pHYs,9L);\n      if (image->units == PixelsPerInchResolution)\n        {\n          PNGLong(chunk+4,(png_uint_32)\n            (image->resolution.x*100.0/2.54+0.5));\n\n          PNGLong(chunk+8,(png_uint_32)\n            (image->resolution.y*100.0/2.54+0.5));\n\n          chunk[12]=1;\n        }\n\n      else\n        {\n          if (image->units == PixelsPerCentimeterResolution)\n            {\n              PNGLong(chunk+4,(png_uint_32)\n                (image->resolution.x*100.0+0.5));\n\n              PNGLong(chunk+8,(png_uint_32)\n                (image->resolution.y*100.0+0.5));\n\n              chunk[12]=1;\n            }\n\n          else\n            {\n              PNGLong(chunk+4,(png_uint_32) (image->resolution.x+0.5));\n              PNGLong(chunk+8,(png_uint_32) (image->resolution.y+0.5));\n              chunk[12]=0;\n            }\n        }\n      (void) WriteBlob(image,13,chunk);\n      (void) WriteBlobMSBULong(image,crc32(0,chunk,13));\n    }\n\n  if (mng_info->write_mng == 0 && (image->page.x || image->page.y))\n    {\n      /*\n         Write JNG oFFs chunk\n      */\n      (void) WriteBlobMSBULong(image,9L);\n      PNGType(chunk,mng_oFFs);\n      LogPNGChunk(logging,mng_oFFs,9L);\n      PNGsLong(chunk+4,(ssize_t) (image->page.x));\n      PNGsLong(chunk+8,(ssize_t) (image->page.y));\n      chunk[12]=0;\n      (void) WriteBlob(image,13,chunk);\n      (void) WriteBlobMSBULong(image,crc32(0,chunk,13));\n    }\n  if (mng_info->write_mng == 0 && (image->page.width || image->page.height))\n    {\n       (void) WriteBlobMSBULong(image,9L);  /* data length=8 */\n       PNGType(chunk,mng_vpAg);\n       LogPNGChunk(logging,mng_vpAg,9L);\n       PNGLong(chunk+4,(png_uint_32) image->page.width);\n       PNGLong(chunk+8,(png_uint_32) image->page.height);\n       chunk[12]=0;   /* unit = pixels */\n       (void) WriteBlob(image,13,chunk);\n       (void) WriteBlobMSBULong(image,crc32(0,chunk,13));\n    }\n\n  if (transparent != 0)\n    {\n      if (jng_alpha_compression_method==0)\n        {\n          register ssize_t\n            i;\n\n          size_t\n            len;\n\n          /* Write IDAT chunk header */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Write IDAT chunks from blob, length=%.20g.\",(double)\n              length);\n\n          /* Copy IDAT chunks */\n          len=0;\n          p=blob+8;\n          for (i=8; i<(ssize_t) length; i+=len+12)\n          {\n            len=(((unsigned int) *(p    ) & 0xff) << 24) +\n                (((unsigned int) *(p + 1) & 0xff) << 16) +\n                (((unsigned int) *(p + 2) & 0xff) <<  8) +\n                (((unsigned int) *(p + 3) & 0xff)      ) ;\n            p+=4;\n\n            if (*(p)==73 && *(p+1)==68 && *(p+2)==65 && *(p+3)==84) /* IDAT */\n              {\n                /* Found an IDAT chunk. */\n                (void) WriteBlobMSBULong(image,len);\n                LogPNGChunk(logging,mng_IDAT,len);\n                (void) WriteBlob(image,len+4,p);\n                (void) WriteBlobMSBULong(image, crc32(0,p,(uInt) len+4));\n              }\n\n            else\n              {\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Skipping %c%c%c%c chunk, length=%.20g.\",\n                    *(p),*(p+1),*(p+2),*(p+3),(double) len);\n              }\n            p+=(8+len);\n          }\n        }\n      else if (length != 0)\n        {\n          /* Write JDAA chunk header */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Write JDAA chunk, length=%.20g.\",(double) length);\n          (void) WriteBlobMSBULong(image,(size_t) length);\n          PNGType(chunk,mng_JDAA);\n          LogPNGChunk(logging,mng_JDAA,length);\n          /* Write JDAT chunk(s) data */\n          (void) WriteBlob(image,4,chunk);\n          (void) WriteBlob(image,length,blob);\n          (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),blob,\n             (uInt) length));\n        }\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n    }\n\n  /* Encode image as a JPEG blob */\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Creating jpeg_image_info.\");\n  jpeg_image_info=(ImageInfo *) CloneImageInfo(image_info);\n  if (jpeg_image_info == (ImageInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Creating jpeg_image.\");\n\n  jpeg_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (jpeg_image == (Image *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) CopyMagickString(jpeg_image->magick,\"JPEG\",MagickPathExtent);\n\n  (void) AcquireUniqueFilename(jpeg_image->filename);\n  (void) FormatLocaleString(jpeg_image_info->filename,MagickPathExtent,\"%s\",\n    jpeg_image->filename);\n\n  status=OpenBlob(jpeg_image_info,jpeg_image,WriteBinaryBlobMode,\n    exception);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Created jpeg_image, %.20g x %.20g.\",(double) jpeg_image->columns,\n      (double) jpeg_image->rows);\n\n  if (status == MagickFalse)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  if (jng_color_type == 8 || jng_color_type == 12)\n    jpeg_image_info->type=GrayscaleType;\n\n  jpeg_image_info->quality=jng_quality;\n  jpeg_image->quality=jng_quality;\n  (void) CopyMagickString(jpeg_image_info->magick,\"JPEG\",MagickPathExtent);\n  (void) CopyMagickString(jpeg_image->magick,\"JPEG\",MagickPathExtent);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Creating blob.\");\n\n  blob=(unsigned char *) ImageToBlob(jpeg_image_info,jpeg_image,&length,\n    exception);\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Successfully read jpeg_image into a blob, length=%.20g.\",\n        (double) length);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Write JDAT chunk, length=%.20g.\",(double) length);\n    }\n\n  /* Write JDAT chunk(s) */\n  (void) WriteBlobMSBULong(image,(size_t) length);\n  PNGType(chunk,mng_JDAT);\n  LogPNGChunk(logging,mng_JDAT,length);\n  (void) WriteBlob(image,4,chunk);\n  (void) WriteBlob(image,length,blob);\n  (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),blob,(uInt) length));\n\n  jpeg_image=DestroyImage(jpeg_image);\n  (void) RelinquishUniqueFileResource(jpeg_image_info->filename);\n  jpeg_image_info=DestroyImageInfo(jpeg_image_info);\n  blob=(unsigned char *) RelinquishMagickMemory(blob);\n\n  /* Write any JNG-chunk-e profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"JNG-chunk-e\",logging);\n\n  /* Write IEND chunk */\n  (void) WriteBlobMSBULong(image,0L);\n  PNGType(chunk,mng_IEND);\n  LogPNGChunk(logging,mng_IEND,0);\n  (void) WriteBlob(image,4,chunk);\n  (void) WriteBlobMSBULong(image,crc32(0,chunk,4));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit WriteOneJNGImage()\");\n\n  return(status);\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e J N G I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteJNGImage() writes a JPEG Network Graphics (JNG) image file.\n%\n%  JNG support written by Glenn Randers-Pehrson, glennrp@image...\n%\n%  The format of the WriteJNGImage method is:\n%\n%      MagickBooleanType WriteJNGImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\nstatic MagickBooleanType WriteJNGImage(const ImageInfo *image_info,\n  Image *image, ExceptionInfo *exception)\n{\n  MagickBooleanType\n    logging,\n    status;\n\n  MngInfo\n    *mng_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\"Enter WriteJNGImage()\");\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if ((image->columns > 65535UL) || (image->rows > 65535UL))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n\n  /*\n    Allocate a MngInfo structure.\n  */\n  mng_info=(MngInfo *) AcquireMagickMemory(sizeof(MngInfo));\n  if (mng_info == (MngInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Initialize members of the MngInfo structure.\n  */\n  (void) ResetMagickMemory(mng_info,0,sizeof(MngInfo));\n  mng_info->image=image;\n\n  (void) WriteBlob(image,8,(const unsigned char *) \"\\213JNG\\r\\n\\032\\n\");\n\n  status=WriteOneJNGImage(mng_info,image_info,image,exception);\n  mng_info=MngInfoFreeStruct(mng_info);\n  (void) CloseBlob(image);\n\n  (void) CatchImageException(image);\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"exit WriteJNGImage()\");\n  return(status);\n}\n#endif\n\nstatic MagickBooleanType WriteMNGImage(const ImageInfo *image_info,\n  Image *image, ExceptionInfo *exception)\n{\n  Image\n    *next_image;\n\n  MagickBooleanType\n    status;\n\n  volatile MagickBooleanType\n    logging;\n\n  MngInfo\n    *mng_info;\n\n  int\n    image_count,\n    need_iterations,\n    need_matte;\n\n  volatile int\n#if defined(PNG_WRITE_EMPTY_PLTE_SUPPORTED) || \\\n    defined(PNG_MNG_FEATURES_SUPPORTED)\n    need_local_plte,\n#endif\n    all_images_are_gray,\n    need_defi,\n    use_global_plte;\n\n  register ssize_t\n    i;\n\n  unsigned char\n    chunk[800];\n\n  volatile unsigned int\n    write_jng,\n    write_mng;\n\n  volatile size_t\n    scene;\n\n  size_t\n    final_delay=0,\n    initial_delay;\n\n#if (PNG_LIBPNG_VER < 10200)\n    if (image_info->verbose)\n      printf(\"Your PNG library (libpng-%s) is rather old.\\n\",\n         PNG_LIBPNG_VER_STRING);\n#endif\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\"Enter WriteMNGImage()\");\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n\n  /*\n    Allocate a MngInfo structure.\n  */\n  mng_info=(MngInfo *) AcquireMagickMemory(sizeof(MngInfo));\n  if (mng_info == (MngInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Initialize members of the MngInfo structure.\n  */\n  (void) ResetMagickMemory(mng_info,0,sizeof(MngInfo));\n  mng_info->image=image;\n  write_mng=LocaleCompare(image_info->magick,\"MNG\") == 0;\n\n  /*\n   * See if user has requested a specific PNG subformat to be used\n   * for all of the PNGs in the MNG being written, e.g.,\n   *\n   *    convert *.png png8:animation.mng\n   *\n   * To do: check -define png:bit_depth and png:color_type as well,\n   * or perhaps use mng:bit_depth and mng:color_type instead for\n   * global settings.\n   */\n\n  mng_info->write_png8=LocaleCompare(image_info->magick,\"PNG8\") == 0;\n  mng_info->write_png24=LocaleCompare(image_info->magick,\"PNG24\") == 0;\n  mng_info->write_png32=LocaleCompare(image_info->magick,\"PNG32\") == 0;\n\n  write_jng=MagickFalse;\n  if (image_info->compression == JPEGCompression)\n    write_jng=MagickTrue;\n\n  mng_info->adjoin=image_info->adjoin &&\n    (GetNextImageInList(image) != (Image *) NULL) && write_mng;\n\n  if (logging != MagickFalse)\n    {\n      /* Log some info about the input */\n      Image\n        *p;\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Checking input image(s)\\n\"\n        \"    Image_info depth: %.20g,    Type: %d\",\n        (double) image_info->depth, image_info->type);\n\n      scene=0;\n      for (p=image; p != (Image *) NULL; p=GetNextImageInList(p))\n      {\n\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"    Scene: %.20g\\n,   Image depth: %.20g\",\n           (double) scene++, (double) p->depth);\n\n        if (p->alpha_trait != UndefinedPixelTrait)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      Matte: True\");\n\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      Matte: False\");\n\n        if (p->storage_class == PseudoClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      Storage class: PseudoClass\");\n\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      Storage class: DirectClass\");\n\n        if (p->colors)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      Number of colors: %.20g\",(double) p->colors);\n\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      Number of colors: unspecified\");\n\n        if (mng_info->adjoin == MagickFalse)\n          break;\n      }\n    }\n\n  use_global_plte=MagickFalse;\n  all_images_are_gray=MagickFalse;\n#ifdef PNG_WRITE_EMPTY_PLTE_SUPPORTED\n  need_local_plte=MagickTrue;\n#endif\n  need_defi=MagickFalse;\n  need_matte=MagickFalse;\n  mng_info->framing_mode=1;\n  mng_info->old_framing_mode=1;\n\n  if (write_mng)\n      if (image_info->page != (char *) NULL)\n        {\n          /*\n            Determine image bounding box.\n          */\n          SetGeometry(image,&mng_info->page);\n          (void) ParseMetaGeometry(image_info->page,&mng_info->page.x,\n            &mng_info->page.y,&mng_info->page.width,&mng_info->page.height);\n        }\n  if (write_mng)\n    {\n      unsigned int\n        need_geom;\n\n      unsigned short\n        red,\n        green,\n        blue;\n\n      const char *\n        option;\n\n      mng_info->page=image->page;\n      need_geom=MagickTrue;\n      if (mng_info->page.width || mng_info->page.height)\n         need_geom=MagickFalse;\n      /*\n        Check all the scenes.\n      */\n      initial_delay=image->delay;\n      need_iterations=MagickFalse;\n      mng_info->equal_chrms=image->chromaticity.red_primary.x != 0.0;\n      mng_info->equal_physs=MagickTrue,\n      mng_info->equal_gammas=MagickTrue;\n      mng_info->equal_srgbs=MagickTrue;\n      mng_info->equal_backgrounds=MagickTrue;\n      image_count=0;\n#if defined(PNG_WRITE_EMPTY_PLTE_SUPPORTED) || \\\n    defined(PNG_MNG_FEATURES_SUPPORTED)\n      all_images_are_gray=MagickTrue;\n      mng_info->equal_palettes=MagickFalse;\n      need_local_plte=MagickFalse;\n#endif\n      for (next_image=image; next_image != (Image *) NULL; )\n      {\n        if (need_geom)\n          {\n            if ((next_image->columns+next_image->page.x) > mng_info->page.width)\n              mng_info->page.width=next_image->columns+next_image->page.x;\n\n            if ((next_image->rows+next_image->page.y) > mng_info->page.height)\n              mng_info->page.height=next_image->rows+next_image->page.y;\n          }\n\n        if (next_image->page.x || next_image->page.y)\n          need_defi=MagickTrue;\n\n        if (next_image->alpha_trait != UndefinedPixelTrait)\n          need_matte=MagickTrue;\n\n        if ((int) next_image->dispose >= BackgroundDispose)\n          if ((next_image->alpha_trait != UndefinedPixelTrait) ||\n               next_image->page.x || next_image->page.y ||\n              ((next_image->columns < mng_info->page.width) &&\n               (next_image->rows < mng_info->page.height)))\n            mng_info->need_fram=MagickTrue;\n\n        if (next_image->iterations)\n          need_iterations=MagickTrue;\n\n        final_delay=next_image->delay;\n\n        if (final_delay != initial_delay || final_delay > 1UL*\n           next_image->ticks_per_second)\n          mng_info->need_fram=1;\n\n#if defined(PNG_WRITE_EMPTY_PLTE_SUPPORTED) || \\\n    defined(PNG_MNG_FEATURES_SUPPORTED)\n        /*\n          check for global palette possibility.\n        */\n        if (image->alpha_trait != UndefinedPixelTrait)\n           need_local_plte=MagickTrue;\n\n        if (need_local_plte == 0)\n          {\n            if (SetImageGray(image,exception) == MagickFalse)\n              all_images_are_gray=MagickFalse;\n            mng_info->equal_palettes=PalettesAreEqual(image,next_image);\n            if (use_global_plte == 0)\n              use_global_plte=mng_info->equal_palettes;\n            need_local_plte=!mng_info->equal_palettes;\n          }\n#endif\n        if (GetNextImageInList(next_image) != (Image *) NULL)\n          {\n            if (next_image->background_color.red !=\n                next_image->next->background_color.red ||\n                next_image->background_color.green !=\n                next_image->next->background_color.green ||\n                next_image->background_color.blue !=\n                next_image->next->background_color.blue)\n              mng_info->equal_backgrounds=MagickFalse;\n\n            if (next_image->gamma != next_image->next->gamma)\n              mng_info->equal_gammas=MagickFalse;\n\n            if (next_image->rendering_intent !=\n                next_image->next->rendering_intent)\n              mng_info->equal_srgbs=MagickFalse;\n\n            if ((next_image->units != next_image->next->units) ||\n                (next_image->resolution.x != next_image->next->resolution.x) ||\n                (next_image->resolution.y != next_image->next->resolution.y))\n              mng_info->equal_physs=MagickFalse;\n\n            if (mng_info->equal_chrms)\n              {\n                if (next_image->chromaticity.red_primary.x !=\n                    next_image->next->chromaticity.red_primary.x ||\n                    next_image->chromaticity.red_primary.y !=\n                    next_image->next->chromaticity.red_primary.y ||\n                    next_image->chromaticity.green_primary.x !=\n                    next_image->next->chromaticity.green_primary.x ||\n                    next_image->chromaticity.green_primary.y !=\n                    next_image->next->chromaticity.green_primary.y ||\n                    next_image->chromaticity.blue_primary.x !=\n                    next_image->next->chromaticity.blue_primary.x ||\n                    next_image->chromaticity.blue_primary.y !=\n                    next_image->next->chromaticity.blue_primary.y ||\n                    next_image->chromaticity.white_point.x !=\n                    next_image->next->chromaticity.white_point.x ||\n                    next_image->chromaticity.white_point.y !=\n                    next_image->next->chromaticity.white_point.y)\n                  mng_info->equal_chrms=MagickFalse;\n              }\n          }\n        image_count++;\n        next_image=GetNextImageInList(next_image);\n      }\n      if (image_count < 2)\n        {\n          mng_info->equal_backgrounds=MagickFalse;\n          mng_info->equal_chrms=MagickFalse;\n          mng_info->equal_gammas=MagickFalse;\n          mng_info->equal_srgbs=MagickFalse;\n          mng_info->equal_physs=MagickFalse;\n          use_global_plte=MagickFalse;\n#ifdef PNG_WRITE_EMPTY_PLTE_SUPPORTED\n          need_local_plte=MagickTrue;\n#endif\n          need_iterations=MagickFalse;\n        }\n\n     if (mng_info->need_fram == MagickFalse)\n       {\n         /*\n           Only certain framing rates 100/n are exactly representable without\n           the FRAM chunk but we'll allow some slop in VLC files\n         */\n         if (final_delay == 0)\n           {\n             if (need_iterations != MagickFalse)\n               {\n                 /*\n                   It's probably a GIF with loop; don't run it *too* fast.\n                 */\n                 if (mng_info->adjoin)\n                   {\n                     final_delay=10;\n                     (void) ThrowMagickException(exception,GetMagickModule(),\n                       CoderWarning,\n                       \"input has zero delay between all frames; assuming\",\n                       \" 10 cs `%s'\",\"\");\n                   }\n               }\n             else\n               mng_info->ticks_per_second=0;\n           }\n         if (final_delay != 0)\n           mng_info->ticks_per_second=(png_uint_32)\n              (image->ticks_per_second/final_delay);\n         if (final_delay > 50)\n           mng_info->ticks_per_second=2;\n\n         if (final_delay > 75)\n           mng_info->ticks_per_second=1;\n\n         if (final_delay > 125)\n           mng_info->need_fram=MagickTrue;\n\n         if (need_defi && final_delay > 2 && (final_delay != 4) &&\n            (final_delay != 5) && (final_delay != 10) && (final_delay != 20) &&\n            (final_delay != 25) && (final_delay != 50) &&\n            (final_delay != (size_t) image->ticks_per_second))\n           mng_info->need_fram=MagickTrue;  /* make it exact; cannot be VLC */\n       }\n\n     if (mng_info->need_fram != MagickFalse)\n        mng_info->ticks_per_second=image->ticks_per_second;\n     /*\n        If pseudocolor, we should also check to see if all the\n        palettes are identical and write a global PLTE if they are.\n        ../glennrp Feb 99.\n     */\n     /*\n        Write the MNG version 1.0 signature and MHDR chunk.\n     */\n     (void) WriteBlob(image,8,(const unsigned char *) \"\\212MNG\\r\\n\\032\\n\");\n     (void) WriteBlobMSBULong(image,28L);  /* chunk data length=28 */\n     PNGType(chunk,mng_MHDR);\n     LogPNGChunk(logging,mng_MHDR,28L);\n     PNGLong(chunk+4,(png_uint_32) mng_info->page.width);\n     PNGLong(chunk+8,(png_uint_32) mng_info->page.height);\n     PNGLong(chunk+12,mng_info->ticks_per_second);\n     PNGLong(chunk+16,0L);  /* layer count=unknown */\n     PNGLong(chunk+20,0L);  /* frame count=unknown */\n     PNGLong(chunk+24,0L);  /* play time=unknown   */\n     if (write_jng)\n       {\n         if (need_matte)\n           {\n             if (need_defi || mng_info->need_fram || use_global_plte)\n               PNGLong(chunk+28,27L);    /* simplicity=LC+JNG */\n\n             else\n               PNGLong(chunk+28,25L);    /* simplicity=VLC+JNG */\n           }\n\n         else\n           {\n             if (need_defi || mng_info->need_fram || use_global_plte)\n               PNGLong(chunk+28,19L);  /* simplicity=LC+JNG, no transparency */\n\n             else\n               PNGLong(chunk+28,17L);  /* simplicity=VLC+JNG, no transparency */\n           }\n       }\n\n     else\n       {\n         if (need_matte)\n           {\n             if (need_defi || mng_info->need_fram || use_global_plte)\n               PNGLong(chunk+28,11L);    /* simplicity=LC */\n\n             else\n               PNGLong(chunk+28,9L);    /* simplicity=VLC */\n           }\n\n         else\n           {\n             if (need_defi || mng_info->need_fram || use_global_plte)\n               PNGLong(chunk+28,3L);    /* simplicity=LC, no transparency */\n\n             else\n               PNGLong(chunk+28,1L);    /* simplicity=VLC, no transparency */\n           }\n       }\n     (void) WriteBlob(image,32,chunk);\n     (void) WriteBlobMSBULong(image,crc32(0,chunk,32));\n     option=GetImageOption(image_info,\"mng:need-cacheoff\");\n     if (option != (const char *) NULL)\n       {\n         size_t\n           length;\n         /*\n           Write \"nEED CACHEOFF\" to turn playback caching off for streaming MNG.\n         */\n         PNGType(chunk,mng_nEED);\n         length=CopyMagickString((char *) chunk+4,\"CACHEOFF\",20);\n         (void) WriteBlobMSBULong(image,(size_t) length);\n         LogPNGChunk(logging,mng_nEED,(size_t) length);\n         length+=4;\n         (void) WriteBlob(image,length,chunk);\n         (void) WriteBlobMSBULong(image,crc32(0,chunk,(uInt) length));\n       }\n     if ((GetPreviousImageInList(image) == (Image *) NULL) &&\n         (GetNextImageInList(image) != (Image *) NULL) &&\n         (image->iterations != 1))\n       {\n         /*\n           Write MNG TERM chunk\n         */\n         (void) WriteBlobMSBULong(image,10L);  /* data length=10 */\n         PNGType(chunk,mng_TERM);\n         LogPNGChunk(logging,mng_TERM,10L);\n         chunk[4]=3;  /* repeat animation */\n         chunk[5]=0;  /* show last frame when done */\n         PNGLong(chunk+6,(png_uint_32) (mng_info->ticks_per_second*\n            final_delay/MagickMax(image->ticks_per_second,1)));\n\n         if (image->iterations == 0)\n           PNGLong(chunk+10,PNG_UINT_31_MAX);\n\n         else\n           PNGLong(chunk+10,(png_uint_32) image->iterations);\n\n         if (logging != MagickFalse)\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"     TERM delay: %.20g\",(double) (mng_info->ticks_per_second*\n              final_delay/MagickMax(image->ticks_per_second,1)));\n\n             if (image->iterations == 0)\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"     TERM iterations: %.20g\",(double) PNG_UINT_31_MAX);\n\n             else\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"     Image iterations: %.20g\",(double) image->iterations);\n           }\n         (void) WriteBlob(image,14,chunk);\n         (void) WriteBlobMSBULong(image,crc32(0,chunk,14));\n       }\n     /*\n       To do: check for cHRM+gAMA == sRGB, and write sRGB instead.\n     */\n     if ((image->colorspace == sRGBColorspace || image->rendering_intent) &&\n          mng_info->equal_srgbs)\n       {\n         /*\n           Write MNG sRGB chunk\n         */\n         (void) WriteBlobMSBULong(image,1L);\n         PNGType(chunk,mng_sRGB);\n         LogPNGChunk(logging,mng_sRGB,1L);\n\n         if (image->rendering_intent != UndefinedIntent)\n           chunk[4]=(unsigned char)\n             Magick_RenderingIntent_to_PNG_RenderingIntent(\n             (image->rendering_intent));\n\n         else\n           chunk[4]=(unsigned char)\n             Magick_RenderingIntent_to_PNG_RenderingIntent(\n               (PerceptualIntent));\n\n         (void) WriteBlob(image,5,chunk);\n         (void) WriteBlobMSBULong(image,crc32(0,chunk,5));\n         mng_info->have_write_global_srgb=MagickTrue;\n       }\n\n     else\n       {\n         if (image->gamma && mng_info->equal_gammas)\n           {\n             /*\n                Write MNG gAMA chunk\n             */\n             (void) WriteBlobMSBULong(image,4L);\n             PNGType(chunk,mng_gAMA);\n             LogPNGChunk(logging,mng_gAMA,4L);\n             PNGLong(chunk+4,(png_uint_32) (100000*image->gamma+0.5));\n             (void) WriteBlob(image,8,chunk);\n             (void) WriteBlobMSBULong(image,crc32(0,chunk,8));\n             mng_info->have_write_global_gama=MagickTrue;\n           }\n         if (mng_info->equal_chrms)\n           {\n             PrimaryInfo\n               primary;\n\n             /*\n                Write MNG cHRM chunk\n             */\n             (void) WriteBlobMSBULong(image,32L);\n             PNGType(chunk,mng_cHRM);\n             LogPNGChunk(logging,mng_cHRM,32L);\n             primary=image->chromaticity.white_point;\n             PNGLong(chunk+4,(png_uint_32) (100000*primary.x+0.5));\n             PNGLong(chunk+8,(png_uint_32) (100000*primary.y+0.5));\n             primary=image->chromaticity.red_primary;\n             PNGLong(chunk+12,(png_uint_32) (100000*primary.x+0.5));\n             PNGLong(chunk+16,(png_uint_32) (100000*primary.y+0.5));\n             primary=image->chromaticity.green_primary;\n             PNGLong(chunk+20,(png_uint_32) (100000*primary.x+0.5));\n             PNGLong(chunk+24,(png_uint_32) (100000*primary.y+0.5));\n             primary=image->chromaticity.blue_primary;\n             PNGLong(chunk+28,(png_uint_32) (100000*primary.x+0.5));\n             PNGLong(chunk+32,(png_uint_32) (100000*primary.y+0.5));\n             (void) WriteBlob(image,36,chunk);\n             (void) WriteBlobMSBULong(image,crc32(0,chunk,36));\n             mng_info->have_write_global_chrm=MagickTrue;\n           }\n       }\n     if (image->resolution.x && image->resolution.y && mng_info->equal_physs)\n       {\n         /*\n            Write MNG pHYs chunk\n         */\n         (void) WriteBlobMSBULong(image,9L);\n         PNGType(chunk,mng_pHYs);\n         LogPNGChunk(logging,mng_pHYs,9L);\n\n         if (image->units == PixelsPerInchResolution)\n           {\n             PNGLong(chunk+4,(png_uint_32)\n               (image->resolution.x*100.0/2.54+0.5));\n\n             PNGLong(chunk+8,(png_uint_32)\n               (image->resolution.y*100.0/2.54+0.5));\n\n             chunk[12]=1;\n           }\n\n         else\n           {\n             if (image->units == PixelsPerCentimeterResolution)\n               {\n                 PNGLong(chunk+4,(png_uint_32)\n                   (image->resolution.x*100.0+0.5));\n\n                 PNGLong(chunk+8,(png_uint_32)\n                   (image->resolution.y*100.0+0.5));\n\n                 chunk[12]=1;\n               }\n\n             else\n               {\n                 PNGLong(chunk+4,(png_uint_32) (image->resolution.x+0.5));\n                 PNGLong(chunk+8,(png_uint_32) (image->resolution.y+0.5));\n                 chunk[12]=0;\n               }\n           }\n         (void) WriteBlob(image,13,chunk);\n         (void) WriteBlobMSBULong(image,crc32(0,chunk,13));\n       }\n     /*\n       Write MNG BACK chunk and global bKGD chunk, if the image is transparent\n       or does not cover the entire frame.\n     */\n     if (write_mng && ((image->alpha_trait != UndefinedPixelTrait) ||\n         image->page.x > 0 || image->page.y > 0 || (image->page.width &&\n         (image->page.width+image->page.x < mng_info->page.width))\n         || (image->page.height && (image->page.height+image->page.y\n         < mng_info->page.height))))\n       {\n         (void) WriteBlobMSBULong(image,6L);\n         PNGType(chunk,mng_BACK);\n         LogPNGChunk(logging,mng_BACK,6L);\n         red=ScaleQuantumToShort(image->background_color.red);\n         green=ScaleQuantumToShort(image->background_color.green);\n         blue=ScaleQuantumToShort(image->background_color.blue);\n         PNGShort(chunk+4,red);\n         PNGShort(chunk+6,green);\n         PNGShort(chunk+8,blue);\n         (void) WriteBlob(image,10,chunk);\n         (void) WriteBlobMSBULong(image,crc32(0,chunk,10));\n         if (mng_info->equal_backgrounds)\n           {\n             (void) WriteBlobMSBULong(image,6L);\n             PNGType(chunk,mng_bKGD);\n             LogPNGChunk(logging,mng_bKGD,6L);\n             (void) WriteBlob(image,10,chunk);\n             (void) WriteBlobMSBULong(image,crc32(0,chunk,10));\n           }\n       }\n\n#ifdef PNG_WRITE_EMPTY_PLTE_SUPPORTED\n     if ((need_local_plte == MagickFalse) &&\n         (image->storage_class == PseudoClass) &&\n         (all_images_are_gray == MagickFalse))\n       {\n         size_t\n           data_length;\n\n         /*\n           Write MNG PLTE chunk\n         */\n         data_length=3*image->colors;\n         (void) WriteBlobMSBULong(image,data_length);\n         PNGType(chunk,mng_PLTE);\n         LogPNGChunk(logging,mng_PLTE,data_length);\n\n         for (i=0; i < (ssize_t) image->colors; i++)\n         {\n           chunk[4+i*3]=(unsigned char) (ScaleQuantumToChar(\n             image->colormap[i].red) & 0xff);\n           chunk[5+i*3]=(unsigned char) (ScaleQuantumToChar(\n             image->colormap[i].green) & 0xff);\n           chunk[6+i*3]=(unsigned char) (ScaleQuantumToChar(\n             image->colormap[i].blue) & 0xff);\n         }\n\n         (void) WriteBlob(image,data_length+4,chunk);\n         (void) WriteBlobMSBULong(image,crc32(0,chunk,(uInt) (data_length+4)));\n         mng_info->have_write_global_plte=MagickTrue;\n       }\n#endif\n    }\n  scene=0;\n  mng_info->delay=0;\n#if defined(PNG_WRITE_EMPTY_PLTE_SUPPORTED) || \\\n    defined(PNG_MNG_FEATURES_SUPPORTED)\n  mng_info->equal_palettes=MagickFalse;\n#endif\n  do\n  {\n    if (mng_info->adjoin)\n    {\n#if defined(PNG_WRITE_EMPTY_PLTE_SUPPORTED) || \\\n    defined(PNG_MNG_FEATURES_SUPPORTED)\n    /*\n      If we aren't using a global palette for the entire MNG, check to\n      see if we can use one for two or more consecutive images.\n    */\n    if (need_local_plte && use_global_plte && !all_images_are_gray)\n      {\n        if (mng_info->IsPalette)\n          {\n            /*\n              When equal_palettes is true, this image has the same palette\n              as the previous PseudoClass image\n            */\n            mng_info->have_write_global_plte=mng_info->equal_palettes;\n            mng_info->equal_palettes=PalettesAreEqual(image,image->next);\n            if (mng_info->equal_palettes && !mng_info->have_write_global_plte)\n              {\n                /*\n                  Write MNG PLTE chunk\n                */\n                size_t\n                  data_length;\n\n                data_length=3*image->colors;\n                (void) WriteBlobMSBULong(image,data_length);\n                PNGType(chunk,mng_PLTE);\n                LogPNGChunk(logging,mng_PLTE,data_length);\n\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  chunk[4+i*3]=ScaleQuantumToChar(image->colormap[i].red);\n                  chunk[5+i*3]=ScaleQuantumToChar(image->colormap[i].green);\n                  chunk[6+i*3]=ScaleQuantumToChar(image->colormap[i].blue);\n                }\n\n                (void) WriteBlob(image,data_length+4,chunk);\n                (void) WriteBlobMSBULong(image,crc32(0,chunk,\n                   (uInt) (data_length+4)));\n                mng_info->have_write_global_plte=MagickTrue;\n              }\n          }\n        else\n          mng_info->have_write_global_plte=MagickFalse;\n      }\n#endif\n    if (need_defi)\n      {\n        ssize_t\n          previous_x,\n          previous_y;\n\n        if (scene)\n          {\n            previous_x=mng_info->page.x;\n            previous_y=mng_info->page.y;\n          }\n        else\n          {\n            previous_x=0;\n            previous_y=0;\n          }\n        mng_info->page=image->page;\n        if ((mng_info->page.x !=  previous_x) ||\n            (mng_info->page.y != previous_y))\n          {\n             (void) WriteBlobMSBULong(image,12L);  /* data length=12 */\n             PNGType(chunk,mng_DEFI);\n             LogPNGChunk(logging,mng_DEFI,12L);\n             chunk[4]=0; /* object 0 MSB */\n             chunk[5]=0; /* object 0 LSB */\n             chunk[6]=0; /* visible  */\n             chunk[7]=0; /* abstract */\n             PNGLong(chunk+8,(png_uint_32) mng_info->page.x);\n             PNGLong(chunk+12,(png_uint_32) mng_info->page.y);\n             (void) WriteBlob(image,16,chunk);\n             (void) WriteBlobMSBULong(image,crc32(0,chunk,16));\n          }\n      }\n    }\n\n   mng_info->write_mng=write_mng;\n\n   if ((int) image->dispose >= 3)\n     mng_info->framing_mode=3;\n\n   if (mng_info->need_fram && mng_info->adjoin &&\n       ((image->delay != mng_info->delay) ||\n        (mng_info->framing_mode != mng_info->old_framing_mode)))\n     {\n       if (image->delay == mng_info->delay)\n         {\n           /*\n             Write a MNG FRAM chunk with the new framing mode.\n           */\n           (void) WriteBlobMSBULong(image,1L);  /* data length=1 */\n           PNGType(chunk,mng_FRAM);\n           LogPNGChunk(logging,mng_FRAM,1L);\n           chunk[4]=(unsigned char) mng_info->framing_mode;\n           (void) WriteBlob(image,5,chunk);\n           (void) WriteBlobMSBULong(image,crc32(0,chunk,5));\n         }\n       else\n         {\n           /*\n             Write a MNG FRAM chunk with the delay.\n           */\n           (void) WriteBlobMSBULong(image,10L);  /* data length=10 */\n           PNGType(chunk,mng_FRAM);\n           LogPNGChunk(logging,mng_FRAM,10L);\n           chunk[4]=(unsigned char) mng_info->framing_mode;\n           chunk[5]=0;  /* frame name separator (no name) */\n           chunk[6]=2;  /* flag for changing default delay */\n           chunk[7]=0;  /* flag for changing frame timeout */\n           chunk[8]=0;  /* flag for changing frame clipping */\n           chunk[9]=0;  /* flag for changing frame sync_id */\n           PNGLong(chunk+10,(png_uint_32)\n             ((mng_info->ticks_per_second*\n             image->delay)/MagickMax(image->ticks_per_second,1)));\n           (void) WriteBlob(image,14,chunk);\n           (void) WriteBlobMSBULong(image,crc32(0,chunk,14));\n           mng_info->delay=(png_uint_32) image->delay;\n         }\n       mng_info->old_framing_mode=mng_info->framing_mode;\n     }\n\n#if defined(JNG_SUPPORTED)\n   if (image_info->compression == JPEGCompression)\n     {\n       ImageInfo\n         *write_info;\n\n       if (logging != MagickFalse)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  Writing JNG object.\");\n       /* To do: specify the desired alpha compression method. */\n       write_info=CloneImageInfo(image_info);\n       write_info->compression=UndefinedCompression;\n       status=WriteOneJNGImage(mng_info,write_info,image,exception);\n       write_info=DestroyImageInfo(write_info);\n     }\n   else\n#endif\n     {\n       if (logging != MagickFalse)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  Writing PNG object.\");\n\n       mng_info->need_blob = MagickFalse;\n       mng_info->ping_preserve_colormap = MagickFalse;\n\n       /* We don't want any ancillary chunks written */\n       mng_info->ping_exclude_bKGD=MagickTrue;\n       mng_info->ping_exclude_caNv=MagickTrue;\n       mng_info->ping_exclude_cHRM=MagickTrue;\n       mng_info->ping_exclude_date=MagickTrue;\n       mng_info->ping_exclude_EXIF=MagickTrue;\n       mng_info->ping_exclude_gAMA=MagickTrue;\n       mng_info->ping_exclude_iCCP=MagickTrue;\n       /* mng_info->ping_exclude_iTXt=MagickTrue; */\n       mng_info->ping_exclude_oFFs=MagickTrue;\n       mng_info->ping_exclude_pHYs=MagickTrue;\n       mng_info->ping_exclude_sRGB=MagickTrue;\n       mng_info->ping_exclude_tEXt=MagickTrue;\n       mng_info->ping_exclude_tRNS=MagickTrue;\n       mng_info->ping_exclude_vpAg=MagickTrue;\n       mng_info->ping_exclude_zCCP=MagickTrue;\n       mng_info->ping_exclude_zTXt=MagickTrue;\n\n       status=WriteOnePNGImage(mng_info,image_info,image,exception);\n     }\n\n    if (status == MagickFalse)\n      {\n        mng_info=MngInfoFreeStruct(mng_info);\n        (void) CloseBlob(image);\n        return(MagickFalse);\n      }\n    (void) CatchImageException(image);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n\n    if (status == MagickFalse)\n      break;\n\n  } while (mng_info->adjoin);\n\n  if (write_mng)\n    {\n      while (GetPreviousImageInList(image) != (Image *) NULL)\n        image=GetPreviousImageInList(image);\n      /*\n        Write the MEND chunk.\n      */\n      (void) WriteBlobMSBULong(image,0x00000000L);\n      PNGType(chunk,mng_MEND);\n      LogPNGChunk(logging,mng_MEND,0L);\n      (void) WriteBlob(image,4,chunk);\n      (void) WriteBlobMSBULong(image,crc32(0,chunk,4));\n    }\n  /*\n    Relinquish resources.\n  */\n  (void) CloseBlob(image);\n  mng_info=MngInfoFreeStruct(mng_info);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"exit WriteMNGImage()\");\n\n  return(MagickTrue);\n}\n#else /* PNG_LIBPNG_VER > 10011 */\n\nstatic MagickBooleanType WritePNGImage(const ImageInfo *image_info,\n  Image *image)\n{\n  (void) image;\n  printf(\"Your PNG library is too old: You have libpng-%s\\n\",\n     PNG_LIBPNG_VER_STRING);\n\n  ThrowBinaryException(CoderError,\"PNG library is too old\",\n     image_info->filename);\n}\n\nstatic MagickBooleanType WriteMNGImage(const ImageInfo *image_info,\n  Image *image)\n{\n  return(WritePNGImage(image_info,image));\n}\n#endif /* PNG_LIBPNG_VER > 10011 */\n#endif\n"], "filenames": ["coders/png.c"], "buggy_code_start_loc": [8282], "buggy_code_end_loc": [8286], "fixing_code_start_loc": [8283], "fixing_code_end_loc": [8288], "type": "CWE-476", "message": "The WriteOnePNGImage function in coders/png.c in ImageMagick through 6.9.9-0 and 7.x through 7.0.6-1 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted file.", "other": {"cve": {"id": "CVE-2017-11522", "sourceIdentifier": "cve@mitre.org", "published": "2017-07-22T21:29:00.180", "lastModified": "2017-07-27T01:39:19.537", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The WriteOnePNGImage function in coders/png.c in ImageMagick through 6.9.9-0 and 7.x through 7.0.6-1 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted file."}, {"lang": "es", "value": "La funci\u00f3n WriteOnePNGImage en el archivo coders/png.c en ImageMagick anterior a versi\u00f3n 6.9.9-0 y 7.x hasta 7.0.6-1, permite a los atacantes remotos causar una denegaci\u00f3n de servicio (desreferencia del puntero NULL) por medio de un archivo creado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.9.9-0", "matchCriteriaId": "FD50817F-6EB7-477D-B5D9-A7E1B10E5FF6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.0-0:*:*:*:*:*:*:*", "matchCriteriaId": "3B7CCC6B-C66E-48E2-BA1E-CBF6421B4FEB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-0:*:*:*:*:*:*:*", "matchCriteriaId": "693C9F8F-A8C1-4D06-8F31-E085E16E701C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-1:*:*:*:*:*:*:*", "matchCriteriaId": "6D3D3DFC-8459-41BA-BF3E-AE84E48FCEE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-2:*:*:*:*:*:*:*", "matchCriteriaId": "A3E12EB4-B8F6-43A3-847D-DBC96AE10905"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-3:*:*:*:*:*:*:*", "matchCriteriaId": "30539421-5872-4C2E-94AE-8A2B05C952C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-4:*:*:*:*:*:*:*", "matchCriteriaId": "1A5B7537-8563-409D-82DE-EB07107D3C04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-5:*:*:*:*:*:*:*", "matchCriteriaId": "FA648D3C-A464-4F54-8B5E-E8431531FBB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-6:*:*:*:*:*:*:*", "matchCriteriaId": "D6666BB0-B211-490F-884C-BE410CD19DAF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-7:*:*:*:*:*:*:*", "matchCriteriaId": "5FF2582D-1513-448B-8B61-9C4844B08324"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-8:*:*:*:*:*:*:*", "matchCriteriaId": "E57E6BA4-A727-4CF5-B15F-76632D02617A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-9:*:*:*:*:*:*:*", "matchCriteriaId": "C721BC6F-61DD-4ED1-8024-2946C494AEC4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-10:*:*:*:*:*:*:*", "matchCriteriaId": "CD319D32-FE7A-456D-AFEE-DC9F0D98652C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-0:*:*:*:*:*:*:*", "matchCriteriaId": "09CDF263-38F5-469F-984B-9D9A223159B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-1:*:*:*:*:*:*:*", "matchCriteriaId": "243FF3C1-D676-4D5F-A90C-3017DCBBE73A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-2:*:*:*:*:*:*:*", "matchCriteriaId": "1B8BDDE6-6B38-442B-83A4-FAADBAE1C792"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-3:*:*:*:*:*:*:*", "matchCriteriaId": "4DCD89B9-6A69-41DE-BE38-5E9193828279"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-4:*:*:*:*:*:*:*", "matchCriteriaId": "139BC277-8E00-4700-8B47-6D3A3CB38B04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-5:*:*:*:*:*:*:*", "matchCriteriaId": "D0FA2E18-6F7B-49D6-B60C-38851398F9B7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-6:*:*:*:*:*:*:*", "matchCriteriaId": "7B7F510A-A439-47A3-AF31-4BF7F74D58A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-7:*:*:*:*:*:*:*", "matchCriteriaId": "A91B94E3-33BB-46B6-A1AE-EAA9906605CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-8:*:*:*:*:*:*:*", "matchCriteriaId": "F5B3DE17-08A8-457D-9AEB-BD6E04376B34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-9:*:*:*:*:*:*:*", "matchCriteriaId": "98AD438E-28B7-4491-B58F-55FDE7F67CFD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-10:*:*:*:*:*:*:*", "matchCriteriaId": "7E033A09-4F2F-4957-A9A8-5C9E7D90A1CA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-0:*:*:*:*:*:*:*", "matchCriteriaId": "BB9B68E7-0E40-437A-A71B-0C078FE76FD8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-1:*:*:*:*:*:*:*", "matchCriteriaId": "948D5778-AD2A-4293-AE39-A406D75F5678"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-2:*:*:*:*:*:*:*", "matchCriteriaId": "D391DECE-2408-4A8F-ACE6-F18028C422A3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-3:*:*:*:*:*:*:*", "matchCriteriaId": "CC773CB4-0E7B-4D73-AB9C-D7CC98C38BD7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-4:*:*:*:*:*:*:*", "matchCriteriaId": "24A0C584-9DA3-48B0-B152-67B9E0239876"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-5:*:*:*:*:*:*:*", "matchCriteriaId": "E42943C5-CC66-4E88-9085-1BD39937C09B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-6:*:*:*:*:*:*:*", "matchCriteriaId": "E396985D-BE6A-4F4C-B294-FE69724534EF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-7:*:*:*:*:*:*:*", "matchCriteriaId": "D1D84944-322C-4B5D-9B1C-587301747A34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-8:*:*:*:*:*:*:*", "matchCriteriaId": "B48F5327-CA20-4756-A06F-B30B660E8DA7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-9:*:*:*:*:*:*:*", "matchCriteriaId": "84C11EC2-C798-4C3B-8E00-9C70C3499B33"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-10:*:*:*:*:*:*:*", "matchCriteriaId": "D30A3BD6-5903-42D6-A1E3-C6D2FE468A1E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-0:*:*:*:*:*:*:*", "matchCriteriaId": "441F9FAE-11FA-4976-8BB3-4A3A79B57663"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-1:*:*:*:*:*:*:*", "matchCriteriaId": "F4389D4A-8AD4-421E-AD4D-6761F45B7F6B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-2:*:*:*:*:*:*:*", "matchCriteriaId": "1620AF57-49AF-4487-80A1-07627F50F817"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-3:*:*:*:*:*:*:*", "matchCriteriaId": "DF373D13-0AB1-4518-AFFE-D09A5F56E992"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-4:*:*:*:*:*:*:*", "matchCriteriaId": "86483865-BFC3-4845-80DE-A6AC632A92A2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-5:*:*:*:*:*:*:*", "matchCriteriaId": "2A147E12-E5D4-400E-9432-BB5BCF2352CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-6:*:*:*:*:*:*:*", "matchCriteriaId": "B1F2BF9D-9821-424E-8F06-BFB637C103A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-7:*:*:*:*:*:*:*", "matchCriteriaId": "26D7231D-442B-4E7C-BCB2-EE8D787FD46D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-8:*:*:*:*:*:*:*", "matchCriteriaId": "749B8733-47B0-4F63-874D-62DF323CD045"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-9:*:*:*:*:*:*:*", "matchCriteriaId": "AD9D1C91-B67A-430B-AB24-DCC7DAF69D7C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-10:*:*:*:*:*:*:*", "matchCriteriaId": "0C5BE761-44E8-4614-BBD4-3FA7148156B0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-0:*:*:*:*:*:*:*", "matchCriteriaId": "79AA4723-3637-4FA7-AE60-9CEE7C535A13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-1:*:*:*:*:*:*:*", "matchCriteriaId": "2D1F577A-316C-4ECE-91CB-4C15F12CC63B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-4:*:*:*:*:*:*:*", "matchCriteriaId": "68F19A0F-29E9-40A5-B6BB-23C20343CDBE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-5:*:*:*:*:*:*:*", "matchCriteriaId": "72A65A02-CD63-4DDD-AFCC-FE6988F85E13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-6:*:*:*:*:*:*:*", "matchCriteriaId": "25690796-E494-4D28-BB4F-AAF40D596AC7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-7:*:*:*:*:*:*:*", "matchCriteriaId": "A2C0242E-0292-4DF7-A3FC-BE96DA95E7D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-8:*:*:*:*:*:*:*", "matchCriteriaId": "9F853E8E-1ED2-4BDA-BE60-BBE1F658695B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.6-1:*:*:*:*:*:*:*", "matchCriteriaId": "72A6252A-35A7-4D74-AF0E-0A7B4B12B146"}]}]}], "references": [{"url": "https://bugs.debian.org/869209", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/816ecab6c532ae086ff4186b3eaf4aa7092d536f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/586", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/816ecab6c532ae086ff4186b3eaf4aa7092d536f"}}