{"buggy_code": ["\"\"\"Domain related views.\"\"\"\n\nfrom functools import reduce\n\nfrom reversion import revisions as reversion\n\nfrom django.contrib.auth import mixins as auth_mixins\nfrom django.contrib.auth.decorators import (\n    login_required, permission_required, user_passes_test\n)\nfrom django.db.models import Q, Sum\nfrom django.http import HttpResponseRedirect\nfrom django.shortcuts import render\nfrom django.template.loader import render_to_string\nfrom django.urls import reverse\nfrom django.utils.translation import ugettext as _, ungettext\nfrom django.views import generic\nfrom django.views.decorators.csrf import ensure_csrf_cookie\nfrom django.views.decorators.http import require_http_methods\n\nfrom modoboa.core import signals as core_signals\nfrom modoboa.lib.exceptions import PermDeniedException\nfrom modoboa.lib.listing import get_listing_page, get_sort_order\nfrom modoboa.lib.web_utils import render_to_json_response\nfrom modoboa.maillog import models as ml_models\n\nfrom .. import signals\nfrom ..forms import DomainForm, DomainWizard\nfrom ..lib import get_domains\nfrom ..models import Domain, Mailbox\n\n\n@login_required\ndef index(request):\n    return HttpResponseRedirect(reverse(\"admin:domain_list\"))\n\n\n@login_required\n@user_passes_test(\n    lambda u: u.has_perm(\"admin.view_domain\") or\n    u.has_perm(\"admin.view_mailbox\")\n)\ndef _domains(request):\n    sort_order, sort_dir = get_sort_order(request.GET, \"name\")\n    extra_filters = signals.extra_domain_filters.send(sender=\"_domains\")\n    if extra_filters:\n        extra_filters = reduce(\n            lambda a, b: a + b, [result[1] for result in extra_filters])\n    filters = {\n        flt: request.GET.get(flt, None)\n        for flt in [\"domfilter\", \"searchquery\"] + extra_filters\n    }\n    request.session[\"domains_filters\"] = filters\n    domainlist = get_domains(request.user, **filters)\n    if sort_order == \"name\":\n        domainlist = sorted(\n            domainlist,\n            key=lambda d: getattr(d, sort_order), reverse=sort_dir == \"-\"\n        )\n    else:\n        domainlist = sorted(domainlist, key=lambda d: d.tags[0][\"name\"],\n                            reverse=sort_dir == \"-\")\n    context = {\n        \"handle_mailboxes\": request.localconfig.parameters.get_value(\n            \"handle_mailboxes\", raise_exception=False),\n        \"auto_account_removal\": request.localconfig.parameters.get_value(\n            \"auto_account_removal\"),\n    }\n    page = get_listing_page(domainlist, request.GET.get(\"page\", 1))\n    parameters = request.localconfig.parameters\n    dns_checks = {\n        \"enable_mx_checks\": parameters.get_value(\"enable_mx_checks\"),\n        \"enable_spf_checks\": parameters.get_value(\"enable_spf_checks\"),\n        \"enable_dkim_checks\": parameters.get_value(\"enable_dkim_checks\"),\n        \"enable_dmarc_checks\": parameters.get_value(\"enable_dmarc_checks\"),\n        \"enable_autoconfig_checks\": (\n            parameters.get_value(\"enable_autoconfig_checks\")),\n        \"enable_dnsbl_checks\": parameters.get_value(\"enable_dnsbl_checks\")\n    }\n    context[\"headers\"] = render_to_string(\n        \"admin/domain_headers.html\", dns_checks, request\n    )\n    if page is None:\n        context[\"length\"] = 0\n    else:\n        tpl_context = {\"domains\": page.object_list}\n        tpl_context.update(dns_checks)\n        context[\"rows\"] = render_to_string(\n            \"admin/domains_table.html\", tpl_context, request\n        )\n        context[\"pages\"] = [page.number]\n    return render_to_json_response(context)\n\n\n@login_required\n@ensure_csrf_cookie\ndef domains(request, tplname=\"admin/domains.html\"):\n    if not request.user.has_perm(\"admin.view_domain\"):\n        if request.user.has_perm(\"admin.view_mailbox\"):\n            return HttpResponseRedirect(\n                reverse(\"admin:identity_list\")\n            )\n        return HttpResponseRedirect(reverse(\"core:user_index\"))\n    parameters = request.localconfig.parameters\n    return render(request, tplname, {\n        \"selection\": \"domains\",\n        \"enable_mx_checks\": parameters.get_value(\"enable_mx_checks\"),\n        \"enable_spf_checks\": parameters.get_value(\"enable_spf_checks\"),\n        \"enable_dkim_checks\": parameters.get_value(\"enable_dkim_checks\"),\n        \"enable_dmarc_checks\": parameters.get_value(\"enable_dmarc_checks\"),\n        \"enable_autoconfig_checks\": (\n            parameters.get_value(\"enable_autoconfig_checks\")),\n        \"enable_dnsbl_checks\": parameters.get_value(\"enable_dnsbl_checks\")\n    })\n\n\n@login_required\n@user_passes_test(\n    lambda u: u.has_perm(\"admin.view_domain\") or\n    u.has_perm(\"admin.view_mailbox\") or\n    u.has_perm(\"admin.add_domain\")\n)\ndef get_next_page(request):\n    \"\"\"Return the next page of the domain or quota list.\"\"\"\n    objtype = request.GET.get(\"objtype\", \"domain\")\n    if objtype == \"domain\":\n        return _domains(request)\n    if objtype == \"quota\":\n        return list_quotas(request)\n    return list_logs(request)\n\n\n@login_required\n@permission_required(\"core.add_user\")\ndef domains_list(request):\n    doms = [dom.name for dom in Domain.objects.get_for_admin(request.user)]\n    return render_to_json_response(doms)\n\n\n@login_required\n@permission_required(\"admin.view_domain\")\ndef list_quotas(request):\n    sort_order, sort_dir = get_sort_order(request.GET, \"name\")\n    domains = Domain.objects.get_for_admin(request.user)\n    domains = domains.exclude(quota=0)\n    if sort_order in [\"name\", \"quota\"]:\n        domains = domains.order_by(\"{}{}\".format(sort_dir, sort_order))\n    elif sort_order == \"allocated_quota\":\n        domains = (\n            domains.annotate(allocated_quota=Sum(\"mailbox__quota\"))\n            .order_by(\"{}{}\".format(sort_dir, sort_order))\n        )\n    page = get_listing_page(domains, request.GET.get(\"page\", 1))\n    context = {\n        \"headers\": render_to_string(\n            \"admin/domains_quota_headers.html\", {}, request\n        )\n    }\n    if page is None:\n        context[\"length\"] = 0\n    else:\n        context[\"rows\"] = render_to_string(\n            \"admin/domains_quotas.html\", {\"domains\": page}, request\n        )\n        context[\"pages\"] = [page.number]\n    return render_to_json_response(context)\n\n\n@login_required\n@permission_required(\"admin.view_domain\")\ndef list_logs(request):\n    \"\"\"List all Maillog entries.\"\"\"\n    sort_order, sort_dir = get_sort_order(request.GET, \"date\")\n    search = request.GET.get(\"searchquery\")\n    if not request.user.is_superuser:\n        domains = Domain.objects.get_for_admin(request.user)\n        logs = ml_models.Maillog.objects.filter(\n            Q(from_domain__in=domains) | Q(to_domain__in=domains)\n        )\n    else:\n        logs = ml_models.Maillog.objects.all()\n    logs = logs.order_by(\"{}{}\".format(sort_dir, sort_order))\n    if search:\n        logs = logs.filter(\n            Q(sender__icontains=search) |\n            Q(rcpt__icontains=search) |\n            Q(queue_id__icontains=search) |\n            Q(status__icontains=search)\n        )\n    page = get_listing_page(logs, request.GET.get(\"page\", 1))\n    context = {\n        \"headers\": render_to_string(\n            \"admin/domains_log_headers.html\", {}, request\n        )\n    }\n    if page is None:\n        context[\"length\"] = 0\n    else:\n        context[\"rows\"] = render_to_string(\n            \"admin/domains_logs.html\", {\"logs\": page}, request\n        )\n        context[\"pages\"] = [page.number]\n    return render_to_json_response(context)\n\n\n@login_required\n@permission_required(\"admin.add_domain\")\n@reversion.create_revision()\ndef newdomain(request):\n    core_signals.can_create_object.send(\n        \"newdomain\", context=request.user, klass=Domain)\n    return DomainWizard(request).process()\n\n\n@login_required\n@permission_required(\"admin.view_domain\")\n@reversion.create_revision()\ndef editdomain(request, dom_id):\n    \"\"\"Edit domain view.\"\"\"\n    domain = Domain.objects.get(pk=dom_id)\n    if not request.user.can_access(domain):\n        raise PermDeniedException\n\n    instances = {\"general\": domain}\n    results = signals.get_domain_form_instances.send(\n        sender=\"editdomain\", user=request.user, domain=domain)\n    for result in results:\n        instances.update(result[1])\n    return DomainForm(request, instances=instances).process()\n\n\n@login_required\n@permission_required(\"admin.delete_domain\")\n@require_http_methods([\"POST\"])\ndef deldomain(request, dom_id):\n    keepdir = request.POST.get(\"keepdir\", \"false\") == \"true\"\n    try:\n        mb = Mailbox.objects.get(user__id=request.user.id)\n    except Mailbox.DoesNotExist:\n        mb = None\n\n    dom = Domain.objects.get(pk=dom_id)\n    if not request.user.can_access(dom):\n        raise PermDeniedException\n    if mb and mb.domain == dom:\n        raise PermDeniedException(_(\"You can't delete your own domain\"))\n    dom.delete(request.user, keepdir)\n\n    msg = ungettext(\"Domain deleted\", \"Domains deleted\", 1)\n    return render_to_json_response(msg)\n\n\nclass DomainDetailView(\n        auth_mixins.PermissionRequiredMixin, generic.DetailView):\n    \"\"\"DetailView for Domain.\"\"\"\n\n    model = Domain\n    permission_required = \"admin.view_domain\"\n\n    def get_queryset(self):\n        \"\"\"Add some prefetching.\"\"\"\n        return (\n            Domain.objects.get_for_admin(self.request.user)\n            .prefetch_related(\"domainalias_set\", \"mailbox_set\", \"alias_set\")\n        )\n\n    def get_context_data(self, **kwargs):\n        \"\"\"Include extra widgets.\"\"\"\n        context = super(DomainDetailView, self).get_context_data(**kwargs)\n        result = signals.extra_domain_dashboard_widgets.send(\n            self.__class__, user=self.request.user, domain=self.object)\n        parameters = self.request.localconfig.parameters\n        context.update({\n            \"templates\": {\"left\": [], \"right\": []},\n            \"enable_mx_checks\": parameters.get_value(\"enable_mx_checks\"),\n            \"enable_spf_checks\": parameters.get_value(\"enable_spf_checks\"),\n            \"enable_dkim_checks\": parameters.get_value(\"enable_dkim_checks\"),\n            \"enable_dmarc_checks\": parameters.get_value(\"enable_dmarc_checks\"),\n            \"enable_autoconfig_checks\": (\n                parameters.get_value(\"enable_autoconfig_checks\")),\n            \"enable_dnsbl_checks\": parameters.get_value(\"enable_dnsbl_checks\"),\n        })\n        for _receiver, widgets in result:\n            for widget in widgets:\n                context[\"templates\"][widget[\"column\"]].append(\n                    widget[\"template\"])\n                # FIXME: can raise conflicts...\n                context.update(widget[\"context\"])\n\n        return context\n\n\nclass DomainAlarmsView(\n        auth_mixins.PermissionRequiredMixin, generic.DetailView):\n    \"\"\"A view to list domain alarms.\"\"\"\n\n    model = Domain\n    permission_required = \"admin.view_domain\"\n    template_name = \"admin/domain_alarms.html\"\n\n    def get_queryset(self):\n        \"\"\"Add some prefetching.\"\"\"\n        return (\n            Domain.objects.get_for_admin(self.request.user)\n            .prefetch_related(\"alarms\")\n        )\n", "\"\"\"Identity related views.\"\"\"\n\nfrom reversion import revisions as reversion\n\nfrom django.contrib.auth import mixins as auth_mixins\nfrom django.contrib.auth.decorators import (\n    login_required, permission_required, user_passes_test\n)\nfrom django.shortcuts import render\nfrom django.template.loader import render_to_string\nfrom django.utils.translation import ugettext as _, ungettext\nfrom django.views import generic\nfrom django.views.decorators.csrf import ensure_csrf_cookie\nfrom django.views.decorators.http import require_http_methods\n\nfrom modoboa.core.models import User\nfrom modoboa.lib.exceptions import BadRequest, PermDeniedException\nfrom modoboa.lib.listing import get_listing_page, get_sort_order\nfrom modoboa.lib.web_utils import render_to_json_response\nfrom .. import signals\nfrom ..forms import AccountForm, AccountWizard\nfrom ..lib import get_identities\nfrom ..models import Domain, Mailbox\n\n\n@login_required\n@user_passes_test(\n    lambda u: u.has_perm(\"core.add_user\") or\n    u.has_perm(\"admin.add_alias\")\n)\ndef _identities(request):\n    filters = {\n        fname: request.GET.get(fname, None)\n        for fname in [\"searchquery\", \"idtfilter\", \"grpfilter\"]\n    }\n    request.session[\"identities_filters\"] = filters\n    idents_list = get_identities(request.user, **filters)\n    sort_order, sort_dir = get_sort_order(request.GET, \"identity\",\n                                          [\"identity\", \"name_or_rcpt\", \"tags\"])\n    if sort_order in [\"identity\", \"name_or_rcpt\"]:\n        objects = sorted(idents_list, key=lambda o: getattr(o, sort_order),\n                         reverse=sort_dir == \"-\")\n    else:\n        objects = sorted(idents_list, key=lambda o: o.tags[0][\"label\"],\n                         reverse=sort_dir == \"-\")\n    context = {\n        \"handle_mailboxes\": request.localconfig.parameters.get_value(\n            \"handle_mailboxes\", raise_exception=False)\n    }\n    page = get_listing_page(objects, request.GET.get(\"page\", 1))\n    context[\"headers\"] = render_to_string(\n        \"admin/identity_headers.html\", {}, request)\n    if page is None:\n        context[\"length\"] = 0\n    else:\n        context[\"rows\"] = render_to_string(\n            \"admin/identities_table.html\", {\n                \"identities\": page.object_list\n            }, request\n        )\n        context[\"pages\"] = [page.number]\n    return render_to_json_response(context)\n\n\n@login_required\n@permission_required(\"admin.add_mailbox\")\ndef list_quotas(request):\n    from modoboa.lib.db_utils import db_type\n\n    sort_order, sort_dir = get_sort_order(request.GET, \"address\")\n    mboxes = Mailbox.objects.get_for_admin(\n        request.user, request.GET.get(\"searchquery\", None)\n    )\n    mboxes = mboxes.exclude(quota=0)\n    if sort_order in [\"address\", \"quota\"]:\n        mboxes = mboxes.order_by(\"%s%s\" % (sort_dir, sort_order))\n    elif sort_order in (\"quota_value__bytes\", \"quota_usage\"):\n        db_type = db_type()\n        if db_type == \"mysql\":\n            where = \"CONCAT(admin_mailbox.address,'@',admin_domain.name)\"\n        else:\n            where = \"admin_mailbox.address||'@'||admin_domain.name\"\n        if sort_order == \"quota_value__bytes\":\n            mboxes = mboxes.extra(\n                select={\"quota_value__bytes\": \"admin_quota.bytes\"},\n                where=[\"admin_quota.username=%s\" % where],\n                tables=[\"admin_quota\", \"admin_domain\"],\n                order_by=[\"%s%s\" % (sort_dir, sort_order)]\n            )\n        else:\n            if db_type == \"postgres\":\n                select = (\n                    \"(admin_quota.bytes::float / (CAST(admin_mailbox.quota \"\n                    \"AS BIGINT) * 1048576)) * 100\"\n                )\n            else:\n                select = (\n                    \"(admin_quota.bytes * 1.0 / (admin_mailbox.quota \"\n                    \"* 1048576)) * 100\"\n                )\n            mboxes = mboxes.extra(\n                select={\"quota_usage\": select},\n                where=[\"admin_quota.username=%s\" % where],\n                tables=[\"admin_quota\", \"admin_domain\"],\n                order_by=[\"%s%s\" % (sort_dir, sort_order)]\n            )\n    else:\n        raise BadRequest(_(\"Invalid request\"))\n    page = get_listing_page(mboxes, request.GET.get(\"page\", 1))\n    context = {\n        \"headers\": render_to_string(\n            \"admin/identities_quota_headers.html\", {}, request\n        )\n    }\n    if page is None:\n        context[\"length\"] = 0\n    else:\n        context[\"rows\"] = render_to_string(\n            \"admin/identities_quotas.html\", {\"mboxes\": page}, request\n        )\n        context[\"pages\"] = [page.number]\n    return render_to_json_response(context)\n\n\n@login_required\n@user_passes_test(\n    lambda u: u.has_perm(\"core.add_user\") or\n    u.has_perm(\"admin.add_alias\") or\n    u.has_perm(\"admin.add_mailbox\")\n)\ndef get_next_page(request):\n    \"\"\"Return the next page of the identity list.\"\"\"\n    if request.GET.get(\"objtype\", \"identity\") == \"identity\":\n        return _identities(request)\n    return list_quotas(request)\n\n\n@login_required\n@user_passes_test(\n    lambda u: u.has_perm(\"core.add_user\") or\n    u.has_perm(\"admin.add_alias\")\n)\n@ensure_csrf_cookie\ndef identities(request, tplname=\"admin/identities.html\"):\n    return render(request, tplname, {\n        \"selection\": \"identities\",\n        \"deflocation\": \"list/\"\n    })\n\n\n@login_required\n@permission_required(\"core.add_user\")\ndef accounts_list(request):\n    accs = User.objects.filter(is_superuser=False) \\\n        .exclude(groups__name=\"SimpleUsers\")\n    res = [a.username for a in accs.all()]\n    return render_to_json_response(res)\n\n\n@login_required\n@permission_required(\"core.add_user\")\n@reversion.create_revision()\ndef newaccount(request):\n    \"\"\"Create a new account.\"\"\"\n    return AccountWizard(request).process()\n\n\n@login_required\n@permission_required(\"core.change_user\")\n@reversion.create_revision()\ndef editaccount(request, pk):\n    account = User.objects.get(pk=pk)\n    if not request.user.can_access(account):\n        raise PermDeniedException\n    mb = account.mailbox if hasattr(account, \"mailbox\") else None\n\n    instances = {\n        \"general\": account, \"profile\": account, \"mail\": mb, \"perms\": account\n    }\n    results = signals.get_account_form_instances.send(\n        sender=\"editaccount\", user=request.user, account=account)\n    for result in results:\n        instances.update(result[1])\n    return AccountForm(request, instances=instances).process()\n\n\n@login_required\n@permission_required(\"core.delete_user\")\n@require_http_methods([\"POST\"])\ndef delaccount(request, pk):\n    User.objects.get(pk=pk).delete()\n    return render_to_json_response(\n        ungettext(\"Account deleted\", \"Accounts deleted\", 1)\n    )\n\n\n@login_required\n@permission_required(\"admin.add_domain\")\n@require_http_methods([\"DELETE\"])\ndef remove_permission(request):\n    domid = request.GET.get(\"domid\", None)\n    daid = request.GET.get(\"daid\", None)\n    if domid is None or daid is None:\n        raise BadRequest(_(\"Invalid request\"))\n    try:\n        account = User.objects.get(pk=daid)\n        domain = Domain.objects.get(pk=domid)\n    except (User.DoesNotExist, Domain.DoesNotExist):\n        raise BadRequest(_(\"Invalid request\"))\n    if not request.user.can_access(account) or \\\n       not request.user.can_access(domain):\n        raise PermDeniedException\n    domain.remove_admin(account)\n    return render_to_json_response({})\n\n\nclass AccountDetailView(\n        auth_mixins.PermissionRequiredMixin, generic.DetailView):\n    \"\"\"DetailView for Account.\"\"\"\n\n    model = User\n    permission_required = \"core.add_user\"\n    template_name = \"admin/account_detail.html\"\n\n    def has_permission(self):\n        \"\"\"Check object-level access.\"\"\"\n        result = super(AccountDetailView, self).has_permission()\n        if not result:\n            return result\n        return self.request.user.can_access(self.get_object())\n\n    def get_context_data(self, **kwargs):\n        \"\"\"Add information to context.\"\"\"\n        context = super(AccountDetailView, self).get_context_data(**kwargs)\n        del context[\"user\"]\n        result = signals.extra_account_dashboard_widgets.send(\n            self.__class__, user=self.request.user, account=self.object)\n        context[\"templates\"] = {\"left\": [], \"right\": []}\n        for _receiver, widgets in result:\n            for widget in widgets:\n                context[\"templates\"][widget[\"column\"]].append(\n                    widget[\"template\"])\n                context.update(widget[\"context\"])\n        if self.object.role in [\"Resellers\", \"DomainAdmins\"]:\n            context[\"domains\"] = Domain.objects.get_for_admin(self.object)\n        context[\"selection\"] = \"identities\"\n        return context\n"], "fixing_code": ["\"\"\"Domain related views.\"\"\"\n\nfrom functools import reduce\n\nfrom reversion import revisions as reversion\n\nfrom django.contrib.auth import mixins as auth_mixins\nfrom django.contrib.auth.decorators import (\n    login_required, permission_required, user_passes_test\n)\nfrom django.db.models import Q, Sum\nfrom django.http import HttpResponseRedirect\nfrom django.shortcuts import render\nfrom django.template.loader import render_to_string\nfrom django.urls import reverse\nfrom django.utils.translation import ugettext as _, ungettext\nfrom django.views import generic\nfrom django.views.decorators.csrf import ensure_csrf_cookie\nfrom django.views.decorators.http import require_http_methods\n\nfrom modoboa.core import signals as core_signals\nfrom modoboa.lib.exceptions import PermDeniedException\nfrom modoboa.lib.listing import get_listing_page, get_sort_order\nfrom modoboa.lib.web_utils import render_to_json_response\nfrom modoboa.maillog import models as ml_models\n\nfrom .. import signals\nfrom ..forms import DomainForm, DomainWizard\nfrom ..lib import get_domains\nfrom ..models import Domain, Mailbox\n\n\n@login_required\ndef index(request):\n    return HttpResponseRedirect(reverse(\"admin:domain_list\"))\n\n\n@login_required\n@user_passes_test(\n    lambda u: u.has_perm(\"admin.view_domain\") or\n    u.has_perm(\"admin.view_mailbox\")\n)\ndef _domains(request):\n    sort_order, sort_dir = get_sort_order(request.GET, \"name\")\n    extra_filters = signals.extra_domain_filters.send(sender=\"_domains\")\n    if extra_filters:\n        extra_filters = reduce(\n            lambda a, b: a + b, [result[1] for result in extra_filters])\n    filters = {\n        flt: request.GET.get(flt, None)\n        for flt in [\"domfilter\", \"searchquery\"] + extra_filters\n    }\n    request.session[\"domains_filters\"] = filters\n    domainlist = get_domains(request.user, **filters)\n    if sort_order == \"name\":\n        domainlist = sorted(\n            domainlist,\n            key=lambda d: getattr(d, sort_order), reverse=sort_dir == \"-\"\n        )\n    else:\n        domainlist = sorted(domainlist, key=lambda d: d.tags[0][\"name\"],\n                            reverse=sort_dir == \"-\")\n    context = {\n        \"handle_mailboxes\": request.localconfig.parameters.get_value(\n            \"handle_mailboxes\", raise_exception=False),\n        \"auto_account_removal\": request.localconfig.parameters.get_value(\n            \"auto_account_removal\"),\n    }\n    page = get_listing_page(domainlist, request.GET.get(\"page\", 1))\n    parameters = request.localconfig.parameters\n    dns_checks = {\n        \"enable_mx_checks\": parameters.get_value(\"enable_mx_checks\"),\n        \"enable_spf_checks\": parameters.get_value(\"enable_spf_checks\"),\n        \"enable_dkim_checks\": parameters.get_value(\"enable_dkim_checks\"),\n        \"enable_dmarc_checks\": parameters.get_value(\"enable_dmarc_checks\"),\n        \"enable_autoconfig_checks\": (\n            parameters.get_value(\"enable_autoconfig_checks\")),\n        \"enable_dnsbl_checks\": parameters.get_value(\"enable_dnsbl_checks\")\n    }\n    context[\"headers\"] = render_to_string(\n        \"admin/domain_headers.html\", dns_checks, request\n    )\n    if page is None:\n        context[\"length\"] = 0\n    else:\n        tpl_context = {\"domains\": page.object_list}\n        tpl_context.update(dns_checks)\n        context[\"rows\"] = render_to_string(\n            \"admin/domains_table.html\", tpl_context, request\n        )\n        context[\"pages\"] = [page.number]\n    return render_to_json_response(context)\n\n\n@login_required\n@ensure_csrf_cookie\ndef domains(request, tplname=\"admin/domains.html\"):\n    if not request.user.has_perm(\"admin.view_domain\"):\n        if request.user.has_perm(\"admin.view_mailbox\"):\n            return HttpResponseRedirect(\n                reverse(\"admin:identity_list\")\n            )\n        return HttpResponseRedirect(reverse(\"core:user_index\"))\n    parameters = request.localconfig.parameters\n    return render(request, tplname, {\n        \"selection\": \"domains\",\n        \"enable_mx_checks\": parameters.get_value(\"enable_mx_checks\"),\n        \"enable_spf_checks\": parameters.get_value(\"enable_spf_checks\"),\n        \"enable_dkim_checks\": parameters.get_value(\"enable_dkim_checks\"),\n        \"enable_dmarc_checks\": parameters.get_value(\"enable_dmarc_checks\"),\n        \"enable_autoconfig_checks\": (\n            parameters.get_value(\"enable_autoconfig_checks\")),\n        \"enable_dnsbl_checks\": parameters.get_value(\"enable_dnsbl_checks\")\n    })\n\n\n@login_required\n@user_passes_test(\n    lambda u: u.has_perm(\"admin.view_domain\") or\n    u.has_perm(\"admin.view_mailbox\") or\n    u.has_perm(\"admin.add_domain\")\n)\ndef get_next_page(request):\n    \"\"\"Return the next page of the domain or quota list.\"\"\"\n    objtype = request.GET.get(\"objtype\", \"domain\")\n    if objtype == \"domain\":\n        return _domains(request)\n    if objtype == \"quota\":\n        return list_quotas(request)\n    return list_logs(request)\n\n\n@login_required\n@permission_required(\"core.add_user\")\ndef domains_list(request):\n    doms = [dom.name for dom in Domain.objects.get_for_admin(request.user)]\n    return render_to_json_response(doms)\n\n\n@login_required\n@permission_required(\"admin.view_domain\")\ndef list_quotas(request):\n    sort_order, sort_dir = get_sort_order(request.GET, \"name\")\n    domains = Domain.objects.get_for_admin(request.user)\n    domains = domains.exclude(quota=0)\n    if sort_order in [\"name\", \"quota\"]:\n        domains = domains.order_by(\"{}{}\".format(sort_dir, sort_order))\n    elif sort_order == \"allocated_quota\":\n        domains = (\n            domains.annotate(allocated_quota=Sum(\"mailbox__quota\"))\n            .order_by(\"{}{}\".format(sort_dir, sort_order))\n        )\n    page = get_listing_page(domains, request.GET.get(\"page\", 1))\n    context = {\n        \"headers\": render_to_string(\n            \"admin/domains_quota_headers.html\", {}, request\n        )\n    }\n    if page is None:\n        context[\"length\"] = 0\n    else:\n        context[\"rows\"] = render_to_string(\n            \"admin/domains_quotas.html\", {\"domains\": page}, request\n        )\n        context[\"pages\"] = [page.number]\n    return render_to_json_response(context)\n\n\n@login_required\n@permission_required(\"admin.view_domain\")\ndef list_logs(request):\n    \"\"\"List all Maillog entries.\"\"\"\n    sort_order, sort_dir = get_sort_order(request.GET, \"date\")\n    search = request.GET.get(\"searchquery\")\n    if not request.user.is_superuser:\n        domains = Domain.objects.get_for_admin(request.user)\n        logs = ml_models.Maillog.objects.filter(\n            Q(from_domain__in=domains) | Q(to_domain__in=domains)\n        )\n    else:\n        logs = ml_models.Maillog.objects.all()\n    logs = logs.order_by(\"{}{}\".format(sort_dir, sort_order))\n    if search:\n        logs = logs.filter(\n            Q(sender__icontains=search) |\n            Q(rcpt__icontains=search) |\n            Q(queue_id__icontains=search) |\n            Q(status__icontains=search)\n        )\n    page = get_listing_page(logs, request.GET.get(\"page\", 1))\n    context = {\n        \"headers\": render_to_string(\n            \"admin/domains_log_headers.html\", {}, request\n        )\n    }\n    if page is None:\n        context[\"length\"] = 0\n    else:\n        context[\"rows\"] = render_to_string(\n            \"admin/domains_logs.html\", {\"logs\": page}, request\n        )\n        context[\"pages\"] = [page.number]\n    return render_to_json_response(context)\n\n\n@login_required\n@permission_required(\"admin.add_domain\")\n@reversion.create_revision()\ndef newdomain(request):\n    core_signals.can_create_object.send(\n        \"newdomain\", context=request.user, klass=Domain)\n    return DomainWizard(request).process()\n\n\n@login_required\n@permission_required(\"admin.view_domain\")\n@require_http_methods([\"POST\"])\n@reversion.create_revision()\ndef editdomain(request, dom_id):\n    \"\"\"Edit domain view.\"\"\"\n    domain = Domain.objects.get(pk=dom_id)\n    if not request.user.can_access(domain):\n        raise PermDeniedException\n\n    instances = {\"general\": domain}\n    results = signals.get_domain_form_instances.send(\n        sender=\"editdomain\", user=request.user, domain=domain)\n    for result in results:\n        instances.update(result[1])\n    return DomainForm(request, instances=instances).process()\n\n\n@login_required\n@permission_required(\"admin.delete_domain\")\n@require_http_methods([\"POST\"])\ndef deldomain(request, dom_id):\n    keepdir = request.POST.get(\"keepdir\", \"false\") == \"true\"\n    try:\n        mb = Mailbox.objects.get(user__id=request.user.id)\n    except Mailbox.DoesNotExist:\n        mb = None\n\n    dom = Domain.objects.get(pk=dom_id)\n    if not request.user.can_access(dom):\n        raise PermDeniedException\n    if mb and mb.domain == dom:\n        raise PermDeniedException(_(\"You can't delete your own domain\"))\n    dom.delete(request.user, keepdir)\n\n    msg = ungettext(\"Domain deleted\", \"Domains deleted\", 1)\n    return render_to_json_response(msg)\n\n\nclass DomainDetailView(\n        auth_mixins.PermissionRequiredMixin, generic.DetailView):\n    \"\"\"DetailView for Domain.\"\"\"\n\n    model = Domain\n    permission_required = \"admin.view_domain\"\n\n    def get_queryset(self):\n        \"\"\"Add some prefetching.\"\"\"\n        return (\n            Domain.objects.get_for_admin(self.request.user)\n            .prefetch_related(\"domainalias_set\", \"mailbox_set\", \"alias_set\")\n        )\n\n    def get_context_data(self, **kwargs):\n        \"\"\"Include extra widgets.\"\"\"\n        context = super(DomainDetailView, self).get_context_data(**kwargs)\n        result = signals.extra_domain_dashboard_widgets.send(\n            self.__class__, user=self.request.user, domain=self.object)\n        parameters = self.request.localconfig.parameters\n        context.update({\n            \"templates\": {\"left\": [], \"right\": []},\n            \"enable_mx_checks\": parameters.get_value(\"enable_mx_checks\"),\n            \"enable_spf_checks\": parameters.get_value(\"enable_spf_checks\"),\n            \"enable_dkim_checks\": parameters.get_value(\"enable_dkim_checks\"),\n            \"enable_dmarc_checks\": parameters.get_value(\"enable_dmarc_checks\"),\n            \"enable_autoconfig_checks\": (\n                parameters.get_value(\"enable_autoconfig_checks\")),\n            \"enable_dnsbl_checks\": parameters.get_value(\"enable_dnsbl_checks\"),\n        })\n        for _receiver, widgets in result:\n            for widget in widgets:\n                context[\"templates\"][widget[\"column\"]].append(\n                    widget[\"template\"])\n                # FIXME: can raise conflicts...\n                context.update(widget[\"context\"])\n\n        return context\n\n\nclass DomainAlarmsView(\n        auth_mixins.PermissionRequiredMixin, generic.DetailView):\n    \"\"\"A view to list domain alarms.\"\"\"\n\n    model = Domain\n    permission_required = \"admin.view_domain\"\n    template_name = \"admin/domain_alarms.html\"\n\n    def get_queryset(self):\n        \"\"\"Add some prefetching.\"\"\"\n        return (\n            Domain.objects.get_for_admin(self.request.user)\n            .prefetch_related(\"alarms\")\n        )\n", "\"\"\"Identity related views.\"\"\"\n\nfrom reversion import revisions as reversion\n\nfrom django.contrib.auth import mixins as auth_mixins\nfrom django.contrib.auth.decorators import (\n    login_required, permission_required, user_passes_test\n)\nfrom django.shortcuts import render\nfrom django.template.loader import render_to_string\nfrom django.utils.translation import ugettext as _, ungettext\nfrom django.views import generic\nfrom django.views.decorators.csrf import ensure_csrf_cookie\nfrom django.views.decorators.http import require_http_methods\n\nfrom modoboa.core.models import User\nfrom modoboa.lib.exceptions import BadRequest, PermDeniedException\nfrom modoboa.lib.listing import get_listing_page, get_sort_order\nfrom modoboa.lib.web_utils import render_to_json_response\nfrom .. import signals\nfrom ..forms import AccountForm, AccountWizard\nfrom ..lib import get_identities\nfrom ..models import Domain, Mailbox\n\n\n@login_required\n@user_passes_test(\n    lambda u: u.has_perm(\"core.add_user\") or\n    u.has_perm(\"admin.add_alias\")\n)\ndef _identities(request):\n    filters = {\n        fname: request.GET.get(fname, None)\n        for fname in [\"searchquery\", \"idtfilter\", \"grpfilter\"]\n    }\n    request.session[\"identities_filters\"] = filters\n    idents_list = get_identities(request.user, **filters)\n    sort_order, sort_dir = get_sort_order(request.GET, \"identity\",\n                                          [\"identity\", \"name_or_rcpt\", \"tags\"])\n    if sort_order in [\"identity\", \"name_or_rcpt\"]:\n        objects = sorted(idents_list, key=lambda o: getattr(o, sort_order),\n                         reverse=sort_dir == \"-\")\n    else:\n        objects = sorted(idents_list, key=lambda o: o.tags[0][\"label\"],\n                         reverse=sort_dir == \"-\")\n    context = {\n        \"handle_mailboxes\": request.localconfig.parameters.get_value(\n            \"handle_mailboxes\", raise_exception=False)\n    }\n    page = get_listing_page(objects, request.GET.get(\"page\", 1))\n    context[\"headers\"] = render_to_string(\n        \"admin/identity_headers.html\", {}, request)\n    if page is None:\n        context[\"length\"] = 0\n    else:\n        context[\"rows\"] = render_to_string(\n            \"admin/identities_table.html\", {\n                \"identities\": page.object_list\n            }, request\n        )\n        context[\"pages\"] = [page.number]\n    return render_to_json_response(context)\n\n\n@login_required\n@permission_required(\"admin.add_mailbox\")\ndef list_quotas(request):\n    from modoboa.lib.db_utils import db_type\n\n    sort_order, sort_dir = get_sort_order(request.GET, \"address\")\n    mboxes = Mailbox.objects.get_for_admin(\n        request.user, request.GET.get(\"searchquery\", None)\n    )\n    mboxes = mboxes.exclude(quota=0)\n    if sort_order in [\"address\", \"quota\"]:\n        mboxes = mboxes.order_by(\"%s%s\" % (sort_dir, sort_order))\n    elif sort_order in (\"quota_value__bytes\", \"quota_usage\"):\n        db_type = db_type()\n        if db_type == \"mysql\":\n            where = \"CONCAT(admin_mailbox.address,'@',admin_domain.name)\"\n        else:\n            where = \"admin_mailbox.address||'@'||admin_domain.name\"\n        if sort_order == \"quota_value__bytes\":\n            mboxes = mboxes.extra(\n                select={\"quota_value__bytes\": \"admin_quota.bytes\"},\n                where=[\"admin_quota.username=%s\" % where],\n                tables=[\"admin_quota\", \"admin_domain\"],\n                order_by=[\"%s%s\" % (sort_dir, sort_order)]\n            )\n        else:\n            if db_type == \"postgres\":\n                select = (\n                    \"(admin_quota.bytes::float / (CAST(admin_mailbox.quota \"\n                    \"AS BIGINT) * 1048576)) * 100\"\n                )\n            else:\n                select = (\n                    \"(admin_quota.bytes * 1.0 / (admin_mailbox.quota \"\n                    \"* 1048576)) * 100\"\n                )\n            mboxes = mboxes.extra(\n                select={\"quota_usage\": select},\n                where=[\"admin_quota.username=%s\" % where],\n                tables=[\"admin_quota\", \"admin_domain\"],\n                order_by=[\"%s%s\" % (sort_dir, sort_order)]\n            )\n    else:\n        raise BadRequest(_(\"Invalid request\"))\n    page = get_listing_page(mboxes, request.GET.get(\"page\", 1))\n    context = {\n        \"headers\": render_to_string(\n            \"admin/identities_quota_headers.html\", {}, request\n        )\n    }\n    if page is None:\n        context[\"length\"] = 0\n    else:\n        context[\"rows\"] = render_to_string(\n            \"admin/identities_quotas.html\", {\"mboxes\": page}, request\n        )\n        context[\"pages\"] = [page.number]\n    return render_to_json_response(context)\n\n\n@login_required\n@user_passes_test(\n    lambda u: u.has_perm(\"core.add_user\") or\n    u.has_perm(\"admin.add_alias\") or\n    u.has_perm(\"admin.add_mailbox\")\n)\ndef get_next_page(request):\n    \"\"\"Return the next page of the identity list.\"\"\"\n    if request.GET.get(\"objtype\", \"identity\") == \"identity\":\n        return _identities(request)\n    return list_quotas(request)\n\n\n@login_required\n@user_passes_test(\n    lambda u: u.has_perm(\"core.add_user\") or\n    u.has_perm(\"admin.add_alias\")\n)\n@ensure_csrf_cookie\ndef identities(request, tplname=\"admin/identities.html\"):\n    return render(request, tplname, {\n        \"selection\": \"identities\",\n        \"deflocation\": \"list/\"\n    })\n\n\n@login_required\n@permission_required(\"core.add_user\")\ndef accounts_list(request):\n    accs = User.objects.filter(is_superuser=False) \\\n        .exclude(groups__name=\"SimpleUsers\")\n    res = [a.username for a in accs.all()]\n    return render_to_json_response(res)\n\n\n@login_required\n@permission_required(\"core.add_user\")\n@reversion.create_revision()\ndef newaccount(request):\n    \"\"\"Create a new account.\"\"\"\n    return AccountWizard(request).process()\n\n\n@login_required\n@permission_required(\"core.change_user\")\n@require_http_methods([\"POST\"])\n@reversion.create_revision()\ndef editaccount(request, pk):\n    account = User.objects.get(pk=pk)\n    if not request.user.can_access(account):\n        raise PermDeniedException\n    mb = account.mailbox if hasattr(account, \"mailbox\") else None\n\n    instances = {\n        \"general\": account, \"profile\": account, \"mail\": mb, \"perms\": account\n    }\n    results = signals.get_account_form_instances.send(\n        sender=\"editaccount\", user=request.user, account=account)\n    for result in results:\n        instances.update(result[1])\n    return AccountForm(request, instances=instances).process()\n\n\n@login_required\n@permission_required(\"core.delete_user\")\n@require_http_methods([\"POST\"])\ndef delaccount(request, pk):\n    User.objects.get(pk=pk).delete()\n    return render_to_json_response(\n        ungettext(\"Account deleted\", \"Accounts deleted\", 1)\n    )\n\n\n@login_required\n@permission_required(\"admin.add_domain\")\n@require_http_methods([\"DELETE\"])\ndef remove_permission(request):\n    domid = request.GET.get(\"domid\", None)\n    daid = request.GET.get(\"daid\", None)\n    if domid is None or daid is None:\n        raise BadRequest(_(\"Invalid request\"))\n    try:\n        account = User.objects.get(pk=daid)\n        domain = Domain.objects.get(pk=domid)\n    except (User.DoesNotExist, Domain.DoesNotExist):\n        raise BadRequest(_(\"Invalid request\"))\n    if not request.user.can_access(account) or \\\n       not request.user.can_access(domain):\n        raise PermDeniedException\n    domain.remove_admin(account)\n    return render_to_json_response({})\n\n\nclass AccountDetailView(\n        auth_mixins.PermissionRequiredMixin, generic.DetailView):\n    \"\"\"DetailView for Account.\"\"\"\n\n    model = User\n    permission_required = \"core.add_user\"\n    template_name = \"admin/account_detail.html\"\n\n    def has_permission(self):\n        \"\"\"Check object-level access.\"\"\"\n        result = super(AccountDetailView, self).has_permission()\n        if not result:\n            return result\n        return self.request.user.can_access(self.get_object())\n\n    def get_context_data(self, **kwargs):\n        \"\"\"Add information to context.\"\"\"\n        context = super(AccountDetailView, self).get_context_data(**kwargs)\n        del context[\"user\"]\n        result = signals.extra_account_dashboard_widgets.send(\n            self.__class__, user=self.request.user, account=self.object)\n        context[\"templates\"] = {\"left\": [], \"right\": []}\n        for _receiver, widgets in result:\n            for widget in widgets:\n                context[\"templates\"][widget[\"column\"]].append(\n                    widget[\"template\"])\n                context.update(widget[\"context\"])\n        if self.object.role in [\"Resellers\", \"DomainAdmins\"]:\n            context[\"domains\"] = Domain.objects.get_for_admin(self.object)\n        context[\"selection\"] = \"identities\"\n        return context\n"], "filenames": ["modoboa/admin/views/domain.py", "modoboa/admin/views/identity.py"], "buggy_code_start_loc": [216, 169], "buggy_code_end_loc": [216, 169], "fixing_code_start_loc": [217, 170], "fixing_code_end_loc": [218, 171], "type": "CWE-352", "message": "Cross-Site Request Forgery (CSRF) in GitHub repository modoboa/modoboa prior to 2.1.0.", "other": {"cve": {"id": "CVE-2023-2228", "sourceIdentifier": "security@huntr.dev", "published": "2023-04-21T13:15:07.203", "lastModified": "2023-05-03T14:55:49.147", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-Site Request Forgery (CSRF) in GitHub repository modoboa/modoboa prior to 2.1.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:modoboa:modoboa:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.0", "matchCriteriaId": "EDF096DF-1D51-43ED-9F11-D69473204DEE"}]}]}], "references": [{"url": "https://github.com/modoboa/modoboa/commit/5d886f3d06373d2c3292911bac0772bcd5102343", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/619fb490-69ad-4a2a-b686-4c42a62404a9", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/modoboa/modoboa/commit/5d886f3d06373d2c3292911bac0772bcd5102343"}}