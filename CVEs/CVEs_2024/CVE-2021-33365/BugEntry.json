{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n//the only static var. Used to store any error happening while opening a movie\nstatic GF_Err MP4_API_IO_Err;\n\nvoid gf_isom_set_last_error(GF_ISOFile *movie, GF_Err error)\n{\n\tif (!movie) {\n\t\tMP4_API_IO_Err = error;\n\t} else {\n\t\tmovie->LastError = error;\n\t}\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_last_error(GF_ISOFile *the_file)\n{\n\tif (!the_file) return MP4_API_IO_Err;\n\treturn the_file->LastError;\n}\n\nGF_EXPORT\nu8 gf_isom_get_mode(GF_ISOFile *the_file)\n{\n\tif (!the_file) return 0;\n\treturn the_file->openMode;\n}\n\n#if 0 //unused\n/*! gets file size of an ISO file\n\\param isom_file the target ISO file\n\\return the file size in bytes\n*/\nu64 gf_isom_get_file_size(GF_ISOFile *the_file)\n{\n\tif (!the_file) return 0;\n\tif (the_file->movieFileMap) return gf_bs_get_size(the_file->movieFileMap->bs);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (the_file->editFileMap) return gf_bs_get_size(the_file->editFileMap->bs);\n#endif\n\treturn 0;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_freeze_order(GF_ISOFile *file)\n{\n\tu32 i=0;\n\tGF_Box *box;\n\tif (!file) return GF_BAD_PARAM;\n\twhile ((box=gf_list_enum(file->TopBoxes, &i))) {\n\t\tgf_isom_box_freeze_order(box);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_inplace_padding(GF_ISOFile *file, u32 padding)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->padding = padding;\n\treturn GF_OK;\n}\n/**************************************************************\n\t\t\t\t\tSample Manip\n**************************************************************/\n\n//creates a new empty sample\nGF_EXPORT\nGF_ISOSample *gf_isom_sample_new()\n{\n\tGF_ISOSample *tmp;\n\tGF_SAFEALLOC(tmp, GF_ISOSample);\n\treturn tmp;\n}\n\n//delete a sample\nGF_EXPORT\nvoid gf_isom_sample_del(GF_ISOSample **samp)\n{\n\tif (!samp || ! *samp) return;\n\tif ((*samp)->data && (*samp)->dataLength) gf_free((*samp)->data);\n\tgf_free(*samp);\n\t*samp = NULL;\n}\n\nstatic u32 gf_isom_probe_type(u32 type)\n{\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_FTYP:\n\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\treturn 2;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tcase GF_ISOM_BOX_TYPE_MOOF:\n\tcase GF_ISOM_BOX_TYPE_STYP:\n\tcase GF_ISOM_BOX_TYPE_SIDX:\n\tcase GF_ISOM_BOX_TYPE_EMSG:\n\tcase GF_ISOM_BOX_TYPE_PRFT:\n    //we map free as segment when it is first in the file - a regular file shall start with ftyp or a file sig, not free\n    //since our route stack may patch boxes to free for incomplete segments, we must map this to free\n    case GF_ISOM_BOX_TYPE_FREE:\n\t\treturn 3;\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\t/*Adobe specific*/\n\tcase GF_ISOM_BOX_TYPE_AFRA:\n\tcase GF_ISOM_BOX_TYPE_ABST:\n#endif\n#endif\n\tcase GF_ISOM_BOX_TYPE_MDAT:\n\tcase GF_ISOM_BOX_TYPE_SKIP:\n\tcase GF_ISOM_BOX_TYPE_UDTA:\n\tcase GF_ISOM_BOX_TYPE_META:\n\tcase GF_ISOM_BOX_TYPE_VOID:\n\tcase GF_ISOM_BOX_TYPE_JP:\n\tcase GF_QT_BOX_TYPE_WIDE:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nGF_EXPORT\nu32 gf_isom_probe_file_range(const char *fileName, u64 start_range, u64 end_range)\n{\n\tu32 type = 0;\n\n\tif (!strncmp(fileName, \"gmem://\", 7)) {\n\t\tu32 size;\n\t\tu8 *mem_address;\n\t\tif (gf_blob_get(fileName, &mem_address, &size, NULL) != GF_OK) {\n\t\t\treturn 0;\n\t\t}\n        if (size && (size > start_range + 8)) {\n\t\t\ttype = GF_4CC(mem_address[start_range + 4], mem_address[start_range + 5], mem_address[start_range + 6], mem_address[start_range + 7]);\n        }\n        gf_blob_release(fileName);\n\t} else if (!strncmp(fileName, \"isobmff://\", 10)) {\n\t\treturn 2;\n\t} else {\n\t\tu32 nb_read;\n\t\tunsigned char data[4];\n\t\tFILE *f = gf_fopen(fileName, \"rb\");\n\t\tif (!f) return 0;\n\t\tif (start_range) gf_fseek(f, start_range, SEEK_SET);\n\t\ttype = 0;\n\t\tnb_read = (u32) gf_fread(data, 4, f);\n\t\tif (nb_read == 4) {\n\t\t\tif (gf_fread(data, 4, f) == 4) {\n\t\t\t\ttype = GF_4CC(data[0], data[1], data[2], data[3]);\n\t\t\t}\n\t\t}\n\t\tgf_fclose(f);\n\t\tif (!nb_read) return 0;\n\t}\n\treturn gf_isom_probe_type(type);\n}\n\nGF_EXPORT\nu32 gf_isom_probe_file(const char *fileName)\n{\n\treturn gf_isom_probe_file_range(fileName, 0, 0);\n}\n\nGF_EXPORT\nu32 gf_isom_probe_data(const u8*inBuf, u32 inSize)\n{\n\tu32 type;\n\tif (inSize < 8) return 0;\n\ttype = GF_4CC(inBuf[4], inBuf[5], inBuf[6], inBuf[7]);\n\treturn gf_isom_probe_type(type);\n}\n\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n#include <gpac/internal/media_dev.h>\n#endif\n\nstatic GF_Err isom_create_init_from_mem(const char *fileName, GF_ISOFile *file)\n{\n\tu32 sample_rate=0;\n\tu32 nb_channels=0;\n\tu32 bps=0;\n\t//u32 atag=0;\n\tu32 nal_len=4;\n\tu32 width = 0;\n\tu32 height = 0;\n\tu32 timescale = 10000000;\n\tu64 tfdt = 0;\n\tchar sz4cc[5];\n\tchar CodecParams[2048];\n\tu32 CodecParamLen=0;\n\tchar *sep, *val;\n\tGF_TrackBox *trak;\n\tGF_TrackExtendsBox *trex;\n\tGF_SampleTableBox *stbl;\n\n\tsz4cc[0] = 0;\n\n\tval = (char*) ( fileName + strlen(\"isobmff://\") );\n\twhile (1)  {\n\t\tsep = strchr(val, ' ');\n\t\tif (sep) sep[0] = 0;\n\n\t\tif (!strncmp(val, \"4cc=\", 4)) strcpy(sz4cc, val+4);\n\t\telse if (!strncmp(val, \"init=\", 5)) {\n\t\t\tchar szH[3], *data = val+5;\n\t\t\tu32 i, len = (u32) strlen(data);\n\t\t\tfor (i=0; i<len; i+=2) {\n\t\t\t\tu32 v;\n\t\t\t\t//init is hex-encoded so 2 input bytes for one output char\n\t\t\t\tszH[0] = data[i];\n\t\t\t\tszH[1] = data[i+1];\n\t\t\t\tszH[2] = 0;\n\t\t\t\tsscanf(szH, \"%X\", &v);\n\t\t\t\tCodecParams[CodecParamLen] = (char) v;\n\t\t\t\tCodecParamLen++;\n\t\t\t}\n\t\t}\n\t\telse if (!strncmp(val, \"nal=\", 4)) nal_len = atoi(val+4);\n\t\telse if (!strncmp(val, \"bps=\", 4)) bps = atoi(val+4);\n\t\t//else if (!strncmp(val, \"atag=\", 5)) atag = atoi(val+5);\n\t\telse if (!strncmp(val, \"ch=\", 3)) nb_channels = atoi(val+3);\n\t\telse if (!strncmp(val, \"srate=\", 6)) sample_rate = atoi(val+6);\n\t\telse if (!strncmp(val, \"w=\", 2)) width = atoi(val+2);\n\t\telse if (!strncmp(val, \"h=\", 2)) height = atoi(val+2);\n\t\telse if (!strncmp(val, \"scale=\", 6)) timescale = atoi(val+6);\n\t\telse if (!strncmp(val, \"tfdt=\", 5)) {\n\t\t\tsscanf(val+5, LLX, &tfdt);\n\t\t}\n\t\tif (!sep) break;\n\t\tsep[0] = ' ';\n\t\tval = sep+1;\n\t}\n\tif (!stricmp(sz4cc, \"H264\") || !stricmp(sz4cc, \"AVC1\")) {\n\t}\n\telse if (!stricmp(sz4cc, \"AACL\")) {\n\t}\n\telse {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Cannot convert smooth media type %s to ISO init segment\\n\", sz4cc));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tfile->moov = (GF_MovieBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MOOV);\n\tif (!file->moov) return GF_OUT_OF_MEM;\n\tgf_list_add(file->TopBoxes, file->moov);\n\tfile->moov->mov = file;\n\tfile->is_smooth = GF_TRUE;\n\tfile->moov->mvhd = (GF_MovieHeaderBox *) gf_isom_box_new_parent(&file->moov->child_boxes, GF_ISOM_BOX_TYPE_MVHD);\n\tif (!file->moov->mvhd) return GF_OUT_OF_MEM;\n\tfile->moov->mvhd->timeScale = timescale;\n\tfile->moov->mvex = (GF_MovieExtendsBox *) gf_isom_box_new_parent(&file->moov->child_boxes, GF_ISOM_BOX_TYPE_MVEX);\n\tif (!file->moov->mvex) return GF_OUT_OF_MEM;\n\ttrex = (GF_TrackExtendsBox *) gf_isom_box_new_parent(&file->moov->mvex->child_boxes, GF_ISOM_BOX_TYPE_TREX);\n\tif (!trex) return GF_OUT_OF_MEM;\n\n\ttrex->def_sample_desc_index = 1;\n\ttrex->trackID = 1;\n\tgf_list_add(file->moov->mvex->TrackExList, trex);\n\n\ttrak = (GF_TrackBox *) gf_isom_box_new_parent(&file->moov->child_boxes, GF_ISOM_BOX_TYPE_TRAK);\n\tif (!trak) return GF_OUT_OF_MEM;\n\ttrak->moov = file->moov;\n\tgf_list_add(file->moov->trackList, trak);\n\n\ttrak->Header = (GF_TrackHeaderBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TKHD);\n\tif (!trak->Header) return GF_OUT_OF_MEM;\n\ttrak->Header->trackID = 1;\n\ttrak->Header->flags |= 1;\n\ttrak->Header->width = width;\n\ttrak->Header->height = height;\n\n\ttrak->Media = (GF_MediaBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_MDIA);\n\tif (!trak->Media) return GF_OUT_OF_MEM;\n\ttrak->Media->mediaTrack = trak;\n\ttrak->Media->mediaHeader = (GF_MediaHeaderBox *) gf_isom_box_new_parent(&trak->Media->child_boxes, GF_ISOM_BOX_TYPE_MDHD);\n\tif (!trak->Media->mediaHeader) return GF_OUT_OF_MEM;\n\ttrak->Media->mediaHeader->timeScale = timescale;\n\n\ttrak->Media->handler = (GF_HandlerBox *) gf_isom_box_new_parent(&trak->Media->child_boxes,GF_ISOM_BOX_TYPE_HDLR);\n\tif (!trak->Media->handler) return GF_OUT_OF_MEM;\n    //we assume by default vide for handler type (only used for smooth streaming)\n\ttrak->Media->handler->handlerType = width ? GF_ISOM_MEDIA_VISUAL : GF_ISOM_MEDIA_AUDIO;\n\n\ttrak->Media->information = (GF_MediaInformationBox *) gf_isom_box_new_parent(&trak->Media->child_boxes, GF_ISOM_BOX_TYPE_MINF);\n\tif (!trak->Media->information) return GF_OUT_OF_MEM;\n\ttrak->Media->information->sampleTable = (GF_SampleTableBox *) gf_isom_box_new_parent(&trak->Media->information->child_boxes, GF_ISOM_BOX_TYPE_STBL);\n\tif (!trak->Media->information->sampleTable) return GF_OUT_OF_MEM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tstbl->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSZ);\n\tif (!stbl->SampleSize) return GF_OUT_OF_MEM;\n\tstbl->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STTS);\n\tif (!stbl->TimeToSample) return GF_OUT_OF_MEM;\n\tstbl->ChunkOffset = (GF_Box *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STCO);\n\tif (!stbl->ChunkOffset) return GF_OUT_OF_MEM;\n\tstbl->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSC);\n\tif (!stbl->SampleToChunk) return GF_OUT_OF_MEM;\n\tstbl->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\tif (!stbl->SyncSample) return GF_OUT_OF_MEM;\n\tstbl->SampleDescription = (GF_SampleDescriptionBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSD);\n\tif (!stbl->SampleDescription) return GF_OUT_OF_MEM;\n\n\ttrak->dts_at_seg_start = tfdt;\n\ttrak->dts_at_next_seg_start = tfdt;\n\n\n\tif (!stricmp(sz4cc, \"H264\") || !stricmp(sz4cc, \"AVC1\")) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tu32 pos = 0;\n\t\tu32 end, sc_size=0;\n#endif\n\t\tGF_MPEGVisualSampleEntryBox *avc =  (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new_parent(&stbl->SampleDescription->child_boxes, GF_ISOM_BOX_TYPE_AVC1);\n\t\tif (!avc) return GF_OUT_OF_MEM;\n\t\tavc->avc_config =  (GF_AVCConfigurationBox *) gf_isom_box_new_parent(&avc->child_boxes, GF_ISOM_BOX_TYPE_AVCC);\n\t\tif (!avc->avc_config) return GF_OUT_OF_MEM;\n\n\t\tavc->Width = width;\n\t\tavc->Height = height;\n\n\t\tavc->avc_config->config = gf_odf_avc_cfg_new();\n\t\tavc->avc_config->config->nal_unit_size = nal_len;\n\t\tavc->avc_config->config->configurationVersion = 1;\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t//locate pps and sps\n\t\tgf_media_nalu_next_start_code((u8 *) CodecParams, CodecParamLen, &sc_size);\n\t\tpos += sc_size;\n\t\twhile (pos<CodecParamLen) {\n\t\t\tGF_NALUFFParam *slc;\n\t\t\tu8 nal_type;\n\t\t\tchar *nal = &CodecParams[pos];\n\t\t\tend = gf_media_nalu_next_start_code(nal, CodecParamLen-pos, &sc_size);\n\t\t\tif (!end) end = CodecParamLen;\n\n\t\t\tGF_SAFEALLOC(slc, GF_NALUFFParam);\n\t\t\tif (!slc) break;\n\t\t\tslc->size = end;\n\t\t\tslc->data = gf_malloc(sizeof(char)*slc->size);\n\t\t\tif (!slc->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(slc->data, nal, sizeof(char)*slc->size);\n\n\t\t\tnal_type = nal[0] & 0x1F;\n\t\t\tif (nal_type == GF_AVC_NALU_SEQ_PARAM) {\n/*\t\t\t\tAVCState avcc;\n\t\t\t\tu32 idx = gf_avc_read_sps(slc->data, slc->size, &avcc, 0, NULL);\n\t\t\t\tavc->avc_config->config->profile_compatibility = avcc.sps[idx].prof_compat;\n\t\t\t\tavc->avc_config->config->AVCProfileIndication = avcc.sps[idx].profile_idc;\n\t\t\t\tavc->avc_config->config->AVCLevelIndication = avcc.sps[idx].level_idc;\n\t\t\t\tavc->avc_config->config->chroma_format = avcc.sps[idx].chroma_format;\n\t\t\t\tavc->avc_config->config->luma_bit_depth = 8 + avcc.sps[idx].luma_bit_depth_m8;\n\t\t\t\tavc->avc_config->config->chroma_bit_depth = 8 + avcc.sps[idx].chroma_bit_depth_m8;\n*/\n\n\t\t\t\tgf_list_add(avc->avc_config->config->sequenceParameterSets, slc);\n\t\t\t} else {\n\t\t\t\tgf_list_add(avc->avc_config->config->pictureParameterSets, slc);\n\t\t\t}\n\t\t\tpos += slc->size + sc_size;\n\t\t}\n#endif\n\n\t\tAVC_RewriteESDescriptor(avc);\n\t}\n\telse if (!stricmp(sz4cc, \"AACL\")) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tGF_M4ADecSpecInfo aacinfo;\n#endif\n\n\t\tGF_MPEGAudioSampleEntryBox *aac =  (GF_MPEGAudioSampleEntryBox *) gf_isom_box_new_parent(&stbl->SampleDescription->child_boxes, GF_ISOM_BOX_TYPE_MP4A);\n\t\tif (!aac) return GF_OUT_OF_MEM;\n\t\taac->esd = (GF_ESDBox *) gf_isom_box_new_parent(&aac->child_boxes, GF_ISOM_BOX_TYPE_ESDS);\n\t\tif (!aac->esd) return GF_OUT_OF_MEM;\n\t\taac->esd->desc = gf_odf_desc_esd_new(2);\n\t\tif (!aac->esd->desc) return GF_OUT_OF_MEM;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tmemset(&aacinfo, 0, sizeof(GF_M4ADecSpecInfo));\n\t\taacinfo.nb_chan = nb_channels;\n\t\taacinfo.base_object_type = GF_M4A_AAC_LC;\n\t\taacinfo.base_sr = sample_rate;\n\t\tgf_m4a_write_config(&aacinfo, &aac->esd->desc->decoderConfig->decoderSpecificInfo->data, &aac->esd->desc->decoderConfig->decoderSpecificInfo->dataLength);\n#endif\n\t\taac->esd->desc->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\taac->esd->desc->decoderConfig->objectTypeIndication = GF_CODECID_AAC_MPEG4;\n\t\taac->bitspersample = bps;\n\t\taac->samplerate_hi = sample_rate;\n\t\taac->channel_count = nb_channels;\n\t}\n\n\treturn GF_OK;\n}\n\n/**************************************************************\n\t\t\t\t\tFile Opening in streaming mode\n\t\t\tthe file map is regular (through FILE handles)\n**************************************************************/\nGF_EXPORT\nGF_Err gf_isom_open_progressive_ex(const char *fileName, u64 start_range, u64 end_range, Bool enable_frag_bounds, GF_ISOFile **the_file, u64 *BytesMissing, u32 *outBoxType)\n{\n\tGF_Err e;\n\tGF_ISOFile *movie;\n\n\tif (!BytesMissing || !the_file)\n\t\treturn GF_BAD_PARAM;\n\t*BytesMissing = 0;\n\t*the_file = NULL;\n\n\tmovie = gf_isom_new_movie();\n\tif (!movie) return GF_OUT_OF_MEM;\n\n\tmovie->fileName = gf_strdup(fileName);\n\tmovie->openMode = GF_ISOM_OPEN_READ;\n\tmovie->signal_frag_bounds = enable_frag_bounds;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tmovie->editFileMap = NULL;\n\tmovie->finalName = NULL;\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\tif (!strncmp(fileName, \"isobmff://\", 10)) {\n\t\tmovie->movieFileMap = NULL;\n\t\te = isom_create_init_from_mem(fileName, movie);\n\t} else {\n\t\t//do NOT use FileMapping on incomplete files\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_READ, &movie->movieFileMap);\n\t\tif (e) {\n\t\t\tgf_isom_delete_movie(movie);\n\t\t\treturn e;\n\t\t}\n\n\t\tif (start_range || end_range) {\n\t\t\tif (end_range>start_range) {\n\t\t\t\tgf_bs_seek(movie->movieFileMap->bs, end_range+1);\n\t\t\t\tgf_bs_truncate(movie->movieFileMap->bs);\n\t\t\t}\n\t\t\tgf_bs_seek(movie->movieFileMap->bs, start_range);\n\t\t}\n\t\te = gf_isom_parse_movie_boxes(movie, outBoxType, BytesMissing, GF_TRUE);\n\n\t}\n\tif (e == GF_ISOM_INCOMPLETE_FILE) {\n\t\t//if we have a moov, we're fine\n\t\tif (movie->moov) {\n\t\t\t*the_file = (GF_ISOFile *)movie;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//if not, delete the movie\n\t\tgf_isom_delete_movie(movie);\n\t\treturn e;\n\t} else if (e) {\n\t\t//if not, delete the movie\n\t\tgf_isom_delete_movie(movie);\n\t\treturn e;\n\t}\n\n\t//OK, let's return\n\t*the_file = (GF_ISOFile *)movie;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_open_progressive(const char *fileName, u64 start_range, u64 end_range, Bool enable_frag_bounds, GF_ISOFile **the_file, u64 *BytesMissing)\n{\n\treturn gf_isom_open_progressive_ex(fileName, start_range, end_range, enable_frag_bounds, the_file, BytesMissing, NULL);\n}\n\n/**************************************************************\n\t\t\t\t\tFile Reading\n**************************************************************/\n\nGF_EXPORT\nGF_ISOFile *gf_isom_open(const char *fileName, GF_ISOOpenMode OpenMode, const char *tmp_dir)\n{\n\tGF_ISOFile *movie;\n\tMP4_API_IO_Err = GF_OK;\n\n\tswitch (OpenMode & 0xFF) {\n\tcase GF_ISOM_OPEN_READ_DUMP:\n\tcase GF_ISOM_OPEN_READ:\n\t\tmovie = gf_isom_open_file(fileName, OpenMode, NULL);\n\t\tbreak;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\tcase GF_ISOM_OPEN_WRITE:\n\t\tmovie = gf_isom_create_movie(fileName, OpenMode, tmp_dir);\n\t\tbreak;\n\tcase GF_ISOM_OPEN_EDIT:\n\tcase GF_ISOM_OPEN_READ_EDIT:\n\tcase GF_ISOM_OPEN_KEEP_FRAGMENTS:\n\t\tmovie = gf_isom_open_file(fileName, OpenMode, tmp_dir);\n\t\tbreak;\n\tcase GF_ISOM_WRITE_EDIT:\n\t\tmovie = gf_isom_create_movie(fileName, OpenMode, tmp_dir);\n\t\tbreak;\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\tdefault:\n\t\treturn NULL;\n\t}\n\treturn (GF_ISOFile *) movie;\n}\n\n\n#if 0\n/*! gets access to the data bitstream  - see \\ref gf_isom_open\n\\param isom_file the target ISO file\n\\param out_bs set to the file input bitstream - do NOT destroy\n\\return error if any\n*/\nGF_Err gf_isom_get_bs(GF_ISOFile *movie, GF_BitStream **out_bs)\n{\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (!movie || movie->openMode != GF_ISOM_OPEN_WRITE || !movie->editFileMap) //memory mode\n\t\treturn GF_NOT_SUPPORTED;\n\n\tif (movie->segment_bs)\n\t\t*out_bs = movie->segment_bs;\n\telse\n\t\t*out_bs = movie->editFileMap->bs;\n\n\tif (movie->moof)\n\t\tmovie->moof->fragment_offset = 0;\n\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_isom_write(GF_ISOFile *movie) {\n\tGF_Err e;\n\tif (movie == NULL) return GF_ISOM_INVALID_FILE;\n\te = GF_OK;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t//write our movie to the file\n\tif ((movie->openMode != GF_ISOM_OPEN_READ) && (movie->openMode != GF_ISOM_OPEN_READ_EDIT)) {\n\t\tgf_isom_get_duration(movie);\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t//movie fragment mode, just store the fragment\n\t\tif ( (movie->openMode == GF_ISOM_OPEN_WRITE) && (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) {\n\t\t\te = gf_isom_close_fragments(movie);\n\t\t\tif (e) return e;\n\t\t\t//in case of mfra box usage -> create mfro, calculate box sizes and write it out\n\t\t\tif (movie->mfra) {\n\t\t\t\tif (!movie->mfra->mfro) {\n\t\t\t\t\tmovie->mfra->mfro = (GF_MovieFragmentRandomAccessOffsetBox *)gf_isom_box_new_parent(&movie->mfra->child_boxes, GF_ISOM_BOX_TYPE_MFRO);\n\t\t\t\t\tif (!movie->mfra->mfro) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\te = gf_isom_box_size((GF_Box *)movie->mfra);\n\t\t\t\tif (e) return e;\n\t\t\t\tmovie->mfra->mfro->container_size = (u32) movie->mfra->size;\n\n\t\t\t\t//write mfra\n\t\t\t\tif (!strcmp(movie->fileName, \"_gpac_isobmff_redirect\") && movie->on_block_out) {\n\t\t\t\t\tGF_BitStream *bs = gf_bs_new_cbk(movie->on_block_out, movie->on_block_out_usr_data, movie->on_block_out_block_size);\n\n\t\t\t\t\te = gf_isom_box_write((GF_Box *)movie->mfra, bs);\n\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t} else {\n\t\t\t\t\te = gf_isom_box_write((GF_Box *)movie->mfra, movie->editFileMap->bs);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n#endif\n\t\t\te = WriteToFile(movie, GF_FALSE);\n\t}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (movie->moov) {\n\t\tu32 i;\n\t\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\t\t/*delete any pending dataHandler of scalable enhancements*/\n\t\t\tif (trak->Media && trak->Media->information && trak->Media->information->scalableDataHandler && (trak->Media->information->scalableDataHandler != movie->movieFileMap))\n\t\t\t\tgf_isom_datamap_del(trak->Media->information->scalableDataHandler);\n\t\t}\n\t}\n#endif\n\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_close(GF_ISOFile *movie)\n{\n\tGF_Err e=GF_OK;\n\tif (movie == NULL) return GF_ISOM_INVALID_FILE;\n\te = gf_isom_write(movie);\n\t//free and return;\n\tgf_isom_delete_movie(movie);\n\treturn e;\n}\n\n\n#if 0 //unused\n/*! checks if files has root OD/IOD or not\n\\param isom_file the target ISO file\n\\return GF_TRUE if the file has a root OD or IOD */\nBool gf_isom_has_root_od(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov || !movie->moov->iods || !movie->moov->iods->descriptor) return GF_FALSE;\n\treturn GF_TRUE;\n}\n#endif\n\nGF_EXPORT\nvoid gf_isom_disable_odf_conversion(GF_ISOFile *movie, Bool disable)\n{\n\tif (movie) movie->disable_odf_translate = disable;\n}\n\n//this funct is used for exchange files, where the iods contains an OD\nGF_EXPORT\nGF_Descriptor *gf_isom_get_root_od(GF_ISOFile *movie)\n{\n\tGF_Descriptor *desc;\n\tGF_ObjectDescriptor *od;\n\tGF_InitialObjectDescriptor *iod;\n\tGF_IsomObjectDescriptor *isom_od;\n\tGF_IsomInitialObjectDescriptor *isom_iod;\n\tGF_ESD *esd;\n\tGF_ES_ID_Inc *inc;\n\tu32 i;\n\tu8 useIOD;\n\n\tif (!movie || !movie->moov) return NULL;\n\tif (!movie->moov->iods) return NULL;\n\n\tif (movie->disable_odf_translate) {\n\t\t//duplicate our descriptor\n\t\tmovie->LastError = gf_odf_desc_copy((GF_Descriptor *) movie->moov->iods->descriptor, &desc);\n\t\tif (movie->LastError) return NULL;\n\t\treturn desc;\n\t}\n\tod = NULL;\n\tiod = NULL;\n\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tod = (GF_ObjectDescriptor*)gf_malloc(sizeof(GF_ObjectDescriptor));\n\t\tif (!od) return NULL;\n\n\t\tmemset(od, 0, sizeof(GF_ObjectDescriptor));\n\t\tod->ESDescriptors = gf_list_new();\n\t\tuseIOD = 0;\n\t\tbreak;\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tiod = (GF_InitialObjectDescriptor*)gf_malloc(sizeof(GF_InitialObjectDescriptor));\n\t\tif (!iod) return NULL;\n\n\t\tmemset(iod, 0, sizeof(GF_InitialObjectDescriptor));\n\t\tiod->ESDescriptors = gf_list_new();\n\t\tuseIOD = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\t//duplicate our descriptor\n\tmovie->LastError = gf_odf_desc_copy((GF_Descriptor *) movie->moov->iods->descriptor, &desc);\n\tif (movie->LastError) return NULL;\n\n\tif (!useIOD) {\n\t\tisom_od = (GF_IsomObjectDescriptor *)desc;\n\t\tod->objectDescriptorID = isom_od->objectDescriptorID;\n\t\tod->extensionDescriptors = isom_od->extensionDescriptors;\n\t\tisom_od->extensionDescriptors = NULL;\n\t\tod->IPMP_Descriptors = isom_od->IPMP_Descriptors;\n\t\tisom_od->IPMP_Descriptors = NULL;\n\t\tod->OCIDescriptors = isom_od->OCIDescriptors;\n\t\tisom_od->OCIDescriptors = NULL;\n\t\tod->URLString = isom_od->URLString;\n\t\tisom_od->URLString = NULL;\n\t\tod->tag = GF_ODF_OD_TAG;\n\t\t//then recreate the desc in Inc\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(isom_od->ES_ID_IncDescriptors, &i))) {\n\t\t\tmovie->LastError = GetESDForTime(movie->moov, inc->trackID, 0, &esd);\n\t\t\tif (!movie->LastError) movie->LastError = gf_list_add(od->ESDescriptors, esd);\n\t\t\tif (movie->LastError) {\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) od);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tgf_odf_desc_del(desc);\n\t\treturn (GF_Descriptor *)od;\n\t} else {\n\t\tisom_iod = (GF_IsomInitialObjectDescriptor *)desc;\n\t\tiod->objectDescriptorID = isom_iod->objectDescriptorID;\n\t\tiod->extensionDescriptors = isom_iod->extensionDescriptors;\n\t\tisom_iod->extensionDescriptors = NULL;\n\t\tiod->IPMP_Descriptors = isom_iod->IPMP_Descriptors;\n\t\tisom_iod->IPMP_Descriptors = NULL;\n\t\tiod->OCIDescriptors = isom_iod->OCIDescriptors;\n\t\tisom_iod->OCIDescriptors = NULL;\n\t\tiod->URLString = isom_iod->URLString;\n\t\tisom_iod->URLString = NULL;\n\t\tiod->tag = GF_ODF_IOD_TAG;\n\n\t\tiod->audio_profileAndLevel = isom_iod->audio_profileAndLevel;\n\t\tiod->graphics_profileAndLevel = isom_iod->graphics_profileAndLevel;\n\t\tiod->inlineProfileFlag = isom_iod->inlineProfileFlag;\n\t\tiod->OD_profileAndLevel = isom_iod->OD_profileAndLevel;\n\t\tiod->scene_profileAndLevel = isom_iod->scene_profileAndLevel;\n\t\tiod->visual_profileAndLevel = isom_iod->visual_profileAndLevel;\n\t\tiod->IPMPToolList = isom_iod->IPMPToolList;\n\t\tisom_iod->IPMPToolList = NULL;\n\n\t\t//then recreate the desc in Inc\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(isom_iod->ES_ID_IncDescriptors, &i))) {\n\t\t\tmovie->LastError = GetESDForTime(movie->moov, inc->trackID, 0, &esd);\n\t\t\tif (!movie->LastError) movie->LastError = gf_list_add(iod->ESDescriptors, esd);\n\t\t\tif (movie->LastError) {\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) iod);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tgf_odf_desc_del(desc);\n\t\treturn (GF_Descriptor *)iod;\n\t}\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_track_count(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov) return 0;\n\n\tif (!movie->moov->trackList) {\n\t\tmovie->LastError = GF_ISOM_INVALID_FILE;\n\t\treturn 0;\n\t}\n\treturn gf_list_count(movie->moov->trackList);\n}\n\n\nGF_EXPORT\nGF_ISOTrackID gf_isom_get_track_id(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tif (!movie) return 0;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Header) return 0;\n\treturn trak->Header->trackID;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_track_by_id(GF_ISOFile *the_file, GF_ISOTrackID trackID)\n{\n\tu32 count;\n\tu32 i;\n\tif (the_file == NULL) return 0;\n\n\tcount = gf_isom_get_track_count(the_file);\n\tif (!count) return 0;\n\tfor (i = 0; i < count; i++) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, i+1);\n\t\tif (!trak || !trak->Header) return 0;\n\t\tif (trak->Header->trackID == trackID) return i+1;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nGF_ISOTrackID gf_isom_get_track_original_id(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tif (!movie) return 0;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->originalID;\n}\n\n//return the timescale of the movie, 0 if error\nGF_EXPORT\nBool gf_isom_has_movie(GF_ISOFile *file)\n{\n\tif (file && file->moov) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\n#ifndef GPAC_DISABLE_ISOM\nGF_EXPORT\nBool gf_isom_has_segment(GF_ISOFile *file, u32 *brand, u32 *version)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i;\n\tGF_Box *a;\n\ti = 0;\n\twhile (NULL != (a = (GF_Box*)gf_list_enum(file->TopBoxes, &i))) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (a->type == GF_ISOM_BOX_TYPE_STYP) {\n\t\t\tGF_FileTypeBox *styp = (GF_FileTypeBox *)a;\n\t\t\t*brand = styp->majorBrand;\n\t\t\t*version = styp->minorVersion;\n\t\t\treturn GF_TRUE;\n\t\t}\n#endif\n\t}\n#endif\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_segment_get_fragment_count(GF_ISOFile *file)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (file) {\n\t\tu32 i, count = 0;\n\t\tfor (i=0; i<gf_list_count(file->TopBoxes); i++) {\n\t\t\tGF_Box *a = (GF_Box*)gf_list_get(file->TopBoxes, i);\n\t\t\tif (a->type==GF_ISOM_BOX_TYPE_MOOF) count++;\n\t\t}\n\t\treturn count;\n\t}\n#endif\n\treturn 0;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nstatic GF_MovieFragmentBox *gf_isom_get_moof(GF_ISOFile *file, u32 moof_index)\n{\n\tu32 i;\n\tfor (i=0; i<gf_list_count(file->TopBoxes); i++) {\n\t\tGF_Box *a = (GF_Box*)gf_list_get(file->TopBoxes, i);\n\t\tif (a->type==GF_ISOM_BOX_TYPE_MOOF) {\n\t\t\tmoof_index--;\n\t\t\tif (!moof_index) return (GF_MovieFragmentBox *) a;\n\t\t}\n\t}\n\treturn NULL;\n}\n#endif /* GPAC_DISABLE_ISOM_FRAGMENTS */\n\nGF_EXPORT\nu32 gf_isom_segment_get_track_fragment_count(GF_ISOFile *file, u32 moof_index)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_MovieFragmentBox *moof;\n\tif (!file) return 0;\n\tgf_list_count(file->TopBoxes);\n\tmoof = gf_isom_get_moof(file, moof_index);\n\treturn moof ? gf_list_count(moof->TrackList) : 0;\n#endif\n\treturn 0;\n}\n\nGF_EXPORT\nu32 gf_isom_segment_get_track_fragment_decode_time(GF_ISOFile *file, u32 moof_index, u32 traf_index, u64 *decode_time)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_MovieFragmentBox *moof;\n\tGF_TrackFragmentBox *traf;\n\tif (!file) return 0;\n\tgf_list_count(file->TopBoxes);\n\tmoof = gf_isom_get_moof(file, moof_index);\n\ttraf = moof ? (GF_TrackFragmentBox*)gf_list_get(moof->TrackList, traf_index-1) : NULL;\n\tif (!traf) return 0;\n\tif (decode_time) {\n\t\t*decode_time = traf->tfdt ? traf->tfdt->baseMediaDecodeTime : 0;\n\t}\n\treturn traf->tfhd->trackID;\n#endif\n\treturn 0;\n}\n#endif\n\n//return the timescale of the movie, 0 if error\nGF_EXPORT\nu32 gf_isom_get_timescale(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov || !movie->moov->mvhd) return 0;\n\treturn movie->moov->mvhd->timeScale;\n}\n\n\n//return the duration of the movie, 0 if error\nGF_EXPORT\nu64 gf_isom_get_duration(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov || !movie->moov->mvhd) return 0;\n\n\t//if file was open in Write or Edit mode, recompute the duration\n\t//the duration of a movie is the MaxDuration of all the tracks...\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tgf_isom_update_duration(movie);\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\treturn movie->moov->mvhd->duration;\n}\n//return the duration of the movie, 0 if error\nGF_EXPORT\nu64 gf_isom_get_original_duration(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov|| !movie->moov->mvhd) return 0;\n\treturn movie->moov->mvhd->original_duration;\n}\n\n//return the creation info of the movie\nGF_EXPORT\nGF_Err gf_isom_get_creation_time(GF_ISOFile *movie, u64 *creationTime, u64 *modificationTime)\n{\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n\tif (creationTime) *creationTime = movie->moov->mvhd->creationTime;\n\tif (creationTime) *modificationTime = movie->moov->mvhd->modificationTime;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_creation_time(GF_ISOFile *movie, u32 trackNumber, u64 *creationTime, u64 *modificationTime)\n{\n\tGF_TrackBox *trak;\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n\tif (creationTime) *creationTime = trak->Media->mediaHeader->creationTime;\n\tif (creationTime) *modificationTime = trak->Media->mediaHeader->modificationTime;\n\treturn GF_OK;\n}\n\n//check the presence of a track in IOD. 0: NO, 1: YES, 2: ERROR\nGF_EXPORT\nu8 gf_isom_is_track_in_root_od(GF_ISOFile *movie, u32 trackNumber)\n{\n\tu32 i;\n\tGF_ISOTrackID trackID;\n\tGF_Descriptor *desc;\n\tGF_ES_ID_Inc *inc;\n\tGF_List *inc_list;\n\tif (!movie) return 2;\n\tif (!movie->moov || !movie->moov->iods) return 0;\n\n\tdesc = movie->moov->iods->descriptor;\n\tswitch (desc->tag) {\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tinc_list = ((GF_IsomInitialObjectDescriptor *)desc)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tinc_list = ((GF_IsomObjectDescriptor *)desc)->ES_ID_IncDescriptors;\n\t\tbreak;\n\t//files without IOD are possible !\n\tdefault:\n\t\treturn 0;\n\t}\n\ttrackID = gf_isom_get_track_id(movie, trackNumber);\n\tif (!trackID) return 2;\n\ti=0;\n\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(inc_list, &i))) {\n\t\tif (inc->trackID == (u32) trackID) return 1;\n\t}\n\treturn 0;\n}\n\n\n\n//gets the enable flag of a track\n//0: NO, 1: YES, 2: ERROR\nGF_EXPORT\nu8 gf_isom_is_track_enabled(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\n\tif (!trak || !trak->Header) return 2;\n\treturn (trak->Header->flags & 1) ? 1 : 0;\n}\n\nGF_EXPORT\nu32 gf_isom_get_track_flags(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->Header->flags;\n}\n\n\n//get the track duration\n//return 0 if bad param\nGF_EXPORT\nu64 gf_isom_get_track_duration(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t/*in all modes except dump recompute duration in case headers are wrong*/\n\tif (movie->openMode != GF_ISOM_OPEN_READ_DUMP) {\n\t\tSetTrackDuration(trak);\n\t}\n#endif\n\treturn trak->Header->duration;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_media_language(GF_ISOFile *the_file, u32 trackNumber, char **lang)\n{\n\tu32 count;\n\tBool elng_found = GF_FALSE;\n\tGF_TrackBox *trak;\n\tif (!lang) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\t*lang = NULL;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tcount = gf_list_count(trak->Media->child_boxes);\n\tif (count>0) {\n\t\tu32 i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tGF_Box *box = (GF_Box *)gf_list_get(trak->Media->child_boxes, i);\n\t\t\tif (box->type == GF_ISOM_BOX_TYPE_ELNG) {\n\t\t\t\t*lang = gf_strdup(((GF_ExtendedLanguageBox *)box)->extended_language);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t}\n\tif (!elng_found) {\n\t\t*lang = gf_strdup(trak->Media->mediaHeader->packedLanguage);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_isom_get_track_kind_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\t\tif (!trak) return 0;\n\t\tif (!trak->udta) {\n\t\t\treturn 0;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\treturn 0;\n\t}\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_KIND, NULL);\n\tif (!map) return 0;\n\n\treturn gf_list_count(map->boxes);\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_kind(GF_ISOFile *the_file, u32 trackNumber, u32 index, char **scheme, char **value)\n{\n\tGF_Err e;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tGF_KindBox *kindBox;\n\tif (!scheme || !value) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\t*scheme = NULL;\n\t*value = NULL;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_KIND, NULL);\n\tif (!map) return GF_BAD_PARAM;\n\n\tkindBox = (GF_KindBox *)gf_list_get(map->boxes, index);\n\tif (!kindBox) return GF_BAD_PARAM;\n\n\t*scheme = gf_strdup(kindBox->schemeURI);\n\tif (kindBox->value) {\n\t\t*value = gf_strdup(kindBox->value);\n\t}\n\treturn GF_OK;\n}\n\n\n//Return the number of track references of a track for a given ReferenceType\n//return 0 if error\nGF_EXPORT\ns32 gf_isom_get_reference_count(GF_ISOFile *movie, u32 trackNumber, u32 referenceType)\n{\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return -1;\n\tif (!trak->References) return 0;\n\tif (movie->openMode == GF_ISOM_OPEN_WRITE) {\n\t\tmovie->LastError = GF_ISOM_INVALID_MODE;\n\t\treturn -1;\n\t}\n\n\tdpnd = NULL;\n\tif ( (movie->LastError = Track_FindRef(trak, referenceType, &dpnd)) ) return -1;\n\tif (!dpnd) return 0;\n\treturn dpnd->trackIDCount;\n}\n\n\n//Return the number of track references of a track for a given ReferenceType\n//return 0 if error\nGF_EXPORT\nconst GF_ISOTrackID *gf_isom_enum_track_references(GF_ISOFile *movie, u32 trackNumber, u32 idx, u32 *referenceType, u32 *referenceCount)\n{\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return NULL;\n\tif (!trak->References) return NULL;\n\tdpnd = gf_list_get(trak->References->child_boxes, idx);\n\tif (!dpnd) return NULL;\n\t*referenceType = dpnd->reference_type;\n\t*referenceCount = dpnd->trackIDCount;\n\treturn dpnd->trackIDs;\n}\n\n\n//Return the referenced track number for a track and a given ReferenceType and Index\n//return -1 if error, 0 if the reference is a NULL one, or the trackNumber\nGF_EXPORT\nGF_Err gf_isom_get_reference(GF_ISOFile *movie, u32 trackNumber, u32 referenceType, u32 referenceIndex, u32 *refTrack)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_ISOTrackID refTrackNum;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\n\t*refTrack = 0;\n\tif (!trak || !trak->References) return GF_BAD_PARAM;\n\n\tdpnd = NULL;\n\te = Track_FindRef(trak, referenceType, &dpnd);\n\tif (e) return e;\n\tif (!dpnd) return GF_BAD_PARAM;\n\n\tif (!referenceIndex || (referenceIndex > dpnd->trackIDCount)) return GF_BAD_PARAM;\n\n\t//the spec allows a NULL reference\n\t//(ex, to force desync of a track, set a sync ref with ID = 0)\n\tif (dpnd->trackIDs[referenceIndex - 1] == 0) return GF_OK;\n\n\trefTrackNum = gf_isom_get_tracknum_from_id(movie->moov, dpnd->trackIDs[referenceIndex-1]);\n\n\t//if the track was not found, this means the file is broken !!!\n\tif (! refTrackNum) return GF_ISOM_INVALID_FILE;\n\t*refTrack = refTrackNum;\n\treturn GF_OK;\n}\n\n//Return the referenced track ID for a track and a given ReferenceType and Index\n//return -1 if error, 0 if the reference is a NULL one, or the trackNumber\nGF_EXPORT\nGF_Err gf_isom_get_reference_ID(GF_ISOFile *movie, u32 trackNumber, u32 referenceType, u32 referenceIndex, GF_ISOTrackID *refTrackID)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\n\t*refTrackID = 0;\n\tif (!trak || !trak->References || !referenceIndex) return GF_BAD_PARAM;\n\n\tdpnd = NULL;\n\te = Track_FindRef(trak, referenceType, &dpnd);\n\tif (e) return e;\n\tif (!dpnd) return GF_BAD_PARAM;\n\n\tif (referenceIndex > dpnd->trackIDCount) return GF_BAD_PARAM;\n\n\t*refTrackID = dpnd->trackIDs[referenceIndex-1];\n\n\treturn GF_OK;\n}\n\n//Return referenceIndex if the given track has a reference to the given TreckID of a given ReferenceType\n//return 0 if error\nGF_EXPORT\nu32 gf_isom_has_track_reference(GF_ISOFile *movie, u32 trackNumber, u32 referenceType, GF_ISOTrackID refTrackID)\n{\n\tu32 i;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\tif (!trak->References) return 0;\n\n\tdpnd = NULL;\n\tif ( (movie->LastError = Track_FindRef(trak, referenceType, &dpnd)) ) return 0;\n\tif (!dpnd) return 0;\n\tfor (i=0; i<dpnd->trackIDCount; i++) {\n\t\tif (dpnd->trackIDs[i]==refTrackID) return i+1;\n\t}\n\treturn 0;\n}\n\n\n\n//Return the media time given the absolute time in the Movie\nGF_EXPORT\nGF_Err gf_isom_get_media_time(GF_ISOFile *the_file, u32 trackNumber, u32 movieTime, u64 *MediaTime)\n{\n\tGF_TrackBox *trak;\n\tu8 useEdit;\n\ts64 SegmentStartTime, mediaOffset;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !MediaTime) return GF_BAD_PARAM;\n\n\tSegmentStartTime = 0;\n\treturn GetMediaTime(trak, GF_FALSE, movieTime, MediaTime, &SegmentStartTime, &mediaOffset, &useEdit, NULL);\n}\n\n\n//Get the stream description index (eg, the ESD) for a given time IN MEDIA TIMESCALE\n//return 0 if error or if empty\nGF_EXPORT\nu32 gf_isom_get_sample_description_index(GF_ISOFile *movie, u32 trackNumber, u64 for_time)\n{\n\tu32 streamDescIndex;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n\tif ( (movie->LastError = Media_GetSampleDescIndex(trak->Media, for_time, &streamDescIndex)) ) {\n\t\treturn 0;\n\t}\n\treturn streamDescIndex;\n}\n\n//Get the number of \"streams\" stored in the media - a media can have several stream descriptions...\nGF_EXPORT\nu32 gf_isom_get_sample_description_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\treturn gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n}\n\n\n//Get the GF_ESD given the StreamDescriptionIndex\n//THE DESCRIPTOR IS DUPLICATED, SO HAS TO BE DELETED BY THE APP\nGF_EXPORT\nGF_ESD *gf_isom_get_esd(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_ESD *esd;\n\tGF_Err e;\n\te = GetESD(movie->moov, gf_isom_get_track_id(movie, trackNumber), StreamDescriptionIndex, &esd);\n\tif (e && (e!= GF_ISOM_INVALID_MEDIA)) {\n\t\tmovie->LastError = e;\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\t\treturn NULL;\n\t}\n\n\treturn esd;\n}\n\n//Get the decoderConfigDescriptor given the SampleDescriptionIndex\n//THE DESCRIPTOR IS DUPLICATED, SO HAS TO BE DELETED BY THE APP\nGF_EXPORT\nGF_DecoderConfig *gf_isom_get_decoder_config(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_ESD *esd;\n\tGF_Descriptor *decInfo;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\t//get the ESD (possibly emulated)\n\tMedia_GetESD(trak->Media, StreamDescriptionIndex, &esd, GF_FALSE);\n\tif (!esd) return NULL;\n\tdecInfo = (GF_Descriptor *) esd->decoderConfig;\n\tesd->decoderConfig = NULL;\n\tgf_odf_desc_del((GF_Descriptor *) esd);\n\treturn (GF_DecoderConfig *)decInfo;\n}\n\n\n//get the media duration (without edit)\n//return 0 if bad param\nGF_EXPORT\nu64 gf_isom_get_media_duration(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\t/*except in dump mode always recompute the duration*/\n\tif (movie->openMode != GF_ISOM_OPEN_READ_DUMP) {\n\t\tif ( (movie->LastError = Media_SetDuration(trak)) ) return 0;\n\t}\n\n#endif\n\n\treturn trak->Media->mediaHeader->duration;\n}\n\n//get the media duration (without edit)\n//return 0 if bad param\nGF_EXPORT\nu64 gf_isom_get_media_original_duration(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->mediaHeader) return 0;\n\n\treturn trak->Media->mediaHeader->original_duration;\n}\n\n//Get the timeScale of the media. All samples DTS/CTS are expressed in this timeScale\nGF_EXPORT\nu32 gf_isom_get_media_timescale(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->mediaHeader) return 0;\n\treturn trak->Media->mediaHeader->timeScale;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_copyright_count(GF_ISOFile *mov)\n{\n\tGF_UserDataMap *map;\n\tif (!mov || !mov->moov || !mov->moov->udta) return 0;\n\tmap = udta_getEntry(mov->moov->udta, GF_ISOM_BOX_TYPE_CPRT, NULL);\n\tif (!map) return 0;\n\treturn gf_list_count(map->boxes);\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_copyright(GF_ISOFile *mov, u32 Index, const char **threeCharCode, const char **notice)\n{\n\tGF_UserDataMap *map;\n\tGF_CopyrightBox *cprt;\n\n\tif (!mov || !mov->moov || !Index) return GF_BAD_PARAM;\n\n\tif (!mov->moov->udta) return GF_OK;\n\tmap = udta_getEntry(mov->moov->udta, GF_ISOM_BOX_TYPE_CPRT, NULL);\n\tif (!map) return GF_OK;\n\n\tif (Index > gf_list_count(map->boxes)) return GF_BAD_PARAM;\n\n\tcprt = (GF_CopyrightBox*)gf_list_get(map->boxes, Index-1);\n\t(*threeCharCode) = cprt->packedLanguageCode;\n\t(*notice) = cprt->notice;\n\treturn GF_OK;\n}\n\n#if 0\nGF_Err gf_isom_get_watermark(GF_ISOFile *mov, bin128 UUID, u8** data, u32* length)\n{\n\tGF_UserDataMap *map;\n\tGF_UnknownUUIDBox *wm;\n\n\tif (!mov) return GF_BAD_PARAM;\n\tif (!mov->moov || !mov->moov->udta) return GF_NOT_SUPPORTED;\n\n\tmap = udta_getEntry(mov->moov->udta, GF_ISOM_BOX_TYPE_UUID, (bin128 *) & UUID);\n\tif (!map) return GF_NOT_SUPPORTED;\n\n\twm = (GF_UnknownUUIDBox*)gf_list_get(map->boxes, 0);\n\tif (!wm) return GF_NOT_SUPPORTED;\n\n\t*data = (u8 *) gf_malloc(sizeof(char)*wm->dataSize);\n\tif (! *data) return GF_OUT_OF_MEM;\n\tmemcpy(*data, wm->data, wm->dataSize);\n\t*length = wm->dataSize;\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nu32 gf_isom_get_chapter_count(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_UserDataMap *map;\n\tGF_ChapterListBox *lst;\n\tGF_UserDataBox *udta;\n\n\tif (!movie || !movie->moov) return 0;\n\n\tudta = NULL;\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return 0;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return 0;\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\tif (!map) return 0;\n\tlst = (GF_ChapterListBox *)gf_list_get(map->boxes, 0);\n\tif (!lst) return 0;\n\treturn gf_list_count(lst->list);\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_chapter(GF_ISOFile *movie, u32 trackNumber, u32 Index, u64 *chapter_time, const char **name)\n{\n\tGF_UserDataMap *map;\n\tGF_ChapterListBox *lst;\n\tGF_ChapterEntry *ce;\n\tGF_UserDataBox *udta;\n\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n\tudta = NULL;\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_BAD_PARAM;\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\tif (!map) return GF_BAD_PARAM;\n\tlst = (GF_ChapterListBox *)gf_list_get(map->boxes, 0);\n\tif (!lst) return GF_BAD_PARAM;\n\n\tce = (GF_ChapterEntry *)gf_list_get(lst->list, Index-1);\n\tif (!ce) return GF_BAD_PARAM;\n\tif (chapter_time) {\n\t\t*chapter_time = ce->start_time;\n\t\t*chapter_time /= 10000L;\n\t}\n\tif (name) *name = ce->name;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_media_type(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\treturn (trak->Media && trak->Media->handler) ? trak->Media->handler->handlerType : 0;\n}\n\nBool IsMP4Description(u32 entryType)\n{\n\tswitch (entryType) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\tcase GF_ISOM_BOX_TYPE_LSR1:\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\tcase GF_ISOM_BOX_TYPE_ENCA:\n\tcase GF_ISOM_BOX_TYPE_ENCV:\n\tcase GF_ISOM_BOX_TYPE_RESV:\n\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nBool gf_isom_is_encrypted_entry(u32 entryType)\n{\n\tswitch (entryType) {\n\tcase GF_ISOM_BOX_TYPE_ENCA:\n\tcase GF_ISOM_BOX_TYPE_ENCV:\n\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nGF_EXPORT\nBool gf_isom_is_track_encrypted(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tu32 i=0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 2;\n\twhile (1) {\n\t\tGF_Box *entry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tif (!entry) break;\n\t\tif (gf_isom_is_encrypted_entry(entry->type)) return GF_TRUE;\n\n\t\tif (gf_isom_is_cenc_media(the_file, trackNumber, i+1))\n\t\t\treturn GF_TRUE;\n\n\t\ti++;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_get_media_subtype(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Box *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !DescriptionIndex || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable) return 0;\n\tentry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return 0;\n\n\t//filter MPEG sub-types\n\tif (IsMP4Description(entry->type)) {\n\t\tif (gf_isom_is_encrypted_entry(entry->type)) return GF_ISOM_SUBTYPE_MPEG4_CRYP;\n\t\telse return GF_ISOM_SUBTYPE_MPEG4;\n\t}\n\tif (entry->type == GF_ISOM_BOX_TYPE_GNRV) {\n\t\treturn ((GF_GenericVisualSampleEntryBox *)entry)->EntryType;\n\t}\n\telse if (entry->type == GF_ISOM_BOX_TYPE_GNRA) {\n\t\treturn ((GF_GenericAudioSampleEntryBox *)entry)->EntryType;\n\t}\n\telse if (entry->type == GF_ISOM_BOX_TYPE_GNRM) {\n\t\treturn ((GF_GenericSampleEntryBox *)entry)->EntryType;\n\t}\n\treturn entry->type;\n}\n\nGF_EXPORT\nu32 gf_isom_get_mpeg4_subtype(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Box *entry=NULL;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !DescriptionIndex) return 0;\n\n\tif (trak->Media\n\t\t&& trak->Media->information\n\t\t&& trak->Media->information->sampleTable\n\t\t&& trak->Media->information->sampleTable->SampleDescription\n\t) {\n\t\tentry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\t}\n\tif (!entry) return 0;\n\n\t//filter MPEG sub-types\n\tif (!IsMP4Description(entry->type)) return 0;\n\treturn entry->type;\n}\n\n//Get the HandlerDescription name.\nGF_EXPORT\nGF_Err gf_isom_get_handler_name(GF_ISOFile *the_file, u32 trackNumber, const char **outName)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !outName) return GF_BAD_PARAM;\n\t*outName = trak->Media->handler->nameUTF8;\n\treturn GF_OK;\n}\n\n//Check the DataReferences of this track\nGF_EXPORT\nGF_Err gf_isom_check_data_reference(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_Err e;\n\tu32 drefIndex;\n\tGF_TrackBox *trak;\n\n\tif (!StreamDescriptionIndex || !trackNumber) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex , NULL, &drefIndex);\n\tif (e) return e;\n\tif (!drefIndex) return GF_BAD_PARAM;\n\treturn Media_CheckDataEntry(trak->Media, drefIndex);\n}\n\n//get the location of the data. If URL && URN are NULL, the data is in this file\nGF_EXPORT\nGF_Err gf_isom_get_data_reference(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const char **outURL, const char **outURN)\n{\n\tGF_TrackBox *trak;\n\tGF_DataEntryURLBox *url=NULL;\n\tGF_DataEntryURNBox *urn;\n\tu32 drefIndex;\n\tGF_Err e;\n\n\t*outURL = *outURN = NULL;\n\n\tif (!StreamDescriptionIndex || !trackNumber) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex , NULL, &drefIndex);\n\tif (e) return e;\n\tif (!drefIndex) return GF_BAD_PARAM;\n\n\tif (trak->Media\n\t\t&& trak->Media->information\n\t\t&& trak->Media->information->dataInformation\n\t\t&& trak->Media->information->dataInformation->dref\n\t) {\n\t\turl = (GF_DataEntryURLBox*)gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, drefIndex - 1);\n\t}\n\tif (!url) return GF_ISOM_INVALID_FILE;\n\n\tif (url->type == GF_ISOM_BOX_TYPE_URL) {\n\t\t*outURL = url->location;\n\t\t*outURN = NULL;\n\t} else if (url->type == GF_ISOM_BOX_TYPE_URN) {\n\t\turn = (GF_DataEntryURNBox *) url;\n\t\t*outURN = urn->nameURN;\n\t\t*outURL = urn->location;\n\t} else {\n\t\t*outURN = NULL;\n\t\t*outURL = NULL;\n\t}\n\treturn GF_OK;\n}\n\n//Get the number of samples\n//return 0 if error or empty\nGF_EXPORT\nu32 gf_isom_get_sample_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\treturn trak->Media->information->sampleTable->SampleSize->sampleCount\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t       + trak->sample_count_at_seg_start\n#endif\n\t       ;\n}\n\nGF_EXPORT\nu32 gf_isom_get_constant_sample_size(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\treturn trak->Media->information->sampleTable->SampleSize->sampleSize;\n}\n\nGF_EXPORT\nu32 gf_isom_get_constant_sample_duration(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->TimeToSample) return 0;\n\tif (trak->Media->information->sampleTable->TimeToSample->nb_entries != 1) return 0;\n\treturn trak->Media->information->sampleTable->TimeToSample->entries[0].sampleDelta;\n}\n\nGF_EXPORT\nBool gf_isom_enable_raw_pack(GF_ISOFile *the_file, u32 trackNumber, u32 pack_num_samples)\n{\n\tu32 afmt, bps, nb_ch;\n\tBool from_qt=GF_FALSE;\n\tGF_TrackBox *trak;\n\tGF_MPEGAudioSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\ttrak->pack_num_samples = 0;\n\t//we only activate sample packing for raw audio\n\tif (!trak->Media || !trak->Media->handler) return GF_FALSE;\n\tif (trak->Media->handler->handlerType != GF_ISOM_MEDIA_AUDIO) return GF_FALSE;\n\t//and sample duration of 1\n\tif (!trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->TimeToSample) return GF_FALSE;\n\tif (trak->Media->information->sampleTable->TimeToSample->nb_entries != 1) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->TimeToSample->entries) return GF_FALSE;\n\tif (trak->Media->information->sampleTable->TimeToSample->entries[0].sampleDelta != 1) return GF_FALSE;\n\t//and sample with constant size\n\tif (!trak->Media->information->sampleTable->SampleSize || !trak->Media->information->sampleTable->SampleSize->sampleSize) return GF_FALSE;\n\ttrak->pack_num_samples = pack_num_samples;\n\n\tif (!pack_num_samples) return GF_FALSE;\n\n\tentry = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\tif (!entry) return GF_FALSE;\n\n\tif (entry->internal_type!=GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_FALSE;\n\n\t//sanity check, some files have wrong stsz sampleSize for raw audio !\n\tafmt = gf_audio_fmt_from_isobmf(entry->type);\n\tbps = gf_audio_fmt_bit_depth(afmt) / 8;\n\tif (!bps) {\n\t\t//unknown format, try QTv2\n\t\tif (entry->qtff_mode && (entry->internal_type==GF_ISOM_SAMPLE_ENTRY_AUDIO)) {\n\t\t\tbps = entry->extensions[8]<<24 | entry->extensions[9]<<16 | entry->extensions[10]<<8 | entry->extensions[11];\n\t\t\tfrom_qt = GF_TRUE;\n\t\t}\n\t}\n\tnb_ch = entry->channel_count;\n\tif (entry->qtff_mode && (entry->version==2)) {\n\t\t//QTFFv2 audio, channel count is 32 bit, after 32bit size of struct and 64 bit samplerate\n\t\t//hence start at 12 in extensions\n\t\tnb_ch = entry->extensions[11]<<24 | entry->extensions[12]<<16 | entry->extensions[13]<<8 | entry->extensions[14];\n\t}\n\n\tif (bps) {\n\t\tu32 res = trak->Media->information->sampleTable->SampleSize->sampleSize % bps;\n\t\tif (res) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"ISOBMF: size mismatch for raw audio sample description: constant sample size %d but %d bytes per channel for %s%s!\\n\", trak->Media->information->sampleTable->SampleSize->sampleSize,\n\t\t\t\t\tbps,\n\t\t\t\t\tgf_4cc_to_str(entry->type),\n\t\t\t\t\tfrom_qt ? \" (as indicated in QT sample description)\" : \"\"\n\t\t\t\t));\n\t\t\ttrak->Media->information->sampleTable->SampleSize->sampleSize = bps * nb_ch;\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\nBool gf_isom_has_time_offset_table(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media->information->sampleTable->CompositionOffset) return GF_FALSE;\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nu32 gf_isom_has_time_offset(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tu32 i;\n\tGF_CompositionOffsetBox *ctts;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media->information->sampleTable->CompositionOffset) return 0;\n\n\t//return true at the first offset found\n\tctts = trak->Media->information->sampleTable->CompositionOffset;\n\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\tif (ctts->entries[i].decodingOffset && ctts->entries[i].sampleCount) return ctts->version ? 2 : 1;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\ns64 gf_isom_get_cts_to_dts_shift(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media->information->sampleTable->CompositionToDecode) return 0;\n\treturn trak->Media->information->sampleTable->CompositionToDecode->compositionToDTSShift;\n}\n\nGF_EXPORT\nBool gf_isom_has_sync_shadows(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->ShadowSync) return GF_FALSE;\n\tif (gf_list_count(trak->Media->information->sampleTable->ShadowSync->entries) ) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nBool gf_isom_has_sample_dependency(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->SampleDep) return GF_FALSE;\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_flags(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *isLeading, u32 *dependsOn, u32 *dependedOn, u32 *redundant)\n{\n\tGF_TrackBox *trak;\n\t*isLeading = 0;\n\t*dependsOn = 0;\n\t*dependedOn = 0;\n\t*redundant = 0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->SampleDep) return GF_BAD_PARAM;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber <= trak->sample_count_at_seg_start)\n\t\treturn GF_BAD_PARAM;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\treturn stbl_GetSampleDepType(trak->Media->information->sampleTable->SampleDep, sampleNumber, isLeading, dependsOn, dependedOn, redundant);\n}\n\n//return a sample give its number, and set the SampleDescIndex of this sample\n//this index allows to retrieve the stream description if needed (2 media in 1 track)\n//return NULL if error\nGF_EXPORT\nGF_ISOSample *gf_isom_get_sample_ex(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, GF_ISOSample *static_sample, u64 *data_offset)\n{\n\tGF_Err e;\n\tu32 descIndex;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *samp;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\n\tif (!sampleNumber) return NULL;\n\tif (static_sample) {\n\t\tsamp = static_sample;\n\t\tif (static_sample->dataLength && !static_sample->alloc_size)\n\t\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\t} else {\n\t\tsamp = gf_isom_sample_new();\n\t}\n\tif (!samp) return NULL;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start)\n\t\treturn NULL;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\te = Media_GetSample(trak->Media, sampleNumber, &samp, &descIndex, GF_FALSE, data_offset);\n\tif (static_sample && !static_sample->alloc_size)\n\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\n\tif (e) {\n\t\tgf_isom_set_last_error(the_file, e);\n\t\tif (!static_sample) gf_isom_sample_del(&samp);\n\t\treturn NULL;\n\t}\n\tif (sampleDescriptionIndex) *sampleDescriptionIndex = descIndex;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (samp) samp->DTS += trak->dts_at_seg_start;\n#endif\n\n\treturn samp;\n}\n\nGF_EXPORT\nGF_ISOSample *gf_isom_get_sample(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex)\n{\n\treturn gf_isom_get_sample_ex(the_file, trackNumber, sampleNumber, sampleDescriptionIndex, NULL, NULL);\n}\n\nGF_EXPORT\nu32 gf_isom_get_sample_duration(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tu32 dur;\n\tu64 dts;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !sampleNumber) return 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return 0;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\tstbl_GetSampleDTS_and_Duration(trak->Media->information->sampleTable->TimeToSample, sampleNumber, &dts, &dur);\n\treturn dur;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_sample_size(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tu32 size = 0;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !sampleNumber) return 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return 0;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tstbl_GetSampleSize(trak->Media->information->sampleTable->SampleSize, sampleNumber, &size);\n\treturn size;\n}\n\nGF_EXPORT\nu32 gf_isom_get_max_sample_size(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\n\treturn trak->Media->information->sampleTable->SampleSize->max_size;\n}\n\nGF_EXPORT\nu32 gf_isom_get_avg_sample_size(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\n\tif ( trak->Media->information->sampleTable->SampleSize->sampleSize)\n\t\treturn trak->Media->information->sampleTable->SampleSize->sampleSize;\n\n\tif (!trak->Media->information->sampleTable->SampleSize->total_samples) return 0;\n\treturn (u32) (trak->Media->information->sampleTable->SampleSize->total_size / trak->Media->information->sampleTable->SampleSize->total_samples);\n}\n\nGF_EXPORT\nu32 gf_isom_get_max_sample_delta(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->TimeToSample) return 0;\n\n\treturn trak->Media->information->sampleTable->TimeToSample->max_ts_delta;\n}\n\nGF_EXPORT\nu32 gf_isom_get_max_sample_cts_offset(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->CompositionOffset) return 0;\n\n\treturn trak->Media->information->sampleTable->CompositionOffset->max_ts_delta;\n}\n\n\nGF_EXPORT\nBool gf_isom_get_sample_sync(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tGF_ISOSAPType is_rap;\n\tGF_Err e;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !sampleNumber) return GF_FALSE;\n\n\tif (! trak->Media->information->sampleTable->SyncSample) return GF_TRUE;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return GF_FALSE;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\te = stbl_GetSampleRAP(trak->Media->information->sampleTable->SyncSample, sampleNumber, &is_rap, NULL, NULL);\n\tif (e) return GF_FALSE;\n\treturn is_rap ? GF_TRUE : GF_FALSE;\n}\n\n//same as gf_isom_get_sample but doesn't fetch media data\nGF_EXPORT\nGF_ISOSample *gf_isom_get_sample_info_ex(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, u64 *data_offset, GF_ISOSample *static_sample)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *samp;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\n\tif (!sampleNumber) return NULL;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return NULL;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tif (static_sample) {\n\t\tsamp = static_sample;\n\t} else {\n\t\tsamp = gf_isom_sample_new();\n\t\tif (!samp) return NULL;\n\t}\n\n\te = Media_GetSample(trak->Media, sampleNumber, &samp, sampleDescriptionIndex, GF_TRUE, data_offset);\n\tif (e) {\n\t\tgf_isom_set_last_error(the_file, e);\n\t\tif (!static_sample)\n\t\t\tgf_isom_sample_del(&samp);\n\t\treturn NULL;\n\t}\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (samp) samp->DTS += trak->dts_at_seg_start;\n#endif\n\treturn samp;\n}\n\nGF_EXPORT\nGF_ISOSample *gf_isom_get_sample_info(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, u64 *data_offset)\n{\n\treturn gf_isom_get_sample_info_ex(the_file, trackNumber, sampleNumber, sampleDescriptionIndex, data_offset, NULL);\n}\n\n\n//get sample dts\nGF_EXPORT\nu64 gf_isom_get_sample_dts(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tu64 dts;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\tif (!sampleNumber) return 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return 0;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tif (stbl_GetSampleDTS(trak->Media->information->sampleTable->TimeToSample, sampleNumber, &dts) != GF_OK) return 0;\n\treturn dts;\n}\n\nGF_EXPORT\nBool gf_isom_is_self_contained(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\treturn Media_IsSelfContained(trak->Media, sampleDescriptionIndex);\n}\n\n/*retrieves given sample DTS*/\nGF_EXPORT\nu32 gf_isom_get_sample_from_dts(GF_ISOFile *the_file, u32 trackNumber, u64 dts)\n{\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber;\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\tstbl = trak->Media->information->sampleTable;\n\n\te = stbl_findEntryForTime(stbl, dts, 1, &sampleNumber, &prevSampleNumber);\n\tif (e) return 0;\n\treturn sampleNumber;\n}\n\n\n//return a sample given a desired display time IN MEDIA TIME SCALE\n//and set the StreamDescIndex of this sample\n//this index allows to retrieve the stream description if needed (2 media in 1 track)\n//return NULL if error\n//WARNING: the sample may not be sync even though the sync was requested (depends on the media)\nGF_EXPORT\nGF_Err gf_isom_get_sample_for_media_time(GF_ISOFile *the_file, u32 trackNumber, u64 desiredTime, u32 *StreamDescriptionIndex, GF_ISOSearchMode SearchMode, GF_ISOSample **sample, u32 *SampleNum, u64 *data_offset)\n{\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber, syncNum, shadowSync;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *shadow;\n\tGF_SampleTableBox *stbl;\n\tBool static_sample = GF_FALSE;\n\tu8 useShadow, IsSync;\n\n\tif (SampleNum) *SampleNum = 0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (desiredTime < trak->dts_at_seg_start) {\n\t\tdesiredTime = 0;\n\t} else {\n\t\tdesiredTime -= trak->dts_at_seg_start;\n\t}\n#endif\n\n\te = stbl_findEntryForTime(stbl, desiredTime, 0, &sampleNumber, &prevSampleNumber);\n\tif (e) return e;\n\n\t//if no shadow table, reset to sync only\n\tuseShadow = 0;\n\tif (!stbl->ShadowSync && (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW))\n\t\tSearchMode = GF_ISOM_SEARCH_SYNC_BACKWARD;\n\n\t//if no syncTable, disable syncSearching, as all samples ARE sync\n\tif (! trak->Media->information->sampleTable->SyncSample) {\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_FORWARD) SearchMode = GF_ISOM_SEARCH_FORWARD;\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD) SearchMode = GF_ISOM_SEARCH_BACKWARD;\n\t}\n\n\t//not found, return EOF or browse backward\n\tif (!sampleNumber && !prevSampleNumber) {\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD || SearchMode == GF_ISOM_SEARCH_BACKWARD) {\n\t\t\tsampleNumber = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\t\t}\n\t\tif (!sampleNumber) return GF_EOS;\n\t}\n\n\t//check in case we have the perfect sample\n\tIsSync = 0;\n\n\t//according to the direction adjust the sampleNum value\n\tswitch (SearchMode) {\n\tcase GF_ISOM_SEARCH_SYNC_FORWARD:\n\t\tIsSync = 1;\n\tcase GF_ISOM_SEARCH_FORWARD:\n\t\t//not the exact one\n\t\tif (!sampleNumber) {\n\t\t\tif (prevSampleNumber != stbl->SampleSize->sampleCount) {\n\t\t\t\tsampleNumber = prevSampleNumber + 1;\n\t\t\t} else {\n\t\t\t\tsampleNumber = prevSampleNumber;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t//if dummy mode, reset to default browsing\n\tcase GF_ISOM_SEARCH_SYNC_BACKWARD:\n\t\tIsSync = 1;\n\tcase GF_ISOM_SEARCH_SYNC_SHADOW:\n\tcase GF_ISOM_SEARCH_BACKWARD:\n\tdefault:\n\t\t//first case, not found....\n\t\tif (!sampleNumber && !prevSampleNumber) {\n\t\t\tsampleNumber = stbl->SampleSize->sampleCount;\n\t\t} else if (!sampleNumber) {\n\t\t\tsampleNumber = prevSampleNumber;\n\t\t}\n\t\tbreak;\n\t}\n\n\t//get the sync sample num\n\tif (IsSync) {\n\t\t//get the SyncNumber\n\t\te = Media_FindSyncSample(trak->Media->information->sampleTable,\n\t\t                         sampleNumber, &syncNum, SearchMode);\n\t\tif (e) return e;\n\t\tif (syncNum) sampleNumber = syncNum;\n\t\tsyncNum = 0;\n\t}\n\t//if we are in shadow mode, get the previous sync sample\n\t//in case we can't find a good SyncShadow\n\telse if (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\n\t\t//get the SyncNumber\n\t\te = Media_FindSyncSample(trak->Media->information->sampleTable,\n\t\t                         sampleNumber, &syncNum, GF_ISOM_SEARCH_SYNC_BACKWARD);\n\t\tif (e) return e;\n\t}\n\n\n\t//OK sampleNumber is exactly the sample we need (except for shadow)\n\n\tif (sample) {\n\t\tif (*sample) {\n\t\t\tstatic_sample = GF_TRUE;\n\t\t} else {\n\t\t\t*sample = gf_isom_sample_new();\n\t\t\tif (*sample == NULL) return GF_OUT_OF_MEM;\n\t\t}\n\t}\n\t//we are in shadow mode, we need to browse both SyncSample and ShadowSyncSample to get\n\t//the desired sample...\n\tif (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\n\t\t//get the shadowing number\n\t\tstbl_GetSampleShadow(stbl->ShadowSync, &sampleNumber, &shadowSync);\n\t\t//now sampleNumber is the closest previous shadowed sample.\n\t\t//1- If we have a closer sync sample, use it.\n\t\t//2- if the shadowSync is 0, we don't have any shadowing, use syncNum\n\t\tif ((sampleNumber < syncNum) || (!shadowSync)) {\n\t\t\tsampleNumber = syncNum;\n\t\t} else {\n\t\t\t//otherwise, we have a better alternate sample in the shadowSync for this sample\n\t\t\tuseShadow = 1;\n\t\t}\n\t}\n\n\te = Media_GetSample(trak->Media, sampleNumber, sample, StreamDescriptionIndex, GF_FALSE, data_offset);\n\tif (e) {\n\t\tif (!static_sample)\n\t\t\tgf_isom_sample_del(sample);\n\t\telse if (! (*sample)->alloc_size && (*sample)->data && (*sample)->dataLength )\n\t\t \t(*sample)->alloc_size =  (*sample)->dataLength;\n\n\t\treturn e;\n\t}\n\tif (sample && ! (*sample)->IsRAP) {\n\t\tBool is_rap;\n\t\tGF_ISOSampleRollType roll_type;\n\t\te = gf_isom_get_sample_rap_roll_info(the_file, trackNumber, sampleNumber, &is_rap, &roll_type, NULL);\n\t\tif (e) return e;\n\t\tif (is_rap) (*sample)->IsRAP = SAP_TYPE_3;\n\t}\n\t//optionally get the sample number\n\tif (SampleNum) {\n\t\t*SampleNum = sampleNumber;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t*SampleNum += trak->sample_count_at_seg_start;\n#endif\n\t}\n\n\t//in shadow mode, we only get the data of the shadowing sample !\n\tif (sample && useShadow) {\n\t\t//we have to use StreamDescriptionIndex in case the sample data is in another desc\n\t\t//though this is unlikely as non optimized...\n\t\tshadow = gf_isom_get_sample(the_file, trackNumber, shadowSync, StreamDescriptionIndex);\n\t\t//if no sample, the shadowSync is broken, return the sample\n\t\tif (!shadow) return GF_OK;\n\t\t(*sample)->IsRAP = RAP;\n\t\tgf_free((*sample)->data);\n\t\t(*sample)->dataLength = shadow->dataLength;\n\t\t(*sample)->data = shadow->data;\n\t\t//set data length to 0 to keep the buffer alive...\n\t\tshadow->dataLength = 0;\n\t\tgf_isom_sample_del(&shadow);\n\t}\n\tif (static_sample && ! (*sample)->alloc_size )\n\t\t (*sample)->alloc_size =  (*sample)->dataLength;\n\t\t \n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_for_movie_time(GF_ISOFile *the_file, u32 trackNumber, u64 movieTime, u32 *StreamDescriptionIndex, GF_ISOSearchMode SearchMode, GF_ISOSample **sample, u32 *sampleNumber, u64 *data_offset)\n{\n\tDouble tsscale;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tu64 mediaTime, nextMediaTime;\n\ts64 segStartTime, mediaOffset;\n\tu32 sampNum;\n\tu8 useEdit;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//only check duration if initially set - do not check duration as updated after fragment merge since that duration does not take\n\t//into account tfdt\n\tif (trak->Header->initial_duration\n\t\t&& (movieTime * trak->moov->mvhd->timeScale > trak->Header->initial_duration * trak->Media->mediaHeader->timeScale)\n\t) {\n\t\tif (sampleNumber) *sampleNumber = 0;\n\t\t*StreamDescriptionIndex = 0;\n\t\treturn GF_EOS;\n\t}\n\n\t//get the media time for this movie time...\n\tmediaTime = segStartTime = 0;\n\t*StreamDescriptionIndex = 0;\n\tnextMediaTime = 0;\n\n\te = GetMediaTime(trak, (SearchMode==GF_ISOM_SEARCH_SYNC_FORWARD) ? GF_TRUE : GF_FALSE, movieTime, &mediaTime, &segStartTime, &mediaOffset, &useEdit, &nextMediaTime);\n\tif (e) return e;\n\n\t/*here we check if we were playing or not and return no sample in normal search modes*/\n\tif (useEdit && mediaOffset == -1) {\n\t\tif ((SearchMode==GF_ISOM_SEARCH_FORWARD) || (SearchMode==GF_ISOM_SEARCH_BACKWARD)) {\n\t\t\t/*get next sample time in MOVIE timescale*/\n\t\t\tif (SearchMode==GF_ISOM_SEARCH_FORWARD)\n\t\t\t\te = GetNextMediaTime(trak, movieTime, &mediaTime);\n\t\t\telse\n\t\t\t\te = GetPrevMediaTime(trak, movieTime, &mediaTime);\n\t\t\tif (e) return e;\n\t\t\treturn gf_isom_get_sample_for_movie_time(the_file, trackNumber, (u32) mediaTime, StreamDescriptionIndex, GF_ISOM_SEARCH_SYNC_FORWARD, sample, sampleNumber, data_offset);\n\t\t}\n\t\tif (sampleNumber) *sampleNumber = 0;\n\t\tif (sample) {\n\t\t\tif (! (*sample)) {\n\t\t\t\t*sample = gf_isom_sample_new();\n\t\t\t\tif (! *sample) return GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\t(*sample)->DTS = movieTime;\n\t\t\t(*sample)->dataLength = 0;\n\t\t\t(*sample)->CTS_Offset = 0;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\t/*dwell edit in non-sync mode, fetch next/prev sample depending on mode.\n\tOtherwise return the dwell entry*/\n\tif (useEdit==2) {\n\t\tif ((SearchMode==GF_ISOM_SEARCH_FORWARD) || (SearchMode==GF_ISOM_SEARCH_BACKWARD)) {\n\t\t\t/*get next sample time in MOVIE timescale*/\n\t\t\tif (SearchMode==GF_ISOM_SEARCH_FORWARD)\n\t\t\t\te = GetNextMediaTime(trak, movieTime, &mediaTime);\n\t\t\telse\n\t\t\t\te = GetPrevMediaTime(trak, movieTime, &mediaTime);\n\t\t\tif (e) return e;\n\t\t\treturn gf_isom_get_sample_for_movie_time(the_file, trackNumber, (u32) mediaTime, StreamDescriptionIndex, GF_ISOM_SEARCH_SYNC_FORWARD, sample, sampleNumber, data_offset);\n\t\t}\n\t}\n\n\ttsscale = trak->Media->mediaHeader->timeScale;\n\ttsscale /= trak->moov->mvhd->timeScale;\n\n\t//OK, we have a sample so fetch it\n\te = gf_isom_get_sample_for_media_time(the_file, trackNumber, mediaTime, StreamDescriptionIndex, SearchMode, sample, &sampNum, data_offset);\n\tif (e) {\n\t\tif (e==GF_EOS) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t//movie is fragmented and samples not yet received, return EOS\n\t\t\tif (the_file->moov->mvex && !trak->Media->information->sampleTable->SampleSize->sampleCount)\n\t\t\t\treturn e;\n#endif\n\n\t\t\tif (nextMediaTime && (nextMediaTime-1 != movieTime))\n\t\t\t\treturn gf_isom_get_sample_for_movie_time(the_file, trackNumber, nextMediaTime-1, StreamDescriptionIndex, SearchMode, sample, sampleNumber, data_offset);\n\t\t}\n\t\treturn e;\n\t}\n\n\t//OK, now the trick: we have to rebuild the time stamps, according\n\t//to the media time scale (used by SLConfig) - add the edit start time but stay in\n\t//the track TS\n\tif (sample && useEdit) {\n\t\tu64 _ts = (u64)(segStartTime * tsscale);\n\n\t\t(*sample)->DTS += _ts;\n\t\t/*watchout, the sample fetched may be before the first sample in the edit list (when seeking)*/\n\t\tif ( (*sample)->DTS > (u64) mediaOffset) {\n\t\t\t(*sample)->DTS -= (u64) mediaOffset;\n\t\t} else {\n\t\t\t(*sample)->DTS = 0;\n\t\t}\n\t}\n\tif (sampleNumber) *sampleNumber = sampNum;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sample && (*sample) ) (*sample)->DTS += trak->dts_at_seg_start;\n#endif\n\n\treturn GF_OK;\n}\n\n\n\nGF_EXPORT\nu64 gf_isom_get_missing_bytes(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\treturn trak->Media->BytesMissing;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_sample_padding(GF_ISOFile *the_file, u32 trackNumber, u32 padding_bytes)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrak->padding_bytes = padding_bytes;\n\treturn GF_OK;\n\n}\n\n//get the number of edited segment\nGF_EXPORT\nBool gf_isom_get_edit_list_type(GF_ISOFile *the_file, u32 trackNumber, s64 *mediaOffset)\n{\n\tGF_EdtsEntry *ent;\n\tGF_TrackBox *trak;\n\tu32 count;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\t*mediaOffset = 0;\n\tif (!trak->editBox || !trak->editBox->editList) return GF_FALSE;\n\n\tcount = gf_list_count(trak->editBox->editList->entryList);\n\tent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, 0);\n\tif (!ent) return GF_TRUE;\n\t/*mediaRate>0, the track playback shall start at media time>0 -> mediaOffset is < 0 */\n\tif ((count==1) && (ent->mediaRate == 0x10000)) {\n\t\t*mediaOffset = - ent->mediaTime;\n\t\treturn GF_FALSE;\n\t} else if (count==2) {\n\t\t/*mediaRate==-1, the track playback shall be empty for segmentDuration -> mediaOffset is > 0 */\n\t\tif ((ent->mediaRate == -0x10000) || (ent->mediaTime==-1)) {\n\t\t\tDouble time = (Double) ent->segmentDuration;\n\t\t\ttime /= trak->moov->mvhd->timeScale;\n\t\t\ttime *= trak->Media->mediaHeader->timeScale;\n\t\t\t*mediaOffset = (s64) time;\n\n\t\t\t//check next entry, if we start from mediaOffset > 0 this may still result in a skip\n\t\t\tent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, 1);\n\t\t\t//next entry playback rate is not nominal, we need edit list handling\n\t\t\tif (ent->mediaRate != 0x10000)\n\t\t\t\treturn GF_TRUE;\n\n\t\t\tif (ent->mediaTime > 0) {\n\t\t\t\t*mediaOffset -= ent->mediaTime;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\n\n//get the number of edited segment\nGF_EXPORT\nu32 gf_isom_get_edits_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\tif (!trak->editBox || !trak->editBox->editList) return 0;\n\treturn gf_list_count(trak->editBox->editList->entryList);\n}\n\n\n//Get the desired segment information\nGF_EXPORT\nGF_Err gf_isom_get_edit(GF_ISOFile *the_file, u32 trackNumber, u32 SegmentIndex, u64 *EditTime, u64 *SegmentDuration, u64 *MediaTime, GF_ISOEditType *EditMode)\n{\n\tu32 i;\n\tu64 startTime;\n\tGF_TrackBox *trak;\n\tGF_EditListBox *elst;\n\tGF_EdtsEntry *ent;\n\n\tent = NULL;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->editBox ||\n\t        !trak->editBox->editList ||\n\t        (SegmentIndex > gf_list_count(trak->editBox->editList->entryList)) ||\n\t        !SegmentIndex)\n\t\treturn GF_BAD_PARAM;\n\n\telst = trak->editBox->editList;\n\tstartTime = 0;\n\n\tfor (i = 0; i < SegmentIndex; i++) {\n\t\tent = (GF_EdtsEntry*)gf_list_get(elst->entryList, i);\n\t\tif (i < SegmentIndex-1) startTime += ent->segmentDuration;\n\t}\n\t*EditTime = startTime;\n\t*SegmentDuration = ent->segmentDuration;\n\tif (ent->mediaTime < 0) {\n\t\t*MediaTime = 0;\n\t\t*EditMode = GF_ISOM_EDIT_EMPTY;\n\t\treturn GF_OK;\n\t}\n\tif (ent->mediaRate == 0) {\n\t\t*MediaTime = ent->mediaTime;\n\t\t*EditMode = GF_ISOM_EDIT_DWELL;\n\t\treturn GF_OK;\n\t}\n\t*MediaTime = ent->mediaTime;\n\t*EditMode = GF_ISOM_EDIT_NORMAL;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu8 gf_isom_has_sync_points(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable) return 0;\n\tif (trak->Media->information->sampleTable->SyncSample) {\n\t\tif (!trak->Media->information->sampleTable->SyncSample->nb_entries) return 2;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*returns number of sync points*/\nGF_EXPORT\nu32 gf_isom_get_sync_point_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\tif (trak->Media->information->sampleTable->SyncSample) {\n\t\treturn trak->Media->information->sampleTable->SyncSample->nb_entries;\n\t}\n\treturn 0;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_get_brand_info(GF_ISOFile *movie, u32 *brand, u32 *minorVersion, u32 *AlternateBrandsCount)\n{\n\tif (!movie) return GF_BAD_PARAM;\n\tif (!movie->brand) {\n\t\tif (brand) *brand = GF_ISOM_BRAND_ISOM;\n\t\tif (minorVersion) *minorVersion = 1;\n\t\tif (AlternateBrandsCount) *AlternateBrandsCount = 0;\n\t\treturn GF_OK;\n\t}\n\n\tif (brand) *brand = movie->brand->majorBrand;\n\tif (minorVersion) *minorVersion = movie->brand->minorVersion;\n\tif (AlternateBrandsCount) *AlternateBrandsCount = movie->brand->altCount;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_alternate_brand(GF_ISOFile *movie, u32 BrandIndex, u32 *brand)\n{\n\tif (!movie || !movie->brand || !brand) return GF_BAD_PARAM;\n\tif (BrandIndex > movie->brand->altCount || !BrandIndex) return GF_BAD_PARAM;\n\t*brand = movie->brand->altBrand[BrandIndex-1];\n\treturn GF_OK;\n}\n\nGF_EXPORT\nconst u32 *gf_isom_get_brands(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->brand) return NULL;\n\treturn movie->brand->altBrand;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_padding_bits(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u8 *NbBits)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\t//Padding info\n\treturn stbl_GetPaddingBits(trak->Media->information->sampleTable->PaddingBits,\n\t                           sampleNumber, NbBits);\n\n}\n\n\nGF_EXPORT\nBool gf_isom_has_padding_bits(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\n\tif (trak->Media->information->sampleTable->PaddingBits) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_get_udta_count(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tif (!movie || !movie->moov) return 0;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return 0;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (udta) return gf_list_count(udta->recordList);\n\treturn 0;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_udta_type(GF_ISOFile *movie, u32 trackNumber, u32 udta_idx, u32 *UserDataType, bin128 *UUID)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tif (!movie || !movie->moov || !udta_idx) return GF_BAD_PARAM;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_OK;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_BAD_PARAM;\n\tif (udta_idx>gf_list_count(udta->recordList)) return GF_BAD_PARAM;\n\tmap = (GF_UserDataMap*)gf_list_get(udta->recordList, udta_idx - 1);\n\tif (UserDataType) *UserDataType = map->boxType;\n\tif (UUID) memcpy(*UUID, map->uuid, 16);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_isom_get_user_data_count(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID)\n{\n\tGF_UserDataMap *map;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tbin128 t;\n\tu32 i, count;\n\n\tif (!movie || !movie->moov) return 0;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return 0;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return 0;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tcount = gf_list_count(map->boxes);\n\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && !memcmp(map->uuid, UUID, 16)) return count;\n\t\telse if (map->boxType == UserDataType) return count;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID, u32 UserDataIndex, u8 **userData, u32 *userDataSize)\n{\n\tGF_UserDataMap *map;\n\tGF_UnknownBox *ptr;\n\tGF_BitStream *bs;\n\tu32 i;\n\tbin128 t;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_BAD_PARAM;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (!userData || !userDataSize || *userData) return GF_BAD_PARAM;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && !memcmp(map->uuid, UUID, 16)) goto found;\n\t\telse if (map->boxType == UserDataType) goto found;\n\n\t}\n\treturn GF_BAD_PARAM;\n\nfound:\n\tif (UserDataIndex) {\n\t\tif (UserDataIndex > gf_list_count(map->boxes) ) return GF_BAD_PARAM;\n\t\tptr = (GF_UnknownBox*)gf_list_get(map->boxes, UserDataIndex-1);\n\n\t\tif (ptr->type == GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\t*userData = (char *)gf_malloc(sizeof(char)*ptr->dataSize);\n\t\t\tif (!*userData) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(*userData, ptr->data, sizeof(char)*ptr->dataSize);\n\t\t\t*userDataSize = ptr->dataSize;\n\t\t\treturn GF_OK;\n\t\t} else if (ptr->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tGF_UnknownUUIDBox *p_uuid = (GF_UnknownUUIDBox *)ptr;\n\t\t\t*userData = (char *)gf_malloc(sizeof(char)*p_uuid->dataSize);\n\t\t\tif (!*userData) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(*userData, p_uuid->data, sizeof(char)*p_uuid->dataSize);\n\t\t\t*userDataSize = p_uuid->dataSize;\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\tchar *str = NULL;\n\t\t\tswitch (ptr->type) {\n\t\t\tcase GF_ISOM_BOX_TYPE_NAME:\n\t\t\t//case GF_QT_BOX_TYPE_NAME: same as above\n\t\t\t\tstr = ((GF_NameBox *)ptr)->string;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_BOX_TYPE_KIND:\n\t\t\t\tstr = ((GF_KindBox *)ptr)->value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (str) {\n\t\t\t\tu32 len = (u32) strlen(str) + 1;\n\t\t\t\t*userData = (char *)gf_malloc(sizeof(char) * len);\n\t\t\t\tif (!*userData) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(*userData, str, sizeof(char)*len);\n\t\t\t\t*userDataSize = len;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t}\n\n\t//serialize all boxes\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\ti=0;\n\twhile ( (ptr = (GF_UnknownBox*)gf_list_enum(map->boxes, &i))) {\n\t\tu32 type, s, data_size;\n\t\tchar *data=NULL;\n\t\tif (ptr->type == GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\ttype = ptr->original_4cc;\n\t\t\tdata_size = ptr->dataSize;\n\t\t\tdata = ptr->data;\n\t\t} else if (ptr->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tGF_UnknownUUIDBox *p_uuid = (GF_UnknownUUIDBox *)ptr;\n\t\t\ttype = p_uuid->type;\n\t\t\tdata_size = p_uuid->dataSize;\n\t\t\tdata = p_uuid->data;\n\t\t} else {\n\t\t\tgf_isom_box_write((GF_Box *)ptr, bs);\n\t\t\tcontinue;\n\t\t}\n\t\ts = data_size+8;\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_UUID) s += 16;\n\n\t\tgf_bs_write_u32(bs, s);\n\t\tgf_bs_write_u32(bs, type);\n\t\tif (type==GF_ISOM_BOX_TYPE_UUID) gf_bs_write_data(bs, (char *) map->uuid, 16);\n\t\tif (data) {\n\t\t\tgf_bs_write_data(bs, data, data_size);\n\t\t} else if (ptr->child_boxes) {\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\t\tgf_isom_box_array_write((GF_Box *)ptr, ptr->child_boxes, bs);\n#else\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"ISOBMF: udta is a box-list - cannot export in read-only version of libisom in GPAC\\n\" ));\n#endif\n\t\t}\n\t}\n\tgf_bs_get_content(bs, userData, userDataSize);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_isom_delete(GF_ISOFile *movie)\n{\n\t//free and return;\n\tgf_isom_delete_movie(movie);\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_chunks_infos(GF_ISOFile *movie, u32 trackNumber, u32 *dur_min, u32 *dur_avg, u32 *dur_max, u32 *size_min, u32 *size_avg, u32 *size_max)\n{\n\tGF_TrackBox *trak;\n\tu32 i, k, sample_idx, dmin, dmax, smin, smax, tot_chunks;\n\tu64 davg, savg;\n\tGF_SampleToChunkBox *stsc;\n\tGF_TimeToSampleBox *stts;\n\tif (!movie || !trackNumber || !movie->moov) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsc = trak->Media->information->sampleTable->SampleToChunk;\n\tstts = trak->Media->information->sampleTable->TimeToSample;\n\tif (!stsc || !stts) return GF_ISOM_INVALID_FILE;\n\n\tdmin = smin = (u32) -1;\n\tdmax = smax = 0;\n\tdavg = savg = 0;\n\tsample_idx = 1;\n\ttot_chunks = 0;\n\tfor (i=0; i<stsc->nb_entries; i++) {\n\t\tu32 nb_chunk = 0;\n\t\tif (stsc->entries[i].samplesPerChunk >  2*trak->Media->information->sampleTable->SampleSize->sampleCount) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] likely broken stco entry (%u samples per chunk but %u samples total)\\n\", stsc->entries[i].samplesPerChunk, trak->Media->information->sampleTable->SampleSize->sampleCount));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\twhile (1) {\n\t\t\tu32 chunk_dur = 0;\n\t\t\tu32 chunk_size = 0;\n\t\t\tfor (k=0; k<stsc->entries[i].samplesPerChunk; k++) {\n\t\t\t\tu64 dts;\n\t\t\t\tu32 dur;\n\t\t\t\tu32 size;\n\t\t\t\tstbl_GetSampleDTS_and_Duration(stts, k+sample_idx, &dts, &dur);\n\t\t\t\tchunk_dur += dur;\n\t\t\t\tstbl_GetSampleSize(trak->Media->information->sampleTable->SampleSize, k+sample_idx, &size);\n\t\t\t\tchunk_size += size;\n\n\t\t\t}\n\t\t\tif (dmin>chunk_dur) dmin = chunk_dur;\n\t\t\tif (dmax<chunk_dur) dmax = chunk_dur;\n\t\t\tdavg += chunk_dur;\n\t\t\tif (smin>chunk_size) smin = chunk_size;\n\t\t\tif (smax<chunk_size) smax = chunk_size;\n\t\t\tsavg += chunk_size;\n\n\t\t\ttot_chunks ++;\n\t\t\tsample_idx += stsc->entries[i].samplesPerChunk;\n\t\t\tif (i+1==stsc->nb_entries) break;\n\t\t\tnb_chunk ++;\n\t\t\tif (stsc->entries[i].firstChunk + nb_chunk == stsc->entries[i+1].firstChunk) break;\n\t\t}\n\t}\n\tif (tot_chunks) {\n\t\tdavg /= tot_chunks;\n\t\tsavg /= tot_chunks;\n\t}\n\tif (dur_min) *dur_min = dmin;\n\tif (dur_avg) *dur_avg = (u32) davg;\n\tif (dur_max) *dur_max = dmax;\n\n\tif (size_min) *size_min = smin;\n\tif (size_avg) *size_avg = (u32) savg;\n\tif (size_max) *size_max = smax;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_fragment_defaults(GF_ISOFile *the_file, u32 trackNumber,\n                                     u32 *defaultDuration, u32 *defaultSize, u32 *defaultDescriptionIndex,\n                                     u32 *defaultRandomAccess, u8 *defaultPadding, u16 *defaultDegradationPriority)\n{\n\tGF_TrackBox *trak;\n\tGF_StscEntry *sc_ent;\n\tu32 i, j, maxValue, value;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackExtendsBox *trex;\n#endif\n\tGF_SampleTableBox *stbl;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t/*if trex is already set, restore flags*/\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\ttrex = the_file->moov->mvex ? GetTrex(the_file->moov, gf_isom_get_track_id(the_file,trackNumber) ) : NULL;\n\tif (trex) {\n\t\ttrex->track = trak;\n\n\t\tif (defaultDuration) *defaultDuration = trex->def_sample_duration;\n\t\tif (defaultSize) *defaultSize = trex->def_sample_size;\n\t\tif (defaultDescriptionIndex) *defaultDescriptionIndex = trex->def_sample_desc_index;\n\t\tif (defaultRandomAccess) *defaultRandomAccess = GF_ISOM_GET_FRAG_SYNC(trex->def_sample_flags);\n\t\tif (defaultPadding) *defaultPadding = GF_ISOM_GET_FRAG_PAD(trex->def_sample_flags);\n\t\tif (defaultDegradationPriority) *defaultDegradationPriority = GF_ISOM_GET_FRAG_DEG(trex->def_sample_flags);\n\t\treturn GF_OK;\n\t}\n#endif\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl->TimeToSample || !stbl->SampleSize || !stbl->SampleToChunk) return GF_ISOM_INVALID_FILE;\n\n\n\t//duration\n\tif (defaultDuration) {\n\t\tmaxValue = value = 0;\n\t\tfor (i=0; i<stbl->TimeToSample->nb_entries; i++) {\n\t\t\tif (stbl->TimeToSample->entries[i].sampleCount>maxValue) {\n\t\t\t\tvalue = stbl->TimeToSample->entries[i].sampleDelta;\n\t\t\t\tmaxValue = stbl->TimeToSample->entries[i].sampleCount;\n\t\t\t}\n\t\t}\n\t\t*defaultDuration = value;\n\t}\n\t//size\n\tif (defaultSize) {\n\t\t*defaultSize = stbl->SampleSize->sampleSize;\n\t}\n\t//descIndex\n\tif (defaultDescriptionIndex) {\n\t\tGF_SampleToChunkBox *stsc= stbl->SampleToChunk;\n\t\tmaxValue = value = 0;\n\t\tfor (i=0; i<stsc->nb_entries; i++) {\n\t\t\tsc_ent = &stsc->entries[i];\n\t\t\tif ((sc_ent->nextChunk - sc_ent->firstChunk) * sc_ent->samplesPerChunk > maxValue) {\n\t\t\t\tvalue = sc_ent->sampleDescriptionIndex;\n\t\t\t\tmaxValue = (sc_ent->nextChunk - sc_ent->firstChunk) * sc_ent->samplesPerChunk;\n\t\t\t}\n\t\t}\n\t\t*defaultDescriptionIndex = value ? value : 1;\n\t}\n\t//RAP\n\tif (defaultRandomAccess) {\n\t\t//no sync table is ALL RAP\n\t\t*defaultRandomAccess = stbl->SyncSample ? 0 : 1;\n\t\tif (stbl->SyncSample\n\t\t        && (stbl->SyncSample->nb_entries == stbl->SampleSize->sampleCount)) {\n\t\t\t*defaultRandomAccess = 1;\n\t\t}\n\t}\n\t//defaultPadding\n\tif (defaultPadding) {\n\t\t*defaultPadding = 0;\n\t\tif (stbl->PaddingBits) {\n\t\t\tmaxValue = 0;\n\t\t\tfor (i=0; i<stbl->PaddingBits->SampleCount; i++) {\n\t\t\t\tvalue = 0;\n\t\t\t\tfor (j=0; j<stbl->PaddingBits->SampleCount; j++) {\n\t\t\t\t\tif (stbl->PaddingBits->padbits[i]==stbl->PaddingBits->padbits[j]) {\n\t\t\t\t\t\tvalue ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (value>maxValue) {\n\t\t\t\t\tmaxValue = value;\n\t\t\t\t\t*defaultPadding = stbl->PaddingBits->padbits[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//defaultDegradationPriority\n\tif (defaultDegradationPriority) {\n\t\t*defaultDegradationPriority = 0;\n\t\tif (stbl->DegradationPriority) {\n\t\t\tmaxValue = 0;\n\t\t\tfor (i=0; i<stbl->DegradationPriority->nb_entries; i++) {\n\t\t\t\tvalue = 0;\n\t\t\t\tfor (j=0; j<stbl->DegradationPriority->nb_entries; j++) {\n\t\t\t\t\tif (stbl->DegradationPriority->priorities[i]==stbl->DegradationPriority->priorities[j]) {\n\t\t\t\t\t\tvalue ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (value>maxValue) {\n\t\t\t\t\tmaxValue = value;\n\t\t\t\t\t*defaultDegradationPriority = stbl->DegradationPriority->priorities[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_refresh_fragmented(GF_ISOFile *movie, u64 *MissingBytes, const char *new_location)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn GF_NOT_SUPPORTED;\n#else\n\tu64 prevsize, size;\n\tu32 i;\n\tif (!movie || !movie->movieFileMap || !movie->moov) return GF_BAD_PARAM;\n\tif (movie->openMode != GF_ISOM_OPEN_READ) return GF_BAD_PARAM;\n\n\t/*refresh size*/\n\tsize = movie->movieFileMap ? gf_bs_get_size(movie->movieFileMap->bs) : 0;\n\n\tif (new_location) {\n\t\tBool delete_map;\n\t\tGF_DataMap *previous_movie_fileMap_address = movie->movieFileMap;\n\t\tGF_Err e;\n\n\t\te = gf_isom_datamap_new(new_location, NULL, GF_ISOM_DATA_MAP_READ_ONLY, &movie->movieFileMap);\n\t\tif (e) {\n\t\t\tmovie->movieFileMap = previous_movie_fileMap_address;\n\t\t\treturn e;\n\t\t}\n\n\t\tdelete_map = (previous_movie_fileMap_address != NULL ? GF_TRUE: GF_FALSE);\n\t\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(movie->moov->trackList, i);\n\t\t\tif (trak->Media->information->dataHandler == previous_movie_fileMap_address) {\n\t\t\t\t//reaasign for later destruction\n\t\t\t\ttrak->Media->information->scalableDataHandler = movie->movieFileMap;\n\t\t\t\t//reassign for Media_GetSample function\n\t\t\t\ttrak->Media->information->dataHandler = movie->movieFileMap;\n\t\t\t} else if (trak->Media->information->scalableDataHandler == previous_movie_fileMap_address) {\n\t\t\t\tdelete_map = GF_FALSE;\n\t\t\t}\n\t\t}\n\t\tif (delete_map) {\n\t\t\tgf_isom_datamap_del(previous_movie_fileMap_address);\n\t\t}\n\t}\n\n\tprevsize = gf_bs_get_refreshed_size(movie->movieFileMap->bs);\n\tif (prevsize==size) return GF_OK;\n\n\tif (!movie->moov->mvex)\n\t\treturn GF_OK;\n\n\t//ok parse root boxes\n\treturn gf_isom_parse_movie_boxes(movie, NULL, MissingBytes, GF_TRUE);\n#endif\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nGF_EXPORT\nvoid gf_isom_set_single_moof_mode(GF_ISOFile *movie, Bool mode)\n{\n\tmovie->single_moof_mode = mode;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_reset_data_offset(GF_ISOFile *movie, u64 *top_box_start)\n{\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i, count;\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\tif (top_box_start) *top_box_start = movie->current_top_box_start;\n\tmovie->current_top_box_start = 0;\n\tmovie->NextMoofNumber = 0;\n\tif (movie->moov->mvex && movie->single_moof_mode) {\n\t\tmovie->single_moof_state = 0;\n\t}\n\tcount = gf_list_count(movie->moov->trackList);\n\tfor (i=0; i<count; i++) {\n\t\tGF_TrackBox *tk = gf_list_get(movie->moov->trackList, i);\n\t\ttk->first_traf_merged = GF_FALSE;\n\t}\n#endif\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_current_top_box_offset(GF_ISOFile *movie, u64 *current_top_box_offset)\n{\n\tif (!movie || !movie->moov || !current_top_box_offset) return GF_BAD_PARAM;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t*current_top_box_offset = movie->current_top_box_start;\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_removed_bytes(GF_ISOFile *movie, u64 bytes_removed)\n{\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\tmovie->bytes_removed = bytes_removed;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_purge_samples(GF_ISOFile *the_file, u32 trackNumber, u32 nb_samples)\n{\n\tGF_TrackBox *trak;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_Err e;\n\tGF_TrackExtendsBox *trex;\n\tGF_SampleTableBox *stbl;\n#endif\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t/*if trex is already set, restore flags*/\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\ttrex = the_file->moov->mvex ? GetTrex(the_file->moov, gf_isom_get_track_id(the_file,trackNumber) ) : NULL;\n\tif (!trex) return GF_BAD_PARAM;\n\n\t//first unpack chunk offsets and CTS\n\te = stbl_UnpackOffsets(trak->Media->information->sampleTable);\n\tif (e) return e;\n\te = stbl_unpackCTS(trak->Media->information->sampleTable);\n\tif (e) return e;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl->TimeToSample || !stbl->SampleSize || !stbl->SampleToChunk) return GF_ISOM_INVALID_FILE;\n\n\t//remove at once nb_samples in stts, ctts, stsz, stco, stsc and stdp (n-times removal is way too slow)\n\t//do NOT change the order DTS, CTS, size chunk\n\tstbl_RemoveDTS(stbl, 1, nb_samples, 0);\n\tstbl_RemoveCTS(stbl, 1, nb_samples);\n\tstbl_RemoveSize(stbl, 1, nb_samples);\n\tstbl_RemoveChunk(stbl, 1, nb_samples);\n\tstbl_RemoveRedundant(stbl, 1, nb_samples);\n\n\t//then remove sample per sample for the rest, which is either\n\t//- sparse data\n\t//- allocated structure rather than memmove-able array\n\t//- not very frequent info (paddind bits)\n\twhile (nb_samples) {\n\t\tstbl_RemoveRAP(stbl, 1);\n\t\tstbl_RemoveShadow(stbl, 1);\n\t\tstbl_RemoveSubSample(stbl, 1);\n\t\tstbl_RemovePaddingBits(stbl, 1);\n\t\tstbl_RemoveSampleGroup(stbl, 1);\n\t\tnb_samples--;\n\t}\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\n\n#define RECREATE_BOX(_a, __cast)\t\\\n    if (_a) {\t\\\n        type = _a->type;\\\n        gf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *)_a);\\\n        _a = __cast gf_isom_box_new_parent(&stbl->child_boxes, type);\\\n    }\\\n\n\nGF_EXPORT\nGF_Err gf_isom_reset_tables(GF_ISOFile *movie, Bool reset_sample_count)\n{\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i, j;\n\n\tif (!movie || !movie->moov || !movie->moov->mvex) return GF_BAD_PARAM;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_Box *a;\n\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(movie->moov->trackList, i);\n\n\t\tu32 type, dur;\n\t\tu64 dts;\n\t\tGF_SampleTableBox *stbl = trak->Media->information->sampleTable;\n\n\t\ttrak->sample_count_at_seg_start += stbl->SampleSize->sampleCount;\n\t\tif (trak->sample_count_at_seg_start) {\n\t\t\tGF_Err e;\n\t\t\te = stbl_GetSampleDTS_and_Duration(stbl->TimeToSample, stbl->SampleSize->sampleCount, &dts, &dur);\n\t\t\tif (e == GF_OK) {\n\t\t\t\ttrak->dts_at_seg_start += dts + dur;\n\t\t\t}\n\t\t}\n\n\t\tRECREATE_BOX(stbl->ChunkOffset, (GF_Box *));\n\t\tRECREATE_BOX(stbl->CompositionOffset, (GF_CompositionOffsetBox *));\n\t\tRECREATE_BOX(stbl->DegradationPriority, (GF_DegradationPriorityBox *));\n\t\tRECREATE_BOX(stbl->PaddingBits, (GF_PaddingBitsBox *));\n\t\tRECREATE_BOX(stbl->SampleDep, (GF_SampleDependencyTypeBox *));\n\t\tRECREATE_BOX(stbl->SampleSize, (GF_SampleSizeBox *));\n\t\tRECREATE_BOX(stbl->SampleToChunk, (GF_SampleToChunkBox *));\n\t\tRECREATE_BOX(stbl->ShadowSync, (GF_ShadowSyncBox *));\n\t\tRECREATE_BOX(stbl->SyncSample, (GF_SyncSampleBox *));\n\t\tRECREATE_BOX(stbl->TimeToSample, (GF_TimeToSampleBox *));\n\n\t\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sai_offsets);\n\t\tstbl->sai_offsets = NULL;\n\n\t\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sai_sizes);\n\t\tstbl->sai_sizes = NULL;\n\n\t\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sampleGroups);\n\t\tstbl->sampleGroups = NULL;\n\n\t\tj = stbl->nb_sgpd_in_stbl;\n\t\twhile ((a = (GF_Box *)gf_list_enum(stbl->sampleGroupsDescription, &j))) {\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\tj--;\n\t\t\tgf_list_rem(stbl->sampleGroupsDescription, j);\n\t\t}\n\n#if 0\n\t\tj = stbl->nb_stbl_boxes;\n\t\twhile ((a = (GF_Box *)gf_list_enum(stbl->child_boxes, &j))) {\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\tj--;\n\t\t}\n#endif\n\n\t\tif (reset_sample_count) {\n\t\t\ttrak->Media->information->sampleTable->SampleSize->sampleCount = 0;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\ttrak->sample_count_at_seg_start = 0;\n\t\t\ttrak->dts_at_seg_start = 0;\n\t\t\ttrak->first_traf_merged = GF_FALSE;\n#endif\n\t\t}\n\n\t}\n\tif (reset_sample_count) {\n\t\tmovie->NextMoofNumber = 0;\n\t}\n#endif\n\treturn GF_OK;\n\n}\n\nGF_EXPORT\nGF_Err gf_isom_release_segment(GF_ISOFile *movie, Bool reset_tables)\n{\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i, j, base_track_sample_count;\n\tBool has_scalable;\n\tGF_Box *a;\n\tif (!movie || !movie->moov || !movie->moov->mvex) return GF_BAD_PARAM;\n\thas_scalable = gf_isom_needs_layer_reconstruction(movie);\n\tbase_track_sample_count = 0;\n\tmovie->moov->compressed_diff = 0;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\ttrak->first_traf_merged = GF_FALSE;\n\t\tif (trak->Media->information->dataHandler == movie->movieFileMap) {\n\t\t\ttrak->Media->information->dataHandler = NULL;\n\t\t}\n\t\tif (trak->Media->information->scalableDataHandler == movie->movieFileMap) {\n\t\t\ttrak->Media->information->scalableDataHandler = NULL;\n\t\t} else {\n\t\t\tif (trak->Media->information->scalableDataHandler==trak->Media->information->dataHandler)\n\t\t\t\ttrak->Media->information->dataHandler = NULL;\n\n\t\t\tgf_isom_datamap_del(trak->Media->information->scalableDataHandler);\n\t\t\ttrak->Media->information->scalableDataHandler = NULL;\n\t\t}\n\n\n\t\tif (reset_tables) {\n\t\t\tu32 type, dur;\n\t\t\tu64 dts;\n\t\t\tGF_SampleTableBox *stbl = trak->Media->information->sampleTable;\n\n\t\t\tif (has_scalable) {\n\t\t\t\t//check if the base reference is in the file - if not, do not consider the track is scalable.\n\t\t\t\tif (gf_isom_get_reference_count(movie, i+1, GF_ISOM_REF_BASE) > 0) {\n\t\t\t\t\tu32 on_track=0;\n\t\t\t\t\tGF_TrackBox *base;\n\t\t\t\t\tgf_isom_get_reference(movie, i+1, GF_ISOM_REF_BASE, 1, &on_track);\n\n\t\t\t\t\tbase = gf_isom_get_track_from_file(movie, on_track);\n\t\t\t\t\tif (!base) {\n\t\t\t\t\t\tbase_track_sample_count=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbase_track_sample_count = base->Media->information->sampleTable->SampleSize->sampleCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttrak->sample_count_at_seg_start += base_track_sample_count ? base_track_sample_count : stbl->SampleSize->sampleCount;\n\n\t\t\tif (trak->sample_count_at_seg_start) {\n\t\t\t\tGF_Err e;\n\t\t\t\te = stbl_GetSampleDTS_and_Duration(stbl->TimeToSample, stbl->SampleSize->sampleCount, &dts, &dur);\n\t\t\t\tif (e == GF_OK) {\n\t\t\t\t\ttrak->dts_at_seg_start += dts + dur;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRECREATE_BOX(stbl->ChunkOffset, (GF_Box *));\n\t\t\tRECREATE_BOX(stbl->CompositionOffset, (GF_CompositionOffsetBox *));\n\t\t\tRECREATE_BOX(stbl->DegradationPriority, (GF_DegradationPriorityBox *));\n\t\t\tRECREATE_BOX(stbl->PaddingBits, (GF_PaddingBitsBox *));\n\t\t\tRECREATE_BOX(stbl->SampleDep, (GF_SampleDependencyTypeBox *));\n\t\t\tRECREATE_BOX(stbl->SampleSize, (GF_SampleSizeBox *));\n\t\t\tRECREATE_BOX(stbl->SampleToChunk, (GF_SampleToChunkBox *));\n\t\t\tRECREATE_BOX(stbl->ShadowSync, (GF_ShadowSyncBox *));\n\t\t\tRECREATE_BOX(stbl->SyncSample, (GF_SyncSampleBox *));\n\t\t\tRECREATE_BOX(stbl->TimeToSample, (GF_TimeToSampleBox *));\n\n\t\t\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sai_offsets);\n\t\t\tstbl->sai_offsets = NULL;\n\n\t\t\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sai_sizes);\n\t\t\tstbl->sai_sizes = NULL;\n\n\t\t\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sampleGroups);\n\t\t\tstbl->sampleGroups = NULL;\n\n\t\t\tif (trak->sample_encryption) {\n\t\t\t\tif (trak->Media->information->sampleTable->child_boxes) {\n\t\t\t\t\tgf_list_del_item(trak->Media->information->sampleTable->child_boxes, trak->sample_encryption);\n\t\t\t\t}\n\t\t\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box*)trak->sample_encryption);\n\t\t\t\ttrak->sample_encryption = NULL;\n\t\t\t}\n\n\t\t\tj = stbl->nb_sgpd_in_stbl;\n\t\t\twhile ((a = (GF_Box *)gf_list_enum(stbl->sampleGroupsDescription, &j))) {\n\t\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\t\tj--;\n\t\t\t\tgf_list_rem(stbl->sampleGroupsDescription, j);\n\t\t\t}\n\n\t\t\tif (stbl->traf_map) {\n\t\t\t\tfor (j=0; j<stbl->traf_map->nb_entries; j++) {\n\t\t\t\t\tif (stbl->traf_map->frag_starts[j].moof_template)\n\t\t\t\t\t\tgf_free(stbl->traf_map->frag_starts[j].moof_template);\n\t\t\t\t}\n\t\t\t\tmemset(stbl->traf_map->frag_starts, 0, sizeof(GF_TrafMapEntry)*stbl->traf_map->nb_alloc);\n\t\t\t\tstbl->traf_map->nb_entries = 0;\n\t\t\t}\n\n#if 0 // TO CHECK\n\t\t\tj = ptr->nb_stbl_boxes;\n\t\t\twhile ((a = (GF_Box *)gf_list_enum(stbl->child_boxes, &j))) {\n\t\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\t\tj--;\n\t\t\t}\n#endif\n\t\t}\n\n\n\t\tj = 0;\n\t\twhile ((a = (GF_Box *)gf_list_enum(movie->moov->child_boxes, &j))) {\n\t\t\tif (a->type == GF_ISOM_BOX_TYPE_PSSH) {\n\t\t\t\tgf_isom_box_del_parent(&movie->moov->child_boxes, a);\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t}\n\n\tgf_isom_datamap_del(movie->movieFileMap);\n\tmovie->movieFileMap = NULL;\n#endif\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_open_segment(GF_ISOFile *movie, const char *fileName, u64 start_range, u64 end_range, GF_ISOSegOpenMode flags)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn GF_NOT_SUPPORTED;\n#else\n\tu64 MissingBytes;\n\tGF_Err e;\n\tu32 i;\n\tBool segment_map_assigned = GF_FALSE;\n\tBool is_scalable_segment = (flags & GF_ISOM_SEGMENT_SCALABLE_FLAG) ? GF_TRUE : GF_FALSE;\n\tBool no_order_check = (flags & GF_ISOM_SEGMENT_NO_ORDER_FLAG) ? GF_TRUE: GF_FALSE;\n\tGF_DataMap *tmp = NULL;\n\tGF_DataMap *orig_file_map = NULL;\n\tif (!movie || !movie->moov || !movie->moov->mvex) return GF_BAD_PARAM;\n\tif (movie->openMode != GF_ISOM_OPEN_READ) return GF_BAD_PARAM;\n\n\t/*this is a scalable segment - use a temp data map for the associated track(s) but do NOT touch the movie file map*/\n\tif (is_scalable_segment) {\n\t\ttmp = NULL;\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_READ_ONLY, &tmp);\n\t\tif (e) return e;\n\n\t\torig_file_map = movie->movieFileMap;\n\t\tmovie->movieFileMap = tmp;\n\t} else {\n\t\tif (movie->movieFileMap)\n\t\t\tgf_isom_release_segment(movie, GF_FALSE);\n\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_READ_ONLY, &movie->movieFileMap);\n\t\tif (e) return e;\n\t}\n\tmovie->moov->compressed_diff = 0;\n\tmovie->current_top_box_start = 0;\n\n\tif (start_range || end_range) {\n\t\tif (end_range > start_range) {\n\t\t\tgf_bs_seek(movie->movieFileMap->bs, end_range+1);\n\t\t\tgf_bs_truncate(movie->movieFileMap->bs);\n\t\t}\n\t\tgf_bs_seek(movie->movieFileMap->bs, start_range);\n\t\tmovie->current_top_box_start = start_range;\n\t}\n\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\n\t\tif (!is_scalable_segment) {\n\t\t\t/*reset data handler to new segment*/\n\t\t\tif (trak->Media->information->dataHandler == NULL) {\n\t\t\t\ttrak->Media->information->dataHandler = movie->movieFileMap;\n\t\t\t}\n\t\t} else {\n\t\t\ttrak->present_in_scalable_segment = GF_FALSE;\n\t\t}\n\t}\n\tif (no_order_check) movie->NextMoofNumber = 0;\n\n\t//ok parse root boxes\n\te = gf_isom_parse_movie_boxes(movie, NULL, &MissingBytes, GF_TRUE);\n\n\tif (!is_scalable_segment)\n\t\treturn e;\n\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\tif (trak->present_in_scalable_segment) {\n\t\t\t/*store the temp dataHandler into scalableDataHandler so that it will not be destroyed\n\t\t\tif we append another representation - destruction of this data handler is done in release_segment*/\n\t\t\ttrak->Media->information->scalableDataHandler = tmp;\n\t\t\tif (!segment_map_assigned) {\n\t\t\t\ttrak->Media->information->scalableDataHandler = tmp;\n\t\t\t\tsegment_map_assigned = GF_TRUE;\n\t\t\t}\n\t\t\t//and update the regular dataHandler for the Media_GetSample function\n\t\t\ttrak->Media->information->dataHandler = tmp;\n\t\t}\n\t}\n\tmovie->movieFileMap = \torig_file_map;\n\treturn e;\n#endif\n}\n\nGF_EXPORT\nGF_ISOTrackID gf_isom_get_highest_track_in_scalable_segment(GF_ISOFile *movie, u32 for_base_track)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn 0;\n#else\n\ts32 max_ref;\n\tu32 i, j;\n\tGF_ISOTrackID track_id;\n\n\tmax_ref = 0;\n\ttrack_id = 0;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\ts32 ref;\n\t\tu32 ref_type = GF_ISOM_REF_SCAL;\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\tif (! trak->present_in_scalable_segment) continue;\n\n\t\tref = gf_isom_get_reference_count(movie, i+1, ref_type);\n\t\tif (ref<=0) {\n\t\t\t//handle implicit reconstruction for LHE1/LHV1, check sbas track ref\n\t\t\tu32 subtype = gf_isom_get_media_subtype(movie, i+1, 1);\n\t\t\tswitch (subtype) {\n\t\t\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\t\tcase GF_ISOM_SUBTYPE_LHV1:\n\t\t\t\tref = gf_isom_get_reference_count(movie, i+1, GF_ISOM_REF_BASE);\n\t\t\t\tif (ref<=0) continue;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (ref<=max_ref) continue;\n\n\t\tfor (j=0; j< (u32) ref; j++) {\n\t\t\tu32 on_track=0;\n\t\t\tgf_isom_get_reference(movie, i+1, GF_ISOM_REF_BASE, j+1, &on_track);\n\t\t\tif (on_track==for_base_track) {\n\t\t\t\tmax_ref = ref;\n\t\t\t\ttrack_id = trak->Header->trackID;\n\t\t\t}\n\t\t}\n\t}\n\treturn track_id;\n#endif\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_text_set_streaming_mode(GF_ISOFile *movie, Bool do_convert)\n{\n\tif (!movie) return GF_BAD_PARAM;\n\tmovie->convert_streaming_text = do_convert;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_GenericSampleDescription *gf_isom_get_generic_sample_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_GenericVisualSampleEntryBox *entry;\n\tGF_GenericAudioSampleEntryBox *gena;\n\tGF_GenericSampleEntryBox *genm;\n\tGF_TrackBox *trak;\n\tGF_GenericSampleDescription *udesc;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !StreamDescriptionIndex || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable) return 0;\n\n\tentry = (GF_GenericVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex-1);\n\t//no entry or MPEG entry:\n\tif (!entry || IsMP4Description(entry->type) ) return NULL;\n\t//if we handle the description return false\n\tswitch (entry->type) {\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\treturn NULL;\n\tcase GF_ISOM_BOX_TYPE_GNRV:\n\t\tGF_SAFEALLOC(udesc, GF_GenericSampleDescription);\n\t\tif (!udesc) return NULL;\n\t\tif (entry->EntryType == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tmemcpy(udesc->UUID, ((GF_UUIDBox*)entry)->uuid, sizeof(bin128));\n\t\t} else {\n\t\t\tudesc->codec_tag = entry->EntryType;\n\t\t}\n\t\tudesc->version = entry->version;\n\t\tudesc->revision = entry->revision;\n\t\tudesc->vendor_code = entry->vendor;\n\t\tudesc->temporal_quality = entry->temporal_quality;\n\t\tudesc->spatial_quality = entry->spatial_quality;\n\t\tudesc->width = entry->Width;\n\t\tudesc->height = entry->Height;\n\t\tudesc->h_res = entry->horiz_res;\n\t\tudesc->v_res = entry->vert_res;\n\t\tstrcpy(udesc->compressor_name, entry->compressor_name);\n\t\tudesc->depth = entry->bit_depth;\n\t\tudesc->color_table_index = entry->color_table_index;\n\t\tif (entry->data_size) {\n\t\t\tudesc->extension_buf_size = entry->data_size;\n\t\t\tudesc->extension_buf = (char*)gf_malloc(sizeof(char) * entry->data_size);\n\t\t\tif (!udesc->extension_buf) {\n\t\t\t\tgf_free(udesc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemcpy(udesc->extension_buf, entry->data, entry->data_size);\n\t\t}\n\t\treturn udesc;\n\tcase GF_ISOM_BOX_TYPE_GNRA:\n\t\tgena = (GF_GenericAudioSampleEntryBox *)entry;\n\t\tGF_SAFEALLOC(udesc, GF_GenericSampleDescription);\n\t\tif (!udesc) return NULL;\n\t\tif (gena->EntryType == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tmemcpy(udesc->UUID, ((GF_UUIDBox*)gena)->uuid, sizeof(bin128));\n\t\t} else {\n\t\t\tudesc->codec_tag = gena->EntryType;\n\t\t}\n\t\tudesc->version = gena->version;\n\t\tudesc->revision = gena->revision;\n\t\tudesc->vendor_code = gena->vendor;\n\t\tudesc->samplerate = gena->samplerate_hi;\n\t\tudesc->bits_per_sample = gena->bitspersample;\n\t\tudesc->nb_channels = gena->channel_count;\n\t\tif (gena->data_size) {\n\t\t\tudesc->extension_buf_size = gena->data_size;\n\t\t\tudesc->extension_buf = (char*)gf_malloc(sizeof(char) * gena->data_size);\n\t\t\tif (!udesc->extension_buf) {\n\t\t\t\tgf_free(udesc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemcpy(udesc->extension_buf, gena->data, gena->data_size);\n\t\t}\n\t\treturn udesc;\n\tcase GF_ISOM_BOX_TYPE_GNRM:\n\t\tgenm = (GF_GenericSampleEntryBox *)entry;\n\t\tGF_SAFEALLOC(udesc, GF_GenericSampleDescription);\n\t\tif (!udesc) return NULL;\n\t\tif (genm->EntryType == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tmemcpy(udesc->UUID, ((GF_UUIDBox*)genm)->uuid, sizeof(bin128));\n\t\t} else {\n\t\t\tudesc->codec_tag = genm->EntryType;\n\t\t}\n\t\tif (genm->data_size) {\n\t\t\tudesc->extension_buf_size = genm->data_size;\n\t\t\tudesc->extension_buf = (char*)gf_malloc(sizeof(char) * genm->data_size);\n\t\t\tif (!udesc->extension_buf) {\n\t\t\t\tgf_free(udesc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemcpy(udesc->extension_buf, genm->data, genm->data_size);\n\t\t}\n\t\treturn udesc;\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_visual_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *Width, u32 *Height)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t*Width = ((GF_VisualSampleEntryBox*)entry)->Width;\n\t\t*Height = ((GF_VisualSampleEntryBox*)entry)->Height;\n\t} else if (trak->Media->handler->handlerType==GF_ISOM_MEDIA_SCENE) {\n\t\t*Width = trak->Header->width>>16;\n\t\t*Height = trak->Header->height>>16;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_visual_bit_depth(GF_ISOFile* movie, u32 trackNumber, u32 StreamDescriptionIndex, u16* bitDepth)\n{\n\tGF_TrackBox* trak;\n\tGF_SampleEntryBox* entry;\n\tGF_SampleDescriptionBox* stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox*)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t*bitDepth = ((GF_VisualSampleEntryBox*)entry)->bit_depth;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_audio_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *SampleRate, u32 *Channels, u32 *bitsPerSample)\n{\n\tGF_TrackBox *trak;\n\tGF_AudioSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd = NULL;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->Media && trak->Media->information && trak->Media->information->sampleTable && trak->Media->information->sampleTable->SampleDescription)\n\t\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_AudioSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_BAD_PARAM;\n\n\tif (SampleRate) {\n\t\t(*SampleRate) = entry->samplerate_hi;\n\t\tif (entry->type==GF_ISOM_BOX_TYPE_MLPA) {\n\t\t\tu32 sr = entry->samplerate_hi;\n\t\t\tsr <<= 16;\n\t\t\tsr |= entry->samplerate_lo;\n\t\t\t(*SampleRate) = sr;\n\t\t}\n\t}\n\tif (Channels) (*Channels) = entry->channel_count;\n\tif (bitsPerSample) (*bitsPerSample) = (u8) entry->bitspersample;\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_audio_layout(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_AudioChannelLayout *layout)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_ChannelLayoutBox *chnl;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !layout) return GF_BAD_PARAM;\n\tmemset(layout, 0, sizeof(GF_AudioChannelLayout));\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_BAD_PARAM;\n\tchnl = (GF_ChannelLayoutBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CHNL);\n\tif (!chnl) return GF_NOT_FOUND;\n\n\tmemcpy(layout, &chnl->layout, sizeof(GF_AudioChannelLayout));\n\treturn GF_OK;\n}\nGF_EXPORT\nGF_Err gf_isom_get_pixel_aspect_ratio(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *hSpacing, u32 *vSpacing)\n{\n\tGF_TrackBox *trak;\n\tGF_VisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !hSpacing || !vSpacing) return GF_BAD_PARAM;\n\t*hSpacing = 1;\n\t*vSpacing = 1;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_VisualSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_OK;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type==GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\tGF_PixelAspectRatioBox *pasp = (GF_PixelAspectRatioBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_PASP);\n\t\tif (pasp) {\n\t\t\t*hSpacing = pasp->hSpacing;\n\t\t\t*vSpacing = pasp->vSpacing;\n\t\t}\n\t\treturn GF_OK;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_color_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *colour_type, u16 *colour_primaries, u16 *transfer_characteristics, u16 *matrix_coefficients, Bool *full_range_flag)\n{\n\tGF_TrackBox *trak;\n\tGF_VisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_VisualSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_OK;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type!=GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\tGF_ColourInformationBox *clr = (GF_ColourInformationBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_COLR);\n\tif (!clr) return GF_NOT_FOUND;\n\n\tif (colour_type) *colour_type = clr->colour_type;\n\tif (colour_primaries) *colour_primaries = clr->colour_primaries;\n\tif (transfer_characteristics) *transfer_characteristics = clr->transfer_characteristics;\n\tif (matrix_coefficients) *matrix_coefficients = clr->matrix_coefficients;\n\tif (full_range_flag) *full_range_flag = clr->full_range_flag;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nconst char *gf_isom_get_filename(GF_ISOFile *movie)\n{\n\tif (!movie) return NULL;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (movie->finalName && !movie->fileName) return movie->finalName;\n#endif\n\treturn movie->fileName;\n}\n\n\nGF_EXPORT\nu8 gf_isom_get_pl_indication(GF_ISOFile *movie, GF_ISOProfileLevelType PL_Code)\n{\n\tGF_IsomInitialObjectDescriptor *iod;\n\tif (!movie || !movie->moov) return 0xFF;\n\tif (!movie->moov->iods || !movie->moov->iods->descriptor) return 0xFF;\n\tif (movie->moov->iods->descriptor->tag != GF_ODF_ISOM_IOD_TAG) return 0xFF;\n\n\tiod = (GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor;\n\tswitch (PL_Code) {\n\tcase GF_ISOM_PL_AUDIO:\n\t\treturn iod->audio_profileAndLevel;\n\tcase GF_ISOM_PL_VISUAL:\n\t\treturn iod->visual_profileAndLevel;\n\tcase GF_ISOM_PL_GRAPHICS:\n\t\treturn iod->graphics_profileAndLevel;\n\tcase GF_ISOM_PL_SCENE:\n\t\treturn iod->scene_profileAndLevel;\n\tcase GF_ISOM_PL_OD:\n\t\treturn iod->OD_profileAndLevel;\n\tcase GF_ISOM_PL_INLINE:\n\t\treturn iod->inlineProfileFlag;\n\tcase GF_ISOM_PL_MPEGJ:\n\tdefault:\n\t\treturn 0xFF;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_matrix(GF_ISOFile *the_file, u32 trackNumber, u32 matrix[9])\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Header) return GF_BAD_PARAM;\n\tmemcpy(matrix, trak->Header->matrix, sizeof(trak->Header->matrix));\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_layout_info(GF_ISOFile *movie, u32 trackNumber, u32 *width, u32 *height, s32 *translation_x, s32 *translation_y, s16 *layer)\n{\n\tGF_TrackBox *tk = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!tk) return GF_BAD_PARAM;\n\tif (width) *width = tk->Header->width>>16;\n\tif (height) *height = tk->Header->height>>16;\n\tif (layer) *layer = tk->Header->layer;\n\tif (translation_x) *translation_x = tk->Header->matrix[6] >> 16;\n\tif (translation_y) *translation_y = tk->Header->matrix[7] >> 16;\n\treturn GF_OK;\n}\n\n\n/*returns total amount of media bytes in track*/\nGF_EXPORT\nu64 gf_isom_get_media_data_size(GF_ISOFile *movie, u32 trackNumber)\n{\n\tu32 i;\n\tu64 size;\n\tGF_SampleSizeBox *stsz;\n\tGF_TrackBox *tk = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!tk) return 0;\n\tstsz = tk->Media->information->sampleTable->SampleSize;\n\tif (!stsz) return 0;\n\tif (stsz->sampleSize) return stsz->sampleSize*stsz->sampleCount;\n\tsize = 0;\n\tfor (i=0; i<stsz->sampleCount; i++) size += stsz->sizes[i];\n\treturn size;\n}\n\n\nGF_EXPORT\nvoid gf_isom_set_default_sync_track(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *tk = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!tk) movie->es_id_default_sync = -1;\n\telse movie->es_id_default_sync = tk->Header->trackID;\n}\n\n\nGF_EXPORT\nBool gf_isom_is_single_av(GF_ISOFile *file)\n{\n\tu32 count, i, nb_any, nb_a, nb_v, nb_auxv, nb_pict, nb_scene, nb_od, nb_text;\n\tnb_auxv = nb_pict = nb_a = nb_v = nb_any = nb_scene = nb_od = nb_text = 0;\n\n\tif (!file->moov) return GF_FALSE;\n\tcount = gf_isom_get_track_count(file);\n\tfor (i=0; i<count; i++) {\n\t\tu32 mtype = gf_isom_get_media_type(file, i+1);\n\t\tswitch (mtype) {\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_any++;\n\t\t\telse nb_scene++;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_any++;\n\t\t\telse nb_od++;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\t\tnb_text++;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tnb_a++;\n\t\t\tbreak;\n        case GF_ISOM_MEDIA_AUXV:\n            /*discard file with images*/\n            if (gf_isom_get_sample_count(file, i+1)==1) nb_any++;\n            else nb_auxv++;\n            break;\n        case GF_ISOM_MEDIA_PICT:\n            /*discard file with images*/\n            if (gf_isom_get_sample_count(file, i+1)==1) nb_any++;\n            else nb_pict++;\n            break;\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\t/*discard file with images*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)==1) nb_any++;\n\t\t\telse nb_v++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnb_any++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (nb_any) return GF_FALSE;\n\tif ((nb_scene<=1) && (nb_od<=1) && (nb_a<=1) && (nb_v+nb_pict+nb_auxv<=1) && (nb_text<=1) ) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nBool gf_isom_is_JPEG2000(GF_ISOFile *mov)\n{\n\treturn (mov && mov->is_jp2) ? GF_TRUE : GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_guess_specification(GF_ISOFile *file)\n{\n\tu32 count, i, nb_any, nb_m4s, nb_a, nb_v, nb_auxv,nb_scene, nb_od, nb_mp3, nb_aac, nb_m4v, nb_avc, nb_amr, nb_h263, nb_qcelp, nb_evrc, nb_smv, nb_text, nb_pict;\n\n\tnb_m4s = nb_a = nb_v = nb_auxv = nb_any = nb_scene = nb_od = nb_mp3 = nb_aac = nb_m4v = nb_avc = nb_amr = nb_h263 = nb_qcelp = nb_evrc = nb_smv = nb_text = nb_pict = 0;\n\n\tif (file->is_jp2) {\n\t\tif (file->moov) return GF_ISOM_BRAND_MJP2;\n\t\treturn GF_ISOM_BRAND_JP2;\n\t}\n\tif (!file->moov) {\n\t\tif (!file->meta || !file->meta->handler) return 0;\n\t\treturn file->meta->handler->handlerType;\n\t}\n\n\tcount = gf_isom_get_track_count(file);\n\tfor (i=0; i<count; i++) {\n\t\tu32 mtype = gf_isom_get_media_type(file, i+1);\n\t\tu32 mstype = gf_isom_get_media_subtype(file, i+1, 1);\n\n\t\tif (mtype==GF_ISOM_MEDIA_SCENE) {\n\t\t\tnb_scene++;\n\t\t\t/*forces non-isma*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_m4s++;\n\t\t} else if (mtype==GF_ISOM_MEDIA_OD) {\n\t\t\tnb_od++;\n\t\t\t/*forces non-isma*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_m4s++;\n\t\t}\n\t\telse if ((mtype==GF_ISOM_MEDIA_TEXT) || (mtype==GF_ISOM_MEDIA_SUBT)) nb_text++;\n\t\telse if ((mtype==GF_ISOM_MEDIA_AUDIO) || gf_isom_is_video_handler_type(mtype) ) {\n\t\t\tswitch (mstype) {\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\t\tnb_amr++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\t\tnb_h263++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t\t\tnb_evrc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\t\tnb_qcelp++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\t\tnb_smv++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\t\t\tnb_avc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\t\t\tnb_avc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\t\tcase GF_ISOM_SUBTYPE_MPEG4_CRYP:\n\t\t\t{\n\t\t\t\tGF_DecoderConfig *dcd = gf_isom_get_decoder_config(file, i+1, 1);\n\t\t\t\tif (!dcd) break;\n\t\t\t\tswitch (dcd->streamType) {\n\t\t\t\tcase GF_STREAM_VISUAL:\n\t\t\t\t\tif (dcd->objectTypeIndication==GF_CODECID_MPEG4_PART2) nb_m4v++;\n\t\t\t\t\telse if ((dcd->objectTypeIndication==GF_CODECID_AVC) || (dcd->objectTypeIndication==GF_CODECID_SVC) || (dcd->objectTypeIndication==GF_CODECID_MVC)) nb_avc++;\n\t\t\t\t\telse nb_v++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_STREAM_AUDIO:\n\t\t\t\t\tswitch (dcd->objectTypeIndication) {\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG2_MP:\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG2_LCP:\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG4:\n\t\t\t\t\t\tnb_aac++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_MPEG2_PART3:\n\t\t\t\t\tcase GF_CODECID_MPEG_AUDIO:\n\t\t\t\t\t\tnb_mp3++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_EVRC:\n\t\t\t\t\t\tnb_evrc++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_SMV:\n\t\t\t\t\t\tnb_smv++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_QCELP:\n\t\t\t\t\t\tnb_qcelp++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tnb_a++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t/*SHOULD NEVER HAPPEN - IF SO, BROKEN MPEG4 FILE*/\n\t\t\t\tdefault:\n\t\t\t\t\tnb_any++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)dcd);\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (mtype==GF_ISOM_MEDIA_VISUAL) nb_v++;\n\t\t\t\telse if (mtype==GF_ISOM_MEDIA_AUXV) nb_auxv++;\n\t\t\t\telse if (mtype==GF_ISOM_MEDIA_PICT) nb_pict++;\n\t\t\t\telse nb_a++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((mtype==GF_ISOM_SUBTYPE_MPEG4) || (mtype==GF_ISOM_SUBTYPE_MPEG4_CRYP)) nb_m4s++;\n\t\telse nb_any++;\n\t}\n\tif (nb_any) return GF_ISOM_BRAND_ISOM;\n\tif (nb_qcelp || nb_evrc || nb_smv) {\n\t\t/*non std mix of streams*/\n\t\tif (nb_m4s || nb_avc || nb_scene || nb_od || nb_mp3 || nb_a || nb_v) return GF_ISOM_BRAND_ISOM;\n\t\treturn GF_ISOM_BRAND_3G2A;\n\t}\n\t/*other a/v/s streams*/\n\tif (nb_v || nb_a || nb_m4s) return GF_ISOM_BRAND_MP42;\n\n\tnb_v = nb_m4v + nb_avc + nb_h263;\n\tnb_a = nb_mp3 + nb_aac + nb_amr;\n\n\t/*avc file: whatever has AVC and no systems*/\n\tif (nb_avc) {\n\t\tif (!nb_scene && !nb_od) return GF_ISOM_BRAND_AVC1;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\t/*MP3: ISMA and MPEG4*/\n\tif (nb_mp3) {\n\t\tif (!nb_text && (nb_v<=1) && (nb_a<=1) && (nb_scene==1) && (nb_od==1))\n\t\t\treturn GF_ISOM_BRAND_ISMA;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\t/*MP4*/\n\tif (nb_scene || nb_od) {\n\t\t/*issue with AMR and H263 which don't have MPEG mapping: non compliant file*/\n\t\tif (nb_amr || nb_h263) return GF_ISOM_BRAND_ISOM;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\t/*use ISMA (3GP fine too)*/\n\tif (!nb_amr && !nb_h263 && !nb_text) {\n\t\tif ((nb_v<=1) && (nb_a<=1)) return GF_ISOM_BRAND_ISMA;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\n\tif ((nb_v<=1) && (nb_a<=1) && (nb_text<=1)) return nb_text ? GF_ISOM_BRAND_3GP6 : GF_ISOM_BRAND_3GP5;\n\treturn GF_ISOM_BRAND_3GG6;\n}\n\nGF_ItemListBox *gf_ismo_locate_box(GF_List *list, u32 boxType, bin128 UUID)\n{\n\tu32 i;\n\tGF_Box *box;\n\ti=0;\n\twhile ((box = (GF_Box *)gf_list_enum(list, &i))) {\n\t\tif (box->type == boxType) {\n\t\t\tGF_UUIDBox* box2 = (GF_UUIDBox* )box;\n\t\t\tif (boxType != GF_ISOM_BOX_TYPE_UUID) return (GF_ItemListBox *)box;\n\t\t\tif (!memcmp(box2->uuid, UUID, 16)) return (GF_ItemListBox *)box;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/*Apple extensions*/\n\n\nGF_EXPORT\nGF_Err gf_isom_apple_get_tag(GF_ISOFile *mov, GF_ISOiTunesTag tag, const u8 **data, u32 *data_len)\n{\n\tu32 i;\n\tGF_ListItemBox *info;\n\tGF_ItemListBox *ilst;\n\tGF_MetaBox *meta;\n\n\t*data = NULL;\n\t*data_len = 0;\n\n\tmeta = (GF_MetaBox *) gf_isom_get_meta_extensions(mov, GF_FALSE);\n\tif (!meta) return GF_URL_ERROR;\n\n\tilst = gf_ismo_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_ILST, NULL);\n\tif (!ilst) return GF_URL_ERROR;\n\n\tif (tag==GF_ISOM_ITUNE_PROBE) return gf_list_count(ilst->child_boxes) ? GF_OK : GF_URL_ERROR;\n\n\ti=0;\n\twhile ( (info=(GF_ListItemBox*)gf_list_enum(ilst->child_boxes, &i))) {\n\t\tif (info->type==tag) break;\n\t\t/*special cases*/\n\t\tif ((tag==GF_ISOM_ITUNE_GENRE) && (info->type==(u32) GF_ISOM_ITUNE_GENRE_USER)) break;\n\t\tinfo = NULL;\n\t}\n\tif (!info || !info->data || !info->data->data) return GF_URL_ERROR;\n\n\tif ((tag == GF_ISOM_ITUNE_GENRE) && (info->data->flags == 0)) {\n\t\tif (info->data->dataSize && (info->data->dataSize>2) && (info->data->dataSize < 5)) {\n\t\t\tGF_BitStream* bs = gf_bs_new(info->data->data, info->data->dataSize, GF_BITSTREAM_READ);\n\t\t\t*data_len = gf_bs_read_int(bs, info->data->dataSize * 8);\n\t\t\tgf_bs_del(bs);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n//\tif (info->data->flags != 0x1) return GF_URL_ERROR;\n\t*data = info->data->data;\n\t*data_len = info->data->dataSize;\n\tif ((tag==GF_ISOM_ITUNE_COVER_ART) && (info->data->flags==14)) *data_len |= 0x80000000; //(1<<31);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_apple_enum_tag(GF_ISOFile *mov, u32 idx, GF_ISOiTunesTag *out_tag, const u8 **data, u32 *data_len, u64 *out_int_val, u32 *out_int_val2, u32 *out_flags)\n{\n\tu32 i, child_index;\n\tGF_ListItemBox *info;\n\tGF_ItemListBox *ilst;\n\tGF_MetaBox *meta;\n\tGF_DataBox *dbox = NULL;\n\tu32 itype, tag_val;\n\ts32 tag_idx;\n\t*data = NULL;\n\t*data_len = 0;\n\n\tmeta = (GF_MetaBox *) gf_isom_get_meta_extensions(mov, GF_FALSE);\n\tif (!meta) return GF_URL_ERROR;\n\n\tilst = gf_ismo_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_ILST, NULL);\n\tif (!ilst) return GF_URL_ERROR;\n\n\tchild_index = i = 0;\n\twhile ( (info=(GF_ListItemBox*)gf_list_enum(ilst->child_boxes, &i))) {\n\t\tGF_DataBox *data_box = NULL;\n\t\tif (gf_itags_find_by_itag(info->type)<0) {\n\t\t\tif (info->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\t\tdata_box = (GF_DataBox *) gf_isom_box_find_child(info->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\t\t\t\tif (!data_box) continue;\n\t\t\t\ttag_val = ((GF_UnknownBox *)info)->original_4cc;\n\t\t\t}\n\t\t} else {\n\t\t\tdata_box = info->data;\n\t\t\ttag_val = info->type;\n\t\t}\n\t\tif (child_index==idx) {\n\t\t\tdbox = data_box;\n\t\t\tbreak;\n\t\t}\n\t\tchild_index++;\n\t}\n\tif (!dbox) return GF_URL_ERROR;\n\n\t*out_flags = dbox->flags;\n\t*out_tag = tag_val;\n\tif (!dbox->data) {\n\t\t*data = NULL;\n\t\t*data_len = 1;\n\t\treturn GF_OK;\n\t}\n\n\ttag_idx = gf_itags_find_by_itag(info->type);\n\tif (tag_idx<0) {\n\t\t*data = dbox->data;\n\t\t*data_len = dbox->dataSize;\n\t\treturn GF_OK;\n\t}\n\n\tif ((tag_val == GF_ISOM_ITUNE_GENRE) && (dbox->flags == 0) && (dbox->dataSize>2)) {\n\t\tu32 int_val = dbox->data[0];\n\t\tint_val <<= 8;\n\t\tint_val |= dbox->data[1];\n\t\t*data = NULL;\n\t\t*data_len = 0;\n\t\t*out_int_val = int_val;\n\t\treturn GF_OK;\n\t}\n\n\titype = gf_itags_get_type((u32) tag_idx);\n\tswitch (itype) {\n\tcase GF_ITAG_BOOL:\n\tcase GF_ITAG_INT8:\n\t\tif (dbox->dataSize) *out_int_val = dbox->data[0];\n\t\tbreak;\n\tcase GF_ITAG_INT16:\n\t\tif (dbox->dataSize>1) {\n\t\t\tu16 v = dbox->data[0];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[1];\n\t\t\t*out_int_val = v;\n\t\t}\n\t\tbreak;\n\tcase GF_ITAG_INT32:\n\t\tif (dbox->dataSize>3) {\n\t\t\tu32 v = dbox->data[0];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[1];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[2];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[3];\n\t\t\t*out_int_val = v;\n\t\t}\n\t\tbreak;\n\tcase GF_ITAG_INT64:\n\t\tif (dbox->dataSize>3) {\n\t\t\tu64 v = dbox->data[0];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[1];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[2];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[3];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[4];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[5];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[6];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[7];\n\t\t\t*out_int_val = v;\n\t\t}\n\t\tbreak;\n\tcase GF_ITAG_FRAC6:\n\tcase GF_ITAG_FRAC8:\n\t\tif (dbox->dataSize>3) {\n\t\t\tu32 v = dbox->data[2];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[3];\n\t\t\t*out_int_val = v;\n\t\t\tv = dbox->data[4];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[5];\n\t\t\t*out_int_val2 = v;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t*data = dbox->data;\n\t\t*data_len = dbox->dataSize;\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_wma_enum_tag(GF_ISOFile *mov, u32 idx, char **out_tag, const u8 **data, u32 *data_len, u32 *version, u32 *data_type)\n{\n\tGF_XtraBox *xtra;\n\tGF_XtraTag *tag;\n\n\t*out_tag = NULL;\n\t*data = NULL;\n\t*data_len = 0;\n\t*version = 0;\n\t*data_type = 0;\n\n\txtra = (GF_XtraBox *) gf_isom_get_meta_extensions(mov, GF_TRUE);\n\tif (!xtra) return GF_URL_ERROR;\n\n\ttag = gf_list_get(xtra->tags, idx);\n\tif (!tag) return GF_NOT_FOUND;\n\t*out_tag = tag->name;\n\t*data_len = tag->prop_size;\n\t*data = tag->prop_value;\n\t*version = tag->flags;\n\t*data_type = tag->prop_type;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_get_track_switch_group_count(GF_ISOFile *movie, u32 trackNumber, u32 *alternateGroupID, u32 *nb_groups)\n{\n\tGF_UserDataMap *map;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Header) return GF_BAD_PARAM;\n\t*alternateGroupID = trak->Header->alternate_group;\n\t*nb_groups = 0;\n\tif (!trak->udta) return GF_OK;\n\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (!map) return GF_OK;\n\t*nb_groups = gf_list_count(map->boxes);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nconst u32 *gf_isom_get_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, u32 group_index, u32 *switchGroupID, u32 *criteriaListSize)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_TrackSelectionBox *tsel;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!group_index || !trak || !trak->udta) return NULL;\n\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (!map) return NULL;\n\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, group_index-1);\n\tif (!tsel) return NULL;\n\t\n\t*switchGroupID = tsel->switchGroup;\n\t*criteriaListSize = tsel->attributeListCount;\n\treturn (const u32 *) tsel->attributeList;\n}\n\nGF_EXPORT\nu32 gf_isom_get_next_alternate_group_id(GF_ISOFile *movie)\n{\n\tu32 id = 0;\n\tu32 i=0;\n\n\twhile (i< gf_isom_get_track_count(movie) ) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, i+1);\n\t\tif (trak->Header->alternate_group > id)\n\t\t\tid = trak->Header->alternate_group;\n\t\ti++;\n\t}\n\treturn id+1;\n}\n\nGF_EXPORT\nu8 *gf_isom_sample_get_subsamples_buffer(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 *osize)\n{\n\tu8 *data;\n\tu32 size;\n\tu32 i, count;\n\tGF_BitStream *bs = NULL;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak || !osize) return NULL;\n\tif (!trak->Media || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->sub_samples) return NULL;\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sub_samples);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j, sub_count, last_sample = 0;\n\t\tGF_SubSampleInformationBox *sub_samples = gf_list_get(trak->Media->information->sampleTable->sub_samples, i);\n\n\t\tsub_count = gf_list_count(sub_samples->Samples);\n\t\tfor (j=0; j<sub_count; j++) {\n\t\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry *) gf_list_get(sub_samples->Samples, j);\n\t\t\tif (last_sample + pSamp->sample_delta == sampleNumber) {\n\t\t\t\tu32 scount = gf_list_count(pSamp->SubSamples);\n\t\t\t\tfor (j=0; j<scount; j++) {\n\t\t\t\t\tGF_SubSampleEntry *sent = gf_list_get(pSamp->SubSamples, j);\n\t\t\t\t\tif (!bs) bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\t\tgf_bs_write_u32(bs, sub_samples->flags);\n\t\t\t\t\tgf_bs_write_u32(bs, sent->subsample_size);\n\t\t\t\t\tgf_bs_write_u32(bs, sent->reserved);\n\t\t\t\t\tgf_bs_write_u8(bs, sent->subsample_priority);\n\t\t\t\t\tgf_bs_write_u8(bs, sent->discardable);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast_sample += pSamp->sample_delta;\n\t\t}\n\t}\n\tif (!bs) return NULL;\n\tgf_bs_get_content(bs, &data, &size);\n\tgf_bs_del(bs);\n\t*osize = size;\n\treturn data;\n}\n\nGF_EXPORT\nu32 gf_isom_sample_has_subsamples(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 flags)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->sub_samples) return 0;\n\tif (!sampleNumber) return 1;\n\treturn gf_isom_sample_get_subsample_entry(movie, track, sampleNumber, flags, NULL);\n}\n\nGF_EXPORT\nGF_Err gf_isom_sample_get_subsample(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 flags, u32 subSampleNumber, u32 *size, u8 *priority, u32 *reserved, Bool *discardable)\n{\n\tGF_SubSampleEntry *entry;\n\tGF_SubSampleInfoEntry *sub_sample;\n\tu32 count = gf_isom_sample_get_subsample_entry(movie, track, sampleNumber, flags, &sub_sample);\n\tif (!size || !priority || !discardable) return GF_BAD_PARAM;\n\n\tif (!subSampleNumber || (subSampleNumber>count)) return GF_BAD_PARAM;\n\tentry = (GF_SubSampleEntry*)gf_list_get(sub_sample->SubSamples, subSampleNumber-1);\n\t*size = entry->subsample_size;\n\t*priority = entry->subsample_priority;\n\t*reserved = entry->reserved;\n\t*discardable = entry->discardable ? GF_TRUE : GF_FALSE;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_rvc_config(GF_ISOFile *movie, u32 track, u32 sampleDescriptionIndex, u16 *rvc_predefined, u8 **data, u32 *size, const char **mime)\n{\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_TrackBox *trak;\n\n\tif (!rvc_predefined || !data || !size) return GF_BAD_PARAM;\n\t*rvc_predefined = 0;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!entry ) return GF_BAD_PARAM;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_RVCConfigurationBox *rvcc = (GF_RVCConfigurationBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RVCC);\n\tif (!rvcc) return GF_NOT_FOUND;\n\n\t*rvc_predefined = rvcc->predefined_rvc_config;\n\tif (rvcc->rvc_meta_idx) {\n\t\tif (!data || !size) return GF_OK;\n\t\treturn gf_isom_extract_meta_item_mem(movie, GF_FALSE, track, rvcc->rvc_meta_idx, data, size, NULL, mime, GF_FALSE);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nBool gf_isom_moov_first(GF_ISOFile *movie)\n{\n\tu32 i;\n\tfor (i=0; i<gf_list_count(movie->TopBoxes); i++) {\n\t\tGF_Box *b = (GF_Box*)gf_list_get(movie->TopBoxes, i);\n\t\tif (b->type == GF_ISOM_BOX_TYPE_MOOV) return GF_TRUE;\n\t\tif (b->type == GF_ISOM_BOX_TYPE_MDAT) return GF_FALSE;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nvoid gf_isom_reset_fragment_info(GF_ISOFile *movie, Bool keep_sample_count)\n{\n\tu32 i;\n\tif (!movie) return;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\ttrak->Media->information->sampleTable->SampleSize->sampleCount = 0;\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\t}\n#else\n\t\t//do not reset tfdt for LL-HLS case where parts do not contain a TFDT\n\t\t//trak->dts_at_seg_start = 0;\n\t\tif (!keep_sample_count)\n\t\t\ttrak->sample_count_at_seg_start = 0;\n\t}\n\tmovie->NextMoofNumber = 0;\n#endif\n}\n\nGF_EXPORT\nvoid gf_isom_reset_seq_num(GF_ISOFile *movie)\n{\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\tmovie->NextMoofNumber = 0;\n#endif\n}\n\nGF_EXPORT\nvoid gf_isom_reset_sample_count(GF_ISOFile *movie)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i;\n\tif (!movie) return;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\ttrak->Media->information->sampleTable->SampleSize->sampleCount = 0;\n\t\ttrak->sample_count_at_seg_start = 0;\n\t}\n\tmovie->NextMoofNumber = 0;\n#endif\n}\n\nGF_EXPORT\nBool gf_isom_has_cenc_sample_group(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tu32 i, count;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->sampleGroups) return GF_FALSE;\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\tif (sgdesc->grouping_type==GF_ISOM_SAMPLE_GROUP_SEIG) {\n\t\t\treturn GF_TRUE;\n\t\t}\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_rap_roll_info(GF_ISOFile *the_file, u32 trackNumber, u32 sample_number, Bool *is_rap, GF_ISOSampleRollType *roll_type, s32 *roll_distance)\n{\n\tGF_TrackBox *trak;\n\tu32 i, count;\n\n\tif (is_rap) *is_rap = GF_FALSE;\n\tif (roll_type) *roll_type = 0;\n\tif (roll_distance) *roll_distance = 0;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->sampleGroups) return GF_OK;\n\n\tif (!sample_number) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\t\tswitch (sgdesc->grouping_type) {\n\t\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t\t\tif (is_rap) *is_rap = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\t\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\t\t\tif (roll_type)\n\t\t\t\t\t*roll_type = (sgdesc->grouping_type==GF_ISOM_SAMPLE_GROUP_PROL) ? GF_ISOM_SAMPLE_PREROLL : GF_ISOM_SAMPLE_ROLL;\n\t\t\t\tif (roll_distance) {\n\t\t\t\t\ts32 max_roll = 0;\n\t\t\t\t\tu32 j;\n\t\t\t\t\tfor (j=0; j<gf_list_count(sgdesc->group_descriptions); j++) {\n\t\t\t\t\t\tGF_RollRecoveryEntry *roll_entry = (GF_RollRecoveryEntry*)gf_list_get(sgdesc->group_descriptions, j);\n\t\t\t\t\t\tif (max_roll < roll_entry->roll_distance)\n\t\t\t\t\t\t\tmax_roll = roll_entry->roll_distance;\n\t\t\t\t\t}\n\t\t\t\t\tif (*roll_distance < max_roll) *roll_distance = max_roll;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroups);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupBox *sg;\n\t\tu32 j, group_desc_index;\n\t\tGF_SampleGroupDescriptionBox *sgdesc;\n\t\tu32 first_sample_in_entry, last_sample_in_entry;\n\t\tfirst_sample_in_entry = 1;\n\t\tgroup_desc_index = 0;\n\t\tsg = (GF_SampleGroupBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);\n\t\tfor (j=0; j<sg->entry_count; j++) {\n\t\t\tlast_sample_in_entry = first_sample_in_entry + sg->sample_entries[j].sample_count - 1;\n\t\t\tif ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {\n\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*we found our sample*/\n\t\t\tgroup_desc_index = sg->sample_entries[j].group_description_index;\n\t\t\tbreak;\n\t\t}\n\t\t/*no sampleGroup info associated*/\n\t\tif (!group_desc_index) continue;\n\n\t\tsgdesc = NULL;\n\t\tfor (j=0; j<gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription); j++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, j);\n\t\t\tif (sgdesc->grouping_type==sg->grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t\t/*no sampleGroup description found for this group (invalid file)*/\n\t\tif (!sgdesc) continue;\n\n\t\tswitch (sgdesc->grouping_type) {\n\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t\tif (is_rap) *is_rap = GF_TRUE;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\t\tif (roll_type)\n\t\t\t\t*roll_type = (sgdesc->grouping_type==GF_ISOM_SAMPLE_GROUP_PROL) ? GF_ISOM_SAMPLE_PREROLL : GF_ISOM_SAMPLE_ROLL;\n\n\t\t\tif (roll_distance) {\n\t\t\t\tGF_RollRecoveryEntry *roll_entry = (GF_RollRecoveryEntry *) gf_list_get(sgdesc->group_descriptions, group_desc_index - 1);\n\t\t\t\tif (roll_entry)\n\t\t\t\t\t*roll_distance = roll_entry->roll_distance;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_DefaultSampleGroupDescriptionEntry * gf_isom_get_sample_group_info_entry(GF_ISOFile *the_file, GF_TrackBox *trak, u32 grouping_type, u32 sample_group_description_index, u32 *default_index, GF_SampleGroupDescriptionBox **out_sgdp)\n{\n\tu32 i, count;\n\n\tif (!trak || !sample_group_description_index) return NULL;\n\tif (!trak->Media->information->sampleTable->sampleGroupsDescription) return NULL;\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\tif (sgdesc->grouping_type != grouping_type) continue;\n\n\t\tif (sgdesc->default_description_index && !sample_group_description_index) sample_group_description_index = sgdesc->default_description_index;\n\n\t\tif (default_index) *default_index = sgdesc->default_description_index ;\n\t\tif (out_sgdp) *out_sgdp = sgdesc;\n\n\t\tif (!sample_group_description_index) return NULL;\n\t\treturn (GF_DefaultSampleGroupDescriptionEntry*)gf_list_get(sgdesc->group_descriptions, sample_group_description_index-1);\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nBool gf_isom_get_sample_group_info(GF_ISOFile *the_file, u32 trackNumber, u32 sample_description_index, u32 grouping_type, u32 *default_index, const u8 **data, u32 *size)\n{\n\tGF_DefaultSampleGroupDescriptionEntry *sg_entry;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\n\tif (default_index) *default_index = 0;\n\tif (size) *size = 0;\n\tif (data) *data = NULL;\n\n\tsg_entry = gf_isom_get_sample_group_info_entry(the_file, trak, grouping_type, sample_description_index, default_index, NULL);\n\tif (!sg_entry) return GF_FALSE;\n\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tif (sg_entry && data) *data = (char *) sg_entry->data;\n\t\tif (sg_entry && size) *size = sg_entry->length;\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n//return the duration of the movie+fragments if known, 0 if error\nGF_EXPORT\nu64 gf_isom_get_fragmented_duration(GF_ISOFile *movie)\n{\n\tif (movie->moov->mvex && movie->moov->mvex->mehd)\n\t\treturn movie->moov->mvex->mehd->fragment_duration;\n\n\treturn 0;\n}\n//return the duration of the movie+fragments if known, 0 if error\nGF_EXPORT\nu32 gf_isom_get_fragments_count(GF_ISOFile *movie, Bool segments_only)\n{\n\tu32 i=0;\n\tu32 nb_frags = 0;\n\tGF_Box *b;\n\twhile ((b=(GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tif (segments_only) {\n\t\t\tif (b->type==GF_ISOM_BOX_TYPE_SIDX)\n\t\t\t\tnb_frags++;\n\t\t} else {\n\t\t\tif (b->type==GF_ISOM_BOX_TYPE_MOOF)\n\t\t\t\tnb_frags++;\n\t\t}\n\t}\n\treturn nb_frags;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_fragmented_samples_info(GF_ISOFile *movie, GF_ISOTrackID trackID, u32 *nb_samples, u64 *duration)\n{\n\tu32 i=0;\n\tu32 k, l;\n\tGF_MovieFragmentBox *moof;\n\tGF_TrackFragmentBox *traf;\n\n\t*nb_samples = 0;\n\t*duration = 0;\n\twhile ((moof=(GF_MovieFragmentBox*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tu32 j=0;\n\t\tif (moof->type!=GF_ISOM_BOX_TYPE_MOOF) continue;\n\n\t\twhile ((traf=(GF_TrackFragmentBox*)gf_list_enum( moof->TrackList, &j))) {\n\t\t\tu64 def_duration, samp_dur=0;\n\n\t\t\tif (traf->tfhd->trackID != trackID)\n\t\t\t\tcontinue;\n\n\t\t\tdef_duration = 0;\n\t\t\tif (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DUR) def_duration = traf->tfhd->def_sample_duration;\n\t\t\telse if (traf->trex) def_duration = traf->trex->def_sample_duration;\n\n\t\t\tfor (k=0; k<gf_list_count(traf->TrackRuns); k++) {\n\t\t\t\tGF_TrackFragmentRunBox *trun = (GF_TrackFragmentRunBox*)gf_list_get(traf->TrackRuns, k);\n\t\t\t\t*nb_samples += trun->sample_count;\n\n\t\t\t\tfor (l=0; l<trun->nb_samples; l++) {\n\t\t\t\t\tGF_TrunEntry *ent = &trun->samples[l];\n\n\t\t\t\t\tsamp_dur = def_duration;\n\t\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DURATION) samp_dur = ent->Duration;\n\t\t\t\t\tif (trun->nb_samples == trun->sample_count)\n\t\t\t\t\t\t*duration += samp_dur;\n\t\t\t\t}\n\t\t\t\tif (trun->nb_samples != trun->sample_count)\n\t\t\t\t\t*duration += samp_dur * trun->sample_count;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_set_nalu_extract_mode(GF_ISOFile *the_file, u32 trackNumber, GF_ISONaluExtractMode nalu_extract_mode)\n{\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrak->extractor_mode = nalu_extract_mode;\n\n\tif (!trak->References) return GF_OK;\n\n\t/*get base*/\n\tdpnd = NULL;\n\ttrak->has_base_layer = GF_FALSE;\n\tTrack_FindRef(trak, GF_ISOM_REF_SCAL, &dpnd);\n\tif (dpnd) trak->has_base_layer = GF_TRUE;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_ISONaluExtractMode gf_isom_get_nalu_extract_mode(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->extractor_mode;\n}\n\nGF_EXPORT\ns32 gf_isom_get_composition_offset_shift(GF_ISOFile *file, u32 track)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return 0;\n\tif (!trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->CompositionToDecode) return 0;\n\treturn trak->Media->information->sampleTable->CompositionToDecode->compositionToDTSShift;\n}\n\nGF_EXPORT\nBool gf_isom_needs_layer_reconstruction(GF_ISOFile *file)\n{\n\tu32 count, i;\n\tif (!file)\n\t\treturn GF_FALSE;\n\tcount = gf_isom_get_track_count(file);\n\tfor (i = 0; i < count; i++) {\n\t\tif (gf_isom_get_reference_count(file, i+1, GF_ISOM_REF_SCAL) > 0) {\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\tif (gf_isom_get_reference_count(file, i+1, GF_ISOM_REF_SABT) > 0) {\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\tswitch (gf_isom_get_media_subtype(file, i+1, 1)) {\n\t\tcase GF_ISOM_SUBTYPE_LHV1:\n\t\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t\tif (gf_isom_get_reference_count(file, i+1, GF_ISOM_REF_BASE) > 0) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nvoid gf_isom_keep_utc_times(GF_ISOFile *file, Bool keep_utc)\n{\n\tif (!file) return;\n\tfile->keep_utc = keep_utc;\n}\n\nGF_EXPORT\nBool gf_isom_has_keep_utc_times(GF_ISOFile *file)\n{\n\tif (!file) return GF_FALSE;\n\treturn file->keep_utc;\n}\n\n\n\nGF_EXPORT\nu32 gf_isom_get_pssh_count(GF_ISOFile *file)\n{\n\tu32 count=0;\n\tu32 i=0;\n\tGF_Box *a_box;\n\tif (file->moov) {\n\t\twhile ((a_box = (GF_Box*)gf_list_enum(file->moov->child_boxes, &i))) {\n\t\t\tif (a_box->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (file->meta) {\n\t\twhile ((a_box = (GF_Box*)gf_list_enum(file->meta->child_boxes, &i))) {\n\t\t\tif (a_box->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\n#if 0 //unused\n/*! gets serialized PSS\n\\param isom_file the target ISO file\n\\param pssh_index 1-based index of PSSH to query, see \\ref gf_isom_get_pssh_count\n\\param pssh_data set to a newly allocated buffer containing serialized PSSH - shall be freeed by caller\n\\param pssh_size set to the size of the allocated buffer\n\\return error if any\n*/\nGF_Err gf_isom_get_pssh(GF_ISOFile *file, u32 pssh_index, u8 **pssh_data, u32 *pssh_size)\n{\n\tGF_Err e;\n\tu32 i=0;\n\tGF_BitStream *bs;\n\tu32 count=1;\n\tGF_Box *pssh;\n\twhile ((pssh = (GF_Box *)gf_list_enum(file->moov->child_boxes, &i))) {\n\t\tif (pssh->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\tif (count == pssh_index) break;\n\t\tcount++;\n\t}\n\tif (!pssh) return GF_BAD_PARAM;\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\te = gf_isom_box_write(pssh, bs);\n\tif (!e) {\n\t\tgf_bs_get_content(bs, pssh_data, pssh_size);\n\t}\n\tgf_bs_del(bs);\n\treturn e;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_get_pssh_info(GF_ISOFile *file, u32 pssh_index, bin128 SystemID, u32 *version, u32 *KID_count, const bin128 **KIDs, const u8 **private_data, u32 *private_data_size)\n{\n\tu32 count=1;\n\tu32 i=0;\n\tGF_ProtectionSystemHeaderBox *pssh=NULL;\n\tif (file->moov) {\n\t\twhile ((pssh = (GF_ProtectionSystemHeaderBox *)gf_list_enum(file->moov->child_boxes, &i))) {\n\t\t\tif (pssh->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tif (count == pssh_index) break;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (!pssh && file->meta) {\n\t\twhile ((pssh = (GF_ProtectionSystemHeaderBox *)gf_list_enum(file->meta->child_boxes, &i))) {\n\t\t\tif (pssh->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tif (count == pssh_index) break;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (!pssh) return GF_BAD_PARAM;\n\n\tif (SystemID) memcpy(SystemID, pssh->SystemID, 16);\n\tif (version) *version = pssh->version;\n\tif (KID_count) *KID_count = pssh->KID_count;\n\tif (KIDs) *KIDs = (const bin128 *) pssh->KIDs;\n\tif (private_data_size) *private_data_size = pssh->private_data_size;\n\tif (private_data) *private_data = pssh->private_data;\n\treturn GF_OK;\n}\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *senc, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n#else\nGF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *trak, void *traf, GF_SampleEncryptionBox *senc, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n#endif\n{\n\tGF_SampleGroupBox *sample_group;\n\tu32 j, group_desc_index;\n\tGF_SampleGroupDescriptionBox *sgdesc;\n\tu32 i, count;\n\tu32 descIndex, chunkNum;\n\tu64 offset;\n\tu32 first_sample_in_entry, last_sample_in_entry;\n\tGF_CENCSampleEncryptionGroupEntry *entry;\n\n\tif (IsEncrypted) *IsEncrypted = GF_FALSE;\n\tif (crypt_byte_block) *crypt_byte_block = 0;\n\tif (skip_byte_block) *skip_byte_block = 0;\n\tif (key_info) *key_info = NULL;\n\tif (key_info_size) *key_info_size = 0;\n\t\n\tif (!trak) return GF_BAD_PARAM;\n\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (traf)\n\t\treturn GF_NOT_SUPPORTED;\n#else\n\tsample_number -= trak->sample_count_at_seg_start;\n#endif\n\n\tif (trak->Media->information->sampleTable->SampleSize && trak->Media->information->sampleTable->SampleSize->sampleCount>=sample_number) {\n\t\tstbl_GetSampleInfos(trak->Media->information->sampleTable, sample_number, &offset, &chunkNum, &descIndex, NULL);\n\t} else {\n\t\t//this is dump mode of fragments, we haven't merged tables yet - use current stsd idx indicated in trak\n\t\tdescIndex = trak->current_traf_stsd_idx;\n\t\tif (!descIndex) descIndex = 1;\n\t}\n\n\tgf_isom_cenc_get_default_info_internal(trak, descIndex, NULL, IsEncrypted, crypt_byte_block, skip_byte_block, key_info, key_info_size);\n\n\tsample_group = NULL;\n\tgroup_desc_index = 0;\n\tif (trak->Media->information->sampleTable->sampleGroups) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroups);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsample_group = (GF_SampleGroupBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);\n\t\t\tif (sample_group->grouping_type ==  GF_ISOM_SAMPLE_GROUP_SEIG)\n\t\t\t\tbreak;\n\t\t\tsample_group = NULL;\n\t\t}\n\t\tif (sample_group) {\n\t\t\tfirst_sample_in_entry = 1;\n\t\t\tfor (j=0; j<sample_group->entry_count; j++) {\n\t\t\t\tlast_sample_in_entry = first_sample_in_entry + sample_group->sample_entries[j].sample_count - 1;\n\t\t\t\tif ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {\n\t\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*we found our sample*/\n\t\t\t\tgroup_desc_index = sample_group->sample_entries[j].group_description_index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!group_desc_index && traf && traf->sampleGroups) {\n\t\tcount = gf_list_count(traf->sampleGroups);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tgroup_desc_index = 0;\n\t\t\tsample_group = (GF_SampleGroupBox*)gf_list_get(traf->sampleGroups, i);\n\t\t\tif (sample_group->grouping_type ==  GF_ISOM_SAMPLE_GROUP_SEIG)\n\t\t\t\tbreak;\n\t\t\tsample_group = NULL;\n\t\t}\n\t\tif (sample_group) {\n\t\t\tfirst_sample_in_entry = 1;\n\t\t\tfor (j=0; j<sample_group->entry_count; j++) {\n\t\t\t\tlast_sample_in_entry = first_sample_in_entry + sample_group->sample_entries[j].sample_count - 1;\n\t\t\t\tif ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {\n\t\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*we found our sample*/\n\t\t\t\tgroup_desc_index = sample_group->sample_entries[j].group_description_index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\t/*no sampleGroup info associated*/\n\tif (!group_desc_index) goto exit;\n\n\tsgdesc = NULL;\n\n\tif (group_desc_index<=0x10000) {\n\t\tfor (j=0; j<gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription); j++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, j);\n\t\t\tif (sgdesc->grouping_type==sample_group->grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\telse if (traf) {\n\t\tgroup_desc_index -= 0x10000;\n\t\tfor (j=0; j<gf_list_count(traf->sampleGroupsDescription); j++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(traf->sampleGroupsDescription, j);\n\t\t\tif (sgdesc->grouping_type==sample_group->grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#endif\n\t/*no sampleGroup description found for this group (invalid file)*/\n\tif (!sgdesc) return GF_ISOM_INVALID_FILE;\n\n\tentry = (GF_CENCSampleEncryptionGroupEntry *) gf_list_get(sgdesc->group_descriptions, group_desc_index - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\n\tif (IsEncrypted) *IsEncrypted = entry->IsProtected;\n\tif (crypt_byte_block) *crypt_byte_block = entry->crypt_byte_block;\n\tif (skip_byte_block) *skip_byte_block = entry->skip_byte_block;\n\n\tif (key_info) *key_info = entry->key_info;\n\tif (key_info_size) *key_info_size = entry->key_info_size;\n\nexit:\n\t//in PIFF we may have default values if no TENC is present: 8 bytes for IV size\n\tif (( (senc && senc->piff_type==1) || (trak->moov && trak->moov->mov->is_smooth) ) && key_info && ! (*key_info) ) {\n\t\tif (!senc) {\n\t\t\tif (IsEncrypted) *IsEncrypted = GF_TRUE;\n\t\t\tif (key_info_size) *key_info_size = 8;\n\t\t} else {\n\t\t\tif (!senc->piff_type) {\n\t\t\t\tsenc->piff_type = 2;\n\t\t\t\tsenc->IV_size = 8;\n\t\t\t}\n\t\t\tassert(senc->IV_size);\n\t\t\tif (IsEncrypted) *IsEncrypted = GF_TRUE;\n\t\t\tif (key_info_size) *key_info_size = senc->IV_size;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_cenc_info(GF_ISOFile *movie, u32 track, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tGF_SampleEncryptionBox *senc = trak->sample_encryption;\n\n\treturn gf_isom_get_sample_cenc_info_internal(trak, NULL, senc, sample_number, IsEncrypted, crypt_byte_block, skip_byte_block, key_info, key_info_size);\n}\n\n\nGF_EXPORT\nBool gf_isom_get_last_producer_time_box(GF_ISOFile *file, GF_ISOTrackID *refTrackID, u64 *ntp, u64 *timestamp, Bool reset_info)\n{\n\tif (!file) return GF_FALSE;\n\tif (refTrackID) *refTrackID = 0;\n\tif (ntp) *ntp = 0;\n\tif (timestamp) *timestamp = 0;\n\n\tif (file->last_producer_ref_time) {\n\t\tif (refTrackID) *refTrackID = file->last_producer_ref_time->refTrackID;\n\t\tif (ntp) *ntp = file->last_producer_ref_time->ntp;\n\t\tif (timestamp) *timestamp = file->last_producer_ref_time->timestamp;\n\n\t\tif (reset_info) {\n\t\t\tfile->last_producer_ref_time = NULL;\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu64 gf_isom_get_current_tfdt(GF_ISOFile *the_file, u32 trackNumber)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn 0;\n#else\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->dts_at_seg_start;\n#endif\n}\n\nGF_EXPORT\nu64 gf_isom_get_smooth_next_tfdt(GF_ISOFile *the_file, u32 trackNumber)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn 0;\n#else\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->dts_at_next_seg_start;\n#endif\n}\n\nGF_EXPORT\nBool gf_isom_is_smooth_streaming_moov(GF_ISOFile *the_file)\n{\n\treturn the_file ? the_file->is_smooth : GF_FALSE;\n}\n\n\nvoid gf_isom_parse_trif_info(const u8 *data, u32 size, u32 *id, u32 *independent, Bool *full_picture, u32 *x, u32 *y, u32 *w, u32 *h)\n{\n\tGF_BitStream *bs;\n\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\t*id = gf_bs_read_u16(bs);\n\tif (! gf_bs_read_int(bs, 1)) {\n\t\t*independent=0;\n\t\t*full_picture=0;\n\t\t*x = *y = *w = *h = 0;\n\t} else {\n\t\t*independent = gf_bs_read_int(bs, 2);\n\t\t*full_picture = (Bool)gf_bs_read_int(bs, 1);\n\t\t/*filter_disabled*/ gf_bs_read_int(bs, 1);\n\t\t/*has_dependency_list*/ gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 2);\n\t\t*x = *full_picture ? 0 : gf_bs_read_u16(bs);\n\t\t*y = *full_picture ? 0 : gf_bs_read_u16(bs);\n\t\t*w = gf_bs_read_u16(bs);\n\t\t*h = gf_bs_read_u16(bs);\n\t}\n\tgf_bs_del(bs);\n}\n\nGF_EXPORT\nBool gf_isom_get_tile_info(GF_ISOFile *file, u32 trackNumber, u32 sample_description_index, u32 *default_sample_group_index, u32 *id, u32 *independent, Bool *full_picture, u32 *x, u32 *y, u32 *w, u32 *h)\n{\n\tconst u8 *data;\n\tu32 size;\n\n\tif (!gf_isom_get_sample_group_info(file, trackNumber, sample_description_index, GF_ISOM_SAMPLE_GROUP_TRIF, default_sample_group_index, &data, &size))\n\t\treturn GF_FALSE;\n\tgf_isom_parse_trif_info(data, size, id, independent, full_picture, x, y, w, h);\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_isom_get_oinf_info(GF_ISOFile *file, u32 trackNumber, GF_OperatingPointsInformation **ptr)\n{\n\tu32 oref_track, def_index=0;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(file, trackNumber);\n\n\tif (!ptr) return GF_FALSE;\n\n\toref_track=0;\n\tgf_isom_get_reference(file, trackNumber, GF_ISOM_REF_OREF, 1, &oref_track);\n\tif (oref_track) {\n\t\ttrak = gf_isom_get_track_from_file(file, oref_track);\n\t\tif (!trak) return GF_FALSE;\n\t}\n\n\t*ptr = (GF_OperatingPointsInformation *) gf_isom_get_sample_group_info_entry(file, trak, GF_ISOM_SAMPLE_GROUP_OINF, 1, &def_index, NULL);\n\n\treturn *ptr ? GF_TRUE : GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_byte_offset(GF_ISOFile *file, s64 byte_offset)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->read_byte_offset = byte_offset;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_isom_get_nalu_length_field(GF_ISOFile *file, u32 track, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_MPEGVisualSampleEntryBox *ve;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd || !StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (!entry || ! gf_isom_is_nalu_based_entry(trak->Media, entry)) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\n\tve = (GF_MPEGVisualSampleEntryBox*)entry;\n\tif (ve->avc_config) return ve->avc_config->config->nal_unit_size;\n\tif (ve->svc_config) return ve->svc_config->config->nal_unit_size;\n\tif (ve->hevc_config) return ve->hevc_config->config->nal_unit_size;\n\tif (ve->lhvc_config) return ve->lhvc_config->config->nal_unit_size;\n\treturn 0;\n}\n\nGF_EXPORT\nBool gf_isom_is_video_handler_type(u32 mtype)\n{\n\tswitch (mtype) {\n\tcase GF_ISOM_MEDIA_VISUAL:\n\tcase GF_ISOM_MEDIA_AUXV:\n\tcase GF_ISOM_MEDIA_PICT:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_bitrate(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescIndex, u32 *average_bitrate, u32 *max_bitrate, u32 *decode_buffer_size)\n{\n\tGF_BitRateBox *a;\n\tu32 i, count, mrate, arate, dbsize, type;\n\tGF_SampleEntryBox *ent;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\tGF_TrackBox *trak;\n\tGF_ESDBox *esd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tmrate = arate = dbsize = 0;\n\tcount = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\tfor (i=0; i<count; i++) {\n\t\tif ((sampleDescIndex>0) && (i+1 != sampleDescIndex)) continue;\n\n\t\tent = (GF_SampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tif (!ent) return GF_BAD_PARAM;\n\t\ta = gf_isom_sample_entry_get_bitrate(ent, GF_FALSE);\n\t\tif (a) {\n\t\t\tif (mrate<a->maxBitrate) mrate = a->maxBitrate;\n\t\t\tif (arate<a->avgBitrate) arate = a->avgBitrate;\n\t\t\tif (dbsize<a->bufferSizeDB) dbsize = a->bufferSizeDB;\n\t\t\tcontinue;\n\t\t}\n\t\ttype = ent->type;\n\t\tswitch (type) {\n\t\tcase GF_ISOM_BOX_TYPE_ENCV:\n\t\tcase GF_ISOM_BOX_TYPE_ENCA:\n\t\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\t\tif (sinf && sinf->original_format) type = sinf->original_format->data_format;\n\t\t\tbreak;\n\t\t}\n\t\tesd = NULL;\n\t\tswitch (type) {\n\t\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\t\tesd = ((GF_MPEGVisualSampleEntryBox *)ent)->esd;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\t\tesd = ((GF_MPEGAudioSampleEntryBox *)ent)->esd;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\t\tesd = ((GF_MPEGSampleEntryBox *)ent)->esd;\n\t\t\tbreak;\n\t\t}\n\t\tif (esd && esd->desc && esd->desc->decoderConfig) {\n\t\t\tif (mrate<esd->desc->decoderConfig->maxBitrate) mrate = esd->desc->decoderConfig->maxBitrate;\n\t\t\tif (arate<esd->desc->decoderConfig->avgBitrate) arate = esd->desc->decoderConfig->avgBitrate;\n\t\t\tif (dbsize<esd->desc->decoderConfig->bufferSizeDB) dbsize = esd->desc->decoderConfig->bufferSizeDB;\n\t\t}\n\t}\n\tif (average_bitrate) *average_bitrate = arate;\n\tif (max_bitrate) *max_bitrate = mrate;\n\tif (decode_buffer_size) *decode_buffer_size = dbsize;\n\treturn GF_OK;\n}\n\nvoid gf_isom_enable_traf_map_templates(GF_ISOFile *movie)\n{\n\tif (movie)\n\t\tmovie->signal_frag_bounds=GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_isom_sample_is_fragment_start(GF_ISOFile *movie, u32 trackNumber, u32 sampleNum, GF_ISOFragmentBoundaryInfo *frag_info)\n{\n\tu32 i;\n\tGF_TrackBox *trak;\n\tGF_TrafToSampleMap *tmap;\n\n\tif (frag_info) memset(frag_info, 0, sizeof(GF_ISOFragmentBoundaryInfo));\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->traf_map) return GF_FALSE;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNum<=trak->sample_count_at_seg_start)\n\t\treturn GF_FALSE;\n\tsampleNum -= trak->sample_count_at_seg_start;\n#endif\n\n\ttmap = trak->Media->information->sampleTable->traf_map;\n\tif (!tmap) return GF_FALSE;\n\tfor (i=0; i<tmap->nb_entries; i++) {\n\t\tGF_TrafMapEntry *finfo = &tmap->frag_starts[i];\n\t\tif (finfo->sample_num == sampleNum) {\n\t\t\tif (frag_info) {\n\t\t\t\tfrag_info->frag_start = finfo->moof_start;\n\t\t\t\tfrag_info->mdat_end = finfo->mdat_end;\n\t\t\t\tfrag_info->moof_template = finfo->moof_template;\n\t\t\t\tfrag_info->moof_template_size = finfo->moof_template_size;\n\t\t\t\tfrag_info->seg_start_plus_one = finfo->seg_start_plus_one;\n\t\t\t\tfrag_info->sidx_start = finfo->sidx_start;\n\t\t\t\tfrag_info->sidx_end = finfo->sidx_end;\n\t\t\t}\n\t\t\treturn GF_TRUE;\n\t\t}\n\n\t\tif (tmap->frag_starts[i].sample_num > sampleNum) return GF_FALSE;\n\t}\n\treturn GF_FALSE;\n}\n\n\n\n\nGF_EXPORT\nGF_Err gf_isom_get_jp2_config(GF_ISOFile *movie, u32 trackNumber, u32 sampleDesc, u8 **out_dsi, u32 *out_size)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_BitStream *bs;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleDescription) return GF_ISOM_INVALID_FILE;\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDesc-1);\n\tif (!entry || !entry->jp2h) return GF_BAD_PARAM;\n\tif (!entry->jp2h->ihdr) return GF_ISOM_INVALID_FILE;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_box_array_write((GF_Box*)entry->jp2h, entry->jp2h->child_boxes, bs);\n\tgf_bs_get_content(bs, out_dsi, out_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\n\nBool gf_isom_is_identical_sgpd(void *ptr1, void *ptr2, u32 grouping_type)\n{\n\tBool res = GF_FALSE;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tGF_BitStream *bs1, *bs2;\n\tu8 *buf1, *buf2;\n\tu32 len1, len2;\n\n\tif (!ptr1 || !ptr2)\n\t\treturn GF_FALSE;\n\n\tbs1 = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (grouping_type) {\n\t\tsgpd_write_entry(grouping_type, ptr1, bs1);\n\t} else {\n\t\tgf_isom_box_size((GF_Box *)ptr1);\n\t\tgf_isom_box_write((GF_Box *)ptr1, bs1);\n\t}\n\tgf_bs_get_content(bs1, &buf1, &len1);\n\tgf_bs_del(bs1);\n\n\tbs2 = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (grouping_type) {\n\t\tsgpd_write_entry(grouping_type, ptr2, bs2);\n\t} else {\n\t\tgf_isom_box_write((GF_Box *)ptr2, bs2);\n\t}\n\tgf_bs_get_content(bs2, &buf2, &len2);\n\tgf_bs_del(bs2);\n\n\n\tif ((len1==len2) && !memcmp(buf1, buf2, len1))\n\t\tres = GF_TRUE;\n\n\tgf_free(buf1);\n\tgf_free(buf2);\n#endif\n\treturn res;\n}\n\nGF_EXPORT\nu64 gf_isom_get_track_magic(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->magic;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_file_offset_for_time(GF_ISOFile *movie, Double start_time, u64 *max_offset)\n{\n\tu32 i;\n\tu64 start_ts, cur_start_time;\n\tu64 offset=0;\n\tif (!movie || !movie->moov)\n\t\treturn GF_BAD_PARAM;\n\n\tif (!movie->main_sidx) return GF_NOT_SUPPORTED;\n\tstart_ts = (u64) (start_time * movie->main_sidx->timescale);\n\tcur_start_time = 0;\n\toffset = movie->main_sidx->first_offset + movie->main_sidx_end_pos;\n\n\tfor (i=0; i<movie->main_sidx->nb_refs; i++) {\n\t\tif (cur_start_time >= start_ts) {\n\t\t\t*max_offset = offset;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tcur_start_time += movie->main_sidx->refs[i].subsegment_duration;\n\t\toffset += movie->main_sidx->refs[i].reference_size;\n\t}\n\n\treturn GF_EOS;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sidx_duration(GF_ISOFile *movie, u64 *sidx_dur, u32 *sidx_timescale)\n{\n\tu64 dur=0;\n\tu32 i;\n\tif (!movie || !movie->moov || !sidx_timescale || !sidx_dur)\n\t\treturn GF_BAD_PARAM;\n\n\tif (!movie->main_sidx) return GF_NOT_SUPPORTED;\n\t*sidx_timescale = movie->main_sidx->timescale;\n\n\tfor (i=0; i<movie->main_sidx->nb_refs; i++) {\n\t\tdur += movie->main_sidx->refs[i].subsegment_duration;\n\t}\n\t*sidx_dur = dur;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nconst u8 *gf_isom_get_mpegh_compatible_profiles(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescIndex, u32 *nb_compat_profiles)\n{\n\tGF_SampleEntryBox *ent;\n\tGF_MHACompatibleProfilesBox *mhap;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !nb_compat_profiles) return NULL;\n\t*nb_compat_profiles = 0;\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescIndex-1);\n\tif (!ent) return NULL;\n\tmhap = (GF_MHACompatibleProfilesBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_MHAP);\n\tif (!mhap) return NULL;\n\t*nb_compat_profiles = mhap->num_profiles;\n\treturn mhap->compat_profiles;\n}\n\nconst void *gf_isom_get_tfrf(GF_ISOFile *movie, u32 trackNumber)\n{\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\treturn NULL;\n#else\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return NULL;\n\n\treturn trak->tfrf;\n#endif\n}\n\nGF_Err gf_isom_get_y3d_info(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescriptionIndex, GF_ISOM_Y3D_Info *info)\n{\n\tGF_SampleEntryBox *ent;\n\tGF_TrackBox *trak;\n\tBool found = GF_FALSE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !info) return GF_BAD_PARAM;\n\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\n\tmemset(info, 0, sizeof(GF_ISOM_Y3D_Info));\n\n\tGF_Stereo3DBox *st3d = (GF_Stereo3DBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (st3d) {\n\t\tfound = GF_TRUE;\n\t\tinfo->stereo_type = st3d->stereo_type;\n\t}\n\n\tGF_Box *sv3d = gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (!sv3d) {\n\t\treturn found ? GF_OK : GF_NOT_FOUND;\n\t}\n\tGF_SphericalVideoInfoBox *svhd = (GF_SphericalVideoInfoBox *) gf_isom_box_find_child(sv3d->child_boxes, GF_ISOM_BOX_TYPE_SVHD);\n\tif (svhd && strlen(svhd->string)) info->meta_data = svhd->string;\n\n\tGF_Box *proj = gf_isom_box_find_child(sv3d->child_boxes, GF_ISOM_BOX_TYPE_PROJ);\n\tif (!proj)\n\t\treturn found ? GF_OK : GF_NOT_FOUND;\n\n\tGF_ProjectionHeaderBox *projh = (GF_ProjectionHeaderBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_PRHD);\n\tif (projh) {\n\t\tinfo->yaw = projh->yaw;\n\t\tinfo->pitch = projh->pitch;\n\t\tinfo->roll = projh->roll;\n\t\tinfo->pose_present = GF_TRUE;\n\t}\n\n\tGF_ProjectionTypeBox *projt = (GF_ProjectionTypeBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_CBMP);\n\tif (projt) {\n\t\tinfo->layout = projt->layout;\n\t\tinfo->padding = projt->padding;\n\t\tinfo->projection_type = 1;\n\t} else {\n\t\tprojt = (GF_ProjectionTypeBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_EQUI);\n\t\tif (projt) {\n\t\t\tinfo->top = projt->bounds_top;\n\t\t\tinfo->bottom = projt->bounds_bottom;\n\t\t\tinfo->left = projt->bounds_left;\n\t\t\tinfo->right = projt->bounds_right;\n\t\t\tinfo->projection_type = 2;\n\t\t} else {\n\t\t\tprojt = (GF_ProjectionTypeBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_EQUI);\n\t\t\tif (projt) {\n\t\t\t\tinfo->projection_type = 3;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_chunk_count(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_ChunkOffsetBox *stco;\n\tGF_TrackBox *trak;\n\tif (!movie || !movie->moov || !trackNumber) return 0;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->ChunkOffset ) return 0;\n\n\tstco = (GF_ChunkOffsetBox *) trak->Media->information->sampleTable->ChunkOffset;\n\tif (stco->type == GF_ISOM_BOX_TYPE_STCO)\n\t\treturn stco->nb_entries;\n\tif (stco->type == GF_ISOM_BOX_TYPE_CO64)\n\t\treturn ((GF_ChunkLargeOffsetBox *) stco)->nb_entries;\n\treturn 0;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_chunk_info(GF_ISOFile *movie, u32 trackNumber, u32 chunk_num, u64 *chunk_offset, u32 *first_sample_num, u32 *sample_per_chunk, u32 *sample_desc_idx)\n{\n\tGF_ChunkOffsetBox *stco = NULL;\n\tGF_ChunkLargeOffsetBox *co64 = NULL;\n\tGF_SampleToChunkBox *stsc = NULL;\n\tGF_TrackBox *trak;\n\tu32 i, nb_entries, nb_samples, sample_desc_index;\n\tif (!movie || !movie->moov || !trackNumber || !chunk_num) return GF_BAD_PARAM;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->ChunkOffset ) return GF_BAD_PARAM;\n\n\tstsc = (GF_SampleToChunkBox *) trak->Media->information->sampleTable->SampleToChunk;\n\tstco = (GF_ChunkOffsetBox *) trak->Media->information->sampleTable->ChunkOffset;\n\tif (stco->type == GF_ISOM_BOX_TYPE_CO64) {\n\t\tstco = NULL;\n\t\tco64 = (GF_ChunkLargeOffsetBox *) trak->Media->information->sampleTable->ChunkOffset;\n\t\tnb_entries = co64->nb_entries;\n\t} else {\n\t\tnb_entries = stco->nb_entries;\n\t}\n\tif (chunk_num>nb_entries) return GF_BAD_PARAM;\n\n\tsample_desc_index = 0;\n\tnb_samples = 1;\n\tfor (i=0; i<stsc->nb_entries; i++) {\n\t\tu32 nb_chunks_before;\n\n\t\tif (stsc->entries[i].firstChunk == chunk_num) {\n\t\t\tsample_desc_index = stsc->entries[i].sampleDescriptionIndex;\n\t\t\tif (sample_per_chunk)\n\t\t\t\t*sample_per_chunk = stsc->entries[i].samplesPerChunk;\n\t\t\tbreak;\n\t\t}\n\t\tassert(stsc->entries[i].firstChunk<chunk_num);\n\n\t\tif ((i+1 == stsc->nb_entries)\n\t\t\t|| (stsc->entries[i+1].firstChunk>chunk_num)\n\t\t) {\n\t\t\tnb_chunks_before = chunk_num - stsc->entries[i].firstChunk;\n\t\t\tnb_samples += stsc->entries[i].samplesPerChunk * nb_chunks_before;\n\t\t\tsample_desc_index = stsc->entries[i].sampleDescriptionIndex;\n\t\t\tif (sample_per_chunk)\n\t\t\t\t*sample_per_chunk = stsc->entries[i].samplesPerChunk;\n\t\t\tbreak;\n\t\t}\n\t\tassert(stsc->entries[i+1].firstChunk > stsc->entries[i].firstChunk);\n\n\t\tnb_chunks_before = stsc->entries[i+1].firstChunk - stsc->entries[i].firstChunk;\n\t\tnb_samples += stsc->entries[i].samplesPerChunk * nb_chunks_before;\n\t}\n\tif (first_sample_num) *first_sample_num = nb_samples;\n\tif (sample_desc_idx) *sample_desc_idx = sample_desc_index;\n\tif (chunk_offset) {\n\t\tif (stco)\n\t\t\t*chunk_offset = stco->offsets[chunk_num-1];\n\t\telse\n\t\t\t*chunk_offset = co64->offsets[chunk_num-1];\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n//the only static var. Used to store any error happening while opening a movie\nstatic GF_Err MP4_API_IO_Err;\n\nvoid gf_isom_set_last_error(GF_ISOFile *movie, GF_Err error)\n{\n\tif (!movie) {\n\t\tMP4_API_IO_Err = error;\n\t} else {\n\t\tmovie->LastError = error;\n\t}\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_last_error(GF_ISOFile *the_file)\n{\n\tif (!the_file) return MP4_API_IO_Err;\n\treturn the_file->LastError;\n}\n\nGF_EXPORT\nu8 gf_isom_get_mode(GF_ISOFile *the_file)\n{\n\tif (!the_file) return 0;\n\treturn the_file->openMode;\n}\n\n#if 0 //unused\n/*! gets file size of an ISO file\n\\param isom_file the target ISO file\n\\return the file size in bytes\n*/\nu64 gf_isom_get_file_size(GF_ISOFile *the_file)\n{\n\tif (!the_file) return 0;\n\tif (the_file->movieFileMap) return gf_bs_get_size(the_file->movieFileMap->bs);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (the_file->editFileMap) return gf_bs_get_size(the_file->editFileMap->bs);\n#endif\n\treturn 0;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_freeze_order(GF_ISOFile *file)\n{\n\tu32 i=0;\n\tGF_Box *box;\n\tif (!file) return GF_BAD_PARAM;\n\twhile ((box=gf_list_enum(file->TopBoxes, &i))) {\n\t\tgf_isom_box_freeze_order(box);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_inplace_padding(GF_ISOFile *file, u32 padding)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->padding = padding;\n\treturn GF_OK;\n}\n/**************************************************************\n\t\t\t\t\tSample Manip\n**************************************************************/\n\n//creates a new empty sample\nGF_EXPORT\nGF_ISOSample *gf_isom_sample_new()\n{\n\tGF_ISOSample *tmp;\n\tGF_SAFEALLOC(tmp, GF_ISOSample);\n\treturn tmp;\n}\n\n//delete a sample\nGF_EXPORT\nvoid gf_isom_sample_del(GF_ISOSample **samp)\n{\n\tif (!samp || ! *samp) return;\n\tif ((*samp)->data && (*samp)->dataLength) gf_free((*samp)->data);\n\tgf_free(*samp);\n\t*samp = NULL;\n}\n\nstatic u32 gf_isom_probe_type(u32 type)\n{\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_FTYP:\n\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\treturn 2;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tcase GF_ISOM_BOX_TYPE_MOOF:\n\tcase GF_ISOM_BOX_TYPE_STYP:\n\tcase GF_ISOM_BOX_TYPE_SIDX:\n\tcase GF_ISOM_BOX_TYPE_EMSG:\n\tcase GF_ISOM_BOX_TYPE_PRFT:\n    //we map free as segment when it is first in the file - a regular file shall start with ftyp or a file sig, not free\n    //since our route stack may patch boxes to free for incomplete segments, we must map this to free\n    case GF_ISOM_BOX_TYPE_FREE:\n\t\treturn 3;\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\t/*Adobe specific*/\n\tcase GF_ISOM_BOX_TYPE_AFRA:\n\tcase GF_ISOM_BOX_TYPE_ABST:\n#endif\n#endif\n\tcase GF_ISOM_BOX_TYPE_MDAT:\n\tcase GF_ISOM_BOX_TYPE_SKIP:\n\tcase GF_ISOM_BOX_TYPE_UDTA:\n\tcase GF_ISOM_BOX_TYPE_META:\n\tcase GF_ISOM_BOX_TYPE_VOID:\n\tcase GF_ISOM_BOX_TYPE_JP:\n\tcase GF_QT_BOX_TYPE_WIDE:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nGF_EXPORT\nu32 gf_isom_probe_file_range(const char *fileName, u64 start_range, u64 end_range)\n{\n\tu32 type = 0;\n\n\tif (!strncmp(fileName, \"gmem://\", 7)) {\n\t\tu32 size;\n\t\tu8 *mem_address;\n\t\tif (gf_blob_get(fileName, &mem_address, &size, NULL) != GF_OK) {\n\t\t\treturn 0;\n\t\t}\n        if (size && (size > start_range + 8)) {\n\t\t\ttype = GF_4CC(mem_address[start_range + 4], mem_address[start_range + 5], mem_address[start_range + 6], mem_address[start_range + 7]);\n        }\n        gf_blob_release(fileName);\n\t} else if (!strncmp(fileName, \"isobmff://\", 10)) {\n\t\treturn 2;\n\t} else {\n\t\tu32 nb_read;\n\t\tunsigned char data[4];\n\t\tFILE *f = gf_fopen(fileName, \"rb\");\n\t\tif (!f) return 0;\n\t\tif (start_range) gf_fseek(f, start_range, SEEK_SET);\n\t\ttype = 0;\n\t\tnb_read = (u32) gf_fread(data, 4, f);\n\t\tif (nb_read == 4) {\n\t\t\tif (gf_fread(data, 4, f) == 4) {\n\t\t\t\ttype = GF_4CC(data[0], data[1], data[2], data[3]);\n\t\t\t}\n\t\t}\n\t\tgf_fclose(f);\n\t\tif (!nb_read) return 0;\n\t}\n\treturn gf_isom_probe_type(type);\n}\n\nGF_EXPORT\nu32 gf_isom_probe_file(const char *fileName)\n{\n\treturn gf_isom_probe_file_range(fileName, 0, 0);\n}\n\nGF_EXPORT\nu32 gf_isom_probe_data(const u8*inBuf, u32 inSize)\n{\n\tu32 type;\n\tif (inSize < 8) return 0;\n\ttype = GF_4CC(inBuf[4], inBuf[5], inBuf[6], inBuf[7]);\n\treturn gf_isom_probe_type(type);\n}\n\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n#include <gpac/internal/media_dev.h>\n#endif\n\nstatic GF_Err isom_create_init_from_mem(const char *fileName, GF_ISOFile *file)\n{\n\tu32 sample_rate=0;\n\tu32 nb_channels=0;\n\tu32 bps=0;\n\t//u32 atag=0;\n\tu32 nal_len=4;\n\tu32 width = 0;\n\tu32 height = 0;\n\tu32 timescale = 10000000;\n\tu64 tfdt = 0;\n\tchar sz4cc[5];\n\tchar CodecParams[2048];\n\tu32 CodecParamLen=0;\n\tchar *sep, *val;\n\tGF_TrackBox *trak;\n\tGF_TrackExtendsBox *trex;\n\tGF_SampleTableBox *stbl;\n\n\tsz4cc[0] = 0;\n\n\tval = (char*) ( fileName + strlen(\"isobmff://\") );\n\twhile (1)  {\n\t\tsep = strchr(val, ' ');\n\t\tif (sep) sep[0] = 0;\n\n\t\tif (!strncmp(val, \"4cc=\", 4)) strcpy(sz4cc, val+4);\n\t\telse if (!strncmp(val, \"init=\", 5)) {\n\t\t\tchar szH[3], *data = val+5;\n\t\t\tu32 i, len = (u32) strlen(data);\n\t\t\tfor (i=0; i<len; i+=2) {\n\t\t\t\tu32 v;\n\t\t\t\t//init is hex-encoded so 2 input bytes for one output char\n\t\t\t\tszH[0] = data[i];\n\t\t\t\tszH[1] = data[i+1];\n\t\t\t\tszH[2] = 0;\n\t\t\t\tsscanf(szH, \"%X\", &v);\n\t\t\t\tCodecParams[CodecParamLen] = (char) v;\n\t\t\t\tCodecParamLen++;\n\t\t\t}\n\t\t}\n\t\telse if (!strncmp(val, \"nal=\", 4)) nal_len = atoi(val+4);\n\t\telse if (!strncmp(val, \"bps=\", 4)) bps = atoi(val+4);\n\t\t//else if (!strncmp(val, \"atag=\", 5)) atag = atoi(val+5);\n\t\telse if (!strncmp(val, \"ch=\", 3)) nb_channels = atoi(val+3);\n\t\telse if (!strncmp(val, \"srate=\", 6)) sample_rate = atoi(val+6);\n\t\telse if (!strncmp(val, \"w=\", 2)) width = atoi(val+2);\n\t\telse if (!strncmp(val, \"h=\", 2)) height = atoi(val+2);\n\t\telse if (!strncmp(val, \"scale=\", 6)) timescale = atoi(val+6);\n\t\telse if (!strncmp(val, \"tfdt=\", 5)) {\n\t\t\tsscanf(val+5, LLX, &tfdt);\n\t\t}\n\t\tif (!sep) break;\n\t\tsep[0] = ' ';\n\t\tval = sep+1;\n\t}\n\tif (!stricmp(sz4cc, \"H264\") || !stricmp(sz4cc, \"AVC1\")) {\n\t}\n\telse if (!stricmp(sz4cc, \"AACL\")) {\n\t}\n\telse {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Cannot convert smooth media type %s to ISO init segment\\n\", sz4cc));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tfile->moov = (GF_MovieBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MOOV);\n\tif (!file->moov) return GF_OUT_OF_MEM;\n\tgf_list_add(file->TopBoxes, file->moov);\n\tfile->moov->mov = file;\n\tfile->is_smooth = GF_TRUE;\n\tfile->moov->mvhd = (GF_MovieHeaderBox *) gf_isom_box_new_parent(&file->moov->child_boxes, GF_ISOM_BOX_TYPE_MVHD);\n\tif (!file->moov->mvhd) return GF_OUT_OF_MEM;\n\tfile->moov->mvhd->timeScale = timescale;\n\tfile->moov->mvex = (GF_MovieExtendsBox *) gf_isom_box_new_parent(&file->moov->child_boxes, GF_ISOM_BOX_TYPE_MVEX);\n\tif (!file->moov->mvex) return GF_OUT_OF_MEM;\n\ttrex = (GF_TrackExtendsBox *) gf_isom_box_new_parent(&file->moov->mvex->child_boxes, GF_ISOM_BOX_TYPE_TREX);\n\tif (!trex) return GF_OUT_OF_MEM;\n\n\ttrex->def_sample_desc_index = 1;\n\ttrex->trackID = 1;\n\tgf_list_add(file->moov->mvex->TrackExList, trex);\n\n\ttrak = (GF_TrackBox *) gf_isom_box_new_parent(&file->moov->child_boxes, GF_ISOM_BOX_TYPE_TRAK);\n\tif (!trak) return GF_OUT_OF_MEM;\n\ttrak->moov = file->moov;\n\tgf_list_add(file->moov->trackList, trak);\n\n\ttrak->Header = (GF_TrackHeaderBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TKHD);\n\tif (!trak->Header) return GF_OUT_OF_MEM;\n\ttrak->Header->trackID = 1;\n\ttrak->Header->flags |= 1;\n\ttrak->Header->width = width;\n\ttrak->Header->height = height;\n\n\ttrak->Media = (GF_MediaBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_MDIA);\n\tif (!trak->Media) return GF_OUT_OF_MEM;\n\ttrak->Media->mediaTrack = trak;\n\ttrak->Media->mediaHeader = (GF_MediaHeaderBox *) gf_isom_box_new_parent(&trak->Media->child_boxes, GF_ISOM_BOX_TYPE_MDHD);\n\tif (!trak->Media->mediaHeader) return GF_OUT_OF_MEM;\n\ttrak->Media->mediaHeader->timeScale = timescale;\n\n\ttrak->Media->handler = (GF_HandlerBox *) gf_isom_box_new_parent(&trak->Media->child_boxes,GF_ISOM_BOX_TYPE_HDLR);\n\tif (!trak->Media->handler) return GF_OUT_OF_MEM;\n    //we assume by default vide for handler type (only used for smooth streaming)\n\ttrak->Media->handler->handlerType = width ? GF_ISOM_MEDIA_VISUAL : GF_ISOM_MEDIA_AUDIO;\n\n\ttrak->Media->information = (GF_MediaInformationBox *) gf_isom_box_new_parent(&trak->Media->child_boxes, GF_ISOM_BOX_TYPE_MINF);\n\tif (!trak->Media->information) return GF_OUT_OF_MEM;\n\ttrak->Media->information->sampleTable = (GF_SampleTableBox *) gf_isom_box_new_parent(&trak->Media->information->child_boxes, GF_ISOM_BOX_TYPE_STBL);\n\tif (!trak->Media->information->sampleTable) return GF_OUT_OF_MEM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tstbl->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSZ);\n\tif (!stbl->SampleSize) return GF_OUT_OF_MEM;\n\tstbl->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STTS);\n\tif (!stbl->TimeToSample) return GF_OUT_OF_MEM;\n\tstbl->ChunkOffset = (GF_Box *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STCO);\n\tif (!stbl->ChunkOffset) return GF_OUT_OF_MEM;\n\tstbl->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSC);\n\tif (!stbl->SampleToChunk) return GF_OUT_OF_MEM;\n\tstbl->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\tif (!stbl->SyncSample) return GF_OUT_OF_MEM;\n\tstbl->SampleDescription = (GF_SampleDescriptionBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSD);\n\tif (!stbl->SampleDescription) return GF_OUT_OF_MEM;\n\n\ttrak->dts_at_seg_start = tfdt;\n\ttrak->dts_at_next_seg_start = tfdt;\n\n\n\tif (!stricmp(sz4cc, \"H264\") || !stricmp(sz4cc, \"AVC1\")) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tu32 pos = 0;\n\t\tu32 end, sc_size=0;\n#endif\n\t\tGF_MPEGVisualSampleEntryBox *avc =  (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new_parent(&stbl->SampleDescription->child_boxes, GF_ISOM_BOX_TYPE_AVC1);\n\t\tif (!avc) return GF_OUT_OF_MEM;\n\t\tavc->avc_config =  (GF_AVCConfigurationBox *) gf_isom_box_new_parent(&avc->child_boxes, GF_ISOM_BOX_TYPE_AVCC);\n\t\tif (!avc->avc_config) return GF_OUT_OF_MEM;\n\n\t\tavc->Width = width;\n\t\tavc->Height = height;\n\n\t\tavc->avc_config->config = gf_odf_avc_cfg_new();\n\t\tavc->avc_config->config->nal_unit_size = nal_len;\n\t\tavc->avc_config->config->configurationVersion = 1;\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t//locate pps and sps\n\t\tgf_media_nalu_next_start_code((u8 *) CodecParams, CodecParamLen, &sc_size);\n\t\tpos += sc_size;\n\t\twhile (pos<CodecParamLen) {\n\t\t\tGF_NALUFFParam *slc;\n\t\t\tu8 nal_type;\n\t\t\tchar *nal = &CodecParams[pos];\n\t\t\tend = gf_media_nalu_next_start_code(nal, CodecParamLen-pos, &sc_size);\n\t\t\tif (!end) end = CodecParamLen;\n\n\t\t\tGF_SAFEALLOC(slc, GF_NALUFFParam);\n\t\t\tif (!slc) break;\n\t\t\tslc->size = end;\n\t\t\tslc->data = gf_malloc(sizeof(char)*slc->size);\n\t\t\tif (!slc->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(slc->data, nal, sizeof(char)*slc->size);\n\n\t\t\tnal_type = nal[0] & 0x1F;\n\t\t\tif (nal_type == GF_AVC_NALU_SEQ_PARAM) {\n/*\t\t\t\tAVCState avcc;\n\t\t\t\tu32 idx = gf_avc_read_sps(slc->data, slc->size, &avcc, 0, NULL);\n\t\t\t\tavc->avc_config->config->profile_compatibility = avcc.sps[idx].prof_compat;\n\t\t\t\tavc->avc_config->config->AVCProfileIndication = avcc.sps[idx].profile_idc;\n\t\t\t\tavc->avc_config->config->AVCLevelIndication = avcc.sps[idx].level_idc;\n\t\t\t\tavc->avc_config->config->chroma_format = avcc.sps[idx].chroma_format;\n\t\t\t\tavc->avc_config->config->luma_bit_depth = 8 + avcc.sps[idx].luma_bit_depth_m8;\n\t\t\t\tavc->avc_config->config->chroma_bit_depth = 8 + avcc.sps[idx].chroma_bit_depth_m8;\n*/\n\n\t\t\t\tgf_list_add(avc->avc_config->config->sequenceParameterSets, slc);\n\t\t\t} else {\n\t\t\t\tgf_list_add(avc->avc_config->config->pictureParameterSets, slc);\n\t\t\t}\n\t\t\tpos += slc->size + sc_size;\n\t\t}\n#endif\n\n\t\tAVC_RewriteESDescriptor(avc);\n\t}\n\telse if (!stricmp(sz4cc, \"AACL\")) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tGF_M4ADecSpecInfo aacinfo;\n#endif\n\n\t\tGF_MPEGAudioSampleEntryBox *aac =  (GF_MPEGAudioSampleEntryBox *) gf_isom_box_new_parent(&stbl->SampleDescription->child_boxes, GF_ISOM_BOX_TYPE_MP4A);\n\t\tif (!aac) return GF_OUT_OF_MEM;\n\t\taac->esd = (GF_ESDBox *) gf_isom_box_new_parent(&aac->child_boxes, GF_ISOM_BOX_TYPE_ESDS);\n\t\tif (!aac->esd) return GF_OUT_OF_MEM;\n\t\taac->esd->desc = gf_odf_desc_esd_new(2);\n\t\tif (!aac->esd->desc) return GF_OUT_OF_MEM;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tmemset(&aacinfo, 0, sizeof(GF_M4ADecSpecInfo));\n\t\taacinfo.nb_chan = nb_channels;\n\t\taacinfo.base_object_type = GF_M4A_AAC_LC;\n\t\taacinfo.base_sr = sample_rate;\n\t\tgf_m4a_write_config(&aacinfo, &aac->esd->desc->decoderConfig->decoderSpecificInfo->data, &aac->esd->desc->decoderConfig->decoderSpecificInfo->dataLength);\n#endif\n\t\taac->esd->desc->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\taac->esd->desc->decoderConfig->objectTypeIndication = GF_CODECID_AAC_MPEG4;\n\t\taac->bitspersample = bps;\n\t\taac->samplerate_hi = sample_rate;\n\t\taac->channel_count = nb_channels;\n\t}\n\n\treturn GF_OK;\n}\n\n/**************************************************************\n\t\t\t\t\tFile Opening in streaming mode\n\t\t\tthe file map is regular (through FILE handles)\n**************************************************************/\nGF_EXPORT\nGF_Err gf_isom_open_progressive_ex(const char *fileName, u64 start_range, u64 end_range, Bool enable_frag_bounds, GF_ISOFile **the_file, u64 *BytesMissing, u32 *outBoxType)\n{\n\tGF_Err e;\n\tGF_ISOFile *movie;\n\n\tif (!BytesMissing || !the_file)\n\t\treturn GF_BAD_PARAM;\n\t*BytesMissing = 0;\n\t*the_file = NULL;\n\n\tmovie = gf_isom_new_movie();\n\tif (!movie) return GF_OUT_OF_MEM;\n\n\tmovie->fileName = gf_strdup(fileName);\n\tmovie->openMode = GF_ISOM_OPEN_READ;\n\tmovie->signal_frag_bounds = enable_frag_bounds;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tmovie->editFileMap = NULL;\n\tmovie->finalName = NULL;\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\tif (!strncmp(fileName, \"isobmff://\", 10)) {\n\t\tmovie->movieFileMap = NULL;\n\t\te = isom_create_init_from_mem(fileName, movie);\n\t} else {\n\t\t//do NOT use FileMapping on incomplete files\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_READ, &movie->movieFileMap);\n\t\tif (e) {\n\t\t\tgf_isom_delete_movie(movie);\n\t\t\treturn e;\n\t\t}\n\n\t\tif (start_range || end_range) {\n\t\t\tif (end_range>start_range) {\n\t\t\t\tgf_bs_seek(movie->movieFileMap->bs, end_range+1);\n\t\t\t\tgf_bs_truncate(movie->movieFileMap->bs);\n\t\t\t}\n\t\t\tgf_bs_seek(movie->movieFileMap->bs, start_range);\n\t\t}\n\t\te = gf_isom_parse_movie_boxes(movie, outBoxType, BytesMissing, GF_TRUE);\n\n\t}\n\tif (e == GF_ISOM_INCOMPLETE_FILE) {\n\t\t//if we have a moov, we're fine\n\t\tif (movie->moov) {\n\t\t\t*the_file = (GF_ISOFile *)movie;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//if not, delete the movie\n\t\tgf_isom_delete_movie(movie);\n\t\treturn e;\n\t} else if (e) {\n\t\t//if not, delete the movie\n\t\tgf_isom_delete_movie(movie);\n\t\treturn e;\n\t}\n\n\t//OK, let's return\n\t*the_file = (GF_ISOFile *)movie;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_open_progressive(const char *fileName, u64 start_range, u64 end_range, Bool enable_frag_bounds, GF_ISOFile **the_file, u64 *BytesMissing)\n{\n\treturn gf_isom_open_progressive_ex(fileName, start_range, end_range, enable_frag_bounds, the_file, BytesMissing, NULL);\n}\n\n/**************************************************************\n\t\t\t\t\tFile Reading\n**************************************************************/\n\nGF_EXPORT\nGF_ISOFile *gf_isom_open(const char *fileName, GF_ISOOpenMode OpenMode, const char *tmp_dir)\n{\n\tGF_ISOFile *movie;\n\tMP4_API_IO_Err = GF_OK;\n\n\tswitch (OpenMode & 0xFF) {\n\tcase GF_ISOM_OPEN_READ_DUMP:\n\tcase GF_ISOM_OPEN_READ:\n\t\tmovie = gf_isom_open_file(fileName, OpenMode, NULL);\n\t\tbreak;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\tcase GF_ISOM_OPEN_WRITE:\n\t\tmovie = gf_isom_create_movie(fileName, OpenMode, tmp_dir);\n\t\tbreak;\n\tcase GF_ISOM_OPEN_EDIT:\n\tcase GF_ISOM_OPEN_READ_EDIT:\n\tcase GF_ISOM_OPEN_KEEP_FRAGMENTS:\n\t\tmovie = gf_isom_open_file(fileName, OpenMode, tmp_dir);\n\t\tbreak;\n\tcase GF_ISOM_WRITE_EDIT:\n\t\tmovie = gf_isom_create_movie(fileName, OpenMode, tmp_dir);\n\t\tbreak;\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\tdefault:\n\t\treturn NULL;\n\t}\n\treturn (GF_ISOFile *) movie;\n}\n\n\n#if 0\n/*! gets access to the data bitstream  - see \\ref gf_isom_open\n\\param isom_file the target ISO file\n\\param out_bs set to the file input bitstream - do NOT destroy\n\\return error if any\n*/\nGF_Err gf_isom_get_bs(GF_ISOFile *movie, GF_BitStream **out_bs)\n{\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (!movie || movie->openMode != GF_ISOM_OPEN_WRITE || !movie->editFileMap) //memory mode\n\t\treturn GF_NOT_SUPPORTED;\n\n\tif (movie->segment_bs)\n\t\t*out_bs = movie->segment_bs;\n\telse\n\t\t*out_bs = movie->editFileMap->bs;\n\n\tif (movie->moof)\n\t\tmovie->moof->fragment_offset = 0;\n\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_isom_write(GF_ISOFile *movie) {\n\tGF_Err e;\n\tif (movie == NULL) return GF_ISOM_INVALID_FILE;\n\te = GF_OK;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t//write our movie to the file\n\tif ((movie->openMode != GF_ISOM_OPEN_READ) && (movie->openMode != GF_ISOM_OPEN_READ_EDIT)) {\n\t\tgf_isom_get_duration(movie);\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t//movie fragment mode, just store the fragment\n\t\tif ( (movie->openMode == GF_ISOM_OPEN_WRITE) && (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) {\n\t\t\te = gf_isom_close_fragments(movie);\n\t\t\tif (e) return e;\n\t\t\t//in case of mfra box usage -> create mfro, calculate box sizes and write it out\n\t\t\tif (movie->mfra) {\n\t\t\t\tif (!movie->mfra->mfro) {\n\t\t\t\t\tmovie->mfra->mfro = (GF_MovieFragmentRandomAccessOffsetBox *)gf_isom_box_new_parent(&movie->mfra->child_boxes, GF_ISOM_BOX_TYPE_MFRO);\n\t\t\t\t\tif (!movie->mfra->mfro) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\te = gf_isom_box_size((GF_Box *)movie->mfra);\n\t\t\t\tif (e) return e;\n\t\t\t\tmovie->mfra->mfro->container_size = (u32) movie->mfra->size;\n\n\t\t\t\t//write mfra\n\t\t\t\tif (!strcmp(movie->fileName, \"_gpac_isobmff_redirect\") && movie->on_block_out) {\n\t\t\t\t\tGF_BitStream *bs = gf_bs_new_cbk(movie->on_block_out, movie->on_block_out_usr_data, movie->on_block_out_block_size);\n\n\t\t\t\t\te = gf_isom_box_write((GF_Box *)movie->mfra, bs);\n\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t} else {\n\t\t\t\t\te = gf_isom_box_write((GF_Box *)movie->mfra, movie->editFileMap->bs);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n#endif\n\t\t\te = WriteToFile(movie, GF_FALSE);\n\t}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (movie->moov) {\n\t\tu32 i;\n\t\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\t\t/*delete any pending dataHandler of scalable enhancements*/\n\t\t\tif (trak->Media && trak->Media->information && trak->Media->information->scalableDataHandler && (trak->Media->information->scalableDataHandler != movie->movieFileMap))\n\t\t\t\tgf_isom_datamap_del(trak->Media->information->scalableDataHandler);\n\t\t}\n\t}\n#endif\n\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_close(GF_ISOFile *movie)\n{\n\tGF_Err e=GF_OK;\n\tif (movie == NULL) return GF_ISOM_INVALID_FILE;\n\te = gf_isom_write(movie);\n\t//free and return;\n\tgf_isom_delete_movie(movie);\n\treturn e;\n}\n\n\n#if 0 //unused\n/*! checks if files has root OD/IOD or not\n\\param isom_file the target ISO file\n\\return GF_TRUE if the file has a root OD or IOD */\nBool gf_isom_has_root_od(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov || !movie->moov->iods || !movie->moov->iods->descriptor) return GF_FALSE;\n\treturn GF_TRUE;\n}\n#endif\n\nGF_EXPORT\nvoid gf_isom_disable_odf_conversion(GF_ISOFile *movie, Bool disable)\n{\n\tif (movie) movie->disable_odf_translate = disable;\n}\n\n//this funct is used for exchange files, where the iods contains an OD\nGF_EXPORT\nGF_Descriptor *gf_isom_get_root_od(GF_ISOFile *movie)\n{\n\tGF_Descriptor *desc;\n\tGF_ObjectDescriptor *od;\n\tGF_InitialObjectDescriptor *iod;\n\tGF_IsomObjectDescriptor *isom_od;\n\tGF_IsomInitialObjectDescriptor *isom_iod;\n\tGF_ESD *esd;\n\tGF_ES_ID_Inc *inc;\n\tu32 i;\n\tu8 useIOD;\n\n\tif (!movie || !movie->moov) return NULL;\n\tif (!movie->moov->iods) return NULL;\n\n\tif (movie->disable_odf_translate) {\n\t\t//duplicate our descriptor\n\t\tmovie->LastError = gf_odf_desc_copy((GF_Descriptor *) movie->moov->iods->descriptor, &desc);\n\t\tif (movie->LastError) return NULL;\n\t\treturn desc;\n\t}\n\tod = NULL;\n\tiod = NULL;\n\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tod = (GF_ObjectDescriptor*)gf_malloc(sizeof(GF_ObjectDescriptor));\n\t\tif (!od) return NULL;\n\n\t\tmemset(od, 0, sizeof(GF_ObjectDescriptor));\n\t\tod->ESDescriptors = gf_list_new();\n\t\tuseIOD = 0;\n\t\tbreak;\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tiod = (GF_InitialObjectDescriptor*)gf_malloc(sizeof(GF_InitialObjectDescriptor));\n\t\tif (!iod) return NULL;\n\n\t\tmemset(iod, 0, sizeof(GF_InitialObjectDescriptor));\n\t\tiod->ESDescriptors = gf_list_new();\n\t\tuseIOD = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\t//duplicate our descriptor\n\tmovie->LastError = gf_odf_desc_copy((GF_Descriptor *) movie->moov->iods->descriptor, &desc);\n\tif (movie->LastError) {\n\t\tif (od) {\n\t\t\tgf_list_del(od->ESDescriptors);\n\t\t\tgf_free(od);\n\t\t}\n\t\tif (iod) {\n\t\t\tgf_list_del(iod->ESDescriptors);\n\t\t\tgf_free(iod);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (!useIOD) {\n\t\tisom_od = (GF_IsomObjectDescriptor *)desc;\n\t\tod->objectDescriptorID = isom_od->objectDescriptorID;\n\t\tod->extensionDescriptors = isom_od->extensionDescriptors;\n\t\tisom_od->extensionDescriptors = NULL;\n\t\tod->IPMP_Descriptors = isom_od->IPMP_Descriptors;\n\t\tisom_od->IPMP_Descriptors = NULL;\n\t\tod->OCIDescriptors = isom_od->OCIDescriptors;\n\t\tisom_od->OCIDescriptors = NULL;\n\t\tod->URLString = isom_od->URLString;\n\t\tisom_od->URLString = NULL;\n\t\tod->tag = GF_ODF_OD_TAG;\n\t\t//then recreate the desc in Inc\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(isom_od->ES_ID_IncDescriptors, &i))) {\n\t\t\tmovie->LastError = GetESDForTime(movie->moov, inc->trackID, 0, &esd);\n\t\t\tif (!movie->LastError) movie->LastError = gf_list_add(od->ESDescriptors, esd);\n\t\t\tif (movie->LastError) {\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) od);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tgf_odf_desc_del(desc);\n\t\treturn (GF_Descriptor *)od;\n\t} else {\n\t\tisom_iod = (GF_IsomInitialObjectDescriptor *)desc;\n\t\tiod->objectDescriptorID = isom_iod->objectDescriptorID;\n\t\tiod->extensionDescriptors = isom_iod->extensionDescriptors;\n\t\tisom_iod->extensionDescriptors = NULL;\n\t\tiod->IPMP_Descriptors = isom_iod->IPMP_Descriptors;\n\t\tisom_iod->IPMP_Descriptors = NULL;\n\t\tiod->OCIDescriptors = isom_iod->OCIDescriptors;\n\t\tisom_iod->OCIDescriptors = NULL;\n\t\tiod->URLString = isom_iod->URLString;\n\t\tisom_iod->URLString = NULL;\n\t\tiod->tag = GF_ODF_IOD_TAG;\n\n\t\tiod->audio_profileAndLevel = isom_iod->audio_profileAndLevel;\n\t\tiod->graphics_profileAndLevel = isom_iod->graphics_profileAndLevel;\n\t\tiod->inlineProfileFlag = isom_iod->inlineProfileFlag;\n\t\tiod->OD_profileAndLevel = isom_iod->OD_profileAndLevel;\n\t\tiod->scene_profileAndLevel = isom_iod->scene_profileAndLevel;\n\t\tiod->visual_profileAndLevel = isom_iod->visual_profileAndLevel;\n\t\tiod->IPMPToolList = isom_iod->IPMPToolList;\n\t\tisom_iod->IPMPToolList = NULL;\n\n\t\t//then recreate the desc in Inc\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(isom_iod->ES_ID_IncDescriptors, &i))) {\n\t\t\tmovie->LastError = GetESDForTime(movie->moov, inc->trackID, 0, &esd);\n\t\t\tif (!movie->LastError) movie->LastError = gf_list_add(iod->ESDescriptors, esd);\n\t\t\tif (movie->LastError) {\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) iod);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tgf_odf_desc_del(desc);\n\t\treturn (GF_Descriptor *)iod;\n\t}\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_track_count(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov) return 0;\n\n\tif (!movie->moov->trackList) {\n\t\tmovie->LastError = GF_ISOM_INVALID_FILE;\n\t\treturn 0;\n\t}\n\treturn gf_list_count(movie->moov->trackList);\n}\n\n\nGF_EXPORT\nGF_ISOTrackID gf_isom_get_track_id(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tif (!movie) return 0;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Header) return 0;\n\treturn trak->Header->trackID;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_track_by_id(GF_ISOFile *the_file, GF_ISOTrackID trackID)\n{\n\tu32 count;\n\tu32 i;\n\tif (the_file == NULL) return 0;\n\n\tcount = gf_isom_get_track_count(the_file);\n\tif (!count) return 0;\n\tfor (i = 0; i < count; i++) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, i+1);\n\t\tif (!trak || !trak->Header) return 0;\n\t\tif (trak->Header->trackID == trackID) return i+1;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nGF_ISOTrackID gf_isom_get_track_original_id(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tif (!movie) return 0;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->originalID;\n}\n\n//return the timescale of the movie, 0 if error\nGF_EXPORT\nBool gf_isom_has_movie(GF_ISOFile *file)\n{\n\tif (file && file->moov) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\n#ifndef GPAC_DISABLE_ISOM\nGF_EXPORT\nBool gf_isom_has_segment(GF_ISOFile *file, u32 *brand, u32 *version)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i;\n\tGF_Box *a;\n\ti = 0;\n\twhile (NULL != (a = (GF_Box*)gf_list_enum(file->TopBoxes, &i))) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (a->type == GF_ISOM_BOX_TYPE_STYP) {\n\t\t\tGF_FileTypeBox *styp = (GF_FileTypeBox *)a;\n\t\t\t*brand = styp->majorBrand;\n\t\t\t*version = styp->minorVersion;\n\t\t\treturn GF_TRUE;\n\t\t}\n#endif\n\t}\n#endif\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_segment_get_fragment_count(GF_ISOFile *file)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (file) {\n\t\tu32 i, count = 0;\n\t\tfor (i=0; i<gf_list_count(file->TopBoxes); i++) {\n\t\t\tGF_Box *a = (GF_Box*)gf_list_get(file->TopBoxes, i);\n\t\t\tif (a->type==GF_ISOM_BOX_TYPE_MOOF) count++;\n\t\t}\n\t\treturn count;\n\t}\n#endif\n\treturn 0;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nstatic GF_MovieFragmentBox *gf_isom_get_moof(GF_ISOFile *file, u32 moof_index)\n{\n\tu32 i;\n\tfor (i=0; i<gf_list_count(file->TopBoxes); i++) {\n\t\tGF_Box *a = (GF_Box*)gf_list_get(file->TopBoxes, i);\n\t\tif (a->type==GF_ISOM_BOX_TYPE_MOOF) {\n\t\t\tmoof_index--;\n\t\t\tif (!moof_index) return (GF_MovieFragmentBox *) a;\n\t\t}\n\t}\n\treturn NULL;\n}\n#endif /* GPAC_DISABLE_ISOM_FRAGMENTS */\n\nGF_EXPORT\nu32 gf_isom_segment_get_track_fragment_count(GF_ISOFile *file, u32 moof_index)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_MovieFragmentBox *moof;\n\tif (!file) return 0;\n\tgf_list_count(file->TopBoxes);\n\tmoof = gf_isom_get_moof(file, moof_index);\n\treturn moof ? gf_list_count(moof->TrackList) : 0;\n#endif\n\treturn 0;\n}\n\nGF_EXPORT\nu32 gf_isom_segment_get_track_fragment_decode_time(GF_ISOFile *file, u32 moof_index, u32 traf_index, u64 *decode_time)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_MovieFragmentBox *moof;\n\tGF_TrackFragmentBox *traf;\n\tif (!file) return 0;\n\tgf_list_count(file->TopBoxes);\n\tmoof = gf_isom_get_moof(file, moof_index);\n\ttraf = moof ? (GF_TrackFragmentBox*)gf_list_get(moof->TrackList, traf_index-1) : NULL;\n\tif (!traf) return 0;\n\tif (decode_time) {\n\t\t*decode_time = traf->tfdt ? traf->tfdt->baseMediaDecodeTime : 0;\n\t}\n\treturn traf->tfhd->trackID;\n#endif\n\treturn 0;\n}\n#endif\n\n//return the timescale of the movie, 0 if error\nGF_EXPORT\nu32 gf_isom_get_timescale(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov || !movie->moov->mvhd) return 0;\n\treturn movie->moov->mvhd->timeScale;\n}\n\n\n//return the duration of the movie, 0 if error\nGF_EXPORT\nu64 gf_isom_get_duration(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov || !movie->moov->mvhd) return 0;\n\n\t//if file was open in Write or Edit mode, recompute the duration\n\t//the duration of a movie is the MaxDuration of all the tracks...\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tgf_isom_update_duration(movie);\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\treturn movie->moov->mvhd->duration;\n}\n//return the duration of the movie, 0 if error\nGF_EXPORT\nu64 gf_isom_get_original_duration(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov|| !movie->moov->mvhd) return 0;\n\treturn movie->moov->mvhd->original_duration;\n}\n\n//return the creation info of the movie\nGF_EXPORT\nGF_Err gf_isom_get_creation_time(GF_ISOFile *movie, u64 *creationTime, u64 *modificationTime)\n{\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n\tif (creationTime) *creationTime = movie->moov->mvhd->creationTime;\n\tif (creationTime) *modificationTime = movie->moov->mvhd->modificationTime;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_creation_time(GF_ISOFile *movie, u32 trackNumber, u64 *creationTime, u64 *modificationTime)\n{\n\tGF_TrackBox *trak;\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n\tif (creationTime) *creationTime = trak->Media->mediaHeader->creationTime;\n\tif (creationTime) *modificationTime = trak->Media->mediaHeader->modificationTime;\n\treturn GF_OK;\n}\n\n//check the presence of a track in IOD. 0: NO, 1: YES, 2: ERROR\nGF_EXPORT\nu8 gf_isom_is_track_in_root_od(GF_ISOFile *movie, u32 trackNumber)\n{\n\tu32 i;\n\tGF_ISOTrackID trackID;\n\tGF_Descriptor *desc;\n\tGF_ES_ID_Inc *inc;\n\tGF_List *inc_list;\n\tif (!movie) return 2;\n\tif (!movie->moov || !movie->moov->iods) return 0;\n\n\tdesc = movie->moov->iods->descriptor;\n\tswitch (desc->tag) {\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tinc_list = ((GF_IsomInitialObjectDescriptor *)desc)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tinc_list = ((GF_IsomObjectDescriptor *)desc)->ES_ID_IncDescriptors;\n\t\tbreak;\n\t//files without IOD are possible !\n\tdefault:\n\t\treturn 0;\n\t}\n\ttrackID = gf_isom_get_track_id(movie, trackNumber);\n\tif (!trackID) return 2;\n\ti=0;\n\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(inc_list, &i))) {\n\t\tif (inc->trackID == (u32) trackID) return 1;\n\t}\n\treturn 0;\n}\n\n\n\n//gets the enable flag of a track\n//0: NO, 1: YES, 2: ERROR\nGF_EXPORT\nu8 gf_isom_is_track_enabled(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\n\tif (!trak || !trak->Header) return 2;\n\treturn (trak->Header->flags & 1) ? 1 : 0;\n}\n\nGF_EXPORT\nu32 gf_isom_get_track_flags(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->Header->flags;\n}\n\n\n//get the track duration\n//return 0 if bad param\nGF_EXPORT\nu64 gf_isom_get_track_duration(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t/*in all modes except dump recompute duration in case headers are wrong*/\n\tif (movie->openMode != GF_ISOM_OPEN_READ_DUMP) {\n\t\tSetTrackDuration(trak);\n\t}\n#endif\n\treturn trak->Header->duration;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_media_language(GF_ISOFile *the_file, u32 trackNumber, char **lang)\n{\n\tu32 count;\n\tBool elng_found = GF_FALSE;\n\tGF_TrackBox *trak;\n\tif (!lang) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\t*lang = NULL;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tcount = gf_list_count(trak->Media->child_boxes);\n\tif (count>0) {\n\t\tu32 i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tGF_Box *box = (GF_Box *)gf_list_get(trak->Media->child_boxes, i);\n\t\t\tif (box->type == GF_ISOM_BOX_TYPE_ELNG) {\n\t\t\t\t*lang = gf_strdup(((GF_ExtendedLanguageBox *)box)->extended_language);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t}\n\tif (!elng_found) {\n\t\t*lang = gf_strdup(trak->Media->mediaHeader->packedLanguage);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_isom_get_track_kind_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\t\tif (!trak) return 0;\n\t\tif (!trak->udta) {\n\t\t\treturn 0;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\treturn 0;\n\t}\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_KIND, NULL);\n\tif (!map) return 0;\n\n\treturn gf_list_count(map->boxes);\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_kind(GF_ISOFile *the_file, u32 trackNumber, u32 index, char **scheme, char **value)\n{\n\tGF_Err e;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tGF_KindBox *kindBox;\n\tif (!scheme || !value) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\t*scheme = NULL;\n\t*value = NULL;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_KIND, NULL);\n\tif (!map) return GF_BAD_PARAM;\n\n\tkindBox = (GF_KindBox *)gf_list_get(map->boxes, index);\n\tif (!kindBox) return GF_BAD_PARAM;\n\n\t*scheme = gf_strdup(kindBox->schemeURI);\n\tif (kindBox->value) {\n\t\t*value = gf_strdup(kindBox->value);\n\t}\n\treturn GF_OK;\n}\n\n\n//Return the number of track references of a track for a given ReferenceType\n//return 0 if error\nGF_EXPORT\ns32 gf_isom_get_reference_count(GF_ISOFile *movie, u32 trackNumber, u32 referenceType)\n{\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return -1;\n\tif (!trak->References) return 0;\n\tif (movie->openMode == GF_ISOM_OPEN_WRITE) {\n\t\tmovie->LastError = GF_ISOM_INVALID_MODE;\n\t\treturn -1;\n\t}\n\n\tdpnd = NULL;\n\tif ( (movie->LastError = Track_FindRef(trak, referenceType, &dpnd)) ) return -1;\n\tif (!dpnd) return 0;\n\treturn dpnd->trackIDCount;\n}\n\n\n//Return the number of track references of a track for a given ReferenceType\n//return 0 if error\nGF_EXPORT\nconst GF_ISOTrackID *gf_isom_enum_track_references(GF_ISOFile *movie, u32 trackNumber, u32 idx, u32 *referenceType, u32 *referenceCount)\n{\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return NULL;\n\tif (!trak->References) return NULL;\n\tdpnd = gf_list_get(trak->References->child_boxes, idx);\n\tif (!dpnd) return NULL;\n\t*referenceType = dpnd->reference_type;\n\t*referenceCount = dpnd->trackIDCount;\n\treturn dpnd->trackIDs;\n}\n\n\n//Return the referenced track number for a track and a given ReferenceType and Index\n//return -1 if error, 0 if the reference is a NULL one, or the trackNumber\nGF_EXPORT\nGF_Err gf_isom_get_reference(GF_ISOFile *movie, u32 trackNumber, u32 referenceType, u32 referenceIndex, u32 *refTrack)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_ISOTrackID refTrackNum;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\n\t*refTrack = 0;\n\tif (!trak || !trak->References) return GF_BAD_PARAM;\n\n\tdpnd = NULL;\n\te = Track_FindRef(trak, referenceType, &dpnd);\n\tif (e) return e;\n\tif (!dpnd) return GF_BAD_PARAM;\n\n\tif (!referenceIndex || (referenceIndex > dpnd->trackIDCount)) return GF_BAD_PARAM;\n\n\t//the spec allows a NULL reference\n\t//(ex, to force desync of a track, set a sync ref with ID = 0)\n\tif (dpnd->trackIDs[referenceIndex - 1] == 0) return GF_OK;\n\n\trefTrackNum = gf_isom_get_tracknum_from_id(movie->moov, dpnd->trackIDs[referenceIndex-1]);\n\n\t//if the track was not found, this means the file is broken !!!\n\tif (! refTrackNum) return GF_ISOM_INVALID_FILE;\n\t*refTrack = refTrackNum;\n\treturn GF_OK;\n}\n\n//Return the referenced track ID for a track and a given ReferenceType and Index\n//return -1 if error, 0 if the reference is a NULL one, or the trackNumber\nGF_EXPORT\nGF_Err gf_isom_get_reference_ID(GF_ISOFile *movie, u32 trackNumber, u32 referenceType, u32 referenceIndex, GF_ISOTrackID *refTrackID)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\n\t*refTrackID = 0;\n\tif (!trak || !trak->References || !referenceIndex) return GF_BAD_PARAM;\n\n\tdpnd = NULL;\n\te = Track_FindRef(trak, referenceType, &dpnd);\n\tif (e) return e;\n\tif (!dpnd) return GF_BAD_PARAM;\n\n\tif (referenceIndex > dpnd->trackIDCount) return GF_BAD_PARAM;\n\n\t*refTrackID = dpnd->trackIDs[referenceIndex-1];\n\n\treturn GF_OK;\n}\n\n//Return referenceIndex if the given track has a reference to the given TreckID of a given ReferenceType\n//return 0 if error\nGF_EXPORT\nu32 gf_isom_has_track_reference(GF_ISOFile *movie, u32 trackNumber, u32 referenceType, GF_ISOTrackID refTrackID)\n{\n\tu32 i;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\tif (!trak->References) return 0;\n\n\tdpnd = NULL;\n\tif ( (movie->LastError = Track_FindRef(trak, referenceType, &dpnd)) ) return 0;\n\tif (!dpnd) return 0;\n\tfor (i=0; i<dpnd->trackIDCount; i++) {\n\t\tif (dpnd->trackIDs[i]==refTrackID) return i+1;\n\t}\n\treturn 0;\n}\n\n\n\n//Return the media time given the absolute time in the Movie\nGF_EXPORT\nGF_Err gf_isom_get_media_time(GF_ISOFile *the_file, u32 trackNumber, u32 movieTime, u64 *MediaTime)\n{\n\tGF_TrackBox *trak;\n\tu8 useEdit;\n\ts64 SegmentStartTime, mediaOffset;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !MediaTime) return GF_BAD_PARAM;\n\n\tSegmentStartTime = 0;\n\treturn GetMediaTime(trak, GF_FALSE, movieTime, MediaTime, &SegmentStartTime, &mediaOffset, &useEdit, NULL);\n}\n\n\n//Get the stream description index (eg, the ESD) for a given time IN MEDIA TIMESCALE\n//return 0 if error or if empty\nGF_EXPORT\nu32 gf_isom_get_sample_description_index(GF_ISOFile *movie, u32 trackNumber, u64 for_time)\n{\n\tu32 streamDescIndex;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n\tif ( (movie->LastError = Media_GetSampleDescIndex(trak->Media, for_time, &streamDescIndex)) ) {\n\t\treturn 0;\n\t}\n\treturn streamDescIndex;\n}\n\n//Get the number of \"streams\" stored in the media - a media can have several stream descriptions...\nGF_EXPORT\nu32 gf_isom_get_sample_description_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\treturn gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n}\n\n\n//Get the GF_ESD given the StreamDescriptionIndex\n//THE DESCRIPTOR IS DUPLICATED, SO HAS TO BE DELETED BY THE APP\nGF_EXPORT\nGF_ESD *gf_isom_get_esd(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_ESD *esd;\n\tGF_Err e;\n\te = GetESD(movie->moov, gf_isom_get_track_id(movie, trackNumber), StreamDescriptionIndex, &esd);\n\tif (e && (e!= GF_ISOM_INVALID_MEDIA)) {\n\t\tmovie->LastError = e;\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\t\treturn NULL;\n\t}\n\n\treturn esd;\n}\n\n//Get the decoderConfigDescriptor given the SampleDescriptionIndex\n//THE DESCRIPTOR IS DUPLICATED, SO HAS TO BE DELETED BY THE APP\nGF_EXPORT\nGF_DecoderConfig *gf_isom_get_decoder_config(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_ESD *esd;\n\tGF_Descriptor *decInfo;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\t//get the ESD (possibly emulated)\n\tMedia_GetESD(trak->Media, StreamDescriptionIndex, &esd, GF_FALSE);\n\tif (!esd) return NULL;\n\tdecInfo = (GF_Descriptor *) esd->decoderConfig;\n\tesd->decoderConfig = NULL;\n\tgf_odf_desc_del((GF_Descriptor *) esd);\n\treturn (GF_DecoderConfig *)decInfo;\n}\n\n\n//get the media duration (without edit)\n//return 0 if bad param\nGF_EXPORT\nu64 gf_isom_get_media_duration(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\t/*except in dump mode always recompute the duration*/\n\tif (movie->openMode != GF_ISOM_OPEN_READ_DUMP) {\n\t\tif ( (movie->LastError = Media_SetDuration(trak)) ) return 0;\n\t}\n\n#endif\n\n\treturn trak->Media->mediaHeader->duration;\n}\n\n//get the media duration (without edit)\n//return 0 if bad param\nGF_EXPORT\nu64 gf_isom_get_media_original_duration(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->mediaHeader) return 0;\n\n\treturn trak->Media->mediaHeader->original_duration;\n}\n\n//Get the timeScale of the media. All samples DTS/CTS are expressed in this timeScale\nGF_EXPORT\nu32 gf_isom_get_media_timescale(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->mediaHeader) return 0;\n\treturn trak->Media->mediaHeader->timeScale;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_copyright_count(GF_ISOFile *mov)\n{\n\tGF_UserDataMap *map;\n\tif (!mov || !mov->moov || !mov->moov->udta) return 0;\n\tmap = udta_getEntry(mov->moov->udta, GF_ISOM_BOX_TYPE_CPRT, NULL);\n\tif (!map) return 0;\n\treturn gf_list_count(map->boxes);\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_copyright(GF_ISOFile *mov, u32 Index, const char **threeCharCode, const char **notice)\n{\n\tGF_UserDataMap *map;\n\tGF_CopyrightBox *cprt;\n\n\tif (!mov || !mov->moov || !Index) return GF_BAD_PARAM;\n\n\tif (!mov->moov->udta) return GF_OK;\n\tmap = udta_getEntry(mov->moov->udta, GF_ISOM_BOX_TYPE_CPRT, NULL);\n\tif (!map) return GF_OK;\n\n\tif (Index > gf_list_count(map->boxes)) return GF_BAD_PARAM;\n\n\tcprt = (GF_CopyrightBox*)gf_list_get(map->boxes, Index-1);\n\t(*threeCharCode) = cprt->packedLanguageCode;\n\t(*notice) = cprt->notice;\n\treturn GF_OK;\n}\n\n#if 0\nGF_Err gf_isom_get_watermark(GF_ISOFile *mov, bin128 UUID, u8** data, u32* length)\n{\n\tGF_UserDataMap *map;\n\tGF_UnknownUUIDBox *wm;\n\n\tif (!mov) return GF_BAD_PARAM;\n\tif (!mov->moov || !mov->moov->udta) return GF_NOT_SUPPORTED;\n\n\tmap = udta_getEntry(mov->moov->udta, GF_ISOM_BOX_TYPE_UUID, (bin128 *) & UUID);\n\tif (!map) return GF_NOT_SUPPORTED;\n\n\twm = (GF_UnknownUUIDBox*)gf_list_get(map->boxes, 0);\n\tif (!wm) return GF_NOT_SUPPORTED;\n\n\t*data = (u8 *) gf_malloc(sizeof(char)*wm->dataSize);\n\tif (! *data) return GF_OUT_OF_MEM;\n\tmemcpy(*data, wm->data, wm->dataSize);\n\t*length = wm->dataSize;\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nu32 gf_isom_get_chapter_count(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_UserDataMap *map;\n\tGF_ChapterListBox *lst;\n\tGF_UserDataBox *udta;\n\n\tif (!movie || !movie->moov) return 0;\n\n\tudta = NULL;\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return 0;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return 0;\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\tif (!map) return 0;\n\tlst = (GF_ChapterListBox *)gf_list_get(map->boxes, 0);\n\tif (!lst) return 0;\n\treturn gf_list_count(lst->list);\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_chapter(GF_ISOFile *movie, u32 trackNumber, u32 Index, u64 *chapter_time, const char **name)\n{\n\tGF_UserDataMap *map;\n\tGF_ChapterListBox *lst;\n\tGF_ChapterEntry *ce;\n\tGF_UserDataBox *udta;\n\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n\tudta = NULL;\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_BAD_PARAM;\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\tif (!map) return GF_BAD_PARAM;\n\tlst = (GF_ChapterListBox *)gf_list_get(map->boxes, 0);\n\tif (!lst) return GF_BAD_PARAM;\n\n\tce = (GF_ChapterEntry *)gf_list_get(lst->list, Index-1);\n\tif (!ce) return GF_BAD_PARAM;\n\tif (chapter_time) {\n\t\t*chapter_time = ce->start_time;\n\t\t*chapter_time /= 10000L;\n\t}\n\tif (name) *name = ce->name;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_media_type(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\treturn (trak->Media && trak->Media->handler) ? trak->Media->handler->handlerType : 0;\n}\n\nBool IsMP4Description(u32 entryType)\n{\n\tswitch (entryType) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\tcase GF_ISOM_BOX_TYPE_LSR1:\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\tcase GF_ISOM_BOX_TYPE_ENCA:\n\tcase GF_ISOM_BOX_TYPE_ENCV:\n\tcase GF_ISOM_BOX_TYPE_RESV:\n\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nBool gf_isom_is_encrypted_entry(u32 entryType)\n{\n\tswitch (entryType) {\n\tcase GF_ISOM_BOX_TYPE_ENCA:\n\tcase GF_ISOM_BOX_TYPE_ENCV:\n\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nGF_EXPORT\nBool gf_isom_is_track_encrypted(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tu32 i=0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 2;\n\twhile (1) {\n\t\tGF_Box *entry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tif (!entry) break;\n\t\tif (gf_isom_is_encrypted_entry(entry->type)) return GF_TRUE;\n\n\t\tif (gf_isom_is_cenc_media(the_file, trackNumber, i+1))\n\t\t\treturn GF_TRUE;\n\n\t\ti++;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_get_media_subtype(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Box *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !DescriptionIndex || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable) return 0;\n\tentry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return 0;\n\n\t//filter MPEG sub-types\n\tif (IsMP4Description(entry->type)) {\n\t\tif (gf_isom_is_encrypted_entry(entry->type)) return GF_ISOM_SUBTYPE_MPEG4_CRYP;\n\t\telse return GF_ISOM_SUBTYPE_MPEG4;\n\t}\n\tif (entry->type == GF_ISOM_BOX_TYPE_GNRV) {\n\t\treturn ((GF_GenericVisualSampleEntryBox *)entry)->EntryType;\n\t}\n\telse if (entry->type == GF_ISOM_BOX_TYPE_GNRA) {\n\t\treturn ((GF_GenericAudioSampleEntryBox *)entry)->EntryType;\n\t}\n\telse if (entry->type == GF_ISOM_BOX_TYPE_GNRM) {\n\t\treturn ((GF_GenericSampleEntryBox *)entry)->EntryType;\n\t}\n\treturn entry->type;\n}\n\nGF_EXPORT\nu32 gf_isom_get_mpeg4_subtype(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Box *entry=NULL;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !DescriptionIndex) return 0;\n\n\tif (trak->Media\n\t\t&& trak->Media->information\n\t\t&& trak->Media->information->sampleTable\n\t\t&& trak->Media->information->sampleTable->SampleDescription\n\t) {\n\t\tentry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\t}\n\tif (!entry) return 0;\n\n\t//filter MPEG sub-types\n\tif (!IsMP4Description(entry->type)) return 0;\n\treturn entry->type;\n}\n\n//Get the HandlerDescription name.\nGF_EXPORT\nGF_Err gf_isom_get_handler_name(GF_ISOFile *the_file, u32 trackNumber, const char **outName)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !outName) return GF_BAD_PARAM;\n\t*outName = trak->Media->handler->nameUTF8;\n\treturn GF_OK;\n}\n\n//Check the DataReferences of this track\nGF_EXPORT\nGF_Err gf_isom_check_data_reference(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_Err e;\n\tu32 drefIndex;\n\tGF_TrackBox *trak;\n\n\tif (!StreamDescriptionIndex || !trackNumber) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex , NULL, &drefIndex);\n\tif (e) return e;\n\tif (!drefIndex) return GF_BAD_PARAM;\n\treturn Media_CheckDataEntry(trak->Media, drefIndex);\n}\n\n//get the location of the data. If URL && URN are NULL, the data is in this file\nGF_EXPORT\nGF_Err gf_isom_get_data_reference(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const char **outURL, const char **outURN)\n{\n\tGF_TrackBox *trak;\n\tGF_DataEntryURLBox *url=NULL;\n\tGF_DataEntryURNBox *urn;\n\tu32 drefIndex;\n\tGF_Err e;\n\n\t*outURL = *outURN = NULL;\n\n\tif (!StreamDescriptionIndex || !trackNumber) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex , NULL, &drefIndex);\n\tif (e) return e;\n\tif (!drefIndex) return GF_BAD_PARAM;\n\n\tif (trak->Media\n\t\t&& trak->Media->information\n\t\t&& trak->Media->information->dataInformation\n\t\t&& trak->Media->information->dataInformation->dref\n\t) {\n\t\turl = (GF_DataEntryURLBox*)gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, drefIndex - 1);\n\t}\n\tif (!url) return GF_ISOM_INVALID_FILE;\n\n\tif (url->type == GF_ISOM_BOX_TYPE_URL) {\n\t\t*outURL = url->location;\n\t\t*outURN = NULL;\n\t} else if (url->type == GF_ISOM_BOX_TYPE_URN) {\n\t\turn = (GF_DataEntryURNBox *) url;\n\t\t*outURN = urn->nameURN;\n\t\t*outURL = urn->location;\n\t} else {\n\t\t*outURN = NULL;\n\t\t*outURL = NULL;\n\t}\n\treturn GF_OK;\n}\n\n//Get the number of samples\n//return 0 if error or empty\nGF_EXPORT\nu32 gf_isom_get_sample_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\treturn trak->Media->information->sampleTable->SampleSize->sampleCount\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t       + trak->sample_count_at_seg_start\n#endif\n\t       ;\n}\n\nGF_EXPORT\nu32 gf_isom_get_constant_sample_size(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\treturn trak->Media->information->sampleTable->SampleSize->sampleSize;\n}\n\nGF_EXPORT\nu32 gf_isom_get_constant_sample_duration(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->TimeToSample) return 0;\n\tif (trak->Media->information->sampleTable->TimeToSample->nb_entries != 1) return 0;\n\treturn trak->Media->information->sampleTable->TimeToSample->entries[0].sampleDelta;\n}\n\nGF_EXPORT\nBool gf_isom_enable_raw_pack(GF_ISOFile *the_file, u32 trackNumber, u32 pack_num_samples)\n{\n\tu32 afmt, bps, nb_ch;\n\tBool from_qt=GF_FALSE;\n\tGF_TrackBox *trak;\n\tGF_MPEGAudioSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\ttrak->pack_num_samples = 0;\n\t//we only activate sample packing for raw audio\n\tif (!trak->Media || !trak->Media->handler) return GF_FALSE;\n\tif (trak->Media->handler->handlerType != GF_ISOM_MEDIA_AUDIO) return GF_FALSE;\n\t//and sample duration of 1\n\tif (!trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->TimeToSample) return GF_FALSE;\n\tif (trak->Media->information->sampleTable->TimeToSample->nb_entries != 1) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->TimeToSample->entries) return GF_FALSE;\n\tif (trak->Media->information->sampleTable->TimeToSample->entries[0].sampleDelta != 1) return GF_FALSE;\n\t//and sample with constant size\n\tif (!trak->Media->information->sampleTable->SampleSize || !trak->Media->information->sampleTable->SampleSize->sampleSize) return GF_FALSE;\n\ttrak->pack_num_samples = pack_num_samples;\n\n\tif (!pack_num_samples) return GF_FALSE;\n\n\tentry = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\tif (!entry) return GF_FALSE;\n\n\tif (entry->internal_type!=GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_FALSE;\n\n\t//sanity check, some files have wrong stsz sampleSize for raw audio !\n\tafmt = gf_audio_fmt_from_isobmf(entry->type);\n\tbps = gf_audio_fmt_bit_depth(afmt) / 8;\n\tif (!bps) {\n\t\t//unknown format, try QTv2\n\t\tif (entry->qtff_mode && (entry->internal_type==GF_ISOM_SAMPLE_ENTRY_AUDIO)) {\n\t\t\tbps = entry->extensions[8]<<24 | entry->extensions[9]<<16 | entry->extensions[10]<<8 | entry->extensions[11];\n\t\t\tfrom_qt = GF_TRUE;\n\t\t}\n\t}\n\tnb_ch = entry->channel_count;\n\tif (entry->qtff_mode && (entry->version==2)) {\n\t\t//QTFFv2 audio, channel count is 32 bit, after 32bit size of struct and 64 bit samplerate\n\t\t//hence start at 12 in extensions\n\t\tnb_ch = entry->extensions[11]<<24 | entry->extensions[12]<<16 | entry->extensions[13]<<8 | entry->extensions[14];\n\t}\n\n\tif (bps) {\n\t\tu32 res = trak->Media->information->sampleTable->SampleSize->sampleSize % bps;\n\t\tif (res) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"ISOBMF: size mismatch for raw audio sample description: constant sample size %d but %d bytes per channel for %s%s!\\n\", trak->Media->information->sampleTable->SampleSize->sampleSize,\n\t\t\t\t\tbps,\n\t\t\t\t\tgf_4cc_to_str(entry->type),\n\t\t\t\t\tfrom_qt ? \" (as indicated in QT sample description)\" : \"\"\n\t\t\t\t));\n\t\t\ttrak->Media->information->sampleTable->SampleSize->sampleSize = bps * nb_ch;\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\nBool gf_isom_has_time_offset_table(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media->information->sampleTable->CompositionOffset) return GF_FALSE;\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nu32 gf_isom_has_time_offset(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tu32 i;\n\tGF_CompositionOffsetBox *ctts;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media->information->sampleTable->CompositionOffset) return 0;\n\n\t//return true at the first offset found\n\tctts = trak->Media->information->sampleTable->CompositionOffset;\n\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\tif (ctts->entries[i].decodingOffset && ctts->entries[i].sampleCount) return ctts->version ? 2 : 1;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\ns64 gf_isom_get_cts_to_dts_shift(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media->information->sampleTable->CompositionToDecode) return 0;\n\treturn trak->Media->information->sampleTable->CompositionToDecode->compositionToDTSShift;\n}\n\nGF_EXPORT\nBool gf_isom_has_sync_shadows(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->ShadowSync) return GF_FALSE;\n\tif (gf_list_count(trak->Media->information->sampleTable->ShadowSync->entries) ) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nBool gf_isom_has_sample_dependency(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->SampleDep) return GF_FALSE;\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_flags(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *isLeading, u32 *dependsOn, u32 *dependedOn, u32 *redundant)\n{\n\tGF_TrackBox *trak;\n\t*isLeading = 0;\n\t*dependsOn = 0;\n\t*dependedOn = 0;\n\t*redundant = 0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->SampleDep) return GF_BAD_PARAM;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber <= trak->sample_count_at_seg_start)\n\t\treturn GF_BAD_PARAM;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\treturn stbl_GetSampleDepType(trak->Media->information->sampleTable->SampleDep, sampleNumber, isLeading, dependsOn, dependedOn, redundant);\n}\n\n//return a sample give its number, and set the SampleDescIndex of this sample\n//this index allows to retrieve the stream description if needed (2 media in 1 track)\n//return NULL if error\nGF_EXPORT\nGF_ISOSample *gf_isom_get_sample_ex(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, GF_ISOSample *static_sample, u64 *data_offset)\n{\n\tGF_Err e;\n\tu32 descIndex;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *samp;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\n\tif (!sampleNumber) return NULL;\n\tif (static_sample) {\n\t\tsamp = static_sample;\n\t\tif (static_sample->dataLength && !static_sample->alloc_size)\n\t\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\t} else {\n\t\tsamp = gf_isom_sample_new();\n\t}\n\tif (!samp) return NULL;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start)\n\t\treturn NULL;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\te = Media_GetSample(trak->Media, sampleNumber, &samp, &descIndex, GF_FALSE, data_offset);\n\tif (static_sample && !static_sample->alloc_size)\n\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\n\tif (e) {\n\t\tgf_isom_set_last_error(the_file, e);\n\t\tif (!static_sample) gf_isom_sample_del(&samp);\n\t\treturn NULL;\n\t}\n\tif (sampleDescriptionIndex) *sampleDescriptionIndex = descIndex;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (samp) samp->DTS += trak->dts_at_seg_start;\n#endif\n\n\treturn samp;\n}\n\nGF_EXPORT\nGF_ISOSample *gf_isom_get_sample(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex)\n{\n\treturn gf_isom_get_sample_ex(the_file, trackNumber, sampleNumber, sampleDescriptionIndex, NULL, NULL);\n}\n\nGF_EXPORT\nu32 gf_isom_get_sample_duration(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tu32 dur;\n\tu64 dts;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !sampleNumber) return 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return 0;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\tstbl_GetSampleDTS_and_Duration(trak->Media->information->sampleTable->TimeToSample, sampleNumber, &dts, &dur);\n\treturn dur;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_sample_size(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tu32 size = 0;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !sampleNumber) return 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return 0;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tstbl_GetSampleSize(trak->Media->information->sampleTable->SampleSize, sampleNumber, &size);\n\treturn size;\n}\n\nGF_EXPORT\nu32 gf_isom_get_max_sample_size(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\n\treturn trak->Media->information->sampleTable->SampleSize->max_size;\n}\n\nGF_EXPORT\nu32 gf_isom_get_avg_sample_size(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\n\tif ( trak->Media->information->sampleTable->SampleSize->sampleSize)\n\t\treturn trak->Media->information->sampleTable->SampleSize->sampleSize;\n\n\tif (!trak->Media->information->sampleTable->SampleSize->total_samples) return 0;\n\treturn (u32) (trak->Media->information->sampleTable->SampleSize->total_size / trak->Media->information->sampleTable->SampleSize->total_samples);\n}\n\nGF_EXPORT\nu32 gf_isom_get_max_sample_delta(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->TimeToSample) return 0;\n\n\treturn trak->Media->information->sampleTable->TimeToSample->max_ts_delta;\n}\n\nGF_EXPORT\nu32 gf_isom_get_max_sample_cts_offset(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->CompositionOffset) return 0;\n\n\treturn trak->Media->information->sampleTable->CompositionOffset->max_ts_delta;\n}\n\n\nGF_EXPORT\nBool gf_isom_get_sample_sync(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tGF_ISOSAPType is_rap;\n\tGF_Err e;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !sampleNumber) return GF_FALSE;\n\n\tif (! trak->Media->information->sampleTable->SyncSample) return GF_TRUE;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return GF_FALSE;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\te = stbl_GetSampleRAP(trak->Media->information->sampleTable->SyncSample, sampleNumber, &is_rap, NULL, NULL);\n\tif (e) return GF_FALSE;\n\treturn is_rap ? GF_TRUE : GF_FALSE;\n}\n\n//same as gf_isom_get_sample but doesn't fetch media data\nGF_EXPORT\nGF_ISOSample *gf_isom_get_sample_info_ex(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, u64 *data_offset, GF_ISOSample *static_sample)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *samp;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\n\tif (!sampleNumber) return NULL;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return NULL;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tif (static_sample) {\n\t\tsamp = static_sample;\n\t} else {\n\t\tsamp = gf_isom_sample_new();\n\t\tif (!samp) return NULL;\n\t}\n\n\te = Media_GetSample(trak->Media, sampleNumber, &samp, sampleDescriptionIndex, GF_TRUE, data_offset);\n\tif (e) {\n\t\tgf_isom_set_last_error(the_file, e);\n\t\tif (!static_sample)\n\t\t\tgf_isom_sample_del(&samp);\n\t\treturn NULL;\n\t}\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (samp) samp->DTS += trak->dts_at_seg_start;\n#endif\n\treturn samp;\n}\n\nGF_EXPORT\nGF_ISOSample *gf_isom_get_sample_info(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, u64 *data_offset)\n{\n\treturn gf_isom_get_sample_info_ex(the_file, trackNumber, sampleNumber, sampleDescriptionIndex, data_offset, NULL);\n}\n\n\n//get sample dts\nGF_EXPORT\nu64 gf_isom_get_sample_dts(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tu64 dts;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\tif (!sampleNumber) return 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return 0;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tif (stbl_GetSampleDTS(trak->Media->information->sampleTable->TimeToSample, sampleNumber, &dts) != GF_OK) return 0;\n\treturn dts;\n}\n\nGF_EXPORT\nBool gf_isom_is_self_contained(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\treturn Media_IsSelfContained(trak->Media, sampleDescriptionIndex);\n}\n\n/*retrieves given sample DTS*/\nGF_EXPORT\nu32 gf_isom_get_sample_from_dts(GF_ISOFile *the_file, u32 trackNumber, u64 dts)\n{\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber;\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\tstbl = trak->Media->information->sampleTable;\n\n\te = stbl_findEntryForTime(stbl, dts, 1, &sampleNumber, &prevSampleNumber);\n\tif (e) return 0;\n\treturn sampleNumber;\n}\n\n\n//return a sample given a desired display time IN MEDIA TIME SCALE\n//and set the StreamDescIndex of this sample\n//this index allows to retrieve the stream description if needed (2 media in 1 track)\n//return NULL if error\n//WARNING: the sample may not be sync even though the sync was requested (depends on the media)\nGF_EXPORT\nGF_Err gf_isom_get_sample_for_media_time(GF_ISOFile *the_file, u32 trackNumber, u64 desiredTime, u32 *StreamDescriptionIndex, GF_ISOSearchMode SearchMode, GF_ISOSample **sample, u32 *SampleNum, u64 *data_offset)\n{\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber, syncNum, shadowSync;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *shadow;\n\tGF_SampleTableBox *stbl;\n\tBool static_sample = GF_FALSE;\n\tu8 useShadow, IsSync;\n\n\tif (SampleNum) *SampleNum = 0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (desiredTime < trak->dts_at_seg_start) {\n\t\tdesiredTime = 0;\n\t} else {\n\t\tdesiredTime -= trak->dts_at_seg_start;\n\t}\n#endif\n\n\te = stbl_findEntryForTime(stbl, desiredTime, 0, &sampleNumber, &prevSampleNumber);\n\tif (e) return e;\n\n\t//if no shadow table, reset to sync only\n\tuseShadow = 0;\n\tif (!stbl->ShadowSync && (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW))\n\t\tSearchMode = GF_ISOM_SEARCH_SYNC_BACKWARD;\n\n\t//if no syncTable, disable syncSearching, as all samples ARE sync\n\tif (! trak->Media->information->sampleTable->SyncSample) {\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_FORWARD) SearchMode = GF_ISOM_SEARCH_FORWARD;\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD) SearchMode = GF_ISOM_SEARCH_BACKWARD;\n\t}\n\n\t//not found, return EOF or browse backward\n\tif (!sampleNumber && !prevSampleNumber) {\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD || SearchMode == GF_ISOM_SEARCH_BACKWARD) {\n\t\t\tsampleNumber = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\t\t}\n\t\tif (!sampleNumber) return GF_EOS;\n\t}\n\n\t//check in case we have the perfect sample\n\tIsSync = 0;\n\n\t//according to the direction adjust the sampleNum value\n\tswitch (SearchMode) {\n\tcase GF_ISOM_SEARCH_SYNC_FORWARD:\n\t\tIsSync = 1;\n\tcase GF_ISOM_SEARCH_FORWARD:\n\t\t//not the exact one\n\t\tif (!sampleNumber) {\n\t\t\tif (prevSampleNumber != stbl->SampleSize->sampleCount) {\n\t\t\t\tsampleNumber = prevSampleNumber + 1;\n\t\t\t} else {\n\t\t\t\tsampleNumber = prevSampleNumber;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t//if dummy mode, reset to default browsing\n\tcase GF_ISOM_SEARCH_SYNC_BACKWARD:\n\t\tIsSync = 1;\n\tcase GF_ISOM_SEARCH_SYNC_SHADOW:\n\tcase GF_ISOM_SEARCH_BACKWARD:\n\tdefault:\n\t\t//first case, not found....\n\t\tif (!sampleNumber && !prevSampleNumber) {\n\t\t\tsampleNumber = stbl->SampleSize->sampleCount;\n\t\t} else if (!sampleNumber) {\n\t\t\tsampleNumber = prevSampleNumber;\n\t\t}\n\t\tbreak;\n\t}\n\n\t//get the sync sample num\n\tif (IsSync) {\n\t\t//get the SyncNumber\n\t\te = Media_FindSyncSample(trak->Media->information->sampleTable,\n\t\t                         sampleNumber, &syncNum, SearchMode);\n\t\tif (e) return e;\n\t\tif (syncNum) sampleNumber = syncNum;\n\t\tsyncNum = 0;\n\t}\n\t//if we are in shadow mode, get the previous sync sample\n\t//in case we can't find a good SyncShadow\n\telse if (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\n\t\t//get the SyncNumber\n\t\te = Media_FindSyncSample(trak->Media->information->sampleTable,\n\t\t                         sampleNumber, &syncNum, GF_ISOM_SEARCH_SYNC_BACKWARD);\n\t\tif (e) return e;\n\t}\n\n\n\t//OK sampleNumber is exactly the sample we need (except for shadow)\n\n\tif (sample) {\n\t\tif (*sample) {\n\t\t\tstatic_sample = GF_TRUE;\n\t\t} else {\n\t\t\t*sample = gf_isom_sample_new();\n\t\t\tif (*sample == NULL) return GF_OUT_OF_MEM;\n\t\t}\n\t}\n\t//we are in shadow mode, we need to browse both SyncSample and ShadowSyncSample to get\n\t//the desired sample...\n\tif (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\n\t\t//get the shadowing number\n\t\tstbl_GetSampleShadow(stbl->ShadowSync, &sampleNumber, &shadowSync);\n\t\t//now sampleNumber is the closest previous shadowed sample.\n\t\t//1- If we have a closer sync sample, use it.\n\t\t//2- if the shadowSync is 0, we don't have any shadowing, use syncNum\n\t\tif ((sampleNumber < syncNum) || (!shadowSync)) {\n\t\t\tsampleNumber = syncNum;\n\t\t} else {\n\t\t\t//otherwise, we have a better alternate sample in the shadowSync for this sample\n\t\t\tuseShadow = 1;\n\t\t}\n\t}\n\n\te = Media_GetSample(trak->Media, sampleNumber, sample, StreamDescriptionIndex, GF_FALSE, data_offset);\n\tif (e) {\n\t\tif (!static_sample)\n\t\t\tgf_isom_sample_del(sample);\n\t\telse if (! (*sample)->alloc_size && (*sample)->data && (*sample)->dataLength )\n\t\t \t(*sample)->alloc_size =  (*sample)->dataLength;\n\n\t\treturn e;\n\t}\n\tif (sample && ! (*sample)->IsRAP) {\n\t\tBool is_rap;\n\t\tGF_ISOSampleRollType roll_type;\n\t\te = gf_isom_get_sample_rap_roll_info(the_file, trackNumber, sampleNumber, &is_rap, &roll_type, NULL);\n\t\tif (e) return e;\n\t\tif (is_rap) (*sample)->IsRAP = SAP_TYPE_3;\n\t}\n\t//optionally get the sample number\n\tif (SampleNum) {\n\t\t*SampleNum = sampleNumber;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t*SampleNum += trak->sample_count_at_seg_start;\n#endif\n\t}\n\n\t//in shadow mode, we only get the data of the shadowing sample !\n\tif (sample && useShadow) {\n\t\t//we have to use StreamDescriptionIndex in case the sample data is in another desc\n\t\t//though this is unlikely as non optimized...\n\t\tshadow = gf_isom_get_sample(the_file, trackNumber, shadowSync, StreamDescriptionIndex);\n\t\t//if no sample, the shadowSync is broken, return the sample\n\t\tif (!shadow) return GF_OK;\n\t\t(*sample)->IsRAP = RAP;\n\t\tgf_free((*sample)->data);\n\t\t(*sample)->dataLength = shadow->dataLength;\n\t\t(*sample)->data = shadow->data;\n\t\t//set data length to 0 to keep the buffer alive...\n\t\tshadow->dataLength = 0;\n\t\tgf_isom_sample_del(&shadow);\n\t}\n\tif (static_sample && ! (*sample)->alloc_size )\n\t\t (*sample)->alloc_size =  (*sample)->dataLength;\n\t\t \n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_for_movie_time(GF_ISOFile *the_file, u32 trackNumber, u64 movieTime, u32 *StreamDescriptionIndex, GF_ISOSearchMode SearchMode, GF_ISOSample **sample, u32 *sampleNumber, u64 *data_offset)\n{\n\tDouble tsscale;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tu64 mediaTime, nextMediaTime;\n\ts64 segStartTime, mediaOffset;\n\tu32 sampNum;\n\tu8 useEdit;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//only check duration if initially set - do not check duration as updated after fragment merge since that duration does not take\n\t//into account tfdt\n\tif (trak->Header->initial_duration\n\t\t&& (movieTime * trak->moov->mvhd->timeScale > trak->Header->initial_duration * trak->Media->mediaHeader->timeScale)\n\t) {\n\t\tif (sampleNumber) *sampleNumber = 0;\n\t\t*StreamDescriptionIndex = 0;\n\t\treturn GF_EOS;\n\t}\n\n\t//get the media time for this movie time...\n\tmediaTime = segStartTime = 0;\n\t*StreamDescriptionIndex = 0;\n\tnextMediaTime = 0;\n\n\te = GetMediaTime(trak, (SearchMode==GF_ISOM_SEARCH_SYNC_FORWARD) ? GF_TRUE : GF_FALSE, movieTime, &mediaTime, &segStartTime, &mediaOffset, &useEdit, &nextMediaTime);\n\tif (e) return e;\n\n\t/*here we check if we were playing or not and return no sample in normal search modes*/\n\tif (useEdit && mediaOffset == -1) {\n\t\tif ((SearchMode==GF_ISOM_SEARCH_FORWARD) || (SearchMode==GF_ISOM_SEARCH_BACKWARD)) {\n\t\t\t/*get next sample time in MOVIE timescale*/\n\t\t\tif (SearchMode==GF_ISOM_SEARCH_FORWARD)\n\t\t\t\te = GetNextMediaTime(trak, movieTime, &mediaTime);\n\t\t\telse\n\t\t\t\te = GetPrevMediaTime(trak, movieTime, &mediaTime);\n\t\t\tif (e) return e;\n\t\t\treturn gf_isom_get_sample_for_movie_time(the_file, trackNumber, (u32) mediaTime, StreamDescriptionIndex, GF_ISOM_SEARCH_SYNC_FORWARD, sample, sampleNumber, data_offset);\n\t\t}\n\t\tif (sampleNumber) *sampleNumber = 0;\n\t\tif (sample) {\n\t\t\tif (! (*sample)) {\n\t\t\t\t*sample = gf_isom_sample_new();\n\t\t\t\tif (! *sample) return GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\t(*sample)->DTS = movieTime;\n\t\t\t(*sample)->dataLength = 0;\n\t\t\t(*sample)->CTS_Offset = 0;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\t/*dwell edit in non-sync mode, fetch next/prev sample depending on mode.\n\tOtherwise return the dwell entry*/\n\tif (useEdit==2) {\n\t\tif ((SearchMode==GF_ISOM_SEARCH_FORWARD) || (SearchMode==GF_ISOM_SEARCH_BACKWARD)) {\n\t\t\t/*get next sample time in MOVIE timescale*/\n\t\t\tif (SearchMode==GF_ISOM_SEARCH_FORWARD)\n\t\t\t\te = GetNextMediaTime(trak, movieTime, &mediaTime);\n\t\t\telse\n\t\t\t\te = GetPrevMediaTime(trak, movieTime, &mediaTime);\n\t\t\tif (e) return e;\n\t\t\treturn gf_isom_get_sample_for_movie_time(the_file, trackNumber, (u32) mediaTime, StreamDescriptionIndex, GF_ISOM_SEARCH_SYNC_FORWARD, sample, sampleNumber, data_offset);\n\t\t}\n\t}\n\n\ttsscale = trak->Media->mediaHeader->timeScale;\n\ttsscale /= trak->moov->mvhd->timeScale;\n\n\t//OK, we have a sample so fetch it\n\te = gf_isom_get_sample_for_media_time(the_file, trackNumber, mediaTime, StreamDescriptionIndex, SearchMode, sample, &sampNum, data_offset);\n\tif (e) {\n\t\tif (e==GF_EOS) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t//movie is fragmented and samples not yet received, return EOS\n\t\t\tif (the_file->moov->mvex && !trak->Media->information->sampleTable->SampleSize->sampleCount)\n\t\t\t\treturn e;\n#endif\n\n\t\t\tif (nextMediaTime && (nextMediaTime-1 != movieTime))\n\t\t\t\treturn gf_isom_get_sample_for_movie_time(the_file, trackNumber, nextMediaTime-1, StreamDescriptionIndex, SearchMode, sample, sampleNumber, data_offset);\n\t\t}\n\t\treturn e;\n\t}\n\n\t//OK, now the trick: we have to rebuild the time stamps, according\n\t//to the media time scale (used by SLConfig) - add the edit start time but stay in\n\t//the track TS\n\tif (sample && useEdit) {\n\t\tu64 _ts = (u64)(segStartTime * tsscale);\n\n\t\t(*sample)->DTS += _ts;\n\t\t/*watchout, the sample fetched may be before the first sample in the edit list (when seeking)*/\n\t\tif ( (*sample)->DTS > (u64) mediaOffset) {\n\t\t\t(*sample)->DTS -= (u64) mediaOffset;\n\t\t} else {\n\t\t\t(*sample)->DTS = 0;\n\t\t}\n\t}\n\tif (sampleNumber) *sampleNumber = sampNum;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sample && (*sample) ) (*sample)->DTS += trak->dts_at_seg_start;\n#endif\n\n\treturn GF_OK;\n}\n\n\n\nGF_EXPORT\nu64 gf_isom_get_missing_bytes(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\treturn trak->Media->BytesMissing;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_sample_padding(GF_ISOFile *the_file, u32 trackNumber, u32 padding_bytes)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrak->padding_bytes = padding_bytes;\n\treturn GF_OK;\n\n}\n\n//get the number of edited segment\nGF_EXPORT\nBool gf_isom_get_edit_list_type(GF_ISOFile *the_file, u32 trackNumber, s64 *mediaOffset)\n{\n\tGF_EdtsEntry *ent;\n\tGF_TrackBox *trak;\n\tu32 count;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\t*mediaOffset = 0;\n\tif (!trak->editBox || !trak->editBox->editList) return GF_FALSE;\n\n\tcount = gf_list_count(trak->editBox->editList->entryList);\n\tent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, 0);\n\tif (!ent) return GF_TRUE;\n\t/*mediaRate>0, the track playback shall start at media time>0 -> mediaOffset is < 0 */\n\tif ((count==1) && (ent->mediaRate == 0x10000)) {\n\t\t*mediaOffset = - ent->mediaTime;\n\t\treturn GF_FALSE;\n\t} else if (count==2) {\n\t\t/*mediaRate==-1, the track playback shall be empty for segmentDuration -> mediaOffset is > 0 */\n\t\tif ((ent->mediaRate == -0x10000) || (ent->mediaTime==-1)) {\n\t\t\tDouble time = (Double) ent->segmentDuration;\n\t\t\ttime /= trak->moov->mvhd->timeScale;\n\t\t\ttime *= trak->Media->mediaHeader->timeScale;\n\t\t\t*mediaOffset = (s64) time;\n\n\t\t\t//check next entry, if we start from mediaOffset > 0 this may still result in a skip\n\t\t\tent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, 1);\n\t\t\t//next entry playback rate is not nominal, we need edit list handling\n\t\t\tif (ent->mediaRate != 0x10000)\n\t\t\t\treturn GF_TRUE;\n\n\t\t\tif (ent->mediaTime > 0) {\n\t\t\t\t*mediaOffset -= ent->mediaTime;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\n\n//get the number of edited segment\nGF_EXPORT\nu32 gf_isom_get_edits_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\tif (!trak->editBox || !trak->editBox->editList) return 0;\n\treturn gf_list_count(trak->editBox->editList->entryList);\n}\n\n\n//Get the desired segment information\nGF_EXPORT\nGF_Err gf_isom_get_edit(GF_ISOFile *the_file, u32 trackNumber, u32 SegmentIndex, u64 *EditTime, u64 *SegmentDuration, u64 *MediaTime, GF_ISOEditType *EditMode)\n{\n\tu32 i;\n\tu64 startTime;\n\tGF_TrackBox *trak;\n\tGF_EditListBox *elst;\n\tGF_EdtsEntry *ent;\n\n\tent = NULL;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->editBox ||\n\t        !trak->editBox->editList ||\n\t        (SegmentIndex > gf_list_count(trak->editBox->editList->entryList)) ||\n\t        !SegmentIndex)\n\t\treturn GF_BAD_PARAM;\n\n\telst = trak->editBox->editList;\n\tstartTime = 0;\n\n\tfor (i = 0; i < SegmentIndex; i++) {\n\t\tent = (GF_EdtsEntry*)gf_list_get(elst->entryList, i);\n\t\tif (i < SegmentIndex-1) startTime += ent->segmentDuration;\n\t}\n\t*EditTime = startTime;\n\t*SegmentDuration = ent->segmentDuration;\n\tif (ent->mediaTime < 0) {\n\t\t*MediaTime = 0;\n\t\t*EditMode = GF_ISOM_EDIT_EMPTY;\n\t\treturn GF_OK;\n\t}\n\tif (ent->mediaRate == 0) {\n\t\t*MediaTime = ent->mediaTime;\n\t\t*EditMode = GF_ISOM_EDIT_DWELL;\n\t\treturn GF_OK;\n\t}\n\t*MediaTime = ent->mediaTime;\n\t*EditMode = GF_ISOM_EDIT_NORMAL;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu8 gf_isom_has_sync_points(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable) return 0;\n\tif (trak->Media->information->sampleTable->SyncSample) {\n\t\tif (!trak->Media->information->sampleTable->SyncSample->nb_entries) return 2;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*returns number of sync points*/\nGF_EXPORT\nu32 gf_isom_get_sync_point_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\tif (trak->Media->information->sampleTable->SyncSample) {\n\t\treturn trak->Media->information->sampleTable->SyncSample->nb_entries;\n\t}\n\treturn 0;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_get_brand_info(GF_ISOFile *movie, u32 *brand, u32 *minorVersion, u32 *AlternateBrandsCount)\n{\n\tif (!movie) return GF_BAD_PARAM;\n\tif (!movie->brand) {\n\t\tif (brand) *brand = GF_ISOM_BRAND_ISOM;\n\t\tif (minorVersion) *minorVersion = 1;\n\t\tif (AlternateBrandsCount) *AlternateBrandsCount = 0;\n\t\treturn GF_OK;\n\t}\n\n\tif (brand) *brand = movie->brand->majorBrand;\n\tif (minorVersion) *minorVersion = movie->brand->minorVersion;\n\tif (AlternateBrandsCount) *AlternateBrandsCount = movie->brand->altCount;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_alternate_brand(GF_ISOFile *movie, u32 BrandIndex, u32 *brand)\n{\n\tif (!movie || !movie->brand || !brand) return GF_BAD_PARAM;\n\tif (BrandIndex > movie->brand->altCount || !BrandIndex) return GF_BAD_PARAM;\n\t*brand = movie->brand->altBrand[BrandIndex-1];\n\treturn GF_OK;\n}\n\nGF_EXPORT\nconst u32 *gf_isom_get_brands(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->brand) return NULL;\n\treturn movie->brand->altBrand;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_padding_bits(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u8 *NbBits)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\t//Padding info\n\treturn stbl_GetPaddingBits(trak->Media->information->sampleTable->PaddingBits,\n\t                           sampleNumber, NbBits);\n\n}\n\n\nGF_EXPORT\nBool gf_isom_has_padding_bits(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\n\tif (trak->Media->information->sampleTable->PaddingBits) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_get_udta_count(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tif (!movie || !movie->moov) return 0;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return 0;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (udta) return gf_list_count(udta->recordList);\n\treturn 0;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_udta_type(GF_ISOFile *movie, u32 trackNumber, u32 udta_idx, u32 *UserDataType, bin128 *UUID)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tif (!movie || !movie->moov || !udta_idx) return GF_BAD_PARAM;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_OK;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_BAD_PARAM;\n\tif (udta_idx>gf_list_count(udta->recordList)) return GF_BAD_PARAM;\n\tmap = (GF_UserDataMap*)gf_list_get(udta->recordList, udta_idx - 1);\n\tif (UserDataType) *UserDataType = map->boxType;\n\tif (UUID) memcpy(*UUID, map->uuid, 16);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_isom_get_user_data_count(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID)\n{\n\tGF_UserDataMap *map;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tbin128 t;\n\tu32 i, count;\n\n\tif (!movie || !movie->moov) return 0;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return 0;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return 0;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tcount = gf_list_count(map->boxes);\n\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && !memcmp(map->uuid, UUID, 16)) return count;\n\t\telse if (map->boxType == UserDataType) return count;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID, u32 UserDataIndex, u8 **userData, u32 *userDataSize)\n{\n\tGF_UserDataMap *map;\n\tGF_UnknownBox *ptr;\n\tGF_BitStream *bs;\n\tu32 i;\n\tbin128 t;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_BAD_PARAM;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (!userData || !userDataSize || *userData) return GF_BAD_PARAM;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && !memcmp(map->uuid, UUID, 16)) goto found;\n\t\telse if (map->boxType == UserDataType) goto found;\n\n\t}\n\treturn GF_BAD_PARAM;\n\nfound:\n\tif (UserDataIndex) {\n\t\tif (UserDataIndex > gf_list_count(map->boxes) ) return GF_BAD_PARAM;\n\t\tptr = (GF_UnknownBox*)gf_list_get(map->boxes, UserDataIndex-1);\n\n\t\tif (ptr->type == GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\t*userData = (char *)gf_malloc(sizeof(char)*ptr->dataSize);\n\t\t\tif (!*userData) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(*userData, ptr->data, sizeof(char)*ptr->dataSize);\n\t\t\t*userDataSize = ptr->dataSize;\n\t\t\treturn GF_OK;\n\t\t} else if (ptr->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tGF_UnknownUUIDBox *p_uuid = (GF_UnknownUUIDBox *)ptr;\n\t\t\t*userData = (char *)gf_malloc(sizeof(char)*p_uuid->dataSize);\n\t\t\tif (!*userData) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(*userData, p_uuid->data, sizeof(char)*p_uuid->dataSize);\n\t\t\t*userDataSize = p_uuid->dataSize;\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\tchar *str = NULL;\n\t\t\tswitch (ptr->type) {\n\t\t\tcase GF_ISOM_BOX_TYPE_NAME:\n\t\t\t//case GF_QT_BOX_TYPE_NAME: same as above\n\t\t\t\tstr = ((GF_NameBox *)ptr)->string;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_BOX_TYPE_KIND:\n\t\t\t\tstr = ((GF_KindBox *)ptr)->value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (str) {\n\t\t\t\tu32 len = (u32) strlen(str) + 1;\n\t\t\t\t*userData = (char *)gf_malloc(sizeof(char) * len);\n\t\t\t\tif (!*userData) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(*userData, str, sizeof(char)*len);\n\t\t\t\t*userDataSize = len;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t}\n\n\t//serialize all boxes\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\ti=0;\n\twhile ( (ptr = (GF_UnknownBox*)gf_list_enum(map->boxes, &i))) {\n\t\tu32 type, s, data_size;\n\t\tchar *data=NULL;\n\t\tif (ptr->type == GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\ttype = ptr->original_4cc;\n\t\t\tdata_size = ptr->dataSize;\n\t\t\tdata = ptr->data;\n\t\t} else if (ptr->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tGF_UnknownUUIDBox *p_uuid = (GF_UnknownUUIDBox *)ptr;\n\t\t\ttype = p_uuid->type;\n\t\t\tdata_size = p_uuid->dataSize;\n\t\t\tdata = p_uuid->data;\n\t\t} else {\n\t\t\tgf_isom_box_write((GF_Box *)ptr, bs);\n\t\t\tcontinue;\n\t\t}\n\t\ts = data_size+8;\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_UUID) s += 16;\n\n\t\tgf_bs_write_u32(bs, s);\n\t\tgf_bs_write_u32(bs, type);\n\t\tif (type==GF_ISOM_BOX_TYPE_UUID) gf_bs_write_data(bs, (char *) map->uuid, 16);\n\t\tif (data) {\n\t\t\tgf_bs_write_data(bs, data, data_size);\n\t\t} else if (ptr->child_boxes) {\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\t\tgf_isom_box_array_write((GF_Box *)ptr, ptr->child_boxes, bs);\n#else\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"ISOBMF: udta is a box-list - cannot export in read-only version of libisom in GPAC\\n\" ));\n#endif\n\t\t}\n\t}\n\tgf_bs_get_content(bs, userData, userDataSize);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_isom_delete(GF_ISOFile *movie)\n{\n\t//free and return;\n\tgf_isom_delete_movie(movie);\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_chunks_infos(GF_ISOFile *movie, u32 trackNumber, u32 *dur_min, u32 *dur_avg, u32 *dur_max, u32 *size_min, u32 *size_avg, u32 *size_max)\n{\n\tGF_TrackBox *trak;\n\tu32 i, k, sample_idx, dmin, dmax, smin, smax, tot_chunks;\n\tu64 davg, savg;\n\tGF_SampleToChunkBox *stsc;\n\tGF_TimeToSampleBox *stts;\n\tif (!movie || !trackNumber || !movie->moov) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsc = trak->Media->information->sampleTable->SampleToChunk;\n\tstts = trak->Media->information->sampleTable->TimeToSample;\n\tif (!stsc || !stts) return GF_ISOM_INVALID_FILE;\n\n\tdmin = smin = (u32) -1;\n\tdmax = smax = 0;\n\tdavg = savg = 0;\n\tsample_idx = 1;\n\ttot_chunks = 0;\n\tfor (i=0; i<stsc->nb_entries; i++) {\n\t\tu32 nb_chunk = 0;\n\t\tif (stsc->entries[i].samplesPerChunk >  2*trak->Media->information->sampleTable->SampleSize->sampleCount) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] likely broken stco entry (%u samples per chunk but %u samples total)\\n\", stsc->entries[i].samplesPerChunk, trak->Media->information->sampleTable->SampleSize->sampleCount));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\twhile (1) {\n\t\t\tu32 chunk_dur = 0;\n\t\t\tu32 chunk_size = 0;\n\t\t\tfor (k=0; k<stsc->entries[i].samplesPerChunk; k++) {\n\t\t\t\tu64 dts;\n\t\t\t\tu32 dur;\n\t\t\t\tu32 size;\n\t\t\t\tstbl_GetSampleDTS_and_Duration(stts, k+sample_idx, &dts, &dur);\n\t\t\t\tchunk_dur += dur;\n\t\t\t\tstbl_GetSampleSize(trak->Media->information->sampleTable->SampleSize, k+sample_idx, &size);\n\t\t\t\tchunk_size += size;\n\n\t\t\t}\n\t\t\tif (dmin>chunk_dur) dmin = chunk_dur;\n\t\t\tif (dmax<chunk_dur) dmax = chunk_dur;\n\t\t\tdavg += chunk_dur;\n\t\t\tif (smin>chunk_size) smin = chunk_size;\n\t\t\tif (smax<chunk_size) smax = chunk_size;\n\t\t\tsavg += chunk_size;\n\n\t\t\ttot_chunks ++;\n\t\t\tsample_idx += stsc->entries[i].samplesPerChunk;\n\t\t\tif (i+1==stsc->nb_entries) break;\n\t\t\tnb_chunk ++;\n\t\t\tif (stsc->entries[i].firstChunk + nb_chunk == stsc->entries[i+1].firstChunk) break;\n\t\t}\n\t}\n\tif (tot_chunks) {\n\t\tdavg /= tot_chunks;\n\t\tsavg /= tot_chunks;\n\t}\n\tif (dur_min) *dur_min = dmin;\n\tif (dur_avg) *dur_avg = (u32) davg;\n\tif (dur_max) *dur_max = dmax;\n\n\tif (size_min) *size_min = smin;\n\tif (size_avg) *size_avg = (u32) savg;\n\tif (size_max) *size_max = smax;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_fragment_defaults(GF_ISOFile *the_file, u32 trackNumber,\n                                     u32 *defaultDuration, u32 *defaultSize, u32 *defaultDescriptionIndex,\n                                     u32 *defaultRandomAccess, u8 *defaultPadding, u16 *defaultDegradationPriority)\n{\n\tGF_TrackBox *trak;\n\tGF_StscEntry *sc_ent;\n\tu32 i, j, maxValue, value;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackExtendsBox *trex;\n#endif\n\tGF_SampleTableBox *stbl;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t/*if trex is already set, restore flags*/\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\ttrex = the_file->moov->mvex ? GetTrex(the_file->moov, gf_isom_get_track_id(the_file,trackNumber) ) : NULL;\n\tif (trex) {\n\t\ttrex->track = trak;\n\n\t\tif (defaultDuration) *defaultDuration = trex->def_sample_duration;\n\t\tif (defaultSize) *defaultSize = trex->def_sample_size;\n\t\tif (defaultDescriptionIndex) *defaultDescriptionIndex = trex->def_sample_desc_index;\n\t\tif (defaultRandomAccess) *defaultRandomAccess = GF_ISOM_GET_FRAG_SYNC(trex->def_sample_flags);\n\t\tif (defaultPadding) *defaultPadding = GF_ISOM_GET_FRAG_PAD(trex->def_sample_flags);\n\t\tif (defaultDegradationPriority) *defaultDegradationPriority = GF_ISOM_GET_FRAG_DEG(trex->def_sample_flags);\n\t\treturn GF_OK;\n\t}\n#endif\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl->TimeToSample || !stbl->SampleSize || !stbl->SampleToChunk) return GF_ISOM_INVALID_FILE;\n\n\n\t//duration\n\tif (defaultDuration) {\n\t\tmaxValue = value = 0;\n\t\tfor (i=0; i<stbl->TimeToSample->nb_entries; i++) {\n\t\t\tif (stbl->TimeToSample->entries[i].sampleCount>maxValue) {\n\t\t\t\tvalue = stbl->TimeToSample->entries[i].sampleDelta;\n\t\t\t\tmaxValue = stbl->TimeToSample->entries[i].sampleCount;\n\t\t\t}\n\t\t}\n\t\t*defaultDuration = value;\n\t}\n\t//size\n\tif (defaultSize) {\n\t\t*defaultSize = stbl->SampleSize->sampleSize;\n\t}\n\t//descIndex\n\tif (defaultDescriptionIndex) {\n\t\tGF_SampleToChunkBox *stsc= stbl->SampleToChunk;\n\t\tmaxValue = value = 0;\n\t\tfor (i=0; i<stsc->nb_entries; i++) {\n\t\t\tsc_ent = &stsc->entries[i];\n\t\t\tif ((sc_ent->nextChunk - sc_ent->firstChunk) * sc_ent->samplesPerChunk > maxValue) {\n\t\t\t\tvalue = sc_ent->sampleDescriptionIndex;\n\t\t\t\tmaxValue = (sc_ent->nextChunk - sc_ent->firstChunk) * sc_ent->samplesPerChunk;\n\t\t\t}\n\t\t}\n\t\t*defaultDescriptionIndex = value ? value : 1;\n\t}\n\t//RAP\n\tif (defaultRandomAccess) {\n\t\t//no sync table is ALL RAP\n\t\t*defaultRandomAccess = stbl->SyncSample ? 0 : 1;\n\t\tif (stbl->SyncSample\n\t\t        && (stbl->SyncSample->nb_entries == stbl->SampleSize->sampleCount)) {\n\t\t\t*defaultRandomAccess = 1;\n\t\t}\n\t}\n\t//defaultPadding\n\tif (defaultPadding) {\n\t\t*defaultPadding = 0;\n\t\tif (stbl->PaddingBits) {\n\t\t\tmaxValue = 0;\n\t\t\tfor (i=0; i<stbl->PaddingBits->SampleCount; i++) {\n\t\t\t\tvalue = 0;\n\t\t\t\tfor (j=0; j<stbl->PaddingBits->SampleCount; j++) {\n\t\t\t\t\tif (stbl->PaddingBits->padbits[i]==stbl->PaddingBits->padbits[j]) {\n\t\t\t\t\t\tvalue ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (value>maxValue) {\n\t\t\t\t\tmaxValue = value;\n\t\t\t\t\t*defaultPadding = stbl->PaddingBits->padbits[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//defaultDegradationPriority\n\tif (defaultDegradationPriority) {\n\t\t*defaultDegradationPriority = 0;\n\t\tif (stbl->DegradationPriority) {\n\t\t\tmaxValue = 0;\n\t\t\tfor (i=0; i<stbl->DegradationPriority->nb_entries; i++) {\n\t\t\t\tvalue = 0;\n\t\t\t\tfor (j=0; j<stbl->DegradationPriority->nb_entries; j++) {\n\t\t\t\t\tif (stbl->DegradationPriority->priorities[i]==stbl->DegradationPriority->priorities[j]) {\n\t\t\t\t\t\tvalue ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (value>maxValue) {\n\t\t\t\t\tmaxValue = value;\n\t\t\t\t\t*defaultDegradationPriority = stbl->DegradationPriority->priorities[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_refresh_fragmented(GF_ISOFile *movie, u64 *MissingBytes, const char *new_location)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn GF_NOT_SUPPORTED;\n#else\n\tu64 prevsize, size;\n\tu32 i;\n\tif (!movie || !movie->movieFileMap || !movie->moov) return GF_BAD_PARAM;\n\tif (movie->openMode != GF_ISOM_OPEN_READ) return GF_BAD_PARAM;\n\n\t/*refresh size*/\n\tsize = movie->movieFileMap ? gf_bs_get_size(movie->movieFileMap->bs) : 0;\n\n\tif (new_location) {\n\t\tBool delete_map;\n\t\tGF_DataMap *previous_movie_fileMap_address = movie->movieFileMap;\n\t\tGF_Err e;\n\n\t\te = gf_isom_datamap_new(new_location, NULL, GF_ISOM_DATA_MAP_READ_ONLY, &movie->movieFileMap);\n\t\tif (e) {\n\t\t\tmovie->movieFileMap = previous_movie_fileMap_address;\n\t\t\treturn e;\n\t\t}\n\n\t\tdelete_map = (previous_movie_fileMap_address != NULL ? GF_TRUE: GF_FALSE);\n\t\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(movie->moov->trackList, i);\n\t\t\tif (trak->Media->information->dataHandler == previous_movie_fileMap_address) {\n\t\t\t\t//reaasign for later destruction\n\t\t\t\ttrak->Media->information->scalableDataHandler = movie->movieFileMap;\n\t\t\t\t//reassign for Media_GetSample function\n\t\t\t\ttrak->Media->information->dataHandler = movie->movieFileMap;\n\t\t\t} else if (trak->Media->information->scalableDataHandler == previous_movie_fileMap_address) {\n\t\t\t\tdelete_map = GF_FALSE;\n\t\t\t}\n\t\t}\n\t\tif (delete_map) {\n\t\t\tgf_isom_datamap_del(previous_movie_fileMap_address);\n\t\t}\n\t}\n\n\tprevsize = gf_bs_get_refreshed_size(movie->movieFileMap->bs);\n\tif (prevsize==size) return GF_OK;\n\n\tif (!movie->moov->mvex)\n\t\treturn GF_OK;\n\n\t//ok parse root boxes\n\treturn gf_isom_parse_movie_boxes(movie, NULL, MissingBytes, GF_TRUE);\n#endif\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nGF_EXPORT\nvoid gf_isom_set_single_moof_mode(GF_ISOFile *movie, Bool mode)\n{\n\tmovie->single_moof_mode = mode;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_reset_data_offset(GF_ISOFile *movie, u64 *top_box_start)\n{\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i, count;\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\tif (top_box_start) *top_box_start = movie->current_top_box_start;\n\tmovie->current_top_box_start = 0;\n\tmovie->NextMoofNumber = 0;\n\tif (movie->moov->mvex && movie->single_moof_mode) {\n\t\tmovie->single_moof_state = 0;\n\t}\n\tcount = gf_list_count(movie->moov->trackList);\n\tfor (i=0; i<count; i++) {\n\t\tGF_TrackBox *tk = gf_list_get(movie->moov->trackList, i);\n\t\ttk->first_traf_merged = GF_FALSE;\n\t}\n#endif\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_current_top_box_offset(GF_ISOFile *movie, u64 *current_top_box_offset)\n{\n\tif (!movie || !movie->moov || !current_top_box_offset) return GF_BAD_PARAM;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t*current_top_box_offset = movie->current_top_box_start;\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_removed_bytes(GF_ISOFile *movie, u64 bytes_removed)\n{\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\tmovie->bytes_removed = bytes_removed;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_purge_samples(GF_ISOFile *the_file, u32 trackNumber, u32 nb_samples)\n{\n\tGF_TrackBox *trak;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_Err e;\n\tGF_TrackExtendsBox *trex;\n\tGF_SampleTableBox *stbl;\n#endif\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t/*if trex is already set, restore flags*/\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\ttrex = the_file->moov->mvex ? GetTrex(the_file->moov, gf_isom_get_track_id(the_file,trackNumber) ) : NULL;\n\tif (!trex) return GF_BAD_PARAM;\n\n\t//first unpack chunk offsets and CTS\n\te = stbl_UnpackOffsets(trak->Media->information->sampleTable);\n\tif (e) return e;\n\te = stbl_unpackCTS(trak->Media->information->sampleTable);\n\tif (e) return e;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl->TimeToSample || !stbl->SampleSize || !stbl->SampleToChunk) return GF_ISOM_INVALID_FILE;\n\n\t//remove at once nb_samples in stts, ctts, stsz, stco, stsc and stdp (n-times removal is way too slow)\n\t//do NOT change the order DTS, CTS, size chunk\n\tstbl_RemoveDTS(stbl, 1, nb_samples, 0);\n\tstbl_RemoveCTS(stbl, 1, nb_samples);\n\tstbl_RemoveSize(stbl, 1, nb_samples);\n\tstbl_RemoveChunk(stbl, 1, nb_samples);\n\tstbl_RemoveRedundant(stbl, 1, nb_samples);\n\n\t//then remove sample per sample for the rest, which is either\n\t//- sparse data\n\t//- allocated structure rather than memmove-able array\n\t//- not very frequent info (paddind bits)\n\twhile (nb_samples) {\n\t\tstbl_RemoveRAP(stbl, 1);\n\t\tstbl_RemoveShadow(stbl, 1);\n\t\tstbl_RemoveSubSample(stbl, 1);\n\t\tstbl_RemovePaddingBits(stbl, 1);\n\t\tstbl_RemoveSampleGroup(stbl, 1);\n\t\tnb_samples--;\n\t}\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\n\n#define RECREATE_BOX(_a, __cast)\t\\\n    if (_a) {\t\\\n        type = _a->type;\\\n        gf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *)_a);\\\n        _a = __cast gf_isom_box_new_parent(&stbl->child_boxes, type);\\\n    }\\\n\n\nGF_EXPORT\nGF_Err gf_isom_reset_tables(GF_ISOFile *movie, Bool reset_sample_count)\n{\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i, j;\n\n\tif (!movie || !movie->moov || !movie->moov->mvex) return GF_BAD_PARAM;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_Box *a;\n\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(movie->moov->trackList, i);\n\n\t\tu32 type, dur;\n\t\tu64 dts;\n\t\tGF_SampleTableBox *stbl = trak->Media->information->sampleTable;\n\n\t\ttrak->sample_count_at_seg_start += stbl->SampleSize->sampleCount;\n\t\tif (trak->sample_count_at_seg_start) {\n\t\t\tGF_Err e;\n\t\t\te = stbl_GetSampleDTS_and_Duration(stbl->TimeToSample, stbl->SampleSize->sampleCount, &dts, &dur);\n\t\t\tif (e == GF_OK) {\n\t\t\t\ttrak->dts_at_seg_start += dts + dur;\n\t\t\t}\n\t\t}\n\n\t\tRECREATE_BOX(stbl->ChunkOffset, (GF_Box *));\n\t\tRECREATE_BOX(stbl->CompositionOffset, (GF_CompositionOffsetBox *));\n\t\tRECREATE_BOX(stbl->DegradationPriority, (GF_DegradationPriorityBox *));\n\t\tRECREATE_BOX(stbl->PaddingBits, (GF_PaddingBitsBox *));\n\t\tRECREATE_BOX(stbl->SampleDep, (GF_SampleDependencyTypeBox *));\n\t\tRECREATE_BOX(stbl->SampleSize, (GF_SampleSizeBox *));\n\t\tRECREATE_BOX(stbl->SampleToChunk, (GF_SampleToChunkBox *));\n\t\tRECREATE_BOX(stbl->ShadowSync, (GF_ShadowSyncBox *));\n\t\tRECREATE_BOX(stbl->SyncSample, (GF_SyncSampleBox *));\n\t\tRECREATE_BOX(stbl->TimeToSample, (GF_TimeToSampleBox *));\n\n\t\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sai_offsets);\n\t\tstbl->sai_offsets = NULL;\n\n\t\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sai_sizes);\n\t\tstbl->sai_sizes = NULL;\n\n\t\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sampleGroups);\n\t\tstbl->sampleGroups = NULL;\n\n\t\tj = stbl->nb_sgpd_in_stbl;\n\t\twhile ((a = (GF_Box *)gf_list_enum(stbl->sampleGroupsDescription, &j))) {\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\tj--;\n\t\t\tgf_list_rem(stbl->sampleGroupsDescription, j);\n\t\t}\n\n#if 0\n\t\tj = stbl->nb_stbl_boxes;\n\t\twhile ((a = (GF_Box *)gf_list_enum(stbl->child_boxes, &j))) {\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\tj--;\n\t\t}\n#endif\n\n\t\tif (reset_sample_count) {\n\t\t\ttrak->Media->information->sampleTable->SampleSize->sampleCount = 0;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\ttrak->sample_count_at_seg_start = 0;\n\t\t\ttrak->dts_at_seg_start = 0;\n\t\t\ttrak->first_traf_merged = GF_FALSE;\n#endif\n\t\t}\n\n\t}\n\tif (reset_sample_count) {\n\t\tmovie->NextMoofNumber = 0;\n\t}\n#endif\n\treturn GF_OK;\n\n}\n\nGF_EXPORT\nGF_Err gf_isom_release_segment(GF_ISOFile *movie, Bool reset_tables)\n{\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i, j, base_track_sample_count;\n\tBool has_scalable;\n\tGF_Box *a;\n\tif (!movie || !movie->moov || !movie->moov->mvex) return GF_BAD_PARAM;\n\thas_scalable = gf_isom_needs_layer_reconstruction(movie);\n\tbase_track_sample_count = 0;\n\tmovie->moov->compressed_diff = 0;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\ttrak->first_traf_merged = GF_FALSE;\n\t\tif (trak->Media->information->dataHandler == movie->movieFileMap) {\n\t\t\ttrak->Media->information->dataHandler = NULL;\n\t\t}\n\t\tif (trak->Media->information->scalableDataHandler == movie->movieFileMap) {\n\t\t\ttrak->Media->information->scalableDataHandler = NULL;\n\t\t} else {\n\t\t\tif (trak->Media->information->scalableDataHandler==trak->Media->information->dataHandler)\n\t\t\t\ttrak->Media->information->dataHandler = NULL;\n\n\t\t\tgf_isom_datamap_del(trak->Media->information->scalableDataHandler);\n\t\t\ttrak->Media->information->scalableDataHandler = NULL;\n\t\t}\n\n\n\t\tif (reset_tables) {\n\t\t\tu32 type, dur;\n\t\t\tu64 dts;\n\t\t\tGF_SampleTableBox *stbl = trak->Media->information->sampleTable;\n\n\t\t\tif (has_scalable) {\n\t\t\t\t//check if the base reference is in the file - if not, do not consider the track is scalable.\n\t\t\t\tif (gf_isom_get_reference_count(movie, i+1, GF_ISOM_REF_BASE) > 0) {\n\t\t\t\t\tu32 on_track=0;\n\t\t\t\t\tGF_TrackBox *base;\n\t\t\t\t\tgf_isom_get_reference(movie, i+1, GF_ISOM_REF_BASE, 1, &on_track);\n\n\t\t\t\t\tbase = gf_isom_get_track_from_file(movie, on_track);\n\t\t\t\t\tif (!base) {\n\t\t\t\t\t\tbase_track_sample_count=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbase_track_sample_count = base->Media->information->sampleTable->SampleSize->sampleCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttrak->sample_count_at_seg_start += base_track_sample_count ? base_track_sample_count : stbl->SampleSize->sampleCount;\n\n\t\t\tif (trak->sample_count_at_seg_start) {\n\t\t\t\tGF_Err e;\n\t\t\t\te = stbl_GetSampleDTS_and_Duration(stbl->TimeToSample, stbl->SampleSize->sampleCount, &dts, &dur);\n\t\t\t\tif (e == GF_OK) {\n\t\t\t\t\ttrak->dts_at_seg_start += dts + dur;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRECREATE_BOX(stbl->ChunkOffset, (GF_Box *));\n\t\t\tRECREATE_BOX(stbl->CompositionOffset, (GF_CompositionOffsetBox *));\n\t\t\tRECREATE_BOX(stbl->DegradationPriority, (GF_DegradationPriorityBox *));\n\t\t\tRECREATE_BOX(stbl->PaddingBits, (GF_PaddingBitsBox *));\n\t\t\tRECREATE_BOX(stbl->SampleDep, (GF_SampleDependencyTypeBox *));\n\t\t\tRECREATE_BOX(stbl->SampleSize, (GF_SampleSizeBox *));\n\t\t\tRECREATE_BOX(stbl->SampleToChunk, (GF_SampleToChunkBox *));\n\t\t\tRECREATE_BOX(stbl->ShadowSync, (GF_ShadowSyncBox *));\n\t\t\tRECREATE_BOX(stbl->SyncSample, (GF_SyncSampleBox *));\n\t\t\tRECREATE_BOX(stbl->TimeToSample, (GF_TimeToSampleBox *));\n\n\t\t\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sai_offsets);\n\t\t\tstbl->sai_offsets = NULL;\n\n\t\t\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sai_sizes);\n\t\t\tstbl->sai_sizes = NULL;\n\n\t\t\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sampleGroups);\n\t\t\tstbl->sampleGroups = NULL;\n\n\t\t\tif (trak->sample_encryption) {\n\t\t\t\tif (trak->Media->information->sampleTable->child_boxes) {\n\t\t\t\t\tgf_list_del_item(trak->Media->information->sampleTable->child_boxes, trak->sample_encryption);\n\t\t\t\t}\n\t\t\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box*)trak->sample_encryption);\n\t\t\t\ttrak->sample_encryption = NULL;\n\t\t\t}\n\n\t\t\tj = stbl->nb_sgpd_in_stbl;\n\t\t\twhile ((a = (GF_Box *)gf_list_enum(stbl->sampleGroupsDescription, &j))) {\n\t\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\t\tj--;\n\t\t\t\tgf_list_rem(stbl->sampleGroupsDescription, j);\n\t\t\t}\n\n\t\t\tif (stbl->traf_map) {\n\t\t\t\tfor (j=0; j<stbl->traf_map->nb_entries; j++) {\n\t\t\t\t\tif (stbl->traf_map->frag_starts[j].moof_template)\n\t\t\t\t\t\tgf_free(stbl->traf_map->frag_starts[j].moof_template);\n\t\t\t\t}\n\t\t\t\tmemset(stbl->traf_map->frag_starts, 0, sizeof(GF_TrafMapEntry)*stbl->traf_map->nb_alloc);\n\t\t\t\tstbl->traf_map->nb_entries = 0;\n\t\t\t}\n\n#if 0 // TO CHECK\n\t\t\tj = ptr->nb_stbl_boxes;\n\t\t\twhile ((a = (GF_Box *)gf_list_enum(stbl->child_boxes, &j))) {\n\t\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\t\tj--;\n\t\t\t}\n#endif\n\t\t}\n\n\n\t\tj = 0;\n\t\twhile ((a = (GF_Box *)gf_list_enum(movie->moov->child_boxes, &j))) {\n\t\t\tif (a->type == GF_ISOM_BOX_TYPE_PSSH) {\n\t\t\t\tgf_isom_box_del_parent(&movie->moov->child_boxes, a);\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t}\n\n\tgf_isom_datamap_del(movie->movieFileMap);\n\tmovie->movieFileMap = NULL;\n#endif\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_open_segment(GF_ISOFile *movie, const char *fileName, u64 start_range, u64 end_range, GF_ISOSegOpenMode flags)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn GF_NOT_SUPPORTED;\n#else\n\tu64 MissingBytes;\n\tGF_Err e;\n\tu32 i;\n\tBool segment_map_assigned = GF_FALSE;\n\tBool is_scalable_segment = (flags & GF_ISOM_SEGMENT_SCALABLE_FLAG) ? GF_TRUE : GF_FALSE;\n\tBool no_order_check = (flags & GF_ISOM_SEGMENT_NO_ORDER_FLAG) ? GF_TRUE: GF_FALSE;\n\tGF_DataMap *tmp = NULL;\n\tGF_DataMap *orig_file_map = NULL;\n\tif (!movie || !movie->moov || !movie->moov->mvex) return GF_BAD_PARAM;\n\tif (movie->openMode != GF_ISOM_OPEN_READ) return GF_BAD_PARAM;\n\n\t/*this is a scalable segment - use a temp data map for the associated track(s) but do NOT touch the movie file map*/\n\tif (is_scalable_segment) {\n\t\ttmp = NULL;\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_READ_ONLY, &tmp);\n\t\tif (e) return e;\n\n\t\torig_file_map = movie->movieFileMap;\n\t\tmovie->movieFileMap = tmp;\n\t} else {\n\t\tif (movie->movieFileMap)\n\t\t\tgf_isom_release_segment(movie, GF_FALSE);\n\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_READ_ONLY, &movie->movieFileMap);\n\t\tif (e) return e;\n\t}\n\tmovie->moov->compressed_diff = 0;\n\tmovie->current_top_box_start = 0;\n\n\tif (start_range || end_range) {\n\t\tif (end_range > start_range) {\n\t\t\tgf_bs_seek(movie->movieFileMap->bs, end_range+1);\n\t\t\tgf_bs_truncate(movie->movieFileMap->bs);\n\t\t}\n\t\tgf_bs_seek(movie->movieFileMap->bs, start_range);\n\t\tmovie->current_top_box_start = start_range;\n\t}\n\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\n\t\tif (!is_scalable_segment) {\n\t\t\t/*reset data handler to new segment*/\n\t\t\tif (trak->Media->information->dataHandler == NULL) {\n\t\t\t\ttrak->Media->information->dataHandler = movie->movieFileMap;\n\t\t\t}\n\t\t} else {\n\t\t\ttrak->present_in_scalable_segment = GF_FALSE;\n\t\t}\n\t}\n\tif (no_order_check) movie->NextMoofNumber = 0;\n\n\t//ok parse root boxes\n\te = gf_isom_parse_movie_boxes(movie, NULL, &MissingBytes, GF_TRUE);\n\n\tif (!is_scalable_segment)\n\t\treturn e;\n\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\tif (trak->present_in_scalable_segment) {\n\t\t\t/*store the temp dataHandler into scalableDataHandler so that it will not be destroyed\n\t\t\tif we append another representation - destruction of this data handler is done in release_segment*/\n\t\t\ttrak->Media->information->scalableDataHandler = tmp;\n\t\t\tif (!segment_map_assigned) {\n\t\t\t\ttrak->Media->information->scalableDataHandler = tmp;\n\t\t\t\tsegment_map_assigned = GF_TRUE;\n\t\t\t}\n\t\t\t//and update the regular dataHandler for the Media_GetSample function\n\t\t\ttrak->Media->information->dataHandler = tmp;\n\t\t}\n\t}\n\tmovie->movieFileMap = \torig_file_map;\n\treturn e;\n#endif\n}\n\nGF_EXPORT\nGF_ISOTrackID gf_isom_get_highest_track_in_scalable_segment(GF_ISOFile *movie, u32 for_base_track)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn 0;\n#else\n\ts32 max_ref;\n\tu32 i, j;\n\tGF_ISOTrackID track_id;\n\n\tmax_ref = 0;\n\ttrack_id = 0;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\ts32 ref;\n\t\tu32 ref_type = GF_ISOM_REF_SCAL;\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\tif (! trak->present_in_scalable_segment) continue;\n\n\t\tref = gf_isom_get_reference_count(movie, i+1, ref_type);\n\t\tif (ref<=0) {\n\t\t\t//handle implicit reconstruction for LHE1/LHV1, check sbas track ref\n\t\t\tu32 subtype = gf_isom_get_media_subtype(movie, i+1, 1);\n\t\t\tswitch (subtype) {\n\t\t\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\t\tcase GF_ISOM_SUBTYPE_LHV1:\n\t\t\t\tref = gf_isom_get_reference_count(movie, i+1, GF_ISOM_REF_BASE);\n\t\t\t\tif (ref<=0) continue;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (ref<=max_ref) continue;\n\n\t\tfor (j=0; j< (u32) ref; j++) {\n\t\t\tu32 on_track=0;\n\t\t\tgf_isom_get_reference(movie, i+1, GF_ISOM_REF_BASE, j+1, &on_track);\n\t\t\tif (on_track==for_base_track) {\n\t\t\t\tmax_ref = ref;\n\t\t\t\ttrack_id = trak->Header->trackID;\n\t\t\t}\n\t\t}\n\t}\n\treturn track_id;\n#endif\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_text_set_streaming_mode(GF_ISOFile *movie, Bool do_convert)\n{\n\tif (!movie) return GF_BAD_PARAM;\n\tmovie->convert_streaming_text = do_convert;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_GenericSampleDescription *gf_isom_get_generic_sample_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_GenericVisualSampleEntryBox *entry;\n\tGF_GenericAudioSampleEntryBox *gena;\n\tGF_GenericSampleEntryBox *genm;\n\tGF_TrackBox *trak;\n\tGF_GenericSampleDescription *udesc;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !StreamDescriptionIndex || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable) return 0;\n\n\tentry = (GF_GenericVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex-1);\n\t//no entry or MPEG entry:\n\tif (!entry || IsMP4Description(entry->type) ) return NULL;\n\t//if we handle the description return false\n\tswitch (entry->type) {\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\treturn NULL;\n\tcase GF_ISOM_BOX_TYPE_GNRV:\n\t\tGF_SAFEALLOC(udesc, GF_GenericSampleDescription);\n\t\tif (!udesc) return NULL;\n\t\tif (entry->EntryType == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tmemcpy(udesc->UUID, ((GF_UUIDBox*)entry)->uuid, sizeof(bin128));\n\t\t} else {\n\t\t\tudesc->codec_tag = entry->EntryType;\n\t\t}\n\t\tudesc->version = entry->version;\n\t\tudesc->revision = entry->revision;\n\t\tudesc->vendor_code = entry->vendor;\n\t\tudesc->temporal_quality = entry->temporal_quality;\n\t\tudesc->spatial_quality = entry->spatial_quality;\n\t\tudesc->width = entry->Width;\n\t\tudesc->height = entry->Height;\n\t\tudesc->h_res = entry->horiz_res;\n\t\tudesc->v_res = entry->vert_res;\n\t\tstrcpy(udesc->compressor_name, entry->compressor_name);\n\t\tudesc->depth = entry->bit_depth;\n\t\tudesc->color_table_index = entry->color_table_index;\n\t\tif (entry->data_size) {\n\t\t\tudesc->extension_buf_size = entry->data_size;\n\t\t\tudesc->extension_buf = (char*)gf_malloc(sizeof(char) * entry->data_size);\n\t\t\tif (!udesc->extension_buf) {\n\t\t\t\tgf_free(udesc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemcpy(udesc->extension_buf, entry->data, entry->data_size);\n\t\t}\n\t\treturn udesc;\n\tcase GF_ISOM_BOX_TYPE_GNRA:\n\t\tgena = (GF_GenericAudioSampleEntryBox *)entry;\n\t\tGF_SAFEALLOC(udesc, GF_GenericSampleDescription);\n\t\tif (!udesc) return NULL;\n\t\tif (gena->EntryType == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tmemcpy(udesc->UUID, ((GF_UUIDBox*)gena)->uuid, sizeof(bin128));\n\t\t} else {\n\t\t\tudesc->codec_tag = gena->EntryType;\n\t\t}\n\t\tudesc->version = gena->version;\n\t\tudesc->revision = gena->revision;\n\t\tudesc->vendor_code = gena->vendor;\n\t\tudesc->samplerate = gena->samplerate_hi;\n\t\tudesc->bits_per_sample = gena->bitspersample;\n\t\tudesc->nb_channels = gena->channel_count;\n\t\tif (gena->data_size) {\n\t\t\tudesc->extension_buf_size = gena->data_size;\n\t\t\tudesc->extension_buf = (char*)gf_malloc(sizeof(char) * gena->data_size);\n\t\t\tif (!udesc->extension_buf) {\n\t\t\t\tgf_free(udesc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemcpy(udesc->extension_buf, gena->data, gena->data_size);\n\t\t}\n\t\treturn udesc;\n\tcase GF_ISOM_BOX_TYPE_GNRM:\n\t\tgenm = (GF_GenericSampleEntryBox *)entry;\n\t\tGF_SAFEALLOC(udesc, GF_GenericSampleDescription);\n\t\tif (!udesc) return NULL;\n\t\tif (genm->EntryType == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tmemcpy(udesc->UUID, ((GF_UUIDBox*)genm)->uuid, sizeof(bin128));\n\t\t} else {\n\t\t\tudesc->codec_tag = genm->EntryType;\n\t\t}\n\t\tif (genm->data_size) {\n\t\t\tudesc->extension_buf_size = genm->data_size;\n\t\t\tudesc->extension_buf = (char*)gf_malloc(sizeof(char) * genm->data_size);\n\t\t\tif (!udesc->extension_buf) {\n\t\t\t\tgf_free(udesc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemcpy(udesc->extension_buf, genm->data, genm->data_size);\n\t\t}\n\t\treturn udesc;\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_visual_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *Width, u32 *Height)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t*Width = ((GF_VisualSampleEntryBox*)entry)->Width;\n\t\t*Height = ((GF_VisualSampleEntryBox*)entry)->Height;\n\t} else if (trak->Media->handler->handlerType==GF_ISOM_MEDIA_SCENE) {\n\t\t*Width = trak->Header->width>>16;\n\t\t*Height = trak->Header->height>>16;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_visual_bit_depth(GF_ISOFile* movie, u32 trackNumber, u32 StreamDescriptionIndex, u16* bitDepth)\n{\n\tGF_TrackBox* trak;\n\tGF_SampleEntryBox* entry;\n\tGF_SampleDescriptionBox* stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox*)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t*bitDepth = ((GF_VisualSampleEntryBox*)entry)->bit_depth;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_audio_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *SampleRate, u32 *Channels, u32 *bitsPerSample)\n{\n\tGF_TrackBox *trak;\n\tGF_AudioSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd = NULL;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->Media && trak->Media->information && trak->Media->information->sampleTable && trak->Media->information->sampleTable->SampleDescription)\n\t\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_AudioSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_BAD_PARAM;\n\n\tif (SampleRate) {\n\t\t(*SampleRate) = entry->samplerate_hi;\n\t\tif (entry->type==GF_ISOM_BOX_TYPE_MLPA) {\n\t\t\tu32 sr = entry->samplerate_hi;\n\t\t\tsr <<= 16;\n\t\t\tsr |= entry->samplerate_lo;\n\t\t\t(*SampleRate) = sr;\n\t\t}\n\t}\n\tif (Channels) (*Channels) = entry->channel_count;\n\tif (bitsPerSample) (*bitsPerSample) = (u8) entry->bitspersample;\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_audio_layout(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_AudioChannelLayout *layout)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_ChannelLayoutBox *chnl;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !layout) return GF_BAD_PARAM;\n\tmemset(layout, 0, sizeof(GF_AudioChannelLayout));\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_BAD_PARAM;\n\tchnl = (GF_ChannelLayoutBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CHNL);\n\tif (!chnl) return GF_NOT_FOUND;\n\n\tmemcpy(layout, &chnl->layout, sizeof(GF_AudioChannelLayout));\n\treturn GF_OK;\n}\nGF_EXPORT\nGF_Err gf_isom_get_pixel_aspect_ratio(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *hSpacing, u32 *vSpacing)\n{\n\tGF_TrackBox *trak;\n\tGF_VisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !hSpacing || !vSpacing) return GF_BAD_PARAM;\n\t*hSpacing = 1;\n\t*vSpacing = 1;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_VisualSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_OK;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type==GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\tGF_PixelAspectRatioBox *pasp = (GF_PixelAspectRatioBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_PASP);\n\t\tif (pasp) {\n\t\t\t*hSpacing = pasp->hSpacing;\n\t\t\t*vSpacing = pasp->vSpacing;\n\t\t}\n\t\treturn GF_OK;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_color_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *colour_type, u16 *colour_primaries, u16 *transfer_characteristics, u16 *matrix_coefficients, Bool *full_range_flag)\n{\n\tGF_TrackBox *trak;\n\tGF_VisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_VisualSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_OK;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type!=GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\tGF_ColourInformationBox *clr = (GF_ColourInformationBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_COLR);\n\tif (!clr) return GF_NOT_FOUND;\n\n\tif (colour_type) *colour_type = clr->colour_type;\n\tif (colour_primaries) *colour_primaries = clr->colour_primaries;\n\tif (transfer_characteristics) *transfer_characteristics = clr->transfer_characteristics;\n\tif (matrix_coefficients) *matrix_coefficients = clr->matrix_coefficients;\n\tif (full_range_flag) *full_range_flag = clr->full_range_flag;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nconst char *gf_isom_get_filename(GF_ISOFile *movie)\n{\n\tif (!movie) return NULL;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (movie->finalName && !movie->fileName) return movie->finalName;\n#endif\n\treturn movie->fileName;\n}\n\n\nGF_EXPORT\nu8 gf_isom_get_pl_indication(GF_ISOFile *movie, GF_ISOProfileLevelType PL_Code)\n{\n\tGF_IsomInitialObjectDescriptor *iod;\n\tif (!movie || !movie->moov) return 0xFF;\n\tif (!movie->moov->iods || !movie->moov->iods->descriptor) return 0xFF;\n\tif (movie->moov->iods->descriptor->tag != GF_ODF_ISOM_IOD_TAG) return 0xFF;\n\n\tiod = (GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor;\n\tswitch (PL_Code) {\n\tcase GF_ISOM_PL_AUDIO:\n\t\treturn iod->audio_profileAndLevel;\n\tcase GF_ISOM_PL_VISUAL:\n\t\treturn iod->visual_profileAndLevel;\n\tcase GF_ISOM_PL_GRAPHICS:\n\t\treturn iod->graphics_profileAndLevel;\n\tcase GF_ISOM_PL_SCENE:\n\t\treturn iod->scene_profileAndLevel;\n\tcase GF_ISOM_PL_OD:\n\t\treturn iod->OD_profileAndLevel;\n\tcase GF_ISOM_PL_INLINE:\n\t\treturn iod->inlineProfileFlag;\n\tcase GF_ISOM_PL_MPEGJ:\n\tdefault:\n\t\treturn 0xFF;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_matrix(GF_ISOFile *the_file, u32 trackNumber, u32 matrix[9])\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Header) return GF_BAD_PARAM;\n\tmemcpy(matrix, trak->Header->matrix, sizeof(trak->Header->matrix));\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_layout_info(GF_ISOFile *movie, u32 trackNumber, u32 *width, u32 *height, s32 *translation_x, s32 *translation_y, s16 *layer)\n{\n\tGF_TrackBox *tk = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!tk) return GF_BAD_PARAM;\n\tif (width) *width = tk->Header->width>>16;\n\tif (height) *height = tk->Header->height>>16;\n\tif (layer) *layer = tk->Header->layer;\n\tif (translation_x) *translation_x = tk->Header->matrix[6] >> 16;\n\tif (translation_y) *translation_y = tk->Header->matrix[7] >> 16;\n\treturn GF_OK;\n}\n\n\n/*returns total amount of media bytes in track*/\nGF_EXPORT\nu64 gf_isom_get_media_data_size(GF_ISOFile *movie, u32 trackNumber)\n{\n\tu32 i;\n\tu64 size;\n\tGF_SampleSizeBox *stsz;\n\tGF_TrackBox *tk = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!tk) return 0;\n\tstsz = tk->Media->information->sampleTable->SampleSize;\n\tif (!stsz) return 0;\n\tif (stsz->sampleSize) return stsz->sampleSize*stsz->sampleCount;\n\tsize = 0;\n\tfor (i=0; i<stsz->sampleCount; i++) size += stsz->sizes[i];\n\treturn size;\n}\n\n\nGF_EXPORT\nvoid gf_isom_set_default_sync_track(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *tk = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!tk) movie->es_id_default_sync = -1;\n\telse movie->es_id_default_sync = tk->Header->trackID;\n}\n\n\nGF_EXPORT\nBool gf_isom_is_single_av(GF_ISOFile *file)\n{\n\tu32 count, i, nb_any, nb_a, nb_v, nb_auxv, nb_pict, nb_scene, nb_od, nb_text;\n\tnb_auxv = nb_pict = nb_a = nb_v = nb_any = nb_scene = nb_od = nb_text = 0;\n\n\tif (!file->moov) return GF_FALSE;\n\tcount = gf_isom_get_track_count(file);\n\tfor (i=0; i<count; i++) {\n\t\tu32 mtype = gf_isom_get_media_type(file, i+1);\n\t\tswitch (mtype) {\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_any++;\n\t\t\telse nb_scene++;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_any++;\n\t\t\telse nb_od++;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\t\tnb_text++;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tnb_a++;\n\t\t\tbreak;\n        case GF_ISOM_MEDIA_AUXV:\n            /*discard file with images*/\n            if (gf_isom_get_sample_count(file, i+1)==1) nb_any++;\n            else nb_auxv++;\n            break;\n        case GF_ISOM_MEDIA_PICT:\n            /*discard file with images*/\n            if (gf_isom_get_sample_count(file, i+1)==1) nb_any++;\n            else nb_pict++;\n            break;\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\t/*discard file with images*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)==1) nb_any++;\n\t\t\telse nb_v++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnb_any++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (nb_any) return GF_FALSE;\n\tif ((nb_scene<=1) && (nb_od<=1) && (nb_a<=1) && (nb_v+nb_pict+nb_auxv<=1) && (nb_text<=1) ) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nBool gf_isom_is_JPEG2000(GF_ISOFile *mov)\n{\n\treturn (mov && mov->is_jp2) ? GF_TRUE : GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_guess_specification(GF_ISOFile *file)\n{\n\tu32 count, i, nb_any, nb_m4s, nb_a, nb_v, nb_auxv,nb_scene, nb_od, nb_mp3, nb_aac, nb_m4v, nb_avc, nb_amr, nb_h263, nb_qcelp, nb_evrc, nb_smv, nb_text, nb_pict;\n\n\tnb_m4s = nb_a = nb_v = nb_auxv = nb_any = nb_scene = nb_od = nb_mp3 = nb_aac = nb_m4v = nb_avc = nb_amr = nb_h263 = nb_qcelp = nb_evrc = nb_smv = nb_text = nb_pict = 0;\n\n\tif (file->is_jp2) {\n\t\tif (file->moov) return GF_ISOM_BRAND_MJP2;\n\t\treturn GF_ISOM_BRAND_JP2;\n\t}\n\tif (!file->moov) {\n\t\tif (!file->meta || !file->meta->handler) return 0;\n\t\treturn file->meta->handler->handlerType;\n\t}\n\n\tcount = gf_isom_get_track_count(file);\n\tfor (i=0; i<count; i++) {\n\t\tu32 mtype = gf_isom_get_media_type(file, i+1);\n\t\tu32 mstype = gf_isom_get_media_subtype(file, i+1, 1);\n\n\t\tif (mtype==GF_ISOM_MEDIA_SCENE) {\n\t\t\tnb_scene++;\n\t\t\t/*forces non-isma*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_m4s++;\n\t\t} else if (mtype==GF_ISOM_MEDIA_OD) {\n\t\t\tnb_od++;\n\t\t\t/*forces non-isma*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_m4s++;\n\t\t}\n\t\telse if ((mtype==GF_ISOM_MEDIA_TEXT) || (mtype==GF_ISOM_MEDIA_SUBT)) nb_text++;\n\t\telse if ((mtype==GF_ISOM_MEDIA_AUDIO) || gf_isom_is_video_handler_type(mtype) ) {\n\t\t\tswitch (mstype) {\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\t\tnb_amr++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\t\tnb_h263++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t\t\tnb_evrc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\t\tnb_qcelp++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\t\tnb_smv++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\t\t\tnb_avc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\t\t\tnb_avc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\t\tcase GF_ISOM_SUBTYPE_MPEG4_CRYP:\n\t\t\t{\n\t\t\t\tGF_DecoderConfig *dcd = gf_isom_get_decoder_config(file, i+1, 1);\n\t\t\t\tif (!dcd) break;\n\t\t\t\tswitch (dcd->streamType) {\n\t\t\t\tcase GF_STREAM_VISUAL:\n\t\t\t\t\tif (dcd->objectTypeIndication==GF_CODECID_MPEG4_PART2) nb_m4v++;\n\t\t\t\t\telse if ((dcd->objectTypeIndication==GF_CODECID_AVC) || (dcd->objectTypeIndication==GF_CODECID_SVC) || (dcd->objectTypeIndication==GF_CODECID_MVC)) nb_avc++;\n\t\t\t\t\telse nb_v++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_STREAM_AUDIO:\n\t\t\t\t\tswitch (dcd->objectTypeIndication) {\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG2_MP:\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG2_LCP:\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG4:\n\t\t\t\t\t\tnb_aac++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_MPEG2_PART3:\n\t\t\t\t\tcase GF_CODECID_MPEG_AUDIO:\n\t\t\t\t\t\tnb_mp3++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_EVRC:\n\t\t\t\t\t\tnb_evrc++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_SMV:\n\t\t\t\t\t\tnb_smv++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_QCELP:\n\t\t\t\t\t\tnb_qcelp++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tnb_a++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t/*SHOULD NEVER HAPPEN - IF SO, BROKEN MPEG4 FILE*/\n\t\t\t\tdefault:\n\t\t\t\t\tnb_any++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)dcd);\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (mtype==GF_ISOM_MEDIA_VISUAL) nb_v++;\n\t\t\t\telse if (mtype==GF_ISOM_MEDIA_AUXV) nb_auxv++;\n\t\t\t\telse if (mtype==GF_ISOM_MEDIA_PICT) nb_pict++;\n\t\t\t\telse nb_a++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((mtype==GF_ISOM_SUBTYPE_MPEG4) || (mtype==GF_ISOM_SUBTYPE_MPEG4_CRYP)) nb_m4s++;\n\t\telse nb_any++;\n\t}\n\tif (nb_any) return GF_ISOM_BRAND_ISOM;\n\tif (nb_qcelp || nb_evrc || nb_smv) {\n\t\t/*non std mix of streams*/\n\t\tif (nb_m4s || nb_avc || nb_scene || nb_od || nb_mp3 || nb_a || nb_v) return GF_ISOM_BRAND_ISOM;\n\t\treturn GF_ISOM_BRAND_3G2A;\n\t}\n\t/*other a/v/s streams*/\n\tif (nb_v || nb_a || nb_m4s) return GF_ISOM_BRAND_MP42;\n\n\tnb_v = nb_m4v + nb_avc + nb_h263;\n\tnb_a = nb_mp3 + nb_aac + nb_amr;\n\n\t/*avc file: whatever has AVC and no systems*/\n\tif (nb_avc) {\n\t\tif (!nb_scene && !nb_od) return GF_ISOM_BRAND_AVC1;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\t/*MP3: ISMA and MPEG4*/\n\tif (nb_mp3) {\n\t\tif (!nb_text && (nb_v<=1) && (nb_a<=1) && (nb_scene==1) && (nb_od==1))\n\t\t\treturn GF_ISOM_BRAND_ISMA;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\t/*MP4*/\n\tif (nb_scene || nb_od) {\n\t\t/*issue with AMR and H263 which don't have MPEG mapping: non compliant file*/\n\t\tif (nb_amr || nb_h263) return GF_ISOM_BRAND_ISOM;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\t/*use ISMA (3GP fine too)*/\n\tif (!nb_amr && !nb_h263 && !nb_text) {\n\t\tif ((nb_v<=1) && (nb_a<=1)) return GF_ISOM_BRAND_ISMA;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\n\tif ((nb_v<=1) && (nb_a<=1) && (nb_text<=1)) return nb_text ? GF_ISOM_BRAND_3GP6 : GF_ISOM_BRAND_3GP5;\n\treturn GF_ISOM_BRAND_3GG6;\n}\n\nGF_ItemListBox *gf_ismo_locate_box(GF_List *list, u32 boxType, bin128 UUID)\n{\n\tu32 i;\n\tGF_Box *box;\n\ti=0;\n\twhile ((box = (GF_Box *)gf_list_enum(list, &i))) {\n\t\tif (box->type == boxType) {\n\t\t\tGF_UUIDBox* box2 = (GF_UUIDBox* )box;\n\t\t\tif (boxType != GF_ISOM_BOX_TYPE_UUID) return (GF_ItemListBox *)box;\n\t\t\tif (!memcmp(box2->uuid, UUID, 16)) return (GF_ItemListBox *)box;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/*Apple extensions*/\n\n\nGF_EXPORT\nGF_Err gf_isom_apple_get_tag(GF_ISOFile *mov, GF_ISOiTunesTag tag, const u8 **data, u32 *data_len)\n{\n\tu32 i;\n\tGF_ListItemBox *info;\n\tGF_ItemListBox *ilst;\n\tGF_MetaBox *meta;\n\n\t*data = NULL;\n\t*data_len = 0;\n\n\tmeta = (GF_MetaBox *) gf_isom_get_meta_extensions(mov, GF_FALSE);\n\tif (!meta) return GF_URL_ERROR;\n\n\tilst = gf_ismo_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_ILST, NULL);\n\tif (!ilst) return GF_URL_ERROR;\n\n\tif (tag==GF_ISOM_ITUNE_PROBE) return gf_list_count(ilst->child_boxes) ? GF_OK : GF_URL_ERROR;\n\n\ti=0;\n\twhile ( (info=(GF_ListItemBox*)gf_list_enum(ilst->child_boxes, &i))) {\n\t\tif (info->type==tag) break;\n\t\t/*special cases*/\n\t\tif ((tag==GF_ISOM_ITUNE_GENRE) && (info->type==(u32) GF_ISOM_ITUNE_GENRE_USER)) break;\n\t\tinfo = NULL;\n\t}\n\tif (!info || !info->data || !info->data->data) return GF_URL_ERROR;\n\n\tif ((tag == GF_ISOM_ITUNE_GENRE) && (info->data->flags == 0)) {\n\t\tif (info->data->dataSize && (info->data->dataSize>2) && (info->data->dataSize < 5)) {\n\t\t\tGF_BitStream* bs = gf_bs_new(info->data->data, info->data->dataSize, GF_BITSTREAM_READ);\n\t\t\t*data_len = gf_bs_read_int(bs, info->data->dataSize * 8);\n\t\t\tgf_bs_del(bs);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n//\tif (info->data->flags != 0x1) return GF_URL_ERROR;\n\t*data = info->data->data;\n\t*data_len = info->data->dataSize;\n\tif ((tag==GF_ISOM_ITUNE_COVER_ART) && (info->data->flags==14)) *data_len |= 0x80000000; //(1<<31);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_apple_enum_tag(GF_ISOFile *mov, u32 idx, GF_ISOiTunesTag *out_tag, const u8 **data, u32 *data_len, u64 *out_int_val, u32 *out_int_val2, u32 *out_flags)\n{\n\tu32 i, child_index;\n\tGF_ListItemBox *info;\n\tGF_ItemListBox *ilst;\n\tGF_MetaBox *meta;\n\tGF_DataBox *dbox = NULL;\n\tu32 itype, tag_val;\n\ts32 tag_idx;\n\t*data = NULL;\n\t*data_len = 0;\n\n\tmeta = (GF_MetaBox *) gf_isom_get_meta_extensions(mov, GF_FALSE);\n\tif (!meta) return GF_URL_ERROR;\n\n\tilst = gf_ismo_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_ILST, NULL);\n\tif (!ilst) return GF_URL_ERROR;\n\n\tchild_index = i = 0;\n\twhile ( (info=(GF_ListItemBox*)gf_list_enum(ilst->child_boxes, &i))) {\n\t\tGF_DataBox *data_box = NULL;\n\t\tif (gf_itags_find_by_itag(info->type)<0) {\n\t\t\tif (info->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\t\tdata_box = (GF_DataBox *) gf_isom_box_find_child(info->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\t\t\t\tif (!data_box) continue;\n\t\t\t\ttag_val = ((GF_UnknownBox *)info)->original_4cc;\n\t\t\t}\n\t\t} else {\n\t\t\tdata_box = info->data;\n\t\t\ttag_val = info->type;\n\t\t}\n\t\tif (child_index==idx) {\n\t\t\tdbox = data_box;\n\t\t\tbreak;\n\t\t}\n\t\tchild_index++;\n\t}\n\tif (!dbox) return GF_URL_ERROR;\n\n\t*out_flags = dbox->flags;\n\t*out_tag = tag_val;\n\tif (!dbox->data) {\n\t\t*data = NULL;\n\t\t*data_len = 1;\n\t\treturn GF_OK;\n\t}\n\n\ttag_idx = gf_itags_find_by_itag(info->type);\n\tif (tag_idx<0) {\n\t\t*data = dbox->data;\n\t\t*data_len = dbox->dataSize;\n\t\treturn GF_OK;\n\t}\n\n\tif ((tag_val == GF_ISOM_ITUNE_GENRE) && (dbox->flags == 0) && (dbox->dataSize>2)) {\n\t\tu32 int_val = dbox->data[0];\n\t\tint_val <<= 8;\n\t\tint_val |= dbox->data[1];\n\t\t*data = NULL;\n\t\t*data_len = 0;\n\t\t*out_int_val = int_val;\n\t\treturn GF_OK;\n\t}\n\n\titype = gf_itags_get_type((u32) tag_idx);\n\tswitch (itype) {\n\tcase GF_ITAG_BOOL:\n\tcase GF_ITAG_INT8:\n\t\tif (dbox->dataSize) *out_int_val = dbox->data[0];\n\t\tbreak;\n\tcase GF_ITAG_INT16:\n\t\tif (dbox->dataSize>1) {\n\t\t\tu16 v = dbox->data[0];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[1];\n\t\t\t*out_int_val = v;\n\t\t}\n\t\tbreak;\n\tcase GF_ITAG_INT32:\n\t\tif (dbox->dataSize>3) {\n\t\t\tu32 v = dbox->data[0];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[1];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[2];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[3];\n\t\t\t*out_int_val = v;\n\t\t}\n\t\tbreak;\n\tcase GF_ITAG_INT64:\n\t\tif (dbox->dataSize>3) {\n\t\t\tu64 v = dbox->data[0];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[1];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[2];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[3];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[4];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[5];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[6];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[7];\n\t\t\t*out_int_val = v;\n\t\t}\n\t\tbreak;\n\tcase GF_ITAG_FRAC6:\n\tcase GF_ITAG_FRAC8:\n\t\tif (dbox->dataSize>3) {\n\t\t\tu32 v = dbox->data[2];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[3];\n\t\t\t*out_int_val = v;\n\t\t\tv = dbox->data[4];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[5];\n\t\t\t*out_int_val2 = v;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t*data = dbox->data;\n\t\t*data_len = dbox->dataSize;\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_wma_enum_tag(GF_ISOFile *mov, u32 idx, char **out_tag, const u8 **data, u32 *data_len, u32 *version, u32 *data_type)\n{\n\tGF_XtraBox *xtra;\n\tGF_XtraTag *tag;\n\n\t*out_tag = NULL;\n\t*data = NULL;\n\t*data_len = 0;\n\t*version = 0;\n\t*data_type = 0;\n\n\txtra = (GF_XtraBox *) gf_isom_get_meta_extensions(mov, GF_TRUE);\n\tif (!xtra) return GF_URL_ERROR;\n\n\ttag = gf_list_get(xtra->tags, idx);\n\tif (!tag) return GF_NOT_FOUND;\n\t*out_tag = tag->name;\n\t*data_len = tag->prop_size;\n\t*data = tag->prop_value;\n\t*version = tag->flags;\n\t*data_type = tag->prop_type;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_get_track_switch_group_count(GF_ISOFile *movie, u32 trackNumber, u32 *alternateGroupID, u32 *nb_groups)\n{\n\tGF_UserDataMap *map;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Header) return GF_BAD_PARAM;\n\t*alternateGroupID = trak->Header->alternate_group;\n\t*nb_groups = 0;\n\tif (!trak->udta) return GF_OK;\n\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (!map) return GF_OK;\n\t*nb_groups = gf_list_count(map->boxes);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nconst u32 *gf_isom_get_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, u32 group_index, u32 *switchGroupID, u32 *criteriaListSize)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_TrackSelectionBox *tsel;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!group_index || !trak || !trak->udta) return NULL;\n\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (!map) return NULL;\n\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, group_index-1);\n\tif (!tsel) return NULL;\n\t\n\t*switchGroupID = tsel->switchGroup;\n\t*criteriaListSize = tsel->attributeListCount;\n\treturn (const u32 *) tsel->attributeList;\n}\n\nGF_EXPORT\nu32 gf_isom_get_next_alternate_group_id(GF_ISOFile *movie)\n{\n\tu32 id = 0;\n\tu32 i=0;\n\n\twhile (i< gf_isom_get_track_count(movie) ) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, i+1);\n\t\tif (trak->Header->alternate_group > id)\n\t\t\tid = trak->Header->alternate_group;\n\t\ti++;\n\t}\n\treturn id+1;\n}\n\nGF_EXPORT\nu8 *gf_isom_sample_get_subsamples_buffer(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 *osize)\n{\n\tu8 *data;\n\tu32 size;\n\tu32 i, count;\n\tGF_BitStream *bs = NULL;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak || !osize) return NULL;\n\tif (!trak->Media || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->sub_samples) return NULL;\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sub_samples);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j, sub_count, last_sample = 0;\n\t\tGF_SubSampleInformationBox *sub_samples = gf_list_get(trak->Media->information->sampleTable->sub_samples, i);\n\n\t\tsub_count = gf_list_count(sub_samples->Samples);\n\t\tfor (j=0; j<sub_count; j++) {\n\t\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry *) gf_list_get(sub_samples->Samples, j);\n\t\t\tif (last_sample + pSamp->sample_delta == sampleNumber) {\n\t\t\t\tu32 scount = gf_list_count(pSamp->SubSamples);\n\t\t\t\tfor (j=0; j<scount; j++) {\n\t\t\t\t\tGF_SubSampleEntry *sent = gf_list_get(pSamp->SubSamples, j);\n\t\t\t\t\tif (!bs) bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\t\tgf_bs_write_u32(bs, sub_samples->flags);\n\t\t\t\t\tgf_bs_write_u32(bs, sent->subsample_size);\n\t\t\t\t\tgf_bs_write_u32(bs, sent->reserved);\n\t\t\t\t\tgf_bs_write_u8(bs, sent->subsample_priority);\n\t\t\t\t\tgf_bs_write_u8(bs, sent->discardable);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast_sample += pSamp->sample_delta;\n\t\t}\n\t}\n\tif (!bs) return NULL;\n\tgf_bs_get_content(bs, &data, &size);\n\tgf_bs_del(bs);\n\t*osize = size;\n\treturn data;\n}\n\nGF_EXPORT\nu32 gf_isom_sample_has_subsamples(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 flags)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->sub_samples) return 0;\n\tif (!sampleNumber) return 1;\n\treturn gf_isom_sample_get_subsample_entry(movie, track, sampleNumber, flags, NULL);\n}\n\nGF_EXPORT\nGF_Err gf_isom_sample_get_subsample(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 flags, u32 subSampleNumber, u32 *size, u8 *priority, u32 *reserved, Bool *discardable)\n{\n\tGF_SubSampleEntry *entry;\n\tGF_SubSampleInfoEntry *sub_sample;\n\tu32 count = gf_isom_sample_get_subsample_entry(movie, track, sampleNumber, flags, &sub_sample);\n\tif (!size || !priority || !discardable) return GF_BAD_PARAM;\n\n\tif (!subSampleNumber || (subSampleNumber>count)) return GF_BAD_PARAM;\n\tentry = (GF_SubSampleEntry*)gf_list_get(sub_sample->SubSamples, subSampleNumber-1);\n\t*size = entry->subsample_size;\n\t*priority = entry->subsample_priority;\n\t*reserved = entry->reserved;\n\t*discardable = entry->discardable ? GF_TRUE : GF_FALSE;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_rvc_config(GF_ISOFile *movie, u32 track, u32 sampleDescriptionIndex, u16 *rvc_predefined, u8 **data, u32 *size, const char **mime)\n{\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_TrackBox *trak;\n\n\tif (!rvc_predefined || !data || !size) return GF_BAD_PARAM;\n\t*rvc_predefined = 0;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!entry ) return GF_BAD_PARAM;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_RVCConfigurationBox *rvcc = (GF_RVCConfigurationBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RVCC);\n\tif (!rvcc) return GF_NOT_FOUND;\n\n\t*rvc_predefined = rvcc->predefined_rvc_config;\n\tif (rvcc->rvc_meta_idx) {\n\t\tif (!data || !size) return GF_OK;\n\t\treturn gf_isom_extract_meta_item_mem(movie, GF_FALSE, track, rvcc->rvc_meta_idx, data, size, NULL, mime, GF_FALSE);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nBool gf_isom_moov_first(GF_ISOFile *movie)\n{\n\tu32 i;\n\tfor (i=0; i<gf_list_count(movie->TopBoxes); i++) {\n\t\tGF_Box *b = (GF_Box*)gf_list_get(movie->TopBoxes, i);\n\t\tif (b->type == GF_ISOM_BOX_TYPE_MOOV) return GF_TRUE;\n\t\tif (b->type == GF_ISOM_BOX_TYPE_MDAT) return GF_FALSE;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nvoid gf_isom_reset_fragment_info(GF_ISOFile *movie, Bool keep_sample_count)\n{\n\tu32 i;\n\tif (!movie) return;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\ttrak->Media->information->sampleTable->SampleSize->sampleCount = 0;\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\t}\n#else\n\t\t//do not reset tfdt for LL-HLS case where parts do not contain a TFDT\n\t\t//trak->dts_at_seg_start = 0;\n\t\tif (!keep_sample_count)\n\t\t\ttrak->sample_count_at_seg_start = 0;\n\t}\n\tmovie->NextMoofNumber = 0;\n#endif\n}\n\nGF_EXPORT\nvoid gf_isom_reset_seq_num(GF_ISOFile *movie)\n{\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\tmovie->NextMoofNumber = 0;\n#endif\n}\n\nGF_EXPORT\nvoid gf_isom_reset_sample_count(GF_ISOFile *movie)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i;\n\tif (!movie) return;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\ttrak->Media->information->sampleTable->SampleSize->sampleCount = 0;\n\t\ttrak->sample_count_at_seg_start = 0;\n\t}\n\tmovie->NextMoofNumber = 0;\n#endif\n}\n\nGF_EXPORT\nBool gf_isom_has_cenc_sample_group(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tu32 i, count;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->sampleGroups) return GF_FALSE;\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\tif (sgdesc->grouping_type==GF_ISOM_SAMPLE_GROUP_SEIG) {\n\t\t\treturn GF_TRUE;\n\t\t}\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_rap_roll_info(GF_ISOFile *the_file, u32 trackNumber, u32 sample_number, Bool *is_rap, GF_ISOSampleRollType *roll_type, s32 *roll_distance)\n{\n\tGF_TrackBox *trak;\n\tu32 i, count;\n\n\tif (is_rap) *is_rap = GF_FALSE;\n\tif (roll_type) *roll_type = 0;\n\tif (roll_distance) *roll_distance = 0;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->sampleGroups) return GF_OK;\n\n\tif (!sample_number) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\t\tswitch (sgdesc->grouping_type) {\n\t\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t\t\tif (is_rap) *is_rap = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\t\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\t\t\tif (roll_type)\n\t\t\t\t\t*roll_type = (sgdesc->grouping_type==GF_ISOM_SAMPLE_GROUP_PROL) ? GF_ISOM_SAMPLE_PREROLL : GF_ISOM_SAMPLE_ROLL;\n\t\t\t\tif (roll_distance) {\n\t\t\t\t\ts32 max_roll = 0;\n\t\t\t\t\tu32 j;\n\t\t\t\t\tfor (j=0; j<gf_list_count(sgdesc->group_descriptions); j++) {\n\t\t\t\t\t\tGF_RollRecoveryEntry *roll_entry = (GF_RollRecoveryEntry*)gf_list_get(sgdesc->group_descriptions, j);\n\t\t\t\t\t\tif (max_roll < roll_entry->roll_distance)\n\t\t\t\t\t\t\tmax_roll = roll_entry->roll_distance;\n\t\t\t\t\t}\n\t\t\t\t\tif (*roll_distance < max_roll) *roll_distance = max_roll;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroups);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupBox *sg;\n\t\tu32 j, group_desc_index;\n\t\tGF_SampleGroupDescriptionBox *sgdesc;\n\t\tu32 first_sample_in_entry, last_sample_in_entry;\n\t\tfirst_sample_in_entry = 1;\n\t\tgroup_desc_index = 0;\n\t\tsg = (GF_SampleGroupBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);\n\t\tfor (j=0; j<sg->entry_count; j++) {\n\t\t\tlast_sample_in_entry = first_sample_in_entry + sg->sample_entries[j].sample_count - 1;\n\t\t\tif ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {\n\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*we found our sample*/\n\t\t\tgroup_desc_index = sg->sample_entries[j].group_description_index;\n\t\t\tbreak;\n\t\t}\n\t\t/*no sampleGroup info associated*/\n\t\tif (!group_desc_index) continue;\n\n\t\tsgdesc = NULL;\n\t\tfor (j=0; j<gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription); j++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, j);\n\t\t\tif (sgdesc->grouping_type==sg->grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t\t/*no sampleGroup description found for this group (invalid file)*/\n\t\tif (!sgdesc) continue;\n\n\t\tswitch (sgdesc->grouping_type) {\n\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t\tif (is_rap) *is_rap = GF_TRUE;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\t\tif (roll_type)\n\t\t\t\t*roll_type = (sgdesc->grouping_type==GF_ISOM_SAMPLE_GROUP_PROL) ? GF_ISOM_SAMPLE_PREROLL : GF_ISOM_SAMPLE_ROLL;\n\n\t\t\tif (roll_distance) {\n\t\t\t\tGF_RollRecoveryEntry *roll_entry = (GF_RollRecoveryEntry *) gf_list_get(sgdesc->group_descriptions, group_desc_index - 1);\n\t\t\t\tif (roll_entry)\n\t\t\t\t\t*roll_distance = roll_entry->roll_distance;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_DefaultSampleGroupDescriptionEntry * gf_isom_get_sample_group_info_entry(GF_ISOFile *the_file, GF_TrackBox *trak, u32 grouping_type, u32 sample_group_description_index, u32 *default_index, GF_SampleGroupDescriptionBox **out_sgdp)\n{\n\tu32 i, count;\n\n\tif (!trak || !sample_group_description_index) return NULL;\n\tif (!trak->Media->information->sampleTable->sampleGroupsDescription) return NULL;\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\tif (sgdesc->grouping_type != grouping_type) continue;\n\n\t\tif (sgdesc->default_description_index && !sample_group_description_index) sample_group_description_index = sgdesc->default_description_index;\n\n\t\tif (default_index) *default_index = sgdesc->default_description_index ;\n\t\tif (out_sgdp) *out_sgdp = sgdesc;\n\n\t\tif (!sample_group_description_index) return NULL;\n\t\treturn (GF_DefaultSampleGroupDescriptionEntry*)gf_list_get(sgdesc->group_descriptions, sample_group_description_index-1);\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nBool gf_isom_get_sample_group_info(GF_ISOFile *the_file, u32 trackNumber, u32 sample_description_index, u32 grouping_type, u32 *default_index, const u8 **data, u32 *size)\n{\n\tGF_DefaultSampleGroupDescriptionEntry *sg_entry;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\n\tif (default_index) *default_index = 0;\n\tif (size) *size = 0;\n\tif (data) *data = NULL;\n\n\tsg_entry = gf_isom_get_sample_group_info_entry(the_file, trak, grouping_type, sample_description_index, default_index, NULL);\n\tif (!sg_entry) return GF_FALSE;\n\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tif (sg_entry && data) *data = (char *) sg_entry->data;\n\t\tif (sg_entry && size) *size = sg_entry->length;\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n//return the duration of the movie+fragments if known, 0 if error\nGF_EXPORT\nu64 gf_isom_get_fragmented_duration(GF_ISOFile *movie)\n{\n\tif (movie->moov->mvex && movie->moov->mvex->mehd)\n\t\treturn movie->moov->mvex->mehd->fragment_duration;\n\n\treturn 0;\n}\n//return the duration of the movie+fragments if known, 0 if error\nGF_EXPORT\nu32 gf_isom_get_fragments_count(GF_ISOFile *movie, Bool segments_only)\n{\n\tu32 i=0;\n\tu32 nb_frags = 0;\n\tGF_Box *b;\n\twhile ((b=(GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tif (segments_only) {\n\t\t\tif (b->type==GF_ISOM_BOX_TYPE_SIDX)\n\t\t\t\tnb_frags++;\n\t\t} else {\n\t\t\tif (b->type==GF_ISOM_BOX_TYPE_MOOF)\n\t\t\t\tnb_frags++;\n\t\t}\n\t}\n\treturn nb_frags;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_fragmented_samples_info(GF_ISOFile *movie, GF_ISOTrackID trackID, u32 *nb_samples, u64 *duration)\n{\n\tu32 i=0;\n\tu32 k, l;\n\tGF_MovieFragmentBox *moof;\n\tGF_TrackFragmentBox *traf;\n\n\t*nb_samples = 0;\n\t*duration = 0;\n\twhile ((moof=(GF_MovieFragmentBox*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tu32 j=0;\n\t\tif (moof->type!=GF_ISOM_BOX_TYPE_MOOF) continue;\n\n\t\twhile ((traf=(GF_TrackFragmentBox*)gf_list_enum( moof->TrackList, &j))) {\n\t\t\tu64 def_duration, samp_dur=0;\n\n\t\t\tif (traf->tfhd->trackID != trackID)\n\t\t\t\tcontinue;\n\n\t\t\tdef_duration = 0;\n\t\t\tif (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DUR) def_duration = traf->tfhd->def_sample_duration;\n\t\t\telse if (traf->trex) def_duration = traf->trex->def_sample_duration;\n\n\t\t\tfor (k=0; k<gf_list_count(traf->TrackRuns); k++) {\n\t\t\t\tGF_TrackFragmentRunBox *trun = (GF_TrackFragmentRunBox*)gf_list_get(traf->TrackRuns, k);\n\t\t\t\t*nb_samples += trun->sample_count;\n\n\t\t\t\tfor (l=0; l<trun->nb_samples; l++) {\n\t\t\t\t\tGF_TrunEntry *ent = &trun->samples[l];\n\n\t\t\t\t\tsamp_dur = def_duration;\n\t\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DURATION) samp_dur = ent->Duration;\n\t\t\t\t\tif (trun->nb_samples == trun->sample_count)\n\t\t\t\t\t\t*duration += samp_dur;\n\t\t\t\t}\n\t\t\t\tif (trun->nb_samples != trun->sample_count)\n\t\t\t\t\t*duration += samp_dur * trun->sample_count;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_set_nalu_extract_mode(GF_ISOFile *the_file, u32 trackNumber, GF_ISONaluExtractMode nalu_extract_mode)\n{\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrak->extractor_mode = nalu_extract_mode;\n\n\tif (!trak->References) return GF_OK;\n\n\t/*get base*/\n\tdpnd = NULL;\n\ttrak->has_base_layer = GF_FALSE;\n\tTrack_FindRef(trak, GF_ISOM_REF_SCAL, &dpnd);\n\tif (dpnd) trak->has_base_layer = GF_TRUE;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_ISONaluExtractMode gf_isom_get_nalu_extract_mode(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->extractor_mode;\n}\n\nGF_EXPORT\ns32 gf_isom_get_composition_offset_shift(GF_ISOFile *file, u32 track)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return 0;\n\tif (!trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->CompositionToDecode) return 0;\n\treturn trak->Media->information->sampleTable->CompositionToDecode->compositionToDTSShift;\n}\n\nGF_EXPORT\nBool gf_isom_needs_layer_reconstruction(GF_ISOFile *file)\n{\n\tu32 count, i;\n\tif (!file)\n\t\treturn GF_FALSE;\n\tcount = gf_isom_get_track_count(file);\n\tfor (i = 0; i < count; i++) {\n\t\tif (gf_isom_get_reference_count(file, i+1, GF_ISOM_REF_SCAL) > 0) {\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\tif (gf_isom_get_reference_count(file, i+1, GF_ISOM_REF_SABT) > 0) {\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\tswitch (gf_isom_get_media_subtype(file, i+1, 1)) {\n\t\tcase GF_ISOM_SUBTYPE_LHV1:\n\t\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t\tif (gf_isom_get_reference_count(file, i+1, GF_ISOM_REF_BASE) > 0) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nvoid gf_isom_keep_utc_times(GF_ISOFile *file, Bool keep_utc)\n{\n\tif (!file) return;\n\tfile->keep_utc = keep_utc;\n}\n\nGF_EXPORT\nBool gf_isom_has_keep_utc_times(GF_ISOFile *file)\n{\n\tif (!file) return GF_FALSE;\n\treturn file->keep_utc;\n}\n\n\n\nGF_EXPORT\nu32 gf_isom_get_pssh_count(GF_ISOFile *file)\n{\n\tu32 count=0;\n\tu32 i=0;\n\tGF_Box *a_box;\n\tif (file->moov) {\n\t\twhile ((a_box = (GF_Box*)gf_list_enum(file->moov->child_boxes, &i))) {\n\t\t\tif (a_box->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (file->meta) {\n\t\twhile ((a_box = (GF_Box*)gf_list_enum(file->meta->child_boxes, &i))) {\n\t\t\tif (a_box->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\n#if 0 //unused\n/*! gets serialized PSS\n\\param isom_file the target ISO file\n\\param pssh_index 1-based index of PSSH to query, see \\ref gf_isom_get_pssh_count\n\\param pssh_data set to a newly allocated buffer containing serialized PSSH - shall be freeed by caller\n\\param pssh_size set to the size of the allocated buffer\n\\return error if any\n*/\nGF_Err gf_isom_get_pssh(GF_ISOFile *file, u32 pssh_index, u8 **pssh_data, u32 *pssh_size)\n{\n\tGF_Err e;\n\tu32 i=0;\n\tGF_BitStream *bs;\n\tu32 count=1;\n\tGF_Box *pssh;\n\twhile ((pssh = (GF_Box *)gf_list_enum(file->moov->child_boxes, &i))) {\n\t\tif (pssh->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\tif (count == pssh_index) break;\n\t\tcount++;\n\t}\n\tif (!pssh) return GF_BAD_PARAM;\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\te = gf_isom_box_write(pssh, bs);\n\tif (!e) {\n\t\tgf_bs_get_content(bs, pssh_data, pssh_size);\n\t}\n\tgf_bs_del(bs);\n\treturn e;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_get_pssh_info(GF_ISOFile *file, u32 pssh_index, bin128 SystemID, u32 *version, u32 *KID_count, const bin128 **KIDs, const u8 **private_data, u32 *private_data_size)\n{\n\tu32 count=1;\n\tu32 i=0;\n\tGF_ProtectionSystemHeaderBox *pssh=NULL;\n\tif (file->moov) {\n\t\twhile ((pssh = (GF_ProtectionSystemHeaderBox *)gf_list_enum(file->moov->child_boxes, &i))) {\n\t\t\tif (pssh->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tif (count == pssh_index) break;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (!pssh && file->meta) {\n\t\twhile ((pssh = (GF_ProtectionSystemHeaderBox *)gf_list_enum(file->meta->child_boxes, &i))) {\n\t\t\tif (pssh->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tif (count == pssh_index) break;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (!pssh) return GF_BAD_PARAM;\n\n\tif (SystemID) memcpy(SystemID, pssh->SystemID, 16);\n\tif (version) *version = pssh->version;\n\tif (KID_count) *KID_count = pssh->KID_count;\n\tif (KIDs) *KIDs = (const bin128 *) pssh->KIDs;\n\tif (private_data_size) *private_data_size = pssh->private_data_size;\n\tif (private_data) *private_data = pssh->private_data;\n\treturn GF_OK;\n}\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *senc, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n#else\nGF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *trak, void *traf, GF_SampleEncryptionBox *senc, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n#endif\n{\n\tGF_SampleGroupBox *sample_group;\n\tu32 j, group_desc_index;\n\tGF_SampleGroupDescriptionBox *sgdesc;\n\tu32 i, count;\n\tu32 descIndex, chunkNum;\n\tu64 offset;\n\tu32 first_sample_in_entry, last_sample_in_entry;\n\tGF_CENCSampleEncryptionGroupEntry *entry;\n\n\tif (IsEncrypted) *IsEncrypted = GF_FALSE;\n\tif (crypt_byte_block) *crypt_byte_block = 0;\n\tif (skip_byte_block) *skip_byte_block = 0;\n\tif (key_info) *key_info = NULL;\n\tif (key_info_size) *key_info_size = 0;\n\t\n\tif (!trak) return GF_BAD_PARAM;\n\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (traf)\n\t\treturn GF_NOT_SUPPORTED;\n#else\n\tsample_number -= trak->sample_count_at_seg_start;\n#endif\n\n\tif (trak->Media->information->sampleTable->SampleSize && trak->Media->information->sampleTable->SampleSize->sampleCount>=sample_number) {\n\t\tstbl_GetSampleInfos(trak->Media->information->sampleTable, sample_number, &offset, &chunkNum, &descIndex, NULL);\n\t} else {\n\t\t//this is dump mode of fragments, we haven't merged tables yet - use current stsd idx indicated in trak\n\t\tdescIndex = trak->current_traf_stsd_idx;\n\t\tif (!descIndex) descIndex = 1;\n\t}\n\n\tgf_isom_cenc_get_default_info_internal(trak, descIndex, NULL, IsEncrypted, crypt_byte_block, skip_byte_block, key_info, key_info_size);\n\n\tsample_group = NULL;\n\tgroup_desc_index = 0;\n\tif (trak->Media->information->sampleTable->sampleGroups) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroups);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsample_group = (GF_SampleGroupBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);\n\t\t\tif (sample_group->grouping_type ==  GF_ISOM_SAMPLE_GROUP_SEIG)\n\t\t\t\tbreak;\n\t\t\tsample_group = NULL;\n\t\t}\n\t\tif (sample_group) {\n\t\t\tfirst_sample_in_entry = 1;\n\t\t\tfor (j=0; j<sample_group->entry_count; j++) {\n\t\t\t\tlast_sample_in_entry = first_sample_in_entry + sample_group->sample_entries[j].sample_count - 1;\n\t\t\t\tif ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {\n\t\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*we found our sample*/\n\t\t\t\tgroup_desc_index = sample_group->sample_entries[j].group_description_index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!group_desc_index && traf && traf->sampleGroups) {\n\t\tcount = gf_list_count(traf->sampleGroups);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tgroup_desc_index = 0;\n\t\t\tsample_group = (GF_SampleGroupBox*)gf_list_get(traf->sampleGroups, i);\n\t\t\tif (sample_group->grouping_type ==  GF_ISOM_SAMPLE_GROUP_SEIG)\n\t\t\t\tbreak;\n\t\t\tsample_group = NULL;\n\t\t}\n\t\tif (sample_group) {\n\t\t\tfirst_sample_in_entry = 1;\n\t\t\tfor (j=0; j<sample_group->entry_count; j++) {\n\t\t\t\tlast_sample_in_entry = first_sample_in_entry + sample_group->sample_entries[j].sample_count - 1;\n\t\t\t\tif ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {\n\t\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*we found our sample*/\n\t\t\t\tgroup_desc_index = sample_group->sample_entries[j].group_description_index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\t/*no sampleGroup info associated*/\n\tif (!group_desc_index) goto exit;\n\n\tsgdesc = NULL;\n\n\tif (group_desc_index<=0x10000) {\n\t\tfor (j=0; j<gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription); j++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, j);\n\t\t\tif (sgdesc->grouping_type==sample_group->grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\telse if (traf) {\n\t\tgroup_desc_index -= 0x10000;\n\t\tfor (j=0; j<gf_list_count(traf->sampleGroupsDescription); j++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(traf->sampleGroupsDescription, j);\n\t\t\tif (sgdesc->grouping_type==sample_group->grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#endif\n\t/*no sampleGroup description found for this group (invalid file)*/\n\tif (!sgdesc) return GF_ISOM_INVALID_FILE;\n\n\tentry = (GF_CENCSampleEncryptionGroupEntry *) gf_list_get(sgdesc->group_descriptions, group_desc_index - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\n\tif (IsEncrypted) *IsEncrypted = entry->IsProtected;\n\tif (crypt_byte_block) *crypt_byte_block = entry->crypt_byte_block;\n\tif (skip_byte_block) *skip_byte_block = entry->skip_byte_block;\n\n\tif (key_info) *key_info = entry->key_info;\n\tif (key_info_size) *key_info_size = entry->key_info_size;\n\nexit:\n\t//in PIFF we may have default values if no TENC is present: 8 bytes for IV size\n\tif (( (senc && senc->piff_type==1) || (trak->moov && trak->moov->mov->is_smooth) ) && key_info && ! (*key_info) ) {\n\t\tif (!senc) {\n\t\t\tif (IsEncrypted) *IsEncrypted = GF_TRUE;\n\t\t\tif (key_info_size) *key_info_size = 8;\n\t\t} else {\n\t\t\tif (!senc->piff_type) {\n\t\t\t\tsenc->piff_type = 2;\n\t\t\t\tsenc->IV_size = 8;\n\t\t\t}\n\t\t\tassert(senc->IV_size);\n\t\t\tif (IsEncrypted) *IsEncrypted = GF_TRUE;\n\t\t\tif (key_info_size) *key_info_size = senc->IV_size;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_cenc_info(GF_ISOFile *movie, u32 track, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tGF_SampleEncryptionBox *senc = trak->sample_encryption;\n\n\treturn gf_isom_get_sample_cenc_info_internal(trak, NULL, senc, sample_number, IsEncrypted, crypt_byte_block, skip_byte_block, key_info, key_info_size);\n}\n\n\nGF_EXPORT\nBool gf_isom_get_last_producer_time_box(GF_ISOFile *file, GF_ISOTrackID *refTrackID, u64 *ntp, u64 *timestamp, Bool reset_info)\n{\n\tif (!file) return GF_FALSE;\n\tif (refTrackID) *refTrackID = 0;\n\tif (ntp) *ntp = 0;\n\tif (timestamp) *timestamp = 0;\n\n\tif (file->last_producer_ref_time) {\n\t\tif (refTrackID) *refTrackID = file->last_producer_ref_time->refTrackID;\n\t\tif (ntp) *ntp = file->last_producer_ref_time->ntp;\n\t\tif (timestamp) *timestamp = file->last_producer_ref_time->timestamp;\n\n\t\tif (reset_info) {\n\t\t\tfile->last_producer_ref_time = NULL;\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu64 gf_isom_get_current_tfdt(GF_ISOFile *the_file, u32 trackNumber)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn 0;\n#else\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->dts_at_seg_start;\n#endif\n}\n\nGF_EXPORT\nu64 gf_isom_get_smooth_next_tfdt(GF_ISOFile *the_file, u32 trackNumber)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn 0;\n#else\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->dts_at_next_seg_start;\n#endif\n}\n\nGF_EXPORT\nBool gf_isom_is_smooth_streaming_moov(GF_ISOFile *the_file)\n{\n\treturn the_file ? the_file->is_smooth : GF_FALSE;\n}\n\n\nvoid gf_isom_parse_trif_info(const u8 *data, u32 size, u32 *id, u32 *independent, Bool *full_picture, u32 *x, u32 *y, u32 *w, u32 *h)\n{\n\tGF_BitStream *bs;\n\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\t*id = gf_bs_read_u16(bs);\n\tif (! gf_bs_read_int(bs, 1)) {\n\t\t*independent=0;\n\t\t*full_picture=0;\n\t\t*x = *y = *w = *h = 0;\n\t} else {\n\t\t*independent = gf_bs_read_int(bs, 2);\n\t\t*full_picture = (Bool)gf_bs_read_int(bs, 1);\n\t\t/*filter_disabled*/ gf_bs_read_int(bs, 1);\n\t\t/*has_dependency_list*/ gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 2);\n\t\t*x = *full_picture ? 0 : gf_bs_read_u16(bs);\n\t\t*y = *full_picture ? 0 : gf_bs_read_u16(bs);\n\t\t*w = gf_bs_read_u16(bs);\n\t\t*h = gf_bs_read_u16(bs);\n\t}\n\tgf_bs_del(bs);\n}\n\nGF_EXPORT\nBool gf_isom_get_tile_info(GF_ISOFile *file, u32 trackNumber, u32 sample_description_index, u32 *default_sample_group_index, u32 *id, u32 *independent, Bool *full_picture, u32 *x, u32 *y, u32 *w, u32 *h)\n{\n\tconst u8 *data;\n\tu32 size;\n\n\tif (!gf_isom_get_sample_group_info(file, trackNumber, sample_description_index, GF_ISOM_SAMPLE_GROUP_TRIF, default_sample_group_index, &data, &size))\n\t\treturn GF_FALSE;\n\tgf_isom_parse_trif_info(data, size, id, independent, full_picture, x, y, w, h);\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_isom_get_oinf_info(GF_ISOFile *file, u32 trackNumber, GF_OperatingPointsInformation **ptr)\n{\n\tu32 oref_track, def_index=0;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(file, trackNumber);\n\n\tif (!ptr) return GF_FALSE;\n\n\toref_track=0;\n\tgf_isom_get_reference(file, trackNumber, GF_ISOM_REF_OREF, 1, &oref_track);\n\tif (oref_track) {\n\t\ttrak = gf_isom_get_track_from_file(file, oref_track);\n\t\tif (!trak) return GF_FALSE;\n\t}\n\n\t*ptr = (GF_OperatingPointsInformation *) gf_isom_get_sample_group_info_entry(file, trak, GF_ISOM_SAMPLE_GROUP_OINF, 1, &def_index, NULL);\n\n\treturn *ptr ? GF_TRUE : GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_byte_offset(GF_ISOFile *file, s64 byte_offset)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->read_byte_offset = byte_offset;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_isom_get_nalu_length_field(GF_ISOFile *file, u32 track, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_MPEGVisualSampleEntryBox *ve;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd || !StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (!entry || ! gf_isom_is_nalu_based_entry(trak->Media, entry)) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\n\tve = (GF_MPEGVisualSampleEntryBox*)entry;\n\tif (ve->avc_config) return ve->avc_config->config->nal_unit_size;\n\tif (ve->svc_config) return ve->svc_config->config->nal_unit_size;\n\tif (ve->hevc_config) return ve->hevc_config->config->nal_unit_size;\n\tif (ve->lhvc_config) return ve->lhvc_config->config->nal_unit_size;\n\treturn 0;\n}\n\nGF_EXPORT\nBool gf_isom_is_video_handler_type(u32 mtype)\n{\n\tswitch (mtype) {\n\tcase GF_ISOM_MEDIA_VISUAL:\n\tcase GF_ISOM_MEDIA_AUXV:\n\tcase GF_ISOM_MEDIA_PICT:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_bitrate(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescIndex, u32 *average_bitrate, u32 *max_bitrate, u32 *decode_buffer_size)\n{\n\tGF_BitRateBox *a;\n\tu32 i, count, mrate, arate, dbsize, type;\n\tGF_SampleEntryBox *ent;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\tGF_TrackBox *trak;\n\tGF_ESDBox *esd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tmrate = arate = dbsize = 0;\n\tcount = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\tfor (i=0; i<count; i++) {\n\t\tif ((sampleDescIndex>0) && (i+1 != sampleDescIndex)) continue;\n\n\t\tent = (GF_SampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tif (!ent) return GF_BAD_PARAM;\n\t\ta = gf_isom_sample_entry_get_bitrate(ent, GF_FALSE);\n\t\tif (a) {\n\t\t\tif (mrate<a->maxBitrate) mrate = a->maxBitrate;\n\t\t\tif (arate<a->avgBitrate) arate = a->avgBitrate;\n\t\t\tif (dbsize<a->bufferSizeDB) dbsize = a->bufferSizeDB;\n\t\t\tcontinue;\n\t\t}\n\t\ttype = ent->type;\n\t\tswitch (type) {\n\t\tcase GF_ISOM_BOX_TYPE_ENCV:\n\t\tcase GF_ISOM_BOX_TYPE_ENCA:\n\t\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\t\tif (sinf && sinf->original_format) type = sinf->original_format->data_format;\n\t\t\tbreak;\n\t\t}\n\t\tesd = NULL;\n\t\tswitch (type) {\n\t\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\t\tesd = ((GF_MPEGVisualSampleEntryBox *)ent)->esd;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\t\tesd = ((GF_MPEGAudioSampleEntryBox *)ent)->esd;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\t\tesd = ((GF_MPEGSampleEntryBox *)ent)->esd;\n\t\t\tbreak;\n\t\t}\n\t\tif (esd && esd->desc && esd->desc->decoderConfig) {\n\t\t\tif (mrate<esd->desc->decoderConfig->maxBitrate) mrate = esd->desc->decoderConfig->maxBitrate;\n\t\t\tif (arate<esd->desc->decoderConfig->avgBitrate) arate = esd->desc->decoderConfig->avgBitrate;\n\t\t\tif (dbsize<esd->desc->decoderConfig->bufferSizeDB) dbsize = esd->desc->decoderConfig->bufferSizeDB;\n\t\t}\n\t}\n\tif (average_bitrate) *average_bitrate = arate;\n\tif (max_bitrate) *max_bitrate = mrate;\n\tif (decode_buffer_size) *decode_buffer_size = dbsize;\n\treturn GF_OK;\n}\n\nvoid gf_isom_enable_traf_map_templates(GF_ISOFile *movie)\n{\n\tif (movie)\n\t\tmovie->signal_frag_bounds=GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_isom_sample_is_fragment_start(GF_ISOFile *movie, u32 trackNumber, u32 sampleNum, GF_ISOFragmentBoundaryInfo *frag_info)\n{\n\tu32 i;\n\tGF_TrackBox *trak;\n\tGF_TrafToSampleMap *tmap;\n\n\tif (frag_info) memset(frag_info, 0, sizeof(GF_ISOFragmentBoundaryInfo));\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->traf_map) return GF_FALSE;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNum<=trak->sample_count_at_seg_start)\n\t\treturn GF_FALSE;\n\tsampleNum -= trak->sample_count_at_seg_start;\n#endif\n\n\ttmap = trak->Media->information->sampleTable->traf_map;\n\tif (!tmap) return GF_FALSE;\n\tfor (i=0; i<tmap->nb_entries; i++) {\n\t\tGF_TrafMapEntry *finfo = &tmap->frag_starts[i];\n\t\tif (finfo->sample_num == sampleNum) {\n\t\t\tif (frag_info) {\n\t\t\t\tfrag_info->frag_start = finfo->moof_start;\n\t\t\t\tfrag_info->mdat_end = finfo->mdat_end;\n\t\t\t\tfrag_info->moof_template = finfo->moof_template;\n\t\t\t\tfrag_info->moof_template_size = finfo->moof_template_size;\n\t\t\t\tfrag_info->seg_start_plus_one = finfo->seg_start_plus_one;\n\t\t\t\tfrag_info->sidx_start = finfo->sidx_start;\n\t\t\t\tfrag_info->sidx_end = finfo->sidx_end;\n\t\t\t}\n\t\t\treturn GF_TRUE;\n\t\t}\n\n\t\tif (tmap->frag_starts[i].sample_num > sampleNum) return GF_FALSE;\n\t}\n\treturn GF_FALSE;\n}\n\n\n\n\nGF_EXPORT\nGF_Err gf_isom_get_jp2_config(GF_ISOFile *movie, u32 trackNumber, u32 sampleDesc, u8 **out_dsi, u32 *out_size)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_BitStream *bs;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleDescription) return GF_ISOM_INVALID_FILE;\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDesc-1);\n\tif (!entry || !entry->jp2h) return GF_BAD_PARAM;\n\tif (!entry->jp2h->ihdr) return GF_ISOM_INVALID_FILE;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_box_array_write((GF_Box*)entry->jp2h, entry->jp2h->child_boxes, bs);\n\tgf_bs_get_content(bs, out_dsi, out_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\n\nBool gf_isom_is_identical_sgpd(void *ptr1, void *ptr2, u32 grouping_type)\n{\n\tBool res = GF_FALSE;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tGF_BitStream *bs1, *bs2;\n\tu8 *buf1, *buf2;\n\tu32 len1, len2;\n\n\tif (!ptr1 || !ptr2)\n\t\treturn GF_FALSE;\n\n\tbs1 = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (grouping_type) {\n\t\tsgpd_write_entry(grouping_type, ptr1, bs1);\n\t} else {\n\t\tgf_isom_box_size((GF_Box *)ptr1);\n\t\tgf_isom_box_write((GF_Box *)ptr1, bs1);\n\t}\n\tgf_bs_get_content(bs1, &buf1, &len1);\n\tgf_bs_del(bs1);\n\n\tbs2 = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (grouping_type) {\n\t\tsgpd_write_entry(grouping_type, ptr2, bs2);\n\t} else {\n\t\tgf_isom_box_write((GF_Box *)ptr2, bs2);\n\t}\n\tgf_bs_get_content(bs2, &buf2, &len2);\n\tgf_bs_del(bs2);\n\n\n\tif ((len1==len2) && !memcmp(buf1, buf2, len1))\n\t\tres = GF_TRUE;\n\n\tgf_free(buf1);\n\tgf_free(buf2);\n#endif\n\treturn res;\n}\n\nGF_EXPORT\nu64 gf_isom_get_track_magic(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->magic;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_file_offset_for_time(GF_ISOFile *movie, Double start_time, u64 *max_offset)\n{\n\tu32 i;\n\tu64 start_ts, cur_start_time;\n\tu64 offset=0;\n\tif (!movie || !movie->moov)\n\t\treturn GF_BAD_PARAM;\n\n\tif (!movie->main_sidx) return GF_NOT_SUPPORTED;\n\tstart_ts = (u64) (start_time * movie->main_sidx->timescale);\n\tcur_start_time = 0;\n\toffset = movie->main_sidx->first_offset + movie->main_sidx_end_pos;\n\n\tfor (i=0; i<movie->main_sidx->nb_refs; i++) {\n\t\tif (cur_start_time >= start_ts) {\n\t\t\t*max_offset = offset;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tcur_start_time += movie->main_sidx->refs[i].subsegment_duration;\n\t\toffset += movie->main_sidx->refs[i].reference_size;\n\t}\n\n\treturn GF_EOS;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sidx_duration(GF_ISOFile *movie, u64 *sidx_dur, u32 *sidx_timescale)\n{\n\tu64 dur=0;\n\tu32 i;\n\tif (!movie || !movie->moov || !sidx_timescale || !sidx_dur)\n\t\treturn GF_BAD_PARAM;\n\n\tif (!movie->main_sidx) return GF_NOT_SUPPORTED;\n\t*sidx_timescale = movie->main_sidx->timescale;\n\n\tfor (i=0; i<movie->main_sidx->nb_refs; i++) {\n\t\tdur += movie->main_sidx->refs[i].subsegment_duration;\n\t}\n\t*sidx_dur = dur;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nconst u8 *gf_isom_get_mpegh_compatible_profiles(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescIndex, u32 *nb_compat_profiles)\n{\n\tGF_SampleEntryBox *ent;\n\tGF_MHACompatibleProfilesBox *mhap;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !nb_compat_profiles) return NULL;\n\t*nb_compat_profiles = 0;\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescIndex-1);\n\tif (!ent) return NULL;\n\tmhap = (GF_MHACompatibleProfilesBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_MHAP);\n\tif (!mhap) return NULL;\n\t*nb_compat_profiles = mhap->num_profiles;\n\treturn mhap->compat_profiles;\n}\n\nconst void *gf_isom_get_tfrf(GF_ISOFile *movie, u32 trackNumber)\n{\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\treturn NULL;\n#else\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return NULL;\n\n\treturn trak->tfrf;\n#endif\n}\n\nGF_Err gf_isom_get_y3d_info(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescriptionIndex, GF_ISOM_Y3D_Info *info)\n{\n\tGF_SampleEntryBox *ent;\n\tGF_TrackBox *trak;\n\tBool found = GF_FALSE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !info) return GF_BAD_PARAM;\n\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\n\tmemset(info, 0, sizeof(GF_ISOM_Y3D_Info));\n\n\tGF_Stereo3DBox *st3d = (GF_Stereo3DBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (st3d) {\n\t\tfound = GF_TRUE;\n\t\tinfo->stereo_type = st3d->stereo_type;\n\t}\n\n\tGF_Box *sv3d = gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (!sv3d) {\n\t\treturn found ? GF_OK : GF_NOT_FOUND;\n\t}\n\tGF_SphericalVideoInfoBox *svhd = (GF_SphericalVideoInfoBox *) gf_isom_box_find_child(sv3d->child_boxes, GF_ISOM_BOX_TYPE_SVHD);\n\tif (svhd && strlen(svhd->string)) info->meta_data = svhd->string;\n\n\tGF_Box *proj = gf_isom_box_find_child(sv3d->child_boxes, GF_ISOM_BOX_TYPE_PROJ);\n\tif (!proj)\n\t\treturn found ? GF_OK : GF_NOT_FOUND;\n\n\tGF_ProjectionHeaderBox *projh = (GF_ProjectionHeaderBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_PRHD);\n\tif (projh) {\n\t\tinfo->yaw = projh->yaw;\n\t\tinfo->pitch = projh->pitch;\n\t\tinfo->roll = projh->roll;\n\t\tinfo->pose_present = GF_TRUE;\n\t}\n\n\tGF_ProjectionTypeBox *projt = (GF_ProjectionTypeBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_CBMP);\n\tif (projt) {\n\t\tinfo->layout = projt->layout;\n\t\tinfo->padding = projt->padding;\n\t\tinfo->projection_type = 1;\n\t} else {\n\t\tprojt = (GF_ProjectionTypeBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_EQUI);\n\t\tif (projt) {\n\t\t\tinfo->top = projt->bounds_top;\n\t\t\tinfo->bottom = projt->bounds_bottom;\n\t\t\tinfo->left = projt->bounds_left;\n\t\t\tinfo->right = projt->bounds_right;\n\t\t\tinfo->projection_type = 2;\n\t\t} else {\n\t\t\tprojt = (GF_ProjectionTypeBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_EQUI);\n\t\t\tif (projt) {\n\t\t\t\tinfo->projection_type = 3;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_chunk_count(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_ChunkOffsetBox *stco;\n\tGF_TrackBox *trak;\n\tif (!movie || !movie->moov || !trackNumber) return 0;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->ChunkOffset ) return 0;\n\n\tstco = (GF_ChunkOffsetBox *) trak->Media->information->sampleTable->ChunkOffset;\n\tif (stco->type == GF_ISOM_BOX_TYPE_STCO)\n\t\treturn stco->nb_entries;\n\tif (stco->type == GF_ISOM_BOX_TYPE_CO64)\n\t\treturn ((GF_ChunkLargeOffsetBox *) stco)->nb_entries;\n\treturn 0;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_chunk_info(GF_ISOFile *movie, u32 trackNumber, u32 chunk_num, u64 *chunk_offset, u32 *first_sample_num, u32 *sample_per_chunk, u32 *sample_desc_idx)\n{\n\tGF_ChunkOffsetBox *stco = NULL;\n\tGF_ChunkLargeOffsetBox *co64 = NULL;\n\tGF_SampleToChunkBox *stsc = NULL;\n\tGF_TrackBox *trak;\n\tu32 i, nb_entries, nb_samples, sample_desc_index;\n\tif (!movie || !movie->moov || !trackNumber || !chunk_num) return GF_BAD_PARAM;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->ChunkOffset ) return GF_BAD_PARAM;\n\n\tstsc = (GF_SampleToChunkBox *) trak->Media->information->sampleTable->SampleToChunk;\n\tstco = (GF_ChunkOffsetBox *) trak->Media->information->sampleTable->ChunkOffset;\n\tif (stco->type == GF_ISOM_BOX_TYPE_CO64) {\n\t\tstco = NULL;\n\t\tco64 = (GF_ChunkLargeOffsetBox *) trak->Media->information->sampleTable->ChunkOffset;\n\t\tnb_entries = co64->nb_entries;\n\t} else {\n\t\tnb_entries = stco->nb_entries;\n\t}\n\tif (chunk_num>nb_entries) return GF_BAD_PARAM;\n\n\tsample_desc_index = 0;\n\tnb_samples = 1;\n\tfor (i=0; i<stsc->nb_entries; i++) {\n\t\tu32 nb_chunks_before;\n\n\t\tif (stsc->entries[i].firstChunk == chunk_num) {\n\t\t\tsample_desc_index = stsc->entries[i].sampleDescriptionIndex;\n\t\t\tif (sample_per_chunk)\n\t\t\t\t*sample_per_chunk = stsc->entries[i].samplesPerChunk;\n\t\t\tbreak;\n\t\t}\n\t\tassert(stsc->entries[i].firstChunk<chunk_num);\n\n\t\tif ((i+1 == stsc->nb_entries)\n\t\t\t|| (stsc->entries[i+1].firstChunk>chunk_num)\n\t\t) {\n\t\t\tnb_chunks_before = chunk_num - stsc->entries[i].firstChunk;\n\t\t\tnb_samples += stsc->entries[i].samplesPerChunk * nb_chunks_before;\n\t\t\tsample_desc_index = stsc->entries[i].sampleDescriptionIndex;\n\t\t\tif (sample_per_chunk)\n\t\t\t\t*sample_per_chunk = stsc->entries[i].samplesPerChunk;\n\t\t\tbreak;\n\t\t}\n\t\tassert(stsc->entries[i+1].firstChunk > stsc->entries[i].firstChunk);\n\n\t\tnb_chunks_before = stsc->entries[i+1].firstChunk - stsc->entries[i].firstChunk;\n\t\tnb_samples += stsc->entries[i].samplesPerChunk * nb_chunks_before;\n\t}\n\tif (first_sample_num) *first_sample_num = nb_samples;\n\tif (sample_desc_idx) *sample_desc_idx = sample_desc_index;\n\tif (chunk_offset) {\n\t\tif (stco)\n\t\t\t*chunk_offset = stco->offsets[chunk_num-1];\n\t\telse\n\t\t\t*chunk_offset = co64->offsets[chunk_num-1];\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "filenames": ["src/isomedia/isom_read.c"], "buggy_code_start_loc": [697], "buggy_code_end_loc": [698], "fixing_code_start_loc": [697], "fixing_code_end_loc": [708], "type": "CWE-401", "message": "Memory leak in the gf_isom_get_root_od function in MP4Box in GPAC 1.0.1 allows attackers to read memory via a crafted file.", "other": {"cve": {"id": "CVE-2021-33365", "sourceIdentifier": "cve@mitre.org", "published": "2021-09-13T20:15:08.627", "lastModified": "2023-05-27T04:15:15.717", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Memory leak in the gf_isom_get_root_od function in MP4Box in GPAC 1.0.1 allows attackers to read memory via a crafted file."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n gf_isom_get_root_od de MP4Box en GPAC versi\u00f3n 1.0.1, permite a atacantes leer memoria por medio de un archivo dise\u00f1ado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "82DD2D40-0A05-48FD-940D-32B4D8B51AB3"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/984787de3d414a5f7d43d0b4584d9469dff2a5a5", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1784", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5411", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/984787de3d414a5f7d43d0b4584d9469dff2a5a5"}}