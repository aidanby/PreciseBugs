{"buggy_code": ["/*\n * Copyright (c) 2012 David Vossel <davidvossel@gmail.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n\n#include <crm_internal.h>\n\n#include <glib.h>\n#include <unistd.h>\n\n#include <crm/crm.h>\n#include <crm/msg_xml.h>\n#include <crm/crm.h>\n#include <crm/msg_xml.h>\n#include <crm/common/mainloop.h>\n\n#include <lrmd_private.h>\n\n#include <netdb.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netinet/ip.h>\n#include <arpa/inet.h>\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n#  define LRMD_REMOTE_AUTH_TIMEOUT 10000\ngnutls_psk_server_credentials_t psk_cred_s;\ngnutls_dh_params_t dh_params;\nstatic int ssock = -1;\nextern int lrmd_call_id;\n\nstatic void\ndebug_log(int level, const char *str)\n{\n    fputs(str, stderr);\n}\n\nstatic int\nlrmd_remote_client_msg(gpointer data)\n{\n    int id = 0;\n    int rc = 0;\n    int disconnected = 0;\n    xmlNode *request = NULL;\n    crm_client_t *client = data;\n\n    if (client->remote->tls_handshake_complete == FALSE) {\n        int rc = 0;\n\n        /* Muliple calls to handshake will be required, this callback\n         * will be invoked once the client sends more handshake data. */\n        do {\n            rc = gnutls_handshake(*client->remote->tls_session);\n\n            if (rc < 0 && rc != GNUTLS_E_AGAIN) {\n                crm_err(\"Remote lrmd tls handshake failed\");\n                return -1;\n            }\n        } while (rc == GNUTLS_E_INTERRUPTED);\n\n        if (rc == 0) {\n            crm_debug(\"Remote lrmd tls handshake completed\");\n            client->remote->tls_handshake_complete = TRUE;\n            if (client->remote->auth_timeout) {\n                g_source_remove(client->remote->auth_timeout);\n            }\n            client->remote->auth_timeout = 0;\n        }\n        return 0;\n    }\n\n    rc = crm_remote_ready(client->remote, 0);\n    if (rc == 0) {\n        /* no msg to read */\n        return 0;\n    } else if (rc < 0) {\n        crm_info(\"Client disconnected during remote client read\");\n        return -1;\n    }\n\n    crm_remote_recv(client->remote, -1, &disconnected);\n\n    request = crm_remote_parse_buffer(client->remote);\n    while (request) {\n        crm_element_value_int(request, F_LRMD_REMOTE_MSG_ID, &id);\n        crm_trace(\"processing request from remote client with remote msg id %d\", id);\n        if (!client->name) {\n            const char *value = crm_element_value(request, F_LRMD_CLIENTNAME);\n\n            if (value) {\n                client->name = strdup(value);\n            }\n        }\n\n        lrmd_call_id++;\n        if (lrmd_call_id < 1) {\n            lrmd_call_id = 1;\n        }\n\n        crm_xml_add(request, F_LRMD_CLIENTID, client->id);\n        crm_xml_add(request, F_LRMD_CLIENTNAME, client->name);\n        crm_xml_add_int(request, F_LRMD_CALLID, lrmd_call_id);\n\n        process_lrmd_message(client, id, request);\n        free_xml(request);\n\n        /* process all the messages in the current buffer */\n        request = crm_remote_parse_buffer(client->remote);\n    }\n\n    if (disconnected) {\n        crm_info(\"Client disconnect detected in tls msg dispatcher.\");\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic void\nlrmd_remote_client_destroy(gpointer user_data)\n{\n    crm_client_t *client = user_data;\n\n    if (client == NULL) {\n        return;\n    }\n\n    ipc_proxy_remove_provider(client);\n\n    /* if this is the last remote connection, stop recurring\n     * operations */\n    if (crm_hash_table_size(client_connections) == 1) {\n        client_disconnect_cleanup(NULL);\n    }\n\n    crm_notice(\"LRMD client disconnecting remote client - name: %s id: %s\",\n               client->name ? client->name : \"<unknown>\", client->id);\n\n    if (client->remote->tls_session) {\n        void *sock_ptr;\n        int csock;\n\n        sock_ptr = gnutls_transport_get_ptr(*client->remote->tls_session);\n        csock = GPOINTER_TO_INT(sock_ptr);\n\n        gnutls_bye(*client->remote->tls_session, GNUTLS_SHUT_RDWR);\n        gnutls_deinit(*client->remote->tls_session);\n        gnutls_free(client->remote->tls_session);\n        close(csock);\n    }\n\n    lrmd_client_destroy(client);\n    return;\n}\n\nstatic gboolean\nlrmd_auth_timeout_cb(gpointer data)\n{\n    crm_client_t *client = data;\n\n    client->remote->auth_timeout = 0;\n\n    if (client->remote->tls_handshake_complete == TRUE) {\n        return FALSE;\n    }\n\n    mainloop_del_fd(client->remote->source);\n    client->remote->source = NULL;\n    crm_err(\"Remote client authentication timed out\");\n\n    return FALSE;\n}\n\n/* Convert a struct sockaddr address to a string, IPv4 and IPv6: */\n\nstatic char *\nget_ip_str(const struct sockaddr * sa, char * s, size_t maxlen)\n{\n    switch(sa->sa_family) {\n        case AF_INET:\n            inet_ntop(AF_INET, &(((struct sockaddr_in *)sa)->sin_addr),\n                      s, maxlen);\n            break;\n\n        case AF_INET6:\n            inet_ntop(AF_INET6, &(((struct sockaddr_in6 *)sa)->sin6_addr),\n                      s, maxlen);\n            break;\n\n        default:\n            strncpy(s, \"Unknown AF\", maxlen);\n            return NULL;\n    }\n\n    return s;\n}\n\nstatic int\nlrmd_remote_listen(gpointer data)\n{\n    int csock = 0;\n    int flag = 0;\n    unsigned laddr = 0;\n    struct sockaddr addr;\n    gnutls_session_t *session = NULL;\n    crm_client_t *new_client = NULL;\n\n    static struct mainloop_fd_callbacks lrmd_remote_fd_cb = {\n        .dispatch = lrmd_remote_client_msg,\n        .destroy = lrmd_remote_client_destroy,\n    };\n\n    laddr = sizeof(addr);\n    memset(&addr, 0, sizeof(addr));\n    getsockname(ssock, &addr, &laddr);\n\n    /* accept the connection */\n\n    if (addr.sa_family == AF_INET6) {\n        struct sockaddr_in6 sa;\n        char addr_str[INET6_ADDRSTRLEN];\n\n        laddr = sizeof(sa);\n        memset(&sa, 0, sizeof(sa));\n        csock = accept(ssock, &sa, &laddr);\n        get_ip_str((struct sockaddr *)&sa, addr_str, INET6_ADDRSTRLEN);\n        crm_info(\"New remote connection from %s\", addr_str);\n\n    } else {\n        struct sockaddr_in sa;\n        char addr_str[INET_ADDRSTRLEN];\n\n        laddr = sizeof(sa);\n        memset(&sa, 0, sizeof(sa));\n        csock = accept(ssock, &sa, &laddr);\n        get_ip_str((struct sockaddr *)&sa, addr_str, INET_ADDRSTRLEN);\n        crm_info(\"New remote connection from %s\", addr_str);\n    }\n\n    if (csock == -1) {\n        crm_err(\"accept socket failed\");\n        return TRUE;\n    }\n\n    if ((flag = fcntl(csock, F_GETFL)) >= 0) {\n        if (fcntl(csock, F_SETFL, flag | O_NONBLOCK) < 0) {\n            crm_err(\"fcntl() write failed\");\n            close(csock);\n            return TRUE;\n        }\n    } else {\n        crm_err(\"fcntl() read failed\");\n        close(csock);\n        return TRUE;\n    }\n\n    session = create_psk_tls_session(csock, GNUTLS_SERVER, psk_cred_s);\n    if (session == NULL) {\n        crm_err(\"TLS session creation failed\");\n        close(csock);\n        return TRUE;\n    }\n\n    new_client = calloc(1, sizeof(crm_client_t));\n    new_client->remote = calloc(1, sizeof(crm_remote_t));\n    new_client->kind = CRM_CLIENT_TLS;\n    new_client->remote->tls_session = session;\n    new_client->id = crm_generate_uuid();\n    new_client->remote->auth_timeout =\n        g_timeout_add(LRMD_REMOTE_AUTH_TIMEOUT, lrmd_auth_timeout_cb, new_client);\n    crm_notice(\"LRMD client connection established. %p id: %s\", new_client, new_client->id);\n\n    new_client->remote->source =\n        mainloop_add_fd(\"lrmd-remote-client\", G_PRIORITY_DEFAULT, csock, new_client,\n                        &lrmd_remote_fd_cb);\n    g_hash_table_insert(client_connections, new_client->id, new_client);\n\n    /* Alert other clients of the new connection */\n    notify_of_new_client(new_client);\n    return TRUE;\n}\n\nstatic void\nlrmd_remote_connection_destroy(gpointer user_data)\n{\n    crm_notice(\"Remote tls server disconnected\");\n    return;\n}\n\nstatic int\nlrmd_tls_server_key_cb(gnutls_session_t session, const char *username, gnutls_datum_t * key)\n{\n    return lrmd_tls_set_key(key);\n}\n\nstatic int\nbind_and_listen(struct addrinfo *addr)\n{\n    int optval;\n    int fd;\n    int rc;\n    char buffer[256] = { 0, };\n\n    if (addr->ai_family == AF_INET6) {\n        struct sockaddr_in6 *addr_in = (struct sockaddr_in6 *)(void*)addr->ai_addr;\n        inet_ntop(addr->ai_family, &addr_in->sin6_addr, buffer, DIMOF(buffer));\n\n    } else {\n        struct sockaddr_in *addr_in = (struct sockaddr_in *)(void*)addr->ai_addr;\n        inet_ntop(addr->ai_family, &addr_in->sin_addr, buffer, DIMOF(buffer));\n    }\n\n    crm_trace(\"Attempting to bind on address %s\", buffer);\n\n    fd = socket(addr->ai_family, addr->ai_socktype, addr->ai_protocol);\n    if (fd < 0) {\n        return -1;\n    }\n\n    /* reuse address */\n    optval = 1;\n    rc = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\n    if (rc < 0) {\n        crm_perror(LOG_INFO, \"Couldn't allow the reuse of local addresses by our remote listener, bind address %s\", buffer);\n        close(fd);\n        return -1;\n    }\n\n    if (addr->ai_family == AF_INET6) {\n        optval = 0;\n        rc = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &optval, sizeof(optval));\n        if (rc < 0) {\n            crm_perror(LOG_INFO, \"Couldn't disable IPV6 only on address %s\", buffer);\n            close(fd);\n            return -1;\n        }\n    }\n\n    if (bind(fd, addr->ai_addr, addr->ai_addrlen) != 0) {\n        close(fd);\n        return -1;\n    }\n\n    if (listen(fd, 10) == -1) {\n        crm_err(\"Can not start listen on address %s\", buffer);\n        close(fd);\n        return -1;\n    }\n\n    crm_notice(\"Listening on address %s\", buffer);\n\n    return fd;\n}\n\nint\nlrmd_init_remote_tls_server(int port)\n{\n    int rc;\n    int filter;\n    struct addrinfo hints, *res = NULL, *iter;\n    char port_str[16];\n\n    static struct mainloop_fd_callbacks remote_listen_fd_callbacks = {\n        .dispatch = lrmd_remote_listen,\n        .destroy = lrmd_remote_connection_destroy,\n    };\n\n    crm_notice(\"Starting a tls listener on port %d.\", port);\n    crm_gnutls_global_init();\n    gnutls_global_set_log_function(debug_log);\n\n    gnutls_dh_params_init(&dh_params);\n    gnutls_dh_params_generate2(dh_params, 1024);\n    gnutls_psk_allocate_server_credentials(&psk_cred_s);\n    gnutls_psk_set_server_credentials_function(psk_cred_s, lrmd_tls_server_key_cb);\n    gnutls_psk_set_server_dh_params(psk_cred_s, dh_params);\n\n    memset(&hints, 0, sizeof(struct addrinfo));\n    hints.ai_flags = AI_PASSIVE; /* Only return socket addresses with wildcard INADDR_ANY or IN6ADDR_ANY_INIT */\n    hints.ai_family = AF_UNSPEC; /* Return IPv6 or IPv4 */\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = IPPROTO_TCP;\n\n    snprintf(port_str, sizeof(port_str), \"%d\", port);\n    rc = getaddrinfo(NULL, port_str, &hints, &res);\n    if (rc) {\n        crm_err(\"getaddrinfo: %s\", gai_strerror(rc));\n        return -1;\n    }\n\n    iter = res;\n    filter = AF_INET6;\n    /* Try IPv6 addresses first, then IPv4 */\n    while (iter) {\n        if (iter->ai_family == filter) {\n            ssock = bind_and_listen(iter);\n        }\n        if (ssock != -1) {\n            break;\n        }\n\n        iter = iter->ai_next;\n        if (iter == NULL && filter == AF_INET6) {\n            iter = res;\n            filter = AF_INET;\n        }\n    }\n\n    if (ssock < 0) {\n        crm_err(\"unable to bind to address\");\n        goto init_remote_cleanup;\n    }\n\n    mainloop_add_fd(\"lrmd-remote\", G_PRIORITY_DEFAULT, ssock, NULL, &remote_listen_fd_callbacks);\n\n    rc = ssock;\n  init_remote_cleanup:\n    if (rc < 0) {\n        close(ssock);\n        ssock = 0;\n    }\n    freeaddrinfo(res);\n    return rc;\n\n}\n\nvoid\nlrmd_tls_server_destroy(void)\n{\n    if (psk_cred_s) {\n        gnutls_psk_free_server_credentials(psk_cred_s);\n        psk_cred_s = 0;\n    }\n\n    if (ssock > 0) {\n        close(ssock);\n        ssock = 0;\n    }\n}\n#endif\n"], "fixing_code": ["/*\n * Copyright (c) 2012 David Vossel <davidvossel@gmail.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n\n#include <crm_internal.h>\n\n#include <glib.h>\n#include <unistd.h>\n\n#include <crm/crm.h>\n#include <crm/msg_xml.h>\n#include <crm/crm.h>\n#include <crm/msg_xml.h>\n#include <crm/common/mainloop.h>\n\n#include <lrmd_private.h>\n\n#include <netdb.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netinet/ip.h>\n#include <arpa/inet.h>\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n#  define LRMD_REMOTE_AUTH_TIMEOUT 10000\ngnutls_psk_server_credentials_t psk_cred_s;\ngnutls_dh_params_t dh_params;\nstatic int ssock = -1;\nextern int lrmd_call_id;\n\nstatic void\ndebug_log(int level, const char *str)\n{\n    fputs(str, stderr);\n}\n\nstatic int\nlrmd_remote_client_msg(gpointer data)\n{\n    int id = 0;\n    int rc = 0;\n    int disconnected = 0;\n    xmlNode *request = NULL;\n    crm_client_t *client = data;\n\n    if (client->remote->tls_handshake_complete == FALSE) {\n        int rc = 0;\n\n        /* Muliple calls to handshake will be required, this callback\n         * will be invoked once the client sends more handshake data. */\n        do {\n            rc = gnutls_handshake(*client->remote->tls_session);\n\n            if (rc < 0 && rc != GNUTLS_E_AGAIN) {\n                crm_err(\"Remote lrmd tls handshake failed\");\n                return -1;\n            }\n        } while (rc == GNUTLS_E_INTERRUPTED);\n\n        if (rc == 0) {\n            crm_debug(\"Remote lrmd tls handshake completed\");\n            client->remote->tls_handshake_complete = TRUE;\n            if (client->remote->auth_timeout) {\n                g_source_remove(client->remote->auth_timeout);\n            }\n            client->remote->auth_timeout = 0;\n\n            /* Alert other clients of the new connection */\n            notify_of_new_client(client);\n        }\n        return 0;\n    }\n\n    rc = crm_remote_ready(client->remote, 0);\n    if (rc == 0) {\n        /* no msg to read */\n        return 0;\n    } else if (rc < 0) {\n        crm_info(\"Client disconnected during remote client read\");\n        return -1;\n    }\n\n    crm_remote_recv(client->remote, -1, &disconnected);\n\n    request = crm_remote_parse_buffer(client->remote);\n    while (request) {\n        crm_element_value_int(request, F_LRMD_REMOTE_MSG_ID, &id);\n        crm_trace(\"processing request from remote client with remote msg id %d\", id);\n        if (!client->name) {\n            const char *value = crm_element_value(request, F_LRMD_CLIENTNAME);\n\n            if (value) {\n                client->name = strdup(value);\n            }\n        }\n\n        lrmd_call_id++;\n        if (lrmd_call_id < 1) {\n            lrmd_call_id = 1;\n        }\n\n        crm_xml_add(request, F_LRMD_CLIENTID, client->id);\n        crm_xml_add(request, F_LRMD_CLIENTNAME, client->name);\n        crm_xml_add_int(request, F_LRMD_CALLID, lrmd_call_id);\n\n        process_lrmd_message(client, id, request);\n        free_xml(request);\n\n        /* process all the messages in the current buffer */\n        request = crm_remote_parse_buffer(client->remote);\n    }\n\n    if (disconnected) {\n        crm_info(\"Client disconnect detected in tls msg dispatcher.\");\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic void\nlrmd_remote_client_destroy(gpointer user_data)\n{\n    crm_client_t *client = user_data;\n\n    if (client == NULL) {\n        return;\n    }\n\n    ipc_proxy_remove_provider(client);\n\n    /* if this is the last remote connection, stop recurring\n     * operations */\n    if (crm_hash_table_size(client_connections) == 1) {\n        client_disconnect_cleanup(NULL);\n    }\n\n    crm_notice(\"LRMD client disconnecting remote client - name: %s id: %s\",\n               client->name ? client->name : \"<unknown>\", client->id);\n\n    if (client->remote->tls_session) {\n        void *sock_ptr;\n        int csock;\n\n        sock_ptr = gnutls_transport_get_ptr(*client->remote->tls_session);\n        csock = GPOINTER_TO_INT(sock_ptr);\n\n        gnutls_bye(*client->remote->tls_session, GNUTLS_SHUT_RDWR);\n        gnutls_deinit(*client->remote->tls_session);\n        gnutls_free(client->remote->tls_session);\n        close(csock);\n    }\n\n    lrmd_client_destroy(client);\n    return;\n}\n\nstatic gboolean\nlrmd_auth_timeout_cb(gpointer data)\n{\n    crm_client_t *client = data;\n\n    client->remote->auth_timeout = 0;\n\n    if (client->remote->tls_handshake_complete == TRUE) {\n        return FALSE;\n    }\n\n    mainloop_del_fd(client->remote->source);\n    client->remote->source = NULL;\n    crm_err(\"Remote client authentication timed out\");\n\n    return FALSE;\n}\n\n/* Convert a struct sockaddr address to a string, IPv4 and IPv6: */\n\nstatic char *\nget_ip_str(const struct sockaddr * sa, char * s, size_t maxlen)\n{\n    switch(sa->sa_family) {\n        case AF_INET:\n            inet_ntop(AF_INET, &(((struct sockaddr_in *)sa)->sin_addr),\n                      s, maxlen);\n            break;\n\n        case AF_INET6:\n            inet_ntop(AF_INET6, &(((struct sockaddr_in6 *)sa)->sin6_addr),\n                      s, maxlen);\n            break;\n\n        default:\n            strncpy(s, \"Unknown AF\", maxlen);\n            return NULL;\n    }\n\n    return s;\n}\n\nstatic int\nlrmd_remote_listen(gpointer data)\n{\n    int csock = 0;\n    int flag = 0;\n    unsigned laddr = 0;\n    struct sockaddr addr;\n    gnutls_session_t *session = NULL;\n    crm_client_t *new_client = NULL;\n\n    static struct mainloop_fd_callbacks lrmd_remote_fd_cb = {\n        .dispatch = lrmd_remote_client_msg,\n        .destroy = lrmd_remote_client_destroy,\n    };\n\n    laddr = sizeof(addr);\n    memset(&addr, 0, sizeof(addr));\n    getsockname(ssock, &addr, &laddr);\n\n    /* accept the connection */\n\n    if (addr.sa_family == AF_INET6) {\n        struct sockaddr_in6 sa;\n        char addr_str[INET6_ADDRSTRLEN];\n\n        laddr = sizeof(sa);\n        memset(&sa, 0, sizeof(sa));\n        csock = accept(ssock, &sa, &laddr);\n        get_ip_str((struct sockaddr *)&sa, addr_str, INET6_ADDRSTRLEN);\n        crm_info(\"New remote connection from %s\", addr_str);\n\n    } else {\n        struct sockaddr_in sa;\n        char addr_str[INET_ADDRSTRLEN];\n\n        laddr = sizeof(sa);\n        memset(&sa, 0, sizeof(sa));\n        csock = accept(ssock, &sa, &laddr);\n        get_ip_str((struct sockaddr *)&sa, addr_str, INET_ADDRSTRLEN);\n        crm_info(\"New remote connection from %s\", addr_str);\n    }\n\n    if (csock == -1) {\n        crm_err(\"accept socket failed\");\n        return TRUE;\n    }\n\n    if ((flag = fcntl(csock, F_GETFL)) >= 0) {\n        if (fcntl(csock, F_SETFL, flag | O_NONBLOCK) < 0) {\n            crm_err(\"fcntl() write failed\");\n            close(csock);\n            return TRUE;\n        }\n    } else {\n        crm_err(\"fcntl() read failed\");\n        close(csock);\n        return TRUE;\n    }\n\n    session = create_psk_tls_session(csock, GNUTLS_SERVER, psk_cred_s);\n    if (session == NULL) {\n        crm_err(\"TLS session creation failed\");\n        close(csock);\n        return TRUE;\n    }\n\n    new_client = calloc(1, sizeof(crm_client_t));\n    new_client->remote = calloc(1, sizeof(crm_remote_t));\n    new_client->kind = CRM_CLIENT_TLS;\n    new_client->remote->tls_session = session;\n    new_client->id = crm_generate_uuid();\n    new_client->remote->auth_timeout =\n        g_timeout_add(LRMD_REMOTE_AUTH_TIMEOUT, lrmd_auth_timeout_cb, new_client);\n    crm_notice(\"LRMD client connection established. %p id: %s\", new_client, new_client->id);\n\n    new_client->remote->source =\n        mainloop_add_fd(\"lrmd-remote-client\", G_PRIORITY_DEFAULT, csock, new_client,\n                        &lrmd_remote_fd_cb);\n    g_hash_table_insert(client_connections, new_client->id, new_client);\n\n    return TRUE;\n}\n\nstatic void\nlrmd_remote_connection_destroy(gpointer user_data)\n{\n    crm_notice(\"Remote tls server disconnected\");\n    return;\n}\n\nstatic int\nlrmd_tls_server_key_cb(gnutls_session_t session, const char *username, gnutls_datum_t * key)\n{\n    return lrmd_tls_set_key(key);\n}\n\nstatic int\nbind_and_listen(struct addrinfo *addr)\n{\n    int optval;\n    int fd;\n    int rc;\n    char buffer[256] = { 0, };\n\n    if (addr->ai_family == AF_INET6) {\n        struct sockaddr_in6 *addr_in = (struct sockaddr_in6 *)(void*)addr->ai_addr;\n        inet_ntop(addr->ai_family, &addr_in->sin6_addr, buffer, DIMOF(buffer));\n\n    } else {\n        struct sockaddr_in *addr_in = (struct sockaddr_in *)(void*)addr->ai_addr;\n        inet_ntop(addr->ai_family, &addr_in->sin_addr, buffer, DIMOF(buffer));\n    }\n\n    crm_trace(\"Attempting to bind on address %s\", buffer);\n\n    fd = socket(addr->ai_family, addr->ai_socktype, addr->ai_protocol);\n    if (fd < 0) {\n        return -1;\n    }\n\n    /* reuse address */\n    optval = 1;\n    rc = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\n    if (rc < 0) {\n        crm_perror(LOG_INFO, \"Couldn't allow the reuse of local addresses by our remote listener, bind address %s\", buffer);\n        close(fd);\n        return -1;\n    }\n\n    if (addr->ai_family == AF_INET6) {\n        optval = 0;\n        rc = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &optval, sizeof(optval));\n        if (rc < 0) {\n            crm_perror(LOG_INFO, \"Couldn't disable IPV6 only on address %s\", buffer);\n            close(fd);\n            return -1;\n        }\n    }\n\n    if (bind(fd, addr->ai_addr, addr->ai_addrlen) != 0) {\n        close(fd);\n        return -1;\n    }\n\n    if (listen(fd, 10) == -1) {\n        crm_err(\"Can not start listen on address %s\", buffer);\n        close(fd);\n        return -1;\n    }\n\n    crm_notice(\"Listening on address %s\", buffer);\n\n    return fd;\n}\n\nint\nlrmd_init_remote_tls_server(int port)\n{\n    int rc;\n    int filter;\n    struct addrinfo hints, *res = NULL, *iter;\n    char port_str[16];\n\n    static struct mainloop_fd_callbacks remote_listen_fd_callbacks = {\n        .dispatch = lrmd_remote_listen,\n        .destroy = lrmd_remote_connection_destroy,\n    };\n\n    crm_notice(\"Starting a tls listener on port %d.\", port);\n    crm_gnutls_global_init();\n    gnutls_global_set_log_function(debug_log);\n\n    gnutls_dh_params_init(&dh_params);\n    gnutls_dh_params_generate2(dh_params, 1024);\n    gnutls_psk_allocate_server_credentials(&psk_cred_s);\n    gnutls_psk_set_server_credentials_function(psk_cred_s, lrmd_tls_server_key_cb);\n    gnutls_psk_set_server_dh_params(psk_cred_s, dh_params);\n\n    memset(&hints, 0, sizeof(struct addrinfo));\n    hints.ai_flags = AI_PASSIVE; /* Only return socket addresses with wildcard INADDR_ANY or IN6ADDR_ANY_INIT */\n    hints.ai_family = AF_UNSPEC; /* Return IPv6 or IPv4 */\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = IPPROTO_TCP;\n\n    snprintf(port_str, sizeof(port_str), \"%d\", port);\n    rc = getaddrinfo(NULL, port_str, &hints, &res);\n    if (rc) {\n        crm_err(\"getaddrinfo: %s\", gai_strerror(rc));\n        return -1;\n    }\n\n    iter = res;\n    filter = AF_INET6;\n    /* Try IPv6 addresses first, then IPv4 */\n    while (iter) {\n        if (iter->ai_family == filter) {\n            ssock = bind_and_listen(iter);\n        }\n        if (ssock != -1) {\n            break;\n        }\n\n        iter = iter->ai_next;\n        if (iter == NULL && filter == AF_INET6) {\n            iter = res;\n            filter = AF_INET;\n        }\n    }\n\n    if (ssock < 0) {\n        crm_err(\"unable to bind to address\");\n        goto init_remote_cleanup;\n    }\n\n    mainloop_add_fd(\"lrmd-remote\", G_PRIORITY_DEFAULT, ssock, NULL, &remote_listen_fd_callbacks);\n\n    rc = ssock;\n  init_remote_cleanup:\n    if (rc < 0) {\n        close(ssock);\n        ssock = 0;\n    }\n    freeaddrinfo(res);\n    return rc;\n\n}\n\nvoid\nlrmd_tls_server_destroy(void)\n{\n    if (psk_cred_s) {\n        gnutls_psk_free_server_credentials(psk_cred_s);\n        psk_cred_s = 0;\n    }\n\n    if (ssock > 0) {\n        close(ssock);\n        ssock = 0;\n    }\n}\n#endif\n"], "filenames": ["lrmd/tls_backend.c"], "buggy_code_start_loc": [81], "buggy_code_end_loc": [294], "fixing_code_start_loc": [82], "fixing_code_end_loc": [294], "type": "CWE-254", "message": "Pacemaker before 1.1.15, when using pacemaker remote, might allow remote attackers to cause a denial of service (node disconnection) via an unauthenticated connection.", "other": {"cve": {"id": "CVE-2016-7797", "sourceIdentifier": "secalert@redhat.com", "published": "2017-03-24T15:59:00.717", "lastModified": "2018-10-30T16:27:33.013", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Pacemaker before 1.1.15, when using pacemaker remote, might allow remote attackers to cause a denial of service (node disconnection) via an unauthenticated connection."}, {"lang": "es", "value": "Pacemaker en versiones anteriores a 1.1.15, al usar el control remoto de marcapasos, podr\u00eda permitir a atacantes remotos provocar una denegaci\u00f3n de servicio (desconexi\u00f3n de nodo) a trav\u00e9s de una conexi\u00f3n no autenticada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-254"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:clusterlabs:pacemaker:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.1.14", "matchCriteriaId": "51E5FBB4-CA9F-4B1E-8B96-5A1307EE73B0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.2:*:*:*:*:*:*:*", "matchCriteriaId": "1EA337A3-B9A3-4962-B8BD-8E0C7C5B28EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse_project:leap:42.1:*:*:*:*:*:*:*", "matchCriteriaId": "CF605E46-ADCE-45B3-BBBA-E593D3CEE2A6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_high_availability:12:sp2:*:*:*:*:*:*", "matchCriteriaId": "4B4F47F0-A116-4844-8A2C-B1D8FD18B27E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_software_development_kit:12:sp2:*:*:*:*:*:*", "matchCriteriaId": "5F150BD9-4B94-42D3-9E14-58665B7FF220"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_high_availability:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "F92715C0-6341-4617-9F61-C87907D1C3F8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_resilient_storage:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "F66BE726-A258-42D7-B23A-925F50FDF449"}]}]}], "references": [{"url": "http://bugs.clusterlabs.org/show_bug.cgi?id=5269", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-11/msg00038.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-12/msg00001.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2016-12/msg00077.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2578.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/10/01/1", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/93261", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/ClusterLabs/pacemaker/commit/5ec24a2642bd0854b884d1a9b51d12371373b410", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ClusterLabs/pacemaker/commit/5ec24a2642bd0854b884d1a9b51d12371373b410"}}