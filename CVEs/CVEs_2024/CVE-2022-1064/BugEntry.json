{"buggy_code": ["<?php\n\nnamespace Backend\\Modules\\Blog\\Engine;\n\nuse Backend\\Core\\Engine\\Exception;\nuse Backend\\Core\\Engine\\Authentication as BackendAuthentication;\nuse Backend\\Core\\Engine\\Model as BackendModel;\nuse Backend\\Core\\Language\\Language as BL;\nuse Backend\\Modules\\Tags\\Engine\\Model as BackendTagsModel;\nuse ForkCMS\\Utility\\Thumbnails;\n\n/**\n * In this file we store all generic functions that we will be using in the blog module\n */\nclass Model\n{\n    const QUERY_DATAGRID_BROWSE =\n        'SELECT i.hidden, i.id, i.revision_id, i.title, UNIX_TIMESTAMP(i.publish_on) AS publish_on, i.user_id, i.num_comments AS comments\n         FROM blog_posts AS i\n         WHERE i.status = ? AND i.language = ?';\n\n    const QUERY_DATAGRID_BROWSE_FOR_CATEGORY =\n        'SELECT i.id, i.revision_id, i.title, UNIX_TIMESTAMP(i.publish_on) AS publish_on, i.user_id, i.num_comments AS comments\n         FROM blog_posts AS i\n         WHERE i.category_id = ? AND i.status = ? AND i.language = ?';\n\n    const QUERY_DATAGRID_BROWSE_CATEGORIES =\n        'SELECT i.id, i.title, COUNT(p.id) AS num_items\n         FROM blog_categories AS i\n         LEFT OUTER JOIN blog_posts AS p ON i.id = p.category_id AND p.status = ? AND p.language = i.language\n         WHERE i.language = ?\n         GROUP BY i.id';\n\n    const QUERY_DATAGRID_BROWSE_COMMENTS =\n        'SELECT\n             i.id, UNIX_TIMESTAMP(i.created_on) AS created_on, i.author, i.text,\n             p.id AS post_id, p.title AS post_title, m.url AS post_url\n         FROM blog_comments AS i\n         INNER JOIN blog_posts AS p ON i.post_id = p.id AND i.language = p.language\n         INNER JOIN meta AS m ON p.meta_id = m.id\n         WHERE i.status = ? AND i.language = ? AND p.status = ?\n         GROUP BY i.id';\n\n    const QUERY_DATAGRID_BROWSE_DRAFTS =\n        'SELECT i.id, i.user_id, i.revision_id, i.title, UNIX_TIMESTAMP(i.edited_on) AS edited_on, i.num_comments AS comments\n         FROM blog_posts AS i\n         INNER JOIN\n         (\n             SELECT MAX(i.revision_id) AS revision_id\n             FROM blog_posts AS i\n             WHERE i.status = ? AND i.user_id = ? AND i.language = ?\n             GROUP BY i.id\n         ) AS p\n         WHERE i.revision_id = p.revision_id';\n\n    const QUERY_DATAGRID_BROWSE_DRAFTS_FOR_CATEGORY =\n        'SELECT i.id, i.user_id, i.revision_id, i.title, UNIX_TIMESTAMP(i.edited_on) AS edited_on, i.num_comments AS comments\n         FROM blog_posts AS i\n         INNER JOIN\n         (\n             SELECT MAX(i.revision_id) AS revision_id\n             FROM blog_posts AS i\n             WHERE i.category_id = ? AND i.status = ? AND i.user_id = ? AND i.language = ?\n             GROUP BY i.id\n         ) AS p\n         WHERE i.revision_id = p.revision_id';\n\n    const QUERY_DATAGRID_BROWSE_RECENT =\n        'SELECT i.id, i.revision_id, i.title, UNIX_TIMESTAMP(i.edited_on) AS edited_on, i.user_id, i.num_comments AS comments\n         FROM blog_posts AS i\n         WHERE i.status = ? AND i.language = ?\n         ORDER BY i.edited_on DESC\n         LIMIT ?';\n\n    const QUERY_DATAGRID_BROWSE_RECENT_FOR_CATEGORY =\n        'SELECT i.id, i.revision_id, i.title, UNIX_TIMESTAMP(i.edited_on) AS edited_on, i.user_id, i.num_comments AS comments\n         FROM blog_posts AS i\n         WHERE i.category_id = ? AND i.status = ? AND i.language = ?\n         ORDER BY i.edited_on DESC\n         LIMIT ?';\n\n    const QUERY_DATAGRID_BROWSE_REVISIONS =\n        'SELECT i.id, i.revision_id, i.title, UNIX_TIMESTAMP(i.edited_on) AS edited_on, i.user_id\n         FROM blog_posts AS i\n         WHERE i.status = ? AND i.id = ? AND i.language = ?\n         ORDER BY i.edited_on DESC';\n\n    const QUERY_DATAGRID_BROWSE_SPECIFIC_DRAFTS =\n        'SELECT i.id, i.revision_id, i.title, UNIX_TIMESTAMP(i.edited_on) AS edited_on, i.user_id\n         FROM blog_posts AS i\n         WHERE i.status = ? AND i.id = ? AND i.language = ?\n         ORDER BY i.edited_on DESC';\n\n    /**\n     * Checks the settings and optionally returns an array with warnings\n     *\n     * @return array\n     */\n    public static function checkSettings(): array\n    {\n        $warnings = [];\n\n        // check if this action is allowed\n        if (BackendAuthentication::isAllowedAction('Settings', 'Blog')) {\n            // rss title\n            if (BackendModel::get('fork.settings')->get('Blog', 'rss_title_' . BL::getWorkingLanguage(), null) == '') {\n                $warnings[] = [\n                    'message' => sprintf(\n                        BL::err('RSSTitle', 'Blog'),\n                        BackendModel::createUrlForAction('Settings', 'Blog')\n                    ),\n                ];\n            }\n\n            // rss description\n            if (BackendModel::get('fork.settings')->get('Blog', 'rss_description_' . BL::getWorkingLanguage(), null) == '') {\n                $warnings[] = [\n                    'message' => sprintf(\n                        BL::err('RSSDescription', 'Blog'),\n                        BackendModel::createUrlForAction('Settings', 'Blog')\n                    ),\n                ];\n            }\n        }\n\n        return $warnings;\n    }\n\n    /**\n     * Deletes one or more items\n     *\n     * @param mixed $ids The ids to delete.\n     */\n    public static function delete($ids): void\n    {\n        // make sure $ids is an array\n        $ids = (array) $ids;\n\n        // make sure we have elements\n        if (empty($ids)) {\n            return;\n        }\n\n        // loop and cast to integers\n        foreach ($ids as &$id) {\n            $id = (int) $id;\n        }\n\n        // create an string with an equal amount of questionmarks as ids provided\n        $idPlaceHolders = implode(', ', array_fill(0, count($ids), '?'));\n\n        // get database\n        $database = BackendModel::getContainer()->get('database');\n\n        // get used meta ids\n        $metaIds = (array) $database->getColumn(\n            'SELECT meta_id\n             FROM blog_posts AS p\n             WHERE id IN (' . $idPlaceHolders . ') AND language = ?',\n            array_merge($ids, [BL::getWorkingLanguage()])\n        );\n\n        // delete meta\n        if (!empty($metaIds)) {\n            $database->delete('meta', 'id IN (' . implode(',', $metaIds) . ')');\n        }\n\n        // delete image files\n        $images = $database->getColumn('SELECT image FROM blog_posts WHERE id IN (' . $idPlaceHolders . ')', $ids);\n\n        foreach ($images as $image) {\n            BackendModel::get(Thumbnails::class)->delete(FRONTEND_FILES_PATH . '/Blog/images', $image);\n        }\n\n        // delete records\n        $database->delete(\n            'blog_posts',\n            'id IN (' . $idPlaceHolders . ') AND language = ?',\n            array_merge($ids, [BL::getWorkingLanguage()])\n        );\n        $database->delete(\n            'blog_comments',\n            'post_id IN (' . $idPlaceHolders . ') AND language = ?',\n            array_merge($ids, [BL::getWorkingLanguage()])\n        );\n\n        // delete tags\n        foreach ($ids as $id) {\n            BackendTagsModel::saveTags($id, '', 'Blog');\n        }\n    }\n\n    /**\n     * Deletes a category\n     *\n     * @param int $id The id of the category to delete.\n     */\n    public static function deleteCategory(int $id): void\n    {\n        $id = (int) $id;\n        $database = BackendModel::getContainer()->get('database');\n\n        // get item\n        $item = self::getCategory($id);\n\n        if (!empty($item)) {\n            // delete meta\n            $database->delete('meta', 'id = ?', [$item['meta_id']]);\n\n            // delete category\n            $database->delete('blog_categories', 'id = ?', [$id]);\n\n            // update category for the posts that might be in this category\n            $database->update('blog_posts', ['category_id' => null], 'category_id = ?', [$id]);\n        }\n    }\n\n    /**\n     * Checks if it is allowed to delete the a category\n     *\n     * @param int $id The id of the category.\n     *\n     * @return bool\n     */\n    public static function deleteCategoryAllowed(int $id): bool\n    {\n        return !(bool) BackendModel::getContainer()->get('database')->getVar(\n            'SELECT 1\n             FROM blog_posts AS i\n             WHERE i.category_id = ? AND i.language = ? AND i.status = ?\n             LIMIT 1',\n            [(int) $id, BL::getWorkingLanguage(), 'active']\n        );\n    }\n\n    /**\n     * Deletes one or more comments\n     *\n     * @param array $ids The id(s) of the items(s) to delete.\n     */\n    public static function deleteComments(array $ids): void\n    {\n        // make sure $ids is an array\n        $ids = (array) $ids;\n\n        // loop and cast to integers\n        foreach ($ids as &$id) {\n            $id = (int) $id;\n        }\n\n        // create an array with an equal amount of questionmarks as ids provided\n        $idPlaceHolders = array_fill(0, count($ids), '?');\n\n        // get database\n        $database = BackendModel::getContainer()->get('database');\n\n        // get ids\n        $itemIds = (array) $database->getColumn(\n            'SELECT i.post_id\n             FROM blog_comments AS i\n             WHERE i.id IN (' . implode(', ', $idPlaceHolders) . ')',\n            $ids\n        );\n\n        // update record\n        $database->delete('blog_comments', 'id IN (' . implode(', ', $idPlaceHolders) . ')', $ids);\n\n        // recalculate the comment count\n        if (!empty($itemIds)) {\n            self::reCalculateCommentCount($itemIds);\n        }\n    }\n\n    public static function deleteSpamComments(): void\n    {\n        $database = BackendModel::getContainer()->get('database');\n\n        // get ids\n        $itemIds = (array) $database->getColumn(\n            'SELECT i.post_id\n             FROM blog_comments AS i\n             WHERE status = ? AND i.language = ?',\n            ['spam', BL::getWorkingLanguage()]\n        );\n\n        // update record\n        $database->delete('blog_comments', 'status = ? AND language = ?', ['spam', BL::getWorkingLanguage()]);\n\n        // recalculate the comment count\n        if (!empty($itemIds)) {\n            self::reCalculateCommentCount($itemIds);\n        }\n    }\n\n    /**\n     * Checks if an item exists\n     *\n     * @param int $id The id of the item to check for existence.\n     *\n     * @return bool\n     */\n    public static function exists(int $id): bool\n    {\n        return (bool) BackendModel::getContainer()->get('database')->getVar(\n            'SELECT i.id\n             FROM blog_posts AS i\n             WHERE i.id = ? AND i.language = ?',\n            [(int) $id, BL::getWorkingLanguage()]\n        );\n    }\n\n    public static function existsCategory(int $id): bool\n    {\n        return (bool) BackendModel::getContainer()->get('database')->getVar(\n            'SELECT 1\n             FROM blog_categories AS i\n             WHERE i.id = ? AND i.language = ?\n             LIMIT 1',\n            [(int) $id, BL::getWorkingLanguage()]\n        );\n    }\n\n    public static function existsComment(int $id): bool\n    {\n        return (bool) BackendModel::getContainer()->get('database')->getVar(\n            'SELECT 1\n             FROM blog_comments AS i\n             WHERE i.id = ? AND i.language = ?\n             LIMIT 1',\n            [(int) $id, BL::getWorkingLanguage()]\n        );\n    }\n\n    /**\n     * Get all data for a given id\n     *\n     * @param int $id The Id of the item to fetch?\n     *\n     * @return array\n     */\n    public static function get(int $id): array\n    {\n        return (array) BackendModel::getContainer()->get('database')->getRecord(\n            'SELECT i.*, UNIX_TIMESTAMP(i.publish_on) AS publish_on, UNIX_TIMESTAMP(i.created_on) AS created_on, UNIX_TIMESTAMP(i.edited_on) AS edited_on, m.url\n             FROM blog_posts AS i\n             INNER JOIN meta AS m ON m.id = i.meta_id\n             WHERE i.id = ? AND (i.status = ? OR i.status = ?) AND i.language = ?\n             ORDER BY i.revision_id DESC',\n            [(int) $id, 'active', 'draft', BL::getWorkingLanguage()]\n        );\n    }\n\n    /**\n     * Get the comments\n     *\n     * @param string $status The type of comments to get.\n     * @param int $limit The maximum number of items to retrieve.\n     * @param int $offset The offset.\n     *\n     * @return array\n     */\n    public static function getAllCommentsForStatus(string $status, int $limit = 30, int $offset = 0): array\n    {\n        return (array) BackendModel::getContainer()->get('database')->getRecords(\n            'SELECT DISTINCT i.id, UNIX_TIMESTAMP(i.created_on) AS created_on, i.author, i.email, i.website, i.text, i.type, i.status,\n             p.id AS post_id, p.title AS post_title, m.url AS post_url, p.language AS post_language\n             FROM blog_comments AS i\n             INNER JOIN blog_posts AS p ON i.post_id = p.id AND i.language = p.language\n             INNER JOIN meta AS m ON p.meta_id = m.id\n             WHERE i.status = ? AND p.language = ?\n             LIMIT ?, ?',\n            [$status, BL::getWorkingLanguage(), $offset, $limit]\n        );\n    }\n\n    /**\n     * Get all items by a given tag id\n     *\n     * @param int $tagId The id of the tag.\n     *\n     * @return array\n     */\n    public static function getByTag(int $tagId): array\n    {\n        $items = (array) BackendModel::getContainer()->get('database')->getRecords(\n            'SELECT i.id AS url, i.title AS name, mt.module\n             FROM modules_tags AS mt\n             INNER JOIN tags AS t ON mt.tag_id = t.id\n             INNER JOIN blog_posts AS i ON mt.other_id = i.id\n             WHERE mt.module = ? AND mt.tag_id = ? AND i.status = ? AND i.language = ?',\n            ['Blog', (int) $tagId, 'active', BL::getWorkingLanguage()]\n        );\n\n        // overwrite the url\n        foreach ($items as &$row) {\n            $row['url'] = BackendModel::createUrlForAction('Edit', 'Blog', null, ['id' => $row['url']]);\n        }\n\n        return $items;\n    }\n\n    /**\n     * Get all categories\n     *\n     * @param bool $includeCount Include the count?\n     *\n     * @return array\n     */\n    public static function getCategories(bool $includeCount = false): array\n    {\n        $database = BackendModel::getContainer()->get('database');\n\n        if ($includeCount) {\n            return (array) $database->getPairs(\n                'SELECT i.id, CONCAT(i.title, \" (\", COUNT(p.category_id) ,\")\") AS title\n                 FROM blog_categories AS i\n                 LEFT OUTER JOIN blog_posts AS p ON i.id = p.category_id AND i.language = p.language AND p.status = ?\n                 WHERE i.language = ?\n                 GROUP BY i.id',\n                ['active', BL::getWorkingLanguage()]\n            );\n        }\n\n        return (array) $database->getPairs(\n            'SELECT i.id, i.title\n             FROM blog_categories AS i\n             WHERE i.language = ?',\n            [BL::getWorkingLanguage()]\n        );\n    }\n\n    /**\n     * Get all data for a given id\n     *\n     * @param int $id The id of the category to fetch.\n     *\n     * @return array\n     */\n    public static function getCategory($id): array\n    {\n        return (array) BackendModel::getContainer()->get('database')->getRecord(\n            'SELECT i.*\n             FROM blog_categories AS i\n             WHERE i.id = ? AND i.language = ?',\n            [(int) $id, BL::getWorkingLanguage()]\n        );\n    }\n\n    /**\n     * Get a category id by title\n     *\n     * @param string $title The title of the category.\n     * @param string $language The language to use, if not provided we will use the working language.\n     *\n     * @return int\n     */\n    public static function getCategoryId(string $title, string $language = null): int\n    {\n        $title = (string) $title;\n        $language = ($language !== null) ? (string) $language : BL::getWorkingLanguage();\n\n        return (int) BackendModel::getContainer()->get('database')->getVar(\n            'SELECT i.id\n             FROM blog_categories AS i\n             WHERE i.title = ? AND i.language = ?',\n            [$title, $language]\n        );\n    }\n\n    /**\n     * Get all data for a given id\n     *\n     * @param int $id The Id of the comment to fetch?\n     *\n     * @return array\n     */\n    public static function getComment($id): array\n    {\n        return (array) BackendModel::getContainer()->get('database')->getRecord(\n            'SELECT i.*, UNIX_TIMESTAMP(i.created_on) AS created_on,\n             p.id AS post_id, p.title AS post_title, m.url AS post_url\n             FROM blog_comments AS i\n             INNER JOIN blog_posts AS p ON i.post_id = p.id AND i.language = p.language\n             INNER JOIN meta AS m ON p.meta_id = m.id\n             WHERE i.id = ? AND p.status = ?\n             LIMIT 1',\n            [(int) $id, 'active']\n        );\n    }\n\n    /**\n     * Get multiple comments at once\n     *\n     * @param array $ids The id(s) of the comment(s).\n     *\n     * @return array\n     */\n    public static function getComments(array $ids): array\n    {\n        return (array) BackendModel::getContainer()->get('database')->getRecords(\n            'SELECT *\n             FROM blog_comments AS i\n             WHERE i.id IN (' . implode(', ', array_fill(0, count($ids), '?')) . ')',\n            $ids\n        );\n    }\n\n    /**\n     * Get a count per comment\n     *\n     * @return array\n     */\n    public static function getCommentStatusCount(): array\n    {\n        return (array) BackendModel::getContainer()->get('database')->getPairs(\n            'SELECT i.status, COUNT(i.id)\n             FROM blog_comments AS i\n             WHERE i.language = ?\n             GROUP BY i.status',\n            [BL::getWorkingLanguage()]\n        );\n    }\n\n    /**\n     * Get the latest comments for a given type\n     *\n     * @param string $status The status for the comments to retrieve.\n     * @param int $limit The maximum number of items to retrieve.\n     *\n     * @return array\n     */\n    public static function getLatestComments(string $status, int $limit = 10): array\n    {\n        // get the comments (order by id, this is faster then on date, the higher the id, the more recent\n        $comments = (array) BackendModel::getContainer()->get('database')->getRecords(\n            'SELECT i.id, i.author, i.text, UNIX_TIMESTAMP(i.created_on) AS created_in,\n             p.title, p.language, m.url\n             FROM blog_comments AS i\n             INNER JOIN blog_posts AS p ON i.post_id = p.id AND i.language = p.language\n             INNER JOIN meta AS m ON p.meta_id = m.id\n             WHERE i.status = ? AND p.status = ? AND i.language = ?\n             ORDER BY i.created_on DESC\n             LIMIT ?',\n            [(string) $status, 'active', BL::getWorkingLanguage(), (int) $limit]\n        );\n\n        // overwrite url\n        $baseUrl = BackendModel::getUrlForBlock('Blog', 'detail');\n\n        foreach ($comments as &$row) {\n            $row['full_url'] = $baseUrl . '/' . $row['url'];\n        }\n\n        return $comments;\n    }\n\n    /**\n     * Get the maximum id\n     *\n     * @return int\n     */\n    public static function getMaximumId(): int\n    {\n        return (int) BackendModel::getContainer()->get('database')->getVar('SELECT MAX(id) FROM blog_posts LIMIT 1');\n    }\n\n    /**\n     * Get all data for a given revision\n     *\n     * @param int $id The id of the item.\n     * @param int $revisionId The revision to get.\n     *\n     * @return array\n     */\n    public static function getRevision(int $id, int $revisionId): array\n    {\n        return (array) BackendModel::getContainer()->get('database')->getRecord(\n            'SELECT i.*, UNIX_TIMESTAMP(i.publish_on) AS publish_on, UNIX_TIMESTAMP(i.created_on) AS created_on, UNIX_TIMESTAMP(i.edited_on) AS edited_on, m.url\n             FROM blog_posts AS i\n             INNER JOIN meta AS m ON m.id = i.meta_id\n             WHERE i.id = ? AND i.revision_id = ?',\n            [(int) $id, (int) $revisionId]\n        );\n    }\n\n    /**\n     * Retrieve the unique URL for an item\n     *\n     * @param string $url The URL to base on.\n     * @param int $id The id of the item to ignore.\n     *\n     * @return string\n     */\n    public static function getUrl(string $url, int $id = null): string\n    {\n        $url = (string) $url;\n\n        // get database\n        $database = BackendModel::getContainer()->get('database');\n\n        // new item\n        if ($id === null) {\n            // already exists\n            if ((bool) $database->getVar(\n                'SELECT 1\n                 FROM blog_posts AS i\n                 INNER JOIN meta AS m ON i.meta_id = m.id\n                 WHERE i.language = ? AND m.url = ?\n                 LIMIT 1',\n                [BL::getWorkingLanguage(), $url]\n            )\n            ) {\n                $url = BackendModel::addNumber($url);\n\n                return self::getUrl($url);\n            }\n        } else {\n            // current category should be excluded\n            if ((bool) $database->getVar(\n                'SELECT 1\n                 FROM blog_posts AS i\n                 INNER JOIN meta AS m ON i.meta_id = m.id\n                 WHERE i.language = ? AND m.url = ? AND i.id != ?\n                 LIMIT 1',\n                [BL::getWorkingLanguage(), $url, $id]\n            )\n            ) {\n                $url = BackendModel::addNumber($url);\n\n                return self::getUrl($url, $id);\n            }\n        }\n\n        return $url;\n    }\n\n    /**\n     * Retrieve the unique URL for a category\n     *\n     * @param string $url The string whereon the URL will be based.\n     * @param int $id The id of the category to ignore.\n     *\n     * @return string\n     */\n    public static function getUrlForCategory($url, int $id = null): string\n    {\n        // redefine URL\n        $url = (string) $url;\n\n        // get database\n        $database = BackendModel::getContainer()->get('database');\n\n        // new category\n        if ($id === null) {\n            // already exists\n            if ((bool) $database->getVar(\n                'SELECT 1\n                 FROM blog_categories AS i\n                 INNER JOIN meta AS m ON i.meta_id = m.id\n                 WHERE i.language = ? AND m.url = ?\n                 LIMIT 1',\n                [BL::getWorkingLanguage(), $url]\n            )\n            ) {\n                $url = BackendModel::addNumber($url);\n\n                return self::getUrlForCategory($url);\n            }\n        } else {\n            // current category should be excluded\n            if ((bool) $database->getVar(\n                'SELECT 1\n                 FROM blog_categories AS i\n                 INNER JOIN meta AS m ON i.meta_id = m.id\n                 WHERE i.language = ? AND m.url = ? AND i.id != ?\n                 LIMIT 1',\n                [BL::getWorkingLanguage(), $url, $id]\n            )\n            ) {\n                $url = BackendModel::addNumber($url);\n\n                return self::getUrlForCategory($url, $id);\n            }\n        }\n\n        return $url;\n    }\n\n    /**\n     * Inserts an item into the database\n     *\n     * @param array $item The data to insert.\n     *\n     * @return int\n     */\n    public static function insert(array $item): int\n    {\n        // insert and return the new revision id\n        $item['revision_id'] = BackendModel::getContainer()->get('database')->insert('blog_posts', $item);\n\n        // return the new revision id\n        return $item['revision_id'];\n    }\n\n    /**\n     * Inserts a complete post item based on some arrays of data\n     *\n     * This method's purpose is to be able to insert a post (possibly with all its metadata, tags, and comments)\n     * in one method call. As much data as possible has been made optional, to be able to do imports where only\n     * fractions of the data we need are known.\n     *\n     * The item array should have at least a 'title' and a 'text' property other properties are optional.\n     * The meta array has only optional properties. You can use these to override the defaults.\n     * The tags array is just a list of tagnames as string.\n     * The comments array is an array of arrays with comment properties. A comment should have\n     * at least 'author', 'email', and 'text' properties.\n     *\n     * @param array $item The data to insert.\n     * @param array $meta The metadata to insert.\n     * @param array $tags The tags to connect to this post.\n     * @param array $comments The comments attached to this post.\n     *\n     * @throws Exception\n     *\n     * @return int\n     */\n    public static function insertCompletePost(array $item, array $meta = [], $tags = [], $comments = []): int\n    {\n        // Build item\n        if (!isset($item['id'])) {\n            $item['id'] = (int) self::getMaximumId() + 1;\n        }\n        if (!isset($item['user_id'])) {\n            $item['user_id'] = BackendAuthentication::getUser()->getUserId();\n        }\n        if (!isset($item['hidden'])) {\n            $item['hidden'] = false;\n        }\n        if (!isset($item['allow_comments'])) {\n            $item['allow_comments'] = true;\n        }\n        if (!isset($item['num_comments'])) {\n            $item['num_comments'] = 0;\n        }\n        if (!isset($item['status'])) {\n            $item['status'] = 'active';\n        }\n        if (!isset($item['language'])) {\n            $item['language'] = BL::getWorkingLanguage();\n        }\n        if (!isset($item['publish_on'])) {\n            $item['publish_on'] = BackendModel::getUTCDate();\n        }\n        if (!isset($item['created_on'])) {\n            $item['created_on'] = BackendModel::getUTCDate();\n        }\n        if (!isset($item['edited_on'])) {\n            $item['edited_on'] = BackendModel::getUTCDate();\n        }\n        if (!isset($item['category_id'])) {\n            $item['category_id'] = 1;\n        }\n        if (!isset($item['title']) || !isset($item['text'])) {\n            throw new Exception('$item should at least have a title and a text property');\n        }\n\n        // Set drafts hidden\n        if (strtotime((string) $item['publish_on']) > time()) {\n            $item['hidden'] = true;\n            $item['status'] = 'draft';\n        }\n\n        // Build meta\n        if (!isset($meta['keywords'])) {\n            $meta['keywords'] = $item['title'];\n        }\n        if (!isset($meta['keywords_overwrite'])) {\n            $meta['keywords_overwrite'] = false;\n        }\n        if (!isset($meta['description'])) {\n            $meta['description'] = $item['title'];\n        }\n        if (!isset($meta['description_overwrite'])) {\n            $meta['description_overwrite'] = false;\n        }\n        if (!isset($meta['title'])) {\n            $meta['title'] = $item['title'];\n        }\n        if (!isset($meta['title_overwrite'])) {\n            $meta['title_overwrite'] = false;\n        }\n        if (!isset($meta['url'])) {\n            $meta['url'] = self::getUrl($item['title']);\n        }\n        if (!isset($meta['url_overwrite'])) {\n            $meta['url_overwrite'] = false;\n        }\n        if (!isset($meta['seo_index'])) {\n            $meta['seo_index'] = 'index';\n        }\n        if (!isset($meta['seo_follow'])) {\n            $meta['seo_follow'] = 'follow';\n        }\n\n        // Write meta to database\n        $item['meta_id'] = BackendModel::getContainer()->get('database')->insert('meta', $meta);\n\n        // Write post to database\n        $item['revision_id'] = self::insert($item);\n\n        // Any tags?\n        if (!empty($tags)) {\n            BackendTagsModel::saveTags($item['id'], implode(',', $tags), 'blog');\n        }\n\n        // Any comments?\n        foreach ($comments as $comment) {\n            // We require some fields (author, email, text)\n            if (!isset($comment['author']) || !isset($comment['email']) || !isset($comment['text'])) {\n                continue;\n            }\n\n            // Set some defaults\n            if (!isset($comment['language'])) {\n                $comment['language'] = BL::getWorkingLanguage();\n            }\n            if (!isset($comment['created_on'])) {\n                $comment['created_on'] = BackendModel::getUTCDate();\n            }\n            if (!isset($comment['status'])) {\n                $comment['status'] = 'published';\n            }\n            if (!isset($comment['data'])) {\n                $comment['data'] = serialize(['server' => $_SERVER]);\n            }\n            if (!isset($comment['website'])) {\n                $comment['website'] = '';\n            }\n\n            $comment['post_id'] = $item['id'];\n            $comment['data'] = serialize(['server' => $_SERVER]);\n\n            // Insert the comment\n            self::insertComment($comment);\n        }\n\n        // Return\n        return $item['revision_id'];\n    }\n\n    /**\n     * Inserts a new category into the database\n     *\n     * @param array $item The data for the category to insert.\n     * @param array $meta The metadata for the category to insert.\n     *\n     * @return int\n     */\n    public static function insertCategory(array $item, array $meta = null): int\n    {\n        // get database\n        $database = BackendModel::getContainer()->get('database');\n\n        // meta given?\n        if ($meta !== null) {\n            $item['meta_id'] = $database->insert('meta', $meta);\n        }\n\n        // create category\n        $item['id'] = $database->insert('blog_categories', $item);\n\n        // return the id\n        return $item['id'];\n    }\n\n    /**\n     * Inserts a new comment (Taken from FrontendBlogModel)\n     *\n     * @param array $comment The comment to add.\n     *\n     * @return int\n     */\n    public static function insertComment(array $comment): int\n    {\n        // get database\n        $database = BackendModel::getContainer()->get('database');\n\n        // insert comment\n        $comment['id'] = (int) $database->insert('blog_comments', $comment);\n\n        // recalculate if published\n        if ($comment['status'] == 'published') {\n            // num comments\n            $numComments = (int) BackendModel::getContainer()->get('database')->getVar(\n                'SELECT COUNT(i.id) AS comment_count\n                 FROM blog_comments AS i\n                 INNER JOIN blog_posts AS p ON i.post_id = p.id AND i.language = p.language\n                 WHERE i.status = ? AND i.post_id = ? AND i.language = ? AND p.status = ?\n                 GROUP BY i.post_id',\n                ['published', $comment['post_id'], BL::getWorkingLanguage(), 'active']\n            );\n\n            // update num comments\n            $database->update('blog_posts', ['num_comments' => $numComments], 'id = ?', $comment['post_id']);\n        }\n\n        return $comment['id'];\n    }\n\n    /**\n     * Recalculate the commentcount\n     *\n     * @param array $ids The id(s) of the post wherefore the commentcount should be recalculated.\n     *\n     * @return bool\n     */\n    public static function reCalculateCommentCount(array $ids): bool\n    {\n        // validate\n        if (empty($ids)) {\n            return false;\n        }\n\n        // make unique ids\n        $ids = array_unique($ids);\n\n        // get database\n        $database = BackendModel::getContainer()->get('database');\n\n        // get counts\n        $commentCounts = (array) $database->getPairs(\n            'SELECT i.post_id, COUNT(i.id) AS comment_count\n             FROM blog_comments AS i\n             INNER JOIN blog_posts AS p ON i.post_id = p.id AND i.language = p.language\n             WHERE i.status = ? AND i.post_id IN (' . implode(',', $ids) . ') AND i.language = ? AND p.status = ?\n             GROUP BY i.post_id',\n            ['published', BL::getWorkingLanguage(), 'active']\n        );\n\n        foreach ($ids as $id) {\n            // get count\n            $count = (isset($commentCounts[$id])) ? (int) $commentCounts[$id] : 0;\n\n            // update\n            $database->update(\n                'blog_posts',\n                ['num_comments' => $count],\n                'id = ? AND language = ?',\n                [$id, BL::getWorkingLanguage()]\n            );\n        }\n\n        return true;\n    }\n\n    /**\n     * Update an existing item\n     *\n     * @param array $item The new data.\n     *\n     * @return int\n     */\n    public static function update(array $item): int\n    {\n        $database = BackendModel::getContainer()->get('database');\n\n        // get the record of the exact item we're editing\n        $revision = self::getRevision($item['id'], $item['revision_id']);\n\n        // assign values\n        $item['created_on'] = BackendModel::getUTCDate('Y-m-d H:i:s', $revision['created_on']);\n        $item['num_comments'] = $revision['num_comments'];\n\n        // check if new version is active\n        if ($item['status'] === 'active') {\n            // archive all older active versions\n            $database->update(\n                'blog_posts',\n                ['status' => 'archived'],\n                'id = ? AND status = ?',\n                [$item['id'], $item['status']]\n            );\n\n            // if it used to be a draft that we're now publishing, remove drafts\n            if ($revision['status'] === 'draft') {\n                $database->delete(\n                    'blog_posts',\n                    'id = ? AND status = ?',\n                    [$item['id'], $revision['status']]\n                );\n            }\n        }\n\n        // don't want revision id\n        unset($item['revision_id']);\n\n        // how many revisions should we keep\n        $rowsToKeep = (int) BackendModel::get('fork.settings')->get('Blog', 'max_num_revisions', 20);\n\n        // set type of archive\n        $archiveType = ($item['status'] === 'active' ? 'archived' : $item['status']);\n\n        // get revision-ids for items to keep\n        $revisionIdsToKeep = (array) $database->getColumn(\n            'SELECT i.revision_id\n             FROM blog_posts AS i\n             WHERE i.id = ? AND i.status = ? AND i.language = ?\n             ORDER BY i.edited_on DESC\n             LIMIT ?',\n            [$item['id'], $archiveType, BL::getWorkingLanguage(), $rowsToKeep]\n        );\n\n        // delete other revisions\n        if (!empty($revisionIdsToKeep)) {\n            // get meta-ids that will be deleted\n            $metasIdsToRemove = (array) $database->getColumn(\n                'SELECT i.meta_id\n                 FROM blog_posts AS i\n                 WHERE i.id = ? AND revision_id NOT IN (' . implode(', ', $revisionIdsToKeep) . ')',\n                [$item['id']]\n            );\n\n            // get all the images of the revisions that will NOT be deleted\n            $imagesToKeep = $database->getColumn(\n                'SELECT image FROM blog_posts\n                 WHERE id = ? AND revision_id IN (' . implode(', ', $revisionIdsToKeep) . ')',\n                [$item['id']]\n            );\n\n            // get the images of the revisions that will be deleted\n            $imagesOfDeletedRevisions = $database->getColumn(\n                'SELECT image FROM blog_posts\n                WHERE id = ? AND status = ? AND revision_id NOT IN (' . implode(', ', $revisionIdsToKeep) . ')',\n                [$item['id'], $archiveType]\n            );\n\n            // make sure that an image that will be deleted, is not used by a revision that is not to be deleted\n            foreach ($imagesOfDeletedRevisions as $imageOfDeletedRevision) {\n                if (!in_array($imageOfDeletedRevision, $imagesToKeep, true)) {\n                    BackendModel::get(Thumbnails::class)->delete(\n                        FRONTEND_FILES_PATH . '/Blog/images',\n                        $imageOfDeletedRevision\n                    );\n                }\n            }\n\n            $database->delete(\n                'blog_posts',\n                'id = ? AND status = ? AND revision_id NOT IN (' . implode(', ', $revisionIdsToKeep) . ')',\n                [$item['id'], $archiveType]\n            );\n\n            if (!empty($metasIdsToRemove)) {\n                $database->delete(\n                    'meta',\n                    'id IN (' . implode(', ', $metasIdsToRemove) . ')'\n                );\n            }\n        }\n\n        // insert new version\n        $item['revision_id'] = BackendModel::getContainer()->get('database')->insert('blog_posts', $item);\n\n        // return the new revision id\n        return $item['revision_id'];\n    }\n\n    /**\n     * Update an existing category\n     *\n     * @param array $item The new data.\n     * @param array $meta The new meta-data.\n     *\n     * @return int\n     */\n    public static function updateCategory(array $item, array $meta = null): int\n    {\n        // get database\n        $database = BackendModel::getContainer()->get('database');\n\n        // update category\n        $updated = $database->update('blog_categories', $item, 'id = ?', [(int) $item['id']]);\n\n        // meta passed?\n        if ($meta !== null) {\n            // get current category\n            $category = self::getCategory($item['id']);\n\n            // update the meta\n            $database->update('meta', $meta, 'id = ?', [(int) $category['meta_id']]);\n        }\n\n        return $updated;\n    }\n\n    /**\n     * Update an existing comment\n     *\n     * @param array $item The new data.\n     *\n     * @return int\n     */\n    public static function updateComment(array $item): int\n    {\n        // update category\n        return BackendModel::getContainer()->get('database')->update(\n            'blog_comments',\n            $item,\n            'id = ?',\n            [(int) $item['id']]\n        );\n    }\n\n    /**\n     * Updates one or more comments' status\n     *\n     * @param array $ids The id(s) of the comment(s) to change the status for.\n     * @param string $status The new status.\n     */\n    public static function updateCommentStatuses(array $ids, string $status): void\n    {\n        // make sure $ids is an array\n        $ids = (array) $ids;\n\n        // loop and cast to integers\n        foreach ($ids as &$id) {\n            $id = (int) $id;\n        }\n\n        // create an array with an equal amount of questionmarks as ids provided\n        $idPlaceHolders = array_fill(0, count($ids), '?');\n\n        // get the items and their languages\n        $items = (array) BackendModel::getContainer()->get('database')->getPairs(\n            'SELECT i.post_id, i.language\n             FROM blog_comments AS i\n             WHERE i.id IN (' . implode(', ', $idPlaceHolders) . ')',\n            $ids,\n            'post_id'\n        );\n\n        // only proceed if there are items\n        if (!empty($items)) {\n            // get the ids\n            $itemIds = array_keys($items);\n\n            // update records\n            BackendModel::getContainer()->get('database')->execute(\n                'UPDATE blog_comments\n                 SET status = ?\n                 WHERE id IN (' . implode(', ', $idPlaceHolders) . ')',\n                array_merge([(string) $status], $ids)\n            );\n\n            // recalculate the comment count\n            self::reCalculateCommentCount($itemIds);\n        }\n    }\n\n    /**\n     * Update a page revision without generating a new revision.\n     * Needed to add an image to a page.\n     *\n     * @param $revision_id\n     * @param $item\n     */\n    public static function updateRevision($revision_id, $item): void\n    {\n        BackendModel::getContainer()->get('database')->update(\n            'blog_posts',\n            $item,\n            'revision_id = ?',\n            [$revision_id]\n        );\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace Backend\\Modules\\Blog\\Engine;\n\nuse Backend\\Core\\Engine\\Exception;\nuse Backend\\Core\\Engine\\Authentication as BackendAuthentication;\nuse Backend\\Core\\Engine\\Model as BackendModel;\nuse Backend\\Core\\Language\\Language as BL;\nuse Backend\\Modules\\Tags\\Engine\\Model as BackendTagsModel;\nuse ForkCMS\\Utility\\Thumbnails;\n\n/**\n * In this file we store all generic functions that we will be using in the blog module\n */\nclass Model\n{\n    const QUERY_DATAGRID_BROWSE =\n        'SELECT i.hidden, i.id, i.revision_id, i.title, UNIX_TIMESTAMP(i.publish_on) AS publish_on, i.user_id, i.num_comments AS comments\n         FROM blog_posts AS i\n         WHERE i.status = ? AND i.language = ?';\n\n    const QUERY_DATAGRID_BROWSE_FOR_CATEGORY =\n        'SELECT i.id, i.revision_id, i.title, UNIX_TIMESTAMP(i.publish_on) AS publish_on, i.user_id, i.num_comments AS comments\n         FROM blog_posts AS i\n         WHERE i.category_id = ? AND i.status = ? AND i.language = ?';\n\n    const QUERY_DATAGRID_BROWSE_CATEGORIES =\n        'SELECT i.id, i.title, COUNT(p.id) AS num_items\n         FROM blog_categories AS i\n         LEFT OUTER JOIN blog_posts AS p ON i.id = p.category_id AND p.status = ? AND p.language = i.language\n         WHERE i.language = ?\n         GROUP BY i.id';\n\n    const QUERY_DATAGRID_BROWSE_COMMENTS =\n        'SELECT\n             i.id, UNIX_TIMESTAMP(i.created_on) AS created_on, i.author, i.text,\n             p.id AS post_id, p.title AS post_title, m.url AS post_url\n         FROM blog_comments AS i\n         INNER JOIN blog_posts AS p ON i.post_id = p.id AND i.language = p.language\n         INNER JOIN meta AS m ON p.meta_id = m.id\n         WHERE i.status = ? AND i.language = ? AND p.status = ?\n         GROUP BY i.id';\n\n    const QUERY_DATAGRID_BROWSE_DRAFTS =\n        'SELECT i.id, i.user_id, i.revision_id, i.title, UNIX_TIMESTAMP(i.edited_on) AS edited_on, i.num_comments AS comments\n         FROM blog_posts AS i\n         INNER JOIN\n         (\n             SELECT MAX(i.revision_id) AS revision_id\n             FROM blog_posts AS i\n             WHERE i.status = ? AND i.user_id = ? AND i.language = ?\n             GROUP BY i.id\n         ) AS p\n         WHERE i.revision_id = p.revision_id';\n\n    const QUERY_DATAGRID_BROWSE_DRAFTS_FOR_CATEGORY =\n        'SELECT i.id, i.user_id, i.revision_id, i.title, UNIX_TIMESTAMP(i.edited_on) AS edited_on, i.num_comments AS comments\n         FROM blog_posts AS i\n         INNER JOIN\n         (\n             SELECT MAX(i.revision_id) AS revision_id\n             FROM blog_posts AS i\n             WHERE i.category_id = ? AND i.status = ? AND i.user_id = ? AND i.language = ?\n             GROUP BY i.id\n         ) AS p\n         WHERE i.revision_id = p.revision_id';\n\n    const QUERY_DATAGRID_BROWSE_RECENT =\n        'SELECT i.id, i.revision_id, i.title, UNIX_TIMESTAMP(i.edited_on) AS edited_on, i.user_id, i.num_comments AS comments\n         FROM blog_posts AS i\n         WHERE i.status = ? AND i.language = ?\n         ORDER BY i.edited_on DESC\n         LIMIT ?';\n\n    const QUERY_DATAGRID_BROWSE_RECENT_FOR_CATEGORY =\n        'SELECT i.id, i.revision_id, i.title, UNIX_TIMESTAMP(i.edited_on) AS edited_on, i.user_id, i.num_comments AS comments\n         FROM blog_posts AS i\n         WHERE i.category_id = ? AND i.status = ? AND i.language = ?\n         ORDER BY i.edited_on DESC\n         LIMIT ?';\n\n    const QUERY_DATAGRID_BROWSE_REVISIONS =\n        'SELECT i.id, i.revision_id, i.title, UNIX_TIMESTAMP(i.edited_on) AS edited_on, i.user_id\n         FROM blog_posts AS i\n         WHERE i.status = ? AND i.id = ? AND i.language = ?\n         ORDER BY i.edited_on DESC';\n\n    const QUERY_DATAGRID_BROWSE_SPECIFIC_DRAFTS =\n        'SELECT i.id, i.revision_id, i.title, UNIX_TIMESTAMP(i.edited_on) AS edited_on, i.user_id\n         FROM blog_posts AS i\n         WHERE i.status = ? AND i.id = ? AND i.language = ?\n         ORDER BY i.edited_on DESC';\n\n    /**\n     * Checks the settings and optionally returns an array with warnings\n     *\n     * @return array\n     */\n    public static function checkSettings(): array\n    {\n        $warnings = [];\n\n        // check if this action is allowed\n        if (BackendAuthentication::isAllowedAction('Settings', 'Blog')) {\n            // rss title\n            if (BackendModel::get('fork.settings')->get('Blog', 'rss_title_' . BL::getWorkingLanguage(), null) == '') {\n                $warnings[] = [\n                    'message' => sprintf(\n                        BL::err('RSSTitle', 'Blog'),\n                        BackendModel::createUrlForAction('Settings', 'Blog')\n                    ),\n                ];\n            }\n\n            // rss description\n            if (BackendModel::get('fork.settings')->get('Blog', 'rss_description_' . BL::getWorkingLanguage(), null) == '') {\n                $warnings[] = [\n                    'message' => sprintf(\n                        BL::err('RSSDescription', 'Blog'),\n                        BackendModel::createUrlForAction('Settings', 'Blog')\n                    ),\n                ];\n            }\n        }\n\n        return $warnings;\n    }\n\n    /**\n     * Deletes one or more items\n     *\n     * @param mixed $ids The ids to delete.\n     */\n    public static function delete($ids): void\n    {\n        // make sure $ids is an array\n        $ids = (array) $ids;\n\n        // make sure we have elements\n        if (empty($ids)) {\n            return;\n        }\n\n        // loop and cast to integers\n        foreach ($ids as &$id) {\n            $id = (int) $id;\n        }\n\n        // create an string with an equal amount of questionmarks as ids provided\n        $idPlaceHolders = implode(', ', array_fill(0, count($ids), '?'));\n\n        // get database\n        $database = BackendModel::getContainer()->get('database');\n\n        // get used meta ids\n        $metaIds = (array) $database->getColumn(\n            'SELECT meta_id\n             FROM blog_posts AS p\n             WHERE id IN (' . $idPlaceHolders . ') AND language = ?',\n            array_merge($ids, [BL::getWorkingLanguage()])\n        );\n\n        // delete meta\n        if (!empty($metaIds)) {\n            $database->delete('meta', 'id IN (' . implode(',', $metaIds) . ')');\n        }\n\n        // delete image files\n        $images = $database->getColumn('SELECT image FROM blog_posts WHERE id IN (' . $idPlaceHolders . ')', $ids);\n\n        foreach ($images as $image) {\n            BackendModel::get(Thumbnails::class)->delete(FRONTEND_FILES_PATH . '/Blog/images', $image);\n        }\n\n        // delete records\n        $database->delete(\n            'blog_posts',\n            'id IN (' . $idPlaceHolders . ') AND language = ?',\n            array_merge($ids, [BL::getWorkingLanguage()])\n        );\n        $database->delete(\n            'blog_comments',\n            'post_id IN (' . $idPlaceHolders . ') AND language = ?',\n            array_merge($ids, [BL::getWorkingLanguage()])\n        );\n\n        // delete tags\n        foreach ($ids as $id) {\n            BackendTagsModel::saveTags($id, '', 'Blog');\n        }\n    }\n\n    /**\n     * Deletes a category\n     *\n     * @param int $id The id of the category to delete.\n     */\n    public static function deleteCategory(int $id): void\n    {\n        $id = (int) $id;\n        $database = BackendModel::getContainer()->get('database');\n\n        // get item\n        $item = self::getCategory($id);\n\n        if (!empty($item)) {\n            // delete meta\n            $database->delete('meta', 'id = ?', [$item['meta_id']]);\n\n            // delete category\n            $database->delete('blog_categories', 'id = ?', [$id]);\n\n            // update category for the posts that might be in this category\n            $database->update('blog_posts', ['category_id' => null], 'category_id = ?', [$id]);\n        }\n    }\n\n    /**\n     * Checks if it is allowed to delete the a category\n     *\n     * @param int $id The id of the category.\n     *\n     * @return bool\n     */\n    public static function deleteCategoryAllowed(int $id): bool\n    {\n        return !(bool) BackendModel::getContainer()->get('database')->getVar(\n            'SELECT 1\n             FROM blog_posts AS i\n             WHERE i.category_id = ? AND i.language = ? AND i.status = ?\n             LIMIT 1',\n            [(int) $id, BL::getWorkingLanguage(), 'active']\n        );\n    }\n\n    /**\n     * Deletes one or more comments\n     *\n     * @param array $ids The id(s) of the items(s) to delete.\n     */\n    public static function deleteComments(array $ids): void\n    {\n        // make sure $ids is an array\n        $ids = (array) $ids;\n\n        // loop and cast to integers\n        foreach ($ids as &$id) {\n            $id = (int) $id;\n        }\n\n        // create an array with an equal amount of questionmarks as ids provided\n        $idPlaceHolders = array_fill(0, count($ids), '?');\n\n        // get database\n        $database = BackendModel::getContainer()->get('database');\n\n        // get ids\n        $itemIds = (array) $database->getColumn(\n            'SELECT i.post_id\n             FROM blog_comments AS i\n             WHERE i.id IN (' . implode(', ', $idPlaceHolders) . ')',\n            $ids\n        );\n\n        // update record\n        $database->delete('blog_comments', 'id IN (' . implode(', ', $idPlaceHolders) . ')', $ids);\n\n        // recalculate the comment count\n        if (!empty($itemIds)) {\n            self::reCalculateCommentCount($itemIds);\n        }\n    }\n\n    public static function deleteSpamComments(): void\n    {\n        $database = BackendModel::getContainer()->get('database');\n\n        // get ids\n        $itemIds = (array) $database->getColumn(\n            'SELECT i.post_id\n             FROM blog_comments AS i\n             WHERE status = ? AND i.language = ?',\n            ['spam', BL::getWorkingLanguage()]\n        );\n\n        // update record\n        $database->delete('blog_comments', 'status = ? AND language = ?', ['spam', BL::getWorkingLanguage()]);\n\n        // recalculate the comment count\n        if (!empty($itemIds)) {\n            self::reCalculateCommentCount($itemIds);\n        }\n    }\n\n    /**\n     * Checks if an item exists\n     *\n     * @param int $id The id of the item to check for existence.\n     *\n     * @return bool\n     */\n    public static function exists(int $id): bool\n    {\n        return (bool) BackendModel::getContainer()->get('database')->getVar(\n            'SELECT i.id\n             FROM blog_posts AS i\n             WHERE i.id = ? AND i.language = ?',\n            [(int) $id, BL::getWorkingLanguage()]\n        );\n    }\n\n    public static function existsCategory(int $id): bool\n    {\n        return (bool) BackendModel::getContainer()->get('database')->getVar(\n            'SELECT 1\n             FROM blog_categories AS i\n             WHERE i.id = ? AND i.language = ?\n             LIMIT 1',\n            [(int) $id, BL::getWorkingLanguage()]\n        );\n    }\n\n    public static function existsComment(int $id): bool\n    {\n        return (bool) BackendModel::getContainer()->get('database')->getVar(\n            'SELECT 1\n             FROM blog_comments AS i\n             WHERE i.id = ? AND i.language = ?\n             LIMIT 1',\n            [(int) $id, BL::getWorkingLanguage()]\n        );\n    }\n\n    /**\n     * Get all data for a given id\n     *\n     * @param int $id The Id of the item to fetch?\n     *\n     * @return array\n     */\n    public static function get(int $id): array\n    {\n        return (array) BackendModel::getContainer()->get('database')->getRecord(\n            'SELECT i.*, UNIX_TIMESTAMP(i.publish_on) AS publish_on, UNIX_TIMESTAMP(i.created_on) AS created_on, UNIX_TIMESTAMP(i.edited_on) AS edited_on, m.url\n             FROM blog_posts AS i\n             INNER JOIN meta AS m ON m.id = i.meta_id\n             WHERE i.id = ? AND (i.status = ? OR i.status = ?) AND i.language = ?\n             ORDER BY i.revision_id DESC',\n            [(int) $id, 'active', 'draft', BL::getWorkingLanguage()]\n        );\n    }\n\n    /**\n     * Get the comments\n     *\n     * @param string $status The type of comments to get.\n     * @param int $limit The maximum number of items to retrieve.\n     * @param int $offset The offset.\n     *\n     * @return array\n     */\n    public static function getAllCommentsForStatus(string $status, int $limit = 30, int $offset = 0): array\n    {\n        return (array) BackendModel::getContainer()->get('database')->getRecords(\n            'SELECT DISTINCT i.id, UNIX_TIMESTAMP(i.created_on) AS created_on, i.author, i.email, i.website, i.text, i.type, i.status,\n             p.id AS post_id, p.title AS post_title, m.url AS post_url, p.language AS post_language\n             FROM blog_comments AS i\n             INNER JOIN blog_posts AS p ON i.post_id = p.id AND i.language = p.language\n             INNER JOIN meta AS m ON p.meta_id = m.id\n             WHERE i.status = ? AND p.language = ?\n             LIMIT ?, ?',\n            [$status, BL::getWorkingLanguage(), $offset, $limit]\n        );\n    }\n\n    /**\n     * Get all items by a given tag id\n     *\n     * @param int $tagId The id of the tag.\n     *\n     * @return array\n     */\n    public static function getByTag(int $tagId): array\n    {\n        $items = (array) BackendModel::getContainer()->get('database')->getRecords(\n            'SELECT i.id AS url, i.title AS name, mt.module\n             FROM modules_tags AS mt\n             INNER JOIN tags AS t ON mt.tag_id = t.id\n             INNER JOIN blog_posts AS i ON mt.other_id = i.id\n             WHERE mt.module = ? AND mt.tag_id = ? AND i.status = ? AND i.language = ?',\n            ['Blog', (int) $tagId, 'active', BL::getWorkingLanguage()]\n        );\n\n        // overwrite the url\n        foreach ($items as &$row) {\n            $row['url'] = BackendModel::createUrlForAction('Edit', 'Blog', null, ['id' => $row['url']]);\n        }\n\n        return $items;\n    }\n\n    /**\n     * Get all categories\n     *\n     * @param bool $includeCount Include the count?\n     *\n     * @return array\n     */\n    public static function getCategories(bool $includeCount = false): array\n    {\n        $database = BackendModel::getContainer()->get('database');\n\n        if ($includeCount) {\n            return (array) $database->getPairs(\n                'SELECT i.id, CONCAT(i.title, \" (\", COUNT(p.category_id) ,\")\") AS title\n                 FROM blog_categories AS i\n                 LEFT OUTER JOIN blog_posts AS p ON i.id = p.category_id AND i.language = p.language AND p.status = ?\n                 WHERE i.language = ?\n                 GROUP BY i.id',\n                ['active', BL::getWorkingLanguage()]\n            );\n        }\n\n        return (array) $database->getPairs(\n            'SELECT i.id, i.title\n             FROM blog_categories AS i\n             WHERE i.language = ?',\n            [BL::getWorkingLanguage()]\n        );\n    }\n\n    /**\n     * Get all data for a given id\n     *\n     * @param int $id The id of the category to fetch.\n     *\n     * @return array\n     */\n    public static function getCategory($id): array\n    {\n        return (array) BackendModel::getContainer()->get('database')->getRecord(\n            'SELECT i.*\n             FROM blog_categories AS i\n             WHERE i.id = ? AND i.language = ?',\n            [(int) $id, BL::getWorkingLanguage()]\n        );\n    }\n\n    /**\n     * Get a category id by title\n     *\n     * @param string $title The title of the category.\n     * @param string $language The language to use, if not provided we will use the working language.\n     *\n     * @return int\n     */\n    public static function getCategoryId(string $title, string $language = null): int\n    {\n        $title = (string) $title;\n        $language = ($language !== null) ? (string) $language : BL::getWorkingLanguage();\n\n        return (int) BackendModel::getContainer()->get('database')->getVar(\n            'SELECT i.id\n             FROM blog_categories AS i\n             WHERE i.title = ? AND i.language = ?',\n            [$title, $language]\n        );\n    }\n\n    /**\n     * Get all data for a given id\n     *\n     * @param int $id The Id of the comment to fetch?\n     *\n     * @return array\n     */\n    public static function getComment($id): array\n    {\n        return (array) BackendModel::getContainer()->get('database')->getRecord(\n            'SELECT i.*, UNIX_TIMESTAMP(i.created_on) AS created_on,\n             p.id AS post_id, p.title AS post_title, m.url AS post_url\n             FROM blog_comments AS i\n             INNER JOIN blog_posts AS p ON i.post_id = p.id AND i.language = p.language\n             INNER JOIN meta AS m ON p.meta_id = m.id\n             WHERE i.id = ? AND p.status = ?\n             LIMIT 1',\n            [(int) $id, 'active']\n        );\n    }\n\n    /**\n     * Get multiple comments at once\n     *\n     * @param array $ids The id(s) of the comment(s).\n     *\n     * @return array\n     */\n    public static function getComments(array $ids): array\n    {\n        return (array) BackendModel::getContainer()->get('database')->getRecords(\n            'SELECT *\n             FROM blog_comments AS i\n             WHERE i.id IN (' . implode(', ', array_fill(0, count($ids), '?')) . ')',\n            array_map('intval', $ids)\n        );\n    }\n\n    /**\n     * Get a count per comment\n     *\n     * @return array\n     */\n    public static function getCommentStatusCount(): array\n    {\n        return (array) BackendModel::getContainer()->get('database')->getPairs(\n            'SELECT i.status, COUNT(i.id)\n             FROM blog_comments AS i\n             WHERE i.language = ?\n             GROUP BY i.status',\n            [BL::getWorkingLanguage()]\n        );\n    }\n\n    /**\n     * Get the latest comments for a given type\n     *\n     * @param string $status The status for the comments to retrieve.\n     * @param int $limit The maximum number of items to retrieve.\n     *\n     * @return array\n     */\n    public static function getLatestComments(string $status, int $limit = 10): array\n    {\n        // get the comments (order by id, this is faster then on date, the higher the id, the more recent\n        $comments = (array) BackendModel::getContainer()->get('database')->getRecords(\n            'SELECT i.id, i.author, i.text, UNIX_TIMESTAMP(i.created_on) AS created_in,\n             p.title, p.language, m.url\n             FROM blog_comments AS i\n             INNER JOIN blog_posts AS p ON i.post_id = p.id AND i.language = p.language\n             INNER JOIN meta AS m ON p.meta_id = m.id\n             WHERE i.status = ? AND p.status = ? AND i.language = ?\n             ORDER BY i.created_on DESC\n             LIMIT ?',\n            [(string) $status, 'active', BL::getWorkingLanguage(), (int) $limit]\n        );\n\n        // overwrite url\n        $baseUrl = BackendModel::getUrlForBlock('Blog', 'detail');\n\n        foreach ($comments as &$row) {\n            $row['full_url'] = $baseUrl . '/' . $row['url'];\n        }\n\n        return $comments;\n    }\n\n    /**\n     * Get the maximum id\n     *\n     * @return int\n     */\n    public static function getMaximumId(): int\n    {\n        return (int) BackendModel::getContainer()->get('database')->getVar('SELECT MAX(id) FROM blog_posts LIMIT 1');\n    }\n\n    /**\n     * Get all data for a given revision\n     *\n     * @param int $id The id of the item.\n     * @param int $revisionId The revision to get.\n     *\n     * @return array\n     */\n    public static function getRevision(int $id, int $revisionId): array\n    {\n        return (array) BackendModel::getContainer()->get('database')->getRecord(\n            'SELECT i.*, UNIX_TIMESTAMP(i.publish_on) AS publish_on, UNIX_TIMESTAMP(i.created_on) AS created_on, UNIX_TIMESTAMP(i.edited_on) AS edited_on, m.url\n             FROM blog_posts AS i\n             INNER JOIN meta AS m ON m.id = i.meta_id\n             WHERE i.id = ? AND i.revision_id = ?',\n            [(int) $id, (int) $revisionId]\n        );\n    }\n\n    /**\n     * Retrieve the unique URL for an item\n     *\n     * @param string $url The URL to base on.\n     * @param int $id The id of the item to ignore.\n     *\n     * @return string\n     */\n    public static function getUrl(string $url, int $id = null): string\n    {\n        $url = (string) $url;\n\n        // get database\n        $database = BackendModel::getContainer()->get('database');\n\n        // new item\n        if ($id === null) {\n            // already exists\n            if ((bool) $database->getVar(\n                'SELECT 1\n                 FROM blog_posts AS i\n                 INNER JOIN meta AS m ON i.meta_id = m.id\n                 WHERE i.language = ? AND m.url = ?\n                 LIMIT 1',\n                [BL::getWorkingLanguage(), $url]\n            )\n            ) {\n                $url = BackendModel::addNumber($url);\n\n                return self::getUrl($url);\n            }\n        } else {\n            // current category should be excluded\n            if ((bool) $database->getVar(\n                'SELECT 1\n                 FROM blog_posts AS i\n                 INNER JOIN meta AS m ON i.meta_id = m.id\n                 WHERE i.language = ? AND m.url = ? AND i.id != ?\n                 LIMIT 1',\n                [BL::getWorkingLanguage(), $url, $id]\n            )\n            ) {\n                $url = BackendModel::addNumber($url);\n\n                return self::getUrl($url, $id);\n            }\n        }\n\n        return $url;\n    }\n\n    /**\n     * Retrieve the unique URL for a category\n     *\n     * @param string $url The string whereon the URL will be based.\n     * @param int $id The id of the category to ignore.\n     *\n     * @return string\n     */\n    public static function getUrlForCategory($url, int $id = null): string\n    {\n        // redefine URL\n        $url = (string) $url;\n\n        // get database\n        $database = BackendModel::getContainer()->get('database');\n\n        // new category\n        if ($id === null) {\n            // already exists\n            if ((bool) $database->getVar(\n                'SELECT 1\n                 FROM blog_categories AS i\n                 INNER JOIN meta AS m ON i.meta_id = m.id\n                 WHERE i.language = ? AND m.url = ?\n                 LIMIT 1',\n                [BL::getWorkingLanguage(), $url]\n            )\n            ) {\n                $url = BackendModel::addNumber($url);\n\n                return self::getUrlForCategory($url);\n            }\n        } else {\n            // current category should be excluded\n            if ((bool) $database->getVar(\n                'SELECT 1\n                 FROM blog_categories AS i\n                 INNER JOIN meta AS m ON i.meta_id = m.id\n                 WHERE i.language = ? AND m.url = ? AND i.id != ?\n                 LIMIT 1',\n                [BL::getWorkingLanguage(), $url, $id]\n            )\n            ) {\n                $url = BackendModel::addNumber($url);\n\n                return self::getUrlForCategory($url, $id);\n            }\n        }\n\n        return $url;\n    }\n\n    /**\n     * Inserts an item into the database\n     *\n     * @param array $item The data to insert.\n     *\n     * @return int\n     */\n    public static function insert(array $item): int\n    {\n        // insert and return the new revision id\n        $item['revision_id'] = BackendModel::getContainer()->get('database')->insert('blog_posts', $item);\n\n        // return the new revision id\n        return $item['revision_id'];\n    }\n\n    /**\n     * Inserts a complete post item based on some arrays of data\n     *\n     * This method's purpose is to be able to insert a post (possibly with all its metadata, tags, and comments)\n     * in one method call. As much data as possible has been made optional, to be able to do imports where only\n     * fractions of the data we need are known.\n     *\n     * The item array should have at least a 'title' and a 'text' property other properties are optional.\n     * The meta array has only optional properties. You can use these to override the defaults.\n     * The tags array is just a list of tagnames as string.\n     * The comments array is an array of arrays with comment properties. A comment should have\n     * at least 'author', 'email', and 'text' properties.\n     *\n     * @param array $item The data to insert.\n     * @param array $meta The metadata to insert.\n     * @param array $tags The tags to connect to this post.\n     * @param array $comments The comments attached to this post.\n     *\n     * @throws Exception\n     *\n     * @return int\n     */\n    public static function insertCompletePost(array $item, array $meta = [], $tags = [], $comments = []): int\n    {\n        // Build item\n        if (!isset($item['id'])) {\n            $item['id'] = (int) self::getMaximumId() + 1;\n        }\n        if (!isset($item['user_id'])) {\n            $item['user_id'] = BackendAuthentication::getUser()->getUserId();\n        }\n        if (!isset($item['hidden'])) {\n            $item['hidden'] = false;\n        }\n        if (!isset($item['allow_comments'])) {\n            $item['allow_comments'] = true;\n        }\n        if (!isset($item['num_comments'])) {\n            $item['num_comments'] = 0;\n        }\n        if (!isset($item['status'])) {\n            $item['status'] = 'active';\n        }\n        if (!isset($item['language'])) {\n            $item['language'] = BL::getWorkingLanguage();\n        }\n        if (!isset($item['publish_on'])) {\n            $item['publish_on'] = BackendModel::getUTCDate();\n        }\n        if (!isset($item['created_on'])) {\n            $item['created_on'] = BackendModel::getUTCDate();\n        }\n        if (!isset($item['edited_on'])) {\n            $item['edited_on'] = BackendModel::getUTCDate();\n        }\n        if (!isset($item['category_id'])) {\n            $item['category_id'] = 1;\n        }\n        if (!isset($item['title']) || !isset($item['text'])) {\n            throw new Exception('$item should at least have a title and a text property');\n        }\n\n        // Set drafts hidden\n        if (strtotime((string) $item['publish_on']) > time()) {\n            $item['hidden'] = true;\n            $item['status'] = 'draft';\n        }\n\n        // Build meta\n        if (!isset($meta['keywords'])) {\n            $meta['keywords'] = $item['title'];\n        }\n        if (!isset($meta['keywords_overwrite'])) {\n            $meta['keywords_overwrite'] = false;\n        }\n        if (!isset($meta['description'])) {\n            $meta['description'] = $item['title'];\n        }\n        if (!isset($meta['description_overwrite'])) {\n            $meta['description_overwrite'] = false;\n        }\n        if (!isset($meta['title'])) {\n            $meta['title'] = $item['title'];\n        }\n        if (!isset($meta['title_overwrite'])) {\n            $meta['title_overwrite'] = false;\n        }\n        if (!isset($meta['url'])) {\n            $meta['url'] = self::getUrl($item['title']);\n        }\n        if (!isset($meta['url_overwrite'])) {\n            $meta['url_overwrite'] = false;\n        }\n        if (!isset($meta['seo_index'])) {\n            $meta['seo_index'] = 'index';\n        }\n        if (!isset($meta['seo_follow'])) {\n            $meta['seo_follow'] = 'follow';\n        }\n\n        // Write meta to database\n        $item['meta_id'] = BackendModel::getContainer()->get('database')->insert('meta', $meta);\n\n        // Write post to database\n        $item['revision_id'] = self::insert($item);\n\n        // Any tags?\n        if (!empty($tags)) {\n            BackendTagsModel::saveTags($item['id'], implode(',', $tags), 'blog');\n        }\n\n        // Any comments?\n        foreach ($comments as $comment) {\n            // We require some fields (author, email, text)\n            if (!isset($comment['author']) || !isset($comment['email']) || !isset($comment['text'])) {\n                continue;\n            }\n\n            // Set some defaults\n            if (!isset($comment['language'])) {\n                $comment['language'] = BL::getWorkingLanguage();\n            }\n            if (!isset($comment['created_on'])) {\n                $comment['created_on'] = BackendModel::getUTCDate();\n            }\n            if (!isset($comment['status'])) {\n                $comment['status'] = 'published';\n            }\n            if (!isset($comment['data'])) {\n                $comment['data'] = serialize(['server' => $_SERVER]);\n            }\n            if (!isset($comment['website'])) {\n                $comment['website'] = '';\n            }\n\n            $comment['post_id'] = $item['id'];\n            $comment['data'] = serialize(['server' => $_SERVER]);\n\n            // Insert the comment\n            self::insertComment($comment);\n        }\n\n        // Return\n        return $item['revision_id'];\n    }\n\n    /**\n     * Inserts a new category into the database\n     *\n     * @param array $item The data for the category to insert.\n     * @param array $meta The metadata for the category to insert.\n     *\n     * @return int\n     */\n    public static function insertCategory(array $item, array $meta = null): int\n    {\n        // get database\n        $database = BackendModel::getContainer()->get('database');\n\n        // meta given?\n        if ($meta !== null) {\n            $item['meta_id'] = $database->insert('meta', $meta);\n        }\n\n        // create category\n        $item['id'] = $database->insert('blog_categories', $item);\n\n        // return the id\n        return $item['id'];\n    }\n\n    /**\n     * Inserts a new comment (Taken from FrontendBlogModel)\n     *\n     * @param array $comment The comment to add.\n     *\n     * @return int\n     */\n    public static function insertComment(array $comment): int\n    {\n        // get database\n        $database = BackendModel::getContainer()->get('database');\n\n        // insert comment\n        $comment['id'] = (int) $database->insert('blog_comments', $comment);\n\n        // recalculate if published\n        if ($comment['status'] == 'published') {\n            // num comments\n            $numComments = (int) BackendModel::getContainer()->get('database')->getVar(\n                'SELECT COUNT(i.id) AS comment_count\n                 FROM blog_comments AS i\n                 INNER JOIN blog_posts AS p ON i.post_id = p.id AND i.language = p.language\n                 WHERE i.status = ? AND i.post_id = ? AND i.language = ? AND p.status = ?\n                 GROUP BY i.post_id',\n                ['published', $comment['post_id'], BL::getWorkingLanguage(), 'active']\n            );\n\n            // update num comments\n            $database->update('blog_posts', ['num_comments' => $numComments], 'id = ?', $comment['post_id']);\n        }\n\n        return $comment['id'];\n    }\n\n    /**\n     * Recalculate the commentcount\n     *\n     * @param array $ids The id(s) of the post wherefore the commentcount should be recalculated.\n     *\n     * @return bool\n     */\n    public static function reCalculateCommentCount(array $ids): bool\n    {\n        // validate\n        if (empty($ids)) {\n            return false;\n        }\n\n        // make unique ids\n        $ids = array_unique($ids);\n\n        // get database\n        $database = BackendModel::getContainer()->get('database');\n\n        // get counts\n        $commentCounts = (array) $database->getPairs(\n            'SELECT i.post_id, COUNT(i.id) AS comment_count\n             FROM blog_comments AS i\n             INNER JOIN blog_posts AS p ON i.post_id = p.id AND i.language = p.language\n             WHERE i.status = ? AND i.post_id IN (' . implode(',', $ids) . ') AND i.language = ? AND p.status = ?\n             GROUP BY i.post_id',\n            ['published', BL::getWorkingLanguage(), 'active']\n        );\n\n        foreach ($ids as $id) {\n            // get count\n            $count = (isset($commentCounts[$id])) ? (int) $commentCounts[$id] : 0;\n\n            // update\n            $database->update(\n                'blog_posts',\n                ['num_comments' => $count],\n                'id = ? AND language = ?',\n                [$id, BL::getWorkingLanguage()]\n            );\n        }\n\n        return true;\n    }\n\n    /**\n     * Update an existing item\n     *\n     * @param array $item The new data.\n     *\n     * @return int\n     */\n    public static function update(array $item): int\n    {\n        $database = BackendModel::getContainer()->get('database');\n\n        // get the record of the exact item we're editing\n        $revision = self::getRevision($item['id'], $item['revision_id']);\n\n        // assign values\n        $item['created_on'] = BackendModel::getUTCDate('Y-m-d H:i:s', $revision['created_on']);\n        $item['num_comments'] = $revision['num_comments'];\n\n        // check if new version is active\n        if ($item['status'] === 'active') {\n            // archive all older active versions\n            $database->update(\n                'blog_posts',\n                ['status' => 'archived'],\n                'id = ? AND status = ?',\n                [$item['id'], $item['status']]\n            );\n\n            // if it used to be a draft that we're now publishing, remove drafts\n            if ($revision['status'] === 'draft') {\n                $database->delete(\n                    'blog_posts',\n                    'id = ? AND status = ?',\n                    [$item['id'], $revision['status']]\n                );\n            }\n        }\n\n        // don't want revision id\n        unset($item['revision_id']);\n\n        // how many revisions should we keep\n        $rowsToKeep = (int) BackendModel::get('fork.settings')->get('Blog', 'max_num_revisions', 20);\n\n        // set type of archive\n        $archiveType = ($item['status'] === 'active' ? 'archived' : $item['status']);\n\n        // get revision-ids for items to keep\n        $revisionIdsToKeep = (array) $database->getColumn(\n            'SELECT i.revision_id\n             FROM blog_posts AS i\n             WHERE i.id = ? AND i.status = ? AND i.language = ?\n             ORDER BY i.edited_on DESC\n             LIMIT ?',\n            [$item['id'], $archiveType, BL::getWorkingLanguage(), $rowsToKeep]\n        );\n\n        // delete other revisions\n        if (!empty($revisionIdsToKeep)) {\n            // get meta-ids that will be deleted\n            $metasIdsToRemove = (array) $database->getColumn(\n                'SELECT i.meta_id\n                 FROM blog_posts AS i\n                 WHERE i.id = ? AND revision_id NOT IN (' . implode(', ', $revisionIdsToKeep) . ')',\n                [$item['id']]\n            );\n\n            // get all the images of the revisions that will NOT be deleted\n            $imagesToKeep = $database->getColumn(\n                'SELECT image FROM blog_posts\n                 WHERE id = ? AND revision_id IN (' . implode(', ', $revisionIdsToKeep) . ')',\n                [$item['id']]\n            );\n\n            // get the images of the revisions that will be deleted\n            $imagesOfDeletedRevisions = $database->getColumn(\n                'SELECT image FROM blog_posts\n                WHERE id = ? AND status = ? AND revision_id NOT IN (' . implode(', ', $revisionIdsToKeep) . ')',\n                [$item['id'], $archiveType]\n            );\n\n            // make sure that an image that will be deleted, is not used by a revision that is not to be deleted\n            foreach ($imagesOfDeletedRevisions as $imageOfDeletedRevision) {\n                if (!in_array($imageOfDeletedRevision, $imagesToKeep, true)) {\n                    BackendModel::get(Thumbnails::class)->delete(\n                        FRONTEND_FILES_PATH . '/Blog/images',\n                        $imageOfDeletedRevision\n                    );\n                }\n            }\n\n            $database->delete(\n                'blog_posts',\n                'id = ? AND status = ? AND revision_id NOT IN (' . implode(', ', $revisionIdsToKeep) . ')',\n                [$item['id'], $archiveType]\n            );\n\n            if (!empty($metasIdsToRemove)) {\n                $database->delete(\n                    'meta',\n                    'id IN (' . implode(', ', $metasIdsToRemove) . ')'\n                );\n            }\n        }\n\n        // insert new version\n        $item['revision_id'] = BackendModel::getContainer()->get('database')->insert('blog_posts', $item);\n\n        // return the new revision id\n        return $item['revision_id'];\n    }\n\n    /**\n     * Update an existing category\n     *\n     * @param array $item The new data.\n     * @param array $meta The new meta-data.\n     *\n     * @return int\n     */\n    public static function updateCategory(array $item, array $meta = null): int\n    {\n        // get database\n        $database = BackendModel::getContainer()->get('database');\n\n        // update category\n        $updated = $database->update('blog_categories', $item, 'id = ?', [(int) $item['id']]);\n\n        // meta passed?\n        if ($meta !== null) {\n            // get current category\n            $category = self::getCategory($item['id']);\n\n            // update the meta\n            $database->update('meta', $meta, 'id = ?', [(int) $category['meta_id']]);\n        }\n\n        return $updated;\n    }\n\n    /**\n     * Update an existing comment\n     *\n     * @param array $item The new data.\n     *\n     * @return int\n     */\n    public static function updateComment(array $item): int\n    {\n        // update category\n        return BackendModel::getContainer()->get('database')->update(\n            'blog_comments',\n            $item,\n            'id = ?',\n            [(int) $item['id']]\n        );\n    }\n\n    /**\n     * Updates one or more comments' status\n     *\n     * @param array $ids The id(s) of the comment(s) to change the status for.\n     * @param string $status The new status.\n     */\n    public static function updateCommentStatuses(array $ids, string $status): void\n    {\n        // make sure $ids is an array\n        $ids = (array) $ids;\n\n        // loop and cast to integers\n        foreach ($ids as &$id) {\n            $id = (int) $id;\n        }\n\n        // create an array with an equal amount of questionmarks as ids provided\n        $idPlaceHolders = array_fill(0, count($ids), '?');\n\n        // get the items and their languages\n        $items = (array) BackendModel::getContainer()->get('database')->getPairs(\n            'SELECT i.post_id, i.language\n             FROM blog_comments AS i\n             WHERE i.id IN (' . implode(', ', $idPlaceHolders) . ')',\n            $ids,\n            'post_id'\n        );\n\n        // only proceed if there are items\n        if (!empty($items)) {\n            // get the ids\n            $itemIds = array_keys($items);\n\n            // update records\n            BackendModel::getContainer()->get('database')->execute(\n                'UPDATE blog_comments\n                 SET status = ?\n                 WHERE id IN (' . implode(', ', $idPlaceHolders) . ')',\n                array_merge([(string) $status], $ids)\n            );\n\n            // recalculate the comment count\n            self::reCalculateCommentCount($itemIds);\n        }\n    }\n\n    /**\n     * Update a page revision without generating a new revision.\n     * Needed to add an image to a page.\n     *\n     * @param $revision_id\n     * @param $item\n     */\n    public static function updateRevision($revision_id, $item): void\n    {\n        BackendModel::getContainer()->get('database')->update(\n            'blog_posts',\n            $item,\n            'revision_id = ?',\n            [$revision_id]\n        );\n    }\n}\n"], "filenames": ["src/Backend/Modules/Blog/Engine/Model.php"], "buggy_code_start_loc": [504], "buggy_code_end_loc": [505], "fixing_code_start_loc": [504], "fixing_code_end_loc": [505], "type": "CWE-89", "message": "SQL injection through marking blog comments on bulk as spam in GitHub repository forkcms/forkcms prior to 5.11.1.", "other": {"cve": {"id": "CVE-2022-1064", "sourceIdentifier": "security@huntr.dev", "published": "2022-03-25T12:15:07.807", "lastModified": "2022-03-31T18:48:58.490", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "SQL injection through marking blog comments on bulk as spam in GitHub repository forkcms/forkcms prior to 5.11.1."}, {"lang": "es", "value": "Una Inyecci\u00f3n SQL mediante el marcado de los comentarios del blog a granel como spam en el repositorio de GitHub forkcms/forkcms versiones anteriores a 5.11.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.3, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.11.1", "matchCriteriaId": "38A5F85C-5508-4425-B245-215759FF27B1"}]}]}], "references": [{"url": "https://github.com/forkcms/forkcms/commit/6aca30e10b4181534f73f96d6e2ebeb45ec15069", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/2f664985-c5fc-485b-b4fc-4c401be2cf40", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/forkcms/forkcms/commit/6aca30e10b4181534f73f96d6e2ebeb45ec15069"}}