{"buggy_code": ["#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\n#   SPDX-FileCopyrightText: 2022 Victor Fuentes <vmfuentes64@gmail.com>\n#   SPDX-FileCopyrightText: 2019 Adriaan de Groot <groot@kde.org>\n#   SPDX-License-Identifier: GPL-3.0-or-later\n#\n#   Calamares is Free Software: see the License-Identifier above.\n#\n\nimport libcalamares\nimport os\nimport subprocess\nimport re\n\nimport gettext\n_ = gettext.translation(\"calamares-python\",\n                        localedir=libcalamares.utils.gettext_path(),\n                        languages=libcalamares.utils.gettext_languages(),\n                        fallback=True).gettext\n\n\n# The following strings contain pieces of a nix-configuration file.\n# They are adapted from the default config generated from the nixos-generate-config command.\n\ncfghead = \"\"\"# Edit this configuration file to define what should be installed on\n# your system.  Help is available in the configuration.nix(5) man page\n# and in the NixOS manual (accessible by running \u2018nixos-help\u2019).\n\n{ config, pkgs, ... }:\n\n{\n  imports =\n    [ # Include the results of the hardware scan.\n      ./hardware-configuration.nix\n    ];\n\n\"\"\"\ncfgbootefi = \"\"\"  # Bootloader.\n  boot.loader.systemd-boot.enable = true;\n  boot.loader.efi.canTouchEfiVariables = true;\n\n\"\"\"\n\ncfgbootbios = \"\"\"  # Bootloader.\n  boot.loader.grub.enable = true;\n  boot.loader.grub.device = \"@@bootdev@@\";\n  boot.loader.grub.useOSProber = true;\n\n\"\"\"\n\ncfgbootnone = \"\"\"  # Disable bootloader.\n  boot.loader.grub.enable = false;\n\n\"\"\"\n\ncfgbootcrypt = \"\"\"  # Setup keyfile\n  boot.initrd.secrets = {\n    \"/crypto_keyfile.bin\" = null;\n  };\n\n\"\"\"\n\ncfgbootgrubcrypt = \"\"\"  # Enable grub cryptodisk\n  boot.loader.grub.enableCryptodisk=true;\n\n\"\"\"\n\ncfgswapcrypt = \"\"\"  # Enable swap on luks\n  boot.initrd.luks.devices.\"@@swapdev@@\".device = \"/dev/disk/by-uuid/@@swapuuid@@\";\n  boot.initrd.luks.devices.\"@@swapdev@@\".keyFile = \"/crypto_keyfile.bin\";\n\n\"\"\"\n\ncfgnetwork = \"\"\"  networking.hostName = \"@@hostname@@\"; # Define your hostname.\n  # networking.wireless.enable = true;  # Enables wireless support via wpa_supplicant.\n\n  # Configure network proxy if necessary\n  # networking.proxy.default = \"http://user:password@proxy:port/\";\n  # networking.proxy.noProxy = \"127.0.0.1,localhost,internal.domain\";\n\n\"\"\"\n\ncfgnetworkmanager = \"\"\"  # Enable networking\n  networking.networkmanager.enable = true;\n\n\"\"\"\n\ncfgconnman = \"\"\"  # Enable networking\n  services.connman.enable = true;\n\n\"\"\"\n\ncfgnmapplet = \"\"\"  # Enable network manager applet\n  programs.nm-applet.enable = true;\n\n\"\"\"\n\ncfgtime = \"\"\"  # Set your time zone.\n  time.timeZone = \"@@timezone@@\";\n\n\"\"\"\n\ncfglocale = \"\"\"  # Select internationalisation properties.\n  i18n.defaultLocale = \"@@LANG@@\";\n\n\"\"\"\n\ncfglocaleextra = \"\"\"  i18n.extraLocaleSettings = {\n    LC_ADDRESS = \"@@LC_ADDRESS@@\";\n    LC_IDENTIFICATION = \"@@LC_IDENTIFICATION@@\";\n    LC_MEASUREMENT = \"@@LC_MEASUREMENT@@\";\n    LC_MONETARY = \"@@LC_MONETARY@@\";\n    LC_NAME = \"@@LC_NAME@@\";\n    LC_NUMERIC = \"@@LC_NUMERIC@@\";\n    LC_PAPER = \"@@LC_PAPER@@\";\n    LC_TELEPHONE = \"@@LC_TELEPHONE@@\";\n    LC_TIME = \"@@LC_TIME@@\";\n  };\n\n\"\"\"\n\ncfggnome = \"\"\"  # Enable the X11 windowing system.\n  services.xserver.enable = true;\n\n  # Enable the GNOME Desktop Environment.\n  services.xserver.displayManager.gdm.enable = true;\n  services.xserver.desktopManager.gnome.enable = true;\n\n\"\"\"\n\ncfgplasma = \"\"\"  # Enable the X11 windowing system.\n  services.xserver.enable = true;\n\n  # Enable the KDE Plasma Desktop Environment.\n  services.xserver.displayManager.sddm.enable = true;\n  services.xserver.desktopManager.plasma5.enable = true;\n\n\"\"\"\n\ncfgxfce = \"\"\"  # Enable the X11 windowing system.\n  services.xserver.enable = true;\n\n  # Enable the XFCE Desktop Environment.\n  services.xserver.displayManager.lightdm.enable = true;\n  services.xserver.desktopManager.xfce.enable = true;\n\n\"\"\"\n\ncfgpantheon = \"\"\"  # Enable the X11 windowing system.\n  services.xserver.enable = true;\n\n  # Enable the Pantheon Desktop Environment.\n  services.xserver.displayManager.lightdm.enable = true;\n  services.xserver.desktopManager.pantheon.enable = true;\n\n\"\"\"\n\ncfgcinnamon = \"\"\"  # Enable the X11 windowing system.\n  services.xserver.enable = true;\n\n  # Enable the Cinnamon Desktop Environment.\n  services.xserver.displayManager.lightdm.enable = true;\n  services.xserver.desktopManager.cinnamon.enable = true;\n\n\"\"\"\n\ncfgmate = \"\"\"  # Enable the X11 windowing system.\n  services.xserver.enable = true;\n\n  # Enable the MATE Desktop Environment.\n  services.xserver.displayManager.lightdm.enable = true;\n  services.xserver.desktopManager.mate.enable = true;\n\n\"\"\"\n\ncfgenlightenment = \"\"\"  # Enable the X11 windowing system.\n  services.xserver.enable = true;\n\n  # Enable the Enlightenment Desktop Environment.\n  services.xserver.displayManager.lightdm.enable = true;\n  services.xserver.desktopManager.enlightenment.enable = true;\n\n  # Enable acpid\n  services.acpid.enable = true;\n\n\"\"\"\n\ncfglxqt = \"\"\"  # Enable the X11 windowing system.\n  services.xserver.enable = true;\n\n  # Enable the LXQT Desktop Environment.\n  services.xserver.displayManager.lightdm.enable = true;\n  services.xserver.desktopManager.lxqt.enable = true;\n\n\"\"\"\n\ncfglumina = \"\"\"  # Enable the X11 windowing system.\n  services.xserver.enable = true;\n\n  # Enable the Lumina Desktop Environment.\n  services.xserver.displayManager.lightdm.enable = true;\n  services.xserver.desktopManager.lumina.enable = true;\n\n\"\"\"\n\ncfgbudgie = \"\"\"  # Enable the X11 windowing system.\n  services.xserver.enable = true;\n\n  # Enable the Budgie Desktop environment.\n  services.xserver.displayManager.lightdm.enable = true;\n  services.xserver.desktopManager.budgie.enable = true;\n\n\"\"\"\n\ncfgkeymap = \"\"\"  # Configure keymap in X11\n  services.xserver = {\n    layout = \"@@kblayout@@\";\n    xkbVariant = \"@@kbvariant@@\";\n  };\n\n\"\"\"\ncfgconsole = \"\"\"  # Configure console keymap\n  console.keyMap = \"@@vconsole@@\";\n\n\"\"\"\n\ncfgmisc = \"\"\"  # Enable CUPS to print documents.\n  services.printing.enable = true;\n\n  # Enable sound with pipewire.\n  sound.enable = true;\n  hardware.pulseaudio.enable = false;\n  security.rtkit.enable = true;\n  services.pipewire = {\n    enable = true;\n    alsa.enable = true;\n    alsa.support32Bit = true;\n    pulse.enable = true;\n    # If you want to use JACK applications, uncomment this\n    #jack.enable = true;\n\n    # use the example session manager (no others are packaged yet so this is enabled by default,\n    # no need to redefine it in your config for now)\n    #media-session.enable = true;\n  };\n\n  # Enable touchpad support (enabled default in most desktopManager).\n  # services.xserver.libinput.enable = true;\n\n\"\"\"\ncfgusers = \"\"\"  # Define a user account. Don't forget to set a password with \u2018passwd\u2019.\n  users.users.@@username@@ = {\n    isNormalUser = true;\n    description = \"@@fullname@@\";\n    extraGroups = [ @@groups@@ ];\n    packages = with pkgs; [@@pkgs@@];\n  };\n\n\"\"\"\n\ncfgautologin = \"\"\"  # Enable automatic login for the user.\n  services.xserver.displayManager.autoLogin.enable = true;\n  services.xserver.displayManager.autoLogin.user = \"@@username@@\";\n\n\"\"\"\n\ncfgautologingdm = \"\"\"  # Workaround for GNOME autologin: https://github.com/NixOS/nixpkgs/issues/103746#issuecomment-945091229\n  systemd.services.\"getty@tty1\".enable = false;\n  systemd.services.\"autovt@tty1\".enable = false;\n\n\"\"\"\n\ncfgautologintty = \"\"\"  # Enable automatic login for the user.\n  services.getty.autologinUser = \"@@username@@\";\n\n\"\"\"\n\ncfgunfree = \"\"\"  # Allow unfree packages\n  nixpkgs.config.allowUnfree = true;\n\n\"\"\"\n\ncfgpkgs = \"\"\"  # List packages installed in system profile. To search, run:\n  # $ nix search wget\n  environment.systemPackages = with pkgs; [\n  #  vim # Do not forget to add an editor to edit configuration.nix! The Nano editor is also installed by default.\n  #  wget\n  ];\n\n\"\"\"\n\ncfgtail = \"\"\"  # Some programs need SUID wrappers, can be configured further or are\n  # started in user sessions.\n  # programs.mtr.enable = true;\n  # programs.gnupg.agent = {\n  #   enable = true;\n  #   enableSSHSupport = true;\n  # };\n\n  # List services that you want to enable:\n\n  # Enable the OpenSSH daemon.\n  # services.openssh.enable = true;\n\n  # Open ports in the firewall.\n  # networking.firewall.allowedTCPPorts = [ ... ];\n  # networking.firewall.allowedUDPPorts = [ ... ];\n  # Or disable the firewall altogether.\n  # networking.firewall.enable = false;\n\n  # This value determines the NixOS release from which the default\n  # settings for stateful data, like file locations and database versions\n  # on your system were taken. It\u2018s perfectly fine and recommended to leave\n  # this value at the release version of the first install of this system.\n  # Before changing this value read the documentation for this option\n  # (e.g. man configuration.nix or on https://nixos.org/nixos/options.html).\n  system.stateVersion = \"@@nixosversion@@\"; # Did you read the comment?\n\n}\n\"\"\"\n\n\ndef pretty_name():\n    return _(\"Installing NixOS.\")\n\n\nstatus = pretty_name()\n\n\ndef pretty_status_message():\n    return status\n\n\ndef catenate(d, key, *values):\n    \"\"\"\n    Sets @p d[key] to the string-concatenation of @p values\n    if none of the values are None.\n    This can be used to set keys conditionally based on\n    the values being found.\n    \"\"\"\n    if [v for v in values if v is None]:\n        return\n\n    d[key] = \"\".join(values)\n\ndef run():\n    \"\"\"NixOS Configuration.\"\"\"\n\n    global status\n    status = _(\"Configuring NixOS\")\n    libcalamares.job.setprogress(0.1)\n\n    # Create initial config file\n    cfg = cfghead\n    gs = libcalamares.globalstorage\n    variables = dict()\n\n    # Setup variables\n    root_mount_point = gs.value(\"rootMountPoint\")\n    config = os.path.join(root_mount_point, \"etc/nixos/configuration.nix\")\n    fw_type = gs.value(\"firmwareType\")\n    bootdev = \"nodev\" if gs.value(\"bootLoader\") is None else gs.value(\n        \"bootLoader\")['installPath']\n\n    # Pick config parts and prepare substitution\n\n    # Check bootloader\n    if (fw_type == \"efi\"):\n        cfg += cfgbootefi\n    elif (bootdev != \"nodev\"):\n        cfg += cfgbootbios\n        catenate(variables, \"bootdev\", bootdev)\n    else:\n        cfg += cfgbootnone\n\n    # Check partitions\n    for part in gs.value(\"partitions\"):\n        if part[\"claimed\"] == True and part[\"fsName\"] == \"luks\":\n            cfg += cfgbootcrypt\n            if fw_type != \"efi\":\n                cfg += cfgbootgrubcrypt\n            status = _(\"Setting up LUKS\")\n            libcalamares.job.setprogress(0.15)\n            try:\n                # Create /crypto_keyfile.bin\n                libcalamares.utils.host_env_process_output(\n                    [\"dd\", \"bs=512\", \"count=4\", \"if=/dev/random\", \"of=\"+root_mount_point+\"/crypto_keyfile.bin\", \"iflag=fullblock\"], None)\n                libcalamares.utils.host_env_process_output(\n                    [\"chmod\", \"600\", root_mount_point+\"/crypto_keyfile.bin\"], None)\n            except subprocess.CalledProcessError:\n                libcalamares.utils.error(\n                    \"Failed to create /crypto_keyfile.bin\")\n                return (_(\"Failed to create /crypto_keyfile.bin\"), _(\"Check if you have enough free space on your partition.\"))\n            break\n\n    # Setup keys in /crypto_keyfile. If we use systemd-boot (EFI), don't add /\n    # Goal is to have one password prompt when booted\n    for part in gs.value(\"partitions\"):\n        if part[\"claimed\"] == True and part[\"fsName\"] == \"luks\" and part[\"device\"] is not None and not (fw_type == \"efi\" and part[\"mountPoint\"] == \"/\"):\n            if part[\"fs\"] == \"linuxswap\":\n                cfg += cfgswapcrypt\n                catenate(variables, \"swapdev\", part[\"luksMapperName\"])\n                uuid = part[\"uuid\"]\n                catenate(variables, \"swapuuid\", uuid)\n            else:\n                cfg += \"\"\"  boot.initrd.luks.devices.\"{}\".keyFile = \"/crypto_keyfile.bin\";\\n\"\"\".format(\n                    part[\"luksMapperName\"])\n\n            try:\n                # Add luks drives to /crypto_keyfile.bin\n                libcalamares.utils.host_env_process_output(\n                    [\"cryptsetup\", \"luksAddKey\", part[\"device\"], root_mount_point+\"/crypto_keyfile.bin\"], None, part[\"luksPassphrase\"])\n            except subprocess.CalledProcessError:\n                libcalamares.utils.error(\n                    \"Failed to add {} to /crypto_keyfile.bin\".format(part[\"luksMapperName\"]))\n                return (_(\"cryptsetup failed\"), _(\"Failed to add {} to /crypto_keyfile.bin\".format(part[\"luksMapperName\"])))\n\n    status = _(\"Configuring NixOS\")\n    libcalamares.job.setprogress(0.18)\n\n    cfg += cfgnetwork\n    if gs.value(\"packagechooser_packagechooser\") == \"enlightenment\":\n        cfg += cfgconnman\n    else:\n        cfg += cfgnetworkmanager\n\n    if (gs.value(\"packagechooser_packagechooser\") == \"mate\") | (gs.value(\"packagechooser_packagechooser\") == \"lxqt\") | (gs.value(\"packagechooser_packagechooser\") == \"lumina\"):\n        cfg += cfgnmapplet\n\n    if (gs.value(\"hostname\") is None):\n        catenate(variables, \"hostname\", \"nixos\")\n    else:\n        catenate(variables, \"hostname\", gs.value(\"hostname\"))\n\n    if (gs.value(\"locationRegion\") is not None and gs.value(\"locationZone\") is not None):\n        cfg += cfgtime\n        catenate(variables, \"timezone\", gs.value(\n            \"locationRegion\"), \"/\", gs.value(\"locationZone\"))\n\n    if (gs.value(\"localeConf\") is not None):\n        localeconf = gs.value(\"localeConf\")\n        locale = localeconf.pop(\"LANG\").split(\"/\")[0]\n        cfg += cfglocale\n        catenate(variables, \"LANG\", locale)\n        if (len(set(localeconf.values())) != 1 or list(set(localeconf.values()))[0] != locale):\n            cfg += cfglocaleextra\n            for conf in localeconf:\n                catenate(variables, conf, localeconf.get(conf).split(\"/\")[0])\n\n    # Choose desktop environment\n    if gs.value(\"packagechooser_packagechooser\") == \"gnome\":\n        cfg += cfggnome\n    elif gs.value(\"packagechooser_packagechooser\") == \"plasma\":\n        cfg += cfgplasma\n    elif gs.value(\"packagechooser_packagechooser\") == \"xfce\":\n        cfg += cfgxfce\n    elif gs.value(\"packagechooser_packagechooser\") == \"pantheon\":\n        cfg += cfgpantheon\n    elif gs.value(\"packagechooser_packagechooser\") == \"cinnamon\":\n        cfg += cfgcinnamon\n    elif gs.value(\"packagechooser_packagechooser\") == \"mate\":\n        cfg += cfgmate\n    elif gs.value(\"packagechooser_packagechooser\") == \"enlightenment\":\n        cfg += cfgenlightenment\n    elif gs.value(\"packagechooser_packagechooser\") == \"lxqt\":\n        cfg += cfglxqt\n    elif gs.value(\"packagechooser_packagechooser\") == \"lumina\":\n        cfg += cfglumina\n    elif gs.value(\"packagechooser_packagechooser\") == \"budgie\":\n        cfg += cfgbudgie\n\n    if (gs.value(\"keyboardLayout\") is not None and gs.value(\"keyboardVariant\") is not None):\n        cfg += cfgkeymap\n        catenate(variables, \"kblayout\", gs.value(\"keyboardLayout\"))\n        catenate(variables, \"kbvariant\", gs.value(\"keyboardVariant\"))\n\n        if (gs.value(\"keyboardVConsoleKeymap\") is not None):\n            try:\n                subprocess.check_output([\"pkexec\", \"loadkeys\", gs.value(\n                    \"keyboardVConsoleKeymap\").strip()], stderr=subprocess.STDOUT)\n                cfg += cfgconsole\n                catenate(variables, \"vconsole\", gs.value(\n                    \"keyboardVConsoleKeymap\").strip())\n            except subprocess.CalledProcessError as e:\n                libcalamares.utils.error(\"loadkeys: {}\".format(e.output))\n                libcalamares.utils.error(\"Setting vconsole keymap to {} will fail, using default\".format(\n                    gs.value(\"keyboardVConsoleKeymap\").strip()))\n        else:\n            kbdmodelmap = open(\n                \"/run/current-system/sw/share/systemd/kbd-model-map\", 'r')\n            kbd = kbdmodelmap.readlines()\n            out = []\n            for line in kbd:\n                if line.startswith(\"#\"):\n                    continue\n                out.append(line.split())\n            # Find rows with same layout\n            find = []\n            for row in out:\n                if gs.value(\"keyboardLayout\") == row[1]:\n                    find.append(row)\n            if find != []:\n                vconsole = find[0][0]\n            else:\n                vconsole = \"\"\n            if gs.value(\"keyboardVariant\") is not None:\n                variant = gs.value(\"keyboardVariant\")\n            else:\n                variant = \"-\"\n            # Find rows with same variant\n            for row in find:\n                if variant in row[3]:\n                    vconsole = row[0]\n                    break\n                # If none found set to \"us\"\n            if vconsole != \"\" and vconsole != \"us\" and vconsole is not None:\n                try:\n                    subprocess.check_output(\n                        [\"pkexec\", \"loadkeys\", vconsole], stderr=subprocess.STDOUT)\n                    cfg += cfgconsole\n                    catenate(variables, \"vconsole\", vconsole)\n                except subprocess.CalledProcessError as e:\n                    libcalamares.utils.error(\"loadkeys: {}\".format(e.output))\n                    libcalamares.utils.error(\n                        \"vconsole value: {}\".format(vconsole))\n                    libcalamares.utils.error(\"Setting vconsole keymap to {} will fail, using default\".format(\n                        gs.value(\"keyboardVConsoleKeymap\")))\n\n    if gs.value(\"packagechooser_packagechooser\") is not None and gs.value(\"packagechooser_packagechooser\") != \"\":\n        cfg += cfgmisc\n\n    if (gs.value(\"username\") is not None):\n        fullname = gs.value(\"fullname\")\n        groups = [\"networkmanager\", \"wheel\"]\n\n        cfg += cfgusers\n        catenate(variables, \"username\", gs.value(\"username\"))\n        catenate(variables, \"fullname\", fullname)\n        catenate(variables, \"groups\", (\" \").join(\n            [\"\\\"\" + s + \"\\\"\" for s in groups]))\n        if (gs.value(\"autoLoginUser\") is not None and gs.value(\"packagechooser_packagechooser\") is not None and gs.value(\"packagechooser_packagechooser\") != \"\"):\n            cfg += cfgautologin\n            if (gs.value(\"packagechooser_packagechooser\") == \"gnome\"):\n                cfg += cfgautologingdm\n        elif (gs.value(\"autoLoginUser\") is not None):\n            cfg += cfgautologintty\n\n    # Check if unfree packages are allowed\n    free = True\n    if gs.value(\"packagechooser_unfree\") is not None:\n        if gs.value(\"packagechooser_unfree\") == \"unfree\":\n            free = False\n            cfg += cfgunfree\n\n    cfg += cfgpkgs\n    # Use firefox as default as a graphical web browser, and add kate to plasma desktop\n    if gs.value(\"packagechooser_packagechooser\") == \"plasma\":\n        catenate(variables, \"pkgs\", \"\\n      firefox\\n      kate\\n    #  thunderbird\\n    \")\n    elif gs.value(\"packagechooser_packagechooser\") != \"\":\n        catenate(variables, \"pkgs\", \"\\n      firefox\\n    #  thunderbird\\n    \")\n    else:\n        catenate(variables, \"pkgs\", \"\")\n\n    cfg += cfgtail\n    version = \".\".join(subprocess.getoutput(\n        [\"nixos-version\"]).split(\".\")[:2])[:5]\n    catenate(variables, \"nixosversion\", version)\n\n    # Check that all variables are used\n    for key in variables.keys():\n        pattern = \"@@{key}@@\".format(key=key)\n        if not pattern in cfg:\n            libcalamares.utils.warning(\n                \"Variable '{key}' is not used.\".format(key=key))\n\n    # Check that all patterns exist\n    variable_pattern = re.compile(\"@@\\w+@@\")\n    for match in variable_pattern.finditer(cfg):\n        variable_name = cfg[match.start()+2:match.end()-2]\n        if not variable_name in variables:\n            libcalamares.utils.warning(\n                \"Variable '{key}' is used but not defined.\".format(key=variable_name))\n\n    # Do the substitutions\n    for key in variables.keys():\n        pattern = \"@@{key}@@\".format(key=key)\n        cfg = cfg.replace(pattern, str(variables[key]))\n\n    # Mount swap partition\n    for part in gs.value(\"partitions\"):\n        if part[\"claimed\"] == True and part[\"fs\"] == \"linuxswap\":\n            status = _(\"Mounting swap\")\n            libcalamares.job.setprogress(0.2)\n            if part[\"fsName\"] == \"luks\":\n                try:\n                    libcalamares.utils.host_env_process_output(\n                        [\"swapon\", \"/dev/mapper/\" + part[\"luksMapperName\"]], None)\n                except subprocess.CalledProcessError:\n                    libcalamares.utils.error(\n                        \"Failed to activate swap: \" + \"/dev/mapper/\" + part[\"luksMapperName\"])\n                    return (_(\"swapon failed to activate swap\"), _(\"failed while activating:\" + \"/dev/mapper/\" + part[\"luksMapperName\"]))\n            else:\n                try:\n                    libcalamares.utils.host_env_process_output(\n                        [\"swapon\", part[\"device\"]], None)\n                except subprocess.CalledProcessError:\n                    libcalamares.utils.error(\n                        \"Failed to activate swap: \" + \"/dev/mapper/\" + part[\"device\"])\n                    return (_(\"swapon failed to activate swap \" + part[\"device\"]), _(\"failed while activating:\" + \"/dev/mapper/\" + part[\"device\"]))\n            break\n\n    status = _(\"Generating NixOS configuration\")\n    libcalamares.job.setprogress(0.25)\n\n    try:\n        # Generate hardware.nix with mounted swap device\n        subprocess.check_output(\n            [\"pkexec\", \"nixos-generate-config\", \"--root\", root_mount_point], stderr=subprocess.STDOUT)\n    except subprocess.CalledProcessError as e:\n        if e.output != None:\n            libcalamares.utils.error(e.output.decode(\"utf8\"))\n        return (_(\"nixos-generate-config failed\"), _(e.output.decode(\"utf8\")))\n\n    # Check for unfree stuff in hardware-configuration.nix\n    hf = open(root_mount_point + \"/etc/nixos/hardware-configuration.nix\", \"r\")\n    htxt = hf.read()\n    search = re.search(\"boot\\.extraModulePackages = \\[ (.*) \\];\", htxt)\n\n    # Check if any extraModulePackages are defined, and remove if only free packages are allowed\n    if search is not None and free:\n        expkgs = search.group(1).split(\" \")\n        for pkg in expkgs:\n            p = \".\".join(pkg.split(\".\")[3:])\n            # Check package p is unfree\n            isunfree = subprocess.check_output([\"nix-instantiate\", \"--eval\", \"--strict\", \"-E\",\n                                               \"with import <nixpkgs> {{}}; pkgs.linuxKernel.packageAliases.linux_default.{}.meta.unfree\".format(p), \"--json\"], stderr=subprocess.STDOUT)\n            if isunfree == b'true':\n                libcalamares.utils.warning(\n                    \"{} is marked as unfree, removing from hardware-configuration.nix\".format(p))\n                expkgs.remove(pkg)\n        hardwareout = re.sub(\n            \"boot\\.extraModulePackages = \\[ (.*) \\];\", \"boot.extraModulePackages = [ {}];\".format(\"\".join(map(lambda x: x+\" \", expkgs))), htxt)\n        # Write the hardware-configuration.nix file\n        libcalamares.utils.host_env_process_output([\"cp\", \"/dev/stdin\",\n                                                    root_mount_point+\"/etc/nixos/hardware-configuration.nix\"], None, hardwareout)\n\n    # Write the configuration.nix file\n    libcalamares.utils.host_env_process_output(\n        [\"cp\", \"/dev/stdin\", config], None, cfg)\n\n    status = _(\"Installing NixOS\")\n    libcalamares.job.setprogress(0.3)\n\n    # Install customizations\n    try:\n        output = \"\"\n        proc = subprocess.Popen([\"pkexec\", \"nixos-install\", \"--no-root-passwd\", \"--root\", root_mount_point], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n        while True:\n            line = proc.stdout.readline().decode(\"utf-8\")\n            output += line\n            libcalamares.utils.debug(\"nixos-install: {}\".format(line.strip()))\n            if not line:\n                break\n        exit = proc.wait()\n        if exit != 0:\n            return (_(\"nixos-install failed\"), _(output))\n    except:\n        return (_(\"nixos-install failed\"), _(\"Installation failed to complete\"))\n\n    return None\n"], "fixing_code": ["#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\n#   SPDX-FileCopyrightText: 2022 Victor Fuentes <vmfuentes64@gmail.com>\n#   SPDX-FileCopyrightText: 2019 Adriaan de Groot <groot@kde.org>\n#   SPDX-License-Identifier: GPL-3.0-or-later\n#\n#   Calamares is Free Software: see the License-Identifier above.\n#\n\nimport libcalamares\nimport os\nimport subprocess\nimport re\n\nimport gettext\n_ = gettext.translation(\"calamares-python\",\n                        localedir=libcalamares.utils.gettext_path(),\n                        languages=libcalamares.utils.gettext_languages(),\n                        fallback=True).gettext\n\n\n# The following strings contain pieces of a nix-configuration file.\n# They are adapted from the default config generated from the nixos-generate-config command.\n\ncfghead = \"\"\"# Edit this configuration file to define what should be installed on\n# your system.  Help is available in the configuration.nix(5) man page\n# and in the NixOS manual (accessible by running \u2018nixos-help\u2019).\n\n{ config, pkgs, ... }:\n\n{\n  imports =\n    [ # Include the results of the hardware scan.\n      ./hardware-configuration.nix\n    ];\n\n\"\"\"\ncfgbootefi = \"\"\"  # Bootloader.\n  boot.loader.systemd-boot.enable = true;\n  boot.loader.efi.canTouchEfiVariables = true;\n\n\"\"\"\n\ncfgbootbios = \"\"\"  # Bootloader.\n  boot.loader.grub.enable = true;\n  boot.loader.grub.device = \"@@bootdev@@\";\n  boot.loader.grub.useOSProber = true;\n\n\"\"\"\n\ncfgbootnone = \"\"\"  # Disable bootloader.\n  boot.loader.grub.enable = false;\n\n\"\"\"\n\ncfgbootgrubcrypt = \"\"\"  # Enable grub cryptodisk\n  boot.loader.grub.enableCryptodisk=true;\n\n\"\"\"\n\ncfgswapcrypt = \"\"\"  # Enable swap on luks\n  boot.initrd.luks.devices.\"@@swapdev@@\".device = \"/dev/disk/by-uuid/@@swapuuid@@\";\n  boot.initrd.luks.devices.\"@@swapdev@@\".keyFile = \"/crypto_keyfile.bin\";\n\n\"\"\"\n\ncfgnetwork = \"\"\"  networking.hostName = \"@@hostname@@\"; # Define your hostname.\n  # networking.wireless.enable = true;  # Enables wireless support via wpa_supplicant.\n\n  # Configure network proxy if necessary\n  # networking.proxy.default = \"http://user:password@proxy:port/\";\n  # networking.proxy.noProxy = \"127.0.0.1,localhost,internal.domain\";\n\n\"\"\"\n\ncfgnetworkmanager = \"\"\"  # Enable networking\n  networking.networkmanager.enable = true;\n\n\"\"\"\n\ncfgconnman = \"\"\"  # Enable networking\n  services.connman.enable = true;\n\n\"\"\"\n\ncfgnmapplet = \"\"\"  # Enable network manager applet\n  programs.nm-applet.enable = true;\n\n\"\"\"\n\ncfgtime = \"\"\"  # Set your time zone.\n  time.timeZone = \"@@timezone@@\";\n\n\"\"\"\n\ncfglocale = \"\"\"  # Select internationalisation properties.\n  i18n.defaultLocale = \"@@LANG@@\";\n\n\"\"\"\n\ncfglocaleextra = \"\"\"  i18n.extraLocaleSettings = {\n    LC_ADDRESS = \"@@LC_ADDRESS@@\";\n    LC_IDENTIFICATION = \"@@LC_IDENTIFICATION@@\";\n    LC_MEASUREMENT = \"@@LC_MEASUREMENT@@\";\n    LC_MONETARY = \"@@LC_MONETARY@@\";\n    LC_NAME = \"@@LC_NAME@@\";\n    LC_NUMERIC = \"@@LC_NUMERIC@@\";\n    LC_PAPER = \"@@LC_PAPER@@\";\n    LC_TELEPHONE = \"@@LC_TELEPHONE@@\";\n    LC_TIME = \"@@LC_TIME@@\";\n  };\n\n\"\"\"\n\ncfggnome = \"\"\"  # Enable the X11 windowing system.\n  services.xserver.enable = true;\n\n  # Enable the GNOME Desktop Environment.\n  services.xserver.displayManager.gdm.enable = true;\n  services.xserver.desktopManager.gnome.enable = true;\n\n\"\"\"\n\ncfgplasma = \"\"\"  # Enable the X11 windowing system.\n  services.xserver.enable = true;\n\n  # Enable the KDE Plasma Desktop Environment.\n  services.xserver.displayManager.sddm.enable = true;\n  services.xserver.desktopManager.plasma5.enable = true;\n\n\"\"\"\n\ncfgxfce = \"\"\"  # Enable the X11 windowing system.\n  services.xserver.enable = true;\n\n  # Enable the XFCE Desktop Environment.\n  services.xserver.displayManager.lightdm.enable = true;\n  services.xserver.desktopManager.xfce.enable = true;\n\n\"\"\"\n\ncfgpantheon = \"\"\"  # Enable the X11 windowing system.\n  services.xserver.enable = true;\n\n  # Enable the Pantheon Desktop Environment.\n  services.xserver.displayManager.lightdm.enable = true;\n  services.xserver.desktopManager.pantheon.enable = true;\n\n\"\"\"\n\ncfgcinnamon = \"\"\"  # Enable the X11 windowing system.\n  services.xserver.enable = true;\n\n  # Enable the Cinnamon Desktop Environment.\n  services.xserver.displayManager.lightdm.enable = true;\n  services.xserver.desktopManager.cinnamon.enable = true;\n\n\"\"\"\n\ncfgmate = \"\"\"  # Enable the X11 windowing system.\n  services.xserver.enable = true;\n\n  # Enable the MATE Desktop Environment.\n  services.xserver.displayManager.lightdm.enable = true;\n  services.xserver.desktopManager.mate.enable = true;\n\n\"\"\"\n\ncfgenlightenment = \"\"\"  # Enable the X11 windowing system.\n  services.xserver.enable = true;\n\n  # Enable the Enlightenment Desktop Environment.\n  services.xserver.displayManager.lightdm.enable = true;\n  services.xserver.desktopManager.enlightenment.enable = true;\n\n  # Enable acpid\n  services.acpid.enable = true;\n\n\"\"\"\n\ncfglxqt = \"\"\"  # Enable the X11 windowing system.\n  services.xserver.enable = true;\n\n  # Enable the LXQT Desktop Environment.\n  services.xserver.displayManager.lightdm.enable = true;\n  services.xserver.desktopManager.lxqt.enable = true;\n\n\"\"\"\n\ncfglumina = \"\"\"  # Enable the X11 windowing system.\n  services.xserver.enable = true;\n\n  # Enable the Lumina Desktop Environment.\n  services.xserver.displayManager.lightdm.enable = true;\n  services.xserver.desktopManager.lumina.enable = true;\n\n\"\"\"\n\ncfgbudgie = \"\"\"  # Enable the X11 windowing system.\n  services.xserver.enable = true;\n\n  # Enable the Budgie Desktop environment.\n  services.xserver.displayManager.lightdm.enable = true;\n  services.xserver.desktopManager.budgie.enable = true;\n\n\"\"\"\n\ncfgkeymap = \"\"\"  # Configure keymap in X11\n  services.xserver = {\n    layout = \"@@kblayout@@\";\n    xkbVariant = \"@@kbvariant@@\";\n  };\n\n\"\"\"\ncfgconsole = \"\"\"  # Configure console keymap\n  console.keyMap = \"@@vconsole@@\";\n\n\"\"\"\n\ncfgmisc = \"\"\"  # Enable CUPS to print documents.\n  services.printing.enable = true;\n\n  # Enable sound with pipewire.\n  sound.enable = true;\n  hardware.pulseaudio.enable = false;\n  security.rtkit.enable = true;\n  services.pipewire = {\n    enable = true;\n    alsa.enable = true;\n    alsa.support32Bit = true;\n    pulse.enable = true;\n    # If you want to use JACK applications, uncomment this\n    #jack.enable = true;\n\n    # use the example session manager (no others are packaged yet so this is enabled by default,\n    # no need to redefine it in your config for now)\n    #media-session.enable = true;\n  };\n\n  # Enable touchpad support (enabled default in most desktopManager).\n  # services.xserver.libinput.enable = true;\n\n\"\"\"\ncfgusers = \"\"\"  # Define a user account. Don't forget to set a password with \u2018passwd\u2019.\n  users.users.@@username@@ = {\n    isNormalUser = true;\n    description = \"@@fullname@@\";\n    extraGroups = [ @@groups@@ ];\n    packages = with pkgs; [@@pkgs@@];\n  };\n\n\"\"\"\n\ncfgautologin = \"\"\"  # Enable automatic login for the user.\n  services.xserver.displayManager.autoLogin.enable = true;\n  services.xserver.displayManager.autoLogin.user = \"@@username@@\";\n\n\"\"\"\n\ncfgautologingdm = \"\"\"  # Workaround for GNOME autologin: https://github.com/NixOS/nixpkgs/issues/103746#issuecomment-945091229\n  systemd.services.\"getty@tty1\".enable = false;\n  systemd.services.\"autovt@tty1\".enable = false;\n\n\"\"\"\n\ncfgautologintty = \"\"\"  # Enable automatic login for the user.\n  services.getty.autologinUser = \"@@username@@\";\n\n\"\"\"\n\ncfgunfree = \"\"\"  # Allow unfree packages\n  nixpkgs.config.allowUnfree = true;\n\n\"\"\"\n\ncfgpkgs = \"\"\"  # List packages installed in system profile. To search, run:\n  # $ nix search wget\n  environment.systemPackages = with pkgs; [\n  #  vim # Do not forget to add an editor to edit configuration.nix! The Nano editor is also installed by default.\n  #  wget\n  ];\n\n\"\"\"\n\ncfgtail = \"\"\"  # Some programs need SUID wrappers, can be configured further or are\n  # started in user sessions.\n  # programs.mtr.enable = true;\n  # programs.gnupg.agent = {\n  #   enable = true;\n  #   enableSSHSupport = true;\n  # };\n\n  # List services that you want to enable:\n\n  # Enable the OpenSSH daemon.\n  # services.openssh.enable = true;\n\n  # Open ports in the firewall.\n  # networking.firewall.allowedTCPPorts = [ ... ];\n  # networking.firewall.allowedUDPPorts = [ ... ];\n  # Or disable the firewall altogether.\n  # networking.firewall.enable = false;\n\n  # This value determines the NixOS release from which the default\n  # settings for stateful data, like file locations and database versions\n  # on your system were taken. It\u2018s perfectly fine and recommended to leave\n  # this value at the release version of the first install of this system.\n  # Before changing this value read the documentation for this option\n  # (e.g. man configuration.nix or on https://nixos.org/nixos/options.html).\n  system.stateVersion = \"@@nixosversion@@\"; # Did you read the comment?\n\n}\n\"\"\"\n\n\ndef pretty_name():\n    return _(\"Installing NixOS.\")\n\n\nstatus = pretty_name()\n\n\ndef pretty_status_message():\n    return status\n\n\ndef catenate(d, key, *values):\n    \"\"\"\n    Sets @p d[key] to the string-concatenation of @p values\n    if none of the values are None.\n    This can be used to set keys conditionally based on\n    the values being found.\n    \"\"\"\n    if [v for v in values if v is None]:\n        return\n\n    d[key] = \"\".join(values)\n\ndef run():\n    \"\"\"NixOS Configuration.\"\"\"\n\n    global status\n    status = _(\"Configuring NixOS\")\n    libcalamares.job.setprogress(0.1)\n\n    # Create initial config file\n    cfg = cfghead\n    gs = libcalamares.globalstorage\n    variables = dict()\n\n    # Setup variables\n    root_mount_point = gs.value(\"rootMountPoint\")\n    config = os.path.join(root_mount_point, \"etc/nixos/configuration.nix\")\n    fw_type = gs.value(\"firmwareType\")\n    bootdev = \"nodev\" if gs.value(\"bootLoader\") is None else gs.value(\n        \"bootLoader\")['installPath']\n\n    # Pick config parts and prepare substitution\n\n    # Check bootloader\n    if (fw_type == \"efi\"):\n        cfg += cfgbootefi\n    elif (bootdev != \"nodev\"):\n        cfg += cfgbootbios\n        catenate(variables, \"bootdev\", bootdev)\n    else:\n        cfg += cfgbootnone\n\n    # Check partitions\n    for part in gs.value(\"partitions\"):\n        if part[\"claimed\"] == True and part[\"fsName\"] == \"luks\":\n            if fw_type != \"efi\":\n                cfg += cfgbootgrubcrypt\n            status = _(\"Setting up LUKS\")\n            libcalamares.job.setprogress(0.15)\n            try:\n                # Create /crypto_keyfile.bin\n                libcalamares.utils.host_env_process_output(\n                    [\"dd\", \"bs=512\", \"count=4\", \"if=/dev/random\", \"of=\"+root_mount_point+\"/crypto_keyfile.bin\", \"iflag=fullblock\"], None)\n                libcalamares.utils.host_env_process_output(\n                    [\"chmod\", \"600\", root_mount_point+\"/crypto_keyfile.bin\"], None)\n            except subprocess.CalledProcessError:\n                libcalamares.utils.error(\n                    \"Failed to create /crypto_keyfile.bin\")\n                return (_(\"Failed to create /crypto_keyfile.bin\"), _(\"Check if you have enough free space on your partition.\"))\n            break\n\n    # Setup keys in /crypto_keyfile. Don't add rootfs!\n    for part in gs.value(\"partitions\"):\n        if part[\"claimed\"] == True and part[\"fsName\"] == \"luks\" and part[\"device\"] is not None and not part[\"mountPoint\"] == \"/\":\n            if part[\"fs\"] == \"linuxswap\":\n                cfg += cfgswapcrypt\n                catenate(variables, \"swapdev\", part[\"luksMapperName\"])\n                uuid = part[\"uuid\"]\n                catenate(variables, \"swapuuid\", uuid)\n            else:\n                cfg += \"\"\"  boot.initrd.luks.devices.\"{}\".keyFile = \"/crypto_keyfile.bin\";\\n\"\"\".format(\n                    part[\"luksMapperName\"])\n\n            try:\n                # Add luks drives to /crypto_keyfile.bin\n                libcalamares.utils.host_env_process_output(\n                    [\"cryptsetup\", \"luksAddKey\", part[\"device\"], root_mount_point+\"/crypto_keyfile.bin\"], None, part[\"luksPassphrase\"])\n            except subprocess.CalledProcessError:\n                libcalamares.utils.error(\n                    \"Failed to add {} to /crypto_keyfile.bin\".format(part[\"luksMapperName\"]))\n                return (_(\"cryptsetup failed\"), _(\"Failed to add {} to /crypto_keyfile.bin\".format(part[\"luksMapperName\"])))\n\n    status = _(\"Configuring NixOS\")\n    libcalamares.job.setprogress(0.18)\n\n    cfg += cfgnetwork\n    if gs.value(\"packagechooser_packagechooser\") == \"enlightenment\":\n        cfg += cfgconnman\n    else:\n        cfg += cfgnetworkmanager\n\n    if (gs.value(\"packagechooser_packagechooser\") == \"mate\") | (gs.value(\"packagechooser_packagechooser\") == \"lxqt\") | (gs.value(\"packagechooser_packagechooser\") == \"lumina\"):\n        cfg += cfgnmapplet\n\n    if (gs.value(\"hostname\") is None):\n        catenate(variables, \"hostname\", \"nixos\")\n    else:\n        catenate(variables, \"hostname\", gs.value(\"hostname\"))\n\n    if (gs.value(\"locationRegion\") is not None and gs.value(\"locationZone\") is not None):\n        cfg += cfgtime\n        catenate(variables, \"timezone\", gs.value(\n            \"locationRegion\"), \"/\", gs.value(\"locationZone\"))\n\n    if (gs.value(\"localeConf\") is not None):\n        localeconf = gs.value(\"localeConf\")\n        locale = localeconf.pop(\"LANG\").split(\"/\")[0]\n        cfg += cfglocale\n        catenate(variables, \"LANG\", locale)\n        if (len(set(localeconf.values())) != 1 or list(set(localeconf.values()))[0] != locale):\n            cfg += cfglocaleextra\n            for conf in localeconf:\n                catenate(variables, conf, localeconf.get(conf).split(\"/\")[0])\n\n    # Choose desktop environment\n    if gs.value(\"packagechooser_packagechooser\") == \"gnome\":\n        cfg += cfggnome\n    elif gs.value(\"packagechooser_packagechooser\") == \"plasma\":\n        cfg += cfgplasma\n    elif gs.value(\"packagechooser_packagechooser\") == \"xfce\":\n        cfg += cfgxfce\n    elif gs.value(\"packagechooser_packagechooser\") == \"pantheon\":\n        cfg += cfgpantheon\n    elif gs.value(\"packagechooser_packagechooser\") == \"cinnamon\":\n        cfg += cfgcinnamon\n    elif gs.value(\"packagechooser_packagechooser\") == \"mate\":\n        cfg += cfgmate\n    elif gs.value(\"packagechooser_packagechooser\") == \"enlightenment\":\n        cfg += cfgenlightenment\n    elif gs.value(\"packagechooser_packagechooser\") == \"lxqt\":\n        cfg += cfglxqt\n    elif gs.value(\"packagechooser_packagechooser\") == \"lumina\":\n        cfg += cfglumina\n    elif gs.value(\"packagechooser_packagechooser\") == \"budgie\":\n        cfg += cfgbudgie\n\n    if (gs.value(\"keyboardLayout\") is not None and gs.value(\"keyboardVariant\") is not None):\n        cfg += cfgkeymap\n        catenate(variables, \"kblayout\", gs.value(\"keyboardLayout\"))\n        catenate(variables, \"kbvariant\", gs.value(\"keyboardVariant\"))\n\n        if (gs.value(\"keyboardVConsoleKeymap\") is not None):\n            try:\n                subprocess.check_output([\"pkexec\", \"loadkeys\", gs.value(\n                    \"keyboardVConsoleKeymap\").strip()], stderr=subprocess.STDOUT)\n                cfg += cfgconsole\n                catenate(variables, \"vconsole\", gs.value(\n                    \"keyboardVConsoleKeymap\").strip())\n            except subprocess.CalledProcessError as e:\n                libcalamares.utils.error(\"loadkeys: {}\".format(e.output))\n                libcalamares.utils.error(\"Setting vconsole keymap to {} will fail, using default\".format(\n                    gs.value(\"keyboardVConsoleKeymap\").strip()))\n        else:\n            kbdmodelmap = open(\n                \"/run/current-system/sw/share/systemd/kbd-model-map\", 'r')\n            kbd = kbdmodelmap.readlines()\n            out = []\n            for line in kbd:\n                if line.startswith(\"#\"):\n                    continue\n                out.append(line.split())\n            # Find rows with same layout\n            find = []\n            for row in out:\n                if gs.value(\"keyboardLayout\") == row[1]:\n                    find.append(row)\n            if find != []:\n                vconsole = find[0][0]\n            else:\n                vconsole = \"\"\n            if gs.value(\"keyboardVariant\") is not None:\n                variant = gs.value(\"keyboardVariant\")\n            else:\n                variant = \"-\"\n            # Find rows with same variant\n            for row in find:\n                if variant in row[3]:\n                    vconsole = row[0]\n                    break\n                # If none found set to \"us\"\n            if vconsole != \"\" and vconsole != \"us\" and vconsole is not None:\n                try:\n                    subprocess.check_output(\n                        [\"pkexec\", \"loadkeys\", vconsole], stderr=subprocess.STDOUT)\n                    cfg += cfgconsole\n                    catenate(variables, \"vconsole\", vconsole)\n                except subprocess.CalledProcessError as e:\n                    libcalamares.utils.error(\"loadkeys: {}\".format(e.output))\n                    libcalamares.utils.error(\n                        \"vconsole value: {}\".format(vconsole))\n                    libcalamares.utils.error(\"Setting vconsole keymap to {} will fail, using default\".format(\n                        gs.value(\"keyboardVConsoleKeymap\")))\n\n    if gs.value(\"packagechooser_packagechooser\") is not None and gs.value(\"packagechooser_packagechooser\") != \"\":\n        cfg += cfgmisc\n\n    if (gs.value(\"username\") is not None):\n        fullname = gs.value(\"fullname\")\n        groups = [\"networkmanager\", \"wheel\"]\n\n        cfg += cfgusers\n        catenate(variables, \"username\", gs.value(\"username\"))\n        catenate(variables, \"fullname\", fullname)\n        catenate(variables, \"groups\", (\" \").join(\n            [\"\\\"\" + s + \"\\\"\" for s in groups]))\n        if (gs.value(\"autoLoginUser\") is not None and gs.value(\"packagechooser_packagechooser\") is not None and gs.value(\"packagechooser_packagechooser\") != \"\"):\n            cfg += cfgautologin\n            if (gs.value(\"packagechooser_packagechooser\") == \"gnome\"):\n                cfg += cfgautologingdm\n        elif (gs.value(\"autoLoginUser\") is not None):\n            cfg += cfgautologintty\n\n    # Check if unfree packages are allowed\n    free = True\n    if gs.value(\"packagechooser_unfree\") is not None:\n        if gs.value(\"packagechooser_unfree\") == \"unfree\":\n            free = False\n            cfg += cfgunfree\n\n    cfg += cfgpkgs\n    # Use firefox as default as a graphical web browser, and add kate to plasma desktop\n    if gs.value(\"packagechooser_packagechooser\") == \"plasma\":\n        catenate(variables, \"pkgs\", \"\\n      firefox\\n      kate\\n    #  thunderbird\\n    \")\n    elif gs.value(\"packagechooser_packagechooser\") != \"\":\n        catenate(variables, \"pkgs\", \"\\n      firefox\\n    #  thunderbird\\n    \")\n    else:\n        catenate(variables, \"pkgs\", \"\")\n\n    cfg += cfgtail\n    version = \".\".join(subprocess.getoutput(\n        [\"nixos-version\"]).split(\".\")[:2])[:5]\n    catenate(variables, \"nixosversion\", version)\n\n    # Check that all variables are used\n    for key in variables.keys():\n        pattern = \"@@{key}@@\".format(key=key)\n        if not pattern in cfg:\n            libcalamares.utils.warning(\n                \"Variable '{key}' is not used.\".format(key=key))\n\n    # Check that all patterns exist\n    variable_pattern = re.compile(\"@@\\w+@@\")\n    for match in variable_pattern.finditer(cfg):\n        variable_name = cfg[match.start()+2:match.end()-2]\n        if not variable_name in variables:\n            libcalamares.utils.warning(\n                \"Variable '{key}' is used but not defined.\".format(key=variable_name))\n\n    # Do the substitutions\n    for key in variables.keys():\n        pattern = \"@@{key}@@\".format(key=key)\n        cfg = cfg.replace(pattern, str(variables[key]))\n\n    # Mount swap partition\n    for part in gs.value(\"partitions\"):\n        if part[\"claimed\"] == True and part[\"fs\"] == \"linuxswap\":\n            status = _(\"Mounting swap\")\n            libcalamares.job.setprogress(0.2)\n            if part[\"fsName\"] == \"luks\":\n                try:\n                    libcalamares.utils.host_env_process_output(\n                        [\"swapon\", \"/dev/mapper/\" + part[\"luksMapperName\"]], None)\n                except subprocess.CalledProcessError:\n                    libcalamares.utils.error(\n                        \"Failed to activate swap: \" + \"/dev/mapper/\" + part[\"luksMapperName\"])\n                    return (_(\"swapon failed to activate swap\"), _(\"failed while activating:\" + \"/dev/mapper/\" + part[\"luksMapperName\"]))\n            else:\n                try:\n                    libcalamares.utils.host_env_process_output(\n                        [\"swapon\", part[\"device\"]], None)\n                except subprocess.CalledProcessError:\n                    libcalamares.utils.error(\n                        \"Failed to activate swap: \" + \"/dev/mapper/\" + part[\"device\"])\n                    return (_(\"swapon failed to activate swap \" + part[\"device\"]), _(\"failed while activating:\" + \"/dev/mapper/\" + part[\"device\"]))\n            break\n\n    status = _(\"Generating NixOS configuration\")\n    libcalamares.job.setprogress(0.25)\n\n    try:\n        # Generate hardware.nix with mounted swap device\n        subprocess.check_output(\n            [\"pkexec\", \"nixos-generate-config\", \"--root\", root_mount_point], stderr=subprocess.STDOUT)\n    except subprocess.CalledProcessError as e:\n        if e.output != None:\n            libcalamares.utils.error(e.output.decode(\"utf8\"))\n        return (_(\"nixos-generate-config failed\"), _(e.output.decode(\"utf8\")))\n\n    # Check for unfree stuff in hardware-configuration.nix\n    hf = open(root_mount_point + \"/etc/nixos/hardware-configuration.nix\", \"r\")\n    htxt = hf.read()\n    search = re.search(\"boot\\.extraModulePackages = \\[ (.*) \\];\", htxt)\n\n    # Check if any extraModulePackages are defined, and remove if only free packages are allowed\n    if search is not None and free:\n        expkgs = search.group(1).split(\" \")\n        for pkg in expkgs:\n            p = \".\".join(pkg.split(\".\")[3:])\n            # Check package p is unfree\n            isunfree = subprocess.check_output([\"nix-instantiate\", \"--eval\", \"--strict\", \"-E\",\n                                               \"with import <nixpkgs> {{}}; pkgs.linuxKernel.packageAliases.linux_default.{}.meta.unfree\".format(p), \"--json\"], stderr=subprocess.STDOUT)\n            if isunfree == b'true':\n                libcalamares.utils.warning(\n                    \"{} is marked as unfree, removing from hardware-configuration.nix\".format(p))\n                expkgs.remove(pkg)\n        hardwareout = re.sub(\n            \"boot\\.extraModulePackages = \\[ (.*) \\];\", \"boot.extraModulePackages = [ {}];\".format(\"\".join(map(lambda x: x+\" \", expkgs))), htxt)\n        # Write the hardware-configuration.nix file\n        libcalamares.utils.host_env_process_output([\"cp\", \"/dev/stdin\",\n                                                    root_mount_point+\"/etc/nixos/hardware-configuration.nix\"], None, hardwareout)\n\n    # Write the configuration.nix file\n    libcalamares.utils.host_env_process_output(\n        [\"cp\", \"/dev/stdin\", config], None, cfg)\n\n    status = _(\"Installing NixOS\")\n    libcalamares.job.setprogress(0.3)\n\n    # Install customizations\n    try:\n        output = \"\"\n        proc = subprocess.Popen([\"pkexec\", \"nixos-install\", \"--no-root-passwd\", \"--root\", root_mount_point], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n        while True:\n            line = proc.stdout.readline().decode(\"utf-8\")\n            output += line\n            libcalamares.utils.debug(\"nixos-install: {}\".format(line.strip()))\n            if not line:\n                break\n        exit = proc.wait()\n        if exit != 0:\n            return (_(\"nixos-install failed\"), _(output))\n    except:\n        return (_(\"nixos-install failed\"), _(\"Installation failed to complete\"))\n\n    return None\n"], "filenames": ["modules/nixos/main.py"], "buggy_code_start_loc": [54], "buggy_code_end_loc": [401], "fixing_code_start_loc": [53], "fixing_code_end_loc": [392], "type": "CWE-522", "message": "calamares-nixos-extensions provides Calamares branding and modules for NixOS, a distribution of GNU/Linux. Users of calamares-nixos-extensions version 0.3.12 and prior who installed NixOS through the graphical calamares installer, with an unencrypted `/boot`, on either non-UEFI systems or with a LUKS partition different from `/` have their LUKS key file in `/boot` as a plaintext CPIO archive attached to their NixOS initrd. A patch is available and anticipated to be part of version 0.3.13 to backport to NixOS 22.11, 23.05, and unstable channels. Expert users who have a copy of their data may, as a workaround, re-encrypt the LUKS partition(s) themselves.", "other": {"cve": {"id": "CVE-2023-36476", "sourceIdentifier": "security-advisories@github.com", "published": "2023-06-29T01:15:51.267", "lastModified": "2023-07-07T17:51:22.317", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "calamares-nixos-extensions provides Calamares branding and modules for NixOS, a distribution of GNU/Linux. Users of calamares-nixos-extensions version 0.3.12 and prior who installed NixOS through the graphical calamares installer, with an unencrypted `/boot`, on either non-UEFI systems or with a LUKS partition different from `/` have their LUKS key file in `/boot` as a plaintext CPIO archive attached to their NixOS initrd. A patch is available and anticipated to be part of version 0.3.13 to backport to NixOS 22.11, 23.05, and unstable channels. Expert users who have a copy of their data may, as a workaround, re-encrypt the LUKS partition(s) themselves."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:C/C:H/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 7.9, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.5, "impactScore": 4.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-522"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nixos:calamares-nixos-extensions:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.3.13", "matchCriteriaId": "9F137430-7CE8-4856-AF49-A86837F31011"}]}]}], "references": [{"url": "https://github.com/NixOS/calamares-nixos-extensions/security/advisories/GHSA-3rvf-24q2-24ww", "source": "security-advisories@github.com", "tags": ["Mitigation", "Vendor Advisory"]}, {"url": "https://github.com/osresearch/heads/issues/1348", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking"]}, {"url": "https://github.com/vlinkz/calamares-nixos-extensions/commit/837ca4da5521a74d3b5ca6f7b88890a6713faa22", "source": "security-advisories@github.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/vlinkz/calamares-nixos-extensions/commit/837ca4da5521a74d3b5ca6f7b88890a6713faa22"}}