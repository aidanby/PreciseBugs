{"buggy_code": ["/*\n * Copyright (C) 2015 bspkrs\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy,\n * modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO\n * THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\npackage bspkrs.mmv;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.security.DigestException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport bspkrs.mmv.gui.MappingGui;\n\npublic class RemoteZipHandler\n{\n    private final URL    zipUrl;\n    private final URL    digestUrl;\n    private final File   localDir;\n    private final String digestType;\n    private final String zipFileName;\n\n    public RemoteZipHandler(String urlString, File dir, String digestType) throws MalformedURLException\n    {\n        zipUrl = new URL(urlString);\n        if (digestType != null)\n            digestUrl = new URL(urlString + \".\" + digestType.toLowerCase());\n        else\n            digestUrl = null;\n        String[] tokens = urlString.split(\"/\");\n        zipFileName = tokens[tokens.length - 1];\n        localDir = dir;\n        this.digestType = digestType;\n    }\n\n    public void checkRemoteZip() throws IOException, NoSuchAlgorithmException, DigestException\n    {\n        // fetch zip file sha1\n        boolean fetchZip = true;\n        String remoteHash = null;\n        File digestFile = null;\n        if (digestType != null)\n        {\n            // check hash against local hash if exists\n            remoteHash = loadTextFromURL(digestUrl, new String[] { \"\" })[0];\n            if (!remoteHash.isEmpty())\n            {\n                digestFile = new File(localDir, zipFileName + \".\" + digestType.toLowerCase());\n\n                // if local digest exists and hashes match skip getting the zip file\n                if (digestFile.exists())\n                {\n                    String existingHash = loadTextFromFile(digestFile, new String[] { \"\" })[0];\n                    if (!existingHash.isEmpty() && remoteHash.equals(existingHash))\n                        fetchZip = false;\n                }\n            }\n        }\n\n        if (fetchZip)\n        {\n            // download zip\n            File localZip = new File(localDir, zipFileName);\n            if (localZip.exists())\n                localZip.delete();\n            OutputStream output = new FileOutputStream(localZip);\n            try\n            {\n                URLConnection uc = zipUrl.openConnection();\n                uc.addRequestProperty(\"User-Agent\", \"MMV/\" + MappingGui.VERSION_NUMBER);\n                byte[] buffer = new byte[1024]; // Or whatever\n                int bytesRead;\n                try (InputStream is = uc.getInputStream())\n                {\n                    while ((bytesRead = is.read(buffer)) > 0)\n                        output.write(buffer, 0, bytesRead);\n                }\n            }\n            finally\n            {\n                output.close();\n            }\n\n            // Check hash of downloaded file to ensure we received it correctly\n            if (digestType != null && !remoteHash.isEmpty())\n            {\n                String downloadHash = getFileDigest(new FileInputStream(localZip), digestType);\n                if (!remoteHash.equals(downloadHash))\n                    throw new java.security.DigestException(\"Remote digest does not match digest of downloaded file!\");\n            }\n\n            // extract zip file\n            extractZip(localZip, localDir);\n            if (localZip.exists())\n                localZip.delete();\n\n            // save new hash after successful extract\n            if (digestType != null && !remoteHash.isEmpty())\n            {\n                if (digestFile.exists())\n                    digestFile.delete();\n                digestFile.createNewFile();\n                PrintWriter out = new PrintWriter(new FileWriter(digestFile));\n                out.print(remoteHash);\n                out.close();\n            }\n        }\n    }\n\n    public static String[] loadTextFromURL(URL url, String[] defaultValue)\n    {\n        List<String> arraylist = new ArrayList<String>();\n        Scanner scanner = null;\n        try\n        {\n            URLConnection uc = url.openConnection();\n            uc.addRequestProperty(\"User-Agent\", \"MMV/\" + MappingGui.VERSION_NUMBER);\n            InputStream is = uc.getInputStream();\n            scanner = new Scanner(is, \"UTF-8\");\n\n            while (scanner.hasNextLine())\n            {\n                arraylist.add(scanner.nextLine());\n            }\n        }\n        catch (Throwable e)\n        {\n            return defaultValue;\n        }\n        finally\n        {\n            if (scanner != null)\n                scanner.close();\n        }\n        return arraylist.toArray(new String[arraylist.size()]);\n    }\n\n    public static String[] loadTextFromFile(File file, String[] defaultValue)\n    {\n        ArrayList<String> lines = new ArrayList<String>();\n\n        Scanner scanner = null;\n        try\n        {\n            scanner = new Scanner(file);\n            while (scanner.hasNextLine())\n                lines.add(scanner.nextLine());\n        }\n        catch (FileNotFoundException e)\n        {\n            return defaultValue;\n        }\n        finally\n        {\n            if (scanner != null)\n                scanner.close();\n        }\n\n        return lines.toArray(new String[lines.size()]);\n    }\n\n    public static String getFileDigest(InputStream is, String digestType) throws NoSuchAlgorithmException, IOException\n    {\n        MessageDigest md = MessageDigest.getInstance(digestType);\n        byte[] dataBytes = new byte[1024];\n\n        int nread = 0;\n\n        while ((nread = is.read(dataBytes)) != -1)\n            md.update(dataBytes, 0, nread);\n\n        is.close();\n\n        byte[] mdbytes = md.digest();\n\n        //convert the byte to hex format\n        StringBuffer sb = new StringBuffer(\"\");\n        for (int i = 0; i < mdbytes.length; i++)\n            sb.append(Integer.toString((mdbytes[i] & 0xff) + 0x100, 16).substring(1));\n        return sb.toString();\n    }\n\n    public static void extractZip(File zipFile, File destDir) throws IOException\n    {\n        byte[] buffer = new byte[1024];\n        if (!destDir.exists())\n            destDir.mkdirs();\n\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile));\n        ZipEntry ze = zis.getNextEntry();\n        try\n        {\n            while (ze != null)\n            {\n                String fileName = ze.getName();\n                File newFile = new File(destDir, fileName);\n                if (ze.isDirectory())\n                {\n                    if (newFile.exists())\n                        deleteDirAndContents(newFile);\n                    newFile.mkdirs();\n                }\n                else\n                {\n                    if (newFile.exists())\n                        newFile.delete();\n                    if (newFile.getParentFile() != null && !newFile.getParentFile().exists())\n                        newFile.getParentFile().mkdirs();\n                    FileOutputStream fos = new FileOutputStream(newFile);\n                    int len;\n                    while ((len = zis.read(buffer)) > 0)\n                        fos.write(buffer, 0, len);\n\n                    fos.close();\n                }\n                ze = zis.getNextEntry();\n            }\n        }\n        finally\n        {\n            zis.closeEntry();\n            zis.close();\n        }\n    }\n\n    public static boolean deleteDirAndContents(File dir)\n    {\n        if (dir.isDirectory())\n        {\n            String[] children = dir.list();\n            for (int i = 0; i < children.length; i++)\n            {\n                boolean success = deleteDirAndContents(new File(dir, children[i]));\n                if (!success)\n                    return false;\n            }\n        }\n        return dir.delete();\n    }\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2015 bspkrs\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy,\n * modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO\n * THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\npackage bspkrs.mmv;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.security.DigestException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport bspkrs.mmv.gui.MappingGui;\n\npublic class RemoteZipHandler\n{\n    private final URL    zipUrl;\n    private final URL    digestUrl;\n    private final File   localDir;\n    private final String digestType;\n    private final String zipFileName;\n\n    public RemoteZipHandler(String urlString, File dir, String digestType) throws MalformedURLException\n    {\n        zipUrl = new URL(urlString);\n        if (digestType != null)\n            digestUrl = new URL(urlString + \".\" + digestType.toLowerCase());\n        else\n            digestUrl = null;\n        String[] tokens = urlString.split(\"/\");\n        zipFileName = tokens[tokens.length - 1];\n        localDir = dir;\n        this.digestType = digestType;\n    }\n\n    public void checkRemoteZip() throws IOException, NoSuchAlgorithmException, DigestException\n    {\n        // fetch zip file sha1\n        boolean fetchZip = true;\n        String remoteHash = null;\n        File digestFile = null;\n        if (digestType != null)\n        {\n            // check hash against local hash if exists\n            remoteHash = loadTextFromURL(digestUrl, new String[] { \"\" })[0];\n            if (!remoteHash.isEmpty())\n            {\n                digestFile = new File(localDir, zipFileName + \".\" + digestType.toLowerCase());\n\n                // if local digest exists and hashes match skip getting the zip file\n                if (digestFile.exists())\n                {\n                    String existingHash = loadTextFromFile(digestFile, new String[] { \"\" })[0];\n                    if (!existingHash.isEmpty() && remoteHash.equals(existingHash))\n                        fetchZip = false;\n                }\n            }\n        }\n\n        if (fetchZip)\n        {\n            // download zip\n            File localZip = new File(localDir, zipFileName);\n            if (localZip.exists())\n                localZip.delete();\n            OutputStream output = new FileOutputStream(localZip);\n            try\n            {\n                URLConnection uc = zipUrl.openConnection();\n                uc.addRequestProperty(\"User-Agent\", \"MMV/\" + MappingGui.VERSION_NUMBER);\n                byte[] buffer = new byte[1024]; // Or whatever\n                int bytesRead;\n                try (InputStream is = uc.getInputStream())\n                {\n                    while ((bytesRead = is.read(buffer)) > 0)\n                        output.write(buffer, 0, bytesRead);\n                }\n            }\n            finally\n            {\n                output.close();\n            }\n\n            // Check hash of downloaded file to ensure we received it correctly\n            if (digestType != null && !remoteHash.isEmpty())\n            {\n                String downloadHash = getFileDigest(new FileInputStream(localZip), digestType);\n                if (!remoteHash.equals(downloadHash))\n                    throw new java.security.DigestException(\"Remote digest does not match digest of downloaded file!\");\n            }\n\n            // extract zip file\n            extractZip(localZip, localDir);\n            if (localZip.exists())\n                localZip.delete();\n\n            // save new hash after successful extract\n            if (digestType != null && !remoteHash.isEmpty())\n            {\n                if (digestFile.exists())\n                    digestFile.delete();\n                digestFile.createNewFile();\n                PrintWriter out = new PrintWriter(new FileWriter(digestFile));\n                out.print(remoteHash);\n                out.close();\n            }\n        }\n    }\n\n    public static String[] loadTextFromURL(URL url, String[] defaultValue)\n    {\n        List<String> arraylist = new ArrayList<String>();\n        Scanner scanner = null;\n        try\n        {\n            URLConnection uc = url.openConnection();\n            uc.addRequestProperty(\"User-Agent\", \"MMV/\" + MappingGui.VERSION_NUMBER);\n            InputStream is = uc.getInputStream();\n            scanner = new Scanner(is, \"UTF-8\");\n\n            while (scanner.hasNextLine())\n            {\n                arraylist.add(scanner.nextLine());\n            }\n        }\n        catch (Throwable e)\n        {\n            return defaultValue;\n        }\n        finally\n        {\n            if (scanner != null)\n                scanner.close();\n        }\n        return arraylist.toArray(new String[arraylist.size()]);\n    }\n\n    public static String[] loadTextFromFile(File file, String[] defaultValue)\n    {\n        ArrayList<String> lines = new ArrayList<String>();\n\n        Scanner scanner = null;\n        try\n        {\n            scanner = new Scanner(file);\n            while (scanner.hasNextLine())\n                lines.add(scanner.nextLine());\n        }\n        catch (FileNotFoundException e)\n        {\n            return defaultValue;\n        }\n        finally\n        {\n            if (scanner != null)\n                scanner.close();\n        }\n\n        return lines.toArray(new String[lines.size()]);\n    }\n\n    public static String getFileDigest(InputStream is, String digestType) throws NoSuchAlgorithmException, IOException\n    {\n        MessageDigest md = MessageDigest.getInstance(digestType);\n        byte[] dataBytes = new byte[1024];\n\n        int nread = 0;\n\n        while ((nread = is.read(dataBytes)) != -1)\n            md.update(dataBytes, 0, nread);\n\n        is.close();\n\n        byte[] mdbytes = md.digest();\n\n        //convert the byte to hex format\n        StringBuffer sb = new StringBuffer(\"\");\n        for (int i = 0; i < mdbytes.length; i++)\n            sb.append(Integer.toString((mdbytes[i] & 0xff) + 0x100, 16).substring(1));\n        return sb.toString();\n    }\n\n    public static void extractZip(File zipFile, File destDir) throws IOException\n    {\n        byte[] buffer = new byte[1024];\n        if (!destDir.exists())\n            destDir.mkdirs();\n\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile));\n        ZipEntry ze = zis.getNextEntry();\n        try\n        {\n            while (ze != null)\n            {\n                String fileName = ze.getName();\n                File newFile = new File(destDir, fileName);\n                if (!newFile.toPath().normalize().startsWith(destDir.toPath().normalize())) {\n                    throw new IOException(\"Bad zip entry\");\n                }\n                if (ze.isDirectory())\n                {\n                    if (newFile.exists())\n                        deleteDirAndContents(newFile);\n                    newFile.mkdirs();\n                }\n                else\n                {\n                    if (newFile.exists())\n                        newFile.delete();\n                    if (newFile.getParentFile() != null && !newFile.getParentFile().exists())\n                        newFile.getParentFile().mkdirs();\n                    FileOutputStream fos = new FileOutputStream(newFile);\n                    int len;\n                    while ((len = zis.read(buffer)) > 0)\n                        fos.write(buffer, 0, len);\n\n                    fos.close();\n                }\n                ze = zis.getNextEntry();\n            }\n        }\n        finally\n        {\n            zis.closeEntry();\n            zis.close();\n        }\n    }\n\n    public static boolean deleteDirAndContents(File dir)\n    {\n        if (dir.isDirectory())\n        {\n            String[] children = dir.list();\n            for (int i = 0; i < children.length; i++)\n            {\n                boolean success = deleteDirAndContents(new File(dir, children[i]));\n                if (!success)\n                    return false;\n            }\n        }\n        return dir.delete();\n    }\n}\n"], "filenames": ["src/main/java/bspkrs/mmv/RemoteZipHandler.java"], "buggy_code_start_loc": [222], "buggy_code_end_loc": [222], "fixing_code_start_loc": [223], "fixing_code_end_loc": [226], "type": "CWE-22", "message": "A vulnerability, which was classified as critical, has been found in bspkrs MCPMappingViewer. Affected by this issue is the function extractZip of the file src/main/java/bspkrs/mmv/RemoteZipHandler.java of the component ZIP File Handler. The manipulation leads to path traversal. The attack may be launched remotely. The name of the patch is 6e602746c96b4756c271d080dae7d22ad804a1bd. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-215804.", "other": {"cve": {"id": "CVE-2022-4494", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-14T12:15:09.983", "lastModified": "2022-12-16T19:28:55.797", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as critical, has been found in bspkrs MCPMappingViewer. Affected by this issue is the function extractZip of the file src/main/java/bspkrs/mmv/RemoteZipHandler.java of the component ZIP File Handler. The manipulation leads to path traversal. The attack may be launched remotely. The name of the patch is 6e602746c96b4756c271d080dae7d22ad804a1bd. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-215804."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mcp_mapping_viewer_project:mcp_mapping_viewer:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-09-22", "matchCriteriaId": "4A4C31C1-55A0-4209-BF37-F110142CB1C5"}]}]}], "references": [{"url": "https://github.com/bspkrs/MCPMappingViewer/commit/6e602746c96b4756c271d080dae7d22ad804a1bd", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.215804", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bspkrs/MCPMappingViewer/commit/6e602746c96b4756c271d080dae7d22ad804a1bd"}}