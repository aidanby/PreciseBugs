{"buggy_code": ["#\n# Copyright (C) 2009-2020 the sqlparse authors and contributors\n# <see AUTHORS file>\n#\n# This module is part of python-sqlparse and is released under\n# the BSD License: https://opensource.org/licenses/BSD-3-Clause\n\nimport re\n\nfrom sqlparse import sql, tokens as T\nfrom sqlparse.utils import split_unquoted_newlines\n\n\nclass StripCommentsFilter:\n\n    @staticmethod\n    def _process(tlist):\n        def get_next_comment():\n            # TODO(andi) Comment types should be unified, see related issue38\n            return tlist.token_next_by(i=sql.Comment, t=T.Comment)\n\n        def _get_insert_token(token):\n            \"\"\"Returns either a whitespace or the line breaks from token.\"\"\"\n            # See issue484 why line breaks should be preserved.\n            m = re.search(r'((\\r\\n|\\r|\\n)+) *$', token.value)\n            if m is not None:\n                return sql.Token(T.Whitespace.Newline, m.groups()[0])\n            else:\n                return sql.Token(T.Whitespace, ' ')\n\n        tidx, token = get_next_comment()\n        while token:\n            pidx, prev_ = tlist.token_prev(tidx, skip_ws=False)\n            nidx, next_ = tlist.token_next(tidx, skip_ws=False)\n            # Replace by whitespace if prev and next exist and if they're not\n            # whitespaces. This doesn't apply if prev or next is a parenthesis.\n            if (prev_ is None or next_ is None\n                    or prev_.is_whitespace or prev_.match(T.Punctuation, '(')\n                    or next_.is_whitespace or next_.match(T.Punctuation, ')')):\n                # Insert a whitespace to ensure the following SQL produces\n                # a valid SQL (see #425).\n                if prev_ is not None and not prev_.match(T.Punctuation, '('):\n                    tlist.tokens.insert(tidx, _get_insert_token(token))\n                tlist.tokens.remove(token)\n            else:\n                tlist.tokens[tidx] = _get_insert_token(token)\n\n            tidx, token = get_next_comment()\n\n    def process(self, stmt):\n        [self.process(sgroup) for sgroup in stmt.get_sublists()]\n        StripCommentsFilter._process(stmt)\n        return stmt\n\n\nclass StripWhitespaceFilter:\n    def _stripws(self, tlist):\n        func_name = '_stripws_{cls}'.format(cls=type(tlist).__name__)\n        func = getattr(self, func_name.lower(), self._stripws_default)\n        func(tlist)\n\n    @staticmethod\n    def _stripws_default(tlist):\n        last_was_ws = False\n        is_first_char = True\n        for token in tlist.tokens:\n            if token.is_whitespace:\n                token.value = '' if last_was_ws or is_first_char else ' '\n            last_was_ws = token.is_whitespace\n            is_first_char = False\n\n    def _stripws_identifierlist(self, tlist):\n        # Removes newlines before commas, see issue140\n        last_nl = None\n        for token in list(tlist.tokens):\n            if last_nl and token.ttype is T.Punctuation and token.value == ',':\n                tlist.tokens.remove(last_nl)\n            last_nl = token if token.is_whitespace else None\n\n            # next_ = tlist.token_next(token, skip_ws=False)\n            # if (next_ and not next_.is_whitespace and\n            #             token.ttype is T.Punctuation and token.value == ','):\n            #     tlist.insert_after(token, sql.Token(T.Whitespace, ' '))\n        return self._stripws_default(tlist)\n\n    def _stripws_parenthesis(self, tlist):\n        while tlist.tokens[1].is_whitespace:\n            tlist.tokens.pop(1)\n        while tlist.tokens[-2].is_whitespace:\n            tlist.tokens.pop(-2)\n        self._stripws_default(tlist)\n\n    def process(self, stmt, depth=0):\n        [self.process(sgroup, depth + 1) for sgroup in stmt.get_sublists()]\n        self._stripws(stmt)\n        if depth == 0 and stmt.tokens and stmt.tokens[-1].is_whitespace:\n            stmt.tokens.pop(-1)\n        return stmt\n\n\nclass SpacesAroundOperatorsFilter:\n    @staticmethod\n    def _process(tlist):\n\n        ttypes = (T.Operator, T.Comparison)\n        tidx, token = tlist.token_next_by(t=ttypes)\n        while token:\n            nidx, next_ = tlist.token_next(tidx, skip_ws=False)\n            if next_ and next_.ttype != T.Whitespace:\n                tlist.insert_after(tidx, sql.Token(T.Whitespace, ' '))\n\n            pidx, prev_ = tlist.token_prev(tidx, skip_ws=False)\n            if prev_ and prev_.ttype != T.Whitespace:\n                tlist.insert_before(tidx, sql.Token(T.Whitespace, ' '))\n                tidx += 1  # has to shift since token inserted before it\n\n            # assert tlist.token_index(token) == tidx\n            tidx, token = tlist.token_next_by(t=ttypes, idx=tidx)\n\n    def process(self, stmt):\n        [self.process(sgroup) for sgroup in stmt.get_sublists()]\n        SpacesAroundOperatorsFilter._process(stmt)\n        return stmt\n\n\n# ---------------------------\n# postprocess\n\nclass SerializerUnicode:\n    @staticmethod\n    def process(stmt):\n        lines = split_unquoted_newlines(stmt)\n        return '\\n'.join(line.rstrip() for line in lines)\n", "import pytest\n\nimport sqlparse\nfrom sqlparse.exceptions import SQLParseError\n\n\nclass TestFormat:\n    def test_keywordcase(self):\n        sql = 'select * from bar; -- select foo\\n'\n        res = sqlparse.format(sql, keyword_case='upper')\n        assert res == 'SELECT * FROM bar; -- select foo\\n'\n        res = sqlparse.format(sql, keyword_case='capitalize')\n        assert res == 'Select * From bar; -- select foo\\n'\n        res = sqlparse.format(sql.upper(), keyword_case='lower')\n        assert res == 'select * from BAR; -- SELECT FOO\\n'\n\n    def test_keywordcase_invalid_option(self):\n        sql = 'select * from bar; -- select foo\\n'\n        with pytest.raises(SQLParseError):\n            sqlparse.format(sql, keyword_case='foo')\n\n    def test_identifiercase(self):\n        sql = 'select * from bar; -- select foo\\n'\n        res = sqlparse.format(sql, identifier_case='upper')\n        assert res == 'select * from BAR; -- select foo\\n'\n        res = sqlparse.format(sql, identifier_case='capitalize')\n        assert res == 'select * from Bar; -- select foo\\n'\n        res = sqlparse.format(sql.upper(), identifier_case='lower')\n        assert res == 'SELECT * FROM bar; -- SELECT FOO\\n'\n\n    def test_identifiercase_invalid_option(self):\n        sql = 'select * from bar; -- select foo\\n'\n        with pytest.raises(SQLParseError):\n            sqlparse.format(sql, identifier_case='foo')\n\n    def test_identifiercase_quotes(self):\n        sql = 'select * from \"foo\".\"bar\"'\n        res = sqlparse.format(sql, identifier_case=\"upper\")\n        assert res == 'select * from \"foo\".\"bar\"'\n\n    def test_strip_comments_single(self):\n        sql = 'select *-- statement starts here\\nfrom foo'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select *\\nfrom foo'\n        sql = 'select * -- statement starts here\\nfrom foo'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select *\\nfrom foo'\n        sql = 'select-- foo\\nfrom -- bar\\nwhere'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select\\nfrom\\nwhere'\n        sql = 'select *-- statement starts here\\n\\nfrom foo'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select *\\n\\nfrom foo'\n        sql = 'select * from foo-- statement starts here\\nwhere'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select * from foo\\nwhere'\n        sql = 'select a-- statement starts here\\nfrom foo'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select a\\nfrom foo'\n        sql = '--comment\\nselect a-- statement starts here\\n' \\\n              'from foo--comment\\nf'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select a\\nfrom foo\\nf'\n\n    def test_strip_comments_invalid_option(self):\n        sql = 'select-- foo\\nfrom -- bar\\nwhere'\n        with pytest.raises(SQLParseError):\n            sqlparse.format(sql, strip_comments=None)\n\n    def test_strip_comments_multi(self):\n        sql = '/* sql starts here */\\nselect'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select'\n        sql = '/* sql starts here */ select'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select'\n        sql = '/*\\n * sql starts here\\n */\\nselect'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select'\n        sql = 'select (/* sql starts here */ select 2)'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select (select 2)'\n        sql = 'select (/* sql /* starts here */ select 2)'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select (select 2)'\n\n    def test_strip_ws(self):\n        f = lambda sql: sqlparse.format(sql, strip_whitespace=True)\n        s = 'select\\n* from      foo\\n\\twhere  ( 1 = 2 )\\n'\n        assert f(s) == 'select * from foo where (1 = 2)'\n        s = 'select -- foo\\nfrom    bar\\n'\n        assert f(s) == 'select -- foo\\nfrom bar'\n\n    def test_strip_ws_invalid_option(self):\n        s = 'select -- foo\\nfrom    bar\\n'\n        with pytest.raises(SQLParseError):\n            sqlparse.format(s, strip_whitespace=None)\n\n    def test_preserve_ws(self):\n        # preserve at least one whitespace after subgroups\n        f = lambda sql: sqlparse.format(sql, strip_whitespace=True)\n        s = 'select\\n* /* foo */  from bar '\n        assert f(s) == 'select * /* foo */ from bar'\n\n    def test_notransform_of_quoted_crlf(self):\n        # Make sure that CR/CR+LF characters inside string literals don't get\n        # affected by the formatter.\n\n        s1 = \"SELECT some_column LIKE 'value\\r'\"\n        s2 = \"SELECT some_column LIKE 'value\\r'\\r\\nWHERE id = 1\\n\"\n        s3 = \"SELECT some_column LIKE 'value\\\\'\\r' WHERE id = 1\\r\"\n        s4 = \"SELECT some_column LIKE 'value\\\\\\\\\\\\'\\r' WHERE id = 1\\r\\n\"\n\n        f = lambda x: sqlparse.format(x)\n\n        # Because of the use of\n        assert f(s1) == \"SELECT some_column LIKE 'value\\r'\"\n        assert f(s2) == \"SELECT some_column LIKE 'value\\r'\\nWHERE id = 1\\n\"\n        assert f(s3) == \"SELECT some_column LIKE 'value\\\\'\\r' WHERE id = 1\\n\"\n        assert (f(s4)\n                == \"SELECT some_column LIKE 'value\\\\\\\\\\\\'\\r' WHERE id = 1\\n\")\n\n\nclass TestFormatReindentAligned:\n    @staticmethod\n    def formatter(sql):\n        return sqlparse.format(sql, reindent_aligned=True)\n\n    def test_basic(self):\n        sql = \"\"\"\n            select a, b as bb,c from table\n            join (select a * 2 as a from new_table) other\n            on table.a = other.a\n            where c is true\n            and b between 3 and 4\n            or d is 'blue'\n            limit 10\n            \"\"\"\n\n        assert self.formatter(sql) == '\\n'.join([\n            'select a,',\n            '       b as bb,',\n            '       c',\n            '  from table',\n            '  join (',\n            '        select a * 2 as a',\n            '          from new_table',\n            '       ) other',\n            '    on table.a = other.a',\n            ' where c is true',\n            '   and b between 3 and 4',\n            \"    or d is 'blue'\",\n            ' limit 10'])\n\n    def test_joins(self):\n        sql = \"\"\"\n            select * from a\n            join b on a.one = b.one\n            left join c on c.two = a.two and c.three = a.three\n            full outer join d on d.three = a.three\n            cross join e on e.four = a.four\n            join f using (one, two, three)\n            \"\"\"\n        assert self.formatter(sql) == '\\n'.join([\n            'select *',\n            '  from a',\n            '  join b',\n            '    on a.one = b.one',\n            '  left join c',\n            '    on c.two = a.two',\n            '   and c.three = a.three',\n            '  full outer join d',\n            '    on d.three = a.three',\n            ' cross join e',\n            '    on e.four = a.four',\n            '  join f using (one, two, three)'])\n\n    def test_case_statement(self):\n        sql = \"\"\"\n            select a,\n            case when a = 0\n            then 1\n            when bb = 1 then 1\n            when c = 2 then 2\n            else 0 end as d,\n            extra_col\n            from table\n            where c is true\n            and b between 3 and 4\n            \"\"\"\n        assert self.formatter(sql) == '\\n'.join([\n            'select a,',\n            '       case when a = 0  then 1',\n            '            when bb = 1 then 1',\n            '            when c = 2  then 2',\n            '            else 0',\n            '             end as d,',\n            '       extra_col',\n            '  from table',\n            ' where c is true',\n            '   and b between 3 and 4'])\n\n    def test_case_statement_with_between(self):\n        sql = \"\"\"\n            select a,\n            case when a = 0\n            then 1\n            when bb = 1 then 1\n            when c = 2 then 2\n            when d between 3 and 5 then 3\n            else 0 end as d,\n            extra_col\n            from table\n            where c is true\n            and b between 3 and 4\n            \"\"\"\n        assert self.formatter(sql) == '\\n'.join([\n            'select a,',\n            '       case when a = 0             then 1',\n            '            when bb = 1            then 1',\n            '            when c = 2             then 2',\n            '            when d between 3 and 5 then 3',\n            '            else 0',\n            '             end as d,',\n            '       extra_col',\n            '  from table',\n            ' where c is true',\n            '   and b between 3 and 4'])\n\n    def test_group_by(self):\n        sql = \"\"\"\n            select a, b, c, sum(x) as sum_x, count(y) as cnt_y\n            from table\n            group by a,b,c\n            having sum(x) > 1\n            and count(y) > 5\n            order by 3,2,1\n            \"\"\"\n        assert self.formatter(sql) == '\\n'.join([\n            'select a,',\n            '       b,',\n            '       c,',\n            '       sum(x) as sum_x,',\n            '       count(y) as cnt_y',\n            '  from table',\n            ' group by a,',\n            '          b,',\n            '          c',\n            'having sum(x) > 1',\n            '   and count(y) > 5',\n            ' order by 3,',\n            '          2,',\n            '          1'])\n\n    def test_group_by_subquery(self):\n        # TODO: add subquery alias when test_identifier_list_subquery fixed\n        sql = \"\"\"\n            select *, sum_b + 2 as mod_sum\n            from (\n              select a, sum(b) as sum_b\n              from table\n              group by a,z)\n            order by 1,2\n            \"\"\"\n        assert self.formatter(sql) == '\\n'.join([\n            'select *,',\n            '       sum_b + 2 as mod_sum',\n            '  from (',\n            '        select a,',\n            '               sum(b) as sum_b',\n            '          from table',\n            '         group by a,',\n            '                  z',\n            '       )',\n            ' order by 1,',\n            '          2'])\n\n    def test_window_functions(self):\n        sql = \"\"\"\n            select a,\n            SUM(a) OVER (PARTITION BY b ORDER BY c ROWS\n            BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as sum_a,\n            ROW_NUMBER() OVER\n            (PARTITION BY b, c ORDER BY d DESC) as row_num\n            from table\"\"\"\n        assert self.formatter(sql) == '\\n'.join([\n            'select a,',\n            '       SUM(a) OVER (PARTITION BY b ORDER BY c ROWS '\n            'BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as sum_a,',\n            '       ROW_NUMBER() OVER '\n            '(PARTITION BY b, c ORDER BY d DESC) as row_num',\n            '  from table'])\n\n\nclass TestSpacesAroundOperators:\n    @staticmethod\n    def formatter(sql):\n        return sqlparse.format(sql, use_space_around_operators=True)\n\n    def test_basic(self):\n        sql = ('select a+b as d from table '\n               'where (c-d)%2= 1 and e> 3.0/4 and z^2 <100')\n        assert self.formatter(sql) == (\n            'select a + b as d from table '\n            'where (c - d) % 2 = 1 and e > 3.0 / 4 and z ^ 2 < 100')\n\n    def test_bools(self):\n        sql = 'select * from table where a &&b or c||d'\n        assert self.formatter(\n            sql) == 'select * from table where a && b or c || d'\n\n    def test_nested(self):\n        sql = 'select *, case when a-b then c end from table'\n        assert self.formatter(\n            sql) == 'select *, case when a - b then c end from table'\n\n    def test_wildcard_vs_mult(self):\n        sql = 'select a*b-c from table'\n        assert self.formatter(sql) == 'select a * b - c from table'\n\n\nclass TestFormatReindent:\n    def test_option(self):\n        with pytest.raises(SQLParseError):\n            sqlparse.format('foo', reindent=2)\n        with pytest.raises(SQLParseError):\n            sqlparse.format('foo', indent_tabs=2)\n        with pytest.raises(SQLParseError):\n            sqlparse.format('foo', reindent=True, indent_width='foo')\n        with pytest.raises(SQLParseError):\n            sqlparse.format('foo', reindent=True, indent_width=-12)\n        with pytest.raises(SQLParseError):\n            sqlparse.format('foo', reindent=True, wrap_after='foo')\n        with pytest.raises(SQLParseError):\n            sqlparse.format('foo', reindent=True, wrap_after=-12)\n        with pytest.raises(SQLParseError):\n            sqlparse.format('foo', reindent=True, comma_first='foo')\n\n    def test_stmts(self):\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'select foo; select bar'\n        assert f(s) == 'select foo;\\n\\nselect bar'\n        s = 'select foo'\n        assert f(s) == 'select foo'\n        s = 'select foo; -- test\\n select bar'\n        assert f(s) == 'select foo; -- test\\n\\nselect bar'\n\n    def test_keywords(self):\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'select * from foo union select * from bar;'\n        assert f(s) == '\\n'.join([\n            'select *',\n            'from foo',\n            'union',\n            'select *',\n            'from bar;'])\n\n    def test_keywords_between(self):\n        # issue 14\n        # don't break AND after BETWEEN\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'and foo between 1 and 2 and bar = 3'\n        assert f(s) == '\\n'.join([\n            '',\n            'and foo between 1 and 2',\n            'and bar = 3'])\n\n    def test_parenthesis(self):\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'select count(*) from (select * from foo);'\n        assert f(s) == '\\n'.join([\n            'select count(*)',\n            'from',\n            '  (select *',\n            '   from foo);'])\n        assert f(\"select f(1)\") == 'select f(1)'\n        assert f(\"select f( 1 )\") == 'select f(1)'\n        assert f(\"select f(\\n\\n\\n1\\n\\n\\n)\") == 'select f(1)'\n        assert f(\"select f(\\n\\n\\n 1 \\n\\n\\n)\") == 'select f(1)'\n        assert f(\"select f(\\n\\n\\n  1  \\n\\n\\n)\") == 'select f(1)'\n\n    def test_where(self):\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'select * from foo where bar = 1 and baz = 2 or bzz = 3;'\n        assert f(s) == '\\n'.join([\n            'select *',\n            'from foo',\n            'where bar = 1',\n            '  and baz = 2',\n            '  or bzz = 3;'])\n\n        s = 'select * from foo where bar = 1 and (baz = 2 or bzz = 3);'\n        assert f(s) == '\\n'.join([\n            'select *',\n            'from foo',\n            'where bar = 1',\n            '  and (baz = 2',\n            '       or bzz = 3);'])\n\n    def test_join(self):\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'select * from foo join bar on 1 = 2'\n        assert f(s) == '\\n'.join([\n            'select *',\n            'from foo',\n            'join bar on 1 = 2'])\n        s = 'select * from foo inner join bar on 1 = 2'\n        assert f(s) == '\\n'.join([\n            'select *',\n            'from foo',\n            'inner join bar on 1 = 2'])\n        s = 'select * from foo left outer join bar on 1 = 2'\n        assert f(s) == '\\n'.join([\n            'select *',\n            'from foo',\n            'left outer join bar on 1 = 2'])\n        s = 'select * from foo straight_join bar on 1 = 2'\n        assert f(s) == '\\n'.join([\n            'select *',\n            'from foo',\n            'straight_join bar on 1 = 2'])\n\n    def test_identifier_list(self):\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'select foo, bar, baz from table1, table2 where 1 = 2'\n        assert f(s) == '\\n'.join([\n            'select foo,',\n            '       bar,',\n            '       baz',\n            'from table1,',\n            '     table2',\n            'where 1 = 2'])\n        s = 'select a.*, b.id from a, b'\n        assert f(s) == '\\n'.join([\n            'select a.*,',\n            '       b.id',\n            'from a,',\n            '     b'])\n\n    def test_identifier_list_with_wrap_after(self):\n        f = lambda sql: sqlparse.format(sql, reindent=True, wrap_after=14)\n        s = 'select foo, bar, baz from table1, table2 where 1 = 2'\n        assert f(s) == '\\n'.join([\n            'select foo, bar,',\n            '       baz',\n            'from table1, table2',\n            'where 1 = 2'])\n\n    def test_identifier_list_comment_first(self):\n        f = lambda sql: sqlparse.format(sql, reindent=True, comma_first=True)\n        # not the 3: It cleans up whitespace too!\n        s = 'select foo, bar, baz from table where foo in (1, 2,3)'\n        assert f(s) == '\\n'.join([\n            'select foo',\n            '     , bar',\n            '     , baz',\n            'from table',\n            'where foo in (1',\n            '            , 2',\n            '            , 3)'])\n\n    def test_identifier_list_with_functions(self):\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = (\"select 'abc' as foo, coalesce(col1, col2)||col3 as bar,\"\n             \"col3 from my_table\")\n        assert f(s) == '\\n'.join([\n            \"select 'abc' as foo,\",\n            \"       coalesce(col1, col2)||col3 as bar,\",\n            \"       col3\",\n            \"from my_table\"])\n\n    def test_long_identifier_list_with_functions(self):\n        f = lambda sql: sqlparse.format(sql, reindent=True, wrap_after=30)\n        s = (\"select 'abc' as foo, json_build_object('a',  a,\"\n             \"'b', b, 'c', c, 'd', d, 'e', e) as col2\"\n             \"col3 from my_table\")\n        assert f(s) == '\\n'.join([\n            \"select 'abc' as foo,\",\n            \"       json_build_object('a',\",\n            \"         a, 'b', b, 'c', c, 'd', d,\",\n            \"         'e', e) as col2col3\",\n            \"from my_table\"])\n\n    def test_case(self):\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'case when foo = 1 then 2 when foo = 3 then 4 else 5 end'\n        assert f(s) == '\\n'.join([\n            'case',\n            '    when foo = 1 then 2',\n            '    when foo = 3 then 4',\n            '    else 5',\n            'end'])\n\n    def test_case2(self):\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'case(foo) when bar = 1 then 2 else 3 end'\n        assert f(s) == '\\n'.join([\n            'case(foo)',\n            '    when bar = 1 then 2',\n            '    else 3',\n            'end'])\n\n    def test_nested_identifier_list(self):\n        # issue4\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = '(foo as bar, bar1, bar2 as bar3, b4 as b5)'\n        assert f(s) == '\\n'.join([\n            '(foo as bar,',\n            ' bar1,',\n            ' bar2 as bar3,',\n            ' b4 as b5)'])\n\n    def test_duplicate_linebreaks(self):\n        # issue3\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'select c1 -- column1\\nfrom foo'\n        assert f(s) == '\\n'.join([\n            'select c1 -- column1',\n            'from foo'])\n        s = 'select c1 -- column1\\nfrom foo'\n        r = sqlparse.format(s, reindent=True, strip_comments=True)\n        assert r == '\\n'.join([\n            'select c1',\n            'from foo'])\n        s = 'select c1\\nfrom foo\\norder by c1'\n        assert f(s) == '\\n'.join([\n            'select c1',\n            'from foo',\n            'order by c1'])\n        s = 'select c1 from t1 where (c1 = 1) order by c1'\n        assert f(s) == '\\n'.join([\n            'select c1',\n            'from t1',\n            'where (c1 = 1)',\n            'order by c1'])\n\n    def test_keywordfunctions(self):\n        # issue36\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'select max(a) b, foo, bar'\n        assert f(s) == '\\n'.join([\n            'select max(a) b,',\n            '       foo,',\n            '       bar'])\n\n    def test_identifier_and_functions(self):\n        # issue45\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'select foo.bar, nvl(1) from dual'\n        assert f(s) == '\\n'.join([\n            'select foo.bar,',\n            '       nvl(1)',\n            'from dual'])\n\n    def test_insert_values(self):\n        # issue 329\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'insert into foo values (1, 2)'\n        assert f(s) == '\\n'.join([\n            'insert into foo',\n            'values (1, 2)'])\n\n        s = 'insert into foo values (1, 2), (3, 4), (5, 6)'\n        assert f(s) == '\\n'.join([\n            'insert into foo',\n            'values (1, 2),',\n            '       (3, 4),',\n            '       (5, 6)'])\n\n        s = 'insert into foo(a, b) values (1, 2), (3, 4), (5, 6)'\n        assert f(s) == '\\n'.join([\n            'insert into foo(a, b)',\n            'values (1, 2),',\n            '       (3, 4),',\n            '       (5, 6)'])\n\n        f = lambda sql: sqlparse.format(sql, reindent=True,\n                                        comma_first=True)\n        s = 'insert into foo values (1, 2)'\n        assert f(s) == '\\n'.join([\n            'insert into foo',\n            'values (1, 2)'])\n\n        s = 'insert into foo values (1, 2), (3, 4), (5, 6)'\n        assert f(s) == '\\n'.join([\n            'insert into foo',\n            'values (1, 2)',\n            '     , (3, 4)',\n            '     , (5, 6)'])\n\n        s = 'insert into foo(a, b) values (1, 2), (3, 4), (5, 6)'\n        assert f(s) == '\\n'.join([\n            'insert into foo(a, b)',\n            'values (1, 2)',\n            '     , (3, 4)',\n            '     , (5, 6)'])\n\n\nclass TestOutputFormat:\n    def test_python(self):\n        sql = 'select * from foo;'\n        f = lambda sql: sqlparse.format(sql, output_format='python')\n        assert f(sql) == \"sql = 'select * from foo;'\"\n        f = lambda sql: sqlparse.format(sql, output_format='python',\n                                        reindent=True)\n        assert f(sql) == '\\n'.join([\n            \"sql = ('select * '\",\n            \"       'from foo;')\"])\n\n    def test_python_multiple_statements(self):\n        sql = 'select * from foo; select 1 from dual'\n        f = lambda sql: sqlparse.format(sql, output_format='python')\n        assert f(sql) == '\\n'.join([\n            \"sql = 'select * from foo; '\",\n            \"sql2 = 'select 1 from dual'\"])\n\n    @pytest.mark.xfail(reason=\"Needs fixing\")\n    def test_python_multiple_statements_with_formatting(self):\n        sql = 'select * from foo; select 1 from dual'\n        f = lambda sql: sqlparse.format(sql, output_format='python',\n                                        reindent=True)\n        assert f(sql) == '\\n'.join([\n            \"sql = ('select * '\",\n            \"       'from foo;')\",\n            \"sql2 = ('select 1 '\",\n            \"        'from dual')\"])\n\n    def test_php(self):\n        sql = 'select * from foo;'\n        f = lambda sql: sqlparse.format(sql, output_format='php')\n        assert f(sql) == '$sql = \"select * from foo;\";'\n        f = lambda sql: sqlparse.format(sql, output_format='php',\n                                        reindent=True)\n        assert f(sql) == '\\n'.join([\n            '$sql  = \"select * \";',\n            '$sql .= \"from foo;\";'])\n\n    def test_sql(self):\n        # \"sql\" is an allowed option but has no effect\n        sql = 'select * from foo;'\n        f = lambda sql: sqlparse.format(sql, output_format='sql')\n        assert f(sql) == 'select * from foo;'\n\n    def test_invalid_option(self):\n        sql = 'select * from foo;'\n        with pytest.raises(SQLParseError):\n            sqlparse.format(sql, output_format='foo')\n\n\ndef test_format_column_ordering():\n    # issue89\n    sql = 'select * from foo order by c1 desc, c2, c3;'\n    formatted = sqlparse.format(sql, reindent=True)\n    expected = '\\n'.join([\n        'select *',\n        'from foo',\n        'order by c1 desc,',\n        '         c2,',\n        '         c3;'])\n    assert formatted == expected\n\n\ndef test_truncate_strings():\n    sql = \"update foo set value = '{}';\".format('x' * 1000)\n    formatted = sqlparse.format(sql, truncate_strings=10)\n    assert formatted == \"update foo set value = 'xxxxxxxxxx[...]';\"\n    formatted = sqlparse.format(sql, truncate_strings=3, truncate_char='YYY')\n    assert formatted == \"update foo set value = 'xxxYYY';\"\n\n\n@pytest.mark.parametrize('option', ['bar', -1, 0])\ndef test_truncate_strings_invalid_option2(option):\n    with pytest.raises(SQLParseError):\n        sqlparse.format('foo', truncate_strings=option)\n\n\n@pytest.mark.parametrize('sql', [\n    'select verrrylongcolumn from foo',\n    'select \"verrrylongcolumn\" from \"foo\"'])\ndef test_truncate_strings_doesnt_truncate_identifiers(sql):\n    formatted = sqlparse.format(sql, truncate_strings=2)\n    assert formatted == sql\n\n\ndef test_having_produces_newline():\n    sql = ('select * from foo, bar where bar.id = foo.bar_id '\n           'having sum(bar.value) > 100')\n    formatted = sqlparse.format(sql, reindent=True)\n    expected = [\n        'select *',\n        'from foo,',\n        '     bar',\n        'where bar.id = foo.bar_id',\n        'having sum(bar.value) > 100']\n    assert formatted == '\\n'.join(expected)\n\n\n@pytest.mark.parametrize('right_margin', ['ten', 2])\ndef test_format_right_margin_invalid_option(right_margin):\n    with pytest.raises(SQLParseError):\n        sqlparse.format('foo', right_margin=right_margin)\n\n\n@pytest.mark.xfail(reason=\"Needs fixing\")\ndef test_format_right_margin():\n    # TODO: Needs better test, only raises exception right now\n    sqlparse.format('foo', right_margin=\"79\")\n"], "fixing_code": ["#\n# Copyright (C) 2009-2020 the sqlparse authors and contributors\n# <see AUTHORS file>\n#\n# This module is part of python-sqlparse and is released under\n# the BSD License: https://opensource.org/licenses/BSD-3-Clause\n\nimport re\n\nfrom sqlparse import sql, tokens as T\nfrom sqlparse.utils import split_unquoted_newlines\n\n\nclass StripCommentsFilter:\n\n    @staticmethod\n    def _process(tlist):\n        def get_next_comment():\n            # TODO(andi) Comment types should be unified, see related issue38\n            return tlist.token_next_by(i=sql.Comment, t=T.Comment)\n\n        def _get_insert_token(token):\n            \"\"\"Returns either a whitespace or the line breaks from token.\"\"\"\n            # See issue484 why line breaks should be preserved.\n            # Note: The actual value for a line break is replaced by \\n\n            # in SerializerUnicode which will be executed in the\n            # postprocessing state.\n            m = re.search(r'((\\r|\\n)+) *$', token.value)\n            if m is not None:\n                return sql.Token(T.Whitespace.Newline, m.groups()[0])\n            else:\n                return sql.Token(T.Whitespace, ' ')\n\n        tidx, token = get_next_comment()\n        while token:\n            pidx, prev_ = tlist.token_prev(tidx, skip_ws=False)\n            nidx, next_ = tlist.token_next(tidx, skip_ws=False)\n            # Replace by whitespace if prev and next exist and if they're not\n            # whitespaces. This doesn't apply if prev or next is a parenthesis.\n            if (prev_ is None or next_ is None\n                    or prev_.is_whitespace or prev_.match(T.Punctuation, '(')\n                    or next_.is_whitespace or next_.match(T.Punctuation, ')')):\n                # Insert a whitespace to ensure the following SQL produces\n                # a valid SQL (see #425).\n                if prev_ is not None and not prev_.match(T.Punctuation, '('):\n                    tlist.tokens.insert(tidx, _get_insert_token(token))\n                tlist.tokens.remove(token)\n            else:\n                tlist.tokens[tidx] = _get_insert_token(token)\n\n            tidx, token = get_next_comment()\n\n    def process(self, stmt):\n        [self.process(sgroup) for sgroup in stmt.get_sublists()]\n        StripCommentsFilter._process(stmt)\n        return stmt\n\n\nclass StripWhitespaceFilter:\n    def _stripws(self, tlist):\n        func_name = '_stripws_{cls}'.format(cls=type(tlist).__name__)\n        func = getattr(self, func_name.lower(), self._stripws_default)\n        func(tlist)\n\n    @staticmethod\n    def _stripws_default(tlist):\n        last_was_ws = False\n        is_first_char = True\n        for token in tlist.tokens:\n            if token.is_whitespace:\n                token.value = '' if last_was_ws or is_first_char else ' '\n            last_was_ws = token.is_whitespace\n            is_first_char = False\n\n    def _stripws_identifierlist(self, tlist):\n        # Removes newlines before commas, see issue140\n        last_nl = None\n        for token in list(tlist.tokens):\n            if last_nl and token.ttype is T.Punctuation and token.value == ',':\n                tlist.tokens.remove(last_nl)\n            last_nl = token if token.is_whitespace else None\n\n            # next_ = tlist.token_next(token, skip_ws=False)\n            # if (next_ and not next_.is_whitespace and\n            #             token.ttype is T.Punctuation and token.value == ','):\n            #     tlist.insert_after(token, sql.Token(T.Whitespace, ' '))\n        return self._stripws_default(tlist)\n\n    def _stripws_parenthesis(self, tlist):\n        while tlist.tokens[1].is_whitespace:\n            tlist.tokens.pop(1)\n        while tlist.tokens[-2].is_whitespace:\n            tlist.tokens.pop(-2)\n        self._stripws_default(tlist)\n\n    def process(self, stmt, depth=0):\n        [self.process(sgroup, depth + 1) for sgroup in stmt.get_sublists()]\n        self._stripws(stmt)\n        if depth == 0 and stmt.tokens and stmt.tokens[-1].is_whitespace:\n            stmt.tokens.pop(-1)\n        return stmt\n\n\nclass SpacesAroundOperatorsFilter:\n    @staticmethod\n    def _process(tlist):\n\n        ttypes = (T.Operator, T.Comparison)\n        tidx, token = tlist.token_next_by(t=ttypes)\n        while token:\n            nidx, next_ = tlist.token_next(tidx, skip_ws=False)\n            if next_ and next_.ttype != T.Whitespace:\n                tlist.insert_after(tidx, sql.Token(T.Whitespace, ' '))\n\n            pidx, prev_ = tlist.token_prev(tidx, skip_ws=False)\n            if prev_ and prev_.ttype != T.Whitespace:\n                tlist.insert_before(tidx, sql.Token(T.Whitespace, ' '))\n                tidx += 1  # has to shift since token inserted before it\n\n            # assert tlist.token_index(token) == tidx\n            tidx, token = tlist.token_next_by(t=ttypes, idx=tidx)\n\n    def process(self, stmt):\n        [self.process(sgroup) for sgroup in stmt.get_sublists()]\n        SpacesAroundOperatorsFilter._process(stmt)\n        return stmt\n\n\n# ---------------------------\n# postprocess\n\nclass SerializerUnicode:\n    @staticmethod\n    def process(stmt):\n        lines = split_unquoted_newlines(stmt)\n        return '\\n'.join(line.rstrip() for line in lines)\n", "import pytest\n\nimport sqlparse\nfrom sqlparse.exceptions import SQLParseError\n\n\nclass TestFormat:\n    def test_keywordcase(self):\n        sql = 'select * from bar; -- select foo\\n'\n        res = sqlparse.format(sql, keyword_case='upper')\n        assert res == 'SELECT * FROM bar; -- select foo\\n'\n        res = sqlparse.format(sql, keyword_case='capitalize')\n        assert res == 'Select * From bar; -- select foo\\n'\n        res = sqlparse.format(sql.upper(), keyword_case='lower')\n        assert res == 'select * from BAR; -- SELECT FOO\\n'\n\n    def test_keywordcase_invalid_option(self):\n        sql = 'select * from bar; -- select foo\\n'\n        with pytest.raises(SQLParseError):\n            sqlparse.format(sql, keyword_case='foo')\n\n    def test_identifiercase(self):\n        sql = 'select * from bar; -- select foo\\n'\n        res = sqlparse.format(sql, identifier_case='upper')\n        assert res == 'select * from BAR; -- select foo\\n'\n        res = sqlparse.format(sql, identifier_case='capitalize')\n        assert res == 'select * from Bar; -- select foo\\n'\n        res = sqlparse.format(sql.upper(), identifier_case='lower')\n        assert res == 'SELECT * FROM bar; -- SELECT FOO\\n'\n\n    def test_identifiercase_invalid_option(self):\n        sql = 'select * from bar; -- select foo\\n'\n        with pytest.raises(SQLParseError):\n            sqlparse.format(sql, identifier_case='foo')\n\n    def test_identifiercase_quotes(self):\n        sql = 'select * from \"foo\".\"bar\"'\n        res = sqlparse.format(sql, identifier_case=\"upper\")\n        assert res == 'select * from \"foo\".\"bar\"'\n\n    def test_strip_comments_single(self):\n        sql = 'select *-- statement starts here\\nfrom foo'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select *\\nfrom foo'\n        sql = 'select * -- statement starts here\\nfrom foo'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select *\\nfrom foo'\n        sql = 'select-- foo\\nfrom -- bar\\nwhere'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select\\nfrom\\nwhere'\n        sql = 'select *-- statement starts here\\n\\nfrom foo'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select *\\n\\nfrom foo'\n        sql = 'select * from foo-- statement starts here\\nwhere'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select * from foo\\nwhere'\n        sql = 'select a-- statement starts here\\nfrom foo'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select a\\nfrom foo'\n        sql = '--comment\\nselect a-- statement starts here\\n' \\\n              'from foo--comment\\nf'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select a\\nfrom foo\\nf'\n\n    def test_strip_comments_invalid_option(self):\n        sql = 'select-- foo\\nfrom -- bar\\nwhere'\n        with pytest.raises(SQLParseError):\n            sqlparse.format(sql, strip_comments=None)\n\n    def test_strip_comments_multi(self):\n        sql = '/* sql starts here */\\nselect'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select'\n        sql = '/* sql starts here */ select'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select'\n        sql = '/*\\n * sql starts here\\n */\\nselect'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select'\n        sql = 'select (/* sql starts here */ select 2)'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select (select 2)'\n        sql = 'select (/* sql /* starts here */ select 2)'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select (select 2)'\n\n    def test_strip_comments_preserves_linebreak(self):\n        sql = 'select * -- a comment\\r\\nfrom foo'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select *\\nfrom foo'\n        sql = 'select * -- a comment\\nfrom foo'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select *\\nfrom foo'\n        sql = 'select * -- a comment\\rfrom foo'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select *\\nfrom foo'\n        sql = 'select * -- a comment\\r\\n\\r\\nfrom foo'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select *\\n\\nfrom foo'\n        sql = 'select * -- a comment\\n\\nfrom foo'\n        res = sqlparse.format(sql, strip_comments=True)\n        assert res == 'select *\\n\\nfrom foo'\n\n    def test_strip_ws(self):\n        f = lambda sql: sqlparse.format(sql, strip_whitespace=True)\n        s = 'select\\n* from      foo\\n\\twhere  ( 1 = 2 )\\n'\n        assert f(s) == 'select * from foo where (1 = 2)'\n        s = 'select -- foo\\nfrom    bar\\n'\n        assert f(s) == 'select -- foo\\nfrom bar'\n\n    def test_strip_ws_invalid_option(self):\n        s = 'select -- foo\\nfrom    bar\\n'\n        with pytest.raises(SQLParseError):\n            sqlparse.format(s, strip_whitespace=None)\n\n    def test_preserve_ws(self):\n        # preserve at least one whitespace after subgroups\n        f = lambda sql: sqlparse.format(sql, strip_whitespace=True)\n        s = 'select\\n* /* foo */  from bar '\n        assert f(s) == 'select * /* foo */ from bar'\n\n    def test_notransform_of_quoted_crlf(self):\n        # Make sure that CR/CR+LF characters inside string literals don't get\n        # affected by the formatter.\n\n        s1 = \"SELECT some_column LIKE 'value\\r'\"\n        s2 = \"SELECT some_column LIKE 'value\\r'\\r\\nWHERE id = 1\\n\"\n        s3 = \"SELECT some_column LIKE 'value\\\\'\\r' WHERE id = 1\\r\"\n        s4 = \"SELECT some_column LIKE 'value\\\\\\\\\\\\'\\r' WHERE id = 1\\r\\n\"\n\n        f = lambda x: sqlparse.format(x)\n\n        # Because of the use of\n        assert f(s1) == \"SELECT some_column LIKE 'value\\r'\"\n        assert f(s2) == \"SELECT some_column LIKE 'value\\r'\\nWHERE id = 1\\n\"\n        assert f(s3) == \"SELECT some_column LIKE 'value\\\\'\\r' WHERE id = 1\\n\"\n        assert (f(s4)\n                == \"SELECT some_column LIKE 'value\\\\\\\\\\\\'\\r' WHERE id = 1\\n\")\n\n\nclass TestFormatReindentAligned:\n    @staticmethod\n    def formatter(sql):\n        return sqlparse.format(sql, reindent_aligned=True)\n\n    def test_basic(self):\n        sql = \"\"\"\n            select a, b as bb,c from table\n            join (select a * 2 as a from new_table) other\n            on table.a = other.a\n            where c is true\n            and b between 3 and 4\n            or d is 'blue'\n            limit 10\n            \"\"\"\n\n        assert self.formatter(sql) == '\\n'.join([\n            'select a,',\n            '       b as bb,',\n            '       c',\n            '  from table',\n            '  join (',\n            '        select a * 2 as a',\n            '          from new_table',\n            '       ) other',\n            '    on table.a = other.a',\n            ' where c is true',\n            '   and b between 3 and 4',\n            \"    or d is 'blue'\",\n            ' limit 10'])\n\n    def test_joins(self):\n        sql = \"\"\"\n            select * from a\n            join b on a.one = b.one\n            left join c on c.two = a.two and c.three = a.three\n            full outer join d on d.three = a.three\n            cross join e on e.four = a.four\n            join f using (one, two, three)\n            \"\"\"\n        assert self.formatter(sql) == '\\n'.join([\n            'select *',\n            '  from a',\n            '  join b',\n            '    on a.one = b.one',\n            '  left join c',\n            '    on c.two = a.two',\n            '   and c.three = a.three',\n            '  full outer join d',\n            '    on d.three = a.three',\n            ' cross join e',\n            '    on e.four = a.four',\n            '  join f using (one, two, three)'])\n\n    def test_case_statement(self):\n        sql = \"\"\"\n            select a,\n            case when a = 0\n            then 1\n            when bb = 1 then 1\n            when c = 2 then 2\n            else 0 end as d,\n            extra_col\n            from table\n            where c is true\n            and b between 3 and 4\n            \"\"\"\n        assert self.formatter(sql) == '\\n'.join([\n            'select a,',\n            '       case when a = 0  then 1',\n            '            when bb = 1 then 1',\n            '            when c = 2  then 2',\n            '            else 0',\n            '             end as d,',\n            '       extra_col',\n            '  from table',\n            ' where c is true',\n            '   and b between 3 and 4'])\n\n    def test_case_statement_with_between(self):\n        sql = \"\"\"\n            select a,\n            case when a = 0\n            then 1\n            when bb = 1 then 1\n            when c = 2 then 2\n            when d between 3 and 5 then 3\n            else 0 end as d,\n            extra_col\n            from table\n            where c is true\n            and b between 3 and 4\n            \"\"\"\n        assert self.formatter(sql) == '\\n'.join([\n            'select a,',\n            '       case when a = 0             then 1',\n            '            when bb = 1            then 1',\n            '            when c = 2             then 2',\n            '            when d between 3 and 5 then 3',\n            '            else 0',\n            '             end as d,',\n            '       extra_col',\n            '  from table',\n            ' where c is true',\n            '   and b between 3 and 4'])\n\n    def test_group_by(self):\n        sql = \"\"\"\n            select a, b, c, sum(x) as sum_x, count(y) as cnt_y\n            from table\n            group by a,b,c\n            having sum(x) > 1\n            and count(y) > 5\n            order by 3,2,1\n            \"\"\"\n        assert self.formatter(sql) == '\\n'.join([\n            'select a,',\n            '       b,',\n            '       c,',\n            '       sum(x) as sum_x,',\n            '       count(y) as cnt_y',\n            '  from table',\n            ' group by a,',\n            '          b,',\n            '          c',\n            'having sum(x) > 1',\n            '   and count(y) > 5',\n            ' order by 3,',\n            '          2,',\n            '          1'])\n\n    def test_group_by_subquery(self):\n        # TODO: add subquery alias when test_identifier_list_subquery fixed\n        sql = \"\"\"\n            select *, sum_b + 2 as mod_sum\n            from (\n              select a, sum(b) as sum_b\n              from table\n              group by a,z)\n            order by 1,2\n            \"\"\"\n        assert self.formatter(sql) == '\\n'.join([\n            'select *,',\n            '       sum_b + 2 as mod_sum',\n            '  from (',\n            '        select a,',\n            '               sum(b) as sum_b',\n            '          from table',\n            '         group by a,',\n            '                  z',\n            '       )',\n            ' order by 1,',\n            '          2'])\n\n    def test_window_functions(self):\n        sql = \"\"\"\n            select a,\n            SUM(a) OVER (PARTITION BY b ORDER BY c ROWS\n            BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as sum_a,\n            ROW_NUMBER() OVER\n            (PARTITION BY b, c ORDER BY d DESC) as row_num\n            from table\"\"\"\n        assert self.formatter(sql) == '\\n'.join([\n            'select a,',\n            '       SUM(a) OVER (PARTITION BY b ORDER BY c ROWS '\n            'BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as sum_a,',\n            '       ROW_NUMBER() OVER '\n            '(PARTITION BY b, c ORDER BY d DESC) as row_num',\n            '  from table'])\n\n\nclass TestSpacesAroundOperators:\n    @staticmethod\n    def formatter(sql):\n        return sqlparse.format(sql, use_space_around_operators=True)\n\n    def test_basic(self):\n        sql = ('select a+b as d from table '\n               'where (c-d)%2= 1 and e> 3.0/4 and z^2 <100')\n        assert self.formatter(sql) == (\n            'select a + b as d from table '\n            'where (c - d) % 2 = 1 and e > 3.0 / 4 and z ^ 2 < 100')\n\n    def test_bools(self):\n        sql = 'select * from table where a &&b or c||d'\n        assert self.formatter(\n            sql) == 'select * from table where a && b or c || d'\n\n    def test_nested(self):\n        sql = 'select *, case when a-b then c end from table'\n        assert self.formatter(\n            sql) == 'select *, case when a - b then c end from table'\n\n    def test_wildcard_vs_mult(self):\n        sql = 'select a*b-c from table'\n        assert self.formatter(sql) == 'select a * b - c from table'\n\n\nclass TestFormatReindent:\n    def test_option(self):\n        with pytest.raises(SQLParseError):\n            sqlparse.format('foo', reindent=2)\n        with pytest.raises(SQLParseError):\n            sqlparse.format('foo', indent_tabs=2)\n        with pytest.raises(SQLParseError):\n            sqlparse.format('foo', reindent=True, indent_width='foo')\n        with pytest.raises(SQLParseError):\n            sqlparse.format('foo', reindent=True, indent_width=-12)\n        with pytest.raises(SQLParseError):\n            sqlparse.format('foo', reindent=True, wrap_after='foo')\n        with pytest.raises(SQLParseError):\n            sqlparse.format('foo', reindent=True, wrap_after=-12)\n        with pytest.raises(SQLParseError):\n            sqlparse.format('foo', reindent=True, comma_first='foo')\n\n    def test_stmts(self):\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'select foo; select bar'\n        assert f(s) == 'select foo;\\n\\nselect bar'\n        s = 'select foo'\n        assert f(s) == 'select foo'\n        s = 'select foo; -- test\\n select bar'\n        assert f(s) == 'select foo; -- test\\n\\nselect bar'\n\n    def test_keywords(self):\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'select * from foo union select * from bar;'\n        assert f(s) == '\\n'.join([\n            'select *',\n            'from foo',\n            'union',\n            'select *',\n            'from bar;'])\n\n    def test_keywords_between(self):\n        # issue 14\n        # don't break AND after BETWEEN\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'and foo between 1 and 2 and bar = 3'\n        assert f(s) == '\\n'.join([\n            '',\n            'and foo between 1 and 2',\n            'and bar = 3'])\n\n    def test_parenthesis(self):\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'select count(*) from (select * from foo);'\n        assert f(s) == '\\n'.join([\n            'select count(*)',\n            'from',\n            '  (select *',\n            '   from foo);'])\n        assert f(\"select f(1)\") == 'select f(1)'\n        assert f(\"select f( 1 )\") == 'select f(1)'\n        assert f(\"select f(\\n\\n\\n1\\n\\n\\n)\") == 'select f(1)'\n        assert f(\"select f(\\n\\n\\n 1 \\n\\n\\n)\") == 'select f(1)'\n        assert f(\"select f(\\n\\n\\n  1  \\n\\n\\n)\") == 'select f(1)'\n\n    def test_where(self):\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'select * from foo where bar = 1 and baz = 2 or bzz = 3;'\n        assert f(s) == '\\n'.join([\n            'select *',\n            'from foo',\n            'where bar = 1',\n            '  and baz = 2',\n            '  or bzz = 3;'])\n\n        s = 'select * from foo where bar = 1 and (baz = 2 or bzz = 3);'\n        assert f(s) == '\\n'.join([\n            'select *',\n            'from foo',\n            'where bar = 1',\n            '  and (baz = 2',\n            '       or bzz = 3);'])\n\n    def test_join(self):\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'select * from foo join bar on 1 = 2'\n        assert f(s) == '\\n'.join([\n            'select *',\n            'from foo',\n            'join bar on 1 = 2'])\n        s = 'select * from foo inner join bar on 1 = 2'\n        assert f(s) == '\\n'.join([\n            'select *',\n            'from foo',\n            'inner join bar on 1 = 2'])\n        s = 'select * from foo left outer join bar on 1 = 2'\n        assert f(s) == '\\n'.join([\n            'select *',\n            'from foo',\n            'left outer join bar on 1 = 2'])\n        s = 'select * from foo straight_join bar on 1 = 2'\n        assert f(s) == '\\n'.join([\n            'select *',\n            'from foo',\n            'straight_join bar on 1 = 2'])\n\n    def test_identifier_list(self):\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'select foo, bar, baz from table1, table2 where 1 = 2'\n        assert f(s) == '\\n'.join([\n            'select foo,',\n            '       bar,',\n            '       baz',\n            'from table1,',\n            '     table2',\n            'where 1 = 2'])\n        s = 'select a.*, b.id from a, b'\n        assert f(s) == '\\n'.join([\n            'select a.*,',\n            '       b.id',\n            'from a,',\n            '     b'])\n\n    def test_identifier_list_with_wrap_after(self):\n        f = lambda sql: sqlparse.format(sql, reindent=True, wrap_after=14)\n        s = 'select foo, bar, baz from table1, table2 where 1 = 2'\n        assert f(s) == '\\n'.join([\n            'select foo, bar,',\n            '       baz',\n            'from table1, table2',\n            'where 1 = 2'])\n\n    def test_identifier_list_comment_first(self):\n        f = lambda sql: sqlparse.format(sql, reindent=True, comma_first=True)\n        # not the 3: It cleans up whitespace too!\n        s = 'select foo, bar, baz from table where foo in (1, 2,3)'\n        assert f(s) == '\\n'.join([\n            'select foo',\n            '     , bar',\n            '     , baz',\n            'from table',\n            'where foo in (1',\n            '            , 2',\n            '            , 3)'])\n\n    def test_identifier_list_with_functions(self):\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = (\"select 'abc' as foo, coalesce(col1, col2)||col3 as bar,\"\n             \"col3 from my_table\")\n        assert f(s) == '\\n'.join([\n            \"select 'abc' as foo,\",\n            \"       coalesce(col1, col2)||col3 as bar,\",\n            \"       col3\",\n            \"from my_table\"])\n\n    def test_long_identifier_list_with_functions(self):\n        f = lambda sql: sqlparse.format(sql, reindent=True, wrap_after=30)\n        s = (\"select 'abc' as foo, json_build_object('a',  a,\"\n             \"'b', b, 'c', c, 'd', d, 'e', e) as col2\"\n             \"col3 from my_table\")\n        assert f(s) == '\\n'.join([\n            \"select 'abc' as foo,\",\n            \"       json_build_object('a',\",\n            \"         a, 'b', b, 'c', c, 'd', d,\",\n            \"         'e', e) as col2col3\",\n            \"from my_table\"])\n\n    def test_case(self):\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'case when foo = 1 then 2 when foo = 3 then 4 else 5 end'\n        assert f(s) == '\\n'.join([\n            'case',\n            '    when foo = 1 then 2',\n            '    when foo = 3 then 4',\n            '    else 5',\n            'end'])\n\n    def test_case2(self):\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'case(foo) when bar = 1 then 2 else 3 end'\n        assert f(s) == '\\n'.join([\n            'case(foo)',\n            '    when bar = 1 then 2',\n            '    else 3',\n            'end'])\n\n    def test_nested_identifier_list(self):\n        # issue4\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = '(foo as bar, bar1, bar2 as bar3, b4 as b5)'\n        assert f(s) == '\\n'.join([\n            '(foo as bar,',\n            ' bar1,',\n            ' bar2 as bar3,',\n            ' b4 as b5)'])\n\n    def test_duplicate_linebreaks(self):\n        # issue3\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'select c1 -- column1\\nfrom foo'\n        assert f(s) == '\\n'.join([\n            'select c1 -- column1',\n            'from foo'])\n        s = 'select c1 -- column1\\nfrom foo'\n        r = sqlparse.format(s, reindent=True, strip_comments=True)\n        assert r == '\\n'.join([\n            'select c1',\n            'from foo'])\n        s = 'select c1\\nfrom foo\\norder by c1'\n        assert f(s) == '\\n'.join([\n            'select c1',\n            'from foo',\n            'order by c1'])\n        s = 'select c1 from t1 where (c1 = 1) order by c1'\n        assert f(s) == '\\n'.join([\n            'select c1',\n            'from t1',\n            'where (c1 = 1)',\n            'order by c1'])\n\n    def test_keywordfunctions(self):\n        # issue36\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'select max(a) b, foo, bar'\n        assert f(s) == '\\n'.join([\n            'select max(a) b,',\n            '       foo,',\n            '       bar'])\n\n    def test_identifier_and_functions(self):\n        # issue45\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'select foo.bar, nvl(1) from dual'\n        assert f(s) == '\\n'.join([\n            'select foo.bar,',\n            '       nvl(1)',\n            'from dual'])\n\n    def test_insert_values(self):\n        # issue 329\n        f = lambda sql: sqlparse.format(sql, reindent=True)\n        s = 'insert into foo values (1, 2)'\n        assert f(s) == '\\n'.join([\n            'insert into foo',\n            'values (1, 2)'])\n\n        s = 'insert into foo values (1, 2), (3, 4), (5, 6)'\n        assert f(s) == '\\n'.join([\n            'insert into foo',\n            'values (1, 2),',\n            '       (3, 4),',\n            '       (5, 6)'])\n\n        s = 'insert into foo(a, b) values (1, 2), (3, 4), (5, 6)'\n        assert f(s) == '\\n'.join([\n            'insert into foo(a, b)',\n            'values (1, 2),',\n            '       (3, 4),',\n            '       (5, 6)'])\n\n        f = lambda sql: sqlparse.format(sql, reindent=True,\n                                        comma_first=True)\n        s = 'insert into foo values (1, 2)'\n        assert f(s) == '\\n'.join([\n            'insert into foo',\n            'values (1, 2)'])\n\n        s = 'insert into foo values (1, 2), (3, 4), (5, 6)'\n        assert f(s) == '\\n'.join([\n            'insert into foo',\n            'values (1, 2)',\n            '     , (3, 4)',\n            '     , (5, 6)'])\n\n        s = 'insert into foo(a, b) values (1, 2), (3, 4), (5, 6)'\n        assert f(s) == '\\n'.join([\n            'insert into foo(a, b)',\n            'values (1, 2)',\n            '     , (3, 4)',\n            '     , (5, 6)'])\n\n\nclass TestOutputFormat:\n    def test_python(self):\n        sql = 'select * from foo;'\n        f = lambda sql: sqlparse.format(sql, output_format='python')\n        assert f(sql) == \"sql = 'select * from foo;'\"\n        f = lambda sql: sqlparse.format(sql, output_format='python',\n                                        reindent=True)\n        assert f(sql) == '\\n'.join([\n            \"sql = ('select * '\",\n            \"       'from foo;')\"])\n\n    def test_python_multiple_statements(self):\n        sql = 'select * from foo; select 1 from dual'\n        f = lambda sql: sqlparse.format(sql, output_format='python')\n        assert f(sql) == '\\n'.join([\n            \"sql = 'select * from foo; '\",\n            \"sql2 = 'select 1 from dual'\"])\n\n    @pytest.mark.xfail(reason=\"Needs fixing\")\n    def test_python_multiple_statements_with_formatting(self):\n        sql = 'select * from foo; select 1 from dual'\n        f = lambda sql: sqlparse.format(sql, output_format='python',\n                                        reindent=True)\n        assert f(sql) == '\\n'.join([\n            \"sql = ('select * '\",\n            \"       'from foo;')\",\n            \"sql2 = ('select 1 '\",\n            \"        'from dual')\"])\n\n    def test_php(self):\n        sql = 'select * from foo;'\n        f = lambda sql: sqlparse.format(sql, output_format='php')\n        assert f(sql) == '$sql = \"select * from foo;\";'\n        f = lambda sql: sqlparse.format(sql, output_format='php',\n                                        reindent=True)\n        assert f(sql) == '\\n'.join([\n            '$sql  = \"select * \";',\n            '$sql .= \"from foo;\";'])\n\n    def test_sql(self):\n        # \"sql\" is an allowed option but has no effect\n        sql = 'select * from foo;'\n        f = lambda sql: sqlparse.format(sql, output_format='sql')\n        assert f(sql) == 'select * from foo;'\n\n    def test_invalid_option(self):\n        sql = 'select * from foo;'\n        with pytest.raises(SQLParseError):\n            sqlparse.format(sql, output_format='foo')\n\n\ndef test_format_column_ordering():\n    # issue89\n    sql = 'select * from foo order by c1 desc, c2, c3;'\n    formatted = sqlparse.format(sql, reindent=True)\n    expected = '\\n'.join([\n        'select *',\n        'from foo',\n        'order by c1 desc,',\n        '         c2,',\n        '         c3;'])\n    assert formatted == expected\n\n\ndef test_truncate_strings():\n    sql = \"update foo set value = '{}';\".format('x' * 1000)\n    formatted = sqlparse.format(sql, truncate_strings=10)\n    assert formatted == \"update foo set value = 'xxxxxxxxxx[...]';\"\n    formatted = sqlparse.format(sql, truncate_strings=3, truncate_char='YYY')\n    assert formatted == \"update foo set value = 'xxxYYY';\"\n\n\n@pytest.mark.parametrize('option', ['bar', -1, 0])\ndef test_truncate_strings_invalid_option2(option):\n    with pytest.raises(SQLParseError):\n        sqlparse.format('foo', truncate_strings=option)\n\n\n@pytest.mark.parametrize('sql', [\n    'select verrrylongcolumn from foo',\n    'select \"verrrylongcolumn\" from \"foo\"'])\ndef test_truncate_strings_doesnt_truncate_identifiers(sql):\n    formatted = sqlparse.format(sql, truncate_strings=2)\n    assert formatted == sql\n\n\ndef test_having_produces_newline():\n    sql = ('select * from foo, bar where bar.id = foo.bar_id '\n           'having sum(bar.value) > 100')\n    formatted = sqlparse.format(sql, reindent=True)\n    expected = [\n        'select *',\n        'from foo,',\n        '     bar',\n        'where bar.id = foo.bar_id',\n        'having sum(bar.value) > 100']\n    assert formatted == '\\n'.join(expected)\n\n\n@pytest.mark.parametrize('right_margin', ['ten', 2])\ndef test_format_right_margin_invalid_option(right_margin):\n    with pytest.raises(SQLParseError):\n        sqlparse.format('foo', right_margin=right_margin)\n\n\n@pytest.mark.xfail(reason=\"Needs fixing\")\ndef test_format_right_margin():\n    # TODO: Needs better test, only raises exception right now\n    sqlparse.format('foo', right_margin=\"79\")\n"], "filenames": ["sqlparse/filters/others.py", "tests/test_format.py"], "buggy_code_start_loc": [25, 85], "buggy_code_end_loc": [26, 85], "fixing_code_start_loc": [25, 86], "fixing_code_end_loc": [29, 103], "type": "CWE-400", "message": "sqlparse is a non-validating SQL parser module for Python. In sqlparse versions 0.4.0 and 0.4.1 there is a regular Expression Denial of Service in sqlparse vulnerability. The regular expression may cause exponential backtracking on strings containing many repetitions of '\\r\\n' in SQL comments. Only the formatting feature that removes comments from SQL statements is affected by this regular expression. As a workaround don't use the sqlformat.format function with keyword strip_comments=True or the --strip-comments command line flag when using the sqlformat command line tool. The issues has been fixed in sqlparse 0.4.2.", "other": {"cve": {"id": "CVE-2021-32839", "sourceIdentifier": "security-advisories@github.com", "published": "2021-09-20T17:15:09.067", "lastModified": "2021-09-29T15:04:05.190", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "sqlparse is a non-validating SQL parser module for Python. In sqlparse versions 0.4.0 and 0.4.1 there is a regular Expression Denial of Service in sqlparse vulnerability. The regular expression may cause exponential backtracking on strings containing many repetitions of '\\r\\n' in SQL comments. Only the formatting feature that removes comments from SQL statements is affected by this regular expression. As a workaround don't use the sqlformat.format function with keyword strip_comments=True or the --strip-comments command line flag when using the sqlformat command line tool. The issues has been fixed in sqlparse 0.4.2."}, {"lang": "es", "value": "sqlparse es un m\u00f3dulo analizador de SQL no comprobable para Python. En las versiones 0.4.0 y 0.4.1 de sqlparse, se presenta una vulnerabilidad de Denegaci\u00f3n de Servicio por Expresi\u00f3n regular en sqlparse. La expresi\u00f3n regular puede causar un retroceso exponencial en las cadenas que contienen muchas repeticiones de \"\\r\\n\" en los comentarios SQL. S\u00f3lo la funci\u00f3n de formato que elimina los comentarios de las sentencias SQL esta afectada por esta expresi\u00f3n regular. Como soluci\u00f3n, no use la funci\u00f3n sqlformat.format con la palabra clave strip_comments=True o el indicador de l\u00ednea de comandos --strip-comments cuando use la herramienta de l\u00ednea de comandos sqlformat. Este problema ha sido corregido en sqlparse versi\u00f3n 0.4.2"}], "metrics": {"cvssMetricV31": [{"source": "security-advisories@github.com", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sqlparse_project:sqlparse:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.4.0", "versionEndExcluding": "0.4.2", "matchCriteriaId": "77AA7C67-AD7E-4F5A-9F4D-577B7670EBE8"}]}]}], "references": [{"url": "https://github.com/andialbrecht/sqlparse/commit/8238a9e450ed1524e40cb3a8b0b3c00606903aeb", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/andialbrecht/sqlparse/security/advisories/GHSA-p5w8-wqhj-9hhf", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/andialbrecht/sqlparse/commit/8238a9e450ed1524e40cb3a8b0b3c00606903aeb"}}