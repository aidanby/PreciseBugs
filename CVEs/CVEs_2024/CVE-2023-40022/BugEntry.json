{"buggy_code": ["// SPDX-FileCopyrightText: 1989-1999 Free Software Foundation, Inc.\n// SPDX-License-Identifier: GPL-2.0-or-later\n\n/* Demangler for GNU C++\n   Copyright 1989, 91, 94, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.\n   Written by James Clark (jjc@jclark.uucp)\n   Rewritten by Fred Fish (fnf@cygnus.com) for ARM and Lucid demangling\n   Modified by Satish Pai (pai@apollo.hp.com) for HP demangling\n\nThis file is part of the libiberty library.\nLibiberty is free software; you can redistribute it and/or\nmodify it under the terms of the GNU Library General Public\nLicense as published by the Free Software Foundation; either\nversion 2 of the License, or (at your option) any later version.\n\nLibiberty is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nLibrary General Public License for more details.\n\nYou should have received a copy of the GNU Library General Public\nLicense along with libiberty; see the file COPYING.LIB.  If\nnot, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n/* This file exports two functions; cplus_mangle_opname and cplus_demangle_v2.\n\n   This file imports malloc and realloc, which are like malloc and\n   realloc except that they generate a fatal error if there is no\n   available memory.  */\n\n/* This file lives in both GCC and libiberty.  When making changes, please\n   try not to break either.  */\n\n#include <ctype.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"cplus-dem.h\"\n#undef CURRENT_DEMANGLING_STYLE\n#define CURRENT_DEMANGLING_STYLE work->options\n\n#define min(X, Y) (((X) < (Y)) ? (X) : (Y))\n\nstatic const char *mystrstr PARAMS((const char *, const char *));\n\nstatic const char *\n\tmystrstr(s1, s2)\n\t\tconst char *s1,\n\t*s2;\n{\n\tregister const char *p = s1;\n\tregister int len = strlen(s2);\n\n\tfor (; (p = strchr(p, *s2)) != 0; p++) {\n\t\tif (strncmp(p, s2, len) == 0) {\n\t\t\treturn (p);\n\t\t}\n\t}\n\treturn (0);\n}\n\n/* In order to allow a single demangler executable to demangle strings\n   using various common values of CPLUS_MARKER, as well as any specific\n   one set at compile time, we maintain a string containing all the\n   commonly used ones, and check to see if the marker we are looking for\n   is in that string.  CPLUS_MARKER is usually '$' on systems where the\n   assembler can deal with that.  Where the assembler can't, it's usually\n   '.' (but on many systems '.' is used for other things).  We put the\n   current defined CPLUS_MARKER first (which defaults to '$'), followed\n   by the next most common value, followed by an explicit '$' in case\n   the value of CPLUS_MARKER is not '$'.\n\n   We could avoid this if we could just get g++ to tell us what the actual\n   cplus marker character is as part of the debug information, perhaps by\n   ensuring that it is the character that terminates the gcc<n>_compiled\n   marker symbol (FIXME).  */\n\n#if !defined(CPLUS_MARKER)\n#define CPLUS_MARKER '$'\n#endif\n\nenum demangling_styles current_demangling_style = gnu_demangling;\n\nstatic char cplus_markers[] = { CPLUS_MARKER, '.', '$', '\\0' };\n\nstatic char char_str[2] = { '\\000', '\\000' };\n\ntypedef struct string /* Beware: these aren't required to be */\n{ /*  '\\0' terminated.  */\n\tchar *b; /* pointer to start of string */\n\tchar *p; /* pointer after last character */\n\tchar *e; /* pointer after end of allocated space */\n} string;\n\n/* Stuff that is shared between sub-routines.\n   Using a shared structure allows cplus_demangle_v2 to be reentrant.  */\n\nstruct work_stuff {\n\tint options;\n\tchar **typevec;\n\tchar **ktypevec;\n\tchar **btypevec;\n\tint numk;\n\tint numb;\n\tint ksize;\n\tint bsize;\n\tint ntypes;\n\tint typevec_size;\n\tint constructor;\n\tint destructor;\n\tint static_type; /* A static member function */\n\tint temp_start; /* index in demangled to start of template args */\n\tint type_quals; /* The type qualifiers.  */\n\tint dllimported; /* Symbol imported from a PE DLL */\n\tchar **tmpl_argvec; /* Template function arguments. */\n\tint ntmpl_args; /* The number of template function arguments. */\n\tint forgetting_types; /* Nonzero if we are not remembering the types\n\t\t\t\t we see.  */\n\tstring *previous_argument; /* The last function argument demangled.  */\n\tint nrepeats; /* The number of times to repeat the previous\n\t\t\t argument.  */\n};\n\n#define PRINT_ANSI_QUALIFIERS (work->options & DMGL_ANSI)\n#define PRINT_ARG_TYPES       (work->options & DMGL_PARAMS)\n\nstatic const struct optable {\n\tconst char *in;\n\tconst char *out;\n\tint flags;\n} optable[] = {\n\t{ \"nw\", \" new\", DMGL_ANSI }, /* new (1.92,\t ansi) */\n\t{ \"dl\", \" delete\", DMGL_ANSI }, /* new (1.92,\t ansi) */\n\t{ \"new\", \" new\", 0 }, /* old (1.91,\t and 1.x) */\n\t{ \"delete\", \" delete\", 0 }, /* old (1.91,\t and 1.x) */\n\t{ \"vn\", \" new []\", DMGL_ANSI }, /* GNU, pending ansi */\n\t{ \"vd\", \" delete []\", DMGL_ANSI }, /* GNU, pending ansi */\n\t{ \"as\", \"=\", DMGL_ANSI }, /* ansi */\n\t{ \"ne\", \"!=\", DMGL_ANSI }, /* old, ansi */\n\t{ \"eq\", \"==\", DMGL_ANSI }, /* old,\tansi */\n\t{ \"ge\", \">=\", DMGL_ANSI }, /* old,\tansi */\n\t{ \"gt\", \">\", DMGL_ANSI }, /* old,\tansi */\n\t{ \"le\", \"<=\", DMGL_ANSI }, /* old,\tansi */\n\t{ \"lt\", \"<\", DMGL_ANSI }, /* old,\tansi */\n\t{ \"plus\", \"+\", 0 }, /* old */\n\t{ \"pl\", \"+\", DMGL_ANSI }, /* ansi */\n\t{ \"apl\", \"+=\", DMGL_ANSI }, /* ansi */\n\t{ \"minus\", \"-\", 0 }, /* old */\n\t{ \"mi\", \"-\", DMGL_ANSI }, /* ansi */\n\t{ \"ami\", \"-=\", DMGL_ANSI }, /* ansi */\n\t{ \"mult\", \"*\", 0 }, /* old */\n\t{ \"ml\", \"*\", DMGL_ANSI }, /* ansi */\n\t{ \"amu\", \"*=\", DMGL_ANSI }, /* ansi (ARM/Lucid) */\n\t{ \"aml\", \"*=\", DMGL_ANSI }, /* ansi (GNU/g++) */\n\t{ \"convert\", \"+\", 0 }, /* old (unary +) */\n\t{ \"negate\", \"-\", 0 }, /* old (unary -) */\n\t{ \"trunc_mod\", \"%\", 0 }, /* old */\n\t{ \"md\", \"%\", DMGL_ANSI }, /* ansi */\n\t{ \"amd\", \"%=\", DMGL_ANSI }, /* ansi */\n\t{ \"trunc_div\", \"/\", 0 }, /* old */\n\t{ \"dv\", \"/\", DMGL_ANSI }, /* ansi */\n\t{ \"adv\", \"/=\", DMGL_ANSI }, /* ansi */\n\t{ \"truth_andif\", \"&&\", 0 }, /* old */\n\t{ \"aa\", \"&&\", DMGL_ANSI }, /* ansi */\n\t{ \"truth_orif\", \"||\", 0 }, /* old */\n\t{ \"oo\", \"||\", DMGL_ANSI }, /* ansi */\n\t{ \"truth_not\", \"!\", 0 }, /* old */\n\t{ \"nt\", \"!\", DMGL_ANSI }, /* ansi */\n\t{ \"postincrement\", \"++\", 0 }, /* old */\n\t{ \"pp\", \"++\", DMGL_ANSI }, /* ansi */\n\t{ \"postdecrement\", \"--\", 0 }, /* old */\n\t{ \"mm\", \"--\", DMGL_ANSI }, /* ansi */\n\t{ \"bit_ior\", \"|\", 0 }, /* old */\n\t{ \"or\", \"|\", DMGL_ANSI }, /* ansi */\n\t{ \"aor\", \"|=\", DMGL_ANSI }, /* ansi */\n\t{ \"bit_xor\", \"^\", 0 }, /* old */\n\t{ \"er\", \"^\", DMGL_ANSI }, /* ansi */\n\t{ \"aer\", \"^=\", DMGL_ANSI }, /* ansi */\n\t{ \"bit_and\", \"&\", 0 }, /* old */\n\t{ \"ad\", \"&\", DMGL_ANSI }, /* ansi */\n\t{ \"aad\", \"&=\", DMGL_ANSI }, /* ansi */\n\t{ \"bit_not\", \"~\", 0 }, /* old */\n\t{ \"co\", \"~\", DMGL_ANSI }, /* ansi */\n\t{ \"call\", \"()\", 0 }, /* old */\n\t{ \"cl\", \"()\", DMGL_ANSI }, /* ansi */\n\t{ \"alshift\", \"<<\", 0 }, /* old */\n\t{ \"ls\", \"<<\", DMGL_ANSI }, /* ansi */\n\t{ \"als\", \"<<=\", DMGL_ANSI }, /* ansi */\n\t{ \"arshift\", \">>\", 0 }, /* old */\n\t{ \"rs\", \">>\", DMGL_ANSI }, /* ansi */\n\t{ \"ars\", \">>=\", DMGL_ANSI }, /* ansi */\n\t{ \"component\", \"->\", 0 }, /* old */\n\t{ \"pt\", \"->\", DMGL_ANSI }, /* ansi; Lucid C++ form */\n\t{ \"rf\", \"->\", DMGL_ANSI }, /* ansi; ARM/GNU form */\n\t{ \"indirect\", \"*\", 0 }, /* old */\n\t{ \"method_call\", \"->()\", 0 }, /* old */\n\t{ \"addr\", \"&\", 0 }, /* old (unary &) */\n\t{ \"array\", \"[]\", 0 }, /* old */\n\t{ \"vc\", \"[]\", DMGL_ANSI }, /* ansi */\n\t{ \"compound\", \", \", 0 }, /* old */\n\t{ \"cm\", \", \", DMGL_ANSI }, /* ansi */\n\t{ \"cond\", \"?:\", 0 }, /* old */\n\t{ \"cn\", \"?:\", DMGL_ANSI }, /* pseudo-ansi */\n\t{ \"max\", \">?\", 0 }, /* old */\n\t{ \"mx\", \">?\", DMGL_ANSI }, /* pseudo-ansi */\n\t{ \"min\", \"<?\", 0 }, /* old */\n\t{ \"mn\", \"<?\", DMGL_ANSI }, /* pseudo-ansi */\n\t{ \"nop\", \"\", 0 }, /* old (for operator=) */\n\t{ \"rm\", \"->*\", DMGL_ANSI }, /* ansi */\n\t{ \"sz\", \"sizeof \", DMGL_ANSI } /* pseudo-ansi */\n};\n\n/* These values are used to indicate the various type varieties.\n   They are all non-zero so that they can be used as `success'\n   values.  */\ntypedef enum type_kind_t {\n\ttk_none,\n\ttk_pointer,\n\ttk_reference,\n\ttk_integral,\n\ttk_bool,\n\ttk_char,\n\ttk_real\n} type_kind_t;\n\n#define STRING_EMPTY(str) ((str)->b == (str)->p)\n#define PREPEND_BLANK(str) \\\n\t{ \\\n\t\tif (!STRING_EMPTY(str)) \\\n\t\t\tstring_prepend(str, \" \"); \\\n\t}\n#define APPEND_BLANK(str) \\\n\t{ \\\n\t\tif (!STRING_EMPTY(str)) \\\n\t\t\tstring_append(str, \" \"); \\\n\t}\n#define LEN_STRING(str) ((STRING_EMPTY(str)) ? 0 : ((str)->p - (str)->b))\n\n/* The scope separator appropriate for the language being demangled.  */\n\n#define SCOPE_STRING(work) ((work->options & DMGL_JAVA) ? \".\" : \"::\")\n\n#define ARM_VTABLE_STRING \"__vtbl__\" /* Lucid/ARM virtual table prefix */\n#define ARM_VTABLE_STRLEN 8 /* strlen (ARM_VTABLE_STRING) */\n\n/* Prototypes for local functions */\n\nstatic char *\n\tmop_up PARAMS((struct work_stuff *, string *, int));\n\nstatic void\n\tsquangle_mop_up PARAMS((struct work_stuff *));\n\n#if 0\nstatic int\ndemangle_method_args PARAMS ((struct work_stuff *, const char **, string *));\n#endif\n\nstatic char *\n\tinternal_cplus_demangle PARAMS((struct work_stuff *, const char *));\n\nstatic int\n\tdemangle_template_template_parm PARAMS((struct work_stuff * work,\n\t\tconst char **, string *));\n\nstatic int\n\tdemangle_template PARAMS((struct work_stuff * work, const char **, string *,\n\t\tstring *, int, int));\n\nstatic int\n\tarm_pt PARAMS((struct work_stuff *, const char *, int, const char **,\n\t\tconst char **));\n\nstatic int\n\tdemangle_class_name PARAMS((struct work_stuff *, const char **, string *));\n\nstatic int\n\tdemangle_qualified PARAMS((struct work_stuff *, const char **, string *,\n\t\tint, int));\n\nstatic int\n\tdemangle_class PARAMS((struct work_stuff *, const char **, string *));\n\nstatic int\n\tdemangle_fund_type PARAMS((struct work_stuff *, const char **, string *));\n\nstatic int\n\tdemangle_signature PARAMS((struct work_stuff *, const char **, string *));\n\nstatic int\n\tdemangle_prefix PARAMS((struct work_stuff *, const char **, string *));\n\nstatic int\n\tgnu_special PARAMS((struct work_stuff *, const char **, string *));\n\nstatic int\n\tarm_special PARAMS((const char **, string *));\n\nstatic void\n\tstring_need PARAMS((string *, int));\n\nstatic void\n\tstring_delete PARAMS((string *));\n\nstatic void\n\tstring_init PARAMS((string *));\n\nstatic void\n\tstring_clear PARAMS((string *));\n\n#if 0\nstatic int\nstring_empty PARAMS ((string *));\n#endif\n\nstatic void\n\tstring_append PARAMS((string *, const char *));\n\nstatic void\n\tstring_appends PARAMS((string *, string *));\n\nstatic void\n\tstring_appendn PARAMS((string *, const char *, int));\n\nstatic void\n\tstring_prepend PARAMS((string *, const char *));\n\nstatic void\n\tstring_prependn PARAMS((string *, const char *, int));\n\nstatic int\n\tget_count PARAMS((const char **, int *));\n\nstatic int\n\tconsume_count PARAMS((const char **));\n\nstatic int\n\tconsume_count_with_underscores PARAMS((const char **));\n\nstatic int\n\tdemangle_args PARAMS((struct work_stuff *, const char **, string *));\n\nstatic int\n\tdemangle_nested_args PARAMS((struct work_stuff *, const char **, string *));\n\nstatic int\n\tdo_type PARAMS((struct work_stuff *, const char **, string *));\n\nstatic int\n\tdo_arg PARAMS((struct work_stuff *, const char **, string *));\n\nstatic void\n\tdemangle_function_name PARAMS((struct work_stuff *, const char **, string *,\n\t\tconst char *));\n\nstatic void\n\tremember_type PARAMS((struct work_stuff *, const char *, int));\n\nstatic void\n\tremember_Btype PARAMS((struct work_stuff *, const char *, int, int));\n\nstatic int\n\tregister_Btype PARAMS((struct work_stuff *));\n\nstatic void\n\tremember_Ktype PARAMS((struct work_stuff *, const char *, int));\n\nstatic void\n\tforget_types PARAMS((struct work_stuff *));\n\nstatic void\n\tforget_B_and_K_types PARAMS((struct work_stuff *));\n\nstatic void\n\tstring_prepends PARAMS((string *, string *));\n\nstatic int\n\tdemangle_template_value_parm PARAMS((struct work_stuff *, const char **,\n\t\tstring *, type_kind_t));\n\nstatic int\n\tdo_hpacc_template_const_value PARAMS((struct work_stuff *, const char **, string *));\n\nstatic int\n\tdo_hpacc_template_literal PARAMS((struct work_stuff *, const char **, string *));\n\nstatic int\n\tsnarf_numeric_literal PARAMS((const char **, string *));\n\n/* There is a TYPE_QUAL value for each type qualifier.  They can be\n   combined by bitwise-or to form the complete set of qualifiers for a\n   type.  */\n\n#define TYPE_UNQUALIFIED   0x0\n#define TYPE_QUAL_CONST    0x1\n#define TYPE_QUAL_VOLATILE 0x2\n#define TYPE_QUAL_RESTRICT 0x4\n\nstatic int\n\tcode_for_qualifier PARAMS((int));\n\nstatic const char *\n\tqualifier_string PARAMS((int));\n\nstatic const char *\n\tdemangle_qualifier PARAMS((int));\n\n/* Translate count to integer, consuming tokens in the process.\n   Conversion terminates on the first non-digit character.\n\n   Trying to consume something that isn't a count results in no\n   consumption of input and a return of -1.\n\n   Overflow consumes the rest of the digits, and returns -1.  */\n\nstatic int\n\tconsume_count(type)\n\t\tconst char **type;\n{\n\tint count = 0;\n\n\tif (!isdigit((unsigned char)**type))\n\t\treturn -1;\n\n\twhile (isdigit((unsigned char)**type)) {\n\t\tcount *= 10;\n\n\t\t/* Check for overflow.\n\t\t   We assume that count is represented using two's-complement;\n\t\t   no power of two is divisible by ten, so if an overflow occurs\n\t\t   when multiplying by ten, the result will not be a multiple of\n\t\t   ten.  */\n\t\tif ((count % 10) != 0) {\n\t\t\twhile (isdigit((unsigned char)**type))\n\t\t\t\t(*type)++;\n\t\t\treturn -1;\n\t\t}\n\n\t\tcount += **type - '0';\n\t\t(*type)++;\n\t}\n\n\treturn (count);\n}\n\n/* Like consume_count, but for counts that are preceded and followed\n   by '_' if they are greater than 10.  Also, -1 is returned for\n   failure, since 0 can be a valid value.  */\n\nstatic int\n\tconsume_count_with_underscores(mangled)\n\t\tconst char **mangled;\n{\n\tint idx;\n\n\tif (**mangled == '_') {\n\t\t(*mangled)++;\n\t\tif (!isdigit((unsigned char)**mangled))\n\t\t\treturn -1;\n\n\t\tidx = consume_count(mangled);\n\t\tif (**mangled != '_')\n\t\t\t/* The trailing underscore was missing. */\n\t\t\treturn -1;\n\n\t\t(*mangled)++;\n\t} else {\n\t\tif (**mangled < '0' || **mangled > '9')\n\t\t\treturn -1;\n\n\t\tidx = **mangled - '0';\n\t\t(*mangled)++;\n\t}\n\n\treturn idx;\n}\n\n/* C is the code for a type-qualifier.  Return the TYPE_QUAL\n   corresponding to this qualifier.  */\n\nstatic int\ncode_for_qualifier(c)\nint c;\n{\n\tswitch (c) {\n\tcase 'C':\n\t\treturn TYPE_QUAL_CONST;\n\n\tcase 'V':\n\t\treturn TYPE_QUAL_VOLATILE;\n\n\tcase 'u':\n\t\treturn TYPE_QUAL_RESTRICT;\n\n\tdefault:\n\t\treturn TYPE_UNQUALIFIED;\n\t}\n}\n\n/* Return the string corresponding to the qualifiers given by\n   TYPE_QUALS.  */\n\nstatic const char *\nqualifier_string(type_quals)\nint type_quals;\n{\n\tswitch (type_quals) {\n\tcase TYPE_UNQUALIFIED:\n\t\treturn \"\";\n\n\tcase TYPE_QUAL_CONST:\n\t\treturn \"const\";\n\n\tcase TYPE_QUAL_VOLATILE:\n\t\treturn \"volatile\";\n\n\tcase TYPE_QUAL_RESTRICT:\n\t\treturn \"__restrict\";\n\n\tcase TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE:\n\t\treturn \"const volatile\";\n\n\tcase TYPE_QUAL_CONST | TYPE_QUAL_RESTRICT:\n\t\treturn \"const __restrict\";\n\n\tcase TYPE_QUAL_VOLATILE | TYPE_QUAL_RESTRICT:\n\t\treturn \"volatile __restrict\";\n\n\tcase TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE | TYPE_QUAL_RESTRICT:\n\t\treturn \"const volatile __restrict\";\n\n\tdefault:\n\t\treturn \"\";\n\t}\n}\n\n/* C is the code for a type-qualifier.  Return the string\n   corresponding to this qualifier.  This function should only be\n   called with a valid qualifier code.  */\n\nstatic const char *\ndemangle_qualifier(c)\nint c;\n{\n\treturn qualifier_string(code_for_qualifier(c));\n}\n\n/* char *cplus_demangle_v2 (const char *mangled, int options)\n\n   If MANGLED is a mangled function name produced by GNU C++, then\n   a pointer to a malloced string giving a C++ representation\n   of the name will be returned; otherwise NULL will be returned.\n   It is the caller's responsibility to free the string which\n   is returned.\n\n   The OPTIONS arg may contain one or more of the following bits:\n\n\tDMGL_ANSI\tANSI qualifiers such as `const' and `void' are\n\t\t\tincluded.\n\tDMGL_PARAMS\tFunction parameters are included.\n\n   For example,\n\n   cplus_demangle_v2 (\"foo__1Ai\", DMGL_PARAMS)\t\t=> \"A::foo(int)\"\n   cplus_demangle_v2 (\"foo__1Ai\", DMGL_PARAMS | DMGL_ANSI)\t=> \"A::foo(int)\"\n   cplus_demangle_v2 (\"foo__1Ai\", 0)\t\t\t=> \"A::foo\"\n\n   cplus_demangle_v2 (\"foo__1Afe\", DMGL_PARAMS)\t\t=> \"A::foo(float,...)\"\n   cplus_demangle_v2 (\"foo__1Afe\", DMGL_PARAMS | DMGL_ANSI)=> \"A::foo(float,...)\"\n   cplus_demangle_v2 (\"foo__1Afe\", 0)\t\t\t=> \"A::foo\"\n\n   Note that any leading underscores, or other such characters prepended by\n   the compilation system, are presumed to have already been stripped from\n   MANGLED.  */\n\nchar *\n\tcplus_demangle_v2(mangled, options)\n\t\tconst char *mangled;\nint options;\n{\n\tchar *ret;\n\tstruct work_stuff work[1];\n\tmemset((char *)work, 0, sizeof(work));\n\twork->options = options;\n\tif ((work->options & DMGL_STYLE_MASK) == 0)\n\t\twork->options |= (int)current_demangling_style & DMGL_STYLE_MASK;\n\n\tret = internal_cplus_demangle(work, mangled);\n\tsquangle_mop_up(work);\n\treturn (ret);\n}\n\n/* This function performs most of what cplus_demangle_v2 use to do, but\n   to be able to demangle a name with a B, K or n code, we need to\n   have a longer term memory of what types have been seen. The original\n   now intializes and cleans up the squangle code info, while internal\n   calls go directly to this routine to avoid resetting that info. */\n\nstatic char *\ninternal_cplus_demangle(work, mangled)\nstruct work_stuff *work;\nconst char *mangled;\n{\n\n\tstring decl;\n\tint success = 0;\n\tchar *demangled = NULL;\n\tint s1, s2, s3, s4;\n\ts1 = work->constructor;\n\ts2 = work->destructor;\n\ts3 = work->static_type;\n\ts4 = work->type_quals;\n\twork->constructor = work->destructor = 0;\n\twork->type_quals = TYPE_UNQUALIFIED;\n\twork->dllimported = 0;\n\n\tif ((mangled != NULL) && (*mangled != '\\0')) {\n\t\tstring_init(&decl);\n\n\t\t/* First check to see if gnu style demangling is active and if the\n\t\t   string to be demangled contains a CPLUS_MARKER.  If so, attempt to\n\t\t   recognize one of the gnu special forms rather than looking for a\n\t\t   standard prefix.  In particular, don't worry about whether there\n\t\t   is a \"__\" string in the mangled string.  Consider \"_$_5__foo\" for\n\t\t   example.  */\n\n\t\tif ((AUTO_DEMANGLING || GNU_DEMANGLING)) {\n\t\t\tsuccess = gnu_special(work, &mangled, &decl);\n\t\t}\n\t\tif (!success) {\n\t\t\tsuccess = demangle_prefix(work, &mangled, &decl);\n\t\t}\n\t\tif (success && (*mangled != '\\0')) {\n\t\t\tsuccess = demangle_signature(work, &mangled, &decl);\n\t\t}\n\t\tif (work->constructor == 2) {\n\t\t\tstring_prepend(&decl, \"global constructors keyed to \");\n\t\t\twork->constructor = 0;\n\t\t} else if (work->destructor == 2) {\n\t\t\tstring_prepend(&decl, \"global destructors keyed to \");\n\t\t\twork->destructor = 0;\n\t\t} else if (work->dllimported == 1) {\n\t\t\tstring_prepend(&decl, \"import stub for \");\n\t\t\twork->dllimported = 0;\n\t\t}\n\t\tdemangled = mop_up(work, &decl, success);\n\t}\n\twork->constructor = s1;\n\twork->destructor = s2;\n\twork->static_type = s3;\n\twork->type_quals = s4;\n\treturn (demangled);\n}\n\n/* Clear out and squangling related storage */\nstatic void\n\tsquangle_mop_up(work) struct work_stuff *work;\n{\n\t/* clean up the B and K type mangling types. */\n\tforget_B_and_K_types(work);\n\tif (work->btypevec != NULL) {\n\t\tfree((char *)work->btypevec);\n\t}\n\tif (work->ktypevec != NULL) {\n\t\tfree((char *)work->ktypevec);\n\t}\n}\n\n/* Clear out any mangled storage */\n\nstatic char *\nmop_up(work, declp, success)\nstruct work_stuff *work;\nstring *declp;\nint success;\n{\n\tchar *demangled = NULL;\n\n\t/* Discard the remembered types, if any.  */\n\n\tforget_types(work);\n\tif (work->typevec != NULL) {\n\t\tfree((char *)work->typevec);\n\t\twork->typevec = NULL;\n\t\twork->typevec_size = 0;\n\t}\n\tif (work->tmpl_argvec) {\n\t\tint i;\n\n\t\tfor (i = 0; i < work->ntmpl_args; i++)\n\t\t\tif (work->tmpl_argvec[i])\n\t\t\t\tfree((char *)work->tmpl_argvec[i]);\n\n\t\tfree((char *)work->tmpl_argvec);\n\t\twork->tmpl_argvec = NULL;\n\t}\n\tif (work->previous_argument) {\n\t\tstring_delete(work->previous_argument);\n\t\tfree((char *)work->previous_argument);\n\t\twork->previous_argument = NULL;\n\t}\n\n\t/* If demangling was successful, ensure that the demangled string is null\n\t   terminated and return it.  Otherwise, free the demangling decl.  */\n\n\tif (!success) {\n\t\tstring_delete(declp);\n\t} else {\n\t\tstring_appendn(declp, \"\", 1);\n\t\tdemangled = declp->b;\n\t}\n\treturn (demangled);\n}\n\n/*\n\nLOCAL FUNCTION\n\n\tdemangle_signature -- demangle the signature part of a mangled name\n\nSYNOPSIS\n\n\tstatic int\n\tdemangle_signature (struct work_stuff *work, const char **mangled,\n\t\t\t    string *declp);\n\nDESCRIPTION\n\n\tConsume and demangle the signature portion of the mangled name.\n\n\tDECLP is the string where demangled output is being built.  At\n\tentry it contains the demangled root name from the mangled name\n\tprefix.  I.E. either a demangled operator name or the root function\n\tname.  In some special cases, it may contain nothing.\n\n\t*MANGLED points to the current unconsumed location in the mangled\n\tname.  As tokens are consumed and demangling is performed, the\n\tpointer is updated to continuously point at the next token to\n\tbe consumed.\n\n\tDemangling GNU style mangled names is nasty because there is no\n\texplicit token that marks the start of the outermost function\n\targument list.  */\n\nstatic int\ndemangle_signature(work, mangled, declp)\nstruct work_stuff *work;\nconst char **mangled;\nstring *declp;\n{\n\tint success = 1;\n\tint func_done = 0;\n\tint expect_func = 0;\n\tint expect_return_type = 0;\n\tconst char *oldmangled = NULL;\n\tstring trawname;\n\tstring tname;\n\n\twhile (success && (**mangled != '\\0')) {\n\t\tswitch (**mangled) {\n\t\tcase 'Q':\n\t\t\toldmangled = *mangled;\n\t\t\tsuccess = demangle_qualified(work, mangled, declp, 1, 0);\n\t\t\tif (success)\n\t\t\t\tremember_type(work, oldmangled, *mangled - oldmangled);\n\t\t\tif (AUTO_DEMANGLING || GNU_DEMANGLING)\n\t\t\t\texpect_func = 1;\n\t\t\toldmangled = NULL;\n\t\t\tbreak;\n\n\t\tcase 'K':\n\t\t\toldmangled = *mangled;\n\t\t\tsuccess = demangle_qualified(work, mangled, declp, 1, 0);\n\t\t\tif (AUTO_DEMANGLING || GNU_DEMANGLING) {\n\t\t\t\texpect_func = 1;\n\t\t\t}\n\t\t\toldmangled = NULL;\n\t\t\tbreak;\n\n\t\tcase 'S':\n\t\t\t/* Static member function */\n\t\t\tif (oldmangled == NULL) {\n\t\t\t\toldmangled = *mangled;\n\t\t\t}\n\t\t\t(*mangled)++;\n\t\t\twork->static_type = 1;\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\tcase 'V':\n\t\tcase 'u':\n\t\t\twork->type_quals |= code_for_qualifier(**mangled);\n\n\t\t\t/* a qualified member function */\n\t\t\tif (oldmangled == NULL)\n\t\t\t\toldmangled = *mangled;\n\t\t\t(*mangled)++;\n\t\t\tbreak;\n\n\t\tcase 'L':\n\t\t\t/* Local class name follows after \"Lnnn_\" */\n\t\t\tif (HP_DEMANGLING) {\n\t\t\t\twhile (**mangled && (**mangled != '_'))\n\t\t\t\t\t(*mangled)++;\n\t\t\t\tif (!**mangled)\n\t\t\t\t\tsuccess = 0;\n\t\t\t\telse\n\t\t\t\t\t(*mangled)++;\n\t\t\t} else\n\t\t\t\tsuccess = 0;\n\t\t\tbreak;\n\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\t\tif (oldmangled == NULL) {\n\t\t\t\toldmangled = *mangled;\n\t\t\t}\n\t\t\twork->temp_start = -1; /* uppermost call to demangle_class */\n\t\t\tsuccess = demangle_class(work, mangled, declp);\n\t\t\tif (success) {\n\t\t\t\tremember_type(work, oldmangled, *mangled - oldmangled);\n\t\t\t}\n\t\t\tif (AUTO_DEMANGLING || GNU_DEMANGLING || EDG_DEMANGLING) {\n\t\t\t\t/* EDG and others will have the \"F\", so we let the loop cycle\n\t\t\t\t   if we are looking at one. */\n\t\t\t\tif (**mangled != 'F')\n\t\t\t\t\texpect_func = 1;\n\t\t\t}\n\t\t\toldmangled = NULL;\n\t\t\tbreak;\n\n\t\tcase 'B': {\n\t\t\tstring s;\n\t\t\tsuccess = do_type(work, mangled, &s);\n\t\t\tif (success) {\n\t\t\t\tstring_append(&s, SCOPE_STRING(work));\n\t\t\t\tstring_prepends(declp, &s);\n\t\t\t}\n\t\t\toldmangled = NULL;\n\t\t\texpect_func = 1;\n\t\t} break;\n\n\t\tcase 'F':\n\t\t\t/* Function */\n\t\t\t/* ARM/HP style demangling includes a specific 'F' character after\n\t\t\t   the class name.  For GNU style, it is just implied.  So we can\n\t\t\t   safely just consume any 'F' at this point and be compatible\n\t\t\t   with either style.  */\n\n\t\t\toldmangled = NULL;\n\t\t\tfunc_done = 1;\n\t\t\t(*mangled)++;\n\n\t\t\t/* For lucid/ARM/HP style we have to forget any types we might\n\t\t\t   have remembered up to this point, since they were not argument\n\t\t\t   types.  GNU style considers all types seen as available for\n\t\t\t   back references.  See comment in demangle_args() */\n\n\t\t\tif (LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING) {\n\t\t\t\tforget_types(work);\n\t\t\t}\n\t\t\tsuccess = demangle_args(work, mangled, declp);\n\t\t\t/* After picking off the function args, we expect to either\n\t\t\t   find the function return type (preceded by an '_') or the\n\t\t\t   end of the string. */\n\t\t\tif (success && (AUTO_DEMANGLING || EDG_DEMANGLING) && **mangled == '_') {\n\t\t\t\t++(*mangled);\n\t\t\t\t/* At this level, we do not care about the return type. */\n\t\t\t\tsuccess = do_type(work, mangled, &tname);\n\t\t\t\tstring_delete(&tname);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t\t/* G++ Template */\n\t\t\tstring_init(&trawname);\n\t\t\tstring_init(&tname);\n\t\t\tif (oldmangled == NULL) {\n\t\t\t\toldmangled = *mangled;\n\t\t\t}\n\t\t\tsuccess = demangle_template(work, mangled, &tname,\n\t\t\t\t&trawname, 1, 1);\n\t\t\tif (success) {\n\t\t\t\tremember_type(work, oldmangled, *mangled - oldmangled);\n\t\t\t}\n\t\t\tstring_append(&tname, SCOPE_STRING(work));\n\n\t\t\tstring_prepends(declp, &tname);\n\t\t\tif (work->destructor & 1) {\n\t\t\t\tstring_prepend(&trawname, \"~\");\n\t\t\t\tstring_appends(declp, &trawname);\n\t\t\t\twork->destructor -= 1;\n\t\t\t}\n\t\t\tif ((work->constructor & 1) || (work->destructor & 1)) {\n\t\t\t\tstring_appends(declp, &trawname);\n\t\t\t\twork->constructor -= 1;\n\t\t\t}\n\t\t\tstring_delete(&trawname);\n\t\t\tstring_delete(&tname);\n\t\t\toldmangled = NULL;\n\t\t\texpect_func = 1;\n\t\t\tbreak;\n\n\t\tcase '_':\n\t\t\tif (GNU_DEMANGLING && expect_return_type) {\n\t\t\t\t/* Read the return type. */\n\t\t\t\tstring return_type;\n\t\t\t\tstring_init(&return_type);\n\n\t\t\t\t(*mangled)++;\n\t\t\t\tsuccess = do_type(work, mangled, &return_type);\n\t\t\t\tAPPEND_BLANK(&return_type);\n\n\t\t\t\tstring_prepends(declp, &return_type);\n\t\t\t\tstring_delete(&return_type);\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\t/* At the outermost level, we cannot have a return type specified,\n\t\t\t\t   so if we run into another '_' at this point we are dealing with\n\t\t\t\t   a mangled name that is either bogus, or has been mangled by\n\t\t\t\t   some algorithm we don't know how to deal with.  So just\n\t\t\t\t   reject the entire demangling.  */\n\t\t\t\t/* However, \"_nnn\" is an expected suffix for alternate entry point\n\t\t\t\t   numbered nnn for a function, with HP aCC, so skip over that\n\t\t\t\t   without reporting failure. pai/1997-09-04 */\n\t\t\t\tif (HP_DEMANGLING) {\n\t\t\t\t\t(*mangled)++;\n\t\t\t\t\twhile (**mangled && isdigit((unsigned char)**mangled))\n\t\t\t\t\t\t(*mangled)++;\n\t\t\t\t} else\n\t\t\t\t\tsuccess = 0;\n\t\t\tbreak;\n\n\t\tcase 'H':\n\t\t\tif (GNU_DEMANGLING) {\n\t\t\t\t/* A G++ template function.  Read the template arguments. */\n\t\t\t\tsuccess = demangle_template(work, mangled, declp, 0, 0,\n\t\t\t\t\t0);\n\t\t\t\tif (!(work->constructor & 1))\n\t\t\t\t\texpect_return_type = 1;\n\t\t\t\t(*mangled)++;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t/* fall through */\n\t\t\t{\n\t\t\t\t;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tif (AUTO_DEMANGLING || GNU_DEMANGLING) {\n\t\t\t\t/* Assume we have stumbled onto the first outermost function\n\t\t\t\t   argument token, and start processing args.  */\n\t\t\t\tfunc_done = 1;\n\t\t\t\tsuccess = demangle_args(work, mangled, declp);\n\t\t\t} else {\n\t\t\t\t/* Non-GNU demanglers use a specific token to mark the start\n\t\t\t\t   of the outermost function argument tokens.  Typically 'F',\n\t\t\t\t   for ARM/HP-demangling, for example.  So if we find something\n\t\t\t\t   we are not prepared for, it must be an error.  */\n\t\t\t\tsuccess = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t  if (AUTO_DEMANGLING || GNU_DEMANGLING)\n\t\t  */\n\t\t{\n\t\t\tif (success && expect_func) {\n\t\t\t\tfunc_done = 1;\n\t\t\t\tif (LUCID_DEMANGLING || ARM_DEMANGLING || EDG_DEMANGLING) {\n\t\t\t\t\tforget_types(work);\n\t\t\t\t}\n\t\t\t\tsuccess = demangle_args(work, mangled, declp);\n\t\t\t\t/* Since template include the mangling of their return types,\n\t\t\t\t   we must set expect_func to 0 so that we don't try do\n\t\t\t\t   demangle more arguments the next time we get here.  */\n\t\t\t\texpect_func = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (success && !func_done) {\n\t\tif (AUTO_DEMANGLING || GNU_DEMANGLING) {\n\t\t\t/* With GNU style demangling, bar__3foo is 'foo::bar(void)', and\n\t\t\t   bar__3fooi is 'foo::bar(int)'.  We get here when we find the\n\t\t\t   first case, and need to ensure that the '(void)' gets added to\n\t\t\t   the current declp.  Note that with ARM/HP, the first case\n\t\t\t   represents the name of a static data member 'foo::bar',\n\t\t\t   which is in the current declp, so we leave it alone.  */\n\t\t\tsuccess = demangle_args(work, mangled, declp);\n\t\t}\n\t}\n\tif (success && PRINT_ARG_TYPES) {\n\t\tif (work->static_type)\n\t\t\tstring_append(declp, \" static\");\n\t\tif (work->type_quals != TYPE_UNQUALIFIED) {\n\t\t\tAPPEND_BLANK(declp);\n\t\t\tstring_append(declp, qualifier_string(work->type_quals));\n\t\t}\n\t}\n\n\treturn (success);\n}\n\n#if 0\n\nstatic int\ndemangle_method_args (work, mangled, declp)\n     struct work_stuff *work;\n     const char **mangled;\n     string *declp;\n{\n  int success = 0;\n\n  if (work -> static_type)\n    {\n      string_append (declp, *mangled + 1);\n      *mangled += strlen (*mangled);\n      success = 1;\n    }\n  else\n    {\n      success = demangle_args (work, mangled, declp);\n    }\n  return (success);\n}\n\n#endif\n\nstatic int\ndemangle_template_template_parm(work, mangled, tname)\nstruct work_stuff *work;\nconst char **mangled;\nstring *tname;\n{\n\tint i;\n\tint r;\n\tint need_comma = 0;\n\tint success = 1;\n\tstring temp;\n\n\tstring_append(tname, \"template <\");\n\t/* get size of template parameter list */\n\tif (get_count(mangled, &r)) {\n\t\tfor (i = 0; i < r; i++) {\n\t\t\tif (need_comma) {\n\t\t\t\tstring_append(tname, \", \");\n\t\t\t}\n\n\t\t\t/* Z for type parameters */\n\t\t\tif (**mangled == 'Z') {\n\t\t\t\t(*mangled)++;\n\t\t\t\tstring_append(tname, \"class\");\n\t\t\t}\n\t\t\t/* z for template parameters */\n\t\t\telse if (**mangled == 'z') {\n\t\t\t\t(*mangled)++;\n\t\t\t\tsuccess =\n\t\t\t\t\tdemangle_template_template_parm(work, mangled, tname);\n\t\t\t\tif (!success) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* temp is initialized in do_type */\n\t\t\t\tsuccess = do_type(work, mangled, &temp);\n\t\t\t\tif (success) {\n\t\t\t\t\tstring_appends(tname, &temp);\n\t\t\t\t}\n\t\t\t\tstring_delete(&temp);\n\t\t\t\tif (!success) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tneed_comma = 1;\n\t\t}\n\t}\n\tif (tname->p[-1] == '>')\n\t\tstring_append(tname, \" \");\n\tstring_append(tname, \"> class\");\n\treturn (success);\n}\n\nstatic int\ndemangle_integral_value(work, mangled, s)\nstruct work_stuff *work;\nconst char **mangled;\nstring *s;\n{\n\tint success;\n\n\tif (**mangled == 'E') {\n\t\tint need_operator = 0;\n\n\t\tsuccess = 1;\n\t\tstring_appendn(s, \"(\", 1);\n\t\t(*mangled)++;\n\t\twhile (success && **mangled != 'W' && **mangled != '\\0') {\n\t\t\tif (need_operator) {\n\t\t\t\tsize_t i;\n\t\t\t\tsize_t len;\n\n\t\t\t\tsuccess = 0;\n\n\t\t\t\tlen = strlen(*mangled);\n\n\t\t\t\tfor (i = 0;\n\t\t\t\t\ti < sizeof(optable) / sizeof(optable[0]);\n\t\t\t\t\t++i) {\n\t\t\t\t\tsize_t l = strlen(optable[i].in);\n\n\t\t\t\t\tif (l <= len && memcmp(optable[i].in, *mangled, l) == 0) {\n\t\t\t\t\t\tstring_appendn(s, \" \", 1);\n\t\t\t\t\t\tstring_append(s, optable[i].out);\n\t\t\t\t\t\tstring_appendn(s, \" \", 1);\n\t\t\t\t\t\tsuccess = 1;\n\t\t\t\t\t\t(*mangled) += l;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!success)\n\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tneed_operator = 1;\n\n\t\t\tsuccess = demangle_template_value_parm(work, mangled, s,\n\t\t\t\ttk_integral);\n\t\t}\n\n\t\tif (**mangled != 'W')\n\t\t\tsuccess = 0;\n\t\telse {\n\t\t\tstring_appendn(s, \")\", 1);\n\t\t\t(*mangled)++;\n\t\t}\n\t} else if (**mangled == 'Q' || **mangled == 'K')\n\t\tsuccess = demangle_qualified(work, mangled, s, 0, 1);\n\telse {\n\t\tsuccess = 0;\n\n\t\tif (**mangled == 'm') {\n\t\t\tstring_appendn(s, \"-\", 1);\n\t\t\t(*mangled)++;\n\t\t}\n\t\twhile (isdigit((unsigned char)**mangled)) {\n\t\t\tstring_appendn(s, *mangled, 1);\n\t\t\t(*mangled)++;\n\t\t\tsuccess = 1;\n\t\t}\n\t}\n\n\treturn success;\n}\n\nstatic int\ndemangle_template_value_parm(work, mangled, s, tk)\nstruct work_stuff *work;\nconst char **mangled;\nstring *s;\ntype_kind_t tk;\n{\n\tint success = 1;\n\n\tif (**mangled == 'Y') {\n\t\t/* The next argument is a template parameter. */\n\t\tint idx;\n\n\t\t(*mangled)++;\n\t\tidx = consume_count_with_underscores(mangled);\n\t\tif (idx == -1 || (work->tmpl_argvec && idx >= work->ntmpl_args) || consume_count_with_underscores(mangled) == -1)\n\t\t\treturn -1;\n\t\tif (work->tmpl_argvec)\n\t\t\tstring_append(s, work->tmpl_argvec[idx]);\n\t\telse {\n\t\t\tchar buf[10];\n\t\t\tsprintf(buf, \"T%d\", idx);\n\t\t\tstring_append(s, buf);\n\t\t}\n\t} else if (tk == tk_integral)\n\t\tsuccess = demangle_integral_value(work, mangled, s);\n\telse if (tk == tk_char) {\n\t\tchar tmp[2];\n\t\tint val;\n\t\tif (**mangled == 'm') {\n\t\t\tstring_appendn(s, \"-\", 1);\n\t\t\t(*mangled)++;\n\t\t}\n\t\tstring_appendn(s, \"'\", 1);\n\t\tval = consume_count(mangled);\n\t\tif (val <= 0)\n\t\t\tsuccess = 0;\n\t\telse {\n\t\t\ttmp[0] = (char)val;\n\t\t\ttmp[1] = '\\0';\n\t\t\tstring_appendn(s, &tmp[0], 1);\n\t\t\tstring_appendn(s, \"'\", 1);\n\t\t}\n\t} else if (tk == tk_bool) {\n\t\tint val = consume_count(mangled);\n\t\tif (val == 0)\n\t\t\tstring_appendn(s, \"false\", 5);\n\t\telse if (val == 1)\n\t\t\tstring_appendn(s, \"true\", 4);\n\t\telse\n\t\t\tsuccess = 0;\n\t} else if (tk == tk_real) {\n\t\tif (**mangled == 'm') {\n\t\t\tstring_appendn(s, \"-\", 1);\n\t\t\t(*mangled)++;\n\t\t}\n\t\twhile (isdigit((unsigned char)**mangled)) {\n\t\t\tstring_appendn(s, *mangled, 1);\n\t\t\t(*mangled)++;\n\t\t}\n\t\tif (**mangled == '.') /* fraction */\n\t\t{\n\t\t\tstring_appendn(s, \".\", 1);\n\t\t\t(*mangled)++;\n\t\t\twhile (isdigit((unsigned char)**mangled)) {\n\t\t\t\tstring_appendn(s, *mangled, 1);\n\t\t\t\t(*mangled)++;\n\t\t\t}\n\t\t}\n\t\tif (**mangled == 'e') /* exponent */\n\t\t{\n\t\t\tstring_appendn(s, \"e\", 1);\n\t\t\t(*mangled)++;\n\t\t\twhile (isdigit((unsigned char)**mangled)) {\n\t\t\t\tstring_appendn(s, *mangled, 1);\n\t\t\t\t(*mangled)++;\n\t\t\t}\n\t\t}\n\t} else if (tk == tk_pointer || tk == tk_reference) {\n\t\tif (**mangled == 'Q')\n\t\t\tsuccess = demangle_qualified(work, mangled, s,\n\t\t\t\t/*isfuncname=*/0,\n\t\t\t\t/*append=*/1);\n\t\telse {\n\t\t\tint symbol_len = consume_count(mangled);\n\t\t\tif (symbol_len == -1)\n\t\t\t\treturn -1;\n\t\t\tif (symbol_len == 0)\n\t\t\t\tstring_appendn(s, \"0\", 1);\n\t\t\telse {\n\t\t\t\tchar *p = malloc(symbol_len + 1), *q;\n\t\t\t\tstrncpy(p, *mangled, symbol_len);\n\t\t\t\tp[symbol_len] = '\\0';\n\t\t\t\t/* We use cplus_demangle_v2 here, rather than\n\t\t\t\t   internal_cplus_demangle, because the name of the entity\n\t\t\t\t   mangled here does not make use of any of the squangling\n\t\t\t\t   or type-code information we have built up thus far; it is\n\t\t\t\t   mangled independently.  */\n\t\t\t\tq = cplus_demangle_v2(p, work->options);\n\t\t\t\tif (tk == tk_pointer)\n\t\t\t\t\tstring_appendn(s, \"&\", 1);\n\t\t\t\t/* FIXME: Pointer-to-member constants should get a\n\t\t\t\t   qualifying class name here.  */\n\t\t\t\tif (q) {\n\t\t\t\t\tstring_append(s, q);\n\t\t\t\t\tfree(q);\n\t\t\t\t} else\n\t\t\t\t\tstring_append(s, p);\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\t*mangled += symbol_len;\n\t\t}\n\t}\n\n\treturn success;\n}\n\n/* Demangle the template name in MANGLED.  The full name of the\n   template (e.g., S<int>) is placed in TNAME.  The name without the\n   template parameters (e.g. S) is placed in TRAWNAME if TRAWNAME is\n   non-NULL.  If IS_TYPE is nonzero, this template is a type template,\n   not a function template.  If both IS_TYPE and REMEMBER are nonzero,\n   the tmeplate is remembered in the list of back-referenceable\n   types.  */\n\nstatic int\ndemangle_template(work, mangled, tname, trawname, is_type, remember)\nstruct work_stuff *work;\nconst char **mangled;\nstring *tname;\nstring *trawname;\nint is_type;\nint remember;\n{\n\tint i = 0;\n\tint r = 0;\n\tint need_comma = 0;\n\tint success = 0;\n\tint is_java_array = 0;\n\tstring temp = { 0 };\n\tint bindex = 0;\n\n\t(*mangled)++;\n\tif (is_type) {\n\t\tif (remember)\n\t\t\tbindex = register_Btype(work);\n\t\t/* get template name */\n\t\tif (**mangled == 'z') {\n\t\t\tint idx;\n\t\t\t(*mangled)++;\n\t\t\t(*mangled)++;\n\n\t\t\tidx = consume_count_with_underscores(mangled);\n\t\t\tif (idx == -1 || (work->tmpl_argvec && idx >= work->ntmpl_args) || consume_count_with_underscores(mangled) == -1)\n\t\t\t\treturn (0);\n\n\t\t\tif (work->tmpl_argvec) {\n\t\t\t\tstring_append(tname, work->tmpl_argvec[idx]);\n\t\t\t\tif (trawname)\n\t\t\t\t\tstring_append(trawname, work->tmpl_argvec[idx]);\n\t\t\t} else {\n\t\t\t\tchar buf[10];\n\t\t\t\tsprintf(buf, \"T%d\", idx);\n\t\t\t\tstring_append(tname, buf);\n\t\t\t\tif (trawname)\n\t\t\t\t\tstring_append(trawname, buf);\n\t\t\t}\n\t\t} else {\n\t\t\tif ((r = consume_count(mangled)) <= 0 || (int)strlen(*mangled) < r) {\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tis_java_array = (work->options & DMGL_JAVA) && strncmp(*mangled, \"JArray1Z\", 8) == 0;\n\t\t\tif (!is_java_array) {\n\t\t\t\tstring_appendn(tname, *mangled, r);\n\t\t\t}\n\t\t\tif (trawname)\n\t\t\t\tstring_appendn(trawname, *mangled, r);\n\t\t\t*mangled += r;\n\t\t}\n\t}\n\tif (!is_java_array)\n\t\tstring_append(tname, \"<\");\n\t/* get size of template parameter list */\n\tif (!get_count(mangled, &r)) {\n\t\treturn (0);\n\t}\n\tif (!is_type) {\n\t\t/* Create an array for saving the template argument values. */\n\t\twork->tmpl_argvec = (char **)malloc(r * sizeof(char *));\n\t\twork->ntmpl_args = r;\n\t\tfor (i = 0; i < r; i++)\n\t\t\twork->tmpl_argvec[i] = 0;\n\t}\n\tfor (i = 0; i < r; i++) {\n\t\tif (need_comma) {\n\t\t\tstring_append(tname, \", \");\n\t\t}\n\t\t/* Z for type parameters */\n\t\tif (**mangled == 'Z') {\n\t\t\t(*mangled)++;\n\t\t\t/* temp is initialized in do_type */\n\t\t\tsuccess = do_type(work, mangled, &temp);\n\t\t\tif (success) {\n\t\t\t\tstring_appends(tname, &temp);\n\n\t\t\t\tif (!is_type) {\n\t\t\t\t\t/* Save the template argument. */\n\t\t\t\t\tint len = temp.p - temp.b;\n\t\t\t\t\twork->tmpl_argvec[i] = malloc(len + 1);\n\t\t\t\t\tmemcpy(work->tmpl_argvec[i], temp.b, len);\n\t\t\t\t\twork->tmpl_argvec[i][len] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring_delete(&temp);\n\t\t\tif (!success) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* z for template parameters */\n\t\telse if (**mangled == 'z') {\n\t\t\tint r2;\n\t\t\t(*mangled)++;\n\t\t\tsuccess = demangle_template_template_parm(work, mangled, tname);\n\n\t\t\tif (success && (r2 = consume_count(mangled)) > 0 && (int)strlen(*mangled) >= r2) {\n\t\t\t\tstring_append(tname, \" \");\n\t\t\t\tstring_appendn(tname, *mangled, r2);\n\t\t\t\tif (!is_type) {\n\t\t\t\t\t/* Save the template argument. */\n\t\t\t\t\tint len = r2;\n\t\t\t\t\twork->tmpl_argvec[i] = malloc(len + 1);\n\t\t\t\t\tmemcpy(work->tmpl_argvec[i], *mangled, len);\n\t\t\t\t\twork->tmpl_argvec[i][len] = '\\0';\n\t\t\t\t}\n\t\t\t\t*mangled += r2;\n\t\t\t}\n\t\t\tif (!success) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tstring param;\n\t\t\tstring *s;\n\n\t\t\t/* otherwise, value parameter */\n\n\t\t\t/* temp is initialized in do_type */\n\t\t\tsuccess = do_type(work, mangled, &temp);\n\t\t\tstring_delete(&temp);\n\t\t\tif (!success)\n\t\t\t\tbreak;\n\n\t\t\tif (!is_type) {\n\t\t\t\ts = &param;\n\t\t\t\tstring_init(s);\n\t\t\t} else\n\t\t\t\ts = tname;\n\n\t\t\tsuccess = demangle_template_value_parm(work, mangled, s,\n\t\t\t\t(type_kind_t)success);\n\n\t\t\tif (!success) {\n\t\t\t\tif (!is_type)\n\t\t\t\t\tstring_delete(s);\n\t\t\t\tsuccess = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!is_type) {\n\t\t\t\tint len = s->p - s->b;\n\t\t\t\twork->tmpl_argvec[i] = malloc(len + 1);\n\t\t\t\tmemcpy(work->tmpl_argvec[i], s->b, len);\n\t\t\t\twork->tmpl_argvec[i][len] = '\\0';\n\n\t\t\t\tstring_appends(tname, s);\n\t\t\t\tstring_delete(s);\n\t\t\t}\n\t\t}\n\t\tneed_comma = 1;\n\t}\n\tif (is_java_array) {\n\t\tstring_append(tname, \"[]\");\n\t} else {\n\t\tif (tname->p[-1] == '>')\n\t\t\tstring_append(tname, \" \");\n\t\tstring_append(tname, \">\");\n\t}\n\n\tif (is_type && remember)\n\t\tremember_Btype(work, tname->b, LEN_STRING(tname), bindex);\n\n\treturn (success);\n}\n\nstatic int\narm_pt(work, mangled, n, anchor, args)\nstruct work_stuff *work;\nconst char *mangled;\nint n;\nconst char **anchor, **args;\n{\n\t/* Check if ARM template with \"__pt__\" in it (\"parameterized type\") */\n\t/* Allow HP also here, because HP's cfront compiler follows ARM to some extent */\n\tif ((ARM_DEMANGLING || HP_DEMANGLING) && (*anchor = mystrstr(mangled, \"__pt__\"))) {\n\t\tint len;\n\t\t*args = *anchor + 6;\n\t\tlen = consume_count(args);\n\t\tif (len == -1)\n\t\t\treturn 0;\n\t\tif (*args + len == mangled + n && **args == '_') {\n\t\t\t++*args;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif (AUTO_DEMANGLING || EDG_DEMANGLING) {\n\t\tif ((*anchor = mystrstr(mangled, \"__tm__\")) || (*anchor = mystrstr(mangled, \"__ps__\")) || (*anchor = mystrstr(mangled, \"__pt__\"))) {\n\t\t\tint len;\n\t\t\t*args = *anchor + 6;\n\t\t\tlen = consume_count(args);\n\t\t\tif (len == -1)\n\t\t\t\treturn 0;\n\t\t\tif (*args + len == mangled + n && **args == '_') {\n\t\t\t\t++*args;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if ((*anchor = mystrstr(mangled, \"__S\"))) {\n\t\t\tint len;\n\t\t\t*args = *anchor + 3;\n\t\t\tlen = consume_count(args);\n\t\t\tif (len == -1)\n\t\t\t\treturn 0;\n\t\t\tif (*args + len == mangled + n && **args == '_') {\n\t\t\t\t++*args;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void\n\tdemangle_arm_hp_template(work, mangled, n, declp) struct work_stuff *work;\nconst char **mangled;\nint n;\nstring *declp;\n{\n\tconst char *p;\n\tconst char *args;\n\tconst char *e = *mangled + n;\n\tstring arg;\n\n\t/* Check for HP aCC template spec: classXt1t2 where t1, t2 are\n\t   template args */\n\tif (HP_DEMANGLING && ((*mangled)[n] == 'X')) {\n\t\tchar *start_spec_args = NULL;\n\n\t\t/* First check for and omit template specialization pseudo-arguments,\n\t\t   such as in \"Spec<#1,#1.*>\" */\n\t\tstart_spec_args = strchr(*mangled, '<');\n\t\tif (start_spec_args && (start_spec_args - *mangled < n))\n\t\t\tstring_appendn(declp, *mangled, start_spec_args - *mangled);\n\t\telse\n\t\t\tstring_appendn(declp, *mangled, n);\n\t\t(*mangled) += n + 1;\n\t\tstring_init(&arg);\n\t\tif (work->temp_start == -1) /* non-recursive call */\n\t\t\twork->temp_start = declp->p - declp->b;\n\t\tstring_append(declp, \"<\");\n\t\twhile (1) {\n\t\t\tstring_clear(&arg);\n\t\t\tswitch (**mangled) {\n\t\t\tcase 'T':\n\t\t\t\t/* 'T' signals a type parameter */\n\t\t\t\t(*mangled)++;\n\t\t\t\tif (!do_type(work, mangled, &arg))\n\t\t\t\t\tgoto hpacc_template_args_done;\n\t\t\t\tbreak;\n\n\t\t\tcase 'U':\n\t\t\tcase 'S':\n\t\t\t\t/* 'U' or 'S' signals an integral value */\n\t\t\t\tif (!do_hpacc_template_const_value(work, mangled, &arg))\n\t\t\t\t\tgoto hpacc_template_args_done;\n\t\t\t\tbreak;\n\n\t\t\tcase 'A':\n\t\t\t\t/* 'A' signals a named constant expression (literal) */\n\t\t\t\tif (!do_hpacc_template_literal(work, mangled, &arg))\n\t\t\t\t\tgoto hpacc_template_args_done;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t/* Today, 1997-09-03, we have only the above types\n\t\t\t\t   of template parameters */\n\t\t\t\t/* FIXME: maybe this should fail and return null */\n\t\t\t\tgoto hpacc_template_args_done;\n\t\t\t}\n\t\t\tstring_appends(declp, &arg);\n\t\t\t/* Check if we're at the end of template args.\n\t\t\t    0 if at end of static member of template class,\n\t\t\t    _ if done with template args for a function */\n\t\t\tif ((**mangled == '\\000') || (**mangled == '_'))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tstring_append(declp, \",\");\n\t\t}\n\thpacc_template_args_done:\n\t\tstring_append(declp, \">\");\n\t\tstring_delete(&arg);\n\t\tif (**mangled == '_')\n\t\t\t(*mangled)++;\n\t\treturn;\n\t}\n\t/* ARM template? (Also handles HP cfront extensions) */\n\telse if (arm_pt(work, *mangled, n, &p, &args)) {\n\t\tstring type_str;\n\n\t\tstring_init(&arg);\n\t\tstring_appendn(declp, *mangled, p - *mangled);\n\t\tif (work->temp_start == -1) /* non-recursive call */\n\t\t\twork->temp_start = declp->p - declp->b;\n\t\tstring_append(declp, \"<\");\n\t\t/* should do error checking here */\n\t\twhile (args < e) {\n\t\t\tstring_clear(&arg);\n\n\t\t\t/* Check for type or literal here */\n\t\t\tswitch (*args) {\n\t\t\t\t/* HP cfront extensions to ARM for template args */\n\t\t\t\t/* spec: Xt1Lv1 where t1 is a type, v1 is a literal value */\n\t\t\t\t/* FIXME: We handle only numeric literals for HP cfront */\n\t\t\tcase 'X':\n\t\t\t\t/* A typed constant value follows */\n\t\t\t\targs++;\n\t\t\t\tif (!do_type(work, &args, &type_str))\n\t\t\t\t\tgoto cfront_template_args_done;\n\t\t\t\tstring_append(&arg, \"(\");\n\t\t\t\tstring_appends(&arg, &type_str);\n\t\t\t\tstring_append(&arg, \")\");\n\t\t\t\tif (*args != 'L')\n\t\t\t\t\tgoto cfront_template_args_done;\n\t\t\t\targs++;\n\t\t\t\t/* Now snarf a literal value following 'L' */\n\t\t\t\tif (!snarf_numeric_literal(&args, &arg))\n\t\t\t\t\tgoto cfront_template_args_done;\n\t\t\t\tbreak;\n\n\t\t\tcase 'L':\n\t\t\t\t/* Snarf a literal following 'L' */\n\t\t\t\targs++;\n\t\t\t\tif (!snarf_numeric_literal(&args, &arg))\n\t\t\t\t\tgoto cfront_template_args_done;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* Not handling other HP cfront stuff */\n\t\t\t\tif (!do_type(work, &args, &arg))\n\t\t\t\t\tgoto cfront_template_args_done;\n\t\t\t}\n\t\t\tstring_appends(declp, &arg);\n\t\t\tstring_append(declp, \",\");\n\t\t}\n\tcfront_template_args_done:\n\t\tstring_delete(&arg);\n\t\tif (args >= e)\n\t\t\t--declp->p; /* remove extra comma */\n\t\tstring_append(declp, \">\");\n\t} else if (n > 10 && strncmp(*mangled, \"_GLOBAL_\", 8) == 0 && (*mangled)[9] == 'N' && (*mangled)[8] == (*mangled)[10] && strchr(cplus_markers, (*mangled)[8])) {\n\t\t/* A member of the anonymous namespace.  */\n\t\tstring_append(declp, \"{anonymous}\");\n\t} else {\n\t\tif (work->temp_start == -1) /* non-recursive call only */\n\t\t\twork->temp_start = 0; /* disable in recursive calls */\n\t\tstring_appendn(declp, *mangled, n);\n\t}\n\t*mangled += n;\n}\n\n/* Extract a class name, possibly a template with arguments, from the\n   mangled string; qualifiers, local class indicators, etc. have\n   already been dealt with */\n\nstatic int\ndemangle_class_name(work, mangled, declp)\nstruct work_stuff *work;\nconst char **mangled;\nstring *declp;\n{\n\tint n;\n\tint success = 0;\n\n\tn = consume_count(mangled);\n\tif (n == -1)\n\t\treturn 0;\n\tif ((int)strlen(*mangled) >= n) {\n\t\tdemangle_arm_hp_template(work, mangled, n, declp);\n\t\tsuccess = 1;\n\t}\n\n\treturn (success);\n}\n\n/*\n\nLOCAL FUNCTION\n\n\tdemangle_class -- demangle a mangled class sequence\n\nSYNOPSIS\n\n\tstatic int\n\tdemangle_class (struct work_stuff *work, const char **mangled,\n\t\t\tstrint *declp)\n\nDESCRIPTION\n\n\tDECLP points to the buffer into which demangling is being done.\n\n\t*MANGLED points to the current token to be demangled.  On input,\n\tit points to a mangled class (I.E. \"3foo\", \"13verylongclass\", etc.)\n\tOn exit, it points to the next token after the mangled class on\n\tsuccess, or the first unconsumed token on failure.\n\n\tIf the CONSTRUCTOR or DESTRUCTOR flags are set in WORK, then\n\twe are demangling a constructor or destructor.  In this case\n\twe prepend \"class::class\" or \"class::~class\" to DECLP.\n\n\tOtherwise, we prepend \"class::\" to the current DECLP.\n\n\tReset the constructor/destructor flags once they have been\n\t\"consumed\".  This allows demangle_class to be called later during\n\tthe same demangling, to do normal class demangling.\n\n\tReturns 1 if demangling is successful, 0 otherwise.\n\n*/\n\nstatic int\ndemangle_class(work, mangled, declp)\nstruct work_stuff *work;\nconst char **mangled;\nstring *declp;\n{\n\tint success = 0;\n\tint btype;\n\tstring class_name;\n\tchar *save_class_name_end = 0;\n\n\tstring_init(&class_name);\n\tbtype = register_Btype(work);\n\tif (demangle_class_name(work, mangled, &class_name)) {\n\t\tsave_class_name_end = class_name.p;\n\t\tif ((work->constructor & 1) || (work->destructor & 1)) {\n\t\t\t/* adjust so we don't include template args */\n\t\t\tif (work->temp_start && (work->temp_start != -1)) {\n\t\t\t\tclass_name.p = class_name.b + work->temp_start;\n\t\t\t}\n\t\t\tstring_prepends(declp, &class_name);\n\t\t\tif (work->destructor & 1) {\n\t\t\t\tstring_prepend(declp, \"~\");\n\t\t\t\twork->destructor -= 1;\n\t\t\t} else {\n\t\t\t\twork->constructor -= 1;\n\t\t\t}\n\t\t}\n\t\tclass_name.p = save_class_name_end;\n\t\tremember_Ktype(work, class_name.b, LEN_STRING(&class_name));\n\t\tremember_Btype(work, class_name.b, LEN_STRING(&class_name), btype);\n\t\tstring_prepend(declp, SCOPE_STRING(work));\n\t\tstring_prepends(declp, &class_name);\n\t\tsuccess = 1;\n\t}\n\tstring_delete(&class_name);\n\treturn (success);\n}\n\n/*\n\nLOCAL FUNCTION\n\n\tdemangle_prefix -- consume the mangled name prefix and find signature\n\nSYNOPSIS\n\n\tstatic int\n\tdemangle_prefix (struct work_stuff *work, const char **mangled,\n\t\t\t string *declp);\n\nDESCRIPTION\n\n\tConsume and demangle the prefix of the mangled name.\n\n\tDECLP points to the string buffer into which demangled output is\n\tplaced.  On entry, the buffer is empty.  On exit it contains\n\tthe root function name, the demangled operator name, or in some\n\tspecial cases either nothing or the completely demangled result.\n\n\tMANGLED points to the current pointer into the mangled name.  As each\n\ttoken of the mangled name is consumed, it is updated.  Upon entry\n\tthe current mangled name pointer points to the first character of\n\tthe mangled name.  Upon exit, it should point to the first character\n\tof the signature if demangling was successful, or to the first\n\tunconsumed character if demangling of the prefix was unsuccessful.\n\n\tReturns 1 on success, 0 otherwise.\n */\n\nstatic int\ndemangle_prefix(work, mangled, declp)\nstruct work_stuff *work;\nconst char **mangled;\nstring *declp;\n{\n\tint success = 1;\n\tconst char *scan;\n\tint i;\n\n\tif (strlen(*mangled) > 6 && (strncmp(*mangled, \"_imp__\", 6) == 0 || strncmp(*mangled, \"__imp_\", 6) == 0)) {\n\t\t/* it's a symbol imported from a PE dynamic library. Check for both\n\t\t   new style prefix _imp__ and legacy __imp_ used by older versions\n\t\t   of dlltool. */\n\t\t(*mangled) += 6;\n\t\twork->dllimported = 1;\n\t} else if (strlen(*mangled) >= 11 && strncmp(*mangled, \"_GLOBAL_\", 8) == 0) {\n\t\tchar *marker = strchr(cplus_markers, (*mangled)[8]);\n\t\tif (marker != NULL && *marker == (*mangled)[10]) {\n\t\t\tif ((*mangled)[9] == 'D') {\n\t\t\t\t/* it's a GNU global destructor to be executed at program exit */\n\t\t\t\t(*mangled) += 11;\n\t\t\t\twork->destructor = 2;\n\t\t\t\tif (gnu_special(work, mangled, declp))\n\t\t\t\t\treturn success;\n\t\t\t} else if ((*mangled)[9] == 'I') {\n\t\t\t\t/* it's a GNU global constructor to be executed at program init */\n\t\t\t\t(*mangled) += 11;\n\t\t\t\twork->constructor = 2;\n\t\t\t\tif (gnu_special(work, mangled, declp))\n\t\t\t\t\treturn success;\n\t\t\t}\n\t\t}\n\t} else if ((ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING) && strncmp(*mangled, \"__std__\", 7) == 0) {\n\t\t/* it's a ARM global destructor to be executed at program exit */\n\t\t(*mangled) += 7;\n\t\twork->destructor = 2;\n\t} else if ((ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING) && strncmp(*mangled, \"__sti__\", 7) == 0) {\n\t\t/* it's a ARM global constructor to be executed at program initial */\n\t\t(*mangled) += 7;\n\t\twork->constructor = 2;\n\t}\n\n\t/*  This block of code is a reduction in strength time optimization\n\t    of:\n\t    scan = mystrstr (*mangled, \"__\"); */\n\n\t{\n\t\tscan = *mangled;\n\n\t\tdo {\n\t\t\tscan = strchr(scan, '_');\n\t\t} while (scan != NULL && *++scan != '_');\n\n\t\tif (scan != NULL)\n\t\t\t--scan;\n\t}\n\n\tif (scan != NULL) {\n\t\t/* We found a sequence of two or more '_', ensure that we start at\n\t\t   the last pair in the sequence.  */\n\t\ti = strspn(scan, \"_\");\n\t\tif (i > 2) {\n\t\t\tscan += (i - 2);\n\t\t}\n\t}\n\n\tif (scan == NULL) {\n\t\tsuccess = 0;\n\t} else if (work->static_type) {\n\t\tif (!isdigit((unsigned char)scan[0]) && (scan[0] != 't')) {\n\t\t\tsuccess = 0;\n\t\t}\n\t} else if ((scan == *mangled) && (isdigit((unsigned char)scan[2]) || (scan[2] == 'Q') || (scan[2] == 't') || (scan[2] == 'K') || (scan[2] == 'H'))) {\n\t\t/* The ARM says nothing about the mangling of local variables.\n\t\t   But cfront mangles local variables by prepending __<nesting_level>\n\t\t   to them. As an extension to ARM demangling we handle this case.  */\n\t\tif ((LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING) && isdigit((unsigned char)scan[2])) {\n\t\t\t*mangled = scan + 2;\n\t\t\tconsume_count(mangled);\n\t\t\tstring_append(declp, *mangled);\n\t\t\t*mangled += strlen(*mangled);\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\t/* A GNU style constructor starts with __[0-9Qt].  But cfront uses\n\t\t\t   names like __Q2_3foo3bar for nested type names.  So don't accept\n\t\t\t   this style of constructor for cfront demangling.  A GNU\n\t\t\t   style member-template constructor starts with 'H'. */\n\t\t\tif (!(LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING))\n\t\t\t\twork->constructor += 1;\n\t\t\t*mangled = scan + 2;\n\t\t}\n\t} else if (ARM_DEMANGLING && scan[2] == 'p' && scan[3] == 't') {\n\t\t/* Cfront-style parameterized type.  Handled later as a signature. */\n\t\tsuccess = 1;\n\n\t\t/* ARM template? */\n\t\tdemangle_arm_hp_template(work, mangled, strlen(*mangled), declp);\n\t} else if (EDG_DEMANGLING && ((scan[2] == 't' && scan[3] == 'm') || (scan[2] == 'p' && scan[3] == 's') || (scan[2] == 'p' && scan[3] == 't'))) {\n\t\t/* EDG-style parameterized type.  Handled later as a signature. */\n\t\tsuccess = 1;\n\n\t\t/* EDG template? */\n\t\tdemangle_arm_hp_template(work, mangled, strlen(*mangled), declp);\n\t} else if ((scan == *mangled) && !isdigit((unsigned char)scan[2]) && (scan[2] != 't')) {\n\t\t/* Mangled name starts with \"__\".  Skip over any leading '_' characters,\n\t\t   then find the next \"__\" that separates the prefix from the signature.\n\t\t   */\n\t\tif (!(ARM_DEMANGLING || LUCID_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING) || (arm_special(mangled, declp) == 0)) {\n\t\t\twhile (*scan == '_') {\n\t\t\t\tscan++;\n\t\t\t}\n\t\t\tif ((scan = mystrstr(scan, \"__\")) == NULL || (*(scan + 2) == '\\0')) {\n\t\t\t\t/* No separator (I.E. \"__not_mangled\"), or empty signature\n\t\t\t\t   (I.E. \"__not_mangled_either__\") */\n\t\t\t\tsuccess = 0;\n\t\t\t} else {\n\t\t\t\tconst char *tmp;\n\n\t\t\t\t/* Look for the LAST occurrence of __, allowing names to\n\t\t\t\t   have the '__' sequence embedded in them. */\n\t\t\t\tif (!(ARM_DEMANGLING || HP_DEMANGLING)) {\n\t\t\t\t\twhile ((tmp = mystrstr(scan + 2, \"__\")) != NULL)\n\t\t\t\t\t\tscan = tmp;\n\t\t\t\t}\n\t\t\t\tif (*(scan + 2) == '\\0')\n\t\t\t\t\tsuccess = 0;\n\t\t\t\telse\n\t\t\t\t\tdemangle_function_name(work, mangled, declp, scan);\n\t\t\t}\n\t\t}\n\t} else if (*(scan + 2) != '\\0') {\n\t\t/* Mangled name does not start with \"__\" but does have one somewhere\n\t\t   in there with non empty stuff after it.  Looks like a global\n\t\t   function name.  */\n\t\tdemangle_function_name(work, mangled, declp, scan);\n\t} else {\n\t\t/* Doesn't look like a mangled name */\n\t\tsuccess = 0;\n\t}\n\n\tif (!success && (work->constructor == 2 || work->destructor == 2)) {\n\t\tstring_append(declp, *mangled);\n\t\t*mangled += strlen(*mangled);\n\t\tsuccess = 1;\n\t}\n\treturn (success);\n}\n\n/*\n\nLOCAL FUNCTION\n\n\tgnu_special -- special handling of gnu mangled strings\n\nSYNOPSIS\n\n\tstatic int\n\tgnu_special (struct work_stuff *work, const char **mangled,\n\t\t     string *declp);\n\n\nDESCRIPTION\n\n\tProcess some special GNU style mangling forms that don't fit\n\tthe normal pattern.  For example:\n\n\t\t_$_3foo\t\t(destructor for class foo)\n\t\t_vt$foo\t\t(foo virtual table)\n\t\t_vt$foo$bar\t(foo::bar virtual table)\n\t\t__vt_foo\t(foo virtual table, new style with thunks)\n\t\t_3foo$varname\t(static data member)\n\t\t_Q22rs2tu$vw\t(static data member)\n\t\t__t6vector1Zii\t(constructor with template)\n\t\t__thunk_4__$_7ostream (virtual function thunk)\n */\n\nstatic int\ngnu_special(work, mangled, declp)\nstruct work_stuff *work;\nconst char **mangled;\nstring *declp;\n{\n\tint n;\n\tint success = 1;\n\tconst char *p;\n\n\tif ((*mangled)[0] == '_' && strchr(cplus_markers, (*mangled)[1]) != NULL && (*mangled)[2] == '_') {\n\t\t/* Found a GNU style destructor, get past \"_<CPLUS_MARKER>_\" */\n\t\t(*mangled) += 3;\n\t\twork->destructor += 1;\n\t} else if ((*mangled)[0] == '_' && (((*mangled)[1] == '_' && (*mangled)[2] == 'v' && (*mangled)[3] == 't' && (*mangled)[4] == '_') || ((*mangled)[1] == 'v' && (*mangled)[2] == 't' && strchr(cplus_markers, (*mangled)[3]) != NULL))) {\n\t\t/* Found a GNU style virtual table, get past \"_vt<CPLUS_MARKER>\"\n\t\t   and create the decl.  Note that we consume the entire mangled\n\t\t   input string, which means that demangle_signature has no work\n\t\t   to do.  */\n\t\tif ((*mangled)[2] == 'v')\n\t\t\t(*mangled) += 5; /* New style, with thunks: \"__vt_\" */\n\t\telse\n\t\t\t(*mangled) += 4; /* Old style, no thunks: \"_vt<CPLUS_MARKER>\" */\n\t\twhile (**mangled != '\\0') {\n\t\t\tswitch (**mangled) {\n\t\t\tcase 'Q':\n\t\t\tcase 'K':\n\t\t\t\tsuccess = demangle_qualified(work, mangled, declp, 0, 1);\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tsuccess = demangle_template(work, mangled, declp, 0, 1,\n\t\t\t\t\t1);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (isdigit((unsigned char)*mangled[0])) {\n\t\t\t\t\tn = consume_count(mangled);\n\t\t\t\t\t/* We may be seeing a too-large size, or else a\n\t\t\t\t\t   \".<digits>\" indicating a static local symbol.  In\n\t\t\t\t\t   any case, declare victory and move on; *don't* try\n\t\t\t\t\t   to use n to allocate.  */\n\t\t\t\t\tif (n > (int)strlen(*mangled)) {\n\t\t\t\t\t\tsuccess = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tn = strcspn(*mangled, cplus_markers);\n\t\t\t\t}\n\t\t\t\tstring_appendn(declp, *mangled, n);\n\t\t\t\t(*mangled) += n;\n\t\t\t}\n\n\t\t\tp = strpbrk(*mangled, cplus_markers);\n\t\t\tif (success && ((p == NULL) || (p == *mangled))) {\n\t\t\t\tif (p != NULL) {\n\t\t\t\t\tstring_append(declp, SCOPE_STRING(work));\n\t\t\t\t\t(*mangled)++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsuccess = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (success)\n\t\t\tstring_append(declp, \" virtual table\");\n\t} else if ((*mangled)[0] == '_' && (strchr(\"0123456789Qt\", (*mangled)[1]) != NULL) && (p = strpbrk(*mangled, cplus_markers)) != NULL) {\n\t\t/* static data member, \"_3foo$varname\" for example */\n\t\t(*mangled)++;\n\t\tswitch (**mangled) {\n\t\tcase 'Q':\n\t\tcase 'K':\n\t\t\tsuccess = demangle_qualified(work, mangled, declp, 0, 1);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tsuccess = demangle_template(work, mangled, declp, 0, 1, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tn = consume_count(mangled);\n\t\t\tif (n < 0 || n > strlen(*mangled)) {\n\t\t\t\tsuccess = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstring_appendn(declp, *mangled, n);\n\t\t\t(*mangled) += n;\n\t\t}\n\t\tif (success && (p == *mangled)) {\n\t\t\t/* Consumed everything up to the cplus_marker, append the\n\t\t\t   variable name.  */\n\t\t\t(*mangled)++;\n\t\t\tstring_append(declp, SCOPE_STRING(work));\n\t\t\tn = strlen(*mangled);\n\t\t\tstring_appendn(declp, *mangled, n);\n\t\t\t(*mangled) += n;\n\t\t} else {\n\t\t\tsuccess = 0;\n\t\t}\n\t} else if (strncmp(*mangled, \"__thunk_\", 8) == 0) {\n\t\tint delta;\n\n\t\t(*mangled) += 8;\n\t\tdelta = consume_count(mangled);\n\t\tif (delta == -1)\n\t\t\tsuccess = 0;\n\t\telse {\n\t\t\tchar *method = internal_cplus_demangle(work, ++*mangled);\n\n\t\t\tif (method) {\n\t\t\t\tchar buf[50];\n\t\t\t\tsprintf(buf, \"virtual function thunk (delta:%d) for \", -delta);\n\t\t\t\tstring_append(declp, buf);\n\t\t\t\tstring_append(declp, method);\n\t\t\t\tfree(method);\n\t\t\t\tn = strlen(*mangled);\n\t\t\t\t(*mangled) += n;\n\t\t\t} else {\n\t\t\t\tsuccess = 0;\n\t\t\t}\n\t\t}\n\t} else if (strncmp(*mangled, \"__t\", 3) == 0 && ((*mangled)[3] == 'i' || (*mangled)[3] == 'f')) {\n\t\tp = (*mangled)[3] == 'i' ? \" type_info node\" : \" type_info function\";\n\t\t(*mangled) += 4;\n\t\tswitch (**mangled) {\n\t\tcase 'Q':\n\t\tcase 'K':\n\t\t\tsuccess = demangle_qualified(work, mangled, declp, 0, 1);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tsuccess = demangle_template(work, mangled, declp, 0, 1, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsuccess = demangle_fund_type(work, mangled, declp);\n\t\t\tbreak;\n\t\t}\n\t\tif (success && **mangled != '\\0')\n\t\t\tsuccess = 0;\n\t\tif (success)\n\t\t\tstring_append(declp, p);\n\t} else {\n\t\tsuccess = 0;\n\t}\n\treturn (success);\n}\n\nstatic void\n\trecursively_demangle(work, mangled, result, namelength) struct work_stuff *work;\nconst char **mangled;\nstring *result;\nint namelength;\n{\n\tchar *recurse = (char *)NULL;\n\tchar *recurse_dem = (char *)NULL;\n\n\trecurse = (char *)malloc(namelength + 1);\n\tmemcpy(recurse, *mangled, namelength);\n\trecurse[namelength] = '\\000';\n\n\trecurse_dem = cplus_demangle_v2(recurse, work->options);\n\n\tif (recurse_dem) {\n\t\tstring_append(result, recurse_dem);\n\t\tfree(recurse_dem);\n\t} else {\n\t\tstring_appendn(result, *mangled, namelength);\n\t}\n\tfree(recurse);\n\t*mangled += namelength;\n}\n\n/*\n\nLOCAL FUNCTION\n\n\tarm_special -- special handling of ARM/lucid mangled strings\n\nSYNOPSIS\n\n\tstatic int\n\tarm_special (const char **mangled,\n\t\t     string *declp);\n\n\nDESCRIPTION\n\n\tProcess some special ARM style mangling forms that don't fit\n\tthe normal pattern.  For example:\n\n\t\t__vtbl__3foo\t\t(foo virtual table)\n\t\t__vtbl__3foo__3bar\t(bar::foo virtual table)\n\n */\n\nstatic int\n\tarm_special(mangled, declp)\n\t\tconst char **mangled;\nstring *declp;\n{\n\tint n;\n\tint success = 1;\n\tconst char *scan;\n\n\tif (strncmp(*mangled, ARM_VTABLE_STRING, ARM_VTABLE_STRLEN) == 0) {\n\t\t/* Found a ARM style virtual table, get past ARM_VTABLE_STRING\n\t\t   and create the decl.  Note that we consume the entire mangled\n\t\t   input string, which means that demangle_signature has no work\n\t\t   to do.  */\n\t\tscan = *mangled + ARM_VTABLE_STRLEN;\n\t\twhile (*scan != '\\0') /* first check it can be demangled */\n\t\t{\n\t\t\tn = consume_count(&scan);\n\t\t\tif (n == -1) {\n\t\t\t\treturn (0); /* no good */\n\t\t\t}\n\t\t\tscan += n;\n\t\t\tif (scan[0] == '_' && scan[1] == '_') {\n\t\t\t\tscan += 2;\n\t\t\t}\n\t\t}\n\t\t(*mangled) += ARM_VTABLE_STRLEN;\n\t\twhile (**mangled != '\\0') {\n\t\t\tn = consume_count(mangled);\n\t\t\tif (n == -1 || n > strlen(*mangled))\n\t\t\t\treturn 0;\n\t\t\tstring_prependn(declp, *mangled, n);\n\t\t\t(*mangled) += n;\n\t\t\tif ((*mangled)[0] == '_' && (*mangled)[1] == '_') {\n\t\t\t\tstring_prepend(declp, \"::\");\n\t\t\t\t(*mangled) += 2;\n\t\t\t}\n\t\t}\n\t\tstring_append(declp, \" virtual table\");\n\t} else {\n\t\tsuccess = 0;\n\t}\n\treturn (success);\n}\n\n/*\n\nLOCAL FUNCTION\n\n\tdemangle_qualified -- demangle 'Q' qualified name strings\n\nSYNOPSIS\n\n\tstatic int\n\tdemangle_qualified (struct work_stuff *, const char *mangled,\n\t\t\t    string *result, int isfuncname, int append);\n\nDESCRIPTION\n\n\tDemangle a qualified name, such as \"Q25Outer5Inner\" which is\n\tthe mangled form of \"Outer::Inner\".  The demangled output is\n\tprepended or appended to the result string according to the\n\tstate of the append flag.\n\n\tIf isfuncname is nonzero, then the qualified name we are building\n\tis going to be used as a member function name, so if it is a\n\tconstructor or destructor function, append an appropriate\n\tconstructor or destructor name.  I.E. for the above example,\n\tthe result for use as a constructor is \"Outer::Inner::Inner\"\n\tand the result for use as a destructor is \"Outer::Inner::~Inner\".\n\nBUGS\n\n\tNumeric conversion is ASCII dependent (FIXME).\n\n */\n\nstatic int\ndemangle_qualified(work, mangled, result, isfuncname, append)\nstruct work_stuff *work;\nconst char **mangled;\nstring *result;\nint isfuncname;\nint append;\n{\n\tint qualifiers = 0;\n\tint success = 1;\n\tconst char *p;\n\tchar num[2];\n\tstring temp;\n\tstring last_name;\n\tint bindex = register_Btype(work);\n\n\t/* We only make use of ISFUNCNAME if the entity is a constructor or\n\t   destructor.  */\n\tisfuncname = (isfuncname && ((work->constructor & 1) || (work->destructor & 1)));\n\n\tstring_init(&temp);\n\tstring_init(&last_name);\n\n\tif ((*mangled)[0] == 'K') {\n\t\t/* Squangling qualified name reuse */\n\t\tint idx;\n\t\t(*mangled)++;\n\t\tidx = consume_count_with_underscores(mangled);\n\t\tif (idx == -1 || idx >= work->numk)\n\t\t\tsuccess = 0;\n\t\telse\n\t\t\tstring_append(&temp, work->ktypevec[idx]);\n\t} else\n\t\tswitch ((*mangled)[1]) {\n\t\tcase '_':\n\t\t\t/* GNU mangled name with more than 9 classes.  The count is preceded\n\t\t\t   by an underscore (to distinguish it from the <= 9 case) and followed\n\t\t\t   by an underscore.  */\n\t\t\tp = *mangled + 2;\n\t\t\tqualifiers = atoi(p);\n\t\t\tif (!isdigit((unsigned char)*p) || *p == '0')\n\t\t\t\tsuccess = 0;\n\n\t\t\t/* Skip the digits.  */\n\t\t\twhile (isdigit((unsigned char)*p))\n\t\t\t\t++p;\n\n\t\t\tif (*p != '_')\n\t\t\t\tsuccess = 0;\n\n\t\t\t*mangled = p + 1;\n\t\t\tbreak;\n\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\t\t/* The count is in a single digit.  */\n\t\t\tnum[0] = (*mangled)[1];\n\t\t\tnum[1] = '\\0';\n\t\t\tqualifiers = atoi(num);\n\n\t\t\t/* If there is an underscore after the digit, skip it.  This is\n\t\t\t   said to be for ARM-qualified names, but the ARM makes no\n\t\t\t   mention of such an underscore.  Perhaps cfront uses one.  */\n\t\t\tif ((*mangled)[2] == '_') {\n\t\t\t\t(*mangled)++;\n\t\t\t}\n\t\t\t(*mangled) += 2;\n\t\t\tbreak;\n\n\t\tcase '0':\n\t\tdefault:\n\t\t\tsuccess = 0;\n\t\t}\n\n\tif (!success)\n\t\treturn success;\n\n\t/* Pick off the names and collect them in the temp buffer in the order\n\t   in which they are found, separated by '::'.  */\n\n\twhile (qualifiers-- > 0) {\n\t\tint remember_K = 1;\n\t\tstring_clear(&last_name);\n\n\t\tif (*mangled[0] == '_')\n\t\t\t(*mangled)++;\n\n\t\tif (*mangled[0] == 't') {\n\t\t\t/* Here we always append to TEMP since we will want to use\n\t\t\t   the template name without the template parameters as a\n\t\t\t   constructor or destructor name.  The appropriate\n\t\t\t   (parameter-less) value is returned by demangle_template\n\t\t\t   in LAST_NAME.  We do not remember the template type here,\n\t\t\t   in order to match the G++ mangling algorithm.  */\n\t\t\tsuccess = demangle_template(work, mangled, &temp,\n\t\t\t\t&last_name, 1, 0);\n\t\t\tif (!success)\n\t\t\t\tbreak;\n\t\t} else if (*mangled[0] == 'K') {\n\t\t\tint idx;\n\t\t\t(*mangled)++;\n\t\t\tidx = consume_count_with_underscores(mangled);\n\t\t\tif (idx == -1 || idx >= work->numk)\n\t\t\t\tsuccess = 0;\n\t\t\telse\n\t\t\t\tstring_append(&temp, work->ktypevec[idx]);\n\t\t\tremember_K = 0;\n\n\t\t\tif (!success)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (EDG_DEMANGLING) {\n\t\t\t\tint namelength;\n\t\t\t\t/* Now recursively demangle the qualifier\n\t\t\t\t * This is necessary to deal with templates in\n\t\t\t\t * mangling styles like EDG */\n\t\t\t\tnamelength = consume_count(mangled);\n\t\t\t\tif (namelength == -1) {\n\t\t\t\t\tsuccess = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trecursively_demangle(work, mangled, &temp, namelength);\n\t\t\t} else {\n\t\t\t\tsuccess = do_type(work, mangled, &last_name);\n\t\t\t\tif (!success)\n\t\t\t\t\tbreak;\n\t\t\t\tstring_appends(&temp, &last_name);\n\t\t\t}\n\t\t}\n\n\t\tif (remember_K)\n\t\t\tremember_Ktype(work, temp.b, LEN_STRING(&temp));\n\n\t\tif (qualifiers > 0)\n\t\t\tstring_append(&temp, SCOPE_STRING(work));\n\t}\n\n\tremember_Btype(work, temp.b, LEN_STRING(&temp), bindex);\n\n\t/* If we are using the result as a function name, we need to append\n\t   the appropriate '::' separated constructor or destructor name.\n\t   We do this here because this is the most convenient place, where\n\t   we already have a pointer to the name and the length of the name.  */\n\n\tif (isfuncname) {\n\t\tstring_append(&temp, SCOPE_STRING(work));\n\t\tif (work->destructor & 1)\n\t\t\tstring_append(&temp, \"~\");\n\t\tstring_appends(&temp, &last_name);\n\t}\n\n\t/* Now either prepend the temp buffer to the result, or append it,\n\t   depending upon the state of the append flag.  */\n\n\tif (append)\n\t\tstring_appends(result, &temp);\n\telse {\n\t\tif (!STRING_EMPTY(result))\n\t\t\tstring_append(&temp, SCOPE_STRING(work));\n\t\tstring_prepends(result, &temp);\n\t}\n\n\tstring_delete(&last_name);\n\tstring_delete(&temp);\n\treturn (success);\n}\n\n/*\n\nLOCAL FUNCTION\n\n\tget_count -- convert an ascii count to integer, consuming tokens\n\nSYNOPSIS\n\n\tstatic int\n\tget_count (const char **type, int *count)\n\nDESCRIPTION\n\n\tAssume that *type points at a count in a mangled name; set\n\t*count to its value, and set *type to the next character after\n\tthe count.  There are some weird rules in effect here.\n\n\tIf *type does not point at a string of digits, return zero.\n\n\tIf *type points at a string of digits followed by an\n\tunderscore, set *count to their value as an integer, advance\n\t*type to point *after the underscore, and return 1.\n\n\tIf *type points at a string of digits not followed by an\n\tunderscore, consume only the first digit.  Set *count to its\n\tvalue as an integer, leave *type pointing after that digit,\n\tand return 1.\n\n\tThe excuse for this odd behavior: in the ARM and HP demangling\n\tstyles, a type can be followed by a repeat count of the form\n\t`Nxy', where:\n\n\t`x' is a single digit specifying how many additional copies\n\t    of the type to append to the argument list, and\n\n\t`y' is one or more digits, specifying the zero-based index of\n\t    the first repeated argument in the list.  Yes, as you're\n\t    unmangling the name you can figure this out yourself, but\n\t    it's there anyway.\n\n\tSo, for example, in `bar__3fooFPiN51', the first argument is a\n\tpointer to an integer (`Pi'), and then the next five arguments\n\tare the same (`N5'), and the first repeat is the function's\n\tsecond argument (`1').\n*/\n\nstatic int\n\tget_count(type, count)\n\t\tconst char **type;\nint *count;\n{\n\tconst char *p;\n\tint n;\n\n\tif (!isdigit((unsigned char)**type)) {\n\t\treturn (0);\n\t} else {\n\t\t*count = **type - '0';\n\t\t(*type)++;\n\t\tif (isdigit((unsigned char)**type)) {\n\t\t\tp = *type;\n\t\t\tn = *count;\n\t\t\tdo {\n\t\t\t\tn *= 10;\n\t\t\t\tn += *p - '0';\n\t\t\t\tp++;\n\t\t\t} while (isdigit((unsigned char)*p));\n\t\t\tif (*p == '_') {\n\t\t\t\t*type = p + 1;\n\t\t\t\t*count = n;\n\t\t\t}\n\t\t}\n\t}\n\treturn (1);\n}\n\n/* RESULT will be initialised here; it will be freed on failure.  The\n   value returned is really a type_kind_t.  */\n\nstatic int\ndo_type(work, mangled, result)\nstruct work_stuff *work;\nconst char **mangled;\nstring *result;\n{\n\tint n;\n\tint done;\n\tint success;\n\tstring decl;\n\tconst char *remembered_type;\n\tint type_quals;\n\tstring btype;\n\ttype_kind_t tk = tk_none;\n\n\tstring_init(&btype);\n\tstring_init(&decl);\n\tstring_init(result);\n\n\tdone = 0;\n\tsuccess = 1;\n\twhile (success && !done) {\n\t\tint member;\n\t\tswitch (**mangled) {\n\n\t\t\t/* A pointer type */\n\t\tcase 'P':\n\t\tcase 'p':\n\t\t\t(*mangled)++;\n\t\t\tif (!(work->options & DMGL_JAVA))\n\t\t\t\tstring_prepend(&decl, \"*\");\n\t\t\tif (tk == tk_none)\n\t\t\t\ttk = tk_pointer;\n\t\t\tbreak;\n\n\t\t\t/* A reference type */\n\t\tcase 'R':\n\t\t\t(*mangled)++;\n\t\t\tstring_prepend(&decl, \"&\");\n\t\t\tif (tk == tk_none)\n\t\t\t\ttk = tk_reference;\n\t\t\tbreak;\n\n\t\t\t/* An array */\n\t\tcase 'A': {\n\t\t\t++(*mangled);\n\t\t\tif (!STRING_EMPTY(&decl) && (decl.b[0] == '*' || decl.b[0] == '&')) {\n\t\t\t\tstring_prepend(&decl, \"(\");\n\t\t\t\tstring_append(&decl, \")\");\n\t\t\t}\n\t\t\tstring_append(&decl, \"[\");\n\t\t\tif (**mangled != '_')\n\t\t\t\tsuccess = demangle_template_value_parm(work, mangled, &decl,\n\t\t\t\t\ttk_integral);\n\t\t\tif (**mangled == '_')\n\t\t\t\t++(*mangled);\n\t\t\tstring_append(&decl, \"]\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/* A back reference to a previously seen type */\n\t\tcase 'T':\n\t\t\t(*mangled)++;\n\t\t\tif (!get_count(mangled, &n) || n >= work->ntypes) {\n\t\t\t\tsuccess = 0;\n\t\t\t} else {\n\t\t\t\tremembered_type = work->typevec[n];\n\t\t\t\tmangled = &remembered_type;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* A function */\n\t\tcase 'F':\n\t\t\t(*mangled)++;\n\t\t\tif (!STRING_EMPTY(&decl) && (decl.b[0] == '*' || decl.b[0] == '&')) {\n\t\t\t\tstring_prepend(&decl, \"(\");\n\t\t\t\tstring_append(&decl, \")\");\n\t\t\t}\n\t\t\t/* After picking off the function args, we expect to either find the\n\t\t\t   function return type (preceded by an '_') or the end of the\n\t\t\t   string.  */\n\t\t\tif (!demangle_nested_args(work, mangled, &decl) || (**mangled != '_' && **mangled != '\\0')) {\n\t\t\t\tsuccess = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (success && (**mangled == '_'))\n\t\t\t\t(*mangled)++;\n\t\t\tbreak;\n\n\t\tcase 'M':\n\t\tcase 'O': {\n\t\t\ttype_quals = TYPE_UNQUALIFIED;\n\n\t\t\tmember = **mangled == 'M';\n\t\t\t(*mangled)++;\n\n\t\t\tstring_append(&decl, \")\");\n\t\t\tstring_prepend(&decl, SCOPE_STRING(work));\n\t\t\tif (isdigit((unsigned char)**mangled)) {\n\t\t\t\tn = consume_count(mangled);\n\t\t\t\tif (n == -1 || (int)strlen(*mangled) < n) {\n\t\t\t\t\tsuccess = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstring_prependn(&decl, *mangled, n);\n\t\t\t\t*mangled += n;\n\t\t\t} else if (**mangled == 'X' || **mangled == 'Y') {\n\t\t\t\tstring temp;\n\t\t\t\tdo_type(work, mangled, &temp);\n\t\t\t\tstring_prepends(&decl, &temp);\n\t\t\t} else if (**mangled == 't') {\n\t\t\t\tstring temp;\n\t\t\t\tstring_init(&temp);\n\t\t\t\tsuccess = demangle_template(work, mangled, &temp,\n\t\t\t\t\tNULL, 1, 1);\n\t\t\t\tif (success) {\n\t\t\t\t\tstring_prependn(&decl, temp.b, temp.p - temp.b);\n\t\t\t\t\tstring_clear(&temp);\n\t\t\t\t} else\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tsuccess = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstring_prepend(&decl, \"(\");\n\t\t\tif (member) {\n\t\t\t\tswitch (**mangled) {\n\t\t\t\tcase 'C':\n\t\t\t\tcase 'V':\n\t\t\t\tcase 'u':\n\t\t\t\t\ttype_quals |= code_for_qualifier(**mangled);\n\t\t\t\t\t(*mangled)++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (*(*mangled)++ != 'F') {\n\t\t\t\t\tsuccess = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((member && !demangle_nested_args(work, mangled, &decl)) || **mangled != '_') {\n\t\t\t\tsuccess = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t(*mangled)++;\n\t\t\tif (!PRINT_ANSI_QUALIFIERS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (type_quals != TYPE_UNQUALIFIED) {\n\t\t\t\tAPPEND_BLANK(&decl);\n\t\t\t\tstring_append(&decl, qualifier_string(type_quals));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 'G':\n\t\t\t(*mangled)++;\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\tcase 'V':\n\t\tcase 'u':\n\t\t\tif (PRINT_ANSI_QUALIFIERS) {\n\t\t\t\tif (!STRING_EMPTY(&decl))\n\t\t\t\t\tstring_prepend(&decl, \" \");\n\n\t\t\t\tstring_prepend(&decl, demangle_qualifier(**mangled));\n\t\t\t}\n\t\t\t(*mangled)++;\n\t\t\tbreak;\n\t\t\t/*\n\t\t\t  }\n\t\t\t  */\n\n\t\t\t/* fall through */\n\t\tdefault:\n\t\t\tdone = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (success)\n\t\tswitch (**mangled) {\n\t\t\t/* A qualified name, such as \"Outer::Inner\".  */\n\t\tcase 'Q':\n\t\tcase 'K': {\n\t\t\tsuccess = demangle_qualified(work, mangled, result, 0, 1);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* A back reference to a previously seen squangled type */\n\t\tcase 'B':\n\t\t\t(*mangled)++;\n\t\t\tif (!get_count(mangled, &n) || n >= work->numb)\n\t\t\t\tsuccess = 0;\n\t\t\telse\n\t\t\t\tstring_append(result, work->btypevec[n]);\n\t\t\tbreak;\n\n\t\tcase 'X':\n\t\tcase 'Y':\n\t\t\t/* A template parm.  We substitute the corresponding argument. */\n\t\t\t{\n\t\t\t\tint idx;\n\n\t\t\t\t(*mangled)++;\n\t\t\t\tidx = consume_count_with_underscores(mangled);\n\n\t\t\t\tif (idx == -1 || (work->tmpl_argvec && idx >= work->ntmpl_args) || consume_count_with_underscores(mangled) == -1) {\n\t\t\t\t\tsuccess = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (work->tmpl_argvec)\n\t\t\t\t\tstring_append(result, work->tmpl_argvec[idx]);\n\t\t\t\telse {\n\t\t\t\t\tchar buf[10];\n\t\t\t\t\tsprintf(buf, \"T%d\", idx);\n\t\t\t\t\tstring_append(result, buf);\n\t\t\t\t}\n\n\t\t\t\tsuccess = 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tsuccess = demangle_fund_type(work, mangled, result);\n\t\t\tif (tk == tk_none)\n\t\t\t\ttk = (type_kind_t)success;\n\t\t\tbreak;\n\t\t}\n\n\tif (success) {\n\t\tif (!STRING_EMPTY(&decl)) {\n\t\t\tstring_append(result, \" \");\n\t\t\tstring_appends(result, &decl);\n\t\t}\n\t} else\n\t\tstring_delete(result);\n\tstring_delete(&decl);\n\n\tif (success)\n\t\t/* Assume an integral type, if we're not sure.  */\n\t\treturn (int)((tk == tk_none) ? tk_integral : tk);\n\telse\n\t\treturn 0;\n}\n\n/* Given a pointer to a type string that represents a fundamental type\n   argument (int, long, unsigned int, etc) in TYPE, a pointer to the\n   string in which the demangled output is being built in RESULT, and\n   the WORK structure, decode the types and add them to the result.\n\n   For example:\n\n\t\"Ci\"\t=>\t\"const int\"\n\t\"Sl\"\t=>\t\"signed long\"\n\t\"CUs\"\t=>\t\"const unsigned short\"\n\n   The value returned is really a type_kind_t.  */\n\nstatic int\ndemangle_fund_type(work, mangled, result)\nstruct work_stuff *work;\nconst char **mangled;\nstring *result;\n{\n\tint done = 0;\n\tint success = 1;\n\tchar buf[10];\n\tint dec = 0;\n\tstring btype;\n\ttype_kind_t tk = tk_integral;\n\n\tstring_init(&btype);\n\n\t/* First pick off any type qualifiers.  There can be more than one.  */\n\n\twhile (!done) {\n\t\tswitch (**mangled) {\n\t\tcase 'C':\n\t\tcase 'V':\n\t\tcase 'u':\n\t\t\tif (PRINT_ANSI_QUALIFIERS) {\n\t\t\t\tif (!STRING_EMPTY(result))\n\t\t\t\t\tstring_prepend(result, \" \");\n\t\t\t\tstring_prepend(result, demangle_qualifier(**mangled));\n\t\t\t}\n\t\t\t(*mangled)++;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\t(*mangled)++;\n\t\t\tAPPEND_BLANK(result);\n\t\t\tstring_append(result, \"unsigned\");\n\t\t\tbreak;\n\t\tcase 'S': /* signed char only */\n\t\t\t(*mangled)++;\n\t\t\tAPPEND_BLANK(result);\n\t\t\tstring_append(result, \"signed\");\n\t\t\tbreak;\n\t\tcase 'J':\n\t\t\t(*mangled)++;\n\t\t\tAPPEND_BLANK(result);\n\t\t\tstring_append(result, \"__complex\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdone = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Now pick off the fundamental type.  There can be only one.  */\n\n\tswitch (**mangled) {\n\tcase '\\0':\n\tcase '_':\n\t\tbreak;\n\tcase 'v':\n\t\t(*mangled)++;\n\t\tAPPEND_BLANK(result);\n\t\tstring_append(result, \"void\");\n\t\tbreak;\n\tcase 'x':\n\t\t(*mangled)++;\n\t\tAPPEND_BLANK(result);\n\t\tstring_append(result, \"long long\");\n\t\tbreak;\n\tcase 'l':\n\t\t(*mangled)++;\n\t\tAPPEND_BLANK(result);\n\t\tstring_append(result, \"long\");\n\t\tbreak;\n\tcase 'i':\n\t\t(*mangled)++;\n\t\tAPPEND_BLANK(result);\n\t\tstring_append(result, \"int\");\n\t\tbreak;\n\tcase 's':\n\t\t(*mangled)++;\n\t\tAPPEND_BLANK(result);\n\t\tstring_append(result, \"short\");\n\t\tbreak;\n\tcase 'b':\n\t\t(*mangled)++;\n\t\tAPPEND_BLANK(result);\n\t\tstring_append(result, \"bool\");\n\t\ttk = tk_bool;\n\t\tbreak;\n\tcase 'c':\n\t\t(*mangled)++;\n\t\tAPPEND_BLANK(result);\n\t\tstring_append(result, \"char\");\n\t\ttk = tk_char;\n\t\tbreak;\n\tcase 'w':\n\t\t(*mangled)++;\n\t\tAPPEND_BLANK(result);\n\t\tstring_append(result, \"wchar_t\");\n\t\ttk = tk_char;\n\t\tbreak;\n\tcase 'r':\n\t\t(*mangled)++;\n\t\tAPPEND_BLANK(result);\n\t\tstring_append(result, \"long double\");\n\t\ttk = tk_real;\n\t\tbreak;\n\tcase 'd':\n\t\t(*mangled)++;\n\t\tAPPEND_BLANK(result);\n\t\tstring_append(result, \"double\");\n\t\ttk = tk_real;\n\t\tbreak;\n\tcase 'f':\n\t\t(*mangled)++;\n\t\tAPPEND_BLANK(result);\n\t\tstring_append(result, \"float\");\n\t\ttk = tk_real;\n\t\tbreak;\n\tcase 'G':\n\t\t(*mangled)++;\n\t\tif (!isdigit((unsigned char)**mangled)) {\n\t\t\tsuccess = 0;\n\t\t\tbreak;\n\t\t}\n\tcase 'I':\n\t\t(*mangled)++;\n\t\tif (**mangled == '_') {\n\t\t\tint i;\n\t\t\t(*mangled)++;\n\t\t\tfor (i = 0;\n\t\t\t\ti < sizeof(buf) - 1 && **mangled && **mangled != '_';\n\t\t\t\t(*mangled)++, i++)\n\t\t\t\tbuf[i] = **mangled;\n\t\t\tif (**mangled != '_') {\n\t\t\t\tsuccess = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf[i] = '\\0';\n\t\t\t(*mangled)++;\n\t\t} else {\n\t\t\tstrncpy(buf, *mangled, 2);\n\t\t\tbuf[2] = '\\0';\n\t\t\t*mangled += min(strlen(*mangled), 2);\n\t\t}\n\t\tsscanf(buf, \"%x\", &dec);\n\t\tsprintf(buf, \"int%i_t\", dec);\n\t\tAPPEND_BLANK(result);\n\t\tstring_append(result, buf);\n\t\tbreak;\n\n\t\t/* fall through */\n\t\t/* An explicit type, such as \"6mytype\" or \"7integer\" */\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9': {\n\t\tint bindex = register_Btype(work);\n\t\tstring btype;\n\t\tstring_init(&btype);\n\t\tif (demangle_class_name(work, mangled, &btype)) {\n\t\t\tremember_Btype(work, btype.b, LEN_STRING(&btype), bindex);\n\t\t\tAPPEND_BLANK(result);\n\t\t\tstring_appends(result, &btype);\n\t\t} else\n\t\t\tsuccess = 0;\n\t\tstring_delete(&btype);\n\t\tbreak;\n\t}\n\tcase 't': {\n\t\tsuccess = demangle_template(work, mangled, &btype, 0, 1, 1);\n\t\tstring_appends(result, &btype);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tsuccess = 0;\n\t\tbreak;\n\t}\n\n\treturn success ? ((int)tk) : 0;\n}\n\n/* Handle a template's value parameter for HP aCC (extension from ARM)\n **mangled points to 'S' or 'U' */\n\nstatic int\ndo_hpacc_template_const_value(work, mangled, result)\nstruct work_stuff *work;\nconst char **mangled;\nstring *result;\n{\n\tint unsigned_const;\n\n\tif (**mangled != 'U' && **mangled != 'S')\n\t\treturn 0;\n\n\tunsigned_const = (**mangled == 'U');\n\n\t(*mangled)++;\n\n\tswitch (**mangled) {\n\tcase 'N':\n\t\tstring_append(result, \"-\");\n\t\t/* fall through */\n\tcase 'P':\n\t\t(*mangled)++;\n\t\tbreak;\n\tcase 'M':\n\t\t/* special case for -2^31 */\n\t\tstring_append(result, \"-2147483648\");\n\t\t(*mangled)++;\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t/* We have to be looking at an integer now */\n\tif (!(isdigit((unsigned char)**mangled)))\n\t\treturn 0;\n\n\t/* We only deal with integral values for template\n\t   parameters -- so it's OK to look only for digits */\n\twhile (isdigit((unsigned char)**mangled)) {\n\t\tchar_str[0] = **mangled;\n\t\tstring_append(result, char_str);\n\t\t(*mangled)++;\n\t}\n\n\tif (unsigned_const)\n\t\tstring_append(result, \"U\");\n\n\t/* FIXME? Some day we may have 64-bit (or larger :-) ) constants\n\t   with L or LL suffixes. pai/1997-09-03 */\n\n\treturn 1; /* success */\n}\n\n/* Handle a template's literal parameter for HP aCC (extension from ARM)\n **mangled is pointing to the 'A' */\n\nstatic int\ndo_hpacc_template_literal(work, mangled, result)\nstruct work_stuff *work;\nconst char **mangled;\nstring *result;\n{\n\tint literal_len = 0;\n\tchar *recurse;\n\tchar *recurse_dem;\n\n\tif (**mangled != 'A')\n\t\treturn 0;\n\n\t(*mangled)++;\n\n\tliteral_len = consume_count(mangled);\n\n\tif (literal_len <= 0)\n\t\treturn 0;\n\n\t/* Literal parameters are names of arrays, functions, etc.  and the\n\t   canonical representation uses the address operator */\n\tstring_append(result, \"&\");\n\n\t/* Now recursively demangle the literal name */\n\trecurse = (char *)malloc(literal_len + 1);\n\tmemcpy(recurse, *mangled, literal_len);\n\trecurse[literal_len] = '\\000';\n\n\trecurse_dem = cplus_demangle_v2(recurse, work->options);\n\n\tif (recurse_dem) {\n\t\tstring_append(result, recurse_dem);\n\t\tfree(recurse_dem);\n\t} else {\n\t\tstring_appendn(result, *mangled, literal_len);\n\t}\n\t(*mangled) += literal_len;\n\tfree(recurse);\n\n\treturn 1;\n}\n\nstatic int\n\tsnarf_numeric_literal(args, arg)\n\t\tconst char **args;\nstring *arg;\n{\n\tif (**args == '-') {\n\t\tchar_str[0] = '-';\n\t\tstring_append(arg, char_str);\n\t\t(*args)++;\n\t} else if (**args == '+')\n\t\t(*args)++;\n\n\tif (!isdigit((unsigned char)**args))\n\t\treturn 0;\n\n\twhile (isdigit((unsigned char)**args)) {\n\t\tchar_str[0] = **args;\n\t\tstring_append(arg, char_str);\n\t\t(*args)++;\n\t}\n\n\treturn 1;\n}\n\n/* Demangle the next argument, given by MANGLED into RESULT, which\n   *should be an uninitialized* string.  It will be initialized here,\n   and free'd should anything go wrong.  */\n\nstatic int\ndo_arg(work, mangled, result)\nstruct work_stuff *work;\nconst char **mangled;\nstring *result;\n{\n\t/* Remember where we started so that we can record the type, for\n\t   non-squangling type remembering.  */\n\tconst char *start = *mangled;\n\n\tstring_init(result);\n\n\tif (work->nrepeats > 0) {\n\t\t--work->nrepeats;\n\n\t\tif (work->previous_argument == 0)\n\t\t\treturn 0;\n\n\t\t/* We want to reissue the previous type in this argument list.  */\n\t\tstring_appends(result, work->previous_argument);\n\t\treturn 1;\n\t}\n\n\tif (**mangled == 'n') {\n\t\t/* A squangling-style repeat.  */\n\t\t(*mangled)++;\n\t\twork->nrepeats = consume_count(mangled);\n\n\t\tif (work->nrepeats <= 0)\n\t\t\t/* This was not a repeat count after all.  */\n\t\t\treturn 0;\n\n\t\tif (work->nrepeats > 9) {\n\t\t\tif (**mangled != '_')\n\t\t\t\t/* The repeat count should be followed by an '_' in this\n\t\t\t\t   case.  */\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\t(*mangled)++;\n\t\t}\n\n\t\t/* Now, the repeat is all set up.  */\n\t\treturn do_arg(work, mangled, result);\n\t}\n\n\t/* Save the result in WORK->previous_argument so that we can find it\n\t   if it's repeated.  Note that saving START is not good enough: we\n\t   do not want to add additional types to the back-referenceable\n\t   type vector when processing a repeated type.  */\n\tif (work->previous_argument)\n\t\tstring_clear(work->previous_argument);\n\telse {\n\t\twork->previous_argument = (string *)malloc(sizeof(string));\n\t\tstring_init(work->previous_argument);\n\t}\n\n\tif (!do_type(work, mangled, work->previous_argument))\n\t\treturn 0;\n\n\tstring_appends(result, work->previous_argument);\n\n\tremember_type(work, start, *mangled - start);\n\treturn 1;\n}\n\nstatic void\n\tremember_type(work, start, len) struct work_stuff *work;\nconst char *start;\nint len;\n{\n\tchar *tem;\n\n\tif (work->forgetting_types)\n\t\treturn;\n\n\tif (work->ntypes >= work->typevec_size) {\n\t\tif (work->typevec_size == 0) {\n\t\t\twork->typevec_size = 3;\n\t\t\twork->typevec = (char **)malloc(sizeof(char *) * work->typevec_size);\n\t\t} else {\n\t\t\twork->typevec_size *= 2;\n\t\t\twork->typevec = (char **)realloc((char *)work->typevec,\n\t\t\t\tsizeof(char *) * work->typevec_size);\n\t\t}\n\t}\n\ttem = malloc(len + 1);\n\tmemcpy(tem, start, len);\n\ttem[len] = '\\0';\n\twork->typevec[work->ntypes++] = tem;\n}\n\n/* Remember a K type class qualifier. */\nstatic void\n\tremember_Ktype(work, start, len) struct work_stuff *work;\nconst char *start;\nint len;\n{\n\tchar *tem;\n\n\tif (work->numk >= work->ksize) {\n\t\tif (work->ksize == 0) {\n\t\t\twork->ksize = 5;\n\t\t\twork->ktypevec = (char **)malloc(sizeof(char *) * work->ksize);\n\t\t} else {\n\t\t\twork->ksize *= 2;\n\t\t\twork->ktypevec = (char **)realloc((char *)work->ktypevec,\n\t\t\t\tsizeof(char *) * work->ksize);\n\t\t}\n\t}\n\ttem = malloc(len + 1);\n\tmemcpy(tem, start, len);\n\ttem[len] = '\\0';\n\twork->ktypevec[work->numk++] = tem;\n}\n\n/* Register a B code, and get an index for it. B codes are registered\n   as they are seen, rather than as they are completed, so map<temp<char> >\n   registers map<temp<char> > as B0, and temp<char> as B1 */\n\nstatic int\nregister_Btype(work)\nstruct work_stuff *work;\n{\n\tint ret;\n\n\tif (work->numb >= work->bsize) {\n\t\tif (work->bsize == 0) {\n\t\t\twork->bsize = 5;\n\t\t\twork->btypevec = (char **)malloc(sizeof(char *) * work->bsize);\n\t\t} else {\n\t\t\twork->bsize *= 2;\n\t\t\twork->btypevec = (char **)realloc((char *)work->btypevec,\n\t\t\t\tsizeof(char *) * work->bsize);\n\t\t}\n\t}\n\tret = work->numb++;\n\twork->btypevec[ret] = NULL;\n\treturn (ret);\n}\n\n/* Store a value into a previously registered B code type. */\n\nstatic void\n\tremember_Btype(work, start, len, index) struct work_stuff *work;\nconst char *start;\nint len, index;\n{\n\tchar *tem;\n\n\ttem = malloc(len + 1);\n\tmemcpy(tem, start, len);\n\ttem[len] = '\\0';\n\twork->btypevec[index] = tem;\n}\n\n/* Lose all the info related to B and K type codes. */\nstatic void\n\tforget_B_and_K_types(work) struct work_stuff *work;\n{\n\tint i;\n\n\twhile (work->numk > 0) {\n\t\ti = --(work->numk);\n\t\tif (work->ktypevec[i] != NULL) {\n\t\t\tfree(work->ktypevec[i]);\n\t\t\twork->ktypevec[i] = NULL;\n\t\t}\n\t}\n\n\twhile (work->numb > 0) {\n\t\ti = --(work->numb);\n\t\tif (work->btypevec[i] != NULL) {\n\t\t\tfree(work->btypevec[i]);\n\t\t\twork->btypevec[i] = NULL;\n\t\t}\n\t}\n}\n/* Forget the remembered types, but not the type vector itself.  */\n\nstatic void\n\tforget_types(work) struct work_stuff *work;\n{\n\tint i;\n\n\twhile (work->ntypes > 0) {\n\t\ti = --(work->ntypes);\n\t\tif (work->typevec[i] != NULL) {\n\t\t\tfree(work->typevec[i]);\n\t\t\twork->typevec[i] = NULL;\n\t\t}\n\t}\n}\n\n/* Process the argument list part of the signature, after any class spec\n   has been consumed, as well as the first 'F' character (if any).  For\n   example:\n\n   \"__als__3fooRT0\"\t\t=>\tprocess \"RT0\"\n   \"complexfunc5__FPFPc_PFl_i\"\t=>\tprocess \"PFPc_PFl_i\"\n\n   DECLP must be already initialised, usually non-empty.  It won't be freed\n   on failure.\n\n   Note that g++ differs significantly from ARM and lucid style mangling\n   with regards to references to previously seen types.  For example, given\n   the source fragment:\n\n     class foo {\n       public:\n       foo::foo (int, foo &ia, int, foo &ib, int, foo &ic);\n     };\n\n     foo::foo (int, foo &ia, int, foo &ib, int, foo &ic) { ia = ib = ic; }\n     void foo (int, foo &ia, int, foo &ib, int, foo &ic) { ia = ib = ic; }\n\n   g++ produces the names:\n\n     __3fooiRT0iT2iT2\n     foo__FiR3fooiT1iT1\n\n   while lcc (and presumably other ARM style compilers as well) produces:\n\n     foo__FiR3fooT1T2T1T2\n     __ct__3fooFiR3fooT1T2T1T2\n\n   Note that g++ bases its type numbers starting at zero and counts all\n   previously seen types, while lucid/ARM bases its type numbers starting\n   at one and only considers types after it has seen the 'F' character\n   indicating the start of the function args.  For lucid/ARM style, we\n   account for this difference by discarding any previously seen types when\n   we see the 'F' character, and subtracting one from the type number\n   reference.\n\n */\n\nstatic int\ndemangle_args(work, mangled, declp)\nstruct work_stuff *work;\nconst char **mangled;\nstring *declp;\n{\n\tstring arg;\n\tint need_comma = 0;\n\tint r;\n\tint t;\n\tconst char *tem;\n\tchar temptype;\n\n\tif (PRINT_ARG_TYPES) {\n\t\tstring_append(declp, \"(\");\n\t\tif (**mangled == '\\0') {\n\t\t\tstring_append(declp, \"void\");\n\t\t}\n\t}\n\n\twhile ((**mangled != '_' && **mangled != '\\0' && **mangled != 'e') || work->nrepeats > 0) {\n\t\tif ((**mangled == 'N') || (**mangled == 'T')) {\n\t\t\ttemptype = *(*mangled)++;\n\n\t\t\tif (temptype == 'N') {\n\t\t\t\tif (!get_count(mangled, &r)) {\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr = 1;\n\t\t\t}\n\t\t\tif ((HP_DEMANGLING || ARM_DEMANGLING || EDG_DEMANGLING) && work->ntypes >= 10) {\n\t\t\t\t/* If we have 10 or more types we might have more than a 1 digit\n\t\t\t\t   index so we'll have to consume the whole count here. This\n\t\t\t\t   will lose if the next thing is a type name preceded by a\n\t\t\t\t   count but it's impossible to demangle that case properly\n\t\t\t\t   anyway. Eg if we already have 12 types is T12Pc \"(..., type1,\n\t\t\t\t   Pc, ...)\"  or \"(..., type12, char *, ...)\" */\n\t\t\t\tif ((t = consume_count(mangled)) <= 0) {\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!get_count(mangled, &t)) {\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING) {\n\t\t\t\tt--;\n\t\t\t}\n\t\t\t/* Validate the type index.  Protect against illegal indices from\n\t\t\t   malformed type strings.  */\n\t\t\tif ((t < 0) || (t >= work->ntypes)) {\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\twhile (work->nrepeats > 0 || --r >= 0) {\n\t\t\t\ttem = work->typevec[t];\n\t\t\t\tif (need_comma && PRINT_ARG_TYPES) {\n\t\t\t\t\tstring_append(declp, \", \");\n\t\t\t\t}\n\t\t\t\tif (!do_arg(work, &tem, &arg)) {\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tif (PRINT_ARG_TYPES) {\n\t\t\t\t\tstring_appends(declp, &arg);\n\t\t\t\t}\n\t\t\t\tstring_delete(&arg);\n\t\t\t\tneed_comma = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (need_comma && PRINT_ARG_TYPES)\n\t\t\t\tstring_append(declp, \", \");\n\t\t\tif (!do_arg(work, mangled, &arg))\n\t\t\t\treturn (0);\n\t\t\tif (PRINT_ARG_TYPES)\n\t\t\t\tstring_appends(declp, &arg);\n\t\t\tstring_delete(&arg);\n\t\t\tneed_comma = 1;\n\t\t}\n\t}\n\n\tif (**mangled == 'e') {\n\t\t(*mangled)++;\n\t\tif (PRINT_ARG_TYPES) {\n\t\t\tif (need_comma) {\n\t\t\t\tstring_append(declp, \",\");\n\t\t\t}\n\t\t\tstring_append(declp, \"...\");\n\t\t}\n\t}\n\n\tif (PRINT_ARG_TYPES) {\n\t\tstring_append(declp, \")\");\n\t}\n\treturn (1);\n}\n\n/* Like demangle_args, but for demangling the argument lists of function\n   and method pointers or references, not top-level declarations.  */\n\nstatic int\ndemangle_nested_args(work, mangled, declp)\nstruct work_stuff *work;\nconst char **mangled;\nstring *declp;\n{\n\tstring *saved_previous_argument;\n\tint result;\n\tint saved_nrepeats;\n\n\t/* The G++ name-mangling algorithm does not remember types on nested\n\t   argument lists, unless -fsquangling is used, and in that case the\n\t   type vector updated by remember_type is not used.  So, we turn\n\t   off remembering of types here.  */\n\t++work->forgetting_types;\n\n\t/* For the repeat codes used with -fsquangling, we must keep track of\n\t   the last argument.  */\n\tsaved_previous_argument = work->previous_argument;\n\tsaved_nrepeats = work->nrepeats;\n\twork->previous_argument = 0;\n\twork->nrepeats = 0;\n\n\t/* Actually demangle the arguments.  */\n\tresult = demangle_args(work, mangled, declp);\n\n\t/* Restore the previous_argument field.  */\n\tif (work->previous_argument)\n\t\tstring_delete(work->previous_argument);\n\twork->previous_argument = saved_previous_argument;\n\t--work->forgetting_types;\n\twork->nrepeats = saved_nrepeats;\n\n\treturn result;\n}\n\nstatic void\n\tdemangle_function_name(work, mangled, declp, scan) struct work_stuff *work;\nconst char **mangled;\nstring *declp;\nconst char *scan;\n{\n\tsize_t i;\n\tstring type;\n\tconst char *tem;\n\n\tstring_appendn(declp, (*mangled), scan - (*mangled));\n\tstring_need(declp, 1);\n\t*(declp->p) = '\\0';\n\n\t/* Consume the function name, including the \"__\" separating the name\n\t   from the signature.  We are guaranteed that SCAN points to the\n\t   separator.  */\n\n\t(*mangled) = scan + 2;\n\t/* We may be looking at an instantiation of a template function:\n\t   foo__Xt1t2_Ft3t4, where t1, t2, ... are template arguments and a\n\t   following _F marks the start of the function arguments.  Handle\n\t   the template arguments first. */\n\n\tif (HP_DEMANGLING && (**mangled == 'X')) {\n\t\tdemangle_arm_hp_template(work, mangled, 0, declp);\n\t\t/* This leaves MANGLED pointing to the 'F' marking func args */\n\t}\n\n\tif (LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING) {\n\n\t\t/* See if we have an ARM style constructor or destructor operator.\n\t\t   If so, then just record it, clear the decl, and return.\n\t\t   We can't build the actual constructor/destructor decl until later,\n\t\t   when we recover the class name from the signature.  */\n\n\t\tif (strcmp(declp->b, \"__ct\") == 0) {\n\t\t\twork->constructor += 1;\n\t\t\tstring_clear(declp);\n\t\t\treturn;\n\t\t} else if (strcmp(declp->b, \"__dt\") == 0) {\n\t\t\twork->destructor += 1;\n\t\t\tstring_clear(declp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (declp->p - declp->b >= 3 && declp->b[0] == 'o' && declp->b[1] == 'p' && strchr(cplus_markers, declp->b[2]) != NULL) {\n\t\t/* see if it's an assignment expression */\n\t\tif (declp->p - declp->b >= 10 /* op$assign_ */\n\t\t\t&& memcmp(declp->b + 3, \"assign_\", 7) == 0) {\n\t\t\tfor (i = 0; i < sizeof(optable) / sizeof(optable[0]); i++) {\n\t\t\t\tint len = declp->p - declp->b - 10;\n\t\t\t\tif ((int)strlen(optable[i].in) == len && memcmp(optable[i].in, declp->b + 10, len) == 0) {\n\t\t\t\t\tstring_clear(declp);\n\t\t\t\t\tstring_append(declp, \"operator\");\n\t\t\t\t\tstring_append(declp, optable[i].out);\n\t\t\t\t\tstring_append(declp, \"=\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < sizeof(optable) / sizeof(optable[0]); i++) {\n\t\t\t\tint len = declp->p - declp->b - 3;\n\t\t\t\tif ((int)strlen(optable[i].in) == len && memcmp(optable[i].in, declp->b + 3, len) == 0) {\n\t\t\t\t\tstring_clear(declp);\n\t\t\t\t\tstring_append(declp, \"operator\");\n\t\t\t\t\tstring_append(declp, optable[i].out);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (declp->p - declp->b >= 5 && memcmp(declp->b, \"type\", 4) == 0 && strchr(cplus_markers, declp->b[4]) != NULL) {\n\t\t/* type conversion operator */\n\t\ttem = declp->b + 5;\n\t\tif (do_type(work, &tem, &type)) {\n\t\t\tstring_clear(declp);\n\t\t\tstring_append(declp, \"operator \");\n\t\t\tstring_appends(declp, &type);\n\t\t\tstring_delete(&type);\n\t\t}\n\t} else if (declp->b[0] == '_' && declp->b[1] == '_' && declp->b[2] == 'o' && declp->b[3] == 'p') {\n\t\t/* ANSI.  */\n\t\t/* type conversion operator.  */\n\t\ttem = declp->b + 4;\n\t\tif (do_type(work, &tem, &type)) {\n\t\t\tstring_clear(declp);\n\t\t\tstring_append(declp, \"operator \");\n\t\t\tstring_appends(declp, &type);\n\t\t\tstring_delete(&type);\n\t\t}\n\t} else if (declp->b[0] == '_' && declp->b[1] == '_' && declp->b[2] >= 'a' && declp->b[2] <= 'z' && declp->b[3] >= 'a' && declp->b[3] <= 'z') {\n\t\tif (declp->b[4] == '\\0') {\n\t\t\t/* Operator.  */\n\t\t\tfor (i = 0; i < sizeof(optable) / sizeof(optable[0]); i++) {\n\t\t\t\tif (strlen(optable[i].in) == 2 && memcmp(optable[i].in, declp->b + 2, 2) == 0) {\n\t\t\t\t\tstring_clear(declp);\n\t\t\t\t\tstring_append(declp, \"operator\");\n\t\t\t\t\tstring_append(declp, optable[i].out);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (declp->b[2] == 'a' && declp->b[5] == '\\0') {\n\t\t\t\t/* Assignment.  */\n\t\t\t\tfor (i = 0; i < sizeof(optable) / sizeof(optable[0]); i++) {\n\t\t\t\t\tif (strlen(optable[i].in) == 3 && memcmp(optable[i].in, declp->b + 2, 3) == 0) {\n\t\t\t\t\t\tstring_clear(declp);\n\t\t\t\t\t\tstring_append(declp, \"operator\");\n\t\t\t\t\t\tstring_append(declp, optable[i].out);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* a mini string-handling package */\n\nstatic void\n\tstring_need(s, n)\n\t\tstring *s;\nint n;\n{\n\tint tem;\n\n\tif (s->b == NULL) {\n\t\tif (n < 32) {\n\t\t\tn = 32;\n\t\t}\n\t\ts->p = s->b = malloc(n);\n\t\ts->e = s->b + n;\n\t} else if (s->e - s->p < n) {\n\t\ttem = s->p - s->b;\n\t\tn += tem;\n\t\tn *= 2;\n\t\ts->b = realloc(s->b, n);\n\t\ts->p = s->b + tem;\n\t\ts->e = s->b + n;\n\t}\n}\n\nstatic void\n\tstring_delete(s)\n\t\tstring *s;\n{\n\tif (s->b != NULL) {\n\t\tfree(s->b);\n\t\ts->b = s->e = s->p = NULL;\n\t}\n}\n\nstatic void\n\tstring_init(s)\n\t\tstring *s;\n{\n\ts->b = s->p = s->e = NULL;\n}\n\nstatic void\n\tstring_clear(s)\n\t\tstring *s;\n{\n\ts->p = s->b;\n}\n\n#if 0\n\nstatic int\nstring_empty (s)\n     string *s;\n{\n  return (s->b == s->p);\n}\n\n#endif\n\nstatic void\n\tstring_append(p, s)\n\t\tstring *p;\nconst char *s;\n{\n\tint n;\n\tif (s == NULL || *s == '\\0')\n\t\treturn;\n\tn = strlen(s);\n\tstring_need(p, n);\n\tmemcpy(p->p, s, n);\n\tp->p += n;\n}\n\nstatic void\n\tstring_appends(p, s)\n\t\tstring *p,\n\t*s;\n{\n\tint n;\n\n\tif (s->b != s->p) {\n\t\tn = s->p - s->b;\n\t\tstring_need(p, n);\n\t\tmemcpy(p->p, s->b, n);\n\t\tp->p += n;\n\t}\n}\n\nstatic void\n\tstring_appendn(p, s, n)\n\t\tstring *p;\nconst char *s;\nint n;\n{\n\tif (n != 0) {\n\t\tstring_need(p, n);\n\t\tmemcpy(p->p, s, n);\n\t\tp->p += n;\n\t}\n}\n\nstatic void\n\tstring_prepend(p, s)\n\t\tstring *p;\nconst char *s;\n{\n\tif (s != NULL && *s != '\\0') {\n\t\tstring_prependn(p, s, strlen(s));\n\t}\n}\n\nstatic void\n\tstring_prepends(p, s)\n\t\tstring *p,\n\t*s;\n{\n\tif (s->b != s->p) {\n\t\tstring_prependn(p, s->b, s->p - s->b);\n\t}\n}\n\nstatic void\n\tstring_prependn(p, s, n)\n\t\tstring *p;\nconst char *s;\nint n;\n{\n\tchar *q;\n\n\tif (n != 0) {\n\t\tstring_need(p, n);\n\t\tfor (q = p->p - 1; q >= p->b; q--) {\n\t\t\tq[n] = q[0];\n\t\t}\n\t\tmemcpy(p->b, s, n);\n\t\tp->p += n;\n\t}\n}\n", "// SPDX-FileCopyrightText: 2023 deroad <wargio@libero.it>\n// SPDX-License-Identifier: LGPL-3.0-only\n\n#include \"minunit.h\"\n\nmu_demangle_tests(gnu_v2,\n\tmu_demangle_test(\"_vt.foo\", \"foo virtual table\"),\n\tmu_demangle_test(\"_vt$foo\", \"foo virtual table\"),\n\tmu_demangle_test(\"_vt$foo$bar\", \"foo::bar virtual table\"),\n\tmu_demangle_test(\"__vt_foo\", \"foo virtual table\"),\n\tmu_demangle_test(\"_3foo$varname\", \"foo::varname\"),\n\tmu_demangle_test(\"__thunk_4__$_7ostream\", \"virtual function thunk (delta:-4) for ostream::~ostream(void)\"),\n\tmu_demangle_test(\"_$_3foo\", \"foo::~foo(void)\"),\n\tmu_demangle_test(\"_._3foo\", \"foo::~foo(void)\"),\n\tmu_demangle_test(\"_Q22rs2tu$vw\", \"rs::tu::vw\"),\n\tmu_demangle_test(\"__t6vector1Zii\", \"vector<int>::vector(int)\"),\n\tmu_demangle_test(\"foo__1Ai\", \"A::foo(int)\"),\n\tmu_demangle_test(\"foo__1Afe\", \"A::foo(float,...)\"),\n\tmu_demangle_test(\"_AddColor__10ZafDisplayUcUcUcUcUc\", \"ZafDisplay::_AddColor(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)\"),\n\t// end\n);\n\nmu_main(gnu_v2, cxx);"], "fixing_code": ["// SPDX-FileCopyrightText: 1989-1999 Free Software Foundation, Inc.\n// SPDX-License-Identifier: GPL-2.0-or-later\n\n/* Demangler for GNU C++\n   Copyright 1989, 91, 94, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.\n   Written by James Clark (jjc@jclark.uucp)\n   Rewritten by Fred Fish (fnf@cygnus.com) for ARM and Lucid demangling\n   Modified by Satish Pai (pai@apollo.hp.com) for HP demangling\n\nThis file is part of the libiberty library.\nLibiberty is free software; you can redistribute it and/or\nmodify it under the terms of the GNU Library General Public\nLicense as published by the Free Software Foundation; either\nversion 2 of the License, or (at your option) any later version.\n\nLibiberty is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nLibrary General Public License for more details.\n\nYou should have received a copy of the GNU Library General Public\nLicense along with libiberty; see the file COPYING.LIB.  If\nnot, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n/* This file exports two functions; cplus_mangle_opname and cplus_demangle_v2.\n\n   This file imports malloc and realloc, which are like malloc and\n   realloc except that they generate a fatal error if there is no\n   available memory.  */\n\n/* This file lives in both GCC and libiberty.  When making changes, please\n   try not to break either.  */\n\n#include <ctype.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"cplus-dem.h\"\n#undef CURRENT_DEMANGLING_STYLE\n#define CURRENT_DEMANGLING_STYLE work->options\n\n#define min(X, Y) (((X) < (Y)) ? (X) : (Y))\n\nstatic const char *mystrstr PARAMS((const char *, const char *));\n\nstatic const char *\n\tmystrstr(s1, s2)\n\t\tconst char *s1,\n\t*s2;\n{\n\tregister const char *p = s1;\n\tregister int len = strlen(s2);\n\n\tfor (; (p = strchr(p, *s2)) != 0; p++) {\n\t\tif (strncmp(p, s2, len) == 0) {\n\t\t\treturn (p);\n\t\t}\n\t}\n\treturn (0);\n}\n\n/* In order to allow a single demangler executable to demangle strings\n   using various common values of CPLUS_MARKER, as well as any specific\n   one set at compile time, we maintain a string containing all the\n   commonly used ones, and check to see if the marker we are looking for\n   is in that string.  CPLUS_MARKER is usually '$' on systems where the\n   assembler can deal with that.  Where the assembler can't, it's usually\n   '.' (but on many systems '.' is used for other things).  We put the\n   current defined CPLUS_MARKER first (which defaults to '$'), followed\n   by the next most common value, followed by an explicit '$' in case\n   the value of CPLUS_MARKER is not '$'.\n\n   We could avoid this if we could just get g++ to tell us what the actual\n   cplus marker character is as part of the debug information, perhaps by\n   ensuring that it is the character that terminates the gcc<n>_compiled\n   marker symbol (FIXME).  */\n\n#if !defined(CPLUS_MARKER)\n#define CPLUS_MARKER '$'\n#endif\n\nenum demangling_styles current_demangling_style = gnu_demangling;\n\nstatic char cplus_markers[] = { CPLUS_MARKER, '.', '$', '\\0' };\n\nstatic char char_str[2] = { '\\000', '\\000' };\n\ntypedef struct string /* Beware: these aren't required to be */\n{ /*  '\\0' terminated.  */\n\tchar *b; /* pointer to start of string */\n\tchar *p; /* pointer after last character */\n\tchar *e; /* pointer after end of allocated space */\n} string;\n\n/* Stuff that is shared between sub-routines.\n   Using a shared structure allows cplus_demangle_v2 to be reentrant.  */\n\nstruct work_stuff {\n\tint options;\n\tchar **typevec;\n\tchar **ktypevec;\n\tchar **btypevec;\n\tint numk;\n\tint numb;\n\tint ksize;\n\tint bsize;\n\tint ntypes;\n\tint typevec_size;\n\tint constructor;\n\tint destructor;\n\tint static_type; /* A static member function */\n\tint temp_start; /* index in demangled to start of template args */\n\tint type_quals; /* The type qualifiers.  */\n\tint dllimported; /* Symbol imported from a PE DLL */\n\tchar **tmpl_argvec; /* Template function arguments. */\n\tint ntmpl_args; /* The number of template function arguments. */\n\tint forgetting_types; /* Nonzero if we are not remembering the types\n\t\t\t\t we see.  */\n\tstring *previous_argument; /* The last function argument demangled.  */\n\tint nrepeats; /* The number of times to repeat the previous\n\t\t\t argument.  */\n};\n\n#define PRINT_ANSI_QUALIFIERS (work->options & DMGL_ANSI)\n#define PRINT_ARG_TYPES       (work->options & DMGL_PARAMS)\n\nstatic const struct optable {\n\tconst char *in;\n\tconst char *out;\n\tint flags;\n} optable[] = {\n\t{ \"nw\", \" new\", DMGL_ANSI }, /* new (1.92,\t ansi) */\n\t{ \"dl\", \" delete\", DMGL_ANSI }, /* new (1.92,\t ansi) */\n\t{ \"new\", \" new\", 0 }, /* old (1.91,\t and 1.x) */\n\t{ \"delete\", \" delete\", 0 }, /* old (1.91,\t and 1.x) */\n\t{ \"vn\", \" new []\", DMGL_ANSI }, /* GNU, pending ansi */\n\t{ \"vd\", \" delete []\", DMGL_ANSI }, /* GNU, pending ansi */\n\t{ \"as\", \"=\", DMGL_ANSI }, /* ansi */\n\t{ \"ne\", \"!=\", DMGL_ANSI }, /* old, ansi */\n\t{ \"eq\", \"==\", DMGL_ANSI }, /* old,\tansi */\n\t{ \"ge\", \">=\", DMGL_ANSI }, /* old,\tansi */\n\t{ \"gt\", \">\", DMGL_ANSI }, /* old,\tansi */\n\t{ \"le\", \"<=\", DMGL_ANSI }, /* old,\tansi */\n\t{ \"lt\", \"<\", DMGL_ANSI }, /* old,\tansi */\n\t{ \"plus\", \"+\", 0 }, /* old */\n\t{ \"pl\", \"+\", DMGL_ANSI }, /* ansi */\n\t{ \"apl\", \"+=\", DMGL_ANSI }, /* ansi */\n\t{ \"minus\", \"-\", 0 }, /* old */\n\t{ \"mi\", \"-\", DMGL_ANSI }, /* ansi */\n\t{ \"ami\", \"-=\", DMGL_ANSI }, /* ansi */\n\t{ \"mult\", \"*\", 0 }, /* old */\n\t{ \"ml\", \"*\", DMGL_ANSI }, /* ansi */\n\t{ \"amu\", \"*=\", DMGL_ANSI }, /* ansi (ARM/Lucid) */\n\t{ \"aml\", \"*=\", DMGL_ANSI }, /* ansi (GNU/g++) */\n\t{ \"convert\", \"+\", 0 }, /* old (unary +) */\n\t{ \"negate\", \"-\", 0 }, /* old (unary -) */\n\t{ \"trunc_mod\", \"%\", 0 }, /* old */\n\t{ \"md\", \"%\", DMGL_ANSI }, /* ansi */\n\t{ \"amd\", \"%=\", DMGL_ANSI }, /* ansi */\n\t{ \"trunc_div\", \"/\", 0 }, /* old */\n\t{ \"dv\", \"/\", DMGL_ANSI }, /* ansi */\n\t{ \"adv\", \"/=\", DMGL_ANSI }, /* ansi */\n\t{ \"truth_andif\", \"&&\", 0 }, /* old */\n\t{ \"aa\", \"&&\", DMGL_ANSI }, /* ansi */\n\t{ \"truth_orif\", \"||\", 0 }, /* old */\n\t{ \"oo\", \"||\", DMGL_ANSI }, /* ansi */\n\t{ \"truth_not\", \"!\", 0 }, /* old */\n\t{ \"nt\", \"!\", DMGL_ANSI }, /* ansi */\n\t{ \"postincrement\", \"++\", 0 }, /* old */\n\t{ \"pp\", \"++\", DMGL_ANSI }, /* ansi */\n\t{ \"postdecrement\", \"--\", 0 }, /* old */\n\t{ \"mm\", \"--\", DMGL_ANSI }, /* ansi */\n\t{ \"bit_ior\", \"|\", 0 }, /* old */\n\t{ \"or\", \"|\", DMGL_ANSI }, /* ansi */\n\t{ \"aor\", \"|=\", DMGL_ANSI }, /* ansi */\n\t{ \"bit_xor\", \"^\", 0 }, /* old */\n\t{ \"er\", \"^\", DMGL_ANSI }, /* ansi */\n\t{ \"aer\", \"^=\", DMGL_ANSI }, /* ansi */\n\t{ \"bit_and\", \"&\", 0 }, /* old */\n\t{ \"ad\", \"&\", DMGL_ANSI }, /* ansi */\n\t{ \"aad\", \"&=\", DMGL_ANSI }, /* ansi */\n\t{ \"bit_not\", \"~\", 0 }, /* old */\n\t{ \"co\", \"~\", DMGL_ANSI }, /* ansi */\n\t{ \"call\", \"()\", 0 }, /* old */\n\t{ \"cl\", \"()\", DMGL_ANSI }, /* ansi */\n\t{ \"alshift\", \"<<\", 0 }, /* old */\n\t{ \"ls\", \"<<\", DMGL_ANSI }, /* ansi */\n\t{ \"als\", \"<<=\", DMGL_ANSI }, /* ansi */\n\t{ \"arshift\", \">>\", 0 }, /* old */\n\t{ \"rs\", \">>\", DMGL_ANSI }, /* ansi */\n\t{ \"ars\", \">>=\", DMGL_ANSI }, /* ansi */\n\t{ \"component\", \"->\", 0 }, /* old */\n\t{ \"pt\", \"->\", DMGL_ANSI }, /* ansi; Lucid C++ form */\n\t{ \"rf\", \"->\", DMGL_ANSI }, /* ansi; ARM/GNU form */\n\t{ \"indirect\", \"*\", 0 }, /* old */\n\t{ \"method_call\", \"->()\", 0 }, /* old */\n\t{ \"addr\", \"&\", 0 }, /* old (unary &) */\n\t{ \"array\", \"[]\", 0 }, /* old */\n\t{ \"vc\", \"[]\", DMGL_ANSI }, /* ansi */\n\t{ \"compound\", \", \", 0 }, /* old */\n\t{ \"cm\", \", \", DMGL_ANSI }, /* ansi */\n\t{ \"cond\", \"?:\", 0 }, /* old */\n\t{ \"cn\", \"?:\", DMGL_ANSI }, /* pseudo-ansi */\n\t{ \"max\", \">?\", 0 }, /* old */\n\t{ \"mx\", \">?\", DMGL_ANSI }, /* pseudo-ansi */\n\t{ \"min\", \"<?\", 0 }, /* old */\n\t{ \"mn\", \"<?\", DMGL_ANSI }, /* pseudo-ansi */\n\t{ \"nop\", \"\", 0 }, /* old (for operator=) */\n\t{ \"rm\", \"->*\", DMGL_ANSI }, /* ansi */\n\t{ \"sz\", \"sizeof \", DMGL_ANSI } /* pseudo-ansi */\n};\n\n/* These values are used to indicate the various type varieties.\n   They are all non-zero so that they can be used as `success'\n   values.  */\ntypedef enum type_kind_t {\n\ttk_none,\n\ttk_pointer,\n\ttk_reference,\n\ttk_integral,\n\ttk_bool,\n\ttk_char,\n\ttk_real\n} type_kind_t;\n\n#define STRING_EMPTY(str) ((str)->b == (str)->p)\n#define PREPEND_BLANK(str) \\\n\t{ \\\n\t\tif (!STRING_EMPTY(str)) \\\n\t\t\tstring_prepend(str, \" \"); \\\n\t}\n#define APPEND_BLANK(str) \\\n\t{ \\\n\t\tif (!STRING_EMPTY(str)) \\\n\t\t\tstring_append(str, \" \"); \\\n\t}\n#define LEN_STRING(str) ((STRING_EMPTY(str)) ? 0 : ((str)->p - (str)->b))\n\n/* The scope separator appropriate for the language being demangled.  */\n\n#define SCOPE_STRING(work) ((work->options & DMGL_JAVA) ? \".\" : \"::\")\n\n#define ARM_VTABLE_STRING \"__vtbl__\" /* Lucid/ARM virtual table prefix */\n#define ARM_VTABLE_STRLEN 8 /* strlen (ARM_VTABLE_STRING) */\n\n/* Prototypes for local functions */\n\nstatic char *\n\tmop_up PARAMS((struct work_stuff *, string *, int));\n\nstatic void\n\tsquangle_mop_up PARAMS((struct work_stuff *));\n\n#if 0\nstatic int\ndemangle_method_args PARAMS ((struct work_stuff *, const char **, string *));\n#endif\n\nstatic char *\n\tinternal_cplus_demangle PARAMS((struct work_stuff *, const char *));\n\nstatic int\n\tdemangle_template_template_parm PARAMS((struct work_stuff * work,\n\t\tconst char **, string *));\n\nstatic int\n\tdemangle_template PARAMS((struct work_stuff * work, const char **, string *,\n\t\tstring *, int, int));\n\nstatic int\n\tarm_pt PARAMS((struct work_stuff *, const char *, int, const char **,\n\t\tconst char **));\n\nstatic int\n\tdemangle_class_name PARAMS((struct work_stuff *, const char **, string *));\n\nstatic int\n\tdemangle_qualified PARAMS((struct work_stuff *, const char **, string *,\n\t\tint, int));\n\nstatic int\n\tdemangle_class PARAMS((struct work_stuff *, const char **, string *));\n\nstatic int\n\tdemangle_fund_type PARAMS((struct work_stuff *, const char **, string *));\n\nstatic int\n\tdemangle_signature PARAMS((struct work_stuff *, const char **, string *));\n\nstatic int\n\tdemangle_prefix PARAMS((struct work_stuff *, const char **, string *));\n\nstatic int\n\tgnu_special PARAMS((struct work_stuff *, const char **, string *));\n\nstatic int\n\tarm_special PARAMS((const char **, string *));\n\nstatic void\n\tstring_need PARAMS((string *, int));\n\nstatic void\n\tstring_delete PARAMS((string *));\n\nstatic void\n\tstring_init PARAMS((string *));\n\nstatic void\n\tstring_clear PARAMS((string *));\n\n#if 0\nstatic int\nstring_empty PARAMS ((string *));\n#endif\n\nstatic void\n\tstring_append PARAMS((string *, const char *));\n\nstatic void\n\tstring_appends PARAMS((string *, string *));\n\nstatic void\n\tstring_appendn PARAMS((string *, const char *, int));\n\nstatic void\n\tstring_prepend PARAMS((string *, const char *));\n\nstatic void\n\tstring_prependn PARAMS((string *, const char *, int));\n\nstatic int\n\tget_count PARAMS((const char **, int *));\n\nstatic int\n\tconsume_count PARAMS((const char **));\n\nstatic int\n\tconsume_count_with_underscores PARAMS((const char **));\n\nstatic int\n\tdemangle_args PARAMS((struct work_stuff *, const char **, string *));\n\nstatic int\n\tdemangle_nested_args PARAMS((struct work_stuff *, const char **, string *));\n\nstatic int\n\tdo_type PARAMS((struct work_stuff *, const char **, string *));\n\nstatic int\n\tdo_arg PARAMS((struct work_stuff *, const char **, string *));\n\nstatic void\n\tdemangle_function_name PARAMS((struct work_stuff *, const char **, string *,\n\t\tconst char *));\n\nstatic void\n\tremember_type PARAMS((struct work_stuff *, const char *, int));\n\nstatic void\n\tremember_Btype PARAMS((struct work_stuff *, const char *, int, int));\n\nstatic int\n\tregister_Btype PARAMS((struct work_stuff *));\n\nstatic void\n\tremember_Ktype PARAMS((struct work_stuff *, const char *, int));\n\nstatic void\n\tforget_types PARAMS((struct work_stuff *));\n\nstatic void\n\tforget_B_and_K_types PARAMS((struct work_stuff *));\n\nstatic void\n\tstring_prepends PARAMS((string *, string *));\n\nstatic int\n\tdemangle_template_value_parm PARAMS((struct work_stuff *, const char **,\n\t\tstring *, type_kind_t));\n\nstatic int\n\tdo_hpacc_template_const_value PARAMS((struct work_stuff *, const char **, string *));\n\nstatic int\n\tdo_hpacc_template_literal PARAMS((struct work_stuff *, const char **, string *));\n\nstatic int\n\tsnarf_numeric_literal PARAMS((const char **, string *));\n\n/* There is a TYPE_QUAL value for each type qualifier.  They can be\n   combined by bitwise-or to form the complete set of qualifiers for a\n   type.  */\n\n#define TYPE_UNQUALIFIED   0x0\n#define TYPE_QUAL_CONST    0x1\n#define TYPE_QUAL_VOLATILE 0x2\n#define TYPE_QUAL_RESTRICT 0x4\n\nstatic int\n\tcode_for_qualifier PARAMS((int));\n\nstatic const char *\n\tqualifier_string PARAMS((int));\n\nstatic const char *\n\tdemangle_qualifier PARAMS((int));\n\n/* Translate count to integer, consuming tokens in the process.\n   Conversion terminates on the first non-digit character.\n\n   Trying to consume something that isn't a count results in no\n   consumption of input and a return of -1.\n\n   Overflow consumes the rest of the digits, and returns -1.  */\n\nstatic int\n\tconsume_count(type)\n\t\tconst char **type;\n{\n\t// Note by RizinOrg:\n\t// to prevent the overflow check to be optimized out\n\t// by the compiler, this variable needs to be volatile.\n\tvolatile int count = 0;\n\n\tif (!isdigit((unsigned char)**type))\n\t\treturn -1;\n\n\twhile (isdigit((unsigned char)**type)) {\n\t\tcount *= 10;\n\n\t\t/* Check for overflow.\n\t\t   We assume that count is represented using two's-complement;\n\t\t   no power of two is divisible by ten, so if an overflow occurs\n\t\t   when multiplying by ten, the result will not be a multiple of\n\t\t   ten.  */\n\t\tif ((count % 10) != 0) {\n\t\t\twhile (isdigit((unsigned char)**type))\n\t\t\t\t(*type)++;\n\t\t\treturn -1;\n\t\t}\n\n\t\tcount += **type - '0';\n\t\t(*type)++;\n\t}\n\n\treturn (count);\n}\n\n/* Like consume_count, but for counts that are preceded and followed\n   by '_' if they are greater than 10.  Also, -1 is returned for\n   failure, since 0 can be a valid value.  */\n\nstatic int\n\tconsume_count_with_underscores(mangled)\n\t\tconst char **mangled;\n{\n\tint idx;\n\n\tif (**mangled == '_') {\n\t\t(*mangled)++;\n\t\tif (!isdigit((unsigned char)**mangled))\n\t\t\treturn -1;\n\n\t\tidx = consume_count(mangled);\n\t\tif (**mangled != '_')\n\t\t\t/* The trailing underscore was missing. */\n\t\t\treturn -1;\n\n\t\t(*mangled)++;\n\t} else {\n\t\tif (**mangled < '0' || **mangled > '9')\n\t\t\treturn -1;\n\n\t\tidx = **mangled - '0';\n\t\t(*mangled)++;\n\t}\n\n\treturn idx;\n}\n\n/* C is the code for a type-qualifier.  Return the TYPE_QUAL\n   corresponding to this qualifier.  */\n\nstatic int\ncode_for_qualifier(c)\nint c;\n{\n\tswitch (c) {\n\tcase 'C':\n\t\treturn TYPE_QUAL_CONST;\n\n\tcase 'V':\n\t\treturn TYPE_QUAL_VOLATILE;\n\n\tcase 'u':\n\t\treturn TYPE_QUAL_RESTRICT;\n\n\tdefault:\n\t\treturn TYPE_UNQUALIFIED;\n\t}\n}\n\n/* Return the string corresponding to the qualifiers given by\n   TYPE_QUALS.  */\n\nstatic const char *\nqualifier_string(type_quals)\nint type_quals;\n{\n\tswitch (type_quals) {\n\tcase TYPE_UNQUALIFIED:\n\t\treturn \"\";\n\n\tcase TYPE_QUAL_CONST:\n\t\treturn \"const\";\n\n\tcase TYPE_QUAL_VOLATILE:\n\t\treturn \"volatile\";\n\n\tcase TYPE_QUAL_RESTRICT:\n\t\treturn \"__restrict\";\n\n\tcase TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE:\n\t\treturn \"const volatile\";\n\n\tcase TYPE_QUAL_CONST | TYPE_QUAL_RESTRICT:\n\t\treturn \"const __restrict\";\n\n\tcase TYPE_QUAL_VOLATILE | TYPE_QUAL_RESTRICT:\n\t\treturn \"volatile __restrict\";\n\n\tcase TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE | TYPE_QUAL_RESTRICT:\n\t\treturn \"const volatile __restrict\";\n\n\tdefault:\n\t\treturn \"\";\n\t}\n}\n\n/* C is the code for a type-qualifier.  Return the string\n   corresponding to this qualifier.  This function should only be\n   called with a valid qualifier code.  */\n\nstatic const char *\ndemangle_qualifier(c)\nint c;\n{\n\treturn qualifier_string(code_for_qualifier(c));\n}\n\n/* char *cplus_demangle_v2 (const char *mangled, int options)\n\n   If MANGLED is a mangled function name produced by GNU C++, then\n   a pointer to a malloced string giving a C++ representation\n   of the name will be returned; otherwise NULL will be returned.\n   It is the caller's responsibility to free the string which\n   is returned.\n\n   The OPTIONS arg may contain one or more of the following bits:\n\n\tDMGL_ANSI\tANSI qualifiers such as `const' and `void' are\n\t\t\tincluded.\n\tDMGL_PARAMS\tFunction parameters are included.\n\n   For example,\n\n   cplus_demangle_v2 (\"foo__1Ai\", DMGL_PARAMS)\t\t=> \"A::foo(int)\"\n   cplus_demangle_v2 (\"foo__1Ai\", DMGL_PARAMS | DMGL_ANSI)\t=> \"A::foo(int)\"\n   cplus_demangle_v2 (\"foo__1Ai\", 0)\t\t\t=> \"A::foo\"\n\n   cplus_demangle_v2 (\"foo__1Afe\", DMGL_PARAMS)\t\t=> \"A::foo(float,...)\"\n   cplus_demangle_v2 (\"foo__1Afe\", DMGL_PARAMS | DMGL_ANSI)=> \"A::foo(float,...)\"\n   cplus_demangle_v2 (\"foo__1Afe\", 0)\t\t\t=> \"A::foo\"\n\n   Note that any leading underscores, or other such characters prepended by\n   the compilation system, are presumed to have already been stripped from\n   MANGLED.  */\n\nchar *\n\tcplus_demangle_v2(mangled, options)\n\t\tconst char *mangled;\nint options;\n{\n\tchar *ret;\n\tstruct work_stuff work[1];\n\tmemset((char *)work, 0, sizeof(work));\n\twork->options = options;\n\tif ((work->options & DMGL_STYLE_MASK) == 0)\n\t\twork->options |= (int)current_demangling_style & DMGL_STYLE_MASK;\n\n\tret = internal_cplus_demangle(work, mangled);\n\tsquangle_mop_up(work);\n\treturn (ret);\n}\n\n/* This function performs most of what cplus_demangle_v2 use to do, but\n   to be able to demangle a name with a B, K or n code, we need to\n   have a longer term memory of what types have been seen. The original\n   now intializes and cleans up the squangle code info, while internal\n   calls go directly to this routine to avoid resetting that info. */\n\nstatic char *\ninternal_cplus_demangle(work, mangled)\nstruct work_stuff *work;\nconst char *mangled;\n{\n\n\tstring decl;\n\tint success = 0;\n\tchar *demangled = NULL;\n\tint s1, s2, s3, s4;\n\ts1 = work->constructor;\n\ts2 = work->destructor;\n\ts3 = work->static_type;\n\ts4 = work->type_quals;\n\twork->constructor = work->destructor = 0;\n\twork->type_quals = TYPE_UNQUALIFIED;\n\twork->dllimported = 0;\n\n\tif ((mangled != NULL) && (*mangled != '\\0')) {\n\t\tstring_init(&decl);\n\n\t\t/* First check to see if gnu style demangling is active and if the\n\t\t   string to be demangled contains a CPLUS_MARKER.  If so, attempt to\n\t\t   recognize one of the gnu special forms rather than looking for a\n\t\t   standard prefix.  In particular, don't worry about whether there\n\t\t   is a \"__\" string in the mangled string.  Consider \"_$_5__foo\" for\n\t\t   example.  */\n\n\t\tif ((AUTO_DEMANGLING || GNU_DEMANGLING)) {\n\t\t\tsuccess = gnu_special(work, &mangled, &decl);\n\t\t}\n\t\tif (!success) {\n\t\t\tsuccess = demangle_prefix(work, &mangled, &decl);\n\t\t}\n\t\tif (success && (*mangled != '\\0')) {\n\t\t\tsuccess = demangle_signature(work, &mangled, &decl);\n\t\t}\n\t\tif (work->constructor == 2) {\n\t\t\tstring_prepend(&decl, \"global constructors keyed to \");\n\t\t\twork->constructor = 0;\n\t\t} else if (work->destructor == 2) {\n\t\t\tstring_prepend(&decl, \"global destructors keyed to \");\n\t\t\twork->destructor = 0;\n\t\t} else if (work->dllimported == 1) {\n\t\t\tstring_prepend(&decl, \"import stub for \");\n\t\t\twork->dllimported = 0;\n\t\t}\n\t\tdemangled = mop_up(work, &decl, success);\n\t}\n\twork->constructor = s1;\n\twork->destructor = s2;\n\twork->static_type = s3;\n\twork->type_quals = s4;\n\treturn (demangled);\n}\n\n/* Clear out and squangling related storage */\nstatic void\n\tsquangle_mop_up(work) struct work_stuff *work;\n{\n\t/* clean up the B and K type mangling types. */\n\tforget_B_and_K_types(work);\n\tif (work->btypevec != NULL) {\n\t\tfree((char *)work->btypevec);\n\t}\n\tif (work->ktypevec != NULL) {\n\t\tfree((char *)work->ktypevec);\n\t}\n}\n\n/* Clear out any mangled storage */\n\nstatic char *\nmop_up(work, declp, success)\nstruct work_stuff *work;\nstring *declp;\nint success;\n{\n\tchar *demangled = NULL;\n\n\t/* Discard the remembered types, if any.  */\n\n\tforget_types(work);\n\tif (work->typevec != NULL) {\n\t\tfree((char *)work->typevec);\n\t\twork->typevec = NULL;\n\t\twork->typevec_size = 0;\n\t}\n\tif (work->tmpl_argvec) {\n\t\tint i;\n\n\t\tfor (i = 0; i < work->ntmpl_args; i++)\n\t\t\tif (work->tmpl_argvec[i])\n\t\t\t\tfree((char *)work->tmpl_argvec[i]);\n\n\t\tfree((char *)work->tmpl_argvec);\n\t\twork->tmpl_argvec = NULL;\n\t}\n\tif (work->previous_argument) {\n\t\tstring_delete(work->previous_argument);\n\t\tfree((char *)work->previous_argument);\n\t\twork->previous_argument = NULL;\n\t}\n\n\t/* If demangling was successful, ensure that the demangled string is null\n\t   terminated and return it.  Otherwise, free the demangling decl.  */\n\n\tif (!success) {\n\t\tstring_delete(declp);\n\t} else {\n\t\tstring_appendn(declp, \"\", 1);\n\t\tdemangled = declp->b;\n\t}\n\treturn (demangled);\n}\n\n/*\n\nLOCAL FUNCTION\n\n\tdemangle_signature -- demangle the signature part of a mangled name\n\nSYNOPSIS\n\n\tstatic int\n\tdemangle_signature (struct work_stuff *work, const char **mangled,\n\t\t\t    string *declp);\n\nDESCRIPTION\n\n\tConsume and demangle the signature portion of the mangled name.\n\n\tDECLP is the string where demangled output is being built.  At\n\tentry it contains the demangled root name from the mangled name\n\tprefix.  I.E. either a demangled operator name or the root function\n\tname.  In some special cases, it may contain nothing.\n\n\t*MANGLED points to the current unconsumed location in the mangled\n\tname.  As tokens are consumed and demangling is performed, the\n\tpointer is updated to continuously point at the next token to\n\tbe consumed.\n\n\tDemangling GNU style mangled names is nasty because there is no\n\texplicit token that marks the start of the outermost function\n\targument list.  */\n\nstatic int\ndemangle_signature(work, mangled, declp)\nstruct work_stuff *work;\nconst char **mangled;\nstring *declp;\n{\n\tint success = 1;\n\tint func_done = 0;\n\tint expect_func = 0;\n\tint expect_return_type = 0;\n\tconst char *oldmangled = NULL;\n\tstring trawname;\n\tstring tname;\n\n\twhile (success && (**mangled != '\\0')) {\n\t\tswitch (**mangled) {\n\t\tcase 'Q':\n\t\t\toldmangled = *mangled;\n\t\t\tsuccess = demangle_qualified(work, mangled, declp, 1, 0);\n\t\t\tif (success)\n\t\t\t\tremember_type(work, oldmangled, *mangled - oldmangled);\n\t\t\tif (AUTO_DEMANGLING || GNU_DEMANGLING)\n\t\t\t\texpect_func = 1;\n\t\t\toldmangled = NULL;\n\t\t\tbreak;\n\n\t\tcase 'K':\n\t\t\toldmangled = *mangled;\n\t\t\tsuccess = demangle_qualified(work, mangled, declp, 1, 0);\n\t\t\tif (AUTO_DEMANGLING || GNU_DEMANGLING) {\n\t\t\t\texpect_func = 1;\n\t\t\t}\n\t\t\toldmangled = NULL;\n\t\t\tbreak;\n\n\t\tcase 'S':\n\t\t\t/* Static member function */\n\t\t\tif (oldmangled == NULL) {\n\t\t\t\toldmangled = *mangled;\n\t\t\t}\n\t\t\t(*mangled)++;\n\t\t\twork->static_type = 1;\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\tcase 'V':\n\t\tcase 'u':\n\t\t\twork->type_quals |= code_for_qualifier(**mangled);\n\n\t\t\t/* a qualified member function */\n\t\t\tif (oldmangled == NULL)\n\t\t\t\toldmangled = *mangled;\n\t\t\t(*mangled)++;\n\t\t\tbreak;\n\n\t\tcase 'L':\n\t\t\t/* Local class name follows after \"Lnnn_\" */\n\t\t\tif (HP_DEMANGLING) {\n\t\t\t\twhile (**mangled && (**mangled != '_'))\n\t\t\t\t\t(*mangled)++;\n\t\t\t\tif (!**mangled)\n\t\t\t\t\tsuccess = 0;\n\t\t\t\telse\n\t\t\t\t\t(*mangled)++;\n\t\t\t} else\n\t\t\t\tsuccess = 0;\n\t\t\tbreak;\n\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\t\tif (oldmangled == NULL) {\n\t\t\t\toldmangled = *mangled;\n\t\t\t}\n\t\t\twork->temp_start = -1; /* uppermost call to demangle_class */\n\t\t\tsuccess = demangle_class(work, mangled, declp);\n\t\t\tif (success) {\n\t\t\t\tremember_type(work, oldmangled, *mangled - oldmangled);\n\t\t\t}\n\t\t\tif (AUTO_DEMANGLING || GNU_DEMANGLING || EDG_DEMANGLING) {\n\t\t\t\t/* EDG and others will have the \"F\", so we let the loop cycle\n\t\t\t\t   if we are looking at one. */\n\t\t\t\tif (**mangled != 'F')\n\t\t\t\t\texpect_func = 1;\n\t\t\t}\n\t\t\toldmangled = NULL;\n\t\t\tbreak;\n\n\t\tcase 'B': {\n\t\t\tstring s;\n\t\t\tsuccess = do_type(work, mangled, &s);\n\t\t\tif (success) {\n\t\t\t\tstring_append(&s, SCOPE_STRING(work));\n\t\t\t\tstring_prepends(declp, &s);\n\t\t\t}\n\t\t\toldmangled = NULL;\n\t\t\texpect_func = 1;\n\t\t} break;\n\n\t\tcase 'F':\n\t\t\t/* Function */\n\t\t\t/* ARM/HP style demangling includes a specific 'F' character after\n\t\t\t   the class name.  For GNU style, it is just implied.  So we can\n\t\t\t   safely just consume any 'F' at this point and be compatible\n\t\t\t   with either style.  */\n\n\t\t\toldmangled = NULL;\n\t\t\tfunc_done = 1;\n\t\t\t(*mangled)++;\n\n\t\t\t/* For lucid/ARM/HP style we have to forget any types we might\n\t\t\t   have remembered up to this point, since they were not argument\n\t\t\t   types.  GNU style considers all types seen as available for\n\t\t\t   back references.  See comment in demangle_args() */\n\n\t\t\tif (LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING) {\n\t\t\t\tforget_types(work);\n\t\t\t}\n\t\t\tsuccess = demangle_args(work, mangled, declp);\n\t\t\t/* After picking off the function args, we expect to either\n\t\t\t   find the function return type (preceded by an '_') or the\n\t\t\t   end of the string. */\n\t\t\tif (success && (AUTO_DEMANGLING || EDG_DEMANGLING) && **mangled == '_') {\n\t\t\t\t++(*mangled);\n\t\t\t\t/* At this level, we do not care about the return type. */\n\t\t\t\tsuccess = do_type(work, mangled, &tname);\n\t\t\t\tstring_delete(&tname);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t\t/* G++ Template */\n\t\t\tstring_init(&trawname);\n\t\t\tstring_init(&tname);\n\t\t\tif (oldmangled == NULL) {\n\t\t\t\toldmangled = *mangled;\n\t\t\t}\n\t\t\tsuccess = demangle_template(work, mangled, &tname,\n\t\t\t\t&trawname, 1, 1);\n\t\t\tif (success) {\n\t\t\t\tremember_type(work, oldmangled, *mangled - oldmangled);\n\t\t\t}\n\t\t\tstring_append(&tname, SCOPE_STRING(work));\n\n\t\t\tstring_prepends(declp, &tname);\n\t\t\tif (work->destructor & 1) {\n\t\t\t\tstring_prepend(&trawname, \"~\");\n\t\t\t\tstring_appends(declp, &trawname);\n\t\t\t\twork->destructor -= 1;\n\t\t\t}\n\t\t\tif ((work->constructor & 1) || (work->destructor & 1)) {\n\t\t\t\tstring_appends(declp, &trawname);\n\t\t\t\twork->constructor -= 1;\n\t\t\t}\n\t\t\tstring_delete(&trawname);\n\t\t\tstring_delete(&tname);\n\t\t\toldmangled = NULL;\n\t\t\texpect_func = 1;\n\t\t\tbreak;\n\n\t\tcase '_':\n\t\t\tif (GNU_DEMANGLING && expect_return_type) {\n\t\t\t\t/* Read the return type. */\n\t\t\t\tstring return_type;\n\t\t\t\tstring_init(&return_type);\n\n\t\t\t\t(*mangled)++;\n\t\t\t\tsuccess = do_type(work, mangled, &return_type);\n\t\t\t\tAPPEND_BLANK(&return_type);\n\n\t\t\t\tstring_prepends(declp, &return_type);\n\t\t\t\tstring_delete(&return_type);\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\t/* At the outermost level, we cannot have a return type specified,\n\t\t\t\t   so if we run into another '_' at this point we are dealing with\n\t\t\t\t   a mangled name that is either bogus, or has been mangled by\n\t\t\t\t   some algorithm we don't know how to deal with.  So just\n\t\t\t\t   reject the entire demangling.  */\n\t\t\t\t/* However, \"_nnn\" is an expected suffix for alternate entry point\n\t\t\t\t   numbered nnn for a function, with HP aCC, so skip over that\n\t\t\t\t   without reporting failure. pai/1997-09-04 */\n\t\t\t\tif (HP_DEMANGLING) {\n\t\t\t\t\t(*mangled)++;\n\t\t\t\t\twhile (**mangled && isdigit((unsigned char)**mangled))\n\t\t\t\t\t\t(*mangled)++;\n\t\t\t\t} else\n\t\t\t\t\tsuccess = 0;\n\t\t\tbreak;\n\n\t\tcase 'H':\n\t\t\tif (GNU_DEMANGLING) {\n\t\t\t\t/* A G++ template function.  Read the template arguments. */\n\t\t\t\tsuccess = demangle_template(work, mangled, declp, 0, 0,\n\t\t\t\t\t0);\n\t\t\t\tif (!(work->constructor & 1))\n\t\t\t\t\texpect_return_type = 1;\n\t\t\t\t(*mangled)++;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t/* fall through */\n\t\t\t{\n\t\t\t\t;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tif (AUTO_DEMANGLING || GNU_DEMANGLING) {\n\t\t\t\t/* Assume we have stumbled onto the first outermost function\n\t\t\t\t   argument token, and start processing args.  */\n\t\t\t\tfunc_done = 1;\n\t\t\t\tsuccess = demangle_args(work, mangled, declp);\n\t\t\t} else {\n\t\t\t\t/* Non-GNU demanglers use a specific token to mark the start\n\t\t\t\t   of the outermost function argument tokens.  Typically 'F',\n\t\t\t\t   for ARM/HP-demangling, for example.  So if we find something\n\t\t\t\t   we are not prepared for, it must be an error.  */\n\t\t\t\tsuccess = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t  if (AUTO_DEMANGLING || GNU_DEMANGLING)\n\t\t  */\n\t\t{\n\t\t\tif (success && expect_func) {\n\t\t\t\tfunc_done = 1;\n\t\t\t\tif (LUCID_DEMANGLING || ARM_DEMANGLING || EDG_DEMANGLING) {\n\t\t\t\t\tforget_types(work);\n\t\t\t\t}\n\t\t\t\tsuccess = demangle_args(work, mangled, declp);\n\t\t\t\t/* Since template include the mangling of their return types,\n\t\t\t\t   we must set expect_func to 0 so that we don't try do\n\t\t\t\t   demangle more arguments the next time we get here.  */\n\t\t\t\texpect_func = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (success && !func_done) {\n\t\tif (AUTO_DEMANGLING || GNU_DEMANGLING) {\n\t\t\t/* With GNU style demangling, bar__3foo is 'foo::bar(void)', and\n\t\t\t   bar__3fooi is 'foo::bar(int)'.  We get here when we find the\n\t\t\t   first case, and need to ensure that the '(void)' gets added to\n\t\t\t   the current declp.  Note that with ARM/HP, the first case\n\t\t\t   represents the name of a static data member 'foo::bar',\n\t\t\t   which is in the current declp, so we leave it alone.  */\n\t\t\tsuccess = demangle_args(work, mangled, declp);\n\t\t}\n\t}\n\tif (success && PRINT_ARG_TYPES) {\n\t\tif (work->static_type)\n\t\t\tstring_append(declp, \" static\");\n\t\tif (work->type_quals != TYPE_UNQUALIFIED) {\n\t\t\tAPPEND_BLANK(declp);\n\t\t\tstring_append(declp, qualifier_string(work->type_quals));\n\t\t}\n\t}\n\n\treturn (success);\n}\n\n#if 0\n\nstatic int\ndemangle_method_args (work, mangled, declp)\n     struct work_stuff *work;\n     const char **mangled;\n     string *declp;\n{\n  int success = 0;\n\n  if (work -> static_type)\n    {\n      string_append (declp, *mangled + 1);\n      *mangled += strlen (*mangled);\n      success = 1;\n    }\n  else\n    {\n      success = demangle_args (work, mangled, declp);\n    }\n  return (success);\n}\n\n#endif\n\nstatic int\ndemangle_template_template_parm(work, mangled, tname)\nstruct work_stuff *work;\nconst char **mangled;\nstring *tname;\n{\n\tint i;\n\tint r;\n\tint need_comma = 0;\n\tint success = 1;\n\tstring temp;\n\n\tstring_append(tname, \"template <\");\n\t/* get size of template parameter list */\n\tif (get_count(mangled, &r)) {\n\t\tfor (i = 0; i < r; i++) {\n\t\t\tif (need_comma) {\n\t\t\t\tstring_append(tname, \", \");\n\t\t\t}\n\n\t\t\t/* Z for type parameters */\n\t\t\tif (**mangled == 'Z') {\n\t\t\t\t(*mangled)++;\n\t\t\t\tstring_append(tname, \"class\");\n\t\t\t}\n\t\t\t/* z for template parameters */\n\t\t\telse if (**mangled == 'z') {\n\t\t\t\t(*mangled)++;\n\t\t\t\tsuccess =\n\t\t\t\t\tdemangle_template_template_parm(work, mangled, tname);\n\t\t\t\tif (!success) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* temp is initialized in do_type */\n\t\t\t\tsuccess = do_type(work, mangled, &temp);\n\t\t\t\tif (success) {\n\t\t\t\t\tstring_appends(tname, &temp);\n\t\t\t\t}\n\t\t\t\tstring_delete(&temp);\n\t\t\t\tif (!success) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tneed_comma = 1;\n\t\t}\n\t}\n\tif (tname->p[-1] == '>')\n\t\tstring_append(tname, \" \");\n\tstring_append(tname, \"> class\");\n\treturn (success);\n}\n\nstatic int\ndemangle_integral_value(work, mangled, s)\nstruct work_stuff *work;\nconst char **mangled;\nstring *s;\n{\n\tint success;\n\n\tif (**mangled == 'E') {\n\t\tint need_operator = 0;\n\n\t\tsuccess = 1;\n\t\tstring_appendn(s, \"(\", 1);\n\t\t(*mangled)++;\n\t\twhile (success && **mangled != 'W' && **mangled != '\\0') {\n\t\t\tif (need_operator) {\n\t\t\t\tsize_t i;\n\t\t\t\tsize_t len;\n\n\t\t\t\tsuccess = 0;\n\n\t\t\t\tlen = strlen(*mangled);\n\n\t\t\t\tfor (i = 0;\n\t\t\t\t\ti < sizeof(optable) / sizeof(optable[0]);\n\t\t\t\t\t++i) {\n\t\t\t\t\tsize_t l = strlen(optable[i].in);\n\n\t\t\t\t\tif (l <= len && memcmp(optable[i].in, *mangled, l) == 0) {\n\t\t\t\t\t\tstring_appendn(s, \" \", 1);\n\t\t\t\t\t\tstring_append(s, optable[i].out);\n\t\t\t\t\t\tstring_appendn(s, \" \", 1);\n\t\t\t\t\t\tsuccess = 1;\n\t\t\t\t\t\t(*mangled) += l;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!success)\n\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tneed_operator = 1;\n\n\t\t\tsuccess = demangle_template_value_parm(work, mangled, s,\n\t\t\t\ttk_integral);\n\t\t}\n\n\t\tif (**mangled != 'W')\n\t\t\tsuccess = 0;\n\t\telse {\n\t\t\tstring_appendn(s, \")\", 1);\n\t\t\t(*mangled)++;\n\t\t}\n\t} else if (**mangled == 'Q' || **mangled == 'K')\n\t\tsuccess = demangle_qualified(work, mangled, s, 0, 1);\n\telse {\n\t\tsuccess = 0;\n\n\t\tif (**mangled == 'm') {\n\t\t\tstring_appendn(s, \"-\", 1);\n\t\t\t(*mangled)++;\n\t\t}\n\t\twhile (isdigit((unsigned char)**mangled)) {\n\t\t\tstring_appendn(s, *mangled, 1);\n\t\t\t(*mangled)++;\n\t\t\tsuccess = 1;\n\t\t}\n\t}\n\n\treturn success;\n}\n\nstatic int\ndemangle_template_value_parm(work, mangled, s, tk)\nstruct work_stuff *work;\nconst char **mangled;\nstring *s;\ntype_kind_t tk;\n{\n\tint success = 1;\n\n\tif (**mangled == 'Y') {\n\t\t/* The next argument is a template parameter. */\n\t\tint idx;\n\n\t\t(*mangled)++;\n\t\tidx = consume_count_with_underscores(mangled);\n\t\tif (idx == -1 || (work->tmpl_argvec && idx >= work->ntmpl_args) || consume_count_with_underscores(mangled) == -1)\n\t\t\treturn -1;\n\t\tif (work->tmpl_argvec)\n\t\t\tstring_append(s, work->tmpl_argvec[idx]);\n\t\telse {\n\t\t\tchar buf[10];\n\t\t\tsprintf(buf, \"T%d\", idx);\n\t\t\tstring_append(s, buf);\n\t\t}\n\t} else if (tk == tk_integral)\n\t\tsuccess = demangle_integral_value(work, mangled, s);\n\telse if (tk == tk_char) {\n\t\tchar tmp[2];\n\t\tint val;\n\t\tif (**mangled == 'm') {\n\t\t\tstring_appendn(s, \"-\", 1);\n\t\t\t(*mangled)++;\n\t\t}\n\t\tstring_appendn(s, \"'\", 1);\n\t\tval = consume_count(mangled);\n\t\tif (val <= 0)\n\t\t\tsuccess = 0;\n\t\telse {\n\t\t\ttmp[0] = (char)val;\n\t\t\ttmp[1] = '\\0';\n\t\t\tstring_appendn(s, &tmp[0], 1);\n\t\t\tstring_appendn(s, \"'\", 1);\n\t\t}\n\t} else if (tk == tk_bool) {\n\t\tint val = consume_count(mangled);\n\t\tif (val == 0)\n\t\t\tstring_appendn(s, \"false\", 5);\n\t\telse if (val == 1)\n\t\t\tstring_appendn(s, \"true\", 4);\n\t\telse\n\t\t\tsuccess = 0;\n\t} else if (tk == tk_real) {\n\t\tif (**mangled == 'm') {\n\t\t\tstring_appendn(s, \"-\", 1);\n\t\t\t(*mangled)++;\n\t\t}\n\t\twhile (isdigit((unsigned char)**mangled)) {\n\t\t\tstring_appendn(s, *mangled, 1);\n\t\t\t(*mangled)++;\n\t\t}\n\t\tif (**mangled == '.') /* fraction */\n\t\t{\n\t\t\tstring_appendn(s, \".\", 1);\n\t\t\t(*mangled)++;\n\t\t\twhile (isdigit((unsigned char)**mangled)) {\n\t\t\t\tstring_appendn(s, *mangled, 1);\n\t\t\t\t(*mangled)++;\n\t\t\t}\n\t\t}\n\t\tif (**mangled == 'e') /* exponent */\n\t\t{\n\t\t\tstring_appendn(s, \"e\", 1);\n\t\t\t(*mangled)++;\n\t\t\twhile (isdigit((unsigned char)**mangled)) {\n\t\t\t\tstring_appendn(s, *mangled, 1);\n\t\t\t\t(*mangled)++;\n\t\t\t}\n\t\t}\n\t} else if (tk == tk_pointer || tk == tk_reference) {\n\t\tif (**mangled == 'Q')\n\t\t\tsuccess = demangle_qualified(work, mangled, s,\n\t\t\t\t/*isfuncname=*/0,\n\t\t\t\t/*append=*/1);\n\t\telse {\n\t\t\tint symbol_len = consume_count(mangled);\n\t\t\tif (symbol_len == -1)\n\t\t\t\treturn -1;\n\t\t\tif (symbol_len == 0)\n\t\t\t\tstring_appendn(s, \"0\", 1);\n\t\t\telse {\n\t\t\t\tchar *p = malloc(symbol_len + 1), *q;\n\t\t\t\tstrncpy(p, *mangled, symbol_len);\n\t\t\t\tp[symbol_len] = '\\0';\n\t\t\t\t/* We use cplus_demangle_v2 here, rather than\n\t\t\t\t   internal_cplus_demangle, because the name of the entity\n\t\t\t\t   mangled here does not make use of any of the squangling\n\t\t\t\t   or type-code information we have built up thus far; it is\n\t\t\t\t   mangled independently.  */\n\t\t\t\tq = cplus_demangle_v2(p, work->options);\n\t\t\t\tif (tk == tk_pointer)\n\t\t\t\t\tstring_appendn(s, \"&\", 1);\n\t\t\t\t/* FIXME: Pointer-to-member constants should get a\n\t\t\t\t   qualifying class name here.  */\n\t\t\t\tif (q) {\n\t\t\t\t\tstring_append(s, q);\n\t\t\t\t\tfree(q);\n\t\t\t\t} else\n\t\t\t\t\tstring_append(s, p);\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\t*mangled += symbol_len;\n\t\t}\n\t}\n\n\treturn success;\n}\n\n/* Demangle the template name in MANGLED.  The full name of the\n   template (e.g., S<int>) is placed in TNAME.  The name without the\n   template parameters (e.g. S) is placed in TRAWNAME if TRAWNAME is\n   non-NULL.  If IS_TYPE is nonzero, this template is a type template,\n   not a function template.  If both IS_TYPE and REMEMBER are nonzero,\n   the tmeplate is remembered in the list of back-referenceable\n   types.  */\n\nstatic int\ndemangle_template(work, mangled, tname, trawname, is_type, remember)\nstruct work_stuff *work;\nconst char **mangled;\nstring *tname;\nstring *trawname;\nint is_type;\nint remember;\n{\n\tint i = 0;\n\tint r = 0;\n\tint need_comma = 0;\n\tint success = 0;\n\tint is_java_array = 0;\n\tstring temp = { 0 };\n\tint bindex = 0;\n\n\t(*mangled)++;\n\tif (is_type) {\n\t\tif (remember)\n\t\t\tbindex = register_Btype(work);\n\t\t/* get template name */\n\t\tif (**mangled == 'z') {\n\t\t\tint idx;\n\t\t\t(*mangled)++;\n\t\t\t(*mangled)++;\n\n\t\t\tidx = consume_count_with_underscores(mangled);\n\t\t\tif (idx == -1 || (work->tmpl_argvec && idx >= work->ntmpl_args) || consume_count_with_underscores(mangled) == -1)\n\t\t\t\treturn (0);\n\n\t\t\tif (work->tmpl_argvec) {\n\t\t\t\tstring_append(tname, work->tmpl_argvec[idx]);\n\t\t\t\tif (trawname)\n\t\t\t\t\tstring_append(trawname, work->tmpl_argvec[idx]);\n\t\t\t} else {\n\t\t\t\tchar buf[10];\n\t\t\t\tsprintf(buf, \"T%d\", idx);\n\t\t\t\tstring_append(tname, buf);\n\t\t\t\tif (trawname)\n\t\t\t\t\tstring_append(trawname, buf);\n\t\t\t}\n\t\t} else {\n\t\t\tif ((r = consume_count(mangled)) <= 0 || (int)strlen(*mangled) < r) {\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tis_java_array = (work->options & DMGL_JAVA) && strncmp(*mangled, \"JArray1Z\", 8) == 0;\n\t\t\tif (!is_java_array) {\n\t\t\t\tstring_appendn(tname, *mangled, r);\n\t\t\t}\n\t\t\tif (trawname)\n\t\t\t\tstring_appendn(trawname, *mangled, r);\n\t\t\t*mangled += r;\n\t\t}\n\t}\n\tif (!is_java_array)\n\t\tstring_append(tname, \"<\");\n\t/* get size of template parameter list */\n\tif (!get_count(mangled, &r)) {\n\t\treturn (0);\n\t}\n\tif (!is_type) {\n\t\t/* Create an array for saving the template argument values. */\n\t\twork->tmpl_argvec = (char **)malloc(r * sizeof(char *));\n\t\twork->ntmpl_args = r;\n\t\tfor (i = 0; i < r; i++)\n\t\t\twork->tmpl_argvec[i] = 0;\n\t}\n\tfor (i = 0; i < r; i++) {\n\t\tif (need_comma) {\n\t\t\tstring_append(tname, \", \");\n\t\t}\n\t\t/* Z for type parameters */\n\t\tif (**mangled == 'Z') {\n\t\t\t(*mangled)++;\n\t\t\t/* temp is initialized in do_type */\n\t\t\tsuccess = do_type(work, mangled, &temp);\n\t\t\tif (success) {\n\t\t\t\tstring_appends(tname, &temp);\n\n\t\t\t\tif (!is_type) {\n\t\t\t\t\t/* Save the template argument. */\n\t\t\t\t\tint len = temp.p - temp.b;\n\t\t\t\t\twork->tmpl_argvec[i] = malloc(len + 1);\n\t\t\t\t\tmemcpy(work->tmpl_argvec[i], temp.b, len);\n\t\t\t\t\twork->tmpl_argvec[i][len] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring_delete(&temp);\n\t\t\tif (!success) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* z for template parameters */\n\t\telse if (**mangled == 'z') {\n\t\t\tint r2;\n\t\t\t(*mangled)++;\n\t\t\tsuccess = demangle_template_template_parm(work, mangled, tname);\n\n\t\t\tif (success && (r2 = consume_count(mangled)) > 0 && (int)strlen(*mangled) >= r2) {\n\t\t\t\tstring_append(tname, \" \");\n\t\t\t\tstring_appendn(tname, *mangled, r2);\n\t\t\t\tif (!is_type) {\n\t\t\t\t\t/* Save the template argument. */\n\t\t\t\t\tint len = r2;\n\t\t\t\t\twork->tmpl_argvec[i] = malloc(len + 1);\n\t\t\t\t\tmemcpy(work->tmpl_argvec[i], *mangled, len);\n\t\t\t\t\twork->tmpl_argvec[i][len] = '\\0';\n\t\t\t\t}\n\t\t\t\t*mangled += r2;\n\t\t\t}\n\t\t\tif (!success) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tstring param;\n\t\t\tstring *s;\n\n\t\t\t/* otherwise, value parameter */\n\n\t\t\t/* temp is initialized in do_type */\n\t\t\tsuccess = do_type(work, mangled, &temp);\n\t\t\tstring_delete(&temp);\n\t\t\tif (!success)\n\t\t\t\tbreak;\n\n\t\t\tif (!is_type) {\n\t\t\t\ts = &param;\n\t\t\t\tstring_init(s);\n\t\t\t} else\n\t\t\t\ts = tname;\n\n\t\t\tsuccess = demangle_template_value_parm(work, mangled, s,\n\t\t\t\t(type_kind_t)success);\n\n\t\t\tif (!success) {\n\t\t\t\tif (!is_type)\n\t\t\t\t\tstring_delete(s);\n\t\t\t\tsuccess = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!is_type) {\n\t\t\t\tint len = s->p - s->b;\n\t\t\t\twork->tmpl_argvec[i] = malloc(len + 1);\n\t\t\t\tmemcpy(work->tmpl_argvec[i], s->b, len);\n\t\t\t\twork->tmpl_argvec[i][len] = '\\0';\n\n\t\t\t\tstring_appends(tname, s);\n\t\t\t\tstring_delete(s);\n\t\t\t}\n\t\t}\n\t\tneed_comma = 1;\n\t}\n\tif (is_java_array) {\n\t\tstring_append(tname, \"[]\");\n\t} else {\n\t\tif (tname->p[-1] == '>')\n\t\t\tstring_append(tname, \" \");\n\t\tstring_append(tname, \">\");\n\t}\n\n\tif (is_type && remember)\n\t\tremember_Btype(work, tname->b, LEN_STRING(tname), bindex);\n\n\treturn (success);\n}\n\nstatic int\narm_pt(work, mangled, n, anchor, args)\nstruct work_stuff *work;\nconst char *mangled;\nint n;\nconst char **anchor, **args;\n{\n\t/* Check if ARM template with \"__pt__\" in it (\"parameterized type\") */\n\t/* Allow HP also here, because HP's cfront compiler follows ARM to some extent */\n\tif ((ARM_DEMANGLING || HP_DEMANGLING) && (*anchor = mystrstr(mangled, \"__pt__\"))) {\n\t\tint len;\n\t\t*args = *anchor + 6;\n\t\tlen = consume_count(args);\n\t\tif (len == -1)\n\t\t\treturn 0;\n\t\tif (*args + len == mangled + n && **args == '_') {\n\t\t\t++*args;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif (AUTO_DEMANGLING || EDG_DEMANGLING) {\n\t\tif ((*anchor = mystrstr(mangled, \"__tm__\")) || (*anchor = mystrstr(mangled, \"__ps__\")) || (*anchor = mystrstr(mangled, \"__pt__\"))) {\n\t\t\tint len;\n\t\t\t*args = *anchor + 6;\n\t\t\tlen = consume_count(args);\n\t\t\tif (len == -1)\n\t\t\t\treturn 0;\n\t\t\tif (*args + len == mangled + n && **args == '_') {\n\t\t\t\t++*args;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if ((*anchor = mystrstr(mangled, \"__S\"))) {\n\t\t\tint len;\n\t\t\t*args = *anchor + 3;\n\t\t\tlen = consume_count(args);\n\t\t\tif (len == -1)\n\t\t\t\treturn 0;\n\t\t\tif (*args + len == mangled + n && **args == '_') {\n\t\t\t\t++*args;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void\n\tdemangle_arm_hp_template(work, mangled, n, declp) struct work_stuff *work;\nconst char **mangled;\nint n;\nstring *declp;\n{\n\tconst char *p;\n\tconst char *args;\n\tconst char *e = *mangled + n;\n\tstring arg;\n\n\t/* Check for HP aCC template spec: classXt1t2 where t1, t2 are\n\t   template args */\n\tif (HP_DEMANGLING && ((*mangled)[n] == 'X')) {\n\t\tchar *start_spec_args = NULL;\n\n\t\t/* First check for and omit template specialization pseudo-arguments,\n\t\t   such as in \"Spec<#1,#1.*>\" */\n\t\tstart_spec_args = strchr(*mangled, '<');\n\t\tif (start_spec_args && (start_spec_args - *mangled < n))\n\t\t\tstring_appendn(declp, *mangled, start_spec_args - *mangled);\n\t\telse\n\t\t\tstring_appendn(declp, *mangled, n);\n\t\t(*mangled) += n + 1;\n\t\tstring_init(&arg);\n\t\tif (work->temp_start == -1) /* non-recursive call */\n\t\t\twork->temp_start = declp->p - declp->b;\n\t\tstring_append(declp, \"<\");\n\t\twhile (1) {\n\t\t\tstring_clear(&arg);\n\t\t\tswitch (**mangled) {\n\t\t\tcase 'T':\n\t\t\t\t/* 'T' signals a type parameter */\n\t\t\t\t(*mangled)++;\n\t\t\t\tif (!do_type(work, mangled, &arg))\n\t\t\t\t\tgoto hpacc_template_args_done;\n\t\t\t\tbreak;\n\n\t\t\tcase 'U':\n\t\t\tcase 'S':\n\t\t\t\t/* 'U' or 'S' signals an integral value */\n\t\t\t\tif (!do_hpacc_template_const_value(work, mangled, &arg))\n\t\t\t\t\tgoto hpacc_template_args_done;\n\t\t\t\tbreak;\n\n\t\t\tcase 'A':\n\t\t\t\t/* 'A' signals a named constant expression (literal) */\n\t\t\t\tif (!do_hpacc_template_literal(work, mangled, &arg))\n\t\t\t\t\tgoto hpacc_template_args_done;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t/* Today, 1997-09-03, we have only the above types\n\t\t\t\t   of template parameters */\n\t\t\t\t/* FIXME: maybe this should fail and return null */\n\t\t\t\tgoto hpacc_template_args_done;\n\t\t\t}\n\t\t\tstring_appends(declp, &arg);\n\t\t\t/* Check if we're at the end of template args.\n\t\t\t    0 if at end of static member of template class,\n\t\t\t    _ if done with template args for a function */\n\t\t\tif ((**mangled == '\\000') || (**mangled == '_'))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tstring_append(declp, \",\");\n\t\t}\n\thpacc_template_args_done:\n\t\tstring_append(declp, \">\");\n\t\tstring_delete(&arg);\n\t\tif (**mangled == '_')\n\t\t\t(*mangled)++;\n\t\treturn;\n\t}\n\t/* ARM template? (Also handles HP cfront extensions) */\n\telse if (arm_pt(work, *mangled, n, &p, &args)) {\n\t\tstring type_str;\n\n\t\tstring_init(&arg);\n\t\tstring_appendn(declp, *mangled, p - *mangled);\n\t\tif (work->temp_start == -1) /* non-recursive call */\n\t\t\twork->temp_start = declp->p - declp->b;\n\t\tstring_append(declp, \"<\");\n\t\t/* should do error checking here */\n\t\twhile (args < e) {\n\t\t\tstring_clear(&arg);\n\n\t\t\t/* Check for type or literal here */\n\t\t\tswitch (*args) {\n\t\t\t\t/* HP cfront extensions to ARM for template args */\n\t\t\t\t/* spec: Xt1Lv1 where t1 is a type, v1 is a literal value */\n\t\t\t\t/* FIXME: We handle only numeric literals for HP cfront */\n\t\t\tcase 'X':\n\t\t\t\t/* A typed constant value follows */\n\t\t\t\targs++;\n\t\t\t\tif (!do_type(work, &args, &type_str))\n\t\t\t\t\tgoto cfront_template_args_done;\n\t\t\t\tstring_append(&arg, \"(\");\n\t\t\t\tstring_appends(&arg, &type_str);\n\t\t\t\tstring_append(&arg, \")\");\n\t\t\t\tif (*args != 'L')\n\t\t\t\t\tgoto cfront_template_args_done;\n\t\t\t\targs++;\n\t\t\t\t/* Now snarf a literal value following 'L' */\n\t\t\t\tif (!snarf_numeric_literal(&args, &arg))\n\t\t\t\t\tgoto cfront_template_args_done;\n\t\t\t\tbreak;\n\n\t\t\tcase 'L':\n\t\t\t\t/* Snarf a literal following 'L' */\n\t\t\t\targs++;\n\t\t\t\tif (!snarf_numeric_literal(&args, &arg))\n\t\t\t\t\tgoto cfront_template_args_done;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* Not handling other HP cfront stuff */\n\t\t\t\tif (!do_type(work, &args, &arg))\n\t\t\t\t\tgoto cfront_template_args_done;\n\t\t\t}\n\t\t\tstring_appends(declp, &arg);\n\t\t\tstring_append(declp, \",\");\n\t\t}\n\tcfront_template_args_done:\n\t\tstring_delete(&arg);\n\t\tif (args >= e)\n\t\t\t--declp->p; /* remove extra comma */\n\t\tstring_append(declp, \">\");\n\t} else if (n > 10 && strncmp(*mangled, \"_GLOBAL_\", 8) == 0 && (*mangled)[9] == 'N' && (*mangled)[8] == (*mangled)[10] && strchr(cplus_markers, (*mangled)[8])) {\n\t\t/* A member of the anonymous namespace.  */\n\t\tstring_append(declp, \"{anonymous}\");\n\t} else {\n\t\tif (work->temp_start == -1) /* non-recursive call only */\n\t\t\twork->temp_start = 0; /* disable in recursive calls */\n\t\tstring_appendn(declp, *mangled, n);\n\t}\n\t*mangled += n;\n}\n\n/* Extract a class name, possibly a template with arguments, from the\n   mangled string; qualifiers, local class indicators, etc. have\n   already been dealt with */\n\nstatic int\ndemangle_class_name(work, mangled, declp)\nstruct work_stuff *work;\nconst char **mangled;\nstring *declp;\n{\n\tint n;\n\tint success = 0;\n\n\tn = consume_count(mangled);\n\tif (n == -1)\n\t\treturn 0;\n\tif ((int)strlen(*mangled) >= n) {\n\t\tdemangle_arm_hp_template(work, mangled, n, declp);\n\t\tsuccess = 1;\n\t}\n\n\treturn (success);\n}\n\n/*\n\nLOCAL FUNCTION\n\n\tdemangle_class -- demangle a mangled class sequence\n\nSYNOPSIS\n\n\tstatic int\n\tdemangle_class (struct work_stuff *work, const char **mangled,\n\t\t\tstrint *declp)\n\nDESCRIPTION\n\n\tDECLP points to the buffer into which demangling is being done.\n\n\t*MANGLED points to the current token to be demangled.  On input,\n\tit points to a mangled class (I.E. \"3foo\", \"13verylongclass\", etc.)\n\tOn exit, it points to the next token after the mangled class on\n\tsuccess, or the first unconsumed token on failure.\n\n\tIf the CONSTRUCTOR or DESTRUCTOR flags are set in WORK, then\n\twe are demangling a constructor or destructor.  In this case\n\twe prepend \"class::class\" or \"class::~class\" to DECLP.\n\n\tOtherwise, we prepend \"class::\" to the current DECLP.\n\n\tReset the constructor/destructor flags once they have been\n\t\"consumed\".  This allows demangle_class to be called later during\n\tthe same demangling, to do normal class demangling.\n\n\tReturns 1 if demangling is successful, 0 otherwise.\n\n*/\n\nstatic int\ndemangle_class(work, mangled, declp)\nstruct work_stuff *work;\nconst char **mangled;\nstring *declp;\n{\n\tint success = 0;\n\tint btype;\n\tstring class_name;\n\tchar *save_class_name_end = 0;\n\n\tstring_init(&class_name);\n\tbtype = register_Btype(work);\n\tif (demangle_class_name(work, mangled, &class_name)) {\n\t\tsave_class_name_end = class_name.p;\n\t\tif ((work->constructor & 1) || (work->destructor & 1)) {\n\t\t\t/* adjust so we don't include template args */\n\t\t\tif (work->temp_start && (work->temp_start != -1)) {\n\t\t\t\tclass_name.p = class_name.b + work->temp_start;\n\t\t\t}\n\t\t\tstring_prepends(declp, &class_name);\n\t\t\tif (work->destructor & 1) {\n\t\t\t\tstring_prepend(declp, \"~\");\n\t\t\t\twork->destructor -= 1;\n\t\t\t} else {\n\t\t\t\twork->constructor -= 1;\n\t\t\t}\n\t\t}\n\t\tclass_name.p = save_class_name_end;\n\t\tremember_Ktype(work, class_name.b, LEN_STRING(&class_name));\n\t\tremember_Btype(work, class_name.b, LEN_STRING(&class_name), btype);\n\t\tstring_prepend(declp, SCOPE_STRING(work));\n\t\tstring_prepends(declp, &class_name);\n\t\tsuccess = 1;\n\t}\n\tstring_delete(&class_name);\n\treturn (success);\n}\n\n/*\n\nLOCAL FUNCTION\n\n\tdemangle_prefix -- consume the mangled name prefix and find signature\n\nSYNOPSIS\n\n\tstatic int\n\tdemangle_prefix (struct work_stuff *work, const char **mangled,\n\t\t\t string *declp);\n\nDESCRIPTION\n\n\tConsume and demangle the prefix of the mangled name.\n\n\tDECLP points to the string buffer into which demangled output is\n\tplaced.  On entry, the buffer is empty.  On exit it contains\n\tthe root function name, the demangled operator name, or in some\n\tspecial cases either nothing or the completely demangled result.\n\n\tMANGLED points to the current pointer into the mangled name.  As each\n\ttoken of the mangled name is consumed, it is updated.  Upon entry\n\tthe current mangled name pointer points to the first character of\n\tthe mangled name.  Upon exit, it should point to the first character\n\tof the signature if demangling was successful, or to the first\n\tunconsumed character if demangling of the prefix was unsuccessful.\n\n\tReturns 1 on success, 0 otherwise.\n */\n\nstatic int\ndemangle_prefix(work, mangled, declp)\nstruct work_stuff *work;\nconst char **mangled;\nstring *declp;\n{\n\tint success = 1;\n\tconst char *scan;\n\tint i;\n\n\tif (strlen(*mangled) > 6 && (strncmp(*mangled, \"_imp__\", 6) == 0 || strncmp(*mangled, \"__imp_\", 6) == 0)) {\n\t\t/* it's a symbol imported from a PE dynamic library. Check for both\n\t\t   new style prefix _imp__ and legacy __imp_ used by older versions\n\t\t   of dlltool. */\n\t\t(*mangled) += 6;\n\t\twork->dllimported = 1;\n\t} else if (strlen(*mangled) >= 11 && strncmp(*mangled, \"_GLOBAL_\", 8) == 0) {\n\t\tchar *marker = strchr(cplus_markers, (*mangled)[8]);\n\t\tif (marker != NULL && *marker == (*mangled)[10]) {\n\t\t\tif ((*mangled)[9] == 'D') {\n\t\t\t\t/* it's a GNU global destructor to be executed at program exit */\n\t\t\t\t(*mangled) += 11;\n\t\t\t\twork->destructor = 2;\n\t\t\t\tif (gnu_special(work, mangled, declp))\n\t\t\t\t\treturn success;\n\t\t\t} else if ((*mangled)[9] == 'I') {\n\t\t\t\t/* it's a GNU global constructor to be executed at program init */\n\t\t\t\t(*mangled) += 11;\n\t\t\t\twork->constructor = 2;\n\t\t\t\tif (gnu_special(work, mangled, declp))\n\t\t\t\t\treturn success;\n\t\t\t}\n\t\t}\n\t} else if ((ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING) && strncmp(*mangled, \"__std__\", 7) == 0) {\n\t\t/* it's a ARM global destructor to be executed at program exit */\n\t\t(*mangled) += 7;\n\t\twork->destructor = 2;\n\t} else if ((ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING) && strncmp(*mangled, \"__sti__\", 7) == 0) {\n\t\t/* it's a ARM global constructor to be executed at program initial */\n\t\t(*mangled) += 7;\n\t\twork->constructor = 2;\n\t}\n\n\t/*  This block of code is a reduction in strength time optimization\n\t    of:\n\t    scan = mystrstr (*mangled, \"__\"); */\n\n\t{\n\t\tscan = *mangled;\n\n\t\tdo {\n\t\t\tscan = strchr(scan, '_');\n\t\t} while (scan != NULL && *++scan != '_');\n\n\t\tif (scan != NULL)\n\t\t\t--scan;\n\t}\n\n\tif (scan != NULL) {\n\t\t/* We found a sequence of two or more '_', ensure that we start at\n\t\t   the last pair in the sequence.  */\n\t\ti = strspn(scan, \"_\");\n\t\tif (i > 2) {\n\t\t\tscan += (i - 2);\n\t\t}\n\t}\n\n\tif (scan == NULL) {\n\t\tsuccess = 0;\n\t} else if (work->static_type) {\n\t\tif (!isdigit((unsigned char)scan[0]) && (scan[0] != 't')) {\n\t\t\tsuccess = 0;\n\t\t}\n\t} else if ((scan == *mangled) && (isdigit((unsigned char)scan[2]) || (scan[2] == 'Q') || (scan[2] == 't') || (scan[2] == 'K') || (scan[2] == 'H'))) {\n\t\t/* The ARM says nothing about the mangling of local variables.\n\t\t   But cfront mangles local variables by prepending __<nesting_level>\n\t\t   to them. As an extension to ARM demangling we handle this case.  */\n\t\tif ((LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING) && isdigit((unsigned char)scan[2])) {\n\t\t\t*mangled = scan + 2;\n\t\t\tconsume_count(mangled);\n\t\t\tstring_append(declp, *mangled);\n\t\t\t*mangled += strlen(*mangled);\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\t/* A GNU style constructor starts with __[0-9Qt].  But cfront uses\n\t\t\t   names like __Q2_3foo3bar for nested type names.  So don't accept\n\t\t\t   this style of constructor for cfront demangling.  A GNU\n\t\t\t   style member-template constructor starts with 'H'. */\n\t\t\tif (!(LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING))\n\t\t\t\twork->constructor += 1;\n\t\t\t*mangled = scan + 2;\n\t\t}\n\t} else if (ARM_DEMANGLING && scan[2] == 'p' && scan[3] == 't') {\n\t\t/* Cfront-style parameterized type.  Handled later as a signature. */\n\t\tsuccess = 1;\n\n\t\t/* ARM template? */\n\t\tdemangle_arm_hp_template(work, mangled, strlen(*mangled), declp);\n\t} else if (EDG_DEMANGLING && ((scan[2] == 't' && scan[3] == 'm') || (scan[2] == 'p' && scan[3] == 's') || (scan[2] == 'p' && scan[3] == 't'))) {\n\t\t/* EDG-style parameterized type.  Handled later as a signature. */\n\t\tsuccess = 1;\n\n\t\t/* EDG template? */\n\t\tdemangle_arm_hp_template(work, mangled, strlen(*mangled), declp);\n\t} else if ((scan == *mangled) && !isdigit((unsigned char)scan[2]) && (scan[2] != 't')) {\n\t\t/* Mangled name starts with \"__\".  Skip over any leading '_' characters,\n\t\t   then find the next \"__\" that separates the prefix from the signature.\n\t\t   */\n\t\tif (!(ARM_DEMANGLING || LUCID_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING) || (arm_special(mangled, declp) == 0)) {\n\t\t\twhile (*scan == '_') {\n\t\t\t\tscan++;\n\t\t\t}\n\t\t\tif ((scan = mystrstr(scan, \"__\")) == NULL || (*(scan + 2) == '\\0')) {\n\t\t\t\t/* No separator (I.E. \"__not_mangled\"), or empty signature\n\t\t\t\t   (I.E. \"__not_mangled_either__\") */\n\t\t\t\tsuccess = 0;\n\t\t\t} else {\n\t\t\t\tconst char *tmp;\n\n\t\t\t\t/* Look for the LAST occurrence of __, allowing names to\n\t\t\t\t   have the '__' sequence embedded in them. */\n\t\t\t\tif (!(ARM_DEMANGLING || HP_DEMANGLING)) {\n\t\t\t\t\twhile ((tmp = mystrstr(scan + 2, \"__\")) != NULL)\n\t\t\t\t\t\tscan = tmp;\n\t\t\t\t}\n\t\t\t\tif (*(scan + 2) == '\\0')\n\t\t\t\t\tsuccess = 0;\n\t\t\t\telse\n\t\t\t\t\tdemangle_function_name(work, mangled, declp, scan);\n\t\t\t}\n\t\t}\n\t} else if (*(scan + 2) != '\\0') {\n\t\t/* Mangled name does not start with \"__\" but does have one somewhere\n\t\t   in there with non empty stuff after it.  Looks like a global\n\t\t   function name.  */\n\t\tdemangle_function_name(work, mangled, declp, scan);\n\t} else {\n\t\t/* Doesn't look like a mangled name */\n\t\tsuccess = 0;\n\t}\n\n\tif (!success && (work->constructor == 2 || work->destructor == 2)) {\n\t\tstring_append(declp, *mangled);\n\t\t*mangled += strlen(*mangled);\n\t\tsuccess = 1;\n\t}\n\treturn (success);\n}\n\n/*\n\nLOCAL FUNCTION\n\n\tgnu_special -- special handling of gnu mangled strings\n\nSYNOPSIS\n\n\tstatic int\n\tgnu_special (struct work_stuff *work, const char **mangled,\n\t\t     string *declp);\n\n\nDESCRIPTION\n\n\tProcess some special GNU style mangling forms that don't fit\n\tthe normal pattern.  For example:\n\n\t\t_$_3foo\t\t(destructor for class foo)\n\t\t_vt$foo\t\t(foo virtual table)\n\t\t_vt$foo$bar\t(foo::bar virtual table)\n\t\t__vt_foo\t(foo virtual table, new style with thunks)\n\t\t_3foo$varname\t(static data member)\n\t\t_Q22rs2tu$vw\t(static data member)\n\t\t__t6vector1Zii\t(constructor with template)\n\t\t__thunk_4__$_7ostream (virtual function thunk)\n */\n\nstatic int\ngnu_special(work, mangled, declp)\nstruct work_stuff *work;\nconst char **mangled;\nstring *declp;\n{\n\tint n;\n\tint success = 1;\n\tconst char *p;\n\n\tif ((*mangled)[0] == '_' && strchr(cplus_markers, (*mangled)[1]) != NULL && (*mangled)[2] == '_') {\n\t\t/* Found a GNU style destructor, get past \"_<CPLUS_MARKER>_\" */\n\t\t(*mangled) += 3;\n\t\twork->destructor += 1;\n\t} else if ((*mangled)[0] == '_' && (((*mangled)[1] == '_' && (*mangled)[2] == 'v' && (*mangled)[3] == 't' && (*mangled)[4] == '_') || ((*mangled)[1] == 'v' && (*mangled)[2] == 't' && strchr(cplus_markers, (*mangled)[3]) != NULL))) {\n\t\t/* Found a GNU style virtual table, get past \"_vt<CPLUS_MARKER>\"\n\t\t   and create the decl.  Note that we consume the entire mangled\n\t\t   input string, which means that demangle_signature has no work\n\t\t   to do.  */\n\t\tif ((*mangled)[2] == 'v')\n\t\t\t(*mangled) += 5; /* New style, with thunks: \"__vt_\" */\n\t\telse\n\t\t\t(*mangled) += 4; /* Old style, no thunks: \"_vt<CPLUS_MARKER>\" */\n\t\twhile (**mangled != '\\0') {\n\t\t\tswitch (**mangled) {\n\t\t\tcase 'Q':\n\t\t\tcase 'K':\n\t\t\t\tsuccess = demangle_qualified(work, mangled, declp, 0, 1);\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tsuccess = demangle_template(work, mangled, declp, 0, 1,\n\t\t\t\t\t1);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (isdigit((unsigned char)*mangled[0])) {\n\t\t\t\t\tn = consume_count(mangled);\n\t\t\t\t\t/* We may be seeing a too-large size, or else a\n\t\t\t\t\t   \".<digits>\" indicating a static local symbol.  In\n\t\t\t\t\t   any case, declare victory and move on; *don't* try\n\t\t\t\t\t   to use n to allocate.  */\n\t\t\t\t\tif (n > (int)strlen(*mangled)) {\n\t\t\t\t\t\tsuccess = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tn = strcspn(*mangled, cplus_markers);\n\t\t\t\t}\n\t\t\t\tstring_appendn(declp, *mangled, n);\n\t\t\t\t(*mangled) += n;\n\t\t\t}\n\n\t\t\tp = strpbrk(*mangled, cplus_markers);\n\t\t\tif (success && ((p == NULL) || (p == *mangled))) {\n\t\t\t\tif (p != NULL) {\n\t\t\t\t\tstring_append(declp, SCOPE_STRING(work));\n\t\t\t\t\t(*mangled)++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsuccess = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (success)\n\t\t\tstring_append(declp, \" virtual table\");\n\t} else if ((*mangled)[0] == '_' && (strchr(\"0123456789Qt\", (*mangled)[1]) != NULL) && (p = strpbrk(*mangled, cplus_markers)) != NULL) {\n\t\t/* static data member, \"_3foo$varname\" for example */\n\t\t(*mangled)++;\n\t\tswitch (**mangled) {\n\t\tcase 'Q':\n\t\tcase 'K':\n\t\t\tsuccess = demangle_qualified(work, mangled, declp, 0, 1);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tsuccess = demangle_template(work, mangled, declp, 0, 1, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tn = consume_count(mangled);\n\t\t\tif (n < 0 || n > strlen(*mangled)) {\n\t\t\t\tsuccess = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstring_appendn(declp, *mangled, n);\n\t\t\t(*mangled) += n;\n\t\t}\n\t\tif (success && (p == *mangled)) {\n\t\t\t/* Consumed everything up to the cplus_marker, append the\n\t\t\t   variable name.  */\n\t\t\t(*mangled)++;\n\t\t\tstring_append(declp, SCOPE_STRING(work));\n\t\t\tn = strlen(*mangled);\n\t\t\tstring_appendn(declp, *mangled, n);\n\t\t\t(*mangled) += n;\n\t\t} else {\n\t\t\tsuccess = 0;\n\t\t}\n\t} else if (strncmp(*mangled, \"__thunk_\", 8) == 0) {\n\t\tint delta;\n\n\t\t(*mangled) += 8;\n\t\tdelta = consume_count(mangled);\n\t\tif (delta == -1)\n\t\t\tsuccess = 0;\n\t\telse {\n\t\t\tchar *method = internal_cplus_demangle(work, ++*mangled);\n\n\t\t\tif (method) {\n\t\t\t\tchar buf[50];\n\t\t\t\tsprintf(buf, \"virtual function thunk (delta:%d) for \", -delta);\n\t\t\t\tstring_append(declp, buf);\n\t\t\t\tstring_append(declp, method);\n\t\t\t\tfree(method);\n\t\t\t\tn = strlen(*mangled);\n\t\t\t\t(*mangled) += n;\n\t\t\t} else {\n\t\t\t\tsuccess = 0;\n\t\t\t}\n\t\t}\n\t} else if (strncmp(*mangled, \"__t\", 3) == 0 && ((*mangled)[3] == 'i' || (*mangled)[3] == 'f')) {\n\t\tp = (*mangled)[3] == 'i' ? \" type_info node\" : \" type_info function\";\n\t\t(*mangled) += 4;\n\t\tswitch (**mangled) {\n\t\tcase 'Q':\n\t\tcase 'K':\n\t\t\tsuccess = demangle_qualified(work, mangled, declp, 0, 1);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tsuccess = demangle_template(work, mangled, declp, 0, 1, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsuccess = demangle_fund_type(work, mangled, declp);\n\t\t\tbreak;\n\t\t}\n\t\tif (success && **mangled != '\\0')\n\t\t\tsuccess = 0;\n\t\tif (success)\n\t\t\tstring_append(declp, p);\n\t} else {\n\t\tsuccess = 0;\n\t}\n\treturn (success);\n}\n\nstatic void\n\trecursively_demangle(work, mangled, result, namelength) struct work_stuff *work;\nconst char **mangled;\nstring *result;\nint namelength;\n{\n\tchar *recurse = (char *)NULL;\n\tchar *recurse_dem = (char *)NULL;\n\n\trecurse = (char *)malloc(namelength + 1);\n\tmemcpy(recurse, *mangled, namelength);\n\trecurse[namelength] = '\\000';\n\n\trecurse_dem = cplus_demangle_v2(recurse, work->options);\n\n\tif (recurse_dem) {\n\t\tstring_append(result, recurse_dem);\n\t\tfree(recurse_dem);\n\t} else {\n\t\tstring_appendn(result, *mangled, namelength);\n\t}\n\tfree(recurse);\n\t*mangled += namelength;\n}\n\n/*\n\nLOCAL FUNCTION\n\n\tarm_special -- special handling of ARM/lucid mangled strings\n\nSYNOPSIS\n\n\tstatic int\n\tarm_special (const char **mangled,\n\t\t     string *declp);\n\n\nDESCRIPTION\n\n\tProcess some special ARM style mangling forms that don't fit\n\tthe normal pattern.  For example:\n\n\t\t__vtbl__3foo\t\t(foo virtual table)\n\t\t__vtbl__3foo__3bar\t(bar::foo virtual table)\n\n */\n\nstatic int\n\tarm_special(mangled, declp)\n\t\tconst char **mangled;\nstring *declp;\n{\n\tint n;\n\tint success = 1;\n\tconst char *scan;\n\n\tif (strncmp(*mangled, ARM_VTABLE_STRING, ARM_VTABLE_STRLEN) == 0) {\n\t\t/* Found a ARM style virtual table, get past ARM_VTABLE_STRING\n\t\t   and create the decl.  Note that we consume the entire mangled\n\t\t   input string, which means that demangle_signature has no work\n\t\t   to do.  */\n\t\tscan = *mangled + ARM_VTABLE_STRLEN;\n\t\twhile (*scan != '\\0') /* first check it can be demangled */\n\t\t{\n\t\t\tn = consume_count(&scan);\n\t\t\tif (n == -1) {\n\t\t\t\treturn (0); /* no good */\n\t\t\t}\n\t\t\tscan += n;\n\t\t\tif (scan[0] == '_' && scan[1] == '_') {\n\t\t\t\tscan += 2;\n\t\t\t}\n\t\t}\n\t\t(*mangled) += ARM_VTABLE_STRLEN;\n\t\twhile (**mangled != '\\0') {\n\t\t\tn = consume_count(mangled);\n\t\t\tif (n == -1 || n > strlen(*mangled))\n\t\t\t\treturn 0;\n\t\t\tstring_prependn(declp, *mangled, n);\n\t\t\t(*mangled) += n;\n\t\t\tif ((*mangled)[0] == '_' && (*mangled)[1] == '_') {\n\t\t\t\tstring_prepend(declp, \"::\");\n\t\t\t\t(*mangled) += 2;\n\t\t\t}\n\t\t}\n\t\tstring_append(declp, \" virtual table\");\n\t} else {\n\t\tsuccess = 0;\n\t}\n\treturn (success);\n}\n\n/*\n\nLOCAL FUNCTION\n\n\tdemangle_qualified -- demangle 'Q' qualified name strings\n\nSYNOPSIS\n\n\tstatic int\n\tdemangle_qualified (struct work_stuff *, const char *mangled,\n\t\t\t    string *result, int isfuncname, int append);\n\nDESCRIPTION\n\n\tDemangle a qualified name, such as \"Q25Outer5Inner\" which is\n\tthe mangled form of \"Outer::Inner\".  The demangled output is\n\tprepended or appended to the result string according to the\n\tstate of the append flag.\n\n\tIf isfuncname is nonzero, then the qualified name we are building\n\tis going to be used as a member function name, so if it is a\n\tconstructor or destructor function, append an appropriate\n\tconstructor or destructor name.  I.E. for the above example,\n\tthe result for use as a constructor is \"Outer::Inner::Inner\"\n\tand the result for use as a destructor is \"Outer::Inner::~Inner\".\n\nBUGS\n\n\tNumeric conversion is ASCII dependent (FIXME).\n\n */\n\nstatic int\ndemangle_qualified(work, mangled, result, isfuncname, append)\nstruct work_stuff *work;\nconst char **mangled;\nstring *result;\nint isfuncname;\nint append;\n{\n\tint qualifiers = 0;\n\tint success = 1;\n\tconst char *p;\n\tchar num[2];\n\tstring temp;\n\tstring last_name;\n\tint bindex = register_Btype(work);\n\n\t/* We only make use of ISFUNCNAME if the entity is a constructor or\n\t   destructor.  */\n\tisfuncname = (isfuncname && ((work->constructor & 1) || (work->destructor & 1)));\n\n\tstring_init(&temp);\n\tstring_init(&last_name);\n\n\tif ((*mangled)[0] == 'K') {\n\t\t/* Squangling qualified name reuse */\n\t\tint idx;\n\t\t(*mangled)++;\n\t\tidx = consume_count_with_underscores(mangled);\n\t\tif (idx == -1 || idx >= work->numk)\n\t\t\tsuccess = 0;\n\t\telse\n\t\t\tstring_append(&temp, work->ktypevec[idx]);\n\t} else\n\t\tswitch ((*mangled)[1]) {\n\t\tcase '_':\n\t\t\t/* GNU mangled name with more than 9 classes.  The count is preceded\n\t\t\t   by an underscore (to distinguish it from the <= 9 case) and followed\n\t\t\t   by an underscore.  */\n\t\t\tp = *mangled + 2;\n\t\t\tqualifiers = atoi(p);\n\t\t\tif (!isdigit((unsigned char)*p) || *p == '0')\n\t\t\t\tsuccess = 0;\n\n\t\t\t/* Skip the digits.  */\n\t\t\twhile (isdigit((unsigned char)*p))\n\t\t\t\t++p;\n\n\t\t\tif (*p != '_')\n\t\t\t\tsuccess = 0;\n\n\t\t\t*mangled = p + 1;\n\t\t\tbreak;\n\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\t\t/* The count is in a single digit.  */\n\t\t\tnum[0] = (*mangled)[1];\n\t\t\tnum[1] = '\\0';\n\t\t\tqualifiers = atoi(num);\n\n\t\t\t/* If there is an underscore after the digit, skip it.  This is\n\t\t\t   said to be for ARM-qualified names, but the ARM makes no\n\t\t\t   mention of such an underscore.  Perhaps cfront uses one.  */\n\t\t\tif ((*mangled)[2] == '_') {\n\t\t\t\t(*mangled)++;\n\t\t\t}\n\t\t\t(*mangled) += 2;\n\t\t\tbreak;\n\n\t\tcase '0':\n\t\tdefault:\n\t\t\tsuccess = 0;\n\t\t}\n\n\tif (!success)\n\t\treturn success;\n\n\t/* Pick off the names and collect them in the temp buffer in the order\n\t   in which they are found, separated by '::'.  */\n\n\twhile (qualifiers-- > 0) {\n\t\tint remember_K = 1;\n\t\tstring_clear(&last_name);\n\n\t\tif (*mangled[0] == '_')\n\t\t\t(*mangled)++;\n\n\t\tif (*mangled[0] == 't') {\n\t\t\t/* Here we always append to TEMP since we will want to use\n\t\t\t   the template name without the template parameters as a\n\t\t\t   constructor or destructor name.  The appropriate\n\t\t\t   (parameter-less) value is returned by demangle_template\n\t\t\t   in LAST_NAME.  We do not remember the template type here,\n\t\t\t   in order to match the G++ mangling algorithm.  */\n\t\t\tsuccess = demangle_template(work, mangled, &temp,\n\t\t\t\t&last_name, 1, 0);\n\t\t\tif (!success)\n\t\t\t\tbreak;\n\t\t} else if (*mangled[0] == 'K') {\n\t\t\tint idx;\n\t\t\t(*mangled)++;\n\t\t\tidx = consume_count_with_underscores(mangled);\n\t\t\tif (idx == -1 || idx >= work->numk)\n\t\t\t\tsuccess = 0;\n\t\t\telse\n\t\t\t\tstring_append(&temp, work->ktypevec[idx]);\n\t\t\tremember_K = 0;\n\n\t\t\tif (!success)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (EDG_DEMANGLING) {\n\t\t\t\tint namelength;\n\t\t\t\t/* Now recursively demangle the qualifier\n\t\t\t\t * This is necessary to deal with templates in\n\t\t\t\t * mangling styles like EDG */\n\t\t\t\tnamelength = consume_count(mangled);\n\t\t\t\tif (namelength == -1) {\n\t\t\t\t\tsuccess = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trecursively_demangle(work, mangled, &temp, namelength);\n\t\t\t} else {\n\t\t\t\tsuccess = do_type(work, mangled, &last_name);\n\t\t\t\tif (!success)\n\t\t\t\t\tbreak;\n\t\t\t\tstring_appends(&temp, &last_name);\n\t\t\t}\n\t\t}\n\n\t\tif (remember_K)\n\t\t\tremember_Ktype(work, temp.b, LEN_STRING(&temp));\n\n\t\tif (qualifiers > 0)\n\t\t\tstring_append(&temp, SCOPE_STRING(work));\n\t}\n\n\tremember_Btype(work, temp.b, LEN_STRING(&temp), bindex);\n\n\t/* If we are using the result as a function name, we need to append\n\t   the appropriate '::' separated constructor or destructor name.\n\t   We do this here because this is the most convenient place, where\n\t   we already have a pointer to the name and the length of the name.  */\n\n\tif (isfuncname) {\n\t\tstring_append(&temp, SCOPE_STRING(work));\n\t\tif (work->destructor & 1)\n\t\t\tstring_append(&temp, \"~\");\n\t\tstring_appends(&temp, &last_name);\n\t}\n\n\t/* Now either prepend the temp buffer to the result, or append it,\n\t   depending upon the state of the append flag.  */\n\n\tif (append)\n\t\tstring_appends(result, &temp);\n\telse {\n\t\tif (!STRING_EMPTY(result))\n\t\t\tstring_append(&temp, SCOPE_STRING(work));\n\t\tstring_prepends(result, &temp);\n\t}\n\n\tstring_delete(&last_name);\n\tstring_delete(&temp);\n\treturn (success);\n}\n\n/*\n\nLOCAL FUNCTION\n\n\tget_count -- convert an ascii count to integer, consuming tokens\n\nSYNOPSIS\n\n\tstatic int\n\tget_count (const char **type, int *count)\n\nDESCRIPTION\n\n\tAssume that *type points at a count in a mangled name; set\n\t*count to its value, and set *type to the next character after\n\tthe count.  There are some weird rules in effect here.\n\n\tIf *type does not point at a string of digits, return zero.\n\n\tIf *type points at a string of digits followed by an\n\tunderscore, set *count to their value as an integer, advance\n\t*type to point *after the underscore, and return 1.\n\n\tIf *type points at a string of digits not followed by an\n\tunderscore, consume only the first digit.  Set *count to its\n\tvalue as an integer, leave *type pointing after that digit,\n\tand return 1.\n\n\tThe excuse for this odd behavior: in the ARM and HP demangling\n\tstyles, a type can be followed by a repeat count of the form\n\t`Nxy', where:\n\n\t`x' is a single digit specifying how many additional copies\n\t    of the type to append to the argument list, and\n\n\t`y' is one or more digits, specifying the zero-based index of\n\t    the first repeated argument in the list.  Yes, as you're\n\t    unmangling the name you can figure this out yourself, but\n\t    it's there anyway.\n\n\tSo, for example, in `bar__3fooFPiN51', the first argument is a\n\tpointer to an integer (`Pi'), and then the next five arguments\n\tare the same (`N5'), and the first repeat is the function's\n\tsecond argument (`1').\n*/\n\nstatic int\n\tget_count(type, count)\n\t\tconst char **type;\nint *count;\n{\n\tconst char *p;\n\tint n;\n\n\tif (!isdigit((unsigned char)**type)) {\n\t\treturn (0);\n\t} else {\n\t\t*count = **type - '0';\n\t\t(*type)++;\n\t\tif (isdigit((unsigned char)**type)) {\n\t\t\tp = *type;\n\t\t\tn = *count;\n\t\t\tdo {\n\t\t\t\tn *= 10;\n\t\t\t\tn += *p - '0';\n\t\t\t\tp++;\n\t\t\t} while (isdigit((unsigned char)*p));\n\t\t\tif (*p == '_') {\n\t\t\t\t*type = p + 1;\n\t\t\t\t*count = n;\n\t\t\t}\n\t\t}\n\t}\n\treturn (1);\n}\n\n/* RESULT will be initialised here; it will be freed on failure.  The\n   value returned is really a type_kind_t.  */\n\nstatic int\ndo_type(work, mangled, result)\nstruct work_stuff *work;\nconst char **mangled;\nstring *result;\n{\n\tint n;\n\tint done;\n\tint success;\n\tstring decl;\n\tconst char *remembered_type;\n\tint type_quals;\n\tstring btype;\n\ttype_kind_t tk = tk_none;\n\n\tstring_init(&btype);\n\tstring_init(&decl);\n\tstring_init(result);\n\n\tdone = 0;\n\tsuccess = 1;\n\twhile (success && !done) {\n\t\tint member;\n\t\tswitch (**mangled) {\n\n\t\t\t/* A pointer type */\n\t\tcase 'P':\n\t\tcase 'p':\n\t\t\t(*mangled)++;\n\t\t\tif (!(work->options & DMGL_JAVA))\n\t\t\t\tstring_prepend(&decl, \"*\");\n\t\t\tif (tk == tk_none)\n\t\t\t\ttk = tk_pointer;\n\t\t\tbreak;\n\n\t\t\t/* A reference type */\n\t\tcase 'R':\n\t\t\t(*mangled)++;\n\t\t\tstring_prepend(&decl, \"&\");\n\t\t\tif (tk == tk_none)\n\t\t\t\ttk = tk_reference;\n\t\t\tbreak;\n\n\t\t\t/* An array */\n\t\tcase 'A': {\n\t\t\t++(*mangled);\n\t\t\tif (!STRING_EMPTY(&decl) && (decl.b[0] == '*' || decl.b[0] == '&')) {\n\t\t\t\tstring_prepend(&decl, \"(\");\n\t\t\t\tstring_append(&decl, \")\");\n\t\t\t}\n\t\t\tstring_append(&decl, \"[\");\n\t\t\tif (**mangled != '_')\n\t\t\t\tsuccess = demangle_template_value_parm(work, mangled, &decl,\n\t\t\t\t\ttk_integral);\n\t\t\tif (**mangled == '_')\n\t\t\t\t++(*mangled);\n\t\t\tstring_append(&decl, \"]\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/* A back reference to a previously seen type */\n\t\tcase 'T':\n\t\t\t(*mangled)++;\n\t\t\tif (!get_count(mangled, &n) || n >= work->ntypes) {\n\t\t\t\tsuccess = 0;\n\t\t\t} else {\n\t\t\t\tremembered_type = work->typevec[n];\n\t\t\t\tmangled = &remembered_type;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* A function */\n\t\tcase 'F':\n\t\t\t(*mangled)++;\n\t\t\tif (!STRING_EMPTY(&decl) && (decl.b[0] == '*' || decl.b[0] == '&')) {\n\t\t\t\tstring_prepend(&decl, \"(\");\n\t\t\t\tstring_append(&decl, \")\");\n\t\t\t}\n\t\t\t/* After picking off the function args, we expect to either find the\n\t\t\t   function return type (preceded by an '_') or the end of the\n\t\t\t   string.  */\n\t\t\tif (!demangle_nested_args(work, mangled, &decl) || (**mangled != '_' && **mangled != '\\0')) {\n\t\t\t\tsuccess = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (success && (**mangled == '_'))\n\t\t\t\t(*mangled)++;\n\t\t\tbreak;\n\n\t\tcase 'M':\n\t\tcase 'O': {\n\t\t\ttype_quals = TYPE_UNQUALIFIED;\n\n\t\t\tmember = **mangled == 'M';\n\t\t\t(*mangled)++;\n\n\t\t\tstring_append(&decl, \")\");\n\t\t\tstring_prepend(&decl, SCOPE_STRING(work));\n\t\t\tif (isdigit((unsigned char)**mangled)) {\n\t\t\t\tn = consume_count(mangled);\n\t\t\t\tif (n == -1 || (int)strlen(*mangled) < n) {\n\t\t\t\t\tsuccess = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstring_prependn(&decl, *mangled, n);\n\t\t\t\t*mangled += n;\n\t\t\t} else if (**mangled == 'X' || **mangled == 'Y') {\n\t\t\t\tstring temp;\n\t\t\t\tdo_type(work, mangled, &temp);\n\t\t\t\tstring_prepends(&decl, &temp);\n\t\t\t} else if (**mangled == 't') {\n\t\t\t\tstring temp;\n\t\t\t\tstring_init(&temp);\n\t\t\t\tsuccess = demangle_template(work, mangled, &temp,\n\t\t\t\t\tNULL, 1, 1);\n\t\t\t\tif (success) {\n\t\t\t\t\tstring_prependn(&decl, temp.b, temp.p - temp.b);\n\t\t\t\t\tstring_clear(&temp);\n\t\t\t\t} else\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tsuccess = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstring_prepend(&decl, \"(\");\n\t\t\tif (member) {\n\t\t\t\tswitch (**mangled) {\n\t\t\t\tcase 'C':\n\t\t\t\tcase 'V':\n\t\t\t\tcase 'u':\n\t\t\t\t\ttype_quals |= code_for_qualifier(**mangled);\n\t\t\t\t\t(*mangled)++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (*(*mangled)++ != 'F') {\n\t\t\t\t\tsuccess = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((member && !demangle_nested_args(work, mangled, &decl)) || **mangled != '_') {\n\t\t\t\tsuccess = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t(*mangled)++;\n\t\t\tif (!PRINT_ANSI_QUALIFIERS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (type_quals != TYPE_UNQUALIFIED) {\n\t\t\t\tAPPEND_BLANK(&decl);\n\t\t\t\tstring_append(&decl, qualifier_string(type_quals));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 'G':\n\t\t\t(*mangled)++;\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\tcase 'V':\n\t\tcase 'u':\n\t\t\tif (PRINT_ANSI_QUALIFIERS) {\n\t\t\t\tif (!STRING_EMPTY(&decl))\n\t\t\t\t\tstring_prepend(&decl, \" \");\n\n\t\t\t\tstring_prepend(&decl, demangle_qualifier(**mangled));\n\t\t\t}\n\t\t\t(*mangled)++;\n\t\t\tbreak;\n\t\t\t/*\n\t\t\t  }\n\t\t\t  */\n\n\t\t\t/* fall through */\n\t\tdefault:\n\t\t\tdone = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (success)\n\t\tswitch (**mangled) {\n\t\t\t/* A qualified name, such as \"Outer::Inner\".  */\n\t\tcase 'Q':\n\t\tcase 'K': {\n\t\t\tsuccess = demangle_qualified(work, mangled, result, 0, 1);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* A back reference to a previously seen squangled type */\n\t\tcase 'B':\n\t\t\t(*mangled)++;\n\t\t\tif (!get_count(mangled, &n) || n >= work->numb)\n\t\t\t\tsuccess = 0;\n\t\t\telse\n\t\t\t\tstring_append(result, work->btypevec[n]);\n\t\t\tbreak;\n\n\t\tcase 'X':\n\t\tcase 'Y':\n\t\t\t/* A template parm.  We substitute the corresponding argument. */\n\t\t\t{\n\t\t\t\tint idx;\n\n\t\t\t\t(*mangled)++;\n\t\t\t\tidx = consume_count_with_underscores(mangled);\n\n\t\t\t\tif (idx == -1 || (work->tmpl_argvec && idx >= work->ntmpl_args) || consume_count_with_underscores(mangled) == -1) {\n\t\t\t\t\tsuccess = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (work->tmpl_argvec)\n\t\t\t\t\tstring_append(result, work->tmpl_argvec[idx]);\n\t\t\t\telse {\n\t\t\t\t\tchar buf[10];\n\t\t\t\t\tsprintf(buf, \"T%d\", idx);\n\t\t\t\t\tstring_append(result, buf);\n\t\t\t\t}\n\n\t\t\t\tsuccess = 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tsuccess = demangle_fund_type(work, mangled, result);\n\t\t\tif (tk == tk_none)\n\t\t\t\ttk = (type_kind_t)success;\n\t\t\tbreak;\n\t\t}\n\n\tif (success) {\n\t\tif (!STRING_EMPTY(&decl)) {\n\t\t\tstring_append(result, \" \");\n\t\t\tstring_appends(result, &decl);\n\t\t}\n\t} else\n\t\tstring_delete(result);\n\tstring_delete(&decl);\n\n\tif (success)\n\t\t/* Assume an integral type, if we're not sure.  */\n\t\treturn (int)((tk == tk_none) ? tk_integral : tk);\n\telse\n\t\treturn 0;\n}\n\n/* Given a pointer to a type string that represents a fundamental type\n   argument (int, long, unsigned int, etc) in TYPE, a pointer to the\n   string in which the demangled output is being built in RESULT, and\n   the WORK structure, decode the types and add them to the result.\n\n   For example:\n\n\t\"Ci\"\t=>\t\"const int\"\n\t\"Sl\"\t=>\t\"signed long\"\n\t\"CUs\"\t=>\t\"const unsigned short\"\n\n   The value returned is really a type_kind_t.  */\n\nstatic int\ndemangle_fund_type(work, mangled, result)\nstruct work_stuff *work;\nconst char **mangled;\nstring *result;\n{\n\tint done = 0;\n\tint success = 1;\n\tchar buf[10];\n\tint dec = 0;\n\tstring btype;\n\ttype_kind_t tk = tk_integral;\n\n\tstring_init(&btype);\n\n\t/* First pick off any type qualifiers.  There can be more than one.  */\n\n\twhile (!done) {\n\t\tswitch (**mangled) {\n\t\tcase 'C':\n\t\tcase 'V':\n\t\tcase 'u':\n\t\t\tif (PRINT_ANSI_QUALIFIERS) {\n\t\t\t\tif (!STRING_EMPTY(result))\n\t\t\t\t\tstring_prepend(result, \" \");\n\t\t\t\tstring_prepend(result, demangle_qualifier(**mangled));\n\t\t\t}\n\t\t\t(*mangled)++;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\t(*mangled)++;\n\t\t\tAPPEND_BLANK(result);\n\t\t\tstring_append(result, \"unsigned\");\n\t\t\tbreak;\n\t\tcase 'S': /* signed char only */\n\t\t\t(*mangled)++;\n\t\t\tAPPEND_BLANK(result);\n\t\t\tstring_append(result, \"signed\");\n\t\t\tbreak;\n\t\tcase 'J':\n\t\t\t(*mangled)++;\n\t\t\tAPPEND_BLANK(result);\n\t\t\tstring_append(result, \"__complex\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdone = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Now pick off the fundamental type.  There can be only one.  */\n\n\tswitch (**mangled) {\n\tcase '\\0':\n\tcase '_':\n\t\tbreak;\n\tcase 'v':\n\t\t(*mangled)++;\n\t\tAPPEND_BLANK(result);\n\t\tstring_append(result, \"void\");\n\t\tbreak;\n\tcase 'x':\n\t\t(*mangled)++;\n\t\tAPPEND_BLANK(result);\n\t\tstring_append(result, \"long long\");\n\t\tbreak;\n\tcase 'l':\n\t\t(*mangled)++;\n\t\tAPPEND_BLANK(result);\n\t\tstring_append(result, \"long\");\n\t\tbreak;\n\tcase 'i':\n\t\t(*mangled)++;\n\t\tAPPEND_BLANK(result);\n\t\tstring_append(result, \"int\");\n\t\tbreak;\n\tcase 's':\n\t\t(*mangled)++;\n\t\tAPPEND_BLANK(result);\n\t\tstring_append(result, \"short\");\n\t\tbreak;\n\tcase 'b':\n\t\t(*mangled)++;\n\t\tAPPEND_BLANK(result);\n\t\tstring_append(result, \"bool\");\n\t\ttk = tk_bool;\n\t\tbreak;\n\tcase 'c':\n\t\t(*mangled)++;\n\t\tAPPEND_BLANK(result);\n\t\tstring_append(result, \"char\");\n\t\ttk = tk_char;\n\t\tbreak;\n\tcase 'w':\n\t\t(*mangled)++;\n\t\tAPPEND_BLANK(result);\n\t\tstring_append(result, \"wchar_t\");\n\t\ttk = tk_char;\n\t\tbreak;\n\tcase 'r':\n\t\t(*mangled)++;\n\t\tAPPEND_BLANK(result);\n\t\tstring_append(result, \"long double\");\n\t\ttk = tk_real;\n\t\tbreak;\n\tcase 'd':\n\t\t(*mangled)++;\n\t\tAPPEND_BLANK(result);\n\t\tstring_append(result, \"double\");\n\t\ttk = tk_real;\n\t\tbreak;\n\tcase 'f':\n\t\t(*mangled)++;\n\t\tAPPEND_BLANK(result);\n\t\tstring_append(result, \"float\");\n\t\ttk = tk_real;\n\t\tbreak;\n\tcase 'G':\n\t\t(*mangled)++;\n\t\tif (!isdigit((unsigned char)**mangled)) {\n\t\t\tsuccess = 0;\n\t\t\tbreak;\n\t\t}\n\tcase 'I':\n\t\t(*mangled)++;\n\t\tif (**mangled == '_') {\n\t\t\tint i;\n\t\t\t(*mangled)++;\n\t\t\tfor (i = 0;\n\t\t\t\ti < sizeof(buf) - 1 && **mangled && **mangled != '_';\n\t\t\t\t(*mangled)++, i++)\n\t\t\t\tbuf[i] = **mangled;\n\t\t\tif (**mangled != '_') {\n\t\t\t\tsuccess = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf[i] = '\\0';\n\t\t\t(*mangled)++;\n\t\t} else {\n\t\t\tstrncpy(buf, *mangled, 2);\n\t\t\tbuf[2] = '\\0';\n\t\t\t*mangled += min(strlen(*mangled), 2);\n\t\t}\n\t\tsscanf(buf, \"%x\", &dec);\n\t\tsprintf(buf, \"int%i_t\", dec);\n\t\tAPPEND_BLANK(result);\n\t\tstring_append(result, buf);\n\t\tbreak;\n\n\t\t/* fall through */\n\t\t/* An explicit type, such as \"6mytype\" or \"7integer\" */\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9': {\n\t\tint bindex = register_Btype(work);\n\t\tstring btype;\n\t\tstring_init(&btype);\n\t\tif (demangle_class_name(work, mangled, &btype)) {\n\t\t\tremember_Btype(work, btype.b, LEN_STRING(&btype), bindex);\n\t\t\tAPPEND_BLANK(result);\n\t\t\tstring_appends(result, &btype);\n\t\t} else\n\t\t\tsuccess = 0;\n\t\tstring_delete(&btype);\n\t\tbreak;\n\t}\n\tcase 't': {\n\t\tsuccess = demangle_template(work, mangled, &btype, 0, 1, 1);\n\t\tstring_appends(result, &btype);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tsuccess = 0;\n\t\tbreak;\n\t}\n\n\treturn success ? ((int)tk) : 0;\n}\n\n/* Handle a template's value parameter for HP aCC (extension from ARM)\n **mangled points to 'S' or 'U' */\n\nstatic int\ndo_hpacc_template_const_value(work, mangled, result)\nstruct work_stuff *work;\nconst char **mangled;\nstring *result;\n{\n\tint unsigned_const;\n\n\tif (**mangled != 'U' && **mangled != 'S')\n\t\treturn 0;\n\n\tunsigned_const = (**mangled == 'U');\n\n\t(*mangled)++;\n\n\tswitch (**mangled) {\n\tcase 'N':\n\t\tstring_append(result, \"-\");\n\t\t/* fall through */\n\tcase 'P':\n\t\t(*mangled)++;\n\t\tbreak;\n\tcase 'M':\n\t\t/* special case for -2^31 */\n\t\tstring_append(result, \"-2147483648\");\n\t\t(*mangled)++;\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t/* We have to be looking at an integer now */\n\tif (!(isdigit((unsigned char)**mangled)))\n\t\treturn 0;\n\n\t/* We only deal with integral values for template\n\t   parameters -- so it's OK to look only for digits */\n\twhile (isdigit((unsigned char)**mangled)) {\n\t\tchar_str[0] = **mangled;\n\t\tstring_append(result, char_str);\n\t\t(*mangled)++;\n\t}\n\n\tif (unsigned_const)\n\t\tstring_append(result, \"U\");\n\n\t/* FIXME? Some day we may have 64-bit (or larger :-) ) constants\n\t   with L or LL suffixes. pai/1997-09-03 */\n\n\treturn 1; /* success */\n}\n\n/* Handle a template's literal parameter for HP aCC (extension from ARM)\n **mangled is pointing to the 'A' */\n\nstatic int\ndo_hpacc_template_literal(work, mangled, result)\nstruct work_stuff *work;\nconst char **mangled;\nstring *result;\n{\n\tint literal_len = 0;\n\tchar *recurse;\n\tchar *recurse_dem;\n\n\tif (**mangled != 'A')\n\t\treturn 0;\n\n\t(*mangled)++;\n\n\tliteral_len = consume_count(mangled);\n\n\tif (literal_len <= 0)\n\t\treturn 0;\n\n\t/* Literal parameters are names of arrays, functions, etc.  and the\n\t   canonical representation uses the address operator */\n\tstring_append(result, \"&\");\n\n\t/* Now recursively demangle the literal name */\n\trecurse = (char *)malloc(literal_len + 1);\n\tmemcpy(recurse, *mangled, literal_len);\n\trecurse[literal_len] = '\\000';\n\n\trecurse_dem = cplus_demangle_v2(recurse, work->options);\n\n\tif (recurse_dem) {\n\t\tstring_append(result, recurse_dem);\n\t\tfree(recurse_dem);\n\t} else {\n\t\tstring_appendn(result, *mangled, literal_len);\n\t}\n\t(*mangled) += literal_len;\n\tfree(recurse);\n\n\treturn 1;\n}\n\nstatic int\n\tsnarf_numeric_literal(args, arg)\n\t\tconst char **args;\nstring *arg;\n{\n\tif (**args == '-') {\n\t\tchar_str[0] = '-';\n\t\tstring_append(arg, char_str);\n\t\t(*args)++;\n\t} else if (**args == '+')\n\t\t(*args)++;\n\n\tif (!isdigit((unsigned char)**args))\n\t\treturn 0;\n\n\twhile (isdigit((unsigned char)**args)) {\n\t\tchar_str[0] = **args;\n\t\tstring_append(arg, char_str);\n\t\t(*args)++;\n\t}\n\n\treturn 1;\n}\n\n/* Demangle the next argument, given by MANGLED into RESULT, which\n   *should be an uninitialized* string.  It will be initialized here,\n   and free'd should anything go wrong.  */\n\nstatic int\ndo_arg(work, mangled, result)\nstruct work_stuff *work;\nconst char **mangled;\nstring *result;\n{\n\t/* Remember where we started so that we can record the type, for\n\t   non-squangling type remembering.  */\n\tconst char *start = *mangled;\n\n\tstring_init(result);\n\n\tif (work->nrepeats > 0) {\n\t\t--work->nrepeats;\n\n\t\tif (work->previous_argument == 0)\n\t\t\treturn 0;\n\n\t\t/* We want to reissue the previous type in this argument list.  */\n\t\tstring_appends(result, work->previous_argument);\n\t\treturn 1;\n\t}\n\n\tif (**mangled == 'n') {\n\t\t/* A squangling-style repeat.  */\n\t\t(*mangled)++;\n\t\twork->nrepeats = consume_count(mangled);\n\n\t\tif (work->nrepeats <= 0)\n\t\t\t/* This was not a repeat count after all.  */\n\t\t\treturn 0;\n\n\t\tif (work->nrepeats > 9) {\n\t\t\tif (**mangled != '_')\n\t\t\t\t/* The repeat count should be followed by an '_' in this\n\t\t\t\t   case.  */\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\t(*mangled)++;\n\t\t}\n\n\t\t/* Now, the repeat is all set up.  */\n\t\treturn do_arg(work, mangled, result);\n\t}\n\n\t/* Save the result in WORK->previous_argument so that we can find it\n\t   if it's repeated.  Note that saving START is not good enough: we\n\t   do not want to add additional types to the back-referenceable\n\t   type vector when processing a repeated type.  */\n\tif (work->previous_argument)\n\t\tstring_clear(work->previous_argument);\n\telse {\n\t\twork->previous_argument = (string *)malloc(sizeof(string));\n\t\tstring_init(work->previous_argument);\n\t}\n\n\tif (!do_type(work, mangled, work->previous_argument))\n\t\treturn 0;\n\n\tstring_appends(result, work->previous_argument);\n\n\tremember_type(work, start, *mangled - start);\n\treturn 1;\n}\n\nstatic void\n\tremember_type(work, start, len) struct work_stuff *work;\nconst char *start;\nint len;\n{\n\tchar *tem;\n\n\tif (work->forgetting_types)\n\t\treturn;\n\n\tif (work->ntypes >= work->typevec_size) {\n\t\tif (work->typevec_size == 0) {\n\t\t\twork->typevec_size = 3;\n\t\t\twork->typevec = (char **)malloc(sizeof(char *) * work->typevec_size);\n\t\t} else {\n\t\t\twork->typevec_size *= 2;\n\t\t\twork->typevec = (char **)realloc((char *)work->typevec,\n\t\t\t\tsizeof(char *) * work->typevec_size);\n\t\t}\n\t}\n\ttem = malloc(len + 1);\n\tmemcpy(tem, start, len);\n\ttem[len] = '\\0';\n\twork->typevec[work->ntypes++] = tem;\n}\n\n/* Remember a K type class qualifier. */\nstatic void\n\tremember_Ktype(work, start, len) struct work_stuff *work;\nconst char *start;\nint len;\n{\n\tchar *tem;\n\n\tif (work->numk >= work->ksize) {\n\t\tif (work->ksize == 0) {\n\t\t\twork->ksize = 5;\n\t\t\twork->ktypevec = (char **)malloc(sizeof(char *) * work->ksize);\n\t\t} else {\n\t\t\twork->ksize *= 2;\n\t\t\twork->ktypevec = (char **)realloc((char *)work->ktypevec,\n\t\t\t\tsizeof(char *) * work->ksize);\n\t\t}\n\t}\n\ttem = malloc(len + 1);\n\tmemcpy(tem, start, len);\n\ttem[len] = '\\0';\n\twork->ktypevec[work->numk++] = tem;\n}\n\n/* Register a B code, and get an index for it. B codes are registered\n   as they are seen, rather than as they are completed, so map<temp<char> >\n   registers map<temp<char> > as B0, and temp<char> as B1 */\n\nstatic int\nregister_Btype(work)\nstruct work_stuff *work;\n{\n\tint ret;\n\n\tif (work->numb >= work->bsize) {\n\t\tif (work->bsize == 0) {\n\t\t\twork->bsize = 5;\n\t\t\twork->btypevec = (char **)malloc(sizeof(char *) * work->bsize);\n\t\t} else {\n\t\t\twork->bsize *= 2;\n\t\t\twork->btypevec = (char **)realloc((char *)work->btypevec,\n\t\t\t\tsizeof(char *) * work->bsize);\n\t\t}\n\t}\n\tret = work->numb++;\n\twork->btypevec[ret] = NULL;\n\treturn (ret);\n}\n\n/* Store a value into a previously registered B code type. */\n\nstatic void\n\tremember_Btype(work, start, len, index) struct work_stuff *work;\nconst char *start;\nint len, index;\n{\n\tchar *tem;\n\n\ttem = malloc(len + 1);\n\tmemcpy(tem, start, len);\n\ttem[len] = '\\0';\n\twork->btypevec[index] = tem;\n}\n\n/* Lose all the info related to B and K type codes. */\nstatic void\n\tforget_B_and_K_types(work) struct work_stuff *work;\n{\n\tint i;\n\n\twhile (work->numk > 0) {\n\t\ti = --(work->numk);\n\t\tif (work->ktypevec[i] != NULL) {\n\t\t\tfree(work->ktypevec[i]);\n\t\t\twork->ktypevec[i] = NULL;\n\t\t}\n\t}\n\n\twhile (work->numb > 0) {\n\t\ti = --(work->numb);\n\t\tif (work->btypevec[i] != NULL) {\n\t\t\tfree(work->btypevec[i]);\n\t\t\twork->btypevec[i] = NULL;\n\t\t}\n\t}\n}\n/* Forget the remembered types, but not the type vector itself.  */\n\nstatic void\n\tforget_types(work) struct work_stuff *work;\n{\n\tint i;\n\n\twhile (work->ntypes > 0) {\n\t\ti = --(work->ntypes);\n\t\tif (work->typevec[i] != NULL) {\n\t\t\tfree(work->typevec[i]);\n\t\t\twork->typevec[i] = NULL;\n\t\t}\n\t}\n}\n\n/* Process the argument list part of the signature, after any class spec\n   has been consumed, as well as the first 'F' character (if any).  For\n   example:\n\n   \"__als__3fooRT0\"\t\t=>\tprocess \"RT0\"\n   \"complexfunc5__FPFPc_PFl_i\"\t=>\tprocess \"PFPc_PFl_i\"\n\n   DECLP must be already initialised, usually non-empty.  It won't be freed\n   on failure.\n\n   Note that g++ differs significantly from ARM and lucid style mangling\n   with regards to references to previously seen types.  For example, given\n   the source fragment:\n\n     class foo {\n       public:\n       foo::foo (int, foo &ia, int, foo &ib, int, foo &ic);\n     };\n\n     foo::foo (int, foo &ia, int, foo &ib, int, foo &ic) { ia = ib = ic; }\n     void foo (int, foo &ia, int, foo &ib, int, foo &ic) { ia = ib = ic; }\n\n   g++ produces the names:\n\n     __3fooiRT0iT2iT2\n     foo__FiR3fooiT1iT1\n\n   while lcc (and presumably other ARM style compilers as well) produces:\n\n     foo__FiR3fooT1T2T1T2\n     __ct__3fooFiR3fooT1T2T1T2\n\n   Note that g++ bases its type numbers starting at zero and counts all\n   previously seen types, while lucid/ARM bases its type numbers starting\n   at one and only considers types after it has seen the 'F' character\n   indicating the start of the function args.  For lucid/ARM style, we\n   account for this difference by discarding any previously seen types when\n   we see the 'F' character, and subtracting one from the type number\n   reference.\n\n */\n\nstatic int\ndemangle_args(work, mangled, declp)\nstruct work_stuff *work;\nconst char **mangled;\nstring *declp;\n{\n\tstring arg;\n\tint need_comma = 0;\n\tint r;\n\tint t;\n\tconst char *tem;\n\tchar temptype;\n\n\tif (PRINT_ARG_TYPES) {\n\t\tstring_append(declp, \"(\");\n\t\tif (**mangled == '\\0') {\n\t\t\tstring_append(declp, \"void\");\n\t\t}\n\t}\n\n\twhile ((**mangled != '_' && **mangled != '\\0' && **mangled != 'e') || work->nrepeats > 0) {\n\t\tif ((**mangled == 'N') || (**mangled == 'T')) {\n\t\t\ttemptype = *(*mangled)++;\n\n\t\t\tif (temptype == 'N') {\n\t\t\t\tif (!get_count(mangled, &r)) {\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr = 1;\n\t\t\t}\n\t\t\tif ((HP_DEMANGLING || ARM_DEMANGLING || EDG_DEMANGLING) && work->ntypes >= 10) {\n\t\t\t\t/* If we have 10 or more types we might have more than a 1 digit\n\t\t\t\t   index so we'll have to consume the whole count here. This\n\t\t\t\t   will lose if the next thing is a type name preceded by a\n\t\t\t\t   count but it's impossible to demangle that case properly\n\t\t\t\t   anyway. Eg if we already have 12 types is T12Pc \"(..., type1,\n\t\t\t\t   Pc, ...)\"  or \"(..., type12, char *, ...)\" */\n\t\t\t\tif ((t = consume_count(mangled)) <= 0) {\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!get_count(mangled, &t)) {\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING) {\n\t\t\t\tt--;\n\t\t\t}\n\t\t\t/* Validate the type index.  Protect against illegal indices from\n\t\t\t   malformed type strings.  */\n\t\t\tif ((t < 0) || (t >= work->ntypes)) {\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\twhile (work->nrepeats > 0 || --r >= 0) {\n\t\t\t\ttem = work->typevec[t];\n\t\t\t\tif (need_comma && PRINT_ARG_TYPES) {\n\t\t\t\t\tstring_append(declp, \", \");\n\t\t\t\t}\n\t\t\t\tif (!do_arg(work, &tem, &arg)) {\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tif (PRINT_ARG_TYPES) {\n\t\t\t\t\tstring_appends(declp, &arg);\n\t\t\t\t}\n\t\t\t\tstring_delete(&arg);\n\t\t\t\tneed_comma = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (need_comma && PRINT_ARG_TYPES)\n\t\t\t\tstring_append(declp, \", \");\n\t\t\tif (!do_arg(work, mangled, &arg))\n\t\t\t\treturn (0);\n\t\t\tif (PRINT_ARG_TYPES)\n\t\t\t\tstring_appends(declp, &arg);\n\t\t\tstring_delete(&arg);\n\t\t\tneed_comma = 1;\n\t\t}\n\t}\n\n\tif (**mangled == 'e') {\n\t\t(*mangled)++;\n\t\tif (PRINT_ARG_TYPES) {\n\t\t\tif (need_comma) {\n\t\t\t\tstring_append(declp, \",\");\n\t\t\t}\n\t\t\tstring_append(declp, \"...\");\n\t\t}\n\t}\n\n\tif (PRINT_ARG_TYPES) {\n\t\tstring_append(declp, \")\");\n\t}\n\treturn (1);\n}\n\n/* Like demangle_args, but for demangling the argument lists of function\n   and method pointers or references, not top-level declarations.  */\n\nstatic int\ndemangle_nested_args(work, mangled, declp)\nstruct work_stuff *work;\nconst char **mangled;\nstring *declp;\n{\n\tstring *saved_previous_argument;\n\tint result;\n\tint saved_nrepeats;\n\n\t/* The G++ name-mangling algorithm does not remember types on nested\n\t   argument lists, unless -fsquangling is used, and in that case the\n\t   type vector updated by remember_type is not used.  So, we turn\n\t   off remembering of types here.  */\n\t++work->forgetting_types;\n\n\t/* For the repeat codes used with -fsquangling, we must keep track of\n\t   the last argument.  */\n\tsaved_previous_argument = work->previous_argument;\n\tsaved_nrepeats = work->nrepeats;\n\twork->previous_argument = 0;\n\twork->nrepeats = 0;\n\n\t/* Actually demangle the arguments.  */\n\tresult = demangle_args(work, mangled, declp);\n\n\t/* Restore the previous_argument field.  */\n\tif (work->previous_argument)\n\t\tstring_delete(work->previous_argument);\n\twork->previous_argument = saved_previous_argument;\n\t--work->forgetting_types;\n\twork->nrepeats = saved_nrepeats;\n\n\treturn result;\n}\n\nstatic void\n\tdemangle_function_name(work, mangled, declp, scan) struct work_stuff *work;\nconst char **mangled;\nstring *declp;\nconst char *scan;\n{\n\tsize_t i;\n\tstring type;\n\tconst char *tem;\n\n\tstring_appendn(declp, (*mangled), scan - (*mangled));\n\tstring_need(declp, 1);\n\t*(declp->p) = '\\0';\n\n\t/* Consume the function name, including the \"__\" separating the name\n\t   from the signature.  We are guaranteed that SCAN points to the\n\t   separator.  */\n\n\t(*mangled) = scan + 2;\n\t/* We may be looking at an instantiation of a template function:\n\t   foo__Xt1t2_Ft3t4, where t1, t2, ... are template arguments and a\n\t   following _F marks the start of the function arguments.  Handle\n\t   the template arguments first. */\n\n\tif (HP_DEMANGLING && (**mangled == 'X')) {\n\t\tdemangle_arm_hp_template(work, mangled, 0, declp);\n\t\t/* This leaves MANGLED pointing to the 'F' marking func args */\n\t}\n\n\tif (LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING) {\n\n\t\t/* See if we have an ARM style constructor or destructor operator.\n\t\t   If so, then just record it, clear the decl, and return.\n\t\t   We can't build the actual constructor/destructor decl until later,\n\t\t   when we recover the class name from the signature.  */\n\n\t\tif (strcmp(declp->b, \"__ct\") == 0) {\n\t\t\twork->constructor += 1;\n\t\t\tstring_clear(declp);\n\t\t\treturn;\n\t\t} else if (strcmp(declp->b, \"__dt\") == 0) {\n\t\t\twork->destructor += 1;\n\t\t\tstring_clear(declp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (declp->p - declp->b >= 3 && declp->b[0] == 'o' && declp->b[1] == 'p' && strchr(cplus_markers, declp->b[2]) != NULL) {\n\t\t/* see if it's an assignment expression */\n\t\tif (declp->p - declp->b >= 10 /* op$assign_ */\n\t\t\t&& memcmp(declp->b + 3, \"assign_\", 7) == 0) {\n\t\t\tfor (i = 0; i < sizeof(optable) / sizeof(optable[0]); i++) {\n\t\t\t\tint len = declp->p - declp->b - 10;\n\t\t\t\tif ((int)strlen(optable[i].in) == len && memcmp(optable[i].in, declp->b + 10, len) == 0) {\n\t\t\t\t\tstring_clear(declp);\n\t\t\t\t\tstring_append(declp, \"operator\");\n\t\t\t\t\tstring_append(declp, optable[i].out);\n\t\t\t\t\tstring_append(declp, \"=\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < sizeof(optable) / sizeof(optable[0]); i++) {\n\t\t\t\tint len = declp->p - declp->b - 3;\n\t\t\t\tif ((int)strlen(optable[i].in) == len && memcmp(optable[i].in, declp->b + 3, len) == 0) {\n\t\t\t\t\tstring_clear(declp);\n\t\t\t\t\tstring_append(declp, \"operator\");\n\t\t\t\t\tstring_append(declp, optable[i].out);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (declp->p - declp->b >= 5 && memcmp(declp->b, \"type\", 4) == 0 && strchr(cplus_markers, declp->b[4]) != NULL) {\n\t\t/* type conversion operator */\n\t\ttem = declp->b + 5;\n\t\tif (do_type(work, &tem, &type)) {\n\t\t\tstring_clear(declp);\n\t\t\tstring_append(declp, \"operator \");\n\t\t\tstring_appends(declp, &type);\n\t\t\tstring_delete(&type);\n\t\t}\n\t} else if (declp->b[0] == '_' && declp->b[1] == '_' && declp->b[2] == 'o' && declp->b[3] == 'p') {\n\t\t/* ANSI.  */\n\t\t/* type conversion operator.  */\n\t\ttem = declp->b + 4;\n\t\tif (do_type(work, &tem, &type)) {\n\t\t\tstring_clear(declp);\n\t\t\tstring_append(declp, \"operator \");\n\t\t\tstring_appends(declp, &type);\n\t\t\tstring_delete(&type);\n\t\t}\n\t} else if (declp->b[0] == '_' && declp->b[1] == '_' && declp->b[2] >= 'a' && declp->b[2] <= 'z' && declp->b[3] >= 'a' && declp->b[3] <= 'z') {\n\t\tif (declp->b[4] == '\\0') {\n\t\t\t/* Operator.  */\n\t\t\tfor (i = 0; i < sizeof(optable) / sizeof(optable[0]); i++) {\n\t\t\t\tif (strlen(optable[i].in) == 2 && memcmp(optable[i].in, declp->b + 2, 2) == 0) {\n\t\t\t\t\tstring_clear(declp);\n\t\t\t\t\tstring_append(declp, \"operator\");\n\t\t\t\t\tstring_append(declp, optable[i].out);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (declp->b[2] == 'a' && declp->b[5] == '\\0') {\n\t\t\t\t/* Assignment.  */\n\t\t\t\tfor (i = 0; i < sizeof(optable) / sizeof(optable[0]); i++) {\n\t\t\t\t\tif (strlen(optable[i].in) == 3 && memcmp(optable[i].in, declp->b + 2, 3) == 0) {\n\t\t\t\t\t\tstring_clear(declp);\n\t\t\t\t\t\tstring_append(declp, \"operator\");\n\t\t\t\t\t\tstring_append(declp, optable[i].out);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* a mini string-handling package */\n\nstatic void\n\tstring_need(s, n)\n\t\tstring *s;\nint n;\n{\n\tint tem;\n\n\tif (s->b == NULL) {\n\t\tif (n < 32) {\n\t\t\tn = 32;\n\t\t}\n\t\ts->p = s->b = malloc(n);\n\t\ts->e = s->b + n;\n\t} else if (s->e - s->p < n) {\n\t\ttem = s->p - s->b;\n\t\tn += tem;\n\t\tn *= 2;\n\t\ts->b = realloc(s->b, n);\n\t\ts->p = s->b + tem;\n\t\ts->e = s->b + n;\n\t}\n}\n\nstatic void\n\tstring_delete(s)\n\t\tstring *s;\n{\n\tif (s->b != NULL) {\n\t\tfree(s->b);\n\t\ts->b = s->e = s->p = NULL;\n\t}\n}\n\nstatic void\n\tstring_init(s)\n\t\tstring *s;\n{\n\ts->b = s->p = s->e = NULL;\n}\n\nstatic void\n\tstring_clear(s)\n\t\tstring *s;\n{\n\ts->p = s->b;\n}\n\n#if 0\n\nstatic int\nstring_empty (s)\n     string *s;\n{\n  return (s->b == s->p);\n}\n\n#endif\n\nstatic void\n\tstring_append(p, s)\n\t\tstring *p;\nconst char *s;\n{\n\tint n;\n\tif (s == NULL || *s == '\\0')\n\t\treturn;\n\tn = strlen(s);\n\tstring_need(p, n);\n\tmemcpy(p->p, s, n);\n\tp->p += n;\n}\n\nstatic void\n\tstring_appends(p, s)\n\t\tstring *p,\n\t*s;\n{\n\tint n;\n\n\tif (s->b != s->p) {\n\t\tn = s->p - s->b;\n\t\tstring_need(p, n);\n\t\tmemcpy(p->p, s->b, n);\n\t\tp->p += n;\n\t}\n}\n\nstatic void\n\tstring_appendn(p, s, n)\n\t\tstring *p;\nconst char *s;\nint n;\n{\n\tif (n != 0) {\n\t\tstring_need(p, n);\n\t\tmemcpy(p->p, s, n);\n\t\tp->p += n;\n\t}\n}\n\nstatic void\n\tstring_prepend(p, s)\n\t\tstring *p;\nconst char *s;\n{\n\tif (s != NULL && *s != '\\0') {\n\t\tstring_prependn(p, s, strlen(s));\n\t}\n}\n\nstatic void\n\tstring_prepends(p, s)\n\t\tstring *p,\n\t*s;\n{\n\tif (s->b != s->p) {\n\t\tstring_prependn(p, s->b, s->p - s->b);\n\t}\n}\n\nstatic void\n\tstring_prependn(p, s, n)\n\t\tstring *p;\nconst char *s;\nint n;\n{\n\tchar *q;\n\n\tif (n != 0) {\n\t\tstring_need(p, n);\n\t\tfor (q = p->p - 1; q >= p->b; q--) {\n\t\t\tq[n] = q[0];\n\t\t}\n\t\tmemcpy(p->b, s, n);\n\t\tp->p += n;\n\t}\n}\n", "// SPDX-FileCopyrightText: 2023 deroad <wargio@libero.it>\n// SPDX-License-Identifier: LGPL-3.0-only\n\n#include \"minunit.h\"\n\nmu_demangle_tests(gnu_v2,\n\t// fuzzed strings\n\tmu_demangle_test(\"_ITM_deregisterTMCCCCCCCCCCCCCCCCCCCtart__5555555555555555CloneTable\", NULL),\n\t// normal\n\tmu_demangle_test(\"_vt.foo\", \"foo virtual table\"),\n\tmu_demangle_test(\"_vt$foo\", \"foo virtual table\"),\n\tmu_demangle_test(\"_vt$foo$bar\", \"foo::bar virtual table\"),\n\tmu_demangle_test(\"__vt_foo\", \"foo virtual table\"),\n\tmu_demangle_test(\"_3foo$varname\", \"foo::varname\"),\n\tmu_demangle_test(\"__thunk_4__$_7ostream\", \"virtual function thunk (delta:-4) for ostream::~ostream(void)\"),\n\tmu_demangle_test(\"_$_3foo\", \"foo::~foo(void)\"),\n\tmu_demangle_test(\"_._3foo\", \"foo::~foo(void)\"),\n\tmu_demangle_test(\"_Q22rs2tu$vw\", \"rs::tu::vw\"),\n\tmu_demangle_test(\"__t6vector1Zii\", \"vector<int>::vector(int)\"),\n\tmu_demangle_test(\"foo__1Ai\", \"A::foo(int)\"),\n\tmu_demangle_test(\"foo__1Afe\", \"A::foo(float,...)\"),\n\tmu_demangle_test(\"_AddColor__10ZafDisplayUcUcUcUcUc\", \"ZafDisplay::_AddColor(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)\"),\n\t// end\n);\n\nmu_main(gnu_v2, cxx);"], "filenames": ["src/gnu_v2/cplus-dem.c", "test/test_cxx_gnu_v2.c"], "buggy_code_start_loc": [423, 6], "buggy_code_end_loc": [424, 6], "fixing_code_start_loc": [423, 7], "fixing_code_end_loc": [427, 10], "type": "CWE-190", "message": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.6.0 and prior are vulnerable to integer overflow in `consume_count` of `src/gnu_v2/cplus-dem.c`. The overflow check is valid logic but, is missing the modulus if the block once compiled. The compiler sees this block as unreachable code since the prior statement is multiplication by 10 and fails to consider overflow assuming the count will always be a multiple of 10. Rizin version 0.6.1 contains a fix for the issue. A temporary workaround would be disabling C++ demangling using the configuration option `bin.demangle=false`.", "other": {"cve": {"id": "CVE-2023-40022", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-24T23:15:09.177", "lastModified": "2023-08-30T19:50:45.640", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.6.0 and prior are vulnerable to integer overflow in `consume_count` of `src/gnu_v2/cplus-dem.c`. The overflow check is valid logic but, is missing the modulus if the block once compiled. The compiler sees this block as unreachable code since the prior statement is multiplication by 10 and fails to consider overflow assuming the count will always be a multiple of 10. Rizin version 0.6.1 contains a fix for the issue. A temporary workaround would be disabling C++ demangling using the configuration option `bin.demangle=false`."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rizin:rizin:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.6.1", "matchCriteriaId": "08C366A2-96F0-48AF-9956-4D145431166F"}]}]}], "references": [{"url": "https://github.com/rizinorg/rizin/pull/3753", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/rizinorg/rizin/security/advisories/GHSA-92h6-wwc2-53cq", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/rizinorg/rz-libdemangle/blob/main/src/gnu_v2/cplus-dem.c#L419", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/rizinorg/rz-libdemangle/commit/51d016750e704b27ab8ace23c0f72acabca67018", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/rizinorg/rz-libdemangle/pull/54", "source": "security-advisories@github.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/rizinorg/rz-libdemangle/commit/51d016750e704b27ab8ace23c0f72acabca67018"}}