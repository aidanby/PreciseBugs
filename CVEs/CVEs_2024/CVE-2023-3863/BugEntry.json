{"buggy_code": ["/* SPDX-License-Identifier: GPL-2.0-or-later */\n/*\n * Copyright (C) 2011  Intel Corporation. All rights reserved.\n */\n\nenum llcp_state {\n\tLLCP_CONNECTED = 1, /* wait_for_packet() wants that */\n\tLLCP_CONNECTING,\n\tLLCP_CLOSED,\n\tLLCP_BOUND,\n\tLLCP_LISTEN,\n};\n\n#define LLCP_DEFAULT_LTO 100\n#define LLCP_DEFAULT_RW  1\n#define LLCP_DEFAULT_MIU 128\n\n#define LLCP_MAX_LTO  0xff\n#define LLCP_MAX_RW   15\n#define LLCP_MAX_MIUX 0x7ff\n#define LLCP_MAX_MIU (LLCP_MAX_MIUX + 128)\n\n#define LLCP_WKS_NUM_SAP   16\n#define LLCP_SDP_NUM_SAP   16\n#define LLCP_LOCAL_NUM_SAP 32\n#define LLCP_LOCAL_SAP_OFFSET (LLCP_WKS_NUM_SAP + LLCP_SDP_NUM_SAP)\n#define LLCP_MAX_SAP (LLCP_WKS_NUM_SAP + LLCP_SDP_NUM_SAP + LLCP_LOCAL_NUM_SAP)\n#define LLCP_SDP_UNBOUND   (LLCP_MAX_SAP + 1)\n\nstruct nfc_llcp_sock;\n\nstruct llcp_sock_list {\n\tstruct hlist_head head;\n\trwlock_t          lock;\n};\n\nstruct nfc_llcp_sdp_tlv {\n\tu8 *tlv;\n\tu8 tlv_len;\n\n\tchar *uri;\n\tu8 tid;\n\tu8 sap;\n\n\tunsigned long time;\n\n\tstruct hlist_node node;\n};\n\nstruct nfc_llcp_local {\n\tstruct list_head list;\n\tstruct nfc_dev *dev;\n\n\tstruct kref ref;\n\n\tstruct mutex sdp_lock;\n\n\tstruct timer_list link_timer;\n\tstruct sk_buff_head tx_queue;\n\tstruct work_struct\t tx_work;\n\tstruct work_struct\t rx_work;\n\tstruct sk_buff *rx_pending;\n\tstruct work_struct\t timeout_work;\n\n\tu32 target_idx;\n\tu8 rf_mode;\n\tu8 comm_mode;\n\tu8 lto;\n\tu8 rw;\n\t__be16 miux;\n\tunsigned long local_wks;      /* Well known services */\n\tunsigned long local_sdp;      /* Local services  */\n\tunsigned long local_sap; /* Local SAPs, not available for discovery */\n\tatomic_t local_sdp_cnt[LLCP_SDP_NUM_SAP];\n\n\t/* local */\n\tu8 gb[NFC_MAX_GT_LEN];\n\tu8 gb_len;\n\n\t/* remote */\n\tu8 remote_gb[NFC_MAX_GT_LEN];\n\tu8 remote_gb_len;\n\n\tu8  remote_version;\n\tu16 remote_miu;\n\tu16 remote_lto;\n\tu8  remote_opt;\n\tu16 remote_wks;\n\n\tstruct mutex sdreq_lock;\n\tstruct hlist_head pending_sdreqs;\n\tstruct timer_list sdreq_timer;\n\tstruct work_struct sdreq_timeout_work;\n\tu8 sdreq_next_tid;\n\n\t/* sockets array */\n\tstruct llcp_sock_list sockets;\n\tstruct llcp_sock_list connecting_sockets;\n\tstruct llcp_sock_list raw_sockets;\n};\n\nstruct nfc_llcp_sock {\n\tstruct sock sk;\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tu32 target_idx;\n\tu32 nfc_protocol;\n\n\t/* Link parameters */\n\tu8 ssap;\n\tu8 dsap;\n\tchar *service_name;\n\tsize_t service_name_len;\n\tu8 rw;\n\t__be16 miux;\n\n\n\t/* Remote link parameters */\n\tu8 remote_rw;\n\tu16 remote_miu;\n\n\t/* Link variables */\n\tu8 send_n;\n\tu8 send_ack_n;\n\tu8 recv_n;\n\tu8 recv_ack_n;\n\n\t/* Is the remote peer ready to receive */\n\tu8 remote_ready;\n\n\t/* Reserved source SAP */\n\tu8 reserved_ssap;\n\n\tstruct sk_buff_head tx_queue;\n\tstruct sk_buff_head tx_pending_queue;\n\n\tstruct list_head accept_queue;\n\tstruct sock *parent;\n};\n\nstruct nfc_llcp_ui_cb {\n\t__u8 dsap;\n\t__u8 ssap;\n};\n\n#define nfc_llcp_ui_skb_cb(__skb) ((struct nfc_llcp_ui_cb *)&((__skb)->cb[0]))\n\n#define nfc_llcp_sock(sk) ((struct nfc_llcp_sock *) (sk))\n#define nfc_llcp_dev(sk)  (nfc_llcp_sock((sk))->dev)\n\n#define LLCP_HEADER_SIZE   2\n#define LLCP_SEQUENCE_SIZE 1\n#define LLCP_AGF_PDU_HEADER_SIZE 2\n\n/* LLCP versions: 1.1 is 1.0 plus SDP */\n#define LLCP_VERSION_10 0x10\n#define LLCP_VERSION_11 0x11\n\n/* LLCP PDU types */\n#define LLCP_PDU_SYMM     0x0\n#define LLCP_PDU_PAX      0x1\n#define LLCP_PDU_AGF      0x2\n#define LLCP_PDU_UI       0x3\n#define LLCP_PDU_CONNECT  0x4\n#define LLCP_PDU_DISC     0x5\n#define LLCP_PDU_CC       0x6\n#define LLCP_PDU_DM       0x7\n#define LLCP_PDU_FRMR     0x8\n#define LLCP_PDU_SNL      0x9\n#define LLCP_PDU_I        0xc\n#define LLCP_PDU_RR       0xd\n#define LLCP_PDU_RNR      0xe\n\n/* Parameters TLV types */\n#define LLCP_TLV_VERSION 0x1\n#define LLCP_TLV_MIUX    0x2\n#define LLCP_TLV_WKS     0x3\n#define LLCP_TLV_LTO     0x4\n#define LLCP_TLV_RW      0x5\n#define LLCP_TLV_SN      0x6\n#define LLCP_TLV_OPT     0x7\n#define LLCP_TLV_SDREQ   0x8\n#define LLCP_TLV_SDRES   0x9\n#define LLCP_TLV_MAX     0xa\n\n/* Well known LLCP SAP */\n#define LLCP_SAP_SDP   0x1\n#define LLCP_SAP_IP    0x2\n#define LLCP_SAP_OBEX  0x3\n#define LLCP_SAP_SNEP  0x4\n#define LLCP_SAP_MAX   0xff\n\n/* Disconnection reason code */\n#define LLCP_DM_DISC    0x00\n#define LLCP_DM_NOCONN  0x01\n#define LLCP_DM_NOBOUND 0x02\n#define LLCP_DM_REJ     0x03\n\n\nvoid nfc_llcp_sock_link(struct llcp_sock_list *l, struct sock *s);\nvoid nfc_llcp_sock_unlink(struct llcp_sock_list *l, struct sock *s);\nvoid nfc_llcp_socket_remote_param_init(struct nfc_llcp_sock *sock);\nstruct nfc_llcp_local *nfc_llcp_find_local(struct nfc_dev *dev);\nstruct nfc_llcp_local *nfc_llcp_local_get(struct nfc_llcp_local *local);\nint nfc_llcp_local_put(struct nfc_llcp_local *local);\nu8 nfc_llcp_get_sdp_ssap(struct nfc_llcp_local *local,\n\t\t\t struct nfc_llcp_sock *sock);\nu8 nfc_llcp_get_local_ssap(struct nfc_llcp_local *local);\nvoid nfc_llcp_put_ssap(struct nfc_llcp_local *local, u8 ssap);\nint nfc_llcp_queue_i_frames(struct nfc_llcp_sock *sock);\nvoid nfc_llcp_send_to_raw_sock(struct nfc_llcp_local *local,\n\t\t\t       struct sk_buff *skb, u8 direction);\n\n/* Sock API */\nstruct sock *nfc_llcp_sock_alloc(struct socket *sock, int type, gfp_t gfp, int kern);\nvoid nfc_llcp_sock_free(struct nfc_llcp_sock *sock);\nvoid nfc_llcp_accept_unlink(struct sock *sk);\nvoid nfc_llcp_accept_enqueue(struct sock *parent, struct sock *sk);\nstruct sock *nfc_llcp_accept_dequeue(struct sock *sk, struct socket *newsock);\n\n/* TLV API */\nint nfc_llcp_parse_gb_tlv(struct nfc_llcp_local *local,\n\t\t\t  const u8 *tlv_array, u16 tlv_array_len);\nint nfc_llcp_parse_connection_tlv(struct nfc_llcp_sock *sock,\n\t\t\t\t  const u8 *tlv_array, u16 tlv_array_len);\n\n/* Commands API */\nvoid nfc_llcp_recv(void *data, struct sk_buff *skb, int err);\nu8 *nfc_llcp_build_tlv(u8 type, const u8 *value, u8 value_length, u8 *tlv_length);\nstruct nfc_llcp_sdp_tlv *nfc_llcp_build_sdres_tlv(u8 tid, u8 sap);\nstruct nfc_llcp_sdp_tlv *nfc_llcp_build_sdreq_tlv(u8 tid, const char *uri,\n\t\t\t\t\t\t  size_t uri_len);\nvoid nfc_llcp_free_sdp_tlv(struct nfc_llcp_sdp_tlv *sdp);\nvoid nfc_llcp_free_sdp_tlv_list(struct hlist_head *sdp_head);\nvoid nfc_llcp_recv(void *data, struct sk_buff *skb, int err);\nint nfc_llcp_send_symm(struct nfc_dev *dev);\nint nfc_llcp_send_connect(struct nfc_llcp_sock *sock);\nint nfc_llcp_send_cc(struct nfc_llcp_sock *sock);\nint nfc_llcp_send_snl_sdres(struct nfc_llcp_local *local,\n\t\t\t    struct hlist_head *tlv_list, size_t tlvs_len);\nint nfc_llcp_send_snl_sdreq(struct nfc_llcp_local *local,\n\t\t\t    struct hlist_head *tlv_list, size_t tlvs_len);\nint nfc_llcp_send_dm(struct nfc_llcp_local *local, u8 ssap, u8 dsap, u8 reason);\nint nfc_llcp_send_disconnect(struct nfc_llcp_sock *sock);\nint nfc_llcp_send_i_frame(struct nfc_llcp_sock *sock,\n\t\t\t  struct msghdr *msg, size_t len);\nint nfc_llcp_send_ui_frame(struct nfc_llcp_sock *sock, u8 ssap, u8 dsap,\n\t\t\t   struct msghdr *msg, size_t len);\nint nfc_llcp_send_rr(struct nfc_llcp_sock *sock);\n\n/* Socket API */\nint __init nfc_llcp_sock_init(void);\nvoid nfc_llcp_sock_exit(void);\n", "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Copyright (C) 2011  Intel Corporation. All rights reserved.\n */\n\n#define pr_fmt(fmt) \"llcp: %s: \" fmt, __func__\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/nfc.h>\n\n#include <net/nfc/nfc.h>\n\n#include \"nfc.h\"\n#include \"llcp.h\"\n\nstatic const u8 llcp_tlv_length[LLCP_TLV_MAX] = {\n\t0,\n\t1, /* VERSION */\n\t2, /* MIUX */\n\t2, /* WKS */\n\t1, /* LTO */\n\t1, /* RW */\n\t0, /* SN */\n\t1, /* OPT */\n\t0, /* SDREQ */\n\t2, /* SDRES */\n\n};\n\nstatic u8 llcp_tlv8(const u8 *tlv, u8 type)\n{\n\tif (tlv[0] != type || tlv[1] != llcp_tlv_length[tlv[0]])\n\t\treturn 0;\n\n\treturn tlv[2];\n}\n\nstatic u16 llcp_tlv16(const u8 *tlv, u8 type)\n{\n\tif (tlv[0] != type || tlv[1] != llcp_tlv_length[tlv[0]])\n\t\treturn 0;\n\n\treturn be16_to_cpu(*((__be16 *)(tlv + 2)));\n}\n\n\nstatic u8 llcp_tlv_version(const u8 *tlv)\n{\n\treturn llcp_tlv8(tlv, LLCP_TLV_VERSION);\n}\n\nstatic u16 llcp_tlv_miux(const u8 *tlv)\n{\n\treturn llcp_tlv16(tlv, LLCP_TLV_MIUX) & 0x7ff;\n}\n\nstatic u16 llcp_tlv_wks(const u8 *tlv)\n{\n\treturn llcp_tlv16(tlv, LLCP_TLV_WKS);\n}\n\nstatic u16 llcp_tlv_lto(const u8 *tlv)\n{\n\treturn llcp_tlv8(tlv, LLCP_TLV_LTO);\n}\n\nstatic u8 llcp_tlv_opt(const u8 *tlv)\n{\n\treturn llcp_tlv8(tlv, LLCP_TLV_OPT);\n}\n\nstatic u8 llcp_tlv_rw(const u8 *tlv)\n{\n\treturn llcp_tlv8(tlv, LLCP_TLV_RW) & 0xf;\n}\n\nu8 *nfc_llcp_build_tlv(u8 type, const u8 *value, u8 value_length, u8 *tlv_length)\n{\n\tu8 *tlv, length;\n\n\tpr_debug(\"type %d\\n\", type);\n\n\tif (type >= LLCP_TLV_MAX)\n\t\treturn NULL;\n\n\tlength = llcp_tlv_length[type];\n\tif (length == 0 && value_length == 0)\n\t\treturn NULL;\n\telse if (length == 0)\n\t\tlength = value_length;\n\n\t*tlv_length = 2 + length;\n\ttlv = kzalloc(2 + length, GFP_KERNEL);\n\tif (tlv == NULL)\n\t\treturn tlv;\n\n\ttlv[0] = type;\n\ttlv[1] = length;\n\tmemcpy(tlv + 2, value, length);\n\n\treturn tlv;\n}\n\nstruct nfc_llcp_sdp_tlv *nfc_llcp_build_sdres_tlv(u8 tid, u8 sap)\n{\n\tstruct nfc_llcp_sdp_tlv *sdres;\n\tu8 value[2];\n\n\tsdres = kzalloc(sizeof(struct nfc_llcp_sdp_tlv), GFP_KERNEL);\n\tif (sdres == NULL)\n\t\treturn NULL;\n\n\tvalue[0] = tid;\n\tvalue[1] = sap;\n\n\tsdres->tlv = nfc_llcp_build_tlv(LLCP_TLV_SDRES, value, 2,\n\t\t\t\t\t&sdres->tlv_len);\n\tif (sdres->tlv == NULL) {\n\t\tkfree(sdres);\n\t\treturn NULL;\n\t}\n\n\tsdres->tid = tid;\n\tsdres->sap = sap;\n\n\tINIT_HLIST_NODE(&sdres->node);\n\n\treturn sdres;\n}\n\nstruct nfc_llcp_sdp_tlv *nfc_llcp_build_sdreq_tlv(u8 tid, const char *uri,\n\t\t\t\t\t\t  size_t uri_len)\n{\n\tstruct nfc_llcp_sdp_tlv *sdreq;\n\n\tpr_debug(\"uri: %s, len: %zu\\n\", uri, uri_len);\n\n\t/* sdreq->tlv_len is u8, takes uri_len, + 3 for header, + 1 for NULL */\n\tif (WARN_ON_ONCE(uri_len > U8_MAX - 4))\n\t\treturn NULL;\n\n\tsdreq = kzalloc(sizeof(struct nfc_llcp_sdp_tlv), GFP_KERNEL);\n\tif (sdreq == NULL)\n\t\treturn NULL;\n\n\tsdreq->tlv_len = uri_len + 3;\n\n\tif (uri[uri_len - 1] == 0)\n\t\tsdreq->tlv_len--;\n\n\tsdreq->tlv = kzalloc(sdreq->tlv_len + 1, GFP_KERNEL);\n\tif (sdreq->tlv == NULL) {\n\t\tkfree(sdreq);\n\t\treturn NULL;\n\t}\n\n\tsdreq->tlv[0] = LLCP_TLV_SDREQ;\n\tsdreq->tlv[1] = sdreq->tlv_len - 2;\n\tsdreq->tlv[2] = tid;\n\n\tsdreq->tid = tid;\n\tsdreq->uri = sdreq->tlv + 3;\n\tmemcpy(sdreq->uri, uri, uri_len);\n\n\tsdreq->time = jiffies;\n\n\tINIT_HLIST_NODE(&sdreq->node);\n\n\treturn sdreq;\n}\n\nvoid nfc_llcp_free_sdp_tlv(struct nfc_llcp_sdp_tlv *sdp)\n{\n\tkfree(sdp->tlv);\n\tkfree(sdp);\n}\n\nvoid nfc_llcp_free_sdp_tlv_list(struct hlist_head *head)\n{\n\tstruct nfc_llcp_sdp_tlv *sdp;\n\tstruct hlist_node *n;\n\n\thlist_for_each_entry_safe(sdp, n, head, node) {\n\t\thlist_del(&sdp->node);\n\n\t\tnfc_llcp_free_sdp_tlv(sdp);\n\t}\n}\n\nint nfc_llcp_parse_gb_tlv(struct nfc_llcp_local *local,\n\t\t\t  const u8 *tlv_array, u16 tlv_array_len)\n{\n\tconst u8 *tlv = tlv_array;\n\tu8 type, length, offset = 0;\n\n\tpr_debug(\"TLV array length %d\\n\", tlv_array_len);\n\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\twhile (offset < tlv_array_len) {\n\t\ttype = tlv[0];\n\t\tlength = tlv[1];\n\n\t\tpr_debug(\"type 0x%x length %d\\n\", type, length);\n\n\t\tswitch (type) {\n\t\tcase LLCP_TLV_VERSION:\n\t\t\tlocal->remote_version = llcp_tlv_version(tlv);\n\t\t\tbreak;\n\t\tcase LLCP_TLV_MIUX:\n\t\t\tlocal->remote_miu = llcp_tlv_miux(tlv) + 128;\n\t\t\tbreak;\n\t\tcase LLCP_TLV_WKS:\n\t\t\tlocal->remote_wks = llcp_tlv_wks(tlv);\n\t\t\tbreak;\n\t\tcase LLCP_TLV_LTO:\n\t\t\tlocal->remote_lto = llcp_tlv_lto(tlv) * 10;\n\t\t\tbreak;\n\t\tcase LLCP_TLV_OPT:\n\t\t\tlocal->remote_opt = llcp_tlv_opt(tlv);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Invalid gt tlv value 0x%x\\n\", type);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset += length + 2;\n\t\ttlv += length + 2;\n\t}\n\n\tpr_debug(\"version 0x%x miu %d lto %d opt 0x%x wks 0x%x\\n\",\n\t\t local->remote_version, local->remote_miu,\n\t\t local->remote_lto, local->remote_opt,\n\t\t local->remote_wks);\n\n\treturn 0;\n}\n\nint nfc_llcp_parse_connection_tlv(struct nfc_llcp_sock *sock,\n\t\t\t\t  const u8 *tlv_array, u16 tlv_array_len)\n{\n\tconst u8 *tlv = tlv_array;\n\tu8 type, length, offset = 0;\n\n\tpr_debug(\"TLV array length %d\\n\", tlv_array_len);\n\n\tif (sock == NULL)\n\t\treturn -ENOTCONN;\n\n\twhile (offset < tlv_array_len) {\n\t\ttype = tlv[0];\n\t\tlength = tlv[1];\n\n\t\tpr_debug(\"type 0x%x length %d\\n\", type, length);\n\n\t\tswitch (type) {\n\t\tcase LLCP_TLV_MIUX:\n\t\t\tsock->remote_miu = llcp_tlv_miux(tlv) + 128;\n\t\t\tbreak;\n\t\tcase LLCP_TLV_RW:\n\t\t\tsock->remote_rw = llcp_tlv_rw(tlv);\n\t\t\tbreak;\n\t\tcase LLCP_TLV_SN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Invalid gt tlv value 0x%x\\n\", type);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset += length + 2;\n\t\ttlv += length + 2;\n\t}\n\n\tpr_debug(\"sock %p rw %d miu %d\\n\", sock,\n\t\t sock->remote_rw, sock->remote_miu);\n\n\treturn 0;\n}\n\nstatic struct sk_buff *llcp_add_header(struct sk_buff *pdu,\n\t\t\t\t       u8 dsap, u8 ssap, u8 ptype)\n{\n\tu8 header[2];\n\n\tpr_debug(\"ptype 0x%x dsap 0x%x ssap 0x%x\\n\", ptype, dsap, ssap);\n\n\theader[0] = (u8)((dsap << 2) | (ptype >> 2));\n\theader[1] = (u8)((ptype << 6) | ssap);\n\n\tpr_debug(\"header 0x%x 0x%x\\n\", header[0], header[1]);\n\n\tskb_put_data(pdu, header, LLCP_HEADER_SIZE);\n\n\treturn pdu;\n}\n\nstatic struct sk_buff *llcp_add_tlv(struct sk_buff *pdu, const u8 *tlv,\n\t\t\t\t    u8 tlv_length)\n{\n\t/* XXX Add an skb length check */\n\n\tif (tlv == NULL)\n\t\treturn NULL;\n\n\tskb_put_data(pdu, tlv, tlv_length);\n\n\treturn pdu;\n}\n\nstatic struct sk_buff *llcp_allocate_pdu(struct nfc_llcp_sock *sock,\n\t\t\t\t\t u8 cmd, u16 size)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tif (sock->ssap == 0)\n\t\treturn NULL;\n\n\tskb = nfc_alloc_send_skb(sock->dev, &sock->sk, MSG_DONTWAIT,\n\t\t\t\t size + LLCP_HEADER_SIZE, &err);\n\tif (skb == NULL) {\n\t\tpr_err(\"Could not allocate PDU\\n\");\n\t\treturn NULL;\n\t}\n\n\tskb = llcp_add_header(skb, sock->dsap, sock->ssap, cmd);\n\n\treturn skb;\n}\n\nint nfc_llcp_send_disconnect(struct nfc_llcp_sock *sock)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tdev = sock->dev;\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_DISC, 0);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\treturn 0;\n}\n\nint nfc_llcp_send_symm(struct nfc_dev *dev)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_llcp_local *local;\n\tu16 size = 0;\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tsize += LLCP_HEADER_SIZE;\n\tsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\n\tskb = llcp_add_header(skb, 0, 0, LLCP_PDU_SYMM);\n\n\t__net_timestamp(skb);\n\n\tnfc_llcp_send_to_raw_sock(local, skb, NFC_DIRECTION_TX);\n\n\treturn nfc_data_exchange(dev, local->target_idx, skb,\n\t\t\t\t nfc_llcp_recv, local);\n}\n\nint nfc_llcp_send_connect(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sk_buff *skb;\n\tconst u8 *service_name_tlv = NULL;\n\tconst u8 *miux_tlv = NULL;\n\tconst u8 *rw_tlv = NULL;\n\tu8 service_name_tlv_length, miux_tlv_length,  rw_tlv_length, rw;\n\tint err;\n\tu16 size = 0;\n\t__be16 miux;\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tif (sock->service_name != NULL) {\n\t\tservice_name_tlv = nfc_llcp_build_tlv(LLCP_TLV_SN,\n\t\t\t\t\t\t      sock->service_name,\n\t\t\t\t\t\t      sock->service_name_len,\n\t\t\t\t\t\t      &service_name_tlv_length);\n\t\tif (!service_name_tlv) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error_tlv;\n\t\t}\n\t\tsize += service_name_tlv_length;\n\t}\n\n\t/* If the socket parameters are not set, use the local ones */\n\tmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\n\t\tlocal->miux : sock->miux;\n\trw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\n\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n\t\t\t\t      &miux_tlv_length);\n\tif (!miux_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += miux_tlv_length;\n\n\trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n\tif (!rw_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += rw_tlv_length;\n\n\tpr_debug(\"SKB size %d SN length %zu\\n\", size, sock->service_name_len);\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_CONNECT, size);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\n\tllcp_add_tlv(skb, service_name_tlv, service_name_tlv_length);\n\tllcp_add_tlv(skb, miux_tlv, miux_tlv_length);\n\tllcp_add_tlv(skb, rw_tlv, rw_tlv_length);\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\terr = 0;\n\nerror_tlv:\n\tif (err)\n\t\tpr_err(\"error %d\\n\", err);\n\n\tkfree(service_name_tlv);\n\tkfree(miux_tlv);\n\tkfree(rw_tlv);\n\n\treturn err;\n}\n\nint nfc_llcp_send_cc(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sk_buff *skb;\n\tconst u8 *miux_tlv = NULL;\n\tconst u8 *rw_tlv = NULL;\n\tu8 miux_tlv_length, rw_tlv_length, rw;\n\tint err;\n\tu16 size = 0;\n\t__be16 miux;\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\t/* If the socket parameters are not set, use the local ones */\n\tmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\n\t\tlocal->miux : sock->miux;\n\trw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\n\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n\t\t\t\t      &miux_tlv_length);\n\tif (!miux_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += miux_tlv_length;\n\n\trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n\tif (!rw_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += rw_tlv_length;\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\n\tllcp_add_tlv(skb, miux_tlv, miux_tlv_length);\n\tllcp_add_tlv(skb, rw_tlv, rw_tlv_length);\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\terr = 0;\n\nerror_tlv:\n\tif (err)\n\t\tpr_err(\"error %d\\n\", err);\n\n\tkfree(miux_tlv);\n\tkfree(rw_tlv);\n\n\treturn err;\n}\n\nstatic struct sk_buff *nfc_llcp_allocate_snl(struct nfc_llcp_local *local,\n\t\t\t\t\t     size_t tlv_length)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_dev *dev;\n\tu16 size = 0;\n\n\tif (local == NULL)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tdev = local->dev;\n\tif (dev == NULL)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tsize += LLCP_HEADER_SIZE;\n\tsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\tsize += tlv_length;\n\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\n\tskb = llcp_add_header(skb, LLCP_SAP_SDP, LLCP_SAP_SDP, LLCP_PDU_SNL);\n\n\treturn skb;\n}\n\nint nfc_llcp_send_snl_sdres(struct nfc_llcp_local *local,\n\t\t\t    struct hlist_head *tlv_list, size_t tlvs_len)\n{\n\tstruct nfc_llcp_sdp_tlv *sdp;\n\tstruct hlist_node *n;\n\tstruct sk_buff *skb;\n\n\tskb = nfc_llcp_allocate_snl(local, tlvs_len);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\thlist_for_each_entry_safe(sdp, n, tlv_list, node) {\n\t\tskb_put_data(skb, sdp->tlv, sdp->tlv_len);\n\n\t\thlist_del(&sdp->node);\n\n\t\tnfc_llcp_free_sdp_tlv(sdp);\n\t}\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\treturn 0;\n}\n\nint nfc_llcp_send_snl_sdreq(struct nfc_llcp_local *local,\n\t\t\t    struct hlist_head *tlv_list, size_t tlvs_len)\n{\n\tstruct nfc_llcp_sdp_tlv *sdreq;\n\tstruct hlist_node *n;\n\tstruct sk_buff *skb;\n\n\tskb = nfc_llcp_allocate_snl(local, tlvs_len);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tmutex_lock(&local->sdreq_lock);\n\n\tif (hlist_empty(&local->pending_sdreqs))\n\t\tmod_timer(&local->sdreq_timer,\n\t\t\t  jiffies + msecs_to_jiffies(3 * local->remote_lto));\n\n\thlist_for_each_entry_safe(sdreq, n, tlv_list, node) {\n\t\tpr_debug(\"tid %d for %s\\n\", sdreq->tid, sdreq->uri);\n\n\t\tskb_put_data(skb, sdreq->tlv, sdreq->tlv_len);\n\n\t\thlist_del(&sdreq->node);\n\n\t\thlist_add_head(&sdreq->node, &local->pending_sdreqs);\n\t}\n\n\tmutex_unlock(&local->sdreq_lock);\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\treturn 0;\n}\n\nint nfc_llcp_send_dm(struct nfc_llcp_local *local, u8 ssap, u8 dsap, u8 reason)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_dev *dev;\n\tu16 size = 1; /* Reason code */\n\n\tpr_debug(\"Sending DM reason 0x%x\\n\", reason);\n\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tdev = local->dev;\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\tsize += LLCP_HEADER_SIZE;\n\tsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\n\tskb = llcp_add_header(skb, dsap, ssap, LLCP_PDU_DM);\n\n\tskb_put_data(skb, &reason, 1);\n\n\tskb_queue_head(&local->tx_queue, skb);\n\n\treturn 0;\n}\n\nint nfc_llcp_send_i_frame(struct nfc_llcp_sock *sock,\n\t\t\t  struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *pdu;\n\tstruct sock *sk = &sock->sk;\n\tstruct nfc_llcp_local *local;\n\tsize_t frag_len = 0, remaining_len;\n\tu8 *msg_data, *msg_ptr;\n\tu16 remote_miu;\n\n\tpr_debug(\"Send I frame len %zd\\n\", len);\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\t/* Remote is ready but has not acknowledged our frames */\n\tif((sock->remote_ready &&\n\t    skb_queue_len(&sock->tx_pending_queue) >= sock->remote_rw &&\n\t    skb_queue_len(&sock->tx_queue) >= 2 * sock->remote_rw)) {\n\t\tpr_err(\"Pending queue is full %d frames\\n\",\n\t\t       skb_queue_len(&sock->tx_pending_queue));\n\t\treturn -ENOBUFS;\n\t}\n\n\t/* Remote is not ready and we've been queueing enough frames */\n\tif ((!sock->remote_ready &&\n\t     skb_queue_len(&sock->tx_queue) >= 2 * sock->remote_rw)) {\n\t\tpr_err(\"Tx queue is full %d frames\\n\",\n\t\t       skb_queue_len(&sock->tx_queue));\n\t\treturn -ENOBUFS;\n\t}\n\n\tmsg_data = kmalloc(len, GFP_USER | __GFP_NOWARN);\n\tif (msg_data == NULL)\n\t\treturn -ENOMEM;\n\n\tif (memcpy_from_msg(msg_data, msg, len)) {\n\t\tkfree(msg_data);\n\t\treturn -EFAULT;\n\t}\n\n\tremaining_len = len;\n\tmsg_ptr = msg_data;\n\n\tdo {\n\t\tremote_miu = sock->remote_miu > LLCP_MAX_MIU ?\n\t\t\t\tLLCP_DEFAULT_MIU : sock->remote_miu;\n\n\t\tfrag_len = min_t(size_t, remote_miu, remaining_len);\n\n\t\tpr_debug(\"Fragment %zd bytes remaining %zd\",\n\t\t\t frag_len, remaining_len);\n\n\t\tpdu = llcp_allocate_pdu(sock, LLCP_PDU_I,\n\t\t\t\t\tfrag_len + LLCP_SEQUENCE_SIZE);\n\t\tif (pdu == NULL) {\n\t\t\tkfree(msg_data);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tskb_put(pdu, LLCP_SEQUENCE_SIZE);\n\n\t\tif (likely(frag_len > 0))\n\t\t\tskb_put_data(pdu, msg_ptr, frag_len);\n\n\t\tskb_queue_tail(&sock->tx_queue, pdu);\n\n\t\tlock_sock(sk);\n\n\t\tnfc_llcp_queue_i_frames(sock);\n\n\t\trelease_sock(sk);\n\n\t\tremaining_len -= frag_len;\n\t\tmsg_ptr += frag_len;\n\t} while (remaining_len > 0);\n\n\tkfree(msg_data);\n\n\treturn len;\n}\n\nint nfc_llcp_send_ui_frame(struct nfc_llcp_sock *sock, u8 ssap, u8 dsap,\n\t\t\t   struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *pdu;\n\tstruct nfc_llcp_local *local;\n\tsize_t frag_len = 0, remaining_len;\n\tu8 *msg_ptr, *msg_data;\n\tu16 remote_miu;\n\tint err;\n\n\tpr_debug(\"Send UI frame len %zd\\n\", len);\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tmsg_data = kmalloc(len, GFP_USER | __GFP_NOWARN);\n\tif (msg_data == NULL)\n\t\treturn -ENOMEM;\n\n\tif (memcpy_from_msg(msg_data, msg, len)) {\n\t\tkfree(msg_data);\n\t\treturn -EFAULT;\n\t}\n\n\tremaining_len = len;\n\tmsg_ptr = msg_data;\n\n\tdo {\n\t\tremote_miu = sock->remote_miu > LLCP_MAX_MIU ?\n\t\t\t\tlocal->remote_miu : sock->remote_miu;\n\n\t\tfrag_len = min_t(size_t, remote_miu, remaining_len);\n\n\t\tpr_debug(\"Fragment %zd bytes remaining %zd\",\n\t\t\t frag_len, remaining_len);\n\n\t\tpdu = nfc_alloc_send_skb(sock->dev, &sock->sk, 0,\n\t\t\t\t\t frag_len + LLCP_HEADER_SIZE, &err);\n\t\tif (pdu == NULL) {\n\t\t\tpr_err(\"Could not allocate PDU (error=%d)\\n\", err);\n\t\t\tlen -= remaining_len;\n\t\t\tif (len == 0)\n\t\t\t\tlen = err;\n\t\t\tbreak;\n\t\t}\n\n\t\tpdu = llcp_add_header(pdu, dsap, ssap, LLCP_PDU_UI);\n\n\t\tif (likely(frag_len > 0))\n\t\t\tskb_put_data(pdu, msg_ptr, frag_len);\n\n\t\t/* No need to check for the peer RW for UI frames */\n\t\tskb_queue_tail(&local->tx_queue, pdu);\n\n\t\tremaining_len -= frag_len;\n\t\tmsg_ptr += frag_len;\n\t} while (remaining_len > 0);\n\n\tkfree(msg_data);\n\n\treturn len;\n}\n\nint nfc_llcp_send_rr(struct nfc_llcp_sock *sock)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_llcp_local *local;\n\n\tpr_debug(\"Send rr nr %d\\n\", sock->recv_n);\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_RR, LLCP_SEQUENCE_SIZE);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tskb_put(skb, LLCP_SEQUENCE_SIZE);\n\n\tskb->data[2] = sock->recv_n;\n\n\tskb_queue_head(&local->tx_queue, skb);\n\n\treturn 0;\n}\n", "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Copyright (C) 2011  Intel Corporation. All rights reserved.\n * Copyright (C) 2014 Marvell International Ltd.\n */\n\n#define pr_fmt(fmt) \"llcp: %s: \" fmt, __func__\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/nfc.h>\n\n#include \"nfc.h\"\n#include \"llcp.h\"\n\nstatic u8 llcp_magic[3] = {0x46, 0x66, 0x6d};\n\nstatic LIST_HEAD(llcp_devices);\n\nstatic void nfc_llcp_rx_skb(struct nfc_llcp_local *local, struct sk_buff *skb);\n\nvoid nfc_llcp_sock_link(struct llcp_sock_list *l, struct sock *sk)\n{\n\twrite_lock(&l->lock);\n\tsk_add_node(sk, &l->head);\n\twrite_unlock(&l->lock);\n}\n\nvoid nfc_llcp_sock_unlink(struct llcp_sock_list *l, struct sock *sk)\n{\n\twrite_lock(&l->lock);\n\tsk_del_node_init(sk);\n\twrite_unlock(&l->lock);\n}\n\nvoid nfc_llcp_socket_remote_param_init(struct nfc_llcp_sock *sock)\n{\n\tsock->remote_rw = LLCP_DEFAULT_RW;\n\tsock->remote_miu = LLCP_MAX_MIU + 1;\n}\n\nstatic void nfc_llcp_socket_purge(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local = sock->local;\n\tstruct sk_buff *s, *tmp;\n\n\tskb_queue_purge(&sock->tx_queue);\n\tskb_queue_purge(&sock->tx_pending_queue);\n\n\tif (local == NULL)\n\t\treturn;\n\n\t/* Search for local pending SKBs that are related to this socket */\n\tskb_queue_walk_safe(&local->tx_queue, s, tmp) {\n\t\tif (s->sk != &sock->sk)\n\t\t\tcontinue;\n\n\t\tskb_unlink(s, &local->tx_queue);\n\t\tkfree_skb(s);\n\t}\n}\n\nstatic void nfc_llcp_socket_release(struct nfc_llcp_local *local, bool device,\n\t\t\t\t    int err)\n{\n\tstruct sock *sk;\n\tstruct hlist_node *tmp;\n\tstruct nfc_llcp_sock *llcp_sock;\n\n\tskb_queue_purge(&local->tx_queue);\n\n\twrite_lock(&local->sockets.lock);\n\n\tsk_for_each_safe(sk, tmp, &local->sockets.head) {\n\t\tllcp_sock = nfc_llcp_sock(sk);\n\n\t\tbh_lock_sock(sk);\n\n\t\tnfc_llcp_socket_purge(llcp_sock);\n\n\t\tif (sk->sk_state == LLCP_CONNECTED)\n\t\t\tnfc_put_device(llcp_sock->dev);\n\n\t\tif (sk->sk_state == LLCP_LISTEN) {\n\t\t\tstruct nfc_llcp_sock *lsk, *n;\n\t\t\tstruct sock *accept_sk;\n\n\t\t\tlist_for_each_entry_safe(lsk, n,\n\t\t\t\t\t\t &llcp_sock->accept_queue,\n\t\t\t\t\t\t accept_queue) {\n\t\t\t\taccept_sk = &lsk->sk;\n\t\t\t\tbh_lock_sock(accept_sk);\n\n\t\t\t\tnfc_llcp_accept_unlink(accept_sk);\n\n\t\t\t\tif (err)\n\t\t\t\t\taccept_sk->sk_err = err;\n\t\t\t\taccept_sk->sk_state = LLCP_CLOSED;\n\t\t\t\taccept_sk->sk_state_change(sk);\n\n\t\t\t\tbh_unlock_sock(accept_sk);\n\t\t\t}\n\t\t}\n\n\t\tif (err)\n\t\t\tsk->sk_err = err;\n\t\tsk->sk_state = LLCP_CLOSED;\n\t\tsk->sk_state_change(sk);\n\n\t\tbh_unlock_sock(sk);\n\n\t\tsk_del_node_init(sk);\n\t}\n\n\twrite_unlock(&local->sockets.lock);\n\n\t/* If we still have a device, we keep the RAW sockets alive */\n\tif (device == true)\n\t\treturn;\n\n\twrite_lock(&local->raw_sockets.lock);\n\n\tsk_for_each_safe(sk, tmp, &local->raw_sockets.head) {\n\t\tllcp_sock = nfc_llcp_sock(sk);\n\n\t\tbh_lock_sock(sk);\n\n\t\tnfc_llcp_socket_purge(llcp_sock);\n\n\t\tif (err)\n\t\t\tsk->sk_err = err;\n\t\tsk->sk_state = LLCP_CLOSED;\n\t\tsk->sk_state_change(sk);\n\n\t\tbh_unlock_sock(sk);\n\n\t\tsk_del_node_init(sk);\n\t}\n\n\twrite_unlock(&local->raw_sockets.lock);\n}\n\nstruct nfc_llcp_local *nfc_llcp_local_get(struct nfc_llcp_local *local)\n{\n\tkref_get(&local->ref);\n\n\treturn local;\n}\n\nstatic void local_cleanup(struct nfc_llcp_local *local)\n{\n\tnfc_llcp_socket_release(local, false, ENXIO);\n\tdel_timer_sync(&local->link_timer);\n\tskb_queue_purge(&local->tx_queue);\n\tcancel_work_sync(&local->tx_work);\n\tcancel_work_sync(&local->rx_work);\n\tcancel_work_sync(&local->timeout_work);\n\tkfree_skb(local->rx_pending);\n\tlocal->rx_pending = NULL;\n\tdel_timer_sync(&local->sdreq_timer);\n\tcancel_work_sync(&local->sdreq_timeout_work);\n\tnfc_llcp_free_sdp_tlv_list(&local->pending_sdreqs);\n}\n\nstatic void local_release(struct kref *ref)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = container_of(ref, struct nfc_llcp_local, ref);\n\n\tlist_del(&local->list);\n\tlocal_cleanup(local);\n\tkfree(local);\n}\n\nint nfc_llcp_local_put(struct nfc_llcp_local *local)\n{\n\tif (local == NULL)\n\t\treturn 0;\n\n\treturn kref_put(&local->ref, local_release);\n}\n\nstatic struct nfc_llcp_sock *nfc_llcp_sock_get(struct nfc_llcp_local *local,\n\t\t\t\t\t       u8 ssap, u8 dsap)\n{\n\tstruct sock *sk;\n\tstruct nfc_llcp_sock *llcp_sock, *tmp_sock;\n\n\tpr_debug(\"ssap dsap %d %d\\n\", ssap, dsap);\n\n\tif (ssap == 0 && dsap == 0)\n\t\treturn NULL;\n\n\tread_lock(&local->sockets.lock);\n\n\tllcp_sock = NULL;\n\n\tsk_for_each(sk, &local->sockets.head) {\n\t\ttmp_sock = nfc_llcp_sock(sk);\n\n\t\tif (tmp_sock->ssap == ssap && tmp_sock->dsap == dsap) {\n\t\t\tllcp_sock = tmp_sock;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tread_unlock(&local->sockets.lock);\n\n\tif (llcp_sock == NULL)\n\t\treturn NULL;\n\n\tsock_hold(&llcp_sock->sk);\n\n\treturn llcp_sock;\n}\n\nstatic void nfc_llcp_sock_put(struct nfc_llcp_sock *sock)\n{\n\tsock_put(&sock->sk);\n}\n\nstatic void nfc_llcp_timeout_work(struct work_struct *work)\n{\n\tstruct nfc_llcp_local *local = container_of(work, struct nfc_llcp_local,\n\t\t\t\t\t\t    timeout_work);\n\n\tnfc_dep_link_down(local->dev);\n}\n\nstatic void nfc_llcp_symm_timer(struct timer_list *t)\n{\n\tstruct nfc_llcp_local *local = from_timer(local, t, link_timer);\n\n\tpr_err(\"SYMM timeout\\n\");\n\n\tschedule_work(&local->timeout_work);\n}\n\nstatic void nfc_llcp_sdreq_timeout_work(struct work_struct *work)\n{\n\tunsigned long time;\n\tHLIST_HEAD(nl_sdres_list);\n\tstruct hlist_node *n;\n\tstruct nfc_llcp_sdp_tlv *sdp;\n\tstruct nfc_llcp_local *local = container_of(work, struct nfc_llcp_local,\n\t\t\t\t\t\t    sdreq_timeout_work);\n\n\tmutex_lock(&local->sdreq_lock);\n\n\ttime = jiffies - msecs_to_jiffies(3 * local->remote_lto);\n\n\thlist_for_each_entry_safe(sdp, n, &local->pending_sdreqs, node) {\n\t\tif (time_after(sdp->time, time))\n\t\t\tcontinue;\n\n\t\tsdp->sap = LLCP_SDP_UNBOUND;\n\n\t\thlist_del(&sdp->node);\n\n\t\thlist_add_head(&sdp->node, &nl_sdres_list);\n\t}\n\n\tif (!hlist_empty(&local->pending_sdreqs))\n\t\tmod_timer(&local->sdreq_timer,\n\t\t\t  jiffies + msecs_to_jiffies(3 * local->remote_lto));\n\n\tmutex_unlock(&local->sdreq_lock);\n\n\tif (!hlist_empty(&nl_sdres_list))\n\t\tnfc_genl_llc_send_sdres(local->dev, &nl_sdres_list);\n}\n\nstatic void nfc_llcp_sdreq_timer(struct timer_list *t)\n{\n\tstruct nfc_llcp_local *local = from_timer(local, t, sdreq_timer);\n\n\tschedule_work(&local->sdreq_timeout_work);\n}\n\nstruct nfc_llcp_local *nfc_llcp_find_local(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlist_for_each_entry(local, &llcp_devices, list)\n\t\tif (local->dev == dev)\n\t\t\treturn local;\n\n\tpr_debug(\"No device found\\n\");\n\n\treturn NULL;\n}\n\nstatic char *wks[] = {\n\tNULL,\n\tNULL, /* SDP */\n\t\"urn:nfc:sn:ip\",\n\t\"urn:nfc:sn:obex\",\n\t\"urn:nfc:sn:snep\",\n};\n\nstatic int nfc_llcp_wks_sap(const char *service_name, size_t service_name_len)\n{\n\tint sap, num_wks;\n\n\tpr_debug(\"%s\\n\", service_name);\n\n\tif (service_name == NULL)\n\t\treturn -EINVAL;\n\n\tnum_wks = ARRAY_SIZE(wks);\n\n\tfor (sap = 0; sap < num_wks; sap++) {\n\t\tif (wks[sap] == NULL)\n\t\t\tcontinue;\n\n\t\tif (strncmp(wks[sap], service_name, service_name_len) == 0)\n\t\t\treturn sap;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic\nstruct nfc_llcp_sock *nfc_llcp_sock_from_sn(struct nfc_llcp_local *local,\n\t\t\t\t\t    const u8 *sn, size_t sn_len)\n{\n\tstruct sock *sk;\n\tstruct nfc_llcp_sock *llcp_sock, *tmp_sock;\n\n\tpr_debug(\"sn %zd %p\\n\", sn_len, sn);\n\n\tif (sn == NULL || sn_len == 0)\n\t\treturn NULL;\n\n\tread_lock(&local->sockets.lock);\n\n\tllcp_sock = NULL;\n\n\tsk_for_each(sk, &local->sockets.head) {\n\t\ttmp_sock = nfc_llcp_sock(sk);\n\n\t\tpr_debug(\"llcp sock %p\\n\", tmp_sock);\n\n\t\tif (tmp_sock->sk.sk_type == SOCK_STREAM &&\n\t\t    tmp_sock->sk.sk_state != LLCP_LISTEN)\n\t\t\tcontinue;\n\n\t\tif (tmp_sock->sk.sk_type == SOCK_DGRAM &&\n\t\t    tmp_sock->sk.sk_state != LLCP_BOUND)\n\t\t\tcontinue;\n\n\t\tif (tmp_sock->service_name == NULL ||\n\t\t    tmp_sock->service_name_len == 0)\n\t\t\tcontinue;\n\n\t\tif (tmp_sock->service_name_len != sn_len)\n\t\t\tcontinue;\n\n\t\tif (memcmp(sn, tmp_sock->service_name, sn_len) == 0) {\n\t\t\tllcp_sock = tmp_sock;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tread_unlock(&local->sockets.lock);\n\n\tpr_debug(\"Found llcp sock %p\\n\", llcp_sock);\n\n\treturn llcp_sock;\n}\n\nu8 nfc_llcp_get_sdp_ssap(struct nfc_llcp_local *local,\n\t\t\t struct nfc_llcp_sock *sock)\n{\n\tmutex_lock(&local->sdp_lock);\n\n\tif (sock->service_name != NULL && sock->service_name_len > 0) {\n\t\tint ssap = nfc_llcp_wks_sap(sock->service_name,\n\t\t\t\t\t    sock->service_name_len);\n\n\t\tif (ssap > 0) {\n\t\t\tpr_debug(\"WKS %d\\n\", ssap);\n\n\t\t\t/* This is a WKS, let's check if it's free */\n\t\t\tif (test_bit(ssap, &local->local_wks)) {\n\t\t\t\tmutex_unlock(&local->sdp_lock);\n\n\t\t\t\treturn LLCP_SAP_MAX;\n\t\t\t}\n\n\t\t\tset_bit(ssap, &local->local_wks);\n\t\t\tmutex_unlock(&local->sdp_lock);\n\n\t\t\treturn ssap;\n\t\t}\n\n\t\t/*\n\t\t * Check if there already is a non WKS socket bound\n\t\t * to this service name.\n\t\t */\n\t\tif (nfc_llcp_sock_from_sn(local, sock->service_name,\n\t\t\t\t\t  sock->service_name_len) != NULL) {\n\t\t\tmutex_unlock(&local->sdp_lock);\n\n\t\t\treturn LLCP_SAP_MAX;\n\t\t}\n\n\t\tmutex_unlock(&local->sdp_lock);\n\n\t\treturn LLCP_SDP_UNBOUND;\n\n\t} else if (sock->ssap != 0 && sock->ssap < LLCP_WKS_NUM_SAP) {\n\t\tif (!test_bit(sock->ssap, &local->local_wks)) {\n\t\t\tset_bit(sock->ssap, &local->local_wks);\n\t\t\tmutex_unlock(&local->sdp_lock);\n\n\t\t\treturn sock->ssap;\n\t\t}\n\t}\n\n\tmutex_unlock(&local->sdp_lock);\n\n\treturn LLCP_SAP_MAX;\n}\n\nu8 nfc_llcp_get_local_ssap(struct nfc_llcp_local *local)\n{\n\tu8 local_ssap;\n\n\tmutex_lock(&local->sdp_lock);\n\n\tlocal_ssap = find_first_zero_bit(&local->local_sap, LLCP_LOCAL_NUM_SAP);\n\tif (local_ssap == LLCP_LOCAL_NUM_SAP) {\n\t\tmutex_unlock(&local->sdp_lock);\n\t\treturn LLCP_SAP_MAX;\n\t}\n\n\tset_bit(local_ssap, &local->local_sap);\n\n\tmutex_unlock(&local->sdp_lock);\n\n\treturn local_ssap + LLCP_LOCAL_SAP_OFFSET;\n}\n\nvoid nfc_llcp_put_ssap(struct nfc_llcp_local *local, u8 ssap)\n{\n\tu8 local_ssap;\n\tunsigned long *sdp;\n\n\tif (ssap < LLCP_WKS_NUM_SAP) {\n\t\tlocal_ssap = ssap;\n\t\tsdp = &local->local_wks;\n\t} else if (ssap < LLCP_LOCAL_NUM_SAP) {\n\t\tatomic_t *client_cnt;\n\n\t\tlocal_ssap = ssap - LLCP_WKS_NUM_SAP;\n\t\tsdp = &local->local_sdp;\n\t\tclient_cnt = &local->local_sdp_cnt[local_ssap];\n\n\t\tpr_debug(\"%d clients\\n\", atomic_read(client_cnt));\n\n\t\tmutex_lock(&local->sdp_lock);\n\n\t\tif (atomic_dec_and_test(client_cnt)) {\n\t\t\tstruct nfc_llcp_sock *l_sock;\n\n\t\t\tpr_debug(\"No more clients for SAP %d\\n\", ssap);\n\n\t\t\tclear_bit(local_ssap, sdp);\n\n\t\t\t/* Find the listening sock and set it back to UNBOUND */\n\t\t\tl_sock = nfc_llcp_sock_get(local, ssap, LLCP_SAP_SDP);\n\t\t\tif (l_sock) {\n\t\t\t\tl_sock->ssap = LLCP_SDP_UNBOUND;\n\t\t\t\tnfc_llcp_sock_put(l_sock);\n\t\t\t}\n\t\t}\n\n\t\tmutex_unlock(&local->sdp_lock);\n\n\t\treturn;\n\t} else if (ssap < LLCP_MAX_SAP) {\n\t\tlocal_ssap = ssap - LLCP_LOCAL_NUM_SAP;\n\t\tsdp = &local->local_sap;\n\t} else {\n\t\treturn;\n\t}\n\n\tmutex_lock(&local->sdp_lock);\n\n\tclear_bit(local_ssap, sdp);\n\n\tmutex_unlock(&local->sdp_lock);\n}\n\nstatic u8 nfc_llcp_reserve_sdp_ssap(struct nfc_llcp_local *local)\n{\n\tu8 ssap;\n\n\tmutex_lock(&local->sdp_lock);\n\n\tssap = find_first_zero_bit(&local->local_sdp, LLCP_SDP_NUM_SAP);\n\tif (ssap == LLCP_SDP_NUM_SAP) {\n\t\tmutex_unlock(&local->sdp_lock);\n\n\t\treturn LLCP_SAP_MAX;\n\t}\n\n\tpr_debug(\"SDP ssap %d\\n\", LLCP_WKS_NUM_SAP + ssap);\n\n\tset_bit(ssap, &local->local_sdp);\n\n\tmutex_unlock(&local->sdp_lock);\n\n\treturn LLCP_WKS_NUM_SAP + ssap;\n}\n\nstatic int nfc_llcp_build_gb(struct nfc_llcp_local *local)\n{\n\tu8 *gb_cur, version, version_length;\n\tu8 lto_length, wks_length, miux_length;\n\tconst u8 *version_tlv = NULL, *lto_tlv = NULL,\n\t   *wks_tlv = NULL, *miux_tlv = NULL;\n\t__be16 wks = cpu_to_be16(local->local_wks);\n\tu8 gb_len = 0;\n\tint ret = 0;\n\n\tversion = LLCP_VERSION_11;\n\tversion_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,\n\t\t\t\t\t 1, &version_length);\n\tif (!version_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgb_len += version_length;\n\n\tlto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);\n\tif (!lto_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgb_len += lto_length;\n\n\tpr_debug(\"Local wks 0x%lx\\n\", local->local_wks);\n\twks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);\n\tif (!wks_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgb_len += wks_length;\n\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,\n\t\t\t\t      &miux_length);\n\tif (!miux_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgb_len += miux_length;\n\n\tgb_len += ARRAY_SIZE(llcp_magic);\n\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tgb_cur = local->gb;\n\n\tmemcpy(gb_cur, llcp_magic, ARRAY_SIZE(llcp_magic));\n\tgb_cur += ARRAY_SIZE(llcp_magic);\n\n\tmemcpy(gb_cur, version_tlv, version_length);\n\tgb_cur += version_length;\n\n\tmemcpy(gb_cur, lto_tlv, lto_length);\n\tgb_cur += lto_length;\n\n\tmemcpy(gb_cur, wks_tlv, wks_length);\n\tgb_cur += wks_length;\n\n\tmemcpy(gb_cur, miux_tlv, miux_length);\n\tgb_cur += miux_length;\n\n\tlocal->gb_len = gb_len;\n\nout:\n\tkfree(version_tlv);\n\tkfree(lto_tlv);\n\tkfree(wks_tlv);\n\tkfree(miux_tlv);\n\n\treturn ret;\n}\n\nu8 *nfc_llcp_general_bytes(struct nfc_dev *dev, size_t *general_bytes_len)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\t*general_bytes_len = 0;\n\t\treturn NULL;\n\t}\n\n\tnfc_llcp_build_gb(local);\n\n\t*general_bytes_len = local->gb_len;\n\n\treturn local->gb;\n}\n\nint nfc_llcp_set_remote_gb(struct nfc_dev *dev, const u8 *gb, u8 gb_len)\n{\n\tstruct nfc_llcp_local *local;\n\n\tif (gb_len < 3 || gb_len > NFC_MAX_GT_LEN)\n\t\treturn -EINVAL;\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tpr_err(\"No LLCP device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmemset(local->remote_gb, 0, NFC_MAX_GT_LEN);\n\tmemcpy(local->remote_gb, gb, gb_len);\n\tlocal->remote_gb_len = gb_len;\n\n\tif (memcmp(local->remote_gb, llcp_magic, 3)) {\n\t\tpr_err(\"MAC does not support LLCP\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn nfc_llcp_parse_gb_tlv(local,\n\t\t\t\t     &local->remote_gb[3],\n\t\t\t\t     local->remote_gb_len - 3);\n}\n\nstatic u8 nfc_llcp_dsap(const struct sk_buff *pdu)\n{\n\treturn (pdu->data[0] & 0xfc) >> 2;\n}\n\nstatic u8 nfc_llcp_ptype(const struct sk_buff *pdu)\n{\n\treturn ((pdu->data[0] & 0x03) << 2) | ((pdu->data[1] & 0xc0) >> 6);\n}\n\nstatic u8 nfc_llcp_ssap(const struct sk_buff *pdu)\n{\n\treturn pdu->data[1] & 0x3f;\n}\n\nstatic u8 nfc_llcp_ns(const struct sk_buff *pdu)\n{\n\treturn pdu->data[2] >> 4;\n}\n\nstatic u8 nfc_llcp_nr(const struct sk_buff *pdu)\n{\n\treturn pdu->data[2] & 0xf;\n}\n\nstatic void nfc_llcp_set_nrns(struct nfc_llcp_sock *sock, struct sk_buff *pdu)\n{\n\tpdu->data[2] = (sock->send_n << 4) | (sock->recv_n);\n\tsock->send_n = (sock->send_n + 1) % 16;\n\tsock->recv_ack_n = (sock->recv_n - 1) % 16;\n}\n\nvoid nfc_llcp_send_to_raw_sock(struct nfc_llcp_local *local,\n\t\t\t       struct sk_buff *skb, u8 direction)\n{\n\tstruct sk_buff *skb_copy = NULL, *nskb;\n\tstruct sock *sk;\n\tu8 *data;\n\n\tread_lock(&local->raw_sockets.lock);\n\n\tsk_for_each(sk, &local->raw_sockets.head) {\n\t\tif (sk->sk_state != LLCP_BOUND)\n\t\t\tcontinue;\n\n\t\tif (skb_copy == NULL) {\n\t\t\tskb_copy = __pskb_copy_fclone(skb, NFC_RAW_HEADER_SIZE,\n\t\t\t\t\t\t      GFP_ATOMIC, true);\n\n\t\t\tif (skb_copy == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tdata = skb_push(skb_copy, NFC_RAW_HEADER_SIZE);\n\n\t\t\tdata[0] = local->dev ? local->dev->idx : 0xFF;\n\t\t\tdata[1] = direction & 0x01;\n\t\t\tdata[1] |= (RAW_PAYLOAD_LLCP << 1);\n\t\t}\n\n\t\tnskb = skb_clone(skb_copy, GFP_ATOMIC);\n\t\tif (!nskb)\n\t\t\tcontinue;\n\n\t\tif (sock_queue_rcv_skb(sk, nskb))\n\t\t\tkfree_skb(nskb);\n\t}\n\n\tread_unlock(&local->raw_sockets.lock);\n\n\tkfree_skb(skb_copy);\n}\n\nstatic void nfc_llcp_tx_work(struct work_struct *work)\n{\n\tstruct nfc_llcp_local *local = container_of(work, struct nfc_llcp_local,\n\t\t\t\t\t\t    tx_work);\n\tstruct sk_buff *skb;\n\tstruct sock *sk;\n\tstruct nfc_llcp_sock *llcp_sock;\n\n\tskb = skb_dequeue(&local->tx_queue);\n\tif (skb != NULL) {\n\t\tsk = skb->sk;\n\t\tllcp_sock = nfc_llcp_sock(sk);\n\n\t\tif (llcp_sock == NULL && nfc_llcp_ptype(skb) == LLCP_PDU_I) {\n\t\t\tkfree_skb(skb);\n\t\t\tnfc_llcp_send_symm(local->dev);\n\t\t} else if (llcp_sock && !llcp_sock->remote_ready) {\n\t\t\tskb_queue_head(&local->tx_queue, skb);\n\t\t\tnfc_llcp_send_symm(local->dev);\n\t\t} else {\n\t\t\tstruct sk_buff *copy_skb = NULL;\n\t\t\tu8 ptype = nfc_llcp_ptype(skb);\n\t\t\tint ret;\n\n\t\t\tpr_debug(\"Sending pending skb\\n\");\n\t\t\tprint_hex_dump_debug(\"LLCP Tx: \", DUMP_PREFIX_OFFSET,\n\t\t\t\t\t     16, 1, skb->data, skb->len, true);\n\n\t\t\tif (ptype == LLCP_PDU_I)\n\t\t\t\tcopy_skb = skb_copy(skb, GFP_ATOMIC);\n\n\t\t\t__net_timestamp(skb);\n\n\t\t\tnfc_llcp_send_to_raw_sock(local, skb,\n\t\t\t\t\t\t  NFC_DIRECTION_TX);\n\n\t\t\tret = nfc_data_exchange(local->dev, local->target_idx,\n\t\t\t\t\t\tskb, nfc_llcp_recv, local);\n\n\t\t\tif (ret) {\n\t\t\t\tkfree_skb(copy_skb);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (ptype == LLCP_PDU_I && copy_skb)\n\t\t\t\tskb_queue_tail(&llcp_sock->tx_pending_queue,\n\t\t\t\t\t       copy_skb);\n\t\t}\n\t} else {\n\t\tnfc_llcp_send_symm(local->dev);\n\t}\n\nout:\n\tmod_timer(&local->link_timer,\n\t\t  jiffies + msecs_to_jiffies(2 * local->remote_lto));\n}\n\nstatic struct nfc_llcp_sock *nfc_llcp_connecting_sock_get(struct nfc_llcp_local *local,\n\t\t\t\t\t\t\t  u8 ssap)\n{\n\tstruct sock *sk;\n\tstruct nfc_llcp_sock *llcp_sock;\n\n\tread_lock(&local->connecting_sockets.lock);\n\n\tsk_for_each(sk, &local->connecting_sockets.head) {\n\t\tllcp_sock = nfc_llcp_sock(sk);\n\n\t\tif (llcp_sock->ssap == ssap) {\n\t\t\tsock_hold(&llcp_sock->sk);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tllcp_sock = NULL;\n\nout:\n\tread_unlock(&local->connecting_sockets.lock);\n\n\treturn llcp_sock;\n}\n\nstatic struct nfc_llcp_sock *nfc_llcp_sock_get_sn(struct nfc_llcp_local *local,\n\t\t\t\t\t\t  const u8 *sn, size_t sn_len)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\n\tllcp_sock = nfc_llcp_sock_from_sn(local, sn, sn_len);\n\n\tif (llcp_sock == NULL)\n\t\treturn NULL;\n\n\tsock_hold(&llcp_sock->sk);\n\n\treturn llcp_sock;\n}\n\nstatic const u8 *nfc_llcp_connect_sn(const struct sk_buff *skb, size_t *sn_len)\n{\n\tu8 type, length;\n\tconst u8 *tlv = &skb->data[2];\n\tsize_t tlv_array_len = skb->len - LLCP_HEADER_SIZE, offset = 0;\n\n\twhile (offset < tlv_array_len) {\n\t\ttype = tlv[0];\n\t\tlength = tlv[1];\n\n\t\tpr_debug(\"type 0x%x length %d\\n\", type, length);\n\n\t\tif (type == LLCP_TLV_SN) {\n\t\t\t*sn_len = length;\n\t\t\treturn &tlv[2];\n\t\t}\n\n\t\toffset += length + 2;\n\t\ttlv += length + 2;\n\t}\n\n\treturn NULL;\n}\n\nstatic void nfc_llcp_recv_ui(struct nfc_llcp_local *local,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct nfc_llcp_ui_cb *ui_cb;\n\tu8 dsap, ssap;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tui_cb = nfc_llcp_ui_skb_cb(skb);\n\tui_cb->dsap = dsap;\n\tui_cb->ssap = ssap;\n\n\tpr_debug(\"%d %d\\n\", dsap, ssap);\n\n\t/* We're looking for a bound socket, not a client one */\n\tllcp_sock = nfc_llcp_sock_get(local, dsap, LLCP_SAP_SDP);\n\tif (llcp_sock == NULL || llcp_sock->sk.sk_type != SOCK_DGRAM)\n\t\treturn;\n\n\t/* There is no sequence with UI frames */\n\tskb_pull(skb, LLCP_HEADER_SIZE);\n\tif (!sock_queue_rcv_skb(&llcp_sock->sk, skb)) {\n\t\t/*\n\t\t * UI frames will be freed from the socket layer, so we\n\t\t * need to keep them alive until someone receives them.\n\t\t */\n\t\tskb_get(skb);\n\t} else {\n\t\tpr_err(\"Receive queue is full\\n\");\n\t}\n\n\tnfc_llcp_sock_put(llcp_sock);\n}\n\nstatic void nfc_llcp_recv_connect(struct nfc_llcp_local *local,\n\t\t\t\t  const struct sk_buff *skb)\n{\n\tstruct sock *new_sk, *parent;\n\tstruct nfc_llcp_sock *sock, *new_sock;\n\tu8 dsap, ssap, reason;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tpr_debug(\"%d %d\\n\", dsap, ssap);\n\n\tif (dsap != LLCP_SAP_SDP) {\n\t\tsock = nfc_llcp_sock_get(local, dsap, LLCP_SAP_SDP);\n\t\tif (sock == NULL || sock->sk.sk_state != LLCP_LISTEN) {\n\t\t\treason = LLCP_DM_NOBOUND;\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\tconst u8 *sn;\n\t\tsize_t sn_len;\n\n\t\tsn = nfc_llcp_connect_sn(skb, &sn_len);\n\t\tif (sn == NULL) {\n\t\t\treason = LLCP_DM_NOBOUND;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tpr_debug(\"Service name length %zu\\n\", sn_len);\n\n\t\tsock = nfc_llcp_sock_get_sn(local, sn, sn_len);\n\t\tif (sock == NULL) {\n\t\t\treason = LLCP_DM_NOBOUND;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tlock_sock(&sock->sk);\n\n\tparent = &sock->sk;\n\n\tif (sk_acceptq_is_full(parent)) {\n\t\treason = LLCP_DM_REJ;\n\t\trelease_sock(&sock->sk);\n\t\tsock_put(&sock->sk);\n\t\tgoto fail;\n\t}\n\n\tif (sock->ssap == LLCP_SDP_UNBOUND) {\n\t\tu8 ssap = nfc_llcp_reserve_sdp_ssap(local);\n\n\t\tpr_debug(\"First client, reserving %d\\n\", ssap);\n\n\t\tif (ssap == LLCP_SAP_MAX) {\n\t\t\treason = LLCP_DM_REJ;\n\t\t\trelease_sock(&sock->sk);\n\t\t\tsock_put(&sock->sk);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tsock->ssap = ssap;\n\t}\n\n\tnew_sk = nfc_llcp_sock_alloc(NULL, parent->sk_type, GFP_ATOMIC, 0);\n\tif (new_sk == NULL) {\n\t\treason = LLCP_DM_REJ;\n\t\trelease_sock(&sock->sk);\n\t\tsock_put(&sock->sk);\n\t\tgoto fail;\n\t}\n\n\tnew_sock = nfc_llcp_sock(new_sk);\n\tnew_sock->dev = local->dev;\n\tnew_sock->local = nfc_llcp_local_get(local);\n\tnew_sock->rw = sock->rw;\n\tnew_sock->miux = sock->miux;\n\tnew_sock->nfc_protocol = sock->nfc_protocol;\n\tnew_sock->dsap = ssap;\n\tnew_sock->target_idx = local->target_idx;\n\tnew_sock->parent = parent;\n\tnew_sock->ssap = sock->ssap;\n\tif (sock->ssap < LLCP_LOCAL_NUM_SAP && sock->ssap >= LLCP_WKS_NUM_SAP) {\n\t\tatomic_t *client_count;\n\n\t\tpr_debug(\"reserved_ssap %d for %p\\n\", sock->ssap, new_sock);\n\n\t\tclient_count =\n\t\t\t&local->local_sdp_cnt[sock->ssap - LLCP_WKS_NUM_SAP];\n\n\t\tatomic_inc(client_count);\n\t\tnew_sock->reserved_ssap = sock->ssap;\n\t}\n\n\tnfc_llcp_parse_connection_tlv(new_sock, &skb->data[LLCP_HEADER_SIZE],\n\t\t\t\t      skb->len - LLCP_HEADER_SIZE);\n\n\tpr_debug(\"new sock %p sk %p\\n\", new_sock, &new_sock->sk);\n\n\tnfc_llcp_sock_link(&local->sockets, new_sk);\n\n\tnfc_llcp_accept_enqueue(&sock->sk, new_sk);\n\n\tnfc_get_device(local->dev->idx);\n\n\tnew_sk->sk_state = LLCP_CONNECTED;\n\n\t/* Wake the listening processes */\n\tparent->sk_data_ready(parent);\n\n\t/* Send CC */\n\tnfc_llcp_send_cc(new_sock);\n\n\trelease_sock(&sock->sk);\n\tsock_put(&sock->sk);\n\n\treturn;\n\nfail:\n\t/* Send DM */\n\tnfc_llcp_send_dm(local, dsap, ssap, reason);\n}\n\nint nfc_llcp_queue_i_frames(struct nfc_llcp_sock *sock)\n{\n\tint nr_frames = 0;\n\tstruct nfc_llcp_local *local = sock->local;\n\n\tpr_debug(\"Remote ready %d tx queue len %d remote rw %d\",\n\t\t sock->remote_ready, skb_queue_len(&sock->tx_pending_queue),\n\t\t sock->remote_rw);\n\n\t/* Try to queue some I frames for transmission */\n\twhile (sock->remote_ready &&\n\t       skb_queue_len(&sock->tx_pending_queue) < sock->remote_rw) {\n\t\tstruct sk_buff *pdu;\n\n\t\tpdu = skb_dequeue(&sock->tx_queue);\n\t\tif (pdu == NULL)\n\t\t\tbreak;\n\n\t\t/* Update N(S)/N(R) */\n\t\tnfc_llcp_set_nrns(sock, pdu);\n\n\t\tskb_queue_tail(&local->tx_queue, pdu);\n\t\tnr_frames++;\n\t}\n\n\treturn nr_frames;\n}\n\nstatic void nfc_llcp_recv_hdlc(struct nfc_llcp_local *local,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct sock *sk;\n\tu8 dsap, ssap, ptype, ns, nr;\n\n\tptype = nfc_llcp_ptype(skb);\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\tns = nfc_llcp_ns(skb);\n\tnr = nfc_llcp_nr(skb);\n\n\tpr_debug(\"%d %d R %d S %d\\n\", dsap, ssap, nr, ns);\n\n\tllcp_sock = nfc_llcp_sock_get(local, dsap, ssap);\n\tif (llcp_sock == NULL) {\n\t\tnfc_llcp_send_dm(local, dsap, ssap, LLCP_DM_NOCONN);\n\t\treturn;\n\t}\n\n\tsk = &llcp_sock->sk;\n\tlock_sock(sk);\n\tif (sk->sk_state == LLCP_CLOSED) {\n\t\trelease_sock(sk);\n\t\tnfc_llcp_sock_put(llcp_sock);\n\t}\n\n\t/* Pass the payload upstream */\n\tif (ptype == LLCP_PDU_I) {\n\t\tpr_debug(\"I frame, queueing on %p\\n\", &llcp_sock->sk);\n\n\t\tif (ns == llcp_sock->recv_n)\n\t\t\tllcp_sock->recv_n = (llcp_sock->recv_n + 1) % 16;\n\t\telse\n\t\t\tpr_err(\"Received out of sequence I PDU\\n\");\n\n\t\tskb_pull(skb, LLCP_HEADER_SIZE + LLCP_SEQUENCE_SIZE);\n\t\tif (!sock_queue_rcv_skb(&llcp_sock->sk, skb)) {\n\t\t\t/*\n\t\t\t * I frames will be freed from the socket layer, so we\n\t\t\t * need to keep them alive until someone receives them.\n\t\t\t */\n\t\t\tskb_get(skb);\n\t\t} else {\n\t\t\tpr_err(\"Receive queue is full\\n\");\n\t\t}\n\t}\n\n\t/* Remove skbs from the pending queue */\n\tif (llcp_sock->send_ack_n != nr) {\n\t\tstruct sk_buff *s, *tmp;\n\t\tu8 n;\n\n\t\tllcp_sock->send_ack_n = nr;\n\n\t\t/* Remove and free all skbs until ns == nr */\n\t\tskb_queue_walk_safe(&llcp_sock->tx_pending_queue, s, tmp) {\n\t\t\tn = nfc_llcp_ns(s);\n\n\t\t\tskb_unlink(s, &llcp_sock->tx_pending_queue);\n\t\t\tkfree_skb(s);\n\n\t\t\tif (n == nr)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Re-queue the remaining skbs for transmission */\n\t\tskb_queue_reverse_walk_safe(&llcp_sock->tx_pending_queue,\n\t\t\t\t\t    s, tmp) {\n\t\t\tskb_unlink(s, &llcp_sock->tx_pending_queue);\n\t\t\tskb_queue_head(&local->tx_queue, s);\n\t\t}\n\t}\n\n\tif (ptype == LLCP_PDU_RR)\n\t\tllcp_sock->remote_ready = true;\n\telse if (ptype == LLCP_PDU_RNR)\n\t\tllcp_sock->remote_ready = false;\n\n\tif (nfc_llcp_queue_i_frames(llcp_sock) == 0 && ptype == LLCP_PDU_I)\n\t\tnfc_llcp_send_rr(llcp_sock);\n\n\trelease_sock(sk);\n\tnfc_llcp_sock_put(llcp_sock);\n}\n\nstatic void nfc_llcp_recv_disc(struct nfc_llcp_local *local,\n\t\t\t       const struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct sock *sk;\n\tu8 dsap, ssap;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tif ((dsap == 0) && (ssap == 0)) {\n\t\tpr_debug(\"Connection termination\");\n\t\tnfc_dep_link_down(local->dev);\n\t\treturn;\n\t}\n\n\tllcp_sock = nfc_llcp_sock_get(local, dsap, ssap);\n\tif (llcp_sock == NULL) {\n\t\tnfc_llcp_send_dm(local, dsap, ssap, LLCP_DM_NOCONN);\n\t\treturn;\n\t}\n\n\tsk = &llcp_sock->sk;\n\tlock_sock(sk);\n\n\tnfc_llcp_socket_purge(llcp_sock);\n\n\tif (sk->sk_state == LLCP_CLOSED) {\n\t\trelease_sock(sk);\n\t\tnfc_llcp_sock_put(llcp_sock);\n\t}\n\n\tif (sk->sk_state == LLCP_CONNECTED) {\n\t\tnfc_put_device(local->dev);\n\t\tsk->sk_state = LLCP_CLOSED;\n\t\tsk->sk_state_change(sk);\n\t}\n\n\tnfc_llcp_send_dm(local, dsap, ssap, LLCP_DM_DISC);\n\n\trelease_sock(sk);\n\tnfc_llcp_sock_put(llcp_sock);\n}\n\nstatic void nfc_llcp_recv_cc(struct nfc_llcp_local *local,\n\t\t\t     const struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct sock *sk;\n\tu8 dsap, ssap;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tllcp_sock = nfc_llcp_connecting_sock_get(local, dsap);\n\tif (llcp_sock == NULL) {\n\t\tpr_err(\"Invalid CC\\n\");\n\t\tnfc_llcp_send_dm(local, dsap, ssap, LLCP_DM_NOCONN);\n\n\t\treturn;\n\t}\n\n\tsk = &llcp_sock->sk;\n\n\t/* Unlink from connecting and link to the client array */\n\tnfc_llcp_sock_unlink(&local->connecting_sockets, sk);\n\tnfc_llcp_sock_link(&local->sockets, sk);\n\tllcp_sock->dsap = ssap;\n\n\tnfc_llcp_parse_connection_tlv(llcp_sock, &skb->data[LLCP_HEADER_SIZE],\n\t\t\t\t      skb->len - LLCP_HEADER_SIZE);\n\n\tsk->sk_state = LLCP_CONNECTED;\n\tsk->sk_state_change(sk);\n\n\tnfc_llcp_sock_put(llcp_sock);\n}\n\nstatic void nfc_llcp_recv_dm(struct nfc_llcp_local *local,\n\t\t\t     const struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct sock *sk;\n\tu8 dsap, ssap, reason;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\treason = skb->data[2];\n\n\tpr_debug(\"%d %d reason %d\\n\", ssap, dsap, reason);\n\n\tswitch (reason) {\n\tcase LLCP_DM_NOBOUND:\n\tcase LLCP_DM_REJ:\n\t\tllcp_sock = nfc_llcp_connecting_sock_get(local, dsap);\n\t\tbreak;\n\n\tdefault:\n\t\tllcp_sock = nfc_llcp_sock_get(local, dsap, ssap);\n\t\tbreak;\n\t}\n\n\tif (llcp_sock == NULL) {\n\t\tpr_debug(\"Already closed\\n\");\n\t\treturn;\n\t}\n\n\tsk = &llcp_sock->sk;\n\n\tsk->sk_err = ENXIO;\n\tsk->sk_state = LLCP_CLOSED;\n\tsk->sk_state_change(sk);\n\n\tnfc_llcp_sock_put(llcp_sock);\n}\n\nstatic void nfc_llcp_recv_snl(struct nfc_llcp_local *local,\n\t\t\t      const struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tu8 dsap, ssap, type, length, tid, sap;\n\tconst u8 *tlv;\n\tu16 tlv_len, offset;\n\tconst char *service_name;\n\tsize_t service_name_len;\n\tstruct nfc_llcp_sdp_tlv *sdp;\n\tHLIST_HEAD(llc_sdres_list);\n\tsize_t sdres_tlvs_len;\n\tHLIST_HEAD(nl_sdres_list);\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tpr_debug(\"%d %d\\n\", dsap, ssap);\n\n\tif (dsap != LLCP_SAP_SDP || ssap != LLCP_SAP_SDP) {\n\t\tpr_err(\"Wrong SNL SAP\\n\");\n\t\treturn;\n\t}\n\n\ttlv = &skb->data[LLCP_HEADER_SIZE];\n\ttlv_len = skb->len - LLCP_HEADER_SIZE;\n\toffset = 0;\n\tsdres_tlvs_len = 0;\n\n\twhile (offset < tlv_len) {\n\t\ttype = tlv[0];\n\t\tlength = tlv[1];\n\n\t\tswitch (type) {\n\t\tcase LLCP_TLV_SDREQ:\n\t\t\ttid = tlv[2];\n\t\t\tservice_name = (char *) &tlv[3];\n\t\t\tservice_name_len = length - 1;\n\n\t\t\tpr_debug(\"Looking for %.16s\\n\", service_name);\n\n\t\t\tif (service_name_len == strlen(\"urn:nfc:sn:sdp\") &&\n\t\t\t    !strncmp(service_name, \"urn:nfc:sn:sdp\",\n\t\t\t\t     service_name_len)) {\n\t\t\t\tsap = 1;\n\t\t\t\tgoto add_snl;\n\t\t\t}\n\n\t\t\tllcp_sock = nfc_llcp_sock_from_sn(local, service_name,\n\t\t\t\t\t\t\t  service_name_len);\n\t\t\tif (!llcp_sock) {\n\t\t\t\tsap = 0;\n\t\t\t\tgoto add_snl;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We found a socket but its ssap has not been reserved\n\t\t\t * yet. We need to assign it for good and send a reply.\n\t\t\t * The ssap will be freed when the socket is closed.\n\t\t\t */\n\t\t\tif (llcp_sock->ssap == LLCP_SDP_UNBOUND) {\n\t\t\t\tatomic_t *client_count;\n\n\t\t\t\tsap = nfc_llcp_reserve_sdp_ssap(local);\n\n\t\t\t\tpr_debug(\"Reserving %d\\n\", sap);\n\n\t\t\t\tif (sap == LLCP_SAP_MAX) {\n\t\t\t\t\tsap = 0;\n\t\t\t\t\tgoto add_snl;\n\t\t\t\t}\n\n\t\t\t\tclient_count =\n\t\t\t\t\t&local->local_sdp_cnt[sap -\n\t\t\t\t\t\t\t      LLCP_WKS_NUM_SAP];\n\n\t\t\t\tatomic_inc(client_count);\n\n\t\t\t\tllcp_sock->ssap = sap;\n\t\t\t\tllcp_sock->reserved_ssap = sap;\n\t\t\t} else {\n\t\t\t\tsap = llcp_sock->ssap;\n\t\t\t}\n\n\t\t\tpr_debug(\"%p %d\\n\", llcp_sock, sap);\n\nadd_snl:\n\t\t\tsdp = nfc_llcp_build_sdres_tlv(tid, sap);\n\t\t\tif (sdp == NULL)\n\t\t\t\tgoto exit;\n\n\t\t\tsdres_tlvs_len += sdp->tlv_len;\n\t\t\thlist_add_head(&sdp->node, &llc_sdres_list);\n\t\t\tbreak;\n\n\t\tcase LLCP_TLV_SDRES:\n\t\t\tmutex_lock(&local->sdreq_lock);\n\n\t\t\tpr_debug(\"LLCP_TLV_SDRES: searching tid %d\\n\", tlv[2]);\n\n\t\t\thlist_for_each_entry(sdp, &local->pending_sdreqs, node) {\n\t\t\t\tif (sdp->tid != tlv[2])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tsdp->sap = tlv[3];\n\n\t\t\t\tpr_debug(\"Found: uri=%s, sap=%d\\n\",\n\t\t\t\t\t sdp->uri, sdp->sap);\n\n\t\t\t\thlist_del(&sdp->node);\n\n\t\t\t\thlist_add_head(&sdp->node, &nl_sdres_list);\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmutex_unlock(&local->sdreq_lock);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"Invalid SNL tlv value 0x%x\\n\", type);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset += length + 2;\n\t\ttlv += length + 2;\n\t}\n\nexit:\n\tif (!hlist_empty(&nl_sdres_list))\n\t\tnfc_genl_llc_send_sdres(local->dev, &nl_sdres_list);\n\n\tif (!hlist_empty(&llc_sdres_list))\n\t\tnfc_llcp_send_snl_sdres(local, &llc_sdres_list, sdres_tlvs_len);\n}\n\nstatic void nfc_llcp_recv_agf(struct nfc_llcp_local *local, struct sk_buff *skb)\n{\n\tu8 ptype;\n\tu16 pdu_len;\n\tstruct sk_buff *new_skb;\n\n\tif (skb->len <= LLCP_HEADER_SIZE) {\n\t\tpr_err(\"Malformed AGF PDU\\n\");\n\t\treturn;\n\t}\n\n\tskb_pull(skb, LLCP_HEADER_SIZE);\n\n\twhile (skb->len > LLCP_AGF_PDU_HEADER_SIZE) {\n\t\tpdu_len = skb->data[0] << 8 | skb->data[1];\n\n\t\tskb_pull(skb, LLCP_AGF_PDU_HEADER_SIZE);\n\n\t\tif (pdu_len < LLCP_HEADER_SIZE || pdu_len > skb->len) {\n\t\t\tpr_err(\"Malformed AGF PDU\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tptype = nfc_llcp_ptype(skb);\n\n\t\tif (ptype == LLCP_PDU_SYMM || ptype == LLCP_PDU_AGF)\n\t\t\tgoto next;\n\n\t\tnew_skb = nfc_alloc_recv_skb(pdu_len, GFP_KERNEL);\n\t\tif (new_skb == NULL) {\n\t\t\tpr_err(\"Could not allocate PDU\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tskb_put_data(new_skb, skb->data, pdu_len);\n\n\t\tnfc_llcp_rx_skb(local, new_skb);\n\n\t\tkfree_skb(new_skb);\nnext:\n\t\tskb_pull(skb, pdu_len);\n\t}\n}\n\nstatic void nfc_llcp_rx_skb(struct nfc_llcp_local *local, struct sk_buff *skb)\n{\n\tu8 dsap, ssap, ptype;\n\n\tptype = nfc_llcp_ptype(skb);\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tpr_debug(\"ptype 0x%x dsap 0x%x ssap 0x%x\\n\", ptype, dsap, ssap);\n\n\tif (ptype != LLCP_PDU_SYMM)\n\t\tprint_hex_dump_debug(\"LLCP Rx: \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\t     skb->data, skb->len, true);\n\n\tswitch (ptype) {\n\tcase LLCP_PDU_SYMM:\n\t\tpr_debug(\"SYMM\\n\");\n\t\tbreak;\n\n\tcase LLCP_PDU_UI:\n\t\tpr_debug(\"UI\\n\");\n\t\tnfc_llcp_recv_ui(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_CONNECT:\n\t\tpr_debug(\"CONNECT\\n\");\n\t\tnfc_llcp_recv_connect(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_DISC:\n\t\tpr_debug(\"DISC\\n\");\n\t\tnfc_llcp_recv_disc(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_CC:\n\t\tpr_debug(\"CC\\n\");\n\t\tnfc_llcp_recv_cc(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_DM:\n\t\tpr_debug(\"DM\\n\");\n\t\tnfc_llcp_recv_dm(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_SNL:\n\t\tpr_debug(\"SNL\\n\");\n\t\tnfc_llcp_recv_snl(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_I:\n\tcase LLCP_PDU_RR:\n\tcase LLCP_PDU_RNR:\n\t\tpr_debug(\"I frame\\n\");\n\t\tnfc_llcp_recv_hdlc(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_AGF:\n\t\tpr_debug(\"AGF frame\\n\");\n\t\tnfc_llcp_recv_agf(local, skb);\n\t\tbreak;\n\t}\n}\n\nstatic void nfc_llcp_rx_work(struct work_struct *work)\n{\n\tstruct nfc_llcp_local *local = container_of(work, struct nfc_llcp_local,\n\t\t\t\t\t\t    rx_work);\n\tstruct sk_buff *skb;\n\n\tskb = local->rx_pending;\n\tif (skb == NULL) {\n\t\tpr_debug(\"No pending SKB\\n\");\n\t\treturn;\n\t}\n\n\t__net_timestamp(skb);\n\n\tnfc_llcp_send_to_raw_sock(local, skb, NFC_DIRECTION_RX);\n\n\tnfc_llcp_rx_skb(local, skb);\n\n\tschedule_work(&local->tx_work);\n\tkfree_skb(local->rx_pending);\n\tlocal->rx_pending = NULL;\n}\n\nstatic void __nfc_llcp_recv(struct nfc_llcp_local *local, struct sk_buff *skb)\n{\n\tlocal->rx_pending = skb;\n\tdel_timer(&local->link_timer);\n\tschedule_work(&local->rx_work);\n}\n\nvoid nfc_llcp_recv(void *data, struct sk_buff *skb, int err)\n{\n\tstruct nfc_llcp_local *local = (struct nfc_llcp_local *) data;\n\n\tif (err < 0) {\n\t\tpr_err(\"LLCP PDU receive err %d\\n\", err);\n\t\treturn;\n\t}\n\n\t__nfc_llcp_recv(local, skb);\n}\n\nint nfc_llcp_data_received(struct nfc_dev *dev, struct sk_buff *skb)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tkfree_skb(skb);\n\t\treturn -ENODEV;\n\t}\n\n\t__nfc_llcp_recv(local, skb);\n\n\treturn 0;\n}\n\nvoid nfc_llcp_mac_is_down(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn;\n\n\tlocal->remote_miu = LLCP_DEFAULT_MIU;\n\tlocal->remote_lto = LLCP_DEFAULT_LTO;\n\n\t/* Close and purge all existing sockets */\n\tnfc_llcp_socket_release(local, true, 0);\n}\n\nvoid nfc_llcp_mac_is_up(struct nfc_dev *dev, u32 target_idx,\n\t\t\tu8 comm_mode, u8 rf_mode)\n{\n\tstruct nfc_llcp_local *local;\n\n\tpr_debug(\"rf mode %d\\n\", rf_mode);\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn;\n\n\tlocal->target_idx = target_idx;\n\tlocal->comm_mode = comm_mode;\n\tlocal->rf_mode = rf_mode;\n\n\tif (rf_mode == NFC_RF_INITIATOR) {\n\t\tpr_debug(\"Queueing Tx work\\n\");\n\n\t\tschedule_work(&local->tx_work);\n\t} else {\n\t\tmod_timer(&local->link_timer,\n\t\t\t  jiffies + msecs_to_jiffies(local->remote_lto));\n\t}\n}\n\nint nfc_llcp_register_device(struct nfc_dev *ndev)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = kzalloc(sizeof(struct nfc_llcp_local), GFP_KERNEL);\n\tif (local == NULL)\n\t\treturn -ENOMEM;\n\n\tlocal->dev = ndev;\n\tINIT_LIST_HEAD(&local->list);\n\tkref_init(&local->ref);\n\tmutex_init(&local->sdp_lock);\n\ttimer_setup(&local->link_timer, nfc_llcp_symm_timer, 0);\n\n\tskb_queue_head_init(&local->tx_queue);\n\tINIT_WORK(&local->tx_work, nfc_llcp_tx_work);\n\n\tlocal->rx_pending = NULL;\n\tINIT_WORK(&local->rx_work, nfc_llcp_rx_work);\n\n\tINIT_WORK(&local->timeout_work, nfc_llcp_timeout_work);\n\n\trwlock_init(&local->sockets.lock);\n\trwlock_init(&local->connecting_sockets.lock);\n\trwlock_init(&local->raw_sockets.lock);\n\n\tlocal->lto = 150; /* 1500 ms */\n\tlocal->rw = LLCP_MAX_RW;\n\tlocal->miux = cpu_to_be16(LLCP_MAX_MIUX);\n\tlocal->local_wks = 0x1; /* LLC Link Management */\n\n\tnfc_llcp_build_gb(local);\n\n\tlocal->remote_miu = LLCP_DEFAULT_MIU;\n\tlocal->remote_lto = LLCP_DEFAULT_LTO;\n\n\tmutex_init(&local->sdreq_lock);\n\tINIT_HLIST_HEAD(&local->pending_sdreqs);\n\ttimer_setup(&local->sdreq_timer, nfc_llcp_sdreq_timer, 0);\n\tINIT_WORK(&local->sdreq_timeout_work, nfc_llcp_sdreq_timeout_work);\n\n\tlist_add(&local->list, &llcp_devices);\n\n\treturn 0;\n}\n\nvoid nfc_llcp_unregister_device(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local = nfc_llcp_find_local(dev);\n\n\tif (local == NULL) {\n\t\tpr_debug(\"No such device\\n\");\n\t\treturn;\n\t}\n\n\tlocal_cleanup(local);\n\n\tnfc_llcp_local_put(local);\n}\n\nint __init nfc_llcp_init(void)\n{\n\treturn nfc_llcp_sock_init();\n}\n\nvoid nfc_llcp_exit(void)\n{\n\tnfc_llcp_sock_exit();\n}\n", "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Copyright (C) 2011  Intel Corporation. All rights reserved.\n */\n\n#define pr_fmt(fmt) \"llcp: %s: \" fmt, __func__\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/nfc.h>\n#include <linux/sched/signal.h>\n\n#include \"nfc.h\"\n#include \"llcp.h\"\n\nstatic int sock_wait_state(struct sock *sk, int state, unsigned long timeo)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tint err = 0;\n\n\tpr_debug(\"sk %p\", sk);\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\n\twhile (sk->sk_state != state) {\n\t\tif (!timeo) {\n\t\t\terr = -EINPROGRESS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\t\ttimeo = schedule_timeout(timeo);\n\t\tlock_sock(sk);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\terr = sock_error(sk);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn err;\n}\n\nstatic struct proto llcp_sock_proto = {\n\t.name     = \"NFC_LLCP\",\n\t.owner    = THIS_MODULE,\n\t.obj_size = sizeof(struct nfc_llcp_sock),\n};\n\nstatic int llcp_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_dev *dev;\n\tstruct sockaddr_nfc_llcp llcp_addr;\n\tint len, ret = 0;\n\n\tif (!addr || alen < offsetofend(struct sockaddr, sa_family) ||\n\t    addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"sk %p addr %p family %d\\n\", sk, addr, addr->sa_family);\n\n\tmemset(&llcp_addr, 0, sizeof(llcp_addr));\n\tlen = min_t(unsigned int, sizeof(llcp_addr), alen);\n\tmemcpy(&llcp_addr, addr, len);\n\n\t/* This is going to be a listening socket, dsap must be 0 */\n\tif (llcp_addr.dsap != 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != LLCP_CLOSED) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\n\tdev = nfc_get_device(llcp_addr.dev_idx);\n\tif (dev == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = nfc_llcp_local_get(local);\n\tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n\tllcp_sock->service_name_len = min_t(unsigned int,\n\t\t\t\t\t    llcp_addr.service_name_len,\n\t\t\t\t\t    NFC_LLCP_MAX_SERVICE_NAME);\n\tllcp_sock->service_name = kmemdup(llcp_addr.service_name,\n\t\t\t\t\t  llcp_sock->service_name_len,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!llcp_sock->service_name) {\n\t\tret = -ENOMEM;\n\t\tgoto sock_llcp_put_local;\n\t}\n\tllcp_sock->ssap = nfc_llcp_get_sdp_ssap(local, llcp_sock);\n\tif (llcp_sock->ssap == LLCP_SAP_MAX) {\n\t\tret = -EADDRINUSE;\n\t\tgoto free_service_name;\n\t}\n\n\tllcp_sock->reserved_ssap = llcp_sock->ssap;\n\n\tnfc_llcp_sock_link(&local->sockets, sk);\n\n\tpr_debug(\"Socket bound to SAP %d\\n\", llcp_sock->ssap);\n\n\tsk->sk_state = LLCP_BOUND;\n\tnfc_put_device(dev);\n\trelease_sock(sk);\n\n\treturn 0;\n\nfree_service_name:\n\tkfree(llcp_sock->service_name);\n\tllcp_sock->service_name = NULL;\n\nsock_llcp_put_local:\n\tnfc_llcp_local_put(llcp_sock->local);\n\tllcp_sock->local = NULL;\n\tllcp_sock->dev = NULL;\n\nput_dev:\n\tnfc_put_device(dev);\n\nerror:\n\trelease_sock(sk);\n\treturn ret;\n}\n\nstatic int llcp_raw_sock_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\t      int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_dev *dev;\n\tstruct sockaddr_nfc_llcp llcp_addr;\n\tint len, ret = 0;\n\n\tif (!addr || alen < offsetofend(struct sockaddr, sa_family) ||\n\t    addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"sk %p addr %p family %d\\n\", sk, addr, addr->sa_family);\n\n\tmemset(&llcp_addr, 0, sizeof(llcp_addr));\n\tlen = min_t(unsigned int, sizeof(llcp_addr), alen);\n\tmemcpy(&llcp_addr, addr, len);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != LLCP_CLOSED) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\n\tdev = nfc_get_device(llcp_addr.dev_idx);\n\tif (dev == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = nfc_llcp_local_get(local);\n\tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n\n\tnfc_llcp_sock_link(&local->raw_sockets, sk);\n\n\tsk->sk_state = LLCP_BOUND;\n\nput_dev:\n\tnfc_put_device(dev);\n\nerror:\n\trelease_sock(sk);\n\treturn ret;\n}\n\nstatic int llcp_sock_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint ret = 0;\n\n\tpr_debug(\"sk %p backlog %d\\n\", sk, backlog);\n\n\tlock_sock(sk);\n\n\tif ((sock->type != SOCK_SEQPACKET && sock->type != SOCK_STREAM) ||\n\t    sk->sk_state != LLCP_BOUND) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\n\tsk->sk_max_ack_backlog = backlog;\n\tsk->sk_ack_backlog = 0;\n\n\tpr_debug(\"Socket listening\\n\");\n\tsk->sk_state = LLCP_LISTEN;\n\nerror:\n\trelease_sock(sk);\n\n\treturn ret;\n}\n\nstatic int nfc_llcp_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t       sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tu32 opt;\n\tint err = 0;\n\n\tpr_debug(\"%p optname %d\\n\", sk, optname);\n\n\tif (level != SOL_NFC)\n\t\treturn -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase NFC_LLCP_RW:\n\t\tif (sk->sk_state == LLCP_CONNECTED ||\n\t\t    sk->sk_state == LLCP_BOUND ||\n\t\t    sk->sk_state == LLCP_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt > LLCP_MAX_RW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tllcp_sock->rw = (u8) opt;\n\n\t\tbreak;\n\n\tcase NFC_LLCP_MIUX:\n\t\tif (sk->sk_state == LLCP_CONNECTED ||\n\t\t    sk->sk_state == LLCP_BOUND ||\n\t\t    sk->sk_state == LLCP_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt > LLCP_MAX_MIUX) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tllcp_sock->miux = cpu_to_be16((u16) opt);\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\n\tpr_debug(\"%p rw %d miux %d\\n\", llcp_sock,\n\t\t llcp_sock->rw, llcp_sock->miux);\n\n\treturn err;\n}\n\nstatic int nfc_llcp_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tint len, err = 0;\n\tu16 miux, remote_miu;\n\tu8 rw;\n\n\tpr_debug(\"%p optname %d\\n\", sk, optname);\n\n\tif (level != SOL_NFC)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlocal = llcp_sock->local;\n\tif (!local)\n\t\treturn -ENODEV;\n\n\tlen = min_t(u32, len, sizeof(u32));\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase NFC_LLCP_RW:\n\t\trw = llcp_sock->rw > LLCP_MAX_RW ? local->rw : llcp_sock->rw;\n\t\tif (put_user(rw, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase NFC_LLCP_MIUX:\n\t\tmiux = be16_to_cpu(llcp_sock->miux) > LLCP_MAX_MIUX ?\n\t\t\tbe16_to_cpu(local->miux) : be16_to_cpu(llcp_sock->miux);\n\n\t\tif (put_user(miux, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase NFC_LLCP_REMOTE_MIU:\n\t\tremote_miu = llcp_sock->remote_miu > LLCP_MAX_MIU ?\n\t\t\t\tlocal->remote_miu : llcp_sock->remote_miu;\n\n\t\tif (put_user(remote_miu, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase NFC_LLCP_REMOTE_LTO:\n\t\tif (put_user(local->remote_lto / 10, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase NFC_LLCP_REMOTE_RW:\n\t\tif (put_user(llcp_sock->remote_rw, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\treturn err;\n}\n\nvoid nfc_llcp_accept_unlink(struct sock *sk)\n{\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\n\tpr_debug(\"state %d\\n\", sk->sk_state);\n\n\tlist_del_init(&llcp_sock->accept_queue);\n\tsk_acceptq_removed(llcp_sock->parent);\n\tllcp_sock->parent = NULL;\n\n\tsock_put(sk);\n}\n\nvoid nfc_llcp_accept_enqueue(struct sock *parent, struct sock *sk)\n{\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct nfc_llcp_sock *llcp_sock_parent = nfc_llcp_sock(parent);\n\n\t/* Lock will be free from unlink */\n\tsock_hold(sk);\n\n\tlist_add_tail(&llcp_sock->accept_queue,\n\t\t      &llcp_sock_parent->accept_queue);\n\tllcp_sock->parent = parent;\n\tsk_acceptq_added(parent);\n}\n\nstruct sock *nfc_llcp_accept_dequeue(struct sock *parent,\n\t\t\t\t     struct socket *newsock)\n{\n\tstruct nfc_llcp_sock *lsk, *n, *llcp_parent;\n\tstruct sock *sk;\n\n\tllcp_parent = nfc_llcp_sock(parent);\n\n\tlist_for_each_entry_safe(lsk, n, &llcp_parent->accept_queue,\n\t\t\t\t accept_queue) {\n\t\tsk = &lsk->sk;\n\t\tlock_sock(sk);\n\n\t\tif (sk->sk_state == LLCP_CLOSED) {\n\t\t\trelease_sock(sk);\n\t\t\tnfc_llcp_accept_unlink(sk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sk->sk_state == LLCP_CONNECTED || !newsock) {\n\t\t\tlist_del_init(&lsk->accept_queue);\n\t\t\tsock_put(sk);\n\n\t\t\tif (newsock)\n\t\t\t\tsock_graft(sk, newsock);\n\n\t\t\trelease_sock(sk);\n\n\t\t\tpr_debug(\"Returning sk state %d\\n\", sk->sk_state);\n\n\t\t\tsk_acceptq_removed(parent);\n\n\t\t\treturn sk;\n\t\t}\n\n\t\trelease_sock(sk);\n\t}\n\n\treturn NULL;\n}\n\nstatic int llcp_sock_accept(struct socket *sock, struct socket *newsock,\n\t\t\t    int flags, bool kern)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct sock *sk = sock->sk, *new_sk;\n\tlong timeo;\n\tint ret = 0;\n\n\tpr_debug(\"parent %p\\n\", sk);\n\n\tlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\n\n\tif (sk->sk_state != LLCP_LISTEN) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\n\ttimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\n\n\t/* Wait for an incoming connection. */\n\tadd_wait_queue_exclusive(sk_sleep(sk), &wait);\n\twhile (!(new_sk = nfc_llcp_accept_dequeue(sk, newsock))) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tif (!timeo) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\t\ttimeo = schedule_timeout(timeo);\n\t\tlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\tif (ret)\n\t\tgoto error;\n\n\tnewsock->state = SS_CONNECTED;\n\n\tpr_debug(\"new socket %p\\n\", new_sk);\n\nerror:\n\trelease_sock(sk);\n\n\treturn ret;\n}\n\nstatic int llcp_sock_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t     int peer)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_nfc_llcp *, llcp_addr, uaddr);\n\n\tif (llcp_sock == NULL || llcp_sock->dev == NULL)\n\t\treturn -EBADFD;\n\n\tpr_debug(\"%p %d %d %d\\n\", sk, llcp_sock->target_idx,\n\t\t llcp_sock->dsap, llcp_sock->ssap);\n\n\tmemset(llcp_addr, 0, sizeof(*llcp_addr));\n\n\tlock_sock(sk);\n\tif (!llcp_sock->dev) {\n\t\trelease_sock(sk);\n\t\treturn -EBADFD;\n\t}\n\tllcp_addr->sa_family = AF_NFC;\n\tllcp_addr->dev_idx = llcp_sock->dev->idx;\n\tllcp_addr->target_idx = llcp_sock->target_idx;\n\tllcp_addr->nfc_protocol = llcp_sock->nfc_protocol;\n\tllcp_addr->dsap = llcp_sock->dsap;\n\tllcp_addr->ssap = llcp_sock->ssap;\n\tllcp_addr->service_name_len = llcp_sock->service_name_len;\n\tmemcpy(llcp_addr->service_name, llcp_sock->service_name,\n\t       llcp_addr->service_name_len);\n\trelease_sock(sk);\n\n\treturn sizeof(struct sockaddr_nfc_llcp);\n}\n\nstatic inline __poll_t llcp_accept_poll(struct sock *parent)\n{\n\tstruct nfc_llcp_sock *llcp_sock, *parent_sock;\n\tstruct sock *sk;\n\n\tparent_sock = nfc_llcp_sock(parent);\n\n\tlist_for_each_entry(llcp_sock, &parent_sock->accept_queue,\n\t\t\t    accept_queue) {\n\t\tsk = &llcp_sock->sk;\n\n\t\tif (sk->sk_state == LLCP_CONNECTED)\n\t\t\treturn EPOLLIN | EPOLLRDNORM;\n\t}\n\n\treturn 0;\n}\n\nstatic __poll_t llcp_sock_poll(struct file *file, struct socket *sock,\n\t\t\t\t   poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\t__poll_t mask = 0;\n\n\tpr_debug(\"%p\\n\", sk);\n\n\tsock_poll_wait(file, sock, wait);\n\n\tif (sk->sk_state == LLCP_LISTEN)\n\t\treturn llcp_accept_poll(sk);\n\n\tif (sk->sk_err || !skb_queue_empty_lockless(&sk->sk_error_queue))\n\t\tmask |= EPOLLERR |\n\t\t\t(sock_flag(sk, SOCK_SELECT_ERR_QUEUE) ? EPOLLPRI : 0);\n\n\tif (!skb_queue_empty_lockless(&sk->sk_receive_queue))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\tif (sk->sk_state == LLCP_CLOSED)\n\t\tmask |= EPOLLHUP;\n\n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\tmask |= EPOLLRDHUP | EPOLLIN | EPOLLRDNORM;\n\n\tif (sk->sk_shutdown == SHUTDOWN_MASK)\n\t\tmask |= EPOLLHUP;\n\n\tif (sock_writeable(sk) && sk->sk_state == LLCP_CONNECTED)\n\t\tmask |= EPOLLOUT | EPOLLWRNORM | EPOLLWRBAND;\n\telse\n\t\tsk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\n\tpr_debug(\"mask 0x%x\\n\", mask);\n\n\treturn mask;\n}\n\nstatic int llcp_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tint err = 0;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tpr_debug(\"%p\\n\", sk);\n\n\tlocal = llcp_sock->local;\n\tif (local == NULL) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tlock_sock(sk);\n\n\t/* Send a DISC */\n\tif (sk->sk_state == LLCP_CONNECTED)\n\t\tnfc_llcp_send_disconnect(llcp_sock);\n\n\tif (sk->sk_state == LLCP_LISTEN) {\n\t\tstruct nfc_llcp_sock *lsk, *n;\n\t\tstruct sock *accept_sk;\n\n\t\tlist_for_each_entry_safe(lsk, n, &llcp_sock->accept_queue,\n\t\t\t\t\t accept_queue) {\n\t\t\taccept_sk = &lsk->sk;\n\t\t\tlock_sock(accept_sk);\n\n\t\t\tnfc_llcp_send_disconnect(lsk);\n\t\t\tnfc_llcp_accept_unlink(accept_sk);\n\n\t\t\trelease_sock(accept_sk);\n\t\t}\n\t}\n\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_llcp_sock_unlink(&local->raw_sockets, sk);\n\telse\n\t\tnfc_llcp_sock_unlink(&local->sockets, sk);\n\n\tif (llcp_sock->reserved_ssap < LLCP_SAP_MAX)\n\t\tnfc_llcp_put_ssap(llcp_sock->local, llcp_sock->ssap);\n\n\trelease_sock(sk);\n\nout:\n\tsock_orphan(sk);\n\tsock_put(sk);\n\n\treturn err;\n}\n\nstatic int llcp_sock_connect(struct socket *sock, struct sockaddr *_addr,\n\t\t\t     int len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct sockaddr_nfc_llcp *addr = (struct sockaddr_nfc_llcp *)_addr;\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tint ret = 0;\n\n\tpr_debug(\"sock %p sk %p flags 0x%x\\n\", sock, sk, flags);\n\n\tif (!addr || len < sizeof(*addr) || addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\n\tif (addr->service_name_len == 0 && addr->dsap == 0)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"addr dev_idx=%u target_idx=%u protocol=%u\\n\", addr->dev_idx,\n\t\t addr->target_idx, addr->nfc_protocol);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == LLCP_CONNECTED) {\n\t\tret = -EISCONN;\n\t\tgoto error;\n\t}\n\tif (sk->sk_state == LLCP_CONNECTING) {\n\t\tret = -EINPROGRESS;\n\t\tgoto error;\n\t}\n\n\tdev = nfc_get_device(addr->dev_idx);\n\tif (dev == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\n\tdevice_lock(&dev->dev);\n\tif (dev->dep_link_up == false) {\n\t\tret = -ENOLINK;\n\t\tdevice_unlock(&dev->dev);\n\t\tgoto put_dev;\n\t}\n\tdevice_unlock(&dev->dev);\n\n\tif (local->rf_mode == NFC_RF_INITIATOR &&\n\t    addr->target_idx != local->target_idx) {\n\t\tret = -ENOLINK;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = nfc_llcp_local_get(local);\n\tllcp_sock->ssap = nfc_llcp_get_local_ssap(local);\n\tif (llcp_sock->ssap == LLCP_SAP_MAX) {\n\t\tret = -ENOMEM;\n\t\tgoto sock_llcp_put_local;\n\t}\n\n\tllcp_sock->reserved_ssap = llcp_sock->ssap;\n\n\tif (addr->service_name_len == 0)\n\t\tllcp_sock->dsap = addr->dsap;\n\telse\n\t\tllcp_sock->dsap = LLCP_SAP_SDP;\n\tllcp_sock->nfc_protocol = addr->nfc_protocol;\n\tllcp_sock->service_name_len = min_t(unsigned int,\n\t\t\t\t\t    addr->service_name_len,\n\t\t\t\t\t    NFC_LLCP_MAX_SERVICE_NAME);\n\tllcp_sock->service_name = kmemdup(addr->service_name,\n\t\t\t\t\t  llcp_sock->service_name_len,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!llcp_sock->service_name) {\n\t\tret = -ENOMEM;\n\t\tgoto sock_llcp_release;\n\t}\n\n\tnfc_llcp_sock_link(&local->connecting_sockets, sk);\n\n\tret = nfc_llcp_send_connect(llcp_sock);\n\tif (ret)\n\t\tgoto sock_unlink;\n\n\tsk->sk_state = LLCP_CONNECTING;\n\n\tret = sock_wait_state(sk, LLCP_CONNECTED,\n\t\t\t      sock_sndtimeo(sk, flags & O_NONBLOCK));\n\tif (ret && ret != -EINPROGRESS)\n\t\tgoto sock_unlink;\n\n\trelease_sock(sk);\n\n\treturn ret;\n\nsock_unlink:\n\tnfc_llcp_sock_unlink(&local->connecting_sockets, sk);\n\tkfree(llcp_sock->service_name);\n\tllcp_sock->service_name = NULL;\n\nsock_llcp_release:\n\tnfc_llcp_put_ssap(local, llcp_sock->ssap);\n\nsock_llcp_put_local:\n\tnfc_llcp_local_put(llcp_sock->local);\n\tllcp_sock->local = NULL;\n\tllcp_sock->dev = NULL;\n\nput_dev:\n\tnfc_put_device(dev);\n\nerror:\n\trelease_sock(sk);\n\treturn ret;\n}\n\nstatic int llcp_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t     size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tint ret;\n\n\tpr_debug(\"sock %p sk %p\", sock, sk);\n\n\tret = sock_error(sk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tlock_sock(sk);\n\n\tif (!llcp_sock->local) {\n\t\trelease_sock(sk);\n\t\treturn -ENODEV;\n\t}\n\n\tif (sk->sk_type == SOCK_DGRAM) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_nfc_llcp *, addr,\n\t\t\t\t msg->msg_name);\n\n\t\tif (msg->msg_namelen < sizeof(*addr)) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trelease_sock(sk);\n\n\t\treturn nfc_llcp_send_ui_frame(llcp_sock, addr->dsap, addr->ssap,\n\t\t\t\t\t      msg, len);\n\t}\n\n\tif (sk->sk_state != LLCP_CONNECTED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\n\trelease_sock(sk);\n\n\treturn nfc_llcp_send_i_frame(llcp_sock, msg, len);\n}\n\nstatic int llcp_sock_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t     size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tunsigned int copied, rlen;\n\tstruct sk_buff *skb, *cskb;\n\tint err = 0;\n\n\tpr_debug(\"%p %zu\\n\", sk, len);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == LLCP_CLOSED &&\n\t    skb_queue_empty(&sk->sk_receive_queue)) {\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\n\trelease_sock(sk);\n\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb) {\n\t\tpr_err(\"Recv datagram failed state %d %d %d\",\n\t\t       sk->sk_state, err, sock_error(sk));\n\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\n\t\treturn err;\n\t}\n\n\trlen = skb->len;\t\t/* real length of skb */\n\tcopied = min_t(unsigned int, rlen, len);\n\n\tcskb = skb;\n\tif (skb_copy_datagram_msg(cskb, 0, msg, copied)) {\n\t\tif (!(flags & MSG_PEEK))\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\treturn -EFAULT;\n\t}\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\tif (sk->sk_type == SOCK_DGRAM && msg->msg_name) {\n\t\tstruct nfc_llcp_ui_cb *ui_cb = nfc_llcp_ui_skb_cb(skb);\n\t\tDECLARE_SOCKADDR(struct sockaddr_nfc_llcp *, sockaddr,\n\t\t\t\t msg->msg_name);\n\n\t\tmsg->msg_namelen = sizeof(struct sockaddr_nfc_llcp);\n\n\t\tpr_debug(\"Datagram socket %d %d\\n\", ui_cb->dsap, ui_cb->ssap);\n\n\t\tmemset(sockaddr, 0, sizeof(*sockaddr));\n\t\tsockaddr->sa_family = AF_NFC;\n\t\tsockaddr->nfc_protocol = NFC_PROTO_NFC_DEP;\n\t\tsockaddr->dsap = ui_cb->dsap;\n\t\tsockaddr->ssap = ui_cb->ssap;\n\t}\n\n\t/* Mark read part of skb as used */\n\tif (!(flags & MSG_PEEK)) {\n\n\t\t/* SOCK_STREAM: re-queue skb if it contains unreceived data */\n\t\tif (sk->sk_type == SOCK_STREAM ||\n\t\t    sk->sk_type == SOCK_DGRAM ||\n\t\t    sk->sk_type == SOCK_RAW) {\n\t\t\tskb_pull(skb, copied);\n\t\t\tif (skb->len) {\n\t\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\tkfree_skb(skb);\n\t}\n\n\t/* XXX Queue backlogged skbs */\n\ndone:\n\t/* SOCK_SEQPACKET: return real length if MSG_TRUNC is set */\n\tif (sk->sk_type == SOCK_SEQPACKET && (flags & MSG_TRUNC))\n\t\tcopied = rlen;\n\n\treturn copied;\n}\n\nstatic const struct proto_ops llcp_sock_ops = {\n\t.family         = PF_NFC,\n\t.owner          = THIS_MODULE,\n\t.bind           = llcp_sock_bind,\n\t.connect        = llcp_sock_connect,\n\t.release        = llcp_sock_release,\n\t.socketpair     = sock_no_socketpair,\n\t.accept         = llcp_sock_accept,\n\t.getname        = llcp_sock_getname,\n\t.poll           = llcp_sock_poll,\n\t.ioctl          = sock_no_ioctl,\n\t.listen         = llcp_sock_listen,\n\t.shutdown       = sock_no_shutdown,\n\t.setsockopt     = nfc_llcp_setsockopt,\n\t.getsockopt     = nfc_llcp_getsockopt,\n\t.sendmsg        = llcp_sock_sendmsg,\n\t.recvmsg        = llcp_sock_recvmsg,\n\t.mmap           = sock_no_mmap,\n};\n\nstatic const struct proto_ops llcp_rawsock_ops = {\n\t.family         = PF_NFC,\n\t.owner          = THIS_MODULE,\n\t.bind           = llcp_raw_sock_bind,\n\t.connect        = sock_no_connect,\n\t.release        = llcp_sock_release,\n\t.socketpair     = sock_no_socketpair,\n\t.accept         = sock_no_accept,\n\t.getname        = llcp_sock_getname,\n\t.poll           = llcp_sock_poll,\n\t.ioctl          = sock_no_ioctl,\n\t.listen         = sock_no_listen,\n\t.shutdown       = sock_no_shutdown,\n\t.sendmsg        = sock_no_sendmsg,\n\t.recvmsg        = llcp_sock_recvmsg,\n\t.mmap           = sock_no_mmap,\n};\n\nstatic void llcp_sock_destruct(struct sock *sk)\n{\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\n\tpr_debug(\"%p\\n\", sk);\n\n\tif (sk->sk_state == LLCP_CONNECTED)\n\t\tnfc_put_device(llcp_sock->dev);\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\n\tnfc_llcp_sock_free(llcp_sock);\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Freeing alive NFC LLCP socket %p\\n\", sk);\n\t\treturn;\n\t}\n}\n\nstruct sock *nfc_llcp_sock_alloc(struct socket *sock, int type, gfp_t gfp, int kern)\n{\n\tstruct sock *sk;\n\tstruct nfc_llcp_sock *llcp_sock;\n\n\tsk = sk_alloc(&init_net, PF_NFC, gfp, &llcp_sock_proto, kern);\n\tif (!sk)\n\t\treturn NULL;\n\n\tllcp_sock = nfc_llcp_sock(sk);\n\n\tsock_init_data(sock, sk);\n\tsk->sk_state = LLCP_CLOSED;\n\tsk->sk_protocol = NFC_SOCKPROTO_LLCP;\n\tsk->sk_type = type;\n\tsk->sk_destruct = llcp_sock_destruct;\n\n\tllcp_sock->ssap = 0;\n\tllcp_sock->dsap = LLCP_SAP_SDP;\n\tllcp_sock->rw = LLCP_MAX_RW + 1;\n\tllcp_sock->miux = cpu_to_be16(LLCP_MAX_MIUX + 1);\n\tllcp_sock->send_n = llcp_sock->send_ack_n = 0;\n\tllcp_sock->recv_n = llcp_sock->recv_ack_n = 0;\n\tllcp_sock->remote_ready = 1;\n\tllcp_sock->reserved_ssap = LLCP_SAP_MAX;\n\tnfc_llcp_socket_remote_param_init(llcp_sock);\n\tskb_queue_head_init(&llcp_sock->tx_queue);\n\tskb_queue_head_init(&llcp_sock->tx_pending_queue);\n\tINIT_LIST_HEAD(&llcp_sock->accept_queue);\n\n\tif (sock != NULL)\n\t\tsock->state = SS_UNCONNECTED;\n\n\treturn sk;\n}\n\nvoid nfc_llcp_sock_free(struct nfc_llcp_sock *sock)\n{\n\tkfree(sock->service_name);\n\n\tskb_queue_purge(&sock->tx_queue);\n\tskb_queue_purge(&sock->tx_pending_queue);\n\n\tlist_del_init(&sock->accept_queue);\n\n\tsock->parent = NULL;\n\n\tnfc_llcp_local_put(sock->local);\n}\n\nstatic int llcp_sock_create(struct net *net, struct socket *sock,\n\t\t\t    const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\n\tpr_debug(\"%p\\n\", sock);\n\n\tif (sock->type != SOCK_STREAM &&\n\t    sock->type != SOCK_DGRAM &&\n\t    sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW) {\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\treturn -EPERM;\n\t\tsock->ops = &llcp_rawsock_ops;\n\t} else {\n\t\tsock->ops = &llcp_sock_ops;\n\t}\n\n\tsk = nfc_llcp_sock_alloc(sock, sock->type, GFP_ATOMIC, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic const struct nfc_protocol llcp_nfc_proto = {\n\t.id\t  = NFC_SOCKPROTO_LLCP,\n\t.proto    = &llcp_sock_proto,\n\t.owner    = THIS_MODULE,\n\t.create   = llcp_sock_create\n};\n\nint __init nfc_llcp_sock_init(void)\n{\n\treturn nfc_proto_register(&llcp_nfc_proto);\n}\n\nvoid nfc_llcp_sock_exit(void)\n{\n\tnfc_proto_unregister(&llcp_nfc_proto);\n}\n", "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Copyright (C) 2011 Instituto Nokia de Tecnologia\n *\n * Authors:\n *    Lauro Ramos Venancio <lauro.venancio@openbossa.org>\n *    Aloisio Almeida Jr <aloisio.almeida@openbossa.org>\n *\n * Vendor commands implementation based on net/wireless/nl80211.c\n * which is:\n *\n * Copyright 2006-2010\tJohannes Berg <johannes@sipsolutions.net>\n * Copyright 2013-2014  Intel Mobile Communications GmbH\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": %s: \" fmt, __func__\n\n#include <net/genetlink.h>\n#include <linux/nfc.h>\n#include <linux/slab.h>\n\n#include \"nfc.h\"\n#include \"llcp.h\"\n\nstatic const struct genl_multicast_group nfc_genl_mcgrps[] = {\n\t{ .name = NFC_GENL_MCAST_EVENT_NAME, },\n};\n\nstatic struct genl_family nfc_genl_family;\nstatic const struct nla_policy nfc_genl_policy[NFC_ATTR_MAX + 1] = {\n\t[NFC_ATTR_DEVICE_INDEX] = { .type = NLA_U32 },\n\t[NFC_ATTR_DEVICE_NAME] = { .type = NLA_STRING,\n\t\t\t\t.len = NFC_DEVICE_NAME_MAXSIZE },\n\t[NFC_ATTR_PROTOCOLS] = { .type = NLA_U32 },\n\t[NFC_ATTR_TARGET_INDEX] = { .type = NLA_U32 },\n\t[NFC_ATTR_COMM_MODE] = { .type = NLA_U8 },\n\t[NFC_ATTR_RF_MODE] = { .type = NLA_U8 },\n\t[NFC_ATTR_DEVICE_POWERED] = { .type = NLA_U8 },\n\t[NFC_ATTR_IM_PROTOCOLS] = { .type = NLA_U32 },\n\t[NFC_ATTR_TM_PROTOCOLS] = { .type = NLA_U32 },\n\t[NFC_ATTR_LLC_PARAM_LTO] = { .type = NLA_U8 },\n\t[NFC_ATTR_LLC_PARAM_RW] = { .type = NLA_U8 },\n\t[NFC_ATTR_LLC_PARAM_MIUX] = { .type = NLA_U16 },\n\t[NFC_ATTR_LLC_SDP] = { .type = NLA_NESTED },\n\t[NFC_ATTR_FIRMWARE_NAME] = { .type = NLA_STRING,\n\t\t\t\t     .len = NFC_FIRMWARE_NAME_MAXSIZE },\n\t[NFC_ATTR_SE_INDEX] = { .type = NLA_U32 },\n\t[NFC_ATTR_SE_APDU] = { .type = NLA_BINARY },\n\t[NFC_ATTR_VENDOR_ID] = { .type = NLA_U32 },\n\t[NFC_ATTR_VENDOR_SUBCMD] = { .type = NLA_U32 },\n\t[NFC_ATTR_VENDOR_DATA] = { .type = NLA_BINARY },\n\n};\n\nstatic const struct nla_policy nfc_sdp_genl_policy[NFC_SDP_ATTR_MAX + 1] = {\n\t[NFC_SDP_ATTR_URI] = { .type = NLA_STRING,\n\t\t\t       .len = U8_MAX - 4 },\n\t[NFC_SDP_ATTR_SAP] = { .type = NLA_U8 },\n};\n\nstatic int nfc_genl_send_target(struct sk_buff *msg, struct nfc_target *target,\n\t\t\t\tstruct netlink_callback *cb, int flags)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(msg, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\t  &nfc_genl_family, flags, NFC_CMD_GET_TARGET);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (nla_put_u32(msg, NFC_ATTR_TARGET_INDEX, target->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_PROTOCOLS, target->supported_protocols) ||\n\t    nla_put_u16(msg, NFC_ATTR_TARGET_SENS_RES, target->sens_res) ||\n\t    nla_put_u8(msg, NFC_ATTR_TARGET_SEL_RES, target->sel_res))\n\t\tgoto nla_put_failure;\n\tif (target->nfcid1_len > 0 &&\n\t    nla_put(msg, NFC_ATTR_TARGET_NFCID1, target->nfcid1_len,\n\t\t    target->nfcid1))\n\t\tgoto nla_put_failure;\n\tif (target->sensb_res_len > 0 &&\n\t    nla_put(msg, NFC_ATTR_TARGET_SENSB_RES, target->sensb_res_len,\n\t\t    target->sensb_res))\n\t\tgoto nla_put_failure;\n\tif (target->sensf_res_len > 0 &&\n\t    nla_put(msg, NFC_ATTR_TARGET_SENSF_RES, target->sensf_res_len,\n\t\t    target->sensf_res))\n\t\tgoto nla_put_failure;\n\n\tif (target->is_iso15693) {\n\t\tif (nla_put_u8(msg, NFC_ATTR_TARGET_ISO15693_DSFID,\n\t\t\t       target->iso15693_dsfid) ||\n\t\t    nla_put(msg, NFC_ATTR_TARGET_ISO15693_UID,\n\t\t\t    sizeof(target->iso15693_uid), target->iso15693_uid))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic struct nfc_dev *__get_device_from_cb(struct netlink_callback *cb)\n{\n\tconst struct genl_dumpit_info *info = genl_dumpit_info(cb);\n\tstruct nfc_dev *dev;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn dev;\n}\n\nstatic int nfc_genl_dump_targets(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tint i = cb->args[0];\n\tstruct nfc_dev *dev = (struct nfc_dev *) cb->args[1];\n\tint rc;\n\n\tif (!dev) {\n\t\tdev = __get_device_from_cb(cb);\n\t\tif (IS_ERR(dev))\n\t\t\treturn PTR_ERR(dev);\n\n\t\tcb->args[1] = (long) dev;\n\t}\n\n\tdevice_lock(&dev->dev);\n\n\tcb->seq = dev->targets_generation;\n\n\twhile (i < dev->n_targets) {\n\t\trc = nfc_genl_send_target(skb, &dev->targets[i], cb,\n\t\t\t\t\t  NLM_F_MULTI);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\ti++;\n\t}\n\n\tdevice_unlock(&dev->dev);\n\n\tcb->args[0] = i;\n\n\treturn skb->len;\n}\n\nstatic int nfc_genl_dump_targets_done(struct netlink_callback *cb)\n{\n\tstruct nfc_dev *dev = (struct nfc_dev *) cb->args[1];\n\n\tif (dev)\n\t\tnfc_put_device(dev);\n\n\treturn 0;\n}\n\nint nfc_genl_targets_found(struct nfc_dev *dev)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tdev->genl_data.poll_req_portid = 0;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_TARGETS_FOUND);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_target_lost(struct nfc_dev *dev, u32 target_idx)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_TARGET_LOST);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_string(msg, NFC_ATTR_DEVICE_NAME, nfc_device_name(dev)) ||\n\t    nla_put_u32(msg, NFC_ATTR_TARGET_INDEX, target_idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_tm_activated(struct nfc_dev *dev, u32 protocol)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_TM_ACTIVATED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(msg, NFC_ATTR_TM_PROTOCOLS, protocol))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_tm_deactivated(struct nfc_dev *dev)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_TM_DEACTIVATED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_setup_device_added(struct nfc_dev *dev, struct sk_buff *msg)\n{\n\tif (nla_put_string(msg, NFC_ATTR_DEVICE_NAME, nfc_device_name(dev)) ||\n\t    nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_PROTOCOLS, dev->supported_protocols) ||\n\t    nla_put_u8(msg, NFC_ATTR_DEVICE_POWERED, dev->dev_up) ||\n\t    nla_put_u8(msg, NFC_ATTR_RF_MODE, dev->rf_mode))\n\t\treturn -1;\n\treturn 0;\n}\n\nint nfc_genl_device_added(struct nfc_dev *dev)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_DEVICE_ADDED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nfc_genl_setup_device_added(dev, msg))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_device_removed(struct nfc_dev *dev)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_DEVICE_REMOVED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_llc_send_sdres(struct nfc_dev *dev, struct hlist_head *sdres_list)\n{\n\tstruct sk_buff *msg;\n\tstruct nlattr *sdp_attr, *uri_attr;\n\tstruct nfc_llcp_sdp_tlv *sdres;\n\tstruct hlist_node *n;\n\tvoid *hdr;\n\tint rc = -EMSGSIZE;\n\tint i;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_LLC_SDRES);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tsdp_attr = nla_nest_start_noflag(msg, NFC_ATTR_LLC_SDP);\n\tif (sdp_attr == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto nla_put_failure;\n\t}\n\n\ti = 1;\n\thlist_for_each_entry_safe(sdres, n, sdres_list, node) {\n\t\tpr_debug(\"uri: %s, sap: %d\\n\", sdres->uri, sdres->sap);\n\n\t\turi_attr = nla_nest_start_noflag(msg, i++);\n\t\tif (uri_attr == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto nla_put_failure;\n\t\t}\n\n\t\tif (nla_put_u8(msg, NFC_SDP_ATTR_SAP, sdres->sap))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_string(msg, NFC_SDP_ATTR_URI, sdres->uri))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, uri_attr);\n\n\t\thlist_del(&sdres->node);\n\n\t\tnfc_llcp_free_sdp_tlv(sdres);\n\t}\n\n\tnla_nest_end(msg, sdp_attr);\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\n\tnfc_llcp_free_sdp_tlv_list(sdres_list);\n\n\treturn rc;\n}\n\nint nfc_genl_se_added(struct nfc_dev *dev, u32 se_idx, u16 type)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_SE_ADDED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx) ||\n\t    nla_put_u8(msg, NFC_ATTR_SE_TYPE, type))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_se_removed(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_SE_REMOVED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_se_transaction(struct nfc_dev *dev, u8 se_idx,\n\t\t\t    struct nfc_evt_transaction *evt_transaction)\n{\n\tstruct nfc_se *se;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_SE_TRANSACTION);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx) ||\n\t    nla_put_u8(msg, NFC_ATTR_SE_TYPE, se->type) ||\n\t    nla_put(msg, NFC_ATTR_SE_AID, evt_transaction->aid_len,\n\t\t    evt_transaction->aid) ||\n\t    nla_put(msg, NFC_ATTR_SE_PARAMS, evt_transaction->params_len,\n\t\t    evt_transaction->params))\n\t\tgoto nla_put_failure;\n\n\t/* evt_transaction is no more used */\n\tdevm_kfree(&dev->dev, evt_transaction);\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\t/* evt_transaction is no more used */\n\tdevm_kfree(&dev->dev, evt_transaction);\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_se_connectivity(struct nfc_dev *dev, u8 se_idx)\n{\n\tconst struct nfc_se *se;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_SE_CONNECTIVITY);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx) ||\n\t    nla_put_u8(msg, NFC_ATTR_SE_TYPE, se->type))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_send_device(struct sk_buff *msg, struct nfc_dev *dev,\n\t\t\t\tu32 portid, u32 seq,\n\t\t\t\tstruct netlink_callback *cb,\n\t\t\t\tint flags)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(msg, portid, seq, &nfc_genl_family, flags,\n\t\t\t  NFC_CMD_GET_DEVICE);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (cb)\n\t\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (nfc_genl_setup_device_added(dev, msg))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_dump_devices(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tstruct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];\n\tstruct nfc_dev *dev = (struct nfc_dev *) cb->args[1];\n\tbool first_call = false;\n\n\tif (!iter) {\n\t\tfirst_call = true;\n\t\titer = kmalloc(sizeof(struct class_dev_iter), GFP_KERNEL);\n\t\tif (!iter)\n\t\t\treturn -ENOMEM;\n\t\tcb->args[0] = (long) iter;\n\t}\n\n\tmutex_lock(&nfc_devlist_mutex);\n\n\tcb->seq = nfc_devlist_generation;\n\n\tif (first_call) {\n\t\tnfc_device_iter_init(iter);\n\t\tdev = nfc_device_iter_next(iter);\n\t}\n\n\twhile (dev) {\n\t\tint rc;\n\n\t\trc = nfc_genl_send_device(skb, dev, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t  cb->nlh->nlmsg_seq, cb, NLM_F_MULTI);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\tdev = nfc_device_iter_next(iter);\n\t}\n\n\tmutex_unlock(&nfc_devlist_mutex);\n\n\tcb->args[1] = (long) dev;\n\n\treturn skb->len;\n}\n\nstatic int nfc_genl_dump_devices_done(struct netlink_callback *cb)\n{\n\tstruct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];\n\n\tif (iter) {\n\t\tnfc_device_iter_exit(iter);\n\t\tkfree(iter);\n\t}\n\n\treturn 0;\n}\n\nint nfc_genl_dep_link_up_event(struct nfc_dev *dev, u32 target_idx,\n\t\t\t       u8 comm_mode, u8 rf_mode)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tpr_debug(\"DEP link is up\\n\");\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0, NFC_CMD_DEP_LINK_UP);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\tif (rf_mode == NFC_RF_INITIATOR &&\n\t    nla_put_u32(msg, NFC_ATTR_TARGET_INDEX, target_idx))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u8(msg, NFC_ATTR_COMM_MODE, comm_mode) ||\n\t    nla_put_u8(msg, NFC_ATTR_RF_MODE, rf_mode))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tdev->dep_link_up = true;\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_dep_link_down_event(struct nfc_dev *dev)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tpr_debug(\"DEP link is down\\n\");\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_DEP_LINK_DOWN);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_get_device(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tstruct nfc_dev *dev;\n\tu32 idx;\n\tint rc = -ENOBUFS;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\trc = -ENOMEM;\n\t\tgoto out_putdev;\n\t}\n\n\trc = nfc_genl_send_device(msg, dev, info->snd_portid, info->snd_seq,\n\t\t\t\t  NULL, 0);\n\tif (rc < 0)\n\t\tgoto out_free;\n\n\tnfc_put_device(dev);\n\n\treturn genlmsg_reply(msg, info);\n\nout_free:\n\tnlmsg_free(msg);\nout_putdev:\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_dev_up(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_dev_up(dev);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_dev_down(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_dev_down(dev);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_start_poll(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\tu32 im_protocols = 0, tm_protocols = 0;\n\n\tpr_debug(\"Poll start\\n\");\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    ((!info->attrs[NFC_ATTR_IM_PROTOCOLS] &&\n\t      !info->attrs[NFC_ATTR_PROTOCOLS]) &&\n\t      !info->attrs[NFC_ATTR_TM_PROTOCOLS]))\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tif (info->attrs[NFC_ATTR_TM_PROTOCOLS])\n\t\ttm_protocols = nla_get_u32(info->attrs[NFC_ATTR_TM_PROTOCOLS]);\n\n\tif (info->attrs[NFC_ATTR_IM_PROTOCOLS])\n\t\tim_protocols = nla_get_u32(info->attrs[NFC_ATTR_IM_PROTOCOLS]);\n\telse if (info->attrs[NFC_ATTR_PROTOCOLS])\n\t\tim_protocols = nla_get_u32(info->attrs[NFC_ATTR_PROTOCOLS]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&dev->genl_data.genl_data_mutex);\n\n\trc = nfc_start_poll(dev, im_protocols, tm_protocols);\n\tif (!rc)\n\t\tdev->genl_data.poll_req_portid = info->snd_portid;\n\n\tmutex_unlock(&dev->genl_data.genl_data_mutex);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_stop_poll(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tdevice_lock(&dev->dev);\n\n\tif (!dev->polling) {\n\t\tdevice_unlock(&dev->dev);\n\t\tnfc_put_device(dev);\n\t\treturn -EINVAL;\n\t}\n\n\tdevice_unlock(&dev->dev);\n\n\tmutex_lock(&dev->genl_data.genl_data_mutex);\n\n\tif (dev->genl_data.poll_req_portid != info->snd_portid) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\trc = nfc_stop_poll(dev);\n\tdev->genl_data.poll_req_portid = 0;\n\nout:\n\tmutex_unlock(&dev->genl_data.genl_data_mutex);\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_activate_target(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx, protocol;\n\tint rc;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_TARGET_INDEX] ||\n\t    !info->attrs[NFC_ATTR_PROTOCOLS])\n\t\treturn -EINVAL;\n\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\tprotocol = nla_get_u32(info->attrs[NFC_ATTR_PROTOCOLS]);\n\n\tnfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\trc = nfc_activate_target(dev, target_idx, protocol);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx;\n\tint rc;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_TARGET_INDEX])\n\t\treturn -EINVAL;\n\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\n\trc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_dep_link_up(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc, tgt_idx;\n\tu32 idx;\n\tu8 comm;\n\n\tpr_debug(\"DEP link up\\n\");\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_COMM_MODE])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tif (!info->attrs[NFC_ATTR_TARGET_INDEX])\n\t\ttgt_idx = NFC_TARGET_IDX_ANY;\n\telse\n\t\ttgt_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\n\tcomm = nla_get_u8(info->attrs[NFC_ATTR_COMM_MODE]);\n\n\tif (comm != NFC_COMM_ACTIVE && comm != NFC_COMM_PASSIVE)\n\t\treturn -EINVAL;\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_dep_link_up(dev, tgt_idx, comm);\n\n\tnfc_put_device(dev);\n\n\treturn rc;\n}\n\nstatic int nfc_genl_dep_link_down(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_TARGET_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_dep_link_down(dev);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_send_params(struct sk_buff *msg,\n\t\t\t\tstruct nfc_llcp_local *local,\n\t\t\t\tu32 portid, u32 seq)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(msg, portid, seq, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_LLC_GET_PARAMS);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, local->dev->idx) ||\n\t    nla_put_u8(msg, NFC_ATTR_LLC_PARAM_LTO, local->lto) ||\n\t    nla_put_u8(msg, NFC_ATTR_LLC_PARAM_RW, local->rw) ||\n\t    nla_put_u16(msg, NFC_ATTR_LLC_PARAM_MIUX, be16_to_cpu(local->miux)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_llc_get_params(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tint rc = 0;\n\tstruct sk_buff *msg = NULL;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_FIRMWARE_NAME])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tdevice_lock(&dev->dev);\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\trc = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\trc = nfc_genl_send_params(msg, local, info->snd_portid, info->snd_seq);\n\nexit:\n\tdevice_unlock(&dev->dev);\n\n\tnfc_put_device(dev);\n\n\tif (rc < 0) {\n\t\tif (msg)\n\t\t\tnlmsg_free(msg);\n\n\t\treturn rc;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int nfc_genl_llc_set_params(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tu8 rw = 0;\n\tu16 miux = 0;\n\tu32 idx;\n\tint rc = 0;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    (!info->attrs[NFC_ATTR_LLC_PARAM_LTO] &&\n\t     !info->attrs[NFC_ATTR_LLC_PARAM_RW] &&\n\t     !info->attrs[NFC_ATTR_LLC_PARAM_MIUX]))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_RW]) {\n\t\trw = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_RW]);\n\n\t\tif (rw > LLCP_MAX_RW)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_MIUX]) {\n\t\tmiux = nla_get_u16(info->attrs[NFC_ATTR_LLC_PARAM_MIUX]);\n\n\t\tif (miux > LLCP_MAX_MIUX)\n\t\t\treturn -EINVAL;\n\t}\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tdevice_lock(&dev->dev);\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_LTO]) {\n\t\tif (dev->dep_link_up) {\n\t\t\trc = -EINPROGRESS;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tlocal->lto = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_LTO]);\n\t}\n\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_RW])\n\t\tlocal->rw = rw;\n\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_MIUX])\n\t\tlocal->miux = cpu_to_be16(miux);\n\nexit:\n\tdevice_unlock(&dev->dev);\n\n\tnfc_put_device(dev);\n\n\treturn rc;\n}\n\nstatic int nfc_genl_llc_sdreq(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tstruct nlattr *attr, *sdp_attrs[NFC_SDP_ATTR_MAX+1];\n\tu32 idx;\n\tu8 tid;\n\tchar *uri;\n\tint rc = 0, rem;\n\tsize_t uri_len, tlvs_len;\n\tstruct hlist_head sdreq_list;\n\tstruct nfc_llcp_sdp_tlv *sdreq;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_LLC_SDP])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->dep_link_up == false) {\n\t\trc = -ENOLINK;\n\t\tgoto exit;\n\t}\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tINIT_HLIST_HEAD(&sdreq_list);\n\n\ttlvs_len = 0;\n\n\tnla_for_each_nested(attr, info->attrs[NFC_ATTR_LLC_SDP], rem) {\n\t\trc = nla_parse_nested_deprecated(sdp_attrs, NFC_SDP_ATTR_MAX,\n\t\t\t\t\t\t attr, nfc_sdp_genl_policy,\n\t\t\t\t\t\t info->extack);\n\n\t\tif (rc != 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (!sdp_attrs[NFC_SDP_ATTR_URI])\n\t\t\tcontinue;\n\n\t\turi_len = nla_len(sdp_attrs[NFC_SDP_ATTR_URI]);\n\t\tif (uri_len == 0)\n\t\t\tcontinue;\n\n\t\turi = nla_data(sdp_attrs[NFC_SDP_ATTR_URI]);\n\t\tif (uri == NULL || *uri == 0)\n\t\t\tcontinue;\n\n\t\ttid = local->sdreq_next_tid++;\n\n\t\tsdreq = nfc_llcp_build_sdreq_tlv(tid, uri, uri_len);\n\t\tif (sdreq == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\n\t\ttlvs_len += sdreq->tlv_len;\n\n\t\thlist_add_head(&sdreq->node, &sdreq_list);\n\t}\n\n\tif (hlist_empty(&sdreq_list)) {\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\trc = nfc_llcp_send_snl_sdreq(local, &sdreq_list, tlvs_len);\nexit:\n\tdevice_unlock(&dev->dev);\n\n\tnfc_put_device(dev);\n\n\treturn rc;\n}\n\nstatic int nfc_genl_fw_download(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\tchar firmware_name[NFC_FIRMWARE_NAME_MAXSIZE + 1];\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] || !info->attrs[NFC_ATTR_FIRMWARE_NAME])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tnla_strscpy(firmware_name, info->attrs[NFC_ATTR_FIRMWARE_NAME],\n\t\t    sizeof(firmware_name));\n\n\trc = nfc_fw_download(dev, firmware_name);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nint nfc_genl_fw_download_done(struct nfc_dev *dev, const char *firmware_name,\n\t\t\t      u32 result)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_FW_DOWNLOAD);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_string(msg, NFC_ATTR_FIRMWARE_NAME, firmware_name) ||\n\t    nla_put_u32(msg, NFC_ATTR_FIRMWARE_DOWNLOAD_STATUS, result) ||\n\t    nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_enable_se(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx, se_idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_SE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tse_idx = nla_get_u32(info->attrs[NFC_ATTR_SE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_enable_se(dev, se_idx);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_disable_se(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx, se_idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_SE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tse_idx = nla_get_u32(info->attrs[NFC_ATTR_SE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_disable_se(dev, se_idx);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_send_se(struct sk_buff *msg, struct nfc_dev *dev,\n\t\t\t\tu32 portid, u32 seq,\n\t\t\t\tstruct netlink_callback *cb,\n\t\t\t\tint flags)\n{\n\tvoid *hdr;\n\tstruct nfc_se *se, *n;\n\n\tlist_for_each_entry_safe(se, n, &dev->secure_elements, list) {\n\t\thdr = genlmsg_put(msg, portid, seq, &nfc_genl_family, flags,\n\t\t\t\t  NFC_CMD_GET_SE);\n\t\tif (!hdr)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (cb)\n\t\t\tgenl_dump_check_consistent(cb, hdr);\n\n\t\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se->idx) ||\n\t\t    nla_put_u8(msg, NFC_ATTR_SE_TYPE, se->type))\n\t\t\tgoto nla_put_failure;\n\n\t\tgenlmsg_end(msg, hdr);\n\t}\n\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_dump_ses(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tstruct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];\n\tstruct nfc_dev *dev = (struct nfc_dev *) cb->args[1];\n\tbool first_call = false;\n\n\tif (!iter) {\n\t\tfirst_call = true;\n\t\titer = kmalloc(sizeof(struct class_dev_iter), GFP_KERNEL);\n\t\tif (!iter)\n\t\t\treturn -ENOMEM;\n\t\tcb->args[0] = (long) iter;\n\t}\n\n\tmutex_lock(&nfc_devlist_mutex);\n\n\tcb->seq = nfc_devlist_generation;\n\n\tif (first_call) {\n\t\tnfc_device_iter_init(iter);\n\t\tdev = nfc_device_iter_next(iter);\n\t}\n\n\twhile (dev) {\n\t\tint rc;\n\n\t\trc = nfc_genl_send_se(skb, dev, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t  cb->nlh->nlmsg_seq, cb, NLM_F_MULTI);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\tdev = nfc_device_iter_next(iter);\n\t}\n\n\tmutex_unlock(&nfc_devlist_mutex);\n\n\tcb->args[1] = (long) dev;\n\n\treturn skb->len;\n}\n\nstatic int nfc_genl_dump_ses_done(struct netlink_callback *cb)\n{\n\tstruct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];\n\n\tif (iter) {\n\t\tnfc_device_iter_exit(iter);\n\t\tkfree(iter);\n\t}\n\n\treturn 0;\n}\n\nstatic int nfc_se_io(struct nfc_dev *dev, u32 se_idx,\n\t\t     u8 *apdu, size_t apdu_length,\n\t\t     se_io_cb_t cb, void *cb_context)\n{\n\tstruct nfc_se *se;\n\tint rc;\n\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\n\tdevice_lock(&dev->dev);\n\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (!dev->ops->se_io) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (se->state != NFC_SE_ENABLED) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\trc = dev->ops->se_io(dev, se_idx, apdu,\n\t\t\tapdu_length, cb, cb_context);\n\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n\nerror:\n\tdevice_unlock(&dev->dev);\n\tkfree(cb_context);\n\treturn rc;\n}\n\nstruct se_io_ctx {\n\tu32 dev_idx;\n\tu32 se_idx;\n};\n\nstatic void se_io_cb(void *context, u8 *apdu, size_t apdu_len, int err)\n{\n\tstruct se_io_ctx *ctx = context;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\tkfree(ctx);\n\t\treturn;\n\t}\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_SE_IO);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, ctx->dev_idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, ctx->se_idx) ||\n\t    nla_put(msg, NFC_ATTR_SE_APDU, apdu_len, apdu))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\tkfree(ctx);\n\n\treturn;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\tkfree(ctx);\n\n\treturn;\n}\n\nstatic int nfc_genl_se_io(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct se_io_ctx *ctx;\n\tu32 dev_idx, se_idx;\n\tu8 *apdu;\n\tsize_t apdu_len;\n\tint rc;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_SE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_SE_APDU])\n\t\treturn -EINVAL;\n\n\tdev_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tse_idx = nla_get_u32(info->attrs[NFC_ATTR_SE_INDEX]);\n\n\tdev = nfc_get_device(dev_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tif (!dev->ops || !dev->ops->se_io) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto put_dev;\n\t}\n\n\tapdu_len = nla_len(info->attrs[NFC_ATTR_SE_APDU]);\n\tif (apdu_len == 0) {\n\t\trc = -EINVAL;\n\t\tgoto put_dev;\n\t}\n\n\tapdu = nla_data(info->attrs[NFC_ATTR_SE_APDU]);\n\tif (!apdu) {\n\t\trc = -EINVAL;\n\t\tgoto put_dev;\n\t}\n\n\tctx = kzalloc(sizeof(struct se_io_ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\trc = -ENOMEM;\n\t\tgoto put_dev;\n\t}\n\n\tctx->dev_idx = dev_idx;\n\tctx->se_idx = se_idx;\n\n\trc = nfc_se_io(dev, se_idx, apdu, apdu_len, se_io_cb, ctx);\n\nput_dev:\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_vendor_cmd(struct sk_buff *skb,\n\t\t\t       struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tconst struct nfc_vendor_cmd *cmd;\n\tu32 dev_idx, vid, subcmd;\n\tu8 *data;\n\tsize_t data_len;\n\tint i, err;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_VENDOR_ID] ||\n\t    !info->attrs[NFC_ATTR_VENDOR_SUBCMD])\n\t\treturn -EINVAL;\n\n\tdev_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tvid = nla_get_u32(info->attrs[NFC_ATTR_VENDOR_ID]);\n\tsubcmd = nla_get_u32(info->attrs[NFC_ATTR_VENDOR_SUBCMD]);\n\n\tdev = nfc_get_device(dev_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tif (!dev->vendor_cmds || !dev->n_vendor_cmds) {\n\t\terr = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\n\tif (info->attrs[NFC_ATTR_VENDOR_DATA]) {\n\t\tdata = nla_data(info->attrs[NFC_ATTR_VENDOR_DATA]);\n\t\tdata_len = nla_len(info->attrs[NFC_ATTR_VENDOR_DATA]);\n\t\tif (data_len == 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto put_dev;\n\t\t}\n\t} else {\n\t\tdata = NULL;\n\t\tdata_len = 0;\n\t}\n\n\tfor (i = 0; i < dev->n_vendor_cmds; i++) {\n\t\tcmd = &dev->vendor_cmds[i];\n\n\t\tif (cmd->vendor_id != vid || cmd->subcmd != subcmd)\n\t\t\tcontinue;\n\n\t\tdev->cur_cmd_info = info;\n\t\terr = cmd->doit(dev, data, data_len);\n\t\tdev->cur_cmd_info = NULL;\n\t\tgoto put_dev;\n\t}\n\n\terr = -EOPNOTSUPP;\n\nput_dev:\n\tnfc_put_device(dev);\n\treturn err;\n}\n\n/* message building helper */\nstatic inline void *nfc_hdr_put(struct sk_buff *skb, u32 portid, u32 seq,\n\t\t\t\tint flags, u8 cmd)\n{\n\t/* since there is no private header just add the generic one */\n\treturn genlmsg_put(skb, portid, seq, &nfc_genl_family, flags, cmd);\n}\n\nstatic struct sk_buff *\n__nfc_alloc_vendor_cmd_skb(struct nfc_dev *dev, int approxlen,\n\t\t\t   u32 portid, u32 seq,\n\t\t\t   enum nfc_attrs attr,\n\t\t\t   u32 oui, u32 subcmd, gfp_t gfp)\n{\n\tstruct sk_buff *skb;\n\tvoid *hdr;\n\n\tskb = nlmsg_new(approxlen + 100, gfp);\n\tif (!skb)\n\t\treturn NULL;\n\n\thdr = nfc_hdr_put(skb, portid, seq, 0, NFC_CMD_VENDOR);\n\tif (!hdr) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tif (nla_put_u32(skb, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(skb, NFC_ATTR_VENDOR_ID, oui))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(skb, NFC_ATTR_VENDOR_SUBCMD, subcmd))\n\t\tgoto nla_put_failure;\n\n\t((void **)skb->cb)[0] = dev;\n\t((void **)skb->cb)[1] = hdr;\n\n\treturn skb;\n\nnla_put_failure:\n\tkfree_skb(skb);\n\treturn NULL;\n}\n\nstruct sk_buff *__nfc_alloc_vendor_cmd_reply_skb(struct nfc_dev *dev,\n\t\t\t\t\t\t enum nfc_attrs attr,\n\t\t\t\t\t\t u32 oui, u32 subcmd,\n\t\t\t\t\t\t int approxlen)\n{\n\tif (WARN_ON(!dev->cur_cmd_info))\n\t\treturn NULL;\n\n\treturn __nfc_alloc_vendor_cmd_skb(dev, approxlen,\n\t\t\t\t\t  dev->cur_cmd_info->snd_portid,\n\t\t\t\t\t  dev->cur_cmd_info->snd_seq, attr,\n\t\t\t\t\t  oui, subcmd, GFP_KERNEL);\n}\nEXPORT_SYMBOL(__nfc_alloc_vendor_cmd_reply_skb);\n\nint nfc_vendor_cmd_reply(struct sk_buff *skb)\n{\n\tstruct nfc_dev *dev = ((void **)skb->cb)[0];\n\tvoid *hdr = ((void **)skb->cb)[1];\n\n\t/* clear CB data for netlink core to own from now on */\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\n\tif (WARN_ON(!dev->cur_cmd_info)) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tgenlmsg_end(skb, hdr);\n\treturn genlmsg_reply(skb, dev->cur_cmd_info);\n}\nEXPORT_SYMBOL(nfc_vendor_cmd_reply);\n\nstatic const struct genl_ops nfc_genl_ops[] = {\n\t{\n\t\t.cmd = NFC_CMD_GET_DEVICE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_get_device,\n\t\t.dumpit = nfc_genl_dump_devices,\n\t\t.done = nfc_genl_dump_devices_done,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_DEV_UP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_dev_up,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_DEV_DOWN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_dev_down,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_START_POLL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_start_poll,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_STOP_POLL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_stop_poll,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_DEP_LINK_UP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_dep_link_up,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_DEP_LINK_DOWN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_dep_link_down,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_GET_TARGET,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT |\n\t\t\t    GENL_DONT_VALIDATE_DUMP_STRICT,\n\t\t.dumpit = nfc_genl_dump_targets,\n\t\t.done = nfc_genl_dump_targets_done,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_LLC_GET_PARAMS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_llc_get_params,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_LLC_SET_PARAMS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_llc_set_params,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_LLC_SDREQ,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_llc_sdreq,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_FW_DOWNLOAD,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_fw_download,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_ENABLE_SE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_enable_se,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_DISABLE_SE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_disable_se,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_GET_SE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.dumpit = nfc_genl_dump_ses,\n\t\t.done = nfc_genl_dump_ses_done,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_SE_IO,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_se_io,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_ACTIVATE_TARGET,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_activate_target,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_VENDOR,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_vendor_cmd,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_DEACTIVATE_TARGET,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_deactivate_target,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n};\n\nstatic struct genl_family nfc_genl_family __ro_after_init = {\n\t.hdrsize = 0,\n\t.name = NFC_GENL_NAME,\n\t.version = NFC_GENL_VERSION,\n\t.maxattr = NFC_ATTR_MAX,\n\t.policy = nfc_genl_policy,\n\t.module = THIS_MODULE,\n\t.ops = nfc_genl_ops,\n\t.n_ops = ARRAY_SIZE(nfc_genl_ops),\n\t.resv_start_op = NFC_CMD_DEACTIVATE_TARGET + 1,\n\t.mcgrps = nfc_genl_mcgrps,\n\t.n_mcgrps = ARRAY_SIZE(nfc_genl_mcgrps),\n};\n\n\nstruct urelease_work {\n\tstruct\twork_struct w;\n\tu32\tportid;\n};\n\nstatic void nfc_urelease_event_work(struct work_struct *work)\n{\n\tstruct urelease_work *w = container_of(work, struct urelease_work, w);\n\tstruct class_dev_iter iter;\n\tstruct nfc_dev *dev;\n\n\tpr_debug(\"portid %d\\n\", w->portid);\n\n\tmutex_lock(&nfc_devlist_mutex);\n\n\tnfc_device_iter_init(&iter);\n\tdev = nfc_device_iter_next(&iter);\n\n\twhile (dev) {\n\t\tmutex_lock(&dev->genl_data.genl_data_mutex);\n\n\t\tif (dev->genl_data.poll_req_portid == w->portid) {\n\t\t\tnfc_stop_poll(dev);\n\t\t\tdev->genl_data.poll_req_portid = 0;\n\t\t}\n\n\t\tmutex_unlock(&dev->genl_data.genl_data_mutex);\n\n\t\tdev = nfc_device_iter_next(&iter);\n\t}\n\n\tnfc_device_iter_exit(&iter);\n\n\tmutex_unlock(&nfc_devlist_mutex);\n\n\tkfree(w);\n}\n\nstatic int nfc_genl_rcv_nl_event(struct notifier_block *this,\n\t\t\t\t unsigned long event, void *ptr)\n{\n\tstruct netlink_notify *n = ptr;\n\tstruct urelease_work *w;\n\n\tif (event != NETLINK_URELEASE || n->protocol != NETLINK_GENERIC)\n\t\tgoto out;\n\n\tpr_debug(\"NETLINK_URELEASE event from id %d\\n\", n->portid);\n\n\tw = kmalloc(sizeof(*w), GFP_ATOMIC);\n\tif (w) {\n\t\tINIT_WORK(&w->w, nfc_urelease_event_work);\n\t\tw->portid = n->portid;\n\t\tschedule_work(&w->w);\n\t}\n\nout:\n\treturn NOTIFY_DONE;\n}\n\nvoid nfc_genl_data_init(struct nfc_genl_data *genl_data)\n{\n\tgenl_data->poll_req_portid = 0;\n\tmutex_init(&genl_data->genl_data_mutex);\n}\n\nvoid nfc_genl_data_exit(struct nfc_genl_data *genl_data)\n{\n\tmutex_destroy(&genl_data->genl_data_mutex);\n}\n\nstatic struct notifier_block nl_notifier = {\n\t.notifier_call  = nfc_genl_rcv_nl_event,\n};\n\n/**\n * nfc_genl_init() - Initialize netlink interface\n *\n * This initialization function registers the nfc netlink family.\n */\nint __init nfc_genl_init(void)\n{\n\tint rc;\n\n\trc = genl_register_family(&nfc_genl_family);\n\tif (rc)\n\t\treturn rc;\n\n\tnetlink_register_notifier(&nl_notifier);\n\n\treturn 0;\n}\n\n/**\n * nfc_genl_exit() - Deinitialize netlink interface\n *\n * This exit function unregisters the nfc netlink family.\n */\nvoid nfc_genl_exit(void)\n{\n\tnetlink_unregister_notifier(&nl_notifier);\n\tgenl_unregister_family(&nfc_genl_family);\n}\n", "/* SPDX-License-Identifier: GPL-2.0-or-later */\n/*\n * Copyright (C) 2011 Instituto Nokia de Tecnologia\n *\n * Authors:\n *    Lauro Ramos Venancio <lauro.venancio@openbossa.org>\n *    Aloisio Almeida Jr <aloisio.almeida@openbossa.org>\n */\n\n#ifndef __LOCAL_NFC_H\n#define __LOCAL_NFC_H\n\n#include <net/nfc/nfc.h>\n#include <net/sock.h>\n\n#define NFC_TARGET_MODE_IDLE 0\n#define NFC_TARGET_MODE_SLEEP 1\n\nstruct nfc_protocol {\n\tint id;\n\tstruct proto *proto;\n\tstruct module *owner;\n\tint (*create)(struct net *net, struct socket *sock,\n\t\t      const struct nfc_protocol *nfc_proto, int kern);\n};\n\nstruct nfc_rawsock {\n\tstruct sock sk;\n\tstruct nfc_dev *dev;\n\tu32 target_idx;\n\tstruct work_struct tx_work;\n\tbool tx_work_scheduled;\n};\n\nstruct nfc_sock_list {\n\tstruct hlist_head head;\n\trwlock_t          lock;\n};\n\n#define nfc_rawsock(sk) ((struct nfc_rawsock *) sk)\n#define to_rawsock_sk(_tx_work) \\\n\t((struct sock *) container_of(_tx_work, struct nfc_rawsock, tx_work))\n\nstruct nfc_llcp_sdp_tlv;\n\nvoid nfc_llcp_mac_is_down(struct nfc_dev *dev);\nvoid nfc_llcp_mac_is_up(struct nfc_dev *dev, u32 target_idx,\n\t\t\tu8 comm_mode, u8 rf_mode);\nint nfc_llcp_register_device(struct nfc_dev *dev);\nvoid nfc_llcp_unregister_device(struct nfc_dev *dev);\nint nfc_llcp_set_remote_gb(struct nfc_dev *dev, const u8 *gb, u8 gb_len);\nu8 *nfc_llcp_general_bytes(struct nfc_dev *dev, size_t *general_bytes_len);\nint nfc_llcp_data_received(struct nfc_dev *dev, struct sk_buff *skb);\nstruct nfc_llcp_local *nfc_llcp_find_local(struct nfc_dev *dev);\nint __init nfc_llcp_init(void);\nvoid nfc_llcp_exit(void);\nvoid nfc_llcp_free_sdp_tlv(struct nfc_llcp_sdp_tlv *sdp);\nvoid nfc_llcp_free_sdp_tlv_list(struct hlist_head *head);\n\nint __init rawsock_init(void);\nvoid rawsock_exit(void);\n\nint __init af_nfc_init(void);\nvoid af_nfc_exit(void);\nint nfc_proto_register(const struct nfc_protocol *nfc_proto);\nvoid nfc_proto_unregister(const struct nfc_protocol *nfc_proto);\n\nextern int nfc_devlist_generation;\nextern struct mutex nfc_devlist_mutex;\n\nint __init nfc_genl_init(void);\nvoid nfc_genl_exit(void);\n\nvoid nfc_genl_data_init(struct nfc_genl_data *genl_data);\nvoid nfc_genl_data_exit(struct nfc_genl_data *genl_data);\n\nint nfc_genl_targets_found(struct nfc_dev *dev);\nint nfc_genl_target_lost(struct nfc_dev *dev, u32 target_idx);\n\nint nfc_genl_device_added(struct nfc_dev *dev);\nint nfc_genl_device_removed(struct nfc_dev *dev);\n\nint nfc_genl_dep_link_up_event(struct nfc_dev *dev, u32 target_idx,\n\t\t\t       u8 comm_mode, u8 rf_mode);\nint nfc_genl_dep_link_down_event(struct nfc_dev *dev);\n\nint nfc_genl_tm_activated(struct nfc_dev *dev, u32 protocol);\nint nfc_genl_tm_deactivated(struct nfc_dev *dev);\n\nint nfc_genl_llc_send_sdres(struct nfc_dev *dev, struct hlist_head *sdres_list);\n\nint nfc_genl_se_added(struct nfc_dev *dev, u32 se_idx, u16 type);\nint nfc_genl_se_removed(struct nfc_dev *dev, u32 se_idx);\nint nfc_genl_se_transaction(struct nfc_dev *dev, u8 se_idx,\n\t\t\t    struct nfc_evt_transaction *evt_transaction);\nint nfc_genl_se_connectivity(struct nfc_dev *dev, u8 se_idx);\n\nstruct nfc_dev *nfc_get_device(unsigned int idx);\n\nstatic inline void nfc_put_device(struct nfc_dev *dev)\n{\n\tput_device(&dev->dev);\n}\n\nstatic inline void nfc_device_iter_init(struct class_dev_iter *iter)\n{\n\tclass_dev_iter_init(iter, &nfc_class, NULL, NULL);\n}\n\nstatic inline struct nfc_dev *nfc_device_iter_next(struct class_dev_iter *iter)\n{\n\tstruct device *d = class_dev_iter_next(iter);\n\tif (!d)\n\t\treturn NULL;\n\n\treturn to_nfc_dev(d);\n}\n\nstatic inline void nfc_device_iter_exit(struct class_dev_iter *iter)\n{\n\tclass_dev_iter_exit(iter);\n}\n\nint nfc_fw_download(struct nfc_dev *dev, const char *firmware_name);\nint nfc_genl_fw_download_done(struct nfc_dev *dev, const char *firmware_name,\n\t\t\t      u32 result);\n\nint nfc_dev_up(struct nfc_dev *dev);\n\nint nfc_dev_down(struct nfc_dev *dev);\n\nint nfc_start_poll(struct nfc_dev *dev, u32 im_protocols, u32 tm_protocols);\n\nint nfc_stop_poll(struct nfc_dev *dev);\n\nint nfc_dep_link_up(struct nfc_dev *dev, int target_idx, u8 comm_mode);\n\nint nfc_dep_link_down(struct nfc_dev *dev);\n\nint nfc_activate_target(struct nfc_dev *dev, u32 target_idx, u32 protocol);\n\nint nfc_deactivate_target(struct nfc_dev *dev, u32 target_idx, u8 mode);\n\nint nfc_data_exchange(struct nfc_dev *dev, u32 target_idx, struct sk_buff *skb,\n\t\t      data_exchange_cb_t cb, void *cb_context);\n\nint nfc_enable_se(struct nfc_dev *dev, u32 se_idx);\nint nfc_disable_se(struct nfc_dev *dev, u32 se_idx);\n\n#endif /* __LOCAL_NFC_H */\n"], "fixing_code": ["/* SPDX-License-Identifier: GPL-2.0-or-later */\n/*\n * Copyright (C) 2011  Intel Corporation. All rights reserved.\n */\n\nenum llcp_state {\n\tLLCP_CONNECTED = 1, /* wait_for_packet() wants that */\n\tLLCP_CONNECTING,\n\tLLCP_CLOSED,\n\tLLCP_BOUND,\n\tLLCP_LISTEN,\n};\n\n#define LLCP_DEFAULT_LTO 100\n#define LLCP_DEFAULT_RW  1\n#define LLCP_DEFAULT_MIU 128\n\n#define LLCP_MAX_LTO  0xff\n#define LLCP_MAX_RW   15\n#define LLCP_MAX_MIUX 0x7ff\n#define LLCP_MAX_MIU (LLCP_MAX_MIUX + 128)\n\n#define LLCP_WKS_NUM_SAP   16\n#define LLCP_SDP_NUM_SAP   16\n#define LLCP_LOCAL_NUM_SAP 32\n#define LLCP_LOCAL_SAP_OFFSET (LLCP_WKS_NUM_SAP + LLCP_SDP_NUM_SAP)\n#define LLCP_MAX_SAP (LLCP_WKS_NUM_SAP + LLCP_SDP_NUM_SAP + LLCP_LOCAL_NUM_SAP)\n#define LLCP_SDP_UNBOUND   (LLCP_MAX_SAP + 1)\n\nstruct nfc_llcp_sock;\n\nstruct llcp_sock_list {\n\tstruct hlist_head head;\n\trwlock_t          lock;\n};\n\nstruct nfc_llcp_sdp_tlv {\n\tu8 *tlv;\n\tu8 tlv_len;\n\n\tchar *uri;\n\tu8 tid;\n\tu8 sap;\n\n\tunsigned long time;\n\n\tstruct hlist_node node;\n};\n\nstruct nfc_llcp_local {\n\tstruct list_head list;\n\tstruct nfc_dev *dev;\n\n\tstruct kref ref;\n\n\tstruct mutex sdp_lock;\n\n\tstruct timer_list link_timer;\n\tstruct sk_buff_head tx_queue;\n\tstruct work_struct\t tx_work;\n\tstruct work_struct\t rx_work;\n\tstruct sk_buff *rx_pending;\n\tstruct work_struct\t timeout_work;\n\n\tu32 target_idx;\n\tu8 rf_mode;\n\tu8 comm_mode;\n\tu8 lto;\n\tu8 rw;\n\t__be16 miux;\n\tunsigned long local_wks;      /* Well known services */\n\tunsigned long local_sdp;      /* Local services  */\n\tunsigned long local_sap; /* Local SAPs, not available for discovery */\n\tatomic_t local_sdp_cnt[LLCP_SDP_NUM_SAP];\n\n\t/* local */\n\tu8 gb[NFC_MAX_GT_LEN];\n\tu8 gb_len;\n\n\t/* remote */\n\tu8 remote_gb[NFC_MAX_GT_LEN];\n\tu8 remote_gb_len;\n\n\tu8  remote_version;\n\tu16 remote_miu;\n\tu16 remote_lto;\n\tu8  remote_opt;\n\tu16 remote_wks;\n\n\tstruct mutex sdreq_lock;\n\tstruct hlist_head pending_sdreqs;\n\tstruct timer_list sdreq_timer;\n\tstruct work_struct sdreq_timeout_work;\n\tu8 sdreq_next_tid;\n\n\t/* sockets array */\n\tstruct llcp_sock_list sockets;\n\tstruct llcp_sock_list connecting_sockets;\n\tstruct llcp_sock_list raw_sockets;\n};\n\nstruct nfc_llcp_sock {\n\tstruct sock sk;\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tu32 target_idx;\n\tu32 nfc_protocol;\n\n\t/* Link parameters */\n\tu8 ssap;\n\tu8 dsap;\n\tchar *service_name;\n\tsize_t service_name_len;\n\tu8 rw;\n\t__be16 miux;\n\n\n\t/* Remote link parameters */\n\tu8 remote_rw;\n\tu16 remote_miu;\n\n\t/* Link variables */\n\tu8 send_n;\n\tu8 send_ack_n;\n\tu8 recv_n;\n\tu8 recv_ack_n;\n\n\t/* Is the remote peer ready to receive */\n\tu8 remote_ready;\n\n\t/* Reserved source SAP */\n\tu8 reserved_ssap;\n\n\tstruct sk_buff_head tx_queue;\n\tstruct sk_buff_head tx_pending_queue;\n\n\tstruct list_head accept_queue;\n\tstruct sock *parent;\n};\n\nstruct nfc_llcp_ui_cb {\n\t__u8 dsap;\n\t__u8 ssap;\n};\n\n#define nfc_llcp_ui_skb_cb(__skb) ((struct nfc_llcp_ui_cb *)&((__skb)->cb[0]))\n\n#define nfc_llcp_sock(sk) ((struct nfc_llcp_sock *) (sk))\n#define nfc_llcp_dev(sk)  (nfc_llcp_sock((sk))->dev)\n\n#define LLCP_HEADER_SIZE   2\n#define LLCP_SEQUENCE_SIZE 1\n#define LLCP_AGF_PDU_HEADER_SIZE 2\n\n/* LLCP versions: 1.1 is 1.0 plus SDP */\n#define LLCP_VERSION_10 0x10\n#define LLCP_VERSION_11 0x11\n\n/* LLCP PDU types */\n#define LLCP_PDU_SYMM     0x0\n#define LLCP_PDU_PAX      0x1\n#define LLCP_PDU_AGF      0x2\n#define LLCP_PDU_UI       0x3\n#define LLCP_PDU_CONNECT  0x4\n#define LLCP_PDU_DISC     0x5\n#define LLCP_PDU_CC       0x6\n#define LLCP_PDU_DM       0x7\n#define LLCP_PDU_FRMR     0x8\n#define LLCP_PDU_SNL      0x9\n#define LLCP_PDU_I        0xc\n#define LLCP_PDU_RR       0xd\n#define LLCP_PDU_RNR      0xe\n\n/* Parameters TLV types */\n#define LLCP_TLV_VERSION 0x1\n#define LLCP_TLV_MIUX    0x2\n#define LLCP_TLV_WKS     0x3\n#define LLCP_TLV_LTO     0x4\n#define LLCP_TLV_RW      0x5\n#define LLCP_TLV_SN      0x6\n#define LLCP_TLV_OPT     0x7\n#define LLCP_TLV_SDREQ   0x8\n#define LLCP_TLV_SDRES   0x9\n#define LLCP_TLV_MAX     0xa\n\n/* Well known LLCP SAP */\n#define LLCP_SAP_SDP   0x1\n#define LLCP_SAP_IP    0x2\n#define LLCP_SAP_OBEX  0x3\n#define LLCP_SAP_SNEP  0x4\n#define LLCP_SAP_MAX   0xff\n\n/* Disconnection reason code */\n#define LLCP_DM_DISC    0x00\n#define LLCP_DM_NOCONN  0x01\n#define LLCP_DM_NOBOUND 0x02\n#define LLCP_DM_REJ     0x03\n\n\nvoid nfc_llcp_sock_link(struct llcp_sock_list *l, struct sock *s);\nvoid nfc_llcp_sock_unlink(struct llcp_sock_list *l, struct sock *s);\nvoid nfc_llcp_socket_remote_param_init(struct nfc_llcp_sock *sock);\nstruct nfc_llcp_local *nfc_llcp_find_local(struct nfc_dev *dev);\nint nfc_llcp_local_put(struct nfc_llcp_local *local);\nu8 nfc_llcp_get_sdp_ssap(struct nfc_llcp_local *local,\n\t\t\t struct nfc_llcp_sock *sock);\nu8 nfc_llcp_get_local_ssap(struct nfc_llcp_local *local);\nvoid nfc_llcp_put_ssap(struct nfc_llcp_local *local, u8 ssap);\nint nfc_llcp_queue_i_frames(struct nfc_llcp_sock *sock);\nvoid nfc_llcp_send_to_raw_sock(struct nfc_llcp_local *local,\n\t\t\t       struct sk_buff *skb, u8 direction);\n\n/* Sock API */\nstruct sock *nfc_llcp_sock_alloc(struct socket *sock, int type, gfp_t gfp, int kern);\nvoid nfc_llcp_sock_free(struct nfc_llcp_sock *sock);\nvoid nfc_llcp_accept_unlink(struct sock *sk);\nvoid nfc_llcp_accept_enqueue(struct sock *parent, struct sock *sk);\nstruct sock *nfc_llcp_accept_dequeue(struct sock *sk, struct socket *newsock);\n\n/* TLV API */\nint nfc_llcp_parse_gb_tlv(struct nfc_llcp_local *local,\n\t\t\t  const u8 *tlv_array, u16 tlv_array_len);\nint nfc_llcp_parse_connection_tlv(struct nfc_llcp_sock *sock,\n\t\t\t\t  const u8 *tlv_array, u16 tlv_array_len);\n\n/* Commands API */\nvoid nfc_llcp_recv(void *data, struct sk_buff *skb, int err);\nu8 *nfc_llcp_build_tlv(u8 type, const u8 *value, u8 value_length, u8 *tlv_length);\nstruct nfc_llcp_sdp_tlv *nfc_llcp_build_sdres_tlv(u8 tid, u8 sap);\nstruct nfc_llcp_sdp_tlv *nfc_llcp_build_sdreq_tlv(u8 tid, const char *uri,\n\t\t\t\t\t\t  size_t uri_len);\nvoid nfc_llcp_free_sdp_tlv(struct nfc_llcp_sdp_tlv *sdp);\nvoid nfc_llcp_free_sdp_tlv_list(struct hlist_head *sdp_head);\nvoid nfc_llcp_recv(void *data, struct sk_buff *skb, int err);\nint nfc_llcp_send_symm(struct nfc_dev *dev);\nint nfc_llcp_send_connect(struct nfc_llcp_sock *sock);\nint nfc_llcp_send_cc(struct nfc_llcp_sock *sock);\nint nfc_llcp_send_snl_sdres(struct nfc_llcp_local *local,\n\t\t\t    struct hlist_head *tlv_list, size_t tlvs_len);\nint nfc_llcp_send_snl_sdreq(struct nfc_llcp_local *local,\n\t\t\t    struct hlist_head *tlv_list, size_t tlvs_len);\nint nfc_llcp_send_dm(struct nfc_llcp_local *local, u8 ssap, u8 dsap, u8 reason);\nint nfc_llcp_send_disconnect(struct nfc_llcp_sock *sock);\nint nfc_llcp_send_i_frame(struct nfc_llcp_sock *sock,\n\t\t\t  struct msghdr *msg, size_t len);\nint nfc_llcp_send_ui_frame(struct nfc_llcp_sock *sock, u8 ssap, u8 dsap,\n\t\t\t   struct msghdr *msg, size_t len);\nint nfc_llcp_send_rr(struct nfc_llcp_sock *sock);\n\n/* Socket API */\nint __init nfc_llcp_sock_init(void);\nvoid nfc_llcp_sock_exit(void);\n", "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Copyright (C) 2011  Intel Corporation. All rights reserved.\n */\n\n#define pr_fmt(fmt) \"llcp: %s: \" fmt, __func__\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/nfc.h>\n\n#include <net/nfc/nfc.h>\n\n#include \"nfc.h\"\n#include \"llcp.h\"\n\nstatic const u8 llcp_tlv_length[LLCP_TLV_MAX] = {\n\t0,\n\t1, /* VERSION */\n\t2, /* MIUX */\n\t2, /* WKS */\n\t1, /* LTO */\n\t1, /* RW */\n\t0, /* SN */\n\t1, /* OPT */\n\t0, /* SDREQ */\n\t2, /* SDRES */\n\n};\n\nstatic u8 llcp_tlv8(const u8 *tlv, u8 type)\n{\n\tif (tlv[0] != type || tlv[1] != llcp_tlv_length[tlv[0]])\n\t\treturn 0;\n\n\treturn tlv[2];\n}\n\nstatic u16 llcp_tlv16(const u8 *tlv, u8 type)\n{\n\tif (tlv[0] != type || tlv[1] != llcp_tlv_length[tlv[0]])\n\t\treturn 0;\n\n\treturn be16_to_cpu(*((__be16 *)(tlv + 2)));\n}\n\n\nstatic u8 llcp_tlv_version(const u8 *tlv)\n{\n\treturn llcp_tlv8(tlv, LLCP_TLV_VERSION);\n}\n\nstatic u16 llcp_tlv_miux(const u8 *tlv)\n{\n\treturn llcp_tlv16(tlv, LLCP_TLV_MIUX) & 0x7ff;\n}\n\nstatic u16 llcp_tlv_wks(const u8 *tlv)\n{\n\treturn llcp_tlv16(tlv, LLCP_TLV_WKS);\n}\n\nstatic u16 llcp_tlv_lto(const u8 *tlv)\n{\n\treturn llcp_tlv8(tlv, LLCP_TLV_LTO);\n}\n\nstatic u8 llcp_tlv_opt(const u8 *tlv)\n{\n\treturn llcp_tlv8(tlv, LLCP_TLV_OPT);\n}\n\nstatic u8 llcp_tlv_rw(const u8 *tlv)\n{\n\treturn llcp_tlv8(tlv, LLCP_TLV_RW) & 0xf;\n}\n\nu8 *nfc_llcp_build_tlv(u8 type, const u8 *value, u8 value_length, u8 *tlv_length)\n{\n\tu8 *tlv, length;\n\n\tpr_debug(\"type %d\\n\", type);\n\n\tif (type >= LLCP_TLV_MAX)\n\t\treturn NULL;\n\n\tlength = llcp_tlv_length[type];\n\tif (length == 0 && value_length == 0)\n\t\treturn NULL;\n\telse if (length == 0)\n\t\tlength = value_length;\n\n\t*tlv_length = 2 + length;\n\ttlv = kzalloc(2 + length, GFP_KERNEL);\n\tif (tlv == NULL)\n\t\treturn tlv;\n\n\ttlv[0] = type;\n\ttlv[1] = length;\n\tmemcpy(tlv + 2, value, length);\n\n\treturn tlv;\n}\n\nstruct nfc_llcp_sdp_tlv *nfc_llcp_build_sdres_tlv(u8 tid, u8 sap)\n{\n\tstruct nfc_llcp_sdp_tlv *sdres;\n\tu8 value[2];\n\n\tsdres = kzalloc(sizeof(struct nfc_llcp_sdp_tlv), GFP_KERNEL);\n\tif (sdres == NULL)\n\t\treturn NULL;\n\n\tvalue[0] = tid;\n\tvalue[1] = sap;\n\n\tsdres->tlv = nfc_llcp_build_tlv(LLCP_TLV_SDRES, value, 2,\n\t\t\t\t\t&sdres->tlv_len);\n\tif (sdres->tlv == NULL) {\n\t\tkfree(sdres);\n\t\treturn NULL;\n\t}\n\n\tsdres->tid = tid;\n\tsdres->sap = sap;\n\n\tINIT_HLIST_NODE(&sdres->node);\n\n\treturn sdres;\n}\n\nstruct nfc_llcp_sdp_tlv *nfc_llcp_build_sdreq_tlv(u8 tid, const char *uri,\n\t\t\t\t\t\t  size_t uri_len)\n{\n\tstruct nfc_llcp_sdp_tlv *sdreq;\n\n\tpr_debug(\"uri: %s, len: %zu\\n\", uri, uri_len);\n\n\t/* sdreq->tlv_len is u8, takes uri_len, + 3 for header, + 1 for NULL */\n\tif (WARN_ON_ONCE(uri_len > U8_MAX - 4))\n\t\treturn NULL;\n\n\tsdreq = kzalloc(sizeof(struct nfc_llcp_sdp_tlv), GFP_KERNEL);\n\tif (sdreq == NULL)\n\t\treturn NULL;\n\n\tsdreq->tlv_len = uri_len + 3;\n\n\tif (uri[uri_len - 1] == 0)\n\t\tsdreq->tlv_len--;\n\n\tsdreq->tlv = kzalloc(sdreq->tlv_len + 1, GFP_KERNEL);\n\tif (sdreq->tlv == NULL) {\n\t\tkfree(sdreq);\n\t\treturn NULL;\n\t}\n\n\tsdreq->tlv[0] = LLCP_TLV_SDREQ;\n\tsdreq->tlv[1] = sdreq->tlv_len - 2;\n\tsdreq->tlv[2] = tid;\n\n\tsdreq->tid = tid;\n\tsdreq->uri = sdreq->tlv + 3;\n\tmemcpy(sdreq->uri, uri, uri_len);\n\n\tsdreq->time = jiffies;\n\n\tINIT_HLIST_NODE(&sdreq->node);\n\n\treturn sdreq;\n}\n\nvoid nfc_llcp_free_sdp_tlv(struct nfc_llcp_sdp_tlv *sdp)\n{\n\tkfree(sdp->tlv);\n\tkfree(sdp);\n}\n\nvoid nfc_llcp_free_sdp_tlv_list(struct hlist_head *head)\n{\n\tstruct nfc_llcp_sdp_tlv *sdp;\n\tstruct hlist_node *n;\n\n\thlist_for_each_entry_safe(sdp, n, head, node) {\n\t\thlist_del(&sdp->node);\n\n\t\tnfc_llcp_free_sdp_tlv(sdp);\n\t}\n}\n\nint nfc_llcp_parse_gb_tlv(struct nfc_llcp_local *local,\n\t\t\t  const u8 *tlv_array, u16 tlv_array_len)\n{\n\tconst u8 *tlv = tlv_array;\n\tu8 type, length, offset = 0;\n\n\tpr_debug(\"TLV array length %d\\n\", tlv_array_len);\n\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\twhile (offset < tlv_array_len) {\n\t\ttype = tlv[0];\n\t\tlength = tlv[1];\n\n\t\tpr_debug(\"type 0x%x length %d\\n\", type, length);\n\n\t\tswitch (type) {\n\t\tcase LLCP_TLV_VERSION:\n\t\t\tlocal->remote_version = llcp_tlv_version(tlv);\n\t\t\tbreak;\n\t\tcase LLCP_TLV_MIUX:\n\t\t\tlocal->remote_miu = llcp_tlv_miux(tlv) + 128;\n\t\t\tbreak;\n\t\tcase LLCP_TLV_WKS:\n\t\t\tlocal->remote_wks = llcp_tlv_wks(tlv);\n\t\t\tbreak;\n\t\tcase LLCP_TLV_LTO:\n\t\t\tlocal->remote_lto = llcp_tlv_lto(tlv) * 10;\n\t\t\tbreak;\n\t\tcase LLCP_TLV_OPT:\n\t\t\tlocal->remote_opt = llcp_tlv_opt(tlv);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Invalid gt tlv value 0x%x\\n\", type);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset += length + 2;\n\t\ttlv += length + 2;\n\t}\n\n\tpr_debug(\"version 0x%x miu %d lto %d opt 0x%x wks 0x%x\\n\",\n\t\t local->remote_version, local->remote_miu,\n\t\t local->remote_lto, local->remote_opt,\n\t\t local->remote_wks);\n\n\treturn 0;\n}\n\nint nfc_llcp_parse_connection_tlv(struct nfc_llcp_sock *sock,\n\t\t\t\t  const u8 *tlv_array, u16 tlv_array_len)\n{\n\tconst u8 *tlv = tlv_array;\n\tu8 type, length, offset = 0;\n\n\tpr_debug(\"TLV array length %d\\n\", tlv_array_len);\n\n\tif (sock == NULL)\n\t\treturn -ENOTCONN;\n\n\twhile (offset < tlv_array_len) {\n\t\ttype = tlv[0];\n\t\tlength = tlv[1];\n\n\t\tpr_debug(\"type 0x%x length %d\\n\", type, length);\n\n\t\tswitch (type) {\n\t\tcase LLCP_TLV_MIUX:\n\t\t\tsock->remote_miu = llcp_tlv_miux(tlv) + 128;\n\t\t\tbreak;\n\t\tcase LLCP_TLV_RW:\n\t\t\tsock->remote_rw = llcp_tlv_rw(tlv);\n\t\t\tbreak;\n\t\tcase LLCP_TLV_SN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Invalid gt tlv value 0x%x\\n\", type);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset += length + 2;\n\t\ttlv += length + 2;\n\t}\n\n\tpr_debug(\"sock %p rw %d miu %d\\n\", sock,\n\t\t sock->remote_rw, sock->remote_miu);\n\n\treturn 0;\n}\n\nstatic struct sk_buff *llcp_add_header(struct sk_buff *pdu,\n\t\t\t\t       u8 dsap, u8 ssap, u8 ptype)\n{\n\tu8 header[2];\n\n\tpr_debug(\"ptype 0x%x dsap 0x%x ssap 0x%x\\n\", ptype, dsap, ssap);\n\n\theader[0] = (u8)((dsap << 2) | (ptype >> 2));\n\theader[1] = (u8)((ptype << 6) | ssap);\n\n\tpr_debug(\"header 0x%x 0x%x\\n\", header[0], header[1]);\n\n\tskb_put_data(pdu, header, LLCP_HEADER_SIZE);\n\n\treturn pdu;\n}\n\nstatic struct sk_buff *llcp_add_tlv(struct sk_buff *pdu, const u8 *tlv,\n\t\t\t\t    u8 tlv_length)\n{\n\t/* XXX Add an skb length check */\n\n\tif (tlv == NULL)\n\t\treturn NULL;\n\n\tskb_put_data(pdu, tlv, tlv_length);\n\n\treturn pdu;\n}\n\nstatic struct sk_buff *llcp_allocate_pdu(struct nfc_llcp_sock *sock,\n\t\t\t\t\t u8 cmd, u16 size)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tif (sock->ssap == 0)\n\t\treturn NULL;\n\n\tskb = nfc_alloc_send_skb(sock->dev, &sock->sk, MSG_DONTWAIT,\n\t\t\t\t size + LLCP_HEADER_SIZE, &err);\n\tif (skb == NULL) {\n\t\tpr_err(\"Could not allocate PDU\\n\");\n\t\treturn NULL;\n\t}\n\n\tskb = llcp_add_header(skb, sock->dsap, sock->ssap, cmd);\n\n\treturn skb;\n}\n\nint nfc_llcp_send_disconnect(struct nfc_llcp_sock *sock)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tdev = sock->dev;\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_DISC, 0);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\treturn 0;\n}\n\nint nfc_llcp_send_symm(struct nfc_dev *dev)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_llcp_local *local;\n\tu16 size = 0;\n\tint err;\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tsize += LLCP_HEADER_SIZE;\n\tsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\n\tskb = llcp_add_header(skb, 0, 0, LLCP_PDU_SYMM);\n\n\t__net_timestamp(skb);\n\n\tnfc_llcp_send_to_raw_sock(local, skb, NFC_DIRECTION_TX);\n\n\terr = nfc_data_exchange(dev, local->target_idx, skb,\n\t\t\t\t nfc_llcp_recv, local);\nout:\n\tnfc_llcp_local_put(local);\n\treturn err;\n}\n\nint nfc_llcp_send_connect(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sk_buff *skb;\n\tconst u8 *service_name_tlv = NULL;\n\tconst u8 *miux_tlv = NULL;\n\tconst u8 *rw_tlv = NULL;\n\tu8 service_name_tlv_length, miux_tlv_length,  rw_tlv_length, rw;\n\tint err;\n\tu16 size = 0;\n\t__be16 miux;\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tif (sock->service_name != NULL) {\n\t\tservice_name_tlv = nfc_llcp_build_tlv(LLCP_TLV_SN,\n\t\t\t\t\t\t      sock->service_name,\n\t\t\t\t\t\t      sock->service_name_len,\n\t\t\t\t\t\t      &service_name_tlv_length);\n\t\tif (!service_name_tlv) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error_tlv;\n\t\t}\n\t\tsize += service_name_tlv_length;\n\t}\n\n\t/* If the socket parameters are not set, use the local ones */\n\tmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\n\t\tlocal->miux : sock->miux;\n\trw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\n\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n\t\t\t\t      &miux_tlv_length);\n\tif (!miux_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += miux_tlv_length;\n\n\trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n\tif (!rw_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += rw_tlv_length;\n\n\tpr_debug(\"SKB size %d SN length %zu\\n\", size, sock->service_name_len);\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_CONNECT, size);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\n\tllcp_add_tlv(skb, service_name_tlv, service_name_tlv_length);\n\tllcp_add_tlv(skb, miux_tlv, miux_tlv_length);\n\tllcp_add_tlv(skb, rw_tlv, rw_tlv_length);\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\terr = 0;\n\nerror_tlv:\n\tif (err)\n\t\tpr_err(\"error %d\\n\", err);\n\n\tkfree(service_name_tlv);\n\tkfree(miux_tlv);\n\tkfree(rw_tlv);\n\n\treturn err;\n}\n\nint nfc_llcp_send_cc(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sk_buff *skb;\n\tconst u8 *miux_tlv = NULL;\n\tconst u8 *rw_tlv = NULL;\n\tu8 miux_tlv_length, rw_tlv_length, rw;\n\tint err;\n\tu16 size = 0;\n\t__be16 miux;\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\t/* If the socket parameters are not set, use the local ones */\n\tmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\n\t\tlocal->miux : sock->miux;\n\trw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\n\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n\t\t\t\t      &miux_tlv_length);\n\tif (!miux_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += miux_tlv_length;\n\n\trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n\tif (!rw_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += rw_tlv_length;\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\n\tllcp_add_tlv(skb, miux_tlv, miux_tlv_length);\n\tllcp_add_tlv(skb, rw_tlv, rw_tlv_length);\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\terr = 0;\n\nerror_tlv:\n\tif (err)\n\t\tpr_err(\"error %d\\n\", err);\n\n\tkfree(miux_tlv);\n\tkfree(rw_tlv);\n\n\treturn err;\n}\n\nstatic struct sk_buff *nfc_llcp_allocate_snl(struct nfc_llcp_local *local,\n\t\t\t\t\t     size_t tlv_length)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_dev *dev;\n\tu16 size = 0;\n\n\tif (local == NULL)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tdev = local->dev;\n\tif (dev == NULL)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tsize += LLCP_HEADER_SIZE;\n\tsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\tsize += tlv_length;\n\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\n\tskb = llcp_add_header(skb, LLCP_SAP_SDP, LLCP_SAP_SDP, LLCP_PDU_SNL);\n\n\treturn skb;\n}\n\nint nfc_llcp_send_snl_sdres(struct nfc_llcp_local *local,\n\t\t\t    struct hlist_head *tlv_list, size_t tlvs_len)\n{\n\tstruct nfc_llcp_sdp_tlv *sdp;\n\tstruct hlist_node *n;\n\tstruct sk_buff *skb;\n\n\tskb = nfc_llcp_allocate_snl(local, tlvs_len);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\thlist_for_each_entry_safe(sdp, n, tlv_list, node) {\n\t\tskb_put_data(skb, sdp->tlv, sdp->tlv_len);\n\n\t\thlist_del(&sdp->node);\n\n\t\tnfc_llcp_free_sdp_tlv(sdp);\n\t}\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\treturn 0;\n}\n\nint nfc_llcp_send_snl_sdreq(struct nfc_llcp_local *local,\n\t\t\t    struct hlist_head *tlv_list, size_t tlvs_len)\n{\n\tstruct nfc_llcp_sdp_tlv *sdreq;\n\tstruct hlist_node *n;\n\tstruct sk_buff *skb;\n\n\tskb = nfc_llcp_allocate_snl(local, tlvs_len);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tmutex_lock(&local->sdreq_lock);\n\n\tif (hlist_empty(&local->pending_sdreqs))\n\t\tmod_timer(&local->sdreq_timer,\n\t\t\t  jiffies + msecs_to_jiffies(3 * local->remote_lto));\n\n\thlist_for_each_entry_safe(sdreq, n, tlv_list, node) {\n\t\tpr_debug(\"tid %d for %s\\n\", sdreq->tid, sdreq->uri);\n\n\t\tskb_put_data(skb, sdreq->tlv, sdreq->tlv_len);\n\n\t\thlist_del(&sdreq->node);\n\n\t\thlist_add_head(&sdreq->node, &local->pending_sdreqs);\n\t}\n\n\tmutex_unlock(&local->sdreq_lock);\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\treturn 0;\n}\n\nint nfc_llcp_send_dm(struct nfc_llcp_local *local, u8 ssap, u8 dsap, u8 reason)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_dev *dev;\n\tu16 size = 1; /* Reason code */\n\n\tpr_debug(\"Sending DM reason 0x%x\\n\", reason);\n\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tdev = local->dev;\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\tsize += LLCP_HEADER_SIZE;\n\tsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\n\tskb = llcp_add_header(skb, dsap, ssap, LLCP_PDU_DM);\n\n\tskb_put_data(skb, &reason, 1);\n\n\tskb_queue_head(&local->tx_queue, skb);\n\n\treturn 0;\n}\n\nint nfc_llcp_send_i_frame(struct nfc_llcp_sock *sock,\n\t\t\t  struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *pdu;\n\tstruct sock *sk = &sock->sk;\n\tstruct nfc_llcp_local *local;\n\tsize_t frag_len = 0, remaining_len;\n\tu8 *msg_data, *msg_ptr;\n\tu16 remote_miu;\n\n\tpr_debug(\"Send I frame len %zd\\n\", len);\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\t/* Remote is ready but has not acknowledged our frames */\n\tif((sock->remote_ready &&\n\t    skb_queue_len(&sock->tx_pending_queue) >= sock->remote_rw &&\n\t    skb_queue_len(&sock->tx_queue) >= 2 * sock->remote_rw)) {\n\t\tpr_err(\"Pending queue is full %d frames\\n\",\n\t\t       skb_queue_len(&sock->tx_pending_queue));\n\t\treturn -ENOBUFS;\n\t}\n\n\t/* Remote is not ready and we've been queueing enough frames */\n\tif ((!sock->remote_ready &&\n\t     skb_queue_len(&sock->tx_queue) >= 2 * sock->remote_rw)) {\n\t\tpr_err(\"Tx queue is full %d frames\\n\",\n\t\t       skb_queue_len(&sock->tx_queue));\n\t\treturn -ENOBUFS;\n\t}\n\n\tmsg_data = kmalloc(len, GFP_USER | __GFP_NOWARN);\n\tif (msg_data == NULL)\n\t\treturn -ENOMEM;\n\n\tif (memcpy_from_msg(msg_data, msg, len)) {\n\t\tkfree(msg_data);\n\t\treturn -EFAULT;\n\t}\n\n\tremaining_len = len;\n\tmsg_ptr = msg_data;\n\n\tdo {\n\t\tremote_miu = sock->remote_miu > LLCP_MAX_MIU ?\n\t\t\t\tLLCP_DEFAULT_MIU : sock->remote_miu;\n\n\t\tfrag_len = min_t(size_t, remote_miu, remaining_len);\n\n\t\tpr_debug(\"Fragment %zd bytes remaining %zd\",\n\t\t\t frag_len, remaining_len);\n\n\t\tpdu = llcp_allocate_pdu(sock, LLCP_PDU_I,\n\t\t\t\t\tfrag_len + LLCP_SEQUENCE_SIZE);\n\t\tif (pdu == NULL) {\n\t\t\tkfree(msg_data);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tskb_put(pdu, LLCP_SEQUENCE_SIZE);\n\n\t\tif (likely(frag_len > 0))\n\t\t\tskb_put_data(pdu, msg_ptr, frag_len);\n\n\t\tskb_queue_tail(&sock->tx_queue, pdu);\n\n\t\tlock_sock(sk);\n\n\t\tnfc_llcp_queue_i_frames(sock);\n\n\t\trelease_sock(sk);\n\n\t\tremaining_len -= frag_len;\n\t\tmsg_ptr += frag_len;\n\t} while (remaining_len > 0);\n\n\tkfree(msg_data);\n\n\treturn len;\n}\n\nint nfc_llcp_send_ui_frame(struct nfc_llcp_sock *sock, u8 ssap, u8 dsap,\n\t\t\t   struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *pdu;\n\tstruct nfc_llcp_local *local;\n\tsize_t frag_len = 0, remaining_len;\n\tu8 *msg_ptr, *msg_data;\n\tu16 remote_miu;\n\tint err;\n\n\tpr_debug(\"Send UI frame len %zd\\n\", len);\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tmsg_data = kmalloc(len, GFP_USER | __GFP_NOWARN);\n\tif (msg_data == NULL)\n\t\treturn -ENOMEM;\n\n\tif (memcpy_from_msg(msg_data, msg, len)) {\n\t\tkfree(msg_data);\n\t\treturn -EFAULT;\n\t}\n\n\tremaining_len = len;\n\tmsg_ptr = msg_data;\n\n\tdo {\n\t\tremote_miu = sock->remote_miu > LLCP_MAX_MIU ?\n\t\t\t\tlocal->remote_miu : sock->remote_miu;\n\n\t\tfrag_len = min_t(size_t, remote_miu, remaining_len);\n\n\t\tpr_debug(\"Fragment %zd bytes remaining %zd\",\n\t\t\t frag_len, remaining_len);\n\n\t\tpdu = nfc_alloc_send_skb(sock->dev, &sock->sk, 0,\n\t\t\t\t\t frag_len + LLCP_HEADER_SIZE, &err);\n\t\tif (pdu == NULL) {\n\t\t\tpr_err(\"Could not allocate PDU (error=%d)\\n\", err);\n\t\t\tlen -= remaining_len;\n\t\t\tif (len == 0)\n\t\t\t\tlen = err;\n\t\t\tbreak;\n\t\t}\n\n\t\tpdu = llcp_add_header(pdu, dsap, ssap, LLCP_PDU_UI);\n\n\t\tif (likely(frag_len > 0))\n\t\t\tskb_put_data(pdu, msg_ptr, frag_len);\n\n\t\t/* No need to check for the peer RW for UI frames */\n\t\tskb_queue_tail(&local->tx_queue, pdu);\n\n\t\tremaining_len -= frag_len;\n\t\tmsg_ptr += frag_len;\n\t} while (remaining_len > 0);\n\n\tkfree(msg_data);\n\n\treturn len;\n}\n\nint nfc_llcp_send_rr(struct nfc_llcp_sock *sock)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_llcp_local *local;\n\n\tpr_debug(\"Send rr nr %d\\n\", sock->recv_n);\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_RR, LLCP_SEQUENCE_SIZE);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tskb_put(skb, LLCP_SEQUENCE_SIZE);\n\n\tskb->data[2] = sock->recv_n;\n\n\tskb_queue_head(&local->tx_queue, skb);\n\n\treturn 0;\n}\n", "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Copyright (C) 2011  Intel Corporation. All rights reserved.\n * Copyright (C) 2014 Marvell International Ltd.\n */\n\n#define pr_fmt(fmt) \"llcp: %s: \" fmt, __func__\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/nfc.h>\n\n#include \"nfc.h\"\n#include \"llcp.h\"\n\nstatic u8 llcp_magic[3] = {0x46, 0x66, 0x6d};\n\nstatic LIST_HEAD(llcp_devices);\n/* Protects llcp_devices list */\nstatic DEFINE_SPINLOCK(llcp_devices_lock);\n\nstatic void nfc_llcp_rx_skb(struct nfc_llcp_local *local, struct sk_buff *skb);\n\nvoid nfc_llcp_sock_link(struct llcp_sock_list *l, struct sock *sk)\n{\n\twrite_lock(&l->lock);\n\tsk_add_node(sk, &l->head);\n\twrite_unlock(&l->lock);\n}\n\nvoid nfc_llcp_sock_unlink(struct llcp_sock_list *l, struct sock *sk)\n{\n\twrite_lock(&l->lock);\n\tsk_del_node_init(sk);\n\twrite_unlock(&l->lock);\n}\n\nvoid nfc_llcp_socket_remote_param_init(struct nfc_llcp_sock *sock)\n{\n\tsock->remote_rw = LLCP_DEFAULT_RW;\n\tsock->remote_miu = LLCP_MAX_MIU + 1;\n}\n\nstatic void nfc_llcp_socket_purge(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local = sock->local;\n\tstruct sk_buff *s, *tmp;\n\n\tskb_queue_purge(&sock->tx_queue);\n\tskb_queue_purge(&sock->tx_pending_queue);\n\n\tif (local == NULL)\n\t\treturn;\n\n\t/* Search for local pending SKBs that are related to this socket */\n\tskb_queue_walk_safe(&local->tx_queue, s, tmp) {\n\t\tif (s->sk != &sock->sk)\n\t\t\tcontinue;\n\n\t\tskb_unlink(s, &local->tx_queue);\n\t\tkfree_skb(s);\n\t}\n}\n\nstatic void nfc_llcp_socket_release(struct nfc_llcp_local *local, bool device,\n\t\t\t\t    int err)\n{\n\tstruct sock *sk;\n\tstruct hlist_node *tmp;\n\tstruct nfc_llcp_sock *llcp_sock;\n\n\tskb_queue_purge(&local->tx_queue);\n\n\twrite_lock(&local->sockets.lock);\n\n\tsk_for_each_safe(sk, tmp, &local->sockets.head) {\n\t\tllcp_sock = nfc_llcp_sock(sk);\n\n\t\tbh_lock_sock(sk);\n\n\t\tnfc_llcp_socket_purge(llcp_sock);\n\n\t\tif (sk->sk_state == LLCP_CONNECTED)\n\t\t\tnfc_put_device(llcp_sock->dev);\n\n\t\tif (sk->sk_state == LLCP_LISTEN) {\n\t\t\tstruct nfc_llcp_sock *lsk, *n;\n\t\t\tstruct sock *accept_sk;\n\n\t\t\tlist_for_each_entry_safe(lsk, n,\n\t\t\t\t\t\t &llcp_sock->accept_queue,\n\t\t\t\t\t\t accept_queue) {\n\t\t\t\taccept_sk = &lsk->sk;\n\t\t\t\tbh_lock_sock(accept_sk);\n\n\t\t\t\tnfc_llcp_accept_unlink(accept_sk);\n\n\t\t\t\tif (err)\n\t\t\t\t\taccept_sk->sk_err = err;\n\t\t\t\taccept_sk->sk_state = LLCP_CLOSED;\n\t\t\t\taccept_sk->sk_state_change(sk);\n\n\t\t\t\tbh_unlock_sock(accept_sk);\n\t\t\t}\n\t\t}\n\n\t\tif (err)\n\t\t\tsk->sk_err = err;\n\t\tsk->sk_state = LLCP_CLOSED;\n\t\tsk->sk_state_change(sk);\n\n\t\tbh_unlock_sock(sk);\n\n\t\tsk_del_node_init(sk);\n\t}\n\n\twrite_unlock(&local->sockets.lock);\n\n\t/* If we still have a device, we keep the RAW sockets alive */\n\tif (device == true)\n\t\treturn;\n\n\twrite_lock(&local->raw_sockets.lock);\n\n\tsk_for_each_safe(sk, tmp, &local->raw_sockets.head) {\n\t\tllcp_sock = nfc_llcp_sock(sk);\n\n\t\tbh_lock_sock(sk);\n\n\t\tnfc_llcp_socket_purge(llcp_sock);\n\n\t\tif (err)\n\t\t\tsk->sk_err = err;\n\t\tsk->sk_state = LLCP_CLOSED;\n\t\tsk->sk_state_change(sk);\n\n\t\tbh_unlock_sock(sk);\n\n\t\tsk_del_node_init(sk);\n\t}\n\n\twrite_unlock(&local->raw_sockets.lock);\n}\n\nstatic struct nfc_llcp_local *nfc_llcp_local_get(struct nfc_llcp_local *local)\n{\n\tkref_get(&local->ref);\n\n\treturn local;\n}\n\nstatic void local_cleanup(struct nfc_llcp_local *local)\n{\n\tnfc_llcp_socket_release(local, false, ENXIO);\n\tdel_timer_sync(&local->link_timer);\n\tskb_queue_purge(&local->tx_queue);\n\tcancel_work_sync(&local->tx_work);\n\tcancel_work_sync(&local->rx_work);\n\tcancel_work_sync(&local->timeout_work);\n\tkfree_skb(local->rx_pending);\n\tlocal->rx_pending = NULL;\n\tdel_timer_sync(&local->sdreq_timer);\n\tcancel_work_sync(&local->sdreq_timeout_work);\n\tnfc_llcp_free_sdp_tlv_list(&local->pending_sdreqs);\n}\n\nstatic void local_release(struct kref *ref)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = container_of(ref, struct nfc_llcp_local, ref);\n\n\tlocal_cleanup(local);\n\tkfree(local);\n}\n\nint nfc_llcp_local_put(struct nfc_llcp_local *local)\n{\n\tif (local == NULL)\n\t\treturn 0;\n\n\treturn kref_put(&local->ref, local_release);\n}\n\nstatic struct nfc_llcp_sock *nfc_llcp_sock_get(struct nfc_llcp_local *local,\n\t\t\t\t\t       u8 ssap, u8 dsap)\n{\n\tstruct sock *sk;\n\tstruct nfc_llcp_sock *llcp_sock, *tmp_sock;\n\n\tpr_debug(\"ssap dsap %d %d\\n\", ssap, dsap);\n\n\tif (ssap == 0 && dsap == 0)\n\t\treturn NULL;\n\n\tread_lock(&local->sockets.lock);\n\n\tllcp_sock = NULL;\n\n\tsk_for_each(sk, &local->sockets.head) {\n\t\ttmp_sock = nfc_llcp_sock(sk);\n\n\t\tif (tmp_sock->ssap == ssap && tmp_sock->dsap == dsap) {\n\t\t\tllcp_sock = tmp_sock;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tread_unlock(&local->sockets.lock);\n\n\tif (llcp_sock == NULL)\n\t\treturn NULL;\n\n\tsock_hold(&llcp_sock->sk);\n\n\treturn llcp_sock;\n}\n\nstatic void nfc_llcp_sock_put(struct nfc_llcp_sock *sock)\n{\n\tsock_put(&sock->sk);\n}\n\nstatic void nfc_llcp_timeout_work(struct work_struct *work)\n{\n\tstruct nfc_llcp_local *local = container_of(work, struct nfc_llcp_local,\n\t\t\t\t\t\t    timeout_work);\n\n\tnfc_dep_link_down(local->dev);\n}\n\nstatic void nfc_llcp_symm_timer(struct timer_list *t)\n{\n\tstruct nfc_llcp_local *local = from_timer(local, t, link_timer);\n\n\tpr_err(\"SYMM timeout\\n\");\n\n\tschedule_work(&local->timeout_work);\n}\n\nstatic void nfc_llcp_sdreq_timeout_work(struct work_struct *work)\n{\n\tunsigned long time;\n\tHLIST_HEAD(nl_sdres_list);\n\tstruct hlist_node *n;\n\tstruct nfc_llcp_sdp_tlv *sdp;\n\tstruct nfc_llcp_local *local = container_of(work, struct nfc_llcp_local,\n\t\t\t\t\t\t    sdreq_timeout_work);\n\n\tmutex_lock(&local->sdreq_lock);\n\n\ttime = jiffies - msecs_to_jiffies(3 * local->remote_lto);\n\n\thlist_for_each_entry_safe(sdp, n, &local->pending_sdreqs, node) {\n\t\tif (time_after(sdp->time, time))\n\t\t\tcontinue;\n\n\t\tsdp->sap = LLCP_SDP_UNBOUND;\n\n\t\thlist_del(&sdp->node);\n\n\t\thlist_add_head(&sdp->node, &nl_sdres_list);\n\t}\n\n\tif (!hlist_empty(&local->pending_sdreqs))\n\t\tmod_timer(&local->sdreq_timer,\n\t\t\t  jiffies + msecs_to_jiffies(3 * local->remote_lto));\n\n\tmutex_unlock(&local->sdreq_lock);\n\n\tif (!hlist_empty(&nl_sdres_list))\n\t\tnfc_genl_llc_send_sdres(local->dev, &nl_sdres_list);\n}\n\nstatic void nfc_llcp_sdreq_timer(struct timer_list *t)\n{\n\tstruct nfc_llcp_local *local = from_timer(local, t, sdreq_timer);\n\n\tschedule_work(&local->sdreq_timeout_work);\n}\n\nstruct nfc_llcp_local *nfc_llcp_find_local(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_llcp_local *res = NULL;\n\n\tspin_lock(&llcp_devices_lock);\n\tlist_for_each_entry(local, &llcp_devices, list)\n\t\tif (local->dev == dev) {\n\t\t\tres = nfc_llcp_local_get(local);\n\t\t\tbreak;\n\t\t}\n\tspin_unlock(&llcp_devices_lock);\n\n\treturn res;\n}\n\nstatic struct nfc_llcp_local *nfc_llcp_remove_local(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local, *tmp;\n\n\tspin_lock(&llcp_devices_lock);\n\tlist_for_each_entry_safe(local, tmp, &llcp_devices, list)\n\t\tif (local->dev == dev) {\n\t\t\tlist_del(&local->list);\n\t\t\tspin_unlock(&llcp_devices_lock);\n\t\t\treturn local;\n\t\t}\n\tspin_unlock(&llcp_devices_lock);\n\n\tpr_warn(\"Shutting down device not found\\n\");\n\n\treturn NULL;\n}\n\nstatic char *wks[] = {\n\tNULL,\n\tNULL, /* SDP */\n\t\"urn:nfc:sn:ip\",\n\t\"urn:nfc:sn:obex\",\n\t\"urn:nfc:sn:snep\",\n};\n\nstatic int nfc_llcp_wks_sap(const char *service_name, size_t service_name_len)\n{\n\tint sap, num_wks;\n\n\tpr_debug(\"%s\\n\", service_name);\n\n\tif (service_name == NULL)\n\t\treturn -EINVAL;\n\n\tnum_wks = ARRAY_SIZE(wks);\n\n\tfor (sap = 0; sap < num_wks; sap++) {\n\t\tif (wks[sap] == NULL)\n\t\t\tcontinue;\n\n\t\tif (strncmp(wks[sap], service_name, service_name_len) == 0)\n\t\t\treturn sap;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic\nstruct nfc_llcp_sock *nfc_llcp_sock_from_sn(struct nfc_llcp_local *local,\n\t\t\t\t\t    const u8 *sn, size_t sn_len)\n{\n\tstruct sock *sk;\n\tstruct nfc_llcp_sock *llcp_sock, *tmp_sock;\n\n\tpr_debug(\"sn %zd %p\\n\", sn_len, sn);\n\n\tif (sn == NULL || sn_len == 0)\n\t\treturn NULL;\n\n\tread_lock(&local->sockets.lock);\n\n\tllcp_sock = NULL;\n\n\tsk_for_each(sk, &local->sockets.head) {\n\t\ttmp_sock = nfc_llcp_sock(sk);\n\n\t\tpr_debug(\"llcp sock %p\\n\", tmp_sock);\n\n\t\tif (tmp_sock->sk.sk_type == SOCK_STREAM &&\n\t\t    tmp_sock->sk.sk_state != LLCP_LISTEN)\n\t\t\tcontinue;\n\n\t\tif (tmp_sock->sk.sk_type == SOCK_DGRAM &&\n\t\t    tmp_sock->sk.sk_state != LLCP_BOUND)\n\t\t\tcontinue;\n\n\t\tif (tmp_sock->service_name == NULL ||\n\t\t    tmp_sock->service_name_len == 0)\n\t\t\tcontinue;\n\n\t\tif (tmp_sock->service_name_len != sn_len)\n\t\t\tcontinue;\n\n\t\tif (memcmp(sn, tmp_sock->service_name, sn_len) == 0) {\n\t\t\tllcp_sock = tmp_sock;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tread_unlock(&local->sockets.lock);\n\n\tpr_debug(\"Found llcp sock %p\\n\", llcp_sock);\n\n\treturn llcp_sock;\n}\n\nu8 nfc_llcp_get_sdp_ssap(struct nfc_llcp_local *local,\n\t\t\t struct nfc_llcp_sock *sock)\n{\n\tmutex_lock(&local->sdp_lock);\n\n\tif (sock->service_name != NULL && sock->service_name_len > 0) {\n\t\tint ssap = nfc_llcp_wks_sap(sock->service_name,\n\t\t\t\t\t    sock->service_name_len);\n\n\t\tif (ssap > 0) {\n\t\t\tpr_debug(\"WKS %d\\n\", ssap);\n\n\t\t\t/* This is a WKS, let's check if it's free */\n\t\t\tif (test_bit(ssap, &local->local_wks)) {\n\t\t\t\tmutex_unlock(&local->sdp_lock);\n\n\t\t\t\treturn LLCP_SAP_MAX;\n\t\t\t}\n\n\t\t\tset_bit(ssap, &local->local_wks);\n\t\t\tmutex_unlock(&local->sdp_lock);\n\n\t\t\treturn ssap;\n\t\t}\n\n\t\t/*\n\t\t * Check if there already is a non WKS socket bound\n\t\t * to this service name.\n\t\t */\n\t\tif (nfc_llcp_sock_from_sn(local, sock->service_name,\n\t\t\t\t\t  sock->service_name_len) != NULL) {\n\t\t\tmutex_unlock(&local->sdp_lock);\n\n\t\t\treturn LLCP_SAP_MAX;\n\t\t}\n\n\t\tmutex_unlock(&local->sdp_lock);\n\n\t\treturn LLCP_SDP_UNBOUND;\n\n\t} else if (sock->ssap != 0 && sock->ssap < LLCP_WKS_NUM_SAP) {\n\t\tif (!test_bit(sock->ssap, &local->local_wks)) {\n\t\t\tset_bit(sock->ssap, &local->local_wks);\n\t\t\tmutex_unlock(&local->sdp_lock);\n\n\t\t\treturn sock->ssap;\n\t\t}\n\t}\n\n\tmutex_unlock(&local->sdp_lock);\n\n\treturn LLCP_SAP_MAX;\n}\n\nu8 nfc_llcp_get_local_ssap(struct nfc_llcp_local *local)\n{\n\tu8 local_ssap;\n\n\tmutex_lock(&local->sdp_lock);\n\n\tlocal_ssap = find_first_zero_bit(&local->local_sap, LLCP_LOCAL_NUM_SAP);\n\tif (local_ssap == LLCP_LOCAL_NUM_SAP) {\n\t\tmutex_unlock(&local->sdp_lock);\n\t\treturn LLCP_SAP_MAX;\n\t}\n\n\tset_bit(local_ssap, &local->local_sap);\n\n\tmutex_unlock(&local->sdp_lock);\n\n\treturn local_ssap + LLCP_LOCAL_SAP_OFFSET;\n}\n\nvoid nfc_llcp_put_ssap(struct nfc_llcp_local *local, u8 ssap)\n{\n\tu8 local_ssap;\n\tunsigned long *sdp;\n\n\tif (ssap < LLCP_WKS_NUM_SAP) {\n\t\tlocal_ssap = ssap;\n\t\tsdp = &local->local_wks;\n\t} else if (ssap < LLCP_LOCAL_NUM_SAP) {\n\t\tatomic_t *client_cnt;\n\n\t\tlocal_ssap = ssap - LLCP_WKS_NUM_SAP;\n\t\tsdp = &local->local_sdp;\n\t\tclient_cnt = &local->local_sdp_cnt[local_ssap];\n\n\t\tpr_debug(\"%d clients\\n\", atomic_read(client_cnt));\n\n\t\tmutex_lock(&local->sdp_lock);\n\n\t\tif (atomic_dec_and_test(client_cnt)) {\n\t\t\tstruct nfc_llcp_sock *l_sock;\n\n\t\t\tpr_debug(\"No more clients for SAP %d\\n\", ssap);\n\n\t\t\tclear_bit(local_ssap, sdp);\n\n\t\t\t/* Find the listening sock and set it back to UNBOUND */\n\t\t\tl_sock = nfc_llcp_sock_get(local, ssap, LLCP_SAP_SDP);\n\t\t\tif (l_sock) {\n\t\t\t\tl_sock->ssap = LLCP_SDP_UNBOUND;\n\t\t\t\tnfc_llcp_sock_put(l_sock);\n\t\t\t}\n\t\t}\n\n\t\tmutex_unlock(&local->sdp_lock);\n\n\t\treturn;\n\t} else if (ssap < LLCP_MAX_SAP) {\n\t\tlocal_ssap = ssap - LLCP_LOCAL_NUM_SAP;\n\t\tsdp = &local->local_sap;\n\t} else {\n\t\treturn;\n\t}\n\n\tmutex_lock(&local->sdp_lock);\n\n\tclear_bit(local_ssap, sdp);\n\n\tmutex_unlock(&local->sdp_lock);\n}\n\nstatic u8 nfc_llcp_reserve_sdp_ssap(struct nfc_llcp_local *local)\n{\n\tu8 ssap;\n\n\tmutex_lock(&local->sdp_lock);\n\n\tssap = find_first_zero_bit(&local->local_sdp, LLCP_SDP_NUM_SAP);\n\tif (ssap == LLCP_SDP_NUM_SAP) {\n\t\tmutex_unlock(&local->sdp_lock);\n\n\t\treturn LLCP_SAP_MAX;\n\t}\n\n\tpr_debug(\"SDP ssap %d\\n\", LLCP_WKS_NUM_SAP + ssap);\n\n\tset_bit(ssap, &local->local_sdp);\n\n\tmutex_unlock(&local->sdp_lock);\n\n\treturn LLCP_WKS_NUM_SAP + ssap;\n}\n\nstatic int nfc_llcp_build_gb(struct nfc_llcp_local *local)\n{\n\tu8 *gb_cur, version, version_length;\n\tu8 lto_length, wks_length, miux_length;\n\tconst u8 *version_tlv = NULL, *lto_tlv = NULL,\n\t   *wks_tlv = NULL, *miux_tlv = NULL;\n\t__be16 wks = cpu_to_be16(local->local_wks);\n\tu8 gb_len = 0;\n\tint ret = 0;\n\n\tversion = LLCP_VERSION_11;\n\tversion_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,\n\t\t\t\t\t 1, &version_length);\n\tif (!version_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgb_len += version_length;\n\n\tlto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);\n\tif (!lto_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgb_len += lto_length;\n\n\tpr_debug(\"Local wks 0x%lx\\n\", local->local_wks);\n\twks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);\n\tif (!wks_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgb_len += wks_length;\n\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,\n\t\t\t\t      &miux_length);\n\tif (!miux_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgb_len += miux_length;\n\n\tgb_len += ARRAY_SIZE(llcp_magic);\n\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tgb_cur = local->gb;\n\n\tmemcpy(gb_cur, llcp_magic, ARRAY_SIZE(llcp_magic));\n\tgb_cur += ARRAY_SIZE(llcp_magic);\n\n\tmemcpy(gb_cur, version_tlv, version_length);\n\tgb_cur += version_length;\n\n\tmemcpy(gb_cur, lto_tlv, lto_length);\n\tgb_cur += lto_length;\n\n\tmemcpy(gb_cur, wks_tlv, wks_length);\n\tgb_cur += wks_length;\n\n\tmemcpy(gb_cur, miux_tlv, miux_length);\n\tgb_cur += miux_length;\n\n\tlocal->gb_len = gb_len;\n\nout:\n\tkfree(version_tlv);\n\tkfree(lto_tlv);\n\tkfree(wks_tlv);\n\tkfree(miux_tlv);\n\n\treturn ret;\n}\n\nu8 *nfc_llcp_general_bytes(struct nfc_dev *dev, size_t *general_bytes_len)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\t*general_bytes_len = 0;\n\t\treturn NULL;\n\t}\n\n\tnfc_llcp_build_gb(local);\n\n\t*general_bytes_len = local->gb_len;\n\n\tnfc_llcp_local_put(local);\n\n\treturn local->gb;\n}\n\nint nfc_llcp_set_remote_gb(struct nfc_dev *dev, const u8 *gb, u8 gb_len)\n{\n\tstruct nfc_llcp_local *local;\n\tint err;\n\n\tif (gb_len < 3 || gb_len > NFC_MAX_GT_LEN)\n\t\treturn -EINVAL;\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tpr_err(\"No LLCP device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmemset(local->remote_gb, 0, NFC_MAX_GT_LEN);\n\tmemcpy(local->remote_gb, gb, gb_len);\n\tlocal->remote_gb_len = gb_len;\n\n\tif (memcmp(local->remote_gb, llcp_magic, 3)) {\n\t\tpr_err(\"MAC does not support LLCP\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = nfc_llcp_parse_gb_tlv(local,\n\t\t\t\t     &local->remote_gb[3],\n\t\t\t\t     local->remote_gb_len - 3);\nout:\n\tnfc_llcp_local_put(local);\n\treturn err;\n}\n\nstatic u8 nfc_llcp_dsap(const struct sk_buff *pdu)\n{\n\treturn (pdu->data[0] & 0xfc) >> 2;\n}\n\nstatic u8 nfc_llcp_ptype(const struct sk_buff *pdu)\n{\n\treturn ((pdu->data[0] & 0x03) << 2) | ((pdu->data[1] & 0xc0) >> 6);\n}\n\nstatic u8 nfc_llcp_ssap(const struct sk_buff *pdu)\n{\n\treturn pdu->data[1] & 0x3f;\n}\n\nstatic u8 nfc_llcp_ns(const struct sk_buff *pdu)\n{\n\treturn pdu->data[2] >> 4;\n}\n\nstatic u8 nfc_llcp_nr(const struct sk_buff *pdu)\n{\n\treturn pdu->data[2] & 0xf;\n}\n\nstatic void nfc_llcp_set_nrns(struct nfc_llcp_sock *sock, struct sk_buff *pdu)\n{\n\tpdu->data[2] = (sock->send_n << 4) | (sock->recv_n);\n\tsock->send_n = (sock->send_n + 1) % 16;\n\tsock->recv_ack_n = (sock->recv_n - 1) % 16;\n}\n\nvoid nfc_llcp_send_to_raw_sock(struct nfc_llcp_local *local,\n\t\t\t       struct sk_buff *skb, u8 direction)\n{\n\tstruct sk_buff *skb_copy = NULL, *nskb;\n\tstruct sock *sk;\n\tu8 *data;\n\n\tread_lock(&local->raw_sockets.lock);\n\n\tsk_for_each(sk, &local->raw_sockets.head) {\n\t\tif (sk->sk_state != LLCP_BOUND)\n\t\t\tcontinue;\n\n\t\tif (skb_copy == NULL) {\n\t\t\tskb_copy = __pskb_copy_fclone(skb, NFC_RAW_HEADER_SIZE,\n\t\t\t\t\t\t      GFP_ATOMIC, true);\n\n\t\t\tif (skb_copy == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tdata = skb_push(skb_copy, NFC_RAW_HEADER_SIZE);\n\n\t\t\tdata[0] = local->dev ? local->dev->idx : 0xFF;\n\t\t\tdata[1] = direction & 0x01;\n\t\t\tdata[1] |= (RAW_PAYLOAD_LLCP << 1);\n\t\t}\n\n\t\tnskb = skb_clone(skb_copy, GFP_ATOMIC);\n\t\tif (!nskb)\n\t\t\tcontinue;\n\n\t\tif (sock_queue_rcv_skb(sk, nskb))\n\t\t\tkfree_skb(nskb);\n\t}\n\n\tread_unlock(&local->raw_sockets.lock);\n\n\tkfree_skb(skb_copy);\n}\n\nstatic void nfc_llcp_tx_work(struct work_struct *work)\n{\n\tstruct nfc_llcp_local *local = container_of(work, struct nfc_llcp_local,\n\t\t\t\t\t\t    tx_work);\n\tstruct sk_buff *skb;\n\tstruct sock *sk;\n\tstruct nfc_llcp_sock *llcp_sock;\n\n\tskb = skb_dequeue(&local->tx_queue);\n\tif (skb != NULL) {\n\t\tsk = skb->sk;\n\t\tllcp_sock = nfc_llcp_sock(sk);\n\n\t\tif (llcp_sock == NULL && nfc_llcp_ptype(skb) == LLCP_PDU_I) {\n\t\t\tkfree_skb(skb);\n\t\t\tnfc_llcp_send_symm(local->dev);\n\t\t} else if (llcp_sock && !llcp_sock->remote_ready) {\n\t\t\tskb_queue_head(&local->tx_queue, skb);\n\t\t\tnfc_llcp_send_symm(local->dev);\n\t\t} else {\n\t\t\tstruct sk_buff *copy_skb = NULL;\n\t\t\tu8 ptype = nfc_llcp_ptype(skb);\n\t\t\tint ret;\n\n\t\t\tpr_debug(\"Sending pending skb\\n\");\n\t\t\tprint_hex_dump_debug(\"LLCP Tx: \", DUMP_PREFIX_OFFSET,\n\t\t\t\t\t     16, 1, skb->data, skb->len, true);\n\n\t\t\tif (ptype == LLCP_PDU_I)\n\t\t\t\tcopy_skb = skb_copy(skb, GFP_ATOMIC);\n\n\t\t\t__net_timestamp(skb);\n\n\t\t\tnfc_llcp_send_to_raw_sock(local, skb,\n\t\t\t\t\t\t  NFC_DIRECTION_TX);\n\n\t\t\tret = nfc_data_exchange(local->dev, local->target_idx,\n\t\t\t\t\t\tskb, nfc_llcp_recv, local);\n\n\t\t\tif (ret) {\n\t\t\t\tkfree_skb(copy_skb);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (ptype == LLCP_PDU_I && copy_skb)\n\t\t\t\tskb_queue_tail(&llcp_sock->tx_pending_queue,\n\t\t\t\t\t       copy_skb);\n\t\t}\n\t} else {\n\t\tnfc_llcp_send_symm(local->dev);\n\t}\n\nout:\n\tmod_timer(&local->link_timer,\n\t\t  jiffies + msecs_to_jiffies(2 * local->remote_lto));\n}\n\nstatic struct nfc_llcp_sock *nfc_llcp_connecting_sock_get(struct nfc_llcp_local *local,\n\t\t\t\t\t\t\t  u8 ssap)\n{\n\tstruct sock *sk;\n\tstruct nfc_llcp_sock *llcp_sock;\n\n\tread_lock(&local->connecting_sockets.lock);\n\n\tsk_for_each(sk, &local->connecting_sockets.head) {\n\t\tllcp_sock = nfc_llcp_sock(sk);\n\n\t\tif (llcp_sock->ssap == ssap) {\n\t\t\tsock_hold(&llcp_sock->sk);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tllcp_sock = NULL;\n\nout:\n\tread_unlock(&local->connecting_sockets.lock);\n\n\treturn llcp_sock;\n}\n\nstatic struct nfc_llcp_sock *nfc_llcp_sock_get_sn(struct nfc_llcp_local *local,\n\t\t\t\t\t\t  const u8 *sn, size_t sn_len)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\n\tllcp_sock = nfc_llcp_sock_from_sn(local, sn, sn_len);\n\n\tif (llcp_sock == NULL)\n\t\treturn NULL;\n\n\tsock_hold(&llcp_sock->sk);\n\n\treturn llcp_sock;\n}\n\nstatic const u8 *nfc_llcp_connect_sn(const struct sk_buff *skb, size_t *sn_len)\n{\n\tu8 type, length;\n\tconst u8 *tlv = &skb->data[2];\n\tsize_t tlv_array_len = skb->len - LLCP_HEADER_SIZE, offset = 0;\n\n\twhile (offset < tlv_array_len) {\n\t\ttype = tlv[0];\n\t\tlength = tlv[1];\n\n\t\tpr_debug(\"type 0x%x length %d\\n\", type, length);\n\n\t\tif (type == LLCP_TLV_SN) {\n\t\t\t*sn_len = length;\n\t\t\treturn &tlv[2];\n\t\t}\n\n\t\toffset += length + 2;\n\t\ttlv += length + 2;\n\t}\n\n\treturn NULL;\n}\n\nstatic void nfc_llcp_recv_ui(struct nfc_llcp_local *local,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct nfc_llcp_ui_cb *ui_cb;\n\tu8 dsap, ssap;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tui_cb = nfc_llcp_ui_skb_cb(skb);\n\tui_cb->dsap = dsap;\n\tui_cb->ssap = ssap;\n\n\tpr_debug(\"%d %d\\n\", dsap, ssap);\n\n\t/* We're looking for a bound socket, not a client one */\n\tllcp_sock = nfc_llcp_sock_get(local, dsap, LLCP_SAP_SDP);\n\tif (llcp_sock == NULL || llcp_sock->sk.sk_type != SOCK_DGRAM)\n\t\treturn;\n\n\t/* There is no sequence with UI frames */\n\tskb_pull(skb, LLCP_HEADER_SIZE);\n\tif (!sock_queue_rcv_skb(&llcp_sock->sk, skb)) {\n\t\t/*\n\t\t * UI frames will be freed from the socket layer, so we\n\t\t * need to keep them alive until someone receives them.\n\t\t */\n\t\tskb_get(skb);\n\t} else {\n\t\tpr_err(\"Receive queue is full\\n\");\n\t}\n\n\tnfc_llcp_sock_put(llcp_sock);\n}\n\nstatic void nfc_llcp_recv_connect(struct nfc_llcp_local *local,\n\t\t\t\t  const struct sk_buff *skb)\n{\n\tstruct sock *new_sk, *parent;\n\tstruct nfc_llcp_sock *sock, *new_sock;\n\tu8 dsap, ssap, reason;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tpr_debug(\"%d %d\\n\", dsap, ssap);\n\n\tif (dsap != LLCP_SAP_SDP) {\n\t\tsock = nfc_llcp_sock_get(local, dsap, LLCP_SAP_SDP);\n\t\tif (sock == NULL || sock->sk.sk_state != LLCP_LISTEN) {\n\t\t\treason = LLCP_DM_NOBOUND;\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\tconst u8 *sn;\n\t\tsize_t sn_len;\n\n\t\tsn = nfc_llcp_connect_sn(skb, &sn_len);\n\t\tif (sn == NULL) {\n\t\t\treason = LLCP_DM_NOBOUND;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tpr_debug(\"Service name length %zu\\n\", sn_len);\n\n\t\tsock = nfc_llcp_sock_get_sn(local, sn, sn_len);\n\t\tif (sock == NULL) {\n\t\t\treason = LLCP_DM_NOBOUND;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tlock_sock(&sock->sk);\n\n\tparent = &sock->sk;\n\n\tif (sk_acceptq_is_full(parent)) {\n\t\treason = LLCP_DM_REJ;\n\t\trelease_sock(&sock->sk);\n\t\tsock_put(&sock->sk);\n\t\tgoto fail;\n\t}\n\n\tif (sock->ssap == LLCP_SDP_UNBOUND) {\n\t\tu8 ssap = nfc_llcp_reserve_sdp_ssap(local);\n\n\t\tpr_debug(\"First client, reserving %d\\n\", ssap);\n\n\t\tif (ssap == LLCP_SAP_MAX) {\n\t\t\treason = LLCP_DM_REJ;\n\t\t\trelease_sock(&sock->sk);\n\t\t\tsock_put(&sock->sk);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tsock->ssap = ssap;\n\t}\n\n\tnew_sk = nfc_llcp_sock_alloc(NULL, parent->sk_type, GFP_ATOMIC, 0);\n\tif (new_sk == NULL) {\n\t\treason = LLCP_DM_REJ;\n\t\trelease_sock(&sock->sk);\n\t\tsock_put(&sock->sk);\n\t\tgoto fail;\n\t}\n\n\tnew_sock = nfc_llcp_sock(new_sk);\n\tnew_sock->dev = local->dev;\n\tnew_sock->local = nfc_llcp_local_get(local);\n\tnew_sock->rw = sock->rw;\n\tnew_sock->miux = sock->miux;\n\tnew_sock->nfc_protocol = sock->nfc_protocol;\n\tnew_sock->dsap = ssap;\n\tnew_sock->target_idx = local->target_idx;\n\tnew_sock->parent = parent;\n\tnew_sock->ssap = sock->ssap;\n\tif (sock->ssap < LLCP_LOCAL_NUM_SAP && sock->ssap >= LLCP_WKS_NUM_SAP) {\n\t\tatomic_t *client_count;\n\n\t\tpr_debug(\"reserved_ssap %d for %p\\n\", sock->ssap, new_sock);\n\n\t\tclient_count =\n\t\t\t&local->local_sdp_cnt[sock->ssap - LLCP_WKS_NUM_SAP];\n\n\t\tatomic_inc(client_count);\n\t\tnew_sock->reserved_ssap = sock->ssap;\n\t}\n\n\tnfc_llcp_parse_connection_tlv(new_sock, &skb->data[LLCP_HEADER_SIZE],\n\t\t\t\t      skb->len - LLCP_HEADER_SIZE);\n\n\tpr_debug(\"new sock %p sk %p\\n\", new_sock, &new_sock->sk);\n\n\tnfc_llcp_sock_link(&local->sockets, new_sk);\n\n\tnfc_llcp_accept_enqueue(&sock->sk, new_sk);\n\n\tnfc_get_device(local->dev->idx);\n\n\tnew_sk->sk_state = LLCP_CONNECTED;\n\n\t/* Wake the listening processes */\n\tparent->sk_data_ready(parent);\n\n\t/* Send CC */\n\tnfc_llcp_send_cc(new_sock);\n\n\trelease_sock(&sock->sk);\n\tsock_put(&sock->sk);\n\n\treturn;\n\nfail:\n\t/* Send DM */\n\tnfc_llcp_send_dm(local, dsap, ssap, reason);\n}\n\nint nfc_llcp_queue_i_frames(struct nfc_llcp_sock *sock)\n{\n\tint nr_frames = 0;\n\tstruct nfc_llcp_local *local = sock->local;\n\n\tpr_debug(\"Remote ready %d tx queue len %d remote rw %d\",\n\t\t sock->remote_ready, skb_queue_len(&sock->tx_pending_queue),\n\t\t sock->remote_rw);\n\n\t/* Try to queue some I frames for transmission */\n\twhile (sock->remote_ready &&\n\t       skb_queue_len(&sock->tx_pending_queue) < sock->remote_rw) {\n\t\tstruct sk_buff *pdu;\n\n\t\tpdu = skb_dequeue(&sock->tx_queue);\n\t\tif (pdu == NULL)\n\t\t\tbreak;\n\n\t\t/* Update N(S)/N(R) */\n\t\tnfc_llcp_set_nrns(sock, pdu);\n\n\t\tskb_queue_tail(&local->tx_queue, pdu);\n\t\tnr_frames++;\n\t}\n\n\treturn nr_frames;\n}\n\nstatic void nfc_llcp_recv_hdlc(struct nfc_llcp_local *local,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct sock *sk;\n\tu8 dsap, ssap, ptype, ns, nr;\n\n\tptype = nfc_llcp_ptype(skb);\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\tns = nfc_llcp_ns(skb);\n\tnr = nfc_llcp_nr(skb);\n\n\tpr_debug(\"%d %d R %d S %d\\n\", dsap, ssap, nr, ns);\n\n\tllcp_sock = nfc_llcp_sock_get(local, dsap, ssap);\n\tif (llcp_sock == NULL) {\n\t\tnfc_llcp_send_dm(local, dsap, ssap, LLCP_DM_NOCONN);\n\t\treturn;\n\t}\n\n\tsk = &llcp_sock->sk;\n\tlock_sock(sk);\n\tif (sk->sk_state == LLCP_CLOSED) {\n\t\trelease_sock(sk);\n\t\tnfc_llcp_sock_put(llcp_sock);\n\t}\n\n\t/* Pass the payload upstream */\n\tif (ptype == LLCP_PDU_I) {\n\t\tpr_debug(\"I frame, queueing on %p\\n\", &llcp_sock->sk);\n\n\t\tif (ns == llcp_sock->recv_n)\n\t\t\tllcp_sock->recv_n = (llcp_sock->recv_n + 1) % 16;\n\t\telse\n\t\t\tpr_err(\"Received out of sequence I PDU\\n\");\n\n\t\tskb_pull(skb, LLCP_HEADER_SIZE + LLCP_SEQUENCE_SIZE);\n\t\tif (!sock_queue_rcv_skb(&llcp_sock->sk, skb)) {\n\t\t\t/*\n\t\t\t * I frames will be freed from the socket layer, so we\n\t\t\t * need to keep them alive until someone receives them.\n\t\t\t */\n\t\t\tskb_get(skb);\n\t\t} else {\n\t\t\tpr_err(\"Receive queue is full\\n\");\n\t\t}\n\t}\n\n\t/* Remove skbs from the pending queue */\n\tif (llcp_sock->send_ack_n != nr) {\n\t\tstruct sk_buff *s, *tmp;\n\t\tu8 n;\n\n\t\tllcp_sock->send_ack_n = nr;\n\n\t\t/* Remove and free all skbs until ns == nr */\n\t\tskb_queue_walk_safe(&llcp_sock->tx_pending_queue, s, tmp) {\n\t\t\tn = nfc_llcp_ns(s);\n\n\t\t\tskb_unlink(s, &llcp_sock->tx_pending_queue);\n\t\t\tkfree_skb(s);\n\n\t\t\tif (n == nr)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Re-queue the remaining skbs for transmission */\n\t\tskb_queue_reverse_walk_safe(&llcp_sock->tx_pending_queue,\n\t\t\t\t\t    s, tmp) {\n\t\t\tskb_unlink(s, &llcp_sock->tx_pending_queue);\n\t\t\tskb_queue_head(&local->tx_queue, s);\n\t\t}\n\t}\n\n\tif (ptype == LLCP_PDU_RR)\n\t\tllcp_sock->remote_ready = true;\n\telse if (ptype == LLCP_PDU_RNR)\n\t\tllcp_sock->remote_ready = false;\n\n\tif (nfc_llcp_queue_i_frames(llcp_sock) == 0 && ptype == LLCP_PDU_I)\n\t\tnfc_llcp_send_rr(llcp_sock);\n\n\trelease_sock(sk);\n\tnfc_llcp_sock_put(llcp_sock);\n}\n\nstatic void nfc_llcp_recv_disc(struct nfc_llcp_local *local,\n\t\t\t       const struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct sock *sk;\n\tu8 dsap, ssap;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tif ((dsap == 0) && (ssap == 0)) {\n\t\tpr_debug(\"Connection termination\");\n\t\tnfc_dep_link_down(local->dev);\n\t\treturn;\n\t}\n\n\tllcp_sock = nfc_llcp_sock_get(local, dsap, ssap);\n\tif (llcp_sock == NULL) {\n\t\tnfc_llcp_send_dm(local, dsap, ssap, LLCP_DM_NOCONN);\n\t\treturn;\n\t}\n\n\tsk = &llcp_sock->sk;\n\tlock_sock(sk);\n\n\tnfc_llcp_socket_purge(llcp_sock);\n\n\tif (sk->sk_state == LLCP_CLOSED) {\n\t\trelease_sock(sk);\n\t\tnfc_llcp_sock_put(llcp_sock);\n\t}\n\n\tif (sk->sk_state == LLCP_CONNECTED) {\n\t\tnfc_put_device(local->dev);\n\t\tsk->sk_state = LLCP_CLOSED;\n\t\tsk->sk_state_change(sk);\n\t}\n\n\tnfc_llcp_send_dm(local, dsap, ssap, LLCP_DM_DISC);\n\n\trelease_sock(sk);\n\tnfc_llcp_sock_put(llcp_sock);\n}\n\nstatic void nfc_llcp_recv_cc(struct nfc_llcp_local *local,\n\t\t\t     const struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct sock *sk;\n\tu8 dsap, ssap;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tllcp_sock = nfc_llcp_connecting_sock_get(local, dsap);\n\tif (llcp_sock == NULL) {\n\t\tpr_err(\"Invalid CC\\n\");\n\t\tnfc_llcp_send_dm(local, dsap, ssap, LLCP_DM_NOCONN);\n\n\t\treturn;\n\t}\n\n\tsk = &llcp_sock->sk;\n\n\t/* Unlink from connecting and link to the client array */\n\tnfc_llcp_sock_unlink(&local->connecting_sockets, sk);\n\tnfc_llcp_sock_link(&local->sockets, sk);\n\tllcp_sock->dsap = ssap;\n\n\tnfc_llcp_parse_connection_tlv(llcp_sock, &skb->data[LLCP_HEADER_SIZE],\n\t\t\t\t      skb->len - LLCP_HEADER_SIZE);\n\n\tsk->sk_state = LLCP_CONNECTED;\n\tsk->sk_state_change(sk);\n\n\tnfc_llcp_sock_put(llcp_sock);\n}\n\nstatic void nfc_llcp_recv_dm(struct nfc_llcp_local *local,\n\t\t\t     const struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct sock *sk;\n\tu8 dsap, ssap, reason;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\treason = skb->data[2];\n\n\tpr_debug(\"%d %d reason %d\\n\", ssap, dsap, reason);\n\n\tswitch (reason) {\n\tcase LLCP_DM_NOBOUND:\n\tcase LLCP_DM_REJ:\n\t\tllcp_sock = nfc_llcp_connecting_sock_get(local, dsap);\n\t\tbreak;\n\n\tdefault:\n\t\tllcp_sock = nfc_llcp_sock_get(local, dsap, ssap);\n\t\tbreak;\n\t}\n\n\tif (llcp_sock == NULL) {\n\t\tpr_debug(\"Already closed\\n\");\n\t\treturn;\n\t}\n\n\tsk = &llcp_sock->sk;\n\n\tsk->sk_err = ENXIO;\n\tsk->sk_state = LLCP_CLOSED;\n\tsk->sk_state_change(sk);\n\n\tnfc_llcp_sock_put(llcp_sock);\n}\n\nstatic void nfc_llcp_recv_snl(struct nfc_llcp_local *local,\n\t\t\t      const struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tu8 dsap, ssap, type, length, tid, sap;\n\tconst u8 *tlv;\n\tu16 tlv_len, offset;\n\tconst char *service_name;\n\tsize_t service_name_len;\n\tstruct nfc_llcp_sdp_tlv *sdp;\n\tHLIST_HEAD(llc_sdres_list);\n\tsize_t sdres_tlvs_len;\n\tHLIST_HEAD(nl_sdres_list);\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tpr_debug(\"%d %d\\n\", dsap, ssap);\n\n\tif (dsap != LLCP_SAP_SDP || ssap != LLCP_SAP_SDP) {\n\t\tpr_err(\"Wrong SNL SAP\\n\");\n\t\treturn;\n\t}\n\n\ttlv = &skb->data[LLCP_HEADER_SIZE];\n\ttlv_len = skb->len - LLCP_HEADER_SIZE;\n\toffset = 0;\n\tsdres_tlvs_len = 0;\n\n\twhile (offset < tlv_len) {\n\t\ttype = tlv[0];\n\t\tlength = tlv[1];\n\n\t\tswitch (type) {\n\t\tcase LLCP_TLV_SDREQ:\n\t\t\ttid = tlv[2];\n\t\t\tservice_name = (char *) &tlv[3];\n\t\t\tservice_name_len = length - 1;\n\n\t\t\tpr_debug(\"Looking for %.16s\\n\", service_name);\n\n\t\t\tif (service_name_len == strlen(\"urn:nfc:sn:sdp\") &&\n\t\t\t    !strncmp(service_name, \"urn:nfc:sn:sdp\",\n\t\t\t\t     service_name_len)) {\n\t\t\t\tsap = 1;\n\t\t\t\tgoto add_snl;\n\t\t\t}\n\n\t\t\tllcp_sock = nfc_llcp_sock_from_sn(local, service_name,\n\t\t\t\t\t\t\t  service_name_len);\n\t\t\tif (!llcp_sock) {\n\t\t\t\tsap = 0;\n\t\t\t\tgoto add_snl;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We found a socket but its ssap has not been reserved\n\t\t\t * yet. We need to assign it for good and send a reply.\n\t\t\t * The ssap will be freed when the socket is closed.\n\t\t\t */\n\t\t\tif (llcp_sock->ssap == LLCP_SDP_UNBOUND) {\n\t\t\t\tatomic_t *client_count;\n\n\t\t\t\tsap = nfc_llcp_reserve_sdp_ssap(local);\n\n\t\t\t\tpr_debug(\"Reserving %d\\n\", sap);\n\n\t\t\t\tif (sap == LLCP_SAP_MAX) {\n\t\t\t\t\tsap = 0;\n\t\t\t\t\tgoto add_snl;\n\t\t\t\t}\n\n\t\t\t\tclient_count =\n\t\t\t\t\t&local->local_sdp_cnt[sap -\n\t\t\t\t\t\t\t      LLCP_WKS_NUM_SAP];\n\n\t\t\t\tatomic_inc(client_count);\n\n\t\t\t\tllcp_sock->ssap = sap;\n\t\t\t\tllcp_sock->reserved_ssap = sap;\n\t\t\t} else {\n\t\t\t\tsap = llcp_sock->ssap;\n\t\t\t}\n\n\t\t\tpr_debug(\"%p %d\\n\", llcp_sock, sap);\n\nadd_snl:\n\t\t\tsdp = nfc_llcp_build_sdres_tlv(tid, sap);\n\t\t\tif (sdp == NULL)\n\t\t\t\tgoto exit;\n\n\t\t\tsdres_tlvs_len += sdp->tlv_len;\n\t\t\thlist_add_head(&sdp->node, &llc_sdres_list);\n\t\t\tbreak;\n\n\t\tcase LLCP_TLV_SDRES:\n\t\t\tmutex_lock(&local->sdreq_lock);\n\n\t\t\tpr_debug(\"LLCP_TLV_SDRES: searching tid %d\\n\", tlv[2]);\n\n\t\t\thlist_for_each_entry(sdp, &local->pending_sdreqs, node) {\n\t\t\t\tif (sdp->tid != tlv[2])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tsdp->sap = tlv[3];\n\n\t\t\t\tpr_debug(\"Found: uri=%s, sap=%d\\n\",\n\t\t\t\t\t sdp->uri, sdp->sap);\n\n\t\t\t\thlist_del(&sdp->node);\n\n\t\t\t\thlist_add_head(&sdp->node, &nl_sdres_list);\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmutex_unlock(&local->sdreq_lock);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"Invalid SNL tlv value 0x%x\\n\", type);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset += length + 2;\n\t\ttlv += length + 2;\n\t}\n\nexit:\n\tif (!hlist_empty(&nl_sdres_list))\n\t\tnfc_genl_llc_send_sdres(local->dev, &nl_sdres_list);\n\n\tif (!hlist_empty(&llc_sdres_list))\n\t\tnfc_llcp_send_snl_sdres(local, &llc_sdres_list, sdres_tlvs_len);\n}\n\nstatic void nfc_llcp_recv_agf(struct nfc_llcp_local *local, struct sk_buff *skb)\n{\n\tu8 ptype;\n\tu16 pdu_len;\n\tstruct sk_buff *new_skb;\n\n\tif (skb->len <= LLCP_HEADER_SIZE) {\n\t\tpr_err(\"Malformed AGF PDU\\n\");\n\t\treturn;\n\t}\n\n\tskb_pull(skb, LLCP_HEADER_SIZE);\n\n\twhile (skb->len > LLCP_AGF_PDU_HEADER_SIZE) {\n\t\tpdu_len = skb->data[0] << 8 | skb->data[1];\n\n\t\tskb_pull(skb, LLCP_AGF_PDU_HEADER_SIZE);\n\n\t\tif (pdu_len < LLCP_HEADER_SIZE || pdu_len > skb->len) {\n\t\t\tpr_err(\"Malformed AGF PDU\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tptype = nfc_llcp_ptype(skb);\n\n\t\tif (ptype == LLCP_PDU_SYMM || ptype == LLCP_PDU_AGF)\n\t\t\tgoto next;\n\n\t\tnew_skb = nfc_alloc_recv_skb(pdu_len, GFP_KERNEL);\n\t\tif (new_skb == NULL) {\n\t\t\tpr_err(\"Could not allocate PDU\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tskb_put_data(new_skb, skb->data, pdu_len);\n\n\t\tnfc_llcp_rx_skb(local, new_skb);\n\n\t\tkfree_skb(new_skb);\nnext:\n\t\tskb_pull(skb, pdu_len);\n\t}\n}\n\nstatic void nfc_llcp_rx_skb(struct nfc_llcp_local *local, struct sk_buff *skb)\n{\n\tu8 dsap, ssap, ptype;\n\n\tptype = nfc_llcp_ptype(skb);\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tpr_debug(\"ptype 0x%x dsap 0x%x ssap 0x%x\\n\", ptype, dsap, ssap);\n\n\tif (ptype != LLCP_PDU_SYMM)\n\t\tprint_hex_dump_debug(\"LLCP Rx: \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\t     skb->data, skb->len, true);\n\n\tswitch (ptype) {\n\tcase LLCP_PDU_SYMM:\n\t\tpr_debug(\"SYMM\\n\");\n\t\tbreak;\n\n\tcase LLCP_PDU_UI:\n\t\tpr_debug(\"UI\\n\");\n\t\tnfc_llcp_recv_ui(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_CONNECT:\n\t\tpr_debug(\"CONNECT\\n\");\n\t\tnfc_llcp_recv_connect(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_DISC:\n\t\tpr_debug(\"DISC\\n\");\n\t\tnfc_llcp_recv_disc(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_CC:\n\t\tpr_debug(\"CC\\n\");\n\t\tnfc_llcp_recv_cc(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_DM:\n\t\tpr_debug(\"DM\\n\");\n\t\tnfc_llcp_recv_dm(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_SNL:\n\t\tpr_debug(\"SNL\\n\");\n\t\tnfc_llcp_recv_snl(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_I:\n\tcase LLCP_PDU_RR:\n\tcase LLCP_PDU_RNR:\n\t\tpr_debug(\"I frame\\n\");\n\t\tnfc_llcp_recv_hdlc(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_AGF:\n\t\tpr_debug(\"AGF frame\\n\");\n\t\tnfc_llcp_recv_agf(local, skb);\n\t\tbreak;\n\t}\n}\n\nstatic void nfc_llcp_rx_work(struct work_struct *work)\n{\n\tstruct nfc_llcp_local *local = container_of(work, struct nfc_llcp_local,\n\t\t\t\t\t\t    rx_work);\n\tstruct sk_buff *skb;\n\n\tskb = local->rx_pending;\n\tif (skb == NULL) {\n\t\tpr_debug(\"No pending SKB\\n\");\n\t\treturn;\n\t}\n\n\t__net_timestamp(skb);\n\n\tnfc_llcp_send_to_raw_sock(local, skb, NFC_DIRECTION_RX);\n\n\tnfc_llcp_rx_skb(local, skb);\n\n\tschedule_work(&local->tx_work);\n\tkfree_skb(local->rx_pending);\n\tlocal->rx_pending = NULL;\n}\n\nstatic void __nfc_llcp_recv(struct nfc_llcp_local *local, struct sk_buff *skb)\n{\n\tlocal->rx_pending = skb;\n\tdel_timer(&local->link_timer);\n\tschedule_work(&local->rx_work);\n}\n\nvoid nfc_llcp_recv(void *data, struct sk_buff *skb, int err)\n{\n\tstruct nfc_llcp_local *local = (struct nfc_llcp_local *) data;\n\n\tif (err < 0) {\n\t\tpr_err(\"LLCP PDU receive err %d\\n\", err);\n\t\treturn;\n\t}\n\n\t__nfc_llcp_recv(local, skb);\n}\n\nint nfc_llcp_data_received(struct nfc_dev *dev, struct sk_buff *skb)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tkfree_skb(skb);\n\t\treturn -ENODEV;\n\t}\n\n\t__nfc_llcp_recv(local, skb);\n\n\tnfc_llcp_local_put(local);\n\n\treturn 0;\n}\n\nvoid nfc_llcp_mac_is_down(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn;\n\n\tlocal->remote_miu = LLCP_DEFAULT_MIU;\n\tlocal->remote_lto = LLCP_DEFAULT_LTO;\n\n\t/* Close and purge all existing sockets */\n\tnfc_llcp_socket_release(local, true, 0);\n\n\tnfc_llcp_local_put(local);\n}\n\nvoid nfc_llcp_mac_is_up(struct nfc_dev *dev, u32 target_idx,\n\t\t\tu8 comm_mode, u8 rf_mode)\n{\n\tstruct nfc_llcp_local *local;\n\n\tpr_debug(\"rf mode %d\\n\", rf_mode);\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn;\n\n\tlocal->target_idx = target_idx;\n\tlocal->comm_mode = comm_mode;\n\tlocal->rf_mode = rf_mode;\n\n\tif (rf_mode == NFC_RF_INITIATOR) {\n\t\tpr_debug(\"Queueing Tx work\\n\");\n\n\t\tschedule_work(&local->tx_work);\n\t} else {\n\t\tmod_timer(&local->link_timer,\n\t\t\t  jiffies + msecs_to_jiffies(local->remote_lto));\n\t}\n\n\tnfc_llcp_local_put(local);\n}\n\nint nfc_llcp_register_device(struct nfc_dev *ndev)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = kzalloc(sizeof(struct nfc_llcp_local), GFP_KERNEL);\n\tif (local == NULL)\n\t\treturn -ENOMEM;\n\n\tlocal->dev = ndev;\n\tINIT_LIST_HEAD(&local->list);\n\tkref_init(&local->ref);\n\tmutex_init(&local->sdp_lock);\n\ttimer_setup(&local->link_timer, nfc_llcp_symm_timer, 0);\n\n\tskb_queue_head_init(&local->tx_queue);\n\tINIT_WORK(&local->tx_work, nfc_llcp_tx_work);\n\n\tlocal->rx_pending = NULL;\n\tINIT_WORK(&local->rx_work, nfc_llcp_rx_work);\n\n\tINIT_WORK(&local->timeout_work, nfc_llcp_timeout_work);\n\n\trwlock_init(&local->sockets.lock);\n\trwlock_init(&local->connecting_sockets.lock);\n\trwlock_init(&local->raw_sockets.lock);\n\n\tlocal->lto = 150; /* 1500 ms */\n\tlocal->rw = LLCP_MAX_RW;\n\tlocal->miux = cpu_to_be16(LLCP_MAX_MIUX);\n\tlocal->local_wks = 0x1; /* LLC Link Management */\n\n\tnfc_llcp_build_gb(local);\n\n\tlocal->remote_miu = LLCP_DEFAULT_MIU;\n\tlocal->remote_lto = LLCP_DEFAULT_LTO;\n\n\tmutex_init(&local->sdreq_lock);\n\tINIT_HLIST_HEAD(&local->pending_sdreqs);\n\ttimer_setup(&local->sdreq_timer, nfc_llcp_sdreq_timer, 0);\n\tINIT_WORK(&local->sdreq_timeout_work, nfc_llcp_sdreq_timeout_work);\n\n\tlist_add(&local->list, &llcp_devices);\n\n\treturn 0;\n}\n\nvoid nfc_llcp_unregister_device(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local = nfc_llcp_remove_local(dev);\n\n\tif (local == NULL) {\n\t\tpr_debug(\"No such device\\n\");\n\t\treturn;\n\t}\n\n\tlocal_cleanup(local);\n\n\tnfc_llcp_local_put(local);\n}\n\nint __init nfc_llcp_init(void)\n{\n\treturn nfc_llcp_sock_init();\n}\n\nvoid nfc_llcp_exit(void)\n{\n\tnfc_llcp_sock_exit();\n}\n", "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Copyright (C) 2011  Intel Corporation. All rights reserved.\n */\n\n#define pr_fmt(fmt) \"llcp: %s: \" fmt, __func__\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/nfc.h>\n#include <linux/sched/signal.h>\n\n#include \"nfc.h\"\n#include \"llcp.h\"\n\nstatic int sock_wait_state(struct sock *sk, int state, unsigned long timeo)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tint err = 0;\n\n\tpr_debug(\"sk %p\", sk);\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\n\twhile (sk->sk_state != state) {\n\t\tif (!timeo) {\n\t\t\terr = -EINPROGRESS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\t\ttimeo = schedule_timeout(timeo);\n\t\tlock_sock(sk);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\terr = sock_error(sk);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn err;\n}\n\nstatic struct proto llcp_sock_proto = {\n\t.name     = \"NFC_LLCP\",\n\t.owner    = THIS_MODULE,\n\t.obj_size = sizeof(struct nfc_llcp_sock),\n};\n\nstatic int llcp_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_dev *dev;\n\tstruct sockaddr_nfc_llcp llcp_addr;\n\tint len, ret = 0;\n\n\tif (!addr || alen < offsetofend(struct sockaddr, sa_family) ||\n\t    addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"sk %p addr %p family %d\\n\", sk, addr, addr->sa_family);\n\n\tmemset(&llcp_addr, 0, sizeof(llcp_addr));\n\tlen = min_t(unsigned int, sizeof(llcp_addr), alen);\n\tmemcpy(&llcp_addr, addr, len);\n\n\t/* This is going to be a listening socket, dsap must be 0 */\n\tif (llcp_addr.dsap != 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != LLCP_CLOSED) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\n\tdev = nfc_get_device(llcp_addr.dev_idx);\n\tif (dev == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = local;\n\tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n\tllcp_sock->service_name_len = min_t(unsigned int,\n\t\t\t\t\t    llcp_addr.service_name_len,\n\t\t\t\t\t    NFC_LLCP_MAX_SERVICE_NAME);\n\tllcp_sock->service_name = kmemdup(llcp_addr.service_name,\n\t\t\t\t\t  llcp_sock->service_name_len,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!llcp_sock->service_name) {\n\t\tret = -ENOMEM;\n\t\tgoto sock_llcp_put_local;\n\t}\n\tllcp_sock->ssap = nfc_llcp_get_sdp_ssap(local, llcp_sock);\n\tif (llcp_sock->ssap == LLCP_SAP_MAX) {\n\t\tret = -EADDRINUSE;\n\t\tgoto free_service_name;\n\t}\n\n\tllcp_sock->reserved_ssap = llcp_sock->ssap;\n\n\tnfc_llcp_sock_link(&local->sockets, sk);\n\n\tpr_debug(\"Socket bound to SAP %d\\n\", llcp_sock->ssap);\n\n\tsk->sk_state = LLCP_BOUND;\n\tnfc_put_device(dev);\n\trelease_sock(sk);\n\n\treturn 0;\n\nfree_service_name:\n\tkfree(llcp_sock->service_name);\n\tllcp_sock->service_name = NULL;\n\nsock_llcp_put_local:\n\tnfc_llcp_local_put(llcp_sock->local);\n\tllcp_sock->local = NULL;\n\tllcp_sock->dev = NULL;\n\nput_dev:\n\tnfc_put_device(dev);\n\nerror:\n\trelease_sock(sk);\n\treturn ret;\n}\n\nstatic int llcp_raw_sock_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\t      int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_dev *dev;\n\tstruct sockaddr_nfc_llcp llcp_addr;\n\tint len, ret = 0;\n\n\tif (!addr || alen < offsetofend(struct sockaddr, sa_family) ||\n\t    addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"sk %p addr %p family %d\\n\", sk, addr, addr->sa_family);\n\n\tmemset(&llcp_addr, 0, sizeof(llcp_addr));\n\tlen = min_t(unsigned int, sizeof(llcp_addr), alen);\n\tmemcpy(&llcp_addr, addr, len);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != LLCP_CLOSED) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\n\tdev = nfc_get_device(llcp_addr.dev_idx);\n\tif (dev == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = local;\n\tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n\n\tnfc_llcp_sock_link(&local->raw_sockets, sk);\n\n\tsk->sk_state = LLCP_BOUND;\n\nput_dev:\n\tnfc_put_device(dev);\n\nerror:\n\trelease_sock(sk);\n\treturn ret;\n}\n\nstatic int llcp_sock_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint ret = 0;\n\n\tpr_debug(\"sk %p backlog %d\\n\", sk, backlog);\n\n\tlock_sock(sk);\n\n\tif ((sock->type != SOCK_SEQPACKET && sock->type != SOCK_STREAM) ||\n\t    sk->sk_state != LLCP_BOUND) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\n\tsk->sk_max_ack_backlog = backlog;\n\tsk->sk_ack_backlog = 0;\n\n\tpr_debug(\"Socket listening\\n\");\n\tsk->sk_state = LLCP_LISTEN;\n\nerror:\n\trelease_sock(sk);\n\n\treturn ret;\n}\n\nstatic int nfc_llcp_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t       sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tu32 opt;\n\tint err = 0;\n\n\tpr_debug(\"%p optname %d\\n\", sk, optname);\n\n\tif (level != SOL_NFC)\n\t\treturn -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase NFC_LLCP_RW:\n\t\tif (sk->sk_state == LLCP_CONNECTED ||\n\t\t    sk->sk_state == LLCP_BOUND ||\n\t\t    sk->sk_state == LLCP_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt > LLCP_MAX_RW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tllcp_sock->rw = (u8) opt;\n\n\t\tbreak;\n\n\tcase NFC_LLCP_MIUX:\n\t\tif (sk->sk_state == LLCP_CONNECTED ||\n\t\t    sk->sk_state == LLCP_BOUND ||\n\t\t    sk->sk_state == LLCP_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt > LLCP_MAX_MIUX) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tllcp_sock->miux = cpu_to_be16((u16) opt);\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\n\tpr_debug(\"%p rw %d miux %d\\n\", llcp_sock,\n\t\t llcp_sock->rw, llcp_sock->miux);\n\n\treturn err;\n}\n\nstatic int nfc_llcp_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tint len, err = 0;\n\tu16 miux, remote_miu;\n\tu8 rw;\n\n\tpr_debug(\"%p optname %d\\n\", sk, optname);\n\n\tif (level != SOL_NFC)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlocal = llcp_sock->local;\n\tif (!local)\n\t\treturn -ENODEV;\n\n\tlen = min_t(u32, len, sizeof(u32));\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase NFC_LLCP_RW:\n\t\trw = llcp_sock->rw > LLCP_MAX_RW ? local->rw : llcp_sock->rw;\n\t\tif (put_user(rw, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase NFC_LLCP_MIUX:\n\t\tmiux = be16_to_cpu(llcp_sock->miux) > LLCP_MAX_MIUX ?\n\t\t\tbe16_to_cpu(local->miux) : be16_to_cpu(llcp_sock->miux);\n\n\t\tif (put_user(miux, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase NFC_LLCP_REMOTE_MIU:\n\t\tremote_miu = llcp_sock->remote_miu > LLCP_MAX_MIU ?\n\t\t\t\tlocal->remote_miu : llcp_sock->remote_miu;\n\n\t\tif (put_user(remote_miu, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase NFC_LLCP_REMOTE_LTO:\n\t\tif (put_user(local->remote_lto / 10, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase NFC_LLCP_REMOTE_RW:\n\t\tif (put_user(llcp_sock->remote_rw, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\treturn err;\n}\n\nvoid nfc_llcp_accept_unlink(struct sock *sk)\n{\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\n\tpr_debug(\"state %d\\n\", sk->sk_state);\n\n\tlist_del_init(&llcp_sock->accept_queue);\n\tsk_acceptq_removed(llcp_sock->parent);\n\tllcp_sock->parent = NULL;\n\n\tsock_put(sk);\n}\n\nvoid nfc_llcp_accept_enqueue(struct sock *parent, struct sock *sk)\n{\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct nfc_llcp_sock *llcp_sock_parent = nfc_llcp_sock(parent);\n\n\t/* Lock will be free from unlink */\n\tsock_hold(sk);\n\n\tlist_add_tail(&llcp_sock->accept_queue,\n\t\t      &llcp_sock_parent->accept_queue);\n\tllcp_sock->parent = parent;\n\tsk_acceptq_added(parent);\n}\n\nstruct sock *nfc_llcp_accept_dequeue(struct sock *parent,\n\t\t\t\t     struct socket *newsock)\n{\n\tstruct nfc_llcp_sock *lsk, *n, *llcp_parent;\n\tstruct sock *sk;\n\n\tllcp_parent = nfc_llcp_sock(parent);\n\n\tlist_for_each_entry_safe(lsk, n, &llcp_parent->accept_queue,\n\t\t\t\t accept_queue) {\n\t\tsk = &lsk->sk;\n\t\tlock_sock(sk);\n\n\t\tif (sk->sk_state == LLCP_CLOSED) {\n\t\t\trelease_sock(sk);\n\t\t\tnfc_llcp_accept_unlink(sk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sk->sk_state == LLCP_CONNECTED || !newsock) {\n\t\t\tlist_del_init(&lsk->accept_queue);\n\t\t\tsock_put(sk);\n\n\t\t\tif (newsock)\n\t\t\t\tsock_graft(sk, newsock);\n\n\t\t\trelease_sock(sk);\n\n\t\t\tpr_debug(\"Returning sk state %d\\n\", sk->sk_state);\n\n\t\t\tsk_acceptq_removed(parent);\n\n\t\t\treturn sk;\n\t\t}\n\n\t\trelease_sock(sk);\n\t}\n\n\treturn NULL;\n}\n\nstatic int llcp_sock_accept(struct socket *sock, struct socket *newsock,\n\t\t\t    int flags, bool kern)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct sock *sk = sock->sk, *new_sk;\n\tlong timeo;\n\tint ret = 0;\n\n\tpr_debug(\"parent %p\\n\", sk);\n\n\tlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\n\n\tif (sk->sk_state != LLCP_LISTEN) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\n\ttimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\n\n\t/* Wait for an incoming connection. */\n\tadd_wait_queue_exclusive(sk_sleep(sk), &wait);\n\twhile (!(new_sk = nfc_llcp_accept_dequeue(sk, newsock))) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tif (!timeo) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\t\ttimeo = schedule_timeout(timeo);\n\t\tlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\tif (ret)\n\t\tgoto error;\n\n\tnewsock->state = SS_CONNECTED;\n\n\tpr_debug(\"new socket %p\\n\", new_sk);\n\nerror:\n\trelease_sock(sk);\n\n\treturn ret;\n}\n\nstatic int llcp_sock_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t     int peer)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_nfc_llcp *, llcp_addr, uaddr);\n\n\tif (llcp_sock == NULL || llcp_sock->dev == NULL)\n\t\treturn -EBADFD;\n\n\tpr_debug(\"%p %d %d %d\\n\", sk, llcp_sock->target_idx,\n\t\t llcp_sock->dsap, llcp_sock->ssap);\n\n\tmemset(llcp_addr, 0, sizeof(*llcp_addr));\n\n\tlock_sock(sk);\n\tif (!llcp_sock->dev) {\n\t\trelease_sock(sk);\n\t\treturn -EBADFD;\n\t}\n\tllcp_addr->sa_family = AF_NFC;\n\tllcp_addr->dev_idx = llcp_sock->dev->idx;\n\tllcp_addr->target_idx = llcp_sock->target_idx;\n\tllcp_addr->nfc_protocol = llcp_sock->nfc_protocol;\n\tllcp_addr->dsap = llcp_sock->dsap;\n\tllcp_addr->ssap = llcp_sock->ssap;\n\tllcp_addr->service_name_len = llcp_sock->service_name_len;\n\tmemcpy(llcp_addr->service_name, llcp_sock->service_name,\n\t       llcp_addr->service_name_len);\n\trelease_sock(sk);\n\n\treturn sizeof(struct sockaddr_nfc_llcp);\n}\n\nstatic inline __poll_t llcp_accept_poll(struct sock *parent)\n{\n\tstruct nfc_llcp_sock *llcp_sock, *parent_sock;\n\tstruct sock *sk;\n\n\tparent_sock = nfc_llcp_sock(parent);\n\n\tlist_for_each_entry(llcp_sock, &parent_sock->accept_queue,\n\t\t\t    accept_queue) {\n\t\tsk = &llcp_sock->sk;\n\n\t\tif (sk->sk_state == LLCP_CONNECTED)\n\t\t\treturn EPOLLIN | EPOLLRDNORM;\n\t}\n\n\treturn 0;\n}\n\nstatic __poll_t llcp_sock_poll(struct file *file, struct socket *sock,\n\t\t\t\t   poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\t__poll_t mask = 0;\n\n\tpr_debug(\"%p\\n\", sk);\n\n\tsock_poll_wait(file, sock, wait);\n\n\tif (sk->sk_state == LLCP_LISTEN)\n\t\treturn llcp_accept_poll(sk);\n\n\tif (sk->sk_err || !skb_queue_empty_lockless(&sk->sk_error_queue))\n\t\tmask |= EPOLLERR |\n\t\t\t(sock_flag(sk, SOCK_SELECT_ERR_QUEUE) ? EPOLLPRI : 0);\n\n\tif (!skb_queue_empty_lockless(&sk->sk_receive_queue))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\tif (sk->sk_state == LLCP_CLOSED)\n\t\tmask |= EPOLLHUP;\n\n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\tmask |= EPOLLRDHUP | EPOLLIN | EPOLLRDNORM;\n\n\tif (sk->sk_shutdown == SHUTDOWN_MASK)\n\t\tmask |= EPOLLHUP;\n\n\tif (sock_writeable(sk) && sk->sk_state == LLCP_CONNECTED)\n\t\tmask |= EPOLLOUT | EPOLLWRNORM | EPOLLWRBAND;\n\telse\n\t\tsk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\n\tpr_debug(\"mask 0x%x\\n\", mask);\n\n\treturn mask;\n}\n\nstatic int llcp_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tint err = 0;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tpr_debug(\"%p\\n\", sk);\n\n\tlocal = llcp_sock->local;\n\tif (local == NULL) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tlock_sock(sk);\n\n\t/* Send a DISC */\n\tif (sk->sk_state == LLCP_CONNECTED)\n\t\tnfc_llcp_send_disconnect(llcp_sock);\n\n\tif (sk->sk_state == LLCP_LISTEN) {\n\t\tstruct nfc_llcp_sock *lsk, *n;\n\t\tstruct sock *accept_sk;\n\n\t\tlist_for_each_entry_safe(lsk, n, &llcp_sock->accept_queue,\n\t\t\t\t\t accept_queue) {\n\t\t\taccept_sk = &lsk->sk;\n\t\t\tlock_sock(accept_sk);\n\n\t\t\tnfc_llcp_send_disconnect(lsk);\n\t\t\tnfc_llcp_accept_unlink(accept_sk);\n\n\t\t\trelease_sock(accept_sk);\n\t\t}\n\t}\n\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_llcp_sock_unlink(&local->raw_sockets, sk);\n\telse\n\t\tnfc_llcp_sock_unlink(&local->sockets, sk);\n\n\tif (llcp_sock->reserved_ssap < LLCP_SAP_MAX)\n\t\tnfc_llcp_put_ssap(llcp_sock->local, llcp_sock->ssap);\n\n\trelease_sock(sk);\n\nout:\n\tsock_orphan(sk);\n\tsock_put(sk);\n\n\treturn err;\n}\n\nstatic int llcp_sock_connect(struct socket *sock, struct sockaddr *_addr,\n\t\t\t     int len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct sockaddr_nfc_llcp *addr = (struct sockaddr_nfc_llcp *)_addr;\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tint ret = 0;\n\n\tpr_debug(\"sock %p sk %p flags 0x%x\\n\", sock, sk, flags);\n\n\tif (!addr || len < sizeof(*addr) || addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\n\tif (addr->service_name_len == 0 && addr->dsap == 0)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"addr dev_idx=%u target_idx=%u protocol=%u\\n\", addr->dev_idx,\n\t\t addr->target_idx, addr->nfc_protocol);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == LLCP_CONNECTED) {\n\t\tret = -EISCONN;\n\t\tgoto error;\n\t}\n\tif (sk->sk_state == LLCP_CONNECTING) {\n\t\tret = -EINPROGRESS;\n\t\tgoto error;\n\t}\n\n\tdev = nfc_get_device(addr->dev_idx);\n\tif (dev == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\n\tdevice_lock(&dev->dev);\n\tif (dev->dep_link_up == false) {\n\t\tret = -ENOLINK;\n\t\tdevice_unlock(&dev->dev);\n\t\tgoto sock_llcp_put_local;\n\t}\n\tdevice_unlock(&dev->dev);\n\n\tif (local->rf_mode == NFC_RF_INITIATOR &&\n\t    addr->target_idx != local->target_idx) {\n\t\tret = -ENOLINK;\n\t\tgoto sock_llcp_put_local;\n\t}\n\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = local;\n\tllcp_sock->ssap = nfc_llcp_get_local_ssap(local);\n\tif (llcp_sock->ssap == LLCP_SAP_MAX) {\n\t\tret = -ENOMEM;\n\t\tgoto sock_llcp_nullify;\n\t}\n\n\tllcp_sock->reserved_ssap = llcp_sock->ssap;\n\n\tif (addr->service_name_len == 0)\n\t\tllcp_sock->dsap = addr->dsap;\n\telse\n\t\tllcp_sock->dsap = LLCP_SAP_SDP;\n\tllcp_sock->nfc_protocol = addr->nfc_protocol;\n\tllcp_sock->service_name_len = min_t(unsigned int,\n\t\t\t\t\t    addr->service_name_len,\n\t\t\t\t\t    NFC_LLCP_MAX_SERVICE_NAME);\n\tllcp_sock->service_name = kmemdup(addr->service_name,\n\t\t\t\t\t  llcp_sock->service_name_len,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!llcp_sock->service_name) {\n\t\tret = -ENOMEM;\n\t\tgoto sock_llcp_release;\n\t}\n\n\tnfc_llcp_sock_link(&local->connecting_sockets, sk);\n\n\tret = nfc_llcp_send_connect(llcp_sock);\n\tif (ret)\n\t\tgoto sock_unlink;\n\n\tsk->sk_state = LLCP_CONNECTING;\n\n\tret = sock_wait_state(sk, LLCP_CONNECTED,\n\t\t\t      sock_sndtimeo(sk, flags & O_NONBLOCK));\n\tif (ret && ret != -EINPROGRESS)\n\t\tgoto sock_unlink;\n\n\trelease_sock(sk);\n\n\treturn ret;\n\nsock_unlink:\n\tnfc_llcp_sock_unlink(&local->connecting_sockets, sk);\n\tkfree(llcp_sock->service_name);\n\tllcp_sock->service_name = NULL;\n\nsock_llcp_release:\n\tnfc_llcp_put_ssap(local, llcp_sock->ssap);\n\nsock_llcp_nullify:\n\tllcp_sock->local = NULL;\n\tllcp_sock->dev = NULL;\n\nsock_llcp_put_local:\n\tnfc_llcp_local_put(local);\n\nput_dev:\n\tnfc_put_device(dev);\n\nerror:\n\trelease_sock(sk);\n\treturn ret;\n}\n\nstatic int llcp_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t     size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tint ret;\n\n\tpr_debug(\"sock %p sk %p\", sock, sk);\n\n\tret = sock_error(sk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tlock_sock(sk);\n\n\tif (!llcp_sock->local) {\n\t\trelease_sock(sk);\n\t\treturn -ENODEV;\n\t}\n\n\tif (sk->sk_type == SOCK_DGRAM) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_nfc_llcp *, addr,\n\t\t\t\t msg->msg_name);\n\n\t\tif (msg->msg_namelen < sizeof(*addr)) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trelease_sock(sk);\n\n\t\treturn nfc_llcp_send_ui_frame(llcp_sock, addr->dsap, addr->ssap,\n\t\t\t\t\t      msg, len);\n\t}\n\n\tif (sk->sk_state != LLCP_CONNECTED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\n\trelease_sock(sk);\n\n\treturn nfc_llcp_send_i_frame(llcp_sock, msg, len);\n}\n\nstatic int llcp_sock_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t     size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tunsigned int copied, rlen;\n\tstruct sk_buff *skb, *cskb;\n\tint err = 0;\n\n\tpr_debug(\"%p %zu\\n\", sk, len);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == LLCP_CLOSED &&\n\t    skb_queue_empty(&sk->sk_receive_queue)) {\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\n\trelease_sock(sk);\n\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb) {\n\t\tpr_err(\"Recv datagram failed state %d %d %d\",\n\t\t       sk->sk_state, err, sock_error(sk));\n\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\n\t\treturn err;\n\t}\n\n\trlen = skb->len;\t\t/* real length of skb */\n\tcopied = min_t(unsigned int, rlen, len);\n\n\tcskb = skb;\n\tif (skb_copy_datagram_msg(cskb, 0, msg, copied)) {\n\t\tif (!(flags & MSG_PEEK))\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\treturn -EFAULT;\n\t}\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\tif (sk->sk_type == SOCK_DGRAM && msg->msg_name) {\n\t\tstruct nfc_llcp_ui_cb *ui_cb = nfc_llcp_ui_skb_cb(skb);\n\t\tDECLARE_SOCKADDR(struct sockaddr_nfc_llcp *, sockaddr,\n\t\t\t\t msg->msg_name);\n\n\t\tmsg->msg_namelen = sizeof(struct sockaddr_nfc_llcp);\n\n\t\tpr_debug(\"Datagram socket %d %d\\n\", ui_cb->dsap, ui_cb->ssap);\n\n\t\tmemset(sockaddr, 0, sizeof(*sockaddr));\n\t\tsockaddr->sa_family = AF_NFC;\n\t\tsockaddr->nfc_protocol = NFC_PROTO_NFC_DEP;\n\t\tsockaddr->dsap = ui_cb->dsap;\n\t\tsockaddr->ssap = ui_cb->ssap;\n\t}\n\n\t/* Mark read part of skb as used */\n\tif (!(flags & MSG_PEEK)) {\n\n\t\t/* SOCK_STREAM: re-queue skb if it contains unreceived data */\n\t\tif (sk->sk_type == SOCK_STREAM ||\n\t\t    sk->sk_type == SOCK_DGRAM ||\n\t\t    sk->sk_type == SOCK_RAW) {\n\t\t\tskb_pull(skb, copied);\n\t\t\tif (skb->len) {\n\t\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\tkfree_skb(skb);\n\t}\n\n\t/* XXX Queue backlogged skbs */\n\ndone:\n\t/* SOCK_SEQPACKET: return real length if MSG_TRUNC is set */\n\tif (sk->sk_type == SOCK_SEQPACKET && (flags & MSG_TRUNC))\n\t\tcopied = rlen;\n\n\treturn copied;\n}\n\nstatic const struct proto_ops llcp_sock_ops = {\n\t.family         = PF_NFC,\n\t.owner          = THIS_MODULE,\n\t.bind           = llcp_sock_bind,\n\t.connect        = llcp_sock_connect,\n\t.release        = llcp_sock_release,\n\t.socketpair     = sock_no_socketpair,\n\t.accept         = llcp_sock_accept,\n\t.getname        = llcp_sock_getname,\n\t.poll           = llcp_sock_poll,\n\t.ioctl          = sock_no_ioctl,\n\t.listen         = llcp_sock_listen,\n\t.shutdown       = sock_no_shutdown,\n\t.setsockopt     = nfc_llcp_setsockopt,\n\t.getsockopt     = nfc_llcp_getsockopt,\n\t.sendmsg        = llcp_sock_sendmsg,\n\t.recvmsg        = llcp_sock_recvmsg,\n\t.mmap           = sock_no_mmap,\n};\n\nstatic const struct proto_ops llcp_rawsock_ops = {\n\t.family         = PF_NFC,\n\t.owner          = THIS_MODULE,\n\t.bind           = llcp_raw_sock_bind,\n\t.connect        = sock_no_connect,\n\t.release        = llcp_sock_release,\n\t.socketpair     = sock_no_socketpair,\n\t.accept         = sock_no_accept,\n\t.getname        = llcp_sock_getname,\n\t.poll           = llcp_sock_poll,\n\t.ioctl          = sock_no_ioctl,\n\t.listen         = sock_no_listen,\n\t.shutdown       = sock_no_shutdown,\n\t.sendmsg        = sock_no_sendmsg,\n\t.recvmsg        = llcp_sock_recvmsg,\n\t.mmap           = sock_no_mmap,\n};\n\nstatic void llcp_sock_destruct(struct sock *sk)\n{\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\n\tpr_debug(\"%p\\n\", sk);\n\n\tif (sk->sk_state == LLCP_CONNECTED)\n\t\tnfc_put_device(llcp_sock->dev);\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\n\tnfc_llcp_sock_free(llcp_sock);\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Freeing alive NFC LLCP socket %p\\n\", sk);\n\t\treturn;\n\t}\n}\n\nstruct sock *nfc_llcp_sock_alloc(struct socket *sock, int type, gfp_t gfp, int kern)\n{\n\tstruct sock *sk;\n\tstruct nfc_llcp_sock *llcp_sock;\n\n\tsk = sk_alloc(&init_net, PF_NFC, gfp, &llcp_sock_proto, kern);\n\tif (!sk)\n\t\treturn NULL;\n\n\tllcp_sock = nfc_llcp_sock(sk);\n\n\tsock_init_data(sock, sk);\n\tsk->sk_state = LLCP_CLOSED;\n\tsk->sk_protocol = NFC_SOCKPROTO_LLCP;\n\tsk->sk_type = type;\n\tsk->sk_destruct = llcp_sock_destruct;\n\n\tllcp_sock->ssap = 0;\n\tllcp_sock->dsap = LLCP_SAP_SDP;\n\tllcp_sock->rw = LLCP_MAX_RW + 1;\n\tllcp_sock->miux = cpu_to_be16(LLCP_MAX_MIUX + 1);\n\tllcp_sock->send_n = llcp_sock->send_ack_n = 0;\n\tllcp_sock->recv_n = llcp_sock->recv_ack_n = 0;\n\tllcp_sock->remote_ready = 1;\n\tllcp_sock->reserved_ssap = LLCP_SAP_MAX;\n\tnfc_llcp_socket_remote_param_init(llcp_sock);\n\tskb_queue_head_init(&llcp_sock->tx_queue);\n\tskb_queue_head_init(&llcp_sock->tx_pending_queue);\n\tINIT_LIST_HEAD(&llcp_sock->accept_queue);\n\n\tif (sock != NULL)\n\t\tsock->state = SS_UNCONNECTED;\n\n\treturn sk;\n}\n\nvoid nfc_llcp_sock_free(struct nfc_llcp_sock *sock)\n{\n\tkfree(sock->service_name);\n\n\tskb_queue_purge(&sock->tx_queue);\n\tskb_queue_purge(&sock->tx_pending_queue);\n\n\tlist_del_init(&sock->accept_queue);\n\n\tsock->parent = NULL;\n\n\tnfc_llcp_local_put(sock->local);\n}\n\nstatic int llcp_sock_create(struct net *net, struct socket *sock,\n\t\t\t    const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\n\tpr_debug(\"%p\\n\", sock);\n\n\tif (sock->type != SOCK_STREAM &&\n\t    sock->type != SOCK_DGRAM &&\n\t    sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW) {\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\treturn -EPERM;\n\t\tsock->ops = &llcp_rawsock_ops;\n\t} else {\n\t\tsock->ops = &llcp_sock_ops;\n\t}\n\n\tsk = nfc_llcp_sock_alloc(sock, sock->type, GFP_ATOMIC, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic const struct nfc_protocol llcp_nfc_proto = {\n\t.id\t  = NFC_SOCKPROTO_LLCP,\n\t.proto    = &llcp_sock_proto,\n\t.owner    = THIS_MODULE,\n\t.create   = llcp_sock_create\n};\n\nint __init nfc_llcp_sock_init(void)\n{\n\treturn nfc_proto_register(&llcp_nfc_proto);\n}\n\nvoid nfc_llcp_sock_exit(void)\n{\n\tnfc_proto_unregister(&llcp_nfc_proto);\n}\n", "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Copyright (C) 2011 Instituto Nokia de Tecnologia\n *\n * Authors:\n *    Lauro Ramos Venancio <lauro.venancio@openbossa.org>\n *    Aloisio Almeida Jr <aloisio.almeida@openbossa.org>\n *\n * Vendor commands implementation based on net/wireless/nl80211.c\n * which is:\n *\n * Copyright 2006-2010\tJohannes Berg <johannes@sipsolutions.net>\n * Copyright 2013-2014  Intel Mobile Communications GmbH\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": %s: \" fmt, __func__\n\n#include <net/genetlink.h>\n#include <linux/nfc.h>\n#include <linux/slab.h>\n\n#include \"nfc.h\"\n#include \"llcp.h\"\n\nstatic const struct genl_multicast_group nfc_genl_mcgrps[] = {\n\t{ .name = NFC_GENL_MCAST_EVENT_NAME, },\n};\n\nstatic struct genl_family nfc_genl_family;\nstatic const struct nla_policy nfc_genl_policy[NFC_ATTR_MAX + 1] = {\n\t[NFC_ATTR_DEVICE_INDEX] = { .type = NLA_U32 },\n\t[NFC_ATTR_DEVICE_NAME] = { .type = NLA_STRING,\n\t\t\t\t.len = NFC_DEVICE_NAME_MAXSIZE },\n\t[NFC_ATTR_PROTOCOLS] = { .type = NLA_U32 },\n\t[NFC_ATTR_TARGET_INDEX] = { .type = NLA_U32 },\n\t[NFC_ATTR_COMM_MODE] = { .type = NLA_U8 },\n\t[NFC_ATTR_RF_MODE] = { .type = NLA_U8 },\n\t[NFC_ATTR_DEVICE_POWERED] = { .type = NLA_U8 },\n\t[NFC_ATTR_IM_PROTOCOLS] = { .type = NLA_U32 },\n\t[NFC_ATTR_TM_PROTOCOLS] = { .type = NLA_U32 },\n\t[NFC_ATTR_LLC_PARAM_LTO] = { .type = NLA_U8 },\n\t[NFC_ATTR_LLC_PARAM_RW] = { .type = NLA_U8 },\n\t[NFC_ATTR_LLC_PARAM_MIUX] = { .type = NLA_U16 },\n\t[NFC_ATTR_LLC_SDP] = { .type = NLA_NESTED },\n\t[NFC_ATTR_FIRMWARE_NAME] = { .type = NLA_STRING,\n\t\t\t\t     .len = NFC_FIRMWARE_NAME_MAXSIZE },\n\t[NFC_ATTR_SE_INDEX] = { .type = NLA_U32 },\n\t[NFC_ATTR_SE_APDU] = { .type = NLA_BINARY },\n\t[NFC_ATTR_VENDOR_ID] = { .type = NLA_U32 },\n\t[NFC_ATTR_VENDOR_SUBCMD] = { .type = NLA_U32 },\n\t[NFC_ATTR_VENDOR_DATA] = { .type = NLA_BINARY },\n\n};\n\nstatic const struct nla_policy nfc_sdp_genl_policy[NFC_SDP_ATTR_MAX + 1] = {\n\t[NFC_SDP_ATTR_URI] = { .type = NLA_STRING,\n\t\t\t       .len = U8_MAX - 4 },\n\t[NFC_SDP_ATTR_SAP] = { .type = NLA_U8 },\n};\n\nstatic int nfc_genl_send_target(struct sk_buff *msg, struct nfc_target *target,\n\t\t\t\tstruct netlink_callback *cb, int flags)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(msg, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\t  &nfc_genl_family, flags, NFC_CMD_GET_TARGET);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (nla_put_u32(msg, NFC_ATTR_TARGET_INDEX, target->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_PROTOCOLS, target->supported_protocols) ||\n\t    nla_put_u16(msg, NFC_ATTR_TARGET_SENS_RES, target->sens_res) ||\n\t    nla_put_u8(msg, NFC_ATTR_TARGET_SEL_RES, target->sel_res))\n\t\tgoto nla_put_failure;\n\tif (target->nfcid1_len > 0 &&\n\t    nla_put(msg, NFC_ATTR_TARGET_NFCID1, target->nfcid1_len,\n\t\t    target->nfcid1))\n\t\tgoto nla_put_failure;\n\tif (target->sensb_res_len > 0 &&\n\t    nla_put(msg, NFC_ATTR_TARGET_SENSB_RES, target->sensb_res_len,\n\t\t    target->sensb_res))\n\t\tgoto nla_put_failure;\n\tif (target->sensf_res_len > 0 &&\n\t    nla_put(msg, NFC_ATTR_TARGET_SENSF_RES, target->sensf_res_len,\n\t\t    target->sensf_res))\n\t\tgoto nla_put_failure;\n\n\tif (target->is_iso15693) {\n\t\tif (nla_put_u8(msg, NFC_ATTR_TARGET_ISO15693_DSFID,\n\t\t\t       target->iso15693_dsfid) ||\n\t\t    nla_put(msg, NFC_ATTR_TARGET_ISO15693_UID,\n\t\t\t    sizeof(target->iso15693_uid), target->iso15693_uid))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic struct nfc_dev *__get_device_from_cb(struct netlink_callback *cb)\n{\n\tconst struct genl_dumpit_info *info = genl_dumpit_info(cb);\n\tstruct nfc_dev *dev;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn dev;\n}\n\nstatic int nfc_genl_dump_targets(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tint i = cb->args[0];\n\tstruct nfc_dev *dev = (struct nfc_dev *) cb->args[1];\n\tint rc;\n\n\tif (!dev) {\n\t\tdev = __get_device_from_cb(cb);\n\t\tif (IS_ERR(dev))\n\t\t\treturn PTR_ERR(dev);\n\n\t\tcb->args[1] = (long) dev;\n\t}\n\n\tdevice_lock(&dev->dev);\n\n\tcb->seq = dev->targets_generation;\n\n\twhile (i < dev->n_targets) {\n\t\trc = nfc_genl_send_target(skb, &dev->targets[i], cb,\n\t\t\t\t\t  NLM_F_MULTI);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\ti++;\n\t}\n\n\tdevice_unlock(&dev->dev);\n\n\tcb->args[0] = i;\n\n\treturn skb->len;\n}\n\nstatic int nfc_genl_dump_targets_done(struct netlink_callback *cb)\n{\n\tstruct nfc_dev *dev = (struct nfc_dev *) cb->args[1];\n\n\tif (dev)\n\t\tnfc_put_device(dev);\n\n\treturn 0;\n}\n\nint nfc_genl_targets_found(struct nfc_dev *dev)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tdev->genl_data.poll_req_portid = 0;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_TARGETS_FOUND);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_target_lost(struct nfc_dev *dev, u32 target_idx)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_TARGET_LOST);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_string(msg, NFC_ATTR_DEVICE_NAME, nfc_device_name(dev)) ||\n\t    nla_put_u32(msg, NFC_ATTR_TARGET_INDEX, target_idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_tm_activated(struct nfc_dev *dev, u32 protocol)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_TM_ACTIVATED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(msg, NFC_ATTR_TM_PROTOCOLS, protocol))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_tm_deactivated(struct nfc_dev *dev)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_TM_DEACTIVATED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_setup_device_added(struct nfc_dev *dev, struct sk_buff *msg)\n{\n\tif (nla_put_string(msg, NFC_ATTR_DEVICE_NAME, nfc_device_name(dev)) ||\n\t    nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_PROTOCOLS, dev->supported_protocols) ||\n\t    nla_put_u8(msg, NFC_ATTR_DEVICE_POWERED, dev->dev_up) ||\n\t    nla_put_u8(msg, NFC_ATTR_RF_MODE, dev->rf_mode))\n\t\treturn -1;\n\treturn 0;\n}\n\nint nfc_genl_device_added(struct nfc_dev *dev)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_DEVICE_ADDED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nfc_genl_setup_device_added(dev, msg))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_device_removed(struct nfc_dev *dev)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_DEVICE_REMOVED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_llc_send_sdres(struct nfc_dev *dev, struct hlist_head *sdres_list)\n{\n\tstruct sk_buff *msg;\n\tstruct nlattr *sdp_attr, *uri_attr;\n\tstruct nfc_llcp_sdp_tlv *sdres;\n\tstruct hlist_node *n;\n\tvoid *hdr;\n\tint rc = -EMSGSIZE;\n\tint i;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_LLC_SDRES);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tsdp_attr = nla_nest_start_noflag(msg, NFC_ATTR_LLC_SDP);\n\tif (sdp_attr == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto nla_put_failure;\n\t}\n\n\ti = 1;\n\thlist_for_each_entry_safe(sdres, n, sdres_list, node) {\n\t\tpr_debug(\"uri: %s, sap: %d\\n\", sdres->uri, sdres->sap);\n\n\t\turi_attr = nla_nest_start_noflag(msg, i++);\n\t\tif (uri_attr == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto nla_put_failure;\n\t\t}\n\n\t\tif (nla_put_u8(msg, NFC_SDP_ATTR_SAP, sdres->sap))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_string(msg, NFC_SDP_ATTR_URI, sdres->uri))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, uri_attr);\n\n\t\thlist_del(&sdres->node);\n\n\t\tnfc_llcp_free_sdp_tlv(sdres);\n\t}\n\n\tnla_nest_end(msg, sdp_attr);\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\n\tnfc_llcp_free_sdp_tlv_list(sdres_list);\n\n\treturn rc;\n}\n\nint nfc_genl_se_added(struct nfc_dev *dev, u32 se_idx, u16 type)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_SE_ADDED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx) ||\n\t    nla_put_u8(msg, NFC_ATTR_SE_TYPE, type))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_se_removed(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_SE_REMOVED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_se_transaction(struct nfc_dev *dev, u8 se_idx,\n\t\t\t    struct nfc_evt_transaction *evt_transaction)\n{\n\tstruct nfc_se *se;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_SE_TRANSACTION);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx) ||\n\t    nla_put_u8(msg, NFC_ATTR_SE_TYPE, se->type) ||\n\t    nla_put(msg, NFC_ATTR_SE_AID, evt_transaction->aid_len,\n\t\t    evt_transaction->aid) ||\n\t    nla_put(msg, NFC_ATTR_SE_PARAMS, evt_transaction->params_len,\n\t\t    evt_transaction->params))\n\t\tgoto nla_put_failure;\n\n\t/* evt_transaction is no more used */\n\tdevm_kfree(&dev->dev, evt_transaction);\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\t/* evt_transaction is no more used */\n\tdevm_kfree(&dev->dev, evt_transaction);\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_se_connectivity(struct nfc_dev *dev, u8 se_idx)\n{\n\tconst struct nfc_se *se;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_SE_CONNECTIVITY);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx) ||\n\t    nla_put_u8(msg, NFC_ATTR_SE_TYPE, se->type))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_send_device(struct sk_buff *msg, struct nfc_dev *dev,\n\t\t\t\tu32 portid, u32 seq,\n\t\t\t\tstruct netlink_callback *cb,\n\t\t\t\tint flags)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(msg, portid, seq, &nfc_genl_family, flags,\n\t\t\t  NFC_CMD_GET_DEVICE);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (cb)\n\t\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (nfc_genl_setup_device_added(dev, msg))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_dump_devices(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tstruct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];\n\tstruct nfc_dev *dev = (struct nfc_dev *) cb->args[1];\n\tbool first_call = false;\n\n\tif (!iter) {\n\t\tfirst_call = true;\n\t\titer = kmalloc(sizeof(struct class_dev_iter), GFP_KERNEL);\n\t\tif (!iter)\n\t\t\treturn -ENOMEM;\n\t\tcb->args[0] = (long) iter;\n\t}\n\n\tmutex_lock(&nfc_devlist_mutex);\n\n\tcb->seq = nfc_devlist_generation;\n\n\tif (first_call) {\n\t\tnfc_device_iter_init(iter);\n\t\tdev = nfc_device_iter_next(iter);\n\t}\n\n\twhile (dev) {\n\t\tint rc;\n\n\t\trc = nfc_genl_send_device(skb, dev, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t  cb->nlh->nlmsg_seq, cb, NLM_F_MULTI);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\tdev = nfc_device_iter_next(iter);\n\t}\n\n\tmutex_unlock(&nfc_devlist_mutex);\n\n\tcb->args[1] = (long) dev;\n\n\treturn skb->len;\n}\n\nstatic int nfc_genl_dump_devices_done(struct netlink_callback *cb)\n{\n\tstruct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];\n\n\tif (iter) {\n\t\tnfc_device_iter_exit(iter);\n\t\tkfree(iter);\n\t}\n\n\treturn 0;\n}\n\nint nfc_genl_dep_link_up_event(struct nfc_dev *dev, u32 target_idx,\n\t\t\t       u8 comm_mode, u8 rf_mode)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tpr_debug(\"DEP link is up\\n\");\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0, NFC_CMD_DEP_LINK_UP);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\tif (rf_mode == NFC_RF_INITIATOR &&\n\t    nla_put_u32(msg, NFC_ATTR_TARGET_INDEX, target_idx))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u8(msg, NFC_ATTR_COMM_MODE, comm_mode) ||\n\t    nla_put_u8(msg, NFC_ATTR_RF_MODE, rf_mode))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tdev->dep_link_up = true;\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_dep_link_down_event(struct nfc_dev *dev)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tpr_debug(\"DEP link is down\\n\");\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_DEP_LINK_DOWN);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_get_device(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tstruct nfc_dev *dev;\n\tu32 idx;\n\tint rc = -ENOBUFS;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\trc = -ENOMEM;\n\t\tgoto out_putdev;\n\t}\n\n\trc = nfc_genl_send_device(msg, dev, info->snd_portid, info->snd_seq,\n\t\t\t\t  NULL, 0);\n\tif (rc < 0)\n\t\tgoto out_free;\n\n\tnfc_put_device(dev);\n\n\treturn genlmsg_reply(msg, info);\n\nout_free:\n\tnlmsg_free(msg);\nout_putdev:\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_dev_up(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_dev_up(dev);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_dev_down(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_dev_down(dev);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_start_poll(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\tu32 im_protocols = 0, tm_protocols = 0;\n\n\tpr_debug(\"Poll start\\n\");\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    ((!info->attrs[NFC_ATTR_IM_PROTOCOLS] &&\n\t      !info->attrs[NFC_ATTR_PROTOCOLS]) &&\n\t      !info->attrs[NFC_ATTR_TM_PROTOCOLS]))\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tif (info->attrs[NFC_ATTR_TM_PROTOCOLS])\n\t\ttm_protocols = nla_get_u32(info->attrs[NFC_ATTR_TM_PROTOCOLS]);\n\n\tif (info->attrs[NFC_ATTR_IM_PROTOCOLS])\n\t\tim_protocols = nla_get_u32(info->attrs[NFC_ATTR_IM_PROTOCOLS]);\n\telse if (info->attrs[NFC_ATTR_PROTOCOLS])\n\t\tim_protocols = nla_get_u32(info->attrs[NFC_ATTR_PROTOCOLS]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&dev->genl_data.genl_data_mutex);\n\n\trc = nfc_start_poll(dev, im_protocols, tm_protocols);\n\tif (!rc)\n\t\tdev->genl_data.poll_req_portid = info->snd_portid;\n\n\tmutex_unlock(&dev->genl_data.genl_data_mutex);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_stop_poll(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tdevice_lock(&dev->dev);\n\n\tif (!dev->polling) {\n\t\tdevice_unlock(&dev->dev);\n\t\tnfc_put_device(dev);\n\t\treturn -EINVAL;\n\t}\n\n\tdevice_unlock(&dev->dev);\n\n\tmutex_lock(&dev->genl_data.genl_data_mutex);\n\n\tif (dev->genl_data.poll_req_portid != info->snd_portid) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\trc = nfc_stop_poll(dev);\n\tdev->genl_data.poll_req_portid = 0;\n\nout:\n\tmutex_unlock(&dev->genl_data.genl_data_mutex);\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_activate_target(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx, protocol;\n\tint rc;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_TARGET_INDEX] ||\n\t    !info->attrs[NFC_ATTR_PROTOCOLS])\n\t\treturn -EINVAL;\n\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\tprotocol = nla_get_u32(info->attrs[NFC_ATTR_PROTOCOLS]);\n\n\tnfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\trc = nfc_activate_target(dev, target_idx, protocol);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx;\n\tint rc;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_TARGET_INDEX])\n\t\treturn -EINVAL;\n\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\n\trc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_dep_link_up(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc, tgt_idx;\n\tu32 idx;\n\tu8 comm;\n\n\tpr_debug(\"DEP link up\\n\");\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_COMM_MODE])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tif (!info->attrs[NFC_ATTR_TARGET_INDEX])\n\t\ttgt_idx = NFC_TARGET_IDX_ANY;\n\telse\n\t\ttgt_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\n\tcomm = nla_get_u8(info->attrs[NFC_ATTR_COMM_MODE]);\n\n\tif (comm != NFC_COMM_ACTIVE && comm != NFC_COMM_PASSIVE)\n\t\treturn -EINVAL;\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_dep_link_up(dev, tgt_idx, comm);\n\n\tnfc_put_device(dev);\n\n\treturn rc;\n}\n\nstatic int nfc_genl_dep_link_down(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_TARGET_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_dep_link_down(dev);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_send_params(struct sk_buff *msg,\n\t\t\t\tstruct nfc_llcp_local *local,\n\t\t\t\tu32 portid, u32 seq)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(msg, portid, seq, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_LLC_GET_PARAMS);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, local->dev->idx) ||\n\t    nla_put_u8(msg, NFC_ATTR_LLC_PARAM_LTO, local->lto) ||\n\t    nla_put_u8(msg, NFC_ATTR_LLC_PARAM_RW, local->rw) ||\n\t    nla_put_u16(msg, NFC_ATTR_LLC_PARAM_MIUX, be16_to_cpu(local->miux)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_llc_get_params(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tint rc = 0;\n\tstruct sk_buff *msg = NULL;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_FIRMWARE_NAME])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tdevice_lock(&dev->dev);\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\trc = -ENOMEM;\n\t\tgoto put_local;\n\t}\n\n\trc = nfc_genl_send_params(msg, local, info->snd_portid, info->snd_seq);\n\nput_local:\n\tnfc_llcp_local_put(local);\n\nexit:\n\tdevice_unlock(&dev->dev);\n\n\tnfc_put_device(dev);\n\n\tif (rc < 0) {\n\t\tif (msg)\n\t\t\tnlmsg_free(msg);\n\n\t\treturn rc;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int nfc_genl_llc_set_params(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tu8 rw = 0;\n\tu16 miux = 0;\n\tu32 idx;\n\tint rc = 0;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    (!info->attrs[NFC_ATTR_LLC_PARAM_LTO] &&\n\t     !info->attrs[NFC_ATTR_LLC_PARAM_RW] &&\n\t     !info->attrs[NFC_ATTR_LLC_PARAM_MIUX]))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_RW]) {\n\t\trw = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_RW]);\n\n\t\tif (rw > LLCP_MAX_RW)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_MIUX]) {\n\t\tmiux = nla_get_u16(info->attrs[NFC_ATTR_LLC_PARAM_MIUX]);\n\n\t\tif (miux > LLCP_MAX_MIUX)\n\t\t\treturn -EINVAL;\n\t}\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tdevice_lock(&dev->dev);\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_LTO]) {\n\t\tif (dev->dep_link_up) {\n\t\t\trc = -EINPROGRESS;\n\t\t\tgoto put_local;\n\t\t}\n\n\t\tlocal->lto = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_LTO]);\n\t}\n\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_RW])\n\t\tlocal->rw = rw;\n\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_MIUX])\n\t\tlocal->miux = cpu_to_be16(miux);\n\nput_local:\n\tnfc_llcp_local_put(local);\n\nexit:\n\tdevice_unlock(&dev->dev);\n\n\tnfc_put_device(dev);\n\n\treturn rc;\n}\n\nstatic int nfc_genl_llc_sdreq(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tstruct nlattr *attr, *sdp_attrs[NFC_SDP_ATTR_MAX+1];\n\tu32 idx;\n\tu8 tid;\n\tchar *uri;\n\tint rc = 0, rem;\n\tsize_t uri_len, tlvs_len;\n\tstruct hlist_head sdreq_list;\n\tstruct nfc_llcp_sdp_tlv *sdreq;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_LLC_SDP])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->dep_link_up == false) {\n\t\trc = -ENOLINK;\n\t\tgoto exit;\n\t}\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tINIT_HLIST_HEAD(&sdreq_list);\n\n\ttlvs_len = 0;\n\n\tnla_for_each_nested(attr, info->attrs[NFC_ATTR_LLC_SDP], rem) {\n\t\trc = nla_parse_nested_deprecated(sdp_attrs, NFC_SDP_ATTR_MAX,\n\t\t\t\t\t\t attr, nfc_sdp_genl_policy,\n\t\t\t\t\t\t info->extack);\n\n\t\tif (rc != 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto put_local;\n\t\t}\n\n\t\tif (!sdp_attrs[NFC_SDP_ATTR_URI])\n\t\t\tcontinue;\n\n\t\turi_len = nla_len(sdp_attrs[NFC_SDP_ATTR_URI]);\n\t\tif (uri_len == 0)\n\t\t\tcontinue;\n\n\t\turi = nla_data(sdp_attrs[NFC_SDP_ATTR_URI]);\n\t\tif (uri == NULL || *uri == 0)\n\t\t\tcontinue;\n\n\t\ttid = local->sdreq_next_tid++;\n\n\t\tsdreq = nfc_llcp_build_sdreq_tlv(tid, uri, uri_len);\n\t\tif (sdreq == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto put_local;\n\t\t}\n\n\t\ttlvs_len += sdreq->tlv_len;\n\n\t\thlist_add_head(&sdreq->node, &sdreq_list);\n\t}\n\n\tif (hlist_empty(&sdreq_list)) {\n\t\trc = -EINVAL;\n\t\tgoto put_local;\n\t}\n\n\trc = nfc_llcp_send_snl_sdreq(local, &sdreq_list, tlvs_len);\n\nput_local:\n\tnfc_llcp_local_put(local);\n\nexit:\n\tdevice_unlock(&dev->dev);\n\n\tnfc_put_device(dev);\n\n\treturn rc;\n}\n\nstatic int nfc_genl_fw_download(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\tchar firmware_name[NFC_FIRMWARE_NAME_MAXSIZE + 1];\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] || !info->attrs[NFC_ATTR_FIRMWARE_NAME])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tnla_strscpy(firmware_name, info->attrs[NFC_ATTR_FIRMWARE_NAME],\n\t\t    sizeof(firmware_name));\n\n\trc = nfc_fw_download(dev, firmware_name);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nint nfc_genl_fw_download_done(struct nfc_dev *dev, const char *firmware_name,\n\t\t\t      u32 result)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_FW_DOWNLOAD);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_string(msg, NFC_ATTR_FIRMWARE_NAME, firmware_name) ||\n\t    nla_put_u32(msg, NFC_ATTR_FIRMWARE_DOWNLOAD_STATUS, result) ||\n\t    nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_enable_se(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx, se_idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_SE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tse_idx = nla_get_u32(info->attrs[NFC_ATTR_SE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_enable_se(dev, se_idx);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_disable_se(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx, se_idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_SE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tse_idx = nla_get_u32(info->attrs[NFC_ATTR_SE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_disable_se(dev, se_idx);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_send_se(struct sk_buff *msg, struct nfc_dev *dev,\n\t\t\t\tu32 portid, u32 seq,\n\t\t\t\tstruct netlink_callback *cb,\n\t\t\t\tint flags)\n{\n\tvoid *hdr;\n\tstruct nfc_se *se, *n;\n\n\tlist_for_each_entry_safe(se, n, &dev->secure_elements, list) {\n\t\thdr = genlmsg_put(msg, portid, seq, &nfc_genl_family, flags,\n\t\t\t\t  NFC_CMD_GET_SE);\n\t\tif (!hdr)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (cb)\n\t\t\tgenl_dump_check_consistent(cb, hdr);\n\n\t\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se->idx) ||\n\t\t    nla_put_u8(msg, NFC_ATTR_SE_TYPE, se->type))\n\t\t\tgoto nla_put_failure;\n\n\t\tgenlmsg_end(msg, hdr);\n\t}\n\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_dump_ses(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tstruct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];\n\tstruct nfc_dev *dev = (struct nfc_dev *) cb->args[1];\n\tbool first_call = false;\n\n\tif (!iter) {\n\t\tfirst_call = true;\n\t\titer = kmalloc(sizeof(struct class_dev_iter), GFP_KERNEL);\n\t\tif (!iter)\n\t\t\treturn -ENOMEM;\n\t\tcb->args[0] = (long) iter;\n\t}\n\n\tmutex_lock(&nfc_devlist_mutex);\n\n\tcb->seq = nfc_devlist_generation;\n\n\tif (first_call) {\n\t\tnfc_device_iter_init(iter);\n\t\tdev = nfc_device_iter_next(iter);\n\t}\n\n\twhile (dev) {\n\t\tint rc;\n\n\t\trc = nfc_genl_send_se(skb, dev, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t  cb->nlh->nlmsg_seq, cb, NLM_F_MULTI);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\tdev = nfc_device_iter_next(iter);\n\t}\n\n\tmutex_unlock(&nfc_devlist_mutex);\n\n\tcb->args[1] = (long) dev;\n\n\treturn skb->len;\n}\n\nstatic int nfc_genl_dump_ses_done(struct netlink_callback *cb)\n{\n\tstruct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];\n\n\tif (iter) {\n\t\tnfc_device_iter_exit(iter);\n\t\tkfree(iter);\n\t}\n\n\treturn 0;\n}\n\nstatic int nfc_se_io(struct nfc_dev *dev, u32 se_idx,\n\t\t     u8 *apdu, size_t apdu_length,\n\t\t     se_io_cb_t cb, void *cb_context)\n{\n\tstruct nfc_se *se;\n\tint rc;\n\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\n\tdevice_lock(&dev->dev);\n\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (!dev->ops->se_io) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (se->state != NFC_SE_ENABLED) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\trc = dev->ops->se_io(dev, se_idx, apdu,\n\t\t\tapdu_length, cb, cb_context);\n\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n\nerror:\n\tdevice_unlock(&dev->dev);\n\tkfree(cb_context);\n\treturn rc;\n}\n\nstruct se_io_ctx {\n\tu32 dev_idx;\n\tu32 se_idx;\n};\n\nstatic void se_io_cb(void *context, u8 *apdu, size_t apdu_len, int err)\n{\n\tstruct se_io_ctx *ctx = context;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\tkfree(ctx);\n\t\treturn;\n\t}\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_SE_IO);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, ctx->dev_idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, ctx->se_idx) ||\n\t    nla_put(msg, NFC_ATTR_SE_APDU, apdu_len, apdu))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\tkfree(ctx);\n\n\treturn;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\tkfree(ctx);\n\n\treturn;\n}\n\nstatic int nfc_genl_se_io(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct se_io_ctx *ctx;\n\tu32 dev_idx, se_idx;\n\tu8 *apdu;\n\tsize_t apdu_len;\n\tint rc;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_SE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_SE_APDU])\n\t\treturn -EINVAL;\n\n\tdev_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tse_idx = nla_get_u32(info->attrs[NFC_ATTR_SE_INDEX]);\n\n\tdev = nfc_get_device(dev_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tif (!dev->ops || !dev->ops->se_io) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto put_dev;\n\t}\n\n\tapdu_len = nla_len(info->attrs[NFC_ATTR_SE_APDU]);\n\tif (apdu_len == 0) {\n\t\trc = -EINVAL;\n\t\tgoto put_dev;\n\t}\n\n\tapdu = nla_data(info->attrs[NFC_ATTR_SE_APDU]);\n\tif (!apdu) {\n\t\trc = -EINVAL;\n\t\tgoto put_dev;\n\t}\n\n\tctx = kzalloc(sizeof(struct se_io_ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\trc = -ENOMEM;\n\t\tgoto put_dev;\n\t}\n\n\tctx->dev_idx = dev_idx;\n\tctx->se_idx = se_idx;\n\n\trc = nfc_se_io(dev, se_idx, apdu, apdu_len, se_io_cb, ctx);\n\nput_dev:\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_vendor_cmd(struct sk_buff *skb,\n\t\t\t       struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tconst struct nfc_vendor_cmd *cmd;\n\tu32 dev_idx, vid, subcmd;\n\tu8 *data;\n\tsize_t data_len;\n\tint i, err;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_VENDOR_ID] ||\n\t    !info->attrs[NFC_ATTR_VENDOR_SUBCMD])\n\t\treturn -EINVAL;\n\n\tdev_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tvid = nla_get_u32(info->attrs[NFC_ATTR_VENDOR_ID]);\n\tsubcmd = nla_get_u32(info->attrs[NFC_ATTR_VENDOR_SUBCMD]);\n\n\tdev = nfc_get_device(dev_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tif (!dev->vendor_cmds || !dev->n_vendor_cmds) {\n\t\terr = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\n\tif (info->attrs[NFC_ATTR_VENDOR_DATA]) {\n\t\tdata = nla_data(info->attrs[NFC_ATTR_VENDOR_DATA]);\n\t\tdata_len = nla_len(info->attrs[NFC_ATTR_VENDOR_DATA]);\n\t\tif (data_len == 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto put_dev;\n\t\t}\n\t} else {\n\t\tdata = NULL;\n\t\tdata_len = 0;\n\t}\n\n\tfor (i = 0; i < dev->n_vendor_cmds; i++) {\n\t\tcmd = &dev->vendor_cmds[i];\n\n\t\tif (cmd->vendor_id != vid || cmd->subcmd != subcmd)\n\t\t\tcontinue;\n\n\t\tdev->cur_cmd_info = info;\n\t\terr = cmd->doit(dev, data, data_len);\n\t\tdev->cur_cmd_info = NULL;\n\t\tgoto put_dev;\n\t}\n\n\terr = -EOPNOTSUPP;\n\nput_dev:\n\tnfc_put_device(dev);\n\treturn err;\n}\n\n/* message building helper */\nstatic inline void *nfc_hdr_put(struct sk_buff *skb, u32 portid, u32 seq,\n\t\t\t\tint flags, u8 cmd)\n{\n\t/* since there is no private header just add the generic one */\n\treturn genlmsg_put(skb, portid, seq, &nfc_genl_family, flags, cmd);\n}\n\nstatic struct sk_buff *\n__nfc_alloc_vendor_cmd_skb(struct nfc_dev *dev, int approxlen,\n\t\t\t   u32 portid, u32 seq,\n\t\t\t   enum nfc_attrs attr,\n\t\t\t   u32 oui, u32 subcmd, gfp_t gfp)\n{\n\tstruct sk_buff *skb;\n\tvoid *hdr;\n\n\tskb = nlmsg_new(approxlen + 100, gfp);\n\tif (!skb)\n\t\treturn NULL;\n\n\thdr = nfc_hdr_put(skb, portid, seq, 0, NFC_CMD_VENDOR);\n\tif (!hdr) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tif (nla_put_u32(skb, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(skb, NFC_ATTR_VENDOR_ID, oui))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(skb, NFC_ATTR_VENDOR_SUBCMD, subcmd))\n\t\tgoto nla_put_failure;\n\n\t((void **)skb->cb)[0] = dev;\n\t((void **)skb->cb)[1] = hdr;\n\n\treturn skb;\n\nnla_put_failure:\n\tkfree_skb(skb);\n\treturn NULL;\n}\n\nstruct sk_buff *__nfc_alloc_vendor_cmd_reply_skb(struct nfc_dev *dev,\n\t\t\t\t\t\t enum nfc_attrs attr,\n\t\t\t\t\t\t u32 oui, u32 subcmd,\n\t\t\t\t\t\t int approxlen)\n{\n\tif (WARN_ON(!dev->cur_cmd_info))\n\t\treturn NULL;\n\n\treturn __nfc_alloc_vendor_cmd_skb(dev, approxlen,\n\t\t\t\t\t  dev->cur_cmd_info->snd_portid,\n\t\t\t\t\t  dev->cur_cmd_info->snd_seq, attr,\n\t\t\t\t\t  oui, subcmd, GFP_KERNEL);\n}\nEXPORT_SYMBOL(__nfc_alloc_vendor_cmd_reply_skb);\n\nint nfc_vendor_cmd_reply(struct sk_buff *skb)\n{\n\tstruct nfc_dev *dev = ((void **)skb->cb)[0];\n\tvoid *hdr = ((void **)skb->cb)[1];\n\n\t/* clear CB data for netlink core to own from now on */\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\n\tif (WARN_ON(!dev->cur_cmd_info)) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tgenlmsg_end(skb, hdr);\n\treturn genlmsg_reply(skb, dev->cur_cmd_info);\n}\nEXPORT_SYMBOL(nfc_vendor_cmd_reply);\n\nstatic const struct genl_ops nfc_genl_ops[] = {\n\t{\n\t\t.cmd = NFC_CMD_GET_DEVICE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_get_device,\n\t\t.dumpit = nfc_genl_dump_devices,\n\t\t.done = nfc_genl_dump_devices_done,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_DEV_UP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_dev_up,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_DEV_DOWN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_dev_down,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_START_POLL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_start_poll,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_STOP_POLL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_stop_poll,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_DEP_LINK_UP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_dep_link_up,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_DEP_LINK_DOWN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_dep_link_down,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_GET_TARGET,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT |\n\t\t\t    GENL_DONT_VALIDATE_DUMP_STRICT,\n\t\t.dumpit = nfc_genl_dump_targets,\n\t\t.done = nfc_genl_dump_targets_done,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_LLC_GET_PARAMS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_llc_get_params,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_LLC_SET_PARAMS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_llc_set_params,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_LLC_SDREQ,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_llc_sdreq,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_FW_DOWNLOAD,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_fw_download,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_ENABLE_SE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_enable_se,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_DISABLE_SE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_disable_se,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_GET_SE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.dumpit = nfc_genl_dump_ses,\n\t\t.done = nfc_genl_dump_ses_done,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_SE_IO,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_se_io,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_ACTIVATE_TARGET,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_activate_target,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_VENDOR,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_vendor_cmd,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_DEACTIVATE_TARGET,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_deactivate_target,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n};\n\nstatic struct genl_family nfc_genl_family __ro_after_init = {\n\t.hdrsize = 0,\n\t.name = NFC_GENL_NAME,\n\t.version = NFC_GENL_VERSION,\n\t.maxattr = NFC_ATTR_MAX,\n\t.policy = nfc_genl_policy,\n\t.module = THIS_MODULE,\n\t.ops = nfc_genl_ops,\n\t.n_ops = ARRAY_SIZE(nfc_genl_ops),\n\t.resv_start_op = NFC_CMD_DEACTIVATE_TARGET + 1,\n\t.mcgrps = nfc_genl_mcgrps,\n\t.n_mcgrps = ARRAY_SIZE(nfc_genl_mcgrps),\n};\n\n\nstruct urelease_work {\n\tstruct\twork_struct w;\n\tu32\tportid;\n};\n\nstatic void nfc_urelease_event_work(struct work_struct *work)\n{\n\tstruct urelease_work *w = container_of(work, struct urelease_work, w);\n\tstruct class_dev_iter iter;\n\tstruct nfc_dev *dev;\n\n\tpr_debug(\"portid %d\\n\", w->portid);\n\n\tmutex_lock(&nfc_devlist_mutex);\n\n\tnfc_device_iter_init(&iter);\n\tdev = nfc_device_iter_next(&iter);\n\n\twhile (dev) {\n\t\tmutex_lock(&dev->genl_data.genl_data_mutex);\n\n\t\tif (dev->genl_data.poll_req_portid == w->portid) {\n\t\t\tnfc_stop_poll(dev);\n\t\t\tdev->genl_data.poll_req_portid = 0;\n\t\t}\n\n\t\tmutex_unlock(&dev->genl_data.genl_data_mutex);\n\n\t\tdev = nfc_device_iter_next(&iter);\n\t}\n\n\tnfc_device_iter_exit(&iter);\n\n\tmutex_unlock(&nfc_devlist_mutex);\n\n\tkfree(w);\n}\n\nstatic int nfc_genl_rcv_nl_event(struct notifier_block *this,\n\t\t\t\t unsigned long event, void *ptr)\n{\n\tstruct netlink_notify *n = ptr;\n\tstruct urelease_work *w;\n\n\tif (event != NETLINK_URELEASE || n->protocol != NETLINK_GENERIC)\n\t\tgoto out;\n\n\tpr_debug(\"NETLINK_URELEASE event from id %d\\n\", n->portid);\n\n\tw = kmalloc(sizeof(*w), GFP_ATOMIC);\n\tif (w) {\n\t\tINIT_WORK(&w->w, nfc_urelease_event_work);\n\t\tw->portid = n->portid;\n\t\tschedule_work(&w->w);\n\t}\n\nout:\n\treturn NOTIFY_DONE;\n}\n\nvoid nfc_genl_data_init(struct nfc_genl_data *genl_data)\n{\n\tgenl_data->poll_req_portid = 0;\n\tmutex_init(&genl_data->genl_data_mutex);\n}\n\nvoid nfc_genl_data_exit(struct nfc_genl_data *genl_data)\n{\n\tmutex_destroy(&genl_data->genl_data_mutex);\n}\n\nstatic struct notifier_block nl_notifier = {\n\t.notifier_call  = nfc_genl_rcv_nl_event,\n};\n\n/**\n * nfc_genl_init() - Initialize netlink interface\n *\n * This initialization function registers the nfc netlink family.\n */\nint __init nfc_genl_init(void)\n{\n\tint rc;\n\n\trc = genl_register_family(&nfc_genl_family);\n\tif (rc)\n\t\treturn rc;\n\n\tnetlink_register_notifier(&nl_notifier);\n\n\treturn 0;\n}\n\n/**\n * nfc_genl_exit() - Deinitialize netlink interface\n *\n * This exit function unregisters the nfc netlink family.\n */\nvoid nfc_genl_exit(void)\n{\n\tnetlink_unregister_notifier(&nl_notifier);\n\tgenl_unregister_family(&nfc_genl_family);\n}\n", "/* SPDX-License-Identifier: GPL-2.0-or-later */\n/*\n * Copyright (C) 2011 Instituto Nokia de Tecnologia\n *\n * Authors:\n *    Lauro Ramos Venancio <lauro.venancio@openbossa.org>\n *    Aloisio Almeida Jr <aloisio.almeida@openbossa.org>\n */\n\n#ifndef __LOCAL_NFC_H\n#define __LOCAL_NFC_H\n\n#include <net/nfc/nfc.h>\n#include <net/sock.h>\n\n#define NFC_TARGET_MODE_IDLE 0\n#define NFC_TARGET_MODE_SLEEP 1\n\nstruct nfc_protocol {\n\tint id;\n\tstruct proto *proto;\n\tstruct module *owner;\n\tint (*create)(struct net *net, struct socket *sock,\n\t\t      const struct nfc_protocol *nfc_proto, int kern);\n};\n\nstruct nfc_rawsock {\n\tstruct sock sk;\n\tstruct nfc_dev *dev;\n\tu32 target_idx;\n\tstruct work_struct tx_work;\n\tbool tx_work_scheduled;\n};\n\nstruct nfc_sock_list {\n\tstruct hlist_head head;\n\trwlock_t          lock;\n};\n\n#define nfc_rawsock(sk) ((struct nfc_rawsock *) sk)\n#define to_rawsock_sk(_tx_work) \\\n\t((struct sock *) container_of(_tx_work, struct nfc_rawsock, tx_work))\n\nstruct nfc_llcp_sdp_tlv;\n\nvoid nfc_llcp_mac_is_down(struct nfc_dev *dev);\nvoid nfc_llcp_mac_is_up(struct nfc_dev *dev, u32 target_idx,\n\t\t\tu8 comm_mode, u8 rf_mode);\nint nfc_llcp_register_device(struct nfc_dev *dev);\nvoid nfc_llcp_unregister_device(struct nfc_dev *dev);\nint nfc_llcp_set_remote_gb(struct nfc_dev *dev, const u8 *gb, u8 gb_len);\nu8 *nfc_llcp_general_bytes(struct nfc_dev *dev, size_t *general_bytes_len);\nint nfc_llcp_data_received(struct nfc_dev *dev, struct sk_buff *skb);\nstruct nfc_llcp_local *nfc_llcp_find_local(struct nfc_dev *dev);\nint nfc_llcp_local_put(struct nfc_llcp_local *local);\nint __init nfc_llcp_init(void);\nvoid nfc_llcp_exit(void);\nvoid nfc_llcp_free_sdp_tlv(struct nfc_llcp_sdp_tlv *sdp);\nvoid nfc_llcp_free_sdp_tlv_list(struct hlist_head *head);\n\nint __init rawsock_init(void);\nvoid rawsock_exit(void);\n\nint __init af_nfc_init(void);\nvoid af_nfc_exit(void);\nint nfc_proto_register(const struct nfc_protocol *nfc_proto);\nvoid nfc_proto_unregister(const struct nfc_protocol *nfc_proto);\n\nextern int nfc_devlist_generation;\nextern struct mutex nfc_devlist_mutex;\n\nint __init nfc_genl_init(void);\nvoid nfc_genl_exit(void);\n\nvoid nfc_genl_data_init(struct nfc_genl_data *genl_data);\nvoid nfc_genl_data_exit(struct nfc_genl_data *genl_data);\n\nint nfc_genl_targets_found(struct nfc_dev *dev);\nint nfc_genl_target_lost(struct nfc_dev *dev, u32 target_idx);\n\nint nfc_genl_device_added(struct nfc_dev *dev);\nint nfc_genl_device_removed(struct nfc_dev *dev);\n\nint nfc_genl_dep_link_up_event(struct nfc_dev *dev, u32 target_idx,\n\t\t\t       u8 comm_mode, u8 rf_mode);\nint nfc_genl_dep_link_down_event(struct nfc_dev *dev);\n\nint nfc_genl_tm_activated(struct nfc_dev *dev, u32 protocol);\nint nfc_genl_tm_deactivated(struct nfc_dev *dev);\n\nint nfc_genl_llc_send_sdres(struct nfc_dev *dev, struct hlist_head *sdres_list);\n\nint nfc_genl_se_added(struct nfc_dev *dev, u32 se_idx, u16 type);\nint nfc_genl_se_removed(struct nfc_dev *dev, u32 se_idx);\nint nfc_genl_se_transaction(struct nfc_dev *dev, u8 se_idx,\n\t\t\t    struct nfc_evt_transaction *evt_transaction);\nint nfc_genl_se_connectivity(struct nfc_dev *dev, u8 se_idx);\n\nstruct nfc_dev *nfc_get_device(unsigned int idx);\n\nstatic inline void nfc_put_device(struct nfc_dev *dev)\n{\n\tput_device(&dev->dev);\n}\n\nstatic inline void nfc_device_iter_init(struct class_dev_iter *iter)\n{\n\tclass_dev_iter_init(iter, &nfc_class, NULL, NULL);\n}\n\nstatic inline struct nfc_dev *nfc_device_iter_next(struct class_dev_iter *iter)\n{\n\tstruct device *d = class_dev_iter_next(iter);\n\tif (!d)\n\t\treturn NULL;\n\n\treturn to_nfc_dev(d);\n}\n\nstatic inline void nfc_device_iter_exit(struct class_dev_iter *iter)\n{\n\tclass_dev_iter_exit(iter);\n}\n\nint nfc_fw_download(struct nfc_dev *dev, const char *firmware_name);\nint nfc_genl_fw_download_done(struct nfc_dev *dev, const char *firmware_name,\n\t\t\t      u32 result);\n\nint nfc_dev_up(struct nfc_dev *dev);\n\nint nfc_dev_down(struct nfc_dev *dev);\n\nint nfc_start_poll(struct nfc_dev *dev, u32 im_protocols, u32 tm_protocols);\n\nint nfc_stop_poll(struct nfc_dev *dev);\n\nint nfc_dep_link_up(struct nfc_dev *dev, int target_idx, u8 comm_mode);\n\nint nfc_dep_link_down(struct nfc_dev *dev);\n\nint nfc_activate_target(struct nfc_dev *dev, u32 target_idx, u32 protocol);\n\nint nfc_deactivate_target(struct nfc_dev *dev, u32 target_idx, u8 mode);\n\nint nfc_data_exchange(struct nfc_dev *dev, u32 target_idx, struct sk_buff *skb,\n\t\t      data_exchange_cb_t cb, void *cb_context);\n\nint nfc_enable_se(struct nfc_dev *dev, u32 se_idx);\nint nfc_disable_se(struct nfc_dev *dev, u32 se_idx);\n\n#endif /* __LOCAL_NFC_H */\n"], "filenames": ["net/nfc/llcp.h", "net/nfc/llcp_commands.c", "net/nfc/llcp_core.c", "net/nfc/llcp_sock.c", "net/nfc/netlink.c", "net/nfc/nfc.h"], "buggy_code_start_loc": [204, 361, 19, 102, 1042, 54], "buggy_code_end_loc": [205, 383, 1612, 763, 1207, 54], "fixing_code_start_loc": [203, 362, 20, 102, 1042, 55], "fixing_code_end_loc": [203, 390, 1647, 766, 1218, 56], "type": "CWE-416", "message": "A use-after-free flaw was found in nfc_llcp_find_local in net/nfc/llcp_core.c in NFC in the Linux kernel. This flaw allows a local user with special privileges to impact a kernel information leak issue.", "other": {"cve": {"id": "CVE-2023-3863", "sourceIdentifier": "secalert@redhat.com", "published": "2023-07-24T15:15:09.397", "lastModified": "2024-02-02T14:15:53.857", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A use-after-free flaw was found in nfc_llcp_find_local in net/nfc/llcp_core.c in NFC in the Linux kernel. This flaw allows a local user with special privileges to impact a kernel information leak issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.5, "impactScore": 3.6}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.5, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.5", "matchCriteriaId": "98C491C7-598A-4D36-BA4F-3505A5727ED1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:12.0:*:*:*:*:*:*:*", "matchCriteriaId": "46D69DCC-AE4D-4EA5-861C-D60951444C6C"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2023-3863", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2225126", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/6709d4b7bc2e079241fdef15d1160581c5261c10", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/10/msg00027.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20240202-0002/", "source": "secalert@redhat.com"}, {"url": "https://www.debian.org/security/2023/dsa-5480", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5492", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/6709d4b7bc2e079241fdef15d1160581c5261c10"}}