{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * mouse.c: mouse handling functions\n */\n\n#include \"vim.h\"\n\n/*\n * Horiziontal and vertical steps used when scrolling.\n * When negative scroll by a whole page.\n */\nstatic long mouse_hor_step = 6;\nstatic long mouse_vert_step = 3;\n\n    void\nmouse_set_vert_scroll_step(long step)\n{\n    mouse_vert_step = step;\n}\n\n    void\nmouse_set_hor_scroll_step(long step)\n{\n    mouse_hor_step = step;\n}\n\n#ifdef CHECK_DOUBLE_CLICK\n/*\n * Return the duration from t1 to t2 in milliseconds.\n */\n    static long\ntime_diff_ms(struct timeval *t1, struct timeval *t2)\n{\n    // This handles wrapping of tv_usec correctly without any special case.\n    // Example of 2 pairs (tv_sec, tv_usec) with a duration of 5 ms:\n    //\t   t1 = (1, 998000) t2 = (2, 3000) gives:\n    //\t   (2 - 1) * 1000 + (3000 - 998000) / 1000 -> 5 ms.\n    return (t2->tv_sec - t1->tv_sec) * 1000\n\t + (t2->tv_usec - t1->tv_usec) / 1000;\n}\n#endif\n\n/*\n * Get class of a character for selection: same class means same word.\n * 0: blank\n * 1: punctuation groups\n * 2: normal word character\n * >2: multi-byte word character.\n */\n    static int\nget_mouse_class(char_u *p)\n{\n    int\t\tc;\n\n    if (has_mbyte && MB_BYTE2LEN(p[0]) > 1)\n\treturn mb_get_class(p);\n\n    c = *p;\n    if (c == ' ' || c == '\\t')\n\treturn 0;\n\n    if (vim_iswordc(c))\n\treturn 2;\n\n    // There are a few special cases where we want certain combinations of\n    // characters to be considered as a single word.  These are things like\n    // \"->\", \"/ *\", \"*=\", \"+=\", \"&=\", \"<=\", \">=\", \"!=\" etc.  Otherwise, each\n    // character is in its own class.\n    if (c != NUL && vim_strchr((char_u *)\"-+*/%<>&|^!=\", c) != NULL)\n\treturn 1;\n    return c;\n}\n\n/*\n * Move \"pos\" back to the start of the word it's in.\n */\n    static void\nfind_start_of_word(pos_T *pos)\n{\n    char_u\t*line;\n    int\t\tcclass;\n    int\t\tcol;\n\n    line = ml_get(pos->lnum);\n    cclass = get_mouse_class(line + pos->col);\n\n    while (pos->col > 0)\n    {\n\tcol = pos->col - 1;\n\tcol -= (*mb_head_off)(line, line + col);\n\tif (get_mouse_class(line + col) != cclass)\n\t    break;\n\tpos->col = col;\n    }\n}\n\n/*\n * Move \"pos\" forward to the end of the word it's in.\n * When 'selection' is \"exclusive\", the position is just after the word.\n */\n    static void\nfind_end_of_word(pos_T *pos)\n{\n    char_u\t*line;\n    int\t\tcclass;\n    int\t\tcol;\n\n    line = ml_get(pos->lnum);\n    if (*p_sel == 'e' && pos->col > 0)\n    {\n\t--pos->col;\n\tpos->col -= (*mb_head_off)(line, line + pos->col);\n    }\n    cclass = get_mouse_class(line + pos->col);\n    while (line[pos->col] != NUL)\n    {\n\tcol = pos->col + (*mb_ptr2len)(line + pos->col);\n\tif (get_mouse_class(line + col) != cclass)\n\t{\n\t    if (*p_sel == 'e')\n\t\tpos->col = col;\n\t    break;\n\t}\n\tpos->col = col;\n    }\n}\n\n#if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) \\\n\t    || defined(FEAT_GUI_MSWIN) \\\n\t    || defined(FEAT_GUI_PHOTON) \\\n\t    || defined(FEAT_TERM_POPUP_MENU)\n# define USE_POPUP_SETPOS\n# define NEED_VCOL2COL\n\n/*\n * Translate window coordinates to buffer position without any side effects\n */\n    static int\nget_fpos_of_mouse(pos_T *mpos)\n{\n    win_T\t*wp;\n    int\t\trow = mouse_row;\n    int\t\tcol = mouse_col;\n\n    if (row < 0 || col < 0)\t\t// check if it makes sense\n\treturn IN_UNKNOWN;\n\n    // find the window where the row is in\n    wp = mouse_find_win(&row, &col, FAIL_POPUP);\n    if (wp == NULL)\n\treturn IN_UNKNOWN;\n    // winpos and height may change in win_enter()!\n    if (row >= wp->w_height)\t// In (or below) status line\n\treturn IN_STATUS_LINE;\n    if (col >= wp->w_width)\t// In vertical separator line\n\treturn IN_SEP_LINE;\n\n    if (wp != curwin)\n\treturn IN_UNKNOWN;\n\n    // compute the position in the buffer line from the posn on the screen\n    if (mouse_comp_pos(curwin, &row, &col, &mpos->lnum, NULL))\n\treturn IN_STATUS_LINE; // past bottom\n\n    mpos->col = vcol2col(wp, mpos->lnum, col);\n\n    if (mpos->col > 0)\n\t--mpos->col;\n    mpos->coladd = 0;\n    return IN_BUFFER;\n}\n#endif\n\n/*\n * Do the appropriate action for the current mouse click in the current mode.\n * Not used for Command-line mode.\n *\n * Normal and Visual Mode:\n * event\t modi-\tposition      visual\t   change   action\n *\t\t fier\tcursor\t\t\t   window\n * left press\t  -\tyes\t    end\t\t    yes\n * left press\t  C\tyes\t    end\t\t    yes\t    \"^]\" (2)\n * left press\t  S\tyes\tend (popup: extend) yes\t    \"*\" (2)\n * left drag\t  -\tyes\tstart if moved\t    no\n * left relse\t  -\tyes\tstart if moved\t    no\n * middle press\t  -\tyes\t if not active\t    no\t    put register\n * middle press\t  -\tyes\t if active\t    no\t    yank and put\n * right press\t  -\tyes\tstart or extend\t    yes\n * right press\t  S\tyes\tno change\t    yes\t    \"#\" (2)\n * right drag\t  -\tyes\textend\t\t    no\n * right relse\t  -\tyes\textend\t\t    no\n *\n * Insert or Replace Mode:\n * event\t modi-\tposition      visual\t   change   action\n *\t\t fier\tcursor\t\t\t   window\n * left press\t  -\tyes\t(cannot be active)  yes\n * left press\t  C\tyes\t(cannot be active)  yes\t    \"CTRL-O^]\" (2)\n * left press\t  S\tyes\t(cannot be active)  yes\t    \"CTRL-O*\" (2)\n * left drag\t  -\tyes\tstart or extend (1) no\t    CTRL-O (1)\n * left relse\t  -\tyes\tstart or extend (1) no\t    CTRL-O (1)\n * middle press\t  -\tno\t(cannot be active)  no\t    put register\n * right press\t  -\tyes\tstart or extend\t    yes\t    CTRL-O\n * right press\t  S\tyes\t(cannot be active)  yes\t    \"CTRL-O#\" (2)\n *\n * (1) only if mouse pointer moved since press\n * (2) only if click is in same buffer\n *\n * Return TRUE if start_arrow() should be called for edit mode.\n */\n    int\ndo_mouse(\n    oparg_T\t*oap,\t\t// operator argument, can be NULL\n    int\t\tc,\t\t// K_LEFTMOUSE, etc\n    int\t\tdir,\t\t// Direction to 'put' if necessary\n    long\tcount,\n    int\t\tfixindent)\t// PUT_FIXINDENT if fixing indent necessary\n{\n    static int\tdo_always = FALSE;\t// ignore 'mouse' setting next time\n    static int\tgot_click = FALSE;\t// got a click some time back\n\n    int\t\twhich_button;\t// MOUSE_LEFT, _MIDDLE or _RIGHT\n    int\t\tis_click = FALSE; // If FALSE it's a drag or release event\n    int\t\tis_drag = FALSE;  // If TRUE it's a drag event\n    int\t\tjump_flags = 0;\t// flags for jump_to_mouse()\n    pos_T\tstart_visual;\n    int\t\tmoved;\t\t// Has cursor moved?\n    int\t\tin_status_line;\t// mouse in status line\n    static int\tin_tab_line = FALSE; // mouse clicked in tab line\n    int\t\tin_sep_line;\t// mouse in vertical separator line\n    int\t\tc1, c2;\n#if defined(FEAT_FOLDING)\n    pos_T\tsave_cursor;\n#endif\n    win_T\t*old_curwin = curwin;\n    static pos_T orig_cursor;\n    colnr_T\tleftcol, rightcol;\n    pos_T\tend_visual;\n    int\t\tdiff;\n    int\t\told_active = VIsual_active;\n    int\t\told_mode = VIsual_mode;\n    int\t\tregname;\n\n#if defined(FEAT_FOLDING)\n    save_cursor = curwin->w_cursor;\n#endif\n\n    // When GUI is active, always recognize mouse events, otherwise:\n    // - Ignore mouse event in normal mode if 'mouse' doesn't include 'n'.\n    // - Ignore mouse event in visual mode if 'mouse' doesn't include 'v'.\n    // - For command line and insert mode 'mouse' is checked before calling\n    //\t do_mouse().\n    if (do_always)\n\tdo_always = FALSE;\n    else\n#ifdef FEAT_GUI\n\tif (!gui.in_use)\n#endif\n\t{\n\t    if (VIsual_active)\n\t    {\n\t\tif (!mouse_has(MOUSE_VISUAL))\n\t\t    return FALSE;\n\t    }\n\t    else if (State == MODE_NORMAL && !mouse_has(MOUSE_NORMAL))\n\t\treturn FALSE;\n\t}\n\n    for (;;)\n    {\n\twhich_button = get_mouse_button(KEY2TERMCAP1(c), &is_click, &is_drag);\n\tif (is_drag)\n\t{\n\t    // If the next character is the same mouse event then use that\n\t    // one. Speeds up dragging the status line.\n\t    // Note: Since characters added to the stuff buffer in the code\n\t    // below need to come before the next character, do not do this\n\t    // when the current character was stuffed.\n\t    if (!KeyStuffed && vpeekc() != NUL)\n\t    {\n\t\tint nc;\n\t\tint save_mouse_row = mouse_row;\n\t\tint save_mouse_col = mouse_col;\n\n\t\t// Need to get the character, peeking doesn't get the actual\n\t\t// one.\n\t\tnc = safe_vgetc();\n\t\tif (c == nc)\n\t\t    continue;\n\t\tvungetc(nc);\n\t\tmouse_row = save_mouse_row;\n\t\tmouse_col = save_mouse_col;\n\t    }\n\t}\n\tbreak;\n    }\n\n    if (c == K_MOUSEMOVE)\n    {\n\t// Mouse moved without a button pressed.\n#ifdef FEAT_BEVAL_TERM\n\tui_may_remove_balloon();\n\tif (p_bevalterm)\n\t{\n\t    profile_setlimit(p_bdlay, &bevalexpr_due);\n\t    bevalexpr_due_set = TRUE;\n\t}\n#endif\n#ifdef FEAT_PROP_POPUP\n\tpopup_handle_mouse_moved();\n#endif\n\treturn FALSE;\n    }\n\n#ifdef FEAT_MOUSESHAPE\n    // May have stopped dragging the status or separator line.  The pointer is\n    // most likely still on the status or separator line.\n    if (!is_drag && drag_status_line)\n    {\n\tdrag_status_line = FALSE;\n\tupdate_mouseshape(SHAPE_IDX_STATUS);\n    }\n    if (!is_drag && drag_sep_line)\n    {\n\tdrag_sep_line = FALSE;\n\tupdate_mouseshape(SHAPE_IDX_VSEP);\n    }\n#endif\n\n    // Ignore drag and release events if we didn't get a click.\n    if (is_click)\n\tgot_click = TRUE;\n    else\n    {\n\tif (!got_click)\t\t\t// didn't get click, ignore\n\t    return FALSE;\n\tif (!is_drag)\t\t\t// release, reset got_click\n\t{\n\t    got_click = FALSE;\n\t    if (in_tab_line)\n\t    {\n\t\tin_tab_line = FALSE;\n\t\treturn FALSE;\n\t    }\n\t}\n    }\n\n    // CTRL right mouse button does CTRL-T\n    if (is_click && (mod_mask & MOD_MASK_CTRL) && which_button == MOUSE_RIGHT)\n    {\n\tif (State & MODE_INSERT)\n\t    stuffcharReadbuff(Ctrl_O);\n\tif (count > 1)\n\t    stuffnumReadbuff(count);\n\tstuffcharReadbuff(Ctrl_T);\n\tgot_click = FALSE;\t\t// ignore drag&release now\n\treturn FALSE;\n    }\n\n    // CTRL only works with left mouse button\n    if ((mod_mask & MOD_MASK_CTRL) && which_button != MOUSE_LEFT)\n\treturn FALSE;\n\n    // When a modifier is down, ignore drag and release events, as well as\n    // multiple clicks and the middle mouse button.\n    // Accept shift-leftmouse drags when 'mousemodel' is \"popup.*\".\n    if ((mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT\n\t\t\t\t\t\t\t     | MOD_MASK_META))\n\t    && (!is_click\n\t\t|| (mod_mask & MOD_MASK_MULTI_CLICK)\n\t\t|| which_button == MOUSE_MIDDLE)\n\t    && !((mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT))\n\t\t&& mouse_model_popup()\n\t\t&& which_button == MOUSE_LEFT)\n\t    && !((mod_mask & MOD_MASK_ALT)\n\t\t&& !mouse_model_popup()\n\t\t&& which_button == MOUSE_RIGHT)\n\t    )\n\treturn FALSE;\n\n    // If the button press was used as the movement command for an operator\n    // (eg \"d<MOUSE>\"), or it is the middle button that is held down, ignore\n    // drag/release events.\n    if (!is_click && which_button == MOUSE_MIDDLE)\n\treturn FALSE;\n\n    if (oap != NULL)\n\tregname = oap->regname;\n    else\n\tregname = 0;\n\n    // Middle mouse button does a 'put' of the selected text\n    if (which_button == MOUSE_MIDDLE)\n    {\n\tif (State == MODE_NORMAL)\n\t{\n\t    // If an operator was pending, we don't know what the user wanted\n\t    // to do. Go back to normal mode: Clear the operator and beep().\n\t    if (oap != NULL && oap->op_type != OP_NOP)\n\t    {\n\t\tclearopbeep(oap);\n\t\treturn FALSE;\n\t    }\n\n\t    // If visual was active, yank the highlighted text and put it\n\t    // before the mouse pointer position.\n\t    // In Select mode replace the highlighted text with the clipboard.\n\t    if (VIsual_active)\n\t    {\n\t\tif (VIsual_select)\n\t\t{\n\t\t    stuffcharReadbuff(Ctrl_G);\n\t\t    stuffReadbuff((char_u *)\"\\\"+p\");\n\t\t}\n\t\telse\n\t\t{\n\t\t    stuffcharReadbuff('y');\n\t\t    stuffcharReadbuff(K_MIDDLEMOUSE);\n\t\t}\n\t\tdo_always = TRUE;\t// ignore 'mouse' setting next time\n\t\treturn FALSE;\n\t    }\n\t    // The rest is below jump_to_mouse()\n\t}\n\n\telse if ((State & MODE_INSERT) == 0)\n\t    return FALSE;\n\n\t// Middle click in insert mode doesn't move the mouse, just insert the\n\t// contents of a register.  '.' register is special, can't insert that\n\t// with do_put().\n\t// Also paste at the cursor if the current mode isn't in 'mouse' (only\n\t// happens for the GUI).\n\tif ((State & MODE_INSERT) || !mouse_has(MOUSE_NORMAL))\n\t{\n\t    if (regname == '.')\n\t\tinsert_reg(regname, TRUE);\n\t    else\n\t    {\n#ifdef FEAT_CLIPBOARD\n\t\tif (clip_star.available && regname == 0)\n\t\t    regname = '*';\n#endif\n\t\tif ((State & REPLACE_FLAG) && !yank_register_mline(regname))\n\t\t    insert_reg(regname, TRUE);\n\t\telse\n\t\t{\n\t\t    do_put(regname, NULL, BACKWARD, 1L,\n\t\t\t\t\t\t      fixindent | PUT_CURSEND);\n\n\t\t    // Repeat it with CTRL-R CTRL-O r or CTRL-R CTRL-P r\n\t\t    AppendCharToRedobuff(Ctrl_R);\n\t\t    AppendCharToRedobuff(fixindent ? Ctrl_P : Ctrl_O);\n\t\t    AppendCharToRedobuff(regname == 0 ? '\"' : regname);\n\t\t}\n\t    }\n\t    return FALSE;\n\t}\n    }\n\n    // When dragging or button-up stay in the same window.\n    if (!is_click)\n\tjump_flags |= MOUSE_FOCUS | MOUSE_DID_MOVE;\n\n    start_visual.lnum = 0;\n\n    // Check for clicking in the tab page line.\n    if (mouse_row == 0 && firstwin->w_winrow > 0)\n    {\n\tif (is_drag)\n\t{\n\t    if (in_tab_line)\n\t    {\n\t\tc1 = TabPageIdxs[mouse_col];\n\t\ttabpage_move(c1 <= 0 ? 9999 : c1 < tabpage_index(curtab)\n\t\t\t\t\t\t\t\t? c1 - 1 : c1);\n\t    }\n\t    return FALSE;\n\t}\n\n\t// click in a tab selects that tab page\n\tif (is_click\n# ifdef FEAT_CMDWIN\n\t\t&& cmdwin_type == 0\n# endif\n\t\t&& mouse_col < Columns)\n\t{\n\t    in_tab_line = TRUE;\n\t    c1 = TabPageIdxs[mouse_col];\n\t    if (c1 >= 0)\n\t    {\n\t\tif ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t\t{\n\t\t    // double click opens new page\n\t\t    end_visual_mode_keep_button();\n\t\t    tabpage_new();\n\t\t    tabpage_move(c1 == 0 ? 9999 : c1 - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Go to specified tab page, or next one if not clicking\n\t\t    // on a label.\n\t\t    goto_tabpage(c1);\n\n\t\t    // It's like clicking on the status line of a window.\n\t\t    if (curwin != old_curwin)\n\t\t\tend_visual_mode_keep_button();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ttabpage_T\t*tp;\n\n\t\t// Close the current or specified tab page.\n\t\tif (c1 == -999)\n\t\t    tp = curtab;\n\t\telse\n\t\t    tp = find_tabpage(-c1);\n\t\tif (tp == curtab)\n\t\t{\n\t\t    if (first_tabpage->tp_next != NULL)\n\t\t\ttabpage_close(FALSE);\n\t\t}\n\t\telse if (tp != NULL)\n\t\t    tabpage_close_other(tp, FALSE);\n\t    }\n\t}\n\treturn TRUE;\n    }\n    else if (is_drag && in_tab_line)\n    {\n\tc1 = TabPageIdxs[mouse_col];\n\ttabpage_move(c1 <= 0 ? 9999 : c1 - 1);\n\treturn FALSE;\n    }\n\n    // When 'mousemodel' is \"popup\" or \"popup_setpos\", translate mouse events:\n    // right button up   -> pop-up menu\n    // shift-left button -> right button\n    // alt-left button   -> alt-right button\n    if (mouse_model_popup())\n    {\n\tif (which_button == MOUSE_RIGHT\n\t\t\t    && !(mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)))\n\t{\n#ifdef USE_POPUP_SETPOS\n# ifdef FEAT_GUI\n\t    if (gui.in_use)\n\t    {\n#  if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) \\\n\t\t\t  || defined(FEAT_GUI_PHOTON)\n\t\tif (!is_click)\n\t\t    // Ignore right button release events, only shows the popup\n\t\t    // menu on the button down event.\n\t\t    return FALSE;\n#  endif\n#  if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_HAIKU)\n\t\tif (is_click || is_drag)\n\t\t    // Ignore right button down and drag mouse events.  Windows\n\t\t    // only shows the popup menu on the button up event.\n\t\t    return FALSE;\n#  endif\n\t    }\n# endif\n# if defined(FEAT_GUI) && defined(FEAT_TERM_POPUP_MENU)\n\t    else\n# endif\n# if defined(FEAT_TERM_POPUP_MENU)\n\t    if (!is_click)\n\t\t// Ignore right button release events, only shows the popup\n\t\t// menu on the button down event.\n\t\treturn FALSE;\n#endif\n\n\t    jump_flags = 0;\n\t    if (STRCMP(p_mousem, \"popup_setpos\") == 0)\n\t    {\n\t\t// First set the cursor position before showing the popup\n\t\t// menu.\n\t\tif (VIsual_active)\n\t\t{\n\t\t    pos_T    m_pos;\n\n\t\t    // set MOUSE_MAY_STOP_VIS if we are outside the\n\t\t    // selection or the current window (might have false\n\t\t    // negative here)\n\t\t    if (mouse_row < curwin->w_winrow\n\t\t\t || mouse_row\n\t\t\t\t  > (curwin->w_winrow + curwin->w_height))\n\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\t\t    else if (get_fpos_of_mouse(&m_pos) != IN_BUFFER)\n\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\t\t    else\n\t\t    {\n\t\t\tif ((LT_POS(curwin->w_cursor, VIsual)\n\t\t\t\t    && (LT_POS(m_pos, curwin->w_cursor)\n\t\t\t\t\t|| LT_POS(VIsual, m_pos)))\n\t\t\t\t|| (LT_POS(VIsual, curwin->w_cursor)\n\t\t\t\t    && (LT_POS(m_pos, VIsual)\n\t\t\t\t      || LT_POS(curwin->w_cursor, m_pos))))\n\t\t\t{\n\t\t\t    jump_flags = MOUSE_MAY_STOP_VIS;\n\t\t\t}\n\t\t\telse if (VIsual_mode == Ctrl_V)\n\t\t\t{\n\t\t\t    getvcols(curwin, &curwin->w_cursor, &VIsual,\n\t\t\t\t\t\t     &leftcol, &rightcol);\n\t\t\t    getvcol(curwin, &m_pos, NULL, &m_pos.col, NULL);\n\t\t\t    if (m_pos.col < leftcol || m_pos.col > rightcol)\n\t\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    jump_flags = MOUSE_MAY_STOP_VIS;\n\t    }\n\t    if (jump_flags)\n\t    {\n\t\tjump_flags = jump_to_mouse(jump_flags, NULL, which_button);\n\t\tupdate_curbuf(VIsual_active ? UPD_INVERTED : UPD_VALID);\n\t\tsetcursor();\n\t\tout_flush();    // Update before showing popup menu\n\t    }\n# ifdef FEAT_MENU\n\t    show_popupmenu();\n\t    got_click = FALSE;\t// ignore release events\n# endif\n\t    return (jump_flags & CURSOR_MOVED) != 0;\n#else\n\t    return FALSE;\n#endif\n\t}\n\tif (which_button == MOUSE_LEFT\n\t\t\t\t&& (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT)))\n\t{\n\t    which_button = MOUSE_RIGHT;\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n    if ((State & (MODE_NORMAL | MODE_INSERT))\n\t\t\t    && !(mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)))\n    {\n\tif (which_button == MOUSE_LEFT)\n\t{\n\t    if (is_click)\n\t    {\n\t\t// stop Visual mode for a left click in a window, but not when\n\t\t// on a status line\n\t\tif (VIsual_active)\n\t\t    jump_flags |= MOUSE_MAY_STOP_VIS;\n\t    }\n\t    else if (mouse_has(MOUSE_VISUAL))\n\t\tjump_flags |= MOUSE_MAY_VIS;\n\t}\n\telse if (which_button == MOUSE_RIGHT)\n\t{\n\t    if (is_click && VIsual_active)\n\t    {\n\t\t// Remember the start and end of visual before moving the\n\t\t// cursor.\n\t\tif (LT_POS(curwin->w_cursor, VIsual))\n\t\t{\n\t\t    start_visual = curwin->w_cursor;\n\t\t    end_visual = VIsual;\n\t\t}\n\t\telse\n\t\t{\n\t\t    start_visual = VIsual;\n\t\t    end_visual = curwin->w_cursor;\n\t\t}\n\t    }\n\t    jump_flags |= MOUSE_FOCUS;\n\t    if (mouse_has(MOUSE_VISUAL))\n\t\tjump_flags |= MOUSE_MAY_VIS;\n\t}\n    }\n\n    // If an operator is pending, ignore all drags and releases until the\n    // next mouse click.\n    if (!is_drag && oap != NULL && oap->op_type != OP_NOP)\n    {\n\tgot_click = FALSE;\n\toap->motion_type = MCHAR;\n    }\n\n    // When releasing the button let jump_to_mouse() know.\n    if (!is_click && !is_drag)\n\tjump_flags |= MOUSE_RELEASED;\n\n    // JUMP!\n    jump_flags = jump_to_mouse(jump_flags,\n\t\t\toap == NULL ? NULL : &(oap->inclusive), which_button);\n\n#ifdef FEAT_MENU\n    // A click in the window toolbar has no side effects.\n    if (jump_flags & MOUSE_WINBAR)\n\treturn FALSE;\n#endif\n    moved = (jump_flags & CURSOR_MOVED);\n    in_status_line = (jump_flags & IN_STATUS_LINE);\n    in_sep_line = (jump_flags & IN_SEP_LINE);\n\n#ifdef FEAT_NETBEANS_INTG\n    if (isNetbeansBuffer(curbuf)\n\t\t\t    && !(jump_flags & (IN_STATUS_LINE | IN_SEP_LINE)))\n    {\n\tint key = KEY2TERMCAP1(c);\n\n\tif (key == (int)KE_LEFTRELEASE || key == (int)KE_MIDDLERELEASE\n\t\t\t\t\t       || key == (int)KE_RIGHTRELEASE)\n\t    netbeans_button_release(which_button);\n    }\n#endif\n\n    // When jumping to another window, clear a pending operator.  That's a bit\n    // friendlier than beeping and not jumping to that window.\n    if (curwin != old_curwin && oap != NULL && oap->op_type != OP_NOP)\n\tclearop(oap);\n\n#ifdef FEAT_FOLDING\n    if (mod_mask == 0\n\t    && !is_drag\n\t    && (jump_flags & (MOUSE_FOLD_CLOSE | MOUSE_FOLD_OPEN))\n\t    && which_button == MOUSE_LEFT)\n    {\n\t// open or close a fold at this line\n\tif (jump_flags & MOUSE_FOLD_OPEN)\n\t    openFold(curwin->w_cursor.lnum, 1L);\n\telse\n\t    closeFold(curwin->w_cursor.lnum, 1L);\n\t// don't move the cursor if still in the same window\n\tif (curwin == old_curwin)\n\t    curwin->w_cursor = save_cursor;\n    }\n#endif\n\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_CMDWIN)\n    if ((jump_flags & IN_OTHER_WIN) && !VIsual_active && clip_star.available)\n    {\n\tclip_modeless(which_button, is_click, is_drag);\n\treturn FALSE;\n    }\n#endif\n\n    // Set global flag that we are extending the Visual area with mouse\n    // dragging; temporarily minimize 'scrolloff'.\n    if (VIsual_active && is_drag && get_scrolloff_value())\n    {\n\t// In the very first line, allow scrolling one line\n\tif (mouse_row == 0)\n\t    mouse_dragging = 2;\n\telse\n\t    mouse_dragging = 1;\n    }\n\n    // When dragging the mouse above the window, scroll down.\n    if (is_drag && mouse_row < 0 && !in_status_line)\n    {\n\tscroll_redraw(FALSE, 1L);\n\tmouse_row = 0;\n    }\n\n    if (start_visual.lnum)\t\t// right click in visual mode\n    {\n       // When ALT is pressed make Visual mode blockwise.\n       if (mod_mask & MOD_MASK_ALT)\n\t   VIsual_mode = Ctrl_V;\n\n\t// In Visual-block mode, divide the area in four, pick up the corner\n\t// that is in the quarter that the cursor is in.\n\tif (VIsual_mode == Ctrl_V)\n\t{\n\t    getvcols(curwin, &start_visual, &end_visual, &leftcol, &rightcol);\n\t    if (curwin->w_curswant > (leftcol + rightcol) / 2)\n\t\tend_visual.col = leftcol;\n\t    else\n\t\tend_visual.col = rightcol;\n\t    if (curwin->w_cursor.lnum >=\n\t\t\t\t    (start_visual.lnum + end_visual.lnum) / 2)\n\t\tend_visual.lnum = start_visual.lnum;\n\n\t    // move VIsual to the right column\n\t    start_visual = curwin->w_cursor;\t    // save the cursor pos\n\t    curwin->w_cursor = end_visual;\n\t    coladvance(end_visual.col);\n\t    VIsual = curwin->w_cursor;\n\t    curwin->w_cursor = start_visual;\t    // restore the cursor\n\t}\n\telse\n\t{\n\t    // If the click is before the start of visual, change the start.\n\t    // If the click is after the end of visual, change the end.  If\n\t    // the click is inside the visual, change the closest side.\n\t    if (LT_POS(curwin->w_cursor, start_visual))\n\t\tVIsual = end_visual;\n\t    else if (LT_POS(end_visual, curwin->w_cursor))\n\t\tVIsual = start_visual;\n\t    else\n\t    {\n\t\t// In the same line, compare column number\n\t\tif (end_visual.lnum == start_visual.lnum)\n\t\t{\n\t\t    if (curwin->w_cursor.col - start_visual.col >\n\t\t\t\t    end_visual.col - curwin->w_cursor.col)\n\t\t\tVIsual = start_visual;\n\t\t    else\n\t\t\tVIsual = end_visual;\n\t\t}\n\n\t\t// In different lines, compare line number\n\t\telse\n\t\t{\n\t\t    diff = (curwin->w_cursor.lnum - start_visual.lnum) -\n\t\t\t\t(end_visual.lnum - curwin->w_cursor.lnum);\n\n\t\t    if (diff > 0)\t\t// closest to end\n\t\t\tVIsual = start_visual;\n\t\t    else if (diff < 0)\t// closest to start\n\t\t\tVIsual = end_visual;\n\t\t    else\t\t\t// in the middle line\n\t\t    {\n\t\t\tif (curwin->w_cursor.col <\n\t\t\t\t\t(start_visual.col + end_visual.col) / 2)\n\t\t\t    VIsual = end_visual;\n\t\t\telse\n\t\t\t    VIsual = start_visual;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    // If Visual mode started in insert mode, execute \"CTRL-O\"\n    else if ((State & MODE_INSERT) && VIsual_active)\n\tstuffcharReadbuff(Ctrl_O);\n\n    // Middle mouse click: Put text before cursor.\n    if (which_button == MOUSE_MIDDLE)\n    {\n#ifdef FEAT_CLIPBOARD\n\tif (clip_star.available && regname == 0)\n\t    regname = '*';\n#endif\n\tif (yank_register_mline(regname))\n\t{\n\t    if (mouse_past_bottom)\n\t\tdir = FORWARD;\n\t}\n\telse if (mouse_past_eol)\n\t    dir = FORWARD;\n\n\tif (fixindent)\n\t{\n\t    c1 = (dir == BACKWARD) ? '[' : ']';\n\t    c2 = 'p';\n\t}\n\telse\n\t{\n\t    c1 = (dir == FORWARD) ? 'p' : 'P';\n\t    c2 = NUL;\n\t}\n\tprep_redo(regname, count, NUL, c1, NUL, c2, NUL);\n\n\t// Remember where the paste started, so in edit() Insstart can be set\n\t// to this position\n\tif (restart_edit != 0)\n\t    where_paste_started = curwin->w_cursor;\n\tdo_put(regname, NULL, dir, count, fixindent | PUT_CURSEND);\n    }\n\n#if defined(FEAT_QUICKFIX)\n    // Ctrl-Mouse click or double click in a quickfix window jumps to the\n    // error under the mouse pointer.\n    else if (((mod_mask & MOD_MASK_CTRL)\n\t\t|| (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t    && bt_quickfix(curbuf))\n    {\n\tif (curwin->w_llist_ref == NULL)\t// quickfix window\n\t    do_cmdline_cmd((char_u *)\".cc\");\n\telse\t\t\t\t\t// location list window\n\t    do_cmdline_cmd((char_u *)\".ll\");\n\tgot_click = FALSE;\t\t// ignore drag&release now\n    }\n#endif\n\n    // Ctrl-Mouse click (or double click in a help window) jumps to the tag\n    // under the mouse pointer.\n    else if ((mod_mask & MOD_MASK_CTRL) || (curbuf->b_help\n\t\t     && (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK))\n    {\n\tif (State & MODE_INSERT)\n\t    stuffcharReadbuff(Ctrl_O);\n\tstuffcharReadbuff(Ctrl_RSB);\n\tgot_click = FALSE;\t\t// ignore drag&release now\n    }\n\n    // Shift-Mouse click searches for the next occurrence of the word under\n    // the mouse pointer\n    else if ((mod_mask & MOD_MASK_SHIFT))\n    {\n\tif ((State & MODE_INSERT) || (VIsual_active && VIsual_select))\n\t    stuffcharReadbuff(Ctrl_O);\n\tif (which_button == MOUSE_LEFT)\n\t    stuffcharReadbuff('*');\n\telse\t// MOUSE_RIGHT\n\t    stuffcharReadbuff('#');\n    }\n\n    // Handle double clicks, unless on status line\n    else if (in_status_line)\n    {\n#ifdef FEAT_MOUSESHAPE\n\tif ((is_drag || is_click) && !drag_status_line)\n\t{\n\t    drag_status_line = TRUE;\n\t    update_mouseshape(-1);\n\t}\n#endif\n    }\n    else if (in_sep_line)\n    {\n#ifdef FEAT_MOUSESHAPE\n\tif ((is_drag || is_click) && !drag_sep_line)\n\t{\n\t    drag_sep_line = TRUE;\n\t    update_mouseshape(-1);\n\t}\n#endif\n    }\n    else if ((mod_mask & MOD_MASK_MULTI_CLICK)\n\t\t\t\t       && (State & (MODE_NORMAL | MODE_INSERT))\n\t     && mouse_has(MOUSE_VISUAL))\n    {\n\tif (is_click || !VIsual_active)\n\t{\n\t    if (VIsual_active)\n\t\torig_cursor = VIsual;\n\t    else\n\t    {\n\t\tcheck_visual_highlight();\n\t\tVIsual = curwin->w_cursor;\n\t\torig_cursor = VIsual;\n\t\tVIsual_active = TRUE;\n\t\tVIsual_reselect = TRUE;\n\t\t// start Select mode if 'selectmode' contains \"mouse\"\n\t\tmay_start_select('o');\n\t\tsetmouse();\n\t    }\n\t    if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t    {\n\t\t// Double click with ALT pressed makes it blockwise.\n\t\tif (mod_mask & MOD_MASK_ALT)\n\t\t    VIsual_mode = Ctrl_V;\n\t\telse\n\t\t    VIsual_mode = 'v';\n\t    }\n\t    else if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_3CLICK)\n\t\tVIsual_mode = 'V';\n\t    else if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_4CLICK)\n\t\tVIsual_mode = Ctrl_V;\n#ifdef FEAT_CLIPBOARD\n\t    // Make sure the clipboard gets updated.  Needed because start and\n\t    // end may still be the same, and the selection needs to be owned\n\t    clip_star.vmode = NUL;\n#endif\n\t}\n\t// A double click selects a word or a block.\n\tif ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t{\n\t    pos_T\t*pos = NULL;\n\t    int\t\tgc;\n\n\t    if (is_click)\n\t    {\n\t\t// If the character under the cursor (skipping white space) is\n\t\t// not a word character, try finding a match and select a (),\n\t\t// {}, [], #if/#endif, etc. block.\n\t\tend_visual = curwin->w_cursor;\n\t\twhile (gc = gchar_pos(&end_visual), VIM_ISWHITE(gc))\n\t\t    inc(&end_visual);\n\t\tif (oap != NULL)\n\t\t    oap->motion_type = MCHAR;\n\t\tif (oap != NULL\n\t\t\t&& VIsual_mode == 'v'\n\t\t\t&& !vim_iswordc(gchar_pos(&end_visual))\n\t\t\t&& EQUAL_POS(curwin->w_cursor, VIsual)\n\t\t\t&& (pos = findmatch(oap, NUL)) != NULL)\n\t\t{\n\t\t    curwin->w_cursor = *pos;\n\t\t    if (oap->motion_type == MLINE)\n\t\t\tVIsual_mode = 'V';\n\t\t    else if (*p_sel == 'e')\n\t\t    {\n\t\t\tif (LT_POS(curwin->w_cursor, VIsual))\n\t\t\t    ++VIsual.col;\n\t\t\telse\n\t\t\t    ++curwin->w_cursor.col;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (pos == NULL && (is_click || is_drag))\n\t    {\n\t\t// When not found a match or when dragging: extend to include\n\t\t// a word.\n\t\tif (LT_POS(curwin->w_cursor, orig_cursor))\n\t\t{\n\t\t    find_start_of_word(&curwin->w_cursor);\n\t\t    find_end_of_word(&VIsual);\n\t\t}\n\t\telse\n\t\t{\n\t\t    find_start_of_word(&VIsual);\n\t\t    if (*p_sel == 'e' && *ml_get_cursor() != NUL)\n\t\t\tcurwin->w_cursor.col +=\n\t\t\t\t\t (*mb_ptr2len)(ml_get_cursor());\n\t\t    find_end_of_word(&curwin->w_cursor);\n\t\t}\n\t    }\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\tif (is_click)\n\t    redraw_curbuf_later(UPD_INVERTED);\t// update the inversion\n    }\n    else if (VIsual_active && !old_active)\n    {\n\tif (mod_mask & MOD_MASK_ALT)\n\t    VIsual_mode = Ctrl_V;\n\telse\n\t    VIsual_mode = 'v';\n    }\n\n    // If Visual mode changed show it later.\n    if ((!VIsual_active && old_active && mode_displayed)\n\t    || (VIsual_active && p_smd && msg_silent == 0\n\t\t\t\t && (!old_active || VIsual_mode != old_mode)))\n\tredraw_cmdline = TRUE;\n\n    return moved;\n}\n\n    void\nins_mouse(int c)\n{\n    pos_T\ttpos;\n    win_T\t*old_curwin = curwin;\n\n# ifdef FEAT_GUI\n    // When GUI is active, also move/paste when 'mouse' is empty\n    if (!gui.in_use)\n# endif\n\tif (!mouse_has(MOUSE_INSERT))\n\t    return;\n\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (do_mouse(NULL, c, BACKWARD, 1L, 0))\n    {\n\twin_T\t*new_curwin = curwin;\n\n\tif (curwin != old_curwin && win_valid(old_curwin))\n\t{\n\t    // Mouse took us to another window.  We need to go back to the\n\t    // previous one to stop insert there properly.\n\t    curwin = old_curwin;\n\t    curbuf = curwin->w_buffer;\n#ifdef FEAT_JOB_CHANNEL\n\t    if (bt_prompt(curbuf))\n\t\t// Restart Insert mode when re-entering the prompt buffer.\n\t\tcurbuf->b_prompt_insert = 'A';\n#endif\n\t}\n\tstart_arrow(curwin == old_curwin ? &tpos : NULL);\n\tif (curwin != new_curwin && win_valid(new_curwin))\n\t{\n\t    curwin = new_curwin;\n\t    curbuf = curwin->w_buffer;\n\t}\n\tset_can_cindent(TRUE);\n    }\n\n    // redraw status lines (in case another window became active)\n    redraw_statuslines();\n}\n\n    void\nins_mousescroll(int dir)\n{\n    pos_T\ttpos;\n    win_T\t*old_curwin = curwin, *wp;\n    int\t\tdid_scroll = FALSE;\n\n    tpos = curwin->w_cursor;\n\n    if (mouse_row >= 0 && mouse_col >= 0)\n    {\n\tint row, col;\n\n\trow = mouse_row;\n\tcol = mouse_col;\n\n\t// find the window at the pointer coordinates\n\twp = mouse_find_win(&row, &col, FIND_POPUP);\n\tif (wp == NULL)\n\t    return;\n\tcurwin = wp;\n\tcurbuf = curwin->w_buffer;\n    }\n    if (curwin == old_curwin)\n\tundisplay_dollar();\n\n    // Don't scroll the window in which completion is being done.\n    if (!pum_visible() || curwin != old_curwin)\n    {\n\tlong step;\n\n\tif (dir == MSCR_DOWN || dir == MSCR_UP)\n\t{\n\t    if (mouse_vert_step < 0\n\t\t    || mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n\t\tstep = (long)(curwin->w_botline - curwin->w_topline);\n\t    else\n\t\tstep = mouse_vert_step;\n\t    scroll_redraw(dir, step);\n# ifdef FEAT_PROP_POPUP\n\tif (WIN_IS_POPUP(curwin))\n\t    popup_set_firstline(curwin);\n# endif\n\t}\n#ifdef FEAT_GUI\n\telse\n\t{\n\t    int val;\n\n\t    if (mouse_hor_step < 0\n\t\t    || mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n\t\tstep = curwin->w_width;\n\t    else\n\t\tstep = mouse_hor_step;\n\t    val = curwin->w_leftcol + (dir == MSCR_RIGHT ? -step : step);\n\t    if (val < 0)\n\t\tval = 0;\n\t    gui_do_horiz_scroll(val, TRUE);\n\t}\n#endif\n\tdid_scroll = TRUE;\n\tmay_trigger_winscrolled();\n    }\n\n    curwin->w_redr_status = TRUE;\n\n    curwin = old_curwin;\n    curbuf = curwin->w_buffer;\n\n    // The popup menu may overlay the window, need to redraw it.\n    // TODO: Would be more efficient to only redraw the windows that are\n    // overlapped by the popup menu.\n    if (pum_visible() && did_scroll)\n    {\n\tredraw_all_later(UPD_NOT_VALID);\n\tins_compl_show_pum();\n    }\n\n    if (!EQUAL_POS(curwin->w_cursor, tpos))\n    {\n\tstart_arrow(&tpos);\n\tset_can_cindent(TRUE);\n    }\n}\n\n/*\n * Return TRUE if \"c\" is a mouse key.\n */\n    int\nis_mouse_key(int c)\n{\n    return c == K_LEFTMOUSE\n\t|| c == K_LEFTMOUSE_NM\n\t|| c == K_LEFTDRAG\n\t|| c == K_LEFTRELEASE\n\t|| c == K_LEFTRELEASE_NM\n\t|| c == K_MOUSEMOVE\n\t|| c == K_MIDDLEMOUSE\n\t|| c == K_MIDDLEDRAG\n\t|| c == K_MIDDLERELEASE\n\t|| c == K_RIGHTMOUSE\n\t|| c == K_RIGHTDRAG\n\t|| c == K_RIGHTRELEASE\n\t|| c == K_MOUSEDOWN\n\t|| c == K_MOUSEUP\n\t|| c == K_MOUSELEFT\n\t|| c == K_MOUSERIGHT\n\t|| c == K_X1MOUSE\n\t|| c == K_X1DRAG\n\t|| c == K_X1RELEASE\n\t|| c == K_X2MOUSE\n\t|| c == K_X2DRAG\n\t|| c == K_X2RELEASE;\n}\n\nstatic struct mousetable\n{\n    int\t    pseudo_code;\t// Code for pseudo mouse event\n    int\t    button;\t\t// Which mouse button is it?\n    int\t    is_click;\t\t// Is it a mouse button click event?\n    int\t    is_drag;\t\t// Is it a mouse drag event?\n} mouse_table[] =\n{\n    {(int)KE_LEFTMOUSE,\t\tMOUSE_LEFT,\tTRUE,\tFALSE},\n#ifdef FEAT_GUI\n    {(int)KE_LEFTMOUSE_NM,\tMOUSE_LEFT,\tTRUE,\tFALSE},\n#endif\n    {(int)KE_LEFTDRAG,\t\tMOUSE_LEFT,\tFALSE,\tTRUE},\n    {(int)KE_LEFTRELEASE,\tMOUSE_LEFT,\tFALSE,\tFALSE},\n#ifdef FEAT_GUI\n    {(int)KE_LEFTRELEASE_NM,\tMOUSE_LEFT,\tFALSE,\tFALSE},\n#endif\n    {(int)KE_MIDDLEMOUSE,\tMOUSE_MIDDLE,\tTRUE,\tFALSE},\n    {(int)KE_MIDDLEDRAG,\tMOUSE_MIDDLE,\tFALSE,\tTRUE},\n    {(int)KE_MIDDLERELEASE,\tMOUSE_MIDDLE,\tFALSE,\tFALSE},\n    {(int)KE_RIGHTMOUSE,\tMOUSE_RIGHT,\tTRUE,\tFALSE},\n    {(int)KE_RIGHTDRAG,\t\tMOUSE_RIGHT,\tFALSE,\tTRUE},\n    {(int)KE_RIGHTRELEASE,\tMOUSE_RIGHT,\tFALSE,\tFALSE},\n    {(int)KE_X1MOUSE,\t\tMOUSE_X1,\tTRUE,\tFALSE},\n    {(int)KE_X1DRAG,\t\tMOUSE_X1,\tFALSE,\tTRUE},\n    {(int)KE_X1RELEASE,\t\tMOUSE_X1,\tFALSE,\tFALSE},\n    {(int)KE_X2MOUSE,\t\tMOUSE_X2,\tTRUE,\tFALSE},\n    {(int)KE_X2DRAG,\t\tMOUSE_X2,\tFALSE,\tTRUE},\n    {(int)KE_X2RELEASE,\t\tMOUSE_X2,\tFALSE,\tFALSE},\n    // DRAG without CLICK\n    {(int)KE_MOUSEMOVE,\t\tMOUSE_RELEASE,\tFALSE,\tTRUE},\n    // RELEASE without CLICK\n    {(int)KE_IGNORE,\t\tMOUSE_RELEASE,\tFALSE,\tFALSE},\n    {0,\t\t\t\t0,\t\t0,\t0},\n};\n\n/*\n * Look up the given mouse code to return the relevant information in the other\n * arguments.  Return which button is down or was released.\n */\n    int\nget_mouse_button(int code, int *is_click, int *is_drag)\n{\n    int\t    i;\n\n    for (i = 0; mouse_table[i].pseudo_code; i++)\n\tif (code == mouse_table[i].pseudo_code)\n\t{\n\t    *is_click = mouse_table[i].is_click;\n\t    *is_drag = mouse_table[i].is_drag;\n\t    return mouse_table[i].button;\n\t}\n    return 0;\t    // Shouldn't get here\n}\n\n/*\n * Return the appropriate pseudo mouse event token (KE_LEFTMOUSE etc) based on\n * the given information about which mouse button is down, and whether the\n * mouse was clicked, dragged or released.\n */\n    int\nget_pseudo_mouse_code(\n    int\t    button,\t// eg MOUSE_LEFT\n    int\t    is_click,\n    int\t    is_drag)\n{\n    int\t    i;\n\n    for (i = 0; mouse_table[i].pseudo_code; i++)\n\tif (button == mouse_table[i].button\n\t    && is_click == mouse_table[i].is_click\n\t    && is_drag == mouse_table[i].is_drag)\n\t{\n#ifdef FEAT_GUI\n\t    // Trick: a non mappable left click and release has mouse_col -1\n\t    // or added MOUSE_COLOFF.  Used for 'mousefocus' in\n\t    // gui_mouse_moved()\n\t    if (mouse_col < 0 || mouse_col > MOUSE_COLOFF)\n\t    {\n\t\tif (mouse_col < 0)\n\t\t    mouse_col = 0;\n\t\telse\n\t\t    mouse_col -= MOUSE_COLOFF;\n\t\tif (mouse_table[i].pseudo_code == (int)KE_LEFTMOUSE)\n\t\t    return (int)KE_LEFTMOUSE_NM;\n\t\tif (mouse_table[i].pseudo_code == (int)KE_LEFTRELEASE)\n\t\t    return (int)KE_LEFTRELEASE_NM;\n\t    }\n#endif\n\t    return mouse_table[i].pseudo_code;\n\t}\n    return (int)KE_IGNORE;\t    // not recognized, ignore it\n}\n\n# define HMT_NORMAL\t1\n# define HMT_NETTERM\t2\n# define HMT_DEC\t4\n# define HMT_JSBTERM\t8\n# define HMT_PTERM\t16\n# define HMT_URXVT\t32\n# define HMT_GPM\t64\n# define HMT_SGR\t128\n# define HMT_SGR_REL\t256\nstatic int has_mouse_termcode = 0;\n\n    void\nset_mouse_termcode(\n    int\t\tn,\t// KS_MOUSE, KS_NETTERM_MOUSE or KS_DEC_MOUSE\n    char_u\t*s)\n{\n    char_u\tname[2];\n\n    name[0] = n;\n    name[1] = KE_FILLER;\n    add_termcode(name, s, FALSE);\n#   ifdef FEAT_MOUSE_JSB\n    if (n == KS_JSBTERM_MOUSE)\n\thas_mouse_termcode |= HMT_JSBTERM;\n    else\n#   endif\n#   ifdef FEAT_MOUSE_NET\n    if (n == KS_NETTERM_MOUSE)\n\thas_mouse_termcode |= HMT_NETTERM;\n    else\n#   endif\n#   ifdef FEAT_MOUSE_DEC\n    if (n == KS_DEC_MOUSE)\n\thas_mouse_termcode |= HMT_DEC;\n    else\n#   endif\n#   ifdef FEAT_MOUSE_PTERM\n    if (n == KS_PTERM_MOUSE)\n\thas_mouse_termcode |= HMT_PTERM;\n    else\n#   endif\n#   ifdef FEAT_MOUSE_URXVT\n    if (n == KS_URXVT_MOUSE)\n\thas_mouse_termcode |= HMT_URXVT;\n    else\n#   endif\n#   ifdef FEAT_MOUSE_GPM\n    if (n == KS_GPM_MOUSE)\n\thas_mouse_termcode |= HMT_GPM;\n    else\n#   endif\n    if (n == KS_SGR_MOUSE)\n\thas_mouse_termcode |= HMT_SGR;\n    else if (n == KS_SGR_MOUSE_RELEASE)\n\thas_mouse_termcode |= HMT_SGR_REL;\n    else\n\thas_mouse_termcode |= HMT_NORMAL;\n}\n\n# if defined(UNIX) || defined(VMS) || defined(PROTO)\n    void\ndel_mouse_termcode(\n    int\t\tn)\t// KS_MOUSE, KS_NETTERM_MOUSE or KS_DEC_MOUSE\n{\n    char_u\tname[2];\n\n    name[0] = n;\n    name[1] = KE_FILLER;\n    del_termcode(name);\n#   ifdef FEAT_MOUSE_JSB\n    if (n == KS_JSBTERM_MOUSE)\n\thas_mouse_termcode &= ~HMT_JSBTERM;\n    else\n#   endif\n#   ifdef FEAT_MOUSE_NET\n    if (n == KS_NETTERM_MOUSE)\n\thas_mouse_termcode &= ~HMT_NETTERM;\n    else\n#   endif\n#   ifdef FEAT_MOUSE_DEC\n    if (n == KS_DEC_MOUSE)\n\thas_mouse_termcode &= ~HMT_DEC;\n    else\n#   endif\n#   ifdef FEAT_MOUSE_PTERM\n    if (n == KS_PTERM_MOUSE)\n\thas_mouse_termcode &= ~HMT_PTERM;\n    else\n#   endif\n#   ifdef FEAT_MOUSE_URXVT\n    if (n == KS_URXVT_MOUSE)\n\thas_mouse_termcode &= ~HMT_URXVT;\n    else\n#   endif\n#   ifdef FEAT_MOUSE_GPM\n    if (n == KS_GPM_MOUSE)\n\thas_mouse_termcode &= ~HMT_GPM;\n    else\n#   endif\n    if (n == KS_SGR_MOUSE)\n\thas_mouse_termcode &= ~HMT_SGR;\n    else if (n == KS_SGR_MOUSE_RELEASE)\n\thas_mouse_termcode &= ~HMT_SGR_REL;\n    else\n\thas_mouse_termcode &= ~HMT_NORMAL;\n}\n# endif\n\n/*\n * setmouse() - switch mouse on/off depending on current mode and 'mouse'\n */\n    void\nsetmouse(void)\n{\n    int\t    checkfor;\n\n# ifdef FEAT_MOUSESHAPE\n    update_mouseshape(-1);\n# endif\n\n    // Should be outside proc, but may break MOUSESHAPE\n#  ifdef FEAT_GUI\n    // In the GUI the mouse is always enabled.\n    if (gui.in_use)\n\treturn;\n#  endif\n    // be quick when mouse is off\n    if (*p_mouse == NUL || has_mouse_termcode == 0)\n\treturn;\n\n    // don't switch mouse on when not in raw mode (Ex mode)\n    if (cur_tmode != TMODE_RAW)\n    {\n\tmch_setmouse(FALSE);\n\treturn;\n    }\n\n    if (VIsual_active)\n\tcheckfor = MOUSE_VISUAL;\n    else if (State == MODE_HITRETURN || State == MODE_ASKMORE\n\t\t\t\t\t\t     || State == MODE_SETWSIZE)\n\tcheckfor = MOUSE_RETURN;\n    else if (State & MODE_INSERT)\n\tcheckfor = MOUSE_INSERT;\n    else if (State & MODE_CMDLINE)\n\tcheckfor = MOUSE_COMMAND;\n    else if (State == MODE_CONFIRM || State == MODE_EXTERNCMD)\n\tcheckfor = ' '; // don't use mouse for \":confirm\" or \":!cmd\"\n    else\n\tcheckfor = MOUSE_NORMAL;    // assume normal mode\n\n    if (mouse_has(checkfor))\n\tmch_setmouse(TRUE);\n    else\n\tmch_setmouse(FALSE);\n}\n\n/*\n * Return TRUE if\n * - \"c\" is in 'mouse', or\n * - 'a' is in 'mouse' and \"c\" is in MOUSE_A, or\n * - the current buffer is a help file and 'h' is in 'mouse' and we are in a\n *   normal editing mode (not at hit-return message).\n */\n    int\nmouse_has(int c)\n{\n    char_u\t*p;\n\n    for (p = p_mouse; *p; ++p)\n\tswitch (*p)\n\t{\n\t    case 'a': if (vim_strchr((char_u *)MOUSE_A, c) != NULL)\n\t\t\t  return TRUE;\n\t\t      break;\n\t    case MOUSE_HELP: if (c != MOUSE_RETURN && curbuf->b_help)\n\t\t\t\t return TRUE;\n\t\t\t     break;\n\t    default: if (c == *p) return TRUE; break;\n\t}\n    return FALSE;\n}\n\n/*\n * Return TRUE when 'mousemodel' is set to \"popup\" or \"popup_setpos\".\n */\n    int\nmouse_model_popup(void)\n{\n    return (p_mousem[0] == 'p');\n}\n\n/*\n * Move the cursor to the specified row and column on the screen.\n * Change current window if necessary.\tReturns an integer with the\n * CURSOR_MOVED bit set if the cursor has moved or unset otherwise.\n *\n * The MOUSE_FOLD_CLOSE bit is set when clicked on the '-' in a fold column.\n * The MOUSE_FOLD_OPEN bit is set when clicked on the '+' in a fold column.\n *\n * If flags has MOUSE_FOCUS, then the current window will not be changed, and\n * if the mouse is outside the window then the text will scroll, or if the\n * mouse was previously on a status line, then the status line may be dragged.\n *\n * If flags has MOUSE_MAY_VIS, then VIsual mode will be started before the\n * cursor is moved unless the cursor was on a status line.\n * This function returns one of IN_UNKNOWN, IN_BUFFER, IN_STATUS_LINE or\n * IN_SEP_LINE depending on where the cursor was clicked.\n *\n * If flags has MOUSE_MAY_STOP_VIS, then Visual mode will be stopped, unless\n * the mouse is on the status line of the same window.\n *\n * If flags has MOUSE_DID_MOVE, nothing is done if the mouse didn't move since\n * the last call.\n *\n * If flags has MOUSE_SETPOS, nothing is done, only the current position is\n * remembered.\n */\n    int\njump_to_mouse(\n    int\t\tflags,\n    int\t\t*inclusive,\t// used for inclusive operator, can be NULL\n    int\t\twhich_button)\t// MOUSE_LEFT, MOUSE_RIGHT, MOUSE_MIDDLE\n{\n    static int\ton_status_line = 0;\t// #lines below bottom of window\n    static int\ton_sep_line = 0;\t// on separator right of window\n#ifdef FEAT_MENU\n    static int  in_winbar = FALSE;\n#endif\n#ifdef FEAT_PROP_POPUP\n    static int   in_popup_win = FALSE;\n    static win_T *click_in_popup_win = NULL;\n#endif\n    static int\tprev_row = -1;\n    static int\tprev_col = -1;\n    static win_T *dragwin = NULL;\t// window being dragged\n    static int\tdid_drag = FALSE;\t// drag was noticed\n\n    win_T\t*wp, *old_curwin;\n    pos_T\told_cursor;\n    int\t\tcount;\n    int\t\tfirst;\n    int\t\trow = mouse_row;\n    int\t\tcol = mouse_col;\n    colnr_T\tcol_from_screen = -1;\n#ifdef FEAT_FOLDING\n    int\t\tmouse_char = ' ';\n#endif\n\n    mouse_past_bottom = FALSE;\n    mouse_past_eol = FALSE;\n\n    if (flags & MOUSE_RELEASED)\n    {\n\t// On button release we may change window focus if positioned on a\n\t// status line and no dragging happened.\n\tif (dragwin != NULL && !did_drag)\n\t    flags &= ~(MOUSE_FOCUS | MOUSE_DID_MOVE);\n\tdragwin = NULL;\n\tdid_drag = FALSE;\n#ifdef FEAT_PROP_POPUP\n\tif (click_in_popup_win != NULL && popup_dragwin == NULL)\n\t    popup_close_for_mouse_click(click_in_popup_win);\n\n\tpopup_dragwin = NULL;\n\tclick_in_popup_win = NULL;\n#endif\n    }\n\n    if ((flags & MOUSE_DID_MOVE)\n\t    && prev_row == mouse_row\n\t    && prev_col == mouse_col)\n    {\nretnomove:\n\t// before moving the cursor for a left click which is NOT in a status\n\t// line, stop Visual mode\n\tif (on_status_line)\n\t    return IN_STATUS_LINE;\n\tif (on_sep_line)\n\t    return IN_SEP_LINE;\n#ifdef FEAT_MENU\n\tif (in_winbar)\n\t{\n\t    // A quick second click may arrive as a double-click, but we use it\n\t    // as a second click in the WinBar.\n\t    if ((mod_mask & MOD_MASK_MULTI_CLICK) && !(flags & MOUSE_RELEASED))\n\t    {\n\t\twp = mouse_find_win(&row, &col, FAIL_POPUP);\n\t\tif (wp == NULL)\n\t\t    return IN_UNKNOWN;\n\t\twinbar_click(wp, col);\n\t    }\n\t    return IN_OTHER_WIN | MOUSE_WINBAR;\n\t}\n#endif\n\tif (flags & MOUSE_MAY_STOP_VIS)\n\t{\n\t    end_visual_mode_keep_button();\n\t    redraw_curbuf_later(UPD_INVERTED);\t// delete the inversion\n\t}\n#if defined(FEAT_CMDWIN) && defined(FEAT_CLIPBOARD)\n\t// Continue a modeless selection in another window.\n\tif (cmdwin_type != 0 && row < curwin->w_winrow)\n\t    return IN_OTHER_WIN;\n#endif\n#ifdef FEAT_PROP_POPUP\n\t// Continue a modeless selection in a popup window or dragging it.\n\tif (in_popup_win)\n\t{\n\t    click_in_popup_win = NULL;  // don't close it on release\n\t    if (popup_dragwin != NULL)\n\t    {\n\t\t// dragging a popup window\n\t\tpopup_drag(popup_dragwin);\n\t\treturn IN_UNKNOWN;\n\t    }\n\t    return IN_OTHER_WIN;\n\t}\n#endif\n\treturn IN_BUFFER;\n    }\n\n    prev_row = mouse_row;\n    prev_col = mouse_col;\n\n    if (flags & MOUSE_SETPOS)\n\tgoto retnomove;\t\t\t\t// ugly goto...\n\n    old_curwin = curwin;\n    old_cursor = curwin->w_cursor;\n\n    if (!(flags & MOUSE_FOCUS))\n    {\n\tif (row < 0 || col < 0)\t\t\t// check if it makes sense\n\t    return IN_UNKNOWN;\n\n\t// find the window where the row is in and adjust \"row\" and \"col\" to be\n\t// relative to top-left of the window\n\twp = mouse_find_win(&row, &col, FIND_POPUP);\n\tif (wp == NULL)\n\t    return IN_UNKNOWN;\n\tdragwin = NULL;\n\n#ifdef FEAT_PROP_POPUP\n\t// Click in a popup window may start dragging or modeless selection,\n\t// but not much else.\n\tif (WIN_IS_POPUP(wp))\n\t{\n\t    on_sep_line = 0;\n\t    on_status_line = 0;\n\t    in_popup_win = TRUE;\n\t    if (which_button == MOUSE_LEFT && popup_close_if_on_X(wp, row, col))\n\t    {\n\t\treturn IN_UNKNOWN;\n\t    }\n\t    else if (((wp->w_popup_flags & (POPF_DRAG | POPF_RESIZE))\n\t\t\t\t\t      && popup_on_border(wp, row, col))\n\t\t\t\t       || (wp->w_popup_flags & POPF_DRAGALL))\n\t    {\n\t\tpopup_dragwin = wp;\n\t\tpopup_start_drag(wp, row, col);\n\t\treturn IN_UNKNOWN;\n\t    }\n\t    // Only close on release, otherwise it's not possible to drag or do\n\t    // modeless selection.\n\t    else if (wp->w_popup_close == POPCLOSE_CLICK\n\t\t    && which_button == MOUSE_LEFT)\n\t    {\n\t\tclick_in_popup_win = wp;\n\t    }\n\t    else if (which_button == MOUSE_LEFT)\n\t\t// If the click is in the scrollbar, may scroll up/down.\n\t\tpopup_handle_scrollbar_click(wp, row, col);\n# ifdef FEAT_CLIPBOARD\n\t    return IN_OTHER_WIN;\n# else\n\t    return IN_UNKNOWN;\n# endif\n\t}\n\tin_popup_win = FALSE;\n\tpopup_dragwin = NULL;\n#endif\n#ifdef FEAT_MENU\n\tif (row == -1)\n\t{\n\t    // A click in the window toolbar does not enter another window or\n\t    // change Visual highlighting.\n\t    winbar_click(wp, col);\n\t    in_winbar = TRUE;\n\t    return IN_OTHER_WIN | MOUSE_WINBAR;\n\t}\n\tin_winbar = FALSE;\n#endif\n\n\t// winpos and height may change in win_enter()!\n\tif (row >= wp->w_height)\t\t// In (or below) status line\n\t{\n\t    on_status_line = row - wp->w_height + 1;\n\t    dragwin = wp;\n\t}\n\telse\n\t    on_status_line = 0;\n\tif (col >= wp->w_width)\t\t// In separator line\n\t{\n\t    on_sep_line = col - wp->w_width + 1;\n\t    dragwin = wp;\n\t}\n\telse\n\t    on_sep_line = 0;\n\n\t// The rightmost character of the status line might be a vertical\n\t// separator character if there is no connecting window to the right.\n\tif (on_status_line && on_sep_line)\n\t{\n\t    if (stl_connected(wp))\n\t\ton_sep_line = 0;\n\t    else\n\t\ton_status_line = 0;\n\t}\n\n\t// Before jumping to another buffer, or moving the cursor for a left\n\t// click, stop Visual mode.\n\tif (VIsual_active\n\t\t&& (wp->w_buffer != curwin->w_buffer\n\t\t    || (!on_status_line && !on_sep_line\n#ifdef FEAT_FOLDING\n\t\t\t&& (\n# ifdef FEAT_RIGHTLEFT\n\t\t\t    wp->w_p_rl ? col < wp->w_width - wp->w_p_fdc :\n# endif\n\t\t\t    col >= wp->w_p_fdc\n# ifdef FEAT_CMDWIN\n\t\t\t\t  + (cmdwin_type == 0 && wp == curwin ? 0 : 1)\n# endif\n\t\t\t    )\n#endif\n\t\t\t&& (flags & MOUSE_MAY_STOP_VIS))))\n\t{\n\t    end_visual_mode_keep_button();\n\t    redraw_curbuf_later(UPD_INVERTED);\t// delete the inversion\n\t}\n#ifdef FEAT_CMDWIN\n\tif (cmdwin_type != 0 && wp != curwin)\n\t{\n\t    // A click outside the command-line window: Use modeless\n\t    // selection if possible.  Allow dragging the status lines.\n\t    on_sep_line = 0;\n# ifdef FEAT_CLIPBOARD\n\t    if (on_status_line)\n\t\treturn IN_STATUS_LINE;\n\t    return IN_OTHER_WIN;\n# else\n\t    row = 0;\n\t    col += wp->w_wincol;\n\t    wp = curwin;\n# endif\n\t}\n#endif\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_TERMINAL)\n\tif (popup_is_popup(curwin) && curbuf->b_term != NULL)\n\t    // terminal in popup window: don't jump to another window\n\t    return IN_OTHER_WIN;\n#endif\n\t// Only change window focus when not clicking on or dragging the\n\t// status line.  Do change focus when releasing the mouse button\n\t// (MOUSE_FOCUS was set above if we dragged first).\n\tif (dragwin == NULL || (flags & MOUSE_RELEASED))\n\t    win_enter(wp, TRUE);\t\t// can make wp invalid!\n\n\tif (curwin != old_curwin)\n\t{\n#ifdef CHECK_DOUBLE_CLICK\n\t    // set topline, to be able to check for double click ourselves\n\t    set_mouse_topline(curwin);\n#endif\n#ifdef FEAT_TERMINAL\n\t    // when entering a terminal window may change state\n\t    term_win_entered();\n#endif\n\t}\n\tif (on_status_line)\t\t\t// In (or below) status line\n\t{\n\t    // Don't use start_arrow() if we're in the same window\n\t    if (curwin == old_curwin)\n\t\treturn IN_STATUS_LINE;\n\t    else\n\t\treturn IN_STATUS_LINE | CURSOR_MOVED;\n\t}\n\tif (on_sep_line)\t\t\t// In (or below) status line\n\t{\n\t    // Don't use start_arrow() if we're in the same window\n\t    if (curwin == old_curwin)\n\t\treturn IN_SEP_LINE;\n\t    else\n\t\treturn IN_SEP_LINE | CURSOR_MOVED;\n\t}\n\n\tcurwin->w_cursor.lnum = curwin->w_topline;\n#ifdef FEAT_GUI\n\t// remember topline, needed for double click\n\tgui_prev_topline = curwin->w_topline;\n# ifdef FEAT_DIFF\n\tgui_prev_topfill = curwin->w_topfill;\n# endif\n#endif\n    }\n    else if (on_status_line && which_button == MOUSE_LEFT)\n    {\n\tif (dragwin != NULL)\n\t{\n\t    // Drag the status line\n\t    count = row - W_WINROW(dragwin) - dragwin->w_height + 1\n\t\t\t\t\t\t\t     - on_status_line;\n\t    win_drag_status_line(dragwin, count);\n\t    did_drag |= count;\n\t}\n\treturn IN_STATUS_LINE;\t\t\t// Cursor didn't move\n    }\n    else if (on_sep_line && which_button == MOUSE_LEFT)\n    {\n\tif (dragwin != NULL)\n\t{\n\t    // Drag the separator column\n\t    count = col - dragwin->w_wincol - dragwin->w_width + 1\n\t\t\t\t\t\t\t\t- on_sep_line;\n\t    win_drag_vsep_line(dragwin, count);\n\t    did_drag |= count;\n\t}\n\treturn IN_SEP_LINE;\t\t\t// Cursor didn't move\n    }\n#ifdef FEAT_MENU\n    else if (in_winbar)\n    {\n\t// After a click on the window toolbar don't start Visual mode.\n\treturn IN_OTHER_WIN | MOUSE_WINBAR;\n    }\n#endif\n    else // keep_window_focus must be TRUE\n    {\n\t// before moving the cursor for a left click, stop Visual mode\n\tif (flags & MOUSE_MAY_STOP_VIS)\n\t{\n\t    end_visual_mode_keep_button();\n\t    redraw_curbuf_later(UPD_INVERTED);\t// delete the inversion\n\t}\n\n#if defined(FEAT_CMDWIN) && defined(FEAT_CLIPBOARD)\n\t// Continue a modeless selection in another window.\n\tif (cmdwin_type != 0 && row < curwin->w_winrow)\n\t    return IN_OTHER_WIN;\n#endif\n#ifdef FEAT_PROP_POPUP\n\tif (in_popup_win)\n\t{\n\t    if (popup_dragwin != NULL)\n\t    {\n\t\t// dragging a popup window\n\t\tpopup_drag(popup_dragwin);\n\t\treturn IN_UNKNOWN;\n\t    }\n\t    // continue a modeless selection in a popup window\n\t    click_in_popup_win = NULL;\n\t    return IN_OTHER_WIN;\n\t}\n#endif\n\n\trow -= W_WINROW(curwin);\n\tcol -= curwin->w_wincol;\n\n\t// When clicking beyond the end of the window, scroll the screen.\n\t// Scroll by however many rows outside the window we are.\n\tif (row < 0)\n\t{\n\t    count = 0;\n\t    for (first = TRUE; curwin->w_topline > 1; )\n\t    {\n#ifdef FEAT_DIFF\n\t\tif (curwin->w_topfill < diff_check(curwin, curwin->w_topline))\n\t\t    ++count;\n\t\telse\n#endif\n\t\t    count += plines(curwin->w_topline - 1);\n\t\tif (!first && count > -row)\n\t\t    break;\n\t\tfirst = FALSE;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n#ifdef FEAT_DIFF\n\t\tif (curwin->w_topfill < diff_check(curwin, curwin->w_topline))\n\t\t    ++curwin->w_topfill;\n\t\telse\n#endif\n\t\t{\n\t\t    --curwin->w_topline;\n#ifdef FEAT_DIFF\n\t\t    curwin->w_topfill = 0;\n#endif\n\t\t}\n\t    }\n#ifdef FEAT_DIFF\n\t    check_topfill(curwin, FALSE);\n#endif\n\t    curwin->w_valid &=\n\t\t      ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    redraw_later(UPD_VALID);\n\t    row = 0;\n\t}\n\telse if (row >= curwin->w_height)\n\t{\n\t    count = 0;\n\t    for (first = TRUE; curwin->w_topline < curbuf->b_ml.ml_line_count; )\n\t    {\n#ifdef FEAT_DIFF\n\t\tif (curwin->w_topfill > 0)\n\t\t    ++count;\n\t\telse\n#endif\n\t\t    count += plines(curwin->w_topline);\n\t\tif (!first && count > row - curwin->w_height + 1)\n\t\t    break;\n\t\tfirst = FALSE;\n#ifdef FEAT_FOLDING\n\t\tif (hasFolding(curwin->w_topline, NULL, &curwin->w_topline)\n\t\t\t&& curwin->w_topline == curbuf->b_ml.ml_line_count)\n\t\t    break;\n#endif\n#ifdef FEAT_DIFF\n\t\tif (curwin->w_topfill > 0)\n\t\t    --curwin->w_topfill;\n\t\telse\n#endif\n\t\t{\n\t\t    ++curwin->w_topline;\n#ifdef FEAT_DIFF\n\t\t    curwin->w_topfill =\n\t\t\t\t   diff_check_fill(curwin, curwin->w_topline);\n#endif\n\t\t}\n\t    }\n#ifdef FEAT_DIFF\n\t    check_topfill(curwin, FALSE);\n#endif\n\t    redraw_later(UPD_VALID);\n\t    curwin->w_valid &=\n\t\t      ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    row = curwin->w_height - 1;\n\t}\n\telse if (row == 0)\n\t{\n\t    // When dragging the mouse, while the text has been scrolled up as\n\t    // far as it goes, moving the mouse in the top line should scroll\n\t    // the text down (done later when recomputing w_topline).\n\t    if (mouse_dragging > 0\n\t\t    && curwin->w_cursor.lnum\n\t\t\t\t       == curwin->w_buffer->b_ml.ml_line_count\n\t\t    && curwin->w_cursor.lnum == curwin->w_topline)\n\t\tcurwin->w_valid &= ~(VALID_TOPLINE);\n\t}\n    }\n\n    if (prev_row >= 0 && prev_row < Rows && prev_col >= 0 && prev_col <= Columns\n\t\t\t\t\t\t       && ScreenLines != NULL)\n    {\n\tint off = LineOffset[prev_row] + prev_col;\n\n\t// Only use ScreenCols[] after the window was redrawn.  Mainly matters\n\t// for tests, a user would not click before redrawing.\n\t// Do not use when 'virtualedit' is active.\n\tif (curwin->w_redr_type <= UPD_VALID_NO_UPDATE && !virtual_active())\n\t    col_from_screen = ScreenCols[off];\n#ifdef FEAT_FOLDING\n\t// Remember the character under the mouse, it might be a '-' or '+' in\n\t// the fold column.\n\tmouse_char = ScreenLines[off];\n#endif\n    }\n\n#ifdef FEAT_FOLDING\n    // Check for position outside of the fold column.\n    if (\n# ifdef FEAT_RIGHTLEFT\n\t    curwin->w_p_rl ? col < curwin->w_width - curwin->w_p_fdc :\n# endif\n\t    col >= curwin->w_p_fdc\n#  ifdef FEAT_CMDWIN\n\t\t\t\t+ (cmdwin_type == 0 ? 0 : 1)\n#  endif\n       )\n\tmouse_char = ' ';\n#endif\n\n    // compute the position in the buffer line from the posn on the screen\n    if (mouse_comp_pos(curwin, &row, &col, &curwin->w_cursor.lnum, NULL))\n\tmouse_past_bottom = TRUE;\n\n    // Start Visual mode before coladvance(), for when 'sel' != \"old\"\n    if ((flags & MOUSE_MAY_VIS) && !VIsual_active)\n    {\n\tcheck_visual_highlight();\n\tVIsual = old_cursor;\n\tVIsual_active = TRUE;\n\tVIsual_reselect = TRUE;\n\t// if 'selectmode' contains \"mouse\", start Select mode\n\tmay_start_select('o');\n\tsetmouse();\n\tif (p_smd && msg_silent == 0)\n\t    redraw_cmdline = TRUE;\t// show visual mode later\n    }\n\n    if (col_from_screen >= 0)\n    {\n\t// Use the column from ScreenCols[], it is accurate also after\n\t// concealed characters.\n\tcurwin->w_cursor.col = col_from_screen;\n\tif (col_from_screen == MAXCOL)\n\t{\n\t    curwin->w_curswant = col_from_screen;\n\t    curwin->w_set_curswant = FALSE;\t// May still have been TRUE\n\t    mouse_past_eol = TRUE;\n\t    if (inclusive != NULL)\n\t\t*inclusive = TRUE;\n\t}\n\telse\n\t{\n\t    curwin->w_set_curswant = TRUE;\n\t    if (inclusive != NULL)\n\t\t*inclusive = FALSE;\n\t}\n\tcheck_cursor_col();\n    }\n    else\n    {\n\tcurwin->w_curswant = col;\n\tcurwin->w_set_curswant = FALSE;\t// May still have been TRUE\n\tif (coladvance(col) == FAIL)\t// Mouse click beyond end of line\n\t{\n\t    if (inclusive != NULL)\n\t\t*inclusive = TRUE;\n\t    mouse_past_eol = TRUE;\n\t}\n\telse if (inclusive != NULL)\n\t    *inclusive = FALSE;\n    }\n\n    count = IN_BUFFER;\n    if (curwin != old_curwin || curwin->w_cursor.lnum != old_cursor.lnum\n\t    || curwin->w_cursor.col != old_cursor.col)\n\tcount |= CURSOR_MOVED;\t\t// Cursor has moved\n\n# ifdef FEAT_FOLDING\n    if (mouse_char == curwin->w_fill_chars.foldclosed)\n\tcount |= MOUSE_FOLD_OPEN;\n    else if (mouse_char != ' ')\n\tcount |= MOUSE_FOLD_CLOSE;\n# endif\n\n    return count;\n}\n\n/*\n * Mouse scroll wheel: Default action is to scroll mouse_vert_step lines (or\n * mouse_hor_step, depending on the scroll direction), or one page when Shift or\n * Ctrl is used.\n * K_MOUSEUP (cap->arg == 1) or K_MOUSEDOWN (cap->arg == 0) or\n * K_MOUSELEFT (cap->arg == -1) or K_MOUSERIGHT (cap->arg == -2)\n */\n    void\nnv_mousescroll(cmdarg_T *cap)\n{\n    win_T *old_curwin = curwin, *wp;\n\n    if (mouse_row >= 0 && mouse_col >= 0)\n    {\n\tint row, col;\n\n\trow = mouse_row;\n\tcol = mouse_col;\n\n\t// find the window at the pointer coordinates\n\twp = mouse_find_win(&row, &col, FIND_POPUP);\n\tif (wp == NULL)\n\t    return;\n#ifdef FEAT_PROP_POPUP\n\tif (WIN_IS_POPUP(wp) && !wp->w_has_scrollbar)\n\t    return;\n#endif\n\tcurwin = wp;\n\tcurbuf = curwin->w_buffer;\n    }\n    if (cap->arg == MSCR_UP || cap->arg == MSCR_DOWN)\n    {\n# ifdef FEAT_TERMINAL\n\tif (term_use_loop())\n\t    // This window is a terminal window, send the mouse event there.\n\t    // Set \"typed\" to FALSE to avoid an endless loop.\n\t    send_keys_to_term(curbuf->b_term, cap->cmdchar, mod_mask, FALSE);\n\telse\n# endif\n\tif (mouse_vert_step < 0 || mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n\t{\n\t    (void)onepage(cap->arg ? FORWARD : BACKWARD, 1L);\n\t}\n\telse\n\t{\n\t    // Don't scroll more than half the window height.\n\t    if (curwin->w_height < mouse_vert_step * 2)\n\t    {\n\t\tcap->count1 = curwin->w_height / 2;\n\t\tif (cap->count1 == 0)\n\t\t    cap->count1 = 1;\n\t    }\n\t    else\n\t\tcap->count1 = mouse_vert_step;\n\t    cap->count0 = cap->count1;\n\t    nv_scroll_line(cap);\n\t}\n#ifdef FEAT_PROP_POPUP\n\tif (WIN_IS_POPUP(curwin))\n\t    popup_set_firstline(curwin);\n#endif\n    }\n# ifdef FEAT_GUI\n    else\n    {\n\t// Horizontal scroll - only allowed when 'wrap' is disabled\n\tif (!curwin->w_p_wrap)\n\t{\n\t    int val, step;\n\n\t    if (mouse_hor_step < 0\n\t\t    || mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n\t\tstep = curwin->w_width;\n\t    else\n\t\tstep = mouse_hor_step;\n\t    val = curwin->w_leftcol + (cap->arg == MSCR_RIGHT ? -step : +step);\n\t    if (val < 0)\n\t\tval = 0;\n\n\t    gui_do_horiz_scroll(val, TRUE);\n\t}\n    }\n# endif\n# ifdef FEAT_SYN_HL\n    if (curwin != old_curwin && curwin->w_p_cul)\n\tredraw_for_cursorline(curwin);\n# endif\n    may_trigger_winscrolled();\n\n    curwin->w_redr_status = TRUE;\n\n    curwin = old_curwin;\n    curbuf = curwin->w_buffer;\n}\n\n/*\n * Mouse clicks and drags.\n */\n    void\nnv_mouse(cmdarg_T *cap)\n{\n    (void)do_mouse(cap->oap, cap->cmdchar, BACKWARD, cap->count1, 0);\n}\n\nstatic int\theld_button = MOUSE_RELEASE;\n\n    void\nreset_held_button()\n{\n    held_button = MOUSE_RELEASE;\n}\n\n/*\n * Check if typebuf 'tp' contains a terminal mouse code and returns the\n * modifiers found in typebuf in 'modifiers'.\n */\n    int\ncheck_termcode_mouse(\n    char_u\t*tp,\n    int\t\t*slen,\n    char_u\t*key_name,\n    char_u\t*modifiers_start,\n    int\t\tidx,\n    int\t\t*modifiers)\n{\n    int\t\tj;\n    char_u\t*p;\n# if !defined(UNIX) || defined(FEAT_MOUSE_XTERM) || defined(FEAT_GUI) \\\n    || defined(FEAT_MOUSE_GPM) || defined(FEAT_SYSMOUSE)\n    char_u\tbytes[6];\n    int\t\tnum_bytes;\n# endif\n    int\t\tmouse_code = 0;\t    // init for GCC\n    int\t\tis_click, is_drag;\n    int\t\tis_release, release_is_ambiguous;\n    int\t\twheel_code = 0;\n    int\t\tcurrent_button;\n    static int\torig_num_clicks = 1;\n    static int\torig_mouse_code = 0x0;\n# ifdef CHECK_DOUBLE_CLICK\n    static int\torig_mouse_col = 0;\n    static int\torig_mouse_row = 0;\n    static struct timeval  orig_mouse_time = {0, 0};\n    // time of previous mouse click\n    struct timeval  mouse_time;\t\t// time of current mouse click\n    long\ttimediff;\t\t// elapsed time in msec\n# endif\n\n    is_click = is_drag = is_release = release_is_ambiguous = FALSE;\n\n# if !defined(UNIX) || defined(FEAT_MOUSE_XTERM) || defined(FEAT_GUI) \\\n    || defined(FEAT_MOUSE_GPM) || defined(FEAT_SYSMOUSE)\n    if (key_name[0] == KS_MOUSE\n#  ifdef FEAT_MOUSE_GPM\n\t    || key_name[0] == KS_GPM_MOUSE\n#  endif\n       )\n    {\n\t/*\n\t * For xterm we get \"<t_mouse>scr\", where s == encoded button state:\n\t *\t   0x20 = left button down\n\t *\t   0x21 = middle button down\n\t *\t   0x22 = right button down\n\t *\t   0x23 = any button release\n\t *\t   0x60 = button 4 down (scroll wheel down)\n\t *\t   0x61 = button 5 down (scroll wheel up)\n\t *\tadd 0x04 for SHIFT\n\t *\tadd 0x08 for ALT\n\t *\tadd 0x10 for CTRL\n\t *\tadd 0x20 for mouse drag (0x40 is drag with left button)\n\t *\tadd 0x40 for mouse move (0x80 is move, 0x81 too)\n\t *\t\t 0x43 (drag + release) is also move\n\t *  c == column + ' ' + 1 == column + 33\n\t *  r == row + ' ' + 1 == row + 33\n\t *\n\t * The coordinates are passed on through global variables.  Ugly, but\n\t * this avoids trouble with mouse clicks at an unexpected moment and\n\t * allows for mapping them.\n\t */\n\tfor (;;)\n\t{\n#  ifdef FEAT_GUI\n\t    if (gui.in_use)\n\t    {\n\t\t// GUI uses more bits for columns > 223\n\t\tnum_bytes = get_bytes_from_buf(tp + *slen, bytes, 5);\n\t\tif (num_bytes == -1)\t// not enough coordinates\n\t\t    return -1;\n\t\tmouse_code = bytes[0];\n\t\tmouse_col = 128 * (bytes[1] - ' ' - 1)\n\t\t    + bytes[2] - ' ' - 1;\n\t\tmouse_row = 128 * (bytes[3] - ' ' - 1)\n\t\t    + bytes[4] - ' ' - 1;\n\t    }\n\t    else\n#  endif\n\t    {\n\t\tnum_bytes = get_bytes_from_buf(tp + *slen, bytes, 3);\n\t\tif (num_bytes == -1)\t// not enough coordinates\n\t\t    return -1;\n\t\tmouse_code = bytes[0];\n\t\tmouse_col = bytes[1] - ' ' - 1;\n\t\tmouse_row = bytes[2] - ' ' - 1;\n\t    }\n\t    *slen += num_bytes;\n\n\t    // If the following bytes is also a mouse code and it has the same\n\t    // code, dump this one and get the next.  This makes dragging a\n\t    // whole lot faster.\n#  ifdef FEAT_GUI\n\t    if (gui.in_use)\n\t\tj = 3;\n\t    else\n#  endif\n\t\tj = get_termcode_len(idx);\n\t    if (STRNCMP(tp, tp + *slen, (size_t)j) == 0\n\t\t    && tp[*slen + j] == mouse_code\n\t\t    && tp[*slen + j + 1] != NUL\n\t\t    && tp[*slen + j + 2] != NUL\n#  ifdef FEAT_GUI\n\t\t    && (!gui.in_use\n\t\t\t|| (tp[*slen + j + 3] != NUL\n\t\t\t    && tp[*slen + j + 4] != NUL))\n#  endif\n\t       )\n\t\t*slen += j;\n\t    else\n\t\tbreak;\n\t}\n    }\n\n    if (key_name[0] == KS_URXVT_MOUSE\n\t    || key_name[0] == KS_SGR_MOUSE\n\t    || key_name[0] == KS_SGR_MOUSE_RELEASE)\n    {\n\t// URXVT 1015 mouse reporting mode:\n\t// Almost identical to xterm mouse mode, except the values are decimal\n\t// instead of bytes.\n\t//\n\t// \\033[%d;%d;%dM\n\t//\t       ^-- row\n\t//\t    ^----- column\n\t//\t ^-------- code\n\t//\n\t// SGR 1006 mouse reporting mode:\n\t// Almost identical to xterm mouse mode, except the values are decimal\n\t// instead of bytes.\n\t//\n\t// \\033[<%d;%d;%dM\n\t//\t       ^-- row\n\t//\t    ^----- column\n\t//\t ^-------- code\n\t//\n\t// \\033[<%d;%d;%dm\t  : mouse release event\n\t//\t       ^-- row\n\t//\t    ^----- column\n\t//\t ^-------- code\n\tp = modifiers_start;\n\tif (p == NULL)\n\t    return -1;\n\n\tmouse_code = getdigits(&p);\n\tif (*p++ != ';')\n\t    return -1;\n\n\t// when mouse reporting is SGR, add 32 to mouse code\n\tif (key_name[0] == KS_SGR_MOUSE\n\t\t|| key_name[0] == KS_SGR_MOUSE_RELEASE)\n\t    mouse_code += 32;\n\n\tmouse_col = getdigits(&p) - 1;\n\tif (*p++ != ';')\n\t    return -1;\n\n\tmouse_row = getdigits(&p) - 1;\n\n\t// The modifiers were the mouse coordinates, not the modifier keys\n\t// (alt/shift/ctrl/meta) state.\n\t*modifiers = 0;\n    }\n\n    if (key_name[0] == KS_SGR_MOUSE\n\t    || key_name[0] == KS_SGR_MOUSE_RELEASE)\n    {\n\tif (key_name[0] == KS_SGR_MOUSE_RELEASE)\n\t{\n\t    is_release = TRUE;\n\t    // This is used below to set held_button.\n\t    mouse_code |= MOUSE_RELEASE;\n\t}\n    }\n    else\n    {\n\trelease_is_ambiguous = TRUE;\n\tif ((mouse_code & MOUSE_RELEASE) == MOUSE_RELEASE)\n\t    is_release = TRUE;\n    }\n\n    if (key_name[0] == KS_MOUSE\n#  ifdef FEAT_MOUSE_GPM\n\t    || key_name[0] == KS_GPM_MOUSE\n#  endif\n#  ifdef FEAT_MOUSE_URXVT\n\t    || key_name[0] == KS_URXVT_MOUSE\n#  endif\n\t    || key_name[0] == KS_SGR_MOUSE\n\t    || key_name[0] == KS_SGR_MOUSE_RELEASE)\n    {\n#  if !defined(MSWIN)\n\t/*\n\t * Handle old style mouse events.\n\t * Recognize the xterm mouse wheel, but not in the GUI, the\n\t * Linux console with GPM and the MS-DOS or Win32 console\n\t * (multi-clicks use >= 0x60).\n\t */\n\tif (mouse_code >= MOUSEWHEEL_LOW\n#   ifdef FEAT_GUI\n\t\t&& !gui.in_use\n#   endif\n#   ifdef FEAT_MOUSE_GPM\n\t\t&& key_name[0] != KS_GPM_MOUSE\n#   endif\n\t   )\n\t{\n#   if defined(UNIX)\n\t    if (use_xterm_mouse() > 1 && mouse_code >= 0x80)\n\t\t// mouse-move event, using MOUSE_DRAG works\n\t\tmouse_code = MOUSE_DRAG;\n\t    else\n#   endif\n\t\t// Keep the mouse_code before it's changed, so that we\n\t\t// remember that it was a mouse wheel click.\n\t\twheel_code = mouse_code;\n\t}\n#   ifdef FEAT_MOUSE_XTERM\n\telse if (held_button == MOUSE_RELEASE\n#    ifdef FEAT_GUI\n\t\t&& !gui.in_use\n#    endif\n\t\t&& (mouse_code == 0x23 || mouse_code == 0x24\n\t\t    || mouse_code == 0x40 || mouse_code == 0x41))\n\t{\n\t    // Apparently 0x23 and 0x24 are used by rxvt scroll wheel.\n\t    // And 0x40 and 0x41 are used by some xterm emulator.\n\t    wheel_code = mouse_code - (mouse_code >= 0x40 ? 0x40 : 0x23)\n\t\t\t\t\t\t\t      + MOUSEWHEEL_LOW;\n\t}\n#   endif\n\n#   if defined(UNIX)\n\telse if (use_xterm_mouse() > 1)\n\t{\n\t    if (mouse_code & MOUSE_DRAG_XTERM)\n\t\tmouse_code |= MOUSE_DRAG;\n\t}\n#   endif\n#   ifdef FEAT_XCLIPBOARD\n\telse if (!(mouse_code & MOUSE_DRAG & ~MOUSE_CLICK_MASK))\n\t{\n\t    if (is_release)\n\t\tstop_xterm_trace();\n\t    else\n\t\tstart_xterm_trace(mouse_code);\n\t}\n#   endif\n#  endif\n    }\n# endif // !UNIX || FEAT_MOUSE_XTERM\n# ifdef FEAT_MOUSE_NET\n    if (key_name[0] == KS_NETTERM_MOUSE)\n    {\n\tint mc, mr;\n\n\t// expect a rather limited sequence like: balancing {\n\t// \\033}6,45\\r\n\t// '6' is the row, 45 is the column\n\tp = tp + *slen;\n\tmr = getdigits(&p);\n\tif (*p++ != ',')\n\t    return -1;\n\tmc = getdigits(&p);\n\tif (*p++ != '\\r')\n\t    return -1;\n\n\tmouse_col = mc - 1;\n\tmouse_row = mr - 1;\n\tmouse_code = MOUSE_LEFT;\n\t*slen += (int)(p - (tp + *slen));\n    }\n# endif\t// FEAT_MOUSE_NET\n# ifdef FEAT_MOUSE_JSB\n    if (key_name[0] == KS_JSBTERM_MOUSE)\n    {\n\tint mult, val, iter, button, status;\n\n\t/*\n\t * JSBTERM Input Model\n\t * \\033[0~zw uniq escape sequence\n\t * (L-x)  Left button pressed - not pressed x not reporting\n\t * (M-x)  Middle button pressed - not pressed x not reporting\n\t * (R-x)  Right button pressed - not pressed x not reporting\n\t * (SDmdu)  Single , Double click, m: mouse move, d: button down,\n\t\t      *\t\t\t\t\t\t   u: button up\n\t *  ###   X cursor position padded to 3 digits\n\t *  ###   Y cursor position padded to 3 digits\n\t * (s-x)  SHIFT key pressed - not pressed x not reporting\n\t * (c-x)  CTRL key pressed - not pressed x not reporting\n\t * \\033\\\\ terminating sequence\n\t */\n\tp = tp + *slen;\n\tbutton = mouse_code = 0;\n\tswitch (*p++)\n\t{\n\t    case 'L': button = 1; break;\n\t    case '-': break;\n\t    case 'x': break; // ignore sequence\n\t    default:  return -1; // Unknown Result\n\t}\n\tswitch (*p++)\n\t{\n\t    case 'M': button |= 2; break;\n\t    case '-': break;\n\t    case 'x': break; // ignore sequence\n\t    default:  return -1; // Unknown Result\n\t}\n\tswitch (*p++)\n\t{\n\t    case 'R': button |= 4; break;\n\t    case '-': break;\n\t    case 'x': break; // ignore sequence\n\t    default:  return -1; // Unknown Result\n\t}\n\tstatus = *p++;\n\tfor (val = 0, mult = 100, iter = 0; iter < 3; iter++,\n\t\tmult /= 10, p++)\n\t    if (*p >= '0' && *p <= '9')\n\t\tval += (*p - '0') * mult;\n\t    else\n\t\treturn -1;\n\tmouse_col = val;\n\tfor (val = 0, mult = 100, iter = 0; iter < 3; iter++,\n\t\tmult /= 10, p++)\n\t    if (*p >= '0' && *p <= '9')\n\t\tval += (*p - '0') * mult;\n\t    else\n\t\treturn -1;\n\tmouse_row = val;\n\tswitch (*p++)\n\t{\n\t    case 's': button |= 8; break;  // SHIFT key Pressed\n\t    case '-': break;  // Not Pressed\n\t    case 'x': break;  // Not Reporting\n\t    default:  return -1; // Unknown Result\n\t}\n\tswitch (*p++)\n\t{\n\t    case 'c': button |= 16; break;  // CTRL key Pressed\n\t    case '-': break;  // Not Pressed\n\t    case 'x': break;  // Not Reporting\n\t    default:  return -1; // Unknown Result\n\t}\n\tif (*p++ != '\\033')\n\t    return -1;\n\tif (*p++ != '\\\\')\n\t    return -1;\n\tswitch (status)\n\t{\n\t    case 'D': // Double Click\n\t    case 'S': // Single Click\n\t\tif (button & 1) mouse_code |= MOUSE_LEFT;\n\t\tif (button & 2) mouse_code |= MOUSE_MIDDLE;\n\t\tif (button & 4) mouse_code |= MOUSE_RIGHT;\n\t\tif (button & 8) mouse_code |= MOUSE_SHIFT;\n\t\tif (button & 16) mouse_code |= MOUSE_CTRL;\n\t\tbreak;\n\t    case 'm': // Mouse move\n\t\tif (button & 1) mouse_code |= MOUSE_LEFT;\n\t\tif (button & 2) mouse_code |= MOUSE_MIDDLE;\n\t\tif (button & 4) mouse_code |= MOUSE_RIGHT;\n\t\tif (button & 8) mouse_code |= MOUSE_SHIFT;\n\t\tif (button & 16) mouse_code |= MOUSE_CTRL;\n\t\tif ((button & 7) != 0)\n\t\t{\n\t\t    held_button = mouse_code;\n\t\t    mouse_code |= MOUSE_DRAG;\n\t\t}\n\t\tis_drag = TRUE;\n\t\tshowmode();\n\t\tbreak;\n\t    case 'd': // Button Down\n\t\tif (button & 1) mouse_code |= MOUSE_LEFT;\n\t\tif (button & 2) mouse_code |= MOUSE_MIDDLE;\n\t\tif (button & 4) mouse_code |= MOUSE_RIGHT;\n\t\tif (button & 8) mouse_code |= MOUSE_SHIFT;\n\t\tif (button & 16) mouse_code |= MOUSE_CTRL;\n\t\tbreak;\n\t    case 'u': // Button Up\n\t\tis_release = TRUE;\n\t\tif (button & 1)\n\t\t    mouse_code |= MOUSE_LEFT;\n\t\tif (button & 2)\n\t\t    mouse_code |= MOUSE_MIDDLE;\n\t\tif (button & 4)\n\t\t    mouse_code |= MOUSE_RIGHT;\n\t\tif (button & 8)\n\t\t    mouse_code |= MOUSE_SHIFT;\n\t\tif (button & 16)\n\t\t    mouse_code |= MOUSE_CTRL;\n\t\tbreak;\n\t    default: return -1; // Unknown Result\n\t}\n\n\t*slen += (p - (tp + *slen));\n    }\n# endif // FEAT_MOUSE_JSB\n# ifdef FEAT_MOUSE_DEC\n    if (key_name[0] == KS_DEC_MOUSE)\n    {\n\t/*\n\t * The DEC Locator Input Model\n\t * Netterm delivers the code sequence:\n\t *  \\033[2;4;24;80&w  (left button down)\n\t *  \\033[3;0;24;80&w  (left button up)\n\t *  \\033[6;1;24;80&w  (right button down)\n\t *  \\033[7;0;24;80&w  (right button up)\n\t * CSI Pe ; Pb ; Pr ; Pc ; Pp & w\n\t * Pe is the event code\n\t * Pb is the button code\n\t * Pr is the row coordinate\n\t * Pc is the column coordinate\n\t * Pp is the third coordinate (page number)\n\t * Pe, the event code indicates what event caused this report\n\t *    The following event codes are defined:\n\t *    0 - request, the terminal received an explicit request for a\n\t *\t  locator report, but the locator is unavailable\n\t *    1 - request, the terminal received an explicit request for a\n\t *\t  locator report\n\t *    2 - left button down\n\t *    3 - left button up\n\t *    4 - middle button down\n\t *    5 - middle button up\n\t *    6 - right button down\n\t *    7 - right button up\n\t *    8 - fourth button down\n\t *    9 - fourth button up\n\t *    10 - locator outside filter rectangle\n\t * Pb, the button code, ASCII decimal 0-15 indicating which buttons are\n\t *   down if any. The state of the four buttons on the locator\n\t *   correspond to the low four bits of the decimal value, \"1\" means\n\t *   button depressed\n\t *   0 - no buttons down,\n\t *   1 - right,\n\t *   2 - middle,\n\t *   4 - left,\n\t *   8 - fourth\n\t * Pr is the row coordinate of the locator position in the page,\n\t *   encoded as an ASCII decimal value.  If Pr is omitted, the locator\n\t *   position is undefined (outside the terminal window for example).\n\t * Pc is the column coordinate of the locator position in the page,\n\t *   encoded as an ASCII decimal value.  If Pc is omitted, the locator\n\t *   position is undefined (outside the terminal window for example).\n\t * Pp is the page coordinate of the locator position encoded as an\n\t *   ASCII decimal value.  The page coordinate may be omitted if the\n\t *   locator is on page one (the default).  We ignore it anyway.\n\t */\n\tint Pe, Pb, Pr, Pc;\n\n\tp = tp + *slen;\n\n\t// get event status\n\tPe = getdigits(&p);\n\tif (*p++ != ';')\n\t    return -1;\n\n\t// get button status\n\tPb = getdigits(&p);\n\tif (*p++ != ';')\n\t    return -1;\n\n\t// get row status\n\tPr = getdigits(&p);\n\tif (*p++ != ';')\n\t    return -1;\n\n\t// get column status\n\tPc = getdigits(&p);\n\n\t// the page parameter is optional\n\tif (*p == ';')\n\t{\n\t    p++;\n\t    (void)getdigits(&p);\n\t}\n\tif (*p++ != '&')\n\t    return -1;\n\tif (*p++ != 'w')\n\t    return -1;\n\n\tmouse_code = 0;\n\tswitch (Pe)\n\t{\n\t    case  0: return -1; // position request while unavailable\n\t    case  1: // a response to a locator position request includes\n\t\t     //\tthe status of all buttons\n\t\t     Pb &= 7;   // mask off and ignore fourth button\n\t\t     if (Pb & 4)\n\t\t\t mouse_code  = MOUSE_LEFT;\n\t\t     if (Pb & 2)\n\t\t\t mouse_code  = MOUSE_MIDDLE;\n\t\t     if (Pb & 1)\n\t\t\t mouse_code  = MOUSE_RIGHT;\n\t\t     if (Pb)\n\t\t     {\n\t\t\t held_button = mouse_code;\n\t\t\t mouse_code |= MOUSE_DRAG;\n\t\t\t WantQueryMouse = TRUE;\n\t\t     }\n\t\t     is_drag = TRUE;\n\t\t     showmode();\n\t\t     break;\n\t    case  2: mouse_code = MOUSE_LEFT;\n\t\t     WantQueryMouse = TRUE;\n\t\t     break;\n\t    case  3: mouse_code = MOUSE_LEFT;\n\t\t     is_release = TRUE;\n\t\t     break;\n\t    case  4: mouse_code = MOUSE_MIDDLE;\n\t\t     WantQueryMouse = TRUE;\n\t\t     break;\n\t    case  5: mouse_code = MOUSE_MIDDLE;\n\t\t     is_release = TRUE;\n\t\t     break;\n\t    case  6: mouse_code = MOUSE_RIGHT;\n\t\t     WantQueryMouse = TRUE;\n\t\t     break;\n\t    case  7: mouse_code = MOUSE_RIGHT;\n\t\t     is_release = TRUE;\n\t\t     break;\n\t    case  8: return -1; // fourth button down\n\t    case  9: return -1; // fourth button up\n\t    case 10: return -1; // mouse outside of filter rectangle\n\t    default: return -1; // should never occur\n\t}\n\n\tmouse_col = Pc - 1;\n\tmouse_row = Pr - 1;\n\n\t*slen += (int)(p - (tp + *slen));\n    }\n# endif // FEAT_MOUSE_DEC\n# ifdef FEAT_MOUSE_PTERM\n    if (key_name[0] == KS_PTERM_MOUSE)\n    {\n\tint button, num_clicks, action;\n\n\tp = tp + *slen;\n\n\taction = getdigits(&p);\n\tif (*p++ != ';')\n\t    return -1;\n\n\tmouse_row = getdigits(&p);\n\tif (*p++ != ';')\n\t    return -1;\n\tmouse_col = getdigits(&p);\n\tif (*p++ != ';')\n\t    return -1;\n\n\tbutton = getdigits(&p);\n\tmouse_code = 0;\n\n\tswitch (button)\n\t{\n\t    case 4: mouse_code = MOUSE_LEFT; break;\n\t    case 1: mouse_code = MOUSE_RIGHT; break;\n\t    case 2: mouse_code = MOUSE_MIDDLE; break;\n\t    default: return -1;\n\t}\n\n\tswitch (action)\n\t{\n\t    case 31: // Initial press\n\t\tif (*p++ != ';')\n\t\t    return -1;\n\n\t\tnum_clicks = getdigits(&p); // Not used\n\t\tbreak;\n\n\t    case 32: // Release\n\t\tis_release = TRUE;\n\t\tbreak;\n\n\t    case 33: // Drag\n\t\theld_button = mouse_code;\n\t\tmouse_code |= MOUSE_DRAG;\n\t\tbreak;\n\n\t    default:\n\t\treturn -1;\n\t}\n\n\tif (*p++ != 't')\n\t    return -1;\n\n\t*slen += (p - (tp + *slen));\n    }\n# endif // FEAT_MOUSE_PTERM\n\n    // Interpret the mouse code\n    current_button = (mouse_code & MOUSE_CLICK_MASK);\n    if (is_release)\n\tcurrent_button |= MOUSE_RELEASE;\n\n    if (current_button == MOUSE_RELEASE\n# ifdef FEAT_MOUSE_XTERM\n\t    && wheel_code == 0\n# endif\n       )\n    {\n\t/*\n\t * If we get a mouse drag or release event when there is no mouse\n\t * button held down (held_button == MOUSE_RELEASE), produce a K_IGNORE\n\t * below.\n\t * (can happen when you hold down two buttons and then let them go, or\n\t * click in the menu bar, but not on a menu, and drag into the text).\n\t */\n\tif ((mouse_code & MOUSE_DRAG) == MOUSE_DRAG)\n\t    is_drag = TRUE;\n\tcurrent_button = held_button;\n    }\n    else\n    {\n      if (wheel_code == 0)\n      {\n# ifdef CHECK_DOUBLE_CLICK\n#  ifdef FEAT_MOUSE_GPM\n\t/*\n\t * Only for Unix, when GUI not active, we handle multi-clicks here, but\n\t * not for GPM mouse events.\n\t */\n#   ifdef FEAT_GUI\n\tif (key_name[0] != KS_GPM_MOUSE && !gui.in_use)\n#   else\n\t    if (key_name[0] != KS_GPM_MOUSE)\n#   endif\n#  else\n#   ifdef FEAT_GUI\n\t\tif (!gui.in_use)\n#   endif\n#  endif\n\t\t{\n\t\t    /*\n\t\t     * Compute the time elapsed since the previous mouse click.\n\t\t     */\n\t\t    gettimeofday(&mouse_time, NULL);\n\t\t    if (orig_mouse_time.tv_sec == 0)\n\t\t    {\n\t\t\t/*\n\t\t\t * Avoid computing the difference between mouse_time\n\t\t\t * and orig_mouse_time for the first click, as the\n\t\t\t * difference would be huge and would cause\n\t\t\t * multiplication overflow.\n\t\t\t */\n\t\t\ttimediff = p_mouset;\n\t\t    }\n\t\t    else\n\t\t\ttimediff = time_diff_ms(&orig_mouse_time, &mouse_time);\n\t\t    orig_mouse_time = mouse_time;\n\t\t    if (mouse_code == orig_mouse_code\n\t\t\t    && timediff < p_mouset\n\t\t\t    && orig_num_clicks != 4\n\t\t\t    && orig_mouse_col == mouse_col\n\t\t\t    && orig_mouse_row == mouse_row\n\t\t\t    && (is_mouse_topline(curwin)\n\t\t\t\t// Double click in tab pages line also works\n\t\t\t\t// when window contents changes.\n\t\t\t\t|| (mouse_row == 0 && firstwin->w_winrow > 0))\n\t\t       )\n\t\t\t++orig_num_clicks;\n\t\t    else\n\t\t\torig_num_clicks = 1;\n\t\t    orig_mouse_col = mouse_col;\n\t\t    orig_mouse_row = mouse_row;\n\t\t    set_mouse_topline(curwin);\n\t\t}\n#  if defined(FEAT_GUI) || defined(FEAT_MOUSE_GPM)\n\t\telse\n\t\t    orig_num_clicks = NUM_MOUSE_CLICKS(mouse_code);\n#  endif\n# else\n\torig_num_clicks = NUM_MOUSE_CLICKS(mouse_code);\n# endif\n\tis_click = TRUE;\n      }\n      orig_mouse_code = mouse_code;\n    }\n    if (!is_drag)\n\theld_button = mouse_code & MOUSE_CLICK_MASK;\n\n    /*\n     * Translate the actual mouse event into a pseudo mouse event.\n     * First work out what modifiers are to be used.\n     */\n    if (orig_mouse_code & MOUSE_SHIFT)\n\t*modifiers |= MOD_MASK_SHIFT;\n    if (orig_mouse_code & MOUSE_CTRL)\n\t*modifiers |= MOD_MASK_CTRL;\n    if (orig_mouse_code & MOUSE_ALT)\n\t*modifiers |= MOD_MASK_ALT;\n    if (orig_num_clicks == 2)\n\t*modifiers |= MOD_MASK_2CLICK;\n    else if (orig_num_clicks == 3)\n\t*modifiers |= MOD_MASK_3CLICK;\n    else if (orig_num_clicks == 4)\n\t*modifiers |= MOD_MASK_4CLICK;\n\n    // Work out our pseudo mouse event. Note that MOUSE_RELEASE gets added,\n    // then it's not mouse up/down.\n    key_name[0] = KS_EXTRA;\n    if (wheel_code != 0 && (!is_release || release_is_ambiguous))\n    {\n\tif (wheel_code & MOUSE_CTRL)\n\t    *modifiers |= MOD_MASK_CTRL;\n\tif (wheel_code & MOUSE_ALT)\n\t    *modifiers |= MOD_MASK_ALT;\n\n\tif (wheel_code & 1 && wheel_code & 2)\n\t    key_name[1] = (int)KE_MOUSELEFT;\n\telse if (wheel_code & 2)\n\t    key_name[1] = (int)KE_MOUSERIGHT;\n\telse if (wheel_code & 1)\n\t    key_name[1] = (int)KE_MOUSEUP;\n\telse\n\t    key_name[1] = (int)KE_MOUSEDOWN;\n\n\theld_button = MOUSE_RELEASE;\n    }\n    else\n\tkey_name[1] = get_pseudo_mouse_code(current_button, is_click, is_drag);\n\n\n    // Make sure the mouse position is valid.  Some terminals may return weird\n    // values.\n    if (mouse_col >= Columns)\n\tmouse_col = Columns - 1;\n    if (mouse_row >= Rows)\n\tmouse_row = Rows - 1;\n\n    return 0;\n}\n\n// Functions also used for popup windows.\n\n/*\n * Compute the buffer line position from the screen position \"rowp\" / \"colp\" in\n * window \"win\".\n * \"plines_cache\" can be NULL (no cache) or an array with \"Rows\" entries that\n * caches the plines_win() result from a previous call.  Entry is zero if not\n * computed yet.  There must be no text or setting changes since the entry is\n * put in the cache.\n * Returns TRUE if the position is below the last line.\n */\n    int\nmouse_comp_pos(\n    win_T\t*win,\n    int\t\t*rowp,\n    int\t\t*colp,\n    linenr_T\t*lnump,\n    int\t\t*plines_cache)\n{\n    int\t\tcol = *colp;\n    int\t\trow = *rowp;\n    linenr_T\tlnum;\n    int\t\tretval = FALSE;\n    int\t\toff;\n    int\t\tcount;\n\n#ifdef FEAT_RIGHTLEFT\n    if (win->w_p_rl)\n\tcol = win->w_width - 1 - col;\n#endif\n\n    lnum = win->w_topline;\n\n    while (row > 0)\n    {\n\tint cache_idx = lnum - win->w_topline;\n\n\t// Only \"Rows\" lines are cached, with folding we'll run out of entries\n\t// and use the slow way.\n\tif (plines_cache != NULL && cache_idx < Rows\n\t\t\t\t\t\t&& plines_cache[cache_idx] > 0)\n\t    count = plines_cache[cache_idx];\n\telse\n\t{\n#ifdef FEAT_DIFF\n\t    // Don't include filler lines in \"count\"\n\t    if (win->w_p_diff\n# ifdef FEAT_FOLDING\n\t\t    && !hasFoldingWin(win, lnum, NULL, NULL, TRUE, NULL)\n# endif\n\t\t    )\n\t    {\n\t\tif (lnum == win->w_topline)\n\t\t    row -= win->w_topfill;\n\t\telse\n\t\t    row -= diff_check_fill(win, lnum);\n\t\tcount = plines_win_nofill(win, lnum, TRUE);\n\t    }\n\t    else\n#endif\n\t\tcount = plines_win(win, lnum, TRUE);\n\t    if (plines_cache != NULL && cache_idx < Rows)\n\t\tplines_cache[cache_idx] = count;\n\t}\n\tif (count > row)\n\t    break;\t// Position is in this buffer line.\n#ifdef FEAT_FOLDING\n\t(void)hasFoldingWin(win, lnum, NULL, &lnum, TRUE, NULL);\n#endif\n\tif (lnum == win->w_buffer->b_ml.ml_line_count)\n\t{\n\t    retval = TRUE;\n\t    break;\t\t// past end of file\n\t}\n\trow -= count;\n\t++lnum;\n    }\n\n    if (!retval)\n    {\n\t// Compute the column without wrapping.\n\toff = win_col_off(win) - win_col_off2(win);\n\tif (col < off)\n\t    col = off;\n\tcol += row * (win->w_width - off);\n\t// add skip column (for long wrapping line)\n\tcol += win->w_skipcol;\n    }\n\n    if (!win->w_p_wrap)\n\tcol += win->w_leftcol;\n\n    // skip line number and fold column in front of the line\n    col -= win_col_off(win);\n    if (col <= 0)\n    {\n#ifdef FEAT_NETBEANS_INTG\n\t// if mouse is clicked on the gutter, then inform the netbeans server\n\tif (*colp < win_col_off(win))\n\t    netbeans_gutter_click(lnum);\n#endif\n\tcol = 0;\n    }\n\n    *colp = col;\n    *rowp = row;\n    *lnump = lnum;\n    return retval;\n}\n\n/*\n * Find the window at screen position \"*rowp\" and \"*colp\".  The positions are\n * updated to become relative to the top-left of the window.\n * When \"popup\" is FAIL_POPUP and the position is in a popup window then NULL\n * is returned.  When \"popup\" is IGNORE_POPUP then do not even check popup\n * windows.\n * Returns NULL when something is wrong.\n */\n    win_T *\nmouse_find_win(int *rowp, int *colp, mouse_find_T popup UNUSED)\n{\n    frame_T\t*fp;\n    win_T\t*wp;\n\n#ifdef FEAT_PROP_POPUP\n    win_T\t*pwp = NULL;\n\n    if (popup != IGNORE_POPUP)\n    {\n\tpopup_reset_handled(POPUP_HANDLED_1);\n\twhile ((wp = find_next_popup(TRUE, POPUP_HANDLED_1)) != NULL)\n\t{\n\t    if (*rowp >= wp->w_winrow && *rowp < wp->w_winrow + popup_height(wp)\n\t\t    && *colp >= wp->w_wincol\n\t\t\t\t    && *colp < wp->w_wincol + popup_width(wp))\n\t\tpwp = wp;\n\t}\n\tif (pwp != NULL)\n\t{\n\t    if (popup == FAIL_POPUP)\n\t\treturn NULL;\n\t    *rowp -= pwp->w_winrow;\n\t    *colp -= pwp->w_wincol;\n\t    return pwp;\n\t}\n    }\n#endif\n\n    fp = topframe;\n    *rowp -= firstwin->w_winrow;\n    for (;;)\n    {\n\tif (fp->fr_layout == FR_LEAF)\n\t    break;\n\tif (fp->fr_layout == FR_ROW)\n\t{\n\t    for (fp = fp->fr_child; fp->fr_next != NULL; fp = fp->fr_next)\n\t    {\n\t\tif (*colp < fp->fr_width)\n\t\t    break;\n\t\t*colp -= fp->fr_width;\n\t    }\n\t}\n\telse    // fr_layout == FR_COL\n\t{\n\t    for (fp = fp->fr_child; fp->fr_next != NULL; fp = fp->fr_next)\n\t    {\n\t\tif (*rowp < fp->fr_height)\n\t\t    break;\n\t\t*rowp -= fp->fr_height;\n\t    }\n\t}\n    }\n    // When using a timer that closes a window the window might not actually\n    // exist.\n    FOR_ALL_WINDOWS(wp)\n\tif (wp == fp->fr_win)\n\t{\n#ifdef FEAT_MENU\n\t    *rowp -= wp->w_winbar_height;\n#endif\n\t    return wp;\n\t}\n    return NULL;\n}\n\n#if defined(NEED_VCOL2COL) || defined(FEAT_BEVAL) || defined(FEAT_PROP_POPUP) \\\n\t|| defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Convert a virtual (screen) column to a character column.\n * The first column is one.\n */\n    int\nvcol2col(win_T *wp, linenr_T lnum, int vcol)\n{\n    char_u\t    *line;\n    chartabsize_T   cts;\n\n    // try to advance to the specified column\n    line = ml_get_buf(wp->w_buffer, lnum, FALSE);\n    init_chartabsize_arg(&cts, wp, lnum, 0, line, line);\n    while (cts.cts_vcol < vcol && *cts.cts_ptr != NUL)\n    {\n\tcts.cts_vcol += win_lbr_chartabsize(&cts, NULL);\n\tMB_PTR_ADV(cts.cts_ptr);\n    }\n    clear_chartabsize_arg(&cts);\n\n    return (int)(cts.cts_ptr - line);\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n    void\nf_getmousepos(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    dict_T\t*d;\n    win_T\t*wp;\n    int\t\trow = mouse_row;\n    int\t\tcol = mouse_col;\n    varnumber_T winid = 0;\n    varnumber_T winrow = 0;\n    varnumber_T wincol = 0;\n    linenr_T\tlnum = 0;\n    varnumber_T column = 0;\n\n    if (rettv_dict_alloc(rettv) == FAIL)\n\treturn;\n    d = rettv->vval.v_dict;\n\n    dict_add_number(d, \"screenrow\", (varnumber_T)mouse_row + 1);\n    dict_add_number(d, \"screencol\", (varnumber_T)mouse_col + 1);\n\n    wp = mouse_find_win(&row, &col, FIND_POPUP);\n    if (wp != NULL)\n    {\n\tint\ttop_off = 0;\n\tint\tleft_off = 0;\n\tint\theight = wp->w_height + wp->w_status_height;\n\n#ifdef FEAT_PROP_POPUP\n\tif (WIN_IS_POPUP(wp))\n\t{\n\t    top_off = popup_top_extra(wp);\n\t    left_off = popup_left_extra(wp);\n\t    height = popup_height(wp);\n\t}\n#endif\n\tif (row < height)\n\t{\n\t    winid = wp->w_id;\n\t    winrow = row + 1;\n\t    wincol = col + 1;\n\t    row -= top_off;\n\t    col -= left_off;\n\t    if (row >= 0 && row < wp->w_height && col >= 0 && col < wp->w_width)\n\t    {\n\t\t(void)mouse_comp_pos(wp, &row, &col, &lnum, NULL);\n\t\tcol = vcol2col(wp, lnum, col);\n\t\tcolumn = col + 1;\n\t    }\n\t}\n    }\n    dict_add_number(d, \"winid\", winid);\n    dict_add_number(d, \"winrow\", winrow);\n    dict_add_number(d, \"wincol\", wincol);\n    dict_add_number(d, \"line\", (varnumber_T)lnum);\n    dict_add_number(d, \"column\", column);\n}\n#endif\n", "\" Test for tabline\n\nsource shared.vim\n\nfunc TablineWithCaughtError()\n  let s:func_in_tabline_called = 1\n  try\n    call eval('unknown expression')\n  catch\n  endtry\n  return ''\nendfunc\n\nfunc TablineWithError()\n  let s:func_in_tabline_called = 1\n  call eval('unknown expression')\n  return ''\nendfunc\n\nfunc Test_caught_error_in_tabline()\n  if has('gui')\n    set guioptions-=e\n  endif\n  let showtabline_save = &showtabline\n  set showtabline=2\n  let s:func_in_tabline_called = 0\n  let tabline = '%{TablineWithCaughtError()}'\n  let &tabline = tabline\n  redraw!\n  call assert_true(s:func_in_tabline_called)\n  call assert_equal(tabline, &tabline)\n  set tabline=\n  let &showtabline = showtabline_save\nendfunc\n\nfunc Test_tabline_will_be_disabled_with_error()\n  if has('gui')\n    set guioptions-=e\n  endif\n  let showtabline_save = &showtabline\n  set showtabline=2\n  let s:func_in_tabline_called = 0\n  let tabline = '%{TablineWithError()}'\n  try\n    let &tabline = tabline\n    redraw!\n  catch\n  endtry\n  call assert_true(s:func_in_tabline_called)\n  call assert_equal('', &tabline)\n  set tabline=\n  let &showtabline = showtabline_save\nendfunc\n\nfunc Test_redrawtabline()\n  if has('gui')\n    set guioptions-=e\n  endif\n  let showtabline_save = &showtabline\n  set showtabline=2\n  set tabline=%{bufnr('$')}\n  edit Xtabline1\n  edit Xtabline2\n  redraw\n  call assert_match(bufnr('$') . '', Screenline(1))\n  au BufAdd * redrawtabline\n  badd Xtabline3\n  call assert_match(bufnr('$') . '', Screenline(1))\n\n  set tabline=\n  let &showtabline = showtabline_save\n  au! Bufadd\nendfunc\n\n\" Test for the \"%T\" and \"%X\" flags in the 'tabline' option\nfunc MyTabLine()\n  let s = ''\n  for i in range(tabpagenr('$'))\n    \" set the tab page number (for mouse clicks)\n    let s .= '%' . (i + 1) . 'T'\n\n    \" the label is made by MyTabLabel()\n    let s .= ' %{MyTabLabel(' . (i + 1) . ')} '\n  endfor\n\n  \" after the last tab fill with TabLineFill and reset tab page nr\n  let s .= '%T'\n\n  \" right-align the label to close the current tab page\n  if tabpagenr('$') > 1\n    let s .= '%=%Xclose'\n  endif\n\n  return s\nendfunc\n\nfunc MyTabLabel(n)\n  let buflist = tabpagebuflist(a:n)\n  let winnr = tabpagewinnr(a:n)\n  return bufname(buflist[winnr - 1])\nendfunc\n\nfunc Test_tabline_flags()\n  if has('gui')\n    set guioptions-=e\n  endif\n  set tabline=%!MyTabLine()\n  edit Xtabline1\n  tabnew Xtabline2\n  redrawtabline\n  call assert_match('^ Xtabline1  Xtabline2\\s\\+close$', Screenline(1))\n  set tabline=\n  %bw!\nendfunc\n\nfunction EmptyTabname()\n  return \"\"\nendfunction\n\nfunction MakeTabLine() abort\n  let titles = map(range(1, tabpagenr('$')), '\"%( %\" . v:val . \"T%{EmptyTabname()}%T %)\"')\n  let sep = '\u3042'\n  let tabpages = join(titles, sep)\n  return tabpages .. sep .. '%=%999X X'\nendfunction\n\nfunc Test_tabline_empty_group()\n  \" this was reading invalid memory\n  set tabline=%!MakeTabLine()\n  tabnew\n  redraw!\n\n  tabclose\n  set tabline=\nendfunc\n\n\" When there are exactly 20 tabline format items (the exact size of the\n\" initial tabline items array), test that we don't write beyond the size\n\" of the array.\nfunc Test_tabline_20_format_items_no_overrun()\n  set showtabline=2\n\n  let tabline = repeat('%#StatColorHi2#', 20)\n  let &tabline = tabline\n  redrawtabline\n\n  set showtabline& tabline&\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * mouse.c: mouse handling functions\n */\n\n#include \"vim.h\"\n\n/*\n * Horiziontal and vertical steps used when scrolling.\n * When negative scroll by a whole page.\n */\nstatic long mouse_hor_step = 6;\nstatic long mouse_vert_step = 3;\n\n    void\nmouse_set_vert_scroll_step(long step)\n{\n    mouse_vert_step = step;\n}\n\n    void\nmouse_set_hor_scroll_step(long step)\n{\n    mouse_hor_step = step;\n}\n\n#ifdef CHECK_DOUBLE_CLICK\n/*\n * Return the duration from t1 to t2 in milliseconds.\n */\n    static long\ntime_diff_ms(struct timeval *t1, struct timeval *t2)\n{\n    // This handles wrapping of tv_usec correctly without any special case.\n    // Example of 2 pairs (tv_sec, tv_usec) with a duration of 5 ms:\n    //\t   t1 = (1, 998000) t2 = (2, 3000) gives:\n    //\t   (2 - 1) * 1000 + (3000 - 998000) / 1000 -> 5 ms.\n    return (t2->tv_sec - t1->tv_sec) * 1000\n\t + (t2->tv_usec - t1->tv_usec) / 1000;\n}\n#endif\n\n/*\n * Get class of a character for selection: same class means same word.\n * 0: blank\n * 1: punctuation groups\n * 2: normal word character\n * >2: multi-byte word character.\n */\n    static int\nget_mouse_class(char_u *p)\n{\n    int\t\tc;\n\n    if (has_mbyte && MB_BYTE2LEN(p[0]) > 1)\n\treturn mb_get_class(p);\n\n    c = *p;\n    if (c == ' ' || c == '\\t')\n\treturn 0;\n\n    if (vim_iswordc(c))\n\treturn 2;\n\n    // There are a few special cases where we want certain combinations of\n    // characters to be considered as a single word.  These are things like\n    // \"->\", \"/ *\", \"*=\", \"+=\", \"&=\", \"<=\", \">=\", \"!=\" etc.  Otherwise, each\n    // character is in its own class.\n    if (c != NUL && vim_strchr((char_u *)\"-+*/%<>&|^!=\", c) != NULL)\n\treturn 1;\n    return c;\n}\n\n/*\n * Move \"pos\" back to the start of the word it's in.\n */\n    static void\nfind_start_of_word(pos_T *pos)\n{\n    char_u\t*line;\n    int\t\tcclass;\n    int\t\tcol;\n\n    line = ml_get(pos->lnum);\n    cclass = get_mouse_class(line + pos->col);\n\n    while (pos->col > 0)\n    {\n\tcol = pos->col - 1;\n\tcol -= (*mb_head_off)(line, line + col);\n\tif (get_mouse_class(line + col) != cclass)\n\t    break;\n\tpos->col = col;\n    }\n}\n\n/*\n * Move \"pos\" forward to the end of the word it's in.\n * When 'selection' is \"exclusive\", the position is just after the word.\n */\n    static void\nfind_end_of_word(pos_T *pos)\n{\n    char_u\t*line;\n    int\t\tcclass;\n    int\t\tcol;\n\n    line = ml_get(pos->lnum);\n    if (*p_sel == 'e' && pos->col > 0)\n    {\n\t--pos->col;\n\tpos->col -= (*mb_head_off)(line, line + pos->col);\n    }\n    cclass = get_mouse_class(line + pos->col);\n    while (line[pos->col] != NUL)\n    {\n\tcol = pos->col + (*mb_ptr2len)(line + pos->col);\n\tif (get_mouse_class(line + col) != cclass)\n\t{\n\t    if (*p_sel == 'e')\n\t\tpos->col = col;\n\t    break;\n\t}\n\tpos->col = col;\n    }\n}\n\n#if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) \\\n\t    || defined(FEAT_GUI_MSWIN) \\\n\t    || defined(FEAT_GUI_PHOTON) \\\n\t    || defined(FEAT_TERM_POPUP_MENU)\n# define USE_POPUP_SETPOS\n# define NEED_VCOL2COL\n\n/*\n * Translate window coordinates to buffer position without any side effects\n */\n    static int\nget_fpos_of_mouse(pos_T *mpos)\n{\n    win_T\t*wp;\n    int\t\trow = mouse_row;\n    int\t\tcol = mouse_col;\n\n    if (row < 0 || col < 0)\t\t// check if it makes sense\n\treturn IN_UNKNOWN;\n\n    // find the window where the row is in\n    wp = mouse_find_win(&row, &col, FAIL_POPUP);\n    if (wp == NULL)\n\treturn IN_UNKNOWN;\n    // winpos and height may change in win_enter()!\n    if (row >= wp->w_height)\t// In (or below) status line\n\treturn IN_STATUS_LINE;\n    if (col >= wp->w_width)\t// In vertical separator line\n\treturn IN_SEP_LINE;\n\n    if (wp != curwin)\n\treturn IN_UNKNOWN;\n\n    // compute the position in the buffer line from the posn on the screen\n    if (mouse_comp_pos(curwin, &row, &col, &mpos->lnum, NULL))\n\treturn IN_STATUS_LINE; // past bottom\n\n    mpos->col = vcol2col(wp, mpos->lnum, col);\n\n    if (mpos->col > 0)\n\t--mpos->col;\n    mpos->coladd = 0;\n    return IN_BUFFER;\n}\n#endif\n\n/*\n * Do the appropriate action for the current mouse click in the current mode.\n * Not used for Command-line mode.\n *\n * Normal and Visual Mode:\n * event\t modi-\tposition      visual\t   change   action\n *\t\t fier\tcursor\t\t\t   window\n * left press\t  -\tyes\t    end\t\t    yes\n * left press\t  C\tyes\t    end\t\t    yes\t    \"^]\" (2)\n * left press\t  S\tyes\tend (popup: extend) yes\t    \"*\" (2)\n * left drag\t  -\tyes\tstart if moved\t    no\n * left relse\t  -\tyes\tstart if moved\t    no\n * middle press\t  -\tyes\t if not active\t    no\t    put register\n * middle press\t  -\tyes\t if active\t    no\t    yank and put\n * right press\t  -\tyes\tstart or extend\t    yes\n * right press\t  S\tyes\tno change\t    yes\t    \"#\" (2)\n * right drag\t  -\tyes\textend\t\t    no\n * right relse\t  -\tyes\textend\t\t    no\n *\n * Insert or Replace Mode:\n * event\t modi-\tposition      visual\t   change   action\n *\t\t fier\tcursor\t\t\t   window\n * left press\t  -\tyes\t(cannot be active)  yes\n * left press\t  C\tyes\t(cannot be active)  yes\t    \"CTRL-O^]\" (2)\n * left press\t  S\tyes\t(cannot be active)  yes\t    \"CTRL-O*\" (2)\n * left drag\t  -\tyes\tstart or extend (1) no\t    CTRL-O (1)\n * left relse\t  -\tyes\tstart or extend (1) no\t    CTRL-O (1)\n * middle press\t  -\tno\t(cannot be active)  no\t    put register\n * right press\t  -\tyes\tstart or extend\t    yes\t    CTRL-O\n * right press\t  S\tyes\t(cannot be active)  yes\t    \"CTRL-O#\" (2)\n *\n * (1) only if mouse pointer moved since press\n * (2) only if click is in same buffer\n *\n * Return TRUE if start_arrow() should be called for edit mode.\n */\n    int\ndo_mouse(\n    oparg_T\t*oap,\t\t// operator argument, can be NULL\n    int\t\tc,\t\t// K_LEFTMOUSE, etc\n    int\t\tdir,\t\t// Direction to 'put' if necessary\n    long\tcount,\n    int\t\tfixindent)\t// PUT_FIXINDENT if fixing indent necessary\n{\n    static int\tdo_always = FALSE;\t// ignore 'mouse' setting next time\n    static int\tgot_click = FALSE;\t// got a click some time back\n\n    int\t\twhich_button;\t// MOUSE_LEFT, _MIDDLE or _RIGHT\n    int\t\tis_click = FALSE; // If FALSE it's a drag or release event\n    int\t\tis_drag = FALSE;  // If TRUE it's a drag event\n    int\t\tjump_flags = 0;\t// flags for jump_to_mouse()\n    pos_T\tstart_visual;\n    int\t\tmoved;\t\t// Has cursor moved?\n    int\t\tin_status_line;\t// mouse in status line\n    static int\tin_tab_line = FALSE; // mouse clicked in tab line\n    int\t\tin_sep_line;\t// mouse in vertical separator line\n    int\t\tc1, c2;\n#if defined(FEAT_FOLDING)\n    pos_T\tsave_cursor;\n#endif\n    win_T\t*old_curwin = curwin;\n    static pos_T orig_cursor;\n    colnr_T\tleftcol, rightcol;\n    pos_T\tend_visual;\n    int\t\tdiff;\n    int\t\told_active = VIsual_active;\n    int\t\told_mode = VIsual_mode;\n    int\t\tregname;\n\n#if defined(FEAT_FOLDING)\n    save_cursor = curwin->w_cursor;\n#endif\n\n    // When GUI is active, always recognize mouse events, otherwise:\n    // - Ignore mouse event in normal mode if 'mouse' doesn't include 'n'.\n    // - Ignore mouse event in visual mode if 'mouse' doesn't include 'v'.\n    // - For command line and insert mode 'mouse' is checked before calling\n    //\t do_mouse().\n    if (do_always)\n\tdo_always = FALSE;\n    else\n#ifdef FEAT_GUI\n\tif (!gui.in_use)\n#endif\n\t{\n\t    if (VIsual_active)\n\t    {\n\t\tif (!mouse_has(MOUSE_VISUAL))\n\t\t    return FALSE;\n\t    }\n\t    else if (State == MODE_NORMAL && !mouse_has(MOUSE_NORMAL))\n\t\treturn FALSE;\n\t}\n\n    for (;;)\n    {\n\twhich_button = get_mouse_button(KEY2TERMCAP1(c), &is_click, &is_drag);\n\tif (is_drag)\n\t{\n\t    // If the next character is the same mouse event then use that\n\t    // one. Speeds up dragging the status line.\n\t    // Note: Since characters added to the stuff buffer in the code\n\t    // below need to come before the next character, do not do this\n\t    // when the current character was stuffed.\n\t    if (!KeyStuffed && vpeekc() != NUL)\n\t    {\n\t\tint nc;\n\t\tint save_mouse_row = mouse_row;\n\t\tint save_mouse_col = mouse_col;\n\n\t\t// Need to get the character, peeking doesn't get the actual\n\t\t// one.\n\t\tnc = safe_vgetc();\n\t\tif (c == nc)\n\t\t    continue;\n\t\tvungetc(nc);\n\t\tmouse_row = save_mouse_row;\n\t\tmouse_col = save_mouse_col;\n\t    }\n\t}\n\tbreak;\n    }\n\n    if (c == K_MOUSEMOVE)\n    {\n\t// Mouse moved without a button pressed.\n#ifdef FEAT_BEVAL_TERM\n\tui_may_remove_balloon();\n\tif (p_bevalterm)\n\t{\n\t    profile_setlimit(p_bdlay, &bevalexpr_due);\n\t    bevalexpr_due_set = TRUE;\n\t}\n#endif\n#ifdef FEAT_PROP_POPUP\n\tpopup_handle_mouse_moved();\n#endif\n\treturn FALSE;\n    }\n\n#ifdef FEAT_MOUSESHAPE\n    // May have stopped dragging the status or separator line.  The pointer is\n    // most likely still on the status or separator line.\n    if (!is_drag && drag_status_line)\n    {\n\tdrag_status_line = FALSE;\n\tupdate_mouseshape(SHAPE_IDX_STATUS);\n    }\n    if (!is_drag && drag_sep_line)\n    {\n\tdrag_sep_line = FALSE;\n\tupdate_mouseshape(SHAPE_IDX_VSEP);\n    }\n#endif\n\n    // Ignore drag and release events if we didn't get a click.\n    if (is_click)\n\tgot_click = TRUE;\n    else\n    {\n\tif (!got_click)\t\t\t// didn't get click, ignore\n\t    return FALSE;\n\tif (!is_drag)\t\t\t// release, reset got_click\n\t{\n\t    got_click = FALSE;\n\t    if (in_tab_line)\n\t    {\n\t\tin_tab_line = FALSE;\n\t\treturn FALSE;\n\t    }\n\t}\n    }\n\n    // CTRL right mouse button does CTRL-T\n    if (is_click && (mod_mask & MOD_MASK_CTRL) && which_button == MOUSE_RIGHT)\n    {\n\tif (State & MODE_INSERT)\n\t    stuffcharReadbuff(Ctrl_O);\n\tif (count > 1)\n\t    stuffnumReadbuff(count);\n\tstuffcharReadbuff(Ctrl_T);\n\tgot_click = FALSE;\t\t// ignore drag&release now\n\treturn FALSE;\n    }\n\n    // CTRL only works with left mouse button\n    if ((mod_mask & MOD_MASK_CTRL) && which_button != MOUSE_LEFT)\n\treturn FALSE;\n\n    // When a modifier is down, ignore drag and release events, as well as\n    // multiple clicks and the middle mouse button.\n    // Accept shift-leftmouse drags when 'mousemodel' is \"popup.*\".\n    if ((mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT\n\t\t\t\t\t\t\t     | MOD_MASK_META))\n\t    && (!is_click\n\t\t|| (mod_mask & MOD_MASK_MULTI_CLICK)\n\t\t|| which_button == MOUSE_MIDDLE)\n\t    && !((mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT))\n\t\t&& mouse_model_popup()\n\t\t&& which_button == MOUSE_LEFT)\n\t    && !((mod_mask & MOD_MASK_ALT)\n\t\t&& !mouse_model_popup()\n\t\t&& which_button == MOUSE_RIGHT)\n\t    )\n\treturn FALSE;\n\n    // If the button press was used as the movement command for an operator\n    // (eg \"d<MOUSE>\"), or it is the middle button that is held down, ignore\n    // drag/release events.\n    if (!is_click && which_button == MOUSE_MIDDLE)\n\treturn FALSE;\n\n    if (oap != NULL)\n\tregname = oap->regname;\n    else\n\tregname = 0;\n\n    // Middle mouse button does a 'put' of the selected text\n    if (which_button == MOUSE_MIDDLE)\n    {\n\tif (State == MODE_NORMAL)\n\t{\n\t    // If an operator was pending, we don't know what the user wanted\n\t    // to do. Go back to normal mode: Clear the operator and beep().\n\t    if (oap != NULL && oap->op_type != OP_NOP)\n\t    {\n\t\tclearopbeep(oap);\n\t\treturn FALSE;\n\t    }\n\n\t    // If visual was active, yank the highlighted text and put it\n\t    // before the mouse pointer position.\n\t    // In Select mode replace the highlighted text with the clipboard.\n\t    if (VIsual_active)\n\t    {\n\t\tif (VIsual_select)\n\t\t{\n\t\t    stuffcharReadbuff(Ctrl_G);\n\t\t    stuffReadbuff((char_u *)\"\\\"+p\");\n\t\t}\n\t\telse\n\t\t{\n\t\t    stuffcharReadbuff('y');\n\t\t    stuffcharReadbuff(K_MIDDLEMOUSE);\n\t\t}\n\t\tdo_always = TRUE;\t// ignore 'mouse' setting next time\n\t\treturn FALSE;\n\t    }\n\t    // The rest is below jump_to_mouse()\n\t}\n\n\telse if ((State & MODE_INSERT) == 0)\n\t    return FALSE;\n\n\t// Middle click in insert mode doesn't move the mouse, just insert the\n\t// contents of a register.  '.' register is special, can't insert that\n\t// with do_put().\n\t// Also paste at the cursor if the current mode isn't in 'mouse' (only\n\t// happens for the GUI).\n\tif ((State & MODE_INSERT) || !mouse_has(MOUSE_NORMAL))\n\t{\n\t    if (regname == '.')\n\t\tinsert_reg(regname, TRUE);\n\t    else\n\t    {\n#ifdef FEAT_CLIPBOARD\n\t\tif (clip_star.available && regname == 0)\n\t\t    regname = '*';\n#endif\n\t\tif ((State & REPLACE_FLAG) && !yank_register_mline(regname))\n\t\t    insert_reg(regname, TRUE);\n\t\telse\n\t\t{\n\t\t    do_put(regname, NULL, BACKWARD, 1L,\n\t\t\t\t\t\t      fixindent | PUT_CURSEND);\n\n\t\t    // Repeat it with CTRL-R CTRL-O r or CTRL-R CTRL-P r\n\t\t    AppendCharToRedobuff(Ctrl_R);\n\t\t    AppendCharToRedobuff(fixindent ? Ctrl_P : Ctrl_O);\n\t\t    AppendCharToRedobuff(regname == 0 ? '\"' : regname);\n\t\t}\n\t    }\n\t    return FALSE;\n\t}\n    }\n\n    // When dragging or button-up stay in the same window.\n    if (!is_click)\n\tjump_flags |= MOUSE_FOCUS | MOUSE_DID_MOVE;\n\n    start_visual.lnum = 0;\n\n    if (TabPageIdxs != NULL)  // only when initialized\n    {\n\t// Check for clicking in the tab page line.\n\tif (mouse_row == 0 && firstwin->w_winrow > 0)\n\t{\n\t    if (is_drag)\n\t    {\n\t\tif (in_tab_line)\n\t\t{\n\t\t    c1 = TabPageIdxs[mouse_col];\n\t\t    tabpage_move(c1 <= 0 ? 9999 : c1 < tabpage_index(curtab)\n\t\t\t\t\t\t\t\t    ? c1 - 1 : c1);\n\t\t}\n\t\treturn FALSE;\n\t    }\n\n\t    // click in a tab selects that tab page\n\t    if (is_click\n# ifdef FEAT_CMDWIN\n\t\t    && cmdwin_type == 0\n# endif\n\t\t    && mouse_col < Columns)\n\t    {\n\t\tin_tab_line = TRUE;\n\t\tc1 = TabPageIdxs[mouse_col];\n\t\tif (c1 >= 0)\n\t\t{\n\t\t    if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t\t    {\n\t\t\t// double click opens new page\n\t\t\tend_visual_mode_keep_button();\n\t\t\ttabpage_new();\n\t\t\ttabpage_move(c1 == 0 ? 9999 : c1 - 1);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Go to specified tab page, or next one if not clicking\n\t\t\t// on a label.\n\t\t\tgoto_tabpage(c1);\n\n\t\t\t// It's like clicking on the status line of a window.\n\t\t\tif (curwin != old_curwin)\n\t\t\t    end_visual_mode_keep_button();\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    tabpage_T\t*tp;\n\n\t\t    // Close the current or specified tab page.\n\t\t    if (c1 == -999)\n\t\t\ttp = curtab;\n\t\t    else\n\t\t\ttp = find_tabpage(-c1);\n\t\t    if (tp == curtab)\n\t\t    {\n\t\t\tif (first_tabpage->tp_next != NULL)\n\t\t\t    tabpage_close(FALSE);\n\t\t    }\n\t\t    else if (tp != NULL)\n\t\t\ttabpage_close_other(tp, FALSE);\n\t\t}\n\t    }\n\t    return TRUE;\n\t}\n\telse if (is_drag && in_tab_line)\n\t{\n\t    c1 = TabPageIdxs[mouse_col];\n\t    tabpage_move(c1 <= 0 ? 9999 : c1 - 1);\n\t    return FALSE;\n\t}\n    }\n\n    // When 'mousemodel' is \"popup\" or \"popup_setpos\", translate mouse events:\n    // right button up   -> pop-up menu\n    // shift-left button -> right button\n    // alt-left button   -> alt-right button\n    if (mouse_model_popup())\n    {\n\tif (which_button == MOUSE_RIGHT\n\t\t\t    && !(mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)))\n\t{\n#ifdef USE_POPUP_SETPOS\n# ifdef FEAT_GUI\n\t    if (gui.in_use)\n\t    {\n#  if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) \\\n\t\t\t  || defined(FEAT_GUI_PHOTON)\n\t\tif (!is_click)\n\t\t    // Ignore right button release events, only shows the popup\n\t\t    // menu on the button down event.\n\t\t    return FALSE;\n#  endif\n#  if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_HAIKU)\n\t\tif (is_click || is_drag)\n\t\t    // Ignore right button down and drag mouse events.  Windows\n\t\t    // only shows the popup menu on the button up event.\n\t\t    return FALSE;\n#  endif\n\t    }\n# endif\n# if defined(FEAT_GUI) && defined(FEAT_TERM_POPUP_MENU)\n\t    else\n# endif\n# if defined(FEAT_TERM_POPUP_MENU)\n\t    if (!is_click)\n\t\t// Ignore right button release events, only shows the popup\n\t\t// menu on the button down event.\n\t\treturn FALSE;\n#endif\n\n\t    jump_flags = 0;\n\t    if (STRCMP(p_mousem, \"popup_setpos\") == 0)\n\t    {\n\t\t// First set the cursor position before showing the popup\n\t\t// menu.\n\t\tif (VIsual_active)\n\t\t{\n\t\t    pos_T    m_pos;\n\n\t\t    // set MOUSE_MAY_STOP_VIS if we are outside the\n\t\t    // selection or the current window (might have false\n\t\t    // negative here)\n\t\t    if (mouse_row < curwin->w_winrow\n\t\t\t || mouse_row\n\t\t\t\t  > (curwin->w_winrow + curwin->w_height))\n\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\t\t    else if (get_fpos_of_mouse(&m_pos) != IN_BUFFER)\n\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\t\t    else\n\t\t    {\n\t\t\tif ((LT_POS(curwin->w_cursor, VIsual)\n\t\t\t\t    && (LT_POS(m_pos, curwin->w_cursor)\n\t\t\t\t\t|| LT_POS(VIsual, m_pos)))\n\t\t\t\t|| (LT_POS(VIsual, curwin->w_cursor)\n\t\t\t\t    && (LT_POS(m_pos, VIsual)\n\t\t\t\t      || LT_POS(curwin->w_cursor, m_pos))))\n\t\t\t{\n\t\t\t    jump_flags = MOUSE_MAY_STOP_VIS;\n\t\t\t}\n\t\t\telse if (VIsual_mode == Ctrl_V)\n\t\t\t{\n\t\t\t    getvcols(curwin, &curwin->w_cursor, &VIsual,\n\t\t\t\t\t\t     &leftcol, &rightcol);\n\t\t\t    getvcol(curwin, &m_pos, NULL, &m_pos.col, NULL);\n\t\t\t    if (m_pos.col < leftcol || m_pos.col > rightcol)\n\t\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    jump_flags = MOUSE_MAY_STOP_VIS;\n\t    }\n\t    if (jump_flags)\n\t    {\n\t\tjump_flags = jump_to_mouse(jump_flags, NULL, which_button);\n\t\tupdate_curbuf(VIsual_active ? UPD_INVERTED : UPD_VALID);\n\t\tsetcursor();\n\t\tout_flush();    // Update before showing popup menu\n\t    }\n# ifdef FEAT_MENU\n\t    show_popupmenu();\n\t    got_click = FALSE;\t// ignore release events\n# endif\n\t    return (jump_flags & CURSOR_MOVED) != 0;\n#else\n\t    return FALSE;\n#endif\n\t}\n\tif (which_button == MOUSE_LEFT\n\t\t\t\t&& (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT)))\n\t{\n\t    which_button = MOUSE_RIGHT;\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n    if ((State & (MODE_NORMAL | MODE_INSERT))\n\t\t\t    && !(mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)))\n    {\n\tif (which_button == MOUSE_LEFT)\n\t{\n\t    if (is_click)\n\t    {\n\t\t// stop Visual mode for a left click in a window, but not when\n\t\t// on a status line\n\t\tif (VIsual_active)\n\t\t    jump_flags |= MOUSE_MAY_STOP_VIS;\n\t    }\n\t    else if (mouse_has(MOUSE_VISUAL))\n\t\tjump_flags |= MOUSE_MAY_VIS;\n\t}\n\telse if (which_button == MOUSE_RIGHT)\n\t{\n\t    if (is_click && VIsual_active)\n\t    {\n\t\t// Remember the start and end of visual before moving the\n\t\t// cursor.\n\t\tif (LT_POS(curwin->w_cursor, VIsual))\n\t\t{\n\t\t    start_visual = curwin->w_cursor;\n\t\t    end_visual = VIsual;\n\t\t}\n\t\telse\n\t\t{\n\t\t    start_visual = VIsual;\n\t\t    end_visual = curwin->w_cursor;\n\t\t}\n\t    }\n\t    jump_flags |= MOUSE_FOCUS;\n\t    if (mouse_has(MOUSE_VISUAL))\n\t\tjump_flags |= MOUSE_MAY_VIS;\n\t}\n    }\n\n    // If an operator is pending, ignore all drags and releases until the\n    // next mouse click.\n    if (!is_drag && oap != NULL && oap->op_type != OP_NOP)\n    {\n\tgot_click = FALSE;\n\toap->motion_type = MCHAR;\n    }\n\n    // When releasing the button let jump_to_mouse() know.\n    if (!is_click && !is_drag)\n\tjump_flags |= MOUSE_RELEASED;\n\n    // JUMP!\n    jump_flags = jump_to_mouse(jump_flags,\n\t\t\toap == NULL ? NULL : &(oap->inclusive), which_button);\n\n#ifdef FEAT_MENU\n    // A click in the window toolbar has no side effects.\n    if (jump_flags & MOUSE_WINBAR)\n\treturn FALSE;\n#endif\n    moved = (jump_flags & CURSOR_MOVED);\n    in_status_line = (jump_flags & IN_STATUS_LINE);\n    in_sep_line = (jump_flags & IN_SEP_LINE);\n\n#ifdef FEAT_NETBEANS_INTG\n    if (isNetbeansBuffer(curbuf)\n\t\t\t    && !(jump_flags & (IN_STATUS_LINE | IN_SEP_LINE)))\n    {\n\tint key = KEY2TERMCAP1(c);\n\n\tif (key == (int)KE_LEFTRELEASE || key == (int)KE_MIDDLERELEASE\n\t\t\t\t\t       || key == (int)KE_RIGHTRELEASE)\n\t    netbeans_button_release(which_button);\n    }\n#endif\n\n    // When jumping to another window, clear a pending operator.  That's a bit\n    // friendlier than beeping and not jumping to that window.\n    if (curwin != old_curwin && oap != NULL && oap->op_type != OP_NOP)\n\tclearop(oap);\n\n#ifdef FEAT_FOLDING\n    if (mod_mask == 0\n\t    && !is_drag\n\t    && (jump_flags & (MOUSE_FOLD_CLOSE | MOUSE_FOLD_OPEN))\n\t    && which_button == MOUSE_LEFT)\n    {\n\t// open or close a fold at this line\n\tif (jump_flags & MOUSE_FOLD_OPEN)\n\t    openFold(curwin->w_cursor.lnum, 1L);\n\telse\n\t    closeFold(curwin->w_cursor.lnum, 1L);\n\t// don't move the cursor if still in the same window\n\tif (curwin == old_curwin)\n\t    curwin->w_cursor = save_cursor;\n    }\n#endif\n\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_CMDWIN)\n    if ((jump_flags & IN_OTHER_WIN) && !VIsual_active && clip_star.available)\n    {\n\tclip_modeless(which_button, is_click, is_drag);\n\treturn FALSE;\n    }\n#endif\n\n    // Set global flag that we are extending the Visual area with mouse\n    // dragging; temporarily minimize 'scrolloff'.\n    if (VIsual_active && is_drag && get_scrolloff_value())\n    {\n\t// In the very first line, allow scrolling one line\n\tif (mouse_row == 0)\n\t    mouse_dragging = 2;\n\telse\n\t    mouse_dragging = 1;\n    }\n\n    // When dragging the mouse above the window, scroll down.\n    if (is_drag && mouse_row < 0 && !in_status_line)\n    {\n\tscroll_redraw(FALSE, 1L);\n\tmouse_row = 0;\n    }\n\n    if (start_visual.lnum)\t\t// right click in visual mode\n    {\n       // When ALT is pressed make Visual mode blockwise.\n       if (mod_mask & MOD_MASK_ALT)\n\t   VIsual_mode = Ctrl_V;\n\n\t// In Visual-block mode, divide the area in four, pick up the corner\n\t// that is in the quarter that the cursor is in.\n\tif (VIsual_mode == Ctrl_V)\n\t{\n\t    getvcols(curwin, &start_visual, &end_visual, &leftcol, &rightcol);\n\t    if (curwin->w_curswant > (leftcol + rightcol) / 2)\n\t\tend_visual.col = leftcol;\n\t    else\n\t\tend_visual.col = rightcol;\n\t    if (curwin->w_cursor.lnum >=\n\t\t\t\t    (start_visual.lnum + end_visual.lnum) / 2)\n\t\tend_visual.lnum = start_visual.lnum;\n\n\t    // move VIsual to the right column\n\t    start_visual = curwin->w_cursor;\t    // save the cursor pos\n\t    curwin->w_cursor = end_visual;\n\t    coladvance(end_visual.col);\n\t    VIsual = curwin->w_cursor;\n\t    curwin->w_cursor = start_visual;\t    // restore the cursor\n\t}\n\telse\n\t{\n\t    // If the click is before the start of visual, change the start.\n\t    // If the click is after the end of visual, change the end.  If\n\t    // the click is inside the visual, change the closest side.\n\t    if (LT_POS(curwin->w_cursor, start_visual))\n\t\tVIsual = end_visual;\n\t    else if (LT_POS(end_visual, curwin->w_cursor))\n\t\tVIsual = start_visual;\n\t    else\n\t    {\n\t\t// In the same line, compare column number\n\t\tif (end_visual.lnum == start_visual.lnum)\n\t\t{\n\t\t    if (curwin->w_cursor.col - start_visual.col >\n\t\t\t\t    end_visual.col - curwin->w_cursor.col)\n\t\t\tVIsual = start_visual;\n\t\t    else\n\t\t\tVIsual = end_visual;\n\t\t}\n\n\t\t// In different lines, compare line number\n\t\telse\n\t\t{\n\t\t    diff = (curwin->w_cursor.lnum - start_visual.lnum) -\n\t\t\t\t(end_visual.lnum - curwin->w_cursor.lnum);\n\n\t\t    if (diff > 0)\t\t// closest to end\n\t\t\tVIsual = start_visual;\n\t\t    else if (diff < 0)\t// closest to start\n\t\t\tVIsual = end_visual;\n\t\t    else\t\t\t// in the middle line\n\t\t    {\n\t\t\tif (curwin->w_cursor.col <\n\t\t\t\t\t(start_visual.col + end_visual.col) / 2)\n\t\t\t    VIsual = end_visual;\n\t\t\telse\n\t\t\t    VIsual = start_visual;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    // If Visual mode started in insert mode, execute \"CTRL-O\"\n    else if ((State & MODE_INSERT) && VIsual_active)\n\tstuffcharReadbuff(Ctrl_O);\n\n    // Middle mouse click: Put text before cursor.\n    if (which_button == MOUSE_MIDDLE)\n    {\n#ifdef FEAT_CLIPBOARD\n\tif (clip_star.available && regname == 0)\n\t    regname = '*';\n#endif\n\tif (yank_register_mline(regname))\n\t{\n\t    if (mouse_past_bottom)\n\t\tdir = FORWARD;\n\t}\n\telse if (mouse_past_eol)\n\t    dir = FORWARD;\n\n\tif (fixindent)\n\t{\n\t    c1 = (dir == BACKWARD) ? '[' : ']';\n\t    c2 = 'p';\n\t}\n\telse\n\t{\n\t    c1 = (dir == FORWARD) ? 'p' : 'P';\n\t    c2 = NUL;\n\t}\n\tprep_redo(regname, count, NUL, c1, NUL, c2, NUL);\n\n\t// Remember where the paste started, so in edit() Insstart can be set\n\t// to this position\n\tif (restart_edit != 0)\n\t    where_paste_started = curwin->w_cursor;\n\tdo_put(regname, NULL, dir, count, fixindent | PUT_CURSEND);\n    }\n\n#if defined(FEAT_QUICKFIX)\n    // Ctrl-Mouse click or double click in a quickfix window jumps to the\n    // error under the mouse pointer.\n    else if (((mod_mask & MOD_MASK_CTRL)\n\t\t|| (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t    && bt_quickfix(curbuf))\n    {\n\tif (curwin->w_llist_ref == NULL)\t// quickfix window\n\t    do_cmdline_cmd((char_u *)\".cc\");\n\telse\t\t\t\t\t// location list window\n\t    do_cmdline_cmd((char_u *)\".ll\");\n\tgot_click = FALSE;\t\t// ignore drag&release now\n    }\n#endif\n\n    // Ctrl-Mouse click (or double click in a help window) jumps to the tag\n    // under the mouse pointer.\n    else if ((mod_mask & MOD_MASK_CTRL) || (curbuf->b_help\n\t\t     && (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK))\n    {\n\tif (State & MODE_INSERT)\n\t    stuffcharReadbuff(Ctrl_O);\n\tstuffcharReadbuff(Ctrl_RSB);\n\tgot_click = FALSE;\t\t// ignore drag&release now\n    }\n\n    // Shift-Mouse click searches for the next occurrence of the word under\n    // the mouse pointer\n    else if ((mod_mask & MOD_MASK_SHIFT))\n    {\n\tif ((State & MODE_INSERT) || (VIsual_active && VIsual_select))\n\t    stuffcharReadbuff(Ctrl_O);\n\tif (which_button == MOUSE_LEFT)\n\t    stuffcharReadbuff('*');\n\telse\t// MOUSE_RIGHT\n\t    stuffcharReadbuff('#');\n    }\n\n    // Handle double clicks, unless on status line\n    else if (in_status_line)\n    {\n#ifdef FEAT_MOUSESHAPE\n\tif ((is_drag || is_click) && !drag_status_line)\n\t{\n\t    drag_status_line = TRUE;\n\t    update_mouseshape(-1);\n\t}\n#endif\n    }\n    else if (in_sep_line)\n    {\n#ifdef FEAT_MOUSESHAPE\n\tif ((is_drag || is_click) && !drag_sep_line)\n\t{\n\t    drag_sep_line = TRUE;\n\t    update_mouseshape(-1);\n\t}\n#endif\n    }\n    else if ((mod_mask & MOD_MASK_MULTI_CLICK)\n\t\t\t\t       && (State & (MODE_NORMAL | MODE_INSERT))\n\t     && mouse_has(MOUSE_VISUAL))\n    {\n\tif (is_click || !VIsual_active)\n\t{\n\t    if (VIsual_active)\n\t\torig_cursor = VIsual;\n\t    else\n\t    {\n\t\tcheck_visual_highlight();\n\t\tVIsual = curwin->w_cursor;\n\t\torig_cursor = VIsual;\n\t\tVIsual_active = TRUE;\n\t\tVIsual_reselect = TRUE;\n\t\t// start Select mode if 'selectmode' contains \"mouse\"\n\t\tmay_start_select('o');\n\t\tsetmouse();\n\t    }\n\t    if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t    {\n\t\t// Double click with ALT pressed makes it blockwise.\n\t\tif (mod_mask & MOD_MASK_ALT)\n\t\t    VIsual_mode = Ctrl_V;\n\t\telse\n\t\t    VIsual_mode = 'v';\n\t    }\n\t    else if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_3CLICK)\n\t\tVIsual_mode = 'V';\n\t    else if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_4CLICK)\n\t\tVIsual_mode = Ctrl_V;\n#ifdef FEAT_CLIPBOARD\n\t    // Make sure the clipboard gets updated.  Needed because start and\n\t    // end may still be the same, and the selection needs to be owned\n\t    clip_star.vmode = NUL;\n#endif\n\t}\n\t// A double click selects a word or a block.\n\tif ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t{\n\t    pos_T\t*pos = NULL;\n\t    int\t\tgc;\n\n\t    if (is_click)\n\t    {\n\t\t// If the character under the cursor (skipping white space) is\n\t\t// not a word character, try finding a match and select a (),\n\t\t// {}, [], #if/#endif, etc. block.\n\t\tend_visual = curwin->w_cursor;\n\t\twhile (gc = gchar_pos(&end_visual), VIM_ISWHITE(gc))\n\t\t    inc(&end_visual);\n\t\tif (oap != NULL)\n\t\t    oap->motion_type = MCHAR;\n\t\tif (oap != NULL\n\t\t\t&& VIsual_mode == 'v'\n\t\t\t&& !vim_iswordc(gchar_pos(&end_visual))\n\t\t\t&& EQUAL_POS(curwin->w_cursor, VIsual)\n\t\t\t&& (pos = findmatch(oap, NUL)) != NULL)\n\t\t{\n\t\t    curwin->w_cursor = *pos;\n\t\t    if (oap->motion_type == MLINE)\n\t\t\tVIsual_mode = 'V';\n\t\t    else if (*p_sel == 'e')\n\t\t    {\n\t\t\tif (LT_POS(curwin->w_cursor, VIsual))\n\t\t\t    ++VIsual.col;\n\t\t\telse\n\t\t\t    ++curwin->w_cursor.col;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (pos == NULL && (is_click || is_drag))\n\t    {\n\t\t// When not found a match or when dragging: extend to include\n\t\t// a word.\n\t\tif (LT_POS(curwin->w_cursor, orig_cursor))\n\t\t{\n\t\t    find_start_of_word(&curwin->w_cursor);\n\t\t    find_end_of_word(&VIsual);\n\t\t}\n\t\telse\n\t\t{\n\t\t    find_start_of_word(&VIsual);\n\t\t    if (*p_sel == 'e' && *ml_get_cursor() != NUL)\n\t\t\tcurwin->w_cursor.col +=\n\t\t\t\t\t (*mb_ptr2len)(ml_get_cursor());\n\t\t    find_end_of_word(&curwin->w_cursor);\n\t\t}\n\t    }\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\tif (is_click)\n\t    redraw_curbuf_later(UPD_INVERTED);\t// update the inversion\n    }\n    else if (VIsual_active && !old_active)\n    {\n\tif (mod_mask & MOD_MASK_ALT)\n\t    VIsual_mode = Ctrl_V;\n\telse\n\t    VIsual_mode = 'v';\n    }\n\n    // If Visual mode changed show it later.\n    if ((!VIsual_active && old_active && mode_displayed)\n\t    || (VIsual_active && p_smd && msg_silent == 0\n\t\t\t\t && (!old_active || VIsual_mode != old_mode)))\n\tredraw_cmdline = TRUE;\n\n    return moved;\n}\n\n    void\nins_mouse(int c)\n{\n    pos_T\ttpos;\n    win_T\t*old_curwin = curwin;\n\n# ifdef FEAT_GUI\n    // When GUI is active, also move/paste when 'mouse' is empty\n    if (!gui.in_use)\n# endif\n\tif (!mouse_has(MOUSE_INSERT))\n\t    return;\n\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (do_mouse(NULL, c, BACKWARD, 1L, 0))\n    {\n\twin_T\t*new_curwin = curwin;\n\n\tif (curwin != old_curwin && win_valid(old_curwin))\n\t{\n\t    // Mouse took us to another window.  We need to go back to the\n\t    // previous one to stop insert there properly.\n\t    curwin = old_curwin;\n\t    curbuf = curwin->w_buffer;\n#ifdef FEAT_JOB_CHANNEL\n\t    if (bt_prompt(curbuf))\n\t\t// Restart Insert mode when re-entering the prompt buffer.\n\t\tcurbuf->b_prompt_insert = 'A';\n#endif\n\t}\n\tstart_arrow(curwin == old_curwin ? &tpos : NULL);\n\tif (curwin != new_curwin && win_valid(new_curwin))\n\t{\n\t    curwin = new_curwin;\n\t    curbuf = curwin->w_buffer;\n\t}\n\tset_can_cindent(TRUE);\n    }\n\n    // redraw status lines (in case another window became active)\n    redraw_statuslines();\n}\n\n    void\nins_mousescroll(int dir)\n{\n    pos_T\ttpos;\n    win_T\t*old_curwin = curwin, *wp;\n    int\t\tdid_scroll = FALSE;\n\n    tpos = curwin->w_cursor;\n\n    if (mouse_row >= 0 && mouse_col >= 0)\n    {\n\tint row, col;\n\n\trow = mouse_row;\n\tcol = mouse_col;\n\n\t// find the window at the pointer coordinates\n\twp = mouse_find_win(&row, &col, FIND_POPUP);\n\tif (wp == NULL)\n\t    return;\n\tcurwin = wp;\n\tcurbuf = curwin->w_buffer;\n    }\n    if (curwin == old_curwin)\n\tundisplay_dollar();\n\n    // Don't scroll the window in which completion is being done.\n    if (!pum_visible() || curwin != old_curwin)\n    {\n\tlong step;\n\n\tif (dir == MSCR_DOWN || dir == MSCR_UP)\n\t{\n\t    if (mouse_vert_step < 0\n\t\t    || mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n\t\tstep = (long)(curwin->w_botline - curwin->w_topline);\n\t    else\n\t\tstep = mouse_vert_step;\n\t    scroll_redraw(dir, step);\n# ifdef FEAT_PROP_POPUP\n\tif (WIN_IS_POPUP(curwin))\n\t    popup_set_firstline(curwin);\n# endif\n\t}\n#ifdef FEAT_GUI\n\telse\n\t{\n\t    int val;\n\n\t    if (mouse_hor_step < 0\n\t\t    || mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n\t\tstep = curwin->w_width;\n\t    else\n\t\tstep = mouse_hor_step;\n\t    val = curwin->w_leftcol + (dir == MSCR_RIGHT ? -step : step);\n\t    if (val < 0)\n\t\tval = 0;\n\t    gui_do_horiz_scroll(val, TRUE);\n\t}\n#endif\n\tdid_scroll = TRUE;\n\tmay_trigger_winscrolled();\n    }\n\n    curwin->w_redr_status = TRUE;\n\n    curwin = old_curwin;\n    curbuf = curwin->w_buffer;\n\n    // The popup menu may overlay the window, need to redraw it.\n    // TODO: Would be more efficient to only redraw the windows that are\n    // overlapped by the popup menu.\n    if (pum_visible() && did_scroll)\n    {\n\tredraw_all_later(UPD_NOT_VALID);\n\tins_compl_show_pum();\n    }\n\n    if (!EQUAL_POS(curwin->w_cursor, tpos))\n    {\n\tstart_arrow(&tpos);\n\tset_can_cindent(TRUE);\n    }\n}\n\n/*\n * Return TRUE if \"c\" is a mouse key.\n */\n    int\nis_mouse_key(int c)\n{\n    return c == K_LEFTMOUSE\n\t|| c == K_LEFTMOUSE_NM\n\t|| c == K_LEFTDRAG\n\t|| c == K_LEFTRELEASE\n\t|| c == K_LEFTRELEASE_NM\n\t|| c == K_MOUSEMOVE\n\t|| c == K_MIDDLEMOUSE\n\t|| c == K_MIDDLEDRAG\n\t|| c == K_MIDDLERELEASE\n\t|| c == K_RIGHTMOUSE\n\t|| c == K_RIGHTDRAG\n\t|| c == K_RIGHTRELEASE\n\t|| c == K_MOUSEDOWN\n\t|| c == K_MOUSEUP\n\t|| c == K_MOUSELEFT\n\t|| c == K_MOUSERIGHT\n\t|| c == K_X1MOUSE\n\t|| c == K_X1DRAG\n\t|| c == K_X1RELEASE\n\t|| c == K_X2MOUSE\n\t|| c == K_X2DRAG\n\t|| c == K_X2RELEASE;\n}\n\nstatic struct mousetable\n{\n    int\t    pseudo_code;\t// Code for pseudo mouse event\n    int\t    button;\t\t// Which mouse button is it?\n    int\t    is_click;\t\t// Is it a mouse button click event?\n    int\t    is_drag;\t\t// Is it a mouse drag event?\n} mouse_table[] =\n{\n    {(int)KE_LEFTMOUSE,\t\tMOUSE_LEFT,\tTRUE,\tFALSE},\n#ifdef FEAT_GUI\n    {(int)KE_LEFTMOUSE_NM,\tMOUSE_LEFT,\tTRUE,\tFALSE},\n#endif\n    {(int)KE_LEFTDRAG,\t\tMOUSE_LEFT,\tFALSE,\tTRUE},\n    {(int)KE_LEFTRELEASE,\tMOUSE_LEFT,\tFALSE,\tFALSE},\n#ifdef FEAT_GUI\n    {(int)KE_LEFTRELEASE_NM,\tMOUSE_LEFT,\tFALSE,\tFALSE},\n#endif\n    {(int)KE_MIDDLEMOUSE,\tMOUSE_MIDDLE,\tTRUE,\tFALSE},\n    {(int)KE_MIDDLEDRAG,\tMOUSE_MIDDLE,\tFALSE,\tTRUE},\n    {(int)KE_MIDDLERELEASE,\tMOUSE_MIDDLE,\tFALSE,\tFALSE},\n    {(int)KE_RIGHTMOUSE,\tMOUSE_RIGHT,\tTRUE,\tFALSE},\n    {(int)KE_RIGHTDRAG,\t\tMOUSE_RIGHT,\tFALSE,\tTRUE},\n    {(int)KE_RIGHTRELEASE,\tMOUSE_RIGHT,\tFALSE,\tFALSE},\n    {(int)KE_X1MOUSE,\t\tMOUSE_X1,\tTRUE,\tFALSE},\n    {(int)KE_X1DRAG,\t\tMOUSE_X1,\tFALSE,\tTRUE},\n    {(int)KE_X1RELEASE,\t\tMOUSE_X1,\tFALSE,\tFALSE},\n    {(int)KE_X2MOUSE,\t\tMOUSE_X2,\tTRUE,\tFALSE},\n    {(int)KE_X2DRAG,\t\tMOUSE_X2,\tFALSE,\tTRUE},\n    {(int)KE_X2RELEASE,\t\tMOUSE_X2,\tFALSE,\tFALSE},\n    // DRAG without CLICK\n    {(int)KE_MOUSEMOVE,\t\tMOUSE_RELEASE,\tFALSE,\tTRUE},\n    // RELEASE without CLICK\n    {(int)KE_IGNORE,\t\tMOUSE_RELEASE,\tFALSE,\tFALSE},\n    {0,\t\t\t\t0,\t\t0,\t0},\n};\n\n/*\n * Look up the given mouse code to return the relevant information in the other\n * arguments.  Return which button is down or was released.\n */\n    int\nget_mouse_button(int code, int *is_click, int *is_drag)\n{\n    int\t    i;\n\n    for (i = 0; mouse_table[i].pseudo_code; i++)\n\tif (code == mouse_table[i].pseudo_code)\n\t{\n\t    *is_click = mouse_table[i].is_click;\n\t    *is_drag = mouse_table[i].is_drag;\n\t    return mouse_table[i].button;\n\t}\n    return 0;\t    // Shouldn't get here\n}\n\n/*\n * Return the appropriate pseudo mouse event token (KE_LEFTMOUSE etc) based on\n * the given information about which mouse button is down, and whether the\n * mouse was clicked, dragged or released.\n */\n    int\nget_pseudo_mouse_code(\n    int\t    button,\t// eg MOUSE_LEFT\n    int\t    is_click,\n    int\t    is_drag)\n{\n    int\t    i;\n\n    for (i = 0; mouse_table[i].pseudo_code; i++)\n\tif (button == mouse_table[i].button\n\t    && is_click == mouse_table[i].is_click\n\t    && is_drag == mouse_table[i].is_drag)\n\t{\n#ifdef FEAT_GUI\n\t    // Trick: a non mappable left click and release has mouse_col -1\n\t    // or added MOUSE_COLOFF.  Used for 'mousefocus' in\n\t    // gui_mouse_moved()\n\t    if (mouse_col < 0 || mouse_col > MOUSE_COLOFF)\n\t    {\n\t\tif (mouse_col < 0)\n\t\t    mouse_col = 0;\n\t\telse\n\t\t    mouse_col -= MOUSE_COLOFF;\n\t\tif (mouse_table[i].pseudo_code == (int)KE_LEFTMOUSE)\n\t\t    return (int)KE_LEFTMOUSE_NM;\n\t\tif (mouse_table[i].pseudo_code == (int)KE_LEFTRELEASE)\n\t\t    return (int)KE_LEFTRELEASE_NM;\n\t    }\n#endif\n\t    return mouse_table[i].pseudo_code;\n\t}\n    return (int)KE_IGNORE;\t    // not recognized, ignore it\n}\n\n# define HMT_NORMAL\t1\n# define HMT_NETTERM\t2\n# define HMT_DEC\t4\n# define HMT_JSBTERM\t8\n# define HMT_PTERM\t16\n# define HMT_URXVT\t32\n# define HMT_GPM\t64\n# define HMT_SGR\t128\n# define HMT_SGR_REL\t256\nstatic int has_mouse_termcode = 0;\n\n    void\nset_mouse_termcode(\n    int\t\tn,\t// KS_MOUSE, KS_NETTERM_MOUSE or KS_DEC_MOUSE\n    char_u\t*s)\n{\n    char_u\tname[2];\n\n    name[0] = n;\n    name[1] = KE_FILLER;\n    add_termcode(name, s, FALSE);\n#   ifdef FEAT_MOUSE_JSB\n    if (n == KS_JSBTERM_MOUSE)\n\thas_mouse_termcode |= HMT_JSBTERM;\n    else\n#   endif\n#   ifdef FEAT_MOUSE_NET\n    if (n == KS_NETTERM_MOUSE)\n\thas_mouse_termcode |= HMT_NETTERM;\n    else\n#   endif\n#   ifdef FEAT_MOUSE_DEC\n    if (n == KS_DEC_MOUSE)\n\thas_mouse_termcode |= HMT_DEC;\n    else\n#   endif\n#   ifdef FEAT_MOUSE_PTERM\n    if (n == KS_PTERM_MOUSE)\n\thas_mouse_termcode |= HMT_PTERM;\n    else\n#   endif\n#   ifdef FEAT_MOUSE_URXVT\n    if (n == KS_URXVT_MOUSE)\n\thas_mouse_termcode |= HMT_URXVT;\n    else\n#   endif\n#   ifdef FEAT_MOUSE_GPM\n    if (n == KS_GPM_MOUSE)\n\thas_mouse_termcode |= HMT_GPM;\n    else\n#   endif\n    if (n == KS_SGR_MOUSE)\n\thas_mouse_termcode |= HMT_SGR;\n    else if (n == KS_SGR_MOUSE_RELEASE)\n\thas_mouse_termcode |= HMT_SGR_REL;\n    else\n\thas_mouse_termcode |= HMT_NORMAL;\n}\n\n# if defined(UNIX) || defined(VMS) || defined(PROTO)\n    void\ndel_mouse_termcode(\n    int\t\tn)\t// KS_MOUSE, KS_NETTERM_MOUSE or KS_DEC_MOUSE\n{\n    char_u\tname[2];\n\n    name[0] = n;\n    name[1] = KE_FILLER;\n    del_termcode(name);\n#   ifdef FEAT_MOUSE_JSB\n    if (n == KS_JSBTERM_MOUSE)\n\thas_mouse_termcode &= ~HMT_JSBTERM;\n    else\n#   endif\n#   ifdef FEAT_MOUSE_NET\n    if (n == KS_NETTERM_MOUSE)\n\thas_mouse_termcode &= ~HMT_NETTERM;\n    else\n#   endif\n#   ifdef FEAT_MOUSE_DEC\n    if (n == KS_DEC_MOUSE)\n\thas_mouse_termcode &= ~HMT_DEC;\n    else\n#   endif\n#   ifdef FEAT_MOUSE_PTERM\n    if (n == KS_PTERM_MOUSE)\n\thas_mouse_termcode &= ~HMT_PTERM;\n    else\n#   endif\n#   ifdef FEAT_MOUSE_URXVT\n    if (n == KS_URXVT_MOUSE)\n\thas_mouse_termcode &= ~HMT_URXVT;\n    else\n#   endif\n#   ifdef FEAT_MOUSE_GPM\n    if (n == KS_GPM_MOUSE)\n\thas_mouse_termcode &= ~HMT_GPM;\n    else\n#   endif\n    if (n == KS_SGR_MOUSE)\n\thas_mouse_termcode &= ~HMT_SGR;\n    else if (n == KS_SGR_MOUSE_RELEASE)\n\thas_mouse_termcode &= ~HMT_SGR_REL;\n    else\n\thas_mouse_termcode &= ~HMT_NORMAL;\n}\n# endif\n\n/*\n * setmouse() - switch mouse on/off depending on current mode and 'mouse'\n */\n    void\nsetmouse(void)\n{\n    int\t    checkfor;\n\n# ifdef FEAT_MOUSESHAPE\n    update_mouseshape(-1);\n# endif\n\n    // Should be outside proc, but may break MOUSESHAPE\n#  ifdef FEAT_GUI\n    // In the GUI the mouse is always enabled.\n    if (gui.in_use)\n\treturn;\n#  endif\n    // be quick when mouse is off\n    if (*p_mouse == NUL || has_mouse_termcode == 0)\n\treturn;\n\n    // don't switch mouse on when not in raw mode (Ex mode)\n    if (cur_tmode != TMODE_RAW)\n    {\n\tmch_setmouse(FALSE);\n\treturn;\n    }\n\n    if (VIsual_active)\n\tcheckfor = MOUSE_VISUAL;\n    else if (State == MODE_HITRETURN || State == MODE_ASKMORE\n\t\t\t\t\t\t     || State == MODE_SETWSIZE)\n\tcheckfor = MOUSE_RETURN;\n    else if (State & MODE_INSERT)\n\tcheckfor = MOUSE_INSERT;\n    else if (State & MODE_CMDLINE)\n\tcheckfor = MOUSE_COMMAND;\n    else if (State == MODE_CONFIRM || State == MODE_EXTERNCMD)\n\tcheckfor = ' '; // don't use mouse for \":confirm\" or \":!cmd\"\n    else\n\tcheckfor = MOUSE_NORMAL;    // assume normal mode\n\n    if (mouse_has(checkfor))\n\tmch_setmouse(TRUE);\n    else\n\tmch_setmouse(FALSE);\n}\n\n/*\n * Return TRUE if\n * - \"c\" is in 'mouse', or\n * - 'a' is in 'mouse' and \"c\" is in MOUSE_A, or\n * - the current buffer is a help file and 'h' is in 'mouse' and we are in a\n *   normal editing mode (not at hit-return message).\n */\n    int\nmouse_has(int c)\n{\n    char_u\t*p;\n\n    for (p = p_mouse; *p; ++p)\n\tswitch (*p)\n\t{\n\t    case 'a': if (vim_strchr((char_u *)MOUSE_A, c) != NULL)\n\t\t\t  return TRUE;\n\t\t      break;\n\t    case MOUSE_HELP: if (c != MOUSE_RETURN && curbuf->b_help)\n\t\t\t\t return TRUE;\n\t\t\t     break;\n\t    default: if (c == *p) return TRUE; break;\n\t}\n    return FALSE;\n}\n\n/*\n * Return TRUE when 'mousemodel' is set to \"popup\" or \"popup_setpos\".\n */\n    int\nmouse_model_popup(void)\n{\n    return (p_mousem[0] == 'p');\n}\n\n/*\n * Move the cursor to the specified row and column on the screen.\n * Change current window if necessary.\tReturns an integer with the\n * CURSOR_MOVED bit set if the cursor has moved or unset otherwise.\n *\n * The MOUSE_FOLD_CLOSE bit is set when clicked on the '-' in a fold column.\n * The MOUSE_FOLD_OPEN bit is set when clicked on the '+' in a fold column.\n *\n * If flags has MOUSE_FOCUS, then the current window will not be changed, and\n * if the mouse is outside the window then the text will scroll, or if the\n * mouse was previously on a status line, then the status line may be dragged.\n *\n * If flags has MOUSE_MAY_VIS, then VIsual mode will be started before the\n * cursor is moved unless the cursor was on a status line.\n * This function returns one of IN_UNKNOWN, IN_BUFFER, IN_STATUS_LINE or\n * IN_SEP_LINE depending on where the cursor was clicked.\n *\n * If flags has MOUSE_MAY_STOP_VIS, then Visual mode will be stopped, unless\n * the mouse is on the status line of the same window.\n *\n * If flags has MOUSE_DID_MOVE, nothing is done if the mouse didn't move since\n * the last call.\n *\n * If flags has MOUSE_SETPOS, nothing is done, only the current position is\n * remembered.\n */\n    int\njump_to_mouse(\n    int\t\tflags,\n    int\t\t*inclusive,\t// used for inclusive operator, can be NULL\n    int\t\twhich_button)\t// MOUSE_LEFT, MOUSE_RIGHT, MOUSE_MIDDLE\n{\n    static int\ton_status_line = 0;\t// #lines below bottom of window\n    static int\ton_sep_line = 0;\t// on separator right of window\n#ifdef FEAT_MENU\n    static int  in_winbar = FALSE;\n#endif\n#ifdef FEAT_PROP_POPUP\n    static int   in_popup_win = FALSE;\n    static win_T *click_in_popup_win = NULL;\n#endif\n    static int\tprev_row = -1;\n    static int\tprev_col = -1;\n    static win_T *dragwin = NULL;\t// window being dragged\n    static int\tdid_drag = FALSE;\t// drag was noticed\n\n    win_T\t*wp, *old_curwin;\n    pos_T\told_cursor;\n    int\t\tcount;\n    int\t\tfirst;\n    int\t\trow = mouse_row;\n    int\t\tcol = mouse_col;\n    colnr_T\tcol_from_screen = -1;\n#ifdef FEAT_FOLDING\n    int\t\tmouse_char = ' ';\n#endif\n\n    mouse_past_bottom = FALSE;\n    mouse_past_eol = FALSE;\n\n    if (flags & MOUSE_RELEASED)\n    {\n\t// On button release we may change window focus if positioned on a\n\t// status line and no dragging happened.\n\tif (dragwin != NULL && !did_drag)\n\t    flags &= ~(MOUSE_FOCUS | MOUSE_DID_MOVE);\n\tdragwin = NULL;\n\tdid_drag = FALSE;\n#ifdef FEAT_PROP_POPUP\n\tif (click_in_popup_win != NULL && popup_dragwin == NULL)\n\t    popup_close_for_mouse_click(click_in_popup_win);\n\n\tpopup_dragwin = NULL;\n\tclick_in_popup_win = NULL;\n#endif\n    }\n\n    if ((flags & MOUSE_DID_MOVE)\n\t    && prev_row == mouse_row\n\t    && prev_col == mouse_col)\n    {\nretnomove:\n\t// before moving the cursor for a left click which is NOT in a status\n\t// line, stop Visual mode\n\tif (on_status_line)\n\t    return IN_STATUS_LINE;\n\tif (on_sep_line)\n\t    return IN_SEP_LINE;\n#ifdef FEAT_MENU\n\tif (in_winbar)\n\t{\n\t    // A quick second click may arrive as a double-click, but we use it\n\t    // as a second click in the WinBar.\n\t    if ((mod_mask & MOD_MASK_MULTI_CLICK) && !(flags & MOUSE_RELEASED))\n\t    {\n\t\twp = mouse_find_win(&row, &col, FAIL_POPUP);\n\t\tif (wp == NULL)\n\t\t    return IN_UNKNOWN;\n\t\twinbar_click(wp, col);\n\t    }\n\t    return IN_OTHER_WIN | MOUSE_WINBAR;\n\t}\n#endif\n\tif (flags & MOUSE_MAY_STOP_VIS)\n\t{\n\t    end_visual_mode_keep_button();\n\t    redraw_curbuf_later(UPD_INVERTED);\t// delete the inversion\n\t}\n#if defined(FEAT_CMDWIN) && defined(FEAT_CLIPBOARD)\n\t// Continue a modeless selection in another window.\n\tif (cmdwin_type != 0 && row < curwin->w_winrow)\n\t    return IN_OTHER_WIN;\n#endif\n#ifdef FEAT_PROP_POPUP\n\t// Continue a modeless selection in a popup window or dragging it.\n\tif (in_popup_win)\n\t{\n\t    click_in_popup_win = NULL;  // don't close it on release\n\t    if (popup_dragwin != NULL)\n\t    {\n\t\t// dragging a popup window\n\t\tpopup_drag(popup_dragwin);\n\t\treturn IN_UNKNOWN;\n\t    }\n\t    return IN_OTHER_WIN;\n\t}\n#endif\n\treturn IN_BUFFER;\n    }\n\n    prev_row = mouse_row;\n    prev_col = mouse_col;\n\n    if (flags & MOUSE_SETPOS)\n\tgoto retnomove;\t\t\t\t// ugly goto...\n\n    old_curwin = curwin;\n    old_cursor = curwin->w_cursor;\n\n    if (!(flags & MOUSE_FOCUS))\n    {\n\tif (row < 0 || col < 0)\t\t\t// check if it makes sense\n\t    return IN_UNKNOWN;\n\n\t// find the window where the row is in and adjust \"row\" and \"col\" to be\n\t// relative to top-left of the window\n\twp = mouse_find_win(&row, &col, FIND_POPUP);\n\tif (wp == NULL)\n\t    return IN_UNKNOWN;\n\tdragwin = NULL;\n\n#ifdef FEAT_PROP_POPUP\n\t// Click in a popup window may start dragging or modeless selection,\n\t// but not much else.\n\tif (WIN_IS_POPUP(wp))\n\t{\n\t    on_sep_line = 0;\n\t    on_status_line = 0;\n\t    in_popup_win = TRUE;\n\t    if (which_button == MOUSE_LEFT && popup_close_if_on_X(wp, row, col))\n\t    {\n\t\treturn IN_UNKNOWN;\n\t    }\n\t    else if (((wp->w_popup_flags & (POPF_DRAG | POPF_RESIZE))\n\t\t\t\t\t      && popup_on_border(wp, row, col))\n\t\t\t\t       || (wp->w_popup_flags & POPF_DRAGALL))\n\t    {\n\t\tpopup_dragwin = wp;\n\t\tpopup_start_drag(wp, row, col);\n\t\treturn IN_UNKNOWN;\n\t    }\n\t    // Only close on release, otherwise it's not possible to drag or do\n\t    // modeless selection.\n\t    else if (wp->w_popup_close == POPCLOSE_CLICK\n\t\t    && which_button == MOUSE_LEFT)\n\t    {\n\t\tclick_in_popup_win = wp;\n\t    }\n\t    else if (which_button == MOUSE_LEFT)\n\t\t// If the click is in the scrollbar, may scroll up/down.\n\t\tpopup_handle_scrollbar_click(wp, row, col);\n# ifdef FEAT_CLIPBOARD\n\t    return IN_OTHER_WIN;\n# else\n\t    return IN_UNKNOWN;\n# endif\n\t}\n\tin_popup_win = FALSE;\n\tpopup_dragwin = NULL;\n#endif\n#ifdef FEAT_MENU\n\tif (row == -1)\n\t{\n\t    // A click in the window toolbar does not enter another window or\n\t    // change Visual highlighting.\n\t    winbar_click(wp, col);\n\t    in_winbar = TRUE;\n\t    return IN_OTHER_WIN | MOUSE_WINBAR;\n\t}\n\tin_winbar = FALSE;\n#endif\n\n\t// winpos and height may change in win_enter()!\n\tif (row >= wp->w_height)\t\t// In (or below) status line\n\t{\n\t    on_status_line = row - wp->w_height + 1;\n\t    dragwin = wp;\n\t}\n\telse\n\t    on_status_line = 0;\n\tif (col >= wp->w_width)\t\t// In separator line\n\t{\n\t    on_sep_line = col - wp->w_width + 1;\n\t    dragwin = wp;\n\t}\n\telse\n\t    on_sep_line = 0;\n\n\t// The rightmost character of the status line might be a vertical\n\t// separator character if there is no connecting window to the right.\n\tif (on_status_line && on_sep_line)\n\t{\n\t    if (stl_connected(wp))\n\t\ton_sep_line = 0;\n\t    else\n\t\ton_status_line = 0;\n\t}\n\n\t// Before jumping to another buffer, or moving the cursor for a left\n\t// click, stop Visual mode.\n\tif (VIsual_active\n\t\t&& (wp->w_buffer != curwin->w_buffer\n\t\t    || (!on_status_line && !on_sep_line\n#ifdef FEAT_FOLDING\n\t\t\t&& (\n# ifdef FEAT_RIGHTLEFT\n\t\t\t    wp->w_p_rl ? col < wp->w_width - wp->w_p_fdc :\n# endif\n\t\t\t    col >= wp->w_p_fdc\n# ifdef FEAT_CMDWIN\n\t\t\t\t  + (cmdwin_type == 0 && wp == curwin ? 0 : 1)\n# endif\n\t\t\t    )\n#endif\n\t\t\t&& (flags & MOUSE_MAY_STOP_VIS))))\n\t{\n\t    end_visual_mode_keep_button();\n\t    redraw_curbuf_later(UPD_INVERTED);\t// delete the inversion\n\t}\n#ifdef FEAT_CMDWIN\n\tif (cmdwin_type != 0 && wp != curwin)\n\t{\n\t    // A click outside the command-line window: Use modeless\n\t    // selection if possible.  Allow dragging the status lines.\n\t    on_sep_line = 0;\n# ifdef FEAT_CLIPBOARD\n\t    if (on_status_line)\n\t\treturn IN_STATUS_LINE;\n\t    return IN_OTHER_WIN;\n# else\n\t    row = 0;\n\t    col += wp->w_wincol;\n\t    wp = curwin;\n# endif\n\t}\n#endif\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_TERMINAL)\n\tif (popup_is_popup(curwin) && curbuf->b_term != NULL)\n\t    // terminal in popup window: don't jump to another window\n\t    return IN_OTHER_WIN;\n#endif\n\t// Only change window focus when not clicking on or dragging the\n\t// status line.  Do change focus when releasing the mouse button\n\t// (MOUSE_FOCUS was set above if we dragged first).\n\tif (dragwin == NULL || (flags & MOUSE_RELEASED))\n\t    win_enter(wp, TRUE);\t\t// can make wp invalid!\n\n\tif (curwin != old_curwin)\n\t{\n#ifdef CHECK_DOUBLE_CLICK\n\t    // set topline, to be able to check for double click ourselves\n\t    set_mouse_topline(curwin);\n#endif\n#ifdef FEAT_TERMINAL\n\t    // when entering a terminal window may change state\n\t    term_win_entered();\n#endif\n\t}\n\tif (on_status_line)\t\t\t// In (or below) status line\n\t{\n\t    // Don't use start_arrow() if we're in the same window\n\t    if (curwin == old_curwin)\n\t\treturn IN_STATUS_LINE;\n\t    else\n\t\treturn IN_STATUS_LINE | CURSOR_MOVED;\n\t}\n\tif (on_sep_line)\t\t\t// In (or below) status line\n\t{\n\t    // Don't use start_arrow() if we're in the same window\n\t    if (curwin == old_curwin)\n\t\treturn IN_SEP_LINE;\n\t    else\n\t\treturn IN_SEP_LINE | CURSOR_MOVED;\n\t}\n\n\tcurwin->w_cursor.lnum = curwin->w_topline;\n#ifdef FEAT_GUI\n\t// remember topline, needed for double click\n\tgui_prev_topline = curwin->w_topline;\n# ifdef FEAT_DIFF\n\tgui_prev_topfill = curwin->w_topfill;\n# endif\n#endif\n    }\n    else if (on_status_line && which_button == MOUSE_LEFT)\n    {\n\tif (dragwin != NULL)\n\t{\n\t    // Drag the status line\n\t    count = row - W_WINROW(dragwin) - dragwin->w_height + 1\n\t\t\t\t\t\t\t     - on_status_line;\n\t    win_drag_status_line(dragwin, count);\n\t    did_drag |= count;\n\t}\n\treturn IN_STATUS_LINE;\t\t\t// Cursor didn't move\n    }\n    else if (on_sep_line && which_button == MOUSE_LEFT)\n    {\n\tif (dragwin != NULL)\n\t{\n\t    // Drag the separator column\n\t    count = col - dragwin->w_wincol - dragwin->w_width + 1\n\t\t\t\t\t\t\t\t- on_sep_line;\n\t    win_drag_vsep_line(dragwin, count);\n\t    did_drag |= count;\n\t}\n\treturn IN_SEP_LINE;\t\t\t// Cursor didn't move\n    }\n#ifdef FEAT_MENU\n    else if (in_winbar)\n    {\n\t// After a click on the window toolbar don't start Visual mode.\n\treturn IN_OTHER_WIN | MOUSE_WINBAR;\n    }\n#endif\n    else // keep_window_focus must be TRUE\n    {\n\t// before moving the cursor for a left click, stop Visual mode\n\tif (flags & MOUSE_MAY_STOP_VIS)\n\t{\n\t    end_visual_mode_keep_button();\n\t    redraw_curbuf_later(UPD_INVERTED);\t// delete the inversion\n\t}\n\n#if defined(FEAT_CMDWIN) && defined(FEAT_CLIPBOARD)\n\t// Continue a modeless selection in another window.\n\tif (cmdwin_type != 0 && row < curwin->w_winrow)\n\t    return IN_OTHER_WIN;\n#endif\n#ifdef FEAT_PROP_POPUP\n\tif (in_popup_win)\n\t{\n\t    if (popup_dragwin != NULL)\n\t    {\n\t\t// dragging a popup window\n\t\tpopup_drag(popup_dragwin);\n\t\treturn IN_UNKNOWN;\n\t    }\n\t    // continue a modeless selection in a popup window\n\t    click_in_popup_win = NULL;\n\t    return IN_OTHER_WIN;\n\t}\n#endif\n\n\trow -= W_WINROW(curwin);\n\tcol -= curwin->w_wincol;\n\n\t// When clicking beyond the end of the window, scroll the screen.\n\t// Scroll by however many rows outside the window we are.\n\tif (row < 0)\n\t{\n\t    count = 0;\n\t    for (first = TRUE; curwin->w_topline > 1; )\n\t    {\n#ifdef FEAT_DIFF\n\t\tif (curwin->w_topfill < diff_check(curwin, curwin->w_topline))\n\t\t    ++count;\n\t\telse\n#endif\n\t\t    count += plines(curwin->w_topline - 1);\n\t\tif (!first && count > -row)\n\t\t    break;\n\t\tfirst = FALSE;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n#ifdef FEAT_DIFF\n\t\tif (curwin->w_topfill < diff_check(curwin, curwin->w_topline))\n\t\t    ++curwin->w_topfill;\n\t\telse\n#endif\n\t\t{\n\t\t    --curwin->w_topline;\n#ifdef FEAT_DIFF\n\t\t    curwin->w_topfill = 0;\n#endif\n\t\t}\n\t    }\n#ifdef FEAT_DIFF\n\t    check_topfill(curwin, FALSE);\n#endif\n\t    curwin->w_valid &=\n\t\t      ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    redraw_later(UPD_VALID);\n\t    row = 0;\n\t}\n\telse if (row >= curwin->w_height)\n\t{\n\t    count = 0;\n\t    for (first = TRUE; curwin->w_topline < curbuf->b_ml.ml_line_count; )\n\t    {\n#ifdef FEAT_DIFF\n\t\tif (curwin->w_topfill > 0)\n\t\t    ++count;\n\t\telse\n#endif\n\t\t    count += plines(curwin->w_topline);\n\t\tif (!first && count > row - curwin->w_height + 1)\n\t\t    break;\n\t\tfirst = FALSE;\n#ifdef FEAT_FOLDING\n\t\tif (hasFolding(curwin->w_topline, NULL, &curwin->w_topline)\n\t\t\t&& curwin->w_topline == curbuf->b_ml.ml_line_count)\n\t\t    break;\n#endif\n#ifdef FEAT_DIFF\n\t\tif (curwin->w_topfill > 0)\n\t\t    --curwin->w_topfill;\n\t\telse\n#endif\n\t\t{\n\t\t    ++curwin->w_topline;\n#ifdef FEAT_DIFF\n\t\t    curwin->w_topfill =\n\t\t\t\t   diff_check_fill(curwin, curwin->w_topline);\n#endif\n\t\t}\n\t    }\n#ifdef FEAT_DIFF\n\t    check_topfill(curwin, FALSE);\n#endif\n\t    redraw_later(UPD_VALID);\n\t    curwin->w_valid &=\n\t\t      ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    row = curwin->w_height - 1;\n\t}\n\telse if (row == 0)\n\t{\n\t    // When dragging the mouse, while the text has been scrolled up as\n\t    // far as it goes, moving the mouse in the top line should scroll\n\t    // the text down (done later when recomputing w_topline).\n\t    if (mouse_dragging > 0\n\t\t    && curwin->w_cursor.lnum\n\t\t\t\t       == curwin->w_buffer->b_ml.ml_line_count\n\t\t    && curwin->w_cursor.lnum == curwin->w_topline)\n\t\tcurwin->w_valid &= ~(VALID_TOPLINE);\n\t}\n    }\n\n    if (prev_row >= 0 && prev_row < Rows && prev_col >= 0 && prev_col <= Columns\n\t\t\t\t\t\t       && ScreenLines != NULL)\n    {\n\tint off = LineOffset[prev_row] + prev_col;\n\n\t// Only use ScreenCols[] after the window was redrawn.  Mainly matters\n\t// for tests, a user would not click before redrawing.\n\t// Do not use when 'virtualedit' is active.\n\tif (curwin->w_redr_type <= UPD_VALID_NO_UPDATE && !virtual_active())\n\t    col_from_screen = ScreenCols[off];\n#ifdef FEAT_FOLDING\n\t// Remember the character under the mouse, it might be a '-' or '+' in\n\t// the fold column.\n\tmouse_char = ScreenLines[off];\n#endif\n    }\n\n#ifdef FEAT_FOLDING\n    // Check for position outside of the fold column.\n    if (\n# ifdef FEAT_RIGHTLEFT\n\t    curwin->w_p_rl ? col < curwin->w_width - curwin->w_p_fdc :\n# endif\n\t    col >= curwin->w_p_fdc\n#  ifdef FEAT_CMDWIN\n\t\t\t\t+ (cmdwin_type == 0 ? 0 : 1)\n#  endif\n       )\n\tmouse_char = ' ';\n#endif\n\n    // compute the position in the buffer line from the posn on the screen\n    if (mouse_comp_pos(curwin, &row, &col, &curwin->w_cursor.lnum, NULL))\n\tmouse_past_bottom = TRUE;\n\n    // Start Visual mode before coladvance(), for when 'sel' != \"old\"\n    if ((flags & MOUSE_MAY_VIS) && !VIsual_active)\n    {\n\tcheck_visual_highlight();\n\tVIsual = old_cursor;\n\tVIsual_active = TRUE;\n\tVIsual_reselect = TRUE;\n\t// if 'selectmode' contains \"mouse\", start Select mode\n\tmay_start_select('o');\n\tsetmouse();\n\tif (p_smd && msg_silent == 0)\n\t    redraw_cmdline = TRUE;\t// show visual mode later\n    }\n\n    if (col_from_screen >= 0)\n    {\n\t// Use the column from ScreenCols[], it is accurate also after\n\t// concealed characters.\n\tcurwin->w_cursor.col = col_from_screen;\n\tif (col_from_screen == MAXCOL)\n\t{\n\t    curwin->w_curswant = col_from_screen;\n\t    curwin->w_set_curswant = FALSE;\t// May still have been TRUE\n\t    mouse_past_eol = TRUE;\n\t    if (inclusive != NULL)\n\t\t*inclusive = TRUE;\n\t}\n\telse\n\t{\n\t    curwin->w_set_curswant = TRUE;\n\t    if (inclusive != NULL)\n\t\t*inclusive = FALSE;\n\t}\n\tcheck_cursor_col();\n    }\n    else\n    {\n\tcurwin->w_curswant = col;\n\tcurwin->w_set_curswant = FALSE;\t// May still have been TRUE\n\tif (coladvance(col) == FAIL)\t// Mouse click beyond end of line\n\t{\n\t    if (inclusive != NULL)\n\t\t*inclusive = TRUE;\n\t    mouse_past_eol = TRUE;\n\t}\n\telse if (inclusive != NULL)\n\t    *inclusive = FALSE;\n    }\n\n    count = IN_BUFFER;\n    if (curwin != old_curwin || curwin->w_cursor.lnum != old_cursor.lnum\n\t    || curwin->w_cursor.col != old_cursor.col)\n\tcount |= CURSOR_MOVED;\t\t// Cursor has moved\n\n# ifdef FEAT_FOLDING\n    if (mouse_char == curwin->w_fill_chars.foldclosed)\n\tcount |= MOUSE_FOLD_OPEN;\n    else if (mouse_char != ' ')\n\tcount |= MOUSE_FOLD_CLOSE;\n# endif\n\n    return count;\n}\n\n/*\n * Mouse scroll wheel: Default action is to scroll mouse_vert_step lines (or\n * mouse_hor_step, depending on the scroll direction), or one page when Shift or\n * Ctrl is used.\n * K_MOUSEUP (cap->arg == 1) or K_MOUSEDOWN (cap->arg == 0) or\n * K_MOUSELEFT (cap->arg == -1) or K_MOUSERIGHT (cap->arg == -2)\n */\n    void\nnv_mousescroll(cmdarg_T *cap)\n{\n    win_T *old_curwin = curwin, *wp;\n\n    if (mouse_row >= 0 && mouse_col >= 0)\n    {\n\tint row, col;\n\n\trow = mouse_row;\n\tcol = mouse_col;\n\n\t// find the window at the pointer coordinates\n\twp = mouse_find_win(&row, &col, FIND_POPUP);\n\tif (wp == NULL)\n\t    return;\n#ifdef FEAT_PROP_POPUP\n\tif (WIN_IS_POPUP(wp) && !wp->w_has_scrollbar)\n\t    return;\n#endif\n\tcurwin = wp;\n\tcurbuf = curwin->w_buffer;\n    }\n    if (cap->arg == MSCR_UP || cap->arg == MSCR_DOWN)\n    {\n# ifdef FEAT_TERMINAL\n\tif (term_use_loop())\n\t    // This window is a terminal window, send the mouse event there.\n\t    // Set \"typed\" to FALSE to avoid an endless loop.\n\t    send_keys_to_term(curbuf->b_term, cap->cmdchar, mod_mask, FALSE);\n\telse\n# endif\n\tif (mouse_vert_step < 0 || mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n\t{\n\t    (void)onepage(cap->arg ? FORWARD : BACKWARD, 1L);\n\t}\n\telse\n\t{\n\t    // Don't scroll more than half the window height.\n\t    if (curwin->w_height < mouse_vert_step * 2)\n\t    {\n\t\tcap->count1 = curwin->w_height / 2;\n\t\tif (cap->count1 == 0)\n\t\t    cap->count1 = 1;\n\t    }\n\t    else\n\t\tcap->count1 = mouse_vert_step;\n\t    cap->count0 = cap->count1;\n\t    nv_scroll_line(cap);\n\t}\n#ifdef FEAT_PROP_POPUP\n\tif (WIN_IS_POPUP(curwin))\n\t    popup_set_firstline(curwin);\n#endif\n    }\n# ifdef FEAT_GUI\n    else\n    {\n\t// Horizontal scroll - only allowed when 'wrap' is disabled\n\tif (!curwin->w_p_wrap)\n\t{\n\t    int val, step;\n\n\t    if (mouse_hor_step < 0\n\t\t    || mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n\t\tstep = curwin->w_width;\n\t    else\n\t\tstep = mouse_hor_step;\n\t    val = curwin->w_leftcol + (cap->arg == MSCR_RIGHT ? -step : +step);\n\t    if (val < 0)\n\t\tval = 0;\n\n\t    gui_do_horiz_scroll(val, TRUE);\n\t}\n    }\n# endif\n# ifdef FEAT_SYN_HL\n    if (curwin != old_curwin && curwin->w_p_cul)\n\tredraw_for_cursorline(curwin);\n# endif\n    may_trigger_winscrolled();\n\n    curwin->w_redr_status = TRUE;\n\n    curwin = old_curwin;\n    curbuf = curwin->w_buffer;\n}\n\n/*\n * Mouse clicks and drags.\n */\n    void\nnv_mouse(cmdarg_T *cap)\n{\n    (void)do_mouse(cap->oap, cap->cmdchar, BACKWARD, cap->count1, 0);\n}\n\nstatic int\theld_button = MOUSE_RELEASE;\n\n    void\nreset_held_button()\n{\n    held_button = MOUSE_RELEASE;\n}\n\n/*\n * Check if typebuf 'tp' contains a terminal mouse code and returns the\n * modifiers found in typebuf in 'modifiers'.\n */\n    int\ncheck_termcode_mouse(\n    char_u\t*tp,\n    int\t\t*slen,\n    char_u\t*key_name,\n    char_u\t*modifiers_start,\n    int\t\tidx,\n    int\t\t*modifiers)\n{\n    int\t\tj;\n    char_u\t*p;\n# if !defined(UNIX) || defined(FEAT_MOUSE_XTERM) || defined(FEAT_GUI) \\\n    || defined(FEAT_MOUSE_GPM) || defined(FEAT_SYSMOUSE)\n    char_u\tbytes[6];\n    int\t\tnum_bytes;\n# endif\n    int\t\tmouse_code = 0;\t    // init for GCC\n    int\t\tis_click, is_drag;\n    int\t\tis_release, release_is_ambiguous;\n    int\t\twheel_code = 0;\n    int\t\tcurrent_button;\n    static int\torig_num_clicks = 1;\n    static int\torig_mouse_code = 0x0;\n# ifdef CHECK_DOUBLE_CLICK\n    static int\torig_mouse_col = 0;\n    static int\torig_mouse_row = 0;\n    static struct timeval  orig_mouse_time = {0, 0};\n    // time of previous mouse click\n    struct timeval  mouse_time;\t\t// time of current mouse click\n    long\ttimediff;\t\t// elapsed time in msec\n# endif\n\n    is_click = is_drag = is_release = release_is_ambiguous = FALSE;\n\n# if !defined(UNIX) || defined(FEAT_MOUSE_XTERM) || defined(FEAT_GUI) \\\n    || defined(FEAT_MOUSE_GPM) || defined(FEAT_SYSMOUSE)\n    if (key_name[0] == KS_MOUSE\n#  ifdef FEAT_MOUSE_GPM\n\t    || key_name[0] == KS_GPM_MOUSE\n#  endif\n       )\n    {\n\t/*\n\t * For xterm we get \"<t_mouse>scr\", where s == encoded button state:\n\t *\t   0x20 = left button down\n\t *\t   0x21 = middle button down\n\t *\t   0x22 = right button down\n\t *\t   0x23 = any button release\n\t *\t   0x60 = button 4 down (scroll wheel down)\n\t *\t   0x61 = button 5 down (scroll wheel up)\n\t *\tadd 0x04 for SHIFT\n\t *\tadd 0x08 for ALT\n\t *\tadd 0x10 for CTRL\n\t *\tadd 0x20 for mouse drag (0x40 is drag with left button)\n\t *\tadd 0x40 for mouse move (0x80 is move, 0x81 too)\n\t *\t\t 0x43 (drag + release) is also move\n\t *  c == column + ' ' + 1 == column + 33\n\t *  r == row + ' ' + 1 == row + 33\n\t *\n\t * The coordinates are passed on through global variables.  Ugly, but\n\t * this avoids trouble with mouse clicks at an unexpected moment and\n\t * allows for mapping them.\n\t */\n\tfor (;;)\n\t{\n#  ifdef FEAT_GUI\n\t    if (gui.in_use)\n\t    {\n\t\t// GUI uses more bits for columns > 223\n\t\tnum_bytes = get_bytes_from_buf(tp + *slen, bytes, 5);\n\t\tif (num_bytes == -1)\t// not enough coordinates\n\t\t    return -1;\n\t\tmouse_code = bytes[0];\n\t\tmouse_col = 128 * (bytes[1] - ' ' - 1)\n\t\t    + bytes[2] - ' ' - 1;\n\t\tmouse_row = 128 * (bytes[3] - ' ' - 1)\n\t\t    + bytes[4] - ' ' - 1;\n\t    }\n\t    else\n#  endif\n\t    {\n\t\tnum_bytes = get_bytes_from_buf(tp + *slen, bytes, 3);\n\t\tif (num_bytes == -1)\t// not enough coordinates\n\t\t    return -1;\n\t\tmouse_code = bytes[0];\n\t\tmouse_col = bytes[1] - ' ' - 1;\n\t\tmouse_row = bytes[2] - ' ' - 1;\n\t    }\n\t    *slen += num_bytes;\n\n\t    // If the following bytes is also a mouse code and it has the same\n\t    // code, dump this one and get the next.  This makes dragging a\n\t    // whole lot faster.\n#  ifdef FEAT_GUI\n\t    if (gui.in_use)\n\t\tj = 3;\n\t    else\n#  endif\n\t\tj = get_termcode_len(idx);\n\t    if (STRNCMP(tp, tp + *slen, (size_t)j) == 0\n\t\t    && tp[*slen + j] == mouse_code\n\t\t    && tp[*slen + j + 1] != NUL\n\t\t    && tp[*slen + j + 2] != NUL\n#  ifdef FEAT_GUI\n\t\t    && (!gui.in_use\n\t\t\t|| (tp[*slen + j + 3] != NUL\n\t\t\t    && tp[*slen + j + 4] != NUL))\n#  endif\n\t       )\n\t\t*slen += j;\n\t    else\n\t\tbreak;\n\t}\n    }\n\n    if (key_name[0] == KS_URXVT_MOUSE\n\t    || key_name[0] == KS_SGR_MOUSE\n\t    || key_name[0] == KS_SGR_MOUSE_RELEASE)\n    {\n\t// URXVT 1015 mouse reporting mode:\n\t// Almost identical to xterm mouse mode, except the values are decimal\n\t// instead of bytes.\n\t//\n\t// \\033[%d;%d;%dM\n\t//\t       ^-- row\n\t//\t    ^----- column\n\t//\t ^-------- code\n\t//\n\t// SGR 1006 mouse reporting mode:\n\t// Almost identical to xterm mouse mode, except the values are decimal\n\t// instead of bytes.\n\t//\n\t// \\033[<%d;%d;%dM\n\t//\t       ^-- row\n\t//\t    ^----- column\n\t//\t ^-------- code\n\t//\n\t// \\033[<%d;%d;%dm\t  : mouse release event\n\t//\t       ^-- row\n\t//\t    ^----- column\n\t//\t ^-------- code\n\tp = modifiers_start;\n\tif (p == NULL)\n\t    return -1;\n\n\tmouse_code = getdigits(&p);\n\tif (*p++ != ';')\n\t    return -1;\n\n\t// when mouse reporting is SGR, add 32 to mouse code\n\tif (key_name[0] == KS_SGR_MOUSE\n\t\t|| key_name[0] == KS_SGR_MOUSE_RELEASE)\n\t    mouse_code += 32;\n\n\tmouse_col = getdigits(&p) - 1;\n\tif (*p++ != ';')\n\t    return -1;\n\n\tmouse_row = getdigits(&p) - 1;\n\n\t// The modifiers were the mouse coordinates, not the modifier keys\n\t// (alt/shift/ctrl/meta) state.\n\t*modifiers = 0;\n    }\n\n    if (key_name[0] == KS_SGR_MOUSE\n\t    || key_name[0] == KS_SGR_MOUSE_RELEASE)\n    {\n\tif (key_name[0] == KS_SGR_MOUSE_RELEASE)\n\t{\n\t    is_release = TRUE;\n\t    // This is used below to set held_button.\n\t    mouse_code |= MOUSE_RELEASE;\n\t}\n    }\n    else\n    {\n\trelease_is_ambiguous = TRUE;\n\tif ((mouse_code & MOUSE_RELEASE) == MOUSE_RELEASE)\n\t    is_release = TRUE;\n    }\n\n    if (key_name[0] == KS_MOUSE\n#  ifdef FEAT_MOUSE_GPM\n\t    || key_name[0] == KS_GPM_MOUSE\n#  endif\n#  ifdef FEAT_MOUSE_URXVT\n\t    || key_name[0] == KS_URXVT_MOUSE\n#  endif\n\t    || key_name[0] == KS_SGR_MOUSE\n\t    || key_name[0] == KS_SGR_MOUSE_RELEASE)\n    {\n#  if !defined(MSWIN)\n\t/*\n\t * Handle old style mouse events.\n\t * Recognize the xterm mouse wheel, but not in the GUI, the\n\t * Linux console with GPM and the MS-DOS or Win32 console\n\t * (multi-clicks use >= 0x60).\n\t */\n\tif (mouse_code >= MOUSEWHEEL_LOW\n#   ifdef FEAT_GUI\n\t\t&& !gui.in_use\n#   endif\n#   ifdef FEAT_MOUSE_GPM\n\t\t&& key_name[0] != KS_GPM_MOUSE\n#   endif\n\t   )\n\t{\n#   if defined(UNIX)\n\t    if (use_xterm_mouse() > 1 && mouse_code >= 0x80)\n\t\t// mouse-move event, using MOUSE_DRAG works\n\t\tmouse_code = MOUSE_DRAG;\n\t    else\n#   endif\n\t\t// Keep the mouse_code before it's changed, so that we\n\t\t// remember that it was a mouse wheel click.\n\t\twheel_code = mouse_code;\n\t}\n#   ifdef FEAT_MOUSE_XTERM\n\telse if (held_button == MOUSE_RELEASE\n#    ifdef FEAT_GUI\n\t\t&& !gui.in_use\n#    endif\n\t\t&& (mouse_code == 0x23 || mouse_code == 0x24\n\t\t    || mouse_code == 0x40 || mouse_code == 0x41))\n\t{\n\t    // Apparently 0x23 and 0x24 are used by rxvt scroll wheel.\n\t    // And 0x40 and 0x41 are used by some xterm emulator.\n\t    wheel_code = mouse_code - (mouse_code >= 0x40 ? 0x40 : 0x23)\n\t\t\t\t\t\t\t      + MOUSEWHEEL_LOW;\n\t}\n#   endif\n\n#   if defined(UNIX)\n\telse if (use_xterm_mouse() > 1)\n\t{\n\t    if (mouse_code & MOUSE_DRAG_XTERM)\n\t\tmouse_code |= MOUSE_DRAG;\n\t}\n#   endif\n#   ifdef FEAT_XCLIPBOARD\n\telse if (!(mouse_code & MOUSE_DRAG & ~MOUSE_CLICK_MASK))\n\t{\n\t    if (is_release)\n\t\tstop_xterm_trace();\n\t    else\n\t\tstart_xterm_trace(mouse_code);\n\t}\n#   endif\n#  endif\n    }\n# endif // !UNIX || FEAT_MOUSE_XTERM\n# ifdef FEAT_MOUSE_NET\n    if (key_name[0] == KS_NETTERM_MOUSE)\n    {\n\tint mc, mr;\n\n\t// expect a rather limited sequence like: balancing {\n\t// \\033}6,45\\r\n\t// '6' is the row, 45 is the column\n\tp = tp + *slen;\n\tmr = getdigits(&p);\n\tif (*p++ != ',')\n\t    return -1;\n\tmc = getdigits(&p);\n\tif (*p++ != '\\r')\n\t    return -1;\n\n\tmouse_col = mc - 1;\n\tmouse_row = mr - 1;\n\tmouse_code = MOUSE_LEFT;\n\t*slen += (int)(p - (tp + *slen));\n    }\n# endif\t// FEAT_MOUSE_NET\n# ifdef FEAT_MOUSE_JSB\n    if (key_name[0] == KS_JSBTERM_MOUSE)\n    {\n\tint mult, val, iter, button, status;\n\n\t/*\n\t * JSBTERM Input Model\n\t * \\033[0~zw uniq escape sequence\n\t * (L-x)  Left button pressed - not pressed x not reporting\n\t * (M-x)  Middle button pressed - not pressed x not reporting\n\t * (R-x)  Right button pressed - not pressed x not reporting\n\t * (SDmdu)  Single , Double click, m: mouse move, d: button down,\n\t\t      *\t\t\t\t\t\t   u: button up\n\t *  ###   X cursor position padded to 3 digits\n\t *  ###   Y cursor position padded to 3 digits\n\t * (s-x)  SHIFT key pressed - not pressed x not reporting\n\t * (c-x)  CTRL key pressed - not pressed x not reporting\n\t * \\033\\\\ terminating sequence\n\t */\n\tp = tp + *slen;\n\tbutton = mouse_code = 0;\n\tswitch (*p++)\n\t{\n\t    case 'L': button = 1; break;\n\t    case '-': break;\n\t    case 'x': break; // ignore sequence\n\t    default:  return -1; // Unknown Result\n\t}\n\tswitch (*p++)\n\t{\n\t    case 'M': button |= 2; break;\n\t    case '-': break;\n\t    case 'x': break; // ignore sequence\n\t    default:  return -1; // Unknown Result\n\t}\n\tswitch (*p++)\n\t{\n\t    case 'R': button |= 4; break;\n\t    case '-': break;\n\t    case 'x': break; // ignore sequence\n\t    default:  return -1; // Unknown Result\n\t}\n\tstatus = *p++;\n\tfor (val = 0, mult = 100, iter = 0; iter < 3; iter++,\n\t\tmult /= 10, p++)\n\t    if (*p >= '0' && *p <= '9')\n\t\tval += (*p - '0') * mult;\n\t    else\n\t\treturn -1;\n\tmouse_col = val;\n\tfor (val = 0, mult = 100, iter = 0; iter < 3; iter++,\n\t\tmult /= 10, p++)\n\t    if (*p >= '0' && *p <= '9')\n\t\tval += (*p - '0') * mult;\n\t    else\n\t\treturn -1;\n\tmouse_row = val;\n\tswitch (*p++)\n\t{\n\t    case 's': button |= 8; break;  // SHIFT key Pressed\n\t    case '-': break;  // Not Pressed\n\t    case 'x': break;  // Not Reporting\n\t    default:  return -1; // Unknown Result\n\t}\n\tswitch (*p++)\n\t{\n\t    case 'c': button |= 16; break;  // CTRL key Pressed\n\t    case '-': break;  // Not Pressed\n\t    case 'x': break;  // Not Reporting\n\t    default:  return -1; // Unknown Result\n\t}\n\tif (*p++ != '\\033')\n\t    return -1;\n\tif (*p++ != '\\\\')\n\t    return -1;\n\tswitch (status)\n\t{\n\t    case 'D': // Double Click\n\t    case 'S': // Single Click\n\t\tif (button & 1) mouse_code |= MOUSE_LEFT;\n\t\tif (button & 2) mouse_code |= MOUSE_MIDDLE;\n\t\tif (button & 4) mouse_code |= MOUSE_RIGHT;\n\t\tif (button & 8) mouse_code |= MOUSE_SHIFT;\n\t\tif (button & 16) mouse_code |= MOUSE_CTRL;\n\t\tbreak;\n\t    case 'm': // Mouse move\n\t\tif (button & 1) mouse_code |= MOUSE_LEFT;\n\t\tif (button & 2) mouse_code |= MOUSE_MIDDLE;\n\t\tif (button & 4) mouse_code |= MOUSE_RIGHT;\n\t\tif (button & 8) mouse_code |= MOUSE_SHIFT;\n\t\tif (button & 16) mouse_code |= MOUSE_CTRL;\n\t\tif ((button & 7) != 0)\n\t\t{\n\t\t    held_button = mouse_code;\n\t\t    mouse_code |= MOUSE_DRAG;\n\t\t}\n\t\tis_drag = TRUE;\n\t\tshowmode();\n\t\tbreak;\n\t    case 'd': // Button Down\n\t\tif (button & 1) mouse_code |= MOUSE_LEFT;\n\t\tif (button & 2) mouse_code |= MOUSE_MIDDLE;\n\t\tif (button & 4) mouse_code |= MOUSE_RIGHT;\n\t\tif (button & 8) mouse_code |= MOUSE_SHIFT;\n\t\tif (button & 16) mouse_code |= MOUSE_CTRL;\n\t\tbreak;\n\t    case 'u': // Button Up\n\t\tis_release = TRUE;\n\t\tif (button & 1)\n\t\t    mouse_code |= MOUSE_LEFT;\n\t\tif (button & 2)\n\t\t    mouse_code |= MOUSE_MIDDLE;\n\t\tif (button & 4)\n\t\t    mouse_code |= MOUSE_RIGHT;\n\t\tif (button & 8)\n\t\t    mouse_code |= MOUSE_SHIFT;\n\t\tif (button & 16)\n\t\t    mouse_code |= MOUSE_CTRL;\n\t\tbreak;\n\t    default: return -1; // Unknown Result\n\t}\n\n\t*slen += (p - (tp + *slen));\n    }\n# endif // FEAT_MOUSE_JSB\n# ifdef FEAT_MOUSE_DEC\n    if (key_name[0] == KS_DEC_MOUSE)\n    {\n\t/*\n\t * The DEC Locator Input Model\n\t * Netterm delivers the code sequence:\n\t *  \\033[2;4;24;80&w  (left button down)\n\t *  \\033[3;0;24;80&w  (left button up)\n\t *  \\033[6;1;24;80&w  (right button down)\n\t *  \\033[7;0;24;80&w  (right button up)\n\t * CSI Pe ; Pb ; Pr ; Pc ; Pp & w\n\t * Pe is the event code\n\t * Pb is the button code\n\t * Pr is the row coordinate\n\t * Pc is the column coordinate\n\t * Pp is the third coordinate (page number)\n\t * Pe, the event code indicates what event caused this report\n\t *    The following event codes are defined:\n\t *    0 - request, the terminal received an explicit request for a\n\t *\t  locator report, but the locator is unavailable\n\t *    1 - request, the terminal received an explicit request for a\n\t *\t  locator report\n\t *    2 - left button down\n\t *    3 - left button up\n\t *    4 - middle button down\n\t *    5 - middle button up\n\t *    6 - right button down\n\t *    7 - right button up\n\t *    8 - fourth button down\n\t *    9 - fourth button up\n\t *    10 - locator outside filter rectangle\n\t * Pb, the button code, ASCII decimal 0-15 indicating which buttons are\n\t *   down if any. The state of the four buttons on the locator\n\t *   correspond to the low four bits of the decimal value, \"1\" means\n\t *   button depressed\n\t *   0 - no buttons down,\n\t *   1 - right,\n\t *   2 - middle,\n\t *   4 - left,\n\t *   8 - fourth\n\t * Pr is the row coordinate of the locator position in the page,\n\t *   encoded as an ASCII decimal value.  If Pr is omitted, the locator\n\t *   position is undefined (outside the terminal window for example).\n\t * Pc is the column coordinate of the locator position in the page,\n\t *   encoded as an ASCII decimal value.  If Pc is omitted, the locator\n\t *   position is undefined (outside the terminal window for example).\n\t * Pp is the page coordinate of the locator position encoded as an\n\t *   ASCII decimal value.  The page coordinate may be omitted if the\n\t *   locator is on page one (the default).  We ignore it anyway.\n\t */\n\tint Pe, Pb, Pr, Pc;\n\n\tp = tp + *slen;\n\n\t// get event status\n\tPe = getdigits(&p);\n\tif (*p++ != ';')\n\t    return -1;\n\n\t// get button status\n\tPb = getdigits(&p);\n\tif (*p++ != ';')\n\t    return -1;\n\n\t// get row status\n\tPr = getdigits(&p);\n\tif (*p++ != ';')\n\t    return -1;\n\n\t// get column status\n\tPc = getdigits(&p);\n\n\t// the page parameter is optional\n\tif (*p == ';')\n\t{\n\t    p++;\n\t    (void)getdigits(&p);\n\t}\n\tif (*p++ != '&')\n\t    return -1;\n\tif (*p++ != 'w')\n\t    return -1;\n\n\tmouse_code = 0;\n\tswitch (Pe)\n\t{\n\t    case  0: return -1; // position request while unavailable\n\t    case  1: // a response to a locator position request includes\n\t\t     //\tthe status of all buttons\n\t\t     Pb &= 7;   // mask off and ignore fourth button\n\t\t     if (Pb & 4)\n\t\t\t mouse_code  = MOUSE_LEFT;\n\t\t     if (Pb & 2)\n\t\t\t mouse_code  = MOUSE_MIDDLE;\n\t\t     if (Pb & 1)\n\t\t\t mouse_code  = MOUSE_RIGHT;\n\t\t     if (Pb)\n\t\t     {\n\t\t\t held_button = mouse_code;\n\t\t\t mouse_code |= MOUSE_DRAG;\n\t\t\t WantQueryMouse = TRUE;\n\t\t     }\n\t\t     is_drag = TRUE;\n\t\t     showmode();\n\t\t     break;\n\t    case  2: mouse_code = MOUSE_LEFT;\n\t\t     WantQueryMouse = TRUE;\n\t\t     break;\n\t    case  3: mouse_code = MOUSE_LEFT;\n\t\t     is_release = TRUE;\n\t\t     break;\n\t    case  4: mouse_code = MOUSE_MIDDLE;\n\t\t     WantQueryMouse = TRUE;\n\t\t     break;\n\t    case  5: mouse_code = MOUSE_MIDDLE;\n\t\t     is_release = TRUE;\n\t\t     break;\n\t    case  6: mouse_code = MOUSE_RIGHT;\n\t\t     WantQueryMouse = TRUE;\n\t\t     break;\n\t    case  7: mouse_code = MOUSE_RIGHT;\n\t\t     is_release = TRUE;\n\t\t     break;\n\t    case  8: return -1; // fourth button down\n\t    case  9: return -1; // fourth button up\n\t    case 10: return -1; // mouse outside of filter rectangle\n\t    default: return -1; // should never occur\n\t}\n\n\tmouse_col = Pc - 1;\n\tmouse_row = Pr - 1;\n\n\t*slen += (int)(p - (tp + *slen));\n    }\n# endif // FEAT_MOUSE_DEC\n# ifdef FEAT_MOUSE_PTERM\n    if (key_name[0] == KS_PTERM_MOUSE)\n    {\n\tint button, num_clicks, action;\n\n\tp = tp + *slen;\n\n\taction = getdigits(&p);\n\tif (*p++ != ';')\n\t    return -1;\n\n\tmouse_row = getdigits(&p);\n\tif (*p++ != ';')\n\t    return -1;\n\tmouse_col = getdigits(&p);\n\tif (*p++ != ';')\n\t    return -1;\n\n\tbutton = getdigits(&p);\n\tmouse_code = 0;\n\n\tswitch (button)\n\t{\n\t    case 4: mouse_code = MOUSE_LEFT; break;\n\t    case 1: mouse_code = MOUSE_RIGHT; break;\n\t    case 2: mouse_code = MOUSE_MIDDLE; break;\n\t    default: return -1;\n\t}\n\n\tswitch (action)\n\t{\n\t    case 31: // Initial press\n\t\tif (*p++ != ';')\n\t\t    return -1;\n\n\t\tnum_clicks = getdigits(&p); // Not used\n\t\tbreak;\n\n\t    case 32: // Release\n\t\tis_release = TRUE;\n\t\tbreak;\n\n\t    case 33: // Drag\n\t\theld_button = mouse_code;\n\t\tmouse_code |= MOUSE_DRAG;\n\t\tbreak;\n\n\t    default:\n\t\treturn -1;\n\t}\n\n\tif (*p++ != 't')\n\t    return -1;\n\n\t*slen += (p - (tp + *slen));\n    }\n# endif // FEAT_MOUSE_PTERM\n\n    // Interpret the mouse code\n    current_button = (mouse_code & MOUSE_CLICK_MASK);\n    if (is_release)\n\tcurrent_button |= MOUSE_RELEASE;\n\n    if (current_button == MOUSE_RELEASE\n# ifdef FEAT_MOUSE_XTERM\n\t    && wheel_code == 0\n# endif\n       )\n    {\n\t/*\n\t * If we get a mouse drag or release event when there is no mouse\n\t * button held down (held_button == MOUSE_RELEASE), produce a K_IGNORE\n\t * below.\n\t * (can happen when you hold down two buttons and then let them go, or\n\t * click in the menu bar, but not on a menu, and drag into the text).\n\t */\n\tif ((mouse_code & MOUSE_DRAG) == MOUSE_DRAG)\n\t    is_drag = TRUE;\n\tcurrent_button = held_button;\n    }\n    else\n    {\n      if (wheel_code == 0)\n      {\n# ifdef CHECK_DOUBLE_CLICK\n#  ifdef FEAT_MOUSE_GPM\n\t/*\n\t * Only for Unix, when GUI not active, we handle multi-clicks here, but\n\t * not for GPM mouse events.\n\t */\n#   ifdef FEAT_GUI\n\tif (key_name[0] != KS_GPM_MOUSE && !gui.in_use)\n#   else\n\t    if (key_name[0] != KS_GPM_MOUSE)\n#   endif\n#  else\n#   ifdef FEAT_GUI\n\t\tif (!gui.in_use)\n#   endif\n#  endif\n\t\t{\n\t\t    /*\n\t\t     * Compute the time elapsed since the previous mouse click.\n\t\t     */\n\t\t    gettimeofday(&mouse_time, NULL);\n\t\t    if (orig_mouse_time.tv_sec == 0)\n\t\t    {\n\t\t\t/*\n\t\t\t * Avoid computing the difference between mouse_time\n\t\t\t * and orig_mouse_time for the first click, as the\n\t\t\t * difference would be huge and would cause\n\t\t\t * multiplication overflow.\n\t\t\t */\n\t\t\ttimediff = p_mouset;\n\t\t    }\n\t\t    else\n\t\t\ttimediff = time_diff_ms(&orig_mouse_time, &mouse_time);\n\t\t    orig_mouse_time = mouse_time;\n\t\t    if (mouse_code == orig_mouse_code\n\t\t\t    && timediff < p_mouset\n\t\t\t    && orig_num_clicks != 4\n\t\t\t    && orig_mouse_col == mouse_col\n\t\t\t    && orig_mouse_row == mouse_row\n\t\t\t    && (is_mouse_topline(curwin)\n\t\t\t\t// Double click in tab pages line also works\n\t\t\t\t// when window contents changes.\n\t\t\t\t|| (mouse_row == 0 && firstwin->w_winrow > 0))\n\t\t       )\n\t\t\t++orig_num_clicks;\n\t\t    else\n\t\t\torig_num_clicks = 1;\n\t\t    orig_mouse_col = mouse_col;\n\t\t    orig_mouse_row = mouse_row;\n\t\t    set_mouse_topline(curwin);\n\t\t}\n#  if defined(FEAT_GUI) || defined(FEAT_MOUSE_GPM)\n\t\telse\n\t\t    orig_num_clicks = NUM_MOUSE_CLICKS(mouse_code);\n#  endif\n# else\n\torig_num_clicks = NUM_MOUSE_CLICKS(mouse_code);\n# endif\n\tis_click = TRUE;\n      }\n      orig_mouse_code = mouse_code;\n    }\n    if (!is_drag)\n\theld_button = mouse_code & MOUSE_CLICK_MASK;\n\n    /*\n     * Translate the actual mouse event into a pseudo mouse event.\n     * First work out what modifiers are to be used.\n     */\n    if (orig_mouse_code & MOUSE_SHIFT)\n\t*modifiers |= MOD_MASK_SHIFT;\n    if (orig_mouse_code & MOUSE_CTRL)\n\t*modifiers |= MOD_MASK_CTRL;\n    if (orig_mouse_code & MOUSE_ALT)\n\t*modifiers |= MOD_MASK_ALT;\n    if (orig_num_clicks == 2)\n\t*modifiers |= MOD_MASK_2CLICK;\n    else if (orig_num_clicks == 3)\n\t*modifiers |= MOD_MASK_3CLICK;\n    else if (orig_num_clicks == 4)\n\t*modifiers |= MOD_MASK_4CLICK;\n\n    // Work out our pseudo mouse event. Note that MOUSE_RELEASE gets added,\n    // then it's not mouse up/down.\n    key_name[0] = KS_EXTRA;\n    if (wheel_code != 0 && (!is_release || release_is_ambiguous))\n    {\n\tif (wheel_code & MOUSE_CTRL)\n\t    *modifiers |= MOD_MASK_CTRL;\n\tif (wheel_code & MOUSE_ALT)\n\t    *modifiers |= MOD_MASK_ALT;\n\n\tif (wheel_code & 1 && wheel_code & 2)\n\t    key_name[1] = (int)KE_MOUSELEFT;\n\telse if (wheel_code & 2)\n\t    key_name[1] = (int)KE_MOUSERIGHT;\n\telse if (wheel_code & 1)\n\t    key_name[1] = (int)KE_MOUSEUP;\n\telse\n\t    key_name[1] = (int)KE_MOUSEDOWN;\n\n\theld_button = MOUSE_RELEASE;\n    }\n    else\n\tkey_name[1] = get_pseudo_mouse_code(current_button, is_click, is_drag);\n\n\n    // Make sure the mouse position is valid.  Some terminals may return weird\n    // values.\n    if (mouse_col >= Columns)\n\tmouse_col = Columns - 1;\n    if (mouse_row >= Rows)\n\tmouse_row = Rows - 1;\n\n    return 0;\n}\n\n// Functions also used for popup windows.\n\n/*\n * Compute the buffer line position from the screen position \"rowp\" / \"colp\" in\n * window \"win\".\n * \"plines_cache\" can be NULL (no cache) or an array with \"Rows\" entries that\n * caches the plines_win() result from a previous call.  Entry is zero if not\n * computed yet.  There must be no text or setting changes since the entry is\n * put in the cache.\n * Returns TRUE if the position is below the last line.\n */\n    int\nmouse_comp_pos(\n    win_T\t*win,\n    int\t\t*rowp,\n    int\t\t*colp,\n    linenr_T\t*lnump,\n    int\t\t*plines_cache)\n{\n    int\t\tcol = *colp;\n    int\t\trow = *rowp;\n    linenr_T\tlnum;\n    int\t\tretval = FALSE;\n    int\t\toff;\n    int\t\tcount;\n\n#ifdef FEAT_RIGHTLEFT\n    if (win->w_p_rl)\n\tcol = win->w_width - 1 - col;\n#endif\n\n    lnum = win->w_topline;\n\n    while (row > 0)\n    {\n\tint cache_idx = lnum - win->w_topline;\n\n\t// Only \"Rows\" lines are cached, with folding we'll run out of entries\n\t// and use the slow way.\n\tif (plines_cache != NULL && cache_idx < Rows\n\t\t\t\t\t\t&& plines_cache[cache_idx] > 0)\n\t    count = plines_cache[cache_idx];\n\telse\n\t{\n#ifdef FEAT_DIFF\n\t    // Don't include filler lines in \"count\"\n\t    if (win->w_p_diff\n# ifdef FEAT_FOLDING\n\t\t    && !hasFoldingWin(win, lnum, NULL, NULL, TRUE, NULL)\n# endif\n\t\t    )\n\t    {\n\t\tif (lnum == win->w_topline)\n\t\t    row -= win->w_topfill;\n\t\telse\n\t\t    row -= diff_check_fill(win, lnum);\n\t\tcount = plines_win_nofill(win, lnum, TRUE);\n\t    }\n\t    else\n#endif\n\t\tcount = plines_win(win, lnum, TRUE);\n\t    if (plines_cache != NULL && cache_idx < Rows)\n\t\tplines_cache[cache_idx] = count;\n\t}\n\tif (count > row)\n\t    break;\t// Position is in this buffer line.\n#ifdef FEAT_FOLDING\n\t(void)hasFoldingWin(win, lnum, NULL, &lnum, TRUE, NULL);\n#endif\n\tif (lnum == win->w_buffer->b_ml.ml_line_count)\n\t{\n\t    retval = TRUE;\n\t    break;\t\t// past end of file\n\t}\n\trow -= count;\n\t++lnum;\n    }\n\n    if (!retval)\n    {\n\t// Compute the column without wrapping.\n\toff = win_col_off(win) - win_col_off2(win);\n\tif (col < off)\n\t    col = off;\n\tcol += row * (win->w_width - off);\n\t// add skip column (for long wrapping line)\n\tcol += win->w_skipcol;\n    }\n\n    if (!win->w_p_wrap)\n\tcol += win->w_leftcol;\n\n    // skip line number and fold column in front of the line\n    col -= win_col_off(win);\n    if (col <= 0)\n    {\n#ifdef FEAT_NETBEANS_INTG\n\t// if mouse is clicked on the gutter, then inform the netbeans server\n\tif (*colp < win_col_off(win))\n\t    netbeans_gutter_click(lnum);\n#endif\n\tcol = 0;\n    }\n\n    *colp = col;\n    *rowp = row;\n    *lnump = lnum;\n    return retval;\n}\n\n/*\n * Find the window at screen position \"*rowp\" and \"*colp\".  The positions are\n * updated to become relative to the top-left of the window.\n * When \"popup\" is FAIL_POPUP and the position is in a popup window then NULL\n * is returned.  When \"popup\" is IGNORE_POPUP then do not even check popup\n * windows.\n * Returns NULL when something is wrong.\n */\n    win_T *\nmouse_find_win(int *rowp, int *colp, mouse_find_T popup UNUSED)\n{\n    frame_T\t*fp;\n    win_T\t*wp;\n\n#ifdef FEAT_PROP_POPUP\n    win_T\t*pwp = NULL;\n\n    if (popup != IGNORE_POPUP)\n    {\n\tpopup_reset_handled(POPUP_HANDLED_1);\n\twhile ((wp = find_next_popup(TRUE, POPUP_HANDLED_1)) != NULL)\n\t{\n\t    if (*rowp >= wp->w_winrow && *rowp < wp->w_winrow + popup_height(wp)\n\t\t    && *colp >= wp->w_wincol\n\t\t\t\t    && *colp < wp->w_wincol + popup_width(wp))\n\t\tpwp = wp;\n\t}\n\tif (pwp != NULL)\n\t{\n\t    if (popup == FAIL_POPUP)\n\t\treturn NULL;\n\t    *rowp -= pwp->w_winrow;\n\t    *colp -= pwp->w_wincol;\n\t    return pwp;\n\t}\n    }\n#endif\n\n    fp = topframe;\n    *rowp -= firstwin->w_winrow;\n    for (;;)\n    {\n\tif (fp->fr_layout == FR_LEAF)\n\t    break;\n\tif (fp->fr_layout == FR_ROW)\n\t{\n\t    for (fp = fp->fr_child; fp->fr_next != NULL; fp = fp->fr_next)\n\t    {\n\t\tif (*colp < fp->fr_width)\n\t\t    break;\n\t\t*colp -= fp->fr_width;\n\t    }\n\t}\n\telse    // fr_layout == FR_COL\n\t{\n\t    for (fp = fp->fr_child; fp->fr_next != NULL; fp = fp->fr_next)\n\t    {\n\t\tif (*rowp < fp->fr_height)\n\t\t    break;\n\t\t*rowp -= fp->fr_height;\n\t    }\n\t}\n    }\n    // When using a timer that closes a window the window might not actually\n    // exist.\n    FOR_ALL_WINDOWS(wp)\n\tif (wp == fp->fr_win)\n\t{\n#ifdef FEAT_MENU\n\t    *rowp -= wp->w_winbar_height;\n#endif\n\t    return wp;\n\t}\n    return NULL;\n}\n\n#if defined(NEED_VCOL2COL) || defined(FEAT_BEVAL) || defined(FEAT_PROP_POPUP) \\\n\t|| defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Convert a virtual (screen) column to a character column.\n * The first column is one.\n */\n    int\nvcol2col(win_T *wp, linenr_T lnum, int vcol)\n{\n    char_u\t    *line;\n    chartabsize_T   cts;\n\n    // try to advance to the specified column\n    line = ml_get_buf(wp->w_buffer, lnum, FALSE);\n    init_chartabsize_arg(&cts, wp, lnum, 0, line, line);\n    while (cts.cts_vcol < vcol && *cts.cts_ptr != NUL)\n    {\n\tcts.cts_vcol += win_lbr_chartabsize(&cts, NULL);\n\tMB_PTR_ADV(cts.cts_ptr);\n    }\n    clear_chartabsize_arg(&cts);\n\n    return (int)(cts.cts_ptr - line);\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n    void\nf_getmousepos(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    dict_T\t*d;\n    win_T\t*wp;\n    int\t\trow = mouse_row;\n    int\t\tcol = mouse_col;\n    varnumber_T winid = 0;\n    varnumber_T winrow = 0;\n    varnumber_T wincol = 0;\n    linenr_T\tlnum = 0;\n    varnumber_T column = 0;\n\n    if (rettv_dict_alloc(rettv) == FAIL)\n\treturn;\n    d = rettv->vval.v_dict;\n\n    dict_add_number(d, \"screenrow\", (varnumber_T)mouse_row + 1);\n    dict_add_number(d, \"screencol\", (varnumber_T)mouse_col + 1);\n\n    wp = mouse_find_win(&row, &col, FIND_POPUP);\n    if (wp != NULL)\n    {\n\tint\ttop_off = 0;\n\tint\tleft_off = 0;\n\tint\theight = wp->w_height + wp->w_status_height;\n\n#ifdef FEAT_PROP_POPUP\n\tif (WIN_IS_POPUP(wp))\n\t{\n\t    top_off = popup_top_extra(wp);\n\t    left_off = popup_left_extra(wp);\n\t    height = popup_height(wp);\n\t}\n#endif\n\tif (row < height)\n\t{\n\t    winid = wp->w_id;\n\t    winrow = row + 1;\n\t    wincol = col + 1;\n\t    row -= top_off;\n\t    col -= left_off;\n\t    if (row >= 0 && row < wp->w_height && col >= 0 && col < wp->w_width)\n\t    {\n\t\t(void)mouse_comp_pos(wp, &row, &col, &lnum, NULL);\n\t\tcol = vcol2col(wp, lnum, col);\n\t\tcolumn = col + 1;\n\t    }\n\t}\n    }\n    dict_add_number(d, \"winid\", winid);\n    dict_add_number(d, \"winrow\", winrow);\n    dict_add_number(d, \"wincol\", wincol);\n    dict_add_number(d, \"line\", (varnumber_T)lnum);\n    dict_add_number(d, \"column\", column);\n}\n#endif\n", "\" Test for tabline\n\nsource shared.vim\n\nfunc TablineWithCaughtError()\n  let s:func_in_tabline_called = 1\n  try\n    call eval('unknown expression')\n  catch\n  endtry\n  return ''\nendfunc\n\nfunc TablineWithError()\n  let s:func_in_tabline_called = 1\n  call eval('unknown expression')\n  return ''\nendfunc\n\nfunc Test_caught_error_in_tabline()\n  if has('gui')\n    set guioptions-=e\n  endif\n  let showtabline_save = &showtabline\n  set showtabline=2\n  let s:func_in_tabline_called = 0\n  let tabline = '%{TablineWithCaughtError()}'\n  let &tabline = tabline\n  redraw!\n  call assert_true(s:func_in_tabline_called)\n  call assert_equal(tabline, &tabline)\n  set tabline=\n  let &showtabline = showtabline_save\nendfunc\n\nfunc Test_tabline_will_be_disabled_with_error()\n  if has('gui')\n    set guioptions-=e\n  endif\n  let showtabline_save = &showtabline\n  set showtabline=2\n  let s:func_in_tabline_called = 0\n  let tabline = '%{TablineWithError()}'\n  try\n    let &tabline = tabline\n    redraw!\n  catch\n  endtry\n  call assert_true(s:func_in_tabline_called)\n  call assert_equal('', &tabline)\n  set tabline=\n  let &showtabline = showtabline_save\nendfunc\n\nfunc Test_redrawtabline()\n  if has('gui')\n    set guioptions-=e\n  endif\n  let showtabline_save = &showtabline\n  set showtabline=2\n  set tabline=%{bufnr('$')}\n  edit Xtabline1\n  edit Xtabline2\n  redraw\n  call assert_match(bufnr('$') . '', Screenline(1))\n  au BufAdd * redrawtabline\n  badd Xtabline3\n  call assert_match(bufnr('$') . '', Screenline(1))\n\n  set tabline=\n  let &showtabline = showtabline_save\n  au! Bufadd\nendfunc\n\n\" Test for the \"%T\" and \"%X\" flags in the 'tabline' option\nfunc MyTabLine()\n  let s = ''\n  for i in range(tabpagenr('$'))\n    \" set the tab page number (for mouse clicks)\n    let s .= '%' . (i + 1) . 'T'\n\n    \" the label is made by MyTabLabel()\n    let s .= ' %{MyTabLabel(' . (i + 1) . ')} '\n  endfor\n\n  \" after the last tab fill with TabLineFill and reset tab page nr\n  let s .= '%T'\n\n  \" right-align the label to close the current tab page\n  if tabpagenr('$') > 1\n    let s .= '%=%Xclose'\n  endif\n\n  return s\nendfunc\n\nfunc MyTabLabel(n)\n  let buflist = tabpagebuflist(a:n)\n  let winnr = tabpagewinnr(a:n)\n  return bufname(buflist[winnr - 1])\nendfunc\n\nfunc Test_tabline_flags()\n  if has('gui')\n    set guioptions-=e\n  endif\n  set tabline=%!MyTabLine()\n  edit Xtabline1\n  tabnew Xtabline2\n  redrawtabline\n  call assert_match('^ Xtabline1  Xtabline2\\s\\+close$', Screenline(1))\n  set tabline=\n  %bw!\nendfunc\n\nfunction EmptyTabname()\n  return \"\"\nendfunction\n\nfunction MakeTabLine() abort\n  let titles = map(range(1, tabpagenr('$')), '\"%( %\" . v:val . \"T%{EmptyTabname()}%T %)\"')\n  let sep = '\u3042'\n  let tabpages = join(titles, sep)\n  return tabpages .. sep .. '%=%999X X'\nendfunction\n\nfunc Test_tabline_empty_group()\n  \" this was reading invalid memory\n  set tabline=%!MakeTabLine()\n  tabnew\n  redraw!\n\n  tabclose\n  set tabline=\nendfunc\n\n\" When there are exactly 20 tabline format items (the exact size of the\n\" initial tabline items array), test that we don't write beyond the size\n\" of the array.\nfunc Test_tabline_20_format_items_no_overrun()\n  set showtabline=2\n\n  let tabline = repeat('%#StatColorHi2#', 20)\n  let &tabline = tabline\n  redrawtabline\n\n  set showtabline& tabline&\nendfunc\n\nfunc Test_mouse_click_in_tab()\n  \" This used to crash because TabPageIdxs[] was not initialized\n  let lines =<< trim END\n      tabnew\n      set mouse=a\n      exe \"norm \\<LeftMouse>\"\n  END\n  call writefile(lines, 'Xclickscript')\n  call RunVim([], [], \"-e -s -S Xclickscript -c qa\")\n\n  call delete('Xclickscript')\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/mouse.c", "src/testdir/test_tabline.vim", "src/version.c"], "buggy_code_start_loc": [474, 149, 733], "buggy_code_end_loc": [542, 149, 733], "fixing_code_start_loc": [474, 150, 734], "fixing_code_end_loc": [545, 164, 736], "type": "CWE-476", "message": "NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.0259.", "other": {"cve": {"id": "CVE-2022-2980", "sourceIdentifier": "security@huntr.dev", "published": "2022-08-25T20:15:09.587", "lastModified": "2023-05-03T12:16:09.687", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.0259."}, {"lang": "es", "value": "Una Desreferencia de Puntero NULL en el repositorio de GitHub vim/vim versiones anteriores a 9.0.0259."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0259", "matchCriteriaId": "01913AB4-2601-4722-8852-1E3CB540F78E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/80525751c5ce9ed82c41d83faf9ef38667bf61b1", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/6e7b12a5-242c-453d-b39e-9625d563b0ea", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XWOJOA7PZZAMBI5GFTL6PWHXMWSDLUXL/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/80525751c5ce9ed82c41d83faf9ef38667bf61b1"}}