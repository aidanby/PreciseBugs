{"buggy_code": ["//====== Copyright Valve Corporation, All rights reserved. ====================\n\n#include \"steamnetworkingsockets_udp.h\"\n#include \"csteamnetworkingsockets.h\"\n#include \"crypto.h\"\n\n#ifdef _WINDOWS\n\t#include <iphlpapi.h>\n#endif\n\n// memdbgon must be the last include file in a .cpp file!!!\n#include \"tier0/memdbgon.h\"\n\n// Put everything in a namespace, so we don't violate the one definition rule\nnamespace SteamNetworkingSocketsLib {\n\n// Try to guess if the route the specified address is probably \"local\".\n// This is difficult to do in general.  We want something that mostly works.\n//\n// False positives: VPNs and IPv6 addresses that appear to be nearby but are not.\n// False negatives: We can't always tell if a route is local.\nbool IsRouteToAddressProbablyLocal( netadr_t addr )\n{\n\n\t// Assume that if we are able to send to any \"reserved\" route, that is is local.\n\t// Note that this will be true for VPNs, too!\n\tif ( addr.IsReservedAdr() )\n\t\treturn true;\n\n\t// But other cases might also be local routes.  E.g. two boxes with public IPs.\n\t// Convert to sockaddr struct so we can ask the operating system\n\taddr.SetPort(0);\n\tsockaddr_storage sockaddrDest;\n\taddr.ToSockadr( &sockaddrDest );\n\n\t#ifdef _WINDOWS\n\n\t\t//\n\t\t// These functions were added with Vista, so load dynamically\n\t\t// in case\n\t\t//\n\n\t\ttypedef\n\t\tDWORD\n\t\t(WINAPI *FnGetBestInterfaceEx)(\n\t\t\tstruct sockaddr *pDestAddr,\n\t\t\tPDWORD           pdwBestIfIndex\n\t\t\t);\n\t\ttypedef \n\t\tNETIO_STATUS\n\t\t(NETIOAPI_API_*FnGetBestRoute2)(\n\t\t\tNET_LUID *InterfaceLuid,\n\t\t\tNET_IFINDEX InterfaceIndex,\n\t\t\tCONST SOCKADDR_INET *SourceAddress,\n\t\t\tCONST SOCKADDR_INET *DestinationAddress,\n\t\t\tULONG AddressSortOptions,\n\t\t\tPMIB_IPFORWARD_ROW2 BestRoute,\n\t\t\tSOCKADDR_INET *BestSourceAddress\n\t\t\t);\n\n\t\tstatic HMODULE hModule = LoadLibraryA( \"Iphlpapi.dll\" );\n\t\tstatic FnGetBestInterfaceEx pGetBestInterfaceEx = hModule ? (FnGetBestInterfaceEx)GetProcAddress( hModule, \"GetBestInterfaceEx\" ) : nullptr;\n\t\tstatic FnGetBestRoute2 pGetBestRoute2 = hModule ? (FnGetBestRoute2)GetProcAddress( hModule, \"GetBestRoute2\" ) : nullptr;;\n\t\tif ( !pGetBestInterfaceEx || !pGetBestRoute2 )\n\t\t\treturn false;\n\n\t\tNET_IFINDEX dwBestIfIndex;\n\t\tDWORD r = (*pGetBestInterfaceEx)( (sockaddr *)&sockaddrDest, &dwBestIfIndex );\n\t\tif ( r != NO_ERROR )\n\t\t{\n\t\t\tAssertMsg2( false, \"GetBestInterfaceEx failed with result %d for address '%s'\", r, CUtlNetAdrRender( addr ).String() );\n\t\t\treturn false;\n\t\t}\n\n\t\tMIB_IPFORWARD_ROW2 bestRoute;\n\t\tSOCKADDR_INET bestSourceAddress;\n\t\tr = (*pGetBestRoute2)(\n\t\t\tnullptr, // InterfaceLuid\n\t\t\tdwBestIfIndex, // InterfaceIndex\n\t\t\tnullptr, // SourceAddress\n\t\t\t(SOCKADDR_INET *)&sockaddrDest, // DestinationAddress\n\t\t\t0, // AddressSortOptions\n\t\t\t&bestRoute, // BestRoute\n\t\t\t&bestSourceAddress // BestSourceAddress\n\t\t);\n\t\tif ( r != NO_ERROR )\n\t\t{\n\t\t\tAssertMsg2( false, \"GetBestRoute2 failed with result %d for address '%s'\", r, CUtlNetAdrRender( addr ).String() );\n\t\t\treturn false;\n\t\t}\n\t\tif ( bestRoute.Protocol == MIB_IPPROTO_LOCAL )\n\t\t\treturn true;\n\t\tnetadr_t nextHop;\n\t\tif ( !nextHop.SetFromSockadr( &bestRoute.NextHop ) )\n\t\t{\n\t\t\tAssertMsg( false, \"GetBestRoute2 returned invalid next hop address\" );\n\t\t\treturn false;\n\t\t}\n\n\t\tnextHop.SetPort( 0 );\n\n\t\t// https://docs.microsoft.com/en-us/windows/win32/api/netioapi/ns-netioapi-mib_ipforward_row2:\n\t\t//   For a remote route, the IP address of the next system or gateway en route.\n\t\t//   If the route is to a local loopback address or an IP address on the local\n\t\t//   link, the next hop is unspecified (all zeros). For a local loopback route,\n\t\t//   this member should be an IPv4 address of 0.0.0.0 for an IPv4 route entry\n\t\t//   or an IPv6 address address of 0::0 for an IPv6 route entry.\n\t\tif ( !nextHop.HasIP() )\n\t\t\treturn true;\n\t\tif ( nextHop == addr )\n\t\t\treturn true;\n\n\t\t// If final destination is on the same IPv6/56 prefix, then assume\n\t\t// it's a local route.  This is an arbitrary prefix size to use,\n\t\t// but it's a compromise.  We think that /64 probably has too\n\t\t// many false negatives, but /48 has have too many false positives.\n\t\tif ( addr.GetType() == k_EIPTypeV6 )\n\t\t{\n\t\t\tif ( nextHop.GetType() == k_EIPTypeV6 )\n\t\t\t{\n\t\t\t\tif ( memcmp( addr.GetIPV6Bytes(), nextHop.GetIPV6Bytes(), 7 ) == 0 )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tnetadr_t netdrBestSource;\n\t\t\tif ( netdrBestSource.SetFromSockadr( &bestSourceAddress ) && netdrBestSource.GetType() == k_EIPTypeV6 )\n\t\t\t{\n\t\t\t\tif ( memcmp( addr.GetIPV6Bytes(), netdrBestSource.GetIPV6Bytes(), 7 ) == 0 )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t#else\n\t\t// FIXME - Writeme\n\t#endif\n\n\t// Nope\n\treturn false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n//\n// Packet parsing / handling utils\n//\n/////////////////////////////////////////////////////////////////////////////\n\nbool BCheckRateLimitReportBadPacket( SteamNetworkingMicroseconds usecNow )\n{\n\tstatic SteamNetworkingMicroseconds s_usecLastReport;\n\tif ( s_usecLastReport + k_nMillion*2 > usecNow )\n\t\treturn false;\n\ts_usecLastReport = usecNow;\n\treturn true;\n}\n\nvoid ReallyReportBadUDPPacket( const char *pszFrom, const char *pszMsgType, const char *pszFmt, ... )\n{\n\tchar buf[ 2048 ];\n\tva_list ap;\n\tva_start( ap, pszFmt );\n\tV_vsprintf_safe( buf, pszFmt, ap );\n\tva_end( ap );\n\tV_StripTrailingWhitespaceASCII( buf );\n\n\tif ( !pszMsgType || !pszMsgType[0] )\n\t\tpszMsgType = \"message\";\n\n\tSpewMsg( \"[%s] Ignored bad %s.  %s\\n\", pszMsgType, pszFrom, buf );\n}\n\n#define ReportBadPacket( pszMsgType, /* fmt */ ... ) \\\n\tReportBadUDPPacketFrom( CUtlNetAdrRender( adrFrom ).String(), pszMsgType, __VA_ARGS__ )\n\n\n#define ParseProtobufBody( pvMsg, cbMsg, CMsgCls, msgVar ) \\\n\tCMsgCls msgVar; \\\n\tif ( !msgVar.ParseFromArray( pvMsg, cbMsg ) ) \\\n\t{ \\\n\t\tReportBadPacket( # CMsgCls, \"Protobuf parse failed.\" ); \\\n\t\treturn; \\\n\t}\n\n#define ParsePaddedPacket( pvPkt, cbPkt, CMsgCls, msgVar ) \\\n\tCMsgCls msgVar; \\\n\t{ \\\n\t\tif ( cbPkt < k_cbSteamNetworkingMinPaddedPacketSize ) \\\n\t\t{ \\\n\t\t\tReportBadPacket( # CMsgCls, \"Packet is %d bytes, must be padded to at least %d bytes.\", cbPkt, k_cbSteamNetworkingMinPaddedPacketSize ); \\\n\t\t\treturn; \\\n\t\t} \\\n\t\tconst UDPPaddedMessageHdr *hdr = static_cast< const UDPPaddedMessageHdr * >( pvPkt ); \\\n\t\tint nMsgLength = LittleWord( hdr->m_nMsgLength ); \\\n\t\tif ( nMsgLength <= 0 || int(nMsgLength+sizeof(UDPPaddedMessageHdr)) > cbPkt ) \\\n\t\t{ \\\n\t\t\tReportBadPacket( # CMsgCls, \"Invalid encoded message length %d.  Packet is %d bytes.\", nMsgLength, cbPkt ); \\\n\t\t\treturn; \\\n\t\t} \\\n\t\tif ( !msgVar.ParseFromArray( hdr+1, nMsgLength ) ) \\\n\t\t{ \\\n\t\t\tReportBadPacket( # CMsgCls, \"Protobuf parse failed.\" ); \\\n\t\t\treturn; \\\n\t\t} \\\n\t}\n\n/////////////////////////////////////////////////////////////////////////////\n//\n// CSteamNetworkListenSocketDirectUDP\n//\n/////////////////////////////////////////////////////////////////////////////\n\nCSteamNetworkListenSocketDirectUDP::CSteamNetworkListenSocketDirectUDP( CSteamNetworkingSockets *pSteamNetworkingSocketsInterface )\n: CSteamNetworkListenSocketBase( pSteamNetworkingSocketsInterface )\n{\n\tm_pSock = nullptr;\n}\n\nCSteamNetworkListenSocketDirectUDP::~CSteamNetworkListenSocketDirectUDP()\n{\n\t// Clean up socket, if any\n\tif ( m_pSock )\n\t{\n\t\tdelete m_pSock;\n\t\tm_pSock = nullptr;\n\t}\n}\n\nbool CSteamNetworkListenSocketDirectUDP::BInit( const SteamNetworkingIPAddr &localAddr, int nOptions, const SteamNetworkingConfigValue_t *pOptions, SteamDatagramErrMsg &errMsg )\n{\n\tAssert( m_pSock == nullptr );\n\n\tif ( localAddr.m_port == 0 )\n\t{\n\t\tV_strcpy_safe( errMsg, \"Must specify local port.\" );\n\t\treturn false;\n\t}\n\n\t// Set options, add us to the global table\n\tif ( !BInitListenSocketCommon( nOptions, pOptions, errMsg ) )\n\t\treturn false;\n\n\t// Might we need to authenticate?\n\tint IP_AllowWithoutAuth = m_connectionConfig.m_IP_AllowWithoutAuth.Get();\n\tif ( IP_AllowWithoutAuth < 2 )\n\t{\n\t\tm_pSteamNetworkingSocketsInterface->AuthenticationNeeded();\n\n\t\t// If we know for sure that this can't ever work, then go ahead and fail now.\n\t\t#ifndef STEAMNETWORKINGSOCKETS_CAN_REQUEST_CERT\n\t\t\tif ( IP_AllowWithoutAuth == 0 )\n\t\t\t{\n\t\t\t\tV_strcpy_safe( errMsg, \"No cert authority, must set IP_AllowWithoutAuth\" );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t#endif\n\t}\n\n\tm_pSock = new CSharedSocket;\n\tif ( !m_pSock->BInit( localAddr, CRecvPacketCallback( ReceivedFromUnknownHost, this ), errMsg ) )\n\t{\n\t\tdelete m_pSock;\n\t\tm_pSock = nullptr;\n\t\treturn false;\n\t}\n\n\tCCrypto::GenerateRandomBlock( m_argbChallengeSecret, sizeof(m_argbChallengeSecret) );\n\n\treturn true;\n}\n\nbool CSteamNetworkListenSocketDirectUDP::APIGetAddress( SteamNetworkingIPAddr *pAddress )\n{\n\tif ( !m_pSock )\n\t{\n\t\tAssert( false );\n\t\treturn false;\n\t}\n\n\tconst SteamNetworkingIPAddr *pBoundAddr = m_pSock->GetBoundAddr();\n\tif ( !pBoundAddr )\n\t\treturn false;\n\tif ( pAddress )\n\t\t*pAddress = *pBoundAddr;\n\treturn true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n//\n// CSteamNetworkListenSocketUDP packet handling\n//\n/////////////////////////////////////////////////////////////////////////////\n\nvoid CSteamNetworkListenSocketDirectUDP::ReceivedFromUnknownHost( const void *pvPkt, int cbPkt, const netadr_t &adrFrom, CSteamNetworkListenSocketDirectUDP *pSock )\n{\n\tconst uint8 *pPkt = static_cast<const uint8 *>( pvPkt );\n\n\tSteamNetworkingMicroseconds usecNow = SteamNetworkingSockets_GetLocalTimestamp();\n\n\tif ( cbPkt < 5 )\n\t{\n\t\tReportBadPacket( \"packet\", \"%d byte packet is too small\", cbPkt );\n\t\treturn;\n\t}\n\n\tif ( *pPkt & 0x80 )\n\t{\n\t\tif ( *(uint32*)pPkt == 0xffffffff )\n\t\t{\n\t\t\t// Source engine connectionless packet (LAN discovery, etc).\n\t\t\t// Just ignore it, and don't even spew.\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// A stray data packet.  Just ignore it.\n\t\t\t//\n\t\t\t// When clients are able to actually establish a connection, after that connection\n\t\t\t// is over we will use the FinWait state to close down the connection gracefully.\n\t\t\t// But since we don't have that connection in our table anymore, either this guy\n\t\t\t// never had a connection, or else we believe he knows that the connection was closed,\n\t\t\t// or the FinWait state has timed out.\n\t\t\tReportBadPacket( \"Data\", \"Stray data packet from host with no connection.  Ignoring.\" );\n\t\t}\n\t}\n\telse if ( *pPkt == k_ESteamNetworkingUDPMsg_ChallengeRequest )\n\t{\n\t\tParsePaddedPacket( pvPkt, cbPkt, CMsgSteamSockets_UDP_ChallengeRequest, msg )\n\t\tpSock->Received_ChallengeRequest( msg, adrFrom, usecNow );\n\t}\n\telse if ( *pPkt == k_ESteamNetworkingUDPMsg_ConnectRequest )\n\t{\n\t\tParseProtobufBody( pPkt+1, cbPkt-1, CMsgSteamSockets_UDP_ConnectRequest, msg )\n\t\tpSock->Received_ConnectRequest( msg, adrFrom, cbPkt, usecNow );\n\t}\n\telse if ( *pPkt == k_ESteamNetworkingUDPMsg_ConnectionClosed )\n\t{\n\t\tParsePaddedPacket( pvPkt, cbPkt, CMsgSteamSockets_UDP_ConnectionClosed, msg )\n\t\tpSock->Received_ConnectionClosed( msg, adrFrom, usecNow );\n\t}\n\telse if ( *pPkt == k_ESteamNetworkingUDPMsg_NoConnection )\n\t{\n\t\t// They don't think there's a connection on this address.\n\t\t// We agree -- connection ID doesn't matter.  Nothing else to do.\n\t}\n\telse\n\t{\n\t\t// Any other lead byte is bogus\n\t\t//\n\t\t// Note in particular that these packet types should be ignored:\n\t\t//\n\t\t// k_ESteamNetworkingUDPMsg_ChallengeReply\n\t\t// k_ESteamNetworkingUDPMsg_ConnectOK\n\t\t//\n\t\t// We are not initiating connections, so we shouldn't ever get\n\t\t// those sorts of replies.\n\n\t\tReportBadPacket( \"packet\", \"Invalid lead byte 0x%02x\", *pPkt );\n\t}\n}\n\nuint64 CSteamNetworkListenSocketDirectUDP::GenerateChallenge( uint16 nTime, const netadr_t &adr ) const\n{\n\t#pragma pack(push,1)\n\tstruct\n\t{\n\t\tuint16 nTime;\n\t\tuint16 nPort;\n\t\tuint8 ipv6[16];\n\t} data;\n\t#pragma pack(pop)\n\tdata.nTime = nTime;\n\tdata.nPort = adr.GetPort();\n\tadr.GetIPV6( data.ipv6 );\n\tuint64 nChallenge = siphash( (const uint8_t *)&data, sizeof(data), m_argbChallengeSecret );\n\treturn ( nChallenge & 0xffffffffffff0000ull ) | nTime;\n}\n\ninline uint16 GetChallengeTime( SteamNetworkingMicroseconds usecNow )\n{\n\treturn uint16( usecNow >> 20 );\n}\n\nvoid CSteamNetworkListenSocketDirectUDP::Received_ChallengeRequest( const CMsgSteamSockets_UDP_ChallengeRequest &msg, const netadr_t &adrFrom, SteamNetworkingMicroseconds usecNow )\n{\n\tif ( msg.connection_id() == 0 )\n\t{\n\t\tReportBadPacket( \"ChallengeRequest\", \"Missing connection_id.\" );\n\t\treturn;\n\t}\n\t//CSteamID steamIDClient( uint64( msg.client_steam_id() ) );\n\t//if ( !steamIDClient.IsValid() )\n\t//{\n\t//\tReportBadPacket( \"ChallengeRequest\", \"Missing/invalid SteamID.\", cbPkt );\n\t//\treturn;\n\t//}\n\n\t// Get time value of challenge\n\tuint16 nTime = GetChallengeTime( usecNow );\n\n\t// Generate a challenge\n\tuint64 nChallenge = GenerateChallenge( nTime, adrFrom );\n\n\t// Send them a reply\n\tCMsgSteamSockets_UDP_ChallengeReply msgReply;\n\tmsgReply.set_connection_id( msg.connection_id() );\n\tmsgReply.set_challenge( nChallenge );\n\tmsgReply.set_your_timestamp( msg.my_timestamp() );\n\tmsgReply.set_protocol_version( k_nCurrentProtocolVersion );\n\tSendMsg( k_ESteamNetworkingUDPMsg_ChallengeReply, msgReply, adrFrom );\n}\n\nvoid CSteamNetworkListenSocketDirectUDP::Received_ConnectRequest( const CMsgSteamSockets_UDP_ConnectRequest &msg, const netadr_t &adrFrom, int cbPkt, SteamNetworkingMicroseconds usecNow )\n{\n\tSteamDatagramErrMsg errMsg;\n\n\t// Make sure challenge was generated relatively recently\n\tuint16 nTimeThen = uint32( msg.challenge() );\n\tuint16 nElapsed = GetChallengeTime( usecNow ) - nTimeThen;\n\tif ( nElapsed > GetChallengeTime( 4*k_nMillion ) )\n\t{\n\t\tReportBadPacket( \"ConnectRequest\", \"Challenge too old.\" );\n\t\treturn;\n\t}\n\n\t// Assuming we sent them this time value, re-create the challenge we would have sent them.\n\tif ( GenerateChallenge( nTimeThen, adrFrom ) != msg.challenge() )\n\t{\n\t\tReportBadPacket( \"ConnectRequest\", \"Incorrect challenge.  Could be spoofed.\" );\n\t\treturn;\n\t}\n\n\tuint32 unClientConnectionID = msg.client_connection_id();\n\tif ( unClientConnectionID == 0 )\n\t{\n\t\tReportBadPacket( \"ConnectRequest\", \"Missing connection ID\" );\n\t\treturn;\n\t}\n\n\t// Parse out identity from the cert\n\tSteamNetworkingIdentity identityRemote;\n\tbool bIdentityInCert = true;\n\t{\n\t\t// !SPEED! We are deserializing the cert here,\n\t\t// and then we are going to do it again below.\n\t\t// Should refactor to fix this.\n\t\tint r = SteamNetworkingIdentityFromSignedCert( identityRemote, msg.cert(), errMsg );\n\t\tif ( r < 0 )\n\t\t{\n\t\t\tReportBadPacket( \"ConnectRequest\", \"Bad identity in cert.  %s\", errMsg );\n\t\t\treturn;\n\t\t}\n\t\tif ( r == 0 )\n\t\t{\n\t\t\t// No identity in the cert.  Check if they put it directly in the connect message\n\t\t\tbIdentityInCert = false;\n\t\t\tr = SteamNetworkingIdentityFromProtobuf( identityRemote, msg, identity_string, legacy_identity_binary, legacy_client_steam_id, errMsg );\n\t\t\tif ( r < 0 )\n\t\t\t{\n\t\t\t\tReportBadPacket( \"ConnectRequest\", \"Bad identity.  %s\", errMsg );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( r == 0 )\n\t\t\t{\n\t\t\t\t// If no identity was presented, it's the same as them saying they are \"localhost\"\n\t\t\t\tidentityRemote.SetLocalHost();\n\t\t\t}\n\t\t}\n\t}\n\tAssert( !identityRemote.IsInvalid() );\n\n\t// Check if they are using an IP address as an identity (possibly the anonymous \"localhost\" identity)\n\tif ( identityRemote.m_eType == k_ESteamNetworkingIdentityType_IPAddress )\n\t{\n\t\tSteamNetworkingIPAddr addr;\n\t\tadrFrom.GetIPV6( addr.m_ipv6 );\n\t\taddr.m_port = adrFrom.GetPort();\n\n\t\tif ( identityRemote.IsLocalHost() )\n\t\t{\n\t\t\tif ( m_connectionConfig.m_IP_AllowWithoutAuth.Get() == 0 )\n\t\t\t{\n\t\t\t\t// Should we send an explicit rejection here?\n\t\t\t\tReportBadPacket( \"ConnectRequest\", \"Unauthenticated connections not allowed.\" );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set their identity to their real address (including port)\n\t\t\tidentityRemote.SetIPAddr( addr );\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// FIXME - Should the address be required to match?\n\t\t\t// If we are behind NAT, it won't.\n\t\t\t//if ( memcmp( addr.m_ipv6, identityRemote.m_ip.m_ipv6, sizeof(addr.m_ipv6) ) != 0\n\t\t\t//\t|| ( identityRemote.m_ip.m_port != 0 && identityRemote.m_ip.m_port != addr.m_port ) ) // Allow 0 port in the identity to mean \"any port\"\n\t\t\t//{\n\t\t\t//\tReportBadPacket( \"ConnectRequest\", \"Identity in request is %s, but packet is coming from %s.\" );\n\t\t\t//\treturn;\n\t\t\t//}\n\n\t\t\t// It's not really clear what the use case is here for\n\t\t\t// requesting a specific IP address as your identity,\n\t\t\t// and not using localhost.  If they have a cert, assume it's\n\t\t\t// meaningful.  Remember: the cert could be unsigned!  That\n\t\t\t// is a separate issue which will be handled later, whether\n\t\t\t// we want to allow that.\n\t\t\tif ( !bIdentityInCert )\n\t\t\t{\n\t\t\t\t// Should we send an explicit rejection here?\n\t\t\t\tReportBadPacket( \"ConnectRequest\", \"Cannot use specific IP address.\" );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Does this connection already exist?  (At a different address?)\n\tint h = m_mapChildConnections.Find( RemoteConnectionKey_t{ identityRemote, unClientConnectionID } );\n\tif ( h != m_mapChildConnections.InvalidIndex() )\n\t{\n\t\tCSteamNetworkConnectionBase *pOldConn = m_mapChildConnections[ h ];\n\t\tAssert( pOldConn->m_identityRemote == identityRemote );\n\n\t\t// NOTE: We cannot just destroy the object.  The API semantics\n\t\t// are that all connections, once accepted and made visible\n\t\t// to the API, must be closed by the application.\n\t\tReportBadPacket( \"ConnectRequest\", \"Rejecting connection request from %s at %s, connection ID %u.  That steamID/ConnectionID pair already has a connection [%s]\\n\",\n\t\t\tSteamNetworkingIdentityRender( identityRemote ).c_str(), CUtlNetAdrRender( adrFrom ).String(), unClientConnectionID, pOldConn->GetDescription()\n\t\t);\n\n\t\tCMsgSteamSockets_UDP_ConnectionClosed msgReply;\n\t\tmsgReply.set_to_connection_id( unClientConnectionID );\n\t\tmsgReply.set_reason_code( k_ESteamNetConnectionEnd_Misc_Generic );\n\t\tmsgReply.set_debug( \"A connection with that ID already exists.\" );\n\t\tSendPaddedMsg( k_ESteamNetworkingUDPMsg_ConnectionClosed, msgReply, adrFrom );\n\t\treturn;\n\t}\n\n\tCSteamNetworkConnectionUDP *pConn = new CSteamNetworkConnectionUDP( m_pSteamNetworkingSocketsInterface );\n\n\t// OK, they have completed the handshake.  Accept the connection.\n\tif ( !pConn->BBeginAccept( this, adrFrom, m_pSock, identityRemote, unClientConnectionID, msg.cert(), msg.crypt(), errMsg ) )\n\t{\n\t\tSpewWarning( \"Failed to accept connection from %s.  %s\\n\", CUtlNetAdrRender( adrFrom ).String(), errMsg );\n\t\tpConn->ConnectionDestroySelfNow();\n\t\treturn;\n\t}\n\n\tpConn->m_statsEndToEnd.TrackRecvPacket( cbPkt, usecNow );\n\n\t// Did they send us a ping estimate?\n\tif ( msg.has_ping_est_ms() )\n\t{\n\t\tif ( msg.ping_est_ms() > 1500 )\n\t\t{\n\t\t\tSpewWarning( \"[%s] Ignoring really large ping estimate %u in connect request\", pConn->GetDescription(), msg.has_ping_est_ms() );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpConn->m_statsEndToEnd.m_ping.ReceivedPing( msg.ping_est_ms(), usecNow );\n\t\t}\n\t}\n\n\t// Save of timestamp that we will use to reply to them when the application\n\t// decides to accept the connection\n\tif ( msg.has_my_timestamp() )\n\t{\n\t\tpConn->m_ulHandshakeRemoteTimestamp = msg.my_timestamp();\n\t\tpConn->m_usecWhenReceivedHandshakeRemoteTimestamp = usecNow;\n\t}\n}\n\nvoid CSteamNetworkListenSocketDirectUDP::Received_ConnectionClosed( const CMsgSteamSockets_UDP_ConnectionClosed &msg, const netadr_t &adrFrom, SteamNetworkingMicroseconds usecNow )\n{\n\t// Send an ack.  Note that we require the inbound message to be padded\n\t// to a minimum size, and this reply is tiny, so we are not at a risk of\n\t// being used for reflection, even though the source address could be spoofed.\n\tCMsgSteamSockets_UDP_NoConnection msgReply;\n\tif ( msg.from_connection_id() )\n\t\tmsgReply.set_to_connection_id( msg.from_connection_id() );\n\tif ( msg.to_connection_id() )\n\t\tmsgReply.set_from_connection_id( msg.to_connection_id() );\n\tSendMsg( k_ESteamNetworkingUDPMsg_NoConnection, msgReply, adrFrom );\n}\n\nvoid CSteamNetworkListenSocketDirectUDP::SendMsg( uint8 nMsgID, const google::protobuf::MessageLite &msg, const netadr_t &adrTo )\n{\n\tif ( !m_pSock )\n\t{\n\t\tAssert( false );\n\t\treturn;\n\t}\n\n\tuint8 pkt[ k_cbSteamNetworkingSocketsMaxUDPMsgLen ];\n\tpkt[0] = nMsgID;\n\tint cbPkt = ProtoMsgByteSize( msg )+1;\n\tif ( cbPkt > sizeof(pkt) )\n\t{\n\t\tAssertMsg3( false, \"Msg type %d is %d bytes, larger than MTU of %d bytes\", int( nMsgID ), int( cbPkt ), (int)sizeof(pkt) );\n\t\treturn;\n\t}\n\tuint8 *pEnd = msg.SerializeWithCachedSizesToArray( pkt+1 );\n\tAssert( cbPkt == pEnd - pkt );\n\n\t// Send the reply\n\tm_pSock->BSendRawPacket( pkt, cbPkt, adrTo );\n}\n\nvoid CSteamNetworkListenSocketDirectUDP::SendPaddedMsg( uint8 nMsgID, const google::protobuf::MessageLite &msg, const netadr_t adrTo )\n{\n\n\tuint8 pkt[ k_cbSteamNetworkingSocketsMaxUDPMsgLen ];\n\tmemset( pkt, 0, sizeof(pkt) ); // don't send random bits from our process memory over the wire!\n\tUDPPaddedMessageHdr *hdr = (UDPPaddedMessageHdr *)pkt;\n\tint nMsgLength = ProtoMsgByteSize( msg );\n\thdr->m_nMsgID = nMsgID;\n\thdr->m_nMsgLength = LittleWord( uint16( nMsgLength ) );\n\tuint8 *pEnd = msg.SerializeWithCachedSizesToArray( pkt + sizeof(*hdr) );\n\tint cbPkt = pEnd - pkt;\n\tAssert( cbPkt == int( sizeof(*hdr) + nMsgLength ) );\n\tcbPkt = MAX( cbPkt, k_cbSteamNetworkingMinPaddedPacketSize );\n\n\tm_pSock->BSendRawPacket( pkt, cbPkt, adrTo );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n//\n// CConnectionTransportUDPBase\n//\n/////////////////////////////////////////////////////////////////////////////\n\nCConnectionTransportUDPBase::CConnectionTransportUDPBase( CSteamNetworkConnectionBase &connection )\n: CConnectionTransport( connection )\n{\n}\n\nbool CConnectionTransportUDPBase::SendDataPacket( SteamNetworkingMicroseconds usecNow )\n{\n\t// Populate context struct with any stats we want/need to send, and how much space we need to reserve for it\n\tUDPSendPacketContext_t ctx( usecNow, \"data\" );\n\tctx.Populate( sizeof(UDPDataMsgHdr), k_EStatsReplyRequest_NothingToSend, this );\n\n\t// Send a packet\n\treturn m_connection.SNP_SendPacket( this, ctx );\n}\n\nint CConnectionTransportUDPBase::SendEncryptedDataChunk( const void *pChunk, int cbChunk, SendPacketContext_t &ctxBase )\n{\n\tUDPSendPacketContext_t &ctx = static_cast<UDPSendPacketContext_t &>( ctxBase );\n\n\tuint8 pkt[ k_cbSteamNetworkingSocketsMaxUDPMsgLen ];\n\tUDPDataMsgHdr *hdr = (UDPDataMsgHdr *)pkt;\n\thdr->m_unMsgFlags = 0x80;\n\tAssert( m_connection.m_unConnectionIDRemote != 0 );\n\thdr->m_unToConnectionID = LittleDWord( m_connection.m_unConnectionIDRemote );\n\thdr->m_unSeqNum = LittleWord( m_connection.m_statsEndToEnd.ConsumeSendPacketNumberAndGetWireFmt( ctx.m_usecNow ) );\n\n\tbyte *p = (byte*)( hdr + 1 );\n\n\t// Check how much bigger we could grow the header\n\t// and still fit in a packet\n\tint cbHdrOutSpaceRemaining = pkt + sizeof(pkt) - p - cbChunk;\n\tif ( cbHdrOutSpaceRemaining < 0 )\n\t{\n\t\tAssertMsg( false, \"MTU / header size problem!\" );\n\t\treturn 0;\n\t}\n\n\t// Try to trim stuff from blob, if it won't fit\n\tctx.Trim( cbHdrOutSpaceRemaining );\n\n\tif ( ctx.Serialize( p ) )\n\t{\n\t\t// Update bookkeeping with the stuff we are actually sending\n\t\tTrackSentStats( ctx );\n\n\t\t// Mark header with the flag\n\t\thdr->m_unMsgFlags |= hdr->kFlag_ProtobufBlob;\n\t}\n\n\t// !FIXME! Time since previous, for jitter measurement?\n\n\t// Use gather-based send.  This saves one memcpy of every payload\n\tiovec gather[2];\n\tgather[0].iov_base = pkt;\n\tgather[0].iov_len = p - pkt;\n\tgather[1].iov_base = const_cast<void*>( pChunk );\n\tgather[1].iov_len = cbChunk;\n\n\tint cbSend = gather[0].iov_len + gather[1].iov_len;\n\tAssert( cbSend <= sizeof(pkt) ); // Bug in the code above.  We should never \"overflow\" the packet.  (Ignoring the fact that we using a gather-based send.  The data could be tiny with a large header for piggy-backed stats.)\n\n\t// !FIXME! Should we track data payload separately?  Maybe we ought to track\n\t// *messages* instead of packets.\n\n\t// Send it\n\tif ( SendPacketGather( 2, gather, cbSend ) )\n\t\treturn cbSend;\n\treturn 0;\n}\n\nstd::string DescribeStatsContents( const CMsgSteamSockets_UDP_Stats &msg )\n{\n\tstd::string sWhat;\n\tif ( msg.flags() & msg.ACK_REQUEST_E2E )\n\t\tsWhat += \" request_ack\";\n\tif ( msg.flags() & msg.ACK_REQUEST_IMMEDIATE )\n\t\tsWhat += \" request_ack_immediate\";\n\tif ( msg.flags() & msg.NOT_PRIMARY_TRANSPORT_E2E )\n\t\tsWhat += \" backup_transport\";\n\tif ( msg.stats().has_lifetime() )\n\t\tsWhat += \" stats.life\";\n\tif ( msg.stats().has_instantaneous() )\n\t\tsWhat += \" stats.rate\";\n\treturn sWhat;\n}\n\nvoid CConnectionTransportUDPBase::RecvStats( const CMsgSteamSockets_UDP_Stats &msgStatsIn, SteamNetworkingMicroseconds usecNow )\n{\n\n\t// Connection quality stats?\n\tif ( msgStatsIn.has_stats() )\n\t\tm_connection.m_statsEndToEnd.ProcessMessage( msgStatsIn.stats(), usecNow );\n\n\t// Spew appropriately\n\tSpewVerbose( \"[%s] Recv UDP stats:%s\\n\",\n\t\tConnectionDescription(),\n\t\tDescribeStatsContents( msgStatsIn ).c_str()\n\t);\n\n\t// Check if we need to reply, either now or later\n\tif ( m_connection.BStateIsActive() )\n\t{\n\n\t\t// Check for queuing outgoing acks\n\t\tif ( ( msgStatsIn.flags() & msgStatsIn.ACK_REQUEST_E2E ) || msgStatsIn.has_stats() )\n\t\t{\n\t\t\tbool bImmediate = ( msgStatsIn.flags() & msgStatsIn.ACK_REQUEST_IMMEDIATE ) != 0;\n\t\t\tm_connection.QueueEndToEndAck( bImmediate, usecNow );\n\n\t\t\t// Check if need to send an immediately reply, either because they\n\t\t\t// requested it, or because we are not the currently selected transport,\n\t\t\t// and we need to need to make sure the reply goes out using us\n\t\t\tif ( bImmediate || m_connection.m_pTransport != this )\n\t\t\t{\n\t\t\t\tSendEndToEndStatsMsg( k_EStatsReplyRequest_NothingToSend, usecNow, \"AckStats\" );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid CConnectionTransportUDPBase::TrackSentStats( UDPSendPacketContext_t &ctx )\n{\n\n\t// What effective flags will be received?\n\tbool bAllowDelayedReply = ( ctx.msg.flags() & ctx.msg.ACK_REQUEST_IMMEDIATE ) == 0;\n\n\t// Record that we sent stats and are waiting for peer to ack\n\tif ( ctx.msg.has_stats() )\n\t{\n\t\tm_connection.m_statsEndToEnd.TrackSentStats( ctx.msg.stats(), ctx.m_usecNow, bAllowDelayedReply );\n\t}\n\telse if ( ctx.msg.flags() & ctx.msg.ACK_REQUEST_E2E )\n\t{\n\t\tm_connection.m_statsEndToEnd.TrackSentMessageExpectingSeqNumAck( ctx.m_usecNow, bAllowDelayedReply );\n\t}\n\n\t// Spew appropriately\n\tSpewVerbose( \"[%s] Sent UDP stats (%s):%s\\n\",\n\t\tConnectionDescription(),\n\t\tctx.m_pszReason,\n\t\tDescribeStatsContents( ctx.msg ).c_str()\n\t);\n}\n\nvoid CConnectionTransportUDPBase::Received_Data( const uint8 *pPkt, int cbPkt, SteamNetworkingMicroseconds usecNow )\n{\n\n\tif ( cbPkt < sizeof(UDPDataMsgHdr) )\n\t{\n\t\tReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"Packet of size %d is too small.\", cbPkt );\n\t\treturn;\n\t}\n\n\t// Check cookie\n\tconst UDPDataMsgHdr *hdr = (const UDPDataMsgHdr *)pPkt;\n\tif ( LittleDWord( hdr->m_unToConnectionID ) != ConnectionIDLocal() )\n\t{\n\n\t\t// Wrong session.  It could be an old session, or it could be spoofed.\n\t\tReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"Incorrect connection ID\" );\n\t\tif ( BCheckGlobalSpamReplyRateLimit( usecNow ) )\n\t\t{\n\t\t\tSendNoConnection( LittleDWord( hdr->m_unToConnectionID ), 0 );\n\t\t}\n\t\treturn;\n\t}\n\tuint16 nWirePktNumber = LittleWord( hdr->m_unSeqNum );\n\n\t// Check state\n\tswitch ( ConnectionState() )\n\t{\n\t\tcase k_ESteamNetworkingConnectionState_Dead:\n\t\tcase k_ESteamNetworkingConnectionState_None:\n\t\tdefault:\n\t\t\tAssert( false );\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_ClosedByPeer:\n\t\tcase k_ESteamNetworkingConnectionState_FinWait:\n\t\tcase k_ESteamNetworkingConnectionState_ProblemDetectedLocally:\n\t\t\tSendConnectionClosedOrNoConnection();\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_Connecting:\n\t\t\t// Ignore it.  We don't have the SteamID of whoever is on the other end yet,\n\t\t\t// their encryption keys, etc.  The most likely cause is that a server sent\n\t\t\t// a ConnectOK, which dropped.  So they think we're connected but we don't\n\t\t\t// have everything yet.\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_Linger:\n\t\tcase k_ESteamNetworkingConnectionState_Connected:\n\t\tcase k_ESteamNetworkingConnectionState_FindingRoute: // not used for raw UDP, but might be used for derived class\n\n\t\t\t// We'll process the chunk\n\t\t\tbreak;\n\t}\n\n\tconst uint8 *pIn = pPkt + sizeof(*hdr);\n\tconst uint8 *pPktEnd = pPkt + cbPkt;\n\n\t// Inline stats?\n\tstatic CMsgSteamSockets_UDP_Stats msgStats;\n\tCMsgSteamSockets_UDP_Stats *pMsgStatsIn = nullptr;\n\tuint32 cbStatsMsgIn = 0;\n\tif ( hdr->m_unMsgFlags & hdr->kFlag_ProtobufBlob )\n\t{\n\t\t//Msg_Verbose( \"Received inline stats from %s\", server.m_szName );\n\n\t\tpIn = DeserializeVarInt( pIn, pPktEnd, cbStatsMsgIn );\n\t\tif ( pIn == NULL )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"Failed to varint decode size of stats blob\" );\n\t\t\treturn;\n\t\t}\n\t\tif ( pIn + cbStatsMsgIn > pPktEnd )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"stats message size doesn't make sense.  Stats message size %d, packet size %d\", cbStatsMsgIn, cbPkt );\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !msgStats.ParseFromArray( pIn, cbStatsMsgIn ) )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"protobuf failed to parse inline stats message\" );\n\t\t\treturn;\n\t\t}\n\n\t\t// Shove sequence number so we know what acks to pend, etc\n\t\tpMsgStatsIn = &msgStats;\n\n\t\t// Advance pointer\n\t\tpIn += cbStatsMsgIn;\n\t}\n\n\tconst void *pChunk = pIn;\n\tint cbChunk = pPktEnd - pIn;\n\n\t// Decrypt it, and check packet number\n\tUDPRecvPacketContext_t ctx;\n\tctx.m_usecNow = usecNow;\n\tctx.m_pTransport = this;\n\tctx.m_pStatsIn = pMsgStatsIn;\n\tif ( !m_connection.DecryptDataChunk( nWirePktNumber, cbPkt, pChunk, cbChunk, ctx ) )\n\t\treturn;\n\n\t// This is a valid packet.  P2P connections might want to make a note of this\n\tRecvValidUDPDataPacket( ctx );\n\n\t// Process plaintext\n\tint usecTimeSinceLast = 0; // FIXME - should we plumb this through so we can measure jitter?\n\tif ( !m_connection.ProcessPlainTextDataChunk( usecTimeSinceLast, ctx ) )\n\t\treturn;\n\n\t// Process the stats, if any\n\tif ( pMsgStatsIn )\n\t\tRecvStats( *pMsgStatsIn, usecNow );\n}\n\nvoid CConnectionTransportUDPBase::RecvValidUDPDataPacket( UDPRecvPacketContext_t &ctx )\n{\n\t// Base class doesn't care\n}\n\nvoid CConnectionTransportUDPBase::SendEndToEndStatsMsg( EStatsReplyRequest eRequest, SteamNetworkingMicroseconds usecNow, const char *pszReason )\n{\n\tUDPSendPacketContext_t ctx( usecNow, pszReason );\n\tctx.Populate( sizeof(UDPDataMsgHdr), eRequest, this );\n\n\t// Send a data packet (maybe containing ordinary data), with this piggy backed on top of it\n\tm_connection.SNP_SendPacket( this, ctx );\n}\n\nvoid CConnectionTransportUDPBase::SendConnectionClosedOrNoConnection()\n{\n\tif ( ConnectionWireState() == k_ESteamNetworkingConnectionState_ClosedByPeer )\n\t{\n\t\tSendNoConnection( ConnectionIDLocal(), ConnectionIDRemote() );\n\t}\n\telse\n\t{\n\t\tCMsgSteamSockets_UDP_ConnectionClosed msg;\n\t\tmsg.set_from_connection_id( ConnectionIDLocal() );\n\n\t\tif ( ConnectionIDRemote() )\n\t\t\tmsg.set_to_connection_id( ConnectionIDRemote() );\n\n\t\tmsg.set_reason_code( m_connection.m_eEndReason );\n\t\tif ( m_connection.m_szEndDebug[0] )\n\t\t\tmsg.set_debug( m_connection.m_szEndDebug );\n\t\tSendPaddedMsg( k_ESteamNetworkingUDPMsg_ConnectionClosed, msg );\n\t}\n}\n\nvoid CConnectionTransportUDPBase::SendNoConnection( uint32 unFromConnectionID, uint32 unToConnectionID )\n{\n\tCMsgSteamSockets_UDP_NoConnection msg;\n\tif ( unFromConnectionID == 0 && unToConnectionID == 0 )\n\t{\n\t\tAssertMsg( false, \"Can't send NoConnection, we need at least one of from/to connection ID!\" );\n\t\treturn;\n\t}\n\tif ( unFromConnectionID )\n\t\tmsg.set_from_connection_id( unFromConnectionID );\n\tif ( unToConnectionID )\n\t\tmsg.set_to_connection_id( unToConnectionID );\n\tSendMsg( k_ESteamNetworkingUDPMsg_NoConnection, msg );\n}\n\nvoid CConnectionTransportUDPBase::SendMsg( uint8 nMsgID, const google::protobuf::MessageLite &msg )\n{\n\n\tuint8 pkt[ k_cbSteamNetworkingSocketsMaxUDPMsgLen ];\n\tpkt[0] = nMsgID;\n\tint cbPkt = ProtoMsgByteSize( msg )+1;\n\tif ( cbPkt > sizeof(pkt) )\n\t{\n\t\tAssertMsg3( false, \"Msg type %d is %d bytes, larger than MTU of %d bytes\", int( nMsgID ), int( cbPkt ), (int)sizeof(pkt) );\n\t\treturn;\n\t}\n\tuint8 *pEnd = msg.SerializeWithCachedSizesToArray( pkt+1 );\n\tAssert( cbPkt == pEnd - pkt );\n\n\tSendPacket( pkt, cbPkt );\n}\n\nvoid CConnectionTransportUDPBase::SendPaddedMsg( uint8 nMsgID, const google::protobuf::MessageLite &msg )\n{\n\n\tuint8 pkt[ k_cbSteamNetworkingSocketsMaxUDPMsgLen ];\n\tV_memset( pkt, 0, sizeof(pkt) ); // don't send random bits from our process memory over the wire!\n\tUDPPaddedMessageHdr *hdr = (UDPPaddedMessageHdr *)pkt;\n\tint nMsgLength = ProtoMsgByteSize( msg );\n\tif ( nMsgLength + sizeof(*hdr) > k_cbSteamNetworkingSocketsMaxUDPMsgLen )\n\t{\n\t\tAssertMsg3( false, \"Msg type %d is %d bytes, larger than MTU of %d bytes\", int( nMsgID ), int( nMsgLength + sizeof(*hdr) ), (int)sizeof(pkt) );\n\t\treturn;\n\t}\n\thdr->m_nMsgID = nMsgID;\n\thdr->m_nMsgLength = LittleWord( uint16( nMsgLength ) );\n\tuint8 *pEnd = msg.SerializeWithCachedSizesToArray( pkt + sizeof(*hdr) );\n\tint cbPkt = pEnd - pkt;\n\tAssert( cbPkt == int( sizeof(*hdr) + nMsgLength ) );\n\tcbPkt = MAX( cbPkt, k_cbSteamNetworkingMinPaddedPacketSize );\n\n\tSendPacket( pkt, cbPkt );\n}\n\nvoid CConnectionTransportUDPBase::Received_ConnectionClosed( const CMsgSteamSockets_UDP_ConnectionClosed &msg, SteamNetworkingMicroseconds usecNow )\n{\n\t// Give them a reply to let them know we heard from them.  If it's the right connection ID,\n\t// then they probably aren't spoofing and it's critical that we give them an ack!\n\t//\n\t// If the wrong connection ID, then it could be an old connection so we'd like to send a reply\n\t// to let them know that they can stop telling us the connection is closed.\n\t// However, it could just be random garbage, so we need to protect ourselves from abuse,\n\t// so limit how many of these we send.\n\tbool bConnectionIDMatch =\n\t\tmsg.to_connection_id() == ConnectionIDLocal()\n\t\t|| ( msg.to_connection_id() == 0 && msg.from_connection_id() && msg.from_connection_id() == m_connection.m_unConnectionIDRemote ); // they might not know our ID yet, if they are a client aborting the connection really early.\n\tif ( bConnectionIDMatch || BCheckGlobalSpamReplyRateLimit( usecNow ) )\n\t{\n\t\t// Send a reply, echoing exactly what they sent to us\n\t\tCMsgSteamSockets_UDP_NoConnection msgReply;\n\t\tif ( msg.to_connection_id() )\n\t\t\tmsgReply.set_from_connection_id( msg.to_connection_id() );\n\t\tif ( msg.from_connection_id() )\n\t\t\tmsgReply.set_to_connection_id( msg.from_connection_id() );\n\t\tSendMsg( k_ESteamNetworkingUDPMsg_NoConnection, msgReply );\n\t}\n\n\t// If incorrect connection ID, then that's all we'll do, since this packet actually\n\t// has nothing to do with current connection at all.\n\tif ( !bConnectionIDMatch )\n\t\treturn;\n\n\t// Generic connection code will take it from here.\n\tm_connection.ConnectionState_ClosedByPeer( msg.reason_code(), msg.debug().c_str() );\n}\n\nvoid CConnectionTransportUDPBase::Received_NoConnection( const CMsgSteamSockets_UDP_NoConnection &msg, SteamNetworkingMicroseconds usecNow )\n{\n\t// Make sure it's an ack of something we would have sent\n\tif ( msg.to_connection_id() != ConnectionIDLocal() || msg.from_connection_id() != m_connection.m_unConnectionIDRemote )\n\t{\n\t\tReportBadUDPPacketFromConnectionPeer( \"NoConnection\", \"Old/incorrect connection ID.  Message is for a stale connection, or is spoofed.  Ignoring.\" );\n\t\treturn;\n\t}\n\n\t// Generic connection code will take it from here.\n\t// Closure failure code will only be used if this is news.\n\t// If we closed the connection (the usual case), it\n\t// will not be used.\n\tm_connection.ConnectionState_ClosedByPeer( k_ESteamNetConnectionEnd_Misc_PeerSentNoConnection, \"Received unexpected 'no connection' from peer\");\n}\n\n/////////////////////////////////////////////////////////////////////////////\n//\n// IP connections\n//\n/////////////////////////////////////////////////////////////////////////////\n\nCSteamNetworkConnectionUDP::CSteamNetworkConnectionUDP( CSteamNetworkingSockets *pSteamNetworkingSocketsInterface )\n: CSteamNetworkConnectionBase( pSteamNetworkingSocketsInterface )\n{\n}\n\nCSteamNetworkConnectionUDP::~CSteamNetworkConnectionUDP()\n{\n}\n\nCConnectionTransportUDP::CConnectionTransportUDP( CSteamNetworkConnectionUDP &connection )\n: CConnectionTransportUDPBase( connection )\n, m_pSocket( nullptr )\n{\n}\n\nCConnectionTransportUDP::~CConnectionTransportUDP()\n{\n\tAssert( !m_pSocket ); // Use TransportDestroySelfNow!\n}\n\nvoid CConnectionTransportUDP::TransportFreeResources()\n{\n\tCConnectionTransport::TransportFreeResources();\n\n\tif ( m_pSocket )\n\t{\n\t\tm_pSocket->Close();\n\t\tm_pSocket = nullptr;\n\t}\n}\n\nvoid CSteamNetworkConnectionUDP::GetConnectionTypeDescription( ConnectionTypeDescription_t &szDescription ) const\n{\n\tchar szAddr[ 64 ];\n\tif ( Transport() && Transport()->m_pSocket )\n\t{\n\t\tSteamNetworkingIPAddr adrRemote;\n\t\tNetAdrToSteamNetworkingIPAddr( adrRemote, Transport()->m_pSocket->GetRemoteHostAddr() );\n\t\tadrRemote.ToString( szAddr, sizeof(szAddr), true );\n\t\tif (\n\t\t\tm_identityRemote.IsLocalHost()\n\t\t\t|| ( m_identityRemote.m_eType == k_ESteamNetworkingIdentityType_IPAddress && adrRemote == m_identityRemote.m_ip )\n\t\t) {\n\t\t\tV_sprintf_safe( szDescription, \"UDP %s\", szAddr );\n\t\t\treturn;\n\t\t}\n\t}\n\telse\n\t{\n\t\tV_strcpy_safe( szAddr, \"???\" );\n\t}\n\n\tSteamNetworkingIdentityRender sIdentity( m_identityRemote );\n\n\tV_sprintf_safe( szDescription, \"UDP %s@%s\", sIdentity.c_str(), szAddr );\n}\n\nvoid UDPSendPacketContext_t::Populate( size_t cbHdrtReserve, EStatsReplyRequest eReplyRequested, CConnectionTransportUDPBase *pTransport )\n{\n\tCSteamNetworkConnectionBase &connection = pTransport->m_connection;\n\tLinkStatsTracker<LinkStatsTrackerEndToEnd> &statsEndToEnd = connection.m_statsEndToEnd;\n\n\tint nFlags = 0;\n\tif ( connection.m_pTransport != pTransport )\n\t\tnFlags |= msg.NOT_PRIMARY_TRANSPORT_E2E;\n\n\t// What effective flags should we send\n\tint nReadyToSendTracer = 0;\n\tif ( eReplyRequested == k_EStatsReplyRequest_Immediate || statsEndToEnd.BNeedToSendPingImmediate( m_usecNow ) )\n\t\tnFlags |= msg.ACK_REQUEST_E2E | msg.ACK_REQUEST_IMMEDIATE;\n\telse if ( eReplyRequested == k_EStatsReplyRequest_DelayedOK || statsEndToEnd.BNeedToSendKeepalive( m_usecNow ) )\n\t\tnFlags |= msg.ACK_REQUEST_E2E;\n\telse\n\t{\n\t\tnReadyToSendTracer = statsEndToEnd.ReadyToSendTracerPing( m_usecNow );\n\t\tif ( nReadyToSendTracer > 1 )\n\t\t\tnFlags |= msg.ACK_REQUEST_E2E;\n\t}\n\n\tm_nFlags = nFlags;\n\n\t// Need to send any connection stats stats?\n\tm_nStatsNeed = statsEndToEnd.GetStatsSendNeed( m_usecNow );\n\tif ( m_nStatsNeed & k_nSendStats_Due )\n\t{\n\t\tstatsEndToEnd.PopulateMessage( m_nStatsNeed, *msg.mutable_stats(), m_usecNow );\n\n\t\tif ( nReadyToSendTracer > 0 )\n\t\t\tm_nFlags |= msg.ACK_REQUEST_E2E;\n\t}\n\n\t// Populate flags now, based on what is implied from what we HAVE to send\n\tSlamFlagsAndCalcSize();\n\tCalcMaxEncryptedPayloadSize( cbHdrtReserve, &connection );\n\n\t// Would we like to try to send some additional stats, if there is room?\n\tif ( m_nStatsNeed & k_nSendStats_Ready )\n\t{\n\t\tif ( nReadyToSendTracer > 0 )\n\t\t\tm_nFlags |= msg.ACK_REQUEST_E2E;\n\t\tstatsEndToEnd.PopulateMessage( m_nStatsNeed & k_nSendStats_Ready, *msg.mutable_stats(), m_usecNow );\n\t\tSlamFlagsAndCalcSize();\n\t}\n}\n\nvoid UDPSendPacketContext_t::Trim( int cbHdrOutSpaceRemaining )\n{\n\twhile ( m_cbTotalSize > cbHdrOutSpaceRemaining )\n\t{\n\t\tif ( !msg.has_stats() )\n\t\t{\n\t\t\t// Nothing left to clear!?  We shouldn't get here!\n\t\t\tAssertMsg( false, \"Serialized stats message still won't fit, ever after clearing everything?\" );\n\t\t\tm_cbTotalSize = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ( m_nStatsNeed & k_nSendStats_Instantanous_Ready )\n\t\t{\n\t\t\tmsg.mutable_stats()->clear_instantaneous();\n\t\t\tm_nStatsNeed &= ~k_nSendStats_Instantanous_Ready;\n\t\t}\n\t\telse if ( m_nStatsNeed & k_nSendStats_Lifetime_Ready )\n\t\t{\n\t\t\tmsg.mutable_stats()->clear_lifetime();\n\t\t\tm_nStatsNeed &= ~k_nSendStats_Lifetime_Ready;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tAssertMsg( false, \"We didn't reserve enough space for stats!\" );\n\t\t\tif ( m_nStatsNeed & k_nSendStats_Instantanous_Due )\n\t\t\t{\n\t\t\t\tmsg.mutable_stats()->clear_instantaneous();\n\t\t\t\tm_nStatsNeed &= ~k_nSendStats_Instantanous_Due;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_nStatsNeed = 0;\n\t\t\t}\n\t\t}\n\n\t\tif ( m_nStatsNeed == 0 )\n\t\t\tmsg.clear_stats();\n\n\t\tSlamFlagsAndCalcSize();\n\t}\n}\n\nbool CConnectionTransportUDP::BConnect( const netadr_t &netadrRemote, SteamDatagramErrMsg &errMsg )\n{\n\n\t// Create an actual OS socket.  We'll bind it to talk only to this host.\n\t// (Note: we might not actually \"bind\" it at the OS layer, but from our perpsective\n\t// it is bound.)\n\t//\n\t// For now we're just assuming each connection will gets its own socket,\n\t// on an ephemeral port.  Later we could add a setting to enable\n\t// sharing of the socket or binding to a particular local address.\n\tAssert( !m_pSocket );\n\tm_pSocket = OpenUDPSocketBoundToHost( netadrRemote, CRecvPacketCallback( PacketReceived, this ), errMsg );\n\tif ( !m_pSocket )\n\t\treturn false;\n\treturn true;\n}\n\nbool CConnectionTransportUDP::BAccept( CSharedSocket *pSharedSock, const netadr_t &netadrRemote, SteamDatagramErrMsg &errMsg )\n{\n\t// Get an interface that is bound to talk to this address\n\tm_pSocket = pSharedSock->AddRemoteHost( netadrRemote, CRecvPacketCallback( PacketReceived, this ) );\n\tif ( !m_pSocket )\n\t{\n\t\t// This is really weird and shouldn't happen\n\t\tV_strcpy_safe( errMsg, \"Unable to create a bound socket on the shared socket.\" );\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nbool CConnectionTransportUDP::CreateLoopbackPair( CConnectionTransportUDP *pTransport[2] )\n{\n\tIBoundUDPSocket *sock[2];\n\tSteamNetworkingErrMsg errMsg;\n\tif ( !CreateBoundSocketPair(\n\t\tCRecvPacketCallback( PacketReceived, pTransport[0] ),\n\t\tCRecvPacketCallback( PacketReceived, pTransport[1] ), sock, errMsg ) )\n\t{\n\t\t// Assert, this really should only fail if we have some sort of bug\n\t\tAssertMsg1( false, \"Failed to create UDP socket pair.  %s\", errMsg );\n\t\treturn false;\n\t}\n\n\tpTransport[0]->m_pSocket = sock[0];\n\tpTransport[1]->m_pSocket = sock[1];\n\n\treturn true;\n}\n\nbool CSteamNetworkConnectionUDP::BInitConnect( const SteamNetworkingIPAddr &addressRemote, int nOptions, const SteamNetworkingConfigValue_t *pOptions, SteamDatagramErrMsg &errMsg )\n{\n\tAssertMsg( !m_pTransport, \"Trying to connect when we already have a socket?\" );\n\n\t// We're initiating a connection, not being accepted on a listen socket\n\tAssert( !m_pParentListenSocket );\n\tAssert( !m_bConnectionInitiatedRemotely );\n\n\tnetadr_t netadrRemote;\n\tSteamNetworkingIPAddrToNetAdr( netadrRemote, addressRemote );\n\n\t// We use identity validity to denote when our connection has been accepted,\n\t// so it's important that it be cleared.  (It should already be so.)\n\tAssert( m_identityRemote.IsInvalid() );\n\tm_identityRemote.Clear();\n\n\t// We should know our own identity, unless the app has said it's OK to go without this.\n\tif ( m_identityLocal.IsInvalid() ) // Specific identity hasn't already been set (by derived class, etc)\n\t{\n\n\t\t// Use identity from the interface, if we have one\n\t\tm_identityLocal = m_pSteamNetworkingSocketsInterface->InternalGetIdentity();\n\t\tif ( m_identityLocal.IsInvalid())\n\t\t{\n\n\t\t\t// We don't know who we are.  Should we attempt anonymous?\n\t\t\tif ( m_connectionConfig.m_IP_AllowWithoutAuth.Get() == 0 )\n\t\t\t{\n\t\t\t\tV_strcpy_safe( errMsg, \"Unable to determine local identity, and auth required.  Not logged in?\" );\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tm_identityLocal.SetLocalHost();\n\t\t}\n\t}\n\n\t// Create transport.\n\tCConnectionTransportUDP *pTransport = new CConnectionTransportUDP( *this );\n\tif ( !pTransport->BConnect( netadrRemote, errMsg ) )\n\t{\n\t\tpTransport->TransportDestroySelfNow();\n\t\treturn false;\n\t}\n\tm_pTransport = pTransport;\n\n\t// Let base class do some common initialization\n\tSteamNetworkingMicroseconds usecNow = SteamNetworkingSockets_GetLocalTimestamp();\n\tif ( !CSteamNetworkConnectionBase::BInitConnection( usecNow, nOptions, pOptions, errMsg ) )\n\t{\n\t\tDestroyTransport();\n\t\treturn false;\n\t}\n\n\t// Start the connection state machine\n\treturn BConnectionState_Connecting( usecNow, errMsg );\n}\n\nbool CConnectionTransportUDP::BCanSendEndToEndConnectRequest() const\n{\n\treturn m_pSocket != nullptr;\n}\n\nbool CConnectionTransportUDP::BCanSendEndToEndData() const\n{\n\treturn m_pSocket != nullptr;\n}\n\nvoid CConnectionTransportUDP::SendEndToEndConnectRequest( SteamNetworkingMicroseconds usecNow )\n{\n\tAssert( !ListenSocket() );\n\tAssert( !m_connection.m_bConnectionInitiatedRemotely );\n\tAssert( ConnectionState() == k_ESteamNetworkingConnectionState_Connecting ); // Why else would we be doing this?\n\tAssert( ConnectionIDLocal() );\n\n\tCMsgSteamSockets_UDP_ChallengeRequest msg;\n\tmsg.set_connection_id( ConnectionIDLocal() );\n\t//msg.set_client_steam_id( m_steamIDLocal.ConvertToUint64() );\n\tmsg.set_my_timestamp( usecNow );\n\tmsg.set_protocol_version( k_nCurrentProtocolVersion );\n\n\t// Send it, with padding\n\tSendPaddedMsg( k_ESteamNetworkingUDPMsg_ChallengeRequest, msg );\n\n\t// They are supposed to reply with a timestamps, from which we can estimate the ping.\n\t// So this counts as a ping request\n\tm_connection.m_statsEndToEnd.TrackSentPingRequest( usecNow, false );\n}\n\nbool CSteamNetworkConnectionUDP::BBeginAccept(\n\tCSteamNetworkListenSocketDirectUDP *pParent,\n\tconst netadr_t &adrFrom,\n\tCSharedSocket *pSharedSock,\n\tconst SteamNetworkingIdentity &identityRemote,\n\tuint32 unConnectionIDRemote,\n\tconst CMsgSteamDatagramCertificateSigned &msgCert,\n\tconst CMsgSteamDatagramSessionCryptInfoSigned &msgCryptSessionInfo,\n\tSteamDatagramErrMsg &errMsg\n)\n{\n\tAssertMsg( !m_pTransport, \"Trying to accept when we already have transport?\" );\n\n\t// Setup transport\n\tCConnectionTransportUDP *pTransport = new CConnectionTransportUDP( *this );\n\tif ( !pTransport->BAccept( pSharedSock, adrFrom, errMsg ) )\n\t{\n\t\tpTransport->TransportDestroySelfNow();\n\t\treturn false;\n\t}\n\tm_pTransport = pTransport;\n\n\tm_identityRemote = identityRemote;\n\n\t// Caller should have ensured a valid identity\n\tAssert( !m_identityRemote.IsInvalid() );\n\n\tm_unConnectionIDRemote = unConnectionIDRemote;\n\tif ( !pParent->BAddChildConnection( this, errMsg ) )\n\t\treturn false;\n\n\t// Let base class do some common initialization\n\tSteamNetworkingMicroseconds usecNow = SteamNetworkingSockets_GetLocalTimestamp();\n\tif ( !CSteamNetworkConnectionBase::BInitConnection( usecNow, 0, nullptr, errMsg ) )\n\t{\n\t\tDestroyTransport();\n\t\treturn false;\n\t}\n\n\t// Process crypto handshake now\n\tif ( !BRecvCryptoHandshake( msgCert, msgCryptSessionInfo, true ) )\n\t{\n\t\tDestroyTransport();\n\t\tAssert( GetState() == k_ESteamNetworkingConnectionState_ProblemDetectedLocally );\n\t\tV_sprintf_safe( errMsg, \"Failed crypto init.  %s\", m_szEndDebug );\n\t\treturn false;\n\t}\n\n\t// Start the connection state machine\n\treturn BConnectionState_Connecting( usecNow, errMsg );\n}\n\nEResult CSteamNetworkConnectionUDP::AcceptConnection( SteamNetworkingMicroseconds usecNow )\n{\n\tif ( !Transport() )\n\t{\n\t\tAssertMsg( false, \"Cannot acception UDP connection.  No transport?\" );\n\t\treturn k_EResultFail;\n\t}\n\n\t// Send the message\n\tTransport()->SendConnectOK( usecNow );\n\n\t// We are fully connected\n\tConnectionState_Connected( usecNow );\n\n\t// OK\n\treturn k_EResultOK;\n}\n\nbool CConnectionTransportUDP::SendPacket( const void *pkt, int cbPkt )\n{\n\tiovec temp;\n\ttemp.iov_base = const_cast<void*>( pkt );\n\ttemp.iov_len = cbPkt;\n\treturn SendPacketGather( 1, &temp, cbPkt );\n}\n\nbool CConnectionTransportUDP::SendPacketGather( int nChunks, const iovec *pChunks, int cbSendTotal )\n{\n\t// Safety\n\tif ( !m_pSocket )\n\t{\n\t\tAssertMsg( false, \"Attemt to send packet, but socket has been closed!\" );\n\t\treturn false;\n\t}\n\n\t// Update stats\n\tm_connection.m_statsEndToEnd.TrackSentPacket( cbSendTotal );\n\n\t// Hand over to operating system\n\treturn m_pSocket->BSendRawPacketGather( nChunks, pChunks );\n}\n\nvoid CConnectionTransportUDP::TransportConnectionStateChanged( ESteamNetworkingConnectionState eOldState )\n{\n\tCConnectionTransport::TransportConnectionStateChanged( eOldState );\n\n\tswitch ( ConnectionState() )\n\t{\n\t\tcase k_ESteamNetworkingConnectionState_FindingRoute: // not used for raw UDP\n\t\tdefault:\n\t\t\tAssert( false );\n\t\tcase k_ESteamNetworkingConnectionState_None:\n\t\tcase k_ESteamNetworkingConnectionState_Dead:\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_FinWait:\n\t\tcase k_ESteamNetworkingConnectionState_ProblemDetectedLocally:\n\t\t\tSendConnectionClosedOrNoConnection();\n\t\t\tbreak;\n\n\t\tcase k_ESteamNetworkingConnectionState_Linger:\n\t\t\tbreak;\n\n\t\tcase k_ESteamNetworkingConnectionState_Connecting:\n\t\tcase k_ESteamNetworkingConnectionState_Connected:\n\t\tcase k_ESteamNetworkingConnectionState_ClosedByPeer:\n\t\t\tbreak;\n\t}\n}\n\nvoid CConnectionTransportUDP::TransportPopulateConnectionInfo( SteamNetConnectionInfo_t &info ) const\n{\n\tCConnectionTransport::TransportPopulateConnectionInfo( info );\n\n\tif ( m_pSocket )\n\t{\n\t\tconst netadr_t &addr = m_pSocket->GetRemoteHostAddr();\n\t\tNetAdrToSteamNetworkingIPAddr( info.m_addrRemote, addr );\n\t\tif ( addr.IsLoopback() )\n\t\t\tinfo.m_eTransportKind = k_ESteamNetTransport_LocalHost;\n\t\telse if ( m_connection.m_statsEndToEnd.m_ping.m_nSmoothedPing <= 5 && IsRouteToAddressProbablyLocal( addr ) )\n\t\t\tinfo.m_eTransportKind = k_ESteamNetTransport_UDPProbablyLocal;\n\t\telse\n\t\t\tinfo.m_eTransportKind = k_ESteamNetTransport_UDP;\n\t}\n}\n\nvoid CConnectionTransportUDP::PacketReceived( const void *pvPkt, int cbPkt, const netadr_t &adrFrom, CConnectionTransportUDP *pSelf )\n{\n\tconst uint8 *pPkt = static_cast<const uint8 *>( pvPkt );\n\n\tSteamNetworkingMicroseconds usecNow = SteamNetworkingSockets_GetLocalTimestamp();\n\n\tif ( cbPkt < 5 )\n\t{\n\t\tReportBadPacket( \"packet\", \"%d byte packet is too small\", cbPkt );\n\t\treturn;\n\t}\n\n\t// Data packet is the most common, check for it first.  Also, does stat tracking.\n\tif ( *pPkt & 0x80 )\n\t{\n\t\tpSelf->Received_Data( pPkt, cbPkt, usecNow );\n\t\treturn;\n\t}\n\n\t// Track stats for other packet types.\n\tpSelf->m_connection.m_statsEndToEnd.TrackRecvPacket( cbPkt, usecNow );\n\n\tif ( *pPkt == k_ESteamNetworkingUDPMsg_ChallengeReply )\n\t{\n\t\tParseProtobufBody( pPkt+1, cbPkt-1, CMsgSteamSockets_UDP_ChallengeReply, msg )\n\t\tpSelf->Received_ChallengeReply( msg, usecNow );\n\t}\n\telse if ( *pPkt == k_ESteamNetworkingUDPMsg_ConnectOK )\n\t{\n\t\tParseProtobufBody( pPkt+1, cbPkt-1, CMsgSteamSockets_UDP_ConnectOK, msg );\n\t\tpSelf->Received_ConnectOK( msg, usecNow );\n\t}\n\telse if ( *pPkt == k_ESteamNetworkingUDPMsg_ConnectionClosed )\n\t{\n\t\tParsePaddedPacket( pvPkt, cbPkt, CMsgSteamSockets_UDP_ConnectionClosed, msg )\n\t\tpSelf->Received_ConnectionClosed( msg, usecNow );\n\t}\n\telse if ( *pPkt == k_ESteamNetworkingUDPMsg_NoConnection )\n\t{\n\t\tParseProtobufBody( pPkt+1, cbPkt-1, CMsgSteamSockets_UDP_NoConnection, msg )\n\t\tpSelf->Received_NoConnection( msg, usecNow );\n\t}\n\telse if ( *pPkt == k_ESteamNetworkingUDPMsg_ChallengeRequest )\n\t{\n\t\tParsePaddedPacket( pvPkt, cbPkt, CMsgSteamSockets_UDP_ChallengeRequest, msg )\n\t\tpSelf->Received_ChallengeOrConnectRequest( \"ChallengeRequest\", msg.connection_id(), usecNow );\n\t}\n\telse if ( *pPkt == k_ESteamNetworkingUDPMsg_ConnectRequest )\n\t{\n\t\tParseProtobufBody( pPkt+1, cbPkt-1, CMsgSteamSockets_UDP_ConnectRequest, msg )\n\t\tpSelf->Received_ChallengeOrConnectRequest( \"ConnectRequest\", msg.client_connection_id(), usecNow );\n\t}\n\telse\n\t{\n\t\tReportBadPacket( \"packet\", \"Lead byte 0x%02x not a known message ID\", *pPkt );\n\t}\n}\n\nvoid CConnectionTransportUDP::Received_ChallengeReply( const CMsgSteamSockets_UDP_ChallengeReply &msg, SteamNetworkingMicroseconds usecNow )\n{\n\t// We should only be getting this if we are the \"client\"\n\tif ( ListenSocket() )\n\t{\n\t\tReportBadUDPPacketFromConnectionPeer( \"ChallengeReply\", \"Shouldn't be receiving this unless on accepted connections, only connections initiated locally.\" );\n\t\treturn;\n\t}\n\n\t// Ignore if we're not trying to connect\n\tif ( ConnectionState() != k_ESteamNetworkingConnectionState_Connecting )\n\t\treturn;\n\n\t// Check session ID to make sure they aren't spoofing.\n\tif ( msg.connection_id() != ConnectionIDLocal() )\n\t{\n\t\tReportBadUDPPacketFromConnectionPeer( \"ChallengeReply\", \"Incorrect connection ID.  Message is stale or could be spoofed, ignoring.\" );\n\t\treturn;\n\t}\n\tif ( msg.protocol_version() < k_nMinRequiredProtocolVersion )\n\t{\n\t\tm_connection.ConnectionState_ProblemDetectedLocally( k_ESteamNetConnectionEnd_Misc_Generic, \"Peer is running old software and needs to be udpated\" );\n\t\treturn;\n\t}\n\n\t// Update ping, if they replied with the timestamp\n\tif ( msg.has_your_timestamp() )\n\t{\n\t\tSteamNetworkingMicroseconds usecElapsed = usecNow - (SteamNetworkingMicroseconds)msg.your_timestamp();\n\t\tif ( usecElapsed < 0 || usecElapsed > 2*k_nMillion )\n\t\t{\n\t\t\tSpewWarning( \"Ignoring weird timestamp %llu in ChallengeReply, current time is %llu.\\n\", (unsigned long long)msg.your_timestamp(), usecNow );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint nPing = (usecElapsed + 500 ) / 1000;\n\t\t\tm_connection.m_statsEndToEnd.m_ping.ReceivedPing( nPing, usecNow );\n\t\t}\n\t}\n\n\t// Make sure we have the crypt info that we need\n\tif ( !m_connection.GetSignedCertLocal().has_cert() || !m_connection.GetSignedCryptLocal().has_info() )\n\t{\n\t\tm_connection.ConnectionState_ProblemDetectedLocally( k_ESteamNetConnectionEnd_Misc_InternalError, \"Tried to connect request, but crypt not ready\" );\n\t\treturn;\n\t}\n\n\t// Remember protocol version.  They must send it again in the connect OK, but we have a valid value now,\n\t// so we might as well save it\n\tm_connection.m_statsEndToEnd.m_nPeerProtocolVersion = msg.protocol_version();\n\n\t// Reply with the challenge data and our cert\n\tCMsgSteamSockets_UDP_ConnectRequest msgConnectRequest;\n\tmsgConnectRequest.set_client_connection_id( ConnectionIDLocal() );\n\tmsgConnectRequest.set_challenge( msg.challenge() );\n\tmsgConnectRequest.set_my_timestamp( usecNow );\n\tif ( m_connection.m_statsEndToEnd.m_ping.m_nSmoothedPing >= 0 )\n\t\tmsgConnectRequest.set_ping_est_ms( m_connection.m_statsEndToEnd.m_ping.m_nSmoothedPing );\n\t*msgConnectRequest.mutable_cert() = m_connection.GetSignedCertLocal();\n\t*msgConnectRequest.mutable_crypt() = m_connection.GetSignedCryptLocal();\n\n\t// If the cert is generic, then we need to specify our identity\n\tif ( !m_connection.BCertHasIdentity() )\n\t{\n\t\tSteamNetworkingIdentityToProtobuf( IdentityLocal(), msgConnectRequest, identity_string, legacy_identity_binary, legacy_client_steam_id );\n\t}\n\telse\n\t{\n\t\t// Identity is in the cert.  But for old peers, set legacy field, if we are a SteamID\n\t\tif ( IdentityLocal().GetSteamID64() )\n\t\t\tmsgConnectRequest.set_legacy_client_steam_id( IdentityLocal().GetSteamID64() );\n\t}\n\n\t// Send it\n\tSendMsg( k_ESteamNetworkingUDPMsg_ConnectRequest, msgConnectRequest );\n\n\t// Update retry bookkeeping, etc\n\tm_connection.SentEndToEndConnectRequest( usecNow );\n\n\t// They are supposed to reply with a timestamps, from which we can estimate the ping.\n\t// So this counts as a ping request\n\tm_connection.m_statsEndToEnd.TrackSentPingRequest( usecNow, false );\n}\n\nvoid CConnectionTransportUDP::Received_ConnectOK( const CMsgSteamSockets_UDP_ConnectOK &msg, SteamNetworkingMicroseconds usecNow )\n{\n\tSteamDatagramErrMsg errMsg;\n\n\t// We should only be getting this if we are the \"client\"\n\tif ( ListenSocket() )\n\t{\n\t\tReportBadUDPPacketFromConnectionPeer( \"ConnectOK\", \"Shouldn't be receiving this unless on accepted connections, only connections initiated locally.\" );\n\t\treturn;\n\t}\n\n\t// Check connection ID to make sure they aren't spoofing and it's the same connection we think it is\n\tif ( msg.client_connection_id() != ConnectionIDLocal() )\n\t{\n\t\tReportBadUDPPacketFromConnectionPeer( \"ConnectOK\", \"Incorrect connection ID.  Message is stale or could be spoofed, ignoring.\" );\n\t\treturn;\n\t}\n\n\t// Parse out identity from the cert\n\tSteamNetworkingIdentity identityRemote;\n\tbool bIdentityInCert = true;\n\t{\n\t\t// !SPEED! We are deserializing the cert here,\n\t\t// and then we are going to do it again below.\n\t\t// Should refactor to fix this.\n\t\tint r = SteamNetworkingIdentityFromSignedCert( identityRemote, msg.cert(), errMsg );\n\t\tif ( r < 0 )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \"ConnectRequest\", \"Bad identity in cert.  %s\", errMsg );\n\t\t\treturn;\n\t\t}\n\t\tif ( r == 0 )\n\t\t{\n\t\t\t// No identity in the cert.  Check if they put it directly in the connect message\n\t\t\tbIdentityInCert = false;\n\t\t\tr = SteamNetworkingIdentityFromProtobuf( identityRemote, msg, identity_string, legacy_identity_binary, legacy_server_steam_id, errMsg );\n\t\t\tif ( r < 0 )\n\t\t\t{\n\t\t\t\tReportBadUDPPacketFromConnectionPeer( \"ConnectRequest\", \"Bad identity.  %s\", errMsg );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( r == 0 )\n\t\t\t{\n\t\t\t\t// If no identity was presented, it's the same as them saying they are \"localhost\"\n\t\t\t\tidentityRemote.SetLocalHost();\n\t\t\t}\n\t\t}\n\t}\n\tAssert( !identityRemote.IsInvalid() );\n\n\t// Check if they are using an IP address as an identity (possibly the anonymous \"localhost\" identity)\n\tif ( identityRemote.m_eType == k_ESteamNetworkingIdentityType_IPAddress )\n\t{\n\t\tSteamNetworkingIPAddr addr;\n\t\tconst netadr_t &adrFrom = m_pSocket->GetRemoteHostAddr();\n\t\tadrFrom.GetIPV6( addr.m_ipv6 );\n\t\taddr.m_port = adrFrom.GetPort();\n\n\t\tif ( identityRemote.IsLocalHost() )\n\t\t{\n\t\t\tif ( m_connection.m_connectionConfig.m_IP_AllowWithoutAuth.Get() == 0 )\n\t\t\t{\n\t\t\t\t// Should we send an explicit rejection here?\n\t\t\t\tReportBadUDPPacketFromConnectionPeer( \"ConnectOK\", \"Unauthenticated connections not allowed.\" );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set their identity to their real address (including port)\n\t\t\tidentityRemote.SetIPAddr( addr );\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// FIXME - Should the address be required to match?\n\t\t\t// If we are behind NAT, it won't.\n\t\t\t//if ( memcmp( addr.m_ipv6, identityRemote.m_ip.m_ipv6, sizeof(addr.m_ipv6) ) != 0\n\t\t\t//\t|| ( identityRemote.m_ip.m_port != 0 && identityRemote.m_ip.m_port != addr.m_port ) ) // Allow 0 port in the identity to mean \"any port\"\n\t\t\t//{\n\t\t\t//\tReportBadPacket( \"ConnectRequest\", \"Identity in request is %s, but packet is coming from %s.\" );\n\t\t\t//\treturn;\n\t\t\t//}\n\n\t\t\t// It's not really clear what the use case is here for\n\t\t\t// requesting a specific IP address as your identity,\n\t\t\t// and not using localhost.  If they have a cert, assume it's\n\t\t\t// meaningful.  Remember: the cert could be unsigned!  That\n\t\t\t// is a separate issue which will be handled later, whether\n\t\t\t// we want to allow that.\n\t\t\tif ( !bIdentityInCert )\n\t\t\t{\n\t\t\t\t// Should we send an explicit rejection here?\n\t\t\t\tReportBadPacket( \"ConnectOK\", \"Cannot use specific IP address.\" );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Make sure they are still who we think they are\n\tif ( !m_connection.m_identityRemote.IsInvalid() && !( m_connection.m_identityRemote == identityRemote ) )\n\t{\n\t\tReportBadUDPPacketFromConnectionPeer( \"ConnectOK\", \"server_steam_id doesn't match who we expect to be connecting to!\" );\n\t\treturn;\n\t}\n\n\t// Update ping, if they replied a timestamp\n\tif ( msg.has_your_timestamp() )\n\t{\n\t\tSteamNetworkingMicroseconds usecElapsed = usecNow - (SteamNetworkingMicroseconds)msg.your_timestamp() - msg.delay_time_usec();\n\t\tif ( usecElapsed < 0 || usecElapsed > 2*k_nMillion )\n\t\t{\n\t\t\tSpewWarning( \"Ignoring weird timestamp %llu in ConnectOK, current time is %llu, remote delay was %lld.\\n\", (unsigned long long)msg.your_timestamp(), usecNow, (long long)msg.delay_time_usec() );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint nPing = (usecElapsed + 500 ) / 1000;\n\t\t\tm_connection.m_statsEndToEnd.m_ping.ReceivedPing( nPing, usecNow );\n\t\t}\n\t}\n\n\t// Check state\n\tswitch ( ConnectionState() )\n\t{\n\t\tcase k_ESteamNetworkingConnectionState_Dead:\n\t\tcase k_ESteamNetworkingConnectionState_None:\n\t\tcase k_ESteamNetworkingConnectionState_FindingRoute: // not used for raw UDP\n\t\tdefault:\n\t\t\tAssert( false );\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_ClosedByPeer:\n\t\tcase k_ESteamNetworkingConnectionState_FinWait:\n\t\tcase k_ESteamNetworkingConnectionState_ProblemDetectedLocally:\n\t\t\tSendConnectionClosedOrNoConnection();\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_Linger:\n\t\tcase k_ESteamNetworkingConnectionState_Connected:\n\t\t\t// We already know we were able to establish the connection.\n\t\t\t// Just ignore this packet\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_Connecting:\n\t\t\tbreak;\n\t}\n\n\t// Connection ID\n\tm_connection.m_unConnectionIDRemote = msg.server_connection_id();\n\tif ( ( m_connection.m_unConnectionIDRemote & 0xffff ) == 0 )\n\t{\n\t\tm_connection.ConnectionState_ProblemDetectedLocally( k_ESteamNetConnectionEnd_Remote_BadCrypt, \"Didn't send valid connection ID\" );\n\t\treturn;\n\t}\n\n\tm_connection.m_identityRemote = identityRemote;\n\n\t// Check the certs, save keys, etc\n\tif ( !m_connection.BRecvCryptoHandshake( msg.cert(), msg.crypt(), false ) )\n\t{\n\t\tAssert( ConnectionState() == k_ESteamNetworkingConnectionState_ProblemDetectedLocally );\n\t\tReportBadUDPPacketFromConnectionPeer( \"ConnectOK\", \"Failed crypto init.  %s\", m_connection.m_szEndDebug );\n\t\treturn;\n\t}\n\n\t// Generic connection code will take it from here.\n\tm_connection.ConnectionState_Connected( usecNow );\n}\n\nvoid CConnectionTransportUDP::Received_ChallengeOrConnectRequest( const char *pszDebugPacketType, uint32 unPacketConnectionID, SteamNetworkingMicroseconds usecNow )\n{\n\t// If wrong connection ID, then check for sending a generic reply and bail\n\tif ( unPacketConnectionID != m_connection.m_unConnectionIDRemote )\n\t{\n\t\tReportBadUDPPacketFromConnectionPeer( pszDebugPacketType, \"Incorrect connection ID, when we do have a connection for this address.  Could be spoofed, ignoring.\" );\n\t\t// Let's not send a reply in this case\n\t\t//if ( BCheckGlobalSpamReplyRateLimit( usecNow ) )\n\t\t//\tSendNoConnection( unPacketConnectionID );\n\t\treturn;\n\t}\n\n\t// Check state\n\tswitch ( ConnectionState() )\n\t{\n\t\tcase k_ESteamNetworkingConnectionState_Dead:\n\t\tcase k_ESteamNetworkingConnectionState_None:\n\t\tcase k_ESteamNetworkingConnectionState_FindingRoute: // not used for raw UDP\n\t\tdefault:\n\t\t\tAssert( false );\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_ClosedByPeer:\n\t\tcase k_ESteamNetworkingConnectionState_FinWait:\n\t\tcase k_ESteamNetworkingConnectionState_ProblemDetectedLocally:\n\t\t\tSendConnectionClosedOrNoConnection();\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_Connecting:\n\t\t\t// We're waiting on the application.  So we'll just have to ignore.\n\t\t\tbreak;\n\n\t\tcase k_ESteamNetworkingConnectionState_Linger:\n\t\tcase k_ESteamNetworkingConnectionState_Connected:\n\t\t\tif ( !ListenSocket() )\n\t\t\t{\n\t\t\t\t// WAT?  We initiated this connection, so why are they requesting to connect?\n\t\t\t\tReportBadUDPPacketFromConnectionPeer( pszDebugPacketType, \"We are the 'client' who initiated the connection, so 'server' shouldn't be sending us this!\" );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// This is totally legit and possible.  Our earlier reply might have dropped, and they are re-sending\n\t\t\tSendConnectOK( usecNow );\n\t\t\treturn;\n\t}\n\n}\n\nvoid CConnectionTransportUDP::SendConnectOK( SteamNetworkingMicroseconds usecNow )\n{\n\tAssert( ConnectionIDLocal() );\n\tAssert( ConnectionIDRemote() );\n\tAssert( ListenSocket() );\n\n\tAssert( m_connection.GetSignedCertLocal().has_cert() );\n\tAssert( m_connection.GetSignedCryptLocal().has_info() );\n\n\tCMsgSteamSockets_UDP_ConnectOK msg;\n\tmsg.set_client_connection_id( ConnectionIDRemote() );\n\tmsg.set_server_connection_id( ConnectionIDLocal() );\n\t*msg.mutable_cert() = m_connection.GetSignedCertLocal();\n\t*msg.mutable_crypt() = m_connection.GetSignedCryptLocal();\n\n\t// If the cert is generic, then we need to specify our identity\n\tif ( !m_connection.BCertHasIdentity() )\n\t{\n\t\tSteamNetworkingIdentityToProtobuf( IdentityLocal(), msg, identity_string, legacy_identity_binary, legacy_server_steam_id );\n\t}\n\telse\n\t{\n\t\t// Identity is in the cert.  But for old peers, set legacy field, if we are a SteamID\n\t\tif ( IdentityLocal().GetSteamID64() )\n\t\t\tmsg.set_legacy_server_steam_id( IdentityLocal().GetSteamID64() );\n\t}\n\n\t// Do we have a timestamp?\n\tif ( m_connection.m_usecWhenReceivedHandshakeRemoteTimestamp )\n\t{\n\t\tSteamNetworkingMicroseconds usecElapsed = usecNow - m_connection.m_usecWhenReceivedHandshakeRemoteTimestamp;\n\t\tAssert( usecElapsed >= 0 );\n\t\tif ( usecElapsed < 4*k_nMillion )\n\t\t{\n\t\t\tmsg.set_your_timestamp( m_connection.m_ulHandshakeRemoteTimestamp );\n\t\t\tmsg.set_delay_time_usec( usecElapsed );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSpewWarning( \"Discarding handshake timestamp that's %lldms old, not sending in ConnectOK\\n\", usecElapsed/1000 );\n\t\t\tm_connection.m_usecWhenReceivedHandshakeRemoteTimestamp = 0;\n\t\t}\n\t}\n\n\n\t// Send it, with padding\n\tSendMsg( k_ESteamNetworkingUDPMsg_ConnectOK, msg );\n}\n\nEUnsignedCert CSteamNetworkConnectionUDP::AllowRemoteUnsignedCert()\n{\n\t// NOTE: No special override for localhost.\n\t// Should we add a seperate convar for this?\n\t// For the CSteamNetworkConnectionlocalhostLoopback connection,\n\t// we know both ends are us.  but if they are just connecting to\n\t// 127.0.0.1, it's not clear that we should handle this any\n\t// differently from any other connection\n\n\t// Enabled by convar?\n\tint nAllow = m_connectionConfig.m_IP_AllowWithoutAuth.Get();\n\tif ( nAllow > 1 )\n\t\treturn k_EUnsignedCert_Allow;\n\tif ( nAllow == 1 )\n\t\treturn k_EUnsignedCert_AllowWarn;\n\n\t// Lock it down\n\treturn k_EUnsignedCert_Disallow;\n}\n\nEUnsignedCert CSteamNetworkConnectionUDP::AllowLocalUnsignedCert()\n{\n\t// Same logic actually applies for remote and local\n\treturn AllowRemoteUnsignedCert();\n}\n\n/////////////////////////////////////////////////////////////////////////////\n//\n// Loopback connections\n//\n/////////////////////////////////////////////////////////////////////////////\n\nCSteamNetworkConnectionlocalhostLoopback::CSteamNetworkConnectionlocalhostLoopback( CSteamNetworkingSockets *pSteamNetworkingSocketsInterface, const SteamNetworkingIdentity &identity )\n: CSteamNetworkConnectionUDP( pSteamNetworkingSocketsInterface )\n{\n\tm_identityLocal = identity;\n}\n\nEUnsignedCert CSteamNetworkConnectionlocalhostLoopback::AllowRemoteUnsignedCert()\n{\n\treturn k_EUnsignedCert_Allow;\n}\n\nEUnsignedCert CSteamNetworkConnectionlocalhostLoopback::AllowLocalUnsignedCert()\n{\n\treturn k_EUnsignedCert_Allow;\n}\n\nbool CSteamNetworkConnectionlocalhostLoopback::APICreateSocketPair( CSteamNetworkingSockets *pSteamNetworkingSocketsInterface, CSteamNetworkConnectionlocalhostLoopback *pConn[2], const SteamNetworkingIdentity pIdentity[2] )\n{\n\tSteamDatagramTransportLock::AssertHeldByCurrentThread();\n\n\tSteamDatagramErrMsg errMsg;\n\n\tpConn[1] = new CSteamNetworkConnectionlocalhostLoopback( pSteamNetworkingSocketsInterface, pIdentity[0] );\n\tpConn[0] = new CSteamNetworkConnectionlocalhostLoopback( pSteamNetworkingSocketsInterface, pIdentity[1] );\n\tif ( !pConn[0] || !pConn[1] )\n\t{\nfailed:\n\t\tpConn[0]->ConnectionDestroySelfNow(); pConn[0] = nullptr;\n\t\tpConn[1]->ConnectionDestroySelfNow(); pConn[1] = nullptr;\n\t\treturn false;\n\t}\n\n\t// Don't post any state changes for these transitions.  We just want to immediately start in the\n\t// connected state\n\t++pConn[0]->m_nSupressStateChangeCallbacks;\n\t++pConn[1]->m_nSupressStateChangeCallbacks;\n\n\tCConnectionTransportUDP *pTransport[2] = {\n\t\tnew CConnectionTransportUDP( *pConn[0] ),\n\t\tnew CConnectionTransportUDP( *pConn[1] )\n\t};\n\tpConn[0]->m_pTransport = pTransport[0];\n\tpConn[1]->m_pTransport = pTransport[1];\n\n\tif ( !CConnectionTransportUDP::CreateLoopbackPair( pTransport ) )\n\t\tgoto failed;\n\n\tSteamNetworkingMicroseconds usecNow = SteamNetworkingSockets_GetLocalTimestamp();\n\n\t// Initialize both connections\n\tfor ( int i = 0 ; i < 2 ; ++i )\n\t{\n\t\tif ( !pConn[i]->BInitConnection( usecNow, 0, nullptr, errMsg ) )\n\t\t{\n\t\t\tAssertMsg1( false, \"CSteamNetworkConnectionlocalhostLoopback::BInitConnection failed.  %s\", errMsg );\n\t\t\tgoto failed;\n\t\t}\n\t}\n\n\t// Tie the connections to each other, and mark them as connected\n\tfor ( int i = 0 ; i < 2 ; ++i )\n\t{\n\t\tCSteamNetworkConnectionlocalhostLoopback *p = pConn[i];\n\t\tCSteamNetworkConnectionlocalhostLoopback *q = pConn[1-i];\n\t\tp->m_identityRemote = q->m_identityLocal;\n\t\tp->m_unConnectionIDRemote = q->m_unConnectionIDLocal;\n\t\tp->m_statsEndToEnd.m_usecTimeLastRecv = usecNow; // Act like we just now received something\n\t\tif ( !p->BRecvCryptoHandshake( q->m_msgSignedCertLocal, q->m_msgSignedCryptLocal, i==0 ) )\n\t\t{\n\t\t\tAssertMsg( false, \"BRecvCryptoHandshake failed creating localhost socket pair\" );\n\t\t\tgoto failed;\n\t\t}\n\t\tif ( !p->BConnectionState_Connecting( usecNow, errMsg ) )\n\t\t{\n\t\t\tAssertMsg( false, \"BConnectionState_Connecting failed creating loopback pipe socket pair.  %s\", errMsg );\n\t\t\tgoto failed;\n\t\t}\n\t\tp->ConnectionState_Connected( usecNow );\n\t}\n\n\t// Any further state changes are legit\n\tpConn[0]->m_nSupressStateChangeCallbacks = 0;\n\tpConn[1]->m_nSupressStateChangeCallbacks = 0;\n\n\treturn true;\n}\n\n} // namespace SteamNetworkingSocketsLib\n"], "fixing_code": ["//====== Copyright Valve Corporation, All rights reserved. ====================\n\n#include \"steamnetworkingsockets_udp.h\"\n#include \"csteamnetworkingsockets.h\"\n#include \"crypto.h\"\n\n#ifdef _WINDOWS\n\t#include <iphlpapi.h>\n#endif\n\n// memdbgon must be the last include file in a .cpp file!!!\n#include \"tier0/memdbgon.h\"\n\n// Put everything in a namespace, so we don't violate the one definition rule\nnamespace SteamNetworkingSocketsLib {\n\n// Try to guess if the route the specified address is probably \"local\".\n// This is difficult to do in general.  We want something that mostly works.\n//\n// False positives: VPNs and IPv6 addresses that appear to be nearby but are not.\n// False negatives: We can't always tell if a route is local.\nbool IsRouteToAddressProbablyLocal( netadr_t addr )\n{\n\n\t// Assume that if we are able to send to any \"reserved\" route, that is is local.\n\t// Note that this will be true for VPNs, too!\n\tif ( addr.IsReservedAdr() )\n\t\treturn true;\n\n\t// But other cases might also be local routes.  E.g. two boxes with public IPs.\n\t// Convert to sockaddr struct so we can ask the operating system\n\taddr.SetPort(0);\n\tsockaddr_storage sockaddrDest;\n\taddr.ToSockadr( &sockaddrDest );\n\n\t#ifdef _WINDOWS\n\n\t\t//\n\t\t// These functions were added with Vista, so load dynamically\n\t\t// in case\n\t\t//\n\n\t\ttypedef\n\t\tDWORD\n\t\t(WINAPI *FnGetBestInterfaceEx)(\n\t\t\tstruct sockaddr *pDestAddr,\n\t\t\tPDWORD           pdwBestIfIndex\n\t\t\t);\n\t\ttypedef \n\t\tNETIO_STATUS\n\t\t(NETIOAPI_API_*FnGetBestRoute2)(\n\t\t\tNET_LUID *InterfaceLuid,\n\t\t\tNET_IFINDEX InterfaceIndex,\n\t\t\tCONST SOCKADDR_INET *SourceAddress,\n\t\t\tCONST SOCKADDR_INET *DestinationAddress,\n\t\t\tULONG AddressSortOptions,\n\t\t\tPMIB_IPFORWARD_ROW2 BestRoute,\n\t\t\tSOCKADDR_INET *BestSourceAddress\n\t\t\t);\n\n\t\tstatic HMODULE hModule = LoadLibraryA( \"Iphlpapi.dll\" );\n\t\tstatic FnGetBestInterfaceEx pGetBestInterfaceEx = hModule ? (FnGetBestInterfaceEx)GetProcAddress( hModule, \"GetBestInterfaceEx\" ) : nullptr;\n\t\tstatic FnGetBestRoute2 pGetBestRoute2 = hModule ? (FnGetBestRoute2)GetProcAddress( hModule, \"GetBestRoute2\" ) : nullptr;;\n\t\tif ( !pGetBestInterfaceEx || !pGetBestRoute2 )\n\t\t\treturn false;\n\n\t\tNET_IFINDEX dwBestIfIndex;\n\t\tDWORD r = (*pGetBestInterfaceEx)( (sockaddr *)&sockaddrDest, &dwBestIfIndex );\n\t\tif ( r != NO_ERROR )\n\t\t{\n\t\t\tAssertMsg2( false, \"GetBestInterfaceEx failed with result %d for address '%s'\", r, CUtlNetAdrRender( addr ).String() );\n\t\t\treturn false;\n\t\t}\n\n\t\tMIB_IPFORWARD_ROW2 bestRoute;\n\t\tSOCKADDR_INET bestSourceAddress;\n\t\tr = (*pGetBestRoute2)(\n\t\t\tnullptr, // InterfaceLuid\n\t\t\tdwBestIfIndex, // InterfaceIndex\n\t\t\tnullptr, // SourceAddress\n\t\t\t(SOCKADDR_INET *)&sockaddrDest, // DestinationAddress\n\t\t\t0, // AddressSortOptions\n\t\t\t&bestRoute, // BestRoute\n\t\t\t&bestSourceAddress // BestSourceAddress\n\t\t);\n\t\tif ( r != NO_ERROR )\n\t\t{\n\t\t\tAssertMsg2( false, \"GetBestRoute2 failed with result %d for address '%s'\", r, CUtlNetAdrRender( addr ).String() );\n\t\t\treturn false;\n\t\t}\n\t\tif ( bestRoute.Protocol == MIB_IPPROTO_LOCAL )\n\t\t\treturn true;\n\t\tnetadr_t nextHop;\n\t\tif ( !nextHop.SetFromSockadr( &bestRoute.NextHop ) )\n\t\t{\n\t\t\tAssertMsg( false, \"GetBestRoute2 returned invalid next hop address\" );\n\t\t\treturn false;\n\t\t}\n\n\t\tnextHop.SetPort( 0 );\n\n\t\t// https://docs.microsoft.com/en-us/windows/win32/api/netioapi/ns-netioapi-mib_ipforward_row2:\n\t\t//   For a remote route, the IP address of the next system or gateway en route.\n\t\t//   If the route is to a local loopback address or an IP address on the local\n\t\t//   link, the next hop is unspecified (all zeros). For a local loopback route,\n\t\t//   this member should be an IPv4 address of 0.0.0.0 for an IPv4 route entry\n\t\t//   or an IPv6 address address of 0::0 for an IPv6 route entry.\n\t\tif ( !nextHop.HasIP() )\n\t\t\treturn true;\n\t\tif ( nextHop == addr )\n\t\t\treturn true;\n\n\t\t// If final destination is on the same IPv6/56 prefix, then assume\n\t\t// it's a local route.  This is an arbitrary prefix size to use,\n\t\t// but it's a compromise.  We think that /64 probably has too\n\t\t// many false negatives, but /48 has have too many false positives.\n\t\tif ( addr.GetType() == k_EIPTypeV6 )\n\t\t{\n\t\t\tif ( nextHop.GetType() == k_EIPTypeV6 )\n\t\t\t{\n\t\t\t\tif ( memcmp( addr.GetIPV6Bytes(), nextHop.GetIPV6Bytes(), 7 ) == 0 )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tnetadr_t netdrBestSource;\n\t\t\tif ( netdrBestSource.SetFromSockadr( &bestSourceAddress ) && netdrBestSource.GetType() == k_EIPTypeV6 )\n\t\t\t{\n\t\t\t\tif ( memcmp( addr.GetIPV6Bytes(), netdrBestSource.GetIPV6Bytes(), 7 ) == 0 )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t#else\n\t\t// FIXME - Writeme\n\t#endif\n\n\t// Nope\n\treturn false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n//\n// Packet parsing / handling utils\n//\n/////////////////////////////////////////////////////////////////////////////\n\nbool BCheckRateLimitReportBadPacket( SteamNetworkingMicroseconds usecNow )\n{\n\tstatic SteamNetworkingMicroseconds s_usecLastReport;\n\tif ( s_usecLastReport + k_nMillion*2 > usecNow )\n\t\treturn false;\n\ts_usecLastReport = usecNow;\n\treturn true;\n}\n\nvoid ReallyReportBadUDPPacket( const char *pszFrom, const char *pszMsgType, const char *pszFmt, ... )\n{\n\tchar buf[ 2048 ];\n\tva_list ap;\n\tva_start( ap, pszFmt );\n\tV_vsprintf_safe( buf, pszFmt, ap );\n\tva_end( ap );\n\tV_StripTrailingWhitespaceASCII( buf );\n\n\tif ( !pszMsgType || !pszMsgType[0] )\n\t\tpszMsgType = \"message\";\n\n\tSpewMsg( \"[%s] Ignored bad %s.  %s\\n\", pszMsgType, pszFrom, buf );\n}\n\n#define ReportBadPacket( pszMsgType, /* fmt */ ... ) \\\n\tReportBadUDPPacketFrom( CUtlNetAdrRender( adrFrom ).String(), pszMsgType, __VA_ARGS__ )\n\n\n#define ParseProtobufBody( pvMsg, cbMsg, CMsgCls, msgVar ) \\\n\tCMsgCls msgVar; \\\n\tif ( !msgVar.ParseFromArray( pvMsg, cbMsg ) ) \\\n\t{ \\\n\t\tReportBadPacket( # CMsgCls, \"Protobuf parse failed.\" ); \\\n\t\treturn; \\\n\t}\n\n#define ParsePaddedPacket( pvPkt, cbPkt, CMsgCls, msgVar ) \\\n\tCMsgCls msgVar; \\\n\t{ \\\n\t\tif ( cbPkt < k_cbSteamNetworkingMinPaddedPacketSize ) \\\n\t\t{ \\\n\t\t\tReportBadPacket( # CMsgCls, \"Packet is %d bytes, must be padded to at least %d bytes.\", cbPkt, k_cbSteamNetworkingMinPaddedPacketSize ); \\\n\t\t\treturn; \\\n\t\t} \\\n\t\tconst UDPPaddedMessageHdr *hdr = static_cast< const UDPPaddedMessageHdr * >( pvPkt ); \\\n\t\tint nMsgLength = LittleWord( hdr->m_nMsgLength ); \\\n\t\tif ( nMsgLength <= 0 || int(nMsgLength+sizeof(UDPPaddedMessageHdr)) > cbPkt ) \\\n\t\t{ \\\n\t\t\tReportBadPacket( # CMsgCls, \"Invalid encoded message length %d.  Packet is %d bytes.\", nMsgLength, cbPkt ); \\\n\t\t\treturn; \\\n\t\t} \\\n\t\tif ( !msgVar.ParseFromArray( hdr+1, nMsgLength ) ) \\\n\t\t{ \\\n\t\t\tReportBadPacket( # CMsgCls, \"Protobuf parse failed.\" ); \\\n\t\t\treturn; \\\n\t\t} \\\n\t}\n\n/////////////////////////////////////////////////////////////////////////////\n//\n// CSteamNetworkListenSocketDirectUDP\n//\n/////////////////////////////////////////////////////////////////////////////\n\nCSteamNetworkListenSocketDirectUDP::CSteamNetworkListenSocketDirectUDP( CSteamNetworkingSockets *pSteamNetworkingSocketsInterface )\n: CSteamNetworkListenSocketBase( pSteamNetworkingSocketsInterface )\n{\n\tm_pSock = nullptr;\n}\n\nCSteamNetworkListenSocketDirectUDP::~CSteamNetworkListenSocketDirectUDP()\n{\n\t// Clean up socket, if any\n\tif ( m_pSock )\n\t{\n\t\tdelete m_pSock;\n\t\tm_pSock = nullptr;\n\t}\n}\n\nbool CSteamNetworkListenSocketDirectUDP::BInit( const SteamNetworkingIPAddr &localAddr, int nOptions, const SteamNetworkingConfigValue_t *pOptions, SteamDatagramErrMsg &errMsg )\n{\n\tAssert( m_pSock == nullptr );\n\n\tif ( localAddr.m_port == 0 )\n\t{\n\t\tV_strcpy_safe( errMsg, \"Must specify local port.\" );\n\t\treturn false;\n\t}\n\n\t// Set options, add us to the global table\n\tif ( !BInitListenSocketCommon( nOptions, pOptions, errMsg ) )\n\t\treturn false;\n\n\t// Might we need to authenticate?\n\tint IP_AllowWithoutAuth = m_connectionConfig.m_IP_AllowWithoutAuth.Get();\n\tif ( IP_AllowWithoutAuth < 2 )\n\t{\n\t\tm_pSteamNetworkingSocketsInterface->AuthenticationNeeded();\n\n\t\t// If we know for sure that this can't ever work, then go ahead and fail now.\n\t\t#ifndef STEAMNETWORKINGSOCKETS_CAN_REQUEST_CERT\n\t\t\tif ( IP_AllowWithoutAuth == 0 )\n\t\t\t{\n\t\t\t\tV_strcpy_safe( errMsg, \"No cert authority, must set IP_AllowWithoutAuth\" );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t#endif\n\t}\n\n\tm_pSock = new CSharedSocket;\n\tif ( !m_pSock->BInit( localAddr, CRecvPacketCallback( ReceivedFromUnknownHost, this ), errMsg ) )\n\t{\n\t\tdelete m_pSock;\n\t\tm_pSock = nullptr;\n\t\treturn false;\n\t}\n\n\tCCrypto::GenerateRandomBlock( m_argbChallengeSecret, sizeof(m_argbChallengeSecret) );\n\n\treturn true;\n}\n\nbool CSteamNetworkListenSocketDirectUDP::APIGetAddress( SteamNetworkingIPAddr *pAddress )\n{\n\tif ( !m_pSock )\n\t{\n\t\tAssert( false );\n\t\treturn false;\n\t}\n\n\tconst SteamNetworkingIPAddr *pBoundAddr = m_pSock->GetBoundAddr();\n\tif ( !pBoundAddr )\n\t\treturn false;\n\tif ( pAddress )\n\t\t*pAddress = *pBoundAddr;\n\treturn true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n//\n// CSteamNetworkListenSocketUDP packet handling\n//\n/////////////////////////////////////////////////////////////////////////////\n\nvoid CSteamNetworkListenSocketDirectUDP::ReceivedFromUnknownHost( const void *pvPkt, int cbPkt, const netadr_t &adrFrom, CSteamNetworkListenSocketDirectUDP *pSock )\n{\n\tconst uint8 *pPkt = static_cast<const uint8 *>( pvPkt );\n\n\tSteamNetworkingMicroseconds usecNow = SteamNetworkingSockets_GetLocalTimestamp();\n\n\tif ( cbPkt < 5 )\n\t{\n\t\tReportBadPacket( \"packet\", \"%d byte packet is too small\", cbPkt );\n\t\treturn;\n\t}\n\n\tif ( *pPkt & 0x80 )\n\t{\n\t\tif ( *(uint32*)pPkt == 0xffffffff )\n\t\t{\n\t\t\t// Source engine connectionless packet (LAN discovery, etc).\n\t\t\t// Just ignore it, and don't even spew.\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// A stray data packet.  Just ignore it.\n\t\t\t//\n\t\t\t// When clients are able to actually establish a connection, after that connection\n\t\t\t// is over we will use the FinWait state to close down the connection gracefully.\n\t\t\t// But since we don't have that connection in our table anymore, either this guy\n\t\t\t// never had a connection, or else we believe he knows that the connection was closed,\n\t\t\t// or the FinWait state has timed out.\n\t\t\tReportBadPacket( \"Data\", \"Stray data packet from host with no connection.  Ignoring.\" );\n\t\t}\n\t}\n\telse if ( *pPkt == k_ESteamNetworkingUDPMsg_ChallengeRequest )\n\t{\n\t\tParsePaddedPacket( pvPkt, cbPkt, CMsgSteamSockets_UDP_ChallengeRequest, msg )\n\t\tpSock->Received_ChallengeRequest( msg, adrFrom, usecNow );\n\t}\n\telse if ( *pPkt == k_ESteamNetworkingUDPMsg_ConnectRequest )\n\t{\n\t\tParseProtobufBody( pPkt+1, cbPkt-1, CMsgSteamSockets_UDP_ConnectRequest, msg )\n\t\tpSock->Received_ConnectRequest( msg, adrFrom, cbPkt, usecNow );\n\t}\n\telse if ( *pPkt == k_ESteamNetworkingUDPMsg_ConnectionClosed )\n\t{\n\t\tParsePaddedPacket( pvPkt, cbPkt, CMsgSteamSockets_UDP_ConnectionClosed, msg )\n\t\tpSock->Received_ConnectionClosed( msg, adrFrom, usecNow );\n\t}\n\telse if ( *pPkt == k_ESteamNetworkingUDPMsg_NoConnection )\n\t{\n\t\t// They don't think there's a connection on this address.\n\t\t// We agree -- connection ID doesn't matter.  Nothing else to do.\n\t}\n\telse\n\t{\n\t\t// Any other lead byte is bogus\n\t\t//\n\t\t// Note in particular that these packet types should be ignored:\n\t\t//\n\t\t// k_ESteamNetworkingUDPMsg_ChallengeReply\n\t\t// k_ESteamNetworkingUDPMsg_ConnectOK\n\t\t//\n\t\t// We are not initiating connections, so we shouldn't ever get\n\t\t// those sorts of replies.\n\n\t\tReportBadPacket( \"packet\", \"Invalid lead byte 0x%02x\", *pPkt );\n\t}\n}\n\nuint64 CSteamNetworkListenSocketDirectUDP::GenerateChallenge( uint16 nTime, const netadr_t &adr ) const\n{\n\t#pragma pack(push,1)\n\tstruct\n\t{\n\t\tuint16 nTime;\n\t\tuint16 nPort;\n\t\tuint8 ipv6[16];\n\t} data;\n\t#pragma pack(pop)\n\tdata.nTime = nTime;\n\tdata.nPort = adr.GetPort();\n\tadr.GetIPV6( data.ipv6 );\n\tuint64 nChallenge = siphash( (const uint8_t *)&data, sizeof(data), m_argbChallengeSecret );\n\treturn ( nChallenge & 0xffffffffffff0000ull ) | nTime;\n}\n\ninline uint16 GetChallengeTime( SteamNetworkingMicroseconds usecNow )\n{\n\treturn uint16( usecNow >> 20 );\n}\n\nvoid CSteamNetworkListenSocketDirectUDP::Received_ChallengeRequest( const CMsgSteamSockets_UDP_ChallengeRequest &msg, const netadr_t &adrFrom, SteamNetworkingMicroseconds usecNow )\n{\n\tif ( msg.connection_id() == 0 )\n\t{\n\t\tReportBadPacket( \"ChallengeRequest\", \"Missing connection_id.\" );\n\t\treturn;\n\t}\n\t//CSteamID steamIDClient( uint64( msg.client_steam_id() ) );\n\t//if ( !steamIDClient.IsValid() )\n\t//{\n\t//\tReportBadPacket( \"ChallengeRequest\", \"Missing/invalid SteamID.\", cbPkt );\n\t//\treturn;\n\t//}\n\n\t// Get time value of challenge\n\tuint16 nTime = GetChallengeTime( usecNow );\n\n\t// Generate a challenge\n\tuint64 nChallenge = GenerateChallenge( nTime, adrFrom );\n\n\t// Send them a reply\n\tCMsgSteamSockets_UDP_ChallengeReply msgReply;\n\tmsgReply.set_connection_id( msg.connection_id() );\n\tmsgReply.set_challenge( nChallenge );\n\tmsgReply.set_your_timestamp( msg.my_timestamp() );\n\tmsgReply.set_protocol_version( k_nCurrentProtocolVersion );\n\tSendMsg( k_ESteamNetworkingUDPMsg_ChallengeReply, msgReply, adrFrom );\n}\n\nvoid CSteamNetworkListenSocketDirectUDP::Received_ConnectRequest( const CMsgSteamSockets_UDP_ConnectRequest &msg, const netadr_t &adrFrom, int cbPkt, SteamNetworkingMicroseconds usecNow )\n{\n\tSteamDatagramErrMsg errMsg;\n\n\t// Make sure challenge was generated relatively recently\n\tuint16 nTimeThen = uint32( msg.challenge() );\n\tuint16 nElapsed = GetChallengeTime( usecNow ) - nTimeThen;\n\tif ( nElapsed > GetChallengeTime( 4*k_nMillion ) )\n\t{\n\t\tReportBadPacket( \"ConnectRequest\", \"Challenge too old.\" );\n\t\treturn;\n\t}\n\n\t// Assuming we sent them this time value, re-create the challenge we would have sent them.\n\tif ( GenerateChallenge( nTimeThen, adrFrom ) != msg.challenge() )\n\t{\n\t\tReportBadPacket( \"ConnectRequest\", \"Incorrect challenge.  Could be spoofed.\" );\n\t\treturn;\n\t}\n\n\tuint32 unClientConnectionID = msg.client_connection_id();\n\tif ( unClientConnectionID == 0 )\n\t{\n\t\tReportBadPacket( \"ConnectRequest\", \"Missing connection ID\" );\n\t\treturn;\n\t}\n\n\t// Parse out identity from the cert\n\tSteamNetworkingIdentity identityRemote;\n\tbool bIdentityInCert = true;\n\t{\n\t\t// !SPEED! We are deserializing the cert here,\n\t\t// and then we are going to do it again below.\n\t\t// Should refactor to fix this.\n\t\tint r = SteamNetworkingIdentityFromSignedCert( identityRemote, msg.cert(), errMsg );\n\t\tif ( r < 0 )\n\t\t{\n\t\t\tReportBadPacket( \"ConnectRequest\", \"Bad identity in cert.  %s\", errMsg );\n\t\t\treturn;\n\t\t}\n\t\tif ( r == 0 )\n\t\t{\n\t\t\t// No identity in the cert.  Check if they put it directly in the connect message\n\t\t\tbIdentityInCert = false;\n\t\t\tr = SteamNetworkingIdentityFromProtobuf( identityRemote, msg, identity_string, legacy_identity_binary, legacy_client_steam_id, errMsg );\n\t\t\tif ( r < 0 )\n\t\t\t{\n\t\t\t\tReportBadPacket( \"ConnectRequest\", \"Bad identity.  %s\", errMsg );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( r == 0 )\n\t\t\t{\n\t\t\t\t// If no identity was presented, it's the same as them saying they are \"localhost\"\n\t\t\t\tidentityRemote.SetLocalHost();\n\t\t\t}\n\t\t}\n\t}\n\tAssert( !identityRemote.IsInvalid() );\n\n\t// Check if they are using an IP address as an identity (possibly the anonymous \"localhost\" identity)\n\tif ( identityRemote.m_eType == k_ESteamNetworkingIdentityType_IPAddress )\n\t{\n\t\tSteamNetworkingIPAddr addr;\n\t\tadrFrom.GetIPV6( addr.m_ipv6 );\n\t\taddr.m_port = adrFrom.GetPort();\n\n\t\tif ( identityRemote.IsLocalHost() )\n\t\t{\n\t\t\tif ( m_connectionConfig.m_IP_AllowWithoutAuth.Get() == 0 )\n\t\t\t{\n\t\t\t\t// Should we send an explicit rejection here?\n\t\t\t\tReportBadPacket( \"ConnectRequest\", \"Unauthenticated connections not allowed.\" );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set their identity to their real address (including port)\n\t\t\tidentityRemote.SetIPAddr( addr );\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// FIXME - Should the address be required to match?\n\t\t\t// If we are behind NAT, it won't.\n\t\t\t//if ( memcmp( addr.m_ipv6, identityRemote.m_ip.m_ipv6, sizeof(addr.m_ipv6) ) != 0\n\t\t\t//\t|| ( identityRemote.m_ip.m_port != 0 && identityRemote.m_ip.m_port != addr.m_port ) ) // Allow 0 port in the identity to mean \"any port\"\n\t\t\t//{\n\t\t\t//\tReportBadPacket( \"ConnectRequest\", \"Identity in request is %s, but packet is coming from %s.\" );\n\t\t\t//\treturn;\n\t\t\t//}\n\n\t\t\t// It's not really clear what the use case is here for\n\t\t\t// requesting a specific IP address as your identity,\n\t\t\t// and not using localhost.  If they have a cert, assume it's\n\t\t\t// meaningful.  Remember: the cert could be unsigned!  That\n\t\t\t// is a separate issue which will be handled later, whether\n\t\t\t// we want to allow that.\n\t\t\tif ( !bIdentityInCert )\n\t\t\t{\n\t\t\t\t// Should we send an explicit rejection here?\n\t\t\t\tReportBadPacket( \"ConnectRequest\", \"Cannot use specific IP address.\" );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Does this connection already exist?  (At a different address?)\n\tint h = m_mapChildConnections.Find( RemoteConnectionKey_t{ identityRemote, unClientConnectionID } );\n\tif ( h != m_mapChildConnections.InvalidIndex() )\n\t{\n\t\tCSteamNetworkConnectionBase *pOldConn = m_mapChildConnections[ h ];\n\t\tAssert( pOldConn->m_identityRemote == identityRemote );\n\n\t\t// NOTE: We cannot just destroy the object.  The API semantics\n\t\t// are that all connections, once accepted and made visible\n\t\t// to the API, must be closed by the application.\n\t\tReportBadPacket( \"ConnectRequest\", \"Rejecting connection request from %s at %s, connection ID %u.  That steamID/ConnectionID pair already has a connection [%s]\\n\",\n\t\t\tSteamNetworkingIdentityRender( identityRemote ).c_str(), CUtlNetAdrRender( adrFrom ).String(), unClientConnectionID, pOldConn->GetDescription()\n\t\t);\n\n\t\tCMsgSteamSockets_UDP_ConnectionClosed msgReply;\n\t\tmsgReply.set_to_connection_id( unClientConnectionID );\n\t\tmsgReply.set_reason_code( k_ESteamNetConnectionEnd_Misc_Generic );\n\t\tmsgReply.set_debug( \"A connection with that ID already exists.\" );\n\t\tSendPaddedMsg( k_ESteamNetworkingUDPMsg_ConnectionClosed, msgReply, adrFrom );\n\t\treturn;\n\t}\n\n\tCSteamNetworkConnectionUDP *pConn = new CSteamNetworkConnectionUDP( m_pSteamNetworkingSocketsInterface );\n\n\t// OK, they have completed the handshake.  Accept the connection.\n\tif ( !pConn->BBeginAccept( this, adrFrom, m_pSock, identityRemote, unClientConnectionID, msg.cert(), msg.crypt(), errMsg ) )\n\t{\n\t\tSpewWarning( \"Failed to accept connection from %s.  %s\\n\", CUtlNetAdrRender( adrFrom ).String(), errMsg );\n\t\tpConn->ConnectionDestroySelfNow();\n\t\treturn;\n\t}\n\n\tpConn->m_statsEndToEnd.TrackRecvPacket( cbPkt, usecNow );\n\n\t// Did they send us a ping estimate?\n\tif ( msg.has_ping_est_ms() )\n\t{\n\t\tif ( msg.ping_est_ms() > 1500 )\n\t\t{\n\t\t\tSpewWarning( \"[%s] Ignoring really large ping estimate %u in connect request\", pConn->GetDescription(), msg.has_ping_est_ms() );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpConn->m_statsEndToEnd.m_ping.ReceivedPing( msg.ping_est_ms(), usecNow );\n\t\t}\n\t}\n\n\t// Save of timestamp that we will use to reply to them when the application\n\t// decides to accept the connection\n\tif ( msg.has_my_timestamp() )\n\t{\n\t\tpConn->m_ulHandshakeRemoteTimestamp = msg.my_timestamp();\n\t\tpConn->m_usecWhenReceivedHandshakeRemoteTimestamp = usecNow;\n\t}\n}\n\nvoid CSteamNetworkListenSocketDirectUDP::Received_ConnectionClosed( const CMsgSteamSockets_UDP_ConnectionClosed &msg, const netadr_t &adrFrom, SteamNetworkingMicroseconds usecNow )\n{\n\t// Send an ack.  Note that we require the inbound message to be padded\n\t// to a minimum size, and this reply is tiny, so we are not at a risk of\n\t// being used for reflection, even though the source address could be spoofed.\n\tCMsgSteamSockets_UDP_NoConnection msgReply;\n\tif ( msg.from_connection_id() )\n\t\tmsgReply.set_to_connection_id( msg.from_connection_id() );\n\tif ( msg.to_connection_id() )\n\t\tmsgReply.set_from_connection_id( msg.to_connection_id() );\n\tSendMsg( k_ESteamNetworkingUDPMsg_NoConnection, msgReply, adrFrom );\n}\n\nvoid CSteamNetworkListenSocketDirectUDP::SendMsg( uint8 nMsgID, const google::protobuf::MessageLite &msg, const netadr_t &adrTo )\n{\n\tif ( !m_pSock )\n\t{\n\t\tAssert( false );\n\t\treturn;\n\t}\n\n\tuint8 pkt[ k_cbSteamNetworkingSocketsMaxUDPMsgLen ];\n\tpkt[0] = nMsgID;\n\tint cbPkt = ProtoMsgByteSize( msg )+1;\n\tif ( cbPkt > sizeof(pkt) )\n\t{\n\t\tAssertMsg3( false, \"Msg type %d is %d bytes, larger than MTU of %d bytes\", int( nMsgID ), int( cbPkt ), (int)sizeof(pkt) );\n\t\treturn;\n\t}\n\tuint8 *pEnd = msg.SerializeWithCachedSizesToArray( pkt+1 );\n\tAssert( cbPkt == pEnd - pkt );\n\n\t// Send the reply\n\tm_pSock->BSendRawPacket( pkt, cbPkt, adrTo );\n}\n\nvoid CSteamNetworkListenSocketDirectUDP::SendPaddedMsg( uint8 nMsgID, const google::protobuf::MessageLite &msg, const netadr_t adrTo )\n{\n\n\tuint8 pkt[ k_cbSteamNetworkingSocketsMaxUDPMsgLen ];\n\tmemset( pkt, 0, sizeof(pkt) ); // don't send random bits from our process memory over the wire!\n\tUDPPaddedMessageHdr *hdr = (UDPPaddedMessageHdr *)pkt;\n\tint nMsgLength = ProtoMsgByteSize( msg );\n\thdr->m_nMsgID = nMsgID;\n\thdr->m_nMsgLength = LittleWord( uint16( nMsgLength ) );\n\tuint8 *pEnd = msg.SerializeWithCachedSizesToArray( pkt + sizeof(*hdr) );\n\tint cbPkt = pEnd - pkt;\n\tAssert( cbPkt == int( sizeof(*hdr) + nMsgLength ) );\n\tcbPkt = MAX( cbPkt, k_cbSteamNetworkingMinPaddedPacketSize );\n\n\tm_pSock->BSendRawPacket( pkt, cbPkt, adrTo );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n//\n// CConnectionTransportUDPBase\n//\n/////////////////////////////////////////////////////////////////////////////\n\nCConnectionTransportUDPBase::CConnectionTransportUDPBase( CSteamNetworkConnectionBase &connection )\n: CConnectionTransport( connection )\n{\n}\n\nbool CConnectionTransportUDPBase::SendDataPacket( SteamNetworkingMicroseconds usecNow )\n{\n\t// Populate context struct with any stats we want/need to send, and how much space we need to reserve for it\n\tUDPSendPacketContext_t ctx( usecNow, \"data\" );\n\tctx.Populate( sizeof(UDPDataMsgHdr), k_EStatsReplyRequest_NothingToSend, this );\n\n\t// Send a packet\n\treturn m_connection.SNP_SendPacket( this, ctx );\n}\n\nint CConnectionTransportUDPBase::SendEncryptedDataChunk( const void *pChunk, int cbChunk, SendPacketContext_t &ctxBase )\n{\n\tUDPSendPacketContext_t &ctx = static_cast<UDPSendPacketContext_t &>( ctxBase );\n\n\tuint8 pkt[ k_cbSteamNetworkingSocketsMaxUDPMsgLen ];\n\tUDPDataMsgHdr *hdr = (UDPDataMsgHdr *)pkt;\n\thdr->m_unMsgFlags = 0x80;\n\tAssert( m_connection.m_unConnectionIDRemote != 0 );\n\thdr->m_unToConnectionID = LittleDWord( m_connection.m_unConnectionIDRemote );\n\thdr->m_unSeqNum = LittleWord( m_connection.m_statsEndToEnd.ConsumeSendPacketNumberAndGetWireFmt( ctx.m_usecNow ) );\n\n\tbyte *p = (byte*)( hdr + 1 );\n\n\t// Check how much bigger we could grow the header\n\t// and still fit in a packet\n\tint cbHdrOutSpaceRemaining = pkt + sizeof(pkt) - p - cbChunk;\n\tif ( cbHdrOutSpaceRemaining < 0 )\n\t{\n\t\tAssertMsg( false, \"MTU / header size problem!\" );\n\t\treturn 0;\n\t}\n\n\t// Try to trim stuff from blob, if it won't fit\n\tctx.Trim( cbHdrOutSpaceRemaining );\n\n\tif ( ctx.Serialize( p ) )\n\t{\n\t\t// Update bookkeeping with the stuff we are actually sending\n\t\tTrackSentStats( ctx );\n\n\t\t// Mark header with the flag\n\t\thdr->m_unMsgFlags |= hdr->kFlag_ProtobufBlob;\n\t}\n\n\t// !FIXME! Time since previous, for jitter measurement?\n\n\t// Use gather-based send.  This saves one memcpy of every payload\n\tiovec gather[2];\n\tgather[0].iov_base = pkt;\n\tgather[0].iov_len = p - pkt;\n\tgather[1].iov_base = const_cast<void*>( pChunk );\n\tgather[1].iov_len = cbChunk;\n\n\tint cbSend = gather[0].iov_len + gather[1].iov_len;\n\tAssert( cbSend <= sizeof(pkt) ); // Bug in the code above.  We should never \"overflow\" the packet.  (Ignoring the fact that we using a gather-based send.  The data could be tiny with a large header for piggy-backed stats.)\n\n\t// !FIXME! Should we track data payload separately?  Maybe we ought to track\n\t// *messages* instead of packets.\n\n\t// Send it\n\tif ( SendPacketGather( 2, gather, cbSend ) )\n\t\treturn cbSend;\n\treturn 0;\n}\n\nstd::string DescribeStatsContents( const CMsgSteamSockets_UDP_Stats &msg )\n{\n\tstd::string sWhat;\n\tif ( msg.flags() & msg.ACK_REQUEST_E2E )\n\t\tsWhat += \" request_ack\";\n\tif ( msg.flags() & msg.ACK_REQUEST_IMMEDIATE )\n\t\tsWhat += \" request_ack_immediate\";\n\tif ( msg.flags() & msg.NOT_PRIMARY_TRANSPORT_E2E )\n\t\tsWhat += \" backup_transport\";\n\tif ( msg.stats().has_lifetime() )\n\t\tsWhat += \" stats.life\";\n\tif ( msg.stats().has_instantaneous() )\n\t\tsWhat += \" stats.rate\";\n\treturn sWhat;\n}\n\nvoid CConnectionTransportUDPBase::RecvStats( const CMsgSteamSockets_UDP_Stats &msgStatsIn, SteamNetworkingMicroseconds usecNow )\n{\n\n\t// Connection quality stats?\n\tif ( msgStatsIn.has_stats() )\n\t\tm_connection.m_statsEndToEnd.ProcessMessage( msgStatsIn.stats(), usecNow );\n\n\t// Spew appropriately\n\tSpewVerbose( \"[%s] Recv UDP stats:%s\\n\",\n\t\tConnectionDescription(),\n\t\tDescribeStatsContents( msgStatsIn ).c_str()\n\t);\n\n\t// Check if we need to reply, either now or later\n\tif ( m_connection.BStateIsActive() )\n\t{\n\n\t\t// Check for queuing outgoing acks\n\t\tif ( ( msgStatsIn.flags() & msgStatsIn.ACK_REQUEST_E2E ) || msgStatsIn.has_stats() )\n\t\t{\n\t\t\tbool bImmediate = ( msgStatsIn.flags() & msgStatsIn.ACK_REQUEST_IMMEDIATE ) != 0;\n\t\t\tm_connection.QueueEndToEndAck( bImmediate, usecNow );\n\n\t\t\t// Check if need to send an immediately reply, either because they\n\t\t\t// requested it, or because we are not the currently selected transport,\n\t\t\t// and we need to need to make sure the reply goes out using us\n\t\t\tif ( bImmediate || m_connection.m_pTransport != this )\n\t\t\t{\n\t\t\t\tSendEndToEndStatsMsg( k_EStatsReplyRequest_NothingToSend, usecNow, \"AckStats\" );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid CConnectionTransportUDPBase::TrackSentStats( UDPSendPacketContext_t &ctx )\n{\n\n\t// What effective flags will be received?\n\tbool bAllowDelayedReply = ( ctx.msg.flags() & ctx.msg.ACK_REQUEST_IMMEDIATE ) == 0;\n\n\t// Record that we sent stats and are waiting for peer to ack\n\tif ( ctx.msg.has_stats() )\n\t{\n\t\tm_connection.m_statsEndToEnd.TrackSentStats( ctx.msg.stats(), ctx.m_usecNow, bAllowDelayedReply );\n\t}\n\telse if ( ctx.msg.flags() & ctx.msg.ACK_REQUEST_E2E )\n\t{\n\t\tm_connection.m_statsEndToEnd.TrackSentMessageExpectingSeqNumAck( ctx.m_usecNow, bAllowDelayedReply );\n\t}\n\n\t// Spew appropriately\n\tSpewVerbose( \"[%s] Sent UDP stats (%s):%s\\n\",\n\t\tConnectionDescription(),\n\t\tctx.m_pszReason,\n\t\tDescribeStatsContents( ctx.msg ).c_str()\n\t);\n}\n\nvoid CConnectionTransportUDPBase::Received_Data( const uint8 *pPkt, int cbPkt, SteamNetworkingMicroseconds usecNow )\n{\n\n\tif ( cbPkt < sizeof(UDPDataMsgHdr) )\n\t{\n\t\tReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"Packet of size %d is too small.\", cbPkt );\n\t\treturn;\n\t}\n\n\t// Check cookie\n\tconst UDPDataMsgHdr *hdr = (const UDPDataMsgHdr *)pPkt;\n\tif ( LittleDWord( hdr->m_unToConnectionID ) != ConnectionIDLocal() )\n\t{\n\n\t\t// Wrong session.  It could be an old session, or it could be spoofed.\n\t\tReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"Incorrect connection ID\" );\n\t\tif ( BCheckGlobalSpamReplyRateLimit( usecNow ) )\n\t\t{\n\t\t\tSendNoConnection( LittleDWord( hdr->m_unToConnectionID ), 0 );\n\t\t}\n\t\treturn;\n\t}\n\tuint16 nWirePktNumber = LittleWord( hdr->m_unSeqNum );\n\n\t// Check state\n\tswitch ( ConnectionState() )\n\t{\n\t\tcase k_ESteamNetworkingConnectionState_Dead:\n\t\tcase k_ESteamNetworkingConnectionState_None:\n\t\tdefault:\n\t\t\tAssert( false );\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_ClosedByPeer:\n\t\tcase k_ESteamNetworkingConnectionState_FinWait:\n\t\tcase k_ESteamNetworkingConnectionState_ProblemDetectedLocally:\n\t\t\tSendConnectionClosedOrNoConnection();\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_Connecting:\n\t\t\t// Ignore it.  We don't have the SteamID of whoever is on the other end yet,\n\t\t\t// their encryption keys, etc.  The most likely cause is that a server sent\n\t\t\t// a ConnectOK, which dropped.  So they think we're connected but we don't\n\t\t\t// have everything yet.\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_Linger:\n\t\tcase k_ESteamNetworkingConnectionState_Connected:\n\t\tcase k_ESteamNetworkingConnectionState_FindingRoute: // not used for raw UDP, but might be used for derived class\n\n\t\t\t// We'll process the chunk\n\t\t\tbreak;\n\t}\n\n\tconst uint8 *pIn = pPkt + sizeof(*hdr);\n\tconst uint8 *pPktEnd = pPkt + cbPkt;\n\n\t// Inline stats?\n\tstatic CMsgSteamSockets_UDP_Stats msgStats;\n\tCMsgSteamSockets_UDP_Stats *pMsgStatsIn = nullptr;\n\tuint32 cbStatsMsgIn = 0;\n\tif ( hdr->m_unMsgFlags & hdr->kFlag_ProtobufBlob )\n\t{\n\t\t//Msg_Verbose( \"Received inline stats from %s\", server.m_szName );\n\n\t\tpIn = DeserializeVarInt( pIn, pPktEnd, cbStatsMsgIn );\n\t\tif ( pIn == NULL )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"Failed to varint decode size of stats blob\" );\n\t\t\treturn;\n\t\t}\n\t\tif ( cbStatsMsgIn > pPktEnd - pIn )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"stats message size doesn't make sense.  Stats message size %u, packet size %d\", cbStatsMsgIn, cbPkt );\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !msgStats.ParseFromArray( pIn, cbStatsMsgIn ) )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"protobuf failed to parse inline stats message\" );\n\t\t\treturn;\n\t\t}\n\n\t\t// Shove sequence number so we know what acks to pend, etc\n\t\tpMsgStatsIn = &msgStats;\n\n\t\t// Advance pointer\n\t\tpIn += cbStatsMsgIn;\n\t}\n\n\tconst void *pChunk = pIn;\n\tint cbChunk = pPktEnd - pIn;\n\n\t// Decrypt it, and check packet number\n\tUDPRecvPacketContext_t ctx;\n\tctx.m_usecNow = usecNow;\n\tctx.m_pTransport = this;\n\tctx.m_pStatsIn = pMsgStatsIn;\n\tif ( !m_connection.DecryptDataChunk( nWirePktNumber, cbPkt, pChunk, cbChunk, ctx ) )\n\t\treturn;\n\n\t// This is a valid packet.  P2P connections might want to make a note of this\n\tRecvValidUDPDataPacket( ctx );\n\n\t// Process plaintext\n\tint usecTimeSinceLast = 0; // FIXME - should we plumb this through so we can measure jitter?\n\tif ( !m_connection.ProcessPlainTextDataChunk( usecTimeSinceLast, ctx ) )\n\t\treturn;\n\n\t// Process the stats, if any\n\tif ( pMsgStatsIn )\n\t\tRecvStats( *pMsgStatsIn, usecNow );\n}\n\nvoid CConnectionTransportUDPBase::RecvValidUDPDataPacket( UDPRecvPacketContext_t &ctx )\n{\n\t// Base class doesn't care\n}\n\nvoid CConnectionTransportUDPBase::SendEndToEndStatsMsg( EStatsReplyRequest eRequest, SteamNetworkingMicroseconds usecNow, const char *pszReason )\n{\n\tUDPSendPacketContext_t ctx( usecNow, pszReason );\n\tctx.Populate( sizeof(UDPDataMsgHdr), eRequest, this );\n\n\t// Send a data packet (maybe containing ordinary data), with this piggy backed on top of it\n\tm_connection.SNP_SendPacket( this, ctx );\n}\n\nvoid CConnectionTransportUDPBase::SendConnectionClosedOrNoConnection()\n{\n\tif ( ConnectionWireState() == k_ESteamNetworkingConnectionState_ClosedByPeer )\n\t{\n\t\tSendNoConnection( ConnectionIDLocal(), ConnectionIDRemote() );\n\t}\n\telse\n\t{\n\t\tCMsgSteamSockets_UDP_ConnectionClosed msg;\n\t\tmsg.set_from_connection_id( ConnectionIDLocal() );\n\n\t\tif ( ConnectionIDRemote() )\n\t\t\tmsg.set_to_connection_id( ConnectionIDRemote() );\n\n\t\tmsg.set_reason_code( m_connection.m_eEndReason );\n\t\tif ( m_connection.m_szEndDebug[0] )\n\t\t\tmsg.set_debug( m_connection.m_szEndDebug );\n\t\tSendPaddedMsg( k_ESteamNetworkingUDPMsg_ConnectionClosed, msg );\n\t}\n}\n\nvoid CConnectionTransportUDPBase::SendNoConnection( uint32 unFromConnectionID, uint32 unToConnectionID )\n{\n\tCMsgSteamSockets_UDP_NoConnection msg;\n\tif ( unFromConnectionID == 0 && unToConnectionID == 0 )\n\t{\n\t\tAssertMsg( false, \"Can't send NoConnection, we need at least one of from/to connection ID!\" );\n\t\treturn;\n\t}\n\tif ( unFromConnectionID )\n\t\tmsg.set_from_connection_id( unFromConnectionID );\n\tif ( unToConnectionID )\n\t\tmsg.set_to_connection_id( unToConnectionID );\n\tSendMsg( k_ESteamNetworkingUDPMsg_NoConnection, msg );\n}\n\nvoid CConnectionTransportUDPBase::SendMsg( uint8 nMsgID, const google::protobuf::MessageLite &msg )\n{\n\n\tuint8 pkt[ k_cbSteamNetworkingSocketsMaxUDPMsgLen ];\n\tpkt[0] = nMsgID;\n\tint cbPkt = ProtoMsgByteSize( msg )+1;\n\tif ( cbPkt > sizeof(pkt) )\n\t{\n\t\tAssertMsg3( false, \"Msg type %d is %d bytes, larger than MTU of %d bytes\", int( nMsgID ), int( cbPkt ), (int)sizeof(pkt) );\n\t\treturn;\n\t}\n\tuint8 *pEnd = msg.SerializeWithCachedSizesToArray( pkt+1 );\n\tAssert( cbPkt == pEnd - pkt );\n\n\tSendPacket( pkt, cbPkt );\n}\n\nvoid CConnectionTransportUDPBase::SendPaddedMsg( uint8 nMsgID, const google::protobuf::MessageLite &msg )\n{\n\n\tuint8 pkt[ k_cbSteamNetworkingSocketsMaxUDPMsgLen ];\n\tV_memset( pkt, 0, sizeof(pkt) ); // don't send random bits from our process memory over the wire!\n\tUDPPaddedMessageHdr *hdr = (UDPPaddedMessageHdr *)pkt;\n\tint nMsgLength = ProtoMsgByteSize( msg );\n\tif ( nMsgLength + sizeof(*hdr) > k_cbSteamNetworkingSocketsMaxUDPMsgLen )\n\t{\n\t\tAssertMsg3( false, \"Msg type %d is %d bytes, larger than MTU of %d bytes\", int( nMsgID ), int( nMsgLength + sizeof(*hdr) ), (int)sizeof(pkt) );\n\t\treturn;\n\t}\n\thdr->m_nMsgID = nMsgID;\n\thdr->m_nMsgLength = LittleWord( uint16( nMsgLength ) );\n\tuint8 *pEnd = msg.SerializeWithCachedSizesToArray( pkt + sizeof(*hdr) );\n\tint cbPkt = pEnd - pkt;\n\tAssert( cbPkt == int( sizeof(*hdr) + nMsgLength ) );\n\tcbPkt = MAX( cbPkt, k_cbSteamNetworkingMinPaddedPacketSize );\n\n\tSendPacket( pkt, cbPkt );\n}\n\nvoid CConnectionTransportUDPBase::Received_ConnectionClosed( const CMsgSteamSockets_UDP_ConnectionClosed &msg, SteamNetworkingMicroseconds usecNow )\n{\n\t// Give them a reply to let them know we heard from them.  If it's the right connection ID,\n\t// then they probably aren't spoofing and it's critical that we give them an ack!\n\t//\n\t// If the wrong connection ID, then it could be an old connection so we'd like to send a reply\n\t// to let them know that they can stop telling us the connection is closed.\n\t// However, it could just be random garbage, so we need to protect ourselves from abuse,\n\t// so limit how many of these we send.\n\tbool bConnectionIDMatch =\n\t\tmsg.to_connection_id() == ConnectionIDLocal()\n\t\t|| ( msg.to_connection_id() == 0 && msg.from_connection_id() && msg.from_connection_id() == m_connection.m_unConnectionIDRemote ); // they might not know our ID yet, if they are a client aborting the connection really early.\n\tif ( bConnectionIDMatch || BCheckGlobalSpamReplyRateLimit( usecNow ) )\n\t{\n\t\t// Send a reply, echoing exactly what they sent to us\n\t\tCMsgSteamSockets_UDP_NoConnection msgReply;\n\t\tif ( msg.to_connection_id() )\n\t\t\tmsgReply.set_from_connection_id( msg.to_connection_id() );\n\t\tif ( msg.from_connection_id() )\n\t\t\tmsgReply.set_to_connection_id( msg.from_connection_id() );\n\t\tSendMsg( k_ESteamNetworkingUDPMsg_NoConnection, msgReply );\n\t}\n\n\t// If incorrect connection ID, then that's all we'll do, since this packet actually\n\t// has nothing to do with current connection at all.\n\tif ( !bConnectionIDMatch )\n\t\treturn;\n\n\t// Generic connection code will take it from here.\n\tm_connection.ConnectionState_ClosedByPeer( msg.reason_code(), msg.debug().c_str() );\n}\n\nvoid CConnectionTransportUDPBase::Received_NoConnection( const CMsgSteamSockets_UDP_NoConnection &msg, SteamNetworkingMicroseconds usecNow )\n{\n\t// Make sure it's an ack of something we would have sent\n\tif ( msg.to_connection_id() != ConnectionIDLocal() || msg.from_connection_id() != m_connection.m_unConnectionIDRemote )\n\t{\n\t\tReportBadUDPPacketFromConnectionPeer( \"NoConnection\", \"Old/incorrect connection ID.  Message is for a stale connection, or is spoofed.  Ignoring.\" );\n\t\treturn;\n\t}\n\n\t// Generic connection code will take it from here.\n\t// Closure failure code will only be used if this is news.\n\t// If we closed the connection (the usual case), it\n\t// will not be used.\n\tm_connection.ConnectionState_ClosedByPeer( k_ESteamNetConnectionEnd_Misc_PeerSentNoConnection, \"Received unexpected 'no connection' from peer\");\n}\n\n/////////////////////////////////////////////////////////////////////////////\n//\n// IP connections\n//\n/////////////////////////////////////////////////////////////////////////////\n\nCSteamNetworkConnectionUDP::CSteamNetworkConnectionUDP( CSteamNetworkingSockets *pSteamNetworkingSocketsInterface )\n: CSteamNetworkConnectionBase( pSteamNetworkingSocketsInterface )\n{\n}\n\nCSteamNetworkConnectionUDP::~CSteamNetworkConnectionUDP()\n{\n}\n\nCConnectionTransportUDP::CConnectionTransportUDP( CSteamNetworkConnectionUDP &connection )\n: CConnectionTransportUDPBase( connection )\n, m_pSocket( nullptr )\n{\n}\n\nCConnectionTransportUDP::~CConnectionTransportUDP()\n{\n\tAssert( !m_pSocket ); // Use TransportDestroySelfNow!\n}\n\nvoid CConnectionTransportUDP::TransportFreeResources()\n{\n\tCConnectionTransport::TransportFreeResources();\n\n\tif ( m_pSocket )\n\t{\n\t\tm_pSocket->Close();\n\t\tm_pSocket = nullptr;\n\t}\n}\n\nvoid CSteamNetworkConnectionUDP::GetConnectionTypeDescription( ConnectionTypeDescription_t &szDescription ) const\n{\n\tchar szAddr[ 64 ];\n\tif ( Transport() && Transport()->m_pSocket )\n\t{\n\t\tSteamNetworkingIPAddr adrRemote;\n\t\tNetAdrToSteamNetworkingIPAddr( adrRemote, Transport()->m_pSocket->GetRemoteHostAddr() );\n\t\tadrRemote.ToString( szAddr, sizeof(szAddr), true );\n\t\tif (\n\t\t\tm_identityRemote.IsLocalHost()\n\t\t\t|| ( m_identityRemote.m_eType == k_ESteamNetworkingIdentityType_IPAddress && adrRemote == m_identityRemote.m_ip )\n\t\t) {\n\t\t\tV_sprintf_safe( szDescription, \"UDP %s\", szAddr );\n\t\t\treturn;\n\t\t}\n\t}\n\telse\n\t{\n\t\tV_strcpy_safe( szAddr, \"???\" );\n\t}\n\n\tSteamNetworkingIdentityRender sIdentity( m_identityRemote );\n\n\tV_sprintf_safe( szDescription, \"UDP %s@%s\", sIdentity.c_str(), szAddr );\n}\n\nvoid UDPSendPacketContext_t::Populate( size_t cbHdrtReserve, EStatsReplyRequest eReplyRequested, CConnectionTransportUDPBase *pTransport )\n{\n\tCSteamNetworkConnectionBase &connection = pTransport->m_connection;\n\tLinkStatsTracker<LinkStatsTrackerEndToEnd> &statsEndToEnd = connection.m_statsEndToEnd;\n\n\tint nFlags = 0;\n\tif ( connection.m_pTransport != pTransport )\n\t\tnFlags |= msg.NOT_PRIMARY_TRANSPORT_E2E;\n\n\t// What effective flags should we send\n\tint nReadyToSendTracer = 0;\n\tif ( eReplyRequested == k_EStatsReplyRequest_Immediate || statsEndToEnd.BNeedToSendPingImmediate( m_usecNow ) )\n\t\tnFlags |= msg.ACK_REQUEST_E2E | msg.ACK_REQUEST_IMMEDIATE;\n\telse if ( eReplyRequested == k_EStatsReplyRequest_DelayedOK || statsEndToEnd.BNeedToSendKeepalive( m_usecNow ) )\n\t\tnFlags |= msg.ACK_REQUEST_E2E;\n\telse\n\t{\n\t\tnReadyToSendTracer = statsEndToEnd.ReadyToSendTracerPing( m_usecNow );\n\t\tif ( nReadyToSendTracer > 1 )\n\t\t\tnFlags |= msg.ACK_REQUEST_E2E;\n\t}\n\n\tm_nFlags = nFlags;\n\n\t// Need to send any connection stats stats?\n\tm_nStatsNeed = statsEndToEnd.GetStatsSendNeed( m_usecNow );\n\tif ( m_nStatsNeed & k_nSendStats_Due )\n\t{\n\t\tstatsEndToEnd.PopulateMessage( m_nStatsNeed, *msg.mutable_stats(), m_usecNow );\n\n\t\tif ( nReadyToSendTracer > 0 )\n\t\t\tm_nFlags |= msg.ACK_REQUEST_E2E;\n\t}\n\n\t// Populate flags now, based on what is implied from what we HAVE to send\n\tSlamFlagsAndCalcSize();\n\tCalcMaxEncryptedPayloadSize( cbHdrtReserve, &connection );\n\n\t// Would we like to try to send some additional stats, if there is room?\n\tif ( m_nStatsNeed & k_nSendStats_Ready )\n\t{\n\t\tif ( nReadyToSendTracer > 0 )\n\t\t\tm_nFlags |= msg.ACK_REQUEST_E2E;\n\t\tstatsEndToEnd.PopulateMessage( m_nStatsNeed & k_nSendStats_Ready, *msg.mutable_stats(), m_usecNow );\n\t\tSlamFlagsAndCalcSize();\n\t}\n}\n\nvoid UDPSendPacketContext_t::Trim( int cbHdrOutSpaceRemaining )\n{\n\twhile ( m_cbTotalSize > cbHdrOutSpaceRemaining )\n\t{\n\t\tif ( !msg.has_stats() )\n\t\t{\n\t\t\t// Nothing left to clear!?  We shouldn't get here!\n\t\t\tAssertMsg( false, \"Serialized stats message still won't fit, ever after clearing everything?\" );\n\t\t\tm_cbTotalSize = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ( m_nStatsNeed & k_nSendStats_Instantanous_Ready )\n\t\t{\n\t\t\tmsg.mutable_stats()->clear_instantaneous();\n\t\t\tm_nStatsNeed &= ~k_nSendStats_Instantanous_Ready;\n\t\t}\n\t\telse if ( m_nStatsNeed & k_nSendStats_Lifetime_Ready )\n\t\t{\n\t\t\tmsg.mutable_stats()->clear_lifetime();\n\t\t\tm_nStatsNeed &= ~k_nSendStats_Lifetime_Ready;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tAssertMsg( false, \"We didn't reserve enough space for stats!\" );\n\t\t\tif ( m_nStatsNeed & k_nSendStats_Instantanous_Due )\n\t\t\t{\n\t\t\t\tmsg.mutable_stats()->clear_instantaneous();\n\t\t\t\tm_nStatsNeed &= ~k_nSendStats_Instantanous_Due;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_nStatsNeed = 0;\n\t\t\t}\n\t\t}\n\n\t\tif ( m_nStatsNeed == 0 )\n\t\t\tmsg.clear_stats();\n\n\t\tSlamFlagsAndCalcSize();\n\t}\n}\n\nbool CConnectionTransportUDP::BConnect( const netadr_t &netadrRemote, SteamDatagramErrMsg &errMsg )\n{\n\n\t// Create an actual OS socket.  We'll bind it to talk only to this host.\n\t// (Note: we might not actually \"bind\" it at the OS layer, but from our perpsective\n\t// it is bound.)\n\t//\n\t// For now we're just assuming each connection will gets its own socket,\n\t// on an ephemeral port.  Later we could add a setting to enable\n\t// sharing of the socket or binding to a particular local address.\n\tAssert( !m_pSocket );\n\tm_pSocket = OpenUDPSocketBoundToHost( netadrRemote, CRecvPacketCallback( PacketReceived, this ), errMsg );\n\tif ( !m_pSocket )\n\t\treturn false;\n\treturn true;\n}\n\nbool CConnectionTransportUDP::BAccept( CSharedSocket *pSharedSock, const netadr_t &netadrRemote, SteamDatagramErrMsg &errMsg )\n{\n\t// Get an interface that is bound to talk to this address\n\tm_pSocket = pSharedSock->AddRemoteHost( netadrRemote, CRecvPacketCallback( PacketReceived, this ) );\n\tif ( !m_pSocket )\n\t{\n\t\t// This is really weird and shouldn't happen\n\t\tV_strcpy_safe( errMsg, \"Unable to create a bound socket on the shared socket.\" );\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nbool CConnectionTransportUDP::CreateLoopbackPair( CConnectionTransportUDP *pTransport[2] )\n{\n\tIBoundUDPSocket *sock[2];\n\tSteamNetworkingErrMsg errMsg;\n\tif ( !CreateBoundSocketPair(\n\t\tCRecvPacketCallback( PacketReceived, pTransport[0] ),\n\t\tCRecvPacketCallback( PacketReceived, pTransport[1] ), sock, errMsg ) )\n\t{\n\t\t// Assert, this really should only fail if we have some sort of bug\n\t\tAssertMsg1( false, \"Failed to create UDP socket pair.  %s\", errMsg );\n\t\treturn false;\n\t}\n\n\tpTransport[0]->m_pSocket = sock[0];\n\tpTransport[1]->m_pSocket = sock[1];\n\n\treturn true;\n}\n\nbool CSteamNetworkConnectionUDP::BInitConnect( const SteamNetworkingIPAddr &addressRemote, int nOptions, const SteamNetworkingConfigValue_t *pOptions, SteamDatagramErrMsg &errMsg )\n{\n\tAssertMsg( !m_pTransport, \"Trying to connect when we already have a socket?\" );\n\n\t// We're initiating a connection, not being accepted on a listen socket\n\tAssert( !m_pParentListenSocket );\n\tAssert( !m_bConnectionInitiatedRemotely );\n\n\tnetadr_t netadrRemote;\n\tSteamNetworkingIPAddrToNetAdr( netadrRemote, addressRemote );\n\n\t// We use identity validity to denote when our connection has been accepted,\n\t// so it's important that it be cleared.  (It should already be so.)\n\tAssert( m_identityRemote.IsInvalid() );\n\tm_identityRemote.Clear();\n\n\t// We should know our own identity, unless the app has said it's OK to go without this.\n\tif ( m_identityLocal.IsInvalid() ) // Specific identity hasn't already been set (by derived class, etc)\n\t{\n\n\t\t// Use identity from the interface, if we have one\n\t\tm_identityLocal = m_pSteamNetworkingSocketsInterface->InternalGetIdentity();\n\t\tif ( m_identityLocal.IsInvalid())\n\t\t{\n\n\t\t\t// We don't know who we are.  Should we attempt anonymous?\n\t\t\tif ( m_connectionConfig.m_IP_AllowWithoutAuth.Get() == 0 )\n\t\t\t{\n\t\t\t\tV_strcpy_safe( errMsg, \"Unable to determine local identity, and auth required.  Not logged in?\" );\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tm_identityLocal.SetLocalHost();\n\t\t}\n\t}\n\n\t// Create transport.\n\tCConnectionTransportUDP *pTransport = new CConnectionTransportUDP( *this );\n\tif ( !pTransport->BConnect( netadrRemote, errMsg ) )\n\t{\n\t\tpTransport->TransportDestroySelfNow();\n\t\treturn false;\n\t}\n\tm_pTransport = pTransport;\n\n\t// Let base class do some common initialization\n\tSteamNetworkingMicroseconds usecNow = SteamNetworkingSockets_GetLocalTimestamp();\n\tif ( !CSteamNetworkConnectionBase::BInitConnection( usecNow, nOptions, pOptions, errMsg ) )\n\t{\n\t\tDestroyTransport();\n\t\treturn false;\n\t}\n\n\t// Start the connection state machine\n\treturn BConnectionState_Connecting( usecNow, errMsg );\n}\n\nbool CConnectionTransportUDP::BCanSendEndToEndConnectRequest() const\n{\n\treturn m_pSocket != nullptr;\n}\n\nbool CConnectionTransportUDP::BCanSendEndToEndData() const\n{\n\treturn m_pSocket != nullptr;\n}\n\nvoid CConnectionTransportUDP::SendEndToEndConnectRequest( SteamNetworkingMicroseconds usecNow )\n{\n\tAssert( !ListenSocket() );\n\tAssert( !m_connection.m_bConnectionInitiatedRemotely );\n\tAssert( ConnectionState() == k_ESteamNetworkingConnectionState_Connecting ); // Why else would we be doing this?\n\tAssert( ConnectionIDLocal() );\n\n\tCMsgSteamSockets_UDP_ChallengeRequest msg;\n\tmsg.set_connection_id( ConnectionIDLocal() );\n\t//msg.set_client_steam_id( m_steamIDLocal.ConvertToUint64() );\n\tmsg.set_my_timestamp( usecNow );\n\tmsg.set_protocol_version( k_nCurrentProtocolVersion );\n\n\t// Send it, with padding\n\tSendPaddedMsg( k_ESteamNetworkingUDPMsg_ChallengeRequest, msg );\n\n\t// They are supposed to reply with a timestamps, from which we can estimate the ping.\n\t// So this counts as a ping request\n\tm_connection.m_statsEndToEnd.TrackSentPingRequest( usecNow, false );\n}\n\nbool CSteamNetworkConnectionUDP::BBeginAccept(\n\tCSteamNetworkListenSocketDirectUDP *pParent,\n\tconst netadr_t &adrFrom,\n\tCSharedSocket *pSharedSock,\n\tconst SteamNetworkingIdentity &identityRemote,\n\tuint32 unConnectionIDRemote,\n\tconst CMsgSteamDatagramCertificateSigned &msgCert,\n\tconst CMsgSteamDatagramSessionCryptInfoSigned &msgCryptSessionInfo,\n\tSteamDatagramErrMsg &errMsg\n)\n{\n\tAssertMsg( !m_pTransport, \"Trying to accept when we already have transport?\" );\n\n\t// Setup transport\n\tCConnectionTransportUDP *pTransport = new CConnectionTransportUDP( *this );\n\tif ( !pTransport->BAccept( pSharedSock, adrFrom, errMsg ) )\n\t{\n\t\tpTransport->TransportDestroySelfNow();\n\t\treturn false;\n\t}\n\tm_pTransport = pTransport;\n\n\tm_identityRemote = identityRemote;\n\n\t// Caller should have ensured a valid identity\n\tAssert( !m_identityRemote.IsInvalid() );\n\n\tm_unConnectionIDRemote = unConnectionIDRemote;\n\tif ( !pParent->BAddChildConnection( this, errMsg ) )\n\t\treturn false;\n\n\t// Let base class do some common initialization\n\tSteamNetworkingMicroseconds usecNow = SteamNetworkingSockets_GetLocalTimestamp();\n\tif ( !CSteamNetworkConnectionBase::BInitConnection( usecNow, 0, nullptr, errMsg ) )\n\t{\n\t\tDestroyTransport();\n\t\treturn false;\n\t}\n\n\t// Process crypto handshake now\n\tif ( !BRecvCryptoHandshake( msgCert, msgCryptSessionInfo, true ) )\n\t{\n\t\tDestroyTransport();\n\t\tAssert( GetState() == k_ESteamNetworkingConnectionState_ProblemDetectedLocally );\n\t\tV_sprintf_safe( errMsg, \"Failed crypto init.  %s\", m_szEndDebug );\n\t\treturn false;\n\t}\n\n\t// Start the connection state machine\n\treturn BConnectionState_Connecting( usecNow, errMsg );\n}\n\nEResult CSteamNetworkConnectionUDP::AcceptConnection( SteamNetworkingMicroseconds usecNow )\n{\n\tif ( !Transport() )\n\t{\n\t\tAssertMsg( false, \"Cannot acception UDP connection.  No transport?\" );\n\t\treturn k_EResultFail;\n\t}\n\n\t// Send the message\n\tTransport()->SendConnectOK( usecNow );\n\n\t// We are fully connected\n\tConnectionState_Connected( usecNow );\n\n\t// OK\n\treturn k_EResultOK;\n}\n\nbool CConnectionTransportUDP::SendPacket( const void *pkt, int cbPkt )\n{\n\tiovec temp;\n\ttemp.iov_base = const_cast<void*>( pkt );\n\ttemp.iov_len = cbPkt;\n\treturn SendPacketGather( 1, &temp, cbPkt );\n}\n\nbool CConnectionTransportUDP::SendPacketGather( int nChunks, const iovec *pChunks, int cbSendTotal )\n{\n\t// Safety\n\tif ( !m_pSocket )\n\t{\n\t\tAssertMsg( false, \"Attemt to send packet, but socket has been closed!\" );\n\t\treturn false;\n\t}\n\n\t// Update stats\n\tm_connection.m_statsEndToEnd.TrackSentPacket( cbSendTotal );\n\n\t// Hand over to operating system\n\treturn m_pSocket->BSendRawPacketGather( nChunks, pChunks );\n}\n\nvoid CConnectionTransportUDP::TransportConnectionStateChanged( ESteamNetworkingConnectionState eOldState )\n{\n\tCConnectionTransport::TransportConnectionStateChanged( eOldState );\n\n\tswitch ( ConnectionState() )\n\t{\n\t\tcase k_ESteamNetworkingConnectionState_FindingRoute: // not used for raw UDP\n\t\tdefault:\n\t\t\tAssert( false );\n\t\tcase k_ESteamNetworkingConnectionState_None:\n\t\tcase k_ESteamNetworkingConnectionState_Dead:\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_FinWait:\n\t\tcase k_ESteamNetworkingConnectionState_ProblemDetectedLocally:\n\t\t\tSendConnectionClosedOrNoConnection();\n\t\t\tbreak;\n\n\t\tcase k_ESteamNetworkingConnectionState_Linger:\n\t\t\tbreak;\n\n\t\tcase k_ESteamNetworkingConnectionState_Connecting:\n\t\tcase k_ESteamNetworkingConnectionState_Connected:\n\t\tcase k_ESteamNetworkingConnectionState_ClosedByPeer:\n\t\t\tbreak;\n\t}\n}\n\nvoid CConnectionTransportUDP::TransportPopulateConnectionInfo( SteamNetConnectionInfo_t &info ) const\n{\n\tCConnectionTransport::TransportPopulateConnectionInfo( info );\n\n\tif ( m_pSocket )\n\t{\n\t\tconst netadr_t &addr = m_pSocket->GetRemoteHostAddr();\n\t\tNetAdrToSteamNetworkingIPAddr( info.m_addrRemote, addr );\n\t\tif ( addr.IsLoopback() )\n\t\t\tinfo.m_eTransportKind = k_ESteamNetTransport_LocalHost;\n\t\telse if ( m_connection.m_statsEndToEnd.m_ping.m_nSmoothedPing <= 5 && IsRouteToAddressProbablyLocal( addr ) )\n\t\t\tinfo.m_eTransportKind = k_ESteamNetTransport_UDPProbablyLocal;\n\t\telse\n\t\t\tinfo.m_eTransportKind = k_ESteamNetTransport_UDP;\n\t}\n}\n\nvoid CConnectionTransportUDP::PacketReceived( const void *pvPkt, int cbPkt, const netadr_t &adrFrom, CConnectionTransportUDP *pSelf )\n{\n\tconst uint8 *pPkt = static_cast<const uint8 *>( pvPkt );\n\n\tSteamNetworkingMicroseconds usecNow = SteamNetworkingSockets_GetLocalTimestamp();\n\n\tif ( cbPkt < 5 )\n\t{\n\t\tReportBadPacket( \"packet\", \"%d byte packet is too small\", cbPkt );\n\t\treturn;\n\t}\n\n\t// Data packet is the most common, check for it first.  Also, does stat tracking.\n\tif ( *pPkt & 0x80 )\n\t{\n\t\tpSelf->Received_Data( pPkt, cbPkt, usecNow );\n\t\treturn;\n\t}\n\n\t// Track stats for other packet types.\n\tpSelf->m_connection.m_statsEndToEnd.TrackRecvPacket( cbPkt, usecNow );\n\n\tif ( *pPkt == k_ESteamNetworkingUDPMsg_ChallengeReply )\n\t{\n\t\tParseProtobufBody( pPkt+1, cbPkt-1, CMsgSteamSockets_UDP_ChallengeReply, msg )\n\t\tpSelf->Received_ChallengeReply( msg, usecNow );\n\t}\n\telse if ( *pPkt == k_ESteamNetworkingUDPMsg_ConnectOK )\n\t{\n\t\tParseProtobufBody( pPkt+1, cbPkt-1, CMsgSteamSockets_UDP_ConnectOK, msg );\n\t\tpSelf->Received_ConnectOK( msg, usecNow );\n\t}\n\telse if ( *pPkt == k_ESteamNetworkingUDPMsg_ConnectionClosed )\n\t{\n\t\tParsePaddedPacket( pvPkt, cbPkt, CMsgSteamSockets_UDP_ConnectionClosed, msg )\n\t\tpSelf->Received_ConnectionClosed( msg, usecNow );\n\t}\n\telse if ( *pPkt == k_ESteamNetworkingUDPMsg_NoConnection )\n\t{\n\t\tParseProtobufBody( pPkt+1, cbPkt-1, CMsgSteamSockets_UDP_NoConnection, msg )\n\t\tpSelf->Received_NoConnection( msg, usecNow );\n\t}\n\telse if ( *pPkt == k_ESteamNetworkingUDPMsg_ChallengeRequest )\n\t{\n\t\tParsePaddedPacket( pvPkt, cbPkt, CMsgSteamSockets_UDP_ChallengeRequest, msg )\n\t\tpSelf->Received_ChallengeOrConnectRequest( \"ChallengeRequest\", msg.connection_id(), usecNow );\n\t}\n\telse if ( *pPkt == k_ESteamNetworkingUDPMsg_ConnectRequest )\n\t{\n\t\tParseProtobufBody( pPkt+1, cbPkt-1, CMsgSteamSockets_UDP_ConnectRequest, msg )\n\t\tpSelf->Received_ChallengeOrConnectRequest( \"ConnectRequest\", msg.client_connection_id(), usecNow );\n\t}\n\telse\n\t{\n\t\tReportBadPacket( \"packet\", \"Lead byte 0x%02x not a known message ID\", *pPkt );\n\t}\n}\n\nvoid CConnectionTransportUDP::Received_ChallengeReply( const CMsgSteamSockets_UDP_ChallengeReply &msg, SteamNetworkingMicroseconds usecNow )\n{\n\t// We should only be getting this if we are the \"client\"\n\tif ( ListenSocket() )\n\t{\n\t\tReportBadUDPPacketFromConnectionPeer( \"ChallengeReply\", \"Shouldn't be receiving this unless on accepted connections, only connections initiated locally.\" );\n\t\treturn;\n\t}\n\n\t// Ignore if we're not trying to connect\n\tif ( ConnectionState() != k_ESteamNetworkingConnectionState_Connecting )\n\t\treturn;\n\n\t// Check session ID to make sure they aren't spoofing.\n\tif ( msg.connection_id() != ConnectionIDLocal() )\n\t{\n\t\tReportBadUDPPacketFromConnectionPeer( \"ChallengeReply\", \"Incorrect connection ID.  Message is stale or could be spoofed, ignoring.\" );\n\t\treturn;\n\t}\n\tif ( msg.protocol_version() < k_nMinRequiredProtocolVersion )\n\t{\n\t\tm_connection.ConnectionState_ProblemDetectedLocally( k_ESteamNetConnectionEnd_Misc_Generic, \"Peer is running old software and needs to be udpated\" );\n\t\treturn;\n\t}\n\n\t// Update ping, if they replied with the timestamp\n\tif ( msg.has_your_timestamp() )\n\t{\n\t\tSteamNetworkingMicroseconds usecElapsed = usecNow - (SteamNetworkingMicroseconds)msg.your_timestamp();\n\t\tif ( usecElapsed < 0 || usecElapsed > 2*k_nMillion )\n\t\t{\n\t\t\tSpewWarning( \"Ignoring weird timestamp %llu in ChallengeReply, current time is %llu.\\n\", (unsigned long long)msg.your_timestamp(), usecNow );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint nPing = (usecElapsed + 500 ) / 1000;\n\t\t\tm_connection.m_statsEndToEnd.m_ping.ReceivedPing( nPing, usecNow );\n\t\t}\n\t}\n\n\t// Make sure we have the crypt info that we need\n\tif ( !m_connection.GetSignedCertLocal().has_cert() || !m_connection.GetSignedCryptLocal().has_info() )\n\t{\n\t\tm_connection.ConnectionState_ProblemDetectedLocally( k_ESteamNetConnectionEnd_Misc_InternalError, \"Tried to connect request, but crypt not ready\" );\n\t\treturn;\n\t}\n\n\t// Remember protocol version.  They must send it again in the connect OK, but we have a valid value now,\n\t// so we might as well save it\n\tm_connection.m_statsEndToEnd.m_nPeerProtocolVersion = msg.protocol_version();\n\n\t// Reply with the challenge data and our cert\n\tCMsgSteamSockets_UDP_ConnectRequest msgConnectRequest;\n\tmsgConnectRequest.set_client_connection_id( ConnectionIDLocal() );\n\tmsgConnectRequest.set_challenge( msg.challenge() );\n\tmsgConnectRequest.set_my_timestamp( usecNow );\n\tif ( m_connection.m_statsEndToEnd.m_ping.m_nSmoothedPing >= 0 )\n\t\tmsgConnectRequest.set_ping_est_ms( m_connection.m_statsEndToEnd.m_ping.m_nSmoothedPing );\n\t*msgConnectRequest.mutable_cert() = m_connection.GetSignedCertLocal();\n\t*msgConnectRequest.mutable_crypt() = m_connection.GetSignedCryptLocal();\n\n\t// If the cert is generic, then we need to specify our identity\n\tif ( !m_connection.BCertHasIdentity() )\n\t{\n\t\tSteamNetworkingIdentityToProtobuf( IdentityLocal(), msgConnectRequest, identity_string, legacy_identity_binary, legacy_client_steam_id );\n\t}\n\telse\n\t{\n\t\t// Identity is in the cert.  But for old peers, set legacy field, if we are a SteamID\n\t\tif ( IdentityLocal().GetSteamID64() )\n\t\t\tmsgConnectRequest.set_legacy_client_steam_id( IdentityLocal().GetSteamID64() );\n\t}\n\n\t// Send it\n\tSendMsg( k_ESteamNetworkingUDPMsg_ConnectRequest, msgConnectRequest );\n\n\t// Update retry bookkeeping, etc\n\tm_connection.SentEndToEndConnectRequest( usecNow );\n\n\t// They are supposed to reply with a timestamps, from which we can estimate the ping.\n\t// So this counts as a ping request\n\tm_connection.m_statsEndToEnd.TrackSentPingRequest( usecNow, false );\n}\n\nvoid CConnectionTransportUDP::Received_ConnectOK( const CMsgSteamSockets_UDP_ConnectOK &msg, SteamNetworkingMicroseconds usecNow )\n{\n\tSteamDatagramErrMsg errMsg;\n\n\t// We should only be getting this if we are the \"client\"\n\tif ( ListenSocket() )\n\t{\n\t\tReportBadUDPPacketFromConnectionPeer( \"ConnectOK\", \"Shouldn't be receiving this unless on accepted connections, only connections initiated locally.\" );\n\t\treturn;\n\t}\n\n\t// Check connection ID to make sure they aren't spoofing and it's the same connection we think it is\n\tif ( msg.client_connection_id() != ConnectionIDLocal() )\n\t{\n\t\tReportBadUDPPacketFromConnectionPeer( \"ConnectOK\", \"Incorrect connection ID.  Message is stale or could be spoofed, ignoring.\" );\n\t\treturn;\n\t}\n\n\t// Parse out identity from the cert\n\tSteamNetworkingIdentity identityRemote;\n\tbool bIdentityInCert = true;\n\t{\n\t\t// !SPEED! We are deserializing the cert here,\n\t\t// and then we are going to do it again below.\n\t\t// Should refactor to fix this.\n\t\tint r = SteamNetworkingIdentityFromSignedCert( identityRemote, msg.cert(), errMsg );\n\t\tif ( r < 0 )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \"ConnectRequest\", \"Bad identity in cert.  %s\", errMsg );\n\t\t\treturn;\n\t\t}\n\t\tif ( r == 0 )\n\t\t{\n\t\t\t// No identity in the cert.  Check if they put it directly in the connect message\n\t\t\tbIdentityInCert = false;\n\t\t\tr = SteamNetworkingIdentityFromProtobuf( identityRemote, msg, identity_string, legacy_identity_binary, legacy_server_steam_id, errMsg );\n\t\t\tif ( r < 0 )\n\t\t\t{\n\t\t\t\tReportBadUDPPacketFromConnectionPeer( \"ConnectRequest\", \"Bad identity.  %s\", errMsg );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( r == 0 )\n\t\t\t{\n\t\t\t\t// If no identity was presented, it's the same as them saying they are \"localhost\"\n\t\t\t\tidentityRemote.SetLocalHost();\n\t\t\t}\n\t\t}\n\t}\n\tAssert( !identityRemote.IsInvalid() );\n\n\t// Check if they are using an IP address as an identity (possibly the anonymous \"localhost\" identity)\n\tif ( identityRemote.m_eType == k_ESteamNetworkingIdentityType_IPAddress )\n\t{\n\t\tSteamNetworkingIPAddr addr;\n\t\tconst netadr_t &adrFrom = m_pSocket->GetRemoteHostAddr();\n\t\tadrFrom.GetIPV6( addr.m_ipv6 );\n\t\taddr.m_port = adrFrom.GetPort();\n\n\t\tif ( identityRemote.IsLocalHost() )\n\t\t{\n\t\t\tif ( m_connection.m_connectionConfig.m_IP_AllowWithoutAuth.Get() == 0 )\n\t\t\t{\n\t\t\t\t// Should we send an explicit rejection here?\n\t\t\t\tReportBadUDPPacketFromConnectionPeer( \"ConnectOK\", \"Unauthenticated connections not allowed.\" );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set their identity to their real address (including port)\n\t\t\tidentityRemote.SetIPAddr( addr );\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// FIXME - Should the address be required to match?\n\t\t\t// If we are behind NAT, it won't.\n\t\t\t//if ( memcmp( addr.m_ipv6, identityRemote.m_ip.m_ipv6, sizeof(addr.m_ipv6) ) != 0\n\t\t\t//\t|| ( identityRemote.m_ip.m_port != 0 && identityRemote.m_ip.m_port != addr.m_port ) ) // Allow 0 port in the identity to mean \"any port\"\n\t\t\t//{\n\t\t\t//\tReportBadPacket( \"ConnectRequest\", \"Identity in request is %s, but packet is coming from %s.\" );\n\t\t\t//\treturn;\n\t\t\t//}\n\n\t\t\t// It's not really clear what the use case is here for\n\t\t\t// requesting a specific IP address as your identity,\n\t\t\t// and not using localhost.  If they have a cert, assume it's\n\t\t\t// meaningful.  Remember: the cert could be unsigned!  That\n\t\t\t// is a separate issue which will be handled later, whether\n\t\t\t// we want to allow that.\n\t\t\tif ( !bIdentityInCert )\n\t\t\t{\n\t\t\t\t// Should we send an explicit rejection here?\n\t\t\t\tReportBadPacket( \"ConnectOK\", \"Cannot use specific IP address.\" );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Make sure they are still who we think they are\n\tif ( !m_connection.m_identityRemote.IsInvalid() && !( m_connection.m_identityRemote == identityRemote ) )\n\t{\n\t\tReportBadUDPPacketFromConnectionPeer( \"ConnectOK\", \"server_steam_id doesn't match who we expect to be connecting to!\" );\n\t\treturn;\n\t}\n\n\t// Update ping, if they replied a timestamp\n\tif ( msg.has_your_timestamp() )\n\t{\n\t\tSteamNetworkingMicroseconds usecElapsed = usecNow - (SteamNetworkingMicroseconds)msg.your_timestamp() - msg.delay_time_usec();\n\t\tif ( usecElapsed < 0 || usecElapsed > 2*k_nMillion )\n\t\t{\n\t\t\tSpewWarning( \"Ignoring weird timestamp %llu in ConnectOK, current time is %llu, remote delay was %lld.\\n\", (unsigned long long)msg.your_timestamp(), usecNow, (long long)msg.delay_time_usec() );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint nPing = (usecElapsed + 500 ) / 1000;\n\t\t\tm_connection.m_statsEndToEnd.m_ping.ReceivedPing( nPing, usecNow );\n\t\t}\n\t}\n\n\t// Check state\n\tswitch ( ConnectionState() )\n\t{\n\t\tcase k_ESteamNetworkingConnectionState_Dead:\n\t\tcase k_ESteamNetworkingConnectionState_None:\n\t\tcase k_ESteamNetworkingConnectionState_FindingRoute: // not used for raw UDP\n\t\tdefault:\n\t\t\tAssert( false );\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_ClosedByPeer:\n\t\tcase k_ESteamNetworkingConnectionState_FinWait:\n\t\tcase k_ESteamNetworkingConnectionState_ProblemDetectedLocally:\n\t\t\tSendConnectionClosedOrNoConnection();\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_Linger:\n\t\tcase k_ESteamNetworkingConnectionState_Connected:\n\t\t\t// We already know we were able to establish the connection.\n\t\t\t// Just ignore this packet\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_Connecting:\n\t\t\tbreak;\n\t}\n\n\t// Connection ID\n\tm_connection.m_unConnectionIDRemote = msg.server_connection_id();\n\tif ( ( m_connection.m_unConnectionIDRemote & 0xffff ) == 0 )\n\t{\n\t\tm_connection.ConnectionState_ProblemDetectedLocally( k_ESteamNetConnectionEnd_Remote_BadCrypt, \"Didn't send valid connection ID\" );\n\t\treturn;\n\t}\n\n\tm_connection.m_identityRemote = identityRemote;\n\n\t// Check the certs, save keys, etc\n\tif ( !m_connection.BRecvCryptoHandshake( msg.cert(), msg.crypt(), false ) )\n\t{\n\t\tAssert( ConnectionState() == k_ESteamNetworkingConnectionState_ProblemDetectedLocally );\n\t\tReportBadUDPPacketFromConnectionPeer( \"ConnectOK\", \"Failed crypto init.  %s\", m_connection.m_szEndDebug );\n\t\treturn;\n\t}\n\n\t// Generic connection code will take it from here.\n\tm_connection.ConnectionState_Connected( usecNow );\n}\n\nvoid CConnectionTransportUDP::Received_ChallengeOrConnectRequest( const char *pszDebugPacketType, uint32 unPacketConnectionID, SteamNetworkingMicroseconds usecNow )\n{\n\t// If wrong connection ID, then check for sending a generic reply and bail\n\tif ( unPacketConnectionID != m_connection.m_unConnectionIDRemote )\n\t{\n\t\tReportBadUDPPacketFromConnectionPeer( pszDebugPacketType, \"Incorrect connection ID, when we do have a connection for this address.  Could be spoofed, ignoring.\" );\n\t\t// Let's not send a reply in this case\n\t\t//if ( BCheckGlobalSpamReplyRateLimit( usecNow ) )\n\t\t//\tSendNoConnection( unPacketConnectionID );\n\t\treturn;\n\t}\n\n\t// Check state\n\tswitch ( ConnectionState() )\n\t{\n\t\tcase k_ESteamNetworkingConnectionState_Dead:\n\t\tcase k_ESteamNetworkingConnectionState_None:\n\t\tcase k_ESteamNetworkingConnectionState_FindingRoute: // not used for raw UDP\n\t\tdefault:\n\t\t\tAssert( false );\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_ClosedByPeer:\n\t\tcase k_ESteamNetworkingConnectionState_FinWait:\n\t\tcase k_ESteamNetworkingConnectionState_ProblemDetectedLocally:\n\t\t\tSendConnectionClosedOrNoConnection();\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_Connecting:\n\t\t\t// We're waiting on the application.  So we'll just have to ignore.\n\t\t\tbreak;\n\n\t\tcase k_ESteamNetworkingConnectionState_Linger:\n\t\tcase k_ESteamNetworkingConnectionState_Connected:\n\t\t\tif ( !ListenSocket() )\n\t\t\t{\n\t\t\t\t// WAT?  We initiated this connection, so why are they requesting to connect?\n\t\t\t\tReportBadUDPPacketFromConnectionPeer( pszDebugPacketType, \"We are the 'client' who initiated the connection, so 'server' shouldn't be sending us this!\" );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// This is totally legit and possible.  Our earlier reply might have dropped, and they are re-sending\n\t\t\tSendConnectOK( usecNow );\n\t\t\treturn;\n\t}\n\n}\n\nvoid CConnectionTransportUDP::SendConnectOK( SteamNetworkingMicroseconds usecNow )\n{\n\tAssert( ConnectionIDLocal() );\n\tAssert( ConnectionIDRemote() );\n\tAssert( ListenSocket() );\n\n\tAssert( m_connection.GetSignedCertLocal().has_cert() );\n\tAssert( m_connection.GetSignedCryptLocal().has_info() );\n\n\tCMsgSteamSockets_UDP_ConnectOK msg;\n\tmsg.set_client_connection_id( ConnectionIDRemote() );\n\tmsg.set_server_connection_id( ConnectionIDLocal() );\n\t*msg.mutable_cert() = m_connection.GetSignedCertLocal();\n\t*msg.mutable_crypt() = m_connection.GetSignedCryptLocal();\n\n\t// If the cert is generic, then we need to specify our identity\n\tif ( !m_connection.BCertHasIdentity() )\n\t{\n\t\tSteamNetworkingIdentityToProtobuf( IdentityLocal(), msg, identity_string, legacy_identity_binary, legacy_server_steam_id );\n\t}\n\telse\n\t{\n\t\t// Identity is in the cert.  But for old peers, set legacy field, if we are a SteamID\n\t\tif ( IdentityLocal().GetSteamID64() )\n\t\t\tmsg.set_legacy_server_steam_id( IdentityLocal().GetSteamID64() );\n\t}\n\n\t// Do we have a timestamp?\n\tif ( m_connection.m_usecWhenReceivedHandshakeRemoteTimestamp )\n\t{\n\t\tSteamNetworkingMicroseconds usecElapsed = usecNow - m_connection.m_usecWhenReceivedHandshakeRemoteTimestamp;\n\t\tAssert( usecElapsed >= 0 );\n\t\tif ( usecElapsed < 4*k_nMillion )\n\t\t{\n\t\t\tmsg.set_your_timestamp( m_connection.m_ulHandshakeRemoteTimestamp );\n\t\t\tmsg.set_delay_time_usec( usecElapsed );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSpewWarning( \"Discarding handshake timestamp that's %lldms old, not sending in ConnectOK\\n\", usecElapsed/1000 );\n\t\t\tm_connection.m_usecWhenReceivedHandshakeRemoteTimestamp = 0;\n\t\t}\n\t}\n\n\n\t// Send it, with padding\n\tSendMsg( k_ESteamNetworkingUDPMsg_ConnectOK, msg );\n}\n\nEUnsignedCert CSteamNetworkConnectionUDP::AllowRemoteUnsignedCert()\n{\n\t// NOTE: No special override for localhost.\n\t// Should we add a seperate convar for this?\n\t// For the CSteamNetworkConnectionlocalhostLoopback connection,\n\t// we know both ends are us.  but if they are just connecting to\n\t// 127.0.0.1, it's not clear that we should handle this any\n\t// differently from any other connection\n\n\t// Enabled by convar?\n\tint nAllow = m_connectionConfig.m_IP_AllowWithoutAuth.Get();\n\tif ( nAllow > 1 )\n\t\treturn k_EUnsignedCert_Allow;\n\tif ( nAllow == 1 )\n\t\treturn k_EUnsignedCert_AllowWarn;\n\n\t// Lock it down\n\treturn k_EUnsignedCert_Disallow;\n}\n\nEUnsignedCert CSteamNetworkConnectionUDP::AllowLocalUnsignedCert()\n{\n\t// Same logic actually applies for remote and local\n\treturn AllowRemoteUnsignedCert();\n}\n\n/////////////////////////////////////////////////////////////////////////////\n//\n// Loopback connections\n//\n/////////////////////////////////////////////////////////////////////////////\n\nCSteamNetworkConnectionlocalhostLoopback::CSteamNetworkConnectionlocalhostLoopback( CSteamNetworkingSockets *pSteamNetworkingSocketsInterface, const SteamNetworkingIdentity &identity )\n: CSteamNetworkConnectionUDP( pSteamNetworkingSocketsInterface )\n{\n\tm_identityLocal = identity;\n}\n\nEUnsignedCert CSteamNetworkConnectionlocalhostLoopback::AllowRemoteUnsignedCert()\n{\n\treturn k_EUnsignedCert_Allow;\n}\n\nEUnsignedCert CSteamNetworkConnectionlocalhostLoopback::AllowLocalUnsignedCert()\n{\n\treturn k_EUnsignedCert_Allow;\n}\n\nbool CSteamNetworkConnectionlocalhostLoopback::APICreateSocketPair( CSteamNetworkingSockets *pSteamNetworkingSocketsInterface, CSteamNetworkConnectionlocalhostLoopback *pConn[2], const SteamNetworkingIdentity pIdentity[2] )\n{\n\tSteamDatagramTransportLock::AssertHeldByCurrentThread();\n\n\tSteamDatagramErrMsg errMsg;\n\n\tpConn[1] = new CSteamNetworkConnectionlocalhostLoopback( pSteamNetworkingSocketsInterface, pIdentity[0] );\n\tpConn[0] = new CSteamNetworkConnectionlocalhostLoopback( pSteamNetworkingSocketsInterface, pIdentity[1] );\n\tif ( !pConn[0] || !pConn[1] )\n\t{\nfailed:\n\t\tpConn[0]->ConnectionDestroySelfNow(); pConn[0] = nullptr;\n\t\tpConn[1]->ConnectionDestroySelfNow(); pConn[1] = nullptr;\n\t\treturn false;\n\t}\n\n\t// Don't post any state changes for these transitions.  We just want to immediately start in the\n\t// connected state\n\t++pConn[0]->m_nSupressStateChangeCallbacks;\n\t++pConn[1]->m_nSupressStateChangeCallbacks;\n\n\tCConnectionTransportUDP *pTransport[2] = {\n\t\tnew CConnectionTransportUDP( *pConn[0] ),\n\t\tnew CConnectionTransportUDP( *pConn[1] )\n\t};\n\tpConn[0]->m_pTransport = pTransport[0];\n\tpConn[1]->m_pTransport = pTransport[1];\n\n\tif ( !CConnectionTransportUDP::CreateLoopbackPair( pTransport ) )\n\t\tgoto failed;\n\n\tSteamNetworkingMicroseconds usecNow = SteamNetworkingSockets_GetLocalTimestamp();\n\n\t// Initialize both connections\n\tfor ( int i = 0 ; i < 2 ; ++i )\n\t{\n\t\tif ( !pConn[i]->BInitConnection( usecNow, 0, nullptr, errMsg ) )\n\t\t{\n\t\t\tAssertMsg1( false, \"CSteamNetworkConnectionlocalhostLoopback::BInitConnection failed.  %s\", errMsg );\n\t\t\tgoto failed;\n\t\t}\n\t}\n\n\t// Tie the connections to each other, and mark them as connected\n\tfor ( int i = 0 ; i < 2 ; ++i )\n\t{\n\t\tCSteamNetworkConnectionlocalhostLoopback *p = pConn[i];\n\t\tCSteamNetworkConnectionlocalhostLoopback *q = pConn[1-i];\n\t\tp->m_identityRemote = q->m_identityLocal;\n\t\tp->m_unConnectionIDRemote = q->m_unConnectionIDLocal;\n\t\tp->m_statsEndToEnd.m_usecTimeLastRecv = usecNow; // Act like we just now received something\n\t\tif ( !p->BRecvCryptoHandshake( q->m_msgSignedCertLocal, q->m_msgSignedCryptLocal, i==0 ) )\n\t\t{\n\t\t\tAssertMsg( false, \"BRecvCryptoHandshake failed creating localhost socket pair\" );\n\t\t\tgoto failed;\n\t\t}\n\t\tif ( !p->BConnectionState_Connecting( usecNow, errMsg ) )\n\t\t{\n\t\t\tAssertMsg( false, \"BConnectionState_Connecting failed creating loopback pipe socket pair.  %s\", errMsg );\n\t\t\tgoto failed;\n\t\t}\n\t\tp->ConnectionState_Connected( usecNow );\n\t}\n\n\t// Any further state changes are legit\n\tpConn[0]->m_nSupressStateChangeCallbacks = 0;\n\tpConn[1]->m_nSupressStateChangeCallbacks = 0;\n\n\treturn true;\n}\n\n} // namespace SteamNetworkingSocketsLib\n"], "filenames": ["src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp"], "buggy_code_start_loc": [843], "buggy_code_end_loc": [846], "fixing_code_start_loc": [843], "fixing_code_end_loc": [846], "type": "NVD-CWE-noinfo", "message": "Valve's Game Networking Sockets prior to version v1.2.0 improperly handles inlined statistics messages in function CConnectionTransportUDPBase::Received_Data(), leading to an exception thrown from libprotobuf and resulting in a crash.", "other": {"cve": {"id": "CVE-2020-6019", "sourceIdentifier": "cve@checkpoint.com", "published": "2020-11-13T16:15:18.463", "lastModified": "2022-11-03T17:51:21.280", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Valve's Game Networking Sockets prior to version v1.2.0 improperly handles inlined statistics messages in function CConnectionTransportUDPBase::Received_Data(), leading to an exception thrown from libprotobuf and resulting in a crash."}, {"lang": "es", "value": "Game Networking Sockets de Valve versiones anteriores a v1.2.0, maneja inapropiadamente unos mensajes de estad\u00edsticas en l\u00ednea en la funci\u00f3n CConnectionTransportUDPBase::Received_Data(), conllevando a una excepci\u00f3n lanzada desde libprotobuf y resultando en un bloqueo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "cve@checkpoint.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-248"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:valvesoftware:game_networking_sockets:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.0", "matchCriteriaId": "8CB71176-D705-4517-81B9-97A557278890"}]}]}], "references": [{"url": "https://github.com/ValveSoftware/GameNetworkingSockets/commit/d944a10808891d202bb1d5e1998de6e0423af678", "source": "cve@checkpoint.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://research.checkpoint.com/2020/game-on-finding-vulnerabilities-in-valves-steam-sockets/", "source": "cve@checkpoint.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ValveSoftware/GameNetworkingSockets/commit/d944a10808891d202bb1d5e1998de6e0423af678"}}