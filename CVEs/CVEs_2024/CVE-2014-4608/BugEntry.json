{"buggy_code": ["/*\n *  LZO1X Decompressor from LZO\n *\n *  Copyright (C) 1996-2012 Markus F.X.J. Oberhumer <markus@oberhumer.com>\n *\n *  The full LZO package can be found at:\n *  http://www.oberhumer.com/opensource/lzo/\n *\n *  Changed for Linux kernel use by:\n *  Nitin Gupta <nitingupta910@gmail.com>\n *  Richard Purdie <rpurdie@openedhand.com>\n */\n\n#ifndef STATIC\n#include <linux/module.h>\n#include <linux/kernel.h>\n#endif\n#include <asm/unaligned.h>\n#include <linux/lzo.h>\n#include \"lzodefs.h\"\n\n#define HAVE_IP(x)      ((size_t)(ip_end - ip) >= (size_t)(x))\n#define HAVE_OP(x)      ((size_t)(op_end - op) >= (size_t)(x))\n#define NEED_IP(x)      if (!HAVE_IP(x)) goto input_overrun\n#define NEED_OP(x)      if (!HAVE_OP(x)) goto output_overrun\n#define TEST_LB(m_pos)  if ((m_pos) < out) goto lookbehind_overrun\n\nint lzo1x_decompress_safe(const unsigned char *in, size_t in_len,\n\t\t\t  unsigned char *out, size_t *out_len)\n{\n\tunsigned char *op;\n\tconst unsigned char *ip;\n\tsize_t t, next;\n\tsize_t state = 0;\n\tconst unsigned char *m_pos;\n\tconst unsigned char * const ip_end = in + in_len;\n\tunsigned char * const op_end = out + *out_len;\n\n\top = out;\n\tip = in;\n\n\tif (unlikely(in_len < 3))\n\t\tgoto input_overrun;\n\tif (*ip > 17) {\n\t\tt = *ip++ - 17;\n\t\tif (t < 4) {\n\t\t\tnext = t;\n\t\t\tgoto match_next;\n\t\t}\n\t\tgoto copy_literal_run;\n\t}\n\n\tfor (;;) {\n\t\tt = *ip++;\n\t\tif (t < 16) {\n\t\t\tif (likely(state == 0)) {\n\t\t\t\tif (unlikely(t == 0)) {\n\t\t\t\t\twhile (unlikely(*ip == 0)) {\n\t\t\t\t\t\tt += 255;\n\t\t\t\t\t\tip++;\n\t\t\t\t\t\tNEED_IP(1);\n\t\t\t\t\t}\n\t\t\t\t\tt += 15 + *ip++;\n\t\t\t\t}\n\t\t\t\tt += 3;\ncopy_literal_run:\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n\t\t\t\tif (likely(HAVE_IP(t + 15) && HAVE_OP(t + 15))) {\n\t\t\t\t\tconst unsigned char *ie = ip + t;\n\t\t\t\t\tunsigned char *oe = op + t;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tCOPY8(op, ip);\n\t\t\t\t\t\top += 8;\n\t\t\t\t\t\tip += 8;\n\t\t\t\t\t\tCOPY8(op, ip);\n\t\t\t\t\t\top += 8;\n\t\t\t\t\t\tip += 8;\n\t\t\t\t\t} while (ip < ie);\n\t\t\t\t\tip = ie;\n\t\t\t\t\top = oe;\n\t\t\t\t} else\n#endif\n\t\t\t\t{\n\t\t\t\t\tNEED_OP(t);\n\t\t\t\t\tNEED_IP(t + 3);\n\t\t\t\t\tdo {\n\t\t\t\t\t\t*op++ = *ip++;\n\t\t\t\t\t} while (--t > 0);\n\t\t\t\t}\n\t\t\t\tstate = 4;\n\t\t\t\tcontinue;\n\t\t\t} else if (state != 4) {\n\t\t\t\tnext = t & 3;\n\t\t\t\tm_pos = op - 1;\n\t\t\t\tm_pos -= t >> 2;\n\t\t\t\tm_pos -= *ip++ << 2;\n\t\t\t\tTEST_LB(m_pos);\n\t\t\t\tNEED_OP(2);\n\t\t\t\top[0] = m_pos[0];\n\t\t\t\top[1] = m_pos[1];\n\t\t\t\top += 2;\n\t\t\t\tgoto match_next;\n\t\t\t} else {\n\t\t\t\tnext = t & 3;\n\t\t\t\tm_pos = op - (1 + M2_MAX_OFFSET);\n\t\t\t\tm_pos -= t >> 2;\n\t\t\t\tm_pos -= *ip++ << 2;\n\t\t\t\tt = 3;\n\t\t\t}\n\t\t} else if (t >= 64) {\n\t\t\tnext = t & 3;\n\t\t\tm_pos = op - 1;\n\t\t\tm_pos -= (t >> 2) & 7;\n\t\t\tm_pos -= *ip++ << 3;\n\t\t\tt = (t >> 5) - 1 + (3 - 1);\n\t\t} else if (t >= 32) {\n\t\t\tt = (t & 31) + (3 - 1);\n\t\t\tif (unlikely(t == 2)) {\n\t\t\t\twhile (unlikely(*ip == 0)) {\n\t\t\t\t\tt += 255;\n\t\t\t\t\tip++;\n\t\t\t\t\tNEED_IP(1);\n\t\t\t\t}\n\t\t\t\tt += 31 + *ip++;\n\t\t\t\tNEED_IP(2);\n\t\t\t}\n\t\t\tm_pos = op - 1;\n\t\t\tnext = get_unaligned_le16(ip);\n\t\t\tip += 2;\n\t\t\tm_pos -= next >> 2;\n\t\t\tnext &= 3;\n\t\t} else {\n\t\t\tm_pos = op;\n\t\t\tm_pos -= (t & 8) << 11;\n\t\t\tt = (t & 7) + (3 - 1);\n\t\t\tif (unlikely(t == 2)) {\n\t\t\t\twhile (unlikely(*ip == 0)) {\n\t\t\t\t\tt += 255;\n\t\t\t\t\tip++;\n\t\t\t\t\tNEED_IP(1);\n\t\t\t\t}\n\t\t\t\tt += 7 + *ip++;\n\t\t\t\tNEED_IP(2);\n\t\t\t}\n\t\t\tnext = get_unaligned_le16(ip);\n\t\t\tip += 2;\n\t\t\tm_pos -= next >> 2;\n\t\t\tnext &= 3;\n\t\t\tif (m_pos == op)\n\t\t\t\tgoto eof_found;\n\t\t\tm_pos -= 0x4000;\n\t\t}\n\t\tTEST_LB(m_pos);\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n\t\tif (op - m_pos >= 8) {\n\t\t\tunsigned char *oe = op + t;\n\t\t\tif (likely(HAVE_OP(t + 15))) {\n\t\t\t\tdo {\n\t\t\t\t\tCOPY8(op, m_pos);\n\t\t\t\t\top += 8;\n\t\t\t\t\tm_pos += 8;\n\t\t\t\t\tCOPY8(op, m_pos);\n\t\t\t\t\top += 8;\n\t\t\t\t\tm_pos += 8;\n\t\t\t\t} while (op < oe);\n\t\t\t\top = oe;\n\t\t\t\tif (HAVE_IP(6)) {\n\t\t\t\t\tstate = next;\n\t\t\t\t\tCOPY4(op, ip);\n\t\t\t\t\top += next;\n\t\t\t\t\tip += next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tNEED_OP(t);\n\t\t\t\tdo {\n\t\t\t\t\t*op++ = *m_pos++;\n\t\t\t\t} while (op < oe);\n\t\t\t}\n\t\t} else\n#endif\n\t\t{\n\t\t\tunsigned char *oe = op + t;\n\t\t\tNEED_OP(t);\n\t\t\top[0] = m_pos[0];\n\t\t\top[1] = m_pos[1];\n\t\t\top += 2;\n\t\t\tm_pos += 2;\n\t\t\tdo {\n\t\t\t\t*op++ = *m_pos++;\n\t\t\t} while (op < oe);\n\t\t}\nmatch_next:\n\t\tstate = next;\n\t\tt = next;\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n\t\tif (likely(HAVE_IP(6) && HAVE_OP(4))) {\n\t\t\tCOPY4(op, ip);\n\t\t\top += t;\n\t\t\tip += t;\n\t\t} else\n#endif\n\t\t{\n\t\t\tNEED_IP(t + 3);\n\t\t\tNEED_OP(t);\n\t\t\twhile (t > 0) {\n\t\t\t\t*op++ = *ip++;\n\t\t\t\tt--;\n\t\t\t}\n\t\t}\n\t}\n\neof_found:\n\t*out_len = op - out;\n\treturn (t != 3       ? LZO_E_ERROR :\n\t\tip == ip_end ? LZO_E_OK :\n\t\tip <  ip_end ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN);\n\ninput_overrun:\n\t*out_len = op - out;\n\treturn LZO_E_INPUT_OVERRUN;\n\noutput_overrun:\n\t*out_len = op - out;\n\treturn LZO_E_OUTPUT_OVERRUN;\n\nlookbehind_overrun:\n\t*out_len = op - out;\n\treturn LZO_E_LOOKBEHIND_OVERRUN;\n}\n#ifndef STATIC\nEXPORT_SYMBOL_GPL(lzo1x_decompress_safe);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"LZO1X Decompressor\");\n\n#endif\n"], "fixing_code": ["/*\n *  LZO1X Decompressor from LZO\n *\n *  Copyright (C) 1996-2012 Markus F.X.J. Oberhumer <markus@oberhumer.com>\n *\n *  The full LZO package can be found at:\n *  http://www.oberhumer.com/opensource/lzo/\n *\n *  Changed for Linux kernel use by:\n *  Nitin Gupta <nitingupta910@gmail.com>\n *  Richard Purdie <rpurdie@openedhand.com>\n */\n\n#ifndef STATIC\n#include <linux/module.h>\n#include <linux/kernel.h>\n#endif\n#include <asm/unaligned.h>\n#include <linux/lzo.h>\n#include \"lzodefs.h\"\n\n#define HAVE_IP(t, x)\t\t\t\t\t\\\n\t(((size_t)(ip_end - ip) >= (size_t)(t + x)) &&\t\\\n\t (((t + x) >= t) && ((t + x) >= x)))\n\n#define HAVE_OP(t, x)\t\t\t\t\t\\\n\t(((size_t)(op_end - op) >= (size_t)(t + x)) &&\t\\\n\t (((t + x) >= t) && ((t + x) >= x)))\n\n#define NEED_IP(t, x)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tif (!HAVE_IP(t, x))\t\t\t\\\n\t\t\tgoto input_overrun;\t\t\\\n\t} while (0)\n\n#define NEED_OP(t, x)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tif (!HAVE_OP(t, x))\t\t\t\\\n\t\t\tgoto output_overrun;\t\t\\\n\t} while (0)\n\n#define TEST_LB(m_pos)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tif ((m_pos) < out)\t\t\t\\\n\t\t\tgoto lookbehind_overrun;\t\\\n\t} while (0)\n\nint lzo1x_decompress_safe(const unsigned char *in, size_t in_len,\n\t\t\t  unsigned char *out, size_t *out_len)\n{\n\tunsigned char *op;\n\tconst unsigned char *ip;\n\tsize_t t, next;\n\tsize_t state = 0;\n\tconst unsigned char *m_pos;\n\tconst unsigned char * const ip_end = in + in_len;\n\tunsigned char * const op_end = out + *out_len;\n\n\top = out;\n\tip = in;\n\n\tif (unlikely(in_len < 3))\n\t\tgoto input_overrun;\n\tif (*ip > 17) {\n\t\tt = *ip++ - 17;\n\t\tif (t < 4) {\n\t\t\tnext = t;\n\t\t\tgoto match_next;\n\t\t}\n\t\tgoto copy_literal_run;\n\t}\n\n\tfor (;;) {\n\t\tt = *ip++;\n\t\tif (t < 16) {\n\t\t\tif (likely(state == 0)) {\n\t\t\t\tif (unlikely(t == 0)) {\n\t\t\t\t\twhile (unlikely(*ip == 0)) {\n\t\t\t\t\t\tt += 255;\n\t\t\t\t\t\tip++;\n\t\t\t\t\t\tNEED_IP(1, 0);\n\t\t\t\t\t}\n\t\t\t\t\tt += 15 + *ip++;\n\t\t\t\t}\n\t\t\t\tt += 3;\ncopy_literal_run:\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n\t\t\t\tif (likely(HAVE_IP(t, 15) && HAVE_OP(t, 15))) {\n\t\t\t\t\tconst unsigned char *ie = ip + t;\n\t\t\t\t\tunsigned char *oe = op + t;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tCOPY8(op, ip);\n\t\t\t\t\t\top += 8;\n\t\t\t\t\t\tip += 8;\n\t\t\t\t\t\tCOPY8(op, ip);\n\t\t\t\t\t\top += 8;\n\t\t\t\t\t\tip += 8;\n\t\t\t\t\t} while (ip < ie);\n\t\t\t\t\tip = ie;\n\t\t\t\t\top = oe;\n\t\t\t\t} else\n#endif\n\t\t\t\t{\n\t\t\t\t\tNEED_OP(t, 0);\n\t\t\t\t\tNEED_IP(t, 3);\n\t\t\t\t\tdo {\n\t\t\t\t\t\t*op++ = *ip++;\n\t\t\t\t\t} while (--t > 0);\n\t\t\t\t}\n\t\t\t\tstate = 4;\n\t\t\t\tcontinue;\n\t\t\t} else if (state != 4) {\n\t\t\t\tnext = t & 3;\n\t\t\t\tm_pos = op - 1;\n\t\t\t\tm_pos -= t >> 2;\n\t\t\t\tm_pos -= *ip++ << 2;\n\t\t\t\tTEST_LB(m_pos);\n\t\t\t\tNEED_OP(2, 0);\n\t\t\t\top[0] = m_pos[0];\n\t\t\t\top[1] = m_pos[1];\n\t\t\t\top += 2;\n\t\t\t\tgoto match_next;\n\t\t\t} else {\n\t\t\t\tnext = t & 3;\n\t\t\t\tm_pos = op - (1 + M2_MAX_OFFSET);\n\t\t\t\tm_pos -= t >> 2;\n\t\t\t\tm_pos -= *ip++ << 2;\n\t\t\t\tt = 3;\n\t\t\t}\n\t\t} else if (t >= 64) {\n\t\t\tnext = t & 3;\n\t\t\tm_pos = op - 1;\n\t\t\tm_pos -= (t >> 2) & 7;\n\t\t\tm_pos -= *ip++ << 3;\n\t\t\tt = (t >> 5) - 1 + (3 - 1);\n\t\t} else if (t >= 32) {\n\t\t\tt = (t & 31) + (3 - 1);\n\t\t\tif (unlikely(t == 2)) {\n\t\t\t\twhile (unlikely(*ip == 0)) {\n\t\t\t\t\tt += 255;\n\t\t\t\t\tip++;\n\t\t\t\t\tNEED_IP(1, 0);\n\t\t\t\t}\n\t\t\t\tt += 31 + *ip++;\n\t\t\t\tNEED_IP(2, 0);\n\t\t\t}\n\t\t\tm_pos = op - 1;\n\t\t\tnext = get_unaligned_le16(ip);\n\t\t\tip += 2;\n\t\t\tm_pos -= next >> 2;\n\t\t\tnext &= 3;\n\t\t} else {\n\t\t\tm_pos = op;\n\t\t\tm_pos -= (t & 8) << 11;\n\t\t\tt = (t & 7) + (3 - 1);\n\t\t\tif (unlikely(t == 2)) {\n\t\t\t\twhile (unlikely(*ip == 0)) {\n\t\t\t\t\tt += 255;\n\t\t\t\t\tip++;\n\t\t\t\t\tNEED_IP(1, 0);\n\t\t\t\t}\n\t\t\t\tt += 7 + *ip++;\n\t\t\t\tNEED_IP(2, 0);\n\t\t\t}\n\t\t\tnext = get_unaligned_le16(ip);\n\t\t\tip += 2;\n\t\t\tm_pos -= next >> 2;\n\t\t\tnext &= 3;\n\t\t\tif (m_pos == op)\n\t\t\t\tgoto eof_found;\n\t\t\tm_pos -= 0x4000;\n\t\t}\n\t\tTEST_LB(m_pos);\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n\t\tif (op - m_pos >= 8) {\n\t\t\tunsigned char *oe = op + t;\n\t\t\tif (likely(HAVE_OP(t, 15))) {\n\t\t\t\tdo {\n\t\t\t\t\tCOPY8(op, m_pos);\n\t\t\t\t\top += 8;\n\t\t\t\t\tm_pos += 8;\n\t\t\t\t\tCOPY8(op, m_pos);\n\t\t\t\t\top += 8;\n\t\t\t\t\tm_pos += 8;\n\t\t\t\t} while (op < oe);\n\t\t\t\top = oe;\n\t\t\t\tif (HAVE_IP(6, 0)) {\n\t\t\t\t\tstate = next;\n\t\t\t\t\tCOPY4(op, ip);\n\t\t\t\t\top += next;\n\t\t\t\t\tip += next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tNEED_OP(t, 0);\n\t\t\t\tdo {\n\t\t\t\t\t*op++ = *m_pos++;\n\t\t\t\t} while (op < oe);\n\t\t\t}\n\t\t} else\n#endif\n\t\t{\n\t\t\tunsigned char *oe = op + t;\n\t\t\tNEED_OP(t, 0);\n\t\t\top[0] = m_pos[0];\n\t\t\top[1] = m_pos[1];\n\t\t\top += 2;\n\t\t\tm_pos += 2;\n\t\t\tdo {\n\t\t\t\t*op++ = *m_pos++;\n\t\t\t} while (op < oe);\n\t\t}\nmatch_next:\n\t\tstate = next;\n\t\tt = next;\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n\t\tif (likely(HAVE_IP(6, 0) && HAVE_OP(4, 0))) {\n\t\t\tCOPY4(op, ip);\n\t\t\top += t;\n\t\t\tip += t;\n\t\t} else\n#endif\n\t\t{\n\t\t\tNEED_IP(t, 3);\n\t\t\tNEED_OP(t, 0);\n\t\t\twhile (t > 0) {\n\t\t\t\t*op++ = *ip++;\n\t\t\t\tt--;\n\t\t\t}\n\t\t}\n\t}\n\neof_found:\n\t*out_len = op - out;\n\treturn (t != 3       ? LZO_E_ERROR :\n\t\tip == ip_end ? LZO_E_OK :\n\t\tip <  ip_end ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN);\n\ninput_overrun:\n\t*out_len = op - out;\n\treturn LZO_E_INPUT_OVERRUN;\n\noutput_overrun:\n\t*out_len = op - out;\n\treturn LZO_E_OUTPUT_OVERRUN;\n\nlookbehind_overrun:\n\t*out_len = op - out;\n\treturn LZO_E_LOOKBEHIND_OVERRUN;\n}\n#ifndef STATIC\nEXPORT_SYMBOL_GPL(lzo1x_decompress_safe);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"LZO1X Decompressor\");\n\n#endif\n"], "filenames": ["lib/lzo/lzo1x_decompress_safe.c"], "buggy_code_start_loc": [22], "buggy_code_end_loc": [206], "fixing_code_start_loc": [22], "fixing_code_end_loc": [226], "type": "CWE-190", "message": "** DISPUTED ** Multiple integer overflows in the lzo1x_decompress_safe function in lib/lzo/lzo1x_decompress_safe.c in the LZO decompressor in the Linux kernel before 3.15.2 allow context-dependent attackers to cause a denial of service (memory corruption) via a crafted Literal Run.  NOTE: the author of the LZO algorithms says \"the Linux kernel is *not* affected; media hype.\"", "other": {"cve": {"id": "CVE-2014-4608", "sourceIdentifier": "cve@mitre.org", "published": "2014-07-03T04:22:15.310", "lastModified": "2020-08-14T17:51:37.367", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "** DISPUTED ** Multiple integer overflows in the lzo1x_decompress_safe function in lib/lzo/lzo1x_decompress_safe.c in the LZO decompressor in the Linux kernel before 3.15.2 allow context-dependent attackers to cause a denial of service (memory corruption) via a crafted Literal Run.  NOTE: the author of the LZO algorithms says \"the Linux kernel is *not* affected; media hype.\""}, {"lang": "es", "value": "** DISPUTADA ** M\u00faltiples desbordamientos de enteros en la funci\u00f3n lzo1x_decompress_safe en lib/lzo/lzo1x_decompress_safe.c en el descompresor LZO en el kernel de Linux anterior a 3.15.2 permiten a atacantes dependientes de contexto causar una denegaci\u00f3n de servicio (corrupci\u00f3n de memoria) a trav\u00e9s de un 'Literal Run' manipulado. NOTA: el autor de los algoritmos LZO algorithms dice que 'el kernel de Linux *no* est\u00e1 afectado; sensacionalismo period\u00edstico.'"}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.15.2", "matchCriteriaId": "588069C4-9D69-48F6-913F-2FEB3E643870"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:11.4:*:*:*:*:*:*:*", "matchCriteriaId": "DE554781-1EB9-446E-911F-6C11970C47F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_real_time_extension:11:sp3:*:*:*:*:*:*", "matchCriteriaId": "3DB41B45-D94D-4A58-88B0-B3EC3EC350E2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp2:*:*:ltss:*:*:*", "matchCriteriaId": "CB6476C7-03F2-4939-AB85-69AA524516D9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:10.04:*:*:*:-:*:*:*", "matchCriteriaId": "01EDA41C-6B2E-49AF-B503-EB3882265C11"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.10:*:*:*:*:*:*:*", "matchCriteriaId": "49A63F39-30BE-443F-AF10-6245587D3359"}]}]}], "references": [{"url": "http://blog.securitymouse.com/2014/06/raising-lazarus-20-year-old-bug-that.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=206a81c18401c0cde6e579164f752c4b147324ce", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-03/msg00010.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-03/msg00025.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-04/msg00015.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-0062.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.15.2", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.oberhumer.com/opensource/lzo/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/06/26/21", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/68214", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-2416-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2417-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2418-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2419-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2420-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2421-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1113899", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/206a81c18401c0cde6e579164f752c4b147324ce", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.securitymouse.com/lms-2014-06-16-2", "source": "cve@mitre.org", "tags": ["Broken Link"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/206a81c18401c0cde6e579164f752c4b147324ce"}}