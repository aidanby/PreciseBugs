{"buggy_code": ["/*\n * This file is part of the KeepKey project.\n *\n * Copyright (C) 2015 KeepKey LLC\n *\n * This library is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"keepkey/board/usb.h\"\n#include \"keepkey/board/messages.h\"\n#include \"keepkey/board/variant.h\"\n#include \"keepkey/board/timer.h\"\n#include \"keepkey/board/layout.h\"\n#include \"keepkey/board/util.h\"\n\n#include <nanopb.h>\n\n#include <assert.h>\n#include <string.h>\n\nstatic const MessagesMap_t *MessagesMap = NULL;\nstatic size_t map_size = 0;\nstatic msg_failure_t msg_failure;\n\n#if DEBUG_LINK\nstatic msg_debug_link_get_state_t msg_debug_link_get_state;\n#endif\n\n/* Tiny messages */\nstatic bool msg_tiny_flag = false;\nstatic CONFIDENTIAL uint8_t msg_tiny[MSG_TINY_BFR_SZ];\nstatic uint16_t msg_tiny_id = MSG_TINY_TYPE_ERROR; /* Default to error type */\n\n/* Allow mapped messages to reset message stack.  This variable by itself doesn't\n * do much but messages down the line can use it to determine for to gracefully\n * exit from a message should the message stack been reset\n */\nbool reset_msg_stack = false;\n\n/*\n * message_map_entry() - Finds a requested message map entry\n *\n * INPUT\n *     - type: type of message (normal or debug)\n *     - msg_id: message id\n *     - dir: direction of message\n * OUTPUT\n *     entry if found\n */\nstatic const MessagesMap_t *message_map_entry(MessageMapType type,\n        MessageType msg_id,\n        MessageMapDirection dir)\n{\n    const MessagesMap_t *m = MessagesMap;\n\n    if (map_size > msg_id && m[msg_id].msg_id == msg_id &&\n        m[msg_id].type == type && m[msg_id].dir == dir)\n    {\n        return &m[msg_id];\n    }\n\n    return NULL;\n}\n\n/*\n * message_fields() - Get protocol buffer for requested message map entry\n *\n * INPUT\n *     - type: type of message (normal or debug)\n *     - msg_id: message id\n *     - dir: direction of message\n * OUTPUT\n *      protocol buffer\n */\nconst pb_field_t *message_fields(MessageMapType type, MessageType msg_id,\n                                 MessageMapDirection dir)\n{\n    assert(MessagesMap != NULL);\n\n    const MessagesMap_t *m = MessagesMap;\n\n    if(map_size > msg_id && m[msg_id].msg_id == msg_id && m[msg_id].type == type &&\n            m[msg_id].dir == dir)\n    {\n        return m[msg_id].fields;\n    }\n\n    return NULL;\n}\n\n/*\n * pb_parse() - Process USB message by protocol buffer\n *\n * INPUT\n *     - entry: pointer to message entry\n *     - msg: pointer to received message buffer\n *     - msg_size: size of message\n *     - buf: pointer to destination buffer\n * OUTPUT\n *     true/false whether protocol buffers were parsed successfully\n */\nstatic bool pb_parse(const MessagesMap_t *entry, uint8_t *msg, uint32_t msg_size,\n                     uint8_t *buf)\n{\n    pb_istream_t stream = pb_istream_from_buffer(msg, msg_size);\n    return pb_decode(&stream, entry->fields, buf);\n}\n\n/*\n * dispatch() - Process received message and jump to corresponding process function\n *\n * INPUT\n *     - entry: pointer to message entry\n *     - msg: pointer to received message buffer\n *     - msg_size: size of message\n * OUTPUT\n *     none\n *\n */\nstatic void dispatch(const MessagesMap_t *entry, uint8_t *msg, uint32_t msg_size)\n{\n    static uint8_t decode_buffer[MAX_DECODE_SIZE] __attribute__((aligned(4)));\n    memset(decode_buffer, 0, sizeof(decode_buffer));\n\n    if (!pb_parse(entry, msg, msg_size, decode_buffer)) {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage,\n                       \"Could not parse protocol buffer message\");\n        return;\n    }\n\n    if (!entry->process_func) {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unexpected message\");\n        return;\n    }\n\n    entry->process_func(decode_buffer);\n}\n\n/*\n * tiny_dispatch() - Process received tiny messages\n *\n * INPUT\n *     - entry: pointer to message entry\n *     - msg: pointer to received message buffer\n *     - msg_size: size of message\n * OUTPUT\n *     none\n *\n */\nstatic void tiny_dispatch(const MessagesMap_t *entry, uint8_t *msg, uint32_t msg_size)\n{\n    if (!pb_parse(entry, msg, msg_size, msg_tiny)) {\n        call_msg_failure_handler(FailureType_Failure_UnexpectedMessage,\n                                 \"Could not parse tiny protocol buffer message\");\n        return;\n    }\n\n    msg_tiny_id = entry->msg_id;\n}\n\n/*\n * raw_dispatch() - Process messages that will not be parsed by protocol buffers\n * and should be manually parsed at message function\n *\n * INPUT\n *     - entry: pointer to message entry\n *     - msg: pointer to received message buffer\n *     - msg_size: size of message\n *     - frame_length: total expected size\n * OUTPUT\n *     none\n */\nstatic void raw_dispatch(const MessagesMap_t *entry, const uint8_t *msg, uint32_t msg_size,\n                         uint32_t frame_length)\n{\n    static RawMessage raw_msg;\n    raw_msg.buffer = msg;\n    raw_msg.length = msg_size;\n\n    if(entry->process_func)\n    {\n        ((raw_msg_handler_t)entry->process_func)(&raw_msg, frame_length);\n    }\n}\n\n#if !defined(__has_builtin)\n#  define __has_builtin(X) 0\n#endif\n#if __has_builtin(__builtin_add_overflow)\n#  define check_uadd_overflow(A, B, R) \\\n    ({ \\\n        typeof(A) __a = (A); \\\n        typeof(B) __b = (B); \\\n        typeof(R) __r = (R); \\\n        (void)(&__a == &__b && \"types must match\"); \\\n        (void)(&__a == __r && \"types must match\"); \\\n        _Static_assert(0 < (typeof(A))-1, \"types must be unsigned\"); \\\n        __builtin_add_overflow((A), (B), (R)); \\\n    })\n#else\n#  define check_uadd_overflow(A, B, R) \\\n    ({ \\\n        typeof(A) __a = (A); \\\n        typeof(B) __b = (B); \\\n        typeof(R) __r = (R); \\\n        (void)(&__a == &__b); \\\n        (void)(&__a == __r); \\\n        (void)(&__a == &__b && \"types must match\"); \\\n        (void)(&__a == __r && \"types must match\"); \\\n        _Static_assert(0 < (typeof(A))-1, \"types must be unsigned\"); \\\n        *__r = __a + __b; \\\n        *__r < __a; \\\n    })\n#endif\n\n/// Common helper that handles USB messages from host\nvoid usb_rx_helper(const uint8_t *buf, size_t length, MessageMapType type)\n{\n    static bool firstFrame = true;\n\n    static uint16_t msgId;\n    static uint32_t msgSize;\n    static uint8_t msg[MAX_FRAME_SIZE];\n    static size_t cursor; //< Index into msg where the current frame is to be written.\n    static const MessagesMap_t *entry;\n\n    if (firstFrame) {\n        msgId = 0xffff;\n        msgSize = 0;\n        memset(msg, 0, sizeof(msg));\n        cursor = 0;\n        entry = NULL;\n    }\n\n    assert(buf != NULL);\n\n    if (length < 1 + 2 + 2 + 4) {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Buffer too small\");\n        goto reset;\n    }\n\n    if (buf[0] != '?') {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed packet\");\n        goto reset;\n    }\n\n    if (firstFrame && (buf[1] != '#' || buf[2] != '#')) {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed packet\");\n        goto reset;\n    }\n\n    // Details of the chunk being copied out of the current frame.\n    const uint8_t *frame;\n    size_t frameSize;\n\n    if (firstFrame) {\n        // Reset the buffer that we're writing fragments into.\n        memset(msg, 0, sizeof(msg));\n\n        // Then fish out the id / size, which are big-endian uint16 /\n        // uint32's respectively.\n        msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n        msgSize =    buf[8]        |\n          ((uint32_t)buf[7]) <<  8 |\n          ((uint32_t)buf[6]) << 16 |\n          ((uint32_t)buf[5]) << 24;\n\n        // Determine callback handler and message map type.\n        entry = message_map_entry(type, msgId, IN_MSG);\n\n        // And reset the cursor.\n        cursor = 0;\n\n        // Then take note of the fragment boundaries.\n        frame = &buf[9];\n        frameSize = MIN(length - 9, msgSize);\n    } else {\n        // Otherwise it's a continuation/fragment.\n        frame = &buf[1];\n        frameSize = length - 1;\n    }\n\n    // If the msgId wasn't in our map, bail.\n    if (!entry) {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n        goto reset;\n    }\n\n    if (entry->dispatch == RAW) {\n        /* Call dispatch for every segment since we are not buffering and parsing, and\n         * assume the raw dispatched callbacks will handle their own state and\n         * buffering internally\n         */\n        raw_dispatch(entry, frame, frameSize, msgSize);\n        firstFrame = false;\n        return;\n    }\n\n    size_t end;\n    if (check_uadd_overflow(cursor, frameSize, &end) || sizeof(msg) < end) {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed message\");\n        goto reset;\n    }\n\n    // Copy content to frame buffer.\n    memcpy(&msg[cursor], frame, frameSize);\n\n    // Advance the cursor.\n    cursor = end;\n\n    // Only parse and message map if all segments have been buffered.\n    bool last_segment = cursor >= msgSize;\n    if (!last_segment) {\n        firstFrame = false;\n        return;\n    }\n\n    dispatch(entry, msg, msgSize);\n\nreset:\n    msgId = 0xffff;\n    msgSize = 0;\n    memset(msg, 0, sizeof(msg));\n    cursor = 0;\n    firstFrame = true;\n    entry = NULL;\n}\n\nvoid handle_usb_rx(const void *msg, size_t len)\n{\n    if (msg_tiny_flag) {\n        uint8_t buf[64];\n        memcpy(buf, msg, sizeof(buf));\n\n        uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n        uint32_t msgSize = buf[8]        |\n                ((uint32_t)buf[7]) <<  8 |\n                ((uint32_t)buf[6]) << 16 |\n                ((uint32_t)buf[5]) << 24;\n\n        if (msgSize > 64 - 9) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n            return;\n        }\n\n        // Determine callback handler and message map type.\n        const MessagesMap_t *entry = message_map_entry(NORMAL_MSG, msgId, IN_MSG);\n        if (!entry) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n            return;\n        }\n\n        tiny_dispatch(entry, buf + 9, msgSize);\n    } else {\n        usb_rx_helper(msg, len, NORMAL_MSG);\n    }\n}\n\n#if DEBUG_LINK\nvoid handle_debug_usb_rx(const void *msg, size_t len)\n{\n    if (msg_tiny_flag) {\n        uint8_t buf[64];\n        memcpy(buf, msg, sizeof(buf));\n\n        uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n        uint32_t msgSize = buf[8]        |\n                ((uint32_t)buf[7]) <<  8 |\n                ((uint32_t)buf[6]) << 16 |\n                ((uint32_t)buf[5]) << 24;\n\n        if (msgSize > 64 - 9) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n            return;\n        }\n\n        // Determine callback handler and message map type.\n        const MessagesMap_t *entry = message_map_entry(DEBUG_MSG, msgId, IN_MSG);\n        if (!entry) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n            return;\n        }\n\n        tiny_dispatch(entry, buf + 9, msgSize);\n    } else {\n        usb_rx_helper(msg, len, DEBUG_MSG);\n    }\n}\n#endif\n\n/*\n * tiny_msg_poll_and_buffer() - Poll usb port to check for tiny message from host\n *\n * INPUT\n *     - block: flag to continually poll usb until tiny message is received\n *     - buf: pointer to destination buffer\n * OUTPUT\n *     message type\n *\n */\nstatic MessageType tiny_msg_poll_and_buffer(bool block, uint8_t *buf)\n{\n    msg_tiny_id = MSG_TINY_TYPE_ERROR;\n    msg_tiny_flag = true;\n\n    while(msg_tiny_id == MSG_TINY_TYPE_ERROR)\n    {\n        usbPoll();\n\n        if(!block)\n        {\n            break;\n        }\n    }\n\n    msg_tiny_flag = false;\n\n    if(msg_tiny_id != MSG_TINY_TYPE_ERROR)\n    {\n        memcpy(buf, msg_tiny, sizeof(msg_tiny));\n    }\n\n    return msg_tiny_id;\n}\n\n/*\n * msg_map_init() - Setup message map with corresping message type\n *\n * INPUT\n *     - map: pointer message map array\n *     - size: size of message map\n * OUTPUT\n *\n */\nvoid msg_map_init(const void *map, const size_t size)\n{\n    assert(map != NULL);\n    MessagesMap = map;\n    map_size = size;\n}\n\n/*\n * set_msg_failure_handler() - Setup usb message failure handler\n *\n * INPUT\n *     - failure_func: message failure handler\n * OUTPUT\n *     none\n */\nvoid set_msg_failure_handler(msg_failure_t failure_func)\n{\n    msg_failure = failure_func;\n}\n\n/*\n * set_msg_debug_link_get_state_handler() - Setup usb message debug link get state handler\n *\n * INPUT\n *     - debug_link_get_state_func: message initialization handler\n * OUTPUT\n *     none\n */\n#if DEBUG_LINK\nvoid set_msg_debug_link_get_state_handler(msg_debug_link_get_state_t\n        debug_link_get_state_func)\n{\n    msg_debug_link_get_state = debug_link_get_state_func;\n}\n#endif\n\n/*\n * call_msg_failure_handler() - Call message failure handler\n *\n * INPUT\n *     - code: failure code\n *     - text: pinter to function arguments\n * OUTPUT\n *     none\n */\nvoid call_msg_failure_handler(FailureType code, const char *text)\n{\n    if(msg_failure)\n    {\n        (*msg_failure)(code, text);\n    }\n}\n\n/*\n * call_msg_debug_link_get_state_handler() - Call message debug link get state handler\n *\n * INPUT\n *     none\n * OUTPUT\n *     none\n */\n#if DEBUG_LINK\nvoid call_msg_debug_link_get_state_handler(DebugLinkGetState *msg)\n{\n    if(msg_debug_link_get_state)\n    {\n        (*msg_debug_link_get_state)(msg);\n    }\n}\n#endif\n\n/*\n * msg_init() - Setup usb receive callback handler\n *\n * INPUT\n *     none\n * OUTPUT\n *     none\n */\nvoid msg_init(void)\n{\n    usb_set_rx_callback(handle_usb_rx);\n#if DEBUG_LINK\n    usb_set_debug_rx_callback(handle_debug_usb_rx);\n#endif\n}\n\n/*\n * wait_for_tiny_msg() - Wait for usb tiny message type from host\n *\n * INPUT\n *     - buf: pointer to destination buffer\n * OUTPUT\n *     message tiny type\n *\n */\nMessageType wait_for_tiny_msg(uint8_t *buf)\n{\n    return tiny_msg_poll_and_buffer(true, buf);\n}\n\n/*\n * check_for_tiny_msg() - Check for usb tiny message type from host\n *\n * INPUT\n *     - buf: pointer to destination buffer\n * OUTPUT\n *     message tiny type\n *\n */\nMessageType check_for_tiny_msg(uint8_t *buf)\n{\n    return tiny_msg_poll_and_buffer(false, buf);\n}\n\n/*\n * parse_pb_varint() - Parses varints off of raw messages\n *\n * INPUT\n *     - msg: pointer to raw message\n *     - varint_count: how many varints to remove\n * OUTPUT\n *     bytes that were skipped\n */\nuint32_t parse_pb_varint(RawMessage *msg, uint8_t varint_count)\n{\n    uint32_t skip;\n    uint8_t i;\n    uint64_t pb_varint;\n    pb_istream_t stream;\n\n    /*\n     * Parse varints\n     */\n    stream = pb_istream_from_buffer((uint8_t*)msg->buffer, msg->length);\n    skip = stream.bytes_left;\n    for(i = 0; i < varint_count; ++i)\n    {\n        pb_decode_varint(&stream, &pb_varint);\n    }\n    skip = skip - stream.bytes_left;\n\n    /*\n     * Increment skip over message\n     */\n    msg->length -= skip;\n    msg->buffer = (uint8_t *)(msg->buffer + skip);\n\n    return skip;\n}\n\n/*\n * encode_pb() - convert to raw pb data\n *\n * INPUT\n *     - source_ptr : pointer to struct\n *     - fields: pointer pb fields\n *     - *buffer: pointer to destination buffer\n *     - len: size of buffer\n * OUTPUT\n *     bytes written to buffer\n */\nint encode_pb(const void *source_ptr, const pb_field_t *fields,  uint8_t *buffer, uint32_t len )\n{\n    pb_ostream_t os = pb_ostream_from_buffer(buffer, len);\n\n    if (!pb_encode(&os, fields, source_ptr))\n        return 0;\n\n    return os.bytes_written;\n}\n"], "fixing_code": ["/*\n * This file is part of the KeepKey project.\n *\n * Copyright (C) 2015 KeepKey LLC\n *\n * This library is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"keepkey/board/usb.h\"\n#include \"keepkey/board/messages.h\"\n#include \"keepkey/board/variant.h\"\n#include \"keepkey/board/timer.h\"\n#include \"keepkey/board/layout.h\"\n#include \"keepkey/board/util.h\"\n\n#include <nanopb.h>\n\n#include <assert.h>\n#include <string.h>\n\nstatic const MessagesMap_t *MessagesMap = NULL;\nstatic size_t map_size = 0;\nstatic msg_failure_t msg_failure;\n\n#if DEBUG_LINK\nstatic msg_debug_link_get_state_t msg_debug_link_get_state;\n#endif\n\n/* Allow mapped messages to reset message stack.  This variable by itself doesn't\n * do much but messages down the line can use it to determine for to gracefully\n * exit from a message should the message stack been reset\n */\nbool reset_msg_stack = false;\n\n/*\n * message_map_entry() - Finds a requested message map entry\n *\n * INPUT\n *     - type: type of message (normal or debug)\n *     - msg_id: message id\n *     - dir: direction of message\n * OUTPUT\n *     entry if found\n */\nstatic const MessagesMap_t *message_map_entry(MessageMapType type,\n        MessageType msg_id,\n        MessageMapDirection dir)\n{\n    const MessagesMap_t *m = MessagesMap;\n\n    if (map_size > msg_id && m[msg_id].msg_id == msg_id &&\n        m[msg_id].type == type && m[msg_id].dir == dir)\n    {\n        return &m[msg_id];\n    }\n\n    return NULL;\n}\n\n/*\n * message_fields() - Get protocol buffer for requested message map entry\n *\n * INPUT\n *     - type: type of message (normal or debug)\n *     - msg_id: message id\n *     - dir: direction of message\n * OUTPUT\n *      protocol buffer\n */\nconst pb_field_t *message_fields(MessageMapType type, MessageType msg_id,\n                                 MessageMapDirection dir)\n{\n    assert(MessagesMap != NULL);\n\n    const MessagesMap_t *m = MessagesMap;\n\n    if(map_size > msg_id && m[msg_id].msg_id == msg_id && m[msg_id].type == type &&\n            m[msg_id].dir == dir)\n    {\n        return m[msg_id].fields;\n    }\n\n    return NULL;\n}\n\n/*\n * pb_parse() - Process USB message by protocol buffer\n *\n * INPUT\n *     - entry: pointer to message entry\n *     - msg: pointer to received message buffer\n *     - msg_size: size of message\n *     - buf: pointer to destination buffer\n * OUTPUT\n *     true/false whether protocol buffers were parsed successfully\n */\nstatic bool pb_parse(const MessagesMap_t *entry, uint8_t *msg, uint32_t msg_size,\n                     uint8_t *buf)\n{\n    pb_istream_t stream = pb_istream_from_buffer(msg, msg_size);\n    return pb_decode(&stream, entry->fields, buf);\n}\n\n/*\n * dispatch() - Process received message and jump to corresponding process function\n *\n * INPUT\n *     - entry: pointer to message entry\n *     - msg: pointer to received message buffer\n *     - msg_size: size of message\n * OUTPUT\n *     none\n *\n */\nstatic void dispatch(const MessagesMap_t *entry, uint8_t *msg, uint32_t msg_size)\n{\n    static uint8_t decode_buffer[MAX_DECODE_SIZE] __attribute__((aligned(4)));\n    memset(decode_buffer, 0, sizeof(decode_buffer));\n\n    if (!pb_parse(entry, msg, msg_size, decode_buffer)) {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage,\n                       \"Could not parse protocol buffer message\");\n        return;\n    }\n\n    if (!entry->process_func) {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unexpected message\");\n        return;\n    }\n\n    entry->process_func(decode_buffer);\n}\n\n/*\n * raw_dispatch() - Process messages that will not be parsed by protocol buffers\n * and should be manually parsed at message function\n *\n * INPUT\n *     - entry: pointer to message entry\n *     - msg: pointer to received message buffer\n *     - msg_size: size of message\n *     - frame_length: total expected size\n * OUTPUT\n *     none\n */\nstatic void raw_dispatch(const MessagesMap_t *entry, const uint8_t *msg, uint32_t msg_size,\n                         uint32_t frame_length)\n{\n    static RawMessage raw_msg;\n    raw_msg.buffer = msg;\n    raw_msg.length = msg_size;\n\n    if(entry->process_func)\n    {\n        ((raw_msg_handler_t)entry->process_func)(&raw_msg, frame_length);\n    }\n}\n\n#if !defined(__has_builtin)\n#  define __has_builtin(X) 0\n#endif\n#if __has_builtin(__builtin_add_overflow)\n#  define check_uadd_overflow(A, B, R) \\\n    ({ \\\n        typeof(A) __a = (A); \\\n        typeof(B) __b = (B); \\\n        typeof(R) __r = (R); \\\n        (void)(&__a == &__b && \"types must match\"); \\\n        (void)(&__a == __r && \"types must match\"); \\\n        _Static_assert(0 < (typeof(A))-1, \"types must be unsigned\"); \\\n        __builtin_add_overflow((A), (B), (R)); \\\n    })\n#else\n#  define check_uadd_overflow(A, B, R) \\\n    ({ \\\n        typeof(A) __a = (A); \\\n        typeof(B) __b = (B); \\\n        typeof(R) __r = (R); \\\n        (void)(&__a == &__b); \\\n        (void)(&__a == __r); \\\n        (void)(&__a == &__b && \"types must match\"); \\\n        (void)(&__a == __r && \"types must match\"); \\\n        _Static_assert(0 < (typeof(A))-1, \"types must be unsigned\"); \\\n        *__r = __a + __b; \\\n        *__r < __a; \\\n    })\n#endif\n\n/// Common helper that handles USB messages from host\nvoid usb_rx_helper(const uint8_t *buf, size_t length, MessageMapType type)\n{\n    static bool firstFrame = true;\n\n    static uint16_t msgId;\n    static uint32_t msgSize;\n    static uint8_t msg[MAX_FRAME_SIZE];\n    static size_t cursor; //< Index into msg where the current frame is to be written.\n    static const MessagesMap_t *entry;\n\n    if (firstFrame) {\n        msgId = 0xffff;\n        msgSize = 0;\n        memset(msg, 0, sizeof(msg));\n        cursor = 0;\n        entry = NULL;\n    }\n\n    assert(buf != NULL);\n\n    if (length < 1 + 2 + 2 + 4) {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Buffer too small\");\n        goto reset;\n    }\n\n    if (buf[0] != '?') {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed packet\");\n        goto reset;\n    }\n\n    if (firstFrame && (buf[1] != '#' || buf[2] != '#')) {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed packet\");\n        goto reset;\n    }\n\n    // Details of the chunk being copied out of the current frame.\n    const uint8_t *frame;\n    size_t frameSize;\n\n    if (firstFrame) {\n        // Reset the buffer that we're writing fragments into.\n        memset(msg, 0, sizeof(msg));\n\n        // Then fish out the id / size, which are big-endian uint16 /\n        // uint32's respectively.\n        msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n        msgSize =    buf[8]        |\n          ((uint32_t)buf[7]) <<  8 |\n          ((uint32_t)buf[6]) << 16 |\n          ((uint32_t)buf[5]) << 24;\n\n        // Determine callback handler and message map type.\n        entry = message_map_entry(type, msgId, IN_MSG);\n\n        // And reset the cursor.\n        cursor = 0;\n\n        // Then take note of the fragment boundaries.\n        frame = &buf[9];\n        frameSize = MIN(length - 9, msgSize);\n    } else {\n        // Otherwise it's a continuation/fragment.\n        frame = &buf[1];\n        frameSize = length - 1;\n    }\n\n    // If the msgId wasn't in our map, bail.\n    if (!entry) {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n        goto reset;\n    }\n\n    if (entry->dispatch == RAW) {\n        /* Call dispatch for every segment since we are not buffering and parsing, and\n         * assume the raw dispatched callbacks will handle their own state and\n         * buffering internally\n         */\n        raw_dispatch(entry, frame, frameSize, msgSize);\n        firstFrame = false;\n        return;\n    }\n\n    size_t end;\n    if (check_uadd_overflow(cursor, frameSize, &end) || sizeof(msg) < end) {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed message\");\n        goto reset;\n    }\n\n    // Copy content to frame buffer.\n    memcpy(&msg[cursor], frame, frameSize);\n\n    // Advance the cursor.\n    cursor = end;\n\n    // Only parse and message map if all segments have been buffered.\n    bool last_segment = cursor >= msgSize;\n    if (!last_segment) {\n        firstFrame = false;\n        return;\n    }\n\n    dispatch(entry, msg, msgSize);\n\nreset:\n    msgId = 0xffff;\n    msgSize = 0;\n    memset(msg, 0, sizeof(msg));\n    cursor = 0;\n    firstFrame = true;\n    entry = NULL;\n}\n\n/* Tiny messages */\nstatic bool msg_tiny_flag = false;\nstatic CONFIDENTIAL uint8_t msg_tiny[MSG_TINY_BFR_SZ];\nstatic uint16_t msg_tiny_id = MSG_TINY_TYPE_ERROR; /* Default to error type */\n\n_Static_assert(sizeof(msg_tiny) >= sizeof(Cancel), \"msg_tiny too tiny\");\n_Static_assert(sizeof(msg_tiny) >= sizeof(Initialize), \"msg_tiny too tiny\");\n_Static_assert(sizeof(msg_tiny) >= sizeof(PassphraseAck), \"msg_tiny too tiny\");\n_Static_assert(sizeof(msg_tiny) >= sizeof(ButtonAck), \"msg_tiny too tiny\");\n_Static_assert(sizeof(msg_tiny) >= sizeof(PinMatrixAck), \"msg_tiny too tiny\");\n#if DEBUG_LINK\n_Static_assert(sizeof(msg_tiny) >= sizeof(DebugLinkDecision),\n               \"msg_tiny too tiny\");\n_Static_assert(sizeof(msg_tiny) >= sizeof(DebugLinkGetState),\n               \"msg_tiny too tiny\");\n#endif\n\nstatic void msg_read_tiny(const uint8_t *msg, size_t len) {\n    if (len != 64)\n        return;\n\n    uint8_t buf[64];\n    memcpy(buf, msg, sizeof(buf));\n\n    if (buf[0] != '?' || buf[1] != '#' || buf[2] != '#') {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n        return;\n    }\n\n    uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n    uint32_t msgSize = buf[8]        |\n            ((uint32_t)buf[7]) <<  8 |\n            ((uint32_t)buf[6]) << 16 |\n            ((uint32_t)buf[5]) << 24;\n\n    if (msgSize > 64 - 9) {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n        return;\n    }\n\n    const pb_field_t *fields = NULL;\n    pb_istream_t stream = pb_istream_from_buffer(buf + 9, msgSize);\n\n    switch (msgId) {\n    case MessageType_MessageType_PinMatrixAck:\n        fields = PinMatrixAck_fields;\n        break;\n    case MessageType_MessageType_ButtonAck:\n        fields = ButtonAck_fields;\n        break;\n    case MessageType_MessageType_PassphraseAck:\n        fields = PassphraseAck_fields;\n        break;\n    case MessageType_MessageType_Cancel:\n        fields = Cancel_fields;\n        break;\n    case MessageType_MessageType_Initialize:\n        fields = Initialize_fields;\n        break;\n#if DEBUG_LINK\n    case MessageType_MessageType_DebugLinkDecision:\n        fields = DebugLinkDecision_fields;\n        break;\n    case MessageType_MessageType_DebugLinkGetState:\n        fields = DebugLinkGetState_fields;\n        break;\n#endif\n    }\n\n    if (fields) {\n        bool status = pb_decode(&stream, fields, msg_tiny);\n        if (status) {\n            msg_tiny_id = msgId;\n        } else {\n            (*msg_failure)(FailureType_Failure_SyntaxError, stream.errmsg);\n            msg_tiny_id = 0xffff;\n        }\n    } else {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n        msg_tiny_id = 0xffff;\n    }\n}\n\nvoid handle_usb_rx(const void *msg, size_t len)\n{\n    if (msg_tiny_flag) {\n        msg_read_tiny(msg, len);\n    } else {\n        usb_rx_helper(msg, len, NORMAL_MSG);\n    }\n}\n\n#if DEBUG_LINK\nvoid handle_debug_usb_rx(const void *msg, size_t len)\n{\n    if (msg_tiny_flag) {\n        msg_read_tiny(msg, len);\n    } else {\n        usb_rx_helper(msg, len, DEBUG_MSG);\n    }\n}\n#endif\n\n/*\n * tiny_msg_poll_and_buffer() - Poll usb port to check for tiny message from host\n *\n * INPUT\n *     - block: flag to continually poll usb until tiny message is received\n *     - buf: pointer to destination buffer\n * OUTPUT\n *     message type\n *\n */\nstatic MessageType tiny_msg_poll_and_buffer(bool block, uint8_t *buf)\n{\n    msg_tiny_id = MSG_TINY_TYPE_ERROR;\n    msg_tiny_flag = true;\n\n    while(msg_tiny_id == MSG_TINY_TYPE_ERROR)\n    {\n        usbPoll();\n\n        if(!block)\n        {\n            break;\n        }\n    }\n\n    msg_tiny_flag = false;\n\n    if(msg_tiny_id != MSG_TINY_TYPE_ERROR)\n    {\n        memcpy(buf, msg_tiny, sizeof(msg_tiny));\n    }\n\n    return msg_tiny_id;\n}\n\n/*\n * msg_map_init() - Setup message map with corresping message type\n *\n * INPUT\n *     - map: pointer message map array\n *     - size: size of message map\n * OUTPUT\n *\n */\nvoid msg_map_init(const void *map, const size_t size)\n{\n    assert(map != NULL);\n    MessagesMap = map;\n    map_size = size;\n}\n\n/*\n * set_msg_failure_handler() - Setup usb message failure handler\n *\n * INPUT\n *     - failure_func: message failure handler\n * OUTPUT\n *     none\n */\nvoid set_msg_failure_handler(msg_failure_t failure_func)\n{\n    msg_failure = failure_func;\n}\n\n/*\n * set_msg_debug_link_get_state_handler() - Setup usb message debug link get state handler\n *\n * INPUT\n *     - debug_link_get_state_func: message initialization handler\n * OUTPUT\n *     none\n */\n#if DEBUG_LINK\nvoid set_msg_debug_link_get_state_handler(msg_debug_link_get_state_t\n        debug_link_get_state_func)\n{\n    msg_debug_link_get_state = debug_link_get_state_func;\n}\n#endif\n\n/*\n * call_msg_failure_handler() - Call message failure handler\n *\n * INPUT\n *     - code: failure code\n *     - text: pinter to function arguments\n * OUTPUT\n *     none\n */\nvoid call_msg_failure_handler(FailureType code, const char *text)\n{\n    if(msg_failure)\n    {\n        (*msg_failure)(code, text);\n    }\n}\n\n/*\n * call_msg_debug_link_get_state_handler() - Call message debug link get state handler\n *\n * INPUT\n *     none\n * OUTPUT\n *     none\n */\n#if DEBUG_LINK\nvoid call_msg_debug_link_get_state_handler(DebugLinkGetState *msg)\n{\n    if(msg_debug_link_get_state)\n    {\n        (*msg_debug_link_get_state)(msg);\n    }\n}\n#endif\n\n/*\n * msg_init() - Setup usb receive callback handler\n *\n * INPUT\n *     none\n * OUTPUT\n *     none\n */\nvoid msg_init(void)\n{\n    usb_set_rx_callback(handle_usb_rx);\n#if DEBUG_LINK\n    usb_set_debug_rx_callback(handle_debug_usb_rx);\n#endif\n}\n\n/*\n * wait_for_tiny_msg() - Wait for usb tiny message type from host\n *\n * INPUT\n *     - buf: pointer to destination buffer\n * OUTPUT\n *     message tiny type\n *\n */\nMessageType wait_for_tiny_msg(uint8_t *buf)\n{\n    return tiny_msg_poll_and_buffer(true, buf);\n}\n\n/*\n * check_for_tiny_msg() - Check for usb tiny message type from host\n *\n * INPUT\n *     - buf: pointer to destination buffer\n * OUTPUT\n *     message tiny type\n *\n */\nMessageType check_for_tiny_msg(uint8_t *buf)\n{\n    return tiny_msg_poll_and_buffer(false, buf);\n}\n\n/*\n * parse_pb_varint() - Parses varints off of raw messages\n *\n * INPUT\n *     - msg: pointer to raw message\n *     - varint_count: how many varints to remove\n * OUTPUT\n *     bytes that were skipped\n */\nuint32_t parse_pb_varint(RawMessage *msg, uint8_t varint_count)\n{\n    uint32_t skip;\n    uint8_t i;\n    uint64_t pb_varint;\n    pb_istream_t stream;\n\n    /*\n     * Parse varints\n     */\n    stream = pb_istream_from_buffer((uint8_t*)msg->buffer, msg->length);\n    skip = stream.bytes_left;\n    for(i = 0; i < varint_count; ++i)\n    {\n        pb_decode_varint(&stream, &pb_varint);\n    }\n    skip = skip - stream.bytes_left;\n\n    /*\n     * Increment skip over message\n     */\n    msg->length -= skip;\n    msg->buffer = (uint8_t *)(msg->buffer + skip);\n\n    return skip;\n}\n\n/*\n * encode_pb() - convert to raw pb data\n *\n * INPUT\n *     - source_ptr : pointer to struct\n *     - fields: pointer pb fields\n *     - *buffer: pointer to destination buffer\n *     - len: size of buffer\n * OUTPUT\n *     bytes written to buffer\n */\nint encode_pb(const void *source_ptr, const pb_field_t *fields,  uint8_t *buffer, uint32_t len )\n{\n    pb_ostream_t os = pb_ostream_from_buffer(buffer, len);\n\n    if (!pb_encode(&os, fields, source_ptr))\n        return 0;\n\n    return os.bytes_written;\n}\n"], "filenames": ["lib/board/messages.c"], "buggy_code_start_loc": [40], "buggy_code_end_loc": [396], "fixing_code_start_loc": [39], "fixing_code_end_loc": [410], "type": "CWE-787", "message": "Insufficient checks in the USB packet handling of the ShapeShift KeepKey hardware wallet before firmware 6.2.2 allow out-of-bounds writes in the .bss segment via crafted messages. The vulnerability could allow code execution or other forms of impact. It can be triggered by unauthenticated attackers and the interface is reachable via WebUSB.", "other": {"cve": {"id": "CVE-2019-18671", "sourceIdentifier": "cve@mitre.org", "published": "2019-12-06T18:15:12.653", "lastModified": "2020-02-12T03:15:10.943", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Insufficient checks in the USB packet handling of the ShapeShift KeepKey hardware wallet before firmware 6.2.2 allow out-of-bounds writes in the .bss segment via crafted messages. The vulnerability could allow code execution or other forms of impact. It can be triggered by unauthenticated attackers and the interface is reachable via WebUSB."}, {"lang": "es", "value": "Las comprobaciones insuficientes en el manejo de paquetes USB de la billetera de hardware ShapeShift KeepKey anteriores a firmware 6.2.2 permiten escrituras fuera de l\u00edmites en el segmento .bss a trav\u00e9s de mensajes especialmente dise\u00f1ados. La vulnerabilidad podr\u00eda permitir la ejecuci\u00f3n de c\u00f3digo u otras formas de impacto. Puede ser activado por atacantes no autenticados y se puede acceder a la interfaz a trav\u00e9s de WebUSB."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:keepkey:keepkey_firmware:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.2.2", "matchCriteriaId": "60AB201E-BAD5-466A-8896-F17EDC53E75E"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:keepkey:keepkey:-:*:*:*:*:*:*:*", "matchCriteriaId": "31C93828-4A0A-4B05-BFE3-9B795EAA0872"}]}]}], "references": [{"url": "https://blog.inhq.net/posts/keepkey-CVE-2019-18671/", "source": "cve@mitre.org"}, {"url": "https://github.com/keepkey/keepkey-firmware/commit/b222c66cdd7c3203d917c80ba615082d309d80c3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://medium.com/shapeshift-stories/keepkey-release-notes-v-6f7d2ec78065", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://medium.com/shapeshift-stories/shapeshift-security-update-8ec89bb1b4e3", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/keepkey/keepkey-firmware/commit/b222c66cdd7c3203d917c80ba615082d309d80c3"}}