{"buggy_code": ["/*\n * Audible AA demuxer\n * Copyright (c) 2015 Vesselin Bontchev\n *\n * Header parsing is borrowed from https://github.com/jteeuwen/audible project.\n * Copyright (c) 2001-2014, Jim Teeuwen\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"avformat.h\"\n#include \"internal.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/tea.h\"\n#include \"libavutil/opt.h\"\n\n#define AA_MAGIC 1469084982 /* this identifies an audible .aa file */\n#define MAX_CODEC_SECOND_SIZE 3982\n#define MAX_TOC_ENTRIES 16\n#define MAX_DICTIONARY_ENTRIES 128\n#define TEA_BLOCK_SIZE 8\n#define CHAPTER_HEADER_SIZE 8\n#define TIMEPREC 1000\n#define MP3_FRAME_SIZE 104\n\ntypedef struct AADemuxContext {\n    AVClass *class;\n    uint8_t *aa_fixed_key;\n    int aa_fixed_key_len;\n    int codec_second_size;\n    int current_codec_second_size;\n    int chapter_idx;\n    struct AVTEA *tea_ctx;\n    uint8_t file_key[16];\n    int64_t current_chapter_size;\n    int64_t content_start;\n    int64_t content_end;\n    int seek_offset;\n} AADemuxContext;\n\nstatic int get_second_size(char *codec_name)\n{\n    int result = -1;\n\n    if (!strcmp(codec_name, \"mp332\")) {\n        result = 3982;\n    } else if (!strcmp(codec_name, \"acelp16\")) {\n        result = 2000;\n    } else if (!strcmp(codec_name, \"acelp85\")) {\n        result = 1045;\n    }\n\n    return result;\n}\n\nstatic int aa_read_header(AVFormatContext *s)\n{\n    int i, j, idx, largest_idx = -1;\n    uint32_t nkey, nval, toc_size, npairs, header_seed = 0, start;\n    char key[128], val[128], codec_name[64] = {0};\n    uint8_t output[24], dst[8], src[8];\n    int64_t largest_size = -1, current_size = -1, chapter_pos;\n    struct toc_entry {\n        uint32_t offset;\n        uint32_t size;\n    } TOC[MAX_TOC_ENTRIES];\n    uint32_t header_key_part[4];\n    uint8_t header_key[16] = {0};\n    AADemuxContext *c = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n\n    /* parse .aa header */\n    avio_skip(pb, 4); // file size\n    avio_skip(pb, 4); // magic string\n    toc_size = avio_rb32(pb); // TOC size\n    avio_skip(pb, 4); // unidentified integer\n    if (toc_size > MAX_TOC_ENTRIES)\n        return AVERROR_INVALIDDATA;\n    for (i = 0; i < toc_size; i++) { // read TOC\n        avio_skip(pb, 4); // TOC entry index\n        TOC[i].offset = avio_rb32(pb); // block offset\n        TOC[i].size = avio_rb32(pb); // block size\n    }\n    avio_skip(pb, 24); // header termination block (ignored)\n    npairs = avio_rb32(pb); // read dictionary entries\n    if (npairs > MAX_DICTIONARY_ENTRIES)\n        return AVERROR_INVALIDDATA;\n    for (i = 0; i < npairs; i++) {\n        memset(val, 0, sizeof(val));\n        memset(key, 0, sizeof(key));\n        avio_skip(pb, 1); // unidentified integer\n        nkey = avio_rb32(pb); // key string length\n        nval = avio_rb32(pb); // value string length\n        avio_get_str(pb, nkey, key, sizeof(key));\n        avio_get_str(pb, nval, val, sizeof(val));\n        if (!strcmp(key, \"codec\")) {\n            av_log(s, AV_LOG_DEBUG, \"Codec is <%s>\\n\", val);\n            strncpy(codec_name, val, sizeof(codec_name) - 1);\n        } else if (!strcmp(key, \"HeaderSeed\")) {\n            av_log(s, AV_LOG_DEBUG, \"HeaderSeed is <%s>\\n\", val);\n            header_seed = atoi(val);\n        } else if (!strcmp(key, \"HeaderKey\")) { // this looks like \"1234567890 1234567890 1234567890 1234567890\"\n            av_log(s, AV_LOG_DEBUG, \"HeaderKey is <%s>\\n\", val);\n            sscanf(val, \"%\"SCNu32\"%\"SCNu32\"%\"SCNu32\"%\"SCNu32,\n                   &header_key_part[0], &header_key_part[1], &header_key_part[2], &header_key_part[3]);\n            for (idx = 0; idx < 4; idx++) {\n                AV_WB32(&header_key[idx * 4], header_key_part[idx]); // convert each part to BE!\n            }\n            av_log(s, AV_LOG_DEBUG, \"Processed HeaderKey is \");\n            for (i = 0; i < 16; i++)\n                av_log(s, AV_LOG_DEBUG, \"%02x\", header_key[i]);\n            av_log(s, AV_LOG_DEBUG, \"\\n\");\n        } else {\n            av_dict_set(&s->metadata, key, val, 0);\n        }\n    }\n\n    /* verify fixed key */\n    if (c->aa_fixed_key_len != 16) {\n        av_log(s, AV_LOG_ERROR, \"aa_fixed_key value needs to be 16 bytes!\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    /* verify codec */\n    if ((c->codec_second_size = get_second_size(codec_name)) == -1) {\n        av_log(s, AV_LOG_ERROR, \"unknown codec <%s>!\\n\", codec_name);\n        return AVERROR(EINVAL);\n    }\n\n    /* decryption key derivation */\n    c->tea_ctx = av_tea_alloc();\n    if (!c->tea_ctx)\n        return AVERROR(ENOMEM);\n    av_tea_init(c->tea_ctx, c->aa_fixed_key, 16);\n    output[0] = output[1] = 0; // purely for padding purposes\n    memcpy(output + 2, header_key, 16);\n    idx = 0;\n    for (i = 0; i < 3; i++) { // TEA CBC with weird mixed endianness\n        AV_WB32(src, header_seed);\n        AV_WB32(src + 4, header_seed + 1);\n        header_seed += 2;\n        av_tea_crypt(c->tea_ctx, dst, src, 1, NULL, 0); // TEA ECB encrypt\n        for (j = 0; j < TEA_BLOCK_SIZE && idx < 18; j+=1, idx+=1) {\n            output[idx] = output[idx] ^ dst[j];\n        }\n    }\n    memcpy(c->file_key, output + 2, 16); // skip first 2 bytes of output\n    av_log(s, AV_LOG_DEBUG, \"File key is \");\n    for (i = 0; i < 16; i++)\n        av_log(s, AV_LOG_DEBUG, \"%02x\", c->file_key[i]);\n    av_log(s, AV_LOG_DEBUG, \"\\n\");\n\n    /* decoder setup */\n    st = avformat_new_stream(s, NULL);\n    if (!st) {\n        av_freep(&c->tea_ctx);\n        return AVERROR(ENOMEM);\n    }\n    st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n    if (!strcmp(codec_name, \"mp332\")) {\n        st->codecpar->codec_id = AV_CODEC_ID_MP3;\n        st->codecpar->sample_rate = 22050;\n        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;\n        avpriv_set_pts_info(st, 64, 8, 32000 * TIMEPREC);\n        // encoded audio frame is MP3_FRAME_SIZE bytes (+1 with padding, unlikely)\n    } else if (!strcmp(codec_name, \"acelp85\")) {\n        st->codecpar->codec_id = AV_CODEC_ID_SIPR;\n        st->codecpar->block_align = 19;\n        st->codecpar->channels = 1;\n        st->codecpar->sample_rate = 8500;\n        st->codecpar->bit_rate = 8500;\n        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;\n        avpriv_set_pts_info(st, 64, 8, 8500 * TIMEPREC);\n    } else if (!strcmp(codec_name, \"acelp16\")) {\n        st->codecpar->codec_id = AV_CODEC_ID_SIPR;\n        st->codecpar->block_align = 20;\n        st->codecpar->channels = 1;\n        st->codecpar->sample_rate = 16000;\n        st->codecpar->bit_rate = 16000;\n        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;\n        avpriv_set_pts_info(st, 64, 8, 16000 * TIMEPREC);\n    }\n\n    /* determine, and jump to audio start offset */\n    for (i = 1; i < toc_size; i++) { // skip the first entry!\n        current_size = TOC[i].size;\n        if (current_size > largest_size) {\n            largest_idx = i;\n            largest_size = current_size;\n        }\n    }\n    start = TOC[largest_idx].offset;\n    avio_seek(pb, start, SEEK_SET);\n\n    // extract chapter positions. since all formats have constant bit rate, use it\n    // as time base in bytes/s, for easy stream position <-> timestamp conversion\n    st->start_time = 0;\n    c->content_start = start;\n    c->content_end = start + largest_size;\n\n    while ((chapter_pos = avio_tell(pb)) >= 0 && chapter_pos < c->content_end) {\n        int chapter_idx = s->nb_chapters;\n        uint32_t chapter_size = avio_rb32(pb);\n        if (chapter_size == 0) break;\n        chapter_pos -= start + CHAPTER_HEADER_SIZE * chapter_idx;\n        avio_skip(pb, 4 + chapter_size);\n        if (!avpriv_new_chapter(s, chapter_idx, st->time_base,\n            chapter_pos * TIMEPREC, (chapter_pos + chapter_size) * TIMEPREC, NULL))\n                return AVERROR(ENOMEM);\n    }\n\n    st->duration = (largest_size - CHAPTER_HEADER_SIZE * s->nb_chapters) * TIMEPREC;\n\n    ff_update_cur_dts(s, st, 0);\n    avio_seek(pb, start, SEEK_SET);\n    c->current_chapter_size = 0;\n    c->seek_offset = 0;\n\n    return 0;\n}\n\nstatic int aa_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    uint8_t dst[TEA_BLOCK_SIZE];\n    uint8_t src[TEA_BLOCK_SIZE];\n    int i;\n    int trailing_bytes;\n    int blocks;\n    uint8_t buf[MAX_CODEC_SECOND_SIZE * 2];\n    int written = 0;\n    int ret;\n    AADemuxContext *c = s->priv_data;\n    uint64_t pos = avio_tell(s->pb);\n\n    // are we at the end of the audio content?\n    if (pos >= c->content_end) {\n        return AVERROR_EOF;\n    }\n\n    // are we at the start of a chapter?\n    if (c->current_chapter_size == 0) {\n        c->current_chapter_size = avio_rb32(s->pb);\n        if (c->current_chapter_size == 0) {\n            return AVERROR_EOF;\n        }\n        av_log(s, AV_LOG_DEBUG, \"Chapter %d (%\" PRId64 \" bytes)\\n\", c->chapter_idx, c->current_chapter_size);\n        c->chapter_idx = c->chapter_idx + 1;\n        avio_skip(s->pb, 4); // data start offset\n        pos += 8;\n        c->current_codec_second_size = c->codec_second_size;\n    }\n\n    // is this the last block in this chapter?\n    if (c->current_chapter_size / c->current_codec_second_size == 0) {\n        c->current_codec_second_size = c->current_chapter_size % c->current_codec_second_size;\n    }\n\n    // decrypt c->current_codec_second_size bytes\n    blocks = c->current_codec_second_size / TEA_BLOCK_SIZE;\n    for (i = 0; i < blocks; i++) {\n        ret = avio_read(s->pb, src, TEA_BLOCK_SIZE);\n        if (ret != TEA_BLOCK_SIZE)\n            return (ret < 0) ? ret : AVERROR_EOF;\n        av_tea_init(c->tea_ctx, c->file_key, 16);\n        av_tea_crypt(c->tea_ctx, dst, src, 1, NULL, 1);\n        memcpy(buf + written, dst, TEA_BLOCK_SIZE);\n        written = written + TEA_BLOCK_SIZE;\n    }\n    trailing_bytes = c->current_codec_second_size % TEA_BLOCK_SIZE;\n    if (trailing_bytes != 0) { // trailing bytes are left unencrypted!\n        ret = avio_read(s->pb, src, trailing_bytes);\n        if (ret != trailing_bytes)\n            return (ret < 0) ? ret : AVERROR_EOF;\n        memcpy(buf + written, src, trailing_bytes);\n        written = written + trailing_bytes;\n    }\n\n    // update state\n    c->current_chapter_size = c->current_chapter_size - c->current_codec_second_size;\n    if (c->current_chapter_size <= 0)\n        c->current_chapter_size = 0;\n\n    if (c->seek_offset > written)\n        c->seek_offset = 0; // ignore wrong estimate\n\n    ret = av_new_packet(pkt, written - c->seek_offset);\n    if (ret < 0)\n        return ret;\n    memcpy(pkt->data, buf + c->seek_offset, written - c->seek_offset);\n    pkt->pos = pos;\n\n    c->seek_offset = 0;\n    return 0;\n}\n\nstatic int aa_read_seek(AVFormatContext *s,\n                        int stream_index, int64_t timestamp, int flags)\n{\n    AADemuxContext *c = s->priv_data;\n    AVChapter *ch;\n    int64_t chapter_pos, chapter_start, chapter_size;\n    int chapter_idx = 0;\n\n    // find chapter containing seek timestamp\n    if (timestamp < 0)\n        timestamp = 0;\n\n    while (chapter_idx < s->nb_chapters && timestamp >= s->chapters[chapter_idx]->end) {\n        ++chapter_idx;\n    }\n\n    if (chapter_idx >= s->nb_chapters) {\n        chapter_idx = s->nb_chapters - 1;\n        if (chapter_idx < 0) return -1; // there is no chapter.\n        timestamp = s->chapters[chapter_idx]->end;\n    }\n\n    ch = s->chapters[chapter_idx];\n\n    // sync by clamping timestamp to nearest valid block position in its chapter\n    chapter_size = ch->end / TIMEPREC - ch->start / TIMEPREC;\n    chapter_pos = av_rescale_rnd((timestamp - ch->start) / TIMEPREC,\n        1, c->codec_second_size,\n        (flags & AVSEEK_FLAG_BACKWARD) ? AV_ROUND_DOWN : AV_ROUND_UP)\n        * c->codec_second_size;\n    if (chapter_pos >= chapter_size)\n        chapter_pos = chapter_size;\n    chapter_start = c->content_start + (ch->start / TIMEPREC) + CHAPTER_HEADER_SIZE * (1 + chapter_idx);\n\n    // reinit read state\n    avio_seek(s->pb, chapter_start + chapter_pos, SEEK_SET);\n    c->current_codec_second_size = c->codec_second_size;\n    c->current_chapter_size = chapter_size - chapter_pos;\n    c->chapter_idx = 1 + chapter_idx;\n\n    // for unaligned frames, estimate offset of first frame in block (assume no padding)\n    if (s->streams[0]->codecpar->codec_id == AV_CODEC_ID_MP3) {\n        c->seek_offset = (MP3_FRAME_SIZE - chapter_pos % MP3_FRAME_SIZE) % MP3_FRAME_SIZE;\n    }\n\n    ff_update_cur_dts(s, s->streams[0], ch->start + (chapter_pos + c->seek_offset) * TIMEPREC);\n\n    return 1;\n}\n\nstatic int aa_probe(const AVProbeData *p)\n{\n    uint8_t *buf = p->buf;\n\n    // first 4 bytes are file size, next 4 bytes are the magic\n    if (AV_RB32(buf+4) != AA_MAGIC)\n        return 0;\n\n    return AVPROBE_SCORE_MAX / 2;\n}\n\nstatic int aa_read_close(AVFormatContext *s)\n{\n    AADemuxContext *c = s->priv_data;\n\n    av_freep(&c->tea_ctx);\n\n    return 0;\n}\n\n#define OFFSET(x) offsetof(AADemuxContext, x)\nstatic const AVOption aa_options[] = {\n    { \"aa_fixed_key\", // extracted from libAAX_SDK.so and AAXSDKWin.dll files!\n        \"Fixed key used for handling Audible AA files\", OFFSET(aa_fixed_key),\n        AV_OPT_TYPE_BINARY, {.str=\"77214d4b196a87cd520045fd2a51d673\"},\n        .flags = AV_OPT_FLAG_DECODING_PARAM },\n    { NULL },\n};\n\nstatic const AVClass aa_class = {\n    .class_name = \"aa\",\n    .item_name  = av_default_item_name,\n    .option     = aa_options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nAVInputFormat ff_aa_demuxer = {\n    .name           = \"aa\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Audible AA format files\"),\n    .priv_class     = &aa_class,\n    .priv_data_size = sizeof(AADemuxContext),\n    .extensions     = \"aa\",\n    .read_probe     = aa_probe,\n    .read_header    = aa_read_header,\n    .read_packet    = aa_read_packet,\n    .read_seek      = aa_read_seek,\n    .read_close     = aa_read_close,\n    .flags          = AVFMT_NO_BYTE_SEEK | AVFMT_NOGENSEARCH,\n};\n"], "fixing_code": ["/*\n * Audible AA demuxer\n * Copyright (c) 2015 Vesselin Bontchev\n *\n * Header parsing is borrowed from https://github.com/jteeuwen/audible project.\n * Copyright (c) 2001-2014, Jim Teeuwen\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"avformat.h\"\n#include \"internal.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/tea.h\"\n#include \"libavutil/opt.h\"\n\n#define AA_MAGIC 1469084982 /* this identifies an audible .aa file */\n#define MAX_CODEC_SECOND_SIZE 3982\n#define MAX_TOC_ENTRIES 16\n#define MAX_DICTIONARY_ENTRIES 128\n#define TEA_BLOCK_SIZE 8\n#define CHAPTER_HEADER_SIZE 8\n#define TIMEPREC 1000\n#define MP3_FRAME_SIZE 104\n\ntypedef struct AADemuxContext {\n    AVClass *class;\n    uint8_t *aa_fixed_key;\n    int aa_fixed_key_len;\n    int codec_second_size;\n    int current_codec_second_size;\n    int chapter_idx;\n    struct AVTEA *tea_ctx;\n    uint8_t file_key[16];\n    int64_t current_chapter_size;\n    int64_t content_start;\n    int64_t content_end;\n    int seek_offset;\n} AADemuxContext;\n\nstatic int get_second_size(char *codec_name)\n{\n    int result = -1;\n\n    if (!strcmp(codec_name, \"mp332\")) {\n        result = 3982;\n    } else if (!strcmp(codec_name, \"acelp16\")) {\n        result = 2000;\n    } else if (!strcmp(codec_name, \"acelp85\")) {\n        result = 1045;\n    }\n\n    return result;\n}\n\nstatic int aa_read_header(AVFormatContext *s)\n{\n    int i, j, idx, largest_idx = -1;\n    uint32_t nkey, nval, toc_size, npairs, header_seed = 0, start;\n    char key[128], val[128], codec_name[64] = {0};\n    uint8_t output[24], dst[8], src[8];\n    int64_t largest_size = -1, current_size = -1, chapter_pos;\n    struct toc_entry {\n        uint32_t offset;\n        uint32_t size;\n    } TOC[MAX_TOC_ENTRIES];\n    uint32_t header_key_part[4];\n    uint8_t header_key[16] = {0};\n    AADemuxContext *c = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    int ret;\n\n    /* parse .aa header */\n    avio_skip(pb, 4); // file size\n    avio_skip(pb, 4); // magic string\n    toc_size = avio_rb32(pb); // TOC size\n    avio_skip(pb, 4); // unidentified integer\n    if (toc_size > MAX_TOC_ENTRIES)\n        return AVERROR_INVALIDDATA;\n    for (i = 0; i < toc_size; i++) { // read TOC\n        avio_skip(pb, 4); // TOC entry index\n        TOC[i].offset = avio_rb32(pb); // block offset\n        TOC[i].size = avio_rb32(pb); // block size\n    }\n    avio_skip(pb, 24); // header termination block (ignored)\n    npairs = avio_rb32(pb); // read dictionary entries\n    if (npairs > MAX_DICTIONARY_ENTRIES)\n        return AVERROR_INVALIDDATA;\n    for (i = 0; i < npairs; i++) {\n        memset(val, 0, sizeof(val));\n        memset(key, 0, sizeof(key));\n        avio_skip(pb, 1); // unidentified integer\n        nkey = avio_rb32(pb); // key string length\n        nval = avio_rb32(pb); // value string length\n        avio_get_str(pb, nkey, key, sizeof(key));\n        avio_get_str(pb, nval, val, sizeof(val));\n        if (!strcmp(key, \"codec\")) {\n            av_log(s, AV_LOG_DEBUG, \"Codec is <%s>\\n\", val);\n            strncpy(codec_name, val, sizeof(codec_name) - 1);\n        } else if (!strcmp(key, \"HeaderSeed\")) {\n            av_log(s, AV_LOG_DEBUG, \"HeaderSeed is <%s>\\n\", val);\n            header_seed = atoi(val);\n        } else if (!strcmp(key, \"HeaderKey\")) { // this looks like \"1234567890 1234567890 1234567890 1234567890\"\n            av_log(s, AV_LOG_DEBUG, \"HeaderKey is <%s>\\n\", val);\n\n            ret = sscanf(val, \"%\"SCNu32\"%\"SCNu32\"%\"SCNu32\"%\"SCNu32,\n                   &header_key_part[0], &header_key_part[1], &header_key_part[2], &header_key_part[3]);\n            if (ret != 4)\n                return AVERROR_INVALIDDATA;\n\n            for (idx = 0; idx < 4; idx++) {\n                AV_WB32(&header_key[idx * 4], header_key_part[idx]); // convert each part to BE!\n            }\n            av_log(s, AV_LOG_DEBUG, \"Processed HeaderKey is \");\n            for (i = 0; i < 16; i++)\n                av_log(s, AV_LOG_DEBUG, \"%02x\", header_key[i]);\n            av_log(s, AV_LOG_DEBUG, \"\\n\");\n        } else {\n            av_dict_set(&s->metadata, key, val, 0);\n        }\n    }\n\n    /* verify fixed key */\n    if (c->aa_fixed_key_len != 16) {\n        av_log(s, AV_LOG_ERROR, \"aa_fixed_key value needs to be 16 bytes!\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    /* verify codec */\n    if ((c->codec_second_size = get_second_size(codec_name)) == -1) {\n        av_log(s, AV_LOG_ERROR, \"unknown codec <%s>!\\n\", codec_name);\n        return AVERROR(EINVAL);\n    }\n\n    /* decryption key derivation */\n    c->tea_ctx = av_tea_alloc();\n    if (!c->tea_ctx)\n        return AVERROR(ENOMEM);\n    av_tea_init(c->tea_ctx, c->aa_fixed_key, 16);\n    output[0] = output[1] = 0; // purely for padding purposes\n    memcpy(output + 2, header_key, 16);\n    idx = 0;\n    for (i = 0; i < 3; i++) { // TEA CBC with weird mixed endianness\n        AV_WB32(src, header_seed);\n        AV_WB32(src + 4, header_seed + 1);\n        header_seed += 2;\n        av_tea_crypt(c->tea_ctx, dst, src, 1, NULL, 0); // TEA ECB encrypt\n        for (j = 0; j < TEA_BLOCK_SIZE && idx < 18; j+=1, idx+=1) {\n            output[idx] = output[idx] ^ dst[j];\n        }\n    }\n    memcpy(c->file_key, output + 2, 16); // skip first 2 bytes of output\n    av_log(s, AV_LOG_DEBUG, \"File key is \");\n    for (i = 0; i < 16; i++)\n        av_log(s, AV_LOG_DEBUG, \"%02x\", c->file_key[i]);\n    av_log(s, AV_LOG_DEBUG, \"\\n\");\n\n    /* decoder setup */\n    st = avformat_new_stream(s, NULL);\n    if (!st) {\n        av_freep(&c->tea_ctx);\n        return AVERROR(ENOMEM);\n    }\n    st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n    if (!strcmp(codec_name, \"mp332\")) {\n        st->codecpar->codec_id = AV_CODEC_ID_MP3;\n        st->codecpar->sample_rate = 22050;\n        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;\n        avpriv_set_pts_info(st, 64, 8, 32000 * TIMEPREC);\n        // encoded audio frame is MP3_FRAME_SIZE bytes (+1 with padding, unlikely)\n    } else if (!strcmp(codec_name, \"acelp85\")) {\n        st->codecpar->codec_id = AV_CODEC_ID_SIPR;\n        st->codecpar->block_align = 19;\n        st->codecpar->channels = 1;\n        st->codecpar->sample_rate = 8500;\n        st->codecpar->bit_rate = 8500;\n        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;\n        avpriv_set_pts_info(st, 64, 8, 8500 * TIMEPREC);\n    } else if (!strcmp(codec_name, \"acelp16\")) {\n        st->codecpar->codec_id = AV_CODEC_ID_SIPR;\n        st->codecpar->block_align = 20;\n        st->codecpar->channels = 1;\n        st->codecpar->sample_rate = 16000;\n        st->codecpar->bit_rate = 16000;\n        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;\n        avpriv_set_pts_info(st, 64, 8, 16000 * TIMEPREC);\n    }\n\n    /* determine, and jump to audio start offset */\n    for (i = 1; i < toc_size; i++) { // skip the first entry!\n        current_size = TOC[i].size;\n        if (current_size > largest_size) {\n            largest_idx = i;\n            largest_size = current_size;\n        }\n    }\n    start = TOC[largest_idx].offset;\n    avio_seek(pb, start, SEEK_SET);\n\n    // extract chapter positions. since all formats have constant bit rate, use it\n    // as time base in bytes/s, for easy stream position <-> timestamp conversion\n    st->start_time = 0;\n    c->content_start = start;\n    c->content_end = start + largest_size;\n\n    while ((chapter_pos = avio_tell(pb)) >= 0 && chapter_pos < c->content_end) {\n        int chapter_idx = s->nb_chapters;\n        uint32_t chapter_size = avio_rb32(pb);\n        if (chapter_size == 0) break;\n        chapter_pos -= start + CHAPTER_HEADER_SIZE * chapter_idx;\n        avio_skip(pb, 4 + chapter_size);\n        if (!avpriv_new_chapter(s, chapter_idx, st->time_base,\n            chapter_pos * TIMEPREC, (chapter_pos + chapter_size) * TIMEPREC, NULL))\n                return AVERROR(ENOMEM);\n    }\n\n    st->duration = (largest_size - CHAPTER_HEADER_SIZE * s->nb_chapters) * TIMEPREC;\n\n    ff_update_cur_dts(s, st, 0);\n    avio_seek(pb, start, SEEK_SET);\n    c->current_chapter_size = 0;\n    c->seek_offset = 0;\n\n    return 0;\n}\n\nstatic int aa_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    uint8_t dst[TEA_BLOCK_SIZE];\n    uint8_t src[TEA_BLOCK_SIZE];\n    int i;\n    int trailing_bytes;\n    int blocks;\n    uint8_t buf[MAX_CODEC_SECOND_SIZE * 2];\n    int written = 0;\n    int ret;\n    AADemuxContext *c = s->priv_data;\n    uint64_t pos = avio_tell(s->pb);\n\n    // are we at the end of the audio content?\n    if (pos >= c->content_end) {\n        return AVERROR_EOF;\n    }\n\n    // are we at the start of a chapter?\n    if (c->current_chapter_size == 0) {\n        c->current_chapter_size = avio_rb32(s->pb);\n        if (c->current_chapter_size == 0) {\n            return AVERROR_EOF;\n        }\n        av_log(s, AV_LOG_DEBUG, \"Chapter %d (%\" PRId64 \" bytes)\\n\", c->chapter_idx, c->current_chapter_size);\n        c->chapter_idx = c->chapter_idx + 1;\n        avio_skip(s->pb, 4); // data start offset\n        pos += 8;\n        c->current_codec_second_size = c->codec_second_size;\n    }\n\n    // is this the last block in this chapter?\n    if (c->current_chapter_size / c->current_codec_second_size == 0) {\n        c->current_codec_second_size = c->current_chapter_size % c->current_codec_second_size;\n    }\n\n    // decrypt c->current_codec_second_size bytes\n    blocks = c->current_codec_second_size / TEA_BLOCK_SIZE;\n    for (i = 0; i < blocks; i++) {\n        ret = avio_read(s->pb, src, TEA_BLOCK_SIZE);\n        if (ret != TEA_BLOCK_SIZE)\n            return (ret < 0) ? ret : AVERROR_EOF;\n        av_tea_init(c->tea_ctx, c->file_key, 16);\n        av_tea_crypt(c->tea_ctx, dst, src, 1, NULL, 1);\n        memcpy(buf + written, dst, TEA_BLOCK_SIZE);\n        written = written + TEA_BLOCK_SIZE;\n    }\n    trailing_bytes = c->current_codec_second_size % TEA_BLOCK_SIZE;\n    if (trailing_bytes != 0) { // trailing bytes are left unencrypted!\n        ret = avio_read(s->pb, src, trailing_bytes);\n        if (ret != trailing_bytes)\n            return (ret < 0) ? ret : AVERROR_EOF;\n        memcpy(buf + written, src, trailing_bytes);\n        written = written + trailing_bytes;\n    }\n\n    // update state\n    c->current_chapter_size = c->current_chapter_size - c->current_codec_second_size;\n    if (c->current_chapter_size <= 0)\n        c->current_chapter_size = 0;\n\n    if (c->seek_offset > written)\n        c->seek_offset = 0; // ignore wrong estimate\n\n    ret = av_new_packet(pkt, written - c->seek_offset);\n    if (ret < 0)\n        return ret;\n    memcpy(pkt->data, buf + c->seek_offset, written - c->seek_offset);\n    pkt->pos = pos;\n\n    c->seek_offset = 0;\n    return 0;\n}\n\nstatic int aa_read_seek(AVFormatContext *s,\n                        int stream_index, int64_t timestamp, int flags)\n{\n    AADemuxContext *c = s->priv_data;\n    AVChapter *ch;\n    int64_t chapter_pos, chapter_start, chapter_size;\n    int chapter_idx = 0;\n\n    // find chapter containing seek timestamp\n    if (timestamp < 0)\n        timestamp = 0;\n\n    while (chapter_idx < s->nb_chapters && timestamp >= s->chapters[chapter_idx]->end) {\n        ++chapter_idx;\n    }\n\n    if (chapter_idx >= s->nb_chapters) {\n        chapter_idx = s->nb_chapters - 1;\n        if (chapter_idx < 0) return -1; // there is no chapter.\n        timestamp = s->chapters[chapter_idx]->end;\n    }\n\n    ch = s->chapters[chapter_idx];\n\n    // sync by clamping timestamp to nearest valid block position in its chapter\n    chapter_size = ch->end / TIMEPREC - ch->start / TIMEPREC;\n    chapter_pos = av_rescale_rnd((timestamp - ch->start) / TIMEPREC,\n        1, c->codec_second_size,\n        (flags & AVSEEK_FLAG_BACKWARD) ? AV_ROUND_DOWN : AV_ROUND_UP)\n        * c->codec_second_size;\n    if (chapter_pos >= chapter_size)\n        chapter_pos = chapter_size;\n    chapter_start = c->content_start + (ch->start / TIMEPREC) + CHAPTER_HEADER_SIZE * (1 + chapter_idx);\n\n    // reinit read state\n    avio_seek(s->pb, chapter_start + chapter_pos, SEEK_SET);\n    c->current_codec_second_size = c->codec_second_size;\n    c->current_chapter_size = chapter_size - chapter_pos;\n    c->chapter_idx = 1 + chapter_idx;\n\n    // for unaligned frames, estimate offset of first frame in block (assume no padding)\n    if (s->streams[0]->codecpar->codec_id == AV_CODEC_ID_MP3) {\n        c->seek_offset = (MP3_FRAME_SIZE - chapter_pos % MP3_FRAME_SIZE) % MP3_FRAME_SIZE;\n    }\n\n    ff_update_cur_dts(s, s->streams[0], ch->start + (chapter_pos + c->seek_offset) * TIMEPREC);\n\n    return 1;\n}\n\nstatic int aa_probe(const AVProbeData *p)\n{\n    uint8_t *buf = p->buf;\n\n    // first 4 bytes are file size, next 4 bytes are the magic\n    if (AV_RB32(buf+4) != AA_MAGIC)\n        return 0;\n\n    return AVPROBE_SCORE_MAX / 2;\n}\n\nstatic int aa_read_close(AVFormatContext *s)\n{\n    AADemuxContext *c = s->priv_data;\n\n    av_freep(&c->tea_ctx);\n\n    return 0;\n}\n\n#define OFFSET(x) offsetof(AADemuxContext, x)\nstatic const AVOption aa_options[] = {\n    { \"aa_fixed_key\", // extracted from libAAX_SDK.so and AAXSDKWin.dll files!\n        \"Fixed key used for handling Audible AA files\", OFFSET(aa_fixed_key),\n        AV_OPT_TYPE_BINARY, {.str=\"77214d4b196a87cd520045fd2a51d673\"},\n        .flags = AV_OPT_FLAG_DECODING_PARAM },\n    { NULL },\n};\n\nstatic const AVClass aa_class = {\n    .class_name = \"aa\",\n    .item_name  = av_default_item_name,\n    .option     = aa_options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nAVInputFormat ff_aa_demuxer = {\n    .name           = \"aa\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Audible AA format files\"),\n    .priv_class     = &aa_class,\n    .priv_data_size = sizeof(AADemuxContext),\n    .extensions     = \"aa\",\n    .read_probe     = aa_probe,\n    .read_header    = aa_read_header,\n    .read_packet    = aa_read_packet,\n    .read_seek      = aa_read_seek,\n    .read_close     = aa_read_close,\n    .flags          = AVFMT_NO_BYTE_SEEK | AVFMT_NOGENSEARCH,\n};\n"], "filenames": ["libavformat/aadec.c"], "buggy_code_start_loc": [87], "buggy_code_end_loc": [122], "fixing_code_start_loc": [88], "fixing_code_end_loc": [128], "type": "CWE-908", "message": "aa_read_header in libavformat/aadec.c in FFmpeg before 3.2.14 and 4.x before 4.1.4 does not check for sscanf failure and consequently allows use of uninitialized variables.", "other": {"cve": {"id": "CVE-2019-12730", "sourceIdentifier": "cve@mitre.org", "published": "2019-06-04T14:29:01.027", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "aa_read_header in libavformat/aadec.c in FFmpeg before 3.2.14 and 4.x before 4.1.4 does not check for sscanf failure and consequently allows use of uninitialized variables."}, {"lang": "es", "value": "aa_read_header en libavformat / aadec.c en FFmpeg en versiones anteriores a la 3.2.14 y versi\u00f3n 4.x versiones anteriores a la 4.1.4 no verifica el error de sscanf y, por lo tanto, permite el uso de variables sin inicializar."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-908"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.14", "matchCriteriaId": "97EFEC1B-1E68-4F76-9B3D-03FDE70505C5"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/109317", "source": "cve@mitre.org"}, {"url": "https://git.ffmpeg.org/gitweb/ffmpeg.git/commit/9b4004c054964a49c7ba44583f4cee22486dd8f2", "source": "cve@mitre.org"}, {"url": "https://git.ffmpeg.org/gitweb/ffmpeg.git/shortlog/n4.1.4", "source": "cve@mitre.org"}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/ed188f6dcdf0935c939ed813cf8745d50742014b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FFmpeg/FFmpeg/compare/a97ea53...ba11e40", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/Aug/30", "source": "cve@mitre.org"}, {"url": "https://security.gentoo.org/glsa/202003-65", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4431-1/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2019/dsa-4502", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/ed188f6dcdf0935c939ed813cf8745d50742014b"}}