{"buggy_code": ["/*\n * Based on arch/arm/kernel/traps.c\n *\n * Copyright (C) 1995-2009 Russell King\n * Copyright (C) 2012 ARM Ltd.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <linux/signal.h>\n#include <linux/personality.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n\n#include <asm/atomic.h>\n#include <asm/traps.h>\n#include <asm/stacktrace.h>\n#include <asm/exception.h>\n#include <asm/system_misc.h>\n\nstatic const char *handler[]= {\n\t\"Synchronous Abort\",\n\t\"IRQ\",\n\t\"FIQ\",\n\t\"Error\"\n};\n\nint show_unhandled_signals = 1;\n\n/*\n * Dump out the contents of some memory nicely...\n */\nstatic void dump_mem(const char *lvl, const char *str, unsigned long bottom,\n\t\t     unsigned long top)\n{\n\tunsigned long first;\n\tmm_segment_t fs;\n\tint i;\n\n\t/*\n\t * We need to switch to kernel mode so that we can use __get_user\n\t * to safely read from kernel space.  Note that we now dump the\n\t * code first, just in case the backtrace kills us.\n\t */\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\tprintk(\"%s%s(0x%016lx to 0x%016lx)\\n\", lvl, str, bottom, top);\n\n\tfor (first = bottom & ~31; first < top; first += 32) {\n\t\tunsigned long p;\n\t\tchar str[sizeof(\" 12345678\") * 8 + 1];\n\n\t\tmemset(str, ' ', sizeof(str));\n\t\tstr[sizeof(str) - 1] = '\\0';\n\n\t\tfor (p = first, i = 0; i < 8 && p < top; i++, p += 4) {\n\t\t\tif (p >= bottom && p < top) {\n\t\t\t\tunsigned int val;\n\t\t\t\tif (__get_user(val, (unsigned int *)p) == 0)\n\t\t\t\t\tsprintf(str + i * 9, \" %08x\", val);\n\t\t\t\telse\n\t\t\t\t\tsprintf(str + i * 9, \" ????????\");\n\t\t\t}\n\t\t}\n\t\tprintk(\"%s%04lx:%s\\n\", lvl, first & 0xffff, str);\n\t}\n\n\tset_fs(fs);\n}\n\nstatic void dump_backtrace_entry(unsigned long where, unsigned long stack)\n{\n\tprint_ip_sym(where);\n\tif (in_exception_text(where))\n\t\tdump_mem(\"\", \"Exception stack\", stack,\n\t\t\t stack + sizeof(struct pt_regs));\n}\n\nstatic void dump_instr(const char *lvl, struct pt_regs *regs)\n{\n\tunsigned long addr = instruction_pointer(regs);\n\tmm_segment_t fs;\n\tchar str[sizeof(\"00000000 \") * 5 + 2 + 1], *p = str;\n\tint i;\n\n\t/*\n\t * We need to switch to kernel mode so that we can use __get_user\n\t * to safely read from kernel space.  Note that we now dump the\n\t * code first, just in case the backtrace kills us.\n\t */\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\tfor (i = -4; i < 1; i++) {\n\t\tunsigned int val, bad;\n\n\t\tbad = __get_user(val, &((u32 *)addr)[i]);\n\n\t\tif (!bad)\n\t\t\tp += sprintf(p, i == 0 ? \"(%08x) \" : \"%08x \", val);\n\t\telse {\n\t\t\tp += sprintf(p, \"bad PC value\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintk(\"%sCode: %s\\n\", lvl, str);\n\n\tset_fs(fs);\n}\n\nstatic void dump_backtrace(struct pt_regs *regs, struct task_struct *tsk)\n{\n\tstruct stackframe frame;\n\tconst register unsigned long current_sp asm (\"sp\");\n\n\tpr_debug(\"%s(regs = %p tsk = %p)\\n\", __func__, regs, tsk);\n\n\tif (!tsk)\n\t\ttsk = current;\n\n\tif (regs) {\n\t\tframe.fp = regs->regs[29];\n\t\tframe.sp = regs->sp;\n\t\tframe.pc = regs->pc;\n\t} else if (tsk == current) {\n\t\tframe.fp = (unsigned long)__builtin_frame_address(0);\n\t\tframe.sp = current_sp;\n\t\tframe.pc = (unsigned long)dump_backtrace;\n\t} else {\n\t\t/*\n\t\t * task blocked in __switch_to\n\t\t */\n\t\tframe.fp = thread_saved_fp(tsk);\n\t\tframe.sp = thread_saved_sp(tsk);\n\t\tframe.pc = thread_saved_pc(tsk);\n\t}\n\n\tprintk(\"Call trace:\\n\");\n\twhile (1) {\n\t\tunsigned long where = frame.pc;\n\t\tint ret;\n\n\t\tret = unwind_frame(&frame);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tdump_backtrace_entry(where, frame.sp);\n\t}\n}\n\nvoid show_stack(struct task_struct *tsk, unsigned long *sp)\n{\n\tdump_backtrace(NULL, tsk);\n\tbarrier();\n}\n\n#ifdef CONFIG_PREEMPT\n#define S_PREEMPT \" PREEMPT\"\n#else\n#define S_PREEMPT \"\"\n#endif\n#ifdef CONFIG_SMP\n#define S_SMP \" SMP\"\n#else\n#define S_SMP \"\"\n#endif\n\nstatic int __die(const char *str, int err, struct thread_info *thread,\n\t\t struct pt_regs *regs)\n{\n\tstruct task_struct *tsk = thread->task;\n\tstatic int die_counter;\n\tint ret;\n\n\tpr_emerg(\"Internal error: %s: %x [#%d]\" S_PREEMPT S_SMP \"\\n\",\n\t\t str, err, ++die_counter);\n\n\t/* trap and error numbers are mostly meaningless on ARM */\n\tret = notify_die(DIE_OOPS, str, regs, err, 0, SIGSEGV);\n\tif (ret == NOTIFY_STOP)\n\t\treturn ret;\n\n\tprint_modules();\n\t__show_regs(regs);\n\tpr_emerg(\"Process %.*s (pid: %d, stack limit = 0x%p)\\n\",\n\t\t TASK_COMM_LEN, tsk->comm, task_pid_nr(tsk), thread + 1);\n\n\tif (!user_mode(regs) || in_interrupt()) {\n\t\tdump_mem(KERN_EMERG, \"Stack: \", regs->sp,\n\t\t\t THREAD_SIZE + (unsigned long)task_stack_page(tsk));\n\t\tdump_backtrace(regs, tsk);\n\t\tdump_instr(KERN_EMERG, regs);\n\t}\n\n\treturn ret;\n}\n\nstatic DEFINE_RAW_SPINLOCK(die_lock);\n\n/*\n * This function is protected against re-entrancy.\n */\nvoid die(const char *str, struct pt_regs *regs, int err)\n{\n\tstruct thread_info *thread = current_thread_info();\n\tint ret;\n\n\toops_enter();\n\n\traw_spin_lock_irq(&die_lock);\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tret = __die(str, err, thread, regs);\n\n\tif (regs && kexec_should_crash(thread->task))\n\t\tcrash_kexec(regs);\n\n\tbust_spinlocks(0);\n\tadd_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);\n\traw_spin_unlock_irq(&die_lock);\n\toops_exit();\n\n\tif (in_interrupt())\n\t\tpanic(\"Fatal exception in interrupt\");\n\tif (panic_on_oops)\n\t\tpanic(\"Fatal exception\");\n\tif (ret != NOTIFY_STOP)\n\t\tdo_exit(SIGSEGV);\n}\n\nvoid arm64_notify_die(const char *str, struct pt_regs *regs,\n\t\t      struct siginfo *info, int err)\n{\n\tif (user_mode(regs))\n\t\tforce_sig_info(info->si_signo, info, current);\n\telse\n\t\tdie(str, regs, err);\n}\n\nasmlinkage void __exception do_undefinstr(struct pt_regs *regs)\n{\n\tsiginfo_t info;\n\tvoid __user *pc = (void __user *)instruction_pointer(regs);\n\n#ifdef CONFIG_COMPAT\n\t/* check for AArch32 breakpoint instructions */\n\tif (compat_user_mode(regs) && aarch32_break_trap(regs) == 0)\n\t\treturn;\n#endif\n\n\tif (show_unhandled_signals && unhandled_signal(current, SIGILL) &&\n\t    printk_ratelimit()) {\n\t\tpr_info(\"%s[%d]: undefined instruction: pc=%p\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current), pc);\n\t\tdump_instr(KERN_INFO, regs);\n\t}\n\n\tinfo.si_signo = SIGILL;\n\tinfo.si_errno = 0;\n\tinfo.si_code  = ILL_ILLOPC;\n\tinfo.si_addr  = pc;\n\n\tarm64_notify_die(\"Oops - undefined instruction\", regs, &info, 0);\n}\n\nlong compat_arm_syscall(struct pt_regs *regs);\n\nasmlinkage long do_ni_syscall(struct pt_regs *regs)\n{\n#ifdef CONFIG_COMPAT\n\tlong ret;\n\tif (is_compat_task()) {\n\t\tret = compat_arm_syscall(regs);\n\t\tif (ret != -ENOSYS)\n\t\t\treturn ret;\n\t}\n#endif\n\n\tif (show_unhandled_signals && printk_ratelimit()) {\n\t\tpr_info(\"%s[%d]: syscall %d\\n\", current->comm,\n\t\t\ttask_pid_nr(current), (int)regs->syscallno);\n\t\tdump_instr(\"\", regs);\n\t\tif (user_mode(regs))\n\t\t\t__show_regs(regs);\n\t}\n\n\treturn sys_ni_syscall();\n}\n\n/*\n * bad_mode handles the impossible case in the exception vector.\n */\nasmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr)\n{\n\tconsole_verbose();\n\n\tpr_crit(\"Bad mode in %s handler detected, code 0x%08x\\n\",\n\t\thandler[reason], esr);\n\n\tdie(\"Oops - bad mode\", regs, 0);\n\tlocal_irq_disable();\n\tpanic(\"bad mode\");\n}\n\nvoid __pte_error(const char *file, int line, unsigned long val)\n{\n\tprintk(\"%s:%d: bad pte %016lx.\\n\", file, line, val);\n}\n\nvoid __pmd_error(const char *file, int line, unsigned long val)\n{\n\tprintk(\"%s:%d: bad pmd %016lx.\\n\", file, line, val);\n}\n\nvoid __pgd_error(const char *file, int line, unsigned long val)\n{\n\tprintk(\"%s:%d: bad pgd %016lx.\\n\", file, line, val);\n}\n\nvoid __init trap_init(void)\n{\n\treturn;\n}\n"], "fixing_code": ["/*\n * Based on arch/arm/kernel/traps.c\n *\n * Copyright (C) 1995-2009 Russell King\n * Copyright (C) 2012 ARM Ltd.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <linux/signal.h>\n#include <linux/personality.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n\n#include <asm/atomic.h>\n#include <asm/traps.h>\n#include <asm/stacktrace.h>\n#include <asm/exception.h>\n#include <asm/system_misc.h>\n\nstatic const char *handler[]= {\n\t\"Synchronous Abort\",\n\t\"IRQ\",\n\t\"FIQ\",\n\t\"Error\"\n};\n\nint show_unhandled_signals = 1;\n\n/*\n * Dump out the contents of some memory nicely...\n */\nstatic void dump_mem(const char *lvl, const char *str, unsigned long bottom,\n\t\t     unsigned long top)\n{\n\tunsigned long first;\n\tmm_segment_t fs;\n\tint i;\n\n\t/*\n\t * We need to switch to kernel mode so that we can use __get_user\n\t * to safely read from kernel space.  Note that we now dump the\n\t * code first, just in case the backtrace kills us.\n\t */\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\tprintk(\"%s%s(0x%016lx to 0x%016lx)\\n\", lvl, str, bottom, top);\n\n\tfor (first = bottom & ~31; first < top; first += 32) {\n\t\tunsigned long p;\n\t\tchar str[sizeof(\" 12345678\") * 8 + 1];\n\n\t\tmemset(str, ' ', sizeof(str));\n\t\tstr[sizeof(str) - 1] = '\\0';\n\n\t\tfor (p = first, i = 0; i < 8 && p < top; i++, p += 4) {\n\t\t\tif (p >= bottom && p < top) {\n\t\t\t\tunsigned int val;\n\t\t\t\tif (__get_user(val, (unsigned int *)p) == 0)\n\t\t\t\t\tsprintf(str + i * 9, \" %08x\", val);\n\t\t\t\telse\n\t\t\t\t\tsprintf(str + i * 9, \" ????????\");\n\t\t\t}\n\t\t}\n\t\tprintk(\"%s%04lx:%s\\n\", lvl, first & 0xffff, str);\n\t}\n\n\tset_fs(fs);\n}\n\nstatic void dump_backtrace_entry(unsigned long where, unsigned long stack)\n{\n\tprint_ip_sym(where);\n\tif (in_exception_text(where))\n\t\tdump_mem(\"\", \"Exception stack\", stack,\n\t\t\t stack + sizeof(struct pt_regs));\n}\n\nstatic void dump_instr(const char *lvl, struct pt_regs *regs)\n{\n\tunsigned long addr = instruction_pointer(regs);\n\tmm_segment_t fs;\n\tchar str[sizeof(\"00000000 \") * 5 + 2 + 1], *p = str;\n\tint i;\n\n\t/*\n\t * We need to switch to kernel mode so that we can use __get_user\n\t * to safely read from kernel space.  Note that we now dump the\n\t * code first, just in case the backtrace kills us.\n\t */\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\tfor (i = -4; i < 1; i++) {\n\t\tunsigned int val, bad;\n\n\t\tbad = __get_user(val, &((u32 *)addr)[i]);\n\n\t\tif (!bad)\n\t\t\tp += sprintf(p, i == 0 ? \"(%08x) \" : \"%08x \", val);\n\t\telse {\n\t\t\tp += sprintf(p, \"bad PC value\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintk(\"%sCode: %s\\n\", lvl, str);\n\n\tset_fs(fs);\n}\n\nstatic void dump_backtrace(struct pt_regs *regs, struct task_struct *tsk)\n{\n\tstruct stackframe frame;\n\tconst register unsigned long current_sp asm (\"sp\");\n\n\tpr_debug(\"%s(regs = %p tsk = %p)\\n\", __func__, regs, tsk);\n\n\tif (!tsk)\n\t\ttsk = current;\n\n\tif (regs) {\n\t\tframe.fp = regs->regs[29];\n\t\tframe.sp = regs->sp;\n\t\tframe.pc = regs->pc;\n\t} else if (tsk == current) {\n\t\tframe.fp = (unsigned long)__builtin_frame_address(0);\n\t\tframe.sp = current_sp;\n\t\tframe.pc = (unsigned long)dump_backtrace;\n\t} else {\n\t\t/*\n\t\t * task blocked in __switch_to\n\t\t */\n\t\tframe.fp = thread_saved_fp(tsk);\n\t\tframe.sp = thread_saved_sp(tsk);\n\t\tframe.pc = thread_saved_pc(tsk);\n\t}\n\n\tprintk(\"Call trace:\\n\");\n\twhile (1) {\n\t\tunsigned long where = frame.pc;\n\t\tint ret;\n\n\t\tret = unwind_frame(&frame);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tdump_backtrace_entry(where, frame.sp);\n\t}\n}\n\nvoid show_stack(struct task_struct *tsk, unsigned long *sp)\n{\n\tdump_backtrace(NULL, tsk);\n\tbarrier();\n}\n\n#ifdef CONFIG_PREEMPT\n#define S_PREEMPT \" PREEMPT\"\n#else\n#define S_PREEMPT \"\"\n#endif\n#ifdef CONFIG_SMP\n#define S_SMP \" SMP\"\n#else\n#define S_SMP \"\"\n#endif\n\nstatic int __die(const char *str, int err, struct thread_info *thread,\n\t\t struct pt_regs *regs)\n{\n\tstruct task_struct *tsk = thread->task;\n\tstatic int die_counter;\n\tint ret;\n\n\tpr_emerg(\"Internal error: %s: %x [#%d]\" S_PREEMPT S_SMP \"\\n\",\n\t\t str, err, ++die_counter);\n\n\t/* trap and error numbers are mostly meaningless on ARM */\n\tret = notify_die(DIE_OOPS, str, regs, err, 0, SIGSEGV);\n\tif (ret == NOTIFY_STOP)\n\t\treturn ret;\n\n\tprint_modules();\n\t__show_regs(regs);\n\tpr_emerg(\"Process %.*s (pid: %d, stack limit = 0x%p)\\n\",\n\t\t TASK_COMM_LEN, tsk->comm, task_pid_nr(tsk), thread + 1);\n\n\tif (!user_mode(regs) || in_interrupt()) {\n\t\tdump_mem(KERN_EMERG, \"Stack: \", regs->sp,\n\t\t\t THREAD_SIZE + (unsigned long)task_stack_page(tsk));\n\t\tdump_backtrace(regs, tsk);\n\t\tdump_instr(KERN_EMERG, regs);\n\t}\n\n\treturn ret;\n}\n\nstatic DEFINE_RAW_SPINLOCK(die_lock);\n\n/*\n * This function is protected against re-entrancy.\n */\nvoid die(const char *str, struct pt_regs *regs, int err)\n{\n\tstruct thread_info *thread = current_thread_info();\n\tint ret;\n\n\toops_enter();\n\n\traw_spin_lock_irq(&die_lock);\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tret = __die(str, err, thread, regs);\n\n\tif (regs && kexec_should_crash(thread->task))\n\t\tcrash_kexec(regs);\n\n\tbust_spinlocks(0);\n\tadd_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);\n\traw_spin_unlock_irq(&die_lock);\n\toops_exit();\n\n\tif (in_interrupt())\n\t\tpanic(\"Fatal exception in interrupt\");\n\tif (panic_on_oops)\n\t\tpanic(\"Fatal exception\");\n\tif (ret != NOTIFY_STOP)\n\t\tdo_exit(SIGSEGV);\n}\n\nvoid arm64_notify_die(const char *str, struct pt_regs *regs,\n\t\t      struct siginfo *info, int err)\n{\n\tif (user_mode(regs))\n\t\tforce_sig_info(info->si_signo, info, current);\n\telse\n\t\tdie(str, regs, err);\n}\n\nasmlinkage void __exception do_undefinstr(struct pt_regs *regs)\n{\n\tsiginfo_t info;\n\tvoid __user *pc = (void __user *)instruction_pointer(regs);\n\n#ifdef CONFIG_COMPAT\n\t/* check for AArch32 breakpoint instructions */\n\tif (compat_user_mode(regs) && aarch32_break_trap(regs) == 0)\n\t\treturn;\n#endif\n\n\tif (show_unhandled_signals && unhandled_signal(current, SIGILL) &&\n\t    printk_ratelimit()) {\n\t\tpr_info(\"%s[%d]: undefined instruction: pc=%p\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current), pc);\n\t\tdump_instr(KERN_INFO, regs);\n\t}\n\n\tinfo.si_signo = SIGILL;\n\tinfo.si_errno = 0;\n\tinfo.si_code  = ILL_ILLOPC;\n\tinfo.si_addr  = pc;\n\n\tarm64_notify_die(\"Oops - undefined instruction\", regs, &info, 0);\n}\n\nlong compat_arm_syscall(struct pt_regs *regs);\n\nasmlinkage long do_ni_syscall(struct pt_regs *regs)\n{\n#ifdef CONFIG_COMPAT\n\tlong ret;\n\tif (is_compat_task()) {\n\t\tret = compat_arm_syscall(regs);\n\t\tif (ret != -ENOSYS)\n\t\t\treturn ret;\n\t}\n#endif\n\n\tif (show_unhandled_signals && printk_ratelimit()) {\n\t\tpr_info(\"%s[%d]: syscall %d\\n\", current->comm,\n\t\t\ttask_pid_nr(current), (int)regs->syscallno);\n\t\tdump_instr(\"\", regs);\n\t\tif (user_mode(regs))\n\t\t\t__show_regs(regs);\n\t}\n\n\treturn sys_ni_syscall();\n}\n\n/*\n * bad_mode handles the impossible case in the exception vector.\n */\nasmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr)\n{\n\tsiginfo_t info;\n\tvoid __user *pc = (void __user *)instruction_pointer(regs);\n\tconsole_verbose();\n\n\tpr_crit(\"Bad mode in %s handler detected, code 0x%08x\\n\",\n\t\thandler[reason], esr);\n\t__show_regs(regs);\n\n\tinfo.si_signo = SIGILL;\n\tinfo.si_errno = 0;\n\tinfo.si_code  = ILL_ILLOPC;\n\tinfo.si_addr  = pc;\n\n\tarm64_notify_die(\"Oops - bad mode\", regs, &info, 0);\n}\n\nvoid __pte_error(const char *file, int line, unsigned long val)\n{\n\tprintk(\"%s:%d: bad pte %016lx.\\n\", file, line, val);\n}\n\nvoid __pmd_error(const char *file, int line, unsigned long val)\n{\n\tprintk(\"%s:%d: bad pmd %016lx.\\n\", file, line, val);\n}\n\nvoid __pgd_error(const char *file, int line, unsigned long val)\n{\n\tprintk(\"%s:%d: bad pgd %016lx.\\n\", file, line, val);\n}\n\nvoid __init trap_init(void)\n{\n\treturn;\n}\n"], "filenames": ["arch/arm64/kernel/traps.c"], "buggy_code_start_loc": [313], "buggy_code_end_loc": [322], "fixing_code_start_loc": [314], "fixing_code_end_loc": [328], "type": "NVD-CWE-noinfo", "message": "The bad_mode function in arch/arm64/kernel/traps.c in the Linux kernel before 3.9.5 on the ARM64 platform allows local users to cause a denial of service (system crash) via vectors involving an attempted register access that triggers an unexpected value in the Exception Syndrome Register (ESR).", "other": {"cve": {"id": "CVE-2013-4220", "sourceIdentifier": "secalert@redhat.com", "published": "2013-08-25T03:27:32.933", "lastModified": "2023-02-13T04:45:06.130", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The bad_mode function in arch/arm64/kernel/traps.c in the Linux kernel before 3.9.5 on the ARM64 platform allows local users to cause a denial of service (system crash) via vectors involving an attempted register access that triggers an unexpected value in the Exception Syndrome Register (ESR)."}, {"lang": "es", "value": "La funci\u00f3n bad_mode en arch/arm64/kernel/traps.c en Linux kernel anterior a v3.9.5 en plataformas ARM64 permite a usuarios locales provocar una denegaci\u00f3n de servicio (ca\u00edda del sistema) a trav\u00e9s de vectores relacionados con un intento de registro de acceso que desencadena un valor inesperado en el Exception Syndrome Register (ESR)."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:arm64:*", "versionEndIncluding": "3.9.4", "matchCriteriaId": "38A0871C-AF11-4460-B6B0-523E12C13D50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.0:*:*:*:*:*:arm64:*", "matchCriteriaId": "59E39242-8051-4018-82BC-F7F2C52749E0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.1:*:*:*:*:*:arm64:*", "matchCriteriaId": "EDAADF21-6FBC-4AE4-88E6-912E2EF367E0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.2:*:*:*:*:*:arm64:*", "matchCriteriaId": "D4A5AB12-E57A-4D49-93EF-1BE2AC1A0FF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.3:*:*:*:*:*:arm64:*", "matchCriteriaId": "BD62DFE5-690C-4972-AA2E-B01BB7A9E16D"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=9955ac47f4ba1c95ecb6092aeaefb40a22e99268", "source": "secalert@redhat.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.9.5", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/08/08/12", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=996380", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/9955ac47f4ba1c95ecb6092aeaefb40a22e99268", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/9955ac47f4ba1c95ecb6092aeaefb40a22e99268"}}