{"buggy_code": ["package file\n\nimport (\n\t\"archive/tar\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/pkg/errors\"\n\n\t\"github.com/anchore/stereoscope/internal/log\"\n)\n\nconst perFileReadLimit = 2 * GB\n\nvar ErrTarStopIteration = fmt.Errorf(\"halt iterating tar\")\n\n// tarFile is a ReadCloser of a tar file on disk.\ntype tarFile struct {\n\tio.Reader\n\tio.Closer\n}\n\n// TarFileEntry represents the header, contents, and list position of an entry within a tar file.\ntype TarFileEntry struct {\n\tSequence int64\n\tHeader   tar.Header\n\tReader   io.Reader\n}\n\n// TarFileVisitor is a visitor function meant to be used in conjunction with the IterateTar.\ntype TarFileVisitor func(TarFileEntry) error\n\n// ErrFileNotFound returned from ReaderFromTar if a file is not found in the given archive.\ntype ErrFileNotFound struct {\n\tPath string\n}\n\nfunc (e *ErrFileNotFound) Error() string {\n\treturn fmt.Sprintf(\"file not found (path=%s)\", e.Path)\n}\n\n// IterateTar is a function that reads across a tar and invokes a visitor function for each entry discovered. The iterator\n// stops when there are no more entries to read, if there is an error in the underlying reader or visitor function,\n// or if the visitor function returns a ErrTarStopIteration sentinel error.\nfunc IterateTar(reader io.Reader, visitor TarFileVisitor) error {\n\ttarReader := tar.NewReader(reader)\n\tvar sequence int64 = -1\n\tfor {\n\t\tsequence++\n\n\t\thdr, err := tarReader.Next()\n\t\tif errors.Is(err, io.EOF) {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif hdr == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif err := visitor(TarFileEntry{\n\t\t\tSequence: sequence,\n\t\t\tHeader:   *hdr,\n\t\t\tReader:   tarReader,\n\t\t}); err != nil {\n\t\t\tif errors.Is(err, ErrTarStopIteration) {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"failed to visit tar entry=%q : %w\", hdr.Name, err)\n\t\t}\n\t}\n\treturn nil\n}\n\n// ReaderFromTar returns a io.ReadCloser for the Path within a tar file.\nfunc ReaderFromTar(reader io.ReadCloser, tarPath string) (io.ReadCloser, error) {\n\tvar result io.ReadCloser\n\n\tvisitor := func(entry TarFileEntry) error {\n\t\tif entry.Header.Name == tarPath {\n\t\t\tresult = &tarFile{\n\t\t\t\tReader: entry.Reader,\n\t\t\t\tCloser: reader,\n\t\t\t}\n\t\t\treturn ErrTarStopIteration\n\t\t}\n\t\treturn nil\n\t}\n\tif err := IterateTar(reader, visitor); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif result == nil {\n\t\treturn nil, &ErrFileNotFound{tarPath}\n\t}\n\n\treturn result, nil\n}\n\n// MetadataFromTar returns the tar metadata from the header info.\nfunc MetadataFromTar(reader io.ReadCloser, tarPath string) (Metadata, error) {\n\tvar metadata *Metadata\n\tvisitor := func(entry TarFileEntry) error {\n\t\tif entry.Header.Name == tarPath {\n\t\t\tvar content io.Reader\n\t\t\tif entry.Header.Size > 0 {\n\t\t\t\tcontent = reader\n\t\t\t}\n\t\t\tm := NewMetadata(entry.Header, content)\n\t\t\tmetadata = &m\n\t\t\treturn ErrTarStopIteration\n\t\t}\n\t\treturn nil\n\t}\n\tif err := IterateTar(reader, visitor); err != nil {\n\t\treturn Metadata{}, err\n\t}\n\tif metadata == nil {\n\t\treturn Metadata{}, &ErrFileNotFound{tarPath}\n\t}\n\treturn *metadata, nil\n}\n\n// UntarToDirectory writes the contents of the given tar reader to the given destination\nfunc UntarToDirectory(reader io.Reader, dst string) error {\n\tvisitor := func(entry TarFileEntry) error {\n\t\ttarget := filepath.Join(dst, entry.Header.Name)\n\n\t\tswitch entry.Header.Typeflag {\n\t\tcase tar.TypeDir:\n\t\t\tif _, err := os.Stat(target); err != nil {\n\t\t\t\tif err := os.MkdirAll(target, 0755); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\tcase tar.TypeReg:\n\t\t\tf, err := os.OpenFile(target, os.O_CREATE|os.O_RDWR, os.FileMode(entry.Header.Mode))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// limit the reader on each file read to prevent decompression bomb attacks\n\t\t\tnumBytes, err := io.Copy(f, io.LimitReader(entry.Reader, perFileReadLimit))\n\t\t\tif numBytes >= perFileReadLimit || errors.Is(err, io.EOF) {\n\t\t\t\treturn fmt.Errorf(\"zip read limit hit (potential decompression bomb attack)\")\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"unable to copy file: %w\", err)\n\t\t\t}\n\n\t\t\tif err = f.Close(); err != nil {\n\t\t\t\tlog.Errorf(\"failed to close file during untar of path=%q: %w\", f.Name(), err)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\treturn IterateTar(reader, visitor)\n}\n", "//go:build !windows\n// +build !windows\n\npackage file\n\nimport (\n\t\"crypto/sha256\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nconst (\n\tfixturesPath = \"test-fixtures\"\n)\n\nvar (\n\tfixturesGeneratorsPath = path.Join(fixturesPath, \"generators\")\n\ttarCachePath           = path.Join(fixturesPath, \"tar-cache\")\n)\n\nfunc TestReaderFromTar_GoCase(t *testing.T) {\n\ttarReader := getTarFixture(t, \"fixture-1\")\n\n\tfileReader, err := ReaderFromTar(tarReader, \"path/branch/two/file-2.txt\")\n\tif err != nil {\n\t\tt.Fatal(\"could not get file reader from tar:\", err)\n\t}\n\n\tcontents, err := io.ReadAll(fileReader)\n\tif err != nil {\n\t\tt.Fatal(\"could not read from file reader:\", err)\n\t}\n\n\tif string(contents) != \"second file\\n\" {\n\t\tt.Errorf(\"unexpected contents: '%s'\", string(contents))\n\t}\n}\n\nfunc TestReaderFromTar_MissingFile(t *testing.T) {\n\ttarReader := getTarFixture(t, \"fixture-1\")\n\n\t_, err := ReaderFromTar(tarReader, \"nOn-ExIsTaNt-paTh\")\n\tif err == nil {\n\t\tt.Error(\"expected an error but did not find one\")\n\t}\n}\n\nfunc TestMetadataFromTar(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tfixture  string\n\t\texpected Metadata\n\t}{\n\t\t{\n\t\t\tname:    \"path/branch/two/file-2.txt\",\n\t\t\tfixture: \"fixture-1\",\n\t\t\texpected: Metadata{\n\t\t\t\tPath:            \"/path/branch/two/file-2.txt\",\n\t\t\t\tLinkDestination: \"\",\n\t\t\t\tUserID:          1337,\n\t\t\t\tGroupID:         5432,\n\t\t\t\tType:            TypeRegular,\n\t\t\t\tMIMEType:        \"application/octet-stream\",\n\t\t\t\tFileInfo: ManualInfo{\n\t\t\t\t\tNameValue:    \"file-2.txt\",\n\t\t\t\t\tSizeValue:    12,\n\t\t\t\t\tModeValue:    0x1ed,\n\t\t\t\t\tModTimeValue: time.Date(2019, time.September, 16, 0, 0, 0, 0, time.UTC),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"path/branch/two/\",\n\t\t\tfixture: \"fixture-1\",\n\t\t\texpected: Metadata{\n\t\t\t\tPath:            \"/path/branch/two\",\n\t\t\t\tLinkDestination: \"\",\n\t\t\t\tUserID:          1337,\n\t\t\t\tGroupID:         5432,\n\t\t\t\tType:            TypeDirectory,\n\t\t\t\tMIMEType:        \"\",\n\t\t\t\tFileInfo: ManualInfo{\n\t\t\t\t\tNameValue:    \"two\",\n\t\t\t\t\tSizeValue:    0,\n\t\t\t\t\tModeValue:    0x800001ed,\n\t\t\t\t\tModTimeValue: time.Date(2019, time.September, 16, 0, 0, 0, 0, time.UTC),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tf := getTarFixture(t, test.fixture)\n\t\t\tmetadata, err := MetadataFromTar(f, test.name)\n\t\t\tassert.NoError(t, err)\n\t\t\tassertMetadataEqual(t, test.expected, metadata)\n\t\t})\n\t}\n}\n\nfunc getTarFixture(t testing.TB, name string) *os.File {\n\tgeneratorScriptName := name + \".sh\"\n\tgeneratorScriptPath := path.Join(fixturesGeneratorsPath, generatorScriptName)\n\tif !fileExists(t, generatorScriptPath) {\n\t\tt.Fatalf(\"no tar generator script for fixture '%s'\", generatorScriptPath)\n\t}\n\n\tversion := fixtureVersion(t, generatorScriptPath)\n\ttarName := name + \":\" + version + \".tar\"\n\ttarFixturePath := path.Join(tarCachePath, tarName)\n\n\tif !fileExists(t, tarFixturePath) {\n\t\tt.Logf(\"Creating tar fixture: %s\", tarFixturePath)\n\n\t\tfullPath, err := filepath.Abs(tarFixturePath)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tcmd := exec.Command(\"./\"+generatorScriptName, fullPath)\n\t\tcmd.Env = os.Environ()\n\t\tcmd.Dir = fixturesGeneratorsPath\n\t\tcmd.Stdout = os.Stdout\n\t\tcmd.Stderr = os.Stderr\n\t\tcmd.Stdin = os.Stdin\n\n\t\terr = cmd.Run()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tfile, err := os.Open(tarFixturePath)\n\tif err != nil {\n\t\tt.Fatalf(\"could not open tar fixture '%s'\", tarFixturePath)\n\t}\n\n\tt.Cleanup(func() {\n\t\tfile.Close()\n\t})\n\n\treturn file\n}\n\nfunc fixtureVersion(t testing.TB, path string) string {\n\tt.Helper()\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() {\n\t\terr := f.Close()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}()\n\n\th := sha256.New()\n\tif _, err := io.Copy(h, f); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treturn fmt.Sprintf(\"%x\", h.Sum(nil))\n}\n\nfunc fileExists(t testing.TB, filename string) bool {\n\tt.Helper()\n\tinfo, err := os.Stat(filename)\n\tif os.IsNotExist(err) {\n\t\treturn false\n\t} else if err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn !info.IsDir()\n}\n"], "fixing_code": ["package file\n\nimport (\n\t\"archive/tar\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/pkg/errors\"\n\t\"github.com/spf13/afero\"\n\n\t\"github.com/anchore/stereoscope/internal/log\"\n)\n\nconst perFileReadLimit = 2 * GB\n\nvar ErrTarStopIteration = fmt.Errorf(\"halt iterating tar\")\n\n// tarFile is a ReadCloser of a tar file on disk.\ntype tarFile struct {\n\tio.Reader\n\tio.Closer\n}\n\n// TarFileEntry represents the header, contents, and list position of an entry within a tar file.\ntype TarFileEntry struct {\n\tSequence int64\n\tHeader   tar.Header\n\tReader   io.Reader\n}\n\n// TarFileVisitor is a visitor function meant to be used in conjunction with the IterateTar.\ntype TarFileVisitor func(TarFileEntry) error\n\n// ErrFileNotFound returned from ReaderFromTar if a file is not found in the given archive.\ntype ErrFileNotFound struct {\n\tPath string\n}\n\nfunc (e *ErrFileNotFound) Error() string {\n\treturn fmt.Sprintf(\"file not found (path=%s)\", e.Path)\n}\n\n// IterateTar is a function that reads across a tar and invokes a visitor function for each entry discovered. The iterator\n// stops when there are no more entries to read, if there is an error in the underlying reader or visitor function,\n// or if the visitor function returns a ErrTarStopIteration sentinel error.\nfunc IterateTar(reader io.Reader, visitor TarFileVisitor) error {\n\ttarReader := tar.NewReader(reader)\n\tvar sequence int64 = -1\n\tfor {\n\t\tsequence++\n\n\t\thdr, err := tarReader.Next()\n\t\tif errors.Is(err, io.EOF) {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif hdr == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif err := visitor(TarFileEntry{\n\t\t\tSequence: sequence,\n\t\t\tHeader:   *hdr,\n\t\t\tReader:   tarReader,\n\t\t}); err != nil {\n\t\t\tif errors.Is(err, ErrTarStopIteration) {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"failed to visit tar entry=%q : %w\", hdr.Name, err)\n\t\t}\n\t}\n\treturn nil\n}\n\n// ReaderFromTar returns a io.ReadCloser for the Path within a tar file.\nfunc ReaderFromTar(reader io.ReadCloser, tarPath string) (io.ReadCloser, error) {\n\tvar result io.ReadCloser\n\n\tvisitor := func(entry TarFileEntry) error {\n\t\tif entry.Header.Name == tarPath {\n\t\t\tresult = &tarFile{\n\t\t\t\tReader: entry.Reader,\n\t\t\t\tCloser: reader,\n\t\t\t}\n\t\t\treturn ErrTarStopIteration\n\t\t}\n\t\treturn nil\n\t}\n\tif err := IterateTar(reader, visitor); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif result == nil {\n\t\treturn nil, &ErrFileNotFound{tarPath}\n\t}\n\n\treturn result, nil\n}\n\n// MetadataFromTar returns the tar metadata from the header info.\nfunc MetadataFromTar(reader io.ReadCloser, tarPath string) (Metadata, error) {\n\tvar metadata *Metadata\n\tvisitor := func(entry TarFileEntry) error {\n\t\tif entry.Header.Name == tarPath {\n\t\t\tvar content io.Reader\n\t\t\tif entry.Header.Size > 0 {\n\t\t\t\tcontent = reader\n\t\t\t}\n\t\t\tm := NewMetadata(entry.Header, content)\n\t\t\tmetadata = &m\n\t\t\treturn ErrTarStopIteration\n\t\t}\n\t\treturn nil\n\t}\n\tif err := IterateTar(reader, visitor); err != nil {\n\t\treturn Metadata{}, err\n\t}\n\tif metadata == nil {\n\t\treturn Metadata{}, &ErrFileNotFound{tarPath}\n\t}\n\treturn *metadata, nil\n}\n\n// UntarToDirectory writes the contents of the given tar reader to the given destination. Note: this is meant to handle\n// archives for images (not image contents) thus intentionally does not handle links or any kinds of special files.\nfunc UntarToDirectory(reader io.Reader, dst string) error {\n\treturn IterateTar(\n\t\treader,\n\t\ttarVisitor{\n\t\t\tfs:          afero.NewOsFs(),\n\t\t\tdestination: dst,\n\t\t}.visit,\n\t)\n}\n\ntype tarVisitor struct {\n\tfs          afero.Fs\n\tdestination string\n}\n\nfunc (v tarVisitor) visit(entry TarFileEntry) error {\n\ttarget := filepath.Join(v.destination, entry.Header.Name)\n\n\t// we should not allow for any destination path to be outside of where we are unarchiving to\n\tif !strings.HasPrefix(target, v.destination) {\n\t\treturn fmt.Errorf(\"potential path traversal attack with entry: %q\", entry.Header.Name)\n\t}\n\n\tswitch entry.Header.Typeflag {\n\tcase tar.TypeSymlink, tar.TypeLink:\n\t\t// we don't handle this is to prevent any potential traversal attacks\n\t\tlog.WithFields(\"path\", entry.Header.Name).Trace(\"skipping symlink/link entry in image tar\")\n\n\tcase tar.TypeDir:\n\t\tif _, err := v.fs.Stat(target); err != nil {\n\t\t\tif err := v.fs.MkdirAll(target, 0755); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\tcase tar.TypeReg:\n\t\tf, err := v.fs.OpenFile(target, os.O_CREATE|os.O_RDWR, os.FileMode(entry.Header.Mode))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// limit the reader on each file read to prevent decompression bomb attacks\n\t\tnumBytes, err := io.Copy(f, io.LimitReader(entry.Reader, perFileReadLimit))\n\t\tif numBytes >= perFileReadLimit || errors.Is(err, io.EOF) {\n\t\t\treturn fmt.Errorf(\"zip read limit hit (potential decompression bomb attack)\")\n\t\t}\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to copy file: %w\", err)\n\t\t}\n\n\t\tif err = f.Close(); err != nil {\n\t\t\tlog.Errorf(\"failed to close file during untar of path=%q: %w\", f.Name(), err)\n\t\t}\n\t}\n\treturn nil\n}\n", "//go:build !windows\n// +build !windows\n\npackage file\n\nimport (\n\t\"archive/tar\"\n\t\"crypto/sha256\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/scylladb/go-set/strset\"\n\t\"github.com/spf13/afero\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nconst (\n\tfixturesPath = \"test-fixtures\"\n)\n\nvar (\n\tfixturesGeneratorsPath = path.Join(fixturesPath, \"generators\")\n\ttarCachePath           = path.Join(fixturesPath, \"tar-cache\")\n)\n\nfunc TestReaderFromTar_GoCase(t *testing.T) {\n\ttarReader := getTarFixture(t, \"fixture-1\")\n\n\tfileReader, err := ReaderFromTar(tarReader, \"path/branch/two/file-2.txt\")\n\tif err != nil {\n\t\tt.Fatal(\"could not get file reader from tar:\", err)\n\t}\n\n\tcontents, err := io.ReadAll(fileReader)\n\tif err != nil {\n\t\tt.Fatal(\"could not read from file reader:\", err)\n\t}\n\n\tif string(contents) != \"second file\\n\" {\n\t\tt.Errorf(\"unexpected contents: '%s'\", string(contents))\n\t}\n}\n\nfunc TestReaderFromTar_MissingFile(t *testing.T) {\n\ttarReader := getTarFixture(t, \"fixture-1\")\n\n\t_, err := ReaderFromTar(tarReader, \"nOn-ExIsTaNt-paTh\")\n\tif err == nil {\n\t\tt.Error(\"expected an error but did not find one\")\n\t}\n}\n\nfunc TestMetadataFromTar(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tfixture  string\n\t\texpected Metadata\n\t}{\n\t\t{\n\t\t\tname:    \"path/branch/two/file-2.txt\",\n\t\t\tfixture: \"fixture-1\",\n\t\t\texpected: Metadata{\n\t\t\t\tPath:            \"/path/branch/two/file-2.txt\",\n\t\t\t\tLinkDestination: \"\",\n\t\t\t\tUserID:          1337,\n\t\t\t\tGroupID:         5432,\n\t\t\t\tType:            TypeRegular,\n\t\t\t\tMIMEType:        \"application/octet-stream\",\n\t\t\t\tFileInfo: ManualInfo{\n\t\t\t\t\tNameValue:    \"file-2.txt\",\n\t\t\t\t\tSizeValue:    12,\n\t\t\t\t\tModeValue:    0x1ed,\n\t\t\t\t\tModTimeValue: time.Date(2019, time.September, 16, 0, 0, 0, 0, time.UTC),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"path/branch/two/\",\n\t\t\tfixture: \"fixture-1\",\n\t\t\texpected: Metadata{\n\t\t\t\tPath:            \"/path/branch/two\",\n\t\t\t\tLinkDestination: \"\",\n\t\t\t\tUserID:          1337,\n\t\t\t\tGroupID:         5432,\n\t\t\t\tType:            TypeDirectory,\n\t\t\t\tMIMEType:        \"\",\n\t\t\t\tFileInfo: ManualInfo{\n\t\t\t\t\tNameValue:    \"two\",\n\t\t\t\t\tSizeValue:    0,\n\t\t\t\t\tModeValue:    0x800001ed,\n\t\t\t\t\tModTimeValue: time.Date(2019, time.September, 16, 0, 0, 0, 0, time.UTC),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tf := getTarFixture(t, test.fixture)\n\t\t\tmetadata, err := MetadataFromTar(f, test.name)\n\t\t\tassert.NoError(t, err)\n\t\t\tassertMetadataEqual(t, test.expected, metadata)\n\t\t})\n\t}\n}\n\nfunc getTarFixture(t testing.TB, name string) *os.File {\n\tgeneratorScriptName := name + \".sh\"\n\tgeneratorScriptPath := path.Join(fixturesGeneratorsPath, generatorScriptName)\n\tif !fileExists(t, generatorScriptPath) {\n\t\tt.Fatalf(\"no tar generator script for fixture '%s'\", generatorScriptPath)\n\t}\n\n\tversion := fixtureVersion(t, generatorScriptPath)\n\ttarName := name + \":\" + version + \".tar\"\n\ttarFixturePath := path.Join(tarCachePath, tarName)\n\n\tif !fileExists(t, tarFixturePath) {\n\t\tt.Logf(\"Creating tar fixture: %s\", tarFixturePath)\n\n\t\tfullPath, err := filepath.Abs(tarFixturePath)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tcmd := exec.Command(\"./\"+generatorScriptName, fullPath)\n\t\tcmd.Env = os.Environ()\n\t\tcmd.Dir = fixturesGeneratorsPath\n\t\tcmd.Stdout = os.Stdout\n\t\tcmd.Stderr = os.Stderr\n\t\tcmd.Stdin = os.Stdin\n\n\t\terr = cmd.Run()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tfile, err := os.Open(tarFixturePath)\n\tif err != nil {\n\t\tt.Fatalf(\"could not open tar fixture '%s'\", tarFixturePath)\n\t}\n\n\tt.Cleanup(func() {\n\t\tfile.Close()\n\t})\n\n\treturn file\n}\n\nfunc fixtureVersion(t testing.TB, path string) string {\n\tt.Helper()\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() {\n\t\terr := f.Close()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}()\n\n\th := sha256.New()\n\tif _, err := io.Copy(h, f); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treturn fmt.Sprintf(\"%x\", h.Sum(nil))\n}\n\nfunc fileExists(t testing.TB, filename string) bool {\n\tt.Helper()\n\tinfo, err := os.Stat(filename)\n\tif os.IsNotExist(err) {\n\t\treturn false\n\t} else if err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn !info.IsDir()\n}\n\nfunc Test_tarVisitor_visit(t *testing.T) {\n\tassertNoFilesInRoot := func(t testing.TB, fs afero.Fs) {\n\t\tt.Helper()\n\n\t\tallowableFiles := strset.New(\"tmp\")\n\n\t\t// list all files in root\n\t\tfiles, err := afero.ReadDir(fs, \"/\")\n\t\trequire.NoError(t, err)\n\n\t\tfor _, f := range files {\n\t\t\tassert.True(t, allowableFiles.Has(f.Name()), \"unexpected file in root: %s\", f.Name())\n\t\t}\n\t}\n\n\tassertPaths := func(expectedFiles []string, expectedDirs []string) func(t testing.TB, fs afero.Fs) {\n\t\treturn func(t testing.TB, fs afero.Fs) {\n\t\t\tt.Helper()\n\n\t\t\tsort.Strings(expectedFiles)\n\t\t\thaveFiles := strset.New()\n\t\t\thaveDirs := strset.New()\n\t\t\terr := afero.Walk(fs, \"/\", func(path string, info os.FileInfo, err error) error {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tif info.IsDir() {\n\t\t\t\t\thaveDirs.Add(path)\n\t\t\t\t} else {\n\t\t\t\t\thaveFiles.Add(path)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t})\n\n\t\t\thaveFilesList := haveFiles.List()\n\t\t\tsort.Strings(haveFilesList)\n\n\t\t\thaveDirsList := haveDirs.List()\n\t\t\tsort.Strings(haveDirsList)\n\n\t\t\trequire.NoError(t, err)\n\n\t\t\tif d := cmp.Diff(expectedFiles, haveFilesList); d != \"\" {\n\t\t\t\tt.Errorf(\"unexpected files (-want +got):\\n%s\", d)\n\t\t\t}\n\n\t\t\tif d := cmp.Diff(expectedDirs, haveDirsList); d != \"\" {\n\t\t\t\tt.Errorf(\"unexpected dirs (-want +got):\\n%s\", d)\n\t\t\t}\n\n\t\t}\n\t}\n\n\ttests := []struct {\n\t\tname     string\n\t\tentry    TarFileEntry\n\t\twantErr  require.ErrorAssertionFunc\n\t\tassertFs []func(t testing.TB, fs afero.Fs)\n\t}{\n\t\t{\n\t\t\tname: \"regular file is written\",\n\t\t\tentry: TarFileEntry{\n\t\t\t\tSequence: 0,\n\t\t\t\tHeader: tar.Header{\n\t\t\t\t\tTypeflag: tar.TypeReg,\n\t\t\t\t\tName:     \"file.txt\",\n\t\t\t\t\tLinkname: \"\",\n\t\t\t\t\tSize:     2,\n\t\t\t\t},\n\t\t\t\tReader: strings.NewReader(\"hi\"),\n\t\t\t},\n\t\t\tassertFs: []func(t testing.TB, fs afero.Fs){\n\t\t\t\tassertPaths(\n\t\t\t\t\t[]string{\"/tmp/file.txt\"},\n\t\t\t\t\t[]string{\"/\", \"/tmp\"},\n\t\t\t\t),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"regular file with possible path traversal errors out\",\n\t\t\tentry: TarFileEntry{\n\t\t\t\tSequence: 0,\n\t\t\t\tHeader: tar.Header{\n\t\t\t\t\tTypeflag: tar.TypeReg,\n\t\t\t\t\tName:     \"../file.txt\",\n\t\t\t\t\tLinkname: \"\",\n\t\t\t\t\tSize:     2,\n\t\t\t\t},\n\t\t\t\tReader: strings.NewReader(\"hi\"),\n\t\t\t},\n\t\t\twantErr: require.Error,\n\t\t},\n\t\t{\n\t\t\tname: \"directory is created\",\n\t\t\tentry: TarFileEntry{\n\t\t\t\tSequence: 0,\n\t\t\t\tHeader: tar.Header{\n\t\t\t\t\tTypeflag: tar.TypeDir,\n\t\t\t\t\tName:     \"dir\",\n\t\t\t\t\tLinkname: \"\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tassertFs: []func(t testing.TB, fs afero.Fs){\n\t\t\t\tassertPaths(\n\t\t\t\t\t[]string{},\n\t\t\t\t\t[]string{\"/\", \"/tmp\", \"/tmp/dir\"},\n\t\t\t\t),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"symlink is ignored\",\n\t\t\tentry: TarFileEntry{\n\t\t\t\tSequence: 0,\n\t\t\t\tHeader: tar.Header{\n\t\t\t\t\tTypeflag: tar.TypeSymlink,\n\t\t\t\t\tName:     \"symlink\",\n\t\t\t\t\tLinkname: \"./../to-location\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tassertFs: []func(t testing.TB, fs afero.Fs){\n\t\t\t\tassertPaths(\n\t\t\t\t\t[]string{},\n\t\t\t\t\t[]string{\"/\"},\n\t\t\t\t),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"hardlink is ignored\",\n\t\t\tentry: TarFileEntry{\n\t\t\t\tSequence: 0,\n\t\t\t\tHeader: tar.Header{\n\t\t\t\t\tTypeflag: tar.TypeLink,\n\t\t\t\t\tName:     \"link\",\n\t\t\t\t\tLinkname: \"./../to-location\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tassertFs: []func(t testing.TB, fs afero.Fs){\n\t\t\t\tassertPaths(\n\t\t\t\t\t[]string{},\n\t\t\t\t\t[]string{\"/\"},\n\t\t\t\t),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"device is ignored\",\n\t\t\tentry: TarFileEntry{\n\t\t\t\tSequence: 0,\n\t\t\t\tHeader: tar.Header{\n\t\t\t\t\tTypeflag: tar.TypeChar,\n\t\t\t\t\tName:     \"device\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tassertFs: []func(t testing.TB, fs afero.Fs){\n\t\t\t\tassertPaths(\n\t\t\t\t\t[]string{},\n\t\t\t\t\t[]string{\"/\"},\n\t\t\t\t),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"block device is ignored\",\n\t\t\tentry: TarFileEntry{\n\t\t\t\tSequence: 0,\n\t\t\t\tHeader: tar.Header{\n\t\t\t\t\tTypeflag: tar.TypeBlock,\n\t\t\t\t\tName:     \"device\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tassertFs: []func(t testing.TB, fs afero.Fs){\n\t\t\t\tassertPaths(\n\t\t\t\t\t[]string{},\n\t\t\t\t\t[]string{\"/\"},\n\t\t\t\t),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"pipe is ignored\",\n\t\t\tentry: TarFileEntry{\n\t\t\t\tSequence: 0,\n\t\t\t\tHeader: tar.Header{\n\t\t\t\t\tTypeflag: tar.TypeFifo,\n\t\t\t\t\tName:     \"pipe\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tassertFs: []func(t testing.TB, fs afero.Fs){\n\t\t\t\tassertPaths(\n\t\t\t\t\t[]string{},\n\t\t\t\t\t[]string{\"/\"},\n\t\t\t\t),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.wantErr == nil {\n\t\t\t\ttt.wantErr = require.NoError\n\t\t\t}\n\t\t\tv := tarVisitor{\n\t\t\t\tfs:          afero.NewMemMapFs(),\n\t\t\t\tdestination: \"/tmp\",\n\t\t\t}\n\t\t\terr := v.visit(tt.entry)\n\t\t\ttt.wantErr(t, err)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor _, fn := range tt.assertFs {\n\t\t\t\tfn(t, v.fs)\n\t\t\t}\n\n\t\t\t// even if the test has no other assertions, check that the root is empty\n\t\t\tassertNoFilesInRoot(t, v.fs)\n\t\t})\n\t}\n}\n"], "filenames": ["pkg/file/tarutil.go", "pkg/file/tarutil_test.go"], "buggy_code_start_loc": [8, 6], "buggy_code_end_loc": [163, 183], "fixing_code_start_loc": [9, 7], "fixing_code_end_loc": [186, 405], "type": "CWE-22", "message": "stereoscope is a go library for processing container images and simulating a squash filesystem.  Prior to version 0.0.1, it is possible to craft an OCI tar archive that, when stereoscope attempts to unarchive the contents, will result in writing to paths outside of the unarchive temporary directory. Specifically, use of `github.com/anchore/stereoscope/pkg/file.UntarToDirectory()` function, the  `github.com/anchore/stereoscope/pkg/image/oci.TarballImageProvider` struct, or the higher level `github.com/anchore/stereoscope/pkg/image.Image.Read()` function express this vulnerability. As a workaround, if you are using the OCI archive as input into stereoscope then you can switch to using an OCI layout by unarchiving the tar archive and provide the unarchived directory to stereoscope.", "other": {"cve": {"id": "CVE-2024-24579", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-31T17:15:40.170", "lastModified": "2024-02-09T16:22:53.863", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "stereoscope is a go library for processing container images and simulating a squash filesystem.  Prior to version 0.0.1, it is possible to craft an OCI tar archive that, when stereoscope attempts to unarchive the contents, will result in writing to paths outside of the unarchive temporary directory. Specifically, use of `github.com/anchore/stereoscope/pkg/file.UntarToDirectory()` function, the  `github.com/anchore/stereoscope/pkg/image/oci.TarballImageProvider` struct, or the higher level `github.com/anchore/stereoscope/pkg/image.Image.Read()` function express this vulnerability. As a workaround, if you are using the OCI archive as input into stereoscope then you can switch to using an OCI layout by unarchiving the tar archive and provide the unarchived directory to stereoscope."}, {"lang": "es", "value": "stereoscope es una liibrer\u00eda para procesar im\u00e1genes de contenedores y simular un sistema de archivos squash. Antes de la versi\u00f3n 0.0.1, era posible crear un archivo tar OCI que, cuando stereoscope  intenta desarchivar el contenido, se escribir\u00eda en rutas fuera del directorio temporal de desarchivado. Espec\u00edficamente, el uso de la funci\u00f3n `github.com/anchore/stereoscope/pkg/file.UntarToDirectory()`, la estructura `github.com/anchore/stereoscope/pkg/image/oci.TarballImageProvider` o el nivel superior `github. com/anchore/stereoscope/pkg/image.Image.Read()` expresa esta vulnerabilidad. Como workaround, si est\u00e1 utilizando el archivo OCI como entrada en el estereoscopio, puede pasar a utilizar un dise\u00f1o OCI desarchivando el archivo tar y proporcionando el directorio desarchivado al estereoscopio."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:anchore:stereoscope:*:*:*:*:*:go:*:*", "versionEndExcluding": "0.0.1", "matchCriteriaId": "E1B95457-6283-4E61-91A7-FF04FC0BB138"}]}]}], "references": [{"url": "https://github.com/anchore/stereoscope/commit/09dacab4d9ee65ee8bc7af8ebf4aa7b5aaa36204", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/anchore/stereoscope/security/advisories/GHSA-hpxr-w9w7-g4gv", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/anchore/stereoscope/commit/09dacab4d9ee65ee8bc7af8ebf4aa7b5aaa36204"}}