{"buggy_code": ["/*-\n * Copyright (c) 2011 NetApp, Inc.\n * Copyright (c) 2015 xhyve developers\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY NETAPP, INC ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL NETAPP, INC OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * $FreeBSD$\n */\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <strings.h>\n#include <pthread.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <assert.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <xhyve/support/misc.h>\n#include <xhyve/support/linker_set.h>\n#include <xhyve/support/md5.h>\n#include <xhyve/xhyve.h>\n#include <xhyve/pci_emul.h>\n#include <xhyve/virtio.h>\n#include <xhyve/block_if.h>\n\n#define VTBLK_RINGSZ    128\n\n#define VTBLK_S_OK\t0\n#define VTBLK_S_IOERR\t1\n#define\tVTBLK_S_UNSUPP\t2\n\n#define\tVTBLK_BLK_ID_BYTES 20 + 1\n\n/* Capability bits */\n#define\tVTBLK_F_SEG_MAX\t\t(1 << 2)\t/* Maximum request segments */\n#define\tVTBLK_F_BLK_SIZE\t(1 << 6)\t/* cfg block size valid */\n#define\tVTBLK_F_FLUSH\t\t(1 << 9)\t/* Cache flush support */\n#define\tVTBLK_F_TOPOLOGY\t(1 << 10)\t/* Optimal I/O alignment */\n#define\tVTBLK_F_DISCARD\t\t(1 << 13)\t/* Supports DISCARD / TRIM / WRITEZEROES */\n#define\tVTBLK_F_WRITE_ZEROES\t(1 << 14)\n\n/*\n * Host capabilities\n */\n#define VTBLK_S_HOSTCAPS      \\\n  ( VTBLK_F_SEG_MAX  |\t\t\t\t\t\t    \\\n    VTBLK_F_BLK_SIZE |\t\t\t\t\t\t    \\\n    VTBLK_F_FLUSH    |\t\t\t\t\t\t    \\\n    VTBLK_F_TOPOLOGY |\t\t\t\t\t\t    \\\n    VTBLK_F_DISCARD  |\t\t\t\t\t\t    \\\n    VIRTIO_RING_F_INDIRECT_DESC )\t/* indirect descriptors */\n\n/*\n * Config space \"registers\"\n */\nstruct vtblk_config {\n\tuint64_t\tvbc_capacity;\n\tuint32_t\tvbc_size_max;\n\tuint32_t\tvbc_seg_max;\n\tstruct {\n\t\tuint16_t cylinders;\n\t\tuint8_t heads;\n\t\tuint8_t sectors;\n\t} vbc_geometry;\n\tuint32_t\tvbc_blk_size;\n\tstruct {\n\t\tuint8_t physical_block_exp;\n\t\tuint8_t alignment_offset;\n\t\tuint16_t min_io_size;\n\t\tuint32_t opt_io_size;\n\t} vbc_topology;\n\tuint8_t\t\tvbc_writeback;\n\tuint8_t\t\tunused0[3];\n\tuint32_t\tmax_discard_sectors; /* in 512 byte units */\n\tuint32_t\tmax_discard_seg;\n\tuint32_t\tdiscard_sector_alignment; /* in 512 byte units */\n\tuint32_t\tmax_write_zeroes_sectors;\n\tuint32_t\tmax_write_zeroes_seg;\n\tuint8_t\t\twrite_zeroes_may_unmap;\n\tuint8_t\t\tunused1[3];\n} __packed;\n\n/*\n * Fixed-size block header\n */\nstruct virtio_blk_hdr {\n#define\tVBH_OP_READ\t\t0\n#define\tVBH_OP_WRITE\t\t1\n#define\tVBH_OP_FLUSH\t\t4\n#define\tVBH_OP_FLUSH_OUT\t5\n#define\tVBH_OP_IDENT\t\t8\n#define\tVBH_OP_DISCARD\t\t11\n#define\tVBH_OP_WRITE_ZEROES\t13\n#define\tVBH_FLAG_BARRIER\t0x80000000\t/* OR'ed into vbh_type */\n\tuint32_t       \tvbh_type;\n\tuint32_t\tvbh_ioprio;\n\tuint64_t\tvbh_sector;\n} __packed;\n\nstatic const char *print_vbh_op(int op) {\n\tswitch ((unsigned int)op & ~VBH_FLAG_BARRIER){\n\tcase VBH_OP_READ:\n\t\treturn \"READ\";\n\tcase VBH_OP_WRITE:\n\t\treturn \"WRITE\";\n\tcase VBH_OP_FLUSH:\n\t\treturn \"FLUSH\";\n\tcase VBH_OP_FLUSH_OUT:\n\t\treturn \"FLUSH_OUT\";\n\tcase VBH_OP_IDENT:\n\t\treturn \"IDENT\";\n\tcase VBH_OP_DISCARD:\n\t\treturn \"DISCARD\";\n\tcase VBH_OP_WRITE_ZEROES:\n\t\treturn \"WRITE_ZEROES\";\n\t}\n\treturn \"UNKNOWN\";\n}\n\n/*\n * Discard / write-zeroes segments\n */\nstruct virtio_blk_discard_write_zeroes {\n\tuint64_t sector; /* starting offset in 512-byte units */\n\tuint32_t num_sectors; /* number of 512-byte units */\n\tstruct {\n\t\tuint32_t unmap:1;\n\t\tuint32_t reserved:31;\n\t} flags;\n} __packed;\n\n/*\n * Debug printf\n */\nstatic int pci_vtblk_debug;\n#define DPRINTF(params) if (pci_vtblk_debug) printf params\n\nstruct pci_vtblk_ioreq {\n\tstruct blockif_req\t\tio_req;\n\tstruct pci_vtblk_softc\t       *io_sc;\n\tuint8_t\t\t\t       *io_status;\n\tuint16_t\t\t\tio_idx;\n};\n\n/*\n * Per-device softc\n */\nstruct pci_vtblk_softc {\n\tstruct virtio_softc vbsc_vs;\n\tpthread_mutex_t vsc_mtx;\n\tstruct vqueue_info vbsc_vq;\n\tstruct vtblk_config vbsc_cfg;\n\tstruct blockif_ctxt *bc;\n\tchar vbsc_ident[VTBLK_BLK_ID_BYTES];\n\tstruct pci_vtblk_ioreq vbsc_ios[VTBLK_RINGSZ];\n};\n\nstatic void pci_vtblk_reset(void *);\nstatic void pci_vtblk_notify(void *, struct vqueue_info *);\nstatic int pci_vtblk_cfgread(void *, int, int, uint32_t *);\nstatic int pci_vtblk_cfgwrite(void *, int, int, uint32_t);\n\nstatic struct virtio_consts vtblk_vi_consts_defaults = {\n\t\"vtblk\",\t\t/* our name */\n\t1,\t\t\t/* we support 1 virtqueue */\n\tsizeof(struct vtblk_config), /* config reg size */\n\tpci_vtblk_reset,\t/* reset */\n\tpci_vtblk_notify,\t/* device-wide qnotify */\n\tpci_vtblk_cfgread,\t/* read PCI config */\n\tpci_vtblk_cfgwrite,\t/* write PCI config */\n\tNULL,\t\t\t/* apply negotiated features */\n\tVTBLK_S_HOSTCAPS,\t/* our capabilities */\n};\n\nstatic void\npci_vtblk_reset(void *vsc)\n{\n\tstruct pci_vtblk_softc *sc = vsc;\n\n\tDPRINTF((\"vtblk: device reset requested !\\n\"));\n\tvi_reset_dev(&sc->vbsc_vs);\n}\n\n/* xhyve: FIXME\n *\n * pci_vtblk_done seems to deadlock when called from pci_vtblk_proc?\n */\nstatic void\npci_vtblk_done_locked(struct blockif_req *br, int err)\n{\n\tstruct pci_vtblk_ioreq *io = br->br_param;\n\tstruct pci_vtblk_softc *sc = io->io_sc;\n\n\t/* convert errno into a virtio block error return */\n\tif (err == EOPNOTSUPP || err == ENOSYS)\n\t\t*io->io_status = VTBLK_S_UNSUPP;\n\telse if (err != 0)\n\t\t*io->io_status = VTBLK_S_IOERR;\n\telse\n\t\t*io->io_status = VTBLK_S_OK;\n\n\t/*\n\t * Return the descriptor back to the host.\n\t * We wrote 1 byte (our status) to host.\n\t */\n\t//pthread_mutex_lock(&sc->vsc_mtx);\n\tvq_relchain(&sc->vbsc_vq, io->io_idx, 1);\n\tvq_endchains(&sc->vbsc_vq, 0);\n\t//pthread_mutex_unlock(&sc->vsc_mtx);\n}\n\nstatic void\npci_vtblk_done(struct blockif_req *br, int err) {\n\tstruct pci_vtblk_ioreq *io = br->br_param;\n\tstruct pci_vtblk_softc *sc = io->io_sc;\n\n\tpthread_mutex_lock(&sc->vsc_mtx);\n\tpci_vtblk_done_locked(br, err);\n\tpthread_mutex_unlock(&sc->vsc_mtx);\n}\n\nstatic void\npci_vtblk_proc(struct pci_vtblk_softc *sc, struct vqueue_info *vq)\n{\n\tstruct virtio_blk_hdr *vbh;\n\tstruct virtio_blk_discard_write_zeroes *vbdiscard;\n\tstruct pci_vtblk_ioreq *io;\n\tint i, n;\n\tint err;\n\tssize_t iolen;\n\tint expectro, type;\n\tstruct iovec iov[BLOCKIF_IOV_MAX + 2];\n\tuint16_t idx, flags[BLOCKIF_IOV_MAX + 2];\n\n\tn = vq_getchain(vq, &idx, iov, BLOCKIF_IOV_MAX + 2, flags);\n\n\t/*\n\t * The first descriptor will be the read-only fixed header,\n\t * and the last is for status (hence +2 above and below).\n\t * The remaining iov's are the actual data I/O vectors.\n\t *\n\t * XXX - note - this fails on crash dump, which does a\n\t * VIRTIO_BLK_T_FLUSH with a zero transfer length\n\t */\n\tassert(n >= 2 && n <= BLOCKIF_IOV_MAX + 2);\n\n\tio = &sc->vbsc_ios[idx];\n\tassert((flags[0] & VRING_DESC_F_WRITE) == 0);\n\tassert(iov[0].iov_len == sizeof(struct virtio_blk_hdr));\n\tvbh = iov[0].iov_base;\n\tmemcpy(&io->io_req.br_iov, &iov[1],\n\t       sizeof(struct iovec) * ((size_t)n - 2));\n\tio->io_req.br_iovcnt = n - 2;\n\tio->io_req.br_offset = (off_t)(vbh->vbh_sector * DEV_BSIZE);\n\tio->io_status = iov[--n].iov_base;\n\tassert(iov[n].iov_len == 1);\n\tassert(flags[n] & VRING_DESC_F_WRITE);\n\n\t/*\n\t * XXX\n\t * The guest should not be setting the BARRIER flag because\n\t * we don't advertise the capability.\n\t */\n\ttype = vbh->vbh_type & ~VBH_FLAG_BARRIER;\n\texpectro = (type == VBH_OP_WRITE) || (type == VBH_OP_DISCARD);\n\tiolen = 0;\n\tfor (i = 1; i < n; i++) {\n\t\t/*\n\t\t * - write/discard op implies read-only descriptor,\n\t\t * - read/ident op implies write-only descriptor,\n\t\t * therefore test the inverse of the descriptor bit\n\t\t * to the op.\n\t\t */\n\t\tassert(((flags[i] & VRING_DESC_F_WRITE) == 0) == expectro);\n\t\tiolen += iov[i].iov_len;\n\t}\n\tio->io_req.br_resid = iolen;\n\n\tDPRINTF((\"virtio-block: %s op, %zd bytes, %d segs\\n\\r\",\n\t\t print_vbh_op(type), iolen, i - 1));\n\n\tswitch (type) {\n\tcase VBH_OP_READ:\n\t\terr = blockif_read(sc->bc, &io->io_req);\n\t\tbreak;\n\tcase VBH_OP_WRITE:\n\t\terr = blockif_write(sc->bc, &io->io_req);\n\t\tbreak;\n\tcase VBH_OP_DISCARD:\n\t\t/* We currently limit the discard to one segment in the initial negotiation\n\t\t   so expect exactly one correctly-sized payload descriptor. */\n\t\tassert(iov[1].iov_len = sizeof(struct virtio_blk_discard_write_zeroes));\n\t\tassert(n == 2);\n\t\tvbdiscard = iov[1].iov_base;\n\t\tio->io_req.br_offset = (off_t) vbdiscard->sector * DEV_BSIZE;\n\t\tio->io_req.br_resid = vbdiscard->num_sectors * DEV_BSIZE;\n\t\terr = blockif_delete(sc->bc, &io->io_req);\n\t\tbreak;\n\tcase VBH_OP_FLUSH:\n\tcase VBH_OP_FLUSH_OUT:\n\t\terr = blockif_flush(sc->bc, &io->io_req);\n\t\tbreak;\n\tcase VBH_OP_IDENT:\n\t\t/* Assume a single buffer */\n\t\t/* S/n equal to buffer is not zero-terminated. */\n\t\tmemset(iov[1].iov_base, 0, iov[1].iov_len);\n\t\tstrncpy(iov[1].iov_base, sc->vbsc_ident,\n\t\t    MIN(iov[1].iov_len, sizeof(sc->vbsc_ident)));\n\t\t/* xhyve: FIXME */\n\t\tpci_vtblk_done_locked(&io->io_req, 0);\n\t\treturn;\n\tdefault:\n\t\t/* xhyve: FIXME */\n\t\tpci_vtblk_done_locked(&io->io_req, EOPNOTSUPP);\n\t\treturn;\n\t}\n\tassert(err == 0);\n}\n\nstatic void\npci_vtblk_notify(void *vsc, struct vqueue_info *vq)\n{\n\tstruct pci_vtblk_softc *sc = vsc;\n\n\twhile (vq_has_descs(vq))\n\t\tpci_vtblk_proc(sc, vq);\n}\n\nstatic int\npci_vtblk_init(struct pci_devinst *pi, char *opts)\n{\n\tchar bident[sizeof(\"XX:X:X\")];\n\tstruct blockif_ctxt *bctxt;\n\tMD5_CTX mdctx;\n\tu_char digest[16];\n\tstruct pci_vtblk_softc *sc;\n\toff_t size;\n\tint i, sectsz, sts, sto;\n\tstruct virtio_consts *vi_consts;\n\n\tif (opts == NULL) {\n\t\tprintf(\"virtio-block: backing device required\\n\");\n\t\treturn (1);\n\t}\n\n\t/*\n\t * The supplied backing file has to exist\n\t */\n\tsnprintf(bident, sizeof(bident), \"%d:%d\", pi->pi_slot, pi->pi_func);\n\tbctxt = blockif_open(opts, bident, 0);\n\tif (bctxt == NULL) {\n\t\tperror(\"Could not open backing file\");\n\t\treturn (1);\n\t}\n\n\tsize = blockif_size(bctxt);\n\tsectsz = blockif_sectsz(bctxt);\n\tblockif_psectsz(bctxt, &sts, &sto);\n\n\tsc = calloc(1, sizeof(struct pci_vtblk_softc));\n\tsc->bc = bctxt;\n\tfor (i = 0; i < VTBLK_RINGSZ; i++) {\n\t\tstruct pci_vtblk_ioreq *io = &sc->vbsc_ios[i];\n\t\tio->io_req.br_callback = pci_vtblk_done;\n\t\tio->io_req.br_param = io;\n\t\tio->io_sc = sc;\n\t\tio->io_idx = (uint16_t)i;\n\t}\n\n\tpthread_mutex_init(&sc->vsc_mtx, NULL);\n\n\t/* Customise the capabilities per-device */\n\tvi_consts = (struct virtio_consts*)malloc(sizeof(struct virtio_consts));\n\tif (vi_consts == NULL){\n\t\tperror(\"Failed to allocate buffer for virtio_consts\");\n\t\treturn (1);\n\t}\n\t*vi_consts = vtblk_vi_consts_defaults;\n\tif (!blockif_candelete(bctxt)){\n\t\t/* Don't tell the guest we can discard if the backing device doesn't support it */\n\t\tvi_consts->vc_hv_caps &= ~(uint64_t)VTBLK_F_DISCARD;\n\t}\n\n\t/* init virtio softc and virtqueues */\n\tvi_softc_linkup(&sc->vbsc_vs, vi_consts, sc, pi, &sc->vbsc_vq);\n\tsc->vbsc_vs.vs_mtx = &sc->vsc_mtx;\n\n\tsc->vbsc_vq.vq_qsize = VTBLK_RINGSZ;\n\t/* sc->vbsc_vq.vq_notify = we have no per-queue notify */\n\n\t/*\n\t * Create an identifier for the backing file. Use parts of the\n\t * md5 sum of the filename\n\t */\n\tMD5Init(&mdctx);\n\tMD5Update(&mdctx, opts, (unsigned)strlen(opts));\n\tMD5Final(digest, &mdctx);\n\tsnprintf(sc->vbsc_ident, VTBLK_BLK_ID_BYTES, \"BHYVE-%02X%02X-%02X%02X-%02X%02X\",\n\t    digest[0], digest[1], digest[2], digest[3], digest[4], digest[5]);\n\n\t/* setup virtio block config space */\n\tsc->vbsc_cfg.vbc_capacity =\n\t\t(uint64_t)(size / DEV_BSIZE); /* 512-byte units */\n\tsc->vbsc_cfg.vbc_size_max = 0;\t/* not negotiated */\n\tsc->vbsc_cfg.vbc_seg_max = BLOCKIF_IOV_MAX;\n\tsc->vbsc_cfg.max_discard_sectors = 1024 * 1024 * 1024 / DEV_BSIZE; /* 1 GiB in 512-byte sectors */\n\tsc->vbsc_cfg.max_discard_seg = 1; /* one offset, length range per request */\n\tsc->vbsc_cfg.discard_sector_alignment = 1; /* 512-byte units */\n\tsc->vbsc_cfg.vbc_geometry.cylinders = 0;\t/* no geometry */\n\tsc->vbsc_cfg.vbc_geometry.heads = 0;\n\tsc->vbsc_cfg.vbc_geometry.sectors = 0;\n\tsc->vbsc_cfg.vbc_blk_size = (uint32_t)sectsz;\n\tsc->vbsc_cfg.vbc_topology.physical_block_exp =\n\t    (uint8_t)((sts > sectsz) ? (ffsll(sts / sectsz) - 1) : 0);\n\tsc->vbsc_cfg.vbc_topology.alignment_offset =\n\t    (uint8_t)((sto != 0) ? ((sts - sto) / sectsz) : 0);\n\tsc->vbsc_cfg.vbc_topology.min_io_size = 0;\n\tsc->vbsc_cfg.vbc_topology.opt_io_size = 0;\n\tsc->vbsc_cfg.vbc_writeback = 0;\n\n\t/*\n\t * Should we move some of this into virtio.c?  Could\n\t * have the device, class, and subdev_0 as fields in\n\t * the virtio constants structure.\n\t */\n\tpci_set_cfgdata16(pi, PCIR_DEVICE, VIRTIO_DEV_BLOCK);\n\tpci_set_cfgdata16(pi, PCIR_VENDOR, VIRTIO_VENDOR);\n\tpci_set_cfgdata8(pi, PCIR_CLASS, PCIC_STORAGE);\n\tpci_set_cfgdata16(pi, PCIR_SUBDEV_0, VIRTIO_TYPE_BLOCK);\n\tpci_set_cfgdata16(pi, PCIR_SUBVEND_0, VIRTIO_VENDOR);\n\n\tif (vi_intr_init(&sc->vbsc_vs, 1, fbsdrun_virtio_msix())) {\n\t\tblockif_close(sc->bc);\n\t\tfree(sc);\n\t\treturn (1);\n\t}\n\tvi_set_io_bar(&sc->vbsc_vs, 0);\n\treturn (0);\n}\n\nstatic int\npci_vtblk_cfgwrite(UNUSED void *vsc, int offset, UNUSED int size,\n\tUNUSED uint32_t value)\n{\n\tDPRINTF((\"vtblk: write to readonly reg %d\\n\\r\", offset));\n\treturn (1);\n}\n\nstatic int\npci_vtblk_cfgread(void *vsc, int offset, int size, uint32_t *retval)\n{\n\tstruct pci_vtblk_softc *sc = vsc;\n\tvoid *ptr;\n\n\t/* our caller has already verified offset and size */\n\tptr = (uint8_t *)&sc->vbsc_cfg + offset;\n\tmemcpy(retval, ptr, size);\n\treturn (0);\n}\n\nstatic struct pci_devemu pci_de_vblk = {\n\t.pe_emu =\t\"virtio-blk\",\n\t.pe_init =\tpci_vtblk_init,\n\t.pe_barwrite =\tvi_pci_write,\n\t.pe_barread =\tvi_pci_read\n};\nPCI_EMUL_SET(pci_de_vblk);\n"], "fixing_code": ["/*-\n * Copyright (c) 2011 NetApp, Inc.\n * Copyright (c) 2015 xhyve developers\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY NETAPP, INC ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL NETAPP, INC OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * $FreeBSD$\n */\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <strings.h>\n#include <pthread.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <assert.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/disk.h>\n#include <xhyve/support/misc.h>\n#include <xhyve/support/linker_set.h>\n#include <xhyve/support/md5.h>\n#include <xhyve/xhyve.h>\n#include <xhyve/pci_emul.h>\n#include <xhyve/virtio.h>\n#include <xhyve/block_if.h>\n\n#define VTBLK_RINGSZ    128\n\n#define VTBLK_S_OK\t0\n#define VTBLK_S_IOERR\t1\n#define\tVTBLK_S_UNSUPP\t2\n\n#define\tVTBLK_BLK_ID_BYTES 20 + 1\n\n/* Capability bits */\n#define\tVTBLK_F_SEG_MAX\t\t(1 << 2)\t/* Maximum request segments */\n#define\tVTBLK_F_BLK_SIZE\t(1 << 6)\t/* cfg block size valid */\n#define\tVTBLK_F_FLUSH\t\t(1 << 9)\t/* Cache flush support */\n#define\tVTBLK_F_TOPOLOGY\t(1 << 10)\t/* Optimal I/O alignment */\n#define\tVTBLK_F_DISCARD\t\t(1 << 13)\t/* Supports DISCARD / TRIM / WRITEZEROES */\n#define\tVTBLK_F_WRITE_ZEROES\t(1 << 14)\n\n/*\n * Host capabilities\n */\n#define VTBLK_S_HOSTCAPS      \\\n  ( VTBLK_F_SEG_MAX  |\t\t\t\t\t\t    \\\n    VTBLK_F_BLK_SIZE |\t\t\t\t\t\t    \\\n    VTBLK_F_FLUSH    |\t\t\t\t\t\t    \\\n    VTBLK_F_TOPOLOGY |\t\t\t\t\t\t    \\\n    VTBLK_F_DISCARD  |\t\t\t\t\t\t    \\\n    VIRTIO_RING_F_INDIRECT_DESC )\t/* indirect descriptors */\n\n/*\n * Config space \"registers\"\n */\nstruct vtblk_config {\n\tuint64_t\tvbc_capacity;\n\tuint32_t\tvbc_size_max;\n\tuint32_t\tvbc_seg_max;\n\tstruct {\n\t\tuint16_t cylinders;\n\t\tuint8_t heads;\n\t\tuint8_t sectors;\n\t} vbc_geometry;\n\tuint32_t\tvbc_blk_size;\n\tstruct {\n\t\tuint8_t physical_block_exp;\n\t\tuint8_t alignment_offset;\n\t\tuint16_t min_io_size;\n\t\tuint32_t opt_io_size;\n\t} vbc_topology;\n\tuint8_t\t\tvbc_writeback;\n\tuint8_t\t\tunused0[3];\n\tuint32_t\tmax_discard_sectors; /* in 512 byte units */\n\tuint32_t\tmax_discard_seg;\n\tuint32_t\tdiscard_sector_alignment; /* in 512 byte units */\n\tuint32_t\tmax_write_zeroes_sectors;\n\tuint32_t\tmax_write_zeroes_seg;\n\tuint8_t\t\twrite_zeroes_may_unmap;\n\tuint8_t\t\tunused1[3];\n} __packed;\n\n/*\n * Fixed-size block header\n */\nstruct virtio_blk_hdr {\n#define\tVBH_OP_READ\t\t0\n#define\tVBH_OP_WRITE\t\t1\n#define\tVBH_OP_FLUSH\t\t4\n#define\tVBH_OP_FLUSH_OUT\t5\n#define\tVBH_OP_IDENT\t\t8\n#define\tVBH_OP_DISCARD\t\t11\n#define\tVBH_OP_WRITE_ZEROES\t13\n#define\tVBH_FLAG_BARRIER\t0x80000000\t/* OR'ed into vbh_type */\n\tuint32_t       \tvbh_type;\n\tuint32_t\tvbh_ioprio;\n\tuint64_t\tvbh_sector;\n} __packed;\n\nstatic const char *print_vbh_op(int op) {\n\tswitch ((unsigned int)op & ~VBH_FLAG_BARRIER){\n\tcase VBH_OP_READ:\n\t\treturn \"READ\";\n\tcase VBH_OP_WRITE:\n\t\treturn \"WRITE\";\n\tcase VBH_OP_FLUSH:\n\t\treturn \"FLUSH\";\n\tcase VBH_OP_FLUSH_OUT:\n\t\treturn \"FLUSH_OUT\";\n\tcase VBH_OP_IDENT:\n\t\treturn \"IDENT\";\n\tcase VBH_OP_DISCARD:\n\t\treturn \"DISCARD\";\n\tcase VBH_OP_WRITE_ZEROES:\n\t\treturn \"WRITE_ZEROES\";\n\t}\n\treturn \"UNKNOWN\";\n}\n\n/*\n * Discard / write-zeroes segments\n */\nstruct virtio_blk_discard_write_zeroes {\n\tuint64_t sector; /* starting offset in 512-byte units */\n\tuint32_t num_sectors; /* number of 512-byte units */\n\tstruct {\n\t\tuint32_t unmap:1;\n\t\tuint32_t reserved:31;\n\t} flags;\n} __packed;\n\n/*\n * Debug printf\n */\nstatic int pci_vtblk_debug;\n#define DPRINTF(params) if (pci_vtblk_debug) printf params\n\nstruct pci_vtblk_ioreq {\n\tstruct blockif_req\t\tio_req;\n\tstruct pci_vtblk_softc\t       *io_sc;\n\tuint8_t\t\t\t       *io_status;\n\tuint16_t\t\t\tio_idx;\n};\n\n/*\n * Per-device softc\n */\nstruct pci_vtblk_softc {\n\tstruct virtio_softc vbsc_vs;\n\tpthread_mutex_t vsc_mtx;\n\tstruct vqueue_info vbsc_vq;\n\tstruct vtblk_config vbsc_cfg;\n\tstruct blockif_ctxt *bc;\n\tchar vbsc_ident[VTBLK_BLK_ID_BYTES];\n\tstruct pci_vtblk_ioreq vbsc_ios[VTBLK_RINGSZ];\n};\n\nstatic void pci_vtblk_reset(void *);\nstatic void pci_vtblk_notify(void *, struct vqueue_info *);\nstatic int pci_vtblk_cfgread(void *, int, int, uint32_t *);\nstatic int pci_vtblk_cfgwrite(void *, int, int, uint32_t);\n\nstatic struct virtio_consts vtblk_vi_consts_defaults = {\n\t\"vtblk\",\t\t/* our name */\n\t1,\t\t\t/* we support 1 virtqueue */\n\tsizeof(struct vtblk_config), /* config reg size */\n\tpci_vtblk_reset,\t/* reset */\n\tpci_vtblk_notify,\t/* device-wide qnotify */\n\tpci_vtblk_cfgread,\t/* read PCI config */\n\tpci_vtblk_cfgwrite,\t/* write PCI config */\n\tNULL,\t\t\t/* apply negotiated features */\n\tVTBLK_S_HOSTCAPS,\t/* our capabilities */\n};\n\nstatic void\npci_vtblk_reset(void *vsc)\n{\n\tstruct pci_vtblk_softc *sc = vsc;\n\n\tDPRINTF((\"vtblk: device reset requested !\\n\"));\n\tvi_reset_dev(&sc->vbsc_vs);\n}\n\n/* xhyve: FIXME\n *\n * pci_vtblk_done seems to deadlock when called from pci_vtblk_proc?\n */\nstatic void\npci_vtblk_done_locked(struct blockif_req *br, int err)\n{\n\tstruct pci_vtblk_ioreq *io = br->br_param;\n\tstruct pci_vtblk_softc *sc = io->io_sc;\n\n\t/* convert errno into a virtio block error return */\n\tif (err == EOPNOTSUPP || err == ENOSYS)\n\t\t*io->io_status = VTBLK_S_UNSUPP;\n\telse if (err != 0)\n\t\t*io->io_status = VTBLK_S_IOERR;\n\telse\n\t\t*io->io_status = VTBLK_S_OK;\n\n\t/*\n\t * Return the descriptor back to the host.\n\t * We wrote 1 byte (our status) to host.\n\t */\n\t//pthread_mutex_lock(&sc->vsc_mtx);\n\tvq_relchain(&sc->vbsc_vq, io->io_idx, 1);\n\tvq_endchains(&sc->vbsc_vq, 0);\n\t//pthread_mutex_unlock(&sc->vsc_mtx);\n}\n\nstatic void\npci_vtblk_done(struct blockif_req *br, int err) {\n\tstruct pci_vtblk_ioreq *io = br->br_param;\n\tstruct pci_vtblk_softc *sc = io->io_sc;\n\n\tpthread_mutex_lock(&sc->vsc_mtx);\n\tpci_vtblk_done_locked(br, err);\n\tpthread_mutex_unlock(&sc->vsc_mtx);\n}\n\nstatic void\npci_vtblk_proc(struct pci_vtblk_softc *sc, struct vqueue_info *vq)\n{\n\tstruct virtio_blk_hdr *vbh;\n\tstruct virtio_blk_discard_write_zeroes *vbdiscard;\n\tstruct pci_vtblk_ioreq *io;\n\tint i, n;\n\tint err;\n\tssize_t iolen;\n\tint expectro, type;\n\tstruct iovec iov[BLOCKIF_IOV_MAX + 2];\n\tuint16_t idx, flags[BLOCKIF_IOV_MAX + 2];\n\n\tn = vq_getchain(vq, &idx, iov, BLOCKIF_IOV_MAX + 2, flags);\n\n\t/*\n\t * The first descriptor will be the read-only fixed header,\n\t * and the last is for status (hence +2 above and below).\n\t * The remaining iov's are the actual data I/O vectors.\n\t *\n\t * XXX - note - this fails on crash dump, which does a\n\t * VIRTIO_BLK_T_FLUSH with a zero transfer length\n\t */\n\tassert(n >= 2 && n <= BLOCKIF_IOV_MAX + 2);\n\n\tio = &sc->vbsc_ios[idx];\n\tassert((flags[0] & VRING_DESC_F_WRITE) == 0);\n\tassert(iov[0].iov_len == sizeof(struct virtio_blk_hdr));\n\tvbh = iov[0].iov_base;\n\tmemcpy(&io->io_req.br_iov, &iov[1],\n\t       sizeof(struct iovec) * ((size_t)n - 2));\n\tio->io_req.br_iovcnt = n - 2;\n\tio->io_req.br_offset = (off_t)(vbh->vbh_sector * DEV_BSIZE);\n\tio->io_status = iov[--n].iov_base;\n\tassert(iov[n].iov_len == 1);\n\tassert(flags[n] & VRING_DESC_F_WRITE);\n\n\t/*\n\t * XXX\n\t * The guest should not be setting the BARRIER flag because\n\t * we don't advertise the capability.\n\t */\n\ttype = vbh->vbh_type & ~VBH_FLAG_BARRIER;\n\texpectro = (type == VBH_OP_WRITE) || (type == VBH_OP_DISCARD);\n\tiolen = 0;\n\tfor (i = 1; i < n; i++) {\n\t\t/*\n\t\t * - write/discard op implies read-only descriptor,\n\t\t * - read/ident op implies write-only descriptor,\n\t\t * therefore test the inverse of the descriptor bit\n\t\t * to the op.\n\t\t */\n\t\tassert(((flags[i] & VRING_DESC_F_WRITE) == 0) == expectro);\n\t\tiolen += iov[i].iov_len;\n\t}\n\tio->io_req.br_resid = iolen;\n\n\tDPRINTF((\"virtio-block: %s op, %zd bytes, %d segs\\n\\r\",\n\t\t print_vbh_op(type), iolen, i - 1));\n\n\tswitch (type) {\n\tcase VBH_OP_READ:\n\t\terr = blockif_read(sc->bc, &io->io_req);\n\t\tbreak;\n\tcase VBH_OP_WRITE:\n\t\terr = blockif_write(sc->bc, &io->io_req);\n\t\tbreak;\n\tcase VBH_OP_DISCARD:\n\t\t/* We currently limit the discard to one segment in the initial negotiation\n\t\t   so expect exactly one correctly-sized payload descriptor. */\n\t\tassert(iov[1].iov_len == sizeof(struct virtio_blk_discard_write_zeroes));\n\t\tassert(n == 2);\n\t\tvbdiscard = iov[1].iov_base;\n\t\tio->io_req.br_offset = (off_t) vbdiscard->sector * DEV_BSIZE;\n\t\tio->io_req.br_resid = vbdiscard->num_sectors * DEV_BSIZE;\n\t\terr = blockif_delete(sc->bc, &io->io_req);\n\t\tbreak;\n\tcase VBH_OP_FLUSH:\n\tcase VBH_OP_FLUSH_OUT:\n\t\terr = blockif_flush(sc->bc, &io->io_req);\n\t\tbreak;\n\tcase VBH_OP_IDENT:\n\t\t/* Assume a single buffer */\n\t\t/* S/n equal to buffer is not zero-terminated. */\n\t\tmemset(iov[1].iov_base, 0, iov[1].iov_len);\n\t\tstrncpy(iov[1].iov_base, sc->vbsc_ident,\n\t\t    MIN(iov[1].iov_len, sizeof(sc->vbsc_ident)));\n\t\t/* xhyve: FIXME */\n\t\tpci_vtblk_done_locked(&io->io_req, 0);\n\t\treturn;\n\tdefault:\n\t\t/* xhyve: FIXME */\n\t\tpci_vtblk_done_locked(&io->io_req, EOPNOTSUPP);\n\t\treturn;\n\t}\n\tassert(err == 0);\n}\n\nstatic void\npci_vtblk_notify(void *vsc, struct vqueue_info *vq)\n{\n\tstruct pci_vtblk_softc *sc = vsc;\n\n\twhile (vq_has_descs(vq))\n\t\tpci_vtblk_proc(sc, vq);\n}\n\nstatic int\npci_vtblk_init(struct pci_devinst *pi, char *opts)\n{\n\tchar bident[sizeof(\"XX:X:X\")];\n\tstruct blockif_ctxt *bctxt;\n\tMD5_CTX mdctx;\n\tu_char digest[16];\n\tstruct pci_vtblk_softc *sc;\n\toff_t size;\n\tint i, sectsz, sts, sto;\n\tstruct virtio_consts *vi_consts;\n\n\tif (opts == NULL) {\n\t\tprintf(\"virtio-block: backing device required\\n\");\n\t\treturn (1);\n\t}\n\n\t/*\n\t * The supplied backing file has to exist\n\t */\n\tsnprintf(bident, sizeof(bident), \"%d:%d\", pi->pi_slot, pi->pi_func);\n\tbctxt = blockif_open(opts, bident, 0);\n\tif (bctxt == NULL) {\n\t\tperror(\"Could not open backing file\");\n\t\treturn (1);\n\t}\n\n\tsize = blockif_size(bctxt);\n\tsectsz = blockif_sectsz(bctxt);\n\tblockif_psectsz(bctxt, &sts, &sto);\n\n\tsc = calloc(1, sizeof(struct pci_vtblk_softc));\n\tsc->bc = bctxt;\n\tfor (i = 0; i < VTBLK_RINGSZ; i++) {\n\t\tstruct pci_vtblk_ioreq *io = &sc->vbsc_ios[i];\n\t\tio->io_req.br_callback = pci_vtblk_done;\n\t\tio->io_req.br_param = io;\n\t\tio->io_sc = sc;\n\t\tio->io_idx = (uint16_t)i;\n\t}\n\n\tpthread_mutex_init(&sc->vsc_mtx, NULL);\n\n\t/* Customise the capabilities per-device */\n\tvi_consts = (struct virtio_consts*)malloc(sizeof(struct virtio_consts));\n\tif (vi_consts == NULL){\n\t\tperror(\"Failed to allocate buffer for virtio_consts\");\n\t\treturn (1);\n\t}\n\t*vi_consts = vtblk_vi_consts_defaults;\n\tif (!blockif_candelete(bctxt)){\n\t\t/* Don't tell the guest we can discard if the backing device doesn't support it */\n\t\tvi_consts->vc_hv_caps &= ~(uint64_t)VTBLK_F_DISCARD;\n\t}\n\n\t/* init virtio softc and virtqueues */\n\tvi_softc_linkup(&sc->vbsc_vs, vi_consts, sc, pi, &sc->vbsc_vq);\n\tsc->vbsc_vs.vs_mtx = &sc->vsc_mtx;\n\n\tsc->vbsc_vq.vq_qsize = VTBLK_RINGSZ;\n\t/* sc->vbsc_vq.vq_notify = we have no per-queue notify */\n\n\t/*\n\t * Create an identifier for the backing file. Use parts of the\n\t * md5 sum of the filename\n\t */\n\tMD5Init(&mdctx);\n\tMD5Update(&mdctx, opts, (unsigned)strlen(opts));\n\tMD5Final(digest, &mdctx);\n\tsnprintf(sc->vbsc_ident, VTBLK_BLK_ID_BYTES, \"BHYVE-%02X%02X-%02X%02X-%02X%02X\",\n\t    digest[0], digest[1], digest[2], digest[3], digest[4], digest[5]);\n\n\t/* setup virtio block config space */\n\tsc->vbsc_cfg.vbc_capacity =\n\t\t(uint64_t)(size / DEV_BSIZE); /* 512-byte units */\n\tsc->vbsc_cfg.vbc_size_max = 0;\t/* not negotiated */\n\tsc->vbsc_cfg.vbc_seg_max = BLOCKIF_IOV_MAX;\n\tsc->vbsc_cfg.max_discard_sectors = 1024 * 1024 * 1024 / DEV_BSIZE; /* 1 GiB in 512-byte sectors */\n\tsc->vbsc_cfg.max_discard_seg = 1; /* one offset, length range per request */\n\tsc->vbsc_cfg.discard_sector_alignment = 1; /* 512-byte units */\n\tsc->vbsc_cfg.vbc_geometry.cylinders = 0;\t/* no geometry */\n\tsc->vbsc_cfg.vbc_geometry.heads = 0;\n\tsc->vbsc_cfg.vbc_geometry.sectors = 0;\n\tsc->vbsc_cfg.vbc_blk_size = (uint32_t)sectsz;\n\tsc->vbsc_cfg.vbc_topology.physical_block_exp =\n\t    (uint8_t)((sts > sectsz) ? (ffsll(sts / sectsz) - 1) : 0);\n\tsc->vbsc_cfg.vbc_topology.alignment_offset =\n\t    (uint8_t)((sto != 0) ? ((sts - sto) / sectsz) : 0);\n\tsc->vbsc_cfg.vbc_topology.min_io_size = 0;\n\tsc->vbsc_cfg.vbc_topology.opt_io_size = 0;\n\tsc->vbsc_cfg.vbc_writeback = 0;\n\n\t/*\n\t * Should we move some of this into virtio.c?  Could\n\t * have the device, class, and subdev_0 as fields in\n\t * the virtio constants structure.\n\t */\n\tpci_set_cfgdata16(pi, PCIR_DEVICE, VIRTIO_DEV_BLOCK);\n\tpci_set_cfgdata16(pi, PCIR_VENDOR, VIRTIO_VENDOR);\n\tpci_set_cfgdata8(pi, PCIR_CLASS, PCIC_STORAGE);\n\tpci_set_cfgdata16(pi, PCIR_SUBDEV_0, VIRTIO_TYPE_BLOCK);\n\tpci_set_cfgdata16(pi, PCIR_SUBVEND_0, VIRTIO_VENDOR);\n\n\tif (vi_intr_init(&sc->vbsc_vs, 1, fbsdrun_virtio_msix())) {\n\t\tblockif_close(sc->bc);\n\t\tfree(sc);\n\t\treturn (1);\n\t}\n\tvi_set_io_bar(&sc->vbsc_vs, 0);\n\treturn (0);\n}\n\nstatic int\npci_vtblk_cfgwrite(UNUSED void *vsc, int offset, UNUSED int size,\n\tUNUSED uint32_t value)\n{\n\tDPRINTF((\"vtblk: write to readonly reg %d\\n\\r\", offset));\n\treturn (1);\n}\n\nstatic int\npci_vtblk_cfgread(void *vsc, int offset, int size, uint32_t *retval)\n{\n\tstruct pci_vtblk_softc *sc = vsc;\n\tvoid *ptr;\n\n\t/* our caller has already verified offset and size */\n\tptr = (uint8_t *)&sc->vbsc_cfg + offset;\n\tmemcpy(retval, ptr, size);\n\treturn (0);\n}\n\nstatic struct pci_devemu pci_de_vblk = {\n\t.pe_emu =\t\"virtio-blk\",\n\t.pe_init =\tpci_vtblk_init,\n\t.pe_barwrite =\tvi_pci_write,\n\t.pe_barread =\tvi_pci_read\n};\nPCI_EMUL_SET(pci_de_vblk);\n"], "filenames": ["src/lib/pci_virtio_block.c"], "buggy_code_start_loc": [319], "buggy_code_end_loc": [320], "fixing_code_start_loc": [319], "fixing_code_end_loc": [320], "type": "CWE-125", "message": "HyperKit is a toolkit for embedding hypervisor capabilities in an application. In versions 0.20210107 and prior, a malicious guest can trigger a vulnerability in the host by abusing the disk driver that may lead to the disclosure of the host memory into the virtualized guest. This issue is fixed in commit cf60095a4d8c3cb2e182a14415467afd356e982f.", "other": {"cve": {"id": "CVE-2021-32847", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-20T17:15:11.857", "lastModified": "2023-03-01T18:03:13.990", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "HyperKit is a toolkit for embedding hypervisor capabilities in an application. In versions 0.20210107 and prior, a malicious guest can trigger a vulnerability in the host by abusing the disk driver that may lead to the disclosure of the host memory into the virtualized guest. This issue is fixed in commit cf60095a4d8c3cb2e182a14415467afd356e982f."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.0, "impactScore": 4.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.5, "impactScore": 4.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mobyproject:hyperkit:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.20210107", "matchCriteriaId": "0AE32831-24E2-44FD-939C-E6F799A5D632"}]}]}], "references": [{"url": "https://github.com/moby/hyperkit/blob/2f061e447e1435cdf1b9eda364cea6414f2c606b/src/lib/pci_virtio_block.c#L316", "source": "security-advisories@github.com", "tags": ["Exploit", "Product"]}, {"url": "https://github.com/moby/hyperkit/commit/cf60095a4d8c3cb2e182a14415467afd356e982f", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://securitylab.github.com/advisories/GHSL-2021-058-moby-hyperkit/", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/moby/hyperkit/commit/cf60095a4d8c3cb2e182a14415467afd356e982f"}}