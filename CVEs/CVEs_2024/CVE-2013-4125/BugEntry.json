{"buggy_code": ["/*\n *\tLinux INET6 implementation\n *\tForwarding Information Database\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n/*\n * \tChanges:\n * \tYuji SEKIYA @USAGI:\tSupport default route on router node;\n * \t\t\t\tremove ip6_null_entry from the top of\n * \t\t\t\trouting table.\n * \tVille Nuorvala:\t\tFixed routing subtrees.\n */\n\n#define pr_fmt(fmt) \"IPv6: \" fmt\n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/net.h>\n#include <linux/route.h>\n#include <linux/netdevice.h>\n#include <linux/in6.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\n#include <net/ipv6.h>\n#include <net/ndisc.h>\n#include <net/addrconf.h>\n\n#include <net/ip6_fib.h>\n#include <net/ip6_route.h>\n\n#define RT6_DEBUG 2\n\n#if RT6_DEBUG >= 3\n#define RT6_TRACE(x...) pr_debug(x)\n#else\n#define RT6_TRACE(x...) do { ; } while (0)\n#endif\n\nstatic struct kmem_cache * fib6_node_kmem __read_mostly;\n\nenum fib_walk_state_t\n{\n#ifdef CONFIG_IPV6_SUBTREES\n\tFWS_S,\n#endif\n\tFWS_L,\n\tFWS_R,\n\tFWS_C,\n\tFWS_U\n};\n\nstruct fib6_cleaner_t\n{\n\tstruct fib6_walker_t w;\n\tstruct net *net;\n\tint (*func)(struct rt6_info *, void *arg);\n\tvoid *arg;\n};\n\nstatic DEFINE_RWLOCK(fib6_walker_lock);\n\n#ifdef CONFIG_IPV6_SUBTREES\n#define FWS_INIT FWS_S\n#else\n#define FWS_INIT FWS_L\n#endif\n\nstatic void fib6_prune_clones(struct net *net, struct fib6_node *fn,\n\t\t\t      struct rt6_info *rt);\nstatic struct rt6_info *fib6_find_prefix(struct net *net, struct fib6_node *fn);\nstatic struct fib6_node *fib6_repair_tree(struct net *net, struct fib6_node *fn);\nstatic int fib6_walk(struct fib6_walker_t *w);\nstatic int fib6_walk_continue(struct fib6_walker_t *w);\n\n/*\n *\tA routing update causes an increase of the serial number on the\n *\taffected subtree. This allows for cached routes to be asynchronously\n *\ttested when modifications are made to the destination cache as a\n *\tresult of redirects, path MTU changes, etc.\n */\n\nstatic __u32 rt_sernum;\n\nstatic void fib6_gc_timer_cb(unsigned long arg);\n\nstatic LIST_HEAD(fib6_walkers);\n#define FOR_WALKERS(w) list_for_each_entry(w, &fib6_walkers, lh)\n\nstatic inline void fib6_walker_link(struct fib6_walker_t *w)\n{\n\twrite_lock_bh(&fib6_walker_lock);\n\tlist_add(&w->lh, &fib6_walkers);\n\twrite_unlock_bh(&fib6_walker_lock);\n}\n\nstatic inline void fib6_walker_unlink(struct fib6_walker_t *w)\n{\n\twrite_lock_bh(&fib6_walker_lock);\n\tlist_del(&w->lh);\n\twrite_unlock_bh(&fib6_walker_lock);\n}\nstatic __inline__ u32 fib6_new_sernum(void)\n{\n\tu32 n = ++rt_sernum;\n\tif ((__s32)n <= 0)\n\t\trt_sernum = n = 1;\n\treturn n;\n}\n\n/*\n *\tAuxiliary address test functions for the radix tree.\n *\n *\tThese assume a 32bit processor (although it will work on\n *\t64bit processors)\n */\n\n/*\n *\ttest bit\n */\n#if defined(__LITTLE_ENDIAN)\n# define BITOP_BE32_SWIZZLE\t(0x1F & ~7)\n#else\n# define BITOP_BE32_SWIZZLE\t0\n#endif\n\nstatic __inline__ __be32 addr_bit_set(const void *token, int fn_bit)\n{\n\tconst __be32 *addr = token;\n\t/*\n\t * Here,\n\t * \t1 << ((~fn_bit ^ BITOP_BE32_SWIZZLE) & 0x1f)\n\t * is optimized version of\n\t *\thtonl(1 << ((~fn_bit)&0x1F))\n\t * See include/asm-generic/bitops/le.h.\n\t */\n\treturn (__force __be32)(1 << ((~fn_bit ^ BITOP_BE32_SWIZZLE) & 0x1f)) &\n\t       addr[fn_bit >> 5];\n}\n\nstatic __inline__ struct fib6_node * node_alloc(void)\n{\n\tstruct fib6_node *fn;\n\n\tfn = kmem_cache_zalloc(fib6_node_kmem, GFP_ATOMIC);\n\n\treturn fn;\n}\n\nstatic __inline__ void node_free(struct fib6_node * fn)\n{\n\tkmem_cache_free(fib6_node_kmem, fn);\n}\n\nstatic __inline__ void rt6_release(struct rt6_info *rt)\n{\n\tif (atomic_dec_and_test(&rt->rt6i_ref))\n\t\tdst_free(&rt->dst);\n}\n\nstatic void fib6_link_table(struct net *net, struct fib6_table *tb)\n{\n\tunsigned int h;\n\n\t/*\n\t * Initialize table lock at a single place to give lockdep a key,\n\t * tables aren't visible prior to being linked to the list.\n\t */\n\trwlock_init(&tb->tb6_lock);\n\n\th = tb->tb6_id & (FIB6_TABLE_HASHSZ - 1);\n\n\t/*\n\t * No protection necessary, this is the only list mutatation\n\t * operation, tables never disappear once they exist.\n\t */\n\thlist_add_head_rcu(&tb->tb6_hlist, &net->ipv6.fib_table_hash[h]);\n}\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\nstatic struct fib6_table *fib6_alloc_table(struct net *net, u32 id)\n{\n\tstruct fib6_table *table;\n\n\ttable = kzalloc(sizeof(*table), GFP_ATOMIC);\n\tif (table) {\n\t\ttable->tb6_id = id;\n\t\ttable->tb6_root.leaf = net->ipv6.ip6_null_entry;\n\t\ttable->tb6_root.fn_flags = RTN_ROOT | RTN_TL_ROOT | RTN_RTINFO;\n\t\tinet_peer_base_init(&table->tb6_peers);\n\t}\n\n\treturn table;\n}\n\nstruct fib6_table *fib6_new_table(struct net *net, u32 id)\n{\n\tstruct fib6_table *tb;\n\n\tif (id == 0)\n\t\tid = RT6_TABLE_MAIN;\n\ttb = fib6_get_table(net, id);\n\tif (tb)\n\t\treturn tb;\n\n\ttb = fib6_alloc_table(net, id);\n\tif (tb)\n\t\tfib6_link_table(net, tb);\n\n\treturn tb;\n}\n\nstruct fib6_table *fib6_get_table(struct net *net, u32 id)\n{\n\tstruct fib6_table *tb;\n\tstruct hlist_head *head;\n\tunsigned int h;\n\n\tif (id == 0)\n\t\tid = RT6_TABLE_MAIN;\n\th = id & (FIB6_TABLE_HASHSZ - 1);\n\trcu_read_lock();\n\thead = &net->ipv6.fib_table_hash[h];\n\thlist_for_each_entry_rcu(tb, head, tb6_hlist) {\n\t\tif (tb->tb6_id == id) {\n\t\t\trcu_read_unlock();\n\t\t\treturn tb;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}\n\nstatic void __net_init fib6_tables_init(struct net *net)\n{\n\tfib6_link_table(net, net->ipv6.fib6_main_tbl);\n\tfib6_link_table(net, net->ipv6.fib6_local_tbl);\n}\n#else\n\nstruct fib6_table *fib6_new_table(struct net *net, u32 id)\n{\n\treturn fib6_get_table(net, id);\n}\n\nstruct fib6_table *fib6_get_table(struct net *net, u32 id)\n{\n\t  return net->ipv6.fib6_main_tbl;\n}\n\nstruct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   int flags, pol_lookup_t lookup)\n{\n\treturn (struct dst_entry *) lookup(net, net->ipv6.fib6_main_tbl, fl6, flags);\n}\n\nstatic void __net_init fib6_tables_init(struct net *net)\n{\n\tfib6_link_table(net, net->ipv6.fib6_main_tbl);\n}\n\n#endif\n\nstatic int fib6_dump_node(struct fib6_walker_t *w)\n{\n\tint res;\n\tstruct rt6_info *rt;\n\n\tfor (rt = w->leaf; rt; rt = rt->dst.rt6_next) {\n\t\tres = rt6_dump_route(rt, w->args);\n\t\tif (res < 0) {\n\t\t\t/* Frame is full, suspend walking */\n\t\t\tw->leaf = rt;\n\t\t\treturn 1;\n\t\t}\n\t\tWARN_ON(res == 0);\n\t}\n\tw->leaf = NULL;\n\treturn 0;\n}\n\nstatic void fib6_dump_end(struct netlink_callback *cb)\n{\n\tstruct fib6_walker_t *w = (void*)cb->args[2];\n\n\tif (w) {\n\t\tif (cb->args[4]) {\n\t\t\tcb->args[4] = 0;\n\t\t\tfib6_walker_unlink(w);\n\t\t}\n\t\tcb->args[2] = 0;\n\t\tkfree(w);\n\t}\n\tcb->done = (void*)cb->args[3];\n\tcb->args[1] = 3;\n}\n\nstatic int fib6_dump_done(struct netlink_callback *cb)\n{\n\tfib6_dump_end(cb);\n\treturn cb->done ? cb->done(cb) : 0;\n}\n\nstatic int fib6_dump_table(struct fib6_table *table, struct sk_buff *skb,\n\t\t\t   struct netlink_callback *cb)\n{\n\tstruct fib6_walker_t *w;\n\tint res;\n\n\tw = (void *)cb->args[2];\n\tw->root = &table->tb6_root;\n\n\tif (cb->args[4] == 0) {\n\t\tw->count = 0;\n\t\tw->skip = 0;\n\n\t\tread_lock_bh(&table->tb6_lock);\n\t\tres = fib6_walk(w);\n\t\tread_unlock_bh(&table->tb6_lock);\n\t\tif (res > 0) {\n\t\t\tcb->args[4] = 1;\n\t\t\tcb->args[5] = w->root->fn_sernum;\n\t\t}\n\t} else {\n\t\tif (cb->args[5] != w->root->fn_sernum) {\n\t\t\t/* Begin at the root if the tree changed */\n\t\t\tcb->args[5] = w->root->fn_sernum;\n\t\t\tw->state = FWS_INIT;\n\t\t\tw->node = w->root;\n\t\t\tw->skip = w->count;\n\t\t} else\n\t\t\tw->skip = 0;\n\n\t\tread_lock_bh(&table->tb6_lock);\n\t\tres = fib6_walk_continue(w);\n\t\tread_unlock_bh(&table->tb6_lock);\n\t\tif (res <= 0) {\n\t\t\tfib6_walker_unlink(w);\n\t\t\tcb->args[4] = 0;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic int inet6_dump_fib(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tunsigned int h, s_h;\n\tunsigned int e = 0, s_e;\n\tstruct rt6_rtnl_dump_arg arg;\n\tstruct fib6_walker_t *w;\n\tstruct fib6_table *tb;\n\tstruct hlist_head *head;\n\tint res = 0;\n\n\ts_h = cb->args[0];\n\ts_e = cb->args[1];\n\n\tw = (void *)cb->args[2];\n\tif (!w) {\n\t\t/* New dump:\n\t\t *\n\t\t * 1. hook callback destructor.\n\t\t */\n\t\tcb->args[3] = (long)cb->done;\n\t\tcb->done = fib6_dump_done;\n\n\t\t/*\n\t\t * 2. allocate and initialize walker.\n\t\t */\n\t\tw = kzalloc(sizeof(*w), GFP_ATOMIC);\n\t\tif (!w)\n\t\t\treturn -ENOMEM;\n\t\tw->func = fib6_dump_node;\n\t\tcb->args[2] = (long)w;\n\t}\n\n\targ.skb = skb;\n\targ.cb = cb;\n\targ.net = net;\n\tw->args = &arg;\n\n\trcu_read_lock();\n\tfor (h = s_h; h < FIB6_TABLE_HASHSZ; h++, s_e = 0) {\n\t\te = 0;\n\t\thead = &net->ipv6.fib_table_hash[h];\n\t\thlist_for_each_entry_rcu(tb, head, tb6_hlist) {\n\t\t\tif (e < s_e)\n\t\t\t\tgoto next;\n\t\t\tres = fib6_dump_table(tb, skb, cb);\n\t\t\tif (res != 0)\n\t\t\t\tgoto out;\nnext:\n\t\t\te++;\n\t\t}\n\t}\nout:\n\trcu_read_unlock();\n\tcb->args[1] = e;\n\tcb->args[0] = h;\n\n\tres = res < 0 ? res : skb->len;\n\tif (res <= 0)\n\t\tfib6_dump_end(cb);\n\treturn res;\n}\n\n/*\n *\tRouting Table\n *\n *\treturn the appropriate node for a routing tree \"add\" operation\n *\tby either creating and inserting or by returning an existing\n *\tnode.\n */\n\nstatic struct fib6_node * fib6_add_1(struct fib6_node *root, void *addr,\n\t\t\t\t     int addrlen, int plen,\n\t\t\t\t     int offset, int allow_create,\n\t\t\t\t     int replace_required)\n{\n\tstruct fib6_node *fn, *in, *ln;\n\tstruct fib6_node *pn = NULL;\n\tstruct rt6key *key;\n\tint\tbit;\n\t__be32\tdir = 0;\n\t__u32\tsernum = fib6_new_sernum();\n\n\tRT6_TRACE(\"fib6_add_1\\n\");\n\n\t/* insert node in tree */\n\n\tfn = root;\n\n\tdo {\n\t\tkey = (struct rt6key *)((u8 *)fn->leaf + offset);\n\n\t\t/*\n\t\t *\tPrefix match\n\t\t */\n\t\tif (plen < fn->fn_bit ||\n\t\t    !ipv6_prefix_equal(&key->addr, addr, fn->fn_bit)) {\n\t\t\tif (!allow_create) {\n\t\t\t\tif (replace_required) {\n\t\t\t\t\tpr_warn(\"Can't replace route, no match found\\n\");\n\t\t\t\t\treturn ERR_PTR(-ENOENT);\n\t\t\t\t}\n\t\t\t\tpr_warn(\"NLM_F_CREATE should be set when creating new route\\n\");\n\t\t\t}\n\t\t\tgoto insert_above;\n\t\t}\n\n\t\t/*\n\t\t *\tExact match ?\n\t\t */\n\n\t\tif (plen == fn->fn_bit) {\n\t\t\t/* clean up an intermediate node */\n\t\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\t\trt6_release(fn->leaf);\n\t\t\t\tfn->leaf = NULL;\n\t\t\t}\n\n\t\t\tfn->fn_sernum = sernum;\n\n\t\t\treturn fn;\n\t\t}\n\n\t\t/*\n\t\t *\tWe have more bits to go\n\t\t */\n\n\t\t/* Try to walk down on tree. */\n\t\tfn->fn_sernum = sernum;\n\t\tdir = addr_bit_set(addr, fn->fn_bit);\n\t\tpn = fn;\n\t\tfn = dir ? fn->right: fn->left;\n\t} while (fn);\n\n\tif (!allow_create) {\n\t\t/* We should not create new node because\n\t\t * NLM_F_REPLACE was specified without NLM_F_CREATE\n\t\t * I assume it is safe to require NLM_F_CREATE when\n\t\t * REPLACE flag is used! Later we may want to remove the\n\t\t * check for replace_required, because according\n\t\t * to netlink specification, NLM_F_CREATE\n\t\t * MUST be specified if new route is created.\n\t\t * That would keep IPv6 consistent with IPv4\n\t\t */\n\t\tif (replace_required) {\n\t\t\tpr_warn(\"Can't replace route, no match found\\n\");\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\t}\n\t\tpr_warn(\"NLM_F_CREATE should be set when creating new route\\n\");\n\t}\n\t/*\n\t *\tWe walked to the bottom of tree.\n\t *\tCreate new leaf node without children.\n\t */\n\n\tln = node_alloc();\n\n\tif (!ln)\n\t\treturn ERR_PTR(-ENOMEM);\n\tln->fn_bit = plen;\n\n\tln->parent = pn;\n\tln->fn_sernum = sernum;\n\n\tif (dir)\n\t\tpn->right = ln;\n\telse\n\t\tpn->left  = ln;\n\n\treturn ln;\n\n\ninsert_above:\n\t/*\n\t * split since we don't have a common prefix anymore or\n\t * we have a less significant route.\n\t * we've to insert an intermediate node on the list\n\t * this new node will point to the one we need to create\n\t * and the current\n\t */\n\n\tpn = fn->parent;\n\n\t/* find 1st bit in difference between the 2 addrs.\n\n\t   See comment in __ipv6_addr_diff: bit may be an invalid value,\n\t   but if it is >= plen, the value is ignored in any case.\n\t */\n\n\tbit = __ipv6_addr_diff(addr, &key->addr, addrlen);\n\n\t/*\n\t *\t\t(intermediate)[in]\n\t *\t          /\t   \\\n\t *\t(new leaf node)[ln] (old node)[fn]\n\t */\n\tif (plen > bit) {\n\t\tin = node_alloc();\n\t\tln = node_alloc();\n\n\t\tif (!in || !ln) {\n\t\t\tif (in)\n\t\t\t\tnode_free(in);\n\t\t\tif (ln)\n\t\t\t\tnode_free(ln);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\n\t\t/*\n\t\t * new intermediate node.\n\t\t * RTN_RTINFO will\n\t\t * be off since that an address that chooses one of\n\t\t * the branches would not match less specific routes\n\t\t * in the other branch\n\t\t */\n\n\t\tin->fn_bit = bit;\n\n\t\tin->parent = pn;\n\t\tin->leaf = fn->leaf;\n\t\tatomic_inc(&in->leaf->rt6i_ref);\n\n\t\tin->fn_sernum = sernum;\n\n\t\t/* update parent pointer */\n\t\tif (dir)\n\t\t\tpn->right = in;\n\t\telse\n\t\t\tpn->left  = in;\n\n\t\tln->fn_bit = plen;\n\n\t\tln->parent = in;\n\t\tfn->parent = in;\n\n\t\tln->fn_sernum = sernum;\n\n\t\tif (addr_bit_set(addr, bit)) {\n\t\t\tin->right = ln;\n\t\t\tin->left  = fn;\n\t\t} else {\n\t\t\tin->left  = ln;\n\t\t\tin->right = fn;\n\t\t}\n\t} else { /* plen <= bit */\n\n\t\t/*\n\t\t *\t\t(new leaf node)[ln]\n\t\t *\t          /\t   \\\n\t\t *\t     (old node)[fn] NULL\n\t\t */\n\n\t\tln = node_alloc();\n\n\t\tif (!ln)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tln->fn_bit = plen;\n\n\t\tln->parent = pn;\n\n\t\tln->fn_sernum = sernum;\n\n\t\tif (dir)\n\t\t\tpn->right = ln;\n\t\telse\n\t\t\tpn->left  = ln;\n\n\t\tif (addr_bit_set(&key->addr, plen))\n\t\t\tln->right = fn;\n\t\telse\n\t\t\tln->left  = fn;\n\n\t\tfn->parent = ln;\n\t}\n\treturn ln;\n}\n\n/*\n *\tInsert routing information in a node.\n */\n\nstatic int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt,\n\t\t\t    struct nl_info *info)\n{\n\tstruct rt6_info *iter = NULL;\n\tstruct rt6_info **ins;\n\tint replace = (info->nlh &&\n\t\t       (info->nlh->nlmsg_flags & NLM_F_REPLACE));\n\tint add = (!info->nlh ||\n\t\t   (info->nlh->nlmsg_flags & NLM_F_CREATE));\n\tint found = 0;\n\n\tins = &fn->leaf;\n\n\tfor (iter = fn->leaf; iter; iter = iter->dst.rt6_next) {\n\t\t/*\n\t\t *\tSearch for duplicates\n\t\t */\n\n\t\tif (iter->rt6i_metric == rt->rt6i_metric) {\n\t\t\t/*\n\t\t\t *\tSame priority level\n\t\t\t */\n\t\t\tif (info->nlh &&\n\t\t\t    (info->nlh->nlmsg_flags & NLM_F_EXCL))\n\t\t\t\treturn -EEXIST;\n\t\t\tif (replace) {\n\t\t\t\tfound++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (iter->dst.dev == rt->dst.dev &&\n\t\t\t    iter->rt6i_idev == rt->rt6i_idev &&\n\t\t\t    ipv6_addr_equal(&iter->rt6i_gateway,\n\t\t\t\t\t    &rt->rt6i_gateway)) {\n\t\t\t\tif (rt->rt6i_nsiblings)\n\t\t\t\t\trt->rt6i_nsiblings = 0;\n\t\t\t\tif (!(iter->rt6i_flags & RTF_EXPIRES))\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\tif (!(rt->rt6i_flags & RTF_EXPIRES))\n\t\t\t\t\trt6_clean_expires(iter);\n\t\t\t\telse\n\t\t\t\t\trt6_set_expires(iter, rt->dst.expires);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\t/* If we have the same destination and the same metric,\n\t\t\t * but not the same gateway, then the route we try to\n\t\t\t * add is sibling to this route, increment our counter\n\t\t\t * of siblings, and later we will add our route to the\n\t\t\t * list.\n\t\t\t * Only static routes (which don't have flag\n\t\t\t * RTF_EXPIRES) are used for ECMPv6.\n\t\t\t *\n\t\t\t * To avoid long list, we only had siblings if the\n\t\t\t * route have a gateway.\n\t\t\t */\n\t\t\tif (rt->rt6i_flags & RTF_GATEWAY &&\n\t\t\t    !(rt->rt6i_flags & RTF_EXPIRES) &&\n\t\t\t    !(iter->rt6i_flags & RTF_EXPIRES))\n\t\t\t\trt->rt6i_nsiblings++;\n\t\t}\n\n\t\tif (iter->rt6i_metric > rt->rt6i_metric)\n\t\t\tbreak;\n\n\t\tins = &iter->dst.rt6_next;\n\t}\n\n\t/* Reset round-robin state, if necessary */\n\tif (ins == &fn->leaf)\n\t\tfn->rr_ptr = NULL;\n\n\t/* Link this route to others same route. */\n\tif (rt->rt6i_nsiblings) {\n\t\tunsigned int rt6i_nsiblings;\n\t\tstruct rt6_info *sibling, *temp_sibling;\n\n\t\t/* Find the first route that have the same metric */\n\t\tsibling = fn->leaf;\n\t\twhile (sibling) {\n\t\t\tif (sibling->rt6i_metric == rt->rt6i_metric) {\n\t\t\t\tlist_add_tail(&rt->rt6i_siblings,\n\t\t\t\t\t      &sibling->rt6i_siblings);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsibling = sibling->dst.rt6_next;\n\t\t}\n\t\t/* For each sibling in the list, increment the counter of\n\t\t * siblings. BUG() if counters does not match, list of siblings\n\t\t * is broken!\n\t\t */\n\t\trt6i_nsiblings = 0;\n\t\tlist_for_each_entry_safe(sibling, temp_sibling,\n\t\t\t\t\t &rt->rt6i_siblings, rt6i_siblings) {\n\t\t\tsibling->rt6i_nsiblings++;\n\t\t\tBUG_ON(sibling->rt6i_nsiblings != rt->rt6i_nsiblings);\n\t\t\trt6i_nsiblings++;\n\t\t}\n\t\tBUG_ON(rt6i_nsiblings != rt->rt6i_nsiblings);\n\t}\n\n\t/*\n\t *\tinsert node\n\t */\n\tif (!replace) {\n\t\tif (!add)\n\t\t\tpr_warn(\"NLM_F_CREATE should be set when creating new route\\n\");\n\nadd:\n\t\trt->dst.rt6_next = iter;\n\t\t*ins = rt;\n\t\trt->rt6i_node = fn;\n\t\tatomic_inc(&rt->rt6i_ref);\n\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info);\n\t\tinfo->nl_net->ipv6.rt6_stats->fib_rt_entries++;\n\n\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\n\t\t\tfn->fn_flags |= RTN_RTINFO;\n\t\t}\n\n\t} else {\n\t\tif (!found) {\n\t\t\tif (add)\n\t\t\t\tgoto add;\n\t\t\tpr_warn(\"NLM_F_REPLACE set, but no existing node found!\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t\t*ins = rt;\n\t\trt->rt6i_node = fn;\n\t\trt->dst.rt6_next = iter->dst.rt6_next;\n\t\tatomic_inc(&rt->rt6i_ref);\n\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info);\n\t\trt6_release(iter);\n\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\n\t\t\tfn->fn_flags |= RTN_RTINFO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic __inline__ void fib6_start_gc(struct net *net, struct rt6_info *rt)\n{\n\tif (!timer_pending(&net->ipv6.ip6_fib_timer) &&\n\t    (rt->rt6i_flags & (RTF_EXPIRES | RTF_CACHE)))\n\t\tmod_timer(&net->ipv6.ip6_fib_timer,\n\t\t\t  jiffies + net->ipv6.sysctl.ip6_rt_gc_interval);\n}\n\nvoid fib6_force_start_gc(struct net *net)\n{\n\tif (!timer_pending(&net->ipv6.ip6_fib_timer))\n\t\tmod_timer(&net->ipv6.ip6_fib_timer,\n\t\t\t  jiffies + net->ipv6.sysctl.ip6_rt_gc_interval);\n}\n\n/*\n *\tAdd routing information to the routing tree.\n *\t<destination addr>/<source addr>\n *\twith source addr info in sub-trees\n */\n\nint fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)\n{\n\tstruct fib6_node *fn, *pn = NULL;\n\tint err = -ENOMEM;\n\tint allow_create = 1;\n\tint replace_required = 0;\n\n\tif (info->nlh) {\n\t\tif (!(info->nlh->nlmsg_flags & NLM_F_CREATE))\n\t\t\tallow_create = 0;\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treplace_required = 1;\n\t}\n\tif (!allow_create && !replace_required)\n\t\tpr_warn(\"RTM_NEWROUTE with no NLM_F_CREATE or NLM_F_REPLACE\\n\");\n\n\tfn = fib6_add_1(root, &rt->rt6i_dst.addr, sizeof(struct in6_addr),\n\t\t\trt->rt6i_dst.plen, offsetof(struct rt6_info, rt6i_dst),\n\t\t\tallow_create, replace_required);\n\n\tif (IS_ERR(fn)) {\n\t\terr = PTR_ERR(fn);\n\t\tgoto out;\n\t}\n\n\tpn = fn;\n\n#ifdef CONFIG_IPV6_SUBTREES\n\tif (rt->rt6i_src.plen) {\n\t\tstruct fib6_node *sn;\n\n\t\tif (!fn->subtree) {\n\t\t\tstruct fib6_node *sfn;\n\n\t\t\t/*\n\t\t\t * Create subtree.\n\t\t\t *\n\t\t\t *\t\tfn[main tree]\n\t\t\t *\t\t|\n\t\t\t *\t\tsfn[subtree root]\n\t\t\t *\t\t   \\\n\t\t\t *\t\t    sn[new leaf node]\n\t\t\t */\n\n\t\t\t/* Create subtree root node */\n\t\t\tsfn = node_alloc();\n\t\t\tif (!sfn)\n\t\t\t\tgoto st_failure;\n\n\t\t\tsfn->leaf = info->nl_net->ipv6.ip6_null_entry;\n\t\t\tatomic_inc(&info->nl_net->ipv6.ip6_null_entry->rt6i_ref);\n\t\t\tsfn->fn_flags = RTN_ROOT;\n\t\t\tsfn->fn_sernum = fib6_new_sernum();\n\n\t\t\t/* Now add the first leaf node to new subtree */\n\n\t\t\tsn = fib6_add_1(sfn, &rt->rt6i_src.addr,\n\t\t\t\t\tsizeof(struct in6_addr), rt->rt6i_src.plen,\n\t\t\t\t\toffsetof(struct rt6_info, rt6i_src),\n\t\t\t\t\tallow_create, replace_required);\n\n\t\t\tif (IS_ERR(sn)) {\n\t\t\t\t/* If it is failed, discard just allocated\n\t\t\t\t   root, and then (in st_failure) stale node\n\t\t\t\t   in main tree.\n\t\t\t\t */\n\t\t\t\tnode_free(sfn);\n\t\t\t\terr = PTR_ERR(sn);\n\t\t\t\tgoto st_failure;\n\t\t\t}\n\n\t\t\t/* Now link new subtree to main tree */\n\t\t\tsfn->parent = fn;\n\t\t\tfn->subtree = sfn;\n\t\t} else {\n\t\t\tsn = fib6_add_1(fn->subtree, &rt->rt6i_src.addr,\n\t\t\t\t\tsizeof(struct in6_addr), rt->rt6i_src.plen,\n\t\t\t\t\toffsetof(struct rt6_info, rt6i_src),\n\t\t\t\t\tallow_create, replace_required);\n\n\t\t\tif (IS_ERR(sn)) {\n\t\t\t\terr = PTR_ERR(sn);\n\t\t\t\tgoto st_failure;\n\t\t\t}\n\t\t}\n\n\t\tif (!fn->leaf) {\n\t\t\tfn->leaf = rt;\n\t\t\tatomic_inc(&rt->rt6i_ref);\n\t\t}\n\t\tfn = sn;\n\t}\n#endif\n\n\terr = fib6_add_rt2node(fn, rt, info);\n\tif (!err) {\n\t\tfib6_start_gc(info->nl_net, rt);\n\t\tif (!(rt->rt6i_flags & RTF_CACHE))\n\t\t\tfib6_prune_clones(info->nl_net, pn, rt);\n\t}\n\nout:\n\tif (err) {\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t/*\n\t\t * If fib6_add_1 has cleared the old leaf pointer in the\n\t\t * super-tree leaf node we have to find a new one for it.\n\t\t */\n\t\tif (pn != fn && pn->leaf == rt) {\n\t\t\tpn->leaf = NULL;\n\t\t\tatomic_dec(&rt->rt6i_ref);\n\t\t}\n\t\tif (pn != fn && !pn->leaf && !(pn->fn_flags & RTN_RTINFO)) {\n\t\t\tpn->leaf = fib6_find_prefix(info->nl_net, pn);\n#if RT6_DEBUG >= 2\n\t\t\tif (!pn->leaf) {\n\t\t\t\tWARN_ON(pn->leaf == NULL);\n\t\t\t\tpn->leaf = info->nl_net->ipv6.ip6_null_entry;\n\t\t\t}\n#endif\n\t\t\tatomic_inc(&pn->leaf->rt6i_ref);\n\t\t}\n#endif\n\t\tdst_free(&rt->dst);\n\t}\n\treturn err;\n\n#ifdef CONFIG_IPV6_SUBTREES\n\t/* Subtree creation failed, probably main tree node\n\t   is orphan. If it is, shoot it.\n\t */\nst_failure:\n\tif (fn && !(fn->fn_flags & (RTN_RTINFO|RTN_ROOT)))\n\t\tfib6_repair_tree(info->nl_net, fn);\n\tdst_free(&rt->dst);\n\treturn err;\n#endif\n}\n\n/*\n *\tRouting tree lookup\n *\n */\n\nstruct lookup_args {\n\tint\t\t\toffset;\t\t/* key offset on rt6_info\t*/\n\tconst struct in6_addr\t*addr;\t\t/* search key\t\t\t*/\n};\n\nstatic struct fib6_node * fib6_lookup_1(struct fib6_node *root,\n\t\t\t\t\tstruct lookup_args *args)\n{\n\tstruct fib6_node *fn;\n\t__be32 dir;\n\n\tif (unlikely(args->offset == 0))\n\t\treturn NULL;\n\n\t/*\n\t *\tDescend on a tree\n\t */\n\n\tfn = root;\n\n\tfor (;;) {\n\t\tstruct fib6_node *next;\n\n\t\tdir = addr_bit_set(args->addr, fn->fn_bit);\n\n\t\tnext = dir ? fn->right : fn->left;\n\n\t\tif (next) {\n\t\t\tfn = next;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\twhile (fn) {\n\t\tif (FIB6_SUBTREE(fn) || fn->fn_flags & RTN_RTINFO) {\n\t\t\tstruct rt6key *key;\n\n\t\t\tkey = (struct rt6key *) ((u8 *) fn->leaf +\n\t\t\t\t\t\t args->offset);\n\n\t\t\tif (ipv6_prefix_equal(&key->addr, args->addr, key->plen)) {\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t\t\tif (fn->subtree)\n\t\t\t\t\tfn = fib6_lookup_1(fn->subtree, args + 1);\n#endif\n\t\t\t\tif (!fn || fn->fn_flags & RTN_RTINFO)\n\t\t\t\t\treturn fn;\n\t\t\t}\n\t\t}\n\n\t\tif (fn->fn_flags & RTN_ROOT)\n\t\t\tbreak;\n\n\t\tfn = fn->parent;\n\t}\n\n\treturn NULL;\n}\n\nstruct fib6_node * fib6_lookup(struct fib6_node *root, const struct in6_addr *daddr,\n\t\t\t       const struct in6_addr *saddr)\n{\n\tstruct fib6_node *fn;\n\tstruct lookup_args args[] = {\n\t\t{\n\t\t\t.offset = offsetof(struct rt6_info, rt6i_dst),\n\t\t\t.addr = daddr,\n\t\t},\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t{\n\t\t\t.offset = offsetof(struct rt6_info, rt6i_src),\n\t\t\t.addr = saddr,\n\t\t},\n#endif\n\t\t{\n\t\t\t.offset = 0,\t/* sentinel */\n\t\t}\n\t};\n\n\tfn = fib6_lookup_1(root, daddr ? args : args + 1);\n\tif (!fn || fn->fn_flags & RTN_TL_ROOT)\n\t\tfn = root;\n\n\treturn fn;\n}\n\n/*\n *\tGet node with specified destination prefix (and source prefix,\n *\tif subtrees are used)\n */\n\n\nstatic struct fib6_node * fib6_locate_1(struct fib6_node *root,\n\t\t\t\t\tconst struct in6_addr *addr,\n\t\t\t\t\tint plen, int offset)\n{\n\tstruct fib6_node *fn;\n\n\tfor (fn = root; fn ; ) {\n\t\tstruct rt6key *key = (struct rt6key *)((u8 *)fn->leaf + offset);\n\n\t\t/*\n\t\t *\tPrefix match\n\t\t */\n\t\tif (plen < fn->fn_bit ||\n\t\t    !ipv6_prefix_equal(&key->addr, addr, fn->fn_bit))\n\t\t\treturn NULL;\n\n\t\tif (plen == fn->fn_bit)\n\t\t\treturn fn;\n\n\t\t/*\n\t\t *\tWe have more bits to go\n\t\t */\n\t\tif (addr_bit_set(addr, fn->fn_bit))\n\t\t\tfn = fn->right;\n\t\telse\n\t\t\tfn = fn->left;\n\t}\n\treturn NULL;\n}\n\nstruct fib6_node * fib6_locate(struct fib6_node *root,\n\t\t\t       const struct in6_addr *daddr, int dst_len,\n\t\t\t       const struct in6_addr *saddr, int src_len)\n{\n\tstruct fib6_node *fn;\n\n\tfn = fib6_locate_1(root, daddr, dst_len,\n\t\t\t   offsetof(struct rt6_info, rt6i_dst));\n\n#ifdef CONFIG_IPV6_SUBTREES\n\tif (src_len) {\n\t\tWARN_ON(saddr == NULL);\n\t\tif (fn && fn->subtree)\n\t\t\tfn = fib6_locate_1(fn->subtree, saddr, src_len,\n\t\t\t\t\t   offsetof(struct rt6_info, rt6i_src));\n\t}\n#endif\n\n\tif (fn && fn->fn_flags & RTN_RTINFO)\n\t\treturn fn;\n\n\treturn NULL;\n}\n\n\n/*\n *\tDeletion\n *\n */\n\nstatic struct rt6_info *fib6_find_prefix(struct net *net, struct fib6_node *fn)\n{\n\tif (fn->fn_flags & RTN_ROOT)\n\t\treturn net->ipv6.ip6_null_entry;\n\n\twhile (fn) {\n\t\tif (fn->left)\n\t\t\treturn fn->left->leaf;\n\t\tif (fn->right)\n\t\t\treturn fn->right->leaf;\n\n\t\tfn = FIB6_SUBTREE(fn);\n\t}\n\treturn NULL;\n}\n\n/*\n *\tCalled to trim the tree of intermediate nodes when possible. \"fn\"\n *\tis the node we want to try and remove.\n */\n\nstatic struct fib6_node *fib6_repair_tree(struct net *net,\n\t\t\t\t\t   struct fib6_node *fn)\n{\n\tint children;\n\tint nstate;\n\tstruct fib6_node *child, *pn;\n\tstruct fib6_walker_t *w;\n\tint iter = 0;\n\n\tfor (;;) {\n\t\tRT6_TRACE(\"fixing tree: plen=%d iter=%d\\n\", fn->fn_bit, iter);\n\t\titer++;\n\n\t\tWARN_ON(fn->fn_flags & RTN_RTINFO);\n\t\tWARN_ON(fn->fn_flags & RTN_TL_ROOT);\n\t\tWARN_ON(fn->leaf != NULL);\n\n\t\tchildren = 0;\n\t\tchild = NULL;\n\t\tif (fn->right) child = fn->right, children |= 1;\n\t\tif (fn->left) child = fn->left, children |= 2;\n\n\t\tif (children == 3 || FIB6_SUBTREE(fn)\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t    /* Subtree root (i.e. fn) may have one child */\n\t\t    || (children && fn->fn_flags & RTN_ROOT)\n#endif\n\t\t    ) {\n\t\t\tfn->leaf = fib6_find_prefix(net, fn);\n#if RT6_DEBUG >= 2\n\t\t\tif (!fn->leaf) {\n\t\t\t\tWARN_ON(!fn->leaf);\n\t\t\t\tfn->leaf = net->ipv6.ip6_null_entry;\n\t\t\t}\n#endif\n\t\t\tatomic_inc(&fn->leaf->rt6i_ref);\n\t\t\treturn fn->parent;\n\t\t}\n\n\t\tpn = fn->parent;\n#ifdef CONFIG_IPV6_SUBTREES\n\t\tif (FIB6_SUBTREE(pn) == fn) {\n\t\t\tWARN_ON(!(fn->fn_flags & RTN_ROOT));\n\t\t\tFIB6_SUBTREE(pn) = NULL;\n\t\t\tnstate = FWS_L;\n\t\t} else {\n\t\t\tWARN_ON(fn->fn_flags & RTN_ROOT);\n#endif\n\t\t\tif (pn->right == fn) pn->right = child;\n\t\t\telse if (pn->left == fn) pn->left = child;\n#if RT6_DEBUG >= 2\n\t\t\telse\n\t\t\t\tWARN_ON(1);\n#endif\n\t\t\tif (child)\n\t\t\t\tchild->parent = pn;\n\t\t\tnstate = FWS_R;\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t}\n#endif\n\n\t\tread_lock(&fib6_walker_lock);\n\t\tFOR_WALKERS(w) {\n\t\t\tif (!child) {\n\t\t\t\tif (w->root == fn) {\n\t\t\t\t\tw->root = w->node = NULL;\n\t\t\t\t\tRT6_TRACE(\"W %p adjusted by delroot 1\\n\", w);\n\t\t\t\t} else if (w->node == fn) {\n\t\t\t\t\tRT6_TRACE(\"W %p adjusted by delnode 1, s=%d/%d\\n\", w, w->state, nstate);\n\t\t\t\t\tw->node = pn;\n\t\t\t\t\tw->state = nstate;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (w->root == fn) {\n\t\t\t\t\tw->root = child;\n\t\t\t\t\tRT6_TRACE(\"W %p adjusted by delroot 2\\n\", w);\n\t\t\t\t}\n\t\t\t\tif (w->node == fn) {\n\t\t\t\t\tw->node = child;\n\t\t\t\t\tif (children&2) {\n\t\t\t\t\t\tRT6_TRACE(\"W %p adjusted by delnode 2, s=%d\\n\", w, w->state);\n\t\t\t\t\t\tw->state = w->state>=FWS_R ? FWS_U : FWS_INIT;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRT6_TRACE(\"W %p adjusted by delnode 2, s=%d\\n\", w, w->state);\n\t\t\t\t\t\tw->state = w->state>=FWS_C ? FWS_U : FWS_INIT;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tread_unlock(&fib6_walker_lock);\n\n\t\tnode_free(fn);\n\t\tif (pn->fn_flags & RTN_RTINFO || FIB6_SUBTREE(pn))\n\t\t\treturn pn;\n\n\t\trt6_release(pn->leaf);\n\t\tpn->leaf = NULL;\n\t\tfn = pn;\n\t}\n}\n\nstatic void fib6_del_route(struct fib6_node *fn, struct rt6_info **rtp,\n\t\t\t   struct nl_info *info)\n{\n\tstruct fib6_walker_t *w;\n\tstruct rt6_info *rt = *rtp;\n\tstruct net *net = info->nl_net;\n\n\tRT6_TRACE(\"fib6_del_route\\n\");\n\n\t/* Unlink it */\n\t*rtp = rt->dst.rt6_next;\n\trt->rt6i_node = NULL;\n\tnet->ipv6.rt6_stats->fib_rt_entries--;\n\tnet->ipv6.rt6_stats->fib_discarded_routes++;\n\n\t/* Reset round-robin state, if necessary */\n\tif (fn->rr_ptr == rt)\n\t\tfn->rr_ptr = NULL;\n\n\t/* Remove this entry from other siblings */\n\tif (rt->rt6i_nsiblings) {\n\t\tstruct rt6_info *sibling, *next_sibling;\n\n\t\tlist_for_each_entry_safe(sibling, next_sibling,\n\t\t\t\t\t &rt->rt6i_siblings, rt6i_siblings)\n\t\t\tsibling->rt6i_nsiblings--;\n\t\trt->rt6i_nsiblings = 0;\n\t\tlist_del_init(&rt->rt6i_siblings);\n\t}\n\n\t/* Adjust walkers */\n\tread_lock(&fib6_walker_lock);\n\tFOR_WALKERS(w) {\n\t\tif (w->state == FWS_C && w->leaf == rt) {\n\t\t\tRT6_TRACE(\"walker %p adjusted by delroute\\n\", w);\n\t\t\tw->leaf = rt->dst.rt6_next;\n\t\t\tif (!w->leaf)\n\t\t\t\tw->state = FWS_U;\n\t\t}\n\t}\n\tread_unlock(&fib6_walker_lock);\n\n\trt->dst.rt6_next = NULL;\n\n\t/* If it was last route, expunge its radix tree node */\n\tif (!fn->leaf) {\n\t\tfn->fn_flags &= ~RTN_RTINFO;\n\t\tnet->ipv6.rt6_stats->fib_route_nodes--;\n\t\tfn = fib6_repair_tree(net, fn);\n\t}\n\n\tif (atomic_read(&rt->rt6i_ref) != 1) {\n\t\t/* This route is used as dummy address holder in some split\n\t\t * nodes. It is not leaked, but it still holds other resources,\n\t\t * which must be released in time. So, scan ascendant nodes\n\t\t * and replace dummy references to this route with references\n\t\t * to still alive ones.\n\t\t */\n\t\twhile (fn) {\n\t\t\tif (!(fn->fn_flags & RTN_RTINFO) && fn->leaf == rt) {\n\t\t\t\tfn->leaf = fib6_find_prefix(net, fn);\n\t\t\t\tatomic_inc(&fn->leaf->rt6i_ref);\n\t\t\t\trt6_release(rt);\n\t\t\t}\n\t\t\tfn = fn->parent;\n\t\t}\n\t\t/* No more references are possible at this point. */\n\t\tBUG_ON(atomic_read(&rt->rt6i_ref) != 1);\n\t}\n\n\tinet6_rt_notify(RTM_DELROUTE, rt, info);\n\trt6_release(rt);\n}\n\nint fib6_del(struct rt6_info *rt, struct nl_info *info)\n{\n\tstruct net *net = info->nl_net;\n\tstruct fib6_node *fn = rt->rt6i_node;\n\tstruct rt6_info **rtp;\n\n#if RT6_DEBUG >= 2\n\tif (rt->dst.obsolete>0) {\n\t\tWARN_ON(fn != NULL);\n\t\treturn -ENOENT;\n\t}\n#endif\n\tif (!fn || rt == net->ipv6.ip6_null_entry)\n\t\treturn -ENOENT;\n\n\tWARN_ON(!(fn->fn_flags & RTN_RTINFO));\n\n\tif (!(rt->rt6i_flags & RTF_CACHE)) {\n\t\tstruct fib6_node *pn = fn;\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t/* clones of this route might be in another subtree */\n\t\tif (rt->rt6i_src.plen) {\n\t\t\twhile (!(pn->fn_flags & RTN_ROOT))\n\t\t\t\tpn = pn->parent;\n\t\t\tpn = pn->parent;\n\t\t}\n#endif\n\t\tfib6_prune_clones(info->nl_net, pn, rt);\n\t}\n\n\t/*\n\t *\tWalk the leaf entries looking for ourself\n\t */\n\n\tfor (rtp = &fn->leaf; *rtp; rtp = &(*rtp)->dst.rt6_next) {\n\t\tif (*rtp == rt) {\n\t\t\tfib6_del_route(fn, rtp, info);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}\n\n/*\n *\tTree traversal function.\n *\n *\tCertainly, it is not interrupt safe.\n *\tHowever, it is internally reenterable wrt itself and fib6_add/fib6_del.\n *\tIt means, that we can modify tree during walking\n *\tand use this function for garbage collection, clone pruning,\n *\tcleaning tree when a device goes down etc. etc.\n *\n *\tIt guarantees that every node will be traversed,\n *\tand that it will be traversed only once.\n *\n *\tCallback function w->func may return:\n *\t0 -> continue walking.\n *\tpositive value -> walking is suspended (used by tree dumps,\n *\tand probably by gc, if it will be split to several slices)\n *\tnegative value -> terminate walking.\n *\n *\tThe function itself returns:\n *\t0   -> walk is complete.\n *\t>0  -> walk is incomplete (i.e. suspended)\n *\t<0  -> walk is terminated by an error.\n */\n\nstatic int fib6_walk_continue(struct fib6_walker_t *w)\n{\n\tstruct fib6_node *fn, *pn;\n\n\tfor (;;) {\n\t\tfn = w->node;\n\t\tif (!fn)\n\t\t\treturn 0;\n\n\t\tif (w->prune && fn != w->root &&\n\t\t    fn->fn_flags & RTN_RTINFO && w->state < FWS_C) {\n\t\t\tw->state = FWS_C;\n\t\t\tw->leaf = fn->leaf;\n\t\t}\n\t\tswitch (w->state) {\n#ifdef CONFIG_IPV6_SUBTREES\n\t\tcase FWS_S:\n\t\t\tif (FIB6_SUBTREE(fn)) {\n\t\t\t\tw->node = FIB6_SUBTREE(fn);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tw->state = FWS_L;\n#endif\n\t\tcase FWS_L:\n\t\t\tif (fn->left) {\n\t\t\t\tw->node = fn->left;\n\t\t\t\tw->state = FWS_INIT;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tw->state = FWS_R;\n\t\tcase FWS_R:\n\t\t\tif (fn->right) {\n\t\t\t\tw->node = fn->right;\n\t\t\t\tw->state = FWS_INIT;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tw->state = FWS_C;\n\t\t\tw->leaf = fn->leaf;\n\t\tcase FWS_C:\n\t\t\tif (w->leaf && fn->fn_flags & RTN_RTINFO) {\n\t\t\t\tint err;\n\n\t\t\t\tif (w->skip) {\n\t\t\t\t\tw->skip--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\terr = w->func(w);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tw->count++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tw->state = FWS_U;\n\t\tcase FWS_U:\n\t\t\tif (fn == w->root)\n\t\t\t\treturn 0;\n\t\t\tpn = fn->parent;\n\t\t\tw->node = pn;\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t\tif (FIB6_SUBTREE(pn) == fn) {\n\t\t\t\tWARN_ON(!(fn->fn_flags & RTN_ROOT));\n\t\t\t\tw->state = FWS_L;\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tif (pn->left == fn) {\n\t\t\t\tw->state = FWS_R;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (pn->right == fn) {\n\t\t\t\tw->state = FWS_C;\n\t\t\t\tw->leaf = w->node->leaf;\n\t\t\t\tcontinue;\n\t\t\t}\n#if RT6_DEBUG >= 2\n\t\t\tWARN_ON(1);\n#endif\n\t\t}\n\t}\n}\n\nstatic int fib6_walk(struct fib6_walker_t *w)\n{\n\tint res;\n\n\tw->state = FWS_INIT;\n\tw->node = w->root;\n\n\tfib6_walker_link(w);\n\tres = fib6_walk_continue(w);\n\tif (res <= 0)\n\t\tfib6_walker_unlink(w);\n\treturn res;\n}\n\nstatic int fib6_clean_node(struct fib6_walker_t *w)\n{\n\tint res;\n\tstruct rt6_info *rt;\n\tstruct fib6_cleaner_t *c = container_of(w, struct fib6_cleaner_t, w);\n\tstruct nl_info info = {\n\t\t.nl_net = c->net,\n\t};\n\n\tfor (rt = w->leaf; rt; rt = rt->dst.rt6_next) {\n\t\tres = c->func(rt, c->arg);\n\t\tif (res < 0) {\n\t\t\tw->leaf = rt;\n\t\t\tres = fib6_del(rt, &info);\n\t\t\tif (res) {\n#if RT6_DEBUG >= 2\n\t\t\t\tpr_debug(\"%s: del failed: rt=%p@%p err=%d\\n\",\n\t\t\t\t\t __func__, rt, rt->rt6i_node, res);\n#endif\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tWARN_ON(res != 0);\n\t}\n\tw->leaf = rt;\n\treturn 0;\n}\n\n/*\n *\tConvenient frontend to tree walker.\n *\n *\tfunc is called on each route.\n *\t\tIt may return -1 -> delete this route.\n *\t\t              0  -> continue walking\n *\n *\tprune==1 -> only immediate children of node (certainly,\n *\tignoring pure split nodes) will be scanned.\n */\n\nstatic void fib6_clean_tree(struct net *net, struct fib6_node *root,\n\t\t\t    int (*func)(struct rt6_info *, void *arg),\n\t\t\t    int prune, void *arg)\n{\n\tstruct fib6_cleaner_t c;\n\n\tc.w.root = root;\n\tc.w.func = fib6_clean_node;\n\tc.w.prune = prune;\n\tc.w.count = 0;\n\tc.w.skip = 0;\n\tc.func = func;\n\tc.arg = arg;\n\tc.net = net;\n\n\tfib6_walk(&c.w);\n}\n\nvoid fib6_clean_all_ro(struct net *net, int (*func)(struct rt6_info *, void *arg),\n\t\t    int prune, void *arg)\n{\n\tstruct fib6_table *table;\n\tstruct hlist_head *head;\n\tunsigned int h;\n\n\trcu_read_lock();\n\tfor (h = 0; h < FIB6_TABLE_HASHSZ; h++) {\n\t\thead = &net->ipv6.fib_table_hash[h];\n\t\thlist_for_each_entry_rcu(table, head, tb6_hlist) {\n\t\t\tread_lock_bh(&table->tb6_lock);\n\t\t\tfib6_clean_tree(net, &table->tb6_root,\n\t\t\t\t\tfunc, prune, arg);\n\t\t\tread_unlock_bh(&table->tb6_lock);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\nvoid fib6_clean_all(struct net *net, int (*func)(struct rt6_info *, void *arg),\n\t\t    int prune, void *arg)\n{\n\tstruct fib6_table *table;\n\tstruct hlist_head *head;\n\tunsigned int h;\n\n\trcu_read_lock();\n\tfor (h = 0; h < FIB6_TABLE_HASHSZ; h++) {\n\t\thead = &net->ipv6.fib_table_hash[h];\n\t\thlist_for_each_entry_rcu(table, head, tb6_hlist) {\n\t\t\twrite_lock_bh(&table->tb6_lock);\n\t\t\tfib6_clean_tree(net, &table->tb6_root,\n\t\t\t\t\tfunc, prune, arg);\n\t\t\twrite_unlock_bh(&table->tb6_lock);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\nstatic int fib6_prune_clone(struct rt6_info *rt, void *arg)\n{\n\tif (rt->rt6i_flags & RTF_CACHE) {\n\t\tRT6_TRACE(\"pruning clone %p\\n\", rt);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void fib6_prune_clones(struct net *net, struct fib6_node *fn,\n\t\t\t      struct rt6_info *rt)\n{\n\tfib6_clean_tree(net, fn, fib6_prune_clone, 1, rt);\n}\n\n/*\n *\tGarbage collection\n */\n\nstatic struct fib6_gc_args\n{\n\tint\t\t\ttimeout;\n\tint\t\t\tmore;\n} gc_args;\n\nstatic int fib6_age(struct rt6_info *rt, void *arg)\n{\n\tunsigned long now = jiffies;\n\n\t/*\n\t *\tcheck addrconf expiration here.\n\t *\tRoutes are expired even if they are in use.\n\t *\n\t *\tAlso age clones. Note, that clones are aged out\n\t *\tonly if they are not in use now.\n\t */\n\n\tif (rt->rt6i_flags & RTF_EXPIRES && rt->dst.expires) {\n\t\tif (time_after(now, rt->dst.expires)) {\n\t\t\tRT6_TRACE(\"expiring %p\\n\", rt);\n\t\t\treturn -1;\n\t\t}\n\t\tgc_args.more++;\n\t} else if (rt->rt6i_flags & RTF_CACHE) {\n\t\tif (atomic_read(&rt->dst.__refcnt) == 0 &&\n\t\t    time_after_eq(now, rt->dst.lastuse + gc_args.timeout)) {\n\t\t\tRT6_TRACE(\"aging clone %p\\n\", rt);\n\t\t\treturn -1;\n\t\t} else if (rt->rt6i_flags & RTF_GATEWAY) {\n\t\t\tstruct neighbour *neigh;\n\t\t\t__u8 neigh_flags = 0;\n\n\t\t\tneigh = dst_neigh_lookup(&rt->dst, &rt->rt6i_gateway);\n\t\t\tif (neigh) {\n\t\t\t\tneigh_flags = neigh->flags;\n\t\t\t\tneigh_release(neigh);\n\t\t\t}\n\t\t\tif (!(neigh_flags & NTF_ROUTER)) {\n\t\t\t\tRT6_TRACE(\"purging route %p via non-router but gateway\\n\",\n\t\t\t\t\t  rt);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tgc_args.more++;\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_SPINLOCK(fib6_gc_lock);\n\nvoid fib6_run_gc(unsigned long expires, struct net *net)\n{\n\tif (expires != ~0UL) {\n\t\tspin_lock_bh(&fib6_gc_lock);\n\t\tgc_args.timeout = expires ? (int)expires :\n\t\t\tnet->ipv6.sysctl.ip6_rt_gc_interval;\n\t} else {\n\t\tif (!spin_trylock_bh(&fib6_gc_lock)) {\n\t\t\tmod_timer(&net->ipv6.ip6_fib_timer, jiffies + HZ);\n\t\t\treturn;\n\t\t}\n\t\tgc_args.timeout = net->ipv6.sysctl.ip6_rt_gc_interval;\n\t}\n\n\tgc_args.more = icmp6_dst_gc();\n\n\tfib6_clean_all(net, fib6_age, 0, NULL);\n\n\tif (gc_args.more)\n\t\tmod_timer(&net->ipv6.ip6_fib_timer,\n\t\t\t  round_jiffies(jiffies\n\t\t\t\t\t+ net->ipv6.sysctl.ip6_rt_gc_interval));\n\telse\n\t\tdel_timer(&net->ipv6.ip6_fib_timer);\n\tspin_unlock_bh(&fib6_gc_lock);\n}\n\nstatic void fib6_gc_timer_cb(unsigned long arg)\n{\n\tfib6_run_gc(0, (struct net *)arg);\n}\n\nstatic int __net_init fib6_net_init(struct net *net)\n{\n\tsize_t size = sizeof(struct hlist_head) * FIB6_TABLE_HASHSZ;\n\n\tsetup_timer(&net->ipv6.ip6_fib_timer, fib6_gc_timer_cb, (unsigned long)net);\n\n\tnet->ipv6.rt6_stats = kzalloc(sizeof(*net->ipv6.rt6_stats), GFP_KERNEL);\n\tif (!net->ipv6.rt6_stats)\n\t\tgoto out_timer;\n\n\t/* Avoid false sharing : Use at least a full cache line */\n\tsize = max_t(size_t, size, L1_CACHE_BYTES);\n\n\tnet->ipv6.fib_table_hash = kzalloc(size, GFP_KERNEL);\n\tif (!net->ipv6.fib_table_hash)\n\t\tgoto out_rt6_stats;\n\n\tnet->ipv6.fib6_main_tbl = kzalloc(sizeof(*net->ipv6.fib6_main_tbl),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!net->ipv6.fib6_main_tbl)\n\t\tgoto out_fib_table_hash;\n\n\tnet->ipv6.fib6_main_tbl->tb6_id = RT6_TABLE_MAIN;\n\tnet->ipv6.fib6_main_tbl->tb6_root.leaf = net->ipv6.ip6_null_entry;\n\tnet->ipv6.fib6_main_tbl->tb6_root.fn_flags =\n\t\tRTN_ROOT | RTN_TL_ROOT | RTN_RTINFO;\n\tinet_peer_base_init(&net->ipv6.fib6_main_tbl->tb6_peers);\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\tnet->ipv6.fib6_local_tbl = kzalloc(sizeof(*net->ipv6.fib6_local_tbl),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!net->ipv6.fib6_local_tbl)\n\t\tgoto out_fib6_main_tbl;\n\tnet->ipv6.fib6_local_tbl->tb6_id = RT6_TABLE_LOCAL;\n\tnet->ipv6.fib6_local_tbl->tb6_root.leaf = net->ipv6.ip6_null_entry;\n\tnet->ipv6.fib6_local_tbl->tb6_root.fn_flags =\n\t\tRTN_ROOT | RTN_TL_ROOT | RTN_RTINFO;\n\tinet_peer_base_init(&net->ipv6.fib6_local_tbl->tb6_peers);\n#endif\n\tfib6_tables_init(net);\n\n\treturn 0;\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\nout_fib6_main_tbl:\n\tkfree(net->ipv6.fib6_main_tbl);\n#endif\nout_fib_table_hash:\n\tkfree(net->ipv6.fib_table_hash);\nout_rt6_stats:\n\tkfree(net->ipv6.rt6_stats);\nout_timer:\n\treturn -ENOMEM;\n }\n\nstatic void fib6_net_exit(struct net *net)\n{\n\trt6_ifdown(net, NULL);\n\tdel_timer_sync(&net->ipv6.ip6_fib_timer);\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\tinetpeer_invalidate_tree(&net->ipv6.fib6_local_tbl->tb6_peers);\n\tkfree(net->ipv6.fib6_local_tbl);\n#endif\n\tinetpeer_invalidate_tree(&net->ipv6.fib6_main_tbl->tb6_peers);\n\tkfree(net->ipv6.fib6_main_tbl);\n\tkfree(net->ipv6.fib_table_hash);\n\tkfree(net->ipv6.rt6_stats);\n}\n\nstatic struct pernet_operations fib6_net_ops = {\n\t.init = fib6_net_init,\n\t.exit = fib6_net_exit,\n};\n\nint __init fib6_init(void)\n{\n\tint ret = -ENOMEM;\n\n\tfib6_node_kmem = kmem_cache_create(\"fib6_nodes\",\n\t\t\t\t\t   sizeof(struct fib6_node),\n\t\t\t\t\t   0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t   NULL);\n\tif (!fib6_node_kmem)\n\t\tgoto out;\n\n\tret = register_pernet_subsys(&fib6_net_ops);\n\tif (ret)\n\t\tgoto out_kmem_cache_create;\n\n\tret = __rtnl_register(PF_INET6, RTM_GETROUTE, NULL, inet6_dump_fib,\n\t\t\t      NULL);\n\tif (ret)\n\t\tgoto out_unregister_subsys;\nout:\n\treturn ret;\n\nout_unregister_subsys:\n\tunregister_pernet_subsys(&fib6_net_ops);\nout_kmem_cache_create:\n\tkmem_cache_destroy(fib6_node_kmem);\n\tgoto out;\n}\n\nvoid fib6_gc_cleanup(void)\n{\n\tunregister_pernet_subsys(&fib6_net_ops);\n\tkmem_cache_destroy(fib6_node_kmem);\n}\n"], "fixing_code": ["/*\n *\tLinux INET6 implementation\n *\tForwarding Information Database\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n/*\n * \tChanges:\n * \tYuji SEKIYA @USAGI:\tSupport default route on router node;\n * \t\t\t\tremove ip6_null_entry from the top of\n * \t\t\t\trouting table.\n * \tVille Nuorvala:\t\tFixed routing subtrees.\n */\n\n#define pr_fmt(fmt) \"IPv6: \" fmt\n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/net.h>\n#include <linux/route.h>\n#include <linux/netdevice.h>\n#include <linux/in6.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\n#include <net/ipv6.h>\n#include <net/ndisc.h>\n#include <net/addrconf.h>\n\n#include <net/ip6_fib.h>\n#include <net/ip6_route.h>\n\n#define RT6_DEBUG 2\n\n#if RT6_DEBUG >= 3\n#define RT6_TRACE(x...) pr_debug(x)\n#else\n#define RT6_TRACE(x...) do { ; } while (0)\n#endif\n\nstatic struct kmem_cache * fib6_node_kmem __read_mostly;\n\nenum fib_walk_state_t\n{\n#ifdef CONFIG_IPV6_SUBTREES\n\tFWS_S,\n#endif\n\tFWS_L,\n\tFWS_R,\n\tFWS_C,\n\tFWS_U\n};\n\nstruct fib6_cleaner_t\n{\n\tstruct fib6_walker_t w;\n\tstruct net *net;\n\tint (*func)(struct rt6_info *, void *arg);\n\tvoid *arg;\n};\n\nstatic DEFINE_RWLOCK(fib6_walker_lock);\n\n#ifdef CONFIG_IPV6_SUBTREES\n#define FWS_INIT FWS_S\n#else\n#define FWS_INIT FWS_L\n#endif\n\nstatic void fib6_prune_clones(struct net *net, struct fib6_node *fn,\n\t\t\t      struct rt6_info *rt);\nstatic struct rt6_info *fib6_find_prefix(struct net *net, struct fib6_node *fn);\nstatic struct fib6_node *fib6_repair_tree(struct net *net, struct fib6_node *fn);\nstatic int fib6_walk(struct fib6_walker_t *w);\nstatic int fib6_walk_continue(struct fib6_walker_t *w);\n\n/*\n *\tA routing update causes an increase of the serial number on the\n *\taffected subtree. This allows for cached routes to be asynchronously\n *\ttested when modifications are made to the destination cache as a\n *\tresult of redirects, path MTU changes, etc.\n */\n\nstatic __u32 rt_sernum;\n\nstatic void fib6_gc_timer_cb(unsigned long arg);\n\nstatic LIST_HEAD(fib6_walkers);\n#define FOR_WALKERS(w) list_for_each_entry(w, &fib6_walkers, lh)\n\nstatic inline void fib6_walker_link(struct fib6_walker_t *w)\n{\n\twrite_lock_bh(&fib6_walker_lock);\n\tlist_add(&w->lh, &fib6_walkers);\n\twrite_unlock_bh(&fib6_walker_lock);\n}\n\nstatic inline void fib6_walker_unlink(struct fib6_walker_t *w)\n{\n\twrite_lock_bh(&fib6_walker_lock);\n\tlist_del(&w->lh);\n\twrite_unlock_bh(&fib6_walker_lock);\n}\nstatic __inline__ u32 fib6_new_sernum(void)\n{\n\tu32 n = ++rt_sernum;\n\tif ((__s32)n <= 0)\n\t\trt_sernum = n = 1;\n\treturn n;\n}\n\n/*\n *\tAuxiliary address test functions for the radix tree.\n *\n *\tThese assume a 32bit processor (although it will work on\n *\t64bit processors)\n */\n\n/*\n *\ttest bit\n */\n#if defined(__LITTLE_ENDIAN)\n# define BITOP_BE32_SWIZZLE\t(0x1F & ~7)\n#else\n# define BITOP_BE32_SWIZZLE\t0\n#endif\n\nstatic __inline__ __be32 addr_bit_set(const void *token, int fn_bit)\n{\n\tconst __be32 *addr = token;\n\t/*\n\t * Here,\n\t * \t1 << ((~fn_bit ^ BITOP_BE32_SWIZZLE) & 0x1f)\n\t * is optimized version of\n\t *\thtonl(1 << ((~fn_bit)&0x1F))\n\t * See include/asm-generic/bitops/le.h.\n\t */\n\treturn (__force __be32)(1 << ((~fn_bit ^ BITOP_BE32_SWIZZLE) & 0x1f)) &\n\t       addr[fn_bit >> 5];\n}\n\nstatic __inline__ struct fib6_node * node_alloc(void)\n{\n\tstruct fib6_node *fn;\n\n\tfn = kmem_cache_zalloc(fib6_node_kmem, GFP_ATOMIC);\n\n\treturn fn;\n}\n\nstatic __inline__ void node_free(struct fib6_node * fn)\n{\n\tkmem_cache_free(fib6_node_kmem, fn);\n}\n\nstatic __inline__ void rt6_release(struct rt6_info *rt)\n{\n\tif (atomic_dec_and_test(&rt->rt6i_ref))\n\t\tdst_free(&rt->dst);\n}\n\nstatic void fib6_link_table(struct net *net, struct fib6_table *tb)\n{\n\tunsigned int h;\n\n\t/*\n\t * Initialize table lock at a single place to give lockdep a key,\n\t * tables aren't visible prior to being linked to the list.\n\t */\n\trwlock_init(&tb->tb6_lock);\n\n\th = tb->tb6_id & (FIB6_TABLE_HASHSZ - 1);\n\n\t/*\n\t * No protection necessary, this is the only list mutatation\n\t * operation, tables never disappear once they exist.\n\t */\n\thlist_add_head_rcu(&tb->tb6_hlist, &net->ipv6.fib_table_hash[h]);\n}\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\nstatic struct fib6_table *fib6_alloc_table(struct net *net, u32 id)\n{\n\tstruct fib6_table *table;\n\n\ttable = kzalloc(sizeof(*table), GFP_ATOMIC);\n\tif (table) {\n\t\ttable->tb6_id = id;\n\t\ttable->tb6_root.leaf = net->ipv6.ip6_null_entry;\n\t\ttable->tb6_root.fn_flags = RTN_ROOT | RTN_TL_ROOT | RTN_RTINFO;\n\t\tinet_peer_base_init(&table->tb6_peers);\n\t}\n\n\treturn table;\n}\n\nstruct fib6_table *fib6_new_table(struct net *net, u32 id)\n{\n\tstruct fib6_table *tb;\n\n\tif (id == 0)\n\t\tid = RT6_TABLE_MAIN;\n\ttb = fib6_get_table(net, id);\n\tif (tb)\n\t\treturn tb;\n\n\ttb = fib6_alloc_table(net, id);\n\tif (tb)\n\t\tfib6_link_table(net, tb);\n\n\treturn tb;\n}\n\nstruct fib6_table *fib6_get_table(struct net *net, u32 id)\n{\n\tstruct fib6_table *tb;\n\tstruct hlist_head *head;\n\tunsigned int h;\n\n\tif (id == 0)\n\t\tid = RT6_TABLE_MAIN;\n\th = id & (FIB6_TABLE_HASHSZ - 1);\n\trcu_read_lock();\n\thead = &net->ipv6.fib_table_hash[h];\n\thlist_for_each_entry_rcu(tb, head, tb6_hlist) {\n\t\tif (tb->tb6_id == id) {\n\t\t\trcu_read_unlock();\n\t\t\treturn tb;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}\n\nstatic void __net_init fib6_tables_init(struct net *net)\n{\n\tfib6_link_table(net, net->ipv6.fib6_main_tbl);\n\tfib6_link_table(net, net->ipv6.fib6_local_tbl);\n}\n#else\n\nstruct fib6_table *fib6_new_table(struct net *net, u32 id)\n{\n\treturn fib6_get_table(net, id);\n}\n\nstruct fib6_table *fib6_get_table(struct net *net, u32 id)\n{\n\t  return net->ipv6.fib6_main_tbl;\n}\n\nstruct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   int flags, pol_lookup_t lookup)\n{\n\treturn (struct dst_entry *) lookup(net, net->ipv6.fib6_main_tbl, fl6, flags);\n}\n\nstatic void __net_init fib6_tables_init(struct net *net)\n{\n\tfib6_link_table(net, net->ipv6.fib6_main_tbl);\n}\n\n#endif\n\nstatic int fib6_dump_node(struct fib6_walker_t *w)\n{\n\tint res;\n\tstruct rt6_info *rt;\n\n\tfor (rt = w->leaf; rt; rt = rt->dst.rt6_next) {\n\t\tres = rt6_dump_route(rt, w->args);\n\t\tif (res < 0) {\n\t\t\t/* Frame is full, suspend walking */\n\t\t\tw->leaf = rt;\n\t\t\treturn 1;\n\t\t}\n\t\tWARN_ON(res == 0);\n\t}\n\tw->leaf = NULL;\n\treturn 0;\n}\n\nstatic void fib6_dump_end(struct netlink_callback *cb)\n{\n\tstruct fib6_walker_t *w = (void*)cb->args[2];\n\n\tif (w) {\n\t\tif (cb->args[4]) {\n\t\t\tcb->args[4] = 0;\n\t\t\tfib6_walker_unlink(w);\n\t\t}\n\t\tcb->args[2] = 0;\n\t\tkfree(w);\n\t}\n\tcb->done = (void*)cb->args[3];\n\tcb->args[1] = 3;\n}\n\nstatic int fib6_dump_done(struct netlink_callback *cb)\n{\n\tfib6_dump_end(cb);\n\treturn cb->done ? cb->done(cb) : 0;\n}\n\nstatic int fib6_dump_table(struct fib6_table *table, struct sk_buff *skb,\n\t\t\t   struct netlink_callback *cb)\n{\n\tstruct fib6_walker_t *w;\n\tint res;\n\n\tw = (void *)cb->args[2];\n\tw->root = &table->tb6_root;\n\n\tif (cb->args[4] == 0) {\n\t\tw->count = 0;\n\t\tw->skip = 0;\n\n\t\tread_lock_bh(&table->tb6_lock);\n\t\tres = fib6_walk(w);\n\t\tread_unlock_bh(&table->tb6_lock);\n\t\tif (res > 0) {\n\t\t\tcb->args[4] = 1;\n\t\t\tcb->args[5] = w->root->fn_sernum;\n\t\t}\n\t} else {\n\t\tif (cb->args[5] != w->root->fn_sernum) {\n\t\t\t/* Begin at the root if the tree changed */\n\t\t\tcb->args[5] = w->root->fn_sernum;\n\t\t\tw->state = FWS_INIT;\n\t\t\tw->node = w->root;\n\t\t\tw->skip = w->count;\n\t\t} else\n\t\t\tw->skip = 0;\n\n\t\tread_lock_bh(&table->tb6_lock);\n\t\tres = fib6_walk_continue(w);\n\t\tread_unlock_bh(&table->tb6_lock);\n\t\tif (res <= 0) {\n\t\t\tfib6_walker_unlink(w);\n\t\t\tcb->args[4] = 0;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic int inet6_dump_fib(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tunsigned int h, s_h;\n\tunsigned int e = 0, s_e;\n\tstruct rt6_rtnl_dump_arg arg;\n\tstruct fib6_walker_t *w;\n\tstruct fib6_table *tb;\n\tstruct hlist_head *head;\n\tint res = 0;\n\n\ts_h = cb->args[0];\n\ts_e = cb->args[1];\n\n\tw = (void *)cb->args[2];\n\tif (!w) {\n\t\t/* New dump:\n\t\t *\n\t\t * 1. hook callback destructor.\n\t\t */\n\t\tcb->args[3] = (long)cb->done;\n\t\tcb->done = fib6_dump_done;\n\n\t\t/*\n\t\t * 2. allocate and initialize walker.\n\t\t */\n\t\tw = kzalloc(sizeof(*w), GFP_ATOMIC);\n\t\tif (!w)\n\t\t\treturn -ENOMEM;\n\t\tw->func = fib6_dump_node;\n\t\tcb->args[2] = (long)w;\n\t}\n\n\targ.skb = skb;\n\targ.cb = cb;\n\targ.net = net;\n\tw->args = &arg;\n\n\trcu_read_lock();\n\tfor (h = s_h; h < FIB6_TABLE_HASHSZ; h++, s_e = 0) {\n\t\te = 0;\n\t\thead = &net->ipv6.fib_table_hash[h];\n\t\thlist_for_each_entry_rcu(tb, head, tb6_hlist) {\n\t\t\tif (e < s_e)\n\t\t\t\tgoto next;\n\t\t\tres = fib6_dump_table(tb, skb, cb);\n\t\t\tif (res != 0)\n\t\t\t\tgoto out;\nnext:\n\t\t\te++;\n\t\t}\n\t}\nout:\n\trcu_read_unlock();\n\tcb->args[1] = e;\n\tcb->args[0] = h;\n\n\tres = res < 0 ? res : skb->len;\n\tif (res <= 0)\n\t\tfib6_dump_end(cb);\n\treturn res;\n}\n\n/*\n *\tRouting Table\n *\n *\treturn the appropriate node for a routing tree \"add\" operation\n *\tby either creating and inserting or by returning an existing\n *\tnode.\n */\n\nstatic struct fib6_node * fib6_add_1(struct fib6_node *root, void *addr,\n\t\t\t\t     int addrlen, int plen,\n\t\t\t\t     int offset, int allow_create,\n\t\t\t\t     int replace_required)\n{\n\tstruct fib6_node *fn, *in, *ln;\n\tstruct fib6_node *pn = NULL;\n\tstruct rt6key *key;\n\tint\tbit;\n\t__be32\tdir = 0;\n\t__u32\tsernum = fib6_new_sernum();\n\n\tRT6_TRACE(\"fib6_add_1\\n\");\n\n\t/* insert node in tree */\n\n\tfn = root;\n\n\tdo {\n\t\tkey = (struct rt6key *)((u8 *)fn->leaf + offset);\n\n\t\t/*\n\t\t *\tPrefix match\n\t\t */\n\t\tif (plen < fn->fn_bit ||\n\t\t    !ipv6_prefix_equal(&key->addr, addr, fn->fn_bit)) {\n\t\t\tif (!allow_create) {\n\t\t\t\tif (replace_required) {\n\t\t\t\t\tpr_warn(\"Can't replace route, no match found\\n\");\n\t\t\t\t\treturn ERR_PTR(-ENOENT);\n\t\t\t\t}\n\t\t\t\tpr_warn(\"NLM_F_CREATE should be set when creating new route\\n\");\n\t\t\t}\n\t\t\tgoto insert_above;\n\t\t}\n\n\t\t/*\n\t\t *\tExact match ?\n\t\t */\n\n\t\tif (plen == fn->fn_bit) {\n\t\t\t/* clean up an intermediate node */\n\t\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\t\trt6_release(fn->leaf);\n\t\t\t\tfn->leaf = NULL;\n\t\t\t}\n\n\t\t\tfn->fn_sernum = sernum;\n\n\t\t\treturn fn;\n\t\t}\n\n\t\t/*\n\t\t *\tWe have more bits to go\n\t\t */\n\n\t\t/* Try to walk down on tree. */\n\t\tfn->fn_sernum = sernum;\n\t\tdir = addr_bit_set(addr, fn->fn_bit);\n\t\tpn = fn;\n\t\tfn = dir ? fn->right: fn->left;\n\t} while (fn);\n\n\tif (!allow_create) {\n\t\t/* We should not create new node because\n\t\t * NLM_F_REPLACE was specified without NLM_F_CREATE\n\t\t * I assume it is safe to require NLM_F_CREATE when\n\t\t * REPLACE flag is used! Later we may want to remove the\n\t\t * check for replace_required, because according\n\t\t * to netlink specification, NLM_F_CREATE\n\t\t * MUST be specified if new route is created.\n\t\t * That would keep IPv6 consistent with IPv4\n\t\t */\n\t\tif (replace_required) {\n\t\t\tpr_warn(\"Can't replace route, no match found\\n\");\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\t}\n\t\tpr_warn(\"NLM_F_CREATE should be set when creating new route\\n\");\n\t}\n\t/*\n\t *\tWe walked to the bottom of tree.\n\t *\tCreate new leaf node without children.\n\t */\n\n\tln = node_alloc();\n\n\tif (!ln)\n\t\treturn ERR_PTR(-ENOMEM);\n\tln->fn_bit = plen;\n\n\tln->parent = pn;\n\tln->fn_sernum = sernum;\n\n\tif (dir)\n\t\tpn->right = ln;\n\telse\n\t\tpn->left  = ln;\n\n\treturn ln;\n\n\ninsert_above:\n\t/*\n\t * split since we don't have a common prefix anymore or\n\t * we have a less significant route.\n\t * we've to insert an intermediate node on the list\n\t * this new node will point to the one we need to create\n\t * and the current\n\t */\n\n\tpn = fn->parent;\n\n\t/* find 1st bit in difference between the 2 addrs.\n\n\t   See comment in __ipv6_addr_diff: bit may be an invalid value,\n\t   but if it is >= plen, the value is ignored in any case.\n\t */\n\n\tbit = __ipv6_addr_diff(addr, &key->addr, addrlen);\n\n\t/*\n\t *\t\t(intermediate)[in]\n\t *\t          /\t   \\\n\t *\t(new leaf node)[ln] (old node)[fn]\n\t */\n\tif (plen > bit) {\n\t\tin = node_alloc();\n\t\tln = node_alloc();\n\n\t\tif (!in || !ln) {\n\t\t\tif (in)\n\t\t\t\tnode_free(in);\n\t\t\tif (ln)\n\t\t\t\tnode_free(ln);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\n\t\t/*\n\t\t * new intermediate node.\n\t\t * RTN_RTINFO will\n\t\t * be off since that an address that chooses one of\n\t\t * the branches would not match less specific routes\n\t\t * in the other branch\n\t\t */\n\n\t\tin->fn_bit = bit;\n\n\t\tin->parent = pn;\n\t\tin->leaf = fn->leaf;\n\t\tatomic_inc(&in->leaf->rt6i_ref);\n\n\t\tin->fn_sernum = sernum;\n\n\t\t/* update parent pointer */\n\t\tif (dir)\n\t\t\tpn->right = in;\n\t\telse\n\t\t\tpn->left  = in;\n\n\t\tln->fn_bit = plen;\n\n\t\tln->parent = in;\n\t\tfn->parent = in;\n\n\t\tln->fn_sernum = sernum;\n\n\t\tif (addr_bit_set(addr, bit)) {\n\t\t\tin->right = ln;\n\t\t\tin->left  = fn;\n\t\t} else {\n\t\t\tin->left  = ln;\n\t\t\tin->right = fn;\n\t\t}\n\t} else { /* plen <= bit */\n\n\t\t/*\n\t\t *\t\t(new leaf node)[ln]\n\t\t *\t          /\t   \\\n\t\t *\t     (old node)[fn] NULL\n\t\t */\n\n\t\tln = node_alloc();\n\n\t\tif (!ln)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tln->fn_bit = plen;\n\n\t\tln->parent = pn;\n\n\t\tln->fn_sernum = sernum;\n\n\t\tif (dir)\n\t\t\tpn->right = ln;\n\t\telse\n\t\t\tpn->left  = ln;\n\n\t\tif (addr_bit_set(&key->addr, plen))\n\t\t\tln->right = fn;\n\t\telse\n\t\t\tln->left  = fn;\n\n\t\tfn->parent = ln;\n\t}\n\treturn ln;\n}\n\nstatic inline bool rt6_qualify_for_ecmp(struct rt6_info *rt)\n{\n\treturn (rt->rt6i_flags & (RTF_GATEWAY|RTF_ADDRCONF|RTF_DYNAMIC)) ==\n\t       RTF_GATEWAY;\n}\n\n/*\n *\tInsert routing information in a node.\n */\n\nstatic int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt,\n\t\t\t    struct nl_info *info)\n{\n\tstruct rt6_info *iter = NULL;\n\tstruct rt6_info **ins;\n\tint replace = (info->nlh &&\n\t\t       (info->nlh->nlmsg_flags & NLM_F_REPLACE));\n\tint add = (!info->nlh ||\n\t\t   (info->nlh->nlmsg_flags & NLM_F_CREATE));\n\tint found = 0;\n\tbool rt_can_ecmp = rt6_qualify_for_ecmp(rt);\n\n\tins = &fn->leaf;\n\n\tfor (iter = fn->leaf; iter; iter = iter->dst.rt6_next) {\n\t\t/*\n\t\t *\tSearch for duplicates\n\t\t */\n\n\t\tif (iter->rt6i_metric == rt->rt6i_metric) {\n\t\t\t/*\n\t\t\t *\tSame priority level\n\t\t\t */\n\t\t\tif (info->nlh &&\n\t\t\t    (info->nlh->nlmsg_flags & NLM_F_EXCL))\n\t\t\t\treturn -EEXIST;\n\t\t\tif (replace) {\n\t\t\t\tfound++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (iter->dst.dev == rt->dst.dev &&\n\t\t\t    iter->rt6i_idev == rt->rt6i_idev &&\n\t\t\t    ipv6_addr_equal(&iter->rt6i_gateway,\n\t\t\t\t\t    &rt->rt6i_gateway)) {\n\t\t\t\tif (rt->rt6i_nsiblings)\n\t\t\t\t\trt->rt6i_nsiblings = 0;\n\t\t\t\tif (!(iter->rt6i_flags & RTF_EXPIRES))\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\tif (!(rt->rt6i_flags & RTF_EXPIRES))\n\t\t\t\t\trt6_clean_expires(iter);\n\t\t\t\telse\n\t\t\t\t\trt6_set_expires(iter, rt->dst.expires);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\t/* If we have the same destination and the same metric,\n\t\t\t * but not the same gateway, then the route we try to\n\t\t\t * add is sibling to this route, increment our counter\n\t\t\t * of siblings, and later we will add our route to the\n\t\t\t * list.\n\t\t\t * Only static routes (which don't have flag\n\t\t\t * RTF_EXPIRES) are used for ECMPv6.\n\t\t\t *\n\t\t\t * To avoid long list, we only had siblings if the\n\t\t\t * route have a gateway.\n\t\t\t */\n\t\t\tif (rt_can_ecmp &&\n\t\t\t    rt6_qualify_for_ecmp(iter))\n\t\t\t\trt->rt6i_nsiblings++;\n\t\t}\n\n\t\tif (iter->rt6i_metric > rt->rt6i_metric)\n\t\t\tbreak;\n\n\t\tins = &iter->dst.rt6_next;\n\t}\n\n\t/* Reset round-robin state, if necessary */\n\tif (ins == &fn->leaf)\n\t\tfn->rr_ptr = NULL;\n\n\t/* Link this route to others same route. */\n\tif (rt->rt6i_nsiblings) {\n\t\tunsigned int rt6i_nsiblings;\n\t\tstruct rt6_info *sibling, *temp_sibling;\n\n\t\t/* Find the first route that have the same metric */\n\t\tsibling = fn->leaf;\n\t\twhile (sibling) {\n\t\t\tif (sibling->rt6i_metric == rt->rt6i_metric &&\n\t\t\t    rt6_qualify_for_ecmp(sibling)) {\n\t\t\t\tlist_add_tail(&rt->rt6i_siblings,\n\t\t\t\t\t      &sibling->rt6i_siblings);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsibling = sibling->dst.rt6_next;\n\t\t}\n\t\t/* For each sibling in the list, increment the counter of\n\t\t * siblings. BUG() if counters does not match, list of siblings\n\t\t * is broken!\n\t\t */\n\t\trt6i_nsiblings = 0;\n\t\tlist_for_each_entry_safe(sibling, temp_sibling,\n\t\t\t\t\t &rt->rt6i_siblings, rt6i_siblings) {\n\t\t\tsibling->rt6i_nsiblings++;\n\t\t\tBUG_ON(sibling->rt6i_nsiblings != rt->rt6i_nsiblings);\n\t\t\trt6i_nsiblings++;\n\t\t}\n\t\tBUG_ON(rt6i_nsiblings != rt->rt6i_nsiblings);\n\t}\n\n\t/*\n\t *\tinsert node\n\t */\n\tif (!replace) {\n\t\tif (!add)\n\t\t\tpr_warn(\"NLM_F_CREATE should be set when creating new route\\n\");\n\nadd:\n\t\trt->dst.rt6_next = iter;\n\t\t*ins = rt;\n\t\trt->rt6i_node = fn;\n\t\tatomic_inc(&rt->rt6i_ref);\n\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info);\n\t\tinfo->nl_net->ipv6.rt6_stats->fib_rt_entries++;\n\n\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\n\t\t\tfn->fn_flags |= RTN_RTINFO;\n\t\t}\n\n\t} else {\n\t\tif (!found) {\n\t\t\tif (add)\n\t\t\t\tgoto add;\n\t\t\tpr_warn(\"NLM_F_REPLACE set, but no existing node found!\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t\t*ins = rt;\n\t\trt->rt6i_node = fn;\n\t\trt->dst.rt6_next = iter->dst.rt6_next;\n\t\tatomic_inc(&rt->rt6i_ref);\n\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info);\n\t\trt6_release(iter);\n\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\n\t\t\tfn->fn_flags |= RTN_RTINFO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic __inline__ void fib6_start_gc(struct net *net, struct rt6_info *rt)\n{\n\tif (!timer_pending(&net->ipv6.ip6_fib_timer) &&\n\t    (rt->rt6i_flags & (RTF_EXPIRES | RTF_CACHE)))\n\t\tmod_timer(&net->ipv6.ip6_fib_timer,\n\t\t\t  jiffies + net->ipv6.sysctl.ip6_rt_gc_interval);\n}\n\nvoid fib6_force_start_gc(struct net *net)\n{\n\tif (!timer_pending(&net->ipv6.ip6_fib_timer))\n\t\tmod_timer(&net->ipv6.ip6_fib_timer,\n\t\t\t  jiffies + net->ipv6.sysctl.ip6_rt_gc_interval);\n}\n\n/*\n *\tAdd routing information to the routing tree.\n *\t<destination addr>/<source addr>\n *\twith source addr info in sub-trees\n */\n\nint fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)\n{\n\tstruct fib6_node *fn, *pn = NULL;\n\tint err = -ENOMEM;\n\tint allow_create = 1;\n\tint replace_required = 0;\n\n\tif (info->nlh) {\n\t\tif (!(info->nlh->nlmsg_flags & NLM_F_CREATE))\n\t\t\tallow_create = 0;\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treplace_required = 1;\n\t}\n\tif (!allow_create && !replace_required)\n\t\tpr_warn(\"RTM_NEWROUTE with no NLM_F_CREATE or NLM_F_REPLACE\\n\");\n\n\tfn = fib6_add_1(root, &rt->rt6i_dst.addr, sizeof(struct in6_addr),\n\t\t\trt->rt6i_dst.plen, offsetof(struct rt6_info, rt6i_dst),\n\t\t\tallow_create, replace_required);\n\n\tif (IS_ERR(fn)) {\n\t\terr = PTR_ERR(fn);\n\t\tgoto out;\n\t}\n\n\tpn = fn;\n\n#ifdef CONFIG_IPV6_SUBTREES\n\tif (rt->rt6i_src.plen) {\n\t\tstruct fib6_node *sn;\n\n\t\tif (!fn->subtree) {\n\t\t\tstruct fib6_node *sfn;\n\n\t\t\t/*\n\t\t\t * Create subtree.\n\t\t\t *\n\t\t\t *\t\tfn[main tree]\n\t\t\t *\t\t|\n\t\t\t *\t\tsfn[subtree root]\n\t\t\t *\t\t   \\\n\t\t\t *\t\t    sn[new leaf node]\n\t\t\t */\n\n\t\t\t/* Create subtree root node */\n\t\t\tsfn = node_alloc();\n\t\t\tif (!sfn)\n\t\t\t\tgoto st_failure;\n\n\t\t\tsfn->leaf = info->nl_net->ipv6.ip6_null_entry;\n\t\t\tatomic_inc(&info->nl_net->ipv6.ip6_null_entry->rt6i_ref);\n\t\t\tsfn->fn_flags = RTN_ROOT;\n\t\t\tsfn->fn_sernum = fib6_new_sernum();\n\n\t\t\t/* Now add the first leaf node to new subtree */\n\n\t\t\tsn = fib6_add_1(sfn, &rt->rt6i_src.addr,\n\t\t\t\t\tsizeof(struct in6_addr), rt->rt6i_src.plen,\n\t\t\t\t\toffsetof(struct rt6_info, rt6i_src),\n\t\t\t\t\tallow_create, replace_required);\n\n\t\t\tif (IS_ERR(sn)) {\n\t\t\t\t/* If it is failed, discard just allocated\n\t\t\t\t   root, and then (in st_failure) stale node\n\t\t\t\t   in main tree.\n\t\t\t\t */\n\t\t\t\tnode_free(sfn);\n\t\t\t\terr = PTR_ERR(sn);\n\t\t\t\tgoto st_failure;\n\t\t\t}\n\n\t\t\t/* Now link new subtree to main tree */\n\t\t\tsfn->parent = fn;\n\t\t\tfn->subtree = sfn;\n\t\t} else {\n\t\t\tsn = fib6_add_1(fn->subtree, &rt->rt6i_src.addr,\n\t\t\t\t\tsizeof(struct in6_addr), rt->rt6i_src.plen,\n\t\t\t\t\toffsetof(struct rt6_info, rt6i_src),\n\t\t\t\t\tallow_create, replace_required);\n\n\t\t\tif (IS_ERR(sn)) {\n\t\t\t\terr = PTR_ERR(sn);\n\t\t\t\tgoto st_failure;\n\t\t\t}\n\t\t}\n\n\t\tif (!fn->leaf) {\n\t\t\tfn->leaf = rt;\n\t\t\tatomic_inc(&rt->rt6i_ref);\n\t\t}\n\t\tfn = sn;\n\t}\n#endif\n\n\terr = fib6_add_rt2node(fn, rt, info);\n\tif (!err) {\n\t\tfib6_start_gc(info->nl_net, rt);\n\t\tif (!(rt->rt6i_flags & RTF_CACHE))\n\t\t\tfib6_prune_clones(info->nl_net, pn, rt);\n\t}\n\nout:\n\tif (err) {\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t/*\n\t\t * If fib6_add_1 has cleared the old leaf pointer in the\n\t\t * super-tree leaf node we have to find a new one for it.\n\t\t */\n\t\tif (pn != fn && pn->leaf == rt) {\n\t\t\tpn->leaf = NULL;\n\t\t\tatomic_dec(&rt->rt6i_ref);\n\t\t}\n\t\tif (pn != fn && !pn->leaf && !(pn->fn_flags & RTN_RTINFO)) {\n\t\t\tpn->leaf = fib6_find_prefix(info->nl_net, pn);\n#if RT6_DEBUG >= 2\n\t\t\tif (!pn->leaf) {\n\t\t\t\tWARN_ON(pn->leaf == NULL);\n\t\t\t\tpn->leaf = info->nl_net->ipv6.ip6_null_entry;\n\t\t\t}\n#endif\n\t\t\tatomic_inc(&pn->leaf->rt6i_ref);\n\t\t}\n#endif\n\t\tdst_free(&rt->dst);\n\t}\n\treturn err;\n\n#ifdef CONFIG_IPV6_SUBTREES\n\t/* Subtree creation failed, probably main tree node\n\t   is orphan. If it is, shoot it.\n\t */\nst_failure:\n\tif (fn && !(fn->fn_flags & (RTN_RTINFO|RTN_ROOT)))\n\t\tfib6_repair_tree(info->nl_net, fn);\n\tdst_free(&rt->dst);\n\treturn err;\n#endif\n}\n\n/*\n *\tRouting tree lookup\n *\n */\n\nstruct lookup_args {\n\tint\t\t\toffset;\t\t/* key offset on rt6_info\t*/\n\tconst struct in6_addr\t*addr;\t\t/* search key\t\t\t*/\n};\n\nstatic struct fib6_node * fib6_lookup_1(struct fib6_node *root,\n\t\t\t\t\tstruct lookup_args *args)\n{\n\tstruct fib6_node *fn;\n\t__be32 dir;\n\n\tif (unlikely(args->offset == 0))\n\t\treturn NULL;\n\n\t/*\n\t *\tDescend on a tree\n\t */\n\n\tfn = root;\n\n\tfor (;;) {\n\t\tstruct fib6_node *next;\n\n\t\tdir = addr_bit_set(args->addr, fn->fn_bit);\n\n\t\tnext = dir ? fn->right : fn->left;\n\n\t\tif (next) {\n\t\t\tfn = next;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\twhile (fn) {\n\t\tif (FIB6_SUBTREE(fn) || fn->fn_flags & RTN_RTINFO) {\n\t\t\tstruct rt6key *key;\n\n\t\t\tkey = (struct rt6key *) ((u8 *) fn->leaf +\n\t\t\t\t\t\t args->offset);\n\n\t\t\tif (ipv6_prefix_equal(&key->addr, args->addr, key->plen)) {\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t\t\tif (fn->subtree)\n\t\t\t\t\tfn = fib6_lookup_1(fn->subtree, args + 1);\n#endif\n\t\t\t\tif (!fn || fn->fn_flags & RTN_RTINFO)\n\t\t\t\t\treturn fn;\n\t\t\t}\n\t\t}\n\n\t\tif (fn->fn_flags & RTN_ROOT)\n\t\t\tbreak;\n\n\t\tfn = fn->parent;\n\t}\n\n\treturn NULL;\n}\n\nstruct fib6_node * fib6_lookup(struct fib6_node *root, const struct in6_addr *daddr,\n\t\t\t       const struct in6_addr *saddr)\n{\n\tstruct fib6_node *fn;\n\tstruct lookup_args args[] = {\n\t\t{\n\t\t\t.offset = offsetof(struct rt6_info, rt6i_dst),\n\t\t\t.addr = daddr,\n\t\t},\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t{\n\t\t\t.offset = offsetof(struct rt6_info, rt6i_src),\n\t\t\t.addr = saddr,\n\t\t},\n#endif\n\t\t{\n\t\t\t.offset = 0,\t/* sentinel */\n\t\t}\n\t};\n\n\tfn = fib6_lookup_1(root, daddr ? args : args + 1);\n\tif (!fn || fn->fn_flags & RTN_TL_ROOT)\n\t\tfn = root;\n\n\treturn fn;\n}\n\n/*\n *\tGet node with specified destination prefix (and source prefix,\n *\tif subtrees are used)\n */\n\n\nstatic struct fib6_node * fib6_locate_1(struct fib6_node *root,\n\t\t\t\t\tconst struct in6_addr *addr,\n\t\t\t\t\tint plen, int offset)\n{\n\tstruct fib6_node *fn;\n\n\tfor (fn = root; fn ; ) {\n\t\tstruct rt6key *key = (struct rt6key *)((u8 *)fn->leaf + offset);\n\n\t\t/*\n\t\t *\tPrefix match\n\t\t */\n\t\tif (plen < fn->fn_bit ||\n\t\t    !ipv6_prefix_equal(&key->addr, addr, fn->fn_bit))\n\t\t\treturn NULL;\n\n\t\tif (plen == fn->fn_bit)\n\t\t\treturn fn;\n\n\t\t/*\n\t\t *\tWe have more bits to go\n\t\t */\n\t\tif (addr_bit_set(addr, fn->fn_bit))\n\t\t\tfn = fn->right;\n\t\telse\n\t\t\tfn = fn->left;\n\t}\n\treturn NULL;\n}\n\nstruct fib6_node * fib6_locate(struct fib6_node *root,\n\t\t\t       const struct in6_addr *daddr, int dst_len,\n\t\t\t       const struct in6_addr *saddr, int src_len)\n{\n\tstruct fib6_node *fn;\n\n\tfn = fib6_locate_1(root, daddr, dst_len,\n\t\t\t   offsetof(struct rt6_info, rt6i_dst));\n\n#ifdef CONFIG_IPV6_SUBTREES\n\tif (src_len) {\n\t\tWARN_ON(saddr == NULL);\n\t\tif (fn && fn->subtree)\n\t\t\tfn = fib6_locate_1(fn->subtree, saddr, src_len,\n\t\t\t\t\t   offsetof(struct rt6_info, rt6i_src));\n\t}\n#endif\n\n\tif (fn && fn->fn_flags & RTN_RTINFO)\n\t\treturn fn;\n\n\treturn NULL;\n}\n\n\n/*\n *\tDeletion\n *\n */\n\nstatic struct rt6_info *fib6_find_prefix(struct net *net, struct fib6_node *fn)\n{\n\tif (fn->fn_flags & RTN_ROOT)\n\t\treturn net->ipv6.ip6_null_entry;\n\n\twhile (fn) {\n\t\tif (fn->left)\n\t\t\treturn fn->left->leaf;\n\t\tif (fn->right)\n\t\t\treturn fn->right->leaf;\n\n\t\tfn = FIB6_SUBTREE(fn);\n\t}\n\treturn NULL;\n}\n\n/*\n *\tCalled to trim the tree of intermediate nodes when possible. \"fn\"\n *\tis the node we want to try and remove.\n */\n\nstatic struct fib6_node *fib6_repair_tree(struct net *net,\n\t\t\t\t\t   struct fib6_node *fn)\n{\n\tint children;\n\tint nstate;\n\tstruct fib6_node *child, *pn;\n\tstruct fib6_walker_t *w;\n\tint iter = 0;\n\n\tfor (;;) {\n\t\tRT6_TRACE(\"fixing tree: plen=%d iter=%d\\n\", fn->fn_bit, iter);\n\t\titer++;\n\n\t\tWARN_ON(fn->fn_flags & RTN_RTINFO);\n\t\tWARN_ON(fn->fn_flags & RTN_TL_ROOT);\n\t\tWARN_ON(fn->leaf != NULL);\n\n\t\tchildren = 0;\n\t\tchild = NULL;\n\t\tif (fn->right) child = fn->right, children |= 1;\n\t\tif (fn->left) child = fn->left, children |= 2;\n\n\t\tif (children == 3 || FIB6_SUBTREE(fn)\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t    /* Subtree root (i.e. fn) may have one child */\n\t\t    || (children && fn->fn_flags & RTN_ROOT)\n#endif\n\t\t    ) {\n\t\t\tfn->leaf = fib6_find_prefix(net, fn);\n#if RT6_DEBUG >= 2\n\t\t\tif (!fn->leaf) {\n\t\t\t\tWARN_ON(!fn->leaf);\n\t\t\t\tfn->leaf = net->ipv6.ip6_null_entry;\n\t\t\t}\n#endif\n\t\t\tatomic_inc(&fn->leaf->rt6i_ref);\n\t\t\treturn fn->parent;\n\t\t}\n\n\t\tpn = fn->parent;\n#ifdef CONFIG_IPV6_SUBTREES\n\t\tif (FIB6_SUBTREE(pn) == fn) {\n\t\t\tWARN_ON(!(fn->fn_flags & RTN_ROOT));\n\t\t\tFIB6_SUBTREE(pn) = NULL;\n\t\t\tnstate = FWS_L;\n\t\t} else {\n\t\t\tWARN_ON(fn->fn_flags & RTN_ROOT);\n#endif\n\t\t\tif (pn->right == fn) pn->right = child;\n\t\t\telse if (pn->left == fn) pn->left = child;\n#if RT6_DEBUG >= 2\n\t\t\telse\n\t\t\t\tWARN_ON(1);\n#endif\n\t\t\tif (child)\n\t\t\t\tchild->parent = pn;\n\t\t\tnstate = FWS_R;\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t}\n#endif\n\n\t\tread_lock(&fib6_walker_lock);\n\t\tFOR_WALKERS(w) {\n\t\t\tif (!child) {\n\t\t\t\tif (w->root == fn) {\n\t\t\t\t\tw->root = w->node = NULL;\n\t\t\t\t\tRT6_TRACE(\"W %p adjusted by delroot 1\\n\", w);\n\t\t\t\t} else if (w->node == fn) {\n\t\t\t\t\tRT6_TRACE(\"W %p adjusted by delnode 1, s=%d/%d\\n\", w, w->state, nstate);\n\t\t\t\t\tw->node = pn;\n\t\t\t\t\tw->state = nstate;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (w->root == fn) {\n\t\t\t\t\tw->root = child;\n\t\t\t\t\tRT6_TRACE(\"W %p adjusted by delroot 2\\n\", w);\n\t\t\t\t}\n\t\t\t\tif (w->node == fn) {\n\t\t\t\t\tw->node = child;\n\t\t\t\t\tif (children&2) {\n\t\t\t\t\t\tRT6_TRACE(\"W %p adjusted by delnode 2, s=%d\\n\", w, w->state);\n\t\t\t\t\t\tw->state = w->state>=FWS_R ? FWS_U : FWS_INIT;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRT6_TRACE(\"W %p adjusted by delnode 2, s=%d\\n\", w, w->state);\n\t\t\t\t\t\tw->state = w->state>=FWS_C ? FWS_U : FWS_INIT;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tread_unlock(&fib6_walker_lock);\n\n\t\tnode_free(fn);\n\t\tif (pn->fn_flags & RTN_RTINFO || FIB6_SUBTREE(pn))\n\t\t\treturn pn;\n\n\t\trt6_release(pn->leaf);\n\t\tpn->leaf = NULL;\n\t\tfn = pn;\n\t}\n}\n\nstatic void fib6_del_route(struct fib6_node *fn, struct rt6_info **rtp,\n\t\t\t   struct nl_info *info)\n{\n\tstruct fib6_walker_t *w;\n\tstruct rt6_info *rt = *rtp;\n\tstruct net *net = info->nl_net;\n\n\tRT6_TRACE(\"fib6_del_route\\n\");\n\n\t/* Unlink it */\n\t*rtp = rt->dst.rt6_next;\n\trt->rt6i_node = NULL;\n\tnet->ipv6.rt6_stats->fib_rt_entries--;\n\tnet->ipv6.rt6_stats->fib_discarded_routes++;\n\n\t/* Reset round-robin state, if necessary */\n\tif (fn->rr_ptr == rt)\n\t\tfn->rr_ptr = NULL;\n\n\t/* Remove this entry from other siblings */\n\tif (rt->rt6i_nsiblings) {\n\t\tstruct rt6_info *sibling, *next_sibling;\n\n\t\tlist_for_each_entry_safe(sibling, next_sibling,\n\t\t\t\t\t &rt->rt6i_siblings, rt6i_siblings)\n\t\t\tsibling->rt6i_nsiblings--;\n\t\trt->rt6i_nsiblings = 0;\n\t\tlist_del_init(&rt->rt6i_siblings);\n\t}\n\n\t/* Adjust walkers */\n\tread_lock(&fib6_walker_lock);\n\tFOR_WALKERS(w) {\n\t\tif (w->state == FWS_C && w->leaf == rt) {\n\t\t\tRT6_TRACE(\"walker %p adjusted by delroute\\n\", w);\n\t\t\tw->leaf = rt->dst.rt6_next;\n\t\t\tif (!w->leaf)\n\t\t\t\tw->state = FWS_U;\n\t\t}\n\t}\n\tread_unlock(&fib6_walker_lock);\n\n\trt->dst.rt6_next = NULL;\n\n\t/* If it was last route, expunge its radix tree node */\n\tif (!fn->leaf) {\n\t\tfn->fn_flags &= ~RTN_RTINFO;\n\t\tnet->ipv6.rt6_stats->fib_route_nodes--;\n\t\tfn = fib6_repair_tree(net, fn);\n\t}\n\n\tif (atomic_read(&rt->rt6i_ref) != 1) {\n\t\t/* This route is used as dummy address holder in some split\n\t\t * nodes. It is not leaked, but it still holds other resources,\n\t\t * which must be released in time. So, scan ascendant nodes\n\t\t * and replace dummy references to this route with references\n\t\t * to still alive ones.\n\t\t */\n\t\twhile (fn) {\n\t\t\tif (!(fn->fn_flags & RTN_RTINFO) && fn->leaf == rt) {\n\t\t\t\tfn->leaf = fib6_find_prefix(net, fn);\n\t\t\t\tatomic_inc(&fn->leaf->rt6i_ref);\n\t\t\t\trt6_release(rt);\n\t\t\t}\n\t\t\tfn = fn->parent;\n\t\t}\n\t\t/* No more references are possible at this point. */\n\t\tBUG_ON(atomic_read(&rt->rt6i_ref) != 1);\n\t}\n\n\tinet6_rt_notify(RTM_DELROUTE, rt, info);\n\trt6_release(rt);\n}\n\nint fib6_del(struct rt6_info *rt, struct nl_info *info)\n{\n\tstruct net *net = info->nl_net;\n\tstruct fib6_node *fn = rt->rt6i_node;\n\tstruct rt6_info **rtp;\n\n#if RT6_DEBUG >= 2\n\tif (rt->dst.obsolete>0) {\n\t\tWARN_ON(fn != NULL);\n\t\treturn -ENOENT;\n\t}\n#endif\n\tif (!fn || rt == net->ipv6.ip6_null_entry)\n\t\treturn -ENOENT;\n\n\tWARN_ON(!(fn->fn_flags & RTN_RTINFO));\n\n\tif (!(rt->rt6i_flags & RTF_CACHE)) {\n\t\tstruct fib6_node *pn = fn;\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t/* clones of this route might be in another subtree */\n\t\tif (rt->rt6i_src.plen) {\n\t\t\twhile (!(pn->fn_flags & RTN_ROOT))\n\t\t\t\tpn = pn->parent;\n\t\t\tpn = pn->parent;\n\t\t}\n#endif\n\t\tfib6_prune_clones(info->nl_net, pn, rt);\n\t}\n\n\t/*\n\t *\tWalk the leaf entries looking for ourself\n\t */\n\n\tfor (rtp = &fn->leaf; *rtp; rtp = &(*rtp)->dst.rt6_next) {\n\t\tif (*rtp == rt) {\n\t\t\tfib6_del_route(fn, rtp, info);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}\n\n/*\n *\tTree traversal function.\n *\n *\tCertainly, it is not interrupt safe.\n *\tHowever, it is internally reenterable wrt itself and fib6_add/fib6_del.\n *\tIt means, that we can modify tree during walking\n *\tand use this function for garbage collection, clone pruning,\n *\tcleaning tree when a device goes down etc. etc.\n *\n *\tIt guarantees that every node will be traversed,\n *\tand that it will be traversed only once.\n *\n *\tCallback function w->func may return:\n *\t0 -> continue walking.\n *\tpositive value -> walking is suspended (used by tree dumps,\n *\tand probably by gc, if it will be split to several slices)\n *\tnegative value -> terminate walking.\n *\n *\tThe function itself returns:\n *\t0   -> walk is complete.\n *\t>0  -> walk is incomplete (i.e. suspended)\n *\t<0  -> walk is terminated by an error.\n */\n\nstatic int fib6_walk_continue(struct fib6_walker_t *w)\n{\n\tstruct fib6_node *fn, *pn;\n\n\tfor (;;) {\n\t\tfn = w->node;\n\t\tif (!fn)\n\t\t\treturn 0;\n\n\t\tif (w->prune && fn != w->root &&\n\t\t    fn->fn_flags & RTN_RTINFO && w->state < FWS_C) {\n\t\t\tw->state = FWS_C;\n\t\t\tw->leaf = fn->leaf;\n\t\t}\n\t\tswitch (w->state) {\n#ifdef CONFIG_IPV6_SUBTREES\n\t\tcase FWS_S:\n\t\t\tif (FIB6_SUBTREE(fn)) {\n\t\t\t\tw->node = FIB6_SUBTREE(fn);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tw->state = FWS_L;\n#endif\n\t\tcase FWS_L:\n\t\t\tif (fn->left) {\n\t\t\t\tw->node = fn->left;\n\t\t\t\tw->state = FWS_INIT;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tw->state = FWS_R;\n\t\tcase FWS_R:\n\t\t\tif (fn->right) {\n\t\t\t\tw->node = fn->right;\n\t\t\t\tw->state = FWS_INIT;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tw->state = FWS_C;\n\t\t\tw->leaf = fn->leaf;\n\t\tcase FWS_C:\n\t\t\tif (w->leaf && fn->fn_flags & RTN_RTINFO) {\n\t\t\t\tint err;\n\n\t\t\t\tif (w->skip) {\n\t\t\t\t\tw->skip--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\terr = w->func(w);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tw->count++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tw->state = FWS_U;\n\t\tcase FWS_U:\n\t\t\tif (fn == w->root)\n\t\t\t\treturn 0;\n\t\t\tpn = fn->parent;\n\t\t\tw->node = pn;\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t\tif (FIB6_SUBTREE(pn) == fn) {\n\t\t\t\tWARN_ON(!(fn->fn_flags & RTN_ROOT));\n\t\t\t\tw->state = FWS_L;\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tif (pn->left == fn) {\n\t\t\t\tw->state = FWS_R;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (pn->right == fn) {\n\t\t\t\tw->state = FWS_C;\n\t\t\t\tw->leaf = w->node->leaf;\n\t\t\t\tcontinue;\n\t\t\t}\n#if RT6_DEBUG >= 2\n\t\t\tWARN_ON(1);\n#endif\n\t\t}\n\t}\n}\n\nstatic int fib6_walk(struct fib6_walker_t *w)\n{\n\tint res;\n\n\tw->state = FWS_INIT;\n\tw->node = w->root;\n\n\tfib6_walker_link(w);\n\tres = fib6_walk_continue(w);\n\tif (res <= 0)\n\t\tfib6_walker_unlink(w);\n\treturn res;\n}\n\nstatic int fib6_clean_node(struct fib6_walker_t *w)\n{\n\tint res;\n\tstruct rt6_info *rt;\n\tstruct fib6_cleaner_t *c = container_of(w, struct fib6_cleaner_t, w);\n\tstruct nl_info info = {\n\t\t.nl_net = c->net,\n\t};\n\n\tfor (rt = w->leaf; rt; rt = rt->dst.rt6_next) {\n\t\tres = c->func(rt, c->arg);\n\t\tif (res < 0) {\n\t\t\tw->leaf = rt;\n\t\t\tres = fib6_del(rt, &info);\n\t\t\tif (res) {\n#if RT6_DEBUG >= 2\n\t\t\t\tpr_debug(\"%s: del failed: rt=%p@%p err=%d\\n\",\n\t\t\t\t\t __func__, rt, rt->rt6i_node, res);\n#endif\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tWARN_ON(res != 0);\n\t}\n\tw->leaf = rt;\n\treturn 0;\n}\n\n/*\n *\tConvenient frontend to tree walker.\n *\n *\tfunc is called on each route.\n *\t\tIt may return -1 -> delete this route.\n *\t\t              0  -> continue walking\n *\n *\tprune==1 -> only immediate children of node (certainly,\n *\tignoring pure split nodes) will be scanned.\n */\n\nstatic void fib6_clean_tree(struct net *net, struct fib6_node *root,\n\t\t\t    int (*func)(struct rt6_info *, void *arg),\n\t\t\t    int prune, void *arg)\n{\n\tstruct fib6_cleaner_t c;\n\n\tc.w.root = root;\n\tc.w.func = fib6_clean_node;\n\tc.w.prune = prune;\n\tc.w.count = 0;\n\tc.w.skip = 0;\n\tc.func = func;\n\tc.arg = arg;\n\tc.net = net;\n\n\tfib6_walk(&c.w);\n}\n\nvoid fib6_clean_all_ro(struct net *net, int (*func)(struct rt6_info *, void *arg),\n\t\t    int prune, void *arg)\n{\n\tstruct fib6_table *table;\n\tstruct hlist_head *head;\n\tunsigned int h;\n\n\trcu_read_lock();\n\tfor (h = 0; h < FIB6_TABLE_HASHSZ; h++) {\n\t\thead = &net->ipv6.fib_table_hash[h];\n\t\thlist_for_each_entry_rcu(table, head, tb6_hlist) {\n\t\t\tread_lock_bh(&table->tb6_lock);\n\t\t\tfib6_clean_tree(net, &table->tb6_root,\n\t\t\t\t\tfunc, prune, arg);\n\t\t\tread_unlock_bh(&table->tb6_lock);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\nvoid fib6_clean_all(struct net *net, int (*func)(struct rt6_info *, void *arg),\n\t\t    int prune, void *arg)\n{\n\tstruct fib6_table *table;\n\tstruct hlist_head *head;\n\tunsigned int h;\n\n\trcu_read_lock();\n\tfor (h = 0; h < FIB6_TABLE_HASHSZ; h++) {\n\t\thead = &net->ipv6.fib_table_hash[h];\n\t\thlist_for_each_entry_rcu(table, head, tb6_hlist) {\n\t\t\twrite_lock_bh(&table->tb6_lock);\n\t\t\tfib6_clean_tree(net, &table->tb6_root,\n\t\t\t\t\tfunc, prune, arg);\n\t\t\twrite_unlock_bh(&table->tb6_lock);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\nstatic int fib6_prune_clone(struct rt6_info *rt, void *arg)\n{\n\tif (rt->rt6i_flags & RTF_CACHE) {\n\t\tRT6_TRACE(\"pruning clone %p\\n\", rt);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void fib6_prune_clones(struct net *net, struct fib6_node *fn,\n\t\t\t      struct rt6_info *rt)\n{\n\tfib6_clean_tree(net, fn, fib6_prune_clone, 1, rt);\n}\n\n/*\n *\tGarbage collection\n */\n\nstatic struct fib6_gc_args\n{\n\tint\t\t\ttimeout;\n\tint\t\t\tmore;\n} gc_args;\n\nstatic int fib6_age(struct rt6_info *rt, void *arg)\n{\n\tunsigned long now = jiffies;\n\n\t/*\n\t *\tcheck addrconf expiration here.\n\t *\tRoutes are expired even if they are in use.\n\t *\n\t *\tAlso age clones. Note, that clones are aged out\n\t *\tonly if they are not in use now.\n\t */\n\n\tif (rt->rt6i_flags & RTF_EXPIRES && rt->dst.expires) {\n\t\tif (time_after(now, rt->dst.expires)) {\n\t\t\tRT6_TRACE(\"expiring %p\\n\", rt);\n\t\t\treturn -1;\n\t\t}\n\t\tgc_args.more++;\n\t} else if (rt->rt6i_flags & RTF_CACHE) {\n\t\tif (atomic_read(&rt->dst.__refcnt) == 0 &&\n\t\t    time_after_eq(now, rt->dst.lastuse + gc_args.timeout)) {\n\t\t\tRT6_TRACE(\"aging clone %p\\n\", rt);\n\t\t\treturn -1;\n\t\t} else if (rt->rt6i_flags & RTF_GATEWAY) {\n\t\t\tstruct neighbour *neigh;\n\t\t\t__u8 neigh_flags = 0;\n\n\t\t\tneigh = dst_neigh_lookup(&rt->dst, &rt->rt6i_gateway);\n\t\t\tif (neigh) {\n\t\t\t\tneigh_flags = neigh->flags;\n\t\t\t\tneigh_release(neigh);\n\t\t\t}\n\t\t\tif (!(neigh_flags & NTF_ROUTER)) {\n\t\t\t\tRT6_TRACE(\"purging route %p via non-router but gateway\\n\",\n\t\t\t\t\t  rt);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tgc_args.more++;\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_SPINLOCK(fib6_gc_lock);\n\nvoid fib6_run_gc(unsigned long expires, struct net *net)\n{\n\tif (expires != ~0UL) {\n\t\tspin_lock_bh(&fib6_gc_lock);\n\t\tgc_args.timeout = expires ? (int)expires :\n\t\t\tnet->ipv6.sysctl.ip6_rt_gc_interval;\n\t} else {\n\t\tif (!spin_trylock_bh(&fib6_gc_lock)) {\n\t\t\tmod_timer(&net->ipv6.ip6_fib_timer, jiffies + HZ);\n\t\t\treturn;\n\t\t}\n\t\tgc_args.timeout = net->ipv6.sysctl.ip6_rt_gc_interval;\n\t}\n\n\tgc_args.more = icmp6_dst_gc();\n\n\tfib6_clean_all(net, fib6_age, 0, NULL);\n\n\tif (gc_args.more)\n\t\tmod_timer(&net->ipv6.ip6_fib_timer,\n\t\t\t  round_jiffies(jiffies\n\t\t\t\t\t+ net->ipv6.sysctl.ip6_rt_gc_interval));\n\telse\n\t\tdel_timer(&net->ipv6.ip6_fib_timer);\n\tspin_unlock_bh(&fib6_gc_lock);\n}\n\nstatic void fib6_gc_timer_cb(unsigned long arg)\n{\n\tfib6_run_gc(0, (struct net *)arg);\n}\n\nstatic int __net_init fib6_net_init(struct net *net)\n{\n\tsize_t size = sizeof(struct hlist_head) * FIB6_TABLE_HASHSZ;\n\n\tsetup_timer(&net->ipv6.ip6_fib_timer, fib6_gc_timer_cb, (unsigned long)net);\n\n\tnet->ipv6.rt6_stats = kzalloc(sizeof(*net->ipv6.rt6_stats), GFP_KERNEL);\n\tif (!net->ipv6.rt6_stats)\n\t\tgoto out_timer;\n\n\t/* Avoid false sharing : Use at least a full cache line */\n\tsize = max_t(size_t, size, L1_CACHE_BYTES);\n\n\tnet->ipv6.fib_table_hash = kzalloc(size, GFP_KERNEL);\n\tif (!net->ipv6.fib_table_hash)\n\t\tgoto out_rt6_stats;\n\n\tnet->ipv6.fib6_main_tbl = kzalloc(sizeof(*net->ipv6.fib6_main_tbl),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!net->ipv6.fib6_main_tbl)\n\t\tgoto out_fib_table_hash;\n\n\tnet->ipv6.fib6_main_tbl->tb6_id = RT6_TABLE_MAIN;\n\tnet->ipv6.fib6_main_tbl->tb6_root.leaf = net->ipv6.ip6_null_entry;\n\tnet->ipv6.fib6_main_tbl->tb6_root.fn_flags =\n\t\tRTN_ROOT | RTN_TL_ROOT | RTN_RTINFO;\n\tinet_peer_base_init(&net->ipv6.fib6_main_tbl->tb6_peers);\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\tnet->ipv6.fib6_local_tbl = kzalloc(sizeof(*net->ipv6.fib6_local_tbl),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!net->ipv6.fib6_local_tbl)\n\t\tgoto out_fib6_main_tbl;\n\tnet->ipv6.fib6_local_tbl->tb6_id = RT6_TABLE_LOCAL;\n\tnet->ipv6.fib6_local_tbl->tb6_root.leaf = net->ipv6.ip6_null_entry;\n\tnet->ipv6.fib6_local_tbl->tb6_root.fn_flags =\n\t\tRTN_ROOT | RTN_TL_ROOT | RTN_RTINFO;\n\tinet_peer_base_init(&net->ipv6.fib6_local_tbl->tb6_peers);\n#endif\n\tfib6_tables_init(net);\n\n\treturn 0;\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\nout_fib6_main_tbl:\n\tkfree(net->ipv6.fib6_main_tbl);\n#endif\nout_fib_table_hash:\n\tkfree(net->ipv6.fib_table_hash);\nout_rt6_stats:\n\tkfree(net->ipv6.rt6_stats);\nout_timer:\n\treturn -ENOMEM;\n }\n\nstatic void fib6_net_exit(struct net *net)\n{\n\trt6_ifdown(net, NULL);\n\tdel_timer_sync(&net->ipv6.ip6_fib_timer);\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\tinetpeer_invalidate_tree(&net->ipv6.fib6_local_tbl->tb6_peers);\n\tkfree(net->ipv6.fib6_local_tbl);\n#endif\n\tinetpeer_invalidate_tree(&net->ipv6.fib6_main_tbl->tb6_peers);\n\tkfree(net->ipv6.fib6_main_tbl);\n\tkfree(net->ipv6.fib_table_hash);\n\tkfree(net->ipv6.rt6_stats);\n}\n\nstatic struct pernet_operations fib6_net_ops = {\n\t.init = fib6_net_init,\n\t.exit = fib6_net_exit,\n};\n\nint __init fib6_init(void)\n{\n\tint ret = -ENOMEM;\n\n\tfib6_node_kmem = kmem_cache_create(\"fib6_nodes\",\n\t\t\t\t\t   sizeof(struct fib6_node),\n\t\t\t\t\t   0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t   NULL);\n\tif (!fib6_node_kmem)\n\t\tgoto out;\n\n\tret = register_pernet_subsys(&fib6_net_ops);\n\tif (ret)\n\t\tgoto out_kmem_cache_create;\n\n\tret = __rtnl_register(PF_INET6, RTM_GETROUTE, NULL, inet6_dump_fib,\n\t\t\t      NULL);\n\tif (ret)\n\t\tgoto out_unregister_subsys;\nout:\n\treturn ret;\n\nout_unregister_subsys:\n\tunregister_pernet_subsys(&fib6_net_ops);\nout_kmem_cache_create:\n\tkmem_cache_destroy(fib6_node_kmem);\n\tgoto out;\n}\n\nvoid fib6_gc_cleanup(void)\n{\n\tunregister_pernet_subsys(&fib6_net_ops);\n\tkmem_cache_destroy(fib6_node_kmem);\n}\n"], "filenames": ["net/ipv6/ip6_fib.c"], "buggy_code_start_loc": [634], "buggy_code_end_loc": [719], "fixing_code_start_loc": [635], "fixing_code_end_loc": [726], "type": "CWE-399", "message": "The fib6_add_rt2node function in net/ipv6/ip6_fib.c in the IPv6 stack in the Linux kernel through 3.10.1 does not properly handle Router Advertisement (RA) messages in certain circumstances involving three routes that initially qualified for membership in an ECMP route set until a change occurred for one of the first two routes, which allows remote attackers to cause a denial of service (system crash) via a crafted sequence of messages.", "other": {"cve": {"id": "CVE-2013-4125", "sourceIdentifier": "secalert@redhat.com", "published": "2013-07-15T20:55:03.500", "lastModified": "2023-02-13T00:28:31.913", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The fib6_add_rt2node function in net/ipv6/ip6_fib.c in the IPv6 stack in the Linux kernel through 3.10.1 does not properly handle Router Advertisement (RA) messages in certain circumstances involving three routes that initially qualified for membership in an ECMP route set until a change occurred for one of the first two routes, which allows remote attackers to cause a denial of service (system crash) via a crafted sequence of messages."}, {"lang": "es", "value": "La funci\u00f3n fib6_add_rt2node en net/ipv6/ip6_fib.c en l apila IPv6 en el kernel de Linux kernel hasta la versi\u00f3n 3.10.1 no maneja adecuadamente los mensajes de advertencia (RA) del router en determinadas circunstancias qie involucran a las tres rutas que se establecen inicialmente para el establecimiento de rutas ECMP hasta que ocurra un cambio para una de las primeras dos rutas, lo que permite a atacantes remotos provocar una denegaci\u00f3n de servicio (ca\u00edda de aplicaci\u00f3n) a trav\u00e9s de una  secuencia de mensajes manipulada."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 5.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 4.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.10.1", "matchCriteriaId": "8D22D6D1-FCD6-4CD2-A5EE-1660AC4F9066"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "D30AEC07-3CBD-4F4F-9646-BEAA1D98750B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C2AA8E68-691B-499C-AEDD-3C0BFFE70044"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "9440475B-5960-4066-A204-F30AAFC87846"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "53BCFBFB-6AF0-4525-8623-7633CC5E17DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "6ED4E86A-74F0-436A-BEB4-3F4EE93A5421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc6:*:*:*:*:*:*", "matchCriteriaId": "BF0365B0-8E16-4F30-BD92-5DD538CC8135"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc7:*:*:*:*:*:*", "matchCriteriaId": "079505E8-2942-4C33-93D1-35ADA4C39E72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "38989541-2360-4E0A-AE5A-3D6144AA6114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "4E51646B-7A0E-40F3-B8C9-239C1DA81DD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "42A8A507-F8E2-491C-A144-B2448A1DB26E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "901FC6F3-2C2A-4112-AE27-AB102BBE8DEE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "203AD334-DB9F-41B0-A4D1-A6C158EF8C40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "B3611753-E440-410F-8250-600C996A4B8E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "9739BB47-EEAF-42F1-A557-2AE2EA9526A3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "5A95E3BB-0AFC-4C2E-B9BE-C975E902A266"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "482A6C9A-9B8E-4D1C-917A-F16370745E7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "C6D87357-63E0-41D0-9F02-1BCBF9A77E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "3765A2D6-2D78-4FB1-989E-D5106BFA3F5E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "F54257DB-7023-43C4-AC4D-9590B815CD92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "61FF5FCD-A4A1-4803-AC53-320A4C838AF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "9F096553-064F-46A2-877B-F32F163A0F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "C0D762D1-E3AD-40EA-8D39-83EEB51B5E85"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.16:*:*:*:*:*:*:*", "matchCriteriaId": "A6187D19-7148-4B87-AD7E-244FF9EE0FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.17:*:*:*:*:*:*:*", "matchCriteriaId": "99AC64C2-E391-485C-9CD7-BA09C8FA5E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.18:*:*:*:*:*:*:*", "matchCriteriaId": "8CDA5E95-7805-441B-BEF7-4448EA45E964"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.19:*:*:*:*:*:*:*", "matchCriteriaId": "51561053-6C28-4F38-BC9B-3F7A7508EB72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.20:*:*:*:*:*:*:*", "matchCriteriaId": "118F4A5B-C498-4FC3-BE28-50D18EBE4F22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.21:*:*:*:*:*:*:*", "matchCriteriaId": "BD38EBE6-FE1A-4B55-9FB5-07952253B7A5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.22:*:*:*:*:*:*:*", "matchCriteriaId": "3A491E47-82AD-4055-9444-2EC0D6715326"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.23:*:*:*:*:*:*:*", "matchCriteriaId": "13C5FD16-23B6-467F-9438-5B554922F974"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.24:*:*:*:*:*:*:*", "matchCriteriaId": "9C67235F-5B51-4BF7-89EC-4810F720246F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.25:*:*:*:*:*:*:*", "matchCriteriaId": "08405DEF-05F4-45F0-AC95-DBF914A36D93"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.26:*:*:*:*:*:*:*", "matchCriteriaId": "1A7B9C4B-4A41-4175-9F07-191C1EE98C1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.27:*:*:*:*:*:*:*", "matchCriteriaId": "B306E0A8-4D4A-4895-8128-A500D30A7E0C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.28:*:*:*:*:*:*:*", "matchCriteriaId": "295C839A-F34E-4853-A926-55EABC639412"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.29:*:*:*:*:*:*:*", "matchCriteriaId": "2AFD5F49-7EF9-4CFE-95BD-8FD19B500B0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.30:*:*:*:*:*:*:*", "matchCriteriaId": "00B3DDDD-B2F6-4753-BA38-65A24017857D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.31:*:*:*:*:*:*:*", "matchCriteriaId": "33FCD39E-F4BF-432D-9CF9-F195CF5844F3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.32:*:*:*:*:*:*:*", "matchCriteriaId": "C7308690-CB0D-4758-B80F-D2ADCD2A9D66"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.33:*:*:*:*:*:*:*", "matchCriteriaId": "313A470B-8A2B-478A-82B5-B27D2718331C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.34:*:*:*:*:*:*:*", "matchCriteriaId": "83FF021E-07E3-41CC-AAE8-D99D7FF24B9D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.35:*:*:*:*:*:*:*", "matchCriteriaId": "F72412E3-8DA9-4CC9-A426-B534202ADBA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.36:*:*:*:*:*:*:*", "matchCriteriaId": "FCAA9D7A-3C3E-4C0B-9D38-EA80E68C2E46"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.37:*:*:*:*:*:*:*", "matchCriteriaId": "4A9E3AE5-3FCF-4CBB-A30B-082BCFBFB0CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.38:*:*:*:*:*:*:*", "matchCriteriaId": "CF715657-4C3A-4392-B85D-1BBF4DE45D89"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.39:*:*:*:*:*:*:*", "matchCriteriaId": "4B63C618-AC3D-4EF7-AFDF-27B9BF482B78"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.40:*:*:*:*:*:*:*", "matchCriteriaId": "C33DA5A9-5E40-4365-9602-82FB4DCD15B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.41:*:*:*:*:*:*:*", "matchCriteriaId": "EFAFDB74-40BD-46FA-89AC-617EB2C7160B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.42:*:*:*:*:*:*:*", "matchCriteriaId": "CF5F17DA-30A7-40CF-BD7C-CEDF06D64617"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.43:*:*:*:*:*:*:*", "matchCriteriaId": "71A276F5-BD9D-4C1B-90DF-9B0C15B6F7DF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.44:*:*:*:*:*:*:*", "matchCriteriaId": "F8F6EBEC-3C29-444B-BB85-6EF239B59EC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.45:*:*:*:*:*:*:*", "matchCriteriaId": "FDB91302-FD18-44CF-A8A8-B31483328539"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.46:*:*:*:*:*:*:*", "matchCriteriaId": "9B81DC2B-46FA-4640-AD6C-2A404D94BA0B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.47:*:*:*:*:*:*:*", "matchCriteriaId": "BA6A1663-BC4C-4FC9-B5EB-A52EDED17B26"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.48:*:*:*:*:*:*:*", "matchCriteriaId": "69C33D6C-6B9F-49F4-B505-E7B589CDEC50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.49:*:*:*:*:*:*:*", "matchCriteriaId": "C464796B-2F31-4159-A132-82A0C74137B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.50:*:*:*:*:*:*:*", "matchCriteriaId": "1D6C6E46-FE29-4D2D-A0EC-43DA5112BCC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.51:*:*:*:*:*:*:*", "matchCriteriaId": "1A370E91-73A1-4D62-8E7B-696B920203F8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.52:*:*:*:*:*:*:*", "matchCriteriaId": "340197CD-9645-4B7E-B976-F3F5A7D4C5BE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.53:*:*:*:*:*:*:*", "matchCriteriaId": "96030636-0C4A-4A10-B768-525D6A0E18CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.54:*:*:*:*:*:*:*", "matchCriteriaId": "A42D8419-914F-4AD6-B0E9-C1290D514FF1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.55:*:*:*:*:*:*:*", "matchCriteriaId": "F4E2C88B-42EA-4F4F-B1F6-A9332EC6888B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.56:*:*:*:*:*:*:*", "matchCriteriaId": "2449D13B-3314-4182-832F-03F6B11AA31F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.57:*:*:*:*:*:*:*", "matchCriteriaId": "9A35B66C-F050-4462-A58E-FEE061B5582E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.58:*:*:*:*:*:*:*", "matchCriteriaId": "1B551164-0167-49BB-A3AE-4034BDA3DCB4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.59:*:*:*:*:*:*:*", "matchCriteriaId": "7244278E-49B6-4405-A14C-F3540C8F5AF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.60:*:*:*:*:*:*:*", "matchCriteriaId": "B4C3E4B8-7274-4ABB-B7CE-6A39C183CE18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.61:*:*:*:*:*:*:*", "matchCriteriaId": "6501EDB9-4847-47F8-90EE-B295626E4CDC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.62:*:*:*:*:*:*:*", "matchCriteriaId": "2D676D48-7521-45E2-8563-6B966FF86A35"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.63:*:*:*:*:*:*:*", "matchCriteriaId": "3B69FA17-0AB9-4986-A5A7-2A4C1DD24222"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.64:*:*:*:*:*:*:*", "matchCriteriaId": "7BC35593-96C7-41F0-B738-1568F8129121"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.65:*:*:*:*:*:*:*", "matchCriteriaId": "38D23794-0E7C-4FA5-A7A8-CF940E3FA962"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.66:*:*:*:*:*:*:*", "matchCriteriaId": "008E1E7D-4C20-4560-9288-EF532ADB0029"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.67:*:*:*:*:*:*:*", "matchCriteriaId": "3B3A7044-A92E-47A9-A7BD-35E5B575F5FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.68:*:*:*:*:*:*:*", "matchCriteriaId": "783E2980-B6AB-489E-B157-B6A2E10A32CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:*:*:*:*:*:*:*", "matchCriteriaId": "3DFFE5A6-6A67-4992-84A3-C0F05FACDEAD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc1:*:*:*:*:*:*", "matchCriteriaId": "13BBD2A3-AE10-48B9-8776-4FB1CAC37D44"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc2:*:*:*:*:*:*", "matchCriteriaId": "B25680CC-8918-4F27-8D7E-A6579215450B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc3:*:*:*:*:*:*", "matchCriteriaId": "92C48B4C-410C-4BA8-A28A-B2E928320FCC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc4:*:*:*:*:*:*", "matchCriteriaId": "CB447523-855B-461E-8197-95169BE86EB0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "B155BBDF-6DF6-4FF5-9C41-D8A5266DCC67"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "28476DEC-9630-4B40-9D4D-9BC151DC4CA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "5646880A-2355-4BDD-89E7-825863A0311F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "7FF99148-267A-46F8-9927-A9082269BAF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "A783C083-5D9C-48F9-B5A6-A97A9604FB19"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "2B817A24-03AC-46CD-BEFA-505457FD2A5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "51CF1BCE-090E-4B70-BA16-ACB74411293B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "187AAD67-10D7-4B57-B4C6-00443E246AF3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "F341CE88-C5BC-4CDD-9CB5-B6BAD7152E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.10:*:*:*:*:*:*:*", "matchCriteriaId": "37ACE2A6-C229-4236-8E9F-235F008F3AA0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "D3220B70-917F-4F9F-8A3B-2BF581281E8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc2:*:*:*:*:*:*", "matchCriteriaId": "99372D07-C06A-41FA-9843-6D57F99AB5AF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc3:*:*:*:*:*:*", "matchCriteriaId": "2B9DC110-D260-4DB4-B8B0-EF1D160ADA07"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc4:*:*:*:*:*:*", "matchCriteriaId": "6192FE84-4D53-40D4-AF61-78CE7136141A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc5:*:*:*:*:*:*", "matchCriteriaId": "42FEF3CF-1302-45EB-89CC-3786FE4BAC1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc6:*:*:*:*:*:*", "matchCriteriaId": "AE6A6B58-2C89-4DE4-BA57-78100818095C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc7:*:*:*:*:*:*", "matchCriteriaId": "1D467F87-2F13-4D26-9A93-E0BA526FEA24"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "FE348F7B-02DE-47D5-8011-F83DA9426021"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "E91594EA-F0A3-41B3-A9C6-F7864FC2F229"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "9E1ECCDB-0208-48F6-B44F-16CC0ECE3503"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "FBA8B5DE-372E-47E0-A0F6-BE286D509CC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "9A1CA083-2CF8-45AE-9E15-1AA3A8352E3B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "19D69A49-5290-4C5F-8157-719AD58D253D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "290BD969-42E7-47B0-B21B-06DE4865432C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "23A9E29E-DE78-4C73-9FBD-C2410F5FC8B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.9:*:*:*:*:*:*:*", "matchCriteriaId": "018434C9-E75F-45CB-A169-DAB4B1D864D7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.10:*:*:*:*:*:*:*", "matchCriteriaId": "DC0AC68F-EC58-4C4F-8CBC-A59ECC00CCDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.11:*:*:*:*:*:*:*", "matchCriteriaId": "C123C844-F6D7-471E-A62E-F756042FB1CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.12:*:*:*:*:*:*:*", "matchCriteriaId": "A11C38BB-7FA2-49B0-AAC9-83DB387A06DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.13:*:*:*:*:*:*:*", "matchCriteriaId": "61F3733C-E5F6-4855-B471-DF3FB823613B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.14:*:*:*:*:*:*:*", "matchCriteriaId": "1DDCA75F-9A06-4457-9A45-38A38E7F7086"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.15:*:*:*:*:*:*:*", "matchCriteriaId": "7AEA837E-7864-4003-8DB7-111ED710A7E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.16:*:*:*:*:*:*:*", "matchCriteriaId": "B6FE471F-2D1F-4A1D-A197-7E46B75787E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.17:*:*:*:*:*:*:*", "matchCriteriaId": "FDA9E6AB-58DC-4EC5-A25C-11F9D0B38BF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.18:*:*:*:*:*:*:*", "matchCriteriaId": "DC6B8DB3-B05B-41A2-B091-342D66AAE8F5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.19:*:*:*:*:*:*:*", "matchCriteriaId": "958F0FF8-33EF-4A71-A0BD-572C85211DBA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.20:*:*:*:*:*:*:*", "matchCriteriaId": "FBA39F48-B02F-4C48-B304-DA9CCA055244"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.21:*:*:*:*:*:*:*", "matchCriteriaId": "1FF841F3-48A7-41D7-9C45-A8170435A5EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.22:*:*:*:*:*:*:*", "matchCriteriaId": "EF506916-A6DC-4B1E-90E5-959492AF55F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.23:*:*:*:*:*:*:*", "matchCriteriaId": "B3CDAD1F-2C6A-48C0-8FAB-C2659373FA25"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.24:*:*:*:*:*:*:*", "matchCriteriaId": "4FFE4B22-C96A-43D0-B993-F51EDD9C5E0E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.25:*:*:*:*:*:*:*", "matchCriteriaId": "F571CC8B-B212-4553-B463-1DB01D616E8A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.26:*:*:*:*:*:*:*", "matchCriteriaId": "84E3E151-D437-48ED-A529-731EEFF88567"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.27:*:*:*:*:*:*:*", "matchCriteriaId": "E9E3EA3C-CCA5-4433-86E0-3D02C4757A0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.28:*:*:*:*:*:*:*", "matchCriteriaId": "F7AC4F7D-9FA6-4CF1-B2E9-70BF7D4D177C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.29:*:*:*:*:*:*:*", "matchCriteriaId": "3CE3A80D-9648-43CC-8F99-D741ED6552BF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.30:*:*:*:*:*:*:*", "matchCriteriaId": "C8A98C03-A465-41B4-A551-A26FEC7FFD94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:*:*:*:*:*:*:*", "matchCriteriaId": "AFB76697-1C2F-48C0-9B14-517EC053D4B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc1:*:*:*:*:*:*", "matchCriteriaId": "BED88DFD-1DC5-4505-A441-44ECDEF0252D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc2:*:*:*:*:*:*", "matchCriteriaId": "DBFD2ACD-728A-4082-BB6A-A1EF6E58E47D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc3:*:*:*:*:*:*", "matchCriteriaId": "C31B0E51-F62D-4053-B04F-FC4D5BC373D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc4:*:*:*:*:*:*", "matchCriteriaId": "A914303E-1CB6-4AAD-9F5F-DE5433C4E814"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc5:*:*:*:*:*:*", "matchCriteriaId": "203BBA69-90B2-4C5E-8023-C14180742421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc6:*:*:*:*:*:*", "matchCriteriaId": "0DBFAB53-B889-4028-AC0E-7E165B152A18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc7:*:*:*:*:*:*", "matchCriteriaId": "FE409AEC-F677-4DEF-8EB7-2C35809043CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "578EC12B-402F-4AD4-B8F8-C9B2CAB06891"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "877002ED-8097-4BB4-BB88-6FC6306C38B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "76294CE3-D72C-41D5-9E0F-B693D0042699"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "916E97D4-1FAB-42F5-826B-653B1C0909A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "33FD2217-C5D0-48C1-AD74-3527127FEF9C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "2E92971F-B629-4E0A-9A50-8B235F9704B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.7:*:*:*:*:*:*:*", "matchCriteriaId": "EDD3A069-3829-4EE2-9D5A-29459F29D4C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.8:*:*:*:*:*:*:*", "matchCriteriaId": "A4A0964C-CEB2-41D7-A69C-1599B05B6171"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "0F960FA6-F904-4A4E-B483-44C70090E9A1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:*:*", "matchCriteriaId": "261C1B41-C9E0-414F-8368-51C0C0B8AD38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:*:*", "matchCriteriaId": "5CCA261D-2B97-492F-89A0-5F209A804350"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:*:*", "matchCriteriaId": "1B1C0C68-9194-473F-BE5E-EC7F184899FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:*:*", "matchCriteriaId": "D7A6AC9E-BEA6-44B0-B3B3-F0F94E32424A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:*:*", "matchCriteriaId": "16038328-9399-4B85-B777-BA4757D02C9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:*:*", "matchCriteriaId": "16CA2757-FA8D-43D9-96E8-D3C0EB6E1DEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:*:*", "matchCriteriaId": "E8CB5481-5EAE-401E-BD7E-D3095CCA9E94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "A0F36FAC-141D-476D-84C5-A558C199F904"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "51D64824-25F6-4761-BD6A-29038A143744"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "E284C8A1-740F-454D-A774-99CD3A21B594"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "C70D72AE-0CBF-4324-9935-57E28EC6279C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "F674B06B-7E86-4E41-9126-8152D0DDABAE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "7039B3EC-8B22-413E-B582-B4BEC6181241"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "35CF1DD2-80B9-4476-8963-5C3EF52B33F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "BFB0B05B-A5CE-4B9C-AE7F-83062868D35B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.9:*:*:*:*:*:*:*", "matchCriteriaId": "D166A66E-7454-47EC-BB56-861A9AFEAFE1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "7DA94F50-2A62-4300-BF4D-A342AAE35629"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.11:*:*:*:*:*:*:*", "matchCriteriaId": "252D937B-50DC-444F-AE73-5FCF6203DF27"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.12:*:*:*:*:*:*:*", "matchCriteriaId": "F6D8EE51-02C1-47BC-A92C-0A8ABEFD28FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.13:*:*:*:*:*:*:*", "matchCriteriaId": "7F20A5D7-3B38-4911-861A-04C8310D5916"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.14:*:*:*:*:*:*:*", "matchCriteriaId": "D472DE3A-71D8-4F40-9DDE-85929A2B047D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.15:*:*:*:*:*:*:*", "matchCriteriaId": "B2AED943-65A8-4FDB-BBD0-CCEF8682A48C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.16:*:*:*:*:*:*:*", "matchCriteriaId": "D4640185-F3D8-4575-A71D-4C889A93DE2C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.17:*:*:*:*:*:*:*", "matchCriteriaId": "144CCF7C-025E-4879-B2E7-ABB8E4390BE5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.18:*:*:*:*:*:*:*", "matchCriteriaId": "B6FAA052-0B2B-40CE-8C98-919B8D08A5ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.19:*:*:*:*:*:*:*", "matchCriteriaId": "4B5A53DE-9C83-4A6B-96F3-23C03BF445D9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.20:*:*:*:*:*:*:*", "matchCriteriaId": "063EB879-CB05-4E33-AA90-9E43516839B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.21:*:*:*:*:*:*:*", "matchCriteriaId": "2D25764F-4B02-4C65-954E-8C7D6632DE00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.22:*:*:*:*:*:*:*", "matchCriteriaId": "F31F5BF3-CD0A-465C-857F-273841BCD28A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.23:*:*:*:*:*:*:*", "matchCriteriaId": "FF302C8A-079B-42B9-B455-CD9083BFA067"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.24:*:*:*:*:*:*:*", "matchCriteriaId": "744999C0-33D3-4363-B3DB-E0D02CDD3918"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.25:*:*:*:*:*:*:*", "matchCriteriaId": "C2E77A76-2A60-45D8-9337-867BC22C5110"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.26:*:*:*:*:*:*:*", "matchCriteriaId": "C9F4AAE7-C870-46B7-B559-2949737BE777"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.27:*:*:*:*:*:*:*", "matchCriteriaId": "20FA2824-20B0-48B8-BB0A-4904C1D3E8AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.28:*:*:*:*:*:*:*", "matchCriteriaId": "9F9B347E-61AC-419F-9701-B862BBFA46F2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.29:*:*:*:*:*:*:*", "matchCriteriaId": "989F351C-8B7C-4C1B-AFA2-AE9431576368"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.30:*:*:*:*:*:*:*", "matchCriteriaId": "8D22172A-9FA7-42E0-8451-165D8E47A573"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.31:*:*:*:*:*:*:*", "matchCriteriaId": "CE31624C-94F9-45D8-9B4A-D0028F10602F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.32:*:*:*:*:*:*:*", "matchCriteriaId": "70967A83-28F6-4568-9ADA-6EF232E5BBC2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "962B0C45-AB29-4383-AC16-C6E8245D0FF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "A0EE126B-74B2-4F79-BFE1-3DC169F3F9B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "392075E0-A9C7-4B4A-90F9-7F1ADFF5EFA7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "ECC66968-06F0-4874-A95A-A292C36E45C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "5FE986E6-1068-4E1B-8EAB-DF1EAF32B4E3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "543E8536-1A8E-4E76-B89F-1B1F9F26FAB8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.7:*:*:*:*:*:*:*", "matchCriteriaId": "EC2B45E3-31E1-4B46-85FA-3A84E75B8F84"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6:*:*:*:*:*:*:*", "matchCriteriaId": "DDB8CC75-D3EE-417C-A83D-CB6D666FE595"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "09A072F1-7BEE-4236-ACBB-55DB8FEF4A03"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "E19D5A58-17D6-4502-A57A-70B2F84817A4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "D58BA035-1204-4DFA-98A1-12111FB6222E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "A17F2E87-8EB8-476A-B5B5-9AE5CF53D9FE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.5:*:*:*:*:*:*:*", "matchCriteriaId": "A8CCC101-5852-4299-9B67-EA1B149D58C0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.6:*:*:*:*:*:*:*", "matchCriteriaId": "B8074D32-C252-4AD3-A579-1C5EDDD7014B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.7:*:*:*:*:*:*:*", "matchCriteriaId": "962AA802-8179-4606-AAC0-9363BAEABC9F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.8:*:*:*:*:*:*:*", "matchCriteriaId": "1286C858-D5A2-45F3-86D1-E50FE53FB23C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.9:*:*:*:*:*:*:*", "matchCriteriaId": "5AC4A13E-F560-4D01-98A3-E2A2B82EB25B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.10:*:*:*:*:*:*:*", "matchCriteriaId": "942C462A-5398-4BB9-A792-598682E1FEF2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.11:*:*:*:*:*:*:*", "matchCriteriaId": "B852F7E0-0282-483D-BB4D-18CB7A4F1392"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7:*:*:*:*:*:*:*", "matchCriteriaId": "53ED9A31-99CC-41C8-8B72-5B2A9B49AA6C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "EFD646BC-62F7-47CF-B0BE-768F701F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F43D418E-87C1-4C83-9FF1-4F45B4F452DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "680D0E00-F29A-487C-8770-8E7EAC672B7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "2DCA96A4-A836-4E94-A39C-3AD3EA1D9611"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "753C05E3-B603-4E36-B9BA-FAEDCBF62A7D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "E385C2E0-B9F1-4564-8E6D-56FD9E762405"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "041335D4-05E1-4004-9381-28AAD5994B47"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "370F2AE5-3DBC-46B9-AC70-F052C9229C00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "7A971BE3-259D-4494-BBC5-12793D92DB57"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.10:*:*:*:*:*:*:*", "matchCriteriaId": "8E4719A6-FDEA-4714-A830-E23A52AE90BC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A6E41FB-38CE-49F2-B796-9A5AA648E73F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "93523FE1-5993-46CB-9299-7C8C1A04E873"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "27ADC356-6BE9-43A3-9E0B-393DC4B1559A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "4F543D23-1774-4D14-A7D1-AD49EDEA94DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "FC323F58-CA00-4C3C-BA4D-CC2C0A6E5F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "FEA0B2E3-668D-40ED-9D3D-709EB6449F8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "3431B258-4EC8-4E7F-87BB-4D934880601E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "1B09FA1E-8B28-4F2A-BA7E-8E1C40365970"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "91917120-9D68-41C0-8B5D-85C256BC6200"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.9:*:*:*:*:*:*:*", "matchCriteriaId": "AAD268A0-096C-4C31-BEC5-D47F5149D462"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.10:*:*:*:*:*:*:*", "matchCriteriaId": "32BD2427-C47F-4660-A1D9-448E500EF5B9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.11:*:*:*:*:*:*:*", "matchCriteriaId": "02048CE5-81C7-4DFB-BC40-CE4C86B7E022"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.12:*:*:*:*:*:*:*", "matchCriteriaId": "934D2B37-0575-4A75-B00B-0028316D6DF0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.13:*:*:*:*:*:*:*", "matchCriteriaId": "06754C21-995C-4850-A4DC-F21826C0F8C5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc1:*:*:*:*:*:*", "matchCriteriaId": "42633FF9-FB0C-4095-B4A1-8D623A98683B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc2:*:*:*:*:*:*", "matchCriteriaId": "08C04619-89A2-4B15-82A2-48BCC662C1F1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc3:*:*:*:*:*:*", "matchCriteriaId": "5B039196-7159-476C-876A-C61242CC41DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc4:*:*:*:*:*:*", "matchCriteriaId": "3A9E0457-53C9-44DD-ACFB-31EE1D1E060E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc5:*:*:*:*:*:*", "matchCriteriaId": "BEE406E7-87BA-44BA-BF61-673E6CC44A2F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc6:*:*:*:*:*:*", "matchCriteriaId": "29FBA173-658F-45DC-8205-934CACD67166"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc7:*:*:*:*:*:*", "matchCriteriaId": "139700F0-BA32-40CF-B9DF-C9C450384FDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "E578085C-3968-4543-BEBA-EE3C3CB4FA02"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "4DCFA441-68FB-4559-A245-FF0B79DE43CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "8C2508D8-6571-4B81-A0D7-E494CCD039CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "8B516926-5E86-4C0A-85F3-F64E1FCDA249"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "069D774D-79BE-479F-BF4E-F021AD808114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "D15B27A9-46E0-4DDF-A00C-29F8F1F18D73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "A381BB4A-28B4-4672-87EE-91B3DDD6C71A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.7:*:*:*:*:*:*:*", "matchCriteriaId": "922F80CF-937D-4FA2-AFF2-6E47FFE9E1E9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "A548ADF4-9E3B-407C-A5ED-05150EB3A185"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.9:*:*:*:*:*:*:*", "matchCriteriaId": "9C623230-4497-41B9-9BD2-7A6CFDD77983"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.10:*:*:*:*:*:*:*", "matchCriteriaId": "C72FA8A6-60A6-4486-A245-7BEF8B2A2711"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=307f2fb95e9b96b3577916e73d92e104f8f26494", "source": "secalert@redhat.com"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-July/112454.html", "source": "secalert@redhat.com"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-July/112619.html", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/07/15/4", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/61166", "source": "secalert@redhat.com"}, {"url": "http://www.securitytracker.com/id/1028780", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=984664", "source": "secalert@redhat.com"}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/85645", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/307f2fb95e9b96b3577916e73d92e104f8f26494", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/307f2fb95e9b96b3577916e73d92e104f8f26494"}}