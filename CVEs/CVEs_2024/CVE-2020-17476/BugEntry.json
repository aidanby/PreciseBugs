{"buggy_code": ["<?php\n/*\n * This file is a part of Mibew Messenger.\n *\n * Copyright 2005-2020 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nuse Mibew\\Asset\\Generator\\UrlGeneratorInterface as AssetUrlGeneratorInterface;\nuse Mibew\\EventDispatcher\\EventDispatcher;\nuse Mibew\\EventDispatcher\\Events;\nuse Mibew\\Settings;\nuse Mibew\\Thread;\nuse Mibew\\Style\\ChatStyle;\nuse Mibew\\Style\\PageStyle;\nuse Mibew\\Routing\\Generator\\SecureUrlGeneratorInterface as UrlGeneratorInterface;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\n/**\n * Convert messages to formatted text\n *\n * @param array $msg message object which most be formatted\n *\n * @return string formatted message\n */\n\nfunction message_to_text($msg)\n{\n    $message_time = date(\"H:i:s \", $msg['created']);\n    if ($msg['kind'] == Thread::KIND_USER || $msg['kind'] == Thread::KIND_AGENT) {\n        if ($msg['name']) {\n            return $message_time . $msg['name'] . \": \" . $msg['message'] . \"\\n\";\n        } else {\n            return $message_time . $msg['message'] . \"\\n\";\n        }\n    } elseif ($msg['kind'] == Thread::KIND_INFO) {\n        return $message_time . $msg['message'] . \"\\n\";\n    } else {\n        return $message_time . \"[\" . $msg['message'] . \"]\\n\";\n    }\n}\n\n/**\n * Sanitize message body and make it a safe HTML string.\n *\n * @param array $msg Message object\n * @return array Message object with sanitized body.\n */\nfunction sanitize_message($msg)\n{\n    $message_body = $msg['message'];\n\n    // Messages entered by user or operator cannot contain any markup\n    if ($msg['kind'] == Thread::KIND_USER || $msg['kind'] == Thread::KIND_AGENT) {\n        $message_body = safe_htmlspecialchars($message_body);\n    }\n\n    $msg['message'] = sanitize_string($message_body, 'low', 'moderate');\n\n    return $msg;\n}\n\n/**\n * Format username\n *\n * @param string $user_name client username\n * @param string $addr ip address of client\n * @param string $id id of client\n *\n * @return string formatted username with \"usernamepattern\" pattern\n */\nfunction get_user_name($user_name, $addr, $id)\n{\n    return str_replace(\n        \"{addr}\",\n        $addr,\n        str_replace(\n            \"{id}\",\n            $id,\n            str_replace(\"{name}\", $user_name, Settings::get('usernamepattern'))\n        )\n    );\n}\n\n/**\n * Prepare logo data\n *\n * @param array $group Group info\n * @return array Array of logo data\n */\nfunction setup_logo($group = null)\n{\n    $data = array();\n    $top_level_group = (!$group) ? array() : get_top_level_group($group);\n\n    $group_name = empty($top_level_group['vctitle'])\n        ? Settings::get('title')\n        : $top_level_group['vctitle'];\n\n    $logo = empty($top_level_group['vclogo'])\n        ? Settings::get('logo')\n        : $top_level_group['vclogo'];\n\n    $mibew_host = empty($top_level_group['vchosturl'])\n        ? Settings::get('hosturl')\n        : $top_level_group['vchosturl'];\n\n    $data['company'] = array(\n        'name' => $group_name,\n        'chatLogoURL' => $logo,\n    );\n    $data['mibewHost'] = $mibew_host;\n\n    return $data;\n}\n\n/**\n * Prepare values common for chat, prechat survey form and leave message form.\n * @return array\n */\nfunction prepare_chat_app_data()\n{\n    $data = array();\n\n    // Set refresh frequency\n    $data['frequency'] = Settings::get('updatefrequency_chat');\n\n    return $data;\n}\n\n/**\n * Prepare data to display leave message form\n *\n * @param string $name User name\n * @param string $email User email\n * @param int $group_id Id of selected group\n * @param string $info User info\n * @param string $referrer URL of referrer page\n * @return array Array of leave message form data\n */\nfunction setup_leavemessage($name, $email, $group_id, $info, $referrer)\n{\n    $data = prepare_chat_app_data();\n\n    // Create some empty arrays\n    $data['leaveMessage'] = array();\n\n    $group = group_by_id($group_id);\n    $group_name = '';\n    if ($group) {\n        $group_name = get_group_name($group);\n    }\n\n    $data['leaveMessage']['leaveMessageForm'] = array(\n        'name' => $name,\n        'email' => $email,\n        'groupId' => $group_id,\n        'groupName' => $group_name,\n        'info' => $info,\n        'referrer' => $referrer,\n        'showCaptcha' => (bool) (Settings::get(\"enablecaptcha\") == \"1\" && can_show_captcha()),\n    );\n\n    $data['page.title'] = (empty($group_name) ? '' : $group_name . ': ')\n        . getlocal('Leave your message');\n    $data['leaveMessage']['page'] = array(\n        'title' => $data['page.title']\n    );\n\n    // Set privacy policy link (if needed)\n    if (Settings::get('enableprivacypolicy')\n         && strcmp('', Settings::get('privacypolicy'))) {\n        $data['leaveMessage']['leaveMessageForm']['privacyPolicyUrl'] = Settings::get('privacypolicy');\n    }\n\n    if (Settings::get('enablegroups') == '1') {\n        $data['leaveMessage']['leaveMessageForm']['groups']\n            = prepare_groups_select($group_id);\n    }\n\n    $data['startFrom'] = 'leaveMessage';\n\n    return $data;\n}\n\n/**\n * Prepare data to display pre-chat survey\n *\n * @param string $name User name\n * @param string $email User email\n * @param int $group_id Id of selected group\n * @param string $info User info\n * @param string $referrer URL of referrer page\n * @return array Array of survey data\n */\nfunction setup_survey($name, $email, $group_id, $info, $referrer)\n{\n    $data = prepare_chat_app_data();\n\n    // Create some empty arrays\n    $data['survey'] = array();\n\n    $data['survey']['surveyForm'] = array(\n        'name' => $name,\n        'groupId' => $group_id,\n        'email' => $email,\n        'info' => $info,\n        'referrer' => $referrer,\n        'showEmail' => (bool) (Settings::get(\"surveyaskmail\") == \"1\"),\n        'showMessage' => (bool) (Settings::get(\"surveyaskmessage\") == \"1\"),\n        'canChangeName' => (bool) (Settings::get('usercanchangename') == \"1\"),\n    );\n\n    $data['page.title'] = getlocal('Live support');\n    $data['survey']['page'] = array(\n        'title' => $data['page.title']\n    );\n\n    // Set privacy policy link (if needed)\n    if (Settings::get('enableprivacypolicy')\n         && strcmp('', Settings::get('privacypolicy'))) {\n        $data['survey']['surveyForm']['privacyPolicyUrl'] = Settings::get('privacypolicy');\n    }\n\n    if (Settings::get('enablegroups') == '1' && Settings::get('surveyaskgroup') == '1') {\n        $data['survey']['surveyForm']['groups']\n            = prepare_groups_select($group_id);\n    }\n\n    $data['startFrom'] = 'survey';\n\n    return $data;\n}\n\n/**\n * Prepare groups list to build group select box.\n *\n * If $group_id specified groups list will consist of group with id equals to\n * $group_id and its children.\n *\n * @param int $group_id Id of selected group\n * @return array|boolean Array of groups info arrays or boolean false if there\n *   are no suitable groups.\n *   Group info array contain following keys:\n *    - 'id': int, group id;\n *    - 'name': string, group name;\n *    - 'description': string, group description;\n *    - 'online': boolean, indicates if group online;\n *    - 'selected': boolean, indicates if group selected by default.\n */\nfunction prepare_groups_select($group_id)\n{\n    $show_groups = ($group_id == '') ? true : group_has_children($group_id);\n\n    if (!$show_groups) {\n        return false;\n    }\n\n    $all_groups = get_groups(false);\n\n    if (empty($all_groups)) {\n        return false;\n    }\n\n    $groups_list = array();\n    $selected_group_id = $group_id;\n\n    foreach ($all_groups as $group) {\n        $group_is_empty = (bool) ($group['inumofagents'] == 0);\n        $group_related_with_specified = empty($group_id)\n            || $group['parent'] == $group_id\n            || $group['groupid'] == $group_id;\n\n        if ($group_is_empty || !$group_related_with_specified) {\n            continue;\n        }\n\n        if (group_is_online($group) && !$selected_group_id) {\n            $selected_group_id = $group['groupid'];\n        }\n\n        $groups_list[] = array(\n            'id' => $group['groupid'],\n            'name' => get_group_name($group),\n            'description' => get_group_description($group),\n            'online' => group_is_online($group),\n            'selected' => (bool) ($group['groupid'] == $selected_group_id),\n        );\n    }\n\n    // One group must be selected by default\n    if (!empty($groups_list)) {\n        // Check if there is selected group\n        $selected_group_present = false;\n        foreach ($groups_list as $group) {\n            if ($group['selected']) {\n                $selected_group_present = true;\n                break;\n            }\n        }\n\n        // If there is no selected group select the first one\n        if (!$selected_group_present) {\n            $groups_list[0]['selected'] = true;\n        }\n    }\n\n    return $groups_list;\n}\n\n/**\n * Prepare some data for chat for both user and operator\n *\n * @param Thread $thread thread object\n * @return array Array of chat view data\n */\nfunction setup_chatview(Thread $thread)\n{\n    $data = prepare_chat_app_data();\n\n    // Get group info\n    if (!empty($thread->groupId)) {\n        $group = group_by_id($thread->groupId);\n        $group = get_top_level_group($group);\n    } else {\n        $group = array();\n    }\n\n    // Create some empty arrays\n    $data['chat'] = array(\n        'messageForm' => array(),\n        'links' => array(),\n        'windowsParams' => array(),\n    );\n\n    // Set thread params\n    $data['chat']['thread'] = array(\n        'id' => $thread->id,\n        'token' => $thread->lastToken,\n        'agentId' => $thread->agentId,\n        'userId' => $thread->userId,\n    );\n\n    $data['page.title'] = empty($group['vcchattitle'])\n        ? Settings::get('chattitle')\n        : $group['vcchattitle'];\n    $data['chat']['page'] = array(\n        'title' => $data['page.title']\n    );\n\n    // Setup logo\n    $data = array_merge_recursive($data, setup_logo($group));\n\n    // Set enter key shortcut\n    if (Settings::get('sendmessagekey') == 'enter') {\n        $data['chat']['messageForm']['ignoreCtrl'] = true;\n    } else {\n        $data['chat']['messageForm']['ignoreCtrl'] = false;\n    }\n\n    // Load dialogs style options\n    $chat_style = new ChatStyle(ChatStyle::getCurrentStyle());\n    $style_config = $chat_style->getConfigurations();\n    $data['chat']['windowsParams']['mail']\n        = $style_config['mail']['window'];\n\n    // Load core style options\n    $page_style = new PageStyle(PageStyle::getCurrentStyle());\n    $style_config = $page_style->getConfigurations();\n    $data['chat']['windowsParams']['history']\n        = $style_config['history']['window'];\n\n    $data['startFrom'] = 'chat';\n\n    return $data;\n}\n\n/**\n * Prepare some data for chat for user\n *\n * @param UrlGeneratorInterface $url_generator A URL generator object.\n * @param AssetUrlGeneratorInterface $asset_url_generator An asset URL generator\n * object.\n * @param Request $request The current request.\n * @param Thread $thread thread object that will be used\n * @return array Array of chat view data\n */\nfunction setup_chatview_for_user(\n    UrlGeneratorInterface $url_generator,\n    AssetUrlGeneratorInterface $asset_url_generator,\n    Request $request,\n    Thread $thread\n) {\n    $data = setup_chatview($thread);\n\n    // Set user info\n    $data['chat']['user'] = array(\n        'name' => htmlspecialchars($thread->userName),\n        'canChangeName' => (bool) (Settings::get('usercanchangename') == \"1\"),\n        'defaultName' => (bool) (getlocal(\"Guest\") != $thread->userName),\n        'canPost' => true,\n        'isAgent' => false,\n    );\n\n    // Set link to send mail page\n    $data['chat']['links']['mail'] = $url_generator->generate(\n        'chat_user_mail',\n        array(\n            'thread_id' => $thread->id,\n            'token' => $thread->lastToken,\n        )\n    );\n\n    // Set SSL link\n    if (Settings::get('enablessl') == \"1\" && $request->isSecure()) {\n        $data['chat']['links']['ssl'] = $url_generator->generateSecure(\n            'chat_user',\n            array(\n                'thread_id' => $thread->id,\n                'token' => $thread->lastToken,\n            ),\n            UrlGeneratorInterface::ABSOLUTE_URL\n        );\n    }\n\n    // Set chat link\n    $data['chat']['links']['chat'] = $url_generator->generate(\n        'chat_user',\n        array(\n            'thread_id' => $thread->id,\n            'token' => $thread->lastToken,\n        ),\n        UrlGeneratorInterface::ABSOLUTE_URL\n    );\n\n    // Set default operator's avatar\n    $operator = operator_by_id($thread->agentId);\n    $data['chat']['avatar'] = $operator['vcavatar']\n        ? $asset_url_generator->generate($operator['vcavatar'])\n        : '';\n\n\n    return $data;\n}\n\n/**\n * Prepare some data for chat for operator\n *\n * @param UrlGeneratorInterface $url_generator A URL generator object.\n * @param Request $request The current request.\n * @param Thread $thread thread object.\n * @param array $operator Operator's data.\n * @return array Array of chat view data\n */\nfunction setup_chatview_for_operator(\n    UrlGeneratorInterface $url_generator,\n    Request $request,\n    Thread $thread,\n    $operator\n) {\n    $data = setup_chatview($thread);\n\n    // Set operator info\n    $data['chat']['user'] = array(\n        'name' => htmlspecialchars(\n            get_user_name(\n                $thread->userName,\n                $thread->remote,\n                $thread->userId\n            )\n        ),\n        'canPost' => (bool) ($thread->agentId == $operator['operatorid']),\n        'isAgent' => true,\n    );\n\n    // Set SSL link\n    if (Settings::get('enablessl') == \"1\" && !$request->isSecure()) {\n        $data['chat']['links']['ssl'] = $url_generator->generateSecure(\n            'chat_operator',\n            array(\n                'thread_id' => $thread->id,\n                'token' => $thread->lastToken,\n            ),\n            UrlGeneratorInterface::ABSOLUTE_URL\n        );\n    }\n\n    // Set chat link\n    $data['chat']['links']['chat'] = $url_generator->generate(\n        'chat_operator',\n        array(\n            'thread_id' => $thread->id,\n            'token' => $thread->lastToken,\n        ),\n        UrlGeneratorInterface::ABSOLUTE_URL\n    );\n\n    // Set history window params\n    $data['chat']['links']['history'] = $url_generator->generate(\n        'history_user',\n        array('user_id' => $thread->userId)\n    );\n\n    // Set tracking params\n    if (Settings::get('enabletracking')) {\n        $visitor = track_get_visitor_by_thread_id($thread->id);\n        $data['chat']['links']['tracked'] = $url_generator->generate(\n            'history_user_track',\n            array('visitor' => $visitor['visitorid'])\n        );\n    }\n\n    // Check if agent can post messages\n    if ($thread->agentId == $operator['operatorid']) {\n        // Get predefined answers\n        $canned_messages = load_canned_messages($thread->locale, 0);\n        if ($thread->groupId) {\n            $canned_messages = array_merge(\n                load_canned_messages($thread->locale, $thread->groupId),\n                $canned_messages\n            );\n        };\n\n        $predefined_answers = array();\n        foreach ($canned_messages as $answer) {\n            $predefined_answers[] = array(\n                'short' => htmlspecialchars(\n                    $answer['vctitle'] ? $answer['vctitle'] : cut_string($answer['vcvalue'], 97, '...')\n                ),\n                'full' => $answer['vcvalue'],\n            );\n        }\n        $data['chat']['messageForm']['predefinedAnswers'] = $predefined_answers;\n    }\n    // Set link to user redirection page\n    $data['chat']['links']['redirect'] = $url_generator->generate(\n        'chat_operator_redirection_links',\n        array(\n            'thread_id' => $thread->id,\n            'token' => $thread->lastToken,\n        )\n    );\n\n    return $data;\n}\n\n/**\n * @return array Return visitor info from active request. contains\n * (user_id string, user_name string)\n */\nfunction visitor_from_request()\n{\n    $default_name = getlocal(\"Guest\");\n    $user_name = $default_name;\n    if (isset($_COOKIE[USERNAME_COOKIE_NAME])) {\n        $data = base64_decode(strtr($_COOKIE[USERNAME_COOKIE_NAME], '-_,', '+/='));\n        if (strlen($data) > 0) {\n            $user_name = $data;\n        }\n    }\n\n    if ($user_name == $default_name) {\n        $temp = Request::createFromGlobals()->query->get('name');\n        $user_name = (isset($temp) && ($temp !== '')) ? $temp : $user_name;\n    }\n\n    if (isset($_COOKIE[USERID_COOKIE_NAME])) {\n        $user_id = $_COOKIE[USERID_COOKIE_NAME];\n    } else {\n        $user_id = uniqid('', true);\n        setcookie(USERID_COOKIE_NAME, $user_id, time() + 60 * 60 * 24 * 365);\n    }\n\n    return array('id' => $user_id, 'name' => $user_name);\n}\n\n/**\n * @return string Return remote host from active request\n */\nfunction get_remote_host()\n{\n    $ext_addr = $_SERVER['REMOTE_ADDR'];\n    $has_proxy = isset($_SERVER['HTTP_X_FORWARDED_FOR'])\n        && $_SERVER['HTTP_X_FORWARDED_FOR'] != $_SERVER['REMOTE_ADDR'];\n    if ($has_proxy) {\n        $ips = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR'], 2);\n        $ext_addr = (count($ips) > 1)\n            ? $ips[0] . ' (' . $_SERVER['HTTP_X_FORWARDED_FOR'] . ')'\n            : $ips[0];\n    }\n\n    return isset($_SERVER['REMOTE_HOST']) ? $_SERVER['REMOTE_HOST'] : $ext_addr;\n}\n\n/**\n * Start chat thread for user\n *\n * @param int $group_id Id of group related to thread\n * @param array $requested_operator Array of requested operator info\n * @param string $visitor_id Id of the visitor\n * @param string $visitor_name Name of the visitor\n * @param string $referrer Page user came from\n * @param string $info User info\n *\n * @return Thread thread object\n */\nfunction chat_start_for_user(\n    $group_id,\n    $requested_operator,\n    $visitor_id,\n    $visitor_name,\n    $referrer,\n    $info\n) {\n    // Get user info\n    $remote_host = get_remote_host();\n    $user_browser = $_SERVER['HTTP_USER_AGENT'];\n\n    // Check connection limit\n    if (Thread::connectionLimitReached($remote_host)) {\n        die(\"number of connections from your IP is exceeded, try again later\");\n    }\n\n    // Check if visitor was invited to chat\n    $is_invited = false;\n    if (Settings::get('enabletracking')) {\n        $invitation_state = invitation_state($_SESSION[SESSION_PREFIX . 'visitorid']);\n        if ($invitation_state['invited']) {\n            $is_invited = true;\n        }\n    }\n\n    // Get info about requested operator\n    $requested_operator_online = false;\n    if ($requested_operator) {\n        $requested_operator_online = is_operator_online(\n            $requested_operator['operatorid']\n        );\n    }\n\n    // Get thread object\n    if ($is_invited) {\n        // Get thread from invitation\n        $thread = invitation_accept($_SESSION[SESSION_PREFIX . 'visitorid']);\n        if (!$thread) {\n            die(\"Cannot start thread\");\n        }\n    } else {\n        // Create thread\n        $thread = new Thread();\n        $thread->state = Thread::STATE_LOADING;\n        $thread->agentId = 0;\n        if ($requested_operator && $requested_operator_online) {\n            $thread->nextAgent = $requested_operator['operatorid'];\n        }\n    }\n\n    // Update thread fields\n    $thread->groupId = $group_id;\n    $thread->userName = $visitor_name;\n    $thread->remote = $remote_host;\n    $thread->referer = $referrer;\n    $thread->locale = get_current_locale();\n    $thread->userId = $visitor_id;\n    $thread->userAgent = $user_browser;\n    $thread->save();\n\n    $_SESSION[SESSION_PREFIX . 'threadid'] = $thread->id;\n\n    // Store own thread ids to restrict access for other people\n    if (!isset($_SESSION[SESSION_PREFIX . 'own_threads'])) {\n        $_SESSION[SESSION_PREFIX . 'own_threads'] = array();\n    }\n    $_SESSION[SESSION_PREFIX . 'own_threads'][] = $thread->id;\n\n    // Bind thread to the visitor\n    if (Settings::get('enabletracking')) {\n        track_visitor_bind_thread($visitor_id, $thread);\n    }\n\n    // Send several messages\n    if ($is_invited) {\n        $operator = operator_by_id($thread->agentId);\n        $operator_name = get_operator_name($operator);\n        $thread->postMessage(\n            Thread::KIND_FOR_AGENT,\n            getlocal(\n                'Visitor accepted invitation from operator {0}',\n                array($operator_name),\n                get_current_locale(),\n                true\n            )\n        );\n    } else {\n        if ($referrer) {\n            $thread->postMessage(\n                Thread::KIND_FOR_AGENT,\n                getlocal('Visitor came from page {0}', array($referrer), get_current_locale(), true)\n            );\n        }\n        if ($requested_operator && !$requested_operator_online) {\n            $thread->postMessage(\n                Thread::KIND_INFO,\n                getlocal(\n                    'Thank you for contacting us. We are sorry, but requested operator <strong>{0}</strong> is offline. Another operator will be with you shortly.',\n                    array(get_operator_name($requested_operator)),\n                    get_current_locale(),\n                    true\n                )\n            );\n        } else {\n            $thread->postMessage(\n                Thread::KIND_INFO,\n                getlocal('Thank you for contacting us. An operator will be with you shortly.', null, get_current_locale(), true)\n            );\n        }\n    }\n\n    // TODO: May be move sending this message somewhere else?\n    if ($info) {\n        $thread->postMessage(\n            Thread::KIND_FOR_AGENT,\n            getlocal('Info: {0}', array($info), get_current_locale(), true)\n        );\n    }\n\n    // Let plugins know that user is ready to chat.\n    $dispatcher = EventDispatcher::getInstance();\n    $event_args = array('thread' => $thread);\n    $dispatcher->triggerEvent(Events::THREAD_USER_IS_READY, $event_args);\n\n    return $thread;\n}\n", "<?php\n/*\n * This file is a part of Mibew Messenger.\n *\n * Copyright 2005-2020 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nnamespace Mibew\\Controller;\n\nuse Mibew\\Settings;\nuse Mibew\\Thread;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\n\n/**\n * Represents button-related actions\n */\nclass ButtonController extends AbstractController\n{\n    /**\n     * Returns content of the chat button.\n     *\n     * @param Request $request\n     * @return string Rendered page content\n     */\n    public function indexAction(Request $request)\n    {\n        $referer = $request->server->get('HTTP_REFERER', '');\n\n        // We need to display message about visited page only if the visitor\n        // really change it.\n        $new_page = empty($_SESSION[SESSION_PREFIX . 'last_visited_page'])\n            || $_SESSION[SESSION_PREFIX . 'last_visited_page'] != $referer;\n\n        // Display message about page change\n        if ($referer && isset($_SESSION[SESSION_PREFIX . 'threadid']) && $new_page) {\n            $thread = Thread::load($_SESSION[SESSION_PREFIX . 'threadid']);\n            if ($thread && $thread->state != Thread::STATE_CLOSED) {\n                $msg = getlocal(\n                    \"Visitor navigated to {0}\",\n                    array($referer),\n                    $thread->locale,\n                    true\n                );\n                $thread->postMessage(Thread::KIND_FOR_AGENT, $msg);\n            }\n        }\n        $_SESSION[SESSION_PREFIX . 'last_visited_page'] = $referer;\n\n        $image = $request->query->get('i', '');\n        if (!preg_match(\"/^\\w+$/\", $image)) {\n            $image = 'mibew';\n        }\n\n        $lang = $request->query->get('lang', '');\n        if (!preg_match(\"/^[\\w-]{2,5}$/\", $lang)) {\n            $lang = '';\n        }\n        if (!$lang || !locale_is_available($lang)) {\n            $lang = get_current_locale();\n        }\n\n        $group_id = $request->query->get('group', '');\n        if (!preg_match(\"/^\\d{1,8}$/\", $group_id)) {\n            $group_id = false;\n        }\n        if ($group_id) {\n            if (Settings::get('enablegroups') == '1') {\n                $group = group_by_id($group_id);\n                if (!$group) {\n                    $group_id = false;\n                }\n            } else {\n                $group_id = false;\n            }\n        }\n\n        // Get image file content\n        $image_postfix = has_online_operators($group_id) ? \"on\" : \"off\";\n        $file_name = \"locales/${lang}/button/${image}_${image_postfix}.png\";\n        $content_type = 'image/png';\n        if (!is_readable($file_name)) {\n            // Fall back to .gif image\n            $file_name = \"locales/${lang}/button/${image}_${image_postfix}.gif\";\n            $content_type = 'image/gif';\n        }\n\n        $fh = fopen($file_name, 'rb');\n        if ($fh) {\n            // Create response with image in body\n            $file_size = filesize($file_name);\n            $content = fread($fh, $file_size);\n            fclose($fh);\n            $response = new Response($content, 200);\n\n            // Set correct content info\n            $response->headers->set('Content-Type', $content_type);\n            $response->headers->set('Content-Length', $file_size);\n        } else {\n            $response = new Response('Not found', 404);\n        }\n\n        // Disable caching\n        $response->headers->addCacheControlDirective('no-cache', true);\n        $response->headers->addCacheControlDirective('no-store', true);\n        $response->headers->addCacheControlDirective('must-revalidate', true);\n        $response->setExpires(new \\DateTime('yesterday noon'));\n        $response->headers->set('Pragma', 'no-cache');\n\n        return $response;\n    }\n}\n", "<?php\n/*\n * This file is a part of Mibew Messenger.\n *\n * Copyright 2005-2020 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nnamespace Mibew\\Controller\\Chat;\n\nuse Mibew\\Database;\nuse Mibew\\Http\\Exception\\BadRequestException;\nuse Mibew\\Http\\Exception\\NotFoundException;\nuse Mibew\\Thread;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\n/**\n * Contains all actions which are related with operator's chat redirect logic.\n */\nclass RedirectController extends AbstractController\n{\n    /**\n     * Renders a page with redirections links.\n     *\n     * @param Request $request Incoming request.\n     * @return string|\\Symfony\\Component\\HttpFoundation\\RedirectResponse Rendered\n     *   page content or a redirect response.\n     * @throws NotFoundException If the thread with specified ID and token is\n     * not found.\n     */\n    public function showRedirectionLinksAction(Request $request)\n    {\n        // Check if we should force the user to use SSL\n        $ssl_redirect = $this->sslRedirect($request);\n        if ($ssl_redirect !== false) {\n            return $ssl_redirect;\n        }\n\n        $operator = $this->getOperator();\n        $thread_id = $request->attributes->get('thread_id');\n        $token = $request->attributes->get('token');\n\n        $thread = Thread::load($thread_id, $token);\n        if (!$thread) {\n            throw new NotFoundException('The thread is not found.');\n        }\n\n        if ($thread->agentId != $operator['operatorid']) {\n            $page = array('errors' => array('Can redirect only own threads.'));\n\n            return $this->render('error', $page);\n        }\n\n        $page = array_merge_recursive(\n            setup_chatview_for_operator(\n                $this->getRouter(),\n                $request,\n                $thread,\n                $operator\n            ),\n            setup_redirect_links(\n                $this->getRouter(),\n                $thread_id,\n                $operator,\n                $token\n            )\n        );\n\n        // Render the page with redirection links.\n        return $this->render('redirect', $page);\n    }\n\n    /**\n     * Process chat thread redirection.\n     *\n     * @param Request $request Incoming request.\n     * @return string|\\Symfony\\Component\\HttpFoundation\\RedirectResponse Rendered\n     *   page content or a redirect response.\n     * @throws NotFoundException If the thread with specified ID and token is\n     * not found.\n     * @throws BadRequestException If one or more arguments have a wrong format.\n     */\n    public function redirectAction(Request $request)\n    {\n        $thread_id = $request->attributes->get('thread_id');\n        $token = $request->attributes->get('token');\n\n        $thread = Thread::load($thread_id, $token);\n        if (!$thread) {\n            throw new NotFoundException('The thread is not found.');\n        }\n\n        $page = array(\n            'errors' => array(),\n        );\n\n        if ($request->query->has('nextGroup')) {\n            // The thread was redirected to a group.\n            $next_id = $request->query->get('nextGroup');\n            if (!preg_match(\"/^\\d{1,10}$/\", $next_id)) {\n                throw new BadRequestException('Wrong value of \"nextGroup\" argument.');\n            }\n            $next_group = group_by_id($next_id);\n\n            if ($next_group) {\n                $page['message'] = getlocal(\n                    'The visitor has been placed in a priorty queue of the group {0}.',\n                    array(get_group_name($next_group))\n                );\n                if (!$this->redirectToGroup($thread, (int)$next_id)) {\n                    $page['errors'][] = getlocal('You are not chatting with the visitor.');\n                }\n            } else {\n                $page['errors'][] = 'Unknown group';\n            }\n        } else {\n            // The thread was redirected to an operator.\n            $next_id = $request->query->get('nextAgent');\n            if (!preg_match(\"/^\\d{1,10}$/\", $next_id)) {\n                throw new BadRequestException('Wrong value of \"nextAgent\" argument.');\n            }\n            $next_operator = operator_by_id($next_id);\n\n            if ($next_operator) {\n                $page['message'] = getlocal(\n                    'The visitor has been placed in the priorty queue of the operator {0}.',\n                    array(get_operator_name($next_operator))\n                );\n                if (!$this->redirectToOperator($thread, $next_id)) {\n                    $page['errors'][] = getlocal('You are not chatting with the visitor.');\n                }\n            } else {\n                $page['errors'][] = 'Unknown operator';\n            }\n        }\n\n        $page = array_merge_recursive($page, setup_logo());\n\n        if (count($page['errors']) > 0) {\n            return $this->render('error', $page);\n        } else {\n            return $this->render('redirected', $page);\n        }\n    }\n\n    /**\n     * Redirects a chat thread to the group with the specified ID.\n     *\n     * @param \\Mibew\\Thread $thread Chat thread to redirect.\n     * @param int $group_id ID of the target group.\n     * @return boolean True if the thread was redirected and false on failure.\n     */\n    protected function redirectToGroup(Thread $thread, $group_id)\n    {\n        if ($thread->state != Thread::STATE_CHATTING) {\n            // We can redirect only threads which are in proggress now.\n            return false;\n        }\n\n        // Redirect the thread\n        $thread->state = Thread::STATE_WAITING;\n        $thread->nextAgent = 0;\n        $thread->groupId = $group_id;\n        $thread->agentId = 0;\n        $thread->agentName = '';\n        $thread->save();\n\n        // Send notification message\n        $thread->postMessage(\n            Thread::KIND_EVENTS,\n            getlocal(\n                'Operator {0} redirected you to another operator. Please wait a while.',\n                array(get_operator_name($this->getOperator())),\n                $thread->locale,\n                true\n            )\n        );\n\n        return true;\n    }\n\n    /**\n     * Redirects a chat thread to the operator with the specified ID.\n     *\n     * @param \\Mibew\\Thread $thread Chat thread to redirect.\n     * @param int $group_id ID of the target operator.\n     * @return boolean True if the thread was redirected and false on failure.\n     */\n    protected function redirectToOperator(Thread $thread, $operator_id)\n    {\n        if ($thread->state != Thread::STATE_CHATTING) {\n            // We can redirect only threads which are in proggress now.\n            return false;\n        }\n\n        // Redirect the thread\n        $thread->state = Thread::STATE_WAITING;\n        $thread->nextAgent = $operator_id;\n        $thread->agentId = 0;\n\n        // Check if the target operator belongs to the current thread's group.\n        // If not reset the current thread's group.\n        if ($thread->groupId != 0) {\n            $db = Database::getInstance();\n            list($groups_count) = $db->query(\n                (\"SELECT count(*) AS count \"\n                    . \"FROM {operatortoopgroup} \"\n                    . \"WHERE operatorid = ? AND groupid = ?\"),\n                array($operator_id, $thread->groupId),\n                array(\n                    'return_rows' => Database::RETURN_ONE_ROW,\n                    'fetch_type' => Database::FETCH_NUM,\n                )\n            );\n            if ($groups_count === 0) {\n                $thread->groupId = 0;\n            }\n        }\n\n        $thread->save();\n\n        // Send notification message\n        $thread->postMessage(\n            Thread::KIND_EVENTS,\n            getlocal(\n                'Operator {0} redirected you to another operator. Please wait a while.',\n                array(get_operator_name($this->getOperator())),\n                $thread->locale,\n                true\n            )\n        );\n\n        return true;\n    }\n}\n", "<?php\n/*\n * This file is a part of Mibew Messenger.\n *\n * Copyright 2005-2020 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nnamespace Mibew\\RequestProcessor;\n\n// Import namespaces and classes of the core\nuse Mibew\\Asset\\AssetManagerAwareInterface;\nuse Mibew\\Asset\\AssetManagerInterface;\nuse Mibew\\Authentication\\AuthenticationManagerAwareInterface;\nuse Mibew\\Authentication\\AuthenticationManagerInterface;\nuse Mibew\\Http\\Exception\\AccessDeniedException;\nuse Mibew\\Mail\\MailerFactoryAwareInterface;\nuse Mibew\\Mail\\MailerFactoryInterface;\nuse Mibew\\Mail\\Template as MailTemplate;\nuse Mibew\\Mail\\Utils as MailUtils;\nuse Mibew\\Settings;\nuse Mibew\\Thread;\nuse Mibew\\API\\API as MibewAPI;\nuse Mibew\\RequestProcessor\\Exception\\ThreadProcessorException;\nuse Mibew\\Routing\\RouterAwareInterface;\nuse Mibew\\Routing\\RouterInterface;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\n/**\n * Incapsulates thread api and thread processing functions.\n *\n * Event triggered by the class (see description of the RequestProcessor class\n * for details):\n *  - threadRequestReceived\n *  - threadReceiveRequestError\n *  - threadCallError\n *  - threadFunctionCall\n *\n * WARNING:\n *  threadResponseReceived registered but never called because of asynchronous\n *  nature of Core-to-Window interaction\n *\n * @todo Move all API functions to another place.\n */\nclass ThreadProcessor extends ClientSideProcessor implements\n    RouterAwareInterface,\n    AssetManagerAwareInterface,\n    AuthenticationManagerAwareInterface,\n    MailerFactoryAwareInterface\n{\n    /**\n     * @var AuthenticationManagerInterface|null\n     */\n    protected $authenticationManager = null;\n\n    /**\n     * The request which is hadled now.\n     *\n     * @var Request|null\n     */\n    protected $currentRequest = null;\n\n    /**\n     * A Router instance.\n     *\n     * @var RouterInterface|null\n     */\n    protected $router = null;\n\n    /**\n     * @var MailerFactoryInterface|null\n     */\n    protected $mailerFactory = null;\n\n    /**\n     * An instance of asset manager.\n     *\n     * @var AssetManagerInterface|null\n     */\n    protected $assetManager = null;\n\n    /**\n     * Loads thread by id and token and checks if thread loaded\n     *\n     * @param int $thread_id Id of the thread\n     * @param int $last_token Last token of the thread\n     * @return \\Mibew\\Thread\n     * @throws \\Mibew\\RequestProcessor\\ThreadProcessorException\n     */\n    public static function getThread($thread_id, $last_token)\n    {\n        // Load thread\n        $thread = Thread::load($thread_id, $last_token);\n        // Check thread\n        if (!$thread) {\n            throw new ThreadProcessorException(\n                'Wrong thread',\n                ThreadProcessorException::ERROR_WRONG_THREAD\n            );\n        }\n\n        // Return thread\n        return $thread;\n    }\n\n    /**\n     * Check if arguments exists in $args array\n     *\n     * @param array $args Arguments array\n     * @param array $vars Array of arguments names that must be checked\n     * @throws \\Mibew\\RequestProcessor\\ThreadProcessorException\n     */\n    public static function checkParams($args, $vars)\n    {\n        if (empty($vars)) {\n            return;\n        }\n        // Check variables exists\n        foreach ($vars as $var) {\n            if (!array_key_exists($var, $args)) {\n                throw new ThreadProcessorException(\n                    \"There is no '{$var}' variable in arguments list\",\n                    ThreadProcessorException::ERROR_WRONG_ARGUMENTS\n                );\n            }\n        }\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function handleRequest($request)\n    {\n        $this->currentRequest = $request;\n        $response = parent::handleRequest($request);\n        $this->currentRequest = null;\n\n        return $response;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getRouter()\n    {\n        return $this->router;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function setRouter(RouterInterface $router)\n    {\n        $this->router = $router;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function setAuthenticationManager(AuthenticationManagerInterface $manager)\n    {\n        $this->authenticationManager = $manager;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getAuthenticationManager()\n    {\n        return $this->authenticationManager;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function setMailerFactory(MailerFactoryInterface $factory)\n    {\n        $this->mailerFactory = $factory;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getMailerFactory()\n    {\n        return $this->mailerFactory;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getAssetManager()\n    {\n        return $this->assetManager;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function setAssetManager(AssetManagerInterface $manager)\n    {\n        $this->assetManager = $manager;\n    }\n\n    /**\n     * Class constructor\n     */\n    protected function __construct()\n    {\n        parent::__construct(array(\n            'signature' => '',\n            'trusted_signatures' => array(''),\n            'event_prefix' => 'thread',\n        ));\n    }\n\n    /**\n     * Creates and returns an instance of the \\Mibew\\API\\API class.\n     *\n     * @return \\Mibew\\API\\API\n     */\n    protected function getMibewAPIInstance()\n    {\n        return MibewAPI::getAPI('\\\\Mibew\\\\API\\\\Interaction\\\\ChatInteraction');\n    }\n\n    /**\n     * Check if operator logged in\n     *\n     * @return array Operators info array\n     * @throws \\Mibew\\RequestProcessor\\ThreadProcessorException If operator is\n     *   not logged in.\n     */\n    protected function checkOperator()\n    {\n        $operator = $this->getAuthenticationManager()->getOperator();\n        if (!$operator) {\n            throw new ThreadProcessorException(\n                \"Operator is not logged in!\",\n                ThreadProcessorException::ERROR_AGENT_NOT_LOGGED_IN\n            );\n        }\n\n        return $operator;\n    }\n\n    /**\n     * Sends asynchronous request\n     *\n     * @param array $request The 'request' array. See Mibew API for details\n     * @return boolean true on success or false on failure\n     */\n    protected function sendAsyncRequest($request)\n    {\n        // Define empty thread id and thread token\n        $thread_id = null;\n        $token = null;\n        $recipient = null;\n        foreach ($request['functions'] as $function) {\n            // Save thread id and thread token from first function in package\n            if (is_null($thread_id)) {\n                $thread_id = $function['arguments']['threadId'];\n                $token = $function['arguments']['token'];\n                $recipient = $function['arguments']['recipient'];\n                continue;\n            }\n            // Check thread id and thread token for the remaining functions\n            $wrong_thread_id = $thread_id != $function['arguments']['threadId'];\n            $wrong_token = $token != $function['arguments']['token'];\n            if ($wrong_thread_id || $wrong_token) {\n                throw new ThreadProcessorException(\n                    'Various thread id or thread token in different functions in one package!',\n                    ThreadProcessorException::VARIOUS_THREAD_ID\n                );\n            }\n            // Check request recipient\n            if ($recipient !== $function['arguments']['recipient']) {\n                throw new ThreadProcessorException(\n                    'Various recipient in different functions in one package!',\n                    ThreadProcessorException::VARIOUS_RECIPIENT\n                );\n            }\n        }\n        // Store request in buffer\n        if ($recipient == 'agent' || $recipient == 'both') {\n            $this->addRequestToBuffer('thread_agent_' . $thread_id, $request);\n        }\n        if ($recipient == 'user' || $recipient == 'both') {\n            $this->addRequestToBuffer('thread_user_' . $thread_id, $request);\n        }\n\n        return true;\n    }\n\n    /**\n     * Additional validation for functions that called via call method\n     *\n     * @param Array $function A Function array\n     */\n    protected function checkFunction($function)\n    {\n        // Check recipient argument existence\n        if (!array_key_exists('recipient', $function['arguments'])) {\n            throw new ThreadProcessorException(\n                \"'recipient' argument is not set in function '{$function['function']}'!\",\n                ThreadProcessorException::EMPTY_RECIPIENT\n            );\n        }\n        $recipient = $function['arguments']['recipient'];\n        // Check recipient value\n        if ($recipient != 'agent' && $recipient != 'both' && $recipient != 'user') {\n            throw new ThreadProcessorException(\n                \"Wrong recipient value '{$recipient}'! It should be one of 'agent', 'user', 'both'\",\n                ThreadProcessorException::WRONG_RECIPIENT_VALUE\n            );\n        }\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function processFunction($function, \\Mibew\\API\\ExecutionContext &$context)\n    {\n        // Check if a function can be called. Operators can call anythig, thus\n        // we should continue validation only for users.\n        if (!$this->getAuthenticationManager()->getOperator()) {\n            // A function is called by a user. We need to check that the thread\n            // is related with the user.\n            $arguments = $context->getArgumentsList($function);\n            $thread_id = $arguments['threadId'];\n            // As defined in Mibew\\API\\Interaction\\ChatInteraction \"threadid\"\n            // argument is mandatory, but some function allows it to be null. In\n            // such cases there is no thread and there is nothing to check.\n            if (!is_null($thread_id)) {\n                $is_own_thread = isset($_SESSION[SESSION_PREFIX . 'own_threads'])\n                    && in_array($thread_id, $_SESSION[SESSION_PREFIX . 'own_threads']);\n                if (!$is_own_thread) {\n                    throw new AccessDeniedException();\n                }\n            }\n        }\n\n        // The function can be called. Process it.\n        parent::processFunction($function, $context);\n    }\n\n    /**\n     * Update chat window state. API function\n     *\n     * Call periodically by chat window\n     * @param array $args Associative array of arguments. It must contains\n     *   following keys:\n     *    - 'threadId': Id of the thread related to chat window\n     *    - 'token': last thread token\n     *    - 'user': TRUE if window used by user and FALSE otherwise\n     *    - 'typed': indicates if user(or agent) typed\n     *    - 'lastId': id of the last sent to message\n     * @return array Array of results. It contains following keys:\n     *    - 'typing': indicates if another side of the conversation is typing\n     *      message\n     *    - 'canPost': indicates if agent(user can post message all the time)\n     *      can post the message\n     *    - 'threadState': current state of the thread. See Thread::STATE_*\n     *      constants for details.\n     *    - 'threadAgentId': ID of the agent that is currently related with the\n     *      thread.\n     */\n    protected function apiUpdate($args)\n    {\n        // Load thread\n        $thread = self::getThread($args['threadId'], $args['token']);\n\n        // Check variables\n        self::checkParams($args, array('user', 'typed'));\n\n        if (!$args['user']) {\n            $operator = $this->checkOperator();\n            $thread->checkForReassign($operator);\n        }\n\n        $thread->ping($args['user'], $args['typed']);\n\n        // Create requests key\n        $requests_key = false;\n        if ($args['user']) {\n            $requests_key = 'thread_user_' . $thread->id;\n        } else {\n            if ($operator['operatorid'] == $thread->agentId) {\n                $requests_key = 'thread_agent_' . $thread->id;\n            }\n        }\n\n        // Load stored requests\n        if ($requests_key !== false) {\n            $stored_requests = $this->getRequestsFromBuffer($requests_key);\n            if ($stored_requests !== false) {\n                $this->responses = array_merge($this->responses, $stored_requests);\n            }\n        }\n\n        // Get status values\n        if ($args['user']) {\n            $is_typing = abs($thread->lastPingAgent - time()) < Settings::get('connection_timeout')\n                && $thread->agentTyping;\n            // Users can post messages only when thread is open.\n            $can_post = $thread->state != Thread::STATE_CLOSED;\n        } else {\n            $is_typing = abs($thread->lastPingUser - time()) < Settings::get('connection_timeout')\n                && $thread->userTyping;\n            // Operators can post messages only to own threads.\n            $can_post = ($operator['operatorid'] == $thread->agentId);\n        }\n\n        return array(\n            'threadState' => $thread->state,\n            'threadAgentId' => $thread->agentId,\n            'typing' => $is_typing,\n            'canPost' => $can_post,\n        );\n    }\n\n    /**\n     * Send new messages to window. API function\n     *\n     * @param array $args Associative array of arguments. It must contains the\n     *   following keys:\n     *    - 'threadId': Id of the thread related to chat window\n     *    - 'token': last thread token\n     *    - 'user': TRUE if window used by user and FALSE otherwise\n     *    - 'lastId': last sent message id\n     */\n    protected function apiUpdateMessages($args)\n    {\n        // Load thread\n        $thread = self::getThread($args['threadId'], $args['token']);\n\n        // Check variables\n        self::checkParams($args, array('user', 'lastId'));\n\n        // Check access\n        if (!$args['user']) {\n            $this->checkOperator();\n        }\n\n        // Send new messages\n        $last_message_id = $args['lastId'];\n        $messages = array_map(\n            'sanitize_message',\n            $thread->getMessages($args['user'], $last_message_id)\n        );\n\n        return array(\n            'messages' => $messages,\n            'lastId' => $last_message_id,\n        );\n    }\n\n    /**\n     * Post message to thread. API function\n     *\n     * @param array $args Associative array of arguments. It must contains the\n     *   following keys:\n     *    - 'threadId': Id of the thread related to chat window\n     *    - 'token': last thread token\n     *    - 'user': TRUE if window used by user and FALSE otherwise\n     *    - 'message': posted message\n     * @throws ThreadProcessorException\n     */\n    protected function apiPost($args)\n    {\n        // Load thread\n        $thread = self::getThread($args['threadId'], $args['token']);\n\n        // Check variables\n        self::checkParams($args, array('user', 'message'));\n\n        // Get operator's array\n        if (!$args['user']) {\n            $operator = $this->checkOperator();\n            // Operators can post messages only to own threads.\n            $can_post = ($operator['operatorid'] == $thread->agentId);\n        } else {\n            // Users can post messages only when a thread is open.\n            $can_post = $thread->state != Thread::STATE_CLOSED;\n        }\n\n        if (!$can_post) {\n            throw new ThreadProcessorException(\n                \"Cannot send\",\n                ThreadProcessorException::ERROR_CANNOT_SEND\n            );\n        }\n\n        // Set fields\n        $kind = $args['user'] ? Thread::KIND_USER : Thread::KIND_AGENT;\n        if ($args['user']) {\n            $msg_options = array('name' => $thread->userName);\n        } else {\n            $msg_options = array(\n                'name' => $thread->agentName,\n                'operator_id' => $operator['operatorid'],\n            );\n        }\n\n        // Post message\n        $posted_id = $thread->postMessage($kind, $args['message'], $msg_options);\n\n        // Update shownMessageId\n        if ($args['user'] && $thread->shownMessageId == 0) {\n            $thread->shownMessageId = $posted_id;\n            $thread->save();\n        }\n    }\n\n    /**\n     * Rename user in the chat. API function\n     *\n     * @param array $args Associative array of arguments. It must contains the\n     *   following keys:\n     *    - 'threadId': Id of the thread related to chat window\n     *    - 'token': last thread token\n     *    - 'name': new user name\n     * @throws \\Mibew\\RequestProcessor\\ThreadProcessorException\n     */\n    protected function apiRename($args)\n    {\n        // Check rename possibility\n        if (Settings::get('usercanchangename') != \"1\") {\n            throw new ThreadProcessorException(\n                'server: forbidden to change name',\n                ThreadProcessorException::ERROR_FORBIDDEN_RENAME\n            );\n        }\n\n        // Load thread\n        $thread = self::getThread($args['threadId'], $args['token']);\n\n        // Check if new name exists\n        self::checkParams($args, array('name'));\n\n        //Rename user\n        $thread->renameUser($args['name']);\n        // Update user name in cookies\n        $data = strtr(base64_encode($args['name']), '+/=', '-_,');\n        setcookie(USERNAME_COOKIE_NAME, $data, time() + 60 * 60 * 24 * 365);\n    }\n\n    /**\n     * Close chat thread. API function\n     *\n     * @param array $args Associative array of arguments. It must contains the\n     *   following keys:\n     *    - 'threadId': Id of the thread related to chat window\n     *    - 'token': last thread token\n     *    - 'user': TRUE if window used by user and FALSE otherwise\n     * @return array Array of results. It contains following keys:\n     *    - 'closed': indicates if thread can be closed\n     */\n    protected function apiClose($args)\n    {\n        // Load thread and check thread's last token\n        $thread = self::getThread($args['threadId'], $args['token']);\n\n        // Check if new user variable exists\n        self::checkParams($args, array('user'));\n\n        // Load operator\n        if (!$args['user']) {\n            $operator = $this->checkOperator();\n        }\n\n        // Close thread\n        if ($args['user'] || $thread->agentId == $operator['operatorid']) {\n            $thread->close($args['user']);\n        }\n\n        return array(\n            'closed' => true,\n        );\n    }\n\n    /**\n     * Process submitted prechat survey.\n     *\n     * @param array $args Associative array of arguments. It must contains the\n     *   following keys:\n     *    - 'threadId': for this function this param equals to null;\n     *    - 'token': for this function this param equals to null;\n     *    - 'name': string, user name;\n     *    - 'email': string, user email;\n     *    - 'message': string, first user message;\n     *    - 'info': string, some info about user;\n     *    - 'referrer': page user came from;\n     *    - 'groupId': selected group id.\n     * @return array Array of results. It contains following keys:\n     *    - 'next': string, indicates what module run next;\n     *    - 'options': options array for next module.\n     */\n    protected function apiProcessSurvey($args)\n    {\n        $visitor = visitor_from_request();\n\n        // Get form values\n        $first_message = $args['message'];\n        $info = $args['info'];\n        $email = $args['email'];\n        $referrer = $args['referrer'];\n\n        // Verify group id\n        $group_id = 0;\n        $group = null;\n        if (Settings::get('enablegroups') == '1') {\n            if (preg_match(\"/^\\d{1,8}$/\", $args['groupId']) != 0) {\n                $group = group_by_id($args['groupId']);\n                if ($group) {\n                    $group_id = (int)$args['groupId'];\n                }\n            }\n        }\n\n        if (Settings::get('usercanchangename') == \"1\" && !empty($args['name'])) {\n            $newname = $args['name'];\n            if ($newname != $visitor['name']) {\n                $data = strtr(base64_encode($newname), '+/=', '-_,');\n                setcookie(USERNAME_COOKIE_NAME, $data, time() + 60 * 60 * 24 * 365);\n                $visitor['name'] = $newname;\n            }\n        }\n\n        // Check if there are online operators\n        if (!has_online_operators($group_id)) {\n            // Display leave message page\n            $client_data = setup_leavemessage(\n                $visitor['name'],\n                $email,\n                $group_id,\n                $info,\n                $referrer\n            );\n            $options = $client_data['leaveMessage'];\n            $options['page'] += setup_logo($group);\n\n            return array(\n                'next' => 'leaveMessage',\n                'options' => $options,\n            );\n        }\n\n        // Initialize dialog\n        $thread = chat_start_for_user(\n            $group_id,\n            false,\n            $visitor['id'],\n            $visitor['name'],\n            $referrer,\n            $info\n        );\n\n        // Send some messages\n        if ($email) {\n            $thread->postMessage(\n                Thread::KIND_FOR_AGENT,\n                getlocal('E-Mail: {0}', array($email), get_current_locale(), true)\n            );\n        }\n\n        if ($first_message) {\n            $posted_id = $thread->postMessage(\n                Thread::KIND_USER,\n                $first_message,\n                array('name' => $visitor['name'])\n            );\n            $thread->shownMessageId = $posted_id;\n            $thread->save();\n        }\n\n        // Prepare chat options\n        $client_data = setup_chatview_for_user(\n            $this->getRouter(),\n            $this->getAssetManager()->getUrlGenerator(),\n            $this->currentRequest,\n            $thread\n        );\n        $options = $client_data['chat'];\n        $options['page'] += setup_logo($group);\n\n        return array(\n            'next' => 'chat',\n            'options' => $options,\n        );\n    }\n\n    /**\n     * Process submitted leave message form.\n     *\n     * Send message to operator email and create special mail thread.\n     * @param array $args Associative array of arguments. It must contains the\n     *   following keys:\n     *    - 'threadId': for this function this param equals to null;\n     *    - 'token': for this function this param equals to null;\n     *    - 'name': string, user name;\n     *    - 'email': string, user email;\n     *    - 'message': string, user message;\n     *    - 'info': string, some info about user;\n     *    - 'referrer': string, page user came from;\n     *    - 'captcha': string, captcha value;\n     *    - 'groupId': selected group id.\n     *\n     * @throws \\Mibew\\RequestProcessor\\ThreadProcessorException Can throw an\n     *   exception if captcha or email is wrong.\n     */\n    protected function apiProcessLeaveMessage($args)\n    {\n        // Check captcha\n        if (Settings::get('enablecaptcha') == '1' && can_show_captcha()) {\n            $captcha = $args['captcha'];\n            $original = isset($_SESSION[SESSION_PREFIX . 'mibew_captcha'])\n                ? $_SESSION[SESSION_PREFIX . 'mibew_captcha']\n                : '';\n            unset($_SESSION[SESSION_PREFIX . 'mibew_captcha']);\n            if (empty($original) || empty($captcha) || $captcha != $original) {\n                throw new ThreadProcessorException(\n                    getlocal('The letters you typed don\\'t match the letters that were shown in the picture.'),\n                    ThreadProcessorException::ERROR_WRONG_CAPTCHA\n                );\n            }\n        }\n\n        // Get form fields\n        $email = $args['email'];\n        $name = $args['name'];\n        $message = $args['message'];\n        $info = $args['info'];\n        $referrer = $args['referrer'];\n\n        if (!MailUtils::isValidAddress($email)) {\n            throw new ThreadProcessorException(\n                wrong_field(\"Your email\"),\n                ThreadProcessorException::ERROR_WRONG_EMAIL\n            );\n        }\n\n        // Verify group id\n        $group_id = 0;\n        if (Settings::get('enablegroups') == '1') {\n            if (preg_match(\"/^\\d{1,8}$/\", $args['groupId']) != 0) {\n                $group = group_by_id($args['groupId']);\n                if ($group) {\n                    $group_id = (int)$args['groupId'];\n                }\n            }\n        }\n\n        // Create thread for left message\n        $remote_host = get_remote_host();\n        $user_browser = $_SERVER['HTTP_USER_AGENT'];\n        $visitor = visitor_from_request();\n\n        // Get message locale\n        $message_locale = Settings::get('left_messages_locale');\n        if (!locale_is_available($message_locale)) {\n            $message_locale = get_home_locale();\n        }\n\n        // Create thread\n        $thread = new Thread();\n        $thread->groupId = $group_id;\n        $thread->userName = $name;\n        $thread->remote = $remote_host;\n        $thread->referer = $referrer;\n        $thread->locale = get_current_locale();\n        $thread->userId = $visitor['id'];\n        $thread->userAgent = $user_browser;\n        $thread->state = Thread::STATE_LEFT;\n        $thread->closed = time();\n        $thread->save();\n\n        // Send some messages\n        if ($referrer) {\n            $thread->postMessage(\n                Thread::KIND_FOR_AGENT,\n                getlocal('Visitor came from page {0}', array($referrer), get_current_locale(), true)\n            );\n        }\n        if ($email) {\n            $thread->postMessage(\n                Thread::KIND_FOR_AGENT,\n                getlocal('E-Mail: {0}', array($email), get_current_locale(), true)\n            );\n        }\n        if ($info) {\n            $thread->postMessage(\n                Thread::KIND_FOR_AGENT,\n                getlocal('Info: {0}', array($info), get_current_locale(), true)\n            );\n        }\n        $thread->postMessage(Thread::KIND_USER, $message, array('name' => $name));\n\n        // Get email for message\n        $inbox_mail = get_group_email($group_id);\n\n        if (empty($inbox_mail)) {\n            $inbox_mail = Settings::get('email');\n        }\n\n        // Send email\n        if ($inbox_mail) {\n            // Prepare message to send by email\n            $mail_template = MailTemplate::loadByName('leave_message', $message_locale);\n            if (!$mail_template) {\n                trigger_error(\n                    'Cannot send e-mail because \"leave_message\" mail template cannot be loaded.',\n                    E_USER_WARNING\n                );\n\n                return;\n            }\n\n            $subject = $mail_template->buildSubject(array($args['name']));\n            $body = $mail_template->buildBody(array(\n                $args['name'],\n                $email,\n                $message,\n                ($info ? $info . \"\\n\" : \"\"),\n            ));\n\n            // Send\n            $this->getMailerFactory()->getMailer()->send(\n                MailUtils::buildMessage($inbox_mail, $email, $subject, $body)\n            );\n        }\n    }\n\n    /**\n     * Returns relative path of the avatar for operator related with the thread.\n     *\n     * @param array $args Associative array of arguments. It must contains the\n     *   following keys:\n     *    - 'threadId': ID of the thread the avatar should be retrieved for.\n     *    - 'token': Token of the thread.\n     * @return array Array of results. It contains following keys:\n     *    - 'imageLink': string, relative path to operator's avatar.\n     */\n    protected function apiGetAvatar($args)\n    {\n        // Load thread and check thread's last token\n        $thread = self::getThread($args['threadId'], $args['token']);\n\n        $image_link = false;\n        if ($thread->agentId) {\n            $operator = operator_by_id($thread->agentId);\n            if ($operator['vcavatar']) {\n                $url_generator = $this->getAssetManager()->getUrlGenerator();\n                $image_link = $url_generator->generate($operator['vcavatar']);\n            }\n        }\n\n        return array('imageLink' => $image_link);\n    }\n}\n", "<?php\n/*\n * This file is a part of Mibew Messenger.\n *\n * Copyright 2005-2020 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nnamespace Mibew;\n\nuse Mibew\\EventDispatcher\\EventDispatcher;\nuse Mibew\\EventDispatcher\\Events;\n\n/**\n * Represents a chat thread\n *\n * @todo Think about STATE_* and KIND_* constant systems and may be simplifies\n *   them.\n */\nclass Thread\n{\n    /**\n     * User in the users queue\n     */\n    const STATE_QUEUE = 0;\n    /**\n     * User waiting for operator\n     */\n    const STATE_WAITING = 1;\n    /**\n     * Conversation in progress\n     */\n    const STATE_CHATTING = 2;\n    /**\n     * Thread closed\n     */\n    const STATE_CLOSED = 3;\n    /**\n     * Thread just created\n     */\n    const STATE_LOADING = 4;\n    /**\n     * User left message without starting a conversation\n     */\n    const STATE_LEFT = 5;\n    /**\n     * Visitor was invited to chat by operator\n     */\n    const STATE_INVITED = 6;\n\n    /**\n     * Visitor was not invited to chat\n     */\n    const INVITATION_NOT_INVITED = 0;\n    /**\n     * Operator invited visitor and wait for reaction.\n     */\n    const INVITATION_WAIT = 1;\n    /**\n     * Invitation was accepted by visitor\n     */\n    const INVITATION_ACCEPTED = 2;\n    /**\n     * Invitation was rejected by visitor\n     */\n    const INVITATION_REJECTED = 3;\n    /**\n     * Invitation was ignored by visitor. Invitation was automatically closed.\n     */\n    const INVITATION_IGNORED = 4;\n\n    /**\n     * Message sent by user\n     */\n    const KIND_USER = 1;\n    /**\n     * Message sent by operator\n     */\n    const KIND_AGENT = 2;\n    /**\n     * Hidden system message to operator\n     */\n    const KIND_FOR_AGENT = 3;\n    /**\n     * System messages for user and operator\n     */\n    const KIND_INFO = 4;\n    /**\n     * Message for user if operator have connection problems\n     */\n    const KIND_CONN = 5;\n    /**\n     * System message about some events (like rename).\n     */\n    const KIND_EVENTS = 6;\n    /**\n     * Message sent by a plugin.\n     */\n    const KIND_PLUGIN = 7;\n\n    /**\n     * ID of the thread.\n     * @var int|bool\n     */\n    public $id;\n\n    /**\n     * Number of the last revision\n     * @var int\n     */\n    public $lastRevision;\n\n    /**\n     * State of the thread. See Thread::STATE_* constants for details.\n     * @var int\n     */\n    public $state;\n\n    /**\n     * State of the invitation. See Thread::INVITATION_* constants for details.\n     * @var int\n     */\n    public $invitationState;\n\n    /**\n     * The last token of the chat thread.\n     * @var string\n     */\n    public $lastToken;\n\n    /**\n     * ID of the next agent(agent that changes the current agent in the chat).\n     * @var int\n     */\n    public $nextAgent;\n\n    /**\n     * ID of the group related with the thread.\n     *\n     * If there is no attached group the value should be equal to 0 (zero).\n     *\n     * @var int\n     */\n    public $groupId;\n\n    /**\n     * ID of the last shown message.\n     * @var int\n     */\n    public $shownMessageId;\n\n    /**\n     * Count of user's messages related to the thread.\n     * @var int\n     */\n    public $messageCount;\n\n    /**\n     * Unix timestamp of the moment the thread was created.\n     * @var int\n     */\n    public $created;\n\n    /**\n     * Unix timestamp of the moment the thread was modified last time.\n     * @var int\n     */\n    public $modified;\n\n    /**\n     * Unix timestamp of the moment when the thread was closed.\n     * @var int\n     */\n    public $closed;\n\n    /**\n     * Unix timestamp of the moment the chat related to the thread was started.\n     * @var int\n     */\n    public $chatStarted;\n\n    /**\n     * ID of an operator who take part in the chat.\n     * @var int\n     */\n    public $agentId;\n\n    /**\n     * Name of an operator who take part in the chat.\n     * @var string\n     */\n    public $agentName;\n\n    /**\n     * Indicates if the opertor who take part in the chat is typing or not.\n     *\n     * It is equal to \"1\" if the operator was typing at the last ping time and\n     * \"0\" otherwise.\n     * @var int\n     */\n    public $agentTyping;\n\n    /**\n     * Unix timestamp of the moment the operator was pinged for the last time.\n     * @var int\n     */\n    public $lastPingAgent;\n\n    /**\n     * Locale code of the chat thread.\n     * @var string\n     */\n    public $locale;\n\n    /**\n     * ID of a user who take part in the chat.\n     * @var string\n     */\n    public $userId;\n\n    /**\n     * Name of a user who take part in the chat.\n     * @var string\n     */\n    public $userName;\n\n    /**\n     * Indicates if the user who take part in the chat is typing or not.\n     *\n     * It is equal to \"1\" if the user was typing at the last ping time and \"0\"\n     * otherwise\n     * @var int\n     */\n    public $userTyping;\n\n    /**\n     * Unix timestamp of the moment the user was pinged for the last time.\n     * @var int\n     */\n    public $lastPingUser;\n\n    /**\n     * User's IP.\n     * @var string\n     */\n    public $remote;\n\n    /**\n     * Content of HTTP \"Referer\" header for the user.\n     * @var string\n     */\n    public $referer;\n\n    /**\n     * Content of HTTP \"User-agent\" header for the user.\n     * @var string\n     */\n    public $userAgent;\n\n    /**\n     * Create thread object from database info.\n     *\n     * @param array $thread_info Associative array of Thread info from database.\n     *   It must contains ALL thread table's\n     *   FIELDS from the database.\n     * @return boolean|Thread Returns an object of the Thread class or boolean\n     *   false on failure\n     */\n    public static function createFromDbInfo($thread_info)\n    {\n        // Create new empty thread\n        $thread = new self();\n        $thread->populateFromDbFields($thread_info);\n\n        return $thread;\n    }\n\n    /**\n     * Load thread from database\n     *\n     * @param int $id ID of the thread to load\n     * @return boolean|Thread Returns an object of the Thread class or boolean\n     *   false on failure\n     */\n    public static function load($id, $last_token = null)\n    {\n        // Check $id\n        if (empty($id)) {\n            return false;\n        }\n\n        // Load thread\n        $thread_info = Database::getInstance()->query(\n            \"SELECT * FROM {thread} WHERE threadid = :threadid\",\n            array(':threadid' => $id),\n            array('return_rows' => Database::RETURN_ONE_ROW)\n        );\n\n        // There is no thread with such id in database\n        if (!$thread_info) {\n            return;\n        }\n\n        // Create new empty thread and populate it with the values from database\n        $thread = new self();\n        $thread->populateFromDbFields($thread_info);\n\n        // Check last token\n        if (!is_null($last_token)) {\n            if ($thread->lastToken != $last_token) {\n                return false;\n            }\n        }\n\n        return $thread;\n    }\n\n    /**\n     * Reopen thread and send message about it\n     *\n     * @return boolean|Thread Boolean FALSE on failure or thread object on\n     *   success\n     */\n    public static function reopen($id)\n    {\n        // Load thread\n        $thread = self::load($id);\n\n        // Check if user and agent gone\n        $user_gone = abs($thread->lastPingUser - time()) > Settings::get('thread_lifetime');\n        $agent_gone = abs($thread->lastPingAgent - time()) > Settings::get('thread_lifetime');\n        if (Settings::get('thread_lifetime') != 0 && $user_gone && $agent_gone) {\n            unset($thread);\n\n            return false;\n        }\n\n        // Check if thread closed\n        if ($thread->state == self::STATE_CLOSED || $thread->state == self::STATE_LEFT) {\n            unset($thread);\n\n            return false;\n        }\n\n        // Reopen thread\n        if ($thread->state == self::STATE_WAITING) {\n            $thread->nextAgent = 0;\n            $thread->save();\n        }\n\n        // Send message\n        $thread->postMessage(\n            self::KIND_EVENTS,\n            getlocal('Visitor joined chat again', null, $thread->locale, true)\n        );\n\n        return $thread;\n    }\n\n    /**\n     * Close all old threads that were not closed by some reasons.\n     */\n    public static function closeOldThreads()\n    {\n        if (Settings::get('thread_lifetime') == 0) {\n            // Threads live forever.\n            return;\n        }\n\n        // We need to run only one instance of cleaning process.\n        $lock = new ProcessLock('threads_close_old');\n\n        if ($lock->get()) {\n            $query = \"SELECT * FROM {thread} \"\n                . \"WHERE istate <> :state_closed \"\n                    . \"AND istate <> :state_left \"\n                    // Check created timestamp\n                    . \"AND ABS(:now - dtmcreated) > :thread_lifetime \"\n                    // Check pings\n                    . \"AND ( \"\n                        . \"( \"\n                            // Both user and operator have no connection\n                            // problems. Check all pings.\n                            . \"lastpingagent <> 0 \"\n                            . \"AND lastpinguser <> 0 \"\n                            . \"AND ABS(:now - lastpinguser) > :thread_lifetime \"\n                            . \"AND ABS(:now - lastpingagent) > :thread_lifetime \"\n                        . \") OR ( \"\n                            // Only operator have connection problems.\n                            // Check user's ping.\n                            . \"lastpingagent = 0 \"\n                            . \"AND lastpinguser <> 0 \"\n                            . \"AND ABS(:now - lastpinguser) > :thread_lifetime \"\n                        . \") OR ( \"\n                            // Only user have connection problems.\n                            // Check operator's ping.\n                            . \"lastpinguser = 0 \"\n                            . \"AND lastpingagent <> 0 \"\n                            . \"AND ABS(:now - lastpingagent) > :thread_lifetime \"\n                        . \") OR ( \"\n                            // Both user and operator have connection problems.\n                            // Just close thread.\n                            . \"lastpinguser = 0 \"\n                            . \"AND lastpingagent = 0 \"\n                        . \") \"\n                    . \")\";\n\n            // Get appropriate threads\n            $now = time();\n            $rows = Database::getInstance()->query(\n                $query,\n                array(\n                    ':now' => $now,\n                    ':state_closed' => self::STATE_CLOSED,\n                    ':state_left' => self::STATE_LEFT,\n                    ':thread_lifetime' => Settings::get('thread_lifetime'),\n                ),\n                array('return_rows' => Database::RETURN_ALL_ROWS)\n            );\n\n            // Perform the cleaning\n            if (count($rows) > 0) {\n                $revision = self::nextRevision();\n                foreach ($rows as $row) {\n                    $thread = Thread::createFromDbInfo($row);\n                    $thread->lastRevision = $revision;\n                    $thread->modified = $now;\n                    $thread->closed = $now;\n                    $thread->state = self::STATE_CLOSED;\n                    $thread->save(false);\n                    unset($thread);\n                }\n            }\n\n            // Release the lock\n            $lock->release();\n        }\n    }\n\n    /**\n     * Check if connection limit reached\n     *\n     * @param string $remote User IP\n     * @return boolean TRUE if connection limit reached and FALSE otherwise\n     */\n    public static function connectionLimitReached($remote)\n    {\n        if (Settings::get('max_connections_from_one_host') == 0) {\n            return false;\n        }\n\n        $result = Database::getInstance()->query(\n            \"SELECT COUNT(*) AS opened FROM {thread} WHERE remote = ? AND istate <> ? AND istate <> ?\",\n            array(\n                $remote,\n                Thread::STATE_CLOSED,\n                Thread::STATE_LEFT,\n            ),\n            array('return_rows' => Database::RETURN_ONE_ROW)\n        );\n\n        if ($result && isset($result['opened'])) {\n            return $result['opened'] >= Settings::get('max_connections_from_one_host');\n        }\n\n        return false;\n    }\n\n    /**\n     * Class constructor.\n     */\n    public function __construct()\n    {\n        // Set the defaults\n        $this->id = false;\n        $this->userName = '';\n        $this->agentId = 0;\n        $this->created = time();\n        $this->modified = time();\n        $this->chatStarted = 0;\n        $this->closed = 0;\n        $this->lastRevision = 0;\n        $this->state = self::STATE_QUEUE;\n        $this->invitationState = self::INVITATION_NOT_INVITED;\n        $this->lastToken = self::nextToken();\n        $this->nextAgent = 0;\n        $this->lastPingAgent = 0;\n        $this->lastPingUser = 0;\n        $this->userTyping = 0;\n        $this->agentTyping = 0;\n        $this->shownMessageId = 0;\n        $this->messageCount = 0;\n        $this->groupId = 0;\n    }\n\n    /**\n     * Remove thread from database\n     *\n     * Triggers {@link \\Mibew\\EventDispatcher\\Events::THREAD_DELETE} event.\n     */\n    public function delete()\n    {\n        Database::getInstance()->query(\n            \"DELETE FROM {thread} WHERE threadid = :id LIMIT 1\",\n            array(':id' => $this->id)\n        );\n\n        $args = array('id' => $this->id);\n        EventDispatcher::getInstance()->triggerEvent(Events::THREAD_DELETE, $args);\n    }\n\n    /**\n     * Ping the thread.\n     *\n     * Updates ping time for conversation members and sends messages about\n     * connection problems.\n     *\n     * @param boolean $is_user Indicates user or operator pings thread. Boolean\n     *   true for user and boolean false otherwise.\n     * @param boolean $is_typing Indicates if user or operator is typing a\n     *   message.\n     */\n    public function ping($is_user, $is_typing)\n    {\n        // Indicates if revision ID of the thread should be updated on save.\n        // Update revision leads to rerender thread in threads list at client\n        // side. Do it on every ping is too costly.\n        $update_revision = false;\n        // Last ping time of other side\n        $last_ping_other_side = 0;\n        // Update last ping time\n        if ($is_user) {\n            $last_ping_other_side = $this->lastPingAgent;\n            $this->lastPingUser = time();\n            $this->userTyping = $is_typing ? \"1\" : \"0\";\n        } else {\n            $last_ping_other_side = $this->lastPingUser;\n            $this->lastPingAgent = time();\n            $this->agentTyping = $is_typing ? \"1\" : \"0\";\n        }\n\n        // Update thread state for the first user ping\n        if ($this->state == self::STATE_LOADING && $is_user) {\n            $this->state = self::STATE_QUEUE;\n            $this->save();\n            return;\n        }\n\n        // Check if other side of the conversation have connection problems\n        if ($last_ping_other_side > 0 && abs(time() - $last_ping_other_side) > Settings::get('connection_timeout')) {\n            // Connection problems detected\n            if ($is_user) {\n                // _Other_ side is operator\n                // Update operator's last ping time\n                $this->lastPingAgent = 0;\n\n                // Check if user chatting at the moment\n                if ($this->state == self::STATE_CHATTING) {\n                    // Send message to user\n                    $message_to_post = getlocal(\n                        'Your operator has connection issues. We have moved you to a priorty position in the queue. Sorry for keeping you waiting.',\n                        null,\n                        $this->locale,\n                        true\n                    );\n                    $this->postMessage(\n                        self::KIND_CONN,\n                        $message_to_post,\n                        array('created' => $last_ping_other_side + Settings::get('connection_timeout'))\n                    );\n\n                    // And update thread\n                    $this->state = self::STATE_WAITING;\n                    $this->nextAgent = 0;\n\n                    // Significant fields of the thread (state and nextAgent)\n                    // are changed. Update revision ID on save.\n                    $update_revision = true;\n                }\n            } else {\n                // _Other_ side is user\n                // Update user's last ping time\n                $this->lastPingUser = 0;\n\n                // And send a message to operator.\n                if ($this->state == self::STATE_CHATTING) {\n                    $message_to_post = getlocal(\n                        'Visitor closed chat window',\n                        null,\n                        $this->locale,\n                        true\n                    );\n                    $this->postMessage(\n                        self::KIND_FOR_AGENT,\n                        $message_to_post,\n                        array('created' => $last_ping_other_side + Settings::get('connection_timeout'))\n                    );\n                }\n            }\n        }\n\n        $this->save($update_revision);\n    }\n\n    /**\n     * Save the thread to the database\n     *\n     * Triggers {@link \\Mibew\\EventDispatcher\\Events::THREAD_UPDATE} and\n     * {@link \\Mibew\\EventDispatcher\\Events::THREAD_CREATE} events.\n     *\n     * @param boolean $update_revision Indicates if last modified time and last\n     *   revision should be updated.\n     */\n    public function save($update_revision = true)\n    {\n        // Update modification time and revision number only if needed\n        if ($update_revision) {\n            $this->lastRevision = $this->nextRevision();\n            $this->modified = time();\n        }\n\n        $db = Database::getInstance();\n        if (!$this->id) {\n            $db->query(\n                ('INSERT INTO {thread} ('\n                    . 'username, userid, agentname, agentid, '\n                    . 'dtmcreated, dtmchatstarted, dtmmodified, dtmclosed, '\n                    . 'lrevision, istate, invitationstate, ltoken, remote, '\n                    . 'referer, nextagent, locale, lastpinguser, '\n                    . 'lastpingagent, usertyping, agenttyping, '\n                    . 'shownmessageid, useragent, messagecount, groupid'\n                . ') VALUES ('\n                    . ':user_name, :user_id, :agent_name, :agent_id, '\n                    . ':created, :chat_started, :modified, :closed, '\n                    . ':revision, :state, :invitation_state, :token, :remote, '\n                    . ':referer, :next_agent, :locale, :last_ping_user, '\n                    . ':last_ping_agent, :user_typing, :agent_typing, '\n                    . ':shown_message_id, :user_agent, :message_count, :group_id '\n                . ')'),\n                array(\n                    ':user_name' => $this->userName,\n                    ':user_id' => $this->userId,\n                    ':agent_name' => $this->agentName,\n                    ':agent_id' => $this->agentId,\n                    ':created' => $this->created,\n                    ':chat_started' => $this->chatStarted,\n                    ':modified' => $this->modified,\n                    ':closed' => $this->closed,\n                    ':revision' => $this->lastRevision,\n                    ':state' => $this->state,\n                    ':invitation_state' => $this->invitationState,\n                    ':token' => $this->lastToken,\n                    ':remote' => $this->remote,\n                    ':referer' => $this->referer,\n                    ':next_agent' => $this->nextAgent,\n                    ':locale' => $this->locale,\n                    ':last_ping_user' => $this->lastPingUser,\n                    ':last_ping_agent' => $this->lastPingAgent,\n                    ':user_typing' => $this->userTyping,\n                    ':agent_typing' => $this->agentTyping,\n                    ':shown_message_id' => $this->shownMessageId,\n                    ':user_agent' => $this->userAgent,\n                    ':message_count' => $this->messageCount,\n                    ':group_id' => $this->groupId,\n                )\n            );\n            $this->id = $db->insertedId();\n\n            $args = array('thread' => $this);\n            EventDispatcher::getInstance()->triggerEvent(Events::THREAD_CREATE, $args);\n        } else {\n            // Get the original state of the thread to trigger event later.\n            $original_thread = Thread::load($this->id);\n\n            $db->query(\n                ('UPDATE {thread} SET '\n                    . 'username = :user_name, userid = :user_id, '\n                    . 'agentname = :agent_name, agentid = :agent_id, '\n                    . 'dtmcreated = :created, dtmchatstarted = :chat_started, '\n                    . 'dtmmodified = :modified, dtmclosed = :closed, '\n                    . 'lrevision = :revision, istate = :state, '\n                    . 'invitationstate = :invitation_state, ltoken = :token, '\n                    . 'remote = :remote, referer = :referer, '\n                    . 'nextagent = :next_agent, locale = :locale, '\n                    . 'lastpinguser = :last_ping_user, '\n                    . 'lastpingagent = :last_ping_agent, '\n                    . 'usertyping = :user_typing, agenttyping = :agent_typing, '\n                    . 'shownmessageid = :shown_message_id, '\n                    . 'useragent = :user_agent, messagecount = :message_count, '\n                    . 'groupid = :group_id '\n                . 'WHERE threadid = :thread_id'),\n                array(\n                    ':thread_id' => $this->id,\n                    ':user_name' => $this->userName,\n                    ':user_id' => $this->userId,\n                    ':agent_name' => $this->agentName,\n                    ':agent_id' => $this->agentId,\n                    ':created' => $this->created,\n                    ':chat_started' => $this->chatStarted,\n                    ':modified' => $this->modified,\n                    ':closed' => $this->closed,\n                    ':revision' => $this->lastRevision,\n                    ':state' => $this->state,\n                    ':invitation_state' => $this->invitationState,\n                    ':token' => $this->lastToken,\n                    ':remote' => $this->remote,\n                    ':referer' => $this->referer,\n                    ':next_agent' => $this->nextAgent,\n                    ':locale' => $this->locale,\n                    ':last_ping_user' => $this->lastPingUser,\n                    ':last_ping_agent' => $this->lastPingAgent,\n                    ':user_typing' => $this->userTyping,\n                    ':agent_typing' => $this->agentTyping,\n                    ':shown_message_id' => $this->shownMessageId,\n                    ':user_agent' => $this->userAgent,\n                    ':message_count' => $this->messageCount,\n                    ':group_id' => $this->groupId,\n                )\n            );\n\n            $args = array(\n                'thread' => $this,\n                'original_thread' => $original_thread,\n            );\n            EventDispatcher::getInstance()->triggerEvent(Events::THREAD_UPDATE, $args);\n        }\n    }\n\n    /**\n     * Check if thread is reassigned for another operator\n     *\n     * Updates thread info, send events messages and avatar message to user.\n     *\n     * @param array $operator Operator for test\n     */\n    public function checkForReassign($operator)\n    {\n        $operator_name = ($this->locale == get_home_locale())\n            ? $operator['vclocalename']\n            : $operator['vccommonname'];\n\n        $is_operator_correct = $this->nextAgent == $operator['operatorid']\n            || $this->agentId == $operator['operatorid'];\n\n        if ($this->state == self::STATE_WAITING && $is_operator_correct) {\n            // Prepare message\n            if ($this->nextAgent == $operator['operatorid']) {\n                $message_to_post = getlocal(\n                    \"Operator <strong>{0}</strong> changed operator <strong>{1}</strong>\",\n                    array($operator_name, $this->agentName),\n                    $this->locale,\n                    true\n                );\n            } else {\n                $message_to_post = getlocal(\n                    \"Operator {0} is back\",\n                    array($operator_name),\n                    $this->locale,\n                    true\n                );\n            }\n\n            // Update thread info\n            $this->state = self::STATE_CHATTING;\n            $this->nextAgent = 0;\n            $this->agentId = $operator['operatorid'];\n            $this->agentName = $operator_name;\n            $this->save();\n\n            // Send messages\n            $this->postMessage(self::KIND_EVENTS, $message_to_post);\n        }\n    }\n\n    /**\n     * Load messages from database corresponding to the thread those ID's more\n     * than $lastid\n     *\n     * @param boolean $is_user Boolean TRUE if messages loads for user\n     *   and boolean FALSE if they loads for operator.\n     * @param int $lastid ID of the last loaded message.\n     * @return array Array of messages. Every message is associative array with\n     *   following keys:\n     *    - 'id': int, message id;\n     *    - 'kind': int, message kind, see Thread::KIND_* for details;\n     *    - 'created': int, unix timestamp when message was created;\n     *    - 'name': string, name of sender;\n     *    - 'message': string, message text;\n     *    - 'plugin': string, name of the plugin which sent the message or an\n     *      empty string if message was not sent by a plugin.\n     *    - 'data' array, arbitrary data attached to the message\n     * @see Thread::postMessage()\n     */\n    public function getMessages($is_user, &$last_id)\n    {\n        $db = Database::getInstance();\n\n        // Load messages\n        $query = \"SELECT messageid AS id, ikind AS kind, dtmcreated AS created, \"\n                . \" tname AS name, tmessage AS message, plugin, data \"\n            . \"FROM {message} \"\n            . \"WHERE threadid = :threadid AND messageid > :lastid \"\n                . ($is_user ? \"AND ikind <> \" . self::KIND_FOR_AGENT : \"\")\n            . \" ORDER BY messageid\";\n\n        $messages = $db->query(\n            $query,\n            array(\n                ':threadid' => $this->id,\n                ':lastid' => $last_id,\n            ),\n            array('return_rows' => Database::RETURN_ALL_ROWS)\n        );\n\n        foreach ($messages as $key => $msg) {\n            // Process data attached to the message\n            if (!empty($messages[$key]['data'])) {\n                $messages[$key]['data'] = unserialize(\n                    $messages[$key]['data']\n                );\n            } else {\n                $messages[$key]['data'] = array();\n            }\n        }\n\n        // Trigger the \"alter\" event\n        $args = array(\n            'messages' => $messages,\n            'thread' => $this,\n        );\n        EventDispatcher::getInstance()->triggerEvent(Events::THREAD_GET_MESSAGES_ALTER, $args);\n        $altered_messages = $args['messages'];\n\n        // Get ID of the last message\n        foreach ($altered_messages as $msg) {\n            if ($msg['id'] > $last_id) {\n                $last_id = $msg['id'];\n            }\n        }\n\n        return $altered_messages;\n    }\n\n    /**\n     * Send the messsage\n     *\n     * One can attach arbitrary data to the message by setting 'data' item\n     * in the $options array. DO NOT serialize data manually - it will be\n     * automatically converted to array and serialized before save in database\n     * and unserialized after retrieve form database.\n     *\n     * One can also set plugin item of the $options array to indicate that\n     * message was sent by a plugin.\n     *\n     * Triggers {@link \\Mibew\\EventDispatcher\\Events::THREAD_POST_MESSAGE}\n     * event.\n     *\n     * @param int $kind Message kind. One of the Thread::KIND_*\n     * @param string $message Message body\n     * @param array $options List of additional options. It may contain\n     *   following items:\n     *    - 'name': string, name of the message sender.\n     *    - 'operator_id': int, ID of the operator who sent the message. For\n     *      system messages do not set this field.\n     *    - 'created': int, unix timestamp of the send time. If you want to set\n     *      current time do not set this field.\n     *    - 'plugin': string, name of the plugin which sent the message. If\n     *      message was not sent by a plugin do not set this field.\n     *    - 'data': array with arbitrary data related with message. This value\n     *      will be converted to array and serialized before save. If there is\n     *      no such data do not set this field.\n     *\n     * @return int Message ID\n     *\n     * @see Thread::KIND_USER\n     * @see Thread::KIND_AGENT\n     * @see Thread::KIND_FOR_AGENT\n     * @see Thread::KIND_INFO\n     * @see Thread::KIND_CONN\n     * @see Thread::KIND_EVENTS\n     * @see Thread::KIND_PLUGIN\n     * @see Thread::getMessages()\n     */\n    public function postMessage($kind, $message, $options = array())\n    {\n        $event_args = array(\n            'thread' => $this,\n            'message_kind' => $kind,\n            'message_body' => $message,\n            'message_options' => (is_array($options) ? $options : array()),\n        );\n        EventDispatcher::getInstance()->triggerEvent(Events::THREAD_POST_MESSAGE, $event_args);\n\n        // Send message\n        return $this->saveMessage(\n            $event_args['message_kind'],\n            $event_args['message_body'],\n            $event_args['message_options']\n        );\n    }\n\n    /**\n     * Close thread and send closing messages to the conversation members\n     *\n     * Triggers {@link \\Mibew\\EventDispatcher\\Events::THREAD_CLOSE} event.\n     *\n     * @param boolean $is_user Boolean TRUE if user initiate thread closing or\n     *   boolean FALSE otherwise\n     */\n    public function close($is_user)\n    {\n        // Send message about closing\n        if ($is_user) {\n            $this->postMessage(\n                self::KIND_EVENTS,\n                getlocal(\n                    \"Visitor {0} left the chat\",\n                    array($this->userName),\n                    $this->locale,\n                    true\n                )\n            );\n        } else {\n            if ($this->state == self::STATE_INVITED) {\n                $this->postMessage(\n                    self::KIND_FOR_AGENT,\n                    getlocal(\n                        'Operator canceled invitation',\n                        null,\n                        $this->locale,\n                        true\n                    )\n                );\n            } else {\n                $this->postMessage(\n                    self::KIND_EVENTS,\n                    getlocal(\n                        \"Operator {0} left the chat\",\n                        array($this->agentName),\n                        $this->locale,\n                        true\n                    )\n                );\n            }\n        }\n\n        // Get messages count\n        $db = Database::getInstance();\n\n        list($message_count) = $db->query(\n            (\"SELECT COUNT(*) FROM {message} \"\n                . \"WHERE {message}.threadid = :threadid AND ikind = :kind_user\"),\n            array(\n                ':threadid' => $this->id,\n                ':kind_user' => Thread::KIND_USER,\n            ),\n            array(\n                'return_rows' => Database::RETURN_ONE_ROW,\n                'fetch_type' => Database::FETCH_NUM,\n            )\n        );\n\n        // Close thread if it's not already closed\n        if ($this->state != self::STATE_CLOSED) {\n            $this->state = self::STATE_CLOSED;\n            $this->closed = time();\n            $this->messageCount = $message_count;\n            $this->save();\n\n            $args = array('thread' => $this);\n            EventDispatcher::getInstance()->triggerEvent(Events::THREAD_CLOSE, $args);\n        }\n    }\n\n    /**\n     * Assign operator to thread\n     *\n     * @param array $operator Operator who try to take thread\n     * @return boolean Boolean TRUE on success or FALSE on failure\n     */\n    public function take($operator)\n    {\n        // There are states which forbids thread taking. Make sure the current\n        // state is not one of them.\n        $forbidden_states = array(\n            self::STATE_CLOSED,\n            self::STATE_LEFT,\n            self::STATE_INVITED,\n        );\n        if (in_array($this->state, $forbidden_states)) {\n            return false;\n        }\n\n        $is_operator_changed = ($operator['operatorid'] != $this->agentId)\n            // Only these states allow operators changing. In other states\n            // changing of operator's ID is treated in different ways (join or\n            // come back).\n            && ($this->state == self::STATE_WAITING || $this->state == self::STATE_CHATTING);\n\n        // For these states we assume that the thread has no operator yet. The\n        // check for operator changing is skipped because it will always\n        // return positive result.\n        $is_operator_joined = ($this->state == self::STATE_LOADING)\n            || ($this->state == self::STATE_QUEUE);\n\n        $is_operator_back = ($this->state == self::STATE_WAITING)\n            && ($operator['operatorid'] == $this->agentId);\n\n        $message = '';\n        $operator_name = ($this->locale == get_home_locale())\n            ? $operator['vclocalename']\n            : $operator['vccommonname'];\n\n        if ($is_operator_changed) {\n            $message = getlocal(\n                \"Operator <strong>{0}</strong> changed operator <strong>{1}</strong>\",\n                array($operator_name, $this->agentName),\n                $this->locale,\n                true\n            );\n        } elseif ($is_operator_joined) {\n            $message = getlocal(\n                \"Operator {0} joined the chat\",\n                array($operator_name),\n                $this->locale,\n                true\n            );\n        } elseif ($is_operator_back) {\n            $message = getlocal(\n                \"Operator {0} is back\",\n                array($operator_name),\n                $this->locale,\n                true\n            );\n        }\n\n        // Make sure the thread have correct operator and state.\n        $this->state = self::STATE_CHATTING;\n        $this->nextAgent = 0;\n        $this->agentId = $operator['operatorid'];\n        $this->agentName = $operator_name;\n        if (empty($this->chatStarted)) {\n            // This is needed only if the chat was not started yet. Such threads\n            // should originally belong to STATE_QUEUE or STATE_LOADING.\n            $this->chatStarted = time();\n        }\n        $this->save();\n\n        // Send message\n        if ($message) {\n            $this->postMessage(self::KIND_EVENTS, $message);\n        }\n\n        return true;\n    }\n\n    /**\n     * Change user name in the conversation\n     *\n     * @param string $new_name New user name\n     */\n    public function renameUser($new_name)\n    {\n        // Rename only if a new name is really new\n        if ($this->userName != $new_name) {\n            // Save old name\n            $old_name = $this->userName;\n            // Rename user\n            $this->userName = $new_name;\n            $this->save();\n\n            // Send message about renaming\n            $message = getlocal(\n                \"The visitor changed their name <strong>{0}</strong> to <strong>{1}</strong>\",\n                array($old_name, $new_name),\n                $this->locale,\n                true\n            );\n            $this->postMessage(self::KIND_EVENTS, $message);\n        }\n    }\n\n    /**\n     * Sets thread's fields according to the fields from Database.\n     *\n     * @param array $db_fields Associative array of database fields which keys\n     *   are fields names and the values are fields values.\n     */\n    protected function populateFromDbFields($db_fields)\n    {\n        $this->id = (int)$db_fields['threadid'];\n        $this->userName = $db_fields['username'];\n        $this->userId = $db_fields['userid'];\n        $this->agentName = $db_fields['agentname'];\n        $this->agentId = (int)$db_fields['agentid'];\n        $this->created = (int)$db_fields['dtmcreated'];\n        $this->chatStarted = (int)$db_fields['dtmchatstarted'];\n        $this->modified = (int)$db_fields['dtmmodified'];\n        $this->closed = (int)$db_fields['dtmclosed'];\n        $this->lastRevision = (int)$db_fields['lrevision'];\n        $this->state = (int)$db_fields['istate'];\n        $this->invitationState = (int)$db_fields['invitationstate'];\n        $this->lastToken = (int)$db_fields['ltoken'];\n        $this->remote = $db_fields['remote'];\n        $this->referer = $db_fields['referer'];\n        $this->nextAgent = (int)$db_fields['nextagent'];\n        $this->locale = $db_fields['locale'];\n        $this->lastPingUser = (int)$db_fields['lastpinguser'];\n        $this->lastPingAgent = (int)$db_fields['lastpingagent'];\n        $this->userTyping = $db_fields['usertyping'];\n        $this->agentTyping = $db_fields['agenttyping'];\n        $this->shownMessageId = (int)$db_fields['shownmessageid'];\n        $this->userAgent = $db_fields['useragent'];\n        $this->messageCount = $db_fields['messagecount'];\n        $this->groupId = (int)$db_fields['groupid'];\n    }\n\n    /**\n     * Save the messsage in database\n     *\n     * @param int $kind Message kind. One of the Thread::KIND_*\n     * @param string $message Message body\n     * @param array $options List of additional options. It may contain\n     *   following items:\n     *    - 'name': string, name of the message sender.\n     *    - 'operator_id': int, ID of the operator who sent the message. For\n     *      system messages do not set this field.\n     *    - 'created': int, unix timestamp of the send time. If you want to set\n     *      current time do not set this field.\n     *    - 'plugin': string, name of the plugin which sent the message. If\n     *      message was not sent by a plugin do not set this field.\n     *    - 'data': array with arbitrary data related with message. This value\n     *      will be converted to array and serialized before save. If there is no\n     *      such data do not set this field.\n     *\n     * @return int Message ID\n     *\n     * @see Thread::KIND_USER\n     * @see Thread::KIND_AGENT\n     * @see Thread::KIND_FOR_AGENT\n     * @see Thread::KIND_INFO\n     * @see Thread::KIND_CONN\n     * @see Thread::KIND_EVENTS\n     * @see Thread::KIND_PLUGIN\n     * @see Thread::getMessages()\n     */\n    protected function saveMessage($kind, $message, $options = array())\n    {\n        $db = Database::getInstance();\n\n        // TODO: check incoming message (it should be non-empty string)\n        // Add default values to options\n        $options += array(\n            'name' => null,\n            'operator_id' => 0,\n            'created' => time(),\n            'plugin' => '',\n            'data' => array(),\n        );\n\n        // Prepare message data\n        $options['data'] = serialize((array) $options['data']);\n\n        // Prepare query\n        $query = \"INSERT INTO {message} (\"\n                . \"threadid, ikind, tmessage, tname, agentid, \"\n                . \"dtmcreated, plugin, data\"\n            . \") VALUES (\"\n                . \":threadid, :kind, :message, :name, :agentid, \"\n                . \":created, :plugin, :data\"\n            . \")\";\n\n        $values = array(\n            ':threadid' => $this->id,\n            ':kind' => $kind,\n            ':message' => $message,\n            ':name' => $options['name'],\n            ':agentid' => $options['operator_id'],\n            ':created' => $options['created'],\n            ':plugin' => $options['plugin'],\n            ':data' => $options['data'],\n        );\n\n        // Execute query\n        $db->query($query, $values);\n\n        return $db->insertedId();\n    }\n\n    /**\n     * Return next revision number (last revision number plus one)\n     *\n     * @return int revision number\n     */\n    protected static function nextRevision()\n    {\n        $db = Database::getInstance();\n        $db->query(\"UPDATE {revision} SET id=LAST_INSERT_ID(id+1)\");\n        $val = $db->insertedId();\n\n        return $val;\n    }\n\n    /**\n     * Create thread token\n     *\n     * @return int Thread token\n     */\n    protected static function nextToken()\n    {\n        if (function_exists('openssl_random_pseudo_bytes')) {\n            $token_arr = unpack('N', \"\\x0\" . openssl_random_pseudo_bytes(3));\n            $token = $token_arr[1];\n        } else {\n            $token = mt_rand(99999, 99999999);\n        }\n\n        return $token;\n    }\n}\n", "<?php\n/*\n * This file is a part of Mibew Messenger.\n *\n * Copyright 2005-2020 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Import namespaces and classes of the core\nuse Mibew\\EventDispatcher\\EventDispatcher;\nuse Mibew\\EventDispatcher\\Events;\nuse Mibew\\Database;\nuse Mibew\\ProcessLock;\nuse Mibew\\Settings;\nuse Mibew\\Thread;\n\n/**\n * Check invitation state for specified visitior\n *\n * @param int $visitor_id ID of the visitor to check\n * @return array Array of invitation info. It contains following items:\n *  - 'invited': boolean, indicates if the visitor was invited by an operator;\n *  - 'threadid': int, ID of the thread, related with visitor or boolean false\n *    if visitor with specfied ID does not exist.\n */\nfunction invitation_state($visitor_id)\n{\n    $db = Database::getInstance();\n    $db_result = $db->query(\n        (\"SELECT t.threadid, t.invitationstate, t.istate \"\n            . \"FROM {sitevisitor} v, {thread} t \"\n            . \"WHERE visitorid = ? \"\n            . \"AND t.threadid = v.threadid\"),\n        array($visitor_id),\n        array('return_rows' => Database::RETURN_ONE_ROW)\n    );\n\n    $ret = array();\n    if (!$db_result) {\n        $ret['invited'] = false;\n        $ret['threadid'] = false;\n    } else {\n        $ret['invited'] = ($db_result['istate'] == Thread::STATE_INVITED)\n            && ($db_result['invitationstate'] == Thread::INVITATION_WAIT);\n        $ret['threadid'] = $db_result['threadid'];\n    }\n\n    return $ret;\n}\n\n/**\n * Invite visitor by operator\n *\n * Triggers {@link \\Mibew\\EventDispatcher\\Events::INVITATION_CREATE} event.\n *\n * @param int $visitor_id ID of the visitor, who must be invited.\n * @param array $operator Info for operator  who invite the visitor\n * @return Thread|boolean Thread object related with invitation or boolean\n *   false on failure\n */\nfunction invitation_invite($visitor_id, $operator)\n{\n    // Check if visitor already invited\n    $invitation_state = invitation_state($visitor_id);\n    if ($invitation_state['invited']) {\n        return false;\n    }\n\n    // Get visitor info\n    $visitor = track_get_visitor_by_id($visitor_id);\n\n    // Get last page visited by the visitor\n    $visitor_path = track_get_path($visitor);\n    ksort($visitor_path);\n    $last_visited_page = array_pop($visitor_path);\n\n    // Get visitor details\n    $visitor_details = track_retrieve_details($visitor);\n\n    // Get some operator's info\n    $operator_name = get_operator_name($operator);\n\n    // Create thread for invitation\n    $thread = new Thread();\n\n    // Populate thread and save it\n    $thread->agentId = $operator['operatorid'];\n    $thread->agentName = $operator_name;\n    $thread->userName = $visitor['username'];\n    $thread->remote = $visitor_details['remote_host'];\n    $thread->referer = $last_visited_page;\n    // User's locale is unknown, set operator locale to the thread\n    $thread->locale = get_current_locale();\n    $thread->userId = $visitor['userid'];\n    $thread->userAgent = $visitor_details['user_agent'];\n    $thread->state = Thread::STATE_INVITED;\n    $thread->invitationState = Thread::INVITATION_WAIT;\n    $thread->save();\n\n    $db = Database::getInstance();\n    $db->query(\n        (\"UPDATE {sitevisitor} set \"\n            . \"invitations = invitations + 1, \"\n            . \"threadid = :thread_id \"\n            . \"WHERE visitorid = :visitor_id\"),\n        array(\n            ':thread_id' => $thread->id,\n            ':visitor_id' => $visitor_id,\n        )\n    );\n\n    // Send some messages\n    $thread->postMessage(\n        Thread::KIND_FOR_AGENT,\n        getlocal(\n            'Operator {0} invites visitor at {1} page',\n            array($operator_name, $last_visited_page),\n            get_current_locale(),\n            true\n        )\n    );\n    $thread->postMessage(\n        Thread::KIND_AGENT,\n        getlocal('Hello, how can I help you?', null, get_current_locale(), true),\n        array(\n            'name' => $operator_name,\n            'operator_id' => $operator['operatorid'],\n        )\n    );\n\n    // Let plugins know about the invitation.\n    $args = array('invitation' => $thread);\n    EventDispatcher::getInstance()->triggerEvent(Events::INVITATION_CREATE, $args);\n\n    return $thread;\n}\n\n/**\n * Invitation was accepted by visitor\n *\n * Triggers {@link \\Mibew\\EventDispatcher\\Events::INVITATION_ACCEPT} event.\n *\n * @param int $visitor_id ID of the visitor who accept invitation\n * @return Thread|boolean Thread object or boolean false on failure\n */\nfunction invitation_accept($visitor_id)\n{\n    // Check if visitor was invited\n    $invitation_state = invitation_state($visitor_id);\n    if (!$invitation_state['invited']) {\n        // Visitor was not invited\n        return false;\n    }\n\n    // Get thread related with the visitor\n    $db = Database::getInstance();\n    $result = $db->query(\n        \"SELECT threadid FROM {sitevisitor} WHERE visitorid = :visitor_id\",\n        array(':visitor_id' => $visitor_id),\n        array('return_rows' => Database::RETURN_ONE_ROW)\n    );\n\n    if (empty($result['threadid'])) {\n        // Something went wrong. There is no thread related with the visitor.\n        return false;\n    }\n\n    $thread = Thread::load($result['threadid']);\n    if (!$thread) {\n        // Something went wrong. Cannot load thread.\n        return false;\n    }\n\n    // Update thread info\n    $thread->state = Thread::STATE_CHATTING;\n    $thread->invitationState = Thread::INVITATION_ACCEPTED;\n    $thread->chatStarted = time();\n    $thread->save();\n\n    // Update visitor info\n    $db->query(\n        (\"UPDATE {sitevisitor} SET chats = chats + 1 \"\n            . \"WHERE visitorid = :visitor_id\"),\n        array(':visitor_id' => $visitor_id)\n    );\n\n    $args = array('invitation' => $thread);\n    EventDispatcher::getInstance()->triggerEvent(Events::INVITATION_ACCEPT, $args);\n\n    return $thread;\n}\n\n/**\n * Inviation was rejected by visitor\n *\n * Triggers {@link \\Mibew\\EventDispatcher\\Events::INVITATION_REJECT} event.\n *\n * @param int $visitor_id ID of the visitor\n */\nfunction invitation_reject($visitor_id)\n{\n    $visitor = track_get_visitor_by_id($visitor_id);\n\n    // Send message to operator\n    $thread = Thread::load($visitor['threadid']);\n    if ($thread) {\n        $thread->postMessage(\n            Thread::KIND_FOR_AGENT,\n            getlocal('Visitor rejected invitation', null, get_current_locale(), true)\n        );\n    }\n\n    $db = Database::getInstance();\n    $db->query(\n        (\"UPDATE {sitevisitor} v, {thread} t SET \"\n            . \"v.threadid = NULL, \"\n            . \"t.invitationstate = :invitation_rejected, \"\n            . \"t.istate = :state_closed, \"\n            . \"t.dtmclosed = :now \"\n            . \"WHERE t.threadid = v.threadid \"\n            . \"AND visitorid = :visitor_id\"),\n        array(\n            ':invitation_rejected' => Thread::INVITATION_REJECTED,\n            ':state_closed' => Thread::STATE_CLOSED,\n            ':visitor_id' => $visitor_id,\n            ':now' => time(),\n        )\n    );\n\n    $args = array('invitation' => $thread);\n    EventDispatcher::getInstance()->triggerEvent(Events::INVITATION_REJECT, $args);\n}\n\n/**\n * Close old invitations.\n *\n * Triggers {@link \\Mibew\\EventDispatcher\\Events::INVITATION_IGNORE} event.\n */\nfunction invitation_close_old()\n{\n    // Run only one instance of cleaning process.\n    $lock = new ProcessLock('invitations_close_old');\n    if ($lock->get()) {\n        // Freeze the time for the whole cleaning process.\n        $now = time();\n\n        $db = Database::getInstance();\n\n        // Remove links between visitors and invitations that will be closed.\n        $db->query(\n            (\"UPDATE {sitevisitor} v, {thread} t SET \"\n                . \"v.threadid = NULL \"\n                . \"WHERE t.istate = :state_invited \"\n                . \"AND t.invitationstate = :invitation_wait \"\n                . \"AND (:now - t.dtmcreated) > :lifetime\"),\n            array(\n                ':invitation_wait' => Thread::INVITATION_WAIT,\n                ':state_invited' => Thread::STATE_INVITED,\n                ':lifetime' => Settings::get('invitation_lifetime'),\n                ':now' => $now,\n            )\n        );\n\n        // Get all invitations to close\n        $threads = $db->query(\n            (\"SELECT * FROM {thread} \"\n                . \"WHERE istate = :state_invited \"\n                . \"AND invitationstate = :invitation_wait \"\n                . \"AND (:now - dtmcreated) > :lifetime\"),\n            array(\n                ':invitation_wait' => Thread::INVITATION_WAIT,\n                ':state_invited' => Thread::STATE_INVITED,\n                ':lifetime' => Settings::get('invitation_lifetime'),\n                ':now' => $now,\n            ),\n            array('return_rows' => Database::RETURN_ALL_ROWS)\n        );\n\n        // Close the invitations\n        foreach ($threads as $thread_info) {\n            $thread = Thread::createFromDbInfo($thread_info);\n            $thread->invitationState = Thread::INVITATION_IGNORED;\n            $thread->state = Thread::STATE_CLOSED;\n            $thread->closed = $now;\n            $thread->save();\n\n            // Notify the operator about autoclosing\n            $thread->postMessage(\n                Thread::KIND_FOR_AGENT,\n                getlocal(\n                    'Visitor ignored invitation and it was closed automatically',\n                    null,\n                    $thread->locale,\n                    true\n                )\n            );\n\n            $args = array('invitation' => $thread);\n            EventDispatcher::getInstance()->triggerEvent(Events::INVITATION_IGNORE, $args);\n\n            unset($thread);\n        }\n\n        // Release the lock\n        $lock->release();\n    }\n}\n\n/**\n * Prepare data to dispaly invitation\n *\n * @param Thread $thread Thread object related with invitation\n * @return array Array of invitation data\n */\nfunction setup_invitation_view(Thread $thread)\n{\n    $data = prepare_chat_app_data();\n\n    // Set refresh frequency\n    $data['frequency'] = Settings::get('updatefrequency_chat');\n\n    // Create some empty arrays\n    $data['invitation'] = array();\n\n    $data['invitation']['thread'] = array(\n        'id' => $thread->id,\n        'token' => $thread->lastToken,\n        'agentId' => $thread->agentId,\n        'userId' => $thread->userId,\n    );\n\n    $data['invitation']['user'] = array(\n        'name' => htmlspecialchars($thread->userName),\n        'canChangeName' => false,\n        'isAgent' => false,\n    );\n\n    $data['startFrom'] = 'invitation';\n\n    return $data;\n}\n"], "fixing_code": ["<?php\n/*\n * This file is a part of Mibew Messenger.\n *\n * Copyright 2005-2020 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nuse Mibew\\Asset\\Generator\\UrlGeneratorInterface as AssetUrlGeneratorInterface;\nuse Mibew\\EventDispatcher\\EventDispatcher;\nuse Mibew\\EventDispatcher\\Events;\nuse Mibew\\Settings;\nuse Mibew\\Thread;\nuse Mibew\\Style\\ChatStyle;\nuse Mibew\\Style\\PageStyle;\nuse Mibew\\Routing\\Generator\\SecureUrlGeneratorInterface as UrlGeneratorInterface;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\n/**\n * Convert messages to formatted text\n *\n * @param array $msg message object which most be formatted\n *\n * @return string formatted message\n */\n\nfunction message_to_text($msg)\n{\n    $message_time = date(\"H:i:s \", $msg['created']);\n    if ($msg['kind'] == Thread::KIND_USER || $msg['kind'] == Thread::KIND_AGENT) {\n        if ($msg['name']) {\n            return $message_time . $msg['name'] . \": \" . $msg['message'] . \"\\n\";\n        } else {\n            return $message_time . $msg['message'] . \"\\n\";\n        }\n    } elseif ($msg['kind'] == Thread::KIND_INFO) {\n        return $message_time . $msg['message'] . \"\\n\";\n    } else {\n        return $message_time . \"[\" . $msg['message'] . \"]\\n\";\n    }\n}\n\n/**\n * Sanitize message body and make it a safe HTML string.\n *\n * @param array $msg Message object\n * @return array Message object with sanitized body.\n */\nfunction sanitize_message($msg)\n{\n    $message_body = $msg['message'];\n\n    // Messages entered by user or operator cannot contain any markup\n    if ($msg['kind'] == Thread::KIND_USER || $msg['kind'] == Thread::KIND_AGENT) {\n        $message_body = safe_htmlspecialchars($message_body);\n    }\n\n    $msg['message'] = sanitize_string($message_body, 'low', 'moderate');\n\n    return $msg;\n}\n\n/**\n * Format username\n *\n * @param string $user_name client username\n * @param string $addr ip address of client\n * @param string $id id of client\n *\n * @return string formatted username with \"usernamepattern\" pattern\n */\nfunction get_user_name($user_name, $addr, $id)\n{\n    return str_replace(\n        \"{addr}\",\n        $addr,\n        str_replace(\n            \"{id}\",\n            $id,\n            str_replace(\"{name}\", $user_name, Settings::get('usernamepattern'))\n        )\n    );\n}\n\n/**\n * Prepare logo data\n *\n * @param array $group Group info\n * @return array Array of logo data\n */\nfunction setup_logo($group = null)\n{\n    $data = array();\n    $top_level_group = (!$group) ? array() : get_top_level_group($group);\n\n    $group_name = empty($top_level_group['vctitle'])\n        ? Settings::get('title')\n        : $top_level_group['vctitle'];\n\n    $logo = empty($top_level_group['vclogo'])\n        ? Settings::get('logo')\n        : $top_level_group['vclogo'];\n\n    $mibew_host = empty($top_level_group['vchosturl'])\n        ? Settings::get('hosturl')\n        : $top_level_group['vchosturl'];\n\n    $data['company'] = array(\n        'name' => $group_name,\n        'chatLogoURL' => $logo,\n    );\n    $data['mibewHost'] = $mibew_host;\n\n    return $data;\n}\n\n/**\n * Prepare values common for chat, prechat survey form and leave message form.\n * @return array\n */\nfunction prepare_chat_app_data()\n{\n    $data = array();\n\n    // Set refresh frequency\n    $data['frequency'] = Settings::get('updatefrequency_chat');\n\n    return $data;\n}\n\n/**\n * Prepare data to display leave message form\n *\n * @param string $name User name\n * @param string $email User email\n * @param int $group_id Id of selected group\n * @param string $info User info\n * @param string $referrer URL of referrer page\n * @return array Array of leave message form data\n */\nfunction setup_leavemessage($name, $email, $group_id, $info, $referrer)\n{\n    $data = prepare_chat_app_data();\n\n    // Create some empty arrays\n    $data['leaveMessage'] = array();\n\n    $group = group_by_id($group_id);\n    $group_name = '';\n    if ($group) {\n        $group_name = get_group_name($group);\n    }\n\n    $data['leaveMessage']['leaveMessageForm'] = array(\n        'name' => $name,\n        'email' => $email,\n        'groupId' => $group_id,\n        'groupName' => $group_name,\n        'info' => $info,\n        'referrer' => $referrer,\n        'showCaptcha' => (bool) (Settings::get(\"enablecaptcha\") == \"1\" && can_show_captcha()),\n    );\n\n    $data['page.title'] = (empty($group_name) ? '' : $group_name . ': ')\n        . getlocal('Leave your message');\n    $data['leaveMessage']['page'] = array(\n        'title' => $data['page.title']\n    );\n\n    // Set privacy policy link (if needed)\n    if (Settings::get('enableprivacypolicy')\n         && strcmp('', Settings::get('privacypolicy'))) {\n        $data['leaveMessage']['leaveMessageForm']['privacyPolicyUrl'] = Settings::get('privacypolicy');\n    }\n\n    if (Settings::get('enablegroups') == '1') {\n        $data['leaveMessage']['leaveMessageForm']['groups']\n            = prepare_groups_select($group_id);\n    }\n\n    $data['startFrom'] = 'leaveMessage';\n\n    return $data;\n}\n\n/**\n * Prepare data to display pre-chat survey\n *\n * @param string $name User name\n * @param string $email User email\n * @param int $group_id Id of selected group\n * @param string $info User info\n * @param string $referrer URL of referrer page\n * @return array Array of survey data\n */\nfunction setup_survey($name, $email, $group_id, $info, $referrer)\n{\n    $data = prepare_chat_app_data();\n\n    // Create some empty arrays\n    $data['survey'] = array();\n\n    $data['survey']['surveyForm'] = array(\n        'name' => $name,\n        'groupId' => $group_id,\n        'email' => $email,\n        'info' => $info,\n        'referrer' => $referrer,\n        'showEmail' => (bool) (Settings::get(\"surveyaskmail\") == \"1\"),\n        'showMessage' => (bool) (Settings::get(\"surveyaskmessage\") == \"1\"),\n        'canChangeName' => (bool) (Settings::get('usercanchangename') == \"1\"),\n    );\n\n    $data['page.title'] = getlocal('Live support');\n    $data['survey']['page'] = array(\n        'title' => $data['page.title']\n    );\n\n    // Set privacy policy link (if needed)\n    if (Settings::get('enableprivacypolicy')\n         && strcmp('', Settings::get('privacypolicy'))) {\n        $data['survey']['surveyForm']['privacyPolicyUrl'] = Settings::get('privacypolicy');\n    }\n\n    if (Settings::get('enablegroups') == '1' && Settings::get('surveyaskgroup') == '1') {\n        $data['survey']['surveyForm']['groups']\n            = prepare_groups_select($group_id);\n    }\n\n    $data['startFrom'] = 'survey';\n\n    return $data;\n}\n\n/**\n * Prepare groups list to build group select box.\n *\n * If $group_id specified groups list will consist of group with id equals to\n * $group_id and its children.\n *\n * @param int $group_id Id of selected group\n * @return array|boolean Array of groups info arrays or boolean false if there\n *   are no suitable groups.\n *   Group info array contain following keys:\n *    - 'id': int, group id;\n *    - 'name': string, group name;\n *    - 'description': string, group description;\n *    - 'online': boolean, indicates if group online;\n *    - 'selected': boolean, indicates if group selected by default.\n */\nfunction prepare_groups_select($group_id)\n{\n    $show_groups = ($group_id == '') ? true : group_has_children($group_id);\n\n    if (!$show_groups) {\n        return false;\n    }\n\n    $all_groups = get_groups(false);\n\n    if (empty($all_groups)) {\n        return false;\n    }\n\n    $groups_list = array();\n    $selected_group_id = $group_id;\n\n    foreach ($all_groups as $group) {\n        $group_is_empty = (bool) ($group['inumofagents'] == 0);\n        $group_related_with_specified = empty($group_id)\n            || $group['parent'] == $group_id\n            || $group['groupid'] == $group_id;\n\n        if ($group_is_empty || !$group_related_with_specified) {\n            continue;\n        }\n\n        if (group_is_online($group) && !$selected_group_id) {\n            $selected_group_id = $group['groupid'];\n        }\n\n        $groups_list[] = array(\n            'id' => $group['groupid'],\n            'name' => get_group_name($group),\n            'description' => get_group_description($group),\n            'online' => group_is_online($group),\n            'selected' => (bool) ($group['groupid'] == $selected_group_id),\n        );\n    }\n\n    // One group must be selected by default\n    if (!empty($groups_list)) {\n        // Check if there is selected group\n        $selected_group_present = false;\n        foreach ($groups_list as $group) {\n            if ($group['selected']) {\n                $selected_group_present = true;\n                break;\n            }\n        }\n\n        // If there is no selected group select the first one\n        if (!$selected_group_present) {\n            $groups_list[0]['selected'] = true;\n        }\n    }\n\n    return $groups_list;\n}\n\n/**\n * Prepare some data for chat for both user and operator\n *\n * @param Thread $thread thread object\n * @return array Array of chat view data\n */\nfunction setup_chatview(Thread $thread)\n{\n    $data = prepare_chat_app_data();\n\n    // Get group info\n    if (!empty($thread->groupId)) {\n        $group = group_by_id($thread->groupId);\n        $group = get_top_level_group($group);\n    } else {\n        $group = array();\n    }\n\n    // Create some empty arrays\n    $data['chat'] = array(\n        'messageForm' => array(),\n        'links' => array(),\n        'windowsParams' => array(),\n    );\n\n    // Set thread params\n    $data['chat']['thread'] = array(\n        'id' => $thread->id,\n        'token' => $thread->lastToken,\n        'agentId' => $thread->agentId,\n        'userId' => $thread->userId,\n    );\n\n    $data['page.title'] = empty($group['vcchattitle'])\n        ? Settings::get('chattitle')\n        : $group['vcchattitle'];\n    $data['chat']['page'] = array(\n        'title' => $data['page.title']\n    );\n\n    // Setup logo\n    $data = array_merge_recursive($data, setup_logo($group));\n\n    // Set enter key shortcut\n    if (Settings::get('sendmessagekey') == 'enter') {\n        $data['chat']['messageForm']['ignoreCtrl'] = true;\n    } else {\n        $data['chat']['messageForm']['ignoreCtrl'] = false;\n    }\n\n    // Load dialogs style options\n    $chat_style = new ChatStyle(ChatStyle::getCurrentStyle());\n    $style_config = $chat_style->getConfigurations();\n    $data['chat']['windowsParams']['mail']\n        = $style_config['mail']['window'];\n\n    // Load core style options\n    $page_style = new PageStyle(PageStyle::getCurrentStyle());\n    $style_config = $page_style->getConfigurations();\n    $data['chat']['windowsParams']['history']\n        = $style_config['history']['window'];\n\n    $data['startFrom'] = 'chat';\n\n    return $data;\n}\n\n/**\n * Prepare some data for chat for user\n *\n * @param UrlGeneratorInterface $url_generator A URL generator object.\n * @param AssetUrlGeneratorInterface $asset_url_generator An asset URL generator\n * object.\n * @param Request $request The current request.\n * @param Thread $thread thread object that will be used\n * @return array Array of chat view data\n */\nfunction setup_chatview_for_user(\n    UrlGeneratorInterface $url_generator,\n    AssetUrlGeneratorInterface $asset_url_generator,\n    Request $request,\n    Thread $thread\n) {\n    $data = setup_chatview($thread);\n\n    // Set user info\n    $data['chat']['user'] = array(\n        'name' => htmlspecialchars($thread->userName),\n        'canChangeName' => (bool) (Settings::get('usercanchangename') == \"1\"),\n        'defaultName' => (bool) (getlocal(\"Guest\") != $thread->userName),\n        'canPost' => true,\n        'isAgent' => false,\n    );\n\n    // Set link to send mail page\n    $data['chat']['links']['mail'] = $url_generator->generate(\n        'chat_user_mail',\n        array(\n            'thread_id' => $thread->id,\n            'token' => $thread->lastToken,\n        )\n    );\n\n    // Set SSL link\n    if (Settings::get('enablessl') == \"1\" && $request->isSecure()) {\n        $data['chat']['links']['ssl'] = $url_generator->generateSecure(\n            'chat_user',\n            array(\n                'thread_id' => $thread->id,\n                'token' => $thread->lastToken,\n            ),\n            UrlGeneratorInterface::ABSOLUTE_URL\n        );\n    }\n\n    // Set chat link\n    $data['chat']['links']['chat'] = $url_generator->generate(\n        'chat_user',\n        array(\n            'thread_id' => $thread->id,\n            'token' => $thread->lastToken,\n        ),\n        UrlGeneratorInterface::ABSOLUTE_URL\n    );\n\n    // Set default operator's avatar\n    $operator = operator_by_id($thread->agentId);\n    $data['chat']['avatar'] = $operator['vcavatar']\n        ? $asset_url_generator->generate($operator['vcavatar'])\n        : '';\n\n\n    return $data;\n}\n\n/**\n * Prepare some data for chat for operator\n *\n * @param UrlGeneratorInterface $url_generator A URL generator object.\n * @param Request $request The current request.\n * @param Thread $thread thread object.\n * @param array $operator Operator's data.\n * @return array Array of chat view data\n */\nfunction setup_chatview_for_operator(\n    UrlGeneratorInterface $url_generator,\n    Request $request,\n    Thread $thread,\n    $operator\n) {\n    $data = setup_chatview($thread);\n\n    // Set operator info\n    $data['chat']['user'] = array(\n        'name' => htmlspecialchars(\n            get_user_name(\n                $thread->userName,\n                $thread->remote,\n                $thread->userId\n            )\n        ),\n        'canPost' => (bool) ($thread->agentId == $operator['operatorid']),\n        'isAgent' => true,\n    );\n\n    // Set SSL link\n    if (Settings::get('enablessl') == \"1\" && !$request->isSecure()) {\n        $data['chat']['links']['ssl'] = $url_generator->generateSecure(\n            'chat_operator',\n            array(\n                'thread_id' => $thread->id,\n                'token' => $thread->lastToken,\n            ),\n            UrlGeneratorInterface::ABSOLUTE_URL\n        );\n    }\n\n    // Set chat link\n    $data['chat']['links']['chat'] = $url_generator->generate(\n        'chat_operator',\n        array(\n            'thread_id' => $thread->id,\n            'token' => $thread->lastToken,\n        ),\n        UrlGeneratorInterface::ABSOLUTE_URL\n    );\n\n    // Set history window params\n    $data['chat']['links']['history'] = $url_generator->generate(\n        'history_user',\n        array('user_id' => $thread->userId)\n    );\n\n    // Set tracking params\n    if (Settings::get('enabletracking')) {\n        $visitor = track_get_visitor_by_thread_id($thread->id);\n        $data['chat']['links']['tracked'] = $url_generator->generate(\n            'history_user_track',\n            array('visitor' => $visitor['visitorid'])\n        );\n    }\n\n    // Check if agent can post messages\n    if ($thread->agentId == $operator['operatorid']) {\n        // Get predefined answers\n        $canned_messages = load_canned_messages($thread->locale, 0);\n        if ($thread->groupId) {\n            $canned_messages = array_merge(\n                load_canned_messages($thread->locale, $thread->groupId),\n                $canned_messages\n            );\n        };\n\n        $predefined_answers = array();\n        foreach ($canned_messages as $answer) {\n            $predefined_answers[] = array(\n                'short' => htmlspecialchars(\n                    $answer['vctitle'] ? $answer['vctitle'] : cut_string($answer['vcvalue'], 97, '...')\n                ),\n                'full' => $answer['vcvalue'],\n            );\n        }\n        $data['chat']['messageForm']['predefinedAnswers'] = $predefined_answers;\n    }\n    // Set link to user redirection page\n    $data['chat']['links']['redirect'] = $url_generator->generate(\n        'chat_operator_redirection_links',\n        array(\n            'thread_id' => $thread->id,\n            'token' => $thread->lastToken,\n        )\n    );\n\n    return $data;\n}\n\n/**\n * @return array Return visitor info from active request. contains\n * (user_id string, user_name string)\n */\nfunction visitor_from_request()\n{\n    $default_name = getlocal(\"Guest\");\n    $user_name = $default_name;\n    if (isset($_COOKIE[USERNAME_COOKIE_NAME])) {\n        $data = base64_decode(strtr($_COOKIE[USERNAME_COOKIE_NAME], '-_,', '+/='));\n        if (strlen($data) > 0) {\n            $user_name = $data;\n        }\n    }\n\n    if ($user_name == $default_name) {\n        $temp = Request::createFromGlobals()->query->get('name');\n        $user_name = (isset($temp) && ($temp !== '')) ? $temp : $user_name;\n    }\n\n    if (isset($_COOKIE[USERID_COOKIE_NAME])) {\n        $user_id = $_COOKIE[USERID_COOKIE_NAME];\n    } else {\n        $user_id = uniqid('', true);\n        setcookie(USERID_COOKIE_NAME, $user_id, time() + 60 * 60 * 24 * 365);\n    }\n\n    return array('id' => $user_id, 'name' => $user_name);\n}\n\n/**\n * @return string Return remote host from active request\n */\nfunction get_remote_host()\n{\n    $ext_addr = $_SERVER['REMOTE_ADDR'];\n    $has_proxy = isset($_SERVER['HTTP_X_FORWARDED_FOR'])\n        && $_SERVER['HTTP_X_FORWARDED_FOR'] != $_SERVER['REMOTE_ADDR'];\n    if ($has_proxy) {\n        $ips = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR'], 2);\n        $ext_addr = (count($ips) > 1)\n            ? $ips[0] . ' (' . $_SERVER['HTTP_X_FORWARDED_FOR'] . ')'\n            : $ips[0];\n    }\n\n    return isset($_SERVER['REMOTE_HOST']) ? $_SERVER['REMOTE_HOST'] : $ext_addr;\n}\n\n/**\n * Start chat thread for user\n *\n * @param int $group_id Id of group related to thread\n * @param array $requested_operator Array of requested operator info\n * @param string $visitor_id Id of the visitor\n * @param string $visitor_name Name of the visitor\n * @param string $referrer Page user came from\n * @param string $info User info\n *\n * @return Thread thread object\n */\nfunction chat_start_for_user(\n    $group_id,\n    $requested_operator,\n    $visitor_id,\n    $visitor_name,\n    $referrer,\n    $info\n) {\n    // Get user info\n    $remote_host = get_remote_host();\n    $user_browser = $_SERVER['HTTP_USER_AGENT'];\n\n    // Check connection limit\n    if (Thread::connectionLimitReached($remote_host)) {\n        die(\"number of connections from your IP is exceeded, try again later\");\n    }\n\n    // Check if visitor was invited to chat\n    $is_invited = false;\n    if (Settings::get('enabletracking')) {\n        $invitation_state = invitation_state($_SESSION[SESSION_PREFIX . 'visitorid']);\n        if ($invitation_state['invited']) {\n            $is_invited = true;\n        }\n    }\n\n    // Get info about requested operator\n    $requested_operator_online = false;\n    if ($requested_operator) {\n        $requested_operator_online = is_operator_online(\n            $requested_operator['operatorid']\n        );\n    }\n\n    // Get thread object\n    if ($is_invited) {\n        // Get thread from invitation\n        $thread = invitation_accept($_SESSION[SESSION_PREFIX . 'visitorid']);\n        if (!$thread) {\n            die(\"Cannot start thread\");\n        }\n    } else {\n        // Create thread\n        $thread = new Thread();\n        $thread->state = Thread::STATE_LOADING;\n        $thread->agentId = 0;\n        if ($requested_operator && $requested_operator_online) {\n            $thread->nextAgent = $requested_operator['operatorid'];\n        }\n    }\n\n    // Update thread fields\n    $thread->groupId = $group_id;\n    $thread->userName = $visitor_name;\n    $thread->remote = $remote_host;\n    $thread->referer = $referrer;\n    $thread->locale = get_current_locale();\n    $thread->userId = $visitor_id;\n    $thread->userAgent = $user_browser;\n    $thread->save();\n\n    $_SESSION[SESSION_PREFIX . 'threadid'] = $thread->id;\n\n    // Store own thread ids to restrict access for other people\n    if (!isset($_SESSION[SESSION_PREFIX . 'own_threads'])) {\n        $_SESSION[SESSION_PREFIX . 'own_threads'] = array();\n    }\n    $_SESSION[SESSION_PREFIX . 'own_threads'][] = $thread->id;\n\n    // Bind thread to the visitor\n    if (Settings::get('enabletracking')) {\n        track_visitor_bind_thread($visitor_id, $thread);\n    }\n\n    // Send several messages\n    if ($is_invited) {\n        $operator = operator_by_id($thread->agentId);\n        $operator_name = get_operator_name($operator);\n        $thread->postMessage(\n            Thread::KIND_FOR_AGENT,\n            getlocal(\n                'Visitor accepted invitation from operator {0}',\n                array(safe_htmlspecialchars($operator_name)),\n                get_current_locale(),\n                true\n            )\n        );\n    } else {\n        if ($referrer) {\n            $thread->postMessage(\n                Thread::KIND_FOR_AGENT,\n                getlocal('Visitor came from page {0}', array(safe_htmlspecialchars($referrer)), get_current_locale(), true)\n            );\n        }\n        if ($requested_operator && !$requested_operator_online) {\n            $thread->postMessage(\n                Thread::KIND_INFO,\n                getlocal(\n                    'Thank you for contacting us. We are sorry, but requested operator <strong>{0}</strong> is offline. Another operator will be with you shortly.',\n                    array(safe_htmlspecialchars(get_operator_name($requested_operator))),\n                    get_current_locale(),\n                    true\n                )\n            );\n        } else {\n            $thread->postMessage(\n                Thread::KIND_INFO,\n                getlocal('Thank you for contacting us. An operator will be with you shortly.', null, get_current_locale(), true)\n            );\n        }\n    }\n\n    // TODO: May be move sending this message somewhere else?\n    if ($info) {\n        $thread->postMessage(\n            Thread::KIND_FOR_AGENT,\n            getlocal('Info: {0}', array(safe_htmlspecialchars($info)), get_current_locale(), true)\n        );\n    }\n\n    // Let plugins know that user is ready to chat.\n    $dispatcher = EventDispatcher::getInstance();\n    $event_args = array('thread' => $thread);\n    $dispatcher->triggerEvent(Events::THREAD_USER_IS_READY, $event_args);\n\n    return $thread;\n}\n", "<?php\n/*\n * This file is a part of Mibew Messenger.\n *\n * Copyright 2005-2020 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nnamespace Mibew\\Controller;\n\nuse Mibew\\Settings;\nuse Mibew\\Thread;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\n\n/**\n * Represents button-related actions\n */\nclass ButtonController extends AbstractController\n{\n    /**\n     * Returns content of the chat button.\n     *\n     * @param Request $request\n     * @return string Rendered page content\n     */\n    public function indexAction(Request $request)\n    {\n        $referer = $request->server->get('HTTP_REFERER', '');\n\n        // We need to display message about visited page only if the visitor\n        // really change it.\n        $new_page = empty($_SESSION[SESSION_PREFIX . 'last_visited_page'])\n            || $_SESSION[SESSION_PREFIX . 'last_visited_page'] != $referer;\n\n        // Display message about page change\n        if ($referer && isset($_SESSION[SESSION_PREFIX . 'threadid']) && $new_page) {\n            $thread = Thread::load($_SESSION[SESSION_PREFIX . 'threadid']);\n            if ($thread && $thread->state != Thread::STATE_CLOSED) {\n                $msg = getlocal(\n                    \"Visitor navigated to {0}\",\n                    array(safe_htmlspecialchars($referer)),\n                    $thread->locale,\n                    true\n                );\n                $thread->postMessage(Thread::KIND_FOR_AGENT, $msg);\n            }\n        }\n        $_SESSION[SESSION_PREFIX . 'last_visited_page'] = $referer;\n\n        $image = $request->query->get('i', '');\n        if (!preg_match(\"/^\\w+$/\", $image)) {\n            $image = 'mibew';\n        }\n\n        $lang = $request->query->get('lang', '');\n        if (!preg_match(\"/^[\\w-]{2,5}$/\", $lang)) {\n            $lang = '';\n        }\n        if (!$lang || !locale_is_available($lang)) {\n            $lang = get_current_locale();\n        }\n\n        $group_id = $request->query->get('group', '');\n        if (!preg_match(\"/^\\d{1,8}$/\", $group_id)) {\n            $group_id = false;\n        }\n        if ($group_id) {\n            if (Settings::get('enablegroups') == '1') {\n                $group = group_by_id($group_id);\n                if (!$group) {\n                    $group_id = false;\n                }\n            } else {\n                $group_id = false;\n            }\n        }\n\n        // Get image file content\n        $image_postfix = has_online_operators($group_id) ? \"on\" : \"off\";\n        $file_name = \"locales/${lang}/button/${image}_${image_postfix}.png\";\n        $content_type = 'image/png';\n        if (!is_readable($file_name)) {\n            // Fall back to .gif image\n            $file_name = \"locales/${lang}/button/${image}_${image_postfix}.gif\";\n            $content_type = 'image/gif';\n        }\n\n        $fh = fopen($file_name, 'rb');\n        if ($fh) {\n            // Create response with image in body\n            $file_size = filesize($file_name);\n            $content = fread($fh, $file_size);\n            fclose($fh);\n            $response = new Response($content, 200);\n\n            // Set correct content info\n            $response->headers->set('Content-Type', $content_type);\n            $response->headers->set('Content-Length', $file_size);\n        } else {\n            $response = new Response('Not found', 404);\n        }\n\n        // Disable caching\n        $response->headers->addCacheControlDirective('no-cache', true);\n        $response->headers->addCacheControlDirective('no-store', true);\n        $response->headers->addCacheControlDirective('must-revalidate', true);\n        $response->setExpires(new \\DateTime('yesterday noon'));\n        $response->headers->set('Pragma', 'no-cache');\n\n        return $response;\n    }\n}\n", "<?php\n/*\n * This file is a part of Mibew Messenger.\n *\n * Copyright 2005-2020 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nnamespace Mibew\\Controller\\Chat;\n\nuse Mibew\\Database;\nuse Mibew\\Http\\Exception\\BadRequestException;\nuse Mibew\\Http\\Exception\\NotFoundException;\nuse Mibew\\Thread;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\n/**\n * Contains all actions which are related with operator's chat redirect logic.\n */\nclass RedirectController extends AbstractController\n{\n    /**\n     * Renders a page with redirections links.\n     *\n     * @param Request $request Incoming request.\n     * @return string|\\Symfony\\Component\\HttpFoundation\\RedirectResponse Rendered\n     *   page content or a redirect response.\n     * @throws NotFoundException If the thread with specified ID and token is\n     * not found.\n     */\n    public function showRedirectionLinksAction(Request $request)\n    {\n        // Check if we should force the user to use SSL\n        $ssl_redirect = $this->sslRedirect($request);\n        if ($ssl_redirect !== false) {\n            return $ssl_redirect;\n        }\n\n        $operator = $this->getOperator();\n        $thread_id = $request->attributes->get('thread_id');\n        $token = $request->attributes->get('token');\n\n        $thread = Thread::load($thread_id, $token);\n        if (!$thread) {\n            throw new NotFoundException('The thread is not found.');\n        }\n\n        if ($thread->agentId != $operator['operatorid']) {\n            $page = array('errors' => array('Can redirect only own threads.'));\n\n            return $this->render('error', $page);\n        }\n\n        $page = array_merge_recursive(\n            setup_chatview_for_operator(\n                $this->getRouter(),\n                $request,\n                $thread,\n                $operator\n            ),\n            setup_redirect_links(\n                $this->getRouter(),\n                $thread_id,\n                $operator,\n                $token\n            )\n        );\n\n        // Render the page with redirection links.\n        return $this->render('redirect', $page);\n    }\n\n    /**\n     * Process chat thread redirection.\n     *\n     * @param Request $request Incoming request.\n     * @return string|\\Symfony\\Component\\HttpFoundation\\RedirectResponse Rendered\n     *   page content or a redirect response.\n     * @throws NotFoundException If the thread with specified ID and token is\n     * not found.\n     * @throws BadRequestException If one or more arguments have a wrong format.\n     */\n    public function redirectAction(Request $request)\n    {\n        $thread_id = $request->attributes->get('thread_id');\n        $token = $request->attributes->get('token');\n\n        $thread = Thread::load($thread_id, $token);\n        if (!$thread) {\n            throw new NotFoundException('The thread is not found.');\n        }\n\n        $page = array(\n            'errors' => array(),\n        );\n\n        if ($request->query->has('nextGroup')) {\n            // The thread was redirected to a group.\n            $next_id = $request->query->get('nextGroup');\n            if (!preg_match(\"/^\\d{1,10}$/\", $next_id)) {\n                throw new BadRequestException('Wrong value of \"nextGroup\" argument.');\n            }\n            $next_group = group_by_id($next_id);\n\n            if ($next_group) {\n                $page['message'] = getlocal(\n                    'The visitor has been placed in a priorty queue of the group {0}.',\n                    array(get_group_name($next_group))\n                );\n                if (!$this->redirectToGroup($thread, (int)$next_id)) {\n                    $page['errors'][] = getlocal('You are not chatting with the visitor.');\n                }\n            } else {\n                $page['errors'][] = 'Unknown group';\n            }\n        } else {\n            // The thread was redirected to an operator.\n            $next_id = $request->query->get('nextAgent');\n            if (!preg_match(\"/^\\d{1,10}$/\", $next_id)) {\n                throw new BadRequestException('Wrong value of \"nextAgent\" argument.');\n            }\n            $next_operator = operator_by_id($next_id);\n\n            if ($next_operator) {\n                $page['message'] = getlocal(\n                    'The visitor has been placed in the priorty queue of the operator {0}.',\n                    array(get_operator_name($next_operator))\n                );\n                if (!$this->redirectToOperator($thread, $next_id)) {\n                    $page['errors'][] = getlocal('You are not chatting with the visitor.');\n                }\n            } else {\n                $page['errors'][] = 'Unknown operator';\n            }\n        }\n\n        $page = array_merge_recursive($page, setup_logo());\n\n        if (count($page['errors']) > 0) {\n            return $this->render('error', $page);\n        } else {\n            return $this->render('redirected', $page);\n        }\n    }\n\n    /**\n     * Redirects a chat thread to the group with the specified ID.\n     *\n     * @param \\Mibew\\Thread $thread Chat thread to redirect.\n     * @param int $group_id ID of the target group.\n     * @return boolean True if the thread was redirected and false on failure.\n     */\n    protected function redirectToGroup(Thread $thread, $group_id)\n    {\n        if ($thread->state != Thread::STATE_CHATTING) {\n            // We can redirect only threads which are in proggress now.\n            return false;\n        }\n\n        // Redirect the thread\n        $thread->state = Thread::STATE_WAITING;\n        $thread->nextAgent = 0;\n        $thread->groupId = $group_id;\n        $thread->agentId = 0;\n        $thread->agentName = '';\n        $thread->save();\n\n        // Send notification message\n        $thread->postMessage(\n            Thread::KIND_EVENTS,\n            getlocal(\n                'Operator {0} redirected you to another operator. Please wait a while.',\n                array(safe_htmlspecialchars(get_operator_name($this->getOperator()))),\n                $thread->locale,\n                true\n            )\n        );\n\n        return true;\n    }\n\n    /**\n     * Redirects a chat thread to the operator with the specified ID.\n     *\n     * @param \\Mibew\\Thread $thread Chat thread to redirect.\n     * @param int $group_id ID of the target operator.\n     * @return boolean True if the thread was redirected and false on failure.\n     */\n    protected function redirectToOperator(Thread $thread, $operator_id)\n    {\n        if ($thread->state != Thread::STATE_CHATTING) {\n            // We can redirect only threads which are in proggress now.\n            return false;\n        }\n\n        // Redirect the thread\n        $thread->state = Thread::STATE_WAITING;\n        $thread->nextAgent = $operator_id;\n        $thread->agentId = 0;\n\n        // Check if the target operator belongs to the current thread's group.\n        // If not reset the current thread's group.\n        if ($thread->groupId != 0) {\n            $db = Database::getInstance();\n            list($groups_count) = $db->query(\n                (\"SELECT count(*) AS count \"\n                    . \"FROM {operatortoopgroup} \"\n                    . \"WHERE operatorid = ? AND groupid = ?\"),\n                array($operator_id, $thread->groupId),\n                array(\n                    'return_rows' => Database::RETURN_ONE_ROW,\n                    'fetch_type' => Database::FETCH_NUM,\n                )\n            );\n            if ($groups_count === 0) {\n                $thread->groupId = 0;\n            }\n        }\n\n        $thread->save();\n\n        // Send notification message\n        $thread->postMessage(\n            Thread::KIND_EVENTS,\n            getlocal(\n                'Operator {0} redirected you to another operator. Please wait a while.',\n                array(safe_htmlspecialchars(get_operator_name($this->getOperator()))),\n                $thread->locale,\n                true\n            )\n        );\n\n        return true;\n    }\n}\n", "<?php\n/*\n * This file is a part of Mibew Messenger.\n *\n * Copyright 2005-2020 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nnamespace Mibew\\RequestProcessor;\n\n// Import namespaces and classes of the core\nuse Mibew\\Asset\\AssetManagerAwareInterface;\nuse Mibew\\Asset\\AssetManagerInterface;\nuse Mibew\\Authentication\\AuthenticationManagerAwareInterface;\nuse Mibew\\Authentication\\AuthenticationManagerInterface;\nuse Mibew\\Http\\Exception\\AccessDeniedException;\nuse Mibew\\Mail\\MailerFactoryAwareInterface;\nuse Mibew\\Mail\\MailerFactoryInterface;\nuse Mibew\\Mail\\Template as MailTemplate;\nuse Mibew\\Mail\\Utils as MailUtils;\nuse Mibew\\Settings;\nuse Mibew\\Thread;\nuse Mibew\\API\\API as MibewAPI;\nuse Mibew\\RequestProcessor\\Exception\\ThreadProcessorException;\nuse Mibew\\Routing\\RouterAwareInterface;\nuse Mibew\\Routing\\RouterInterface;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\n/**\n * Incapsulates thread api and thread processing functions.\n *\n * Event triggered by the class (see description of the RequestProcessor class\n * for details):\n *  - threadRequestReceived\n *  - threadReceiveRequestError\n *  - threadCallError\n *  - threadFunctionCall\n *\n * WARNING:\n *  threadResponseReceived registered but never called because of asynchronous\n *  nature of Core-to-Window interaction\n *\n * @todo Move all API functions to another place.\n */\nclass ThreadProcessor extends ClientSideProcessor implements\n    RouterAwareInterface,\n    AssetManagerAwareInterface,\n    AuthenticationManagerAwareInterface,\n    MailerFactoryAwareInterface\n{\n    /**\n     * @var AuthenticationManagerInterface|null\n     */\n    protected $authenticationManager = null;\n\n    /**\n     * The request which is hadled now.\n     *\n     * @var Request|null\n     */\n    protected $currentRequest = null;\n\n    /**\n     * A Router instance.\n     *\n     * @var RouterInterface|null\n     */\n    protected $router = null;\n\n    /**\n     * @var MailerFactoryInterface|null\n     */\n    protected $mailerFactory = null;\n\n    /**\n     * An instance of asset manager.\n     *\n     * @var AssetManagerInterface|null\n     */\n    protected $assetManager = null;\n\n    /**\n     * Loads thread by id and token and checks if thread loaded\n     *\n     * @param int $thread_id Id of the thread\n     * @param int $last_token Last token of the thread\n     * @return \\Mibew\\Thread\n     * @throws \\Mibew\\RequestProcessor\\ThreadProcessorException\n     */\n    public static function getThread($thread_id, $last_token)\n    {\n        // Load thread\n        $thread = Thread::load($thread_id, $last_token);\n        // Check thread\n        if (!$thread) {\n            throw new ThreadProcessorException(\n                'Wrong thread',\n                ThreadProcessorException::ERROR_WRONG_THREAD\n            );\n        }\n\n        // Return thread\n        return $thread;\n    }\n\n    /**\n     * Check if arguments exists in $args array\n     *\n     * @param array $args Arguments array\n     * @param array $vars Array of arguments names that must be checked\n     * @throws \\Mibew\\RequestProcessor\\ThreadProcessorException\n     */\n    public static function checkParams($args, $vars)\n    {\n        if (empty($vars)) {\n            return;\n        }\n        // Check variables exists\n        foreach ($vars as $var) {\n            if (!array_key_exists($var, $args)) {\n                throw new ThreadProcessorException(\n                    \"There is no '{$var}' variable in arguments list\",\n                    ThreadProcessorException::ERROR_WRONG_ARGUMENTS\n                );\n            }\n        }\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function handleRequest($request)\n    {\n        $this->currentRequest = $request;\n        $response = parent::handleRequest($request);\n        $this->currentRequest = null;\n\n        return $response;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getRouter()\n    {\n        return $this->router;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function setRouter(RouterInterface $router)\n    {\n        $this->router = $router;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function setAuthenticationManager(AuthenticationManagerInterface $manager)\n    {\n        $this->authenticationManager = $manager;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getAuthenticationManager()\n    {\n        return $this->authenticationManager;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function setMailerFactory(MailerFactoryInterface $factory)\n    {\n        $this->mailerFactory = $factory;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getMailerFactory()\n    {\n        return $this->mailerFactory;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getAssetManager()\n    {\n        return $this->assetManager;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function setAssetManager(AssetManagerInterface $manager)\n    {\n        $this->assetManager = $manager;\n    }\n\n    /**\n     * Class constructor\n     */\n    protected function __construct()\n    {\n        parent::__construct(array(\n            'signature' => '',\n            'trusted_signatures' => array(''),\n            'event_prefix' => 'thread',\n        ));\n    }\n\n    /**\n     * Creates and returns an instance of the \\Mibew\\API\\API class.\n     *\n     * @return \\Mibew\\API\\API\n     */\n    protected function getMibewAPIInstance()\n    {\n        return MibewAPI::getAPI('\\\\Mibew\\\\API\\\\Interaction\\\\ChatInteraction');\n    }\n\n    /**\n     * Check if operator logged in\n     *\n     * @return array Operators info array\n     * @throws \\Mibew\\RequestProcessor\\ThreadProcessorException If operator is\n     *   not logged in.\n     */\n    protected function checkOperator()\n    {\n        $operator = $this->getAuthenticationManager()->getOperator();\n        if (!$operator) {\n            throw new ThreadProcessorException(\n                \"Operator is not logged in!\",\n                ThreadProcessorException::ERROR_AGENT_NOT_LOGGED_IN\n            );\n        }\n\n        return $operator;\n    }\n\n    /**\n     * Sends asynchronous request\n     *\n     * @param array $request The 'request' array. See Mibew API for details\n     * @return boolean true on success or false on failure\n     */\n    protected function sendAsyncRequest($request)\n    {\n        // Define empty thread id and thread token\n        $thread_id = null;\n        $token = null;\n        $recipient = null;\n        foreach ($request['functions'] as $function) {\n            // Save thread id and thread token from first function in package\n            if (is_null($thread_id)) {\n                $thread_id = $function['arguments']['threadId'];\n                $token = $function['arguments']['token'];\n                $recipient = $function['arguments']['recipient'];\n                continue;\n            }\n            // Check thread id and thread token for the remaining functions\n            $wrong_thread_id = $thread_id != $function['arguments']['threadId'];\n            $wrong_token = $token != $function['arguments']['token'];\n            if ($wrong_thread_id || $wrong_token) {\n                throw new ThreadProcessorException(\n                    'Various thread id or thread token in different functions in one package!',\n                    ThreadProcessorException::VARIOUS_THREAD_ID\n                );\n            }\n            // Check request recipient\n            if ($recipient !== $function['arguments']['recipient']) {\n                throw new ThreadProcessorException(\n                    'Various recipient in different functions in one package!',\n                    ThreadProcessorException::VARIOUS_RECIPIENT\n                );\n            }\n        }\n        // Store request in buffer\n        if ($recipient == 'agent' || $recipient == 'both') {\n            $this->addRequestToBuffer('thread_agent_' . $thread_id, $request);\n        }\n        if ($recipient == 'user' || $recipient == 'both') {\n            $this->addRequestToBuffer('thread_user_' . $thread_id, $request);\n        }\n\n        return true;\n    }\n\n    /**\n     * Additional validation for functions that called via call method\n     *\n     * @param Array $function A Function array\n     */\n    protected function checkFunction($function)\n    {\n        // Check recipient argument existence\n        if (!array_key_exists('recipient', $function['arguments'])) {\n            throw new ThreadProcessorException(\n                \"'recipient' argument is not set in function '{$function['function']}'!\",\n                ThreadProcessorException::EMPTY_RECIPIENT\n            );\n        }\n        $recipient = $function['arguments']['recipient'];\n        // Check recipient value\n        if ($recipient != 'agent' && $recipient != 'both' && $recipient != 'user') {\n            throw new ThreadProcessorException(\n                \"Wrong recipient value '{$recipient}'! It should be one of 'agent', 'user', 'both'\",\n                ThreadProcessorException::WRONG_RECIPIENT_VALUE\n            );\n        }\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function processFunction($function, \\Mibew\\API\\ExecutionContext &$context)\n    {\n        // Check if a function can be called. Operators can call anythig, thus\n        // we should continue validation only for users.\n        if (!$this->getAuthenticationManager()->getOperator()) {\n            // A function is called by a user. We need to check that the thread\n            // is related with the user.\n            $arguments = $context->getArgumentsList($function);\n            $thread_id = $arguments['threadId'];\n            // As defined in Mibew\\API\\Interaction\\ChatInteraction \"threadid\"\n            // argument is mandatory, but some function allows it to be null. In\n            // such cases there is no thread and there is nothing to check.\n            if (!is_null($thread_id)) {\n                $is_own_thread = isset($_SESSION[SESSION_PREFIX . 'own_threads'])\n                    && in_array($thread_id, $_SESSION[SESSION_PREFIX . 'own_threads']);\n                if (!$is_own_thread) {\n                    throw new AccessDeniedException();\n                }\n            }\n        }\n\n        // The function can be called. Process it.\n        parent::processFunction($function, $context);\n    }\n\n    /**\n     * Update chat window state. API function\n     *\n     * Call periodically by chat window\n     * @param array $args Associative array of arguments. It must contains\n     *   following keys:\n     *    - 'threadId': Id of the thread related to chat window\n     *    - 'token': last thread token\n     *    - 'user': TRUE if window used by user and FALSE otherwise\n     *    - 'typed': indicates if user(or agent) typed\n     *    - 'lastId': id of the last sent to message\n     * @return array Array of results. It contains following keys:\n     *    - 'typing': indicates if another side of the conversation is typing\n     *      message\n     *    - 'canPost': indicates if agent(user can post message all the time)\n     *      can post the message\n     *    - 'threadState': current state of the thread. See Thread::STATE_*\n     *      constants for details.\n     *    - 'threadAgentId': ID of the agent that is currently related with the\n     *      thread.\n     */\n    protected function apiUpdate($args)\n    {\n        // Load thread\n        $thread = self::getThread($args['threadId'], $args['token']);\n\n        // Check variables\n        self::checkParams($args, array('user', 'typed'));\n\n        if (!$args['user']) {\n            $operator = $this->checkOperator();\n            $thread->checkForReassign($operator);\n        }\n\n        $thread->ping($args['user'], $args['typed']);\n\n        // Create requests key\n        $requests_key = false;\n        if ($args['user']) {\n            $requests_key = 'thread_user_' . $thread->id;\n        } else {\n            if ($operator['operatorid'] == $thread->agentId) {\n                $requests_key = 'thread_agent_' . $thread->id;\n            }\n        }\n\n        // Load stored requests\n        if ($requests_key !== false) {\n            $stored_requests = $this->getRequestsFromBuffer($requests_key);\n            if ($stored_requests !== false) {\n                $this->responses = array_merge($this->responses, $stored_requests);\n            }\n        }\n\n        // Get status values\n        if ($args['user']) {\n            $is_typing = abs($thread->lastPingAgent - time()) < Settings::get('connection_timeout')\n                && $thread->agentTyping;\n            // Users can post messages only when thread is open.\n            $can_post = $thread->state != Thread::STATE_CLOSED;\n        } else {\n            $is_typing = abs($thread->lastPingUser - time()) < Settings::get('connection_timeout')\n                && $thread->userTyping;\n            // Operators can post messages only to own threads.\n            $can_post = ($operator['operatorid'] == $thread->agentId);\n        }\n\n        return array(\n            'threadState' => $thread->state,\n            'threadAgentId' => $thread->agentId,\n            'typing' => $is_typing,\n            'canPost' => $can_post,\n        );\n    }\n\n    /**\n     * Send new messages to window. API function\n     *\n     * @param array $args Associative array of arguments. It must contains the\n     *   following keys:\n     *    - 'threadId': Id of the thread related to chat window\n     *    - 'token': last thread token\n     *    - 'user': TRUE if window used by user and FALSE otherwise\n     *    - 'lastId': last sent message id\n     */\n    protected function apiUpdateMessages($args)\n    {\n        // Load thread\n        $thread = self::getThread($args['threadId'], $args['token']);\n\n        // Check variables\n        self::checkParams($args, array('user', 'lastId'));\n\n        // Check access\n        if (!$args['user']) {\n            $this->checkOperator();\n        }\n\n        // Send new messages\n        $last_message_id = $args['lastId'];\n        $messages = array_map(\n            'sanitize_message',\n            $thread->getMessages($args['user'], $last_message_id)\n        );\n\n        return array(\n            'messages' => $messages,\n            'lastId' => $last_message_id,\n        );\n    }\n\n    /**\n     * Post message to thread. API function\n     *\n     * @param array $args Associative array of arguments. It must contains the\n     *   following keys:\n     *    - 'threadId': Id of the thread related to chat window\n     *    - 'token': last thread token\n     *    - 'user': TRUE if window used by user and FALSE otherwise\n     *    - 'message': posted message\n     * @throws ThreadProcessorException\n     */\n    protected function apiPost($args)\n    {\n        // Load thread\n        $thread = self::getThread($args['threadId'], $args['token']);\n\n        // Check variables\n        self::checkParams($args, array('user', 'message'));\n\n        // Get operator's array\n        if (!$args['user']) {\n            $operator = $this->checkOperator();\n            // Operators can post messages only to own threads.\n            $can_post = ($operator['operatorid'] == $thread->agentId);\n        } else {\n            // Users can post messages only when a thread is open.\n            $can_post = $thread->state != Thread::STATE_CLOSED;\n        }\n\n        if (!$can_post) {\n            throw new ThreadProcessorException(\n                \"Cannot send\",\n                ThreadProcessorException::ERROR_CANNOT_SEND\n            );\n        }\n\n        // Set fields\n        $kind = $args['user'] ? Thread::KIND_USER : Thread::KIND_AGENT;\n        if ($args['user']) {\n            $msg_options = array('name' => $thread->userName);\n        } else {\n            $msg_options = array(\n                'name' => $thread->agentName,\n                'operator_id' => $operator['operatorid'],\n            );\n        }\n\n        // Post message\n        $posted_id = $thread->postMessage($kind, $args['message'], $msg_options);\n\n        // Update shownMessageId\n        if ($args['user'] && $thread->shownMessageId == 0) {\n            $thread->shownMessageId = $posted_id;\n            $thread->save();\n        }\n    }\n\n    /**\n     * Rename user in the chat. API function\n     *\n     * @param array $args Associative array of arguments. It must contains the\n     *   following keys:\n     *    - 'threadId': Id of the thread related to chat window\n     *    - 'token': last thread token\n     *    - 'name': new user name\n     * @throws \\Mibew\\RequestProcessor\\ThreadProcessorException\n     */\n    protected function apiRename($args)\n    {\n        // Check rename possibility\n        if (Settings::get('usercanchangename') != \"1\") {\n            throw new ThreadProcessorException(\n                'server: forbidden to change name',\n                ThreadProcessorException::ERROR_FORBIDDEN_RENAME\n            );\n        }\n\n        // Load thread\n        $thread = self::getThread($args['threadId'], $args['token']);\n\n        // Check if new name exists\n        self::checkParams($args, array('name'));\n\n        //Rename user\n        $thread->renameUser($args['name']);\n        // Update user name in cookies\n        $data = strtr(base64_encode($args['name']), '+/=', '-_,');\n        setcookie(USERNAME_COOKIE_NAME, $data, time() + 60 * 60 * 24 * 365);\n    }\n\n    /**\n     * Close chat thread. API function\n     *\n     * @param array $args Associative array of arguments. It must contains the\n     *   following keys:\n     *    - 'threadId': Id of the thread related to chat window\n     *    - 'token': last thread token\n     *    - 'user': TRUE if window used by user and FALSE otherwise\n     * @return array Array of results. It contains following keys:\n     *    - 'closed': indicates if thread can be closed\n     */\n    protected function apiClose($args)\n    {\n        // Load thread and check thread's last token\n        $thread = self::getThread($args['threadId'], $args['token']);\n\n        // Check if new user variable exists\n        self::checkParams($args, array('user'));\n\n        // Load operator\n        if (!$args['user']) {\n            $operator = $this->checkOperator();\n        }\n\n        // Close thread\n        if ($args['user'] || $thread->agentId == $operator['operatorid']) {\n            $thread->close($args['user']);\n        }\n\n        return array(\n            'closed' => true,\n        );\n    }\n\n    /**\n     * Process submitted prechat survey.\n     *\n     * @param array $args Associative array of arguments. It must contains the\n     *   following keys:\n     *    - 'threadId': for this function this param equals to null;\n     *    - 'token': for this function this param equals to null;\n     *    - 'name': string, user name;\n     *    - 'email': string, user email;\n     *    - 'message': string, first user message;\n     *    - 'info': string, some info about user;\n     *    - 'referrer': page user came from;\n     *    - 'groupId': selected group id.\n     * @return array Array of results. It contains following keys:\n     *    - 'next': string, indicates what module run next;\n     *    - 'options': options array for next module.\n     */\n    protected function apiProcessSurvey($args)\n    {\n        $visitor = visitor_from_request();\n\n        // Get form values\n        $first_message = $args['message'];\n        $info = $args['info'];\n        $email = $args['email'];\n        $referrer = $args['referrer'];\n\n        // Verify group id\n        $group_id = 0;\n        $group = null;\n        if (Settings::get('enablegroups') == '1') {\n            if (preg_match(\"/^\\d{1,8}$/\", $args['groupId']) != 0) {\n                $group = group_by_id($args['groupId']);\n                if ($group) {\n                    $group_id = (int)$args['groupId'];\n                }\n            }\n        }\n\n        if (Settings::get('usercanchangename') == \"1\" && !empty($args['name'])) {\n            $newname = $args['name'];\n            if ($newname != $visitor['name']) {\n                $data = strtr(base64_encode($newname), '+/=', '-_,');\n                setcookie(USERNAME_COOKIE_NAME, $data, time() + 60 * 60 * 24 * 365);\n                $visitor['name'] = $newname;\n            }\n        }\n\n        // Check if there are online operators\n        if (!has_online_operators($group_id)) {\n            // Display leave message page\n            $client_data = setup_leavemessage(\n                $visitor['name'],\n                $email,\n                $group_id,\n                $info,\n                $referrer\n            );\n            $options = $client_data['leaveMessage'];\n            $options['page'] += setup_logo($group);\n\n            return array(\n                'next' => 'leaveMessage',\n                'options' => $options,\n            );\n        }\n\n        // Initialize dialog\n        $thread = chat_start_for_user(\n            $group_id,\n            false,\n            $visitor['id'],\n            $visitor['name'],\n            $referrer,\n            $info\n        );\n\n        // Send some messages\n        if ($email) {\n            $thread->postMessage(\n                Thread::KIND_FOR_AGENT,\n                getlocal('E-Mail: {0}', array(safe_htmlspecialchars($email)), get_current_locale(), true)\n            );\n        }\n\n        if ($first_message) {\n            $posted_id = $thread->postMessage(\n                Thread::KIND_USER,\n                $first_message,\n                array('name' => $visitor['name'])\n            );\n            $thread->shownMessageId = $posted_id;\n            $thread->save();\n        }\n\n        // Prepare chat options\n        $client_data = setup_chatview_for_user(\n            $this->getRouter(),\n            $this->getAssetManager()->getUrlGenerator(),\n            $this->currentRequest,\n            $thread\n        );\n        $options = $client_data['chat'];\n        $options['page'] += setup_logo($group);\n\n        return array(\n            'next' => 'chat',\n            'options' => $options,\n        );\n    }\n\n    /**\n     * Process submitted leave message form.\n     *\n     * Send message to operator email and create special mail thread.\n     * @param array $args Associative array of arguments. It must contains the\n     *   following keys:\n     *    - 'threadId': for this function this param equals to null;\n     *    - 'token': for this function this param equals to null;\n     *    - 'name': string, user name;\n     *    - 'email': string, user email;\n     *    - 'message': string, user message;\n     *    - 'info': string, some info about user;\n     *    - 'referrer': string, page user came from;\n     *    - 'captcha': string, captcha value;\n     *    - 'groupId': selected group id.\n     *\n     * @throws \\Mibew\\RequestProcessor\\ThreadProcessorException Can throw an\n     *   exception if captcha or email is wrong.\n     */\n    protected function apiProcessLeaveMessage($args)\n    {\n        // Check captcha\n        if (Settings::get('enablecaptcha') == '1' && can_show_captcha()) {\n            $captcha = $args['captcha'];\n            $original = isset($_SESSION[SESSION_PREFIX . 'mibew_captcha'])\n                ? $_SESSION[SESSION_PREFIX . 'mibew_captcha']\n                : '';\n            unset($_SESSION[SESSION_PREFIX . 'mibew_captcha']);\n            if (empty($original) || empty($captcha) || $captcha != $original) {\n                throw new ThreadProcessorException(\n                    getlocal('The letters you typed don\\'t match the letters that were shown in the picture.'),\n                    ThreadProcessorException::ERROR_WRONG_CAPTCHA\n                );\n            }\n        }\n\n        // Get form fields\n        $email = $args['email'];\n        $name = $args['name'];\n        $message = $args['message'];\n        $info = $args['info'];\n        $referrer = $args['referrer'];\n\n        if (!MailUtils::isValidAddress($email)) {\n            throw new ThreadProcessorException(\n                wrong_field(\"Your email\"),\n                ThreadProcessorException::ERROR_WRONG_EMAIL\n            );\n        }\n\n        // Verify group id\n        $group_id = 0;\n        if (Settings::get('enablegroups') == '1') {\n            if (preg_match(\"/^\\d{1,8}$/\", $args['groupId']) != 0) {\n                $group = group_by_id($args['groupId']);\n                if ($group) {\n                    $group_id = (int)$args['groupId'];\n                }\n            }\n        }\n\n        // Create thread for left message\n        $remote_host = get_remote_host();\n        $user_browser = $_SERVER['HTTP_USER_AGENT'];\n        $visitor = visitor_from_request();\n\n        // Get message locale\n        $message_locale = Settings::get('left_messages_locale');\n        if (!locale_is_available($message_locale)) {\n            $message_locale = get_home_locale();\n        }\n\n        // Create thread\n        $thread = new Thread();\n        $thread->groupId = $group_id;\n        $thread->userName = $name;\n        $thread->remote = $remote_host;\n        $thread->referer = $referrer;\n        $thread->locale = get_current_locale();\n        $thread->userId = $visitor['id'];\n        $thread->userAgent = $user_browser;\n        $thread->state = Thread::STATE_LEFT;\n        $thread->closed = time();\n        $thread->save();\n\n        // Send some messages\n        if ($referrer) {\n            $thread->postMessage(\n                Thread::KIND_FOR_AGENT,\n                getlocal('Visitor came from page {0}', array(safe_htmlspecialchars($referrer)), get_current_locale(), true)\n            );\n        }\n        if ($email) {\n            $thread->postMessage(\n                Thread::KIND_FOR_AGENT,\n                getlocal('E-Mail: {0}', array(safe_htmlspecialchars($email)), get_current_locale(), true)\n            );\n        }\n        if ($info) {\n            $thread->postMessage(\n                Thread::KIND_FOR_AGENT,\n                getlocal('Info: {0}', array(safe_htmlspecialchars($info)), get_current_locale(), true)\n            );\n        }\n        $thread->postMessage(Thread::KIND_USER, $message, array('name' => $name));\n\n        // Get email for message\n        $inbox_mail = get_group_email($group_id);\n\n        if (empty($inbox_mail)) {\n            $inbox_mail = Settings::get('email');\n        }\n\n        // Send email\n        if ($inbox_mail) {\n            // Prepare message to send by email\n            $mail_template = MailTemplate::loadByName('leave_message', $message_locale);\n            if (!$mail_template) {\n                trigger_error(\n                    'Cannot send e-mail because \"leave_message\" mail template cannot be loaded.',\n                    E_USER_WARNING\n                );\n\n                return;\n            }\n\n            $subject = $mail_template->buildSubject(array($args['name']));\n            $body = $mail_template->buildBody(array(\n                $args['name'],\n                $email,\n                $message,\n                ($info ? $info . \"\\n\" : \"\"),\n            ));\n\n            // Send\n            $this->getMailerFactory()->getMailer()->send(\n                MailUtils::buildMessage($inbox_mail, $email, $subject, $body)\n            );\n        }\n    }\n\n    /**\n     * Returns relative path of the avatar for operator related with the thread.\n     *\n     * @param array $args Associative array of arguments. It must contains the\n     *   following keys:\n     *    - 'threadId': ID of the thread the avatar should be retrieved for.\n     *    - 'token': Token of the thread.\n     * @return array Array of results. It contains following keys:\n     *    - 'imageLink': string, relative path to operator's avatar.\n     */\n    protected function apiGetAvatar($args)\n    {\n        // Load thread and check thread's last token\n        $thread = self::getThread($args['threadId'], $args['token']);\n\n        $image_link = false;\n        if ($thread->agentId) {\n            $operator = operator_by_id($thread->agentId);\n            if ($operator['vcavatar']) {\n                $url_generator = $this->getAssetManager()->getUrlGenerator();\n                $image_link = $url_generator->generate($operator['vcavatar']);\n            }\n        }\n\n        return array('imageLink' => $image_link);\n    }\n}\n", "<?php\n/*\n * This file is a part of Mibew Messenger.\n *\n * Copyright 2005-2020 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nnamespace Mibew;\n\nuse Mibew\\EventDispatcher\\EventDispatcher;\nuse Mibew\\EventDispatcher\\Events;\n\n/**\n * Represents a chat thread\n *\n * @todo Think about STATE_* and KIND_* constant systems and may be simplifies\n *   them.\n */\nclass Thread\n{\n    /**\n     * User in the users queue\n     */\n    const STATE_QUEUE = 0;\n    /**\n     * User waiting for operator\n     */\n    const STATE_WAITING = 1;\n    /**\n     * Conversation in progress\n     */\n    const STATE_CHATTING = 2;\n    /**\n     * Thread closed\n     */\n    const STATE_CLOSED = 3;\n    /**\n     * Thread just created\n     */\n    const STATE_LOADING = 4;\n    /**\n     * User left message without starting a conversation\n     */\n    const STATE_LEFT = 5;\n    /**\n     * Visitor was invited to chat by operator\n     */\n    const STATE_INVITED = 6;\n\n    /**\n     * Visitor was not invited to chat\n     */\n    const INVITATION_NOT_INVITED = 0;\n    /**\n     * Operator invited visitor and wait for reaction.\n     */\n    const INVITATION_WAIT = 1;\n    /**\n     * Invitation was accepted by visitor\n     */\n    const INVITATION_ACCEPTED = 2;\n    /**\n     * Invitation was rejected by visitor\n     */\n    const INVITATION_REJECTED = 3;\n    /**\n     * Invitation was ignored by visitor. Invitation was automatically closed.\n     */\n    const INVITATION_IGNORED = 4;\n\n    /**\n     * Message sent by user\n     */\n    const KIND_USER = 1;\n    /**\n     * Message sent by operator\n     */\n    const KIND_AGENT = 2;\n    /**\n     * Hidden system message to operator\n     */\n    const KIND_FOR_AGENT = 3;\n    /**\n     * System messages for user and operator\n     */\n    const KIND_INFO = 4;\n    /**\n     * Message for user if operator have connection problems\n     */\n    const KIND_CONN = 5;\n    /**\n     * System message about some events (like rename).\n     */\n    const KIND_EVENTS = 6;\n    /**\n     * Message sent by a plugin.\n     */\n    const KIND_PLUGIN = 7;\n\n    /**\n     * ID of the thread.\n     * @var int|bool\n     */\n    public $id;\n\n    /**\n     * Number of the last revision\n     * @var int\n     */\n    public $lastRevision;\n\n    /**\n     * State of the thread. See Thread::STATE_* constants for details.\n     * @var int\n     */\n    public $state;\n\n    /**\n     * State of the invitation. See Thread::INVITATION_* constants for details.\n     * @var int\n     */\n    public $invitationState;\n\n    /**\n     * The last token of the chat thread.\n     * @var string\n     */\n    public $lastToken;\n\n    /**\n     * ID of the next agent(agent that changes the current agent in the chat).\n     * @var int\n     */\n    public $nextAgent;\n\n    /**\n     * ID of the group related with the thread.\n     *\n     * If there is no attached group the value should be equal to 0 (zero).\n     *\n     * @var int\n     */\n    public $groupId;\n\n    /**\n     * ID of the last shown message.\n     * @var int\n     */\n    public $shownMessageId;\n\n    /**\n     * Count of user's messages related to the thread.\n     * @var int\n     */\n    public $messageCount;\n\n    /**\n     * Unix timestamp of the moment the thread was created.\n     * @var int\n     */\n    public $created;\n\n    /**\n     * Unix timestamp of the moment the thread was modified last time.\n     * @var int\n     */\n    public $modified;\n\n    /**\n     * Unix timestamp of the moment when the thread was closed.\n     * @var int\n     */\n    public $closed;\n\n    /**\n     * Unix timestamp of the moment the chat related to the thread was started.\n     * @var int\n     */\n    public $chatStarted;\n\n    /**\n     * ID of an operator who take part in the chat.\n     * @var int\n     */\n    public $agentId;\n\n    /**\n     * Name of an operator who take part in the chat.\n     * @var string\n     */\n    public $agentName;\n\n    /**\n     * Indicates if the opertor who take part in the chat is typing or not.\n     *\n     * It is equal to \"1\" if the operator was typing at the last ping time and\n     * \"0\" otherwise.\n     * @var int\n     */\n    public $agentTyping;\n\n    /**\n     * Unix timestamp of the moment the operator was pinged for the last time.\n     * @var int\n     */\n    public $lastPingAgent;\n\n    /**\n     * Locale code of the chat thread.\n     * @var string\n     */\n    public $locale;\n\n    /**\n     * ID of a user who take part in the chat.\n     * @var string\n     */\n    public $userId;\n\n    /**\n     * Name of a user who take part in the chat.\n     * @var string\n     */\n    public $userName;\n\n    /**\n     * Indicates if the user who take part in the chat is typing or not.\n     *\n     * It is equal to \"1\" if the user was typing at the last ping time and \"0\"\n     * otherwise\n     * @var int\n     */\n    public $userTyping;\n\n    /**\n     * Unix timestamp of the moment the user was pinged for the last time.\n     * @var int\n     */\n    public $lastPingUser;\n\n    /**\n     * User's IP.\n     * @var string\n     */\n    public $remote;\n\n    /**\n     * Content of HTTP \"Referer\" header for the user.\n     * @var string\n     */\n    public $referer;\n\n    /**\n     * Content of HTTP \"User-agent\" header for the user.\n     * @var string\n     */\n    public $userAgent;\n\n    /**\n     * Create thread object from database info.\n     *\n     * @param array $thread_info Associative array of Thread info from database.\n     *   It must contains ALL thread table's\n     *   FIELDS from the database.\n     * @return boolean|Thread Returns an object of the Thread class or boolean\n     *   false on failure\n     */\n    public static function createFromDbInfo($thread_info)\n    {\n        // Create new empty thread\n        $thread = new self();\n        $thread->populateFromDbFields($thread_info);\n\n        return $thread;\n    }\n\n    /**\n     * Load thread from database\n     *\n     * @param int $id ID of the thread to load\n     * @return boolean|Thread Returns an object of the Thread class or boolean\n     *   false on failure\n     */\n    public static function load($id, $last_token = null)\n    {\n        // Check $id\n        if (empty($id)) {\n            return false;\n        }\n\n        // Load thread\n        $thread_info = Database::getInstance()->query(\n            \"SELECT * FROM {thread} WHERE threadid = :threadid\",\n            array(':threadid' => $id),\n            array('return_rows' => Database::RETURN_ONE_ROW)\n        );\n\n        // There is no thread with such id in database\n        if (!$thread_info) {\n            return;\n        }\n\n        // Create new empty thread and populate it with the values from database\n        $thread = new self();\n        $thread->populateFromDbFields($thread_info);\n\n        // Check last token\n        if (!is_null($last_token)) {\n            if ($thread->lastToken != $last_token) {\n                return false;\n            }\n        }\n\n        return $thread;\n    }\n\n    /**\n     * Reopen thread and send message about it\n     *\n     * @return boolean|Thread Boolean FALSE on failure or thread object on\n     *   success\n     */\n    public static function reopen($id)\n    {\n        // Load thread\n        $thread = self::load($id);\n\n        // Check if user and agent gone\n        $user_gone = abs($thread->lastPingUser - time()) > Settings::get('thread_lifetime');\n        $agent_gone = abs($thread->lastPingAgent - time()) > Settings::get('thread_lifetime');\n        if (Settings::get('thread_lifetime') != 0 && $user_gone && $agent_gone) {\n            unset($thread);\n\n            return false;\n        }\n\n        // Check if thread closed\n        if ($thread->state == self::STATE_CLOSED || $thread->state == self::STATE_LEFT) {\n            unset($thread);\n\n            return false;\n        }\n\n        // Reopen thread\n        if ($thread->state == self::STATE_WAITING) {\n            $thread->nextAgent = 0;\n            $thread->save();\n        }\n\n        // Send message\n        $thread->postMessage(\n            self::KIND_EVENTS,\n            getlocal('Visitor joined chat again', null, $thread->locale, true)\n        );\n\n        return $thread;\n    }\n\n    /**\n     * Close all old threads that were not closed by some reasons.\n     */\n    public static function closeOldThreads()\n    {\n        if (Settings::get('thread_lifetime') == 0) {\n            // Threads live forever.\n            return;\n        }\n\n        // We need to run only one instance of cleaning process.\n        $lock = new ProcessLock('threads_close_old');\n\n        if ($lock->get()) {\n            $query = \"SELECT * FROM {thread} \"\n                . \"WHERE istate <> :state_closed \"\n                    . \"AND istate <> :state_left \"\n                    // Check created timestamp\n                    . \"AND ABS(:now - dtmcreated) > :thread_lifetime \"\n                    // Check pings\n                    . \"AND ( \"\n                        . \"( \"\n                            // Both user and operator have no connection\n                            // problems. Check all pings.\n                            . \"lastpingagent <> 0 \"\n                            . \"AND lastpinguser <> 0 \"\n                            . \"AND ABS(:now - lastpinguser) > :thread_lifetime \"\n                            . \"AND ABS(:now - lastpingagent) > :thread_lifetime \"\n                        . \") OR ( \"\n                            // Only operator have connection problems.\n                            // Check user's ping.\n                            . \"lastpingagent = 0 \"\n                            . \"AND lastpinguser <> 0 \"\n                            . \"AND ABS(:now - lastpinguser) > :thread_lifetime \"\n                        . \") OR ( \"\n                            // Only user have connection problems.\n                            // Check operator's ping.\n                            . \"lastpinguser = 0 \"\n                            . \"AND lastpingagent <> 0 \"\n                            . \"AND ABS(:now - lastpingagent) > :thread_lifetime \"\n                        . \") OR ( \"\n                            // Both user and operator have connection problems.\n                            // Just close thread.\n                            . \"lastpinguser = 0 \"\n                            . \"AND lastpingagent = 0 \"\n                        . \") \"\n                    . \")\";\n\n            // Get appropriate threads\n            $now = time();\n            $rows = Database::getInstance()->query(\n                $query,\n                array(\n                    ':now' => $now,\n                    ':state_closed' => self::STATE_CLOSED,\n                    ':state_left' => self::STATE_LEFT,\n                    ':thread_lifetime' => Settings::get('thread_lifetime'),\n                ),\n                array('return_rows' => Database::RETURN_ALL_ROWS)\n            );\n\n            // Perform the cleaning\n            if (count($rows) > 0) {\n                $revision = self::nextRevision();\n                foreach ($rows as $row) {\n                    $thread = Thread::createFromDbInfo($row);\n                    $thread->lastRevision = $revision;\n                    $thread->modified = $now;\n                    $thread->closed = $now;\n                    $thread->state = self::STATE_CLOSED;\n                    $thread->save(false);\n                    unset($thread);\n                }\n            }\n\n            // Release the lock\n            $lock->release();\n        }\n    }\n\n    /**\n     * Check if connection limit reached\n     *\n     * @param string $remote User IP\n     * @return boolean TRUE if connection limit reached and FALSE otherwise\n     */\n    public static function connectionLimitReached($remote)\n    {\n        if (Settings::get('max_connections_from_one_host') == 0) {\n            return false;\n        }\n\n        $result = Database::getInstance()->query(\n            \"SELECT COUNT(*) AS opened FROM {thread} WHERE remote = ? AND istate <> ? AND istate <> ?\",\n            array(\n                $remote,\n                Thread::STATE_CLOSED,\n                Thread::STATE_LEFT,\n            ),\n            array('return_rows' => Database::RETURN_ONE_ROW)\n        );\n\n        if ($result && isset($result['opened'])) {\n            return $result['opened'] >= Settings::get('max_connections_from_one_host');\n        }\n\n        return false;\n    }\n\n    /**\n     * Class constructor.\n     */\n    public function __construct()\n    {\n        // Set the defaults\n        $this->id = false;\n        $this->userName = '';\n        $this->agentId = 0;\n        $this->created = time();\n        $this->modified = time();\n        $this->chatStarted = 0;\n        $this->closed = 0;\n        $this->lastRevision = 0;\n        $this->state = self::STATE_QUEUE;\n        $this->invitationState = self::INVITATION_NOT_INVITED;\n        $this->lastToken = self::nextToken();\n        $this->nextAgent = 0;\n        $this->lastPingAgent = 0;\n        $this->lastPingUser = 0;\n        $this->userTyping = 0;\n        $this->agentTyping = 0;\n        $this->shownMessageId = 0;\n        $this->messageCount = 0;\n        $this->groupId = 0;\n    }\n\n    /**\n     * Remove thread from database\n     *\n     * Triggers {@link \\Mibew\\EventDispatcher\\Events::THREAD_DELETE} event.\n     */\n    public function delete()\n    {\n        Database::getInstance()->query(\n            \"DELETE FROM {thread} WHERE threadid = :id LIMIT 1\",\n            array(':id' => $this->id)\n        );\n\n        $args = array('id' => $this->id);\n        EventDispatcher::getInstance()->triggerEvent(Events::THREAD_DELETE, $args);\n    }\n\n    /**\n     * Ping the thread.\n     *\n     * Updates ping time for conversation members and sends messages about\n     * connection problems.\n     *\n     * @param boolean $is_user Indicates user or operator pings thread. Boolean\n     *   true for user and boolean false otherwise.\n     * @param boolean $is_typing Indicates if user or operator is typing a\n     *   message.\n     */\n    public function ping($is_user, $is_typing)\n    {\n        // Indicates if revision ID of the thread should be updated on save.\n        // Update revision leads to rerender thread in threads list at client\n        // side. Do it on every ping is too costly.\n        $update_revision = false;\n        // Last ping time of other side\n        $last_ping_other_side = 0;\n        // Update last ping time\n        if ($is_user) {\n            $last_ping_other_side = $this->lastPingAgent;\n            $this->lastPingUser = time();\n            $this->userTyping = $is_typing ? \"1\" : \"0\";\n        } else {\n            $last_ping_other_side = $this->lastPingUser;\n            $this->lastPingAgent = time();\n            $this->agentTyping = $is_typing ? \"1\" : \"0\";\n        }\n\n        // Update thread state for the first user ping\n        if ($this->state == self::STATE_LOADING && $is_user) {\n            $this->state = self::STATE_QUEUE;\n            $this->save();\n            return;\n        }\n\n        // Check if other side of the conversation have connection problems\n        if ($last_ping_other_side > 0 && abs(time() - $last_ping_other_side) > Settings::get('connection_timeout')) {\n            // Connection problems detected\n            if ($is_user) {\n                // _Other_ side is operator\n                // Update operator's last ping time\n                $this->lastPingAgent = 0;\n\n                // Check if user chatting at the moment\n                if ($this->state == self::STATE_CHATTING) {\n                    // Send message to user\n                    $message_to_post = getlocal(\n                        'Your operator has connection issues. We have moved you to a priorty position in the queue. Sorry for keeping you waiting.',\n                        null,\n                        $this->locale,\n                        true\n                    );\n                    $this->postMessage(\n                        self::KIND_CONN,\n                        $message_to_post,\n                        array('created' => $last_ping_other_side + Settings::get('connection_timeout'))\n                    );\n\n                    // And update thread\n                    $this->state = self::STATE_WAITING;\n                    $this->nextAgent = 0;\n\n                    // Significant fields of the thread (state and nextAgent)\n                    // are changed. Update revision ID on save.\n                    $update_revision = true;\n                }\n            } else {\n                // _Other_ side is user\n                // Update user's last ping time\n                $this->lastPingUser = 0;\n\n                // And send a message to operator.\n                if ($this->state == self::STATE_CHATTING) {\n                    $message_to_post = getlocal(\n                        'Visitor closed chat window',\n                        null,\n                        $this->locale,\n                        true\n                    );\n                    $this->postMessage(\n                        self::KIND_FOR_AGENT,\n                        $message_to_post,\n                        array('created' => $last_ping_other_side + Settings::get('connection_timeout'))\n                    );\n                }\n            }\n        }\n\n        $this->save($update_revision);\n    }\n\n    /**\n     * Save the thread to the database\n     *\n     * Triggers {@link \\Mibew\\EventDispatcher\\Events::THREAD_UPDATE} and\n     * {@link \\Mibew\\EventDispatcher\\Events::THREAD_CREATE} events.\n     *\n     * @param boolean $update_revision Indicates if last modified time and last\n     *   revision should be updated.\n     */\n    public function save($update_revision = true)\n    {\n        // Update modification time and revision number only if needed\n        if ($update_revision) {\n            $this->lastRevision = $this->nextRevision();\n            $this->modified = time();\n        }\n\n        $db = Database::getInstance();\n        if (!$this->id) {\n            $db->query(\n                ('INSERT INTO {thread} ('\n                    . 'username, userid, agentname, agentid, '\n                    . 'dtmcreated, dtmchatstarted, dtmmodified, dtmclosed, '\n                    . 'lrevision, istate, invitationstate, ltoken, remote, '\n                    . 'referer, nextagent, locale, lastpinguser, '\n                    . 'lastpingagent, usertyping, agenttyping, '\n                    . 'shownmessageid, useragent, messagecount, groupid'\n                . ') VALUES ('\n                    . ':user_name, :user_id, :agent_name, :agent_id, '\n                    . ':created, :chat_started, :modified, :closed, '\n                    . ':revision, :state, :invitation_state, :token, :remote, '\n                    . ':referer, :next_agent, :locale, :last_ping_user, '\n                    . ':last_ping_agent, :user_typing, :agent_typing, '\n                    . ':shown_message_id, :user_agent, :message_count, :group_id '\n                . ')'),\n                array(\n                    ':user_name' => $this->userName,\n                    ':user_id' => $this->userId,\n                    ':agent_name' => $this->agentName,\n                    ':agent_id' => $this->agentId,\n                    ':created' => $this->created,\n                    ':chat_started' => $this->chatStarted,\n                    ':modified' => $this->modified,\n                    ':closed' => $this->closed,\n                    ':revision' => $this->lastRevision,\n                    ':state' => $this->state,\n                    ':invitation_state' => $this->invitationState,\n                    ':token' => $this->lastToken,\n                    ':remote' => $this->remote,\n                    ':referer' => $this->referer,\n                    ':next_agent' => $this->nextAgent,\n                    ':locale' => $this->locale,\n                    ':last_ping_user' => $this->lastPingUser,\n                    ':last_ping_agent' => $this->lastPingAgent,\n                    ':user_typing' => $this->userTyping,\n                    ':agent_typing' => $this->agentTyping,\n                    ':shown_message_id' => $this->shownMessageId,\n                    ':user_agent' => $this->userAgent,\n                    ':message_count' => $this->messageCount,\n                    ':group_id' => $this->groupId,\n                )\n            );\n            $this->id = $db->insertedId();\n\n            $args = array('thread' => $this);\n            EventDispatcher::getInstance()->triggerEvent(Events::THREAD_CREATE, $args);\n        } else {\n            // Get the original state of the thread to trigger event later.\n            $original_thread = Thread::load($this->id);\n\n            $db->query(\n                ('UPDATE {thread} SET '\n                    . 'username = :user_name, userid = :user_id, '\n                    . 'agentname = :agent_name, agentid = :agent_id, '\n                    . 'dtmcreated = :created, dtmchatstarted = :chat_started, '\n                    . 'dtmmodified = :modified, dtmclosed = :closed, '\n                    . 'lrevision = :revision, istate = :state, '\n                    . 'invitationstate = :invitation_state, ltoken = :token, '\n                    . 'remote = :remote, referer = :referer, '\n                    . 'nextagent = :next_agent, locale = :locale, '\n                    . 'lastpinguser = :last_ping_user, '\n                    . 'lastpingagent = :last_ping_agent, '\n                    . 'usertyping = :user_typing, agenttyping = :agent_typing, '\n                    . 'shownmessageid = :shown_message_id, '\n                    . 'useragent = :user_agent, messagecount = :message_count, '\n                    . 'groupid = :group_id '\n                . 'WHERE threadid = :thread_id'),\n                array(\n                    ':thread_id' => $this->id,\n                    ':user_name' => $this->userName,\n                    ':user_id' => $this->userId,\n                    ':agent_name' => $this->agentName,\n                    ':agent_id' => $this->agentId,\n                    ':created' => $this->created,\n                    ':chat_started' => $this->chatStarted,\n                    ':modified' => $this->modified,\n                    ':closed' => $this->closed,\n                    ':revision' => $this->lastRevision,\n                    ':state' => $this->state,\n                    ':invitation_state' => $this->invitationState,\n                    ':token' => $this->lastToken,\n                    ':remote' => $this->remote,\n                    ':referer' => $this->referer,\n                    ':next_agent' => $this->nextAgent,\n                    ':locale' => $this->locale,\n                    ':last_ping_user' => $this->lastPingUser,\n                    ':last_ping_agent' => $this->lastPingAgent,\n                    ':user_typing' => $this->userTyping,\n                    ':agent_typing' => $this->agentTyping,\n                    ':shown_message_id' => $this->shownMessageId,\n                    ':user_agent' => $this->userAgent,\n                    ':message_count' => $this->messageCount,\n                    ':group_id' => $this->groupId,\n                )\n            );\n\n            $args = array(\n                'thread' => $this,\n                'original_thread' => $original_thread,\n            );\n            EventDispatcher::getInstance()->triggerEvent(Events::THREAD_UPDATE, $args);\n        }\n    }\n\n    /**\n     * Check if thread is reassigned for another operator\n     *\n     * Updates thread info, send events messages and avatar message to user.\n     *\n     * @param array $operator Operator for test\n     */\n    public function checkForReassign($operator)\n    {\n        $operator_name = ($this->locale == get_home_locale())\n            ? $operator['vclocalename']\n            : $operator['vccommonname'];\n\n        $is_operator_correct = $this->nextAgent == $operator['operatorid']\n            || $this->agentId == $operator['operatorid'];\n\n        if ($this->state == self::STATE_WAITING && $is_operator_correct) {\n            // Prepare message\n            if ($this->nextAgent == $operator['operatorid']) {\n                $message_to_post = getlocal(\n                    \"Operator <strong>{0}</strong> changed operator <strong>{1}</strong>\",\n                    array(safe_htmlspecialchars($operator_name), safe_htmlspecialchars($this->agentName)),\n                    $this->locale,\n                    true\n                );\n            } else {\n                $message_to_post = getlocal(\n                    \"Operator {0} is back\",\n                    array(safe_htmlspecialchars($operator_name)),\n                    $this->locale,\n                    true\n                );\n            }\n\n            // Update thread info\n            $this->state = self::STATE_CHATTING;\n            $this->nextAgent = 0;\n            $this->agentId = $operator['operatorid'];\n            $this->agentName = $operator_name;\n            $this->save();\n\n            // Send messages\n            $this->postMessage(self::KIND_EVENTS, $message_to_post);\n        }\n    }\n\n    /**\n     * Load messages from database corresponding to the thread those ID's more\n     * than $lastid\n     *\n     * @param boolean $is_user Boolean TRUE if messages loads for user\n     *   and boolean FALSE if they loads for operator.\n     * @param int $lastid ID of the last loaded message.\n     * @return array Array of messages. Every message is associative array with\n     *   following keys:\n     *    - 'id': int, message id;\n     *    - 'kind': int, message kind, see Thread::KIND_* for details;\n     *    - 'created': int, unix timestamp when message was created;\n     *    - 'name': string, name of sender;\n     *    - 'message': string, message text;\n     *    - 'plugin': string, name of the plugin which sent the message or an\n     *      empty string if message was not sent by a plugin.\n     *    - 'data' array, arbitrary data attached to the message\n     * @see Thread::postMessage()\n     */\n    public function getMessages($is_user, &$last_id)\n    {\n        $db = Database::getInstance();\n\n        // Load messages\n        $query = \"SELECT messageid AS id, ikind AS kind, dtmcreated AS created, \"\n                . \" tname AS name, tmessage AS message, plugin, data \"\n            . \"FROM {message} \"\n            . \"WHERE threadid = :threadid AND messageid > :lastid \"\n                . ($is_user ? \"AND ikind <> \" . self::KIND_FOR_AGENT : \"\")\n            . \" ORDER BY messageid\";\n\n        $messages = $db->query(\n            $query,\n            array(\n                ':threadid' => $this->id,\n                ':lastid' => $last_id,\n            ),\n            array('return_rows' => Database::RETURN_ALL_ROWS)\n        );\n\n        foreach ($messages as $key => $msg) {\n            // Process data attached to the message\n            if (!empty($messages[$key]['data'])) {\n                $messages[$key]['data'] = unserialize(\n                    $messages[$key]['data']\n                );\n            } else {\n                $messages[$key]['data'] = array();\n            }\n        }\n\n        // Trigger the \"alter\" event\n        $args = array(\n            'messages' => $messages,\n            'thread' => $this,\n        );\n        EventDispatcher::getInstance()->triggerEvent(Events::THREAD_GET_MESSAGES_ALTER, $args);\n        $altered_messages = $args['messages'];\n\n        // Get ID of the last message\n        foreach ($altered_messages as $msg) {\n            if ($msg['id'] > $last_id) {\n                $last_id = $msg['id'];\n            }\n        }\n\n        return $altered_messages;\n    }\n\n    /**\n     * Send the messsage\n     *\n     * One can attach arbitrary data to the message by setting 'data' item\n     * in the $options array. DO NOT serialize data manually - it will be\n     * automatically converted to array and serialized before save in database\n     * and unserialized after retrieve form database.\n     *\n     * One can also set plugin item of the $options array to indicate that\n     * message was sent by a plugin.\n     *\n     * Triggers {@link \\Mibew\\EventDispatcher\\Events::THREAD_POST_MESSAGE}\n     * event.\n     *\n     * @param int $kind Message kind. One of the Thread::KIND_*\n     * @param string $message Message body\n     * @param array $options List of additional options. It may contain\n     *   following items:\n     *    - 'name': string, name of the message sender.\n     *    - 'operator_id': int, ID of the operator who sent the message. For\n     *      system messages do not set this field.\n     *    - 'created': int, unix timestamp of the send time. If you want to set\n     *      current time do not set this field.\n     *    - 'plugin': string, name of the plugin which sent the message. If\n     *      message was not sent by a plugin do not set this field.\n     *    - 'data': array with arbitrary data related with message. This value\n     *      will be converted to array and serialized before save. If there is\n     *      no such data do not set this field.\n     *\n     * @return int Message ID\n     *\n     * @see Thread::KIND_USER\n     * @see Thread::KIND_AGENT\n     * @see Thread::KIND_FOR_AGENT\n     * @see Thread::KIND_INFO\n     * @see Thread::KIND_CONN\n     * @see Thread::KIND_EVENTS\n     * @see Thread::KIND_PLUGIN\n     * @see Thread::getMessages()\n     */\n    public function postMessage($kind, $message, $options = array())\n    {\n        $event_args = array(\n            'thread' => $this,\n            'message_kind' => $kind,\n            'message_body' => $message,\n            'message_options' => (is_array($options) ? $options : array()),\n        );\n        EventDispatcher::getInstance()->triggerEvent(Events::THREAD_POST_MESSAGE, $event_args);\n\n        // Send message\n        return $this->saveMessage(\n            $event_args['message_kind'],\n            $event_args['message_body'],\n            $event_args['message_options']\n        );\n    }\n\n    /**\n     * Close thread and send closing messages to the conversation members\n     *\n     * Triggers {@link \\Mibew\\EventDispatcher\\Events::THREAD_CLOSE} event.\n     *\n     * @param boolean $is_user Boolean TRUE if user initiate thread closing or\n     *   boolean FALSE otherwise\n     */\n    public function close($is_user)\n    {\n        // Send message about closing\n        if ($is_user) {\n            $this->postMessage(\n                self::KIND_EVENTS,\n                getlocal(\n                    \"Visitor {0} left the chat\",\n                    array(safe_htmlspecialchars($this->userName)),\n                    $this->locale,\n                    true\n                )\n            );\n        } else {\n            if ($this->state == self::STATE_INVITED) {\n                $this->postMessage(\n                    self::KIND_FOR_AGENT,\n                    getlocal(\n                        'Operator canceled invitation',\n                        null,\n                        $this->locale,\n                        true\n                    )\n                );\n            } else {\n                $this->postMessage(\n                    self::KIND_EVENTS,\n                    getlocal(\n                        \"Operator {0} left the chat\",\n                        array(safe_htmlspecialchars($this->agentName)),\n                        $this->locale,\n                        true\n                    )\n                );\n            }\n        }\n\n        // Get messages count\n        $db = Database::getInstance();\n\n        list($message_count) = $db->query(\n            (\"SELECT COUNT(*) FROM {message} \"\n                . \"WHERE {message}.threadid = :threadid AND ikind = :kind_user\"),\n            array(\n                ':threadid' => $this->id,\n                ':kind_user' => Thread::KIND_USER,\n            ),\n            array(\n                'return_rows' => Database::RETURN_ONE_ROW,\n                'fetch_type' => Database::FETCH_NUM,\n            )\n        );\n\n        // Close thread if it's not already closed\n        if ($this->state != self::STATE_CLOSED) {\n            $this->state = self::STATE_CLOSED;\n            $this->closed = time();\n            $this->messageCount = $message_count;\n            $this->save();\n\n            $args = array('thread' => $this);\n            EventDispatcher::getInstance()->triggerEvent(Events::THREAD_CLOSE, $args);\n        }\n    }\n\n    /**\n     * Assign operator to thread\n     *\n     * @param array $operator Operator who try to take thread\n     * @return boolean Boolean TRUE on success or FALSE on failure\n     */\n    public function take($operator)\n    {\n        // There are states which forbids thread taking. Make sure the current\n        // state is not one of them.\n        $forbidden_states = array(\n            self::STATE_CLOSED,\n            self::STATE_LEFT,\n            self::STATE_INVITED,\n        );\n        if (in_array($this->state, $forbidden_states)) {\n            return false;\n        }\n\n        $is_operator_changed = ($operator['operatorid'] != $this->agentId)\n            // Only these states allow operators changing. In other states\n            // changing of operator's ID is treated in different ways (join or\n            // come back).\n            && ($this->state == self::STATE_WAITING || $this->state == self::STATE_CHATTING);\n\n        // For these states we assume that the thread has no operator yet. The\n        // check for operator changing is skipped because it will always\n        // return positive result.\n        $is_operator_joined = ($this->state == self::STATE_LOADING)\n            || ($this->state == self::STATE_QUEUE);\n\n        $is_operator_back = ($this->state == self::STATE_WAITING)\n            && ($operator['operatorid'] == $this->agentId);\n\n        $message = '';\n        $operator_name = ($this->locale == get_home_locale())\n            ? $operator['vclocalename']\n            : $operator['vccommonname'];\n\n        if ($is_operator_changed) {\n            $message = getlocal(\n                \"Operator <strong>{0}</strong> changed operator <strong>{1}</strong>\",\n                array(safe_htmlspecialchars($operator_name), safe_htmlspecialchars($this->agentName)),\n                $this->locale,\n                true\n            );\n        } elseif ($is_operator_joined) {\n            $message = getlocal(\n                \"Operator {0} joined the chat\",\n                array(safe_htmlspecialchars($operator_name)),\n                $this->locale,\n                true\n            );\n        } elseif ($is_operator_back) {\n            $message = getlocal(\n                \"Operator {0} is back\",\n                array(safe_htmlspecialchars($operator_name)),\n                $this->locale,\n                true\n            );\n        }\n\n        // Make sure the thread have correct operator and state.\n        $this->state = self::STATE_CHATTING;\n        $this->nextAgent = 0;\n        $this->agentId = $operator['operatorid'];\n        $this->agentName = $operator_name;\n        if (empty($this->chatStarted)) {\n            // This is needed only if the chat was not started yet. Such threads\n            // should originally belong to STATE_QUEUE or STATE_LOADING.\n            $this->chatStarted = time();\n        }\n        $this->save();\n\n        // Send message\n        if ($message) {\n            $this->postMessage(self::KIND_EVENTS, $message);\n        }\n\n        return true;\n    }\n\n    /**\n     * Change user name in the conversation\n     *\n     * @param string $new_name New user name\n     */\n    public function renameUser($new_name)\n    {\n        // Rename only if a new name is really new\n        if ($this->userName != $new_name) {\n            // Save old name\n            $old_name = $this->userName;\n            // Rename user\n            $this->userName = $new_name;\n            $this->save();\n\n            // Send message about renaming\n            $message = getlocal(\n                \"The visitor changed their name <strong>{0}</strong> to <strong>{1}</strong>\",\n                array(safe_htmlspecialchars($old_name), safe_htmlspecialchars($new_name)),\n                $this->locale,\n                true\n            );\n            $this->postMessage(self::KIND_EVENTS, $message);\n        }\n    }\n\n    /**\n     * Sets thread's fields according to the fields from Database.\n     *\n     * @param array $db_fields Associative array of database fields which keys\n     *   are fields names and the values are fields values.\n     */\n    protected function populateFromDbFields($db_fields)\n    {\n        $this->id = (int)$db_fields['threadid'];\n        $this->userName = $db_fields['username'];\n        $this->userId = $db_fields['userid'];\n        $this->agentName = $db_fields['agentname'];\n        $this->agentId = (int)$db_fields['agentid'];\n        $this->created = (int)$db_fields['dtmcreated'];\n        $this->chatStarted = (int)$db_fields['dtmchatstarted'];\n        $this->modified = (int)$db_fields['dtmmodified'];\n        $this->closed = (int)$db_fields['dtmclosed'];\n        $this->lastRevision = (int)$db_fields['lrevision'];\n        $this->state = (int)$db_fields['istate'];\n        $this->invitationState = (int)$db_fields['invitationstate'];\n        $this->lastToken = (int)$db_fields['ltoken'];\n        $this->remote = $db_fields['remote'];\n        $this->referer = $db_fields['referer'];\n        $this->nextAgent = (int)$db_fields['nextagent'];\n        $this->locale = $db_fields['locale'];\n        $this->lastPingUser = (int)$db_fields['lastpinguser'];\n        $this->lastPingAgent = (int)$db_fields['lastpingagent'];\n        $this->userTyping = $db_fields['usertyping'];\n        $this->agentTyping = $db_fields['agenttyping'];\n        $this->shownMessageId = (int)$db_fields['shownmessageid'];\n        $this->userAgent = $db_fields['useragent'];\n        $this->messageCount = $db_fields['messagecount'];\n        $this->groupId = (int)$db_fields['groupid'];\n    }\n\n    /**\n     * Save the messsage in database\n     *\n     * @param int $kind Message kind. One of the Thread::KIND_*\n     * @param string $message Message body\n     * @param array $options List of additional options. It may contain\n     *   following items:\n     *    - 'name': string, name of the message sender.\n     *    - 'operator_id': int, ID of the operator who sent the message. For\n     *      system messages do not set this field.\n     *    - 'created': int, unix timestamp of the send time. If you want to set\n     *      current time do not set this field.\n     *    - 'plugin': string, name of the plugin which sent the message. If\n     *      message was not sent by a plugin do not set this field.\n     *    - 'data': array with arbitrary data related with message. This value\n     *      will be converted to array and serialized before save. If there is no\n     *      such data do not set this field.\n     *\n     * @return int Message ID\n     *\n     * @see Thread::KIND_USER\n     * @see Thread::KIND_AGENT\n     * @see Thread::KIND_FOR_AGENT\n     * @see Thread::KIND_INFO\n     * @see Thread::KIND_CONN\n     * @see Thread::KIND_EVENTS\n     * @see Thread::KIND_PLUGIN\n     * @see Thread::getMessages()\n     */\n    protected function saveMessage($kind, $message, $options = array())\n    {\n        $db = Database::getInstance();\n\n        // TODO: check incoming message (it should be non-empty string)\n        // Add default values to options\n        $options += array(\n            'name' => null,\n            'operator_id' => 0,\n            'created' => time(),\n            'plugin' => '',\n            'data' => array(),\n        );\n\n        // Prepare message data\n        $options['data'] = serialize((array) $options['data']);\n\n        // Prepare query\n        $query = \"INSERT INTO {message} (\"\n                . \"threadid, ikind, tmessage, tname, agentid, \"\n                . \"dtmcreated, plugin, data\"\n            . \") VALUES (\"\n                . \":threadid, :kind, :message, :name, :agentid, \"\n                . \":created, :plugin, :data\"\n            . \")\";\n\n        $values = array(\n            ':threadid' => $this->id,\n            ':kind' => $kind,\n            ':message' => $message,\n            ':name' => $options['name'],\n            ':agentid' => $options['operator_id'],\n            ':created' => $options['created'],\n            ':plugin' => $options['plugin'],\n            ':data' => $options['data'],\n        );\n\n        // Execute query\n        $db->query($query, $values);\n\n        return $db->insertedId();\n    }\n\n    /**\n     * Return next revision number (last revision number plus one)\n     *\n     * @return int revision number\n     */\n    protected static function nextRevision()\n    {\n        $db = Database::getInstance();\n        $db->query(\"UPDATE {revision} SET id=LAST_INSERT_ID(id+1)\");\n        $val = $db->insertedId();\n\n        return $val;\n    }\n\n    /**\n     * Create thread token\n     *\n     * @return int Thread token\n     */\n    protected static function nextToken()\n    {\n        if (function_exists('openssl_random_pseudo_bytes')) {\n            $token_arr = unpack('N', \"\\x0\" . openssl_random_pseudo_bytes(3));\n            $token = $token_arr[1];\n        } else {\n            $token = mt_rand(99999, 99999999);\n        }\n\n        return $token;\n    }\n}\n", "<?php\n/*\n * This file is a part of Mibew Messenger.\n *\n * Copyright 2005-2020 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Import namespaces and classes of the core\nuse Mibew\\EventDispatcher\\EventDispatcher;\nuse Mibew\\EventDispatcher\\Events;\nuse Mibew\\Database;\nuse Mibew\\ProcessLock;\nuse Mibew\\Settings;\nuse Mibew\\Thread;\n\n/**\n * Check invitation state for specified visitior\n *\n * @param int $visitor_id ID of the visitor to check\n * @return array Array of invitation info. It contains following items:\n *  - 'invited': boolean, indicates if the visitor was invited by an operator;\n *  - 'threadid': int, ID of the thread, related with visitor or boolean false\n *    if visitor with specfied ID does not exist.\n */\nfunction invitation_state($visitor_id)\n{\n    $db = Database::getInstance();\n    $db_result = $db->query(\n        (\"SELECT t.threadid, t.invitationstate, t.istate \"\n            . \"FROM {sitevisitor} v, {thread} t \"\n            . \"WHERE visitorid = ? \"\n            . \"AND t.threadid = v.threadid\"),\n        array($visitor_id),\n        array('return_rows' => Database::RETURN_ONE_ROW)\n    );\n\n    $ret = array();\n    if (!$db_result) {\n        $ret['invited'] = false;\n        $ret['threadid'] = false;\n    } else {\n        $ret['invited'] = ($db_result['istate'] == Thread::STATE_INVITED)\n            && ($db_result['invitationstate'] == Thread::INVITATION_WAIT);\n        $ret['threadid'] = $db_result['threadid'];\n    }\n\n    return $ret;\n}\n\n/**\n * Invite visitor by operator\n *\n * Triggers {@link \\Mibew\\EventDispatcher\\Events::INVITATION_CREATE} event.\n *\n * @param int $visitor_id ID of the visitor, who must be invited.\n * @param array $operator Info for operator  who invite the visitor\n * @return Thread|boolean Thread object related with invitation or boolean\n *   false on failure\n */\nfunction invitation_invite($visitor_id, $operator)\n{\n    // Check if visitor already invited\n    $invitation_state = invitation_state($visitor_id);\n    if ($invitation_state['invited']) {\n        return false;\n    }\n\n    // Get visitor info\n    $visitor = track_get_visitor_by_id($visitor_id);\n\n    // Get last page visited by the visitor\n    $visitor_path = track_get_path($visitor);\n    ksort($visitor_path);\n    $last_visited_page = array_pop($visitor_path);\n\n    // Get visitor details\n    $visitor_details = track_retrieve_details($visitor);\n\n    // Get some operator's info\n    $operator_name = get_operator_name($operator);\n\n    // Create thread for invitation\n    $thread = new Thread();\n\n    // Populate thread and save it\n    $thread->agentId = $operator['operatorid'];\n    $thread->agentName = $operator_name;\n    $thread->userName = $visitor['username'];\n    $thread->remote = $visitor_details['remote_host'];\n    $thread->referer = $last_visited_page;\n    // User's locale is unknown, set operator locale to the thread\n    $thread->locale = get_current_locale();\n    $thread->userId = $visitor['userid'];\n    $thread->userAgent = $visitor_details['user_agent'];\n    $thread->state = Thread::STATE_INVITED;\n    $thread->invitationState = Thread::INVITATION_WAIT;\n    $thread->save();\n\n    $db = Database::getInstance();\n    $db->query(\n        (\"UPDATE {sitevisitor} set \"\n            . \"invitations = invitations + 1, \"\n            . \"threadid = :thread_id \"\n            . \"WHERE visitorid = :visitor_id\"),\n        array(\n            ':thread_id' => $thread->id,\n            ':visitor_id' => $visitor_id,\n        )\n    );\n\n    // Send some messages\n    $thread->postMessage(\n        Thread::KIND_FOR_AGENT,\n        getlocal(\n            'Operator {0} invites visitor at {1} page',\n            array(safe_htmlspecialchars($operator_name), safe_htmlspecialchars($last_visited_page)),\n            get_current_locale(),\n            true\n        )\n    );\n    $thread->postMessage(\n        Thread::KIND_AGENT,\n        getlocal('Hello, how can I help you?', null, get_current_locale(), true),\n        array(\n            'name' => $operator_name,\n            'operator_id' => $operator['operatorid'],\n        )\n    );\n\n    // Let plugins know about the invitation.\n    $args = array('invitation' => $thread);\n    EventDispatcher::getInstance()->triggerEvent(Events::INVITATION_CREATE, $args);\n\n    return $thread;\n}\n\n/**\n * Invitation was accepted by visitor\n *\n * Triggers {@link \\Mibew\\EventDispatcher\\Events::INVITATION_ACCEPT} event.\n *\n * @param int $visitor_id ID of the visitor who accept invitation\n * @return Thread|boolean Thread object or boolean false on failure\n */\nfunction invitation_accept($visitor_id)\n{\n    // Check if visitor was invited\n    $invitation_state = invitation_state($visitor_id);\n    if (!$invitation_state['invited']) {\n        // Visitor was not invited\n        return false;\n    }\n\n    // Get thread related with the visitor\n    $db = Database::getInstance();\n    $result = $db->query(\n        \"SELECT threadid FROM {sitevisitor} WHERE visitorid = :visitor_id\",\n        array(':visitor_id' => $visitor_id),\n        array('return_rows' => Database::RETURN_ONE_ROW)\n    );\n\n    if (empty($result['threadid'])) {\n        // Something went wrong. There is no thread related with the visitor.\n        return false;\n    }\n\n    $thread = Thread::load($result['threadid']);\n    if (!$thread) {\n        // Something went wrong. Cannot load thread.\n        return false;\n    }\n\n    // Update thread info\n    $thread->state = Thread::STATE_CHATTING;\n    $thread->invitationState = Thread::INVITATION_ACCEPTED;\n    $thread->chatStarted = time();\n    $thread->save();\n\n    // Update visitor info\n    $db->query(\n        (\"UPDATE {sitevisitor} SET chats = chats + 1 \"\n            . \"WHERE visitorid = :visitor_id\"),\n        array(':visitor_id' => $visitor_id)\n    );\n\n    $args = array('invitation' => $thread);\n    EventDispatcher::getInstance()->triggerEvent(Events::INVITATION_ACCEPT, $args);\n\n    return $thread;\n}\n\n/**\n * Inviation was rejected by visitor\n *\n * Triggers {@link \\Mibew\\EventDispatcher\\Events::INVITATION_REJECT} event.\n *\n * @param int $visitor_id ID of the visitor\n */\nfunction invitation_reject($visitor_id)\n{\n    $visitor = track_get_visitor_by_id($visitor_id);\n\n    // Send message to operator\n    $thread = Thread::load($visitor['threadid']);\n    if ($thread) {\n        $thread->postMessage(\n            Thread::KIND_FOR_AGENT,\n            getlocal('Visitor rejected invitation', null, get_current_locale(), true)\n        );\n    }\n\n    $db = Database::getInstance();\n    $db->query(\n        (\"UPDATE {sitevisitor} v, {thread} t SET \"\n            . \"v.threadid = NULL, \"\n            . \"t.invitationstate = :invitation_rejected, \"\n            . \"t.istate = :state_closed, \"\n            . \"t.dtmclosed = :now \"\n            . \"WHERE t.threadid = v.threadid \"\n            . \"AND visitorid = :visitor_id\"),\n        array(\n            ':invitation_rejected' => Thread::INVITATION_REJECTED,\n            ':state_closed' => Thread::STATE_CLOSED,\n            ':visitor_id' => $visitor_id,\n            ':now' => time(),\n        )\n    );\n\n    $args = array('invitation' => $thread);\n    EventDispatcher::getInstance()->triggerEvent(Events::INVITATION_REJECT, $args);\n}\n\n/**\n * Close old invitations.\n *\n * Triggers {@link \\Mibew\\EventDispatcher\\Events::INVITATION_IGNORE} event.\n */\nfunction invitation_close_old()\n{\n    // Run only one instance of cleaning process.\n    $lock = new ProcessLock('invitations_close_old');\n    if ($lock->get()) {\n        // Freeze the time for the whole cleaning process.\n        $now = time();\n\n        $db = Database::getInstance();\n\n        // Remove links between visitors and invitations that will be closed.\n        $db->query(\n            (\"UPDATE {sitevisitor} v, {thread} t SET \"\n                . \"v.threadid = NULL \"\n                . \"WHERE t.istate = :state_invited \"\n                . \"AND t.invitationstate = :invitation_wait \"\n                . \"AND (:now - t.dtmcreated) > :lifetime\"),\n            array(\n                ':invitation_wait' => Thread::INVITATION_WAIT,\n                ':state_invited' => Thread::STATE_INVITED,\n                ':lifetime' => Settings::get('invitation_lifetime'),\n                ':now' => $now,\n            )\n        );\n\n        // Get all invitations to close\n        $threads = $db->query(\n            (\"SELECT * FROM {thread} \"\n                . \"WHERE istate = :state_invited \"\n                . \"AND invitationstate = :invitation_wait \"\n                . \"AND (:now - dtmcreated) > :lifetime\"),\n            array(\n                ':invitation_wait' => Thread::INVITATION_WAIT,\n                ':state_invited' => Thread::STATE_INVITED,\n                ':lifetime' => Settings::get('invitation_lifetime'),\n                ':now' => $now,\n            ),\n            array('return_rows' => Database::RETURN_ALL_ROWS)\n        );\n\n        // Close the invitations\n        foreach ($threads as $thread_info) {\n            $thread = Thread::createFromDbInfo($thread_info);\n            $thread->invitationState = Thread::INVITATION_IGNORED;\n            $thread->state = Thread::STATE_CLOSED;\n            $thread->closed = $now;\n            $thread->save();\n\n            // Notify the operator about autoclosing\n            $thread->postMessage(\n                Thread::KIND_FOR_AGENT,\n                getlocal(\n                    'Visitor ignored invitation and it was closed automatically',\n                    null,\n                    $thread->locale,\n                    true\n                )\n            );\n\n            $args = array('invitation' => $thread);\n            EventDispatcher::getInstance()->triggerEvent(Events::INVITATION_IGNORE, $args);\n\n            unset($thread);\n        }\n\n        // Release the lock\n        $lock->release();\n    }\n}\n\n/**\n * Prepare data to dispaly invitation\n *\n * @param Thread $thread Thread object related with invitation\n * @return array Array of invitation data\n */\nfunction setup_invitation_view(Thread $thread)\n{\n    $data = prepare_chat_app_data();\n\n    // Set refresh frequency\n    $data['frequency'] = Settings::get('updatefrequency_chat');\n\n    // Create some empty arrays\n    $data['invitation'] = array();\n\n    $data['invitation']['thread'] = array(\n        'id' => $thread->id,\n        'token' => $thread->lastToken,\n        'agentId' => $thread->agentId,\n        'userId' => $thread->userId,\n    );\n\n    $data['invitation']['user'] = array(\n        'name' => htmlspecialchars($thread->userName),\n        'canChangeName' => false,\n        'isAgent' => false,\n    );\n\n    $data['startFrom'] = 'invitation';\n\n    return $data;\n}\n"], "filenames": ["src/mibew/libs/chat.php", "src/mibew/libs/classes/Mibew/Controller/ButtonController.php", "src/mibew/libs/classes/Mibew/Controller/Chat/RedirectController.php", "src/mibew/libs/classes/Mibew/RequestProcessor/ThreadProcessor.php", "src/mibew/libs/classes/Mibew/Thread.php", "src/mibew/libs/invitation.php"], "buggy_code_start_loc": [700, 53, 184, 674, 761, 128], "buggy_code_end_loc": [735, 54, 239, 806, 1087, 129], "fixing_code_start_loc": [700, 53, 184, 674, 761, 128], "fixing_code_end_loc": [735, 54, 239, 806, 1087, 129], "type": "CWE-79", "message": "Mibew Messenger before 3.2.7 allows XSS via a crafted user name.", "other": {"cve": {"id": "CVE-2020-17476", "sourceIdentifier": "cve@mitre.org", "published": "2020-08-10T17:15:13.133", "lastModified": "2020-08-10T18:22:23.303", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Mibew Messenger before 3.2.7 allows XSS via a crafted user name."}, {"lang": "es", "value": "Mibew Messenger versiones anteriores a 3.2.7, permite un ataque de tipo XSS por medio de un nombre de usuario dise\u00f1ado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mibew:messenger:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.7", "matchCriteriaId": "EECBF5E0-50F6-412B-8BB1-27854A7D3B04"}]}]}], "references": [{"url": "https://github.com/Mibew/mibew/commit/84f5bca0a90b2fe470e35e9b5121548ccce0093c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://mibew.org/announcements/2020/07/09/mibew-messenger-3-2-7-has-been-released", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/Mibew/mibew/commit/84f5bca0a90b2fe470e35e9b5121548ccce0093c"}}