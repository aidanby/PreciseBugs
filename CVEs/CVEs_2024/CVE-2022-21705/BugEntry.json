{"buggy_code": ["<?php namespace October\\Rain\\Halcyon\\Processors;\n\nuse October\\Rain\\Parse\\Ini;\nuse October\\Rain\\Support\\Str;\n\n/**\n * This class parses CMS object files (pages, partials and layouts).\n * Returns the structured file information.\n *\n * @package october\\halcyon\n * @author Alexey Bobkov, Samuel Georges\n */\nclass SectionParser\n{\n    const SECTION_SEPARATOR = '==';\n\n    const ERROR_INI = '_PARSER_ERROR_INI';\n\n    /**\n     * Renders a CMS object as file content.\n     * @return string\n     */\n    public static function render($data, $options = [])\n    {\n        extract(array_merge([\n            'wrapCodeInPhpTags' => true,\n            'isCompoundObject'  => true\n        ], $options));\n\n        if (!$isCompoundObject) {\n            return array_get($data, 'content');\n        }\n\n        $iniParser = new Ini;\n        $code = trim(array_get($data, 'code'));\n        $markup = trim(array_get($data, 'markup'));\n\n        $trim = function (&$values) use (&$trim) {\n            foreach ($values as &$value) {\n                if (!is_array($value)) {\n                    $value = trim($value);\n                }\n                else {\n                    $trim($value);\n                }\n            }\n        };\n\n        $settings = array_get($data, 'settings', []);\n        $trim($settings);\n\n        /*\n         * Build content\n         */\n        $content = [];\n\n        if ($settings) {\n            $content[] = $iniParser->render($settings);\n        }\n\n        if ($code) {\n            if ($wrapCodeInPhpTags) {\n                $code = preg_replace('/^\\<\\?php/', '', $code);\n                $code = preg_replace('/^\\<\\?/', '', $code);\n                $code = preg_replace('/\\?>$/', '', $code);\n                $code = trim($code, PHP_EOL);\n\n                $content[] = '<?php'.PHP_EOL.$code.PHP_EOL.'?>';\n            }\n            else {\n                $content[] = $code;\n            }\n        }\n\n        $content[] = $markup;\n\n        $content = trim(implode(PHP_EOL.self::SECTION_SEPARATOR.PHP_EOL, $content));\n\n        return $content;\n    }\n\n    /**\n     * Parses a CMS object file content.\n     * The expected file format is following:\n     * <pre>\n     * INI settings section\n     * ==\n     * PHP code section\n     * ==\n     * Twig markup section\n     * </pre>\n     * If the content has only 2 sections they are considered as settings and Twig.\n     * If there is only a single section, it is considered as Twig.\n     * @param string $content Specifies the file content.\n     * @return array Returns an array with the following indexes: 'settings', 'markup', 'code'.\n     * The 'markup' and 'code' elements contain strings. The 'settings' element contains the\n     * parsed INI file as array. If the content string doesn't contain a section, the corresponding\n     * result element has null value.\n     */\n    public static function parse($content, $options = [])\n    {\n        extract(array_merge([\n            'isCompoundObject' => true\n        ], $options));\n\n        $result = [\n            'settings' => [],\n            'code'     => null,\n            'markup'   => null\n        ];\n\n        if (!$isCompoundObject || !strlen($content)) {\n            return $result;\n        }\n\n        $iniParser = new Ini;\n        $sections = preg_split('/^'.preg_quote(self::SECTION_SEPARATOR).'\\s*$/m', $content, -1);\n        $count = count($sections);\n        foreach ($sections as &$section) {\n            $section = trim($section);\n        }\n\n        if ($count >= 3) {\n            $result['settings'] = @$iniParser->parse($sections[0], true)\n                ?: [self::ERROR_INI => $sections[0]];\n\n            $result['code'] = $sections[1];\n            $result['code'] = preg_replace('/^\\s*\\<\\?php/', '', $result['code']);\n            $result['code'] = preg_replace('/^\\s*\\<\\?/', '', $result['code']);\n            $result['code'] = preg_replace('/\\?\\>\\s*$/', '', $result['code']);\n            $result['code'] = trim($result['code'], PHP_EOL);\n\n            $result['markup'] = $sections[2];\n        }\n        elseif ($count == 2) {\n            $result['settings'] = @$iniParser->parse($sections[0], true)\n                ?: [self::ERROR_INI => $sections[0]];\n\n            $result['markup'] = $sections[1];\n        }\n        elseif ($count == 1) {\n            $result['markup'] = $sections[0];\n        }\n\n        return $result;\n    }\n\n    /**\n     * Same as parse method, except the line number where the respective section\n     * begins is returned.\n     * @param string $content Specifies the file content.\n     * @return array Returns an array with the following indexes: 'settings', 'markup', 'code'.\n     */\n    public static function parseOffset($content)\n    {\n        $content = Str::normalizeEol($content);\n        $sections = preg_split('/^'.preg_quote(self::SECTION_SEPARATOR).'\\s*$/m', $content, -1);\n        $count = count($sections);\n\n        $result = [\n            'settings' => null,\n            'code'     => null,\n            'markup'   => null\n        ];\n\n        if ($count >= 3) {\n            $result['settings'] = self::adjustLinePosition($content);\n            $result['code'] = self::calculateLinePosition($content);\n            $result['markup'] = self::calculateLinePosition($content, 2);\n        }\n        elseif ($count == 2) {\n            $result['settings'] = self::adjustLinePosition($content);\n            $result['markup'] = self::calculateLinePosition($content);\n        }\n        elseif ($count == 1) {\n            $result['markup'] = 1;\n        }\n\n        return $result;\n    }\n\n    /**\n     * Returns the line number of a found instance of CMS object section separator (==).\n     * @param string $content Object content\n     * @param int $instance Which instance to look for\n     * @return int The line number the instance was found.\n     */\n    private static function calculateLinePosition($content, $instance = 1)\n    {\n        $count = 0;\n        $lines = explode(PHP_EOL, $content);\n        foreach ($lines as $number => $line) {\n            if (trim($line) == self::SECTION_SEPARATOR) {\n                $count++;\n            }\n\n            if ($count == $instance) {\n                return static::adjustLinePosition($content, $number);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Pushes the starting line number forward since it is not always directly\n     * after the separator (==). There can be an opening tag or white space in between\n     * where the section really begins.\n     * @param string $content Object content\n     * @param int $startLine The calculated starting line from calculateLinePosition()\n     * @return int The adjusted line number.\n     */\n    private static function adjustLinePosition($content, $startLine = -1)\n    {\n        // Account for the separator itself.\n        $startLine++;\n\n        $lines = array_slice(explode(PHP_EOL, $content), $startLine);\n        foreach ($lines as $line) {\n            $line = trim($line);\n\n            /*\n             * Empty line\n             */\n            if ($line == '') {\n                $startLine++;\n                continue;\n            }\n\n            /*\n             * PHP line\n             */\n            if ($line == '<?php' || $line == '<?') {\n                $startLine++;\n                continue;\n            }\n\n            /*\n             * PHP namespaced line (use x;) {\n             * Don't increase the line count, it will be rewritten by Cms\\Classes\\CodeParser\n             */\n            if (preg_match_all('/(use\\s+[a-z0-9_\\\\\\\\]+;\\n?)/mi', $line) == 1) {\n                continue;\n            }\n\n            break;\n        }\n\n        // Line 0 does not exist.\n        return ++$startLine;\n    }\n}\n"], "fixing_code": ["<?php namespace October\\Rain\\Halcyon\\Processors;\n\nuse October\\Rain\\Parse\\Ini;\nuse October\\Rain\\Support\\Str;\n\n/**\n * This class parses CMS object files (pages, partials and layouts).\n * Returns the structured file information.\n *\n * @package october\\halcyon\n * @author Alexey Bobkov, Samuel Georges\n */\nclass SectionParser\n{\n    const SECTION_SEPARATOR = '==';\n\n    const ERROR_INI = '_PARSER_ERROR_INI';\n\n    /**\n     * Renders a CMS object as file content.\n     * @return string\n     */\n    public static function render($data, $options = [])\n    {\n        extract(array_merge([\n            'wrapCodeInPhpTags' => true,\n            'isCompoundObject'  => true\n        ], $options));\n\n        if (!$isCompoundObject) {\n            return array_get($data, 'content');\n        }\n\n        $iniParser = new Ini;\n        $code = trim(array_get($data, 'code'));\n        $markup = trim(array_get($data, 'markup'));\n\n        $trim = function (&$values) use (&$trim) {\n            foreach ($values as &$value) {\n                if (!is_array($value)) {\n                    $value = trim($value);\n                }\n                else {\n                    $trim($value);\n                }\n            }\n        };\n\n        $settings = array_get($data, 'settings', []);\n        $trim($settings);\n\n        /*\n         * Build content\n         */\n        $content = [];\n\n        if ($settings) {\n            $content[] = $iniParser->render($settings);\n        }\n\n        if ($code) {\n            if ($wrapCodeInPhpTags) {\n                $code = preg_replace('/^\\<\\?php/', '', $code);\n                $code = preg_replace('/^\\<\\?/', '', $code);\n                $code = preg_replace('/\\?>$/', '', $code);\n                $code = trim($code, PHP_EOL);\n\n                $content[] = '<?php'.PHP_EOL.$code.PHP_EOL.'?>';\n            }\n            else {\n                $content[] = $code;\n            }\n        }\n\n        $sections = preg_split('/^'.preg_quote(self::SECTION_SEPARATOR).'\\s*$/m', $markup, -1);\n        $content[] = end($sections);\n\n        $content = trim(implode(PHP_EOL.self::SECTION_SEPARATOR.PHP_EOL, $content));\n\n        return $content;\n    }\n\n    /**\n     * Parses a CMS object file content.\n     * The expected file format is following:\n     * <pre>\n     * INI settings section\n     * ==\n     * PHP code section\n     * ==\n     * Twig markup section\n     * </pre>\n     * If the content has only 2 sections they are considered as settings and Twig.\n     * If there is only a single section, it is considered as Twig.\n     * @param string $content Specifies the file content.\n     * @return array Returns an array with the following indexes: 'settings', 'markup', 'code'.\n     * The 'markup' and 'code' elements contain strings. The 'settings' element contains the\n     * parsed INI file as array. If the content string doesn't contain a section, the corresponding\n     * result element has null value.\n     */\n    public static function parse($content, $options = [])\n    {\n        extract(array_merge([\n            'isCompoundObject' => true\n        ], $options));\n\n        $result = [\n            'settings' => [],\n            'code'     => null,\n            'markup'   => null\n        ];\n\n        if (!$isCompoundObject || !strlen($content)) {\n            return $result;\n        }\n\n        $iniParser = new Ini;\n        $sections = preg_split('/^'.preg_quote(self::SECTION_SEPARATOR).'\\s*$/m', $content, -1);\n        $count = count($sections);\n        foreach ($sections as &$section) {\n            $section = trim($section);\n        }\n\n        if ($count >= 3) {\n            $result['settings'] = @$iniParser->parse($sections[0], true)\n                ?: [self::ERROR_INI => $sections[0]];\n\n            $result['code'] = $sections[1];\n            $result['code'] = preg_replace('/^\\s*\\<\\?php/', '', $result['code']);\n            $result['code'] = preg_replace('/^\\s*\\<\\?/', '', $result['code']);\n            $result['code'] = preg_replace('/\\?\\>\\s*$/', '', $result['code']);\n            $result['code'] = trim($result['code'], PHP_EOL);\n\n            $result['markup'] = $sections[2];\n        }\n        elseif ($count == 2) {\n            $result['settings'] = @$iniParser->parse($sections[0], true)\n                ?: [self::ERROR_INI => $sections[0]];\n\n            $result['markup'] = $sections[1];\n        }\n        elseif ($count == 1) {\n            $result['markup'] = $sections[0];\n        }\n\n        return $result;\n    }\n\n    /**\n     * Same as parse method, except the line number where the respective section\n     * begins is returned.\n     * @param string $content Specifies the file content.\n     * @return array Returns an array with the following indexes: 'settings', 'markup', 'code'.\n     */\n    public static function parseOffset($content)\n    {\n        $content = Str::normalizeEol($content);\n        $sections = preg_split('/^'.preg_quote(self::SECTION_SEPARATOR).'\\s*$/m', $content, -1);\n        $count = count($sections);\n\n        $result = [\n            'settings' => null,\n            'code'     => null,\n            'markup'   => null\n        ];\n\n        if ($count >= 3) {\n            $result['settings'] = self::adjustLinePosition($content);\n            $result['code'] = self::calculateLinePosition($content);\n            $result['markup'] = self::calculateLinePosition($content, 2);\n        }\n        elseif ($count == 2) {\n            $result['settings'] = self::adjustLinePosition($content);\n            $result['markup'] = self::calculateLinePosition($content);\n        }\n        elseif ($count == 1) {\n            $result['markup'] = 1;\n        }\n\n        return $result;\n    }\n\n    /**\n     * Returns the line number of a found instance of CMS object section separator (==).\n     * @param string $content Object content\n     * @param int $instance Which instance to look for\n     * @return int The line number the instance was found.\n     */\n    private static function calculateLinePosition($content, $instance = 1)\n    {\n        $count = 0;\n        $lines = explode(PHP_EOL, $content);\n        foreach ($lines as $number => $line) {\n            if (trim($line) == self::SECTION_SEPARATOR) {\n                $count++;\n            }\n\n            if ($count == $instance) {\n                return static::adjustLinePosition($content, $number);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Pushes the starting line number forward since it is not always directly\n     * after the separator (==). There can be an opening tag or white space in between\n     * where the section really begins.\n     * @param string $content Object content\n     * @param int $startLine The calculated starting line from calculateLinePosition()\n     * @return int The adjusted line number.\n     */\n    private static function adjustLinePosition($content, $startLine = -1)\n    {\n        // Account for the separator itself.\n        $startLine++;\n\n        $lines = array_slice(explode(PHP_EOL, $content), $startLine);\n        foreach ($lines as $line) {\n            $line = trim($line);\n\n            /*\n             * Empty line\n             */\n            if ($line == '') {\n                $startLine++;\n                continue;\n            }\n\n            /*\n             * PHP line\n             */\n            if ($line == '<?php' || $line == '<?') {\n                $startLine++;\n                continue;\n            }\n\n            /*\n             * PHP namespaced line (use x;) {\n             * Don't increase the line count, it will be rewritten by Cms\\Classes\\CodeParser\n             */\n            if (preg_match_all('/(use\\s+[a-z0-9_\\\\\\\\]+;\\n?)/mi', $line) == 1) {\n                continue;\n            }\n\n            break;\n        }\n\n        // Line 0 does not exist.\n        return ++$startLine;\n    }\n}\n"], "filenames": ["src/Halcyon/Processors/SectionParser.php"], "buggy_code_start_loc": [75], "buggy_code_end_loc": [76], "fixing_code_start_loc": [75], "fixing_code_end_loc": [77], "type": "CWE-74", "message": "Octobercms is a self-hosted CMS platform based on the Laravel PHP Framework. In affected versions user input was not properly sanitized before rendering. An authenticated user with the permissions to create, modify and delete website pages can exploit this vulnerability to bypass `cms.safe_mode` / `cms.enableSafeMode` in order to execute arbitrary code. This issue only affects admin panels that rely on safe mode and restricted permissions. To exploit this vulnerability, an attacker must first have access to the backend area. The issue has been patched in Build 474 (v1.0.474) and v1.1.10. Users unable to upgrade should apply https://github.com/octobercms/library/commit/c393c5ce9ca2c5acc3ed6c9bb0dab5ffd61965fe to your installation manually.", "other": {"cve": {"id": "CVE-2022-21705", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-23T19:15:08.583", "lastModified": "2022-03-02T15:54:20.563", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Octobercms is a self-hosted CMS platform based on the Laravel PHP Framework. In affected versions user input was not properly sanitized before rendering. An authenticated user with the permissions to create, modify and delete website pages can exploit this vulnerability to bypass `cms.safe_mode` / `cms.enableSafeMode` in order to execute arbitrary code. This issue only affects admin panels that rely on safe mode and restricted permissions. To exploit this vulnerability, an attacker must first have access to the backend area. The issue has been patched in Build 474 (v1.0.474) and v1.1.10. Users unable to upgrade should apply https://github.com/octobercms/library/commit/c393c5ce9ca2c5acc3ed6c9bb0dab5ffd61965fe to your installation manually."}, {"lang": "es", "value": "Octobercms es una plataforma CMS auto-alojada basada en el framework PHP Laravel. En las versiones afectadas, la entrada del usuario no se desinfectaba correctamente antes de la renderizaci\u00f3n. Un usuario autenticado con permisos para crear, modificar y eliminar p\u00e1ginas del sitio web puede explotar esta vulnerabilidad para saltarse `cms.safe_mode` / `cms.enableSafeMode` con el fin de ejecutar c\u00f3digo arbitrario. Este problema s\u00f3lo afecta a los paneles de administraci\u00f3n que dependen del modo seguro y de los permisos restringidos. Para explotar esta vulnerabilidad, un atacante debe tener primero acceso al \u00e1rea del backend. El problema ha sido parcheado en la Build 474 (v1.0.474) y en la v1.1.10. Los usuarios que no puedan actualizar deber\u00e1n aplicar https://github.com/octobercms/library/commit/c393c5ce9ca2c5acc3ed6c9bb0dab5ffd61965fe a su instalaci\u00f3n manualmente"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 8.5}, "baseSeverity": "HIGH", "exploitabilityScore": 6.8, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:octobercms:october:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.474", "matchCriteriaId": "0583E0B8-5810-4BC1-9E48-70A5D445CD46"}, {"vulnerable": true, "criteria": "cpe:2.3:a:octobercms:october:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.1.0", "versionEndExcluding": "1.1.10", "matchCriteriaId": "8F04F1FB-DF89-4C6E-BB64-0872B84097FB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:octobercms:october:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.1.27", "matchCriteriaId": "E0834C0B-82AF-4E5A-8C29-21DED792332F"}]}]}], "references": [{"url": "https://github.com/octobercms/library/commit/c393c5ce9ca2c5acc3ed6c9bb0dab5ffd61965fe", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/octobercms/october/security/advisories/GHSA-79jw-2f46-wv22", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/octobercms/library/commit/c393c5ce9ca2c5acc3ed6c9bb0dab5ffd61965fe"}}