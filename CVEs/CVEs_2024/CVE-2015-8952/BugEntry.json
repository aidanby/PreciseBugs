{"buggy_code": ["/*\n * Copyright (C) 1992, 1993, 1994, 1995\n * Remy Card (card@masi.ibp.fr)\n * Laboratoire MASI - Institut Blaise Pascal\n * Universite Pierre et Marie Curie (Paris VI)\n *\n *  from\n *\n *  linux/include/linux/minix_fs.h\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n#include <linux/fs.h>\n#include <linux/ext2_fs.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/percpu_counter.h>\n#include <linux/rbtree.h>\n\n/* XXX Here for now... not interested in restructing headers JUST now */\n\n/* data type for block offset of block group */\ntypedef int ext2_grpblk_t;\n\n/* data type for filesystem-wide blocks number */\ntypedef unsigned long ext2_fsblk_t;\n\n#define E2FSBLK \"%lu\"\n\nstruct ext2_reserve_window {\n\text2_fsblk_t\t\t_rsv_start;\t/* First byte reserved */\n\text2_fsblk_t\t\t_rsv_end;\t/* Last byte reserved or 0 */\n};\n\nstruct ext2_reserve_window_node {\n\tstruct rb_node\t \trsv_node;\n\t__u32\t\t\trsv_goal_size;\n\t__u32\t\t\trsv_alloc_hit;\n\tstruct ext2_reserve_window\trsv_window;\n};\n\nstruct ext2_block_alloc_info {\n\t/* information about reservation window */\n\tstruct ext2_reserve_window_node\trsv_window_node;\n\t/*\n\t * was i_next_alloc_block in ext2_inode_info\n\t * is the logical (file-relative) number of the\n\t * most-recently-allocated block in this file.\n\t * We use this for detecting linearly ascending allocation requests.\n\t */\n\t__u32\t\t\tlast_alloc_logical_block;\n\t/*\n\t * Was i_next_alloc_goal in ext2_inode_info\n\t * is the *physical* companion to i_next_alloc_block.\n\t * it the the physical block number of the block which was most-recentl\n\t * allocated to this file.  This give us the goal (target) for the next\n\t * allocation when we detect linearly ascending requests.\n\t */\n\text2_fsblk_t\t\tlast_alloc_physical_block;\n};\n\n#define rsv_start rsv_window._rsv_start\n#define rsv_end rsv_window._rsv_end\n\n/*\n * second extended-fs super-block data in memory\n */\nstruct ext2_sb_info {\n\tunsigned long s_frag_size;\t/* Size of a fragment in bytes */\n\tunsigned long s_frags_per_block;/* Number of fragments per block */\n\tunsigned long s_inodes_per_block;/* Number of inodes per block */\n\tunsigned long s_frags_per_group;/* Number of fragments in a group */\n\tunsigned long s_blocks_per_group;/* Number of blocks in a group */\n\tunsigned long s_inodes_per_group;/* Number of inodes in a group */\n\tunsigned long s_itb_per_group;\t/* Number of inode table blocks per group */\n\tunsigned long s_gdb_count;\t/* Number of group descriptor blocks */\n\tunsigned long s_desc_per_block;\t/* Number of group descriptors per block */\n\tunsigned long s_groups_count;\t/* Number of groups in the fs */\n\tunsigned long s_overhead_last;  /* Last calculated overhead */\n\tunsigned long s_blocks_last;    /* Last seen block count */\n\tstruct buffer_head * s_sbh;\t/* Buffer containing the super block */\n\tstruct ext2_super_block * s_es;\t/* Pointer to the super block in the buffer */\n\tstruct buffer_head ** s_group_desc;\n\tunsigned long  s_mount_opt;\n\tunsigned long s_sb_block;\n\tkuid_t s_resuid;\n\tkgid_t s_resgid;\n\tunsigned short s_mount_state;\n\tunsigned short s_pad;\n\tint s_addr_per_block_bits;\n\tint s_desc_per_block_bits;\n\tint s_inode_size;\n\tint s_first_ino;\n\tspinlock_t s_next_gen_lock;\n\tu32 s_next_generation;\n\tunsigned long s_dir_count;\n\tu8 *s_debts;\n\tstruct percpu_counter s_freeblocks_counter;\n\tstruct percpu_counter s_freeinodes_counter;\n\tstruct percpu_counter s_dirs_counter;\n\tstruct blockgroup_lock *s_blockgroup_lock;\n\t/* root of the per fs reservation window tree */\n\tspinlock_t s_rsv_window_lock;\n\tstruct rb_root s_rsv_window_root;\n\tstruct ext2_reserve_window_node s_rsv_window_head;\n\t/*\n\t * s_lock protects against concurrent modifications of s_mount_state,\n\t * s_blocks_last, s_overhead_last and the content of superblock's\n\t * buffer pointed to by sbi->s_es.\n\t *\n\t * Note: It is used in ext2_show_options() to provide a consistent view\n\t * of the mount options.\n\t */\n\tspinlock_t s_lock;\n};\n\nstatic inline spinlock_t *\nsb_bgl_lock(struct ext2_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}\n\n/*\n * Define EXT2FS_DEBUG to produce debug messages\n */\n#undef EXT2FS_DEBUG\n\n/*\n * Define EXT2_RESERVATION to reserve data blocks for expanding files\n */\n#define EXT2_DEFAULT_RESERVE_BLOCKS     8\n/*max window size: 1024(direct blocks) + 3([t,d]indirect blocks) */\n#define EXT2_MAX_RESERVE_BLOCKS         1027\n#define EXT2_RESERVE_WINDOW_NOT_ALLOCATED 0\n/*\n * The second extended file system version\n */\n#define EXT2FS_DATE\t\t\"95/08/09\"\n#define EXT2FS_VERSION\t\t\"0.5b\"\n\n/*\n * Debug code\n */\n#ifdef EXT2FS_DEBUG\n#\tdefine ext2_debug(f, a...)\t{ \\\n\t\t\t\t\tprintk (\"EXT2-fs DEBUG (%s, %d): %s:\", \\\n\t\t\t\t\t\t__FILE__, __LINE__, __func__); \\\n\t\t\t\t  \tprintk (f, ## a); \\\n\t\t\t\t\t}\n#else\n#\tdefine ext2_debug(f, a...)\t/**/\n#endif\n\n/*\n * Special inode numbers\n */\n#define\tEXT2_BAD_INO\t\t 1\t/* Bad blocks inode */\n#define EXT2_ROOT_INO\t\t 2\t/* Root inode */\n#define EXT2_BOOT_LOADER_INO\t 5\t/* Boot loader inode */\n#define EXT2_UNDEL_DIR_INO\t 6\t/* Undelete directory inode */\n\n/* First non-reserved inode for old ext2 filesystems */\n#define EXT2_GOOD_OLD_FIRST_INO\t11\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}\n\n/*\n * Macro-instructions used to manage several block sizes\n */\n#define EXT2_MIN_BLOCK_SIZE\t\t1024\n#define\tEXT2_MAX_BLOCK_SIZE\t\t4096\n#define EXT2_MIN_BLOCK_LOG_SIZE\t\t  10\n#define EXT2_BLOCK_SIZE(s)\t\t((s)->s_blocksize)\n#define\tEXT2_ADDR_PER_BLOCK(s)\t\t(EXT2_BLOCK_SIZE(s) / sizeof (__u32))\n#define EXT2_BLOCK_SIZE_BITS(s)\t\t((s)->s_blocksize_bits)\n#define\tEXT2_ADDR_PER_BLOCK_BITS(s)\t(EXT2_SB(s)->s_addr_per_block_bits)\n#define EXT2_INODE_SIZE(s)\t\t(EXT2_SB(s)->s_inode_size)\n#define EXT2_FIRST_INO(s)\t\t(EXT2_SB(s)->s_first_ino)\n\n/*\n * Macro-instructions used to manage fragments\n */\n#define EXT2_MIN_FRAG_SIZE\t\t1024\n#define\tEXT2_MAX_FRAG_SIZE\t\t4096\n#define EXT2_MIN_FRAG_LOG_SIZE\t\t  10\n#define EXT2_FRAG_SIZE(s)\t\t(EXT2_SB(s)->s_frag_size)\n#define EXT2_FRAGS_PER_BLOCK(s)\t\t(EXT2_SB(s)->s_frags_per_block)\n\n/*\n * Structure of a blocks group descriptor\n */\nstruct ext2_group_desc\n{\n\t__le32\tbg_block_bitmap;\t\t/* Blocks bitmap block */\n\t__le32\tbg_inode_bitmap;\t\t/* Inodes bitmap block */\n\t__le32\tbg_inode_table;\t\t/* Inodes table block */\n\t__le16\tbg_free_blocks_count;\t/* Free blocks count */\n\t__le16\tbg_free_inodes_count;\t/* Free inodes count */\n\t__le16\tbg_used_dirs_count;\t/* Directories count */\n\t__le16\tbg_pad;\n\t__le32\tbg_reserved[3];\n};\n\n/*\n * Macro-instructions used to manage group descriptors\n */\n#define EXT2_BLOCKS_PER_GROUP(s)\t(EXT2_SB(s)->s_blocks_per_group)\n#define EXT2_DESC_PER_BLOCK(s)\t\t(EXT2_SB(s)->s_desc_per_block)\n#define EXT2_INODES_PER_GROUP(s)\t(EXT2_SB(s)->s_inodes_per_group)\n#define EXT2_DESC_PER_BLOCK_BITS(s)\t(EXT2_SB(s)->s_desc_per_block_bits)\n\n/*\n * Constants relative to the data blocks\n */\n#define\tEXT2_NDIR_BLOCKS\t\t12\n#define\tEXT2_IND_BLOCK\t\t\tEXT2_NDIR_BLOCKS\n#define\tEXT2_DIND_BLOCK\t\t\t(EXT2_IND_BLOCK + 1)\n#define\tEXT2_TIND_BLOCK\t\t\t(EXT2_DIND_BLOCK + 1)\n#define\tEXT2_N_BLOCKS\t\t\t(EXT2_TIND_BLOCK + 1)\n\n/*\n * Inode flags (GETFLAGS/SETFLAGS)\n */\n#define\tEXT2_SECRM_FL\t\t\tFS_SECRM_FL\t/* Secure deletion */\n#define\tEXT2_UNRM_FL\t\t\tFS_UNRM_FL\t/* Undelete */\n#define\tEXT2_COMPR_FL\t\t\tFS_COMPR_FL\t/* Compress file */\n#define EXT2_SYNC_FL\t\t\tFS_SYNC_FL\t/* Synchronous updates */\n#define EXT2_IMMUTABLE_FL\t\tFS_IMMUTABLE_FL\t/* Immutable file */\n#define EXT2_APPEND_FL\t\t\tFS_APPEND_FL\t/* writes to file may only append */\n#define EXT2_NODUMP_FL\t\t\tFS_NODUMP_FL\t/* do not dump file */\n#define EXT2_NOATIME_FL\t\t\tFS_NOATIME_FL\t/* do not update atime */\n/* Reserved for compression usage... */\n#define EXT2_DIRTY_FL\t\t\tFS_DIRTY_FL\n#define EXT2_COMPRBLK_FL\t\tFS_COMPRBLK_FL\t/* One or more compressed clusters */\n#define EXT2_NOCOMP_FL\t\t\tFS_NOCOMP_FL\t/* Don't compress */\n#define EXT2_ECOMPR_FL\t\t\tFS_ECOMPR_FL\t/* Compression error */\n/* End compression flags --- maybe not all used */\t\n#define EXT2_BTREE_FL\t\t\tFS_BTREE_FL\t/* btree format dir */\n#define EXT2_INDEX_FL\t\t\tFS_INDEX_FL\t/* hash-indexed directory */\n#define EXT2_IMAGIC_FL\t\t\tFS_IMAGIC_FL\t/* AFS directory */\n#define EXT2_JOURNAL_DATA_FL\t\tFS_JOURNAL_DATA_FL /* Reserved for ext3 */\n#define EXT2_NOTAIL_FL\t\t\tFS_NOTAIL_FL\t/* file tail should not be merged */\n#define EXT2_DIRSYNC_FL\t\t\tFS_DIRSYNC_FL\t/* dirsync behaviour (directories only) */\n#define EXT2_TOPDIR_FL\t\t\tFS_TOPDIR_FL\t/* Top of directory hierarchies*/\n#define EXT2_RESERVED_FL\t\tFS_RESERVED_FL\t/* reserved for ext2 lib */\n\n#define EXT2_FL_USER_VISIBLE\t\tFS_FL_USER_VISIBLE\t/* User visible flags */\n#define EXT2_FL_USER_MODIFIABLE\t\tFS_FL_USER_MODIFIABLE\t/* User modifiable flags */\n\n/* Flags that should be inherited by new inodes from their parent. */\n#define EXT2_FL_INHERITED (EXT2_SECRM_FL | EXT2_UNRM_FL | EXT2_COMPR_FL |\\\n\t\t\t   EXT2_SYNC_FL | EXT2_NODUMP_FL |\\\n\t\t\t   EXT2_NOATIME_FL | EXT2_COMPRBLK_FL |\\\n\t\t\t   EXT2_NOCOMP_FL | EXT2_JOURNAL_DATA_FL |\\\n\t\t\t   EXT2_NOTAIL_FL | EXT2_DIRSYNC_FL)\n\n/* Flags that are appropriate for regular files (all but dir-specific ones). */\n#define EXT2_REG_FLMASK (~(EXT2_DIRSYNC_FL | EXT2_TOPDIR_FL))\n\n/* Flags that are appropriate for non-directories/regular files. */\n#define EXT2_OTHER_FLMASK (EXT2_NODUMP_FL | EXT2_NOATIME_FL)\n\n/* Mask out flags that are inappropriate for the given type of inode. */\nstatic inline __u32 ext2_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & EXT2_REG_FLMASK;\n\telse\n\t\treturn flags & EXT2_OTHER_FLMASK;\n}\n\n/*\n * ioctl commands\n */\n#define\tEXT2_IOC_GETFLAGS\t\tFS_IOC_GETFLAGS\n#define\tEXT2_IOC_SETFLAGS\t\tFS_IOC_SETFLAGS\n#define\tEXT2_IOC_GETVERSION\t\tFS_IOC_GETVERSION\n#define\tEXT2_IOC_SETVERSION\t\tFS_IOC_SETVERSION\n#define\tEXT2_IOC_GETRSVSZ\t\t_IOR('f', 5, long)\n#define\tEXT2_IOC_SETRSVSZ\t\t_IOW('f', 6, long)\n\n/*\n * ioctl commands in 32 bit emulation\n */\n#define EXT2_IOC32_GETFLAGS\t\tFS_IOC32_GETFLAGS\n#define EXT2_IOC32_SETFLAGS\t\tFS_IOC32_SETFLAGS\n#define EXT2_IOC32_GETVERSION\t\tFS_IOC32_GETVERSION\n#define EXT2_IOC32_SETVERSION\t\tFS_IOC32_SETVERSION\n\n/*\n * Structure of an inode on the disk\n */\nstruct ext2_inode {\n\t__le16\ti_mode;\t\t/* File mode */\n\t__le16\ti_uid;\t\t/* Low 16 bits of Owner Uid */\n\t__le32\ti_size;\t\t/* Size in bytes */\n\t__le32\ti_atime;\t/* Access time */\n\t__le32\ti_ctime;\t/* Creation time */\n\t__le32\ti_mtime;\t/* Modification time */\n\t__le32\ti_dtime;\t/* Deletion Time */\n\t__le16\ti_gid;\t\t/* Low 16 bits of Group Id */\n\t__le16\ti_links_count;\t/* Links count */\n\t__le32\ti_blocks;\t/* Blocks count */\n\t__le32\ti_flags;\t/* File flags */\n\tunion {\n\t\tstruct {\n\t\t\t__le32  l_i_reserved1;\n\t\t} linux1;\n\t\tstruct {\n\t\t\t__le32  h_i_translator;\n\t\t} hurd1;\n\t\tstruct {\n\t\t\t__le32  m_i_reserved1;\n\t\t} masix1;\n\t} osd1;\t\t\t\t/* OS dependent 1 */\n\t__le32\ti_block[EXT2_N_BLOCKS];/* Pointers to blocks */\n\t__le32\ti_generation;\t/* File version (for NFS) */\n\t__le32\ti_file_acl;\t/* File ACL */\n\t__le32\ti_dir_acl;\t/* Directory ACL */\n\t__le32\ti_faddr;\t/* Fragment address */\n\tunion {\n\t\tstruct {\n\t\t\t__u8\tl_i_frag;\t/* Fragment number */\n\t\t\t__u8\tl_i_fsize;\t/* Fragment size */\n\t\t\t__u16\ti_pad1;\n\t\t\t__le16\tl_i_uid_high;\t/* these 2 fields    */\n\t\t\t__le16\tl_i_gid_high;\t/* were reserved2[0] */\n\t\t\t__u32\tl_i_reserved2;\n\t\t} linux2;\n\t\tstruct {\n\t\t\t__u8\th_i_frag;\t/* Fragment number */\n\t\t\t__u8\th_i_fsize;\t/* Fragment size */\n\t\t\t__le16\th_i_mode_high;\n\t\t\t__le16\th_i_uid_high;\n\t\t\t__le16\th_i_gid_high;\n\t\t\t__le32\th_i_author;\n\t\t} hurd2;\n\t\tstruct {\n\t\t\t__u8\tm_i_frag;\t/* Fragment number */\n\t\t\t__u8\tm_i_fsize;\t/* Fragment size */\n\t\t\t__u16\tm_pad1;\n\t\t\t__u32\tm_i_reserved2[2];\n\t\t} masix2;\n\t} osd2;\t\t\t\t/* OS dependent 2 */\n};\n\n#define i_size_high\ti_dir_acl\n\n#define i_reserved1\tosd1.linux1.l_i_reserved1\n#define i_frag\t\tosd2.linux2.l_i_frag\n#define i_fsize\t\tosd2.linux2.l_i_fsize\n#define i_uid_low\ti_uid\n#define i_gid_low\ti_gid\n#define i_uid_high\tosd2.linux2.l_i_uid_high\n#define i_gid_high\tosd2.linux2.l_i_gid_high\n#define i_reserved2\tosd2.linux2.l_i_reserved2\n\n/*\n * File system states\n */\n#define\tEXT2_VALID_FS\t\t\t0x0001\t/* Unmounted cleanly */\n#define\tEXT2_ERROR_FS\t\t\t0x0002\t/* Errors detected */\n\n/*\n * Mount flags\n */\n#define EXT2_MOUNT_CHECK\t\t0x000001  /* Do mount-time checks */\n#define EXT2_MOUNT_OLDALLOC\t\t0x000002  /* Don't use the new Orlov allocator */\n#define EXT2_MOUNT_GRPID\t\t0x000004  /* Create files with directory's group */\n#define EXT2_MOUNT_DEBUG\t\t0x000008  /* Some debugging messages */\n#define EXT2_MOUNT_ERRORS_CONT\t\t0x000010  /* Continue on errors */\n#define EXT2_MOUNT_ERRORS_RO\t\t0x000020  /* Remount fs ro on errors */\n#define EXT2_MOUNT_ERRORS_PANIC\t\t0x000040  /* Panic on errors */\n#define EXT2_MOUNT_MINIX_DF\t\t0x000080  /* Mimics the Minix statfs */\n#define EXT2_MOUNT_NOBH\t\t\t0x000100  /* No buffer_heads */\n#define EXT2_MOUNT_NO_UID32\t\t0x000200  /* Disable 32-bit UIDs */\n#define EXT2_MOUNT_XATTR_USER\t\t0x004000  /* Extended user attributes */\n#define EXT2_MOUNT_POSIX_ACL\t\t0x008000  /* POSIX Access Control Lists */\n#define EXT2_MOUNT_XIP\t\t\t0x010000  /* Obsolete, use DAX */\n#define EXT2_MOUNT_USRQUOTA\t\t0x020000  /* user quota */\n#define EXT2_MOUNT_GRPQUOTA\t\t0x040000  /* group quota */\n#define EXT2_MOUNT_RESERVATION\t\t0x080000  /* Preallocation */\n#ifdef CONFIG_FS_DAX\n#define EXT2_MOUNT_DAX\t\t\t0x100000  /* Direct Access */\n#else\n#define EXT2_MOUNT_DAX\t\t\t0\n#endif\n\n\n#define clear_opt(o, opt)\t\to &= ~EXT2_MOUNT_##opt\n#define set_opt(o, opt)\t\t\to |= EXT2_MOUNT_##opt\n#define test_opt(sb, opt)\t\t(EXT2_SB(sb)->s_mount_opt & \\\n\t\t\t\t\t EXT2_MOUNT_##opt)\n/*\n * Maximal mount counts between two filesystem checks\n */\n#define EXT2_DFL_MAX_MNT_COUNT\t\t20\t/* Allow 20 mounts */\n#define EXT2_DFL_CHECKINTERVAL\t\t0\t/* Don't use interval check */\n\n/*\n * Behaviour when detecting errors\n */\n#define EXT2_ERRORS_CONTINUE\t\t1\t/* Continue execution */\n#define EXT2_ERRORS_RO\t\t\t2\t/* Remount fs read-only */\n#define EXT2_ERRORS_PANIC\t\t3\t/* Panic */\n#define EXT2_ERRORS_DEFAULT\t\tEXT2_ERRORS_CONTINUE\n\n/*\n * Structure of the super block\n */\nstruct ext2_super_block {\n\t__le32\ts_inodes_count;\t\t/* Inodes count */\n\t__le32\ts_blocks_count;\t\t/* Blocks count */\n\t__le32\ts_r_blocks_count;\t/* Reserved blocks count */\n\t__le32\ts_free_blocks_count;\t/* Free blocks count */\n\t__le32\ts_free_inodes_count;\t/* Free inodes count */\n\t__le32\ts_first_data_block;\t/* First Data Block */\n\t__le32\ts_log_block_size;\t/* Block size */\n\t__le32\ts_log_frag_size;\t/* Fragment size */\n\t__le32\ts_blocks_per_group;\t/* # Blocks per group */\n\t__le32\ts_frags_per_group;\t/* # Fragments per group */\n\t__le32\ts_inodes_per_group;\t/* # Inodes per group */\n\t__le32\ts_mtime;\t\t/* Mount time */\n\t__le32\ts_wtime;\t\t/* Write time */\n\t__le16\ts_mnt_count;\t\t/* Mount count */\n\t__le16\ts_max_mnt_count;\t/* Maximal mount count */\n\t__le16\ts_magic;\t\t/* Magic signature */\n\t__le16\ts_state;\t\t/* File system state */\n\t__le16\ts_errors;\t\t/* Behaviour when detecting errors */\n\t__le16\ts_minor_rev_level; \t/* minor revision level */\n\t__le32\ts_lastcheck;\t\t/* time of last check */\n\t__le32\ts_checkinterval;\t/* max. time between checks */\n\t__le32\ts_creator_os;\t\t/* OS */\n\t__le32\ts_rev_level;\t\t/* Revision level */\n\t__le16\ts_def_resuid;\t\t/* Default uid for reserved blocks */\n\t__le16\ts_def_resgid;\t\t/* Default gid for reserved blocks */\n\t/*\n\t * These fields are for EXT2_DYNAMIC_REV superblocks only.\n\t *\n\t * Note: the difference between the compatible feature set and\n\t * the incompatible feature set is that if there is a bit set\n\t * in the incompatible feature set that the kernel doesn't\n\t * know about, it should refuse to mount the filesystem.\n\t * \n\t * e2fsck's requirements are more strict; if it doesn't know\n\t * about a feature in either the compatible or incompatible\n\t * feature set, it must abort and not try to meddle with\n\t * things it doesn't understand...\n\t */\n\t__le32\ts_first_ino; \t\t/* First non-reserved inode */\n\t__le16   s_inode_size; \t\t/* size of inode structure */\n\t__le16\ts_block_group_nr; \t/* block group # of this superblock */\n\t__le32\ts_feature_compat; \t/* compatible feature set */\n\t__le32\ts_feature_incompat; \t/* incompatible feature set */\n\t__le32\ts_feature_ro_compat; \t/* readonly-compatible feature set */\n\t__u8\ts_uuid[16];\t\t/* 128-bit uuid for volume */\n\tchar\ts_volume_name[16]; \t/* volume name */\n\tchar\ts_last_mounted[64]; \t/* directory where last mounted */\n\t__le32\ts_algorithm_usage_bitmap; /* For compression */\n\t/*\n\t * Performance hints.  Directory preallocation should only\n\t * happen if the EXT2_COMPAT_PREALLOC flag is on.\n\t */\n\t__u8\ts_prealloc_blocks;\t/* Nr of blocks to try to preallocate*/\n\t__u8\ts_prealloc_dir_blocks;\t/* Nr to preallocate for dirs */\n\t__u16\ts_padding1;\n\t/*\n\t * Journaling support valid if EXT3_FEATURE_COMPAT_HAS_JOURNAL set.\n\t */\n\t__u8\ts_journal_uuid[16];\t/* uuid of journal superblock */\n\t__u32\ts_journal_inum;\t\t/* inode number of journal file */\n\t__u32\ts_journal_dev;\t\t/* device number of journal file */\n\t__u32\ts_last_orphan;\t\t/* start of list of inodes to delete */\n\t__u32\ts_hash_seed[4];\t\t/* HTREE hash seed */\n\t__u8\ts_def_hash_version;\t/* Default hash version to use */\n\t__u8\ts_reserved_char_pad;\n\t__u16\ts_reserved_word_pad;\n\t__le32\ts_default_mount_opts;\n \t__le32\ts_first_meta_bg; \t/* First metablock block group */\n\t__u32\ts_reserved[190];\t/* Padding to the end of the block */\n};\n\n/*\n * Codes for operating systems\n */\n#define EXT2_OS_LINUX\t\t0\n#define EXT2_OS_HURD\t\t1\n#define EXT2_OS_MASIX\t\t2\n#define EXT2_OS_FREEBSD\t\t3\n#define EXT2_OS_LITES\t\t4\n\n/*\n * Revision levels\n */\n#define EXT2_GOOD_OLD_REV\t0\t/* The good old (original) format */\n#define EXT2_DYNAMIC_REV\t1 \t/* V2 format w/ dynamic inode sizes */\n\n#define EXT2_CURRENT_REV\tEXT2_GOOD_OLD_REV\n#define EXT2_MAX_SUPP_REV\tEXT2_DYNAMIC_REV\n\n#define EXT2_GOOD_OLD_INODE_SIZE 128\n\n/*\n * Feature set definitions\n */\n\n#define EXT2_HAS_COMPAT_FEATURE(sb,mask)\t\t\t\\\n\t( EXT2_SB(sb)->s_es->s_feature_compat & cpu_to_le32(mask) )\n#define EXT2_HAS_RO_COMPAT_FEATURE(sb,mask)\t\t\t\\\n\t( EXT2_SB(sb)->s_es->s_feature_ro_compat & cpu_to_le32(mask) )\n#define EXT2_HAS_INCOMPAT_FEATURE(sb,mask)\t\t\t\\\n\t( EXT2_SB(sb)->s_es->s_feature_incompat & cpu_to_le32(mask) )\n#define EXT2_SET_COMPAT_FEATURE(sb,mask)\t\t\t\\\n\tEXT2_SB(sb)->s_es->s_feature_compat |= cpu_to_le32(mask)\n#define EXT2_SET_RO_COMPAT_FEATURE(sb,mask)\t\t\t\\\n\tEXT2_SB(sb)->s_es->s_feature_ro_compat |= cpu_to_le32(mask)\n#define EXT2_SET_INCOMPAT_FEATURE(sb,mask)\t\t\t\\\n\tEXT2_SB(sb)->s_es->s_feature_incompat |= cpu_to_le32(mask)\n#define EXT2_CLEAR_COMPAT_FEATURE(sb,mask)\t\t\t\\\n\tEXT2_SB(sb)->s_es->s_feature_compat &= ~cpu_to_le32(mask)\n#define EXT2_CLEAR_RO_COMPAT_FEATURE(sb,mask)\t\t\t\\\n\tEXT2_SB(sb)->s_es->s_feature_ro_compat &= ~cpu_to_le32(mask)\n#define EXT2_CLEAR_INCOMPAT_FEATURE(sb,mask)\t\t\t\\\n\tEXT2_SB(sb)->s_es->s_feature_incompat &= ~cpu_to_le32(mask)\n\n#define EXT2_FEATURE_COMPAT_DIR_PREALLOC\t0x0001\n#define EXT2_FEATURE_COMPAT_IMAGIC_INODES\t0x0002\n#define EXT3_FEATURE_COMPAT_HAS_JOURNAL\t\t0x0004\n#define EXT2_FEATURE_COMPAT_EXT_ATTR\t\t0x0008\n#define EXT2_FEATURE_COMPAT_RESIZE_INO\t\t0x0010\n#define EXT2_FEATURE_COMPAT_DIR_INDEX\t\t0x0020\n#define EXT2_FEATURE_COMPAT_ANY\t\t\t0xffffffff\n\n#define EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER\t0x0001\n#define EXT2_FEATURE_RO_COMPAT_LARGE_FILE\t0x0002\n#define EXT2_FEATURE_RO_COMPAT_BTREE_DIR\t0x0004\n#define EXT2_FEATURE_RO_COMPAT_ANY\t\t0xffffffff\n\n#define EXT2_FEATURE_INCOMPAT_COMPRESSION\t0x0001\n#define EXT2_FEATURE_INCOMPAT_FILETYPE\t\t0x0002\n#define EXT3_FEATURE_INCOMPAT_RECOVER\t\t0x0004\n#define EXT3_FEATURE_INCOMPAT_JOURNAL_DEV\t0x0008\n#define EXT2_FEATURE_INCOMPAT_META_BG\t\t0x0010\n#define EXT2_FEATURE_INCOMPAT_ANY\t\t0xffffffff\n\n#define EXT2_FEATURE_COMPAT_SUPP\tEXT2_FEATURE_COMPAT_EXT_ATTR\n#define EXT2_FEATURE_INCOMPAT_SUPP\t(EXT2_FEATURE_INCOMPAT_FILETYPE| \\\n\t\t\t\t\t EXT2_FEATURE_INCOMPAT_META_BG)\n#define EXT2_FEATURE_RO_COMPAT_SUPP\t(EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER| \\\n\t\t\t\t\t EXT2_FEATURE_RO_COMPAT_LARGE_FILE| \\\n\t\t\t\t\t EXT2_FEATURE_RO_COMPAT_BTREE_DIR)\n#define EXT2_FEATURE_RO_COMPAT_UNSUPPORTED\t~EXT2_FEATURE_RO_COMPAT_SUPP\n#define EXT2_FEATURE_INCOMPAT_UNSUPPORTED\t~EXT2_FEATURE_INCOMPAT_SUPP\n\n/*\n * Default values for user and/or group using reserved blocks\n */\n#define\tEXT2_DEF_RESUID\t\t0\n#define\tEXT2_DEF_RESGID\t\t0\n\n/*\n * Default mount options\n */\n#define EXT2_DEFM_DEBUG\t\t0x0001\n#define EXT2_DEFM_BSDGROUPS\t0x0002\n#define EXT2_DEFM_XATTR_USER\t0x0004\n#define EXT2_DEFM_ACL\t\t0x0008\n#define EXT2_DEFM_UID16\t\t0x0010\n    /* Not used by ext2, but reserved for use by ext3 */\n#define EXT3_DEFM_JMODE\t\t0x0060 \n#define EXT3_DEFM_JMODE_DATA\t0x0020\n#define EXT3_DEFM_JMODE_ORDERED\t0x0040\n#define EXT3_DEFM_JMODE_WBACK\t0x0060\n\n/*\n * Structure of a directory entry\n */\n\nstruct ext2_dir_entry {\n\t__le32\tinode;\t\t\t/* Inode number */\n\t__le16\trec_len;\t\t/* Directory entry length */\n\t__le16\tname_len;\t\t/* Name length */\n\tchar\tname[];\t\t\t/* File name, up to EXT2_NAME_LEN */\n};\n\n/*\n * The new version of the directory entry.  Since EXT2 structures are\n * stored in intel byte order, and the name_len field could never be\n * bigger than 255 chars, it's safe to reclaim the extra byte for the\n * file_type field.\n */\nstruct ext2_dir_entry_2 {\n\t__le32\tinode;\t\t\t/* Inode number */\n\t__le16\trec_len;\t\t/* Directory entry length */\n\t__u8\tname_len;\t\t/* Name length */\n\t__u8\tfile_type;\n\tchar\tname[];\t\t\t/* File name, up to EXT2_NAME_LEN */\n};\n\n/*\n * Ext2 directory file types.  Only the low 3 bits are used.  The\n * other bits are reserved for now.\n */\nenum {\n\tEXT2_FT_UNKNOWN\t\t= 0,\n\tEXT2_FT_REG_FILE\t= 1,\n\tEXT2_FT_DIR\t\t= 2,\n\tEXT2_FT_CHRDEV\t\t= 3,\n\tEXT2_FT_BLKDEV\t\t= 4,\n\tEXT2_FT_FIFO\t\t= 5,\n\tEXT2_FT_SOCK\t\t= 6,\n\tEXT2_FT_SYMLINK\t\t= 7,\n\tEXT2_FT_MAX\n};\n\n/*\n * EXT2_DIR_PAD defines the directory entries boundaries\n *\n * NOTE: It must be a multiple of 4\n */\n#define EXT2_DIR_PAD\t\t \t4\n#define EXT2_DIR_ROUND \t\t\t(EXT2_DIR_PAD - 1)\n#define EXT2_DIR_REC_LEN(name_len)\t(((name_len) + 8 + EXT2_DIR_ROUND) & \\\n\t\t\t\t\t ~EXT2_DIR_ROUND)\n#define EXT2_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline void verify_offsets(void)\n{\n#define A(x,y) BUILD_BUG_ON(x != offsetof(struct ext2_super_block, y));\n\tA(EXT2_SB_MAGIC_OFFSET, s_magic);\n\tA(EXT2_SB_BLOCKS_OFFSET, s_blocks_count);\n\tA(EXT2_SB_BSIZE_OFFSET, s_log_block_size);\n#undef A\n}\n\n/*\n * ext2 mount options\n */\nstruct ext2_mount_options {\n\tunsigned long s_mount_opt;\n\tkuid_t s_resuid;\n\tkgid_t s_resgid;\n};\n\n/*\n * second extended file system inode data in memory\n */\nstruct ext2_inode_info {\n\t__le32\ti_data[15];\n\t__u32\ti_flags;\n\t__u32\ti_faddr;\n\t__u8\ti_frag_no;\n\t__u8\ti_frag_size;\n\t__u16\ti_state;\n\t__u32\ti_file_acl;\n\t__u32\ti_dir_acl;\n\t__u32\ti_dtime;\n\n\t/*\n\t * i_block_group is the number of the block group which contains\n\t * this file's inode.  Constant across the lifetime of the inode,\n\t * it is used for making block allocation decisions - we try to\n\t * place a file's data blocks near its inode block, and new inodes\n\t * near to their parent directory's inode.\n\t */\n\t__u32\ti_block_group;\n\n\t/* block reservation info */\n\tstruct ext2_block_alloc_info *i_block_alloc_info;\n\n\t__u32\ti_dir_start_lookup;\n#ifdef CONFIG_EXT2_FS_XATTR\n\t/*\n\t * Extended attributes can be read independently of the main file\n\t * data. Taking i_mutex even when reading would cause contention\n\t * between readers of EAs and writers of regular file data, so\n\t * instead we synchronize on xattr_sem when reading or changing\n\t * EAs.\n\t */\n\tstruct rw_semaphore xattr_sem;\n#endif\n\trwlock_t i_meta_lock;\n#ifdef CONFIG_FS_DAX\n\tstruct rw_semaphore dax_sem;\n#endif\n\n\t/*\n\t * truncate_mutex is for serialising ext2_truncate() against\n\t * ext2_getblock().  It also protects the internals of the inode's\n\t * reservation data structures: ext2_reserve_window and\n\t * ext2_reserve_window_node.\n\t */\n\tstruct mutex truncate_mutex;\n\tstruct inode\tvfs_inode;\n\tstruct list_head i_orphan;\t/* unlinked but open inodes */\n#ifdef CONFIG_QUOTA\n\tstruct dquot *i_dquot[MAXQUOTAS];\n#endif\n};\n\n#ifdef CONFIG_FS_DAX\n#define dax_sem_down_write(ext2_inode)\tdown_write(&(ext2_inode)->dax_sem)\n#define dax_sem_up_write(ext2_inode)\tup_write(&(ext2_inode)->dax_sem)\n#else\n#define dax_sem_down_write(ext2_inode)\n#define dax_sem_up_write(ext2_inode)\n#endif\n\n/*\n * Inode dynamic state flags\n */\n#define EXT2_STATE_NEW\t\t\t0x00000001 /* inode is newly created */\n\n\n/*\n * Function prototypes\n */\n\n/*\n * Ok, these declarations are also in <linux/kernel.h> but none of the\n * ext2 source programs needs to include it so they are duplicated here.\n */\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}\n\n/* balloc.c */\nextern int ext2_bg_has_super(struct super_block *sb, int group);\nextern unsigned long ext2_bg_num_gdb(struct super_block *sb, int group);\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern struct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t\t    unsigned int block_group,\n\t\t\t\t\t\t    struct buffer_head ** bh);\nextern void ext2_discard_reservation (struct inode *);\nextern int ext2_should_retry_alloc(struct super_block *sb, int *retries);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern void ext2_rsv_window_add(struct super_block *sb, struct ext2_reserve_window_node *rsv);\n\n/* dir.c */\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern ino_t ext2_inode_by_name(struct inode *, struct qstr *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern struct ext2_dir_entry_2 * ext2_find_entry (struct inode *,struct qstr *, struct page **);\nextern int ext2_delete_entry (struct ext2_dir_entry_2 *, struct page *);\nextern int ext2_empty_dir (struct inode *);\nextern struct ext2_dir_entry_2 * ext2_dotdot (struct inode *, struct page **);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\n\n/* ialloc.c */\nextern struct inode * ext2_new_inode (struct inode *, umode_t, const struct qstr *);\nextern void ext2_free_inode (struct inode *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern unsigned long ext2_count_free (struct buffer_head *, unsigned);\n\n/* inode.c */\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\nextern int ext2_write_inode (struct inode *, struct writeback_control *);\nextern void ext2_evict_inode(struct inode *);\nextern int ext2_get_block(struct inode *, sector_t, struct buffer_head *, int);\nextern int ext2_setattr (struct dentry *, struct iattr *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\nextern int ext2_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);\n\n/* ioctl.c */\nextern long ext2_ioctl(struct file *, unsigned int, unsigned long);\nextern long ext2_compat_ioctl(struct file *, unsigned int, unsigned long);\n\n/* namei.c */\nstruct dentry *ext2_get_parent(struct dentry *child);\n\n/* super.c */\nextern __printf(3, 4)\nvoid ext2_error(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext2_msg(struct super_block *, const char *, const char *, ...);\nextern void ext2_update_dynamic_rev (struct super_block *sb);\nextern void ext2_write_super (struct super_block *);\n\n/*\n * Inodes and files operations\n */\n\n/* dir.c */\nextern const struct file_operations ext2_dir_operations;\n\n/* file.c */\nextern int ext2_fsync(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync);\nextern const struct inode_operations ext2_file_inode_operations;\nextern const struct file_operations ext2_file_operations;\n\n/* inode.c */\nextern const struct address_space_operations ext2_aops;\nextern const struct address_space_operations ext2_nobh_aops;\n\n/* namei.c */\nextern const struct inode_operations ext2_dir_inode_operations;\nextern const struct inode_operations ext2_special_inode_operations;\n\n/* symlink.c */\nextern const struct inode_operations ext2_fast_symlink_inode_operations;\nextern const struct inode_operations ext2_symlink_inode_operations;\n\nstatic inline ext2_fsblk_t\next2_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext2_fsblk_t)EXT2_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT2_SB(sb)->s_es->s_first_data_block);\n}\n\n#define ext2_set_bit\t__test_and_set_bit_le\n#define ext2_clear_bit\t__test_and_clear_bit_le\n#define ext2_test_bit\ttest_bit_le\n#define ext2_find_first_zero_bit\tfind_first_zero_bit_le\n#define ext2_find_next_zero_bit\t\tfind_next_zero_bit_le\n", "/*\n *  linux/fs/ext2/super.c\n *\n * Copyright (C) 1992, 1993, 1994, 1995\n * Remy Card (card@masi.ibp.fr)\n * Laboratoire MASI - Institut Blaise Pascal\n * Universite Pierre et Marie Curie (Paris VI)\n *\n *  from\n *\n *  linux/fs/minix/inode.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n *\n *  Big-endian to little-endian byte-swapping/bitmaps by\n *        David S. Miller (davem@caip.rutgers.edu), 1995\n */\n\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/parser.h>\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/exportfs.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/quotaops.h>\n#include <asm/uaccess.h>\n#include \"ext2.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n\nstatic void ext2_sync_super(struct super_block *sb,\n\t\t\t    struct ext2_super_block *es, int wait);\nstatic int ext2_remount (struct super_block * sb, int * flags, char * data);\nstatic int ext2_statfs (struct dentry * dentry, struct kstatfs * buf);\nstatic int ext2_sync_fs(struct super_block *sb, int wait);\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}\n\nvoid ext2_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT2-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}\n\n/*\n * This must be called with sbi->s_lock held.\n */\nvoid ext2_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext2_super_block *es = EXT2_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT2_GOOD_OLD_REV)\n\t\treturn;\n\n\text2_msg(sb, KERN_WARNING,\n\t\t     \"warning: updating to rev %d because of \"\n\t\t     \"new feature flag, running e2fsck is recommended\",\n\t\t     EXT2_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT2_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT2_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT2_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}\n\nstatic void ext2_put_super (struct super_block * sb)\n{\n\tint db_count;\n\tint i;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\n\text2_xattr_put_super(sb);\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tstruct ext2_super_block *es = sbi->s_es;\n\n\t\tspin_lock(&sbi->s_lock);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\tdb_count = sbi->s_gdb_count;\n\tfor (i = 0; i < db_count; i++)\n\t\tif (sbi->s_group_desc[i])\n\t\t\tbrelse (sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\n\tkfree(sbi->s_debts);\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tbrelse (sbi->s_sbh);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n}\n\nstatic struct kmem_cache * ext2_inode_cachep;\n\nstatic struct inode *ext2_alloc_inode(struct super_block *sb)\n{\n\tstruct ext2_inode_info *ei;\n\tei = kmem_cache_alloc(ext2_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\tei->i_block_alloc_info = NULL;\n\tei->vfs_inode.i_version = 1;\n#ifdef CONFIG_QUOTA\n\tmemset(&ei->i_dquot, 0, sizeof(ei->i_dquot));\n#endif\n\n\treturn &ei->vfs_inode;\n}\n\nstatic void ext2_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(ext2_inode_cachep, EXT2_I(inode));\n}\n\nstatic void ext2_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, ext2_i_callback);\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct ext2_inode_info *ei = (struct ext2_inode_info *) foo;\n\n\trwlock_init(&ei->i_meta_lock);\n#ifdef CONFIG_EXT2_FS_XATTR\n\tinit_rwsem(&ei->xattr_sem);\n#endif\n\tmutex_init(&ei->truncate_mutex);\n#ifdef CONFIG_FS_DAX\n\tinit_rwsem(&ei->dax_sem);\n#endif\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic int __init init_inodecache(void)\n{\n\text2_inode_cachep = kmem_cache_create(\"ext2_inode_cache\",\n\t\t\t\t\t     sizeof(struct ext2_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\t\t     init_once);\n\tif (ext2_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext2_inode_cachep);\n}\n\nstatic int ext2_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct super_block *sb = root->d_sb;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\tunsigned long def_mount_opts;\n\n\tspin_lock(&sbi->s_lock);\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\n\tif (sbi->s_sb_block != 1)\n\t\tseq_printf(seq, \",sb=%lu\", sbi->s_sb_block);\n\tif (test_opt(sb, MINIX_DF))\n\t\tseq_puts(seq, \",minixdf\");\n\tif (test_opt(sb, GRPID))\n\t\tseq_puts(seq, \",grpid\");\n\tif (!test_opt(sb, GRPID) && (def_mount_opts & EXT2_DEFM_BSDGROUPS))\n\t\tseq_puts(seq, \",nogrpid\");\n\tif (!uid_eq(sbi->s_resuid, make_kuid(&init_user_ns, EXT2_DEF_RESUID)) ||\n\t    le16_to_cpu(es->s_def_resuid) != EXT2_DEF_RESUID) {\n\t\tseq_printf(seq, \",resuid=%u\",\n\t\t\t\tfrom_kuid_munged(&init_user_ns, sbi->s_resuid));\n\t}\n\tif (!gid_eq(sbi->s_resgid, make_kgid(&init_user_ns, EXT2_DEF_RESGID)) ||\n\t    le16_to_cpu(es->s_def_resgid) != EXT2_DEF_RESGID) {\n\t\tseq_printf(seq, \",resgid=%u\",\n\t\t\t\tfrom_kgid_munged(&init_user_ns, sbi->s_resgid));\n\t}\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\tint def_errors = le16_to_cpu(es->s_errors);\n\n\t\tif (def_errors == EXT2_ERRORS_PANIC ||\n\t\t    def_errors == EXT2_ERRORS_CONTINUE) {\n\t\t\tseq_puts(seq, \",errors=remount-ro\");\n\t\t}\n\t}\n\tif (test_opt(sb, ERRORS_CONT))\n\t\tseq_puts(seq, \",errors=continue\");\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tseq_puts(seq, \",errors=panic\");\n\tif (test_opt(sb, NO_UID32))\n\t\tseq_puts(seq, \",nouid32\");\n\tif (test_opt(sb, DEBUG))\n\t\tseq_puts(seq, \",debug\");\n\tif (test_opt(sb, OLDALLOC))\n\t\tseq_puts(seq, \",oldalloc\");\n\n#ifdef CONFIG_EXT2_FS_XATTR\n\tif (test_opt(sb, XATTR_USER))\n\t\tseq_puts(seq, \",user_xattr\");\n\tif (!test_opt(sb, XATTR_USER) &&\n\t    (def_mount_opts & EXT2_DEFM_XATTR_USER)) {\n\t\tseq_puts(seq, \",nouser_xattr\");\n\t}\n#endif\n\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\tif (test_opt(sb, POSIX_ACL))\n\t\tseq_puts(seq, \",acl\");\n\tif (!test_opt(sb, POSIX_ACL) && (def_mount_opts & EXT2_DEFM_ACL))\n\t\tseq_puts(seq, \",noacl\");\n#endif\n\n\tif (test_opt(sb, NOBH))\n\t\tseq_puts(seq, \",nobh\");\n\n#if defined(CONFIG_QUOTA)\n\tif (sbi->s_mount_opt & EXT2_MOUNT_USRQUOTA)\n\t\tseq_puts(seq, \",usrquota\");\n\n\tif (sbi->s_mount_opt & EXT2_MOUNT_GRPQUOTA)\n\t\tseq_puts(seq, \",grpquota\");\n#endif\n\n#ifdef CONFIG_FS_DAX\n\tif (sbi->s_mount_opt & EXT2_MOUNT_XIP)\n\t\tseq_puts(seq, \",xip\");\n\tif (sbi->s_mount_opt & EXT2_MOUNT_DAX)\n\t\tseq_puts(seq, \",dax\");\n#endif\n\n\tif (!test_opt(sb, RESERVATION))\n\t\tseq_puts(seq, \",noreservation\");\n\n\tspin_unlock(&sbi->s_lock);\n\treturn 0;\n}\n\n#ifdef CONFIG_QUOTA\nstatic ssize_t ext2_quota_read(struct super_block *sb, int type, char *data, size_t len, loff_t off);\nstatic ssize_t ext2_quota_write(struct super_block *sb, int type, const char *data, size_t len, loff_t off);\nstatic struct dquot **ext2_get_dquots(struct inode *inode)\n{\n\treturn EXT2_I(inode)->i_dquot;\n}\n#endif\n\nstatic const struct super_operations ext2_sops = {\n\t.alloc_inode\t= ext2_alloc_inode,\n\t.destroy_inode\t= ext2_destroy_inode,\n\t.write_inode\t= ext2_write_inode,\n\t.evict_inode\t= ext2_evict_inode,\n\t.put_super\t= ext2_put_super,\n\t.sync_fs\t= ext2_sync_fs,\n\t.freeze_fs\t= ext2_freeze,\n\t.unfreeze_fs\t= ext2_unfreeze,\n\t.statfs\t\t= ext2_statfs,\n\t.remount_fs\t= ext2_remount,\n\t.show_options\t= ext2_show_options,\n#ifdef CONFIG_QUOTA\n\t.quota_read\t= ext2_quota_read,\n\t.quota_write\t= ext2_quota_write,\n\t.get_dquots\t= ext2_get_dquots,\n#endif\n};\n\nstatic struct inode *ext2_nfs_get_inode(struct super_block *sb,\n\t\tu64 ino, u32 generation)\n{\n\tstruct inode *inode;\n\n\tif (ino < EXT2_FIRST_INO(sb) && ino != EXT2_ROOT_INO)\n\t\treturn ERR_PTR(-ESTALE);\n\tif (ino > le32_to_cpu(EXT2_SB(sb)->s_es->s_inodes_count))\n\t\treturn ERR_PTR(-ESTALE);\n\n\t/*\n\t * ext2_iget isn't quite right if the inode is currently unallocated!\n\t * However ext2_iget currently does appropriate checks to handle stale\n\t * inodes so everything is OK.\n\t */\n\tinode = ext2_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (generation && inode->i_generation != generation) {\n\t\t/* we didn't find the right inode.. */\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\treturn inode;\n}\n\nstatic struct dentry *ext2_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext2_nfs_get_inode);\n}\n\nstatic struct dentry *ext2_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext2_nfs_get_inode);\n}\n\nstatic const struct export_operations ext2_export_ops = {\n\t.fh_to_dentry = ext2_fh_to_dentry,\n\t.fh_to_parent = ext2_fh_to_parent,\n\t.get_parent = ext2_get_parent,\n};\n\nstatic unsigned long get_sb_block(void **data)\n{\n\tunsigned long \tsb_block;\n\tchar \t\t*options = (char *) *data;\n\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t/* Default location */\n\toptions += 3;\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\tprintk(\"EXT2-fs: Invalid sb specification: %s\\n\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\treturn sb_block;\n}\n\nenum {\n\tOpt_bsd_df, Opt_minix_df, Opt_grpid, Opt_nogrpid,\n\tOpt_resgid, Opt_resuid, Opt_sb, Opt_err_cont, Opt_err_panic,\n\tOpt_err_ro, Opt_nouid32, Opt_nocheck, Opt_debug,\n\tOpt_oldalloc, Opt_orlov, Opt_nobh, Opt_user_xattr, Opt_nouser_xattr,\n\tOpt_acl, Opt_noacl, Opt_xip, Opt_dax, Opt_ignore, Opt_err, Opt_quota,\n\tOpt_usrquota, Opt_grpquota, Opt_reservation, Opt_noreservation\n};\n\nstatic const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_nocheck, \"check=none\"},\n\t{Opt_nocheck, \"nocheck\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_oldalloc, \"oldalloc\"},\n\t{Opt_orlov, \"orlov\"},\n\t{Opt_nobh, \"nobh\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_xip, \"xip\"},\n\t{Opt_dax, \"dax\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_ignore, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_reservation, \"reservation\"},\n\t{Opt_noreservation, \"noreservation\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(char *options, struct super_block *sb)\n{\n\tchar *p;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep (&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_bsd_df:\n\t\t\tclear_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_minix_df:\n\t\t\tset_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_grpid:\n\t\t\tset_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_nogrpid:\n\t\t\tclear_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_resuid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid)) {\n\t\t\t\text2_msg(sb, KERN_ERR, \"Invalid uid value %d\", option);\n\t\t\t\treturn 0;\n\n\t\t\t}\n\t\t\tsbi->s_resuid = uid;\n\t\t\tbreak;\n\t\tcase Opt_resgid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid)) {\n\t\t\t\text2_msg(sb, KERN_ERR, \"Invalid gid value %d\", option);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_resgid = gid;\n\t\t\tbreak;\n\t\tcase Opt_sb:\n\t\t\t/* handled by get_sb_block() instead of here */\n\t\t\t/* *sb_block = match_int(&args[0]); */\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tbreak;\n\t\tcase Opt_nouid32:\n\t\t\tset_opt (sbi->s_mount_opt, NO_UID32);\n\t\t\tbreak;\n\t\tcase Opt_nocheck:\n\t\t\tclear_opt (sbi->s_mount_opt, CHECK);\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\tset_opt (sbi->s_mount_opt, DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_oldalloc:\n\t\t\tset_opt (sbi->s_mount_opt, OLDALLOC);\n\t\t\tbreak;\n\t\tcase Opt_orlov:\n\t\t\tclear_opt (sbi->s_mount_opt, OLDALLOC);\n\t\t\tbreak;\n\t\tcase Opt_nobh:\n\t\t\tset_opt (sbi->s_mount_opt, NOBH);\n\t\t\tbreak;\n#ifdef CONFIG_EXT2_FS_XATTR\n\t\tcase Opt_user_xattr:\n\t\t\tset_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tclear_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n#else\n\t\tcase Opt_user_xattr:\n\t\tcase Opt_nouser_xattr:\n\t\t\text2_msg(sb, KERN_INFO, \"(no)user_xattr options\"\n\t\t\t\t\"not supported\");\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\t\tcase Opt_acl:\n\t\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tclear_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n#else\n\t\tcase Opt_acl:\n\t\tcase Opt_noacl:\n\t\t\text2_msg(sb, KERN_INFO,\n\t\t\t\t\"(no)acl options not supported\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_xip:\n\t\t\text2_msg(sb, KERN_INFO, \"use dax instead of xip\");\n\t\t\tset_opt(sbi->s_mount_opt, XIP);\n\t\t\t/* Fall through */\n\t\tcase Opt_dax:\n#ifdef CONFIG_FS_DAX\n\t\t\text2_msg(sb, KERN_WARNING,\n\t\t\"DAX enabled. Warning: EXPERIMENTAL, use at your own risk\");\n\t\t\tset_opt(sbi->s_mount_opt, DAX);\n#else\n\t\t\text2_msg(sb, KERN_INFO, \"dax option not supported\");\n#endif\n\t\t\tbreak;\n\n#if defined(CONFIG_QUOTA)\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\t\tset_opt(sbi->s_mount_opt, USRQUOTA);\n\t\t\tbreak;\n\n\t\tcase Opt_grpquota:\n\t\t\tset_opt(sbi->s_mount_opt, GRPQUOTA);\n\t\t\tbreak;\n#else\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\tcase Opt_grpquota:\n\t\t\text2_msg(sb, KERN_INFO,\n\t\t\t\t\"quota operations not supported\");\n\t\t\tbreak;\n#endif\n\n\t\tcase Opt_reservation:\n\t\t\tset_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\text2_msg(sb, KERN_INFO, \"reservations ON\");\n\t\t\tbreak;\n\t\tcase Opt_noreservation:\n\t\t\tclear_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\text2_msg(sb, KERN_INFO, \"reservations OFF\");\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int ext2_setup_super (struct super_block * sb,\n\t\t\t      struct ext2_super_block * es,\n\t\t\t      int read_only)\n{\n\tint res = 0;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT2_MAX_SUPP_REV) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: revision level too high, \"\n\t\t\t\"forcing read-only mode\");\n\t\tres = MS_RDONLY;\n\t}\n\tif (read_only)\n\t\treturn res;\n\tif (!(sbi->s_mount_state & EXT2_VALID_FS))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting unchecked fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((sbi->s_mount_state & EXT2_ERROR_FS))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting fs with errors, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) >= 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t (unsigned short) (__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: maximal mount count reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t(le32_to_cpu(es->s_lastcheck) +\n\t\t\tle32_to_cpu(es->s_checkinterval) <= get_seconds()))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: checktime reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\tif (!le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT2_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\tif (test_opt (sb, DEBUG))\n\t\text2_msg(sb, KERN_INFO, \"%s, %s, bs=%lu, fs=%lu, gc=%lu, \"\n\t\t\t\"bpg=%lu, ipg=%lu, mo=%04lx]\",\n\t\t\tEXT2FS_VERSION, EXT2FS_DATE, sb->s_blocksize,\n\t\t\tsbi->s_frag_size,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT2_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT2_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt);\n\treturn res;\n}\n\nstatic int ext2_check_descriptors(struct super_block *sb)\n{\n\tint i;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\text2_debug (\"Checking group descriptors\");\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tstruct ext2_group_desc *gdp = ext2_get_group_desc(sb, i, NULL);\n\t\text2_fsblk_t first_block = ext2_group_first_block_no(sb, i);\n\t\text2_fsblk_t last_block;\n\n\t\tif (i == sbi->s_groups_count - 1)\n\t\t\tlast_block = le32_to_cpu(sbi->s_es->s_blocks_count) - 1;\n\t\telse\n\t\t\tlast_block = first_block +\n\t\t\t\t(EXT2_BLOCKS_PER_GROUP(sb) - 1);\n\n\t\tif (le32_to_cpu(gdp->bg_block_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_block_bitmap) > last_block)\n\t\t{\n\t\t\text2_error (sb, \"ext2_check_descriptors\",\n\t\t\t\t    \"Block bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long) le32_to_cpu(gdp->bg_block_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_bitmap) > last_block)\n\t\t{\n\t\t\text2_error (sb, \"ext2_check_descriptors\",\n\t\t\t\t    \"Inode bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long) le32_to_cpu(gdp->bg_inode_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_table) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_table) + sbi->s_itb_per_group - 1 >\n\t\t    last_block)\n\t\t{\n\t\t\text2_error (sb, \"ext2_check_descriptors\",\n\t\t\t\t    \"Inode table for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long) le32_to_cpu(gdp->bg_inode_table));\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\n/*\n * Maximal file size.  There is a direct, and {,double-,triple-}indirect\n * block limit, and also a limit of (2^32 - 1) 512-byte sectors in i_blocks.\n * We need to be 1 filesystem block less than the 2^32 sector limit.\n */\nstatic loff_t ext2_max_size(int bits)\n{\n\tloff_t res = EXT2_NDIR_BLOCKS;\n\tint meta_blocks;\n\tloff_t upper_limit;\n\n\t/* This is calculated to be the largest file size for a\n\t * dense, file such that the total number of\n\t * sectors in the file, including data and all indirect blocks,\n\t * does not exceed 2^32 -1\n\t * __u32 i_blocks representing the total number of\n\t * 512 bytes blocks of the file\n\t */\n\tupper_limit = (1LL << 32) - 1;\n\n\t/* total blocks in file system block size */\n\tupper_limit >>= (bits - 9);\n\n\n\t/* indirect blocks */\n\tmeta_blocks = 1;\n\t/* double indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2));\n\t/* tripple indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2)) + (1LL << (2*(bits-2)));\n\n\tupper_limit -= meta_blocks;\n\tupper_limit <<= bits;\n\n\tres += 1LL << (bits-2);\n\tres += 1LL << (2*(bits-2));\n\tres += 1LL << (3*(bits-2));\n\tres <<= bits;\n\tif (res > upper_limit)\n\t\tres = upper_limit;\n\n\tif (res > MAX_LFS_FILESIZE)\n\t\tres = MAX_LFS_FILESIZE;\n\n\treturn res;\n}\n\nstatic unsigned long descriptor_loc(struct super_block *sb,\n\t\t\t\t    unsigned long logic_sb_block,\n\t\t\t\t    int nr)\n{\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tunsigned long bg, first_meta_bg;\n\tint has_super = 0;\n\t\n\tfirst_meta_bg = le32_to_cpu(sbi->s_es->s_first_meta_bg);\n\n\tif (!EXT2_HAS_INCOMPAT_FEATURE(sb, EXT2_FEATURE_INCOMPAT_META_BG) ||\n\t    nr < first_meta_bg)\n\t\treturn (logic_sb_block + nr + 1);\n\tbg = sbi->s_desc_per_block * nr;\n\tif (ext2_bg_has_super(sb, bg))\n\t\thas_super = 1;\n\n\treturn ext2_group_first_block_no(sb, bg) + has_super;\n}\n\nstatic int ext2_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct buffer_head * bh;\n\tstruct ext2_sb_info * sbi;\n\tstruct ext2_super_block * es;\n\tstruct inode *root;\n\tunsigned long block;\n\tunsigned long sb_block = get_sb_block(&data);\n\tunsigned long logic_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long def_mount_opts;\n\tlong ret = -EINVAL;\n\tint blocksize = BLOCK_SIZE;\n\tint db_count;\n\tint i, j;\n\t__le32 features;\n\tint err;\n\n\terr = -ENOMEM;\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\tgoto failed;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock) {\n\t\tkfree(sbi);\n\t\tgoto failed;\n\t}\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb_block = sb_block;\n\n\tspin_lock_init(&sbi->s_lock);\n\n\t/*\n\t * See what the current blocksize for the device is, and\n\t * use that as the blocksize.  Otherwise (or if the blocksize\n\t * is smaller than the default) use the default.\n\t * This is important for devices that have a hardware\n\t * sectorsize that is larger than the default.\n\t */\n\tblocksize = sb_min_blocksize(sb, BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text2_msg(sb, KERN_ERR, \"error: unable to set blocksize\");\n\t\tgoto failed_sbi;\n\t}\n\n\t/*\n\t * If the superblock doesn't start on a hardware sector boundary,\n\t * calculate the offset.  \n\t */\n\tif (blocksize != BLOCK_SIZE) {\n\t\tlogic_sb_block = (sb_block*BLOCK_SIZE) / blocksize;\n\t\toffset = (sb_block*BLOCK_SIZE) % blocksize;\n\t} else {\n\t\tlogic_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread(sb, logic_sb_block))) {\n\t\text2_msg(sb, KERN_ERR, \"error: unable to read superblock\");\n\t\tgoto failed_sbi;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext2 macro-instructions depend on its value\n\t */\n\tes = (struct ext2_super_block *) (((char *)bh->b_data) + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\n\tif (sb->s_magic != EXT2_SUPER_MAGIC)\n\t\tgoto cantfind_ext2;\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tif (def_mount_opts & EXT2_DEFM_DEBUG)\n\t\tset_opt(sbi->s_mount_opt, DEBUG);\n\tif (def_mount_opts & EXT2_DEFM_BSDGROUPS)\n\t\tset_opt(sbi->s_mount_opt, GRPID);\n\tif (def_mount_opts & EXT2_DEFM_UID16)\n\t\tset_opt(sbi->s_mount_opt, NO_UID32);\n#ifdef CONFIG_EXT2_FS_XATTR\n\tif (def_mount_opts & EXT2_DEFM_XATTR_USER)\n\t\tset_opt(sbi->s_mount_opt, XATTR_USER);\n#endif\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\tif (def_mount_opts & EXT2_DEFM_ACL)\n\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n#endif\n\t\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT2_ERRORS_PANIC)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT2_ERRORS_CONTINUE)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_CONT);\n\telse\n\t\tset_opt(sbi->s_mount_opt, ERRORS_RO);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\t\n\tset_opt(sbi->s_mount_opt, RESERVATION);\n\n\tif (!parse_options((char *) data, sb))\n\t\tgoto failed_mount;\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t((EXT2_SB(sb)->s_mount_opt & EXT2_MOUNT_POSIX_ACL) ?\n\t\t MS_POSIXACL : 0);\n\tsb->s_iflags |= SB_I_CGROUPWB;\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT2_GOOD_OLD_REV &&\n\t    (EXT2_HAS_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT2_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT2_HAS_INCOMPAT_FEATURE(sb, ~0U)))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: feature flags set on rev 0 fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tfeatures = EXT2_HAS_INCOMPAT_FEATURE(sb, ~EXT2_FEATURE_INCOMPAT_SUPP);\n\tif (features) {\n\t\text2_msg(sb, KERN_ERR,\t\"error: couldn't mount because of \"\n\t\t       \"unsupported optional features (%x)\",\n\t\t\tle32_to_cpu(features));\n\t\tgoto failed_mount;\n\t}\n\tif (!(sb->s_flags & MS_RDONLY) &&\n\t    (features = EXT2_HAS_RO_COMPAT_FEATURE(sb, ~EXT2_FEATURE_RO_COMPAT_SUPP))){\n\t\text2_msg(sb, KERN_ERR, \"error: couldn't mount RDWR because of \"\n\t\t       \"unsupported optional features (%x)\",\n\t\t       le32_to_cpu(features));\n\t\tgoto failed_mount;\n\t}\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(sbi->s_es->s_log_block_size);\n\n\tif (sbi->s_mount_opt & EXT2_MOUNT_DAX) {\n\t\tif (blocksize != PAGE_SIZE) {\n\t\t\text2_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: unsupported blocksize for dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (!sb->s_bdev->bd_disk->fops->direct_access) {\n\t\t\text2_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: device does not support dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* If the blocksize doesn't match, re-read the thing.. */\n\tif (sb->s_blocksize != blocksize) {\n\t\tbrelse(bh);\n\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text2_msg(sb, KERN_ERR,\n\t\t\t\t\"error: bad blocksize %d\", blocksize);\n\t\t\tgoto failed_sbi;\n\t\t}\n\n\t\tlogic_sb_block = (sb_block*BLOCK_SIZE) / blocksize;\n\t\toffset = (sb_block*BLOCK_SIZE) % blocksize;\n\t\tbh = sb_bread(sb, logic_sb_block);\n\t\tif(!bh) {\n\t\t\text2_msg(sb, KERN_ERR, \"error: couldn't read\"\n\t\t\t\t\"superblock on 2nd try\");\n\t\t\tgoto failed_sbi;\n\t\t}\n\t\tes = (struct ext2_super_block *) (((char *)bh->b_data) + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT2_SUPER_MAGIC)) {\n\t\t\text2_msg(sb, KERN_ERR, \"error: magic mismatch\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tsb->s_maxbytes = ext2_max_size(sb->s_blocksize_bits);\n\tsb->s_max_links = EXT2_LINK_MAX;\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT2_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT2_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT2_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT2_GOOD_OLD_INODE_SIZE) ||\n\t\t    !is_power_of_2(sbi->s_inode_size) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text2_msg(sb, KERN_ERR,\n\t\t\t\t\"error: unsupported inode size: %d\",\n\t\t\t\tsbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tsbi->s_frag_size = EXT2_MIN_FRAG_SIZE <<\n\t\t\t\t   le32_to_cpu(es->s_log_frag_size);\n\tif (sbi->s_frag_size == 0)\n\t\tgoto cantfind_ext2;\n\tsbi->s_frags_per_block = sb->s_blocksize / sbi->s_frag_size;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_frags_per_group = le32_to_cpu(es->s_frags_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tif (EXT2_INODE_SIZE(sb) == 0)\n\t\tgoto cantfind_ext2;\n\tsbi->s_inodes_per_block = sb->s_blocksize / EXT2_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0 || sbi->s_inodes_per_group == 0)\n\t\tgoto cantfind_ext2;\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = sb->s_blocksize /\n\t\t\t\t\tsizeof (struct ext2_group_desc);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits =\n\t\tilog2 (EXT2_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits =\n\t\tilog2 (EXT2_DESC_PER_BLOCK(sb));\n\n\tif (sb->s_magic != EXT2_SUPER_MAGIC)\n\t\tgoto cantfind_ext2;\n\n\tif (sb->s_blocksize != bh->b_size) {\n\t\tif (!silent)\n\t\t\text2_msg(sb, KERN_ERR, \"error: unsupported blocksize\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != sbi->s_frag_size) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: fragsize %lu != blocksize %lu\"\n\t\t\t\"(not supported yet)\",\n\t\t\tsbi->s_frag_size, sb->s_blocksize);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_blocks_per_group > sb->s_blocksize * 8) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: #blocks per group too big: %lu\",\n\t\t\tsbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_frags_per_group > sb->s_blocksize * 8) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: #fragments per group too big: %lu\",\n\t\t\tsbi->s_frags_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_inodes_per_group > sb->s_blocksize * 8) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: #inodes per group too big: %lu\",\n\t\t\tsbi->s_inodes_per_group);\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT2_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext2;\n \tsbi->s_groups_count = ((le32_to_cpu(es->s_blocks_count) -\n \t\t\t\tle32_to_cpu(es->s_first_data_block) - 1)\n \t\t\t\t\t/ EXT2_BLOCKS_PER_GROUP(sb)) + 1;\n\tdb_count = (sbi->s_groups_count + EXT2_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT2_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = kmalloc (db_count * sizeof (struct buffer_head *), GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text2_msg(sb, KERN_ERR, \"error: not enough memory\");\n\t\tgoto failed_mount;\n\t}\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\tsbi->s_debts = kcalloc(sbi->s_groups_count, sizeof(*sbi->s_debts), GFP_KERNEL);\n\tif (!sbi->s_debts) {\n\t\text2_msg(sb, KERN_ERR, \"error: not enough memory\");\n\t\tgoto failed_mount_group_desc;\n\t}\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logic_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tbrelse (sbi->s_group_desc[j]);\n\t\t\text2_msg(sb, KERN_ERR,\n\t\t\t\t\"error: unable to read group descriptors\");\n\t\t\tgoto failed_mount_group_desc;\n\t\t}\n\t}\n\tif (!ext2_check_descriptors (sb)) {\n\t\text2_msg(sb, KERN_ERR, \"group descriptors corrupted\");\n\t\tgoto failed_mount2;\n\t}\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\t/* per fileystem reservation list head & lock */\n\tspin_lock_init(&sbi->s_rsv_window_lock);\n\tsbi->s_rsv_window_root = RB_ROOT;\n\t/*\n\t * Add a single, static dummy reservation to the start of the\n\t * reservation window list --- it gives us a placeholder for\n\t * append-at-start-of-list which makes the allocation logic\n\t * _much_ simpler.\n\t */\n\tsbi->s_rsv_window_head.rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\tsbi->s_rsv_window_head.rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\tsbi->s_rsv_window_head.rsv_alloc_hit = 0;\n\tsbi->s_rsv_window_head.rsv_goal_size = 0;\n\text2_rsv_window_add(sb, &sbi->s_rsv_window_head);\n\n\terr = percpu_counter_init(&sbi->s_freeblocks_counter,\n\t\t\t\text2_count_free_blocks(sb), GFP_KERNEL);\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter,\n\t\t\t\text2_count_free_inodes(sb), GFP_KERNEL);\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\text2_count_dirs(sb), GFP_KERNEL);\n\t}\n\tif (err) {\n\t\text2_msg(sb, KERN_ERR, \"error: insufficient memory\");\n\t\tgoto failed_mount3;\n\t}\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext2_sops;\n\tsb->s_export_op = &ext2_export_ops;\n\tsb->s_xattr = ext2_xattr_handlers;\n\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &dquot_operations;\n\tsb->s_qcop = &dquot_quotactl_ops;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n#endif\n\n\troot = ext2_iget(sb, EXT2_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\tret = PTR_ERR(root);\n\t\tgoto failed_mount3;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\tiput(root);\n\t\text2_msg(sb, KERN_ERR, \"error: corrupt root inode, run e2fsck\");\n\t\tgoto failed_mount3;\n\t}\n\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text2_msg(sb, KERN_ERR, \"error: get root inode failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount3;\n\t}\n\tif (EXT2_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_HAS_JOURNAL))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting ext3 filesystem as ext2\");\n\tif (ext2_setup_super (sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\text2_write_super(sb);\n\treturn 0;\n\ncantfind_ext2:\n\tif (!silent)\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: can't find an ext2 filesystem on dev %s.\",\n\t\t\tsb->s_id);\n\tgoto failed_mount;\nfailed_mount3:\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\nfailed_mount_group_desc:\n\tkfree(sbi->s_group_desc);\n\tkfree(sbi->s_debts);\nfailed_mount:\n\tbrelse(bh);\nfailed_sbi:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\nfailed:\n\treturn ret;\n}\n\nstatic void ext2_clear_super_error(struct super_block *sb)\n{\n\tstruct buffer_head *sbh = EXT2_SB(sb)->s_sbh;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text2_msg(sb, KERN_ERR,\n\t\t       \"previous I/O error to superblock detected\\n\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n}\n\nstatic void ext2_sync_super(struct super_block *sb, struct ext2_super_block *es,\n\t\t\t    int wait)\n{\n\text2_clear_super_error(sb);\n\tspin_lock(&EXT2_SB(sb)->s_lock);\n\tes->s_free_blocks_count = cpu_to_le32(ext2_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext2_count_free_inodes(sb));\n\tes->s_wtime = cpu_to_le32(get_seconds());\n\t/* unlock before we do IO */\n\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\tmark_buffer_dirty(EXT2_SB(sb)->s_sbh);\n\tif (wait)\n\t\tsync_dirty_buffer(EXT2_SB(sb)->s_sbh);\n}\n\n/*\n * In the second extended file system, it is not necessary to\n * write the super block since we use a mapping of the\n * disk super block in a buffer.\n *\n * However, this function is still used to set the fs valid\n * flags to 0.  We need to set this flag to 0 since the fs\n * may have been checked while mounted and e2fsck may have\n * set s_state to EXT2_VALID_FS after some corrections.\n */\nstatic int ext2_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = EXT2_SB(sb)->s_es;\n\n\t/*\n\t * Write quota structures to quota file, sync_blockdev() will write\n\t * them to disk later\n\t */\n\tdquot_writeback_dquots(sb, -1);\n\n\tspin_lock(&sbi->s_lock);\n\tif (es->s_state & cpu_to_le16(EXT2_VALID_FS)) {\n\t\text2_debug(\"setting valid to 0\\n\");\n\t\tes->s_state &= cpu_to_le16(~EXT2_VALID_FS);\n\t}\n\tspin_unlock(&sbi->s_lock);\n\text2_sync_super(sb, es, wait);\n\treturn 0;\n}\n\nstatic int ext2_freeze(struct super_block *sb)\n{\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\t/*\n\t * Open but unlinked files present? Keep EXT2_VALID_FS flag cleared\n\t * because we have unattached inodes and thus filesystem is not fully\n\t * consistent.\n\t */\n\tif (atomic_long_read(&sb->s_remove_count)) {\n\t\text2_sync_fs(sb, 1);\n\t\treturn 0;\n\t}\n\t/* Set EXT2_FS_VALID flag */\n\tspin_lock(&sbi->s_lock);\n\tsbi->s_es->s_state = cpu_to_le16(sbi->s_mount_state);\n\tspin_unlock(&sbi->s_lock);\n\text2_sync_super(sb, sbi->s_es, 1);\n\n\treturn 0;\n}\n\nstatic int ext2_unfreeze(struct super_block *sb)\n{\n\t/* Just write sb to clear EXT2_VALID_FS flag */\n\text2_write_super(sb);\n\n\treturn 0;\n}\n\nvoid ext2_write_super(struct super_block *sb)\n{\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\text2_sync_fs(sb, 1);\n}\n\nstatic int ext2_remount (struct super_block * sb, int * flags, char * data)\n{\n\tstruct ext2_sb_info * sbi = EXT2_SB(sb);\n\tstruct ext2_super_block * es;\n\tstruct ext2_mount_options old_opts;\n\tunsigned long old_sb_flags;\n\tint err;\n\n\tsync_filesystem(sb);\n\tspin_lock(&sbi->s_lock);\n\n\t/* Store the old options */\n\told_sb_flags = sb->s_flags;\n\told_opts.s_mount_opt = sbi->s_mount_opt;\n\told_opts.s_resuid = sbi->s_resuid;\n\told_opts.s_resgid = sbi->s_resgid;\n\n\t/*\n\t * Allow the \"check\" option to be passed as a remount option.\n\t */\n\tif (!parse_options(data, sb)) {\n\t\terr = -EINVAL;\n\t\tgoto restore_opts;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t((sbi->s_mount_opt & EXT2_MOUNT_POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tes = sbi->s_es;\n\tif ((sbi->s_mount_opt ^ old_opts.s_mount_opt) & EXT2_MOUNT_DAX) {\n\t\text2_msg(sb, KERN_WARNING, \"warning: refusing change of \"\n\t\t\t \"dax flag with busy inodes while remounting\");\n\t\tsbi->s_mount_opt ^= EXT2_MOUNT_DAX;\n\t}\n\tif ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY)) {\n\t\tspin_unlock(&sbi->s_lock);\n\t\treturn 0;\n\t}\n\tif (*flags & MS_RDONLY) {\n\t\tif (le16_to_cpu(es->s_state) & EXT2_VALID_FS ||\n\t\t    !(sbi->s_mount_state & EXT2_VALID_FS)) {\n\t\t\tspin_unlock(&sbi->s_lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * OK, we are remounting a valid rw partition rdonly, so set\n\t\t * the rdonly flag and then mark the partition as valid again.\n\t\t */\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tes->s_mtime = cpu_to_le32(get_seconds());\n\t\tspin_unlock(&sbi->s_lock);\n\n\t\terr = dquot_suspend(sb, -1);\n\t\tif (err < 0) {\n\t\t\tspin_lock(&sbi->s_lock);\n\t\t\tgoto restore_opts;\n\t\t}\n\n\t\text2_sync_super(sb, es, 1);\n\t} else {\n\t\t__le32 ret = EXT2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t       ~EXT2_FEATURE_RO_COMPAT_SUPP);\n\t\tif (ret) {\n\t\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\t\"warning: couldn't remount RDWR because of \"\n\t\t\t\t\"unsupported optional features (%x).\",\n\t\t\t\tle32_to_cpu(ret));\n\t\t\terr = -EROFS;\n\t\t\tgoto restore_opts;\n\t\t}\n\t\t/*\n\t\t * Mounting a RDONLY partition read-write, so reread and\n\t\t * store the current valid flag.  (It may have been changed\n\t\t * by e2fsck since we originally mounted the partition.)\n\t\t */\n\t\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\t\tif (!ext2_setup_super (sb, es, 0))\n\t\t\tsb->s_flags &= ~MS_RDONLY;\n\t\tspin_unlock(&sbi->s_lock);\n\n\t\text2_write_super(sb);\n\n\t\tdquot_resume(sb, -1);\n\t}\n\n\treturn 0;\nrestore_opts:\n\tsbi->s_mount_opt = old_opts.s_mount_opt;\n\tsbi->s_resuid = old_opts.s_resuid;\n\tsbi->s_resgid = old_opts.s_resgid;\n\tsb->s_flags = old_sb_flags;\n\tspin_unlock(&sbi->s_lock);\n\treturn err;\n}\n\nstatic int ext2_statfs (struct dentry * dentry, struct kstatfs * buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\tu64 fsid;\n\n\tspin_lock(&sbi->s_lock);\n\n\tif (test_opt (sb, MINIX_DF))\n\t\tsbi->s_overhead_last = 0;\n\telse if (sbi->s_blocks_last != le32_to_cpu(es->s_blocks_count)) {\n\t\tunsigned long i, overhead = 0;\n\t\tsmp_rmb();\n\n\t\t/*\n\t\t * Compute the overhead (FS structures). This is constant\n\t\t * for a given filesystem unless the number of block groups\n\t\t * changes so we cache the previous value until it does.\n\t\t */\n\n\t\t/*\n\t\t * All of the blocks before first_data_block are\n\t\t * overhead\n\t\t */\n\t\toverhead = le32_to_cpu(es->s_first_data_block);\n\n\t\t/*\n\t\t * Add the overhead attributed to the superblock and\n\t\t * block group descriptors.  If the sparse superblocks\n\t\t * feature is turned on, then not all groups have this.\n\t\t */\n\t\tfor (i = 0; i < sbi->s_groups_count; i++)\n\t\t\toverhead += ext2_bg_has_super(sb, i) +\n\t\t\t\text2_bg_num_gdb(sb, i);\n\n\t\t/*\n\t\t * Every block group has an inode bitmap, a block\n\t\t * bitmap, and an inode table.\n\t\t */\n\t\toverhead += (sbi->s_groups_count *\n\t\t\t     (2 + sbi->s_itb_per_group));\n\t\tsbi->s_overhead_last = overhead;\n\t\tsmp_wmb();\n\t\tsbi->s_blocks_last = le32_to_cpu(es->s_blocks_count);\n\t}\n\n\tbuf->f_type = EXT2_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = le32_to_cpu(es->s_blocks_count) - sbi->s_overhead_last;\n\tbuf->f_bfree = ext2_count_free_blocks(sb);\n\tes->s_free_blocks_count = cpu_to_le32(buf->f_bfree);\n\tbuf->f_bavail = buf->f_bfree - le32_to_cpu(es->s_r_blocks_count);\n\tif (buf->f_bfree < le32_to_cpu(es->s_r_blocks_count))\n\t\tbuf->f_bavail = 0;\n\tbuf->f_files = le32_to_cpu(es->s_inodes_count);\n\tbuf->f_ffree = ext2_count_free_inodes(sb);\n\tes->s_free_inodes_count = cpu_to_le32(buf->f_ffree);\n\tbuf->f_namelen = EXT2_NAME_LEN;\n\tfsid = le64_to_cpup((void *)es->s_uuid) ^\n\t       le64_to_cpup((void *)es->s_uuid + sizeof(u64));\n\tbuf->f_fsid.val[0] = fsid & 0xFFFFFFFFUL;\n\tbuf->f_fsid.val[1] = (fsid >> 32) & 0xFFFFFFFFUL;\n\tspin_unlock(&sbi->s_lock);\n\treturn 0;\n}\n\nstatic struct dentry *ext2_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, ext2_fill_super);\n}\n\n#ifdef CONFIG_QUOTA\n\n/* Read data from quotafile - avoid pagecache and such because we cannot afford\n * acquiring the locks... As quota files are never truncated and quota code\n * itself serializes the operations (and no one else should touch the files)\n * we don't have to be afraid of races */\nstatic ssize_t ext2_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t       size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> EXT2_BLOCK_SIZE_BITS(sb);\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint tocopy;\n\tsize_t toread;\n\tstruct buffer_head tmp_bh;\n\tstruct buffer_head *bh;\n\tloff_t i_size = i_size_read(inode);\n\n\tif (off > i_size)\n\t\treturn 0;\n\tif (off+len > i_size)\n\t\tlen = i_size-off;\n\ttoread = len;\n\twhile (toread > 0) {\n\t\ttocopy = sb->s_blocksize - offset < toread ?\n\t\t\t\tsb->s_blocksize - offset : toread;\n\n\t\ttmp_bh.b_state = 0;\n\t\ttmp_bh.b_size = sb->s_blocksize;\n\t\terr = ext2_get_block(inode, blk, &tmp_bh, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (!buffer_mapped(&tmp_bh))\t/* A hole? */\n\t\t\tmemset(data, 0, tocopy);\n\t\telse {\n\t\t\tbh = sb_bread(sb, tmp_bh.b_blocknr);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tmemcpy(data, bh->b_data+offset, tocopy);\n\t\t\tbrelse(bh);\n\t\t}\n\t\toffset = 0;\n\t\ttoread -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\n\treturn len;\n}\n\n/* Write to quotafile */\nstatic ssize_t ext2_quota_write(struct super_block *sb, int type,\n\t\t\t\tconst char *data, size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> EXT2_BLOCK_SIZE_BITS(sb);\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint tocopy;\n\tsize_t towrite = len;\n\tstruct buffer_head tmp_bh;\n\tstruct buffer_head *bh;\n\n\twhile (towrite > 0) {\n\t\ttocopy = sb->s_blocksize - offset < towrite ?\n\t\t\t\tsb->s_blocksize - offset : towrite;\n\n\t\ttmp_bh.b_state = 0;\n\t\ttmp_bh.b_size = sb->s_blocksize;\n\t\terr = ext2_get_block(inode, blk, &tmp_bh, 1);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tif (offset || tocopy != EXT2_BLOCK_SIZE(sb))\n\t\t\tbh = sb_bread(sb, tmp_bh.b_blocknr);\n\t\telse\n\t\t\tbh = sb_getblk(sb, tmp_bh.b_blocknr);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tmemcpy(bh->b_data+offset, data, tocopy);\n\t\tflush_dcache_page(bh->b_page);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tbrelse(bh);\n\t\toffset = 0;\n\t\ttowrite -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\nout:\n\tif (len == towrite)\n\t\treturn err;\n\tif (inode->i_size < off+len-towrite)\n\t\ti_size_write(inode, off+len-towrite);\n\tinode->i_version++;\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(inode);\n\treturn len - towrite;\n}\n\n#endif\n\nstatic struct file_system_type ext2_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ext2\",\n\t.mount\t\t= ext2_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"ext2\");\n\nstatic int __init init_ext2_fs(void)\n{\n\tint err = init_ext2_xattr();\n\tif (err)\n\t\treturn err;\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n        err = register_filesystem(&ext2_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\texit_ext2_xattr();\n\treturn err;\n}\n\nstatic void __exit exit_ext2_fs(void)\n{\n\tunregister_filesystem(&ext2_fs_type);\n\tdestroy_inodecache();\n\texit_ext2_xattr();\n}\n\nMODULE_AUTHOR(\"Remy Card and others\");\nMODULE_DESCRIPTION(\"Second Extended Filesystem\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(init_ext2_fs)\nmodule_exit(exit_ext2_fs)\n", "/*\n * linux/fs/ext2/xattr.c\n *\n * Copyright (C) 2001-2003 Andreas Gruenbacher <agruen@suse.de>\n *\n * Fix by Harrison Xing <harrison@mountainviewdata.com>.\n * Extended attributes for symlinks and special files added per\n *  suggestion of Luka Renko <luka.renko@hermes.si>.\n * xattr consolidation Copyright (c) 2004 James Morris <jmorris@redhat.com>,\n *  Red Hat Inc.\n *\n */\n\n/*\n * Extended attributes are stored on disk blocks allocated outside of\n * any inode. The i_file_acl field is then made to point to this allocated\n * block. If all extended attributes of an inode are identical, these\n * inodes may share the same extended attribute block. Such situations\n * are automatically detected by keeping a cache of recent attribute block\n * numbers and hashes over the block's contents in memory.\n *\n *\n * Extended attribute block layout:\n *\n *   +------------------+\n *   | header           |\n *   | entry 1          | |\n *   | entry 2          | | growing downwards\n *   | entry 3          | v\n *   | four null bytes  |\n *   | . . .            |\n *   | value 1          | ^\n *   | value 3          | | growing upwards\n *   | value 2          | |\n *   +------------------+\n *\n * The block header is followed by multiple entry descriptors. These entry\n * descriptors are variable in size, and aligned to EXT2_XATTR_PAD\n * byte boundaries. The entry descriptors are sorted by attribute name,\n * so that two extended attribute blocks can be compared efficiently.\n *\n * Attribute values are aligned to the end of the block, stored in\n * no specific order. They are also padded to EXT2_XATTR_PAD byte\n * boundaries. No additional gaps are left between them.\n *\n * Locking strategy\n * ----------------\n * EXT2_I(inode)->i_file_acl is protected by EXT2_I(inode)->xattr_sem.\n * EA blocks are only changed if they are exclusive to an inode, so\n * holding xattr_sem also means that nothing but the EA block's reference\n * count will change. Multiple writers to an EA block are synchronized\n * by the bh lock. No more than a single bh lock is held at any time\n * to avoid deadlocks.\n */\n\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mbcache.h>\n#include <linux/quotaops.h>\n#include <linux/rwsem.h>\n#include <linux/security.h>\n#include \"ext2.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n\n#define HDR(bh) ((struct ext2_xattr_header *)((bh)->b_data))\n#define ENTRY(ptr) ((struct ext2_xattr_entry *)(ptr))\n#define FIRST_ENTRY(bh) ENTRY(HDR(bh)+1)\n#define IS_LAST_ENTRY(entry) (*(__u32 *)(entry) == 0)\n\n#ifdef EXT2_XATTR_DEBUG\n# define ea_idebug(inode, f...) do { \\\n\t\tprintk(KERN_DEBUG \"inode %s:%ld: \", \\\n\t\t\tinode->i_sb->s_id, inode->i_ino); \\\n\t\tprintk(f); \\\n\t\tprintk(\"\\n\"); \\\n\t} while (0)\n# define ea_bdebug(bh, f...) do { \\\n\t\tprintk(KERN_DEBUG \"block %pg:%lu: \", \\\n\t\t\tbh->b_bdev, (unsigned long) bh->b_blocknr); \\\n\t\tprintk(f); \\\n\t\tprintk(\"\\n\"); \\\n\t} while (0)\n#else\n# define ea_idebug(f...)\n# define ea_bdebug(f...)\n#endif\n\nstatic int ext2_xattr_set2(struct inode *, struct buffer_head *,\n\t\t\t   struct ext2_xattr_header *);\n\nstatic int ext2_xattr_cache_insert(struct buffer_head *);\nstatic struct buffer_head *ext2_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext2_xattr_header *);\nstatic void ext2_xattr_rehash(struct ext2_xattr_header *,\n\t\t\t      struct ext2_xattr_entry *);\n\nstatic struct mb_cache *ext2_xattr_cache;\n\nstatic const struct xattr_handler *ext2_xattr_handler_map[] = {\n\t[EXT2_XATTR_INDEX_USER]\t\t     = &ext2_xattr_user_handler,\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\t[EXT2_XATTR_INDEX_POSIX_ACL_ACCESS]  = &posix_acl_access_xattr_handler,\n\t[EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT] = &posix_acl_default_xattr_handler,\n#endif\n\t[EXT2_XATTR_INDEX_TRUSTED]\t     = &ext2_xattr_trusted_handler,\n#ifdef CONFIG_EXT2_FS_SECURITY\n\t[EXT2_XATTR_INDEX_SECURITY]\t     = &ext2_xattr_security_handler,\n#endif\n};\n\nconst struct xattr_handler *ext2_xattr_handlers[] = {\n\t&ext2_xattr_user_handler,\n\t&ext2_xattr_trusted_handler,\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\t&posix_acl_access_xattr_handler,\n\t&posix_acl_default_xattr_handler,\n#endif\n#ifdef CONFIG_EXT2_FS_SECURITY\n\t&ext2_xattr_security_handler,\n#endif\n\tNULL\n};\n\nstatic inline const struct xattr_handler *\next2_xattr_handler(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < ARRAY_SIZE(ext2_xattr_handler_map))\n\t\thandler = ext2_xattr_handler_map[name_index];\n\treturn handler;\n}\n\n/*\n * ext2_xattr_get()\n *\n * Copy an extended attribute into the buffer\n * provided, or compute the buffer size required.\n * Buffer is NULL to compute the size of the buffer required.\n *\n * Returns a negative error number on failure, or the number of bytes\n * used / required on success.\n */\nint\next2_xattr_get(struct inode *inode, int name_index, const char *name,\n\t       void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext2_xattr_entry *entry;\n\tsize_t name_len, size;\n\tchar *end;\n\tint error;\n\n\tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n\t\t  name_index, name, buffer, (long)buffer_size);\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tif (name_len > 255)\n\t\treturn -ERANGE;\n\n\tdown_read(&EXT2_I(inode)->xattr_sem);\n\terror = -ENODATA;\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %d\", EXT2_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));\n\tend = bh->b_data + bh->b_size;\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\nbad_block:\text2_error(inode->i_sb, \"ext2_xattr_get\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\n\t/* find named attribute */\n\tentry = FIRST_ENTRY(bh);\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tstruct ext2_xattr_entry *next =\n\t\t\tEXT2_XATTR_NEXT(entry);\n\t\tif ((char *)next >= end)\n\t\t\tgoto bad_block;\n\t\tif (name_index == entry->e_name_index &&\n\t\t    name_len == entry->e_name_len &&\n\t\t    memcmp(name, entry->e_name, name_len) == 0)\n\t\t\tgoto found;\n\t\tentry = next;\n\t}\n\tif (ext2_xattr_cache_insert(bh))\n\t\tea_idebug(inode, \"cache insert failed\");\n\terror = -ENODATA;\n\tgoto cleanup;\nfound:\n\t/* check the buffer size */\n\tif (entry->e_value_block != 0)\n\t\tgoto bad_block;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (size > inode->i_sb->s_blocksize ||\n\t    le16_to_cpu(entry->e_value_offs) + size > inode->i_sb->s_blocksize)\n\t\tgoto bad_block;\n\n\tif (ext2_xattr_cache_insert(bh))\n\t\tea_idebug(inode, \"cache insert failed\");\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\t/* return value of attribute */\n\t\tmemcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),\n\t\t\tsize);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(bh);\n\tup_read(&EXT2_I(inode)->xattr_sem);\n\n\treturn error;\n}\n\n/*\n * ext2_xattr_list()\n *\n * Copy a list of attribute names into the buffer\n * provided, or compute the buffer size required.\n * Buffer is NULL to compute the size of the buffer required.\n *\n * Returns a negative error number on failure, or the number of bytes\n * used / required on success.\n */\nstatic int\next2_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct buffer_head *bh = NULL;\n\tstruct ext2_xattr_entry *entry;\n\tchar *end;\n\tsize_t rest = buffer_size;\n\tint error;\n\n\tea_idebug(inode, \"buffer=%p, buffer_size=%ld\",\n\t\t  buffer, (long)buffer_size);\n\n\tdown_read(&EXT2_I(inode)->xattr_sem);\n\terror = 0;\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %d\", EXT2_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));\n\tend = bh->b_data + bh->b_size;\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\nbad_block:\text2_error(inode->i_sb, \"ext2_xattr_list\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\n\t/* check the on-disk data structure */\n\tentry = FIRST_ENTRY(bh);\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tstruct ext2_xattr_entry *next = EXT2_XATTR_NEXT(entry);\n\n\t\tif ((char *)next >= end)\n\t\t\tgoto bad_block;\n\t\tentry = next;\n\t}\n\tif (ext2_xattr_cache_insert(bh))\n\t\tea_idebug(inode, \"cache insert failed\");\n\n\t/* list the attribute names */\n\tfor (entry = FIRST_ENTRY(bh); !IS_LAST_ENTRY(entry);\n\t     entry = EXT2_XATTR_NEXT(entry)) {\n\t\tconst struct xattr_handler *handler =\n\t\t\text2_xattr_handler(entry->e_name_index);\n\n\t\tif (handler && (!handler->list || handler->list(dentry))) {\n\t\t\tconst char *prefix = handler->prefix ?: handler->name;\n\t\t\tsize_t prefix_len = strlen(prefix);\n\t\t\tsize_t size = prefix_len + entry->e_name_len + 1;\n\n\t\t\tif (buffer) {\n\t\t\t\tif (size > rest) {\n\t\t\t\t\terror = -ERANGE;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tmemcpy(buffer, prefix, prefix_len);\n\t\t\t\tbuffer += prefix_len;\n\t\t\t\tmemcpy(buffer, entry->e_name, entry->e_name_len);\n\t\t\t\tbuffer += entry->e_name_len;\n\t\t\t\t*buffer++ = 0;\n\t\t\t}\n\t\t\trest -= size;\n\t\t}\n\t}\n\terror = buffer_size - rest;  /* total size */\n\ncleanup:\n\tbrelse(bh);\n\tup_read(&EXT2_I(inode)->xattr_sem);\n\n\treturn error;\n}\n\n/*\n * Inode operation listxattr()\n *\n * d_inode(dentry)->i_mutex: don't care\n */\nssize_t\next2_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\treturn ext2_xattr_list(dentry, buffer, size);\n}\n\n/*\n * If the EXT2_FEATURE_COMPAT_EXT_ATTR feature of this file system is\n * not set, set it.\n */\nstatic void ext2_xattr_update_super_block(struct super_block *sb)\n{\n\tif (EXT2_HAS_COMPAT_FEATURE(sb, EXT2_FEATURE_COMPAT_EXT_ATTR))\n\t\treturn;\n\n\tspin_lock(&EXT2_SB(sb)->s_lock);\n\tEXT2_SET_COMPAT_FEATURE(sb, EXT2_FEATURE_COMPAT_EXT_ATTR);\n\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\tmark_buffer_dirty(EXT2_SB(sb)->s_sbh);\n}\n\n/*\n * ext2_xattr_set()\n *\n * Create, replace or remove an extended attribute for this inode.  Value\n * is NULL to remove an existing extended attribute, and non-NULL to\n * either replace an existing extended attribute, or create a new extended\n * attribute. The flags XATTR_REPLACE and XATTR_CREATE\n * specify that an extended attribute must exist and must not exist\n * previous to the call, respectively.\n *\n * Returns 0, or a negative error number on failure.\n */\nint\next2_xattr_set(struct inode *inode, int name_index, const char *name,\n\t       const void *value, size_t value_len, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh = NULL;\n\tstruct ext2_xattr_header *header = NULL;\n\tstruct ext2_xattr_entry *here, *last;\n\tsize_t name_len, free, min_offs = sb->s_blocksize;\n\tint not_found = 1, error;\n\tchar *end;\n\t\n\t/*\n\t * header -- Points either into bh, or to a temporarily\n\t *           allocated buffer.\n\t * here -- The named entry found, or the place for inserting, within\n\t *         the block pointed to by header.\n\t * last -- Points right after the last named entry within the block\n\t *         pointed to by header.\n\t * min_offs -- The offset of the first value (values are aligned\n\t *             towards the end of the block).\n\t * end -- Points right after the block pointed to by header.\n\t */\n\t\n\tea_idebug(inode, \"name=%d.%s, value=%p, value_len=%ld\",\n\t\t  name_index, name, value, (long)value_len);\n\n\tif (value == NULL)\n\t\tvalue_len = 0;\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tif (name_len > 255 || value_len > sb->s_blocksize)\n\t\treturn -ERANGE;\n\tdown_write(&EXT2_I(inode)->xattr_sem);\n\tif (EXT2_I(inode)->i_file_acl) {\n\t\t/* The inode already has an extended attribute block. */\n\t\tbh = sb_bread(sb, EXT2_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tif (!bh)\n\t\t\tgoto cleanup;\n\t\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\t\tatomic_read(&(bh->b_count)),\n\t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n\t\theader = HDR(bh);\n\t\tend = bh->b_data + bh->b_size;\n\t\tif (header->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t\t    header->h_blocks != cpu_to_le32(1)) {\nbad_block:\t\text2_error(sb, \"ext2_xattr_set\",\n\t\t\t\t\"inode %ld: bad block %d\", inode->i_ino, \n\t\t\t\t   EXT2_I(inode)->i_file_acl);\n\t\t\terror = -EIO;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* Find the named attribute. */\n\t\there = FIRST_ENTRY(bh);\n\t\twhile (!IS_LAST_ENTRY(here)) {\n\t\t\tstruct ext2_xattr_entry *next = EXT2_XATTR_NEXT(here);\n\t\t\tif ((char *)next >= end)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!here->e_value_block && here->e_value_size) {\n\t\t\t\tsize_t offs = le16_to_cpu(here->e_value_offs);\n\t\t\t\tif (offs < min_offs)\n\t\t\t\t\tmin_offs = offs;\n\t\t\t}\n\t\t\tnot_found = name_index - here->e_name_index;\n\t\t\tif (!not_found)\n\t\t\t\tnot_found = name_len - here->e_name_len;\n\t\t\tif (!not_found)\n\t\t\t\tnot_found = memcmp(name, here->e_name,name_len);\n\t\t\tif (not_found <= 0)\n\t\t\t\tbreak;\n\t\t\there = next;\n\t\t}\n\t\tlast = here;\n\t\t/* We still need to compute min_offs and last. */\n\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\tstruct ext2_xattr_entry *next = EXT2_XATTR_NEXT(last);\n\t\t\tif ((char *)next >= end)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (offs < min_offs)\n\t\t\t\t\tmin_offs = offs;\n\t\t\t}\n\t\t\tlast = next;\n\t\t}\n\n\t\t/* Check whether we have enough space left. */\n\t\tfree = min_offs - ((char*)last - (char*)header) - sizeof(__u32);\n\t} else {\n\t\t/* We will use a new extended attribute block. */\n\t\tfree = sb->s_blocksize -\n\t\t\tsizeof(struct ext2_xattr_header) - sizeof(__u32);\n\t\there = last = NULL;  /* avoid gcc uninitialized warning. */\n\t}\n\n\tif (not_found) {\n\t\t/* Request to remove a nonexistent attribute? */\n\t\terror = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\terror = 0;\n\t\tif (value == NULL)\n\t\t\tgoto cleanup;\n\t} else {\n\t\t/* Request to create an existing attribute? */\n\t\terror = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t\tif (!here->e_value_block && here->e_value_size) {\n\t\t\tsize_t size = le32_to_cpu(here->e_value_size);\n\n\t\t\tif (le16_to_cpu(here->e_value_offs) + size > \n\t\t\t    sb->s_blocksize || size > sb->s_blocksize)\n\t\t\t\tgoto bad_block;\n\t\t\tfree += EXT2_XATTR_SIZE(size);\n\t\t}\n\t\tfree += EXT2_XATTR_LEN(name_len);\n\t}\n\terror = -ENOSPC;\n\tif (free < EXT2_XATTR_LEN(name_len) + EXT2_XATTR_SIZE(value_len))\n\t\tgoto cleanup;\n\n\t/* Here we know that we can set the new attribute. */\n\n\tif (header) {\n\t\tstruct mb_cache_entry *ce;\n\n\t\t/* assert(header == HDR(bh)); */\n\t\tce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev,\n\t\t\t\t\tbh->b_blocknr);\n\t\tlock_buffer(bh);\n\t\tif (header->h_refcount == cpu_to_le32(1)) {\n\t\t\tea_bdebug(bh, \"modifying in-place\");\n\t\t\tif (ce)\n\t\t\t\tmb_cache_entry_free(ce);\n\t\t\t/* keep the buffer locked while modifying it. */\n\t\t} else {\n\t\t\tint offset;\n\n\t\t\tif (ce)\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\tunlock_buffer(bh);\n\t\t\tea_bdebug(bh, \"cloning\");\n\t\t\theader = kmalloc(bh->b_size, GFP_KERNEL);\n\t\t\terror = -ENOMEM;\n\t\t\tif (header == NULL)\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(header, HDR(bh), bh->b_size);\n\t\t\theader->h_refcount = cpu_to_le32(1);\n\n\t\t\toffset = (char *)here - bh->b_data;\n\t\t\there = ENTRY((char *)header + offset);\n\t\t\toffset = (char *)last - bh->b_data;\n\t\t\tlast = ENTRY((char *)header + offset);\n\t\t}\n\t} else {\n\t\t/* Allocate a buffer where we construct the new block. */\n\t\theader = kzalloc(sb->s_blocksize, GFP_KERNEL);\n\t\terror = -ENOMEM;\n\t\tif (header == NULL)\n\t\t\tgoto cleanup;\n\t\tend = (char *)header + sb->s_blocksize;\n\t\theader->h_magic = cpu_to_le32(EXT2_XATTR_MAGIC);\n\t\theader->h_blocks = header->h_refcount = cpu_to_le32(1);\n\t\tlast = here = ENTRY(header+1);\n\t}\n\n\t/* Iff we are modifying the block in-place, bh is locked here. */\n\n\tif (not_found) {\n\t\t/* Insert the new name. */\n\t\tsize_t size = EXT2_XATTR_LEN(name_len);\n\t\tsize_t rest = (char *)last - (char *)here;\n\t\tmemmove((char *)here + size, here, rest);\n\t\tmemset(here, 0, size);\n\t\there->e_name_index = name_index;\n\t\there->e_name_len = name_len;\n\t\tmemcpy(here->e_name, name, name_len);\n\t} else {\n\t\tif (!here->e_value_block && here->e_value_size) {\n\t\t\tchar *first_val = (char *)header + min_offs;\n\t\t\tsize_t offs = le16_to_cpu(here->e_value_offs);\n\t\t\tchar *val = (char *)header + offs;\n\t\t\tsize_t size = EXT2_XATTR_SIZE(\n\t\t\t\tle32_to_cpu(here->e_value_size));\n\n\t\t\tif (size == EXT2_XATTR_SIZE(value_len)) {\n\t\t\t\t/* The old and the new value have the same\n\t\t\t\t   size. Just replace. */\n\t\t\t\there->e_value_size = cpu_to_le32(value_len);\n\t\t\t\tmemset(val + size - EXT2_XATTR_PAD, 0,\n\t\t\t\t       EXT2_XATTR_PAD); /* Clear pad bytes. */\n\t\t\t\tmemcpy(val, value, value_len);\n\t\t\t\tgoto skip_replace;\n\t\t\t}\n\n\t\t\t/* Remove the old value. */\n\t\t\tmemmove(first_val + size, first_val, val - first_val);\n\t\t\tmemset(first_val, 0, size);\n\t\t\there->e_value_offs = 0;\n\t\t\tmin_offs += size;\n\n\t\t\t/* Adjust all value offsets. */\n\t\t\tlast = ENTRY(header+1);\n\t\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\t\tsize_t o = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (!last->e_value_block && o < offs)\n\t\t\t\t\tlast->e_value_offs =\n\t\t\t\t\t\tcpu_to_le16(o + size);\n\t\t\t\tlast = EXT2_XATTR_NEXT(last);\n\t\t\t}\n\t\t}\n\t\tif (value == NULL) {\n\t\t\t/* Remove the old name. */\n\t\t\tsize_t size = EXT2_XATTR_LEN(name_len);\n\t\t\tlast = ENTRY((char *)last - size);\n\t\t\tmemmove(here, (char*)here + size,\n\t\t\t\t(char*)last - (char*)here);\n\t\t\tmemset(last, 0, size);\n\t\t}\n\t}\n\n\tif (value != NULL) {\n\t\t/* Insert the new value. */\n\t\there->e_value_size = cpu_to_le32(value_len);\n\t\tif (value_len) {\n\t\t\tsize_t size = EXT2_XATTR_SIZE(value_len);\n\t\t\tchar *val = (char *)header + min_offs - size;\n\t\t\there->e_value_offs =\n\t\t\t\tcpu_to_le16((char *)val - (char *)header);\n\t\t\tmemset(val + size - EXT2_XATTR_PAD, 0,\n\t\t\t       EXT2_XATTR_PAD); /* Clear the pad bytes. */\n\t\t\tmemcpy(val, value, value_len);\n\t\t}\n\t}\n\nskip_replace:\n\tif (IS_LAST_ENTRY(ENTRY(header+1))) {\n\t\t/* This block is now empty. */\n\t\tif (bh && header == HDR(bh))\n\t\t\tunlock_buffer(bh);  /* we were modifying in-place. */\n\t\terror = ext2_xattr_set2(inode, bh, NULL);\n\t} else {\n\t\text2_xattr_rehash(header, here);\n\t\tif (bh && header == HDR(bh))\n\t\t\tunlock_buffer(bh);  /* we were modifying in-place. */\n\t\terror = ext2_xattr_set2(inode, bh, header);\n\t}\n\ncleanup:\n\tbrelse(bh);\n\tif (!(bh && header == HDR(bh)))\n\t\tkfree(header);\n\tup_write(&EXT2_I(inode)->xattr_sem);\n\n\treturn error;\n}\n\n/*\n * Second half of ext2_xattr_set(): Update the file system.\n */\nstatic int\next2_xattr_set2(struct inode *inode, struct buffer_head *old_bh,\n\t\tstruct ext2_xattr_header *header)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *new_bh = NULL;\n\tint error;\n\n\tif (header) {\n\t\tnew_bh = ext2_xattr_cache_find(inode, header);\n\t\tif (new_bh) {\n\t\t\t/* We found an identical block in the cache. */\n\t\t\tif (new_bh == old_bh) {\n\t\t\t\tea_bdebug(new_bh, \"keeping this block\");\n\t\t\t} else {\n\t\t\t\t/* The old block is released after updating\n\t\t\t\t   the inode.  */\n\t\t\t\tea_bdebug(new_bh, \"reusing block\");\n\n\t\t\t\terror = dquot_alloc_block(inode, 1);\n\t\t\t\tif (error) {\n\t\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tle32_add_cpu(&HDR(new_bh)->h_refcount, 1);\n\t\t\t\tea_bdebug(new_bh, \"refcount now=%d\",\n\t\t\t\t\tle32_to_cpu(HDR(new_bh)->h_refcount));\n\t\t\t}\n\t\t\tunlock_buffer(new_bh);\n\t\t} else if (old_bh && header == HDR(old_bh)) {\n\t\t\t/* Keep this block. No need to lock the block as we\n\t\t\t   don't need to change the reference count. */\n\t\t\tnew_bh = old_bh;\n\t\t\tget_bh(new_bh);\n\t\t\text2_xattr_cache_insert(new_bh);\n\t\t} else {\n\t\t\t/* We need to allocate a new block */\n\t\t\text2_fsblk_t goal = ext2_group_first_block_no(sb,\n\t\t\t\t\t\tEXT2_I(inode)->i_block_group);\n\t\t\tint block = ext2_new_block(inode, goal, &error);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tea_idebug(inode, \"creating block %d\", block);\n\n\t\t\tnew_bh = sb_getblk(sb, block);\n\t\t\tif (unlikely(!new_bh)) {\n\t\t\t\text2_free_blocks(inode, block, 1);\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tlock_buffer(new_bh);\n\t\t\tmemcpy(new_bh->b_data, header, new_bh->b_size);\n\t\t\tset_buffer_uptodate(new_bh);\n\t\t\tunlock_buffer(new_bh);\n\t\t\text2_xattr_cache_insert(new_bh);\n\t\t\t\n\t\t\text2_xattr_update_super_block(sb);\n\t\t}\n\t\tmark_buffer_dirty(new_bh);\n\t\tif (IS_SYNC(inode)) {\n\t\t\tsync_dirty_buffer(new_bh);\n\t\t\terror = -EIO;\n\t\t\tif (buffer_req(new_bh) && !buffer_uptodate(new_bh))\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* Update the inode. */\n\tEXT2_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tif (IS_SYNC(inode)) {\n\t\terror = sync_inode_metadata(inode, 1);\n\t\t/* In case sync failed due to ENOSPC the inode was actually\n\t\t * written (only some dirty data were not) so we just proceed\n\t\t * as if nothing happened and cleanup the unused block */\n\t\tif (error && error != -ENOSPC) {\n\t\t\tif (new_bh && new_bh != old_bh) {\n\t\t\t\tdquot_free_block_nodirty(inode, 1);\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t}\n\t\t\tgoto cleanup;\n\t\t}\n\t} else\n\t\tmark_inode_dirty(inode);\n\n\terror = 0;\n\tif (old_bh && old_bh != new_bh) {\n\t\tstruct mb_cache_entry *ce;\n\n\t\t/*\n\t\t * If there was an old block and we are no longer using it,\n\t\t * release the old block.\n\t\t */\n\t\tce = mb_cache_entry_get(ext2_xattr_cache, old_bh->b_bdev,\n\t\t\t\t\told_bh->b_blocknr);\n\t\tlock_buffer(old_bh);\n\t\tif (HDR(old_bh)->h_refcount == cpu_to_le32(1)) {\n\t\t\t/* Free the old block. */\n\t\t\tif (ce)\n\t\t\t\tmb_cache_entry_free(ce);\n\t\t\tea_bdebug(old_bh, \"freeing\");\n\t\t\text2_free_blocks(inode, old_bh->b_blocknr, 1);\n\t\t\tmark_inode_dirty(inode);\n\t\t\t/* We let our caller release old_bh, so we\n\t\t\t * need to duplicate the buffer before. */\n\t\t\tget_bh(old_bh);\n\t\t\tbforget(old_bh);\n\t\t} else {\n\t\t\t/* Decrement the refcount only. */\n\t\t\tle32_add_cpu(&HDR(old_bh)->h_refcount, -1);\n\t\t\tif (ce)\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\tdquot_free_block_nodirty(inode, 1);\n\t\t\tmark_inode_dirty(inode);\n\t\t\tmark_buffer_dirty(old_bh);\n\t\t\tea_bdebug(old_bh, \"refcount now=%d\",\n\t\t\t\tle32_to_cpu(HDR(old_bh)->h_refcount));\n\t\t}\n\t\tunlock_buffer(old_bh);\n\t}\n\ncleanup:\n\tbrelse(new_bh);\n\n\treturn error;\n}\n\n/*\n * ext2_xattr_delete_inode()\n *\n * Free extended attribute resources associated with this inode. This\n * is called immediately before an inode is freed.\n */\nvoid\next2_xattr_delete_inode(struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct mb_cache_entry *ce;\n\n\tdown_write(&EXT2_I(inode)->xattr_sem);\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\tif (!bh) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: block %d read error\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tea_bdebug(bh, \"b_count=%d\", atomic_read(&(bh->b_count)));\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev, bh->b_blocknr);\n\tlock_buffer(bh);\n\tif (HDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\text2_free_blocks(inode, EXT2_I(inode)->i_file_acl, 1);\n\t\tget_bh(bh);\n\t\tbforget(bh);\n\t\tunlock_buffer(bh);\n\t} else {\n\t\tle32_add_cpu(&HDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t\tea_bdebug(bh, \"refcount now=%d\",\n\t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n\t\tunlock_buffer(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tif (IS_SYNC(inode))\n\t\t\tsync_dirty_buffer(bh);\n\t\tdquot_free_block_nodirty(inode, 1);\n\t}\n\tEXT2_I(inode)->i_file_acl = 0;\n\ncleanup:\n\tbrelse(bh);\n\tup_write(&EXT2_I(inode)->xattr_sem);\n}\n\n/*\n * ext2_xattr_put_super()\n *\n * This is called when a file system is unmounted.\n */\nvoid\next2_xattr_put_super(struct super_block *sb)\n{\n\tmb_cache_shrink(sb->s_bdev);\n}\n\n\n/*\n * ext2_xattr_cache_insert()\n *\n * Create a new entry in the extended attribute cache, and insert\n * it unless such an entry is already in the cache.\n *\n * Returns 0, or a negative error number on failure.\n */\nstatic int\next2_xattr_cache_insert(struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext2_xattr_cache, GFP_NOFS);\n\tif (!ce)\n\t\treturn -ENOMEM;\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache (%d cache entries)\",\n\t\t\t\tatomic_read(&ext2_xattr_cache->c_entry_count));\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x] (%d cache entries)\", (int)hash,\n\t\t\t  atomic_read(&ext2_xattr_cache->c_entry_count));\n\t\tmb_cache_entry_release(ce);\n\t}\n\treturn error;\n}\n\n/*\n * ext2_xattr_cmp()\n *\n * Compare two extended attribute blocks for equality.\n *\n * Returns 0 if the blocks are equal, 1 if they differ, and\n * a negative error number on errors.\n */\nstatic int\next2_xattr_cmp(struct ext2_xattr_header *header1,\n\t       struct ext2_xattr_header *header2)\n{\n\tstruct ext2_xattr_entry *entry1, *entry2;\n\n\tentry1 = ENTRY(header1+1);\n\tentry2 = ENTRY(header2+1);\n\twhile (!IS_LAST_ENTRY(entry1)) {\n\t\tif (IS_LAST_ENTRY(entry2))\n\t\t\treturn 1;\n\t\tif (entry1->e_hash != entry2->e_hash ||\n\t\t    entry1->e_name_index != entry2->e_name_index ||\n\t\t    entry1->e_name_len != entry2->e_name_len ||\n\t\t    entry1->e_value_size != entry2->e_value_size ||\n\t\t    memcmp(entry1->e_name, entry2->e_name, entry1->e_name_len))\n\t\t\treturn 1;\n\t\tif (entry1->e_value_block != 0 || entry2->e_value_block != 0)\n\t\t\treturn -EIO;\n\t\tif (memcmp((char *)header1 + le16_to_cpu(entry1->e_value_offs),\n\t\t\t   (char *)header2 + le16_to_cpu(entry2->e_value_offs),\n\t\t\t   le32_to_cpu(entry1->e_value_size)))\n\t\t\treturn 1;\n\n\t\tentry1 = EXT2_XATTR_NEXT(entry1);\n\t\tentry2 = EXT2_XATTR_NEXT(entry2);\n\t}\n\tif (!IS_LAST_ENTRY(entry2))\n\t\treturn 1;\n\treturn 0;\n}\n\n/*\n * ext2_xattr_cache_find()\n *\n * Find an identical extended attribute block.\n *\n * Returns a locked buffer head to the block found, or NULL if such\n * a block was not found or an error occurred.\n */\nstatic struct buffer_head *\next2_xattr_cache_find(struct inode *inode, struct ext2_xattr_header *header)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb_cache_entry *ce;\n\n\tif (!header->h_hash)\n\t\treturn NULL;  /* never share */\n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\nagain:\n\tce = mb_cache_entry_find_first(ext2_xattr_cache, inode->i_sb->s_bdev,\n\t\t\t\t       hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\n\t\tif (IS_ERR(ce)) {\n\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t}\n\n\t\tbh = sb_bread(inode->i_sb, ce->e_block);\n\t\tif (!bh) {\n\t\t\text2_error(inode->i_sb, \"ext2_xattr_cache_find\",\n\t\t\t\t\"inode %ld: block %ld read error\",\n\t\t\t\tinode->i_ino, (unsigned long) ce->e_block);\n\t\t} else {\n\t\t\tlock_buffer(bh);\n\t\t\tif (le32_to_cpu(HDR(bh)->h_refcount) >\n\t\t\t\t   EXT2_XATTR_REFCOUNT_MAX) {\n\t\t\t\tea_idebug(inode, \"block %ld refcount %d>%d\",\n\t\t\t\t\t  (unsigned long) ce->e_block,\n\t\t\t\t\t  le32_to_cpu(HDR(bh)->h_refcount),\n\t\t\t\t\t  EXT2_XATTR_REFCOUNT_MAX);\n\t\t\t} else if (!ext2_xattr_cmp(header, HDR(bh))) {\n\t\t\t\tea_bdebug(bh, \"b_count=%d\",\n\t\t\t\t\t  atomic_read(&(bh->b_count)));\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\t\treturn bh;\n\t\t\t}\n\t\t\tunlock_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\t\tce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);\n\t}\n\treturn NULL;\n}\n\n#define NAME_HASH_SHIFT 5\n#define VALUE_HASH_SHIFT 16\n\n/*\n * ext2_xattr_hash_entry()\n *\n * Compute the hash of an extended attribute.\n */\nstatic inline void ext2_xattr_hash_entry(struct ext2_xattr_header *header,\n\t\t\t\t\t struct ext2_xattr_entry *entry)\n{\n\t__u32 hash = 0;\n\tchar *name = entry->e_name;\n\tint n;\n\n\tfor (n=0; n < entry->e_name_len; n++) {\n\t\thash = (hash << NAME_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - NAME_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\n\tif (entry->e_value_block == 0 && entry->e_value_size != 0) {\n\t\t__le32 *value = (__le32 *)((char *)header +\n\t\t\tle16_to_cpu(entry->e_value_offs));\n\t\tfor (n = (le32_to_cpu(entry->e_value_size) +\n\t\t     EXT2_XATTR_ROUND) >> EXT2_XATTR_PAD_BITS; n; n--) {\n\t\t\thash = (hash << VALUE_HASH_SHIFT) ^\n\t\t\t       (hash >> (8*sizeof(hash) - VALUE_HASH_SHIFT)) ^\n\t\t\t       le32_to_cpu(*value++);\n\t\t}\n\t}\n\tentry->e_hash = cpu_to_le32(hash);\n}\n\n#undef NAME_HASH_SHIFT\n#undef VALUE_HASH_SHIFT\n\n#define BLOCK_HASH_SHIFT 16\n\n/*\n * ext2_xattr_rehash()\n *\n * Re-compute the extended attribute hash value after an entry has changed.\n */\nstatic void ext2_xattr_rehash(struct ext2_xattr_header *header,\n\t\t\t      struct ext2_xattr_entry *entry)\n{\n\tstruct ext2_xattr_entry *here;\n\t__u32 hash = 0;\n\t\n\text2_xattr_hash_entry(header, entry);\n\there = ENTRY(header+1);\n\twhile (!IS_LAST_ENTRY(here)) {\n\t\tif (!here->e_hash) {\n\t\t\t/* Block is not shared if an entry's hash value == 0 */\n\t\t\thash = 0;\n\t\t\tbreak;\n\t\t}\n\t\thash = (hash << BLOCK_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - BLOCK_HASH_SHIFT)) ^\n\t\t       le32_to_cpu(here->e_hash);\n\t\there = EXT2_XATTR_NEXT(here);\n\t}\n\theader->h_hash = cpu_to_le32(hash);\n}\n\n#undef BLOCK_HASH_SHIFT\n\nint __init\ninit_ext2_xattr(void)\n{\n\text2_xattr_cache = mb_cache_create(\"ext2_xattr\", 6);\n\tif (!ext2_xattr_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid\nexit_ext2_xattr(void)\n{\n\tmb_cache_destroy(ext2_xattr_cache);\n}\n", "/*\n  File: linux/ext2_xattr.h\n\n  On-disk format of extended attributes for the ext2 filesystem.\n\n  (C) 2001 Andreas Gruenbacher, <a.gruenbacher@computer.org>\n*/\n\n#include <linux/init.h>\n#include <linux/xattr.h>\n\n/* Magic value in attribute blocks */\n#define EXT2_XATTR_MAGIC\t\t0xEA020000\n\n/* Maximum number of references to one attribute block */\n#define EXT2_XATTR_REFCOUNT_MAX\t\t1024\n\n/* Name indexes */\n#define EXT2_XATTR_INDEX_USER\t\t\t1\n#define EXT2_XATTR_INDEX_POSIX_ACL_ACCESS\t2\n#define EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT\t3\n#define EXT2_XATTR_INDEX_TRUSTED\t\t4\n#define\tEXT2_XATTR_INDEX_LUSTRE\t\t\t5\n#define EXT2_XATTR_INDEX_SECURITY\t        6\n\nstruct ext2_xattr_header {\n\t__le32\th_magic;\t/* magic number for identification */\n\t__le32\th_refcount;\t/* reference count */\n\t__le32\th_blocks;\t/* number of disk blocks used */\n\t__le32\th_hash;\t\t/* hash value of all attributes */\n\t__u32\th_reserved[4];\t/* zero right now */\n};\n\nstruct ext2_xattr_entry {\n\t__u8\te_name_len;\t/* length of name */\n\t__u8\te_name_index;\t/* attribute name index */\n\t__le16\te_value_offs;\t/* offset in disk block of value */\n\t__le32\te_value_block;\t/* disk block attribute is stored on (n/i) */\n\t__le32\te_value_size;\t/* size of attribute value */\n\t__le32\te_hash;\t\t/* hash value of name and value */\n\tchar\te_name[0];\t/* attribute name */\n};\n\n#define EXT2_XATTR_PAD_BITS\t\t2\n#define EXT2_XATTR_PAD\t\t(1<<EXT2_XATTR_PAD_BITS)\n#define EXT2_XATTR_ROUND\t\t(EXT2_XATTR_PAD-1)\n#define EXT2_XATTR_LEN(name_len) \\\n\t(((name_len) + EXT2_XATTR_ROUND + \\\n\tsizeof(struct ext2_xattr_entry)) & ~EXT2_XATTR_ROUND)\n#define EXT2_XATTR_NEXT(entry) \\\n\t( (struct ext2_xattr_entry *)( \\\n\t  (char *)(entry) + EXT2_XATTR_LEN((entry)->e_name_len)) )\n#define EXT2_XATTR_SIZE(size) \\\n\t(((size) + EXT2_XATTR_ROUND) & ~EXT2_XATTR_ROUND)\n\n# ifdef CONFIG_EXT2_FS_XATTR\n\nextern const struct xattr_handler ext2_xattr_user_handler;\nextern const struct xattr_handler ext2_xattr_trusted_handler;\nextern const struct xattr_handler ext2_xattr_security_handler;\n\nextern ssize_t ext2_listxattr(struct dentry *, char *, size_t);\n\nextern int ext2_xattr_get(struct inode *, int, const char *, void *, size_t);\nextern int ext2_xattr_set(struct inode *, int, const char *, const void *, size_t, int);\n\nextern void ext2_xattr_delete_inode(struct inode *);\nextern void ext2_xattr_put_super(struct super_block *);\n\nextern int init_ext2_xattr(void);\nextern void exit_ext2_xattr(void);\n\nextern const struct xattr_handler *ext2_xattr_handlers[];\n\n# else  /* CONFIG_EXT2_FS_XATTR */\n\nstatic inline int\next2_xattr_get(struct inode *inode, int name_index,\n\t       const char *name, void *buffer, size_t size)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int\next2_xattr_set(struct inode *inode, int name_index, const char *name,\n\t       const void *value, size_t size, int flags)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline void\next2_xattr_delete_inode(struct inode *inode)\n{\n}\n\nstatic inline void\next2_xattr_put_super(struct super_block *sb)\n{\n}\n\nstatic inline int\ninit_ext2_xattr(void)\n{\n\treturn 0;\n}\n\nstatic inline void\nexit_ext2_xattr(void)\n{\n}\n\n#define ext2_xattr_handlers NULL\n\n# endif  /* CONFIG_EXT2_FS_XATTR */\n\n#ifdef CONFIG_EXT2_FS_SECURITY\nextern int ext2_init_security(struct inode *inode, struct inode *dir,\n\t\t\t      const struct qstr *qstr);\n#else\nstatic inline int ext2_init_security(struct inode *inode, struct inode *dir,\n\t\t\t\t     const struct qstr *qstr)\n{\n\treturn 0;\n}\n#endif\n"], "fixing_code": ["/*\n * Copyright (C) 1992, 1993, 1994, 1995\n * Remy Card (card@masi.ibp.fr)\n * Laboratoire MASI - Institut Blaise Pascal\n * Universite Pierre et Marie Curie (Paris VI)\n *\n *  from\n *\n *  linux/include/linux/minix_fs.h\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n#include <linux/fs.h>\n#include <linux/ext2_fs.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/percpu_counter.h>\n#include <linux/rbtree.h>\n\n/* XXX Here for now... not interested in restructing headers JUST now */\n\n/* data type for block offset of block group */\ntypedef int ext2_grpblk_t;\n\n/* data type for filesystem-wide blocks number */\ntypedef unsigned long ext2_fsblk_t;\n\n#define E2FSBLK \"%lu\"\n\nstruct ext2_reserve_window {\n\text2_fsblk_t\t\t_rsv_start;\t/* First byte reserved */\n\text2_fsblk_t\t\t_rsv_end;\t/* Last byte reserved or 0 */\n};\n\nstruct ext2_reserve_window_node {\n\tstruct rb_node\t \trsv_node;\n\t__u32\t\t\trsv_goal_size;\n\t__u32\t\t\trsv_alloc_hit;\n\tstruct ext2_reserve_window\trsv_window;\n};\n\nstruct ext2_block_alloc_info {\n\t/* information about reservation window */\n\tstruct ext2_reserve_window_node\trsv_window_node;\n\t/*\n\t * was i_next_alloc_block in ext2_inode_info\n\t * is the logical (file-relative) number of the\n\t * most-recently-allocated block in this file.\n\t * We use this for detecting linearly ascending allocation requests.\n\t */\n\t__u32\t\t\tlast_alloc_logical_block;\n\t/*\n\t * Was i_next_alloc_goal in ext2_inode_info\n\t * is the *physical* companion to i_next_alloc_block.\n\t * it the the physical block number of the block which was most-recentl\n\t * allocated to this file.  This give us the goal (target) for the next\n\t * allocation when we detect linearly ascending requests.\n\t */\n\text2_fsblk_t\t\tlast_alloc_physical_block;\n};\n\n#define rsv_start rsv_window._rsv_start\n#define rsv_end rsv_window._rsv_end\n\nstruct mb2_cache;\n\n/*\n * second extended-fs super-block data in memory\n */\nstruct ext2_sb_info {\n\tunsigned long s_frag_size;\t/* Size of a fragment in bytes */\n\tunsigned long s_frags_per_block;/* Number of fragments per block */\n\tunsigned long s_inodes_per_block;/* Number of inodes per block */\n\tunsigned long s_frags_per_group;/* Number of fragments in a group */\n\tunsigned long s_blocks_per_group;/* Number of blocks in a group */\n\tunsigned long s_inodes_per_group;/* Number of inodes in a group */\n\tunsigned long s_itb_per_group;\t/* Number of inode table blocks per group */\n\tunsigned long s_gdb_count;\t/* Number of group descriptor blocks */\n\tunsigned long s_desc_per_block;\t/* Number of group descriptors per block */\n\tunsigned long s_groups_count;\t/* Number of groups in the fs */\n\tunsigned long s_overhead_last;  /* Last calculated overhead */\n\tunsigned long s_blocks_last;    /* Last seen block count */\n\tstruct buffer_head * s_sbh;\t/* Buffer containing the super block */\n\tstruct ext2_super_block * s_es;\t/* Pointer to the super block in the buffer */\n\tstruct buffer_head ** s_group_desc;\n\tunsigned long  s_mount_opt;\n\tunsigned long s_sb_block;\n\tkuid_t s_resuid;\n\tkgid_t s_resgid;\n\tunsigned short s_mount_state;\n\tunsigned short s_pad;\n\tint s_addr_per_block_bits;\n\tint s_desc_per_block_bits;\n\tint s_inode_size;\n\tint s_first_ino;\n\tspinlock_t s_next_gen_lock;\n\tu32 s_next_generation;\n\tunsigned long s_dir_count;\n\tu8 *s_debts;\n\tstruct percpu_counter s_freeblocks_counter;\n\tstruct percpu_counter s_freeinodes_counter;\n\tstruct percpu_counter s_dirs_counter;\n\tstruct blockgroup_lock *s_blockgroup_lock;\n\t/* root of the per fs reservation window tree */\n\tspinlock_t s_rsv_window_lock;\n\tstruct rb_root s_rsv_window_root;\n\tstruct ext2_reserve_window_node s_rsv_window_head;\n\t/*\n\t * s_lock protects against concurrent modifications of s_mount_state,\n\t * s_blocks_last, s_overhead_last and the content of superblock's\n\t * buffer pointed to by sbi->s_es.\n\t *\n\t * Note: It is used in ext2_show_options() to provide a consistent view\n\t * of the mount options.\n\t */\n\tspinlock_t s_lock;\n\tstruct mb2_cache *s_mb_cache;\n};\n\nstatic inline spinlock_t *\nsb_bgl_lock(struct ext2_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}\n\n/*\n * Define EXT2FS_DEBUG to produce debug messages\n */\n#undef EXT2FS_DEBUG\n\n/*\n * Define EXT2_RESERVATION to reserve data blocks for expanding files\n */\n#define EXT2_DEFAULT_RESERVE_BLOCKS     8\n/*max window size: 1024(direct blocks) + 3([t,d]indirect blocks) */\n#define EXT2_MAX_RESERVE_BLOCKS         1027\n#define EXT2_RESERVE_WINDOW_NOT_ALLOCATED 0\n/*\n * The second extended file system version\n */\n#define EXT2FS_DATE\t\t\"95/08/09\"\n#define EXT2FS_VERSION\t\t\"0.5b\"\n\n/*\n * Debug code\n */\n#ifdef EXT2FS_DEBUG\n#\tdefine ext2_debug(f, a...)\t{ \\\n\t\t\t\t\tprintk (\"EXT2-fs DEBUG (%s, %d): %s:\", \\\n\t\t\t\t\t\t__FILE__, __LINE__, __func__); \\\n\t\t\t\t  \tprintk (f, ## a); \\\n\t\t\t\t\t}\n#else\n#\tdefine ext2_debug(f, a...)\t/**/\n#endif\n\n/*\n * Special inode numbers\n */\n#define\tEXT2_BAD_INO\t\t 1\t/* Bad blocks inode */\n#define EXT2_ROOT_INO\t\t 2\t/* Root inode */\n#define EXT2_BOOT_LOADER_INO\t 5\t/* Boot loader inode */\n#define EXT2_UNDEL_DIR_INO\t 6\t/* Undelete directory inode */\n\n/* First non-reserved inode for old ext2 filesystems */\n#define EXT2_GOOD_OLD_FIRST_INO\t11\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}\n\n/*\n * Macro-instructions used to manage several block sizes\n */\n#define EXT2_MIN_BLOCK_SIZE\t\t1024\n#define\tEXT2_MAX_BLOCK_SIZE\t\t4096\n#define EXT2_MIN_BLOCK_LOG_SIZE\t\t  10\n#define EXT2_BLOCK_SIZE(s)\t\t((s)->s_blocksize)\n#define\tEXT2_ADDR_PER_BLOCK(s)\t\t(EXT2_BLOCK_SIZE(s) / sizeof (__u32))\n#define EXT2_BLOCK_SIZE_BITS(s)\t\t((s)->s_blocksize_bits)\n#define\tEXT2_ADDR_PER_BLOCK_BITS(s)\t(EXT2_SB(s)->s_addr_per_block_bits)\n#define EXT2_INODE_SIZE(s)\t\t(EXT2_SB(s)->s_inode_size)\n#define EXT2_FIRST_INO(s)\t\t(EXT2_SB(s)->s_first_ino)\n\n/*\n * Macro-instructions used to manage fragments\n */\n#define EXT2_MIN_FRAG_SIZE\t\t1024\n#define\tEXT2_MAX_FRAG_SIZE\t\t4096\n#define EXT2_MIN_FRAG_LOG_SIZE\t\t  10\n#define EXT2_FRAG_SIZE(s)\t\t(EXT2_SB(s)->s_frag_size)\n#define EXT2_FRAGS_PER_BLOCK(s)\t\t(EXT2_SB(s)->s_frags_per_block)\n\n/*\n * Structure of a blocks group descriptor\n */\nstruct ext2_group_desc\n{\n\t__le32\tbg_block_bitmap;\t\t/* Blocks bitmap block */\n\t__le32\tbg_inode_bitmap;\t\t/* Inodes bitmap block */\n\t__le32\tbg_inode_table;\t\t/* Inodes table block */\n\t__le16\tbg_free_blocks_count;\t/* Free blocks count */\n\t__le16\tbg_free_inodes_count;\t/* Free inodes count */\n\t__le16\tbg_used_dirs_count;\t/* Directories count */\n\t__le16\tbg_pad;\n\t__le32\tbg_reserved[3];\n};\n\n/*\n * Macro-instructions used to manage group descriptors\n */\n#define EXT2_BLOCKS_PER_GROUP(s)\t(EXT2_SB(s)->s_blocks_per_group)\n#define EXT2_DESC_PER_BLOCK(s)\t\t(EXT2_SB(s)->s_desc_per_block)\n#define EXT2_INODES_PER_GROUP(s)\t(EXT2_SB(s)->s_inodes_per_group)\n#define EXT2_DESC_PER_BLOCK_BITS(s)\t(EXT2_SB(s)->s_desc_per_block_bits)\n\n/*\n * Constants relative to the data blocks\n */\n#define\tEXT2_NDIR_BLOCKS\t\t12\n#define\tEXT2_IND_BLOCK\t\t\tEXT2_NDIR_BLOCKS\n#define\tEXT2_DIND_BLOCK\t\t\t(EXT2_IND_BLOCK + 1)\n#define\tEXT2_TIND_BLOCK\t\t\t(EXT2_DIND_BLOCK + 1)\n#define\tEXT2_N_BLOCKS\t\t\t(EXT2_TIND_BLOCK + 1)\n\n/*\n * Inode flags (GETFLAGS/SETFLAGS)\n */\n#define\tEXT2_SECRM_FL\t\t\tFS_SECRM_FL\t/* Secure deletion */\n#define\tEXT2_UNRM_FL\t\t\tFS_UNRM_FL\t/* Undelete */\n#define\tEXT2_COMPR_FL\t\t\tFS_COMPR_FL\t/* Compress file */\n#define EXT2_SYNC_FL\t\t\tFS_SYNC_FL\t/* Synchronous updates */\n#define EXT2_IMMUTABLE_FL\t\tFS_IMMUTABLE_FL\t/* Immutable file */\n#define EXT2_APPEND_FL\t\t\tFS_APPEND_FL\t/* writes to file may only append */\n#define EXT2_NODUMP_FL\t\t\tFS_NODUMP_FL\t/* do not dump file */\n#define EXT2_NOATIME_FL\t\t\tFS_NOATIME_FL\t/* do not update atime */\n/* Reserved for compression usage... */\n#define EXT2_DIRTY_FL\t\t\tFS_DIRTY_FL\n#define EXT2_COMPRBLK_FL\t\tFS_COMPRBLK_FL\t/* One or more compressed clusters */\n#define EXT2_NOCOMP_FL\t\t\tFS_NOCOMP_FL\t/* Don't compress */\n#define EXT2_ECOMPR_FL\t\t\tFS_ECOMPR_FL\t/* Compression error */\n/* End compression flags --- maybe not all used */\t\n#define EXT2_BTREE_FL\t\t\tFS_BTREE_FL\t/* btree format dir */\n#define EXT2_INDEX_FL\t\t\tFS_INDEX_FL\t/* hash-indexed directory */\n#define EXT2_IMAGIC_FL\t\t\tFS_IMAGIC_FL\t/* AFS directory */\n#define EXT2_JOURNAL_DATA_FL\t\tFS_JOURNAL_DATA_FL /* Reserved for ext3 */\n#define EXT2_NOTAIL_FL\t\t\tFS_NOTAIL_FL\t/* file tail should not be merged */\n#define EXT2_DIRSYNC_FL\t\t\tFS_DIRSYNC_FL\t/* dirsync behaviour (directories only) */\n#define EXT2_TOPDIR_FL\t\t\tFS_TOPDIR_FL\t/* Top of directory hierarchies*/\n#define EXT2_RESERVED_FL\t\tFS_RESERVED_FL\t/* reserved for ext2 lib */\n\n#define EXT2_FL_USER_VISIBLE\t\tFS_FL_USER_VISIBLE\t/* User visible flags */\n#define EXT2_FL_USER_MODIFIABLE\t\tFS_FL_USER_MODIFIABLE\t/* User modifiable flags */\n\n/* Flags that should be inherited by new inodes from their parent. */\n#define EXT2_FL_INHERITED (EXT2_SECRM_FL | EXT2_UNRM_FL | EXT2_COMPR_FL |\\\n\t\t\t   EXT2_SYNC_FL | EXT2_NODUMP_FL |\\\n\t\t\t   EXT2_NOATIME_FL | EXT2_COMPRBLK_FL |\\\n\t\t\t   EXT2_NOCOMP_FL | EXT2_JOURNAL_DATA_FL |\\\n\t\t\t   EXT2_NOTAIL_FL | EXT2_DIRSYNC_FL)\n\n/* Flags that are appropriate for regular files (all but dir-specific ones). */\n#define EXT2_REG_FLMASK (~(EXT2_DIRSYNC_FL | EXT2_TOPDIR_FL))\n\n/* Flags that are appropriate for non-directories/regular files. */\n#define EXT2_OTHER_FLMASK (EXT2_NODUMP_FL | EXT2_NOATIME_FL)\n\n/* Mask out flags that are inappropriate for the given type of inode. */\nstatic inline __u32 ext2_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & EXT2_REG_FLMASK;\n\telse\n\t\treturn flags & EXT2_OTHER_FLMASK;\n}\n\n/*\n * ioctl commands\n */\n#define\tEXT2_IOC_GETFLAGS\t\tFS_IOC_GETFLAGS\n#define\tEXT2_IOC_SETFLAGS\t\tFS_IOC_SETFLAGS\n#define\tEXT2_IOC_GETVERSION\t\tFS_IOC_GETVERSION\n#define\tEXT2_IOC_SETVERSION\t\tFS_IOC_SETVERSION\n#define\tEXT2_IOC_GETRSVSZ\t\t_IOR('f', 5, long)\n#define\tEXT2_IOC_SETRSVSZ\t\t_IOW('f', 6, long)\n\n/*\n * ioctl commands in 32 bit emulation\n */\n#define EXT2_IOC32_GETFLAGS\t\tFS_IOC32_GETFLAGS\n#define EXT2_IOC32_SETFLAGS\t\tFS_IOC32_SETFLAGS\n#define EXT2_IOC32_GETVERSION\t\tFS_IOC32_GETVERSION\n#define EXT2_IOC32_SETVERSION\t\tFS_IOC32_SETVERSION\n\n/*\n * Structure of an inode on the disk\n */\nstruct ext2_inode {\n\t__le16\ti_mode;\t\t/* File mode */\n\t__le16\ti_uid;\t\t/* Low 16 bits of Owner Uid */\n\t__le32\ti_size;\t\t/* Size in bytes */\n\t__le32\ti_atime;\t/* Access time */\n\t__le32\ti_ctime;\t/* Creation time */\n\t__le32\ti_mtime;\t/* Modification time */\n\t__le32\ti_dtime;\t/* Deletion Time */\n\t__le16\ti_gid;\t\t/* Low 16 bits of Group Id */\n\t__le16\ti_links_count;\t/* Links count */\n\t__le32\ti_blocks;\t/* Blocks count */\n\t__le32\ti_flags;\t/* File flags */\n\tunion {\n\t\tstruct {\n\t\t\t__le32  l_i_reserved1;\n\t\t} linux1;\n\t\tstruct {\n\t\t\t__le32  h_i_translator;\n\t\t} hurd1;\n\t\tstruct {\n\t\t\t__le32  m_i_reserved1;\n\t\t} masix1;\n\t} osd1;\t\t\t\t/* OS dependent 1 */\n\t__le32\ti_block[EXT2_N_BLOCKS];/* Pointers to blocks */\n\t__le32\ti_generation;\t/* File version (for NFS) */\n\t__le32\ti_file_acl;\t/* File ACL */\n\t__le32\ti_dir_acl;\t/* Directory ACL */\n\t__le32\ti_faddr;\t/* Fragment address */\n\tunion {\n\t\tstruct {\n\t\t\t__u8\tl_i_frag;\t/* Fragment number */\n\t\t\t__u8\tl_i_fsize;\t/* Fragment size */\n\t\t\t__u16\ti_pad1;\n\t\t\t__le16\tl_i_uid_high;\t/* these 2 fields    */\n\t\t\t__le16\tl_i_gid_high;\t/* were reserved2[0] */\n\t\t\t__u32\tl_i_reserved2;\n\t\t} linux2;\n\t\tstruct {\n\t\t\t__u8\th_i_frag;\t/* Fragment number */\n\t\t\t__u8\th_i_fsize;\t/* Fragment size */\n\t\t\t__le16\th_i_mode_high;\n\t\t\t__le16\th_i_uid_high;\n\t\t\t__le16\th_i_gid_high;\n\t\t\t__le32\th_i_author;\n\t\t} hurd2;\n\t\tstruct {\n\t\t\t__u8\tm_i_frag;\t/* Fragment number */\n\t\t\t__u8\tm_i_fsize;\t/* Fragment size */\n\t\t\t__u16\tm_pad1;\n\t\t\t__u32\tm_i_reserved2[2];\n\t\t} masix2;\n\t} osd2;\t\t\t\t/* OS dependent 2 */\n};\n\n#define i_size_high\ti_dir_acl\n\n#define i_reserved1\tosd1.linux1.l_i_reserved1\n#define i_frag\t\tosd2.linux2.l_i_frag\n#define i_fsize\t\tosd2.linux2.l_i_fsize\n#define i_uid_low\ti_uid\n#define i_gid_low\ti_gid\n#define i_uid_high\tosd2.linux2.l_i_uid_high\n#define i_gid_high\tosd2.linux2.l_i_gid_high\n#define i_reserved2\tosd2.linux2.l_i_reserved2\n\n/*\n * File system states\n */\n#define\tEXT2_VALID_FS\t\t\t0x0001\t/* Unmounted cleanly */\n#define\tEXT2_ERROR_FS\t\t\t0x0002\t/* Errors detected */\n\n/*\n * Mount flags\n */\n#define EXT2_MOUNT_CHECK\t\t0x000001  /* Do mount-time checks */\n#define EXT2_MOUNT_OLDALLOC\t\t0x000002  /* Don't use the new Orlov allocator */\n#define EXT2_MOUNT_GRPID\t\t0x000004  /* Create files with directory's group */\n#define EXT2_MOUNT_DEBUG\t\t0x000008  /* Some debugging messages */\n#define EXT2_MOUNT_ERRORS_CONT\t\t0x000010  /* Continue on errors */\n#define EXT2_MOUNT_ERRORS_RO\t\t0x000020  /* Remount fs ro on errors */\n#define EXT2_MOUNT_ERRORS_PANIC\t\t0x000040  /* Panic on errors */\n#define EXT2_MOUNT_MINIX_DF\t\t0x000080  /* Mimics the Minix statfs */\n#define EXT2_MOUNT_NOBH\t\t\t0x000100  /* No buffer_heads */\n#define EXT2_MOUNT_NO_UID32\t\t0x000200  /* Disable 32-bit UIDs */\n#define EXT2_MOUNT_XATTR_USER\t\t0x004000  /* Extended user attributes */\n#define EXT2_MOUNT_POSIX_ACL\t\t0x008000  /* POSIX Access Control Lists */\n#define EXT2_MOUNT_XIP\t\t\t0x010000  /* Obsolete, use DAX */\n#define EXT2_MOUNT_USRQUOTA\t\t0x020000  /* user quota */\n#define EXT2_MOUNT_GRPQUOTA\t\t0x040000  /* group quota */\n#define EXT2_MOUNT_RESERVATION\t\t0x080000  /* Preallocation */\n#ifdef CONFIG_FS_DAX\n#define EXT2_MOUNT_DAX\t\t\t0x100000  /* Direct Access */\n#else\n#define EXT2_MOUNT_DAX\t\t\t0\n#endif\n\n\n#define clear_opt(o, opt)\t\to &= ~EXT2_MOUNT_##opt\n#define set_opt(o, opt)\t\t\to |= EXT2_MOUNT_##opt\n#define test_opt(sb, opt)\t\t(EXT2_SB(sb)->s_mount_opt & \\\n\t\t\t\t\t EXT2_MOUNT_##opt)\n/*\n * Maximal mount counts between two filesystem checks\n */\n#define EXT2_DFL_MAX_MNT_COUNT\t\t20\t/* Allow 20 mounts */\n#define EXT2_DFL_CHECKINTERVAL\t\t0\t/* Don't use interval check */\n\n/*\n * Behaviour when detecting errors\n */\n#define EXT2_ERRORS_CONTINUE\t\t1\t/* Continue execution */\n#define EXT2_ERRORS_RO\t\t\t2\t/* Remount fs read-only */\n#define EXT2_ERRORS_PANIC\t\t3\t/* Panic */\n#define EXT2_ERRORS_DEFAULT\t\tEXT2_ERRORS_CONTINUE\n\n/*\n * Structure of the super block\n */\nstruct ext2_super_block {\n\t__le32\ts_inodes_count;\t\t/* Inodes count */\n\t__le32\ts_blocks_count;\t\t/* Blocks count */\n\t__le32\ts_r_blocks_count;\t/* Reserved blocks count */\n\t__le32\ts_free_blocks_count;\t/* Free blocks count */\n\t__le32\ts_free_inodes_count;\t/* Free inodes count */\n\t__le32\ts_first_data_block;\t/* First Data Block */\n\t__le32\ts_log_block_size;\t/* Block size */\n\t__le32\ts_log_frag_size;\t/* Fragment size */\n\t__le32\ts_blocks_per_group;\t/* # Blocks per group */\n\t__le32\ts_frags_per_group;\t/* # Fragments per group */\n\t__le32\ts_inodes_per_group;\t/* # Inodes per group */\n\t__le32\ts_mtime;\t\t/* Mount time */\n\t__le32\ts_wtime;\t\t/* Write time */\n\t__le16\ts_mnt_count;\t\t/* Mount count */\n\t__le16\ts_max_mnt_count;\t/* Maximal mount count */\n\t__le16\ts_magic;\t\t/* Magic signature */\n\t__le16\ts_state;\t\t/* File system state */\n\t__le16\ts_errors;\t\t/* Behaviour when detecting errors */\n\t__le16\ts_minor_rev_level; \t/* minor revision level */\n\t__le32\ts_lastcheck;\t\t/* time of last check */\n\t__le32\ts_checkinterval;\t/* max. time between checks */\n\t__le32\ts_creator_os;\t\t/* OS */\n\t__le32\ts_rev_level;\t\t/* Revision level */\n\t__le16\ts_def_resuid;\t\t/* Default uid for reserved blocks */\n\t__le16\ts_def_resgid;\t\t/* Default gid for reserved blocks */\n\t/*\n\t * These fields are for EXT2_DYNAMIC_REV superblocks only.\n\t *\n\t * Note: the difference between the compatible feature set and\n\t * the incompatible feature set is that if there is a bit set\n\t * in the incompatible feature set that the kernel doesn't\n\t * know about, it should refuse to mount the filesystem.\n\t * \n\t * e2fsck's requirements are more strict; if it doesn't know\n\t * about a feature in either the compatible or incompatible\n\t * feature set, it must abort and not try to meddle with\n\t * things it doesn't understand...\n\t */\n\t__le32\ts_first_ino; \t\t/* First non-reserved inode */\n\t__le16   s_inode_size; \t\t/* size of inode structure */\n\t__le16\ts_block_group_nr; \t/* block group # of this superblock */\n\t__le32\ts_feature_compat; \t/* compatible feature set */\n\t__le32\ts_feature_incompat; \t/* incompatible feature set */\n\t__le32\ts_feature_ro_compat; \t/* readonly-compatible feature set */\n\t__u8\ts_uuid[16];\t\t/* 128-bit uuid for volume */\n\tchar\ts_volume_name[16]; \t/* volume name */\n\tchar\ts_last_mounted[64]; \t/* directory where last mounted */\n\t__le32\ts_algorithm_usage_bitmap; /* For compression */\n\t/*\n\t * Performance hints.  Directory preallocation should only\n\t * happen if the EXT2_COMPAT_PREALLOC flag is on.\n\t */\n\t__u8\ts_prealloc_blocks;\t/* Nr of blocks to try to preallocate*/\n\t__u8\ts_prealloc_dir_blocks;\t/* Nr to preallocate for dirs */\n\t__u16\ts_padding1;\n\t/*\n\t * Journaling support valid if EXT3_FEATURE_COMPAT_HAS_JOURNAL set.\n\t */\n\t__u8\ts_journal_uuid[16];\t/* uuid of journal superblock */\n\t__u32\ts_journal_inum;\t\t/* inode number of journal file */\n\t__u32\ts_journal_dev;\t\t/* device number of journal file */\n\t__u32\ts_last_orphan;\t\t/* start of list of inodes to delete */\n\t__u32\ts_hash_seed[4];\t\t/* HTREE hash seed */\n\t__u8\ts_def_hash_version;\t/* Default hash version to use */\n\t__u8\ts_reserved_char_pad;\n\t__u16\ts_reserved_word_pad;\n\t__le32\ts_default_mount_opts;\n \t__le32\ts_first_meta_bg; \t/* First metablock block group */\n\t__u32\ts_reserved[190];\t/* Padding to the end of the block */\n};\n\n/*\n * Codes for operating systems\n */\n#define EXT2_OS_LINUX\t\t0\n#define EXT2_OS_HURD\t\t1\n#define EXT2_OS_MASIX\t\t2\n#define EXT2_OS_FREEBSD\t\t3\n#define EXT2_OS_LITES\t\t4\n\n/*\n * Revision levels\n */\n#define EXT2_GOOD_OLD_REV\t0\t/* The good old (original) format */\n#define EXT2_DYNAMIC_REV\t1 \t/* V2 format w/ dynamic inode sizes */\n\n#define EXT2_CURRENT_REV\tEXT2_GOOD_OLD_REV\n#define EXT2_MAX_SUPP_REV\tEXT2_DYNAMIC_REV\n\n#define EXT2_GOOD_OLD_INODE_SIZE 128\n\n/*\n * Feature set definitions\n */\n\n#define EXT2_HAS_COMPAT_FEATURE(sb,mask)\t\t\t\\\n\t( EXT2_SB(sb)->s_es->s_feature_compat & cpu_to_le32(mask) )\n#define EXT2_HAS_RO_COMPAT_FEATURE(sb,mask)\t\t\t\\\n\t( EXT2_SB(sb)->s_es->s_feature_ro_compat & cpu_to_le32(mask) )\n#define EXT2_HAS_INCOMPAT_FEATURE(sb,mask)\t\t\t\\\n\t( EXT2_SB(sb)->s_es->s_feature_incompat & cpu_to_le32(mask) )\n#define EXT2_SET_COMPAT_FEATURE(sb,mask)\t\t\t\\\n\tEXT2_SB(sb)->s_es->s_feature_compat |= cpu_to_le32(mask)\n#define EXT2_SET_RO_COMPAT_FEATURE(sb,mask)\t\t\t\\\n\tEXT2_SB(sb)->s_es->s_feature_ro_compat |= cpu_to_le32(mask)\n#define EXT2_SET_INCOMPAT_FEATURE(sb,mask)\t\t\t\\\n\tEXT2_SB(sb)->s_es->s_feature_incompat |= cpu_to_le32(mask)\n#define EXT2_CLEAR_COMPAT_FEATURE(sb,mask)\t\t\t\\\n\tEXT2_SB(sb)->s_es->s_feature_compat &= ~cpu_to_le32(mask)\n#define EXT2_CLEAR_RO_COMPAT_FEATURE(sb,mask)\t\t\t\\\n\tEXT2_SB(sb)->s_es->s_feature_ro_compat &= ~cpu_to_le32(mask)\n#define EXT2_CLEAR_INCOMPAT_FEATURE(sb,mask)\t\t\t\\\n\tEXT2_SB(sb)->s_es->s_feature_incompat &= ~cpu_to_le32(mask)\n\n#define EXT2_FEATURE_COMPAT_DIR_PREALLOC\t0x0001\n#define EXT2_FEATURE_COMPAT_IMAGIC_INODES\t0x0002\n#define EXT3_FEATURE_COMPAT_HAS_JOURNAL\t\t0x0004\n#define EXT2_FEATURE_COMPAT_EXT_ATTR\t\t0x0008\n#define EXT2_FEATURE_COMPAT_RESIZE_INO\t\t0x0010\n#define EXT2_FEATURE_COMPAT_DIR_INDEX\t\t0x0020\n#define EXT2_FEATURE_COMPAT_ANY\t\t\t0xffffffff\n\n#define EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER\t0x0001\n#define EXT2_FEATURE_RO_COMPAT_LARGE_FILE\t0x0002\n#define EXT2_FEATURE_RO_COMPAT_BTREE_DIR\t0x0004\n#define EXT2_FEATURE_RO_COMPAT_ANY\t\t0xffffffff\n\n#define EXT2_FEATURE_INCOMPAT_COMPRESSION\t0x0001\n#define EXT2_FEATURE_INCOMPAT_FILETYPE\t\t0x0002\n#define EXT3_FEATURE_INCOMPAT_RECOVER\t\t0x0004\n#define EXT3_FEATURE_INCOMPAT_JOURNAL_DEV\t0x0008\n#define EXT2_FEATURE_INCOMPAT_META_BG\t\t0x0010\n#define EXT2_FEATURE_INCOMPAT_ANY\t\t0xffffffff\n\n#define EXT2_FEATURE_COMPAT_SUPP\tEXT2_FEATURE_COMPAT_EXT_ATTR\n#define EXT2_FEATURE_INCOMPAT_SUPP\t(EXT2_FEATURE_INCOMPAT_FILETYPE| \\\n\t\t\t\t\t EXT2_FEATURE_INCOMPAT_META_BG)\n#define EXT2_FEATURE_RO_COMPAT_SUPP\t(EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER| \\\n\t\t\t\t\t EXT2_FEATURE_RO_COMPAT_LARGE_FILE| \\\n\t\t\t\t\t EXT2_FEATURE_RO_COMPAT_BTREE_DIR)\n#define EXT2_FEATURE_RO_COMPAT_UNSUPPORTED\t~EXT2_FEATURE_RO_COMPAT_SUPP\n#define EXT2_FEATURE_INCOMPAT_UNSUPPORTED\t~EXT2_FEATURE_INCOMPAT_SUPP\n\n/*\n * Default values for user and/or group using reserved blocks\n */\n#define\tEXT2_DEF_RESUID\t\t0\n#define\tEXT2_DEF_RESGID\t\t0\n\n/*\n * Default mount options\n */\n#define EXT2_DEFM_DEBUG\t\t0x0001\n#define EXT2_DEFM_BSDGROUPS\t0x0002\n#define EXT2_DEFM_XATTR_USER\t0x0004\n#define EXT2_DEFM_ACL\t\t0x0008\n#define EXT2_DEFM_UID16\t\t0x0010\n    /* Not used by ext2, but reserved for use by ext3 */\n#define EXT3_DEFM_JMODE\t\t0x0060 \n#define EXT3_DEFM_JMODE_DATA\t0x0020\n#define EXT3_DEFM_JMODE_ORDERED\t0x0040\n#define EXT3_DEFM_JMODE_WBACK\t0x0060\n\n/*\n * Structure of a directory entry\n */\n\nstruct ext2_dir_entry {\n\t__le32\tinode;\t\t\t/* Inode number */\n\t__le16\trec_len;\t\t/* Directory entry length */\n\t__le16\tname_len;\t\t/* Name length */\n\tchar\tname[];\t\t\t/* File name, up to EXT2_NAME_LEN */\n};\n\n/*\n * The new version of the directory entry.  Since EXT2 structures are\n * stored in intel byte order, and the name_len field could never be\n * bigger than 255 chars, it's safe to reclaim the extra byte for the\n * file_type field.\n */\nstruct ext2_dir_entry_2 {\n\t__le32\tinode;\t\t\t/* Inode number */\n\t__le16\trec_len;\t\t/* Directory entry length */\n\t__u8\tname_len;\t\t/* Name length */\n\t__u8\tfile_type;\n\tchar\tname[];\t\t\t/* File name, up to EXT2_NAME_LEN */\n};\n\n/*\n * Ext2 directory file types.  Only the low 3 bits are used.  The\n * other bits are reserved for now.\n */\nenum {\n\tEXT2_FT_UNKNOWN\t\t= 0,\n\tEXT2_FT_REG_FILE\t= 1,\n\tEXT2_FT_DIR\t\t= 2,\n\tEXT2_FT_CHRDEV\t\t= 3,\n\tEXT2_FT_BLKDEV\t\t= 4,\n\tEXT2_FT_FIFO\t\t= 5,\n\tEXT2_FT_SOCK\t\t= 6,\n\tEXT2_FT_SYMLINK\t\t= 7,\n\tEXT2_FT_MAX\n};\n\n/*\n * EXT2_DIR_PAD defines the directory entries boundaries\n *\n * NOTE: It must be a multiple of 4\n */\n#define EXT2_DIR_PAD\t\t \t4\n#define EXT2_DIR_ROUND \t\t\t(EXT2_DIR_PAD - 1)\n#define EXT2_DIR_REC_LEN(name_len)\t(((name_len) + 8 + EXT2_DIR_ROUND) & \\\n\t\t\t\t\t ~EXT2_DIR_ROUND)\n#define EXT2_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline void verify_offsets(void)\n{\n#define A(x,y) BUILD_BUG_ON(x != offsetof(struct ext2_super_block, y));\n\tA(EXT2_SB_MAGIC_OFFSET, s_magic);\n\tA(EXT2_SB_BLOCKS_OFFSET, s_blocks_count);\n\tA(EXT2_SB_BSIZE_OFFSET, s_log_block_size);\n#undef A\n}\n\n/*\n * ext2 mount options\n */\nstruct ext2_mount_options {\n\tunsigned long s_mount_opt;\n\tkuid_t s_resuid;\n\tkgid_t s_resgid;\n};\n\n/*\n * second extended file system inode data in memory\n */\nstruct ext2_inode_info {\n\t__le32\ti_data[15];\n\t__u32\ti_flags;\n\t__u32\ti_faddr;\n\t__u8\ti_frag_no;\n\t__u8\ti_frag_size;\n\t__u16\ti_state;\n\t__u32\ti_file_acl;\n\t__u32\ti_dir_acl;\n\t__u32\ti_dtime;\n\n\t/*\n\t * i_block_group is the number of the block group which contains\n\t * this file's inode.  Constant across the lifetime of the inode,\n\t * it is used for making block allocation decisions - we try to\n\t * place a file's data blocks near its inode block, and new inodes\n\t * near to their parent directory's inode.\n\t */\n\t__u32\ti_block_group;\n\n\t/* block reservation info */\n\tstruct ext2_block_alloc_info *i_block_alloc_info;\n\n\t__u32\ti_dir_start_lookup;\n#ifdef CONFIG_EXT2_FS_XATTR\n\t/*\n\t * Extended attributes can be read independently of the main file\n\t * data. Taking i_mutex even when reading would cause contention\n\t * between readers of EAs and writers of regular file data, so\n\t * instead we synchronize on xattr_sem when reading or changing\n\t * EAs.\n\t */\n\tstruct rw_semaphore xattr_sem;\n#endif\n\trwlock_t i_meta_lock;\n#ifdef CONFIG_FS_DAX\n\tstruct rw_semaphore dax_sem;\n#endif\n\n\t/*\n\t * truncate_mutex is for serialising ext2_truncate() against\n\t * ext2_getblock().  It also protects the internals of the inode's\n\t * reservation data structures: ext2_reserve_window and\n\t * ext2_reserve_window_node.\n\t */\n\tstruct mutex truncate_mutex;\n\tstruct inode\tvfs_inode;\n\tstruct list_head i_orphan;\t/* unlinked but open inodes */\n#ifdef CONFIG_QUOTA\n\tstruct dquot *i_dquot[MAXQUOTAS];\n#endif\n};\n\n#ifdef CONFIG_FS_DAX\n#define dax_sem_down_write(ext2_inode)\tdown_write(&(ext2_inode)->dax_sem)\n#define dax_sem_up_write(ext2_inode)\tup_write(&(ext2_inode)->dax_sem)\n#else\n#define dax_sem_down_write(ext2_inode)\n#define dax_sem_up_write(ext2_inode)\n#endif\n\n/*\n * Inode dynamic state flags\n */\n#define EXT2_STATE_NEW\t\t\t0x00000001 /* inode is newly created */\n\n\n/*\n * Function prototypes\n */\n\n/*\n * Ok, these declarations are also in <linux/kernel.h> but none of the\n * ext2 source programs needs to include it so they are duplicated here.\n */\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}\n\n/* balloc.c */\nextern int ext2_bg_has_super(struct super_block *sb, int group);\nextern unsigned long ext2_bg_num_gdb(struct super_block *sb, int group);\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern struct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t\t    unsigned int block_group,\n\t\t\t\t\t\t    struct buffer_head ** bh);\nextern void ext2_discard_reservation (struct inode *);\nextern int ext2_should_retry_alloc(struct super_block *sb, int *retries);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern void ext2_rsv_window_add(struct super_block *sb, struct ext2_reserve_window_node *rsv);\n\n/* dir.c */\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern ino_t ext2_inode_by_name(struct inode *, struct qstr *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern struct ext2_dir_entry_2 * ext2_find_entry (struct inode *,struct qstr *, struct page **);\nextern int ext2_delete_entry (struct ext2_dir_entry_2 *, struct page *);\nextern int ext2_empty_dir (struct inode *);\nextern struct ext2_dir_entry_2 * ext2_dotdot (struct inode *, struct page **);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\n\n/* ialloc.c */\nextern struct inode * ext2_new_inode (struct inode *, umode_t, const struct qstr *);\nextern void ext2_free_inode (struct inode *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern unsigned long ext2_count_free (struct buffer_head *, unsigned);\n\n/* inode.c */\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\nextern int ext2_write_inode (struct inode *, struct writeback_control *);\nextern void ext2_evict_inode(struct inode *);\nextern int ext2_get_block(struct inode *, sector_t, struct buffer_head *, int);\nextern int ext2_setattr (struct dentry *, struct iattr *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\nextern int ext2_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);\n\n/* ioctl.c */\nextern long ext2_ioctl(struct file *, unsigned int, unsigned long);\nextern long ext2_compat_ioctl(struct file *, unsigned int, unsigned long);\n\n/* namei.c */\nstruct dentry *ext2_get_parent(struct dentry *child);\n\n/* super.c */\nextern __printf(3, 4)\nvoid ext2_error(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext2_msg(struct super_block *, const char *, const char *, ...);\nextern void ext2_update_dynamic_rev (struct super_block *sb);\nextern void ext2_write_super (struct super_block *);\n\n/*\n * Inodes and files operations\n */\n\n/* dir.c */\nextern const struct file_operations ext2_dir_operations;\n\n/* file.c */\nextern int ext2_fsync(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync);\nextern const struct inode_operations ext2_file_inode_operations;\nextern const struct file_operations ext2_file_operations;\n\n/* inode.c */\nextern const struct address_space_operations ext2_aops;\nextern const struct address_space_operations ext2_nobh_aops;\n\n/* namei.c */\nextern const struct inode_operations ext2_dir_inode_operations;\nextern const struct inode_operations ext2_special_inode_operations;\n\n/* symlink.c */\nextern const struct inode_operations ext2_fast_symlink_inode_operations;\nextern const struct inode_operations ext2_symlink_inode_operations;\n\nstatic inline ext2_fsblk_t\next2_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext2_fsblk_t)EXT2_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT2_SB(sb)->s_es->s_first_data_block);\n}\n\n#define ext2_set_bit\t__test_and_set_bit_le\n#define ext2_clear_bit\t__test_and_clear_bit_le\n#define ext2_test_bit\ttest_bit_le\n#define ext2_find_first_zero_bit\tfind_first_zero_bit_le\n#define ext2_find_next_zero_bit\t\tfind_next_zero_bit_le\n", "/*\n *  linux/fs/ext2/super.c\n *\n * Copyright (C) 1992, 1993, 1994, 1995\n * Remy Card (card@masi.ibp.fr)\n * Laboratoire MASI - Institut Blaise Pascal\n * Universite Pierre et Marie Curie (Paris VI)\n *\n *  from\n *\n *  linux/fs/minix/inode.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n *\n *  Big-endian to little-endian byte-swapping/bitmaps by\n *        David S. Miller (davem@caip.rutgers.edu), 1995\n */\n\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/parser.h>\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/exportfs.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/quotaops.h>\n#include <asm/uaccess.h>\n#include \"ext2.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n\nstatic void ext2_sync_super(struct super_block *sb,\n\t\t\t    struct ext2_super_block *es, int wait);\nstatic int ext2_remount (struct super_block * sb, int * flags, char * data);\nstatic int ext2_statfs (struct dentry * dentry, struct kstatfs * buf);\nstatic int ext2_sync_fs(struct super_block *sb, int wait);\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}\n\nvoid ext2_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT2-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}\n\n/*\n * This must be called with sbi->s_lock held.\n */\nvoid ext2_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext2_super_block *es = EXT2_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT2_GOOD_OLD_REV)\n\t\treturn;\n\n\text2_msg(sb, KERN_WARNING,\n\t\t     \"warning: updating to rev %d because of \"\n\t\t     \"new feature flag, running e2fsck is recommended\",\n\t\t     EXT2_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT2_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT2_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT2_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}\n\nstatic void ext2_put_super (struct super_block * sb)\n{\n\tint db_count;\n\tint i;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\n\tif (sbi->s_mb_cache) {\n\t\text2_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tstruct ext2_super_block *es = sbi->s_es;\n\n\t\tspin_lock(&sbi->s_lock);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\tdb_count = sbi->s_gdb_count;\n\tfor (i = 0; i < db_count; i++)\n\t\tif (sbi->s_group_desc[i])\n\t\t\tbrelse (sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\n\tkfree(sbi->s_debts);\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tbrelse (sbi->s_sbh);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n}\n\nstatic struct kmem_cache * ext2_inode_cachep;\n\nstatic struct inode *ext2_alloc_inode(struct super_block *sb)\n{\n\tstruct ext2_inode_info *ei;\n\tei = kmem_cache_alloc(ext2_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\tei->i_block_alloc_info = NULL;\n\tei->vfs_inode.i_version = 1;\n#ifdef CONFIG_QUOTA\n\tmemset(&ei->i_dquot, 0, sizeof(ei->i_dquot));\n#endif\n\n\treturn &ei->vfs_inode;\n}\n\nstatic void ext2_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(ext2_inode_cachep, EXT2_I(inode));\n}\n\nstatic void ext2_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, ext2_i_callback);\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct ext2_inode_info *ei = (struct ext2_inode_info *) foo;\n\n\trwlock_init(&ei->i_meta_lock);\n#ifdef CONFIG_EXT2_FS_XATTR\n\tinit_rwsem(&ei->xattr_sem);\n#endif\n\tmutex_init(&ei->truncate_mutex);\n#ifdef CONFIG_FS_DAX\n\tinit_rwsem(&ei->dax_sem);\n#endif\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic int __init init_inodecache(void)\n{\n\text2_inode_cachep = kmem_cache_create(\"ext2_inode_cache\",\n\t\t\t\t\t     sizeof(struct ext2_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\t\t     init_once);\n\tif (ext2_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext2_inode_cachep);\n}\n\nstatic int ext2_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct super_block *sb = root->d_sb;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\tunsigned long def_mount_opts;\n\n\tspin_lock(&sbi->s_lock);\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\n\tif (sbi->s_sb_block != 1)\n\t\tseq_printf(seq, \",sb=%lu\", sbi->s_sb_block);\n\tif (test_opt(sb, MINIX_DF))\n\t\tseq_puts(seq, \",minixdf\");\n\tif (test_opt(sb, GRPID))\n\t\tseq_puts(seq, \",grpid\");\n\tif (!test_opt(sb, GRPID) && (def_mount_opts & EXT2_DEFM_BSDGROUPS))\n\t\tseq_puts(seq, \",nogrpid\");\n\tif (!uid_eq(sbi->s_resuid, make_kuid(&init_user_ns, EXT2_DEF_RESUID)) ||\n\t    le16_to_cpu(es->s_def_resuid) != EXT2_DEF_RESUID) {\n\t\tseq_printf(seq, \",resuid=%u\",\n\t\t\t\tfrom_kuid_munged(&init_user_ns, sbi->s_resuid));\n\t}\n\tif (!gid_eq(sbi->s_resgid, make_kgid(&init_user_ns, EXT2_DEF_RESGID)) ||\n\t    le16_to_cpu(es->s_def_resgid) != EXT2_DEF_RESGID) {\n\t\tseq_printf(seq, \",resgid=%u\",\n\t\t\t\tfrom_kgid_munged(&init_user_ns, sbi->s_resgid));\n\t}\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\tint def_errors = le16_to_cpu(es->s_errors);\n\n\t\tif (def_errors == EXT2_ERRORS_PANIC ||\n\t\t    def_errors == EXT2_ERRORS_CONTINUE) {\n\t\t\tseq_puts(seq, \",errors=remount-ro\");\n\t\t}\n\t}\n\tif (test_opt(sb, ERRORS_CONT))\n\t\tseq_puts(seq, \",errors=continue\");\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tseq_puts(seq, \",errors=panic\");\n\tif (test_opt(sb, NO_UID32))\n\t\tseq_puts(seq, \",nouid32\");\n\tif (test_opt(sb, DEBUG))\n\t\tseq_puts(seq, \",debug\");\n\tif (test_opt(sb, OLDALLOC))\n\t\tseq_puts(seq, \",oldalloc\");\n\n#ifdef CONFIG_EXT2_FS_XATTR\n\tif (test_opt(sb, XATTR_USER))\n\t\tseq_puts(seq, \",user_xattr\");\n\tif (!test_opt(sb, XATTR_USER) &&\n\t    (def_mount_opts & EXT2_DEFM_XATTR_USER)) {\n\t\tseq_puts(seq, \",nouser_xattr\");\n\t}\n#endif\n\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\tif (test_opt(sb, POSIX_ACL))\n\t\tseq_puts(seq, \",acl\");\n\tif (!test_opt(sb, POSIX_ACL) && (def_mount_opts & EXT2_DEFM_ACL))\n\t\tseq_puts(seq, \",noacl\");\n#endif\n\n\tif (test_opt(sb, NOBH))\n\t\tseq_puts(seq, \",nobh\");\n\n#if defined(CONFIG_QUOTA)\n\tif (sbi->s_mount_opt & EXT2_MOUNT_USRQUOTA)\n\t\tseq_puts(seq, \",usrquota\");\n\n\tif (sbi->s_mount_opt & EXT2_MOUNT_GRPQUOTA)\n\t\tseq_puts(seq, \",grpquota\");\n#endif\n\n#ifdef CONFIG_FS_DAX\n\tif (sbi->s_mount_opt & EXT2_MOUNT_XIP)\n\t\tseq_puts(seq, \",xip\");\n\tif (sbi->s_mount_opt & EXT2_MOUNT_DAX)\n\t\tseq_puts(seq, \",dax\");\n#endif\n\n\tif (!test_opt(sb, RESERVATION))\n\t\tseq_puts(seq, \",noreservation\");\n\n\tspin_unlock(&sbi->s_lock);\n\treturn 0;\n}\n\n#ifdef CONFIG_QUOTA\nstatic ssize_t ext2_quota_read(struct super_block *sb, int type, char *data, size_t len, loff_t off);\nstatic ssize_t ext2_quota_write(struct super_block *sb, int type, const char *data, size_t len, loff_t off);\nstatic struct dquot **ext2_get_dquots(struct inode *inode)\n{\n\treturn EXT2_I(inode)->i_dquot;\n}\n#endif\n\nstatic const struct super_operations ext2_sops = {\n\t.alloc_inode\t= ext2_alloc_inode,\n\t.destroy_inode\t= ext2_destroy_inode,\n\t.write_inode\t= ext2_write_inode,\n\t.evict_inode\t= ext2_evict_inode,\n\t.put_super\t= ext2_put_super,\n\t.sync_fs\t= ext2_sync_fs,\n\t.freeze_fs\t= ext2_freeze,\n\t.unfreeze_fs\t= ext2_unfreeze,\n\t.statfs\t\t= ext2_statfs,\n\t.remount_fs\t= ext2_remount,\n\t.show_options\t= ext2_show_options,\n#ifdef CONFIG_QUOTA\n\t.quota_read\t= ext2_quota_read,\n\t.quota_write\t= ext2_quota_write,\n\t.get_dquots\t= ext2_get_dquots,\n#endif\n};\n\nstatic struct inode *ext2_nfs_get_inode(struct super_block *sb,\n\t\tu64 ino, u32 generation)\n{\n\tstruct inode *inode;\n\n\tif (ino < EXT2_FIRST_INO(sb) && ino != EXT2_ROOT_INO)\n\t\treturn ERR_PTR(-ESTALE);\n\tif (ino > le32_to_cpu(EXT2_SB(sb)->s_es->s_inodes_count))\n\t\treturn ERR_PTR(-ESTALE);\n\n\t/*\n\t * ext2_iget isn't quite right if the inode is currently unallocated!\n\t * However ext2_iget currently does appropriate checks to handle stale\n\t * inodes so everything is OK.\n\t */\n\tinode = ext2_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (generation && inode->i_generation != generation) {\n\t\t/* we didn't find the right inode.. */\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\treturn inode;\n}\n\nstatic struct dentry *ext2_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext2_nfs_get_inode);\n}\n\nstatic struct dentry *ext2_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext2_nfs_get_inode);\n}\n\nstatic const struct export_operations ext2_export_ops = {\n\t.fh_to_dentry = ext2_fh_to_dentry,\n\t.fh_to_parent = ext2_fh_to_parent,\n\t.get_parent = ext2_get_parent,\n};\n\nstatic unsigned long get_sb_block(void **data)\n{\n\tunsigned long \tsb_block;\n\tchar \t\t*options = (char *) *data;\n\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t/* Default location */\n\toptions += 3;\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\tprintk(\"EXT2-fs: Invalid sb specification: %s\\n\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\treturn sb_block;\n}\n\nenum {\n\tOpt_bsd_df, Opt_minix_df, Opt_grpid, Opt_nogrpid,\n\tOpt_resgid, Opt_resuid, Opt_sb, Opt_err_cont, Opt_err_panic,\n\tOpt_err_ro, Opt_nouid32, Opt_nocheck, Opt_debug,\n\tOpt_oldalloc, Opt_orlov, Opt_nobh, Opt_user_xattr, Opt_nouser_xattr,\n\tOpt_acl, Opt_noacl, Opt_xip, Opt_dax, Opt_ignore, Opt_err, Opt_quota,\n\tOpt_usrquota, Opt_grpquota, Opt_reservation, Opt_noreservation\n};\n\nstatic const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_nocheck, \"check=none\"},\n\t{Opt_nocheck, \"nocheck\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_oldalloc, \"oldalloc\"},\n\t{Opt_orlov, \"orlov\"},\n\t{Opt_nobh, \"nobh\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_xip, \"xip\"},\n\t{Opt_dax, \"dax\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_ignore, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_reservation, \"reservation\"},\n\t{Opt_noreservation, \"noreservation\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(char *options, struct super_block *sb)\n{\n\tchar *p;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep (&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_bsd_df:\n\t\t\tclear_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_minix_df:\n\t\t\tset_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_grpid:\n\t\t\tset_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_nogrpid:\n\t\t\tclear_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_resuid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid)) {\n\t\t\t\text2_msg(sb, KERN_ERR, \"Invalid uid value %d\", option);\n\t\t\t\treturn 0;\n\n\t\t\t}\n\t\t\tsbi->s_resuid = uid;\n\t\t\tbreak;\n\t\tcase Opt_resgid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid)) {\n\t\t\t\text2_msg(sb, KERN_ERR, \"Invalid gid value %d\", option);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_resgid = gid;\n\t\t\tbreak;\n\t\tcase Opt_sb:\n\t\t\t/* handled by get_sb_block() instead of here */\n\t\t\t/* *sb_block = match_int(&args[0]); */\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tbreak;\n\t\tcase Opt_nouid32:\n\t\t\tset_opt (sbi->s_mount_opt, NO_UID32);\n\t\t\tbreak;\n\t\tcase Opt_nocheck:\n\t\t\tclear_opt (sbi->s_mount_opt, CHECK);\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\tset_opt (sbi->s_mount_opt, DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_oldalloc:\n\t\t\tset_opt (sbi->s_mount_opt, OLDALLOC);\n\t\t\tbreak;\n\t\tcase Opt_orlov:\n\t\t\tclear_opt (sbi->s_mount_opt, OLDALLOC);\n\t\t\tbreak;\n\t\tcase Opt_nobh:\n\t\t\tset_opt (sbi->s_mount_opt, NOBH);\n\t\t\tbreak;\n#ifdef CONFIG_EXT2_FS_XATTR\n\t\tcase Opt_user_xattr:\n\t\t\tset_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tclear_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n#else\n\t\tcase Opt_user_xattr:\n\t\tcase Opt_nouser_xattr:\n\t\t\text2_msg(sb, KERN_INFO, \"(no)user_xattr options\"\n\t\t\t\t\"not supported\");\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\t\tcase Opt_acl:\n\t\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tclear_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n#else\n\t\tcase Opt_acl:\n\t\tcase Opt_noacl:\n\t\t\text2_msg(sb, KERN_INFO,\n\t\t\t\t\"(no)acl options not supported\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_xip:\n\t\t\text2_msg(sb, KERN_INFO, \"use dax instead of xip\");\n\t\t\tset_opt(sbi->s_mount_opt, XIP);\n\t\t\t/* Fall through */\n\t\tcase Opt_dax:\n#ifdef CONFIG_FS_DAX\n\t\t\text2_msg(sb, KERN_WARNING,\n\t\t\"DAX enabled. Warning: EXPERIMENTAL, use at your own risk\");\n\t\t\tset_opt(sbi->s_mount_opt, DAX);\n#else\n\t\t\text2_msg(sb, KERN_INFO, \"dax option not supported\");\n#endif\n\t\t\tbreak;\n\n#if defined(CONFIG_QUOTA)\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\t\tset_opt(sbi->s_mount_opt, USRQUOTA);\n\t\t\tbreak;\n\n\t\tcase Opt_grpquota:\n\t\t\tset_opt(sbi->s_mount_opt, GRPQUOTA);\n\t\t\tbreak;\n#else\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\tcase Opt_grpquota:\n\t\t\text2_msg(sb, KERN_INFO,\n\t\t\t\t\"quota operations not supported\");\n\t\t\tbreak;\n#endif\n\n\t\tcase Opt_reservation:\n\t\t\tset_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\text2_msg(sb, KERN_INFO, \"reservations ON\");\n\t\t\tbreak;\n\t\tcase Opt_noreservation:\n\t\t\tclear_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\text2_msg(sb, KERN_INFO, \"reservations OFF\");\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int ext2_setup_super (struct super_block * sb,\n\t\t\t      struct ext2_super_block * es,\n\t\t\t      int read_only)\n{\n\tint res = 0;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT2_MAX_SUPP_REV) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: revision level too high, \"\n\t\t\t\"forcing read-only mode\");\n\t\tres = MS_RDONLY;\n\t}\n\tif (read_only)\n\t\treturn res;\n\tif (!(sbi->s_mount_state & EXT2_VALID_FS))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting unchecked fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((sbi->s_mount_state & EXT2_ERROR_FS))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting fs with errors, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) >= 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t (unsigned short) (__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: maximal mount count reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t(le32_to_cpu(es->s_lastcheck) +\n\t\t\tle32_to_cpu(es->s_checkinterval) <= get_seconds()))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: checktime reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\tif (!le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT2_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\tif (test_opt (sb, DEBUG))\n\t\text2_msg(sb, KERN_INFO, \"%s, %s, bs=%lu, fs=%lu, gc=%lu, \"\n\t\t\t\"bpg=%lu, ipg=%lu, mo=%04lx]\",\n\t\t\tEXT2FS_VERSION, EXT2FS_DATE, sb->s_blocksize,\n\t\t\tsbi->s_frag_size,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT2_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT2_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt);\n\treturn res;\n}\n\nstatic int ext2_check_descriptors(struct super_block *sb)\n{\n\tint i;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\text2_debug (\"Checking group descriptors\");\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tstruct ext2_group_desc *gdp = ext2_get_group_desc(sb, i, NULL);\n\t\text2_fsblk_t first_block = ext2_group_first_block_no(sb, i);\n\t\text2_fsblk_t last_block;\n\n\t\tif (i == sbi->s_groups_count - 1)\n\t\t\tlast_block = le32_to_cpu(sbi->s_es->s_blocks_count) - 1;\n\t\telse\n\t\t\tlast_block = first_block +\n\t\t\t\t(EXT2_BLOCKS_PER_GROUP(sb) - 1);\n\n\t\tif (le32_to_cpu(gdp->bg_block_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_block_bitmap) > last_block)\n\t\t{\n\t\t\text2_error (sb, \"ext2_check_descriptors\",\n\t\t\t\t    \"Block bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long) le32_to_cpu(gdp->bg_block_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_bitmap) > last_block)\n\t\t{\n\t\t\text2_error (sb, \"ext2_check_descriptors\",\n\t\t\t\t    \"Inode bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long) le32_to_cpu(gdp->bg_inode_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_table) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_table) + sbi->s_itb_per_group - 1 >\n\t\t    last_block)\n\t\t{\n\t\t\text2_error (sb, \"ext2_check_descriptors\",\n\t\t\t\t    \"Inode table for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long) le32_to_cpu(gdp->bg_inode_table));\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\n/*\n * Maximal file size.  There is a direct, and {,double-,triple-}indirect\n * block limit, and also a limit of (2^32 - 1) 512-byte sectors in i_blocks.\n * We need to be 1 filesystem block less than the 2^32 sector limit.\n */\nstatic loff_t ext2_max_size(int bits)\n{\n\tloff_t res = EXT2_NDIR_BLOCKS;\n\tint meta_blocks;\n\tloff_t upper_limit;\n\n\t/* This is calculated to be the largest file size for a\n\t * dense, file such that the total number of\n\t * sectors in the file, including data and all indirect blocks,\n\t * does not exceed 2^32 -1\n\t * __u32 i_blocks representing the total number of\n\t * 512 bytes blocks of the file\n\t */\n\tupper_limit = (1LL << 32) - 1;\n\n\t/* total blocks in file system block size */\n\tupper_limit >>= (bits - 9);\n\n\n\t/* indirect blocks */\n\tmeta_blocks = 1;\n\t/* double indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2));\n\t/* tripple indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2)) + (1LL << (2*(bits-2)));\n\n\tupper_limit -= meta_blocks;\n\tupper_limit <<= bits;\n\n\tres += 1LL << (bits-2);\n\tres += 1LL << (2*(bits-2));\n\tres += 1LL << (3*(bits-2));\n\tres <<= bits;\n\tif (res > upper_limit)\n\t\tres = upper_limit;\n\n\tif (res > MAX_LFS_FILESIZE)\n\t\tres = MAX_LFS_FILESIZE;\n\n\treturn res;\n}\n\nstatic unsigned long descriptor_loc(struct super_block *sb,\n\t\t\t\t    unsigned long logic_sb_block,\n\t\t\t\t    int nr)\n{\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tunsigned long bg, first_meta_bg;\n\tint has_super = 0;\n\t\n\tfirst_meta_bg = le32_to_cpu(sbi->s_es->s_first_meta_bg);\n\n\tif (!EXT2_HAS_INCOMPAT_FEATURE(sb, EXT2_FEATURE_INCOMPAT_META_BG) ||\n\t    nr < first_meta_bg)\n\t\treturn (logic_sb_block + nr + 1);\n\tbg = sbi->s_desc_per_block * nr;\n\tif (ext2_bg_has_super(sb, bg))\n\t\thas_super = 1;\n\n\treturn ext2_group_first_block_no(sb, bg) + has_super;\n}\n\nstatic int ext2_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct buffer_head * bh;\n\tstruct ext2_sb_info * sbi;\n\tstruct ext2_super_block * es;\n\tstruct inode *root;\n\tunsigned long block;\n\tunsigned long sb_block = get_sb_block(&data);\n\tunsigned long logic_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long def_mount_opts;\n\tlong ret = -EINVAL;\n\tint blocksize = BLOCK_SIZE;\n\tint db_count;\n\tint i, j;\n\t__le32 features;\n\tint err;\n\n\terr = -ENOMEM;\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\tgoto failed;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock) {\n\t\tkfree(sbi);\n\t\tgoto failed;\n\t}\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb_block = sb_block;\n\n\tspin_lock_init(&sbi->s_lock);\n\n\t/*\n\t * See what the current blocksize for the device is, and\n\t * use that as the blocksize.  Otherwise (or if the blocksize\n\t * is smaller than the default) use the default.\n\t * This is important for devices that have a hardware\n\t * sectorsize that is larger than the default.\n\t */\n\tblocksize = sb_min_blocksize(sb, BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text2_msg(sb, KERN_ERR, \"error: unable to set blocksize\");\n\t\tgoto failed_sbi;\n\t}\n\n\t/*\n\t * If the superblock doesn't start on a hardware sector boundary,\n\t * calculate the offset.  \n\t */\n\tif (blocksize != BLOCK_SIZE) {\n\t\tlogic_sb_block = (sb_block*BLOCK_SIZE) / blocksize;\n\t\toffset = (sb_block*BLOCK_SIZE) % blocksize;\n\t} else {\n\t\tlogic_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread(sb, logic_sb_block))) {\n\t\text2_msg(sb, KERN_ERR, \"error: unable to read superblock\");\n\t\tgoto failed_sbi;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext2 macro-instructions depend on its value\n\t */\n\tes = (struct ext2_super_block *) (((char *)bh->b_data) + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\n\tif (sb->s_magic != EXT2_SUPER_MAGIC)\n\t\tgoto cantfind_ext2;\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tif (def_mount_opts & EXT2_DEFM_DEBUG)\n\t\tset_opt(sbi->s_mount_opt, DEBUG);\n\tif (def_mount_opts & EXT2_DEFM_BSDGROUPS)\n\t\tset_opt(sbi->s_mount_opt, GRPID);\n\tif (def_mount_opts & EXT2_DEFM_UID16)\n\t\tset_opt(sbi->s_mount_opt, NO_UID32);\n#ifdef CONFIG_EXT2_FS_XATTR\n\tif (def_mount_opts & EXT2_DEFM_XATTR_USER)\n\t\tset_opt(sbi->s_mount_opt, XATTR_USER);\n#endif\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\tif (def_mount_opts & EXT2_DEFM_ACL)\n\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n#endif\n\t\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT2_ERRORS_PANIC)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT2_ERRORS_CONTINUE)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_CONT);\n\telse\n\t\tset_opt(sbi->s_mount_opt, ERRORS_RO);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\t\n\tset_opt(sbi->s_mount_opt, RESERVATION);\n\n\tif (!parse_options((char *) data, sb))\n\t\tgoto failed_mount;\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t((EXT2_SB(sb)->s_mount_opt & EXT2_MOUNT_POSIX_ACL) ?\n\t\t MS_POSIXACL : 0);\n\tsb->s_iflags |= SB_I_CGROUPWB;\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT2_GOOD_OLD_REV &&\n\t    (EXT2_HAS_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT2_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT2_HAS_INCOMPAT_FEATURE(sb, ~0U)))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: feature flags set on rev 0 fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tfeatures = EXT2_HAS_INCOMPAT_FEATURE(sb, ~EXT2_FEATURE_INCOMPAT_SUPP);\n\tif (features) {\n\t\text2_msg(sb, KERN_ERR,\t\"error: couldn't mount because of \"\n\t\t       \"unsupported optional features (%x)\",\n\t\t\tle32_to_cpu(features));\n\t\tgoto failed_mount;\n\t}\n\tif (!(sb->s_flags & MS_RDONLY) &&\n\t    (features = EXT2_HAS_RO_COMPAT_FEATURE(sb, ~EXT2_FEATURE_RO_COMPAT_SUPP))){\n\t\text2_msg(sb, KERN_ERR, \"error: couldn't mount RDWR because of \"\n\t\t       \"unsupported optional features (%x)\",\n\t\t       le32_to_cpu(features));\n\t\tgoto failed_mount;\n\t}\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(sbi->s_es->s_log_block_size);\n\n\tif (sbi->s_mount_opt & EXT2_MOUNT_DAX) {\n\t\tif (blocksize != PAGE_SIZE) {\n\t\t\text2_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: unsupported blocksize for dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (!sb->s_bdev->bd_disk->fops->direct_access) {\n\t\t\text2_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: device does not support dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* If the blocksize doesn't match, re-read the thing.. */\n\tif (sb->s_blocksize != blocksize) {\n\t\tbrelse(bh);\n\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text2_msg(sb, KERN_ERR,\n\t\t\t\t\"error: bad blocksize %d\", blocksize);\n\t\t\tgoto failed_sbi;\n\t\t}\n\n\t\tlogic_sb_block = (sb_block*BLOCK_SIZE) / blocksize;\n\t\toffset = (sb_block*BLOCK_SIZE) % blocksize;\n\t\tbh = sb_bread(sb, logic_sb_block);\n\t\tif(!bh) {\n\t\t\text2_msg(sb, KERN_ERR, \"error: couldn't read\"\n\t\t\t\t\"superblock on 2nd try\");\n\t\t\tgoto failed_sbi;\n\t\t}\n\t\tes = (struct ext2_super_block *) (((char *)bh->b_data) + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT2_SUPER_MAGIC)) {\n\t\t\text2_msg(sb, KERN_ERR, \"error: magic mismatch\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tsb->s_maxbytes = ext2_max_size(sb->s_blocksize_bits);\n\tsb->s_max_links = EXT2_LINK_MAX;\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT2_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT2_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT2_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT2_GOOD_OLD_INODE_SIZE) ||\n\t\t    !is_power_of_2(sbi->s_inode_size) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text2_msg(sb, KERN_ERR,\n\t\t\t\t\"error: unsupported inode size: %d\",\n\t\t\t\tsbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tsbi->s_frag_size = EXT2_MIN_FRAG_SIZE <<\n\t\t\t\t   le32_to_cpu(es->s_log_frag_size);\n\tif (sbi->s_frag_size == 0)\n\t\tgoto cantfind_ext2;\n\tsbi->s_frags_per_block = sb->s_blocksize / sbi->s_frag_size;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_frags_per_group = le32_to_cpu(es->s_frags_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tif (EXT2_INODE_SIZE(sb) == 0)\n\t\tgoto cantfind_ext2;\n\tsbi->s_inodes_per_block = sb->s_blocksize / EXT2_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0 || sbi->s_inodes_per_group == 0)\n\t\tgoto cantfind_ext2;\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = sb->s_blocksize /\n\t\t\t\t\tsizeof (struct ext2_group_desc);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits =\n\t\tilog2 (EXT2_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits =\n\t\tilog2 (EXT2_DESC_PER_BLOCK(sb));\n\n\tif (sb->s_magic != EXT2_SUPER_MAGIC)\n\t\tgoto cantfind_ext2;\n\n\tif (sb->s_blocksize != bh->b_size) {\n\t\tif (!silent)\n\t\t\text2_msg(sb, KERN_ERR, \"error: unsupported blocksize\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != sbi->s_frag_size) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: fragsize %lu != blocksize %lu\"\n\t\t\t\"(not supported yet)\",\n\t\t\tsbi->s_frag_size, sb->s_blocksize);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_blocks_per_group > sb->s_blocksize * 8) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: #blocks per group too big: %lu\",\n\t\t\tsbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_frags_per_group > sb->s_blocksize * 8) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: #fragments per group too big: %lu\",\n\t\t\tsbi->s_frags_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_inodes_per_group > sb->s_blocksize * 8) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: #inodes per group too big: %lu\",\n\t\t\tsbi->s_inodes_per_group);\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT2_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext2;\n \tsbi->s_groups_count = ((le32_to_cpu(es->s_blocks_count) -\n \t\t\t\tle32_to_cpu(es->s_first_data_block) - 1)\n \t\t\t\t\t/ EXT2_BLOCKS_PER_GROUP(sb)) + 1;\n\tdb_count = (sbi->s_groups_count + EXT2_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT2_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = kmalloc (db_count * sizeof (struct buffer_head *), GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text2_msg(sb, KERN_ERR, \"error: not enough memory\");\n\t\tgoto failed_mount;\n\t}\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\tsbi->s_debts = kcalloc(sbi->s_groups_count, sizeof(*sbi->s_debts), GFP_KERNEL);\n\tif (!sbi->s_debts) {\n\t\text2_msg(sb, KERN_ERR, \"error: not enough memory\");\n\t\tgoto failed_mount_group_desc;\n\t}\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logic_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tbrelse (sbi->s_group_desc[j]);\n\t\t\text2_msg(sb, KERN_ERR,\n\t\t\t\t\"error: unable to read group descriptors\");\n\t\t\tgoto failed_mount_group_desc;\n\t\t}\n\t}\n\tif (!ext2_check_descriptors (sb)) {\n\t\text2_msg(sb, KERN_ERR, \"group descriptors corrupted\");\n\t\tgoto failed_mount2;\n\t}\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\t/* per fileystem reservation list head & lock */\n\tspin_lock_init(&sbi->s_rsv_window_lock);\n\tsbi->s_rsv_window_root = RB_ROOT;\n\t/*\n\t * Add a single, static dummy reservation to the start of the\n\t * reservation window list --- it gives us a placeholder for\n\t * append-at-start-of-list which makes the allocation logic\n\t * _much_ simpler.\n\t */\n\tsbi->s_rsv_window_head.rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\tsbi->s_rsv_window_head.rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\tsbi->s_rsv_window_head.rsv_alloc_hit = 0;\n\tsbi->s_rsv_window_head.rsv_goal_size = 0;\n\text2_rsv_window_add(sb, &sbi->s_rsv_window_head);\n\n\terr = percpu_counter_init(&sbi->s_freeblocks_counter,\n\t\t\t\text2_count_free_blocks(sb), GFP_KERNEL);\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter,\n\t\t\t\text2_count_free_inodes(sb), GFP_KERNEL);\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\text2_count_dirs(sb), GFP_KERNEL);\n\t}\n\tif (err) {\n\t\text2_msg(sb, KERN_ERR, \"error: insufficient memory\");\n\t\tgoto failed_mount3;\n\t}\n\n#ifdef CONFIG_EXT2_FS_XATTR\n\tsbi->s_mb_cache = ext2_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text2_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount3;\n\t}\n#endif\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext2_sops;\n\tsb->s_export_op = &ext2_export_ops;\n\tsb->s_xattr = ext2_xattr_handlers;\n\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &dquot_operations;\n\tsb->s_qcop = &dquot_quotactl_ops;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n#endif\n\n\troot = ext2_iget(sb, EXT2_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\tret = PTR_ERR(root);\n\t\tgoto failed_mount3;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\tiput(root);\n\t\text2_msg(sb, KERN_ERR, \"error: corrupt root inode, run e2fsck\");\n\t\tgoto failed_mount3;\n\t}\n\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text2_msg(sb, KERN_ERR, \"error: get root inode failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount3;\n\t}\n\tif (EXT2_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_HAS_JOURNAL))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting ext3 filesystem as ext2\");\n\tif (ext2_setup_super (sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\text2_write_super(sb);\n\treturn 0;\n\ncantfind_ext2:\n\tif (!silent)\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: can't find an ext2 filesystem on dev %s.\",\n\t\t\tsb->s_id);\n\tgoto failed_mount;\nfailed_mount3:\n\tif (sbi->s_mb_cache)\n\t\text2_xattr_destroy_cache(sbi->s_mb_cache);\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\nfailed_mount_group_desc:\n\tkfree(sbi->s_group_desc);\n\tkfree(sbi->s_debts);\nfailed_mount:\n\tbrelse(bh);\nfailed_sbi:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\nfailed:\n\treturn ret;\n}\n\nstatic void ext2_clear_super_error(struct super_block *sb)\n{\n\tstruct buffer_head *sbh = EXT2_SB(sb)->s_sbh;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text2_msg(sb, KERN_ERR,\n\t\t       \"previous I/O error to superblock detected\\n\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n}\n\nstatic void ext2_sync_super(struct super_block *sb, struct ext2_super_block *es,\n\t\t\t    int wait)\n{\n\text2_clear_super_error(sb);\n\tspin_lock(&EXT2_SB(sb)->s_lock);\n\tes->s_free_blocks_count = cpu_to_le32(ext2_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext2_count_free_inodes(sb));\n\tes->s_wtime = cpu_to_le32(get_seconds());\n\t/* unlock before we do IO */\n\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\tmark_buffer_dirty(EXT2_SB(sb)->s_sbh);\n\tif (wait)\n\t\tsync_dirty_buffer(EXT2_SB(sb)->s_sbh);\n}\n\n/*\n * In the second extended file system, it is not necessary to\n * write the super block since we use a mapping of the\n * disk super block in a buffer.\n *\n * However, this function is still used to set the fs valid\n * flags to 0.  We need to set this flag to 0 since the fs\n * may have been checked while mounted and e2fsck may have\n * set s_state to EXT2_VALID_FS after some corrections.\n */\nstatic int ext2_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = EXT2_SB(sb)->s_es;\n\n\t/*\n\t * Write quota structures to quota file, sync_blockdev() will write\n\t * them to disk later\n\t */\n\tdquot_writeback_dquots(sb, -1);\n\n\tspin_lock(&sbi->s_lock);\n\tif (es->s_state & cpu_to_le16(EXT2_VALID_FS)) {\n\t\text2_debug(\"setting valid to 0\\n\");\n\t\tes->s_state &= cpu_to_le16(~EXT2_VALID_FS);\n\t}\n\tspin_unlock(&sbi->s_lock);\n\text2_sync_super(sb, es, wait);\n\treturn 0;\n}\n\nstatic int ext2_freeze(struct super_block *sb)\n{\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\t/*\n\t * Open but unlinked files present? Keep EXT2_VALID_FS flag cleared\n\t * because we have unattached inodes and thus filesystem is not fully\n\t * consistent.\n\t */\n\tif (atomic_long_read(&sb->s_remove_count)) {\n\t\text2_sync_fs(sb, 1);\n\t\treturn 0;\n\t}\n\t/* Set EXT2_FS_VALID flag */\n\tspin_lock(&sbi->s_lock);\n\tsbi->s_es->s_state = cpu_to_le16(sbi->s_mount_state);\n\tspin_unlock(&sbi->s_lock);\n\text2_sync_super(sb, sbi->s_es, 1);\n\n\treturn 0;\n}\n\nstatic int ext2_unfreeze(struct super_block *sb)\n{\n\t/* Just write sb to clear EXT2_VALID_FS flag */\n\text2_write_super(sb);\n\n\treturn 0;\n}\n\nvoid ext2_write_super(struct super_block *sb)\n{\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\text2_sync_fs(sb, 1);\n}\n\nstatic int ext2_remount (struct super_block * sb, int * flags, char * data)\n{\n\tstruct ext2_sb_info * sbi = EXT2_SB(sb);\n\tstruct ext2_super_block * es;\n\tstruct ext2_mount_options old_opts;\n\tunsigned long old_sb_flags;\n\tint err;\n\n\tsync_filesystem(sb);\n\tspin_lock(&sbi->s_lock);\n\n\t/* Store the old options */\n\told_sb_flags = sb->s_flags;\n\told_opts.s_mount_opt = sbi->s_mount_opt;\n\told_opts.s_resuid = sbi->s_resuid;\n\told_opts.s_resgid = sbi->s_resgid;\n\n\t/*\n\t * Allow the \"check\" option to be passed as a remount option.\n\t */\n\tif (!parse_options(data, sb)) {\n\t\terr = -EINVAL;\n\t\tgoto restore_opts;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t((sbi->s_mount_opt & EXT2_MOUNT_POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tes = sbi->s_es;\n\tif ((sbi->s_mount_opt ^ old_opts.s_mount_opt) & EXT2_MOUNT_DAX) {\n\t\text2_msg(sb, KERN_WARNING, \"warning: refusing change of \"\n\t\t\t \"dax flag with busy inodes while remounting\");\n\t\tsbi->s_mount_opt ^= EXT2_MOUNT_DAX;\n\t}\n\tif ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY)) {\n\t\tspin_unlock(&sbi->s_lock);\n\t\treturn 0;\n\t}\n\tif (*flags & MS_RDONLY) {\n\t\tif (le16_to_cpu(es->s_state) & EXT2_VALID_FS ||\n\t\t    !(sbi->s_mount_state & EXT2_VALID_FS)) {\n\t\t\tspin_unlock(&sbi->s_lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * OK, we are remounting a valid rw partition rdonly, so set\n\t\t * the rdonly flag and then mark the partition as valid again.\n\t\t */\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tes->s_mtime = cpu_to_le32(get_seconds());\n\t\tspin_unlock(&sbi->s_lock);\n\n\t\terr = dquot_suspend(sb, -1);\n\t\tif (err < 0) {\n\t\t\tspin_lock(&sbi->s_lock);\n\t\t\tgoto restore_opts;\n\t\t}\n\n\t\text2_sync_super(sb, es, 1);\n\t} else {\n\t\t__le32 ret = EXT2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t       ~EXT2_FEATURE_RO_COMPAT_SUPP);\n\t\tif (ret) {\n\t\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\t\"warning: couldn't remount RDWR because of \"\n\t\t\t\t\"unsupported optional features (%x).\",\n\t\t\t\tle32_to_cpu(ret));\n\t\t\terr = -EROFS;\n\t\t\tgoto restore_opts;\n\t\t}\n\t\t/*\n\t\t * Mounting a RDONLY partition read-write, so reread and\n\t\t * store the current valid flag.  (It may have been changed\n\t\t * by e2fsck since we originally mounted the partition.)\n\t\t */\n\t\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\t\tif (!ext2_setup_super (sb, es, 0))\n\t\t\tsb->s_flags &= ~MS_RDONLY;\n\t\tspin_unlock(&sbi->s_lock);\n\n\t\text2_write_super(sb);\n\n\t\tdquot_resume(sb, -1);\n\t}\n\n\treturn 0;\nrestore_opts:\n\tsbi->s_mount_opt = old_opts.s_mount_opt;\n\tsbi->s_resuid = old_opts.s_resuid;\n\tsbi->s_resgid = old_opts.s_resgid;\n\tsb->s_flags = old_sb_flags;\n\tspin_unlock(&sbi->s_lock);\n\treturn err;\n}\n\nstatic int ext2_statfs (struct dentry * dentry, struct kstatfs * buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\tu64 fsid;\n\n\tspin_lock(&sbi->s_lock);\n\n\tif (test_opt (sb, MINIX_DF))\n\t\tsbi->s_overhead_last = 0;\n\telse if (sbi->s_blocks_last != le32_to_cpu(es->s_blocks_count)) {\n\t\tunsigned long i, overhead = 0;\n\t\tsmp_rmb();\n\n\t\t/*\n\t\t * Compute the overhead (FS structures). This is constant\n\t\t * for a given filesystem unless the number of block groups\n\t\t * changes so we cache the previous value until it does.\n\t\t */\n\n\t\t/*\n\t\t * All of the blocks before first_data_block are\n\t\t * overhead\n\t\t */\n\t\toverhead = le32_to_cpu(es->s_first_data_block);\n\n\t\t/*\n\t\t * Add the overhead attributed to the superblock and\n\t\t * block group descriptors.  If the sparse superblocks\n\t\t * feature is turned on, then not all groups have this.\n\t\t */\n\t\tfor (i = 0; i < sbi->s_groups_count; i++)\n\t\t\toverhead += ext2_bg_has_super(sb, i) +\n\t\t\t\text2_bg_num_gdb(sb, i);\n\n\t\t/*\n\t\t * Every block group has an inode bitmap, a block\n\t\t * bitmap, and an inode table.\n\t\t */\n\t\toverhead += (sbi->s_groups_count *\n\t\t\t     (2 + sbi->s_itb_per_group));\n\t\tsbi->s_overhead_last = overhead;\n\t\tsmp_wmb();\n\t\tsbi->s_blocks_last = le32_to_cpu(es->s_blocks_count);\n\t}\n\n\tbuf->f_type = EXT2_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = le32_to_cpu(es->s_blocks_count) - sbi->s_overhead_last;\n\tbuf->f_bfree = ext2_count_free_blocks(sb);\n\tes->s_free_blocks_count = cpu_to_le32(buf->f_bfree);\n\tbuf->f_bavail = buf->f_bfree - le32_to_cpu(es->s_r_blocks_count);\n\tif (buf->f_bfree < le32_to_cpu(es->s_r_blocks_count))\n\t\tbuf->f_bavail = 0;\n\tbuf->f_files = le32_to_cpu(es->s_inodes_count);\n\tbuf->f_ffree = ext2_count_free_inodes(sb);\n\tes->s_free_inodes_count = cpu_to_le32(buf->f_ffree);\n\tbuf->f_namelen = EXT2_NAME_LEN;\n\tfsid = le64_to_cpup((void *)es->s_uuid) ^\n\t       le64_to_cpup((void *)es->s_uuid + sizeof(u64));\n\tbuf->f_fsid.val[0] = fsid & 0xFFFFFFFFUL;\n\tbuf->f_fsid.val[1] = (fsid >> 32) & 0xFFFFFFFFUL;\n\tspin_unlock(&sbi->s_lock);\n\treturn 0;\n}\n\nstatic struct dentry *ext2_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, ext2_fill_super);\n}\n\n#ifdef CONFIG_QUOTA\n\n/* Read data from quotafile - avoid pagecache and such because we cannot afford\n * acquiring the locks... As quota files are never truncated and quota code\n * itself serializes the operations (and no one else should touch the files)\n * we don't have to be afraid of races */\nstatic ssize_t ext2_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t       size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> EXT2_BLOCK_SIZE_BITS(sb);\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint tocopy;\n\tsize_t toread;\n\tstruct buffer_head tmp_bh;\n\tstruct buffer_head *bh;\n\tloff_t i_size = i_size_read(inode);\n\n\tif (off > i_size)\n\t\treturn 0;\n\tif (off+len > i_size)\n\t\tlen = i_size-off;\n\ttoread = len;\n\twhile (toread > 0) {\n\t\ttocopy = sb->s_blocksize - offset < toread ?\n\t\t\t\tsb->s_blocksize - offset : toread;\n\n\t\ttmp_bh.b_state = 0;\n\t\ttmp_bh.b_size = sb->s_blocksize;\n\t\terr = ext2_get_block(inode, blk, &tmp_bh, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (!buffer_mapped(&tmp_bh))\t/* A hole? */\n\t\t\tmemset(data, 0, tocopy);\n\t\telse {\n\t\t\tbh = sb_bread(sb, tmp_bh.b_blocknr);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tmemcpy(data, bh->b_data+offset, tocopy);\n\t\t\tbrelse(bh);\n\t\t}\n\t\toffset = 0;\n\t\ttoread -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\n\treturn len;\n}\n\n/* Write to quotafile */\nstatic ssize_t ext2_quota_write(struct super_block *sb, int type,\n\t\t\t\tconst char *data, size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> EXT2_BLOCK_SIZE_BITS(sb);\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint tocopy;\n\tsize_t towrite = len;\n\tstruct buffer_head tmp_bh;\n\tstruct buffer_head *bh;\n\n\twhile (towrite > 0) {\n\t\ttocopy = sb->s_blocksize - offset < towrite ?\n\t\t\t\tsb->s_blocksize - offset : towrite;\n\n\t\ttmp_bh.b_state = 0;\n\t\ttmp_bh.b_size = sb->s_blocksize;\n\t\terr = ext2_get_block(inode, blk, &tmp_bh, 1);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tif (offset || tocopy != EXT2_BLOCK_SIZE(sb))\n\t\t\tbh = sb_bread(sb, tmp_bh.b_blocknr);\n\t\telse\n\t\t\tbh = sb_getblk(sb, tmp_bh.b_blocknr);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tmemcpy(bh->b_data+offset, data, tocopy);\n\t\tflush_dcache_page(bh->b_page);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tbrelse(bh);\n\t\toffset = 0;\n\t\ttowrite -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\nout:\n\tif (len == towrite)\n\t\treturn err;\n\tif (inode->i_size < off+len-towrite)\n\t\ti_size_write(inode, off+len-towrite);\n\tinode->i_version++;\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(inode);\n\treturn len - towrite;\n}\n\n#endif\n\nstatic struct file_system_type ext2_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ext2\",\n\t.mount\t\t= ext2_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"ext2\");\n\nstatic int __init init_ext2_fs(void)\n{\n\tint err;\n\n\terr = init_inodecache();\n\tif (err)\n\t\treturn err;\n        err = register_filesystem(&ext2_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\n\treturn err;\n}\n\nstatic void __exit exit_ext2_fs(void)\n{\n\tunregister_filesystem(&ext2_fs_type);\n\tdestroy_inodecache();\n}\n\nMODULE_AUTHOR(\"Remy Card and others\");\nMODULE_DESCRIPTION(\"Second Extended Filesystem\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(init_ext2_fs)\nmodule_exit(exit_ext2_fs)\n", "/*\n * linux/fs/ext2/xattr.c\n *\n * Copyright (C) 2001-2003 Andreas Gruenbacher <agruen@suse.de>\n *\n * Fix by Harrison Xing <harrison@mountainviewdata.com>.\n * Extended attributes for symlinks and special files added per\n *  suggestion of Luka Renko <luka.renko@hermes.si>.\n * xattr consolidation Copyright (c) 2004 James Morris <jmorris@redhat.com>,\n *  Red Hat Inc.\n *\n */\n\n/*\n * Extended attributes are stored on disk blocks allocated outside of\n * any inode. The i_file_acl field is then made to point to this allocated\n * block. If all extended attributes of an inode are identical, these\n * inodes may share the same extended attribute block. Such situations\n * are automatically detected by keeping a cache of recent attribute block\n * numbers and hashes over the block's contents in memory.\n *\n *\n * Extended attribute block layout:\n *\n *   +------------------+\n *   | header           |\n *   | entry 1          | |\n *   | entry 2          | | growing downwards\n *   | entry 3          | v\n *   | four null bytes  |\n *   | . . .            |\n *   | value 1          | ^\n *   | value 3          | | growing upwards\n *   | value 2          | |\n *   +------------------+\n *\n * The block header is followed by multiple entry descriptors. These entry\n * descriptors are variable in size, and aligned to EXT2_XATTR_PAD\n * byte boundaries. The entry descriptors are sorted by attribute name,\n * so that two extended attribute blocks can be compared efficiently.\n *\n * Attribute values are aligned to the end of the block, stored in\n * no specific order. They are also padded to EXT2_XATTR_PAD byte\n * boundaries. No additional gaps are left between them.\n *\n * Locking strategy\n * ----------------\n * EXT2_I(inode)->i_file_acl is protected by EXT2_I(inode)->xattr_sem.\n * EA blocks are only changed if they are exclusive to an inode, so\n * holding xattr_sem also means that nothing but the EA block's reference\n * count will change. Multiple writers to an EA block are synchronized\n * by the bh lock. No more than a single bh lock is held at any time\n * to avoid deadlocks.\n */\n\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mbcache2.h>\n#include <linux/quotaops.h>\n#include <linux/rwsem.h>\n#include <linux/security.h>\n#include \"ext2.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n\n#define HDR(bh) ((struct ext2_xattr_header *)((bh)->b_data))\n#define ENTRY(ptr) ((struct ext2_xattr_entry *)(ptr))\n#define FIRST_ENTRY(bh) ENTRY(HDR(bh)+1)\n#define IS_LAST_ENTRY(entry) (*(__u32 *)(entry) == 0)\n\n#ifdef EXT2_XATTR_DEBUG\n# define ea_idebug(inode, f...) do { \\\n\t\tprintk(KERN_DEBUG \"inode %s:%ld: \", \\\n\t\t\tinode->i_sb->s_id, inode->i_ino); \\\n\t\tprintk(f); \\\n\t\tprintk(\"\\n\"); \\\n\t} while (0)\n# define ea_bdebug(bh, f...) do { \\\n\t\tprintk(KERN_DEBUG \"block %pg:%lu: \", \\\n\t\t\tbh->b_bdev, (unsigned long) bh->b_blocknr); \\\n\t\tprintk(f); \\\n\t\tprintk(\"\\n\"); \\\n\t} while (0)\n#else\n# define ea_idebug(f...)\n# define ea_bdebug(f...)\n#endif\n\nstatic int ext2_xattr_set2(struct inode *, struct buffer_head *,\n\t\t\t   struct ext2_xattr_header *);\n\nstatic int ext2_xattr_cache_insert(struct mb2_cache *, struct buffer_head *);\nstatic struct buffer_head *ext2_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext2_xattr_header *);\nstatic void ext2_xattr_rehash(struct ext2_xattr_header *,\n\t\t\t      struct ext2_xattr_entry *);\n\nstatic const struct xattr_handler *ext2_xattr_handler_map[] = {\n\t[EXT2_XATTR_INDEX_USER]\t\t     = &ext2_xattr_user_handler,\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\t[EXT2_XATTR_INDEX_POSIX_ACL_ACCESS]  = &posix_acl_access_xattr_handler,\n\t[EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT] = &posix_acl_default_xattr_handler,\n#endif\n\t[EXT2_XATTR_INDEX_TRUSTED]\t     = &ext2_xattr_trusted_handler,\n#ifdef CONFIG_EXT2_FS_SECURITY\n\t[EXT2_XATTR_INDEX_SECURITY]\t     = &ext2_xattr_security_handler,\n#endif\n};\n\nconst struct xattr_handler *ext2_xattr_handlers[] = {\n\t&ext2_xattr_user_handler,\n\t&ext2_xattr_trusted_handler,\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\t&posix_acl_access_xattr_handler,\n\t&posix_acl_default_xattr_handler,\n#endif\n#ifdef CONFIG_EXT2_FS_SECURITY\n\t&ext2_xattr_security_handler,\n#endif\n\tNULL\n};\n\nstatic inline const struct xattr_handler *\next2_xattr_handler(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < ARRAY_SIZE(ext2_xattr_handler_map))\n\t\thandler = ext2_xattr_handler_map[name_index];\n\treturn handler;\n}\n\n/*\n * ext2_xattr_get()\n *\n * Copy an extended attribute into the buffer\n * provided, or compute the buffer size required.\n * Buffer is NULL to compute the size of the buffer required.\n *\n * Returns a negative error number on failure, or the number of bytes\n * used / required on success.\n */\nint\next2_xattr_get(struct inode *inode, int name_index, const char *name,\n\t       void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext2_xattr_entry *entry;\n\tsize_t name_len, size;\n\tchar *end;\n\tint error;\n\tstruct mb2_cache *ext2_mb_cache = EXT2_SB(inode->i_sb)->s_mb_cache;\n\n\tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n\t\t  name_index, name, buffer, (long)buffer_size);\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tif (name_len > 255)\n\t\treturn -ERANGE;\n\n\tdown_read(&EXT2_I(inode)->xattr_sem);\n\terror = -ENODATA;\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %d\", EXT2_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));\n\tend = bh->b_data + bh->b_size;\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\nbad_block:\text2_error(inode->i_sb, \"ext2_xattr_get\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\n\t/* find named attribute */\n\tentry = FIRST_ENTRY(bh);\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tstruct ext2_xattr_entry *next =\n\t\t\tEXT2_XATTR_NEXT(entry);\n\t\tif ((char *)next >= end)\n\t\t\tgoto bad_block;\n\t\tif (name_index == entry->e_name_index &&\n\t\t    name_len == entry->e_name_len &&\n\t\t    memcmp(name, entry->e_name, name_len) == 0)\n\t\t\tgoto found;\n\t\tentry = next;\n\t}\n\tif (ext2_xattr_cache_insert(ext2_mb_cache, bh))\n\t\tea_idebug(inode, \"cache insert failed\");\n\terror = -ENODATA;\n\tgoto cleanup;\nfound:\n\t/* check the buffer size */\n\tif (entry->e_value_block != 0)\n\t\tgoto bad_block;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (size > inode->i_sb->s_blocksize ||\n\t    le16_to_cpu(entry->e_value_offs) + size > inode->i_sb->s_blocksize)\n\t\tgoto bad_block;\n\n\tif (ext2_xattr_cache_insert(ext2_mb_cache, bh))\n\t\tea_idebug(inode, \"cache insert failed\");\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\t/* return value of attribute */\n\t\tmemcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),\n\t\t\tsize);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(bh);\n\tup_read(&EXT2_I(inode)->xattr_sem);\n\n\treturn error;\n}\n\n/*\n * ext2_xattr_list()\n *\n * Copy a list of attribute names into the buffer\n * provided, or compute the buffer size required.\n * Buffer is NULL to compute the size of the buffer required.\n *\n * Returns a negative error number on failure, or the number of bytes\n * used / required on success.\n */\nstatic int\next2_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct buffer_head *bh = NULL;\n\tstruct ext2_xattr_entry *entry;\n\tchar *end;\n\tsize_t rest = buffer_size;\n\tint error;\n\tstruct mb2_cache *ext2_mb_cache = EXT2_SB(inode->i_sb)->s_mb_cache;\n\n\tea_idebug(inode, \"buffer=%p, buffer_size=%ld\",\n\t\t  buffer, (long)buffer_size);\n\n\tdown_read(&EXT2_I(inode)->xattr_sem);\n\terror = 0;\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %d\", EXT2_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));\n\tend = bh->b_data + bh->b_size;\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\nbad_block:\text2_error(inode->i_sb, \"ext2_xattr_list\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\n\t/* check the on-disk data structure */\n\tentry = FIRST_ENTRY(bh);\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tstruct ext2_xattr_entry *next = EXT2_XATTR_NEXT(entry);\n\n\t\tif ((char *)next >= end)\n\t\t\tgoto bad_block;\n\t\tentry = next;\n\t}\n\tif (ext2_xattr_cache_insert(ext2_mb_cache, bh))\n\t\tea_idebug(inode, \"cache insert failed\");\n\n\t/* list the attribute names */\n\tfor (entry = FIRST_ENTRY(bh); !IS_LAST_ENTRY(entry);\n\t     entry = EXT2_XATTR_NEXT(entry)) {\n\t\tconst struct xattr_handler *handler =\n\t\t\text2_xattr_handler(entry->e_name_index);\n\n\t\tif (handler && (!handler->list || handler->list(dentry))) {\n\t\t\tconst char *prefix = handler->prefix ?: handler->name;\n\t\t\tsize_t prefix_len = strlen(prefix);\n\t\t\tsize_t size = prefix_len + entry->e_name_len + 1;\n\n\t\t\tif (buffer) {\n\t\t\t\tif (size > rest) {\n\t\t\t\t\terror = -ERANGE;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tmemcpy(buffer, prefix, prefix_len);\n\t\t\t\tbuffer += prefix_len;\n\t\t\t\tmemcpy(buffer, entry->e_name, entry->e_name_len);\n\t\t\t\tbuffer += entry->e_name_len;\n\t\t\t\t*buffer++ = 0;\n\t\t\t}\n\t\t\trest -= size;\n\t\t}\n\t}\n\terror = buffer_size - rest;  /* total size */\n\ncleanup:\n\tbrelse(bh);\n\tup_read(&EXT2_I(inode)->xattr_sem);\n\n\treturn error;\n}\n\n/*\n * Inode operation listxattr()\n *\n * d_inode(dentry)->i_mutex: don't care\n */\nssize_t\next2_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\treturn ext2_xattr_list(dentry, buffer, size);\n}\n\n/*\n * If the EXT2_FEATURE_COMPAT_EXT_ATTR feature of this file system is\n * not set, set it.\n */\nstatic void ext2_xattr_update_super_block(struct super_block *sb)\n{\n\tif (EXT2_HAS_COMPAT_FEATURE(sb, EXT2_FEATURE_COMPAT_EXT_ATTR))\n\t\treturn;\n\n\tspin_lock(&EXT2_SB(sb)->s_lock);\n\tEXT2_SET_COMPAT_FEATURE(sb, EXT2_FEATURE_COMPAT_EXT_ATTR);\n\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\tmark_buffer_dirty(EXT2_SB(sb)->s_sbh);\n}\n\n/*\n * ext2_xattr_set()\n *\n * Create, replace or remove an extended attribute for this inode.  Value\n * is NULL to remove an existing extended attribute, and non-NULL to\n * either replace an existing extended attribute, or create a new extended\n * attribute. The flags XATTR_REPLACE and XATTR_CREATE\n * specify that an extended attribute must exist and must not exist\n * previous to the call, respectively.\n *\n * Returns 0, or a negative error number on failure.\n */\nint\next2_xattr_set(struct inode *inode, int name_index, const char *name,\n\t       const void *value, size_t value_len, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh = NULL;\n\tstruct ext2_xattr_header *header = NULL;\n\tstruct ext2_xattr_entry *here, *last;\n\tsize_t name_len, free, min_offs = sb->s_blocksize;\n\tint not_found = 1, error;\n\tchar *end;\n\t\n\t/*\n\t * header -- Points either into bh, or to a temporarily\n\t *           allocated buffer.\n\t * here -- The named entry found, or the place for inserting, within\n\t *         the block pointed to by header.\n\t * last -- Points right after the last named entry within the block\n\t *         pointed to by header.\n\t * min_offs -- The offset of the first value (values are aligned\n\t *             towards the end of the block).\n\t * end -- Points right after the block pointed to by header.\n\t */\n\t\n\tea_idebug(inode, \"name=%d.%s, value=%p, value_len=%ld\",\n\t\t  name_index, name, value, (long)value_len);\n\n\tif (value == NULL)\n\t\tvalue_len = 0;\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tif (name_len > 255 || value_len > sb->s_blocksize)\n\t\treturn -ERANGE;\n\tdown_write(&EXT2_I(inode)->xattr_sem);\n\tif (EXT2_I(inode)->i_file_acl) {\n\t\t/* The inode already has an extended attribute block. */\n\t\tbh = sb_bread(sb, EXT2_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tif (!bh)\n\t\t\tgoto cleanup;\n\t\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\t\tatomic_read(&(bh->b_count)),\n\t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n\t\theader = HDR(bh);\n\t\tend = bh->b_data + bh->b_size;\n\t\tif (header->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t\t    header->h_blocks != cpu_to_le32(1)) {\nbad_block:\t\text2_error(sb, \"ext2_xattr_set\",\n\t\t\t\t\"inode %ld: bad block %d\", inode->i_ino, \n\t\t\t\t   EXT2_I(inode)->i_file_acl);\n\t\t\terror = -EIO;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* Find the named attribute. */\n\t\there = FIRST_ENTRY(bh);\n\t\twhile (!IS_LAST_ENTRY(here)) {\n\t\t\tstruct ext2_xattr_entry *next = EXT2_XATTR_NEXT(here);\n\t\t\tif ((char *)next >= end)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!here->e_value_block && here->e_value_size) {\n\t\t\t\tsize_t offs = le16_to_cpu(here->e_value_offs);\n\t\t\t\tif (offs < min_offs)\n\t\t\t\t\tmin_offs = offs;\n\t\t\t}\n\t\t\tnot_found = name_index - here->e_name_index;\n\t\t\tif (!not_found)\n\t\t\t\tnot_found = name_len - here->e_name_len;\n\t\t\tif (!not_found)\n\t\t\t\tnot_found = memcmp(name, here->e_name,name_len);\n\t\t\tif (not_found <= 0)\n\t\t\t\tbreak;\n\t\t\there = next;\n\t\t}\n\t\tlast = here;\n\t\t/* We still need to compute min_offs and last. */\n\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\tstruct ext2_xattr_entry *next = EXT2_XATTR_NEXT(last);\n\t\t\tif ((char *)next >= end)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (offs < min_offs)\n\t\t\t\t\tmin_offs = offs;\n\t\t\t}\n\t\t\tlast = next;\n\t\t}\n\n\t\t/* Check whether we have enough space left. */\n\t\tfree = min_offs - ((char*)last - (char*)header) - sizeof(__u32);\n\t} else {\n\t\t/* We will use a new extended attribute block. */\n\t\tfree = sb->s_blocksize -\n\t\t\tsizeof(struct ext2_xattr_header) - sizeof(__u32);\n\t\there = last = NULL;  /* avoid gcc uninitialized warning. */\n\t}\n\n\tif (not_found) {\n\t\t/* Request to remove a nonexistent attribute? */\n\t\terror = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\terror = 0;\n\t\tif (value == NULL)\n\t\t\tgoto cleanup;\n\t} else {\n\t\t/* Request to create an existing attribute? */\n\t\terror = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t\tif (!here->e_value_block && here->e_value_size) {\n\t\t\tsize_t size = le32_to_cpu(here->e_value_size);\n\n\t\t\tif (le16_to_cpu(here->e_value_offs) + size > \n\t\t\t    sb->s_blocksize || size > sb->s_blocksize)\n\t\t\t\tgoto bad_block;\n\t\t\tfree += EXT2_XATTR_SIZE(size);\n\t\t}\n\t\tfree += EXT2_XATTR_LEN(name_len);\n\t}\n\terror = -ENOSPC;\n\tif (free < EXT2_XATTR_LEN(name_len) + EXT2_XATTR_SIZE(value_len))\n\t\tgoto cleanup;\n\n\t/* Here we know that we can set the new attribute. */\n\n\tif (header) {\n\t\t/* assert(header == HDR(bh)); */\n\t\tlock_buffer(bh);\n\t\tif (header->h_refcount == cpu_to_le32(1)) {\n\t\t\t__u32 hash = le32_to_cpu(header->h_hash);\n\n\t\t\tea_bdebug(bh, \"modifying in-place\");\n\t\t\t/*\n\t\t\t * This must happen under buffer lock for\n\t\t\t * ext2_xattr_set2() to reliably detect modified block\n\t\t\t */\n\t\t\tmb2_cache_entry_delete_block(EXT2_SB(sb)->s_mb_cache,\n\t\t\t\t\t\t     hash, bh->b_blocknr);\n\n\t\t\t/* keep the buffer locked while modifying it. */\n\t\t} else {\n\t\t\tint offset;\n\n\t\t\tunlock_buffer(bh);\n\t\t\tea_bdebug(bh, \"cloning\");\n\t\t\theader = kmalloc(bh->b_size, GFP_KERNEL);\n\t\t\terror = -ENOMEM;\n\t\t\tif (header == NULL)\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(header, HDR(bh), bh->b_size);\n\t\t\theader->h_refcount = cpu_to_le32(1);\n\n\t\t\toffset = (char *)here - bh->b_data;\n\t\t\there = ENTRY((char *)header + offset);\n\t\t\toffset = (char *)last - bh->b_data;\n\t\t\tlast = ENTRY((char *)header + offset);\n\t\t}\n\t} else {\n\t\t/* Allocate a buffer where we construct the new block. */\n\t\theader = kzalloc(sb->s_blocksize, GFP_KERNEL);\n\t\terror = -ENOMEM;\n\t\tif (header == NULL)\n\t\t\tgoto cleanup;\n\t\tend = (char *)header + sb->s_blocksize;\n\t\theader->h_magic = cpu_to_le32(EXT2_XATTR_MAGIC);\n\t\theader->h_blocks = header->h_refcount = cpu_to_le32(1);\n\t\tlast = here = ENTRY(header+1);\n\t}\n\n\t/* Iff we are modifying the block in-place, bh is locked here. */\n\n\tif (not_found) {\n\t\t/* Insert the new name. */\n\t\tsize_t size = EXT2_XATTR_LEN(name_len);\n\t\tsize_t rest = (char *)last - (char *)here;\n\t\tmemmove((char *)here + size, here, rest);\n\t\tmemset(here, 0, size);\n\t\there->e_name_index = name_index;\n\t\there->e_name_len = name_len;\n\t\tmemcpy(here->e_name, name, name_len);\n\t} else {\n\t\tif (!here->e_value_block && here->e_value_size) {\n\t\t\tchar *first_val = (char *)header + min_offs;\n\t\t\tsize_t offs = le16_to_cpu(here->e_value_offs);\n\t\t\tchar *val = (char *)header + offs;\n\t\t\tsize_t size = EXT2_XATTR_SIZE(\n\t\t\t\tle32_to_cpu(here->e_value_size));\n\n\t\t\tif (size == EXT2_XATTR_SIZE(value_len)) {\n\t\t\t\t/* The old and the new value have the same\n\t\t\t\t   size. Just replace. */\n\t\t\t\there->e_value_size = cpu_to_le32(value_len);\n\t\t\t\tmemset(val + size - EXT2_XATTR_PAD, 0,\n\t\t\t\t       EXT2_XATTR_PAD); /* Clear pad bytes. */\n\t\t\t\tmemcpy(val, value, value_len);\n\t\t\t\tgoto skip_replace;\n\t\t\t}\n\n\t\t\t/* Remove the old value. */\n\t\t\tmemmove(first_val + size, first_val, val - first_val);\n\t\t\tmemset(first_val, 0, size);\n\t\t\there->e_value_offs = 0;\n\t\t\tmin_offs += size;\n\n\t\t\t/* Adjust all value offsets. */\n\t\t\tlast = ENTRY(header+1);\n\t\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\t\tsize_t o = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (!last->e_value_block && o < offs)\n\t\t\t\t\tlast->e_value_offs =\n\t\t\t\t\t\tcpu_to_le16(o + size);\n\t\t\t\tlast = EXT2_XATTR_NEXT(last);\n\t\t\t}\n\t\t}\n\t\tif (value == NULL) {\n\t\t\t/* Remove the old name. */\n\t\t\tsize_t size = EXT2_XATTR_LEN(name_len);\n\t\t\tlast = ENTRY((char *)last - size);\n\t\t\tmemmove(here, (char*)here + size,\n\t\t\t\t(char*)last - (char*)here);\n\t\t\tmemset(last, 0, size);\n\t\t}\n\t}\n\n\tif (value != NULL) {\n\t\t/* Insert the new value. */\n\t\there->e_value_size = cpu_to_le32(value_len);\n\t\tif (value_len) {\n\t\t\tsize_t size = EXT2_XATTR_SIZE(value_len);\n\t\t\tchar *val = (char *)header + min_offs - size;\n\t\t\there->e_value_offs =\n\t\t\t\tcpu_to_le16((char *)val - (char *)header);\n\t\t\tmemset(val + size - EXT2_XATTR_PAD, 0,\n\t\t\t       EXT2_XATTR_PAD); /* Clear the pad bytes. */\n\t\t\tmemcpy(val, value, value_len);\n\t\t}\n\t}\n\nskip_replace:\n\tif (IS_LAST_ENTRY(ENTRY(header+1))) {\n\t\t/* This block is now empty. */\n\t\tif (bh && header == HDR(bh))\n\t\t\tunlock_buffer(bh);  /* we were modifying in-place. */\n\t\terror = ext2_xattr_set2(inode, bh, NULL);\n\t} else {\n\t\text2_xattr_rehash(header, here);\n\t\tif (bh && header == HDR(bh))\n\t\t\tunlock_buffer(bh);  /* we were modifying in-place. */\n\t\terror = ext2_xattr_set2(inode, bh, header);\n\t}\n\ncleanup:\n\tbrelse(bh);\n\tif (!(bh && header == HDR(bh)))\n\t\tkfree(header);\n\tup_write(&EXT2_I(inode)->xattr_sem);\n\n\treturn error;\n}\n\n/*\n * Second half of ext2_xattr_set(): Update the file system.\n */\nstatic int\next2_xattr_set2(struct inode *inode, struct buffer_head *old_bh,\n\t\tstruct ext2_xattr_header *header)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *new_bh = NULL;\n\tint error;\n\tstruct mb2_cache *ext2_mb_cache = EXT2_SB(sb)->s_mb_cache;\n\n\tif (header) {\n\t\tnew_bh = ext2_xattr_cache_find(inode, header);\n\t\tif (new_bh) {\n\t\t\t/* We found an identical block in the cache. */\n\t\t\tif (new_bh == old_bh) {\n\t\t\t\tea_bdebug(new_bh, \"keeping this block\");\n\t\t\t} else {\n\t\t\t\t/* The old block is released after updating\n\t\t\t\t   the inode.  */\n\t\t\t\tea_bdebug(new_bh, \"reusing block\");\n\n\t\t\t\terror = dquot_alloc_block(inode, 1);\n\t\t\t\tif (error) {\n\t\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tle32_add_cpu(&HDR(new_bh)->h_refcount, 1);\n\t\t\t\tea_bdebug(new_bh, \"refcount now=%d\",\n\t\t\t\t\tle32_to_cpu(HDR(new_bh)->h_refcount));\n\t\t\t}\n\t\t\tunlock_buffer(new_bh);\n\t\t} else if (old_bh && header == HDR(old_bh)) {\n\t\t\t/* Keep this block. No need to lock the block as we\n\t\t\t   don't need to change the reference count. */\n\t\t\tnew_bh = old_bh;\n\t\t\tget_bh(new_bh);\n\t\t\text2_xattr_cache_insert(ext2_mb_cache, new_bh);\n\t\t} else {\n\t\t\t/* We need to allocate a new block */\n\t\t\text2_fsblk_t goal = ext2_group_first_block_no(sb,\n\t\t\t\t\t\tEXT2_I(inode)->i_block_group);\n\t\t\tint block = ext2_new_block(inode, goal, &error);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tea_idebug(inode, \"creating block %d\", block);\n\n\t\t\tnew_bh = sb_getblk(sb, block);\n\t\t\tif (unlikely(!new_bh)) {\n\t\t\t\text2_free_blocks(inode, block, 1);\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tlock_buffer(new_bh);\n\t\t\tmemcpy(new_bh->b_data, header, new_bh->b_size);\n\t\t\tset_buffer_uptodate(new_bh);\n\t\t\tunlock_buffer(new_bh);\n\t\t\text2_xattr_cache_insert(ext2_mb_cache, new_bh);\n\t\t\t\n\t\t\text2_xattr_update_super_block(sb);\n\t\t}\n\t\tmark_buffer_dirty(new_bh);\n\t\tif (IS_SYNC(inode)) {\n\t\t\tsync_dirty_buffer(new_bh);\n\t\t\terror = -EIO;\n\t\t\tif (buffer_req(new_bh) && !buffer_uptodate(new_bh))\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* Update the inode. */\n\tEXT2_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tif (IS_SYNC(inode)) {\n\t\terror = sync_inode_metadata(inode, 1);\n\t\t/* In case sync failed due to ENOSPC the inode was actually\n\t\t * written (only some dirty data were not) so we just proceed\n\t\t * as if nothing happened and cleanup the unused block */\n\t\tif (error && error != -ENOSPC) {\n\t\t\tif (new_bh && new_bh != old_bh) {\n\t\t\t\tdquot_free_block_nodirty(inode, 1);\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t}\n\t\t\tgoto cleanup;\n\t\t}\n\t} else\n\t\tmark_inode_dirty(inode);\n\n\terror = 0;\n\tif (old_bh && old_bh != new_bh) {\n\t\t/*\n\t\t * If there was an old block and we are no longer using it,\n\t\t * release the old block.\n\t\t */\n\t\tlock_buffer(old_bh);\n\t\tif (HDR(old_bh)->h_refcount == cpu_to_le32(1)) {\n\t\t\t__u32 hash = le32_to_cpu(HDR(old_bh)->h_hash);\n\n\t\t\t/*\n\t\t\t * This must happen under buffer lock for\n\t\t\t * ext2_xattr_set2() to reliably detect freed block\n\t\t\t */\n\t\t\tmb2_cache_entry_delete_block(ext2_mb_cache,\n\t\t\t\t\t\t     hash, old_bh->b_blocknr);\n\t\t\t/* Free the old block. */\n\t\t\tea_bdebug(old_bh, \"freeing\");\n\t\t\text2_free_blocks(inode, old_bh->b_blocknr, 1);\n\t\t\tmark_inode_dirty(inode);\n\t\t\t/* We let our caller release old_bh, so we\n\t\t\t * need to duplicate the buffer before. */\n\t\t\tget_bh(old_bh);\n\t\t\tbforget(old_bh);\n\t\t} else {\n\t\t\t/* Decrement the refcount only. */\n\t\t\tle32_add_cpu(&HDR(old_bh)->h_refcount, -1);\n\t\t\tdquot_free_block_nodirty(inode, 1);\n\t\t\tmark_inode_dirty(inode);\n\t\t\tmark_buffer_dirty(old_bh);\n\t\t\tea_bdebug(old_bh, \"refcount now=%d\",\n\t\t\t\tle32_to_cpu(HDR(old_bh)->h_refcount));\n\t\t}\n\t\tunlock_buffer(old_bh);\n\t}\n\ncleanup:\n\tbrelse(new_bh);\n\n\treturn error;\n}\n\n/*\n * ext2_xattr_delete_inode()\n *\n * Free extended attribute resources associated with this inode. This\n * is called immediately before an inode is freed.\n */\nvoid\next2_xattr_delete_inode(struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\n\tdown_write(&EXT2_I(inode)->xattr_sem);\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\tif (!bh) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: block %d read error\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tea_bdebug(bh, \"b_count=%d\", atomic_read(&(bh->b_count)));\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tlock_buffer(bh);\n\tif (HDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n\n\t\t/*\n\t\t * This must happen under buffer lock for ext2_xattr_set2() to\n\t\t * reliably detect freed block\n\t\t */\n\t\tmb2_cache_entry_delete_block(EXT2_SB(inode->i_sb)->s_mb_cache,\n\t\t\t\t\t     hash, bh->b_blocknr);\n\t\text2_free_blocks(inode, EXT2_I(inode)->i_file_acl, 1);\n\t\tget_bh(bh);\n\t\tbforget(bh);\n\t\tunlock_buffer(bh);\n\t} else {\n\t\tle32_add_cpu(&HDR(bh)->h_refcount, -1);\n\t\tea_bdebug(bh, \"refcount now=%d\",\n\t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n\t\tunlock_buffer(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tif (IS_SYNC(inode))\n\t\t\tsync_dirty_buffer(bh);\n\t\tdquot_free_block_nodirty(inode, 1);\n\t}\n\tEXT2_I(inode)->i_file_acl = 0;\n\ncleanup:\n\tbrelse(bh);\n\tup_write(&EXT2_I(inode)->xattr_sem);\n}\n\n/*\n * ext2_xattr_cache_insert()\n *\n * Create a new entry in the extended attribute cache, and insert\n * it unless such an entry is already in the cache.\n *\n * Returns 0, or a negative error number on failure.\n */\nstatic int\next2_xattr_cache_insert(struct mb2_cache *cache, struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n\tint error;\n\n\terror = mb2_cache_entry_create(cache, GFP_NOFS, hash, bh->b_blocknr);\n\tif (error) {\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache (%d cache entries)\",\n\t\t\t\tatomic_read(&ext2_xattr_cache->c_entry_count));\n\t\t\terror = 0;\n\t\t}\n\t} else\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\treturn error;\n}\n\n/*\n * ext2_xattr_cmp()\n *\n * Compare two extended attribute blocks for equality.\n *\n * Returns 0 if the blocks are equal, 1 if they differ, and\n * a negative error number on errors.\n */\nstatic int\next2_xattr_cmp(struct ext2_xattr_header *header1,\n\t       struct ext2_xattr_header *header2)\n{\n\tstruct ext2_xattr_entry *entry1, *entry2;\n\n\tentry1 = ENTRY(header1+1);\n\tentry2 = ENTRY(header2+1);\n\twhile (!IS_LAST_ENTRY(entry1)) {\n\t\tif (IS_LAST_ENTRY(entry2))\n\t\t\treturn 1;\n\t\tif (entry1->e_hash != entry2->e_hash ||\n\t\t    entry1->e_name_index != entry2->e_name_index ||\n\t\t    entry1->e_name_len != entry2->e_name_len ||\n\t\t    entry1->e_value_size != entry2->e_value_size ||\n\t\t    memcmp(entry1->e_name, entry2->e_name, entry1->e_name_len))\n\t\t\treturn 1;\n\t\tif (entry1->e_value_block != 0 || entry2->e_value_block != 0)\n\t\t\treturn -EIO;\n\t\tif (memcmp((char *)header1 + le16_to_cpu(entry1->e_value_offs),\n\t\t\t   (char *)header2 + le16_to_cpu(entry2->e_value_offs),\n\t\t\t   le32_to_cpu(entry1->e_value_size)))\n\t\t\treturn 1;\n\n\t\tentry1 = EXT2_XATTR_NEXT(entry1);\n\t\tentry2 = EXT2_XATTR_NEXT(entry2);\n\t}\n\tif (!IS_LAST_ENTRY(entry2))\n\t\treturn 1;\n\treturn 0;\n}\n\n/*\n * ext2_xattr_cache_find()\n *\n * Find an identical extended attribute block.\n *\n * Returns a locked buffer head to the block found, or NULL if such\n * a block was not found or an error occurred.\n */\nstatic struct buffer_head *\next2_xattr_cache_find(struct inode *inode, struct ext2_xattr_header *header)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb2_cache_entry *ce;\n\tstruct mb2_cache *ext2_mb_cache = EXT2_SB(inode->i_sb)->s_mb_cache;\n\n\tif (!header->h_hash)\n\t\treturn NULL;  /* never share */\n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\nagain:\n\tce = mb2_cache_entry_find_first(ext2_mb_cache, hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\n\t\tbh = sb_bread(inode->i_sb, ce->e_block);\n\t\tif (!bh) {\n\t\t\text2_error(inode->i_sb, \"ext2_xattr_cache_find\",\n\t\t\t\t\"inode %ld: block %ld read error\",\n\t\t\t\tinode->i_ino, (unsigned long) ce->e_block);\n\t\t} else {\n\t\t\tlock_buffer(bh);\n\t\t\t/*\n\t\t\t * We have to be careful about races with freeing or\n\t\t\t * rehashing of xattr block. Once we hold buffer lock\n\t\t\t * xattr block's state is stable so we can check\n\t\t\t * whether the block got freed / rehashed or not.\n\t\t\t * Since we unhash mbcache entry under buffer lock when\n\t\t\t * freeing / rehashing xattr block, checking whether\n\t\t\t * entry is still hashed is reliable.\n\t\t\t */\n\t\t\tif (hlist_bl_unhashed(&ce->e_hash_list)) {\n\t\t\t\tmb2_cache_entry_put(ext2_mb_cache, ce);\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto again;\n\t\t\t} else if (le32_to_cpu(HDR(bh)->h_refcount) >\n\t\t\t\t   EXT2_XATTR_REFCOUNT_MAX) {\n\t\t\t\tea_idebug(inode, \"block %ld refcount %d>%d\",\n\t\t\t\t\t  (unsigned long) ce->e_block,\n\t\t\t\t\t  le32_to_cpu(HDR(bh)->h_refcount),\n\t\t\t\t\t  EXT2_XATTR_REFCOUNT_MAX);\n\t\t\t} else if (!ext2_xattr_cmp(header, HDR(bh))) {\n\t\t\t\tea_bdebug(bh, \"b_count=%d\",\n\t\t\t\t\t  atomic_read(&(bh->b_count)));\n\t\t\t\tmb2_cache_entry_touch(ext2_mb_cache, ce);\n\t\t\t\tmb2_cache_entry_put(ext2_mb_cache, ce);\n\t\t\t\treturn bh;\n\t\t\t}\n\t\t\tunlock_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\t\tce = mb2_cache_entry_find_next(ext2_mb_cache, ce);\n\t}\n\treturn NULL;\n}\n\n#define NAME_HASH_SHIFT 5\n#define VALUE_HASH_SHIFT 16\n\n/*\n * ext2_xattr_hash_entry()\n *\n * Compute the hash of an extended attribute.\n */\nstatic inline void ext2_xattr_hash_entry(struct ext2_xattr_header *header,\n\t\t\t\t\t struct ext2_xattr_entry *entry)\n{\n\t__u32 hash = 0;\n\tchar *name = entry->e_name;\n\tint n;\n\n\tfor (n=0; n < entry->e_name_len; n++) {\n\t\thash = (hash << NAME_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - NAME_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\n\tif (entry->e_value_block == 0 && entry->e_value_size != 0) {\n\t\t__le32 *value = (__le32 *)((char *)header +\n\t\t\tle16_to_cpu(entry->e_value_offs));\n\t\tfor (n = (le32_to_cpu(entry->e_value_size) +\n\t\t     EXT2_XATTR_ROUND) >> EXT2_XATTR_PAD_BITS; n; n--) {\n\t\t\thash = (hash << VALUE_HASH_SHIFT) ^\n\t\t\t       (hash >> (8*sizeof(hash) - VALUE_HASH_SHIFT)) ^\n\t\t\t       le32_to_cpu(*value++);\n\t\t}\n\t}\n\tentry->e_hash = cpu_to_le32(hash);\n}\n\n#undef NAME_HASH_SHIFT\n#undef VALUE_HASH_SHIFT\n\n#define BLOCK_HASH_SHIFT 16\n\n/*\n * ext2_xattr_rehash()\n *\n * Re-compute the extended attribute hash value after an entry has changed.\n */\nstatic void ext2_xattr_rehash(struct ext2_xattr_header *header,\n\t\t\t      struct ext2_xattr_entry *entry)\n{\n\tstruct ext2_xattr_entry *here;\n\t__u32 hash = 0;\n\t\n\text2_xattr_hash_entry(header, entry);\n\there = ENTRY(header+1);\n\twhile (!IS_LAST_ENTRY(here)) {\n\t\tif (!here->e_hash) {\n\t\t\t/* Block is not shared if an entry's hash value == 0 */\n\t\t\thash = 0;\n\t\t\tbreak;\n\t\t}\n\t\thash = (hash << BLOCK_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - BLOCK_HASH_SHIFT)) ^\n\t\t       le32_to_cpu(here->e_hash);\n\t\there = EXT2_XATTR_NEXT(here);\n\t}\n\theader->h_hash = cpu_to_le32(hash);\n}\n\n#undef BLOCK_HASH_SHIFT\n\n#define HASH_BUCKET_BITS 10\n\nstruct mb2_cache *ext2_xattr_create_cache(void)\n{\n\treturn mb2_cache_create(HASH_BUCKET_BITS);\n}\n\nvoid ext2_xattr_destroy_cache(struct mb2_cache *cache)\n{\n\tif (cache)\n\t\tmb2_cache_destroy(cache);\n}\n", "/*\n  File: linux/ext2_xattr.h\n\n  On-disk format of extended attributes for the ext2 filesystem.\n\n  (C) 2001 Andreas Gruenbacher, <a.gruenbacher@computer.org>\n*/\n\n#include <linux/init.h>\n#include <linux/xattr.h>\n\n/* Magic value in attribute blocks */\n#define EXT2_XATTR_MAGIC\t\t0xEA020000\n\n/* Maximum number of references to one attribute block */\n#define EXT2_XATTR_REFCOUNT_MAX\t\t1024\n\n/* Name indexes */\n#define EXT2_XATTR_INDEX_USER\t\t\t1\n#define EXT2_XATTR_INDEX_POSIX_ACL_ACCESS\t2\n#define EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT\t3\n#define EXT2_XATTR_INDEX_TRUSTED\t\t4\n#define\tEXT2_XATTR_INDEX_LUSTRE\t\t\t5\n#define EXT2_XATTR_INDEX_SECURITY\t        6\n\nstruct ext2_xattr_header {\n\t__le32\th_magic;\t/* magic number for identification */\n\t__le32\th_refcount;\t/* reference count */\n\t__le32\th_blocks;\t/* number of disk blocks used */\n\t__le32\th_hash;\t\t/* hash value of all attributes */\n\t__u32\th_reserved[4];\t/* zero right now */\n};\n\nstruct ext2_xattr_entry {\n\t__u8\te_name_len;\t/* length of name */\n\t__u8\te_name_index;\t/* attribute name index */\n\t__le16\te_value_offs;\t/* offset in disk block of value */\n\t__le32\te_value_block;\t/* disk block attribute is stored on (n/i) */\n\t__le32\te_value_size;\t/* size of attribute value */\n\t__le32\te_hash;\t\t/* hash value of name and value */\n\tchar\te_name[0];\t/* attribute name */\n};\n\n#define EXT2_XATTR_PAD_BITS\t\t2\n#define EXT2_XATTR_PAD\t\t(1<<EXT2_XATTR_PAD_BITS)\n#define EXT2_XATTR_ROUND\t\t(EXT2_XATTR_PAD-1)\n#define EXT2_XATTR_LEN(name_len) \\\n\t(((name_len) + EXT2_XATTR_ROUND + \\\n\tsizeof(struct ext2_xattr_entry)) & ~EXT2_XATTR_ROUND)\n#define EXT2_XATTR_NEXT(entry) \\\n\t( (struct ext2_xattr_entry *)( \\\n\t  (char *)(entry) + EXT2_XATTR_LEN((entry)->e_name_len)) )\n#define EXT2_XATTR_SIZE(size) \\\n\t(((size) + EXT2_XATTR_ROUND) & ~EXT2_XATTR_ROUND)\n\nstruct mb2_cache;\n\n# ifdef CONFIG_EXT2_FS_XATTR\n\nextern const struct xattr_handler ext2_xattr_user_handler;\nextern const struct xattr_handler ext2_xattr_trusted_handler;\nextern const struct xattr_handler ext2_xattr_security_handler;\n\nextern ssize_t ext2_listxattr(struct dentry *, char *, size_t);\n\nextern int ext2_xattr_get(struct inode *, int, const char *, void *, size_t);\nextern int ext2_xattr_set(struct inode *, int, const char *, const void *, size_t, int);\n\nextern void ext2_xattr_delete_inode(struct inode *);\n\nextern struct mb2_cache *ext2_xattr_create_cache(void);\nextern void ext2_xattr_destroy_cache(struct mb2_cache *cache);\n\nextern const struct xattr_handler *ext2_xattr_handlers[];\n\n# else  /* CONFIG_EXT2_FS_XATTR */\n\nstatic inline int\next2_xattr_get(struct inode *inode, int name_index,\n\t       const char *name, void *buffer, size_t size)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int\next2_xattr_set(struct inode *inode, int name_index, const char *name,\n\t       const void *value, size_t size, int flags)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline void\next2_xattr_delete_inode(struct inode *inode)\n{\n}\n\nstatic inline void ext2_xattr_destroy_cache(struct mb2_cache *cache)\n{\n}\n\n#define ext2_xattr_handlers NULL\n\n# endif  /* CONFIG_EXT2_FS_XATTR */\n\n#ifdef CONFIG_EXT2_FS_SECURITY\nextern int ext2_init_security(struct inode *inode, struct inode *dir,\n\t\t\t      const struct qstr *qstr);\n#else\nstatic inline int ext2_init_security(struct inode *inode, struct inode *dir,\n\t\t\t\t     const struct qstr *qstr)\n{\n\treturn 0;\n}\n#endif\n"], "filenames": ["fs/ext2/ext2.h", "fs/ext2/super.c", "fs/ext2/xattr.c", "fs/ext2/xattr.h"], "buggy_code_start_loc": [62, 134, 59, 55], "buggy_code_end_loc": [113, 1580, 1032, 109], "fixing_code_start_loc": [63, 134, 59, 56], "fixing_code_end_loc": [117, 1588, 1023, 98], "type": "CWE-19", "message": "The mbcache feature in the ext2 and ext4 filesystem implementations in the Linux kernel before 4.6 mishandles xattr block caching, which allows local users to cause a denial of service (soft lockup) via filesystem operations in environments that use many attributes, as demonstrated by Ceph and Samba.", "other": {"cve": {"id": "CVE-2015-8952", "sourceIdentifier": "cve@mitre.org", "published": "2016-10-16T21:59:01.910", "lastModified": "2018-03-16T01:29:00.747", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The mbcache feature in the ext2 and ext4 filesystem implementations in the Linux kernel before 4.6 mishandles xattr block caching, which allows local users to cause a denial of service (soft lockup) via filesystem operations in environments that use many attributes, as demonstrated by Ceph and Samba."}, {"lang": "es", "value": "La funcionalidad mbcache en las implementaciones del sistema de archivos ext2 y ext4 en el kernel de Linux en versiones anteriores a 4.6 no maneja adecuadamente bloque de almacenamiento en cach\u00e9 xattr, lo que permite a usuarios locales provocar una denegaci\u00f3n de servicio (bloqueo d\u00e9bil) a trav\u00e9s de operaciones de sistema de archivos en entornos que usan muchos atributos, como se demuestra por Ceph y Samba."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-19"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.5.7", "matchCriteriaId": "02606D90-EB6B-45DE-B022-6E5783BD64FA"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=82939d7999dfc1f1998c4b1c12e2f19edbdff272", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=be0726d33cb8f411945884664924bed3cb8c70ee", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=f9a61eb4e2471c56a63cd804c7474128138c38ac", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/08/22/2", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/08/25/4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.kernel.org/show_bug.cgi?id=107301", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1360968", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/82939d7999dfc1f1998c4b1c12e2f19edbdff272", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/be0726d33cb8f411945884664924bed3cb8c70ee", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/torvalds/linux/commit/f9a61eb4e2471c56a63cd804c7474128138c38ac", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://lwn.net/Articles/668718/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3582-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3582-2/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/be0726d33cb8f411945884664924bed3cb8c70ee"}}