{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                  M   M   AAA   TTTTT  L       AAA   BBBB                    %\n%                  MM MM  A   A    T    L      A   A  B   B                   %\n%                  M M M  AAAAA    T    L      AAAAA  BBBB                    %\n%                  M   M  A   A    T    L      A   A  B   B                   %\n%                  M   M  A   A    T    LLLLL  A   A  BBBB                    %\n%                                                                             %\n%                                                                             %\n%                        Read MATLAB Image Format                             %\n%                                                                             %\n%                              Software Design                                %\n%                              Jaroslav Fojtik                                %\n%                                2001-2008                                    %\n%                                                                             %\n%                                                                             %\n%  Permission is hereby granted, free of charge, to any person obtaining a    %\n%  copy of this software and associated documentation files (\"ImageMagick\"),  %\n%  to deal in ImageMagick without restriction, including without limitation   %\n%  the rights to use, copy, modify, merge, publish, distribute, sublicense,   %\n%  and/or sell copies of ImageMagick, and to permit persons to whom the       %\n%  ImageMagick is furnished to do so, subject to the following conditions:    %\n%                                                                             %\n%  The above copyright notice and this permission notice shall be included in %\n%  all copies or substantial portions of ImageMagick.                         %\n%                                                                             %\n%  The software is provided \"as is\", without warranty of any kind, express or %\n%  implied, including but not limited to the warranties of merchantability,   %\n%  fitness for a particular purpose and noninfringement.  In no event shall   %\n%  ImageMagick Studio be liable for any claim, damages or other liability,    %\n%  whether in an action of contract, tort or otherwise, arising from, out of  %\n%  or in connection with ImageMagick or the use or other dealings in          %\n%  ImageMagick.                                                               %\n%                                                                             %\n%  Except as contained in this notice, the name of the ImageMagick Studio     %\n%  shall not be used in advertising or otherwise to promote the sale, use or  %\n%  other dealings in ImageMagick without prior written authorization from the %\n%  ImageMagick Studio.                                                        %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/distort.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/utility-private.h\"\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n #include \"zlib.h\"\n#endif\n\f\n/*\n  Forward declaration.\n*/\nstatic MagickBooleanType\n  WriteMATImage(const ImageInfo *,Image *,ExceptionInfo *);\n\n\n/* Auto coloring method, sorry this creates some artefact inside data\nMinReal+j*MaxComplex = red  MaxReal+j*MaxComplex = black\nMinReal+j*0 = white          MaxReal+j*0 = black\nMinReal+j*MinComplex = blue  MaxReal+j*MinComplex = black\n*/\n\ntypedef struct\n{\n  char identific[124];\n  unsigned short Version;\n  char EndianIndicator[2];\n  unsigned long DataType;\n  unsigned long ObjectSize;\n  unsigned long unknown1;\n  unsigned long unknown2;\n\n  unsigned short unknown5;\n  unsigned char StructureFlag;\n  unsigned char StructureClass;\n  unsigned long unknown3;\n  unsigned long unknown4;\n  unsigned long DimFlag;\n\n  unsigned long SizeX;\n  unsigned long SizeY;\n  unsigned short Flag1;\n  unsigned short NameFlag;\n}\nMATHeader;\n\nstatic const char *MonthsTab[12]={\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"};\nstatic const char *DayOfWTab[7]={\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\"};\nstatic const char *OsDesc=\n#ifdef __WIN32__\n    \"PCWIN\";\n#else\n #ifdef __APPLE__\n    \"MAC\";\n #else\n    \"LNX86\";\n #endif\n#endif\n\ntypedef enum\n  {\n    miINT8 = 1,      /* 8 bit signed */\n    miUINT8,      /* 8 bit unsigned */\n    miINT16,      /* 16 bit signed */\n    miUINT16,      /* 16 bit unsigned */\n    miINT32,      /* 32 bit signed */\n    miUINT32,      /* 32 bit unsigned */\n    miSINGLE,      /* IEEE 754 single precision float */\n    miRESERVE1,\n    miDOUBLE,      /* IEEE 754 double precision float */\n    miRESERVE2,\n    miRESERVE3,\n    miINT64,      /* 64 bit signed */\n    miUINT64,      /* 64 bit unsigned */\n    miMATRIX,            /* MATLAB array */\n    miCOMPRESSED,          /* Compressed Data */\n    miUTF8,            /* Unicode UTF-8 Encoded Character Data */\n    miUTF16,            /* Unicode UTF-16 Encoded Character Data */\n    miUTF32      /* Unicode UTF-32 Encoded Character Data */\n  } mat5_data_type;\n\ntypedef enum\n  {\n    mxCELL_CLASS=1,    /* cell array */\n    mxSTRUCT_CLASS,    /* structure */\n    mxOBJECT_CLASS,    /* object */\n    mxCHAR_CLASS,    /* character array */\n    mxSPARSE_CLASS,    /* sparse array */\n    mxDOUBLE_CLASS,    /* double precision array */\n    mxSINGLE_CLASS,    /* single precision floating point */\n    mxINT8_CLASS,    /* 8 bit signed integer */\n    mxUINT8_CLASS,    /* 8 bit unsigned integer */\n    mxINT16_CLASS,    /* 16 bit signed integer */\n    mxUINT16_CLASS,    /* 16 bit unsigned integer */\n    mxINT32_CLASS,    /* 32 bit signed integer */\n    mxUINT32_CLASS,    /* 32 bit unsigned integer */\n    mxINT64_CLASS,    /* 64 bit signed integer */\n    mxUINT64_CLASS,    /* 64 bit unsigned integer */\n    mxFUNCTION_CLASS            /* Function handle */\n  } arrayclasstype;\n\n#define FLAG_COMPLEX 0x8\n#define FLAG_GLOBAL  0x4\n#define FLAG_LOGICAL 0x2\n\nstatic const QuantumType z2qtype[4] = {GrayQuantum, BlueQuantum, GreenQuantum, RedQuantum};\n\n\nstatic void InsertComplexDoubleRow(Image *image,double *p,int y,double MinVal,\n  double MaxVal,ExceptionInfo *exception)\n{\n\n  double f;\n  int x;\n  register Quantum *q;\n\n  if (MinVal == 0)\n    MinVal = -1;\n  if (MaxVal == 0)\n    MaxVal = 1;\n\n  q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return;\n  for (x = 0; x < (ssize_t) image->columns; x++)\n  {\n    if (*p > 0)\n    {\n      f = (*p / MaxVal) * (QuantumRange-GetPixelRed(image,q));\n      if (f + GetPixelRed(image,q) > QuantumRange)\n        SetPixelRed(image,QuantumRange,q);\n      else\n        SetPixelRed(image,GetPixelRed(image,q)+(int) f,q);\n      if ((int) f / 2.0 > GetPixelGreen(image,q))\n        {\n          SetPixelGreen(image,0,q);\n          SetPixelBlue(image,0,q);\n        }\n      else\n        {\n          SetPixelBlue(image,GetPixelBlue(image,q)-(int) (f/2.0),q);\n          SetPixelGreen(image,GetPixelBlue(image,q),q);\n        }\n    }\n    if (*p < 0)\n    {\n      f = (*p / MaxVal) * (QuantumRange-GetPixelBlue(image,q));\n      if (f+GetPixelBlue(image,q) > QuantumRange)\n        SetPixelBlue(image,QuantumRange,q);\n      else\n        SetPixelBlue(image,GetPixelBlue(image,q)+(int) f,q);\n      if ((int) f / 2.0 > GetPixelGreen(image,q))\n        {\n          SetPixelRed(image,0,q);\n          SetPixelGreen(image,0,q);\n        }\n      else\n        {\n          SetPixelRed(image,GetPixelRed(image,q)-(int) (f/2.0),q);\n          SetPixelGreen(image,GetPixelRed(image,q),q);\n        }\n    }\n    p++;\n    q+=GetPixelChannels(image);\n  }\n  if (!SyncAuthenticPixels(image,exception))\n    return;\n  return;\n}\n\n\nstatic void InsertComplexFloatRow(Image *image,float *p,int y,double MinVal,\n  double MaxVal,ExceptionInfo *exception)\n{\n  double f;\n  int x;\n  register Quantum *q;\n\n  if (MinVal == 0)\n    MinVal = -1;\n  if (MaxVal == 0)\n    MaxVal = 1;\n\n  q = QueueAuthenticPixels(image, 0, y, image->columns, 1,exception);\n  if (q == (Quantum *) NULL)\n    return;\n  for (x = 0; x < (ssize_t) image->columns; x++)\n  {\n    if (*p > 0)\n    {\n      f = (*p / MaxVal) * (QuantumRange-GetPixelRed(image,q));\n      if (f+GetPixelRed(image,q) > QuantumRange)\n        SetPixelRed(image,QuantumRange,q);\n      else\n        SetPixelRed(image,GetPixelRed(image,q)+(int) f,q);\n      if ((int) f / 2.0 > GetPixelGreen(image,q))\n        {\n          SetPixelGreen(image,0,q);\n          SetPixelBlue(image,0,q);\n        }\n      else\n        {\n          SetPixelBlue(image,GetPixelBlue(image,q)-(int) (f/2.0),q);\n          SetPixelGreen(image,GetPixelBlue(image,q),q);\n        }\n    }\n    if (*p < 0)\n    {\n      f = (*p / MaxVal) * (QuantumRange - GetPixelBlue(image,q));\n      if (f + GetPixelBlue(image,q) > QuantumRange)\n        SetPixelBlue(image,QuantumRange,q);\n      else\n        SetPixelBlue(image,GetPixelBlue(image,q)+\n          (int) f,q);\n      if ((int) f / 2.0 > GetPixelGreen(image,q))\n        {\n          SetPixelGreen(image,0,q);\n          SetPixelRed(image,0,q);\n        }\n      else\n        {\n          SetPixelRed(image,GetPixelRed(image,q)-(int) (f/2.0),q);\n          SetPixelGreen(image,GetPixelRed(image,q),q);\n        }\n    }\n    p++;\n    q++;\n  }\n  if (!SyncAuthenticPixels(image,exception))\n    return;\n  return;\n}\n\n\n/************** READERS ******************/\n\n/* This function reads one block of floats*/\nstatic void ReadBlobFloatsLSB(Image * image, size_t len, float *data)\n{\n  while (len >= 4)\n  {\n    *data++ = ReadBlobFloat(image);\n    len -= sizeof(float);\n  }\n  if (len > 0)\n    (void) SeekBlob(image, len, SEEK_CUR);\n}\n\nstatic void ReadBlobFloatsMSB(Image * image, size_t len, float *data)\n{\n  while (len >= 4)\n  {\n    *data++ = ReadBlobFloat(image);\n    len -= sizeof(float);\n  }\n  if (len > 0)\n    (void) SeekBlob(image, len, SEEK_CUR);\n}\n\n/* This function reads one block of doubles*/\nstatic void ReadBlobDoublesLSB(Image * image, size_t len, double *data)\n{\n  while (len >= 8)\n  {\n    *data++ = ReadBlobDouble(image);\n    len -= sizeof(double);\n  }\n  if (len > 0)\n    (void) SeekBlob(image, len, SEEK_CUR);\n}\n\nstatic void ReadBlobDoublesMSB(Image * image, size_t len, double *data)\n{\n  while (len >= 8)\n  {\n    *data++ = ReadBlobDouble(image);\n    len -= sizeof(double);\n  }\n  if (len > 0)\n    (void) SeekBlob(image, len, SEEK_CUR);\n}\n\n/* Calculate minimum and maximum from a given block of data */\nstatic void CalcMinMax(Image *image, int endian_indicator, int SizeX, int SizeY, size_t CellType, unsigned ldblk, void *BImgBuff, double *Min, double *Max)\n{\nMagickOffsetType filepos;\nint i, x;\nvoid (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\nvoid (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\ndouble *dblrow;\nfloat *fltrow;\n\n  if (endian_indicator == LSBEndian)\n  {    \n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;   \n  } \n  else    /* MI */\n  {    \n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;   \n  }\n\n  filepos = TellBlob(image);     /* Please note that file seeking occurs only in the case of doubles */\n  for (i = 0; i < SizeY; i++)\n  {\n    if (CellType==miDOUBLE)\n    {\n      ReadBlobDoublesXXX(image, ldblk, (double *)BImgBuff);\n      dblrow = (double *)BImgBuff;\n      if (i == 0)\n      {\n        *Min = *Max = *dblrow;\n      }\n      for (x = 0; x < SizeX; x++)\n      {\n        if (*Min > *dblrow)\n          *Min = *dblrow;\n        if (*Max < *dblrow)\n          *Max = *dblrow;\n        dblrow++;\n      }\n    }\n    if (CellType==miSINGLE)\n    {\n      ReadBlobFloatsXXX(image, ldblk, (float *)BImgBuff);\n      fltrow = (float *)BImgBuff;\n      if (i == 0)\n      {\n        *Min = *Max = *fltrow;\n      }\n    for (x = 0; x < (ssize_t) SizeX; x++)\n      {\n        if (*Min > *fltrow)\n          *Min = *fltrow;\n        if (*Max < *fltrow)\n          *Max = *fltrow;\n        fltrow++;\n      }\n    }\n  }\n  (void) SeekBlob(image, filepos, SEEK_SET);\n}\n\n\nstatic void FixSignedValues(const Image *image,Quantum *q, int y)\n{\n  while(y-->0)\n  {\n     /* Please note that negative values will overflow\n        Q=8; QuantumRange=255: <0;127> + 127+1 = <128; 255> \n           <-1;-128> + 127+1 = <0; 127> */\n    SetPixelRed(image,GetPixelRed(image,q)+QuantumRange/2+1,q);\n    SetPixelGreen(image,GetPixelGreen(image,q)+QuantumRange/2+1,q);\n    SetPixelBlue(image,GetPixelBlue(image,q)+QuantumRange/2+1,q);\n    q++;\n  }\n}\n\n\n/** Fix whole row of logical/binary data. It means pack it. */\nstatic void FixLogical(unsigned char *Buff,int ldblk)\n{\nunsigned char mask=128;\nunsigned char *BuffL = Buff;\nunsigned char val = 0;\n\n  while(ldblk-->0)\n  {\n    if(*Buff++ != 0)\n      val |= mask;    \n\n    mask >>= 1;\n    if(mask==0)\n    {\n      *BuffL++ = val;\n      val = 0;\n      mask = 128;\n    }   \n      \n  }\n  *BuffL = val;\n}\n\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\nstatic voidpf AcquireZIPMemory(voidpf context,unsigned int items,\n  unsigned int size)\n{\n  (void) context;\n  return((voidpf) AcquireQuantumMemory(items,size));\n}\n\nstatic void RelinquishZIPMemory(voidpf context,voidpf memory)\n{\n  (void) context;\n  memory=RelinquishMagickMemory(memory);\n}\n#endif\n\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n/** This procedure decompreses an image block for a new MATLAB format. */\nstatic Image *DecompressBlock(Image *orig, MagickOffsetType Size, ImageInfo *clone_info, ExceptionInfo *exception)\n{\n\nImage *image2;\nvoid *CacheBlock, *DecompressBlock;\nz_stream zip_info;\nFILE *mat_file;\nsize_t magick_size;\nsize_t extent;\nint file;\n\nint status;\n\n  if(clone_info==NULL) return NULL;\n  if(clone_info->file)    /* Close file opened from previous transaction. */\n  {\n    fclose(clone_info->file);\n    clone_info->file = NULL;\n    (void) remove_utf8(clone_info->filename);\n  }\n\n  CacheBlock = AcquireQuantumMemory((size_t)((Size<16384)?Size:16384),sizeof(unsigned char *));\n  if(CacheBlock==NULL) return NULL;\n  DecompressBlock = AcquireQuantumMemory((size_t)(4096),sizeof(unsigned char *));\n  if(DecompressBlock==NULL) \n  {\n    RelinquishMagickMemory(CacheBlock);    \n    return NULL;\n  }\n\n  mat_file=0;\n  file = AcquireUniqueFileResource(clone_info->filename);\n  if (file != -1)\n    mat_file = fdopen(file,\"w\");\n  if(!mat_file)\n  {\n    RelinquishMagickMemory(CacheBlock);\n    RelinquishMagickMemory(DecompressBlock);\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Gannot create file stream for PS image\");\n    return NULL;\n  }\n\n  zip_info.zalloc=AcquireZIPMemory;\n  zip_info.zfree=RelinquishZIPMemory;\n  zip_info.opaque = (voidpf) NULL;\n  inflateInit(&zip_info);\n  /* zip_info.next_out = 8*4;*/\n\n  zip_info.avail_in = 0;\n  zip_info.total_out = 0;\n  while(Size>0 && !EOFBlob(orig))\n  {    \n    magick_size = ReadBlob(orig, (Size<16384)?Size:16384, (unsigned char *) CacheBlock);\n    zip_info.next_in = (Bytef *) CacheBlock;\n    zip_info.avail_in = (uInt) magick_size;    \n\n    while(zip_info.avail_in>0)\n    {\n      zip_info.avail_out = 4096;    \n      zip_info.next_out = (Bytef *) DecompressBlock;\n      status = inflate(&zip_info,Z_NO_FLUSH);      \n      extent=fwrite(DecompressBlock, 4096-zip_info.avail_out, 1, mat_file);\n      (void) extent;\n\n      if(status == Z_STREAM_END) goto DblBreak;\n    }\n\n    Size -= magick_size;\n  }\nDblBreak:\n \n  inflateEnd(&zip_info);\n  (void)fclose(mat_file);\n  RelinquishMagickMemory(CacheBlock);\n  RelinquishMagickMemory(DecompressBlock);\n\n  if((clone_info->file=fopen(clone_info->filename,\"rb\"))==NULL) goto UnlinkFile;\n  if( (image2 = AcquireImage(clone_info,exception))==NULL ) goto EraseFile;  \n  status = OpenBlob(clone_info,image2,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n  {\n    DeleteImageFromList(&image2);    \nEraseFile:\n    fclose(clone_info->file);\n    clone_info->file = NULL;\nUnlinkFile:\n    (void) remove_utf8(clone_info->filename);\n    return NULL; \n  }\n\n  return image2;\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d M A T L A B i m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadMATImage() reads an MAT X image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadMATImage method is:\n%\n%      Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image:  Method ReadMATImage returns a pointer to the image after\n%      reading. A null image is returned if there is a memory shortage or if\n%      the image cannot be read.\n%\n%    o image_info: Specifies a pointer to a ImageInfo structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;  \n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n  \n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\"); \n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=CloneImageInfo(image_info);\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  } \n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else \n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif    \n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n \n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);  \n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;  \n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);  \n   \n\n    switch(MATLAB_HDR.DimFlag)\n    {     \n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n           Frames = ReadBlobXXXLong(image2);\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }  \n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS && \n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n  \n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL) \n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;      \n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);      \n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);      \n        break;   \n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64; \n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */        \n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;    \n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }  \n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(unsigned char));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);      \n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }    \n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);      \n      DeleteImageFromList(&image);      \n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2); \n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }    \n      }\n\n      /* Allocate next image structure. */    \n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;                \n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;    \n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n  }\n\n  clone_info=DestroyImageInfo(clone_info);\n  RelinquishMagickMemory(BImgBuff);\n  CloseBlob(image);\n\n\n  {\n    Image *p;    \n    ssize_t scene=0;\n    \n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n    \n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r M A T I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Method RegisterMATImage adds attributes for the MAT image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterMATImage method is:\n%\n%      size_t RegisterMATImage(void)\n%\n*/\nModuleExport size_t RegisterMATImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"MAT\",\"MAT\",\"MATLAB level 5 image format\");\n  entry->decoder=(DecodeImageHandler *) ReadMATImage;\n  entry->encoder=(EncodeImageHandler *) WriteMATImage;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->flags|=CoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r M A T I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Method UnregisterMATImage removes format registrations made by the\n%  MAT module from the list of supported formats.\n%\n%  The format of the UnregisterMATImage method is:\n%\n%      UnregisterMATImage(void)\n%\n*/\nModuleExport void UnregisterMATImage(void)\n{\n  (void) UnregisterMagickInfo(\"MAT\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e M A T L A B I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Function WriteMATImage writes an Matlab matrix to a file.  \n%\n%  The format of the WriteMATImage method is:\n%\n%      MagickBooleanType WriteMATImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: Specifies a pointer to a ImageInfo structure.\n%\n%    o image:  A pointer to an Image structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteMATImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  ssize_t y;\n  unsigned z;\n  register const Quantum *p;\n\n  unsigned int status;\n  int logging;\n  size_t DataSize;\n  char padding;\n  char MATLAB_HDR[0x80];\n  time_t current_time;\n  struct tm local_time;\n  unsigned char *pixels;\n  int is_gray;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\"enter MAT\");\n  (void) logging;\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  image->depth=8;\n\n  current_time=time((time_t *) NULL);\n#if defined(MAGICKCORE_HAVE_LOCALTIME_R)\n  (void) localtime_r(&current_time,&local_time);\n#else\n  (void) memcpy(&local_time,localtime(&current_time),sizeof(local_time));\n#endif\n  (void) memset(MATLAB_HDR,' ',MagickMin(sizeof(MATLAB_HDR),124));\n  FormatLocaleString(MATLAB_HDR,sizeof(MATLAB_HDR),\n    \"MATLAB 5.0 MAT-file, Platform: %s, Created on: %s %s %2d %2d:%2d:%2d %d\",\n    OsDesc,DayOfWTab[local_time.tm_wday],MonthsTab[local_time.tm_mon],\n    local_time.tm_mday,local_time.tm_hour,local_time.tm_min,\n    local_time.tm_sec,local_time.tm_year+1900);\n  MATLAB_HDR[0x7C]=0;\n  MATLAB_HDR[0x7D]=1;\n  MATLAB_HDR[0x7E]='I';\n  MATLAB_HDR[0x7F]='M';\n  (void) WriteBlob(image,sizeof(MATLAB_HDR),(unsigned char *) MATLAB_HDR);\n  scene=0;\n  do\n  {\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    is_gray = SetImageGray(image,exception);\n    z = is_gray ? 0 : 3;\n\n    /*\n      Store MAT header.\n    */\n    DataSize = image->rows /*Y*/ * image->columns /*X*/;\n    if(!is_gray) DataSize *= 3 /*Z*/;\n    padding=((unsigned char)(DataSize-1) & 0x7) ^ 0x7;\n\n    (void) WriteBlobLSBLong(image, miMATRIX);\n    (void) WriteBlobLSBLong(image, (unsigned int) DataSize+padding+(is_gray ? 48 : 56));\n    (void) WriteBlobLSBLong(image, 0x6); /* 0x88 */\n    (void) WriteBlobLSBLong(image, 0x8); /* 0x8C */\n    (void) WriteBlobLSBLong(image, 0x6); /* 0x90 */  \n    (void) WriteBlobLSBLong(image, 0);   \n    (void) WriteBlobLSBLong(image, 0x5); /* 0x98 */\n    (void) WriteBlobLSBLong(image, is_gray ? 0x8 : 0xC); /* 0x9C - DimFlag */\n    (void) WriteBlobLSBLong(image, (unsigned int) image->rows);    /* x: 0xA0 */  \n    (void) WriteBlobLSBLong(image, (unsigned int) image->columns); /* y: 0xA4 */  \n    if(!is_gray)\n    {\n      (void) WriteBlobLSBLong(image, 3); /* z: 0xA8 */  \n      (void) WriteBlobLSBLong(image, 0);\n    }\n    (void) WriteBlobLSBShort(image, 1);  /* 0xB0 */  \n    (void) WriteBlobLSBShort(image, 1);  /* 0xB2 */\n    (void) WriteBlobLSBLong(image, 'M'); /* 0xB4 */\n    (void) WriteBlobLSBLong(image, 0x2); /* 0xB8 */  \n    (void) WriteBlobLSBLong(image, (unsigned int) DataSize); /* 0xBC */\n\n    /*\n      Store image data.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    do\n    {\n      for (y=0; y < (ssize_t)image->columns; y++)\n      {\n        p=GetVirtualPixels(image,y,0,1,image->rows,exception);\n        if (p == (const Quantum *) NULL)\n          break;\n        (void) ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n          z2qtype[z],pixels,exception);\n        (void) WriteBlob(image,image->rows,pixels);\n      }    \n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n    } while(z-- >= 2);\n    while(padding-->0) (void) WriteBlobByte(image,0);\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                  M   M   AAA   TTTTT  L       AAA   BBBB                    %\n%                  MM MM  A   A    T    L      A   A  B   B                   %\n%                  M M M  AAAAA    T    L      AAAAA  BBBB                    %\n%                  M   M  A   A    T    L      A   A  B   B                   %\n%                  M   M  A   A    T    LLLLL  A   A  BBBB                    %\n%                                                                             %\n%                                                                             %\n%                        Read MATLAB Image Format                             %\n%                                                                             %\n%                              Software Design                                %\n%                              Jaroslav Fojtik                                %\n%                                2001-2008                                    %\n%                                                                             %\n%                                                                             %\n%  Permission is hereby granted, free of charge, to any person obtaining a    %\n%  copy of this software and associated documentation files (\"ImageMagick\"),  %\n%  to deal in ImageMagick without restriction, including without limitation   %\n%  the rights to use, copy, modify, merge, publish, distribute, sublicense,   %\n%  and/or sell copies of ImageMagick, and to permit persons to whom the       %\n%  ImageMagick is furnished to do so, subject to the following conditions:    %\n%                                                                             %\n%  The above copyright notice and this permission notice shall be included in %\n%  all copies or substantial portions of ImageMagick.                         %\n%                                                                             %\n%  The software is provided \"as is\", without warranty of any kind, express or %\n%  implied, including but not limited to the warranties of merchantability,   %\n%  fitness for a particular purpose and noninfringement.  In no event shall   %\n%  ImageMagick Studio be liable for any claim, damages or other liability,    %\n%  whether in an action of contract, tort or otherwise, arising from, out of  %\n%  or in connection with ImageMagick or the use or other dealings in          %\n%  ImageMagick.                                                               %\n%                                                                             %\n%  Except as contained in this notice, the name of the ImageMagick Studio     %\n%  shall not be used in advertising or otherwise to promote the sale, use or  %\n%  other dealings in ImageMagick without prior written authorization from the %\n%  ImageMagick Studio.                                                        %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/distort.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/utility-private.h\"\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n #include \"zlib.h\"\n#endif\n\f\n/*\n  Forward declaration.\n*/\nstatic MagickBooleanType\n  WriteMATImage(const ImageInfo *,Image *,ExceptionInfo *);\n\n\n/* Auto coloring method, sorry this creates some artefact inside data\nMinReal+j*MaxComplex = red  MaxReal+j*MaxComplex = black\nMinReal+j*0 = white          MaxReal+j*0 = black\nMinReal+j*MinComplex = blue  MaxReal+j*MinComplex = black\n*/\n\ntypedef struct\n{\n  char identific[124];\n  unsigned short Version;\n  char EndianIndicator[2];\n  unsigned long DataType;\n  unsigned long ObjectSize;\n  unsigned long unknown1;\n  unsigned long unknown2;\n\n  unsigned short unknown5;\n  unsigned char StructureFlag;\n  unsigned char StructureClass;\n  unsigned long unknown3;\n  unsigned long unknown4;\n  unsigned long DimFlag;\n\n  unsigned long SizeX;\n  unsigned long SizeY;\n  unsigned short Flag1;\n  unsigned short NameFlag;\n}\nMATHeader;\n\nstatic const char *MonthsTab[12]={\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"};\nstatic const char *DayOfWTab[7]={\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\"};\nstatic const char *OsDesc=\n#ifdef __WIN32__\n    \"PCWIN\";\n#else\n #ifdef __APPLE__\n    \"MAC\";\n #else\n    \"LNX86\";\n #endif\n#endif\n\ntypedef enum\n  {\n    miINT8 = 1,      /* 8 bit signed */\n    miUINT8,      /* 8 bit unsigned */\n    miINT16,      /* 16 bit signed */\n    miUINT16,      /* 16 bit unsigned */\n    miINT32,      /* 32 bit signed */\n    miUINT32,      /* 32 bit unsigned */\n    miSINGLE,      /* IEEE 754 single precision float */\n    miRESERVE1,\n    miDOUBLE,      /* IEEE 754 double precision float */\n    miRESERVE2,\n    miRESERVE3,\n    miINT64,      /* 64 bit signed */\n    miUINT64,      /* 64 bit unsigned */\n    miMATRIX,            /* MATLAB array */\n    miCOMPRESSED,          /* Compressed Data */\n    miUTF8,            /* Unicode UTF-8 Encoded Character Data */\n    miUTF16,            /* Unicode UTF-16 Encoded Character Data */\n    miUTF32      /* Unicode UTF-32 Encoded Character Data */\n  } mat5_data_type;\n\ntypedef enum\n  {\n    mxCELL_CLASS=1,    /* cell array */\n    mxSTRUCT_CLASS,    /* structure */\n    mxOBJECT_CLASS,    /* object */\n    mxCHAR_CLASS,    /* character array */\n    mxSPARSE_CLASS,    /* sparse array */\n    mxDOUBLE_CLASS,    /* double precision array */\n    mxSINGLE_CLASS,    /* single precision floating point */\n    mxINT8_CLASS,    /* 8 bit signed integer */\n    mxUINT8_CLASS,    /* 8 bit unsigned integer */\n    mxINT16_CLASS,    /* 16 bit signed integer */\n    mxUINT16_CLASS,    /* 16 bit unsigned integer */\n    mxINT32_CLASS,    /* 32 bit signed integer */\n    mxUINT32_CLASS,    /* 32 bit unsigned integer */\n    mxINT64_CLASS,    /* 64 bit signed integer */\n    mxUINT64_CLASS,    /* 64 bit unsigned integer */\n    mxFUNCTION_CLASS            /* Function handle */\n  } arrayclasstype;\n\n#define FLAG_COMPLEX 0x8\n#define FLAG_GLOBAL  0x4\n#define FLAG_LOGICAL 0x2\n\nstatic const QuantumType z2qtype[4] = {GrayQuantum, BlueQuantum, GreenQuantum, RedQuantum};\n\n\nstatic void InsertComplexDoubleRow(Image *image,double *p,int y,double MinVal,\n  double MaxVal,ExceptionInfo *exception)\n{\n\n  double f;\n  int x;\n  register Quantum *q;\n\n  if (MinVal == 0)\n    MinVal = -1;\n  if (MaxVal == 0)\n    MaxVal = 1;\n\n  q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return;\n  for (x = 0; x < (ssize_t) image->columns; x++)\n  {\n    if (*p > 0)\n    {\n      f = (*p / MaxVal) * (QuantumRange-GetPixelRed(image,q));\n      if (f + GetPixelRed(image,q) > QuantumRange)\n        SetPixelRed(image,QuantumRange,q);\n      else\n        SetPixelRed(image,GetPixelRed(image,q)+(int) f,q);\n      if ((int) f / 2.0 > GetPixelGreen(image,q))\n        {\n          SetPixelGreen(image,0,q);\n          SetPixelBlue(image,0,q);\n        }\n      else\n        {\n          SetPixelBlue(image,GetPixelBlue(image,q)-(int) (f/2.0),q);\n          SetPixelGreen(image,GetPixelBlue(image,q),q);\n        }\n    }\n    if (*p < 0)\n    {\n      f = (*p / MaxVal) * (QuantumRange-GetPixelBlue(image,q));\n      if (f+GetPixelBlue(image,q) > QuantumRange)\n        SetPixelBlue(image,QuantumRange,q);\n      else\n        SetPixelBlue(image,GetPixelBlue(image,q)+(int) f,q);\n      if ((int) f / 2.0 > GetPixelGreen(image,q))\n        {\n          SetPixelRed(image,0,q);\n          SetPixelGreen(image,0,q);\n        }\n      else\n        {\n          SetPixelRed(image,GetPixelRed(image,q)-(int) (f/2.0),q);\n          SetPixelGreen(image,GetPixelRed(image,q),q);\n        }\n    }\n    p++;\n    q+=GetPixelChannels(image);\n  }\n  if (!SyncAuthenticPixels(image,exception))\n    return;\n  return;\n}\n\n\nstatic void InsertComplexFloatRow(Image *image,float *p,int y,double MinVal,\n  double MaxVal,ExceptionInfo *exception)\n{\n  double f;\n  int x;\n  register Quantum *q;\n\n  if (MinVal == 0)\n    MinVal = -1;\n  if (MaxVal == 0)\n    MaxVal = 1;\n\n  q = QueueAuthenticPixels(image, 0, y, image->columns, 1,exception);\n  if (q == (Quantum *) NULL)\n    return;\n  for (x = 0; x < (ssize_t) image->columns; x++)\n  {\n    if (*p > 0)\n    {\n      f = (*p / MaxVal) * (QuantumRange-GetPixelRed(image,q));\n      if (f+GetPixelRed(image,q) > QuantumRange)\n        SetPixelRed(image,QuantumRange,q);\n      else\n        SetPixelRed(image,GetPixelRed(image,q)+(int) f,q);\n      if ((int) f / 2.0 > GetPixelGreen(image,q))\n        {\n          SetPixelGreen(image,0,q);\n          SetPixelBlue(image,0,q);\n        }\n      else\n        {\n          SetPixelBlue(image,GetPixelBlue(image,q)-(int) (f/2.0),q);\n          SetPixelGreen(image,GetPixelBlue(image,q),q);\n        }\n    }\n    if (*p < 0)\n    {\n      f = (*p / MaxVal) * (QuantumRange - GetPixelBlue(image,q));\n      if (f + GetPixelBlue(image,q) > QuantumRange)\n        SetPixelBlue(image,QuantumRange,q);\n      else\n        SetPixelBlue(image,GetPixelBlue(image,q)+\n          (int) f,q);\n      if ((int) f / 2.0 > GetPixelGreen(image,q))\n        {\n          SetPixelGreen(image,0,q);\n          SetPixelRed(image,0,q);\n        }\n      else\n        {\n          SetPixelRed(image,GetPixelRed(image,q)-(int) (f/2.0),q);\n          SetPixelGreen(image,GetPixelRed(image,q),q);\n        }\n    }\n    p++;\n    q++;\n  }\n  if (!SyncAuthenticPixels(image,exception))\n    return;\n  return;\n}\n\n\n/************** READERS ******************/\n\n/* This function reads one block of floats*/\nstatic void ReadBlobFloatsLSB(Image * image, size_t len, float *data)\n{\n  while (len >= 4)\n  {\n    *data++ = ReadBlobFloat(image);\n    len -= sizeof(float);\n  }\n  if (len > 0)\n    (void) SeekBlob(image, len, SEEK_CUR);\n}\n\nstatic void ReadBlobFloatsMSB(Image * image, size_t len, float *data)\n{\n  while (len >= 4)\n  {\n    *data++ = ReadBlobFloat(image);\n    len -= sizeof(float);\n  }\n  if (len > 0)\n    (void) SeekBlob(image, len, SEEK_CUR);\n}\n\n/* This function reads one block of doubles*/\nstatic void ReadBlobDoublesLSB(Image * image, size_t len, double *data)\n{\n  while (len >= 8)\n  {\n    *data++ = ReadBlobDouble(image);\n    len -= sizeof(double);\n  }\n  if (len > 0)\n    (void) SeekBlob(image, len, SEEK_CUR);\n}\n\nstatic void ReadBlobDoublesMSB(Image * image, size_t len, double *data)\n{\n  while (len >= 8)\n  {\n    *data++ = ReadBlobDouble(image);\n    len -= sizeof(double);\n  }\n  if (len > 0)\n    (void) SeekBlob(image, len, SEEK_CUR);\n}\n\n/* Calculate minimum and maximum from a given block of data */\nstatic void CalcMinMax(Image *image, int endian_indicator, int SizeX, int SizeY, size_t CellType, unsigned ldblk, void *BImgBuff, double *Min, double *Max)\n{\nMagickOffsetType filepos;\nint i, x;\nvoid (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\nvoid (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\ndouble *dblrow;\nfloat *fltrow;\n\n  if (endian_indicator == LSBEndian)\n  {    \n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;   \n  } \n  else    /* MI */\n  {    \n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;   \n  }\n\n  filepos = TellBlob(image);     /* Please note that file seeking occurs only in the case of doubles */\n  for (i = 0; i < SizeY; i++)\n  {\n    if (CellType==miDOUBLE)\n    {\n      ReadBlobDoublesXXX(image, ldblk, (double *)BImgBuff);\n      dblrow = (double *)BImgBuff;\n      if (i == 0)\n      {\n        *Min = *Max = *dblrow;\n      }\n      for (x = 0; x < SizeX; x++)\n      {\n        if (*Min > *dblrow)\n          *Min = *dblrow;\n        if (*Max < *dblrow)\n          *Max = *dblrow;\n        dblrow++;\n      }\n    }\n    if (CellType==miSINGLE)\n    {\n      ReadBlobFloatsXXX(image, ldblk, (float *)BImgBuff);\n      fltrow = (float *)BImgBuff;\n      if (i == 0)\n      {\n        *Min = *Max = *fltrow;\n      }\n    for (x = 0; x < (ssize_t) SizeX; x++)\n      {\n        if (*Min > *fltrow)\n          *Min = *fltrow;\n        if (*Max < *fltrow)\n          *Max = *fltrow;\n        fltrow++;\n      }\n    }\n  }\n  (void) SeekBlob(image, filepos, SEEK_SET);\n}\n\n\nstatic void FixSignedValues(const Image *image,Quantum *q, int y)\n{\n  while(y-->0)\n  {\n     /* Please note that negative values will overflow\n        Q=8; QuantumRange=255: <0;127> + 127+1 = <128; 255> \n           <-1;-128> + 127+1 = <0; 127> */\n    SetPixelRed(image,GetPixelRed(image,q)+QuantumRange/2+1,q);\n    SetPixelGreen(image,GetPixelGreen(image,q)+QuantumRange/2+1,q);\n    SetPixelBlue(image,GetPixelBlue(image,q)+QuantumRange/2+1,q);\n    q++;\n  }\n}\n\n\n/** Fix whole row of logical/binary data. It means pack it. */\nstatic void FixLogical(unsigned char *Buff,int ldblk)\n{\nunsigned char mask=128;\nunsigned char *BuffL = Buff;\nunsigned char val = 0;\n\n  while(ldblk-->0)\n  {\n    if(*Buff++ != 0)\n      val |= mask;    \n\n    mask >>= 1;\n    if(mask==0)\n    {\n      *BuffL++ = val;\n      val = 0;\n      mask = 128;\n    }   \n      \n  }\n  *BuffL = val;\n}\n\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\nstatic voidpf AcquireZIPMemory(voidpf context,unsigned int items,\n  unsigned int size)\n{\n  (void) context;\n  return((voidpf) AcquireQuantumMemory(items,size));\n}\n\nstatic void RelinquishZIPMemory(voidpf context,voidpf memory)\n{\n  (void) context;\n  memory=RelinquishMagickMemory(memory);\n}\n#endif\n\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n/** This procedure decompreses an image block for a new MATLAB format. */\nstatic Image *DecompressBlock(Image *orig, MagickOffsetType Size, ImageInfo *clone_info, ExceptionInfo *exception)\n{\n\nImage *image2;\nvoid *CacheBlock, *DecompressBlock;\nz_stream zip_info;\nFILE *mat_file;\nsize_t magick_size;\nsize_t extent;\nint file;\n\nint status;\n\n  if(clone_info==NULL) return NULL;\n  if(clone_info->file)    /* Close file opened from previous transaction. */\n  {\n    fclose(clone_info->file);\n    clone_info->file = NULL;\n    (void) remove_utf8(clone_info->filename);\n  }\n\n  CacheBlock = AcquireQuantumMemory((size_t)((Size<16384)?Size:16384),sizeof(unsigned char *));\n  if(CacheBlock==NULL) return NULL;\n  DecompressBlock = AcquireQuantumMemory((size_t)(4096),sizeof(unsigned char *));\n  if(DecompressBlock==NULL) \n  {\n    RelinquishMagickMemory(CacheBlock);    \n    return NULL;\n  }\n\n  mat_file=0;\n  file = AcquireUniqueFileResource(clone_info->filename);\n  if (file != -1)\n    mat_file = fdopen(file,\"w\");\n  if(!mat_file)\n  {\n    RelinquishMagickMemory(CacheBlock);\n    RelinquishMagickMemory(DecompressBlock);\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Gannot create file stream for PS image\");\n    return NULL;\n  }\n\n  zip_info.zalloc=AcquireZIPMemory;\n  zip_info.zfree=RelinquishZIPMemory;\n  zip_info.opaque = (voidpf) NULL;\n  inflateInit(&zip_info);\n  /* zip_info.next_out = 8*4;*/\n\n  zip_info.avail_in = 0;\n  zip_info.total_out = 0;\n  while(Size>0 && !EOFBlob(orig))\n  {    \n    magick_size = ReadBlob(orig, (Size<16384)?Size:16384, (unsigned char *) CacheBlock);\n    zip_info.next_in = (Bytef *) CacheBlock;\n    zip_info.avail_in = (uInt) magick_size;    \n\n    while(zip_info.avail_in>0)\n    {\n      zip_info.avail_out = 4096;    \n      zip_info.next_out = (Bytef *) DecompressBlock;\n      status = inflate(&zip_info,Z_NO_FLUSH);      \n      extent=fwrite(DecompressBlock, 4096-zip_info.avail_out, 1, mat_file);\n      (void) extent;\n\n      if(status == Z_STREAM_END) goto DblBreak;\n    }\n\n    Size -= magick_size;\n  }\nDblBreak:\n \n  inflateEnd(&zip_info);\n  (void)fclose(mat_file);\n  RelinquishMagickMemory(CacheBlock);\n  RelinquishMagickMemory(DecompressBlock);\n\n  if((clone_info->file=fopen(clone_info->filename,\"rb\"))==NULL) goto UnlinkFile;\n  if( (image2 = AcquireImage(clone_info,exception))==NULL ) goto EraseFile;  \n  status = OpenBlob(clone_info,image2,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n  {\n    DeleteImageFromList(&image2);    \nEraseFile:\n    fclose(clone_info->file);\n    clone_info->file = NULL;\nUnlinkFile:\n    (void) remove_utf8(clone_info->filename);\n    return NULL; \n  }\n\n  return image2;\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d M A T L A B i m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadMATImage() reads an MAT X image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadMATImage method is:\n%\n%      Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image:  Method ReadMATImage returns a pointer to the image after\n%      reading. A null image is returned if there is a memory shortage or if\n%      the image cannot be read.\n%\n%    o image_info: Specifies a pointer to a ImageInfo structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;  \n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n  \n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\"); \n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=CloneImageInfo(image_info);\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  } \n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else \n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif    \n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n \n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);  \n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;  \n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);  \n   \n\n    switch(MATLAB_HDR.DimFlag)\n    {     \n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n           Frames = ReadBlobXXXLong(image2);\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }  \n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS && \n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n  \n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL) \n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;      \n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);      \n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);      \n        break;   \n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64; \n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */        \n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;    \n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }  \n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);      \n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }    \n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);      \n      DeleteImageFromList(&image);      \n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2); \n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }    \n      }\n\n      /* Allocate next image structure. */    \n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;                \n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;    \n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n  }\n\n  clone_info=DestroyImageInfo(clone_info);\n  RelinquishMagickMemory(BImgBuff);\n  CloseBlob(image);\n\n\n  {\n    Image *p;    \n    ssize_t scene=0;\n    \n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n    \n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r M A T I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Method RegisterMATImage adds attributes for the MAT image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterMATImage method is:\n%\n%      size_t RegisterMATImage(void)\n%\n*/\nModuleExport size_t RegisterMATImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"MAT\",\"MAT\",\"MATLAB level 5 image format\");\n  entry->decoder=(DecodeImageHandler *) ReadMATImage;\n  entry->encoder=(EncodeImageHandler *) WriteMATImage;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->flags|=CoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r M A T I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Method UnregisterMATImage removes format registrations made by the\n%  MAT module from the list of supported formats.\n%\n%  The format of the UnregisterMATImage method is:\n%\n%      UnregisterMATImage(void)\n%\n*/\nModuleExport void UnregisterMATImage(void)\n{\n  (void) UnregisterMagickInfo(\"MAT\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e M A T L A B I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Function WriteMATImage writes an Matlab matrix to a file.  \n%\n%  The format of the WriteMATImage method is:\n%\n%      MagickBooleanType WriteMATImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: Specifies a pointer to a ImageInfo structure.\n%\n%    o image:  A pointer to an Image structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteMATImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  ssize_t y;\n  unsigned z;\n  register const Quantum *p;\n\n  unsigned int status;\n  int logging;\n  size_t DataSize;\n  char padding;\n  char MATLAB_HDR[0x80];\n  time_t current_time;\n  struct tm local_time;\n  unsigned char *pixels;\n  int is_gray;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\"enter MAT\");\n  (void) logging;\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  image->depth=8;\n\n  current_time=time((time_t *) NULL);\n#if defined(MAGICKCORE_HAVE_LOCALTIME_R)\n  (void) localtime_r(&current_time,&local_time);\n#else\n  (void) memcpy(&local_time,localtime(&current_time),sizeof(local_time));\n#endif\n  (void) memset(MATLAB_HDR,' ',MagickMin(sizeof(MATLAB_HDR),124));\n  FormatLocaleString(MATLAB_HDR,sizeof(MATLAB_HDR),\n    \"MATLAB 5.0 MAT-file, Platform: %s, Created on: %s %s %2d %2d:%2d:%2d %d\",\n    OsDesc,DayOfWTab[local_time.tm_wday],MonthsTab[local_time.tm_mon],\n    local_time.tm_mday,local_time.tm_hour,local_time.tm_min,\n    local_time.tm_sec,local_time.tm_year+1900);\n  MATLAB_HDR[0x7C]=0;\n  MATLAB_HDR[0x7D]=1;\n  MATLAB_HDR[0x7E]='I';\n  MATLAB_HDR[0x7F]='M';\n  (void) WriteBlob(image,sizeof(MATLAB_HDR),(unsigned char *) MATLAB_HDR);\n  scene=0;\n  do\n  {\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    is_gray = SetImageGray(image,exception);\n    z = is_gray ? 0 : 3;\n\n    /*\n      Store MAT header.\n    */\n    DataSize = image->rows /*Y*/ * image->columns /*X*/;\n    if(!is_gray) DataSize *= 3 /*Z*/;\n    padding=((unsigned char)(DataSize-1) & 0x7) ^ 0x7;\n\n    (void) WriteBlobLSBLong(image, miMATRIX);\n    (void) WriteBlobLSBLong(image, (unsigned int) DataSize+padding+(is_gray ? 48 : 56));\n    (void) WriteBlobLSBLong(image, 0x6); /* 0x88 */\n    (void) WriteBlobLSBLong(image, 0x8); /* 0x8C */\n    (void) WriteBlobLSBLong(image, 0x6); /* 0x90 */  \n    (void) WriteBlobLSBLong(image, 0);   \n    (void) WriteBlobLSBLong(image, 0x5); /* 0x98 */\n    (void) WriteBlobLSBLong(image, is_gray ? 0x8 : 0xC); /* 0x9C - DimFlag */\n    (void) WriteBlobLSBLong(image, (unsigned int) image->rows);    /* x: 0xA0 */  \n    (void) WriteBlobLSBLong(image, (unsigned int) image->columns); /* y: 0xA4 */  \n    if(!is_gray)\n    {\n      (void) WriteBlobLSBLong(image, 3); /* z: 0xA8 */  \n      (void) WriteBlobLSBLong(image, 0);\n    }\n    (void) WriteBlobLSBShort(image, 1);  /* 0xB0 */  \n    (void) WriteBlobLSBShort(image, 1);  /* 0xB2 */\n    (void) WriteBlobLSBLong(image, 'M'); /* 0xB4 */\n    (void) WriteBlobLSBLong(image, 0x2); /* 0xB8 */  \n    (void) WriteBlobLSBLong(image, (unsigned int) DataSize); /* 0xBC */\n\n    /*\n      Store image data.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    do\n    {\n      for (y=0; y < (ssize_t)image->columns; y++)\n      {\n        p=GetVirtualPixels(image,y,0,1,image->rows,exception);\n        if (p == (const Quantum *) NULL)\n          break;\n        (void) ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n          z2qtype[z],pixels,exception);\n        (void) WriteBlob(image,image->rows,pixels);\n      }    \n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n    } while(z-- >= 2);\n    while(padding-->0) (void) WriteBlobByte(image,0);\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["coders/mat.c"], "buggy_code_start_loc": [870], "buggy_code_end_loc": [871], "fixing_code_start_loc": [870], "fixing_code_end_loc": [871], "type": "CWE-125", "message": "coders/mat.c in ImageMagick before 6.9.4-0 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted mat file.", "other": {"cve": {"id": "CVE-2016-10071", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-02T21:59:00.600", "lastModified": "2020-11-16T19:43:42.800", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "coders/mat.c in ImageMagick before 6.9.4-0 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted mat file."}, {"lang": "es", "value": "coders/mat.c en ImageMagick en versiones anteriores a 6.9.4-0 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites y ca\u00edda de aplicaci\u00f3n) a trav\u00e9s de un archivo mat manipulado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.9.3-10", "matchCriteriaId": "9EF469CF-DE38-4068-AA0D-1E0CDDB9A765"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/12/26/9", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95222", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1410513", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/1bc1fd0ff8c555841c78829217ac81fa0598255d", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/f3b483e8b054c50149912523b4773687e18afe25", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/1bc1fd0ff8c555841c78829217ac81fa0598255d"}}