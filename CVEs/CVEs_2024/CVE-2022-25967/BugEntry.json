{"buggy_code": ["// express is set like: app.engine('html', require('eta').renderFile)\n\nimport EtaErr from \"./err.ts\";\nimport compile from \"./compile.ts\";\nimport { getConfig } from \"./config.ts\";\nimport { getPath, readFile } from \"./file-utils.ts\";\nimport { copyProps } from \"./utils.ts\";\nimport { promiseImpl } from \"./polyfills.ts\";\n\n/* TYPES */\n\nimport type {\n  EtaConfig,\n  EtaConfigWithFilename,\n  PartialConfig,\n} from \"./config.ts\";\nimport type { TemplateFunction } from \"./compile.ts\";\n\nexport type CallbackFn = (err: Error | null, str?: string) => void;\n\ninterface DataObj {\n  /** Express.js settings may be stored here */\n  settings?: {\n    [key: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n  };\n  [key: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n}\n\ninterface PartialConfigWithFilename extends Partial<EtaConfig> {\n  filename: string;\n}\n\n/* END TYPES */\n\n/**\n * Reads a template, compiles it into a function, caches it if caching isn't disabled, returns the function\n *\n * @param filePath Absolute path to template file\n * @param options Eta configuration overrides\n * @param noCache Optionally, make Eta not cache the template\n */\n\nexport function loadFile(\n  filePath: string,\n  options: PartialConfigWithFilename,\n  noCache?: boolean,\n): TemplateFunction {\n  const config = getConfig(options);\n  const template = readFile(filePath);\n  try {\n    const compiledTemplate = compile(template, config);\n    if (!noCache) {\n      config.templates.define(\n        (config as EtaConfigWithFilename).filename,\n        compiledTemplate,\n      );\n    }\n    return compiledTemplate;\n  } catch (e) {\n    throw EtaErr(\n      \"Loading file: \" + filePath + \" failed:\\n\\n\" + (e as Error).message,\n    );\n  }\n}\n\n/**\n * Get the template from a string or a file, either compiled on-the-fly or\n * read from cache (if enabled), and cache the template if needed.\n *\n * If `options.cache` is true, this function reads the file from\n * `options.filename` so it must be set prior to calling this function.\n *\n * @param options   compilation options\n * @return Eta template function\n */\n\nfunction handleCache(options: EtaConfigWithFilename): TemplateFunction {\n  const filename = options.filename;\n\n  if (options.cache) {\n    const func = options.templates.get(filename);\n    if (func) {\n      return func;\n    }\n\n    return loadFile(filename, options);\n  }\n\n  // Caching is disabled, so pass noCache = true\n  return loadFile(filename, options, true);\n}\n\n/**\n * Try calling handleCache with the given options and data and call the\n * callback with the result. If an error occurs, call the callback with\n * the error. Used by renderFile().\n *\n * @param data template data\n * @param options compilation options\n * @param cb callback\n */\n\nfunction tryHandleCache(\n  data: object,\n  options: EtaConfigWithFilename,\n  cb: CallbackFn | undefined,\n) {\n  if (cb) {\n    try {\n      // Note: if there is an error while rendering the template,\n      // It will bubble up and be caught here\n      const templateFn = handleCache(options);\n      templateFn(data, options, cb);\n    } catch (err) {\n      return cb(err as Error);\n    }\n  } else {\n    // No callback, try returning a promise\n    if (typeof promiseImpl === \"function\") {\n      return new promiseImpl<string>(\n        function (resolve: Function, reject: Function) {\n          try {\n            const templateFn = handleCache(options);\n            const result = templateFn(data, options);\n            resolve(result);\n          } catch (err) {\n            reject(err);\n          }\n        },\n      );\n    } else {\n      throw EtaErr(\n        \"Please provide a callback function, this env doesn't support Promises\",\n      );\n    }\n  }\n}\n\n/**\n * Get the template function.\n *\n * If `options.cache` is `true`, then the template is cached.\n *\n * This returns a template function and the config object with which that template function should be called.\n *\n * @remarks\n *\n * It's important that this returns a config object with `filename` set.\n * Otherwise, the included file would not be able to use relative paths\n *\n * @param path path for the specified file (if relative, specify `views` on `options`)\n * @param options compilation options\n * @return [Eta template function, new config object]\n */\n\nfunction includeFile(\n  path: string,\n  options: EtaConfig,\n): [TemplateFunction, EtaConfig] {\n  // the below creates a new options object, using the parent filepath of the old options object and the path\n  const newFileOptions = getConfig(\n    { filename: getPath(path, options) },\n    options,\n  );\n  // TODO: make sure properties are currectly copied over\n  return [handleCache(newFileOptions as EtaConfigWithFilename), newFileOptions];\n}\n\n/**\n * Render a template from a filepath.\n *\n * @param filepath Path to template file. If relative, specify `views` on the config object\n *\n * This can take two different function signatures:\n *\n * - `renderFile(filename, dataAndConfig, [cb])`\n *   - Eta will merge `dataAndConfig` into `eta.config`\n * - `renderFile(filename, data, [config], [cb])`\n *\n * Note that renderFile does not immediately return the rendered result. If you pass in a callback function, it will be called with `(err, res)`. Otherwise, `renderFile` will return a `Promise` that resolves to the render result.\n *\n * **Examples**\n *\n * ```js\n * eta.renderFile(\"./template.eta\", data, {cache: true}, function (err, rendered) {\n *   if (err) console.log(err)\n *   console.log(rendered)\n * })\n *\n * let rendered = await eta.renderFile(\"./template.eta\", data, {cache: true})\n *\n * let rendered = await eta.renderFile(\"./template\", {...data, cache: true})\n * ```\n */\n\nfunction renderFile(\n  filename: string,\n  data: DataObj,\n  config?: PartialConfig,\n): Promise<string>;\n\nfunction renderFile(\n  filename: string,\n  data: DataObj,\n  config: PartialConfig,\n  cb: CallbackFn,\n): void;\n\nfunction renderFile(\n  filename: string,\n  data: DataObj,\n  config?: PartialConfig,\n  cb?: CallbackFn,\n): Promise<string> | void;\n\nfunction renderFile(filename: string, data: DataObj, cb: CallbackFn): void;\n\nfunction renderFile(\n  filename: string,\n  data: DataObj,\n  config?: PartialConfig,\n  cb?: CallbackFn,\n): Promise<string> | void {\n  /*\n  Here we have some function overloading.\n  Essentially, the first 2 arguments to renderFile should always be the filename and data\n  However, with Express, configuration options will be passed along with the data.\n  Thus, Express will call renderFile with (filename, dataAndOptions, cb)\n  And we want to also make (filename, data, options, cb) available\n  */\n\n  let renderConfig: EtaConfigWithFilename;\n  let callback: CallbackFn | undefined;\n  data = data || {}; // If data is undefined, we don't want accessing data.settings to error\n\n  // First, assign our callback function to `callback`\n  // We can leave it undefined if neither parameter is a function;\n  // Callbacks are optional\n  if (typeof cb === \"function\") {\n    // The 4th argument is the callback\n    callback = cb;\n  } else if (typeof config === \"function\") {\n    // The 3rd arg is the callback\n    callback = config;\n  }\n\n  // If there is a config object passed in explicitly, use it\n  if (typeof config === \"object\") {\n    renderConfig = getConfig(\n      (config as PartialConfig) || {},\n    ) as EtaConfigWithFilename;\n  } else {\n    // Otherwise, get the config from the data object\n    // And then grab some config options from data.settings\n    // Which is where Express sometimes stores them\n    renderConfig = getConfig(data as PartialConfig) as EtaConfigWithFilename;\n    if (data.settings) {\n      // Pull a few things from known locations\n      if (data.settings.views) {\n        renderConfig.views = data.settings.views;\n      }\n      if (data.settings[\"view cache\"]) {\n        renderConfig.cache = true;\n      }\n      // Undocumented after Express 2, but still usable, esp. for\n      // items that are unsafe to be passed along with data, like `root`\n      const viewOpts = data.settings[\"view options\"];\n\n      if (viewOpts) {\n        copyProps(renderConfig, viewOpts);\n      }\n    }\n  }\n\n  // Set the filename option on the template\n  // This will first try to resolve the file path (see getPath for details)\n  renderConfig.filename = getPath(filename, renderConfig);\n\n  return tryHandleCache(data, renderConfig, callback);\n}\n\n/**\n * Render a template from a filepath asynchronously.\n *\n * @param filepath Path to template file. If relative, specify `views` on the config object\n *\n * This can take two different function signatures:\n *\n * - `renderFile(filename, dataAndConfig, [cb])`\n *   - Eta will merge `dataAndConfig` into `eta.config`\n * - `renderFile(filename, data, [config], [cb])`\n *\n * Note that renderFile does not immediately return the rendered result. If you pass in a callback function, it will be called with `(err, res)`. Otherwise, `renderFile` will return a `Promise` that resolves to the render result.\n *\n * **Examples**\n *\n * ```js\n * eta.renderFile(\"./template.eta\", data, {cache: true}, function (err, rendered) {\n *   if (err) console.log(err)\n *   console.log(rendered)\n * })\n *\n * let rendered = await eta.renderFile(\"./template.eta\", data, {cache: true})\n *\n * let rendered = await eta.renderFile(\"./template\", {...data, cache: true})\n * ```\n */\n\nfunction renderFileAsync(\n  filename: string,\n  data: DataObj,\n  config?: PartialConfig,\n): Promise<string>;\n\nfunction renderFileAsync(\n  filename: string,\n  data: DataObj,\n  config: PartialConfig,\n  cb: CallbackFn,\n): void;\n\nfunction renderFileAsync(\n  filename: string,\n  data: DataObj,\n  config?: PartialConfig,\n  cb?: CallbackFn,\n): Promise<string> | void;\n\nfunction renderFileAsync(filename: string, data: DataObj, cb: CallbackFn): void;\n\nfunction renderFileAsync(\n  filename: string,\n  data: DataObj,\n  config?: PartialConfig,\n  cb?: CallbackFn,\n): Promise<string> | void {\n  return renderFile(\n    filename,\n    typeof config === \"function\" ? { ...data, async: true } : data,\n    typeof config === \"object\" ? { ...config, async: true } : config,\n    cb,\n  );\n}\n\nexport { includeFile, renderFile, renderFileAsync };\n", "// express is set like: app.engine('html', require('eta').renderFile)\n\nimport EtaErr from \"./err.js\";\nimport compile from \"./compile.js\";\nimport { getConfig } from \"./config.js\";\nimport { getPath, readFile } from \"./file-utils.js\";\nimport { copyProps } from \"./utils.js\";\nimport { promiseImpl } from \"./polyfills.js\";\n\n/* TYPES */\n\nimport type { EtaConfig, PartialConfig, EtaConfigWithFilename } from \"./config.js\";\nimport type { TemplateFunction } from \"./compile.js\";\n\nexport type CallbackFn = (err: Error | null, str?: string) => void;\n\ninterface DataObj {\n  /** Express.js settings may be stored here */\n  settings?: {\n    [key: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n  };\n  [key: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n}\n\ninterface PartialConfigWithFilename extends Partial<EtaConfig> {\n  filename: string;\n}\n\n/* END TYPES */\n\n/**\n * Reads a template, compiles it into a function, caches it if caching isn't disabled, returns the function\n *\n * @param filePath Absolute path to template file\n * @param options Eta configuration overrides\n * @param noCache Optionally, make Eta not cache the template\n */\n\nexport function loadFile(\n  filePath: string,\n  options: PartialConfigWithFilename,\n  noCache?: boolean\n): TemplateFunction {\n  const config = getConfig(options);\n  const template = readFile(filePath);\n  try {\n    const compiledTemplate = compile(template, config);\n    if (!noCache) {\n      config.templates.define((config as EtaConfigWithFilename).filename, compiledTemplate);\n    }\n    return compiledTemplate;\n  } catch (e) {\n    throw EtaErr(\"Loading file: \" + filePath + \" failed:\\n\\n\" + (e as Error).message);\n  }\n}\n\n/**\n * Get the template from a string or a file, either compiled on-the-fly or\n * read from cache (if enabled), and cache the template if needed.\n *\n * If `options.cache` is true, this function reads the file from\n * `options.filename` so it must be set prior to calling this function.\n *\n * @param options   compilation options\n * @return Eta template function\n */\n\nfunction handleCache(options: EtaConfigWithFilename): TemplateFunction {\n  const filename = options.filename;\n\n  if (options.cache) {\n    const func = options.templates.get(filename);\n    if (func) {\n      return func;\n    }\n\n    return loadFile(filename, options);\n  }\n\n  // Caching is disabled, so pass noCache = true\n  return loadFile(filename, options, true);\n}\n\n/**\n * Try calling handleCache with the given options and data and call the\n * callback with the result. If an error occurs, call the callback with\n * the error. Used by renderFile().\n *\n * @param data template data\n * @param options compilation options\n * @param cb callback\n */\n\nfunction tryHandleCache(data: object, options: EtaConfigWithFilename, cb: CallbackFn | undefined) {\n  if (cb) {\n    try {\n      // Note: if there is an error while rendering the template,\n      // It will bubble up and be caught here\n      const templateFn = handleCache(options);\n      templateFn(data, options, cb);\n    } catch (err) {\n      return cb(err as Error);\n    }\n  } else {\n    // No callback, try returning a promise\n    if (typeof promiseImpl === \"function\") {\n      return new promiseImpl<string>(function (resolve: Function, reject: Function) {\n        try {\n          const templateFn = handleCache(options);\n          const result = templateFn(data, options);\n          resolve(result);\n        } catch (err) {\n          reject(err);\n        }\n      });\n    } else {\n      throw EtaErr(\"Please provide a callback function, this env doesn't support Promises\");\n    }\n  }\n}\n\n/**\n * Get the template function.\n *\n * If `options.cache` is `true`, then the template is cached.\n *\n * This returns a template function and the config object with which that template function should be called.\n *\n * @remarks\n *\n * It's important that this returns a config object with `filename` set.\n * Otherwise, the included file would not be able to use relative paths\n *\n * @param path path for the specified file (if relative, specify `views` on `options`)\n * @param options compilation options\n * @return [Eta template function, new config object]\n */\n\nfunction includeFile(path: string, options: EtaConfig): [TemplateFunction, EtaConfig] {\n  // the below creates a new options object, using the parent filepath of the old options object and the path\n  const newFileOptions = getConfig({ filename: getPath(path, options) }, options);\n  // TODO: make sure properties are currectly copied over\n  return [handleCache(newFileOptions as EtaConfigWithFilename), newFileOptions];\n}\n\n/**\n * Render a template from a filepath.\n *\n * @param filepath Path to template file. If relative, specify `views` on the config object\n *\n * This can take two different function signatures:\n *\n * - `renderFile(filename, dataAndConfig, [cb])`\n *   - Eta will merge `dataAndConfig` into `eta.config`\n * - `renderFile(filename, data, [config], [cb])`\n *\n * Note that renderFile does not immediately return the rendered result. If you pass in a callback function, it will be called with `(err, res)`. Otherwise, `renderFile` will return a `Promise` that resolves to the render result.\n *\n * **Examples**\n *\n * ```js\n * eta.renderFile(\"./template.eta\", data, {cache: true}, function (err, rendered) {\n *   if (err) console.log(err)\n *   console.log(rendered)\n * })\n *\n * let rendered = await eta.renderFile(\"./template.eta\", data, {cache: true})\n *\n * let rendered = await eta.renderFile(\"./template\", {...data, cache: true})\n * ```\n */\n\nfunction renderFile(filename: string, data: DataObj, config?: PartialConfig): Promise<string>;\n\nfunction renderFile(filename: string, data: DataObj, config: PartialConfig, cb: CallbackFn): void;\n\nfunction renderFile(\n  filename: string,\n  data: DataObj,\n  config?: PartialConfig,\n  cb?: CallbackFn\n): Promise<string> | void;\n\nfunction renderFile(filename: string, data: DataObj, cb: CallbackFn): void;\n\nfunction renderFile(\n  filename: string,\n  data: DataObj,\n  config?: PartialConfig,\n  cb?: CallbackFn\n): Promise<string> | void {\n  /*\n  Here we have some function overloading.\n  Essentially, the first 2 arguments to renderFile should always be the filename and data\n  However, with Express, configuration options will be passed along with the data.\n  Thus, Express will call renderFile with (filename, dataAndOptions, cb)\n  And we want to also make (filename, data, options, cb) available\n  */\n\n  let renderConfig: EtaConfigWithFilename;\n  let callback: CallbackFn | undefined;\n  data = data || {}; // If data is undefined, we don't want accessing data.settings to error\n\n  // First, assign our callback function to `callback`\n  // We can leave it undefined if neither parameter is a function;\n  // Callbacks are optional\n  if (typeof cb === \"function\") {\n    // The 4th argument is the callback\n    callback = cb;\n  } else if (typeof config === \"function\") {\n    // The 3rd arg is the callback\n    callback = config;\n  }\n\n  // If there is a config object passed in explicitly, use it\n  if (typeof config === \"object\") {\n    renderConfig = getConfig((config as PartialConfig) || {}) as EtaConfigWithFilename;\n  } else {\n    // Otherwise, get the config from the data object\n    // And then grab some config options from data.settings\n    // Which is where Express sometimes stores them\n    renderConfig = getConfig(data as PartialConfig) as EtaConfigWithFilename;\n    if (data.settings) {\n      // Pull a few things from known locations\n      if (data.settings.views) {\n        renderConfig.views = data.settings.views;\n      }\n      if (data.settings[\"view cache\"]) {\n        renderConfig.cache = true;\n      }\n      // Undocumented after Express 2, but still usable, esp. for\n      // items that are unsafe to be passed along with data, like `root`\n      const viewOpts = data.settings[\"view options\"];\n\n      if (viewOpts) {\n        copyProps(renderConfig, viewOpts);\n      }\n    }\n  }\n\n  // Set the filename option on the template\n  // This will first try to resolve the file path (see getPath for details)\n  renderConfig.filename = getPath(filename, renderConfig);\n\n  return tryHandleCache(data, renderConfig, callback);\n}\n\n/**\n * Render a template from a filepath asynchronously.\n *\n * @param filepath Path to template file. If relative, specify `views` on the config object\n *\n * This can take two different function signatures:\n *\n * - `renderFile(filename, dataAndConfig, [cb])`\n *   - Eta will merge `dataAndConfig` into `eta.config`\n * - `renderFile(filename, data, [config], [cb])`\n *\n * Note that renderFile does not immediately return the rendered result. If you pass in a callback function, it will be called with `(err, res)`. Otherwise, `renderFile` will return a `Promise` that resolves to the render result.\n *\n * **Examples**\n *\n * ```js\n * eta.renderFile(\"./template.eta\", data, {cache: true}, function (err, rendered) {\n *   if (err) console.log(err)\n *   console.log(rendered)\n * })\n *\n * let rendered = await eta.renderFile(\"./template.eta\", data, {cache: true})\n *\n * let rendered = await eta.renderFile(\"./template\", {...data, cache: true})\n * ```\n */\n\nfunction renderFileAsync(filename: string, data: DataObj, config?: PartialConfig): Promise<string>;\n\nfunction renderFileAsync(\n  filename: string,\n  data: DataObj,\n  config: PartialConfig,\n  cb: CallbackFn\n): void;\n\nfunction renderFileAsync(\n  filename: string,\n  data: DataObj,\n  config?: PartialConfig,\n  cb?: CallbackFn\n): Promise<string> | void;\n\nfunction renderFileAsync(filename: string, data: DataObj, cb: CallbackFn): void;\n\nfunction renderFileAsync(\n  filename: string,\n  data: DataObj,\n  config?: PartialConfig,\n  cb?: CallbackFn\n): Promise<string> | void {\n  return renderFile(\n    filename,\n    typeof config === \"function\" ? { ...data, async: true } : data,\n    typeof config === \"object\" ? { ...config, async: true } : config,\n    cb\n  );\n}\n\nexport { includeFile, renderFile, renderFileAsync };\n", "/* global it, expect, describe */\n\nimport { renderFile, renderFileAsync, __express, templates, compile } from \"../src/index\";\n\nimport { buildRegEx } from \"./err.spec\";\n\nconst path = require(\"path\"),\n  filePath = path.join(__dirname, \"templates/simple.eta\"),\n  errFilePath = path.join(__dirname, \"templates/badsyntax.eta\"),\n  fakeFilePath = path.join(__dirname, \"templates/fake.eta\");\n\ndescribe(\"Simple renderFile tests\", () => {\n  it(\"renders a simple template file\", async () => {\n    const renderedFile = await renderFile(filePath, { name: \"Ben\" });\n\n    expect(renderedFile).toEqual(\"Hi Ben\");\n  });\n\n  it(\"renderFile is aliased as __express\", async () => {\n    const renderedFile = await __express(filePath, { name: \"Ben\" });\n\n    expect(renderedFile).toEqual(\"Hi Ben\");\n  });\n\n  it(\"renders async template with callback\", (done) => {\n    function cb(_err: Error | null, res?: string) {\n      try {\n        expect(res).toBe(\"Hi Ada Lovelace\");\n        done();\n      } catch (error) {\n        done(error);\n      }\n    }\n\n    renderFile(filePath, { name: \"Ada Lovelace\", async: true }, cb);\n  });\n\n  it(\"renders a simple template w/ a callback\", async () => {\n    renderFile(filePath, { name: \"Ben\" }, function (_err: Error | null, res?: string) {\n      expect(res).toEqual(\"Hi Ben\");\n    });\n  });\n\n  it(\"renders a simple template w/ callback and explicit config\", async () => {\n    // Note that rmWhitespace doesn't do anything specific\n    renderFile(\n      filePath,\n      { name: \"Ben\" },\n      { rmWhitespace: true },\n      function (_err: Error | null, res?: string) {\n        expect(res).toEqual(\"Hi Ben\");\n      }\n    );\n  });\n\n  it(\"renders an async template using Promises\", async () => {\n    const res = await renderFile(filePath, { name: \"Ada\", async: true });\n    expect(res).toEqual(\"Hi Ada\");\n  });\n\n  it(\"renders an async template with an explicit config using Promises\", async () => {\n    const res = await renderFile(filePath, { name: \"Ada\" }, { async: true });\n    expect(res).toEqual(\"Hi Ada\");\n  });\n\n  it(\"uses cached version of a file\", async () => {\n    templates.define(fakeFilePath, compile(\"This template does not exist\"));\n\n    // renderFile should just look straight in the cache for the template\n    renderFile(fakeFilePath, { cache: true }, function (_err: Error | null, res?: string) {\n      expect(res).toEqual(\"This template does not exist\");\n    });\n  });\n\n  it(\"parses a simple template w/ settings from Express\", async () => {\n    renderFile(\n      filePath,\n      {\n        name: \"<p>Ben</p>\",\n        cache: true,\n        settings: {\n          views: [path.join(__dirname, \"templates\"), path.join(__dirname, \"othertemplates\")],\n          \"view cache\": true,\n          \"view options\": { autoEscape: false },\n        },\n      },\n      function (_err: Error | null, res?: string) {\n        expect(res).toEqual(\"Hi <p>Ben</p>\");\n      }\n    );\n  });\n});\n\ndescribe(\"File location tests\", () => {\n  it(\"locates a file with the views option\", async () => {\n    const res = await renderFile(\n      \"simple.eta\",\n      { name: \"Ada\" },\n      { views: path.join(__dirname, \"templates\") }\n    );\n\n    expect(res).toEqual(\"Hi Ada\");\n  });\n});\n\ndescribe(\"renderFile error tests\", () => {\n  it(\"render file with callback works on error\", (done) => {\n    function cb(err: Error, _res?: string) {\n      expect(err).toBeTruthy();\n      expect(err.message).toMatch(\n        buildRegEx(`\nvar tR='',__l,__lP,include=E.include.bind(E),includeFile=E.includeFile.bind(E)\nfunction layout(p,d){__l=p;__lP=d}\ntR+='Hi '\ntR+=E.e(badSyntax(=!)\nif(__l)tR=await includeFile(__l,Object.assign(it,{body:tR},__lP))\nif(cb){cb(null,tR)} return tR\n`)\n      );\n      done();\n    }\n\n    renderFile(errFilePath, { name: \"Ada Lovelace\", async: true }, cb);\n  });\n\n  test(\"throws with bad inner JS syntax using Promises\", async () => {\n    await expect(async () => {\n      await renderFile(errFilePath, {});\n    }).rejects.toThrow(\n      buildRegEx(`\nvar tR='',__l,__lP,include=E.include.bind(E),includeFile=E.includeFile.bind(E)\nfunction layout(p,d){__l=p;__lP=d}\ntR+='Hi '\ntR+=E.e(badSyntax(=!)\nif(__l)tR=includeFile(__l,Object.assign(it,{body:tR},__lP))\nif(cb){cb(null,tR)} return tR\n`)\n    );\n  });\n});\n\ndescribe(\"renderFileAsync function\", () => {\n  it(\"should render properly\", async () => {\n    expect(await renderFileAsync(filePath, { name: \"foo\" })).toBe(\"Hi foo\");\n  });\n});\n\n// NOTE: the errors will really look like this:\n\n/*\nLoading file: /home/nebrelbug/Coding/eta/test/templates/badsyntax.eta failed:\n\nBad template syntax\n\nUnexpected token '='\n====================\nvar tR='',__l,__lP,include=E.include.bind(E),includeFile=E.includeFile.bind(E)\nfunction layout(p,d){__l=p;__lP=d}\ntR+='Hi '\ntR+=E.e(badSyntax(=!)\nif(__l)tR=includeFile(__l,Object.assign(it,{body:tR},__lP))\nif(cb){cb(null,tR)} return tR\n*/\n\n// Unfortunately, Node throws different errors (\"Unexpected token '='\", \"Unexpected token =\", \"Invalid or unexpected token\") depending on the version so we can't test against the first part of the string.\n"], "fixing_code": ["// express is set like: app.engine('html', require('eta').renderFile)\n\nimport EtaErr from \"./err.ts\";\nimport compile from \"./compile.ts\";\nimport { getConfig } from \"./config.ts\";\nimport { getPath, readFile } from \"./file-utils.ts\";\nimport { promiseImpl } from \"./polyfills.ts\";\n\n/* TYPES */\n\nimport type {\n  EtaConfig,\n  EtaConfigWithFilename,\n  PartialConfig,\n} from \"./config.ts\";\nimport type { TemplateFunction } from \"./compile.ts\";\n\nexport type CallbackFn = (err: Error | null, str?: string) => void;\n\ninterface DataObj {\n  [key: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n}\n\ninterface PartialConfigWithFilename extends Partial<EtaConfig> {\n  filename: string;\n}\n\n/* END TYPES */\n\n/**\n * Reads a template, compiles it into a function, caches it if caching isn't disabled, returns the function\n *\n * @param filePath Absolute path to template file\n * @param options Eta configuration overrides\n * @param noCache Optionally, make Eta not cache the template\n */\n\nexport function loadFile(\n  filePath: string,\n  options: PartialConfigWithFilename,\n  noCache?: boolean,\n): TemplateFunction {\n  const config = getConfig(options);\n  const template = readFile(filePath);\n  try {\n    const compiledTemplate = compile(template, config);\n    if (!noCache) {\n      config.templates.define(\n        (config as EtaConfigWithFilename).filename,\n        compiledTemplate,\n      );\n    }\n    return compiledTemplate;\n  } catch (e) {\n    throw EtaErr(\n      \"Loading file: \" + filePath + \" failed:\\n\\n\" + (e as Error).message,\n    );\n  }\n}\n\n/**\n * Get the template from a string or a file, either compiled on-the-fly or\n * read from cache (if enabled), and cache the template if needed.\n *\n * If `options.cache` is true, this function reads the file from\n * `options.filename` so it must be set prior to calling this function.\n *\n * @param options   compilation options\n * @return Eta template function\n */\n\nfunction handleCache(options: EtaConfigWithFilename): TemplateFunction {\n  const filename = options.filename;\n\n  if (options.cache) {\n    const func = options.templates.get(filename);\n    if (func) {\n      return func;\n    }\n\n    return loadFile(filename, options);\n  }\n\n  // Caching is disabled, so pass noCache = true\n  return loadFile(filename, options, true);\n}\n\n/**\n * Try calling handleCache with the given options and data and call the\n * callback with the result. If an error occurs, call the callback with\n * the error. Used by renderFile().\n *\n * @param data template data\n * @param options compilation options\n * @param cb callback\n */\n\nfunction tryHandleCache(\n  data: object,\n  options: EtaConfigWithFilename,\n  cb: CallbackFn | undefined,\n) {\n  if (cb) {\n    try {\n      // Note: if there is an error while rendering the template,\n      // It will bubble up and be caught here\n      const templateFn = handleCache(options);\n      templateFn(data, options, cb);\n    } catch (err) {\n      return cb(err as Error);\n    }\n  } else {\n    // No callback, try returning a promise\n    if (typeof promiseImpl === \"function\") {\n      return new promiseImpl<string>(\n        function (resolve: Function, reject: Function) {\n          try {\n            const templateFn = handleCache(options);\n            const result = templateFn(data, options);\n            resolve(result);\n          } catch (err) {\n            reject(err);\n          }\n        },\n      );\n    } else {\n      throw EtaErr(\n        \"Please provide a callback function, this env doesn't support Promises\",\n      );\n    }\n  }\n}\n\n/**\n * Get the template function.\n *\n * If `options.cache` is `true`, then the template is cached.\n *\n * This returns a template function and the config object with which that template function should be called.\n *\n * @remarks\n *\n * It's important that this returns a config object with `filename` set.\n * Otherwise, the included file would not be able to use relative paths\n *\n * @param path path for the specified file (if relative, specify `views` on `options`)\n * @param options compilation options\n * @return [Eta template function, new config object]\n */\n\nfunction includeFile(\n  path: string,\n  options: EtaConfig,\n): [TemplateFunction, EtaConfig] {\n  // the below creates a new options object, using the parent filepath of the old options object and the path\n  const newFileOptions = getConfig(\n    { filename: getPath(path, options) },\n    options,\n  );\n  // TODO: make sure properties are currectly copied over\n  return [handleCache(newFileOptions as EtaConfigWithFilename), newFileOptions];\n}\n\n/**\n * Render a template from a filepath.\n *\n * @param filepath Path to template file. If relative, specify `views` on the config object\n *\n * This can take two different function signatures:\n *\n * - `renderFile(filename, data, [cb])`\n * - `renderFile(filename, data, [config], [cb])`\n *\n * Note that renderFile does not immediately return the rendered result. If you pass in a callback function, it will be called with `(err, res)`. Otherwise, `renderFile` will return a `Promise` that resolves to the render result.\n *\n * **Examples**\n *\n * ```js\n * eta.renderFile(\"./template.eta\", data, {cache: true}, function (err, rendered) {\n *   if (err) console.log(err)\n *   console.log(rendered)\n * })\n *\n * let rendered = await eta.renderFile(\"./template.eta\", data, {cache: true})\n *\n * ```\n */\n\nfunction renderFile(\n  filename: string,\n  data: DataObj,\n  config?: PartialConfig,\n): Promise<string>;\n\nfunction renderFile(\n  filename: string,\n  data: DataObj,\n  config: PartialConfig,\n  cb: CallbackFn,\n): void;\n\nfunction renderFile(\n  filename: string,\n  data: DataObj,\n  config?: PartialConfig,\n  cb?: CallbackFn,\n): Promise<string> | void;\n\nfunction renderFile(filename: string, data: DataObj, cb: CallbackFn): void;\n\nfunction renderFile(\n  filename: string,\n  data: DataObj,\n  config?: PartialConfig,\n  cb?: CallbackFn,\n): Promise<string> | void {\n  /*\n  Here we have some function overloading.\n  Essentially, the first 2 arguments to renderFile should always be the filename and data\n  Express will call renderFile with (filename, data, cb)\n  We also want to make (filename, data, options, cb) available\n  */\n\n  let renderConfig: EtaConfigWithFilename;\n  let callback: CallbackFn | undefined;\n  data = data || {};\n\n  // First, assign our callback function to `callback`\n  // We can leave it undefined if neither parameter is a function;\n  // Callbacks are optional\n  if (typeof cb === \"function\") {\n    // The 4th argument is the callback\n    callback = cb;\n  } else if (typeof config === \"function\") {\n    // The 3rd arg is the callback\n    callback = config;\n  }\n\n  // If there is a config object passed in explicitly, use it\n  if (typeof config === \"object\") {\n    renderConfig = getConfig(\n      (config as PartialConfig) || {},\n    ) as EtaConfigWithFilename;\n  } else {\n    // Otherwise, get the default config\n    renderConfig = getConfig({}) as EtaConfigWithFilename;\n  }\n\n  // Set the filename option on the template\n  // This will first try to resolve the file path (see getPath for details)\n  renderConfig.filename = getPath(filename, renderConfig);\n\n  return tryHandleCache(data, renderConfig, callback);\n}\n\n/**\n * Render a template from a filepath asynchronously.\n *\n * @param filepath Path to template file. If relative, specify `views` on the config object\n *\n * This can take two different function signatures:\n *\n * - `renderFile(filename, data, [cb])`\n * - `renderFile(filename, data, [config], [cb])`\n *\n * Note that renderFile does not immediately return the rendered result. If you pass in a callback function, it will be called with `(err, res)`. Otherwise, `renderFile` will return a `Promise` that resolves to the render result.\n *\n * **Examples**\n *\n * ```js\n * eta.renderFile(\"./template.eta\", data, {cache: true}, function (err, rendered) {\n *   if (err) console.log(err)\n *   console.log(rendered)\n * })\n *\n * let rendered = await eta.renderFile(\"./template.eta\", data, {cache: true})\n *\n * ```\n */\n\nfunction renderFileAsync(\n  filename: string,\n  data: DataObj,\n  config?: PartialConfig,\n): Promise<string>;\n\nfunction renderFileAsync(\n  filename: string,\n  data: DataObj,\n  config: PartialConfig,\n  cb: CallbackFn,\n): void;\n\nfunction renderFileAsync(\n  filename: string,\n  data: DataObj,\n  config?: PartialConfig,\n  cb?: CallbackFn,\n): Promise<string> | void;\n\nfunction renderFileAsync(filename: string, data: DataObj, cb: CallbackFn): void;\n\nfunction renderFileAsync(\n  filename: string,\n  data: DataObj,\n  config?: PartialConfig,\n  cb?: CallbackFn,\n): Promise<string> | void {\n  return renderFile(\n    filename,\n    typeof config === \"function\" ? { ...data, async: true } : data,\n    typeof config === \"object\" ? { ...config, async: true } : config,\n    cb,\n  );\n}\n\nexport { includeFile, renderFile, renderFileAsync };\n", "// express is set like: app.engine('html', require('eta').renderFile)\n\nimport EtaErr from \"./err.js\";\nimport compile from \"./compile.js\";\nimport { getConfig } from \"./config.js\";\nimport { getPath, readFile } from \"./file-utils.js\";\nimport { promiseImpl } from \"./polyfills.js\";\n\n/* TYPES */\n\nimport type { EtaConfig, PartialConfig, EtaConfigWithFilename } from \"./config.js\";\nimport type { TemplateFunction } from \"./compile.js\";\n\nexport type CallbackFn = (err: Error | null, str?: string) => void;\n\ninterface DataObj {\n  [key: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n}\n\ninterface PartialConfigWithFilename extends Partial<EtaConfig> {\n  filename: string;\n}\n\n/* END TYPES */\n\n/**\n * Reads a template, compiles it into a function, caches it if caching isn't disabled, returns the function\n *\n * @param filePath Absolute path to template file\n * @param options Eta configuration overrides\n * @param noCache Optionally, make Eta not cache the template\n */\n\nexport function loadFile(\n  filePath: string,\n  options: PartialConfigWithFilename,\n  noCache?: boolean\n): TemplateFunction {\n  const config = getConfig(options);\n  const template = readFile(filePath);\n  try {\n    const compiledTemplate = compile(template, config);\n    if (!noCache) {\n      config.templates.define((config as EtaConfigWithFilename).filename, compiledTemplate);\n    }\n    return compiledTemplate;\n  } catch (e) {\n    throw EtaErr(\"Loading file: \" + filePath + \" failed:\\n\\n\" + (e as Error).message);\n  }\n}\n\n/**\n * Get the template from a string or a file, either compiled on-the-fly or\n * read from cache (if enabled), and cache the template if needed.\n *\n * If `options.cache` is true, this function reads the file from\n * `options.filename` so it must be set prior to calling this function.\n *\n * @param options   compilation options\n * @return Eta template function\n */\n\nfunction handleCache(options: EtaConfigWithFilename): TemplateFunction {\n  const filename = options.filename;\n\n  if (options.cache) {\n    const func = options.templates.get(filename);\n    if (func) {\n      return func;\n    }\n\n    return loadFile(filename, options);\n  }\n\n  // Caching is disabled, so pass noCache = true\n  return loadFile(filename, options, true);\n}\n\n/**\n * Try calling handleCache with the given options and data and call the\n * callback with the result. If an error occurs, call the callback with\n * the error. Used by renderFile().\n *\n * @param data template data\n * @param options compilation options\n * @param cb callback\n */\n\nfunction tryHandleCache(data: object, options: EtaConfigWithFilename, cb: CallbackFn | undefined) {\n  if (cb) {\n    try {\n      // Note: if there is an error while rendering the template,\n      // It will bubble up and be caught here\n      const templateFn = handleCache(options);\n      templateFn(data, options, cb);\n    } catch (err) {\n      return cb(err as Error);\n    }\n  } else {\n    // No callback, try returning a promise\n    if (typeof promiseImpl === \"function\") {\n      return new promiseImpl<string>(function (resolve: Function, reject: Function) {\n        try {\n          const templateFn = handleCache(options);\n          const result = templateFn(data, options);\n          resolve(result);\n        } catch (err) {\n          reject(err);\n        }\n      });\n    } else {\n      throw EtaErr(\"Please provide a callback function, this env doesn't support Promises\");\n    }\n  }\n}\n\n/**\n * Get the template function.\n *\n * If `options.cache` is `true`, then the template is cached.\n *\n * This returns a template function and the config object with which that template function should be called.\n *\n * @remarks\n *\n * It's important that this returns a config object with `filename` set.\n * Otherwise, the included file would not be able to use relative paths\n *\n * @param path path for the specified file (if relative, specify `views` on `options`)\n * @param options compilation options\n * @return [Eta template function, new config object]\n */\n\nfunction includeFile(path: string, options: EtaConfig): [TemplateFunction, EtaConfig] {\n  // the below creates a new options object, using the parent filepath of the old options object and the path\n  const newFileOptions = getConfig({ filename: getPath(path, options) }, options);\n  // TODO: make sure properties are currectly copied over\n  return [handleCache(newFileOptions as EtaConfigWithFilename), newFileOptions];\n}\n\n/**\n * Render a template from a filepath.\n *\n * @param filepath Path to template file. If relative, specify `views` on the config object\n *\n * This can take two different function signatures:\n *\n * - `renderFile(filename, data, [cb])`\n * - `renderFile(filename, data, [config], [cb])`\n *\n * Note that renderFile does not immediately return the rendered result. If you pass in a callback function, it will be called with `(err, res)`. Otherwise, `renderFile` will return a `Promise` that resolves to the render result.\n *\n * **Examples**\n *\n * ```js\n * eta.renderFile(\"./template.eta\", data, {cache: true}, function (err, rendered) {\n *   if (err) console.log(err)\n *   console.log(rendered)\n * })\n *\n * let rendered = await eta.renderFile(\"./template.eta\", data, {cache: true})\n *\n * ```\n */\n\nfunction renderFile(filename: string, data: DataObj, config?: PartialConfig): Promise<string>;\n\nfunction renderFile(filename: string, data: DataObj, config: PartialConfig, cb: CallbackFn): void;\n\nfunction renderFile(\n  filename: string,\n  data: DataObj,\n  config?: PartialConfig,\n  cb?: CallbackFn\n): Promise<string> | void;\n\nfunction renderFile(filename: string, data: DataObj, cb: CallbackFn): void;\n\nfunction renderFile(\n  filename: string,\n  data: DataObj,\n  config?: PartialConfig,\n  cb?: CallbackFn\n): Promise<string> | void {\n  /*\n  Here we have some function overloading.\n  Essentially, the first 2 arguments to renderFile should always be the filename and data\n  Express will call renderFile with (filename, data, cb)\n  We also want to make (filename, data, options, cb) available\n  */\n\n  let renderConfig: EtaConfigWithFilename;\n  let callback: CallbackFn | undefined;\n  data = data || {};\n\n  // First, assign our callback function to `callback`\n  // We can leave it undefined if neither parameter is a function;\n  // Callbacks are optional\n  if (typeof cb === \"function\") {\n    // The 4th argument is the callback\n    callback = cb;\n  } else if (typeof config === \"function\") {\n    // The 3rd arg is the callback\n    callback = config;\n  }\n\n  // If there is a config object passed in explicitly, use it\n  if (typeof config === \"object\") {\n    renderConfig = getConfig((config as PartialConfig) || {}) as EtaConfigWithFilename;\n  } else {\n    // Otherwise, get the default config\n    renderConfig = getConfig({}) as EtaConfigWithFilename;\n  }\n\n  // Set the filename option on the template\n  // This will first try to resolve the file path (see getPath for details)\n  renderConfig.filename = getPath(filename, renderConfig);\n\n  return tryHandleCache(data, renderConfig, callback);\n}\n\n/**\n * Render a template from a filepath asynchronously.\n *\n * @param filepath Path to template file. If relative, specify `views` on the config object\n *\n * This can take two different function signatures:\n *\n * - `renderFile(filename, data, [cb])`\n * - `renderFile(filename, data, [config], [cb])`\n *\n * Note that renderFile does not immediately return the rendered result. If you pass in a callback function, it will be called with `(err, res)`. Otherwise, `renderFile` will return a `Promise` that resolves to the render result.\n *\n * **Examples**\n *\n * ```js\n * eta.renderFile(\"./template.eta\", data, {cache: true}, function (err, rendered) {\n *   if (err) console.log(err)\n *   console.log(rendered)\n * })\n *\n * let rendered = await eta.renderFile(\"./template.eta\", data, {cache: true})\n *\n * ```\n */\n\nfunction renderFileAsync(filename: string, data: DataObj, config?: PartialConfig): Promise<string>;\n\nfunction renderFileAsync(\n  filename: string,\n  data: DataObj,\n  config: PartialConfig,\n  cb: CallbackFn\n): void;\n\nfunction renderFileAsync(\n  filename: string,\n  data: DataObj,\n  config?: PartialConfig,\n  cb?: CallbackFn\n): Promise<string> | void;\n\nfunction renderFileAsync(filename: string, data: DataObj, cb: CallbackFn): void;\n\nfunction renderFileAsync(\n  filename: string,\n  data: DataObj,\n  config?: PartialConfig,\n  cb?: CallbackFn\n): Promise<string> | void {\n  return renderFile(\n    filename,\n    typeof config === \"function\" ? { ...data, async: true } : data,\n    typeof config === \"object\" ? { ...config, async: true } : config,\n    cb\n  );\n}\n\nexport { includeFile, renderFile, renderFileAsync };\n", "/* global it, expect, describe */\n\nimport { renderFile, renderFileAsync, __express, templates, compile } from \"../src/index\";\n\nimport { buildRegEx } from \"./err.spec\";\n\nconst path = require(\"path\"),\n  filePath = path.join(__dirname, \"templates/simple.eta\"),\n  errFilePath = path.join(__dirname, \"templates/badsyntax.eta\"),\n  fakeFilePath = path.join(__dirname, \"templates/fake.eta\");\n\ndescribe(\"Simple renderFile tests\", () => {\n  it(\"renders a simple template file\", async () => {\n    const renderedFile = await renderFile(filePath, { name: \"Ben\" });\n\n    expect(renderedFile).toEqual(\"Hi Ben\");\n  });\n\n  it(\"renderFile is aliased as __express\", async () => {\n    const renderedFile = await __express(filePath, { name: \"Ben\" });\n\n    expect(renderedFile).toEqual(\"Hi Ben\");\n  });\n\n  it(\"renders async template with callback\", (done) => {\n    function cb(_err: Error | null, res?: string) {\n      try {\n        expect(res).toBe(\"Hi Ada Lovelace\");\n        done();\n      } catch (error) {\n        done(error);\n      }\n    }\n\n    renderFile(filePath, { name: \"Ada Lovelace\", async: true }, cb);\n  });\n\n  it(\"renders a simple template w/ a callback\", async () => {\n    renderFile(filePath, { name: \"Ben\" }, function (_err: Error | null, res?: string) {\n      expect(res).toEqual(\"Hi Ben\");\n    });\n  });\n\n  it(\"renders a simple template w/ callback and explicit config\", async () => {\n    // Note that rmWhitespace doesn't do anything specific\n    renderFile(\n      filePath,\n      { name: \"Ben\" },\n      { rmWhitespace: true },\n      function (_err: Error | null, res?: string) {\n        expect(res).toEqual(\"Hi Ben\");\n      }\n    );\n  });\n\n  it(\"renders an async template using Promises\", async () => {\n    const res = await renderFile(filePath, { name: \"Ada\", async: true });\n    expect(res).toEqual(\"Hi Ada\");\n  });\n\n  it(\"renders an async template with an explicit config using Promises\", async () => {\n    const res = await renderFile(filePath, { name: \"Ada\" }, { async: true });\n    expect(res).toEqual(\"Hi Ada\");\n  });\n\n  it(\"uses cached version of a file\", async () => {\n    templates.define(fakeFilePath, compile(\"This template does not exist\"));\n\n    // renderFile should just look straight in the cache for the template\n    renderFile(fakeFilePath, {}, { cache: true }, function (_err: Error | null, res?: string) {\n      expect(res).toEqual(\"This template does not exist\");\n    });\n  });\n});\n\ndescribe(\"File location tests\", () => {\n  it(\"locates a file with the views option\", async () => {\n    const res = await renderFile(\n      \"simple.eta\",\n      { name: \"Ada\" },\n      { views: path.join(__dirname, \"templates\") }\n    );\n\n    expect(res).toEqual(\"Hi Ada\");\n  });\n});\n\ndescribe(\"renderFile error tests\", () => {\n  it(\"render file with callback works on error\", (done) => {\n    function cb(err: Error | null, _res?: string) {\n      expect(err).toBeTruthy();\n      expect(err?.message).toMatch(\n        buildRegEx(`\nvar tR='',__l,__lP,include=E.include.bind(E),includeFile=E.includeFile.bind(E)\nfunction layout(p,d){__l=p;__lP=d}\ntR+='Hi '\ntR+=E.e(badSyntax(=!)\nif(__l)tR=await includeFile(__l,Object.assign(it,{body:tR},__lP))\nif(cb){cb(null,tR)} return tR\n`)\n      );\n      done();\n    }\n\n    renderFile(errFilePath, { name: \"Ada Lovelace\" }, { async: true }, cb);\n  });\n\n  test(\"throws with bad inner JS syntax using Promises\", async () => {\n    await expect(async () => {\n      await renderFile(errFilePath, {});\n    }).rejects.toThrow(\n      buildRegEx(`\nvar tR='',__l,__lP,include=E.include.bind(E),includeFile=E.includeFile.bind(E)\nfunction layout(p,d){__l=p;__lP=d}\ntR+='Hi '\ntR+=E.e(badSyntax(=!)\nif(__l)tR=includeFile(__l,Object.assign(it,{body:tR},__lP))\nif(cb){cb(null,tR)} return tR\n`)\n    );\n  });\n});\n\ndescribe(\"renderFileAsync function\", () => {\n  it(\"should render properly\", async () => {\n    expect(await renderFileAsync(filePath, { name: \"foo\" })).toBe(\"Hi foo\");\n  });\n});\n\n// NOTE: the errors will really look like this:\n\n/*\nLoading file: /home/nebrelbug/Coding/eta/test/templates/badsyntax.eta failed:\n\nBad template syntax\n\nUnexpected token '='\n====================\nvar tR='',__l,__lP,include=E.include.bind(E),includeFile=E.includeFile.bind(E)\nfunction layout(p,d){__l=p;__lP=d}\ntR+='Hi '\ntR+=E.e(badSyntax(=!)\nif(__l)tR=includeFile(__l,Object.assign(it,{body:tR},__lP))\nif(cb){cb(null,tR)} return tR\n*/\n\n// Unfortunately, Node throws different errors (\"Unexpected token '='\", \"Unexpected token =\", \"Invalid or unexpected token\") depending on the version so we can't test against the first part of the string.\n"], "filenames": ["deno_dist/file-handlers.ts", "src/file-handlers.ts", "test/file-handlers.spec.ts"], "buggy_code_start_loc": [7, 7, 70], "buggy_code_end_loc": [306, 272, 124], "fixing_code_start_loc": [6, 6, 70], "fixing_code_end_loc": [277, 243, 106], "type": "NVD-CWE-noinfo", "message": "Versions of the package eta before 2.0.0 are vulnerable to Remote Code Execution (RCE) by overwriting template engine configuration variables with view options received from The Express render API. **Note:** This is exploitable only for users who are rendering templates with user-defined data.", "other": {"cve": {"id": "CVE-2022-25967", "sourceIdentifier": "report@snyk.io", "published": "2023-01-30T05:15:10.177", "lastModified": "2023-02-07T19:13:42.123", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Versions of the package eta before 2.0.0 are vulnerable to Remote Code Execution (RCE) by overwriting template engine configuration variables with view options received from The Express render API. **Note:** This is exploitable only for users who are rendering templates with user-defined data."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:eta.js:eta:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "2.0.0", "matchCriteriaId": "1E6958D1-1731-4523-BE7B-F4BBED80549B"}]}]}], "references": [{"url": "https://github.com/eta-dev/eta/blob/9c8e4263d3a559444a3881a85c1607bf344d0b28/src/compile-string.ts%23L21", "source": "report@snyk.io", "tags": ["Broken Link"]}, {"url": "https://github.com/eta-dev/eta/blob/9c8e4263d3a559444a3881a85c1607bf344d0b28/src/file-handlers.ts%23L182", "source": "report@snyk.io", "tags": ["Broken Link"]}, {"url": "https://github.com/eta-dev/eta/commit/5651392462ee0ff19d77c8481081a99e5b9138dd", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.snyk.io/vuln/SNYK-JS-ETA-2936803", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/eta-dev/eta/commit/5651392462ee0ff19d77c8481081a99e5b9138dd"}}