{"buggy_code": ["#!/bin/bash --norc\n#\n# Generator script for a dracut initramfs\n# Tries to retain some degree of compatibility with the command line\n# of the various mkinitrd implementations out there\n#\n\n# Copyright 2005-2013 Red Hat, Inc.  All rights reserved.\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\n# store for logging\n\n# Verify bash version, current minimum is 4\nif (( BASH_VERSINFO[0] < 4 )); then\n    printf -- 'You need at least Bash 4 to use dracut, sorry.' >&2\n    exit 1\nfi\n\ndracut_args=( \"$@\" )\nreadonly dracut_cmd=\"$(readlink -f $0)\"\n\nset -o pipefail\n\nusage() {\n    [[ $dracutbasedir ]] || dracutbasedir=/usr/lib/dracut\n    if [[ -f $dracutbasedir/dracut-version.sh ]]; then\n        . $dracutbasedir/dracut-version.sh\n    fi\n\n#                                                       80x25 linebreak here ^\n    cat << EOF\nUsage: $dracut_cmd [OPTION]... [<initramfs> [<kernel-version>]]\n\nVersion: $DRACUT_VERSION\n\nCreates initial ramdisk images for preloading modules\n\n  -h, --help  Display all options\n\nIf a [LIST] has multiple arguments, then you have to put these in quotes.\n\nFor example:\n\n    # dracut --add-drivers \"module1 module2\"  ...\n\nEOF\n}\n\nlong_usage() {\n    [[ $dracutbasedir ]] || dracutbasedir=/usr/lib/dracut\n    if [[ -f $dracutbasedir/dracut-version.sh ]]; then\n        . $dracutbasedir/dracut-version.sh\n    fi\n\n#                                                       80x25 linebreak here ^\n    cat << EOF\nUsage: $dracut_cmd [OPTION]... [<initramfs> [<kernel-version>]]\n\nVersion: $DRACUT_VERSION\n\nCreates initial ramdisk images for preloading modules\n\n  --kver [VERSION]      Set kernel version to [VERSION].\n  -f, --force           Overwrite existing initramfs file.\n  -a, --add [LIST]      Add a space-separated list of dracut modules.\n  --rebuild         Append arguments to those of existing image and rebuild\n  -m, --modules [LIST]  Specify a space-separated list of dracut modules to\n                         call when building the initramfs. Modules are located\n                         in /usr/lib/dracut/modules.d.\n  -o, --omit [LIST]     Omit a space-separated list of dracut modules.\n  --force-add [LIST]    Force to add a space-separated list of dracut modules\n                         to the default set of modules, when -H is specified.\n  -d, --drivers [LIST]  Specify a space-separated list of kernel modules to\n                         exclusively include in the initramfs.\n  --add-drivers [LIST]  Specify a space-separated list of kernel\n                         modules to add to the initramfs.\n  --force-drivers [LIST] Specify a space-separated list of kernel\n                         modules to add to the initramfs and make sure they\n                         are tried to be loaded via modprobe same as passing\n                         rd.driver.pre=DRIVER kernel parameter.\n  --omit-drivers [LIST] Specify a space-separated list of kernel\n                         modules not to add to the initramfs.\n  --filesystems [LIST]  Specify a space-separated list of kernel filesystem\n                         modules to exclusively include in the generic\n                         initramfs.\n  -k, --kmoddir [DIR]   Specify the directory, where to look for kernel\n                         modules\n  --fwdir [DIR]         Specify additional directories, where to look for\n                         firmwares, separated by :\n  --kernel-only         Only install kernel drivers and firmware files\n  --no-kernel           Do not install kernel drivers and firmware files\n  --print-cmdline       Print the kernel command line for the given disk layout\n  --early-microcode     Combine early microcode with ramdisk\n  --no-early-microcode  Do not combine early microcode with ramdisk\n  --kernel-cmdline [PARAMETERS] Specify default kernel command line parameters\n  --strip               Strip binaries in the initramfs\n  --nostrip             Do not strip binaries in the initramfs\n  --prelink             Prelink binaries in the initramfs\n  --noprelink           Do not prelink binaries in the initramfs\n  --hardlink            Hardlink files in the initramfs\n  --nohardlink          Do not hardlink files in the initramfs\n  --prefix [DIR]        Prefix initramfs files with [DIR]\n  --noprefix            Do not prefix initramfs files\n  --mdadmconf           Include local /etc/mdadm.conf\n  --nomdadmconf         Do not include local /etc/mdadm.conf\n  --lvmconf             Include local /etc/lvm/lvm.conf\n  --nolvmconf           Do not include local /etc/lvm/lvm.conf\n  --fscks [LIST]        Add a space-separated list of fsck helpers.\n  --nofscks             Inhibit installation of any fsck helpers.\n  --ro-mnt              Mount / and /usr read-only by default.\n  -h, --help            This message\n  --debug               Output debug information of the build process\n  --profile             Output profile information of the build process\n  -L, --stdlog [0-6]    Specify logging level (to standard error)\n                         0 - suppress any messages\n                         1 - only fatal errors\n                         2 - all errors\n                         3 - warnings\n                         4 - info\n                         5 - debug info (here starts lots of output)\n                         6 - trace info (and even more)\n  -v, --verbose         Increase verbosity level\n  -q, --quiet           Decrease verbosity level\n  -c, --conf [FILE]     Specify configuration file to use.\n                         Default: /etc/dracut.conf\n  --confdir [DIR]       Specify configuration directory to use *.conf files\n                         from. Default: /etc/dracut.conf.d\n  --tmpdir [DIR]        Temporary directory to be used instead of default\n                         /var/tmp.\n  -l, --local           Local mode. Use modules from the current working\n                         directory instead of the system-wide installed in\n                         /usr/lib/dracut/modules.d.\n                         Useful when running dracut from a git checkout.\n  -H, --hostonly        Host-Only mode: Install only what is needed for\n                        booting the local host instead of a generic host.\n  -N, --no-hostonly     Disables Host-Only mode\n  --hostonly-cmdline    Store kernel command line arguments needed\n                        in the initramfs\n  --no-hostonly-cmdline Do not store kernel command line arguments needed\n                        in the initramfs\n  --hostonly-i18n       Install only needed keyboard and font files according\n                        to the host configuration (default).\n  --no-hostonly-i18n    Install all keyboard and font files available.\n  --persistent-policy [POLICY]\n                        Use [POLICY] to address disks and partitions.\n                        POLICY can be any directory name found in /dev/disk.\n                        E.g. \"by-uuid\", \"by-label\"\n  --fstab               Use /etc/fstab to determine the root device.\n  --add-fstab [FILE]    Add file to the initramfs fstab\n  --mount \"[DEV] [MP] [FSTYPE] [FSOPTS]\"\n                        Mount device [DEV] on mountpoint [MP] with filesystem\n                        [FSTYPE] and options [FSOPTS] in the initramfs\n  --mount \"[MP]\"\tSame as above, but [DEV], [FSTYPE] and [FSOPTS] are\n\t\t\tdetermined by looking at the current mounts.\n  --add-device \"[DEV]\"  Bring up [DEV] in initramfs\n  -i, --include [SOURCE] [TARGET]\n                        Include the files in the SOURCE directory into the\n                         Target directory in the final initramfs.\n                        If SOURCE is a file, it will be installed to TARGET\n                         in the final initramfs.\n  -I, --install [LIST]  Install the space separated list of files into the\n                         initramfs.\n  --install-optional [LIST]  Install the space separated list of files into the\n                         initramfs, if they exist.\n  --gzip                Compress the generated initramfs using gzip.\n                         This will be done by default, unless another\n                         compression option or --no-compress is passed.\n  --bzip2               Compress the generated initramfs using bzip2.\n                         Make sure your kernel has bzip2 decompression support\n                         compiled in, otherwise you will not be able to boot.\n  --lzma                Compress the generated initramfs using lzma.\n                         Make sure your kernel has lzma support compiled in,\n                         otherwise you will not be able to boot.\n  --xz                  Compress the generated initramfs using xz.\n                         Make sure that your kernel has xz support compiled\n                         in, otherwise you will not be able to boot.\n  --lzo                 Compress the generated initramfs using lzop.\n                         Make sure that your kernel has lzo support compiled\n                         in, otherwise you will not be able to boot.\n  --lz4                 Compress the generated initramfs using lz4.\n                         Make sure that your kernel has lz4 support compiled\n                         in, otherwise you will not be able to boot.\n  --compress [COMPRESSION] Compress the generated initramfs with the\n                         passed compression program.  Make sure your kernel\n                         knows how to decompress the generated initramfs,\n                         otherwise you will not be able to boot.\n  --no-compress         Do not compress the generated initramfs.  This will\n                         override any other compression options.\n  --list-modules        List all available dracut modules.\n  -M, --show-modules    Print included module's name to standard output during\n                         build.\n  --keep                Keep the temporary initramfs for debugging purposes\n  --printsize           Print out the module install size\n  --sshkey [SSHKEY]     Add ssh key to initramfs (use with ssh-client module)\n  --logfile [FILE]      Logfile to use (overrides configuration setting)\n  --reproducible        Create reproducible images\n  --no-reproducible     Do not create reproducible images\n  --loginstall [DIR]    Log all files installed from the host to [DIR]\n  --uefi                Create an UEFI executable with the kernel cmdline and\n                        kernel combined\n  --uefi-stub [FILE]    Use the UEFI stub [FILE] to create an UEFI executable\n  --kernel-image [FILE] location of the kernel image\n\nIf [LIST] has multiple arguments, then you have to put these in quotes.\n\nFor example:\n\n    # dracut --add-drivers \"module1 module2\"  ...\n\nEOF\n}\n\n# Fills up host_devs stack variable and makes sure there are no duplicates\npush_host_devs() {\n    local _dev\n    for _dev in \"$@\"; do\n        [[ \" ${host_devs[@]} \" == *\" $_dev \"* ]] && return\n        host_devs+=( \"$_dev\" )\n    done\n}\n\n# Little helper function for reading args from the commandline.\n# it automatically handles -a b and -a=b variants, and returns 1 if\n# we need to shift $3.\nread_arg() {\n    # $1 = arg name\n    # $2 = arg value\n    # $3 = arg parameter\n    local rematch='^[^=]*=(.*)$'\n    if [[ $2 =~ $rematch ]]; then\n        read \"$1\" <<< \"${BASH_REMATCH[1]}\"\n    else\n        read \"$1\" <<< \"$3\"\n        # There is no way to shift our callers args, so\n        # return 1 to indicate they should do it instead.\n        return 1\n    fi\n}\n\ndropindirs_sort()\n{\n    local suffix=$1; shift\n    local -a files\n    local f d\n\n    for d in \"$@\"; do\n        for i in \"$d/\"*\"$suffix\"; do\n            if [[ -e \"$i\" ]]; then\n                printf \"%s\\n\" \"${i##*/}\"\n            fi\n        done\n    done | sort -Vu | {\n        readarray -t files\n\n        for f in \"${files[@]}\"; do\n            for d in \"$@\"; do\n                if [[ -e \"$d/$f\" ]]; then\n                    printf \"%s\\n\" \"$d/$f\"\n                    continue 2\n                fi\n            done\n        done\n    }\n}\n\nrearrange_params()\n{\n    # Workaround -i, --include taking 2 arguments\n    set -- \"${@/--include/++include}\"\n\n    # This prevents any long argument ending with \"-i\"\n    # -i, like --opt-i but I think we can just prevent that\n    set -- \"${@/%-i/++include}\"\n\n    TEMP=$(unset POSIXLY_CORRECT; getopt \\\n        -o \"a:m:o:d:I:k:c:L:fvqlHhMN\" \\\n        --long kver: \\\n        --long add: \\\n        --long force-add: \\\n        --long add-drivers: \\\n        --long force-drivers: \\\n        --long omit-drivers: \\\n        --long modules: \\\n        --long omit: \\\n        --long drivers: \\\n        --long filesystems: \\\n        --long install: \\\n        --long install-optional: \\\n        --long fwdir: \\\n        --long libdirs: \\\n        --long fscks: \\\n        --long add-fstab: \\\n        --long mount: \\\n        --long device: \\\n        --long add-device: \\\n        --long nofscks: \\\n        --long ro-mnt \\\n        --long kmoddir: \\\n        --long conf: \\\n        --long confdir: \\\n        --long tmpdir: \\\n        --long stdlog: \\\n        --long compress: \\\n        --long prefix: \\\n        --long rebuild: \\\n        --long force \\\n        --long kernel-only \\\n        --long no-kernel \\\n        --long print-cmdline \\\n        --long kernel-cmdline: \\\n        --long strip \\\n        --long nostrip \\\n        --long prelink \\\n        --long noprelink \\\n        --long hardlink \\\n        --long nohardlink \\\n        --long noprefix \\\n        --long mdadmconf \\\n        --long nomdadmconf \\\n        --long lvmconf \\\n        --long nolvmconf \\\n        --long debug \\\n        --long profile \\\n        --long sshkey: \\\n        --long logfile: \\\n        --long verbose \\\n        --long quiet \\\n        --long local \\\n        --long hostonly \\\n        --long host-only \\\n        --long no-hostonly \\\n        --long no-host-only \\\n        --long hostonly-cmdline \\\n        --long no-hostonly-cmdline \\\n        --long persistent-policy: \\\n        --long fstab \\\n        --long help \\\n        --long bzip2 \\\n        --long lzma \\\n        --long xz \\\n        --long lzo \\\n        --long lz4 \\\n        --long no-compress \\\n        --long gzip \\\n        --long list-modules \\\n        --long show-modules \\\n        --long keep \\\n        --long printsize \\\n        --long regenerate-all \\\n        --long noimageifnotneeded \\\n        --long early-microcode \\\n        --long no-early-microcode \\\n        --long reproducible \\\n        --long no-reproducible \\\n        --long loginstall: \\\n        --long uefi \\\n        --long uefi-stub: \\\n        --long kernel-image: \\\n        --long no-hostonly-i18n \\\n        --long hostonly-i18n \\\n        -- \"$@\")\n\n    if (( $? != 0 )); then\n        usage\n        exit 1\n    fi\n}\n\nverbosity_mod_l=0\nunset kernel\nunset outfile\n\nrearrange_params \"$@\"\neval set -- \"$TEMP\"\n\n# parse command line args to check if '--rebuild' option is present\nunset append_args_l\nunset rebuild_file\nwhile :\ndo\n\tif [ \"$1\" == \"--\" ]; then\n\t    shift; break\n\tfi\n\tif [ \"$1\" == \"--rebuild\" ]; then\n\t    append_args_l=\"yes\"\n            rebuild_file=$2\n            if [ ! -e $rebuild_file ]; then\n                echo \"Image file '$rebuild_file', for rebuild, does not exist!\"\n                exit 1\n            fi\n            abs_rebuild_file=$(readlink -f \"$rebuild_file\") && rebuild_file=\"$abs_rebuild_file\"\n\t    shift; continue\n\tfi\n\tshift\ndone\n\n# get output file name and kernel version from command line arguments\nwhile (($# > 0)); do\n    case ${1%%=*} in\n        ++include)\n            shift 2;;\n        *)\n            if ! [[ ${outfile+x} ]]; then\n                outfile=$1\n            elif ! [[ ${kernel+x} ]]; then\n                kernel=$1\n            else\n                printf \"\\nUnknown arguments: %s\\n\\n\" \"$*\" >&2\n                usage; exit 1;\n            fi\n            ;;\n    esac\n    shift\ndone\n\n# extract input image file provided with rebuild option to get previous parameters, if any\nif [[ $append_args_l == \"yes\" ]]; then\n    unset rebuild_param\n\n    # determine resultant file\n    if ! [[ $outfile ]]; then\n        outfile=$rebuild_file\n    fi\n\n    if ! rebuild_param=$(lsinitrd $rebuild_file '*lib/dracut/build-parameter.txt'); then\n        echo \"Image '$rebuild_file' has no rebuild information stored\"\n        exit 1\n    fi\n\n    # prepend previous parameters to current command line args\n    if [[ $rebuild_param ]]; then\n        TEMP=\"$rebuild_param $TEMP\"\n        eval set -- \"$TEMP\"\n        rearrange_params \"$@\"\n    fi\n\n    # clean the temporarily used scratch-pad directory\n    rm -rf $scratch_dir\nfi\n\nunset PARMS_TO_STORE\nPARMS_TO_STORE=\"\"\n\neval set -- \"$TEMP\"\n\nwhile :; do\n    if [ $1 != \"--\" ] && [ $1 != \"--rebuild\" ]; then\n        PARMS_TO_STORE+=\" $1\";\n    fi\n    case $1 in\n        --kver)        kernel=\"$2\";                           PARMS_TO_STORE+=\" '$2'\"; shift;;\n        -a|--add)      add_dracutmodules_l+=(\"$2\");           PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --force-add)   force_add_dracutmodules_l+=(\"$2\");     PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --add-drivers) add_drivers_l+=(\"$2\");                 PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --force-drivers) force_drivers_l+=(\"$2\");             PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --omit-drivers) omit_drivers_l+=(\"$2\");               PARMS_TO_STORE+=\" '$2'\"; shift;;\n        -m|--modules)  dracutmodules_l+=(\"$2\");               PARMS_TO_STORE+=\" '$2'\"; shift;;\n        -o|--omit)     omit_dracutmodules_l+=(\"$2\");          PARMS_TO_STORE+=\" '$2'\"; shift;;\n        -d|--drivers)  drivers_l+=(\"$2\");                     PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --filesystems) filesystems_l+=(\"$2\");                 PARMS_TO_STORE+=\" '$2'\"; shift;;\n        -I|--install)  install_items_l+=(\"$2\");               PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --install-optional) install_optional_items_l+=(\"$2\"); PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --fwdir)       fw_dir_l+=(\"$2\");                      PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --libdirs)     libdirs_l+=(\"$2\");                     PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --fscks)       fscks_l+=(\"$2\");                       PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --add-fstab)   add_fstab_l+=(\"$2\");                   PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --mount)       fstab_lines+=(\"$2\");                   PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --add-device|--device) add_device_l+=(\"$2\");          PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --kernel-cmdline) kernel_cmdline_l+=(\"$2\");           PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --nofscks)     nofscks_l=\"yes\";;\n        --ro-mnt)      ro_mnt_l=\"yes\";;\n        -k|--kmoddir)  drivers_dir_l=\"$2\";             PARMS_TO_STORE+=\" '$2'\"; shift;;\n        -c|--conf)     conffile=\"$2\";                  PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --confdir)     confdir=\"$2\";                   PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --tmpdir)      tmpdir_l=\"$2\";                  PARMS_TO_STORE+=\" '$2'\"; shift;;\n        -L|--stdlog)   stdloglvl_l=\"$2\";               PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --compress)    compress_l=\"$2\";                PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --prefix)      prefix_l=\"$2\";                  PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --loginstall)  loginstall_l=\"$2\";              PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --rebuild)     if [ $rebuild_file == $outfile ]; then\n                           force=yes\n                       fi\n                       shift\n                       ;;\n        -f|--force)    force=yes;;\n        --kernel-only) kernel_only=\"yes\"; no_kernel=\"no\";;\n        --no-kernel)   kernel_only=\"no\"; no_kernel=\"yes\";;\n        --print-cmdline)\n                       print_cmdline=\"yes\"; hostonly_l=\"yes\"; kernel_only=\"yes\"; no_kernel=\"yes\";;\n        --early-microcode)\n                       early_microcode_l=\"yes\";;\n        --no-early-microcode)\n                       early_microcode_l=\"no\";;\n        --strip)       do_strip_l=\"yes\";;\n        --nostrip)     do_strip_l=\"no\";;\n        --prelink)     do_prelink_l=\"yes\";;\n        --noprelink)   do_prelink_l=\"no\";;\n        --hardlink)    do_hardlink_l=\"yes\";;\n        --nohardlink)  do_hardlink_l=\"no\";;\n        --noprefix)    prefix_l=\"/\";;\n        --mdadmconf)   mdadmconf_l=\"yes\";;\n        --nomdadmconf) mdadmconf_l=\"no\";;\n        --lvmconf)     lvmconf_l=\"yes\";;\n        --nolvmconf)   lvmconf_l=\"no\";;\n        --debug)       debug=\"yes\";;\n        --profile)     profile=\"yes\";;\n        --sshkey)      sshkey=\"$2\";                    PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --logfile)     logfile_l=\"$2\"; shift;;\n        -v|--verbose)  ((verbosity_mod_l++));;\n        -q|--quiet)    ((verbosity_mod_l--));;\n        -l|--local)\n                       allowlocal=\"yes\"\n                       [[ -f \"$(readlink -f \"${0%/*}\")/dracut-init.sh\" ]] \\\n                           && dracutbasedir=\"$(readlink -f \"${0%/*}\")\"\n                       ;;\n        -H|--hostonly|--host-only)\n                       hostonly_l=\"yes\" ;;\n        -N|--no-hostonly|--no-host-only)\n                       hostonly_l=\"no\" ;;\n        --hostonly-cmdline)\n                       hostonly_cmdline_l=\"yes\" ;;\n        --hostonly-i18n)\n                       i18n_install_all_l=\"no\" ;;\n        --no-hostonly-i18n)\n                       i18n_install_all_l=\"yes\" ;;\n        --no-hostonly-cmdline)\n                       hostonly_cmdline_l=\"no\" ;;\n        --persistent-policy)\n                       persistent_policy_l=\"$2\";       PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --fstab)       use_fstab_l=\"yes\" ;;\n        -h|--help)     long_usage; exit 1 ;;\n        -i|--include)  include_src+=(\"$2\");          PARMS_TO_STORE+=\" '$2'\";\n                       shift;;\n        --bzip2)       compress_l=\"bzip2\";;\n        --lzma)        compress_l=\"lzma\";;\n        --xz)          compress_l=\"xz\";;\n        --lzo)         compress_l=\"lzo\";;\n        --lz4)         compress_l=\"lz4\";;\n        --no-compress) _no_compress_l=\"cat\";;\n        --gzip)        compress_l=\"gzip\";;\n        --list-modules) do_list=\"yes\";;\n        -M|--show-modules)\n                       show_modules_l=\"yes\"\n                       ;;\n        --keep)        keep=\"yes\";;\n        --printsize)   printsize=\"yes\";;\n        --regenerate-all) regenerate_all=\"yes\";;\n        --noimageifnotneeded) noimageifnotneeded=\"yes\";;\n        --reproducible) reproducible_l=\"yes\";;\n        --no-reproducible) reproducible_l=\"no\";;\n        --uefi)        uefi=\"yes\";;\n        --uefi-stub)\n                       uefi_stub_l=\"$2\";               PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --kernel-image)\n                       kernel_image_l=\"$2\";            PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --) shift; break;;\n\n        *)  # should not even reach this point\n            printf \"\\n!Unknown option: '%s'\\n\\n\" \"$1\" >&2; usage; exit 1;;\n    esac\n    shift\ndone\n\n# getopt cannot handle multiple arguments, so just handle \"-I,--include\"\n# the old fashioned way\n\nwhile (($# > 0)); do\n    if [ \"${1%%=*}\" == \"++include\" ]; then\n        include_src+=(\"$2\")\n        include_target+=(\"$3\")\n        PARMS_TO_STORE+=\" --include '$2' '$3'\"\n        shift 2\n    fi\n    shift\ndone\n\nif [[ $regenerate_all == \"yes\" ]]; then\n    ret=0\n    if [[ $kernel ]]; then\n        printf -- \"--regenerate-all cannot be called with a kernel version\\n\" >&2\n        exit 1\n    fi\n\n    if [[ $outfile ]]; then\n        printf -- \"--regenerate-all cannot be called with a image file\\n\" >&2\n        exit 1\n    fi\n\n    ((len=${#dracut_args[@]}))\n    for ((i=0; i < len; i++)); do\n        [[ ${dracut_args[$i]} == \"--regenerate-all\" ]] && \\\n            unset dracut_args[$i]\n    done\n\n    cd /lib/modules\n    for i in *; do\n        [[ -f $i/modules.dep ]] || [[ -f $i/modules.dep.bin ]] || continue\n        \"$dracut_cmd\" --kver=\"$i\" \"${dracut_args[@]}\"\n        ((ret+=$?))\n    done\n    exit $ret\nfi\n\nif ! [[ $kernel ]]; then\n    kernel=$(uname -r)\nfi\n\nif [[ $kernel ]]; then\n    if ! [[ -d /lib/modules/$kernel ]] && [[ $no_kernel != yes ]]; then\n        printf -- \"Kernel version $kernel has no module directory /lib/modules/$kernel\\n\" >&2\n    fi\nfi\n\nif ! [[ $outfile ]]; then\n    [[ -f /etc/machine-id ]] && read MACHINE_ID < /etc/machine-id\n\n    if [[ $MACHINE_ID ]] && ( [[ -d /boot/${MACHINE_ID} ]] || [[ -L /boot/${MACHINE_ID} ]] ); then\n        outfile=\"/boot/${MACHINE_ID}/$kernel/initrd\"\n    else\n        outfile=\"/boot/initramfs-$kernel.img\"\n    fi\nfi\n\nunset LC_MESSAGES\nunset LC_CTYPE\nexport LC_ALL=C\nexport LANG=C\nunset LD_LIBRARY_PATH\nunset LD_PRELOAD\nunset GREP_OPTIONS\n\nexport DRACUT_LOG_LEVEL=warning\n[[ $debug ]] && {\n    export DRACUT_LOG_LEVEL=debug\n    export PS4='${BASH_SOURCE}@${LINENO}(${FUNCNAME[0]}): ';\n    set -x\n}\n\n[[ $profile ]] && {\n    export PS4='+ $(date \"+%s.%N\") ${BASH_SOURCE}@${LINENO}: ';\n    set -x\n    debug=yes\n}\n\n[[ $dracutbasedir ]] || dracutbasedir=/usr/lib/dracut\n\n# if we were not passed a config file, try the default one\nif [[ ! -f $conffile ]]; then\n    if [[ $allowlocal ]]; then\n        conffile=\"$dracutbasedir/dracut.conf\"\n    else\n        conffile=\"/etc/dracut.conf\"\n    fi\nfi\n\nif [[ ! -d $confdir ]]; then\n    if [[ $allowlocal ]]; then\n        confdir=\"$dracutbasedir/dracut.conf.d\"\n    else\n        confdir=\"/etc/dracut.conf.d\"\n    fi\nfi\n\n# source our config file\n[[ -f $conffile ]] && . \"$conffile\"\n\n# source our config dir\nfor f in $(dropindirs_sort \".conf\" \"$confdir\" \"$dracutbasedir/dracut.conf.d\"); do\n    [[ -e $f ]] && . \"$f\"\ndone\n\nDRACUT_PATH=${DRACUT_PATH:-/sbin /bin /usr/sbin /usr/bin}\n\nfor i in $DRACUT_PATH; do\n    rl=$i\n    if [ -L \"$i\" ]; then\n        rl=$(readlink -f $i)\n    fi\n    if [[ \"$NPATH\" != *:$rl* ]] ; then\n        NPATH+=\":$rl\"\n    fi\ndone\nexport PATH=\"${NPATH#:}\"\nunset NPATH\n\n# these options add to the stuff in the config file\n(( ${#add_dracutmodules_l[@]} )) && add_dracutmodules+=\" ${add_dracutmodules_l[@]} \"\n(( ${#force_add_dracutmodules_l[@]} )) && force_add_dracutmodules+=\" ${force_add_dracutmodules_l[@]} \"\n(( ${#fscks_l[@]} )) && fscks+=\" ${fscks_l[@]} \"\n(( ${#add_fstab_l[@]} )) && add_fstab+=\" ${add_fstab_l[@]} \"\n(( ${#fstab_lines_l[@]} )) && fstab_lines+=( \"${fstab_lines_l[@]}\" )\n(( ${#install_items_l[@]} )) && install_items+=\" ${install_items_l[@]} \"\n(( ${#install_optional_items_l[@]} )) && install_optional_items+=\" ${install_optional_items_l[@]} \"\n\n# these options override the stuff in the config file\n(( ${#dracutmodules_l[@]} )) && dracutmodules=\"${dracutmodules_l[@]}\"\n(( ${#omit_dracutmodules_l[@]} )) && omit_dracutmodules=\"${omit_dracutmodules_l[@]}\"\n(( ${#filesystems_l[@]} )) && filesystems=\"${filesystems_l[@]}\"\n(( ${#fw_dir_l[@]} )) && fw_dir=\"${fw_dir_l[@]}\"\n(( ${#libdirs_l[@]} ))&& libdirs=\"${libdirs_l[@]}\"\n\n[[ $stdloglvl_l ]] && stdloglvl=$stdloglvl_l\n[[ ! $stdloglvl ]] && stdloglvl=4\nstdloglvl=$((stdloglvl + verbosity_mod_l))\n((stdloglvl > 6)) && stdloglvl=6\n((stdloglvl < 0)) && stdloglvl=0\n\n[[ $drivers_dir_l ]] && drivers_dir=$drivers_dir_l\n[[ $do_strip_l ]] && do_strip=$do_strip_l\n[[ $do_strip ]] || do_strip=yes\n[[ $do_prelink_l ]] && do_prelink=$do_prelink_l\n[[ $do_prelink ]] || do_prelink=yes\n[[ $do_hardlink_l ]] && do_hardlink=$do_hardlink_l\n[[ $do_hardlink ]] || do_hardlink=yes\n[[ $prefix_l ]] && prefix=$prefix_l\n[[ $prefix = \"/\" ]] && unset prefix\n[[ $hostonly_l ]] && hostonly=$hostonly_l\n[[ $hostonly_cmdline_l ]] && hostonly_cmdline=$hostonly_cmdline_l\n[[ \"$hostonly\" == \"yes\" ]] && ! [[ $hostonly_cmdline ]] && hostonly_cmdline=\"yes\"\n[[ $i18n_install_all_l ]] && i18n_install_all=$i18n_install_all_l\n[[ $persistent_policy_l ]] && persistent_policy=$persistent_policy_l\n[[ $use_fstab_l ]] && use_fstab=$use_fstab_l\n[[ $mdadmconf_l ]] && mdadmconf=$mdadmconf_l\n[[ $lvmconf_l ]] && lvmconf=$lvmconf_l\n[[ $dracutbasedir ]] || dracutbasedir=/usr/lib/dracut\n[[ $fw_dir ]] || fw_dir=\"/lib/firmware/updates:/lib/firmware:/lib/firmware/$kernel\"\n[[ $tmpdir_l ]] && tmpdir=\"$tmpdir_l\"\n[[ $tmpdir ]] || tmpdir=/var/tmp\n[[ $INITRD_COMPRESS ]] && compress=$INITRD_COMPRESS\n[[ $compress_l ]] && compress=$compress_l\n[[ $show_modules_l ]] && show_modules=$show_modules_l\n[[ $nofscks_l ]] && nofscks=\"yes\"\n[[ $ro_mnt_l ]] && ro_mnt=\"yes\"\n[[ $early_microcode_l ]] && early_microcode=$early_microcode_l\n[[ $early_microcode ]] || early_microcode=no\n[[ $logfile_l ]] && logfile=\"$logfile_l\"\n[[ $reproducible_l ]] && reproducible=\"$reproducible_l\"\n[[ $loginstall_l ]] && loginstall=\"$loginstall_l\"\n[[ $uefi_stub_l ]] && uefi_stub=\"$uefi_stub_l\"\n[[ $kernel_image_l ]] && kernel_image=\"$kernel_image_l\"\n\n# eliminate IFS hackery when messing with fw_dir\nexport DRACUT_FIRMWARE_PATH=${fw_dir// /:}\nfw_dir=${fw_dir//:/ }\n\n# check for logfile and try to create one if it doesn't exist\nif [[ -n \"$logfile\" ]];then\n    if [[ ! -f \"$logfile\" ]];then\n        touch \"$logfile\"\n        if [ ! $? -eq 0 ] ;then\n            printf \"%s\\n\" \"dracut: touch $logfile failed.\" >&2\n        fi\n    fi\nfi\n\n# handle compression options.\nif [[ $_no_compress_l = \"cat\" ]]; then\n    compress=\"cat\"\nfi\n\nif ! [[ $compress ]]; then\n    # check all known compressors, if none specified\n    for i in pigz gzip lz4 lzop lzma xz lbzip2 bzip2 cat; do\n        command -v \"$i\" &>/dev/null || continue\n        compress=\"$i\"\n        break\n    done\n    if [[ $compress = cat ]]; then\n            printf \"%s\\n\" \"dracut: no compression tool available. Initramfs image is going to be big.\" >&2\n    fi\nfi\n\n# choose the right arguments for the compressor\ncase $compress in\n    bzip2|lbzip2)\n        if [[ \"$compress\" =  lbzip2 ]] || command -v lbzip2 &>/dev/null; then\n            compress=\"lbzip2 -9\"\n        else\n            compress=\"bzip2 -9\"\n        fi\n        ;;\n    lzma)\n        compress=\"lzma -9 -T0\"\n        ;;\n    xz)\n        compress=\"xz --check=crc32 --lzma2=dict=1MiB -T0\"\n        ;;\n    gzip|pigz)\n        if [[ \"$compress\" = pigz ]] || command -v pigz &>/dev/null; then\n            compress=\"pigz -9 -n -T -R\"\n        elif command -v gzip &>/dev/null && gzip --help 2>&1 | grep -q rsyncable; then\n            compress=\"gzip -n -9 --rsyncable\"\n        else\n            compress=\"gzip -n -9\"\n        fi\n        ;;\n    lzo|lzop)\n        compress=\"lzop -9\"\n        ;;\n    lz4)\n        compress=\"lz4 -l -9\"\n        ;;\nesac\n\n[[ $hostonly = yes ]] && hostonly=\"-h\"\n[[ $hostonly != \"-h\" ]] && unset hostonly\n\n[[ $reproducible == yes ]] && DRACUT_REPRODUCIBLE=1\n\nreadonly TMPDIR=\"$tmpdir\"\nreadonly DRACUT_TMPDIR=\"$(mktemp -p \"$TMPDIR/\" -d -t dracut.XXXXXX)\"\n[ -d \"$DRACUT_TMPDIR\" ] || {\n    printf \"%s\\n\" \"dracut: mktemp -p '$TMPDIR/' -d -t dracut.XXXXXX failed.\" >&2\n    exit 1\n}\n\n# clean up after ourselves no matter how we die.\ntrap '\n    ret=$?;\n    [[ $keep ]] && echo \"Not removing $DRACUT_TMPDIR.\" >&2 || { [[ $DRACUT_TMPDIR ]] && rm -rf -- \"$DRACUT_TMPDIR\"; };\n    exit $ret;\n    ' EXIT\n\n# clean up after ourselves no matter how we die.\ntrap 'exit 1;' SIGINT\n\nreadonly initdir=\"${DRACUT_TMPDIR}/initramfs\"\nmkdir \"$initdir\"\n\nif [[ $early_microcode = yes ]] || ( [[ $acpi_override = yes ]] && [[ -d $acpi_table_dir ]] ); then\n    readonly early_cpio_dir=\"${DRACUT_TMPDIR}/earlycpio\"\n    mkdir \"$early_cpio_dir\"\nfi\n\nexport DRACUT_RESOLVE_LAZY=\"1\"\n\nif [[ $print_cmdline ]]; then\n    stdloglvl=0\n    sysloglvl=0\n    fileloglvl=0\n    kmsgloglvl=0\nfi\n\nif [[ -f $dracutbasedir/dracut-version.sh ]]; then\n    . $dracutbasedir/dracut-version.sh\nfi\n\nif [[ -f $dracutbasedir/dracut-init.sh ]]; then\n    . $dracutbasedir/dracut-init.sh\nelse\n    printf \"%s\\n\" \"dracut: Cannot find $dracutbasedir/dracut-init.sh.\" >&2\n    printf \"%s\\n\" \"dracut: Are you running from a git checkout?\" >&2\n    printf \"%s\\n\" \"dracut: Try passing -l as an argument to $dracut_cmd\" >&2\n    exit 1\nfi\n\nif ! [[ $print_cmdline ]]; then\n    inst /bin/sh\n    if ! $DRACUT_INSTALL ${initdir:+-D \"$initdir\"} -R \"$initdir/bin/sh\" &>/dev/null; then\n        unset DRACUT_RESOLVE_LAZY\n        export DRACUT_RESOLVE_DEPS=1\n    fi\n    rm -fr -- ${initdir}/*\nfi\n\ndracutfunctions=$dracutbasedir/dracut-functions.sh\nexport dracutfunctions\n\n(( ${#drivers_l[@]} )) && drivers=\"${drivers_l[@]}\"\ndrivers=${drivers/-/_}\n\n(( ${#add_drivers_l[@]} )) && add_drivers+=\" ${add_drivers_l[@]} \"\nadd_drivers=${add_drivers/-/_}\n\n(( ${#force_drivers_l[@]} )) && force_drivers+=\" ${force_drivers_l[@]} \"\nforce_drivers=${force_drivers/-/_}\n\n(( ${#omit_drivers_l[@]} )) && omit_drivers+=\" ${omit_drivers_l[@]} \"\nomit_drivers=${omit_drivers/-/_}\n\n(( ${#kernel_cmdline_l[@]} )) && kernel_cmdline+=\" ${kernel_cmdline_l[@]} \"\n\nomit_drivers_corrected=\"\"\nfor d in $omit_drivers; do\n    [[ \" $drivers $add_drivers \" == *\\ $d\\ * ]] && continue\n    [[ \" $drivers $force_drivers \" == *\\ $d\\ * ]] && continue\n    omit_drivers_corrected+=\"$d|\"\ndone\nomit_drivers=\"${omit_drivers_corrected%|}\"\nunset omit_drivers_corrected\n\n# prepare args for logging\nfor ((i=0; i < ${#dracut_args[@]}; i++)); do\n    [[ \"${dracut_args[$i]}\" == *\\ * ]] && \\\n        dracut_args[$i]=\"\\\"${dracut_args[$i]}\\\"\"\n        #\" keep vim happy\ndone\n\ndinfo \"Executing: $dracut_cmd ${dracut_args[@]}\"\n\n[[ $do_list = yes ]] && {\n    for mod in $dracutbasedir/modules.d/*; do\n        [[ -d $mod ]] || continue;\n        [[ -e $mod/install || -e $mod/installkernel || \\\n            -e $mod/module-setup.sh ]] || continue\n        printf \"%s\\n\" \"${mod##*/??}\"\n    done\n    exit 0\n}\n\n# This is kinda legacy -- eventually it should go away.\ncase $dracutmodules in\n    \"\"|auto) dracutmodules=\"all\" ;;\nesac\n\nabs_outfile=$(readlink -f \"$outfile\") && outfile=\"$abs_outfile\"\n\nif [[ $no_kernel != yes ]] && [[ -d $srcmods ]]; then\n    if ! [[ -f $srcmods/modules.dep ]]; then\n        if [[ -n \"$(find \"$srcmods\" -name '*.ko*')\" ]]; then\n            dfatal \"$srcmods/modules.dep is missing. Did you run depmod?\"\n            exit 1\n        else\n            dwarn \"$srcmods/modules.dep is missing. Did you run depmod?\"\n        fi\n    elif ! ( command -v gzip &>/dev/null && command -v xz &>/dev/null); then\n        read _mod < $srcmods/modules.dep\n        _mod=${_mod%%:*}\n        if [[ -f $srcmods/\"$_mod\" ]]; then\n            # Check, if kernel modules are compressed, and if we can uncompress them\n            case \"$_mod\" in\n                *.ko.gz) kcompress=gzip;;\n                *.ko.xz) kcompress=xz;;\n            esac\n            if [[ $kcompress ]]; then\n                if ! command -v \"$kcompress\" &>/dev/null; then\n                    dfatal \"Kernel modules are compressed with $kcompress, but $kcompress is not available.\"\n                    exit 1\n                fi\n            fi\n        fi\n    fi\nfi\n\nif [[ ! $print_cmdline ]]; then\n    if [[ -f $outfile && ! $force ]]; then\n        dfatal \"Will not override existing initramfs ($outfile) without --force\"\n        exit 1\n    fi\n\n    outdir=${outfile%/*}\n    [[ $outdir ]] || outdir=\"/\"\n\n    if [[ ! -d \"$outdir\" ]]; then\n        dfatal \"Can't write to $outdir: Directory $outdir does not exist or is not accessible.\"\n        exit 1\n    elif [[ ! -w \"$outdir\" ]]; then\n        dfatal \"No permission to write to $outdir.\"\n        exit 1\n    elif [[ -f \"$outfile\" && ! -w \"$outfile\" ]]; then\n        dfatal \"No permission to write $outfile.\"\n        exit 1\n    fi\n\n    if [[ $loginstall ]]; then\n        if ! mkdir -p \"$loginstall\"; then\n            dfatal \"Could not create directory to log installed files to '$loginstall'.\"\n            exit 1\n        fi\n        loginstall=$(readlink -f \"$loginstall\")\n    fi\n\n    if [[ $uefi = yes ]]; then\n        if ! command -v objcopy &>/dev/null; then\n            dfatal \"Need 'objcopy' to create a UEFI executable\"\n            exit 1\n        fi\n        unset EFI_MACHINE_TYPE_NAME\n        case $(arch) in\n            x86_64)\n                EFI_MACHINE_TYPE_NAME=x64;;\n            ia32)\n                EFI_MACHINE_TYPE_NAME=ia32;;\n            *)\n                dfatal \"Architecture '$(arch)' not supported to create a UEFI executable\"\n                exit 1\n                ;;\n        esac\n\n        if ! [[ -s $uefi_stub ]]; then\n            for uefi_stub in \\\n                \"/lib/systemd/boot/efi/linux${EFI_MACHINE_TYPE_NAME}.efi.stub\" \\\n                    \"/usr/lib/gummiboot/linux${EFI_MACHINE_TYPE_NAME}.efi.stub\"; do\n                [[ -s $uefi_stub ]] || continue\n                break\n            done\n        fi\n        if ! [[ -s $uefi_stub ]]; then\n            dfatal \"Can't find a uefi stub '$uefi_stub' to create a UEFI executable\"\n            exit 1\n        fi\n\n        if ! [[ $kernel_image ]]; then\n            for kernel_image in \"/lib/modules/$kernel/vmlinuz\" \"/boot/vmlinuz-$kernel\"; do\n                [[ -s \"$kernel_image\" ]] || continue\n                break\n            done\n        fi\n        if ! [[ -s $kernel_image ]]; then\n            dfatal \"Can't find a kernel image '$kernel_image' to create a UEFI executable\"\n            exit 1\n        fi\n    fi\nfi\n\nif [[ $acpi_override = yes ]] && ! check_kernel_config CONFIG_ACPI_INITRD_TABLE_OVERRIDE; then\n    dwarn \"Disabling ACPI override, because kernel does not support it. CONFIG_ACPI_INITRD_TABLE_OVERRIDE!=y\"\n    unset acpi_override\nfi\n\nif [[ $early_microcode = yes ]]; then\n    if [[ $hostonly ]]; then\n        [[ $(get_cpu_vendor) == \"AMD\" ]] \\\n            && ! check_kernel_config CONFIG_MICROCODE_AMD \\\n            && unset early_microcode\n        [[ $(get_cpu_vendor) == \"Intel\" ]] \\\n            && ! check_kernel_config CONFIG_MICROCODE_INTEL \\\n            && unset early_microcode\n    else\n        ! check_kernel_config CONFIG_MICROCODE_AMD \\\n            && ! check_kernel_config CONFIG_MICROCODE_INTEL \\\n            && unset early_microcode\n    fi\n    [[ $early_microcode != yes ]] \\\n        && dwarn \"Disabling early microcode, because kernel does not support it. CONFIG_MICROCODE_[AMD|INTEL]!=y\"\nfi\n\n# Need to be able to have non-root users read stuff (rpcbind etc)\nchmod 755 \"$initdir\"\n\nif [[ $hostonly ]]; then\n    for i in /sys /proc /run /dev; do\n        if ! findmnt --target \"$i\" &>/dev/null; then\n            dwarning \"Turning off host-only mode: '$i' is not mounted!\"\n            unset hostonly\n        fi\n    done\nfi\n\ndeclare -A host_fs_types\n\nfor line in \"${fstab_lines[@]}\"; do\n    set -- $line\n    dev=\"$1\"\n    #dev mp fs fsopts\n    case \"$dev\" in\n        UUID=*)\n            dev=$(blkid -l -t UUID=${dev#UUID=} -o device)\n            ;;\n        LABEL=*)\n            dev=$(blkid -l -t LABEL=${dev#LABEL=} -o device)\n            ;;\n        PARTUUID=*)\n            dev=$(blkid -l -t PARTUUID=${dev#PARTUUID=} -o device)\n            ;;\n        PARTLABEL=*)\n            dev=$(blkid -l -t PARTLABEL=${dev#PARTLABEL=} -o device)\n            ;;\n    esac\n    [ -z \"$dev\" ] && dwarn \"Bad fstab entry $@\" && continue\n    if [[ \"$3\" == btrfs ]]; then\n        for i in $(btrfs_devs \"$2\"); do\n            push_host_devs \"$i\"\n        done\n    fi\n    push_host_devs \"$dev\"\n    host_fs_types[\"$dev\"]=\"$3\"\ndone\n\nfor f in $add_fstab; do\n    [[ -e $f ]] || continue\n    while read dev rest || [ -n \"$dev\" ]; do\n        push_host_devs \"$dev\"\n    done < \"$f\"\ndone\n\nfor dev in $add_device; do\n    push_host_devs \"$dev\"\ndone\n\nif (( ${#add_device_l[@]} )); then\n    add_device+=\" ${add_device_l[@]} \"\n    push_host_devs \"${add_device_l[@]}\"\nfi\n\nif [[ $hostonly ]]; then\n    # in hostonly mode, determine all devices, which have to be accessed\n    # and examine them for filesystem types\n\n    for mp in \\\n        \"/\" \\\n        \"/etc\" \\\n        \"/bin\" \\\n        \"/sbin\" \\\n        \"/lib\" \\\n        \"/lib64\" \\\n        \"/usr\" \\\n        \"/usr/bin\" \\\n        \"/usr/sbin\" \\\n        \"/usr/lib\" \\\n        \"/usr/lib64\" \\\n        \"/boot\" \\\n        \"/boot/efi\" \\\n        ;\n    do\n        mp=$(readlink -f \"$mp\")\n        mountpoint \"$mp\" >/dev/null 2>&1 || continue\n        _dev=$(find_block_device \"$mp\")\n        _bdev=$(readlink -f \"/dev/block/$_dev\")\n        [[ -b $_bdev ]] && _dev=$_bdev\n        [[ \"$mp\" == \"/\" ]] && root_devs+=(\"$_dev\")\n        push_host_devs \"$_dev\"\n        if [[ $(find_mp_fstype \"$mp\") == btrfs ]]; then\n            for i in $(btrfs_devs \"$mp\"); do\n                [[ \"$mp\" == \"/\" ]] && root_devs+=(\"$i\")\n                push_host_devs \"$i\"\n            done\n        fi\n    done\n\n    if [[ -f /proc/swaps ]] && [[ -f /etc/fstab ]]; then\n        while read dev type rest || [ -n \"$dev\" ]; do\n            [[ -b $dev ]] || continue\n            [[ \"$type\" == \"partition\" ]] || continue\n\n            while read _d _m _t _o _r || [ -n \"$_d\" ]; do\n                [[ \"$_d\" == \\#* ]] && continue\n                [[ $_d ]] || continue\n                [[ $_t != \"swap\" ]] && continue\n                [[ $_m != \"swap\" ]] && [[ $_m != \"none\" ]] && continue\n                [[ \"$_o\" == *noauto* ]] && continue\n                _d=$(expand_persistent_dev \"$_d\")\n                [[ \"$_d\" -ef \"$dev\" ]] || continue\n\n                if [[ -f /etc/crypttab ]]; then\n                    while read _mapper _a _p _o || [ -n \"$_mapper\" ]; do\n                        [[ $_mapper = \\#* ]] && continue\n                        [[ \"$_d\" -ef /dev/mapper/\"$_mapper\" ]] || continue\n                        [[ \"$_o\" ]] || _o=\"$_p\"\n                        # skip entries with password files\n                        [[ \"$_p\" == /* ]] && [[ -f $_p ]] && continue 2\n                        # skip mkswap swap\n                        [[ $_o == *swap* ]] && continue 2\n                    done < /etc/crypttab\n                fi\n\n                _dev=\"$(readlink -f \"$dev\")\"\n                push_host_devs \"$_dev\"\n                swap_devs+=(\"$_dev\")\n                break\n            done < /etc/fstab\n        done < /proc/swaps\n    fi\n\n    # collect all \"x-initrd.mount\" entries from /etc/fstab\n    if [[ -f /etc/fstab ]]; then\n        while read _d _m _t _o _r || [ -n \"$_d\" ]; do\n            [[ \"$_d\" == \\#* ]] && continue\n            [[ $_d ]] || continue\n            [[ \"$_o\" != *x-initrd.mount* ]] && continue\n            _dev=$(expand_persistent_dev \"$_d\")\n            _dev=\"$(readlink -f \"$_dev\")\"\n            [[ -b $_dev ]] || continue\n\n            push_host_devs \"$_dev\"\n            if [[ \"$_t\" == btrfs ]]; then\n                for i in $(find_btrfs_devs \"$_m\"); do\n                    push_host_devs \"$i\"\n                done\n            fi\n        done < /etc/fstab\n    fi\nfi\n\nunset m\nunset rest\n\n_get_fs_type() {\n    [[ $1 ]] || return\n    if [[ -b /dev/block/$1 ]]; then\n        ID_FS_TYPE=$(get_fs_env \"/dev/block/$1\") && host_fs_types[\"$(readlink -f \"/dev/block/$1\")\"]=\"$ID_FS_TYPE\"\n        return 1\n    fi\n    if [[ -b $1 ]]; then\n        ID_FS_TYPE=$(get_fs_env \"$1\") && host_fs_types[\"$(readlink -f \"$1\")\"]=\"$ID_FS_TYPE\"\n        return 1\n    fi\n    if fstype=$(find_dev_fstype \"$1\"); then\n        host_fs_types[\"$1\"]=\"$fstype\"\n        return 1\n    fi\n    return 1\n}\n\nfor dev in \"${host_devs[@]}\"; do\n    _get_fs_type \"$dev\"\n    check_block_and_slaves_all _get_fs_type \"$(get_maj_min \"$dev\")\"\ndone\n\nfor dev in \"${!host_fs_types[@]}\"; do\n    [[ ${host_fs_types[$dev]} = \"reiserfs\" ]] || [[ ${host_fs_types[$dev]} = \"xfs\" ]] || continue\n    rootopts=$(find_dev_fsopts \"$dev\")\n    if [[ ${host_fs_types[$dev]} = \"reiserfs\" ]]; then\n        journaldev=$(fs_get_option $rootopts \"jdev\")\n    elif [[ ${host_fs_types[$dev]} = \"xfs\" ]]; then\n        journaldev=$(fs_get_option $rootopts \"logdev\")\n    fi\n    if [[ $journaldev ]]; then\n        dev=\"$(readlink -f \"$dev\")\"\n        push_host_devs \"$dev\"\n        _get_fs_type \"$dev\"\n        check_block_and_slaves_all _get_fs_type \"$(get_maj_min \"$dev\")\"\n    fi\ndone\n\n[[ -d $udevdir ]] \\\n    || udevdir=\"$(pkg-config udev --variable=udevdir 2>/dev/null)\"\nif ! [[ -d \"$udevdir\" ]]; then\n    [[ ! -h /lib ]] && [[ -d /lib/udev ]] && udevdir=/lib/udev\n    [[ -d /usr/lib/udev ]] && udevdir=/usr/lib/udev\nfi\n\n[[ -d $systemdutildir ]] \\\n    || systemdutildir=$(pkg-config systemd --variable=systemdutildir 2>/dev/null)\n\nif ! [[ -d \"$systemdutildir\" ]]; then\n    [[ ! -h /lib ]] && [[ -d /lib/systemd ]] && systemdutildir=/lib/systemd\n    [[ -d /usr/lib/systemd ]] && systemdutildir=/usr/lib/systemd\nfi\n\n[[ -d $systemdsystemunitdir ]] \\\n    || systemdsystemunitdir=$(pkg-config systemd --variable=systemdsystemunitdir 2>/dev/null)\n\n[[ -d \"$systemdsystemunitdir\" ]] || systemdsystemunitdir=${systemdutildir}/system\n\n[[ -d $systemdsystemconfdir ]] \\\n    || systemdsystemconfdir=$(pkg-config systemd --variable=systemdsystemconfdir 2>/dev/null)\n\n[[ -d \"$systemdsystemconfdir\" ]] || systemdsystemconfdir=/etc/systemd/system\n\n[[ -d $tmpfilesdir ]] \\\n    || tmpfilesdir=$(pkg-config systemd --variable=tmpfilesdir 2>/dev/null)\n\nif ! [[ -d \"$tmpfilesdir\" ]]; then\n    [[ -d /lib/tmpfiles.d ]] && tmpfilesdir=/lib/tmpfiles.d\n    [[ -d /usr/lib/tmpfiles.d ]] && tmpfilesdir=/usr/lib/tmpfiles.d\nfi\n\nexport initdir dracutbasedir \\\n    dracutmodules force_add_dracutmodules add_dracutmodules omit_dracutmodules \\\n    mods_to_load \\\n    fw_dir drivers_dir debug no_kernel kernel_only \\\n    omit_drivers mdadmconf lvmconf root_dev \\\n    use_fstab fstab_lines libdirs fscks nofscks ro_mnt \\\n    stdloglvl sysloglvl fileloglvl kmsgloglvl logfile \\\n    debug host_fs_types host_devs swap_devs sshkey add_fstab \\\n    DRACUT_VERSION udevdir prefix filesystems drivers \\\n    systemdutildir systemdsystemunitdir systemdsystemconfdir \\\n    hostonly_cmdline loginstall \\\n    tmpfilesdir\n\nmods_to_load=\"\"\n# check all our modules to see if they should be sourced.\n# This builds a list of modules that we will install next.\nfor_each_module_dir check_module\nfor_each_module_dir check_mount\n\ndracut_module_included \"fips\" && export DRACUT_FIPS_MODE=1\n\ndo_print_cmdline()\n{\n    local -A _mods_to_print\n    for i in $modules_loaded $mods_to_load; do\n        _mods_to_print[$i]=1\n    done\n\n    # source our modules.\n    for moddir in \"$dracutbasedir/modules.d\"/[0-9][0-9]*; do\n        _d_mod=${moddir##*/}; _d_mod=${_d_mod#[0-9][0-9]}\n        [[ ${_mods_to_print[$_d_mod]} ]] || continue\n        module_cmdline \"$_d_mod\"\n    done\n    unset moddir\n}\n\nif [[ $print_cmdline ]]; then\n    do_print_cmdline\n    printf \"\\n\"\n    exit 0\nfi\n\n# Create some directory structure first\n[[ $prefix ]] && mkdir -m 0755 -p \"${initdir}${prefix}\"\n\n[[ -h /lib ]] || mkdir -m 0755 -p \"${initdir}${prefix}/lib\"\n[[ $prefix ]] && ln -sfn \"${prefix#/}/lib\" \"$initdir/lib\"\n\nif [[ $prefix ]]; then\n    for d in bin etc lib sbin tmp usr var $libdirs; do\n        [[ \"$d\" == */* ]] && continue\n        ln -sfn \"${prefix#/}/${d#/}\" \"$initdir/$d\"\n    done\nfi\n\nif [[ $kernel_only != yes ]]; then\n    for d in usr/bin usr/sbin bin etc lib sbin tmp usr var var/tmp $libdirs; do\n        [[ -e \"${initdir}${prefix}/$d\" ]] && continue\n        if [ -L \"/$d\" ]; then\n            inst_symlink \"/$d\" \"${prefix}/$d\"\n        else\n            mkdir -m 0755 -p \"${initdir}${prefix}/$d\"\n        fi\n    done\n\n    for d in dev proc sys sysroot root run; do\n        if [ -L \"/$d\" ]; then\n            inst_symlink \"/$d\"\n        else\n            mkdir -m 0755 -p \"$initdir/$d\"\n        fi\n    done\n\n    ln -sfn ../run \"$initdir/var/run\"\n    ln -sfn ../run/lock \"$initdir/var/lock\"\nelse\n    for d in lib \"$libdir\"; do\n        [[ -e \"${initdir}${prefix}/$d\" ]] && continue\n        if [ -h \"/$d\" ]; then\n            inst \"/$d\" \"${prefix}/$d\"\n        else\n            mkdir -m 0755 -p \"${initdir}${prefix}/$d\"\n        fi\n    done\nfi\n\nif [[ $kernel_only != yes ]]; then\n    mkdir -p \"${initdir}/etc/cmdline.d\"\n    for _d in $hookdirs; do\n        mkdir -m 0755 -p ${initdir}/lib/dracut/hooks/$_d\n    done\n    if [[ \"$UID\" = \"0\" ]]; then\n        [ -c ${initdir}/dev/null ] || mknod ${initdir}/dev/null c 1 3\n        [ -c ${initdir}/dev/kmsg ] || mknod ${initdir}/dev/kmsg c 1 11\n        [ -c ${initdir}/dev/console ] || mknod ${initdir}/dev/console c 5 1\n    fi\nfi\n\n_isize=0 #initramfs size\nmodules_loaded=\" \"\n# source our modules.\nfor moddir in \"$dracutbasedir/modules.d\"/[0-9][0-9]*; do\n    _d_mod=${moddir##*/}; _d_mod=${_d_mod#[0-9][0-9]}\n    [[ \"$mods_to_load\" == *\\ $_d_mod\\ * ]] || continue\n    if [[ $show_modules = yes ]]; then\n        printf \"%s\\n\" \"$_d_mod\"\n    else\n        dinfo \"*** Including module: $_d_mod ***\"\n    fi\n    if [[ $kernel_only == yes ]]; then\n        module_installkernel \"$_d_mod\" || {\n            dfatal \"installkernel failed in module $_d_mod\"\n            exit 1\n        }\n    else\n        module_install \"$_d_mod\"\n        if [[ $no_kernel != yes ]]; then\n            module_installkernel \"$_d_mod\" || {\n                dfatal \"installkernel failed in module $_d_mod\"\n                exit 1\n            }\n        fi\n    fi\n    mods_to_load=${mods_to_load// $_d_mod /}\n    modules_loaded+=\"$_d_mod \"\n\n    #print the module install size\n    if [ -n \"$printsize\" ]; then\n        _isize_new=$(du -sk ${initdir}|cut -f1)\n        _isize_delta=$((_isize_new - _isize))\n        printf \"%s\\n\" \"$_d_mod install size: ${_isize_delta}k\"\n        _isize=$_isize_new\n    fi\ndone\nunset moddir\n\nfor i in $modules_loaded; do\n    mkdir -p $initdir/lib/dracut\n    printf \"%s\\n\" \"$i\" >> $initdir/lib/dracut/modules.txt\ndone\n\ndinfo \"*** Including modules done ***\"\n\n## final stuff that has to happen\nif [[ $no_kernel != yes ]]; then\n\n    if [[ $drivers ]]; then\n        hostonly='' instmods $drivers\n    fi\n\n    if [[ $add_drivers ]]; then\n        hostonly='' instmods -c $add_drivers\n    fi\n    if [[ $force_drivers ]]; then\n        hostonly='' instmods -c $force_drivers\n        rm -f $initdir/etc/cmdline.d/20-force_driver.conf\n        for mod in $force_drivers; do\n            echo \"rd.driver.pre=$mod\" >>$initdir/etc/cmdline.d/20-force_drivers.conf\n        done\n    fi\n    if [[ $filesystems ]]; then\n        hostonly='' instmods -c $filesystems\n    fi\n\n    dinfo \"*** Installing kernel module dependencies ***\"\n    dracut_kernel_post\n    dinfo \"*** Installing kernel module dependencies done ***\"\n\n    if [[ $noimageifnotneeded == yes ]] && [[ $hostonly ]]; then\n        if [[ ! -f \"$initdir/lib/dracut/need-initqueue\" ]] && \\\n            [[ -f ${initdir}/lib/modules/$kernel/modules.dep && ! -s ${initdir}/lib/modules/$kernel/modules.dep ]]; then\n            for i in ${initdir}/etc/cmdline.d/*.conf; do\n                # We need no initramfs image and do not generate one.\n                [[ $i == \"${initdir}/etc/cmdline.d/*.conf\" ]] && exit 0\n            done\n        fi\n    fi\nfi\n\nif [[ $kernel_only != yes ]]; then\n    (( ${#install_items[@]} > 0 )) && inst_multiple ${install_items[@]}\n    (( ${#install_optional_items[@]} > 0 )) && inst_multiple -o ${install_optional_items[@]}\n\n    [[ $kernel_cmdline ]] && printf \"%s\\n\" \"$kernel_cmdline\" >> \"${initdir}/etc/cmdline.d/01-default.conf\"\n\n    for line in \"${fstab_lines[@]}\"; do\n        line=($line)\n\n        if [ -z \"${line[1]}\" ]; then\n            # Determine device and mount options from current system\n            mountpoint -q \"${line[0]}\" || derror \"${line[0]} is not a mount point!\"\n            line=($(findmnt --raw -n --target \"${line[0]}\" --output=source,target,fstype,options))\n            dinfo \"Line for ${line[1]}: ${line[@]}\"\n        else\n            # Use default options\n            [ -z \"${line[3]}\" ] && line[3]=\"defaults\"\n        fi\n\n        # Default options for freq and passno\n        [ -z \"${line[4]}\" ] && line[4]=\"0\"\n        [ -z \"${line[5]}\" ] && line[5]=\"2\"\n\n        strstr \"${line[2]}\" \"nfs\" && line[5]=\"0\"\n        echo \"${line[@]}\" >> \"${initdir}/etc/fstab\"\n    done\n\n    for f in $add_fstab; do\n        cat \"$f\" >> \"${initdir}/etc/fstab\"\n    done\n\n    if [[ $systemdutildir ]]; then\n        if [ -d ${initdir}/$systemdutildir ]; then\n            mkdir -p ${initdir}/etc/conf.d\n            {\n                printf \"%s\\n\" \"systemdutildir=\\\"$systemdutildir\\\"\"\n                printf \"%s\\n\" \"systemdsystemunitdir=\\\"$systemdsystemunitdir\\\"\"\n                printf \"%s\\n\" \"systemdsystemconfdir=\\\"$systemdsystemconfdir\\\"\"\n            } > ${initdir}/etc/conf.d/systemd.conf\n        fi\n    fi\n\n    if [[ $DRACUT_RESOLVE_LAZY ]] && [[ $DRACUT_INSTALL ]]; then\n        dinfo \"*** Resolving executable dependencies ***\"\n        find \"$initdir\" -type f -perm /0111 -not -path '*.ko' -print0 \\\n        | xargs -r -0 $DRACUT_INSTALL ${initdir:+-D \"$initdir\"} -R ${DRACUT_FIPS_MODE:+-f} --\n        dinfo \"*** Resolving executable dependencies done***\"\n    fi\n\n    # libpthread workaround: pthread_cancel wants to dlopen libgcc_s.so\n    for _dir in $libdirs; do\n        for _f in \"$_dir/libpthread.so\"*; do\n            [[ -e \"$_f\" ]] || continue\n            inst_libdir_file \"libgcc_s.so*\"\n            break 2\n        done\n    done\nfi\n\nfor ((i=0; i < ${#include_src[@]}; i++)); do\n    src=\"${include_src[$i]}\"\n    target=\"${include_target[$i]}\"\n    if [[ $src && $target ]]; then\n        if [[ -f $src ]]; then\n            inst $src $target\n        else\n            ddebug \"Including directory: $src\"\n            destdir=\"${initdir}/${target}\"\n            mkdir -p \"$destdir\"\n            # check for preexisting symlinks, so we can cope with the\n            # symlinks to $prefix\n            # Objectname is a file or a directory\n            for objectname in \"$src\"/*; do\n                [[ -e \"$objectname\" || -h \"$objectname\" ]] || continue\n                if [[ -d \"$objectname\" ]]; then\n                    # objectname is a directory, let's compute the final directory name\n                    object_destdir=${destdir}/${objectname#$src/}\n                    if ! [[ -e \"$object_destdir\" ]]; then\n                        mkdir -m 0755 -p \"$object_destdir\"\n                        chmod --reference=\"$objectname\" \"$object_destdir\"\n                    fi\n                    cp --reflink=auto --sparse=auto -fa -t \"$object_destdir\" \"$objectname\"/*\n                else\n                    cp --reflink=auto --sparse=auto -fa -t \"$destdir\" \"$objectname\"\n                fi\n            done\n        fi\n    fi\ndone\n\nif [[ $kernel_only != yes ]]; then\n    # make sure that library links are correct and up to date\n    for f in /etc/ld.so.conf /etc/ld.so.conf.d/*; do\n        [[ -f $f ]] && inst_simple \"$f\"\n    done\n    if ! ldconfig -r \"$initdir\"; then\n        if [[ $UID = 0 ]]; then\n            derror \"ldconfig exited ungracefully\"\n        else\n            derror \"ldconfig might need uid=0 (root) for chroot()\"\n        fi\n    fi\nfi\n\nPRELINK_BIN=\"$(command -v prelink)\"\nif [[ $UID = 0 ]] && [[ $PRELINK_BIN ]]; then\n    if [[ $DRACUT_FIPS_MODE ]]; then\n        dinfo \"*** Installing prelink files ***\"\n        inst_multiple -o prelink /etc/prelink.conf /etc/prelink.conf.d/*.conf /etc/prelink.cache\n    elif [[ $do_prelink == yes ]]; then\n        dinfo \"*** Pre-linking files ***\"\n        inst_multiple -o prelink /etc/prelink.conf /etc/prelink.conf.d/*.conf\n        chroot \"$initdir\" \"$PRELINK_BIN\" -a\n        rm -f -- \"$initdir/$PRELINK_BIN\"\n        rm -fr -- \"$initdir\"/etc/prelink.*\n        dinfo \"*** Pre-linking files done ***\"\n    fi\nfi\n\nif [[ $do_hardlink = yes ]] && command -v hardlink >/dev/null; then\n    dinfo \"*** Hardlinking files ***\"\n    hardlink \"$initdir\" 2>&1\n    dinfo \"*** Hardlinking files done ***\"\nfi\n\n# strip binaries\nif [[ $do_strip = yes ]] ; then\n    for p in strip xargs find; do\n        if ! type -P $p >/dev/null; then\n            dinfo \"Could not find '$p'. Not stripping the initramfs.\"\n            do_strip=no\n        fi\n    done\nfi\n\nif [[ $do_strip = yes ]] && ! [[ $DRACUT_FIPS_MODE ]]; then\n    dinfo \"*** Stripping files ***\"\n    find \"$initdir\" -type f \\\n        -executable -not -path '*/lib/modules/*.ko' -print0 \\\n        | xargs -r -0 strip -g 2>/dev/null\n\n    # strip kernel modules, but do not touch signed modules\n    find \"$initdir\" -type f -path '*/lib/modules/*.ko' -print0 \\\n        | while read -r -d $'\\0' f || [ -n \"$f\" ]; do\n        SIG=$(tail -c 28 \"$f\")\n        [[ $SIG == '~Module signature appended~' ]] || { printf \"%s\\000\" \"$f\"; }\n    done | xargs -r -0 strip -g\n\n    dinfo \"*** Stripping files done ***\"\nfi\nif [[ $early_microcode = yes ]]; then\n    dinfo \"*** Generating early-microcode cpio image ***\"\n    ucode_dir=(amd-ucode intel-ucode)\n    ucode_dest=(AuthenticAMD.bin GenuineIntel.bin)\n    _dest_dir=\"$early_cpio_dir/d/kernel/x86/microcode\"\n    _dest_idx=\"0 1\"\n    mkdir -p $_dest_dir\n    if [[ $hostonly ]]; then\n        [[ $(get_cpu_vendor) == \"AMD\" ]] && _dest_idx=\"0\"\n        [[ $(get_cpu_vendor) == \"Intel\" ]] && _dest_idx=\"1\"\n    fi\n    for idx in $_dest_idx; do\n        _fw=${ucode_dir[$idx]}\n        for _fwdir in $fw_dir; do\n            if [[ -d $_fwdir && -d $_fwdir/$_fw ]]; then\n                _src=\"*\"\n                dinfo \"*** Constructing ${ucode_dest[$idx]} ****\"\n                if [[ $hostonly ]]; then\n                    _src=$(get_ucode_file)\n                    [[ $_src ]] || break\n                    [[ -r $_fwdir/$_fw/$_src ]] || break\n                fi\n\n                for i in $_fwdir/$_fw/$_src; do\n                    [ -e \"$i\" ] && break\n                    break 2\n                done\n                for i in $_fwdir/$_fw/$_src; do\n                    [[ -e \"$i\" ]] || continue\n                    # skip gpg files\n                    str_ends \"$i\" \".asc\" && continue\n                    cat \"$i\" >> $_dest_dir/${ucode_dest[$idx]}\n                done\n                create_early_cpio=\"yes\"\n            fi\n        done\n    done\nfi\n\nif [[ $acpi_override = yes ]] && [[ -d $acpi_table_dir ]]; then\n    dinfo \"*** Packaging ACPI tables to override BIOS provided ones ***\"\n    _dest_dir=\"$early_cpio_dir/d/kernel/firmware/acpi\"\n    mkdir -p $_dest_dir\n    for table in $acpi_table_dir/*.aml; do\n        dinfo \"   Adding ACPI table: $table\"\n        cp -a $table $_dest_dir\n        create_early_cpio=\"yes\"\n    done\nfi\n\ndinfo \"*** Store current command line parameters ***\"\nif ! ( echo $PARMS_TO_STORE > $initdir/lib/dracut/build-parameter.txt ); then\n    dfatal \"Could not store the current command line parameters\"\n    exit 1\nfi\n\nif [[ $hostonly_cmdline ]] ; then\n    unset _stored_cmdline\n    if [ -d $initdir/etc/cmdline.d ];then\n        dinfo \"Stored kernel commandline:\"\n        for conf in $initdir/etc/cmdline.d/*.conf ; do\n            [ -e \"$conf\" ] || continue\n            dinfo \"$(< $conf)\"\n            _stored_cmdline=1\n        done\n    fi\n    if ! [[ $_stored_cmdline ]]; then\n        dinfo \"No dracut internal kernel commandline stored in the initramfs\"\n    fi\nfi\n\ndinfo \"*** Creating image file '$outfile' ***\"\n\nif [[ $uefi = yes ]]; then\n    readonly uefi_outdir=\"$DRACUT_TMPDIR/uefi\"\n    mkdir \"$uefi_outdir\"\nfi\n\nif [[ $DRACUT_REPRODUCIBLE ]]; then\n    find \"$initdir\" -newer \"$dracutbasedir/dracut-functions.sh\" -print0 \\\n        | xargs -r -0 touch -h -m -c -r \"$dracutbasedir/dracut-functions.sh\"\n\n    if [[ \"$(cpio --help)\" == *--reproducible* ]]; then\n        CPIO_REPRODUCIBLE=1\n    else\n        dinfo \"cpio does not support '--reproducible'. Resulting image will not be reproducible.\"\n    fi\nfi\n\n[[ \"$UID\" != 0 ]] && cpio_owner_root=\"-R 0:0\"\n\nif [[ $create_early_cpio = yes ]]; then\n    echo 1 > \"$early_cpio_dir/d/early_cpio\"\n\n    if [[ $DRACUT_REPRODUCIBLE ]]; then\n        find \"$early_cpio_dir/d\" -newer \"$dracutbasedir/dracut-functions.sh\" -print0 \\\n            | xargs -r -0 touch -h -m -c -r \"$dracutbasedir/dracut-functions.sh\"\n    fi\n\n    # The microcode blob is _before_ the initramfs blob, not after\n    if ! (\n            cd \"$early_cpio_dir/d\"\n            find . -print0 | sort -z \\\n                | cpio ${CPIO_REPRODUCIBLE:+--reproducible} --null $cpio_owner_root -H newc -o --quiet > \"${DRACUT_TMPDIR}/initramfs.img\"\n        ); then\n        dfatal \"dracut: creation of $outfile failed\"\n        exit 1\n    fi\nfi\n\nif ! (\n        umask 077; cd \"$initdir\"\n        find . -print0 | sort -z \\\n            | cpio ${CPIO_REPRODUCIBLE:+--reproducible} --null $cpio_owner_root -H newc -o --quiet \\\n            | $compress >> \"${DRACUT_TMPDIR}/initramfs.img\"\n    ); then\n    dfatal \"dracut: creation of $outfile failed\"\n    exit 1\nfi\n\nif (( maxloglvl >= 5 )); then\n    if [[ $allowlocal ]]; then\n\t\"$dracutbasedir/lsinitrd.sh\" \"${DRACUT_TMPDIR}/initramfs.img\"| ddebug\n    else\n        lsinitrd \"${DRACUT_TMPDIR}/initramfs.img\"| ddebug\n    fi\nfi\n\numask 077\n\nif [[ $uefi = yes ]]; then\n    if [[ $kernel_cmdline ]]; then\n        echo -n \"$kernel_cmdline\" > \"$uefi_outdir/cmdline.txt\"\n    elif [[ $hostonly_cmdline = yes ]] && [ -d $initdir/etc/cmdline.d ];then\n        for conf in $initdir/etc/cmdline.d/*.conf ; do\n            [ -e \"$conf\" ] || continue\n            printf \"%s \" \"$(< $conf)\" >> \"$uefi_outdir/cmdline.txt\"\n        done\n    else\n        do_print_cmdline > \"$uefi_outdir/cmdline.txt\"\n    fi\n    echo -ne \"\\x00\" >> \"$uefi_outdir/cmdline.txt\"\n\n    dinfo \"Using UEFI kernel cmdline:\"\n    dinfo $(< \"$uefi_outdir/cmdline.txt\")\n\n    [[ -s /usr/lib/os-release ]] && uefi_osrelease=\"/usr/lib/os-release\"\n    [[ -s /etc/os-release ]] && uefi_osrelease=\"/etc/os-release\"\n\n    if objcopy \\\n           ${uefi_osrelease:+--add-section .osrel=$uefi_osrelease --change-section-vma .osrel=0x20000} \\\n           --add-section .cmdline=\"${uefi_outdir}/cmdline.txt\" --change-section-vma .cmdline=0x30000 \\\n           --add-section .linux=\"$kernel_image\" --change-section-vma .linux=0x40000 \\\n           --add-section .initrd=\"${DRACUT_TMPDIR}/initramfs.img\" --change-section-vma .initrd=0x3000000 \\\n           \"$uefi_stub\" \"${uefi_outdir}/linux.efi\" \\\n            && cp --reflink=auto \"${uefi_outdir}/linux.efi\" \"$outfile\"; then\n        dinfo \"*** Creating UEFI image file '$outfile' done ***\"\n    else\n        rm -f -- \"$outfile\"\n        dfatal \"*** Creating UEFI image file '$outfile' failed ***\"\n        exit 1\n    fi\nelse\n    if cp --reflink=auto \"${DRACUT_TMPDIR}/initramfs.img\" \"$outfile\"; then\n        dinfo \"*** Creating initramfs image file '$outfile' done ***\"\n    else\n        rm -f -- \"$outfile\"\n        dfatal \"dracut: creation of $outfile failed\"\n        exit 1\n    fi\nfi\n\ncommand -v restorecon &>/dev/null && restorecon -- \"$outfile\"\n\nexit 0\n"], "fixing_code": ["#!/bin/bash --norc\n#\n# Generator script for a dracut initramfs\n# Tries to retain some degree of compatibility with the command line\n# of the various mkinitrd implementations out there\n#\n\n# Copyright 2005-2013 Red Hat, Inc.  All rights reserved.\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\n# store for logging\n\n# Verify bash version, current minimum is 4\nif (( BASH_VERSINFO[0] < 4 )); then\n    printf -- 'You need at least Bash 4 to use dracut, sorry.' >&2\n    exit 1\nfi\n\ndracut_args=( \"$@\" )\nreadonly dracut_cmd=\"$(readlink -f $0)\"\n\nset -o pipefail\n\nusage() {\n    [[ $dracutbasedir ]] || dracutbasedir=/usr/lib/dracut\n    if [[ -f $dracutbasedir/dracut-version.sh ]]; then\n        . $dracutbasedir/dracut-version.sh\n    fi\n\n#                                                       80x25 linebreak here ^\n    cat << EOF\nUsage: $dracut_cmd [OPTION]... [<initramfs> [<kernel-version>]]\n\nVersion: $DRACUT_VERSION\n\nCreates initial ramdisk images for preloading modules\n\n  -h, --help  Display all options\n\nIf a [LIST] has multiple arguments, then you have to put these in quotes.\n\nFor example:\n\n    # dracut --add-drivers \"module1 module2\"  ...\n\nEOF\n}\n\nlong_usage() {\n    [[ $dracutbasedir ]] || dracutbasedir=/usr/lib/dracut\n    if [[ -f $dracutbasedir/dracut-version.sh ]]; then\n        . $dracutbasedir/dracut-version.sh\n    fi\n\n#                                                       80x25 linebreak here ^\n    cat << EOF\nUsage: $dracut_cmd [OPTION]... [<initramfs> [<kernel-version>]]\n\nVersion: $DRACUT_VERSION\n\nCreates initial ramdisk images for preloading modules\n\n  --kver [VERSION]      Set kernel version to [VERSION].\n  -f, --force           Overwrite existing initramfs file.\n  -a, --add [LIST]      Add a space-separated list of dracut modules.\n  --rebuild         Append arguments to those of existing image and rebuild\n  -m, --modules [LIST]  Specify a space-separated list of dracut modules to\n                         call when building the initramfs. Modules are located\n                         in /usr/lib/dracut/modules.d.\n  -o, --omit [LIST]     Omit a space-separated list of dracut modules.\n  --force-add [LIST]    Force to add a space-separated list of dracut modules\n                         to the default set of modules, when -H is specified.\n  -d, --drivers [LIST]  Specify a space-separated list of kernel modules to\n                         exclusively include in the initramfs.\n  --add-drivers [LIST]  Specify a space-separated list of kernel\n                         modules to add to the initramfs.\n  --force-drivers [LIST] Specify a space-separated list of kernel\n                         modules to add to the initramfs and make sure they\n                         are tried to be loaded via modprobe same as passing\n                         rd.driver.pre=DRIVER kernel parameter.\n  --omit-drivers [LIST] Specify a space-separated list of kernel\n                         modules not to add to the initramfs.\n  --filesystems [LIST]  Specify a space-separated list of kernel filesystem\n                         modules to exclusively include in the generic\n                         initramfs.\n  -k, --kmoddir [DIR]   Specify the directory, where to look for kernel\n                         modules\n  --fwdir [DIR]         Specify additional directories, where to look for\n                         firmwares, separated by :\n  --kernel-only         Only install kernel drivers and firmware files\n  --no-kernel           Do not install kernel drivers and firmware files\n  --print-cmdline       Print the kernel command line for the given disk layout\n  --early-microcode     Combine early microcode with ramdisk\n  --no-early-microcode  Do not combine early microcode with ramdisk\n  --kernel-cmdline [PARAMETERS] Specify default kernel command line parameters\n  --strip               Strip binaries in the initramfs\n  --nostrip             Do not strip binaries in the initramfs\n  --prelink             Prelink binaries in the initramfs\n  --noprelink           Do not prelink binaries in the initramfs\n  --hardlink            Hardlink files in the initramfs\n  --nohardlink          Do not hardlink files in the initramfs\n  --prefix [DIR]        Prefix initramfs files with [DIR]\n  --noprefix            Do not prefix initramfs files\n  --mdadmconf           Include local /etc/mdadm.conf\n  --nomdadmconf         Do not include local /etc/mdadm.conf\n  --lvmconf             Include local /etc/lvm/lvm.conf\n  --nolvmconf           Do not include local /etc/lvm/lvm.conf\n  --fscks [LIST]        Add a space-separated list of fsck helpers.\n  --nofscks             Inhibit installation of any fsck helpers.\n  --ro-mnt              Mount / and /usr read-only by default.\n  -h, --help            This message\n  --debug               Output debug information of the build process\n  --profile             Output profile information of the build process\n  -L, --stdlog [0-6]    Specify logging level (to standard error)\n                         0 - suppress any messages\n                         1 - only fatal errors\n                         2 - all errors\n                         3 - warnings\n                         4 - info\n                         5 - debug info (here starts lots of output)\n                         6 - trace info (and even more)\n  -v, --verbose         Increase verbosity level\n  -q, --quiet           Decrease verbosity level\n  -c, --conf [FILE]     Specify configuration file to use.\n                         Default: /etc/dracut.conf\n  --confdir [DIR]       Specify configuration directory to use *.conf files\n                         from. Default: /etc/dracut.conf.d\n  --tmpdir [DIR]        Temporary directory to be used instead of default\n                         /var/tmp.\n  -l, --local           Local mode. Use modules from the current working\n                         directory instead of the system-wide installed in\n                         /usr/lib/dracut/modules.d.\n                         Useful when running dracut from a git checkout.\n  -H, --hostonly        Host-Only mode: Install only what is needed for\n                        booting the local host instead of a generic host.\n  -N, --no-hostonly     Disables Host-Only mode\n  --hostonly-cmdline    Store kernel command line arguments needed\n                        in the initramfs\n  --no-hostonly-cmdline Do not store kernel command line arguments needed\n                        in the initramfs\n  --hostonly-i18n       Install only needed keyboard and font files according\n                        to the host configuration (default).\n  --no-hostonly-i18n    Install all keyboard and font files available.\n  --persistent-policy [POLICY]\n                        Use [POLICY] to address disks and partitions.\n                        POLICY can be any directory name found in /dev/disk.\n                        E.g. \"by-uuid\", \"by-label\"\n  --fstab               Use /etc/fstab to determine the root device.\n  --add-fstab [FILE]    Add file to the initramfs fstab\n  --mount \"[DEV] [MP] [FSTYPE] [FSOPTS]\"\n                        Mount device [DEV] on mountpoint [MP] with filesystem\n                        [FSTYPE] and options [FSOPTS] in the initramfs\n  --mount \"[MP]\"\tSame as above, but [DEV], [FSTYPE] and [FSOPTS] are\n\t\t\tdetermined by looking at the current mounts.\n  --add-device \"[DEV]\"  Bring up [DEV] in initramfs\n  -i, --include [SOURCE] [TARGET]\n                        Include the files in the SOURCE directory into the\n                         Target directory in the final initramfs.\n                        If SOURCE is a file, it will be installed to TARGET\n                         in the final initramfs.\n  -I, --install [LIST]  Install the space separated list of files into the\n                         initramfs.\n  --install-optional [LIST]  Install the space separated list of files into the\n                         initramfs, if they exist.\n  --gzip                Compress the generated initramfs using gzip.\n                         This will be done by default, unless another\n                         compression option or --no-compress is passed.\n  --bzip2               Compress the generated initramfs using bzip2.\n                         Make sure your kernel has bzip2 decompression support\n                         compiled in, otherwise you will not be able to boot.\n  --lzma                Compress the generated initramfs using lzma.\n                         Make sure your kernel has lzma support compiled in,\n                         otherwise you will not be able to boot.\n  --xz                  Compress the generated initramfs using xz.\n                         Make sure that your kernel has xz support compiled\n                         in, otherwise you will not be able to boot.\n  --lzo                 Compress the generated initramfs using lzop.\n                         Make sure that your kernel has lzo support compiled\n                         in, otherwise you will not be able to boot.\n  --lz4                 Compress the generated initramfs using lz4.\n                         Make sure that your kernel has lz4 support compiled\n                         in, otherwise you will not be able to boot.\n  --compress [COMPRESSION] Compress the generated initramfs with the\n                         passed compression program.  Make sure your kernel\n                         knows how to decompress the generated initramfs,\n                         otherwise you will not be able to boot.\n  --no-compress         Do not compress the generated initramfs.  This will\n                         override any other compression options.\n  --list-modules        List all available dracut modules.\n  -M, --show-modules    Print included module's name to standard output during\n                         build.\n  --keep                Keep the temporary initramfs for debugging purposes\n  --printsize           Print out the module install size\n  --sshkey [SSHKEY]     Add ssh key to initramfs (use with ssh-client module)\n  --logfile [FILE]      Logfile to use (overrides configuration setting)\n  --reproducible        Create reproducible images\n  --no-reproducible     Do not create reproducible images\n  --loginstall [DIR]    Log all files installed from the host to [DIR]\n  --uefi                Create an UEFI executable with the kernel cmdline and\n                        kernel combined\n  --uefi-stub [FILE]    Use the UEFI stub [FILE] to create an UEFI executable\n  --kernel-image [FILE] location of the kernel image\n\nIf [LIST] has multiple arguments, then you have to put these in quotes.\n\nFor example:\n\n    # dracut --add-drivers \"module1 module2\"  ...\n\nEOF\n}\n\n# Fills up host_devs stack variable and makes sure there are no duplicates\npush_host_devs() {\n    local _dev\n    for _dev in \"$@\"; do\n        [[ \" ${host_devs[@]} \" == *\" $_dev \"* ]] && return\n        host_devs+=( \"$_dev\" )\n    done\n}\n\n# Little helper function for reading args from the commandline.\n# it automatically handles -a b and -a=b variants, and returns 1 if\n# we need to shift $3.\nread_arg() {\n    # $1 = arg name\n    # $2 = arg value\n    # $3 = arg parameter\n    local rematch='^[^=]*=(.*)$'\n    if [[ $2 =~ $rematch ]]; then\n        read \"$1\" <<< \"${BASH_REMATCH[1]}\"\n    else\n        read \"$1\" <<< \"$3\"\n        # There is no way to shift our callers args, so\n        # return 1 to indicate they should do it instead.\n        return 1\n    fi\n}\n\ndropindirs_sort()\n{\n    local suffix=$1; shift\n    local -a files\n    local f d\n\n    for d in \"$@\"; do\n        for i in \"$d/\"*\"$suffix\"; do\n            if [[ -e \"$i\" ]]; then\n                printf \"%s\\n\" \"${i##*/}\"\n            fi\n        done\n    done | sort -Vu | {\n        readarray -t files\n\n        for f in \"${files[@]}\"; do\n            for d in \"$@\"; do\n                if [[ -e \"$d/$f\" ]]; then\n                    printf \"%s\\n\" \"$d/$f\"\n                    continue 2\n                fi\n            done\n        done\n    }\n}\n\nrearrange_params()\n{\n    # Workaround -i, --include taking 2 arguments\n    set -- \"${@/--include/++include}\"\n\n    # This prevents any long argument ending with \"-i\"\n    # -i, like --opt-i but I think we can just prevent that\n    set -- \"${@/%-i/++include}\"\n\n    TEMP=$(unset POSIXLY_CORRECT; getopt \\\n        -o \"a:m:o:d:I:k:c:L:fvqlHhMN\" \\\n        --long kver: \\\n        --long add: \\\n        --long force-add: \\\n        --long add-drivers: \\\n        --long force-drivers: \\\n        --long omit-drivers: \\\n        --long modules: \\\n        --long omit: \\\n        --long drivers: \\\n        --long filesystems: \\\n        --long install: \\\n        --long install-optional: \\\n        --long fwdir: \\\n        --long libdirs: \\\n        --long fscks: \\\n        --long add-fstab: \\\n        --long mount: \\\n        --long device: \\\n        --long add-device: \\\n        --long nofscks: \\\n        --long ro-mnt \\\n        --long kmoddir: \\\n        --long conf: \\\n        --long confdir: \\\n        --long tmpdir: \\\n        --long stdlog: \\\n        --long compress: \\\n        --long prefix: \\\n        --long rebuild: \\\n        --long force \\\n        --long kernel-only \\\n        --long no-kernel \\\n        --long print-cmdline \\\n        --long kernel-cmdline: \\\n        --long strip \\\n        --long nostrip \\\n        --long prelink \\\n        --long noprelink \\\n        --long hardlink \\\n        --long nohardlink \\\n        --long noprefix \\\n        --long mdadmconf \\\n        --long nomdadmconf \\\n        --long lvmconf \\\n        --long nolvmconf \\\n        --long debug \\\n        --long profile \\\n        --long sshkey: \\\n        --long logfile: \\\n        --long verbose \\\n        --long quiet \\\n        --long local \\\n        --long hostonly \\\n        --long host-only \\\n        --long no-hostonly \\\n        --long no-host-only \\\n        --long hostonly-cmdline \\\n        --long no-hostonly-cmdline \\\n        --long persistent-policy: \\\n        --long fstab \\\n        --long help \\\n        --long bzip2 \\\n        --long lzma \\\n        --long xz \\\n        --long lzo \\\n        --long lz4 \\\n        --long no-compress \\\n        --long gzip \\\n        --long list-modules \\\n        --long show-modules \\\n        --long keep \\\n        --long printsize \\\n        --long regenerate-all \\\n        --long noimageifnotneeded \\\n        --long early-microcode \\\n        --long no-early-microcode \\\n        --long reproducible \\\n        --long no-reproducible \\\n        --long loginstall: \\\n        --long uefi \\\n        --long uefi-stub: \\\n        --long kernel-image: \\\n        --long no-hostonly-i18n \\\n        --long hostonly-i18n \\\n        -- \"$@\")\n\n    if (( $? != 0 )); then\n        usage\n        exit 1\n    fi\n}\n\nverbosity_mod_l=0\nunset kernel\nunset outfile\n\nrearrange_params \"$@\"\neval set -- \"$TEMP\"\n\n# parse command line args to check if '--rebuild' option is present\nunset append_args_l\nunset rebuild_file\nwhile :\ndo\n\tif [ \"$1\" == \"--\" ]; then\n\t    shift; break\n\tfi\n\tif [ \"$1\" == \"--rebuild\" ]; then\n\t    append_args_l=\"yes\"\n            rebuild_file=$2\n            if [ ! -e $rebuild_file ]; then\n                echo \"Image file '$rebuild_file', for rebuild, does not exist!\"\n                exit 1\n            fi\n            abs_rebuild_file=$(readlink -f \"$rebuild_file\") && rebuild_file=\"$abs_rebuild_file\"\n\t    shift; continue\n\tfi\n\tshift\ndone\n\n# get output file name and kernel version from command line arguments\nwhile (($# > 0)); do\n    case ${1%%=*} in\n        ++include)\n            shift 2;;\n        *)\n            if ! [[ ${outfile+x} ]]; then\n                outfile=$1\n            elif ! [[ ${kernel+x} ]]; then\n                kernel=$1\n            else\n                printf \"\\nUnknown arguments: %s\\n\\n\" \"$*\" >&2\n                usage; exit 1;\n            fi\n            ;;\n    esac\n    shift\ndone\n\n# extract input image file provided with rebuild option to get previous parameters, if any\nif [[ $append_args_l == \"yes\" ]]; then\n    unset rebuild_param\n\n    # determine resultant file\n    if ! [[ $outfile ]]; then\n        outfile=$rebuild_file\n    fi\n\n    if ! rebuild_param=$(lsinitrd $rebuild_file '*lib/dracut/build-parameter.txt'); then\n        echo \"Image '$rebuild_file' has no rebuild information stored\"\n        exit 1\n    fi\n\n    # prepend previous parameters to current command line args\n    if [[ $rebuild_param ]]; then\n        TEMP=\"$rebuild_param $TEMP\"\n        eval set -- \"$TEMP\"\n        rearrange_params \"$@\"\n    fi\n\n    # clean the temporarily used scratch-pad directory\n    rm -rf $scratch_dir\nfi\n\nunset PARMS_TO_STORE\nPARMS_TO_STORE=\"\"\n\neval set -- \"$TEMP\"\n\nwhile :; do\n    if [ $1 != \"--\" ] && [ $1 != \"--rebuild\" ]; then\n        PARMS_TO_STORE+=\" $1\";\n    fi\n    case $1 in\n        --kver)        kernel=\"$2\";                           PARMS_TO_STORE+=\" '$2'\"; shift;;\n        -a|--add)      add_dracutmodules_l+=(\"$2\");           PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --force-add)   force_add_dracutmodules_l+=(\"$2\");     PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --add-drivers) add_drivers_l+=(\"$2\");                 PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --force-drivers) force_drivers_l+=(\"$2\");             PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --omit-drivers) omit_drivers_l+=(\"$2\");               PARMS_TO_STORE+=\" '$2'\"; shift;;\n        -m|--modules)  dracutmodules_l+=(\"$2\");               PARMS_TO_STORE+=\" '$2'\"; shift;;\n        -o|--omit)     omit_dracutmodules_l+=(\"$2\");          PARMS_TO_STORE+=\" '$2'\"; shift;;\n        -d|--drivers)  drivers_l+=(\"$2\");                     PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --filesystems) filesystems_l+=(\"$2\");                 PARMS_TO_STORE+=\" '$2'\"; shift;;\n        -I|--install)  install_items_l+=(\"$2\");               PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --install-optional) install_optional_items_l+=(\"$2\"); PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --fwdir)       fw_dir_l+=(\"$2\");                      PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --libdirs)     libdirs_l+=(\"$2\");                     PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --fscks)       fscks_l+=(\"$2\");                       PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --add-fstab)   add_fstab_l+=(\"$2\");                   PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --mount)       fstab_lines+=(\"$2\");                   PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --add-device|--device) add_device_l+=(\"$2\");          PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --kernel-cmdline) kernel_cmdline_l+=(\"$2\");           PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --nofscks)     nofscks_l=\"yes\";;\n        --ro-mnt)      ro_mnt_l=\"yes\";;\n        -k|--kmoddir)  drivers_dir_l=\"$2\";             PARMS_TO_STORE+=\" '$2'\"; shift;;\n        -c|--conf)     conffile=\"$2\";                  PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --confdir)     confdir=\"$2\";                   PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --tmpdir)      tmpdir_l=\"$2\";                  PARMS_TO_STORE+=\" '$2'\"; shift;;\n        -L|--stdlog)   stdloglvl_l=\"$2\";               PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --compress)    compress_l=\"$2\";                PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --prefix)      prefix_l=\"$2\";                  PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --loginstall)  loginstall_l=\"$2\";              PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --rebuild)     if [ $rebuild_file == $outfile ]; then\n                           force=yes\n                       fi\n                       shift\n                       ;;\n        -f|--force)    force=yes;;\n        --kernel-only) kernel_only=\"yes\"; no_kernel=\"no\";;\n        --no-kernel)   kernel_only=\"no\"; no_kernel=\"yes\";;\n        --print-cmdline)\n                       print_cmdline=\"yes\"; hostonly_l=\"yes\"; kernel_only=\"yes\"; no_kernel=\"yes\";;\n        --early-microcode)\n                       early_microcode_l=\"yes\";;\n        --no-early-microcode)\n                       early_microcode_l=\"no\";;\n        --strip)       do_strip_l=\"yes\";;\n        --nostrip)     do_strip_l=\"no\";;\n        --prelink)     do_prelink_l=\"yes\";;\n        --noprelink)   do_prelink_l=\"no\";;\n        --hardlink)    do_hardlink_l=\"yes\";;\n        --nohardlink)  do_hardlink_l=\"no\";;\n        --noprefix)    prefix_l=\"/\";;\n        --mdadmconf)   mdadmconf_l=\"yes\";;\n        --nomdadmconf) mdadmconf_l=\"no\";;\n        --lvmconf)     lvmconf_l=\"yes\";;\n        --nolvmconf)   lvmconf_l=\"no\";;\n        --debug)       debug=\"yes\";;\n        --profile)     profile=\"yes\";;\n        --sshkey)      sshkey=\"$2\";                    PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --logfile)     logfile_l=\"$2\"; shift;;\n        -v|--verbose)  ((verbosity_mod_l++));;\n        -q|--quiet)    ((verbosity_mod_l--));;\n        -l|--local)\n                       allowlocal=\"yes\"\n                       [[ -f \"$(readlink -f \"${0%/*}\")/dracut-init.sh\" ]] \\\n                           && dracutbasedir=\"$(readlink -f \"${0%/*}\")\"\n                       ;;\n        -H|--hostonly|--host-only)\n                       hostonly_l=\"yes\" ;;\n        -N|--no-hostonly|--no-host-only)\n                       hostonly_l=\"no\" ;;\n        --hostonly-cmdline)\n                       hostonly_cmdline_l=\"yes\" ;;\n        --hostonly-i18n)\n                       i18n_install_all_l=\"no\" ;;\n        --no-hostonly-i18n)\n                       i18n_install_all_l=\"yes\" ;;\n        --no-hostonly-cmdline)\n                       hostonly_cmdline_l=\"no\" ;;\n        --persistent-policy)\n                       persistent_policy_l=\"$2\";       PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --fstab)       use_fstab_l=\"yes\" ;;\n        -h|--help)     long_usage; exit 1 ;;\n        -i|--include)  include_src+=(\"$2\");          PARMS_TO_STORE+=\" '$2'\";\n                       shift;;\n        --bzip2)       compress_l=\"bzip2\";;\n        --lzma)        compress_l=\"lzma\";;\n        --xz)          compress_l=\"xz\";;\n        --lzo)         compress_l=\"lzo\";;\n        --lz4)         compress_l=\"lz4\";;\n        --no-compress) _no_compress_l=\"cat\";;\n        --gzip)        compress_l=\"gzip\";;\n        --list-modules) do_list=\"yes\";;\n        -M|--show-modules)\n                       show_modules_l=\"yes\"\n                       ;;\n        --keep)        keep=\"yes\";;\n        --printsize)   printsize=\"yes\";;\n        --regenerate-all) regenerate_all=\"yes\";;\n        --noimageifnotneeded) noimageifnotneeded=\"yes\";;\n        --reproducible) reproducible_l=\"yes\";;\n        --no-reproducible) reproducible_l=\"no\";;\n        --uefi)        uefi=\"yes\";;\n        --uefi-stub)\n                       uefi_stub_l=\"$2\";               PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --kernel-image)\n                       kernel_image_l=\"$2\";            PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --) shift; break;;\n\n        *)  # should not even reach this point\n            printf \"\\n!Unknown option: '%s'\\n\\n\" \"$1\" >&2; usage; exit 1;;\n    esac\n    shift\ndone\n\n# getopt cannot handle multiple arguments, so just handle \"-I,--include\"\n# the old fashioned way\n\nwhile (($# > 0)); do\n    if [ \"${1%%=*}\" == \"++include\" ]; then\n        include_src+=(\"$2\")\n        include_target+=(\"$3\")\n        PARMS_TO_STORE+=\" --include '$2' '$3'\"\n        shift 2\n    fi\n    shift\ndone\n\nif [[ $regenerate_all == \"yes\" ]]; then\n    ret=0\n    if [[ $kernel ]]; then\n        printf -- \"--regenerate-all cannot be called with a kernel version\\n\" >&2\n        exit 1\n    fi\n\n    if [[ $outfile ]]; then\n        printf -- \"--regenerate-all cannot be called with a image file\\n\" >&2\n        exit 1\n    fi\n\n    ((len=${#dracut_args[@]}))\n    for ((i=0; i < len; i++)); do\n        [[ ${dracut_args[$i]} == \"--regenerate-all\" ]] && \\\n            unset dracut_args[$i]\n    done\n\n    cd /lib/modules\n    for i in *; do\n        [[ -f $i/modules.dep ]] || [[ -f $i/modules.dep.bin ]] || continue\n        \"$dracut_cmd\" --kver=\"$i\" \"${dracut_args[@]}\"\n        ((ret+=$?))\n    done\n    exit $ret\nfi\n\nif ! [[ $kernel ]]; then\n    kernel=$(uname -r)\nfi\n\nif [[ $kernel ]]; then\n    if ! [[ -d /lib/modules/$kernel ]] && [[ $no_kernel != yes ]]; then\n        printf -- \"Kernel version $kernel has no module directory /lib/modules/$kernel\\n\" >&2\n    fi\nfi\n\nif ! [[ $outfile ]]; then\n    [[ -f /etc/machine-id ]] && read MACHINE_ID < /etc/machine-id\n\n    if [[ $MACHINE_ID ]] && ( [[ -d /boot/${MACHINE_ID} ]] || [[ -L /boot/${MACHINE_ID} ]] ); then\n        outfile=\"/boot/${MACHINE_ID}/$kernel/initrd\"\n    else\n        outfile=\"/boot/initramfs-$kernel.img\"\n    fi\nfi\n\nunset LC_MESSAGES\nunset LC_CTYPE\nexport LC_ALL=C\nexport LANG=C\nunset LD_LIBRARY_PATH\nunset LD_PRELOAD\nunset GREP_OPTIONS\n\nexport DRACUT_LOG_LEVEL=warning\n[[ $debug ]] && {\n    export DRACUT_LOG_LEVEL=debug\n    export PS4='${BASH_SOURCE}@${LINENO}(${FUNCNAME[0]}): ';\n    set -x\n}\n\n[[ $profile ]] && {\n    export PS4='+ $(date \"+%s.%N\") ${BASH_SOURCE}@${LINENO}: ';\n    set -x\n    debug=yes\n}\n\n[[ $dracutbasedir ]] || dracutbasedir=/usr/lib/dracut\n\n# if we were not passed a config file, try the default one\nif [[ ! -f $conffile ]]; then\n    if [[ $allowlocal ]]; then\n        conffile=\"$dracutbasedir/dracut.conf\"\n    else\n        conffile=\"/etc/dracut.conf\"\n    fi\nfi\n\nif [[ ! -d $confdir ]]; then\n    if [[ $allowlocal ]]; then\n        confdir=\"$dracutbasedir/dracut.conf.d\"\n    else\n        confdir=\"/etc/dracut.conf.d\"\n    fi\nfi\n\n# source our config file\n[[ -f $conffile ]] && . \"$conffile\"\n\n# source our config dir\nfor f in $(dropindirs_sort \".conf\" \"$confdir\" \"$dracutbasedir/dracut.conf.d\"); do\n    [[ -e $f ]] && . \"$f\"\ndone\n\nDRACUT_PATH=${DRACUT_PATH:-/sbin /bin /usr/sbin /usr/bin}\n\nfor i in $DRACUT_PATH; do\n    rl=$i\n    if [ -L \"$i\" ]; then\n        rl=$(readlink -f $i)\n    fi\n    if [[ \"$NPATH\" != *:$rl* ]] ; then\n        NPATH+=\":$rl\"\n    fi\ndone\nexport PATH=\"${NPATH#:}\"\nunset NPATH\n\n# these options add to the stuff in the config file\n(( ${#add_dracutmodules_l[@]} )) && add_dracutmodules+=\" ${add_dracutmodules_l[@]} \"\n(( ${#force_add_dracutmodules_l[@]} )) && force_add_dracutmodules+=\" ${force_add_dracutmodules_l[@]} \"\n(( ${#fscks_l[@]} )) && fscks+=\" ${fscks_l[@]} \"\n(( ${#add_fstab_l[@]} )) && add_fstab+=\" ${add_fstab_l[@]} \"\n(( ${#fstab_lines_l[@]} )) && fstab_lines+=( \"${fstab_lines_l[@]}\" )\n(( ${#install_items_l[@]} )) && install_items+=\" ${install_items_l[@]} \"\n(( ${#install_optional_items_l[@]} )) && install_optional_items+=\" ${install_optional_items_l[@]} \"\n\n# these options override the stuff in the config file\n(( ${#dracutmodules_l[@]} )) && dracutmodules=\"${dracutmodules_l[@]}\"\n(( ${#omit_dracutmodules_l[@]} )) && omit_dracutmodules=\"${omit_dracutmodules_l[@]}\"\n(( ${#filesystems_l[@]} )) && filesystems=\"${filesystems_l[@]}\"\n(( ${#fw_dir_l[@]} )) && fw_dir=\"${fw_dir_l[@]}\"\n(( ${#libdirs_l[@]} ))&& libdirs=\"${libdirs_l[@]}\"\n\n[[ $stdloglvl_l ]] && stdloglvl=$stdloglvl_l\n[[ ! $stdloglvl ]] && stdloglvl=4\nstdloglvl=$((stdloglvl + verbosity_mod_l))\n((stdloglvl > 6)) && stdloglvl=6\n((stdloglvl < 0)) && stdloglvl=0\n\n[[ $drivers_dir_l ]] && drivers_dir=$drivers_dir_l\n[[ $do_strip_l ]] && do_strip=$do_strip_l\n[[ $do_strip ]] || do_strip=yes\n[[ $do_prelink_l ]] && do_prelink=$do_prelink_l\n[[ $do_prelink ]] || do_prelink=yes\n[[ $do_hardlink_l ]] && do_hardlink=$do_hardlink_l\n[[ $do_hardlink ]] || do_hardlink=yes\n[[ $prefix_l ]] && prefix=$prefix_l\n[[ $prefix = \"/\" ]] && unset prefix\n[[ $hostonly_l ]] && hostonly=$hostonly_l\n[[ $hostonly_cmdline_l ]] && hostonly_cmdline=$hostonly_cmdline_l\n[[ \"$hostonly\" == \"yes\" ]] && ! [[ $hostonly_cmdline ]] && hostonly_cmdline=\"yes\"\n[[ $i18n_install_all_l ]] && i18n_install_all=$i18n_install_all_l\n[[ $persistent_policy_l ]] && persistent_policy=$persistent_policy_l\n[[ $use_fstab_l ]] && use_fstab=$use_fstab_l\n[[ $mdadmconf_l ]] && mdadmconf=$mdadmconf_l\n[[ $lvmconf_l ]] && lvmconf=$lvmconf_l\n[[ $dracutbasedir ]] || dracutbasedir=/usr/lib/dracut\n[[ $fw_dir ]] || fw_dir=\"/lib/firmware/updates:/lib/firmware:/lib/firmware/$kernel\"\n[[ $tmpdir_l ]] && tmpdir=\"$tmpdir_l\"\n[[ $tmpdir ]] || tmpdir=/var/tmp\n[[ $INITRD_COMPRESS ]] && compress=$INITRD_COMPRESS\n[[ $compress_l ]] && compress=$compress_l\n[[ $show_modules_l ]] && show_modules=$show_modules_l\n[[ $nofscks_l ]] && nofscks=\"yes\"\n[[ $ro_mnt_l ]] && ro_mnt=\"yes\"\n[[ $early_microcode_l ]] && early_microcode=$early_microcode_l\n[[ $early_microcode ]] || early_microcode=no\n[[ $logfile_l ]] && logfile=\"$logfile_l\"\n[[ $reproducible_l ]] && reproducible=\"$reproducible_l\"\n[[ $loginstall_l ]] && loginstall=\"$loginstall_l\"\n[[ $uefi_stub_l ]] && uefi_stub=\"$uefi_stub_l\"\n[[ $kernel_image_l ]] && kernel_image=\"$kernel_image_l\"\n\n# eliminate IFS hackery when messing with fw_dir\nexport DRACUT_FIRMWARE_PATH=${fw_dir// /:}\nfw_dir=${fw_dir//:/ }\n\n# check for logfile and try to create one if it doesn't exist\nif [[ -n \"$logfile\" ]];then\n    if [[ ! -f \"$logfile\" ]];then\n        touch \"$logfile\"\n        if [ ! $? -eq 0 ] ;then\n            printf \"%s\\n\" \"dracut: touch $logfile failed.\" >&2\n        fi\n    fi\nfi\n\n# handle compression options.\nif [[ $_no_compress_l = \"cat\" ]]; then\n    compress=\"cat\"\nfi\n\nif ! [[ $compress ]]; then\n    # check all known compressors, if none specified\n    for i in pigz gzip lz4 lzop lzma xz lbzip2 bzip2 cat; do\n        command -v \"$i\" &>/dev/null || continue\n        compress=\"$i\"\n        break\n    done\n    if [[ $compress = cat ]]; then\n            printf \"%s\\n\" \"dracut: no compression tool available. Initramfs image is going to be big.\" >&2\n    fi\nfi\n\n# choose the right arguments for the compressor\ncase $compress in\n    bzip2|lbzip2)\n        if [[ \"$compress\" =  lbzip2 ]] || command -v lbzip2 &>/dev/null; then\n            compress=\"lbzip2 -9\"\n        else\n            compress=\"bzip2 -9\"\n        fi\n        ;;\n    lzma)\n        compress=\"lzma -9 -T0\"\n        ;;\n    xz)\n        compress=\"xz --check=crc32 --lzma2=dict=1MiB -T0\"\n        ;;\n    gzip|pigz)\n        if [[ \"$compress\" = pigz ]] || command -v pigz &>/dev/null; then\n            compress=\"pigz -9 -n -T -R\"\n        elif command -v gzip &>/dev/null && gzip --help 2>&1 | grep -q rsyncable; then\n            compress=\"gzip -n -9 --rsyncable\"\n        else\n            compress=\"gzip -n -9\"\n        fi\n        ;;\n    lzo|lzop)\n        compress=\"lzop -9\"\n        ;;\n    lz4)\n        compress=\"lz4 -l -9\"\n        ;;\nesac\n\n[[ $hostonly = yes ]] && hostonly=\"-h\"\n[[ $hostonly != \"-h\" ]] && unset hostonly\n\n[[ $reproducible == yes ]] && DRACUT_REPRODUCIBLE=1\n\nreadonly TMPDIR=\"$tmpdir\"\nreadonly DRACUT_TMPDIR=\"$(mktemp -p \"$TMPDIR/\" -d -t dracut.XXXXXX)\"\n[ -d \"$DRACUT_TMPDIR\" ] || {\n    printf \"%s\\n\" \"dracut: mktemp -p '$TMPDIR/' -d -t dracut.XXXXXX failed.\" >&2\n    exit 1\n}\n\n# clean up after ourselves no matter how we die.\ntrap '\n    ret=$?;\n    [[ $keep ]] && echo \"Not removing $DRACUT_TMPDIR.\" >&2 || { [[ $DRACUT_TMPDIR ]] && rm -rf -- \"$DRACUT_TMPDIR\"; };\n    exit $ret;\n    ' EXIT\n\n# clean up after ourselves no matter how we die.\ntrap 'exit 1;' SIGINT\n\nreadonly initdir=\"${DRACUT_TMPDIR}/initramfs\"\nmkdir \"$initdir\"\n\nif [[ $early_microcode = yes ]] || ( [[ $acpi_override = yes ]] && [[ -d $acpi_table_dir ]] ); then\n    readonly early_cpio_dir=\"${DRACUT_TMPDIR}/earlycpio\"\n    mkdir \"$early_cpio_dir\"\nfi\n\nexport DRACUT_RESOLVE_LAZY=\"1\"\n\nif [[ $print_cmdline ]]; then\n    stdloglvl=0\n    sysloglvl=0\n    fileloglvl=0\n    kmsgloglvl=0\nfi\n\nif [[ -f $dracutbasedir/dracut-version.sh ]]; then\n    . $dracutbasedir/dracut-version.sh\nfi\n\nif [[ -f $dracutbasedir/dracut-init.sh ]]; then\n    . $dracutbasedir/dracut-init.sh\nelse\n    printf \"%s\\n\" \"dracut: Cannot find $dracutbasedir/dracut-init.sh.\" >&2\n    printf \"%s\\n\" \"dracut: Are you running from a git checkout?\" >&2\n    printf \"%s\\n\" \"dracut: Try passing -l as an argument to $dracut_cmd\" >&2\n    exit 1\nfi\n\nif ! [[ $print_cmdline ]]; then\n    inst /bin/sh\n    if ! $DRACUT_INSTALL ${initdir:+-D \"$initdir\"} -R \"$initdir/bin/sh\" &>/dev/null; then\n        unset DRACUT_RESOLVE_LAZY\n        export DRACUT_RESOLVE_DEPS=1\n    fi\n    rm -fr -- ${initdir}/*\nfi\n\ndracutfunctions=$dracutbasedir/dracut-functions.sh\nexport dracutfunctions\n\n(( ${#drivers_l[@]} )) && drivers=\"${drivers_l[@]}\"\ndrivers=${drivers/-/_}\n\n(( ${#add_drivers_l[@]} )) && add_drivers+=\" ${add_drivers_l[@]} \"\nadd_drivers=${add_drivers/-/_}\n\n(( ${#force_drivers_l[@]} )) && force_drivers+=\" ${force_drivers_l[@]} \"\nforce_drivers=${force_drivers/-/_}\n\n(( ${#omit_drivers_l[@]} )) && omit_drivers+=\" ${omit_drivers_l[@]} \"\nomit_drivers=${omit_drivers/-/_}\n\n(( ${#kernel_cmdline_l[@]} )) && kernel_cmdline+=\" ${kernel_cmdline_l[@]} \"\n\nomit_drivers_corrected=\"\"\nfor d in $omit_drivers; do\n    [[ \" $drivers $add_drivers \" == *\\ $d\\ * ]] && continue\n    [[ \" $drivers $force_drivers \" == *\\ $d\\ * ]] && continue\n    omit_drivers_corrected+=\"$d|\"\ndone\nomit_drivers=\"${omit_drivers_corrected%|}\"\nunset omit_drivers_corrected\n\n# prepare args for logging\nfor ((i=0; i < ${#dracut_args[@]}; i++)); do\n    [[ \"${dracut_args[$i]}\" == *\\ * ]] && \\\n        dracut_args[$i]=\"\\\"${dracut_args[$i]}\\\"\"\n        #\" keep vim happy\ndone\n\ndinfo \"Executing: $dracut_cmd ${dracut_args[@]}\"\n\n[[ $do_list = yes ]] && {\n    for mod in $dracutbasedir/modules.d/*; do\n        [[ -d $mod ]] || continue;\n        [[ -e $mod/install || -e $mod/installkernel || \\\n            -e $mod/module-setup.sh ]] || continue\n        printf \"%s\\n\" \"${mod##*/??}\"\n    done\n    exit 0\n}\n\n# This is kinda legacy -- eventually it should go away.\ncase $dracutmodules in\n    \"\"|auto) dracutmodules=\"all\" ;;\nesac\n\nabs_outfile=$(readlink -f \"$outfile\") && outfile=\"$abs_outfile\"\n\nif [[ $no_kernel != yes ]] && [[ -d $srcmods ]]; then\n    if ! [[ -f $srcmods/modules.dep ]]; then\n        if [[ -n \"$(find \"$srcmods\" -name '*.ko*')\" ]]; then\n            dfatal \"$srcmods/modules.dep is missing. Did you run depmod?\"\n            exit 1\n        else\n            dwarn \"$srcmods/modules.dep is missing. Did you run depmod?\"\n        fi\n    elif ! ( command -v gzip &>/dev/null && command -v xz &>/dev/null); then\n        read _mod < $srcmods/modules.dep\n        _mod=${_mod%%:*}\n        if [[ -f $srcmods/\"$_mod\" ]]; then\n            # Check, if kernel modules are compressed, and if we can uncompress them\n            case \"$_mod\" in\n                *.ko.gz) kcompress=gzip;;\n                *.ko.xz) kcompress=xz;;\n            esac\n            if [[ $kcompress ]]; then\n                if ! command -v \"$kcompress\" &>/dev/null; then\n                    dfatal \"Kernel modules are compressed with $kcompress, but $kcompress is not available.\"\n                    exit 1\n                fi\n            fi\n        fi\n    fi\nfi\n\nif [[ ! $print_cmdline ]]; then\n    if [[ -f $outfile && ! $force ]]; then\n        dfatal \"Will not override existing initramfs ($outfile) without --force\"\n        exit 1\n    fi\n\n    outdir=${outfile%/*}\n    [[ $outdir ]] || outdir=\"/\"\n\n    if [[ ! -d \"$outdir\" ]]; then\n        dfatal \"Can't write to $outdir: Directory $outdir does not exist or is not accessible.\"\n        exit 1\n    elif [[ ! -w \"$outdir\" ]]; then\n        dfatal \"No permission to write to $outdir.\"\n        exit 1\n    elif [[ -f \"$outfile\" && ! -w \"$outfile\" ]]; then\n        dfatal \"No permission to write $outfile.\"\n        exit 1\n    fi\n\n    if [[ $loginstall ]]; then\n        if ! mkdir -p \"$loginstall\"; then\n            dfatal \"Could not create directory to log installed files to '$loginstall'.\"\n            exit 1\n        fi\n        loginstall=$(readlink -f \"$loginstall\")\n    fi\n\n    if [[ $uefi = yes ]]; then\n        if ! command -v objcopy &>/dev/null; then\n            dfatal \"Need 'objcopy' to create a UEFI executable\"\n            exit 1\n        fi\n        unset EFI_MACHINE_TYPE_NAME\n        case $(arch) in\n            x86_64)\n                EFI_MACHINE_TYPE_NAME=x64;;\n            ia32)\n                EFI_MACHINE_TYPE_NAME=ia32;;\n            *)\n                dfatal \"Architecture '$(arch)' not supported to create a UEFI executable\"\n                exit 1\n                ;;\n        esac\n\n        if ! [[ -s $uefi_stub ]]; then\n            for uefi_stub in \\\n                \"/lib/systemd/boot/efi/linux${EFI_MACHINE_TYPE_NAME}.efi.stub\" \\\n                    \"/usr/lib/gummiboot/linux${EFI_MACHINE_TYPE_NAME}.efi.stub\"; do\n                [[ -s $uefi_stub ]] || continue\n                break\n            done\n        fi\n        if ! [[ -s $uefi_stub ]]; then\n            dfatal \"Can't find a uefi stub '$uefi_stub' to create a UEFI executable\"\n            exit 1\n        fi\n\n        if ! [[ $kernel_image ]]; then\n            for kernel_image in \"/lib/modules/$kernel/vmlinuz\" \"/boot/vmlinuz-$kernel\"; do\n                [[ -s \"$kernel_image\" ]] || continue\n                break\n            done\n        fi\n        if ! [[ -s $kernel_image ]]; then\n            dfatal \"Can't find a kernel image '$kernel_image' to create a UEFI executable\"\n            exit 1\n        fi\n    fi\nfi\n\nif [[ $acpi_override = yes ]] && ! check_kernel_config CONFIG_ACPI_INITRD_TABLE_OVERRIDE; then\n    dwarn \"Disabling ACPI override, because kernel does not support it. CONFIG_ACPI_INITRD_TABLE_OVERRIDE!=y\"\n    unset acpi_override\nfi\n\nif [[ $early_microcode = yes ]]; then\n    if [[ $hostonly ]]; then\n        [[ $(get_cpu_vendor) == \"AMD\" ]] \\\n            && ! check_kernel_config CONFIG_MICROCODE_AMD \\\n            && unset early_microcode\n        [[ $(get_cpu_vendor) == \"Intel\" ]] \\\n            && ! check_kernel_config CONFIG_MICROCODE_INTEL \\\n            && unset early_microcode\n    else\n        ! check_kernel_config CONFIG_MICROCODE_AMD \\\n            && ! check_kernel_config CONFIG_MICROCODE_INTEL \\\n            && unset early_microcode\n    fi\n    [[ $early_microcode != yes ]] \\\n        && dwarn \"Disabling early microcode, because kernel does not support it. CONFIG_MICROCODE_[AMD|INTEL]!=y\"\nfi\n\n# Need to be able to have non-root users read stuff (rpcbind etc)\nchmod 755 \"$initdir\"\n\nif [[ $hostonly ]]; then\n    for i in /sys /proc /run /dev; do\n        if ! findmnt --target \"$i\" &>/dev/null; then\n            dwarning \"Turning off host-only mode: '$i' is not mounted!\"\n            unset hostonly\n        fi\n    done\nfi\n\ndeclare -A host_fs_types\n\nfor line in \"${fstab_lines[@]}\"; do\n    set -- $line\n    dev=\"$1\"\n    #dev mp fs fsopts\n    case \"$dev\" in\n        UUID=*)\n            dev=$(blkid -l -t UUID=${dev#UUID=} -o device)\n            ;;\n        LABEL=*)\n            dev=$(blkid -l -t LABEL=${dev#LABEL=} -o device)\n            ;;\n        PARTUUID=*)\n            dev=$(blkid -l -t PARTUUID=${dev#PARTUUID=} -o device)\n            ;;\n        PARTLABEL=*)\n            dev=$(blkid -l -t PARTLABEL=${dev#PARTLABEL=} -o device)\n            ;;\n    esac\n    [ -z \"$dev\" ] && dwarn \"Bad fstab entry $@\" && continue\n    if [[ \"$3\" == btrfs ]]; then\n        for i in $(btrfs_devs \"$2\"); do\n            push_host_devs \"$i\"\n        done\n    fi\n    push_host_devs \"$dev\"\n    host_fs_types[\"$dev\"]=\"$3\"\ndone\n\nfor f in $add_fstab; do\n    [[ -e $f ]] || continue\n    while read dev rest || [ -n \"$dev\" ]; do\n        push_host_devs \"$dev\"\n    done < \"$f\"\ndone\n\nfor dev in $add_device; do\n    push_host_devs \"$dev\"\ndone\n\nif (( ${#add_device_l[@]} )); then\n    add_device+=\" ${add_device_l[@]} \"\n    push_host_devs \"${add_device_l[@]}\"\nfi\n\nif [[ $hostonly ]]; then\n    # in hostonly mode, determine all devices, which have to be accessed\n    # and examine them for filesystem types\n\n    for mp in \\\n        \"/\" \\\n        \"/etc\" \\\n        \"/bin\" \\\n        \"/sbin\" \\\n        \"/lib\" \\\n        \"/lib64\" \\\n        \"/usr\" \\\n        \"/usr/bin\" \\\n        \"/usr/sbin\" \\\n        \"/usr/lib\" \\\n        \"/usr/lib64\" \\\n        \"/boot\" \\\n        \"/boot/efi\" \\\n        ;\n    do\n        mp=$(readlink -f \"$mp\")\n        mountpoint \"$mp\" >/dev/null 2>&1 || continue\n        _dev=$(find_block_device \"$mp\")\n        _bdev=$(readlink -f \"/dev/block/$_dev\")\n        [[ -b $_bdev ]] && _dev=$_bdev\n        [[ \"$mp\" == \"/\" ]] && root_devs+=(\"$_dev\")\n        push_host_devs \"$_dev\"\n        if [[ $(find_mp_fstype \"$mp\") == btrfs ]]; then\n            for i in $(btrfs_devs \"$mp\"); do\n                [[ \"$mp\" == \"/\" ]] && root_devs+=(\"$i\")\n                push_host_devs \"$i\"\n            done\n        fi\n    done\n\n    if [[ -f /proc/swaps ]] && [[ -f /etc/fstab ]]; then\n        while read dev type rest || [ -n \"$dev\" ]; do\n            [[ -b $dev ]] || continue\n            [[ \"$type\" == \"partition\" ]] || continue\n\n            while read _d _m _t _o _r || [ -n \"$_d\" ]; do\n                [[ \"$_d\" == \\#* ]] && continue\n                [[ $_d ]] || continue\n                [[ $_t != \"swap\" ]] && continue\n                [[ $_m != \"swap\" ]] && [[ $_m != \"none\" ]] && continue\n                [[ \"$_o\" == *noauto* ]] && continue\n                _d=$(expand_persistent_dev \"$_d\")\n                [[ \"$_d\" -ef \"$dev\" ]] || continue\n\n                if [[ -f /etc/crypttab ]]; then\n                    while read _mapper _a _p _o || [ -n \"$_mapper\" ]; do\n                        [[ $_mapper = \\#* ]] && continue\n                        [[ \"$_d\" -ef /dev/mapper/\"$_mapper\" ]] || continue\n                        [[ \"$_o\" ]] || _o=\"$_p\"\n                        # skip entries with password files\n                        [[ \"$_p\" == /* ]] && [[ -f $_p ]] && continue 2\n                        # skip mkswap swap\n                        [[ $_o == *swap* ]] && continue 2\n                    done < /etc/crypttab\n                fi\n\n                _dev=\"$(readlink -f \"$dev\")\"\n                push_host_devs \"$_dev\"\n                swap_devs+=(\"$_dev\")\n                break\n            done < /etc/fstab\n        done < /proc/swaps\n    fi\n\n    # collect all \"x-initrd.mount\" entries from /etc/fstab\n    if [[ -f /etc/fstab ]]; then\n        while read _d _m _t _o _r || [ -n \"$_d\" ]; do\n            [[ \"$_d\" == \\#* ]] && continue\n            [[ $_d ]] || continue\n            [[ \"$_o\" != *x-initrd.mount* ]] && continue\n            _dev=$(expand_persistent_dev \"$_d\")\n            _dev=\"$(readlink -f \"$_dev\")\"\n            [[ -b $_dev ]] || continue\n\n            push_host_devs \"$_dev\"\n            if [[ \"$_t\" == btrfs ]]; then\n                for i in $(find_btrfs_devs \"$_m\"); do\n                    push_host_devs \"$i\"\n                done\n            fi\n        done < /etc/fstab\n    fi\nfi\n\nunset m\nunset rest\n\n_get_fs_type() {\n    [[ $1 ]] || return\n    if [[ -b /dev/block/$1 ]]; then\n        ID_FS_TYPE=$(get_fs_env \"/dev/block/$1\") && host_fs_types[\"$(readlink -f \"/dev/block/$1\")\"]=\"$ID_FS_TYPE\"\n        return 1\n    fi\n    if [[ -b $1 ]]; then\n        ID_FS_TYPE=$(get_fs_env \"$1\") && host_fs_types[\"$(readlink -f \"$1\")\"]=\"$ID_FS_TYPE\"\n        return 1\n    fi\n    if fstype=$(find_dev_fstype \"$1\"); then\n        host_fs_types[\"$1\"]=\"$fstype\"\n        return 1\n    fi\n    return 1\n}\n\nfor dev in \"${host_devs[@]}\"; do\n    _get_fs_type \"$dev\"\n    check_block_and_slaves_all _get_fs_type \"$(get_maj_min \"$dev\")\"\ndone\n\nfor dev in \"${!host_fs_types[@]}\"; do\n    [[ ${host_fs_types[$dev]} = \"reiserfs\" ]] || [[ ${host_fs_types[$dev]} = \"xfs\" ]] || continue\n    rootopts=$(find_dev_fsopts \"$dev\")\n    if [[ ${host_fs_types[$dev]} = \"reiserfs\" ]]; then\n        journaldev=$(fs_get_option $rootopts \"jdev\")\n    elif [[ ${host_fs_types[$dev]} = \"xfs\" ]]; then\n        journaldev=$(fs_get_option $rootopts \"logdev\")\n    fi\n    if [[ $journaldev ]]; then\n        dev=\"$(readlink -f \"$dev\")\"\n        push_host_devs \"$dev\"\n        _get_fs_type \"$dev\"\n        check_block_and_slaves_all _get_fs_type \"$(get_maj_min \"$dev\")\"\n    fi\ndone\n\n[[ -d $udevdir ]] \\\n    || udevdir=\"$(pkg-config udev --variable=udevdir 2>/dev/null)\"\nif ! [[ -d \"$udevdir\" ]]; then\n    [[ ! -h /lib ]] && [[ -d /lib/udev ]] && udevdir=/lib/udev\n    [[ -d /usr/lib/udev ]] && udevdir=/usr/lib/udev\nfi\n\n[[ -d $systemdutildir ]] \\\n    || systemdutildir=$(pkg-config systemd --variable=systemdutildir 2>/dev/null)\n\nif ! [[ -d \"$systemdutildir\" ]]; then\n    [[ ! -h /lib ]] && [[ -d /lib/systemd ]] && systemdutildir=/lib/systemd\n    [[ -d /usr/lib/systemd ]] && systemdutildir=/usr/lib/systemd\nfi\n\n[[ -d $systemdsystemunitdir ]] \\\n    || systemdsystemunitdir=$(pkg-config systemd --variable=systemdsystemunitdir 2>/dev/null)\n\n[[ -d \"$systemdsystemunitdir\" ]] || systemdsystemunitdir=${systemdutildir}/system\n\n[[ -d $systemdsystemconfdir ]] \\\n    || systemdsystemconfdir=$(pkg-config systemd --variable=systemdsystemconfdir 2>/dev/null)\n\n[[ -d \"$systemdsystemconfdir\" ]] || systemdsystemconfdir=/etc/systemd/system\n\n[[ -d $tmpfilesdir ]] \\\n    || tmpfilesdir=$(pkg-config systemd --variable=tmpfilesdir 2>/dev/null)\n\nif ! [[ -d \"$tmpfilesdir\" ]]; then\n    [[ -d /lib/tmpfiles.d ]] && tmpfilesdir=/lib/tmpfiles.d\n    [[ -d /usr/lib/tmpfiles.d ]] && tmpfilesdir=/usr/lib/tmpfiles.d\nfi\n\nexport initdir dracutbasedir \\\n    dracutmodules force_add_dracutmodules add_dracutmodules omit_dracutmodules \\\n    mods_to_load \\\n    fw_dir drivers_dir debug no_kernel kernel_only \\\n    omit_drivers mdadmconf lvmconf root_dev \\\n    use_fstab fstab_lines libdirs fscks nofscks ro_mnt \\\n    stdloglvl sysloglvl fileloglvl kmsgloglvl logfile \\\n    debug host_fs_types host_devs swap_devs sshkey add_fstab \\\n    DRACUT_VERSION udevdir prefix filesystems drivers \\\n    systemdutildir systemdsystemunitdir systemdsystemconfdir \\\n    hostonly_cmdline loginstall \\\n    tmpfilesdir\n\nmods_to_load=\"\"\n# check all our modules to see if they should be sourced.\n# This builds a list of modules that we will install next.\nfor_each_module_dir check_module\nfor_each_module_dir check_mount\n\ndracut_module_included \"fips\" && export DRACUT_FIPS_MODE=1\n\ndo_print_cmdline()\n{\n    local -A _mods_to_print\n    for i in $modules_loaded $mods_to_load; do\n        _mods_to_print[$i]=1\n    done\n\n    # source our modules.\n    for moddir in \"$dracutbasedir/modules.d\"/[0-9][0-9]*; do\n        _d_mod=${moddir##*/}; _d_mod=${_d_mod#[0-9][0-9]}\n        [[ ${_mods_to_print[$_d_mod]} ]] || continue\n        module_cmdline \"$_d_mod\"\n    done\n    unset moddir\n}\n\nif [[ $print_cmdline ]]; then\n    do_print_cmdline\n    printf \"\\n\"\n    exit 0\nfi\n\n# Create some directory structure first\n[[ $prefix ]] && mkdir -m 0755 -p \"${initdir}${prefix}\"\n\n[[ -h /lib ]] || mkdir -m 0755 -p \"${initdir}${prefix}/lib\"\n[[ $prefix ]] && ln -sfn \"${prefix#/}/lib\" \"$initdir/lib\"\n\nif [[ $prefix ]]; then\n    for d in bin etc lib sbin tmp usr var $libdirs; do\n        [[ \"$d\" == */* ]] && continue\n        ln -sfn \"${prefix#/}/${d#/}\" \"$initdir/$d\"\n    done\nfi\n\nif [[ $kernel_only != yes ]]; then\n    for d in usr/bin usr/sbin bin etc lib sbin tmp usr var var/tmp $libdirs; do\n        [[ -e \"${initdir}${prefix}/$d\" ]] && continue\n        if [ -L \"/$d\" ]; then\n            inst_symlink \"/$d\" \"${prefix}/$d\"\n        else\n            mkdir -m 0755 -p \"${initdir}${prefix}/$d\"\n        fi\n    done\n\n    for d in dev proc sys sysroot root run; do\n        if [ -L \"/$d\" ]; then\n            inst_symlink \"/$d\"\n        else\n            mkdir -m 0755 -p \"$initdir/$d\"\n        fi\n    done\n\n    ln -sfn ../run \"$initdir/var/run\"\n    ln -sfn ../run/lock \"$initdir/var/lock\"\nelse\n    for d in lib \"$libdir\"; do\n        [[ -e \"${initdir}${prefix}/$d\" ]] && continue\n        if [ -h \"/$d\" ]; then\n            inst \"/$d\" \"${prefix}/$d\"\n        else\n            mkdir -m 0755 -p \"${initdir}${prefix}/$d\"\n        fi\n    done\nfi\n\nif [[ $kernel_only != yes ]]; then\n    mkdir -p \"${initdir}/etc/cmdline.d\"\n    for _d in $hookdirs; do\n        mkdir -m 0755 -p ${initdir}/lib/dracut/hooks/$_d\n    done\n    if [[ \"$UID\" = \"0\" ]]; then\n        [ -c ${initdir}/dev/null ] || mknod ${initdir}/dev/null c 1 3\n        [ -c ${initdir}/dev/kmsg ] || mknod ${initdir}/dev/kmsg c 1 11\n        [ -c ${initdir}/dev/console ] || mknod ${initdir}/dev/console c 5 1\n    fi\nfi\n\n_isize=0 #initramfs size\nmodules_loaded=\" \"\n# source our modules.\nfor moddir in \"$dracutbasedir/modules.d\"/[0-9][0-9]*; do\n    _d_mod=${moddir##*/}; _d_mod=${_d_mod#[0-9][0-9]}\n    [[ \"$mods_to_load\" == *\\ $_d_mod\\ * ]] || continue\n    if [[ $show_modules = yes ]]; then\n        printf \"%s\\n\" \"$_d_mod\"\n    else\n        dinfo \"*** Including module: $_d_mod ***\"\n    fi\n    if [[ $kernel_only == yes ]]; then\n        module_installkernel \"$_d_mod\" || {\n            dfatal \"installkernel failed in module $_d_mod\"\n            exit 1\n        }\n    else\n        module_install \"$_d_mod\"\n        if [[ $no_kernel != yes ]]; then\n            module_installkernel \"$_d_mod\" || {\n                dfatal \"installkernel failed in module $_d_mod\"\n                exit 1\n            }\n        fi\n    fi\n    mods_to_load=${mods_to_load// $_d_mod /}\n    modules_loaded+=\"$_d_mod \"\n\n    #print the module install size\n    if [ -n \"$printsize\" ]; then\n        _isize_new=$(du -sk ${initdir}|cut -f1)\n        _isize_delta=$((_isize_new - _isize))\n        printf \"%s\\n\" \"$_d_mod install size: ${_isize_delta}k\"\n        _isize=$_isize_new\n    fi\ndone\nunset moddir\n\nfor i in $modules_loaded; do\n    mkdir -p $initdir/lib/dracut\n    printf \"%s\\n\" \"$i\" >> $initdir/lib/dracut/modules.txt\ndone\n\ndinfo \"*** Including modules done ***\"\n\n## final stuff that has to happen\nif [[ $no_kernel != yes ]]; then\n\n    if [[ $drivers ]]; then\n        hostonly='' instmods $drivers\n    fi\n\n    if [[ $add_drivers ]]; then\n        hostonly='' instmods -c $add_drivers\n    fi\n    if [[ $force_drivers ]]; then\n        hostonly='' instmods -c $force_drivers\n        rm -f $initdir/etc/cmdline.d/20-force_driver.conf\n        for mod in $force_drivers; do\n            echo \"rd.driver.pre=$mod\" >>$initdir/etc/cmdline.d/20-force_drivers.conf\n        done\n    fi\n    if [[ $filesystems ]]; then\n        hostonly='' instmods -c $filesystems\n    fi\n\n    dinfo \"*** Installing kernel module dependencies ***\"\n    dracut_kernel_post\n    dinfo \"*** Installing kernel module dependencies done ***\"\n\n    if [[ $noimageifnotneeded == yes ]] && [[ $hostonly ]]; then\n        if [[ ! -f \"$initdir/lib/dracut/need-initqueue\" ]] && \\\n            [[ -f ${initdir}/lib/modules/$kernel/modules.dep && ! -s ${initdir}/lib/modules/$kernel/modules.dep ]]; then\n            for i in ${initdir}/etc/cmdline.d/*.conf; do\n                # We need no initramfs image and do not generate one.\n                [[ $i == \"${initdir}/etc/cmdline.d/*.conf\" ]] && exit 0\n            done\n        fi\n    fi\nfi\n\nif [[ $kernel_only != yes ]]; then\n    (( ${#install_items[@]} > 0 )) && inst_multiple ${install_items[@]}\n    (( ${#install_optional_items[@]} > 0 )) && inst_multiple -o ${install_optional_items[@]}\n\n    [[ $kernel_cmdline ]] && printf \"%s\\n\" \"$kernel_cmdline\" >> \"${initdir}/etc/cmdline.d/01-default.conf\"\n\n    for line in \"${fstab_lines[@]}\"; do\n        line=($line)\n\n        if [ -z \"${line[1]}\" ]; then\n            # Determine device and mount options from current system\n            mountpoint -q \"${line[0]}\" || derror \"${line[0]} is not a mount point!\"\n            line=($(findmnt --raw -n --target \"${line[0]}\" --output=source,target,fstype,options))\n            dinfo \"Line for ${line[1]}: ${line[@]}\"\n        else\n            # Use default options\n            [ -z \"${line[3]}\" ] && line[3]=\"defaults\"\n        fi\n\n        # Default options for freq and passno\n        [ -z \"${line[4]}\" ] && line[4]=\"0\"\n        [ -z \"${line[5]}\" ] && line[5]=\"2\"\n\n        strstr \"${line[2]}\" \"nfs\" && line[5]=\"0\"\n        echo \"${line[@]}\" >> \"${initdir}/etc/fstab\"\n    done\n\n    for f in $add_fstab; do\n        cat \"$f\" >> \"${initdir}/etc/fstab\"\n    done\n\n    if [[ $systemdutildir ]]; then\n        if [ -d ${initdir}/$systemdutildir ]; then\n            mkdir -p ${initdir}/etc/conf.d\n            {\n                printf \"%s\\n\" \"systemdutildir=\\\"$systemdutildir\\\"\"\n                printf \"%s\\n\" \"systemdsystemunitdir=\\\"$systemdsystemunitdir\\\"\"\n                printf \"%s\\n\" \"systemdsystemconfdir=\\\"$systemdsystemconfdir\\\"\"\n            } > ${initdir}/etc/conf.d/systemd.conf\n        fi\n    fi\n\n    if [[ $DRACUT_RESOLVE_LAZY ]] && [[ $DRACUT_INSTALL ]]; then\n        dinfo \"*** Resolving executable dependencies ***\"\n        find \"$initdir\" -type f -perm /0111 -not -path '*.ko' -print0 \\\n        | xargs -r -0 $DRACUT_INSTALL ${initdir:+-D \"$initdir\"} -R ${DRACUT_FIPS_MODE:+-f} --\n        dinfo \"*** Resolving executable dependencies done***\"\n    fi\n\n    # libpthread workaround: pthread_cancel wants to dlopen libgcc_s.so\n    for _dir in $libdirs; do\n        for _f in \"$_dir/libpthread.so\"*; do\n            [[ -e \"$_f\" ]] || continue\n            inst_libdir_file \"libgcc_s.so*\"\n            break 2\n        done\n    done\nfi\n\nfor ((i=0; i < ${#include_src[@]}; i++)); do\n    src=\"${include_src[$i]}\"\n    target=\"${include_target[$i]}\"\n    if [[ $src && $target ]]; then\n        if [[ -f $src ]]; then\n            inst $src $target\n        else\n            ddebug \"Including directory: $src\"\n            destdir=\"${initdir}/${target}\"\n            mkdir -p \"$destdir\"\n            # check for preexisting symlinks, so we can cope with the\n            # symlinks to $prefix\n            # Objectname is a file or a directory\n            for objectname in \"$src\"/*; do\n                [[ -e \"$objectname\" || -h \"$objectname\" ]] || continue\n                if [[ -d \"$objectname\" ]]; then\n                    # objectname is a directory, let's compute the final directory name\n                    object_destdir=${destdir}/${objectname#$src/}\n                    if ! [[ -e \"$object_destdir\" ]]; then\n                        mkdir -m 0755 -p \"$object_destdir\"\n                        chmod --reference=\"$objectname\" \"$object_destdir\"\n                    fi\n                    cp --reflink=auto --sparse=auto -fa -t \"$object_destdir\" \"$objectname\"/*\n                else\n                    cp --reflink=auto --sparse=auto -fa -t \"$destdir\" \"$objectname\"\n                fi\n            done\n        fi\n    fi\ndone\n\nif [[ $kernel_only != yes ]]; then\n    # make sure that library links are correct and up to date\n    for f in /etc/ld.so.conf /etc/ld.so.conf.d/*; do\n        [[ -f $f ]] && inst_simple \"$f\"\n    done\n    if ! ldconfig -r \"$initdir\"; then\n        if [[ $UID = 0 ]]; then\n            derror \"ldconfig exited ungracefully\"\n        else\n            derror \"ldconfig might need uid=0 (root) for chroot()\"\n        fi\n    fi\nfi\n\nPRELINK_BIN=\"$(command -v prelink)\"\nif [[ $UID = 0 ]] && [[ $PRELINK_BIN ]]; then\n    if [[ $DRACUT_FIPS_MODE ]]; then\n        dinfo \"*** Installing prelink files ***\"\n        inst_multiple -o prelink /etc/prelink.conf /etc/prelink.conf.d/*.conf /etc/prelink.cache\n    elif [[ $do_prelink == yes ]]; then\n        dinfo \"*** Pre-linking files ***\"\n        inst_multiple -o prelink /etc/prelink.conf /etc/prelink.conf.d/*.conf\n        chroot \"$initdir\" \"$PRELINK_BIN\" -a\n        rm -f -- \"$initdir/$PRELINK_BIN\"\n        rm -fr -- \"$initdir\"/etc/prelink.*\n        dinfo \"*** Pre-linking files done ***\"\n    fi\nfi\n\nif [[ $do_hardlink = yes ]] && command -v hardlink >/dev/null; then\n    dinfo \"*** Hardlinking files ***\"\n    hardlink \"$initdir\" 2>&1\n    dinfo \"*** Hardlinking files done ***\"\nfi\n\n# strip binaries\nif [[ $do_strip = yes ]] ; then\n    for p in strip xargs find; do\n        if ! type -P $p >/dev/null; then\n            dinfo \"Could not find '$p'. Not stripping the initramfs.\"\n            do_strip=no\n        fi\n    done\nfi\n\nif [[ $do_strip = yes ]] && ! [[ $DRACUT_FIPS_MODE ]]; then\n    dinfo \"*** Stripping files ***\"\n    find \"$initdir\" -type f \\\n        -executable -not -path '*/lib/modules/*.ko' -print0 \\\n        | xargs -r -0 strip -g 2>/dev/null\n\n    # strip kernel modules, but do not touch signed modules\n    find \"$initdir\" -type f -path '*/lib/modules/*.ko' -print0 \\\n        | while read -r -d $'\\0' f || [ -n \"$f\" ]; do\n        SIG=$(tail -c 28 \"$f\")\n        [[ $SIG == '~Module signature appended~' ]] || { printf \"%s\\000\" \"$f\"; }\n    done | xargs -r -0 strip -g\n\n    dinfo \"*** Stripping files done ***\"\nfi\nif [[ $early_microcode = yes ]]; then\n    dinfo \"*** Generating early-microcode cpio image ***\"\n    ucode_dir=(amd-ucode intel-ucode)\n    ucode_dest=(AuthenticAMD.bin GenuineIntel.bin)\n    _dest_dir=\"$early_cpio_dir/d/kernel/x86/microcode\"\n    _dest_idx=\"0 1\"\n    mkdir -p $_dest_dir\n    if [[ $hostonly ]]; then\n        [[ $(get_cpu_vendor) == \"AMD\" ]] && _dest_idx=\"0\"\n        [[ $(get_cpu_vendor) == \"Intel\" ]] && _dest_idx=\"1\"\n    fi\n    for idx in $_dest_idx; do\n        _fw=${ucode_dir[$idx]}\n        for _fwdir in $fw_dir; do\n            if [[ -d $_fwdir && -d $_fwdir/$_fw ]]; then\n                _src=\"*\"\n                dinfo \"*** Constructing ${ucode_dest[$idx]} ****\"\n                if [[ $hostonly ]]; then\n                    _src=$(get_ucode_file)\n                    [[ $_src ]] || break\n                    [[ -r $_fwdir/$_fw/$_src ]] || break\n                fi\n\n                for i in $_fwdir/$_fw/$_src; do\n                    [ -e \"$i\" ] && break\n                    break 2\n                done\n                for i in $_fwdir/$_fw/$_src; do\n                    [[ -e \"$i\" ]] || continue\n                    # skip gpg files\n                    str_ends \"$i\" \".asc\" && continue\n                    cat \"$i\" >> $_dest_dir/${ucode_dest[$idx]}\n                done\n                create_early_cpio=\"yes\"\n            fi\n        done\n    done\nfi\n\nif [[ $acpi_override = yes ]] && [[ -d $acpi_table_dir ]]; then\n    dinfo \"*** Packaging ACPI tables to override BIOS provided ones ***\"\n    _dest_dir=\"$early_cpio_dir/d/kernel/firmware/acpi\"\n    mkdir -p $_dest_dir\n    for table in $acpi_table_dir/*.aml; do\n        dinfo \"   Adding ACPI table: $table\"\n        cp -a $table $_dest_dir\n        create_early_cpio=\"yes\"\n    done\nfi\n\ndinfo \"*** Store current command line parameters ***\"\nif ! ( echo $PARMS_TO_STORE > $initdir/lib/dracut/build-parameter.txt ); then\n    dfatal \"Could not store the current command line parameters\"\n    exit 1\nfi\n\nif [[ $hostonly_cmdline ]] ; then\n    unset _stored_cmdline\n    if [ -d $initdir/etc/cmdline.d ];then\n        dinfo \"Stored kernel commandline:\"\n        for conf in $initdir/etc/cmdline.d/*.conf ; do\n            [ -e \"$conf\" ] || continue\n            dinfo \"$(< $conf)\"\n            _stored_cmdline=1\n        done\n    fi\n    if ! [[ $_stored_cmdline ]]; then\n        dinfo \"No dracut internal kernel commandline stored in the initramfs\"\n    fi\nfi\n\ndinfo \"*** Creating image file '$outfile' ***\"\n\nif [[ $uefi = yes ]]; then\n    readonly uefi_outdir=\"$DRACUT_TMPDIR/uefi\"\n    mkdir \"$uefi_outdir\"\nfi\n\nif [[ $DRACUT_REPRODUCIBLE ]]; then\n    find \"$initdir\" -newer \"$dracutbasedir/dracut-functions.sh\" -print0 \\\n        | xargs -r -0 touch -h -m -c -r \"$dracutbasedir/dracut-functions.sh\"\n\n    if [[ \"$(cpio --help)\" == *--reproducible* ]]; then\n        CPIO_REPRODUCIBLE=1\n    else\n        dinfo \"cpio does not support '--reproducible'. Resulting image will not be reproducible.\"\n    fi\nfi\n\n[[ \"$UID\" != 0 ]] && cpio_owner_root=\"-R 0:0\"\n\nif [[ $create_early_cpio = yes ]]; then\n    echo 1 > \"$early_cpio_dir/d/early_cpio\"\n\n    if [[ $DRACUT_REPRODUCIBLE ]]; then\n        find \"$early_cpio_dir/d\" -newer \"$dracutbasedir/dracut-functions.sh\" -print0 \\\n            | xargs -r -0 touch -h -m -c -r \"$dracutbasedir/dracut-functions.sh\"\n    fi\n\n    # The microcode blob is _before_ the initramfs blob, not after\n    if ! (\n            umask 077; cd \"$early_cpio_dir/d\"\n            find . -print0 | sort -z \\\n                | cpio ${CPIO_REPRODUCIBLE:+--reproducible} --null $cpio_owner_root -H newc -o --quiet > \"${DRACUT_TMPDIR}/initramfs.img\"\n        ); then\n        dfatal \"dracut: creation of $outfile failed\"\n        exit 1\n    fi\nfi\n\nif ! (\n        umask 077; cd \"$initdir\"\n        find . -print0 | sort -z \\\n            | cpio ${CPIO_REPRODUCIBLE:+--reproducible} --null $cpio_owner_root -H newc -o --quiet \\\n            | $compress >> \"${DRACUT_TMPDIR}/initramfs.img\"\n    ); then\n    dfatal \"dracut: creation of $outfile failed\"\n    exit 1\nfi\n\nif (( maxloglvl >= 5 )); then\n    if [[ $allowlocal ]]; then\n\t\"$dracutbasedir/lsinitrd.sh\" \"${DRACUT_TMPDIR}/initramfs.img\"| ddebug\n    else\n        lsinitrd \"${DRACUT_TMPDIR}/initramfs.img\"| ddebug\n    fi\nfi\n\numask 077\n\nif [[ $uefi = yes ]]; then\n    if [[ $kernel_cmdline ]]; then\n        echo -n \"$kernel_cmdline\" > \"$uefi_outdir/cmdline.txt\"\n    elif [[ $hostonly_cmdline = yes ]] && [ -d $initdir/etc/cmdline.d ];then\n        for conf in $initdir/etc/cmdline.d/*.conf ; do\n            [ -e \"$conf\" ] || continue\n            printf \"%s \" \"$(< $conf)\" >> \"$uefi_outdir/cmdline.txt\"\n        done\n    else\n        do_print_cmdline > \"$uefi_outdir/cmdline.txt\"\n    fi\n    echo -ne \"\\x00\" >> \"$uefi_outdir/cmdline.txt\"\n\n    dinfo \"Using UEFI kernel cmdline:\"\n    dinfo $(< \"$uefi_outdir/cmdline.txt\")\n\n    [[ -s /usr/lib/os-release ]] && uefi_osrelease=\"/usr/lib/os-release\"\n    [[ -s /etc/os-release ]] && uefi_osrelease=\"/etc/os-release\"\n\n    if objcopy \\\n           ${uefi_osrelease:+--add-section .osrel=$uefi_osrelease --change-section-vma .osrel=0x20000} \\\n           --add-section .cmdline=\"${uefi_outdir}/cmdline.txt\" --change-section-vma .cmdline=0x30000 \\\n           --add-section .linux=\"$kernel_image\" --change-section-vma .linux=0x40000 \\\n           --add-section .initrd=\"${DRACUT_TMPDIR}/initramfs.img\" --change-section-vma .initrd=0x3000000 \\\n           \"$uefi_stub\" \"${uefi_outdir}/linux.efi\" \\\n            && cp --reflink=auto \"${uefi_outdir}/linux.efi\" \"$outfile\"; then\n        dinfo \"*** Creating UEFI image file '$outfile' done ***\"\n    else\n        rm -f -- \"$outfile\"\n        dfatal \"*** Creating UEFI image file '$outfile' failed ***\"\n        exit 1\n    fi\nelse\n    if cp --reflink=auto \"${DRACUT_TMPDIR}/initramfs.img\" \"$outfile\"; then\n        dinfo \"*** Creating initramfs image file '$outfile' done ***\"\n    else\n        rm -f -- \"$outfile\"\n        dfatal \"dracut: creation of $outfile failed\"\n        exit 1\n    fi\nfi\n\ncommand -v restorecon &>/dev/null && restorecon -- \"$outfile\"\n\nexit 0\n"], "filenames": ["dracut.sh"], "buggy_code_start_loc": [1703], "buggy_code_end_loc": [1704], "fixing_code_start_loc": [1703], "fixing_code_end_loc": [1704], "type": "CWE-732", "message": "A local information disclosure issue was found in dracut before 045 when generating initramfs images with world-readable permissions when 'early cpio' is used, such as when including microcode updates. Local attacker can use this to obtain sensitive information from these files, such as encryption keys or credentials.", "other": {"cve": {"id": "CVE-2016-8637", "sourceIdentifier": "secalert@redhat.com", "published": "2018-08-01T13:29:00.263", "lastModified": "2023-02-12T23:26:16.407", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A local information disclosure issue was found in dracut before 045 when generating initramfs images with world-readable permissions when 'early cpio' is used, such as when including microcode updates. Local attacker can use this to obtain sensitive information from these files, such as encryption keys or credentials."}, {"lang": "es", "value": "Se ha encontrado un problema de divulgaci\u00f3n de informaci\u00f3n local en dracut en versiones anteriores a la 045 al generar im\u00e1genes initramfs con permisos de lectura globales al emplear \"early cpio\", como al incluir actualizaciones de microc\u00f3digo. Un atacante local puede emplear esto para obtener informaci\u00f3n sensible de estos archivos, como las claves de cifrado o las credenciales."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:R/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.3, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-732"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dracut_project:dracut:*:*:*:*:*:*:*:*", "versionEndExcluding": "045", "matchCriteriaId": "2DBF390D-A4A6-4371-A534-BDD710AAB9A1"}]}]}], "references": [{"url": "http://seclists.org/oss-sec/2016/q4/352", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/94128", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2016-8637", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/dracutdevs/dracut/commit/0db98910a11c12a454eac4c8e86dc7a7bbc764a4", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dracutdevs/dracut/commit/0db98910a11c12a454eac4c8e86dc7a7bbc764a4"}}