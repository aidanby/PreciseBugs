{"buggy_code": ["<?php\n\nnamespace Illuminate\\View\\Compilers;\n\nuse Illuminate\\Filesystem\\Filesystem;\nuse InvalidArgumentException;\n\nabstract class Compiler\n{\n    /**\n     * The Filesystem instance.\n     *\n     * @var \\Illuminate\\Filesystem\\Filesystem\n     */\n    protected $files;\n\n    /**\n     * Get the cache path for the compiled views.\n     *\n     * @var string\n     */\n    protected $cachePath;\n\n    /**\n     * Create a new compiler instance.\n     *\n     * @param  \\Illuminate\\Filesystem\\Filesystem  $files\n     * @param  string  $cachePath\n     * @return void\n     *\n     * @throws \\InvalidArgumentException\n     */\n    public function __construct(Filesystem $files, $cachePath)\n    {\n        if (! $cachePath) {\n            throw new InvalidArgumentException('Please provide a valid cache path.');\n        }\n\n        $this->files = $files;\n        $this->cachePath = $cachePath;\n    }\n\n    /**\n     * Get the path to the compiled version of a view.\n     *\n     * @param  string  $path\n     * @return string\n     */\n    public function getCompiledPath($path)\n    {\n        return $this->cachePath.'/'.sha1($path).'.php';\n    }\n\n    /**\n     * Determine if the view at the given path is expired.\n     *\n     * @param  string  $path\n     * @return bool\n     */\n    public function isExpired($path)\n    {\n        $compiled = $this->getCompiledPath($path);\n\n        // If the compiled file doesn't exist we will indicate that the view is expired\n        // so that it can be re-compiled. Else, we will verify the last modification\n        // of the views is less than the modification times of the compiled views.\n        if (! $this->files->exists($compiled)) {\n            return true;\n        }\n\n        return $this->files->lastModified($path) >=\n               $this->files->lastModified($compiled);\n    }\n}\n", "<?php\n\nnamespace Illuminate\\View\\Compilers\\Concerns;\n\nuse Illuminate\\View\\Factory as ViewFactory;\n\ntrait CompilesLayouts\n{\n    /**\n     * The name of the last section that was started.\n     *\n     * @var string\n     */\n    protected $lastSection;\n\n    /**\n     * Compile the extends statements into valid PHP.\n     *\n     * @param  string  $expression\n     * @return string\n     */\n    protected function compileExtends($expression)\n    {\n        $expression = $this->stripParentheses($expression);\n\n        $echo = \"<?php echo \\$__env->make({$expression}, \\Illuminate\\Support\\Arr::except(get_defined_vars(), ['__data', '__path']))->render(); ?>\";\n\n        $this->footer[] = $echo;\n\n        return '';\n    }\n\n    /**\n     * Compile the section statements into valid PHP.\n     *\n     * @param  string  $expression\n     * @return string\n     */\n    protected function compileSection($expression)\n    {\n        $this->lastSection = trim($expression, \"()'\\\" \");\n\n        return \"<?php \\$__env->startSection{$expression}; ?>\";\n    }\n\n    /**\n     * Replace the @parent directive to a placeholder.\n     *\n     * @return string\n     */\n    protected function compileParent()\n    {\n        return ViewFactory::parentPlaceholder($this->lastSection ?: '');\n    }\n\n    /**\n     * Compile the yield statements into valid PHP.\n     *\n     * @param  string  $expression\n     * @return string\n     */\n    protected function compileYield($expression)\n    {\n        return \"<?php echo \\$__env->yieldContent{$expression}; ?>\";\n    }\n\n    /**\n     * Compile the show statements into valid PHP.\n     *\n     * @return string\n     */\n    protected function compileShow()\n    {\n        return '<?php echo $__env->yieldSection(); ?>';\n    }\n\n    /**\n     * Compile the append statements into valid PHP.\n     *\n     * @return string\n     */\n    protected function compileAppend()\n    {\n        return '<?php $__env->appendSection(); ?>';\n    }\n\n    /**\n     * Compile the overwrite statements into valid PHP.\n     *\n     * @return string\n     */\n    protected function compileOverwrite()\n    {\n        return '<?php $__env->stopSection(true); ?>';\n    }\n\n    /**\n     * Compile the stop statements into valid PHP.\n     *\n     * @return string\n     */\n    protected function compileStop()\n    {\n        return '<?php $__env->stopSection(); ?>';\n    }\n\n    /**\n     * Compile the end-section statements into valid PHP.\n     *\n     * @return string\n     */\n    protected function compileEndsection()\n    {\n        return '<?php $__env->stopSection(); ?>';\n    }\n}\n", "<?php\n\nnamespace Illuminate\\View\\Concerns;\n\nuse Illuminate\\Contracts\\View\\View;\nuse InvalidArgumentException;\n\ntrait ManagesLayouts\n{\n    /**\n     * All of the finished, captured sections.\n     *\n     * @var array\n     */\n    protected $sections = [];\n\n    /**\n     * The stack of in-progress sections.\n     *\n     * @var array\n     */\n    protected $sectionStack = [];\n\n    /**\n     * The parent placeholder for the request.\n     *\n     * @var mixed\n     */\n    protected static $parentPlaceholder = [];\n\n    /**\n     * Start injecting content into a section.\n     *\n     * @param  string  $section\n     * @param  string|null  $content\n     * @return void\n     */\n    public function startSection($section, $content = null)\n    {\n        if ($content === null) {\n            if (ob_start()) {\n                $this->sectionStack[] = $section;\n            }\n        } else {\n            $this->extendSection($section, $content instanceof View ? $content : e($content));\n        }\n    }\n\n    /**\n     * Inject inline content into a section.\n     *\n     * @param  string  $section\n     * @param  string  $content\n     * @return void\n     */\n    public function inject($section, $content)\n    {\n        $this->startSection($section, $content);\n    }\n\n    /**\n     * Stop injecting content into a section and return its contents.\n     *\n     * @return string\n     */\n    public function yieldSection()\n    {\n        if (empty($this->sectionStack)) {\n            return '';\n        }\n\n        return $this->yieldContent($this->stopSection());\n    }\n\n    /**\n     * Stop injecting content into a section.\n     *\n     * @param  bool  $overwrite\n     * @return string\n     *\n     * @throws \\InvalidArgumentException\n     */\n    public function stopSection($overwrite = false)\n    {\n        if (empty($this->sectionStack)) {\n            throw new InvalidArgumentException('Cannot end a section without first starting one.');\n        }\n\n        $last = array_pop($this->sectionStack);\n\n        if ($overwrite) {\n            $this->sections[$last] = ob_get_clean();\n        } else {\n            $this->extendSection($last, ob_get_clean());\n        }\n\n        return $last;\n    }\n\n    /**\n     * Stop injecting content into a section and append it.\n     *\n     * @return string\n     *\n     * @throws \\InvalidArgumentException\n     */\n    public function appendSection()\n    {\n        if (empty($this->sectionStack)) {\n            throw new InvalidArgumentException('Cannot end a section without first starting one.');\n        }\n\n        $last = array_pop($this->sectionStack);\n\n        if (isset($this->sections[$last])) {\n            $this->sections[$last] .= ob_get_clean();\n        } else {\n            $this->sections[$last] = ob_get_clean();\n        }\n\n        return $last;\n    }\n\n    /**\n     * Append content to a given section.\n     *\n     * @param  string  $section\n     * @param  string  $content\n     * @return void\n     */\n    protected function extendSection($section, $content)\n    {\n        if (isset($this->sections[$section])) {\n            $content = str_replace(static::parentPlaceholder($section), $content, $this->sections[$section]);\n        }\n\n        $this->sections[$section] = $content;\n    }\n\n    /**\n     * Get the string contents of a section.\n     *\n     * @param  string  $section\n     * @param  string  $default\n     * @return string\n     */\n    public function yieldContent($section, $default = '')\n    {\n        $sectionContent = $default instanceof View ? $default : e($default);\n\n        if (isset($this->sections[$section])) {\n            $sectionContent = $this->sections[$section];\n        }\n\n        $sectionContent = str_replace('@@parent', '--parent--holder--', $sectionContent);\n\n        return str_replace(\n            '--parent--holder--', '@parent', str_replace(static::parentPlaceholder($section), '', $sectionContent)\n        );\n    }\n\n    /**\n     * Get the parent placeholder for the current request.\n     *\n     * @param  string  $section\n     * @return string\n     */\n    public static function parentPlaceholder($section = '')\n    {\n        if (! isset(static::$parentPlaceholder[$section])) {\n            static::$parentPlaceholder[$section] = '##parent-placeholder-'.sha1($section).'##';\n        }\n\n        return static::$parentPlaceholder[$section];\n    }\n\n    /**\n     * Check if section exists.\n     *\n     * @param  string  $name\n     * @return bool\n     */\n    public function hasSection($name)\n    {\n        return array_key_exists($name, $this->sections);\n    }\n\n    /**\n     * Get the contents of a section.\n     *\n     * @param  string  $name\n     * @param  string|null  $default\n     * @return mixed\n     */\n    public function getSection($name, $default = null)\n    {\n        return $this->getSections()[$name] ?? $default;\n    }\n\n    /**\n     * Get the entire array of sections.\n     *\n     * @return array\n     */\n    public function getSections()\n    {\n        return $this->sections;\n    }\n\n    /**\n     * Flush all of the sections.\n     *\n     * @return void\n     */\n    public function flushSections()\n    {\n        $this->sections = [];\n        $this->sectionStack = [];\n    }\n}\n", "<?php\n\nnamespace Illuminate\\Tests\\View;\n\nuse Illuminate\\Filesystem\\Filesystem;\nuse Illuminate\\View\\Compilers\\BladeCompiler;\nuse InvalidArgumentException;\nuse Mockery as m;\nuse PHPUnit\\Framework\\TestCase;\n\nclass ViewBladeCompilerTest extends TestCase\n{\n    protected function tearDown(): void\n    {\n        m::close();\n    }\n\n    public function testIsExpiredReturnsTrueIfCompiledFileDoesntExist()\n    {\n        $compiler = new BladeCompiler($files = $this->getFiles(), __DIR__);\n        $files->shouldReceive('exists')->once()->with(__DIR__.'/'.sha1('foo').'.php')->andReturn(false);\n        $this->assertTrue($compiler->isExpired('foo'));\n    }\n\n    public function testCannotConstructWithBadCachePath()\n    {\n        $this->expectException(InvalidArgumentException::class);\n        $this->expectExceptionMessage('Please provide a valid cache path.');\n\n        new BladeCompiler($this->getFiles(), null);\n    }\n\n    public function testIsExpiredReturnsTrueWhenModificationTimesWarrant()\n    {\n        $compiler = new BladeCompiler($files = $this->getFiles(), __DIR__);\n        $files->shouldReceive('exists')->once()->with(__DIR__.'/'.sha1('foo').'.php')->andReturn(true);\n        $files->shouldReceive('lastModified')->once()->with('foo')->andReturn(100);\n        $files->shouldReceive('lastModified')->once()->with(__DIR__.'/'.sha1('foo').'.php')->andReturn(0);\n        $this->assertTrue($compiler->isExpired('foo'));\n    }\n\n    public function testCompilePathIsProperlyCreated()\n    {\n        $compiler = new BladeCompiler($this->getFiles(), __DIR__);\n        $this->assertEquals(__DIR__.'/'.sha1('foo').'.php', $compiler->getCompiledPath('foo'));\n    }\n\n    public function testCompileCompilesFileAndReturnsContents()\n    {\n        $compiler = new BladeCompiler($files = $this->getFiles(), __DIR__);\n        $files->shouldReceive('get')->once()->with('foo')->andReturn('Hello World');\n        $files->shouldReceive('put')->once()->with(__DIR__.'/'.sha1('foo').'.php', 'Hello World<?php /**PATH foo ENDPATH**/ ?>');\n        $compiler->compile('foo');\n    }\n\n    public function testCompileCompilesAndGetThePath()\n    {\n        $compiler = new BladeCompiler($files = $this->getFiles(), __DIR__);\n        $files->shouldReceive('get')->once()->with('foo')->andReturn('Hello World');\n        $files->shouldReceive('put')->once()->with(__DIR__.'/'.sha1('foo').'.php', 'Hello World<?php /**PATH foo ENDPATH**/ ?>');\n        $compiler->compile('foo');\n        $this->assertSame('foo', $compiler->getPath());\n    }\n\n    public function testCompileSetAndGetThePath()\n    {\n        $compiler = new BladeCompiler($files = $this->getFiles(), __DIR__);\n        $compiler->setPath('foo');\n        $this->assertSame('foo', $compiler->getPath());\n    }\n\n    public function testCompileWithPathSetBefore()\n    {\n        $compiler = new BladeCompiler($files = $this->getFiles(), __DIR__);\n        $files->shouldReceive('get')->once()->with('foo')->andReturn('Hello World');\n        $files->shouldReceive('put')->once()->with(__DIR__.'/'.sha1('foo').'.php', 'Hello World<?php /**PATH foo ENDPATH**/ ?>');\n        // set path before compilation\n        $compiler->setPath('foo');\n        // trigger compilation with $path\n        $compiler->compile();\n        $this->assertSame('foo', $compiler->getPath());\n    }\n\n    public function testRawTagsCanBeSetToLegacyValues()\n    {\n        $compiler = new BladeCompiler($this->getFiles(), __DIR__);\n        $compiler->setEchoFormat('%s');\n\n        $this->assertSame('<?php echo e($name); ?>', $compiler->compileString('{{{ $name }}}'));\n        $this->assertSame('<?php echo $name; ?>', $compiler->compileString('{{ $name }}'));\n        $this->assertSame('<?php echo $name; ?>', $compiler->compileString('{{\n            $name\n        }}'));\n    }\n\n    /**\n     * @dataProvider appendViewPathDataProvider\n     *\n     * @param  string  $content\n     * @param  string  $compiled\n     */\n    public function testIncludePathToTemplate($content, $compiled)\n    {\n        $compiler = new BladeCompiler($files = $this->getFiles(), __DIR__);\n        $files->shouldReceive('get')->once()->with('foo')->andReturn($content);\n        $files->shouldReceive('put')->once()->with(__DIR__.'/'.sha1('foo').'.php', $compiled);\n\n        $compiler->compile('foo');\n    }\n\n    /**\n     * @return array\n     */\n    public function appendViewPathDataProvider()\n    {\n        return [\n            'No PHP blocks' => [\n                'Hello World',\n                'Hello World<?php /**PATH foo ENDPATH**/ ?>',\n            ],\n            'Single PHP block without closing ?>' => [\n                '<?php echo $path',\n                '<?php echo $path ?><?php /**PATH foo ENDPATH**/ ?>',\n            ],\n            'Ending PHP block.' => [\n                'Hello world<?php echo $path ?>',\n                'Hello world<?php echo $path ?><?php /**PATH foo ENDPATH**/ ?>',\n            ],\n            'Ending PHP block without closing ?>' => [\n                'Hello world<?php echo $path',\n                'Hello world<?php echo $path ?><?php /**PATH foo ENDPATH**/ ?>',\n            ],\n            'PHP block between content.' => [\n                'Hello world<?php echo $path ?>Hi There',\n                'Hello world<?php echo $path ?>Hi There<?php /**PATH foo ENDPATH**/ ?>',\n            ],\n            'Multiple PHP blocks.' => [\n                'Hello world<?php echo $path ?>Hi There<?php echo $path ?>Hello Again',\n                'Hello world<?php echo $path ?>Hi There<?php echo $path ?>Hello Again<?php /**PATH foo ENDPATH**/ ?>',\n            ],\n            'Multiple PHP blocks without closing ?>' => [\n                'Hello world<?php echo $path ?>Hi There<?php echo $path',\n                'Hello world<?php echo $path ?>Hi There<?php echo $path ?><?php /**PATH foo ENDPATH**/ ?>',\n            ],\n            'Short open echo tag' => [\n                'Hello world<?= echo $path',\n                'Hello world<?= echo $path ?><?php /**PATH foo ENDPATH**/ ?>',\n            ],\n            'Echo XML declaration' => [\n                '<?php echo \\'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\';',\n                '<?php echo \\'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\'; ?><?php /**PATH foo ENDPATH**/ ?>',\n            ],\n        ];\n    }\n\n    public function testDontIncludeEmptyPath()\n    {\n        $compiler = new BladeCompiler($files = $this->getFiles(), __DIR__);\n        $files->shouldReceive('get')->once()->with('')->andReturn('Hello World');\n        $files->shouldReceive('put')->once()->with(__DIR__.'/'.sha1('').'.php', 'Hello World');\n        $compiler->setPath('');\n        $compiler->compile();\n    }\n\n    public function testDontIncludeNullPath()\n    {\n        $compiler = new BladeCompiler($files = $this->getFiles(), __DIR__);\n        $files->shouldReceive('get')->once()->with(null)->andReturn('Hello World');\n        $files->shouldReceive('put')->once()->with(__DIR__.'/'.sha1(null).'.php', 'Hello World');\n        $compiler->setPath(null);\n        $compiler->compile();\n    }\n\n    public function testShouldStartFromStrictTypesDeclaration()\n    {\n        $compiler = new BladeCompiler($files = $this->getFiles(), __DIR__);\n        $strictTypeDecl = \"<?php\\ndeclare(strict_types = 1);\";\n        $this->assertTrue(substr($compiler->compileString(\"<?php\\ndeclare(strict_types = 1);\\nHello World\"),\n            0, strlen($strictTypeDecl)) === $strictTypeDecl);\n    }\n\n    protected function getFiles()\n    {\n        return m::mock(Filesystem::class);\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace Illuminate\\View\\Compilers;\n\nuse Illuminate\\Filesystem\\Filesystem;\nuse InvalidArgumentException;\n\nabstract class Compiler\n{\n    /**\n     * The Filesystem instance.\n     *\n     * @var \\Illuminate\\Filesystem\\Filesystem\n     */\n    protected $files;\n\n    /**\n     * Get the cache path for the compiled views.\n     *\n     * @var string\n     */\n    protected $cachePath;\n\n    /**\n     * Create a new compiler instance.\n     *\n     * @param  \\Illuminate\\Filesystem\\Filesystem  $files\n     * @param  string  $cachePath\n     * @return void\n     *\n     * @throws \\InvalidArgumentException\n     */\n    public function __construct(Filesystem $files, $cachePath)\n    {\n        if (! $cachePath) {\n            throw new InvalidArgumentException('Please provide a valid cache path.');\n        }\n\n        $this->files = $files;\n        $this->cachePath = $cachePath;\n    }\n\n    /**\n     * Get the path to the compiled version of a view.\n     *\n     * @param  string  $path\n     * @return string\n     */\n    public function getCompiledPath($path)\n    {\n        return $this->cachePath.'/'.sha1('v2'.$path).'.php';\n    }\n\n    /**\n     * Determine if the view at the given path is expired.\n     *\n     * @param  string  $path\n     * @return bool\n     */\n    public function isExpired($path)\n    {\n        $compiled = $this->getCompiledPath($path);\n\n        // If the compiled file doesn't exist we will indicate that the view is expired\n        // so that it can be re-compiled. Else, we will verify the last modification\n        // of the views is less than the modification times of the compiled views.\n        if (! $this->files->exists($compiled)) {\n            return true;\n        }\n\n        return $this->files->lastModified($path) >=\n               $this->files->lastModified($compiled);\n    }\n}\n", "<?php\n\nnamespace Illuminate\\View\\Compilers\\Concerns;\n\ntrait CompilesLayouts\n{\n    /**\n     * The name of the last section that was started.\n     *\n     * @var string\n     */\n    protected $lastSection;\n\n    /**\n     * Compile the extends statements into valid PHP.\n     *\n     * @param  string  $expression\n     * @return string\n     */\n    protected function compileExtends($expression)\n    {\n        $expression = $this->stripParentheses($expression);\n\n        $echo = \"<?php echo \\$__env->make({$expression}, \\Illuminate\\Support\\Arr::except(get_defined_vars(), ['__data', '__path']))->render(); ?>\";\n\n        $this->footer[] = $echo;\n\n        return '';\n    }\n\n    /**\n     * Compile the section statements into valid PHP.\n     *\n     * @param  string  $expression\n     * @return string\n     */\n    protected function compileSection($expression)\n    {\n        $this->lastSection = trim($expression, \"()'\\\" \");\n\n        return \"<?php \\$__env->startSection{$expression}; ?>\";\n    }\n\n    /**\n     * Replace the @parent directive to a placeholder.\n     *\n     * @return string\n     */\n    protected function compileParent()\n    {\n        $escapedLastSection = strtr($this->lastSection, ['\\\\' => '\\\\\\\\', \"'\" => \"\\\\'\"]);\n\n        return \"<?php echo \\Illuminate\\View\\Factory::parentPlaceholder('{$escapedLastSection}'); ?>\";\n    }\n\n    /**\n     * Compile the yield statements into valid PHP.\n     *\n     * @param  string  $expression\n     * @return string\n     */\n    protected function compileYield($expression)\n    {\n        return \"<?php echo \\$__env->yieldContent{$expression}; ?>\";\n    }\n\n    /**\n     * Compile the show statements into valid PHP.\n     *\n     * @return string\n     */\n    protected function compileShow()\n    {\n        return '<?php echo $__env->yieldSection(); ?>';\n    }\n\n    /**\n     * Compile the append statements into valid PHP.\n     *\n     * @return string\n     */\n    protected function compileAppend()\n    {\n        return '<?php $__env->appendSection(); ?>';\n    }\n\n    /**\n     * Compile the overwrite statements into valid PHP.\n     *\n     * @return string\n     */\n    protected function compileOverwrite()\n    {\n        return '<?php $__env->stopSection(true); ?>';\n    }\n\n    /**\n     * Compile the stop statements into valid PHP.\n     *\n     * @return string\n     */\n    protected function compileStop()\n    {\n        return '<?php $__env->stopSection(); ?>';\n    }\n\n    /**\n     * Compile the end-section statements into valid PHP.\n     *\n     * @return string\n     */\n    protected function compileEndsection()\n    {\n        return '<?php $__env->stopSection(); ?>';\n    }\n}\n", "<?php\n\nnamespace Illuminate\\View\\Concerns;\n\nuse Illuminate\\Contracts\\View\\View;\nuse Illuminate\\Support\\Str;\nuse InvalidArgumentException;\n\ntrait ManagesLayouts\n{\n    /**\n     * All of the finished, captured sections.\n     *\n     * @var array\n     */\n    protected $sections = [];\n\n    /**\n     * The stack of in-progress sections.\n     *\n     * @var array\n     */\n    protected $sectionStack = [];\n\n    /**\n     * The parent placeholder for the request.\n     *\n     * @var mixed\n     */\n    protected static $parentPlaceholder = [];\n\n    /**\n     * The parent placeholder salt for the request.\n     *\n     * @var string\n     */\n    protected static $parentPlaceholderSalt;\n\n    /**\n     * Start injecting content into a section.\n     *\n     * @param  string  $section\n     * @param  string|null  $content\n     * @return void\n     */\n    public function startSection($section, $content = null)\n    {\n        if ($content === null) {\n            if (ob_start()) {\n                $this->sectionStack[] = $section;\n            }\n        } else {\n            $this->extendSection($section, $content instanceof View ? $content : e($content));\n        }\n    }\n\n    /**\n     * Inject inline content into a section.\n     *\n     * @param  string  $section\n     * @param  string  $content\n     * @return void\n     */\n    public function inject($section, $content)\n    {\n        $this->startSection($section, $content);\n    }\n\n    /**\n     * Stop injecting content into a section and return its contents.\n     *\n     * @return string\n     */\n    public function yieldSection()\n    {\n        if (empty($this->sectionStack)) {\n            return '';\n        }\n\n        return $this->yieldContent($this->stopSection());\n    }\n\n    /**\n     * Stop injecting content into a section.\n     *\n     * @param  bool  $overwrite\n     * @return string\n     *\n     * @throws \\InvalidArgumentException\n     */\n    public function stopSection($overwrite = false)\n    {\n        if (empty($this->sectionStack)) {\n            throw new InvalidArgumentException('Cannot end a section without first starting one.');\n        }\n\n        $last = array_pop($this->sectionStack);\n\n        if ($overwrite) {\n            $this->sections[$last] = ob_get_clean();\n        } else {\n            $this->extendSection($last, ob_get_clean());\n        }\n\n        return $last;\n    }\n\n    /**\n     * Stop injecting content into a section and append it.\n     *\n     * @return string\n     *\n     * @throws \\InvalidArgumentException\n     */\n    public function appendSection()\n    {\n        if (empty($this->sectionStack)) {\n            throw new InvalidArgumentException('Cannot end a section without first starting one.');\n        }\n\n        $last = array_pop($this->sectionStack);\n\n        if (isset($this->sections[$last])) {\n            $this->sections[$last] .= ob_get_clean();\n        } else {\n            $this->sections[$last] = ob_get_clean();\n        }\n\n        return $last;\n    }\n\n    /**\n     * Append content to a given section.\n     *\n     * @param  string  $section\n     * @param  string  $content\n     * @return void\n     */\n    protected function extendSection($section, $content)\n    {\n        if (isset($this->sections[$section])) {\n            $content = str_replace(static::parentPlaceholder($section), $content, $this->sections[$section]);\n        }\n\n        $this->sections[$section] = $content;\n    }\n\n    /**\n     * Get the string contents of a section.\n     *\n     * @param  string  $section\n     * @param  string  $default\n     * @return string\n     */\n    public function yieldContent($section, $default = '')\n    {\n        $sectionContent = $default instanceof View ? $default : e($default);\n\n        if (isset($this->sections[$section])) {\n            $sectionContent = $this->sections[$section];\n        }\n\n        $sectionContent = str_replace('@@parent', '--parent--holder--', $sectionContent);\n\n        return str_replace(\n            '--parent--holder--', '@parent', str_replace(static::parentPlaceholder($section), '', $sectionContent)\n        );\n    }\n\n    /**\n     * Get the parent placeholder for the current request.\n     *\n     * @param  string  $section\n     * @return string\n     */\n    public static function parentPlaceholder($section = '')\n    {\n        if (! isset(static::$parentPlaceholder[$section])) {\n            $salt = static::parentPlaceholderSalt();\n\n            static::$parentPlaceholder[$section] = '##parent-placeholder-'.sha1($salt.$section).'##';\n        }\n\n        return static::$parentPlaceholder[$section];\n    }\n\n    /**\n     * Get the parent placeholder salt.\n     *\n     * @return string\n     */\n    protected static function parentPlaceholderSalt()\n    {\n        if (! static::$parentPlaceholderSalt) {\n            return static::$parentPlaceholderSalt = Str::random(40);\n        }\n\n        return static::$parentPlaceholderSalt;\n    }\n\n    /**\n     * Check if section exists.\n     *\n     * @param  string  $name\n     * @return bool\n     */\n    public function hasSection($name)\n    {\n        return array_key_exists($name, $this->sections);\n    }\n\n    /**\n     * Get the contents of a section.\n     *\n     * @param  string  $name\n     * @param  string|null  $default\n     * @return mixed\n     */\n    public function getSection($name, $default = null)\n    {\n        return $this->getSections()[$name] ?? $default;\n    }\n\n    /**\n     * Get the entire array of sections.\n     *\n     * @return array\n     */\n    public function getSections()\n    {\n        return $this->sections;\n    }\n\n    /**\n     * Flush all of the sections.\n     *\n     * @return void\n     */\n    public function flushSections()\n    {\n        $this->sections = [];\n        $this->sectionStack = [];\n    }\n}\n", "<?php\n\nnamespace Illuminate\\Tests\\View;\n\nuse Illuminate\\Filesystem\\Filesystem;\nuse Illuminate\\View\\Compilers\\BladeCompiler;\nuse InvalidArgumentException;\nuse Mockery as m;\nuse PHPUnit\\Framework\\TestCase;\n\nclass ViewBladeCompilerTest extends TestCase\n{\n    protected function tearDown(): void\n    {\n        m::close();\n    }\n\n    public function testIsExpiredReturnsTrueIfCompiledFileDoesntExist()\n    {\n        $compiler = new BladeCompiler($files = $this->getFiles(), __DIR__);\n        $files->shouldReceive('exists')->once()->with(__DIR__.'/'.sha1('v2foo').'.php')->andReturn(false);\n        $this->assertTrue($compiler->isExpired('foo'));\n    }\n\n    public function testCannotConstructWithBadCachePath()\n    {\n        $this->expectException(InvalidArgumentException::class);\n        $this->expectExceptionMessage('Please provide a valid cache path.');\n\n        new BladeCompiler($this->getFiles(), null);\n    }\n\n    public function testIsExpiredReturnsTrueWhenModificationTimesWarrant()\n    {\n        $compiler = new BladeCompiler($files = $this->getFiles(), __DIR__);\n        $files->shouldReceive('exists')->once()->with(__DIR__.'/'.sha1('v2foo').'.php')->andReturn(true);\n        $files->shouldReceive('lastModified')->once()->with('foo')->andReturn(100);\n        $files->shouldReceive('lastModified')->once()->with(__DIR__.'/'.sha1('v2foo').'.php')->andReturn(0);\n        $this->assertTrue($compiler->isExpired('foo'));\n    }\n\n    public function testCompilePathIsProperlyCreated()\n    {\n        $compiler = new BladeCompiler($this->getFiles(), __DIR__);\n        $this->assertEquals(__DIR__.'/'.sha1('v2foo').'.php', $compiler->getCompiledPath('foo'));\n    }\n\n    public function testCompileCompilesFileAndReturnsContents()\n    {\n        $compiler = new BladeCompiler($files = $this->getFiles(), __DIR__);\n        $files->shouldReceive('get')->once()->with('foo')->andReturn('Hello World');\n        $files->shouldReceive('put')->once()->with(__DIR__.'/'.sha1('v2foo').'.php', 'Hello World<?php /**PATH foo ENDPATH**/ ?>');\n        $compiler->compile('foo');\n    }\n\n    public function testCompileCompilesAndGetThePath()\n    {\n        $compiler = new BladeCompiler($files = $this->getFiles(), __DIR__);\n        $files->shouldReceive('get')->once()->with('foo')->andReturn('Hello World');\n        $files->shouldReceive('put')->once()->with(__DIR__.'/'.sha1('v2foo').'.php', 'Hello World<?php /**PATH foo ENDPATH**/ ?>');\n        $compiler->compile('foo');\n        $this->assertSame('foo', $compiler->getPath());\n    }\n\n    public function testCompileSetAndGetThePath()\n    {\n        $compiler = new BladeCompiler($files = $this->getFiles(), __DIR__);\n        $compiler->setPath('foo');\n        $this->assertSame('foo', $compiler->getPath());\n    }\n\n    public function testCompileWithPathSetBefore()\n    {\n        $compiler = new BladeCompiler($files = $this->getFiles(), __DIR__);\n        $files->shouldReceive('get')->once()->with('foo')->andReturn('Hello World');\n        $files->shouldReceive('put')->once()->with(__DIR__.'/'.sha1('v2foo').'.php', 'Hello World<?php /**PATH foo ENDPATH**/ ?>');\n        // set path before compilation\n        $compiler->setPath('foo');\n        // trigger compilation with $path\n        $compiler->compile();\n        $this->assertSame('foo', $compiler->getPath());\n    }\n\n    public function testRawTagsCanBeSetToLegacyValues()\n    {\n        $compiler = new BladeCompiler($this->getFiles(), __DIR__);\n        $compiler->setEchoFormat('%s');\n\n        $this->assertSame('<?php echo e($name); ?>', $compiler->compileString('{{{ $name }}}'));\n        $this->assertSame('<?php echo $name; ?>', $compiler->compileString('{{ $name }}'));\n        $this->assertSame('<?php echo $name; ?>', $compiler->compileString('{{\n            $name\n        }}'));\n    }\n\n    /**\n     * @dataProvider appendViewPathDataProvider\n     *\n     * @param  string  $content\n     * @param  string  $compiled\n     */\n    public function testIncludePathToTemplate($content, $compiled)\n    {\n        $compiler = new BladeCompiler($files = $this->getFiles(), __DIR__);\n        $files->shouldReceive('get')->once()->with('foo')->andReturn($content);\n        $files->shouldReceive('put')->once()->with(__DIR__.'/'.sha1('v2foo').'.php', $compiled);\n\n        $compiler->compile('foo');\n    }\n\n    /**\n     * @return array\n     */\n    public function appendViewPathDataProvider()\n    {\n        return [\n            'No PHP blocks' => [\n                'Hello World',\n                'Hello World<?php /**PATH foo ENDPATH**/ ?>',\n            ],\n            'Single PHP block without closing ?>' => [\n                '<?php echo $path',\n                '<?php echo $path ?><?php /**PATH foo ENDPATH**/ ?>',\n            ],\n            'Ending PHP block.' => [\n                'Hello world<?php echo $path ?>',\n                'Hello world<?php echo $path ?><?php /**PATH foo ENDPATH**/ ?>',\n            ],\n            'Ending PHP block without closing ?>' => [\n                'Hello world<?php echo $path',\n                'Hello world<?php echo $path ?><?php /**PATH foo ENDPATH**/ ?>',\n            ],\n            'PHP block between content.' => [\n                'Hello world<?php echo $path ?>Hi There',\n                'Hello world<?php echo $path ?>Hi There<?php /**PATH foo ENDPATH**/ ?>',\n            ],\n            'Multiple PHP blocks.' => [\n                'Hello world<?php echo $path ?>Hi There<?php echo $path ?>Hello Again',\n                'Hello world<?php echo $path ?>Hi There<?php echo $path ?>Hello Again<?php /**PATH foo ENDPATH**/ ?>',\n            ],\n            'Multiple PHP blocks without closing ?>' => [\n                'Hello world<?php echo $path ?>Hi There<?php echo $path',\n                'Hello world<?php echo $path ?>Hi There<?php echo $path ?><?php /**PATH foo ENDPATH**/ ?>',\n            ],\n            'Short open echo tag' => [\n                'Hello world<?= echo $path',\n                'Hello world<?= echo $path ?><?php /**PATH foo ENDPATH**/ ?>',\n            ],\n            'Echo XML declaration' => [\n                '<?php echo \\'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\';',\n                '<?php echo \\'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\'; ?><?php /**PATH foo ENDPATH**/ ?>',\n            ],\n        ];\n    }\n\n    public function testDontIncludeEmptyPath()\n    {\n        $compiler = new BladeCompiler($files = $this->getFiles(), __DIR__);\n        $files->shouldReceive('get')->once()->with('')->andReturn('Hello World');\n        $files->shouldReceive('put')->once()->with(__DIR__.'/'.sha1('v2').'.php', 'Hello World');\n        $compiler->setPath('');\n        $compiler->compile();\n    }\n\n    public function testDontIncludeNullPath()\n    {\n        $compiler = new BladeCompiler($files = $this->getFiles(), __DIR__);\n        $files->shouldReceive('get')->once()->with(null)->andReturn('Hello World');\n        $files->shouldReceive('put')->once()->with(__DIR__.'/'.sha1('v2').'.php', 'Hello World');\n        $compiler->setPath(null);\n        $compiler->compile();\n    }\n\n    public function testShouldStartFromStrictTypesDeclaration()\n    {\n        $compiler = new BladeCompiler($files = $this->getFiles(), __DIR__);\n        $strictTypeDecl = \"<?php\\ndeclare(strict_types = 1);\";\n        $this->assertTrue(substr($compiler->compileString(\"<?php\\ndeclare(strict_types = 1);\\nHello World\"),\n            0, strlen($strictTypeDecl)) === $strictTypeDecl);\n    }\n\n    protected function getFiles()\n    {\n        return m::mock(Filesystem::class);\n    }\n}\n"], "filenames": ["src/Illuminate/View/Compilers/Compiler.php", "src/Illuminate/View/Compilers/Concerns/CompilesLayouts.php", "src/Illuminate/View/Concerns/ManagesLayouts.php", "tests/View/ViewBladeCompilerTest.php"], "buggy_code_start_loc": [51, 4, 5, 21], "buggy_code_end_loc": [52, 54, 174, 170], "fixing_code_start_loc": [51, 3, 6, 21], "fixing_code_end_loc": [52, 54, 199, 170], "type": "CWE-327", "message": "Laravel is a web application framework. Laravel prior to versions 8.75.0, 7.30.6, and 6.20.42 contain a possible cross-site scripting (XSS) vulnerability in the Blade templating engine. A broken HTML element may be clicked and the user taken to another location in their browser due to XSS. This is due to the user being able to guess the parent placeholder SHA-1 hash by trying common names of sections. If the parent template contains an exploitable HTML structure an XSS vulnerability can be exposed. This vulnerability has been patched in versions 8.75.0, 7.30.6, and 6.20.42 by determining the parent placeholder at runtime and using a random hash that is unique to each request.", "other": {"cve": {"id": "CVE-2021-43808", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-08T00:15:07.683", "lastModified": "2022-08-09T13:17:13.167", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Laravel is a web application framework. Laravel prior to versions 8.75.0, 7.30.6, and 6.20.42 contain a possible cross-site scripting (XSS) vulnerability in the Blade templating engine. A broken HTML element may be clicked and the user taken to another location in their browser due to XSS. This is due to the user being able to guess the parent placeholder SHA-1 hash by trying common names of sections. If the parent template contains an exploitable HTML structure an XSS vulnerability can be exposed. This vulnerability has been patched in versions 8.75.0, 7.30.6, and 6.20.42 by determining the parent placeholder at runtime and using a random hash that is unique to each request."}, {"lang": "es", "value": "Laravel es un framework de aplicaciones web. Laravel versiones anteriores a 8.75.0, 7.30.6 y 6.20.42, contiene una posible vulnerabilidad de tipo cross-site scripting (XSS) en el motor de plantillas Blade. Puede hacerse clic en un elemento HTML roto y llevar al usuario a otra ubicaci\u00f3n en su navegador debido a un ataque de tipo XSS. Esto es debido a que el usuario puede adivinar el hash SHA-1 del marcador de posici\u00f3n padre al probar los nombres comunes de las secciones. Si la plantilla padre contiene una estructura HTML explotable puede exponerse una vulnerabilidad de tipo XSS. Esta vulnerabilidad ha sido parcheada en las versiones 8.75.0, 7.30.6 y 6.20.42 determinando el marcador de posici\u00f3n padre en tiempo de ejecuci\u00f3n y usando un hash aleatorio que es \u00fanico para cada petici\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-327"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:laravel:framework:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.20.42", "matchCriteriaId": "008F1411-5AC5-4BB3-9BB4-C873D9D4CB2C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:laravel:framework:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0", "versionEndExcluding": "7.30.6", "matchCriteriaId": "6B26BF29-BEB7-44FF-A39F-A103C30B0726"}, {"vulnerable": true, "criteria": "cpe:2.3:a:laravel:framework:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0.0", "versionEndExcluding": "8.75.0", "matchCriteriaId": "15E8F817-7A3D-40D4-9DCB-FBC8FD7CE3F7"}]}]}], "references": [{"url": "https://github.com/laravel/framework/commit/b8174169b1807f36de1837751599e2828ceddb9b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/laravel/framework/pull/39906", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/laravel/framework/pull/39908", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/laravel/framework/pull/39909", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/laravel/framework/releases/tag/v6.20.42", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/laravel/framework/releases/tag/v7.30.6", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/laravel/framework/releases/tag/v8.75.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/laravel/framework/security/advisories/GHSA-66hf-2p6w-jqfw", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/laravel/framework/commit/b8174169b1807f36de1837751599e2828ceddb9b"}}