{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n *  linux/drivers/block/floppy.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n *  Copyright (C) 1993, 1994  Alain Knaff\n *  Copyright (C) 1998 Alan Cox\n */\n\n/*\n * 02.12.91 - Changed to static variables to indicate need for reset\n * and recalibrate. This makes some things easier (output_byte reset\n * checking etc), and means less interrupt jumping in case of errors,\n * so the code is hopefully easier to understand.\n */\n\n/*\n * This file is certainly a mess. I've tried my best to get it working,\n * but I don't like programming floppies, and I have only one anyway.\n * Urgel. I should check for more errors, and do more graceful error\n * recovery. Seems there are problems with several drives. I've tried to\n * correct them. No promises.\n */\n\n/*\n * As with hd.c, all routines within this file can (and will) be called\n * by interrupts, so extreme caution is needed. A hardware interrupt\n * handler may not sleep, or a kernel panic will happen. Thus I cannot\n * call \"floppy-on\" directly, but have to set a special timer interrupt\n * etc.\n */\n\n/*\n * 28.02.92 - made track-buffering routines, based on the routines written\n * by entropy@wintermute.wpi.edu (Lawrence Foard). Linus.\n */\n\n/*\n * Automatic floppy-detection and formatting written by Werner Almesberger\n * (almesber@nessie.cs.id.ethz.ch), who also corrected some problems with\n * the floppy-change signal detection.\n */\n\n/*\n * 1992/7/22 -- Hennus Bergman: Added better error reporting, fixed\n * FDC data overrun bug, added some preliminary stuff for vertical\n * recording support.\n *\n * 1992/9/17: Added DMA allocation & DMA functions. -- hhb.\n *\n * TODO: Errors are still not counted properly.\n */\n\n/* 1992/9/20\n * Modifications for ``Sector Shifting'' by Rob Hooft (hooft@chem.ruu.nl)\n * modeled after the freeware MS-DOS program fdformat/88 V1.8 by\n * Christoph H. Hochst\\\"atter.\n * I have fixed the shift values to the ones I always use. Maybe a new\n * ioctl() should be created to be able to modify them.\n * There is a bug in the driver that makes it impossible to format a\n * floppy as the first thing after bootup.\n */\n\n/*\n * 1993/4/29 -- Linus -- cleaned up the timer handling in the kernel, and\n * this helped the floppy driver as well. Much cleaner, and still seems to\n * work.\n */\n\n/* 1994/6/24 --bbroad-- added the floppy table entries and made\n * minor modifications to allow 2.88 floppies to be run.\n */\n\n/* 1994/7/13 -- Paul Vojta -- modified the probing code to allow three or more\n * disk types.\n */\n\n/*\n * 1994/8/8 -- Alain Knaff -- Switched to fdpatch driver: Support for bigger\n * format bug fixes, but unfortunately some new bugs too...\n */\n\n/* 1994/9/17 -- Koen Holtman -- added logging of physical floppy write\n * errors to allow safe writing by specialized programs.\n */\n\n/* 1995/4/24 -- Dan Fandrich -- added support for Commodore 1581 3.5\" disks\n * by defining bit 1 of the \"stretch\" parameter to mean put sectors on the\n * opposite side of the disk, leaving the sector IDs alone (i.e. Commodore's\n * drives are \"upside-down\").\n */\n\n/*\n * 1995/8/26 -- Andreas Busse -- added Mips support.\n */\n\n/*\n * 1995/10/18 -- Ralf Baechle -- Portability cleanup; move machine dependent\n * features to asm/floppy.h.\n */\n\n/*\n * 1998/1/21 -- Richard Gooch <rgooch@atnf.csiro.au> -- devfs support\n */\n\n/*\n * 1998/05/07 -- Russell King -- More portability cleanups; moved definition of\n * interrupt and dma channel to asm/floppy.h. Cleaned up some formatting &\n * use of '0' for NULL.\n */\n\n/*\n * 1998/06/07 -- Alan Cox -- Merged the 2.0.34 fixes for resource allocation\n * failures.\n */\n\n/*\n * 1998/09/20 -- David Weinehall -- Added slow-down code for buggy PS/2-drives.\n */\n\n/*\n * 1999/08/13 -- Paul Slootman -- floppy stopped working on Alpha after 24\n * days, 6 hours, 32 minutes and 32 seconds (i.e. MAXINT jiffies; ints were\n * being used to store jiffies, which are unsigned longs).\n */\n\n/*\n * 2000/08/28 -- Arnaldo Carvalho de Melo <acme@conectiva.com.br>\n * - get rid of check_region\n * - s/suser/capable/\n */\n\n/*\n * 2001/08/26 -- Paul Gortmaker - fix insmod oops on machines with no\n * floppy controller (lingering task on list after module is gone... boom.)\n */\n\n/*\n * 2002/02/07 -- Anton Altaparmakov - Fix io ports reservation to correct range\n * (0x3f2-0x3f5, 0x3f7). This fix is a bit of a hack but the proper fix\n * requires many non-obvious changes in arch dependent code.\n */\n\n/* 2003/07/28 -- Daniele Bellucci <bellucda@tiscali.it>.\n * Better audit of register_blkdev.\n */\n\n#undef  FLOPPY_SILENT_DCL_CLEAR\n\n#define REALLY_SLOW_IO\n\n#define DEBUGT 2\n\n#define DPRINT(format, args...) \\\n\tpr_info(\"floppy%d: \" format, current_drive, ##args)\n\n#define DCL_DEBUG\t\t/* debug disk change line */\n#ifdef DCL_DEBUG\n#define debug_dcl(test, fmt, args...) \\\n\tdo { if ((test) & FD_DEBUG) DPRINT(fmt, ##args); } while (0)\n#else\n#define debug_dcl(test, fmt, args...) \\\n\tdo { if (0) DPRINT(fmt, ##args); } while (0)\n#endif\n\n/* do print messages for unexpected interrupts */\nstatic int print_unex = 1;\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/workqueue.h>\n#define FDPATCHES\n#include <linux/fdreg.h>\n#include <linux/fd.h>\n#include <linux/hdreg.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/string.h>\n#include <linux/jiffies.h>\n#include <linux/fcntl.h>\n#include <linux/delay.h>\n#include <linux/mc146818rtc.h>\t/* CMOS defines */\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mutex.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/compat.h>\n\n/*\n * PS/2 floppies have much slower step rates than regular floppies.\n * It's been recommended that take about 1/4 of the default speed\n * in some more extreme cases.\n */\nstatic DEFINE_MUTEX(floppy_mutex);\nstatic int slow_floppy;\n\n#include <asm/dma.h>\n#include <asm/irq.h>\n\nstatic int FLOPPY_IRQ = 6;\nstatic int FLOPPY_DMA = 2;\nstatic int can_use_virtual_dma = 2;\n/* =======\n * can use virtual DMA:\n * 0 = use of virtual DMA disallowed by config\n * 1 = use of virtual DMA prescribed by config\n * 2 = no virtual DMA preference configured.  By default try hard DMA,\n * but fall back on virtual DMA when not enough memory available\n */\n\nstatic int use_virtual_dma;\n/* =======\n * use virtual DMA\n * 0 using hard DMA\n * 1 using virtual DMA\n * This variable is set to virtual when a DMA mem problem arises, and\n * reset back in floppy_grab_irq_and_dma.\n * It is not safe to reset it in other circumstances, because the floppy\n * driver may have several buffers in use at once, and we do currently not\n * record each buffers capabilities\n */\n\nstatic DEFINE_SPINLOCK(floppy_lock);\n\nstatic unsigned short virtual_dma_port = 0x3f0;\nirqreturn_t floppy_interrupt(int irq, void *dev_id);\nstatic int set_dor(int fdc, char mask, char data);\n\n#define K_64\t0x10000\t\t/* 64KB */\n\n/* the following is the mask of allowed drives. By default units 2 and\n * 3 of both floppy controllers are disabled, because switching on the\n * motor of these drives causes system hangs on some PCI computers. drive\n * 0 is the low bit (0x1), and drive 7 is the high bit (0x80). Bits are on if\n * a drive is allowed.\n *\n * NOTE: This must come before we include the arch floppy header because\n *       some ports reference this variable from there. -DaveM\n */\n\nstatic int allowed_drive_mask = 0x33;\n\n#include <asm/floppy.h>\n\nstatic int irqdma_allocated;\n\n#include <linux/blk-mq.h>\n#include <linux/blkpg.h>\n#include <linux/cdrom.h>\t/* for the compatibility eject ioctl */\n#include <linux/completion.h>\n\nstatic LIST_HEAD(floppy_reqs);\nstatic struct request *current_req;\nstatic int set_next_request(void);\n\n#ifndef fd_get_dma_residue\n#define fd_get_dma_residue() get_dma_residue(FLOPPY_DMA)\n#endif\n\n/* Dma Memory related stuff */\n\n#ifndef fd_dma_mem_free\n#define fd_dma_mem_free(addr, size) free_pages(addr, get_order(size))\n#endif\n\n#ifndef fd_dma_mem_alloc\n#define fd_dma_mem_alloc(size) __get_dma_pages(GFP_KERNEL, get_order(size))\n#endif\n\n#ifndef fd_cacheflush\n#define fd_cacheflush(addr, size) /* nothing... */\n#endif\n\nstatic inline void fallback_on_nodma_alloc(char **addr, size_t l)\n{\n#ifdef FLOPPY_CAN_FALLBACK_ON_NODMA\n\tif (*addr)\n\t\treturn;\t\t/* we have the memory */\n\tif (can_use_virtual_dma != 2)\n\t\treturn;\t\t/* no fallback allowed */\n\tpr_info(\"DMA memory shortage. Temporarily falling back on virtual DMA\\n\");\n\t*addr = (char *)nodma_mem_alloc(l);\n#else\n\treturn;\n#endif\n}\n\n/* End dma memory related stuff */\n\nstatic unsigned long fake_change;\nstatic bool initialized;\n\n#define ITYPE(x)\t(((x) >> 2) & 0x1f)\n#define TOMINOR(x)\t((x & 3) | ((x & 4) << 5))\n#define UNIT(x)\t\t((x) & 0x03)\t\t/* drive on fdc */\n#define FDC(x)\t\t(((x) & 0x04) >> 2)\t/* fdc of drive */\n\t/* reverse mapping from unit and fdc to drive */\n#define REVDRIVE(fdc, unit) ((unit) + ((fdc) << 2))\n\n#define DP\t(&drive_params[current_drive])\n#define DRS\t(&drive_state[current_drive])\n#define DRWE\t(&write_errors[current_drive])\n#define FDCS\t(&fdc_state[fdc])\n\n#define UDP\t(&drive_params[drive])\n#define UDRS\t(&drive_state[drive])\n#define UDRWE\t(&write_errors[drive])\n#define UFDCS\t(&fdc_state[FDC(drive)])\n\n#define PH_HEAD(floppy, head) (((((floppy)->stretch & 2) >> 1) ^ head) << 2)\n#define STRETCH(floppy)\t((floppy)->stretch & FD_STRETCH)\n\n/* read/write */\n#define COMMAND\t\t(raw_cmd->cmd[0])\n#define DR_SELECT\t(raw_cmd->cmd[1])\n#define TRACK\t\t(raw_cmd->cmd[2])\n#define HEAD\t\t(raw_cmd->cmd[3])\n#define SECTOR\t\t(raw_cmd->cmd[4])\n#define SIZECODE\t(raw_cmd->cmd[5])\n#define SECT_PER_TRACK\t(raw_cmd->cmd[6])\n#define GAP\t\t(raw_cmd->cmd[7])\n#define SIZECODE2\t(raw_cmd->cmd[8])\n#define NR_RW 9\n\n/* format */\n#define F_SIZECODE\t(raw_cmd->cmd[2])\n#define F_SECT_PER_TRACK (raw_cmd->cmd[3])\n#define F_GAP\t\t(raw_cmd->cmd[4])\n#define F_FILL\t\t(raw_cmd->cmd[5])\n#define NR_F 6\n\n/*\n * Maximum disk size (in kilobytes).\n * This default is used whenever the current disk size is unknown.\n * [Now it is rather a minimum]\n */\n#define MAX_DISK_SIZE 4\t\t/* 3984 */\n\n/*\n * globals used by 'result()'\n */\n#define MAX_REPLIES 16\nstatic unsigned char reply_buffer[MAX_REPLIES];\nstatic int inr;\t\t/* size of reply buffer, when called from interrupt */\n#define ST0\t\t(reply_buffer[0])\n#define ST1\t\t(reply_buffer[1])\n#define ST2\t\t(reply_buffer[2])\n#define ST3\t\t(reply_buffer[0])\t/* result of GETSTATUS */\n#define R_TRACK\t\t(reply_buffer[3])\n#define R_HEAD\t\t(reply_buffer[4])\n#define R_SECTOR\t(reply_buffer[5])\n#define R_SIZECODE\t(reply_buffer[6])\n\n#define SEL_DLY\t\t(2 * HZ / 100)\n\n/*\n * this struct defines the different floppy drive types.\n */\nstatic struct {\n\tstruct floppy_drive_params params;\n\tconst char *name;\t/* name printed while booting */\n} default_drive_params[] = {\n/* NOTE: the time values in jiffies should be in msec!\n CMOS drive type\n  |     Maximum data rate supported by drive type\n  |     |   Head load time, msec\n  |     |   |   Head unload time, msec (not used)\n  |     |   |   |     Step rate interval, usec\n  |     |   |   |     |       Time needed for spinup time (jiffies)\n  |     |   |   |     |       |      Timeout for spinning down (jiffies)\n  |     |   |   |     |       |      |   Spindown offset (where disk stops)\n  |     |   |   |     |       |      |   |     Select delay\n  |     |   |   |     |       |      |   |     |     RPS\n  |     |   |   |     |       |      |   |     |     |    Max number of tracks\n  |     |   |   |     |       |      |   |     |     |    |     Interrupt timeout\n  |     |   |   |     |       |      |   |     |     |    |     |   Max nonintlv. sectors\n  |     |   |   |     |       |      |   |     |     |    |     |   | -Max Errors- flags */\n{{0,  500, 16, 16, 8000,    1*HZ, 3*HZ,  0, SEL_DLY, 5,  80, 3*HZ, 20, {3,1,2,0,2}, 0,\n      0, { 7, 4, 8, 2, 1, 5, 3,10}, 3*HZ/2, 0 }, \"unknown\" },\n\n{{1,  300, 16, 16, 8000,    1*HZ, 3*HZ,  0, SEL_DLY, 5,  40, 3*HZ, 17, {3,1,2,0,2}, 0,\n      0, { 1, 0, 0, 0, 0, 0, 0, 0}, 3*HZ/2, 1 }, \"360K PC\" }, /*5 1/4 360 KB PC*/\n\n{{2,  500, 16, 16, 6000, 4*HZ/10, 3*HZ, 14, SEL_DLY, 6,  83, 3*HZ, 17, {3,1,2,0,2}, 0,\n      0, { 2, 5, 6,23,10,20,12, 0}, 3*HZ/2, 2 }, \"1.2M\" }, /*5 1/4 HD AT*/\n\n{{3,  250, 16, 16, 3000,    1*HZ, 3*HZ,  0, SEL_DLY, 5,  83, 3*HZ, 20, {3,1,2,0,2}, 0,\n      0, { 4,22,21,30, 3, 0, 0, 0}, 3*HZ/2, 4 }, \"720k\" }, /*3 1/2 DD*/\n\n{{4,  500, 16, 16, 4000, 4*HZ/10, 3*HZ, 10, SEL_DLY, 5,  83, 3*HZ, 20, {3,1,2,0,2}, 0,\n      0, { 7, 4,25,22,31,21,29,11}, 3*HZ/2, 7 }, \"1.44M\" }, /*3 1/2 HD*/\n\n{{5, 1000, 15,  8, 3000, 4*HZ/10, 3*HZ, 10, SEL_DLY, 5,  83, 3*HZ, 40, {3,1,2,0,2}, 0,\n      0, { 7, 8, 4,25,28,22,31,21}, 3*HZ/2, 8 }, \"2.88M AMI BIOS\" }, /*3 1/2 ED*/\n\n{{6, 1000, 15,  8, 3000, 4*HZ/10, 3*HZ, 10, SEL_DLY, 5,  83, 3*HZ, 40, {3,1,2,0,2}, 0,\n      0, { 7, 8, 4,25,28,22,31,21}, 3*HZ/2, 8 }, \"2.88M\" } /*3 1/2 ED*/\n/*    |  --autodetected formats---    |      |      |\n *    read_track                      |      |    Name printed when booting\n *\t\t\t\t      |     Native format\n *\t            Frequency of disk change checks */\n};\n\nstatic struct floppy_drive_params drive_params[N_DRIVE];\nstatic struct floppy_drive_struct drive_state[N_DRIVE];\nstatic struct floppy_write_errors write_errors[N_DRIVE];\nstatic struct timer_list motor_off_timer[N_DRIVE];\nstatic struct gendisk *disks[N_DRIVE];\nstatic struct blk_mq_tag_set tag_sets[N_DRIVE];\nstatic struct block_device *opened_bdev[N_DRIVE];\nstatic DEFINE_MUTEX(open_lock);\nstatic struct floppy_raw_cmd *raw_cmd, default_raw_cmd;\n\n/*\n * This struct defines the different floppy types.\n *\n * Bit 0 of 'stretch' tells if the tracks need to be doubled for some\n * types (e.g. 360kB diskette in 1.2MB drive, etc.).  Bit 1 of 'stretch'\n * tells if the disk is in Commodore 1581 format, which means side 0 sectors\n * are located on side 1 of the disk but with a side 0 ID, and vice-versa.\n * This is the same as the Sharp MZ-80 5.25\" CP/M disk format, except that the\n * 1581's logical side 0 is on physical side 1, whereas the Sharp's logical\n * side 0 is on physical side 0 (but with the misnamed sector IDs).\n * 'stretch' should probably be renamed to something more general, like\n * 'options'.\n *\n * Bits 2 through 9 of 'stretch' tell the number of the first sector.\n * The LSB (bit 2) is flipped. For most disks, the first sector\n * is 1 (represented by 0x00<<2).  For some CP/M and music sampler\n * disks (such as Ensoniq EPS 16plus) it is 0 (represented as 0x01<<2).\n * For Amstrad CPC disks it is 0xC1 (represented as 0xC0<<2).\n *\n * Other parameters should be self-explanatory (see also setfdprm(8)).\n */\n/*\n\t    Size\n\t     |  Sectors per track\n\t     |  | Head\n\t     |  | |  Tracks\n\t     |  | |  | Stretch\n\t     |  | |  | |  Gap 1 size\n\t     |  | |  | |    |  Data rate, | 0x40 for perp\n\t     |  | |  | |    |    |  Spec1 (stepping rate, head unload\n\t     |  | |  | |    |    |    |    /fmt gap (gap2) */\nstatic struct floppy_struct floppy_type[32] = {\n\t{    0, 0,0, 0,0,0x00,0x00,0x00,0x00,NULL    },\t/*  0 no testing    */\n\t{  720, 9,2,40,0,0x2A,0x02,0xDF,0x50,\"d360\"  }, /*  1 360KB PC      */\n\t{ 2400,15,2,80,0,0x1B,0x00,0xDF,0x54,\"h1200\" },\t/*  2 1.2MB AT      */\n\t{  720, 9,1,80,0,0x2A,0x02,0xDF,0x50,\"D360\"  },\t/*  3 360KB SS 3.5\" */\n\t{ 1440, 9,2,80,0,0x2A,0x02,0xDF,0x50,\"D720\"  },\t/*  4 720KB 3.5\"    */\n\t{  720, 9,2,40,1,0x23,0x01,0xDF,0x50,\"h360\"  },\t/*  5 360KB AT      */\n\t{ 1440, 9,2,80,0,0x23,0x01,0xDF,0x50,\"h720\"  },\t/*  6 720KB AT      */\n\t{ 2880,18,2,80,0,0x1B,0x00,0xCF,0x6C,\"H1440\" },\t/*  7 1.44MB 3.5\"   */\n\t{ 5760,36,2,80,0,0x1B,0x43,0xAF,0x54,\"E2880\" },\t/*  8 2.88MB 3.5\"   */\n\t{ 6240,39,2,80,0,0x1B,0x43,0xAF,0x28,\"E3120\" },\t/*  9 3.12MB 3.5\"   */\n\n\t{ 2880,18,2,80,0,0x25,0x00,0xDF,0x02,\"h1440\" }, /* 10 1.44MB 5.25\"  */\n\t{ 3360,21,2,80,0,0x1C,0x00,0xCF,0x0C,\"H1680\" }, /* 11 1.68MB 3.5\"   */\n\t{  820,10,2,41,1,0x25,0x01,0xDF,0x2E,\"h410\"  },\t/* 12 410KB 5.25\"   */\n\t{ 1640,10,2,82,0,0x25,0x02,0xDF,0x2E,\"H820\"  },\t/* 13 820KB 3.5\"    */\n\t{ 2952,18,2,82,0,0x25,0x00,0xDF,0x02,\"h1476\" },\t/* 14 1.48MB 5.25\"  */\n\t{ 3444,21,2,82,0,0x25,0x00,0xDF,0x0C,\"H1722\" },\t/* 15 1.72MB 3.5\"   */\n\t{  840,10,2,42,1,0x25,0x01,0xDF,0x2E,\"h420\"  },\t/* 16 420KB 5.25\"   */\n\t{ 1660,10,2,83,0,0x25,0x02,0xDF,0x2E,\"H830\"  },\t/* 17 830KB 3.5\"    */\n\t{ 2988,18,2,83,0,0x25,0x00,0xDF,0x02,\"h1494\" },\t/* 18 1.49MB 5.25\"  */\n\t{ 3486,21,2,83,0,0x25,0x00,0xDF,0x0C,\"H1743\" }, /* 19 1.74 MB 3.5\"  */\n\n\t{ 1760,11,2,80,0,0x1C,0x09,0xCF,0x00,\"h880\"  }, /* 20 880KB 5.25\"   */\n\t{ 2080,13,2,80,0,0x1C,0x01,0xCF,0x00,\"D1040\" }, /* 21 1.04MB 3.5\"   */\n\t{ 2240,14,2,80,0,0x1C,0x19,0xCF,0x00,\"D1120\" }, /* 22 1.12MB 3.5\"   */\n\t{ 3200,20,2,80,0,0x1C,0x20,0xCF,0x2C,\"h1600\" }, /* 23 1.6MB 5.25\"   */\n\t{ 3520,22,2,80,0,0x1C,0x08,0xCF,0x2e,\"H1760\" }, /* 24 1.76MB 3.5\"   */\n\t{ 3840,24,2,80,0,0x1C,0x20,0xCF,0x00,\"H1920\" }, /* 25 1.92MB 3.5\"   */\n\t{ 6400,40,2,80,0,0x25,0x5B,0xCF,0x00,\"E3200\" }, /* 26 3.20MB 3.5\"   */\n\t{ 7040,44,2,80,0,0x25,0x5B,0xCF,0x00,\"E3520\" }, /* 27 3.52MB 3.5\"   */\n\t{ 7680,48,2,80,0,0x25,0x63,0xCF,0x00,\"E3840\" }, /* 28 3.84MB 3.5\"   */\n\t{ 3680,23,2,80,0,0x1C,0x10,0xCF,0x00,\"H1840\" }, /* 29 1.84MB 3.5\"   */\n\n\t{ 1600,10,2,80,0,0x25,0x02,0xDF,0x2E,\"D800\"  },\t/* 30 800KB 3.5\"    */\n\t{ 3200,20,2,80,0,0x1C,0x00,0xCF,0x2C,\"H1600\" }, /* 31 1.6MB 3.5\"    */\n};\n\n#define SECTSIZE (_FD_SECTSIZE(*floppy))\n\n/* Auto-detection: Disk type used until the next media change occurs. */\nstatic struct floppy_struct *current_type[N_DRIVE];\n\n/*\n * User-provided type information. current_type points to\n * the respective entry of this array.\n */\nstatic struct floppy_struct user_params[N_DRIVE];\n\nstatic sector_t floppy_sizes[256];\n\nstatic char floppy_device_name[] = \"floppy\";\n\n/*\n * The driver is trying to determine the correct media format\n * while probing is set. rw_interrupt() clears it after a\n * successful access.\n */\nstatic int probing;\n\n/* Synchronization of FDC access. */\n#define FD_COMMAND_NONE\t\t-1\n#define FD_COMMAND_ERROR\t2\n#define FD_COMMAND_OKAY\t\t3\n\nstatic volatile int command_status = FD_COMMAND_NONE;\nstatic unsigned long fdc_busy;\nstatic DECLARE_WAIT_QUEUE_HEAD(fdc_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(command_done);\n\n/* Errors during formatting are counted here. */\nstatic int format_errors;\n\n/* Format request descriptor. */\nstatic struct format_descr format_req;\n\n/*\n * Rate is 0 for 500kb/s, 1 for 300kbps, 2 for 250kbps\n * Spec1 is 0xSH, where S is stepping rate (F=1ms, E=2ms, D=3ms etc),\n * H is head unload time (1=16ms, 2=32ms, etc)\n */\n\n/*\n * Track buffer\n * Because these are written to by the DMA controller, they must\n * not contain a 64k byte boundary crossing, or data will be\n * corrupted/lost.\n */\nstatic char *floppy_track_buffer;\nstatic int max_buffer_sectors;\n\nstatic int *errors;\ntypedef void (*done_f)(int);\nstatic const struct cont_t {\n\tvoid (*interrupt)(void);\n\t\t\t\t/* this is called after the interrupt of the\n\t\t\t\t * main command */\n\tvoid (*redo)(void);\t/* this is called to retry the operation */\n\tvoid (*error)(void);\t/* this is called to tally an error */\n\tdone_f done;\t\t/* this is called to say if the operation has\n\t\t\t\t * succeeded/failed */\n} *cont;\n\nstatic void floppy_ready(void);\nstatic void floppy_start(void);\nstatic void process_fd_request(void);\nstatic void recalibrate_floppy(void);\nstatic void floppy_shutdown(struct work_struct *);\n\nstatic int floppy_request_regions(int);\nstatic void floppy_release_regions(int);\nstatic int floppy_grab_irq_and_dma(void);\nstatic void floppy_release_irq_and_dma(void);\n\n/*\n * The \"reset\" variable should be tested whenever an interrupt is scheduled,\n * after the commands have been sent. This is to ensure that the driver doesn't\n * get wedged when the interrupt doesn't come because of a failed command.\n * reset doesn't need to be tested before sending commands, because\n * output_byte is automatically disabled when reset is set.\n */\nstatic void reset_fdc(void);\n\n/*\n * These are global variables, as that's the easiest way to give\n * information to interrupts. They are the data used for the current\n * request.\n */\n#define NO_TRACK\t-1\n#define NEED_1_RECAL\t-2\n#define NEED_2_RECAL\t-3\n\nstatic atomic_t usage_count = ATOMIC_INIT(0);\n\n/* buffer related variables */\nstatic int buffer_track = -1;\nstatic int buffer_drive = -1;\nstatic int buffer_min = -1;\nstatic int buffer_max = -1;\n\n/* fdc related variables, should end up in a struct */\nstatic struct floppy_fdc_state fdc_state[N_FDC];\nstatic int fdc;\t\t\t/* current fdc */\n\nstatic struct workqueue_struct *floppy_wq;\n\nstatic struct floppy_struct *_floppy = floppy_type;\nstatic unsigned char current_drive;\nstatic long current_count_sectors;\nstatic unsigned char fsector_t;\t/* sector in track */\nstatic unsigned char in_sector_offset;\t/* offset within physical sector,\n\t\t\t\t\t * expressed in units of 512 bytes */\n\nstatic inline bool drive_no_geom(int drive)\n{\n\treturn !current_type[drive] && !ITYPE(UDRS->fd_device);\n}\n\n#ifndef fd_eject\nstatic inline int fd_eject(int drive)\n{\n\treturn -EINVAL;\n}\n#endif\n\n/*\n * Debugging\n * =========\n */\n#ifdef DEBUGT\nstatic long unsigned debugtimer;\n\nstatic inline void set_debugt(void)\n{\n\tdebugtimer = jiffies;\n}\n\nstatic inline void debugt(const char *func, const char *msg)\n{\n\tif (DP->flags & DEBUGT)\n\t\tpr_info(\"%s:%s dtime=%lu\\n\", func, msg, jiffies - debugtimer);\n}\n#else\nstatic inline void set_debugt(void) { }\nstatic inline void debugt(const char *func, const char *msg) { }\n#endif /* DEBUGT */\n\n\nstatic DECLARE_DELAYED_WORK(fd_timeout, floppy_shutdown);\nstatic const char *timeout_message;\n\nstatic void is_alive(const char *func, const char *message)\n{\n\t/* this routine checks whether the floppy driver is \"alive\" */\n\tif (test_bit(0, &fdc_busy) && command_status < 2 &&\n\t    !delayed_work_pending(&fd_timeout)) {\n\t\tDPRINT(\"%s: timeout handler died.  %s\\n\", func, message);\n\t}\n}\n\nstatic void (*do_floppy)(void) = NULL;\n\n#define OLOGSIZE 20\n\nstatic void (*lasthandler)(void);\nstatic unsigned long interruptjiffies;\nstatic unsigned long resultjiffies;\nstatic int resultsize;\nstatic unsigned long lastredo;\n\nstatic struct output_log {\n\tunsigned char data;\n\tunsigned char status;\n\tunsigned long jiffies;\n} output_log[OLOGSIZE];\n\nstatic int output_log_pos;\n\n#define current_reqD -1\n#define MAXTIMEOUT -2\n\nstatic void __reschedule_timeout(int drive, const char *message)\n{\n\tunsigned long delay;\n\n\tif (drive == current_reqD)\n\t\tdrive = current_drive;\n\n\tif (drive < 0 || drive >= N_DRIVE) {\n\t\tdelay = 20UL * HZ;\n\t\tdrive = 0;\n\t} else\n\t\tdelay = UDP->timeout;\n\n\tmod_delayed_work(floppy_wq, &fd_timeout, delay);\n\tif (UDP->flags & FD_DEBUG)\n\t\tDPRINT(\"reschedule timeout %s\\n\", message);\n\ttimeout_message = message;\n}\n\nstatic void reschedule_timeout(int drive, const char *message)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&floppy_lock, flags);\n\t__reschedule_timeout(drive, message);\n\tspin_unlock_irqrestore(&floppy_lock, flags);\n}\n\n#define INFBOUND(a, b) (a) = max_t(int, a, b)\n#define SUPBOUND(a, b) (a) = min_t(int, a, b)\n\n/*\n * Bottom half floppy driver.\n * ==========================\n *\n * This part of the file contains the code talking directly to the hardware,\n * and also the main service loop (seek-configure-spinup-command)\n */\n\n/*\n * disk change.\n * This routine is responsible for maintaining the FD_DISK_CHANGE flag,\n * and the last_checked date.\n *\n * last_checked is the date of the last check which showed 'no disk change'\n * FD_DISK_CHANGE is set under two conditions:\n * 1. The floppy has been changed after some i/o to that floppy already\n *    took place.\n * 2. No floppy disk is in the drive. This is done in order to ensure that\n *    requests are quickly flushed in case there is no disk in the drive. It\n *    follows that FD_DISK_CHANGE can only be cleared if there is a disk in\n *    the drive.\n *\n * For 1., maxblock is observed. Maxblock is 0 if no i/o has taken place yet.\n * For 2., FD_DISK_NEWCHANGE is watched. FD_DISK_NEWCHANGE is cleared on\n *  each seek. If a disk is present, the disk change line should also be\n *  cleared on each seek. Thus, if FD_DISK_NEWCHANGE is clear, but the disk\n *  change line is set, this means either that no disk is in the drive, or\n *  that it has been removed since the last seek.\n *\n * This means that we really have a third possibility too:\n *  The floppy has been changed after the last seek.\n */\n\nstatic int disk_change(int drive)\n{\n\tint fdc = FDC(drive);\n\n\tif (time_before(jiffies, UDRS->select_date + UDP->select_delay))\n\t\tDPRINT(\"WARNING disk change called early\\n\");\n\tif (!(FDCS->dor & (0x10 << UNIT(drive))) ||\n\t    (FDCS->dor & 3) != UNIT(drive) || fdc != FDC(drive)) {\n\t\tDPRINT(\"probing disk change on unselected drive\\n\");\n\t\tDPRINT(\"drive=%d fdc=%d dor=%x\\n\", drive, FDC(drive),\n\t\t       (unsigned int)FDCS->dor);\n\t}\n\n\tdebug_dcl(UDP->flags,\n\t\t  \"checking disk change line for drive %d\\n\", drive);\n\tdebug_dcl(UDP->flags, \"jiffies=%lu\\n\", jiffies);\n\tdebug_dcl(UDP->flags, \"disk change line=%x\\n\", fd_inb(FD_DIR) & 0x80);\n\tdebug_dcl(UDP->flags, \"flags=%lx\\n\", UDRS->flags);\n\n\tif (UDP->flags & FD_BROKEN_DCL)\n\t\treturn test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags);\n\tif ((fd_inb(FD_DIR) ^ UDP->flags) & 0x80) {\n\t\tset_bit(FD_VERIFY_BIT, &UDRS->flags);\n\t\t\t\t\t/* verify write protection */\n\n\t\tif (UDRS->maxblock)\t/* mark it changed */\n\t\t\tset_bit(FD_DISK_CHANGED_BIT, &UDRS->flags);\n\n\t\t/* invalidate its geometry */\n\t\tif (UDRS->keep_data >= 0) {\n\t\t\tif ((UDP->flags & FTD_MSG) &&\n\t\t\t    current_type[drive] != NULL)\n\t\t\t\tDPRINT(\"Disk type is undefined after disk change\\n\");\n\t\t\tcurrent_type[drive] = NULL;\n\t\t\tfloppy_sizes[TOMINOR(drive)] = MAX_DISK_SIZE << 1;\n\t\t}\n\n\t\treturn 1;\n\t} else {\n\t\tUDRS->last_checked = jiffies;\n\t\tclear_bit(FD_DISK_NEWCHANGE_BIT, &UDRS->flags);\n\t}\n\treturn 0;\n}\n\nstatic inline int is_selected(int dor, int unit)\n{\n\treturn ((dor & (0x10 << unit)) && (dor & 3) == unit);\n}\n\nstatic bool is_ready_state(int status)\n{\n\tint state = status & (STATUS_READY | STATUS_DIR | STATUS_DMA);\n\treturn state == STATUS_READY;\n}\n\nstatic int set_dor(int fdc, char mask, char data)\n{\n\tunsigned char unit;\n\tunsigned char drive;\n\tunsigned char newdor;\n\tunsigned char olddor;\n\n\tif (FDCS->address == -1)\n\t\treturn -1;\n\n\tolddor = FDCS->dor;\n\tnewdor = (olddor & mask) | data;\n\tif (newdor != olddor) {\n\t\tunit = olddor & 0x3;\n\t\tif (is_selected(olddor, unit) && !is_selected(newdor, unit)) {\n\t\t\tdrive = REVDRIVE(fdc, unit);\n\t\t\tdebug_dcl(UDP->flags,\n\t\t\t\t  \"calling disk change from set_dor\\n\");\n\t\t\tdisk_change(drive);\n\t\t}\n\t\tFDCS->dor = newdor;\n\t\tfd_outb(newdor, FD_DOR);\n\n\t\tunit = newdor & 0x3;\n\t\tif (!is_selected(olddor, unit) && is_selected(newdor, unit)) {\n\t\t\tdrive = REVDRIVE(fdc, unit);\n\t\t\tUDRS->select_date = jiffies;\n\t\t}\n\t}\n\treturn olddor;\n}\n\nstatic void twaddle(void)\n{\n\tif (DP->select_delay)\n\t\treturn;\n\tfd_outb(FDCS->dor & ~(0x10 << UNIT(current_drive)), FD_DOR);\n\tfd_outb(FDCS->dor, FD_DOR);\n\tDRS->select_date = jiffies;\n}\n\n/*\n * Reset all driver information about the current fdc.\n * This is needed after a reset, and after a raw command.\n */\nstatic void reset_fdc_info(int mode)\n{\n\tint drive;\n\n\tFDCS->spec1 = FDCS->spec2 = -1;\n\tFDCS->need_configure = 1;\n\tFDCS->perp_mode = 1;\n\tFDCS->rawcmd = 0;\n\tfor (drive = 0; drive < N_DRIVE; drive++)\n\t\tif (FDC(drive) == fdc && (mode || UDRS->track != NEED_1_RECAL))\n\t\t\tUDRS->track = NEED_2_RECAL;\n}\n\n/* selects the fdc and drive, and enables the fdc's input/dma. */\nstatic void set_fdc(int drive)\n{\n\tif (drive >= 0 && drive < N_DRIVE) {\n\t\tfdc = FDC(drive);\n\t\tcurrent_drive = drive;\n\t}\n\tif (fdc != 1 && fdc != 0) {\n\t\tpr_info(\"bad fdc value\\n\");\n\t\treturn;\n\t}\n\tset_dor(fdc, ~0, 8);\n#if N_FDC > 1\n\tset_dor(1 - fdc, ~8, 0);\n#endif\n\tif (FDCS->rawcmd == 2)\n\t\treset_fdc_info(1);\n\tif (fd_inb(FD_STATUS) != STATUS_READY)\n\t\tFDCS->reset = 1;\n}\n\n/* locks the driver */\nstatic int lock_fdc(int drive)\n{\n\tif (WARN(atomic_read(&usage_count) == 0,\n\t\t \"Trying to lock fdc while usage count=0\\n\"))\n\t\treturn -1;\n\n\tif (wait_event_interruptible(fdc_wait, !test_and_set_bit(0, &fdc_busy)))\n\t\treturn -EINTR;\n\n\tcommand_status = FD_COMMAND_NONE;\n\n\treschedule_timeout(drive, \"lock fdc\");\n\tset_fdc(drive);\n\treturn 0;\n}\n\n/* unlocks the driver */\nstatic void unlock_fdc(void)\n{\n\tif (!test_bit(0, &fdc_busy))\n\t\tDPRINT(\"FDC access conflict!\\n\");\n\n\traw_cmd = NULL;\n\tcommand_status = FD_COMMAND_NONE;\n\tcancel_delayed_work(&fd_timeout);\n\tdo_floppy = NULL;\n\tcont = NULL;\n\tclear_bit(0, &fdc_busy);\n\twake_up(&fdc_wait);\n}\n\n/* switches the motor off after a given timeout */\nstatic void motor_off_callback(struct timer_list *t)\n{\n\tunsigned long nr = t - motor_off_timer;\n\tunsigned char mask = ~(0x10 << UNIT(nr));\n\n\tif (WARN_ON_ONCE(nr >= N_DRIVE))\n\t\treturn;\n\n\tset_dor(FDC(nr), mask, 0);\n}\n\n/* schedules motor off */\nstatic void floppy_off(unsigned int drive)\n{\n\tunsigned long volatile delta;\n\tint fdc = FDC(drive);\n\n\tif (!(FDCS->dor & (0x10 << UNIT(drive))))\n\t\treturn;\n\n\tdel_timer(motor_off_timer + drive);\n\n\t/* make spindle stop in a position which minimizes spinup time\n\t * next time */\n\tif (UDP->rps) {\n\t\tdelta = jiffies - UDRS->first_read_date + HZ -\n\t\t    UDP->spindown_offset;\n\t\tdelta = ((delta * UDP->rps) % HZ) / UDP->rps;\n\t\tmotor_off_timer[drive].expires =\n\t\t    jiffies + UDP->spindown - delta;\n\t}\n\tadd_timer(motor_off_timer + drive);\n}\n\n/*\n * cycle through all N_DRIVE floppy drives, for disk change testing.\n * stopping at current drive. This is done before any long operation, to\n * be sure to have up to date disk change information.\n */\nstatic void scandrives(void)\n{\n\tint i;\n\tint drive;\n\tint saved_drive;\n\n\tif (DP->select_delay)\n\t\treturn;\n\n\tsaved_drive = current_drive;\n\tfor (i = 0; i < N_DRIVE; i++) {\n\t\tdrive = (saved_drive + i + 1) % N_DRIVE;\n\t\tif (UDRS->fd_ref == 0 || UDP->select_delay != 0)\n\t\t\tcontinue;\t/* skip closed drives */\n\t\tset_fdc(drive);\n\t\tif (!(set_dor(fdc, ~3, UNIT(drive) | (0x10 << UNIT(drive))) &\n\t\t      (0x10 << UNIT(drive))))\n\t\t\t/* switch the motor off again, if it was off to\n\t\t\t * begin with */\n\t\t\tset_dor(fdc, ~(0x10 << UNIT(drive)), 0);\n\t}\n\tset_fdc(saved_drive);\n}\n\nstatic void empty(void)\n{\n}\n\nstatic void (*floppy_work_fn)(void);\n\nstatic void floppy_work_workfn(struct work_struct *work)\n{\n\tfloppy_work_fn();\n}\n\nstatic DECLARE_WORK(floppy_work, floppy_work_workfn);\n\nstatic void schedule_bh(void (*handler)(void))\n{\n\tWARN_ON(work_pending(&floppy_work));\n\n\tfloppy_work_fn = handler;\n\tqueue_work(floppy_wq, &floppy_work);\n}\n\nstatic void (*fd_timer_fn)(void) = NULL;\n\nstatic void fd_timer_workfn(struct work_struct *work)\n{\n\tfd_timer_fn();\n}\n\nstatic DECLARE_DELAYED_WORK(fd_timer, fd_timer_workfn);\n\nstatic void cancel_activity(void)\n{\n\tdo_floppy = NULL;\n\tcancel_delayed_work_sync(&fd_timer);\n\tcancel_work_sync(&floppy_work);\n}\n\n/* this function makes sure that the disk stays in the drive during the\n * transfer */\nstatic void fd_watchdog(void)\n{\n\tdebug_dcl(DP->flags, \"calling disk change from watchdog\\n\");\n\n\tif (disk_change(current_drive)) {\n\t\tDPRINT(\"disk removed during i/o\\n\");\n\t\tcancel_activity();\n\t\tcont->done(0);\n\t\treset_fdc();\n\t} else {\n\t\tcancel_delayed_work(&fd_timer);\n\t\tfd_timer_fn = fd_watchdog;\n\t\tqueue_delayed_work(floppy_wq, &fd_timer, HZ / 10);\n\t}\n}\n\nstatic void main_command_interrupt(void)\n{\n\tcancel_delayed_work(&fd_timer);\n\tcont->interrupt();\n}\n\n/* waits for a delay (spinup or select) to pass */\nstatic int fd_wait_for_completion(unsigned long expires,\n\t\t\t\t  void (*function)(void))\n{\n\tif (FDCS->reset) {\n\t\treset_fdc();\t/* do the reset during sleep to win time\n\t\t\t\t * if we don't need to sleep, it's a good\n\t\t\t\t * occasion anyways */\n\t\treturn 1;\n\t}\n\n\tif (time_before(jiffies, expires)) {\n\t\tcancel_delayed_work(&fd_timer);\n\t\tfd_timer_fn = function;\n\t\tqueue_delayed_work(floppy_wq, &fd_timer, expires - jiffies);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void setup_DMA(void)\n{\n\tunsigned long f;\n\n\tif (raw_cmd->length == 0) {\n\t\tint i;\n\n\t\tpr_info(\"zero dma transfer size:\");\n\t\tfor (i = 0; i < raw_cmd->cmd_count; i++)\n\t\t\tpr_cont(\"%x,\", raw_cmd->cmd[i]);\n\t\tpr_cont(\"\\n\");\n\t\tcont->done(0);\n\t\tFDCS->reset = 1;\n\t\treturn;\n\t}\n\tif (((unsigned long)raw_cmd->kernel_data) % 512) {\n\t\tpr_info(\"non aligned address: %p\\n\", raw_cmd->kernel_data);\n\t\tcont->done(0);\n\t\tFDCS->reset = 1;\n\t\treturn;\n\t}\n\tf = claim_dma_lock();\n\tfd_disable_dma();\n#ifdef fd_dma_setup\n\tif (fd_dma_setup(raw_cmd->kernel_data, raw_cmd->length,\n\t\t\t (raw_cmd->flags & FD_RAW_READ) ?\n\t\t\t DMA_MODE_READ : DMA_MODE_WRITE, FDCS->address) < 0) {\n\t\trelease_dma_lock(f);\n\t\tcont->done(0);\n\t\tFDCS->reset = 1;\n\t\treturn;\n\t}\n\trelease_dma_lock(f);\n#else\n\tfd_clear_dma_ff();\n\tfd_cacheflush(raw_cmd->kernel_data, raw_cmd->length);\n\tfd_set_dma_mode((raw_cmd->flags & FD_RAW_READ) ?\n\t\t\tDMA_MODE_READ : DMA_MODE_WRITE);\n\tfd_set_dma_addr(raw_cmd->kernel_data);\n\tfd_set_dma_count(raw_cmd->length);\n\tvirtual_dma_port = FDCS->address;\n\tfd_enable_dma();\n\trelease_dma_lock(f);\n#endif\n}\n\nstatic void show_floppy(void);\n\n/* waits until the fdc becomes ready */\nstatic int wait_til_ready(void)\n{\n\tint status;\n\tint counter;\n\n\tif (FDCS->reset)\n\t\treturn -1;\n\tfor (counter = 0; counter < 10000; counter++) {\n\t\tstatus = fd_inb(FD_STATUS);\n\t\tif (status & STATUS_READY)\n\t\t\treturn status;\n\t}\n\tif (initialized) {\n\t\tDPRINT(\"Getstatus times out (%x) on fdc %d\\n\", status, fdc);\n\t\tshow_floppy();\n\t}\n\tFDCS->reset = 1;\n\treturn -1;\n}\n\n/* sends a command byte to the fdc */\nstatic int output_byte(char byte)\n{\n\tint status = wait_til_ready();\n\n\tif (status < 0)\n\t\treturn -1;\n\n\tif (is_ready_state(status)) {\n\t\tfd_outb(byte, FD_DATA);\n\t\toutput_log[output_log_pos].data = byte;\n\t\toutput_log[output_log_pos].status = status;\n\t\toutput_log[output_log_pos].jiffies = jiffies;\n\t\toutput_log_pos = (output_log_pos + 1) % OLOGSIZE;\n\t\treturn 0;\n\t}\n\tFDCS->reset = 1;\n\tif (initialized) {\n\t\tDPRINT(\"Unable to send byte %x to FDC. Fdc=%x Status=%x\\n\",\n\t\t       byte, fdc, status);\n\t\tshow_floppy();\n\t}\n\treturn -1;\n}\n\n/* gets the response from the fdc */\nstatic int result(void)\n{\n\tint i;\n\tint status = 0;\n\n\tfor (i = 0; i < MAX_REPLIES; i++) {\n\t\tstatus = wait_til_ready();\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus &= STATUS_DIR | STATUS_READY | STATUS_BUSY | STATUS_DMA;\n\t\tif ((status & ~STATUS_BUSY) == STATUS_READY) {\n\t\t\tresultjiffies = jiffies;\n\t\t\tresultsize = i;\n\t\t\treturn i;\n\t\t}\n\t\tif (status == (STATUS_DIR | STATUS_READY | STATUS_BUSY))\n\t\t\treply_buffer[i] = fd_inb(FD_DATA);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (initialized) {\n\t\tDPRINT(\"get result error. Fdc=%d Last status=%x Read bytes=%d\\n\",\n\t\t       fdc, status, i);\n\t\tshow_floppy();\n\t}\n\tFDCS->reset = 1;\n\treturn -1;\n}\n\n#define MORE_OUTPUT -2\n/* does the fdc need more output? */\nstatic int need_more_output(void)\n{\n\tint status = wait_til_ready();\n\n\tif (status < 0)\n\t\treturn -1;\n\n\tif (is_ready_state(status))\n\t\treturn MORE_OUTPUT;\n\n\treturn result();\n}\n\n/* Set perpendicular mode as required, based on data rate, if supported.\n * 82077 Now tested. 1Mbps data rate only possible with 82077-1.\n */\nstatic void perpendicular_mode(void)\n{\n\tunsigned char perp_mode;\n\n\tif (raw_cmd->rate & 0x40) {\n\t\tswitch (raw_cmd->rate & 3) {\n\t\tcase 0:\n\t\t\tperp_mode = 2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tperp_mode = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDPRINT(\"Invalid data rate for perpendicular mode!\\n\");\n\t\t\tcont->done(0);\n\t\t\tFDCS->reset = 1;\n\t\t\t\t\t/*\n\t\t\t\t\t * convenient way to return to\n\t\t\t\t\t * redo without too much hassle\n\t\t\t\t\t * (deep stack et al.)\n\t\t\t\t\t */\n\t\t\treturn;\n\t\t}\n\t} else\n\t\tperp_mode = 0;\n\n\tif (FDCS->perp_mode == perp_mode)\n\t\treturn;\n\tif (FDCS->version >= FDC_82077_ORIG) {\n\t\toutput_byte(FD_PERPENDICULAR);\n\t\toutput_byte(perp_mode);\n\t\tFDCS->perp_mode = perp_mode;\n\t} else if (perp_mode) {\n\t\tDPRINT(\"perpendicular mode not supported by this FDC.\\n\");\n\t}\n}\t\t\t\t/* perpendicular_mode */\n\nstatic int fifo_depth = 0xa;\nstatic int no_fifo;\n\nstatic int fdc_configure(void)\n{\n\t/* Turn on FIFO */\n\toutput_byte(FD_CONFIGURE);\n\tif (need_more_output() != MORE_OUTPUT)\n\t\treturn 0;\n\toutput_byte(0);\n\toutput_byte(0x10 | (no_fifo & 0x20) | (fifo_depth & 0xf));\n\toutput_byte(0);\t\t/* pre-compensation from track\n\t\t\t\t   0 upwards */\n\treturn 1;\n}\n\n#define NOMINAL_DTR 500\n\n/* Issue a \"SPECIFY\" command to set the step rate time, head unload time,\n * head load time, and DMA disable flag to values needed by floppy.\n *\n * The value \"dtr\" is the data transfer rate in Kbps.  It is needed\n * to account for the data rate-based scaling done by the 82072 and 82077\n * FDC types.  This parameter is ignored for other types of FDCs (i.e.\n * 8272a).\n *\n * Note that changing the data transfer rate has a (probably deleterious)\n * effect on the parameters subject to scaling for 82072/82077 FDCs, so\n * fdc_specify is called again after each data transfer rate\n * change.\n *\n * srt: 1000 to 16000 in microseconds\n * hut: 16 to 240 milliseconds\n * hlt: 2 to 254 milliseconds\n *\n * These values are rounded up to the next highest available delay time.\n */\nstatic void fdc_specify(void)\n{\n\tunsigned char spec1;\n\tunsigned char spec2;\n\tunsigned long srt;\n\tunsigned long hlt;\n\tunsigned long hut;\n\tunsigned long dtr = NOMINAL_DTR;\n\tunsigned long scale_dtr = NOMINAL_DTR;\n\tint hlt_max_code = 0x7f;\n\tint hut_max_code = 0xf;\n\n\tif (FDCS->need_configure && FDCS->version >= FDC_82072A) {\n\t\tfdc_configure();\n\t\tFDCS->need_configure = 0;\n\t}\n\n\tswitch (raw_cmd->rate & 0x03) {\n\tcase 3:\n\t\tdtr = 1000;\n\t\tbreak;\n\tcase 1:\n\t\tdtr = 300;\n\t\tif (FDCS->version >= FDC_82078) {\n\t\t\t/* chose the default rate table, not the one\n\t\t\t * where 1 = 2 Mbps */\n\t\t\toutput_byte(FD_DRIVESPEC);\n\t\t\tif (need_more_output() == MORE_OUTPUT) {\n\t\t\t\toutput_byte(UNIT(current_drive));\n\t\t\t\toutput_byte(0xc0);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tdtr = 250;\n\t\tbreak;\n\t}\n\n\tif (FDCS->version >= FDC_82072) {\n\t\tscale_dtr = dtr;\n\t\thlt_max_code = 0x00;\t/* 0==256msec*dtr0/dtr (not linear!) */\n\t\thut_max_code = 0x0;\t/* 0==256msec*dtr0/dtr (not linear!) */\n\t}\n\n\t/* Convert step rate from microseconds to milliseconds and 4 bits */\n\tsrt = 16 - DIV_ROUND_UP(DP->srt * scale_dtr / 1000, NOMINAL_DTR);\n\tif (slow_floppy)\n\t\tsrt = srt / 4;\n\n\tSUPBOUND(srt, 0xf);\n\tINFBOUND(srt, 0);\n\n\thlt = DIV_ROUND_UP(DP->hlt * scale_dtr / 2, NOMINAL_DTR);\n\tif (hlt < 0x01)\n\t\thlt = 0x01;\n\telse if (hlt > 0x7f)\n\t\thlt = hlt_max_code;\n\n\thut = DIV_ROUND_UP(DP->hut * scale_dtr / 16, NOMINAL_DTR);\n\tif (hut < 0x1)\n\t\thut = 0x1;\n\telse if (hut > 0xf)\n\t\thut = hut_max_code;\n\n\tspec1 = (srt << 4) | hut;\n\tspec2 = (hlt << 1) | (use_virtual_dma & 1);\n\n\t/* If these parameters did not change, just return with success */\n\tif (FDCS->spec1 != spec1 || FDCS->spec2 != spec2) {\n\t\t/* Go ahead and set spec1 and spec2 */\n\t\toutput_byte(FD_SPECIFY);\n\t\toutput_byte(FDCS->spec1 = spec1);\n\t\toutput_byte(FDCS->spec2 = spec2);\n\t}\n}\t\t\t\t/* fdc_specify */\n\n/* Set the FDC's data transfer rate on behalf of the specified drive.\n * NOTE: with 82072/82077 FDCs, changing the data rate requires a reissue\n * of the specify command (i.e. using the fdc_specify function).\n */\nstatic int fdc_dtr(void)\n{\n\t/* If data rate not already set to desired value, set it. */\n\tif ((raw_cmd->rate & 3) == FDCS->dtr)\n\t\treturn 0;\n\n\t/* Set dtr */\n\tfd_outb(raw_cmd->rate & 3, FD_DCR);\n\n\t/* TODO: some FDC/drive combinations (C&T 82C711 with TEAC 1.2MB)\n\t * need a stabilization period of several milliseconds to be\n\t * enforced after data rate changes before R/W operations.\n\t * Pause 5 msec to avoid trouble. (Needs to be 2 jiffies)\n\t */\n\tFDCS->dtr = raw_cmd->rate & 3;\n\treturn fd_wait_for_completion(jiffies + 2UL * HZ / 100, floppy_ready);\n}\t\t\t\t/* fdc_dtr */\n\nstatic void tell_sector(void)\n{\n\tpr_cont(\": track %d, head %d, sector %d, size %d\",\n\t\tR_TRACK, R_HEAD, R_SECTOR, R_SIZECODE);\n}\t\t\t\t/* tell_sector */\n\nstatic void print_errors(void)\n{\n\tDPRINT(\"\");\n\tif (ST0 & ST0_ECE) {\n\t\tpr_cont(\"Recalibrate failed!\");\n\t} else if (ST2 & ST2_CRC) {\n\t\tpr_cont(\"data CRC error\");\n\t\ttell_sector();\n\t} else if (ST1 & ST1_CRC) {\n\t\tpr_cont(\"CRC error\");\n\t\ttell_sector();\n\t} else if ((ST1 & (ST1_MAM | ST1_ND)) ||\n\t\t   (ST2 & ST2_MAM)) {\n\t\tif (!probing) {\n\t\t\tpr_cont(\"sector not found\");\n\t\t\ttell_sector();\n\t\t} else\n\t\t\tpr_cont(\"probe failed...\");\n\t} else if (ST2 & ST2_WC) {\t/* seek error */\n\t\tpr_cont(\"wrong cylinder\");\n\t} else if (ST2 & ST2_BC) {\t/* cylinder marked as bad */\n\t\tpr_cont(\"bad cylinder\");\n\t} else {\n\t\tpr_cont(\"unknown error. ST[0..2] are: 0x%x 0x%x 0x%x\",\n\t\t\tST0, ST1, ST2);\n\t\ttell_sector();\n\t}\n\tpr_cont(\"\\n\");\n}\n\n/*\n * OK, this error interpreting routine is called after a\n * DMA read/write has succeeded\n * or failed, so we check the results, and copy any buffers.\n * hhb: Added better error reporting.\n * ak: Made this into a separate routine.\n */\nstatic int interpret_errors(void)\n{\n\tchar bad;\n\n\tif (inr != 7) {\n\t\tDPRINT(\"-- FDC reply error\\n\");\n\t\tFDCS->reset = 1;\n\t\treturn 1;\n\t}\n\n\t/* check IC to find cause of interrupt */\n\tswitch (ST0 & ST0_INTR) {\n\tcase 0x40:\t\t/* error occurred during command execution */\n\t\tif (ST1 & ST1_EOC)\n\t\t\treturn 0;\t/* occurs with pseudo-DMA */\n\t\tbad = 1;\n\t\tif (ST1 & ST1_WP) {\n\t\t\tDPRINT(\"Drive is write protected\\n\");\n\t\t\tclear_bit(FD_DISK_WRITABLE_BIT, &DRS->flags);\n\t\t\tcont->done(0);\n\t\t\tbad = 2;\n\t\t} else if (ST1 & ST1_ND) {\n\t\t\tset_bit(FD_NEED_TWADDLE_BIT, &DRS->flags);\n\t\t} else if (ST1 & ST1_OR) {\n\t\t\tif (DP->flags & FTD_MSG)\n\t\t\t\tDPRINT(\"Over/Underrun - retrying\\n\");\n\t\t\tbad = 0;\n\t\t} else if (*errors >= DP->max_errors.reporting) {\n\t\t\tprint_errors();\n\t\t}\n\t\tif (ST2 & ST2_WC || ST2 & ST2_BC)\n\t\t\t/* wrong cylinder => recal */\n\t\t\tDRS->track = NEED_2_RECAL;\n\t\treturn bad;\n\tcase 0x80:\t\t/* invalid command given */\n\t\tDPRINT(\"Invalid FDC command given!\\n\");\n\t\tcont->done(0);\n\t\treturn 2;\n\tcase 0xc0:\n\t\tDPRINT(\"Abnormal termination caused by polling\\n\");\n\t\tcont->error();\n\t\treturn 2;\n\tdefault:\t\t/* (0) Normal command termination */\n\t\treturn 0;\n\t}\n}\n\n/*\n * This routine is called when everything should be correctly set up\n * for the transfer (i.e. floppy motor is on, the correct floppy is\n * selected, and the head is sitting on the right track).\n */\nstatic void setup_rw_floppy(void)\n{\n\tint i;\n\tint r;\n\tint flags;\n\tunsigned long ready_date;\n\tvoid (*function)(void);\n\n\tflags = raw_cmd->flags;\n\tif (flags & (FD_RAW_READ | FD_RAW_WRITE))\n\t\tflags |= FD_RAW_INTR;\n\n\tif ((flags & FD_RAW_SPIN) && !(flags & FD_RAW_NO_MOTOR)) {\n\t\tready_date = DRS->spinup_date + DP->spinup;\n\t\t/* If spinup will take a long time, rerun scandrives\n\t\t * again just before spinup completion. Beware that\n\t\t * after scandrives, we must again wait for selection.\n\t\t */\n\t\tif (time_after(ready_date, jiffies + DP->select_delay)) {\n\t\t\tready_date -= DP->select_delay;\n\t\t\tfunction = floppy_start;\n\t\t} else\n\t\t\tfunction = setup_rw_floppy;\n\n\t\t/* wait until the floppy is spinning fast enough */\n\t\tif (fd_wait_for_completion(ready_date, function))\n\t\t\treturn;\n\t}\n\tif ((flags & FD_RAW_READ) || (flags & FD_RAW_WRITE))\n\t\tsetup_DMA();\n\n\tif (flags & FD_RAW_INTR)\n\t\tdo_floppy = main_command_interrupt;\n\n\tr = 0;\n\tfor (i = 0; i < raw_cmd->cmd_count; i++)\n\t\tr |= output_byte(raw_cmd->cmd[i]);\n\n\tdebugt(__func__, \"rw_command\");\n\n\tif (r) {\n\t\tcont->error();\n\t\treset_fdc();\n\t\treturn;\n\t}\n\n\tif (!(flags & FD_RAW_INTR)) {\n\t\tinr = result();\n\t\tcont->interrupt();\n\t} else if (flags & FD_RAW_NEED_DISK)\n\t\tfd_watchdog();\n}\n\nstatic int blind_seek;\n\n/*\n * This is the routine called after every seek (or recalibrate) interrupt\n * from the floppy controller.\n */\nstatic void seek_interrupt(void)\n{\n\tdebugt(__func__, \"\");\n\tif (inr != 2 || (ST0 & 0xF8) != 0x20) {\n\t\tDPRINT(\"seek failed\\n\");\n\t\tDRS->track = NEED_2_RECAL;\n\t\tcont->error();\n\t\tcont->redo();\n\t\treturn;\n\t}\n\tif (DRS->track >= 0 && DRS->track != ST1 && !blind_seek) {\n\t\tdebug_dcl(DP->flags,\n\t\t\t  \"clearing NEWCHANGE flag because of effective seek\\n\");\n\t\tdebug_dcl(DP->flags, \"jiffies=%lu\\n\", jiffies);\n\t\tclear_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags);\n\t\t\t\t\t/* effective seek */\n\t\tDRS->select_date = jiffies;\n\t}\n\tDRS->track = ST1;\n\tfloppy_ready();\n}\n\nstatic void check_wp(void)\n{\n\tif (test_bit(FD_VERIFY_BIT, &DRS->flags)) {\n\t\t\t\t\t/* check write protection */\n\t\toutput_byte(FD_GETSTATUS);\n\t\toutput_byte(UNIT(current_drive));\n\t\tif (result() != 1) {\n\t\t\tFDCS->reset = 1;\n\t\t\treturn;\n\t\t}\n\t\tclear_bit(FD_VERIFY_BIT, &DRS->flags);\n\t\tclear_bit(FD_NEED_TWADDLE_BIT, &DRS->flags);\n\t\tdebug_dcl(DP->flags,\n\t\t\t  \"checking whether disk is write protected\\n\");\n\t\tdebug_dcl(DP->flags, \"wp=%x\\n\", ST3 & 0x40);\n\t\tif (!(ST3 & 0x40))\n\t\t\tset_bit(FD_DISK_WRITABLE_BIT, &DRS->flags);\n\t\telse\n\t\t\tclear_bit(FD_DISK_WRITABLE_BIT, &DRS->flags);\n\t}\n}\n\nstatic void seek_floppy(void)\n{\n\tint track;\n\n\tblind_seek = 0;\n\n\tdebug_dcl(DP->flags, \"calling disk change from %s\\n\", __func__);\n\n\tif (!test_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags) &&\n\t    disk_change(current_drive) && (raw_cmd->flags & FD_RAW_NEED_DISK)) {\n\t\t/* the media changed flag should be cleared after the seek.\n\t\t * If it isn't, this means that there is really no disk in\n\t\t * the drive.\n\t\t */\n\t\tset_bit(FD_DISK_CHANGED_BIT, &DRS->flags);\n\t\tcont->done(0);\n\t\tcont->redo();\n\t\treturn;\n\t}\n\tif (DRS->track <= NEED_1_RECAL) {\n\t\trecalibrate_floppy();\n\t\treturn;\n\t} else if (test_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags) &&\n\t\t   (raw_cmd->flags & FD_RAW_NEED_DISK) &&\n\t\t   (DRS->track <= NO_TRACK || DRS->track == raw_cmd->track)) {\n\t\t/* we seek to clear the media-changed condition. Does anybody\n\t\t * know a more elegant way, which works on all drives? */\n\t\tif (raw_cmd->track)\n\t\t\ttrack = raw_cmd->track - 1;\n\t\telse {\n\t\t\tif (DP->flags & FD_SILENT_DCL_CLEAR) {\n\t\t\t\tset_dor(fdc, ~(0x10 << UNIT(current_drive)), 0);\n\t\t\t\tblind_seek = 1;\n\t\t\t\traw_cmd->flags |= FD_RAW_NEED_SEEK;\n\t\t\t}\n\t\t\ttrack = 1;\n\t\t}\n\t} else {\n\t\tcheck_wp();\n\t\tif (raw_cmd->track != DRS->track &&\n\t\t    (raw_cmd->flags & FD_RAW_NEED_SEEK))\n\t\t\ttrack = raw_cmd->track;\n\t\telse {\n\t\t\tsetup_rw_floppy();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdo_floppy = seek_interrupt;\n\toutput_byte(FD_SEEK);\n\toutput_byte(UNIT(current_drive));\n\tif (output_byte(track) < 0) {\n\t\treset_fdc();\n\t\treturn;\n\t}\n\tdebugt(__func__, \"\");\n}\n\nstatic void recal_interrupt(void)\n{\n\tdebugt(__func__, \"\");\n\tif (inr != 2)\n\t\tFDCS->reset = 1;\n\telse if (ST0 & ST0_ECE) {\n\t\tswitch (DRS->track) {\n\t\tcase NEED_1_RECAL:\n\t\t\tdebugt(__func__, \"need 1 recal\");\n\t\t\t/* after a second recalibrate, we still haven't\n\t\t\t * reached track 0. Probably no drive. Raise an\n\t\t\t * error, as failing immediately might upset\n\t\t\t * computers possessed by the Devil :-) */\n\t\t\tcont->error();\n\t\t\tcont->redo();\n\t\t\treturn;\n\t\tcase NEED_2_RECAL:\n\t\t\tdebugt(__func__, \"need 2 recal\");\n\t\t\t/* If we already did a recalibrate,\n\t\t\t * and we are not at track 0, this\n\t\t\t * means we have moved. (The only way\n\t\t\t * not to move at recalibration is to\n\t\t\t * be already at track 0.) Clear the\n\t\t\t * new change flag */\n\t\t\tdebug_dcl(DP->flags,\n\t\t\t\t  \"clearing NEWCHANGE flag because of second recalibrate\\n\");\n\n\t\t\tclear_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags);\n\t\t\tDRS->select_date = jiffies;\n\t\t\t/* fall through */\n\t\tdefault:\n\t\t\tdebugt(__func__, \"default\");\n\t\t\t/* Recalibrate moves the head by at\n\t\t\t * most 80 steps. If after one\n\t\t\t * recalibrate we don't have reached\n\t\t\t * track 0, this might mean that we\n\t\t\t * started beyond track 80.  Try\n\t\t\t * again.  */\n\t\t\tDRS->track = NEED_1_RECAL;\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tDRS->track = ST1;\n\tfloppy_ready();\n}\n\nstatic void print_result(char *message, int inr)\n{\n\tint i;\n\n\tDPRINT(\"%s \", message);\n\tif (inr >= 0)\n\t\tfor (i = 0; i < inr; i++)\n\t\t\tpr_cont(\"repl[%d]=%x \", i, reply_buffer[i]);\n\tpr_cont(\"\\n\");\n}\n\n/* interrupt handler. Note that this can be called externally on the Sparc */\nirqreturn_t floppy_interrupt(int irq, void *dev_id)\n{\n\tint do_print;\n\tunsigned long f;\n\tvoid (*handler)(void) = do_floppy;\n\n\tlasthandler = handler;\n\tinterruptjiffies = jiffies;\n\n\tf = claim_dma_lock();\n\tfd_disable_dma();\n\trelease_dma_lock(f);\n\n\tdo_floppy = NULL;\n\tif (fdc >= N_FDC || FDCS->address == -1) {\n\t\t/* we don't even know which FDC is the culprit */\n\t\tpr_info(\"DOR0=%x\\n\", fdc_state[0].dor);\n\t\tpr_info(\"floppy interrupt on bizarre fdc %d\\n\", fdc);\n\t\tpr_info(\"handler=%ps\\n\", handler);\n\t\tis_alive(__func__, \"bizarre fdc\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tFDCS->reset = 0;\n\t/* We have to clear the reset flag here, because apparently on boxes\n\t * with level triggered interrupts (PS/2, Sparc, ...), it is needed to\n\t * emit SENSEI's to clear the interrupt line. And FDCS->reset blocks the\n\t * emission of the SENSEI's.\n\t * It is OK to emit floppy commands because we are in an interrupt\n\t * handler here, and thus we have to fear no interference of other\n\t * activity.\n\t */\n\n\tdo_print = !handler && print_unex && initialized;\n\n\tinr = result();\n\tif (do_print)\n\t\tprint_result(\"unexpected interrupt\", inr);\n\tif (inr == 0) {\n\t\tint max_sensei = 4;\n\t\tdo {\n\t\t\toutput_byte(FD_SENSEI);\n\t\t\tinr = result();\n\t\t\tif (do_print)\n\t\t\t\tprint_result(\"sensei\", inr);\n\t\t\tmax_sensei--;\n\t\t} while ((ST0 & 0x83) != UNIT(current_drive) &&\n\t\t\t inr == 2 && max_sensei);\n\t}\n\tif (!handler) {\n\t\tFDCS->reset = 1;\n\t\treturn IRQ_NONE;\n\t}\n\tschedule_bh(handler);\n\tis_alive(__func__, \"normal interrupt end\");\n\n\t/* FIXME! Was it really for us? */\n\treturn IRQ_HANDLED;\n}\n\nstatic void recalibrate_floppy(void)\n{\n\tdebugt(__func__, \"\");\n\tdo_floppy = recal_interrupt;\n\toutput_byte(FD_RECALIBRATE);\n\tif (output_byte(UNIT(current_drive)) < 0)\n\t\treset_fdc();\n}\n\n/*\n * Must do 4 FD_SENSEIs after reset because of ``drive polling''.\n */\nstatic void reset_interrupt(void)\n{\n\tdebugt(__func__, \"\");\n\tresult();\t\t/* get the status ready for set_fdc */\n\tif (FDCS->reset) {\n\t\tpr_info(\"reset set in interrupt, calling %ps\\n\", cont->error);\n\t\tcont->error();\t/* a reset just after a reset. BAD! */\n\t}\n\tcont->redo();\n}\n\n/*\n * reset is done by pulling bit 2 of DOR low for a while (old FDCs),\n * or by setting the self clearing bit 7 of STATUS (newer FDCs)\n */\nstatic void reset_fdc(void)\n{\n\tunsigned long flags;\n\n\tdo_floppy = reset_interrupt;\n\tFDCS->reset = 0;\n\treset_fdc_info(0);\n\n\t/* Pseudo-DMA may intercept 'reset finished' interrupt.  */\n\t/* Irrelevant for systems with true DMA (i386).          */\n\n\tflags = claim_dma_lock();\n\tfd_disable_dma();\n\trelease_dma_lock(flags);\n\n\tif (FDCS->version >= FDC_82072A)\n\t\tfd_outb(0x80 | (FDCS->dtr & 3), FD_STATUS);\n\telse {\n\t\tfd_outb(FDCS->dor & ~0x04, FD_DOR);\n\t\tudelay(FD_RESET_DELAY);\n\t\tfd_outb(FDCS->dor, FD_DOR);\n\t}\n}\n\nstatic void show_floppy(void)\n{\n\tint i;\n\n\tpr_info(\"\\n\");\n\tpr_info(\"floppy driver state\\n\");\n\tpr_info(\"-------------------\\n\");\n\tpr_info(\"now=%lu last interrupt=%lu diff=%lu last called handler=%ps\\n\",\n\t\tjiffies, interruptjiffies, jiffies - interruptjiffies,\n\t\tlasthandler);\n\n\tpr_info(\"timeout_message=%s\\n\", timeout_message);\n\tpr_info(\"last output bytes:\\n\");\n\tfor (i = 0; i < OLOGSIZE; i++)\n\t\tpr_info(\"%2x %2x %lu\\n\",\n\t\t\toutput_log[(i + output_log_pos) % OLOGSIZE].data,\n\t\t\toutput_log[(i + output_log_pos) % OLOGSIZE].status,\n\t\t\toutput_log[(i + output_log_pos) % OLOGSIZE].jiffies);\n\tpr_info(\"last result at %lu\\n\", resultjiffies);\n\tpr_info(\"last redo_fd_request at %lu\\n\", lastredo);\n\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_NONE, 16, 1,\n\t\t       reply_buffer, resultsize, true);\n\n\tpr_info(\"status=%x\\n\", fd_inb(FD_STATUS));\n\tpr_info(\"fdc_busy=%lu\\n\", fdc_busy);\n\tif (do_floppy)\n\t\tpr_info(\"do_floppy=%ps\\n\", do_floppy);\n\tif (work_pending(&floppy_work))\n\t\tpr_info(\"floppy_work.func=%ps\\n\", floppy_work.func);\n\tif (delayed_work_pending(&fd_timer))\n\t\tpr_info(\"delayed work.function=%p expires=%ld\\n\",\n\t\t       fd_timer.work.func,\n\t\t       fd_timer.timer.expires - jiffies);\n\tif (delayed_work_pending(&fd_timeout))\n\t\tpr_info(\"timer_function=%p expires=%ld\\n\",\n\t\t       fd_timeout.work.func,\n\t\t       fd_timeout.timer.expires - jiffies);\n\n\tpr_info(\"cont=%p\\n\", cont);\n\tpr_info(\"current_req=%p\\n\", current_req);\n\tpr_info(\"command_status=%d\\n\", command_status);\n\tpr_info(\"\\n\");\n}\n\nstatic void floppy_shutdown(struct work_struct *arg)\n{\n\tunsigned long flags;\n\n\tif (initialized)\n\t\tshow_floppy();\n\tcancel_activity();\n\n\tflags = claim_dma_lock();\n\tfd_disable_dma();\n\trelease_dma_lock(flags);\n\n\t/* avoid dma going to a random drive after shutdown */\n\n\tif (initialized)\n\t\tDPRINT(\"floppy timeout called\\n\");\n\tFDCS->reset = 1;\n\tif (cont) {\n\t\tcont->done(0);\n\t\tcont->redo();\t/* this will recall reset when needed */\n\t} else {\n\t\tpr_info(\"no cont in shutdown!\\n\");\n\t\tprocess_fd_request();\n\t}\n\tis_alive(__func__, \"\");\n}\n\n/* start motor, check media-changed condition and write protection */\nstatic int start_motor(void (*function)(void))\n{\n\tint mask;\n\tint data;\n\n\tmask = 0xfc;\n\tdata = UNIT(current_drive);\n\tif (!(raw_cmd->flags & FD_RAW_NO_MOTOR)) {\n\t\tif (!(FDCS->dor & (0x10 << UNIT(current_drive)))) {\n\t\t\tset_debugt();\n\t\t\t/* no read since this drive is running */\n\t\t\tDRS->first_read_date = 0;\n\t\t\t/* note motor start time if motor is not yet running */\n\t\t\tDRS->spinup_date = jiffies;\n\t\t\tdata |= (0x10 << UNIT(current_drive));\n\t\t}\n\t} else if (FDCS->dor & (0x10 << UNIT(current_drive)))\n\t\tmask &= ~(0x10 << UNIT(current_drive));\n\n\t/* starts motor and selects floppy */\n\tdel_timer(motor_off_timer + current_drive);\n\tset_dor(fdc, mask, data);\n\n\t/* wait_for_completion also schedules reset if needed. */\n\treturn fd_wait_for_completion(DRS->select_date + DP->select_delay,\n\t\t\t\t      function);\n}\n\nstatic void floppy_ready(void)\n{\n\tif (FDCS->reset) {\n\t\treset_fdc();\n\t\treturn;\n\t}\n\tif (start_motor(floppy_ready))\n\t\treturn;\n\tif (fdc_dtr())\n\t\treturn;\n\n\tdebug_dcl(DP->flags, \"calling disk change from floppy_ready\\n\");\n\tif (!(raw_cmd->flags & FD_RAW_NO_MOTOR) &&\n\t    disk_change(current_drive) && !DP->select_delay)\n\t\ttwaddle();\t/* this clears the dcl on certain\n\t\t\t\t * drive/controller combinations */\n\n#ifdef fd_chose_dma_mode\n\tif ((raw_cmd->flags & FD_RAW_READ) || (raw_cmd->flags & FD_RAW_WRITE)) {\n\t\tunsigned long flags = claim_dma_lock();\n\t\tfd_chose_dma_mode(raw_cmd->kernel_data, raw_cmd->length);\n\t\trelease_dma_lock(flags);\n\t}\n#endif\n\n\tif (raw_cmd->flags & (FD_RAW_NEED_SEEK | FD_RAW_NEED_DISK)) {\n\t\tperpendicular_mode();\n\t\tfdc_specify();\t/* must be done here because of hut, hlt ... */\n\t\tseek_floppy();\n\t} else {\n\t\tif ((raw_cmd->flags & FD_RAW_READ) ||\n\t\t    (raw_cmd->flags & FD_RAW_WRITE))\n\t\t\tfdc_specify();\n\t\tsetup_rw_floppy();\n\t}\n}\n\nstatic void floppy_start(void)\n{\n\treschedule_timeout(current_reqD, \"floppy start\");\n\n\tscandrives();\n\tdebug_dcl(DP->flags, \"setting NEWCHANGE in floppy_start\\n\");\n\tset_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags);\n\tfloppy_ready();\n}\n\n/*\n * ========================================================================\n * here ends the bottom half. Exported routines are:\n * floppy_start, floppy_off, floppy_ready, lock_fdc, unlock_fdc, set_fdc,\n * start_motor, reset_fdc, reset_fdc_info, interpret_errors.\n * Initialization also uses output_byte, result, set_dor, floppy_interrupt\n * and set_dor.\n * ========================================================================\n */\n/*\n * General purpose continuations.\n * ==============================\n */\n\nstatic void do_wakeup(void)\n{\n\treschedule_timeout(MAXTIMEOUT, \"do wakeup\");\n\tcont = NULL;\n\tcommand_status += 2;\n\twake_up(&command_done);\n}\n\nstatic const struct cont_t wakeup_cont = {\n\t.interrupt\t= empty,\n\t.redo\t\t= do_wakeup,\n\t.error\t\t= empty,\n\t.done\t\t= (done_f)empty\n};\n\nstatic const struct cont_t intr_cont = {\n\t.interrupt\t= empty,\n\t.redo\t\t= process_fd_request,\n\t.error\t\t= empty,\n\t.done\t\t= (done_f)empty\n};\n\nstatic int wait_til_done(void (*handler)(void), bool interruptible)\n{\n\tint ret;\n\n\tschedule_bh(handler);\n\n\tif (interruptible)\n\t\twait_event_interruptible(command_done, command_status >= 2);\n\telse\n\t\twait_event(command_done, command_status >= 2);\n\n\tif (command_status < 2) {\n\t\tcancel_activity();\n\t\tcont = &intr_cont;\n\t\treset_fdc();\n\t\treturn -EINTR;\n\t}\n\n\tif (FDCS->reset)\n\t\tcommand_status = FD_COMMAND_ERROR;\n\tif (command_status == FD_COMMAND_OKAY)\n\t\tret = 0;\n\telse\n\t\tret = -EIO;\n\tcommand_status = FD_COMMAND_NONE;\n\treturn ret;\n}\n\nstatic void generic_done(int result)\n{\n\tcommand_status = result;\n\tcont = &wakeup_cont;\n}\n\nstatic void generic_success(void)\n{\n\tcont->done(1);\n}\n\nstatic void generic_failure(void)\n{\n\tcont->done(0);\n}\n\nstatic void success_and_wakeup(void)\n{\n\tgeneric_success();\n\tcont->redo();\n}\n\n/*\n * formatting and rw support.\n * ==========================\n */\n\nstatic int next_valid_format(void)\n{\n\tint probed_format;\n\n\tprobed_format = DRS->probed_format;\n\twhile (1) {\n\t\tif (probed_format >= 8 || !DP->autodetect[probed_format]) {\n\t\t\tDRS->probed_format = 0;\n\t\t\treturn 1;\n\t\t}\n\t\tif (floppy_type[DP->autodetect[probed_format]].sect) {\n\t\t\tDRS->probed_format = probed_format;\n\t\t\treturn 0;\n\t\t}\n\t\tprobed_format++;\n\t}\n}\n\nstatic void bad_flp_intr(void)\n{\n\tint err_count;\n\n\tif (probing) {\n\t\tDRS->probed_format++;\n\t\tif (!next_valid_format())\n\t\t\treturn;\n\t}\n\terr_count = ++(*errors);\n\tINFBOUND(DRWE->badness, err_count);\n\tif (err_count > DP->max_errors.abort)\n\t\tcont->done(0);\n\tif (err_count > DP->max_errors.reset)\n\t\tFDCS->reset = 1;\n\telse if (err_count > DP->max_errors.recal)\n\t\tDRS->track = NEED_2_RECAL;\n}\n\nstatic void set_floppy(int drive)\n{\n\tint type = ITYPE(UDRS->fd_device);\n\n\tif (type)\n\t\t_floppy = floppy_type + type;\n\telse\n\t\t_floppy = current_type[drive];\n}\n\n/*\n * formatting support.\n * ===================\n */\nstatic void format_interrupt(void)\n{\n\tswitch (interpret_errors()) {\n\tcase 1:\n\t\tcont->error();\n\tcase 2:\n\t\tbreak;\n\tcase 0:\n\t\tcont->done(1);\n\t}\n\tcont->redo();\n}\n\n#define FM_MODE(x, y) ((y) & ~(((x)->rate & 0x80) >> 1))\n#define CT(x) ((x) | 0xc0)\n\nstatic void setup_format_params(int track)\n{\n\tint n;\n\tint il;\n\tint count;\n\tint head_shift;\n\tint track_shift;\n\tstruct fparm {\n\t\tunsigned char track, head, sect, size;\n\t} *here = (struct fparm *)floppy_track_buffer;\n\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->track = track;\n\n\traw_cmd->flags = (FD_RAW_WRITE | FD_RAW_INTR | FD_RAW_SPIN |\n\t\t\t  FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK);\n\traw_cmd->rate = _floppy->rate & 0x43;\n\traw_cmd->cmd_count = NR_F;\n\tCOMMAND = FM_MODE(_floppy, FD_FORMAT);\n\tDR_SELECT = UNIT(current_drive) + PH_HEAD(_floppy, format_req.head);\n\tF_SIZECODE = FD_SIZECODE(_floppy);\n\tF_SECT_PER_TRACK = _floppy->sect << 2 >> F_SIZECODE;\n\tF_GAP = _floppy->fmt_gap;\n\tF_FILL = FD_FILL_BYTE;\n\n\traw_cmd->kernel_data = floppy_track_buffer;\n\traw_cmd->length = 4 * F_SECT_PER_TRACK;\n\n\t/* allow for about 30ms for data transport per track */\n\thead_shift = (F_SECT_PER_TRACK + 5) / 6;\n\n\t/* a ``cylinder'' is two tracks plus a little stepping time */\n\ttrack_shift = 2 * head_shift + 3;\n\n\t/* position of logical sector 1 on this track */\n\tn = (track_shift * format_req.track + head_shift * format_req.head)\n\t    % F_SECT_PER_TRACK;\n\n\t/* determine interleave */\n\til = 1;\n\tif (_floppy->fmt_gap < 0x22)\n\t\til++;\n\n\t/* initialize field */\n\tfor (count = 0; count < F_SECT_PER_TRACK; ++count) {\n\t\there[count].track = format_req.track;\n\t\there[count].head = format_req.head;\n\t\there[count].sect = 0;\n\t\there[count].size = F_SIZECODE;\n\t}\n\t/* place logical sectors */\n\tfor (count = 1; count <= F_SECT_PER_TRACK; ++count) {\n\t\there[n].sect = count;\n\t\tn = (n + il) % F_SECT_PER_TRACK;\n\t\tif (here[n].sect) {\t/* sector busy, find next free sector */\n\t\t\t++n;\n\t\t\tif (n >= F_SECT_PER_TRACK) {\n\t\t\t\tn -= F_SECT_PER_TRACK;\n\t\t\t\twhile (here[n].sect)\n\t\t\t\t\t++n;\n\t\t\t}\n\t\t}\n\t}\n\tif (_floppy->stretch & FD_SECTBASEMASK) {\n\t\tfor (count = 0; count < F_SECT_PER_TRACK; count++)\n\t\t\there[count].sect += FD_SECTBASE(_floppy) - 1;\n\t}\n}\n\nstatic void redo_format(void)\n{\n\tbuffer_track = -1;\n\tsetup_format_params(format_req.track << STRETCH(_floppy));\n\tfloppy_start();\n\tdebugt(__func__, \"queue format request\");\n}\n\nstatic const struct cont_t format_cont = {\n\t.interrupt\t= format_interrupt,\n\t.redo\t\t= redo_format,\n\t.error\t\t= bad_flp_intr,\n\t.done\t\t= generic_done\n};\n\nstatic int do_format(int drive, struct format_descr *tmp_format_req)\n{\n\tint ret;\n\n\tif (lock_fdc(drive))\n\t\treturn -EINTR;\n\n\tset_floppy(drive);\n\tif (!_floppy ||\n\t    _floppy->track > DP->tracks ||\n\t    tmp_format_req->track >= _floppy->track ||\n\t    tmp_format_req->head >= _floppy->head ||\n\t    (_floppy->sect << 2) % (1 << FD_SIZECODE(_floppy)) ||\n\t    !_floppy->fmt_gap) {\n\t\tprocess_fd_request();\n\t\treturn -EINVAL;\n\t}\n\tformat_req = *tmp_format_req;\n\tformat_errors = 0;\n\tcont = &format_cont;\n\terrors = &format_errors;\n\tret = wait_til_done(redo_format, true);\n\tif (ret == -EINTR)\n\t\treturn -EINTR;\n\tprocess_fd_request();\n\treturn ret;\n}\n\n/*\n * Buffer read/write and support\n * =============================\n */\n\nstatic void floppy_end_request(struct request *req, blk_status_t error)\n{\n\tunsigned int nr_sectors = current_count_sectors;\n\tunsigned int drive = (unsigned long)req->rq_disk->private_data;\n\n\t/* current_count_sectors can be zero if transfer failed */\n\tif (error)\n\t\tnr_sectors = blk_rq_cur_sectors(req);\n\tif (blk_update_request(req, error, nr_sectors << 9))\n\t\treturn;\n\t__blk_mq_end_request(req, error);\n\n\t/* We're done with the request */\n\tfloppy_off(drive);\n\tcurrent_req = NULL;\n}\n\n/* new request_done. Can handle physical sectors which are smaller than a\n * logical buffer */\nstatic void request_done(int uptodate)\n{\n\tstruct request *req = current_req;\n\tint block;\n\tchar msg[sizeof(\"request done \") + sizeof(int) * 3];\n\n\tprobing = 0;\n\tsnprintf(msg, sizeof(msg), \"request done %d\", uptodate);\n\treschedule_timeout(MAXTIMEOUT, msg);\n\n\tif (!req) {\n\t\tpr_info(\"floppy.c: no request in request_done\\n\");\n\t\treturn;\n\t}\n\n\tif (uptodate) {\n\t\t/* maintain values for invalidation on geometry\n\t\t * change */\n\t\tblock = current_count_sectors + blk_rq_pos(req);\n\t\tINFBOUND(DRS->maxblock, block);\n\t\tif (block > _floppy->sect)\n\t\t\tDRS->maxtrack = 1;\n\n\t\tfloppy_end_request(req, 0);\n\t} else {\n\t\tif (rq_data_dir(req) == WRITE) {\n\t\t\t/* record write error information */\n\t\t\tDRWE->write_errors++;\n\t\t\tif (DRWE->write_errors == 1) {\n\t\t\t\tDRWE->first_error_sector = blk_rq_pos(req);\n\t\t\t\tDRWE->first_error_generation = DRS->generation;\n\t\t\t}\n\t\t\tDRWE->last_error_sector = blk_rq_pos(req);\n\t\t\tDRWE->last_error_generation = DRS->generation;\n\t\t}\n\t\tfloppy_end_request(req, BLK_STS_IOERR);\n\t}\n}\n\n/* Interrupt handler evaluating the result of the r/w operation */\nstatic void rw_interrupt(void)\n{\n\tint eoc;\n\tint ssize;\n\tint heads;\n\tint nr_sectors;\n\n\tif (R_HEAD >= 2) {\n\t\t/* some Toshiba floppy controllers occasionnally seem to\n\t\t * return bogus interrupts after read/write operations, which\n\t\t * can be recognized by a bad head number (>= 2) */\n\t\treturn;\n\t}\n\n\tif (!DRS->first_read_date)\n\t\tDRS->first_read_date = jiffies;\n\n\tnr_sectors = 0;\n\tssize = DIV_ROUND_UP(1 << SIZECODE, 4);\n\n\tif (ST1 & ST1_EOC)\n\t\teoc = 1;\n\telse\n\t\teoc = 0;\n\n\tif (COMMAND & 0x80)\n\t\theads = 2;\n\telse\n\t\theads = 1;\n\n\tnr_sectors = (((R_TRACK - TRACK) * heads +\n\t\t       R_HEAD - HEAD) * SECT_PER_TRACK +\n\t\t      R_SECTOR - SECTOR + eoc) << SIZECODE >> 2;\n\n\tif (nr_sectors / ssize >\n\t    DIV_ROUND_UP(in_sector_offset + current_count_sectors, ssize)) {\n\t\tDPRINT(\"long rw: %x instead of %lx\\n\",\n\t\t       nr_sectors, current_count_sectors);\n\t\tpr_info(\"rs=%d s=%d\\n\", R_SECTOR, SECTOR);\n\t\tpr_info(\"rh=%d h=%d\\n\", R_HEAD, HEAD);\n\t\tpr_info(\"rt=%d t=%d\\n\", R_TRACK, TRACK);\n\t\tpr_info(\"heads=%d eoc=%d\\n\", heads, eoc);\n\t\tpr_info(\"spt=%d st=%d ss=%d\\n\",\n\t\t\tSECT_PER_TRACK, fsector_t, ssize);\n\t\tpr_info(\"in_sector_offset=%d\\n\", in_sector_offset);\n\t}\n\n\tnr_sectors -= in_sector_offset;\n\tINFBOUND(nr_sectors, 0);\n\tSUPBOUND(current_count_sectors, nr_sectors);\n\n\tswitch (interpret_errors()) {\n\tcase 2:\n\t\tcont->redo();\n\t\treturn;\n\tcase 1:\n\t\tif (!current_count_sectors) {\n\t\t\tcont->error();\n\t\t\tcont->redo();\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase 0:\n\t\tif (!current_count_sectors) {\n\t\t\tcont->redo();\n\t\t\treturn;\n\t\t}\n\t\tcurrent_type[current_drive] = _floppy;\n\t\tfloppy_sizes[TOMINOR(current_drive)] = _floppy->size;\n\t\tbreak;\n\t}\n\n\tif (probing) {\n\t\tif (DP->flags & FTD_MSG)\n\t\t\tDPRINT(\"Auto-detected floppy type %s in fd%d\\n\",\n\t\t\t       _floppy->name, current_drive);\n\t\tcurrent_type[current_drive] = _floppy;\n\t\tfloppy_sizes[TOMINOR(current_drive)] = _floppy->size;\n\t\tprobing = 0;\n\t}\n\n\tif (CT(COMMAND) != FD_READ ||\n\t    raw_cmd->kernel_data == bio_data(current_req->bio)) {\n\t\t/* transfer directly from buffer */\n\t\tcont->done(1);\n\t} else if (CT(COMMAND) == FD_READ) {\n\t\tbuffer_track = raw_cmd->track;\n\t\tbuffer_drive = current_drive;\n\t\tINFBOUND(buffer_max, nr_sectors + fsector_t);\n\t}\n\tcont->redo();\n}\n\n/* Compute maximal contiguous buffer size. */\nstatic int buffer_chain_size(void)\n{\n\tstruct bio_vec bv;\n\tint size;\n\tstruct req_iterator iter;\n\tchar *base;\n\n\tbase = bio_data(current_req->bio);\n\tsize = 0;\n\n\trq_for_each_segment(bv, current_req, iter) {\n\t\tif (page_address(bv.bv_page) + bv.bv_offset != base + size)\n\t\t\tbreak;\n\n\t\tsize += bv.bv_len;\n\t}\n\n\treturn size >> 9;\n}\n\n/* Compute the maximal transfer size */\nstatic int transfer_size(int ssize, int max_sector, int max_size)\n{\n\tSUPBOUND(max_sector, fsector_t + max_size);\n\n\t/* alignment */\n\tmax_sector -= (max_sector % _floppy->sect) % ssize;\n\n\t/* transfer size, beginning not aligned */\n\tcurrent_count_sectors = max_sector - fsector_t;\n\n\treturn max_sector;\n}\n\n/*\n * Move data from/to the track buffer to/from the buffer cache.\n */\nstatic void copy_buffer(int ssize, int max_sector, int max_sector_2)\n{\n\tint remaining;\t\t/* number of transferred 512-byte sectors */\n\tstruct bio_vec bv;\n\tchar *buffer;\n\tchar *dma_buffer;\n\tint size;\n\tstruct req_iterator iter;\n\n\tmax_sector = transfer_size(ssize,\n\t\t\t\t   min(max_sector, max_sector_2),\n\t\t\t\t   blk_rq_sectors(current_req));\n\n\tif (current_count_sectors <= 0 && CT(COMMAND) == FD_WRITE &&\n\t    buffer_max > fsector_t + blk_rq_sectors(current_req))\n\t\tcurrent_count_sectors = min_t(int, buffer_max - fsector_t,\n\t\t\t\t\t      blk_rq_sectors(current_req));\n\n\tremaining = current_count_sectors << 9;\n\tif (remaining > blk_rq_bytes(current_req) && CT(COMMAND) == FD_WRITE) {\n\t\tDPRINT(\"in copy buffer\\n\");\n\t\tpr_info(\"current_count_sectors=%ld\\n\", current_count_sectors);\n\t\tpr_info(\"remaining=%d\\n\", remaining >> 9);\n\t\tpr_info(\"current_req->nr_sectors=%u\\n\",\n\t\t\tblk_rq_sectors(current_req));\n\t\tpr_info(\"current_req->current_nr_sectors=%u\\n\",\n\t\t\tblk_rq_cur_sectors(current_req));\n\t\tpr_info(\"max_sector=%d\\n\", max_sector);\n\t\tpr_info(\"ssize=%d\\n\", ssize);\n\t}\n\n\tbuffer_max = max(max_sector, buffer_max);\n\n\tdma_buffer = floppy_track_buffer + ((fsector_t - buffer_min) << 9);\n\n\tsize = blk_rq_cur_bytes(current_req);\n\n\trq_for_each_segment(bv, current_req, iter) {\n\t\tif (!remaining)\n\t\t\tbreak;\n\n\t\tsize = bv.bv_len;\n\t\tSUPBOUND(size, remaining);\n\n\t\tbuffer = page_address(bv.bv_page) + bv.bv_offset;\n\t\tif (dma_buffer + size >\n\t\t    floppy_track_buffer + (max_buffer_sectors << 10) ||\n\t\t    dma_buffer < floppy_track_buffer) {\n\t\t\tDPRINT(\"buffer overrun in copy buffer %d\\n\",\n\t\t\t       (int)((floppy_track_buffer - dma_buffer) >> 9));\n\t\t\tpr_info(\"fsector_t=%d buffer_min=%d\\n\",\n\t\t\t\tfsector_t, buffer_min);\n\t\t\tpr_info(\"current_count_sectors=%ld\\n\",\n\t\t\t\tcurrent_count_sectors);\n\t\t\tif (CT(COMMAND) == FD_READ)\n\t\t\t\tpr_info(\"read\\n\");\n\t\t\tif (CT(COMMAND) == FD_WRITE)\n\t\t\t\tpr_info(\"write\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (((unsigned long)buffer) % 512)\n\t\t\tDPRINT(\"%p buffer not aligned\\n\", buffer);\n\n\t\tif (CT(COMMAND) == FD_READ)\n\t\t\tmemcpy(buffer, dma_buffer, size);\n\t\telse\n\t\t\tmemcpy(dma_buffer, buffer, size);\n\n\t\tremaining -= size;\n\t\tdma_buffer += size;\n\t}\n\tif (remaining) {\n\t\tif (remaining > 0)\n\t\t\tmax_sector -= remaining >> 9;\n\t\tDPRINT(\"weirdness: remaining %d\\n\", remaining >> 9);\n\t}\n}\n\n/* work around a bug in pseudo DMA\n * (on some FDCs) pseudo DMA does not stop when the CPU stops\n * sending data.  Hence we need a different way to signal the\n * transfer length:  We use SECT_PER_TRACK.  Unfortunately, this\n * does not work with MT, hence we can only transfer one head at\n * a time\n */\nstatic void virtualdmabug_workaround(void)\n{\n\tint hard_sectors;\n\tint end_sector;\n\n\tif (CT(COMMAND) == FD_WRITE) {\n\t\tCOMMAND &= ~0x80;\t/* switch off multiple track mode */\n\n\t\thard_sectors = raw_cmd->length >> (7 + SIZECODE);\n\t\tend_sector = SECTOR + hard_sectors - 1;\n\t\tif (end_sector > SECT_PER_TRACK) {\n\t\t\tpr_info(\"too many sectors %d > %d\\n\",\n\t\t\t\tend_sector, SECT_PER_TRACK);\n\t\t\treturn;\n\t\t}\n\t\tSECT_PER_TRACK = end_sector;\n\t\t\t\t\t/* make sure SECT_PER_TRACK\n\t\t\t\t\t * points to end of transfer */\n\t}\n}\n\n/*\n * Formulate a read/write request.\n * this routine decides where to load the data (directly to buffer, or to\n * tmp floppy area), how much data to load (the size of the buffer, the whole\n * track, or a single sector)\n * All floppy_track_buffer handling goes in here. If we ever add track buffer\n * allocation on the fly, it should be done here. No other part should need\n * modification.\n */\n\nstatic int make_raw_rw_request(void)\n{\n\tint aligned_sector_t;\n\tint max_sector;\n\tint max_size;\n\tint tracksize;\n\tint ssize;\n\n\tif (WARN(max_buffer_sectors == 0, \"VFS: Block I/O scheduled on unopened device\\n\"))\n\t\treturn 0;\n\n\tset_fdc((long)current_req->rq_disk->private_data);\n\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->flags = FD_RAW_SPIN | FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK;\n\traw_cmd->cmd_count = NR_RW;\n\tif (rq_data_dir(current_req) == READ) {\n\t\traw_cmd->flags |= FD_RAW_READ;\n\t\tCOMMAND = FM_MODE(_floppy, FD_READ);\n\t} else if (rq_data_dir(current_req) == WRITE) {\n\t\traw_cmd->flags |= FD_RAW_WRITE;\n\t\tCOMMAND = FM_MODE(_floppy, FD_WRITE);\n\t} else {\n\t\tDPRINT(\"%s: unknown command\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tmax_sector = _floppy->sect * _floppy->head;\n\n\tTRACK = (int)blk_rq_pos(current_req) / max_sector;\n\tfsector_t = (int)blk_rq_pos(current_req) % max_sector;\n\tif (_floppy->track && TRACK >= _floppy->track) {\n\t\tif (blk_rq_cur_sectors(current_req) & 1) {\n\t\t\tcurrent_count_sectors = 1;\n\t\t\treturn 1;\n\t\t} else\n\t\t\treturn 0;\n\t}\n\tHEAD = fsector_t / _floppy->sect;\n\n\tif (((_floppy->stretch & (FD_SWAPSIDES | FD_SECTBASEMASK)) ||\n\t     test_bit(FD_NEED_TWADDLE_BIT, &DRS->flags)) &&\n\t    fsector_t < _floppy->sect)\n\t\tmax_sector = _floppy->sect;\n\n\t/* 2M disks have phantom sectors on the first track */\n\tif ((_floppy->rate & FD_2M) && (!TRACK) && (!HEAD)) {\n\t\tmax_sector = 2 * _floppy->sect / 3;\n\t\tif (fsector_t >= max_sector) {\n\t\t\tcurrent_count_sectors =\n\t\t\t    min_t(int, _floppy->sect - fsector_t,\n\t\t\t\t  blk_rq_sectors(current_req));\n\t\t\treturn 1;\n\t\t}\n\t\tSIZECODE = 2;\n\t} else\n\t\tSIZECODE = FD_SIZECODE(_floppy);\n\traw_cmd->rate = _floppy->rate & 0x43;\n\tif ((_floppy->rate & FD_2M) && (TRACK || HEAD) && raw_cmd->rate == 2)\n\t\traw_cmd->rate = 1;\n\n\tif (SIZECODE)\n\t\tSIZECODE2 = 0xff;\n\telse\n\t\tSIZECODE2 = 0x80;\n\traw_cmd->track = TRACK << STRETCH(_floppy);\n\tDR_SELECT = UNIT(current_drive) + PH_HEAD(_floppy, HEAD);\n\tGAP = _floppy->gap;\n\tssize = DIV_ROUND_UP(1 << SIZECODE, 4);\n\tSECT_PER_TRACK = _floppy->sect << 2 >> SIZECODE;\n\tSECTOR = ((fsector_t % _floppy->sect) << 2 >> SIZECODE) +\n\t    FD_SECTBASE(_floppy);\n\n\t/* tracksize describes the size which can be filled up with sectors\n\t * of size ssize.\n\t */\n\ttracksize = _floppy->sect - _floppy->sect % ssize;\n\tif (tracksize < _floppy->sect) {\n\t\tSECT_PER_TRACK++;\n\t\tif (tracksize <= fsector_t % _floppy->sect)\n\t\t\tSECTOR--;\n\n\t\t/* if we are beyond tracksize, fill up using smaller sectors */\n\t\twhile (tracksize <= fsector_t % _floppy->sect) {\n\t\t\twhile (tracksize + ssize > _floppy->sect) {\n\t\t\t\tSIZECODE--;\n\t\t\t\tssize >>= 1;\n\t\t\t}\n\t\t\tSECTOR++;\n\t\t\tSECT_PER_TRACK++;\n\t\t\ttracksize += ssize;\n\t\t}\n\t\tmax_sector = HEAD * _floppy->sect + tracksize;\n\t} else if (!TRACK && !HEAD && !(_floppy->rate & FD_2M) && probing) {\n\t\tmax_sector = _floppy->sect;\n\t} else if (!HEAD && CT(COMMAND) == FD_WRITE) {\n\t\t/* for virtual DMA bug workaround */\n\t\tmax_sector = _floppy->sect;\n\t}\n\n\tin_sector_offset = (fsector_t % _floppy->sect) % ssize;\n\taligned_sector_t = fsector_t - in_sector_offset;\n\tmax_size = blk_rq_sectors(current_req);\n\tif ((raw_cmd->track == buffer_track) &&\n\t    (current_drive == buffer_drive) &&\n\t    (fsector_t >= buffer_min) && (fsector_t < buffer_max)) {\n\t\t/* data already in track buffer */\n\t\tif (CT(COMMAND) == FD_READ) {\n\t\t\tcopy_buffer(1, max_sector, buffer_max);\n\t\t\treturn 1;\n\t\t}\n\t} else if (in_sector_offset || blk_rq_sectors(current_req) < ssize) {\n\t\tif (CT(COMMAND) == FD_WRITE) {\n\t\t\tunsigned int sectors;\n\n\t\t\tsectors = fsector_t + blk_rq_sectors(current_req);\n\t\t\tif (sectors > ssize && sectors < ssize + ssize)\n\t\t\t\tmax_size = ssize + ssize;\n\t\t\telse\n\t\t\t\tmax_size = ssize;\n\t\t}\n\t\traw_cmd->flags &= ~FD_RAW_WRITE;\n\t\traw_cmd->flags |= FD_RAW_READ;\n\t\tCOMMAND = FM_MODE(_floppy, FD_READ);\n\t} else if ((unsigned long)bio_data(current_req->bio) < MAX_DMA_ADDRESS) {\n\t\tunsigned long dma_limit;\n\t\tint direct, indirect;\n\n\t\tindirect =\n\t\t    transfer_size(ssize, max_sector,\n\t\t\t\t  max_buffer_sectors * 2) - fsector_t;\n\n\t\t/*\n\t\t * Do NOT use minimum() here---MAX_DMA_ADDRESS is 64 bits wide\n\t\t * on a 64 bit machine!\n\t\t */\n\t\tmax_size = buffer_chain_size();\n\t\tdma_limit = (MAX_DMA_ADDRESS -\n\t\t\t     ((unsigned long)bio_data(current_req->bio))) >> 9;\n\t\tif ((unsigned long)max_size > dma_limit)\n\t\t\tmax_size = dma_limit;\n\t\t/* 64 kb boundaries */\n\t\tif (CROSS_64KB(bio_data(current_req->bio), max_size << 9))\n\t\t\tmax_size = (K_64 -\n\t\t\t\t    ((unsigned long)bio_data(current_req->bio)) %\n\t\t\t\t    K_64) >> 9;\n\t\tdirect = transfer_size(ssize, max_sector, max_size) - fsector_t;\n\t\t/*\n\t\t * We try to read tracks, but if we get too many errors, we\n\t\t * go back to reading just one sector at a time.\n\t\t *\n\t\t * This means we should be able to read a sector even if there\n\t\t * are other bad sectors on this track.\n\t\t */\n\t\tif (!direct ||\n\t\t    (indirect * 2 > direct * 3 &&\n\t\t     *errors < DP->max_errors.read_track &&\n\t\t     ((!probing ||\n\t\t       (DP->read_track & (1 << DRS->probed_format)))))) {\n\t\t\tmax_size = blk_rq_sectors(current_req);\n\t\t} else {\n\t\t\traw_cmd->kernel_data = bio_data(current_req->bio);\n\t\t\traw_cmd->length = current_count_sectors << 9;\n\t\t\tif (raw_cmd->length == 0) {\n\t\t\t\tDPRINT(\"%s: zero dma transfer attempted\\n\", __func__);\n\t\t\t\tDPRINT(\"indirect=%d direct=%d fsector_t=%d\\n\",\n\t\t\t\t       indirect, direct, fsector_t);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tvirtualdmabug_workaround();\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\tif (CT(COMMAND) == FD_READ)\n\t\tmax_size = max_sector;\t/* unbounded */\n\n\t/* claim buffer track if needed */\n\tif (buffer_track != raw_cmd->track ||\t/* bad track */\n\t    buffer_drive != current_drive ||\t/* bad drive */\n\t    fsector_t > buffer_max ||\n\t    fsector_t < buffer_min ||\n\t    ((CT(COMMAND) == FD_READ ||\n\t      (!in_sector_offset && blk_rq_sectors(current_req) >= ssize)) &&\n\t     max_sector > 2 * max_buffer_sectors + buffer_min &&\n\t     max_size + fsector_t > 2 * max_buffer_sectors + buffer_min)) {\n\t\t/* not enough space */\n\t\tbuffer_track = -1;\n\t\tbuffer_drive = current_drive;\n\t\tbuffer_max = buffer_min = aligned_sector_t;\n\t}\n\traw_cmd->kernel_data = floppy_track_buffer +\n\t\t((aligned_sector_t - buffer_min) << 9);\n\n\tif (CT(COMMAND) == FD_WRITE) {\n\t\t/* copy write buffer to track buffer.\n\t\t * if we get here, we know that the write\n\t\t * is either aligned or the data already in the buffer\n\t\t * (buffer will be overwritten) */\n\t\tif (in_sector_offset && buffer_track == -1)\n\t\t\tDPRINT(\"internal error offset !=0 on write\\n\");\n\t\tbuffer_track = raw_cmd->track;\n\t\tbuffer_drive = current_drive;\n\t\tcopy_buffer(ssize, max_sector,\n\t\t\t    2 * max_buffer_sectors + buffer_min);\n\t} else\n\t\ttransfer_size(ssize, max_sector,\n\t\t\t      2 * max_buffer_sectors + buffer_min -\n\t\t\t      aligned_sector_t);\n\n\t/* round up current_count_sectors to get dma xfer size */\n\traw_cmd->length = in_sector_offset + current_count_sectors;\n\traw_cmd->length = ((raw_cmd->length - 1) | (ssize - 1)) + 1;\n\traw_cmd->length <<= 9;\n\tif ((raw_cmd->length < current_count_sectors << 9) ||\n\t    (raw_cmd->kernel_data != bio_data(current_req->bio) &&\n\t     CT(COMMAND) == FD_WRITE &&\n\t     (aligned_sector_t + (raw_cmd->length >> 9) > buffer_max ||\n\t      aligned_sector_t < buffer_min)) ||\n\t    raw_cmd->length % (128 << SIZECODE) ||\n\t    raw_cmd->length <= 0 || current_count_sectors <= 0) {\n\t\tDPRINT(\"fractionary current count b=%lx s=%lx\\n\",\n\t\t       raw_cmd->length, current_count_sectors);\n\t\tif (raw_cmd->kernel_data != bio_data(current_req->bio))\n\t\t\tpr_info(\"addr=%d, length=%ld\\n\",\n\t\t\t\t(int)((raw_cmd->kernel_data -\n\t\t\t\t       floppy_track_buffer) >> 9),\n\t\t\t\tcurrent_count_sectors);\n\t\tpr_info(\"st=%d ast=%d mse=%d msi=%d\\n\",\n\t\t\tfsector_t, aligned_sector_t, max_sector, max_size);\n\t\tpr_info(\"ssize=%x SIZECODE=%d\\n\", ssize, SIZECODE);\n\t\tpr_info(\"command=%x SECTOR=%d HEAD=%d, TRACK=%d\\n\",\n\t\t\tCOMMAND, SECTOR, HEAD, TRACK);\n\t\tpr_info(\"buffer drive=%d\\n\", buffer_drive);\n\t\tpr_info(\"buffer track=%d\\n\", buffer_track);\n\t\tpr_info(\"buffer_min=%d\\n\", buffer_min);\n\t\tpr_info(\"buffer_max=%d\\n\", buffer_max);\n\t\treturn 0;\n\t}\n\n\tif (raw_cmd->kernel_data != bio_data(current_req->bio)) {\n\t\tif (raw_cmd->kernel_data < floppy_track_buffer ||\n\t\t    current_count_sectors < 0 ||\n\t\t    raw_cmd->length < 0 ||\n\t\t    raw_cmd->kernel_data + raw_cmd->length >\n\t\t    floppy_track_buffer + (max_buffer_sectors << 10)) {\n\t\t\tDPRINT(\"buffer overrun in schedule dma\\n\");\n\t\t\tpr_info(\"fsector_t=%d buffer_min=%d current_count=%ld\\n\",\n\t\t\t\tfsector_t, buffer_min, raw_cmd->length >> 9);\n\t\t\tpr_info(\"current_count_sectors=%ld\\n\",\n\t\t\t\tcurrent_count_sectors);\n\t\t\tif (CT(COMMAND) == FD_READ)\n\t\t\t\tpr_info(\"read\\n\");\n\t\t\tif (CT(COMMAND) == FD_WRITE)\n\t\t\t\tpr_info(\"write\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else if (raw_cmd->length > blk_rq_bytes(current_req) ||\n\t\t   current_count_sectors > blk_rq_sectors(current_req)) {\n\t\tDPRINT(\"buffer overrun in direct transfer\\n\");\n\t\treturn 0;\n\t} else if (raw_cmd->length < current_count_sectors << 9) {\n\t\tDPRINT(\"more sectors than bytes\\n\");\n\t\tpr_info(\"bytes=%ld\\n\", raw_cmd->length >> 9);\n\t\tpr_info(\"sectors=%ld\\n\", current_count_sectors);\n\t}\n\tif (raw_cmd->length == 0) {\n\t\tDPRINT(\"zero dma transfer attempted from make_raw_request\\n\");\n\t\treturn 0;\n\t}\n\n\tvirtualdmabug_workaround();\n\treturn 2;\n}\n\nstatic int set_next_request(void)\n{\n\tcurrent_req = list_first_entry_or_null(&floppy_reqs, struct request,\n\t\t\t\t\t       queuelist);\n\tif (current_req) {\n\t\tcurrent_req->error_count = 0;\n\t\tlist_del_init(&current_req->queuelist);\n\t}\n\treturn current_req != NULL;\n}\n\nstatic void redo_fd_request(void)\n{\n\tint drive;\n\tint tmp;\n\n\tlastredo = jiffies;\n\tif (current_drive < N_DRIVE)\n\t\tfloppy_off(current_drive);\n\ndo_request:\n\tif (!current_req) {\n\t\tint pending;\n\n\t\tspin_lock_irq(&floppy_lock);\n\t\tpending = set_next_request();\n\t\tspin_unlock_irq(&floppy_lock);\n\t\tif (!pending) {\n\t\t\tdo_floppy = NULL;\n\t\t\tunlock_fdc();\n\t\t\treturn;\n\t\t}\n\t}\n\tdrive = (long)current_req->rq_disk->private_data;\n\tset_fdc(drive);\n\treschedule_timeout(current_reqD, \"redo fd request\");\n\n\tset_floppy(drive);\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->flags = 0;\n\tif (start_motor(redo_fd_request))\n\t\treturn;\n\n\tdisk_change(current_drive);\n\tif (test_bit(current_drive, &fake_change) ||\n\t    test_bit(FD_DISK_CHANGED_BIT, &DRS->flags)) {\n\t\tDPRINT(\"disk absent or changed during operation\\n\");\n\t\trequest_done(0);\n\t\tgoto do_request;\n\t}\n\tif (!_floppy) {\t/* Autodetection */\n\t\tif (!probing) {\n\t\t\tDRS->probed_format = 0;\n\t\t\tif (next_valid_format()) {\n\t\t\t\tDPRINT(\"no autodetectable formats\\n\");\n\t\t\t\t_floppy = NULL;\n\t\t\t\trequest_done(0);\n\t\t\t\tgoto do_request;\n\t\t\t}\n\t\t}\n\t\tprobing = 1;\n\t\t_floppy = floppy_type + DP->autodetect[DRS->probed_format];\n\t} else\n\t\tprobing = 0;\n\terrors = &(current_req->error_count);\n\ttmp = make_raw_rw_request();\n\tif (tmp < 2) {\n\t\trequest_done(tmp);\n\t\tgoto do_request;\n\t}\n\n\tif (test_bit(FD_NEED_TWADDLE_BIT, &DRS->flags))\n\t\ttwaddle();\n\tschedule_bh(floppy_start);\n\tdebugt(__func__, \"queue fd request\");\n\treturn;\n}\n\nstatic const struct cont_t rw_cont = {\n\t.interrupt\t= rw_interrupt,\n\t.redo\t\t= redo_fd_request,\n\t.error\t\t= bad_flp_intr,\n\t.done\t\t= request_done\n};\n\nstatic void process_fd_request(void)\n{\n\tcont = &rw_cont;\n\tschedule_bh(redo_fd_request);\n}\n\nstatic blk_status_t floppy_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t    const struct blk_mq_queue_data *bd)\n{\n\tblk_mq_start_request(bd->rq);\n\n\tif (WARN(max_buffer_sectors == 0,\n\t\t \"VFS: %s called on non-open device\\n\", __func__))\n\t\treturn BLK_STS_IOERR;\n\n\tif (WARN(atomic_read(&usage_count) == 0,\n\t\t \"warning: usage count=0, current_req=%p sect=%ld flags=%llx\\n\",\n\t\t current_req, (long)blk_rq_pos(current_req),\n\t\t (unsigned long long) current_req->cmd_flags))\n\t\treturn BLK_STS_IOERR;\n\n\tspin_lock_irq(&floppy_lock);\n\tlist_add_tail(&bd->rq->queuelist, &floppy_reqs);\n\tspin_unlock_irq(&floppy_lock);\n\n\tif (test_and_set_bit(0, &fdc_busy)) {\n\t\t/* fdc busy, this new request will be treated when the\n\t\t   current one is done */\n\t\tis_alive(__func__, \"old request running\");\n\t\treturn BLK_STS_OK;\n\t}\n\n\tcommand_status = FD_COMMAND_NONE;\n\t__reschedule_timeout(MAXTIMEOUT, \"fd_request\");\n\tset_fdc(0);\n\tprocess_fd_request();\n\tis_alive(__func__, \"\");\n\treturn BLK_STS_OK;\n}\n\nstatic const struct cont_t poll_cont = {\n\t.interrupt\t= success_and_wakeup,\n\t.redo\t\t= floppy_ready,\n\t.error\t\t= generic_failure,\n\t.done\t\t= generic_done\n};\n\nstatic int poll_drive(bool interruptible, int flag)\n{\n\t/* no auto-sense, just clear dcl */\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->flags = flag;\n\traw_cmd->track = 0;\n\traw_cmd->cmd_count = 0;\n\tcont = &poll_cont;\n\tdebug_dcl(DP->flags, \"setting NEWCHANGE in poll_drive\\n\");\n\tset_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags);\n\n\treturn wait_til_done(floppy_ready, interruptible);\n}\n\n/*\n * User triggered reset\n * ====================\n */\n\nstatic void reset_intr(void)\n{\n\tpr_info(\"weird, reset interrupt called\\n\");\n}\n\nstatic const struct cont_t reset_cont = {\n\t.interrupt\t= reset_intr,\n\t.redo\t\t= success_and_wakeup,\n\t.error\t\t= generic_failure,\n\t.done\t\t= generic_done\n};\n\nstatic int user_reset_fdc(int drive, int arg, bool interruptible)\n{\n\tint ret;\n\n\tif (lock_fdc(drive))\n\t\treturn -EINTR;\n\n\tif (arg == FD_RESET_ALWAYS)\n\t\tFDCS->reset = 1;\n\tif (FDCS->reset) {\n\t\tcont = &reset_cont;\n\t\tret = wait_til_done(reset_fdc, interruptible);\n\t\tif (ret == -EINTR)\n\t\t\treturn -EINTR;\n\t}\n\tprocess_fd_request();\n\treturn 0;\n}\n\n/*\n * Misc Ioctl's and support\n * ========================\n */\nstatic inline int fd_copyout(void __user *param, const void *address,\n\t\t\t     unsigned long size)\n{\n\treturn copy_to_user(param, address, size) ? -EFAULT : 0;\n}\n\nstatic inline int fd_copyin(void __user *param, void *address,\n\t\t\t    unsigned long size)\n{\n\treturn copy_from_user(address, param, size) ? -EFAULT : 0;\n}\n\nstatic const char *drive_name(int type, int drive)\n{\n\tstruct floppy_struct *floppy;\n\n\tif (type)\n\t\tfloppy = floppy_type + type;\n\telse {\n\t\tif (UDP->native_format)\n\t\t\tfloppy = floppy_type + UDP->native_format;\n\t\telse\n\t\t\treturn \"(null)\";\n\t}\n\tif (floppy->name)\n\t\treturn floppy->name;\n\telse\n\t\treturn \"(null)\";\n}\n\n/* raw commands */\nstatic void raw_cmd_done(int flag)\n{\n\tint i;\n\n\tif (!flag) {\n\t\traw_cmd->flags |= FD_RAW_FAILURE;\n\t\traw_cmd->flags |= FD_RAW_HARDFAILURE;\n\t} else {\n\t\traw_cmd->reply_count = inr;\n\t\tif (raw_cmd->reply_count > MAX_REPLIES)\n\t\t\traw_cmd->reply_count = 0;\n\t\tfor (i = 0; i < raw_cmd->reply_count; i++)\n\t\t\traw_cmd->reply[i] = reply_buffer[i];\n\n\t\tif (raw_cmd->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\t\tunsigned long flags;\n\t\t\tflags = claim_dma_lock();\n\t\t\traw_cmd->length = fd_get_dma_residue();\n\t\t\trelease_dma_lock(flags);\n\t\t}\n\n\t\tif ((raw_cmd->flags & FD_RAW_SOFTFAILURE) &&\n\t\t    (!raw_cmd->reply_count || (raw_cmd->reply[0] & 0xc0)))\n\t\t\traw_cmd->flags |= FD_RAW_FAILURE;\n\n\t\tif (disk_change(current_drive))\n\t\t\traw_cmd->flags |= FD_RAW_DISK_CHANGE;\n\t\telse\n\t\t\traw_cmd->flags &= ~FD_RAW_DISK_CHANGE;\n\t\tif (raw_cmd->flags & FD_RAW_NO_MOTOR_AFTER)\n\t\t\tmotor_off_callback(&motor_off_timer[current_drive]);\n\n\t\tif (raw_cmd->next &&\n\t\t    (!(raw_cmd->flags & FD_RAW_FAILURE) ||\n\t\t     !(raw_cmd->flags & FD_RAW_STOP_IF_FAILURE)) &&\n\t\t    ((raw_cmd->flags & FD_RAW_FAILURE) ||\n\t\t     !(raw_cmd->flags & FD_RAW_STOP_IF_SUCCESS))) {\n\t\t\traw_cmd = raw_cmd->next;\n\t\t\treturn;\n\t\t}\n\t}\n\tgeneric_done(flag);\n}\n\nstatic const struct cont_t raw_cmd_cont = {\n\t.interrupt\t= success_and_wakeup,\n\t.redo\t\t= floppy_start,\n\t.error\t\t= generic_failure,\n\t.done\t\t= raw_cmd_done\n};\n\nstatic int raw_cmd_copyout(int cmd, void __user *param,\n\t\t\t\t  struct floppy_raw_cmd *ptr)\n{\n\tint ret;\n\n\twhile (ptr) {\n\t\tstruct floppy_raw_cmd cmd = *ptr;\n\t\tcmd.next = NULL;\n\t\tcmd.kernel_data = NULL;\n\t\tret = copy_to_user(param, &cmd, sizeof(cmd));\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tparam += sizeof(struct floppy_raw_cmd);\n\t\tif ((ptr->flags & FD_RAW_READ) && ptr->buffer_length) {\n\t\t\tif (ptr->length >= 0 &&\n\t\t\t    ptr->length <= ptr->buffer_length) {\n\t\t\t\tlong length = ptr->buffer_length - ptr->length;\n\t\t\t\tret = fd_copyout(ptr->data, ptr->kernel_data,\n\t\t\t\t\t\t length);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\treturn 0;\n}\n\nstatic void raw_cmd_free(struct floppy_raw_cmd **ptr)\n{\n\tstruct floppy_raw_cmd *next;\n\tstruct floppy_raw_cmd *this;\n\n\tthis = *ptr;\n\t*ptr = NULL;\n\twhile (this) {\n\t\tif (this->buffer_length) {\n\t\t\tfd_dma_mem_free((unsigned long)this->kernel_data,\n\t\t\t\t\tthis->buffer_length);\n\t\t\tthis->buffer_length = 0;\n\t\t}\n\t\tnext = this->next;\n\t\tkfree(this);\n\t\tthis = next;\n\t}\n}\n\nstatic int raw_cmd_copyin(int cmd, void __user *param,\n\t\t\t\t struct floppy_raw_cmd **rcmd)\n{\n\tstruct floppy_raw_cmd *ptr;\n\tint ret;\n\tint i;\n\n\t*rcmd = NULL;\n\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\t*rcmd = ptr;\n\tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tptr->next = NULL;\n\tptr->buffer_length = 0;\n\tptr->kernel_data = NULL;\n\tif (ret)\n\t\treturn -EFAULT;\n\tparam += sizeof(struct floppy_raw_cmd);\n\tif (ptr->cmd_count > 33)\n\t\t\t/* the command may now also take up the space\n\t\t\t * initially intended for the reply & the\n\t\t\t * reply count. Needed for long 82078 commands\n\t\t\t * such as RESTORE, which takes ... 17 command\n\t\t\t * bytes. Murphy's law #137: When you reserve\n\t\t\t * 16 bytes for a structure, you'll one day\n\t\t\t * discover that you really need 17...\n\t\t\t */\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < 16; i++)\n\t\tptr->reply[i] = 0;\n\tptr->resultcode = 0;\n\n\tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}\n\tif (ptr->flags & FD_RAW_WRITE) {\n\t\tret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (ptr->flags & FD_RAW_MORE) {\n\t\trcmd = &(ptr->next);\n\t\tptr->rate &= 0x43;\n\t\tgoto loop;\n\t}\n\n\treturn 0;\n}\n\nstatic int raw_cmd_ioctl(int cmd, void __user *param)\n{\n\tstruct floppy_raw_cmd *my_raw_cmd;\n\tint drive;\n\tint ret2;\n\tint ret;\n\n\tif (FDCS->rawcmd <= 1)\n\t\tFDCS->rawcmd = 1;\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tif (FDC(drive) != fdc)\n\t\t\tcontinue;\n\t\tif (drive == current_drive) {\n\t\t\tif (UDRS->fd_ref > 1) {\n\t\t\t\tFDCS->rawcmd = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (UDRS->fd_ref) {\n\t\t\tFDCS->rawcmd = 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (FDCS->reset)\n\t\treturn -EIO;\n\n\tret = raw_cmd_copyin(cmd, param, &my_raw_cmd);\n\tif (ret) {\n\t\traw_cmd_free(&my_raw_cmd);\n\t\treturn ret;\n\t}\n\n\traw_cmd = my_raw_cmd;\n\tcont = &raw_cmd_cont;\n\tret = wait_til_done(floppy_start, true);\n\tdebug_dcl(DP->flags, \"calling disk change from raw_cmd ioctl\\n\");\n\n\tif (ret != -EINTR && FDCS->reset)\n\t\tret = -EIO;\n\n\tDRS->track = NO_TRACK;\n\n\tret2 = raw_cmd_copyout(cmd, param, my_raw_cmd);\n\tif (!ret)\n\t\tret = ret2;\n\traw_cmd_free(&my_raw_cmd);\n\treturn ret;\n}\n\nstatic int invalidate_drive(struct block_device *bdev)\n{\n\t/* invalidate the buffer track to force a reread */\n\tset_bit((long)bdev->bd_disk->private_data, &fake_change);\n\tprocess_fd_request();\n\tcheck_disk_change(bdev);\n\treturn 0;\n}\n\nstatic int set_geometry(unsigned int cmd, struct floppy_struct *g,\n\t\t\t       int drive, int type, struct block_device *bdev)\n{\n\tint cnt;\n\n\t/* sanity checking for parameters. */\n\tif (g->sect <= 0 ||\n\t    g->head <= 0 ||\n\t    g->track <= 0 || g->track > UDP->tracks >> STRETCH(g) ||\n\t    /* check if reserved bits are set */\n\t    (g->stretch & ~(FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK)) != 0)\n\t\treturn -EINVAL;\n\tif (type) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tmutex_lock(&open_lock);\n\t\tif (lock_fdc(drive)) {\n\t\t\tmutex_unlock(&open_lock);\n\t\t\treturn -EINTR;\n\t\t}\n\t\tfloppy_type[type] = *g;\n\t\tfloppy_type[type].name = \"user format\";\n\t\tfor (cnt = type << 2; cnt < (type << 2) + 4; cnt++)\n\t\t\tfloppy_sizes[cnt] = floppy_sizes[cnt + 0x80] =\n\t\t\t    floppy_type[type].size + 1;\n\t\tprocess_fd_request();\n\t\tfor (cnt = 0; cnt < N_DRIVE; cnt++) {\n\t\t\tstruct block_device *bdev = opened_bdev[cnt];\n\t\t\tif (!bdev || ITYPE(drive_state[cnt].fd_device) != type)\n\t\t\t\tcontinue;\n\t\t\t__invalidate_device(bdev, true);\n\t\t}\n\t\tmutex_unlock(&open_lock);\n\t} else {\n\t\tint oldStretch;\n\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (cmd != FDDEFPRM) {\n\t\t\t/* notice a disk change immediately, else\n\t\t\t * we lose our settings immediately*/\n\t\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\t\treturn -EINTR;\n\t\t}\n\t\toldStretch = g->stretch;\n\t\tuser_params[drive] = *g;\n\t\tif (buffer_drive == drive)\n\t\t\tSUPBOUND(buffer_max, user_params[drive].sect);\n\t\tcurrent_type[drive] = &user_params[drive];\n\t\tfloppy_sizes[drive] = user_params[drive].size;\n\t\tif (cmd == FDDEFPRM)\n\t\t\tDRS->keep_data = -1;\n\t\telse\n\t\t\tDRS->keep_data = 1;\n\t\t/* invalidation. Invalidate only when needed, i.e.\n\t\t * when there are already sectors in the buffer cache\n\t\t * whose number will change. This is useful, because\n\t\t * mtools often changes the geometry of the disk after\n\t\t * looking at the boot block */\n\t\tif (DRS->maxblock > user_params[drive].sect ||\n\t\t    DRS->maxtrack ||\n\t\t    ((user_params[drive].sect ^ oldStretch) &\n\t\t     (FD_SWAPSIDES | FD_SECTBASEMASK)))\n\t\t\tinvalidate_drive(bdev);\n\t\telse\n\t\t\tprocess_fd_request();\n\t}\n\treturn 0;\n}\n\n/* handle obsolete ioctl's */\nstatic unsigned int ioctl_table[] = {\n\tFDCLRPRM,\n\tFDSETPRM,\n\tFDDEFPRM,\n\tFDGETPRM,\n\tFDMSGON,\n\tFDMSGOFF,\n\tFDFMTBEG,\n\tFDFMTTRK,\n\tFDFMTEND,\n\tFDSETEMSGTRESH,\n\tFDFLUSH,\n\tFDSETMAXERRS,\n\tFDGETMAXERRS,\n\tFDGETDRVTYP,\n\tFDSETDRVPRM,\n\tFDGETDRVPRM,\n\tFDGETDRVSTAT,\n\tFDPOLLDRVSTAT,\n\tFDRESET,\n\tFDGETFDCSTAT,\n\tFDWERRORCLR,\n\tFDWERRORGET,\n\tFDRAWCMD,\n\tFDEJECT,\n\tFDTWADDLE\n};\n\nstatic int normalize_ioctl(unsigned int *cmd, int *size)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ioctl_table); i++) {\n\t\tif ((*cmd & 0xffff) == (ioctl_table[i] & 0xffff)) {\n\t\t\t*size = _IOC_SIZE(*cmd);\n\t\t\t*cmd = ioctl_table[i];\n\t\t\tif (*size > _IOC_SIZE(*cmd)) {\n\t\t\t\tpr_info(\"ioctl not yet supported\\n\");\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int get_floppy_geometry(int drive, int type, struct floppy_struct **g)\n{\n\tif (type)\n\t\t*g = &floppy_type[type];\n\telse {\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (poll_drive(false, 0) == -EINTR)\n\t\t\treturn -EINTR;\n\t\tprocess_fd_request();\n\t\t*g = current_type[drive];\n\t}\n\tif (!*g)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic int fd_getgeo(struct block_device *bdev, struct hd_geometry *geo)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tint type = ITYPE(drive_state[drive].fd_device);\n\tstruct floppy_struct *g;\n\tint ret;\n\n\tret = get_floppy_geometry(drive, type, &g);\n\tif (ret)\n\t\treturn ret;\n\n\tgeo->heads = g->head;\n\tgeo->sectors = g->sect;\n\tgeo->cylinders = g->track;\n\treturn 0;\n}\n\nstatic int fd_locked_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd,\n\t\t    unsigned long param)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tint type = ITYPE(UDRS->fd_device);\n\tint i;\n\tint ret;\n\tint size;\n\tunion inparam {\n\t\tstruct floppy_struct g;\t/* geometry */\n\t\tstruct format_descr f;\n\t\tstruct floppy_max_errors max_errors;\n\t\tstruct floppy_drive_params dp;\n\t} inparam;\t\t/* parameters coming from user space */\n\tconst void *outparam;\t/* parameters passed back to user space */\n\n\t/* convert compatibility eject ioctls into floppy eject ioctl.\n\t * We do this in order to provide a means to eject floppy disks before\n\t * installing the new fdutils package */\n\tif (cmd == CDROMEJECT ||\t/* CD-ROM eject */\n\t    cmd == 0x6470) {\t\t/* SunOS floppy eject */\n\t\tDPRINT(\"obsolete eject ioctl\\n\");\n\t\tDPRINT(\"please use floppycontrol --eject\\n\");\n\t\tcmd = FDEJECT;\n\t}\n\n\tif (!((cmd & 0xff00) == 0x0200))\n\t\treturn -EINVAL;\n\n\t/* convert the old style command into a new style command */\n\tret = normalize_ioctl(&cmd, &size);\n\tif (ret)\n\t\treturn ret;\n\n\t/* permission checks */\n\tif (((cmd & 0x40) && !(mode & (FMODE_WRITE | FMODE_WRITE_IOCTL))) ||\n\t    ((cmd & 0x80) && !capable(CAP_SYS_ADMIN)))\n\t\treturn -EPERM;\n\n\tif (WARN_ON(size < 0 || size > sizeof(inparam)))\n\t\treturn -EINVAL;\n\n\t/* copyin */\n\tmemset(&inparam, 0, sizeof(inparam));\n\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\tret = fd_copyin((void __user *)param, &inparam, size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tswitch (cmd) {\n\tcase FDEJECT:\n\t\tif (UDRS->fd_ref != 1)\n\t\t\t/* somebody else has this drive open */\n\t\t\treturn -EBUSY;\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\n\t\t/* do the actual eject. Fails on\n\t\t * non-Sparc architectures */\n\t\tret = fd_eject(UNIT(drive));\n\n\t\tset_bit(FD_DISK_CHANGED_BIT, &UDRS->flags);\n\t\tset_bit(FD_VERIFY_BIT, &UDRS->flags);\n\t\tprocess_fd_request();\n\t\treturn ret;\n\tcase FDCLRPRM:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tcurrent_type[drive] = NULL;\n\t\tfloppy_sizes[drive] = MAX_DISK_SIZE << 1;\n\t\tUDRS->keep_data = 0;\n\t\treturn invalidate_drive(bdev);\n\tcase FDSETPRM:\n\tcase FDDEFPRM:\n\t\treturn set_geometry(cmd, &inparam.g, drive, type, bdev);\n\tcase FDGETPRM:\n\t\tret = get_floppy_geometry(drive, type,\n\t\t\t\t\t  (struct floppy_struct **)&outparam);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmemcpy(&inparam.g, outparam,\n\t\t\t\toffsetof(struct floppy_struct, name));\n\t\toutparam = &inparam.g;\n\t\tbreak;\n\tcase FDMSGON:\n\t\tUDP->flags |= FTD_MSG;\n\t\treturn 0;\n\tcase FDMSGOFF:\n\t\tUDP->flags &= ~FTD_MSG;\n\t\treturn 0;\n\tcase FDFMTBEG:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\treturn -EINTR;\n\t\tret = UDRS->flags;\n\t\tprocess_fd_request();\n\t\tif (ret & FD_VERIFY)\n\t\t\treturn -ENODEV;\n\t\tif (!(ret & FD_DISK_WRITABLE))\n\t\t\treturn -EROFS;\n\t\treturn 0;\n\tcase FDFMTTRK:\n\t\tif (UDRS->fd_ref != 1)\n\t\t\treturn -EBUSY;\n\t\treturn do_format(drive, &inparam.f);\n\tcase FDFMTEND:\n\tcase FDFLUSH:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\treturn invalidate_drive(bdev);\n\tcase FDSETEMSGTRESH:\n\t\tUDP->max_errors.reporting = (unsigned short)(param & 0x0f);\n\t\treturn 0;\n\tcase FDGETMAXERRS:\n\t\toutparam = &UDP->max_errors;\n\t\tbreak;\n\tcase FDSETMAXERRS:\n\t\tUDP->max_errors = inparam.max_errors;\n\t\tbreak;\n\tcase FDGETDRVTYP:\n\t\toutparam = drive_name(type, drive);\n\t\tSUPBOUND(size, strlen((const char *)outparam) + 1);\n\t\tbreak;\n\tcase FDSETDRVPRM:\n\t\t*UDP = inparam.dp;\n\t\tbreak;\n\tcase FDGETDRVPRM:\n\t\toutparam = UDP;\n\t\tbreak;\n\tcase FDPOLLDRVSTAT:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\treturn -EINTR;\n\t\tprocess_fd_request();\n\t\t/* fall through */\n\tcase FDGETDRVSTAT:\n\t\toutparam = UDRS;\n\t\tbreak;\n\tcase FDRESET:\n\t\treturn user_reset_fdc(drive, (int)param, true);\n\tcase FDGETFDCSTAT:\n\t\toutparam = UFDCS;\n\t\tbreak;\n\tcase FDWERRORCLR:\n\t\tmemset(UDRWE, 0, sizeof(*UDRWE));\n\t\treturn 0;\n\tcase FDWERRORGET:\n\t\toutparam = UDRWE;\n\t\tbreak;\n\tcase FDRAWCMD:\n\t\tif (type)\n\t\t\treturn -EINVAL;\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tset_floppy(drive);\n\t\ti = raw_cmd_ioctl(cmd, (void __user *)param);\n\t\tif (i == -EINTR)\n\t\t\treturn -EINTR;\n\t\tprocess_fd_request();\n\t\treturn i;\n\tcase FDTWADDLE:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\ttwaddle();\n\t\tprocess_fd_request();\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (_IOC_DIR(cmd) & _IOC_READ)\n\t\treturn fd_copyout((void __user *)param, outparam, size);\n\n\treturn 0;\n}\n\nstatic int fd_ioctl(struct block_device *bdev, fmode_t mode,\n\t\t\t     unsigned int cmd, unsigned long param)\n{\n\tint ret;\n\n\tmutex_lock(&floppy_mutex);\n\tret = fd_locked_ioctl(bdev, mode, cmd, param);\n\tmutex_unlock(&floppy_mutex);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\n\nstruct compat_floppy_drive_params {\n\tchar\t\tcmos;\n\tcompat_ulong_t\tmax_dtr;\n\tcompat_ulong_t\thlt;\n\tcompat_ulong_t\thut;\n\tcompat_ulong_t\tsrt;\n\tcompat_ulong_t\tspinup;\n\tcompat_ulong_t\tspindown;\n\tunsigned char\tspindown_offset;\n\tunsigned char\tselect_delay;\n\tunsigned char\trps;\n\tunsigned char\ttracks;\n\tcompat_ulong_t\ttimeout;\n\tunsigned char\tinterleave_sect;\n\tstruct floppy_max_errors max_errors;\n\tchar\t\tflags;\n\tchar\t\tread_track;\n\tshort\t\tautodetect[8];\n\tcompat_int_t\tcheckfreq;\n\tcompat_int_t\tnative_format;\n};\n\nstruct compat_floppy_drive_struct {\n\tsigned char\tflags;\n\tcompat_ulong_t\tspinup_date;\n\tcompat_ulong_t\tselect_date;\n\tcompat_ulong_t\tfirst_read_date;\n\tshort\t\tprobed_format;\n\tshort\t\ttrack;\n\tshort\t\tmaxblock;\n\tshort\t\tmaxtrack;\n\tcompat_int_t\tgeneration;\n\tcompat_int_t\tkeep_data;\n\tcompat_int_t\tfd_ref;\n\tcompat_int_t\tfd_device;\n\tcompat_int_t\tlast_checked;\n\tcompat_caddr_t dmabuf;\n\tcompat_int_t\tbufblocks;\n};\n\nstruct compat_floppy_fdc_state {\n\tcompat_int_t\tspec1;\n\tcompat_int_t\tspec2;\n\tcompat_int_t\tdtr;\n\tunsigned char\tversion;\n\tunsigned char\tdor;\n\tcompat_ulong_t\taddress;\n\tunsigned int\trawcmd:2;\n\tunsigned int\treset:1;\n\tunsigned int\tneed_configure:1;\n\tunsigned int\tperp_mode:2;\n\tunsigned int\thas_fifo:1;\n\tunsigned int\tdriver_version;\n\tunsigned char\ttrack[4];\n};\n\nstruct compat_floppy_write_errors {\n\tunsigned int\twrite_errors;\n\tcompat_ulong_t\tfirst_error_sector;\n\tcompat_int_t\tfirst_error_generation;\n\tcompat_ulong_t\tlast_error_sector;\n\tcompat_int_t\tlast_error_generation;\n\tcompat_uint_t\tbadness;\n};\n\n#define FDSETPRM32 _IOW(2, 0x42, struct compat_floppy_struct)\n#define FDDEFPRM32 _IOW(2, 0x43, struct compat_floppy_struct)\n#define FDSETDRVPRM32 _IOW(2, 0x90, struct compat_floppy_drive_params)\n#define FDGETDRVPRM32 _IOR(2, 0x11, struct compat_floppy_drive_params)\n#define FDGETDRVSTAT32 _IOR(2, 0x12, struct compat_floppy_drive_struct)\n#define FDPOLLDRVSTAT32 _IOR(2, 0x13, struct compat_floppy_drive_struct)\n#define FDGETFDCSTAT32 _IOR(2, 0x15, struct compat_floppy_fdc_state)\n#define FDWERRORGET32  _IOR(2, 0x17, struct compat_floppy_write_errors)\n\nstatic int compat_set_geometry(struct block_device *bdev, fmode_t mode, unsigned int cmd,\n\t\t    struct compat_floppy_struct __user *arg)\n{\n\tstruct floppy_struct v;\n\tint drive, type;\n\tint err;\n\n\tBUILD_BUG_ON(offsetof(struct floppy_struct, name) !=\n\t\t     offsetof(struct compat_floppy_struct, name));\n\n\tif (!(mode & (FMODE_WRITE | FMODE_WRITE_IOCTL)))\n\t\treturn -EPERM;\n\n\tmemset(&v, 0, sizeof(struct floppy_struct));\n\tif (copy_from_user(&v, arg, offsetof(struct floppy_struct, name)))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&floppy_mutex);\n\tdrive = (long)bdev->bd_disk->private_data;\n\ttype = ITYPE(UDRS->fd_device);\n\terr = set_geometry(cmd == FDSETPRM32 ? FDSETPRM : FDDEFPRM,\n\t\t\t&v, drive, type, bdev);\n\tmutex_unlock(&floppy_mutex);\n\treturn err;\n}\n\nstatic int compat_get_prm(int drive,\n\t\t\t  struct compat_floppy_struct __user *arg)\n{\n\tstruct compat_floppy_struct v;\n\tstruct floppy_struct *p;\n\tint err;\n\n\tmemset(&v, 0, sizeof(v));\n\tmutex_lock(&floppy_mutex);\n\terr = get_floppy_geometry(drive, ITYPE(UDRS->fd_device), &p);\n\tif (err) {\n\t\tmutex_unlock(&floppy_mutex);\n\t\treturn err;\n\t}\n\tmemcpy(&v, p, offsetof(struct floppy_struct, name));\n\tmutex_unlock(&floppy_mutex);\n\tif (copy_to_user(arg, &v, sizeof(struct compat_floppy_struct)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int compat_setdrvprm(int drive,\n\t\t\t    struct compat_floppy_drive_params __user *arg)\n{\n\tstruct compat_floppy_drive_params v;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&v, arg, sizeof(struct compat_floppy_drive_params)))\n\t\treturn -EFAULT;\n\tmutex_lock(&floppy_mutex);\n\tUDP->cmos = v.cmos;\n\tUDP->max_dtr = v.max_dtr;\n\tUDP->hlt = v.hlt;\n\tUDP->hut = v.hut;\n\tUDP->srt = v.srt;\n\tUDP->spinup = v.spinup;\n\tUDP->spindown = v.spindown;\n\tUDP->spindown_offset = v.spindown_offset;\n\tUDP->select_delay = v.select_delay;\n\tUDP->rps = v.rps;\n\tUDP->tracks = v.tracks;\n\tUDP->timeout = v.timeout;\n\tUDP->interleave_sect = v.interleave_sect;\n\tUDP->max_errors = v.max_errors;\n\tUDP->flags = v.flags;\n\tUDP->read_track = v.read_track;\n\tmemcpy(UDP->autodetect, v.autodetect, sizeof(v.autodetect));\n\tUDP->checkfreq = v.checkfreq;\n\tUDP->native_format = v.native_format;\n\tmutex_unlock(&floppy_mutex);\n\treturn 0;\n}\n\nstatic int compat_getdrvprm(int drive,\n\t\t\t    struct compat_floppy_drive_params __user *arg)\n{\n\tstruct compat_floppy_drive_params v;\n\n\tmemset(&v, 0, sizeof(struct compat_floppy_drive_params));\n\tmutex_lock(&floppy_mutex);\n\tv.cmos = UDP->cmos;\n\tv.max_dtr = UDP->max_dtr;\n\tv.hlt = UDP->hlt;\n\tv.hut = UDP->hut;\n\tv.srt = UDP->srt;\n\tv.spinup = UDP->spinup;\n\tv.spindown = UDP->spindown;\n\tv.spindown_offset = UDP->spindown_offset;\n\tv.select_delay = UDP->select_delay;\n\tv.rps = UDP->rps;\n\tv.tracks = UDP->tracks;\n\tv.timeout = UDP->timeout;\n\tv.interleave_sect = UDP->interleave_sect;\n\tv.max_errors = UDP->max_errors;\n\tv.flags = UDP->flags;\n\tv.read_track = UDP->read_track;\n\tmemcpy(v.autodetect, UDP->autodetect, sizeof(v.autodetect));\n\tv.checkfreq = UDP->checkfreq;\n\tv.native_format = UDP->native_format;\n\tmutex_unlock(&floppy_mutex);\n\n\tif (copy_from_user(arg, &v, sizeof(struct compat_floppy_drive_params)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int compat_getdrvstat(int drive, bool poll,\n\t\t\t    struct compat_floppy_drive_struct __user *arg)\n{\n\tstruct compat_floppy_drive_struct v;\n\n\tmemset(&v, 0, sizeof(struct compat_floppy_drive_struct));\n\tmutex_lock(&floppy_mutex);\n\n\tif (poll) {\n\t\tif (lock_fdc(drive))\n\t\t\tgoto Eintr;\n\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\tgoto Eintr;\n\t\tprocess_fd_request();\n\t}\n\tv.spinup_date = UDRS->spinup_date;\n\tv.select_date = UDRS->select_date;\n\tv.first_read_date = UDRS->first_read_date;\n\tv.probed_format = UDRS->probed_format;\n\tv.track = UDRS->track;\n\tv.maxblock = UDRS->maxblock;\n\tv.maxtrack = UDRS->maxtrack;\n\tv.generation = UDRS->generation;\n\tv.keep_data = UDRS->keep_data;\n\tv.fd_ref = UDRS->fd_ref;\n\tv.fd_device = UDRS->fd_device;\n\tv.last_checked = UDRS->last_checked;\n\tv.dmabuf = (uintptr_t)UDRS->dmabuf;\n\tv.bufblocks = UDRS->bufblocks;\n\tmutex_unlock(&floppy_mutex);\n\n\tif (copy_from_user(arg, &v, sizeof(struct compat_floppy_drive_struct)))\n\t\treturn -EFAULT;\n\treturn 0;\nEintr:\n\tmutex_unlock(&floppy_mutex);\n\treturn -EINTR;\n}\n\nstatic int compat_getfdcstat(int drive,\n\t\t\t    struct compat_floppy_fdc_state __user *arg)\n{\n\tstruct compat_floppy_fdc_state v32;\n\tstruct floppy_fdc_state v;\n\n\tmutex_lock(&floppy_mutex);\n\tv = *UFDCS;\n\tmutex_unlock(&floppy_mutex);\n\n\tmemset(&v32, 0, sizeof(struct compat_floppy_fdc_state));\n\tv32.spec1 = v.spec1;\n\tv32.spec2 = v.spec2;\n\tv32.dtr = v.dtr;\n\tv32.version = v.version;\n\tv32.dor = v.dor;\n\tv32.address = v.address;\n\tv32.rawcmd = v.rawcmd;\n\tv32.reset = v.reset;\n\tv32.need_configure = v.need_configure;\n\tv32.perp_mode = v.perp_mode;\n\tv32.has_fifo = v.has_fifo;\n\tv32.driver_version = v.driver_version;\n\tmemcpy(v32.track, v.track, 4);\n\tif (copy_to_user(arg, &v32, sizeof(struct compat_floppy_fdc_state)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int compat_werrorget(int drive,\n\t\t\t    struct compat_floppy_write_errors __user *arg)\n{\n\tstruct compat_floppy_write_errors v32;\n\tstruct floppy_write_errors v;\n\n\tmemset(&v32, 0, sizeof(struct compat_floppy_write_errors));\n\tmutex_lock(&floppy_mutex);\n\tv = *UDRWE;\n\tmutex_unlock(&floppy_mutex);\n\tv32.write_errors = v.write_errors;\n\tv32.first_error_sector = v.first_error_sector;\n\tv32.first_error_generation = v.first_error_generation;\n\tv32.last_error_sector = v.last_error_sector;\n\tv32.last_error_generation = v.last_error_generation;\n\tv32.badness = v.badness;\n\tif (copy_to_user(arg, &v32, sizeof(struct compat_floppy_write_errors)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int fd_compat_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd,\n\t\t    unsigned long param)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tswitch (cmd) {\n\tcase FDMSGON:\n\tcase FDMSGOFF:\n\tcase FDSETEMSGTRESH:\n\tcase FDFLUSH:\n\tcase FDWERRORCLR:\n\tcase FDEJECT:\n\tcase FDCLRPRM:\n\tcase FDFMTBEG:\n\tcase FDRESET:\n\tcase FDTWADDLE:\n\t\treturn fd_ioctl(bdev, mode, cmd, param);\n\tcase FDSETMAXERRS:\n\tcase FDGETMAXERRS:\n\tcase FDGETDRVTYP:\n\tcase FDFMTEND:\n\tcase FDFMTTRK:\n\tcase FDRAWCMD:\n\t\treturn fd_ioctl(bdev, mode, cmd,\n\t\t\t\t(unsigned long)compat_ptr(param));\n\tcase FDSETPRM32:\n\tcase FDDEFPRM32:\n\t\treturn compat_set_geometry(bdev, mode, cmd, compat_ptr(param));\n\tcase FDGETPRM32:\n\t\treturn compat_get_prm(drive, compat_ptr(param));\n\tcase FDSETDRVPRM32:\n\t\treturn compat_setdrvprm(drive, compat_ptr(param));\n\tcase FDGETDRVPRM32:\n\t\treturn compat_getdrvprm(drive, compat_ptr(param));\n\tcase FDPOLLDRVSTAT32:\n\t\treturn compat_getdrvstat(drive, true, compat_ptr(param));\n\tcase FDGETDRVSTAT32:\n\t\treturn compat_getdrvstat(drive, false, compat_ptr(param));\n\tcase FDGETFDCSTAT32:\n\t\treturn compat_getfdcstat(drive, compat_ptr(param));\n\tcase FDWERRORGET32:\n\t\treturn compat_werrorget(drive, compat_ptr(param));\n\t}\n\treturn -EINVAL;\n}\n#endif\n\nstatic void __init config_types(void)\n{\n\tbool has_drive = false;\n\tint drive;\n\n\t/* read drive info out of physical CMOS */\n\tdrive = 0;\n\tif (!UDP->cmos)\n\t\tUDP->cmos = FLOPPY0_TYPE;\n\tdrive = 1;\n\tif (!UDP->cmos && FLOPPY1_TYPE)\n\t\tUDP->cmos = FLOPPY1_TYPE;\n\n\t/* FIXME: additional physical CMOS drive detection should go here */\n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tunsigned int type = UDP->cmos;\n\t\tstruct floppy_drive_params *params;\n\t\tconst char *name = NULL;\n\t\tchar temparea[32];\n\n\t\tif (type < ARRAY_SIZE(default_drive_params)) {\n\t\t\tparams = &default_drive_params[type].params;\n\t\t\tif (type) {\n\t\t\t\tname = default_drive_params[type].name;\n\t\t\t\tallowed_drive_mask |= 1 << drive;\n\t\t\t} else\n\t\t\t\tallowed_drive_mask &= ~(1 << drive);\n\t\t} else {\n\t\t\tparams = &default_drive_params[0].params;\n\t\t\tsnprintf(temparea, sizeof(temparea),\n\t\t\t\t \"unknown type %d (usb?)\", type);\n\t\t\tname = temparea;\n\t\t}\n\t\tif (name) {\n\t\t\tconst char *prepend;\n\t\t\tif (!has_drive) {\n\t\t\t\tprepend = \"\";\n\t\t\t\thas_drive = true;\n\t\t\t\tpr_info(\"Floppy drive(s):\");\n\t\t\t} else {\n\t\t\t\tprepend = \",\";\n\t\t\t}\n\n\t\t\tpr_cont(\"%s fd%d is %s\", prepend, drive, name);\n\t\t}\n\t\t*UDP = *params;\n\t}\n\n\tif (has_drive)\n\t\tpr_cont(\"\\n\");\n}\n\nstatic void floppy_release(struct gendisk *disk, fmode_t mode)\n{\n\tint drive = (long)disk->private_data;\n\n\tmutex_lock(&floppy_mutex);\n\tmutex_lock(&open_lock);\n\tif (!UDRS->fd_ref--) {\n\t\tDPRINT(\"floppy_release with fd_ref == 0\");\n\t\tUDRS->fd_ref = 0;\n\t}\n\tif (!UDRS->fd_ref)\n\t\topened_bdev[drive] = NULL;\n\tmutex_unlock(&open_lock);\n\tmutex_unlock(&floppy_mutex);\n}\n\n/*\n * floppy_open check for aliasing (/dev/fd0 can be the same as\n * /dev/PS0 etc), and disallows simultaneous access to the same\n * drive with different device numbers.\n */\nstatic int floppy_open(struct block_device *bdev, fmode_t mode)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tint old_dev, new_dev;\n\tint try;\n\tint res = -EBUSY;\n\tchar *tmp;\n\n\tmutex_lock(&floppy_mutex);\n\tmutex_lock(&open_lock);\n\told_dev = UDRS->fd_device;\n\tif (opened_bdev[drive] && opened_bdev[drive] != bdev)\n\t\tgoto out2;\n\n\tif (!UDRS->fd_ref && (UDP->flags & FD_BROKEN_DCL)) {\n\t\tset_bit(FD_DISK_CHANGED_BIT, &UDRS->flags);\n\t\tset_bit(FD_VERIFY_BIT, &UDRS->flags);\n\t}\n\n\tUDRS->fd_ref++;\n\n\topened_bdev[drive] = bdev;\n\n\tres = -ENXIO;\n\n\tif (!floppy_track_buffer) {\n\t\t/* if opening an ED drive, reserve a big buffer,\n\t\t * else reserve a small one */\n\t\tif ((UDP->cmos == 6) || (UDP->cmos == 5))\n\t\t\ttry = 64;\t/* Only 48 actually useful */\n\t\telse\n\t\t\ttry = 32;\t/* Only 24 actually useful */\n\n\t\ttmp = (char *)fd_dma_mem_alloc(1024 * try);\n\t\tif (!tmp && !floppy_track_buffer) {\n\t\t\ttry >>= 1;\t/* buffer only one side */\n\t\t\tINFBOUND(try, 16);\n\t\t\ttmp = (char *)fd_dma_mem_alloc(1024 * try);\n\t\t}\n\t\tif (!tmp && !floppy_track_buffer)\n\t\t\tfallback_on_nodma_alloc(&tmp, 2048 * try);\n\t\tif (!tmp && !floppy_track_buffer) {\n\t\t\tDPRINT(\"Unable to allocate DMA memory\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (floppy_track_buffer) {\n\t\t\tif (tmp)\n\t\t\t\tfd_dma_mem_free((unsigned long)tmp, try * 1024);\n\t\t} else {\n\t\t\tbuffer_min = buffer_max = -1;\n\t\t\tfloppy_track_buffer = tmp;\n\t\t\tmax_buffer_sectors = try;\n\t\t}\n\t}\n\n\tnew_dev = MINOR(bdev->bd_dev);\n\tUDRS->fd_device = new_dev;\n\tset_capacity(disks[drive], floppy_sizes[new_dev]);\n\tif (old_dev != -1 && old_dev != new_dev) {\n\t\tif (buffer_drive == drive)\n\t\t\tbuffer_track = -1;\n\t}\n\n\tif (UFDCS->rawcmd == 1)\n\t\tUFDCS->rawcmd = 2;\n\n\tif (!(mode & FMODE_NDELAY)) {\n\t\tif (mode & (FMODE_READ|FMODE_WRITE)) {\n\t\t\tUDRS->last_checked = 0;\n\t\t\tclear_bit(FD_OPEN_SHOULD_FAIL_BIT, &UDRS->flags);\n\t\t\tcheck_disk_change(bdev);\n\t\t\tif (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags))\n\t\t\t\tgoto out;\n\t\t\tif (test_bit(FD_OPEN_SHOULD_FAIL_BIT, &UDRS->flags))\n\t\t\t\tgoto out;\n\t\t}\n\t\tres = -EROFS;\n\t\tif ((mode & FMODE_WRITE) &&\n\t\t    !test_bit(FD_DISK_WRITABLE_BIT, &UDRS->flags))\n\t\t\tgoto out;\n\t}\n\tmutex_unlock(&open_lock);\n\tmutex_unlock(&floppy_mutex);\n\treturn 0;\nout:\n\tUDRS->fd_ref--;\n\n\tif (!UDRS->fd_ref)\n\t\topened_bdev[drive] = NULL;\nout2:\n\tmutex_unlock(&open_lock);\n\tmutex_unlock(&floppy_mutex);\n\treturn res;\n}\n\n/*\n * Check if the disk has been changed or if a change has been faked.\n */\nstatic unsigned int floppy_check_events(struct gendisk *disk,\n\t\t\t\t\tunsigned int clearing)\n{\n\tint drive = (long)disk->private_data;\n\n\tif (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\n\t    test_bit(FD_VERIFY_BIT, &UDRS->flags))\n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\n\tif (time_after(jiffies, UDRS->last_checked + UDP->checkfreq)) {\n\t\tif (lock_fdc(drive))\n\t\t\treturn 0;\n\t\tpoll_drive(false, 0);\n\t\tprocess_fd_request();\n\t}\n\n\tif (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\n\t    test_bit(FD_VERIFY_BIT, &UDRS->flags) ||\n\t    test_bit(drive, &fake_change) ||\n\t    drive_no_geom(drive))\n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\treturn 0;\n}\n\n/*\n * This implements \"read block 0\" for floppy_revalidate().\n * Needed for format autodetection, checking whether there is\n * a disk in the drive, and whether that disk is writable.\n */\n\nstruct rb0_cbdata {\n\tint drive;\n\tstruct completion complete;\n};\n\nstatic void floppy_rb0_cb(struct bio *bio)\n{\n\tstruct rb0_cbdata *cbdata = (struct rb0_cbdata *)bio->bi_private;\n\tint drive = cbdata->drive;\n\n\tif (bio->bi_status) {\n\t\tpr_info(\"floppy: error %d while reading block 0\\n\",\n\t\t\tbio->bi_status);\n\t\tset_bit(FD_OPEN_SHOULD_FAIL_BIT, &UDRS->flags);\n\t}\n\tcomplete(&cbdata->complete);\n}\n\nstatic int __floppy_read_block_0(struct block_device *bdev, int drive)\n{\n\tstruct bio bio;\n\tstruct bio_vec bio_vec;\n\tstruct page *page;\n\tstruct rb0_cbdata cbdata;\n\tsize_t size;\n\n\tpage = alloc_page(GFP_NOIO);\n\tif (!page) {\n\t\tprocess_fd_request();\n\t\treturn -ENOMEM;\n\t}\n\n\tsize = bdev->bd_block_size;\n\tif (!size)\n\t\tsize = 1024;\n\n\tcbdata.drive = drive;\n\n\tbio_init(&bio, &bio_vec, 1);\n\tbio_set_dev(&bio, bdev);\n\tbio_add_page(&bio, page, size, 0);\n\n\tbio.bi_iter.bi_sector = 0;\n\tbio.bi_flags |= (1 << BIO_QUIET);\n\tbio.bi_private = &cbdata;\n\tbio.bi_end_io = floppy_rb0_cb;\n\tbio_set_op_attrs(&bio, REQ_OP_READ, 0);\n\n\tinit_completion(&cbdata.complete);\n\n\tsubmit_bio(&bio);\n\tprocess_fd_request();\n\n\twait_for_completion(&cbdata.complete);\n\n\t__free_page(page);\n\n\treturn 0;\n}\n\n/* revalidate the floppy disk, i.e. trigger format autodetection by reading\n * the bootblock (block 0). \"Autodetection\" is also needed to check whether\n * there is a disk in the drive at all... Thus we also do it for fixed\n * geometry formats */\nstatic int floppy_revalidate(struct gendisk *disk)\n{\n\tint drive = (long)disk->private_data;\n\tint cf;\n\tint res = 0;\n\n\tif (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\n\t    test_bit(FD_VERIFY_BIT, &UDRS->flags) ||\n\t    test_bit(drive, &fake_change) ||\n\t    drive_no_geom(drive)) {\n\t\tif (WARN(atomic_read(&usage_count) == 0,\n\t\t\t \"VFS: revalidate called on non-open device.\\n\"))\n\t\t\treturn -EFAULT;\n\n\t\tres = lock_fdc(drive);\n\t\tif (res)\n\t\t\treturn res;\n\t\tcf = (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\n\t\t      test_bit(FD_VERIFY_BIT, &UDRS->flags));\n\t\tif (!(cf || test_bit(drive, &fake_change) || drive_no_geom(drive))) {\n\t\t\tprocess_fd_request();\t/*already done by another thread */\n\t\t\treturn 0;\n\t\t}\n\t\tUDRS->maxblock = 0;\n\t\tUDRS->maxtrack = 0;\n\t\tif (buffer_drive == drive)\n\t\t\tbuffer_track = -1;\n\t\tclear_bit(drive, &fake_change);\n\t\tclear_bit(FD_DISK_CHANGED_BIT, &UDRS->flags);\n\t\tif (cf)\n\t\t\tUDRS->generation++;\n\t\tif (drive_no_geom(drive)) {\n\t\t\t/* auto-sensing */\n\t\t\tres = __floppy_read_block_0(opened_bdev[drive], drive);\n\t\t} else {\n\t\t\tif (cf)\n\t\t\t\tpoll_drive(false, FD_RAW_NEED_DISK);\n\t\t\tprocess_fd_request();\n\t\t}\n\t}\n\tset_capacity(disk, floppy_sizes[UDRS->fd_device]);\n\treturn res;\n}\n\nstatic const struct block_device_operations floppy_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.open\t\t\t= floppy_open,\n\t.release\t\t= floppy_release,\n\t.ioctl\t\t\t= fd_ioctl,\n\t.getgeo\t\t\t= fd_getgeo,\n\t.check_events\t\t= floppy_check_events,\n\t.revalidate_disk\t= floppy_revalidate,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t\t= fd_compat_ioctl,\n#endif\n};\n\n/*\n * Floppy Driver initialization\n * =============================\n */\n\n/* Determine the floppy disk controller type */\n/* This routine was written by David C. Niemi */\nstatic char __init get_fdc_version(void)\n{\n\tint r;\n\n\toutput_byte(FD_DUMPREGS);\t/* 82072 and better know DUMPREGS */\n\tif (FDCS->reset)\n\t\treturn FDC_NONE;\n\tr = result();\n\tif (r <= 0x00)\n\t\treturn FDC_NONE;\t/* No FDC present ??? */\n\tif ((r == 1) && (reply_buffer[0] == 0x80)) {\n\t\tpr_info(\"FDC %d is an 8272A\\n\", fdc);\n\t\treturn FDC_8272A;\t/* 8272a/765 don't know DUMPREGS */\n\t}\n\tif (r != 10) {\n\t\tpr_info(\"FDC %d init: DUMPREGS: unexpected return of %d bytes.\\n\",\n\t\t\tfdc, r);\n\t\treturn FDC_UNKNOWN;\n\t}\n\n\tif (!fdc_configure()) {\n\t\tpr_info(\"FDC %d is an 82072\\n\", fdc);\n\t\treturn FDC_82072;\t/* 82072 doesn't know CONFIGURE */\n\t}\n\n\toutput_byte(FD_PERPENDICULAR);\n\tif (need_more_output() == MORE_OUTPUT) {\n\t\toutput_byte(0);\n\t} else {\n\t\tpr_info(\"FDC %d is an 82072A\\n\", fdc);\n\t\treturn FDC_82072A;\t/* 82072A as found on Sparcs. */\n\t}\n\n\toutput_byte(FD_UNLOCK);\n\tr = result();\n\tif ((r == 1) && (reply_buffer[0] == 0x80)) {\n\t\tpr_info(\"FDC %d is a pre-1991 82077\\n\", fdc);\n\t\treturn FDC_82077_ORIG;\t/* Pre-1991 82077, doesn't know\n\t\t\t\t\t * LOCK/UNLOCK */\n\t}\n\tif ((r != 1) || (reply_buffer[0] != 0x00)) {\n\t\tpr_info(\"FDC %d init: UNLOCK: unexpected return of %d bytes.\\n\",\n\t\t\tfdc, r);\n\t\treturn FDC_UNKNOWN;\n\t}\n\toutput_byte(FD_PARTID);\n\tr = result();\n\tif (r != 1) {\n\t\tpr_info(\"FDC %d init: PARTID: unexpected return of %d bytes.\\n\",\n\t\t\tfdc, r);\n\t\treturn FDC_UNKNOWN;\n\t}\n\tif (reply_buffer[0] == 0x80) {\n\t\tpr_info(\"FDC %d is a post-1991 82077\\n\", fdc);\n\t\treturn FDC_82077;\t/* Revised 82077AA passes all the tests */\n\t}\n\tswitch (reply_buffer[0] >> 5) {\n\tcase 0x0:\n\t\t/* Either a 82078-1 or a 82078SL running at 5Volt */\n\t\tpr_info(\"FDC %d is an 82078.\\n\", fdc);\n\t\treturn FDC_82078;\n\tcase 0x1:\n\t\tpr_info(\"FDC %d is a 44pin 82078\\n\", fdc);\n\t\treturn FDC_82078;\n\tcase 0x2:\n\t\tpr_info(\"FDC %d is a S82078B\\n\", fdc);\n\t\treturn FDC_S82078B;\n\tcase 0x3:\n\t\tpr_info(\"FDC %d is a National Semiconductor PC87306\\n\", fdc);\n\t\treturn FDC_87306;\n\tdefault:\n\t\tpr_info(\"FDC %d init: 82078 variant with unknown PARTID=%d.\\n\",\n\t\t\tfdc, reply_buffer[0] >> 5);\n\t\treturn FDC_82078_UNKN;\n\t}\n}\t\t\t\t/* get_fdc_version */\n\n/* lilo configuration */\n\nstatic void __init floppy_set_flags(int *ints, int param, int param2)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(default_drive_params); i++) {\n\t\tif (param)\n\t\t\tdefault_drive_params[i].params.flags |= param2;\n\t\telse\n\t\t\tdefault_drive_params[i].params.flags &= ~param2;\n\t}\n\tDPRINT(\"%s flag 0x%x\\n\", param2 ? \"Setting\" : \"Clearing\", param);\n}\n\nstatic void __init daring(int *ints, int param, int param2)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(default_drive_params); i++) {\n\t\tif (param) {\n\t\t\tdefault_drive_params[i].params.select_delay = 0;\n\t\t\tdefault_drive_params[i].params.flags |=\n\t\t\t    FD_SILENT_DCL_CLEAR;\n\t\t} else {\n\t\t\tdefault_drive_params[i].params.select_delay =\n\t\t\t    2 * HZ / 100;\n\t\t\tdefault_drive_params[i].params.flags &=\n\t\t\t    ~FD_SILENT_DCL_CLEAR;\n\t\t}\n\t}\n\tDPRINT(\"Assuming %s floppy hardware\\n\", param ? \"standard\" : \"broken\");\n}\n\nstatic void __init set_cmos(int *ints, int dummy, int dummy2)\n{\n\tint current_drive = 0;\n\n\tif (ints[0] != 2) {\n\t\tDPRINT(\"wrong number of parameters for CMOS\\n\");\n\t\treturn;\n\t}\n\tcurrent_drive = ints[1];\n\tif (current_drive < 0 || current_drive >= 8) {\n\t\tDPRINT(\"bad drive for set_cmos\\n\");\n\t\treturn;\n\t}\n#if N_FDC > 1\n\tif (current_drive >= 4 && !FDC2)\n\t\tFDC2 = 0x370;\n#endif\n\tDP->cmos = ints[2];\n\tDPRINT(\"setting CMOS code to %d\\n\", ints[2]);\n}\n\nstatic struct param_table {\n\tconst char *name;\n\tvoid (*fn) (int *ints, int param, int param2);\n\tint *var;\n\tint def_param;\n\tint param2;\n} config_params[] __initdata = {\n\t{\"allowed_drive_mask\", NULL, &allowed_drive_mask, 0xff, 0}, /* obsolete */\n\t{\"all_drives\", NULL, &allowed_drive_mask, 0xff, 0},\t/* obsolete */\n\t{\"asus_pci\", NULL, &allowed_drive_mask, 0x33, 0},\n\t{\"irq\", NULL, &FLOPPY_IRQ, 6, 0},\n\t{\"dma\", NULL, &FLOPPY_DMA, 2, 0},\n\t{\"daring\", daring, NULL, 1, 0},\n#if N_FDC > 1\n\t{\"two_fdc\", NULL, &FDC2, 0x370, 0},\n\t{\"one_fdc\", NULL, &FDC2, 0, 0},\n#endif\n\t{\"thinkpad\", floppy_set_flags, NULL, 1, FD_INVERTED_DCL},\n\t{\"broken_dcl\", floppy_set_flags, NULL, 1, FD_BROKEN_DCL},\n\t{\"messages\", floppy_set_flags, NULL, 1, FTD_MSG},\n\t{\"silent_dcl_clear\", floppy_set_flags, NULL, 1, FD_SILENT_DCL_CLEAR},\n\t{\"debug\", floppy_set_flags, NULL, 1, FD_DEBUG},\n\t{\"nodma\", NULL, &can_use_virtual_dma, 1, 0},\n\t{\"omnibook\", NULL, &can_use_virtual_dma, 1, 0},\n\t{\"yesdma\", NULL, &can_use_virtual_dma, 0, 0},\n\t{\"fifo_depth\", NULL, &fifo_depth, 0xa, 0},\n\t{\"nofifo\", NULL, &no_fifo, 0x20, 0},\n\t{\"usefifo\", NULL, &no_fifo, 0, 0},\n\t{\"cmos\", set_cmos, NULL, 0, 0},\n\t{\"slow\", NULL, &slow_floppy, 1, 0},\n\t{\"unexpected_interrupts\", NULL, &print_unex, 1, 0},\n\t{\"no_unexpected_interrupts\", NULL, &print_unex, 0, 0},\n\t{\"L40SX\", NULL, &print_unex, 0, 0}\n\n\tEXTRA_FLOPPY_PARAMS\n};\n\nstatic int __init floppy_setup(char *str)\n{\n\tint i;\n\tint param;\n\tint ints[11];\n\n\tstr = get_options(str, ARRAY_SIZE(ints), ints);\n\tif (str) {\n\t\tfor (i = 0; i < ARRAY_SIZE(config_params); i++) {\n\t\t\tif (strcmp(str, config_params[i].name) == 0) {\n\t\t\t\tif (ints[0])\n\t\t\t\t\tparam = ints[1];\n\t\t\t\telse\n\t\t\t\t\tparam = config_params[i].def_param;\n\t\t\t\tif (config_params[i].fn)\n\t\t\t\t\tconfig_params[i].fn(ints, param,\n\t\t\t\t\t\t\t    config_params[i].\n\t\t\t\t\t\t\t    param2);\n\t\t\t\tif (config_params[i].var) {\n\t\t\t\t\tDPRINT(\"%s=%d\\n\", str, param);\n\t\t\t\t\t*config_params[i].var = param;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (str) {\n\t\tDPRINT(\"unknown floppy option [%s]\\n\", str);\n\n\t\tDPRINT(\"allowed options are:\");\n\t\tfor (i = 0; i < ARRAY_SIZE(config_params); i++)\n\t\t\tpr_cont(\" %s\", config_params[i].name);\n\t\tpr_cont(\"\\n\");\n\t} else\n\t\tDPRINT(\"botched floppy option\\n\");\n\tDPRINT(\"Read Documentation/blockdev/floppy.txt\\n\");\n\treturn 0;\n}\n\nstatic int have_no_fdc = -ENODEV;\n\nstatic ssize_t floppy_cmos_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *p = to_platform_device(dev);\n\tint drive;\n\n\tdrive = p->id;\n\treturn sprintf(buf, \"%X\\n\", UDP->cmos);\n}\n\nstatic DEVICE_ATTR(cmos, 0444, floppy_cmos_show, NULL);\n\nstatic struct attribute *floppy_dev_attrs[] = {\n\t&dev_attr_cmos.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(floppy_dev);\n\nstatic void floppy_device_release(struct device *dev)\n{\n}\n\nstatic int floppy_resume(struct device *dev)\n{\n\tint fdc;\n\n\tfor (fdc = 0; fdc < N_FDC; fdc++)\n\t\tif (FDCS->address != -1)\n\t\t\tuser_reset_fdc(-1, FD_RESET_ALWAYS, false);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops floppy_pm_ops = {\n\t.resume = floppy_resume,\n\t.restore = floppy_resume,\n};\n\nstatic struct platform_driver floppy_driver = {\n\t.driver = {\n\t\t   .name = \"floppy\",\n\t\t   .pm = &floppy_pm_ops,\n\t},\n};\n\nstatic const struct blk_mq_ops floppy_mq_ops = {\n\t.queue_rq = floppy_queue_rq,\n};\n\nstatic struct platform_device floppy_device[N_DRIVE];\n\nstatic bool floppy_available(int drive)\n{\n\tif (!(allowed_drive_mask & (1 << drive)))\n\t\treturn false;\n\tif (fdc_state[FDC(drive)].version == FDC_NONE)\n\t\treturn false;\n\treturn true;\n}\n\nstatic struct kobject *floppy_find(dev_t dev, int *part, void *data)\n{\n\tint drive = (*part & 3) | ((*part & 0x80) >> 5);\n\tif (drive >= N_DRIVE || !floppy_available(drive))\n\t\treturn NULL;\n\tif (((*part >> 2) & 0x1f) >= ARRAY_SIZE(floppy_type))\n\t\treturn NULL;\n\t*part = 0;\n\treturn get_disk_and_module(disks[drive]);\n}\n\nstatic int __init do_floppy_init(void)\n{\n\tint i, unit, drive, err;\n\n\tset_debugt();\n\tinterruptjiffies = resultjiffies = jiffies;\n\n#if defined(CONFIG_PPC)\n\tif (check_legacy_ioport(FDC1))\n\t\treturn -ENODEV;\n#endif\n\n\traw_cmd = NULL;\n\n\tfloppy_wq = alloc_ordered_workqueue(\"floppy\", 0);\n\tif (!floppy_wq)\n\t\treturn -ENOMEM;\n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tdisks[drive] = alloc_disk(1);\n\t\tif (!disks[drive]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_put_disk;\n\t\t}\n\n\t\tdisks[drive]->queue = blk_mq_init_sq_queue(&tag_sets[drive],\n\t\t\t\t\t\t\t   &floppy_mq_ops, 2,\n\t\t\t\t\t\t\t   BLK_MQ_F_SHOULD_MERGE);\n\t\tif (IS_ERR(disks[drive]->queue)) {\n\t\t\terr = PTR_ERR(disks[drive]->queue);\n\t\t\tdisks[drive]->queue = NULL;\n\t\t\tgoto out_put_disk;\n\t\t}\n\n\t\tblk_queue_bounce_limit(disks[drive]->queue, BLK_BOUNCE_HIGH);\n\t\tblk_queue_max_hw_sectors(disks[drive]->queue, 64);\n\t\tdisks[drive]->major = FLOPPY_MAJOR;\n\t\tdisks[drive]->first_minor = TOMINOR(drive);\n\t\tdisks[drive]->fops = &floppy_fops;\n\t\tdisks[drive]->events = DISK_EVENT_MEDIA_CHANGE;\n\t\tsprintf(disks[drive]->disk_name, \"fd%d\", drive);\n\n\t\ttimer_setup(&motor_off_timer[drive], motor_off_callback, 0);\n\t}\n\n\terr = register_blkdev(FLOPPY_MAJOR, \"fd\");\n\tif (err)\n\t\tgoto out_put_disk;\n\n\terr = platform_driver_register(&floppy_driver);\n\tif (err)\n\t\tgoto out_unreg_blkdev;\n\n\tblk_register_region(MKDEV(FLOPPY_MAJOR, 0), 256, THIS_MODULE,\n\t\t\t    floppy_find, NULL, NULL);\n\n\tfor (i = 0; i < 256; i++)\n\t\tif (ITYPE(i))\n\t\t\tfloppy_sizes[i] = floppy_type[ITYPE(i)].size;\n\t\telse\n\t\t\tfloppy_sizes[i] = MAX_DISK_SIZE << 1;\n\n\treschedule_timeout(MAXTIMEOUT, \"floppy init\");\n\tconfig_types();\n\n\tfor (i = 0; i < N_FDC; i++) {\n\t\tfdc = i;\n\t\tmemset(FDCS, 0, sizeof(*FDCS));\n\t\tFDCS->dtr = -1;\n\t\tFDCS->dor = 0x4;\n#if defined(__sparc__) || defined(__mc68000__)\n\t/*sparcs/sun3x don't have a DOR reset which we can fall back on to */\n#ifdef __mc68000__\n\t\tif (MACH_IS_SUN3X)\n#endif\n\t\t\tFDCS->version = FDC_82072A;\n#endif\n\t}\n\n\tuse_virtual_dma = can_use_virtual_dma & 1;\n\tfdc_state[0].address = FDC1;\n\tif (fdc_state[0].address == -1) {\n\t\tcancel_delayed_work(&fd_timeout);\n\t\terr = -ENODEV;\n\t\tgoto out_unreg_region;\n\t}\n#if N_FDC > 1\n\tfdc_state[1].address = FDC2;\n#endif\n\n\tfdc = 0;\t\t/* reset fdc in case of unexpected interrupt */\n\terr = floppy_grab_irq_and_dma();\n\tif (err) {\n\t\tcancel_delayed_work(&fd_timeout);\n\t\terr = -EBUSY;\n\t\tgoto out_unreg_region;\n\t}\n\n\t/* initialise drive state */\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tmemset(UDRS, 0, sizeof(*UDRS));\n\t\tmemset(UDRWE, 0, sizeof(*UDRWE));\n\t\tset_bit(FD_DISK_NEWCHANGE_BIT, &UDRS->flags);\n\t\tset_bit(FD_DISK_CHANGED_BIT, &UDRS->flags);\n\t\tset_bit(FD_VERIFY_BIT, &UDRS->flags);\n\t\tUDRS->fd_device = -1;\n\t\tfloppy_track_buffer = NULL;\n\t\tmax_buffer_sectors = 0;\n\t}\n\t/*\n\t * Small 10 msec delay to let through any interrupt that\n\t * initialization might have triggered, to not\n\t * confuse detection:\n\t */\n\tmsleep(10);\n\n\tfor (i = 0; i < N_FDC; i++) {\n\t\tfdc = i;\n\t\tFDCS->driver_version = FD_DRIVER_VERSION;\n\t\tfor (unit = 0; unit < 4; unit++)\n\t\t\tFDCS->track[unit] = 0;\n\t\tif (FDCS->address == -1)\n\t\t\tcontinue;\n\t\tFDCS->rawcmd = 2;\n\t\tif (user_reset_fdc(-1, FD_RESET_ALWAYS, false)) {\n\t\t\t/* free ioports reserved by floppy_grab_irq_and_dma() */\n\t\t\tfloppy_release_regions(fdc);\n\t\t\tFDCS->address = -1;\n\t\t\tFDCS->version = FDC_NONE;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Try to determine the floppy controller type */\n\t\tFDCS->version = get_fdc_version();\n\t\tif (FDCS->version == FDC_NONE) {\n\t\t\t/* free ioports reserved by floppy_grab_irq_and_dma() */\n\t\t\tfloppy_release_regions(fdc);\n\t\t\tFDCS->address = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (can_use_virtual_dma == 2 && FDCS->version < FDC_82072A)\n\t\t\tcan_use_virtual_dma = 0;\n\n\t\thave_no_fdc = 0;\n\t\t/* Not all FDCs seem to be able to handle the version command\n\t\t * properly, so force a reset for the standard FDC clones,\n\t\t * to avoid interrupt garbage.\n\t\t */\n\t\tuser_reset_fdc(-1, FD_RESET_ALWAYS, false);\n\t}\n\tfdc = 0;\n\tcancel_delayed_work(&fd_timeout);\n\tcurrent_drive = 0;\n\tinitialized = true;\n\tif (have_no_fdc) {\n\t\tDPRINT(\"no floppy controllers found\\n\");\n\t\terr = have_no_fdc;\n\t\tgoto out_release_dma;\n\t}\n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tif (!floppy_available(drive))\n\t\t\tcontinue;\n\n\t\tfloppy_device[drive].name = floppy_device_name;\n\t\tfloppy_device[drive].id = drive;\n\t\tfloppy_device[drive].dev.release = floppy_device_release;\n\t\tfloppy_device[drive].dev.groups = floppy_dev_groups;\n\n\t\terr = platform_device_register(&floppy_device[drive]);\n\t\tif (err)\n\t\t\tgoto out_remove_drives;\n\n\t\t/* to be cleaned up... */\n\t\tdisks[drive]->private_data = (void *)(long)drive;\n\t\tdisks[drive]->flags |= GENHD_FL_REMOVABLE;\n\t\tdevice_add_disk(&floppy_device[drive].dev, disks[drive], NULL);\n\t}\n\n\treturn 0;\n\nout_remove_drives:\n\twhile (drive--) {\n\t\tif (floppy_available(drive)) {\n\t\t\tdel_gendisk(disks[drive]);\n\t\t\tplatform_device_unregister(&floppy_device[drive]);\n\t\t}\n\t}\nout_release_dma:\n\tif (atomic_read(&usage_count))\n\t\tfloppy_release_irq_and_dma();\nout_unreg_region:\n\tblk_unregister_region(MKDEV(FLOPPY_MAJOR, 0), 256);\n\tplatform_driver_unregister(&floppy_driver);\nout_unreg_blkdev:\n\tunregister_blkdev(FLOPPY_MAJOR, \"fd\");\nout_put_disk:\n\tdestroy_workqueue(floppy_wq);\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tif (!disks[drive])\n\t\t\tbreak;\n\t\tif (disks[drive]->queue) {\n\t\t\tdel_timer_sync(&motor_off_timer[drive]);\n\t\t\tblk_cleanup_queue(disks[drive]->queue);\n\t\t\tdisks[drive]->queue = NULL;\n\t\t\tblk_mq_free_tag_set(&tag_sets[drive]);\n\t\t}\n\t\tput_disk(disks[drive]);\n\t}\n\treturn err;\n}\n\n#ifndef MODULE\nstatic __init void floppy_async_init(void *data, async_cookie_t cookie)\n{\n\tdo_floppy_init();\n}\n#endif\n\nstatic int __init floppy_init(void)\n{\n#ifdef MODULE\n\treturn do_floppy_init();\n#else\n\t/* Don't hold up the bootup by the floppy initialization */\n\tasync_schedule(floppy_async_init, NULL);\n\treturn 0;\n#endif\n}\n\nstatic const struct io_region {\n\tint offset;\n\tint size;\n} io_regions[] = {\n\t{ 2, 1 },\n\t/* address + 3 is sometimes reserved by pnp bios for motherboard */\n\t{ 4, 2 },\n\t/* address + 6 is reserved, and may be taken by IDE.\n\t * Unfortunately, Adaptec doesn't know this :-(, */\n\t{ 7, 1 },\n};\n\nstatic void floppy_release_allocated_regions(int fdc, const struct io_region *p)\n{\n\twhile (p != io_regions) {\n\t\tp--;\n\t\trelease_region(FDCS->address + p->offset, p->size);\n\t}\n}\n\n#define ARRAY_END(X) (&((X)[ARRAY_SIZE(X)]))\n\nstatic int floppy_request_regions(int fdc)\n{\n\tconst struct io_region *p;\n\n\tfor (p = io_regions; p < ARRAY_END(io_regions); p++) {\n\t\tif (!request_region(FDCS->address + p->offset,\n\t\t\t\t    p->size, \"floppy\")) {\n\t\t\tDPRINT(\"Floppy io-port 0x%04lx in use\\n\",\n\t\t\t       FDCS->address + p->offset);\n\t\t\tfloppy_release_allocated_regions(fdc, p);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void floppy_release_regions(int fdc)\n{\n\tfloppy_release_allocated_regions(fdc, ARRAY_END(io_regions));\n}\n\nstatic int floppy_grab_irq_and_dma(void)\n{\n\tif (atomic_inc_return(&usage_count) > 1)\n\t\treturn 0;\n\n\t/*\n\t * We might have scheduled a free_irq(), wait it to\n\t * drain first:\n\t */\n\tflush_workqueue(floppy_wq);\n\n\tif (fd_request_irq()) {\n\t\tDPRINT(\"Unable to grab IRQ%d for the floppy driver\\n\",\n\t\t       FLOPPY_IRQ);\n\t\tatomic_dec(&usage_count);\n\t\treturn -1;\n\t}\n\tif (fd_request_dma()) {\n\t\tDPRINT(\"Unable to grab DMA%d for the floppy driver\\n\",\n\t\t       FLOPPY_DMA);\n\t\tif (can_use_virtual_dma & 2)\n\t\t\tuse_virtual_dma = can_use_virtual_dma = 1;\n\t\tif (!(can_use_virtual_dma & 1)) {\n\t\t\tfd_free_irq();\n\t\t\tatomic_dec(&usage_count);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (fdc = 0; fdc < N_FDC; fdc++) {\n\t\tif (FDCS->address != -1) {\n\t\t\tif (floppy_request_regions(fdc))\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tfor (fdc = 0; fdc < N_FDC; fdc++) {\n\t\tif (FDCS->address != -1) {\n\t\t\treset_fdc_info(1);\n\t\t\tfd_outb(FDCS->dor, FD_DOR);\n\t\t}\n\t}\n\tfdc = 0;\n\tset_dor(0, ~0, 8);\t/* avoid immediate interrupt */\n\n\tfor (fdc = 0; fdc < N_FDC; fdc++)\n\t\tif (FDCS->address != -1)\n\t\t\tfd_outb(FDCS->dor, FD_DOR);\n\t/*\n\t * The driver will try and free resources and relies on us\n\t * to know if they were allocated or not.\n\t */\n\tfdc = 0;\n\tirqdma_allocated = 1;\n\treturn 0;\ncleanup:\n\tfd_free_irq();\n\tfd_free_dma();\n\twhile (--fdc >= 0)\n\t\tfloppy_release_regions(fdc);\n\tatomic_dec(&usage_count);\n\treturn -1;\n}\n\nstatic void floppy_release_irq_and_dma(void)\n{\n\tint old_fdc;\n#ifndef __sparc__\n\tint drive;\n#endif\n\tlong tmpsize;\n\tunsigned long tmpaddr;\n\n\tif (!atomic_dec_and_test(&usage_count))\n\t\treturn;\n\n\tif (irqdma_allocated) {\n\t\tfd_disable_dma();\n\t\tfd_free_dma();\n\t\tfd_free_irq();\n\t\tirqdma_allocated = 0;\n\t}\n\tset_dor(0, ~0, 8);\n#if N_FDC > 1\n\tset_dor(1, ~8, 0);\n#endif\n\n\tif (floppy_track_buffer && max_buffer_sectors) {\n\t\ttmpsize = max_buffer_sectors * 1024;\n\t\ttmpaddr = (unsigned long)floppy_track_buffer;\n\t\tfloppy_track_buffer = NULL;\n\t\tmax_buffer_sectors = 0;\n\t\tbuffer_min = buffer_max = -1;\n\t\tfd_dma_mem_free(tmpaddr, tmpsize);\n\t}\n#ifndef __sparc__\n\tfor (drive = 0; drive < N_FDC * 4; drive++)\n\t\tif (timer_pending(motor_off_timer + drive))\n\t\t\tpr_info(\"motor off timer %d still active\\n\", drive);\n#endif\n\n\tif (delayed_work_pending(&fd_timeout))\n\t\tpr_info(\"floppy timer still active:%s\\n\", timeout_message);\n\tif (delayed_work_pending(&fd_timer))\n\t\tpr_info(\"auxiliary floppy timer still active\\n\");\n\tif (work_pending(&floppy_work))\n\t\tpr_info(\"work still pending\\n\");\n\told_fdc = fdc;\n\tfor (fdc = 0; fdc < N_FDC; fdc++)\n\t\tif (FDCS->address != -1)\n\t\t\tfloppy_release_regions(fdc);\n\tfdc = old_fdc;\n}\n\n#ifdef MODULE\n\nstatic char *floppy;\n\nstatic void __init parse_floppy_cfg_string(char *cfg)\n{\n\tchar *ptr;\n\n\twhile (*cfg) {\n\t\tptr = cfg;\n\t\twhile (*cfg && *cfg != ' ' && *cfg != '\\t')\n\t\t\tcfg++;\n\t\tif (*cfg) {\n\t\t\t*cfg = '\\0';\n\t\t\tcfg++;\n\t\t}\n\t\tif (*ptr)\n\t\t\tfloppy_setup(ptr);\n\t}\n}\n\nstatic int __init floppy_module_init(void)\n{\n\tif (floppy)\n\t\tparse_floppy_cfg_string(floppy);\n\treturn floppy_init();\n}\nmodule_init(floppy_module_init);\n\nstatic void __exit floppy_module_exit(void)\n{\n\tint drive;\n\n\tblk_unregister_region(MKDEV(FLOPPY_MAJOR, 0), 256);\n\tunregister_blkdev(FLOPPY_MAJOR, \"fd\");\n\tplatform_driver_unregister(&floppy_driver);\n\n\tdestroy_workqueue(floppy_wq);\n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tdel_timer_sync(&motor_off_timer[drive]);\n\n\t\tif (floppy_available(drive)) {\n\t\t\tdel_gendisk(disks[drive]);\n\t\t\tplatform_device_unregister(&floppy_device[drive]);\n\t\t}\n\t\tblk_cleanup_queue(disks[drive]->queue);\n\t\tblk_mq_free_tag_set(&tag_sets[drive]);\n\n\t\t/*\n\t\t * These disks have not called add_disk().  Don't put down\n\t\t * queue reference in put_disk().\n\t\t */\n\t\tif (!(allowed_drive_mask & (1 << drive)) ||\n\t\t    fdc_state[FDC(drive)].version == FDC_NONE)\n\t\t\tdisks[drive]->queue = NULL;\n\n\t\tput_disk(disks[drive]);\n\t}\n\n\tcancel_delayed_work_sync(&fd_timeout);\n\tcancel_delayed_work_sync(&fd_timer);\n\n\tif (atomic_read(&usage_count))\n\t\tfloppy_release_irq_and_dma();\n\n\t/* eject disk, if any */\n\tfd_eject(0);\n}\n\nmodule_exit(floppy_module_exit);\n\nmodule_param(floppy, charp, 0);\nmodule_param(FLOPPY_IRQ, int, 0);\nmodule_param(FLOPPY_DMA, int, 0);\nMODULE_AUTHOR(\"Alain L. Knaff\");\nMODULE_SUPPORTED_DEVICE(\"fd\");\nMODULE_LICENSE(\"GPL\");\n\n/* This doesn't actually get used other than for module information */\nstatic const struct pnp_device_id floppy_pnpids[] = {\n\t{\"PNP0700\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pnp, floppy_pnpids);\n\n#else\n\n__setup(\"floppy=\", floppy_setup);\nmodule_init(floppy_init)\n#endif\n\nMODULE_ALIAS_BLOCKDEV_MAJOR(FLOPPY_MAJOR);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n *  linux/drivers/block/floppy.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n *  Copyright (C) 1993, 1994  Alain Knaff\n *  Copyright (C) 1998 Alan Cox\n */\n\n/*\n * 02.12.91 - Changed to static variables to indicate need for reset\n * and recalibrate. This makes some things easier (output_byte reset\n * checking etc), and means less interrupt jumping in case of errors,\n * so the code is hopefully easier to understand.\n */\n\n/*\n * This file is certainly a mess. I've tried my best to get it working,\n * but I don't like programming floppies, and I have only one anyway.\n * Urgel. I should check for more errors, and do more graceful error\n * recovery. Seems there are problems with several drives. I've tried to\n * correct them. No promises.\n */\n\n/*\n * As with hd.c, all routines within this file can (and will) be called\n * by interrupts, so extreme caution is needed. A hardware interrupt\n * handler may not sleep, or a kernel panic will happen. Thus I cannot\n * call \"floppy-on\" directly, but have to set a special timer interrupt\n * etc.\n */\n\n/*\n * 28.02.92 - made track-buffering routines, based on the routines written\n * by entropy@wintermute.wpi.edu (Lawrence Foard). Linus.\n */\n\n/*\n * Automatic floppy-detection and formatting written by Werner Almesberger\n * (almesber@nessie.cs.id.ethz.ch), who also corrected some problems with\n * the floppy-change signal detection.\n */\n\n/*\n * 1992/7/22 -- Hennus Bergman: Added better error reporting, fixed\n * FDC data overrun bug, added some preliminary stuff for vertical\n * recording support.\n *\n * 1992/9/17: Added DMA allocation & DMA functions. -- hhb.\n *\n * TODO: Errors are still not counted properly.\n */\n\n/* 1992/9/20\n * Modifications for ``Sector Shifting'' by Rob Hooft (hooft@chem.ruu.nl)\n * modeled after the freeware MS-DOS program fdformat/88 V1.8 by\n * Christoph H. Hochst\\\"atter.\n * I have fixed the shift values to the ones I always use. Maybe a new\n * ioctl() should be created to be able to modify them.\n * There is a bug in the driver that makes it impossible to format a\n * floppy as the first thing after bootup.\n */\n\n/*\n * 1993/4/29 -- Linus -- cleaned up the timer handling in the kernel, and\n * this helped the floppy driver as well. Much cleaner, and still seems to\n * work.\n */\n\n/* 1994/6/24 --bbroad-- added the floppy table entries and made\n * minor modifications to allow 2.88 floppies to be run.\n */\n\n/* 1994/7/13 -- Paul Vojta -- modified the probing code to allow three or more\n * disk types.\n */\n\n/*\n * 1994/8/8 -- Alain Knaff -- Switched to fdpatch driver: Support for bigger\n * format bug fixes, but unfortunately some new bugs too...\n */\n\n/* 1994/9/17 -- Koen Holtman -- added logging of physical floppy write\n * errors to allow safe writing by specialized programs.\n */\n\n/* 1995/4/24 -- Dan Fandrich -- added support for Commodore 1581 3.5\" disks\n * by defining bit 1 of the \"stretch\" parameter to mean put sectors on the\n * opposite side of the disk, leaving the sector IDs alone (i.e. Commodore's\n * drives are \"upside-down\").\n */\n\n/*\n * 1995/8/26 -- Andreas Busse -- added Mips support.\n */\n\n/*\n * 1995/10/18 -- Ralf Baechle -- Portability cleanup; move machine dependent\n * features to asm/floppy.h.\n */\n\n/*\n * 1998/1/21 -- Richard Gooch <rgooch@atnf.csiro.au> -- devfs support\n */\n\n/*\n * 1998/05/07 -- Russell King -- More portability cleanups; moved definition of\n * interrupt and dma channel to asm/floppy.h. Cleaned up some formatting &\n * use of '0' for NULL.\n */\n\n/*\n * 1998/06/07 -- Alan Cox -- Merged the 2.0.34 fixes for resource allocation\n * failures.\n */\n\n/*\n * 1998/09/20 -- David Weinehall -- Added slow-down code for buggy PS/2-drives.\n */\n\n/*\n * 1999/08/13 -- Paul Slootman -- floppy stopped working on Alpha after 24\n * days, 6 hours, 32 minutes and 32 seconds (i.e. MAXINT jiffies; ints were\n * being used to store jiffies, which are unsigned longs).\n */\n\n/*\n * 2000/08/28 -- Arnaldo Carvalho de Melo <acme@conectiva.com.br>\n * - get rid of check_region\n * - s/suser/capable/\n */\n\n/*\n * 2001/08/26 -- Paul Gortmaker - fix insmod oops on machines with no\n * floppy controller (lingering task on list after module is gone... boom.)\n */\n\n/*\n * 2002/02/07 -- Anton Altaparmakov - Fix io ports reservation to correct range\n * (0x3f2-0x3f5, 0x3f7). This fix is a bit of a hack but the proper fix\n * requires many non-obvious changes in arch dependent code.\n */\n\n/* 2003/07/28 -- Daniele Bellucci <bellucda@tiscali.it>.\n * Better audit of register_blkdev.\n */\n\n#undef  FLOPPY_SILENT_DCL_CLEAR\n\n#define REALLY_SLOW_IO\n\n#define DEBUGT 2\n\n#define DPRINT(format, args...) \\\n\tpr_info(\"floppy%d: \" format, current_drive, ##args)\n\n#define DCL_DEBUG\t\t/* debug disk change line */\n#ifdef DCL_DEBUG\n#define debug_dcl(test, fmt, args...) \\\n\tdo { if ((test) & FD_DEBUG) DPRINT(fmt, ##args); } while (0)\n#else\n#define debug_dcl(test, fmt, args...) \\\n\tdo { if (0) DPRINT(fmt, ##args); } while (0)\n#endif\n\n/* do print messages for unexpected interrupts */\nstatic int print_unex = 1;\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/workqueue.h>\n#define FDPATCHES\n#include <linux/fdreg.h>\n#include <linux/fd.h>\n#include <linux/hdreg.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/string.h>\n#include <linux/jiffies.h>\n#include <linux/fcntl.h>\n#include <linux/delay.h>\n#include <linux/mc146818rtc.h>\t/* CMOS defines */\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mutex.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/compat.h>\n\n/*\n * PS/2 floppies have much slower step rates than regular floppies.\n * It's been recommended that take about 1/4 of the default speed\n * in some more extreme cases.\n */\nstatic DEFINE_MUTEX(floppy_mutex);\nstatic int slow_floppy;\n\n#include <asm/dma.h>\n#include <asm/irq.h>\n\nstatic int FLOPPY_IRQ = 6;\nstatic int FLOPPY_DMA = 2;\nstatic int can_use_virtual_dma = 2;\n/* =======\n * can use virtual DMA:\n * 0 = use of virtual DMA disallowed by config\n * 1 = use of virtual DMA prescribed by config\n * 2 = no virtual DMA preference configured.  By default try hard DMA,\n * but fall back on virtual DMA when not enough memory available\n */\n\nstatic int use_virtual_dma;\n/* =======\n * use virtual DMA\n * 0 using hard DMA\n * 1 using virtual DMA\n * This variable is set to virtual when a DMA mem problem arises, and\n * reset back in floppy_grab_irq_and_dma.\n * It is not safe to reset it in other circumstances, because the floppy\n * driver may have several buffers in use at once, and we do currently not\n * record each buffers capabilities\n */\n\nstatic DEFINE_SPINLOCK(floppy_lock);\n\nstatic unsigned short virtual_dma_port = 0x3f0;\nirqreturn_t floppy_interrupt(int irq, void *dev_id);\nstatic int set_dor(int fdc, char mask, char data);\n\n#define K_64\t0x10000\t\t/* 64KB */\n\n/* the following is the mask of allowed drives. By default units 2 and\n * 3 of both floppy controllers are disabled, because switching on the\n * motor of these drives causes system hangs on some PCI computers. drive\n * 0 is the low bit (0x1), and drive 7 is the high bit (0x80). Bits are on if\n * a drive is allowed.\n *\n * NOTE: This must come before we include the arch floppy header because\n *       some ports reference this variable from there. -DaveM\n */\n\nstatic int allowed_drive_mask = 0x33;\n\n#include <asm/floppy.h>\n\nstatic int irqdma_allocated;\n\n#include <linux/blk-mq.h>\n#include <linux/blkpg.h>\n#include <linux/cdrom.h>\t/* for the compatibility eject ioctl */\n#include <linux/completion.h>\n\nstatic LIST_HEAD(floppy_reqs);\nstatic struct request *current_req;\nstatic int set_next_request(void);\n\n#ifndef fd_get_dma_residue\n#define fd_get_dma_residue() get_dma_residue(FLOPPY_DMA)\n#endif\n\n/* Dma Memory related stuff */\n\n#ifndef fd_dma_mem_free\n#define fd_dma_mem_free(addr, size) free_pages(addr, get_order(size))\n#endif\n\n#ifndef fd_dma_mem_alloc\n#define fd_dma_mem_alloc(size) __get_dma_pages(GFP_KERNEL, get_order(size))\n#endif\n\n#ifndef fd_cacheflush\n#define fd_cacheflush(addr, size) /* nothing... */\n#endif\n\nstatic inline void fallback_on_nodma_alloc(char **addr, size_t l)\n{\n#ifdef FLOPPY_CAN_FALLBACK_ON_NODMA\n\tif (*addr)\n\t\treturn;\t\t/* we have the memory */\n\tif (can_use_virtual_dma != 2)\n\t\treturn;\t\t/* no fallback allowed */\n\tpr_info(\"DMA memory shortage. Temporarily falling back on virtual DMA\\n\");\n\t*addr = (char *)nodma_mem_alloc(l);\n#else\n\treturn;\n#endif\n}\n\n/* End dma memory related stuff */\n\nstatic unsigned long fake_change;\nstatic bool initialized;\n\n#define ITYPE(x)\t(((x) >> 2) & 0x1f)\n#define TOMINOR(x)\t((x & 3) | ((x & 4) << 5))\n#define UNIT(x)\t\t((x) & 0x03)\t\t/* drive on fdc */\n#define FDC(x)\t\t(((x) & 0x04) >> 2)\t/* fdc of drive */\n\t/* reverse mapping from unit and fdc to drive */\n#define REVDRIVE(fdc, unit) ((unit) + ((fdc) << 2))\n\n#define DP\t(&drive_params[current_drive])\n#define DRS\t(&drive_state[current_drive])\n#define DRWE\t(&write_errors[current_drive])\n#define FDCS\t(&fdc_state[fdc])\n\n#define UDP\t(&drive_params[drive])\n#define UDRS\t(&drive_state[drive])\n#define UDRWE\t(&write_errors[drive])\n#define UFDCS\t(&fdc_state[FDC(drive)])\n\n#define PH_HEAD(floppy, head) (((((floppy)->stretch & 2) >> 1) ^ head) << 2)\n#define STRETCH(floppy)\t((floppy)->stretch & FD_STRETCH)\n\n/* read/write */\n#define COMMAND\t\t(raw_cmd->cmd[0])\n#define DR_SELECT\t(raw_cmd->cmd[1])\n#define TRACK\t\t(raw_cmd->cmd[2])\n#define HEAD\t\t(raw_cmd->cmd[3])\n#define SECTOR\t\t(raw_cmd->cmd[4])\n#define SIZECODE\t(raw_cmd->cmd[5])\n#define SECT_PER_TRACK\t(raw_cmd->cmd[6])\n#define GAP\t\t(raw_cmd->cmd[7])\n#define SIZECODE2\t(raw_cmd->cmd[8])\n#define NR_RW 9\n\n/* format */\n#define F_SIZECODE\t(raw_cmd->cmd[2])\n#define F_SECT_PER_TRACK (raw_cmd->cmd[3])\n#define F_GAP\t\t(raw_cmd->cmd[4])\n#define F_FILL\t\t(raw_cmd->cmd[5])\n#define NR_F 6\n\n/*\n * Maximum disk size (in kilobytes).\n * This default is used whenever the current disk size is unknown.\n * [Now it is rather a minimum]\n */\n#define MAX_DISK_SIZE 4\t\t/* 3984 */\n\n/*\n * globals used by 'result()'\n */\n#define MAX_REPLIES 16\nstatic unsigned char reply_buffer[MAX_REPLIES];\nstatic int inr;\t\t/* size of reply buffer, when called from interrupt */\n#define ST0\t\t(reply_buffer[0])\n#define ST1\t\t(reply_buffer[1])\n#define ST2\t\t(reply_buffer[2])\n#define ST3\t\t(reply_buffer[0])\t/* result of GETSTATUS */\n#define R_TRACK\t\t(reply_buffer[3])\n#define R_HEAD\t\t(reply_buffer[4])\n#define R_SECTOR\t(reply_buffer[5])\n#define R_SIZECODE\t(reply_buffer[6])\n\n#define SEL_DLY\t\t(2 * HZ / 100)\n\n/*\n * this struct defines the different floppy drive types.\n */\nstatic struct {\n\tstruct floppy_drive_params params;\n\tconst char *name;\t/* name printed while booting */\n} default_drive_params[] = {\n/* NOTE: the time values in jiffies should be in msec!\n CMOS drive type\n  |     Maximum data rate supported by drive type\n  |     |   Head load time, msec\n  |     |   |   Head unload time, msec (not used)\n  |     |   |   |     Step rate interval, usec\n  |     |   |   |     |       Time needed for spinup time (jiffies)\n  |     |   |   |     |       |      Timeout for spinning down (jiffies)\n  |     |   |   |     |       |      |   Spindown offset (where disk stops)\n  |     |   |   |     |       |      |   |     Select delay\n  |     |   |   |     |       |      |   |     |     RPS\n  |     |   |   |     |       |      |   |     |     |    Max number of tracks\n  |     |   |   |     |       |      |   |     |     |    |     Interrupt timeout\n  |     |   |   |     |       |      |   |     |     |    |     |   Max nonintlv. sectors\n  |     |   |   |     |       |      |   |     |     |    |     |   | -Max Errors- flags */\n{{0,  500, 16, 16, 8000,    1*HZ, 3*HZ,  0, SEL_DLY, 5,  80, 3*HZ, 20, {3,1,2,0,2}, 0,\n      0, { 7, 4, 8, 2, 1, 5, 3,10}, 3*HZ/2, 0 }, \"unknown\" },\n\n{{1,  300, 16, 16, 8000,    1*HZ, 3*HZ,  0, SEL_DLY, 5,  40, 3*HZ, 17, {3,1,2,0,2}, 0,\n      0, { 1, 0, 0, 0, 0, 0, 0, 0}, 3*HZ/2, 1 }, \"360K PC\" }, /*5 1/4 360 KB PC*/\n\n{{2,  500, 16, 16, 6000, 4*HZ/10, 3*HZ, 14, SEL_DLY, 6,  83, 3*HZ, 17, {3,1,2,0,2}, 0,\n      0, { 2, 5, 6,23,10,20,12, 0}, 3*HZ/2, 2 }, \"1.2M\" }, /*5 1/4 HD AT*/\n\n{{3,  250, 16, 16, 3000,    1*HZ, 3*HZ,  0, SEL_DLY, 5,  83, 3*HZ, 20, {3,1,2,0,2}, 0,\n      0, { 4,22,21,30, 3, 0, 0, 0}, 3*HZ/2, 4 }, \"720k\" }, /*3 1/2 DD*/\n\n{{4,  500, 16, 16, 4000, 4*HZ/10, 3*HZ, 10, SEL_DLY, 5,  83, 3*HZ, 20, {3,1,2,0,2}, 0,\n      0, { 7, 4,25,22,31,21,29,11}, 3*HZ/2, 7 }, \"1.44M\" }, /*3 1/2 HD*/\n\n{{5, 1000, 15,  8, 3000, 4*HZ/10, 3*HZ, 10, SEL_DLY, 5,  83, 3*HZ, 40, {3,1,2,0,2}, 0,\n      0, { 7, 8, 4,25,28,22,31,21}, 3*HZ/2, 8 }, \"2.88M AMI BIOS\" }, /*3 1/2 ED*/\n\n{{6, 1000, 15,  8, 3000, 4*HZ/10, 3*HZ, 10, SEL_DLY, 5,  83, 3*HZ, 40, {3,1,2,0,2}, 0,\n      0, { 7, 8, 4,25,28,22,31,21}, 3*HZ/2, 8 }, \"2.88M\" } /*3 1/2 ED*/\n/*    |  --autodetected formats---    |      |      |\n *    read_track                      |      |    Name printed when booting\n *\t\t\t\t      |     Native format\n *\t            Frequency of disk change checks */\n};\n\nstatic struct floppy_drive_params drive_params[N_DRIVE];\nstatic struct floppy_drive_struct drive_state[N_DRIVE];\nstatic struct floppy_write_errors write_errors[N_DRIVE];\nstatic struct timer_list motor_off_timer[N_DRIVE];\nstatic struct gendisk *disks[N_DRIVE];\nstatic struct blk_mq_tag_set tag_sets[N_DRIVE];\nstatic struct block_device *opened_bdev[N_DRIVE];\nstatic DEFINE_MUTEX(open_lock);\nstatic struct floppy_raw_cmd *raw_cmd, default_raw_cmd;\n\n/*\n * This struct defines the different floppy types.\n *\n * Bit 0 of 'stretch' tells if the tracks need to be doubled for some\n * types (e.g. 360kB diskette in 1.2MB drive, etc.).  Bit 1 of 'stretch'\n * tells if the disk is in Commodore 1581 format, which means side 0 sectors\n * are located on side 1 of the disk but with a side 0 ID, and vice-versa.\n * This is the same as the Sharp MZ-80 5.25\" CP/M disk format, except that the\n * 1581's logical side 0 is on physical side 1, whereas the Sharp's logical\n * side 0 is on physical side 0 (but with the misnamed sector IDs).\n * 'stretch' should probably be renamed to something more general, like\n * 'options'.\n *\n * Bits 2 through 9 of 'stretch' tell the number of the first sector.\n * The LSB (bit 2) is flipped. For most disks, the first sector\n * is 1 (represented by 0x00<<2).  For some CP/M and music sampler\n * disks (such as Ensoniq EPS 16plus) it is 0 (represented as 0x01<<2).\n * For Amstrad CPC disks it is 0xC1 (represented as 0xC0<<2).\n *\n * Other parameters should be self-explanatory (see also setfdprm(8)).\n */\n/*\n\t    Size\n\t     |  Sectors per track\n\t     |  | Head\n\t     |  | |  Tracks\n\t     |  | |  | Stretch\n\t     |  | |  | |  Gap 1 size\n\t     |  | |  | |    |  Data rate, | 0x40 for perp\n\t     |  | |  | |    |    |  Spec1 (stepping rate, head unload\n\t     |  | |  | |    |    |    |    /fmt gap (gap2) */\nstatic struct floppy_struct floppy_type[32] = {\n\t{    0, 0,0, 0,0,0x00,0x00,0x00,0x00,NULL    },\t/*  0 no testing    */\n\t{  720, 9,2,40,0,0x2A,0x02,0xDF,0x50,\"d360\"  }, /*  1 360KB PC      */\n\t{ 2400,15,2,80,0,0x1B,0x00,0xDF,0x54,\"h1200\" },\t/*  2 1.2MB AT      */\n\t{  720, 9,1,80,0,0x2A,0x02,0xDF,0x50,\"D360\"  },\t/*  3 360KB SS 3.5\" */\n\t{ 1440, 9,2,80,0,0x2A,0x02,0xDF,0x50,\"D720\"  },\t/*  4 720KB 3.5\"    */\n\t{  720, 9,2,40,1,0x23,0x01,0xDF,0x50,\"h360\"  },\t/*  5 360KB AT      */\n\t{ 1440, 9,2,80,0,0x23,0x01,0xDF,0x50,\"h720\"  },\t/*  6 720KB AT      */\n\t{ 2880,18,2,80,0,0x1B,0x00,0xCF,0x6C,\"H1440\" },\t/*  7 1.44MB 3.5\"   */\n\t{ 5760,36,2,80,0,0x1B,0x43,0xAF,0x54,\"E2880\" },\t/*  8 2.88MB 3.5\"   */\n\t{ 6240,39,2,80,0,0x1B,0x43,0xAF,0x28,\"E3120\" },\t/*  9 3.12MB 3.5\"   */\n\n\t{ 2880,18,2,80,0,0x25,0x00,0xDF,0x02,\"h1440\" }, /* 10 1.44MB 5.25\"  */\n\t{ 3360,21,2,80,0,0x1C,0x00,0xCF,0x0C,\"H1680\" }, /* 11 1.68MB 3.5\"   */\n\t{  820,10,2,41,1,0x25,0x01,0xDF,0x2E,\"h410\"  },\t/* 12 410KB 5.25\"   */\n\t{ 1640,10,2,82,0,0x25,0x02,0xDF,0x2E,\"H820\"  },\t/* 13 820KB 3.5\"    */\n\t{ 2952,18,2,82,0,0x25,0x00,0xDF,0x02,\"h1476\" },\t/* 14 1.48MB 5.25\"  */\n\t{ 3444,21,2,82,0,0x25,0x00,0xDF,0x0C,\"H1722\" },\t/* 15 1.72MB 3.5\"   */\n\t{  840,10,2,42,1,0x25,0x01,0xDF,0x2E,\"h420\"  },\t/* 16 420KB 5.25\"   */\n\t{ 1660,10,2,83,0,0x25,0x02,0xDF,0x2E,\"H830\"  },\t/* 17 830KB 3.5\"    */\n\t{ 2988,18,2,83,0,0x25,0x00,0xDF,0x02,\"h1494\" },\t/* 18 1.49MB 5.25\"  */\n\t{ 3486,21,2,83,0,0x25,0x00,0xDF,0x0C,\"H1743\" }, /* 19 1.74 MB 3.5\"  */\n\n\t{ 1760,11,2,80,0,0x1C,0x09,0xCF,0x00,\"h880\"  }, /* 20 880KB 5.25\"   */\n\t{ 2080,13,2,80,0,0x1C,0x01,0xCF,0x00,\"D1040\" }, /* 21 1.04MB 3.5\"   */\n\t{ 2240,14,2,80,0,0x1C,0x19,0xCF,0x00,\"D1120\" }, /* 22 1.12MB 3.5\"   */\n\t{ 3200,20,2,80,0,0x1C,0x20,0xCF,0x2C,\"h1600\" }, /* 23 1.6MB 5.25\"   */\n\t{ 3520,22,2,80,0,0x1C,0x08,0xCF,0x2e,\"H1760\" }, /* 24 1.76MB 3.5\"   */\n\t{ 3840,24,2,80,0,0x1C,0x20,0xCF,0x00,\"H1920\" }, /* 25 1.92MB 3.5\"   */\n\t{ 6400,40,2,80,0,0x25,0x5B,0xCF,0x00,\"E3200\" }, /* 26 3.20MB 3.5\"   */\n\t{ 7040,44,2,80,0,0x25,0x5B,0xCF,0x00,\"E3520\" }, /* 27 3.52MB 3.5\"   */\n\t{ 7680,48,2,80,0,0x25,0x63,0xCF,0x00,\"E3840\" }, /* 28 3.84MB 3.5\"   */\n\t{ 3680,23,2,80,0,0x1C,0x10,0xCF,0x00,\"H1840\" }, /* 29 1.84MB 3.5\"   */\n\n\t{ 1600,10,2,80,0,0x25,0x02,0xDF,0x2E,\"D800\"  },\t/* 30 800KB 3.5\"    */\n\t{ 3200,20,2,80,0,0x1C,0x00,0xCF,0x2C,\"H1600\" }, /* 31 1.6MB 3.5\"    */\n};\n\n#define SECTSIZE (_FD_SECTSIZE(*floppy))\n\n/* Auto-detection: Disk type used until the next media change occurs. */\nstatic struct floppy_struct *current_type[N_DRIVE];\n\n/*\n * User-provided type information. current_type points to\n * the respective entry of this array.\n */\nstatic struct floppy_struct user_params[N_DRIVE];\n\nstatic sector_t floppy_sizes[256];\n\nstatic char floppy_device_name[] = \"floppy\";\n\n/*\n * The driver is trying to determine the correct media format\n * while probing is set. rw_interrupt() clears it after a\n * successful access.\n */\nstatic int probing;\n\n/* Synchronization of FDC access. */\n#define FD_COMMAND_NONE\t\t-1\n#define FD_COMMAND_ERROR\t2\n#define FD_COMMAND_OKAY\t\t3\n\nstatic volatile int command_status = FD_COMMAND_NONE;\nstatic unsigned long fdc_busy;\nstatic DECLARE_WAIT_QUEUE_HEAD(fdc_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(command_done);\n\n/* Errors during formatting are counted here. */\nstatic int format_errors;\n\n/* Format request descriptor. */\nstatic struct format_descr format_req;\n\n/*\n * Rate is 0 for 500kb/s, 1 for 300kbps, 2 for 250kbps\n * Spec1 is 0xSH, where S is stepping rate (F=1ms, E=2ms, D=3ms etc),\n * H is head unload time (1=16ms, 2=32ms, etc)\n */\n\n/*\n * Track buffer\n * Because these are written to by the DMA controller, they must\n * not contain a 64k byte boundary crossing, or data will be\n * corrupted/lost.\n */\nstatic char *floppy_track_buffer;\nstatic int max_buffer_sectors;\n\nstatic int *errors;\ntypedef void (*done_f)(int);\nstatic const struct cont_t {\n\tvoid (*interrupt)(void);\n\t\t\t\t/* this is called after the interrupt of the\n\t\t\t\t * main command */\n\tvoid (*redo)(void);\t/* this is called to retry the operation */\n\tvoid (*error)(void);\t/* this is called to tally an error */\n\tdone_f done;\t\t/* this is called to say if the operation has\n\t\t\t\t * succeeded/failed */\n} *cont;\n\nstatic void floppy_ready(void);\nstatic void floppy_start(void);\nstatic void process_fd_request(void);\nstatic void recalibrate_floppy(void);\nstatic void floppy_shutdown(struct work_struct *);\n\nstatic int floppy_request_regions(int);\nstatic void floppy_release_regions(int);\nstatic int floppy_grab_irq_and_dma(void);\nstatic void floppy_release_irq_and_dma(void);\n\n/*\n * The \"reset\" variable should be tested whenever an interrupt is scheduled,\n * after the commands have been sent. This is to ensure that the driver doesn't\n * get wedged when the interrupt doesn't come because of a failed command.\n * reset doesn't need to be tested before sending commands, because\n * output_byte is automatically disabled when reset is set.\n */\nstatic void reset_fdc(void);\n\n/*\n * These are global variables, as that's the easiest way to give\n * information to interrupts. They are the data used for the current\n * request.\n */\n#define NO_TRACK\t-1\n#define NEED_1_RECAL\t-2\n#define NEED_2_RECAL\t-3\n\nstatic atomic_t usage_count = ATOMIC_INIT(0);\n\n/* buffer related variables */\nstatic int buffer_track = -1;\nstatic int buffer_drive = -1;\nstatic int buffer_min = -1;\nstatic int buffer_max = -1;\n\n/* fdc related variables, should end up in a struct */\nstatic struct floppy_fdc_state fdc_state[N_FDC];\nstatic int fdc;\t\t\t/* current fdc */\n\nstatic struct workqueue_struct *floppy_wq;\n\nstatic struct floppy_struct *_floppy = floppy_type;\nstatic unsigned char current_drive;\nstatic long current_count_sectors;\nstatic unsigned char fsector_t;\t/* sector in track */\nstatic unsigned char in_sector_offset;\t/* offset within physical sector,\n\t\t\t\t\t * expressed in units of 512 bytes */\n\nstatic inline bool drive_no_geom(int drive)\n{\n\treturn !current_type[drive] && !ITYPE(UDRS->fd_device);\n}\n\n#ifndef fd_eject\nstatic inline int fd_eject(int drive)\n{\n\treturn -EINVAL;\n}\n#endif\n\n/*\n * Debugging\n * =========\n */\n#ifdef DEBUGT\nstatic long unsigned debugtimer;\n\nstatic inline void set_debugt(void)\n{\n\tdebugtimer = jiffies;\n}\n\nstatic inline void debugt(const char *func, const char *msg)\n{\n\tif (DP->flags & DEBUGT)\n\t\tpr_info(\"%s:%s dtime=%lu\\n\", func, msg, jiffies - debugtimer);\n}\n#else\nstatic inline void set_debugt(void) { }\nstatic inline void debugt(const char *func, const char *msg) { }\n#endif /* DEBUGT */\n\n\nstatic DECLARE_DELAYED_WORK(fd_timeout, floppy_shutdown);\nstatic const char *timeout_message;\n\nstatic void is_alive(const char *func, const char *message)\n{\n\t/* this routine checks whether the floppy driver is \"alive\" */\n\tif (test_bit(0, &fdc_busy) && command_status < 2 &&\n\t    !delayed_work_pending(&fd_timeout)) {\n\t\tDPRINT(\"%s: timeout handler died.  %s\\n\", func, message);\n\t}\n}\n\nstatic void (*do_floppy)(void) = NULL;\n\n#define OLOGSIZE 20\n\nstatic void (*lasthandler)(void);\nstatic unsigned long interruptjiffies;\nstatic unsigned long resultjiffies;\nstatic int resultsize;\nstatic unsigned long lastredo;\n\nstatic struct output_log {\n\tunsigned char data;\n\tunsigned char status;\n\tunsigned long jiffies;\n} output_log[OLOGSIZE];\n\nstatic int output_log_pos;\n\n#define current_reqD -1\n#define MAXTIMEOUT -2\n\nstatic void __reschedule_timeout(int drive, const char *message)\n{\n\tunsigned long delay;\n\n\tif (drive == current_reqD)\n\t\tdrive = current_drive;\n\n\tif (drive < 0 || drive >= N_DRIVE) {\n\t\tdelay = 20UL * HZ;\n\t\tdrive = 0;\n\t} else\n\t\tdelay = UDP->timeout;\n\n\tmod_delayed_work(floppy_wq, &fd_timeout, delay);\n\tif (UDP->flags & FD_DEBUG)\n\t\tDPRINT(\"reschedule timeout %s\\n\", message);\n\ttimeout_message = message;\n}\n\nstatic void reschedule_timeout(int drive, const char *message)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&floppy_lock, flags);\n\t__reschedule_timeout(drive, message);\n\tspin_unlock_irqrestore(&floppy_lock, flags);\n}\n\n#define INFBOUND(a, b) (a) = max_t(int, a, b)\n#define SUPBOUND(a, b) (a) = min_t(int, a, b)\n\n/*\n * Bottom half floppy driver.\n * ==========================\n *\n * This part of the file contains the code talking directly to the hardware,\n * and also the main service loop (seek-configure-spinup-command)\n */\n\n/*\n * disk change.\n * This routine is responsible for maintaining the FD_DISK_CHANGE flag,\n * and the last_checked date.\n *\n * last_checked is the date of the last check which showed 'no disk change'\n * FD_DISK_CHANGE is set under two conditions:\n * 1. The floppy has been changed after some i/o to that floppy already\n *    took place.\n * 2. No floppy disk is in the drive. This is done in order to ensure that\n *    requests are quickly flushed in case there is no disk in the drive. It\n *    follows that FD_DISK_CHANGE can only be cleared if there is a disk in\n *    the drive.\n *\n * For 1., maxblock is observed. Maxblock is 0 if no i/o has taken place yet.\n * For 2., FD_DISK_NEWCHANGE is watched. FD_DISK_NEWCHANGE is cleared on\n *  each seek. If a disk is present, the disk change line should also be\n *  cleared on each seek. Thus, if FD_DISK_NEWCHANGE is clear, but the disk\n *  change line is set, this means either that no disk is in the drive, or\n *  that it has been removed since the last seek.\n *\n * This means that we really have a third possibility too:\n *  The floppy has been changed after the last seek.\n */\n\nstatic int disk_change(int drive)\n{\n\tint fdc = FDC(drive);\n\n\tif (time_before(jiffies, UDRS->select_date + UDP->select_delay))\n\t\tDPRINT(\"WARNING disk change called early\\n\");\n\tif (!(FDCS->dor & (0x10 << UNIT(drive))) ||\n\t    (FDCS->dor & 3) != UNIT(drive) || fdc != FDC(drive)) {\n\t\tDPRINT(\"probing disk change on unselected drive\\n\");\n\t\tDPRINT(\"drive=%d fdc=%d dor=%x\\n\", drive, FDC(drive),\n\t\t       (unsigned int)FDCS->dor);\n\t}\n\n\tdebug_dcl(UDP->flags,\n\t\t  \"checking disk change line for drive %d\\n\", drive);\n\tdebug_dcl(UDP->flags, \"jiffies=%lu\\n\", jiffies);\n\tdebug_dcl(UDP->flags, \"disk change line=%x\\n\", fd_inb(FD_DIR) & 0x80);\n\tdebug_dcl(UDP->flags, \"flags=%lx\\n\", UDRS->flags);\n\n\tif (UDP->flags & FD_BROKEN_DCL)\n\t\treturn test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags);\n\tif ((fd_inb(FD_DIR) ^ UDP->flags) & 0x80) {\n\t\tset_bit(FD_VERIFY_BIT, &UDRS->flags);\n\t\t\t\t\t/* verify write protection */\n\n\t\tif (UDRS->maxblock)\t/* mark it changed */\n\t\t\tset_bit(FD_DISK_CHANGED_BIT, &UDRS->flags);\n\n\t\t/* invalidate its geometry */\n\t\tif (UDRS->keep_data >= 0) {\n\t\t\tif ((UDP->flags & FTD_MSG) &&\n\t\t\t    current_type[drive] != NULL)\n\t\t\t\tDPRINT(\"Disk type is undefined after disk change\\n\");\n\t\t\tcurrent_type[drive] = NULL;\n\t\t\tfloppy_sizes[TOMINOR(drive)] = MAX_DISK_SIZE << 1;\n\t\t}\n\n\t\treturn 1;\n\t} else {\n\t\tUDRS->last_checked = jiffies;\n\t\tclear_bit(FD_DISK_NEWCHANGE_BIT, &UDRS->flags);\n\t}\n\treturn 0;\n}\n\nstatic inline int is_selected(int dor, int unit)\n{\n\treturn ((dor & (0x10 << unit)) && (dor & 3) == unit);\n}\n\nstatic bool is_ready_state(int status)\n{\n\tint state = status & (STATUS_READY | STATUS_DIR | STATUS_DMA);\n\treturn state == STATUS_READY;\n}\n\nstatic int set_dor(int fdc, char mask, char data)\n{\n\tunsigned char unit;\n\tunsigned char drive;\n\tunsigned char newdor;\n\tunsigned char olddor;\n\n\tif (FDCS->address == -1)\n\t\treturn -1;\n\n\tolddor = FDCS->dor;\n\tnewdor = (olddor & mask) | data;\n\tif (newdor != olddor) {\n\t\tunit = olddor & 0x3;\n\t\tif (is_selected(olddor, unit) && !is_selected(newdor, unit)) {\n\t\t\tdrive = REVDRIVE(fdc, unit);\n\t\t\tdebug_dcl(UDP->flags,\n\t\t\t\t  \"calling disk change from set_dor\\n\");\n\t\t\tdisk_change(drive);\n\t\t}\n\t\tFDCS->dor = newdor;\n\t\tfd_outb(newdor, FD_DOR);\n\n\t\tunit = newdor & 0x3;\n\t\tif (!is_selected(olddor, unit) && is_selected(newdor, unit)) {\n\t\t\tdrive = REVDRIVE(fdc, unit);\n\t\t\tUDRS->select_date = jiffies;\n\t\t}\n\t}\n\treturn olddor;\n}\n\nstatic void twaddle(void)\n{\n\tif (DP->select_delay)\n\t\treturn;\n\tfd_outb(FDCS->dor & ~(0x10 << UNIT(current_drive)), FD_DOR);\n\tfd_outb(FDCS->dor, FD_DOR);\n\tDRS->select_date = jiffies;\n}\n\n/*\n * Reset all driver information about the current fdc.\n * This is needed after a reset, and after a raw command.\n */\nstatic void reset_fdc_info(int mode)\n{\n\tint drive;\n\n\tFDCS->spec1 = FDCS->spec2 = -1;\n\tFDCS->need_configure = 1;\n\tFDCS->perp_mode = 1;\n\tFDCS->rawcmd = 0;\n\tfor (drive = 0; drive < N_DRIVE; drive++)\n\t\tif (FDC(drive) == fdc && (mode || UDRS->track != NEED_1_RECAL))\n\t\t\tUDRS->track = NEED_2_RECAL;\n}\n\n/* selects the fdc and drive, and enables the fdc's input/dma. */\nstatic void set_fdc(int drive)\n{\n\tif (drive >= 0 && drive < N_DRIVE) {\n\t\tfdc = FDC(drive);\n\t\tcurrent_drive = drive;\n\t}\n\tif (fdc != 1 && fdc != 0) {\n\t\tpr_info(\"bad fdc value\\n\");\n\t\treturn;\n\t}\n\tset_dor(fdc, ~0, 8);\n#if N_FDC > 1\n\tset_dor(1 - fdc, ~8, 0);\n#endif\n\tif (FDCS->rawcmd == 2)\n\t\treset_fdc_info(1);\n\tif (fd_inb(FD_STATUS) != STATUS_READY)\n\t\tFDCS->reset = 1;\n}\n\n/* locks the driver */\nstatic int lock_fdc(int drive)\n{\n\tif (WARN(atomic_read(&usage_count) == 0,\n\t\t \"Trying to lock fdc while usage count=0\\n\"))\n\t\treturn -1;\n\n\tif (wait_event_interruptible(fdc_wait, !test_and_set_bit(0, &fdc_busy)))\n\t\treturn -EINTR;\n\n\tcommand_status = FD_COMMAND_NONE;\n\n\treschedule_timeout(drive, \"lock fdc\");\n\tset_fdc(drive);\n\treturn 0;\n}\n\n/* unlocks the driver */\nstatic void unlock_fdc(void)\n{\n\tif (!test_bit(0, &fdc_busy))\n\t\tDPRINT(\"FDC access conflict!\\n\");\n\n\traw_cmd = NULL;\n\tcommand_status = FD_COMMAND_NONE;\n\tcancel_delayed_work(&fd_timeout);\n\tdo_floppy = NULL;\n\tcont = NULL;\n\tclear_bit(0, &fdc_busy);\n\twake_up(&fdc_wait);\n}\n\n/* switches the motor off after a given timeout */\nstatic void motor_off_callback(struct timer_list *t)\n{\n\tunsigned long nr = t - motor_off_timer;\n\tunsigned char mask = ~(0x10 << UNIT(nr));\n\n\tif (WARN_ON_ONCE(nr >= N_DRIVE))\n\t\treturn;\n\n\tset_dor(FDC(nr), mask, 0);\n}\n\n/* schedules motor off */\nstatic void floppy_off(unsigned int drive)\n{\n\tunsigned long volatile delta;\n\tint fdc = FDC(drive);\n\n\tif (!(FDCS->dor & (0x10 << UNIT(drive))))\n\t\treturn;\n\n\tdel_timer(motor_off_timer + drive);\n\n\t/* make spindle stop in a position which minimizes spinup time\n\t * next time */\n\tif (UDP->rps) {\n\t\tdelta = jiffies - UDRS->first_read_date + HZ -\n\t\t    UDP->spindown_offset;\n\t\tdelta = ((delta * UDP->rps) % HZ) / UDP->rps;\n\t\tmotor_off_timer[drive].expires =\n\t\t    jiffies + UDP->spindown - delta;\n\t}\n\tadd_timer(motor_off_timer + drive);\n}\n\n/*\n * cycle through all N_DRIVE floppy drives, for disk change testing.\n * stopping at current drive. This is done before any long operation, to\n * be sure to have up to date disk change information.\n */\nstatic void scandrives(void)\n{\n\tint i;\n\tint drive;\n\tint saved_drive;\n\n\tif (DP->select_delay)\n\t\treturn;\n\n\tsaved_drive = current_drive;\n\tfor (i = 0; i < N_DRIVE; i++) {\n\t\tdrive = (saved_drive + i + 1) % N_DRIVE;\n\t\tif (UDRS->fd_ref == 0 || UDP->select_delay != 0)\n\t\t\tcontinue;\t/* skip closed drives */\n\t\tset_fdc(drive);\n\t\tif (!(set_dor(fdc, ~3, UNIT(drive) | (0x10 << UNIT(drive))) &\n\t\t      (0x10 << UNIT(drive))))\n\t\t\t/* switch the motor off again, if it was off to\n\t\t\t * begin with */\n\t\t\tset_dor(fdc, ~(0x10 << UNIT(drive)), 0);\n\t}\n\tset_fdc(saved_drive);\n}\n\nstatic void empty(void)\n{\n}\n\nstatic void (*floppy_work_fn)(void);\n\nstatic void floppy_work_workfn(struct work_struct *work)\n{\n\tfloppy_work_fn();\n}\n\nstatic DECLARE_WORK(floppy_work, floppy_work_workfn);\n\nstatic void schedule_bh(void (*handler)(void))\n{\n\tWARN_ON(work_pending(&floppy_work));\n\n\tfloppy_work_fn = handler;\n\tqueue_work(floppy_wq, &floppy_work);\n}\n\nstatic void (*fd_timer_fn)(void) = NULL;\n\nstatic void fd_timer_workfn(struct work_struct *work)\n{\n\tfd_timer_fn();\n}\n\nstatic DECLARE_DELAYED_WORK(fd_timer, fd_timer_workfn);\n\nstatic void cancel_activity(void)\n{\n\tdo_floppy = NULL;\n\tcancel_delayed_work_sync(&fd_timer);\n\tcancel_work_sync(&floppy_work);\n}\n\n/* this function makes sure that the disk stays in the drive during the\n * transfer */\nstatic void fd_watchdog(void)\n{\n\tdebug_dcl(DP->flags, \"calling disk change from watchdog\\n\");\n\n\tif (disk_change(current_drive)) {\n\t\tDPRINT(\"disk removed during i/o\\n\");\n\t\tcancel_activity();\n\t\tcont->done(0);\n\t\treset_fdc();\n\t} else {\n\t\tcancel_delayed_work(&fd_timer);\n\t\tfd_timer_fn = fd_watchdog;\n\t\tqueue_delayed_work(floppy_wq, &fd_timer, HZ / 10);\n\t}\n}\n\nstatic void main_command_interrupt(void)\n{\n\tcancel_delayed_work(&fd_timer);\n\tcont->interrupt();\n}\n\n/* waits for a delay (spinup or select) to pass */\nstatic int fd_wait_for_completion(unsigned long expires,\n\t\t\t\t  void (*function)(void))\n{\n\tif (FDCS->reset) {\n\t\treset_fdc();\t/* do the reset during sleep to win time\n\t\t\t\t * if we don't need to sleep, it's a good\n\t\t\t\t * occasion anyways */\n\t\treturn 1;\n\t}\n\n\tif (time_before(jiffies, expires)) {\n\t\tcancel_delayed_work(&fd_timer);\n\t\tfd_timer_fn = function;\n\t\tqueue_delayed_work(floppy_wq, &fd_timer, expires - jiffies);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void setup_DMA(void)\n{\n\tunsigned long f;\n\n\tif (raw_cmd->length == 0) {\n\t\tint i;\n\n\t\tpr_info(\"zero dma transfer size:\");\n\t\tfor (i = 0; i < raw_cmd->cmd_count; i++)\n\t\t\tpr_cont(\"%x,\", raw_cmd->cmd[i]);\n\t\tpr_cont(\"\\n\");\n\t\tcont->done(0);\n\t\tFDCS->reset = 1;\n\t\treturn;\n\t}\n\tif (((unsigned long)raw_cmd->kernel_data) % 512) {\n\t\tpr_info(\"non aligned address: %p\\n\", raw_cmd->kernel_data);\n\t\tcont->done(0);\n\t\tFDCS->reset = 1;\n\t\treturn;\n\t}\n\tf = claim_dma_lock();\n\tfd_disable_dma();\n#ifdef fd_dma_setup\n\tif (fd_dma_setup(raw_cmd->kernel_data, raw_cmd->length,\n\t\t\t (raw_cmd->flags & FD_RAW_READ) ?\n\t\t\t DMA_MODE_READ : DMA_MODE_WRITE, FDCS->address) < 0) {\n\t\trelease_dma_lock(f);\n\t\tcont->done(0);\n\t\tFDCS->reset = 1;\n\t\treturn;\n\t}\n\trelease_dma_lock(f);\n#else\n\tfd_clear_dma_ff();\n\tfd_cacheflush(raw_cmd->kernel_data, raw_cmd->length);\n\tfd_set_dma_mode((raw_cmd->flags & FD_RAW_READ) ?\n\t\t\tDMA_MODE_READ : DMA_MODE_WRITE);\n\tfd_set_dma_addr(raw_cmd->kernel_data);\n\tfd_set_dma_count(raw_cmd->length);\n\tvirtual_dma_port = FDCS->address;\n\tfd_enable_dma();\n\trelease_dma_lock(f);\n#endif\n}\n\nstatic void show_floppy(void);\n\n/* waits until the fdc becomes ready */\nstatic int wait_til_ready(void)\n{\n\tint status;\n\tint counter;\n\n\tif (FDCS->reset)\n\t\treturn -1;\n\tfor (counter = 0; counter < 10000; counter++) {\n\t\tstatus = fd_inb(FD_STATUS);\n\t\tif (status & STATUS_READY)\n\t\t\treturn status;\n\t}\n\tif (initialized) {\n\t\tDPRINT(\"Getstatus times out (%x) on fdc %d\\n\", status, fdc);\n\t\tshow_floppy();\n\t}\n\tFDCS->reset = 1;\n\treturn -1;\n}\n\n/* sends a command byte to the fdc */\nstatic int output_byte(char byte)\n{\n\tint status = wait_til_ready();\n\n\tif (status < 0)\n\t\treturn -1;\n\n\tif (is_ready_state(status)) {\n\t\tfd_outb(byte, FD_DATA);\n\t\toutput_log[output_log_pos].data = byte;\n\t\toutput_log[output_log_pos].status = status;\n\t\toutput_log[output_log_pos].jiffies = jiffies;\n\t\toutput_log_pos = (output_log_pos + 1) % OLOGSIZE;\n\t\treturn 0;\n\t}\n\tFDCS->reset = 1;\n\tif (initialized) {\n\t\tDPRINT(\"Unable to send byte %x to FDC. Fdc=%x Status=%x\\n\",\n\t\t       byte, fdc, status);\n\t\tshow_floppy();\n\t}\n\treturn -1;\n}\n\n/* gets the response from the fdc */\nstatic int result(void)\n{\n\tint i;\n\tint status = 0;\n\n\tfor (i = 0; i < MAX_REPLIES; i++) {\n\t\tstatus = wait_til_ready();\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus &= STATUS_DIR | STATUS_READY | STATUS_BUSY | STATUS_DMA;\n\t\tif ((status & ~STATUS_BUSY) == STATUS_READY) {\n\t\t\tresultjiffies = jiffies;\n\t\t\tresultsize = i;\n\t\t\treturn i;\n\t\t}\n\t\tif (status == (STATUS_DIR | STATUS_READY | STATUS_BUSY))\n\t\t\treply_buffer[i] = fd_inb(FD_DATA);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (initialized) {\n\t\tDPRINT(\"get result error. Fdc=%d Last status=%x Read bytes=%d\\n\",\n\t\t       fdc, status, i);\n\t\tshow_floppy();\n\t}\n\tFDCS->reset = 1;\n\treturn -1;\n}\n\n#define MORE_OUTPUT -2\n/* does the fdc need more output? */\nstatic int need_more_output(void)\n{\n\tint status = wait_til_ready();\n\n\tif (status < 0)\n\t\treturn -1;\n\n\tif (is_ready_state(status))\n\t\treturn MORE_OUTPUT;\n\n\treturn result();\n}\n\n/* Set perpendicular mode as required, based on data rate, if supported.\n * 82077 Now tested. 1Mbps data rate only possible with 82077-1.\n */\nstatic void perpendicular_mode(void)\n{\n\tunsigned char perp_mode;\n\n\tif (raw_cmd->rate & 0x40) {\n\t\tswitch (raw_cmd->rate & 3) {\n\t\tcase 0:\n\t\t\tperp_mode = 2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tperp_mode = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDPRINT(\"Invalid data rate for perpendicular mode!\\n\");\n\t\t\tcont->done(0);\n\t\t\tFDCS->reset = 1;\n\t\t\t\t\t/*\n\t\t\t\t\t * convenient way to return to\n\t\t\t\t\t * redo without too much hassle\n\t\t\t\t\t * (deep stack et al.)\n\t\t\t\t\t */\n\t\t\treturn;\n\t\t}\n\t} else\n\t\tperp_mode = 0;\n\n\tif (FDCS->perp_mode == perp_mode)\n\t\treturn;\n\tif (FDCS->version >= FDC_82077_ORIG) {\n\t\toutput_byte(FD_PERPENDICULAR);\n\t\toutput_byte(perp_mode);\n\t\tFDCS->perp_mode = perp_mode;\n\t} else if (perp_mode) {\n\t\tDPRINT(\"perpendicular mode not supported by this FDC.\\n\");\n\t}\n}\t\t\t\t/* perpendicular_mode */\n\nstatic int fifo_depth = 0xa;\nstatic int no_fifo;\n\nstatic int fdc_configure(void)\n{\n\t/* Turn on FIFO */\n\toutput_byte(FD_CONFIGURE);\n\tif (need_more_output() != MORE_OUTPUT)\n\t\treturn 0;\n\toutput_byte(0);\n\toutput_byte(0x10 | (no_fifo & 0x20) | (fifo_depth & 0xf));\n\toutput_byte(0);\t\t/* pre-compensation from track\n\t\t\t\t   0 upwards */\n\treturn 1;\n}\n\n#define NOMINAL_DTR 500\n\n/* Issue a \"SPECIFY\" command to set the step rate time, head unload time,\n * head load time, and DMA disable flag to values needed by floppy.\n *\n * The value \"dtr\" is the data transfer rate in Kbps.  It is needed\n * to account for the data rate-based scaling done by the 82072 and 82077\n * FDC types.  This parameter is ignored for other types of FDCs (i.e.\n * 8272a).\n *\n * Note that changing the data transfer rate has a (probably deleterious)\n * effect on the parameters subject to scaling for 82072/82077 FDCs, so\n * fdc_specify is called again after each data transfer rate\n * change.\n *\n * srt: 1000 to 16000 in microseconds\n * hut: 16 to 240 milliseconds\n * hlt: 2 to 254 milliseconds\n *\n * These values are rounded up to the next highest available delay time.\n */\nstatic void fdc_specify(void)\n{\n\tunsigned char spec1;\n\tunsigned char spec2;\n\tunsigned long srt;\n\tunsigned long hlt;\n\tunsigned long hut;\n\tunsigned long dtr = NOMINAL_DTR;\n\tunsigned long scale_dtr = NOMINAL_DTR;\n\tint hlt_max_code = 0x7f;\n\tint hut_max_code = 0xf;\n\n\tif (FDCS->need_configure && FDCS->version >= FDC_82072A) {\n\t\tfdc_configure();\n\t\tFDCS->need_configure = 0;\n\t}\n\n\tswitch (raw_cmd->rate & 0x03) {\n\tcase 3:\n\t\tdtr = 1000;\n\t\tbreak;\n\tcase 1:\n\t\tdtr = 300;\n\t\tif (FDCS->version >= FDC_82078) {\n\t\t\t/* chose the default rate table, not the one\n\t\t\t * where 1 = 2 Mbps */\n\t\t\toutput_byte(FD_DRIVESPEC);\n\t\t\tif (need_more_output() == MORE_OUTPUT) {\n\t\t\t\toutput_byte(UNIT(current_drive));\n\t\t\t\toutput_byte(0xc0);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tdtr = 250;\n\t\tbreak;\n\t}\n\n\tif (FDCS->version >= FDC_82072) {\n\t\tscale_dtr = dtr;\n\t\thlt_max_code = 0x00;\t/* 0==256msec*dtr0/dtr (not linear!) */\n\t\thut_max_code = 0x0;\t/* 0==256msec*dtr0/dtr (not linear!) */\n\t}\n\n\t/* Convert step rate from microseconds to milliseconds and 4 bits */\n\tsrt = 16 - DIV_ROUND_UP(DP->srt * scale_dtr / 1000, NOMINAL_DTR);\n\tif (slow_floppy)\n\t\tsrt = srt / 4;\n\n\tSUPBOUND(srt, 0xf);\n\tINFBOUND(srt, 0);\n\n\thlt = DIV_ROUND_UP(DP->hlt * scale_dtr / 2, NOMINAL_DTR);\n\tif (hlt < 0x01)\n\t\thlt = 0x01;\n\telse if (hlt > 0x7f)\n\t\thlt = hlt_max_code;\n\n\thut = DIV_ROUND_UP(DP->hut * scale_dtr / 16, NOMINAL_DTR);\n\tif (hut < 0x1)\n\t\thut = 0x1;\n\telse if (hut > 0xf)\n\t\thut = hut_max_code;\n\n\tspec1 = (srt << 4) | hut;\n\tspec2 = (hlt << 1) | (use_virtual_dma & 1);\n\n\t/* If these parameters did not change, just return with success */\n\tif (FDCS->spec1 != spec1 || FDCS->spec2 != spec2) {\n\t\t/* Go ahead and set spec1 and spec2 */\n\t\toutput_byte(FD_SPECIFY);\n\t\toutput_byte(FDCS->spec1 = spec1);\n\t\toutput_byte(FDCS->spec2 = spec2);\n\t}\n}\t\t\t\t/* fdc_specify */\n\n/* Set the FDC's data transfer rate on behalf of the specified drive.\n * NOTE: with 82072/82077 FDCs, changing the data rate requires a reissue\n * of the specify command (i.e. using the fdc_specify function).\n */\nstatic int fdc_dtr(void)\n{\n\t/* If data rate not already set to desired value, set it. */\n\tif ((raw_cmd->rate & 3) == FDCS->dtr)\n\t\treturn 0;\n\n\t/* Set dtr */\n\tfd_outb(raw_cmd->rate & 3, FD_DCR);\n\n\t/* TODO: some FDC/drive combinations (C&T 82C711 with TEAC 1.2MB)\n\t * need a stabilization period of several milliseconds to be\n\t * enforced after data rate changes before R/W operations.\n\t * Pause 5 msec to avoid trouble. (Needs to be 2 jiffies)\n\t */\n\tFDCS->dtr = raw_cmd->rate & 3;\n\treturn fd_wait_for_completion(jiffies + 2UL * HZ / 100, floppy_ready);\n}\t\t\t\t/* fdc_dtr */\n\nstatic void tell_sector(void)\n{\n\tpr_cont(\": track %d, head %d, sector %d, size %d\",\n\t\tR_TRACK, R_HEAD, R_SECTOR, R_SIZECODE);\n}\t\t\t\t/* tell_sector */\n\nstatic void print_errors(void)\n{\n\tDPRINT(\"\");\n\tif (ST0 & ST0_ECE) {\n\t\tpr_cont(\"Recalibrate failed!\");\n\t} else if (ST2 & ST2_CRC) {\n\t\tpr_cont(\"data CRC error\");\n\t\ttell_sector();\n\t} else if (ST1 & ST1_CRC) {\n\t\tpr_cont(\"CRC error\");\n\t\ttell_sector();\n\t} else if ((ST1 & (ST1_MAM | ST1_ND)) ||\n\t\t   (ST2 & ST2_MAM)) {\n\t\tif (!probing) {\n\t\t\tpr_cont(\"sector not found\");\n\t\t\ttell_sector();\n\t\t} else\n\t\t\tpr_cont(\"probe failed...\");\n\t} else if (ST2 & ST2_WC) {\t/* seek error */\n\t\tpr_cont(\"wrong cylinder\");\n\t} else if (ST2 & ST2_BC) {\t/* cylinder marked as bad */\n\t\tpr_cont(\"bad cylinder\");\n\t} else {\n\t\tpr_cont(\"unknown error. ST[0..2] are: 0x%x 0x%x 0x%x\",\n\t\t\tST0, ST1, ST2);\n\t\ttell_sector();\n\t}\n\tpr_cont(\"\\n\");\n}\n\n/*\n * OK, this error interpreting routine is called after a\n * DMA read/write has succeeded\n * or failed, so we check the results, and copy any buffers.\n * hhb: Added better error reporting.\n * ak: Made this into a separate routine.\n */\nstatic int interpret_errors(void)\n{\n\tchar bad;\n\n\tif (inr != 7) {\n\t\tDPRINT(\"-- FDC reply error\\n\");\n\t\tFDCS->reset = 1;\n\t\treturn 1;\n\t}\n\n\t/* check IC to find cause of interrupt */\n\tswitch (ST0 & ST0_INTR) {\n\tcase 0x40:\t\t/* error occurred during command execution */\n\t\tif (ST1 & ST1_EOC)\n\t\t\treturn 0;\t/* occurs with pseudo-DMA */\n\t\tbad = 1;\n\t\tif (ST1 & ST1_WP) {\n\t\t\tDPRINT(\"Drive is write protected\\n\");\n\t\t\tclear_bit(FD_DISK_WRITABLE_BIT, &DRS->flags);\n\t\t\tcont->done(0);\n\t\t\tbad = 2;\n\t\t} else if (ST1 & ST1_ND) {\n\t\t\tset_bit(FD_NEED_TWADDLE_BIT, &DRS->flags);\n\t\t} else if (ST1 & ST1_OR) {\n\t\t\tif (DP->flags & FTD_MSG)\n\t\t\t\tDPRINT(\"Over/Underrun - retrying\\n\");\n\t\t\tbad = 0;\n\t\t} else if (*errors >= DP->max_errors.reporting) {\n\t\t\tprint_errors();\n\t\t}\n\t\tif (ST2 & ST2_WC || ST2 & ST2_BC)\n\t\t\t/* wrong cylinder => recal */\n\t\t\tDRS->track = NEED_2_RECAL;\n\t\treturn bad;\n\tcase 0x80:\t\t/* invalid command given */\n\t\tDPRINT(\"Invalid FDC command given!\\n\");\n\t\tcont->done(0);\n\t\treturn 2;\n\tcase 0xc0:\n\t\tDPRINT(\"Abnormal termination caused by polling\\n\");\n\t\tcont->error();\n\t\treturn 2;\n\tdefault:\t\t/* (0) Normal command termination */\n\t\treturn 0;\n\t}\n}\n\n/*\n * This routine is called when everything should be correctly set up\n * for the transfer (i.e. floppy motor is on, the correct floppy is\n * selected, and the head is sitting on the right track).\n */\nstatic void setup_rw_floppy(void)\n{\n\tint i;\n\tint r;\n\tint flags;\n\tunsigned long ready_date;\n\tvoid (*function)(void);\n\n\tflags = raw_cmd->flags;\n\tif (flags & (FD_RAW_READ | FD_RAW_WRITE))\n\t\tflags |= FD_RAW_INTR;\n\n\tif ((flags & FD_RAW_SPIN) && !(flags & FD_RAW_NO_MOTOR)) {\n\t\tready_date = DRS->spinup_date + DP->spinup;\n\t\t/* If spinup will take a long time, rerun scandrives\n\t\t * again just before spinup completion. Beware that\n\t\t * after scandrives, we must again wait for selection.\n\t\t */\n\t\tif (time_after(ready_date, jiffies + DP->select_delay)) {\n\t\t\tready_date -= DP->select_delay;\n\t\t\tfunction = floppy_start;\n\t\t} else\n\t\t\tfunction = setup_rw_floppy;\n\n\t\t/* wait until the floppy is spinning fast enough */\n\t\tif (fd_wait_for_completion(ready_date, function))\n\t\t\treturn;\n\t}\n\tif ((flags & FD_RAW_READ) || (flags & FD_RAW_WRITE))\n\t\tsetup_DMA();\n\n\tif (flags & FD_RAW_INTR)\n\t\tdo_floppy = main_command_interrupt;\n\n\tr = 0;\n\tfor (i = 0; i < raw_cmd->cmd_count; i++)\n\t\tr |= output_byte(raw_cmd->cmd[i]);\n\n\tdebugt(__func__, \"rw_command\");\n\n\tif (r) {\n\t\tcont->error();\n\t\treset_fdc();\n\t\treturn;\n\t}\n\n\tif (!(flags & FD_RAW_INTR)) {\n\t\tinr = result();\n\t\tcont->interrupt();\n\t} else if (flags & FD_RAW_NEED_DISK)\n\t\tfd_watchdog();\n}\n\nstatic int blind_seek;\n\n/*\n * This is the routine called after every seek (or recalibrate) interrupt\n * from the floppy controller.\n */\nstatic void seek_interrupt(void)\n{\n\tdebugt(__func__, \"\");\n\tif (inr != 2 || (ST0 & 0xF8) != 0x20) {\n\t\tDPRINT(\"seek failed\\n\");\n\t\tDRS->track = NEED_2_RECAL;\n\t\tcont->error();\n\t\tcont->redo();\n\t\treturn;\n\t}\n\tif (DRS->track >= 0 && DRS->track != ST1 && !blind_seek) {\n\t\tdebug_dcl(DP->flags,\n\t\t\t  \"clearing NEWCHANGE flag because of effective seek\\n\");\n\t\tdebug_dcl(DP->flags, \"jiffies=%lu\\n\", jiffies);\n\t\tclear_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags);\n\t\t\t\t\t/* effective seek */\n\t\tDRS->select_date = jiffies;\n\t}\n\tDRS->track = ST1;\n\tfloppy_ready();\n}\n\nstatic void check_wp(void)\n{\n\tif (test_bit(FD_VERIFY_BIT, &DRS->flags)) {\n\t\t\t\t\t/* check write protection */\n\t\toutput_byte(FD_GETSTATUS);\n\t\toutput_byte(UNIT(current_drive));\n\t\tif (result() != 1) {\n\t\t\tFDCS->reset = 1;\n\t\t\treturn;\n\t\t}\n\t\tclear_bit(FD_VERIFY_BIT, &DRS->flags);\n\t\tclear_bit(FD_NEED_TWADDLE_BIT, &DRS->flags);\n\t\tdebug_dcl(DP->flags,\n\t\t\t  \"checking whether disk is write protected\\n\");\n\t\tdebug_dcl(DP->flags, \"wp=%x\\n\", ST3 & 0x40);\n\t\tif (!(ST3 & 0x40))\n\t\t\tset_bit(FD_DISK_WRITABLE_BIT, &DRS->flags);\n\t\telse\n\t\t\tclear_bit(FD_DISK_WRITABLE_BIT, &DRS->flags);\n\t}\n}\n\nstatic void seek_floppy(void)\n{\n\tint track;\n\n\tblind_seek = 0;\n\n\tdebug_dcl(DP->flags, \"calling disk change from %s\\n\", __func__);\n\n\tif (!test_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags) &&\n\t    disk_change(current_drive) && (raw_cmd->flags & FD_RAW_NEED_DISK)) {\n\t\t/* the media changed flag should be cleared after the seek.\n\t\t * If it isn't, this means that there is really no disk in\n\t\t * the drive.\n\t\t */\n\t\tset_bit(FD_DISK_CHANGED_BIT, &DRS->flags);\n\t\tcont->done(0);\n\t\tcont->redo();\n\t\treturn;\n\t}\n\tif (DRS->track <= NEED_1_RECAL) {\n\t\trecalibrate_floppy();\n\t\treturn;\n\t} else if (test_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags) &&\n\t\t   (raw_cmd->flags & FD_RAW_NEED_DISK) &&\n\t\t   (DRS->track <= NO_TRACK || DRS->track == raw_cmd->track)) {\n\t\t/* we seek to clear the media-changed condition. Does anybody\n\t\t * know a more elegant way, which works on all drives? */\n\t\tif (raw_cmd->track)\n\t\t\ttrack = raw_cmd->track - 1;\n\t\telse {\n\t\t\tif (DP->flags & FD_SILENT_DCL_CLEAR) {\n\t\t\t\tset_dor(fdc, ~(0x10 << UNIT(current_drive)), 0);\n\t\t\t\tblind_seek = 1;\n\t\t\t\traw_cmd->flags |= FD_RAW_NEED_SEEK;\n\t\t\t}\n\t\t\ttrack = 1;\n\t\t}\n\t} else {\n\t\tcheck_wp();\n\t\tif (raw_cmd->track != DRS->track &&\n\t\t    (raw_cmd->flags & FD_RAW_NEED_SEEK))\n\t\t\ttrack = raw_cmd->track;\n\t\telse {\n\t\t\tsetup_rw_floppy();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdo_floppy = seek_interrupt;\n\toutput_byte(FD_SEEK);\n\toutput_byte(UNIT(current_drive));\n\tif (output_byte(track) < 0) {\n\t\treset_fdc();\n\t\treturn;\n\t}\n\tdebugt(__func__, \"\");\n}\n\nstatic void recal_interrupt(void)\n{\n\tdebugt(__func__, \"\");\n\tif (inr != 2)\n\t\tFDCS->reset = 1;\n\telse if (ST0 & ST0_ECE) {\n\t\tswitch (DRS->track) {\n\t\tcase NEED_1_RECAL:\n\t\t\tdebugt(__func__, \"need 1 recal\");\n\t\t\t/* after a second recalibrate, we still haven't\n\t\t\t * reached track 0. Probably no drive. Raise an\n\t\t\t * error, as failing immediately might upset\n\t\t\t * computers possessed by the Devil :-) */\n\t\t\tcont->error();\n\t\t\tcont->redo();\n\t\t\treturn;\n\t\tcase NEED_2_RECAL:\n\t\t\tdebugt(__func__, \"need 2 recal\");\n\t\t\t/* If we already did a recalibrate,\n\t\t\t * and we are not at track 0, this\n\t\t\t * means we have moved. (The only way\n\t\t\t * not to move at recalibration is to\n\t\t\t * be already at track 0.) Clear the\n\t\t\t * new change flag */\n\t\t\tdebug_dcl(DP->flags,\n\t\t\t\t  \"clearing NEWCHANGE flag because of second recalibrate\\n\");\n\n\t\t\tclear_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags);\n\t\t\tDRS->select_date = jiffies;\n\t\t\t/* fall through */\n\t\tdefault:\n\t\t\tdebugt(__func__, \"default\");\n\t\t\t/* Recalibrate moves the head by at\n\t\t\t * most 80 steps. If after one\n\t\t\t * recalibrate we don't have reached\n\t\t\t * track 0, this might mean that we\n\t\t\t * started beyond track 80.  Try\n\t\t\t * again.  */\n\t\t\tDRS->track = NEED_1_RECAL;\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tDRS->track = ST1;\n\tfloppy_ready();\n}\n\nstatic void print_result(char *message, int inr)\n{\n\tint i;\n\n\tDPRINT(\"%s \", message);\n\tif (inr >= 0)\n\t\tfor (i = 0; i < inr; i++)\n\t\t\tpr_cont(\"repl[%d]=%x \", i, reply_buffer[i]);\n\tpr_cont(\"\\n\");\n}\n\n/* interrupt handler. Note that this can be called externally on the Sparc */\nirqreturn_t floppy_interrupt(int irq, void *dev_id)\n{\n\tint do_print;\n\tunsigned long f;\n\tvoid (*handler)(void) = do_floppy;\n\n\tlasthandler = handler;\n\tinterruptjiffies = jiffies;\n\n\tf = claim_dma_lock();\n\tfd_disable_dma();\n\trelease_dma_lock(f);\n\n\tdo_floppy = NULL;\n\tif (fdc >= N_FDC || FDCS->address == -1) {\n\t\t/* we don't even know which FDC is the culprit */\n\t\tpr_info(\"DOR0=%x\\n\", fdc_state[0].dor);\n\t\tpr_info(\"floppy interrupt on bizarre fdc %d\\n\", fdc);\n\t\tpr_info(\"handler=%ps\\n\", handler);\n\t\tis_alive(__func__, \"bizarre fdc\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tFDCS->reset = 0;\n\t/* We have to clear the reset flag here, because apparently on boxes\n\t * with level triggered interrupts (PS/2, Sparc, ...), it is needed to\n\t * emit SENSEI's to clear the interrupt line. And FDCS->reset blocks the\n\t * emission of the SENSEI's.\n\t * It is OK to emit floppy commands because we are in an interrupt\n\t * handler here, and thus we have to fear no interference of other\n\t * activity.\n\t */\n\n\tdo_print = !handler && print_unex && initialized;\n\n\tinr = result();\n\tif (do_print)\n\t\tprint_result(\"unexpected interrupt\", inr);\n\tif (inr == 0) {\n\t\tint max_sensei = 4;\n\t\tdo {\n\t\t\toutput_byte(FD_SENSEI);\n\t\t\tinr = result();\n\t\t\tif (do_print)\n\t\t\t\tprint_result(\"sensei\", inr);\n\t\t\tmax_sensei--;\n\t\t} while ((ST0 & 0x83) != UNIT(current_drive) &&\n\t\t\t inr == 2 && max_sensei);\n\t}\n\tif (!handler) {\n\t\tFDCS->reset = 1;\n\t\treturn IRQ_NONE;\n\t}\n\tschedule_bh(handler);\n\tis_alive(__func__, \"normal interrupt end\");\n\n\t/* FIXME! Was it really for us? */\n\treturn IRQ_HANDLED;\n}\n\nstatic void recalibrate_floppy(void)\n{\n\tdebugt(__func__, \"\");\n\tdo_floppy = recal_interrupt;\n\toutput_byte(FD_RECALIBRATE);\n\tif (output_byte(UNIT(current_drive)) < 0)\n\t\treset_fdc();\n}\n\n/*\n * Must do 4 FD_SENSEIs after reset because of ``drive polling''.\n */\nstatic void reset_interrupt(void)\n{\n\tdebugt(__func__, \"\");\n\tresult();\t\t/* get the status ready for set_fdc */\n\tif (FDCS->reset) {\n\t\tpr_info(\"reset set in interrupt, calling %ps\\n\", cont->error);\n\t\tcont->error();\t/* a reset just after a reset. BAD! */\n\t}\n\tcont->redo();\n}\n\n/*\n * reset is done by pulling bit 2 of DOR low for a while (old FDCs),\n * or by setting the self clearing bit 7 of STATUS (newer FDCs)\n */\nstatic void reset_fdc(void)\n{\n\tunsigned long flags;\n\n\tdo_floppy = reset_interrupt;\n\tFDCS->reset = 0;\n\treset_fdc_info(0);\n\n\t/* Pseudo-DMA may intercept 'reset finished' interrupt.  */\n\t/* Irrelevant for systems with true DMA (i386).          */\n\n\tflags = claim_dma_lock();\n\tfd_disable_dma();\n\trelease_dma_lock(flags);\n\n\tif (FDCS->version >= FDC_82072A)\n\t\tfd_outb(0x80 | (FDCS->dtr & 3), FD_STATUS);\n\telse {\n\t\tfd_outb(FDCS->dor & ~0x04, FD_DOR);\n\t\tudelay(FD_RESET_DELAY);\n\t\tfd_outb(FDCS->dor, FD_DOR);\n\t}\n}\n\nstatic void show_floppy(void)\n{\n\tint i;\n\n\tpr_info(\"\\n\");\n\tpr_info(\"floppy driver state\\n\");\n\tpr_info(\"-------------------\\n\");\n\tpr_info(\"now=%lu last interrupt=%lu diff=%lu last called handler=%ps\\n\",\n\t\tjiffies, interruptjiffies, jiffies - interruptjiffies,\n\t\tlasthandler);\n\n\tpr_info(\"timeout_message=%s\\n\", timeout_message);\n\tpr_info(\"last output bytes:\\n\");\n\tfor (i = 0; i < OLOGSIZE; i++)\n\t\tpr_info(\"%2x %2x %lu\\n\",\n\t\t\toutput_log[(i + output_log_pos) % OLOGSIZE].data,\n\t\t\toutput_log[(i + output_log_pos) % OLOGSIZE].status,\n\t\t\toutput_log[(i + output_log_pos) % OLOGSIZE].jiffies);\n\tpr_info(\"last result at %lu\\n\", resultjiffies);\n\tpr_info(\"last redo_fd_request at %lu\\n\", lastredo);\n\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_NONE, 16, 1,\n\t\t       reply_buffer, resultsize, true);\n\n\tpr_info(\"status=%x\\n\", fd_inb(FD_STATUS));\n\tpr_info(\"fdc_busy=%lu\\n\", fdc_busy);\n\tif (do_floppy)\n\t\tpr_info(\"do_floppy=%ps\\n\", do_floppy);\n\tif (work_pending(&floppy_work))\n\t\tpr_info(\"floppy_work.func=%ps\\n\", floppy_work.func);\n\tif (delayed_work_pending(&fd_timer))\n\t\tpr_info(\"delayed work.function=%p expires=%ld\\n\",\n\t\t       fd_timer.work.func,\n\t\t       fd_timer.timer.expires - jiffies);\n\tif (delayed_work_pending(&fd_timeout))\n\t\tpr_info(\"timer_function=%p expires=%ld\\n\",\n\t\t       fd_timeout.work.func,\n\t\t       fd_timeout.timer.expires - jiffies);\n\n\tpr_info(\"cont=%p\\n\", cont);\n\tpr_info(\"current_req=%p\\n\", current_req);\n\tpr_info(\"command_status=%d\\n\", command_status);\n\tpr_info(\"\\n\");\n}\n\nstatic void floppy_shutdown(struct work_struct *arg)\n{\n\tunsigned long flags;\n\n\tif (initialized)\n\t\tshow_floppy();\n\tcancel_activity();\n\n\tflags = claim_dma_lock();\n\tfd_disable_dma();\n\trelease_dma_lock(flags);\n\n\t/* avoid dma going to a random drive after shutdown */\n\n\tif (initialized)\n\t\tDPRINT(\"floppy timeout called\\n\");\n\tFDCS->reset = 1;\n\tif (cont) {\n\t\tcont->done(0);\n\t\tcont->redo();\t/* this will recall reset when needed */\n\t} else {\n\t\tpr_info(\"no cont in shutdown!\\n\");\n\t\tprocess_fd_request();\n\t}\n\tis_alive(__func__, \"\");\n}\n\n/* start motor, check media-changed condition and write protection */\nstatic int start_motor(void (*function)(void))\n{\n\tint mask;\n\tint data;\n\n\tmask = 0xfc;\n\tdata = UNIT(current_drive);\n\tif (!(raw_cmd->flags & FD_RAW_NO_MOTOR)) {\n\t\tif (!(FDCS->dor & (0x10 << UNIT(current_drive)))) {\n\t\t\tset_debugt();\n\t\t\t/* no read since this drive is running */\n\t\t\tDRS->first_read_date = 0;\n\t\t\t/* note motor start time if motor is not yet running */\n\t\t\tDRS->spinup_date = jiffies;\n\t\t\tdata |= (0x10 << UNIT(current_drive));\n\t\t}\n\t} else if (FDCS->dor & (0x10 << UNIT(current_drive)))\n\t\tmask &= ~(0x10 << UNIT(current_drive));\n\n\t/* starts motor and selects floppy */\n\tdel_timer(motor_off_timer + current_drive);\n\tset_dor(fdc, mask, data);\n\n\t/* wait_for_completion also schedules reset if needed. */\n\treturn fd_wait_for_completion(DRS->select_date + DP->select_delay,\n\t\t\t\t      function);\n}\n\nstatic void floppy_ready(void)\n{\n\tif (FDCS->reset) {\n\t\treset_fdc();\n\t\treturn;\n\t}\n\tif (start_motor(floppy_ready))\n\t\treturn;\n\tif (fdc_dtr())\n\t\treturn;\n\n\tdebug_dcl(DP->flags, \"calling disk change from floppy_ready\\n\");\n\tif (!(raw_cmd->flags & FD_RAW_NO_MOTOR) &&\n\t    disk_change(current_drive) && !DP->select_delay)\n\t\ttwaddle();\t/* this clears the dcl on certain\n\t\t\t\t * drive/controller combinations */\n\n#ifdef fd_chose_dma_mode\n\tif ((raw_cmd->flags & FD_RAW_READ) || (raw_cmd->flags & FD_RAW_WRITE)) {\n\t\tunsigned long flags = claim_dma_lock();\n\t\tfd_chose_dma_mode(raw_cmd->kernel_data, raw_cmd->length);\n\t\trelease_dma_lock(flags);\n\t}\n#endif\n\n\tif (raw_cmd->flags & (FD_RAW_NEED_SEEK | FD_RAW_NEED_DISK)) {\n\t\tperpendicular_mode();\n\t\tfdc_specify();\t/* must be done here because of hut, hlt ... */\n\t\tseek_floppy();\n\t} else {\n\t\tif ((raw_cmd->flags & FD_RAW_READ) ||\n\t\t    (raw_cmd->flags & FD_RAW_WRITE))\n\t\t\tfdc_specify();\n\t\tsetup_rw_floppy();\n\t}\n}\n\nstatic void floppy_start(void)\n{\n\treschedule_timeout(current_reqD, \"floppy start\");\n\n\tscandrives();\n\tdebug_dcl(DP->flags, \"setting NEWCHANGE in floppy_start\\n\");\n\tset_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags);\n\tfloppy_ready();\n}\n\n/*\n * ========================================================================\n * here ends the bottom half. Exported routines are:\n * floppy_start, floppy_off, floppy_ready, lock_fdc, unlock_fdc, set_fdc,\n * start_motor, reset_fdc, reset_fdc_info, interpret_errors.\n * Initialization also uses output_byte, result, set_dor, floppy_interrupt\n * and set_dor.\n * ========================================================================\n */\n/*\n * General purpose continuations.\n * ==============================\n */\n\nstatic void do_wakeup(void)\n{\n\treschedule_timeout(MAXTIMEOUT, \"do wakeup\");\n\tcont = NULL;\n\tcommand_status += 2;\n\twake_up(&command_done);\n}\n\nstatic const struct cont_t wakeup_cont = {\n\t.interrupt\t= empty,\n\t.redo\t\t= do_wakeup,\n\t.error\t\t= empty,\n\t.done\t\t= (done_f)empty\n};\n\nstatic const struct cont_t intr_cont = {\n\t.interrupt\t= empty,\n\t.redo\t\t= process_fd_request,\n\t.error\t\t= empty,\n\t.done\t\t= (done_f)empty\n};\n\nstatic int wait_til_done(void (*handler)(void), bool interruptible)\n{\n\tint ret;\n\n\tschedule_bh(handler);\n\n\tif (interruptible)\n\t\twait_event_interruptible(command_done, command_status >= 2);\n\telse\n\t\twait_event(command_done, command_status >= 2);\n\n\tif (command_status < 2) {\n\t\tcancel_activity();\n\t\tcont = &intr_cont;\n\t\treset_fdc();\n\t\treturn -EINTR;\n\t}\n\n\tif (FDCS->reset)\n\t\tcommand_status = FD_COMMAND_ERROR;\n\tif (command_status == FD_COMMAND_OKAY)\n\t\tret = 0;\n\telse\n\t\tret = -EIO;\n\tcommand_status = FD_COMMAND_NONE;\n\treturn ret;\n}\n\nstatic void generic_done(int result)\n{\n\tcommand_status = result;\n\tcont = &wakeup_cont;\n}\n\nstatic void generic_success(void)\n{\n\tcont->done(1);\n}\n\nstatic void generic_failure(void)\n{\n\tcont->done(0);\n}\n\nstatic void success_and_wakeup(void)\n{\n\tgeneric_success();\n\tcont->redo();\n}\n\n/*\n * formatting and rw support.\n * ==========================\n */\n\nstatic int next_valid_format(void)\n{\n\tint probed_format;\n\n\tprobed_format = DRS->probed_format;\n\twhile (1) {\n\t\tif (probed_format >= 8 || !DP->autodetect[probed_format]) {\n\t\t\tDRS->probed_format = 0;\n\t\t\treturn 1;\n\t\t}\n\t\tif (floppy_type[DP->autodetect[probed_format]].sect) {\n\t\t\tDRS->probed_format = probed_format;\n\t\t\treturn 0;\n\t\t}\n\t\tprobed_format++;\n\t}\n}\n\nstatic void bad_flp_intr(void)\n{\n\tint err_count;\n\n\tif (probing) {\n\t\tDRS->probed_format++;\n\t\tif (!next_valid_format())\n\t\t\treturn;\n\t}\n\terr_count = ++(*errors);\n\tINFBOUND(DRWE->badness, err_count);\n\tif (err_count > DP->max_errors.abort)\n\t\tcont->done(0);\n\tif (err_count > DP->max_errors.reset)\n\t\tFDCS->reset = 1;\n\telse if (err_count > DP->max_errors.recal)\n\t\tDRS->track = NEED_2_RECAL;\n}\n\nstatic void set_floppy(int drive)\n{\n\tint type = ITYPE(UDRS->fd_device);\n\n\tif (type)\n\t\t_floppy = floppy_type + type;\n\telse\n\t\t_floppy = current_type[drive];\n}\n\n/*\n * formatting support.\n * ===================\n */\nstatic void format_interrupt(void)\n{\n\tswitch (interpret_errors()) {\n\tcase 1:\n\t\tcont->error();\n\tcase 2:\n\t\tbreak;\n\tcase 0:\n\t\tcont->done(1);\n\t}\n\tcont->redo();\n}\n\n#define FM_MODE(x, y) ((y) & ~(((x)->rate & 0x80) >> 1))\n#define CT(x) ((x) | 0xc0)\n\nstatic void setup_format_params(int track)\n{\n\tint n;\n\tint il;\n\tint count;\n\tint head_shift;\n\tint track_shift;\n\tstruct fparm {\n\t\tunsigned char track, head, sect, size;\n\t} *here = (struct fparm *)floppy_track_buffer;\n\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->track = track;\n\n\traw_cmd->flags = (FD_RAW_WRITE | FD_RAW_INTR | FD_RAW_SPIN |\n\t\t\t  FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK);\n\traw_cmd->rate = _floppy->rate & 0x43;\n\traw_cmd->cmd_count = NR_F;\n\tCOMMAND = FM_MODE(_floppy, FD_FORMAT);\n\tDR_SELECT = UNIT(current_drive) + PH_HEAD(_floppy, format_req.head);\n\tF_SIZECODE = FD_SIZECODE(_floppy);\n\tF_SECT_PER_TRACK = _floppy->sect << 2 >> F_SIZECODE;\n\tF_GAP = _floppy->fmt_gap;\n\tF_FILL = FD_FILL_BYTE;\n\n\traw_cmd->kernel_data = floppy_track_buffer;\n\traw_cmd->length = 4 * F_SECT_PER_TRACK;\n\n\tif (!F_SECT_PER_TRACK)\n\t\treturn;\n\n\t/* allow for about 30ms for data transport per track */\n\thead_shift = (F_SECT_PER_TRACK + 5) / 6;\n\n\t/* a ``cylinder'' is two tracks plus a little stepping time */\n\ttrack_shift = 2 * head_shift + 3;\n\n\t/* position of logical sector 1 on this track */\n\tn = (track_shift * format_req.track + head_shift * format_req.head)\n\t    % F_SECT_PER_TRACK;\n\n\t/* determine interleave */\n\til = 1;\n\tif (_floppy->fmt_gap < 0x22)\n\t\til++;\n\n\t/* initialize field */\n\tfor (count = 0; count < F_SECT_PER_TRACK; ++count) {\n\t\there[count].track = format_req.track;\n\t\there[count].head = format_req.head;\n\t\there[count].sect = 0;\n\t\there[count].size = F_SIZECODE;\n\t}\n\t/* place logical sectors */\n\tfor (count = 1; count <= F_SECT_PER_TRACK; ++count) {\n\t\there[n].sect = count;\n\t\tn = (n + il) % F_SECT_PER_TRACK;\n\t\tif (here[n].sect) {\t/* sector busy, find next free sector */\n\t\t\t++n;\n\t\t\tif (n >= F_SECT_PER_TRACK) {\n\t\t\t\tn -= F_SECT_PER_TRACK;\n\t\t\t\twhile (here[n].sect)\n\t\t\t\t\t++n;\n\t\t\t}\n\t\t}\n\t}\n\tif (_floppy->stretch & FD_SECTBASEMASK) {\n\t\tfor (count = 0; count < F_SECT_PER_TRACK; count++)\n\t\t\there[count].sect += FD_SECTBASE(_floppy) - 1;\n\t}\n}\n\nstatic void redo_format(void)\n{\n\tbuffer_track = -1;\n\tsetup_format_params(format_req.track << STRETCH(_floppy));\n\tfloppy_start();\n\tdebugt(__func__, \"queue format request\");\n}\n\nstatic const struct cont_t format_cont = {\n\t.interrupt\t= format_interrupt,\n\t.redo\t\t= redo_format,\n\t.error\t\t= bad_flp_intr,\n\t.done\t\t= generic_done\n};\n\nstatic int do_format(int drive, struct format_descr *tmp_format_req)\n{\n\tint ret;\n\n\tif (lock_fdc(drive))\n\t\treturn -EINTR;\n\n\tset_floppy(drive);\n\tif (!_floppy ||\n\t    _floppy->track > DP->tracks ||\n\t    tmp_format_req->track >= _floppy->track ||\n\t    tmp_format_req->head >= _floppy->head ||\n\t    (_floppy->sect << 2) % (1 << FD_SIZECODE(_floppy)) ||\n\t    !_floppy->fmt_gap) {\n\t\tprocess_fd_request();\n\t\treturn -EINVAL;\n\t}\n\tformat_req = *tmp_format_req;\n\tformat_errors = 0;\n\tcont = &format_cont;\n\terrors = &format_errors;\n\tret = wait_til_done(redo_format, true);\n\tif (ret == -EINTR)\n\t\treturn -EINTR;\n\tprocess_fd_request();\n\treturn ret;\n}\n\n/*\n * Buffer read/write and support\n * =============================\n */\n\nstatic void floppy_end_request(struct request *req, blk_status_t error)\n{\n\tunsigned int nr_sectors = current_count_sectors;\n\tunsigned int drive = (unsigned long)req->rq_disk->private_data;\n\n\t/* current_count_sectors can be zero if transfer failed */\n\tif (error)\n\t\tnr_sectors = blk_rq_cur_sectors(req);\n\tif (blk_update_request(req, error, nr_sectors << 9))\n\t\treturn;\n\t__blk_mq_end_request(req, error);\n\n\t/* We're done with the request */\n\tfloppy_off(drive);\n\tcurrent_req = NULL;\n}\n\n/* new request_done. Can handle physical sectors which are smaller than a\n * logical buffer */\nstatic void request_done(int uptodate)\n{\n\tstruct request *req = current_req;\n\tint block;\n\tchar msg[sizeof(\"request done \") + sizeof(int) * 3];\n\n\tprobing = 0;\n\tsnprintf(msg, sizeof(msg), \"request done %d\", uptodate);\n\treschedule_timeout(MAXTIMEOUT, msg);\n\n\tif (!req) {\n\t\tpr_info(\"floppy.c: no request in request_done\\n\");\n\t\treturn;\n\t}\n\n\tif (uptodate) {\n\t\t/* maintain values for invalidation on geometry\n\t\t * change */\n\t\tblock = current_count_sectors + blk_rq_pos(req);\n\t\tINFBOUND(DRS->maxblock, block);\n\t\tif (block > _floppy->sect)\n\t\t\tDRS->maxtrack = 1;\n\n\t\tfloppy_end_request(req, 0);\n\t} else {\n\t\tif (rq_data_dir(req) == WRITE) {\n\t\t\t/* record write error information */\n\t\t\tDRWE->write_errors++;\n\t\t\tif (DRWE->write_errors == 1) {\n\t\t\t\tDRWE->first_error_sector = blk_rq_pos(req);\n\t\t\t\tDRWE->first_error_generation = DRS->generation;\n\t\t\t}\n\t\t\tDRWE->last_error_sector = blk_rq_pos(req);\n\t\t\tDRWE->last_error_generation = DRS->generation;\n\t\t}\n\t\tfloppy_end_request(req, BLK_STS_IOERR);\n\t}\n}\n\n/* Interrupt handler evaluating the result of the r/w operation */\nstatic void rw_interrupt(void)\n{\n\tint eoc;\n\tint ssize;\n\tint heads;\n\tint nr_sectors;\n\n\tif (R_HEAD >= 2) {\n\t\t/* some Toshiba floppy controllers occasionnally seem to\n\t\t * return bogus interrupts after read/write operations, which\n\t\t * can be recognized by a bad head number (>= 2) */\n\t\treturn;\n\t}\n\n\tif (!DRS->first_read_date)\n\t\tDRS->first_read_date = jiffies;\n\n\tnr_sectors = 0;\n\tssize = DIV_ROUND_UP(1 << SIZECODE, 4);\n\n\tif (ST1 & ST1_EOC)\n\t\teoc = 1;\n\telse\n\t\teoc = 0;\n\n\tif (COMMAND & 0x80)\n\t\theads = 2;\n\telse\n\t\theads = 1;\n\n\tnr_sectors = (((R_TRACK - TRACK) * heads +\n\t\t       R_HEAD - HEAD) * SECT_PER_TRACK +\n\t\t      R_SECTOR - SECTOR + eoc) << SIZECODE >> 2;\n\n\tif (nr_sectors / ssize >\n\t    DIV_ROUND_UP(in_sector_offset + current_count_sectors, ssize)) {\n\t\tDPRINT(\"long rw: %x instead of %lx\\n\",\n\t\t       nr_sectors, current_count_sectors);\n\t\tpr_info(\"rs=%d s=%d\\n\", R_SECTOR, SECTOR);\n\t\tpr_info(\"rh=%d h=%d\\n\", R_HEAD, HEAD);\n\t\tpr_info(\"rt=%d t=%d\\n\", R_TRACK, TRACK);\n\t\tpr_info(\"heads=%d eoc=%d\\n\", heads, eoc);\n\t\tpr_info(\"spt=%d st=%d ss=%d\\n\",\n\t\t\tSECT_PER_TRACK, fsector_t, ssize);\n\t\tpr_info(\"in_sector_offset=%d\\n\", in_sector_offset);\n\t}\n\n\tnr_sectors -= in_sector_offset;\n\tINFBOUND(nr_sectors, 0);\n\tSUPBOUND(current_count_sectors, nr_sectors);\n\n\tswitch (interpret_errors()) {\n\tcase 2:\n\t\tcont->redo();\n\t\treturn;\n\tcase 1:\n\t\tif (!current_count_sectors) {\n\t\t\tcont->error();\n\t\t\tcont->redo();\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase 0:\n\t\tif (!current_count_sectors) {\n\t\t\tcont->redo();\n\t\t\treturn;\n\t\t}\n\t\tcurrent_type[current_drive] = _floppy;\n\t\tfloppy_sizes[TOMINOR(current_drive)] = _floppy->size;\n\t\tbreak;\n\t}\n\n\tif (probing) {\n\t\tif (DP->flags & FTD_MSG)\n\t\t\tDPRINT(\"Auto-detected floppy type %s in fd%d\\n\",\n\t\t\t       _floppy->name, current_drive);\n\t\tcurrent_type[current_drive] = _floppy;\n\t\tfloppy_sizes[TOMINOR(current_drive)] = _floppy->size;\n\t\tprobing = 0;\n\t}\n\n\tif (CT(COMMAND) != FD_READ ||\n\t    raw_cmd->kernel_data == bio_data(current_req->bio)) {\n\t\t/* transfer directly from buffer */\n\t\tcont->done(1);\n\t} else if (CT(COMMAND) == FD_READ) {\n\t\tbuffer_track = raw_cmd->track;\n\t\tbuffer_drive = current_drive;\n\t\tINFBOUND(buffer_max, nr_sectors + fsector_t);\n\t}\n\tcont->redo();\n}\n\n/* Compute maximal contiguous buffer size. */\nstatic int buffer_chain_size(void)\n{\n\tstruct bio_vec bv;\n\tint size;\n\tstruct req_iterator iter;\n\tchar *base;\n\n\tbase = bio_data(current_req->bio);\n\tsize = 0;\n\n\trq_for_each_segment(bv, current_req, iter) {\n\t\tif (page_address(bv.bv_page) + bv.bv_offset != base + size)\n\t\t\tbreak;\n\n\t\tsize += bv.bv_len;\n\t}\n\n\treturn size >> 9;\n}\n\n/* Compute the maximal transfer size */\nstatic int transfer_size(int ssize, int max_sector, int max_size)\n{\n\tSUPBOUND(max_sector, fsector_t + max_size);\n\n\t/* alignment */\n\tmax_sector -= (max_sector % _floppy->sect) % ssize;\n\n\t/* transfer size, beginning not aligned */\n\tcurrent_count_sectors = max_sector - fsector_t;\n\n\treturn max_sector;\n}\n\n/*\n * Move data from/to the track buffer to/from the buffer cache.\n */\nstatic void copy_buffer(int ssize, int max_sector, int max_sector_2)\n{\n\tint remaining;\t\t/* number of transferred 512-byte sectors */\n\tstruct bio_vec bv;\n\tchar *buffer;\n\tchar *dma_buffer;\n\tint size;\n\tstruct req_iterator iter;\n\n\tmax_sector = transfer_size(ssize,\n\t\t\t\t   min(max_sector, max_sector_2),\n\t\t\t\t   blk_rq_sectors(current_req));\n\n\tif (current_count_sectors <= 0 && CT(COMMAND) == FD_WRITE &&\n\t    buffer_max > fsector_t + blk_rq_sectors(current_req))\n\t\tcurrent_count_sectors = min_t(int, buffer_max - fsector_t,\n\t\t\t\t\t      blk_rq_sectors(current_req));\n\n\tremaining = current_count_sectors << 9;\n\tif (remaining > blk_rq_bytes(current_req) && CT(COMMAND) == FD_WRITE) {\n\t\tDPRINT(\"in copy buffer\\n\");\n\t\tpr_info(\"current_count_sectors=%ld\\n\", current_count_sectors);\n\t\tpr_info(\"remaining=%d\\n\", remaining >> 9);\n\t\tpr_info(\"current_req->nr_sectors=%u\\n\",\n\t\t\tblk_rq_sectors(current_req));\n\t\tpr_info(\"current_req->current_nr_sectors=%u\\n\",\n\t\t\tblk_rq_cur_sectors(current_req));\n\t\tpr_info(\"max_sector=%d\\n\", max_sector);\n\t\tpr_info(\"ssize=%d\\n\", ssize);\n\t}\n\n\tbuffer_max = max(max_sector, buffer_max);\n\n\tdma_buffer = floppy_track_buffer + ((fsector_t - buffer_min) << 9);\n\n\tsize = blk_rq_cur_bytes(current_req);\n\n\trq_for_each_segment(bv, current_req, iter) {\n\t\tif (!remaining)\n\t\t\tbreak;\n\n\t\tsize = bv.bv_len;\n\t\tSUPBOUND(size, remaining);\n\n\t\tbuffer = page_address(bv.bv_page) + bv.bv_offset;\n\t\tif (dma_buffer + size >\n\t\t    floppy_track_buffer + (max_buffer_sectors << 10) ||\n\t\t    dma_buffer < floppy_track_buffer) {\n\t\t\tDPRINT(\"buffer overrun in copy buffer %d\\n\",\n\t\t\t       (int)((floppy_track_buffer - dma_buffer) >> 9));\n\t\t\tpr_info(\"fsector_t=%d buffer_min=%d\\n\",\n\t\t\t\tfsector_t, buffer_min);\n\t\t\tpr_info(\"current_count_sectors=%ld\\n\",\n\t\t\t\tcurrent_count_sectors);\n\t\t\tif (CT(COMMAND) == FD_READ)\n\t\t\t\tpr_info(\"read\\n\");\n\t\t\tif (CT(COMMAND) == FD_WRITE)\n\t\t\t\tpr_info(\"write\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (((unsigned long)buffer) % 512)\n\t\t\tDPRINT(\"%p buffer not aligned\\n\", buffer);\n\n\t\tif (CT(COMMAND) == FD_READ)\n\t\t\tmemcpy(buffer, dma_buffer, size);\n\t\telse\n\t\t\tmemcpy(dma_buffer, buffer, size);\n\n\t\tremaining -= size;\n\t\tdma_buffer += size;\n\t}\n\tif (remaining) {\n\t\tif (remaining > 0)\n\t\t\tmax_sector -= remaining >> 9;\n\t\tDPRINT(\"weirdness: remaining %d\\n\", remaining >> 9);\n\t}\n}\n\n/* work around a bug in pseudo DMA\n * (on some FDCs) pseudo DMA does not stop when the CPU stops\n * sending data.  Hence we need a different way to signal the\n * transfer length:  We use SECT_PER_TRACK.  Unfortunately, this\n * does not work with MT, hence we can only transfer one head at\n * a time\n */\nstatic void virtualdmabug_workaround(void)\n{\n\tint hard_sectors;\n\tint end_sector;\n\n\tif (CT(COMMAND) == FD_WRITE) {\n\t\tCOMMAND &= ~0x80;\t/* switch off multiple track mode */\n\n\t\thard_sectors = raw_cmd->length >> (7 + SIZECODE);\n\t\tend_sector = SECTOR + hard_sectors - 1;\n\t\tif (end_sector > SECT_PER_TRACK) {\n\t\t\tpr_info(\"too many sectors %d > %d\\n\",\n\t\t\t\tend_sector, SECT_PER_TRACK);\n\t\t\treturn;\n\t\t}\n\t\tSECT_PER_TRACK = end_sector;\n\t\t\t\t\t/* make sure SECT_PER_TRACK\n\t\t\t\t\t * points to end of transfer */\n\t}\n}\n\n/*\n * Formulate a read/write request.\n * this routine decides where to load the data (directly to buffer, or to\n * tmp floppy area), how much data to load (the size of the buffer, the whole\n * track, or a single sector)\n * All floppy_track_buffer handling goes in here. If we ever add track buffer\n * allocation on the fly, it should be done here. No other part should need\n * modification.\n */\n\nstatic int make_raw_rw_request(void)\n{\n\tint aligned_sector_t;\n\tint max_sector;\n\tint max_size;\n\tint tracksize;\n\tint ssize;\n\n\tif (WARN(max_buffer_sectors == 0, \"VFS: Block I/O scheduled on unopened device\\n\"))\n\t\treturn 0;\n\n\tset_fdc((long)current_req->rq_disk->private_data);\n\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->flags = FD_RAW_SPIN | FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK;\n\traw_cmd->cmd_count = NR_RW;\n\tif (rq_data_dir(current_req) == READ) {\n\t\traw_cmd->flags |= FD_RAW_READ;\n\t\tCOMMAND = FM_MODE(_floppy, FD_READ);\n\t} else if (rq_data_dir(current_req) == WRITE) {\n\t\traw_cmd->flags |= FD_RAW_WRITE;\n\t\tCOMMAND = FM_MODE(_floppy, FD_WRITE);\n\t} else {\n\t\tDPRINT(\"%s: unknown command\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tmax_sector = _floppy->sect * _floppy->head;\n\n\tTRACK = (int)blk_rq_pos(current_req) / max_sector;\n\tfsector_t = (int)blk_rq_pos(current_req) % max_sector;\n\tif (_floppy->track && TRACK >= _floppy->track) {\n\t\tif (blk_rq_cur_sectors(current_req) & 1) {\n\t\t\tcurrent_count_sectors = 1;\n\t\t\treturn 1;\n\t\t} else\n\t\t\treturn 0;\n\t}\n\tHEAD = fsector_t / _floppy->sect;\n\n\tif (((_floppy->stretch & (FD_SWAPSIDES | FD_SECTBASEMASK)) ||\n\t     test_bit(FD_NEED_TWADDLE_BIT, &DRS->flags)) &&\n\t    fsector_t < _floppy->sect)\n\t\tmax_sector = _floppy->sect;\n\n\t/* 2M disks have phantom sectors on the first track */\n\tif ((_floppy->rate & FD_2M) && (!TRACK) && (!HEAD)) {\n\t\tmax_sector = 2 * _floppy->sect / 3;\n\t\tif (fsector_t >= max_sector) {\n\t\t\tcurrent_count_sectors =\n\t\t\t    min_t(int, _floppy->sect - fsector_t,\n\t\t\t\t  blk_rq_sectors(current_req));\n\t\t\treturn 1;\n\t\t}\n\t\tSIZECODE = 2;\n\t} else\n\t\tSIZECODE = FD_SIZECODE(_floppy);\n\traw_cmd->rate = _floppy->rate & 0x43;\n\tif ((_floppy->rate & FD_2M) && (TRACK || HEAD) && raw_cmd->rate == 2)\n\t\traw_cmd->rate = 1;\n\n\tif (SIZECODE)\n\t\tSIZECODE2 = 0xff;\n\telse\n\t\tSIZECODE2 = 0x80;\n\traw_cmd->track = TRACK << STRETCH(_floppy);\n\tDR_SELECT = UNIT(current_drive) + PH_HEAD(_floppy, HEAD);\n\tGAP = _floppy->gap;\n\tssize = DIV_ROUND_UP(1 << SIZECODE, 4);\n\tSECT_PER_TRACK = _floppy->sect << 2 >> SIZECODE;\n\tSECTOR = ((fsector_t % _floppy->sect) << 2 >> SIZECODE) +\n\t    FD_SECTBASE(_floppy);\n\n\t/* tracksize describes the size which can be filled up with sectors\n\t * of size ssize.\n\t */\n\ttracksize = _floppy->sect - _floppy->sect % ssize;\n\tif (tracksize < _floppy->sect) {\n\t\tSECT_PER_TRACK++;\n\t\tif (tracksize <= fsector_t % _floppy->sect)\n\t\t\tSECTOR--;\n\n\t\t/* if we are beyond tracksize, fill up using smaller sectors */\n\t\twhile (tracksize <= fsector_t % _floppy->sect) {\n\t\t\twhile (tracksize + ssize > _floppy->sect) {\n\t\t\t\tSIZECODE--;\n\t\t\t\tssize >>= 1;\n\t\t\t}\n\t\t\tSECTOR++;\n\t\t\tSECT_PER_TRACK++;\n\t\t\ttracksize += ssize;\n\t\t}\n\t\tmax_sector = HEAD * _floppy->sect + tracksize;\n\t} else if (!TRACK && !HEAD && !(_floppy->rate & FD_2M) && probing) {\n\t\tmax_sector = _floppy->sect;\n\t} else if (!HEAD && CT(COMMAND) == FD_WRITE) {\n\t\t/* for virtual DMA bug workaround */\n\t\tmax_sector = _floppy->sect;\n\t}\n\n\tin_sector_offset = (fsector_t % _floppy->sect) % ssize;\n\taligned_sector_t = fsector_t - in_sector_offset;\n\tmax_size = blk_rq_sectors(current_req);\n\tif ((raw_cmd->track == buffer_track) &&\n\t    (current_drive == buffer_drive) &&\n\t    (fsector_t >= buffer_min) && (fsector_t < buffer_max)) {\n\t\t/* data already in track buffer */\n\t\tif (CT(COMMAND) == FD_READ) {\n\t\t\tcopy_buffer(1, max_sector, buffer_max);\n\t\t\treturn 1;\n\t\t}\n\t} else if (in_sector_offset || blk_rq_sectors(current_req) < ssize) {\n\t\tif (CT(COMMAND) == FD_WRITE) {\n\t\t\tunsigned int sectors;\n\n\t\t\tsectors = fsector_t + blk_rq_sectors(current_req);\n\t\t\tif (sectors > ssize && sectors < ssize + ssize)\n\t\t\t\tmax_size = ssize + ssize;\n\t\t\telse\n\t\t\t\tmax_size = ssize;\n\t\t}\n\t\traw_cmd->flags &= ~FD_RAW_WRITE;\n\t\traw_cmd->flags |= FD_RAW_READ;\n\t\tCOMMAND = FM_MODE(_floppy, FD_READ);\n\t} else if ((unsigned long)bio_data(current_req->bio) < MAX_DMA_ADDRESS) {\n\t\tunsigned long dma_limit;\n\t\tint direct, indirect;\n\n\t\tindirect =\n\t\t    transfer_size(ssize, max_sector,\n\t\t\t\t  max_buffer_sectors * 2) - fsector_t;\n\n\t\t/*\n\t\t * Do NOT use minimum() here---MAX_DMA_ADDRESS is 64 bits wide\n\t\t * on a 64 bit machine!\n\t\t */\n\t\tmax_size = buffer_chain_size();\n\t\tdma_limit = (MAX_DMA_ADDRESS -\n\t\t\t     ((unsigned long)bio_data(current_req->bio))) >> 9;\n\t\tif ((unsigned long)max_size > dma_limit)\n\t\t\tmax_size = dma_limit;\n\t\t/* 64 kb boundaries */\n\t\tif (CROSS_64KB(bio_data(current_req->bio), max_size << 9))\n\t\t\tmax_size = (K_64 -\n\t\t\t\t    ((unsigned long)bio_data(current_req->bio)) %\n\t\t\t\t    K_64) >> 9;\n\t\tdirect = transfer_size(ssize, max_sector, max_size) - fsector_t;\n\t\t/*\n\t\t * We try to read tracks, but if we get too many errors, we\n\t\t * go back to reading just one sector at a time.\n\t\t *\n\t\t * This means we should be able to read a sector even if there\n\t\t * are other bad sectors on this track.\n\t\t */\n\t\tif (!direct ||\n\t\t    (indirect * 2 > direct * 3 &&\n\t\t     *errors < DP->max_errors.read_track &&\n\t\t     ((!probing ||\n\t\t       (DP->read_track & (1 << DRS->probed_format)))))) {\n\t\t\tmax_size = blk_rq_sectors(current_req);\n\t\t} else {\n\t\t\traw_cmd->kernel_data = bio_data(current_req->bio);\n\t\t\traw_cmd->length = current_count_sectors << 9;\n\t\t\tif (raw_cmd->length == 0) {\n\t\t\t\tDPRINT(\"%s: zero dma transfer attempted\\n\", __func__);\n\t\t\t\tDPRINT(\"indirect=%d direct=%d fsector_t=%d\\n\",\n\t\t\t\t       indirect, direct, fsector_t);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tvirtualdmabug_workaround();\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\tif (CT(COMMAND) == FD_READ)\n\t\tmax_size = max_sector;\t/* unbounded */\n\n\t/* claim buffer track if needed */\n\tif (buffer_track != raw_cmd->track ||\t/* bad track */\n\t    buffer_drive != current_drive ||\t/* bad drive */\n\t    fsector_t > buffer_max ||\n\t    fsector_t < buffer_min ||\n\t    ((CT(COMMAND) == FD_READ ||\n\t      (!in_sector_offset && blk_rq_sectors(current_req) >= ssize)) &&\n\t     max_sector > 2 * max_buffer_sectors + buffer_min &&\n\t     max_size + fsector_t > 2 * max_buffer_sectors + buffer_min)) {\n\t\t/* not enough space */\n\t\tbuffer_track = -1;\n\t\tbuffer_drive = current_drive;\n\t\tbuffer_max = buffer_min = aligned_sector_t;\n\t}\n\traw_cmd->kernel_data = floppy_track_buffer +\n\t\t((aligned_sector_t - buffer_min) << 9);\n\n\tif (CT(COMMAND) == FD_WRITE) {\n\t\t/* copy write buffer to track buffer.\n\t\t * if we get here, we know that the write\n\t\t * is either aligned or the data already in the buffer\n\t\t * (buffer will be overwritten) */\n\t\tif (in_sector_offset && buffer_track == -1)\n\t\t\tDPRINT(\"internal error offset !=0 on write\\n\");\n\t\tbuffer_track = raw_cmd->track;\n\t\tbuffer_drive = current_drive;\n\t\tcopy_buffer(ssize, max_sector,\n\t\t\t    2 * max_buffer_sectors + buffer_min);\n\t} else\n\t\ttransfer_size(ssize, max_sector,\n\t\t\t      2 * max_buffer_sectors + buffer_min -\n\t\t\t      aligned_sector_t);\n\n\t/* round up current_count_sectors to get dma xfer size */\n\traw_cmd->length = in_sector_offset + current_count_sectors;\n\traw_cmd->length = ((raw_cmd->length - 1) | (ssize - 1)) + 1;\n\traw_cmd->length <<= 9;\n\tif ((raw_cmd->length < current_count_sectors << 9) ||\n\t    (raw_cmd->kernel_data != bio_data(current_req->bio) &&\n\t     CT(COMMAND) == FD_WRITE &&\n\t     (aligned_sector_t + (raw_cmd->length >> 9) > buffer_max ||\n\t      aligned_sector_t < buffer_min)) ||\n\t    raw_cmd->length % (128 << SIZECODE) ||\n\t    raw_cmd->length <= 0 || current_count_sectors <= 0) {\n\t\tDPRINT(\"fractionary current count b=%lx s=%lx\\n\",\n\t\t       raw_cmd->length, current_count_sectors);\n\t\tif (raw_cmd->kernel_data != bio_data(current_req->bio))\n\t\t\tpr_info(\"addr=%d, length=%ld\\n\",\n\t\t\t\t(int)((raw_cmd->kernel_data -\n\t\t\t\t       floppy_track_buffer) >> 9),\n\t\t\t\tcurrent_count_sectors);\n\t\tpr_info(\"st=%d ast=%d mse=%d msi=%d\\n\",\n\t\t\tfsector_t, aligned_sector_t, max_sector, max_size);\n\t\tpr_info(\"ssize=%x SIZECODE=%d\\n\", ssize, SIZECODE);\n\t\tpr_info(\"command=%x SECTOR=%d HEAD=%d, TRACK=%d\\n\",\n\t\t\tCOMMAND, SECTOR, HEAD, TRACK);\n\t\tpr_info(\"buffer drive=%d\\n\", buffer_drive);\n\t\tpr_info(\"buffer track=%d\\n\", buffer_track);\n\t\tpr_info(\"buffer_min=%d\\n\", buffer_min);\n\t\tpr_info(\"buffer_max=%d\\n\", buffer_max);\n\t\treturn 0;\n\t}\n\n\tif (raw_cmd->kernel_data != bio_data(current_req->bio)) {\n\t\tif (raw_cmd->kernel_data < floppy_track_buffer ||\n\t\t    current_count_sectors < 0 ||\n\t\t    raw_cmd->length < 0 ||\n\t\t    raw_cmd->kernel_data + raw_cmd->length >\n\t\t    floppy_track_buffer + (max_buffer_sectors << 10)) {\n\t\t\tDPRINT(\"buffer overrun in schedule dma\\n\");\n\t\t\tpr_info(\"fsector_t=%d buffer_min=%d current_count=%ld\\n\",\n\t\t\t\tfsector_t, buffer_min, raw_cmd->length >> 9);\n\t\t\tpr_info(\"current_count_sectors=%ld\\n\",\n\t\t\t\tcurrent_count_sectors);\n\t\t\tif (CT(COMMAND) == FD_READ)\n\t\t\t\tpr_info(\"read\\n\");\n\t\t\tif (CT(COMMAND) == FD_WRITE)\n\t\t\t\tpr_info(\"write\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else if (raw_cmd->length > blk_rq_bytes(current_req) ||\n\t\t   current_count_sectors > blk_rq_sectors(current_req)) {\n\t\tDPRINT(\"buffer overrun in direct transfer\\n\");\n\t\treturn 0;\n\t} else if (raw_cmd->length < current_count_sectors << 9) {\n\t\tDPRINT(\"more sectors than bytes\\n\");\n\t\tpr_info(\"bytes=%ld\\n\", raw_cmd->length >> 9);\n\t\tpr_info(\"sectors=%ld\\n\", current_count_sectors);\n\t}\n\tif (raw_cmd->length == 0) {\n\t\tDPRINT(\"zero dma transfer attempted from make_raw_request\\n\");\n\t\treturn 0;\n\t}\n\n\tvirtualdmabug_workaround();\n\treturn 2;\n}\n\nstatic int set_next_request(void)\n{\n\tcurrent_req = list_first_entry_or_null(&floppy_reqs, struct request,\n\t\t\t\t\t       queuelist);\n\tif (current_req) {\n\t\tcurrent_req->error_count = 0;\n\t\tlist_del_init(&current_req->queuelist);\n\t}\n\treturn current_req != NULL;\n}\n\nstatic void redo_fd_request(void)\n{\n\tint drive;\n\tint tmp;\n\n\tlastredo = jiffies;\n\tif (current_drive < N_DRIVE)\n\t\tfloppy_off(current_drive);\n\ndo_request:\n\tif (!current_req) {\n\t\tint pending;\n\n\t\tspin_lock_irq(&floppy_lock);\n\t\tpending = set_next_request();\n\t\tspin_unlock_irq(&floppy_lock);\n\t\tif (!pending) {\n\t\t\tdo_floppy = NULL;\n\t\t\tunlock_fdc();\n\t\t\treturn;\n\t\t}\n\t}\n\tdrive = (long)current_req->rq_disk->private_data;\n\tset_fdc(drive);\n\treschedule_timeout(current_reqD, \"redo fd request\");\n\n\tset_floppy(drive);\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->flags = 0;\n\tif (start_motor(redo_fd_request))\n\t\treturn;\n\n\tdisk_change(current_drive);\n\tif (test_bit(current_drive, &fake_change) ||\n\t    test_bit(FD_DISK_CHANGED_BIT, &DRS->flags)) {\n\t\tDPRINT(\"disk absent or changed during operation\\n\");\n\t\trequest_done(0);\n\t\tgoto do_request;\n\t}\n\tif (!_floppy) {\t/* Autodetection */\n\t\tif (!probing) {\n\t\t\tDRS->probed_format = 0;\n\t\t\tif (next_valid_format()) {\n\t\t\t\tDPRINT(\"no autodetectable formats\\n\");\n\t\t\t\t_floppy = NULL;\n\t\t\t\trequest_done(0);\n\t\t\t\tgoto do_request;\n\t\t\t}\n\t\t}\n\t\tprobing = 1;\n\t\t_floppy = floppy_type + DP->autodetect[DRS->probed_format];\n\t} else\n\t\tprobing = 0;\n\terrors = &(current_req->error_count);\n\ttmp = make_raw_rw_request();\n\tif (tmp < 2) {\n\t\trequest_done(tmp);\n\t\tgoto do_request;\n\t}\n\n\tif (test_bit(FD_NEED_TWADDLE_BIT, &DRS->flags))\n\t\ttwaddle();\n\tschedule_bh(floppy_start);\n\tdebugt(__func__, \"queue fd request\");\n\treturn;\n}\n\nstatic const struct cont_t rw_cont = {\n\t.interrupt\t= rw_interrupt,\n\t.redo\t\t= redo_fd_request,\n\t.error\t\t= bad_flp_intr,\n\t.done\t\t= request_done\n};\n\nstatic void process_fd_request(void)\n{\n\tcont = &rw_cont;\n\tschedule_bh(redo_fd_request);\n}\n\nstatic blk_status_t floppy_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t    const struct blk_mq_queue_data *bd)\n{\n\tblk_mq_start_request(bd->rq);\n\n\tif (WARN(max_buffer_sectors == 0,\n\t\t \"VFS: %s called on non-open device\\n\", __func__))\n\t\treturn BLK_STS_IOERR;\n\n\tif (WARN(atomic_read(&usage_count) == 0,\n\t\t \"warning: usage count=0, current_req=%p sect=%ld flags=%llx\\n\",\n\t\t current_req, (long)blk_rq_pos(current_req),\n\t\t (unsigned long long) current_req->cmd_flags))\n\t\treturn BLK_STS_IOERR;\n\n\tspin_lock_irq(&floppy_lock);\n\tlist_add_tail(&bd->rq->queuelist, &floppy_reqs);\n\tspin_unlock_irq(&floppy_lock);\n\n\tif (test_and_set_bit(0, &fdc_busy)) {\n\t\t/* fdc busy, this new request will be treated when the\n\t\t   current one is done */\n\t\tis_alive(__func__, \"old request running\");\n\t\treturn BLK_STS_OK;\n\t}\n\n\tcommand_status = FD_COMMAND_NONE;\n\t__reschedule_timeout(MAXTIMEOUT, \"fd_request\");\n\tset_fdc(0);\n\tprocess_fd_request();\n\tis_alive(__func__, \"\");\n\treturn BLK_STS_OK;\n}\n\nstatic const struct cont_t poll_cont = {\n\t.interrupt\t= success_and_wakeup,\n\t.redo\t\t= floppy_ready,\n\t.error\t\t= generic_failure,\n\t.done\t\t= generic_done\n};\n\nstatic int poll_drive(bool interruptible, int flag)\n{\n\t/* no auto-sense, just clear dcl */\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->flags = flag;\n\traw_cmd->track = 0;\n\traw_cmd->cmd_count = 0;\n\tcont = &poll_cont;\n\tdebug_dcl(DP->flags, \"setting NEWCHANGE in poll_drive\\n\");\n\tset_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags);\n\n\treturn wait_til_done(floppy_ready, interruptible);\n}\n\n/*\n * User triggered reset\n * ====================\n */\n\nstatic void reset_intr(void)\n{\n\tpr_info(\"weird, reset interrupt called\\n\");\n}\n\nstatic const struct cont_t reset_cont = {\n\t.interrupt\t= reset_intr,\n\t.redo\t\t= success_and_wakeup,\n\t.error\t\t= generic_failure,\n\t.done\t\t= generic_done\n};\n\nstatic int user_reset_fdc(int drive, int arg, bool interruptible)\n{\n\tint ret;\n\n\tif (lock_fdc(drive))\n\t\treturn -EINTR;\n\n\tif (arg == FD_RESET_ALWAYS)\n\t\tFDCS->reset = 1;\n\tif (FDCS->reset) {\n\t\tcont = &reset_cont;\n\t\tret = wait_til_done(reset_fdc, interruptible);\n\t\tif (ret == -EINTR)\n\t\t\treturn -EINTR;\n\t}\n\tprocess_fd_request();\n\treturn 0;\n}\n\n/*\n * Misc Ioctl's and support\n * ========================\n */\nstatic inline int fd_copyout(void __user *param, const void *address,\n\t\t\t     unsigned long size)\n{\n\treturn copy_to_user(param, address, size) ? -EFAULT : 0;\n}\n\nstatic inline int fd_copyin(void __user *param, void *address,\n\t\t\t    unsigned long size)\n{\n\treturn copy_from_user(address, param, size) ? -EFAULT : 0;\n}\n\nstatic const char *drive_name(int type, int drive)\n{\n\tstruct floppy_struct *floppy;\n\n\tif (type)\n\t\tfloppy = floppy_type + type;\n\telse {\n\t\tif (UDP->native_format)\n\t\t\tfloppy = floppy_type + UDP->native_format;\n\t\telse\n\t\t\treturn \"(null)\";\n\t}\n\tif (floppy->name)\n\t\treturn floppy->name;\n\telse\n\t\treturn \"(null)\";\n}\n\n/* raw commands */\nstatic void raw_cmd_done(int flag)\n{\n\tint i;\n\n\tif (!flag) {\n\t\traw_cmd->flags |= FD_RAW_FAILURE;\n\t\traw_cmd->flags |= FD_RAW_HARDFAILURE;\n\t} else {\n\t\traw_cmd->reply_count = inr;\n\t\tif (raw_cmd->reply_count > MAX_REPLIES)\n\t\t\traw_cmd->reply_count = 0;\n\t\tfor (i = 0; i < raw_cmd->reply_count; i++)\n\t\t\traw_cmd->reply[i] = reply_buffer[i];\n\n\t\tif (raw_cmd->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\t\tunsigned long flags;\n\t\t\tflags = claim_dma_lock();\n\t\t\traw_cmd->length = fd_get_dma_residue();\n\t\t\trelease_dma_lock(flags);\n\t\t}\n\n\t\tif ((raw_cmd->flags & FD_RAW_SOFTFAILURE) &&\n\t\t    (!raw_cmd->reply_count || (raw_cmd->reply[0] & 0xc0)))\n\t\t\traw_cmd->flags |= FD_RAW_FAILURE;\n\n\t\tif (disk_change(current_drive))\n\t\t\traw_cmd->flags |= FD_RAW_DISK_CHANGE;\n\t\telse\n\t\t\traw_cmd->flags &= ~FD_RAW_DISK_CHANGE;\n\t\tif (raw_cmd->flags & FD_RAW_NO_MOTOR_AFTER)\n\t\t\tmotor_off_callback(&motor_off_timer[current_drive]);\n\n\t\tif (raw_cmd->next &&\n\t\t    (!(raw_cmd->flags & FD_RAW_FAILURE) ||\n\t\t     !(raw_cmd->flags & FD_RAW_STOP_IF_FAILURE)) &&\n\t\t    ((raw_cmd->flags & FD_RAW_FAILURE) ||\n\t\t     !(raw_cmd->flags & FD_RAW_STOP_IF_SUCCESS))) {\n\t\t\traw_cmd = raw_cmd->next;\n\t\t\treturn;\n\t\t}\n\t}\n\tgeneric_done(flag);\n}\n\nstatic const struct cont_t raw_cmd_cont = {\n\t.interrupt\t= success_and_wakeup,\n\t.redo\t\t= floppy_start,\n\t.error\t\t= generic_failure,\n\t.done\t\t= raw_cmd_done\n};\n\nstatic int raw_cmd_copyout(int cmd, void __user *param,\n\t\t\t\t  struct floppy_raw_cmd *ptr)\n{\n\tint ret;\n\n\twhile (ptr) {\n\t\tstruct floppy_raw_cmd cmd = *ptr;\n\t\tcmd.next = NULL;\n\t\tcmd.kernel_data = NULL;\n\t\tret = copy_to_user(param, &cmd, sizeof(cmd));\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tparam += sizeof(struct floppy_raw_cmd);\n\t\tif ((ptr->flags & FD_RAW_READ) && ptr->buffer_length) {\n\t\t\tif (ptr->length >= 0 &&\n\t\t\t    ptr->length <= ptr->buffer_length) {\n\t\t\t\tlong length = ptr->buffer_length - ptr->length;\n\t\t\t\tret = fd_copyout(ptr->data, ptr->kernel_data,\n\t\t\t\t\t\t length);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\treturn 0;\n}\n\nstatic void raw_cmd_free(struct floppy_raw_cmd **ptr)\n{\n\tstruct floppy_raw_cmd *next;\n\tstruct floppy_raw_cmd *this;\n\n\tthis = *ptr;\n\t*ptr = NULL;\n\twhile (this) {\n\t\tif (this->buffer_length) {\n\t\t\tfd_dma_mem_free((unsigned long)this->kernel_data,\n\t\t\t\t\tthis->buffer_length);\n\t\t\tthis->buffer_length = 0;\n\t\t}\n\t\tnext = this->next;\n\t\tkfree(this);\n\t\tthis = next;\n\t}\n}\n\nstatic int raw_cmd_copyin(int cmd, void __user *param,\n\t\t\t\t struct floppy_raw_cmd **rcmd)\n{\n\tstruct floppy_raw_cmd *ptr;\n\tint ret;\n\tint i;\n\n\t*rcmd = NULL;\n\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\t*rcmd = ptr;\n\tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tptr->next = NULL;\n\tptr->buffer_length = 0;\n\tptr->kernel_data = NULL;\n\tif (ret)\n\t\treturn -EFAULT;\n\tparam += sizeof(struct floppy_raw_cmd);\n\tif (ptr->cmd_count > 33)\n\t\t\t/* the command may now also take up the space\n\t\t\t * initially intended for the reply & the\n\t\t\t * reply count. Needed for long 82078 commands\n\t\t\t * such as RESTORE, which takes ... 17 command\n\t\t\t * bytes. Murphy's law #137: When you reserve\n\t\t\t * 16 bytes for a structure, you'll one day\n\t\t\t * discover that you really need 17...\n\t\t\t */\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < 16; i++)\n\t\tptr->reply[i] = 0;\n\tptr->resultcode = 0;\n\n\tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}\n\tif (ptr->flags & FD_RAW_WRITE) {\n\t\tret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (ptr->flags & FD_RAW_MORE) {\n\t\trcmd = &(ptr->next);\n\t\tptr->rate &= 0x43;\n\t\tgoto loop;\n\t}\n\n\treturn 0;\n}\n\nstatic int raw_cmd_ioctl(int cmd, void __user *param)\n{\n\tstruct floppy_raw_cmd *my_raw_cmd;\n\tint drive;\n\tint ret2;\n\tint ret;\n\n\tif (FDCS->rawcmd <= 1)\n\t\tFDCS->rawcmd = 1;\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tif (FDC(drive) != fdc)\n\t\t\tcontinue;\n\t\tif (drive == current_drive) {\n\t\t\tif (UDRS->fd_ref > 1) {\n\t\t\t\tFDCS->rawcmd = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (UDRS->fd_ref) {\n\t\t\tFDCS->rawcmd = 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (FDCS->reset)\n\t\treturn -EIO;\n\n\tret = raw_cmd_copyin(cmd, param, &my_raw_cmd);\n\tif (ret) {\n\t\traw_cmd_free(&my_raw_cmd);\n\t\treturn ret;\n\t}\n\n\traw_cmd = my_raw_cmd;\n\tcont = &raw_cmd_cont;\n\tret = wait_til_done(floppy_start, true);\n\tdebug_dcl(DP->flags, \"calling disk change from raw_cmd ioctl\\n\");\n\n\tif (ret != -EINTR && FDCS->reset)\n\t\tret = -EIO;\n\n\tDRS->track = NO_TRACK;\n\n\tret2 = raw_cmd_copyout(cmd, param, my_raw_cmd);\n\tif (!ret)\n\t\tret = ret2;\n\traw_cmd_free(&my_raw_cmd);\n\treturn ret;\n}\n\nstatic int invalidate_drive(struct block_device *bdev)\n{\n\t/* invalidate the buffer track to force a reread */\n\tset_bit((long)bdev->bd_disk->private_data, &fake_change);\n\tprocess_fd_request();\n\tcheck_disk_change(bdev);\n\treturn 0;\n}\n\nstatic int set_geometry(unsigned int cmd, struct floppy_struct *g,\n\t\t\t       int drive, int type, struct block_device *bdev)\n{\n\tint cnt;\n\n\t/* sanity checking for parameters. */\n\tif (g->sect <= 0 ||\n\t    g->head <= 0 ||\n\t    /* check for zero in F_SECT_PER_TRACK */\n\t    (unsigned char)((g->sect << 2) >> FD_SIZECODE(g)) == 0 ||\n\t    g->track <= 0 || g->track > UDP->tracks >> STRETCH(g) ||\n\t    /* check if reserved bits are set */\n\t    (g->stretch & ~(FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK)) != 0)\n\t\treturn -EINVAL;\n\tif (type) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tmutex_lock(&open_lock);\n\t\tif (lock_fdc(drive)) {\n\t\t\tmutex_unlock(&open_lock);\n\t\t\treturn -EINTR;\n\t\t}\n\t\tfloppy_type[type] = *g;\n\t\tfloppy_type[type].name = \"user format\";\n\t\tfor (cnt = type << 2; cnt < (type << 2) + 4; cnt++)\n\t\t\tfloppy_sizes[cnt] = floppy_sizes[cnt + 0x80] =\n\t\t\t    floppy_type[type].size + 1;\n\t\tprocess_fd_request();\n\t\tfor (cnt = 0; cnt < N_DRIVE; cnt++) {\n\t\t\tstruct block_device *bdev = opened_bdev[cnt];\n\t\t\tif (!bdev || ITYPE(drive_state[cnt].fd_device) != type)\n\t\t\t\tcontinue;\n\t\t\t__invalidate_device(bdev, true);\n\t\t}\n\t\tmutex_unlock(&open_lock);\n\t} else {\n\t\tint oldStretch;\n\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (cmd != FDDEFPRM) {\n\t\t\t/* notice a disk change immediately, else\n\t\t\t * we lose our settings immediately*/\n\t\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\t\treturn -EINTR;\n\t\t}\n\t\toldStretch = g->stretch;\n\t\tuser_params[drive] = *g;\n\t\tif (buffer_drive == drive)\n\t\t\tSUPBOUND(buffer_max, user_params[drive].sect);\n\t\tcurrent_type[drive] = &user_params[drive];\n\t\tfloppy_sizes[drive] = user_params[drive].size;\n\t\tif (cmd == FDDEFPRM)\n\t\t\tDRS->keep_data = -1;\n\t\telse\n\t\t\tDRS->keep_data = 1;\n\t\t/* invalidation. Invalidate only when needed, i.e.\n\t\t * when there are already sectors in the buffer cache\n\t\t * whose number will change. This is useful, because\n\t\t * mtools often changes the geometry of the disk after\n\t\t * looking at the boot block */\n\t\tif (DRS->maxblock > user_params[drive].sect ||\n\t\t    DRS->maxtrack ||\n\t\t    ((user_params[drive].sect ^ oldStretch) &\n\t\t     (FD_SWAPSIDES | FD_SECTBASEMASK)))\n\t\t\tinvalidate_drive(bdev);\n\t\telse\n\t\t\tprocess_fd_request();\n\t}\n\treturn 0;\n}\n\n/* handle obsolete ioctl's */\nstatic unsigned int ioctl_table[] = {\n\tFDCLRPRM,\n\tFDSETPRM,\n\tFDDEFPRM,\n\tFDGETPRM,\n\tFDMSGON,\n\tFDMSGOFF,\n\tFDFMTBEG,\n\tFDFMTTRK,\n\tFDFMTEND,\n\tFDSETEMSGTRESH,\n\tFDFLUSH,\n\tFDSETMAXERRS,\n\tFDGETMAXERRS,\n\tFDGETDRVTYP,\n\tFDSETDRVPRM,\n\tFDGETDRVPRM,\n\tFDGETDRVSTAT,\n\tFDPOLLDRVSTAT,\n\tFDRESET,\n\tFDGETFDCSTAT,\n\tFDWERRORCLR,\n\tFDWERRORGET,\n\tFDRAWCMD,\n\tFDEJECT,\n\tFDTWADDLE\n};\n\nstatic int normalize_ioctl(unsigned int *cmd, int *size)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ioctl_table); i++) {\n\t\tif ((*cmd & 0xffff) == (ioctl_table[i] & 0xffff)) {\n\t\t\t*size = _IOC_SIZE(*cmd);\n\t\t\t*cmd = ioctl_table[i];\n\t\t\tif (*size > _IOC_SIZE(*cmd)) {\n\t\t\t\tpr_info(\"ioctl not yet supported\\n\");\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int get_floppy_geometry(int drive, int type, struct floppy_struct **g)\n{\n\tif (type)\n\t\t*g = &floppy_type[type];\n\telse {\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (poll_drive(false, 0) == -EINTR)\n\t\t\treturn -EINTR;\n\t\tprocess_fd_request();\n\t\t*g = current_type[drive];\n\t}\n\tif (!*g)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic int fd_getgeo(struct block_device *bdev, struct hd_geometry *geo)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tint type = ITYPE(drive_state[drive].fd_device);\n\tstruct floppy_struct *g;\n\tint ret;\n\n\tret = get_floppy_geometry(drive, type, &g);\n\tif (ret)\n\t\treturn ret;\n\n\tgeo->heads = g->head;\n\tgeo->sectors = g->sect;\n\tgeo->cylinders = g->track;\n\treturn 0;\n}\n\nstatic int fd_locked_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd,\n\t\t    unsigned long param)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tint type = ITYPE(UDRS->fd_device);\n\tint i;\n\tint ret;\n\tint size;\n\tunion inparam {\n\t\tstruct floppy_struct g;\t/* geometry */\n\t\tstruct format_descr f;\n\t\tstruct floppy_max_errors max_errors;\n\t\tstruct floppy_drive_params dp;\n\t} inparam;\t\t/* parameters coming from user space */\n\tconst void *outparam;\t/* parameters passed back to user space */\n\n\t/* convert compatibility eject ioctls into floppy eject ioctl.\n\t * We do this in order to provide a means to eject floppy disks before\n\t * installing the new fdutils package */\n\tif (cmd == CDROMEJECT ||\t/* CD-ROM eject */\n\t    cmd == 0x6470) {\t\t/* SunOS floppy eject */\n\t\tDPRINT(\"obsolete eject ioctl\\n\");\n\t\tDPRINT(\"please use floppycontrol --eject\\n\");\n\t\tcmd = FDEJECT;\n\t}\n\n\tif (!((cmd & 0xff00) == 0x0200))\n\t\treturn -EINVAL;\n\n\t/* convert the old style command into a new style command */\n\tret = normalize_ioctl(&cmd, &size);\n\tif (ret)\n\t\treturn ret;\n\n\t/* permission checks */\n\tif (((cmd & 0x40) && !(mode & (FMODE_WRITE | FMODE_WRITE_IOCTL))) ||\n\t    ((cmd & 0x80) && !capable(CAP_SYS_ADMIN)))\n\t\treturn -EPERM;\n\n\tif (WARN_ON(size < 0 || size > sizeof(inparam)))\n\t\treturn -EINVAL;\n\n\t/* copyin */\n\tmemset(&inparam, 0, sizeof(inparam));\n\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\tret = fd_copyin((void __user *)param, &inparam, size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tswitch (cmd) {\n\tcase FDEJECT:\n\t\tif (UDRS->fd_ref != 1)\n\t\t\t/* somebody else has this drive open */\n\t\t\treturn -EBUSY;\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\n\t\t/* do the actual eject. Fails on\n\t\t * non-Sparc architectures */\n\t\tret = fd_eject(UNIT(drive));\n\n\t\tset_bit(FD_DISK_CHANGED_BIT, &UDRS->flags);\n\t\tset_bit(FD_VERIFY_BIT, &UDRS->flags);\n\t\tprocess_fd_request();\n\t\treturn ret;\n\tcase FDCLRPRM:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tcurrent_type[drive] = NULL;\n\t\tfloppy_sizes[drive] = MAX_DISK_SIZE << 1;\n\t\tUDRS->keep_data = 0;\n\t\treturn invalidate_drive(bdev);\n\tcase FDSETPRM:\n\tcase FDDEFPRM:\n\t\treturn set_geometry(cmd, &inparam.g, drive, type, bdev);\n\tcase FDGETPRM:\n\t\tret = get_floppy_geometry(drive, type,\n\t\t\t\t\t  (struct floppy_struct **)&outparam);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmemcpy(&inparam.g, outparam,\n\t\t\t\toffsetof(struct floppy_struct, name));\n\t\toutparam = &inparam.g;\n\t\tbreak;\n\tcase FDMSGON:\n\t\tUDP->flags |= FTD_MSG;\n\t\treturn 0;\n\tcase FDMSGOFF:\n\t\tUDP->flags &= ~FTD_MSG;\n\t\treturn 0;\n\tcase FDFMTBEG:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\treturn -EINTR;\n\t\tret = UDRS->flags;\n\t\tprocess_fd_request();\n\t\tif (ret & FD_VERIFY)\n\t\t\treturn -ENODEV;\n\t\tif (!(ret & FD_DISK_WRITABLE))\n\t\t\treturn -EROFS;\n\t\treturn 0;\n\tcase FDFMTTRK:\n\t\tif (UDRS->fd_ref != 1)\n\t\t\treturn -EBUSY;\n\t\treturn do_format(drive, &inparam.f);\n\tcase FDFMTEND:\n\tcase FDFLUSH:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\treturn invalidate_drive(bdev);\n\tcase FDSETEMSGTRESH:\n\t\tUDP->max_errors.reporting = (unsigned short)(param & 0x0f);\n\t\treturn 0;\n\tcase FDGETMAXERRS:\n\t\toutparam = &UDP->max_errors;\n\t\tbreak;\n\tcase FDSETMAXERRS:\n\t\tUDP->max_errors = inparam.max_errors;\n\t\tbreak;\n\tcase FDGETDRVTYP:\n\t\toutparam = drive_name(type, drive);\n\t\tSUPBOUND(size, strlen((const char *)outparam) + 1);\n\t\tbreak;\n\tcase FDSETDRVPRM:\n\t\t*UDP = inparam.dp;\n\t\tbreak;\n\tcase FDGETDRVPRM:\n\t\toutparam = UDP;\n\t\tbreak;\n\tcase FDPOLLDRVSTAT:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\treturn -EINTR;\n\t\tprocess_fd_request();\n\t\t/* fall through */\n\tcase FDGETDRVSTAT:\n\t\toutparam = UDRS;\n\t\tbreak;\n\tcase FDRESET:\n\t\treturn user_reset_fdc(drive, (int)param, true);\n\tcase FDGETFDCSTAT:\n\t\toutparam = UFDCS;\n\t\tbreak;\n\tcase FDWERRORCLR:\n\t\tmemset(UDRWE, 0, sizeof(*UDRWE));\n\t\treturn 0;\n\tcase FDWERRORGET:\n\t\toutparam = UDRWE;\n\t\tbreak;\n\tcase FDRAWCMD:\n\t\tif (type)\n\t\t\treturn -EINVAL;\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tset_floppy(drive);\n\t\ti = raw_cmd_ioctl(cmd, (void __user *)param);\n\t\tif (i == -EINTR)\n\t\t\treturn -EINTR;\n\t\tprocess_fd_request();\n\t\treturn i;\n\tcase FDTWADDLE:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\ttwaddle();\n\t\tprocess_fd_request();\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (_IOC_DIR(cmd) & _IOC_READ)\n\t\treturn fd_copyout((void __user *)param, outparam, size);\n\n\treturn 0;\n}\n\nstatic int fd_ioctl(struct block_device *bdev, fmode_t mode,\n\t\t\t     unsigned int cmd, unsigned long param)\n{\n\tint ret;\n\n\tmutex_lock(&floppy_mutex);\n\tret = fd_locked_ioctl(bdev, mode, cmd, param);\n\tmutex_unlock(&floppy_mutex);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\n\nstruct compat_floppy_drive_params {\n\tchar\t\tcmos;\n\tcompat_ulong_t\tmax_dtr;\n\tcompat_ulong_t\thlt;\n\tcompat_ulong_t\thut;\n\tcompat_ulong_t\tsrt;\n\tcompat_ulong_t\tspinup;\n\tcompat_ulong_t\tspindown;\n\tunsigned char\tspindown_offset;\n\tunsigned char\tselect_delay;\n\tunsigned char\trps;\n\tunsigned char\ttracks;\n\tcompat_ulong_t\ttimeout;\n\tunsigned char\tinterleave_sect;\n\tstruct floppy_max_errors max_errors;\n\tchar\t\tflags;\n\tchar\t\tread_track;\n\tshort\t\tautodetect[8];\n\tcompat_int_t\tcheckfreq;\n\tcompat_int_t\tnative_format;\n};\n\nstruct compat_floppy_drive_struct {\n\tsigned char\tflags;\n\tcompat_ulong_t\tspinup_date;\n\tcompat_ulong_t\tselect_date;\n\tcompat_ulong_t\tfirst_read_date;\n\tshort\t\tprobed_format;\n\tshort\t\ttrack;\n\tshort\t\tmaxblock;\n\tshort\t\tmaxtrack;\n\tcompat_int_t\tgeneration;\n\tcompat_int_t\tkeep_data;\n\tcompat_int_t\tfd_ref;\n\tcompat_int_t\tfd_device;\n\tcompat_int_t\tlast_checked;\n\tcompat_caddr_t dmabuf;\n\tcompat_int_t\tbufblocks;\n};\n\nstruct compat_floppy_fdc_state {\n\tcompat_int_t\tspec1;\n\tcompat_int_t\tspec2;\n\tcompat_int_t\tdtr;\n\tunsigned char\tversion;\n\tunsigned char\tdor;\n\tcompat_ulong_t\taddress;\n\tunsigned int\trawcmd:2;\n\tunsigned int\treset:1;\n\tunsigned int\tneed_configure:1;\n\tunsigned int\tperp_mode:2;\n\tunsigned int\thas_fifo:1;\n\tunsigned int\tdriver_version;\n\tunsigned char\ttrack[4];\n};\n\nstruct compat_floppy_write_errors {\n\tunsigned int\twrite_errors;\n\tcompat_ulong_t\tfirst_error_sector;\n\tcompat_int_t\tfirst_error_generation;\n\tcompat_ulong_t\tlast_error_sector;\n\tcompat_int_t\tlast_error_generation;\n\tcompat_uint_t\tbadness;\n};\n\n#define FDSETPRM32 _IOW(2, 0x42, struct compat_floppy_struct)\n#define FDDEFPRM32 _IOW(2, 0x43, struct compat_floppy_struct)\n#define FDSETDRVPRM32 _IOW(2, 0x90, struct compat_floppy_drive_params)\n#define FDGETDRVPRM32 _IOR(2, 0x11, struct compat_floppy_drive_params)\n#define FDGETDRVSTAT32 _IOR(2, 0x12, struct compat_floppy_drive_struct)\n#define FDPOLLDRVSTAT32 _IOR(2, 0x13, struct compat_floppy_drive_struct)\n#define FDGETFDCSTAT32 _IOR(2, 0x15, struct compat_floppy_fdc_state)\n#define FDWERRORGET32  _IOR(2, 0x17, struct compat_floppy_write_errors)\n\nstatic int compat_set_geometry(struct block_device *bdev, fmode_t mode, unsigned int cmd,\n\t\t    struct compat_floppy_struct __user *arg)\n{\n\tstruct floppy_struct v;\n\tint drive, type;\n\tint err;\n\n\tBUILD_BUG_ON(offsetof(struct floppy_struct, name) !=\n\t\t     offsetof(struct compat_floppy_struct, name));\n\n\tif (!(mode & (FMODE_WRITE | FMODE_WRITE_IOCTL)))\n\t\treturn -EPERM;\n\n\tmemset(&v, 0, sizeof(struct floppy_struct));\n\tif (copy_from_user(&v, arg, offsetof(struct floppy_struct, name)))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&floppy_mutex);\n\tdrive = (long)bdev->bd_disk->private_data;\n\ttype = ITYPE(UDRS->fd_device);\n\terr = set_geometry(cmd == FDSETPRM32 ? FDSETPRM : FDDEFPRM,\n\t\t\t&v, drive, type, bdev);\n\tmutex_unlock(&floppy_mutex);\n\treturn err;\n}\n\nstatic int compat_get_prm(int drive,\n\t\t\t  struct compat_floppy_struct __user *arg)\n{\n\tstruct compat_floppy_struct v;\n\tstruct floppy_struct *p;\n\tint err;\n\n\tmemset(&v, 0, sizeof(v));\n\tmutex_lock(&floppy_mutex);\n\terr = get_floppy_geometry(drive, ITYPE(UDRS->fd_device), &p);\n\tif (err) {\n\t\tmutex_unlock(&floppy_mutex);\n\t\treturn err;\n\t}\n\tmemcpy(&v, p, offsetof(struct floppy_struct, name));\n\tmutex_unlock(&floppy_mutex);\n\tif (copy_to_user(arg, &v, sizeof(struct compat_floppy_struct)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int compat_setdrvprm(int drive,\n\t\t\t    struct compat_floppy_drive_params __user *arg)\n{\n\tstruct compat_floppy_drive_params v;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&v, arg, sizeof(struct compat_floppy_drive_params)))\n\t\treturn -EFAULT;\n\tmutex_lock(&floppy_mutex);\n\tUDP->cmos = v.cmos;\n\tUDP->max_dtr = v.max_dtr;\n\tUDP->hlt = v.hlt;\n\tUDP->hut = v.hut;\n\tUDP->srt = v.srt;\n\tUDP->spinup = v.spinup;\n\tUDP->spindown = v.spindown;\n\tUDP->spindown_offset = v.spindown_offset;\n\tUDP->select_delay = v.select_delay;\n\tUDP->rps = v.rps;\n\tUDP->tracks = v.tracks;\n\tUDP->timeout = v.timeout;\n\tUDP->interleave_sect = v.interleave_sect;\n\tUDP->max_errors = v.max_errors;\n\tUDP->flags = v.flags;\n\tUDP->read_track = v.read_track;\n\tmemcpy(UDP->autodetect, v.autodetect, sizeof(v.autodetect));\n\tUDP->checkfreq = v.checkfreq;\n\tUDP->native_format = v.native_format;\n\tmutex_unlock(&floppy_mutex);\n\treturn 0;\n}\n\nstatic int compat_getdrvprm(int drive,\n\t\t\t    struct compat_floppy_drive_params __user *arg)\n{\n\tstruct compat_floppy_drive_params v;\n\n\tmemset(&v, 0, sizeof(struct compat_floppy_drive_params));\n\tmutex_lock(&floppy_mutex);\n\tv.cmos = UDP->cmos;\n\tv.max_dtr = UDP->max_dtr;\n\tv.hlt = UDP->hlt;\n\tv.hut = UDP->hut;\n\tv.srt = UDP->srt;\n\tv.spinup = UDP->spinup;\n\tv.spindown = UDP->spindown;\n\tv.spindown_offset = UDP->spindown_offset;\n\tv.select_delay = UDP->select_delay;\n\tv.rps = UDP->rps;\n\tv.tracks = UDP->tracks;\n\tv.timeout = UDP->timeout;\n\tv.interleave_sect = UDP->interleave_sect;\n\tv.max_errors = UDP->max_errors;\n\tv.flags = UDP->flags;\n\tv.read_track = UDP->read_track;\n\tmemcpy(v.autodetect, UDP->autodetect, sizeof(v.autodetect));\n\tv.checkfreq = UDP->checkfreq;\n\tv.native_format = UDP->native_format;\n\tmutex_unlock(&floppy_mutex);\n\n\tif (copy_from_user(arg, &v, sizeof(struct compat_floppy_drive_params)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int compat_getdrvstat(int drive, bool poll,\n\t\t\t    struct compat_floppy_drive_struct __user *arg)\n{\n\tstruct compat_floppy_drive_struct v;\n\n\tmemset(&v, 0, sizeof(struct compat_floppy_drive_struct));\n\tmutex_lock(&floppy_mutex);\n\n\tif (poll) {\n\t\tif (lock_fdc(drive))\n\t\t\tgoto Eintr;\n\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\tgoto Eintr;\n\t\tprocess_fd_request();\n\t}\n\tv.spinup_date = UDRS->spinup_date;\n\tv.select_date = UDRS->select_date;\n\tv.first_read_date = UDRS->first_read_date;\n\tv.probed_format = UDRS->probed_format;\n\tv.track = UDRS->track;\n\tv.maxblock = UDRS->maxblock;\n\tv.maxtrack = UDRS->maxtrack;\n\tv.generation = UDRS->generation;\n\tv.keep_data = UDRS->keep_data;\n\tv.fd_ref = UDRS->fd_ref;\n\tv.fd_device = UDRS->fd_device;\n\tv.last_checked = UDRS->last_checked;\n\tv.dmabuf = (uintptr_t)UDRS->dmabuf;\n\tv.bufblocks = UDRS->bufblocks;\n\tmutex_unlock(&floppy_mutex);\n\n\tif (copy_from_user(arg, &v, sizeof(struct compat_floppy_drive_struct)))\n\t\treturn -EFAULT;\n\treturn 0;\nEintr:\n\tmutex_unlock(&floppy_mutex);\n\treturn -EINTR;\n}\n\nstatic int compat_getfdcstat(int drive,\n\t\t\t    struct compat_floppy_fdc_state __user *arg)\n{\n\tstruct compat_floppy_fdc_state v32;\n\tstruct floppy_fdc_state v;\n\n\tmutex_lock(&floppy_mutex);\n\tv = *UFDCS;\n\tmutex_unlock(&floppy_mutex);\n\n\tmemset(&v32, 0, sizeof(struct compat_floppy_fdc_state));\n\tv32.spec1 = v.spec1;\n\tv32.spec2 = v.spec2;\n\tv32.dtr = v.dtr;\n\tv32.version = v.version;\n\tv32.dor = v.dor;\n\tv32.address = v.address;\n\tv32.rawcmd = v.rawcmd;\n\tv32.reset = v.reset;\n\tv32.need_configure = v.need_configure;\n\tv32.perp_mode = v.perp_mode;\n\tv32.has_fifo = v.has_fifo;\n\tv32.driver_version = v.driver_version;\n\tmemcpy(v32.track, v.track, 4);\n\tif (copy_to_user(arg, &v32, sizeof(struct compat_floppy_fdc_state)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int compat_werrorget(int drive,\n\t\t\t    struct compat_floppy_write_errors __user *arg)\n{\n\tstruct compat_floppy_write_errors v32;\n\tstruct floppy_write_errors v;\n\n\tmemset(&v32, 0, sizeof(struct compat_floppy_write_errors));\n\tmutex_lock(&floppy_mutex);\n\tv = *UDRWE;\n\tmutex_unlock(&floppy_mutex);\n\tv32.write_errors = v.write_errors;\n\tv32.first_error_sector = v.first_error_sector;\n\tv32.first_error_generation = v.first_error_generation;\n\tv32.last_error_sector = v.last_error_sector;\n\tv32.last_error_generation = v.last_error_generation;\n\tv32.badness = v.badness;\n\tif (copy_to_user(arg, &v32, sizeof(struct compat_floppy_write_errors)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int fd_compat_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd,\n\t\t    unsigned long param)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tswitch (cmd) {\n\tcase FDMSGON:\n\tcase FDMSGOFF:\n\tcase FDSETEMSGTRESH:\n\tcase FDFLUSH:\n\tcase FDWERRORCLR:\n\tcase FDEJECT:\n\tcase FDCLRPRM:\n\tcase FDFMTBEG:\n\tcase FDRESET:\n\tcase FDTWADDLE:\n\t\treturn fd_ioctl(bdev, mode, cmd, param);\n\tcase FDSETMAXERRS:\n\tcase FDGETMAXERRS:\n\tcase FDGETDRVTYP:\n\tcase FDFMTEND:\n\tcase FDFMTTRK:\n\tcase FDRAWCMD:\n\t\treturn fd_ioctl(bdev, mode, cmd,\n\t\t\t\t(unsigned long)compat_ptr(param));\n\tcase FDSETPRM32:\n\tcase FDDEFPRM32:\n\t\treturn compat_set_geometry(bdev, mode, cmd, compat_ptr(param));\n\tcase FDGETPRM32:\n\t\treturn compat_get_prm(drive, compat_ptr(param));\n\tcase FDSETDRVPRM32:\n\t\treturn compat_setdrvprm(drive, compat_ptr(param));\n\tcase FDGETDRVPRM32:\n\t\treturn compat_getdrvprm(drive, compat_ptr(param));\n\tcase FDPOLLDRVSTAT32:\n\t\treturn compat_getdrvstat(drive, true, compat_ptr(param));\n\tcase FDGETDRVSTAT32:\n\t\treturn compat_getdrvstat(drive, false, compat_ptr(param));\n\tcase FDGETFDCSTAT32:\n\t\treturn compat_getfdcstat(drive, compat_ptr(param));\n\tcase FDWERRORGET32:\n\t\treturn compat_werrorget(drive, compat_ptr(param));\n\t}\n\treturn -EINVAL;\n}\n#endif\n\nstatic void __init config_types(void)\n{\n\tbool has_drive = false;\n\tint drive;\n\n\t/* read drive info out of physical CMOS */\n\tdrive = 0;\n\tif (!UDP->cmos)\n\t\tUDP->cmos = FLOPPY0_TYPE;\n\tdrive = 1;\n\tif (!UDP->cmos && FLOPPY1_TYPE)\n\t\tUDP->cmos = FLOPPY1_TYPE;\n\n\t/* FIXME: additional physical CMOS drive detection should go here */\n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tunsigned int type = UDP->cmos;\n\t\tstruct floppy_drive_params *params;\n\t\tconst char *name = NULL;\n\t\tchar temparea[32];\n\n\t\tif (type < ARRAY_SIZE(default_drive_params)) {\n\t\t\tparams = &default_drive_params[type].params;\n\t\t\tif (type) {\n\t\t\t\tname = default_drive_params[type].name;\n\t\t\t\tallowed_drive_mask |= 1 << drive;\n\t\t\t} else\n\t\t\t\tallowed_drive_mask &= ~(1 << drive);\n\t\t} else {\n\t\t\tparams = &default_drive_params[0].params;\n\t\t\tsnprintf(temparea, sizeof(temparea),\n\t\t\t\t \"unknown type %d (usb?)\", type);\n\t\t\tname = temparea;\n\t\t}\n\t\tif (name) {\n\t\t\tconst char *prepend;\n\t\t\tif (!has_drive) {\n\t\t\t\tprepend = \"\";\n\t\t\t\thas_drive = true;\n\t\t\t\tpr_info(\"Floppy drive(s):\");\n\t\t\t} else {\n\t\t\t\tprepend = \",\";\n\t\t\t}\n\n\t\t\tpr_cont(\"%s fd%d is %s\", prepend, drive, name);\n\t\t}\n\t\t*UDP = *params;\n\t}\n\n\tif (has_drive)\n\t\tpr_cont(\"\\n\");\n}\n\nstatic void floppy_release(struct gendisk *disk, fmode_t mode)\n{\n\tint drive = (long)disk->private_data;\n\n\tmutex_lock(&floppy_mutex);\n\tmutex_lock(&open_lock);\n\tif (!UDRS->fd_ref--) {\n\t\tDPRINT(\"floppy_release with fd_ref == 0\");\n\t\tUDRS->fd_ref = 0;\n\t}\n\tif (!UDRS->fd_ref)\n\t\topened_bdev[drive] = NULL;\n\tmutex_unlock(&open_lock);\n\tmutex_unlock(&floppy_mutex);\n}\n\n/*\n * floppy_open check for aliasing (/dev/fd0 can be the same as\n * /dev/PS0 etc), and disallows simultaneous access to the same\n * drive with different device numbers.\n */\nstatic int floppy_open(struct block_device *bdev, fmode_t mode)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tint old_dev, new_dev;\n\tint try;\n\tint res = -EBUSY;\n\tchar *tmp;\n\n\tmutex_lock(&floppy_mutex);\n\tmutex_lock(&open_lock);\n\told_dev = UDRS->fd_device;\n\tif (opened_bdev[drive] && opened_bdev[drive] != bdev)\n\t\tgoto out2;\n\n\tif (!UDRS->fd_ref && (UDP->flags & FD_BROKEN_DCL)) {\n\t\tset_bit(FD_DISK_CHANGED_BIT, &UDRS->flags);\n\t\tset_bit(FD_VERIFY_BIT, &UDRS->flags);\n\t}\n\n\tUDRS->fd_ref++;\n\n\topened_bdev[drive] = bdev;\n\n\tres = -ENXIO;\n\n\tif (!floppy_track_buffer) {\n\t\t/* if opening an ED drive, reserve a big buffer,\n\t\t * else reserve a small one */\n\t\tif ((UDP->cmos == 6) || (UDP->cmos == 5))\n\t\t\ttry = 64;\t/* Only 48 actually useful */\n\t\telse\n\t\t\ttry = 32;\t/* Only 24 actually useful */\n\n\t\ttmp = (char *)fd_dma_mem_alloc(1024 * try);\n\t\tif (!tmp && !floppy_track_buffer) {\n\t\t\ttry >>= 1;\t/* buffer only one side */\n\t\t\tINFBOUND(try, 16);\n\t\t\ttmp = (char *)fd_dma_mem_alloc(1024 * try);\n\t\t}\n\t\tif (!tmp && !floppy_track_buffer)\n\t\t\tfallback_on_nodma_alloc(&tmp, 2048 * try);\n\t\tif (!tmp && !floppy_track_buffer) {\n\t\t\tDPRINT(\"Unable to allocate DMA memory\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (floppy_track_buffer) {\n\t\t\tif (tmp)\n\t\t\t\tfd_dma_mem_free((unsigned long)tmp, try * 1024);\n\t\t} else {\n\t\t\tbuffer_min = buffer_max = -1;\n\t\t\tfloppy_track_buffer = tmp;\n\t\t\tmax_buffer_sectors = try;\n\t\t}\n\t}\n\n\tnew_dev = MINOR(bdev->bd_dev);\n\tUDRS->fd_device = new_dev;\n\tset_capacity(disks[drive], floppy_sizes[new_dev]);\n\tif (old_dev != -1 && old_dev != new_dev) {\n\t\tif (buffer_drive == drive)\n\t\t\tbuffer_track = -1;\n\t}\n\n\tif (UFDCS->rawcmd == 1)\n\t\tUFDCS->rawcmd = 2;\n\n\tif (!(mode & FMODE_NDELAY)) {\n\t\tif (mode & (FMODE_READ|FMODE_WRITE)) {\n\t\t\tUDRS->last_checked = 0;\n\t\t\tclear_bit(FD_OPEN_SHOULD_FAIL_BIT, &UDRS->flags);\n\t\t\tcheck_disk_change(bdev);\n\t\t\tif (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags))\n\t\t\t\tgoto out;\n\t\t\tif (test_bit(FD_OPEN_SHOULD_FAIL_BIT, &UDRS->flags))\n\t\t\t\tgoto out;\n\t\t}\n\t\tres = -EROFS;\n\t\tif ((mode & FMODE_WRITE) &&\n\t\t    !test_bit(FD_DISK_WRITABLE_BIT, &UDRS->flags))\n\t\t\tgoto out;\n\t}\n\tmutex_unlock(&open_lock);\n\tmutex_unlock(&floppy_mutex);\n\treturn 0;\nout:\n\tUDRS->fd_ref--;\n\n\tif (!UDRS->fd_ref)\n\t\topened_bdev[drive] = NULL;\nout2:\n\tmutex_unlock(&open_lock);\n\tmutex_unlock(&floppy_mutex);\n\treturn res;\n}\n\n/*\n * Check if the disk has been changed or if a change has been faked.\n */\nstatic unsigned int floppy_check_events(struct gendisk *disk,\n\t\t\t\t\tunsigned int clearing)\n{\n\tint drive = (long)disk->private_data;\n\n\tif (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\n\t    test_bit(FD_VERIFY_BIT, &UDRS->flags))\n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\n\tif (time_after(jiffies, UDRS->last_checked + UDP->checkfreq)) {\n\t\tif (lock_fdc(drive))\n\t\t\treturn 0;\n\t\tpoll_drive(false, 0);\n\t\tprocess_fd_request();\n\t}\n\n\tif (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\n\t    test_bit(FD_VERIFY_BIT, &UDRS->flags) ||\n\t    test_bit(drive, &fake_change) ||\n\t    drive_no_geom(drive))\n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\treturn 0;\n}\n\n/*\n * This implements \"read block 0\" for floppy_revalidate().\n * Needed for format autodetection, checking whether there is\n * a disk in the drive, and whether that disk is writable.\n */\n\nstruct rb0_cbdata {\n\tint drive;\n\tstruct completion complete;\n};\n\nstatic void floppy_rb0_cb(struct bio *bio)\n{\n\tstruct rb0_cbdata *cbdata = (struct rb0_cbdata *)bio->bi_private;\n\tint drive = cbdata->drive;\n\n\tif (bio->bi_status) {\n\t\tpr_info(\"floppy: error %d while reading block 0\\n\",\n\t\t\tbio->bi_status);\n\t\tset_bit(FD_OPEN_SHOULD_FAIL_BIT, &UDRS->flags);\n\t}\n\tcomplete(&cbdata->complete);\n}\n\nstatic int __floppy_read_block_0(struct block_device *bdev, int drive)\n{\n\tstruct bio bio;\n\tstruct bio_vec bio_vec;\n\tstruct page *page;\n\tstruct rb0_cbdata cbdata;\n\tsize_t size;\n\n\tpage = alloc_page(GFP_NOIO);\n\tif (!page) {\n\t\tprocess_fd_request();\n\t\treturn -ENOMEM;\n\t}\n\n\tsize = bdev->bd_block_size;\n\tif (!size)\n\t\tsize = 1024;\n\n\tcbdata.drive = drive;\n\n\tbio_init(&bio, &bio_vec, 1);\n\tbio_set_dev(&bio, bdev);\n\tbio_add_page(&bio, page, size, 0);\n\n\tbio.bi_iter.bi_sector = 0;\n\tbio.bi_flags |= (1 << BIO_QUIET);\n\tbio.bi_private = &cbdata;\n\tbio.bi_end_io = floppy_rb0_cb;\n\tbio_set_op_attrs(&bio, REQ_OP_READ, 0);\n\n\tinit_completion(&cbdata.complete);\n\n\tsubmit_bio(&bio);\n\tprocess_fd_request();\n\n\twait_for_completion(&cbdata.complete);\n\n\t__free_page(page);\n\n\treturn 0;\n}\n\n/* revalidate the floppy disk, i.e. trigger format autodetection by reading\n * the bootblock (block 0). \"Autodetection\" is also needed to check whether\n * there is a disk in the drive at all... Thus we also do it for fixed\n * geometry formats */\nstatic int floppy_revalidate(struct gendisk *disk)\n{\n\tint drive = (long)disk->private_data;\n\tint cf;\n\tint res = 0;\n\n\tif (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\n\t    test_bit(FD_VERIFY_BIT, &UDRS->flags) ||\n\t    test_bit(drive, &fake_change) ||\n\t    drive_no_geom(drive)) {\n\t\tif (WARN(atomic_read(&usage_count) == 0,\n\t\t\t \"VFS: revalidate called on non-open device.\\n\"))\n\t\t\treturn -EFAULT;\n\n\t\tres = lock_fdc(drive);\n\t\tif (res)\n\t\t\treturn res;\n\t\tcf = (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\n\t\t      test_bit(FD_VERIFY_BIT, &UDRS->flags));\n\t\tif (!(cf || test_bit(drive, &fake_change) || drive_no_geom(drive))) {\n\t\t\tprocess_fd_request();\t/*already done by another thread */\n\t\t\treturn 0;\n\t\t}\n\t\tUDRS->maxblock = 0;\n\t\tUDRS->maxtrack = 0;\n\t\tif (buffer_drive == drive)\n\t\t\tbuffer_track = -1;\n\t\tclear_bit(drive, &fake_change);\n\t\tclear_bit(FD_DISK_CHANGED_BIT, &UDRS->flags);\n\t\tif (cf)\n\t\t\tUDRS->generation++;\n\t\tif (drive_no_geom(drive)) {\n\t\t\t/* auto-sensing */\n\t\t\tres = __floppy_read_block_0(opened_bdev[drive], drive);\n\t\t} else {\n\t\t\tif (cf)\n\t\t\t\tpoll_drive(false, FD_RAW_NEED_DISK);\n\t\t\tprocess_fd_request();\n\t\t}\n\t}\n\tset_capacity(disk, floppy_sizes[UDRS->fd_device]);\n\treturn res;\n}\n\nstatic const struct block_device_operations floppy_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.open\t\t\t= floppy_open,\n\t.release\t\t= floppy_release,\n\t.ioctl\t\t\t= fd_ioctl,\n\t.getgeo\t\t\t= fd_getgeo,\n\t.check_events\t\t= floppy_check_events,\n\t.revalidate_disk\t= floppy_revalidate,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t\t= fd_compat_ioctl,\n#endif\n};\n\n/*\n * Floppy Driver initialization\n * =============================\n */\n\n/* Determine the floppy disk controller type */\n/* This routine was written by David C. Niemi */\nstatic char __init get_fdc_version(void)\n{\n\tint r;\n\n\toutput_byte(FD_DUMPREGS);\t/* 82072 and better know DUMPREGS */\n\tif (FDCS->reset)\n\t\treturn FDC_NONE;\n\tr = result();\n\tif (r <= 0x00)\n\t\treturn FDC_NONE;\t/* No FDC present ??? */\n\tif ((r == 1) && (reply_buffer[0] == 0x80)) {\n\t\tpr_info(\"FDC %d is an 8272A\\n\", fdc);\n\t\treturn FDC_8272A;\t/* 8272a/765 don't know DUMPREGS */\n\t}\n\tif (r != 10) {\n\t\tpr_info(\"FDC %d init: DUMPREGS: unexpected return of %d bytes.\\n\",\n\t\t\tfdc, r);\n\t\treturn FDC_UNKNOWN;\n\t}\n\n\tif (!fdc_configure()) {\n\t\tpr_info(\"FDC %d is an 82072\\n\", fdc);\n\t\treturn FDC_82072;\t/* 82072 doesn't know CONFIGURE */\n\t}\n\n\toutput_byte(FD_PERPENDICULAR);\n\tif (need_more_output() == MORE_OUTPUT) {\n\t\toutput_byte(0);\n\t} else {\n\t\tpr_info(\"FDC %d is an 82072A\\n\", fdc);\n\t\treturn FDC_82072A;\t/* 82072A as found on Sparcs. */\n\t}\n\n\toutput_byte(FD_UNLOCK);\n\tr = result();\n\tif ((r == 1) && (reply_buffer[0] == 0x80)) {\n\t\tpr_info(\"FDC %d is a pre-1991 82077\\n\", fdc);\n\t\treturn FDC_82077_ORIG;\t/* Pre-1991 82077, doesn't know\n\t\t\t\t\t * LOCK/UNLOCK */\n\t}\n\tif ((r != 1) || (reply_buffer[0] != 0x00)) {\n\t\tpr_info(\"FDC %d init: UNLOCK: unexpected return of %d bytes.\\n\",\n\t\t\tfdc, r);\n\t\treturn FDC_UNKNOWN;\n\t}\n\toutput_byte(FD_PARTID);\n\tr = result();\n\tif (r != 1) {\n\t\tpr_info(\"FDC %d init: PARTID: unexpected return of %d bytes.\\n\",\n\t\t\tfdc, r);\n\t\treturn FDC_UNKNOWN;\n\t}\n\tif (reply_buffer[0] == 0x80) {\n\t\tpr_info(\"FDC %d is a post-1991 82077\\n\", fdc);\n\t\treturn FDC_82077;\t/* Revised 82077AA passes all the tests */\n\t}\n\tswitch (reply_buffer[0] >> 5) {\n\tcase 0x0:\n\t\t/* Either a 82078-1 or a 82078SL running at 5Volt */\n\t\tpr_info(\"FDC %d is an 82078.\\n\", fdc);\n\t\treturn FDC_82078;\n\tcase 0x1:\n\t\tpr_info(\"FDC %d is a 44pin 82078\\n\", fdc);\n\t\treturn FDC_82078;\n\tcase 0x2:\n\t\tpr_info(\"FDC %d is a S82078B\\n\", fdc);\n\t\treturn FDC_S82078B;\n\tcase 0x3:\n\t\tpr_info(\"FDC %d is a National Semiconductor PC87306\\n\", fdc);\n\t\treturn FDC_87306;\n\tdefault:\n\t\tpr_info(\"FDC %d init: 82078 variant with unknown PARTID=%d.\\n\",\n\t\t\tfdc, reply_buffer[0] >> 5);\n\t\treturn FDC_82078_UNKN;\n\t}\n}\t\t\t\t/* get_fdc_version */\n\n/* lilo configuration */\n\nstatic void __init floppy_set_flags(int *ints, int param, int param2)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(default_drive_params); i++) {\n\t\tif (param)\n\t\t\tdefault_drive_params[i].params.flags |= param2;\n\t\telse\n\t\t\tdefault_drive_params[i].params.flags &= ~param2;\n\t}\n\tDPRINT(\"%s flag 0x%x\\n\", param2 ? \"Setting\" : \"Clearing\", param);\n}\n\nstatic void __init daring(int *ints, int param, int param2)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(default_drive_params); i++) {\n\t\tif (param) {\n\t\t\tdefault_drive_params[i].params.select_delay = 0;\n\t\t\tdefault_drive_params[i].params.flags |=\n\t\t\t    FD_SILENT_DCL_CLEAR;\n\t\t} else {\n\t\t\tdefault_drive_params[i].params.select_delay =\n\t\t\t    2 * HZ / 100;\n\t\t\tdefault_drive_params[i].params.flags &=\n\t\t\t    ~FD_SILENT_DCL_CLEAR;\n\t\t}\n\t}\n\tDPRINT(\"Assuming %s floppy hardware\\n\", param ? \"standard\" : \"broken\");\n}\n\nstatic void __init set_cmos(int *ints, int dummy, int dummy2)\n{\n\tint current_drive = 0;\n\n\tif (ints[0] != 2) {\n\t\tDPRINT(\"wrong number of parameters for CMOS\\n\");\n\t\treturn;\n\t}\n\tcurrent_drive = ints[1];\n\tif (current_drive < 0 || current_drive >= 8) {\n\t\tDPRINT(\"bad drive for set_cmos\\n\");\n\t\treturn;\n\t}\n#if N_FDC > 1\n\tif (current_drive >= 4 && !FDC2)\n\t\tFDC2 = 0x370;\n#endif\n\tDP->cmos = ints[2];\n\tDPRINT(\"setting CMOS code to %d\\n\", ints[2]);\n}\n\nstatic struct param_table {\n\tconst char *name;\n\tvoid (*fn) (int *ints, int param, int param2);\n\tint *var;\n\tint def_param;\n\tint param2;\n} config_params[] __initdata = {\n\t{\"allowed_drive_mask\", NULL, &allowed_drive_mask, 0xff, 0}, /* obsolete */\n\t{\"all_drives\", NULL, &allowed_drive_mask, 0xff, 0},\t/* obsolete */\n\t{\"asus_pci\", NULL, &allowed_drive_mask, 0x33, 0},\n\t{\"irq\", NULL, &FLOPPY_IRQ, 6, 0},\n\t{\"dma\", NULL, &FLOPPY_DMA, 2, 0},\n\t{\"daring\", daring, NULL, 1, 0},\n#if N_FDC > 1\n\t{\"two_fdc\", NULL, &FDC2, 0x370, 0},\n\t{\"one_fdc\", NULL, &FDC2, 0, 0},\n#endif\n\t{\"thinkpad\", floppy_set_flags, NULL, 1, FD_INVERTED_DCL},\n\t{\"broken_dcl\", floppy_set_flags, NULL, 1, FD_BROKEN_DCL},\n\t{\"messages\", floppy_set_flags, NULL, 1, FTD_MSG},\n\t{\"silent_dcl_clear\", floppy_set_flags, NULL, 1, FD_SILENT_DCL_CLEAR},\n\t{\"debug\", floppy_set_flags, NULL, 1, FD_DEBUG},\n\t{\"nodma\", NULL, &can_use_virtual_dma, 1, 0},\n\t{\"omnibook\", NULL, &can_use_virtual_dma, 1, 0},\n\t{\"yesdma\", NULL, &can_use_virtual_dma, 0, 0},\n\t{\"fifo_depth\", NULL, &fifo_depth, 0xa, 0},\n\t{\"nofifo\", NULL, &no_fifo, 0x20, 0},\n\t{\"usefifo\", NULL, &no_fifo, 0, 0},\n\t{\"cmos\", set_cmos, NULL, 0, 0},\n\t{\"slow\", NULL, &slow_floppy, 1, 0},\n\t{\"unexpected_interrupts\", NULL, &print_unex, 1, 0},\n\t{\"no_unexpected_interrupts\", NULL, &print_unex, 0, 0},\n\t{\"L40SX\", NULL, &print_unex, 0, 0}\n\n\tEXTRA_FLOPPY_PARAMS\n};\n\nstatic int __init floppy_setup(char *str)\n{\n\tint i;\n\tint param;\n\tint ints[11];\n\n\tstr = get_options(str, ARRAY_SIZE(ints), ints);\n\tif (str) {\n\t\tfor (i = 0; i < ARRAY_SIZE(config_params); i++) {\n\t\t\tif (strcmp(str, config_params[i].name) == 0) {\n\t\t\t\tif (ints[0])\n\t\t\t\t\tparam = ints[1];\n\t\t\t\telse\n\t\t\t\t\tparam = config_params[i].def_param;\n\t\t\t\tif (config_params[i].fn)\n\t\t\t\t\tconfig_params[i].fn(ints, param,\n\t\t\t\t\t\t\t    config_params[i].\n\t\t\t\t\t\t\t    param2);\n\t\t\t\tif (config_params[i].var) {\n\t\t\t\t\tDPRINT(\"%s=%d\\n\", str, param);\n\t\t\t\t\t*config_params[i].var = param;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (str) {\n\t\tDPRINT(\"unknown floppy option [%s]\\n\", str);\n\n\t\tDPRINT(\"allowed options are:\");\n\t\tfor (i = 0; i < ARRAY_SIZE(config_params); i++)\n\t\t\tpr_cont(\" %s\", config_params[i].name);\n\t\tpr_cont(\"\\n\");\n\t} else\n\t\tDPRINT(\"botched floppy option\\n\");\n\tDPRINT(\"Read Documentation/blockdev/floppy.txt\\n\");\n\treturn 0;\n}\n\nstatic int have_no_fdc = -ENODEV;\n\nstatic ssize_t floppy_cmos_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *p = to_platform_device(dev);\n\tint drive;\n\n\tdrive = p->id;\n\treturn sprintf(buf, \"%X\\n\", UDP->cmos);\n}\n\nstatic DEVICE_ATTR(cmos, 0444, floppy_cmos_show, NULL);\n\nstatic struct attribute *floppy_dev_attrs[] = {\n\t&dev_attr_cmos.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(floppy_dev);\n\nstatic void floppy_device_release(struct device *dev)\n{\n}\n\nstatic int floppy_resume(struct device *dev)\n{\n\tint fdc;\n\n\tfor (fdc = 0; fdc < N_FDC; fdc++)\n\t\tif (FDCS->address != -1)\n\t\t\tuser_reset_fdc(-1, FD_RESET_ALWAYS, false);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops floppy_pm_ops = {\n\t.resume = floppy_resume,\n\t.restore = floppy_resume,\n};\n\nstatic struct platform_driver floppy_driver = {\n\t.driver = {\n\t\t   .name = \"floppy\",\n\t\t   .pm = &floppy_pm_ops,\n\t},\n};\n\nstatic const struct blk_mq_ops floppy_mq_ops = {\n\t.queue_rq = floppy_queue_rq,\n};\n\nstatic struct platform_device floppy_device[N_DRIVE];\n\nstatic bool floppy_available(int drive)\n{\n\tif (!(allowed_drive_mask & (1 << drive)))\n\t\treturn false;\n\tif (fdc_state[FDC(drive)].version == FDC_NONE)\n\t\treturn false;\n\treturn true;\n}\n\nstatic struct kobject *floppy_find(dev_t dev, int *part, void *data)\n{\n\tint drive = (*part & 3) | ((*part & 0x80) >> 5);\n\tif (drive >= N_DRIVE || !floppy_available(drive))\n\t\treturn NULL;\n\tif (((*part >> 2) & 0x1f) >= ARRAY_SIZE(floppy_type))\n\t\treturn NULL;\n\t*part = 0;\n\treturn get_disk_and_module(disks[drive]);\n}\n\nstatic int __init do_floppy_init(void)\n{\n\tint i, unit, drive, err;\n\n\tset_debugt();\n\tinterruptjiffies = resultjiffies = jiffies;\n\n#if defined(CONFIG_PPC)\n\tif (check_legacy_ioport(FDC1))\n\t\treturn -ENODEV;\n#endif\n\n\traw_cmd = NULL;\n\n\tfloppy_wq = alloc_ordered_workqueue(\"floppy\", 0);\n\tif (!floppy_wq)\n\t\treturn -ENOMEM;\n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tdisks[drive] = alloc_disk(1);\n\t\tif (!disks[drive]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_put_disk;\n\t\t}\n\n\t\tdisks[drive]->queue = blk_mq_init_sq_queue(&tag_sets[drive],\n\t\t\t\t\t\t\t   &floppy_mq_ops, 2,\n\t\t\t\t\t\t\t   BLK_MQ_F_SHOULD_MERGE);\n\t\tif (IS_ERR(disks[drive]->queue)) {\n\t\t\terr = PTR_ERR(disks[drive]->queue);\n\t\t\tdisks[drive]->queue = NULL;\n\t\t\tgoto out_put_disk;\n\t\t}\n\n\t\tblk_queue_bounce_limit(disks[drive]->queue, BLK_BOUNCE_HIGH);\n\t\tblk_queue_max_hw_sectors(disks[drive]->queue, 64);\n\t\tdisks[drive]->major = FLOPPY_MAJOR;\n\t\tdisks[drive]->first_minor = TOMINOR(drive);\n\t\tdisks[drive]->fops = &floppy_fops;\n\t\tdisks[drive]->events = DISK_EVENT_MEDIA_CHANGE;\n\t\tsprintf(disks[drive]->disk_name, \"fd%d\", drive);\n\n\t\ttimer_setup(&motor_off_timer[drive], motor_off_callback, 0);\n\t}\n\n\terr = register_blkdev(FLOPPY_MAJOR, \"fd\");\n\tif (err)\n\t\tgoto out_put_disk;\n\n\terr = platform_driver_register(&floppy_driver);\n\tif (err)\n\t\tgoto out_unreg_blkdev;\n\n\tblk_register_region(MKDEV(FLOPPY_MAJOR, 0), 256, THIS_MODULE,\n\t\t\t    floppy_find, NULL, NULL);\n\n\tfor (i = 0; i < 256; i++)\n\t\tif (ITYPE(i))\n\t\t\tfloppy_sizes[i] = floppy_type[ITYPE(i)].size;\n\t\telse\n\t\t\tfloppy_sizes[i] = MAX_DISK_SIZE << 1;\n\n\treschedule_timeout(MAXTIMEOUT, \"floppy init\");\n\tconfig_types();\n\n\tfor (i = 0; i < N_FDC; i++) {\n\t\tfdc = i;\n\t\tmemset(FDCS, 0, sizeof(*FDCS));\n\t\tFDCS->dtr = -1;\n\t\tFDCS->dor = 0x4;\n#if defined(__sparc__) || defined(__mc68000__)\n\t/*sparcs/sun3x don't have a DOR reset which we can fall back on to */\n#ifdef __mc68000__\n\t\tif (MACH_IS_SUN3X)\n#endif\n\t\t\tFDCS->version = FDC_82072A;\n#endif\n\t}\n\n\tuse_virtual_dma = can_use_virtual_dma & 1;\n\tfdc_state[0].address = FDC1;\n\tif (fdc_state[0].address == -1) {\n\t\tcancel_delayed_work(&fd_timeout);\n\t\terr = -ENODEV;\n\t\tgoto out_unreg_region;\n\t}\n#if N_FDC > 1\n\tfdc_state[1].address = FDC2;\n#endif\n\n\tfdc = 0;\t\t/* reset fdc in case of unexpected interrupt */\n\terr = floppy_grab_irq_and_dma();\n\tif (err) {\n\t\tcancel_delayed_work(&fd_timeout);\n\t\terr = -EBUSY;\n\t\tgoto out_unreg_region;\n\t}\n\n\t/* initialise drive state */\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tmemset(UDRS, 0, sizeof(*UDRS));\n\t\tmemset(UDRWE, 0, sizeof(*UDRWE));\n\t\tset_bit(FD_DISK_NEWCHANGE_BIT, &UDRS->flags);\n\t\tset_bit(FD_DISK_CHANGED_BIT, &UDRS->flags);\n\t\tset_bit(FD_VERIFY_BIT, &UDRS->flags);\n\t\tUDRS->fd_device = -1;\n\t\tfloppy_track_buffer = NULL;\n\t\tmax_buffer_sectors = 0;\n\t}\n\t/*\n\t * Small 10 msec delay to let through any interrupt that\n\t * initialization might have triggered, to not\n\t * confuse detection:\n\t */\n\tmsleep(10);\n\n\tfor (i = 0; i < N_FDC; i++) {\n\t\tfdc = i;\n\t\tFDCS->driver_version = FD_DRIVER_VERSION;\n\t\tfor (unit = 0; unit < 4; unit++)\n\t\t\tFDCS->track[unit] = 0;\n\t\tif (FDCS->address == -1)\n\t\t\tcontinue;\n\t\tFDCS->rawcmd = 2;\n\t\tif (user_reset_fdc(-1, FD_RESET_ALWAYS, false)) {\n\t\t\t/* free ioports reserved by floppy_grab_irq_and_dma() */\n\t\t\tfloppy_release_regions(fdc);\n\t\t\tFDCS->address = -1;\n\t\t\tFDCS->version = FDC_NONE;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Try to determine the floppy controller type */\n\t\tFDCS->version = get_fdc_version();\n\t\tif (FDCS->version == FDC_NONE) {\n\t\t\t/* free ioports reserved by floppy_grab_irq_and_dma() */\n\t\t\tfloppy_release_regions(fdc);\n\t\t\tFDCS->address = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (can_use_virtual_dma == 2 && FDCS->version < FDC_82072A)\n\t\t\tcan_use_virtual_dma = 0;\n\n\t\thave_no_fdc = 0;\n\t\t/* Not all FDCs seem to be able to handle the version command\n\t\t * properly, so force a reset for the standard FDC clones,\n\t\t * to avoid interrupt garbage.\n\t\t */\n\t\tuser_reset_fdc(-1, FD_RESET_ALWAYS, false);\n\t}\n\tfdc = 0;\n\tcancel_delayed_work(&fd_timeout);\n\tcurrent_drive = 0;\n\tinitialized = true;\n\tif (have_no_fdc) {\n\t\tDPRINT(\"no floppy controllers found\\n\");\n\t\terr = have_no_fdc;\n\t\tgoto out_release_dma;\n\t}\n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tif (!floppy_available(drive))\n\t\t\tcontinue;\n\n\t\tfloppy_device[drive].name = floppy_device_name;\n\t\tfloppy_device[drive].id = drive;\n\t\tfloppy_device[drive].dev.release = floppy_device_release;\n\t\tfloppy_device[drive].dev.groups = floppy_dev_groups;\n\n\t\terr = platform_device_register(&floppy_device[drive]);\n\t\tif (err)\n\t\t\tgoto out_remove_drives;\n\n\t\t/* to be cleaned up... */\n\t\tdisks[drive]->private_data = (void *)(long)drive;\n\t\tdisks[drive]->flags |= GENHD_FL_REMOVABLE;\n\t\tdevice_add_disk(&floppy_device[drive].dev, disks[drive], NULL);\n\t}\n\n\treturn 0;\n\nout_remove_drives:\n\twhile (drive--) {\n\t\tif (floppy_available(drive)) {\n\t\t\tdel_gendisk(disks[drive]);\n\t\t\tplatform_device_unregister(&floppy_device[drive]);\n\t\t}\n\t}\nout_release_dma:\n\tif (atomic_read(&usage_count))\n\t\tfloppy_release_irq_and_dma();\nout_unreg_region:\n\tblk_unregister_region(MKDEV(FLOPPY_MAJOR, 0), 256);\n\tplatform_driver_unregister(&floppy_driver);\nout_unreg_blkdev:\n\tunregister_blkdev(FLOPPY_MAJOR, \"fd\");\nout_put_disk:\n\tdestroy_workqueue(floppy_wq);\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tif (!disks[drive])\n\t\t\tbreak;\n\t\tif (disks[drive]->queue) {\n\t\t\tdel_timer_sync(&motor_off_timer[drive]);\n\t\t\tblk_cleanup_queue(disks[drive]->queue);\n\t\t\tdisks[drive]->queue = NULL;\n\t\t\tblk_mq_free_tag_set(&tag_sets[drive]);\n\t\t}\n\t\tput_disk(disks[drive]);\n\t}\n\treturn err;\n}\n\n#ifndef MODULE\nstatic __init void floppy_async_init(void *data, async_cookie_t cookie)\n{\n\tdo_floppy_init();\n}\n#endif\n\nstatic int __init floppy_init(void)\n{\n#ifdef MODULE\n\treturn do_floppy_init();\n#else\n\t/* Don't hold up the bootup by the floppy initialization */\n\tasync_schedule(floppy_async_init, NULL);\n\treturn 0;\n#endif\n}\n\nstatic const struct io_region {\n\tint offset;\n\tint size;\n} io_regions[] = {\n\t{ 2, 1 },\n\t/* address + 3 is sometimes reserved by pnp bios for motherboard */\n\t{ 4, 2 },\n\t/* address + 6 is reserved, and may be taken by IDE.\n\t * Unfortunately, Adaptec doesn't know this :-(, */\n\t{ 7, 1 },\n};\n\nstatic void floppy_release_allocated_regions(int fdc, const struct io_region *p)\n{\n\twhile (p != io_regions) {\n\t\tp--;\n\t\trelease_region(FDCS->address + p->offset, p->size);\n\t}\n}\n\n#define ARRAY_END(X) (&((X)[ARRAY_SIZE(X)]))\n\nstatic int floppy_request_regions(int fdc)\n{\n\tconst struct io_region *p;\n\n\tfor (p = io_regions; p < ARRAY_END(io_regions); p++) {\n\t\tif (!request_region(FDCS->address + p->offset,\n\t\t\t\t    p->size, \"floppy\")) {\n\t\t\tDPRINT(\"Floppy io-port 0x%04lx in use\\n\",\n\t\t\t       FDCS->address + p->offset);\n\t\t\tfloppy_release_allocated_regions(fdc, p);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void floppy_release_regions(int fdc)\n{\n\tfloppy_release_allocated_regions(fdc, ARRAY_END(io_regions));\n}\n\nstatic int floppy_grab_irq_and_dma(void)\n{\n\tif (atomic_inc_return(&usage_count) > 1)\n\t\treturn 0;\n\n\t/*\n\t * We might have scheduled a free_irq(), wait it to\n\t * drain first:\n\t */\n\tflush_workqueue(floppy_wq);\n\n\tif (fd_request_irq()) {\n\t\tDPRINT(\"Unable to grab IRQ%d for the floppy driver\\n\",\n\t\t       FLOPPY_IRQ);\n\t\tatomic_dec(&usage_count);\n\t\treturn -1;\n\t}\n\tif (fd_request_dma()) {\n\t\tDPRINT(\"Unable to grab DMA%d for the floppy driver\\n\",\n\t\t       FLOPPY_DMA);\n\t\tif (can_use_virtual_dma & 2)\n\t\t\tuse_virtual_dma = can_use_virtual_dma = 1;\n\t\tif (!(can_use_virtual_dma & 1)) {\n\t\t\tfd_free_irq();\n\t\t\tatomic_dec(&usage_count);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (fdc = 0; fdc < N_FDC; fdc++) {\n\t\tif (FDCS->address != -1) {\n\t\t\tif (floppy_request_regions(fdc))\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tfor (fdc = 0; fdc < N_FDC; fdc++) {\n\t\tif (FDCS->address != -1) {\n\t\t\treset_fdc_info(1);\n\t\t\tfd_outb(FDCS->dor, FD_DOR);\n\t\t}\n\t}\n\tfdc = 0;\n\tset_dor(0, ~0, 8);\t/* avoid immediate interrupt */\n\n\tfor (fdc = 0; fdc < N_FDC; fdc++)\n\t\tif (FDCS->address != -1)\n\t\t\tfd_outb(FDCS->dor, FD_DOR);\n\t/*\n\t * The driver will try and free resources and relies on us\n\t * to know if they were allocated or not.\n\t */\n\tfdc = 0;\n\tirqdma_allocated = 1;\n\treturn 0;\ncleanup:\n\tfd_free_irq();\n\tfd_free_dma();\n\twhile (--fdc >= 0)\n\t\tfloppy_release_regions(fdc);\n\tatomic_dec(&usage_count);\n\treturn -1;\n}\n\nstatic void floppy_release_irq_and_dma(void)\n{\n\tint old_fdc;\n#ifndef __sparc__\n\tint drive;\n#endif\n\tlong tmpsize;\n\tunsigned long tmpaddr;\n\n\tif (!atomic_dec_and_test(&usage_count))\n\t\treturn;\n\n\tif (irqdma_allocated) {\n\t\tfd_disable_dma();\n\t\tfd_free_dma();\n\t\tfd_free_irq();\n\t\tirqdma_allocated = 0;\n\t}\n\tset_dor(0, ~0, 8);\n#if N_FDC > 1\n\tset_dor(1, ~8, 0);\n#endif\n\n\tif (floppy_track_buffer && max_buffer_sectors) {\n\t\ttmpsize = max_buffer_sectors * 1024;\n\t\ttmpaddr = (unsigned long)floppy_track_buffer;\n\t\tfloppy_track_buffer = NULL;\n\t\tmax_buffer_sectors = 0;\n\t\tbuffer_min = buffer_max = -1;\n\t\tfd_dma_mem_free(tmpaddr, tmpsize);\n\t}\n#ifndef __sparc__\n\tfor (drive = 0; drive < N_FDC * 4; drive++)\n\t\tif (timer_pending(motor_off_timer + drive))\n\t\t\tpr_info(\"motor off timer %d still active\\n\", drive);\n#endif\n\n\tif (delayed_work_pending(&fd_timeout))\n\t\tpr_info(\"floppy timer still active:%s\\n\", timeout_message);\n\tif (delayed_work_pending(&fd_timer))\n\t\tpr_info(\"auxiliary floppy timer still active\\n\");\n\tif (work_pending(&floppy_work))\n\t\tpr_info(\"work still pending\\n\");\n\told_fdc = fdc;\n\tfor (fdc = 0; fdc < N_FDC; fdc++)\n\t\tif (FDCS->address != -1)\n\t\t\tfloppy_release_regions(fdc);\n\tfdc = old_fdc;\n}\n\n#ifdef MODULE\n\nstatic char *floppy;\n\nstatic void __init parse_floppy_cfg_string(char *cfg)\n{\n\tchar *ptr;\n\n\twhile (*cfg) {\n\t\tptr = cfg;\n\t\twhile (*cfg && *cfg != ' ' && *cfg != '\\t')\n\t\t\tcfg++;\n\t\tif (*cfg) {\n\t\t\t*cfg = '\\0';\n\t\t\tcfg++;\n\t\t}\n\t\tif (*ptr)\n\t\t\tfloppy_setup(ptr);\n\t}\n}\n\nstatic int __init floppy_module_init(void)\n{\n\tif (floppy)\n\t\tparse_floppy_cfg_string(floppy);\n\treturn floppy_init();\n}\nmodule_init(floppy_module_init);\n\nstatic void __exit floppy_module_exit(void)\n{\n\tint drive;\n\n\tblk_unregister_region(MKDEV(FLOPPY_MAJOR, 0), 256);\n\tunregister_blkdev(FLOPPY_MAJOR, \"fd\");\n\tplatform_driver_unregister(&floppy_driver);\n\n\tdestroy_workqueue(floppy_wq);\n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tdel_timer_sync(&motor_off_timer[drive]);\n\n\t\tif (floppy_available(drive)) {\n\t\t\tdel_gendisk(disks[drive]);\n\t\t\tplatform_device_unregister(&floppy_device[drive]);\n\t\t}\n\t\tblk_cleanup_queue(disks[drive]->queue);\n\t\tblk_mq_free_tag_set(&tag_sets[drive]);\n\n\t\t/*\n\t\t * These disks have not called add_disk().  Don't put down\n\t\t * queue reference in put_disk().\n\t\t */\n\t\tif (!(allowed_drive_mask & (1 << drive)) ||\n\t\t    fdc_state[FDC(drive)].version == FDC_NONE)\n\t\t\tdisks[drive]->queue = NULL;\n\n\t\tput_disk(disks[drive]);\n\t}\n\n\tcancel_delayed_work_sync(&fd_timeout);\n\tcancel_delayed_work_sync(&fd_timer);\n\n\tif (atomic_read(&usage_count))\n\t\tfloppy_release_irq_and_dma();\n\n\t/* eject disk, if any */\n\tfd_eject(0);\n}\n\nmodule_exit(floppy_module_exit);\n\nmodule_param(floppy, charp, 0);\nmodule_param(FLOPPY_IRQ, int, 0);\nmodule_param(FLOPPY_DMA, int, 0);\nMODULE_AUTHOR(\"Alain L. Knaff\");\nMODULE_SUPPORTED_DEVICE(\"fd\");\nMODULE_LICENSE(\"GPL\");\n\n/* This doesn't actually get used other than for module information */\nstatic const struct pnp_device_id floppy_pnpids[] = {\n\t{\"PNP0700\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pnp, floppy_pnpids);\n\n#else\n\n__setup(\"floppy=\", floppy_setup);\nmodule_init(floppy_init)\n#endif\n\nMODULE_ALIAS_BLOCKDEV_MAJOR(FLOPPY_MAJOR);\n"], "filenames": ["drivers/block/floppy.c"], "buggy_code_start_loc": [2121], "buggy_code_end_loc": [3234], "fixing_code_start_loc": [2122], "fixing_code_end_loc": [3240], "type": "CWE-369", "message": "In the Linux kernel before 5.2.3, drivers/block/floppy.c allows a denial of service by setup_format_params division-by-zero. Two consecutive ioctls can trigger the bug: the first one should set the drive geometry with .sect and .rate values that make F_SECT_PER_TRACK be zero. Next, the floppy format operation should be called. It can be triggered by an unprivileged local user even when a floppy disk has not been inserted. NOTE: QEMU creates the floppy device by default.", "other": {"cve": {"id": "CVE-2019-14284", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-26T13:15:13.113", "lastModified": "2019-08-11T23:15:12.970", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 5.2.3, drivers/block/floppy.c allows a denial of service by setup_format_params division-by-zero. Two consecutive ioctls can trigger the bug: the first one should set the drive geometry with .sect and .rate values that make F_SECT_PER_TRACK be zero. Next, the floppy format operation should be called. It can be triggered by an unprivileged local user even when a floppy disk has not been inserted. NOTE: QEMU creates the floppy device by default."}, {"lang": "es", "value": "En el kernel de Linux anterior a versi\u00f3n 5.2.3, el archivo drivers/block/floppy.c, permite una denegaci\u00f3n de servicio mediante la divisi\u00f3n por cero de la funci\u00f3n setup_format_params. Dos ioctls consecutivos pueden desencadenar el error: el primero debe establecer la geometr\u00eda de la unidad con valores .sect y .rate que hacen que F_SECT_PER_TRACK sea cero. A continuaci\u00f3n, se debe llamar a la operaci\u00f3n de formato de disquete. Puede ser activado por un usuario local sin privilegios incluso cuando no se ha insertado un disquete. NOTA: QEMU crea el dispositivo de disquete de por defecto."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.2.3", "matchCriteriaId": "38844317-DEDF-4600-BA0E-C7D28D8EC200"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00055.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00056.html", "source": "cve@mitre.org"}, {"url": "http://packetstormsecurity.com/files/154059/Slackware-Security-Advisory-Slackware-14.2-kernel-Updates.html", "source": "cve@mitre.org"}, {"url": "http://packetstormsecurity.com/files/154408/Kernel-Live-Patch-Security-Notice-LSN-0055-1.html", "source": "cve@mitre.org"}, {"url": "http://packetstormsecurity.com/files/154951/Kernel-Live-Patch-Security-Notice-LSN-0058-1.html", "source": "cve@mitre.org"}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.2.3", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=f3554aeb991214cbfafd17d55e2bfddb50282e32", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/f3554aeb991214cbfafd17d55e2bfddb50282e32", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/08/msg00016.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2019/08/msg00017.html", "source": "cve@mitre.org"}, {"url": "https://seclists.org/bugtraq/2019/Aug/13", "source": "cve@mitre.org"}, {"url": "https://seclists.org/bugtraq/2019/Aug/18", "source": "cve@mitre.org"}, {"url": "https://seclists.org/bugtraq/2019/Aug/26", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20190905-0002/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4114-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4115-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4116-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4117-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4118-1/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2019/dsa-4495", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2019/dsa-4497", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/f3554aeb991214cbfafd17d55e2bfddb50282e32"}}