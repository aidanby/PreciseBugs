{"buggy_code": ["#!/usr/bin/perl\n\nuse strict;\nuse warnings;\n\n# ----------------------------------------------------------------------------\n# you:  what's the invocation?\n# me:   Hail, O Lord Ganesha, destroyer of obsta...\n# you:  err hmm not *that* sort of invocation... I meant how does this program\n#       get invoked?\n# me:   oh hehe <hides sheepish grin>, ok here we go...\n#\n# ssh mode\n# - started by sshd\n# - one argument, the \"user\" name\n# - one env var, SSH_ORIGINAL_COMMAND, containing the command\n# - command typically: git-(receive|upload)-pack 'reponame(.git)?'\n# - special gitolite commands: info, expand, (get|set)(perms|desc)\n# - special non-gitolite commands: rsync, svnserve, htpasswd\n# - other commands: anything in $GL_ADC_PATH if defined (see rc file)\n#\n# (smart) http mode\n# - started by apache (httpd)\n# - no arguments\n# - REQUEST_URI contains verb and repo, REMOTE_USER contains username\n# - REQUEST_URI looks like /path/reponame.git/(info/refs\\?service=)?git-(receive|upload)-pack\n# - no special processing commands currently handled\n# ----------------------------------------------------------------------------\n\n# ----------------------------------------------------------------------------\n#       common definitions\n# ----------------------------------------------------------------------------\n\n# these are set by the \"rc\" file\nour ($GL_LOGT, $GL_CONF_COMPILED, $REPO_BASE, $GIT_PATH, $REPO_UMASK, $GL_ADMINDIR, $RSYNC_BASE, $HTPASSWD_FILE, $GL_WILDREPOS, $GL_WILDREPOS_DEFPERMS, $GL_ADC_PATH, $SVNSERVE, $PROJECTS_LIST, $GL_SLAVE_MODE, $GL_PERFLOGT, $GL_ALL_READ_ALL);\n# and these are set by gitolite.pm\nour ($R_COMMANDS, $W_COMMANDS, $REPONAME_PATT, $REPOPATT_PATT, $ADC_CMD_ARGS_PATT);\nour %repos;\nour %groups;\nour %git_configs;\nour %split_conf;;\n\n# the common setup module is in the same directory as this running program is\nmy $bindir = $0;\n$bindir =~ s/\\/[^\\/]+$//;\n$bindir = \"$ENV{PWD}/$bindir\" unless $bindir =~ /^\\//;\nunshift @INC, $bindir;\nrequire gitolite or die \"parse gitolite.pm failed\\n\";\n\n# ask where the rc file is, get it, and \"do\" it\n&where_is_rc();\ndie \"parse $ENV{GL_RC} failed: \"       . ($! or $@) unless do $ENV{GL_RC};\n\n# we need to pass GL_ADMINDIR and the bindir to the child hooks\n$ENV{GL_ADMINDIR} = $GL_ADMINDIR;\n$ENV{GL_BINDIR} = $bindir;\n\n# add a custom path for git binaries, if specified\n$ENV{PATH} .= \":$GIT_PATH\" if $GIT_PATH;\n\n# set default permission of wildcard repositories\n$ENV{GL_WILDREPOS_DEFPERMS} = $GL_WILDREPOS_DEFPERMS if $GL_WILDREPOS_DEFPERMS;\n\n# set the umask before creating any files\numask($REPO_UMASK);\n\n$ENV{GL_REPO_BASE_ABS} = ( $REPO_BASE =~ m(^/) ? $REPO_BASE : \"$ENV{HOME}/$REPO_BASE\" );\n\n# ----------------------------------------------------------------------------\n#       start...\n# ----------------------------------------------------------------------------\n\n# if the first argument is a \"-s\", this user is allowed to get a shell using\n# this key\nmy $shell_allowed = 0;\nif (@ARGV and $ARGV[0] eq '-s') {\n    $shell_allowed = 1;\n    shift;\n}\n\n# ----------------------------------------------------------------------------\n#       set up SSH_ORIGINAL_COMMAND and SSH_CONNECTION in http mode\n# ----------------------------------------------------------------------------\n\n# fake out SSH_ORIGINAL_COMMAND and SSH_CONNECTION so the rest of the code\n# stays the same (except the exec at the end).\n\nmy $user;\nif ($ENV{REQUEST_URI}) {\n    die \"fallback to DAV not supported\\n\" if $ENV{REQUEST_METHOD} eq 'PROPFIND';\n\n    # these patterns indicate normal git usage; see \"services[]\" in\n    # http-backend.c for how I got that.  Also note that \"info\" is overloaded;\n    # git uses \"info/refs...\", while gitolite uses \"info\" or \"info?...\".  So\n    # there's a \"/\" after info in the list below\n    if ($ENV{PATH_INFO} =~ m(^/(.*)/(HEAD$|info/refs$|objects/|git-(?:upload|receive)-pack$))) {\n        my $repo = $1;\n        my $verb = ($ENV{REQUEST_URI} =~ /git-receive-pack/) ?  'git-receive-pack' : 'git-upload-pack';\n        $ENV{SSH_ORIGINAL_COMMAND} = \"$verb '$repo'\";\n    } else {\n        # this is one of our custom commands; could be anything really,\n        # because of the adc feature\n        my ($verb) = ($ENV{PATH_INFO} =~ m(^/(\\S+)));\n        my $args = $ENV{QUERY_STRING};\n        $args =~ s/\\+/ /g;\n        $ENV{SSH_ORIGINAL_COMMAND} = $verb;\n        $ENV{SSH_ORIGINAL_COMMAND} .= \" $args\" if $args;\n        &print_http_headers();  # in preparation for the eventual output!\n    }\n    $ENV{SSH_CONNECTION} = \"$ENV{REMOTE_ADDR} $ENV{REMOTE_PORT} $ENV{SERVER_ADDR} $ENV{SERVER_PORT}\";\n    $user = $ENV{GL_USER} = $ENV{REMOTE_USER};\n} else {\n    # no (more) arguments given in ssh mode?  default user is $USER\n    # (fedorahosted works like this, and it is harmless for others)\n    @ARGV = ($ENV{USER}) unless @ARGV;\n    $user=$ENV{GL_USER}=shift;\n}\n\n# ----------------------------------------------------------------------------\n#       logging, timestamp env vars\n# ----------------------------------------------------------------------------\n\n$ENV{GL_LOG} = &get_logfilename($GL_LOGT);\n\n# ----------------------------------------------------------------------------\n#       sanity checks on SSH_ORIGINAL_COMMAND\n# ----------------------------------------------------------------------------\n\n# no SSH_ORIGINAL_COMMAND given...\nunless ($ENV{SSH_ORIGINAL_COMMAND}) {\n    # if the user is allowed to use a shell, give him one\n    if ($shell_allowed) {\n        my $shell = $ENV{SHELL};\n        $shell =~ s/.*\\//-/;    # change \"/bin/bash\" to \"-bash\"\n        &log_it($shell);\n        exec { $ENV{SHELL} } $shell;\n    }\n    # otherwise, pretend he typed in \"info\" and carry on...\n    $ENV{SSH_ORIGINAL_COMMAND} = 'info';\n}\n\n# ----------------------------------------------------------------------------\n#       slave mode should not do much\n# ----------------------------------------------------------------------------\n\ndie \"server is in slave mode; you can only fetch\\n\"\n    if ($GL_SLAVE_MODE and $ENV{SSH_ORIGINAL_COMMAND} !~ /^(info|expand|get|git-upload-)/);\n\n# ----------------------------------------------------------------------------\n#       admin defined commands\n# ----------------------------------------------------------------------------\n\n# please see doc/admin-defined-commands.mkd for details\nif ($GL_ADC_PATH and -d $GL_ADC_PATH) {\n    my ($cmd, @args) = split ' ', $ENV{SSH_ORIGINAL_COMMAND};\n    if (-x \"$GL_ADC_PATH/$cmd\") {\n        # yes this is rather strict, sorry.\n        do { die \"I don't like $_\\n\" unless $_ =~ $ADC_CMD_ARGS_PATT } for ($cmd, @args);\n        &log_it(\"$GL_ADC_PATH/$ENV{SSH_ORIGINAL_COMMAND}\");\n        exec(\"$GL_ADC_PATH/$cmd\", @args);\n    }\n}\n\n# ----------------------------------------------------------------------------\n#       get and set perms for actual repo created by wildcard-autoviv\n# ----------------------------------------------------------------------------\n\nmy $CUSTOM_COMMANDS=qr/^\\s*(expand|(get|set)(perms|desc))\\b/;\n\n# note that all the subs called here chdir somewhere else and do not come\n# back; they all blithely take advantage of the fact that processing custom\n# commands is sort of a dead end for normal (git) processing\n\nif ($ENV{SSH_ORIGINAL_COMMAND} =~ $CUSTOM_COMMANDS) {\n    die \"wildrepos disabled, sorry\\n\" unless $GL_WILDREPOS;\n    my $cmd = $ENV{SSH_ORIGINAL_COMMAND};\n    my ($verb, $repo) = ($cmd =~ /^\\s*(\\S+)(?:\\s+'?\\/?(.*?)(?:\\.git)?'?)?$/);\n    # deal with \"no argument\" cases\n    $verb eq 'expand' ? $repo = '^' : die \"$verb needs an argument\\n\" unless $repo;\n    if ($repo =~ $REPONAME_PATT and $verb =~ /getperms|setperms/) {\n        # with an actual reponame, you can \"getperms\" or \"setperms\"\n        get_set_perms($repo, $verb, $user);\n    }\n    elsif ($repo =~ $REPONAME_PATT and $verb =~ /(get|set)desc/) {\n        # with an actual reponame, you can \"getdesc\" or \"setdesc\"\n        get_set_desc($repo, $verb, $user);\n    }\n    elsif ($verb eq 'expand') {\n        # with a wildcard, you can \"expand\" it to see what repos actually match\n        die \"$repo has invalid characters\" unless \"x$repo\" =~ $REPOPATT_PATT;\n        expand_wild($GL_ADMINDIR, $GL_CONF_COMPILED, $repo, $user);\n    } else {\n        die \"$cmd doesn't make sense to me\\n\";\n    }\n    exit 0;\n}\n\n# ----------------------------------------------------------------------------\n#       non-git commands\n# ----------------------------------------------------------------------------\n\n# if the command does NOT fit the pattern of a normal git command, send it off\n# somewhere else...\n\n# side notes on detecting a normal git command: the pattern we check allows\n# old style as well as new style (\"git-subcommand arg\" or \"git subcommand\n# arg\").  Currently, this is how git sends across the command (including the\n# single quotes):\n#       git-receive-pack 'reponame.git'\n\nmy ($verb, $repo) = ($ENV{SSH_ORIGINAL_COMMAND} =~ /^\\s*(git\\s+\\S+|\\S+)\\s+'\\/?(.*?)(?:\\.git)?'/);\nunless ( $verb and ( $verb eq 'git-init' or $verb =~ $R_COMMANDS or $verb =~ $W_COMMANDS ) and $repo and $repo =~ $REPONAME_PATT ) {\n    # ok, it's not a normal git command; call the special command helper\n    &special_cmd ($GL_ADMINDIR, $GL_CONF_COMPILED, $shell_allowed, $RSYNC_BASE, $HTPASSWD_FILE, $SVNSERVE);\n    exit;\n}\ndie \"$repo ends with a slash; I don't like that\\n\" if $repo =~ /\\/$/;\ndie \"$repo has two consecutive periods; I don't like that\\n\" if $repo =~ /\\.\\./;\n\n# reponame\n$ENV{GL_REPO}=$repo;\n\n# ----------------------------------------------------------------------------\n#       the real git commands (git-receive-pack, etc...)\n# ----------------------------------------------------------------------------\n\n# ----------------------------------------------------------------------------\n#       first level permissions check\n# ----------------------------------------------------------------------------\n\nmy ($perm, $creator, $wild);\nif ( $GL_ALL_READ_ALL and $verb =~ $R_COMMANDS and -d \"$ENV{GL_REPO_BASE_ABS}/$repo.git\") {\n    $perm = 'R';\n} else {\n    ($perm, $creator, $wild) = &repo_rights($repo);\n}\nif ($perm =~ /C/) {\n    # it was missing, and you have create perms\n    wrap_chdir(\"$ENV{GL_REPO_BASE_ABS}\");\n    new_repo($repo, \"$GL_ADMINDIR/hooks/common\", $user);\n        # note pwd is now the bare \"repo.git\"; new_repo does that...\n    wrap_print(\"gl-perms\", \"$GL_WILDREPOS_DEFPERMS\\n\") if $GL_WILDREPOS_DEFPERMS;\n    &setup_git_configs($repo, \\%git_configs);\n    &setup_daemon_access($repo);\n    &add_del_line (\"$repo.git\", $PROJECTS_LIST, &setup_gitweb_access($repo, '', ''));\n    wrap_chdir($ENV{HOME});\n}\n\n# we know the user and repo; we just need to know what perm he's trying\n# aa == attempted access\nmy $aa = ($verb =~ $R_COMMANDS ? 'R' : 'W');\ndie \"$aa access for $repo DENIED to $user\n(Or there may be no repository at the given path. Did you spell it correctly?)\\n\" unless $perm =~ /$aa/;\n\n# check if repo is write-enabled\n&check_repo_write_enabled($repo) if $aa eq 'W';\n\n# ----------------------------------------------------------------------------\n#       over to git now\n# ----------------------------------------------------------------------------\n\nif ($ENV{REQUEST_URI}) {\n    &log_it($ENV{REQUEST_URI});\n    exec $ENV{GIT_HTTP_BACKEND};\n    # the GIT_HTTP_BACKEND env var should be set either by the rc file, or as\n    # a SetEnv in the apache config somewhere\n}\n\n&log_it();\n\n$repo = \"'$REPO_BASE/$repo.git'\";\nexec(\"git\", \"shell\", \"-c\", \"$verb $repo\") unless $verb eq 'git-init';\n"], "fixing_code": ["#!/usr/bin/perl\n\nuse strict;\nuse warnings;\n\n# ----------------------------------------------------------------------------\n# you:  what's the invocation?\n# me:   Hail, O Lord Ganesha, destroyer of obsta...\n# you:  err hmm not *that* sort of invocation... I meant how does this program\n#       get invoked?\n# me:   oh hehe <hides sheepish grin>, ok here we go...\n#\n# ssh mode\n# - started by sshd\n# - one argument, the \"user\" name\n# - one env var, SSH_ORIGINAL_COMMAND, containing the command\n# - command typically: git-(receive|upload)-pack 'reponame(.git)?'\n# - special gitolite commands: info, expand, (get|set)(perms|desc)\n# - special non-gitolite commands: rsync, svnserve, htpasswd\n# - other commands: anything in $GL_ADC_PATH if defined (see rc file)\n#\n# (smart) http mode\n# - started by apache (httpd)\n# - no arguments\n# - REQUEST_URI contains verb and repo, REMOTE_USER contains username\n# - REQUEST_URI looks like /path/reponame.git/(info/refs\\?service=)?git-(receive|upload)-pack\n# - no special processing commands currently handled\n# ----------------------------------------------------------------------------\n\n# ----------------------------------------------------------------------------\n#       common definitions\n# ----------------------------------------------------------------------------\n\n# these are set by the \"rc\" file\nour ($GL_LOGT, $GL_CONF_COMPILED, $REPO_BASE, $GIT_PATH, $REPO_UMASK, $GL_ADMINDIR, $RSYNC_BASE, $HTPASSWD_FILE, $GL_WILDREPOS, $GL_WILDREPOS_DEFPERMS, $GL_ADC_PATH, $SVNSERVE, $PROJECTS_LIST, $GL_SLAVE_MODE, $GL_PERFLOGT, $GL_ALL_READ_ALL);\n# and these are set by gitolite.pm\nour ($R_COMMANDS, $W_COMMANDS, $REPONAME_PATT, $REPOPATT_PATT, $ADC_CMD_ARGS_PATT);\nour %repos;\nour %groups;\nour %git_configs;\nour %split_conf;;\n\n# the common setup module is in the same directory as this running program is\nmy $bindir = $0;\n$bindir =~ s/\\/[^\\/]+$//;\n$bindir = \"$ENV{PWD}/$bindir\" unless $bindir =~ /^\\//;\nunshift @INC, $bindir;\nrequire gitolite or die \"parse gitolite.pm failed\\n\";\n\n# ask where the rc file is, get it, and \"do\" it\n&where_is_rc();\ndie \"parse $ENV{GL_RC} failed: \"       . ($! or $@) unless do $ENV{GL_RC};\n\n# we need to pass GL_ADMINDIR and the bindir to the child hooks\n$ENV{GL_ADMINDIR} = $GL_ADMINDIR;\n$ENV{GL_BINDIR} = $bindir;\n\n# add a custom path for git binaries, if specified\n$ENV{PATH} .= \":$GIT_PATH\" if $GIT_PATH;\n\n# set default permission of wildcard repositories\n$ENV{GL_WILDREPOS_DEFPERMS} = $GL_WILDREPOS_DEFPERMS if $GL_WILDREPOS_DEFPERMS;\n\n# set the umask before creating any files\numask($REPO_UMASK);\n\n$ENV{GL_REPO_BASE_ABS} = ( $REPO_BASE =~ m(^/) ? $REPO_BASE : \"$ENV{HOME}/$REPO_BASE\" );\n\n# ----------------------------------------------------------------------------\n#       start...\n# ----------------------------------------------------------------------------\n\n# if the first argument is a \"-s\", this user is allowed to get a shell using\n# this key\nmy $shell_allowed = 0;\nif (@ARGV and $ARGV[0] eq '-s') {\n    $shell_allowed = 1;\n    shift;\n}\n\n# ----------------------------------------------------------------------------\n#       set up SSH_ORIGINAL_COMMAND and SSH_CONNECTION in http mode\n# ----------------------------------------------------------------------------\n\n# fake out SSH_ORIGINAL_COMMAND and SSH_CONNECTION so the rest of the code\n# stays the same (except the exec at the end).\n\nmy $user;\nif ($ENV{REQUEST_URI}) {\n    die \"fallback to DAV not supported\\n\" if $ENV{REQUEST_METHOD} eq 'PROPFIND';\n\n    # these patterns indicate normal git usage; see \"services[]\" in\n    # http-backend.c for how I got that.  Also note that \"info\" is overloaded;\n    # git uses \"info/refs...\", while gitolite uses \"info\" or \"info?...\".  So\n    # there's a \"/\" after info in the list below\n    if ($ENV{PATH_INFO} =~ m(^/(.*)/(HEAD$|info/refs$|objects/|git-(?:upload|receive)-pack$))) {\n        my $repo = $1;\n        my $verb = ($ENV{REQUEST_URI} =~ /git-receive-pack/) ?  'git-receive-pack' : 'git-upload-pack';\n        $ENV{SSH_ORIGINAL_COMMAND} = \"$verb '$repo'\";\n    } else {\n        # this is one of our custom commands; could be anything really,\n        # because of the adc feature\n        my ($verb) = ($ENV{PATH_INFO} =~ m(^/(\\S+)));\n        my $args = $ENV{QUERY_STRING};\n        $args =~ s/\\+/ /g;\n        $ENV{SSH_ORIGINAL_COMMAND} = $verb;\n        $ENV{SSH_ORIGINAL_COMMAND} .= \" $args\" if $args;\n        &print_http_headers();  # in preparation for the eventual output!\n    }\n    $ENV{SSH_CONNECTION} = \"$ENV{REMOTE_ADDR} $ENV{REMOTE_PORT} $ENV{SERVER_ADDR} $ENV{SERVER_PORT}\";\n    $user = $ENV{GL_USER} = $ENV{REMOTE_USER};\n} else {\n    # no (more) arguments given in ssh mode?  default user is $USER\n    # (fedorahosted works like this, and it is harmless for others)\n    @ARGV = ($ENV{USER}) unless @ARGV;\n    $user=$ENV{GL_USER}=shift;\n}\n\n# ----------------------------------------------------------------------------\n#       logging, timestamp env vars\n# ----------------------------------------------------------------------------\n\n$ENV{GL_LOG} = &get_logfilename($GL_LOGT);\n\n# ----------------------------------------------------------------------------\n#       sanity checks on SSH_ORIGINAL_COMMAND\n# ----------------------------------------------------------------------------\n\n# no SSH_ORIGINAL_COMMAND given...\nunless ($ENV{SSH_ORIGINAL_COMMAND}) {\n    # if the user is allowed to use a shell, give him one\n    if ($shell_allowed) {\n        my $shell = $ENV{SHELL};\n        $shell =~ s/.*\\//-/;    # change \"/bin/bash\" to \"-bash\"\n        &log_it($shell);\n        exec { $ENV{SHELL} } $shell;\n    }\n    # otherwise, pretend he typed in \"info\" and carry on...\n    $ENV{SSH_ORIGINAL_COMMAND} = 'info';\n}\n\n# ----------------------------------------------------------------------------\n#       slave mode should not do much\n# ----------------------------------------------------------------------------\n\ndie \"server is in slave mode; you can only fetch\\n\"\n    if ($GL_SLAVE_MODE and $ENV{SSH_ORIGINAL_COMMAND} !~ /^(info|expand|get|git-upload-)/);\n\n# ----------------------------------------------------------------------------\n#       admin defined commands\n# ----------------------------------------------------------------------------\n\n# please see doc/admin-defined-commands.mkd for details\nif ($GL_ADC_PATH and -d $GL_ADC_PATH) {\n    my ($cmd, @args) = split ' ', $ENV{SSH_ORIGINAL_COMMAND};\n    if (-x \"$GL_ADC_PATH/$cmd\") {\n        die \"I don't like $cmd\\n\" if $cmd =~ /\\.\\./;\n        # yes this is rather strict, sorry.\n        do { die \"I don't like $_\\n\" unless $_ =~ $ADC_CMD_ARGS_PATT } for ($cmd, @args);\n        &log_it(\"$GL_ADC_PATH/$ENV{SSH_ORIGINAL_COMMAND}\");\n        exec(\"$GL_ADC_PATH/$cmd\", @args);\n    }\n}\n\n# ----------------------------------------------------------------------------\n#       get and set perms for actual repo created by wildcard-autoviv\n# ----------------------------------------------------------------------------\n\nmy $CUSTOM_COMMANDS=qr/^\\s*(expand|(get|set)(perms|desc))\\b/;\n\n# note that all the subs called here chdir somewhere else and do not come\n# back; they all blithely take advantage of the fact that processing custom\n# commands is sort of a dead end for normal (git) processing\n\nif ($ENV{SSH_ORIGINAL_COMMAND} =~ $CUSTOM_COMMANDS) {\n    die \"wildrepos disabled, sorry\\n\" unless $GL_WILDREPOS;\n    my $cmd = $ENV{SSH_ORIGINAL_COMMAND};\n    my ($verb, $repo) = ($cmd =~ /^\\s*(\\S+)(?:\\s+'?\\/?(.*?)(?:\\.git)?'?)?$/);\n    # deal with \"no argument\" cases\n    $verb eq 'expand' ? $repo = '^' : die \"$verb needs an argument\\n\" unless $repo;\n    if ($repo =~ $REPONAME_PATT and $verb =~ /getperms|setperms/) {\n        # with an actual reponame, you can \"getperms\" or \"setperms\"\n        get_set_perms($repo, $verb, $user);\n    }\n    elsif ($repo =~ $REPONAME_PATT and $verb =~ /(get|set)desc/) {\n        # with an actual reponame, you can \"getdesc\" or \"setdesc\"\n        get_set_desc($repo, $verb, $user);\n    }\n    elsif ($verb eq 'expand') {\n        # with a wildcard, you can \"expand\" it to see what repos actually match\n        die \"$repo has invalid characters\" unless \"x$repo\" =~ $REPOPATT_PATT;\n        expand_wild($GL_ADMINDIR, $GL_CONF_COMPILED, $repo, $user);\n    } else {\n        die \"$cmd doesn't make sense to me\\n\";\n    }\n    exit 0;\n}\n\n# ----------------------------------------------------------------------------\n#       non-git commands\n# ----------------------------------------------------------------------------\n\n# if the command does NOT fit the pattern of a normal git command, send it off\n# somewhere else...\n\n# side notes on detecting a normal git command: the pattern we check allows\n# old style as well as new style (\"git-subcommand arg\" or \"git subcommand\n# arg\").  Currently, this is how git sends across the command (including the\n# single quotes):\n#       git-receive-pack 'reponame.git'\n\nmy ($verb, $repo) = ($ENV{SSH_ORIGINAL_COMMAND} =~ /^\\s*(git\\s+\\S+|\\S+)\\s+'\\/?(.*?)(?:\\.git)?'/);\nunless ( $verb and ( $verb eq 'git-init' or $verb =~ $R_COMMANDS or $verb =~ $W_COMMANDS ) and $repo and $repo =~ $REPONAME_PATT ) {\n    # ok, it's not a normal git command; call the special command helper\n    &special_cmd ($GL_ADMINDIR, $GL_CONF_COMPILED, $shell_allowed, $RSYNC_BASE, $HTPASSWD_FILE, $SVNSERVE);\n    exit;\n}\ndie \"$repo ends with a slash; I don't like that\\n\" if $repo =~ /\\/$/;\ndie \"$repo has two consecutive periods; I don't like that\\n\" if $repo =~ /\\.\\./;\n\n# reponame\n$ENV{GL_REPO}=$repo;\n\n# ----------------------------------------------------------------------------\n#       the real git commands (git-receive-pack, etc...)\n# ----------------------------------------------------------------------------\n\n# ----------------------------------------------------------------------------\n#       first level permissions check\n# ----------------------------------------------------------------------------\n\nmy ($perm, $creator, $wild);\nif ( $GL_ALL_READ_ALL and $verb =~ $R_COMMANDS and -d \"$ENV{GL_REPO_BASE_ABS}/$repo.git\") {\n    $perm = 'R';\n} else {\n    ($perm, $creator, $wild) = &repo_rights($repo);\n}\nif ($perm =~ /C/) {\n    # it was missing, and you have create perms\n    wrap_chdir(\"$ENV{GL_REPO_BASE_ABS}\");\n    new_repo($repo, \"$GL_ADMINDIR/hooks/common\", $user);\n        # note pwd is now the bare \"repo.git\"; new_repo does that...\n    wrap_print(\"gl-perms\", \"$GL_WILDREPOS_DEFPERMS\\n\") if $GL_WILDREPOS_DEFPERMS;\n    &setup_git_configs($repo, \\%git_configs);\n    &setup_daemon_access($repo);\n    &add_del_line (\"$repo.git\", $PROJECTS_LIST, &setup_gitweb_access($repo, '', ''));\n    wrap_chdir($ENV{HOME});\n}\n\n# we know the user and repo; we just need to know what perm he's trying\n# aa == attempted access\nmy $aa = ($verb =~ $R_COMMANDS ? 'R' : 'W');\ndie \"$aa access for $repo DENIED to $user\n(Or there may be no repository at the given path. Did you spell it correctly?)\\n\" unless $perm =~ /$aa/;\n\n# check if repo is write-enabled\n&check_repo_write_enabled($repo) if $aa eq 'W';\n\n# ----------------------------------------------------------------------------\n#       over to git now\n# ----------------------------------------------------------------------------\n\nif ($ENV{REQUEST_URI}) {\n    &log_it($ENV{REQUEST_URI});\n    exec $ENV{GIT_HTTP_BACKEND};\n    # the GIT_HTTP_BACKEND env var should be set either by the rc file, or as\n    # a SetEnv in the apache config somewhere\n}\n\n&log_it();\n\n$repo = \"'$REPO_BASE/$repo.git'\";\nexec(\"git\", \"shell\", \"-c\", \"$verb $repo\") unless $verb eq 'git-init';\n"], "filenames": ["src/gl-auth-command"], "buggy_code_start_loc": [156], "buggy_code_end_loc": [156], "fixing_code_start_loc": [157], "fixing_code_end_loc": [158], "type": "CWE-22", "message": "Directory traversal vulnerability in the Admin Defined Commands (ADC) feature in gitolite before 1.5.9.1 allows remote attackers to execute arbitrary commands via .. (dot dot) sequences in admin-defined commands.", "other": {"cve": {"id": "CVE-2011-1572", "sourceIdentifier": "secalert@redhat.com", "published": "2011-10-04T10:55:09.003", "lastModified": "2019-09-09T18:02:34.013", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Directory traversal vulnerability in the Admin Defined Commands (ADC) feature in gitolite before 1.5.9.1 allows remote attackers to execute arbitrary commands via .. (dot dot) sequences in admin-defined commands."}, {"lang": "es", "value": "Vulnerabilidad de salto de directorio en la caracter\u00edstica Admin Defined Commands (ADC) en gitolite antes de la versi\u00f3n v1.5.9.1, permite a atacantes remotos incluir y ejecutar comandos al utilizar caracteres .. (punto punto) en comandos admin-defined."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.5.9", "matchCriteriaId": "9D4F021E-D2F9-4987-A9DA-F652F024F892"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:0.50:*:*:*:*:*:*:*", "matchCriteriaId": "9B00ECB9-B900-4A7D-9E16-F7CC9234D1BA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:0.55:*:*:*:*:*:*:*", "matchCriteriaId": "03D7FD64-44D8-4649-B234-25570C7002BA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:0.60:*:*:*:*:*:*:*", "matchCriteriaId": "C34A62EA-6141-46BC-861C-9B27B73879F3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:0.65:*:*:*:*:*:*:*", "matchCriteriaId": "EF3B2609-E301-4F04-A41E-56904F2198B4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:0.70:*:*:*:*:*:*:*", "matchCriteriaId": "F932CA6A-B5A8-4127-A05B-0B2451B058B6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:0.80:*:*:*:*:*:*:*", "matchCriteriaId": "A7856BE3-0ACB-4110-9588-4D54D6542670"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:0.85:*:*:*:*:*:*:*", "matchCriteriaId": "6335BE0C-58F8-4ACE-BA81-552339A7F085"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:0.90:*:*:*:*:*:*:*", "matchCriteriaId": "6D47DC83-99F9-4BE9-A265-3534D1014B20"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:0.95:*:*:*:*:*:*:*", "matchCriteriaId": "4A719302-490A-4652-A834-E431C7BCCECA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "A96FBE8E-4A1E-4306-8D2D-9D0C531A8D75"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:1.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "C3AEB2CF-276F-4C04-9729-DB9753C8D804"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:1.1:*:*:*:*:*:*:*", "matchCriteriaId": "850F72D5-BF5B-438A-B9AE-E5EFDD4E1631"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:1.2:*:*:*:*:*:*:*", "matchCriteriaId": "5B418106-A153-4561-83A9-3CCA7749F4EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:1.3:*:*:*:*:*:*:*", "matchCriteriaId": "6C0E473E-0FFF-4AB7-AE83-1A1D84857127"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:1.4:*:*:*:*:*:*:*", "matchCriteriaId": "794D0551-9624-476D-9C92-241E778AF4A3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:1.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "AEE889D6-5C1E-4C3A-85DA-982322D74FBB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:1.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "1A6A0ADB-C8B8-4D1E-8A4C-08CBA6B5E9A8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:1.5:*:*:*:*:*:*:*", "matchCriteriaId": "91EB741F-94D1-4361-8F4C-B1405A40E35D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:1.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "1EE930FA-AA3E-461C-8FE1-82F32B65F505"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:1.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "53548625-65A5-4A68-B847-0F7595661602"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:1.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "EA62E8B7-039E-486B-B06F-766B0B351A3D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:1.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "F9C6BF86-6B75-4FDA-9B9C-547E90CD87A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:1.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "C3B7B6C9-ECCD-4023-9BEB-33AE12B02A8A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:1.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "1C6E961E-701E-463D-BBF8-A67EF14229C3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:1.5.7:*:*:*:*:*:*:*", "matchCriteriaId": "A21C5AE6-D644-4F37-BC6C-FA270D29A884"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:1.5.8:*:*:*:*:*:*:*", "matchCriteriaId": "68890C03-F497-4B25-8EB0-6196CB65EA2B"}]}]}], "references": [{"url": "http://groups.google.com/group/gitolite/browse_thread/thread/797a93ec26e1dcbc?pli=1", "source": "secalert@redhat.com"}, {"url": "http://seclists.org/oss-sec/2011/q2/197", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://seclists.org/oss-sec/2011/q2/209", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.debian.org/security/2011/dsa-2215", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/46473", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=695568", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/65542", "source": "secalert@redhat.com"}, {"url": "https://github.com/sitaramc/gitolite/commit/4ce00aef84d1ff7c35f7adbbb99a6241cfda00cc", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/sitaramc/gitolite/commit/4ce00aef84d1ff7c35f7adbbb99a6241cfda00cc"}}