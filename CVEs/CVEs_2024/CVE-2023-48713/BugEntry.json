{"buggy_code": ["/*\nCopyright 2019 The Knative Authors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage metrics\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"sync\"\n\n\tnethttp \"knative.dev/networking/pkg/http\"\n\tnetheader \"knative.dev/networking/pkg/http/header\"\n)\n\nvar errUnsupportedMetricType = errors.New(\"unsupported metric type\")\n\ntype httpScrapeClient struct {\n\thttpClient *http.Client\n}\n\ntype scrapeError struct {\n\terror\n\tmightBeMesh bool\n}\n\nvar pool = sync.Pool{\n\tNew: func() interface{} {\n\t\treturn new(bytes.Buffer)\n\t},\n}\n\nfunc newHTTPScrapeClient(httpClient *http.Client) *httpScrapeClient {\n\treturn &httpScrapeClient{\n\t\thttpClient: httpClient,\n\t}\n}\n\nfunc (c *httpScrapeClient) Do(req *http.Request) (Stat, error) {\n\treq.Header.Add(\"Accept\", netheader.ProtobufMIMEType)\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn emptyStat, err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode < http.StatusOK || resp.StatusCode >= http.StatusMultipleChoices {\n\t\treturn emptyStat, scrapeError{\n\t\t\terror:       fmt.Errorf(\"GET request for URL %q returned HTTP status %v\", req.URL.String(), resp.StatusCode),\n\t\t\tmightBeMesh: nethttp.IsPotentialMeshErrorResponse(resp),\n\t\t}\n\t}\n\tif resp.Header.Get(\"Content-Type\") != netheader.ProtobufMIMEType {\n\t\treturn emptyStat, errUnsupportedMetricType\n\t}\n\treturn statFromProto(resp.Body)\n}\n\n// isPotentialMeshError returns whether the error encountered during scraping\n// is compatible with having been caused by the mesh being enabled.\nfunc isPotentialMeshError(err error) bool {\n\tvar se scrapeError\n\treturn errors.As(err, &se) && se.mightBeMesh\n}\n\nfunc statFromProto(body io.Reader) (Stat, error) {\n\tvar stat Stat\n\tb := pool.Get().(*bytes.Buffer)\n\tb.Reset()\n\tdefer pool.Put(b)\n\t_, err := b.ReadFrom(body)\n\tif err != nil {\n\t\treturn emptyStat, fmt.Errorf(\"reading body failed: %w\", err)\n\t}\n\terr = stat.Unmarshal(b.Bytes())\n\tif err != nil {\n\t\treturn emptyStat, fmt.Errorf(\"unmarshalling failed: %w\", err)\n\t}\n\treturn stat, nil\n}\n", "/*\nCopyright 2019 The Knative Authors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage metrics\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\tnetheader \"knative.dev/networking/pkg/http/header\"\n)\n\nconst (\n\tqueueAverageConcurrentRequests        = 3.0\n\tqueueRequestsPerSecond                = 5\n\tqueueAverageProxiedConcurrentRequests = 2.0\n\tqueueProxiedOperationsPerSecond       = 4\n\tprocessUptime                         = 2937.12\n\tpodName                               = \"test-revision-1234\"\n)\n\nvar (\n\ttestURL = \"http://test-revision-zhudex.test-namespace:9090/metrics\"\n\n\tstat = Stat{\n\t\tPodName:                          podName,\n\t\tAverageConcurrentRequests:        queueAverageConcurrentRequests,\n\t\tAverageProxiedConcurrentRequests: queueAverageProxiedConcurrentRequests,\n\t\tRequestCount:                     queueRequestsPerSecond,\n\t\tProxiedRequestCount:              queueProxiedOperationsPerSecond,\n\t\tProcessUptime:                    processUptime,\n\t}\n)\n\nfunc TestHTTPScrapeClientScrapeHappyCaseWithOptionals(t *testing.T) {\n\thClient := newTestHTTPClient(makeProtoResponse(http.StatusOK, stat, netheader.ProtobufMIMEType), nil)\n\tsClient := newHTTPScrapeClient(hClient)\n\treq, err := http.NewRequest(http.MethodGet, testURL, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create a request: %v\", err)\n\t}\n\tgot, err := sClient.Do(req)\n\tif err != nil {\n\t\tt.Fatalf(\"Scrape = %v, want no error\", err)\n\t}\n\tif !cmp.Equal(got, stat) {\n\t\tt.Errorf(\"Scraped stat mismatch; diff(-want,+got):\\n%s\", cmp.Diff(stat, got))\n\t}\n}\n\nfunc TestHTTPScrapeClientScrapeProtoErrorCases(t *testing.T) {\n\ttestCases := []struct {\n\t\tname            string\n\t\tresponseCode    int\n\t\tresponseType    string\n\t\tresponseErr     error\n\t\tstat            Stat\n\t\texpectedErr     string\n\t\texpectedMeshErr bool\n\t}{{\n\t\tname:         \"Non 200 return code\",\n\t\tresponseCode: http.StatusForbidden,\n\t\texpectedErr:  fmt.Sprintf(\"GET request for URL %q returned HTTP status 403\", testURL),\n\t}, {\n\t\tname:            \"503 return code\",\n\t\tresponseCode:    http.StatusServiceUnavailable,\n\t\texpectedErr:     fmt.Sprintf(\"GET request for URL %q returned HTTP status 503\", testURL),\n\t\texpectedMeshErr: true,\n\t}, {\n\t\tname:         \"Error got when sending request\",\n\t\tresponseCode: http.StatusOK,\n\t\tresponseErr:  errors.New(\"upstream closed\"),\n\t\texpectedErr:  \"upstream closed\",\n\t}, {\n\t\tname:         \"Wrong Content-Type\",\n\t\tresponseCode: http.StatusOK,\n\t\tresponseType: \"text/html\",\n\t\texpectedErr:  errUnsupportedMetricType.Error(),\n\t}}\n\n\tfor _, test := range testCases {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\thClient := newTestHTTPClient(makeProtoResponse(test.responseCode, test.stat, test.responseType), test.responseErr)\n\t\t\tsClient := newHTTPScrapeClient(hClient)\n\t\t\treq, err := http.NewRequest(http.MethodGet, testURL, nil)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to create a request: %v\", err)\n\t\t\t}\n\t\t\t_, err = sClient.Do(req)\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(\"Got no error\")\n\t\t\t}\n\t\t\tif !strings.Contains(err.Error(), test.expectedErr) {\n\t\t\t\tt.Errorf(\"Error = %q, want to contain: %q\", err.Error(), test.expectedErr)\n\t\t\t}\n\t\t\tif got := isPotentialMeshError(err); got != test.expectedMeshErr {\n\t\t\t\tt.Errorf(\"isMeshError(err) = %v, expected %v\", got, test.expectedMeshErr)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc makeProtoResponse(statusCode int, stat Stat, contentType string) *http.Response {\n\tbuffer, _ := stat.Marshal()\n\tres := &http.Response{\n\t\tStatusCode: statusCode,\n\t\tBody:       io.NopCloser(bytes.NewBuffer(buffer)),\n\t}\n\tres.Header = http.Header{}\n\tres.Header.Set(\"Content-Type\", contentType)\n\treturn res\n}\n\ntype fakeRoundTripper struct {\n\tresponse      *http.Response\n\tresponseError error\n}\n\nfunc (frt fakeRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {\n\treturn frt.response, frt.responseError\n}\n\nfunc newTestHTTPClient(response *http.Response, err error) *http.Client {\n\treturn &http.Client{\n\t\tTransport: fakeRoundTripper{\n\t\t\tresponse:      response,\n\t\t\tresponseError: err,\n\t\t},\n\t}\n}\n\nfunc BenchmarkUnmarshallingProtoData(b *testing.B) {\n\tstat := Stat{\n\t\tProcessUptime:                    12.2,\n\t\tAverageConcurrentRequests:        2.3,\n\t\tAverageProxiedConcurrentRequests: 100.2,\n\t\tRequestCount:                     122,\n\t\tProxiedRequestCount:              122,\n\t}\n\n\tbenchmarks := []struct {\n\t\tname    string\n\t\tpodName string\n\t}{{\n\t\tname:    \"BenchmarkStatWithEmptyPodName\",\n\t\tpodName: \"\",\n\t}, {\n\t\tname:    \"BenchmarkStatWithSmallPodName\",\n\t\tpodName: \"a-lzrjc-deployment-85d4b7d859-gspjs\",\n\t}, {\n\t\tname:    \"BenchmarkStatWithMediumPodName\",\n\t\tpodName: \"a-lzrjc-deployment-85d4b7d859-gspjs\" + strings.Repeat(\"p\", 50),\n\t}, {\n\t\tname:    \"BenchmarkStatWithLargePodName\",\n\t\tpodName: strings.Repeat(\"p\", 253),\n\t}}\n\tfor _, bm := range benchmarks {\n\t\tstat.PodName = bm.podName\n\t\tbodyBytes, err := stat.Marshal()\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tb.Run(bm.name, func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_, err = statFromProto(bytes.NewReader(bodyBytes))\n\t\t\t\tif err != nil {\n\t\t\t\t\tb.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n"], "fixing_code": ["/*\nCopyright 2019 The Knative Authors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage metrics\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"sync\"\n\n\tnethttp \"knative.dev/networking/pkg/http\"\n\tnetheader \"knative.dev/networking/pkg/http/header\"\n)\n\nvar errUnsupportedMetricType = errors.New(\"unsupported metric type\")\n\ntype httpScrapeClient struct {\n\thttpClient *http.Client\n}\n\ntype scrapeError struct {\n\terror\n\tmightBeMesh bool\n}\n\nvar pool = sync.Pool{\n\tNew: func() interface{} {\n\t\treturn new(bytes.Buffer)\n\t},\n}\n\nfunc newHTTPScrapeClient(httpClient *http.Client) *httpScrapeClient {\n\treturn &httpScrapeClient{\n\t\thttpClient: httpClient,\n\t}\n}\n\nfunc (c *httpScrapeClient) Do(req *http.Request) (Stat, error) {\n\treq.Header.Add(\"Accept\", netheader.ProtobufMIMEType)\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn emptyStat, err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode < http.StatusOK || resp.StatusCode >= http.StatusMultipleChoices {\n\t\treturn emptyStat, scrapeError{\n\t\t\terror:       fmt.Errorf(\"GET request for URL %q returned HTTP status %v\", req.URL.String(), resp.StatusCode),\n\t\t\tmightBeMesh: nethttp.IsPotentialMeshErrorResponse(resp),\n\t\t}\n\t}\n\tif resp.Header.Get(\"Content-Type\") != netheader.ProtobufMIMEType {\n\t\treturn emptyStat, errUnsupportedMetricType\n\t}\n\treturn statFromProto(resp.Body)\n}\n\n// isPotentialMeshError returns whether the error encountered during scraping\n// is compatible with having been caused by the mesh being enabled.\nfunc isPotentialMeshError(err error) bool {\n\tvar se scrapeError\n\treturn errors.As(err, &se) && se.mightBeMesh\n}\n\nfunc statFromProto(body io.Reader) (Stat, error) {\n\tvar stat Stat\n\tb := pool.Get().(*bytes.Buffer)\n\tb.Reset()\n\tdefer pool.Put(b)\n\t// 6 8-byte fields (+2 bytes marshalling), one hostname, 20 bytes extra space\n\tr := io.LimitedReader{R: body, N: 6*10 + 256 + 20}\n\t_, err := b.ReadFrom(&r)\n\tif err != nil {\n\t\treturn emptyStat, fmt.Errorf(\"reading body failed: %w\", err)\n\t}\n\terr = stat.Unmarshal(b.Bytes())\n\tif err != nil {\n\t\treturn emptyStat, fmt.Errorf(\"unmarshalling failed: %w\", err)\n\t}\n\treturn stat, nil\n}\n", "/*\nCopyright 2019 The Knative Authors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage metrics\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\tnetheader \"knative.dev/networking/pkg/http/header\"\n)\n\nconst (\n\tqueueAverageConcurrentRequests        = 3.0\n\tqueueRequestsPerSecond                = 5\n\tqueueAverageProxiedConcurrentRequests = 2.0\n\tqueueProxiedOperationsPerSecond       = 4\n\tprocessUptime                         = 2937.12\n\tpodName                               = \"test-revision-1234\"\n)\n\nvar (\n\ttestURL = \"http://test-revision-zhudex.test-namespace:9090/metrics\"\n\n\tstat = Stat{\n\t\tPodName:                          podName,\n\t\tAverageConcurrentRequests:        queueAverageConcurrentRequests,\n\t\tAverageProxiedConcurrentRequests: queueAverageProxiedConcurrentRequests,\n\t\tRequestCount:                     queueRequestsPerSecond,\n\t\tProxiedRequestCount:              queueProxiedOperationsPerSecond,\n\t\tProcessUptime:                    processUptime,\n\t}\n)\n\nfunc TestHTTPScrapeClientScrapeHappyCaseWithOptionals(t *testing.T) {\n\thClient := newTestHTTPClient(makeProtoResponse(http.StatusOK, stat, netheader.ProtobufMIMEType), nil)\n\tsClient := newHTTPScrapeClient(hClient)\n\treq, err := http.NewRequest(http.MethodGet, testURL, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create a request: %v\", err)\n\t}\n\tgot, err := sClient.Do(req)\n\tif err != nil {\n\t\tt.Fatalf(\"Scrape = %v, want no error\", err)\n\t}\n\tif !cmp.Equal(got, stat) {\n\t\tt.Errorf(\"Scraped stat mismatch; diff(-want,+got):\\n%s\", cmp.Diff(stat, got))\n\t}\n}\n\nfunc TestHTTPScrapeClientScrapeProtoErrorCases(t *testing.T) {\n\ttestCases := []struct {\n\t\tname            string\n\t\tresponseCode    int\n\t\tresponseType    string\n\t\tresponseErr     error\n\t\tstat            Stat\n\t\texpectedErr     string\n\t\texpectedMeshErr bool\n\t}{{\n\t\tname:         \"Non 200 return code\",\n\t\tresponseCode: http.StatusForbidden,\n\t\texpectedErr:  fmt.Sprintf(\"GET request for URL %q returned HTTP status 403\", testURL),\n\t}, {\n\t\tname:            \"503 return code\",\n\t\tresponseCode:    http.StatusServiceUnavailable,\n\t\texpectedErr:     fmt.Sprintf(\"GET request for URL %q returned HTTP status 503\", testURL),\n\t\texpectedMeshErr: true,\n\t}, {\n\t\tname:         \"Error got when sending request\",\n\t\tresponseCode: http.StatusOK,\n\t\tresponseErr:  errors.New(\"upstream closed\"),\n\t\texpectedErr:  \"upstream closed\",\n\t}, {\n\t\tname:         \"Wrong Content-Type\",\n\t\tresponseCode: http.StatusOK,\n\t\tresponseType: \"text/html\",\n\t\texpectedErr:  errUnsupportedMetricType.Error(),\n\t}, {\n\t\tname:         \"LongStat\",\n\t\tresponseCode: http.StatusOK,\n\t\tresponseType: \"application/protobuf\",\n\t\tstat: Stat{\n\t\t\t// We don't expect PodName to be 600 characters long\n\t\t\tPodName:                          strings.Repeat(\"a123456789\", 60),\n\t\t\tAverageConcurrentRequests:        1.1,\n\t\t\tAverageProxiedConcurrentRequests: 1.1,\n\t\t\tRequestCount:                     33.2,\n\t\t\tProxiedRequestCount:              33.2,\n\t\t\tProcessUptime:                    12345.678,\n\t\t\tTimestamp:                        1697431278,\n\t\t},\n\t\texpectedErr: \"unmarshalling failed: unexpected EOF\",\n\t}}\n\n\tfor _, test := range testCases {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\thClient := newTestHTTPClient(makeProtoResponse(test.responseCode, test.stat, test.responseType), test.responseErr)\n\t\t\tsClient := newHTTPScrapeClient(hClient)\n\t\t\treq, err := http.NewRequest(http.MethodGet, testURL, nil)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to create a request: %v\", err)\n\t\t\t}\n\t\t\t_, err = sClient.Do(req)\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(\"Got no error\")\n\t\t\t}\n\t\t\tif !strings.Contains(err.Error(), test.expectedErr) {\n\t\t\t\tt.Errorf(\"Error = %q, want to contain: %q\", err.Error(), test.expectedErr)\n\t\t\t}\n\t\t\tif got := isPotentialMeshError(err); got != test.expectedMeshErr {\n\t\t\t\tt.Errorf(\"isMeshError(err) = %v, expected %v\", got, test.expectedMeshErr)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc makeProtoResponse(statusCode int, stat Stat, contentType string) *http.Response {\n\tbuffer, _ := stat.Marshal()\n\tres := &http.Response{\n\t\tStatusCode: statusCode,\n\t\tBody:       io.NopCloser(bytes.NewBuffer(buffer)),\n\t}\n\tres.Header = http.Header{}\n\tres.Header.Set(\"Content-Type\", contentType)\n\treturn res\n}\n\ntype fakeRoundTripper struct {\n\tresponse      *http.Response\n\tresponseError error\n}\n\nfunc (frt fakeRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {\n\treturn frt.response, frt.responseError\n}\n\nfunc newTestHTTPClient(response *http.Response, err error) *http.Client {\n\treturn &http.Client{\n\t\tTransport: fakeRoundTripper{\n\t\t\tresponse:      response,\n\t\t\tresponseError: err,\n\t\t},\n\t}\n}\n\nfunc BenchmarkUnmarshallingProtoData(b *testing.B) {\n\tstat := Stat{\n\t\tProcessUptime:                    12.2,\n\t\tAverageConcurrentRequests:        2.3,\n\t\tAverageProxiedConcurrentRequests: 100.2,\n\t\tRequestCount:                     122,\n\t\tProxiedRequestCount:              122,\n\t}\n\n\tbenchmarks := []struct {\n\t\tname    string\n\t\tpodName string\n\t}{{\n\t\tname:    \"BenchmarkStatWithEmptyPodName\",\n\t\tpodName: \"\",\n\t}, {\n\t\tname:    \"BenchmarkStatWithSmallPodName\",\n\t\tpodName: \"a-lzrjc-deployment-85d4b7d859-gspjs\",\n\t}, {\n\t\tname:    \"BenchmarkStatWithMediumPodName\",\n\t\tpodName: \"a-lzrjc-deployment-85d4b7d859-gspjs\" + strings.Repeat(\"p\", 50),\n\t}, {\n\t\tname:    \"BenchmarkStatWithLargePodName\",\n\t\tpodName: strings.Repeat(\"p\", 253),\n\t}}\n\tfor _, bm := range benchmarks {\n\t\tstat.PodName = bm.podName\n\t\tbodyBytes, err := stat.Marshal()\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tb.Run(bm.name, func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_, err = statFromProto(bytes.NewReader(bodyBytes))\n\t\t\t\tif err != nil {\n\t\t\t\t\tb.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n"], "filenames": ["pkg/autoscaler/metrics/http_scrape_client.go", "pkg/autoscaler/metrics/http_scrape_client_test.go"], "buggy_code_start_loc": [85, 97], "buggy_code_end_loc": [86, 97], "fixing_code_start_loc": [85, 98], "fixing_code_end_loc": [88, 113], "type": "NVD-CWE-noinfo", "message": "Knative Serving builds on Kubernetes to support deploying and serving of applications and functions as serverless containers. An attacker who controls a pod to a degree where they can control the responses from the /metrics endpoint can cause Denial-of-Service of the autoscaler from an unbound memory allocation bug. This is a DoS vulnerability, where a non-privileged Knative user can cause a DoS for the cluster. This issue has been patched in version 0.39.0.", "other": {"cve": {"id": "CVE-2023-48713", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-28T04:15:07.820", "lastModified": "2023-12-01T21:53:20.687", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Knative Serving builds on Kubernetes to support deploying and serving of applications and functions as serverless containers. An attacker who controls a pod to a degree where they can control the responses from the /metrics endpoint can cause Denial-of-Service of the autoscaler from an unbound memory allocation bug. This is a DoS vulnerability, where a non-privileged Knative user can cause a DoS for the cluster. This issue has been patched in version 0.39.0."}, {"lang": "es", "value": "Knative Serving se basa en Kubernetes para admitir la implementaci\u00f3n y el servicio de aplicaciones y funciones como contenedores sin servidor. Un atacante que controla un pod hasta un punto en el que pueda controlar las respuestas desde el endpoint /metrics puede provocar una Denegaci\u00f3n de Servicio del escalador autom\u00e1tico debido a un error de asignaci\u00f3n de memoria independiente. Esta es una vulnerabilidad DoS, donde un usuario de Knative sin privilegios puede provocar un DoS para el cl\u00faster. Este problema se solucion\u00f3 en la versi\u00f3n 0.39.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:knative:serving:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.5", "matchCriteriaId": "F83BBBFD-C622-41D7-BE6A-D7BA52B6B2D2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:knative:serving:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.11.0", "versionEndExcluding": "1.11.3", "matchCriteriaId": "3672D2F9-C70C-4FC1-8992-B8EB42F755BB"}]}]}], "references": [{"url": "https://github.com/knative/serving/commit/012ee2509231b80b7842139bfabc30516d3026ca", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/knative/serving/commit/101f814112b9ca0767f457e7e616b46205551cf1", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/knative/serving/commit/fff40ef7bac9be8380ec3d1c70fc15b57093382a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/knative/serving/security/advisories/GHSA-qmvj-4qr9-v547", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/knative/serving/commit/012ee2509231b80b7842139bfabc30516d3026ca"}}