{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Scene Management sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include <gpac/nodes_mpeg4.h>\n#include <gpac/internal/swf_dev.h>\n#include <gpac/avparse.h>\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\n\n#include <zlib.h>\n\nenum\n{\n\tSWF_END = 0,\n\tSWF_SHOWFRAME = 1,\n\tSWF_DEFINESHAPE = 2,\n\tSWF_FREECHARACTER = 3,\n\tSWF_PLACEOBJECT = 4,\n\tSWF_REMOVEOBJECT = 5,\n\tSWF_DEFINEBITS = 6,\n\tSWF_DEFINEBITSJPEG = 6,\n\tSWF_DEFINEBUTTON = 7,\n\tSWF_JPEGTABLES = 8,\n\tSWF_SETBACKGROUNDCOLOR = 9,\n\tSWF_DEFINEFONT = 10,\n\tSWF_DEFINETEXT = 11,\n\tSWF_DOACTION = 12,\n\tSWF_DEFINEFONTINFO = 13,\n\tSWF_DEFINESOUND = 14,\n\tSWF_STARTSOUND = 15,\n\tSWF_DEFINEBUTTONSOUND = 17,\n\tSWF_SOUNDSTREAMHEAD = 18,\n\tSWF_SOUNDSTREAMBLOCK = 19,\n\tSWF_DEFINEBITSLOSSLESS = 20,\n\tSWF_DEFINEBITSJPEG2 = 21,\n\tSWF_DEFINESHAPE2 = 22,\n\tSWF_DEFINEBUTTONCXFORM = 23,\n\tSWF_PROTECT = 24,\n\tSWF_PLACEOBJECT2 = 26,\n\tSWF_REMOVEOBJECT2 = 28,\n\tSWF_DEFINESHAPE3 = 32,\n\tSWF_DEFINETEXT2 = 33,\n\tSWF_DEFINEBUTTON2 = 34,\n\tSWF_DEFINEBITSJPEG3 = 35,\n\tSWF_DEFINEBITSLOSSLESS2 = 36,\n\tSWF_DEFINEEDITTEXT = 37,\n\tSWF_DEFINEMOVIE = 38,\n\tSWF_DEFINESPRITE = 39,\n\tSWF_NAMECHARACTER = 40,\n\tSWF_SERIALNUMBER = 41,\n\tSWF_GENERATORTEXT = 42,\n\tSWF_FRAMELABEL = 43,\n\tSWF_SOUNDSTREAMHEAD2 = 45,\n\tSWF_DEFINEMORPHSHAPE = 46,\n\tSWF_DEFINEFONT2 = 48,\n\tSWF_TEMPLATECOMMAND = 49,\n\tSWF_GENERATOR3 = 51,\n\tSWF_EXTERNALFONT = 52,\n\tSWF_EXPORTASSETS = 56,\n\tSWF_IMPORTASSETS\t= 57,\n\tSWF_ENABLEDEBUGGER = 58,\n\tSWF_MX0 = 59,\n\tSWF_MX1 = 60,\n\tSWF_MX2 = 61,\n\tSWF_MX3 = 62,\n\tSWF_MX4 = 63,\n\tSWF_REFLEX = 777\n};\n\n\nstatic void swf_init_decompress(SWFReader *read)\n{\n\tu32 size, dst_size;\n\tuLongf destLen;\n\tchar *src, *dst;\n\n\tsize = (u32) gf_bs_get_size(read->bs)-8;\n\tif (gf_bs_get_size(read->bs) - 8 >= (u64)1<<31) {\n\t\tgf_bs_del(read->bs);\n\t\tread->bs = NULL;\n\t\treturn;\n\t}\n\tdst_size = read->length;\n\tsrc = gf_malloc(sizeof(char)*size);\n\tdst = gf_malloc(sizeof(char)*dst_size);\n\tmemset(dst, 0, sizeof(char)*8);\n\tgf_bs_read_data(read->bs, src, size);\n\tdst_size -= 8;\n\tdestLen = (uLongf)dst_size;\n\tuncompress((Bytef *) dst+8, &destLen, (Bytef *) src, size);\n\tdst_size += 8;\n\tgf_free(src);\n\tread->mem = dst;\n\tgf_bs_del(read->bs);\n\tread->bs = gf_bs_new(read->mem, dst_size, GF_BITSTREAM_READ);\n\tgf_bs_skip_bytes(read->bs, 8);\n}\n\n\nstatic GF_Err swf_seek_file_to(SWFReader *read, u32 size)\n{\n\treturn gf_bs_seek(read->bs, size);\n}\n\nstatic u32 swf_get_file_pos(SWFReader *read)\n{\n\treturn (u32) gf_bs_get_position(read->bs);\n}\n\nstatic u32 swf_read_data(SWFReader *read, char *data, u32 data_size)\n{\n\treturn gf_bs_read_data(read->bs, data, data_size);\n}\n\nstatic u32 swf_read_int(SWFReader *read, u32 nbBits)\n{\n\treturn gf_bs_read_int(read->bs, nbBits);\n}\n\nstatic s32 swf_read_sint(SWFReader *read, u32 nbBits)\n{\n\tu32 r = 0;\n\tu32 i;\n\tif (!nbBits)return 0;\n\tr = swf_read_int(read, 1) ? 0xFFFFFFFF : 0;\n\tfor (i=1; i<nbBits; i++) {\n\t\tr <<= 1;\n\t\tr |= swf_read_int(read, 1);\n\t}\n\treturn (s32) r;\n}\n\nstatic u32 swf_align(SWFReader *read)\n{\n\treturn gf_bs_align(read->bs);\n}\n\nstatic void swf_skip_data(SWFReader *read, u32 size)\n{\n\twhile (size && !read->ioerr) {\n\t\tswf_read_int(read, 8);\n\t\tsize --;\n\t}\n}\n\nstatic void swf_get_rec(SWFReader *read, SWFRec *rc)\n{\n\tu32 nbbits;\n\tswf_align(read);\n\tnbbits = swf_read_int(read, 5);\n\trc->x = FLT2FIX( swf_read_sint(read, nbbits) * SWF_TWIP_SCALE );\n\trc->w = FLT2FIX( swf_read_sint(read, nbbits) * SWF_TWIP_SCALE );\n\trc->w -= rc->x;\n\trc->y = FLT2FIX( swf_read_sint(read, nbbits) * SWF_TWIP_SCALE );\n\trc->h = FLT2FIX( swf_read_sint(read, nbbits) * SWF_TWIP_SCALE );\n\trc->h -= rc->y;\n}\n\nstatic u32 swf_get_32(SWFReader *read)\n{\n\tu32 val, res;\n\tval = swf_read_int(read, 32);\n\tres = (val&0xFF);\n\tres <<=8;\n\tres |= ((val>>8)&0xFF);\n\tres<<=8;\n\tres |= ((val>>16)&0xFF);\n\tres<<=8;\n\tres|= ((val>>24)&0xFF);\n\treturn res;\n}\n\nstatic u16 swf_get_16(SWFReader *read)\n{\n\tu16 val, res;\n\tval = swf_read_int(read, 16);\n\tres = (val&0xFF);\n\tres <<=8;\n\tres |= ((val>>8)&0xFF);\n\treturn res;\n}\n\nstatic s16 swf_get_s16(SWFReader *read)\n{\n\ts16 val;\n\tu8 v1;\n\tv1 = swf_read_int(read, 8);\n\tval = swf_read_sint(read, 8);\n\tval = (val<<8)&0xFF00;\n\tval |= (v1&0xFF);\n\treturn val;\n}\n\nstatic u32 swf_get_color(SWFReader *read)\n{\n\tu32 res;\n\tres = 0xFF00;\n\tres |= swf_read_int(read, 8);\n\tres<<=8;\n\tres |= swf_read_int(read, 8);\n\tres<<=8;\n\tres |= swf_read_int(read, 8);\n\treturn res;\n}\n\nstatic u32 swf_get_argb(SWFReader *read)\n{\n\tu32 res, al;\n\tres = swf_read_int(read, 8);\n\tres<<=8;\n\tres |= swf_read_int(read, 8);\n\tres<<=8;\n\tres |= swf_read_int(read, 8);\n\tal = swf_read_int(read, 8);\n\treturn ((al<<24) | res);\n}\n\nstatic u32 swf_get_matrix(SWFReader *read, GF_Matrix2D *mat)\n{\n\tu32 bits_read;\n\tu32 flag, nb_bits;\n\n\tmemset(mat, 0, sizeof(GF_Matrix2D));\n\tmat->m[0] = mat->m[4] = FIX_ONE;\n\n\tbits_read = swf_align(read);\n\n\tflag = swf_read_int(read, 1);\n\tbits_read += 1;\n\tif (flag) {\n\t\tnb_bits = swf_read_int(read, 5);\n#ifdef GPAC_FIXED_POINT\n\t\tmat->m[0] = swf_read_sint(read, nb_bits);\n\t\tmat->m[4] = swf_read_sint(read, nb_bits);\n#else\n\t\tmat->m[0] = (Float) swf_read_sint(read, nb_bits);\n\t\tmat->m[0] /= 0x10000;\n\t\tmat->m[4] = (Float) swf_read_sint(read, nb_bits);\n\t\tmat->m[4] /= 0x10000;\n#endif\n\t\tbits_read += 5 + 2*nb_bits;\n\t}\n\tflag = swf_read_int(read, 1);\n\tbits_read += 1;\n\tif (flag) {\n\t\tnb_bits = swf_read_int(read, 5);\n\t\t/*WATCHOUT FOR ORDER*/\n#ifdef GPAC_FIXED_POINT\n\t\tmat->m[3] = swf_read_sint(read, nb_bits);\n\t\tmat->m[1] = swf_read_sint(read, nb_bits);\n#else\n\t\tmat->m[3] = (Float) swf_read_sint(read, nb_bits);\n\t\tmat->m[3] /= 0x10000;\n\t\tmat->m[1] = (Float) swf_read_sint(read, nb_bits);\n\t\tmat->m[1] /= 0x10000;\n#endif\n\t\tbits_read += 5 + 2*nb_bits;\n\t}\n\tnb_bits = swf_read_int(read, 5);\n\tbits_read += 5 + 2*nb_bits;\n\tif (nb_bits) {\n\t\tmat->m[2] = FLT2FIX( swf_read_sint(read, nb_bits) * SWF_TWIP_SCALE );\n\t\tmat->m[5] = FLT2FIX( swf_read_sint(read, nb_bits) * SWF_TWIP_SCALE );\n\t}\n\treturn bits_read;\n}\n\n#define SWF_COLOR_SCALE\t\t\t\t(1/256.0f)\n\nstatic void swf_get_colormatrix(SWFReader *read, GF_ColorMatrix *cmat)\n{\n\tBool has_add, has_mul;\n\tu32 nbbits;\n\tmemset(cmat, 0, sizeof(GF_ColorMatrix));\n\tcmat->m[0] = cmat->m[6] = cmat->m[12] = cmat->m[18] = FIX_ONE;\n\n\thas_add = swf_read_int(read, 1);\n\thas_mul = swf_read_int(read, 1);\n\tnbbits = swf_read_int(read, 4);\n\tif (has_mul) {\n\t\tcmat->m[0] = FLT2FIX( swf_read_sint(read, nbbits) * SWF_COLOR_SCALE );\n\t\tcmat->m[6] = FLT2FIX( swf_read_sint(read, nbbits) * SWF_COLOR_SCALE );\n\t\tcmat->m[12] = FLT2FIX( swf_read_sint(read, nbbits) * SWF_COLOR_SCALE );\n\t\tcmat->m[18] = FLT2FIX( swf_read_sint(read, nbbits) * SWF_COLOR_SCALE );\n\t}\n\tif (has_add) {\n\t\tcmat->m[4] = FLT2FIX( swf_read_sint(read, nbbits) * SWF_COLOR_SCALE );\n\t\tcmat->m[9] = FLT2FIX( swf_read_sint(read, nbbits) * SWF_COLOR_SCALE );\n\t\tcmat->m[14] = FLT2FIX( swf_read_sint(read, nbbits) * SWF_COLOR_SCALE );\n\t\tcmat->m[19] = FLT2FIX( swf_read_sint(read, nbbits) * SWF_COLOR_SCALE );\n\t}\n\tcmat->identity = 0;\n\tif ((cmat->m[0] == cmat->m[6])\n\t        && (cmat->m[0] == cmat->m[12])\n\t        && (cmat->m[0] == cmat->m[18])\n\t        && (cmat->m[0] == FIX_ONE)\n\t        && (cmat->m[4] == cmat->m[9])\n\t        && (cmat->m[4] == cmat->m[14])\n\t        && (cmat->m[4] == cmat->m[19])\n\t        && (cmat->m[4] == 0))\n\t\tcmat->identity = 1;\n}\n\nstatic char *swf_get_string(SWFReader *read)\n{\n\tchar szName[1024];\n\tchar *name;\n\tu32 i = 0;\n\n\tif (read->size>1024) {\n\t\tname = gf_malloc(sizeof(char)*read->size);\n\t} else {\n\t\tname = szName;\n\t}\n\twhile (1) {\n\t\tif (i>=read->size) {\n\t\t\tread->ioerr = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tbreak;\n\t\t}\n\t\tname[i] = swf_read_int(read, 8);\n\t\tif (!name[i]) break;\n\t\ti++;\n\t}\n\tif (read->size>1024) {\n\t\treturn gf_realloc(name, sizeof(char)*(strlen(name)+1));\n\t} else {\n\t\treturn gf_strdup(szName);\n\t}\n}\n\nstatic SWFShapeRec *swf_new_shape_rec()\n{\n\tSWFShapeRec *style;\n\tGF_SAFEALLOC(style, SWFShapeRec);\n\tif (!style) return NULL;\n\tGF_SAFEALLOC(style->path, SWFPath);\n\tif (!style->path) {\n\t\tgf_free(style);\n\t\treturn NULL;\n\t}\n\treturn style;\n}\n\nstatic SWFShapeRec *swf_clone_shape_rec(SWFShapeRec *old_sr)\n{\n\tSWFShapeRec *new_sr = (SWFShapeRec *)gf_malloc(sizeof(SWFShapeRec));\n\tmemcpy(new_sr, old_sr, sizeof(SWFShapeRec));\n\tnew_sr->path = (SWFPath*)gf_malloc(sizeof(SWFPath));\n\tmemset(new_sr->path, 0, sizeof(SWFPath));\n\n\tif (old_sr->nbGrad) {\n\t\tnew_sr->grad_col = (u32*)gf_malloc(sizeof(u32) * old_sr->nbGrad);\n\t\tmemcpy(new_sr->grad_col, old_sr->grad_col, sizeof(u32) * old_sr->nbGrad);\n\t\tnew_sr->grad_ratio = (u8*)gf_malloc(sizeof(u8) * old_sr->nbGrad);\n\t\tmemcpy(new_sr->grad_ratio, old_sr->grad_ratio, sizeof(u8) * old_sr->nbGrad);\n\t}\n\treturn new_sr;\n}\n\n/*parse/append fill and line styles*/\nstatic void swf_parse_styles(SWFReader *read, u32 revision, SWFShape *shape, u32 *bits_fill, u32 *bits_line)\n{\n\tu32 i, j, count;\n\tSWFShapeRec *style;\n\n\tswf_align(read);\n\n\t/*get fill styles*/\n\tcount = swf_read_int(read, 8);\n\tif (revision && (count== 0xFF)) count = swf_get_16(read);\n\tif (count) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tstyle = swf_new_shape_rec();\n\n\t\t\tstyle->solid_col = 0xFF00FF00;\n\t\t\tstyle->type = swf_read_int(read, 8);\n\n\t\t\t/*gradient fill*/\n\t\t\tif (style->type & 0x10) {\n\t\t\t\tswf_get_matrix(read, &style->mat);\n\t\t\t\tswf_align(read);\n\t\t\t\tstyle->nbGrad = swf_read_int(read, 8);\n\t\t\t\tif (style->nbGrad) {\n\t\t\t\t\tstyle->grad_col = (u32 *) gf_malloc(sizeof(u32) * style->nbGrad);\n\t\t\t\t\tstyle->grad_ratio = (u8 *) gf_malloc(sizeof(u8) * style->nbGrad);\n\t\t\t\t\tfor (j=0; j<style->nbGrad; j++) {\n\t\t\t\t\t\tstyle->grad_ratio[j] = swf_read_int(read, 8);\n\t\t\t\t\t\tif (revision==2) style->grad_col[j] = swf_get_argb(read);\n\t\t\t\t\t\telse style->grad_col[j] = swf_get_color(read);\n\t\t\t\t\t}\n\t\t\t\t\tstyle->solid_col = style->grad_col[0];\n\n\t\t\t\t\t/*make sure we have keys between 0 and 1.0 for BIFS (0 and 255 in swf)*/\n\t\t\t\t\tif (style->grad_ratio[0] != 0) {\n\t\t\t\t\t\tu32 *grad_col;\n\t\t\t\t\t\tu8 *grad_ratio;\n\t\t\t\t\t\tgrad_ratio = (u8 *) gf_malloc(sizeof(u8) * (style->nbGrad+1));\n\t\t\t\t\t\tgrad_col = (u32 *) gf_malloc(sizeof(u32) * (style->nbGrad+1));\n\t\t\t\t\t\tgrad_col[0] = style->grad_col[0];\n\t\t\t\t\t\tgrad_ratio[0] = 0;\n\t\t\t\t\t\tfor (j=0; j<style->nbGrad; j++) {\n\t\t\t\t\t\t\tgrad_col[j+1] = style->grad_col[j];\n\t\t\t\t\t\t\tgrad_ratio[j+1] = style->grad_ratio[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_free(style->grad_col);\n\t\t\t\t\t\tstyle->grad_col = grad_col;\n\t\t\t\t\t\tgf_free(style->grad_ratio);\n\t\t\t\t\t\tstyle->grad_ratio = grad_ratio;\n\t\t\t\t\t\tstyle->nbGrad++;\n\t\t\t\t\t}\n\t\t\t\t\tif (style->grad_ratio[style->nbGrad-1] != 255) {\n\t\t\t\t\t\tu32 *grad_col = (u32*)gf_malloc(sizeof(u32) * (style->nbGrad+1));\n\t\t\t\t\t\tu8 *grad_ratio = (u8*)gf_malloc(sizeof(u8) * (style->nbGrad+1));\n\t\t\t\t\t\tmemcpy(grad_col, style->grad_col, sizeof(u32) * style->nbGrad);\n\t\t\t\t\t\tmemcpy(grad_ratio, style->grad_ratio, sizeof(u8) * style->nbGrad);\n\t\t\t\t\t\tgrad_col[style->nbGrad] = style->grad_col[style->nbGrad-1];\n\t\t\t\t\t\tgrad_ratio[style->nbGrad] = 255;\n\t\t\t\t\t\tgf_free(style->grad_col);\n\t\t\t\t\t\tstyle->grad_col = grad_col;\n\t\t\t\t\t\tgf_free(style->grad_ratio);\n\t\t\t\t\t\tstyle->grad_ratio = grad_ratio;\n\t\t\t\t\t\tstyle->nbGrad++;\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tstyle->solid_col = 0xFF;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*bitmap fill*/\n\t\t\telse if (style->type & 0x40) {\n\t\t\t\tstyle->img_id = swf_get_16(read);\n\t\t\t\tif (style->img_id == 65535) {\n\t\t\t\t\tstyle->img_id = 0;\n\t\t\t\t\tstyle->type = 0;\n\t\t\t\t\tstyle->solid_col = 0xFF00FFFF;\n\t\t\t\t}\n\t\t\t\tswf_get_matrix(read, &style->mat);\n\t\t\t}\n\t\t\t/*solid fill*/\n\t\t\telse {\n\t\t\t\tif (revision==2) style->solid_col = swf_get_argb(read);\n\t\t\t\telse style->solid_col = swf_get_color(read);\n\t\t\t}\n\t\t\tgf_list_add(shape->fill_right, style);\n\t\t\tstyle = swf_clone_shape_rec(style);\n\t\t\tgf_list_add(shape->fill_left, style);\n\t\t}\n\t}\n\n\tswf_align(read);\n\t/*get line styles*/\n\tcount = swf_read_int(read, 8);\n\tif (revision && (count==0xFF)) count = swf_get_16(read);\n\tif (count) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tstyle = swf_new_shape_rec();\n\t\t\tgf_list_add(shape->lines, style);\n\t\t\tstyle->width = FLT2FIX( swf_get_16(read) * SWF_TWIP_SCALE );\n\t\t\tif (revision==2) style->solid_col = swf_get_argb(read);\n\t\t\telse style->solid_col = swf_get_color(read);\n\t\t}\n\t}\n\n\tswf_align(read);\n\t*bits_fill = swf_read_int(read, 4);\n\t*bits_line = swf_read_int(read, 4);\n}\n\nstatic void swf_path_realloc_pts(SWFPath *path, u32 nbPts)\n{\n\tif (path)\n\t\tpath->pts = (SFVec2f*)gf_realloc(path->pts, sizeof(SFVec2f) * (path->nbPts + nbPts));\n}\n\nstatic void swf_path_add_com(SWFShapeRec *sr, SFVec2f pt, SFVec2f ctr, u32 type)\n{\n\t/*not an error*/\n\tif (!sr) return;\n\n\tsr->path->types = (u32*)gf_realloc(sr->path->types, sizeof(u32) * (sr->path->nbType+1));\n\n\tsr->path->types[sr->path->nbType] = type;\n\tswitch (type) {\n\tcase 2:\n\t\tswf_path_realloc_pts(sr->path, 2);\n\t\tsr->path->pts[sr->path->nbPts] = ctr;\n\t\tsr->path->pts[sr->path->nbPts+1] = pt;\n\t\tsr->path->nbPts+=2;\n\t\tbreak;\n\tcase 1:\n\tdefault:\n\t\tswf_path_realloc_pts(sr->path, 1);\n\t\tsr->path->pts[sr->path->nbPts] = pt;\n\t\tsr->path->nbPts++;\n\t\tbreak;\n\t}\n\tsr->path->nbType++;\n}\n\nstatic void swf_referse_path(SWFPath *path)\n{\n\tu32 i, j, pti, ptj;\n\tu32 *types;\n\tSFVec2f *pts;\n\n\tif (path->nbType<=1) return;\n\n\ttypes = (u32 *) gf_malloc(sizeof(u32) * path->nbType);\n\tpts = (SFVec2f *) gf_malloc(sizeof(SFVec2f) * path->nbPts);\n\n\n\t/*need first moveTo*/\n\ttypes[0] = 0;\n\tpts[0] = path->pts[path->nbPts - 1];\n\tpti = path->nbPts - 2;\n\tptj = 1;\n\tj=1;\n\n\tfor (i=0; i<path->nbType-1; i++) {\n\t\ttypes[j] = path->types[path->nbType - i - 1];\n\t\tswitch (types[j]) {\n\t\tcase 2:\n\t\t\tassert(ptj<=path->nbPts-2);\n\t\t\tpts[ptj] = path->pts[pti];\n\t\t\tpts[ptj+1] = path->pts[pti-1];\n\t\t\tpti-=2;\n\t\t\tptj+=2;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tassert(ptj<=path->nbPts-1);\n\t\t\tpts[ptj] = path->pts[pti];\n\t\t\tpti--;\n\t\t\tptj++;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tassert(ptj<=path->nbPts-1);\n\t\t\tpts[ptj] = path->pts[pti];\n\t\t\tpti--;\n\t\t\tptj++;\n\t\t\tbreak;\n\t\t}\n\t\tj++;\n\t}\n\tgf_free(path->pts);\n\tpath->pts = pts;\n\tgf_free(path->types);\n\tpath->types = types;\n}\n\nstatic void swf_free_shape_rec(SWFShapeRec *ptr)\n{\n\tif (ptr->grad_col) gf_free(ptr->grad_col);\n\tif (ptr->grad_ratio) gf_free(ptr->grad_ratio);\n\tif (ptr->path) {\n\t\tif (ptr->path->pts) gf_free(ptr->path->pts);\n\t\tif (ptr->path->types) gf_free(ptr->path->types);\n\t\tif (ptr->path->idx) gf_free(ptr->path->idx);\n\t\tgf_free(ptr->path);\n\t}\n\tgf_free(ptr);\n}\n\nstatic void swf_reset_rec_list(GF_List *recs)\n{\n\twhile (gf_list_count(recs)) {\n\t\tSWFShapeRec *tmp = (SWFShapeRec *)gf_list_get(recs, 0);\n\t\tgf_list_rem(recs, 0);\n\t\tswf_free_shape_rec(tmp);\n\t}\n}\n\nstatic void swf_append_path(SWFPath *a, SWFPath *b)\n{\n\tif (b->nbType<=1) return;\n\n\ta->pts = (SFVec2f*)gf_realloc(a->pts, sizeof(SFVec2f) * (a->nbPts + b->nbPts));\n\tmemcpy(&a->pts[a->nbPts], b->pts, sizeof(SFVec2f)*b->nbPts);\n\ta->nbPts += b->nbPts;\n\n\ta->types = (u32*)gf_realloc(a->types, sizeof(u32)*(a->nbType+ b->nbType));\n\tmemcpy(&a->types[a->nbType], b->types, sizeof(u32)*b->nbType);\n\ta->nbType += b->nbType;\n}\n\nstatic void swf_path_add_type(SWFPath *path, u32 val)\n{\n\tpath->types = (u32*)gf_realloc(path->types, sizeof(u32) * (path->nbType + 1));\n\tpath->types[path->nbType] = val;\n\tpath->nbType++;\n}\n\nstatic void swf_resort_path(SWFPath *a, SWFReader *read)\n{\n\tu32 idx, i, j;\n\tGF_List *paths;\n\tSWFPath *sorted, *p, *np;\n\n\tif (!a->nbType) return;\n\n\tpaths = gf_list_new();\n\tGF_SAFEALLOC(sorted, SWFPath);\n\tif (!sorted) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[SWF Parsing] Fail to allocate path for resorting\\n\"));\n\t\treturn;\n\t}\n\tswf_path_realloc_pts(sorted, 1);\n\tsorted->pts[sorted->nbPts] = a->pts[0];\n\tsorted->nbPts++;\n\tswf_path_add_type(sorted, 0);\n\tgf_list_add(paths, sorted);\n\n\t/*1- split all paths*/\n\tidx = 1;\n\tfor (i=1; i<a->nbType; i++) {\n\t\tswitch (a->types[i]) {\n\t\tcase 2:\n\t\t\tswf_path_realloc_pts(sorted, 2);\n\t\t\tsorted->pts[sorted->nbPts] = a->pts[idx];\n\t\t\tsorted->pts[sorted->nbPts+1] = a->pts[idx+1];\n\t\t\tsorted->nbPts+=2;\n\t\t\tswf_path_add_type(sorted, 2);\n\t\t\tidx += 2;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tswf_path_realloc_pts(sorted, 1);\n\t\t\tsorted->pts[sorted->nbPts] = a->pts[idx];\n\t\t\tsorted->nbPts+=1;\n\t\t\tswf_path_add_type(sorted, 1);\n\t\t\tidx += 1;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tGF_SAFEALLOC(sorted , SWFPath);\n\t\t\tif (!sorted) return;\n\t\t\tswf_path_realloc_pts(sorted, 1);\n\t\t\tsorted->pts[sorted->nbPts] = a->pts[idx];\n\t\t\tsorted->nbPts++;\n\t\t\tswf_path_add_type(sorted, 0);\n\t\t\tgf_list_add(paths, sorted);\n\t\t\tidx += 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\nrestart:\n\tfor (i=0; i<gf_list_count(paths); i++) {\n\t\tp = (SWFPath*)gf_list_get(paths, i);\n\n\t\tfor (j=i+1; j < gf_list_count(paths); j++) {\n\t\t\tnp = (SWFPath*)gf_list_get(paths, j);\n\n\t\t\t/*check if any next subpath ends at the same place we're starting*/\n\t\t\tif ((np->pts[np->nbPts-1].x == p->pts[0].x) && (np->pts[np->nbPts-1].y == p->pts[0].y)) {\n\t\t\t\tu32 k;\n\t\t\t\tidx = 1;\n\t\t\t\tfor (k=1; k<p->nbType; k++) {\n\t\t\t\t\tswitch (p->types[k]) {\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tswf_path_realloc_pts(np, 2);\n\t\t\t\t\t\tnp->pts[np->nbPts] = p->pts[idx];\n\t\t\t\t\t\tnp->pts[np->nbPts+1] = p->pts[idx+1];\n\t\t\t\t\t\tnp->nbPts+=2;\n\t\t\t\t\t\tswf_path_add_type(np, 2);\n\t\t\t\t\t\tidx += 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tswf_path_realloc_pts(np, 1);\n\t\t\t\t\t\tnp->pts[np->nbPts] = p->pts[idx];\n\t\t\t\t\t\tnp->nbPts+=1;\n\t\t\t\t\t\tswf_path_add_type(np, 1);\n\t\t\t\t\t\tidx += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tassert(0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_free(p->pts);\n\t\t\t\tgf_free(p->types);\n\t\t\t\tgf_free(p);\n\t\t\t\tgf_list_rem(paths, i);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\t/*check if any next subpath starts at the same place we're ending*/\n\t\t\telse if ((p->pts[p->nbPts-1].x == np->pts[0].x) && (p->pts[p->nbPts-1].y == np->pts[0].y)) {\n\t\t\t\tu32 k;\n\t\t\t\tidx = 1;\n\t\t\t\tfor (k=1; k<np->nbType; k++) {\n\t\t\t\t\tswitch (np->types[k]) {\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tswf_path_realloc_pts(p, 2);\n\t\t\t\t\t\tp->pts[p->nbPts] = np->pts[idx];\n\t\t\t\t\t\tp->pts[p->nbPts+1] = np->pts[idx+1];\n\t\t\t\t\t\tp->nbPts+=2;\n\t\t\t\t\t\tswf_path_add_type(p, 2);\n\t\t\t\t\t\tidx += 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tswf_path_realloc_pts(p, 1);\n\t\t\t\t\t\tp->pts[p->nbPts] = np->pts[idx];\n\t\t\t\t\t\tp->nbPts+=1;\n\t\t\t\t\t\tswf_path_add_type(p, 1);\n\t\t\t\t\t\tidx += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tassert(0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_free(np->pts);\n\t\t\t\tgf_free(np->types);\n\t\t\t\tgf_free(np);\n\t\t\t\tgf_list_rem(paths, j);\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*reassemble path*/\n\tgf_free(a->pts);\n\tgf_free(a->types);\n\tmemset(a, 0, sizeof(SWFPath));\n\n\twhile (gf_list_count(paths)) {\n\t\tsorted = (SWFPath*)gf_list_get(paths, 0);\n\t\tif (read->flat_limit==0) {\n\t\t\tswf_append_path(a, sorted);\n\t\t} else {\n\t\t\tBool prev_is_line_to = 0;\n\t\t\tidx = 0;\n\t\t\tfor (i=0; i<sorted->nbType; i++) {\n\t\t\t\tswitch (sorted->types[i]) {\n\t\t\t\tcase 2:\n\t\t\t\t\tswf_path_realloc_pts(a, 2);\n\t\t\t\t\ta->pts[a->nbPts] = sorted->pts[idx];\n\t\t\t\t\ta->pts[a->nbPts+1] = sorted->pts[idx+1];\n\t\t\t\t\ta->nbPts+=2;\n\t\t\t\t\tswf_path_add_type(a, 2);\n\t\t\t\t\tidx += 2;\n\t\t\t\t\tprev_is_line_to = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tif (prev_is_line_to) {\n\t\t\t\t\t\tFixed angle;\n\t\t\t\t\t\tBool flatten = 0;\n\t\t\t\t\t\tSFVec2f v1, v2;\n\t\t\t\t\t\tv1.x = a->pts[a->nbPts-1].x - a->pts[a->nbPts-2].x;\n\t\t\t\t\t\tv1.y = a->pts[a->nbPts-1].y - a->pts[a->nbPts-2].y;\n\t\t\t\t\t\tv2.x = a->pts[a->nbPts-1].x - sorted->pts[idx].x;\n\t\t\t\t\t\tv2.y = a->pts[a->nbPts-1].y - sorted->pts[idx].y;\n\n\t\t\t\t\t\tangle = gf_mulfix(v1.x,v2.x) + gf_mulfix(v1.y,v2.y);\n\t\t\t\t\t\t/*get magnitudes*/\n\t\t\t\t\t\tv1.x = gf_v2d_len(&v1);\n\t\t\t\t\t\tv2.x = gf_v2d_len(&v2);\n\t\t\t\t\t\tif (!v1.x || !v2.x) flatten = 1;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tFixed h_pi = GF_PI / 2;\n\t\t\t\t\t\t\tangle = gf_divfix(angle, gf_mulfix(v1.x, v2.x));\n\t\t\t\t\t\t\tif (angle + FIX_EPSILON >= FIX_ONE) angle = 0;\n\t\t\t\t\t\t\telse if (angle - FIX_EPSILON <= -FIX_ONE) angle = GF_PI;\n\t\t\t\t\t\t\telse angle = gf_acos(angle);\n\n\t\t\t\t\t\t\tif (angle<0) angle += h_pi;\n\t\t\t\t\t\t\tangle = ABSDIFF(angle, h_pi);\n\t\t\t\t\t\t\tif (angle < read->flat_limit) flatten = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flatten) {\n\t\t\t\t\t\t\ta->pts[a->nbPts-1] = sorted->pts[idx];\n\t\t\t\t\t\t\tidx++;\n\t\t\t\t\t\t\tread->flatten_points++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswf_path_realloc_pts(a, 1);\n\t\t\t\t\ta->pts[a->nbPts] = sorted->pts[idx];\n\t\t\t\t\ta->nbPts+=1;\n\t\t\t\t\tswf_path_add_type(a, 1);\n\t\t\t\t\tidx += 1;\n\t\t\t\t\tprev_is_line_to = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0:\n\t\t\t\t\tswf_path_realloc_pts(a, 1);\n\t\t\t\t\ta->pts[a->nbPts] = sorted->pts[idx];\n\t\t\t\t\ta->nbPts+=1;\n\t\t\t\t\tswf_path_add_type(a, 0);\n\t\t\t\t\tidx += 1;\n\t\t\t\t\tprev_is_line_to = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgf_free(sorted->pts);\n\t\tgf_free(sorted->types);\n\t\tgf_free(sorted);\n\t\tgf_list_rem(paths, 0);\n\t}\n\tgf_list_del(paths);\n}\n\n/*\n\tNotes on SWF->BIFS conversion - some ideas taken from libswfdec\n\tA single fillStyle has 2 associated path, one used for left fill, one for right fill\n\tThis is then a 4 step process:\n\t1- blindly parse swf shape, and add point/lines to the proper left/right path\n\t2- for each fillStyles, revert the right path so that it becomes a left path\n\t3- concatenate left and right paths\n\t4- resort all subelements of the final path, making sure moveTo introduced by the SWF coding (due to style changes)\n\tare removed.\n\t\tEx: if path is\n\t\t\tA->C, B->A, C->B = moveTo(A), lineTo(C), moveTo(B), lineTo (A), moveTo(C), lineTo(B)\n\t\twe restort and remove unneeded moves to get\n\t\t\tA->C->B = moveTo(A), lineTo(C), lineTo(B), lineTo(A)\n*/\nstatic GF_Err swf_flush_shape(SWFReader *read, SWFShape *shape, SWFFont *font, Bool last_shape)\n{\n\tGF_Err e;\n\tSWFShapeRec *sf0;\n\tu32 i, count;\n\tcount = gf_list_count(shape->fill_left);\n\tfor (i=0; i<count; i++) {\n\t\tSWFShapeRec *sf1;\n\t\tsf0 = (SWFShapeRec*)gf_list_get(shape->fill_left, i);\n\t\tsf1 = (SWFShapeRec*)gf_list_get(shape->fill_right, i);\n\t\t/*reverse right path*/\n\t\tswf_referse_path(sf1->path);\n\t\t/*concatenate with left path*/\n\t\tswf_append_path(sf0->path, sf1->path);\n\t\t/*resort all path curves*/\n\t\tswf_resort_path(sf0->path, read);\n\t}\n\t/*remove dummy fill_left*/\n\tfor (i=0; i<gf_list_count(shape->fill_left); i++) {\n\t\tsf0 = (SWFShapeRec*)gf_list_get(shape->fill_left, i);\n\t\tif (sf0->path->nbType<=1) {\n\t\t\tgf_list_rem(shape->fill_left, i);\n\t\t\tswf_free_shape_rec(sf0);\n\t\t\ti--;\n\t\t}\n\t}\n\t/*remove dummy lines*/\n\tfor (i=0; i<gf_list_count(shape->lines); i++) {\n\t\tSWFShapeRec *sl = (SWFShapeRec*)gf_list_get(shape->lines, i);\n\t\tif (sl->path->nbType<1) {\n\t\t\tgf_list_rem(shape->lines, i);\n\t\t\tswf_free_shape_rec(sl);\n\t\t\ti--;\n\t\t} else {\n\t\t\tswf_resort_path(sl->path, read);\n\t\t}\n\t}\n\n\t/*now translate a flash shape record into BIFS*/\n\te = read->define_shape(read, shape, font, last_shape);\n\n\t/*delete shape*/\n\tswf_reset_rec_list(shape->fill_left);\n\tswf_reset_rec_list(shape->fill_right);\n\tswf_reset_rec_list(shape->lines);\n\treturn e;\n}\n\nstatic GF_Err swf_parse_shape_def(SWFReader *read, SWFFont *font, u32 revision)\n{\n\tu32 nbBits, comType;\n\ts32 x, y;\n\tSFVec2f orig, ctrl, end;\n\tBool flag;\n\tu32 fill0, fill1, strike;\n\tu32 bits_fill, bits_line;\n\tSWFShape shape;\n\tBool is_empty;\n\tSWFShapeRec *sf0, *sf1, *sl;\n\n\tmemset(&shape, 0, sizeof(SWFShape));\n\tshape.fill_left = gf_list_new();\n\tshape.fill_right = gf_list_new();\n\tshape.lines = gf_list_new();\n\tctrl.x = ctrl.y = 0;\n\tswf_align(read);\n\n\t/*regular shape - get initial styles*/\n\tif (!font) {\n\t\tshape.ID = swf_get_16(read);\n\t\tswf_get_rec(read, &shape.rc);\n\t\tswf_parse_styles(read, revision, &shape, &bits_fill, &bits_line);\n\t}\n\t/*glyph*/\n\telse {\n\t\tbits_fill = swf_read_int(read, 4);\n\t\tbits_line = swf_read_int(read, 4);\n\n\t\t/*fonts are usually defined without styles*/\n\t\tif ((read->tag == SWF_DEFINEFONT) || (read->tag==SWF_DEFINEFONT2)) {\n\t\t\tsf0 = swf_new_shape_rec();\n\t\t\tgf_list_add(shape.fill_right, sf0);\n\t\t\tsf0 = swf_new_shape_rec();\n\t\t\tgf_list_add(shape.fill_left, sf0);\n\t\t\tsf0->solid_col = 0xFF000000;\n\t\t\tsf0->type = 0;\n\t\t}\n\t}\n\n\tis_empty = 1;\n\n\t/*parse all points*/\n\tfill0 = fill1 = strike = 0;\n\tsf0 = sf1 = sl = NULL;\n\tx = y = 0;\n\twhile (1) {\n\t\tflag = swf_read_int(read, 1);\n\t\tif (!flag) {\n\t\t\tBool new_style = swf_read_int(read, 1);\n\t\t\tBool set_strike = swf_read_int(read, 1);\n\t\t\tBool set_fill1 = swf_read_int(read, 1);\n\t\t\tBool set_fill0 = swf_read_int(read, 1);\n\t\t\tBool move_to = swf_read_int(read, 1);\n\t\t\t/*end of shape*/\n\t\t\tif (!new_style && !set_strike && !set_fill0 && !set_fill1 && !move_to) break;\n\n\t\t\tis_empty = 0;\n\n\t\t\tif (move_to) {\n\t\t\t\tnbBits = swf_read_int(read, 5);\n\t\t\t\tx = swf_read_sint(read, nbBits);\n\t\t\t\ty = swf_read_sint(read, nbBits);\n\t\t\t}\n\t\t\tif (set_fill0) fill0 = swf_read_int(read, bits_fill);\n\t\t\tif (set_fill1) fill1 = swf_read_int(read, bits_fill);\n\t\t\tif (set_strike) strike = swf_read_int(read, bits_line);\n\t\t\t/*looks like newStyle does not append styles but define a new set - old styles can no\n\t\t\tlonger be referenced*/\n\t\t\tif (new_style) {\n\t\t\t\t/*flush current shape record into BIFS*/\n\t\t\t\tswf_flush_shape(read, &shape, font, 0);\n\t\t\t\tswf_parse_styles(read, revision, &shape, &bits_fill, &bits_line);\n\t\t\t}\n\n\t\t\tif (read->flags & GF_SM_SWF_NO_LINE) strike = 0;\n\n\t\t\t/*moveto*/\n\t\t\torig.x = FLT2FIX( x * SWF_TWIP_SCALE );\n\t\t\torig.y = FLT2FIX( y * SWF_TWIP_SCALE );\n\t\t\tend = orig;\n\n\t\t\tsf0 = fill0 ? (SWFShapeRec*)gf_list_get(shape.fill_left, fill0 - 1) : NULL;\n\t\t\tsf1 = fill1 ? (SWFShapeRec*)gf_list_get(shape.fill_right, fill1 - 1) : NULL;\n\t\t\tsl = strike ? (SWFShapeRec*)gf_list_get(shape.lines, strike - 1) : NULL;\n\n\t\t\tif (move_to) {\n\t\t\t\tswf_path_add_com(sf0, end, ctrl, 0);\n\t\t\t\tswf_path_add_com(sf1, end, ctrl, 0);\n\t\t\t\tswf_path_add_com(sl, end, ctrl, 0);\n\t\t\t} else {\n\t\t\t\tif (set_fill0) swf_path_add_com(sf0, end, ctrl, 0);\n\t\t\t\tif (set_fill1) swf_path_add_com(sf1, end, ctrl, 0);\n\t\t\t\tif (set_strike) swf_path_add_com(sl, end, ctrl, 0);\n\t\t\t}\n\n\t\t} else {\n\t\t\tflag = swf_read_int(read, 1);\n\t\t\t/*quadratic curve*/\n\t\t\tif (!flag) {\n\t\t\t\tnbBits = 2 + swf_read_int(read, 4);\n\t\t\t\tx += swf_read_sint(read, nbBits);\n\t\t\t\ty += swf_read_sint(read, nbBits);\n\t\t\t\tctrl.x = FLT2FIX( x * SWF_TWIP_SCALE );\n\t\t\t\tctrl.y = FLT2FIX( y * SWF_TWIP_SCALE );\n\t\t\t\tx += swf_read_sint(read, nbBits);\n\t\t\t\ty += swf_read_sint(read, nbBits);\n\t\t\t\tend.x = FLT2FIX( x * SWF_TWIP_SCALE );\n\t\t\t\tend.y = FLT2FIX( y * SWF_TWIP_SCALE );\n\t\t\t\t/*curveTo*/\n\t\t\t\tcomType = 2;\n\t\t\t}\n\t\t\t/*straight line*/\n\t\t\telse {\n\t\t\t\tnbBits = 2 + swf_read_int(read, 4);\n\t\t\t\tflag = swf_read_int(read, 1);\n\t\t\t\tif (flag) {\n\t\t\t\t\tx += swf_read_sint(read, nbBits);\n\t\t\t\t\ty += swf_read_sint(read, nbBits);\n\t\t\t\t} else {\n\t\t\t\t\tflag = swf_read_int(read, 1);\n\t\t\t\t\tif (flag) {\n\t\t\t\t\t\ty += swf_read_sint(read, nbBits);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx += swf_read_sint(read, nbBits);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*lineTo*/\n\t\t\t\tcomType = 1;\n\t\t\t\tend.x = FLT2FIX( x * SWF_TWIP_SCALE );\n\t\t\t\tend.y = FLT2FIX( y * SWF_TWIP_SCALE );\n\t\t\t}\n\t\t\tswf_path_add_com(sf0, end, ctrl, comType);\n\t\t\tswf_path_add_com(sf1, end, ctrl, comType);\n\t\t\tswf_path_add_com(sl, end, ctrl, comType);\n\t\t}\n\t}\n\n\tif (is_empty) {\n\t\tswf_reset_rec_list(shape.fill_left);\n\t\tswf_reset_rec_list(shape.fill_right);\n\t\tswf_reset_rec_list(shape.lines);\n\t}\n\n\tswf_align(read);\n\n\t/*now translate a flash shape record*/\n\tswf_flush_shape(read, &shape, font, 1);\n\n\t/*delete shape*/\n\tswf_reset_rec_list(shape.fill_left);\n\tswf_reset_rec_list(shape.fill_right);\n\tswf_reset_rec_list(shape.lines);\n\tgf_list_del(shape.fill_left);\n\tgf_list_del(shape.fill_right);\n\tgf_list_del(shape.lines);\n\n\treturn GF_OK;\n}\n\nSWFFont *swf_find_font(SWFReader *read, u32 ID)\n{\n\tu32 i, count;\n\tcount = gf_list_count(read->fonts);\n\tfor (i=0; i<count; i++) {\n\t\tSWFFont *ft = (SWFFont *)gf_list_get(read->fonts, i);\n\t\tif (ft->fontID==ID) return ft;\n\t}\n\treturn NULL;\n}\n\nstatic DispShape *swf_get_depth_entry(SWFReader *read, u32 Depth, Bool create)\n{\n\tu32 i;\n\tDispShape *tmp;\n\ti=0;\n\twhile ((tmp = (DispShape *)gf_list_enum(read->display_list, &i))) {\n\t\tif (tmp->depth == Depth) return tmp;\n\t}\n\tif (!create) return NULL;\n\tGF_SAFEALLOC(tmp , DispShape);\n\tif (!tmp) return NULL;\n\ttmp->depth = Depth;\n\ttmp->char_id = 0;\n\tgf_list_add(read->display_list, tmp);\n\n\tmemset(&tmp->mat, 0, sizeof(GF_Matrix2D));\n\ttmp->mat.m[0] = tmp->mat.m[4] = FIX_ONE;\n\n\tmemset(&tmp->cmat, 0, sizeof(GF_ColorMatrix));\n\ttmp->cmat.m[0] = tmp->cmat.m[6] = tmp->cmat.m[12] = tmp->cmat.m[18] = FIX_ONE;\n\ttmp->cmat.identity = 1;\n\treturn tmp;\n}\n\n\nstatic GF_Err swf_func_skip(SWFReader *read)\n{\n\tif (!read) return GF_OK;\n\tswf_skip_data(read, read->size);\n\treturn read->ioerr;\n}\n\nstatic GF_Err swf_set_backcol(SWFReader *read)\n{\n\tu32 col = swf_get_color(read);\n\treturn read->set_backcol(read, col);\n}\n\nstatic GF_Err swf_actions(SWFReader *read, u32 mask, u32 key)\n{\n\tu32 skip_actions = 0;\n\tu8 action_code = swf_read_int(read, 8);\n\tread->has_interact = 1;\n\n\n#define DO_ACT(_code) { act.type = _code; read->action(read, &act); break; }\n\n\twhile (action_code) {\n\t\tu16 length;\n\t\tif (action_code > 0x80) length = swf_get_16(read);\n\t\telse length = 0;\n\n\t\tif (read->no_as || skip_actions) {\n\t\t\tswf_skip_data(read, length);\n\t\t\tif (skip_actions) skip_actions--;\n\t\t} else {\n\t\t\tSWFAction act;\n\t\t\tmemset(&act, 0, sizeof(SWFAction));\n\t\t\tact.button_mask = mask;\n\t\t\tact.button_key = key;\n\n\t\t\tswitch (action_code) {\n\t\t\t/* SWF 3 Action Model */\n\t\t\tcase 0x81: /* goto frame */\n\t\t\t\tact.type = GF_SWF_AS3_GOTO_FRAME;\n\t\t\t\tact.frame_number = swf_get_16(read);\n\t\t\t\tread->action(read, &act);\n\t\t\t\tbreak;\n\t\t\tcase 0x83: /* get URL */\n\t\t\t\tact.type = GF_SWF_AS3_GET_URL;\n\t\t\t\tact.url = swf_get_string(read);\n\t\t\t\tact.target = swf_get_string(read);\n\t\t\t\tread->action(read, &act);\n\t\t\t\tif (act.url) gf_free(act.url);\n\t\t\t\tif (act.target) gf_free(act.target);\n\t\t\t\tbreak;\n\t\t\t/* next frame */\n\t\t\tcase 0x04:\n\t\t\t\tDO_ACT(GF_SWF_AS3_NEXT_FRAME)\n\t\t\t/* previous frame */\n\t\t\tcase 0x05:\n\t\t\t\tDO_ACT(GF_SWF_AS3_PREV_FRAME)\n\t\t\t/* play */\n\t\t\tcase 0x06:\n\t\t\t\tDO_ACT(GF_SWF_AS3_PLAY)\n\t\t\t/* stop */\n\t\t\tcase 0x07:\n\t\t\t\tDO_ACT(GF_SWF_AS3_STOP)\n\t\t\t/* toggle quality */\n\t\t\tcase 0x08:\n\t\t\t\tDO_ACT(GF_SWF_AS3_TOGGLE_QUALITY)\n\t\t\t/* stop sounds*/\n\t\t\tcase 0x09:\n\t\t\t\tDO_ACT(GF_SWF_AS3_STOP_SOUNDS)\n\t\t\t/* wait for frame */\n\t\t\tcase 0x8A:\n\t\t\t\tact.type = GF_SWF_AS3_WAIT_FOR_FRAME;\n\t\t\t\tact.frame_number = swf_get_16(read);\n\t\t\t\tskip_actions = swf_read_int(read, 8);\n\t\t\t\tif (read->action(read, &act)) skip_actions = 0;\n\t\t\t\tbreak;\n\t\t\t/* set target */\n\t\t\tcase 0x8B:\n\t\t\t\tact.type = GF_SWF_AS3_SET_TARGET;\n\t\t\t\tact.target = swf_get_string(read);\n\t\t\t\tread->action(read, &act);\n\t\t\t\tif (act.target) gf_free(act.target);\n\t\t\t\tbreak;\n\t\t\t/* goto label */\n\t\t\tcase 0x8C:\n\t\t\t\tact.type = GF_SWF_AS3_GOTO_LABEL;\n\t\t\t\tact.target = swf_get_string(read);\n\t\t\t\tread->action(read, &act);\n\t\t\t\tif (act.target) gf_free(act.target);\n\t\t\t\tbreak;\n\t\t\tdefault:\n//\t\t\t\tswf_report(read, GF_OK, \"Skipping unsupported action %x\", action_code);\n\t\t\t\tif (length) swf_skip_data(read, length);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (gf_bs_is_overflow(read->bs))\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\taction_code = swf_read_int(read, 8);\n\t}\n#undef DO_ACT\n\n\treturn GF_OK;\n}\n\nstatic GF_Err swf_def_button(SWFReader *read, u32 revision)\n{\n\tSWF_Button button;\n\tBool has_actions;\n\n\tmemset(&button, 0, sizeof(SWF_Button));\n\thas_actions = 0;\n\tbutton.count = 0;\n\tbutton.ID = swf_get_16(read);\n\tif (revision==1) {\n\t\tgf_bs_read_int(read->bs, 7);\n\t\tgf_bs_read_int(read->bs, 1);\n\t\thas_actions = swf_get_16(read);\n\t}\n\twhile (1) {\n\t\tSWF_ButtonRecord *rec = &button.buttons[button.count];\n\t\tgf_bs_read_int(read->bs, 4);\n\t\trec->hitTest = gf_bs_read_int(read->bs, 1);\n\t\trec->down = gf_bs_read_int(read->bs, 1);\n\t\trec->over = gf_bs_read_int(read->bs, 1);\n\t\trec->up = gf_bs_read_int(read->bs, 1);\n\t\tif (!rec->hitTest && !rec->up && !rec->over && !rec->down) break;\n\t\trec->character_id = swf_get_16(read);\n\t\trec->depth = swf_get_16(read);\n\t\tswf_get_matrix(read, &rec->mx);\n\t\tif (revision==1) {\n\t\t\tswf_align(read);\n\t\t\tswf_get_colormatrix(read, &rec->cmx);\n\t\t}\n\t\telse gf_cmx_init(&rec->cmx);\n\t\tgf_bs_align(read->bs);\n\t\tbutton.count++;\n\t\tif (button.count>=40) return GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tread->define_button(read, &button);\n\tif (revision==0) {\n\t\tswf_actions(read, GF_SWF_COND_OVERUP_TO_OVERDOWN, 0);\n\t} else {\n\t\twhile (has_actions) {\n\t\t\tu32 i, mask, key;\n\t\t\thas_actions = swf_get_16(read);\n\t\t\tmask = 0;\n\t\t\tfor (i=0; i<8; i++) {\n\t\t\t\tif (swf_read_int(read, 1))\n\t\t\t\t\tmask |= 1<<i;\n\t\t\t}\n\t\t\tkey = swf_read_int(read, 7);\n\t\t\tif (swf_read_int(read, 1))\n\t\t\t\tmask |= GF_SWF_COND_OVERDOWN_TO_IDLE;\n\n\t\t\tswf_actions(read, mask, key);\n\t\t}\n\t}\n\tread->define_button(read, NULL);\n\treturn GF_OK;\n}\n\nstatic Bool swf_mat_is_identity(GF_Matrix2D *mat)\n{\n\tif (mat->m[0] != FIX_ONE) return 0;\n\tif (mat->m[4] != FIX_ONE) return 0;\n\tif (mat->m[1]) return 0;\n\tif (mat->m[2]) return 0;\n\tif (mat->m[3]) return 0;\n\tif (mat->m[5]) return 0;\n\treturn 1;\n}\n\nstatic GF_Err swf_place_obj(SWFReader *read, u32 revision)\n{\n\tGF_Err e;\n\tu32 shape_id;\n\tu32 ID, bitsize;\n\tu32 clip_depth;\n\tGF_Matrix2D mat;\n\tGF_ColorMatrix cmat;\n\tDispShape *ds;\n\tchar *name;\n\tu32 depth, type;\n\tBool had_depth;\n\t/*SWF flags*/\n\tBool has_clip_actions, has_clip, has_name, has_ratio, has_cmat, has_mat, has_id, has_move;\n\n\tname = NULL;\n\tclip_depth = 0;\n\tID = 0;\n\tdepth = 0;\n\thas_cmat = has_mat = has_move = 0;\n\n\tgf_cmx_init(&cmat);\n\tgf_mx2d_init(mat);\n\t/*place*/\n\ttype = SWF_PLACE;\n\n\t/*SWF 1.0*/\n\tif (revision==0) {\n\t\tID = swf_get_16(read);\n\t\tdepth = swf_get_16(read);\n\t\tbitsize = 32;\n\t\tbitsize += swf_get_matrix(read, &mat);\n\t\thas_mat = 1;\n\t\tbitsize += swf_align(read);\n\t\t/*size exceeds matrix, parse col mat*/\n\t\tif (bitsize < read->size*8) {\n\t\t\tswf_get_colormatrix(read, &cmat);\n\t\t\thas_cmat = 1;\n\t\t\tswf_align(read);\n\t\t}\n\t}\n\t/*SWF 3.0*/\n\telse if (revision==1) {\n\t\t/*reserved*/\n\t\thas_clip_actions = swf_read_int(read, 1);\n\t\thas_clip = swf_read_int(read, 1);\n\t\thas_name = swf_read_int(read, 1);\n\t\thas_ratio = swf_read_int(read, 1);\n\t\thas_cmat = swf_read_int(read, 1);\n\t\thas_mat = swf_read_int(read, 1);\n\t\thas_id = swf_read_int(read, 1);\n\t\thas_move = swf_read_int(read, 1);\n\n\t\tdepth = swf_get_16(read);\n\t\tif (has_id) ID = swf_get_16(read);\n\t\tif (has_mat) {\n\t\t\tswf_get_matrix(read, &mat);\n\t\t\tswf_align(read);\n\t\t}\n\t\tif (has_cmat) {\n\t\t\tswf_align(read);\n\t\t\tswf_get_colormatrix(read, &cmat);\n\t\t\tswf_align(read);\n\t\t}\n\t\tif (has_ratio) /*ratio = */swf_get_16(read);\n\t\tif (has_clip) clip_depth = swf_get_16(read);\n\n\t\tif (has_name) {\n\t\t\tname = swf_get_string(read);\n\t\t\tgf_free(name);\n\t\t}\n\t\tif (has_clip_actions) {\n\t\t\tswf_get_16(read);\n\t\t\tswf_get_16(read);\n\t\t}\n\t\t/*replace*/\n\t\tif (has_id && has_move) type = SWF_REPLACE;\n\t\t/*move*/\n\t\telse if (!has_id && has_move) type = SWF_MOVE;\n\t\t/*place*/\n\t\telse type = SWF_PLACE;\n\t}\n\n\tif (clip_depth) {\n\t\tswf_report(read, GF_NOT_SUPPORTED, \"Clipping not supported - ignoring\");\n\t\treturn GF_OK;\n\t}\n\n\t/*1: check depth of display list*/\n\thad_depth = read->allocate_depth(read, depth);\n\t/*check validity*/\n\tif ((type==SWF_MOVE) && !had_depth) swf_report(read, GF_BAD_PARAM, \"Accessing empty depth level %d\", depth);\n\n\tds = NULL;\n\n\t/*usual case: (re)place depth level*/\n\tswitch (type) {\n\tcase SWF_MOVE:\n\t\tds = swf_get_depth_entry(read, depth, 0);\n\t\tshape_id = ds ? ds->char_id : 0;\n\t\tbreak;\n\tcase SWF_REPLACE:\n\tcase SWF_PLACE:\n\tdefault:\n\t\tshape_id = ID;\n\t\tbreak;\n\t}\n\n\tif (!shape_id) {\n\t\tswf_report(read, GF_BAD_PARAM, \"%s unfound object (ID %d)\", (type==SWF_MOVE) ? \"Moving\" : ((type==SWF_PLACE) ? \"Placing\" : \"Replacing\"), ID);\n\t\treturn GF_OK;\n\t}\n\t/*restore prev matrix if needed*/\n\tif (type==SWF_REPLACE) {\n\t\tif (!ds) ds = swf_get_depth_entry(read, depth, 0);\n\t\tif (ds) {\n\t\t\tif (!has_mat) {\n\t\t\t\tmemcpy(&mat, &ds->mat, sizeof(GF_Matrix2D));\n\t\t\t\thas_mat = 1;\n\t\t\t}\n\t\t\tif (!has_cmat) {\n\t\t\t\tmemcpy(&cmat, &ds->cmat, sizeof(GF_ColorMatrix));\n\t\t\t\thas_cmat = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*check for identity matrices*/\n\tif (has_cmat && cmat.identity) has_cmat = 0;\n\tif (has_mat && swf_mat_is_identity(&mat)) has_mat = 0;\n\n\t/*store in display list*/\n\tds = swf_get_depth_entry(read, depth, 1);\n\te = read->place_obj(read, depth, shape_id, ds->char_id, type,\n\t                    has_mat ? &mat : NULL,\n\t                    has_cmat ? &cmat : NULL,\n\t                    swf_mat_is_identity(&ds->mat) ? NULL : &ds->mat,\n\t                    ds->cmat.identity ? NULL : &ds->cmat);\n\n\t/*remember matrices*/\n\tmemcpy(&ds->mat, &mat, sizeof(GF_Matrix2D));\n\tmemcpy(&ds->cmat, &cmat, sizeof(GF_ColorMatrix));\n\tds->char_id = shape_id;\n\n\tif (e) swf_report(read, e, \"Error %s object ID %d\", (type==SWF_MOVE) ? \"Moving\" : ((type==SWF_PLACE) ? \"Placing\" : \"Replacing\"), shape_id);\n\treturn GF_OK;\n}\n\nstatic GF_Err swf_remove_obj(SWFReader *read, u32 revision)\n{\n\tGF_Err e;\n\tDispShape *ds;\n\tu32 depth;\n\tif (revision==0) swf_get_16(read);\n\tdepth = swf_get_16(read);\n\tds = swf_get_depth_entry(read, depth, 0);\n\t/*this happens if a placeObject has failed*/\n\tif (!ds) return GF_OK;\n\te = read->remove_obj(read, depth, ds->char_id);\n\tds->char_id = 0;\n\treturn e;\n}\n\nstatic GF_Err swf_show_frame(SWFReader *read)\n{\n\tGF_Err e;\n\te = read->show_frame(read);\n\tread->current_frame ++;\n\treturn e;\n}\n\nstatic GF_Err swf_def_font(SWFReader *read, u32 revision)\n{\n\tu32 i, count;\n\tGF_Err e;\n\tSWFFont *ft;\n\tu32 *offset_table = NULL;\n\tu32 start;\n\n\tGF_SAFEALLOC(ft, SWFFont);\n\tif (!ft) return GF_OUT_OF_MEM;\n\n\tft->glyphs = gf_list_new();\n\tft->fontID = swf_get_16(read);\n\te = GF_OK;\n\tgf_list_add(read->fonts, ft);\n\n\tif (revision==0) {\n\t\tstart = swf_get_file_pos(read);\n\n\t\tcount = swf_get_16(read);\n\t\tft->nbGlyphs = count / 2;\n\t\toffset_table = (u32*)gf_malloc(sizeof(u32) * ft->nbGlyphs);\n\t\toffset_table[0] = 0;\n\t\tfor (i=1; i<ft->nbGlyphs; i++) offset_table[i] = swf_get_16(read);\n\n\t\tfor (i=0; i<ft->nbGlyphs; i++) {\n\t\t\tswf_align(read);\n\t\t\te = swf_seek_file_to(read, start + offset_table[i]);\n\t\t\tif (e) break;\n\t\t\tswf_parse_shape_def(read, ft, 0);\n\t\t}\n\t\tgf_free(offset_table);\n\t\tif (e) return e;\n\t} else if (revision==1) {\n\t\tSWFRec rc;\n\t\tBool wide_offset, wide_codes;\n\t\tu32 code_offset, checkpos;\n\t\tft->has_layout = swf_read_int(read, 1);\n\t\tft->has_shiftJIS = swf_read_int(read, 1);\n\t\tft->is_unicode = swf_read_int(read, 1);\n\t\tft->is_ansi = swf_read_int(read, 1);\n\t\twide_offset = swf_read_int(read, 1);\n\t\twide_codes = swf_read_int(read, 1);\n\t\tft->is_italic = swf_read_int(read, 1);\n\t\tft->is_bold = swf_read_int(read, 1);\n\t\tswf_read_int(read, 8);\n\t\tcount = swf_read_int(read, 8);\n\t\tft->fontName = (char*)gf_malloc(sizeof(u8)*count+1);\n\t\tft->fontName[count] = 0;\n\t\tfor (i=0; i<count; i++) ft->fontName[i] = swf_read_int(read, 8);\n\n\t\tft->nbGlyphs = swf_get_16(read);\n\t\tstart = swf_get_file_pos(read);\n\n\t\tif (ft->nbGlyphs) {\n\t\t\toffset_table = (u32*)gf_malloc(sizeof(u32) * ft->nbGlyphs);\n\t\t\tfor (i=0; i<ft->nbGlyphs; i++) {\n\t\t\t\tif (wide_offset) offset_table[i] = swf_get_32(read);\n\t\t\t\telse offset_table[i] = swf_get_16(read);\n\t\t\t}\n\t\t}\n\n\t\tif (wide_offset) {\n\t\t\tcode_offset = swf_get_32(read);\n\t\t} else {\n\t\t\tcode_offset = swf_get_16(read);\n\t\t}\n\n\t\tif (ft->nbGlyphs) {\n\t\t\tfor (i=0; i<ft->nbGlyphs; i++) {\n\t\t\t\tswf_align(read);\n\t\t\t\te = swf_seek_file_to(read, start + offset_table[i]);\n\t\t\t\tif (e) break;\n\n\t\t\t\tswf_parse_shape_def(read, ft, 0);\n\t\t\t}\n\t\t\tgf_free(offset_table);\n\t\t\tif (e) return e;\n\n\t\t\tcheckpos = swf_get_file_pos(read);\n\t\t\tif (checkpos != start + code_offset) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[SWF Parsing] bad code offset in font\\n\"));\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\n\t\t\tft->glyph_codes = (u16*)gf_malloc(sizeof(u16) * ft->nbGlyphs);\n\t\t\tfor (i=0; i<ft->nbGlyphs; i++) {\n\t\t\t\tif (wide_codes) ft->glyph_codes[i] = swf_get_16(read);\n\t\t\t\telse ft->glyph_codes[i] = swf_read_int(read, 8);\n\t\t\t}\n\t\t}\n\t\tif (ft->has_layout) {\n\t\t\tft->ascent = swf_get_s16(read);\n\t\t\tft->descent = swf_get_s16(read);\n\t\t\tft->leading = swf_get_s16(read);\n\t\t\tif (ft->nbGlyphs) {\n\t\t\t\tft->glyph_adv = (s16*)gf_malloc(sizeof(s16) * ft->nbGlyphs);\n\t\t\t\tfor (i=0; i<ft->nbGlyphs; i++) ft->glyph_adv[i] = swf_get_s16(read);\n\t\t\t\tfor (i=0; i<ft->nbGlyphs; i++) swf_get_rec(read, &rc);\n\t\t\t}\n\t\t\t/*kerning info*/\n\t\t\tcount = swf_get_16(read);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tif (wide_codes) {\n\t\t\t\t\tswf_get_16(read);\n\t\t\t\t\tswf_get_16(read);\n\t\t\t\t} else {\n\t\t\t\t\tswf_read_int(read, 8);\n\t\t\t\t\tswf_read_int(read, 8);\n\t\t\t\t}\n\t\t\t\tswf_get_s16(read);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err swf_def_font_info(SWFReader *read)\n{\n\tSWFFont *ft;\n\tBool wide_chars;\n\tu32 i, count;\n\n\ti = swf_get_16(read);\n\tft = swf_find_font(read, i);\n\tif (!ft) {\n\t\tswf_report(read, GF_BAD_PARAM, \"Cannot locate font ID %d\", i);\n\t\treturn GF_BAD_PARAM;\n\t}\n\t/*overwrite font info*/\n\tif (ft->fontName) gf_free(ft->fontName);\n\tcount = swf_read_int(read, 8);\n\tft->fontName = (char*)gf_malloc(sizeof(char) * (count+1));\n\tft->fontName[count] = 0;\n\tfor (i=0; i<count; i++) ft->fontName[i] = swf_read_int(read, 8);\n\tswf_read_int(read, 2);\n\tft->is_unicode = swf_read_int(read, 1);\n\tft->has_shiftJIS = swf_read_int(read, 1);\n\tft->is_ansi = swf_read_int(read, 1);\n\tft->is_italic = swf_read_int(read, 1);\n\tft->is_bold = swf_read_int(read, 1);\n\t/*TODO - this should be remapped to a font data stream, we currently only assume the glyph code\n\ttable is the same as the original font file...*/\n\twide_chars = swf_read_int(read, 1);\n\tif (ft->glyph_codes) gf_free(ft->glyph_codes);\n\tft->glyph_codes = (u16*)gf_malloc(sizeof(u16) * ft->nbGlyphs);\n\n\tfor (i=0; i<ft->nbGlyphs; i++) {\n\t\tif (wide_chars) ft->glyph_codes[i] = swf_get_16(read);\n\t\telse ft->glyph_codes[i] = swf_read_int(read, 8);\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err swf_def_text(SWFReader *read, u32 revision)\n{\n\tSWFRec rc;\n\tSWFText txt;\n\tBool flag;\n\tu32 nbits_adv, nbits_glyph, i, col, fontID, count, font_height;\n\tFixed offX, offY;\n\tGF_Err e;\n\n\ttxt.ID = swf_get_16(read);\n\tswf_get_rec(read, &rc);\n\tswf_get_matrix(read, &txt.mat);\n\ttxt.text = gf_list_new();\n\n\tswf_align(read);\n\tnbits_glyph = swf_read_int(read, 8);\n\tnbits_adv = swf_read_int(read, 8);\n\tfontID = 0;\n\toffX = offY = 0;\n\tfont_height = 0;\n\tcol = 0xFF000000;\n\te = GF_OK;\n\n\twhile (1) {\n\t\tflag = swf_read_int(read, 1);\n\t\t/*regular glyph record*/\n\t\tif (!flag) {\n\t\t\tSWFGlyphRec *gr;\n\t\t\tcount = swf_read_int(read, 7);\n\t\t\tif (!count) break;\n\n\t\t\tif (!fontID) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tswf_report(read, GF_BAD_PARAM, \"Defining text %d without assigning font\", fontID);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tGF_SAFEALLOC(gr, SWFGlyphRec);\n\t\t\tif (!gr) return GF_OUT_OF_MEM;\n\n\t\t\tgf_list_add(txt.text, gr);\n\t\t\tgr->fontID = fontID;\n\t\t\tgr->fontSize = font_height;\n\t\t\tgr->col = col;\n\t\t\tgr->orig_x = offX;\n\t\t\tgr->orig_y = offY;\n\t\t\tgr->nbGlyphs = count;\n\t\t\tgr->indexes = (u32*)gf_malloc(sizeof(u32) * gr->nbGlyphs);\n\t\t\tgr->dx = (Fixed*)gf_malloc(sizeof(Fixed) * gr->nbGlyphs);\n\t\t\tfor (i=0; i<gr->nbGlyphs; i++) {\n\t\t\t\tgr->indexes[i] = swf_read_int(read, nbits_glyph);\n\t\t\t\tgr->dx[i] = FLT2FIX( swf_read_int(read, nbits_adv) * SWF_TWIP_SCALE );\n\t\t\t}\n\t\t\tswf_align(read);\n\t\t}\n\t\t/*text state change*/\n\t\telse {\n\t\t\tBool has_font, has_col, has_y_off, has_x_off;\n\t\t\t/*reserved*/\n\t\t\tswf_read_int(read, 3);\n\t\t\thas_font = swf_read_int(read, 1);\n\t\t\thas_col = swf_read_int(read, 1);\n\t\t\thas_y_off = swf_read_int(read, 1);\n\t\t\thas_x_off = swf_read_int(read, 1);\n\n\t\t\t/*end of rec*/\n\t\t\tif (!has_font && !has_col && !has_y_off && !has_x_off) break;\n\t\t\tif (has_font) fontID = swf_get_16(read);\n\t\t\tif (has_col) {\n\t\t\t\tif (revision==0) col = swf_get_color(read);\n\t\t\t\telse col = swf_get_argb(read);\n\t\t\t}\n\t\t\t/*openSWF spec seems to have wrong order here*/\n\t\t\tif (has_x_off) offX = FLT2FIX( swf_get_s16(read) * SWF_TWIP_SCALE );\n\t\t\tif (has_y_off) offY = FLT2FIX( swf_get_s16(read) * SWF_TWIP_SCALE );\n\t\t\tif (has_font) font_height = swf_get_16(read);\n\t\t}\n\t}\n\n\tif (e) goto exit;\n\n\tif (! (read->flags & GF_SM_SWF_NO_TEXT) ) {\n\t\te = read->define_text(read, &txt);\n\t}\n\nexit:\n\twhile (gf_list_count(txt.text)) {\n\t\tSWFGlyphRec *gr = (SWFGlyphRec *)gf_list_get(txt.text, 0);\n\t\tgf_list_rem(txt.text, 0);\n\t\tif (gr->indexes) gf_free(gr->indexes);\n\t\tif (gr->dx) gf_free(gr->dx);\n\t\tgf_free(gr);\n\t}\n\tgf_list_del(txt.text);\n\n\treturn e;\n}\n\n\nstatic GF_Err swf_def_edit_text(SWFReader *read)\n{\n\tGF_Err e;\n\tSWFEditText txt;\n\tchar *var_name;\n\tBool has_text, has_text_color, has_max_length, has_font;\n\n\tmemset(&txt, 0, sizeof(SWFEditText));\n\ttxt.color = 0xFF000000;\n\n\ttxt.ID = swf_get_16(read);\n\tswf_get_rec(read, &txt.bounds);\n\tswf_align(read);\n\n\thas_text = swf_read_int(read, 1);\n\ttxt.word_wrap = swf_read_int(read, 1);\n\ttxt.multiline = swf_read_int(read, 1);\n\ttxt.password = swf_read_int(read, 1);\n\ttxt.read_only = swf_read_int(read, 1);\n\thas_text_color = swf_read_int(read, 1);\n\thas_max_length = swf_read_int(read, 1);\n\thas_font = swf_read_int(read, 1);\n\t/*reserved*/swf_read_int(read, 1);\n\ttxt.auto_size = swf_read_int(read, 1);\n\ttxt.has_layout = swf_read_int(read, 1);\n\ttxt.no_select = swf_read_int(read, 1);\n\ttxt.border = swf_read_int(read, 1);\n\t/*reserved*/swf_read_int(read, 1);\n\ttxt.html = swf_read_int(read, 1);\n\ttxt.outlines = swf_read_int(read, 1);\n\n\tif (has_font) {\n\t\ttxt.fontID = swf_get_16(read);\n\t\ttxt.font_height = FLT2FIX( swf_get_16(read) * SWF_TWIP_SCALE );\n\t}\n\tif (has_text_color) txt.color = swf_get_argb(read);\n\tif (has_max_length) txt.max_length = FLT2FIX( swf_get_16(read) * SWF_TWIP_SCALE );\n\n\tif (txt.has_layout) {\n\t\ttxt.align = swf_read_int(read, 8);\n\t\ttxt.left = FLT2FIX( swf_get_16(read) * SWF_TWIP_SCALE );\n\t\ttxt.right = FLT2FIX( swf_get_16(read) * SWF_TWIP_SCALE );\n\t\ttxt.indent = FLT2FIX( swf_get_16(read) * SWF_TWIP_SCALE );\n\t\ttxt.leading = FLT2FIX( swf_get_16(read) * SWF_TWIP_SCALE );\n\t}\n\tvar_name = swf_get_string(read);\n\tif (has_text) txt.init_value = swf_get_string(read);\n\n\te = GF_OK;\n\tif (! (read->flags & GF_SM_SWF_NO_TEXT) ) {\n\t\te = read->define_edit_text(read, &txt);\n\t}\n\tgf_free(var_name);\n\tif (txt.init_value) gf_free(txt.init_value);\n\n\treturn e;\n}\n\nstatic void swf_delete_sound_stream(SWFReader *read)\n{\n\tif (!read->sound_stream) return;\n\tif (read->sound_stream->output) gf_fclose(read->sound_stream->output);\n\tif (read->sound_stream->szFileName) gf_free(read->sound_stream->szFileName);\n\tgf_free(read->sound_stream);\n\tread->sound_stream = NULL;\n}\n\nstatic GF_Err swf_def_sprite(SWFReader *read)\n{\n\tGF_Err e;\n\tGF_List *prev_dlist;\n\tu32 frame_count;\n\tBool prev_sprite;\n\tu32 prev_frame, prev_depth;\n\tSWFSound *snd;\n\n\tprev_sprite = read->current_sprite_id;\n\tread->current_sprite_id = swf_get_16(read);\n\tframe_count = swf_get_16(read);\n\n\t/*store frame state*/\n\tprev_frame = read->current_frame;\n\tread->current_frame = 0;\n\t/*store soundStream state*/\n\tsnd = read->sound_stream;\n\tread->sound_stream = NULL;\n\t/*store depth state*/\n\tprev_depth = read->max_depth;\n\tread->max_depth = 0;\n\n\tprev_dlist = read->display_list;\n\tread->display_list = gf_list_new();\n\n\te = read->define_sprite(read, frame_count);\n\tif (e) return e;\n\n\t/*close sprite soundStream*/\n\tswf_delete_sound_stream(read);\n\t/*restore sound stream*/\n\tread->sound_stream = snd;\n\tread->max_depth = prev_depth;\n\n\twhile (gf_list_count(read->display_list)) {\n\t\tDispShape *s = (DispShape *)gf_list_get(read->display_list, 0);\n\t\tgf_list_rem(read->display_list, 0);\n\t\tgf_free(s);\n\t}\n\tgf_list_del(read->display_list);\n\tread->display_list = prev_dlist;\n\n\tread->current_frame = prev_frame;\n\tread->current_sprite_id = prev_sprite;\n\n\tread->tag = SWF_DEFINESPRITE;\n\treturn GF_OK;\n}\n\nstatic GF_Err swf_def_sound(SWFReader *read)\n{\n\tSWFSound *snd;\n\tGF_SAFEALLOC(snd , SWFSound);\n\tif (!snd) return GF_OUT_OF_MEM;\n\tsnd->ID = swf_get_16(read);\n\tsnd->format = swf_read_int(read, 4);\n\tsnd->sound_rate = swf_read_int(read, 2);\n\tsnd->bits_per_sample = swf_read_int(read, 1) ? 16 : 8;\n\tsnd->stereo = swf_read_int(read, 1);\n\tsnd->sample_count = swf_get_32(read);\n\n\tswitch (snd->format) {\n\t/*raw PCM*/\n\tcase 0:\n\t\tswf_report(read, GF_NOT_SUPPORTED, \"Raw PCM Audio not supported\");\n\t\tgf_free(snd);\n\t\tbreak;\n\t/*ADPCM*/\n\tcase 1:\n\t\tswf_report(read, GF_NOT_SUPPORTED, \"AD-PCM Audio not supported\");\n\t\tgf_free(snd);\n\t\tbreak;\n\t/*MP3*/\n\tcase 2:\n\t{\n\t\tchar szName[1024];\n\t\tu32 alloc_size, tot_size;\n\t\tchar *frame;\n\t\tGF_Err e=GF_OK;\n\n\t\tsprintf(szName, \"swf_sound_%d.mp3\", snd->ID);\n\t\tif (read->localPath) {\n\t\t\tsnd->szFileName = (char*)gf_malloc(sizeof(char)*GF_MAX_PATH);\n\t\t\tstrcpy(snd->szFileName, read->localPath);\n\t\t\tstrcat(snd->szFileName, szName);\n\t\t} else {\n\t\t\tsnd->szFileName = gf_strdup(szName);\n\t\t}\n\t\tsnd->output = gf_fopen(snd->szFileName, \"wb\");\n\n\t\talloc_size = 4096;\n\t\tframe = (char*)gf_malloc(sizeof(char)*4096);\n\t\t/*snd->frame_delay_ms =*/ swf_get_16(read);\n\t\tsnd->frame_delay_ms = read->current_frame*1000;\n\t\tsnd->frame_delay_ms /= read->frame_rate;\n\t\ttot_size = 9;\n\t\t/*parse all frames*/\n\t\twhile (tot_size<read->size) {\n\t\t\tu32 toread = read->size - tot_size;\n\t\t\tif (toread>alloc_size) toread = alloc_size;\n\t\t\tswf_read_data(read, frame, toread);\n\t\t\tif (gf_fwrite(frame, sizeof(char)*toread, snd->output) != toread)\n\t\t\t\te = GF_IO_ERR;\n\t\t\ttot_size += toread;\n\t\t}\n\n\t\tgf_free(frame);\n\t\tif (e) {\n\t\t\tgf_free(snd);\n\t\t\treturn e;\n\t\t}\n\t\treturn gf_list_add(read->sounds, snd);\n\t}\n\tcase 3:\n\t\tswf_report(read, GF_NOT_SUPPORTED, \"Unrecognized sound format\");\n\t\tgf_free(snd);\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n\ntypedef struct\n{\n\tu32 sync_flags;\n\tu32 in_point, out_point;\n\tu32 nb_loops;\n} SoundInfo;\n\nstatic SoundInfo swf_skip_soundinfo(SWFReader *read)\n{\n\tSoundInfo si;\n\tu32 sync_flags = swf_read_int(read, 4);\n\tBool has_env = swf_read_int(read, 1);\n\tBool has_loops = swf_read_int(read, 1);\n\tBool has_out_pt = swf_read_int(read, 1);\n\tBool has_in_pt = swf_read_int(read, 1);\n\n\tmemset(&si, 0, sizeof(SoundInfo));\n\tsi.sync_flags = sync_flags;\n\tif (has_in_pt) si.in_point = swf_get_32(read);\n\tif (has_out_pt) si.out_point = swf_get_32(read);\n\tif (has_loops) si.nb_loops = swf_get_16(read);\n\t/*we ignore the envelope*/\n\tif (has_env) {\n\t\tu32 i;\n\t\tu32 nb_ctrl = swf_read_int(read, 8);\n\t\tfor (i=0; i<nb_ctrl; i++) {\n\t\t\tswf_read_int(read, 32);\t/*mark44*/\n\t\t\tswf_read_int(read, 16);\t/*l0*/\n\t\t\tswf_read_int(read, 16);\t/*l1*/\n\t\t}\n\t}\n\treturn si;\n}\n\nstatic SWFSound *sndswf_get_sound(SWFReader *read, u32 ID)\n{\n\tu32 i;\n\tSWFSound *snd;\n\ti=0;\n\twhile ((snd = (SWFSound *)gf_list_enum(read->sounds, &i))) {\n\t\tif (snd->ID==ID) return snd;\n\t}\n\treturn NULL;\n}\n\nstatic GF_Err swf_start_sound(SWFReader *read)\n{\n\tSWFSound *snd;\n\tu32 ID = swf_get_16(read);\n\tSoundInfo si;\n\tsi = swf_skip_soundinfo(read);\n\n\tsnd = sndswf_get_sound(read, ID);\n\tif (!snd) {\n\t\tswf_report(read, GF_BAD_PARAM, \"Cannot find sound with ID %d\", ID);\n\t\treturn GF_OK;\n\t}\n\tif (!snd->is_setup) {\n\t\tGF_Err e = read->setup_sound(read, snd, 0);\n\t\tif (e) return e;\n\t\tsnd->is_setup = 1;\n\t}\n\treturn read->start_sound(read, snd, (si.sync_flags & 0x2) ? 1 : 0);\n}\n\nstatic GF_Err swf_soundstream_hdr(SWFReader *read)\n{\n\tchar szName[1024];\n\tSWFSound *snd;\n\n\tif (read->sound_stream) {\n\t\tswf_report(read, GF_BAD_PARAM, \"More than one sound stream for current timeline!!\");\n\t\treturn swf_func_skip(read);\n\t}\n\n\tGF_SAFEALLOC(snd, SWFSound);\n\tif (!snd) return GF_OUT_OF_MEM;\n\n\t/*rec_mix = */swf_read_int(read, 8);\n\t/*0: uncompressed, 1: ADPCM, 2: MP3*/\n\tsnd->format = swf_read_int(read, 4);\n\t/*0: 5.5k, 1: 11k, 2: 2: 22k, 3: 44k*/\n\tsnd->sound_rate = swf_read_int(read, 2);\n\t/*0: 8 bit, 1: 16 bit*/\n\tsnd->bits_per_sample = swf_read_int(read, 1) ? 16 : 8;\n\t/*0: mono, 8 1: stereo*/\n\tsnd->stereo = swf_read_int(read, 1);\n\t/*samplesperframe hint*/\n\tswf_read_int(read, 16);\n\n\tswitch (snd->format) {\n\t/*raw PCM*/\n\tcase 0:\n\t\tswf_report(read, GF_NOT_SUPPORTED, \"Raw PCM Audio not supported\");\n\t\tgf_free(snd);\n\t\tbreak;\n\t/*ADPCM*/\n\tcase 1:\n\t\tswf_report(read, GF_NOT_SUPPORTED, \"AD-PCM Audio not supported\");\n\t\tgf_free(snd);\n\t\tbreak;\n\t/*MP3*/\n\tcase 2:\n\t\tread->sound_stream = snd;\n\t\tif (read->localPath) {\n\t\t\tsprintf(szName, \"%s/swf_soundstream_%d.mp3\", read->localPath, read->current_sprite_id);\n\t\t} else {\n\t\t\tsprintf(szName, \"swf_soundstream_%d.mp3\", read->current_sprite_id);\n\t\t}\n\t\tread->sound_stream->szFileName = gf_strdup(szName);\n\t\tread->setup_sound(read, read->sound_stream, 0);\n\t\tbreak;\n\tcase 3:\n\t\tswf_report(read, GF_NOT_SUPPORTED, \"Unrecognized sound format\");\n\t\tgf_free(snd);\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err swf_soundstream_block(SWFReader *read)\n{\n#ifdef GPAC_DISABLE_AV_PARSERS\n\treturn swf_func_skip(read);\n#else\n\tunsigned char bytes[4];\n\tu32 hdr, alloc_size, size, tot_size, samplesPerFrame;\n\tchar *frame;\n\tGF_Err e = GF_OK;\n\n\t/*note we're doing only MP3*/\n\tif (!read->sound_stream) return swf_func_skip(read);\n\n\tsamplesPerFrame = swf_get_16(read);\n\t/*delay = */swf_get_16(read);\n\n\tif (!read->sound_stream->is_setup) {\n\n\t\t/*error at setup*/\n\t\tif (!read->sound_stream->output) {\n\t\t\tread->sound_stream->output = gf_fopen(read->sound_stream->szFileName, \"wb\");\n\t\t\tif (!read->sound_stream->output)\n\t\t\t\treturn swf_func_skip(read);\n\t\t}\n\t\t/*store TS of first AU*/\n\t\tread->sound_stream->frame_delay_ms = read->current_frame*1000;\n\t\tread->sound_stream->frame_delay_ms /= read->frame_rate;\n\t\tread->setup_sound(read, read->sound_stream, 1);\n\t\tread->sound_stream->is_setup = 1;\n\t}\n\n\tif (!samplesPerFrame) return GF_OK;\n\n\talloc_size = 1;\n\tframe = (char*)gf_malloc(sizeof(char));\n\ttot_size = 4;\n\t/*parse all frames*/\n\twhile (1) {\n\t\tbytes[0] = swf_read_int(read, 8);\n\t\tbytes[1] = swf_read_int(read, 8);\n\t\tbytes[2] = swf_read_int(read, 8);\n\t\tbytes[3] = swf_read_int(read, 8);\n\t\thdr = GF_4CC(bytes[0], bytes[1], bytes[2], bytes[3]);\n\t\tsize = gf_mp3_frame_size(hdr);\n\t\tif (alloc_size<size-4) {\n\t\t\tframe = (char*)gf_realloc(frame, sizeof(char)*(size-4));\n\t\t\talloc_size = size-4;\n\t\t}\n\t\t/*watchout for truncated framesif */\n\t\tif (tot_size + size >= read->size) size = read->size - tot_size;\n\n\t\tswf_read_data(read, frame, size-4);\n\t\tif (gf_fwrite(bytes, sizeof(char)*4, read->sound_stream->output)!=4) e = GF_IO_ERR;\n\t\tif (gf_fwrite(frame, sizeof(char)*(size-4), read->sound_stream->output) != size-4) e = GF_IO_ERR;\n\t\tif (tot_size + size >= read->size) break;\n\t\ttot_size += size;\n\t}\n\tgf_free(frame);\n\treturn e;\n#endif\n}\n\nstatic GF_Err swf_def_hdr_jpeg(SWFReader *read)\n{\n\tif (!read) return GF_OK;\n\tif (read->jpeg_hdr) {\n\t\tswf_report(read, GF_NON_COMPLIANT_BITSTREAM, \"JPEG Table already defined in file\");\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tread->jpeg_hdr_size = read->size;\n\tif (read->size) {\n\t\tread->jpeg_hdr = gf_malloc(sizeof(char)*read->size);\n\t\tswf_read_data(read, (char *) read->jpeg_hdr, read->size);\n\t}\n\treturn GF_OK;\n}\n\n\nstatic GF_Err swf_def_bits_jpeg(SWFReader *read, u32 version)\n{\n\tu32 ID;\n\tFILE *file = NULL;\n\tchar szName[1024];\n\tu8 *buf;\n\tu32 skip = 0;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tu32 AlphaPlaneSize = 0;\n#endif\n\tu32 size = read->size;\n\tGF_Err e=GF_OK;\n\n\tID = swf_get_16(read);\n\tsize -= 2;\n\tif (version==3) {\n\t\tu32 offset = swf_get_32(read);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tsize -= 4;\n\t\tAlphaPlaneSize = size - offset;\n#endif\n\t\tsize = offset;\n\t}\n\n\t/*dump file*/\n\tif (read->localPath) {\n\t\tsprintf(szName, \"%s/swf_jpeg_%d.jpg\", read->localPath, ID);\n\t} else {\n\t\tsprintf(szName, \"swf_jpeg_%d.jpg\", ID);\n\t}\n\n\tif (version!=3)\n\t\tfile = gf_fopen(szName, \"wb\");\n\n\tif (version==1 && read->jpeg_hdr_size) {\n\t\t/*remove JPEG EOI*/\n\t\tif (gf_fwrite(read->jpeg_hdr, read->jpeg_hdr_size-2, file)!=read->jpeg_hdr_size-2)\n\t\t\treturn GF_IO_ERR;\n\t\t/*remove JPEG SOI*/\n\t\tswf_get_16(read);\n\t\tsize-=2;\n\t}\n\tbuf = gf_malloc(sizeof(u8)*size);\n\tif (!buf) return GF_OUT_OF_MEM;\n\tswf_read_data(read, (char *) buf, size);\n\tif (version==1) {\n\t\tif (gf_fwrite(buf, size, file)!=size)\n\t\t\te = GF_IO_ERR;\n\t} else {\n\t\tu32 i;\n\t\tfor (i=0; i<size; i++) {\n\t\t\tif ((i+4<size)\n\t\t\t        && (buf[i]==0xFF) && (buf[i+1]==0xD9)\n\t\t\t        && (buf[i+2]==0xFF) && (buf[i+3]==0xD8)\n\t\t\t   ) {\n\t\t\t\tmemmove(buf+i, buf+i+4, sizeof(char)*(size-i-4));\n\t\t\t\tsize -= 4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ((buf[0]==0xFF) && (buf[1]==0xD8) && (buf[2]==0xFF) && (buf[3]==0xD8)) {\n\t\t\tskip = 2;\n\t\t}\n\t\tif (version==2) {\n\t\t\tif (gf_fwrite(buf+skip, size-skip, file) != size-skip) e = GF_IO_ERR;\n\t\t}\n\t}\n\tif (version!=3)\n\t\tgf_fclose(file);\n\n\tif (e) {\n\t\tgf_free(buf);\n\t\treturn e;\n\t}\n\n\tif (version==3) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tchar *dst, *raw;\n\t\tu32 codecid;\n\t\tu32 osize, w, h, j, pf;\n\t\tGF_BitStream *bs;\n\n\t\t/*decompress jpeg*/\n\t\tbs = gf_bs_new( (char *) buf+skip, size-skip, GF_BITSTREAM_READ);\n\t\tgf_img_parse(bs, &codecid, &w, &h, NULL, NULL);\n\t\tgf_bs_del(bs);\n\n\t\tosize = w*h*4;\n\t\traw = gf_malloc(sizeof(char)*osize);\n\t\tif (!raw) {\n\t\t\tgf_free(buf);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tmemset(raw, 0, sizeof(char)*osize);\n\t\te = gf_img_jpeg_dec(buf+skip, size-skip, &w, &h, &pf, raw, &osize, 4);\n\t\tif (e != GF_OK) {\n\t\t\tswf_report(read, e, \"Cannot decode JPEG image\");\n\t\t}\n\n\t\t/*read alpha map and decompress it*/\n\t\tif (size<AlphaPlaneSize) buf = gf_realloc(buf, sizeof(u8)*AlphaPlaneSize);\n\t\tswf_read_data(read, (char *) buf, AlphaPlaneSize);\n\n\t\tosize = w*h;\n\t\tdst = gf_malloc(sizeof(char)*osize);\n\t\tuncompress((Bytef *) dst, (uLongf *) &osize, buf, AlphaPlaneSize);\n\t\t/*write alpha channel*/\n\t\tfor (j=0; j<osize; j++) {\n\t\t\traw[4*j + 3] = dst[j];\n\t\t}\n\t\tgf_free(dst);\n\n\t\t/*write png*/\n\t\tif (read->localPath) {\n\t\t\tsprintf(szName, \"%s/swf_png_%d.png\", read->localPath, ID);\n\t\t} else {\n\t\t\tsprintf(szName, \"swf_png_%d.png\", ID);\n\t\t}\n\n\t\tosize = w*h*4;\n\t\tbuf = gf_realloc(buf, sizeof(char)*osize);\n\t\tgf_img_png_enc(raw, w, h, h*4, GF_PIXEL_RGBA, (char *)buf, &osize);\n\n\t\tfile = gf_fopen(szName, \"wb\");\n\t\tif (gf_fwrite(buf, osize, file)!=osize) e = GF_IO_ERR;\n\t\tgf_fclose(file);\n\n\t\tgf_free(raw);\n#endif //GPAC_DISABLE_AV_PARSERS\n\t}\n\tgf_free(buf);\n\tif (e) return e;\n\n\treturn read->setup_image(read, ID, szName);\n}\n\n\nstatic const char *swf_get_tag_name(u32 tag)\n{\n\tswitch (tag) {\n\tcase SWF_END:\n\t\treturn \"End\";\n\tcase SWF_SHOWFRAME:\n\t\treturn \"ShowFrame\";\n\tcase SWF_DEFINESHAPE:\n\t\treturn \"DefineShape\";\n\tcase SWF_FREECHARACTER:\n\t\treturn \"FreeCharacter\";\n\tcase SWF_PLACEOBJECT:\n\t\treturn \"PlaceObject\";\n\tcase SWF_REMOVEOBJECT:\n\t\treturn \"RemoveObject\";\n\tcase SWF_DEFINEBITSJPEG:\n\t\treturn \"DefineBitsJPEG\";\n\tcase SWF_DEFINEBUTTON:\n\t\treturn \"DefineButton\";\n\tcase SWF_JPEGTABLES:\n\t\treturn \"JPEGTables\";\n\tcase SWF_SETBACKGROUNDCOLOR:\n\t\treturn \"SetBackgroundColor\";\n\tcase SWF_DEFINEFONT:\n\t\treturn \"DefineFont\";\n\tcase SWF_DEFINETEXT:\n\t\treturn \"DefineText\";\n\tcase SWF_DOACTION:\n\t\treturn \"DoAction\";\n\tcase SWF_DEFINEFONTINFO:\n\t\treturn \"DefineFontInfo\";\n\tcase SWF_DEFINESOUND:\n\t\treturn \"DefineSound\";\n\tcase SWF_STARTSOUND:\n\t\treturn \"StartSound\";\n\tcase SWF_DEFINEBUTTONSOUND:\n\t\treturn \"DefineButtonSound\";\n\tcase SWF_SOUNDSTREAMHEAD:\n\t\treturn \"SoundStreamHead\";\n\tcase SWF_SOUNDSTREAMBLOCK:\n\t\treturn \"SoundStreamBlock\";\n\tcase SWF_DEFINEBITSLOSSLESS:\n\t\treturn \"DefineBitsLossless\";\n\tcase SWF_DEFINEBITSJPEG2:\n\t\treturn \"DefineBitsJPEG2\";\n\tcase SWF_DEFINESHAPE2:\n\t\treturn \"DefineShape2\";\n\tcase SWF_DEFINEBUTTONCXFORM:\n\t\treturn \"DefineButtonCXForm\";\n\tcase SWF_PROTECT:\n\t\treturn \"Protect\";\n\tcase SWF_PLACEOBJECT2:\n\t\treturn \"PlaceObject2\";\n\tcase SWF_REMOVEOBJECT2:\n\t\treturn \"RemoveObject2\";\n\tcase SWF_DEFINESHAPE3:\n\t\treturn \"DefineShape3\";\n\tcase SWF_DEFINETEXT2:\n\t\treturn \"DefineText2\";\n\tcase SWF_DEFINEBUTTON2:\n\t\treturn \"DefineButton2\";\n\tcase SWF_DEFINEBITSJPEG3:\n\t\treturn \"DefineBitsJPEG3\";\n\tcase SWF_DEFINEBITSLOSSLESS2:\n\t\treturn \"DefineBitsLossless2\";\n\tcase SWF_DEFINEEDITTEXT:\n\t\treturn \"DefineEditText\";\n\tcase SWF_DEFINEMOVIE:\n\t\treturn \"DefineMovie\";\n\tcase SWF_DEFINESPRITE:\n\t\treturn \"DefineSprite\";\n\tcase SWF_NAMECHARACTER:\n\t\treturn \"NameCharacter\";\n\tcase SWF_SERIALNUMBER:\n\t\treturn \"SerialNumber\";\n\tcase SWF_GENERATORTEXT:\n\t\treturn \"GeneratorText\";\n\tcase SWF_FRAMELABEL:\n\t\treturn \"FrameLabel\";\n\tcase SWF_SOUNDSTREAMHEAD2:\n\t\treturn \"SoundStreamHead2\";\n\tcase SWF_DEFINEMORPHSHAPE:\n\t\treturn \"DefineMorphShape\";\n\tcase SWF_DEFINEFONT2:\n\t\treturn \"DefineFont2\";\n\tcase SWF_TEMPLATECOMMAND:\n\t\treturn \"TemplateCommand\";\n\tcase SWF_GENERATOR3:\n\t\treturn \"Generator3\";\n\tcase SWF_EXTERNALFONT:\n\t\treturn \"ExternalFont\";\n\tcase SWF_EXPORTASSETS:\n\t\treturn \"ExportAssets\";\n\tcase SWF_IMPORTASSETS:\n\t\treturn \"ImportAssets\";\n\tcase SWF_ENABLEDEBUGGER:\n\t\treturn \"EnableDebugger\";\n\tcase SWF_MX0:\n\t\treturn \"MX0\";\n\tcase SWF_MX1:\n\t\treturn \"MX1\";\n\tcase SWF_MX2:\n\t\treturn \"MX2\";\n\tcase SWF_MX3:\n\t\treturn \"MX3\";\n\tcase SWF_MX4:\n\t\treturn \"MX4\";\n\tdefault:\n\t\treturn \"UnknownTag\";\n\t}\n}\n\nstatic GF_Err swf_unknown_tag(SWFReader *read)\n{\n\tif (!read) return GF_OK;\n\tswf_report(read, GF_NOT_SUPPORTED, \"Tag %s (0x%2x) not implemented - skipping\", swf_get_tag_name(read->tag), read->tag);\n\treturn swf_func_skip(read);\n}\n\nstatic GF_Err swf_process_tag(SWFReader *read)\n{\n\tswitch (read->tag) {\n\tcase SWF_END:\n\t\treturn GF_OK;\n\tcase SWF_PROTECT:\n\t\treturn GF_OK;\n\tcase SWF_SETBACKGROUNDCOLOR:\n\t\treturn swf_set_backcol(read);\n\tcase SWF_DEFINESHAPE:\n\t\treturn swf_parse_shape_def(read, NULL, 0);\n\tcase SWF_DEFINESHAPE2:\n\t\treturn swf_parse_shape_def(read, NULL, 1);\n\tcase SWF_DEFINESHAPE3:\n\t\treturn swf_parse_shape_def(read, NULL, 2);\n\tcase SWF_PLACEOBJECT:\n\t\treturn swf_place_obj(read, 0);\n\tcase SWF_PLACEOBJECT2:\n\t\treturn swf_place_obj(read, 1);\n\tcase SWF_REMOVEOBJECT:\n\t\treturn swf_remove_obj(read, 0);\n\tcase SWF_REMOVEOBJECT2:\n\t\treturn swf_remove_obj(read, 1);\n\tcase SWF_SHOWFRAME:\n\t\treturn swf_show_frame(read);\n\tcase SWF_DEFINEFONT:\n\t\treturn swf_def_font(read, 0);\n\tcase SWF_DEFINEFONT2:\n\t\treturn swf_def_font(read, 1);\n\tcase SWF_DEFINEFONTINFO:\n\t\treturn swf_def_font_info(read);\n\tcase SWF_DEFINETEXT:\n\t\treturn swf_def_text(read, 0);\n\tcase SWF_DEFINETEXT2:\n\t\treturn swf_def_text(read, 1);\n\tcase SWF_DEFINEEDITTEXT:\n\t\treturn swf_def_edit_text(read);\n\tcase SWF_DEFINESPRITE:\n\t\treturn swf_def_sprite(read);\n\t/*no revision needed*/\n\tcase SWF_SOUNDSTREAMHEAD:\n\tcase SWF_SOUNDSTREAMHEAD2:\n\t\treturn swf_soundstream_hdr(read);\n\tcase SWF_DEFINESOUND:\n\t\treturn swf_def_sound(read);\n\tcase SWF_STARTSOUND:\n\t\treturn swf_start_sound(read);\n\tcase SWF_SOUNDSTREAMBLOCK:\n\t\treturn swf_soundstream_block(read);\n\n\tcase SWF_DEFINEBUTTON:\n\t\treturn swf_def_button(read, 0);\n\tcase SWF_DEFINEBUTTON2:\n\t\treturn swf_def_button(read, 1);\n//\tcase SWF_DEFINEBUTTONSOUND:\n\tcase SWF_DOACTION:\n\t\treturn swf_actions(read, 0, 0);\n\tcase SWF_FRAMELABEL:\n\t{\n\t\tchar *framelabel = swf_get_string(read);\n\t\tgf_free(framelabel);\n\t\treturn GF_OK;\n\t}\n\n\tcase SWF_JPEGTABLES:\n\t\treturn swf_def_hdr_jpeg(read);\n\tcase SWF_DEFINEBITSJPEG:\n\t\treturn swf_def_bits_jpeg(read, 1);\n\tcase SWF_DEFINEBITSJPEG2:\n\t\treturn swf_def_bits_jpeg(read, 2);\n\tcase SWF_DEFINEBITSJPEG3:\n\t\treturn swf_def_bits_jpeg(read, 3);\n\n\tdefault:\n\t\treturn swf_unknown_tag(read);\n\t}\n}\n\nGF_Err swf_parse_tag(SWFReader *read)\n{\n\tGF_Err e;\n\ts32 diff;\n\tu16 hdr;\n\tu32 pos;\n\n\n\thdr = swf_get_16(read);\n\tread->tag = hdr>>6;\n\tread->size = hdr & 0x3f;\n\tif (read->size == 0x3f) {\n\t\tswf_align(read);\n\t\tread->size = swf_get_32(read);\n\t}\n\tpos = swf_get_file_pos(read);\n\tdiff = pos + read->size;\n\tgf_set_progress(\"SWF Parsing\", pos, read->length);\n\n\tread->ioerr = GF_OK;\n\te = swf_process_tag(read);\n\tswf_align(read);\n\tif (!e) e = read->ioerr;\n\n\tdiff -= swf_get_file_pos(read);\n\tif (diff<0) {\n\t\tswf_report(read, GF_IO_ERR, \"tag %s over-read of %d bytes (size %d)\", swf_get_tag_name(read->tag), -1*diff, read->size);\n\t\treturn GF_IO_ERR;\n\t} else {\n\t\tgf_bs_skip_bytes(read->bs, diff);\n\t}\n\n\n\tif (!e && !read->tag) {\n\t\treturn GF_EOS;\n\t}\n\n\tif (read->ioerr) {\n\t\tswf_report(read, GF_IO_ERR, \"bitstream IO err (tag size %d)\", read->size);\n\t\treturn read->ioerr;\n\t}\n\treturn e;\n}\n\n\n\nGF_Err swf_parse_sprite(SWFReader *read)\n{\n\t/*parse*/\n\twhile (1) {\n\t\tGF_Err e = swf_parse_tag(read);\n\t\tif (e<0) {\n\t\t\tswf_report(read, e, \"Error parsing tag %s\", swf_get_tag_name(read->tag));\n\t\t\treturn e;\n\t\t}\n\t\t/*done with sprite*/\n\t\tif (read->tag==SWF_END) break;\n\t}\n\treturn GF_OK;\n}\n\n\nvoid swf_report(SWFReader *read, GF_Err e, char *format, ...)\n{\n#ifndef GPAC_DISABLE_LOG\n\tif (gf_log_tool_level_on(GF_LOG_PARSER, e ? GF_LOG_ERROR : GF_LOG_WARNING)) {\n\t\tchar szMsg[2048];\n\t\tva_list args;\n\t\tva_start(args, format);\n\t\tvsnprintf(szMsg, 2048, format, args);\n\t\tva_end(args);\n\t\tGF_LOG((u32) (e ? GF_LOG_ERROR : GF_LOG_WARNING), GF_LOG_PARSER, (\"[SWF Parsing] %s (frame %d)\\n\", szMsg, read->current_frame+1) );\n\t}\n#endif\n}\n\n\nstatic void swf_io_error(void *par)\n{\n\tSWFReader *read = (SWFReader *)par;\n\tif (read) read->ioerr = GF_IO_ERR;\n}\n\nGF_Err gf_sm_load_run_swf(GF_SceneLoader *load)\n{\n\tGF_Err e;\n\tSWFReader *read = (SWFReader *)load->loader_priv;\n\tif (!read) return GF_BAD_PARAM;\n\n\t/*parse all tags*/\n\twhile (1) {\n\t\te = swf_parse_tag(read);\n\t\tif (e) break;\n\t}\n\tgf_set_progress(\"SWF Parsing\", read->length, read->length);\n\n\tif (e==GF_EOS) {\n\t\tif (read->finalize)\n\t\t\tread->finalize(read);\n\t\te = GF_OK;\n\t}\n\tif (!e) {\n\t\tif (read->flat_limit != 0)\n\t\t\tswf_report(read, GF_OK, \"%d points removed while parsing shapes (Flattening limit %.4f)\", read->flatten_points, read->flat_limit);\n\n\t\tif (read->no_as && read->has_interact) swf_report(read, GF_OK, \"ActionScripts and interactions have been removed\");\n\t} else\n\t\tswf_report(read, e, \"Error parsing tag %s\", swf_get_tag_name(read->tag));\n\n\n\treturn e;\n}\n\nvoid gf_swf_reader_del(SWFReader *read)\n{\n\tif (!read) return;\n\tgf_bs_del(read->bs);\n\tif (read->mem) gf_free(read->mem);\n\n\twhile (gf_list_count(read->display_list)) {\n\t\tDispShape *s = (DispShape *)gf_list_get(read->display_list, 0);\n\t\tgf_list_rem(read->display_list, 0);\n\t\tgf_free(s);\n\t}\n\tgf_list_del(read->display_list);\n\twhile (gf_list_count(read->fonts)) {\n\t\tSWFFont *ft = (SWFFont *)gf_list_get(read->fonts, 0);\n\t\tgf_list_rem(read->fonts, 0);\n\t\tif (ft->glyph_adv) gf_free(ft->glyph_adv);\n\t\tif (ft->glyph_codes) gf_free(ft->glyph_codes);\n\t\tif (ft->fontName) gf_free(ft->fontName);\n\t\tgf_list_del(ft->glyphs);\n\t\tgf_free(ft);\n\t}\n\tgf_list_del(read->fonts);\n\tgf_list_del(read->apps);\n\n\twhile (gf_list_count(read->sounds)) {\n\t\tSWFSound *snd = (SWFSound *)gf_list_get(read->sounds, 0);\n\t\tgf_list_rem(read->sounds, 0);\n\t\tif (snd->output) gf_fclose(snd->output);\n\t\tif (snd->szFileName) gf_free(snd->szFileName);\n\t\tgf_free(snd);\n\t}\n\tgf_list_del(read->sounds);\n\tswf_delete_sound_stream(read);\n\n\tif (read->jpeg_hdr) gf_free(read->jpeg_hdr);\n\tif (read->localPath) gf_free(read->localPath);\n\tgf_fclose(read->input);\n\tgf_free(read->inputName);\n\tgf_free(read);\n}\n\nvoid gf_sm_load_done_swf(GF_SceneLoader *load)\n{\n\tSWFReader *read = (SWFReader *) load->loader_priv;\n\tif (!read) return;\n\tif (read->svg_file) {\n\t\tgf_fclose(read->svg_file);\n\t\tread->svg_file = NULL;\n\t}\n\tgf_swf_reader_del(read);\n\tload->loader_priv = NULL;\n}\n\nSWFReader *gf_swf_reader_new(const char *localPath, const char *inputName)\n{\n\tSWFReader *read;\n\tFILE *input;\n\tinput = gf_fopen(inputName, \"rb\");\n\tif (!input) return NULL;\n\n\tGF_SAFEALLOC(read, SWFReader);\n\tif (!read) return NULL;\n\tread->inputName = gf_strdup(inputName);\n\tread->input = input;\n\tread->bs = gf_bs_from_file(input, GF_BITSTREAM_READ);\n\tgf_bs_set_eos_callback(read->bs, swf_io_error, read);\n\tread->display_list = gf_list_new();\n\tread->fonts = gf_list_new();\n\tread->apps = gf_list_new();\n\tread->sounds = gf_list_new();\n\n\tif (localPath) {\n\t\tread->localPath = gf_strdup(localPath);\n\t} else {\n\t\tchar *c;\n\t\tread->localPath = gf_strdup(inputName);\n\t\tc = strrchr(read->localPath, GF_PATH_SEPARATOR);\n\t\tif (c) c[1] = 0;\n\t\telse {\n\t\t\tgf_free(read->localPath);\n\t\t\tread->localPath = NULL;\n\t\t}\n\t}\n\n\treturn read;\n}\n\nGF_Err gf_swf_reader_set_user_mode(SWFReader *read, void *user,\n                                   GF_Err (*add_sample)(void *user, const u8 *data, u32 length, u64 timestamp, Bool isRap),\n                                   GF_Err (*add_header)(void *user, const u8 *data, u32 length, Bool isHeader))\n{\n\tif (!read) return GF_BAD_PARAM;\n\tread->user = user;\n\tread->add_header = add_header;\n\tread->add_sample = add_sample;\n\treturn GF_OK;\n}\n\nGF_Err gf_swf_read_header(SWFReader *read)\n{\n\tSWFRec rc;\n\tu8 sig[3];\n\n\t/*get signature*/\n\tsig[0] = gf_bs_read_u8(read->bs);\n\tsig[1] = gf_bs_read_u8(read->bs);\n\tsig[2] = gf_bs_read_u8(read->bs);\n\t/*\"FWS\" or \"CWS\"*/\n\tif ( ((sig[0] != 'F') && (sig[0] != 'C')) || (sig[1] != 'W') || (sig[2] != 'S') ) {\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\t/*version = */gf_bs_read_u8(read->bs);\n\tread->length = swf_get_32(read);\n\n\t/*if compressed decompress the whole file*/\n\tif (sig[0] == 'C') {\n\t\tswf_init_decompress(read);\n\t\tif (!read->bs) return GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\tswf_get_rec(read, &rc);\n\tread->width = rc.w;\n\tread->height = rc.h;\n\n\tswf_align(read);\n\tread->frame_rate = swf_get_16(read)>>8;\n\tread->frame_count = swf_get_16(read);\n\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"SWF Import - Scene Size %gx%g - %d frames @ %d FPS\\n\", read->width, read->height, read->frame_count, read->frame_rate));\n\tif (!read->frame_rate) read->frame_rate = 1;\n\treturn GF_OK;\n}\n\nGF_Err gf_swf_get_duration(SWFReader *read, u32 *frame_rate, u32 *frame_count)\n{\n\t*frame_rate = read->frame_rate;\n\t*frame_count = read->frame_count;\n\treturn GF_OK;\n}\n\nGF_Err gf_sm_load_init_swf(GF_SceneLoader *load)\n{\n\tSWFReader *read;\n\tGF_Err e;\n\n\tif (!load->ctx || !load->scene_graph || !load->fileName) return GF_BAD_PARAM;\n\n#ifdef GPAC_ENABLE_COVERAGE\n\tif (gf_sys_is_cov_mode()) {\n\t\tswf_func_skip(NULL);\n\t\tswf_def_hdr_jpeg(NULL);\n\t\tswf_get_tag_name(SWF_FREECHARACTER);\n\t\tswf_unknown_tag(NULL);\n\t\tswf_io_error(NULL);\n\t}\n#endif\n\n\tread = gf_swf_reader_new(load->localPath, load->fileName);\n\tread->load = load;\n\tread->flags = load->swf_import_flags;\n\tread->flat_limit = FLT2FIX(load->swf_flatten_limit);\n\tload->loader_priv = read;\n\n\te = gf_swf_read_header(read);\n\tif (e) goto exit;\n\tload->ctx->scene_width = FIX2INT(read->width);\n\tload->ctx->scene_height = FIX2INT(read->height);\n\tload->ctx->is_pixel_metrics = 1;\n\n\tif (!(load->swf_import_flags & GF_SM_SWF_SPLIT_TIMELINE) ) {\n\t\tswf_report(read, GF_OK, \"ActionScript disabled\");\n\t\tread->no_as = 1;\n\t}\n\n\tif (!(load->swf_import_flags & GF_SM_SWF_USE_SVG)) {\n#ifndef GPAC_DISABLE_VRML\n\t\te = swf_to_bifs_init(read);\n#else\n\t\te = GF_NOT_SUPPORTED;\n#endif\n\t} else {\n#ifndef GPAC_DISABLE_SVG\n\t\tFILE *svgFile;\n\t\tif (load->svgOutFile) {\n\t\t\tchar svgFileName[GF_MAX_PATH];\n\t\t\tif (load->localPath) {\n\t\t\t\tsprintf(svgFileName, \"%s%c%s.svg\", load->localPath, GF_PATH_SEPARATOR, load->svgOutFile);\n\t\t\t} else {\n\t\t\t\tsprintf(svgFileName, \"%s.svg\", load->svgOutFile);\n\t\t\t}\n\t\t\tsvgFile = gf_fopen(svgFileName, \"wt\");\n\t\t\tif (!svgFile) return GF_BAD_PARAM;\n\t\t\tread->svg_file = svgFile;\n\t\t} else {\n\t\t\tsvgFile = stdout;\n\t\t}\n\t\tgf_swf_reader_set_user_mode(read, svgFile, swf_svg_write_text_sample, swf_svg_write_text_header);\n\t\te = swf_to_svg_init(read, read->flags, load->swf_flatten_limit);\n#else\n\t\te = GF_NOT_SUPPORTED;\n#endif\n\t}\n\tif (e) goto exit;\n\n\t/*parse all tags*/\n\twhile (e == GF_OK) {\n\t\te = swf_parse_tag(read);\n\t\tif (read->current_frame==1) break;\n\t}\n\tif (e==GF_EOS) e = GF_OK;\n\n\tload->done = gf_sm_load_done_swf;\n\tload->process = gf_sm_load_run_swf;\n\nexit:\n\tif (e) gf_sm_load_done_swf(load);\n\treturn e;\n}\n\n#endif /*GPAC_DISABLE_SWF_IMPORT*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Scene Management sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include <gpac/nodes_mpeg4.h>\n#include <gpac/internal/swf_dev.h>\n#include <gpac/avparse.h>\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\n\n#include <zlib.h>\n\nenum\n{\n\tSWF_END = 0,\n\tSWF_SHOWFRAME = 1,\n\tSWF_DEFINESHAPE = 2,\n\tSWF_FREECHARACTER = 3,\n\tSWF_PLACEOBJECT = 4,\n\tSWF_REMOVEOBJECT = 5,\n\tSWF_DEFINEBITS = 6,\n\tSWF_DEFINEBITSJPEG = 6,\n\tSWF_DEFINEBUTTON = 7,\n\tSWF_JPEGTABLES = 8,\n\tSWF_SETBACKGROUNDCOLOR = 9,\n\tSWF_DEFINEFONT = 10,\n\tSWF_DEFINETEXT = 11,\n\tSWF_DOACTION = 12,\n\tSWF_DEFINEFONTINFO = 13,\n\tSWF_DEFINESOUND = 14,\n\tSWF_STARTSOUND = 15,\n\tSWF_DEFINEBUTTONSOUND = 17,\n\tSWF_SOUNDSTREAMHEAD = 18,\n\tSWF_SOUNDSTREAMBLOCK = 19,\n\tSWF_DEFINEBITSLOSSLESS = 20,\n\tSWF_DEFINEBITSJPEG2 = 21,\n\tSWF_DEFINESHAPE2 = 22,\n\tSWF_DEFINEBUTTONCXFORM = 23,\n\tSWF_PROTECT = 24,\n\tSWF_PLACEOBJECT2 = 26,\n\tSWF_REMOVEOBJECT2 = 28,\n\tSWF_DEFINESHAPE3 = 32,\n\tSWF_DEFINETEXT2 = 33,\n\tSWF_DEFINEBUTTON2 = 34,\n\tSWF_DEFINEBITSJPEG3 = 35,\n\tSWF_DEFINEBITSLOSSLESS2 = 36,\n\tSWF_DEFINEEDITTEXT = 37,\n\tSWF_DEFINEMOVIE = 38,\n\tSWF_DEFINESPRITE = 39,\n\tSWF_NAMECHARACTER = 40,\n\tSWF_SERIALNUMBER = 41,\n\tSWF_GENERATORTEXT = 42,\n\tSWF_FRAMELABEL = 43,\n\tSWF_SOUNDSTREAMHEAD2 = 45,\n\tSWF_DEFINEMORPHSHAPE = 46,\n\tSWF_DEFINEFONT2 = 48,\n\tSWF_TEMPLATECOMMAND = 49,\n\tSWF_GENERATOR3 = 51,\n\tSWF_EXTERNALFONT = 52,\n\tSWF_EXPORTASSETS = 56,\n\tSWF_IMPORTASSETS\t= 57,\n\tSWF_ENABLEDEBUGGER = 58,\n\tSWF_MX0 = 59,\n\tSWF_MX1 = 60,\n\tSWF_MX2 = 61,\n\tSWF_MX3 = 62,\n\tSWF_MX4 = 63,\n\tSWF_REFLEX = 777\n};\n\n\nstatic void swf_init_decompress(SWFReader *read)\n{\n\tu32 size, dst_size;\n\tuLongf destLen;\n\tchar *src, *dst;\n\n\tsize = (u32) gf_bs_get_size(read->bs)-8;\n\tif (gf_bs_get_size(read->bs) - 8 >= (u64)1<<31) {\n\t\tgf_bs_del(read->bs);\n\t\tread->bs = NULL;\n\t\treturn;\n\t}\n\tdst_size = read->length;\n\tsrc = gf_malloc(sizeof(char)*size);\n\tdst = gf_malloc(sizeof(char)*dst_size);\n\tmemset(dst, 0, sizeof(char)*8);\n\tgf_bs_read_data(read->bs, src, size);\n\tdst_size -= 8;\n\tdestLen = (uLongf)dst_size;\n\tuncompress((Bytef *) dst+8, &destLen, (Bytef *) src, size);\n\tdst_size += 8;\n\tgf_free(src);\n\tread->mem = dst;\n\tgf_bs_del(read->bs);\n\tread->bs = gf_bs_new(read->mem, dst_size, GF_BITSTREAM_READ);\n\tgf_bs_skip_bytes(read->bs, 8);\n}\n\n\nstatic GF_Err swf_seek_file_to(SWFReader *read, u32 size)\n{\n\treturn gf_bs_seek(read->bs, size);\n}\n\nstatic u32 swf_get_file_pos(SWFReader *read)\n{\n\treturn (u32) gf_bs_get_position(read->bs);\n}\n\nstatic u32 swf_read_data(SWFReader *read, char *data, u32 data_size)\n{\n\treturn gf_bs_read_data(read->bs, data, data_size);\n}\n\nstatic u32 swf_read_int(SWFReader *read, u32 nbBits)\n{\n\treturn gf_bs_read_int(read->bs, nbBits);\n}\n\nstatic s32 swf_read_sint(SWFReader *read, u32 nbBits)\n{\n\tu32 r = 0;\n\tu32 i;\n\tif (!nbBits)return 0;\n\tr = swf_read_int(read, 1) ? 0xFFFFFFFF : 0;\n\tfor (i=1; i<nbBits; i++) {\n\t\tr <<= 1;\n\t\tr |= swf_read_int(read, 1);\n\t}\n\treturn (s32) r;\n}\n\nstatic u32 swf_align(SWFReader *read)\n{\n\treturn gf_bs_align(read->bs);\n}\n\nstatic void swf_skip_data(SWFReader *read, u32 size)\n{\n\twhile (size && !read->ioerr) {\n\t\tswf_read_int(read, 8);\n\t\tsize --;\n\t}\n}\n\nstatic void swf_get_rec(SWFReader *read, SWFRec *rc)\n{\n\tu32 nbbits;\n\tswf_align(read);\n\tnbbits = swf_read_int(read, 5);\n\trc->x = FLT2FIX( swf_read_sint(read, nbbits) * SWF_TWIP_SCALE );\n\trc->w = FLT2FIX( swf_read_sint(read, nbbits) * SWF_TWIP_SCALE );\n\trc->w -= rc->x;\n\trc->y = FLT2FIX( swf_read_sint(read, nbbits) * SWF_TWIP_SCALE );\n\trc->h = FLT2FIX( swf_read_sint(read, nbbits) * SWF_TWIP_SCALE );\n\trc->h -= rc->y;\n}\n\nstatic u32 swf_get_32(SWFReader *read)\n{\n\treturn gf_bs_read_u32_le(read->bs);\n}\n\nstatic u16 swf_get_16(SWFReader *read)\n{\n\treturn gf_bs_read_u16_le(read->bs);\n}\n\nstatic s16 swf_get_s16(SWFReader *read)\n{\n\treturn (s16) gf_bs_read_u16_le(read->bs);\n}\n\nstatic u32 swf_get_color(SWFReader *read)\n{\n\tu32 res;\n\tres = 0xFF00;\n\tres |= swf_read_int(read, 8);\n\tres<<=8;\n\tres |= swf_read_int(read, 8);\n\tres<<=8;\n\tres |= swf_read_int(read, 8);\n\treturn res;\n}\n\nstatic u32 swf_get_argb(SWFReader *read)\n{\n\tu32 res, al;\n\tres = swf_read_int(read, 8);\n\tres<<=8;\n\tres |= swf_read_int(read, 8);\n\tres<<=8;\n\tres |= swf_read_int(read, 8);\n\tal = swf_read_int(read, 8);\n\treturn ((al<<24) | res);\n}\n\nstatic u32 swf_get_matrix(SWFReader *read, GF_Matrix2D *mat)\n{\n\tu32 bits_read;\n\tu32 flag, nb_bits;\n\n\tmemset(mat, 0, sizeof(GF_Matrix2D));\n\tmat->m[0] = mat->m[4] = FIX_ONE;\n\n\tbits_read = swf_align(read);\n\n\tflag = swf_read_int(read, 1);\n\tbits_read += 1;\n\tif (flag) {\n\t\tnb_bits = swf_read_int(read, 5);\n#ifdef GPAC_FIXED_POINT\n\t\tmat->m[0] = swf_read_sint(read, nb_bits);\n\t\tmat->m[4] = swf_read_sint(read, nb_bits);\n#else\n\t\tmat->m[0] = (Float) swf_read_sint(read, nb_bits);\n\t\tmat->m[0] /= 0x10000;\n\t\tmat->m[4] = (Float) swf_read_sint(read, nb_bits);\n\t\tmat->m[4] /= 0x10000;\n#endif\n\t\tbits_read += 5 + 2*nb_bits;\n\t}\n\tflag = swf_read_int(read, 1);\n\tbits_read += 1;\n\tif (flag) {\n\t\tnb_bits = swf_read_int(read, 5);\n\t\t/*WATCHOUT FOR ORDER*/\n#ifdef GPAC_FIXED_POINT\n\t\tmat->m[3] = swf_read_sint(read, nb_bits);\n\t\tmat->m[1] = swf_read_sint(read, nb_bits);\n#else\n\t\tmat->m[3] = (Float) swf_read_sint(read, nb_bits);\n\t\tmat->m[3] /= 0x10000;\n\t\tmat->m[1] = (Float) swf_read_sint(read, nb_bits);\n\t\tmat->m[1] /= 0x10000;\n#endif\n\t\tbits_read += 5 + 2*nb_bits;\n\t}\n\tnb_bits = swf_read_int(read, 5);\n\tbits_read += 5 + 2*nb_bits;\n\tif (nb_bits) {\n\t\tmat->m[2] = FLT2FIX( swf_read_sint(read, nb_bits) * SWF_TWIP_SCALE );\n\t\tmat->m[5] = FLT2FIX( swf_read_sint(read, nb_bits) * SWF_TWIP_SCALE );\n\t}\n\treturn bits_read;\n}\n\n#define SWF_COLOR_SCALE\t\t\t\t(1/256.0f)\n\nstatic void swf_get_colormatrix(SWFReader *read, GF_ColorMatrix *cmat)\n{\n\tBool has_add, has_mul;\n\tu32 nbbits;\n\tmemset(cmat, 0, sizeof(GF_ColorMatrix));\n\tcmat->m[0] = cmat->m[6] = cmat->m[12] = cmat->m[18] = FIX_ONE;\n\n\thas_add = swf_read_int(read, 1);\n\thas_mul = swf_read_int(read, 1);\n\tnbbits = swf_read_int(read, 4);\n\tif (has_mul) {\n\t\tcmat->m[0] = FLT2FIX( swf_read_sint(read, nbbits) * SWF_COLOR_SCALE );\n\t\tcmat->m[6] = FLT2FIX( swf_read_sint(read, nbbits) * SWF_COLOR_SCALE );\n\t\tcmat->m[12] = FLT2FIX( swf_read_sint(read, nbbits) * SWF_COLOR_SCALE );\n\t\tcmat->m[18] = FLT2FIX( swf_read_sint(read, nbbits) * SWF_COLOR_SCALE );\n\t}\n\tif (has_add) {\n\t\tcmat->m[4] = FLT2FIX( swf_read_sint(read, nbbits) * SWF_COLOR_SCALE );\n\t\tcmat->m[9] = FLT2FIX( swf_read_sint(read, nbbits) * SWF_COLOR_SCALE );\n\t\tcmat->m[14] = FLT2FIX( swf_read_sint(read, nbbits) * SWF_COLOR_SCALE );\n\t\tcmat->m[19] = FLT2FIX( swf_read_sint(read, nbbits) * SWF_COLOR_SCALE );\n\t}\n\tcmat->identity = 0;\n\tif ((cmat->m[0] == cmat->m[6])\n\t        && (cmat->m[0] == cmat->m[12])\n\t        && (cmat->m[0] == cmat->m[18])\n\t        && (cmat->m[0] == FIX_ONE)\n\t        && (cmat->m[4] == cmat->m[9])\n\t        && (cmat->m[4] == cmat->m[14])\n\t        && (cmat->m[4] == cmat->m[19])\n\t        && (cmat->m[4] == 0))\n\t\tcmat->identity = 1;\n}\n\nstatic char *swf_get_string(SWFReader *read)\n{\n\tchar szName[1024];\n\tchar *name;\n\tu32 i = 0;\n\n\tif (read->size>1024) {\n\t\tname = gf_malloc(sizeof(char)*read->size);\n\t} else {\n\t\tname = szName;\n\t}\n\twhile (1) {\n\t\tif (i>=read->size) {\n\t\t\tread->ioerr = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tbreak;\n\t\t}\n\t\tname[i] = swf_read_int(read, 8);\n\t\tif (!name[i]) break;\n\t\ti++;\n\t}\n\tif (read->size>1024) {\n\t\treturn gf_realloc(name, sizeof(char)*(strlen(name)+1));\n\t} else {\n\t\treturn gf_strdup(szName);\n\t}\n}\n\nstatic SWFShapeRec *swf_new_shape_rec()\n{\n\tSWFShapeRec *style;\n\tGF_SAFEALLOC(style, SWFShapeRec);\n\tif (!style) return NULL;\n\tGF_SAFEALLOC(style->path, SWFPath);\n\tif (!style->path) {\n\t\tgf_free(style);\n\t\treturn NULL;\n\t}\n\treturn style;\n}\n\nstatic SWFShapeRec *swf_clone_shape_rec(SWFShapeRec *old_sr)\n{\n\tSWFShapeRec *new_sr = (SWFShapeRec *)gf_malloc(sizeof(SWFShapeRec));\n\tmemcpy(new_sr, old_sr, sizeof(SWFShapeRec));\n\tnew_sr->path = (SWFPath*)gf_malloc(sizeof(SWFPath));\n\tmemset(new_sr->path, 0, sizeof(SWFPath));\n\n\tif (old_sr->nbGrad) {\n\t\tnew_sr->grad_col = (u32*)gf_malloc(sizeof(u32) * old_sr->nbGrad);\n\t\tmemcpy(new_sr->grad_col, old_sr->grad_col, sizeof(u32) * old_sr->nbGrad);\n\t\tnew_sr->grad_ratio = (u8*)gf_malloc(sizeof(u8) * old_sr->nbGrad);\n\t\tmemcpy(new_sr->grad_ratio, old_sr->grad_ratio, sizeof(u8) * old_sr->nbGrad);\n\t}\n\treturn new_sr;\n}\n\n/*parse/append fill and line styles*/\nstatic void swf_parse_styles(SWFReader *read, u32 revision, SWFShape *shape, u32 *bits_fill, u32 *bits_line)\n{\n\tu32 i, j, count;\n\tSWFShapeRec *style;\n\n\tswf_align(read);\n\n\t/*get fill styles*/\n\tcount = swf_read_int(read, 8);\n\tif (revision && (count== 0xFF)) count = swf_get_16(read);\n\tif (count) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tstyle = swf_new_shape_rec();\n\n\t\t\tstyle->solid_col = 0xFF00FF00;\n\t\t\tstyle->type = swf_read_int(read, 8);\n\n\t\t\t/*gradient fill*/\n\t\t\tif (style->type & 0x10) {\n\t\t\t\tswf_get_matrix(read, &style->mat);\n\t\t\t\tswf_align(read);\n\t\t\t\tstyle->nbGrad = swf_read_int(read, 8);\n\t\t\t\tif (style->nbGrad) {\n\t\t\t\t\tstyle->grad_col = (u32 *) gf_malloc(sizeof(u32) * style->nbGrad);\n\t\t\t\t\tstyle->grad_ratio = (u8 *) gf_malloc(sizeof(u8) * style->nbGrad);\n\t\t\t\t\tfor (j=0; j<style->nbGrad; j++) {\n\t\t\t\t\t\tstyle->grad_ratio[j] = swf_read_int(read, 8);\n\t\t\t\t\t\tif (revision==2) style->grad_col[j] = swf_get_argb(read);\n\t\t\t\t\t\telse style->grad_col[j] = swf_get_color(read);\n\t\t\t\t\t}\n\t\t\t\t\tstyle->solid_col = style->grad_col[0];\n\n\t\t\t\t\t/*make sure we have keys between 0 and 1.0 for BIFS (0 and 255 in swf)*/\n\t\t\t\t\tif (style->grad_ratio[0] != 0) {\n\t\t\t\t\t\tu32 *grad_col;\n\t\t\t\t\t\tu8 *grad_ratio;\n\t\t\t\t\t\tgrad_ratio = (u8 *) gf_malloc(sizeof(u8) * (style->nbGrad+1));\n\t\t\t\t\t\tgrad_col = (u32 *) gf_malloc(sizeof(u32) * (style->nbGrad+1));\n\t\t\t\t\t\tgrad_col[0] = style->grad_col[0];\n\t\t\t\t\t\tgrad_ratio[0] = 0;\n\t\t\t\t\t\tfor (j=0; j<style->nbGrad; j++) {\n\t\t\t\t\t\t\tgrad_col[j+1] = style->grad_col[j];\n\t\t\t\t\t\t\tgrad_ratio[j+1] = style->grad_ratio[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_free(style->grad_col);\n\t\t\t\t\t\tstyle->grad_col = grad_col;\n\t\t\t\t\t\tgf_free(style->grad_ratio);\n\t\t\t\t\t\tstyle->grad_ratio = grad_ratio;\n\t\t\t\t\t\tstyle->nbGrad++;\n\t\t\t\t\t}\n\t\t\t\t\tif (style->grad_ratio[style->nbGrad-1] != 255) {\n\t\t\t\t\t\tu32 *grad_col = (u32*)gf_malloc(sizeof(u32) * (style->nbGrad+1));\n\t\t\t\t\t\tu8 *grad_ratio = (u8*)gf_malloc(sizeof(u8) * (style->nbGrad+1));\n\t\t\t\t\t\tmemcpy(grad_col, style->grad_col, sizeof(u32) * style->nbGrad);\n\t\t\t\t\t\tmemcpy(grad_ratio, style->grad_ratio, sizeof(u8) * style->nbGrad);\n\t\t\t\t\t\tgrad_col[style->nbGrad] = style->grad_col[style->nbGrad-1];\n\t\t\t\t\t\tgrad_ratio[style->nbGrad] = 255;\n\t\t\t\t\t\tgf_free(style->grad_col);\n\t\t\t\t\t\tstyle->grad_col = grad_col;\n\t\t\t\t\t\tgf_free(style->grad_ratio);\n\t\t\t\t\t\tstyle->grad_ratio = grad_ratio;\n\t\t\t\t\t\tstyle->nbGrad++;\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tstyle->solid_col = 0xFF;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*bitmap fill*/\n\t\t\telse if (style->type & 0x40) {\n\t\t\t\tstyle->img_id = swf_get_16(read);\n\t\t\t\tif (style->img_id == 65535) {\n\t\t\t\t\tstyle->img_id = 0;\n\t\t\t\t\tstyle->type = 0;\n\t\t\t\t\tstyle->solid_col = 0xFF00FFFF;\n\t\t\t\t}\n\t\t\t\tswf_get_matrix(read, &style->mat);\n\t\t\t}\n\t\t\t/*solid fill*/\n\t\t\telse {\n\t\t\t\tif (revision==2) style->solid_col = swf_get_argb(read);\n\t\t\t\telse style->solid_col = swf_get_color(read);\n\t\t\t}\n\t\t\tgf_list_add(shape->fill_right, style);\n\t\t\tstyle = swf_clone_shape_rec(style);\n\t\t\tgf_list_add(shape->fill_left, style);\n\t\t}\n\t}\n\n\tswf_align(read);\n\t/*get line styles*/\n\tcount = swf_read_int(read, 8);\n\tif (revision && (count==0xFF)) count = swf_get_16(read);\n\tif (count) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tstyle = swf_new_shape_rec();\n\t\t\tgf_list_add(shape->lines, style);\n\t\t\tstyle->width = FLT2FIX( swf_get_16(read) * SWF_TWIP_SCALE );\n\t\t\tif (revision==2) style->solid_col = swf_get_argb(read);\n\t\t\telse style->solid_col = swf_get_color(read);\n\t\t}\n\t}\n\n\tswf_align(read);\n\t*bits_fill = swf_read_int(read, 4);\n\t*bits_line = swf_read_int(read, 4);\n}\n\nstatic void swf_path_realloc_pts(SWFPath *path, u32 nbPts)\n{\n\tif (path)\n\t\tpath->pts = (SFVec2f*)gf_realloc(path->pts, sizeof(SFVec2f) * (path->nbPts + nbPts));\n}\n\nstatic void swf_path_add_com(SWFShapeRec *sr, SFVec2f pt, SFVec2f ctr, u32 type)\n{\n\t/*not an error*/\n\tif (!sr) return;\n\n\tsr->path->types = (u32*)gf_realloc(sr->path->types, sizeof(u32) * (sr->path->nbType+1));\n\n\tsr->path->types[sr->path->nbType] = type;\n\tswitch (type) {\n\tcase 2:\n\t\tswf_path_realloc_pts(sr->path, 2);\n\t\tsr->path->pts[sr->path->nbPts] = ctr;\n\t\tsr->path->pts[sr->path->nbPts+1] = pt;\n\t\tsr->path->nbPts+=2;\n\t\tbreak;\n\tcase 1:\n\tdefault:\n\t\tswf_path_realloc_pts(sr->path, 1);\n\t\tsr->path->pts[sr->path->nbPts] = pt;\n\t\tsr->path->nbPts++;\n\t\tbreak;\n\t}\n\tsr->path->nbType++;\n}\n\nstatic void swf_referse_path(SWFPath *path)\n{\n\tu32 i, j, pti, ptj;\n\tu32 *types;\n\tSFVec2f *pts;\n\n\tif (path->nbType<=1) return;\n\n\ttypes = (u32 *) gf_malloc(sizeof(u32) * path->nbType);\n\tpts = (SFVec2f *) gf_malloc(sizeof(SFVec2f) * path->nbPts);\n\n\n\t/*need first moveTo*/\n\ttypes[0] = 0;\n\tpts[0] = path->pts[path->nbPts - 1];\n\tpti = path->nbPts - 2;\n\tptj = 1;\n\tj=1;\n\n\tfor (i=0; i<path->nbType-1; i++) {\n\t\ttypes[j] = path->types[path->nbType - i - 1];\n\t\tswitch (types[j]) {\n\t\tcase 2:\n\t\t\tassert(ptj<=path->nbPts-2);\n\t\t\tpts[ptj] = path->pts[pti];\n\t\t\tpts[ptj+1] = path->pts[pti-1];\n\t\t\tpti-=2;\n\t\t\tptj+=2;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tassert(ptj<=path->nbPts-1);\n\t\t\tpts[ptj] = path->pts[pti];\n\t\t\tpti--;\n\t\t\tptj++;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tassert(ptj<=path->nbPts-1);\n\t\t\tpts[ptj] = path->pts[pti];\n\t\t\tpti--;\n\t\t\tptj++;\n\t\t\tbreak;\n\t\t}\n\t\tj++;\n\t}\n\tgf_free(path->pts);\n\tpath->pts = pts;\n\tgf_free(path->types);\n\tpath->types = types;\n}\n\nstatic void swf_free_shape_rec(SWFShapeRec *ptr)\n{\n\tif (ptr->grad_col) gf_free(ptr->grad_col);\n\tif (ptr->grad_ratio) gf_free(ptr->grad_ratio);\n\tif (ptr->path) {\n\t\tif (ptr->path->pts) gf_free(ptr->path->pts);\n\t\tif (ptr->path->types) gf_free(ptr->path->types);\n\t\tif (ptr->path->idx) gf_free(ptr->path->idx);\n\t\tgf_free(ptr->path);\n\t}\n\tgf_free(ptr);\n}\n\nstatic void swf_reset_rec_list(GF_List *recs)\n{\n\twhile (gf_list_count(recs)) {\n\t\tSWFShapeRec *tmp = (SWFShapeRec *)gf_list_get(recs, 0);\n\t\tgf_list_rem(recs, 0);\n\t\tswf_free_shape_rec(tmp);\n\t}\n}\n\nstatic void swf_append_path(SWFPath *a, SWFPath *b)\n{\n\tif (b->nbType<=1) return;\n\n\ta->pts = (SFVec2f*)gf_realloc(a->pts, sizeof(SFVec2f) * (a->nbPts + b->nbPts));\n\tmemcpy(&a->pts[a->nbPts], b->pts, sizeof(SFVec2f)*b->nbPts);\n\ta->nbPts += b->nbPts;\n\n\ta->types = (u32*)gf_realloc(a->types, sizeof(u32)*(a->nbType+ b->nbType));\n\tmemcpy(&a->types[a->nbType], b->types, sizeof(u32)*b->nbType);\n\ta->nbType += b->nbType;\n}\n\nstatic void swf_path_add_type(SWFPath *path, u32 val)\n{\n\tpath->types = (u32*)gf_realloc(path->types, sizeof(u32) * (path->nbType + 1));\n\tpath->types[path->nbType] = val;\n\tpath->nbType++;\n}\n\nstatic void swf_resort_path(SWFPath *a, SWFReader *read)\n{\n\tu32 idx, i, j;\n\tGF_List *paths;\n\tSWFPath *sorted, *p, *np;\n\n\tif (!a->nbType) return;\n\n\tpaths = gf_list_new();\n\tGF_SAFEALLOC(sorted, SWFPath);\n\tif (!sorted) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[SWF Parsing] Fail to allocate path for resorting\\n\"));\n\t\treturn;\n\t}\n\tswf_path_realloc_pts(sorted, 1);\n\tsorted->pts[sorted->nbPts] = a->pts[0];\n\tsorted->nbPts++;\n\tswf_path_add_type(sorted, 0);\n\tgf_list_add(paths, sorted);\n\n\t/*1- split all paths*/\n\tidx = 1;\n\tfor (i=1; i<a->nbType; i++) {\n\t\tswitch (a->types[i]) {\n\t\tcase 2:\n\t\t\tswf_path_realloc_pts(sorted, 2);\n\t\t\tsorted->pts[sorted->nbPts] = a->pts[idx];\n\t\t\tsorted->pts[sorted->nbPts+1] = a->pts[idx+1];\n\t\t\tsorted->nbPts+=2;\n\t\t\tswf_path_add_type(sorted, 2);\n\t\t\tidx += 2;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tswf_path_realloc_pts(sorted, 1);\n\t\t\tsorted->pts[sorted->nbPts] = a->pts[idx];\n\t\t\tsorted->nbPts+=1;\n\t\t\tswf_path_add_type(sorted, 1);\n\t\t\tidx += 1;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tGF_SAFEALLOC(sorted , SWFPath);\n\t\t\tif (!sorted) return;\n\t\t\tswf_path_realloc_pts(sorted, 1);\n\t\t\tsorted->pts[sorted->nbPts] = a->pts[idx];\n\t\t\tsorted->nbPts++;\n\t\t\tswf_path_add_type(sorted, 0);\n\t\t\tgf_list_add(paths, sorted);\n\t\t\tidx += 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\nrestart:\n\tfor (i=0; i<gf_list_count(paths); i++) {\n\t\tp = (SWFPath*)gf_list_get(paths, i);\n\n\t\tfor (j=i+1; j < gf_list_count(paths); j++) {\n\t\t\tnp = (SWFPath*)gf_list_get(paths, j);\n\n\t\t\t/*check if any next subpath ends at the same place we're starting*/\n\t\t\tif ((np->pts[np->nbPts-1].x == p->pts[0].x) && (np->pts[np->nbPts-1].y == p->pts[0].y)) {\n\t\t\t\tu32 k;\n\t\t\t\tidx = 1;\n\t\t\t\tfor (k=1; k<p->nbType; k++) {\n\t\t\t\t\tswitch (p->types[k]) {\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tswf_path_realloc_pts(np, 2);\n\t\t\t\t\t\tnp->pts[np->nbPts] = p->pts[idx];\n\t\t\t\t\t\tnp->pts[np->nbPts+1] = p->pts[idx+1];\n\t\t\t\t\t\tnp->nbPts+=2;\n\t\t\t\t\t\tswf_path_add_type(np, 2);\n\t\t\t\t\t\tidx += 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tswf_path_realloc_pts(np, 1);\n\t\t\t\t\t\tnp->pts[np->nbPts] = p->pts[idx];\n\t\t\t\t\t\tnp->nbPts+=1;\n\t\t\t\t\t\tswf_path_add_type(np, 1);\n\t\t\t\t\t\tidx += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tassert(0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_free(p->pts);\n\t\t\t\tgf_free(p->types);\n\t\t\t\tgf_free(p);\n\t\t\t\tgf_list_rem(paths, i);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\t/*check if any next subpath starts at the same place we're ending*/\n\t\t\telse if ((p->pts[p->nbPts-1].x == np->pts[0].x) && (p->pts[p->nbPts-1].y == np->pts[0].y)) {\n\t\t\t\tu32 k;\n\t\t\t\tidx = 1;\n\t\t\t\tfor (k=1; k<np->nbType; k++) {\n\t\t\t\t\tswitch (np->types[k]) {\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tswf_path_realloc_pts(p, 2);\n\t\t\t\t\t\tp->pts[p->nbPts] = np->pts[idx];\n\t\t\t\t\t\tp->pts[p->nbPts+1] = np->pts[idx+1];\n\t\t\t\t\t\tp->nbPts+=2;\n\t\t\t\t\t\tswf_path_add_type(p, 2);\n\t\t\t\t\t\tidx += 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tswf_path_realloc_pts(p, 1);\n\t\t\t\t\t\tp->pts[p->nbPts] = np->pts[idx];\n\t\t\t\t\t\tp->nbPts+=1;\n\t\t\t\t\t\tswf_path_add_type(p, 1);\n\t\t\t\t\t\tidx += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tassert(0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_free(np->pts);\n\t\t\t\tgf_free(np->types);\n\t\t\t\tgf_free(np);\n\t\t\t\tgf_list_rem(paths, j);\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*reassemble path*/\n\tgf_free(a->pts);\n\tgf_free(a->types);\n\tmemset(a, 0, sizeof(SWFPath));\n\n\twhile (gf_list_count(paths)) {\n\t\tsorted = (SWFPath*)gf_list_get(paths, 0);\n\t\tif (read->flat_limit==0) {\n\t\t\tswf_append_path(a, sorted);\n\t\t} else {\n\t\t\tBool prev_is_line_to = 0;\n\t\t\tidx = 0;\n\t\t\tfor (i=0; i<sorted->nbType; i++) {\n\t\t\t\tswitch (sorted->types[i]) {\n\t\t\t\tcase 2:\n\t\t\t\t\tswf_path_realloc_pts(a, 2);\n\t\t\t\t\ta->pts[a->nbPts] = sorted->pts[idx];\n\t\t\t\t\ta->pts[a->nbPts+1] = sorted->pts[idx+1];\n\t\t\t\t\ta->nbPts+=2;\n\t\t\t\t\tswf_path_add_type(a, 2);\n\t\t\t\t\tidx += 2;\n\t\t\t\t\tprev_is_line_to = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tif (prev_is_line_to) {\n\t\t\t\t\t\tFixed angle;\n\t\t\t\t\t\tBool flatten = 0;\n\t\t\t\t\t\tSFVec2f v1, v2;\n\t\t\t\t\t\tv1.x = a->pts[a->nbPts-1].x - a->pts[a->nbPts-2].x;\n\t\t\t\t\t\tv1.y = a->pts[a->nbPts-1].y - a->pts[a->nbPts-2].y;\n\t\t\t\t\t\tv2.x = a->pts[a->nbPts-1].x - sorted->pts[idx].x;\n\t\t\t\t\t\tv2.y = a->pts[a->nbPts-1].y - sorted->pts[idx].y;\n\n\t\t\t\t\t\tangle = gf_mulfix(v1.x,v2.x) + gf_mulfix(v1.y,v2.y);\n\t\t\t\t\t\t/*get magnitudes*/\n\t\t\t\t\t\tv1.x = gf_v2d_len(&v1);\n\t\t\t\t\t\tv2.x = gf_v2d_len(&v2);\n\t\t\t\t\t\tif (!v1.x || !v2.x) flatten = 1;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tFixed h_pi = GF_PI / 2;\n\t\t\t\t\t\t\tangle = gf_divfix(angle, gf_mulfix(v1.x, v2.x));\n\t\t\t\t\t\t\tif (angle + FIX_EPSILON >= FIX_ONE) angle = 0;\n\t\t\t\t\t\t\telse if (angle - FIX_EPSILON <= -FIX_ONE) angle = GF_PI;\n\t\t\t\t\t\t\telse angle = gf_acos(angle);\n\n\t\t\t\t\t\t\tif (angle<0) angle += h_pi;\n\t\t\t\t\t\t\tangle = ABSDIFF(angle, h_pi);\n\t\t\t\t\t\t\tif (angle < read->flat_limit) flatten = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flatten) {\n\t\t\t\t\t\t\ta->pts[a->nbPts-1] = sorted->pts[idx];\n\t\t\t\t\t\t\tidx++;\n\t\t\t\t\t\t\tread->flatten_points++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswf_path_realloc_pts(a, 1);\n\t\t\t\t\ta->pts[a->nbPts] = sorted->pts[idx];\n\t\t\t\t\ta->nbPts+=1;\n\t\t\t\t\tswf_path_add_type(a, 1);\n\t\t\t\t\tidx += 1;\n\t\t\t\t\tprev_is_line_to = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0:\n\t\t\t\t\tswf_path_realloc_pts(a, 1);\n\t\t\t\t\ta->pts[a->nbPts] = sorted->pts[idx];\n\t\t\t\t\ta->nbPts+=1;\n\t\t\t\t\tswf_path_add_type(a, 0);\n\t\t\t\t\tidx += 1;\n\t\t\t\t\tprev_is_line_to = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgf_free(sorted->pts);\n\t\tgf_free(sorted->types);\n\t\tgf_free(sorted);\n\t\tgf_list_rem(paths, 0);\n\t}\n\tgf_list_del(paths);\n}\n\n/*\n\tNotes on SWF->BIFS conversion - some ideas taken from libswfdec\n\tA single fillStyle has 2 associated path, one used for left fill, one for right fill\n\tThis is then a 4 step process:\n\t1- blindly parse swf shape, and add point/lines to the proper left/right path\n\t2- for each fillStyles, revert the right path so that it becomes a left path\n\t3- concatenate left and right paths\n\t4- resort all subelements of the final path, making sure moveTo introduced by the SWF coding (due to style changes)\n\tare removed.\n\t\tEx: if path is\n\t\t\tA->C, B->A, C->B = moveTo(A), lineTo(C), moveTo(B), lineTo (A), moveTo(C), lineTo(B)\n\t\twe restort and remove unneeded moves to get\n\t\t\tA->C->B = moveTo(A), lineTo(C), lineTo(B), lineTo(A)\n*/\nstatic GF_Err swf_flush_shape(SWFReader *read, SWFShape *shape, SWFFont *font, Bool last_shape)\n{\n\tGF_Err e;\n\tSWFShapeRec *sf0;\n\tu32 i, count;\n\tcount = gf_list_count(shape->fill_left);\n\tfor (i=0; i<count; i++) {\n\t\tSWFShapeRec *sf1;\n\t\tsf0 = (SWFShapeRec*)gf_list_get(shape->fill_left, i);\n\t\tsf1 = (SWFShapeRec*)gf_list_get(shape->fill_right, i);\n\t\t/*reverse right path*/\n\t\tswf_referse_path(sf1->path);\n\t\t/*concatenate with left path*/\n\t\tswf_append_path(sf0->path, sf1->path);\n\t\t/*resort all path curves*/\n\t\tswf_resort_path(sf0->path, read);\n\t}\n\t/*remove dummy fill_left*/\n\tfor (i=0; i<gf_list_count(shape->fill_left); i++) {\n\t\tsf0 = (SWFShapeRec*)gf_list_get(shape->fill_left, i);\n\t\tif (sf0->path->nbType<=1) {\n\t\t\tgf_list_rem(shape->fill_left, i);\n\t\t\tswf_free_shape_rec(sf0);\n\t\t\ti--;\n\t\t}\n\t}\n\t/*remove dummy lines*/\n\tfor (i=0; i<gf_list_count(shape->lines); i++) {\n\t\tSWFShapeRec *sl = (SWFShapeRec*)gf_list_get(shape->lines, i);\n\t\tif (sl->path->nbType<1) {\n\t\t\tgf_list_rem(shape->lines, i);\n\t\t\tswf_free_shape_rec(sl);\n\t\t\ti--;\n\t\t} else {\n\t\t\tswf_resort_path(sl->path, read);\n\t\t}\n\t}\n\n\t/*now translate a flash shape record into BIFS*/\n\te = read->define_shape(read, shape, font, last_shape);\n\n\t/*delete shape*/\n\tswf_reset_rec_list(shape->fill_left);\n\tswf_reset_rec_list(shape->fill_right);\n\tswf_reset_rec_list(shape->lines);\n\treturn e;\n}\n\nstatic GF_Err swf_parse_shape_def(SWFReader *read, SWFFont *font, u32 revision)\n{\n\tu32 nbBits, comType;\n\ts32 x, y;\n\tSFVec2f orig, ctrl, end;\n\tBool flag;\n\tu32 fill0, fill1, strike;\n\tu32 bits_fill, bits_line;\n\tSWFShape shape;\n\tBool is_empty;\n\tSWFShapeRec *sf0, *sf1, *sl;\n\n\tmemset(&shape, 0, sizeof(SWFShape));\n\tshape.fill_left = gf_list_new();\n\tshape.fill_right = gf_list_new();\n\tshape.lines = gf_list_new();\n\tctrl.x = ctrl.y = 0;\n\tswf_align(read);\n\n\t/*regular shape - get initial styles*/\n\tif (!font) {\n\t\tshape.ID = swf_get_16(read);\n\t\tswf_get_rec(read, &shape.rc);\n\t\tswf_parse_styles(read, revision, &shape, &bits_fill, &bits_line);\n\t}\n\t/*glyph*/\n\telse {\n\t\tbits_fill = swf_read_int(read, 4);\n\t\tbits_line = swf_read_int(read, 4);\n\n\t\t/*fonts are usually defined without styles*/\n\t\tif ((read->tag == SWF_DEFINEFONT) || (read->tag==SWF_DEFINEFONT2)) {\n\t\t\tsf0 = swf_new_shape_rec();\n\t\t\tgf_list_add(shape.fill_right, sf0);\n\t\t\tsf0 = swf_new_shape_rec();\n\t\t\tgf_list_add(shape.fill_left, sf0);\n\t\t\tsf0->solid_col = 0xFF000000;\n\t\t\tsf0->type = 0;\n\t\t}\n\t}\n\n\tis_empty = 1;\n\n\t/*parse all points*/\n\tfill0 = fill1 = strike = 0;\n\tsf0 = sf1 = sl = NULL;\n\tx = y = 0;\n\twhile (1) {\n\t\tflag = swf_read_int(read, 1);\n\t\tif (!flag) {\n\t\t\tBool new_style = swf_read_int(read, 1);\n\t\t\tBool set_strike = swf_read_int(read, 1);\n\t\t\tBool set_fill1 = swf_read_int(read, 1);\n\t\t\tBool set_fill0 = swf_read_int(read, 1);\n\t\t\tBool move_to = swf_read_int(read, 1);\n\t\t\t/*end of shape*/\n\t\t\tif (!new_style && !set_strike && !set_fill0 && !set_fill1 && !move_to) break;\n\n\t\t\tis_empty = 0;\n\n\t\t\tif (move_to) {\n\t\t\t\tnbBits = swf_read_int(read, 5);\n\t\t\t\tx = swf_read_sint(read, nbBits);\n\t\t\t\ty = swf_read_sint(read, nbBits);\n\t\t\t}\n\t\t\tif (set_fill0) fill0 = swf_read_int(read, bits_fill);\n\t\t\tif (set_fill1) fill1 = swf_read_int(read, bits_fill);\n\t\t\tif (set_strike) strike = swf_read_int(read, bits_line);\n\t\t\t/*looks like newStyle does not append styles but define a new set - old styles can no\n\t\t\tlonger be referenced*/\n\t\t\tif (new_style) {\n\t\t\t\t/*flush current shape record into BIFS*/\n\t\t\t\tswf_flush_shape(read, &shape, font, 0);\n\t\t\t\tswf_parse_styles(read, revision, &shape, &bits_fill, &bits_line);\n\t\t\t}\n\n\t\t\tif (read->flags & GF_SM_SWF_NO_LINE) strike = 0;\n\n\t\t\t/*moveto*/\n\t\t\torig.x = FLT2FIX( x * SWF_TWIP_SCALE );\n\t\t\torig.y = FLT2FIX( y * SWF_TWIP_SCALE );\n\t\t\tend = orig;\n\n\t\t\tsf0 = fill0 ? (SWFShapeRec*)gf_list_get(shape.fill_left, fill0 - 1) : NULL;\n\t\t\tsf1 = fill1 ? (SWFShapeRec*)gf_list_get(shape.fill_right, fill1 - 1) : NULL;\n\t\t\tsl = strike ? (SWFShapeRec*)gf_list_get(shape.lines, strike - 1) : NULL;\n\n\t\t\tif (move_to) {\n\t\t\t\tswf_path_add_com(sf0, end, ctrl, 0);\n\t\t\t\tswf_path_add_com(sf1, end, ctrl, 0);\n\t\t\t\tswf_path_add_com(sl, end, ctrl, 0);\n\t\t\t} else {\n\t\t\t\tif (set_fill0) swf_path_add_com(sf0, end, ctrl, 0);\n\t\t\t\tif (set_fill1) swf_path_add_com(sf1, end, ctrl, 0);\n\t\t\t\tif (set_strike) swf_path_add_com(sl, end, ctrl, 0);\n\t\t\t}\n\n\t\t} else {\n\t\t\tflag = swf_read_int(read, 1);\n\t\t\t/*quadratic curve*/\n\t\t\tif (!flag) {\n\t\t\t\tnbBits = 2 + swf_read_int(read, 4);\n\t\t\t\tx += swf_read_sint(read, nbBits);\n\t\t\t\ty += swf_read_sint(read, nbBits);\n\t\t\t\tctrl.x = FLT2FIX( x * SWF_TWIP_SCALE );\n\t\t\t\tctrl.y = FLT2FIX( y * SWF_TWIP_SCALE );\n\t\t\t\tx += swf_read_sint(read, nbBits);\n\t\t\t\ty += swf_read_sint(read, nbBits);\n\t\t\t\tend.x = FLT2FIX( x * SWF_TWIP_SCALE );\n\t\t\t\tend.y = FLT2FIX( y * SWF_TWIP_SCALE );\n\t\t\t\t/*curveTo*/\n\t\t\t\tcomType = 2;\n\t\t\t}\n\t\t\t/*straight line*/\n\t\t\telse {\n\t\t\t\tnbBits = 2 + swf_read_int(read, 4);\n\t\t\t\tflag = swf_read_int(read, 1);\n\t\t\t\tif (flag) {\n\t\t\t\t\tx += swf_read_sint(read, nbBits);\n\t\t\t\t\ty += swf_read_sint(read, nbBits);\n\t\t\t\t} else {\n\t\t\t\t\tflag = swf_read_int(read, 1);\n\t\t\t\t\tif (flag) {\n\t\t\t\t\t\ty += swf_read_sint(read, nbBits);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx += swf_read_sint(read, nbBits);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*lineTo*/\n\t\t\t\tcomType = 1;\n\t\t\t\tend.x = FLT2FIX( x * SWF_TWIP_SCALE );\n\t\t\t\tend.y = FLT2FIX( y * SWF_TWIP_SCALE );\n\t\t\t}\n\t\t\tswf_path_add_com(sf0, end, ctrl, comType);\n\t\t\tswf_path_add_com(sf1, end, ctrl, comType);\n\t\t\tswf_path_add_com(sl, end, ctrl, comType);\n\t\t}\n\t}\n\n\tif (is_empty) {\n\t\tswf_reset_rec_list(shape.fill_left);\n\t\tswf_reset_rec_list(shape.fill_right);\n\t\tswf_reset_rec_list(shape.lines);\n\t}\n\n\tswf_align(read);\n\n\t/*now translate a flash shape record*/\n\tswf_flush_shape(read, &shape, font, 1);\n\n\t/*delete shape*/\n\tswf_reset_rec_list(shape.fill_left);\n\tswf_reset_rec_list(shape.fill_right);\n\tswf_reset_rec_list(shape.lines);\n\tgf_list_del(shape.fill_left);\n\tgf_list_del(shape.fill_right);\n\tgf_list_del(shape.lines);\n\n\treturn GF_OK;\n}\n\nSWFFont *swf_find_font(SWFReader *read, u32 ID)\n{\n\tu32 i, count;\n\tcount = gf_list_count(read->fonts);\n\tfor (i=0; i<count; i++) {\n\t\tSWFFont *ft = (SWFFont *)gf_list_get(read->fonts, i);\n\t\tif (ft->fontID==ID) return ft;\n\t}\n\treturn NULL;\n}\n\nstatic DispShape *swf_get_depth_entry(SWFReader *read, u32 Depth, Bool create)\n{\n\tu32 i;\n\tDispShape *tmp;\n\ti=0;\n\twhile ((tmp = (DispShape *)gf_list_enum(read->display_list, &i))) {\n\t\tif (tmp->depth == Depth) return tmp;\n\t}\n\tif (!create) return NULL;\n\tGF_SAFEALLOC(tmp , DispShape);\n\tif (!tmp) return NULL;\n\ttmp->depth = Depth;\n\ttmp->char_id = 0;\n\tgf_list_add(read->display_list, tmp);\n\n\tmemset(&tmp->mat, 0, sizeof(GF_Matrix2D));\n\ttmp->mat.m[0] = tmp->mat.m[4] = FIX_ONE;\n\n\tmemset(&tmp->cmat, 0, sizeof(GF_ColorMatrix));\n\ttmp->cmat.m[0] = tmp->cmat.m[6] = tmp->cmat.m[12] = tmp->cmat.m[18] = FIX_ONE;\n\ttmp->cmat.identity = 1;\n\treturn tmp;\n}\n\n\nstatic GF_Err swf_func_skip(SWFReader *read)\n{\n\tif (!read) return GF_OK;\n\tswf_skip_data(read, read->size);\n\treturn read->ioerr;\n}\n\nstatic GF_Err swf_set_backcol(SWFReader *read)\n{\n\tu32 col = swf_get_color(read);\n\treturn read->set_backcol(read, col);\n}\n\nstatic GF_Err swf_actions(SWFReader *read, u32 mask, u32 key)\n{\n\tu32 skip_actions = 0;\n\tu8 action_code = swf_read_int(read, 8);\n\tread->has_interact = 1;\n\n\n#define DO_ACT(_code) { act.type = _code; read->action(read, &act); break; }\n\n\twhile (action_code) {\n\t\tu16 length;\n\t\tif (action_code > 0x80) length = swf_get_16(read);\n\t\telse length = 0;\n\n\t\tif (read->no_as || skip_actions) {\n\t\t\tswf_skip_data(read, length);\n\t\t\tif (skip_actions) skip_actions--;\n\t\t} else {\n\t\t\tSWFAction act;\n\t\t\tmemset(&act, 0, sizeof(SWFAction));\n\t\t\tact.button_mask = mask;\n\t\t\tact.button_key = key;\n\n\t\t\tswitch (action_code) {\n\t\t\t/* SWF 3 Action Model */\n\t\t\tcase 0x81: /* goto frame */\n\t\t\t\tact.type = GF_SWF_AS3_GOTO_FRAME;\n\t\t\t\tact.frame_number = swf_get_16(read);\n\t\t\t\tread->action(read, &act);\n\t\t\t\tbreak;\n\t\t\tcase 0x83: /* get URL */\n\t\t\t\tact.type = GF_SWF_AS3_GET_URL;\n\t\t\t\tact.url = swf_get_string(read);\n\t\t\t\tact.target = swf_get_string(read);\n\t\t\t\tread->action(read, &act);\n\t\t\t\tif (act.url) gf_free(act.url);\n\t\t\t\tif (act.target) gf_free(act.target);\n\t\t\t\tbreak;\n\t\t\t/* next frame */\n\t\t\tcase 0x04:\n\t\t\t\tDO_ACT(GF_SWF_AS3_NEXT_FRAME)\n\t\t\t/* previous frame */\n\t\t\tcase 0x05:\n\t\t\t\tDO_ACT(GF_SWF_AS3_PREV_FRAME)\n\t\t\t/* play */\n\t\t\tcase 0x06:\n\t\t\t\tDO_ACT(GF_SWF_AS3_PLAY)\n\t\t\t/* stop */\n\t\t\tcase 0x07:\n\t\t\t\tDO_ACT(GF_SWF_AS3_STOP)\n\t\t\t/* toggle quality */\n\t\t\tcase 0x08:\n\t\t\t\tDO_ACT(GF_SWF_AS3_TOGGLE_QUALITY)\n\t\t\t/* stop sounds*/\n\t\t\tcase 0x09:\n\t\t\t\tDO_ACT(GF_SWF_AS3_STOP_SOUNDS)\n\t\t\t/* wait for frame */\n\t\t\tcase 0x8A:\n\t\t\t\tact.type = GF_SWF_AS3_WAIT_FOR_FRAME;\n\t\t\t\tact.frame_number = swf_get_16(read);\n\t\t\t\tskip_actions = swf_read_int(read, 8);\n\t\t\t\tif (read->action(read, &act)) skip_actions = 0;\n\t\t\t\tbreak;\n\t\t\t/* set target */\n\t\t\tcase 0x8B:\n\t\t\t\tact.type = GF_SWF_AS3_SET_TARGET;\n\t\t\t\tact.target = swf_get_string(read);\n\t\t\t\tread->action(read, &act);\n\t\t\t\tif (act.target) gf_free(act.target);\n\t\t\t\tbreak;\n\t\t\t/* goto label */\n\t\t\tcase 0x8C:\n\t\t\t\tact.type = GF_SWF_AS3_GOTO_LABEL;\n\t\t\t\tact.target = swf_get_string(read);\n\t\t\t\tread->action(read, &act);\n\t\t\t\tif (act.target) gf_free(act.target);\n\t\t\t\tbreak;\n\t\t\tdefault:\n//\t\t\t\tswf_report(read, GF_OK, \"Skipping unsupported action %x\", action_code);\n\t\t\t\tif (length) swf_skip_data(read, length);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (gf_bs_is_overflow(read->bs))\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\taction_code = swf_read_int(read, 8);\n\t}\n#undef DO_ACT\n\n\treturn GF_OK;\n}\n\nstatic GF_Err swf_def_button(SWFReader *read, u32 revision)\n{\n\tSWF_Button button;\n\tBool has_actions;\n\n\tmemset(&button, 0, sizeof(SWF_Button));\n\thas_actions = 0;\n\tbutton.count = 0;\n\tbutton.ID = swf_get_16(read);\n\tif (revision==1) {\n\t\tgf_bs_read_int(read->bs, 7);\n\t\tgf_bs_read_int(read->bs, 1);\n\t\thas_actions = swf_get_16(read);\n\t}\n\twhile (1) {\n\t\tSWF_ButtonRecord *rec = &button.buttons[button.count];\n\t\tgf_bs_read_int(read->bs, 4);\n\t\trec->hitTest = gf_bs_read_int(read->bs, 1);\n\t\trec->down = gf_bs_read_int(read->bs, 1);\n\t\trec->over = gf_bs_read_int(read->bs, 1);\n\t\trec->up = gf_bs_read_int(read->bs, 1);\n\t\tif (!rec->hitTest && !rec->up && !rec->over && !rec->down) break;\n\t\trec->character_id = swf_get_16(read);\n\t\trec->depth = swf_get_16(read);\n\t\tswf_get_matrix(read, &rec->mx);\n\t\tif (revision==1) {\n\t\t\tswf_align(read);\n\t\t\tswf_get_colormatrix(read, &rec->cmx);\n\t\t}\n\t\telse gf_cmx_init(&rec->cmx);\n\t\tgf_bs_align(read->bs);\n\t\tbutton.count++;\n\t\tif (button.count>=40) return GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tread->define_button(read, &button);\n\tif (revision==0) {\n\t\tswf_actions(read, GF_SWF_COND_OVERUP_TO_OVERDOWN, 0);\n\t} else {\n\t\twhile (has_actions) {\n\t\t\tu32 i, mask, key;\n\t\t\thas_actions = swf_get_16(read);\n\t\t\tmask = 0;\n\t\t\tfor (i=0; i<8; i++) {\n\t\t\t\tif (swf_read_int(read, 1))\n\t\t\t\t\tmask |= 1<<i;\n\t\t\t}\n\t\t\tkey = swf_read_int(read, 7);\n\t\t\tif (swf_read_int(read, 1))\n\t\t\t\tmask |= GF_SWF_COND_OVERDOWN_TO_IDLE;\n\n\t\t\tswf_actions(read, mask, key);\n\t\t}\n\t}\n\tread->define_button(read, NULL);\n\treturn GF_OK;\n}\n\nstatic Bool swf_mat_is_identity(GF_Matrix2D *mat)\n{\n\tif (mat->m[0] != FIX_ONE) return 0;\n\tif (mat->m[4] != FIX_ONE) return 0;\n\tif (mat->m[1]) return 0;\n\tif (mat->m[2]) return 0;\n\tif (mat->m[3]) return 0;\n\tif (mat->m[5]) return 0;\n\treturn 1;\n}\n\nstatic GF_Err swf_place_obj(SWFReader *read, u32 revision)\n{\n\tGF_Err e;\n\tu32 shape_id;\n\tu32 ID, bitsize;\n\tu32 clip_depth;\n\tGF_Matrix2D mat;\n\tGF_ColorMatrix cmat;\n\tDispShape *ds;\n\tchar *name;\n\tu32 depth, type;\n\tBool had_depth;\n\t/*SWF flags*/\n\tBool has_clip_actions, has_clip, has_name, has_ratio, has_cmat, has_mat, has_id, has_move;\n\n\tname = NULL;\n\tclip_depth = 0;\n\tID = 0;\n\tdepth = 0;\n\thas_cmat = has_mat = has_move = 0;\n\n\tgf_cmx_init(&cmat);\n\tgf_mx2d_init(mat);\n\t/*place*/\n\ttype = SWF_PLACE;\n\n\t/*SWF 1.0*/\n\tif (revision==0) {\n\t\tID = swf_get_16(read);\n\t\tdepth = swf_get_16(read);\n\t\tbitsize = 32;\n\t\tbitsize += swf_get_matrix(read, &mat);\n\t\thas_mat = 1;\n\t\tbitsize += swf_align(read);\n\t\t/*size exceeds matrix, parse col mat*/\n\t\tif (bitsize < read->size*8) {\n\t\t\tswf_get_colormatrix(read, &cmat);\n\t\t\thas_cmat = 1;\n\t\t\tswf_align(read);\n\t\t}\n\t}\n\t/*SWF 3.0*/\n\telse if (revision==1) {\n\t\t/*reserved*/\n\t\thas_clip_actions = swf_read_int(read, 1);\n\t\thas_clip = swf_read_int(read, 1);\n\t\thas_name = swf_read_int(read, 1);\n\t\thas_ratio = swf_read_int(read, 1);\n\t\thas_cmat = swf_read_int(read, 1);\n\t\thas_mat = swf_read_int(read, 1);\n\t\thas_id = swf_read_int(read, 1);\n\t\thas_move = swf_read_int(read, 1);\n\n\t\tdepth = swf_get_16(read);\n\t\tif (has_id) ID = swf_get_16(read);\n\t\tif (has_mat) {\n\t\t\tswf_get_matrix(read, &mat);\n\t\t\tswf_align(read);\n\t\t}\n\t\tif (has_cmat) {\n\t\t\tswf_align(read);\n\t\t\tswf_get_colormatrix(read, &cmat);\n\t\t\tswf_align(read);\n\t\t}\n\t\tif (has_ratio) /*ratio = */swf_get_16(read);\n\t\tif (has_clip) clip_depth = swf_get_16(read);\n\n\t\tif (has_name) {\n\t\t\tname = swf_get_string(read);\n\t\t\tgf_free(name);\n\t\t}\n\t\tif (has_clip_actions) {\n\t\t\tswf_get_16(read);\n\t\t\tswf_get_16(read);\n\t\t}\n\t\t/*replace*/\n\t\tif (has_id && has_move) type = SWF_REPLACE;\n\t\t/*move*/\n\t\telse if (!has_id && has_move) type = SWF_MOVE;\n\t\t/*place*/\n\t\telse type = SWF_PLACE;\n\t}\n\n\tif (clip_depth) {\n\t\tswf_report(read, GF_NOT_SUPPORTED, \"Clipping not supported - ignoring\");\n\t\treturn GF_OK;\n\t}\n\n\t/*1: check depth of display list*/\n\thad_depth = read->allocate_depth(read, depth);\n\t/*check validity*/\n\tif ((type==SWF_MOVE) && !had_depth) swf_report(read, GF_BAD_PARAM, \"Accessing empty depth level %d\", depth);\n\n\tds = NULL;\n\n\t/*usual case: (re)place depth level*/\n\tswitch (type) {\n\tcase SWF_MOVE:\n\t\tds = swf_get_depth_entry(read, depth, 0);\n\t\tshape_id = ds ? ds->char_id : 0;\n\t\tbreak;\n\tcase SWF_REPLACE:\n\tcase SWF_PLACE:\n\tdefault:\n\t\tshape_id = ID;\n\t\tbreak;\n\t}\n\n\tif (!shape_id) {\n\t\tswf_report(read, GF_BAD_PARAM, \"%s unfound object (ID %d)\", (type==SWF_MOVE) ? \"Moving\" : ((type==SWF_PLACE) ? \"Placing\" : \"Replacing\"), ID);\n\t\treturn GF_OK;\n\t}\n\t/*restore prev matrix if needed*/\n\tif (type==SWF_REPLACE) {\n\t\tif (!ds) ds = swf_get_depth_entry(read, depth, 0);\n\t\tif (ds) {\n\t\t\tif (!has_mat) {\n\t\t\t\tmemcpy(&mat, &ds->mat, sizeof(GF_Matrix2D));\n\t\t\t\thas_mat = 1;\n\t\t\t}\n\t\t\tif (!has_cmat) {\n\t\t\t\tmemcpy(&cmat, &ds->cmat, sizeof(GF_ColorMatrix));\n\t\t\t\thas_cmat = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*check for identity matrices*/\n\tif (has_cmat && cmat.identity) has_cmat = 0;\n\tif (has_mat && swf_mat_is_identity(&mat)) has_mat = 0;\n\n\t/*store in display list*/\n\tds = swf_get_depth_entry(read, depth, 1);\n\te = read->place_obj(read, depth, shape_id, ds->char_id, type,\n\t                    has_mat ? &mat : NULL,\n\t                    has_cmat ? &cmat : NULL,\n\t                    swf_mat_is_identity(&ds->mat) ? NULL : &ds->mat,\n\t                    ds->cmat.identity ? NULL : &ds->cmat);\n\n\t/*remember matrices*/\n\tmemcpy(&ds->mat, &mat, sizeof(GF_Matrix2D));\n\tmemcpy(&ds->cmat, &cmat, sizeof(GF_ColorMatrix));\n\tds->char_id = shape_id;\n\n\tif (e) swf_report(read, e, \"Error %s object ID %d\", (type==SWF_MOVE) ? \"Moving\" : ((type==SWF_PLACE) ? \"Placing\" : \"Replacing\"), shape_id);\n\treturn GF_OK;\n}\n\nstatic GF_Err swf_remove_obj(SWFReader *read, u32 revision)\n{\n\tGF_Err e;\n\tDispShape *ds;\n\tu32 depth;\n\tif (revision==0) swf_get_16(read);\n\tdepth = swf_get_16(read);\n\tds = swf_get_depth_entry(read, depth, 0);\n\t/*this happens if a placeObject has failed*/\n\tif (!ds) return GF_OK;\n\te = read->remove_obj(read, depth, ds->char_id);\n\tds->char_id = 0;\n\treturn e;\n}\n\nstatic GF_Err swf_show_frame(SWFReader *read)\n{\n\tGF_Err e;\n\te = read->show_frame(read);\n\tread->current_frame ++;\n\treturn e;\n}\n\nstatic GF_Err swf_def_font(SWFReader *read, u32 revision)\n{\n\tu32 i, count;\n\tGF_Err e;\n\tSWFFont *ft;\n\tu32 *offset_table = NULL;\n\tu32 start;\n\n\tGF_SAFEALLOC(ft, SWFFont);\n\tif (!ft) return GF_OUT_OF_MEM;\n\n\tft->glyphs = gf_list_new();\n\tft->fontID = swf_get_16(read);\n\te = GF_OK;\n\tgf_list_add(read->fonts, ft);\n\n\tif (revision==0) {\n\t\tstart = swf_get_file_pos(read);\n\n\t\tcount = swf_get_16(read);\n\t\tft->nbGlyphs = count / 2;\n\t\toffset_table = (u32*)gf_malloc(sizeof(u32) * ft->nbGlyphs);\n\t\toffset_table[0] = 0;\n\t\tfor (i=1; i<ft->nbGlyphs; i++) offset_table[i] = swf_get_16(read);\n\n\t\tfor (i=0; i<ft->nbGlyphs; i++) {\n\t\t\tswf_align(read);\n\t\t\te = swf_seek_file_to(read, start + offset_table[i]);\n\t\t\tif (e) break;\n\t\t\tswf_parse_shape_def(read, ft, 0);\n\t\t}\n\t\tgf_free(offset_table);\n\t\tif (e) return e;\n\t} else if (revision==1) {\n\t\tSWFRec rc;\n\t\tBool wide_offset, wide_codes;\n\t\tu32 code_offset, checkpos;\n\t\tft->has_layout = swf_read_int(read, 1);\n\t\tft->has_shiftJIS = swf_read_int(read, 1);\n\t\tft->is_unicode = swf_read_int(read, 1);\n\t\tft->is_ansi = swf_read_int(read, 1);\n\t\twide_offset = swf_read_int(read, 1);\n\t\twide_codes = swf_read_int(read, 1);\n\t\tft->is_italic = swf_read_int(read, 1);\n\t\tft->is_bold = swf_read_int(read, 1);\n\t\tswf_read_int(read, 8);\n\t\tcount = swf_read_int(read, 8);\n\t\tft->fontName = (char*)gf_malloc(sizeof(u8)*count+1);\n\t\tft->fontName[count] = 0;\n\t\tfor (i=0; i<count; i++) ft->fontName[i] = swf_read_int(read, 8);\n\n\t\tft->nbGlyphs = swf_get_16(read);\n\t\tstart = swf_get_file_pos(read);\n\n\t\tif (ft->nbGlyphs) {\n\t\t\toffset_table = (u32*)gf_malloc(sizeof(u32) * ft->nbGlyphs);\n\t\t\tfor (i=0; i<ft->nbGlyphs; i++) {\n\t\t\t\tif (wide_offset) offset_table[i] = swf_get_32(read);\n\t\t\t\telse offset_table[i] = swf_get_16(read);\n\t\t\t}\n\t\t}\n\n\t\tif (wide_offset) {\n\t\t\tcode_offset = swf_get_32(read);\n\t\t} else {\n\t\t\tcode_offset = swf_get_16(read);\n\t\t}\n\n\t\tif (ft->nbGlyphs) {\n\t\t\tfor (i=0; i<ft->nbGlyphs; i++) {\n\t\t\t\tswf_align(read);\n\t\t\t\te = swf_seek_file_to(read, start + offset_table[i]);\n\t\t\t\tif (e) break;\n\n\t\t\t\tswf_parse_shape_def(read, ft, 0);\n\t\t\t}\n\t\t\tgf_free(offset_table);\n\t\t\tif (e) return e;\n\n\t\t\tcheckpos = swf_get_file_pos(read);\n\t\t\tif (checkpos != start + code_offset) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[SWF Parsing] bad code offset in font\\n\"));\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\n\t\t\tft->glyph_codes = (u16*)gf_malloc(sizeof(u16) * ft->nbGlyphs);\n\t\t\tfor (i=0; i<ft->nbGlyphs; i++) {\n\t\t\t\tif (wide_codes) ft->glyph_codes[i] = swf_get_16(read);\n\t\t\t\telse ft->glyph_codes[i] = swf_read_int(read, 8);\n\t\t\t}\n\t\t}\n\t\tif (ft->has_layout) {\n\t\t\tft->ascent = swf_get_s16(read);\n\t\t\tft->descent = swf_get_s16(read);\n\t\t\tft->leading = swf_get_s16(read);\n\t\t\tif (ft->nbGlyphs) {\n\t\t\t\tft->glyph_adv = (s16*)gf_malloc(sizeof(s16) * ft->nbGlyphs);\n\t\t\t\tfor (i=0; i<ft->nbGlyphs; i++) ft->glyph_adv[i] = swf_get_s16(read);\n\t\t\t\tfor (i=0; i<ft->nbGlyphs; i++) swf_get_rec(read, &rc);\n\t\t\t}\n\t\t\t/*kerning info*/\n\t\t\tcount = swf_get_16(read);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tif (wide_codes) {\n\t\t\t\t\tswf_get_16(read);\n\t\t\t\t\tswf_get_16(read);\n\t\t\t\t} else {\n\t\t\t\t\tswf_read_int(read, 8);\n\t\t\t\t\tswf_read_int(read, 8);\n\t\t\t\t}\n\t\t\t\tswf_get_s16(read);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err swf_def_font_info(SWFReader *read)\n{\n\tSWFFont *ft;\n\tBool wide_chars;\n\tu32 i, count;\n\n\ti = swf_get_16(read);\n\tft = swf_find_font(read, i);\n\tif (!ft) {\n\t\tswf_report(read, GF_BAD_PARAM, \"Cannot locate font ID %d\", i);\n\t\treturn GF_BAD_PARAM;\n\t}\n\t/*overwrite font info*/\n\tif (ft->fontName) gf_free(ft->fontName);\n\tcount = swf_read_int(read, 8);\n\tft->fontName = (char*)gf_malloc(sizeof(char) * (count+1));\n\tft->fontName[count] = 0;\n\tfor (i=0; i<count; i++) ft->fontName[i] = swf_read_int(read, 8);\n\tswf_read_int(read, 2);\n\tft->is_unicode = swf_read_int(read, 1);\n\tft->has_shiftJIS = swf_read_int(read, 1);\n\tft->is_ansi = swf_read_int(read, 1);\n\tft->is_italic = swf_read_int(read, 1);\n\tft->is_bold = swf_read_int(read, 1);\n\t/*TODO - this should be remapped to a font data stream, we currently only assume the glyph code\n\ttable is the same as the original font file...*/\n\twide_chars = swf_read_int(read, 1);\n\tif (ft->glyph_codes) gf_free(ft->glyph_codes);\n\tft->glyph_codes = (u16*)gf_malloc(sizeof(u16) * ft->nbGlyphs);\n\n\tfor (i=0; i<ft->nbGlyphs; i++) {\n\t\tif (wide_chars) ft->glyph_codes[i] = swf_get_16(read);\n\t\telse ft->glyph_codes[i] = swf_read_int(read, 8);\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err swf_def_text(SWFReader *read, u32 revision)\n{\n\tSWFRec rc;\n\tSWFText txt;\n\tBool flag;\n\tu32 nbits_adv, nbits_glyph, i, col, fontID, count, font_height;\n\tFixed offX, offY;\n\tGF_Err e;\n\n\ttxt.ID = swf_get_16(read);\n\tswf_get_rec(read, &rc);\n\tswf_get_matrix(read, &txt.mat);\n\ttxt.text = gf_list_new();\n\n\tswf_align(read);\n\tnbits_glyph = swf_read_int(read, 8);\n\tnbits_adv = swf_read_int(read, 8);\n\tfontID = 0;\n\toffX = offY = 0;\n\tfont_height = 0;\n\tcol = 0xFF000000;\n\te = GF_OK;\n\n\twhile (1) {\n\t\tflag = swf_read_int(read, 1);\n\t\t/*regular glyph record*/\n\t\tif (!flag) {\n\t\t\tSWFGlyphRec *gr;\n\t\t\tcount = swf_read_int(read, 7);\n\t\t\tif (!count) break;\n\n\t\t\tif (!fontID) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tswf_report(read, GF_BAD_PARAM, \"Defining text %d without assigning font\", fontID);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tGF_SAFEALLOC(gr, SWFGlyphRec);\n\t\t\tif (!gr) return GF_OUT_OF_MEM;\n\n\t\t\tgf_list_add(txt.text, gr);\n\t\t\tgr->fontID = fontID;\n\t\t\tgr->fontSize = font_height;\n\t\t\tgr->col = col;\n\t\t\tgr->orig_x = offX;\n\t\t\tgr->orig_y = offY;\n\t\t\tgr->nbGlyphs = count;\n\t\t\tgr->indexes = (u32*)gf_malloc(sizeof(u32) * gr->nbGlyphs);\n\t\t\tgr->dx = (Fixed*)gf_malloc(sizeof(Fixed) * gr->nbGlyphs);\n\t\t\tfor (i=0; i<gr->nbGlyphs; i++) {\n\t\t\t\tgr->indexes[i] = swf_read_int(read, nbits_glyph);\n\t\t\t\tgr->dx[i] = FLT2FIX( swf_read_int(read, nbits_adv) * SWF_TWIP_SCALE );\n\t\t\t}\n\t\t\tswf_align(read);\n\t\t}\n\t\t/*text state change*/\n\t\telse {\n\t\t\tBool has_font, has_col, has_y_off, has_x_off;\n\t\t\t/*reserved*/\n\t\t\tswf_read_int(read, 3);\n\t\t\thas_font = swf_read_int(read, 1);\n\t\t\thas_col = swf_read_int(read, 1);\n\t\t\thas_y_off = swf_read_int(read, 1);\n\t\t\thas_x_off = swf_read_int(read, 1);\n\n\t\t\t/*end of rec*/\n\t\t\tif (!has_font && !has_col && !has_y_off && !has_x_off) break;\n\t\t\tif (has_font) fontID = swf_get_16(read);\n\t\t\tif (has_col) {\n\t\t\t\tif (revision==0) col = swf_get_color(read);\n\t\t\t\telse col = swf_get_argb(read);\n\t\t\t}\n\t\t\t/*openSWF spec seems to have wrong order here*/\n\t\t\tif (has_x_off) offX = FLT2FIX( swf_get_s16(read) * SWF_TWIP_SCALE );\n\t\t\tif (has_y_off) offY = FLT2FIX( swf_get_s16(read) * SWF_TWIP_SCALE );\n\t\t\tif (has_font) font_height = swf_get_16(read);\n\t\t}\n\t}\n\n\tif (e) goto exit;\n\n\tif (! (read->flags & GF_SM_SWF_NO_TEXT) ) {\n\t\te = read->define_text(read, &txt);\n\t}\n\nexit:\n\twhile (gf_list_count(txt.text)) {\n\t\tSWFGlyphRec *gr = (SWFGlyphRec *)gf_list_get(txt.text, 0);\n\t\tgf_list_rem(txt.text, 0);\n\t\tif (gr->indexes) gf_free(gr->indexes);\n\t\tif (gr->dx) gf_free(gr->dx);\n\t\tgf_free(gr);\n\t}\n\tgf_list_del(txt.text);\n\n\treturn e;\n}\n\n\nstatic GF_Err swf_def_edit_text(SWFReader *read)\n{\n\tGF_Err e;\n\tSWFEditText txt;\n\tchar *var_name;\n\tBool has_text, has_text_color, has_max_length, has_font;\n\n\tmemset(&txt, 0, sizeof(SWFEditText));\n\ttxt.color = 0xFF000000;\n\n\ttxt.ID = swf_get_16(read);\n\tswf_get_rec(read, &txt.bounds);\n\tswf_align(read);\n\n\thas_text = swf_read_int(read, 1);\n\ttxt.word_wrap = swf_read_int(read, 1);\n\ttxt.multiline = swf_read_int(read, 1);\n\ttxt.password = swf_read_int(read, 1);\n\ttxt.read_only = swf_read_int(read, 1);\n\thas_text_color = swf_read_int(read, 1);\n\thas_max_length = swf_read_int(read, 1);\n\thas_font = swf_read_int(read, 1);\n\t/*reserved*/swf_read_int(read, 1);\n\ttxt.auto_size = swf_read_int(read, 1);\n\ttxt.has_layout = swf_read_int(read, 1);\n\ttxt.no_select = swf_read_int(read, 1);\n\ttxt.border = swf_read_int(read, 1);\n\t/*reserved*/swf_read_int(read, 1);\n\ttxt.html = swf_read_int(read, 1);\n\ttxt.outlines = swf_read_int(read, 1);\n\n\tif (has_font) {\n\t\ttxt.fontID = swf_get_16(read);\n\t\ttxt.font_height = FLT2FIX( swf_get_16(read) * SWF_TWIP_SCALE );\n\t}\n\tif (has_text_color) txt.color = swf_get_argb(read);\n\tif (has_max_length) txt.max_length = FLT2FIX( swf_get_16(read) * SWF_TWIP_SCALE );\n\n\tif (txt.has_layout) {\n\t\ttxt.align = swf_read_int(read, 8);\n\t\ttxt.left = FLT2FIX( swf_get_16(read) * SWF_TWIP_SCALE );\n\t\ttxt.right = FLT2FIX( swf_get_16(read) * SWF_TWIP_SCALE );\n\t\ttxt.indent = FLT2FIX( swf_get_16(read) * SWF_TWIP_SCALE );\n\t\ttxt.leading = FLT2FIX( swf_get_16(read) * SWF_TWIP_SCALE );\n\t}\n\tvar_name = swf_get_string(read);\n\tif (has_text) txt.init_value = swf_get_string(read);\n\n\te = GF_OK;\n\tif (! (read->flags & GF_SM_SWF_NO_TEXT) ) {\n\t\te = read->define_edit_text(read, &txt);\n\t}\n\tgf_free(var_name);\n\tif (txt.init_value) gf_free(txt.init_value);\n\n\treturn e;\n}\n\nstatic void swf_delete_sound_stream(SWFReader *read)\n{\n\tif (!read->sound_stream) return;\n\tif (read->sound_stream->output) gf_fclose(read->sound_stream->output);\n\tif (read->sound_stream->szFileName) gf_free(read->sound_stream->szFileName);\n\tgf_free(read->sound_stream);\n\tread->sound_stream = NULL;\n}\n\nstatic GF_Err swf_def_sprite(SWFReader *read)\n{\n\tGF_Err e;\n\tGF_List *prev_dlist;\n\tu32 frame_count;\n\tBool prev_sprite;\n\tu32 prev_frame, prev_depth;\n\tSWFSound *snd;\n\n\tprev_sprite = read->current_sprite_id;\n\tread->current_sprite_id = swf_get_16(read);\n\tframe_count = swf_get_16(read);\n\n\t/*store frame state*/\n\tprev_frame = read->current_frame;\n\tread->current_frame = 0;\n\t/*store soundStream state*/\n\tsnd = read->sound_stream;\n\tread->sound_stream = NULL;\n\t/*store depth state*/\n\tprev_depth = read->max_depth;\n\tread->max_depth = 0;\n\n\tprev_dlist = read->display_list;\n\tread->display_list = gf_list_new();\n\n\te = read->define_sprite(read, frame_count);\n\tif (e) return e;\n\n\t/*close sprite soundStream*/\n\tswf_delete_sound_stream(read);\n\t/*restore sound stream*/\n\tread->sound_stream = snd;\n\tread->max_depth = prev_depth;\n\n\twhile (gf_list_count(read->display_list)) {\n\t\tDispShape *s = (DispShape *)gf_list_get(read->display_list, 0);\n\t\tgf_list_rem(read->display_list, 0);\n\t\tgf_free(s);\n\t}\n\tgf_list_del(read->display_list);\n\tread->display_list = prev_dlist;\n\n\tread->current_frame = prev_frame;\n\tread->current_sprite_id = prev_sprite;\n\n\tread->tag = SWF_DEFINESPRITE;\n\treturn GF_OK;\n}\n\nstatic GF_Err swf_def_sound(SWFReader *read)\n{\n\tSWFSound *snd;\n\tGF_SAFEALLOC(snd , SWFSound);\n\tif (!snd) return GF_OUT_OF_MEM;\n\tsnd->ID = swf_get_16(read);\n\tsnd->format = swf_read_int(read, 4);\n\tsnd->sound_rate = swf_read_int(read, 2);\n\tsnd->bits_per_sample = swf_read_int(read, 1) ? 16 : 8;\n\tsnd->stereo = swf_read_int(read, 1);\n\tsnd->sample_count = swf_get_32(read);\n\n\tswitch (snd->format) {\n\t/*raw PCM*/\n\tcase 0:\n\t\tswf_report(read, GF_NOT_SUPPORTED, \"Raw PCM Audio not supported\");\n\t\tgf_free(snd);\n\t\tbreak;\n\t/*ADPCM*/\n\tcase 1:\n\t\tswf_report(read, GF_NOT_SUPPORTED, \"AD-PCM Audio not supported\");\n\t\tgf_free(snd);\n\t\tbreak;\n\t/*MP3*/\n\tcase 2:\n\t{\n\t\tchar szName[1024];\n\t\tu32 alloc_size, tot_size;\n\t\tchar *frame;\n\t\tGF_Err e=GF_OK;\n\n\t\tsprintf(szName, \"swf_sound_%d.mp3\", snd->ID);\n\t\tif (read->localPath) {\n\t\t\tsnd->szFileName = (char*)gf_malloc(sizeof(char)*GF_MAX_PATH);\n\t\t\tstrcpy(snd->szFileName, read->localPath);\n\t\t\tstrcat(snd->szFileName, szName);\n\t\t} else {\n\t\t\tsnd->szFileName = gf_strdup(szName);\n\t\t}\n\t\tsnd->output = gf_fopen(snd->szFileName, \"wb\");\n\n\t\talloc_size = 4096;\n\t\tframe = (char*)gf_malloc(sizeof(char)*4096);\n\t\t/*snd->frame_delay_ms =*/ swf_get_16(read);\n\t\tsnd->frame_delay_ms = read->current_frame*1000;\n\t\tsnd->frame_delay_ms /= read->frame_rate;\n\t\ttot_size = 9;\n\t\t/*parse all frames*/\n\t\twhile (tot_size<read->size) {\n\t\t\tu32 toread = read->size - tot_size;\n\t\t\tif (toread>alloc_size) toread = alloc_size;\n\t\t\tswf_read_data(read, frame, toread);\n\t\t\tif (gf_fwrite(frame, sizeof(char)*toread, snd->output) != toread)\n\t\t\t\te = GF_IO_ERR;\n\t\t\ttot_size += toread;\n\t\t}\n\n\t\tgf_free(frame);\n\t\tif (e) {\n\t\t\tgf_free(snd);\n\t\t\treturn e;\n\t\t}\n\t\treturn gf_list_add(read->sounds, snd);\n\t}\n\tcase 3:\n\t\tswf_report(read, GF_NOT_SUPPORTED, \"Unrecognized sound format\");\n\t\tgf_free(snd);\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n\ntypedef struct\n{\n\tu32 sync_flags;\n\tu32 in_point, out_point;\n\tu32 nb_loops;\n} SoundInfo;\n\nstatic SoundInfo swf_skip_soundinfo(SWFReader *read)\n{\n\tSoundInfo si;\n\tu32 sync_flags = swf_read_int(read, 4);\n\tBool has_env = swf_read_int(read, 1);\n\tBool has_loops = swf_read_int(read, 1);\n\tBool has_out_pt = swf_read_int(read, 1);\n\tBool has_in_pt = swf_read_int(read, 1);\n\n\tmemset(&si, 0, sizeof(SoundInfo));\n\tsi.sync_flags = sync_flags;\n\tif (has_in_pt) si.in_point = swf_get_32(read);\n\tif (has_out_pt) si.out_point = swf_get_32(read);\n\tif (has_loops) si.nb_loops = swf_get_16(read);\n\t/*we ignore the envelope*/\n\tif (has_env) {\n\t\tu32 i;\n\t\tu32 nb_ctrl = swf_read_int(read, 8);\n\t\tfor (i=0; i<nb_ctrl; i++) {\n\t\t\tswf_read_int(read, 32);\t/*mark44*/\n\t\t\tswf_read_int(read, 16);\t/*l0*/\n\t\t\tswf_read_int(read, 16);\t/*l1*/\n\t\t}\n\t}\n\treturn si;\n}\n\nstatic SWFSound *sndswf_get_sound(SWFReader *read, u32 ID)\n{\n\tu32 i;\n\tSWFSound *snd;\n\ti=0;\n\twhile ((snd = (SWFSound *)gf_list_enum(read->sounds, &i))) {\n\t\tif (snd->ID==ID) return snd;\n\t}\n\treturn NULL;\n}\n\nstatic GF_Err swf_start_sound(SWFReader *read)\n{\n\tSWFSound *snd;\n\tu32 ID = swf_get_16(read);\n\tSoundInfo si;\n\tsi = swf_skip_soundinfo(read);\n\n\tsnd = sndswf_get_sound(read, ID);\n\tif (!snd) {\n\t\tswf_report(read, GF_BAD_PARAM, \"Cannot find sound with ID %d\", ID);\n\t\treturn GF_OK;\n\t}\n\tif (!snd->is_setup) {\n\t\tGF_Err e = read->setup_sound(read, snd, 0);\n\t\tif (e) return e;\n\t\tsnd->is_setup = 1;\n\t}\n\treturn read->start_sound(read, snd, (si.sync_flags & 0x2) ? 1 : 0);\n}\n\nstatic GF_Err swf_soundstream_hdr(SWFReader *read)\n{\n\tchar szName[1024];\n\tSWFSound *snd;\n\n\tif (read->sound_stream) {\n\t\tswf_report(read, GF_BAD_PARAM, \"More than one sound stream for current timeline!!\");\n\t\treturn swf_func_skip(read);\n\t}\n\n\tGF_SAFEALLOC(snd, SWFSound);\n\tif (!snd) return GF_OUT_OF_MEM;\n\n\t/*rec_mix = */swf_read_int(read, 8);\n\t/*0: uncompressed, 1: ADPCM, 2: MP3*/\n\tsnd->format = swf_read_int(read, 4);\n\t/*0: 5.5k, 1: 11k, 2: 2: 22k, 3: 44k*/\n\tsnd->sound_rate = swf_read_int(read, 2);\n\t/*0: 8 bit, 1: 16 bit*/\n\tsnd->bits_per_sample = swf_read_int(read, 1) ? 16 : 8;\n\t/*0: mono, 8 1: stereo*/\n\tsnd->stereo = swf_read_int(read, 1);\n\t/*samplesperframe hint*/\n\tswf_read_int(read, 16);\n\n\tswitch (snd->format) {\n\t/*raw PCM*/\n\tcase 0:\n\t\tswf_report(read, GF_NOT_SUPPORTED, \"Raw PCM Audio not supported\");\n\t\tgf_free(snd);\n\t\tbreak;\n\t/*ADPCM*/\n\tcase 1:\n\t\tswf_report(read, GF_NOT_SUPPORTED, \"AD-PCM Audio not supported\");\n\t\tgf_free(snd);\n\t\tbreak;\n\t/*MP3*/\n\tcase 2:\n\t\tread->sound_stream = snd;\n\t\tif (read->localPath) {\n\t\t\tsprintf(szName, \"%s/swf_soundstream_%d.mp3\", read->localPath, read->current_sprite_id);\n\t\t} else {\n\t\t\tsprintf(szName, \"swf_soundstream_%d.mp3\", read->current_sprite_id);\n\t\t}\n\t\tread->sound_stream->szFileName = gf_strdup(szName);\n\t\tread->setup_sound(read, read->sound_stream, 0);\n\t\tbreak;\n\tcase 3:\n\t\tswf_report(read, GF_NOT_SUPPORTED, \"Unrecognized sound format\");\n\t\tgf_free(snd);\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err swf_soundstream_block(SWFReader *read)\n{\n#ifdef GPAC_DISABLE_AV_PARSERS\n\treturn swf_func_skip(read);\n#else\n\tunsigned char bytes[4];\n\tu32 hdr, alloc_size, size, tot_size, samplesPerFrame;\n\tchar *frame;\n\tGF_Err e = GF_OK;\n\n\t/*note we're doing only MP3*/\n\tif (!read->sound_stream) return swf_func_skip(read);\n\n\tsamplesPerFrame = swf_get_16(read);\n\t/*delay = */swf_get_16(read);\n\n\tif (!read->sound_stream->is_setup) {\n\n\t\t/*error at setup*/\n\t\tif (!read->sound_stream->output) {\n\t\t\tread->sound_stream->output = gf_fopen(read->sound_stream->szFileName, \"wb\");\n\t\t\tif (!read->sound_stream->output)\n\t\t\t\treturn swf_func_skip(read);\n\t\t}\n\t\t/*store TS of first AU*/\n\t\tread->sound_stream->frame_delay_ms = read->current_frame*1000;\n\t\tread->sound_stream->frame_delay_ms /= read->frame_rate;\n\t\tread->setup_sound(read, read->sound_stream, 1);\n\t\tread->sound_stream->is_setup = 1;\n\t}\n\n\tif (!samplesPerFrame) return GF_OK;\n\n\talloc_size = 1;\n\tframe = (char*)gf_malloc(sizeof(char));\n\ttot_size = 4;\n\t/*parse all frames*/\n\twhile (1) {\n\t\tbytes[0] = swf_read_int(read, 8);\n\t\tbytes[1] = swf_read_int(read, 8);\n\t\tbytes[2] = swf_read_int(read, 8);\n\t\tbytes[3] = swf_read_int(read, 8);\n\t\thdr = GF_4CC(bytes[0], bytes[1], bytes[2], bytes[3]);\n\t\tsize = gf_mp3_frame_size(hdr);\n\t\tif (alloc_size<size-4) {\n\t\t\tframe = (char*)gf_realloc(frame, sizeof(char)*(size-4));\n\t\t\talloc_size = size-4;\n\t\t}\n\t\t/*watchout for truncated framesif */\n\t\tif (tot_size + size >= read->size) size = read->size - tot_size;\n\n\t\tswf_read_data(read, frame, size-4);\n\t\tif (gf_fwrite(bytes, sizeof(char)*4, read->sound_stream->output)!=4) e = GF_IO_ERR;\n\t\tif (gf_fwrite(frame, sizeof(char)*(size-4), read->sound_stream->output) != size-4) e = GF_IO_ERR;\n\t\tif (tot_size + size >= read->size) break;\n\t\ttot_size += size;\n\t}\n\tgf_free(frame);\n\treturn e;\n#endif\n}\n\nstatic GF_Err swf_def_hdr_jpeg(SWFReader *read)\n{\n\tif (!read) return GF_OK;\n\tif (read->jpeg_hdr) {\n\t\tswf_report(read, GF_NON_COMPLIANT_BITSTREAM, \"JPEG Table already defined in file\");\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tread->jpeg_hdr_size = read->size;\n\tif (read->size) {\n\t\tread->jpeg_hdr = gf_malloc(sizeof(char)*read->size);\n\t\tswf_read_data(read, (char *) read->jpeg_hdr, read->size);\n\t}\n\treturn GF_OK;\n}\n\n\nstatic GF_Err swf_def_bits_jpeg(SWFReader *read, u32 version)\n{\n\tu32 ID;\n\tFILE *file = NULL;\n\tchar szName[1024];\n\tu8 *buf;\n\tu32 skip = 0;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tu32 AlphaPlaneSize = 0;\n#endif\n\tu32 size = read->size;\n\tGF_Err e=GF_OK;\n\n\tID = swf_get_16(read);\n\tsize -= 2;\n\tif (version==3) {\n\t\tu32 offset = swf_get_32(read);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tsize -= 4;\n\t\tAlphaPlaneSize = size - offset;\n#endif\n\t\tsize = offset;\n\t}\n\n\t/*dump file*/\n\tif (read->localPath) {\n\t\tsprintf(szName, \"%s/swf_jpeg_%d.jpg\", read->localPath, ID);\n\t} else {\n\t\tsprintf(szName, \"swf_jpeg_%d.jpg\", ID);\n\t}\n\n\tif (version!=3)\n\t\tfile = gf_fopen(szName, \"wb\");\n\n\tif (version==1 && read->jpeg_hdr_size) {\n\t\t/*remove JPEG EOI*/\n\t\tif (gf_fwrite(read->jpeg_hdr, read->jpeg_hdr_size-2, file)!=read->jpeg_hdr_size-2)\n\t\t\treturn GF_IO_ERR;\n\t\t/*remove JPEG SOI*/\n\t\tswf_get_16(read);\n\t\tsize-=2;\n\t}\n\tbuf = gf_malloc(sizeof(u8)*size);\n\tif (!buf) return GF_OUT_OF_MEM;\n\tswf_read_data(read, (char *) buf, size);\n\tif (version==1) {\n\t\tif (gf_fwrite(buf, size, file)!=size)\n\t\t\te = GF_IO_ERR;\n\t} else {\n\t\tu32 i;\n\t\tfor (i=0; i<size; i++) {\n\t\t\tif ((i+4<size)\n\t\t\t        && (buf[i]==0xFF) && (buf[i+1]==0xD9)\n\t\t\t        && (buf[i+2]==0xFF) && (buf[i+3]==0xD8)\n\t\t\t   ) {\n\t\t\t\tmemmove(buf+i, buf+i+4, sizeof(char)*(size-i-4));\n\t\t\t\tsize -= 4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ((buf[0]==0xFF) && (buf[1]==0xD8) && (buf[2]==0xFF) && (buf[3]==0xD8)) {\n\t\t\tskip = 2;\n\t\t}\n\t\tif (version==2) {\n\t\t\tif (gf_fwrite(buf+skip, size-skip, file) != size-skip) e = GF_IO_ERR;\n\t\t}\n\t}\n\tif (version!=3)\n\t\tgf_fclose(file);\n\n\tif (e) {\n\t\tgf_free(buf);\n\t\treturn e;\n\t}\n\n\tif (version==3) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tchar *dst, *raw;\n\t\tu32 codecid;\n\t\tu32 osize, w, h, j, pf;\n\t\tGF_BitStream *bs;\n\n\t\t/*decompress jpeg*/\n\t\tbs = gf_bs_new( (char *) buf+skip, size-skip, GF_BITSTREAM_READ);\n\t\tgf_img_parse(bs, &codecid, &w, &h, NULL, NULL);\n\t\tgf_bs_del(bs);\n\n\t\tosize = w*h*4;\n\t\traw = gf_malloc(sizeof(char)*osize);\n\t\tif (!raw) {\n\t\t\tgf_free(buf);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tmemset(raw, 0, sizeof(char)*osize);\n\t\te = gf_img_jpeg_dec(buf+skip, size-skip, &w, &h, &pf, raw, &osize, 4);\n\t\tif (e != GF_OK) {\n\t\t\tswf_report(read, e, \"Cannot decode JPEG image\");\n\t\t}\n\n\t\t/*read alpha map and decompress it*/\n\t\tif (size<AlphaPlaneSize) buf = gf_realloc(buf, sizeof(u8)*AlphaPlaneSize);\n\t\tswf_read_data(read, (char *) buf, AlphaPlaneSize);\n\n\t\tosize = w*h;\n\t\tdst = gf_malloc(sizeof(char)*osize);\n\t\tuncompress((Bytef *) dst, (uLongf *) &osize, buf, AlphaPlaneSize);\n\t\t/*write alpha channel*/\n\t\tfor (j=0; j<osize; j++) {\n\t\t\traw[4*j + 3] = dst[j];\n\t\t}\n\t\tgf_free(dst);\n\n\t\t/*write png*/\n\t\tif (read->localPath) {\n\t\t\tsprintf(szName, \"%s/swf_png_%d.png\", read->localPath, ID);\n\t\t} else {\n\t\t\tsprintf(szName, \"swf_png_%d.png\", ID);\n\t\t}\n\n\t\tosize = w*h*4;\n\t\tbuf = gf_realloc(buf, sizeof(char)*osize);\n\t\tgf_img_png_enc(raw, w, h, h*4, GF_PIXEL_RGBA, (char *)buf, &osize);\n\n\t\tfile = gf_fopen(szName, \"wb\");\n\t\tif (gf_fwrite(buf, osize, file)!=osize) e = GF_IO_ERR;\n\t\tgf_fclose(file);\n\n\t\tgf_free(raw);\n#endif //GPAC_DISABLE_AV_PARSERS\n\t}\n\tgf_free(buf);\n\tif (e) return e;\n\n\treturn read->setup_image(read, ID, szName);\n}\n\n\nstatic const char *swf_get_tag_name(u32 tag)\n{\n\tswitch (tag) {\n\tcase SWF_END:\n\t\treturn \"End\";\n\tcase SWF_SHOWFRAME:\n\t\treturn \"ShowFrame\";\n\tcase SWF_DEFINESHAPE:\n\t\treturn \"DefineShape\";\n\tcase SWF_FREECHARACTER:\n\t\treturn \"FreeCharacter\";\n\tcase SWF_PLACEOBJECT:\n\t\treturn \"PlaceObject\";\n\tcase SWF_REMOVEOBJECT:\n\t\treturn \"RemoveObject\";\n\tcase SWF_DEFINEBITSJPEG:\n\t\treturn \"DefineBitsJPEG\";\n\tcase SWF_DEFINEBUTTON:\n\t\treturn \"DefineButton\";\n\tcase SWF_JPEGTABLES:\n\t\treturn \"JPEGTables\";\n\tcase SWF_SETBACKGROUNDCOLOR:\n\t\treturn \"SetBackgroundColor\";\n\tcase SWF_DEFINEFONT:\n\t\treturn \"DefineFont\";\n\tcase SWF_DEFINETEXT:\n\t\treturn \"DefineText\";\n\tcase SWF_DOACTION:\n\t\treturn \"DoAction\";\n\tcase SWF_DEFINEFONTINFO:\n\t\treturn \"DefineFontInfo\";\n\tcase SWF_DEFINESOUND:\n\t\treturn \"DefineSound\";\n\tcase SWF_STARTSOUND:\n\t\treturn \"StartSound\";\n\tcase SWF_DEFINEBUTTONSOUND:\n\t\treturn \"DefineButtonSound\";\n\tcase SWF_SOUNDSTREAMHEAD:\n\t\treturn \"SoundStreamHead\";\n\tcase SWF_SOUNDSTREAMBLOCK:\n\t\treturn \"SoundStreamBlock\";\n\tcase SWF_DEFINEBITSLOSSLESS:\n\t\treturn \"DefineBitsLossless\";\n\tcase SWF_DEFINEBITSJPEG2:\n\t\treturn \"DefineBitsJPEG2\";\n\tcase SWF_DEFINESHAPE2:\n\t\treturn \"DefineShape2\";\n\tcase SWF_DEFINEBUTTONCXFORM:\n\t\treturn \"DefineButtonCXForm\";\n\tcase SWF_PROTECT:\n\t\treturn \"Protect\";\n\tcase SWF_PLACEOBJECT2:\n\t\treturn \"PlaceObject2\";\n\tcase SWF_REMOVEOBJECT2:\n\t\treturn \"RemoveObject2\";\n\tcase SWF_DEFINESHAPE3:\n\t\treturn \"DefineShape3\";\n\tcase SWF_DEFINETEXT2:\n\t\treturn \"DefineText2\";\n\tcase SWF_DEFINEBUTTON2:\n\t\treturn \"DefineButton2\";\n\tcase SWF_DEFINEBITSJPEG3:\n\t\treturn \"DefineBitsJPEG3\";\n\tcase SWF_DEFINEBITSLOSSLESS2:\n\t\treturn \"DefineBitsLossless2\";\n\tcase SWF_DEFINEEDITTEXT:\n\t\treturn \"DefineEditText\";\n\tcase SWF_DEFINEMOVIE:\n\t\treturn \"DefineMovie\";\n\tcase SWF_DEFINESPRITE:\n\t\treturn \"DefineSprite\";\n\tcase SWF_NAMECHARACTER:\n\t\treturn \"NameCharacter\";\n\tcase SWF_SERIALNUMBER:\n\t\treturn \"SerialNumber\";\n\tcase SWF_GENERATORTEXT:\n\t\treturn \"GeneratorText\";\n\tcase SWF_FRAMELABEL:\n\t\treturn \"FrameLabel\";\n\tcase SWF_SOUNDSTREAMHEAD2:\n\t\treturn \"SoundStreamHead2\";\n\tcase SWF_DEFINEMORPHSHAPE:\n\t\treturn \"DefineMorphShape\";\n\tcase SWF_DEFINEFONT2:\n\t\treturn \"DefineFont2\";\n\tcase SWF_TEMPLATECOMMAND:\n\t\treturn \"TemplateCommand\";\n\tcase SWF_GENERATOR3:\n\t\treturn \"Generator3\";\n\tcase SWF_EXTERNALFONT:\n\t\treturn \"ExternalFont\";\n\tcase SWF_EXPORTASSETS:\n\t\treturn \"ExportAssets\";\n\tcase SWF_IMPORTASSETS:\n\t\treturn \"ImportAssets\";\n\tcase SWF_ENABLEDEBUGGER:\n\t\treturn \"EnableDebugger\";\n\tcase SWF_MX0:\n\t\treturn \"MX0\";\n\tcase SWF_MX1:\n\t\treturn \"MX1\";\n\tcase SWF_MX2:\n\t\treturn \"MX2\";\n\tcase SWF_MX3:\n\t\treturn \"MX3\";\n\tcase SWF_MX4:\n\t\treturn \"MX4\";\n\tdefault:\n\t\treturn \"UnknownTag\";\n\t}\n}\n\nstatic GF_Err swf_unknown_tag(SWFReader *read)\n{\n\tif (!read) return GF_OK;\n\tswf_report(read, GF_NOT_SUPPORTED, \"Tag %s (0x%2x) not implemented - skipping\", swf_get_tag_name(read->tag), read->tag);\n\treturn swf_func_skip(read);\n}\n\nstatic GF_Err swf_process_tag(SWFReader *read)\n{\n\tswitch (read->tag) {\n\tcase SWF_END:\n\t\treturn GF_OK;\n\tcase SWF_PROTECT:\n\t\treturn GF_OK;\n\tcase SWF_SETBACKGROUNDCOLOR:\n\t\treturn swf_set_backcol(read);\n\tcase SWF_DEFINESHAPE:\n\t\treturn swf_parse_shape_def(read, NULL, 0);\n\tcase SWF_DEFINESHAPE2:\n\t\treturn swf_parse_shape_def(read, NULL, 1);\n\tcase SWF_DEFINESHAPE3:\n\t\treturn swf_parse_shape_def(read, NULL, 2);\n\tcase SWF_PLACEOBJECT:\n\t\treturn swf_place_obj(read, 0);\n\tcase SWF_PLACEOBJECT2:\n\t\treturn swf_place_obj(read, 1);\n\tcase SWF_REMOVEOBJECT:\n\t\treturn swf_remove_obj(read, 0);\n\tcase SWF_REMOVEOBJECT2:\n\t\treturn swf_remove_obj(read, 1);\n\tcase SWF_SHOWFRAME:\n\t\treturn swf_show_frame(read);\n\tcase SWF_DEFINEFONT:\n\t\treturn swf_def_font(read, 0);\n\tcase SWF_DEFINEFONT2:\n\t\treturn swf_def_font(read, 1);\n\tcase SWF_DEFINEFONTINFO:\n\t\treturn swf_def_font_info(read);\n\tcase SWF_DEFINETEXT:\n\t\treturn swf_def_text(read, 0);\n\tcase SWF_DEFINETEXT2:\n\t\treturn swf_def_text(read, 1);\n\tcase SWF_DEFINEEDITTEXT:\n\t\treturn swf_def_edit_text(read);\n\tcase SWF_DEFINESPRITE:\n\t\treturn swf_def_sprite(read);\n\t/*no revision needed*/\n\tcase SWF_SOUNDSTREAMHEAD:\n\tcase SWF_SOUNDSTREAMHEAD2:\n\t\treturn swf_soundstream_hdr(read);\n\tcase SWF_DEFINESOUND:\n\t\treturn swf_def_sound(read);\n\tcase SWF_STARTSOUND:\n\t\treturn swf_start_sound(read);\n\tcase SWF_SOUNDSTREAMBLOCK:\n\t\treturn swf_soundstream_block(read);\n\n\tcase SWF_DEFINEBUTTON:\n\t\treturn swf_def_button(read, 0);\n\tcase SWF_DEFINEBUTTON2:\n\t\treturn swf_def_button(read, 1);\n//\tcase SWF_DEFINEBUTTONSOUND:\n\tcase SWF_DOACTION:\n\t\treturn swf_actions(read, 0, 0);\n\tcase SWF_FRAMELABEL:\n\t{\n\t\tchar *framelabel = swf_get_string(read);\n\t\tgf_free(framelabel);\n\t\treturn GF_OK;\n\t}\n\n\tcase SWF_JPEGTABLES:\n\t\treturn swf_def_hdr_jpeg(read);\n\tcase SWF_DEFINEBITSJPEG:\n\t\treturn swf_def_bits_jpeg(read, 1);\n\tcase SWF_DEFINEBITSJPEG2:\n\t\treturn swf_def_bits_jpeg(read, 2);\n\tcase SWF_DEFINEBITSJPEG3:\n\t\treturn swf_def_bits_jpeg(read, 3);\n\n\tdefault:\n\t\treturn swf_unknown_tag(read);\n\t}\n}\n\nGF_Err swf_parse_tag(SWFReader *read)\n{\n\tGF_Err e;\n\ts32 diff;\n\tu16 hdr;\n\tu32 pos;\n\n\n\thdr = swf_get_16(read);\n\tread->tag = hdr>>6;\n\tread->size = hdr & 0x3f;\n\tif (read->size == 0x3f) {\n\t\tswf_align(read);\n\t\tread->size = swf_get_32(read);\n\t}\n\tpos = swf_get_file_pos(read);\n\tdiff = pos + read->size;\n\tgf_set_progress(\"SWF Parsing\", pos, read->length);\n\n\tread->ioerr = GF_OK;\n\te = swf_process_tag(read);\n\tswf_align(read);\n\tif (!e) e = read->ioerr;\n\n\tdiff -= swf_get_file_pos(read);\n\tif (diff<0) {\n\t\tswf_report(read, GF_IO_ERR, \"tag %s over-read of %d bytes (size %d)\", swf_get_tag_name(read->tag), -1*diff, read->size);\n\t\treturn GF_IO_ERR;\n\t} else {\n\t\tgf_bs_skip_bytes(read->bs, diff);\n\t}\n\n\n\tif (!e && !read->tag) {\n\t\treturn GF_EOS;\n\t}\n\n\tif (read->ioerr) {\n\t\tswf_report(read, GF_IO_ERR, \"bitstream IO err (tag size %d)\", read->size);\n\t\treturn read->ioerr;\n\t}\n\treturn e;\n}\n\n\n\nGF_Err swf_parse_sprite(SWFReader *read)\n{\n\t/*parse*/\n\twhile (1) {\n\t\tGF_Err e = swf_parse_tag(read);\n\t\tif (e<0) {\n\t\t\tswf_report(read, e, \"Error parsing tag %s\", swf_get_tag_name(read->tag));\n\t\t\treturn e;\n\t\t}\n\t\t/*done with sprite*/\n\t\tif (read->tag==SWF_END) break;\n\t}\n\treturn GF_OK;\n}\n\n\nvoid swf_report(SWFReader *read, GF_Err e, char *format, ...)\n{\n#ifndef GPAC_DISABLE_LOG\n\tif (gf_log_tool_level_on(GF_LOG_PARSER, e ? GF_LOG_ERROR : GF_LOG_WARNING)) {\n\t\tchar szMsg[2048];\n\t\tva_list args;\n\t\tva_start(args, format);\n\t\tvsnprintf(szMsg, 2048, format, args);\n\t\tva_end(args);\n\t\tGF_LOG((u32) (e ? GF_LOG_ERROR : GF_LOG_WARNING), GF_LOG_PARSER, (\"[SWF Parsing] %s (frame %d)\\n\", szMsg, read->current_frame+1) );\n\t}\n#endif\n}\n\n\nstatic void swf_io_error(void *par)\n{\n\tSWFReader *read = (SWFReader *)par;\n\tif (read) read->ioerr = GF_IO_ERR;\n}\n\nGF_Err gf_sm_load_run_swf(GF_SceneLoader *load)\n{\n\tGF_Err e;\n\tSWFReader *read = (SWFReader *)load->loader_priv;\n\tif (!read) return GF_BAD_PARAM;\n\n\t/*parse all tags*/\n\twhile (1) {\n\t\te = swf_parse_tag(read);\n\t\tif (e) break;\n\t}\n\tgf_set_progress(\"SWF Parsing\", read->length, read->length);\n\n\tif (e==GF_EOS) {\n\t\tif (read->finalize)\n\t\t\tread->finalize(read);\n\t\te = GF_OK;\n\t}\n\tif (!e) {\n\t\tif (read->flat_limit != 0)\n\t\t\tswf_report(read, GF_OK, \"%d points removed while parsing shapes (Flattening limit %.4f)\", read->flatten_points, read->flat_limit);\n\n\t\tif (read->no_as && read->has_interact) swf_report(read, GF_OK, \"ActionScripts and interactions have been removed\");\n\t} else\n\t\tswf_report(read, e, \"Error parsing tag %s\", swf_get_tag_name(read->tag));\n\n\n\treturn e;\n}\n\nvoid gf_swf_reader_del(SWFReader *read)\n{\n\tif (!read) return;\n\tgf_bs_del(read->bs);\n\tif (read->mem) gf_free(read->mem);\n\n\twhile (gf_list_count(read->display_list)) {\n\t\tDispShape *s = (DispShape *)gf_list_get(read->display_list, 0);\n\t\tgf_list_rem(read->display_list, 0);\n\t\tgf_free(s);\n\t}\n\tgf_list_del(read->display_list);\n\twhile (gf_list_count(read->fonts)) {\n\t\tSWFFont *ft = (SWFFont *)gf_list_get(read->fonts, 0);\n\t\tgf_list_rem(read->fonts, 0);\n\t\tif (ft->glyph_adv) gf_free(ft->glyph_adv);\n\t\tif (ft->glyph_codes) gf_free(ft->glyph_codes);\n\t\tif (ft->fontName) gf_free(ft->fontName);\n\t\tgf_list_del(ft->glyphs);\n\t\tgf_free(ft);\n\t}\n\tgf_list_del(read->fonts);\n\tgf_list_del(read->apps);\n\n\twhile (gf_list_count(read->sounds)) {\n\t\tSWFSound *snd = (SWFSound *)gf_list_get(read->sounds, 0);\n\t\tgf_list_rem(read->sounds, 0);\n\t\tif (snd->output) gf_fclose(snd->output);\n\t\tif (snd->szFileName) gf_free(snd->szFileName);\n\t\tgf_free(snd);\n\t}\n\tgf_list_del(read->sounds);\n\tswf_delete_sound_stream(read);\n\n\tif (read->jpeg_hdr) gf_free(read->jpeg_hdr);\n\tif (read->localPath) gf_free(read->localPath);\n\tgf_fclose(read->input);\n\tgf_free(read->inputName);\n\tgf_free(read);\n}\n\nvoid gf_sm_load_done_swf(GF_SceneLoader *load)\n{\n\tSWFReader *read = (SWFReader *) load->loader_priv;\n\tif (!read) return;\n\tif (read->svg_file) {\n\t\tgf_fclose(read->svg_file);\n\t\tread->svg_file = NULL;\n\t}\n\tgf_swf_reader_del(read);\n\tload->loader_priv = NULL;\n}\n\nSWFReader *gf_swf_reader_new(const char *localPath, const char *inputName)\n{\n\tSWFReader *read;\n\tFILE *input;\n\tinput = gf_fopen(inputName, \"rb\");\n\tif (!input) return NULL;\n\n\tGF_SAFEALLOC(read, SWFReader);\n\tif (!read) return NULL;\n\tread->inputName = gf_strdup(inputName);\n\tread->input = input;\n\tread->bs = gf_bs_from_file(input, GF_BITSTREAM_READ);\n\tgf_bs_set_eos_callback(read->bs, swf_io_error, read);\n\tread->display_list = gf_list_new();\n\tread->fonts = gf_list_new();\n\tread->apps = gf_list_new();\n\tread->sounds = gf_list_new();\n\n\tif (localPath) {\n\t\tread->localPath = gf_strdup(localPath);\n\t} else {\n\t\tchar *c;\n\t\tread->localPath = gf_strdup(inputName);\n\t\tc = strrchr(read->localPath, GF_PATH_SEPARATOR);\n\t\tif (c) c[1] = 0;\n\t\telse {\n\t\t\tgf_free(read->localPath);\n\t\t\tread->localPath = NULL;\n\t\t}\n\t}\n\n\treturn read;\n}\n\nGF_Err gf_swf_reader_set_user_mode(SWFReader *read, void *user,\n                                   GF_Err (*add_sample)(void *user, const u8 *data, u32 length, u64 timestamp, Bool isRap),\n                                   GF_Err (*add_header)(void *user, const u8 *data, u32 length, Bool isHeader))\n{\n\tif (!read) return GF_BAD_PARAM;\n\tread->user = user;\n\tread->add_header = add_header;\n\tread->add_sample = add_sample;\n\treturn GF_OK;\n}\n\nGF_Err gf_swf_read_header(SWFReader *read)\n{\n\tSWFRec rc;\n\tu8 sig[3];\n\n\t/*get signature*/\n\tsig[0] = gf_bs_read_u8(read->bs);\n\tsig[1] = gf_bs_read_u8(read->bs);\n\tsig[2] = gf_bs_read_u8(read->bs);\n\t/*\"FWS\" or \"CWS\"*/\n\tif ( ((sig[0] != 'F') && (sig[0] != 'C')) || (sig[1] != 'W') || (sig[2] != 'S') ) {\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\t/*version = */gf_bs_read_u8(read->bs);\n\tread->length = swf_get_32(read);\n\n\t/*if compressed decompress the whole file*/\n\tif (sig[0] == 'C') {\n\t\tswf_init_decompress(read);\n\t\tif (!read->bs) return GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\tswf_get_rec(read, &rc);\n\tread->width = rc.w;\n\tread->height = rc.h;\n\n\tswf_align(read);\n\tread->frame_rate = swf_get_16(read)>>8;\n\tread->frame_count = swf_get_16(read);\n\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"SWF Import - Scene Size %gx%g - %d frames @ %d FPS\\n\", read->width, read->height, read->frame_count, read->frame_rate));\n\tif (!read->frame_rate) read->frame_rate = 1;\n\treturn GF_OK;\n}\n\nGF_Err gf_swf_get_duration(SWFReader *read, u32 *frame_rate, u32 *frame_count)\n{\n\t*frame_rate = read->frame_rate;\n\t*frame_count = read->frame_count;\n\treturn GF_OK;\n}\n\nGF_Err gf_sm_load_init_swf(GF_SceneLoader *load)\n{\n\tSWFReader *read;\n\tGF_Err e;\n\n\tif (!load->ctx || !load->scene_graph || !load->fileName) return GF_BAD_PARAM;\n\n#ifdef GPAC_ENABLE_COVERAGE\n\tif (gf_sys_is_cov_mode()) {\n\t\tswf_func_skip(NULL);\n\t\tswf_def_hdr_jpeg(NULL);\n\t\tswf_get_tag_name(SWF_FREECHARACTER);\n\t\tswf_unknown_tag(NULL);\n\t\tswf_io_error(NULL);\n\t}\n#endif\n\n\tread = gf_swf_reader_new(load->localPath, load->fileName);\n\tread->load = load;\n\tread->flags = load->swf_import_flags;\n\tread->flat_limit = FLT2FIX(load->swf_flatten_limit);\n\tload->loader_priv = read;\n\n\te = gf_swf_read_header(read);\n\tif (e) goto exit;\n\tload->ctx->scene_width = FIX2INT(read->width);\n\tload->ctx->scene_height = FIX2INT(read->height);\n\tload->ctx->is_pixel_metrics = 1;\n\n\tif (!(load->swf_import_flags & GF_SM_SWF_SPLIT_TIMELINE) ) {\n\t\tswf_report(read, GF_OK, \"ActionScript disabled\");\n\t\tread->no_as = 1;\n\t}\n\n\tif (!(load->swf_import_flags & GF_SM_SWF_USE_SVG)) {\n#ifndef GPAC_DISABLE_VRML\n\t\te = swf_to_bifs_init(read);\n#else\n\t\te = GF_NOT_SUPPORTED;\n#endif\n\t} else {\n#ifndef GPAC_DISABLE_SVG\n\t\tFILE *svgFile;\n\t\tif (load->svgOutFile) {\n\t\t\tchar svgFileName[GF_MAX_PATH];\n\t\t\tif (load->localPath) {\n\t\t\t\tsprintf(svgFileName, \"%s%c%s.svg\", load->localPath, GF_PATH_SEPARATOR, load->svgOutFile);\n\t\t\t} else {\n\t\t\t\tsprintf(svgFileName, \"%s.svg\", load->svgOutFile);\n\t\t\t}\n\t\t\tsvgFile = gf_fopen(svgFileName, \"wt\");\n\t\t\tif (!svgFile) return GF_BAD_PARAM;\n\t\t\tread->svg_file = svgFile;\n\t\t} else {\n\t\t\tsvgFile = stdout;\n\t\t}\n\t\tgf_swf_reader_set_user_mode(read, svgFile, swf_svg_write_text_sample, swf_svg_write_text_header);\n\t\te = swf_to_svg_init(read, read->flags, load->swf_flatten_limit);\n#else\n\t\te = GF_NOT_SUPPORTED;\n#endif\n\t}\n\tif (e) goto exit;\n\n\t/*parse all tags*/\n\twhile (e == GF_OK) {\n\t\te = swf_parse_tag(read);\n\t\tif (read->current_frame==1) break;\n\t}\n\tif (e==GF_EOS) e = GF_OK;\n\n\tload->done = gf_sm_load_done_swf;\n\tload->process = gf_sm_load_run_swf;\n\nexit:\n\tif (e) gf_sm_load_done_swf(load);\n\treturn e;\n}\n\n#endif /*GPAC_DISABLE_SWF_IMPORT*/\n"], "filenames": ["src/scene_manager/swf_parse.c"], "buggy_code_start_loc": [185], "buggy_code_end_loc": [216], "fixing_code_start_loc": [185], "fixing_code_end_loc": [196], "type": "CWE-1077", "message": "Floating Point Comparison with Incorrect Operator in GitHub repository gpac/gpac prior to 2.3-DEV.", "other": {"cve": {"id": "CVE-2023-4720", "sourceIdentifier": "security@huntr.dev", "published": "2023-09-01T16:15:08.577", "lastModified": "2023-09-06T00:14:31.183", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Floating Point Comparison with Incorrect Operator in GitHub repository gpac/gpac prior to 2.3-DEV."}, {"lang": "es", "value": "Comparaci\u00f3n de punto flotante con operador incorrecto en GitHub repository gpac/gpac anterior a 2.3-DEV."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 1.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1077"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.3-dev", "matchCriteriaId": "F76B0068-AE98-4B7C-885D-B083842F6521"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/e396648e48c57e2d53988d3fd4465b068b96c89a", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/1dc2954c-8497-49fa-b2af-113e1e9381ad", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/e396648e48c57e2d53988d3fd4465b068b96c89a"}}