{"buggy_code": ["# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 OpenStack LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nimport uuid\n\nimport routes\n\nfrom keystone import catalog\nfrom keystone import exception\nfrom keystone import identity\nfrom keystone import policy\nfrom keystone import token\nfrom keystone.common import logging\nfrom keystone.common import utils\nfrom keystone.common import wsgi\n\n\nLOG = logging.getLogger(__name__)\n\n\nclass AdminRouter(wsgi.ComposingRouter):\n    def __init__(self):\n        mapper = routes.Mapper()\n\n        version_controller = VersionController('admin')\n        mapper.connect('/',\n                       controller=version_controller,\n                       action='get_version')\n\n        # Token Operations\n        auth_controller = TokenController()\n        mapper.connect('/tokens',\n                       controller=auth_controller,\n                       action='authenticate',\n                       conditions=dict(method=['POST']))\n        mapper.connect('/tokens/{token_id}',\n                       controller=auth_controller,\n                       action='validate_token',\n                       conditions=dict(method=['GET']))\n        mapper.connect('/tokens/{token_id}',\n                       controller=auth_controller,\n                       action='validate_token_head',\n                       conditions=dict(method=['HEAD']))\n        mapper.connect('/tokens/{token_id}',\n                       controller=auth_controller,\n                       action='delete_token',\n                       conditions=dict(method=['DELETE']))\n        mapper.connect('/tokens/{token_id}/endpoints',\n                       controller=auth_controller,\n                       action='endpoints',\n                       conditions=dict(method=['GET']))\n\n        # Miscellaneous Operations\n        extensions_controller = AdminExtensionsController()\n        mapper.connect('/extensions',\n                       controller=extensions_controller,\n                       action='get_extensions_info',\n                       conditions=dict(method=['GET']))\n        mapper.connect('/extensions/{extension_alias}',\n                       controller=extensions_controller,\n                       action='get_extension_info',\n                       conditions=dict(method=['GET']))\n        identity_router = identity.AdminRouter()\n        routers = [identity_router]\n        super(AdminRouter, self).__init__(mapper, routers)\n\n\nclass PublicRouter(wsgi.ComposingRouter):\n    def __init__(self):\n        mapper = routes.Mapper()\n\n        version_controller = VersionController('public')\n        mapper.connect('/',\n                       controller=version_controller,\n                       action='get_version')\n\n        # Token Operations\n        auth_controller = TokenController()\n        mapper.connect('/tokens',\n                       controller=auth_controller,\n                       action='authenticate',\n                       conditions=dict(method=['POST']))\n\n        # Miscellaneous\n        extensions_controller = PublicExtensionsController()\n        mapper.connect('/extensions',\n                       controller=extensions_controller,\n                       action='get_extensions_info',\n                       conditions=dict(method=['GET']))\n        mapper.connect('/extensions/{extension_alias}',\n                       controller=extensions_controller,\n                       action='get_extension_info',\n                       conditions=dict(method=['GET']))\n\n        identity_router = identity.PublicRouter()\n        routers = [identity_router]\n\n        super(PublicRouter, self).__init__(mapper, routers)\n\n\nclass PublicVersionRouter(wsgi.ComposingRouter):\n    def __init__(self):\n        mapper = routes.Mapper()\n        version_controller = VersionController('public')\n        mapper.connect('/',\n                       controller=version_controller,\n                       action='get_versions')\n        routers = []\n        super(PublicVersionRouter, self).__init__(mapper, routers)\n\n\nclass AdminVersionRouter(wsgi.ComposingRouter):\n    def __init__(self):\n        mapper = routes.Mapper()\n        version_controller = VersionController('admin')\n        mapper.connect('/',\n                       controller=version_controller,\n                       action='get_versions')\n        routers = []\n        super(AdminVersionRouter, self).__init__(mapper, routers)\n\n\nclass VersionController(wsgi.Application):\n    def __init__(self, version_type):\n        self.catalog_api = catalog.Manager()\n        self.url_key = \"%sURL\" % version_type\n\n        super(VersionController, self).__init__()\n\n    def _get_identity_url(self, context):\n        catalog_ref = self.catalog_api.get_catalog(\n                context=context,\n                user_id=None,\n                tenant_id=None)\n        for region, region_ref in catalog_ref.iteritems():\n            for service, service_ref in region_ref.iteritems():\n                if service == 'identity':\n                    return service_ref[self.url_key]\n\n        raise exception.NotImplemented()\n\n    def _get_versions_list(self, context):\n        \"\"\"The list of versions is dependent on the context.\"\"\"\n        identity_url = self._get_identity_url(context)\n        if not identity_url.endswith('/'):\n            identity_url = identity_url + '/'\n\n        versions = {}\n        versions['v2.0'] = {\n            \"id\": \"v2.0\",\n            \"status\": \"beta\",\n            \"updated\": \"2011-11-19T00:00:00Z\",\n            \"links\": [\n                {\n                    \"rel\": \"self\",\n                    \"href\": identity_url,\n                }, {\n                    \"rel\": \"describedby\",\n                    \"type\": \"text/html\",\n                    \"href\": \"http://docs.openstack.org/api/openstack-\"\n                                \"identity-service/2.0/content/\"\n                }, {\n                    \"rel\": \"describedby\",\n                    \"type\": \"application/pdf\",\n                    \"href\": \"http://docs.openstack.org/api/openstack-\"\n                                \"identity-service/2.0/identity-dev-guide-\"\n                                \"2.0.pdf\"\n                }\n            ],\n            \"media-types\": [\n                {\n                    \"base\": \"application/json\",\n                    \"type\": \"application/vnd.openstack.identity-v2.0\"\n                                \"+json\"\n                }, {\n                    \"base\": \"application/xml\",\n                    \"type\": \"application/vnd.openstack.identity-v2.0\"\n                                \"+xml\"\n                }\n            ]\n        }\n\n        return versions\n\n    def get_versions(self, context):\n        versions = self._get_versions_list(context)\n        return wsgi.render_response(status=(300, 'Multiple Choices'), body={\n            \"versions\": {\n                \"values\": versions.values()\n            }\n        })\n\n    def get_version(self, context):\n        versions = self._get_versions_list(context)\n        return wsgi.render_response(body={\n            \"version\": versions['v2.0']\n        })\n\n\nclass NoopController(wsgi.Application):\n    def __init__(self):\n        super(NoopController, self).__init__()\n\n    def noop(self, context):\n        return {}\n\n\nclass TokenController(wsgi.Application):\n    def __init__(self):\n        self.catalog_api = catalog.Manager()\n        self.identity_api = identity.Manager()\n        self.token_api = token.Manager()\n        self.policy_api = policy.Manager()\n        super(TokenController, self).__init__()\n\n    def authenticate(self, context, auth=None):\n        \"\"\"Authenticate credentials and return a token.\n\n        Accept auth as a dict that looks like::\n\n            {\n                \"auth\":{\n                    \"passwordCredentials\":{\n                        \"username\":\"test_user\",\n                        \"password\":\"mypass\"\n                    },\n                    \"tenantName\":\"customer-x\"\n                }\n            }\n\n        In this case, tenant is optional, if not provided the token will be\n        considered \"unscoped\" and can later be used to get a scoped token.\n\n        Alternatively, this call accepts auth with only a token and tenant\n        that will return a token that is scoped to that tenant.\n        \"\"\"\n\n        token_id = uuid.uuid4().hex\n        if 'passwordCredentials' in auth:\n            username = auth['passwordCredentials'].get('username', '')\n            password = auth['passwordCredentials'].get('password', '')\n            tenant_name = auth.get('tenantName', None)\n\n            user_id = auth['passwordCredentials'].get('userId', None)\n            if username:\n                user_ref = self.identity_api.get_user_by_name(\n                        context=context, user_name=username)\n                if user_ref:\n                    user_id = user_ref['id']\n\n            # more compat\n            tenant_id = auth.get('tenantId', None)\n            if tenant_name:\n                tenant_ref = self.identity_api.get_tenant_by_name(\n                        context=context, tenant_name=tenant_name)\n                if tenant_ref:\n                    tenant_id = tenant_ref['id']\n\n            try:\n                auth_info = self.identity_api.authenticate(context=context,\n                                                           user_id=user_id,\n                                                           password=password,\n                                                           tenant_id=tenant_id)\n                (user_ref, tenant_ref, metadata_ref) = auth_info\n\n                # If the user is disabled don't allow them to authenticate\n                if not user_ref.get('enabled', True):\n                    LOG.warning('User %s is disabled' % user_id)\n                    raise exception.Unauthorized()\n            except AssertionError as e:\n                raise exception.Unauthorized(e.message)\n\n            token_ref = self.token_api.create_token(\n                    context, token_id, dict(id=token_id,\n                                            user=user_ref,\n                                            tenant=tenant_ref,\n                                            metadata=metadata_ref))\n            if tenant_ref:\n                catalog_ref = self.catalog_api.get_catalog(\n                        context=context,\n                        user_id=user_ref['id'],\n                        tenant_id=tenant_ref['id'],\n                        metadata=metadata_ref)\n            else:\n                catalog_ref = {}\n\n        elif 'token' in auth:\n            token = auth['token'].get('id', None)\n\n            tenant_name = auth.get('tenantName')\n\n            # more compat\n            if tenant_name:\n                tenant_ref = self.identity_api.get_tenant_by_name(\n                        context=context, tenant_name=tenant_name)\n                tenant_id = tenant_ref['id']\n            else:\n                tenant_id = auth.get('tenantId', None)\n\n            try:\n                old_token_ref = self.token_api.get_token(context=context,\n                                                         token_id=token)\n            except exception.NotFound:\n                raise exception.Unauthorized()\n\n            user_ref = old_token_ref['user']\n\n            # If the user is disabled don't allow them to authenticate\n            current_user_ref = self.identity_api.get_user(\n                                                    context=context,\n                                                    user_id=user_ref['id'])\n            if not current_user_ref.get('enabled', True):\n                LOG.warning('User %s is disabled' % user_ref['id'])\n                raise exception.Unauthorized()\n\n            tenants = self.identity_api.get_tenants_for_user(context,\n                                                             user_ref['id'])\n            if tenant_id:\n                assert tenant_id in tenants\n\n            tenant_ref = self.identity_api.get_tenant(context=context,\n                                                      tenant_id=tenant_id)\n            if tenant_ref:\n                metadata_ref = self.identity_api.get_metadata(\n                        context=context,\n                        user_id=user_ref['id'],\n                        tenant_id=tenant_ref['id'])\n                catalog_ref = self.catalog_api.get_catalog(\n                        context=context,\n                        user_id=user_ref['id'],\n                        tenant_id=tenant_ref['id'],\n                        metadata=metadata_ref)\n            else:\n                metadata_ref = {}\n                catalog_ref = {}\n\n            token_ref = self.token_api.create_token(\n                    context, token_id, dict(id=token_id,\n                                            user=user_ref,\n                                            tenant=tenant_ref,\n                                            metadata=metadata_ref))\n\n        # TODO(termie): optimize this call at some point and put it into the\n        #               the return for metadata\n        # fill out the roles in the metadata\n        roles_ref = []\n        for role_id in metadata_ref.get('roles', []):\n            roles_ref.append(self.identity_api.get_role(context, role_id))\n        logging.debug('TOKEN_REF %s', token_ref)\n        return self._format_authenticate(token_ref, roles_ref, catalog_ref)\n\n    def _get_token_ref(self, context, token_id, belongs_to=None):\n        \"\"\"Returns a token if a valid one exists.\n\n        Optionally, limited to a token owned by a specific tenant.\n\n        \"\"\"\n        # TODO(termie): this stuff should probably be moved to middleware\n        self.assert_admin(context)\n\n        token_ref = self.token_api.get_token(context=context,\n                                             token_id=token_id)\n\n        if belongs_to:\n            assert token_ref['tenant']['id'] == belongs_to\n\n        return token_ref\n\n    # admin only\n    def validate_token_head(self, context, token_id):\n        \"\"\"Check that a token is valid.\n\n        Optionally, also ensure that it is owned by a specific tenant.\n\n        Identical to ``validate_token``, except does not return a response.\n\n        \"\"\"\n        belongs_to = context['query_string'].get(\"belongsTo\")\n        assert self._get_token_ref(context, token_id, belongs_to)\n\n    # admin only\n    def validate_token(self, context, token_id):\n        \"\"\"Check that a token is valid.\n\n        Optionally, also ensure that it is owned by a specific tenant.\n\n        Returns metadata about the token along any associated roles.\n\n        \"\"\"\n        belongs_to = context['query_string'].get(\"belongsTo\")\n        token_ref = self._get_token_ref(context, token_id, belongs_to)\n\n        # TODO(termie): optimize this call at some point and put it into the\n        #               the return for metadata\n        # fill out the roles in the metadata\n        metadata_ref = token_ref['metadata']\n        roles_ref = []\n        for role_id in metadata_ref.get('roles', []):\n            roles_ref.append(self.identity_api.get_role(context, role_id))\n\n        # Get a service catalog if belongs_to is not none\n        # This is needed for on-behalf-of requests\n        catalog_ref = None\n        if belongs_to is not None:\n            catalog_ref = self.catalog_api.get_catalog(\n                context=context,\n                user_id=token_ref['user']['id'],\n                tenant_id=token_ref['tenant']['id'],\n                metadata=metadata_ref)\n        return self._format_token(token_ref, roles_ref, catalog_ref)\n\n    def delete_token(self, context, token_id):\n        \"\"\"Delete a token, effectively invalidating it for authz.\"\"\"\n        # TODO(termie): this stuff should probably be moved to middleware\n        self.assert_admin(context)\n\n        self.token_api.delete_token(context=context, token_id=token_id)\n\n    def endpoints(self, context, token_id):\n        \"\"\"Return a list of endpoints available to the token.\"\"\"\n        raise exception.NotImplemented()\n\n    def _format_authenticate(self, token_ref, roles_ref, catalog_ref):\n        o = self._format_token(token_ref, roles_ref)\n        o['access']['serviceCatalog'] = self._format_catalog(catalog_ref)\n        return o\n\n    def _format_token(self, token_ref, roles_ref, catalog_ref=None):\n        user_ref = token_ref['user']\n        metadata_ref = token_ref['metadata']\n        expires = token_ref['expires']\n        if expires is not None:\n            expires = utils.isotime(expires)\n        o = {'access': {'token': {'id': token_ref['id'],\n                                  'expires': expires,\n                                  },\n                        'user': {'id': user_ref['id'],\n                                 'name': user_ref['name'],\n                                 'username': user_ref['name'],\n                                 'roles': roles_ref,\n                                 'roles_links': metadata_ref.get('roles_links',\n                                                               [])\n                                 }\n                        }\n             }\n        if 'tenant' in token_ref and token_ref['tenant']:\n            token_ref['tenant']['enabled'] = True\n            o['access']['token']['tenant'] = token_ref['tenant']\n        if catalog_ref is not None:\n            o['access']['serviceCatalog'] = self._format_catalog(catalog_ref)\n        return o\n\n    def _format_catalog(self, catalog_ref):\n        \"\"\"Munge catalogs from internal to output format\n        Internal catalogs look like:\n\n        {$REGION: {\n            {$SERVICE: {\n                $key1: $value1,\n                ...\n                }\n            }\n        }\n\n        The legacy api wants them to look like\n\n        [{'name': $SERVICE[name],\n          'type': $SERVICE,\n          'endpoints': [{\n              'tenantId': $tenant_id,\n              ...\n              'region': $REGION,\n              }],\n          'endpoints_links': [],\n         }]\n\n        \"\"\"\n        if not catalog_ref:\n            return {}\n\n        services = {}\n        for region, region_ref in catalog_ref.iteritems():\n            for service, service_ref in region_ref.iteritems():\n                new_service_ref = services.get(service, {})\n                new_service_ref['name'] = service_ref.pop('name')\n                new_service_ref['type'] = service\n                new_service_ref['endpoints_links'] = []\n                service_ref['region'] = region\n\n                endpoints_ref = new_service_ref.get('endpoints', [])\n                endpoints_ref.append(service_ref)\n\n                new_service_ref['endpoints'] = endpoints_ref\n                services[service] = new_service_ref\n\n        return services.values()\n\n\nclass ExtensionsController(wsgi.Application):\n    \"\"\"Base extensions controller to be extended by public and admin API's.\"\"\"\n\n    def __init__(self, extensions=None):\n        super(ExtensionsController, self).__init__()\n\n        self.extensions = extensions or {}\n\n    def get_extensions_info(self, context):\n        return {'extensions': {'values': self.extensions.values()}}\n\n    def get_extension_info(self, context, extension_alias):\n        try:\n            return {'extension': self.extensions[extension_alias]}\n        except KeyError:\n            raise exception.NotFound(target=extension_alias)\n\n\nclass PublicExtensionsController(ExtensionsController):\n    pass\n\n\nclass AdminExtensionsController(ExtensionsController):\n    def __init__(self, *args, **kwargs):\n        super(AdminExtensionsController, self).__init__(*args, **kwargs)\n\n        # TODO(dolph): Extensions should obviously provide this information\n        #               themselves, but hardcoding it here allows us to match\n        #               the API spec in the short term with minimal complexity.\n        self.extensions['OS-KSADM'] = {\n            'name': 'Openstack Keystone Admin',\n            'namespace': 'http://docs.openstack.org/identity/api/ext/'\n                         'OS-KSADM/v1.0',\n            'alias': 'OS-KSADM',\n            'updated': '2011-08-19T13:25:27-06:00',\n            'description': 'Openstack extensions to Keystone v2.0 API '\n                           'enabling Admin Operations.',\n            'links': [\n                {\n                    'rel': 'describedby',\n                    # TODO(dolph): link needs to be revised after\n                    #              bug 928059 merges\n                    'type': 'text/html',\n                    'href': ('https://github.com/openstack/'\n                        'identity-api'),\n                }\n            ]\n        }\n\n\n@logging.fail_gracefully\ndef public_app_factory(global_conf, **local_conf):\n    conf = global_conf.copy()\n    conf.update(local_conf)\n    return PublicRouter()\n\n\n@logging.fail_gracefully\ndef admin_app_factory(global_conf, **local_conf):\n    conf = global_conf.copy()\n    conf.update(local_conf)\n    return AdminRouter()\n\n\n@logging.fail_gracefully\ndef public_version_app_factory(global_conf, **local_conf):\n    conf = global_conf.copy()\n    conf.update(local_conf)\n    return PublicVersionRouter()\n\n\n@logging.fail_gracefully\ndef admin_version_app_factory(global_conf, **local_conf):\n    conf = global_conf.copy()\n    conf.update(local_conf)\n    return AdminVersionRouter()\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 OpenStack LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nimport uuid\n\nimport nose.exc\n\nfrom keystone import test\n\nimport default_fixtures\n\nOPENSTACK_REPO = 'https://review.openstack.org/p/openstack'\nKEYSTONECLIENT_REPO = '%s/python-keystoneclient.git' % OPENSTACK_REPO\n\n\nclass CompatTestCase(test.TestCase):\n    def setUp(self):\n        super(CompatTestCase, self).setUp()\n\n        revdir = test.checkout_vendor(*self.get_checkout())\n        self.add_path(revdir)\n        self.clear_module('keystoneclient')\n\n        self.load_backends()\n        self.load_fixtures(default_fixtures)\n\n        self.public_server = self.serveapp('keystone', name='main')\n        self.admin_server = self.serveapp('keystone', name='admin')\n\n        # TODO(termie): is_admin is being deprecated once the policy stuff\n        #               is all working\n        # TODO(termie): add an admin user to the fixtures and use that user\n        # override the fixtures, for now\n        self.metadata_foobar = self.identity_api.update_metadata(\n            self.user_foo['id'], self.tenant_bar['id'],\n            dict(roles=['keystone_admin'], is_admin='1'))\n\n    def tearDown(self):\n        self.public_server.kill()\n        self.admin_server.kill()\n        self.public_server = None\n        self.admin_server = None\n        super(CompatTestCase, self).tearDown()\n\n    def _public_url(self):\n        public_port = self.public_server.socket_info['socket'][1]\n        return \"http://localhost:%s/v2.0\" % public_port\n\n    def _admin_url(self):\n        admin_port = self.admin_server.socket_info['socket'][1]\n        return \"http://localhost:%s/v2.0\" % admin_port\n\n    def _client(self, admin=False, **kwargs):\n        from keystoneclient.v2_0 import client as ks_client\n\n        url = self._admin_url() if admin else self._public_url()\n        kc = ks_client.Client(endpoint=url,\n                              auth_url=self._public_url(),\n                              **kwargs)\n        kc.authenticate()\n        # have to manually overwrite the management url after authentication\n        kc.management_url = url\n        return kc\n\n    def get_client(self, user_ref=None, tenant_ref=None, admin=False):\n        if user_ref is None:\n            user_ref = self.user_foo\n        if tenant_ref is None:\n            for user in default_fixtures.USERS:\n                if user['id'] == user_ref['id']:\n                    tenant_id = user['tenants'][0]\n        else:\n            tenant_id = tenant_ref['id']\n\n        return self._client(username=user_ref['name'],\n                            password=user_ref['password'],\n                            tenant_id=tenant_id,\n                            admin=admin)\n\n\nclass KeystoneClientTests(object):\n    \"\"\"Tests for all versions of keystoneclient.\"\"\"\n\n    def test_authenticate_tenant_name_and_tenants(self):\n        client = self.get_client()\n        tenants = client.tenants.list()\n        self.assertEquals(tenants[0].id, self.tenant_bar['id'])\n\n    def test_authenticate_tenant_id_and_tenants(self):\n        client = self._client(username=self.user_foo['name'],\n                              password=self.user_foo['password'],\n                              tenant_id='bar')\n        tenants = client.tenants.list()\n        self.assertEquals(tenants[0].id, self.tenant_bar['id'])\n\n    def test_authenticate_invalid_tenant_id(self):\n        from keystoneclient import exceptions as client_exceptions\n        self.assertRaises(client_exceptions.Unauthorized,\n                          self._client,\n                          username=self.user_foo['name'],\n                          password=self.user_foo['password'],\n                          tenant_id='baz')\n\n    def test_authenticate_token_no_tenant(self):\n        client = self.get_client()\n        token = client.auth_token\n        token_client = self._client(token=token)\n        tenants = token_client.tenants.list()\n        self.assertEquals(tenants[0].id, self.tenant_bar['id'])\n\n    def test_authenticate_token_tenant_id(self):\n        client = self.get_client()\n        token = client.auth_token\n        token_client = self._client(token=token, tenant_id='bar')\n        tenants = token_client.tenants.list()\n        self.assertEquals(tenants[0].id, self.tenant_bar['id'])\n\n    def test_authenticate_token_invalid_tenant_id(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client()\n        token = client.auth_token\n        self.assertRaises(client_exceptions.AuthorizationFailure,\n                          self._client, token=token, tenant_id='baz')\n\n    def test_authenticate_token_tenant_name(self):\n        client = self.get_client()\n        token = client.auth_token\n        token_client = self._client(token=token, tenant_name='BAR')\n        tenants = token_client.tenants.list()\n        self.assertEquals(tenants[0].id, self.tenant_bar['id'])\n        self.assertEquals(tenants[0].id, self.tenant_bar['id'])\n\n    def test_authenticate_and_delete_token(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        client = self.get_client(admin=True)\n        token = client.auth_token\n        token_client = self._client(token=token)\n        tenants = token_client.tenants.list()\n        self.assertEquals(tenants[0].id, self.tenant_bar['id'])\n\n        client.tokens.delete(token_client.auth_token)\n\n        self.assertRaises(client_exceptions.Unauthorized,\n                          token_client.tenants.list)\n\n    def test_authenticate_no_password(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        user_ref = self.user_foo.copy()\n        user_ref['password'] = None\n        self.assertRaises(client_exceptions.AuthorizationFailure,\n                          self.get_client,\n                          user_ref)\n\n    def test_authenticate_no_username(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        user_ref = self.user_foo.copy()\n        user_ref['name'] = None\n        self.assertRaises(client_exceptions.AuthorizationFailure,\n                          self.get_client,\n                          user_ref)\n\n    # FIXME(ja): this test should require the \"keystone:admin\" roled\n    #            (probably the role set via --keystone_admin_role flag)\n    # FIXME(ja): add a test that admin endpoint is only sent to admin user\n    # FIXME(ja): add a test that admin endpoint returns unauthorized if not\n    #            admin\n    def test_tenant_create_update_and_delete(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        tenant_name = 'original_tenant'\n        tenant_description = 'My original tenant!'\n        tenant_enabled = True\n        client = self.get_client(admin=True)\n\n        # create, get, and list a tenant\n        tenant = client.tenants.create(tenant_name=tenant_name,\n                                       description=tenant_description,\n                                       enabled=tenant_enabled)\n        self.assertEquals(tenant.name, tenant_name)\n        self.assertEquals(tenant.description, tenant_description)\n        self.assertEquals(tenant.enabled, tenant_enabled)\n\n        tenant = client.tenants.get(tenant_id=tenant.id)\n        self.assertEquals(tenant.name, tenant_name)\n        self.assertEquals(tenant.description, tenant_description)\n        self.assertEquals(tenant.enabled, tenant_enabled)\n\n        tenant = [t for t in client.tenants.list() if t.id == tenant.id].pop()\n        self.assertEquals(tenant.name, tenant_name)\n        self.assertEquals(tenant.description, tenant_description)\n        self.assertEquals(tenant.enabled, tenant_enabled)\n\n        # update, get, and list a tenant\n        tenant_name = 'updated_tenant'\n        tenant_description = 'Updated tenant!'\n        tenant_enabled = False\n        tenant = client.tenants.update(tenant_id=tenant.id,\n                                       tenant_name=tenant_name,\n                                       enabled=tenant_enabled,\n                                       description=tenant_description)\n        self.assertEquals(tenant.name, tenant_name)\n        self.assertEquals(tenant.description, tenant_description)\n        self.assertEquals(tenant.enabled, tenant_enabled)\n\n        tenant = client.tenants.get(tenant_id=tenant.id)\n        self.assertEquals(tenant.name, tenant_name)\n        self.assertEquals(tenant.description, tenant_description)\n        self.assertEquals(tenant.enabled, tenant_enabled)\n\n        tenant = [t for t in client.tenants.list() if t.id == tenant.id].pop()\n        self.assertEquals(tenant.name, tenant_name)\n        self.assertEquals(tenant.description, tenant_description)\n        self.assertEquals(tenant.enabled, tenant_enabled)\n\n        # delete, get, and list a tenant\n        client.tenants.delete(tenant=tenant.id)\n        self.assertRaises(client_exceptions.NotFound, client.tenants.get,\n                          tenant.id)\n        self.assertFalse([t for t in client.tenants.list()\n                           if t.id == tenant.id])\n\n    def test_tenant_create_no_name(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.BadRequest,\n                          client.tenants.create,\n                          tenant_name=\"\")\n\n    def test_tenant_delete_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.tenants.delete,\n                          tenant=uuid.uuid4().hex)\n\n    def test_tenant_get_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.tenants.get,\n                          tenant_id=uuid.uuid4().hex)\n\n    def test_tenant_update_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.tenants.update,\n                          tenant_id=uuid.uuid4().hex)\n\n    def test_tenant_list(self):\n        client = self.get_client()\n        tenants = client.tenants.list()\n        self.assertEquals(len(tenants), 1)\n\n        # Admin endpoint should return *all* tenants\n        client = self.get_client(admin=True)\n        tenants = client.tenants.list()\n        self.assertEquals(len(tenants), len(default_fixtures.TENANTS))\n\n    def test_invalid_password(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        good_client = self._client(username=self.user_foo['name'],\n                                   password=self.user_foo['password'])\n        good_client.tenants.list()\n\n        self.assertRaises(client_exceptions.Unauthorized,\n                          self._client,\n                          username=self.user_foo['name'],\n                          password='invalid')\n\n    def test_invalid_user_password(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        self.assertRaises(client_exceptions.Unauthorized,\n                          self._client,\n                          username='blah',\n                          password='blah')\n\n    def test_change_password_invalidates_token(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        client = self.get_client(admin=True)\n\n        username = uuid.uuid4().hex\n        passwd = uuid.uuid4().hex\n        user = client.users.create(name=username, password=passwd,\n                                   email=uuid.uuid4().hex)\n\n        token_id = client.tokens.authenticate(username=username,\n                                              password=passwd).id\n\n        # authenticate with a token should work before a password change\n        client.tokens.authenticate(token=token_id)\n\n        client.users.update_password(user=user.id, password=uuid.uuid4().hex)\n\n        # authenticate with a token should not work after a password change\n        self.assertRaises(client_exceptions.Unauthorized,\n                          client.tokens.authenticate,\n                          token=token_id)\n\n    def test_disable_user_invalidates_token(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        admin_client = self.get_client(admin=True)\n        foo_client = self.get_client(self.user_foo)\n\n        admin_client.users.update_enabled(user=self.user_foo['id'],\n                                          enabled=False)\n\n        self.assertRaises(client_exceptions.Unauthorized,\n                          foo_client.tokens.authenticate,\n                          token=foo_client.auth_token)\n\n        self.assertRaises(client_exceptions.Unauthorized,\n                          self.get_client,\n                          self.user_foo)\n\n    def test_user_create_update_delete(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        test_username = 'new_user'\n        client = self.get_client(admin=True)\n        user = client.users.create(name=test_username,\n                                   password='password',\n                                   email='user1@test.com')\n        self.assertEquals(user.name, test_username)\n\n        user = client.users.get(user=user.id)\n        self.assertEquals(user.name, test_username)\n\n        user = client.users.update(user=user,\n                                   name=test_username,\n                                   email='user2@test.com')\n        self.assertEquals(user.email, 'user2@test.com')\n\n        # NOTE(termie): update_enabled doesn't return anything, probably a bug\n        client.users.update_enabled(user=user, enabled=False)\n        user = client.users.get(user.id)\n        self.assertFalse(user.enabled)\n\n        self.assertRaises(client_exceptions.Unauthorized,\n                  self._client,\n                  username=test_username,\n                  password='password')\n        client.users.update_enabled(user, True)\n\n        user = client.users.update_password(user=user, password='password2')\n\n        self._client(username=test_username,\n                     password='password2')\n\n        user = client.users.update_tenant(user=user, tenant='bar')\n        # TODO(ja): once keystonelight supports default tenant\n        #           when you login without specifying tenant, the\n        #           token should be scoped to tenant 'bar'\n\n        client.users.delete(user.id)\n        self.assertRaises(client_exceptions.NotFound, client.users.get,\n                          user.id)\n\n        # Test creating a user with a tenant (auto-add to tenant)\n        user2 = client.users.create(name=test_username,\n                                    password='password',\n                                    email='user1@test.com',\n                                    tenant_id='bar')\n        self.assertEquals(user2.name, test_username)\n\n    def test_user_create_no_name(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.BadRequest,\n                          client.users.create,\n                          name=\"\",\n                          password=uuid.uuid4().hex,\n                          email=uuid.uuid4().hex)\n\n    def test_user_create_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.users.create,\n                          name=uuid.uuid4().hex,\n                          password=uuid.uuid4().hex,\n                          email=uuid.uuid4().hex,\n                          tenant_id=uuid.uuid4().hex)\n\n    def test_user_get_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.users.get,\n                          user=uuid.uuid4().hex)\n\n    def test_user_list_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.users.list,\n                          tenant_id=uuid.uuid4().hex)\n\n    def test_user_update_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.users.update,\n                          user=uuid.uuid4().hex)\n\n    def test_user_update_tenant_404(self):\n        raise nose.exc.SkipTest('N/A')\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.users.update,\n                          user=self.user_foo['id'],\n                          tenant_id=uuid.uuid4().hex)\n\n    def test_user_update_password_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.users.update_password,\n                          user=uuid.uuid4().hex,\n                          password=uuid.uuid4().hex)\n\n    def test_user_delete_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.users.delete,\n                          user=uuid.uuid4().hex)\n\n    def test_user_list(self):\n        client = self.get_client(admin=True)\n        users = client.users.list()\n        self.assertTrue(len(users) > 0)\n        user = users[0]\n        self.assertRaises(AttributeError, lambda: user.password)\n\n    def test_user_get(self):\n        client = self.get_client(admin=True)\n        user = client.users.get(user=self.user_foo['id'])\n        self.assertRaises(AttributeError, lambda: user.password)\n\n    def test_role_get(self):\n        client = self.get_client(admin=True)\n        role = client.roles.get(role='keystone_admin')\n        self.assertEquals(role.id, 'keystone_admin')\n\n    def test_role_crud(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        test_role = 'new_role'\n        client = self.get_client(admin=True)\n        role = client.roles.create(name=test_role)\n        self.assertEquals(role.name, test_role)\n\n        role = client.roles.get(role=role.id)\n        self.assertEquals(role.name, test_role)\n\n        client.roles.delete(role=role.id)\n\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.delete,\n                          role=role.id)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.get,\n                          role=role.id)\n\n    def test_role_create_no_name(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.BadRequest,\n                          client.roles.create,\n                          name=\"\")\n\n    def test_role_get_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.get,\n                          role=uuid.uuid4().hex)\n\n    def test_role_delete_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.delete,\n                          role=uuid.uuid4().hex)\n\n    def test_role_list_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.roles_for_user,\n                          user=uuid.uuid4().hex,\n                          tenant=uuid.uuid4().hex)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.roles_for_user,\n                          user=self.user_foo['id'],\n                          tenant=uuid.uuid4().hex)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.roles_for_user,\n                          user=uuid.uuid4().hex,\n                          tenant=self.tenant_bar['id'])\n\n    def test_role_list(self):\n        client = self.get_client(admin=True)\n        roles = client.roles.list()\n        # TODO(devcamcar): This assert should be more specific.\n        self.assertTrue(len(roles) > 0)\n\n    def test_ec2_credential_crud(self):\n        client = self.get_client()\n        creds = client.ec2.list(user_id=self.user_foo['id'])\n        self.assertEquals(creds, [])\n\n        cred = client.ec2.create(user_id=self.user_foo['id'],\n                                 tenant_id=self.tenant_bar['id'])\n        creds = client.ec2.list(user_id=self.user_foo['id'])\n        self.assertEquals(creds, [cred])\n\n        got = client.ec2.get(user_id=self.user_foo['id'], access=cred.access)\n        self.assertEquals(cred, got)\n\n        client.ec2.delete(user_id=self.user_foo['id'], access=cred.access)\n        creds = client.ec2.list(user_id=self.user_foo['id'])\n        self.assertEquals(creds, [])\n\n    def test_ec2_credentials_create_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client()\n        self.assertRaises(client_exceptions.NotFound,\n                          client.ec2.create,\n                          user_id=uuid.uuid4().hex,\n                          tenant_id=self.tenant_bar['id'])\n        self.assertRaises(client_exceptions.NotFound,\n                          client.ec2.create,\n                          user_id=self.user_foo['id'],\n                          tenant_id=uuid.uuid4().hex)\n\n    def test_ec2_credentials_delete_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client()\n        self.assertRaises(client_exceptions.NotFound,\n                          client.ec2.delete,\n                          user_id=uuid.uuid4().hex,\n                          access=uuid.uuid4().hex)\n\n    def test_ec2_credentials_get_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client()\n        self.assertRaises(client_exceptions.NotFound,\n                          client.ec2.get,\n                          user_id=uuid.uuid4().hex,\n                          access=uuid.uuid4().hex)\n\n    def test_ec2_credentials_list_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client()\n        self.assertRaises(client_exceptions.NotFound,\n                          client.ec2.list,\n                          user_id=uuid.uuid4().hex)\n\n    def test_ec2_credentials_list_user_forbidden(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        two = self.get_client(self.user_two)\n        self.assertRaises(client_exceptions.Forbidden, two.ec2.list,\n                          user_id=self.user_foo['id'])\n\n    def test_ec2_credentials_get_user_forbidden(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        foo = self.get_client()\n        cred = foo.ec2.create(user_id=self.user_foo['id'],\n                              tenant_id=self.tenant_bar['id'])\n\n        two = self.get_client(self.user_two)\n        self.assertRaises(client_exceptions.Forbidden, two.ec2.get,\n                          user_id=self.user_foo['id'], access=cred.access)\n\n        foo.ec2.delete(user_id=self.user_foo['id'], access=cred.access)\n\n    def test_ec2_credentials_delete_user_forbidden(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        foo = self.get_client()\n        cred = foo.ec2.create(user_id=self.user_foo['id'],\n                              tenant_id=self.tenant_bar['id'])\n\n        two = self.get_client(self.user_two)\n        self.assertRaises(client_exceptions.Forbidden, two.ec2.delete,\n                          user_id=self.user_foo['id'], access=cred.access)\n\n        foo.ec2.delete(user_id=self.user_foo['id'], access=cred.access)\n\n    def test_service_crud(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n\n        service_name = uuid.uuid4().hex\n        service_type = uuid.uuid4().hex\n        service_desc = uuid.uuid4().hex\n\n        # create & read\n        service = client.services.create(name=service_name,\n                                         service_type=service_type,\n                                         description=service_desc)\n        self.assertEquals(service_name, service.name)\n        self.assertEquals(service_type, service.type)\n        self.assertEquals(service_desc, service.description)\n\n        service = client.services.get(id=service.id)\n        self.assertEquals(service_name, service.name)\n        self.assertEquals(service_type, service.type)\n        self.assertEquals(service_desc, service.description)\n\n        service = [x for x in client.services.list() if x.id == service.id][0]\n        self.assertEquals(service_name, service.name)\n        self.assertEquals(service_type, service.type)\n        self.assertEquals(service_desc, service.description)\n\n        # update is not supported...\n\n        # delete & read\n        client.services.delete(id=service.id)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.services.get,\n                          id=service.id)\n        services = [x for x in client.services.list() if x.id == service.id]\n        self.assertEquals(len(services), 0)\n\n    def test_service_delete_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.services.delete,\n                          id=uuid.uuid4().hex)\n\n    def test_service_get_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.services.get,\n                          id=uuid.uuid4().hex)\n\n    def test_endpoint_create_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.endpoints.create,\n                          region=uuid.uuid4().hex,\n                          service_id=uuid.uuid4().hex,\n                          publicurl=uuid.uuid4().hex,\n                          adminurl=uuid.uuid4().hex,\n                          internalurl=uuid.uuid4().hex)\n\n    def test_endpoint_delete_404(self):\n        # the catalog backend is expected to return Not Implemented\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.HTTPNotImplemented,\n                          client.endpoints.delete,\n                          id=uuid.uuid4().hex)\n\n    def test_admin_requires_adminness(self):\n        from keystoneclient import exceptions as client_exceptions\n        # FIXME(ja): this should be Unauthorized\n        exception = client_exceptions.ClientException\n\n        two = self.get_client(self.user_two, admin=True)  # non-admin user\n\n        # USER CRUD\n        self.assertRaises(exception,\n                          two.users.list)\n        self.assertRaises(exception,\n                          two.users.get,\n                          user=self.user_two['id'])\n        self.assertRaises(exception,\n                          two.users.create,\n                          name='oops',\n                          password='password',\n                          email='oops@test.com')\n        self.assertRaises(exception,\n                          two.users.delete,\n                          user=self.user_foo['id'])\n\n        # TENANT CRUD\n        self.assertRaises(exception,\n                          two.tenants.list)\n        self.assertRaises(exception,\n                          two.tenants.get,\n                          tenant_id=self.tenant_bar['id'])\n        self.assertRaises(exception,\n                          two.tenants.create,\n                          tenant_name='oops',\n                          description=\"shouldn't work!\",\n                          enabled=True)\n        self.assertRaises(exception,\n                          two.tenants.delete,\n                          tenant=self.tenant_baz['id'])\n\n        # ROLE CRUD\n        self.assertRaises(exception,\n                          two.roles.get,\n                          role='keystone_admin')\n        self.assertRaises(exception,\n                          two.roles.list)\n        self.assertRaises(exception,\n                          two.roles.create,\n                          name='oops')\n        self.assertRaises(exception,\n                          two.roles.delete,\n                          role='keystone_admin')\n\n        # TODO(ja): MEMBERSHIP CRUD\n        # TODO(ja): determine what else todo\n\n\nclass KcMasterTestCase(CompatTestCase, KeystoneClientTests):\n    def get_checkout(self):\n        return KEYSTONECLIENT_REPO, 'master'\n\n    def test_tenant_add_and_remove_user(self):\n        client = self.get_client(admin=True)\n        client.roles.add_user_role(tenant=self.tenant_baz['id'],\n                                   user=self.user_foo['id'],\n                                   role=self.role_useless['id'])\n        user_refs = client.tenants.list_users(tenant=self.tenant_baz['id'])\n        self.assert_(self.user_foo['id'] in [x.id for x in user_refs])\n        client.roles.remove_user_role(tenant=self.tenant_baz['id'],\n                                      user=self.user_foo['id'],\n                                      role=self.role_useless['id'])\n        user_refs = client.tenants.list_users(tenant=self.tenant_baz['id'])\n        self.assert_(self.user_foo['id'] not in [x.id for x in user_refs])\n\n    def test_user_role_add_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.add_user_role,\n                          tenant=uuid.uuid4().hex,\n                          user=self.user_foo['id'],\n                          role=self.role_useless['id'])\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.add_user_role,\n                          tenant=self.tenant_baz['id'],\n                          user=uuid.uuid4().hex,\n                          role=self.role_useless['id'])\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.add_user_role,\n                          tenant=self.tenant_baz['id'],\n                          user=self.user_foo['id'],\n                          role=uuid.uuid4().hex)\n\n    def test_user_role_remove_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.remove_user_role,\n                          tenant=uuid.uuid4().hex,\n                          user=self.user_foo['id'],\n                          role=self.role_useless['id'])\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.remove_user_role,\n                          tenant=self.tenant_baz['id'],\n                          user=uuid.uuid4().hex,\n                          role=self.role_useless['id'])\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.remove_user_role,\n                          tenant=self.tenant_baz['id'],\n                          user=self.user_foo['id'],\n                          role=uuid.uuid4().hex)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.remove_user_role,\n                          tenant=self.tenant_baz['id'],\n                          user=self.user_foo['id'],\n                          role=self.role_useless['id'])\n\n    def test_tenant_list_marker(self):\n        client = self.get_client()\n\n        # Add two arbitrary tenants to user for testing purposes\n        for i in range(2):\n            tenant_id = uuid.uuid4().hex\n            tenant = {'name': 'tenant-%s' % tenant_id, 'id': tenant_id}\n            self.identity_api.create_tenant(tenant_id, tenant)\n            self.identity_api.add_user_to_tenant(tenant_id,\n                                                 self.user_foo['id'])\n\n        tenants = client.tenants.list()\n        self.assertEqual(len(tenants), 3)\n\n        tenants_marker = client.tenants.list(marker=tenants[0].id)\n        self.assertEqual(len(tenants_marker), 2)\n        self.assertEqual(tenants[1].name, tenants_marker[0].name)\n        self.assertEqual(tenants[2].name, tenants_marker[1].name)\n\n    def test_tenant_list_marker_not_found(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        client = self.get_client()\n        self.assertRaises(client_exceptions.BadRequest,\n                          client.tenants.list, marker=uuid.uuid4().hex)\n\n    def test_tenant_list_limit(self):\n        client = self.get_client()\n\n        # Add two arbitrary tenants to user for testing purposes\n        for i in range(2):\n            tenant_id = uuid.uuid4().hex\n            tenant = {'name': 'tenant-%s' % tenant_id, 'id': tenant_id}\n            self.identity_api.create_tenant(tenant_id, tenant)\n            self.identity_api.add_user_to_tenant(tenant_id,\n                                                 self.user_foo['id'])\n\n        tenants = client.tenants.list()\n        self.assertEqual(len(tenants), 3)\n\n        tenants_limited = client.tenants.list(limit=2)\n        self.assertEqual(len(tenants_limited), 2)\n        self.assertEqual(tenants[0].name, tenants_limited[0].name)\n        self.assertEqual(tenants[1].name, tenants_limited[1].name)\n\n    def test_tenant_list_limit_bad_value(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        client = self.get_client()\n        self.assertRaises(client_exceptions.BadRequest,\n                          client.tenants.list, limit='a')\n        self.assertRaises(client_exceptions.BadRequest,\n                          client.tenants.list, limit=-1)\n\n    def test_roles_get_by_user(self):\n        client = self.get_client(admin=True)\n        roles = client.roles.roles_for_user(user=self.user_foo['id'],\n                                            tenant=self.tenant_bar['id'])\n        self.assertTrue(len(roles) > 0)\n\n\nclass KcEssex3TestCase(CompatTestCase, KeystoneClientTests):\n    def get_checkout(self):\n        return KEYSTONECLIENT_REPO, 'essex-3'\n\n    def test_tenant_add_and_remove_user(self):\n        client = self.get_client(admin=True)\n        client.roles.add_user_to_tenant(tenant_id=self.tenant_baz['id'],\n                                        user_id=self.user_foo['id'],\n                                        role_id=self.role_useless['id'])\n        role_refs = client.roles.get_user_role_refs(\n                user_id=self.user_foo['id'])\n        self.assert_(self.tenant_baz['id'] in [x.tenantId for x in role_refs])\n\n        # get the \"role_refs\" so we get the proper id, this is how the clients\n        # do it\n        roleref_refs = client.roles.get_user_role_refs(\n                user_id=self.user_foo['id'])\n        for roleref_ref in roleref_refs:\n            if (roleref_ref.roleId == self.role_useless['id']\n                and roleref_ref.tenantId == self.tenant_baz['id']):\n                # use python's scope fall through to leave roleref_ref set\n                break\n\n        client.roles.remove_user_from_tenant(tenant_id=self.tenant_baz['id'],\n                                             user_id=self.user_foo['id'],\n                                             role_id=roleref_ref.id)\n\n        role_refs = client.roles.get_user_role_refs(\n                user_id=self.user_foo['id'])\n        self.assert_(self.tenant_baz['id'] not in\n                     [x.tenantId for x in role_refs])\n\n    def test_roles_get_by_user(self):\n        client = self.get_client(admin=True)\n        roles = client.roles.get_user_role_refs(user_id='foo')\n        self.assertTrue(len(roles) > 0)\n\n    def test_role_list_404(self):\n        raise nose.exc.SkipTest('N/A')\n\n    def test_authenticate_and_delete_token(self):\n        raise nose.exc.SkipTest('N/A')\n\n    def test_user_create_update_delete(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        test_username = 'new_user'\n        client = self.get_client(admin=True)\n        user = client.users.create(name=test_username,\n                                   password='password',\n                                   email='user1@test.com')\n        self.assertEquals(user.name, test_username)\n\n        user = client.users.get(user=user.id)\n        self.assertEquals(user.name, test_username)\n\n        user = client.users.update_email(user=user, email='user2@test.com')\n        self.assertEquals(user.email, 'user2@test.com')\n\n        # NOTE(termie): update_enabled doesn't return anything, probably a bug\n        client.users.update_enabled(user=user, enabled=False)\n        user = client.users.get(user.id)\n        self.assertFalse(user.enabled)\n\n        self.assertRaises(client_exceptions.Unauthorized,\n                  self._client,\n                  username=test_username,\n                  password='password')\n        client.users.update_enabled(user, True)\n\n        user = client.users.update_password(user=user, password='password2')\n\n        self._client(username=test_username,\n                     password='password2')\n\n        user = client.users.update_tenant(user=user, tenant='bar')\n        # TODO(ja): once keystonelight supports default tenant\n        #           when you login without specifying tenant, the\n        #           token should be scoped to tenant 'bar'\n\n        client.users.delete(user.id)\n        self.assertRaises(client_exceptions.NotFound, client.users.get,\n                          user.id)\n\n    def test_user_update_404(self):\n        raise nose.exc.SkipTest('N/A')\n\n    def test_endpoint_create_404(self):\n        raise nose.exc.SkipTest('N/A')\n\n    def test_endpoint_delete_404(self):\n        raise nose.exc.SkipTest('N/A')\n"], "fixing_code": ["# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 OpenStack LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nimport uuid\n\nimport routes\n\nfrom keystone import catalog\nfrom keystone import exception\nfrom keystone import identity\nfrom keystone import policy\nfrom keystone import token\nfrom keystone.common import logging\nfrom keystone.common import utils\nfrom keystone.common import wsgi\n\n\nLOG = logging.getLogger(__name__)\n\n\nclass AdminRouter(wsgi.ComposingRouter):\n    def __init__(self):\n        mapper = routes.Mapper()\n\n        version_controller = VersionController('admin')\n        mapper.connect('/',\n                       controller=version_controller,\n                       action='get_version')\n\n        # Token Operations\n        auth_controller = TokenController()\n        mapper.connect('/tokens',\n                       controller=auth_controller,\n                       action='authenticate',\n                       conditions=dict(method=['POST']))\n        mapper.connect('/tokens/{token_id}',\n                       controller=auth_controller,\n                       action='validate_token',\n                       conditions=dict(method=['GET']))\n        mapper.connect('/tokens/{token_id}',\n                       controller=auth_controller,\n                       action='validate_token_head',\n                       conditions=dict(method=['HEAD']))\n        mapper.connect('/tokens/{token_id}',\n                       controller=auth_controller,\n                       action='delete_token',\n                       conditions=dict(method=['DELETE']))\n        mapper.connect('/tokens/{token_id}/endpoints',\n                       controller=auth_controller,\n                       action='endpoints',\n                       conditions=dict(method=['GET']))\n\n        # Miscellaneous Operations\n        extensions_controller = AdminExtensionsController()\n        mapper.connect('/extensions',\n                       controller=extensions_controller,\n                       action='get_extensions_info',\n                       conditions=dict(method=['GET']))\n        mapper.connect('/extensions/{extension_alias}',\n                       controller=extensions_controller,\n                       action='get_extension_info',\n                       conditions=dict(method=['GET']))\n        identity_router = identity.AdminRouter()\n        routers = [identity_router]\n        super(AdminRouter, self).__init__(mapper, routers)\n\n\nclass PublicRouter(wsgi.ComposingRouter):\n    def __init__(self):\n        mapper = routes.Mapper()\n\n        version_controller = VersionController('public')\n        mapper.connect('/',\n                       controller=version_controller,\n                       action='get_version')\n\n        # Token Operations\n        auth_controller = TokenController()\n        mapper.connect('/tokens',\n                       controller=auth_controller,\n                       action='authenticate',\n                       conditions=dict(method=['POST']))\n\n        # Miscellaneous\n        extensions_controller = PublicExtensionsController()\n        mapper.connect('/extensions',\n                       controller=extensions_controller,\n                       action='get_extensions_info',\n                       conditions=dict(method=['GET']))\n        mapper.connect('/extensions/{extension_alias}',\n                       controller=extensions_controller,\n                       action='get_extension_info',\n                       conditions=dict(method=['GET']))\n\n        identity_router = identity.PublicRouter()\n        routers = [identity_router]\n\n        super(PublicRouter, self).__init__(mapper, routers)\n\n\nclass PublicVersionRouter(wsgi.ComposingRouter):\n    def __init__(self):\n        mapper = routes.Mapper()\n        version_controller = VersionController('public')\n        mapper.connect('/',\n                       controller=version_controller,\n                       action='get_versions')\n        routers = []\n        super(PublicVersionRouter, self).__init__(mapper, routers)\n\n\nclass AdminVersionRouter(wsgi.ComposingRouter):\n    def __init__(self):\n        mapper = routes.Mapper()\n        version_controller = VersionController('admin')\n        mapper.connect('/',\n                       controller=version_controller,\n                       action='get_versions')\n        routers = []\n        super(AdminVersionRouter, self).__init__(mapper, routers)\n\n\nclass VersionController(wsgi.Application):\n    def __init__(self, version_type):\n        self.catalog_api = catalog.Manager()\n        self.url_key = \"%sURL\" % version_type\n\n        super(VersionController, self).__init__()\n\n    def _get_identity_url(self, context):\n        catalog_ref = self.catalog_api.get_catalog(\n                context=context,\n                user_id=None,\n                tenant_id=None)\n        for region, region_ref in catalog_ref.iteritems():\n            for service, service_ref in region_ref.iteritems():\n                if service == 'identity':\n                    return service_ref[self.url_key]\n\n        raise exception.NotImplemented()\n\n    def _get_versions_list(self, context):\n        \"\"\"The list of versions is dependent on the context.\"\"\"\n        identity_url = self._get_identity_url(context)\n        if not identity_url.endswith('/'):\n            identity_url = identity_url + '/'\n\n        versions = {}\n        versions['v2.0'] = {\n            \"id\": \"v2.0\",\n            \"status\": \"beta\",\n            \"updated\": \"2011-11-19T00:00:00Z\",\n            \"links\": [\n                {\n                    \"rel\": \"self\",\n                    \"href\": identity_url,\n                }, {\n                    \"rel\": \"describedby\",\n                    \"type\": \"text/html\",\n                    \"href\": \"http://docs.openstack.org/api/openstack-\"\n                                \"identity-service/2.0/content/\"\n                }, {\n                    \"rel\": \"describedby\",\n                    \"type\": \"application/pdf\",\n                    \"href\": \"http://docs.openstack.org/api/openstack-\"\n                                \"identity-service/2.0/identity-dev-guide-\"\n                                \"2.0.pdf\"\n                }\n            ],\n            \"media-types\": [\n                {\n                    \"base\": \"application/json\",\n                    \"type\": \"application/vnd.openstack.identity-v2.0\"\n                                \"+json\"\n                }, {\n                    \"base\": \"application/xml\",\n                    \"type\": \"application/vnd.openstack.identity-v2.0\"\n                                \"+xml\"\n                }\n            ]\n        }\n\n        return versions\n\n    def get_versions(self, context):\n        versions = self._get_versions_list(context)\n        return wsgi.render_response(status=(300, 'Multiple Choices'), body={\n            \"versions\": {\n                \"values\": versions.values()\n            }\n        })\n\n    def get_version(self, context):\n        versions = self._get_versions_list(context)\n        return wsgi.render_response(body={\n            \"version\": versions['v2.0']\n        })\n\n\nclass NoopController(wsgi.Application):\n    def __init__(self):\n        super(NoopController, self).__init__()\n\n    def noop(self, context):\n        return {}\n\n\nclass TokenController(wsgi.Application):\n    def __init__(self):\n        self.catalog_api = catalog.Manager()\n        self.identity_api = identity.Manager()\n        self.token_api = token.Manager()\n        self.policy_api = policy.Manager()\n        super(TokenController, self).__init__()\n\n    def authenticate(self, context, auth=None):\n        \"\"\"Authenticate credentials and return a token.\n\n        Accept auth as a dict that looks like::\n\n            {\n                \"auth\":{\n                    \"passwordCredentials\":{\n                        \"username\":\"test_user\",\n                        \"password\":\"mypass\"\n                    },\n                    \"tenantName\":\"customer-x\"\n                }\n            }\n\n        In this case, tenant is optional, if not provided the token will be\n        considered \"unscoped\" and can later be used to get a scoped token.\n\n        Alternatively, this call accepts auth with only a token and tenant\n        that will return a token that is scoped to that tenant.\n        \"\"\"\n\n        token_id = uuid.uuid4().hex\n        if 'passwordCredentials' in auth:\n            username = auth['passwordCredentials'].get('username', '')\n            password = auth['passwordCredentials'].get('password', '')\n            tenant_name = auth.get('tenantName', None)\n\n            user_id = auth['passwordCredentials'].get('userId', None)\n            if username:\n                user_ref = self.identity_api.get_user_by_name(\n                        context=context, user_name=username)\n                if user_ref:\n                    user_id = user_ref['id']\n\n            # more compat\n            tenant_id = auth.get('tenantId', None)\n            if tenant_name:\n                tenant_ref = self.identity_api.get_tenant_by_name(\n                        context=context, tenant_name=tenant_name)\n                if tenant_ref:\n                    tenant_id = tenant_ref['id']\n\n            try:\n                auth_info = self.identity_api.authenticate(context=context,\n                                                           user_id=user_id,\n                                                           password=password,\n                                                           tenant_id=tenant_id)\n                (user_ref, tenant_ref, metadata_ref) = auth_info\n\n                # If the user is disabled don't allow them to authenticate\n                if not user_ref.get('enabled', True):\n                    LOG.warning('User %s is disabled' % user_id)\n                    raise exception.Unauthorized()\n            except AssertionError as e:\n                raise exception.Unauthorized(e.message)\n\n            token_ref = self.token_api.create_token(\n                    context, token_id, dict(id=token_id,\n                                            user=user_ref,\n                                            tenant=tenant_ref,\n                                            metadata=metadata_ref))\n            if tenant_ref:\n                catalog_ref = self.catalog_api.get_catalog(\n                        context=context,\n                        user_id=user_ref['id'],\n                        tenant_id=tenant_ref['id'],\n                        metadata=metadata_ref)\n            else:\n                catalog_ref = {}\n\n        elif 'token' in auth:\n            token = auth['token'].get('id', None)\n\n            tenant_name = auth.get('tenantName')\n\n            # more compat\n            if tenant_name:\n                tenant_ref = self.identity_api.get_tenant_by_name(\n                        context=context, tenant_name=tenant_name)\n                tenant_id = tenant_ref['id']\n            else:\n                tenant_id = auth.get('tenantId', None)\n\n            try:\n                old_token_ref = self.token_api.get_token(context=context,\n                                                         token_id=token)\n            except exception.NotFound:\n                raise exception.Unauthorized()\n\n            user_ref = old_token_ref['user']\n\n            # If the user is disabled don't allow them to authenticate\n            current_user_ref = self.identity_api.get_user(\n                                                    context=context,\n                                                    user_id=user_ref['id'])\n            if not current_user_ref.get('enabled', True):\n                LOG.warning('User %s is disabled' % user_ref['id'])\n                raise exception.Unauthorized()\n\n            tenants = self.identity_api.get_tenants_for_user(context,\n                                                             user_ref['id'])\n            if tenant_id:\n                assert tenant_id in tenants\n\n            tenant_ref = self.identity_api.get_tenant(context=context,\n                                                      tenant_id=tenant_id)\n            if tenant_ref:\n                metadata_ref = self.identity_api.get_metadata(\n                        context=context,\n                        user_id=user_ref['id'],\n                        tenant_id=tenant_ref['id'])\n                catalog_ref = self.catalog_api.get_catalog(\n                        context=context,\n                        user_id=user_ref['id'],\n                        tenant_id=tenant_ref['id'],\n                        metadata=metadata_ref)\n            else:\n                metadata_ref = {}\n                catalog_ref = {}\n\n            token_ref = self.token_api.create_token(\n                    context, token_id, dict(id=token_id,\n                                            user=user_ref,\n                                            tenant=tenant_ref,\n                                            metadata=metadata_ref,\n                                            expires=old_token_ref['expires']))\n\n        # TODO(termie): optimize this call at some point and put it into the\n        #               the return for metadata\n        # fill out the roles in the metadata\n        roles_ref = []\n        for role_id in metadata_ref.get('roles', []):\n            roles_ref.append(self.identity_api.get_role(context, role_id))\n        logging.debug('TOKEN_REF %s', token_ref)\n        return self._format_authenticate(token_ref, roles_ref, catalog_ref)\n\n    def _get_token_ref(self, context, token_id, belongs_to=None):\n        \"\"\"Returns a token if a valid one exists.\n\n        Optionally, limited to a token owned by a specific tenant.\n\n        \"\"\"\n        # TODO(termie): this stuff should probably be moved to middleware\n        self.assert_admin(context)\n\n        token_ref = self.token_api.get_token(context=context,\n                                             token_id=token_id)\n\n        if belongs_to:\n            assert token_ref['tenant']['id'] == belongs_to\n\n        return token_ref\n\n    # admin only\n    def validate_token_head(self, context, token_id):\n        \"\"\"Check that a token is valid.\n\n        Optionally, also ensure that it is owned by a specific tenant.\n\n        Identical to ``validate_token``, except does not return a response.\n\n        \"\"\"\n        belongs_to = context['query_string'].get(\"belongsTo\")\n        assert self._get_token_ref(context, token_id, belongs_to)\n\n    # admin only\n    def validate_token(self, context, token_id):\n        \"\"\"Check that a token is valid.\n\n        Optionally, also ensure that it is owned by a specific tenant.\n\n        Returns metadata about the token along any associated roles.\n\n        \"\"\"\n        belongs_to = context['query_string'].get(\"belongsTo\")\n        token_ref = self._get_token_ref(context, token_id, belongs_to)\n\n        # TODO(termie): optimize this call at some point and put it into the\n        #               the return for metadata\n        # fill out the roles in the metadata\n        metadata_ref = token_ref['metadata']\n        roles_ref = []\n        for role_id in metadata_ref.get('roles', []):\n            roles_ref.append(self.identity_api.get_role(context, role_id))\n\n        # Get a service catalog if belongs_to is not none\n        # This is needed for on-behalf-of requests\n        catalog_ref = None\n        if belongs_to is not None:\n            catalog_ref = self.catalog_api.get_catalog(\n                context=context,\n                user_id=token_ref['user']['id'],\n                tenant_id=token_ref['tenant']['id'],\n                metadata=metadata_ref)\n        return self._format_token(token_ref, roles_ref, catalog_ref)\n\n    def delete_token(self, context, token_id):\n        \"\"\"Delete a token, effectively invalidating it for authz.\"\"\"\n        # TODO(termie): this stuff should probably be moved to middleware\n        self.assert_admin(context)\n\n        self.token_api.delete_token(context=context, token_id=token_id)\n\n    def endpoints(self, context, token_id):\n        \"\"\"Return a list of endpoints available to the token.\"\"\"\n        raise exception.NotImplemented()\n\n    def _format_authenticate(self, token_ref, roles_ref, catalog_ref):\n        o = self._format_token(token_ref, roles_ref)\n        o['access']['serviceCatalog'] = self._format_catalog(catalog_ref)\n        return o\n\n    def _format_token(self, token_ref, roles_ref, catalog_ref=None):\n        user_ref = token_ref['user']\n        metadata_ref = token_ref['metadata']\n        expires = token_ref['expires']\n        if expires is not None:\n            expires = utils.isotime(expires)\n        o = {'access': {'token': {'id': token_ref['id'],\n                                  'expires': expires,\n                                  },\n                        'user': {'id': user_ref['id'],\n                                 'name': user_ref['name'],\n                                 'username': user_ref['name'],\n                                 'roles': roles_ref,\n                                 'roles_links': metadata_ref.get('roles_links',\n                                                               [])\n                                 }\n                        }\n             }\n        if 'tenant' in token_ref and token_ref['tenant']:\n            token_ref['tenant']['enabled'] = True\n            o['access']['token']['tenant'] = token_ref['tenant']\n        if catalog_ref is not None:\n            o['access']['serviceCatalog'] = self._format_catalog(catalog_ref)\n        return o\n\n    def _format_catalog(self, catalog_ref):\n        \"\"\"Munge catalogs from internal to output format\n        Internal catalogs look like:\n\n        {$REGION: {\n            {$SERVICE: {\n                $key1: $value1,\n                ...\n                }\n            }\n        }\n\n        The legacy api wants them to look like\n\n        [{'name': $SERVICE[name],\n          'type': $SERVICE,\n          'endpoints': [{\n              'tenantId': $tenant_id,\n              ...\n              'region': $REGION,\n              }],\n          'endpoints_links': [],\n         }]\n\n        \"\"\"\n        if not catalog_ref:\n            return {}\n\n        services = {}\n        for region, region_ref in catalog_ref.iteritems():\n            for service, service_ref in region_ref.iteritems():\n                new_service_ref = services.get(service, {})\n                new_service_ref['name'] = service_ref.pop('name')\n                new_service_ref['type'] = service\n                new_service_ref['endpoints_links'] = []\n                service_ref['region'] = region\n\n                endpoints_ref = new_service_ref.get('endpoints', [])\n                endpoints_ref.append(service_ref)\n\n                new_service_ref['endpoints'] = endpoints_ref\n                services[service] = new_service_ref\n\n        return services.values()\n\n\nclass ExtensionsController(wsgi.Application):\n    \"\"\"Base extensions controller to be extended by public and admin API's.\"\"\"\n\n    def __init__(self, extensions=None):\n        super(ExtensionsController, self).__init__()\n\n        self.extensions = extensions or {}\n\n    def get_extensions_info(self, context):\n        return {'extensions': {'values': self.extensions.values()}}\n\n    def get_extension_info(self, context, extension_alias):\n        try:\n            return {'extension': self.extensions[extension_alias]}\n        except KeyError:\n            raise exception.NotFound(target=extension_alias)\n\n\nclass PublicExtensionsController(ExtensionsController):\n    pass\n\n\nclass AdminExtensionsController(ExtensionsController):\n    def __init__(self, *args, **kwargs):\n        super(AdminExtensionsController, self).__init__(*args, **kwargs)\n\n        # TODO(dolph): Extensions should obviously provide this information\n        #               themselves, but hardcoding it here allows us to match\n        #               the API spec in the short term with minimal complexity.\n        self.extensions['OS-KSADM'] = {\n            'name': 'Openstack Keystone Admin',\n            'namespace': 'http://docs.openstack.org/identity/api/ext/'\n                         'OS-KSADM/v1.0',\n            'alias': 'OS-KSADM',\n            'updated': '2011-08-19T13:25:27-06:00',\n            'description': 'Openstack extensions to Keystone v2.0 API '\n                           'enabling Admin Operations.',\n            'links': [\n                {\n                    'rel': 'describedby',\n                    # TODO(dolph): link needs to be revised after\n                    #              bug 928059 merges\n                    'type': 'text/html',\n                    'href': ('https://github.com/openstack/'\n                        'identity-api'),\n                }\n            ]\n        }\n\n\n@logging.fail_gracefully\ndef public_app_factory(global_conf, **local_conf):\n    conf = global_conf.copy()\n    conf.update(local_conf)\n    return PublicRouter()\n\n\n@logging.fail_gracefully\ndef admin_app_factory(global_conf, **local_conf):\n    conf = global_conf.copy()\n    conf.update(local_conf)\n    return AdminRouter()\n\n\n@logging.fail_gracefully\ndef public_version_app_factory(global_conf, **local_conf):\n    conf = global_conf.copy()\n    conf.update(local_conf)\n    return PublicVersionRouter()\n\n\n@logging.fail_gracefully\ndef admin_version_app_factory(global_conf, **local_conf):\n    conf = global_conf.copy()\n    conf.update(local_conf)\n    return AdminVersionRouter()\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 OpenStack LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nimport time\nimport uuid\n\nimport nose.exc\n\nfrom keystone import test\n\nimport default_fixtures\n\nOPENSTACK_REPO = 'https://review.openstack.org/p/openstack'\nKEYSTONECLIENT_REPO = '%s/python-keystoneclient.git' % OPENSTACK_REPO\n\n\nclass CompatTestCase(test.TestCase):\n    def setUp(self):\n        super(CompatTestCase, self).setUp()\n\n        revdir = test.checkout_vendor(*self.get_checkout())\n        self.add_path(revdir)\n        self.clear_module('keystoneclient')\n\n        self.load_backends()\n        self.load_fixtures(default_fixtures)\n\n        self.public_server = self.serveapp('keystone', name='main')\n        self.admin_server = self.serveapp('keystone', name='admin')\n\n        # TODO(termie): is_admin is being deprecated once the policy stuff\n        #               is all working\n        # TODO(termie): add an admin user to the fixtures and use that user\n        # override the fixtures, for now\n        self.metadata_foobar = self.identity_api.update_metadata(\n            self.user_foo['id'], self.tenant_bar['id'],\n            dict(roles=['keystone_admin'], is_admin='1'))\n\n    def tearDown(self):\n        self.public_server.kill()\n        self.admin_server.kill()\n        self.public_server = None\n        self.admin_server = None\n        super(CompatTestCase, self).tearDown()\n\n    def _public_url(self):\n        public_port = self.public_server.socket_info['socket'][1]\n        return \"http://localhost:%s/v2.0\" % public_port\n\n    def _admin_url(self):\n        admin_port = self.admin_server.socket_info['socket'][1]\n        return \"http://localhost:%s/v2.0\" % admin_port\n\n    def _client(self, admin=False, **kwargs):\n        from keystoneclient.v2_0 import client as ks_client\n\n        url = self._admin_url() if admin else self._public_url()\n        kc = ks_client.Client(endpoint=url,\n                              auth_url=self._public_url(),\n                              **kwargs)\n        kc.authenticate()\n        # have to manually overwrite the management url after authentication\n        kc.management_url = url\n        return kc\n\n    def get_client(self, user_ref=None, tenant_ref=None, admin=False):\n        if user_ref is None:\n            user_ref = self.user_foo\n        if tenant_ref is None:\n            for user in default_fixtures.USERS:\n                if user['id'] == user_ref['id']:\n                    tenant_id = user['tenants'][0]\n        else:\n            tenant_id = tenant_ref['id']\n\n        return self._client(username=user_ref['name'],\n                            password=user_ref['password'],\n                            tenant_id=tenant_id,\n                            admin=admin)\n\n\nclass KeystoneClientTests(object):\n    \"\"\"Tests for all versions of keystoneclient.\"\"\"\n\n    def test_authenticate_tenant_name_and_tenants(self):\n        client = self.get_client()\n        tenants = client.tenants.list()\n        self.assertEquals(tenants[0].id, self.tenant_bar['id'])\n\n    def test_authenticate_tenant_id_and_tenants(self):\n        client = self._client(username=self.user_foo['name'],\n                              password=self.user_foo['password'],\n                              tenant_id='bar')\n        tenants = client.tenants.list()\n        self.assertEquals(tenants[0].id, self.tenant_bar['id'])\n\n    def test_authenticate_invalid_tenant_id(self):\n        from keystoneclient import exceptions as client_exceptions\n        self.assertRaises(client_exceptions.Unauthorized,\n                          self._client,\n                          username=self.user_foo['name'],\n                          password=self.user_foo['password'],\n                          tenant_id='baz')\n\n    def test_authenticate_token_no_tenant(self):\n        client = self.get_client()\n        token = client.auth_token\n        token_client = self._client(token=token)\n        tenants = token_client.tenants.list()\n        self.assertEquals(tenants[0].id, self.tenant_bar['id'])\n\n    def test_authenticate_token_tenant_id(self):\n        client = self.get_client()\n        token = client.auth_token\n        token_client = self._client(token=token, tenant_id='bar')\n        tenants = token_client.tenants.list()\n        self.assertEquals(tenants[0].id, self.tenant_bar['id'])\n\n    def test_authenticate_token_invalid_tenant_id(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client()\n        token = client.auth_token\n        self.assertRaises(client_exceptions.AuthorizationFailure,\n                          self._client, token=token, tenant_id='baz')\n\n    def test_authenticate_token_tenant_name(self):\n        client = self.get_client()\n        token = client.auth_token\n        token_client = self._client(token=token, tenant_name='BAR')\n        tenants = token_client.tenants.list()\n        self.assertEquals(tenants[0].id, self.tenant_bar['id'])\n        self.assertEquals(tenants[0].id, self.tenant_bar['id'])\n\n    def test_authenticate_and_delete_token(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        client = self.get_client(admin=True)\n        token = client.auth_token\n        token_client = self._client(token=token)\n        tenants = token_client.tenants.list()\n        self.assertEquals(tenants[0].id, self.tenant_bar['id'])\n\n        client.tokens.delete(token_client.auth_token)\n\n        self.assertRaises(client_exceptions.Unauthorized,\n                          token_client.tenants.list)\n\n    def test_authenticate_no_password(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        user_ref = self.user_foo.copy()\n        user_ref['password'] = None\n        self.assertRaises(client_exceptions.AuthorizationFailure,\n                          self.get_client,\n                          user_ref)\n\n    def test_authenticate_no_username(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        user_ref = self.user_foo.copy()\n        user_ref['name'] = None\n        self.assertRaises(client_exceptions.AuthorizationFailure,\n                          self.get_client,\n                          user_ref)\n\n    # FIXME(ja): this test should require the \"keystone:admin\" roled\n    #            (probably the role set via --keystone_admin_role flag)\n    # FIXME(ja): add a test that admin endpoint is only sent to admin user\n    # FIXME(ja): add a test that admin endpoint returns unauthorized if not\n    #            admin\n    def test_tenant_create_update_and_delete(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        tenant_name = 'original_tenant'\n        tenant_description = 'My original tenant!'\n        tenant_enabled = True\n        client = self.get_client(admin=True)\n\n        # create, get, and list a tenant\n        tenant = client.tenants.create(tenant_name=tenant_name,\n                                       description=tenant_description,\n                                       enabled=tenant_enabled)\n        self.assertEquals(tenant.name, tenant_name)\n        self.assertEquals(tenant.description, tenant_description)\n        self.assertEquals(tenant.enabled, tenant_enabled)\n\n        tenant = client.tenants.get(tenant_id=tenant.id)\n        self.assertEquals(tenant.name, tenant_name)\n        self.assertEquals(tenant.description, tenant_description)\n        self.assertEquals(tenant.enabled, tenant_enabled)\n\n        tenant = [t for t in client.tenants.list() if t.id == tenant.id].pop()\n        self.assertEquals(tenant.name, tenant_name)\n        self.assertEquals(tenant.description, tenant_description)\n        self.assertEquals(tenant.enabled, tenant_enabled)\n\n        # update, get, and list a tenant\n        tenant_name = 'updated_tenant'\n        tenant_description = 'Updated tenant!'\n        tenant_enabled = False\n        tenant = client.tenants.update(tenant_id=tenant.id,\n                                       tenant_name=tenant_name,\n                                       enabled=tenant_enabled,\n                                       description=tenant_description)\n        self.assertEquals(tenant.name, tenant_name)\n        self.assertEquals(tenant.description, tenant_description)\n        self.assertEquals(tenant.enabled, tenant_enabled)\n\n        tenant = client.tenants.get(tenant_id=tenant.id)\n        self.assertEquals(tenant.name, tenant_name)\n        self.assertEquals(tenant.description, tenant_description)\n        self.assertEquals(tenant.enabled, tenant_enabled)\n\n        tenant = [t for t in client.tenants.list() if t.id == tenant.id].pop()\n        self.assertEquals(tenant.name, tenant_name)\n        self.assertEquals(tenant.description, tenant_description)\n        self.assertEquals(tenant.enabled, tenant_enabled)\n\n        # delete, get, and list a tenant\n        client.tenants.delete(tenant=tenant.id)\n        self.assertRaises(client_exceptions.NotFound, client.tenants.get,\n                          tenant.id)\n        self.assertFalse([t for t in client.tenants.list()\n                           if t.id == tenant.id])\n\n    def test_tenant_create_no_name(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.BadRequest,\n                          client.tenants.create,\n                          tenant_name=\"\")\n\n    def test_tenant_delete_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.tenants.delete,\n                          tenant=uuid.uuid4().hex)\n\n    def test_tenant_get_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.tenants.get,\n                          tenant_id=uuid.uuid4().hex)\n\n    def test_tenant_update_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.tenants.update,\n                          tenant_id=uuid.uuid4().hex)\n\n    def test_tenant_list(self):\n        client = self.get_client()\n        tenants = client.tenants.list()\n        self.assertEquals(len(tenants), 1)\n\n        # Admin endpoint should return *all* tenants\n        client = self.get_client(admin=True)\n        tenants = client.tenants.list()\n        self.assertEquals(len(tenants), len(default_fixtures.TENANTS))\n\n    def test_invalid_password(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        good_client = self._client(username=self.user_foo['name'],\n                                   password=self.user_foo['password'])\n        good_client.tenants.list()\n\n        self.assertRaises(client_exceptions.Unauthorized,\n                          self._client,\n                          username=self.user_foo['name'],\n                          password='invalid')\n\n    def test_invalid_user_password(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        self.assertRaises(client_exceptions.Unauthorized,\n                          self._client,\n                          username='blah',\n                          password='blah')\n\n    def test_change_password_invalidates_token(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        client = self.get_client(admin=True)\n\n        username = uuid.uuid4().hex\n        passwd = uuid.uuid4().hex\n        user = client.users.create(name=username, password=passwd,\n                                   email=uuid.uuid4().hex)\n\n        token_id = client.tokens.authenticate(username=username,\n                                              password=passwd).id\n\n        # authenticate with a token should work before a password change\n        client.tokens.authenticate(token=token_id)\n\n        client.users.update_password(user=user.id, password=uuid.uuid4().hex)\n\n        # authenticate with a token should not work after a password change\n        self.assertRaises(client_exceptions.Unauthorized,\n                          client.tokens.authenticate,\n                          token=token_id)\n\n    def test_disable_user_invalidates_token(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        admin_client = self.get_client(admin=True)\n        foo_client = self.get_client(self.user_foo)\n\n        admin_client.users.update_enabled(user=self.user_foo['id'],\n                                          enabled=False)\n\n        self.assertRaises(client_exceptions.Unauthorized,\n                          foo_client.tokens.authenticate,\n                          token=foo_client.auth_token)\n\n        self.assertRaises(client_exceptions.Unauthorized,\n                          self.get_client,\n                          self.user_foo)\n\n    def test_token_expiry_maintained(self):\n        foo_client = self.get_client(self.user_foo)\n        orig_token = foo_client.service_catalog.catalog['token']\n\n        time.sleep(1.01)\n        reauthenticated_token = foo_client.tokens.authenticate(\n                                    token=foo_client.auth_token)\n\n        self.assertEquals(orig_token['expires'],\n                          reauthenticated_token.expires)\n\n    def test_user_create_update_delete(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        test_username = 'new_user'\n        client = self.get_client(admin=True)\n        user = client.users.create(name=test_username,\n                                   password='password',\n                                   email='user1@test.com')\n        self.assertEquals(user.name, test_username)\n\n        user = client.users.get(user=user.id)\n        self.assertEquals(user.name, test_username)\n\n        user = client.users.update(user=user,\n                                   name=test_username,\n                                   email='user2@test.com')\n        self.assertEquals(user.email, 'user2@test.com')\n\n        # NOTE(termie): update_enabled doesn't return anything, probably a bug\n        client.users.update_enabled(user=user, enabled=False)\n        user = client.users.get(user.id)\n        self.assertFalse(user.enabled)\n\n        self.assertRaises(client_exceptions.Unauthorized,\n                  self._client,\n                  username=test_username,\n                  password='password')\n        client.users.update_enabled(user, True)\n\n        user = client.users.update_password(user=user, password='password2')\n\n        self._client(username=test_username,\n                     password='password2')\n\n        user = client.users.update_tenant(user=user, tenant='bar')\n        # TODO(ja): once keystonelight supports default tenant\n        #           when you login without specifying tenant, the\n        #           token should be scoped to tenant 'bar'\n\n        client.users.delete(user.id)\n        self.assertRaises(client_exceptions.NotFound, client.users.get,\n                          user.id)\n\n        # Test creating a user with a tenant (auto-add to tenant)\n        user2 = client.users.create(name=test_username,\n                                    password='password',\n                                    email='user1@test.com',\n                                    tenant_id='bar')\n        self.assertEquals(user2.name, test_username)\n\n    def test_user_create_no_name(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.BadRequest,\n                          client.users.create,\n                          name=\"\",\n                          password=uuid.uuid4().hex,\n                          email=uuid.uuid4().hex)\n\n    def test_user_create_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.users.create,\n                          name=uuid.uuid4().hex,\n                          password=uuid.uuid4().hex,\n                          email=uuid.uuid4().hex,\n                          tenant_id=uuid.uuid4().hex)\n\n    def test_user_get_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.users.get,\n                          user=uuid.uuid4().hex)\n\n    def test_user_list_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.users.list,\n                          tenant_id=uuid.uuid4().hex)\n\n    def test_user_update_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.users.update,\n                          user=uuid.uuid4().hex)\n\n    def test_user_update_tenant_404(self):\n        raise nose.exc.SkipTest('N/A')\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.users.update,\n                          user=self.user_foo['id'],\n                          tenant_id=uuid.uuid4().hex)\n\n    def test_user_update_password_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.users.update_password,\n                          user=uuid.uuid4().hex,\n                          password=uuid.uuid4().hex)\n\n    def test_user_delete_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.users.delete,\n                          user=uuid.uuid4().hex)\n\n    def test_user_list(self):\n        client = self.get_client(admin=True)\n        users = client.users.list()\n        self.assertTrue(len(users) > 0)\n        user = users[0]\n        self.assertRaises(AttributeError, lambda: user.password)\n\n    def test_user_get(self):\n        client = self.get_client(admin=True)\n        user = client.users.get(user=self.user_foo['id'])\n        self.assertRaises(AttributeError, lambda: user.password)\n\n    def test_role_get(self):\n        client = self.get_client(admin=True)\n        role = client.roles.get(role='keystone_admin')\n        self.assertEquals(role.id, 'keystone_admin')\n\n    def test_role_crud(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        test_role = 'new_role'\n        client = self.get_client(admin=True)\n        role = client.roles.create(name=test_role)\n        self.assertEquals(role.name, test_role)\n\n        role = client.roles.get(role=role.id)\n        self.assertEquals(role.name, test_role)\n\n        client.roles.delete(role=role.id)\n\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.delete,\n                          role=role.id)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.get,\n                          role=role.id)\n\n    def test_role_create_no_name(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.BadRequest,\n                          client.roles.create,\n                          name=\"\")\n\n    def test_role_get_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.get,\n                          role=uuid.uuid4().hex)\n\n    def test_role_delete_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.delete,\n                          role=uuid.uuid4().hex)\n\n    def test_role_list_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.roles_for_user,\n                          user=uuid.uuid4().hex,\n                          tenant=uuid.uuid4().hex)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.roles_for_user,\n                          user=self.user_foo['id'],\n                          tenant=uuid.uuid4().hex)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.roles_for_user,\n                          user=uuid.uuid4().hex,\n                          tenant=self.tenant_bar['id'])\n\n    def test_role_list(self):\n        client = self.get_client(admin=True)\n        roles = client.roles.list()\n        # TODO(devcamcar): This assert should be more specific.\n        self.assertTrue(len(roles) > 0)\n\n    def test_ec2_credential_crud(self):\n        client = self.get_client()\n        creds = client.ec2.list(user_id=self.user_foo['id'])\n        self.assertEquals(creds, [])\n\n        cred = client.ec2.create(user_id=self.user_foo['id'],\n                                 tenant_id=self.tenant_bar['id'])\n        creds = client.ec2.list(user_id=self.user_foo['id'])\n        self.assertEquals(creds, [cred])\n\n        got = client.ec2.get(user_id=self.user_foo['id'], access=cred.access)\n        self.assertEquals(cred, got)\n\n        client.ec2.delete(user_id=self.user_foo['id'], access=cred.access)\n        creds = client.ec2.list(user_id=self.user_foo['id'])\n        self.assertEquals(creds, [])\n\n    def test_ec2_credentials_create_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client()\n        self.assertRaises(client_exceptions.NotFound,\n                          client.ec2.create,\n                          user_id=uuid.uuid4().hex,\n                          tenant_id=self.tenant_bar['id'])\n        self.assertRaises(client_exceptions.NotFound,\n                          client.ec2.create,\n                          user_id=self.user_foo['id'],\n                          tenant_id=uuid.uuid4().hex)\n\n    def test_ec2_credentials_delete_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client()\n        self.assertRaises(client_exceptions.NotFound,\n                          client.ec2.delete,\n                          user_id=uuid.uuid4().hex,\n                          access=uuid.uuid4().hex)\n\n    def test_ec2_credentials_get_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client()\n        self.assertRaises(client_exceptions.NotFound,\n                          client.ec2.get,\n                          user_id=uuid.uuid4().hex,\n                          access=uuid.uuid4().hex)\n\n    def test_ec2_credentials_list_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client()\n        self.assertRaises(client_exceptions.NotFound,\n                          client.ec2.list,\n                          user_id=uuid.uuid4().hex)\n\n    def test_ec2_credentials_list_user_forbidden(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        two = self.get_client(self.user_two)\n        self.assertRaises(client_exceptions.Forbidden, two.ec2.list,\n                          user_id=self.user_foo['id'])\n\n    def test_ec2_credentials_get_user_forbidden(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        foo = self.get_client()\n        cred = foo.ec2.create(user_id=self.user_foo['id'],\n                              tenant_id=self.tenant_bar['id'])\n\n        two = self.get_client(self.user_two)\n        self.assertRaises(client_exceptions.Forbidden, two.ec2.get,\n                          user_id=self.user_foo['id'], access=cred.access)\n\n        foo.ec2.delete(user_id=self.user_foo['id'], access=cred.access)\n\n    def test_ec2_credentials_delete_user_forbidden(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        foo = self.get_client()\n        cred = foo.ec2.create(user_id=self.user_foo['id'],\n                              tenant_id=self.tenant_bar['id'])\n\n        two = self.get_client(self.user_two)\n        self.assertRaises(client_exceptions.Forbidden, two.ec2.delete,\n                          user_id=self.user_foo['id'], access=cred.access)\n\n        foo.ec2.delete(user_id=self.user_foo['id'], access=cred.access)\n\n    def test_service_crud(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n\n        service_name = uuid.uuid4().hex\n        service_type = uuid.uuid4().hex\n        service_desc = uuid.uuid4().hex\n\n        # create & read\n        service = client.services.create(name=service_name,\n                                         service_type=service_type,\n                                         description=service_desc)\n        self.assertEquals(service_name, service.name)\n        self.assertEquals(service_type, service.type)\n        self.assertEquals(service_desc, service.description)\n\n        service = client.services.get(id=service.id)\n        self.assertEquals(service_name, service.name)\n        self.assertEquals(service_type, service.type)\n        self.assertEquals(service_desc, service.description)\n\n        service = [x for x in client.services.list() if x.id == service.id][0]\n        self.assertEquals(service_name, service.name)\n        self.assertEquals(service_type, service.type)\n        self.assertEquals(service_desc, service.description)\n\n        # update is not supported...\n\n        # delete & read\n        client.services.delete(id=service.id)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.services.get,\n                          id=service.id)\n        services = [x for x in client.services.list() if x.id == service.id]\n        self.assertEquals(len(services), 0)\n\n    def test_service_delete_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.services.delete,\n                          id=uuid.uuid4().hex)\n\n    def test_service_get_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.services.get,\n                          id=uuid.uuid4().hex)\n\n    def test_endpoint_create_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.endpoints.create,\n                          region=uuid.uuid4().hex,\n                          service_id=uuid.uuid4().hex,\n                          publicurl=uuid.uuid4().hex,\n                          adminurl=uuid.uuid4().hex,\n                          internalurl=uuid.uuid4().hex)\n\n    def test_endpoint_delete_404(self):\n        # the catalog backend is expected to return Not Implemented\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.HTTPNotImplemented,\n                          client.endpoints.delete,\n                          id=uuid.uuid4().hex)\n\n    def test_admin_requires_adminness(self):\n        from keystoneclient import exceptions as client_exceptions\n        # FIXME(ja): this should be Unauthorized\n        exception = client_exceptions.ClientException\n\n        two = self.get_client(self.user_two, admin=True)  # non-admin user\n\n        # USER CRUD\n        self.assertRaises(exception,\n                          two.users.list)\n        self.assertRaises(exception,\n                          two.users.get,\n                          user=self.user_two['id'])\n        self.assertRaises(exception,\n                          two.users.create,\n                          name='oops',\n                          password='password',\n                          email='oops@test.com')\n        self.assertRaises(exception,\n                          two.users.delete,\n                          user=self.user_foo['id'])\n\n        # TENANT CRUD\n        self.assertRaises(exception,\n                          two.tenants.list)\n        self.assertRaises(exception,\n                          two.tenants.get,\n                          tenant_id=self.tenant_bar['id'])\n        self.assertRaises(exception,\n                          two.tenants.create,\n                          tenant_name='oops',\n                          description=\"shouldn't work!\",\n                          enabled=True)\n        self.assertRaises(exception,\n                          two.tenants.delete,\n                          tenant=self.tenant_baz['id'])\n\n        # ROLE CRUD\n        self.assertRaises(exception,\n                          two.roles.get,\n                          role='keystone_admin')\n        self.assertRaises(exception,\n                          two.roles.list)\n        self.assertRaises(exception,\n                          two.roles.create,\n                          name='oops')\n        self.assertRaises(exception,\n                          two.roles.delete,\n                          role='keystone_admin')\n\n        # TODO(ja): MEMBERSHIP CRUD\n        # TODO(ja): determine what else todo\n\n\nclass KcMasterTestCase(CompatTestCase, KeystoneClientTests):\n    def get_checkout(self):\n        return KEYSTONECLIENT_REPO, 'master'\n\n    def test_tenant_add_and_remove_user(self):\n        client = self.get_client(admin=True)\n        client.roles.add_user_role(tenant=self.tenant_baz['id'],\n                                   user=self.user_foo['id'],\n                                   role=self.role_useless['id'])\n        user_refs = client.tenants.list_users(tenant=self.tenant_baz['id'])\n        self.assert_(self.user_foo['id'] in [x.id for x in user_refs])\n        client.roles.remove_user_role(tenant=self.tenant_baz['id'],\n                                      user=self.user_foo['id'],\n                                      role=self.role_useless['id'])\n        user_refs = client.tenants.list_users(tenant=self.tenant_baz['id'])\n        self.assert_(self.user_foo['id'] not in [x.id for x in user_refs])\n\n    def test_user_role_add_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.add_user_role,\n                          tenant=uuid.uuid4().hex,\n                          user=self.user_foo['id'],\n                          role=self.role_useless['id'])\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.add_user_role,\n                          tenant=self.tenant_baz['id'],\n                          user=uuid.uuid4().hex,\n                          role=self.role_useless['id'])\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.add_user_role,\n                          tenant=self.tenant_baz['id'],\n                          user=self.user_foo['id'],\n                          role=uuid.uuid4().hex)\n\n    def test_user_role_remove_404(self):\n        from keystoneclient import exceptions as client_exceptions\n        client = self.get_client(admin=True)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.remove_user_role,\n                          tenant=uuid.uuid4().hex,\n                          user=self.user_foo['id'],\n                          role=self.role_useless['id'])\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.remove_user_role,\n                          tenant=self.tenant_baz['id'],\n                          user=uuid.uuid4().hex,\n                          role=self.role_useless['id'])\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.remove_user_role,\n                          tenant=self.tenant_baz['id'],\n                          user=self.user_foo['id'],\n                          role=uuid.uuid4().hex)\n        self.assertRaises(client_exceptions.NotFound,\n                          client.roles.remove_user_role,\n                          tenant=self.tenant_baz['id'],\n                          user=self.user_foo['id'],\n                          role=self.role_useless['id'])\n\n    def test_tenant_list_marker(self):\n        client = self.get_client()\n\n        # Add two arbitrary tenants to user for testing purposes\n        for i in range(2):\n            tenant_id = uuid.uuid4().hex\n            tenant = {'name': 'tenant-%s' % tenant_id, 'id': tenant_id}\n            self.identity_api.create_tenant(tenant_id, tenant)\n            self.identity_api.add_user_to_tenant(tenant_id,\n                                                 self.user_foo['id'])\n\n        tenants = client.tenants.list()\n        self.assertEqual(len(tenants), 3)\n\n        tenants_marker = client.tenants.list(marker=tenants[0].id)\n        self.assertEqual(len(tenants_marker), 2)\n        self.assertEqual(tenants[1].name, tenants_marker[0].name)\n        self.assertEqual(tenants[2].name, tenants_marker[1].name)\n\n    def test_tenant_list_marker_not_found(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        client = self.get_client()\n        self.assertRaises(client_exceptions.BadRequest,\n                          client.tenants.list, marker=uuid.uuid4().hex)\n\n    def test_tenant_list_limit(self):\n        client = self.get_client()\n\n        # Add two arbitrary tenants to user for testing purposes\n        for i in range(2):\n            tenant_id = uuid.uuid4().hex\n            tenant = {'name': 'tenant-%s' % tenant_id, 'id': tenant_id}\n            self.identity_api.create_tenant(tenant_id, tenant)\n            self.identity_api.add_user_to_tenant(tenant_id,\n                                                 self.user_foo['id'])\n\n        tenants = client.tenants.list()\n        self.assertEqual(len(tenants), 3)\n\n        tenants_limited = client.tenants.list(limit=2)\n        self.assertEqual(len(tenants_limited), 2)\n        self.assertEqual(tenants[0].name, tenants_limited[0].name)\n        self.assertEqual(tenants[1].name, tenants_limited[1].name)\n\n    def test_tenant_list_limit_bad_value(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        client = self.get_client()\n        self.assertRaises(client_exceptions.BadRequest,\n                          client.tenants.list, limit='a')\n        self.assertRaises(client_exceptions.BadRequest,\n                          client.tenants.list, limit=-1)\n\n    def test_roles_get_by_user(self):\n        client = self.get_client(admin=True)\n        roles = client.roles.roles_for_user(user=self.user_foo['id'],\n                                            tenant=self.tenant_bar['id'])\n        self.assertTrue(len(roles) > 0)\n\n\nclass KcEssex3TestCase(CompatTestCase, KeystoneClientTests):\n    def get_checkout(self):\n        return KEYSTONECLIENT_REPO, 'essex-3'\n\n    def test_tenant_add_and_remove_user(self):\n        client = self.get_client(admin=True)\n        client.roles.add_user_to_tenant(tenant_id=self.tenant_baz['id'],\n                                        user_id=self.user_foo['id'],\n                                        role_id=self.role_useless['id'])\n        role_refs = client.roles.get_user_role_refs(\n                user_id=self.user_foo['id'])\n        self.assert_(self.tenant_baz['id'] in [x.tenantId for x in role_refs])\n\n        # get the \"role_refs\" so we get the proper id, this is how the clients\n        # do it\n        roleref_refs = client.roles.get_user_role_refs(\n                user_id=self.user_foo['id'])\n        for roleref_ref in roleref_refs:\n            if (roleref_ref.roleId == self.role_useless['id']\n                and roleref_ref.tenantId == self.tenant_baz['id']):\n                # use python's scope fall through to leave roleref_ref set\n                break\n\n        client.roles.remove_user_from_tenant(tenant_id=self.tenant_baz['id'],\n                                             user_id=self.user_foo['id'],\n                                             role_id=roleref_ref.id)\n\n        role_refs = client.roles.get_user_role_refs(\n                user_id=self.user_foo['id'])\n        self.assert_(self.tenant_baz['id'] not in\n                     [x.tenantId for x in role_refs])\n\n    def test_roles_get_by_user(self):\n        client = self.get_client(admin=True)\n        roles = client.roles.get_user_role_refs(user_id='foo')\n        self.assertTrue(len(roles) > 0)\n\n    def test_role_list_404(self):\n        raise nose.exc.SkipTest('N/A')\n\n    def test_authenticate_and_delete_token(self):\n        raise nose.exc.SkipTest('N/A')\n\n    def test_user_create_update_delete(self):\n        from keystoneclient import exceptions as client_exceptions\n\n        test_username = 'new_user'\n        client = self.get_client(admin=True)\n        user = client.users.create(name=test_username,\n                                   password='password',\n                                   email='user1@test.com')\n        self.assertEquals(user.name, test_username)\n\n        user = client.users.get(user=user.id)\n        self.assertEquals(user.name, test_username)\n\n        user = client.users.update_email(user=user, email='user2@test.com')\n        self.assertEquals(user.email, 'user2@test.com')\n\n        # NOTE(termie): update_enabled doesn't return anything, probably a bug\n        client.users.update_enabled(user=user, enabled=False)\n        user = client.users.get(user.id)\n        self.assertFalse(user.enabled)\n\n        self.assertRaises(client_exceptions.Unauthorized,\n                  self._client,\n                  username=test_username,\n                  password='password')\n        client.users.update_enabled(user, True)\n\n        user = client.users.update_password(user=user, password='password2')\n\n        self._client(username=test_username,\n                     password='password2')\n\n        user = client.users.update_tenant(user=user, tenant='bar')\n        # TODO(ja): once keystonelight supports default tenant\n        #           when you login without specifying tenant, the\n        #           token should be scoped to tenant 'bar'\n\n        client.users.delete(user.id)\n        self.assertRaises(client_exceptions.NotFound, client.users.get,\n                          user.id)\n\n    def test_user_update_404(self):\n        raise nose.exc.SkipTest('N/A')\n\n    def test_endpoint_create_404(self):\n        raise nose.exc.SkipTest('N/A')\n\n    def test_endpoint_delete_404(self):\n        raise nose.exc.SkipTest('N/A')\n"], "filenames": ["keystone/service.py", "tests/test_keystoneclient.py"], "buggy_code_start_loc": [354, 16], "buggy_code_end_loc": [355, 335], "fixing_code_start_loc": [354, 17], "fixing_code_end_loc": [356, 348], "type": "CWE-264", "message": "OpenStack Keystone before 2012.1.1, as used in OpenStack Folsom before Folsom-1 and OpenStack Essex, does not properly implement token expiration, which allows remote authenticated users to bypass intended authorization restrictions by (1) creating new tokens through token chaining, (2) leveraging possession of a token for a disabled user account, or (3) leveraging possession of a token for an account with a changed password.", "other": {"cve": {"id": "CVE-2012-3426", "sourceIdentifier": "secalert@redhat.com", "published": "2012-07-31T10:45:42.670", "lastModified": "2012-09-07T04:30:35.663", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "OpenStack Keystone before 2012.1.1, as used in OpenStack Folsom before Folsom-1 and OpenStack Essex, does not properly implement token expiration, which allows remote authenticated users to bypass intended authorization restrictions by (1) creating new tokens through token chaining, (2) leveraging possession of a token for a disabled user account, or (3) leveraging possession of a token for an account with a changed password."}, {"lang": "es", "value": "OpenStack Keystone antes de v2012.1.1, como se usa en OpenStack Folsom antes de Folsom-1 y OpenStack Essex, no implementan apropiadamente la expiraci\u00f3n de los token, lo que permite a usuarios autenticados remotamente evitar restricciones de acceso (1) creando nuevos token a trav\u00e9s de la cadena de token, (2) aprovechando la posesi\u00f3n de un token de una cuenta de usuario deshabilitada o (3) aprovechando la posesi\u00f3n de un token de una cuenta con una contrase\u00f1a cambiada"}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openstack:essex:*:*:*:*:*:*:*:*", "matchCriteriaId": "F50B9DA6-B071-4B48-A486-54CB3E64AE58"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openstack:horizon:folsom-1:*:*:*:*:*:*:*", "matchCriteriaId": "1E72EACB-1FA6-4F1D-A3C8-D255C705AAAD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openstack:keystone:2012.1:*:*:*:*:*:*:*", "matchCriteriaId": "8DACEFF0-BA6A-4184-A1AB-397438034AF0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openstack:keystone:2012.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "C5BD2FC1-7C36-4532-813A-DED5F0BD1FFF"}]}]}], "references": [{"url": "http://github.com/openstack/keystone/commit/29e74e73a6e51cffc0371b32354558391826a4aa", "source": "secalert@redhat.com"}, {"url": "http://github.com/openstack/keystone/commit/375838cfceb88cacc312ff6564e64eb18ee6a355", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://github.com/openstack/keystone/commit/628149b3dc6b58b91fd08e6ca8d91c728ccb8626", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "http://github.com/openstack/keystone/commit/a67b24878a6156eab17b9098fa649f0279256f5d", "source": "secalert@redhat.com"}, {"url": "http://github.com/openstack/keystone/commit/d9600434da14976463a0bd03abd8e0309f0db454", "source": "secalert@redhat.com"}, {"url": "http://github.com/openstack/keystone/commit/ea03d05ed5de0c015042876100d37a6a14bf56de", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2012/07/27/4", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.ubuntu.com/usn/USN-1552-1", "source": "secalert@redhat.com"}, {"url": "https://bugs.launchpad.net/keystone/+bug/996595", "source": "secalert@redhat.com"}, {"url": "https://bugs.launchpad.net/keystone/+bug/997194", "source": "secalert@redhat.com"}, {"url": "https://bugs.launchpad.net/keystone/+bug/998185", "source": "secalert@redhat.com"}, {"url": "https://launchpad.net/keystone/essex/2012.1.1/+download/keystone-2012.1.1.tar.gz", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "http://github.com/openstack/keystone/commit/375838cfceb88cacc312ff6564e64eb18ee6a355"}}