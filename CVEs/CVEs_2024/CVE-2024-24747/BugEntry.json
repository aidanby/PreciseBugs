{"buggy_code": ["// Copyright (c) 2015-2023 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"sort\"\n\t\"time\"\n\n\t\"github.com/klauspost/compress/zip\"\n\t\"github.com/minio/madmin-go/v3\"\n\t\"github.com/minio/minio/internal/auth\"\n\t\"github.com/minio/minio/internal/config/dns\"\n\t\"github.com/minio/minio/internal/logger\"\n\t\"github.com/minio/mux\"\n\t\"github.com/minio/pkg/v2/policy\"\n)\n\n// RemoveUser - DELETE /minio/admin/v3/remove-user?accessKey=<access_key>\nfunc (a adminAPIHandlers) RemoveUser(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, cred := validateAdminReq(ctx, w, r, policy.DeleteUserAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\taccessKey := vars[\"accessKey\"]\n\n\tok, _, err := globalIAMSys.IsTempUser(accessKey)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\tif ok {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errIAMActionNotAllowed), r.URL)\n\t\treturn\n\t}\n\n\t// When the user is root credential you are not allowed to\n\t// remove the root user. Also you cannot delete yourself.\n\tif accessKey == globalActiveCred.AccessKey || accessKey == cred.AccessKey {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errIAMActionNotAllowed), r.URL)\n\t\treturn\n\t}\n\n\tif err := globalIAMSys.DeleteUser(ctx, accessKey, true); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemIAMUser,\n\t\tIAMUser: &madmin.SRIAMUser{\n\t\t\tAccessKey:   accessKey,\n\t\t\tIsDeleteReq: true,\n\t\t},\n\t\tUpdatedAt: UTCNow(),\n\t}))\n}\n\n// ListBucketUsers - GET /minio/admin/v3/list-users?bucket={bucket}\nfunc (a adminAPIHandlers) ListBucketUsers(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, cred := validateAdminReq(ctx, w, r, policy.ListUsersAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tbucket := mux.Vars(r)[\"bucket\"]\n\n\tpassword := cred.SecretKey\n\n\tallCredentials, err := globalIAMSys.ListBucketUsers(ctx, bucket)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tdata, err := json.Marshal(allCredentials)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\teconfigData, err := madmin.EncryptData(password, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, econfigData)\n}\n\n// ListUsers - GET /minio/admin/v3/list-users\nfunc (a adminAPIHandlers) ListUsers(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, cred := validateAdminReq(ctx, w, r, policy.ListUsersAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tpassword := cred.SecretKey\n\n\tallCredentials, err := globalIAMSys.ListUsers(ctx)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Add ldap users which have mapped policies if in LDAP mode\n\t// FIXME(vadmeste): move this to policy info in the future\n\tldapUsers, err := globalIAMSys.ListLDAPUsers(ctx)\n\tif err != nil && err != errIAMActionNotAllowed {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\tfor k, v := range ldapUsers {\n\t\tallCredentials[k] = v\n\t}\n\n\t// Marshal the response\n\tdata, err := json.Marshal(allCredentials)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\teconfigData, err := madmin.EncryptData(password, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, econfigData)\n}\n\n// GetUserInfo - GET /minio/admin/v3/user-info\nfunc (a adminAPIHandlers) GetUserInfo(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tvars := mux.Vars(r)\n\tname := vars[\"accessKey\"]\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\tcheckDenyOnly := false\n\tif name == cred.AccessKey {\n\t\t// Check that there is no explicit deny - otherwise it's allowed\n\t\t// to view one's own info.\n\t\tcheckDenyOnly = true\n\t}\n\n\tif !globalIAMSys.IsAllowed(policy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          policy.GetUserAdminAction,\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t\tDenyOnly:        checkDenyOnly,\n\t}) {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\treturn\n\t}\n\n\tuserInfo, err := globalIAMSys.GetUserInfo(ctx, name)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tdata, err := json.Marshal(userInfo)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, data)\n}\n\n// UpdateGroupMembers - PUT /minio/admin/v3/update-group-members\nfunc (a adminAPIHandlers) UpdateGroupMembers(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, policy.AddUserToGroupAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tdata, err := io.ReadAll(r.Body)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n\t\treturn\n\t}\n\n\tvar updReq madmin.GroupAddRemove\n\terr = json.Unmarshal(data, &updReq)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n\t\treturn\n\t}\n\n\t// Reject if the group add and remove are temporary credentials, or root credential.\n\tfor _, member := range updReq.Members {\n\t\tok, _, err := globalIAMSys.IsTempUser(member)\n\t\tif err != nil && err != errNoSuchUser {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\tif ok {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errIAMActionNotAllowed), r.URL)\n\t\t\treturn\n\t\t}\n\t\t// When the user is root credential you are not allowed to\n\t\t// add policies for root user.\n\t\tif member == globalActiveCred.AccessKey {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errIAMActionNotAllowed), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\tvar updatedAt time.Time\n\tif updReq.IsRemove {\n\t\tupdatedAt, err = globalIAMSys.RemoveUsersFromGroup(ctx, updReq.Group, updReq.Members)\n\t} else {\n\t\t// Check if group already exists\n\t\tif _, gerr := globalIAMSys.GetGroupDescription(updReq.Group); gerr != nil {\n\t\t\t// If group does not exist, then check if the group has beginning and end space characters\n\t\t\t// we will reject such group names.\n\t\t\tif errors.Is(gerr, errNoSuchGroup) && hasSpaceBE(updReq.Group) {\n\t\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminResourceInvalidArgument), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tupdatedAt, err = globalIAMSys.AddUsersToGroup(ctx, updReq.Group, updReq.Members)\n\t}\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemGroupInfo,\n\t\tGroupInfo: &madmin.SRGroupInfo{\n\t\t\tUpdateReq: updReq,\n\t\t},\n\t\tUpdatedAt: updatedAt,\n\t}))\n}\n\n// GetGroup - /minio/admin/v3/group?group=mygroup1\nfunc (a adminAPIHandlers) GetGroup(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, policy.GetGroupAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\tgroup := vars[\"group\"]\n\n\tgdesc, err := globalIAMSys.GetGroupDescription(group)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tbody, err := json.Marshal(gdesc)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, body)\n}\n\n// ListGroups - GET /minio/admin/v3/groups\nfunc (a adminAPIHandlers) ListGroups(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, policy.ListGroupsAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tgroups, err := globalIAMSys.ListGroups(ctx)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tbody, err := json.Marshal(groups)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, body)\n}\n\n// SetGroupStatus - PUT /minio/admin/v3/set-group-status?group=mygroup1&status=enabled\nfunc (a adminAPIHandlers) SetGroupStatus(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, policy.EnableGroupAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\tgroup := vars[\"group\"]\n\tstatus := vars[\"status\"]\n\n\tvar (\n\t\terr       error\n\t\tupdatedAt time.Time\n\t)\n\tswitch status {\n\tcase statusEnabled:\n\t\tupdatedAt, err = globalIAMSys.SetGroupStatus(ctx, group, true)\n\tcase statusDisabled:\n\t\tupdatedAt, err = globalIAMSys.SetGroupStatus(ctx, group, false)\n\tdefault:\n\t\terr = errInvalidArgument\n\t}\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemGroupInfo,\n\t\tGroupInfo: &madmin.SRGroupInfo{\n\t\t\tUpdateReq: madmin.GroupAddRemove{\n\t\t\t\tGroup:    group,\n\t\t\t\tStatus:   madmin.GroupStatus(status),\n\t\t\t\tIsRemove: false,\n\t\t\t},\n\t\t},\n\t\tUpdatedAt: updatedAt,\n\t}))\n}\n\n// SetUserStatus - PUT /minio/admin/v3/set-user-status?accessKey=<access_key>&status=[enabled|disabled]\nfunc (a adminAPIHandlers) SetUserStatus(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, creds := validateAdminReq(ctx, w, r, policy.EnableUserAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\taccessKey := vars[\"accessKey\"]\n\tstatus := vars[\"status\"]\n\n\t// you cannot enable or disable yourself.\n\tif accessKey == creds.AccessKey {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errInvalidArgument), r.URL)\n\t\treturn\n\t}\n\n\tupdatedAt, err := globalIAMSys.SetUserStatus(ctx, accessKey, madmin.AccountStatus(status))\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemIAMUser,\n\t\tIAMUser: &madmin.SRIAMUser{\n\t\t\tAccessKey:   accessKey,\n\t\t\tIsDeleteReq: false,\n\t\t\tUserReq: &madmin.AddOrUpdateUserReq{\n\t\t\t\tStatus: madmin.AccountStatus(status),\n\t\t\t},\n\t\t},\n\t\tUpdatedAt: updatedAt,\n\t}))\n}\n\n// AddUser - PUT /minio/admin/v3/add-user?accessKey=<access_key>\nfunc (a adminAPIHandlers) AddUser(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tvars := mux.Vars(r)\n\taccessKey := vars[\"accessKey\"]\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\t// Not allowed to add a user with same access key as root credential\n\tif accessKey == globalActiveCred.AccessKey {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAddUserInvalidArgument), r.URL)\n\t\treturn\n\t}\n\n\tuser, exists := globalIAMSys.GetUser(ctx, accessKey)\n\tif exists && (user.Credentials.IsTemp() || user.Credentials.IsServiceAccount()) {\n\t\t// Updating STS credential is not allowed, and this API does not\n\t\t// support updating service accounts.\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAddUserInvalidArgument), r.URL)\n\t\treturn\n\t}\n\n\tif (cred.IsTemp() || cred.IsServiceAccount()) && cred.ParentUser == accessKey {\n\t\t// Incoming access key matches parent user then we should\n\t\t// reject password change requests.\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAddUserInvalidArgument), r.URL)\n\t\treturn\n\t}\n\n\t// Check if accessKey has beginning and end space characters, this only applies to new users.\n\tif !exists && hasSpaceBE(accessKey) {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminResourceInvalidArgument), r.URL)\n\t\treturn\n\t}\n\n\tcheckDenyOnly := false\n\tif accessKey == cred.AccessKey {\n\t\t// Check that there is no explicit deny - otherwise it's allowed\n\t\t// to change one's own password.\n\t\tcheckDenyOnly = true\n\t}\n\n\tif !globalIAMSys.IsAllowed(policy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          policy.CreateUserAdminAction,\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t\tDenyOnly:        checkDenyOnly,\n\t}) {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\treturn\n\t}\n\n\tif r.ContentLength > maxEConfigJSONSize || r.ContentLength == -1 {\n\t\t// More than maxConfigSize bytes were available\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminConfigTooLarge), r.URL)\n\t\treturn\n\t}\n\n\tpassword := cred.SecretKey\n\tconfigBytes, err := madmin.DecryptData(password, io.LimitReader(r.Body, r.ContentLength))\n\tif err != nil {\n\t\tlogger.LogIf(ctx, err)\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminConfigBadJSON), r.URL)\n\t\treturn\n\t}\n\n\tvar ureq madmin.AddOrUpdateUserReq\n\tif err = json.Unmarshal(configBytes, &ureq); err != nil {\n\t\tlogger.LogIf(ctx, err)\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminConfigBadJSON), r.URL)\n\t\treturn\n\t}\n\n\tupdatedAt, err := globalIAMSys.CreateUser(ctx, accessKey, ureq)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemIAMUser,\n\t\tIAMUser: &madmin.SRIAMUser{\n\t\t\tAccessKey:   accessKey,\n\t\t\tIsDeleteReq: false,\n\t\t\tUserReq:     &ureq,\n\t\t},\n\t\tUpdatedAt: updatedAt,\n\t}))\n}\n\n// TemporaryAccountInfo - GET /minio/admin/v3/temporary-account-info\nfunc (a adminAPIHandlers) TemporaryAccountInfo(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\taccessKey := mux.Vars(r)[\"accessKey\"]\n\tif accessKey == \"\" {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n\t\treturn\n\t}\n\n\targs := policy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          policy.ListTemporaryAccountsAdminAction,\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t}\n\n\tif !globalIAMSys.IsAllowed(args) {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\treturn\n\t}\n\n\tstsAccount, sessionPolicy, err := globalIAMSys.GetTemporaryAccount(ctx, accessKey)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tvar stsAccountPolicy policy.Policy\n\n\tif sessionPolicy != nil {\n\t\tstsAccountPolicy = *sessionPolicy\n\t} else {\n\t\tpoliciesNames, err := globalIAMSys.PolicyDBGet(stsAccount.ParentUser, stsAccount.Groups...)\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\tif len(policiesNames) == 0 {\n\t\t\tpolicySet, _ := args.GetPolicies(iamPolicyClaimNameOpenID())\n\t\t\tpoliciesNames = policySet.ToSlice()\n\t\t}\n\n\t\tstsAccountPolicy = globalIAMSys.GetCombinedPolicy(policiesNames...)\n\t}\n\n\tpolicyJSON, err := json.MarshalIndent(stsAccountPolicy, \"\", \" \")\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tinfoResp := madmin.TemporaryAccountInfoResp{\n\t\tParentUser:    stsAccount.ParentUser,\n\t\tAccountStatus: stsAccount.Status,\n\t\tImpliedPolicy: sessionPolicy == nil,\n\t\tPolicy:        string(policyJSON),\n\t\tExpiration:    &stsAccount.Expiration,\n\t}\n\n\tdata, err := json.Marshal(infoResp)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tencryptedData, err := madmin.EncryptData(cred.SecretKey, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, encryptedData)\n}\n\n// AddServiceAccount - PUT /minio/admin/v3/add-service-account\nfunc (a adminAPIHandlers) AddServiceAccount(w http.ResponseWriter, r *http.Request) {\n\tctx, cred, opts, createReq, targetUser, APIError := commonAddServiceAccount(r)\n\tif APIError.Code != \"\" {\n\t\twriteErrorResponseJSON(ctx, w, APIError, r.URL)\n\t\treturn\n\t}\n\n\tvar (\n\t\ttargetGroups []string\n\t\terr          error\n\t)\n\n\t// Find the user for the request sender (as it may be sent via a service\n\t// account or STS account):\n\trequestorUser := cred.AccessKey\n\trequestorParentUser := cred.AccessKey\n\trequestorGroups := cred.Groups\n\trequestorIsDerivedCredential := false\n\tif cred.IsServiceAccount() || cred.IsTemp() {\n\t\trequestorParentUser = cred.ParentUser\n\t\trequestorIsDerivedCredential = true\n\t}\n\n\tif globalIAMSys.GetUsersSysType() == MinIOUsersSysType && targetUser != cred.AccessKey {\n\t\t// For internal IDP, ensure that the targetUser's parent account exists.\n\t\t// It could be a regular user account or the root account.\n\t\t_, isRegularUser := globalIAMSys.GetUser(ctx, targetUser)\n\t\tif !isRegularUser && targetUser != globalActiveCred.AccessKey {\n\t\t\tapiErr := toAdminAPIErr(ctx, errNoSuchUser)\n\t\t\tapiErr.Description = fmt.Sprintf(\"Specified target user %s does not exist\", targetUser)\n\t\t\twriteErrorResponseJSON(ctx, w, apiErr, r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Check if we are creating svc account for request sender.\n\tisSvcAccForRequestor := false\n\tif targetUser == requestorUser || targetUser == requestorParentUser {\n\t\tisSvcAccForRequestor = true\n\t}\n\n\t// If we are creating svc account for request sender, ensure\n\t// that targetUser is a real user (i.e. not derived\n\t// credentials).\n\tif isSvcAccForRequestor {\n\t\tif requestorIsDerivedCredential {\n\t\t\tif requestorParentUser == \"\" {\n\t\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx,\n\t\t\t\t\terrors.New(\"service accounts cannot be generated for temporary credentials without parent\")), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\ttargetUser = requestorParentUser\n\t\t}\n\t\ttargetGroups = requestorGroups\n\n\t\t// In case of LDAP/OIDC we need to set `opts.claims` to ensure\n\t\t// it is associated with the LDAP/OIDC user properly.\n\t\tfor k, v := range cred.Claims {\n\t\t\tif k == expClaim {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\topts.claims[k] = v\n\t\t}\n\t} else if globalIAMSys.LDAPConfig.Enabled() {\n\t\t// In case of LDAP we need to resolve the targetUser to a DN and\n\t\t// query their groups:\n\t\topts.claims[ldapUserN] = targetUser // simple username\n\t\ttargetUser, targetGroups, err = globalIAMSys.LDAPConfig.LookupUserDN(targetUser)\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\topts.claims[ldapUser] = targetUser // username DN\n\n\t\t// NOTE: if not using LDAP, then internal IDP or open ID is\n\t\t// being used - in the former, group info is enforced when\n\t\t// generated credentials are used to make requests, and in the\n\t\t// latter, a group notion is not supported.\n\t}\n\n\tnewCred, updatedAt, err := globalIAMSys.NewServiceAccount(ctx, targetUser, targetGroups, opts)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tcreateResp := madmin.AddServiceAccountResp{\n\t\tCredentials: madmin.Credentials{\n\t\t\tAccessKey:  newCred.AccessKey,\n\t\t\tSecretKey:  newCred.SecretKey,\n\t\t\tExpiration: newCred.Expiration,\n\t\t},\n\t}\n\n\tdata, err := json.Marshal(createResp)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tencryptedData, err := madmin.EncryptData(cred.SecretKey, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, encryptedData)\n\n\t// Call hook for cluster-replication if the service account is not for a\n\t// root user.\n\tif newCred.ParentUser != globalActiveCred.AccessKey {\n\t\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\t\tType: madmin.SRIAMItemSvcAcc,\n\t\t\tSvcAccChange: &madmin.SRSvcAccChange{\n\t\t\t\tCreate: &madmin.SRSvcAccCreate{\n\t\t\t\t\tParent:        newCred.ParentUser,\n\t\t\t\t\tAccessKey:     newCred.AccessKey,\n\t\t\t\t\tSecretKey:     newCred.SecretKey,\n\t\t\t\t\tGroups:        newCred.Groups,\n\t\t\t\t\tName:          newCred.Name,\n\t\t\t\t\tDescription:   newCred.Description,\n\t\t\t\t\tClaims:        opts.claims,\n\t\t\t\t\tSessionPolicy: createReq.Policy,\n\t\t\t\t\tStatus:        auth.AccountOn,\n\t\t\t\t\tExpiration:    createReq.Expiration,\n\t\t\t\t},\n\t\t\t},\n\t\t\tUpdatedAt: updatedAt,\n\t\t}))\n\t}\n}\n\n// UpdateServiceAccount - POST /minio/admin/v3/update-service-account\nfunc (a adminAPIHandlers) UpdateServiceAccount(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\taccessKey := mux.Vars(r)[\"accessKey\"]\n\tif accessKey == \"\" {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n\t\treturn\n\t}\n\n\tsvcAccount, _, err := globalIAMSys.GetServiceAccount(ctx, accessKey)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tif !globalIAMSys.IsAllowed(policy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          policy.UpdateServiceAccountAdminAction,\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t}) {\n\t\trequestUser := cred.AccessKey\n\t\tif cred.ParentUser != \"\" {\n\t\t\trequestUser = cred.ParentUser\n\t\t}\n\n\t\tif requestUser != svcAccount.ParentUser {\n\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\tpassword := cred.SecretKey\n\treqBytes, err := madmin.DecryptData(password, io.LimitReader(r.Body, r.ContentLength))\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErrWithErr(ErrAdminConfigBadJSON, err), r.URL)\n\t\treturn\n\t}\n\n\tvar updateReq madmin.UpdateServiceAccountReq\n\tif err = json.Unmarshal(reqBytes, &updateReq); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErrWithErr(ErrAdminConfigBadJSON, err), r.URL)\n\t\treturn\n\t}\n\n\tif err := updateReq.Validate(); err != nil {\n\t\t// Since this validation would happen client side as well, we only send\n\t\t// a generic error message here.\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminResourceInvalidArgument), r.URL)\n\t\treturn\n\t}\n\n\tvar sp *policy.Policy\n\tif len(updateReq.NewPolicy) > 0 {\n\t\tsp, err = policy.ParseConfig(bytes.NewReader(updateReq.NewPolicy))\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\tif sp.Version == \"\" && len(sp.Statements) == 0 {\n\t\t\tsp = nil\n\t\t}\n\t}\n\topts := updateServiceAccountOpts{\n\t\tsecretKey:     updateReq.NewSecretKey,\n\t\tstatus:        updateReq.NewStatus,\n\t\tname:          updateReq.NewName,\n\t\tdescription:   updateReq.NewDescription,\n\t\texpiration:    updateReq.NewExpiration,\n\t\tsessionPolicy: sp,\n\t}\n\tupdatedAt, err := globalIAMSys.UpdateServiceAccount(ctx, accessKey, opts)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Call site replication hook - non-root user accounts are replicated.\n\tif svcAccount.ParentUser != globalActiveCred.AccessKey {\n\t\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\t\tType: madmin.SRIAMItemSvcAcc,\n\t\t\tSvcAccChange: &madmin.SRSvcAccChange{\n\t\t\t\tUpdate: &madmin.SRSvcAccUpdate{\n\t\t\t\t\tAccessKey:     accessKey,\n\t\t\t\t\tSecretKey:     opts.secretKey,\n\t\t\t\t\tStatus:        opts.status,\n\t\t\t\t\tName:          opts.name,\n\t\t\t\t\tDescription:   opts.description,\n\t\t\t\t\tSessionPolicy: updateReq.NewPolicy,\n\t\t\t\t\tExpiration:    updateReq.NewExpiration,\n\t\t\t\t},\n\t\t\t},\n\t\t\tUpdatedAt: updatedAt,\n\t\t}))\n\t}\n\n\twriteSuccessNoContent(w)\n}\n\n// InfoServiceAccount - GET /minio/admin/v3/info-service-account\nfunc (a adminAPIHandlers) InfoServiceAccount(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\taccessKey := mux.Vars(r)[\"accessKey\"]\n\tif accessKey == \"\" {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n\t\treturn\n\t}\n\n\tsvcAccount, sessionPolicy, err := globalIAMSys.GetServiceAccount(ctx, accessKey)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tif !globalIAMSys.IsAllowed(policy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          policy.ListServiceAccountsAdminAction,\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t}) {\n\t\trequestUser := cred.AccessKey\n\t\tif cred.ParentUser != \"\" {\n\t\t\trequestUser = cred.ParentUser\n\t\t}\n\n\t\tif requestUser != svcAccount.ParentUser {\n\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// if session policy is nil or empty, then it is implied policy\n\timpliedPolicy := sessionPolicy == nil || (sessionPolicy.Version == \"\" && len(sessionPolicy.Statements) == 0)\n\n\tvar svcAccountPolicy policy.Policy\n\n\tif !impliedPolicy {\n\t\tsvcAccountPolicy = *sessionPolicy\n\t} else {\n\t\tpoliciesNames, err := globalIAMSys.PolicyDBGet(svcAccount.ParentUser, svcAccount.Groups...)\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\tsvcAccountPolicy = globalIAMSys.GetCombinedPolicy(policiesNames...)\n\t}\n\n\tpolicyJSON, err := json.MarshalIndent(svcAccountPolicy, \"\", \" \")\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tvar expiration *time.Time\n\tif !svcAccount.Expiration.IsZero() && !svcAccount.Expiration.Equal(timeSentinel) {\n\t\texpiration = &svcAccount.Expiration\n\t}\n\n\tinfoResp := madmin.InfoServiceAccountResp{\n\t\tParentUser:    svcAccount.ParentUser,\n\t\tName:          svcAccount.Name,\n\t\tDescription:   svcAccount.Description,\n\t\tAccountStatus: svcAccount.Status,\n\t\tImpliedPolicy: impliedPolicy,\n\t\tPolicy:        string(policyJSON),\n\t\tExpiration:    expiration,\n\t}\n\n\tdata, err := json.Marshal(infoResp)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tencryptedData, err := madmin.EncryptData(cred.SecretKey, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, encryptedData)\n}\n\n// ListServiceAccounts - GET /minio/admin/v3/list-service-accounts\nfunc (a adminAPIHandlers) ListServiceAccounts(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\tvar targetAccount string\n\n\t// If listing is requested for a specific user (who is not the request\n\t// sender), check that the user has permissions.\n\tuser := r.Form.Get(\"user\")\n\tif user != \"\" && user != cred.AccessKey {\n\t\tif !globalIAMSys.IsAllowed(policy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          policy.ListServiceAccountsAdminAction,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\t\tIsOwner:         owner,\n\t\t\tClaims:          cred.Claims,\n\t\t}) {\n\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\t\treturn\n\t\t}\n\t\ttargetAccount = user\n\t} else {\n\t\ttargetAccount = cred.AccessKey\n\t\tif cred.ParentUser != \"\" {\n\t\t\ttargetAccount = cred.ParentUser\n\t\t}\n\t}\n\n\tserviceAccounts, err := globalIAMSys.ListServiceAccounts(ctx, targetAccount)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tvar serviceAccountList []madmin.ServiceAccountInfo\n\n\tfor _, svc := range serviceAccounts {\n\t\texpiryTime := svc.Expiration\n\t\tserviceAccountList = append(serviceAccountList, madmin.ServiceAccountInfo{\n\t\t\tAccessKey:  svc.AccessKey,\n\t\t\tExpiration: &expiryTime,\n\t\t})\n\t}\n\n\tlistResp := madmin.ListServiceAccountsResp{\n\t\tAccounts: serviceAccountList,\n\t}\n\n\tdata, err := json.Marshal(listResp)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tencryptedData, err := madmin.EncryptData(cred.SecretKey, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, encryptedData)\n}\n\n// DeleteServiceAccount - DELETE /minio/admin/v3/delete-service-account\nfunc (a adminAPIHandlers) DeleteServiceAccount(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\tserviceAccount := mux.Vars(r)[\"accessKey\"]\n\tif serviceAccount == \"\" {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminInvalidArgument), r.URL)\n\t\treturn\n\t}\n\n\t// We do not care if service account is readable or not at this point,\n\t// since this is a delete call we shall allow it to be deleted if possible.\n\tsvcAccount, _, err := globalIAMSys.GetServiceAccount(ctx, serviceAccount)\n\tif errors.Is(err, errNoSuchServiceAccount) {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminServiceAccountNotFound), r.URL)\n\t\treturn\n\t}\n\n\tadminPrivilege := globalIAMSys.IsAllowed(policy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          policy.RemoveServiceAccountAdminAction,\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t})\n\n\tif !adminPrivilege {\n\t\tparentUser := cred.AccessKey\n\t\tif cred.ParentUser != \"\" {\n\t\t\tparentUser = cred.ParentUser\n\t\t}\n\t\tif svcAccount.ParentUser != \"\" && parentUser != svcAccount.ParentUser {\n\t\t\t// The service account belongs to another user but return not\n\t\t\t// found error to mitigate brute force attacks. or the\n\t\t\t// serviceAccount doesn't exist.\n\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminServiceAccountNotFound), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\tif err := globalIAMSys.DeleteServiceAccount(ctx, serviceAccount, true); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Call site replication hook - non-root user accounts are replicated.\n\tif svcAccount.ParentUser != \"\" && svcAccount.ParentUser != globalActiveCred.AccessKey {\n\t\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\t\tType: madmin.SRIAMItemSvcAcc,\n\t\t\tSvcAccChange: &madmin.SRSvcAccChange{\n\t\t\t\tDelete: &madmin.SRSvcAccDelete{\n\t\t\t\t\tAccessKey: serviceAccount,\n\t\t\t\t},\n\t\t\t},\n\t\t\tUpdatedAt: UTCNow(),\n\t\t}))\n\t}\n\n\twriteSuccessNoContent(w)\n}\n\n// AccountInfoHandler returns usage, permissions and other bucket metadata for incoming us\nfunc (a adminAPIHandlers) AccountInfoHandler(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\t// Set prefix value for \"s3:prefix\" policy conditionals.\n\tr.Header.Set(\"prefix\", \"\")\n\n\t// Set delimiter value for \"s3:delimiter\" policy conditionals.\n\tr.Header.Set(\"delimiter\", SlashSeparator)\n\n\t// Check if we are asked to return prefix usage\n\tenablePrefixUsage := r.Form.Get(\"prefix-usage\") == \"true\"\n\n\tisAllowedAccess := func(bucketName string) (rd, wr bool) {\n\t\tif globalIAMSys.IsAllowed(policy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          policy.ListBucketAction,\n\t\t\tBucketName:      bucketName,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      \"\",\n\t\t\tClaims:          cred.Claims,\n\t\t}) {\n\t\t\trd = true\n\t\t}\n\n\t\tif globalIAMSys.IsAllowed(policy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          policy.GetBucketLocationAction,\n\t\t\tBucketName:      bucketName,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      \"\",\n\t\t\tClaims:          cred.Claims,\n\t\t}) {\n\t\t\trd = true\n\t\t}\n\n\t\tif globalIAMSys.IsAllowed(policy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          policy.PutObjectAction,\n\t\t\tBucketName:      bucketName,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      \"\",\n\t\t\tClaims:          cred.Claims,\n\t\t}) {\n\t\t\twr = true\n\t\t}\n\n\t\treturn rd, wr\n\t}\n\n\tbucketStorageCache.Once.Do(func() {\n\t\t// Set this to 10 secs since its enough, as scanner\n\t\t// does not update the bucket usage values frequently.\n\t\tbucketStorageCache.TTL = 10 * time.Second\n\n\t\t// Rely on older value if usage loading fails from disk.\n\t\tbucketStorageCache.Relax = true\n\t\tbucketStorageCache.Update = func() (interface{}, error) {\n\t\t\tctx, done := context.WithTimeout(context.Background(), 2*time.Second)\n\t\t\tdefer done()\n\n\t\t\treturn loadDataUsageFromBackend(ctx, objectAPI)\n\t\t}\n\t})\n\n\tvar dataUsageInfo DataUsageInfo\n\tv, _ := bucketStorageCache.Get()\n\tif v != nil {\n\t\tdataUsageInfo, _ = v.(DataUsageInfo)\n\t}\n\n\t// If etcd, dns federation configured list buckets from etcd.\n\tvar err error\n\tvar buckets []BucketInfo\n\tif globalDNSConfig != nil && globalBucketFederation {\n\t\tdnsBuckets, err := globalDNSConfig.List()\n\t\tif err != nil && !IsErrIgnored(err,\n\t\t\tdns.ErrNoEntriesFound,\n\t\t\tdns.ErrDomainMissing) {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\tfor _, dnsRecords := range dnsBuckets {\n\t\t\tbuckets = append(buckets, BucketInfo{\n\t\t\t\tName:    dnsRecords[0].Key,\n\t\t\t\tCreated: dnsRecords[0].CreationDate,\n\t\t\t})\n\t\t}\n\t\tsort.Slice(buckets, func(i, j int) bool {\n\t\t\treturn buckets[i].Name < buckets[j].Name\n\t\t})\n\t} else {\n\t\tbuckets, err = objectAPI.ListBuckets(ctx, BucketOptions{Cached: true})\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\taccountName := cred.AccessKey\n\tif cred.IsTemp() || cred.IsServiceAccount() {\n\t\t// For derived credentials, check the parent user's permissions.\n\t\taccountName = cred.ParentUser\n\t}\n\n\troleArn := policy.Args{Claims: cred.Claims}.GetRoleArn()\n\tpolicySetFromClaims, hasPolicyClaim := policy.GetPoliciesFromClaims(cred.Claims, iamPolicyClaimNameOpenID())\n\tvar effectivePolicy policy.Policy\n\n\tvar buf []byte\n\tswitch {\n\tcase accountName == globalActiveCred.AccessKey:\n\t\tfor _, policy := range policy.DefaultPolicies {\n\t\t\tif policy.Name == \"consoleAdmin\" {\n\t\t\t\teffectivePolicy = policy.Definition\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\tcase roleArn != \"\":\n\t\t_, policy, err := globalIAMSys.GetRolePolicy(roleArn)\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\tpolicySlice := newMappedPolicy(policy).toSlice()\n\t\teffectivePolicy = globalIAMSys.GetCombinedPolicy(policySlice...)\n\n\tcase hasPolicyClaim:\n\t\teffectivePolicy = globalIAMSys.GetCombinedPolicy(policySetFromClaims.ToSlice()...)\n\n\tdefault:\n\t\tpolicies, err := globalIAMSys.PolicyDBGet(accountName, cred.Groups...)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, err)\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\teffectivePolicy = globalIAMSys.GetCombinedPolicy(policies...)\n\n\t}\n\tbuf, err = json.MarshalIndent(effectivePolicy, \"\", \" \")\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tacctInfo := madmin.AccountInfo{\n\t\tAccountName: accountName,\n\t\tServer:      objectAPI.BackendInfo(),\n\t\tPolicy:      buf,\n\t}\n\n\tfor _, bucket := range buckets {\n\t\trd, wr := isAllowedAccess(bucket.Name)\n\t\tif rd || wr {\n\t\t\t// Fetch the data usage of the current bucket\n\t\t\tvar size uint64\n\t\t\tvar objectsCount uint64\n\t\t\tvar objectsHist, versionsHist map[string]uint64\n\t\t\tif !dataUsageInfo.LastUpdate.IsZero() {\n\t\t\t\tsize = dataUsageInfo.BucketsUsage[bucket.Name].Size\n\t\t\t\tobjectsCount = dataUsageInfo.BucketsUsage[bucket.Name].ObjectsCount\n\t\t\t\tobjectsHist = dataUsageInfo.BucketsUsage[bucket.Name].ObjectSizesHistogram\n\t\t\t\tversionsHist = dataUsageInfo.BucketsUsage[bucket.Name].ObjectVersionsHistogram\n\t\t\t}\n\t\t\t// Fetch the prefix usage of the current bucket\n\t\t\tvar prefixUsage map[string]uint64\n\t\t\tif enablePrefixUsage {\n\t\t\t\tprefixUsage, _ = loadPrefixUsageFromBackend(ctx, objectAPI, bucket.Name)\n\t\t\t}\n\n\t\t\tlcfg, _ := globalBucketObjectLockSys.Get(bucket.Name)\n\t\t\tquota, _ := globalBucketQuotaSys.Get(ctx, bucket.Name)\n\t\t\trcfg, _, _ := globalBucketMetadataSys.GetReplicationConfig(ctx, bucket.Name)\n\t\t\ttcfg, _, _ := globalBucketMetadataSys.GetTaggingConfig(bucket.Name)\n\n\t\t\tacctInfo.Buckets = append(acctInfo.Buckets, madmin.BucketAccessInfo{\n\t\t\t\tName:                    bucket.Name,\n\t\t\t\tCreated:                 bucket.Created,\n\t\t\t\tSize:                    size,\n\t\t\t\tObjects:                 objectsCount,\n\t\t\t\tObjectSizesHistogram:    objectsHist,\n\t\t\t\tObjectVersionsHistogram: versionsHist,\n\t\t\t\tPrefixUsage:             prefixUsage,\n\t\t\t\tDetails: &madmin.BucketDetails{\n\t\t\t\t\tVersioning:          globalBucketVersioningSys.Enabled(bucket.Name),\n\t\t\t\t\tVersioningSuspended: globalBucketVersioningSys.Suspended(bucket.Name),\n\t\t\t\t\tReplication:         rcfg != nil,\n\t\t\t\t\tLocking:             lcfg.LockEnabled,\n\t\t\t\t\tQuota:               quota,\n\t\t\t\t\tTagging:             tcfg,\n\t\t\t\t},\n\t\t\t\tAccess: madmin.AccountAccess{\n\t\t\t\t\tRead:  rd,\n\t\t\t\t\tWrite: wr,\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t}\n\n\tusageInfoJSON, err := json.Marshal(acctInfo)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, usageInfoJSON)\n}\n\n// InfoCannedPolicy - GET /minio/admin/v3/info-canned-policy?name={policyName}\n//\n// Newer API response with policy timestamps is returned with query parameter\n// `v=2` like:\n//\n// GET /minio/admin/v3/info-canned-policy?name={policyName}&v=2\n//\n// The newer API will eventually become the default (and only) one. The older\n// response is to return only the policy JSON. The newer response returns\n// timestamps along with the policy JSON. Both versions are supported for now,\n// for smooth transition to new API.\nfunc (a adminAPIHandlers) InfoCannedPolicy(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, policy.GetPolicyAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tname := mux.Vars(r)[\"name\"]\n\tpolicies := newMappedPolicy(name).toSlice()\n\tif len(policies) != 1 {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errTooManyPolicies), r.URL)\n\t\treturn\n\t}\n\n\tpolicyDoc, err := globalIAMSys.InfoPolicy(name)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Is the new API version being requested?\n\tinfoPolicyAPIVersion := r.Form.Get(\"v\")\n\tif infoPolicyAPIVersion == \"2\" {\n\t\tbuf, err := json.MarshalIndent(policyDoc, \"\", \" \")\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\tw.Write(buf)\n\t\treturn\n\t} else if infoPolicyAPIVersion != \"\" {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errors.New(\"invalid version parameter 'v' supplied\")), r.URL)\n\t\treturn\n\t}\n\n\t// Return the older API response value of just the policy json.\n\tbuf, err := json.MarshalIndent(policyDoc.Policy, \"\", \" \")\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\tw.Write(buf)\n}\n\n// ListBucketPolicies - GET /minio/admin/v3/list-canned-policies?bucket={bucket}\nfunc (a adminAPIHandlers) ListBucketPolicies(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, policy.ListUserPoliciesAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tbucket := mux.Vars(r)[\"bucket\"]\n\tpolicies, err := globalIAMSys.ListPolicies(ctx, bucket)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tnewPolicies := make(map[string]policy.Policy)\n\tfor name, p := range policies {\n\t\t_, err = json.Marshal(p)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, err)\n\t\t\tcontinue\n\t\t}\n\t\tnewPolicies[name] = p\n\t}\n\tif err = json.NewEncoder(w).Encode(newPolicies); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n}\n\n// ListCannedPolicies - GET /minio/admin/v3/list-canned-policies\nfunc (a adminAPIHandlers) ListCannedPolicies(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, policy.ListUserPoliciesAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tpolicies, err := globalIAMSys.ListPolicies(ctx, \"\")\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tnewPolicies := make(map[string]policy.Policy)\n\tfor name, p := range policies {\n\t\t_, err = json.Marshal(p)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, err)\n\t\t\tcontinue\n\t\t}\n\t\tnewPolicies[name] = p\n\t}\n\tif err = json.NewEncoder(w).Encode(newPolicies); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n}\n\n// RemoveCannedPolicy - DELETE /minio/admin/v3/remove-canned-policy?name=<policy_name>\nfunc (a adminAPIHandlers) RemoveCannedPolicy(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, policy.DeletePolicyAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\tpolicyName := vars[\"name\"]\n\n\tif err := globalIAMSys.DeletePolicy(ctx, policyName, true); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Call cluster-replication policy creation hook to replicate policy deletion to\n\t// other minio clusters.\n\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType:      madmin.SRIAMItemPolicy,\n\t\tName:      policyName,\n\t\tUpdatedAt: UTCNow(),\n\t}))\n}\n\n// AddCannedPolicy - PUT /minio/admin/v3/add-canned-policy?name=<policy_name>\nfunc (a adminAPIHandlers) AddCannedPolicy(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, policy.CreatePolicyAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\tpolicyName := vars[\"name\"]\n\n\t// Policy has space characters in begin and end reject such inputs.\n\tif hasSpaceBE(policyName) {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminResourceInvalidArgument), r.URL)\n\t\treturn\n\t}\n\n\t// Error out if Content-Length is missing.\n\tif r.ContentLength <= 0 {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrMissingContentLength), r.URL)\n\t\treturn\n\t}\n\n\t// Error out if Content-Length is beyond allowed size.\n\tif r.ContentLength > maxBucketPolicySize {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrEntityTooLarge), r.URL)\n\t\treturn\n\t}\n\n\tiamPolicyBytes, err := io.ReadAll(io.LimitReader(r.Body, r.ContentLength))\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tiamPolicy, err := policy.ParseConfig(bytes.NewReader(iamPolicyBytes))\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Version in policy must not be empty\n\tif iamPolicy.Version == \"\" {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrPolicyInvalidVersion), r.URL)\n\t\treturn\n\t}\n\n\tupdatedAt, err := globalIAMSys.SetPolicy(ctx, policyName, *iamPolicy)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Call cluster-replication policy creation hook to replicate policy to\n\t// other minio clusters.\n\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType:      madmin.SRIAMItemPolicy,\n\t\tName:      policyName,\n\t\tPolicy:    iamPolicyBytes,\n\t\tUpdatedAt: updatedAt,\n\t}))\n}\n\n// SetPolicyForUserOrGroup - PUT /minio/admin/v3/set-policy?policy=xxx&user-or-group=?[&is-group]\nfunc (a adminAPIHandlers) SetPolicyForUserOrGroup(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, policy.AttachPolicyAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\tpolicyName := vars[\"policyName\"]\n\tentityName := vars[\"userOrGroup\"]\n\tisGroup := vars[\"isGroup\"] == \"true\"\n\n\tif !isGroup {\n\t\tok, _, err := globalIAMSys.IsTempUser(entityName)\n\t\tif err != nil && err != errNoSuchUser {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\tif ok {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errIAMActionNotAllowed), r.URL)\n\t\t\treturn\n\t\t}\n\t\t// When the user is root credential you are not allowed to\n\t\t// add policies for root user.\n\t\tif entityName == globalActiveCred.AccessKey {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errIAMActionNotAllowed), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Validate that user or group exists.\n\tif !isGroup {\n\t\tif globalIAMSys.GetUsersSysType() == MinIOUsersSysType {\n\t\t\t_, ok := globalIAMSys.GetUser(ctx, entityName)\n\t\t\tif !ok {\n\t\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errNoSuchUser), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t} else {\n\t\t_, err := globalIAMSys.GetGroupDescription(entityName)\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\tuserType := regUser\n\tif globalIAMSys.GetUsersSysType() == LDAPUsersSysType {\n\t\tuserType = stsUser\n\t}\n\n\tupdatedAt, err := globalIAMSys.PolicyDBSet(ctx, entityName, policyName, userType, isGroup)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemPolicyMapping,\n\t\tPolicyMapping: &madmin.SRPolicyMapping{\n\t\t\tUserOrGroup: entityName,\n\t\t\tUserType:    int(userType),\n\t\t\tIsGroup:     isGroup,\n\t\t\tPolicy:      policyName,\n\t\t},\n\t\tUpdatedAt: updatedAt,\n\t}))\n}\n\n// ListPolicyMappingEntities - GET /minio/admin/v3/idp/builtin/polciy-entities?policy=xxx&user=xxx&group=xxx\nfunc (a adminAPIHandlers) ListPolicyMappingEntities(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\t// Check authorization.\n\tobjectAPI, cred := validateAdminReq(ctx, w, r,\n\t\tpolicy.ListGroupsAdminAction, policy.ListUsersAdminAction, policy.ListUserPoliciesAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\t// Validate API arguments.\n\tq := madmin.PolicyEntitiesQuery{\n\t\tUsers:  r.Form[\"user\"],\n\t\tGroups: r.Form[\"group\"],\n\t\tPolicy: r.Form[\"policy\"],\n\t}\n\n\t// Query IAM\n\tres, err := globalIAMSys.QueryPolicyEntities(r.Context(), q)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Encode result and send response.\n\tdata, err := json.Marshal(res)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\tpassword := cred.SecretKey\n\teconfigData, err := madmin.EncryptData(password, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\twriteSuccessResponseJSON(w, econfigData)\n}\n\n// AttachDetachPolicyBuiltin - POST /minio/admin/v3/idp/builtin/policy/{operation}\nfunc (a adminAPIHandlers) AttachDetachPolicyBuiltin(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, cred := validateAdminReq(ctx, w, r, policy.UpdatePolicyAssociationAction,\n\t\tpolicy.AttachPolicyAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tif r.ContentLength > maxEConfigJSONSize || r.ContentLength == -1 {\n\t\t// More than maxConfigSize bytes were available\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminConfigTooLarge), r.URL)\n\t\treturn\n\t}\n\n\t// Ensure body content type is opaque to ensure that request body has not\n\t// been interpreted as form data.\n\tcontentType := r.Header.Get(\"Content-Type\")\n\tif contentType != \"application/octet-stream\" {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrBadRequest), r.URL)\n\t\treturn\n\t}\n\n\toperation := mux.Vars(r)[\"operation\"]\n\tif operation != \"attach\" && operation != \"detach\" {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminInvalidArgument), r.URL)\n\t\treturn\n\t}\n\tisAttach := operation == \"attach\"\n\n\tpassword := cred.SecretKey\n\treqBytes, err := madmin.DecryptData(password, io.LimitReader(r.Body, r.ContentLength))\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tvar par madmin.PolicyAssociationReq\n\tif err = json.Unmarshal(reqBytes, &par); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tif err = par.IsValid(); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tupdatedAt, addedOrRemoved, _, err := globalIAMSys.PolicyDBUpdateBuiltin(ctx, isAttach, par)\n\tif err != nil {\n\t\tif err == errNoSuchUser || err == errNoSuchGroup {\n\t\t\tif globalIAMSys.LDAPConfig.Enabled() {\n\t\t\t\t// When LDAP is enabled, warn user that they are using the wrong\n\t\t\t\t// API. FIXME: error can be no such group as well - fix errNoSuchUserLDAPWarn\n\t\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errNoSuchUserLDAPWarn), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\trespBody := madmin.PolicyAssociationResp{\n\t\tUpdatedAt: updatedAt,\n\t}\n\tif isAttach {\n\t\trespBody.PoliciesAttached = addedOrRemoved\n\t} else {\n\t\trespBody.PoliciesDetached = addedOrRemoved\n\t}\n\n\tdata, err := json.Marshal(respBody)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tencryptedData, err := madmin.EncryptData(password, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, encryptedData)\n}\n\nconst (\n\tallPoliciesFile            = \"policies.json\"\n\tallUsersFile               = \"users.json\"\n\tallGroupsFile              = \"groups.json\"\n\tallSvcAcctsFile            = \"svcaccts.json\"\n\tuserPolicyMappingsFile     = \"user_mappings.json\"\n\tgroupPolicyMappingsFile    = \"group_mappings.json\"\n\tstsUserPolicyMappingsFile  = \"stsuser_mappings.json\"\n\tstsGroupPolicyMappingsFile = \"stsgroup_mappings.json\"\n\tiamAssetsDir               = \"iam-assets\"\n)\n\n// ExportIAMHandler - exports all iam info as a zipped file\nfunc (a adminAPIHandlers) ExportIAM(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\t// Get current object layer instance.\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, policy.ExportIAMAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\t// Initialize a zip writer which will provide a zipped content\n\t// of bucket metadata\n\tzipWriter := zip.NewWriter(w)\n\tdefer zipWriter.Close()\n\trawDataFn := func(r io.Reader, filename string, sz int) error {\n\t\theader, zerr := zip.FileInfoHeader(dummyFileInfo{\n\t\t\tname:    filename,\n\t\t\tsize:    int64(sz),\n\t\t\tmode:    0o600,\n\t\t\tmodTime: time.Now(),\n\t\t\tisDir:   false,\n\t\t\tsys:     nil,\n\t\t})\n\t\tif zerr != nil {\n\t\t\tlogger.LogIf(ctx, zerr)\n\t\t\treturn nil\n\t\t}\n\t\theader.Method = zip.Deflate\n\t\tzwriter, zerr := zipWriter.CreateHeader(header)\n\t\tif zerr != nil {\n\t\t\tlogger.LogIf(ctx, zerr)\n\t\t\treturn nil\n\t\t}\n\t\tif _, err := io.Copy(zwriter, r); err != nil {\n\t\t\tlogger.LogIf(ctx, err)\n\t\t}\n\t\treturn nil\n\t}\n\n\tiamFiles := []string{\n\t\tallPoliciesFile,\n\t\tallUsersFile,\n\t\tallGroupsFile,\n\t\tallSvcAcctsFile,\n\t\tuserPolicyMappingsFile,\n\t\tgroupPolicyMappingsFile,\n\t\tstsUserPolicyMappingsFile,\n\t\tstsGroupPolicyMappingsFile,\n\t}\n\tfor _, f := range iamFiles {\n\t\tiamFile := pathJoin(iamAssetsDir, f)\n\t\tswitch f {\n\t\tcase allPoliciesFile:\n\t\t\tallPolicies, err := globalIAMSys.ListPolicies(ctx, \"\")\n\t\t\tif err != nil {\n\t\t\t\tlogger.LogIf(ctx, err)\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tpoliciesData, err := json.Marshal(allPolicies)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err = rawDataFn(bytes.NewReader(policiesData), iamFile, len(policiesData)); err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase allUsersFile:\n\t\t\tuserIdentities := make(map[string]UserIdentity)\n\t\t\terr := globalIAMSys.store.loadUsers(ctx, regUser, userIdentities)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tuserAccounts := make(map[string]madmin.AddOrUpdateUserReq)\n\t\t\tfor u, uid := range userIdentities {\n\t\t\t\tuserAccounts[u] = madmin.AddOrUpdateUserReq{\n\t\t\t\t\tSecretKey: uid.Credentials.SecretKey,\n\t\t\t\t\tStatus: func() madmin.AccountStatus {\n\t\t\t\t\t\t// Export current credential status\n\t\t\t\t\t\tif uid.Credentials.Status == auth.AccountOff {\n\t\t\t\t\t\t\treturn madmin.AccountDisabled\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn madmin.AccountEnabled\n\t\t\t\t\t}(),\n\t\t\t\t}\n\t\t\t}\n\t\t\tuserData, err := json.Marshal(userAccounts)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err = rawDataFn(bytes.NewReader(userData), iamFile, len(userData)); err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase allGroupsFile:\n\t\t\tgroups := make(map[string]GroupInfo)\n\t\t\terr := globalIAMSys.store.loadGroups(ctx, groups)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgroupData, err := json.Marshal(groups)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err = rawDataFn(bytes.NewReader(groupData), iamFile, len(groupData)); err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase allSvcAcctsFile:\n\t\t\tserviceAccounts := make(map[string]UserIdentity)\n\t\t\terr := globalIAMSys.store.loadUsers(ctx, svcUser, serviceAccounts)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tsvcAccts := make(map[string]madmin.SRSvcAccCreate)\n\t\t\tfor user, acc := range serviceAccounts {\n\t\t\t\tif user == siteReplicatorSvcAcc {\n\t\t\t\t\t// skip site-replication service account.\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tclaims, err := globalIAMSys.GetClaimsForSvcAcc(ctx, acc.Credentials.AccessKey)\n\t\t\t\tif err != nil {\n\t\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\t_, policy, err := globalIAMSys.GetServiceAccount(ctx, acc.Credentials.AccessKey)\n\t\t\t\tif err != nil {\n\t\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tvar policyJSON []byte\n\t\t\t\tif policy != nil {\n\t\t\t\t\tpolicyJSON, err = json.Marshal(policy)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsvcAccts[user] = madmin.SRSvcAccCreate{\n\t\t\t\t\tParent:        acc.Credentials.ParentUser,\n\t\t\t\t\tAccessKey:     user,\n\t\t\t\t\tSecretKey:     acc.Credentials.SecretKey,\n\t\t\t\t\tGroups:        acc.Credentials.Groups,\n\t\t\t\t\tClaims:        claims,\n\t\t\t\t\tSessionPolicy: json.RawMessage(policyJSON),\n\t\t\t\t\tStatus:        acc.Credentials.Status,\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsvcAccData, err := json.Marshal(svcAccts)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err = rawDataFn(bytes.NewReader(svcAccData), iamFile, len(svcAccData)); err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase userPolicyMappingsFile:\n\t\t\tuserPolicyMap := make(map[string]MappedPolicy)\n\t\t\terr := globalIAMSys.store.loadMappedPolicies(ctx, regUser, false, userPolicyMap)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tuserPolData, err := json.Marshal(userPolicyMap)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err = rawDataFn(bytes.NewReader(userPolData), iamFile, len(userPolData)); err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase groupPolicyMappingsFile:\n\t\t\tgroupPolicyMap := make(map[string]MappedPolicy)\n\t\t\terr := globalIAMSys.store.loadMappedPolicies(ctx, regUser, true, groupPolicyMap)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgrpPolData, err := json.Marshal(groupPolicyMap)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err = rawDataFn(bytes.NewReader(grpPolData), iamFile, len(grpPolData)); err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase stsUserPolicyMappingsFile:\n\t\t\tuserPolicyMap := make(map[string]MappedPolicy)\n\t\t\terr := globalIAMSys.store.loadMappedPolicies(ctx, stsUser, false, userPolicyMap)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tuserPolData, err := json.Marshal(userPolicyMap)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err = rawDataFn(bytes.NewReader(userPolData), iamFile, len(userPolData)); err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase stsGroupPolicyMappingsFile:\n\t\t\tgroupPolicyMap := make(map[string]MappedPolicy)\n\t\t\terr := globalIAMSys.store.loadMappedPolicies(ctx, stsUser, true, groupPolicyMap)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgrpPolData, err := json.Marshal(groupPolicyMap)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err = rawDataFn(bytes.NewReader(grpPolData), iamFile, len(grpPolData)); err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ImportIAM - imports all IAM info into MinIO\nfunc (a adminAPIHandlers) ImportIAM(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\tcred, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\tdata, err := io.ReadAll(r.Body)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n\t\treturn\n\t}\n\treader := bytes.NewReader(data)\n\tzr, err := zip.NewReader(reader, int64(len(data)))\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n\t\treturn\n\t}\n\t// import policies first\n\t{\n\n\t\tf, err := zr.Open(pathJoin(iamAssetsDir, allPoliciesFile))\n\t\tswitch {\n\t\tcase errors.Is(err, os.ErrNotExist):\n\t\tcase err != nil:\n\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, allPoliciesFile, \"\"), r.URL)\n\t\t\treturn\n\t\tdefault:\n\t\t\tdefer f.Close()\n\t\t\tvar allPolicies map[string]policy.Policy\n\t\t\tdata, err = io.ReadAll(f)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, allPoliciesFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = json.Unmarshal(data, &allPolicies)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminConfigBadJSON, err, allPoliciesFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor policyName, policy := range allPolicies {\n\t\t\t\tif policy.IsEmpty() {\n\t\t\t\t\terr = globalIAMSys.DeletePolicy(ctx, policyName, true)\n\t\t\t\t} else {\n\t\t\t\t\t_, err = globalIAMSys.SetPolicy(ctx, policyName, policy)\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, allPoliciesFile, policyName), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// import users\n\t{\n\t\tf, err := zr.Open(pathJoin(iamAssetsDir, allUsersFile))\n\t\tswitch {\n\t\tcase errors.Is(err, os.ErrNotExist):\n\t\tcase err != nil:\n\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, allUsersFile, \"\"), r.URL)\n\t\t\treturn\n\t\tdefault:\n\t\t\tdefer f.Close()\n\t\t\tvar userAccts map[string]madmin.AddOrUpdateUserReq\n\t\t\tdata, err := io.ReadAll(f)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, allUsersFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = json.Unmarshal(data, &userAccts)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminConfigBadJSON, err, allUsersFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor accessKey, ureq := range userAccts {\n\t\t\t\t// Not allowed to add a user with same access key as root credential\n\t\t\t\tif accessKey == globalActiveCred.AccessKey {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAddUserInvalidArgument, err, allUsersFile, accessKey), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tuser, exists := globalIAMSys.GetUser(ctx, accessKey)\n\t\t\t\tif exists && (user.Credentials.IsTemp() || user.Credentials.IsServiceAccount()) {\n\t\t\t\t\t// Updating STS credential is not allowed, and this API does not\n\t\t\t\t\t// support updating service accounts.\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAddUserInvalidArgument, err, allUsersFile, accessKey), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif (cred.IsTemp() || cred.IsServiceAccount()) && cred.ParentUser == accessKey {\n\t\t\t\t\t// Incoming access key matches parent user then we should\n\t\t\t\t\t// reject password change requests.\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAddUserInvalidArgument, err, allUsersFile, accessKey), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// Check if accessKey has beginning and end space characters, this only applies to new users.\n\t\t\t\tif !exists && hasSpaceBE(accessKey) {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminResourceInvalidArgument, err, allUsersFile, accessKey), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tcheckDenyOnly := false\n\t\t\t\tif accessKey == cred.AccessKey {\n\t\t\t\t\t// Check that there is no explicit deny - otherwise it's allowed\n\t\t\t\t\t// to change one's own password.\n\t\t\t\t\tcheckDenyOnly = true\n\t\t\t\t}\n\n\t\t\t\tif !globalIAMSys.IsAllowed(policy.Args{\n\t\t\t\t\tAccountName:     cred.AccessKey,\n\t\t\t\t\tGroups:          cred.Groups,\n\t\t\t\t\tAction:          policy.CreateUserAdminAction,\n\t\t\t\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\t\t\t\tIsOwner:         owner,\n\t\t\t\t\tClaims:          cred.Claims,\n\t\t\t\t\tDenyOnly:        checkDenyOnly,\n\t\t\t\t}) {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAccessDenied, err, allUsersFile, accessKey), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif _, err = globalIAMSys.CreateUser(ctx, accessKey, ureq); err != nil {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, toAdminAPIErrCode(ctx, err), err, allUsersFile, accessKey), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\t// import groups\n\t{\n\t\tf, err := zr.Open(pathJoin(iamAssetsDir, allGroupsFile))\n\t\tswitch {\n\t\tcase errors.Is(err, os.ErrNotExist):\n\t\tcase err != nil:\n\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, allGroupsFile, \"\"), r.URL)\n\t\t\treturn\n\t\tdefault:\n\t\t\tdefer f.Close()\n\t\t\tvar grpInfos map[string]GroupInfo\n\t\t\tdata, err := io.ReadAll(f)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, allGroupsFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err = json.Unmarshal(data, &grpInfos); err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminConfigBadJSON, err, allGroupsFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor group, grpInfo := range grpInfos {\n\t\t\t\t// Check if group already exists\n\t\t\t\tif _, gerr := globalIAMSys.GetGroupDescription(group); gerr != nil {\n\t\t\t\t\t// If group does not exist, then check if the group has beginning and end space characters\n\t\t\t\t\t// we will reject such group names.\n\t\t\t\t\tif errors.Is(gerr, errNoSuchGroup) && hasSpaceBE(group) {\n\t\t\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminResourceInvalidArgument, err, allGroupsFile, group), r.URL)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif _, gerr := globalIAMSys.AddUsersToGroup(ctx, group, grpInfo.Members); gerr != nil {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, allGroupsFile, group), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// import service accounts\n\t{\n\t\tf, err := zr.Open(pathJoin(iamAssetsDir, allSvcAcctsFile))\n\t\tswitch {\n\t\tcase errors.Is(err, os.ErrNotExist):\n\t\tcase err != nil:\n\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, allSvcAcctsFile, \"\"), r.URL)\n\t\t\treturn\n\t\tdefault:\n\t\t\tdefer f.Close()\n\t\t\tvar serviceAcctReqs map[string]madmin.SRSvcAccCreate\n\t\t\tdata, err := io.ReadAll(f)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, allSvcAcctsFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err = json.Unmarshal(data, &serviceAcctReqs); err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminConfigBadJSON, err, allSvcAcctsFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor user, svcAcctReq := range serviceAcctReqs {\n\t\t\t\tvar sp *policy.Policy\n\t\t\t\tvar err error\n\t\t\t\tif len(svcAcctReq.SessionPolicy) > 0 {\n\t\t\t\t\tsp, err = policy.ParseConfig(bytes.NewReader(svcAcctReq.SessionPolicy))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, allSvcAcctsFile, user), r.URL)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// service account access key cannot have space characters beginning and end of the string.\n\t\t\t\tif hasSpaceBE(svcAcctReq.AccessKey) {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminResourceInvalidArgument), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif !globalIAMSys.IsAllowed(policy.Args{\n\t\t\t\t\tAccountName:     cred.AccessKey,\n\t\t\t\t\tGroups:          cred.Groups,\n\t\t\t\t\tAction:          policy.CreateServiceAccountAdminAction,\n\t\t\t\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\t\t\t\tIsOwner:         owner,\n\t\t\t\t\tClaims:          cred.Claims,\n\t\t\t\t}) {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAccessDenied, err, allSvcAcctsFile, user), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tupdateReq := true\n\t\t\t\t_, _, err = globalIAMSys.GetServiceAccount(ctx, svcAcctReq.AccessKey)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif !errors.Is(err, errNoSuchServiceAccount) {\n\t\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, allSvcAcctsFile, user), r.URL)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tupdateReq = false\n\t\t\t\t}\n\t\t\t\tif updateReq {\n\t\t\t\t\topts := updateServiceAccountOpts{\n\t\t\t\t\t\tsecretKey:     svcAcctReq.SecretKey,\n\t\t\t\t\t\tstatus:        svcAcctReq.Status,\n\t\t\t\t\t\tname:          svcAcctReq.Name,\n\t\t\t\t\t\tdescription:   svcAcctReq.Description,\n\t\t\t\t\t\texpiration:    svcAcctReq.Expiration,\n\t\t\t\t\t\tsessionPolicy: sp,\n\t\t\t\t\t}\n\t\t\t\t\t_, err = globalIAMSys.UpdateServiceAccount(ctx, svcAcctReq.AccessKey, opts)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, allSvcAcctsFile, user), r.URL)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\topts := newServiceAccountOpts{\n\t\t\t\t\taccessKey:                  user,\n\t\t\t\t\tsecretKey:                  svcAcctReq.SecretKey,\n\t\t\t\t\tsessionPolicy:              sp,\n\t\t\t\t\tclaims:                     svcAcctReq.Claims,\n\t\t\t\t\tname:                       svcAcctReq.Name,\n\t\t\t\t\tdescription:                svcAcctReq.Description,\n\t\t\t\t\texpiration:                 svcAcctReq.Expiration,\n\t\t\t\t\tallowSiteReplicatorAccount: false,\n\t\t\t\t}\n\n\t\t\t\t// In case of LDAP we need to resolve the targetUser to a DN and\n\t\t\t\t// query their groups:\n\t\t\t\tif globalIAMSys.LDAPConfig.Enabled() {\n\t\t\t\t\topts.claims[ldapUserN] = svcAcctReq.AccessKey // simple username\n\t\t\t\t\ttargetUser, _, err := globalIAMSys.LDAPConfig.LookupUserDN(svcAcctReq.AccessKey)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, allSvcAcctsFile, user), r.URL)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\topts.claims[ldapUser] = targetUser // username DN\n\t\t\t\t}\n\n\t\t\t\tif _, _, err = globalIAMSys.NewServiceAccount(ctx, svcAcctReq.Parent, svcAcctReq.Groups, opts); err != nil {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, allSvcAcctsFile, user), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\t// import user policy mappings\n\t{\n\t\tf, err := zr.Open(pathJoin(iamAssetsDir, userPolicyMappingsFile))\n\t\tswitch {\n\t\tcase errors.Is(err, os.ErrNotExist):\n\t\tcase err != nil:\n\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, userPolicyMappingsFile, \"\"), r.URL)\n\t\t\treturn\n\t\tdefault:\n\t\t\tdefer f.Close()\n\t\t\tvar userPolicyMap map[string]MappedPolicy\n\t\t\tdata, err := io.ReadAll(f)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, userPolicyMappingsFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err = json.Unmarshal(data, &userPolicyMap); err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminConfigBadJSON, err, userPolicyMappingsFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor u, pm := range userPolicyMap {\n\t\t\t\t// disallow setting policy mapping if user is a temporary user\n\t\t\t\tok, _, err := globalIAMSys.IsTempUser(u)\n\t\t\t\tif err != nil && err != errNoSuchUser {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, userPolicyMappingsFile, u), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif ok {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, errIAMActionNotAllowed, userPolicyMappingsFile, u), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif _, err := globalIAMSys.PolicyDBSet(ctx, u, pm.Policies, regUser, false); err != nil {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, userPolicyMappingsFile, u), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// import group policy mappings\n\t{\n\t\tf, err := zr.Open(pathJoin(iamAssetsDir, groupPolicyMappingsFile))\n\t\tswitch {\n\t\tcase errors.Is(err, os.ErrNotExist):\n\t\tcase err != nil:\n\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, groupPolicyMappingsFile, \"\"), r.URL)\n\t\t\treturn\n\t\tdefault:\n\t\t\tdefer f.Close()\n\t\t\tvar grpPolicyMap map[string]MappedPolicy\n\t\t\tdata, err := io.ReadAll(f)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, groupPolicyMappingsFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err = json.Unmarshal(data, &grpPolicyMap); err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminConfigBadJSON, err, groupPolicyMappingsFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor g, pm := range grpPolicyMap {\n\t\t\t\tif _, err := globalIAMSys.PolicyDBSet(ctx, g, pm.Policies, unknownIAMUserType, true); err != nil {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, groupPolicyMappingsFile, g), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// import sts user policy mappings\n\t{\n\t\tf, err := zr.Open(pathJoin(iamAssetsDir, stsUserPolicyMappingsFile))\n\t\tswitch {\n\t\tcase errors.Is(err, os.ErrNotExist):\n\t\tcase err != nil:\n\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, stsUserPolicyMappingsFile, \"\"), r.URL)\n\t\t\treturn\n\t\tdefault:\n\t\t\tdefer f.Close()\n\t\t\tvar userPolicyMap map[string]MappedPolicy\n\t\t\tdata, err := io.ReadAll(f)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, stsUserPolicyMappingsFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err = json.Unmarshal(data, &userPolicyMap); err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminConfigBadJSON, err, stsUserPolicyMappingsFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor u, pm := range userPolicyMap {\n\t\t\t\t// disallow setting policy mapping if user is a temporary user\n\t\t\t\tok, _, err := globalIAMSys.IsTempUser(u)\n\t\t\t\tif err != nil && err != errNoSuchUser {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, stsUserPolicyMappingsFile, u), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif ok {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, errIAMActionNotAllowed, stsUserPolicyMappingsFile, u), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif _, err := globalIAMSys.PolicyDBSet(ctx, u, pm.Policies, stsUser, false); err != nil {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, stsUserPolicyMappingsFile, u), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// import sts group policy mappings\n\t{\n\t\tf, err := zr.Open(pathJoin(iamAssetsDir, stsGroupPolicyMappingsFile))\n\t\tswitch {\n\t\tcase errors.Is(err, os.ErrNotExist):\n\t\tcase err != nil:\n\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, stsGroupPolicyMappingsFile, \"\"), r.URL)\n\t\t\treturn\n\t\tdefault:\n\t\t\tdefer f.Close()\n\t\t\tvar grpPolicyMap map[string]MappedPolicy\n\t\t\tdata, err := io.ReadAll(f)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, stsGroupPolicyMappingsFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err = json.Unmarshal(data, &grpPolicyMap); err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminConfigBadJSON, err, stsGroupPolicyMappingsFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor g, pm := range grpPolicyMap {\n\t\t\t\tif _, err := globalIAMSys.PolicyDBSet(ctx, g, pm.Policies, unknownIAMUserType, true); err != nil {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, stsGroupPolicyMappingsFile, g), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc commonAddServiceAccount(r *http.Request) (context.Context, auth.Credentials, newServiceAccountOpts, madmin.AddServiceAccountReq, string, APIError) {\n\tctx := r.Context()\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\treturn ctx, auth.Credentials{}, newServiceAccountOpts{}, madmin.AddServiceAccountReq{}, \"\", errorCodes.ToAPIErr(ErrServerNotInitialized)\n\t}\n\n\tcred, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\treturn ctx, auth.Credentials{}, newServiceAccountOpts{}, madmin.AddServiceAccountReq{}, \"\", errorCodes.ToAPIErr(s3Err)\n\t}\n\n\tpassword := cred.SecretKey\n\treqBytes, err := madmin.DecryptData(password, io.LimitReader(r.Body, r.ContentLength))\n\tif err != nil {\n\t\treturn ctx, auth.Credentials{}, newServiceAccountOpts{}, madmin.AddServiceAccountReq{}, \"\", errorCodes.ToAPIErrWithErr(ErrAdminConfigBadJSON, err)\n\t}\n\n\tvar createReq madmin.AddServiceAccountReq\n\tif err = json.Unmarshal(reqBytes, &createReq); err != nil {\n\t\treturn ctx, auth.Credentials{}, newServiceAccountOpts{}, madmin.AddServiceAccountReq{}, \"\", errorCodes.ToAPIErrWithErr(ErrAdminConfigBadJSON, err)\n\t}\n\n\t// service account access key cannot have space characters beginning and end of the string.\n\tif hasSpaceBE(createReq.AccessKey) {\n\t\treturn ctx, auth.Credentials{}, newServiceAccountOpts{}, madmin.AddServiceAccountReq{}, \"\", errorCodes.ToAPIErr(ErrAdminResourceInvalidArgument)\n\t}\n\n\tif err := createReq.Validate(); err != nil {\n\t\t// Since this validation would happen client side as well, we only send\n\t\t// a generic error message here.\n\t\treturn ctx, auth.Credentials{}, newServiceAccountOpts{}, madmin.AddServiceAccountReq{}, \"\", errorCodes.ToAPIErr(ErrAdminResourceInvalidArgument)\n\t}\n\t// If the request did not set a TargetUser, the service account is\n\t// created for the request sender.\n\ttargetUser := createReq.TargetUser\n\tif targetUser == \"\" {\n\t\ttargetUser = cred.AccessKey\n\t}\n\n\tdescription := createReq.Description\n\tif description == \"\" {\n\t\tdescription = createReq.Comment\n\t}\n\topts := newServiceAccountOpts{\n\t\taccessKey:   createReq.AccessKey,\n\t\tsecretKey:   createReq.SecretKey,\n\t\tname:        createReq.Name,\n\t\tdescription: description,\n\t\texpiration:  createReq.Expiration,\n\t\tclaims:      make(map[string]interface{}),\n\t}\n\n\t// Check if action is allowed if creating access key for another user\n\t// Check if action is explicitly denied if for self\n\tif !globalIAMSys.IsAllowed(policy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          policy.CreateServiceAccountAdminAction,\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t\tDenyOnly:        (targetUser == cred.AccessKey || targetUser == cred.ParentUser),\n\t}) {\n\t\treturn ctx, auth.Credentials{}, newServiceAccountOpts{}, madmin.AddServiceAccountReq{}, \"\", errorCodes.ToAPIErr(ErrAccessDenied)\n\t}\n\n\tvar sp *policy.Policy\n\tif len(createReq.Policy) > 0 {\n\t\tsp, err = policy.ParseConfig(bytes.NewReader(createReq.Policy))\n\t\tif err != nil {\n\t\t\treturn ctx, auth.Credentials{}, newServiceAccountOpts{}, madmin.AddServiceAccountReq{}, \"\", toAdminAPIErr(ctx, err)\n\t\t}\n\t}\n\n\topts.sessionPolicy = sp\n\n\treturn ctx, cred, opts, createReq, targetUser, APIError{}\n}\n", "// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/minio/madmin-go/v3\"\n\t\"github.com/minio/minio-go/v7\"\n\t\"github.com/minio/minio-go/v7/pkg/credentials\"\n\t\"github.com/minio/minio-go/v7/pkg/s3utils\"\n\t\"github.com/minio/minio-go/v7/pkg/set\"\n\t\"github.com/minio/minio-go/v7/pkg/signer\"\n\t\"github.com/minio/minio/internal/auth\"\n\t\"github.com/minio/pkg/v2/env\"\n)\n\nconst (\n\ttestDefaultTimeout = 30 * time.Second\n)\n\n// API suite container for IAM\ntype TestSuiteIAM struct {\n\tTestSuiteCommon\n\n\tServerTypeDescription string\n\n\t// Flag to turn on tests for etcd backend IAM\n\twithEtcdBackend bool\n\n\tendpoint string\n\tadm      *madmin.AdminClient\n\tclient   *minio.Client\n}\n\nfunc newTestSuiteIAM(c TestSuiteCommon, withEtcdBackend bool) *TestSuiteIAM {\n\tetcdStr := \"\"\n\tif withEtcdBackend {\n\t\tetcdStr = \" (with etcd backend)\"\n\t}\n\treturn &TestSuiteIAM{\n\t\tTestSuiteCommon:       c,\n\t\tServerTypeDescription: fmt.Sprintf(\"%s%s\", c.serverType, etcdStr),\n\t\twithEtcdBackend:       withEtcdBackend,\n\t}\n}\n\nfunc (s *TestSuiteIAM) iamSetup(c *check) {\n\tvar err error\n\t// strip url scheme from endpoint\n\ts.endpoint = strings.TrimPrefix(s.endPoint, \"http://\")\n\tif s.secure {\n\t\ts.endpoint = strings.TrimPrefix(s.endPoint, \"https://\")\n\t}\n\n\ts.adm, err = madmin.New(s.endpoint, s.accessKey, s.secretKey, s.secure)\n\tif err != nil {\n\t\tc.Fatalf(\"error creating admin client: %v\", err)\n\t}\n\t// Set transport, so that TLS is handled correctly.\n\ts.adm.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\ts.client, err = minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     credentials.NewStaticV4(s.accessKey, s.secretKey, \"\"),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"error creating minio client: %v\", err)\n\t}\n}\n\n// List of all IAM test suites (i.e. test server configuration combinations)\n// common to tests.\nvar iamTestSuites = func() []*TestSuiteIAM {\n\tbaseTestCases := []TestSuiteCommon{\n\t\t// Init and run test on ErasureSD backend with signature v4.\n\t\t{serverType: \"ErasureSD\", signer: signerV4},\n\t\t// Init and run test on ErasureSD backend, with tls enabled.\n\t\t{serverType: \"ErasureSD\", signer: signerV4, secure: true},\n\t\t// Init and run test on Erasure backend.\n\t\t{serverType: \"Erasure\", signer: signerV4},\n\t\t// Init and run test on ErasureSet backend.\n\t\t{serverType: \"ErasureSet\", signer: signerV4},\n\t}\n\ttestCases := []*TestSuiteIAM{}\n\tfor _, bt := range baseTestCases {\n\t\ttestCases = append(testCases,\n\t\t\tnewTestSuiteIAM(bt, false),\n\t\t\tnewTestSuiteIAM(bt, true),\n\t\t)\n\t}\n\treturn testCases\n}()\n\nconst (\n\tEnvTestEtcdBackend = \"_MINIO_ETCD_TEST_SERVER\"\n)\n\nfunc (s *TestSuiteIAM) setUpEtcd(c *check, etcdServer string) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tconfigCmds := []string{\n\t\t\"etcd\",\n\t\t\"endpoints=\" + etcdServer,\n\t\t\"path_prefix=\" + mustGetUUID(),\n\t}\n\t_, err := s.adm.SetConfigKV(ctx, strings.Join(configCmds, \" \"))\n\tif err != nil {\n\t\tc.Fatalf(\"unable to setup Etcd for tests: %v\", err)\n\t}\n\n\ts.RestartIAMSuite(c)\n}\n\nfunc (s *TestSuiteIAM) SetUpSuite(c *check) {\n\t// If etcd backend is specified and etcd server is not present, the test\n\t// is skipped.\n\tetcdServer := env.Get(EnvTestEtcdBackend, \"\")\n\tif s.withEtcdBackend && etcdServer == \"\" {\n\t\tc.Skip(\"Skipping etcd backend IAM test as no etcd server is configured.\")\n\t}\n\n\ts.TestSuiteCommon.SetUpSuite(c)\n\n\ts.iamSetup(c)\n\n\tif s.withEtcdBackend {\n\t\ts.setUpEtcd(c, etcdServer)\n\t}\n}\n\nfunc (s *TestSuiteIAM) RestartIAMSuite(c *check) {\n\ts.TestSuiteCommon.RestartTestServer(c)\n\n\ts.iamSetup(c)\n}\n\nfunc (s *TestSuiteIAM) getAdminClient(c *check, accessKey, secretKey, sessionToken string) *madmin.AdminClient {\n\tmadmClnt, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  credentials.NewStaticV4(accessKey, secretKey, sessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"error creating user admin client: %s\", err)\n\t}\n\tmadmClnt.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\treturn madmClnt\n}\n\nfunc (s *TestSuiteIAM) getUserClient(c *check, accessKey, secretKey, sessionToken string) *minio.Client {\n\tclient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     credentials.NewStaticV4(accessKey, secretKey, sessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"error creating user minio client: %s\", err)\n\t}\n\treturn client\n}\n\nfunc TestIAMInternalIDPServerSuite(t *testing.T) {\n\tif runtime.GOOS == globalWindowsOSName {\n\t\tt.Skip(\"windows is clunky disable these tests\")\n\t}\n\tfor i, testCase := range iamTestSuites {\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s\", i+1, testCase.ServerTypeDescription),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tsuite := testCase\n\t\t\t\tc := &check{t, testCase.serverType}\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tsuite.TestUserCreate(c)\n\t\t\t\tsuite.TestUserPolicyEscalationBug(c)\n\t\t\t\tsuite.TestPolicyCreate(c)\n\t\t\t\tsuite.TestCannedPolicies(c)\n\t\t\t\tsuite.TestGroupAddRemove(c)\n\t\t\t\tsuite.TestServiceAccountOpsByAdmin(c)\n\t\t\t\tsuite.TestServiceAccountOpsByUser(c)\n\t\t\t\tsuite.TestAddServiceAccountPerms(c)\n\t\t\t\tsuite.TearDownSuite(c)\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestUserCreate(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\t// 1. Create a user.\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr := s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\t// 2. Check new user appears in listing\n\tusersMap, err := s.adm.ListUsers(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"error listing: %v\", err)\n\t}\n\tv, ok := usersMap[accessKey]\n\tif !ok {\n\t\tc.Fatalf(\"user not listed: %s\", accessKey)\n\t}\n\tc.Assert(v.Status, madmin.AccountEnabled)\n\n\t// 3. Associate policy and check that user can access\n\terr = s.adm.SetPolicy(ctx, \"readwrite\", accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"unable to set policy: %v\", err)\n\t}\n\n\tclient := s.getUserClient(c, accessKey, secretKey, \"\")\n\terr = client.MakeBucket(ctx, getRandomBucketName(), minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"user could not create bucket: %v\", err)\n\t}\n\n\t// 3.10. Check that user's password can be updated.\n\t_, newSecretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, newSecretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to update user's secret key: %v\", err)\n\t}\n\t// 3.10.1 Check that old password no longer works.\n\terr = client.MakeBucket(ctx, getRandomBucketName(), minio.MakeBucketOptions{})\n\tif err == nil {\n\t\tc.Fatalf(\"user was unexpectedly able to create bucket with bad password!\")\n\t}\n\t// 3.10.2 Check that new password works.\n\tclient = s.getUserClient(c, accessKey, newSecretKey, \"\")\n\terr = client.MakeBucket(ctx, getRandomBucketName(), minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"user could not create bucket: %v\", err)\n\t}\n\n\t// 4. Check that user can be disabled and verify it.\n\terr = s.adm.SetUserStatus(ctx, accessKey, madmin.AccountDisabled)\n\tif err != nil {\n\t\tc.Fatalf(\"could not set user account to disabled\")\n\t}\n\tusersMap, err = s.adm.ListUsers(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"error listing: %v\", err)\n\t}\n\tv, ok = usersMap[accessKey]\n\tif !ok {\n\t\tc.Fatalf(\"user was not listed after disabling: %s\", accessKey)\n\t}\n\tc.Assert(v.Status, madmin.AccountDisabled)\n\terr = client.MakeBucket(ctx, getRandomBucketName(), minio.MakeBucketOptions{})\n\tif err == nil {\n\t\tc.Fatalf(\"user account was not disabled!\")\n\t}\n\n\t// 5. Check that user can be deleted and verify it.\n\terr = s.adm.RemoveUser(ctx, accessKey)\n\tif err != nil {\n\t\tc.Fatalf(\"user could not be deleted: %v\", err)\n\t}\n\tusersMap, err = s.adm.ListUsers(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"error listing: %v\", err)\n\t}\n\t_, ok = usersMap[accessKey]\n\tif ok {\n\t\tc.Fatalf(\"user not deleted: %s\", accessKey)\n\t}\n\terr = client.MakeBucket(ctx, getRandomBucketName(), minio.MakeBucketOptions{})\n\tif err == nil {\n\t\tc.Fatalf(\"user account was not deleted!\")\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestUserPolicyEscalationBug(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// 2. Create a user, associate policy and verify access\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\t// 2.1 check that user does not have any access to the bucket\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustNotListObjects(ctx, uClient, bucket)\n\n\t// 2.2 create and associate policy to user\n\tpolicy := \"mypolicy-test-user-update\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\terr = s.adm.SetPolicy(ctx, policy, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\t// 2.3 check user has access to bucket\n\tc.mustListObjects(ctx, uClient, bucket)\n\t// 2.3 check that user cannot delete the bucket\n\terr = uClient.RemoveBucket(ctx, bucket)\n\tif err == nil || err.Error() != \"Access Denied.\" {\n\t\tc.Fatalf(\"bucket was deleted unexpectedly or got unexpected err: %v\", err)\n\t}\n\n\t// 3. Craft a request to update the user's permissions\n\tep := s.adm.GetEndpointURL()\n\turlValue := url.Values{}\n\turlValue.Add(\"accessKey\", accessKey)\n\tu, err := url.Parse(fmt.Sprintf(\"%s://%s/minio/admin/v3/add-user?%s\", ep.Scheme, ep.Host, s3utils.QueryEncode(urlValue)))\n\tif err != nil {\n\t\tc.Fatalf(\"unexpected url parse err: %v\", err)\n\t}\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPut, u.String(), nil)\n\tif err != nil {\n\t\tc.Fatalf(\"unexpected new request err: %v\", err)\n\t}\n\treqBodyArg := madmin.UserInfo{\n\t\tSecretKey:  secretKey,\n\t\tPolicyName: \"consoleAdmin\",\n\t\tStatus:     madmin.AccountEnabled,\n\t}\n\tbuf, err := json.Marshal(reqBodyArg)\n\tif err != nil {\n\t\tc.Fatalf(\"unexpected json encode err: %v\", err)\n\t}\n\tbuf, err = madmin.EncryptData(secretKey, buf)\n\tif err != nil {\n\t\tc.Fatalf(\"unexpected encryption err: %v\", err)\n\t}\n\n\treq.ContentLength = int64(len(buf))\n\tsum := sha256.Sum256(buf)\n\treq.Header.Set(\"X-Amz-Content-Sha256\", hex.EncodeToString(sum[:]))\n\treq.Body = io.NopCloser(bytes.NewReader(buf))\n\treq = signer.SignV4(*req, accessKey, secretKey, \"\", \"\")\n\n\t// 3.1 Execute the request.\n\tresp, err := s.TestSuiteCommon.client.Do(req)\n\tif err != nil {\n\t\tc.Fatalf(\"unexpected request err: %v\", err)\n\t}\n\tif resp.StatusCode != 200 {\n\t\tc.Fatalf(\"got unexpected response: %#v\\n\", resp)\n\t}\n\n\t// 3.2 check that user cannot delete the bucket\n\terr = uClient.RemoveBucket(ctx, bucket)\n\tif err == nil || err.Error() != \"Access Denied.\" {\n\t\tc.Fatalf(\"User was able to escalate privileges (Err=%v)!\", err)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestAddServiceAccountPerms(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\t// 1. Create a policy\n\tpolicy1 := \"deny-svc\"\n\tpolicy2 := \"allow-svc\"\n\tpolicyBytes := []byte(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Deny\",\n   \"Action\": [\n    \"admin:CreateServiceAccount\"\n   ]\n  }\n ]\n}`)\n\n\tnewPolicyBytes := []byte(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::testbucket/*\"\n   ]\n  }\n ]\n}`)\n\n\terr := s.adm.AddCannedPolicy(ctx, policy1, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\terr = s.adm.AddCannedPolicy(ctx, policy2, newPolicyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\t// 2. Verify that policy json is validated by server\n\tinvalidPolicyBytes := policyBytes[:len(policyBytes)-1]\n\terr = s.adm.AddCannedPolicy(ctx, policy1+\"invalid\", invalidPolicyBytes)\n\tif err == nil {\n\t\tc.Fatalf(\"invalid policy creation success\")\n\t}\n\n\t// 3. Create a user, associate policy and verify access\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\t// 3.1 check that user does not have any access to the bucket\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustNotListObjects(ctx, uClient, \"testbucket\")\n\n\t// 3.2 associate policy to user\n\terr = s.adm.SetPolicy(ctx, policy1, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\tadmClnt := s.getAdminClient(c, accessKey, secretKey, \"\")\n\n\t// 3.3 check user does not have explicit permissions to create service account.\n\tc.mustNotCreateSvcAccount(ctx, accessKey, admClnt)\n\n\t// 4. Verify the policy appears in listing\n\tps, err := s.adm.ListCannedPolicies(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"policy list err: %v\", err)\n\t}\n\t_, ok := ps[policy1]\n\tif !ok {\n\t\tc.Fatalf(\"policy was missing!\")\n\t}\n\n\t// 3.2 associate policy to user\n\terr = s.adm.SetPolicy(ctx, policy2, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\t// 3.3 check user can create service account implicitly.\n\tc.mustCreateSvcAccount(ctx, accessKey, admClnt)\n\n\t_, ok = ps[policy2]\n\tif !ok {\n\t\tc.Fatalf(\"policy was missing!\")\n\t}\n\n\terr = s.adm.RemoveUser(ctx, accessKey)\n\tif err != nil {\n\t\tc.Fatalf(\"user could not be deleted: %v\", err)\n\t}\n\n\terr = s.adm.RemoveCannedPolicy(ctx, policy1)\n\tif err != nil {\n\t\tc.Fatalf(\"policy del err: %v\", err)\n\t}\n\n\terr = s.adm.RemoveCannedPolicy(ctx, policy2)\n\tif err != nil {\n\t\tc.Fatalf(\"policy del err: %v\", err)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestPolicyCreate(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// 1. Create a policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\t// 2. Verify that policy json is validated by server\n\tinvalidPolicyBytes := policyBytes[:len(policyBytes)-1]\n\terr = s.adm.AddCannedPolicy(ctx, policy+\"invalid\", invalidPolicyBytes)\n\tif err == nil {\n\t\tc.Fatalf(\"invalid policy creation success\")\n\t}\n\n\t// 3. Create a user, associate policy and verify access\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\t// 3.1 check that user does not have any access to the bucket\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustNotListObjects(ctx, uClient, bucket)\n\n\t// 3.2 associate policy to user\n\terr = s.adm.SetPolicy(ctx, policy, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\t// 3.3 check user has access to bucket\n\tc.mustListObjects(ctx, uClient, bucket)\n\t// 3.4 Check that user cannot exceed their permissions\n\terr = uClient.RemoveBucket(ctx, bucket)\n\tif err == nil {\n\t\tc.Fatalf(\"bucket was deleted!\")\n\t}\n\n\t// 4. Verify the policy appears in listing\n\tps, err := s.adm.ListCannedPolicies(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"policy list err: %v\", err)\n\t}\n\t_, ok := ps[policy]\n\tif !ok {\n\t\tc.Fatalf(\"policy was missing!\")\n\t}\n\n\t// 5. Check that policy cannot be deleted when attached to a user.\n\terr = s.adm.RemoveCannedPolicy(ctx, policy)\n\tif err == nil {\n\t\tc.Fatalf(\"policy could be unexpectedly deleted!\")\n\t}\n\n\t// 6. Delete the user and then delete the policy.\n\terr = s.adm.RemoveUser(ctx, accessKey)\n\tif err != nil {\n\t\tc.Fatalf(\"user could not be deleted: %v\", err)\n\t}\n\terr = s.adm.RemoveCannedPolicy(ctx, policy)\n\tif err != nil {\n\t\tc.Fatalf(\"policy del err: %v\", err)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestCannedPolicies(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tpolicies, err := s.adm.ListCannedPolicies(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"unable to list policies: %v\", err)\n\t}\n\n\tdefaultPolicies := []string{\n\t\t\"readwrite\",\n\t\t\"readonly\",\n\t\t\"writeonly\",\n\t\t\"diagnostics\",\n\t\t\"consoleAdmin\",\n\t}\n\n\tfor _, v := range defaultPolicies {\n\t\tif _, ok := policies[v]; !ok {\n\t\t\tc.Fatalf(\"Failed to find %s in policies list\", v)\n\t\t}\n\t}\n\n\tbucket := getRandomBucketName()\n\terr = s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\n\t// Check that default policies can be overwritten.\n\terr = s.adm.AddCannedPolicy(ctx, \"readwrite\", policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tinfo, err := s.adm.InfoCannedPolicy(ctx, \"readwrite\")\n\tif err != nil {\n\t\tc.Fatalf(\"policy info err: %v\", err)\n\t}\n\n\tinfoStr := string(info)\n\tif !strings.Contains(infoStr, `\"s3:PutObject\"`) || !strings.Contains(infoStr, \":\"+bucket+\"/\") {\n\t\tc.Fatalf(\"policy contains unexpected content!\")\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestGroupAddRemove(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\t// 1. Add user to a new group\n\tgroup := \"mygroup\"\n\terr = s.adm.UpdateGroupMembers(ctx, madmin.GroupAddRemove{\n\t\tGroup:   group,\n\t\tMembers: []string{accessKey},\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to add user to group: %v\", err)\n\t}\n\n\t// 2. Check that user has no access\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustNotListObjects(ctx, uClient, bucket)\n\n\t// 3. Associate policy to group and check user got access.\n\terr = s.adm.SetPolicy(ctx, policy, group, true)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\t// 3.1 check user has access to bucket\n\tc.mustListObjects(ctx, uClient, bucket)\n\t// 3.2 Check that user cannot exceed their permissions\n\terr = uClient.RemoveBucket(ctx, bucket)\n\tif err == nil {\n\t\tc.Fatalf(\"bucket was deleted!\")\n\t}\n\n\t// 4. List groups and members and verify\n\tgroups, err := s.adm.ListGroups(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"group list err: %v\", err)\n\t}\n\tif !set.CreateStringSet(groups...).Contains(group) {\n\t\tc.Fatalf(\"created group not present!\")\n\t}\n\tgroupInfo, err := s.adm.GetGroupDescription(ctx, group)\n\tif err != nil {\n\t\tc.Fatalf(\"group desc err: %v\", err)\n\t}\n\tc.Assert(groupInfo.Name, group)\n\tc.Assert(set.CreateStringSet(groupInfo.Members...), set.CreateStringSet(accessKey))\n\tc.Assert(groupInfo.Policy, policy)\n\tc.Assert(groupInfo.Status, string(madmin.GroupEnabled))\n\n\t// 5. Disable/enable the group and verify that user access is revoked/restored.\n\terr = s.adm.SetGroupStatus(ctx, group, madmin.GroupDisabled)\n\tif err != nil {\n\t\tc.Fatalf(\"group set status err: %v\", err)\n\t}\n\tgroupInfo, err = s.adm.GetGroupDescription(ctx, group)\n\tif err != nil {\n\t\tc.Fatalf(\"group desc err: %v\", err)\n\t}\n\tc.Assert(groupInfo.Status, string(madmin.GroupDisabled))\n\tc.mustNotListObjects(ctx, uClient, bucket)\n\n\terr = s.adm.SetGroupStatus(ctx, group, madmin.GroupEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"group set status err: %v\", err)\n\t}\n\tgroupInfo, err = s.adm.GetGroupDescription(ctx, group)\n\tif err != nil {\n\t\tc.Fatalf(\"group desc err: %v\", err)\n\t}\n\tc.Assert(groupInfo.Status, string(madmin.GroupEnabled))\n\tc.mustListObjects(ctx, uClient, bucket)\n\n\t// 6. Verify that group cannot be deleted with users.\n\terr = s.adm.UpdateGroupMembers(ctx, madmin.GroupAddRemove{\n\t\tGroup:    group,\n\t\tIsRemove: true,\n\t})\n\tif err == nil {\n\t\tc.Fatalf(\"group was removed!\")\n\t}\n\tgroupInfo, err = s.adm.GetGroupDescription(ctx, group)\n\tif err != nil {\n\t\tc.Fatalf(\"group desc err: %v\", err)\n\t}\n\tc.Assert(groupInfo.Name, group)\n\n\t// 7. Remove user from group and verify access is revoked.\n\terr = s.adm.UpdateGroupMembers(ctx, madmin.GroupAddRemove{\n\t\tGroup:    group,\n\t\tMembers:  []string{accessKey},\n\t\tIsRemove: true,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"group update err: %v\", err)\n\t}\n\tc.mustNotListObjects(ctx, uClient, bucket)\n\n\t// 7.1 verify group still exists\n\tgroupInfo, err = s.adm.GetGroupDescription(ctx, group)\n\tif err != nil {\n\t\tc.Fatalf(\"group desc err: %v\", err)\n\t}\n\tc.Assert(groupInfo.Name, group)\n\tc.Assert(len(groupInfo.Members), 0)\n\n\t// 8. Delete group and verify\n\terr = s.adm.UpdateGroupMembers(ctx, madmin.GroupAddRemove{\n\t\tGroup:    group,\n\t\tIsRemove: true,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"group update err: %v\", err)\n\t}\n\tgroups, err = s.adm.ListGroups(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"group list err: %v\", err)\n\t}\n\tif set.CreateStringSet(groups...).Contains(group) {\n\t\tc.Fatalf(\"created group still present!\")\n\t}\n\t_, err = s.adm.GetGroupDescription(ctx, group)\n\tif err == nil {\n\t\tc.Fatalf(\"group appears to exist\")\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestServiceAccountOpsByUser(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// Create policy, user and associate policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  credentials.NewStaticV4(accessKey, secretKey, \"\"),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, accessKey, userAdmClient)\n\n\t// 1. Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, userAdmClient, accessKey, cr.AccessKey)\n\n\t// 2. Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, userAdmClient, accessKey, cr.AccessKey, false)\n\n\t// 3. Check S3 access\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// 4. Check that svc account can restrict the policy, and that the\n\t// session policy can be updated.\n\tc.assertSvcAccSessionPolicyUpdate(ctx, s, userAdmClient, accessKey, bucket)\n\n\t// 4. Check that service account's secret key and account status can be\n\t// updated.\n\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, userAdmClient, accessKey, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, userAdmClient, accessKey, bucket)\n\n\t// 6. Check that service account cannot be created for some other user.\n\tc.mustNotCreateSvcAccount(ctx, globalActiveCred.AccessKey, userAdmClient)\n}\n\nfunc (s *TestSuiteIAM) TestServiceAccountOpsByAdmin(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// Create policy, user and associate policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\t// 1. Create a service account for the user\n\tcr := c.mustCreateSvcAccount(ctx, accessKey, s.adm)\n\n\t// 1.2 Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, s.adm, accessKey, cr.AccessKey)\n\n\t// 1.3 Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, s.adm, accessKey, cr.AccessKey, false)\n\n\t// 2. Check that svc account can access the bucket\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// 3. Check that svc account can restrict the policy, and that the\n\t// session policy can be updated.\n\tc.assertSvcAccSessionPolicyUpdate(ctx, s, s.adm, accessKey, bucket)\n\n\t// 4. Check that service account's secret key and account status can be\n\t// updated.\n\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, s.adm, accessKey, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, s.adm, accessKey, bucket)\n}\n\nfunc (s *TestSuiteIAM) SetUpAccMgmtPlugin(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tpluginEndpoint := env.Get(\"_MINIO_POLICY_PLUGIN_ENDPOINT\", \"\")\n\tif pluginEndpoint == \"\" {\n\t\tc.Skip(\"_MINIO_POLICY_PLUGIN_ENDPOINT not given - skipping.\")\n\t}\n\n\tconfigCmds := []string{\n\t\t\"policy_plugin\",\n\t\t\"url=\" + pluginEndpoint,\n\t}\n\n\t_, err := s.adm.SetConfigKV(ctx, strings.Join(configCmds, \" \"))\n\tif err != nil {\n\t\tc.Fatalf(\"unable to setup access management plugin for tests: %v\", err)\n\t}\n\n\ts.RestartIAMSuite(c)\n}\n\n// TestIAM_AMPInternalIDPServerSuite - tests for access management plugin\nfunc TestIAM_AMPInternalIDPServerSuite(t *testing.T) {\n\tfor i, testCase := range iamTestSuites {\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s\", i+1, testCase.ServerTypeDescription),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tsuite := testCase\n\t\t\t\tc := &check{t, testCase.serverType}\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tdefer suite.TearDownSuite(c)\n\n\t\t\t\tsuite.SetUpAccMgmtPlugin(c)\n\n\t\t\t\tsuite.TestAccMgmtPlugin(c)\n\t\t\t},\n\t\t)\n\t}\n}\n\n// TestAccMgmtPlugin - this test assumes that the access-management-plugin is\n// the same as the example in `docs/iam/access-manager-plugin.go` -\n// specifically, it denies only `s3:Put*` operations on non-root accounts.\nfunc (s *TestSuiteIAM) TestAccMgmtPlugin(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\t// 0. Check that owner is able to make-bucket.\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// 1. Create a user.\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\t// 2. Check new user appears in listing\n\tusersMap, err := s.adm.ListUsers(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"error listing: %v\", err)\n\t}\n\tv, ok := usersMap[accessKey]\n\tif !ok {\n\t\tc.Fatalf(\"user not listed: %s\", accessKey)\n\t}\n\tc.Assert(v.Status, madmin.AccountEnabled)\n\n\t// 3. Check that user is able to make a bucket.\n\tclient := s.getUserClient(c, accessKey, secretKey, \"\")\n\terr = client.MakeBucket(ctx, getRandomBucketName(), minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"user not create bucket: %v\", err)\n\t}\n\n\t// 3.1 check user has access to bucket\n\tc.mustListObjects(ctx, client, bucket)\n\n\t// 3.2 check that user cannot upload an object.\n\t_, err = client.PutObject(ctx, bucket, \"objectName\", bytes.NewBuffer([]byte(\"some content\")), 12, minio.PutObjectOptions{})\n\tif err == nil {\n\t\tc.Fatalf(\"user was able to upload unexpectedly\")\n\t}\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  credentials.NewStaticV4(accessKey, secretKey, \"\"),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, accessKey, userAdmClient)\n\n\t// 1. Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, userAdmClient, accessKey, cr.AccessKey)\n\n\t// 2. Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, userAdmClient, accessKey, cr.AccessKey, false)\n\n\t// 3. Check S3 access\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// Check that session policies do not apply - as policy enforcement is\n\t// delegated to plugin.\n\t{\n\t\tsvcAK, svcSK := mustGenerateCredentials(c)\n\n\t\t// This policy does not allow listing objects.\n\t\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\t\tcr, err := userAdmClient.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n\t\t\tPolicy:     policyBytes,\n\t\t\tTargetUser: accessKey,\n\t\t\tAccessKey:  svcAK,\n\t\t\tSecretKey:  svcSK,\n\t\t})\n\t\tif err != nil {\n\t\t\tc.Fatalf(\"Unable to create svc acc: %v\", err)\n\t\t}\n\t\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n\t\t// Though the attached policy does not allow listing, it will be\n\t\t// ignored because the plugin allows it.\n\t\tc.mustListObjects(ctx, svcClient, bucket)\n\t}\n\n\t// 4. Check that service account's secret key and account status can be\n\t// updated.\n\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, userAdmClient, accessKey, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, userAdmClient, accessKey, bucket)\n\n\t// 6. Check that service account **can** be created for some other user.\n\t// This is possible because the policy enforced in the plugin.\n\tc.mustCreateSvcAccount(ctx, globalActiveCred.AccessKey, userAdmClient)\n}\n\nfunc (c *check) mustCreateIAMUser(ctx context.Context, admClnt *madmin.AdminClient) madmin.Credentials {\n\tc.Helper()\n\trandUser := mustGetUUID()\n\trandPass := mustGetUUID()\n\terr := admClnt.AddUser(ctx, randUser, randPass)\n\tif err != nil {\n\t\tc.Fatalf(\"should be able to create a user: %v\", err)\n\t}\n\treturn madmin.Credentials{\n\t\tAccessKey: randUser,\n\t\tSecretKey: randPass,\n\t}\n}\n\nfunc (c *check) mustGetIAMUserInfo(ctx context.Context, admClnt *madmin.AdminClient, accessKey string) madmin.UserInfo {\n\tc.Helper()\n\tui, err := admClnt.GetUserInfo(ctx, accessKey)\n\tif err != nil {\n\t\tc.Fatalf(\"should be able to get user info: %v\", err)\n\t}\n\treturn ui\n}\n\nfunc (c *check) mustNotCreateIAMUser(ctx context.Context, admClnt *madmin.AdminClient) {\n\tc.Helper()\n\trandUser := mustGetUUID()\n\trandPass := mustGetUUID()\n\terr := admClnt.AddUser(ctx, randUser, randPass)\n\tif err == nil {\n\t\tc.Fatalf(\"should not be able to create a user\")\n\t}\n}\n\nfunc (c *check) mustCreateSvcAccount(ctx context.Context, tgtUser string, admClnt *madmin.AdminClient) madmin.Credentials {\n\tc.Helper()\n\tcr, err := admClnt.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n\t\tTargetUser: tgtUser,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"user should be able to create service accounts %s\", err)\n\t}\n\treturn cr\n}\n\nfunc (c *check) mustNotCreateSvcAccount(ctx context.Context, tgtUser string, admClnt *madmin.AdminClient) {\n\tc.Helper()\n\t_, err := admClnt.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n\t\tTargetUser: tgtUser,\n\t})\n\tif err == nil {\n\t\tc.Fatalf(\"user was able to add service accounts unexpectedly!\")\n\t}\n}\n\nfunc (c *check) mustNotListObjects(ctx context.Context, client *minio.Client, bucket string) {\n\tc.Helper()\n\tres := client.ListObjects(ctx, bucket, minio.ListObjectsOptions{})\n\tv, ok := <-res\n\tif !ok || v.Err == nil {\n\t\tc.Fatalf(\"user was able to list unexpectedly! on %s\", bucket)\n\t}\n}\n\nfunc (c *check) mustPutObjectWithTags(ctx context.Context, client *minio.Client, bucket, object string) {\n\tc.Helper()\n\t_, err := client.PutObject(ctx, bucket, object, bytes.NewBuffer([]byte(\"stuff\")), 5, minio.PutObjectOptions{\n\t\tUserTags: map[string]string{\n\t\t\t\"security\": \"public\",\n\t\t\t\"virus\":    \"true\",\n\t\t},\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"user was unable to upload the object: %v\", err)\n\t}\n}\n\nfunc (c *check) mustGetObject(ctx context.Context, client *minio.Client, bucket, object string) {\n\tc.Helper()\n\n\tr, err := client.GetObject(ctx, bucket, object, minio.GetObjectOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"user was unable to download the object: %v\", err)\n\t}\n\tdefer r.Close()\n\n\t_, err = io.Copy(io.Discard, r)\n\tif err != nil {\n\t\tc.Fatalf(\"user was unable to download the object: %v\", err)\n\t}\n}\n\nfunc (c *check) mustHeadObject(ctx context.Context, client *minio.Client, bucket, object string, tagCount int) {\n\tc.Helper()\n\n\toinfo, err := client.StatObject(ctx, bucket, object, minio.StatObjectOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"user was unable to download the object: %v\", err)\n\t}\n\n\tif oinfo.UserTagCount != tagCount {\n\t\tc.Fatalf(\"expected tagCount: %d, got %d\", tagCount, oinfo.UserTagCount)\n\t}\n}\n\nfunc (c *check) mustListObjects(ctx context.Context, client *minio.Client, bucket string) {\n\tc.Helper()\n\tres := client.ListObjects(ctx, bucket, minio.ListObjectsOptions{})\n\tv, ok := <-res\n\tif ok && v.Err != nil {\n\t\tc.Fatalf(\"user was unable to list: %v\", v.Err)\n\t}\n}\n\nfunc (c *check) mustListBuckets(ctx context.Context, client *minio.Client) {\n\tc.Helper()\n\t_, err := client.ListBuckets(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"user was unable to list buckets: %v\", err)\n\t}\n}\n\nfunc (c *check) mustNotDelete(ctx context.Context, client *minio.Client, bucket string, vid string) {\n\tc.Helper()\n\n\terr := client.RemoveObject(ctx, bucket, \"some-object\", minio.RemoveObjectOptions{VersionID: vid})\n\tif err == nil {\n\t\tc.Fatalf(\"user must not be allowed to delete\")\n\t}\n\n\terr = client.RemoveObject(ctx, bucket, \"some-object\", minio.RemoveObjectOptions{})\n\tif err != nil {\n\t\tc.Fatal(\"user must be able to create delete marker\")\n\t}\n}\n\nfunc (c *check) mustDownload(ctx context.Context, client *minio.Client, bucket string) {\n\tc.Helper()\n\trd, err := client.GetObject(ctx, bucket, \"some-object\", minio.GetObjectOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"download did not succeed got %#v\", err)\n\t}\n\tif _, err = io.Copy(io.Discard, rd); err != nil {\n\t\tc.Fatalf(\"download did not succeed got %#v\", err)\n\t}\n}\n\nfunc (c *check) mustUploadReturnVersions(ctx context.Context, client *minio.Client, bucket string) []string {\n\tc.Helper()\n\tversions := []string{}\n\tfor i := 0; i < 5; i++ {\n\t\tui, err := client.PutObject(ctx, bucket, \"some-object\", bytes.NewBuffer([]byte(\"stuff\")), 5, minio.PutObjectOptions{})\n\t\tif err != nil {\n\t\t\tc.Fatalf(\"upload did not succeed got %#v\", err)\n\t\t}\n\t\tversions = append(versions, ui.VersionID)\n\t}\n\treturn versions\n}\n\nfunc (c *check) mustUpload(ctx context.Context, client *minio.Client, bucket string) {\n\tc.Helper()\n\t_, err := client.PutObject(ctx, bucket, \"some-object\", bytes.NewBuffer([]byte(\"stuff\")), 5, minio.PutObjectOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"upload did not succeed got %#v\", err)\n\t}\n}\n\nfunc (c *check) mustNotUpload(ctx context.Context, client *minio.Client, bucket string) {\n\tc.Helper()\n\t_, err := client.PutObject(ctx, bucket, \"some-object\", bytes.NewBuffer([]byte(\"stuff\")), 5, minio.PutObjectOptions{})\n\tif e, ok := err.(minio.ErrorResponse); ok {\n\t\tif e.Code == \"AccessDenied\" {\n\t\t\treturn\n\t\t}\n\t}\n\tc.Fatalf(\"upload did not get an AccessDenied error - got %#v instead\", err)\n}\n\nfunc (c *check) assertSvcAccS3Access(ctx context.Context, s *TestSuiteIAM, cr madmin.Credentials, bucket string) {\n\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n\tc.mustListObjects(ctx, svcClient, bucket)\n}\n\nfunc (c *check) assertSvcAccAppearsInListing(ctx context.Context, madmClient *madmin.AdminClient, parentAK, svcAK string) {\n\tc.Helper()\n\tlistResp, err := madmClient.ListServiceAccounts(ctx, parentAK)\n\tif err != nil {\n\t\tc.Fatalf(\"unable to list svc accounts: %v\", err)\n\t}\n\tvar accessKeys []string\n\tfor _, item := range listResp.Accounts {\n\t\taccessKeys = append(accessKeys, item.AccessKey)\n\t}\n\tif !set.CreateStringSet(accessKeys...).Contains(svcAK) {\n\t\tc.Fatalf(\"service account did not appear in listing!\")\n\t}\n}\n\nfunc (c *check) assertSvcAccInfoQueryable(ctx context.Context, madmClient *madmin.AdminClient, parentAK, svcAK string, skipParentUserCheck bool) {\n\tinfoResp, err := madmClient.InfoServiceAccount(ctx, svcAK)\n\tif err != nil {\n\t\tc.Fatalf(\"unable to get svc acc info: %v\", err)\n\t}\n\tif !skipParentUserCheck {\n\t\tc.Assert(infoResp.ParentUser, parentAK)\n\t}\n\tc.Assert(infoResp.AccountStatus, \"on\")\n\tc.Assert(infoResp.ImpliedPolicy, true)\n}\n\n// This test assumes that the policy for `accessKey` allows listing on the given\n// bucket. It creates a session policy that restricts listing on the bucket and\n// then enables it again in a session policy update call.\nfunc (c *check) assertSvcAccSessionPolicyUpdate(ctx context.Context, s *TestSuiteIAM, madmClient *madmin.AdminClient, accessKey, bucket string) {\n\tc.Helper()\n\tsvcAK, svcSK := mustGenerateCredentials(c)\n\n\t// This policy does not allow listing objects.\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\tcr, err := madmClient.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n\t\tPolicy:     policyBytes,\n\t\tTargetUser: accessKey,\n\t\tAccessKey:  svcAK,\n\t\tSecretKey:  svcSK,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to create svc acc: %v\", err)\n\t}\n\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n\tc.mustNotListObjects(ctx, svcClient, bucket)\n\n\t// This policy allows listing objects.\n\tnewPolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = madmClient.UpdateServiceAccount(ctx, svcAK, madmin.UpdateServiceAccountReq{\n\t\tNewPolicy: newPolicyBytes,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"unable to update session policy for svc acc: %v\", err)\n\t}\n\tc.mustListObjects(ctx, svcClient, bucket)\n}\n\nfunc (c *check) assertSvcAccSecretKeyAndStatusUpdate(ctx context.Context, s *TestSuiteIAM, madmClient *madmin.AdminClient, accessKey, bucket string) {\n\tc.Helper()\n\tsvcAK, svcSK := mustGenerateCredentials(c)\n\tcr, err := madmClient.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n\t\tTargetUser: accessKey,\n\t\tAccessKey:  svcAK,\n\t\tSecretKey:  svcSK,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to create svc acc: %v\", err)\n\t}\n\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n\tc.mustListObjects(ctx, svcClient, bucket)\n\n\t_, svcSK2 := mustGenerateCredentials(c)\n\terr = madmClient.UpdateServiceAccount(ctx, svcAK, madmin.UpdateServiceAccountReq{\n\t\tNewSecretKey: svcSK2,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"unable to update secret key for svc acc: %v\", err)\n\t}\n\t// old creds should not work:\n\tc.mustNotListObjects(ctx, svcClient, bucket)\n\t// new creds work:\n\tsvcClient2 := s.getUserClient(c, cr.AccessKey, svcSK2, \"\")\n\tc.mustListObjects(ctx, svcClient2, bucket)\n\n\t// update status to disabled\n\terr = madmClient.UpdateServiceAccount(ctx, svcAK, madmin.UpdateServiceAccountReq{\n\t\tNewStatus: \"off\",\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"unable to update secret key for svc acc: %v\", err)\n\t}\n\tc.mustNotListObjects(ctx, svcClient2, bucket)\n}\n\nfunc (c *check) assertSvcAccDeletion(ctx context.Context, s *TestSuiteIAM, madmClient *madmin.AdminClient, accessKey, bucket string) {\n\tc.Helper()\n\tsvcAK, svcSK := mustGenerateCredentials(c)\n\tcr, err := madmClient.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n\t\tTargetUser: accessKey,\n\t\tAccessKey:  svcAK,\n\t\tSecretKey:  svcSK,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to create svc acc: %v\", err)\n\t}\n\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n\tc.mustListObjects(ctx, svcClient, bucket)\n\n\terr = madmClient.DeleteServiceAccount(ctx, svcAK)\n\tif err != nil {\n\t\tc.Fatalf(\"unable to delete svc acc: %v\", err)\n\t}\n\tc.mustNotListObjects(ctx, svcClient, bucket)\n}\n\nfunc mustGenerateCredentials(c *check) (string, string) {\n\tc.Helper()\n\tak, sk, err := auth.GenerateCredentials()\n\tif err != nil {\n\t\tc.Fatalf(\"unable to generate credentials: %v\", err)\n\t}\n\treturn ak, sk\n}\n", "// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/subtle\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"io\"\n\t\"mime\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/minio/minio/internal/auth\"\n\tobjectlock \"github.com/minio/minio/internal/bucket/object/lock\"\n\t\"github.com/minio/minio/internal/etag\"\n\t\"github.com/minio/minio/internal/hash\"\n\txhttp \"github.com/minio/minio/internal/http\"\n\txjwt \"github.com/minio/minio/internal/jwt\"\n\t\"github.com/minio/minio/internal/logger\"\n\t\"github.com/minio/minio/internal/mcontext\"\n\t\"github.com/minio/pkg/v2/policy\"\n)\n\n// Verify if request has JWT.\nfunc isRequestJWT(r *http.Request) bool {\n\treturn strings.HasPrefix(r.Header.Get(xhttp.Authorization), jwtAlgorithm)\n}\n\n// Verify if request has AWS Signature Version '4'.\nfunc isRequestSignatureV4(r *http.Request) bool {\n\treturn strings.HasPrefix(r.Header.Get(xhttp.Authorization), signV4Algorithm)\n}\n\n// Verify if request has AWS Signature Version '2'.\nfunc isRequestSignatureV2(r *http.Request) bool {\n\treturn (!strings.HasPrefix(r.Header.Get(xhttp.Authorization), signV4Algorithm) &&\n\t\tstrings.HasPrefix(r.Header.Get(xhttp.Authorization), signV2Algorithm))\n}\n\n// Verify if request has AWS PreSign Version '4'.\nfunc isRequestPresignedSignatureV4(r *http.Request) bool {\n\t_, ok := r.Form[xhttp.AmzCredential]\n\treturn ok\n}\n\n// Verify request has AWS PreSign Version '2'.\nfunc isRequestPresignedSignatureV2(r *http.Request) bool {\n\t_, ok := r.Form[xhttp.AmzAccessKeyID]\n\treturn ok\n}\n\n// Verify if request has AWS Post policy Signature Version '4'.\nfunc isRequestPostPolicySignatureV4(r *http.Request) bool {\n\tmediaType, _, err := mime.ParseMediaType(r.Header.Get(xhttp.ContentType))\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn mediaType == \"multipart/form-data\" && r.Method == http.MethodPost\n}\n\n// Verify if the request has AWS Streaming Signature Version '4'. This is only valid for 'PUT' operation.\nfunc isRequestSignStreamingV4(r *http.Request) bool {\n\treturn r.Header.Get(xhttp.AmzContentSha256) == streamingContentSHA256 &&\n\t\tr.Method == http.MethodPut\n}\n\n// Verify if the request has AWS Streaming Signature Version '4'. This is only valid for 'PUT' operation.\nfunc isRequestSignStreamingTrailerV4(r *http.Request) bool {\n\treturn r.Header.Get(xhttp.AmzContentSha256) == streamingContentSHA256Trailer &&\n\t\tr.Method == http.MethodPut\n}\n\n// Verify if the request has AWS Streaming Signature Version '4', with unsigned content and trailer.\nfunc isRequestUnsignedTrailerV4(r *http.Request) bool {\n\treturn r.Header.Get(xhttp.AmzContentSha256) == unsignedPayloadTrailer &&\n\t\tr.Method == http.MethodPut && strings.Contains(r.Header.Get(xhttp.ContentEncoding), streamingContentEncoding)\n}\n\n// Authorization type.\n//\n//go:generate stringer -type=authType -trimprefix=authType $GOFILE\ntype authType int\n\n// List of all supported auth types.\nconst (\n\tauthTypeUnknown authType = iota\n\tauthTypeAnonymous\n\tauthTypePresigned\n\tauthTypePresignedV2\n\tauthTypePostPolicy\n\tauthTypeStreamingSigned\n\tauthTypeSigned\n\tauthTypeSignedV2\n\tauthTypeJWT\n\tauthTypeSTS\n\tauthTypeStreamingSignedTrailer\n\tauthTypeStreamingUnsignedTrailer\n)\n\n// Get request authentication type.\nfunc getRequestAuthType(r *http.Request) (at authType) {\n\tif r.URL != nil {\n\t\tvar err error\n\t\tr.Form, err = url.ParseQuery(r.URL.RawQuery)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(r.Context(), err)\n\t\t\treturn authTypeUnknown\n\t\t}\n\t}\n\tif isRequestSignatureV2(r) {\n\t\treturn authTypeSignedV2\n\t} else if isRequestPresignedSignatureV2(r) {\n\t\treturn authTypePresignedV2\n\t} else if isRequestSignStreamingV4(r) {\n\t\treturn authTypeStreamingSigned\n\t} else if isRequestSignStreamingTrailerV4(r) {\n\t\treturn authTypeStreamingSignedTrailer\n\t} else if isRequestUnsignedTrailerV4(r) {\n\t\treturn authTypeStreamingUnsignedTrailer\n\t} else if isRequestSignatureV4(r) {\n\t\treturn authTypeSigned\n\t} else if isRequestPresignedSignatureV4(r) {\n\t\treturn authTypePresigned\n\t} else if isRequestJWT(r) {\n\t\treturn authTypeJWT\n\t} else if isRequestPostPolicySignatureV4(r) {\n\t\treturn authTypePostPolicy\n\t} else if _, ok := r.Form[xhttp.Action]; ok {\n\t\treturn authTypeSTS\n\t} else if _, ok := r.Header[xhttp.Authorization]; !ok {\n\t\treturn authTypeAnonymous\n\t}\n\treturn authTypeUnknown\n}\n\nfunc validateAdminSignature(ctx context.Context, r *http.Request, region string) (auth.Credentials, bool, APIErrorCode) {\n\tvar cred auth.Credentials\n\tvar owner bool\n\ts3Err := ErrAccessDenied\n\tif _, ok := r.Header[xhttp.AmzContentSha256]; ok &&\n\t\tgetRequestAuthType(r) == authTypeSigned {\n\t\t// We only support admin credentials to access admin APIs.\n\t\tcred, owner, s3Err = getReqAccessKeyV4(r, region, serviceS3)\n\t\tif s3Err != ErrNone {\n\t\t\treturn cred, owner, s3Err\n\t\t}\n\n\t\t// we only support V4 (no presign) with auth body\n\t\ts3Err = isReqAuthenticated(ctx, r, region, serviceS3)\n\t}\n\tif s3Err != ErrNone {\n\t\treturn cred, owner, s3Err\n\t}\n\n\tlogger.GetReqInfo(ctx).Cred = cred\n\tlogger.GetReqInfo(ctx).Owner = owner\n\tlogger.GetReqInfo(ctx).Region = globalSite.Region\n\n\treturn cred, owner, ErrNone\n}\n\n// checkAdminRequestAuth checks for authentication and authorization for the incoming\n// request. It only accepts V2 and V4 requests. Presigned, JWT and anonymous requests\n// are automatically rejected.\nfunc checkAdminRequestAuth(ctx context.Context, r *http.Request, action policy.AdminAction, region string) (auth.Credentials, APIErrorCode) {\n\tcred, owner, s3Err := validateAdminSignature(ctx, r, region)\n\tif s3Err != ErrNone {\n\t\treturn cred, s3Err\n\t}\n\tif globalIAMSys.IsAllowed(policy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          policy.Action(action),\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t}) {\n\t\t// Request is allowed return the appropriate access key.\n\t\treturn cred, ErrNone\n\t}\n\n\treturn cred, ErrAccessDenied\n}\n\n// Fetch the security token set by the client.\nfunc getSessionToken(r *http.Request) (token string) {\n\ttoken = r.Header.Get(xhttp.AmzSecurityToken)\n\tif token != \"\" {\n\t\treturn token\n\t}\n\treturn r.Form.Get(xhttp.AmzSecurityToken)\n}\n\n// Fetch claims in the security token returned by the client, doesn't return\n// errors - upon errors the returned claims map will be empty.\nfunc mustGetClaimsFromToken(r *http.Request) map[string]interface{} {\n\tclaims, _ := getClaimsFromToken(getSessionToken(r))\n\treturn claims\n}\n\nfunc getClaimsFromTokenWithSecret(token, secret string) (map[string]interface{}, error) {\n\t// JWT token for x-amz-security-token is signed with admin\n\t// secret key, temporary credentials become invalid if\n\t// server admin credentials change. This is done to ensure\n\t// that clients cannot decode the token using the temp\n\t// secret keys and generate an entirely new claim by essentially\n\t// hijacking the policies. We need to make sure that this is\n\t// based on admin credential such that token cannot be decoded\n\t// on the client side and is treated like an opaque value.\n\tclaims, err := auth.ExtractClaims(token, secret)\n\tif err != nil {\n\t\tif subtle.ConstantTimeCompare([]byte(secret), []byte(globalActiveCred.SecretKey)) == 1 {\n\t\t\treturn nil, errAuthentication\n\t\t}\n\t\tclaims, err = auth.ExtractClaims(token, globalActiveCred.SecretKey)\n\t\tif err != nil {\n\t\t\treturn nil, errAuthentication\n\t\t}\n\t}\n\n\t// If AuthZPlugin is set, return without any further checks.\n\tif newGlobalAuthZPluginFn() != nil {\n\t\treturn claims.Map(), nil\n\t}\n\n\t// Check if a session policy is set. If so, decode it here.\n\tsp, spok := claims.Lookup(policy.SessionPolicyName)\n\tif spok {\n\t\t// Looks like subpolicy is set and is a string, if set then its\n\t\t// base64 encoded, decode it. Decoding fails reject such\n\t\t// requests.\n\t\tspBytes, err := base64.StdEncoding.DecodeString(sp)\n\t\tif err != nil {\n\t\t\t// Base64 decoding fails, we should log to indicate\n\t\t\t// something is malforming the request sent by client.\n\t\t\tlogger.LogIf(GlobalContext, err, logger.Application)\n\t\t\treturn nil, errAuthentication\n\t\t}\n\t\tclaims.MapClaims[sessionPolicyNameExtracted] = string(spBytes)\n\t}\n\n\treturn claims.Map(), nil\n}\n\n// Fetch claims in the security token returned by the client.\nfunc getClaimsFromToken(token string) (map[string]interface{}, error) {\n\treturn getClaimsFromTokenWithSecret(token, globalActiveCred.SecretKey)\n}\n\n// Fetch claims in the security token returned by the client and validate the token.\nfunc checkClaimsFromToken(r *http.Request, cred auth.Credentials) (map[string]interface{}, APIErrorCode) {\n\ttoken := getSessionToken(r)\n\tif token != \"\" && cred.AccessKey == \"\" {\n\t\t// x-amz-security-token is not allowed for anonymous access.\n\t\treturn nil, ErrNoAccessKey\n\t}\n\n\tif token == \"\" && cred.IsTemp() && !cred.IsServiceAccount() {\n\t\t// Temporary credentials should always have x-amz-security-token\n\t\treturn nil, ErrInvalidToken\n\t}\n\n\tif token != \"\" && !cred.IsTemp() {\n\t\t// x-amz-security-token should not present for static credentials.\n\t\treturn nil, ErrInvalidToken\n\t}\n\n\tif !cred.IsServiceAccount() && cred.IsTemp() && subtle.ConstantTimeCompare([]byte(token), []byte(cred.SessionToken)) != 1 {\n\t\t// validate token for temporary credentials only.\n\t\treturn nil, ErrInvalidToken\n\t}\n\n\tsecret := globalActiveCred.SecretKey\n\tif cred.IsServiceAccount() {\n\t\ttoken = cred.SessionToken\n\t\tsecret = cred.SecretKey\n\t}\n\n\tif token != \"\" {\n\t\tclaims, err := getClaimsFromTokenWithSecret(token, secret)\n\t\tif err != nil {\n\t\t\treturn nil, toAPIErrorCode(r.Context(), err)\n\t\t}\n\t\treturn claims, ErrNone\n\t}\n\n\tclaims := xjwt.NewMapClaims()\n\treturn claims.Map(), ErrNone\n}\n\n// Check request auth type verifies the incoming http request\n//   - validates the request signature\n//   - validates the policy action if anonymous tests bucket policies if any,\n//     for authenticated requests validates IAM policies.\n//\n// returns APIErrorCode if any to be replied to the client.\nfunc checkRequestAuthType(ctx context.Context, r *http.Request, action policy.Action, bucketName, objectName string) (s3Err APIErrorCode) {\n\tlogger.GetReqInfo(ctx).BucketName = bucketName\n\tlogger.GetReqInfo(ctx).ObjectName = objectName\n\n\t_, _, s3Err = checkRequestAuthTypeCredential(ctx, r, action)\n\treturn s3Err\n}\n\n// checkRequestAuthTypeWithVID is similar to checkRequestAuthType\n// passes versionID additionally.\nfunc checkRequestAuthTypeWithVID(ctx context.Context, r *http.Request, action policy.Action, bucketName, objectName, versionID string) (s3Err APIErrorCode) {\n\tlogger.GetReqInfo(ctx).BucketName = bucketName\n\tlogger.GetReqInfo(ctx).ObjectName = objectName\n\tlogger.GetReqInfo(ctx).VersionID = versionID\n\n\t_, _, s3Err = checkRequestAuthTypeCredential(ctx, r, action)\n\treturn s3Err\n}\n\nfunc authenticateRequest(ctx context.Context, r *http.Request, action policy.Action) (s3Err APIErrorCode) {\n\tif logger.GetReqInfo(ctx) == nil {\n\t\tlogger.LogIf(ctx, errors.New(\"unexpected context.Context does not have a logger.ReqInfo\"), logger.Minio)\n\t\treturn ErrAccessDenied\n\t}\n\n\tvar cred auth.Credentials\n\tvar owner bool\n\tswitch getRequestAuthType(r) {\n\tcase authTypeUnknown, authTypeStreamingSigned:\n\t\treturn ErrSignatureVersionNotSupported\n\tcase authTypePresignedV2, authTypeSignedV2:\n\t\tif s3Err = isReqAuthenticatedV2(r); s3Err != ErrNone {\n\t\t\treturn s3Err\n\t\t}\n\t\tcred, owner, s3Err = getReqAccessKeyV2(r)\n\tcase authTypeSigned, authTypePresigned:\n\t\tregion := globalSite.Region\n\t\tswitch action {\n\t\tcase policy.GetBucketLocationAction, policy.ListAllMyBucketsAction:\n\t\t\tregion = \"\"\n\t\t}\n\t\tif s3Err = isReqAuthenticated(ctx, r, region, serviceS3); s3Err != ErrNone {\n\t\t\treturn s3Err\n\t\t}\n\t\tcred, owner, s3Err = getReqAccessKeyV4(r, region, serviceS3)\n\t}\n\tif s3Err != ErrNone {\n\t\treturn s3Err\n\t}\n\n\tlogger.GetReqInfo(ctx).Cred = cred\n\tlogger.GetReqInfo(ctx).Owner = owner\n\tlogger.GetReqInfo(ctx).Region = globalSite.Region\n\n\t// region is valid only for CreateBucketAction.\n\tvar region string\n\tif action == policy.CreateBucketAction {\n\t\t// To extract region from XML in request body, get copy of request body.\n\t\tpayload, err := io.ReadAll(io.LimitReader(r.Body, maxLocationConstraintSize))\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, err, logger.Application)\n\t\t\treturn ErrMalformedXML\n\t\t}\n\n\t\t// Populate payload to extract location constraint.\n\t\tr.Body = io.NopCloser(bytes.NewReader(payload))\n\t\tregion, s3Err = parseLocationConstraint(r)\n\t\tif s3Err != ErrNone {\n\t\t\treturn s3Err\n\t\t}\n\n\t\t// Populate payload again to handle it in HTTP handler.\n\t\tr.Body = io.NopCloser(bytes.NewReader(payload))\n\t}\n\n\tlogger.GetReqInfo(ctx).Region = region\n\n\treturn s3Err\n}\n\nfunc authorizeRequest(ctx context.Context, r *http.Request, action policy.Action) (s3Err APIErrorCode) {\n\treqInfo := logger.GetReqInfo(ctx)\n\tif reqInfo == nil {\n\t\treturn ErrAccessDenied\n\t}\n\n\tcred := reqInfo.Cred\n\towner := reqInfo.Owner\n\tregion := reqInfo.Region\n\tbucket := reqInfo.BucketName\n\tobject := reqInfo.ObjectName\n\tversionID := reqInfo.VersionID\n\n\tif action != policy.ListAllMyBucketsAction && cred.AccessKey == \"\" {\n\t\t// Anonymous checks are not meant for ListAllBuckets action\n\t\tif globalPolicySys.IsAllowed(policy.BucketPolicyArgs{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          action,\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, region, auth.AnonymousCredentials),\n\t\t\tIsOwner:         false,\n\t\t\tObjectName:      object,\n\t\t}) {\n\t\t\t// Request is allowed return the appropriate access key.\n\t\t\treturn ErrNone\n\t\t}\n\n\t\tif action == policy.ListBucketVersionsAction {\n\t\t\t// In AWS S3 s3:ListBucket permission is same as s3:ListBucketVersions permission\n\t\t\t// verify as a fallback.\n\t\t\tif globalPolicySys.IsAllowed(policy.BucketPolicyArgs{\n\t\t\t\tAccountName:     cred.AccessKey,\n\t\t\t\tGroups:          cred.Groups,\n\t\t\t\tAction:          policy.ListBucketAction,\n\t\t\t\tBucketName:      bucket,\n\t\t\t\tConditionValues: getConditionValues(r, region, auth.AnonymousCredentials),\n\t\t\t\tIsOwner:         false,\n\t\t\t\tObjectName:      object,\n\t\t\t}) {\n\t\t\t\t// Request is allowed return the appropriate access key.\n\t\t\t\treturn ErrNone\n\t\t\t}\n\t\t}\n\n\t\treturn ErrAccessDenied\n\t}\n\tif action == policy.DeleteObjectAction && versionID != \"\" {\n\t\tif !globalIAMSys.IsAllowed(policy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          policy.Action(policy.DeleteObjectVersionAction),\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\t\tObjectName:      object,\n\t\t\tIsOwner:         owner,\n\t\t\tClaims:          cred.Claims,\n\t\t\tDenyOnly:        true,\n\t\t}) { // Request is not allowed if Deny action on DeleteObjectVersionAction\n\t\t\treturn ErrAccessDenied\n\t\t}\n\t}\n\tif globalIAMSys.IsAllowed(policy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          action,\n\t\tBucketName:      bucket,\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tObjectName:      object,\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t}) {\n\t\t// Request is allowed return the appropriate access key.\n\t\treturn ErrNone\n\t}\n\n\tif action == policy.ListBucketVersionsAction {\n\t\t// In AWS S3 s3:ListBucket permission is same as s3:ListBucketVersions permission\n\t\t// verify as a fallback.\n\t\tif globalIAMSys.IsAllowed(policy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          policy.ListBucketAction,\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\t\tObjectName:      object,\n\t\t\tIsOwner:         owner,\n\t\t\tClaims:          cred.Claims,\n\t\t}) {\n\t\t\t// Request is allowed return the appropriate access key.\n\t\t\treturn ErrNone\n\t\t}\n\t}\n\n\treturn ErrAccessDenied\n}\n\n// Check request auth type verifies the incoming http request\n//   - validates the request signature\n//   - validates the policy action if anonymous tests bucket policies if any,\n//     for authenticated requests validates IAM policies.\n//\n// returns APIErrorCode if any to be replied to the client.\n// Additionally returns the accessKey used in the request, and if this request is by an admin.\nfunc checkRequestAuthTypeCredential(ctx context.Context, r *http.Request, action policy.Action) (cred auth.Credentials, owner bool, s3Err APIErrorCode) {\n\ts3Err = authenticateRequest(ctx, r, action)\n\treqInfo := logger.GetReqInfo(ctx)\n\tif reqInfo == nil {\n\t\treturn cred, owner, ErrAccessDenied\n\t}\n\n\tcred = reqInfo.Cred\n\towner = reqInfo.Owner\n\tif s3Err != ErrNone {\n\t\treturn cred, owner, s3Err\n\t}\n\n\treturn cred, owner, authorizeRequest(ctx, r, action)\n}\n\n// Verify if request has valid AWS Signature Version '2'.\nfunc isReqAuthenticatedV2(r *http.Request) (s3Error APIErrorCode) {\n\tif isRequestSignatureV2(r) {\n\t\treturn doesSignV2Match(r)\n\t}\n\treturn doesPresignV2SignatureMatch(r)\n}\n\nfunc reqSignatureV4Verify(r *http.Request, region string, stype serviceType) (s3Error APIErrorCode) {\n\tsha256sum := getContentSha256Cksum(r, stype)\n\tswitch {\n\tcase isRequestSignatureV4(r):\n\t\treturn doesSignatureMatch(sha256sum, r, region, stype)\n\tcase isRequestPresignedSignatureV4(r):\n\t\treturn doesPresignedSignatureMatch(sha256sum, r, region, stype)\n\tdefault:\n\t\treturn ErrAccessDenied\n\t}\n}\n\n// Verify if request has valid AWS Signature Version '4'.\nfunc isReqAuthenticated(ctx context.Context, r *http.Request, region string, stype serviceType) (s3Error APIErrorCode) {\n\tif errCode := reqSignatureV4Verify(r, region, stype); errCode != ErrNone {\n\t\treturn errCode\n\t}\n\n\tclientETag, err := etag.FromContentMD5(r.Header)\n\tif err != nil {\n\t\treturn ErrInvalidDigest\n\t}\n\n\t// Extract either 'X-Amz-Content-Sha256' header or 'X-Amz-Content-Sha256' query parameter (if V4 presigned)\n\t// Do not verify 'X-Amz-Content-Sha256' if skipSHA256.\n\tvar contentSHA256 []byte\n\tif skipSHA256 := skipContentSha256Cksum(r); !skipSHA256 && isRequestPresignedSignatureV4(r) {\n\t\tif sha256Sum, ok := r.Form[xhttp.AmzContentSha256]; ok && len(sha256Sum) > 0 {\n\t\t\tcontentSHA256, err = hex.DecodeString(sha256Sum[0])\n\t\t\tif err != nil {\n\t\t\t\treturn ErrContentSHA256Mismatch\n\t\t\t}\n\t\t}\n\t} else if _, ok := r.Header[xhttp.AmzContentSha256]; !skipSHA256 && ok {\n\t\tcontentSHA256, err = hex.DecodeString(r.Header.Get(xhttp.AmzContentSha256))\n\t\tif err != nil || len(contentSHA256) == 0 {\n\t\t\treturn ErrContentSHA256Mismatch\n\t\t}\n\t}\n\n\t// Verify 'Content-Md5' and/or 'X-Amz-Content-Sha256' if present.\n\t// The verification happens implicit during reading.\n\treader, err := hash.NewReader(ctx, r.Body, -1, clientETag.String(), hex.EncodeToString(contentSHA256), -1)\n\tif err != nil {\n\t\treturn toAPIErrorCode(ctx, err)\n\t}\n\tr.Body = reader\n\treturn ErrNone\n}\n\n// List of all support S3 auth types.\nvar supportedS3AuthTypes = map[authType]struct{}{\n\tauthTypeAnonymous:                {},\n\tauthTypePresigned:                {},\n\tauthTypePresignedV2:              {},\n\tauthTypeSigned:                   {},\n\tauthTypeSignedV2:                 {},\n\tauthTypePostPolicy:               {},\n\tauthTypeStreamingSigned:          {},\n\tauthTypeStreamingSignedTrailer:   {},\n\tauthTypeStreamingUnsignedTrailer: {},\n}\n\n// Validate if the authType is valid and supported.\nfunc isSupportedS3AuthType(aType authType) bool {\n\t_, ok := supportedS3AuthTypes[aType]\n\treturn ok\n}\n\n// setAuthMiddleware to validate authorization header for the incoming request.\nfunc setAuthMiddleware(h http.Handler) http.Handler {\n\t// handler for validating incoming authorization headers.\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttc, ok := r.Context().Value(mcontext.ContextTraceKey).(*mcontext.TraceCtxt)\n\n\t\taType := getRequestAuthType(r)\n\t\tswitch aType {\n\t\tcase authTypeSigned, authTypeSignedV2, authTypeStreamingSigned, authTypeStreamingSignedTrailer:\n\t\t\t// Verify if date headers are set, if not reject the request\n\t\t\tamzDate, errCode := parseAmzDateHeader(r)\n\t\t\tif errCode != ErrNone {\n\t\t\t\tif ok {\n\t\t\t\t\ttc.FuncName = \"handler.Auth\"\n\t\t\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t\t\t}\n\n\t\t\t\t// All our internal APIs are sensitive towards Date\n\t\t\t\t// header, for all requests where Date header is not\n\t\t\t\t// present we will reject such clients.\n\t\t\t\tdefer logger.AuditLog(r.Context(), w, r, mustGetClaimsFromToken(r))\n\t\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(errCode), r.URL)\n\t\t\t\tatomic.AddUint64(&globalHTTPStats.rejectedRequestsTime, 1)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Verify if the request date header is shifted by less than globalMaxSkewTime parameter in the past\n\t\t\t// or in the future, reject request otherwise.\n\t\t\tcurTime := UTCNow()\n\t\t\tif curTime.Sub(amzDate) > globalMaxSkewTime || amzDate.Sub(curTime) > globalMaxSkewTime {\n\t\t\t\tif ok {\n\t\t\t\t\ttc.FuncName = \"handler.Auth\"\n\t\t\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t\t\t}\n\n\t\t\t\tdefer logger.AuditLog(r.Context(), w, r, mustGetClaimsFromToken(r))\n\t\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrRequestTimeTooSkewed), r.URL)\n\t\t\t\tatomic.AddUint64(&globalHTTPStats.rejectedRequestsTime, 1)\n\t\t\t\treturn\n\t\t\t}\n\t\t\th.ServeHTTP(w, r)\n\t\t\treturn\n\t\tcase authTypeJWT, authTypeSTS:\n\t\t\th.ServeHTTP(w, r)\n\t\t\treturn\n\t\tdefault:\n\t\t\tif isSupportedS3AuthType(aType) {\n\t\t\t\th.ServeHTTP(w, r)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif ok {\n\t\t\ttc.FuncName = \"handler.Auth\"\n\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t}\n\n\t\tdefer logger.AuditLog(r.Context(), w, r, mustGetClaimsFromToken(r))\n\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrSignatureVersionNotSupported), r.URL)\n\t\tatomic.AddUint64(&globalHTTPStats.rejectedRequestsAuth, 1)\n\t})\n}\n\nfunc validateSignature(atype authType, r *http.Request) (auth.Credentials, bool, APIErrorCode) {\n\tvar cred auth.Credentials\n\tvar owner bool\n\tvar s3Err APIErrorCode\n\tswitch atype {\n\tcase authTypeUnknown, authTypeStreamingSigned:\n\t\treturn cred, owner, ErrSignatureVersionNotSupported\n\tcase authTypeSignedV2, authTypePresignedV2:\n\t\tif s3Err = isReqAuthenticatedV2(r); s3Err != ErrNone {\n\t\t\treturn cred, owner, s3Err\n\t\t}\n\t\tcred, owner, s3Err = getReqAccessKeyV2(r)\n\tcase authTypePresigned, authTypeSigned:\n\t\tregion := globalSite.Region\n\t\tif s3Err = isReqAuthenticated(GlobalContext, r, region, serviceS3); s3Err != ErrNone {\n\t\t\treturn cred, owner, s3Err\n\t\t}\n\t\tcred, owner, s3Err = getReqAccessKeyV4(r, region, serviceS3)\n\t}\n\tif s3Err != ErrNone {\n\t\treturn cred, owner, s3Err\n\t}\n\n\treturn cred, owner, ErrNone\n}\n\nfunc isPutRetentionAllowed(bucketName, objectName string, retDays int, retDate time.Time, retMode objectlock.RetMode, byPassSet bool, r *http.Request, cred auth.Credentials, owner bool) (s3Err APIErrorCode) {\n\tvar retSet bool\n\tif cred.AccessKey == \"\" {\n\t\treturn ErrAccessDenied\n\t}\n\n\tconditions := getConditionValues(r, \"\", cred)\n\tconditions[\"object-lock-mode\"] = []string{string(retMode)}\n\tconditions[\"object-lock-retain-until-date\"] = []string{retDate.UTC().Format(time.RFC3339)}\n\tif retDays > 0 {\n\t\tconditions[\"object-lock-remaining-retention-days\"] = []string{strconv.Itoa(retDays)}\n\t}\n\tif retMode == objectlock.RetGovernance && byPassSet {\n\t\tbyPassSet = globalIAMSys.IsAllowed(policy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          policy.BypassGovernanceRetentionAction,\n\t\t\tBucketName:      bucketName,\n\t\t\tObjectName:      objectName,\n\t\t\tConditionValues: conditions,\n\t\t\tIsOwner:         owner,\n\t\t\tClaims:          cred.Claims,\n\t\t})\n\t}\n\tif globalIAMSys.IsAllowed(policy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          policy.PutObjectRetentionAction,\n\t\tBucketName:      bucketName,\n\t\tConditionValues: conditions,\n\t\tObjectName:      objectName,\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t}) {\n\t\tretSet = true\n\t}\n\tif byPassSet || retSet {\n\t\treturn ErrNone\n\t}\n\treturn ErrAccessDenied\n}\n\n// isPutActionAllowed - check if PUT operation is allowed on the resource, this\n// call verifies bucket policies and IAM policies, supports multi user\n// checks etc.\nfunc isPutActionAllowed(ctx context.Context, atype authType, bucketName, objectName string, r *http.Request, action policy.Action) (s3Err APIErrorCode) {\n\tvar cred auth.Credentials\n\tvar owner bool\n\tregion := globalSite.Region\n\tswitch atype {\n\tcase authTypeUnknown:\n\t\treturn ErrSignatureVersionNotSupported\n\tcase authTypeSignedV2, authTypePresignedV2:\n\t\tcred, owner, s3Err = getReqAccessKeyV2(r)\n\tcase authTypeStreamingSigned, authTypePresigned, authTypeSigned, authTypeStreamingSignedTrailer, authTypeStreamingUnsignedTrailer:\n\t\tcred, owner, s3Err = getReqAccessKeyV4(r, region, serviceS3)\n\t}\n\tif s3Err != ErrNone {\n\t\treturn s3Err\n\t}\n\n\tlogger.GetReqInfo(ctx).Cred = cred\n\tlogger.GetReqInfo(ctx).Owner = owner\n\tlogger.GetReqInfo(ctx).Region = region\n\n\t// Do not check for PutObjectRetentionAction permission,\n\t// if mode and retain until date are not set.\n\t// Can happen when bucket has default lock config set\n\tif action == policy.PutObjectRetentionAction &&\n\t\tr.Header.Get(xhttp.AmzObjectLockMode) == \"\" &&\n\t\tr.Header.Get(xhttp.AmzObjectLockRetainUntilDate) == \"\" {\n\t\treturn ErrNone\n\t}\n\n\tif cred.AccessKey == \"\" {\n\t\tif globalPolicySys.IsAllowed(policy.BucketPolicyArgs{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          action,\n\t\t\tBucketName:      bucketName,\n\t\t\tConditionValues: getConditionValues(r, \"\", auth.AnonymousCredentials),\n\t\t\tIsOwner:         false,\n\t\t\tObjectName:      objectName,\n\t\t}) {\n\t\t\treturn ErrNone\n\t\t}\n\t\treturn ErrAccessDenied\n\t}\n\n\tif globalIAMSys.IsAllowed(policy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          action,\n\t\tBucketName:      bucketName,\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tObjectName:      objectName,\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t}) {\n\t\treturn ErrNone\n\t}\n\treturn ErrAccessDenied\n}\n", "// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"path\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/minio/madmin-go/v3\"\n\t\"github.com/minio/minio-go/v7/pkg/set\"\n\t\"github.com/minio/minio/internal/arn\"\n\t\"github.com/minio/minio/internal/auth\"\n\t\"github.com/minio/minio/internal/color\"\n\t\"github.com/minio/minio/internal/config\"\n\txldap \"github.com/minio/minio/internal/config/identity/ldap\"\n\t\"github.com/minio/minio/internal/config/identity/openid\"\n\tidplugin \"github.com/minio/minio/internal/config/identity/plugin\"\n\txtls \"github.com/minio/minio/internal/config/identity/tls\"\n\t\"github.com/minio/minio/internal/config/policy/opa\"\n\tpolplugin \"github.com/minio/minio/internal/config/policy/plugin\"\n\txhttp \"github.com/minio/minio/internal/http\"\n\txioutil \"github.com/minio/minio/internal/ioutil\"\n\t\"github.com/minio/minio/internal/jwt\"\n\t\"github.com/minio/minio/internal/logger\"\n\t\"github.com/minio/pkg/v2/policy\"\n\tetcd \"go.etcd.io/etcd/client/v3\"\n)\n\n// UsersSysType - defines the type of users and groups system that is\n// active on the server.\ntype UsersSysType string\n\n// Types of users configured in the server.\nconst (\n\t// This mode uses the internal users system in MinIO.\n\tMinIOUsersSysType UsersSysType = \"MinIOUsersSys\"\n\n\t// This mode uses users and groups from a configured LDAP\n\t// server.\n\tLDAPUsersSysType UsersSysType = \"LDAPUsersSys\"\n)\n\nconst (\n\tstatusEnabled  = \"enabled\"\n\tstatusDisabled = \"disabled\"\n)\n\nconst (\n\tembeddedPolicyType  = \"embedded-policy\"\n\tinheritedPolicyType = \"inherited-policy\"\n)\n\n// IAMSys - config system.\ntype IAMSys struct {\n\t// Need to keep them here to keep alignment - ref: https://golang.org/pkg/sync/atomic/#pkg-note-BUG\n\t// metrics\n\tLastRefreshTimeUnixNano         uint64\n\tLastRefreshDurationMilliseconds uint64\n\tTotalRefreshSuccesses           uint64\n\tTotalRefreshFailures            uint64\n\n\tsync.Mutex\n\n\tiamRefreshInterval time.Duration\n\n\tLDAPConfig   xldap.Config  // only valid if usersSysType is LDAPUsers\n\tOpenIDConfig openid.Config // only valid if OpenID is configured\n\tSTSTLSConfig xtls.Config   // only valid if STS TLS is configured\n\n\tusersSysType UsersSysType\n\n\trolesMap map[arn.ARN]string\n\n\t// Persistence layer for IAM subsystem\n\tstore *IAMStoreSys\n\n\t// configLoaded will be closed and remain so after first load.\n\tconfigLoaded chan struct{}\n}\n\n// IAMUserType represents a user type inside MinIO server\ntype IAMUserType int\n\nconst (\n\tunknownIAMUserType IAMUserType = iota - 1\n\tregUser\n\tstsUser\n\tsvcUser\n)\n\n// LoadGroup - loads a specific group from storage, and updates the\n// memberships cache. If the specified group does not exist in\n// storage, it is removed from in-memory maps as well - this\n// simplifies the implementation for group removal. This is called\n// only via IAM notifications.\nfunc (sys *IAMSys) LoadGroup(ctx context.Context, objAPI ObjectLayer, group string) error {\n\tif !sys.Initialized() {\n\t\treturn errServerNotInitialized\n\t}\n\n\treturn sys.store.GroupNotificationHandler(ctx, group)\n}\n\n// LoadPolicy - reloads a specific canned policy from backend disks or etcd.\nfunc (sys *IAMSys) LoadPolicy(ctx context.Context, objAPI ObjectLayer, policyName string) error {\n\tif !sys.Initialized() {\n\t\treturn errServerNotInitialized\n\t}\n\n\treturn sys.store.PolicyNotificationHandler(ctx, policyName)\n}\n\n// LoadPolicyMapping - loads the mapped policy for a user or group\n// from storage into server memory.\nfunc (sys *IAMSys) LoadPolicyMapping(ctx context.Context, objAPI ObjectLayer, userOrGroup string, userType IAMUserType, isGroup bool) error {\n\tif !sys.Initialized() {\n\t\treturn errServerNotInitialized\n\t}\n\n\treturn sys.store.PolicyMappingNotificationHandler(ctx, userOrGroup, isGroup, userType)\n}\n\n// LoadUser - reloads a specific user from backend disks or etcd.\nfunc (sys *IAMSys) LoadUser(ctx context.Context, objAPI ObjectLayer, accessKey string, userType IAMUserType) error {\n\tif !sys.Initialized() {\n\t\treturn errServerNotInitialized\n\t}\n\n\treturn sys.store.UserNotificationHandler(ctx, accessKey, userType)\n}\n\n// LoadServiceAccount - reloads a specific service account from backend disks or etcd.\nfunc (sys *IAMSys) LoadServiceAccount(ctx context.Context, accessKey string) error {\n\tif !sys.Initialized() {\n\t\treturn errServerNotInitialized\n\t}\n\n\treturn sys.store.UserNotificationHandler(ctx, accessKey, svcUser)\n}\n\n// initStore initializes IAM stores\nfunc (sys *IAMSys) initStore(objAPI ObjectLayer, etcdClient *etcd.Client) {\n\tif sys.LDAPConfig.Enabled() {\n\t\tsys.SetUsersSysType(LDAPUsersSysType)\n\t}\n\n\tif etcdClient == nil {\n\t\tsys.store = &IAMStoreSys{newIAMObjectStore(objAPI, sys.usersSysType)}\n\t} else {\n\t\tsys.store = &IAMStoreSys{newIAMEtcdStore(etcdClient, sys.usersSysType)}\n\t}\n}\n\n// Initialized checks if IAM is initialized\nfunc (sys *IAMSys) Initialized() bool {\n\tif sys == nil {\n\t\treturn false\n\t}\n\tsys.Lock()\n\tdefer sys.Unlock()\n\treturn sys.store != nil\n}\n\n// Load - loads all credentials, policies and policy mappings.\nfunc (sys *IAMSys) Load(ctx context.Context, firstTime bool) error {\n\tloadStartTime := time.Now()\n\terr := sys.store.LoadIAMCache(ctx, firstTime)\n\tif err != nil {\n\t\tatomic.AddUint64(&sys.TotalRefreshFailures, 1)\n\t\treturn err\n\t}\n\tloadDuration := time.Since(loadStartTime)\n\n\tatomic.StoreUint64(&sys.LastRefreshDurationMilliseconds, uint64(loadDuration.Milliseconds()))\n\tatomic.StoreUint64(&sys.LastRefreshTimeUnixNano, uint64(loadStartTime.Add(loadDuration).UnixNano()))\n\tatomic.AddUint64(&sys.TotalRefreshSuccesses, 1)\n\n\tif firstTime {\n\t\tbootstrapTraceMsg(fmt.Sprintf(\"globalIAMSys.Load(): (duration: %s)\", loadDuration))\n\t}\n\n\tselect {\n\tcase <-sys.configLoaded:\n\tdefault:\n\t\txioutil.SafeClose(sys.configLoaded)\n\t}\n\treturn nil\n}\n\n// Init - initializes config system by reading entries from config/iam\nfunc (sys *IAMSys) Init(ctx context.Context, objAPI ObjectLayer, etcdClient *etcd.Client, iamRefreshInterval time.Duration) {\n\tbootstrapTraceMsg(\"IAM initialization started\")\n\tglobalServerConfigMu.RLock()\n\ts := globalServerConfig\n\tglobalServerConfigMu.RUnlock()\n\n\topenidConfig, err := openid.LookupConfig(s,\n\t\tNewHTTPTransport(), xhttp.DrainBody, globalSite.Region)\n\tif err != nil {\n\t\tlogger.LogIf(ctx, fmt.Errorf(\"Unable to initialize OpenID: %w\", err))\n\t}\n\n\t// Initialize if LDAP is enabled\n\tldapConfig, err := xldap.Lookup(s, globalRootCAs)\n\tif err != nil {\n\t\tlogger.LogIf(ctx, fmt.Errorf(\"Unable to parse LDAP configuration: %w\", err))\n\t}\n\n\tstsTLSConfig, err := xtls.Lookup(s[config.IdentityTLSSubSys][config.Default])\n\tif err != nil {\n\t\tlogger.LogIf(ctx, fmt.Errorf(\"Unable to initialize X.509/TLS STS API: %w\", err))\n\t}\n\n\tif stsTLSConfig.InsecureSkipVerify {\n\t\tlogger.LogIf(ctx, fmt.Errorf(\"CRITICAL: enabling %s is not recommended in a production environment\", xtls.EnvIdentityTLSSkipVerify))\n\t}\n\n\tauthNPluginCfg, err := idplugin.LookupConfig(s[config.IdentityPluginSubSys][config.Default],\n\t\tNewHTTPTransport(), xhttp.DrainBody, globalSite.Region)\n\tif err != nil {\n\t\tlogger.LogIf(ctx, fmt.Errorf(\"Unable to initialize AuthNPlugin: %w\", err))\n\t}\n\n\tsetGlobalAuthNPlugin(idplugin.New(GlobalContext, authNPluginCfg))\n\n\tauthZPluginCfg, err := polplugin.LookupConfig(s, GetDefaultConnSettings(), xhttp.DrainBody)\n\tif err != nil {\n\t\tlogger.LogIf(ctx, fmt.Errorf(\"Unable to initialize AuthZPlugin: %w\", err))\n\t}\n\n\tif authZPluginCfg.URL == nil {\n\t\topaCfg, err := opa.LookupConfig(s[config.PolicyOPASubSys][config.Default],\n\t\t\tNewHTTPTransport(), xhttp.DrainBody)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, fmt.Errorf(\"Unable to initialize AuthZPlugin from legacy OPA config: %w\", err))\n\t\t} else {\n\t\t\tauthZPluginCfg.URL = opaCfg.URL\n\t\t\tauthZPluginCfg.AuthToken = opaCfg.AuthToken\n\t\t\tauthZPluginCfg.Transport = opaCfg.Transport\n\t\t\tauthZPluginCfg.CloseRespFn = opaCfg.CloseRespFn\n\t\t}\n\t}\n\n\tsetGlobalAuthZPlugin(polplugin.New(authZPluginCfg))\n\n\tsys.Lock()\n\tdefer sys.Unlock()\n\n\tsys.LDAPConfig = ldapConfig\n\tsys.OpenIDConfig = openidConfig\n\tsys.STSTLSConfig = stsTLSConfig\n\n\tsys.iamRefreshInterval = iamRefreshInterval\n\n\t// Initialize IAM store\n\tsys.initStore(objAPI, etcdClient)\n\n\tretryCtx, cancel := context.WithCancel(ctx)\n\n\t// Indicate to our routine to exit cleanly upon return.\n\tdefer cancel()\n\n\tr := rand.New(rand.NewSource(time.Now().UnixNano()))\n\n\t// Migrate storage format if needed.\n\tfor {\n\t\t// Migrate IAM configuration, if necessary.\n\t\tif err := saveIAMFormat(retryCtx, sys.store); err != nil {\n\t\t\tif configRetriableErrors(err) {\n\t\t\t\tlogger.Info(\"Waiting for all MinIO IAM sub-system to be initialized.. possible cause (%v)\", err)\n\t\t\t\ttime.Sleep(time.Duration(r.Float64() * float64(time.Second)))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlogger.LogIf(ctx, fmt.Errorf(\"IAM sub-system is partially initialized, unable to write the IAM format: %w\", err))\n\t\t\treturn\n\t\t}\n\n\t\tbreak\n\t}\n\n\t// Load IAM data from storage.\n\tfor {\n\t\tif err := sys.Load(retryCtx, true); err != nil {\n\t\t\tif configRetriableErrors(err) {\n\t\t\t\tlogger.Info(\"Waiting for all MinIO IAM sub-system to be initialized.. possible cause (%v)\", err)\n\t\t\t\ttime.Sleep(time.Duration(r.Float64() * float64(time.Second)))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tlogger.LogIf(ctx, fmt.Errorf(\"Unable to initialize IAM sub-system, some users may not be available: %w\", err))\n\t\t\t}\n\t\t}\n\t\tbreak\n\t}\n\n\trefreshInterval := sys.iamRefreshInterval\n\n\tgo sys.periodicRoutines(ctx, refreshInterval)\n\n\t// Load RoleARNs\n\tsys.rolesMap = make(map[arn.ARN]string)\n\n\t// From OpenID\n\tif riMap := sys.OpenIDConfig.GetRoleInfo(); riMap != nil {\n\t\tsys.validateAndAddRolePolicyMappings(ctx, riMap)\n\t}\n\n\t// From AuthN plugin if enabled.\n\tif authn := newGlobalAuthNPluginFn(); authn != nil {\n\t\triMap := authn.GetRoleInfo()\n\t\tsys.validateAndAddRolePolicyMappings(ctx, riMap)\n\t}\n\n\tsys.printIAMRoles()\n\n\tbootstrapTraceMsg(\"finishing IAM loading\")\n}\n\nfunc (sys *IAMSys) periodicRoutines(ctx context.Context, baseInterval time.Duration) {\n\t// Watch for IAM config changes for iamStorageWatcher.\n\twatcher, isWatcher := sys.store.IAMStorageAPI.(iamStorageWatcher)\n\tif isWatcher {\n\t\tgo func() {\n\t\t\tch := watcher.watch(ctx, iamConfigPrefix)\n\t\t\tfor event := range ch {\n\t\t\t\tif err := sys.loadWatchedEvent(ctx, event); err != nil {\n\t\t\t\t\t// we simply log errors\n\t\t\t\t\tlogger.LogIf(ctx, fmt.Errorf(\"Failure in loading watch event: %v\", err))\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\tr := rand.New(rand.NewSource(time.Now().UnixNano()))\n\t// Add a random interval of up to 20% of the base interval.\n\trandInterval := func() time.Duration {\n\t\treturn time.Duration(r.Float64() * float64(baseInterval) * 0.2)\n\t}\n\n\tvar maxDurationSecondsForLog float64 = 5\n\ttimer := time.NewTimer(baseInterval + randInterval())\n\tdefer timer.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-timer.C:\n\t\t\t// Load all IAM items (except STS creds) periodically.\n\t\t\trefreshStart := time.Now()\n\t\t\tif err := sys.Load(ctx, false); err != nil {\n\t\t\t\tlogger.LogIf(ctx, fmt.Errorf(\"Failure in periodic refresh for IAM (took %.2fs): %v\", time.Since(refreshStart).Seconds(), err))\n\t\t\t} else {\n\t\t\t\ttook := time.Since(refreshStart).Seconds()\n\t\t\t\tif took > maxDurationSecondsForLog {\n\t\t\t\t\t// Log if we took a lot of time to load.\n\t\t\t\t\tlogger.Info(\"IAM refresh took %.2fs\", took)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// The following actions are performed about once in 4 times that\n\t\t\t// IAM is refreshed:\n\t\t\tif r.Intn(4) == 0 {\n\t\t\t\t// Purge expired STS credentials.\n\t\t\t\tpurgeStart := time.Now()\n\t\t\t\tif err := sys.store.PurgeExpiredSTS(ctx); err != nil {\n\t\t\t\t\tlogger.LogIf(ctx, fmt.Errorf(\"Failure in periodic STS purge for IAM (took %.2fs): %v\", time.Since(purgeStart).Seconds(), err))\n\t\t\t\t} else {\n\t\t\t\t\ttook := time.Since(purgeStart).Seconds()\n\t\t\t\t\tif took > maxDurationSecondsForLog {\n\t\t\t\t\t\t// Log if we took a lot of time to load.\n\t\t\t\t\t\tlogger.Info(\"IAM expired STS purge took %.2fs\", took)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Poll and remove accounts for those users who were removed\n\t\t\t\t// from LDAP/OpenID.\n\t\t\t\tif sys.LDAPConfig.Enabled() {\n\t\t\t\t\tsys.purgeExpiredCredentialsForLDAP(ctx)\n\t\t\t\t\tsys.updateGroupMembershipsForLDAP(ctx)\n\t\t\t\t}\n\t\t\t\tif sys.OpenIDConfig.ProviderEnabled() {\n\t\t\t\t\tsys.purgeExpiredCredentialsForExternalSSO(ctx)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttimer.Reset(baseInterval + randInterval())\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (sys *IAMSys) validateAndAddRolePolicyMappings(ctx context.Context, m map[arn.ARN]string) {\n\t// Validate that policies associated with roles are defined. If\n\t// authZ plugin is set, role policies are just claims sent to\n\t// the plugin and they need not exist.\n\t//\n\t// If some mapped policies do not exist, we print some error\n\t// messages but continue any way - they can be fixed in the\n\t// running server by creating the policies after start up.\n\tfor arn, rolePolicies := range m {\n\t\tspecifiedPoliciesSet := newMappedPolicy(rolePolicies).policySet()\n\t\tvalidPolicies, _ := sys.store.FilterPolicies(rolePolicies, \"\")\n\t\tknownPoliciesSet := newMappedPolicy(validPolicies).policySet()\n\t\tunknownPoliciesSet := specifiedPoliciesSet.Difference(knownPoliciesSet)\n\t\tif len(unknownPoliciesSet) > 0 {\n\t\t\tauthz := newGlobalAuthZPluginFn()\n\t\t\tif authz == nil {\n\t\t\t\t// Print a warning that some policies mapped to a role are not defined.\n\t\t\t\terrMsg := fmt.Errorf(\n\t\t\t\t\t\"The policies \\\"%s\\\" mapped to role ARN %s are not defined - this role may not work as expected.\",\n\t\t\t\t\tunknownPoliciesSet.ToSlice(), arn.String())\n\t\t\t\tlogger.LogIf(ctx, errMsg)\n\t\t\t}\n\t\t}\n\t\tsys.rolesMap[arn] = rolePolicies\n\t}\n}\n\n// Prints IAM role ARNs.\nfunc (sys *IAMSys) printIAMRoles() {\n\tif len(sys.rolesMap) == 0 {\n\t\treturn\n\t}\n\tvar arns []string\n\tfor arn := range sys.rolesMap {\n\t\tarns = append(arns, arn.String())\n\t}\n\tsort.Strings(arns)\n\tmsgs := make([]string, 0, len(arns))\n\tfor _, arn := range arns {\n\t\tmsgs = append(msgs, color.Bold(arn))\n\t}\n\n\tlogger.Info(fmt.Sprintf(\"%s %s\", color.Blue(\"IAM Roles:\"), strings.Join(msgs, \" \")))\n}\n\n// HasWatcher - returns if the IAM system has a watcher to be notified of\n// changes.\nfunc (sys *IAMSys) HasWatcher() bool {\n\treturn sys.store.HasWatcher()\n}\n\nfunc (sys *IAMSys) loadWatchedEvent(ctx context.Context, event iamWatchEvent) (err error) {\n\tusersPrefix := strings.HasPrefix(event.keyPath, iamConfigUsersPrefix)\n\tgroupsPrefix := strings.HasPrefix(event.keyPath, iamConfigGroupsPrefix)\n\tstsPrefix := strings.HasPrefix(event.keyPath, iamConfigSTSPrefix)\n\tsvcPrefix := strings.HasPrefix(event.keyPath, iamConfigServiceAccountsPrefix)\n\tpolicyPrefix := strings.HasPrefix(event.keyPath, iamConfigPoliciesPrefix)\n\tpolicyDBUsersPrefix := strings.HasPrefix(event.keyPath, iamConfigPolicyDBUsersPrefix)\n\tpolicyDBSTSUsersPrefix := strings.HasPrefix(event.keyPath, iamConfigPolicyDBSTSUsersPrefix)\n\tpolicyDBGroupsPrefix := strings.HasPrefix(event.keyPath, iamConfigPolicyDBGroupsPrefix)\n\n\tctx, cancel := context.WithTimeout(ctx, defaultContextTimeout)\n\tdefer cancel()\n\n\tswitch {\n\tcase usersPrefix:\n\t\taccessKey := path.Dir(strings.TrimPrefix(event.keyPath, iamConfigUsersPrefix))\n\t\terr = sys.store.UserNotificationHandler(ctx, accessKey, regUser)\n\tcase stsPrefix:\n\t\taccessKey := path.Dir(strings.TrimPrefix(event.keyPath, iamConfigSTSPrefix))\n\t\terr = sys.store.UserNotificationHandler(ctx, accessKey, stsUser)\n\tcase svcPrefix:\n\t\taccessKey := path.Dir(strings.TrimPrefix(event.keyPath, iamConfigServiceAccountsPrefix))\n\t\terr = sys.store.UserNotificationHandler(ctx, accessKey, svcUser)\n\tcase groupsPrefix:\n\t\tgroup := path.Dir(strings.TrimPrefix(event.keyPath, iamConfigGroupsPrefix))\n\t\terr = sys.store.GroupNotificationHandler(ctx, group)\n\tcase policyPrefix:\n\t\tpolicyName := path.Dir(strings.TrimPrefix(event.keyPath, iamConfigPoliciesPrefix))\n\t\terr = sys.store.PolicyNotificationHandler(ctx, policyName)\n\tcase policyDBUsersPrefix:\n\t\tpolicyMapFile := strings.TrimPrefix(event.keyPath, iamConfigPolicyDBUsersPrefix)\n\t\tuser := strings.TrimSuffix(policyMapFile, \".json\")\n\t\terr = sys.store.PolicyMappingNotificationHandler(ctx, user, false, regUser)\n\tcase policyDBSTSUsersPrefix:\n\t\tpolicyMapFile := strings.TrimPrefix(event.keyPath, iamConfigPolicyDBSTSUsersPrefix)\n\t\tuser := strings.TrimSuffix(policyMapFile, \".json\")\n\t\terr = sys.store.PolicyMappingNotificationHandler(ctx, user, false, stsUser)\n\tcase policyDBGroupsPrefix:\n\t\tpolicyMapFile := strings.TrimPrefix(event.keyPath, iamConfigPolicyDBGroupsPrefix)\n\t\tuser := strings.TrimSuffix(policyMapFile, \".json\")\n\t\terr = sys.store.PolicyMappingNotificationHandler(ctx, user, true, regUser)\n\t}\n\treturn err\n}\n\n// HasRolePolicy - returns if a role policy is configured for IAM.\nfunc (sys *IAMSys) HasRolePolicy() bool {\n\treturn len(sys.rolesMap) > 0\n}\n\n// GetRolePolicy - returns policies associated with a role ARN.\nfunc (sys *IAMSys) GetRolePolicy(arnStr string) (arn.ARN, string, error) {\n\troleArn, err := arn.Parse(arnStr)\n\tif err != nil {\n\t\treturn arn.ARN{}, \"\", fmt.Errorf(\"RoleARN parse err: %v\", err)\n\t}\n\trolePolicy, ok := sys.rolesMap[roleArn]\n\tif !ok {\n\t\treturn arn.ARN{}, \"\", fmt.Errorf(\"RoleARN %s is not defined.\", arnStr)\n\t}\n\treturn roleArn, rolePolicy, nil\n}\n\n// DeletePolicy - deletes a canned policy from backend or etcd.\nfunc (sys *IAMSys) DeletePolicy(ctx context.Context, policyName string, notifyPeers bool) error {\n\tif !sys.Initialized() {\n\t\treturn errServerNotInitialized\n\t}\n\n\tfor _, v := range policy.DefaultPolicies {\n\t\tif v.Name == policyName {\n\t\t\tif err := checkConfig(ctx, globalObjectAPI, getPolicyDocPath(policyName)); err != nil && err == errConfigNotFound {\n\t\t\t\treturn fmt.Errorf(\"inbuilt policy `%s` not allowed to be deleted\", policyName)\n\t\t\t}\n\t\t}\n\t}\n\n\terr := sys.store.DeletePolicy(ctx, policyName)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !notifyPeers || sys.HasWatcher() {\n\t\treturn nil\n\t}\n\n\t// Notify all other MinIO peers to delete policy\n\tfor _, nerr := range globalNotificationSys.DeletePolicy(policyName) {\n\t\tif nerr.Err != nil {\n\t\t\tlogger.GetReqInfo(ctx).SetTags(\"peerAddress\", nerr.Host.String())\n\t\t\tlogger.LogIf(ctx, nerr.Err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// InfoPolicy - returns the policy definition with some metadata.\nfunc (sys *IAMSys) InfoPolicy(policyName string) (*madmin.PolicyInfo, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\n\td, err := sys.store.GetPolicyDoc(policyName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpdata, err := json.Marshal(d.Policy)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &madmin.PolicyInfo{\n\t\tPolicyName: policyName,\n\t\tPolicy:     pdata,\n\t\tCreateDate: d.CreateDate,\n\t\tUpdateDate: d.UpdateDate,\n\t}, nil\n}\n\n// ListPolicies - lists all canned policies.\nfunc (sys *IAMSys) ListPolicies(ctx context.Context, bucketName string) (map[string]policy.Policy, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\n\treturn sys.store.ListPolicies(ctx, bucketName)\n}\n\n// ListPolicyDocs - lists all canned policy docs.\nfunc (sys *IAMSys) ListPolicyDocs(ctx context.Context, bucketName string) (map[string]PolicyDoc, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\n\treturn sys.store.ListPolicyDocs(ctx, bucketName)\n}\n\n// SetPolicy - sets a new named policy.\nfunc (sys *IAMSys) SetPolicy(ctx context.Context, policyName string, p policy.Policy) (time.Time, error) {\n\tif !sys.Initialized() {\n\t\treturn time.Time{}, errServerNotInitialized\n\t}\n\n\tupdatedAt, err := sys.store.SetPolicy(ctx, policyName, p)\n\tif err != nil {\n\t\treturn updatedAt, err\n\t}\n\n\tif !sys.HasWatcher() {\n\t\t// Notify all other MinIO peers to reload policy\n\t\tfor _, nerr := range globalNotificationSys.LoadPolicy(policyName) {\n\t\t\tif nerr.Err != nil {\n\t\t\t\tlogger.GetReqInfo(ctx).SetTags(\"peerAddress\", nerr.Host.String())\n\t\t\t\tlogger.LogIf(ctx, nerr.Err)\n\t\t\t}\n\t\t}\n\t}\n\treturn updatedAt, nil\n}\n\n// DeleteUser - delete user (only for long-term users not STS users).\nfunc (sys *IAMSys) DeleteUser(ctx context.Context, accessKey string, notifyPeers bool) error {\n\tif !sys.Initialized() {\n\t\treturn errServerNotInitialized\n\t}\n\n\tif err := sys.store.DeleteUser(ctx, accessKey, regUser); err != nil {\n\t\treturn err\n\t}\n\n\t// Notify all other MinIO peers to delete user.\n\tif notifyPeers && !sys.HasWatcher() {\n\t\tfor _, nerr := range globalNotificationSys.DeleteUser(accessKey) {\n\t\t\tif nerr.Err != nil {\n\t\t\t\tlogger.GetReqInfo(ctx).SetTags(\"peerAddress\", nerr.Host.String())\n\t\t\t\tlogger.LogIf(ctx, nerr.Err)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// CurrentPolicies - returns comma separated policy string, from\n// an input policy after validating if there are any current\n// policies which exist on MinIO corresponding to the input.\nfunc (sys *IAMSys) CurrentPolicies(policyName string) string {\n\tif !sys.Initialized() {\n\t\treturn \"\"\n\t}\n\n\tpolicies, _ := sys.store.FilterPolicies(policyName, \"\")\n\treturn policies\n}\n\nfunc (sys *IAMSys) notifyForUser(ctx context.Context, accessKey string, isTemp bool) {\n\t// Notify all other MinIO peers to reload user.\n\tif !sys.HasWatcher() {\n\t\tfor _, nerr := range globalNotificationSys.LoadUser(accessKey, isTemp) {\n\t\t\tif nerr.Err != nil {\n\t\t\t\tlogger.GetReqInfo(ctx).SetTags(\"peerAddress\", nerr.Host.String())\n\t\t\t\tlogger.LogIf(ctx, nerr.Err)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// SetTempUser - set temporary user credentials, these credentials have an\n// expiry. The permissions for these STS credentials is determined in one of the\n// following ways:\n//\n// - RoleARN - if a role-arn is specified in the request, the STS credential's\n// policy is the role's policy.\n//\n// - inherited from parent - this is the case for AssumeRole API, where the\n// parent user is an actual real user with their own (permanent) credentials and\n// policy association.\n//\n// - inherited from \"virtual\" parent - this is the case for AssumeRoleWithLDAP\n// where the parent user is the DN of the actual LDAP user. The parent user\n// itself cannot login, but the policy associated with them determines the base\n// policy for the STS credential. The policy mapping can be updated by the\n// administrator.\n//\n// - from `Subject.CommonName` field from the STS request for\n// AssumeRoleWithCertificate. In this case, the policy for the STS credential\n// has the same name as the value of this field.\n//\n// - from special JWT claim from STS request for AssumeRoleWithOIDC API (when\n// not using RoleARN). The claim value can be a string or a list and refers to\n// the names of access policies.\n//\n// For all except the RoleARN case, the implementation is the same - the policy\n// for the STS credential is associated with a parent user. For the\n// AssumeRoleWithCertificate case, the \"virtual\" parent user is the value of the\n// `Subject.CommonName` field. For the OIDC (without RoleARN) case the \"virtual\"\n// parent is derived as a concatenation of the `sub` and `iss` fields. The\n// policies applicable to the STS credential are associated with this \"virtual\"\n// parent.\n//\n// When a policyName is given to this function, the policy association is\n// created and stored in the IAM store. Thus, it should NOT be given for the\n// role-arn case (because the role-to-policy mapping is separately stored\n// elsewhere), the AssumeRole case (because the parent user is real and their\n// policy is associated via policy-set API) and the AssumeRoleWithLDAP case\n// (because the policy association is made via policy-set API).\nfunc (sys *IAMSys) SetTempUser(ctx context.Context, accessKey string, cred auth.Credentials, policyName string) (time.Time, error) {\n\tif !sys.Initialized() {\n\t\treturn time.Time{}, errServerNotInitialized\n\t}\n\n\tif newGlobalAuthZPluginFn() != nil {\n\t\t// If OPA is set, we do not need to set a policy mapping.\n\t\tpolicyName = \"\"\n\t}\n\n\tupdatedAt, err := sys.store.SetTempUser(ctx, accessKey, cred, policyName)\n\tif err != nil {\n\t\treturn time.Time{}, err\n\t}\n\n\tsys.notifyForUser(ctx, cred.AccessKey, true)\n\n\treturn updatedAt, nil\n}\n\n// ListBucketUsers - list all users who can access this 'bucket'\nfunc (sys *IAMSys) ListBucketUsers(ctx context.Context, bucket string) (map[string]madmin.UserInfo, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\n\tselect {\n\tcase <-sys.configLoaded:\n\t\treturn sys.store.GetBucketUsers(bucket)\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\t}\n}\n\n// ListUsers - list all users.\nfunc (sys *IAMSys) ListUsers(ctx context.Context) (map[string]madmin.UserInfo, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\tselect {\n\tcase <-sys.configLoaded:\n\t\treturn sys.store.GetUsers(), nil\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\t}\n}\n\n// ListLDAPUsers - list LDAP users which has\nfunc (sys *IAMSys) ListLDAPUsers(ctx context.Context) (map[string]madmin.UserInfo, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\n\tif sys.usersSysType != LDAPUsersSysType {\n\t\treturn nil, errIAMActionNotAllowed\n\t}\n\n\tselect {\n\tcase <-sys.configLoaded:\n\t\tldapUsers := make(map[string]madmin.UserInfo)\n\t\tfor user, policy := range sys.store.GetUsersWithMappedPolicies() {\n\t\t\tldapUsers[user] = madmin.UserInfo{\n\t\t\t\tPolicyName: policy,\n\t\t\t\tStatus:     madmin.AccountEnabled,\n\t\t\t}\n\t\t}\n\t\treturn ldapUsers, nil\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\t}\n}\n\n// QueryLDAPPolicyEntities - queries policy associations for LDAP users/groups/policies.\nfunc (sys *IAMSys) QueryLDAPPolicyEntities(ctx context.Context, q madmin.PolicyEntitiesQuery) (*madmin.PolicyEntitiesResult, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\n\tif !sys.LDAPConfig.Enabled() {\n\t\treturn nil, errIAMActionNotAllowed\n\t}\n\n\tselect {\n\tcase <-sys.configLoaded:\n\t\tpe := sys.store.ListPolicyMappings(q, sys.LDAPConfig.IsLDAPUserDN, sys.LDAPConfig.IsLDAPGroupDN)\n\t\tpe.Timestamp = UTCNow()\n\t\treturn &pe, nil\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\t}\n}\n\n// IsTempUser - returns if given key is a temporary user and parent user.\nfunc (sys *IAMSys) IsTempUser(name string) (bool, string, error) {\n\tif !sys.Initialized() {\n\t\treturn false, \"\", errServerNotInitialized\n\t}\n\n\tu, found := sys.store.GetUser(name)\n\tif !found {\n\t\treturn false, \"\", errNoSuchUser\n\t}\n\tcred := u.Credentials\n\tif cred.IsTemp() {\n\t\treturn true, cred.ParentUser, nil\n\t}\n\n\treturn false, \"\", nil\n}\n\n// IsServiceAccount - returns if given key is a service account\nfunc (sys *IAMSys) IsServiceAccount(name string) (bool, string, error) {\n\tif !sys.Initialized() {\n\t\treturn false, \"\", errServerNotInitialized\n\t}\n\n\tu, found := sys.store.GetUser(name)\n\tif !found {\n\t\treturn false, \"\", errNoSuchUser\n\t}\n\tcred := u.Credentials\n\tif cred.IsServiceAccount() {\n\t\treturn true, cred.ParentUser, nil\n\t}\n\n\treturn false, \"\", nil\n}\n\n// GetUserInfo - get info on a user.\nfunc (sys *IAMSys) GetUserInfo(ctx context.Context, name string) (u madmin.UserInfo, err error) {\n\tif !sys.Initialized() {\n\t\treturn u, errServerNotInitialized\n\t}\n\n\tloadUserCalled := false\n\tselect {\n\tcase <-sys.configLoaded:\n\tdefault:\n\t\tsys.store.LoadUser(ctx, name)\n\t\tloadUserCalled = true\n\t}\n\n\tuserInfo, err := sys.store.GetUserInfo(name)\n\tif err == errNoSuchUser && !loadUserCalled {\n\t\tsys.store.LoadUser(ctx, name)\n\t\tuserInfo, err = sys.store.GetUserInfo(name)\n\t}\n\treturn userInfo, err\n}\n\n// QueryPolicyEntities - queries policy associations for builtin users/groups/policies.\nfunc (sys *IAMSys) QueryPolicyEntities(ctx context.Context, q madmin.PolicyEntitiesQuery) (*madmin.PolicyEntitiesResult, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\n\tselect {\n\tcase <-sys.configLoaded:\n\t\tvar userPredicate, groupPredicate func(string) bool\n\t\tif sys.LDAPConfig.Enabled() {\n\t\t\tuserPredicate = func(s string) bool {\n\t\t\t\treturn !sys.LDAPConfig.IsLDAPUserDN(s)\n\t\t\t}\n\t\t\tgroupPredicate = func(s string) bool {\n\t\t\t\treturn !sys.LDAPConfig.IsLDAPGroupDN(s)\n\t\t\t}\n\t\t}\n\t\tpe := sys.store.ListPolicyMappings(q, userPredicate, groupPredicate)\n\t\tpe.Timestamp = UTCNow()\n\t\treturn &pe, nil\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\t}\n}\n\n// SetUserStatus - sets current user status, supports disabled or enabled.\nfunc (sys *IAMSys) SetUserStatus(ctx context.Context, accessKey string, status madmin.AccountStatus) (updatedAt time.Time, err error) {\n\tif !sys.Initialized() {\n\t\treturn updatedAt, errServerNotInitialized\n\t}\n\n\tif sys.usersSysType != MinIOUsersSysType {\n\t\treturn updatedAt, errIAMActionNotAllowed\n\t}\n\n\tupdatedAt, err = sys.store.SetUserStatus(ctx, accessKey, status)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tsys.notifyForUser(ctx, accessKey, false)\n\treturn updatedAt, nil\n}\n\nfunc (sys *IAMSys) notifyForServiceAccount(ctx context.Context, accessKey string) {\n\t// Notify all other Minio peers to reload the service account\n\tif !sys.HasWatcher() {\n\t\tfor _, nerr := range globalNotificationSys.LoadServiceAccount(accessKey) {\n\t\t\tif nerr.Err != nil {\n\t\t\t\tlogger.GetReqInfo(ctx).SetTags(\"peerAddress\", nerr.Host.String())\n\t\t\t\tlogger.LogIf(ctx, nerr.Err)\n\t\t\t}\n\t\t}\n\t}\n}\n\ntype newServiceAccountOpts struct {\n\tsessionPolicy              *policy.Policy\n\taccessKey                  string\n\tsecretKey                  string\n\tname, description          string\n\texpiration                 *time.Time\n\tallowSiteReplicatorAccount bool // allow creating internal service account for site-replication.\n\n\tclaims map[string]interface{}\n}\n\n// NewServiceAccount - create a new service account\nfunc (sys *IAMSys) NewServiceAccount(ctx context.Context, parentUser string, groups []string, opts newServiceAccountOpts) (auth.Credentials, time.Time, error) {\n\tif !sys.Initialized() {\n\t\treturn auth.Credentials{}, time.Time{}, errServerNotInitialized\n\t}\n\n\tif parentUser == \"\" {\n\t\treturn auth.Credentials{}, time.Time{}, errInvalidArgument\n\t}\n\n\tvar policyBuf []byte\n\tif opts.sessionPolicy != nil {\n\t\terr := opts.sessionPolicy.Validate()\n\t\tif err != nil {\n\t\t\treturn auth.Credentials{}, time.Time{}, err\n\t\t}\n\t\tpolicyBuf, err = json.Marshal(opts.sessionPolicy)\n\t\tif err != nil {\n\t\t\treturn auth.Credentials{}, time.Time{}, err\n\t\t}\n\t\tif len(policyBuf) > 2048 {\n\t\t\treturn auth.Credentials{}, time.Time{}, errSessionPolicyTooLarge\n\t\t}\n\t}\n\n\t// found newly requested service account, to be same as\n\t// parentUser, reject such operations.\n\tif parentUser == opts.accessKey {\n\t\treturn auth.Credentials{}, time.Time{}, errIAMActionNotAllowed\n\t}\n\tif siteReplicatorSvcAcc == opts.accessKey && !opts.allowSiteReplicatorAccount {\n\t\treturn auth.Credentials{}, time.Time{}, errIAMActionNotAllowed\n\t}\n\tm := make(map[string]interface{})\n\tm[parentClaim] = parentUser\n\n\tif len(policyBuf) > 0 {\n\t\tm[policy.SessionPolicyName] = base64.StdEncoding.EncodeToString(policyBuf)\n\t\tm[iamPolicyClaimNameSA()] = embeddedPolicyType\n\t} else {\n\t\tm[iamPolicyClaimNameSA()] = inheritedPolicyType\n\t}\n\n\t// Add all the necessary claims for the service accounts.\n\tfor k, v := range opts.claims {\n\t\t_, ok := m[k]\n\t\tif !ok {\n\t\t\tm[k] = v\n\t\t}\n\t}\n\n\tvar accessKey, secretKey string\n\tvar err error\n\tif len(opts.accessKey) > 0 {\n\t\taccessKey, secretKey = opts.accessKey, opts.secretKey\n\t} else {\n\t\taccessKey, secretKey, err = auth.GenerateCredentials()\n\t\tif err != nil {\n\t\t\treturn auth.Credentials{}, time.Time{}, err\n\t\t}\n\t}\n\tcred, err := auth.CreateNewCredentialsWithMetadata(accessKey, secretKey, m, secretKey)\n\tif err != nil {\n\t\treturn auth.Credentials{}, time.Time{}, err\n\t}\n\tcred.ParentUser = parentUser\n\tcred.Groups = groups\n\tcred.Status = string(auth.AccountOn)\n\tcred.Name = opts.name\n\tcred.Description = opts.description\n\n\tif opts.expiration != nil {\n\t\texpirationInUTC := opts.expiration.UTC()\n\t\tif err := validateSvcExpirationInUTC(expirationInUTC); err != nil {\n\t\t\treturn auth.Credentials{}, time.Time{}, err\n\t\t}\n\t\tcred.Expiration = expirationInUTC\n\t}\n\n\tupdatedAt, err := sys.store.AddServiceAccount(ctx, cred)\n\tif err != nil {\n\t\treturn auth.Credentials{}, time.Time{}, err\n\t}\n\n\tsys.notifyForServiceAccount(ctx, cred.AccessKey)\n\treturn cred, updatedAt, nil\n}\n\ntype updateServiceAccountOpts struct {\n\tsessionPolicy     *policy.Policy\n\tsecretKey         string\n\tstatus            string\n\tname, description string\n\texpiration        *time.Time\n}\n\n// UpdateServiceAccount - edit a service account\nfunc (sys *IAMSys) UpdateServiceAccount(ctx context.Context, accessKey string, opts updateServiceAccountOpts) (updatedAt time.Time, err error) {\n\tif !sys.Initialized() {\n\t\treturn updatedAt, errServerNotInitialized\n\t}\n\n\tupdatedAt, err = sys.store.UpdateServiceAccount(ctx, accessKey, opts)\n\tif err != nil {\n\t\treturn updatedAt, err\n\t}\n\n\tsys.notifyForServiceAccount(ctx, accessKey)\n\treturn updatedAt, nil\n}\n\n// ListServiceAccounts - lists all service accounts associated to a specific user\nfunc (sys *IAMSys) ListServiceAccounts(ctx context.Context, accessKey string) ([]auth.Credentials, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\n\tselect {\n\tcase <-sys.configLoaded:\n\t\treturn sys.store.ListServiceAccounts(ctx, accessKey)\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\t}\n}\n\n// ListTempAccounts - lists all temporary service accounts associated to a specific user\nfunc (sys *IAMSys) ListTempAccounts(ctx context.Context, accessKey string) ([]UserIdentity, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\n\tselect {\n\tcase <-sys.configLoaded:\n\t\treturn sys.store.ListTempAccounts(ctx, accessKey)\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\t}\n}\n\n// ListSTSAccounts - lists all STS accounts associated to a specific user\nfunc (sys *IAMSys) ListSTSAccounts(ctx context.Context, accessKey string) ([]auth.Credentials, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\n\tselect {\n\tcase <-sys.configLoaded:\n\t\treturn sys.store.ListSTSAccounts(ctx, accessKey)\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\t}\n}\n\n// GetServiceAccount - wrapper method to get information about a service account\nfunc (sys *IAMSys) GetServiceAccount(ctx context.Context, accessKey string) (auth.Credentials, *policy.Policy, error) {\n\tsa, embeddedPolicy, err := sys.getServiceAccount(ctx, accessKey)\n\tif err != nil {\n\t\treturn auth.Credentials{}, nil, err\n\t}\n\t// Hide secret & session keys\n\tsa.Credentials.SecretKey = \"\"\n\tsa.Credentials.SessionToken = \"\"\n\treturn sa.Credentials, embeddedPolicy, nil\n}\n\nfunc (sys *IAMSys) getServiceAccount(ctx context.Context, accessKey string) (UserIdentity, *policy.Policy, error) {\n\tsa, jwtClaims, err := sys.getAccountWithClaims(ctx, accessKey)\n\tif err != nil {\n\t\tif err == errNoSuchAccount {\n\t\t\treturn UserIdentity{}, nil, errNoSuchServiceAccount\n\t\t}\n\t\treturn UserIdentity{}, nil, err\n\t}\n\tif !sa.Credentials.IsServiceAccount() {\n\t\treturn UserIdentity{}, nil, errNoSuchServiceAccount\n\t}\n\n\tvar embeddedPolicy *policy.Policy\n\n\tpt, ptok := jwtClaims.Lookup(iamPolicyClaimNameSA())\n\tsp, spok := jwtClaims.Lookup(policy.SessionPolicyName)\n\tif ptok && spok && pt == embeddedPolicyType {\n\t\tpolicyBytes, err := base64.StdEncoding.DecodeString(sp)\n\t\tif err != nil {\n\t\t\treturn UserIdentity{}, nil, err\n\t\t}\n\t\tembeddedPolicy, err = policy.ParseConfig(bytes.NewReader(policyBytes))\n\t\tif err != nil {\n\t\t\treturn UserIdentity{}, nil, err\n\t\t}\n\t}\n\n\treturn sa, embeddedPolicy, nil\n}\n\n// GetTemporaryAccount - wrapper method to get information about a temporary account\nfunc (sys *IAMSys) GetTemporaryAccount(ctx context.Context, accessKey string) (auth.Credentials, *policy.Policy, error) {\n\ttmpAcc, embeddedPolicy, err := sys.getTempAccount(ctx, accessKey)\n\tif err != nil {\n\t\treturn auth.Credentials{}, nil, err\n\t}\n\t// Hide secret & session keys\n\ttmpAcc.Credentials.SecretKey = \"\"\n\ttmpAcc.Credentials.SessionToken = \"\"\n\treturn tmpAcc.Credentials, embeddedPolicy, nil\n}\n\nfunc (sys *IAMSys) getTempAccount(ctx context.Context, accessKey string) (UserIdentity, *policy.Policy, error) {\n\ttmpAcc, claims, err := sys.getAccountWithClaims(ctx, accessKey)\n\tif err != nil {\n\t\tif err == errNoSuchAccount {\n\t\t\treturn UserIdentity{}, nil, errNoSuchTempAccount\n\t\t}\n\t\treturn UserIdentity{}, nil, err\n\t}\n\tif !tmpAcc.Credentials.IsTemp() {\n\t\treturn UserIdentity{}, nil, errNoSuchTempAccount\n\t}\n\n\tvar embeddedPolicy *policy.Policy\n\n\tsp, spok := claims.Lookup(policy.SessionPolicyName)\n\tif spok {\n\t\tpolicyBytes, err := base64.StdEncoding.DecodeString(sp)\n\t\tif err != nil {\n\t\t\treturn UserIdentity{}, nil, err\n\t\t}\n\t\tembeddedPolicy, err = policy.ParseConfig(bytes.NewReader(policyBytes))\n\t\tif err != nil {\n\t\t\treturn UserIdentity{}, nil, err\n\t\t}\n\t}\n\n\treturn tmpAcc, embeddedPolicy, nil\n}\n\n// getAccountWithClaims - gets information about an account with claims\nfunc (sys *IAMSys) getAccountWithClaims(ctx context.Context, accessKey string) (UserIdentity, *jwt.MapClaims, error) {\n\tif !sys.Initialized() {\n\t\treturn UserIdentity{}, nil, errServerNotInitialized\n\t}\n\n\tacc, ok := sys.store.GetUser(accessKey)\n\tif !ok {\n\t\treturn UserIdentity{}, nil, errNoSuchAccount\n\t}\n\n\tjwtClaims, err := extractJWTClaims(acc)\n\tif err != nil {\n\t\treturn UserIdentity{}, nil, err\n\t}\n\n\treturn acc, jwtClaims, nil\n}\n\n// GetClaimsForSvcAcc - gets the claims associated with the service account.\nfunc (sys *IAMSys) GetClaimsForSvcAcc(ctx context.Context, accessKey string) (map[string]interface{}, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\n\tif sys.usersSysType != LDAPUsersSysType {\n\t\treturn nil, nil\n\t}\n\n\tsa, ok := sys.store.GetUser(accessKey)\n\tif !ok || !sa.Credentials.IsServiceAccount() {\n\t\treturn nil, errNoSuchServiceAccount\n\t}\n\n\tjwtClaims, err := extractJWTClaims(sa)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn jwtClaims.Map(), nil\n}\n\n// DeleteServiceAccount - delete a service account\nfunc (sys *IAMSys) DeleteServiceAccount(ctx context.Context, accessKey string, notifyPeers bool) error {\n\tif !sys.Initialized() {\n\t\treturn errServerNotInitialized\n\t}\n\n\tsa, ok := sys.store.GetUser(accessKey)\n\tif !ok || !sa.Credentials.IsServiceAccount() {\n\t\treturn nil\n\t}\n\n\tif err := sys.store.DeleteUser(ctx, accessKey, svcUser); err != nil {\n\t\treturn err\n\t}\n\n\tif notifyPeers && !sys.HasWatcher() {\n\t\tfor _, nerr := range globalNotificationSys.DeleteServiceAccount(accessKey) {\n\t\t\tif nerr.Err != nil {\n\t\t\t\tlogger.GetReqInfo(ctx).SetTags(\"peerAddress\", nerr.Host.String())\n\t\t\t\tlogger.LogIf(ctx, nerr.Err)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// CreateUser - create new user credentials and policy, if user already exists\n// they shall be rewritten with new inputs.\nfunc (sys *IAMSys) CreateUser(ctx context.Context, accessKey string, ureq madmin.AddOrUpdateUserReq) (updatedAt time.Time, err error) {\n\tif !sys.Initialized() {\n\t\treturn updatedAt, errServerNotInitialized\n\t}\n\n\tif sys.usersSysType != MinIOUsersSysType {\n\t\treturn updatedAt, errIAMActionNotAllowed\n\t}\n\n\tif !auth.IsAccessKeyValid(accessKey) {\n\t\treturn updatedAt, auth.ErrInvalidAccessKeyLength\n\t}\n\n\tif !auth.IsSecretKeyValid(ureq.SecretKey) {\n\t\treturn updatedAt, auth.ErrInvalidSecretKeyLength\n\t}\n\n\tupdatedAt, err = sys.store.AddUser(ctx, accessKey, ureq)\n\tif err != nil {\n\t\treturn updatedAt, err\n\t}\n\n\tsys.notifyForUser(ctx, accessKey, false)\n\treturn updatedAt, nil\n}\n\n// SetUserSecretKey - sets user secret key\nfunc (sys *IAMSys) SetUserSecretKey(ctx context.Context, accessKey string, secretKey string) error {\n\tif !sys.Initialized() {\n\t\treturn errServerNotInitialized\n\t}\n\n\tif sys.usersSysType != MinIOUsersSysType {\n\t\treturn errIAMActionNotAllowed\n\t}\n\n\tif !auth.IsAccessKeyValid(accessKey) {\n\t\treturn auth.ErrInvalidAccessKeyLength\n\t}\n\n\tif !auth.IsSecretKeyValid(secretKey) {\n\t\treturn auth.ErrInvalidSecretKeyLength\n\t}\n\n\treturn sys.store.UpdateUserSecretKey(ctx, accessKey, secretKey)\n}\n\n// purgeExpiredCredentialsForExternalSSO - validates if local credentials are still valid\n// by checking remote IDP if the relevant users are still active and present.\nfunc (sys *IAMSys) purgeExpiredCredentialsForExternalSSO(ctx context.Context) {\n\tparentUsersMap := sys.store.GetAllParentUsers()\n\tvar expiredUsers []string\n\tfor parentUser, puInfo := range parentUsersMap {\n\t\t// There are multiple role ARNs for parent user only when there\n\t\t// are multiple openid provider configurations with the same ID\n\t\t// provider. We lookup the provider associated with some one of\n\t\t// the roleARNs to check if the user still exists. If they don't\n\t\t// we can safely remove credentials for this parent user\n\t\t// associated with any of the provider configurations.\n\t\t//\n\t\t// If there is no roleARN mapped to the user, the user may be\n\t\t// coming from a policy claim based openid provider.\n\t\troleArns := puInfo.roleArns.ToSlice()\n\t\tvar roleArn string\n\t\tif len(roleArns) == 0 {\n\t\t\tlogger.LogIf(GlobalContext,\n\t\t\t\tfmt.Errorf(\"parentUser: %s had no roleArns mapped!\", parentUser))\n\t\t\tcontinue\n\t\t}\n\t\troleArn = roleArns[0]\n\t\tu, err := sys.OpenIDConfig.LookupUser(roleArn, puInfo.subClaimValue)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(GlobalContext, err)\n\t\t\tcontinue\n\t\t}\n\t\t// If user is set to \"disabled\", we will remove them\n\t\t// subsequently.\n\t\tif !u.Enabled {\n\t\t\texpiredUsers = append(expiredUsers, parentUser)\n\t\t}\n\t}\n\n\t// We ignore any errors\n\t_ = sys.store.DeleteUsers(ctx, expiredUsers)\n}\n\n// purgeExpiredCredentialsForLDAP - validates if local credentials are still\n// valid by checking LDAP server if the relevant users are still present.\nfunc (sys *IAMSys) purgeExpiredCredentialsForLDAP(ctx context.Context) {\n\tparentUsers := sys.store.GetAllParentUsers()\n\tvar allDistNames []string\n\tfor parentUser := range parentUsers {\n\t\tif !sys.LDAPConfig.IsLDAPUserDN(parentUser) {\n\t\t\tcontinue\n\t\t}\n\n\t\tallDistNames = append(allDistNames, parentUser)\n\t}\n\n\texpiredUsers, err := sys.LDAPConfig.GetNonEligibleUserDistNames(allDistNames)\n\tif err != nil {\n\t\t// Log and return on error - perhaps it'll work the next time.\n\t\tlogger.LogIf(GlobalContext, err)\n\t\treturn\n\t}\n\n\t// We ignore any errors\n\t_ = sys.store.DeleteUsers(ctx, expiredUsers)\n}\n\n// updateGroupMembershipsForLDAP - updates the list of groups associated with the credential.\nfunc (sys *IAMSys) updateGroupMembershipsForLDAP(ctx context.Context) {\n\t// 1. Collect all LDAP users with active creds.\n\tallCreds := sys.store.GetSTSAndServiceAccounts()\n\t// List of unique LDAP (parent) user DNs that have active creds\n\tvar parentUsers []string\n\t// Map of LDAP user to list of active credential objects\n\tparentUserToCredsMap := make(map[string][]auth.Credentials)\n\t// DN to ldap username mapping for each LDAP user\n\tparentUserToLDAPUsernameMap := make(map[string]string)\n\tfor _, cred := range allCreds {\n\t\t// Expired credentials don't need parent user updates.\n\t\tif cred.IsExpired() {\n\t\t\tcontinue\n\t\t}\n\n\t\tif !sys.LDAPConfig.IsLDAPUserDN(cred.ParentUser) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Check if this is the first time we are\n\t\t// encountering this LDAP user.\n\t\tif _, ok := parentUserToCredsMap[cred.ParentUser]; !ok {\n\t\t\t// Try to find the ldapUsername for this\n\t\t\t// parentUser by extracting JWT claims\n\t\t\tvar (\n\t\t\t\tjwtClaims *jwt.MapClaims\n\t\t\t\terr       error\n\t\t\t)\n\n\t\t\tif cred.SessionToken == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif cred.IsServiceAccount() {\n\t\t\t\tjwtClaims, err = auth.ExtractClaims(cred.SessionToken, cred.SecretKey)\n\t\t\t\tif err != nil {\n\t\t\t\t\tjwtClaims, err = auth.ExtractClaims(cred.SessionToken, globalActiveCred.SecretKey)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjwtClaims, err = auth.ExtractClaims(cred.SessionToken, globalActiveCred.SecretKey)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\t// skip this cred - session token seems invalid\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tldapUsername, ok := jwtClaims.Lookup(ldapUserN)\n\t\t\tif !ok {\n\t\t\t\t// skip this cred - we dont have the\n\t\t\t\t// username info needed\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Collect each new cred.ParentUser into parentUsers\n\t\t\tparentUsers = append(parentUsers, cred.ParentUser)\n\n\t\t\t// Update the ldapUsernameMap\n\t\t\tparentUserToLDAPUsernameMap[cred.ParentUser] = ldapUsername\n\t\t}\n\t\tparentUserToCredsMap[cred.ParentUser] = append(parentUserToCredsMap[cred.ParentUser], cred)\n\n\t}\n\n\t// 2. Query LDAP server for groups of the LDAP users collected.\n\tupdatedGroups, err := sys.LDAPConfig.LookupGroupMemberships(parentUsers, parentUserToLDAPUsernameMap)\n\tif err != nil {\n\t\t// Log and return on error - perhaps it'll work the next time.\n\t\tlogger.LogIf(GlobalContext, err)\n\t\treturn\n\t}\n\n\t// 3. Update creds for those users whose groups are changed\n\tfor _, parentUser := range parentUsers {\n\t\tcurrGroupsSet := updatedGroups[parentUser]\n\t\tcurrGroups := currGroupsSet.ToSlice()\n\t\tfor _, cred := range parentUserToCredsMap[parentUser] {\n\t\t\tgSet := set.CreateStringSet(cred.Groups...)\n\t\t\tif gSet.Equals(currGroupsSet) {\n\t\t\t\t// No change to groups memberships for this\n\t\t\t\t// credential.\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Expired credentials don't need group membership updates.\n\t\t\tif cred.IsExpired() {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tcred.Groups = currGroups\n\t\t\tif err := sys.store.UpdateUserIdentity(ctx, cred); err != nil {\n\t\t\t\t// Log and continue error - perhaps it'll work the next time.\n\t\t\t\tlogger.LogIf(GlobalContext, err)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// GetUser - get user credentials\nfunc (sys *IAMSys) GetUser(ctx context.Context, accessKey string) (u UserIdentity, ok bool) {\n\tif !sys.Initialized() {\n\t\treturn u, false\n\t}\n\n\tif accessKey == globalActiveCred.AccessKey {\n\t\treturn newUserIdentity(globalActiveCred), true\n\t}\n\n\tloadUserCalled := false\n\tselect {\n\tcase <-sys.configLoaded:\n\tdefault:\n\t\tsys.store.LoadUser(ctx, accessKey)\n\t\tloadUserCalled = true\n\t}\n\n\tu, ok = sys.store.GetUser(accessKey)\n\tif !ok && !loadUserCalled {\n\t\tsys.store.LoadUser(ctx, accessKey)\n\t\tu, ok = sys.store.GetUser(accessKey)\n\t}\n\n\treturn u, ok && u.Credentials.IsValid()\n}\n\n// Notify all other MinIO peers to load group.\nfunc (sys *IAMSys) notifyForGroup(ctx context.Context, group string) {\n\tif !sys.HasWatcher() {\n\t\tfor _, nerr := range globalNotificationSys.LoadGroup(group) {\n\t\t\tif nerr.Err != nil {\n\t\t\t\tlogger.GetReqInfo(ctx).SetTags(\"peerAddress\", nerr.Host.String())\n\t\t\t\tlogger.LogIf(ctx, nerr.Err)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// AddUsersToGroup - adds users to a group, creating the group if\n// needed. No error if user(s) already are in the group.\nfunc (sys *IAMSys) AddUsersToGroup(ctx context.Context, group string, members []string) (updatedAt time.Time, err error) {\n\tif !sys.Initialized() {\n\t\treturn updatedAt, errServerNotInitialized\n\t}\n\n\tif sys.usersSysType != MinIOUsersSysType {\n\t\treturn updatedAt, errIAMActionNotAllowed\n\t}\n\n\tupdatedAt, err = sys.store.AddUsersToGroup(ctx, group, members)\n\tif err != nil {\n\t\treturn updatedAt, err\n\t}\n\n\tsys.notifyForGroup(ctx, group)\n\treturn updatedAt, nil\n}\n\n// RemoveUsersFromGroup - remove users from group. If no users are\n// given, and the group is empty, deletes the group as well.\nfunc (sys *IAMSys) RemoveUsersFromGroup(ctx context.Context, group string, members []string) (updatedAt time.Time, err error) {\n\tif !sys.Initialized() {\n\t\treturn updatedAt, errServerNotInitialized\n\t}\n\n\tif sys.usersSysType != MinIOUsersSysType {\n\t\treturn updatedAt, errIAMActionNotAllowed\n\t}\n\n\tupdatedAt, err = sys.store.RemoveUsersFromGroup(ctx, group, members)\n\tif err != nil {\n\t\treturn updatedAt, err\n\t}\n\n\tsys.notifyForGroup(ctx, group)\n\treturn updatedAt, nil\n}\n\n// SetGroupStatus - enable/disabled a group\nfunc (sys *IAMSys) SetGroupStatus(ctx context.Context, group string, enabled bool) (updatedAt time.Time, err error) {\n\tif !sys.Initialized() {\n\t\treturn updatedAt, errServerNotInitialized\n\t}\n\n\tif sys.usersSysType != MinIOUsersSysType {\n\t\treturn updatedAt, errIAMActionNotAllowed\n\t}\n\n\tupdatedAt, err = sys.store.SetGroupStatus(ctx, group, enabled)\n\tif err != nil {\n\t\treturn updatedAt, err\n\t}\n\n\tsys.notifyForGroup(ctx, group)\n\treturn updatedAt, nil\n}\n\n// GetGroupDescription - builds up group description\nfunc (sys *IAMSys) GetGroupDescription(group string) (gd madmin.GroupDesc, err error) {\n\tif !sys.Initialized() {\n\t\treturn gd, errServerNotInitialized\n\t}\n\n\treturn sys.store.GetGroupDescription(group)\n}\n\n// ListGroups - lists groups.\nfunc (sys *IAMSys) ListGroups(ctx context.Context) (r []string, err error) {\n\tif !sys.Initialized() {\n\t\treturn r, errServerNotInitialized\n\t}\n\n\tselect {\n\tcase <-sys.configLoaded:\n\t\treturn sys.store.ListGroups(ctx)\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\t}\n}\n\n// PolicyDBSet - sets a policy for a user or group in the PolicyDB - the user doesn't have to exist since sometimes they are virtuals\nfunc (sys *IAMSys) PolicyDBSet(ctx context.Context, name, policy string, userType IAMUserType, isGroup bool) (updatedAt time.Time, err error) {\n\tif !sys.Initialized() {\n\t\treturn updatedAt, errServerNotInitialized\n\t}\n\n\tupdatedAt, err = sys.store.PolicyDBSet(ctx, name, policy, userType, isGroup)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// Notify all other MinIO peers to reload policy\n\tif !sys.HasWatcher() {\n\t\tfor _, nerr := range globalNotificationSys.LoadPolicyMapping(name, userType, isGroup) {\n\t\t\tif nerr.Err != nil {\n\t\t\t\tlogger.GetReqInfo(ctx).SetTags(\"peerAddress\", nerr.Host.String())\n\t\t\t\tlogger.LogIf(ctx, nerr.Err)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn updatedAt, nil\n}\n\n// PolicyDBUpdateBuiltin - adds or removes policies from a user or a group\n// verified to be an internal IDP user.\nfunc (sys *IAMSys) PolicyDBUpdateBuiltin(ctx context.Context, isAttach bool,\n\tr madmin.PolicyAssociationReq,\n) (updatedAt time.Time, addedOrRemoved, effectivePolicies []string, err error) {\n\tif !sys.Initialized() {\n\t\terr = errServerNotInitialized\n\t\treturn\n\t}\n\n\tuserOrGroup := r.User\n\tvar isGroup bool\n\tif userOrGroup == \"\" {\n\t\tisGroup = true\n\t\tuserOrGroup = r.Group\n\t}\n\n\tif isGroup {\n\t\t_, err = sys.GetGroupDescription(userOrGroup)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t} else {\n\t\tvar isTemp bool\n\t\tisTemp, _, err = sys.IsTempUser(userOrGroup)\n\t\tif err != nil && err != errNoSuchUser {\n\t\t\treturn\n\t\t}\n\t\tif isTemp {\n\t\t\terr = errIAMActionNotAllowed\n\t\t\treturn\n\t\t}\n\n\t\t// When the user is root credential you are not allowed to\n\t\t// add policies for root user.\n\t\tif userOrGroup == globalActiveCred.AccessKey {\n\t\t\terr = errIAMActionNotAllowed\n\t\t\treturn\n\t\t}\n\n\t\t// Validate that user exists.\n\t\tvar userExists bool\n\t\t_, userExists = sys.GetUser(ctx, userOrGroup)\n\t\tif !userExists {\n\t\t\terr = errNoSuchUser\n\t\t\treturn\n\t\t}\n\t}\n\n\tupdatedAt, addedOrRemoved, effectivePolicies, err = sys.store.PolicyDBUpdate(ctx, userOrGroup, isGroup,\n\t\tregUser, r.Policies, isAttach)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// Notify all other MinIO peers to reload policy\n\tif !sys.HasWatcher() {\n\t\tfor _, nerr := range globalNotificationSys.LoadPolicyMapping(userOrGroup, regUser, isGroup) {\n\t\t\tif nerr.Err != nil {\n\t\t\t\tlogger.GetReqInfo(ctx).SetTags(\"peerAddress\", nerr.Host.String())\n\t\t\t\tlogger.LogIf(ctx, nerr.Err)\n\t\t\t}\n\t\t}\n\t}\n\n\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemPolicyMapping,\n\t\tPolicyMapping: &madmin.SRPolicyMapping{\n\t\t\tUserOrGroup: userOrGroup,\n\t\t\tUserType:    int(regUser),\n\t\t\tIsGroup:     isGroup,\n\t\t\tPolicy:      strings.Join(effectivePolicies, \",\"),\n\t\t},\n\t\tUpdatedAt: updatedAt,\n\t}))\n\n\treturn\n}\n\n// PolicyDBUpdateLDAP - adds or removes policies from a user or a group verified\n// to be in the LDAP directory.\nfunc (sys *IAMSys) PolicyDBUpdateLDAP(ctx context.Context, isAttach bool,\n\tr madmin.PolicyAssociationReq,\n) (updatedAt time.Time, addedOrRemoved, effectivePolicies []string, err error) {\n\tif !sys.Initialized() {\n\t\terr = errServerNotInitialized\n\t\treturn\n\t}\n\n\tvar dn string\n\tvar isGroup bool\n\tif r.User != \"\" {\n\t\tdn, err = sys.LDAPConfig.DoesUsernameExist(r.User)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, err)\n\t\t\treturn\n\t\t}\n\t\tif dn == \"\" {\n\t\t\t// Still attempt to detach if provided user is a DN.\n\t\t\tif !isAttach && sys.LDAPConfig.IsLDAPUserDN(r.User) {\n\t\t\t\tdn = r.User\n\t\t\t} else {\n\t\t\t\terr = errNoSuchUser\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tisGroup = false\n\t} else {\n\t\tif isAttach {\n\t\t\tvar exists bool\n\t\t\tif exists, err = sys.LDAPConfig.DoesGroupDNExist(r.Group); err != nil {\n\t\t\t\tlogger.LogIf(ctx, err)\n\t\t\t\treturn\n\t\t\t} else if !exists {\n\t\t\t\terr = errNoSuchGroup\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tdn = r.Group\n\t\tisGroup = true\n\t}\n\n\tuserType := stsUser\n\tupdatedAt, addedOrRemoved, effectivePolicies, err = sys.store.PolicyDBUpdate(ctx, dn, isGroup,\n\t\tuserType, r.Policies, isAttach)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// Notify all other MinIO peers to reload policy\n\tif !sys.HasWatcher() {\n\t\tfor _, nerr := range globalNotificationSys.LoadPolicyMapping(dn, userType, isGroup) {\n\t\t\tif nerr.Err != nil {\n\t\t\t\tlogger.GetReqInfo(ctx).SetTags(\"peerAddress\", nerr.Host.String())\n\t\t\t\tlogger.LogIf(ctx, nerr.Err)\n\t\t\t}\n\t\t}\n\t}\n\n\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemPolicyMapping,\n\t\tPolicyMapping: &madmin.SRPolicyMapping{\n\t\t\tUserOrGroup: dn,\n\t\t\tUserType:    int(userType),\n\t\t\tIsGroup:     isGroup,\n\t\t\tPolicy:      strings.Join(effectivePolicies, \",\"),\n\t\t},\n\t\tUpdatedAt: updatedAt,\n\t}))\n\n\treturn\n}\n\n// PolicyDBGet - gets policy set on a user or group. If a list of groups is\n// given, policies associated with them are included as well.\nfunc (sys *IAMSys) PolicyDBGet(name string, groups ...string) ([]string, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\n\treturn sys.store.PolicyDBGet(name, groups...)\n}\n\nconst sessionPolicyNameExtracted = policy.SessionPolicyName + \"-extracted\"\n\n// IsAllowedServiceAccount - checks if the given service account is allowed to perform\n// actions. The permission of the parent user is checked first\nfunc (sys *IAMSys) IsAllowedServiceAccount(args policy.Args, parentUser string) bool {\n\t// Verify if the parent claim matches the parentUser.\n\tp, ok := args.Claims[parentClaim]\n\tif ok {\n\t\tparentInClaim, ok := p.(string)\n\t\tif !ok {\n\t\t\t// Reject malformed/malicious requests.\n\t\t\treturn false\n\t\t}\n\t\t// The parent claim in the session token should be equal\n\t\t// to the parent detected in the backend\n\t\tif parentInClaim != parentUser {\n\t\t\treturn false\n\t\t}\n\t} else {\n\t\t// This is needed so a malicious user cannot\n\t\t// use a leaked session key of another user\n\t\t// to widen its privileges.\n\t\treturn false\n\t}\n\n\tisOwnerDerived := parentUser == globalActiveCred.AccessKey\n\n\tvar err error\n\tvar svcPolicies []string\n\troleArn := args.GetRoleArn()\n\n\tswitch {\n\tcase isOwnerDerived:\n\t\t// All actions are allowed by default and no policy evaluation is\n\t\t// required.\n\n\tcase roleArn != \"\":\n\t\tarn, err := arn.Parse(roleArn)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(GlobalContext, fmt.Errorf(\"error parsing role ARN %s: %v\", roleArn, err))\n\t\t\treturn false\n\t\t}\n\t\tsvcPolicies = newMappedPolicy(sys.rolesMap[arn]).toSlice()\n\n\tdefault:\n\t\t// Check policy for parent user of service account.\n\t\tsvcPolicies, err = sys.PolicyDBGet(parentUser, args.Groups...)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(GlobalContext, err)\n\t\t\treturn false\n\t\t}\n\n\t\t// Finally, if there is no parent policy, check if a policy claim is\n\t\t// present.\n\t\tif len(svcPolicies) == 0 {\n\t\t\tpolicySet, _ := policy.GetPoliciesFromClaims(args.Claims, iamPolicyClaimNameOpenID())\n\t\t\tsvcPolicies = policySet.ToSlice()\n\t\t}\n\t}\n\n\t// Defensive code: Do not allow any operation if no policy is found.\n\tif !isOwnerDerived && len(svcPolicies) == 0 {\n\t\treturn false\n\t}\n\n\tvar combinedPolicy policy.Policy\n\t// Policies were found, evaluate all of them.\n\tif !isOwnerDerived {\n\t\tavailablePoliciesStr, c := sys.store.FilterPolicies(strings.Join(svcPolicies, \",\"), \"\")\n\t\tif availablePoliciesStr == \"\" {\n\t\t\treturn false\n\t\t}\n\t\tcombinedPolicy = c\n\t}\n\n\tparentArgs := args\n\tparentArgs.AccountName = parentUser\n\n\tsaPolicyClaim, ok := args.Claims[iamPolicyClaimNameSA()]\n\tif !ok {\n\t\treturn false\n\t}\n\n\tsaPolicyClaimStr, ok := saPolicyClaim.(string)\n\tif !ok {\n\t\t// Sub policy if set, should be a string reject\n\t\t// malformed/malicious requests.\n\t\treturn false\n\t}\n\n\tif saPolicyClaimStr == inheritedPolicyType {\n\t\treturn isOwnerDerived || combinedPolicy.IsAllowed(parentArgs)\n\t}\n\n\t// Now check if we have a sessionPolicy.\n\tspolicy, ok := args.Claims[sessionPolicyNameExtracted]\n\tif !ok {\n\t\treturn false\n\t}\n\n\tspolicyStr, ok := spolicy.(string)\n\tif !ok {\n\t\t// Sub policy if set, should be a string reject\n\t\t// malformed/malicious requests.\n\t\treturn false\n\t}\n\n\t// Check if policy is parseable.\n\tsubPolicy, err := policy.ParseConfig(bytes.NewReader([]byte(spolicyStr)))\n\tif err != nil {\n\t\t// Log any error in input session policy config.\n\t\tlogger.LogIf(GlobalContext, err)\n\t\treturn false\n\t}\n\n\t// This can only happen if policy was set but with an empty JSON.\n\tif subPolicy.Version == \"\" && len(subPolicy.Statements) == 0 {\n\t\treturn isOwnerDerived || combinedPolicy.IsAllowed(parentArgs)\n\t}\n\n\tif subPolicy.Version == \"\" {\n\t\treturn false\n\t}\n\n\treturn subPolicy.IsAllowed(parentArgs) && (isOwnerDerived || combinedPolicy.IsAllowed(parentArgs))\n}\n\n// IsAllowedSTS is meant for STS based temporary credentials,\n// which implements claims validation and verification other than\n// applying policies.\nfunc (sys *IAMSys) IsAllowedSTS(args policy.Args, parentUser string) bool {\n\t// 1. Determine mapped policies\n\n\tisOwnerDerived := parentUser == globalActiveCred.AccessKey\n\tvar policies []string\n\troleArn := args.GetRoleArn()\n\n\tswitch {\n\tcase isOwnerDerived:\n\t\t// All actions are allowed by default and no policy evaluation is\n\t\t// required.\n\n\tcase roleArn != \"\":\n\t\t// If a roleARN is present, the role policy is applied.\n\t\tarn, err := arn.Parse(roleArn)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(GlobalContext, fmt.Errorf(\"error parsing role ARN %s: %v\", roleArn, err))\n\t\t\treturn false\n\t\t}\n\t\tpolicies = newMappedPolicy(sys.rolesMap[arn]).toSlice()\n\n\tdefault:\n\t\t// Otherwise, inherit parent user's policy\n\t\tvar err error\n\t\tpolicies, err = sys.store.PolicyDBGet(parentUser, args.Groups...)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(GlobalContext, fmt.Errorf(\"error fetching policies on %s: %v\", parentUser, err))\n\t\t\treturn false\n\t\t}\n\n\t\t// Finally, if there is no parent policy, check if a policy claim is\n\t\t// present in the session token.\n\t\tif len(policies) == 0 {\n\t\t\t// If there is no parent policy mapping, we fall back to\n\t\t\t// using policy claim from JWT.\n\t\t\tpolicySet, ok := args.GetPolicies(iamPolicyClaimNameOpenID())\n\t\t\tif !ok {\n\t\t\t\t// When claims are set, it should have a policy claim field.\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tpolicies = policySet.ToSlice()\n\t\t}\n\n\t}\n\n\t// Defensive code: Do not allow any operation if no policy is found in the session token\n\tif !isOwnerDerived && len(policies) == 0 {\n\t\treturn false\n\t}\n\n\t// 2. Combine the mapped policies into a single combined policy.\n\n\tvar combinedPolicy policy.Policy\n\tif !isOwnerDerived {\n\t\tvar err error\n\t\tcombinedPolicy, err = sys.store.GetPolicy(strings.Join(policies, \",\"))\n\t\tif errors.Is(err, errNoSuchPolicy) {\n\t\t\tfor _, pname := range policies {\n\t\t\t\t_, err := sys.store.GetPolicy(pname)\n\t\t\t\tif errors.Is(err, errNoSuchPolicy) {\n\t\t\t\t\t// all policies presented in the claim should exist\n\t\t\t\t\tlogger.LogIf(GlobalContext, fmt.Errorf(\"expected policy (%s) missing from the JWT claim %s, rejecting the request\", pname, iamPolicyClaimNameOpenID()))\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t\tlogger.LogIf(GlobalContext, fmt.Errorf(\"all policies were unexpectedly present!\"))\n\t\t\treturn false\n\t\t}\n\n\t}\n\n\t// 3. If an inline session-policy is present, evaluate it.\n\n\t// Now check if we have a sessionPolicy.\n\thasSessionPolicy, isAllowedSP := isAllowedBySessionPolicy(args)\n\tif hasSessionPolicy {\n\t\treturn isAllowedSP && (isOwnerDerived || combinedPolicy.IsAllowed(args))\n\t}\n\n\t// Sub policy not set, this is most common since subPolicy\n\t// is optional, use the inherited policies.\n\treturn isOwnerDerived || combinedPolicy.IsAllowed(args)\n}\n\nfunc isAllowedBySessionPolicy(args policy.Args) (hasSessionPolicy bool, isAllowed bool) {\n\thasSessionPolicy = false\n\tisAllowed = false\n\n\t// Now check if we have a sessionPolicy.\n\tspolicy, ok := args.Claims[sessionPolicyNameExtracted]\n\tif !ok {\n\t\treturn\n\t}\n\n\thasSessionPolicy = true\n\n\tspolicyStr, ok := spolicy.(string)\n\tif !ok {\n\t\t// Sub policy if set, should be a string reject\n\t\t// malformed/malicious requests.\n\t\treturn\n\t}\n\n\t// Check if policy is parseable.\n\tsubPolicy, err := policy.ParseConfig(bytes.NewReader([]byte(spolicyStr)))\n\tif err != nil {\n\t\t// Log any error in input session policy config.\n\t\tlogger.LogIf(GlobalContext, err)\n\t\treturn\n\t}\n\n\t// Policy without Version string value reject it.\n\tif subPolicy.Version == \"\" {\n\t\treturn\n\t}\n\n\t// Sub policy is set and valid.\n\treturn hasSessionPolicy, subPolicy.IsAllowed(args)\n}\n\n// GetCombinedPolicy returns a combined policy combining all policies\nfunc (sys *IAMSys) GetCombinedPolicy(policies ...string) policy.Policy {\n\t_, policy := sys.store.FilterPolicies(strings.Join(policies, \",\"), \"\")\n\treturn policy\n}\n\n// IsAllowed - checks given policy args is allowed to continue the Rest API.\nfunc (sys *IAMSys) IsAllowed(args policy.Args) bool {\n\t// If opa is configured, use OPA always.\n\tif authz := newGlobalAuthZPluginFn(); authz != nil {\n\t\tok, err := authz.IsAllowed(args)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(GlobalContext, err)\n\t\t}\n\t\treturn ok\n\t}\n\n\t// Policies don't apply to the owner.\n\tif args.IsOwner {\n\t\treturn true\n\t}\n\n\t// If the credential is temporary, perform STS related checks.\n\tok, parentUser, err := sys.IsTempUser(args.AccountName)\n\tif err != nil {\n\t\treturn false\n\t}\n\tif ok {\n\t\treturn sys.IsAllowedSTS(args, parentUser)\n\t}\n\n\t// If the credential is for a service account, perform related check\n\tok, parentUser, err = sys.IsServiceAccount(args.AccountName)\n\tif err != nil {\n\t\treturn false\n\t}\n\tif ok {\n\t\treturn sys.IsAllowedServiceAccount(args, parentUser)\n\t}\n\n\t// Continue with the assumption of a regular user\n\tpolicies, err := sys.PolicyDBGet(args.AccountName, args.Groups...)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tif len(policies) == 0 {\n\t\t// No policy found.\n\t\treturn false\n\t}\n\n\t// Policies were found, evaluate all of them.\n\treturn sys.GetCombinedPolicy(policies...).IsAllowed(args)\n}\n\n// SetUsersSysType - sets the users system type, regular or LDAP.\nfunc (sys *IAMSys) SetUsersSysType(t UsersSysType) {\n\tsys.usersSysType = t\n}\n\n// GetUsersSysType - returns the users system type for this IAM\nfunc (sys *IAMSys) GetUsersSysType() UsersSysType {\n\treturn sys.usersSysType\n}\n\n// NewIAMSys - creates new config system object.\nfunc NewIAMSys() *IAMSys {\n\treturn &IAMSys{\n\t\tusersSysType: MinIOUsersSysType,\n\t\tconfigLoaded: make(chan struct{}),\n\t}\n}\n", "// Copyright (c) 2015-2023 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"crypto/hmac\"\n\t\"encoding/hex\"\n\t\"io\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/minio/minio/internal/auth\"\n\t\"github.com/minio/minio/internal/hash/sha256\"\n\txhttp \"github.com/minio/minio/internal/http\"\n\t\"github.com/minio/minio/internal/logger\"\n\t\"github.com/minio/pkg/v2/policy\"\n\t\"golang.org/x/exp/slices\"\n)\n\n// http Header \"x-amz-content-sha256\" == \"UNSIGNED-PAYLOAD\" indicates that the\n// client did not calculate sha256 of the payload.\nconst unsignedPayload = \"UNSIGNED-PAYLOAD\"\n\n// http Header \"x-amz-content-sha256\" == \"STREAMING-UNSIGNED-PAYLOAD-TRAILER\" indicates that the\n// client did not calculate sha256 of the payload and there is a trailer.\nconst unsignedPayloadTrailer = \"STREAMING-UNSIGNED-PAYLOAD-TRAILER\"\n\n// skipContentSha256Cksum returns true if caller needs to skip\n// payload checksum, false if not.\nfunc skipContentSha256Cksum(r *http.Request) bool {\n\tvar (\n\t\tv  []string\n\t\tok bool\n\t)\n\n\tif isRequestPresignedSignatureV4(r) {\n\t\tv, ok = r.Form[xhttp.AmzContentSha256]\n\t\tif !ok {\n\t\t\tv, ok = r.Header[xhttp.AmzContentSha256]\n\t\t}\n\t} else {\n\t\tv, ok = r.Header[xhttp.AmzContentSha256]\n\t}\n\n\t// Skip if no header was set.\n\tif !ok {\n\t\treturn true\n\t}\n\n\t// If x-amz-content-sha256 is set and the value is not\n\t// 'UNSIGNED-PAYLOAD' we should validate the content sha256.\n\tswitch v[0] {\n\tcase unsignedPayload, unsignedPayloadTrailer:\n\t\treturn true\n\tcase emptySHA256:\n\t\t// some broken clients set empty-sha256\n\t\t// with > 0 content-length in the body,\n\t\t// we should skip such clients and allow\n\t\t// blindly such insecure clients only if\n\t\t// S3 strict compatibility is disabled.\n\n\t\t// We return true only in situations when\n\t\t// deployment has asked MinIO to allow for\n\t\t// such broken clients and content-length > 0.\n\t\treturn r.ContentLength > 0 && !globalServerCtxt.StrictS3Compat\n\t}\n\treturn false\n}\n\n// Returns SHA256 for calculating canonical-request.\nfunc getContentSha256Cksum(r *http.Request, stype serviceType) string {\n\tif stype == serviceSTS {\n\t\tpayload, err := io.ReadAll(io.LimitReader(r.Body, stsRequestBodyLimit))\n\t\tif err != nil {\n\t\t\tlogger.CriticalIf(GlobalContext, err)\n\t\t}\n\t\tsum256 := sha256.Sum256(payload)\n\t\tr.Body = io.NopCloser(bytes.NewReader(payload))\n\t\treturn hex.EncodeToString(sum256[:])\n\t}\n\n\tvar (\n\t\tdefaultSha256Cksum string\n\t\tv                  []string\n\t\tok                 bool\n\t)\n\n\t// For a presigned request we look at the query param for sha256.\n\tif isRequestPresignedSignatureV4(r) {\n\t\t// X-Amz-Content-Sha256, if not set in presigned requests, checksum\n\t\t// will default to 'UNSIGNED-PAYLOAD'.\n\t\tdefaultSha256Cksum = unsignedPayload\n\t\tv, ok = r.Form[xhttp.AmzContentSha256]\n\t\tif !ok {\n\t\t\tv, ok = r.Header[xhttp.AmzContentSha256]\n\t\t}\n\t} else {\n\t\t// X-Amz-Content-Sha256, if not set in signed requests, checksum\n\t\t// will default to sha256([]byte(\"\")).\n\t\tdefaultSha256Cksum = emptySHA256\n\t\tv, ok = r.Header[xhttp.AmzContentSha256]\n\t}\n\n\t// We found 'X-Amz-Content-Sha256' return the captured value.\n\tif ok {\n\t\treturn v[0]\n\t}\n\n\t// We couldn't find 'X-Amz-Content-Sha256'.\n\treturn defaultSha256Cksum\n}\n\n// isValidRegion - verify if incoming region value is valid with configured Region.\nfunc isValidRegion(reqRegion string, confRegion string) bool {\n\tif confRegion == \"\" {\n\t\treturn true\n\t}\n\tif confRegion == \"US\" {\n\t\tconfRegion = globalMinioDefaultRegion\n\t}\n\t// Some older s3 clients set region as \"US\" instead of\n\t// globalMinioDefaultRegion, handle it.\n\tif reqRegion == \"US\" {\n\t\treqRegion = globalMinioDefaultRegion\n\t}\n\treturn reqRegion == confRegion\n}\n\n// check if the access key is valid and recognized, additionally\n// also returns if the access key is owner/admin.\nfunc checkKeyValid(r *http.Request, accessKey string) (auth.Credentials, bool, APIErrorCode) {\n\tcred := globalActiveCred\n\tif cred.AccessKey != accessKey {\n\t\tif !globalIAMSys.Initialized() {\n\t\t\t// Check if server has initialized, then only proceed\n\t\t\t// to check for IAM users otherwise its okay for clients\n\t\t\t// to retry with 503 errors when server is coming up.\n\t\t\treturn auth.Credentials{}, false, ErrServerNotInitialized\n\t\t}\n\n\t\t// Check if the access key is part of users credentials.\n\t\tu, ok := globalIAMSys.GetUser(r.Context(), accessKey)\n\t\tif !ok {\n\t\t\t// Credentials will be invalid but and disabled\n\t\t\t// return a different error in such a scenario.\n\t\t\tif u.Credentials.Status == auth.AccountOff {\n\t\t\t\treturn cred, false, ErrAccessKeyDisabled\n\t\t\t}\n\t\t\treturn cred, false, ErrInvalidAccessKeyID\n\t\t}\n\t\tcred = u.Credentials\n\t}\n\n\tclaims, s3Err := checkClaimsFromToken(r, cred)\n\tif s3Err != ErrNone {\n\t\treturn cred, false, s3Err\n\t}\n\tcred.Claims = claims\n\n\towner := cred.AccessKey == globalActiveCred.AccessKey || (cred.ParentUser == globalActiveCred.AccessKey && cred.AccessKey != siteReplicatorSvcAcc)\n\tif owner && !globalAPIConfig.permitRootAccess() {\n\t\t// We disable root access and its service accounts if asked for.\n\t\treturn cred, owner, ErrAccessKeyDisabled\n\t}\n\n\tif _, ok := claims[policy.SessionPolicyName]; ok {\n\t\towner = false\n\t}\n\n\treturn cred, owner, ErrNone\n}\n\n// sumHMAC calculate hmac between two input byte array.\nfunc sumHMAC(key []byte, data []byte) []byte {\n\thash := hmac.New(sha256.New, key)\n\thash.Write(data)\n\treturn hash.Sum(nil)\n}\n\n// extractSignedHeaders extract signed headers from Authorization header\nfunc extractSignedHeaders(signedHeaders []string, r *http.Request) (http.Header, APIErrorCode) {\n\treqHeaders := r.Header\n\treqQueries := r.Form\n\t// find whether \"host\" is part of list of signed headers.\n\t// if not return ErrUnsignedHeaders. \"host\" is mandatory.\n\tif !slices.Contains(signedHeaders, \"host\") {\n\t\treturn nil, ErrUnsignedHeaders\n\t}\n\textractedSignedHeaders := make(http.Header)\n\tfor _, header := range signedHeaders {\n\t\t// `host` will not be found in the headers, can be found in r.Host.\n\t\t// but its always necessary that the list of signed headers containing host in it.\n\t\tval, ok := reqHeaders[http.CanonicalHeaderKey(header)]\n\t\tif !ok {\n\t\t\t// try to set headers from Query String\n\t\t\tval, ok = reqQueries[header]\n\t\t}\n\t\tif ok {\n\t\t\textractedSignedHeaders[http.CanonicalHeaderKey(header)] = val\n\t\t\tcontinue\n\t\t}\n\t\tswitch header {\n\t\tcase \"expect\":\n\t\t\t// Golang http server strips off 'Expect' header, if the\n\t\t\t// client sent this as part of signed headers we need to\n\t\t\t// handle otherwise we would see a signature mismatch.\n\t\t\t// `aws-cli` sets this as part of signed headers.\n\t\t\t//\n\t\t\t// According to\n\t\t\t// http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.20\n\t\t\t// Expect header is always of form:\n\t\t\t//\n\t\t\t//   Expect       =  \"Expect\" \":\" 1#expectation\n\t\t\t//   expectation  =  \"100-continue\" | expectation-extension\n\t\t\t//\n\t\t\t// So it safe to assume that '100-continue' is what would\n\t\t\t// be sent, for the time being keep this work around.\n\t\t\t// Adding a *TODO* to remove this later when Golang server\n\t\t\t// doesn't filter out the 'Expect' header.\n\t\t\textractedSignedHeaders.Set(header, \"100-continue\")\n\t\tcase \"host\":\n\t\t\t// Go http server removes \"host\" from Request.Header\n\t\t\textractedSignedHeaders.Set(header, r.Host)\n\t\tcase \"transfer-encoding\":\n\t\t\t// Go http server removes \"host\" from Request.Header\n\t\t\textractedSignedHeaders[http.CanonicalHeaderKey(header)] = r.TransferEncoding\n\t\tcase \"content-length\":\n\t\t\t// Signature-V4 spec excludes Content-Length from signed headers list for signature calculation.\n\t\t\t// But some clients deviate from this rule. Hence we consider Content-Length for signature\n\t\t\t// calculation to be compatible with such clients.\n\t\t\textractedSignedHeaders.Set(header, strconv.FormatInt(r.ContentLength, 10))\n\t\tdefault:\n\t\t\treturn nil, ErrUnsignedHeaders\n\t\t}\n\t}\n\treturn extractedSignedHeaders, ErrNone\n}\n\n// Trim leading and trailing spaces and replace sequential spaces with one space, following Trimall()\n// in http://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html\nfunc signV4TrimAll(input string) string {\n\t// Compress adjacent spaces (a space is determined by\n\t// unicode.IsSpace() internally here) to one space and return\n\treturn strings.Join(strings.Fields(input), \" \")\n}\n\n// checkMetaHeaders will check if the metadata from header/url is the same with the one from signed headers\nfunc checkMetaHeaders(signedHeadersMap http.Header, r *http.Request) APIErrorCode {\n\t// check values from http header\n\tfor k, val := range r.Header {\n\t\tif stringsHasPrefixFold(k, \"X-Amz-Meta-\") {\n\t\t\tif signedHeadersMap.Get(k) == val[0] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn ErrUnsignedHeaders\n\t\t}\n\t}\n\n\treturn ErrNone\n}\n", "// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/minio/madmin-go/v3\"\n\tminio \"github.com/minio/minio-go/v7\"\n\tcr \"github.com/minio/minio-go/v7/pkg/credentials\"\n\t\"github.com/minio/minio-go/v7/pkg/set\"\n)\n\nfunc runAllIAMSTSTests(suite *TestSuiteIAM, c *check) {\n\tsuite.SetUpSuite(c)\n\t// The STS for root test needs to be the first one after setup.\n\tsuite.TestSTSForRoot(c)\n\tsuite.TestSTS(c)\n\tsuite.TestSTSWithDenyDeleteVersion(c)\n\tsuite.TestSTSWithTags(c)\n\tsuite.TestSTSServiceAccountsWithUsername(c)\n\tsuite.TestSTSWithGroupPolicy(c)\n\tsuite.TearDownSuite(c)\n}\n\nfunc TestIAMInternalIDPSTSServerSuite(t *testing.T) {\n\tbaseTestCases := []TestSuiteCommon{\n\t\t// Init and run test on ErasureSD backend with signature v4.\n\t\t{serverType: \"ErasureSD\", signer: signerV4},\n\t\t// Init and run test on ErasureSD backend, with tls enabled.\n\t\t{serverType: \"ErasureSD\", signer: signerV4, secure: true},\n\t\t// Init and run test on Erasure backend.\n\t\t{serverType: \"Erasure\", signer: signerV4},\n\t\t// Init and run test on ErasureSet backend.\n\t\t{serverType: \"ErasureSet\", signer: signerV4},\n\t}\n\ttestCases := []*TestSuiteIAM{}\n\tfor _, bt := range baseTestCases {\n\t\ttestCases = append(testCases,\n\t\t\tnewTestSuiteIAM(bt, false),\n\t\t\tnewTestSuiteIAM(bt, true),\n\t\t)\n\t}\n\tfor i, testCase := range testCases {\n\t\tetcdStr := \"\"\n\t\tif testCase.withEtcdBackend {\n\t\t\tetcdStr = \" (with etcd backend)\"\n\t\t}\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s%s\", i+1, testCase.serverType, etcdStr),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\trunAllIAMSTSTests(testCase, &check{t, testCase.serverType})\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestSTSServiceAccountsWithUsername(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := \"dillon-bucket\"\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Create policy\n\tpolicy := \"mypolicy-username\"\n\tpolicyBytes := []byte(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:*\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::${aws:username}-*\"\n   ]\n  }\n ]\n}`)\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tif err = s.adm.AddUser(ctx, \"dillon\", \"dillon-123\"); err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, \"dillon\", false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\tassumeRole := cr.STSAssumeRole{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tOptions: cr.STSAssumeRoleOptions{\n\t\t\tAccessKey: \"dillon\",\n\t\t\tSecretKey: \"dillon-123\",\n\t\t\tLocation:  \"\",\n\t\t},\n\t}\n\n\tvalue, err := assumeRole.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Check that the LDAP sts cred is actually working.\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, value.AccessKeyID, userAdmClient)\n\n\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n\n\t// 1. Check S3 access for service account ListObjects()\n\tc.mustListObjects(ctx, svcClient, bucket)\n\n\t// 2. Check S3 access for upload\n\tc.mustUpload(ctx, svcClient, bucket)\n\n\t// 3. Check S3 access for download\n\tc.mustDownload(ctx, svcClient, bucket)\n}\n\nfunc (s *TestSuiteIAM) TestSTSWithDenyDeleteVersion(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{ObjectLocking: true})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// Create policy, user and associate policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n   {\n    \"Sid\": \"ObjectActionsRW\",\n    \"Effect\": \"Allow\",\n    \"Action\": [\n     \"s3:PutObject\",\n     \"s3:PutObjectTagging\",\n     \"s3:AbortMultipartUpload\",\n     \"s3:DeleteObject\",\n     \"s3:GetObject\",\n     \"s3:GetObjectTagging\",\n     \"s3:GetObjectVersion\",\n     \"s3:ListMultipartUploadParts\"\n    ],\n    \"Resource\": [\n     \"arn:aws:s3:::%s/*\"\n    ]\n   },\n   {\n    \"Sid\": \"DenyDeleteVersionAction\",\n    \"Effect\": \"Deny\",\n    \"Action\": [\n     \"s3:DeleteObjectVersion\"\n    ],\n    \"Resource\": [\n     \"arn:aws:s3:::%s/*\"\n    ]\n   }\n  ]\n }\n`, bucket, bucket))\n\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\t// confirm that the user is able to access the bucket\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tversions := c.mustUploadReturnVersions(ctx, uClient, bucket)\n\tc.mustNotDelete(ctx, uClient, bucket, versions[0])\n\n\tassumeRole := cr.STSAssumeRole{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tOptions: cr.STSAssumeRoleOptions{\n\t\t\tAccessKey: accessKey,\n\t\t\tSecretKey: secretKey,\n\t\t\tLocation:  \"\",\n\t\t},\n\t}\n\n\tvalue, err := assumeRole.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"err calling assumeRole: %v\", err)\n\t}\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\tversions = c.mustUploadReturnVersions(ctx, minioClient, bucket)\n\tc.mustNotDelete(ctx, minioClient, bucket, versions[0])\n}\n\nfunc (s *TestSuiteIAM) TestSTSWithTags(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\tobject := getRandomObjectName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// Create policy, user and associate policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\":     \"Allow\",\n      \"Action\":     \"s3:GetObject\",\n      \"Resource\":    \"arn:aws:s3:::%s/*\",\n      \"Condition\": {  \"StringEquals\": {\"s3:ExistingObjectTag/security\": \"public\" } }\n    },\n    {\n      \"Effect\":     \"Allow\",\n      \"Action\":     \"s3:DeleteObjectTagging\",\n      \"Resource\":    \"arn:aws:s3:::%s/*\",\n      \"Condition\": {  \"StringEquals\": {\"s3:ExistingObjectTag/security\": \"public\" } }\n    },\n    {\n      \"Effect\":     \"Allow\",\n      \"Action\":     \"s3:DeleteObject\",\n      \"Resource\":    \"arn:aws:s3:::%s/*\"\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"s3:PutObject\"\n      ],\n      \"Resource\": [\n        \"arn:aws:s3:::%s/*\"\n      ],\n      \"Condition\": {\n        \"ForAllValues:StringLike\": {\n          \"s3:RequestObjectTagKeys\": [\n            \"security\",\n            \"virus\"\n          ]\n        }\n      }\n    }\n  ]\n}`, bucket, bucket, bucket, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\t// confirm that the user is able to access the bucket\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustPutObjectWithTags(ctx, uClient, bucket, object)\n\tc.mustGetObject(ctx, uClient, bucket, object)\n\n\tassumeRole := cr.STSAssumeRole{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tOptions: cr.STSAssumeRoleOptions{\n\t\t\tAccessKey: accessKey,\n\t\t\tSecretKey: secretKey,\n\t\t\tLocation:  \"\",\n\t\t},\n\t}\n\n\tvalue, err := assumeRole.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"err calling assumeRole: %v\", err)\n\t}\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate sts creds can access the object\n\tc.mustPutObjectWithTags(ctx, minioClient, bucket, object)\n\tc.mustGetObject(ctx, minioClient, bucket, object)\n\tc.mustHeadObject(ctx, minioClient, bucket, object, 2)\n\n\t// Validate that the client can remove objects\n\tif err = minioClient.RemoveObjectTagging(ctx, bucket, object, minio.RemoveObjectTaggingOptions{}); err != nil {\n\t\tc.Fatalf(\"user is unable to delete the object tags: %v\", err)\n\t}\n\n\tif err = minioClient.RemoveObject(ctx, bucket, object, minio.RemoveObjectOptions{}); err != nil {\n\t\tc.Fatalf(\"user is unable to delete the object: %v\", err)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestSTS(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// Create policy, user and associate policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\t// confirm that the user is able to access the bucket\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustListObjects(ctx, uClient, bucket)\n\n\tassumeRole := cr.STSAssumeRole{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tOptions: cr.STSAssumeRoleOptions{\n\t\t\tAccessKey: accessKey,\n\t\t\tSecretKey: secretKey,\n\t\t\tLocation:  \"\",\n\t\t},\n\t}\n\n\tvalue, err := assumeRole.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"err calling assumeRole: %v\", err)\n\t}\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that the client cannot remove any objects\n\terr = minioClient.RemoveObject(ctx, bucket, \"someobject\", minio.RemoveObjectOptions{})\n\tif err.Error() != \"Access Denied.\" {\n\t\tc.Fatalf(\"unexpected non-access-denied err: %v\", err)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestSTSWithGroupPolicy(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// Create policy, user and associate policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\t// confirm that the user is unable to access the bucket - we have not\n\t// yet set any policy\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustNotListObjects(ctx, uClient, bucket)\n\n\terr = s.adm.UpdateGroupMembers(ctx, madmin.GroupAddRemove{\n\t\tGroup:   \"test-group\",\n\t\tMembers: []string{accessKey},\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"unable to add user to group: %v\", err)\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, \"test-group\", true)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\t// confirm that the user is able to access the bucket - permission comes\n\t// from group.\n\tc.mustListObjects(ctx, uClient, bucket)\n\n\t// Create STS user.\n\tassumeRole := cr.STSAssumeRole{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tOptions: cr.STSAssumeRoleOptions{\n\t\t\tAccessKey: accessKey,\n\t\t\tSecretKey: secretKey,\n\t\t\tLocation:  \"\",\n\t\t},\n\t}\n\tvalue, err := assumeRole.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"err calling assumeRole: %v\", err)\n\t}\n\n\t// Check that STS user client has access coming from parent user's\n\t// group.\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that the client cannot remove any objects\n\terr = minioClient.RemoveObject(ctx, bucket, \"someobject\", minio.RemoveObjectOptions{})\n\tif err.Error() != \"Access Denied.\" {\n\t\tc.Fatalf(\"unexpected non-access-denied err: %v\", err)\n\t}\n}\n\n// TestSTSForRoot - needs to be the first test after server setup due to the\n// buckets list check.\nfunc (s *TestSuiteIAM) TestSTSForRoot(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\tassumeRole := cr.STSAssumeRole{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tOptions: cr.STSAssumeRoleOptions{\n\t\t\tAccessKey: globalActiveCred.AccessKey,\n\t\t\tSecretKey: globalActiveCred.SecretKey,\n\t\t\tLocation:  \"\",\n\t\t},\n\t}\n\n\tvalue, err := assumeRole.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"err calling assumeRole: %v\", err)\n\t}\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that a bucket can be created\n\tbucket2 := getRandomBucketName()\n\terr = minioClient.MakeBucket(ctx, bucket2, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// Validate that admin APIs can be called - create an madmin client with\n\t// user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\ttime.Sleep(2 * time.Second) // wait for listbuckets cache to be invalidated\n\n\taccInfo, err := userAdmClient.AccountInfo(ctx, madmin.AccountOpts{})\n\tif err != nil {\n\t\tc.Fatalf(\"root user STS should be able to get account info: %v\", err)\n\t}\n\n\tgotBuckets := set.NewStringSet()\n\tfor _, b := range accInfo.Buckets {\n\t\tgotBuckets.Add(b.Name)\n\t\tif !(b.Access.Read && b.Access.Write) {\n\t\t\tc.Fatalf(\"root user should have read and write access to bucket: %v\", b.Name)\n\t\t}\n\t}\n\tshouldHaveBuckets := set.CreateStringSet(bucket2, bucket)\n\tif !gotBuckets.Equals(shouldHaveBuckets) {\n\t\tc.Fatalf(\"root user should have access to all buckets\")\n\t}\n\n\t// This must fail.\n\tif err := userAdmClient.AddUser(ctx, globalActiveCred.AccessKey, globalActiveCred.SecretKey); err == nil {\n\t\tc.Fatal(\"AddUser() for root credential must fail via root STS creds\")\n\t}\n}\n\n// SetUpLDAP - expects to setup an LDAP test server using the test LDAP\n// container and canned data from https://github.com/minio/minio-ldap-testing\nfunc (s *TestSuiteIAM) SetUpLDAP(c *check, serverAddr string) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tconfigCmds := []string{\n\t\t\"identity_ldap\",\n\t\tfmt.Sprintf(\"server_addr=%s\", serverAddr),\n\t\t\"server_insecure=on\",\n\t\t\"lookup_bind_dn=cn=admin,dc=min,dc=io\",\n\t\t\"lookup_bind_password=admin\",\n\t\t\"user_dn_search_base_dn=dc=min,dc=io\",\n\t\t\"user_dn_search_filter=(uid=%s)\",\n\t\t\"group_search_base_dn=ou=swengg,dc=min,dc=io\",\n\t\t\"group_search_filter=(&(objectclass=groupofnames)(member=%d))\",\n\t}\n\t_, err := s.adm.SetConfigKV(ctx, strings.Join(configCmds, \" \"))\n\tif err != nil {\n\t\tc.Fatalf(\"unable to setup LDAP for tests: %v\", err)\n\t}\n\n\ts.RestartIAMSuite(c)\n}\n\nconst (\n\tEnvTestLDAPServer = \"_MINIO_LDAP_TEST_SERVER\"\n)\n\nfunc TestIAMWithLDAPServerSuite(t *testing.T) {\n\tfor i, testCase := range iamTestSuites {\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s\", i+1, testCase.ServerTypeDescription),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tc := &check{t, testCase.serverType}\n\t\t\t\tsuite := testCase\n\n\t\t\t\tldapServer := os.Getenv(EnvTestLDAPServer)\n\t\t\t\tif ldapServer == \"\" {\n\t\t\t\t\tc.Skip(\"Skipping LDAP test as no LDAP server is provided.\")\n\t\t\t\t}\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tsuite.SetUpLDAP(c, ldapServer)\n\t\t\t\tsuite.TestLDAPSTS(c)\n\t\t\t\tsuite.TestLDAPSTSServiceAccounts(c)\n\t\t\t\tsuite.TestLDAPSTSServiceAccountsWithUsername(c)\n\t\t\t\tsuite.TestLDAPSTSServiceAccountsWithGroups(c)\n\t\t\t\tsuite.TearDownSuite(c)\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestLDAPSTS(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Create policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tldapID := cr.LDAPIdentity{\n\t\tClient:       s.TestSuiteCommon.client,\n\t\tSTSEndpoint:  s.endPoint,\n\t\tLDAPUsername: \"dillon\",\n\t\tLDAPPassword: \"dillon\",\n\t}\n\n\t_, err = ldapID.Retrieve()\n\tif err == nil {\n\t\tc.Fatalf(\"Expected to fail to create STS cred with no associated policy!\")\n\t}\n\n\t// Attempting to set a non-existent policy should fail.\n\tuserDN := \"uid=dillon,ou=people,ou=swengg,dc=min,dc=io\"\n\terr = s.adm.SetPolicy(ctx, policy+\"x\", userDN, false)\n\tif err == nil {\n\t\tc.Fatalf(\"should not be able to set non-existent policy\")\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, userDN, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\tvalue, err := ldapID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that user listing does not return any entries\n\tusersList, err := s.adm.ListUsers(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"list users should not fail: %v\", err)\n\t}\n\tif len(usersList) != 1 {\n\t\tc.Fatalf(\"expected user listing output: %v\", usersList)\n\t}\n\tuinfo := usersList[userDN]\n\tif uinfo.PolicyName != policy || uinfo.Status != madmin.AccountEnabled {\n\t\tc.Fatalf(\"expected user listing content: %v\", uinfo)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that the client cannot remove any objects\n\terr = minioClient.RemoveObject(ctx, bucket, \"someobject\", minio.RemoveObjectOptions{})\n\tif err.Error() != \"Access Denied.\" {\n\t\tc.Fatalf(\"unexpected non-access-denied err: %v\", err)\n\t}\n\n\t// Remove the policy assignment on the user DN:\n\terr = s.adm.SetPolicy(ctx, \"\", userDN, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to remove policy setting: %v\", err)\n\t}\n\n\t_, err = ldapID.Retrieve()\n\tif err == nil {\n\t\tc.Fatalf(\"Expected to fail to create a user with no associated policy!\")\n\t}\n\n\t// Set policy via group and validate policy assignment.\n\tgroupDN := \"cn=projectb,ou=groups,ou=swengg,dc=min,dc=io\"\n\terr = s.adm.SetPolicy(ctx, policy, groupDN, true)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set group policy: %v\", err)\n\t}\n\n\tvalue, err = ldapID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\tminioClient, err = minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that the client cannot remove any objects\n\terr = minioClient.RemoveObject(ctx, bucket, \"someobject\", minio.RemoveObjectOptions{})\n\tc.Assert(err.Error(), \"Access Denied.\")\n}\n\nfunc (s *TestSuiteIAM) TestLDAPSTSServiceAccounts(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Create policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tuserDN := \"uid=dillon,ou=people,ou=swengg,dc=min,dc=io\"\n\terr = s.adm.SetPolicy(ctx, policy, userDN, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\tldapID := cr.LDAPIdentity{\n\t\tClient:       s.TestSuiteCommon.client,\n\t\tSTSEndpoint:  s.endPoint,\n\t\tLDAPUsername: \"dillon\",\n\t\tLDAPPassword: \"dillon\",\n\t}\n\n\tvalue, err := ldapID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Check that the LDAP sts cred is actually working.\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, value.AccessKeyID, userAdmClient)\n\n\t// 1. Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey)\n\n\t// 2. Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey, true)\n\n\t// 3. Check S3 access\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// 4. Check that svc account can restrict the policy, and that the\n\t// session policy can be updated.\n\tc.assertSvcAccSessionPolicyUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 4. Check that service account's secret key and account status can be\n\t// updated.\n\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 6. Check that service account cannot be created for some other user.\n\tc.mustNotCreateSvcAccount(ctx, globalActiveCred.AccessKey, userAdmClient)\n}\n\nfunc (s *TestSuiteIAM) TestLDAPSTSServiceAccountsWithUsername(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := \"dillon\"\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Create policy\n\tpolicy := \"mypolicy-username\"\n\tpolicyBytes := []byte(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::${ldap:username}/*\"\n   ]\n  }\n ]\n}`)\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tuserDN := \"uid=dillon,ou=people,ou=swengg,dc=min,dc=io\"\n\terr = s.adm.SetPolicy(ctx, policy, userDN, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\tldapID := cr.LDAPIdentity{\n\t\tClient:       s.TestSuiteCommon.client,\n\t\tSTSEndpoint:  s.endPoint,\n\t\tLDAPUsername: \"dillon\",\n\t\tLDAPPassword: \"dillon\",\n\t}\n\n\tvalue, err := ldapID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Check that the LDAP sts cred is actually working.\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, value.AccessKeyID, userAdmClient)\n\n\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n\n\t// 1. Check S3 access for service account ListObjects()\n\tc.mustListObjects(ctx, svcClient, bucket)\n\n\t// 2. Check S3 access for upload\n\tc.mustUpload(ctx, svcClient, bucket)\n\n\t// 3. Check S3 access for download\n\tc.mustDownload(ctx, svcClient, bucket)\n}\n\n// In this test, the parent users gets their permissions from a group, rather\n// than having a policy set directly on them.\nfunc (s *TestSuiteIAM) TestLDAPSTSServiceAccountsWithGroups(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Create policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tgroupDN := \"cn=projecta,ou=groups,ou=swengg,dc=min,dc=io\"\n\terr = s.adm.SetPolicy(ctx, policy, groupDN, true)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\tldapID := cr.LDAPIdentity{\n\t\tClient:       s.TestSuiteCommon.client,\n\t\tSTSEndpoint:  s.endPoint,\n\t\tLDAPUsername: \"dillon\",\n\t\tLDAPPassword: \"dillon\",\n\t}\n\n\tvalue, err := ldapID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Check that the LDAP sts cred is actually working.\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, value.AccessKeyID, userAdmClient)\n\n\t// 1. Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey)\n\n\t// 2. Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey, true)\n\n\t// 3. Check S3 access\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// 4. Check that svc account can restrict the policy, and that the\n\t// session policy can be updated.\n\tc.assertSvcAccSessionPolicyUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 4. Check that service account's secret key and account status can be\n\t// updated.\n\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 6. Check that service account cannot be created for some other user.\n\tc.mustNotCreateSvcAccount(ctx, globalActiveCred.AccessKey, userAdmClient)\n}\n\nfunc (s *TestSuiteIAM) TestOpenIDSTS(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Generate web identity STS token by interacting with OpenID IDP.\n\ttoken, err := MockOpenIDTestUserInteraction(ctx, testAppParams, \"dillon@example.io\", \"dillon\")\n\tif err != nil {\n\t\tc.Fatalf(\"mock user err: %v\", err)\n\t}\n\t// fmt.Printf(\"TOKEN: %s\\n\", token)\n\n\twebID := cr.STSWebIdentity{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\tToken: token,\n\t\t\t}, nil\n\t\t},\n\t}\n\n\t// Create policy - with name as one of the groups in OpenID the user is\n\t// a member of.\n\tpolicy := \"projecta\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tvalue, err := webID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that the client cannot remove any objects\n\terr = minioClient.RemoveObject(ctx, bucket, \"someobject\", minio.RemoveObjectOptions{})\n\tif err.Error() != \"Access Denied.\" {\n\t\tc.Fatalf(\"unexpected non-access-denied err: %v\", err)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestOpenIDSTSAddUser(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Generate web identity STS token by interacting with OpenID IDP.\n\ttoken, err := MockOpenIDTestUserInteraction(ctx, testAppParams, \"dillon@example.io\", \"dillon\")\n\tif err != nil {\n\t\tc.Fatalf(\"mock user err: %v\", err)\n\t}\n\n\twebID := cr.STSWebIdentity{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\tToken: token,\n\t\t\t}, nil\n\t\t},\n\t}\n\n\t// Create policy - with name as one of the groups in OpenID the user is\n\t// a member of.\n\tpolicy := \"projecta\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tvalue, err := webID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\tc.mustNotCreateIAMUser(ctx, userAdmClient)\n\n\t// Create admin user policy.\n\tpolicyBytes = []byte(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"admin:*\"\n   ]\n  }\n ]\n}`)\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tcr := c.mustCreateIAMUser(ctx, userAdmClient)\n\n\tuserInfo := c.mustGetIAMUserInfo(ctx, userAdmClient, cr.AccessKey)\n\tc.Assert(userInfo.Status, madmin.AccountEnabled)\n}\n\nfunc (s *TestSuiteIAM) TestOpenIDServiceAcc(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Generate web identity STS token by interacting with OpenID IDP.\n\ttoken, err := MockOpenIDTestUserInteraction(ctx, testAppParams, \"dillon@example.io\", \"dillon\")\n\tif err != nil {\n\t\tc.Fatalf(\"mock user err: %v\", err)\n\t}\n\n\twebID := cr.STSWebIdentity{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\tToken: token,\n\t\t\t}, nil\n\t\t},\n\t}\n\n\t// Create policy - with name as one of the groups in OpenID the user is\n\t// a member of.\n\tpolicy := \"projecta\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tvalue, err := webID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, value.AccessKeyID, userAdmClient)\n\n\t// 1. Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey)\n\n\t// 2. Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey, true)\n\n\t// 3. Check S3 access\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// 4. Check that svc account can restrict the policy, and that the\n\t// session policy can be updated.\n\tc.assertSvcAccSessionPolicyUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 4. Check that service account's secret key and account status can be\n\t// updated.\n\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 6. Check that service account cannot be created for some other user.\n\tc.mustNotCreateSvcAccount(ctx, globalActiveCred.AccessKey, userAdmClient)\n}\n\nvar testAppParams = OpenIDClientAppParams{\n\tClientID:     \"minio-client-app\",\n\tClientSecret: \"minio-client-app-secret\",\n\tProviderURL:  \"http://127.0.0.1:5556/dex\",\n\tRedirectURL:  \"http://127.0.0.1:10000/oauth_callback\",\n}\n\nconst (\n\tEnvTestOpenIDServer  = \"_MINIO_OPENID_TEST_SERVER\"\n\tEnvTestOpenIDServer2 = \"_MINIO_OPENID_TEST_SERVER_2\"\n)\n\n// SetUpOpenIDs - sets up one or more OpenID test servers using the test OpenID\n// container and canned data from https://github.com/minio/minio-ldap-testing\n//\n// Each set of client app params corresponds to a separate openid server, and\n// the i-th server in this will be applied the i-th policy in `rolePolicies`. If\n// a rolePolicies entry is an empty string, that server will be configured as\n// policy-claim based openid server. NOTE that a valid configuration can have a\n// policy claim based provider only if it is the only OpenID provider.\nfunc (s *TestSuiteIAM) SetUpOpenIDs(c *check, testApps []OpenIDClientAppParams, rolePolicies []string) error {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tfor i, testApp := range testApps {\n\t\tconfigCmds := []string{\n\t\t\tfmt.Sprintf(\"identity_openid:%d\", i),\n\t\t\tfmt.Sprintf(\"config_url=%s/.well-known/openid-configuration\", testApp.ProviderURL),\n\t\t\tfmt.Sprintf(\"client_id=%s\", testApp.ClientID),\n\t\t\tfmt.Sprintf(\"client_secret=%s\", testApp.ClientSecret),\n\t\t\t\"scopes=openid,groups\",\n\t\t\tfmt.Sprintf(\"redirect_uri=%s\", testApp.RedirectURL),\n\t\t}\n\t\tif rolePolicies[i] != \"\" {\n\t\t\tconfigCmds = append(configCmds, fmt.Sprintf(\"role_policy=%s\", rolePolicies[i]))\n\t\t} else {\n\t\t\tconfigCmds = append(configCmds, \"claim_name=groups\")\n\t\t}\n\t\t_, err := s.adm.SetConfigKV(ctx, strings.Join(configCmds, \" \"))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to setup OpenID for tests: %v\", err)\n\t\t}\n\t}\n\n\ts.RestartIAMSuite(c)\n\treturn nil\n}\n\n// SetUpOpenID - expects to setup an OpenID test server using the test OpenID\n// container and canned data from https://github.com/minio/minio-ldap-testing\nfunc (s *TestSuiteIAM) SetUpOpenID(c *check, serverAddr string, rolePolicy string) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tconfigCmds := []string{\n\t\t\"identity_openid\",\n\t\tfmt.Sprintf(\"config_url=%s/.well-known/openid-configuration\", serverAddr),\n\t\t\"client_id=minio-client-app\",\n\t\t\"client_secret=minio-client-app-secret\",\n\t\t\"scopes=openid,groups\",\n\t\t\"redirect_uri=http://127.0.0.1:10000/oauth_callback\",\n\t}\n\tif rolePolicy != \"\" {\n\t\tconfigCmds = append(configCmds, fmt.Sprintf(\"role_policy=%s\", rolePolicy))\n\t} else {\n\t\tconfigCmds = append(configCmds, \"claim_name=groups\")\n\t}\n\t_, err := s.adm.SetConfigKV(ctx, strings.Join(configCmds, \" \"))\n\tif err != nil {\n\t\tc.Fatalf(\"unable to setup OpenID for tests: %v\", err)\n\t}\n\n\ts.RestartIAMSuite(c)\n}\n\nfunc TestIAMWithOpenIDServerSuite(t *testing.T) {\n\tfor i, testCase := range iamTestSuites {\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s\", i+1, testCase.ServerTypeDescription),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tc := &check{t, testCase.serverType}\n\t\t\t\tsuite := testCase\n\n\t\t\t\topenIDServer := os.Getenv(EnvTestOpenIDServer)\n\t\t\t\tif openIDServer == \"\" {\n\t\t\t\t\tc.Skip(\"Skipping OpenID test as no OpenID server is provided.\")\n\t\t\t\t}\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tsuite.SetUpOpenID(c, openIDServer, \"\")\n\t\t\t\tsuite.TestOpenIDSTS(c)\n\t\t\t\tsuite.TestOpenIDServiceAcc(c)\n\t\t\t\tsuite.TestOpenIDSTSAddUser(c)\n\t\t\t\tsuite.TearDownSuite(c)\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc TestIAMWithOpenIDWithRolePolicyServerSuite(t *testing.T) {\n\tfor i, testCase := range iamTestSuites {\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s\", i+1, testCase.ServerTypeDescription),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tc := &check{t, testCase.serverType}\n\t\t\t\tsuite := testCase\n\n\t\t\t\topenIDServer := os.Getenv(EnvTestOpenIDServer)\n\t\t\t\tif openIDServer == \"\" {\n\t\t\t\t\tc.Skip(\"Skipping OpenID test as no OpenID server is provided.\")\n\t\t\t\t}\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tsuite.SetUpOpenID(c, openIDServer, \"readwrite\")\n\t\t\t\tsuite.TestOpenIDSTSWithRolePolicy(c, testRoleARNs[0], testRoleMap[testRoleARNs[0]])\n\t\t\t\tsuite.TestOpenIDServiceAccWithRolePolicy(c)\n\t\t\t\tsuite.TearDownSuite(c)\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc TestIAMWithOpenIDWithRolePolicyWithPolicyVariablesServerSuite(t *testing.T) {\n\tfor i, testCase := range iamTestSuites {\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s\", i+1, testCase.ServerTypeDescription),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tc := &check{t, testCase.serverType}\n\t\t\t\tsuite := testCase\n\n\t\t\t\topenIDServer := os.Getenv(EnvTestOpenIDServer)\n\t\t\t\tif openIDServer == \"\" {\n\t\t\t\t\tc.Skip(\"Skipping OpenID test as no OpenID server is provided.\")\n\t\t\t\t}\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tsuite.SetUpOpenID(c, openIDServer, \"projecta,projectb,projectaorb\")\n\t\t\t\tsuite.TestOpenIDSTSWithRolePolicyWithPolVar(c, testRoleARNs[0], testRoleMap[testRoleARNs[0]])\n\t\t\t\tsuite.TearDownSuite(c)\n\t\t\t},\n\t\t)\n\t}\n}\n\nconst (\n\ttestRoleARN  = \"arn:minio:iam:::role/nOybJqMNzNmroqEKq5D0EUsRZw0\"\n\ttestRoleARN2 = \"arn:minio:iam:::role/domXb70kze7Ugc1SaxaeFchhLP4\"\n)\n\nvar (\n\ttestRoleARNs = []string{testRoleARN, testRoleARN2}\n\n\t// Load test client app and test role mapping depending on test\n\t// environment.\n\ttestClientApps, testRoleMap = func() ([]OpenIDClientAppParams, map[string]OpenIDClientAppParams) {\n\t\tvar apps []OpenIDClientAppParams\n\t\tm := map[string]OpenIDClientAppParams{}\n\n\t\topenIDServer := os.Getenv(EnvTestOpenIDServer)\n\t\tif openIDServer != \"\" {\n\t\t\tapps = append(apps, OpenIDClientAppParams{\n\t\t\t\tClientID:     \"minio-client-app\",\n\t\t\t\tClientSecret: \"minio-client-app-secret\",\n\t\t\t\tProviderURL:  openIDServer,\n\t\t\t\tRedirectURL:  \"http://127.0.0.1:10000/oauth_callback\",\n\t\t\t})\n\t\t\tm[testRoleARNs[len(apps)-1]] = apps[len(apps)-1]\n\t\t}\n\n\t\topenIDServer2 := os.Getenv(EnvTestOpenIDServer2)\n\t\tif openIDServer2 != \"\" {\n\t\t\tapps = append(apps, OpenIDClientAppParams{\n\t\t\t\tClientID:     \"minio-client-app-2\",\n\t\t\t\tClientSecret: \"minio-client-app-secret-2\",\n\t\t\t\tProviderURL:  openIDServer2,\n\t\t\t\tRedirectURL:  \"http://127.0.0.1:10000/oauth_callback\",\n\t\t\t})\n\t\t\tm[testRoleARNs[len(apps)-1]] = apps[len(apps)-1]\n\t\t}\n\n\t\treturn apps, m\n\t}()\n)\n\nfunc (s *TestSuiteIAM) TestOpenIDSTSWithRolePolicy(c *check, roleARN string, clientApp OpenIDClientAppParams) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Generate web identity JWT by interacting with OpenID IDP.\n\ttoken, err := MockOpenIDTestUserInteraction(ctx, clientApp, \"dillon@example.io\", \"dillon\")\n\tif err != nil {\n\t\tc.Fatalf(\"mock user err: %v\", err)\n\t}\n\n\t// Generate STS credential.\n\twebID := cr.STSWebIdentity{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\tToken: token,\n\t\t\t}, nil\n\t\t},\n\t\tRoleARN: roleARN,\n\t}\n\n\tvalue, err := webID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\t// fmt.Printf(\"value: %#v\\n\", value)\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n}\n\nfunc (s *TestSuiteIAM) TestOpenIDServiceAccWithRolePolicy(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Generate web identity STS token by interacting with OpenID IDP.\n\ttoken, err := MockOpenIDTestUserInteraction(ctx, testAppParams, \"dillon@example.io\", \"dillon\")\n\tif err != nil {\n\t\tc.Fatalf(\"mock user err: %v\", err)\n\t}\n\n\twebID := cr.STSWebIdentity{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\tToken: token,\n\t\t\t}, nil\n\t\t},\n\t\tRoleARN: testRoleARN,\n\t}\n\n\tvalue, err := webID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, value.AccessKeyID, userAdmClient)\n\n\t// 1. Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey)\n\n\t// 2. Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey, true)\n\n\t// 3. Check S3 access\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// 4. Check that svc account can restrict the policy, and that the\n\t// session policy can be updated.\n\tc.assertSvcAccSessionPolicyUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 4. Check that service account's secret key and account status can be\n\t// updated.\n\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n}\n\n// Constants for Policy Variables test.\nvar (\n\tpolicyProjectA = `{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                        \"s3:GetBucketLocation\",\n                        \"s3:ListAllMyBuckets\"\n                      ],\n            \"Resource\": \"arn:aws:s3:::*\"\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": \"s3:*\",\n            \"Resource\": [\n                \"arn:aws:s3:::projecta\",\n                \"arn:aws:s3:::projecta/*\"\n            ],\n            \"Condition\": {\n                \"ForAnyValue:StringEquals\": {\n                    \"jwt:groups\": [\n                        \"projecta\"\n                    ]\n                }\n            }\n        }\n    ]\n}\n`\n\tpolicyProjectB = `{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                        \"s3:GetBucketLocation\",\n                        \"s3:ListAllMyBuckets\"\n                      ],\n            \"Resource\": \"arn:aws:s3:::*\"\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": \"s3:*\",\n            \"Resource\": [\n                \"arn:aws:s3:::projectb\",\n                \"arn:aws:s3:::projectb/*\"\n            ],\n            \"Condition\": {\n                \"ForAnyValue:StringEquals\": {\n                    \"jwt:groups\": [\n                        \"projectb\"\n                    ]\n                }\n            }\n        }\n    ]\n}\n`\n\tpolicyProjectAorB = `{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                        \"s3:GetBucketLocation\",\n                        \"s3:ListAllMyBuckets\"\n                      ],\n            \"Resource\": \"arn:aws:s3:::*\"\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": \"s3:*\",\n            \"Resource\": [\n                \"arn:aws:s3:::projectaorb\",\n                \"arn:aws:s3:::projectaorb/*\"\n            ],\n            \"Condition\": {\n                \"ForAnyValue:StringEquals\": {\n                    \"jwt:groups\": [\n                        \"projecta\",\n                        \"projectb\"\n                    ]\n                }\n            }\n        }\n    ]\n}`\n\n\tpolicyProjectsMap = map[string]string{\n\t\t// grants access to bucket `projecta` if user is in group `projecta`\n\t\t\"projecta\": policyProjectA,\n\n\t\t// grants access to bucket `projectb` if user is in group `projectb`\n\t\t\"projectb\": policyProjectB,\n\n\t\t// grants access to bucket `projectaorb` if user is in either group\n\t\t// `projecta` or `projectb`\n\t\t\"projectaorb\": policyProjectAorB,\n\t}\n)\n\nfunc (s *TestSuiteIAM) TestOpenIDSTSWithRolePolicyWithPolVar(c *check, roleARN string, clientApp OpenIDClientAppParams) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\t// Create project buckets\n\tbuckets := []string{\"projecta\", \"projectb\", \"projectaorb\", \"other\"}\n\tfor _, bucket := range buckets {\n\t\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\t\tif err != nil {\n\t\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t\t}\n\t}\n\n\t// Create policies\n\tfor polName, polContent := range policyProjectsMap {\n\t\terr := s.adm.AddCannedPolicy(ctx, polName, []byte(polContent))\n\t\tif err != nil {\n\t\t\tc.Fatalf(\"policy add error: %v\", err)\n\t\t}\n\t}\n\n\tmakeSTSClient := func(user, password string) *minio.Client {\n\t\t// Generate web identity JWT by interacting with OpenID IDP.\n\t\ttoken, err := MockOpenIDTestUserInteraction(ctx, clientApp, user, password)\n\t\tif err != nil {\n\t\t\tc.Fatalf(\"mock user err: %v\", err)\n\t\t}\n\n\t\t// Generate STS credential.\n\t\twebID := cr.STSWebIdentity{\n\t\t\tClient:      s.TestSuiteCommon.client,\n\t\t\tSTSEndpoint: s.endPoint,\n\t\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\t\tToken: token,\n\t\t\t\t}, nil\n\t\t\t},\n\t\t\tRoleARN: roleARN,\n\t\t}\n\n\t\tvalue, err := webID.Retrieve()\n\t\tif err != nil {\n\t\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t\t}\n\t\t// fmt.Printf(\"value: %#v\\n\", value)\n\n\t\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\t\tSecure:    s.secure,\n\t\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t\t})\n\t\tif err != nil {\n\t\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t\t}\n\n\t\treturn minioClient\n\t}\n\n\t// user dillon's groups attribute is [\"projecta\", \"projectb\"]\n\tdillonClient := makeSTSClient(\"dillon@example.io\", \"dillon\")\n\t// Validate client's permissions\n\tc.mustListBuckets(ctx, dillonClient)\n\tc.mustListObjects(ctx, dillonClient, \"projecta\")\n\tc.mustListObjects(ctx, dillonClient, \"projectb\")\n\tc.mustListObjects(ctx, dillonClient, \"projectaorb\")\n\tc.mustNotListObjects(ctx, dillonClient, \"other\")\n\n\t// this user's groups attribute is [\"projectb\"]\n\tlisaClient := makeSTSClient(\"ejones@example.io\", \"liza\")\n\t// Validate client's permissions\n\tc.mustListBuckets(ctx, lisaClient)\n\tc.mustNotListObjects(ctx, lisaClient, \"projecta\")\n\tc.mustListObjects(ctx, lisaClient, \"projectb\")\n\tc.mustListObjects(ctx, lisaClient, \"projectaorb\")\n\tc.mustNotListObjects(ctx, lisaClient, \"other\")\n}\n\nfunc TestIAMWithOpenIDMultipleConfigsValidation1(t *testing.T) {\n\topenIDServer := os.Getenv(EnvTestOpenIDServer)\n\topenIDServer2 := os.Getenv(EnvTestOpenIDServer2)\n\tif openIDServer == \"\" || openIDServer2 == \"\" {\n\t\tt.Skip(\"Skipping OpenID test as enough OpenID servers are not provided.\")\n\t}\n\ttestApps := testClientApps\n\n\trolePolicies := []string{\n\t\t\"\", // Treated as claim-based provider as no role policy is given.\n\t\t\"readwrite\",\n\t}\n\n\tfor i, testCase := range iamTestSuites {\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s\", i+1, testCase.ServerTypeDescription),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tc := &check{t, testCase.serverType}\n\t\t\t\tsuite := testCase\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tdefer suite.TearDownSuite(c)\n\n\t\t\t\terr := suite.SetUpOpenIDs(c, testApps, rolePolicies)\n\t\t\t\tif err != nil {\n\t\t\t\t\tc.Fatalf(\"config with 1 claim based and 1 role based provider should pass but got: %v\", err)\n\t\t\t\t}\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc TestIAMWithOpenIDMultipleConfigsValidation2(t *testing.T) {\n\topenIDServer := os.Getenv(EnvTestOpenIDServer)\n\topenIDServer2 := os.Getenv(EnvTestOpenIDServer2)\n\tif openIDServer == \"\" || openIDServer2 == \"\" {\n\t\tt.Skip(\"Skipping OpenID test as enough OpenID servers are not provided.\")\n\t}\n\ttestApps := testClientApps\n\n\trolePolicies := []string{\n\t\t\"\", // Treated as claim-based provider as no role policy is given.\n\t\t\"\", // Treated as claim-based provider as no role policy is given.\n\t}\n\n\tfor i, testCase := range iamTestSuites {\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s\", i+1, testCase.ServerTypeDescription),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tc := &check{t, testCase.serverType}\n\t\t\t\tsuite := testCase\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tdefer suite.TearDownSuite(c)\n\n\t\t\t\terr := suite.SetUpOpenIDs(c, testApps, rolePolicies)\n\t\t\t\tif err == nil {\n\t\t\t\t\tc.Fatalf(\"config with 2 claim based provider should fail\")\n\t\t\t\t}\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc TestIAMWithOpenIDWithMultipleRolesServerSuite(t *testing.T) {\n\topenIDServer := os.Getenv(EnvTestOpenIDServer)\n\topenIDServer2 := os.Getenv(EnvTestOpenIDServer2)\n\tif openIDServer == \"\" || openIDServer2 == \"\" {\n\t\tt.Skip(\"Skipping OpenID test as enough OpenID servers are not provided.\")\n\t}\n\ttestApps := testClientApps\n\n\trolePolicies := []string{\n\t\t\"consoleAdmin\",\n\t\t\"readwrite\",\n\t}\n\n\tfor i, testCase := range iamTestSuites {\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s\", i+1, testCase.ServerTypeDescription),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tc := &check{t, testCase.serverType}\n\t\t\t\tsuite := testCase\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\terr := suite.SetUpOpenIDs(c, testApps, rolePolicies)\n\t\t\t\tif err != nil {\n\t\t\t\t\tc.Fatalf(\"Error setting up openid providers for tests: %v\", err)\n\t\t\t\t}\n\t\t\t\tsuite.TestOpenIDSTSWithRolePolicy(c, testRoleARNs[0], testRoleMap[testRoleARNs[0]])\n\t\t\t\tsuite.TestOpenIDSTSWithRolePolicy(c, testRoleARNs[1], testRoleMap[testRoleARNs[1]])\n\t\t\t\tsuite.TestOpenIDServiceAccWithRolePolicy(c)\n\t\t\t\tsuite.TearDownSuite(c)\n\t\t\t},\n\t\t)\n\t}\n}\n\n// Access Management Plugin tests\nfunc TestIAM_AMPWithOpenIDWithMultipleRolesServerSuite(t *testing.T) {\n\topenIDServer := os.Getenv(EnvTestOpenIDServer)\n\topenIDServer2 := os.Getenv(EnvTestOpenIDServer2)\n\tif openIDServer == \"\" || openIDServer2 == \"\" {\n\t\tt.Skip(\"Skipping OpenID test as enough OpenID servers are not provided.\")\n\t}\n\ttestApps := testClientApps\n\n\trolePolicies := []string{\n\t\t\"consoleAdmin\",\n\t\t\"readwrite\",\n\t}\n\n\tfor i, testCase := range iamTestSuites {\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s\", i+1, testCase.ServerTypeDescription),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tc := &check{t, testCase.serverType}\n\t\t\t\tsuite := testCase\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tdefer suite.TearDownSuite(c)\n\n\t\t\t\terr := suite.SetUpOpenIDs(c, testApps, rolePolicies)\n\t\t\t\tif err != nil {\n\t\t\t\t\tc.Fatalf(\"Error setting up openid providers for tests: %v\", err)\n\t\t\t\t}\n\n\t\t\t\tsuite.SetUpAccMgmtPlugin(c)\n\n\t\t\t\tsuite.TestOpenIDSTSWithRolePolicyUnderAMP(c, testRoleARNs[0], testRoleMap[testRoleARNs[0]])\n\t\t\t\tsuite.TestOpenIDSTSWithRolePolicyUnderAMP(c, testRoleARNs[1], testRoleMap[testRoleARNs[1]])\n\t\t\t\tsuite.TestOpenIDServiceAccWithRolePolicyUnderAMP(c)\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestOpenIDSTSWithRolePolicyUnderAMP(c *check, roleARN string, clientApp OpenIDClientAppParams) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Generate web identity JWT by interacting with OpenID IDP.\n\ttoken, err := MockOpenIDTestUserInteraction(ctx, clientApp, \"dillon@example.io\", \"dillon\")\n\tif err != nil {\n\t\tc.Fatalf(\"mock user err: %v\", err)\n\t}\n\n\t// Generate STS credential.\n\twebID := cr.STSWebIdentity{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\tToken: token,\n\t\t\t}, nil\n\t\t},\n\t\tRoleARN: roleARN,\n\t}\n\n\tvalue, err := webID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\t// fmt.Printf(\"value: %#v\\n\", value)\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that the client from STS creds cannot upload any object as\n\t// it is denied by the plugin.\n\tc.mustNotUpload(ctx, minioClient, bucket)\n}\n\nfunc (s *TestSuiteIAM) TestOpenIDServiceAccWithRolePolicyUnderAMP(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Generate web identity STS token by interacting with OpenID IDP.\n\ttoken, err := MockOpenIDTestUserInteraction(ctx, testAppParams, \"dillon@example.io\", \"dillon\")\n\tif err != nil {\n\t\tc.Fatalf(\"mock user err: %v\", err)\n\t}\n\n\twebID := cr.STSWebIdentity{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\tToken: token,\n\t\t\t}, nil\n\t\t},\n\t\tRoleARN: testRoleARN,\n\t}\n\n\tvalue, err := webID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, value.AccessKeyID, userAdmClient)\n\n\t// 1. Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey)\n\n\t// 2. Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey, true)\n\n\t// 3. Check S3 access\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\t// 3.1 Validate that the client from STS creds cannot upload any object as\n\t// it is denied by the plugin.\n\tc.mustNotUpload(ctx, s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\"), bucket)\n\n\t// Check that session policies do not apply - as policy enforcement is\n\t// delegated to plugin.\n\t{\n\t\tsvcAK, svcSK := mustGenerateCredentials(c)\n\n\t\t// This policy does not allow listing objects.\n\t\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\t\tcr, err := userAdmClient.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n\t\t\tPolicy:     policyBytes,\n\t\t\tTargetUser: value.AccessKeyID,\n\t\t\tAccessKey:  svcAK,\n\t\t\tSecretKey:  svcSK,\n\t\t})\n\t\tif err != nil {\n\t\t\tc.Fatalf(\"Unable to create svc acc: %v\", err)\n\t\t}\n\t\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n\t\t// Though the attached policy does not allow listing, it will be\n\t\t// ignored because the plugin allows it.\n\t\tc.mustListObjects(ctx, svcClient, bucket)\n\t}\n\n\t// 4. Check that service account's secret key and account status can be\n\t// updated.\n\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n}\n"], "fixing_code": ["// Copyright (c) 2015-2023 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"sort\"\n\t\"time\"\n\n\t\"github.com/klauspost/compress/zip\"\n\t\"github.com/minio/madmin-go/v3\"\n\t\"github.com/minio/minio/internal/auth\"\n\t\"github.com/minio/minio/internal/config/dns\"\n\t\"github.com/minio/minio/internal/logger\"\n\t\"github.com/minio/mux\"\n\t\"github.com/minio/pkg/v2/policy\"\n)\n\n// RemoveUser - DELETE /minio/admin/v3/remove-user?accessKey=<access_key>\nfunc (a adminAPIHandlers) RemoveUser(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, cred := validateAdminReq(ctx, w, r, policy.DeleteUserAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\taccessKey := vars[\"accessKey\"]\n\n\tok, _, err := globalIAMSys.IsTempUser(accessKey)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\tif ok {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errIAMActionNotAllowed), r.URL)\n\t\treturn\n\t}\n\n\t// When the user is root credential you are not allowed to\n\t// remove the root user. Also you cannot delete yourself.\n\tif accessKey == globalActiveCred.AccessKey || accessKey == cred.AccessKey {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errIAMActionNotAllowed), r.URL)\n\t\treturn\n\t}\n\n\tif err := globalIAMSys.DeleteUser(ctx, accessKey, true); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemIAMUser,\n\t\tIAMUser: &madmin.SRIAMUser{\n\t\t\tAccessKey:   accessKey,\n\t\t\tIsDeleteReq: true,\n\t\t},\n\t\tUpdatedAt: UTCNow(),\n\t}))\n}\n\n// ListBucketUsers - GET /minio/admin/v3/list-users?bucket={bucket}\nfunc (a adminAPIHandlers) ListBucketUsers(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, cred := validateAdminReq(ctx, w, r, policy.ListUsersAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tbucket := mux.Vars(r)[\"bucket\"]\n\n\tpassword := cred.SecretKey\n\n\tallCredentials, err := globalIAMSys.ListBucketUsers(ctx, bucket)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tdata, err := json.Marshal(allCredentials)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\teconfigData, err := madmin.EncryptData(password, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, econfigData)\n}\n\n// ListUsers - GET /minio/admin/v3/list-users\nfunc (a adminAPIHandlers) ListUsers(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, cred := validateAdminReq(ctx, w, r, policy.ListUsersAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tpassword := cred.SecretKey\n\n\tallCredentials, err := globalIAMSys.ListUsers(ctx)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Add ldap users which have mapped policies if in LDAP mode\n\t// FIXME(vadmeste): move this to policy info in the future\n\tldapUsers, err := globalIAMSys.ListLDAPUsers(ctx)\n\tif err != nil && err != errIAMActionNotAllowed {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\tfor k, v := range ldapUsers {\n\t\tallCredentials[k] = v\n\t}\n\n\t// Marshal the response\n\tdata, err := json.Marshal(allCredentials)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\teconfigData, err := madmin.EncryptData(password, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, econfigData)\n}\n\n// GetUserInfo - GET /minio/admin/v3/user-info\nfunc (a adminAPIHandlers) GetUserInfo(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tvars := mux.Vars(r)\n\tname := vars[\"accessKey\"]\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\tcheckDenyOnly := false\n\tif name == cred.AccessKey {\n\t\t// Check that there is no explicit deny - otherwise it's allowed\n\t\t// to view one's own info.\n\t\tcheckDenyOnly = true\n\t}\n\n\tif !globalIAMSys.IsAllowed(policy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          policy.GetUserAdminAction,\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t\tDenyOnly:        checkDenyOnly,\n\t}) {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\treturn\n\t}\n\n\tuserInfo, err := globalIAMSys.GetUserInfo(ctx, name)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tdata, err := json.Marshal(userInfo)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, data)\n}\n\n// UpdateGroupMembers - PUT /minio/admin/v3/update-group-members\nfunc (a adminAPIHandlers) UpdateGroupMembers(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, policy.AddUserToGroupAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tdata, err := io.ReadAll(r.Body)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n\t\treturn\n\t}\n\n\tvar updReq madmin.GroupAddRemove\n\terr = json.Unmarshal(data, &updReq)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n\t\treturn\n\t}\n\n\t// Reject if the group add and remove are temporary credentials, or root credential.\n\tfor _, member := range updReq.Members {\n\t\tok, _, err := globalIAMSys.IsTempUser(member)\n\t\tif err != nil && err != errNoSuchUser {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\tif ok {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errIAMActionNotAllowed), r.URL)\n\t\t\treturn\n\t\t}\n\t\t// When the user is root credential you are not allowed to\n\t\t// add policies for root user.\n\t\tif member == globalActiveCred.AccessKey {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errIAMActionNotAllowed), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\tvar updatedAt time.Time\n\tif updReq.IsRemove {\n\t\tupdatedAt, err = globalIAMSys.RemoveUsersFromGroup(ctx, updReq.Group, updReq.Members)\n\t} else {\n\t\t// Check if group already exists\n\t\tif _, gerr := globalIAMSys.GetGroupDescription(updReq.Group); gerr != nil {\n\t\t\t// If group does not exist, then check if the group has beginning and end space characters\n\t\t\t// we will reject such group names.\n\t\t\tif errors.Is(gerr, errNoSuchGroup) && hasSpaceBE(updReq.Group) {\n\t\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminResourceInvalidArgument), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tupdatedAt, err = globalIAMSys.AddUsersToGroup(ctx, updReq.Group, updReq.Members)\n\t}\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemGroupInfo,\n\t\tGroupInfo: &madmin.SRGroupInfo{\n\t\t\tUpdateReq: updReq,\n\t\t},\n\t\tUpdatedAt: updatedAt,\n\t}))\n}\n\n// GetGroup - /minio/admin/v3/group?group=mygroup1\nfunc (a adminAPIHandlers) GetGroup(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, policy.GetGroupAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\tgroup := vars[\"group\"]\n\n\tgdesc, err := globalIAMSys.GetGroupDescription(group)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tbody, err := json.Marshal(gdesc)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, body)\n}\n\n// ListGroups - GET /minio/admin/v3/groups\nfunc (a adminAPIHandlers) ListGroups(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, policy.ListGroupsAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tgroups, err := globalIAMSys.ListGroups(ctx)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tbody, err := json.Marshal(groups)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, body)\n}\n\n// SetGroupStatus - PUT /minio/admin/v3/set-group-status?group=mygroup1&status=enabled\nfunc (a adminAPIHandlers) SetGroupStatus(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, policy.EnableGroupAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\tgroup := vars[\"group\"]\n\tstatus := vars[\"status\"]\n\n\tvar (\n\t\terr       error\n\t\tupdatedAt time.Time\n\t)\n\tswitch status {\n\tcase statusEnabled:\n\t\tupdatedAt, err = globalIAMSys.SetGroupStatus(ctx, group, true)\n\tcase statusDisabled:\n\t\tupdatedAt, err = globalIAMSys.SetGroupStatus(ctx, group, false)\n\tdefault:\n\t\terr = errInvalidArgument\n\t}\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemGroupInfo,\n\t\tGroupInfo: &madmin.SRGroupInfo{\n\t\t\tUpdateReq: madmin.GroupAddRemove{\n\t\t\t\tGroup:    group,\n\t\t\t\tStatus:   madmin.GroupStatus(status),\n\t\t\t\tIsRemove: false,\n\t\t\t},\n\t\t},\n\t\tUpdatedAt: updatedAt,\n\t}))\n}\n\n// SetUserStatus - PUT /minio/admin/v3/set-user-status?accessKey=<access_key>&status=[enabled|disabled]\nfunc (a adminAPIHandlers) SetUserStatus(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, creds := validateAdminReq(ctx, w, r, policy.EnableUserAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\taccessKey := vars[\"accessKey\"]\n\tstatus := vars[\"status\"]\n\n\t// you cannot enable or disable yourself.\n\tif accessKey == creds.AccessKey {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errInvalidArgument), r.URL)\n\t\treturn\n\t}\n\n\tupdatedAt, err := globalIAMSys.SetUserStatus(ctx, accessKey, madmin.AccountStatus(status))\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemIAMUser,\n\t\tIAMUser: &madmin.SRIAMUser{\n\t\t\tAccessKey:   accessKey,\n\t\t\tIsDeleteReq: false,\n\t\t\tUserReq: &madmin.AddOrUpdateUserReq{\n\t\t\t\tStatus: madmin.AccountStatus(status),\n\t\t\t},\n\t\t},\n\t\tUpdatedAt: updatedAt,\n\t}))\n}\n\n// AddUser - PUT /minio/admin/v3/add-user?accessKey=<access_key>\nfunc (a adminAPIHandlers) AddUser(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tvars := mux.Vars(r)\n\taccessKey := vars[\"accessKey\"]\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\t// Not allowed to add a user with same access key as root credential\n\tif accessKey == globalActiveCred.AccessKey {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAddUserInvalidArgument), r.URL)\n\t\treturn\n\t}\n\n\tuser, exists := globalIAMSys.GetUser(ctx, accessKey)\n\tif exists && (user.Credentials.IsTemp() || user.Credentials.IsServiceAccount()) {\n\t\t// Updating STS credential is not allowed, and this API does not\n\t\t// support updating service accounts.\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAddUserInvalidArgument), r.URL)\n\t\treturn\n\t}\n\n\tif (cred.IsTemp() || cred.IsServiceAccount()) && cred.ParentUser == accessKey {\n\t\t// Incoming access key matches parent user then we should\n\t\t// reject password change requests.\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAddUserInvalidArgument), r.URL)\n\t\treturn\n\t}\n\n\t// Check if accessKey has beginning and end space characters, this only applies to new users.\n\tif !exists && hasSpaceBE(accessKey) {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminResourceInvalidArgument), r.URL)\n\t\treturn\n\t}\n\n\tcheckDenyOnly := false\n\tif accessKey == cred.AccessKey {\n\t\t// Check that there is no explicit deny - otherwise it's allowed\n\t\t// to change one's own password.\n\t\tcheckDenyOnly = true\n\t}\n\n\tif !globalIAMSys.IsAllowed(policy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          policy.CreateUserAdminAction,\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t\tDenyOnly:        checkDenyOnly,\n\t}) {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\treturn\n\t}\n\n\tif r.ContentLength > maxEConfigJSONSize || r.ContentLength == -1 {\n\t\t// More than maxConfigSize bytes were available\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminConfigTooLarge), r.URL)\n\t\treturn\n\t}\n\n\tpassword := cred.SecretKey\n\tconfigBytes, err := madmin.DecryptData(password, io.LimitReader(r.Body, r.ContentLength))\n\tif err != nil {\n\t\tlogger.LogIf(ctx, err)\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminConfigBadJSON), r.URL)\n\t\treturn\n\t}\n\n\tvar ureq madmin.AddOrUpdateUserReq\n\tif err = json.Unmarshal(configBytes, &ureq); err != nil {\n\t\tlogger.LogIf(ctx, err)\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminConfigBadJSON), r.URL)\n\t\treturn\n\t}\n\n\tupdatedAt, err := globalIAMSys.CreateUser(ctx, accessKey, ureq)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemIAMUser,\n\t\tIAMUser: &madmin.SRIAMUser{\n\t\t\tAccessKey:   accessKey,\n\t\t\tIsDeleteReq: false,\n\t\t\tUserReq:     &ureq,\n\t\t},\n\t\tUpdatedAt: updatedAt,\n\t}))\n}\n\n// TemporaryAccountInfo - GET /minio/admin/v3/temporary-account-info\nfunc (a adminAPIHandlers) TemporaryAccountInfo(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\taccessKey := mux.Vars(r)[\"accessKey\"]\n\tif accessKey == \"\" {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n\t\treturn\n\t}\n\n\targs := policy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          policy.ListTemporaryAccountsAdminAction,\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t}\n\n\tif !globalIAMSys.IsAllowed(args) {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\treturn\n\t}\n\n\tstsAccount, sessionPolicy, err := globalIAMSys.GetTemporaryAccount(ctx, accessKey)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tvar stsAccountPolicy policy.Policy\n\n\tif sessionPolicy != nil {\n\t\tstsAccountPolicy = *sessionPolicy\n\t} else {\n\t\tpoliciesNames, err := globalIAMSys.PolicyDBGet(stsAccount.ParentUser, stsAccount.Groups...)\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\tif len(policiesNames) == 0 {\n\t\t\tpolicySet, _ := args.GetPolicies(iamPolicyClaimNameOpenID())\n\t\t\tpoliciesNames = policySet.ToSlice()\n\t\t}\n\n\t\tstsAccountPolicy = globalIAMSys.GetCombinedPolicy(policiesNames...)\n\t}\n\n\tpolicyJSON, err := json.MarshalIndent(stsAccountPolicy, \"\", \" \")\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tinfoResp := madmin.TemporaryAccountInfoResp{\n\t\tParentUser:    stsAccount.ParentUser,\n\t\tAccountStatus: stsAccount.Status,\n\t\tImpliedPolicy: sessionPolicy == nil,\n\t\tPolicy:        string(policyJSON),\n\t\tExpiration:    &stsAccount.Expiration,\n\t}\n\n\tdata, err := json.Marshal(infoResp)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tencryptedData, err := madmin.EncryptData(cred.SecretKey, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, encryptedData)\n}\n\n// AddServiceAccount - PUT /minio/admin/v3/add-service-account\nfunc (a adminAPIHandlers) AddServiceAccount(w http.ResponseWriter, r *http.Request) {\n\tctx, cred, opts, createReq, targetUser, APIError := commonAddServiceAccount(r)\n\tif APIError.Code != \"\" {\n\t\twriteErrorResponseJSON(ctx, w, APIError, r.URL)\n\t\treturn\n\t}\n\n\tvar (\n\t\ttargetGroups []string\n\t\terr          error\n\t)\n\n\t// Find the user for the request sender (as it may be sent via a service\n\t// account or STS account):\n\trequestorUser := cred.AccessKey\n\trequestorParentUser := cred.AccessKey\n\trequestorGroups := cred.Groups\n\trequestorIsDerivedCredential := false\n\tif cred.IsServiceAccount() || cred.IsTemp() {\n\t\trequestorParentUser = cred.ParentUser\n\t\trequestorIsDerivedCredential = true\n\t}\n\n\tif globalIAMSys.GetUsersSysType() == MinIOUsersSysType && targetUser != cred.AccessKey {\n\t\t// For internal IDP, ensure that the targetUser's parent account exists.\n\t\t// It could be a regular user account or the root account.\n\t\t_, isRegularUser := globalIAMSys.GetUser(ctx, targetUser)\n\t\tif !isRegularUser && targetUser != globalActiveCred.AccessKey {\n\t\t\tapiErr := toAdminAPIErr(ctx, errNoSuchUser)\n\t\t\tapiErr.Description = fmt.Sprintf(\"Specified target user %s does not exist\", targetUser)\n\t\t\twriteErrorResponseJSON(ctx, w, apiErr, r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Check if we are creating svc account for request sender.\n\tisSvcAccForRequestor := false\n\tif targetUser == requestorUser || targetUser == requestorParentUser {\n\t\tisSvcAccForRequestor = true\n\t}\n\n\t// If we are creating svc account for request sender, ensure\n\t// that targetUser is a real user (i.e. not derived\n\t// credentials).\n\tif isSvcAccForRequestor {\n\t\tif requestorIsDerivedCredential {\n\t\t\tif requestorParentUser == \"\" {\n\t\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx,\n\t\t\t\t\terrors.New(\"service accounts cannot be generated for temporary credentials without parent\")), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\ttargetUser = requestorParentUser\n\t\t}\n\t\ttargetGroups = requestorGroups\n\n\t\t// In case of LDAP/OIDC we need to set `opts.claims` to ensure\n\t\t// it is associated with the LDAP/OIDC user properly.\n\t\tfor k, v := range cred.Claims {\n\t\t\tif k == expClaim {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\topts.claims[k] = v\n\t\t}\n\t} else if globalIAMSys.LDAPConfig.Enabled() {\n\t\t// In case of LDAP we need to resolve the targetUser to a DN and\n\t\t// query their groups:\n\t\topts.claims[ldapUserN] = targetUser // simple username\n\t\ttargetUser, targetGroups, err = globalIAMSys.LDAPConfig.LookupUserDN(targetUser)\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\topts.claims[ldapUser] = targetUser // username DN\n\n\t\t// NOTE: if not using LDAP, then internal IDP or open ID is\n\t\t// being used - in the former, group info is enforced when\n\t\t// generated credentials are used to make requests, and in the\n\t\t// latter, a group notion is not supported.\n\t}\n\n\tnewCred, updatedAt, err := globalIAMSys.NewServiceAccount(ctx, targetUser, targetGroups, opts)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tcreateResp := madmin.AddServiceAccountResp{\n\t\tCredentials: madmin.Credentials{\n\t\t\tAccessKey:  newCred.AccessKey,\n\t\t\tSecretKey:  newCred.SecretKey,\n\t\t\tExpiration: newCred.Expiration,\n\t\t},\n\t}\n\n\tdata, err := json.Marshal(createResp)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tencryptedData, err := madmin.EncryptData(cred.SecretKey, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, encryptedData)\n\n\t// Call hook for cluster-replication if the service account is not for a\n\t// root user.\n\tif newCred.ParentUser != globalActiveCred.AccessKey {\n\t\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\t\tType: madmin.SRIAMItemSvcAcc,\n\t\t\tSvcAccChange: &madmin.SRSvcAccChange{\n\t\t\t\tCreate: &madmin.SRSvcAccCreate{\n\t\t\t\t\tParent:        newCred.ParentUser,\n\t\t\t\t\tAccessKey:     newCred.AccessKey,\n\t\t\t\t\tSecretKey:     newCred.SecretKey,\n\t\t\t\t\tGroups:        newCred.Groups,\n\t\t\t\t\tName:          newCred.Name,\n\t\t\t\t\tDescription:   newCred.Description,\n\t\t\t\t\tClaims:        opts.claims,\n\t\t\t\t\tSessionPolicy: createReq.Policy,\n\t\t\t\t\tStatus:        auth.AccountOn,\n\t\t\t\t\tExpiration:    createReq.Expiration,\n\t\t\t\t},\n\t\t\t},\n\t\t\tUpdatedAt: updatedAt,\n\t\t}))\n\t}\n}\n\n// UpdateServiceAccount - POST /minio/admin/v3/update-service-account\nfunc (a adminAPIHandlers) UpdateServiceAccount(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\taccessKey := mux.Vars(r)[\"accessKey\"]\n\tif accessKey == \"\" {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n\t\treturn\n\t}\n\n\tsvcAccount, _, err := globalIAMSys.GetServiceAccount(ctx, accessKey)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Permission checks:\n\t//\n\t// 1. Any type of account (i.e. access keys (previously/still called service\n\t// accounts), STS accounts, internal IDP accounts, etc) with the\n\t// policy.UpdateServiceAccountAdminAction permission can update any service\n\t// account.\n\t//\n\t// 2. We would like to let a user update their own access keys, however it\n\t// is currently blocked pending a re-design. Users are still able to delete\n\t// and re-create them.\n\tif !globalIAMSys.IsAllowed(policy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          policy.UpdateServiceAccountAdminAction,\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t}) {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\treturn\n\t}\n\n\tpassword := cred.SecretKey\n\treqBytes, err := madmin.DecryptData(password, io.LimitReader(r.Body, r.ContentLength))\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErrWithErr(ErrAdminConfigBadJSON, err), r.URL)\n\t\treturn\n\t}\n\n\tvar updateReq madmin.UpdateServiceAccountReq\n\tif err = json.Unmarshal(reqBytes, &updateReq); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErrWithErr(ErrAdminConfigBadJSON, err), r.URL)\n\t\treturn\n\t}\n\n\tif err := updateReq.Validate(); err != nil {\n\t\t// Since this validation would happen client side as well, we only send\n\t\t// a generic error message here.\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminResourceInvalidArgument), r.URL)\n\t\treturn\n\t}\n\n\tvar sp *policy.Policy\n\tif len(updateReq.NewPolicy) > 0 {\n\t\tsp, err = policy.ParseConfig(bytes.NewReader(updateReq.NewPolicy))\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\tif sp.Version == \"\" && len(sp.Statements) == 0 {\n\t\t\tsp = nil\n\t\t}\n\t}\n\topts := updateServiceAccountOpts{\n\t\tsecretKey:     updateReq.NewSecretKey,\n\t\tstatus:        updateReq.NewStatus,\n\t\tname:          updateReq.NewName,\n\t\tdescription:   updateReq.NewDescription,\n\t\texpiration:    updateReq.NewExpiration,\n\t\tsessionPolicy: sp,\n\t}\n\tupdatedAt, err := globalIAMSys.UpdateServiceAccount(ctx, accessKey, opts)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Call site replication hook - non-root user accounts are replicated.\n\tif svcAccount.ParentUser != globalActiveCred.AccessKey {\n\t\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\t\tType: madmin.SRIAMItemSvcAcc,\n\t\t\tSvcAccChange: &madmin.SRSvcAccChange{\n\t\t\t\tUpdate: &madmin.SRSvcAccUpdate{\n\t\t\t\t\tAccessKey:     accessKey,\n\t\t\t\t\tSecretKey:     opts.secretKey,\n\t\t\t\t\tStatus:        opts.status,\n\t\t\t\t\tName:          opts.name,\n\t\t\t\t\tDescription:   opts.description,\n\t\t\t\t\tSessionPolicy: updateReq.NewPolicy,\n\t\t\t\t\tExpiration:    updateReq.NewExpiration,\n\t\t\t\t},\n\t\t\t},\n\t\t\tUpdatedAt: updatedAt,\n\t\t}))\n\t}\n\n\twriteSuccessNoContent(w)\n}\n\n// InfoServiceAccount - GET /minio/admin/v3/info-service-account\nfunc (a adminAPIHandlers) InfoServiceAccount(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\taccessKey := mux.Vars(r)[\"accessKey\"]\n\tif accessKey == \"\" {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n\t\treturn\n\t}\n\n\tsvcAccount, sessionPolicy, err := globalIAMSys.GetServiceAccount(ctx, accessKey)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tif !globalIAMSys.IsAllowed(policy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          policy.ListServiceAccountsAdminAction,\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t}) {\n\t\trequestUser := cred.AccessKey\n\t\tif cred.ParentUser != \"\" {\n\t\t\trequestUser = cred.ParentUser\n\t\t}\n\n\t\tif requestUser != svcAccount.ParentUser {\n\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// if session policy is nil or empty, then it is implied policy\n\timpliedPolicy := sessionPolicy == nil || (sessionPolicy.Version == \"\" && len(sessionPolicy.Statements) == 0)\n\n\tvar svcAccountPolicy policy.Policy\n\n\tif !impliedPolicy {\n\t\tsvcAccountPolicy = *sessionPolicy\n\t} else {\n\t\tpoliciesNames, err := globalIAMSys.PolicyDBGet(svcAccount.ParentUser, svcAccount.Groups...)\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\tsvcAccountPolicy = globalIAMSys.GetCombinedPolicy(policiesNames...)\n\t}\n\n\tpolicyJSON, err := json.MarshalIndent(svcAccountPolicy, \"\", \" \")\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tvar expiration *time.Time\n\tif !svcAccount.Expiration.IsZero() && !svcAccount.Expiration.Equal(timeSentinel) {\n\t\texpiration = &svcAccount.Expiration\n\t}\n\n\tinfoResp := madmin.InfoServiceAccountResp{\n\t\tParentUser:    svcAccount.ParentUser,\n\t\tName:          svcAccount.Name,\n\t\tDescription:   svcAccount.Description,\n\t\tAccountStatus: svcAccount.Status,\n\t\tImpliedPolicy: impliedPolicy,\n\t\tPolicy:        string(policyJSON),\n\t\tExpiration:    expiration,\n\t}\n\n\tdata, err := json.Marshal(infoResp)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tencryptedData, err := madmin.EncryptData(cred.SecretKey, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, encryptedData)\n}\n\n// ListServiceAccounts - GET /minio/admin/v3/list-service-accounts\nfunc (a adminAPIHandlers) ListServiceAccounts(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\tvar targetAccount string\n\n\t// If listing is requested for a specific user (who is not the request\n\t// sender), check that the user has permissions.\n\tuser := r.Form.Get(\"user\")\n\tif user != \"\" && user != cred.AccessKey {\n\t\tif !globalIAMSys.IsAllowed(policy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          policy.ListServiceAccountsAdminAction,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\t\tIsOwner:         owner,\n\t\t\tClaims:          cred.Claims,\n\t\t}) {\n\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\t\treturn\n\t\t}\n\t\ttargetAccount = user\n\t} else {\n\t\ttargetAccount = cred.AccessKey\n\t\tif cred.ParentUser != \"\" {\n\t\t\ttargetAccount = cred.ParentUser\n\t\t}\n\t}\n\n\tserviceAccounts, err := globalIAMSys.ListServiceAccounts(ctx, targetAccount)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tvar serviceAccountList []madmin.ServiceAccountInfo\n\n\tfor _, svc := range serviceAccounts {\n\t\texpiryTime := svc.Expiration\n\t\tserviceAccountList = append(serviceAccountList, madmin.ServiceAccountInfo{\n\t\t\tAccessKey:  svc.AccessKey,\n\t\t\tExpiration: &expiryTime,\n\t\t})\n\t}\n\n\tlistResp := madmin.ListServiceAccountsResp{\n\t\tAccounts: serviceAccountList,\n\t}\n\n\tdata, err := json.Marshal(listResp)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tencryptedData, err := madmin.EncryptData(cred.SecretKey, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, encryptedData)\n}\n\n// DeleteServiceAccount - DELETE /minio/admin/v3/delete-service-account\nfunc (a adminAPIHandlers) DeleteServiceAccount(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\tserviceAccount := mux.Vars(r)[\"accessKey\"]\n\tif serviceAccount == \"\" {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminInvalidArgument), r.URL)\n\t\treturn\n\t}\n\n\t// We do not care if service account is readable or not at this point,\n\t// since this is a delete call we shall allow it to be deleted if possible.\n\tsvcAccount, _, err := globalIAMSys.GetServiceAccount(ctx, serviceAccount)\n\tif errors.Is(err, errNoSuchServiceAccount) {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminServiceAccountNotFound), r.URL)\n\t\treturn\n\t}\n\n\tadminPrivilege := globalIAMSys.IsAllowed(policy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          policy.RemoveServiceAccountAdminAction,\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t})\n\n\tif !adminPrivilege {\n\t\tparentUser := cred.AccessKey\n\t\tif cred.ParentUser != \"\" {\n\t\t\tparentUser = cred.ParentUser\n\t\t}\n\t\tif svcAccount.ParentUser != \"\" && parentUser != svcAccount.ParentUser {\n\t\t\t// The service account belongs to another user but return not\n\t\t\t// found error to mitigate brute force attacks. or the\n\t\t\t// serviceAccount doesn't exist.\n\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminServiceAccountNotFound), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\tif err := globalIAMSys.DeleteServiceAccount(ctx, serviceAccount, true); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Call site replication hook - non-root user accounts are replicated.\n\tif svcAccount.ParentUser != \"\" && svcAccount.ParentUser != globalActiveCred.AccessKey {\n\t\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\t\tType: madmin.SRIAMItemSvcAcc,\n\t\t\tSvcAccChange: &madmin.SRSvcAccChange{\n\t\t\t\tDelete: &madmin.SRSvcAccDelete{\n\t\t\t\t\tAccessKey: serviceAccount,\n\t\t\t\t},\n\t\t\t},\n\t\t\tUpdatedAt: UTCNow(),\n\t\t}))\n\t}\n\n\twriteSuccessNoContent(w)\n}\n\n// AccountInfoHandler returns usage, permissions and other bucket metadata for incoming us\nfunc (a adminAPIHandlers) AccountInfoHandler(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\t// Set prefix value for \"s3:prefix\" policy conditionals.\n\tr.Header.Set(\"prefix\", \"\")\n\n\t// Set delimiter value for \"s3:delimiter\" policy conditionals.\n\tr.Header.Set(\"delimiter\", SlashSeparator)\n\n\t// Check if we are asked to return prefix usage\n\tenablePrefixUsage := r.Form.Get(\"prefix-usage\") == \"true\"\n\n\tisAllowedAccess := func(bucketName string) (rd, wr bool) {\n\t\tif globalIAMSys.IsAllowed(policy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          policy.ListBucketAction,\n\t\t\tBucketName:      bucketName,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      \"\",\n\t\t\tClaims:          cred.Claims,\n\t\t}) {\n\t\t\trd = true\n\t\t}\n\n\t\tif globalIAMSys.IsAllowed(policy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          policy.GetBucketLocationAction,\n\t\t\tBucketName:      bucketName,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      \"\",\n\t\t\tClaims:          cred.Claims,\n\t\t}) {\n\t\t\trd = true\n\t\t}\n\n\t\tif globalIAMSys.IsAllowed(policy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          policy.PutObjectAction,\n\t\t\tBucketName:      bucketName,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      \"\",\n\t\t\tClaims:          cred.Claims,\n\t\t}) {\n\t\t\twr = true\n\t\t}\n\n\t\treturn rd, wr\n\t}\n\n\tbucketStorageCache.Once.Do(func() {\n\t\t// Set this to 10 secs since its enough, as scanner\n\t\t// does not update the bucket usage values frequently.\n\t\tbucketStorageCache.TTL = 10 * time.Second\n\n\t\t// Rely on older value if usage loading fails from disk.\n\t\tbucketStorageCache.Relax = true\n\t\tbucketStorageCache.Update = func() (interface{}, error) {\n\t\t\tctx, done := context.WithTimeout(context.Background(), 2*time.Second)\n\t\t\tdefer done()\n\n\t\t\treturn loadDataUsageFromBackend(ctx, objectAPI)\n\t\t}\n\t})\n\n\tvar dataUsageInfo DataUsageInfo\n\tv, _ := bucketStorageCache.Get()\n\tif v != nil {\n\t\tdataUsageInfo, _ = v.(DataUsageInfo)\n\t}\n\n\t// If etcd, dns federation configured list buckets from etcd.\n\tvar err error\n\tvar buckets []BucketInfo\n\tif globalDNSConfig != nil && globalBucketFederation {\n\t\tdnsBuckets, err := globalDNSConfig.List()\n\t\tif err != nil && !IsErrIgnored(err,\n\t\t\tdns.ErrNoEntriesFound,\n\t\t\tdns.ErrDomainMissing) {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\tfor _, dnsRecords := range dnsBuckets {\n\t\t\tbuckets = append(buckets, BucketInfo{\n\t\t\t\tName:    dnsRecords[0].Key,\n\t\t\t\tCreated: dnsRecords[0].CreationDate,\n\t\t\t})\n\t\t}\n\t\tsort.Slice(buckets, func(i, j int) bool {\n\t\t\treturn buckets[i].Name < buckets[j].Name\n\t\t})\n\t} else {\n\t\tbuckets, err = objectAPI.ListBuckets(ctx, BucketOptions{Cached: true})\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\taccountName := cred.AccessKey\n\tif cred.IsTemp() || cred.IsServiceAccount() {\n\t\t// For derived credentials, check the parent user's permissions.\n\t\taccountName = cred.ParentUser\n\t}\n\n\troleArn := policy.Args{Claims: cred.Claims}.GetRoleArn()\n\tpolicySetFromClaims, hasPolicyClaim := policy.GetPoliciesFromClaims(cred.Claims, iamPolicyClaimNameOpenID())\n\tvar effectivePolicy policy.Policy\n\n\tvar buf []byte\n\tswitch {\n\tcase accountName == globalActiveCred.AccessKey:\n\t\tfor _, policy := range policy.DefaultPolicies {\n\t\t\tif policy.Name == \"consoleAdmin\" {\n\t\t\t\teffectivePolicy = policy.Definition\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\tcase roleArn != \"\":\n\t\t_, policy, err := globalIAMSys.GetRolePolicy(roleArn)\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\tpolicySlice := newMappedPolicy(policy).toSlice()\n\t\teffectivePolicy = globalIAMSys.GetCombinedPolicy(policySlice...)\n\n\tcase hasPolicyClaim:\n\t\teffectivePolicy = globalIAMSys.GetCombinedPolicy(policySetFromClaims.ToSlice()...)\n\n\tdefault:\n\t\tpolicies, err := globalIAMSys.PolicyDBGet(accountName, cred.Groups...)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, err)\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\teffectivePolicy = globalIAMSys.GetCombinedPolicy(policies...)\n\n\t}\n\tbuf, err = json.MarshalIndent(effectivePolicy, \"\", \" \")\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tacctInfo := madmin.AccountInfo{\n\t\tAccountName: accountName,\n\t\tServer:      objectAPI.BackendInfo(),\n\t\tPolicy:      buf,\n\t}\n\n\tfor _, bucket := range buckets {\n\t\trd, wr := isAllowedAccess(bucket.Name)\n\t\tif rd || wr {\n\t\t\t// Fetch the data usage of the current bucket\n\t\t\tvar size uint64\n\t\t\tvar objectsCount uint64\n\t\t\tvar objectsHist, versionsHist map[string]uint64\n\t\t\tif !dataUsageInfo.LastUpdate.IsZero() {\n\t\t\t\tsize = dataUsageInfo.BucketsUsage[bucket.Name].Size\n\t\t\t\tobjectsCount = dataUsageInfo.BucketsUsage[bucket.Name].ObjectsCount\n\t\t\t\tobjectsHist = dataUsageInfo.BucketsUsage[bucket.Name].ObjectSizesHistogram\n\t\t\t\tversionsHist = dataUsageInfo.BucketsUsage[bucket.Name].ObjectVersionsHistogram\n\t\t\t}\n\t\t\t// Fetch the prefix usage of the current bucket\n\t\t\tvar prefixUsage map[string]uint64\n\t\t\tif enablePrefixUsage {\n\t\t\t\tprefixUsage, _ = loadPrefixUsageFromBackend(ctx, objectAPI, bucket.Name)\n\t\t\t}\n\n\t\t\tlcfg, _ := globalBucketObjectLockSys.Get(bucket.Name)\n\t\t\tquota, _ := globalBucketQuotaSys.Get(ctx, bucket.Name)\n\t\t\trcfg, _, _ := globalBucketMetadataSys.GetReplicationConfig(ctx, bucket.Name)\n\t\t\ttcfg, _, _ := globalBucketMetadataSys.GetTaggingConfig(bucket.Name)\n\n\t\t\tacctInfo.Buckets = append(acctInfo.Buckets, madmin.BucketAccessInfo{\n\t\t\t\tName:                    bucket.Name,\n\t\t\t\tCreated:                 bucket.Created,\n\t\t\t\tSize:                    size,\n\t\t\t\tObjects:                 objectsCount,\n\t\t\t\tObjectSizesHistogram:    objectsHist,\n\t\t\t\tObjectVersionsHistogram: versionsHist,\n\t\t\t\tPrefixUsage:             prefixUsage,\n\t\t\t\tDetails: &madmin.BucketDetails{\n\t\t\t\t\tVersioning:          globalBucketVersioningSys.Enabled(bucket.Name),\n\t\t\t\t\tVersioningSuspended: globalBucketVersioningSys.Suspended(bucket.Name),\n\t\t\t\t\tReplication:         rcfg != nil,\n\t\t\t\t\tLocking:             lcfg.LockEnabled,\n\t\t\t\t\tQuota:               quota,\n\t\t\t\t\tTagging:             tcfg,\n\t\t\t\t},\n\t\t\t\tAccess: madmin.AccountAccess{\n\t\t\t\t\tRead:  rd,\n\t\t\t\t\tWrite: wr,\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t}\n\n\tusageInfoJSON, err := json.Marshal(acctInfo)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, usageInfoJSON)\n}\n\n// InfoCannedPolicy - GET /minio/admin/v3/info-canned-policy?name={policyName}\n//\n// Newer API response with policy timestamps is returned with query parameter\n// `v=2` like:\n//\n// GET /minio/admin/v3/info-canned-policy?name={policyName}&v=2\n//\n// The newer API will eventually become the default (and only) one. The older\n// response is to return only the policy JSON. The newer response returns\n// timestamps along with the policy JSON. Both versions are supported for now,\n// for smooth transition to new API.\nfunc (a adminAPIHandlers) InfoCannedPolicy(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, policy.GetPolicyAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tname := mux.Vars(r)[\"name\"]\n\tpolicies := newMappedPolicy(name).toSlice()\n\tif len(policies) != 1 {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errTooManyPolicies), r.URL)\n\t\treturn\n\t}\n\n\tpolicyDoc, err := globalIAMSys.InfoPolicy(name)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Is the new API version being requested?\n\tinfoPolicyAPIVersion := r.Form.Get(\"v\")\n\tif infoPolicyAPIVersion == \"2\" {\n\t\tbuf, err := json.MarshalIndent(policyDoc, \"\", \" \")\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\tw.Write(buf)\n\t\treturn\n\t} else if infoPolicyAPIVersion != \"\" {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errors.New(\"invalid version parameter 'v' supplied\")), r.URL)\n\t\treturn\n\t}\n\n\t// Return the older API response value of just the policy json.\n\tbuf, err := json.MarshalIndent(policyDoc.Policy, \"\", \" \")\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\tw.Write(buf)\n}\n\n// ListBucketPolicies - GET /minio/admin/v3/list-canned-policies?bucket={bucket}\nfunc (a adminAPIHandlers) ListBucketPolicies(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, policy.ListUserPoliciesAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tbucket := mux.Vars(r)[\"bucket\"]\n\tpolicies, err := globalIAMSys.ListPolicies(ctx, bucket)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tnewPolicies := make(map[string]policy.Policy)\n\tfor name, p := range policies {\n\t\t_, err = json.Marshal(p)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, err)\n\t\t\tcontinue\n\t\t}\n\t\tnewPolicies[name] = p\n\t}\n\tif err = json.NewEncoder(w).Encode(newPolicies); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n}\n\n// ListCannedPolicies - GET /minio/admin/v3/list-canned-policies\nfunc (a adminAPIHandlers) ListCannedPolicies(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, policy.ListUserPoliciesAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tpolicies, err := globalIAMSys.ListPolicies(ctx, \"\")\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tnewPolicies := make(map[string]policy.Policy)\n\tfor name, p := range policies {\n\t\t_, err = json.Marshal(p)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, err)\n\t\t\tcontinue\n\t\t}\n\t\tnewPolicies[name] = p\n\t}\n\tif err = json.NewEncoder(w).Encode(newPolicies); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n}\n\n// RemoveCannedPolicy - DELETE /minio/admin/v3/remove-canned-policy?name=<policy_name>\nfunc (a adminAPIHandlers) RemoveCannedPolicy(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, policy.DeletePolicyAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\tpolicyName := vars[\"name\"]\n\n\tif err := globalIAMSys.DeletePolicy(ctx, policyName, true); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Call cluster-replication policy creation hook to replicate policy deletion to\n\t// other minio clusters.\n\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType:      madmin.SRIAMItemPolicy,\n\t\tName:      policyName,\n\t\tUpdatedAt: UTCNow(),\n\t}))\n}\n\n// AddCannedPolicy - PUT /minio/admin/v3/add-canned-policy?name=<policy_name>\nfunc (a adminAPIHandlers) AddCannedPolicy(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, policy.CreatePolicyAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\tpolicyName := vars[\"name\"]\n\n\t// Policy has space characters in begin and end reject such inputs.\n\tif hasSpaceBE(policyName) {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminResourceInvalidArgument), r.URL)\n\t\treturn\n\t}\n\n\t// Error out if Content-Length is missing.\n\tif r.ContentLength <= 0 {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrMissingContentLength), r.URL)\n\t\treturn\n\t}\n\n\t// Error out if Content-Length is beyond allowed size.\n\tif r.ContentLength > maxBucketPolicySize {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrEntityTooLarge), r.URL)\n\t\treturn\n\t}\n\n\tiamPolicyBytes, err := io.ReadAll(io.LimitReader(r.Body, r.ContentLength))\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tiamPolicy, err := policy.ParseConfig(bytes.NewReader(iamPolicyBytes))\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Version in policy must not be empty\n\tif iamPolicy.Version == \"\" {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrPolicyInvalidVersion), r.URL)\n\t\treturn\n\t}\n\n\tupdatedAt, err := globalIAMSys.SetPolicy(ctx, policyName, *iamPolicy)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Call cluster-replication policy creation hook to replicate policy to\n\t// other minio clusters.\n\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType:      madmin.SRIAMItemPolicy,\n\t\tName:      policyName,\n\t\tPolicy:    iamPolicyBytes,\n\t\tUpdatedAt: updatedAt,\n\t}))\n}\n\n// SetPolicyForUserOrGroup - PUT /minio/admin/v3/set-policy?policy=xxx&user-or-group=?[&is-group]\nfunc (a adminAPIHandlers) SetPolicyForUserOrGroup(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, policy.AttachPolicyAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\tpolicyName := vars[\"policyName\"]\n\tentityName := vars[\"userOrGroup\"]\n\tisGroup := vars[\"isGroup\"] == \"true\"\n\n\tif !isGroup {\n\t\tok, _, err := globalIAMSys.IsTempUser(entityName)\n\t\tif err != nil && err != errNoSuchUser {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\tif ok {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errIAMActionNotAllowed), r.URL)\n\t\t\treturn\n\t\t}\n\t\t// When the user is root credential you are not allowed to\n\t\t// add policies for root user.\n\t\tif entityName == globalActiveCred.AccessKey {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errIAMActionNotAllowed), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Validate that user or group exists.\n\tif !isGroup {\n\t\tif globalIAMSys.GetUsersSysType() == MinIOUsersSysType {\n\t\t\t_, ok := globalIAMSys.GetUser(ctx, entityName)\n\t\t\tif !ok {\n\t\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errNoSuchUser), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t} else {\n\t\t_, err := globalIAMSys.GetGroupDescription(entityName)\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\tuserType := regUser\n\tif globalIAMSys.GetUsersSysType() == LDAPUsersSysType {\n\t\tuserType = stsUser\n\t}\n\n\tupdatedAt, err := globalIAMSys.PolicyDBSet(ctx, entityName, policyName, userType, isGroup)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemPolicyMapping,\n\t\tPolicyMapping: &madmin.SRPolicyMapping{\n\t\t\tUserOrGroup: entityName,\n\t\t\tUserType:    int(userType),\n\t\t\tIsGroup:     isGroup,\n\t\t\tPolicy:      policyName,\n\t\t},\n\t\tUpdatedAt: updatedAt,\n\t}))\n}\n\n// ListPolicyMappingEntities - GET /minio/admin/v3/idp/builtin/polciy-entities?policy=xxx&user=xxx&group=xxx\nfunc (a adminAPIHandlers) ListPolicyMappingEntities(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\t// Check authorization.\n\tobjectAPI, cred := validateAdminReq(ctx, w, r,\n\t\tpolicy.ListGroupsAdminAction, policy.ListUsersAdminAction, policy.ListUserPoliciesAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\t// Validate API arguments.\n\tq := madmin.PolicyEntitiesQuery{\n\t\tUsers:  r.Form[\"user\"],\n\t\tGroups: r.Form[\"group\"],\n\t\tPolicy: r.Form[\"policy\"],\n\t}\n\n\t// Query IAM\n\tres, err := globalIAMSys.QueryPolicyEntities(r.Context(), q)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Encode result and send response.\n\tdata, err := json.Marshal(res)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\tpassword := cred.SecretKey\n\teconfigData, err := madmin.EncryptData(password, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\twriteSuccessResponseJSON(w, econfigData)\n}\n\n// AttachDetachPolicyBuiltin - POST /minio/admin/v3/idp/builtin/policy/{operation}\nfunc (a adminAPIHandlers) AttachDetachPolicyBuiltin(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tobjectAPI, cred := validateAdminReq(ctx, w, r, policy.UpdatePolicyAssociationAction,\n\t\tpolicy.AttachPolicyAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tif r.ContentLength > maxEConfigJSONSize || r.ContentLength == -1 {\n\t\t// More than maxConfigSize bytes were available\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminConfigTooLarge), r.URL)\n\t\treturn\n\t}\n\n\t// Ensure body content type is opaque to ensure that request body has not\n\t// been interpreted as form data.\n\tcontentType := r.Header.Get(\"Content-Type\")\n\tif contentType != \"application/octet-stream\" {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrBadRequest), r.URL)\n\t\treturn\n\t}\n\n\toperation := mux.Vars(r)[\"operation\"]\n\tif operation != \"attach\" && operation != \"detach\" {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminInvalidArgument), r.URL)\n\t\treturn\n\t}\n\tisAttach := operation == \"attach\"\n\n\tpassword := cred.SecretKey\n\treqBytes, err := madmin.DecryptData(password, io.LimitReader(r.Body, r.ContentLength))\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tvar par madmin.PolicyAssociationReq\n\tif err = json.Unmarshal(reqBytes, &par); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tif err = par.IsValid(); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tupdatedAt, addedOrRemoved, _, err := globalIAMSys.PolicyDBUpdateBuiltin(ctx, isAttach, par)\n\tif err != nil {\n\t\tif err == errNoSuchUser || err == errNoSuchGroup {\n\t\t\tif globalIAMSys.LDAPConfig.Enabled() {\n\t\t\t\t// When LDAP is enabled, warn user that they are using the wrong\n\t\t\t\t// API. FIXME: error can be no such group as well - fix errNoSuchUserLDAPWarn\n\t\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errNoSuchUserLDAPWarn), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\trespBody := madmin.PolicyAssociationResp{\n\t\tUpdatedAt: updatedAt,\n\t}\n\tif isAttach {\n\t\trespBody.PoliciesAttached = addedOrRemoved\n\t} else {\n\t\trespBody.PoliciesDetached = addedOrRemoved\n\t}\n\n\tdata, err := json.Marshal(respBody)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tencryptedData, err := madmin.EncryptData(password, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, encryptedData)\n}\n\nconst (\n\tallPoliciesFile            = \"policies.json\"\n\tallUsersFile               = \"users.json\"\n\tallGroupsFile              = \"groups.json\"\n\tallSvcAcctsFile            = \"svcaccts.json\"\n\tuserPolicyMappingsFile     = \"user_mappings.json\"\n\tgroupPolicyMappingsFile    = \"group_mappings.json\"\n\tstsUserPolicyMappingsFile  = \"stsuser_mappings.json\"\n\tstsGroupPolicyMappingsFile = \"stsgroup_mappings.json\"\n\tiamAssetsDir               = \"iam-assets\"\n)\n\n// ExportIAMHandler - exports all iam info as a zipped file\nfunc (a adminAPIHandlers) ExportIAM(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\t// Get current object layer instance.\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, policy.ExportIAMAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\t// Initialize a zip writer which will provide a zipped content\n\t// of bucket metadata\n\tzipWriter := zip.NewWriter(w)\n\tdefer zipWriter.Close()\n\trawDataFn := func(r io.Reader, filename string, sz int) error {\n\t\theader, zerr := zip.FileInfoHeader(dummyFileInfo{\n\t\t\tname:    filename,\n\t\t\tsize:    int64(sz),\n\t\t\tmode:    0o600,\n\t\t\tmodTime: time.Now(),\n\t\t\tisDir:   false,\n\t\t\tsys:     nil,\n\t\t})\n\t\tif zerr != nil {\n\t\t\tlogger.LogIf(ctx, zerr)\n\t\t\treturn nil\n\t\t}\n\t\theader.Method = zip.Deflate\n\t\tzwriter, zerr := zipWriter.CreateHeader(header)\n\t\tif zerr != nil {\n\t\t\tlogger.LogIf(ctx, zerr)\n\t\t\treturn nil\n\t\t}\n\t\tif _, err := io.Copy(zwriter, r); err != nil {\n\t\t\tlogger.LogIf(ctx, err)\n\t\t}\n\t\treturn nil\n\t}\n\n\tiamFiles := []string{\n\t\tallPoliciesFile,\n\t\tallUsersFile,\n\t\tallGroupsFile,\n\t\tallSvcAcctsFile,\n\t\tuserPolicyMappingsFile,\n\t\tgroupPolicyMappingsFile,\n\t\tstsUserPolicyMappingsFile,\n\t\tstsGroupPolicyMappingsFile,\n\t}\n\tfor _, f := range iamFiles {\n\t\tiamFile := pathJoin(iamAssetsDir, f)\n\t\tswitch f {\n\t\tcase allPoliciesFile:\n\t\t\tallPolicies, err := globalIAMSys.ListPolicies(ctx, \"\")\n\t\t\tif err != nil {\n\t\t\t\tlogger.LogIf(ctx, err)\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tpoliciesData, err := json.Marshal(allPolicies)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err = rawDataFn(bytes.NewReader(policiesData), iamFile, len(policiesData)); err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase allUsersFile:\n\t\t\tuserIdentities := make(map[string]UserIdentity)\n\t\t\terr := globalIAMSys.store.loadUsers(ctx, regUser, userIdentities)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tuserAccounts := make(map[string]madmin.AddOrUpdateUserReq)\n\t\t\tfor u, uid := range userIdentities {\n\t\t\t\tuserAccounts[u] = madmin.AddOrUpdateUserReq{\n\t\t\t\t\tSecretKey: uid.Credentials.SecretKey,\n\t\t\t\t\tStatus: func() madmin.AccountStatus {\n\t\t\t\t\t\t// Export current credential status\n\t\t\t\t\t\tif uid.Credentials.Status == auth.AccountOff {\n\t\t\t\t\t\t\treturn madmin.AccountDisabled\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn madmin.AccountEnabled\n\t\t\t\t\t}(),\n\t\t\t\t}\n\t\t\t}\n\t\t\tuserData, err := json.Marshal(userAccounts)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err = rawDataFn(bytes.NewReader(userData), iamFile, len(userData)); err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase allGroupsFile:\n\t\t\tgroups := make(map[string]GroupInfo)\n\t\t\terr := globalIAMSys.store.loadGroups(ctx, groups)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgroupData, err := json.Marshal(groups)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err = rawDataFn(bytes.NewReader(groupData), iamFile, len(groupData)); err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase allSvcAcctsFile:\n\t\t\tserviceAccounts := make(map[string]UserIdentity)\n\t\t\terr := globalIAMSys.store.loadUsers(ctx, svcUser, serviceAccounts)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tsvcAccts := make(map[string]madmin.SRSvcAccCreate)\n\t\t\tfor user, acc := range serviceAccounts {\n\t\t\t\tif user == siteReplicatorSvcAcc {\n\t\t\t\t\t// skip site-replication service account.\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tclaims, err := globalIAMSys.GetClaimsForSvcAcc(ctx, acc.Credentials.AccessKey)\n\t\t\t\tif err != nil {\n\t\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\t_, policy, err := globalIAMSys.GetServiceAccount(ctx, acc.Credentials.AccessKey)\n\t\t\t\tif err != nil {\n\t\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tvar policyJSON []byte\n\t\t\t\tif policy != nil {\n\t\t\t\t\tpolicyJSON, err = json.Marshal(policy)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsvcAccts[user] = madmin.SRSvcAccCreate{\n\t\t\t\t\tParent:        acc.Credentials.ParentUser,\n\t\t\t\t\tAccessKey:     user,\n\t\t\t\t\tSecretKey:     acc.Credentials.SecretKey,\n\t\t\t\t\tGroups:        acc.Credentials.Groups,\n\t\t\t\t\tClaims:        claims,\n\t\t\t\t\tSessionPolicy: json.RawMessage(policyJSON),\n\t\t\t\t\tStatus:        acc.Credentials.Status,\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsvcAccData, err := json.Marshal(svcAccts)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err = rawDataFn(bytes.NewReader(svcAccData), iamFile, len(svcAccData)); err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase userPolicyMappingsFile:\n\t\t\tuserPolicyMap := make(map[string]MappedPolicy)\n\t\t\terr := globalIAMSys.store.loadMappedPolicies(ctx, regUser, false, userPolicyMap)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tuserPolData, err := json.Marshal(userPolicyMap)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err = rawDataFn(bytes.NewReader(userPolData), iamFile, len(userPolData)); err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase groupPolicyMappingsFile:\n\t\t\tgroupPolicyMap := make(map[string]MappedPolicy)\n\t\t\terr := globalIAMSys.store.loadMappedPolicies(ctx, regUser, true, groupPolicyMap)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgrpPolData, err := json.Marshal(groupPolicyMap)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err = rawDataFn(bytes.NewReader(grpPolData), iamFile, len(grpPolData)); err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase stsUserPolicyMappingsFile:\n\t\t\tuserPolicyMap := make(map[string]MappedPolicy)\n\t\t\terr := globalIAMSys.store.loadMappedPolicies(ctx, stsUser, false, userPolicyMap)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tuserPolData, err := json.Marshal(userPolicyMap)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err = rawDataFn(bytes.NewReader(userPolData), iamFile, len(userPolData)); err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase stsGroupPolicyMappingsFile:\n\t\t\tgroupPolicyMap := make(map[string]MappedPolicy)\n\t\t\terr := globalIAMSys.store.loadMappedPolicies(ctx, stsUser, true, groupPolicyMap)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgrpPolData, err := json.Marshal(groupPolicyMap)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err = rawDataFn(bytes.NewReader(grpPolData), iamFile, len(grpPolData)); err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ImportIAM - imports all IAM info into MinIO\nfunc (a adminAPIHandlers) ImportIAM(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\tcred, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\tdata, err := io.ReadAll(r.Body)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n\t\treturn\n\t}\n\treader := bytes.NewReader(data)\n\tzr, err := zip.NewReader(reader, int64(len(data)))\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n\t\treturn\n\t}\n\t// import policies first\n\t{\n\n\t\tf, err := zr.Open(pathJoin(iamAssetsDir, allPoliciesFile))\n\t\tswitch {\n\t\tcase errors.Is(err, os.ErrNotExist):\n\t\tcase err != nil:\n\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, allPoliciesFile, \"\"), r.URL)\n\t\t\treturn\n\t\tdefault:\n\t\t\tdefer f.Close()\n\t\t\tvar allPolicies map[string]policy.Policy\n\t\t\tdata, err = io.ReadAll(f)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, allPoliciesFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = json.Unmarshal(data, &allPolicies)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminConfigBadJSON, err, allPoliciesFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor policyName, policy := range allPolicies {\n\t\t\t\tif policy.IsEmpty() {\n\t\t\t\t\terr = globalIAMSys.DeletePolicy(ctx, policyName, true)\n\t\t\t\t} else {\n\t\t\t\t\t_, err = globalIAMSys.SetPolicy(ctx, policyName, policy)\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, allPoliciesFile, policyName), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// import users\n\t{\n\t\tf, err := zr.Open(pathJoin(iamAssetsDir, allUsersFile))\n\t\tswitch {\n\t\tcase errors.Is(err, os.ErrNotExist):\n\t\tcase err != nil:\n\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, allUsersFile, \"\"), r.URL)\n\t\t\treturn\n\t\tdefault:\n\t\t\tdefer f.Close()\n\t\t\tvar userAccts map[string]madmin.AddOrUpdateUserReq\n\t\t\tdata, err := io.ReadAll(f)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, allUsersFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = json.Unmarshal(data, &userAccts)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminConfigBadJSON, err, allUsersFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor accessKey, ureq := range userAccts {\n\t\t\t\t// Not allowed to add a user with same access key as root credential\n\t\t\t\tif accessKey == globalActiveCred.AccessKey {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAddUserInvalidArgument, err, allUsersFile, accessKey), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tuser, exists := globalIAMSys.GetUser(ctx, accessKey)\n\t\t\t\tif exists && (user.Credentials.IsTemp() || user.Credentials.IsServiceAccount()) {\n\t\t\t\t\t// Updating STS credential is not allowed, and this API does not\n\t\t\t\t\t// support updating service accounts.\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAddUserInvalidArgument, err, allUsersFile, accessKey), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif (cred.IsTemp() || cred.IsServiceAccount()) && cred.ParentUser == accessKey {\n\t\t\t\t\t// Incoming access key matches parent user then we should\n\t\t\t\t\t// reject password change requests.\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAddUserInvalidArgument, err, allUsersFile, accessKey), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// Check if accessKey has beginning and end space characters, this only applies to new users.\n\t\t\t\tif !exists && hasSpaceBE(accessKey) {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminResourceInvalidArgument, err, allUsersFile, accessKey), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tcheckDenyOnly := false\n\t\t\t\tif accessKey == cred.AccessKey {\n\t\t\t\t\t// Check that there is no explicit deny - otherwise it's allowed\n\t\t\t\t\t// to change one's own password.\n\t\t\t\t\tcheckDenyOnly = true\n\t\t\t\t}\n\n\t\t\t\tif !globalIAMSys.IsAllowed(policy.Args{\n\t\t\t\t\tAccountName:     cred.AccessKey,\n\t\t\t\t\tGroups:          cred.Groups,\n\t\t\t\t\tAction:          policy.CreateUserAdminAction,\n\t\t\t\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\t\t\t\tIsOwner:         owner,\n\t\t\t\t\tClaims:          cred.Claims,\n\t\t\t\t\tDenyOnly:        checkDenyOnly,\n\t\t\t\t}) {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAccessDenied, err, allUsersFile, accessKey), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif _, err = globalIAMSys.CreateUser(ctx, accessKey, ureq); err != nil {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, toAdminAPIErrCode(ctx, err), err, allUsersFile, accessKey), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\t// import groups\n\t{\n\t\tf, err := zr.Open(pathJoin(iamAssetsDir, allGroupsFile))\n\t\tswitch {\n\t\tcase errors.Is(err, os.ErrNotExist):\n\t\tcase err != nil:\n\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, allGroupsFile, \"\"), r.URL)\n\t\t\treturn\n\t\tdefault:\n\t\t\tdefer f.Close()\n\t\t\tvar grpInfos map[string]GroupInfo\n\t\t\tdata, err := io.ReadAll(f)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, allGroupsFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err = json.Unmarshal(data, &grpInfos); err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminConfigBadJSON, err, allGroupsFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor group, grpInfo := range grpInfos {\n\t\t\t\t// Check if group already exists\n\t\t\t\tif _, gerr := globalIAMSys.GetGroupDescription(group); gerr != nil {\n\t\t\t\t\t// If group does not exist, then check if the group has beginning and end space characters\n\t\t\t\t\t// we will reject such group names.\n\t\t\t\t\tif errors.Is(gerr, errNoSuchGroup) && hasSpaceBE(group) {\n\t\t\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminResourceInvalidArgument, err, allGroupsFile, group), r.URL)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif _, gerr := globalIAMSys.AddUsersToGroup(ctx, group, grpInfo.Members); gerr != nil {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, allGroupsFile, group), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// import service accounts\n\t{\n\t\tf, err := zr.Open(pathJoin(iamAssetsDir, allSvcAcctsFile))\n\t\tswitch {\n\t\tcase errors.Is(err, os.ErrNotExist):\n\t\tcase err != nil:\n\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, allSvcAcctsFile, \"\"), r.URL)\n\t\t\treturn\n\t\tdefault:\n\t\t\tdefer f.Close()\n\t\t\tvar serviceAcctReqs map[string]madmin.SRSvcAccCreate\n\t\t\tdata, err := io.ReadAll(f)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, allSvcAcctsFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err = json.Unmarshal(data, &serviceAcctReqs); err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminConfigBadJSON, err, allSvcAcctsFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor user, svcAcctReq := range serviceAcctReqs {\n\t\t\t\tvar sp *policy.Policy\n\t\t\t\tvar err error\n\t\t\t\tif len(svcAcctReq.SessionPolicy) > 0 {\n\t\t\t\t\tsp, err = policy.ParseConfig(bytes.NewReader(svcAcctReq.SessionPolicy))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, allSvcAcctsFile, user), r.URL)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// service account access key cannot have space characters beginning and end of the string.\n\t\t\t\tif hasSpaceBE(svcAcctReq.AccessKey) {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminResourceInvalidArgument), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif !globalIAMSys.IsAllowed(policy.Args{\n\t\t\t\t\tAccountName:     cred.AccessKey,\n\t\t\t\t\tGroups:          cred.Groups,\n\t\t\t\t\tAction:          policy.CreateServiceAccountAdminAction,\n\t\t\t\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\t\t\t\tIsOwner:         owner,\n\t\t\t\t\tClaims:          cred.Claims,\n\t\t\t\t}) {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAccessDenied, err, allSvcAcctsFile, user), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tupdateReq := true\n\t\t\t\t_, _, err = globalIAMSys.GetServiceAccount(ctx, svcAcctReq.AccessKey)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif !errors.Is(err, errNoSuchServiceAccount) {\n\t\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, allSvcAcctsFile, user), r.URL)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tupdateReq = false\n\t\t\t\t}\n\t\t\t\tif updateReq {\n\t\t\t\t\topts := updateServiceAccountOpts{\n\t\t\t\t\t\tsecretKey:     svcAcctReq.SecretKey,\n\t\t\t\t\t\tstatus:        svcAcctReq.Status,\n\t\t\t\t\t\tname:          svcAcctReq.Name,\n\t\t\t\t\t\tdescription:   svcAcctReq.Description,\n\t\t\t\t\t\texpiration:    svcAcctReq.Expiration,\n\t\t\t\t\t\tsessionPolicy: sp,\n\t\t\t\t\t}\n\t\t\t\t\t_, err = globalIAMSys.UpdateServiceAccount(ctx, svcAcctReq.AccessKey, opts)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, allSvcAcctsFile, user), r.URL)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\topts := newServiceAccountOpts{\n\t\t\t\t\taccessKey:                  user,\n\t\t\t\t\tsecretKey:                  svcAcctReq.SecretKey,\n\t\t\t\t\tsessionPolicy:              sp,\n\t\t\t\t\tclaims:                     svcAcctReq.Claims,\n\t\t\t\t\tname:                       svcAcctReq.Name,\n\t\t\t\t\tdescription:                svcAcctReq.Description,\n\t\t\t\t\texpiration:                 svcAcctReq.Expiration,\n\t\t\t\t\tallowSiteReplicatorAccount: false,\n\t\t\t\t}\n\n\t\t\t\t// In case of LDAP we need to resolve the targetUser to a DN and\n\t\t\t\t// query their groups:\n\t\t\t\tif globalIAMSys.LDAPConfig.Enabled() {\n\t\t\t\t\topts.claims[ldapUserN] = svcAcctReq.AccessKey // simple username\n\t\t\t\t\ttargetUser, _, err := globalIAMSys.LDAPConfig.LookupUserDN(svcAcctReq.AccessKey)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, allSvcAcctsFile, user), r.URL)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\topts.claims[ldapUser] = targetUser // username DN\n\t\t\t\t}\n\n\t\t\t\tif _, _, err = globalIAMSys.NewServiceAccount(ctx, svcAcctReq.Parent, svcAcctReq.Groups, opts); err != nil {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, allSvcAcctsFile, user), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\t// import user policy mappings\n\t{\n\t\tf, err := zr.Open(pathJoin(iamAssetsDir, userPolicyMappingsFile))\n\t\tswitch {\n\t\tcase errors.Is(err, os.ErrNotExist):\n\t\tcase err != nil:\n\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, userPolicyMappingsFile, \"\"), r.URL)\n\t\t\treturn\n\t\tdefault:\n\t\t\tdefer f.Close()\n\t\t\tvar userPolicyMap map[string]MappedPolicy\n\t\t\tdata, err := io.ReadAll(f)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, userPolicyMappingsFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err = json.Unmarshal(data, &userPolicyMap); err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminConfigBadJSON, err, userPolicyMappingsFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor u, pm := range userPolicyMap {\n\t\t\t\t// disallow setting policy mapping if user is a temporary user\n\t\t\t\tok, _, err := globalIAMSys.IsTempUser(u)\n\t\t\t\tif err != nil && err != errNoSuchUser {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, userPolicyMappingsFile, u), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif ok {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, errIAMActionNotAllowed, userPolicyMappingsFile, u), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif _, err := globalIAMSys.PolicyDBSet(ctx, u, pm.Policies, regUser, false); err != nil {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, userPolicyMappingsFile, u), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// import group policy mappings\n\t{\n\t\tf, err := zr.Open(pathJoin(iamAssetsDir, groupPolicyMappingsFile))\n\t\tswitch {\n\t\tcase errors.Is(err, os.ErrNotExist):\n\t\tcase err != nil:\n\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, groupPolicyMappingsFile, \"\"), r.URL)\n\t\t\treturn\n\t\tdefault:\n\t\t\tdefer f.Close()\n\t\t\tvar grpPolicyMap map[string]MappedPolicy\n\t\t\tdata, err := io.ReadAll(f)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, groupPolicyMappingsFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err = json.Unmarshal(data, &grpPolicyMap); err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminConfigBadJSON, err, groupPolicyMappingsFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor g, pm := range grpPolicyMap {\n\t\t\t\tif _, err := globalIAMSys.PolicyDBSet(ctx, g, pm.Policies, unknownIAMUserType, true); err != nil {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, groupPolicyMappingsFile, g), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// import sts user policy mappings\n\t{\n\t\tf, err := zr.Open(pathJoin(iamAssetsDir, stsUserPolicyMappingsFile))\n\t\tswitch {\n\t\tcase errors.Is(err, os.ErrNotExist):\n\t\tcase err != nil:\n\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, stsUserPolicyMappingsFile, \"\"), r.URL)\n\t\t\treturn\n\t\tdefault:\n\t\t\tdefer f.Close()\n\t\t\tvar userPolicyMap map[string]MappedPolicy\n\t\t\tdata, err := io.ReadAll(f)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, stsUserPolicyMappingsFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err = json.Unmarshal(data, &userPolicyMap); err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminConfigBadJSON, err, stsUserPolicyMappingsFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor u, pm := range userPolicyMap {\n\t\t\t\t// disallow setting policy mapping if user is a temporary user\n\t\t\t\tok, _, err := globalIAMSys.IsTempUser(u)\n\t\t\t\tif err != nil && err != errNoSuchUser {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, stsUserPolicyMappingsFile, u), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif ok {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, errIAMActionNotAllowed, stsUserPolicyMappingsFile, u), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif _, err := globalIAMSys.PolicyDBSet(ctx, u, pm.Policies, stsUser, false); err != nil {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, stsUserPolicyMappingsFile, u), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// import sts group policy mappings\n\t{\n\t\tf, err := zr.Open(pathJoin(iamAssetsDir, stsGroupPolicyMappingsFile))\n\t\tswitch {\n\t\tcase errors.Is(err, os.ErrNotExist):\n\t\tcase err != nil:\n\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, stsGroupPolicyMappingsFile, \"\"), r.URL)\n\t\t\treturn\n\t\tdefault:\n\t\t\tdefer f.Close()\n\t\t\tvar grpPolicyMap map[string]MappedPolicy\n\t\t\tdata, err := io.ReadAll(f)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, stsGroupPolicyMappingsFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err = json.Unmarshal(data, &grpPolicyMap); err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminConfigBadJSON, err, stsGroupPolicyMappingsFile, \"\"), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor g, pm := range grpPolicyMap {\n\t\t\t\tif _, err := globalIAMSys.PolicyDBSet(ctx, g, pm.Policies, unknownIAMUserType, true); err != nil {\n\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, stsGroupPolicyMappingsFile, g), r.URL)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc commonAddServiceAccount(r *http.Request) (context.Context, auth.Credentials, newServiceAccountOpts, madmin.AddServiceAccountReq, string, APIError) {\n\tctx := r.Context()\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\treturn ctx, auth.Credentials{}, newServiceAccountOpts{}, madmin.AddServiceAccountReq{}, \"\", errorCodes.ToAPIErr(ErrServerNotInitialized)\n\t}\n\n\tcred, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\treturn ctx, auth.Credentials{}, newServiceAccountOpts{}, madmin.AddServiceAccountReq{}, \"\", errorCodes.ToAPIErr(s3Err)\n\t}\n\n\tpassword := cred.SecretKey\n\treqBytes, err := madmin.DecryptData(password, io.LimitReader(r.Body, r.ContentLength))\n\tif err != nil {\n\t\treturn ctx, auth.Credentials{}, newServiceAccountOpts{}, madmin.AddServiceAccountReq{}, \"\", errorCodes.ToAPIErrWithErr(ErrAdminConfigBadJSON, err)\n\t}\n\n\tvar createReq madmin.AddServiceAccountReq\n\tif err = json.Unmarshal(reqBytes, &createReq); err != nil {\n\t\treturn ctx, auth.Credentials{}, newServiceAccountOpts{}, madmin.AddServiceAccountReq{}, \"\", errorCodes.ToAPIErrWithErr(ErrAdminConfigBadJSON, err)\n\t}\n\n\t// service account access key cannot have space characters beginning and end of the string.\n\tif hasSpaceBE(createReq.AccessKey) {\n\t\treturn ctx, auth.Credentials{}, newServiceAccountOpts{}, madmin.AddServiceAccountReq{}, \"\", errorCodes.ToAPIErr(ErrAdminResourceInvalidArgument)\n\t}\n\n\tif err := createReq.Validate(); err != nil {\n\t\t// Since this validation would happen client side as well, we only send\n\t\t// a generic error message here.\n\t\treturn ctx, auth.Credentials{}, newServiceAccountOpts{}, madmin.AddServiceAccountReq{}, \"\", errorCodes.ToAPIErr(ErrAdminResourceInvalidArgument)\n\t}\n\t// If the request did not set a TargetUser, the service account is\n\t// created for the request sender.\n\ttargetUser := createReq.TargetUser\n\tif targetUser == \"\" {\n\t\ttargetUser = cred.AccessKey\n\t}\n\n\tdescription := createReq.Description\n\tif description == \"\" {\n\t\tdescription = createReq.Comment\n\t}\n\topts := newServiceAccountOpts{\n\t\taccessKey:   createReq.AccessKey,\n\t\tsecretKey:   createReq.SecretKey,\n\t\tname:        createReq.Name,\n\t\tdescription: description,\n\t\texpiration:  createReq.Expiration,\n\t\tclaims:      make(map[string]interface{}),\n\t}\n\n\t// Check if action is allowed if creating access key for another user\n\t// Check if action is explicitly denied if for self\n\tif !globalIAMSys.IsAllowed(policy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          policy.CreateServiceAccountAdminAction,\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t\tDenyOnly:        (targetUser == cred.AccessKey || targetUser == cred.ParentUser),\n\t}) {\n\t\treturn ctx, auth.Credentials{}, newServiceAccountOpts{}, madmin.AddServiceAccountReq{}, \"\", errorCodes.ToAPIErr(ErrAccessDenied)\n\t}\n\n\tvar sp *policy.Policy\n\tif len(createReq.Policy) > 0 {\n\t\tsp, err = policy.ParseConfig(bytes.NewReader(createReq.Policy))\n\t\tif err != nil {\n\t\t\treturn ctx, auth.Credentials{}, newServiceAccountOpts{}, madmin.AddServiceAccountReq{}, \"\", toAdminAPIErr(ctx, err)\n\t\t}\n\t}\n\n\topts.sessionPolicy = sp\n\n\treturn ctx, cred, opts, createReq, targetUser, APIError{}\n}\n", "// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/minio/madmin-go/v3\"\n\t\"github.com/minio/minio-go/v7\"\n\t\"github.com/minio/minio-go/v7/pkg/credentials\"\n\t\"github.com/minio/minio-go/v7/pkg/s3utils\"\n\t\"github.com/minio/minio-go/v7/pkg/set\"\n\t\"github.com/minio/minio-go/v7/pkg/signer\"\n\t\"github.com/minio/minio/internal/auth\"\n\t\"github.com/minio/pkg/v2/env\"\n)\n\nconst (\n\ttestDefaultTimeout = 30 * time.Second\n)\n\n// API suite container for IAM\ntype TestSuiteIAM struct {\n\tTestSuiteCommon\n\n\tServerTypeDescription string\n\n\t// Flag to turn on tests for etcd backend IAM\n\twithEtcdBackend bool\n\n\tendpoint string\n\tadm      *madmin.AdminClient\n\tclient   *minio.Client\n}\n\nfunc newTestSuiteIAM(c TestSuiteCommon, withEtcdBackend bool) *TestSuiteIAM {\n\tetcdStr := \"\"\n\tif withEtcdBackend {\n\t\tetcdStr = \" (with etcd backend)\"\n\t}\n\treturn &TestSuiteIAM{\n\t\tTestSuiteCommon:       c,\n\t\tServerTypeDescription: fmt.Sprintf(\"%s%s\", c.serverType, etcdStr),\n\t\twithEtcdBackend:       withEtcdBackend,\n\t}\n}\n\nfunc (s *TestSuiteIAM) iamSetup(c *check) {\n\tvar err error\n\t// strip url scheme from endpoint\n\ts.endpoint = strings.TrimPrefix(s.endPoint, \"http://\")\n\tif s.secure {\n\t\ts.endpoint = strings.TrimPrefix(s.endPoint, \"https://\")\n\t}\n\n\ts.adm, err = madmin.New(s.endpoint, s.accessKey, s.secretKey, s.secure)\n\tif err != nil {\n\t\tc.Fatalf(\"error creating admin client: %v\", err)\n\t}\n\t// Set transport, so that TLS is handled correctly.\n\ts.adm.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\ts.client, err = minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     credentials.NewStaticV4(s.accessKey, s.secretKey, \"\"),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"error creating minio client: %v\", err)\n\t}\n}\n\n// List of all IAM test suites (i.e. test server configuration combinations)\n// common to tests.\nvar iamTestSuites = func() []*TestSuiteIAM {\n\tbaseTestCases := []TestSuiteCommon{\n\t\t// Init and run test on ErasureSD backend with signature v4.\n\t\t{serverType: \"ErasureSD\", signer: signerV4},\n\t\t// Init and run test on ErasureSD backend, with tls enabled.\n\t\t{serverType: \"ErasureSD\", signer: signerV4, secure: true},\n\t\t// Init and run test on Erasure backend.\n\t\t{serverType: \"Erasure\", signer: signerV4},\n\t\t// Init and run test on ErasureSet backend.\n\t\t{serverType: \"ErasureSet\", signer: signerV4},\n\t}\n\ttestCases := []*TestSuiteIAM{}\n\tfor _, bt := range baseTestCases {\n\t\ttestCases = append(testCases,\n\t\t\tnewTestSuiteIAM(bt, false),\n\t\t\tnewTestSuiteIAM(bt, true),\n\t\t)\n\t}\n\treturn testCases\n}()\n\nconst (\n\tEnvTestEtcdBackend = \"_MINIO_ETCD_TEST_SERVER\"\n)\n\nfunc (s *TestSuiteIAM) setUpEtcd(c *check, etcdServer string) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tconfigCmds := []string{\n\t\t\"etcd\",\n\t\t\"endpoints=\" + etcdServer,\n\t\t\"path_prefix=\" + mustGetUUID(),\n\t}\n\t_, err := s.adm.SetConfigKV(ctx, strings.Join(configCmds, \" \"))\n\tif err != nil {\n\t\tc.Fatalf(\"unable to setup Etcd for tests: %v\", err)\n\t}\n\n\ts.RestartIAMSuite(c)\n}\n\nfunc (s *TestSuiteIAM) SetUpSuite(c *check) {\n\t// If etcd backend is specified and etcd server is not present, the test\n\t// is skipped.\n\tetcdServer := env.Get(EnvTestEtcdBackend, \"\")\n\tif s.withEtcdBackend && etcdServer == \"\" {\n\t\tc.Skip(\"Skipping etcd backend IAM test as no etcd server is configured.\")\n\t}\n\n\ts.TestSuiteCommon.SetUpSuite(c)\n\n\ts.iamSetup(c)\n\n\tif s.withEtcdBackend {\n\t\ts.setUpEtcd(c, etcdServer)\n\t}\n}\n\nfunc (s *TestSuiteIAM) RestartIAMSuite(c *check) {\n\ts.TestSuiteCommon.RestartTestServer(c)\n\n\ts.iamSetup(c)\n}\n\nfunc (s *TestSuiteIAM) getAdminClient(c *check, accessKey, secretKey, sessionToken string) *madmin.AdminClient {\n\tmadmClnt, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  credentials.NewStaticV4(accessKey, secretKey, sessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"error creating user admin client: %s\", err)\n\t}\n\tmadmClnt.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\treturn madmClnt\n}\n\nfunc (s *TestSuiteIAM) getUserClient(c *check, accessKey, secretKey, sessionToken string) *minio.Client {\n\tclient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     credentials.NewStaticV4(accessKey, secretKey, sessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"error creating user minio client: %s\", err)\n\t}\n\treturn client\n}\n\nfunc TestIAMInternalIDPServerSuite(t *testing.T) {\n\tif runtime.GOOS == globalWindowsOSName {\n\t\tt.Skip(\"windows is clunky disable these tests\")\n\t}\n\tfor i, testCase := range iamTestSuites {\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s\", i+1, testCase.ServerTypeDescription),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tsuite := testCase\n\t\t\t\tc := &check{t, testCase.serverType}\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tsuite.TestUserCreate(c)\n\t\t\t\tsuite.TestUserPolicyEscalationBug(c)\n\t\t\t\tsuite.TestPolicyCreate(c)\n\t\t\t\tsuite.TestCannedPolicies(c)\n\t\t\t\tsuite.TestGroupAddRemove(c)\n\t\t\t\tsuite.TestServiceAccountOpsByAdmin(c)\n\t\t\t\tsuite.TestServiceAccountPrivilegeEscalationBug(c)\n\t\t\t\tsuite.TestServiceAccountOpsByUser(c)\n\t\t\t\tsuite.TestAddServiceAccountPerms(c)\n\t\t\t\tsuite.TearDownSuite(c)\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestUserCreate(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\t// 1. Create a user.\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr := s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\t// 2. Check new user appears in listing\n\tusersMap, err := s.adm.ListUsers(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"error listing: %v\", err)\n\t}\n\tv, ok := usersMap[accessKey]\n\tif !ok {\n\t\tc.Fatalf(\"user not listed: %s\", accessKey)\n\t}\n\tc.Assert(v.Status, madmin.AccountEnabled)\n\n\t// 3. Associate policy and check that user can access\n\terr = s.adm.SetPolicy(ctx, \"readwrite\", accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"unable to set policy: %v\", err)\n\t}\n\n\tclient := s.getUserClient(c, accessKey, secretKey, \"\")\n\terr = client.MakeBucket(ctx, getRandomBucketName(), minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"user could not create bucket: %v\", err)\n\t}\n\n\t// 3.10. Check that user's password can be updated.\n\t_, newSecretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, newSecretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to update user's secret key: %v\", err)\n\t}\n\t// 3.10.1 Check that old password no longer works.\n\terr = client.MakeBucket(ctx, getRandomBucketName(), minio.MakeBucketOptions{})\n\tif err == nil {\n\t\tc.Fatalf(\"user was unexpectedly able to create bucket with bad password!\")\n\t}\n\t// 3.10.2 Check that new password works.\n\tclient = s.getUserClient(c, accessKey, newSecretKey, \"\")\n\terr = client.MakeBucket(ctx, getRandomBucketName(), minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"user could not create bucket: %v\", err)\n\t}\n\n\t// 4. Check that user can be disabled and verify it.\n\terr = s.adm.SetUserStatus(ctx, accessKey, madmin.AccountDisabled)\n\tif err != nil {\n\t\tc.Fatalf(\"could not set user account to disabled\")\n\t}\n\tusersMap, err = s.adm.ListUsers(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"error listing: %v\", err)\n\t}\n\tv, ok = usersMap[accessKey]\n\tif !ok {\n\t\tc.Fatalf(\"user was not listed after disabling: %s\", accessKey)\n\t}\n\tc.Assert(v.Status, madmin.AccountDisabled)\n\terr = client.MakeBucket(ctx, getRandomBucketName(), minio.MakeBucketOptions{})\n\tif err == nil {\n\t\tc.Fatalf(\"user account was not disabled!\")\n\t}\n\n\t// 5. Check that user can be deleted and verify it.\n\terr = s.adm.RemoveUser(ctx, accessKey)\n\tif err != nil {\n\t\tc.Fatalf(\"user could not be deleted: %v\", err)\n\t}\n\tusersMap, err = s.adm.ListUsers(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"error listing: %v\", err)\n\t}\n\t_, ok = usersMap[accessKey]\n\tif ok {\n\t\tc.Fatalf(\"user not deleted: %s\", accessKey)\n\t}\n\terr = client.MakeBucket(ctx, getRandomBucketName(), minio.MakeBucketOptions{})\n\tif err == nil {\n\t\tc.Fatalf(\"user account was not deleted!\")\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestUserPolicyEscalationBug(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// 2. Create a user, associate policy and verify access\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\t// 2.1 check that user does not have any access to the bucket\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustNotListObjects(ctx, uClient, bucket)\n\n\t// 2.2 create and associate policy to user\n\tpolicy := \"mypolicy-test-user-update\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\terr = s.adm.SetPolicy(ctx, policy, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\t// 2.3 check user has access to bucket\n\tc.mustListObjects(ctx, uClient, bucket)\n\t// 2.3 check that user cannot delete the bucket\n\terr = uClient.RemoveBucket(ctx, bucket)\n\tif err == nil || err.Error() != \"Access Denied.\" {\n\t\tc.Fatalf(\"bucket was deleted unexpectedly or got unexpected err: %v\", err)\n\t}\n\n\t// 3. Craft a request to update the user's permissions\n\tep := s.adm.GetEndpointURL()\n\turlValue := url.Values{}\n\turlValue.Add(\"accessKey\", accessKey)\n\tu, err := url.Parse(fmt.Sprintf(\"%s://%s/minio/admin/v3/add-user?%s\", ep.Scheme, ep.Host, s3utils.QueryEncode(urlValue)))\n\tif err != nil {\n\t\tc.Fatalf(\"unexpected url parse err: %v\", err)\n\t}\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPut, u.String(), nil)\n\tif err != nil {\n\t\tc.Fatalf(\"unexpected new request err: %v\", err)\n\t}\n\treqBodyArg := madmin.UserInfo{\n\t\tSecretKey:  secretKey,\n\t\tPolicyName: \"consoleAdmin\",\n\t\tStatus:     madmin.AccountEnabled,\n\t}\n\tbuf, err := json.Marshal(reqBodyArg)\n\tif err != nil {\n\t\tc.Fatalf(\"unexpected json encode err: %v\", err)\n\t}\n\tbuf, err = madmin.EncryptData(secretKey, buf)\n\tif err != nil {\n\t\tc.Fatalf(\"unexpected encryption err: %v\", err)\n\t}\n\n\treq.ContentLength = int64(len(buf))\n\tsum := sha256.Sum256(buf)\n\treq.Header.Set(\"X-Amz-Content-Sha256\", hex.EncodeToString(sum[:]))\n\treq.Body = io.NopCloser(bytes.NewReader(buf))\n\treq = signer.SignV4(*req, accessKey, secretKey, \"\", \"\")\n\n\t// 3.1 Execute the request.\n\tresp, err := s.TestSuiteCommon.client.Do(req)\n\tif err != nil {\n\t\tc.Fatalf(\"unexpected request err: %v\", err)\n\t}\n\tif resp.StatusCode != 200 {\n\t\tc.Fatalf(\"got unexpected response: %#v\\n\", resp)\n\t}\n\n\t// 3.2 check that user cannot delete the bucket\n\terr = uClient.RemoveBucket(ctx, bucket)\n\tif err == nil || err.Error() != \"Access Denied.\" {\n\t\tc.Fatalf(\"User was able to escalate privileges (Err=%v)!\", err)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestAddServiceAccountPerms(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\t// 1. Create a policy\n\tpolicy1 := \"deny-svc\"\n\tpolicy2 := \"allow-svc\"\n\tpolicyBytes := []byte(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Deny\",\n   \"Action\": [\n    \"admin:CreateServiceAccount\"\n   ]\n  }\n ]\n}`)\n\n\tnewPolicyBytes := []byte(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::testbucket/*\"\n   ]\n  }\n ]\n}`)\n\n\terr := s.adm.AddCannedPolicy(ctx, policy1, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\terr = s.adm.AddCannedPolicy(ctx, policy2, newPolicyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\t// 2. Verify that policy json is validated by server\n\tinvalidPolicyBytes := policyBytes[:len(policyBytes)-1]\n\terr = s.adm.AddCannedPolicy(ctx, policy1+\"invalid\", invalidPolicyBytes)\n\tif err == nil {\n\t\tc.Fatalf(\"invalid policy creation success\")\n\t}\n\n\t// 3. Create a user, associate policy and verify access\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\t// 3.1 check that user does not have any access to the bucket\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustNotListObjects(ctx, uClient, \"testbucket\")\n\n\t// 3.2 associate policy to user\n\terr = s.adm.SetPolicy(ctx, policy1, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\tadmClnt := s.getAdminClient(c, accessKey, secretKey, \"\")\n\n\t// 3.3 check user does not have explicit permissions to create service account.\n\tc.mustNotCreateSvcAccount(ctx, accessKey, admClnt)\n\n\t// 4. Verify the policy appears in listing\n\tps, err := s.adm.ListCannedPolicies(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"policy list err: %v\", err)\n\t}\n\t_, ok := ps[policy1]\n\tif !ok {\n\t\tc.Fatalf(\"policy was missing!\")\n\t}\n\n\t// 3.2 associate policy to user\n\terr = s.adm.SetPolicy(ctx, policy2, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\t// 3.3 check user can create service account implicitly.\n\tc.mustCreateSvcAccount(ctx, accessKey, admClnt)\n\n\t_, ok = ps[policy2]\n\tif !ok {\n\t\tc.Fatalf(\"policy was missing!\")\n\t}\n\n\terr = s.adm.RemoveUser(ctx, accessKey)\n\tif err != nil {\n\t\tc.Fatalf(\"user could not be deleted: %v\", err)\n\t}\n\n\terr = s.adm.RemoveCannedPolicy(ctx, policy1)\n\tif err != nil {\n\t\tc.Fatalf(\"policy del err: %v\", err)\n\t}\n\n\terr = s.adm.RemoveCannedPolicy(ctx, policy2)\n\tif err != nil {\n\t\tc.Fatalf(\"policy del err: %v\", err)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestPolicyCreate(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// 1. Create a policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\t// 2. Verify that policy json is validated by server\n\tinvalidPolicyBytes := policyBytes[:len(policyBytes)-1]\n\terr = s.adm.AddCannedPolicy(ctx, policy+\"invalid\", invalidPolicyBytes)\n\tif err == nil {\n\t\tc.Fatalf(\"invalid policy creation success\")\n\t}\n\n\t// 3. Create a user, associate policy and verify access\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\t// 3.1 check that user does not have any access to the bucket\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustNotListObjects(ctx, uClient, bucket)\n\n\t// 3.2 associate policy to user\n\terr = s.adm.SetPolicy(ctx, policy, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\t// 3.3 check user has access to bucket\n\tc.mustListObjects(ctx, uClient, bucket)\n\t// 3.4 Check that user cannot exceed their permissions\n\terr = uClient.RemoveBucket(ctx, bucket)\n\tif err == nil {\n\t\tc.Fatalf(\"bucket was deleted!\")\n\t}\n\n\t// 4. Verify the policy appears in listing\n\tps, err := s.adm.ListCannedPolicies(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"policy list err: %v\", err)\n\t}\n\t_, ok := ps[policy]\n\tif !ok {\n\t\tc.Fatalf(\"policy was missing!\")\n\t}\n\n\t// 5. Check that policy cannot be deleted when attached to a user.\n\terr = s.adm.RemoveCannedPolicy(ctx, policy)\n\tif err == nil {\n\t\tc.Fatalf(\"policy could be unexpectedly deleted!\")\n\t}\n\n\t// 6. Delete the user and then delete the policy.\n\terr = s.adm.RemoveUser(ctx, accessKey)\n\tif err != nil {\n\t\tc.Fatalf(\"user could not be deleted: %v\", err)\n\t}\n\terr = s.adm.RemoveCannedPolicy(ctx, policy)\n\tif err != nil {\n\t\tc.Fatalf(\"policy del err: %v\", err)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestCannedPolicies(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tpolicies, err := s.adm.ListCannedPolicies(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"unable to list policies: %v\", err)\n\t}\n\n\tdefaultPolicies := []string{\n\t\t\"readwrite\",\n\t\t\"readonly\",\n\t\t\"writeonly\",\n\t\t\"diagnostics\",\n\t\t\"consoleAdmin\",\n\t}\n\n\tfor _, v := range defaultPolicies {\n\t\tif _, ok := policies[v]; !ok {\n\t\t\tc.Fatalf(\"Failed to find %s in policies list\", v)\n\t\t}\n\t}\n\n\tbucket := getRandomBucketName()\n\terr = s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\n\t// Check that default policies can be overwritten.\n\terr = s.adm.AddCannedPolicy(ctx, \"readwrite\", policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tinfo, err := s.adm.InfoCannedPolicy(ctx, \"readwrite\")\n\tif err != nil {\n\t\tc.Fatalf(\"policy info err: %v\", err)\n\t}\n\n\tinfoStr := string(info)\n\tif !strings.Contains(infoStr, `\"s3:PutObject\"`) || !strings.Contains(infoStr, \":\"+bucket+\"/\") {\n\t\tc.Fatalf(\"policy contains unexpected content!\")\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestGroupAddRemove(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\t// 1. Add user to a new group\n\tgroup := \"mygroup\"\n\terr = s.adm.UpdateGroupMembers(ctx, madmin.GroupAddRemove{\n\t\tGroup:   group,\n\t\tMembers: []string{accessKey},\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to add user to group: %v\", err)\n\t}\n\n\t// 2. Check that user has no access\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustNotListObjects(ctx, uClient, bucket)\n\n\t// 3. Associate policy to group and check user got access.\n\terr = s.adm.SetPolicy(ctx, policy, group, true)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\t// 3.1 check user has access to bucket\n\tc.mustListObjects(ctx, uClient, bucket)\n\t// 3.2 Check that user cannot exceed their permissions\n\terr = uClient.RemoveBucket(ctx, bucket)\n\tif err == nil {\n\t\tc.Fatalf(\"bucket was deleted!\")\n\t}\n\n\t// 4. List groups and members and verify\n\tgroups, err := s.adm.ListGroups(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"group list err: %v\", err)\n\t}\n\tif !set.CreateStringSet(groups...).Contains(group) {\n\t\tc.Fatalf(\"created group not present!\")\n\t}\n\tgroupInfo, err := s.adm.GetGroupDescription(ctx, group)\n\tif err != nil {\n\t\tc.Fatalf(\"group desc err: %v\", err)\n\t}\n\tc.Assert(groupInfo.Name, group)\n\tc.Assert(set.CreateStringSet(groupInfo.Members...), set.CreateStringSet(accessKey))\n\tc.Assert(groupInfo.Policy, policy)\n\tc.Assert(groupInfo.Status, string(madmin.GroupEnabled))\n\n\t// 5. Disable/enable the group and verify that user access is revoked/restored.\n\terr = s.adm.SetGroupStatus(ctx, group, madmin.GroupDisabled)\n\tif err != nil {\n\t\tc.Fatalf(\"group set status err: %v\", err)\n\t}\n\tgroupInfo, err = s.adm.GetGroupDescription(ctx, group)\n\tif err != nil {\n\t\tc.Fatalf(\"group desc err: %v\", err)\n\t}\n\tc.Assert(groupInfo.Status, string(madmin.GroupDisabled))\n\tc.mustNotListObjects(ctx, uClient, bucket)\n\n\terr = s.adm.SetGroupStatus(ctx, group, madmin.GroupEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"group set status err: %v\", err)\n\t}\n\tgroupInfo, err = s.adm.GetGroupDescription(ctx, group)\n\tif err != nil {\n\t\tc.Fatalf(\"group desc err: %v\", err)\n\t}\n\tc.Assert(groupInfo.Status, string(madmin.GroupEnabled))\n\tc.mustListObjects(ctx, uClient, bucket)\n\n\t// 6. Verify that group cannot be deleted with users.\n\terr = s.adm.UpdateGroupMembers(ctx, madmin.GroupAddRemove{\n\t\tGroup:    group,\n\t\tIsRemove: true,\n\t})\n\tif err == nil {\n\t\tc.Fatalf(\"group was removed!\")\n\t}\n\tgroupInfo, err = s.adm.GetGroupDescription(ctx, group)\n\tif err != nil {\n\t\tc.Fatalf(\"group desc err: %v\", err)\n\t}\n\tc.Assert(groupInfo.Name, group)\n\n\t// 7. Remove user from group and verify access is revoked.\n\terr = s.adm.UpdateGroupMembers(ctx, madmin.GroupAddRemove{\n\t\tGroup:    group,\n\t\tMembers:  []string{accessKey},\n\t\tIsRemove: true,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"group update err: %v\", err)\n\t}\n\tc.mustNotListObjects(ctx, uClient, bucket)\n\n\t// 7.1 verify group still exists\n\tgroupInfo, err = s.adm.GetGroupDescription(ctx, group)\n\tif err != nil {\n\t\tc.Fatalf(\"group desc err: %v\", err)\n\t}\n\tc.Assert(groupInfo.Name, group)\n\tc.Assert(len(groupInfo.Members), 0)\n\n\t// 8. Delete group and verify\n\terr = s.adm.UpdateGroupMembers(ctx, madmin.GroupAddRemove{\n\t\tGroup:    group,\n\t\tIsRemove: true,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"group update err: %v\", err)\n\t}\n\tgroups, err = s.adm.ListGroups(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"group list err: %v\", err)\n\t}\n\tif set.CreateStringSet(groups...).Contains(group) {\n\t\tc.Fatalf(\"created group still present!\")\n\t}\n\t_, err = s.adm.GetGroupDescription(ctx, group)\n\tif err == nil {\n\t\tc.Fatalf(\"group appears to exist\")\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestServiceAccountOpsByUser(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// Create policy, user and associate policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  credentials.NewStaticV4(accessKey, secretKey, \"\"),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, accessKey, userAdmClient)\n\n\t// 1. Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, userAdmClient, accessKey, cr.AccessKey)\n\n\t// 2. Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, userAdmClient, accessKey, cr.AccessKey, false)\n\n\t// 3. Check S3 access\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, userAdmClient, accessKey, bucket)\n\n\t// 6. Check that service account cannot be created for some other user.\n\tc.mustNotCreateSvcAccount(ctx, globalActiveCred.AccessKey, userAdmClient)\n}\n\nfunc (s *TestSuiteIAM) TestServiceAccountOpsByAdmin(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// Create policy, user and associate policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\t// 1. Create a service account for the user\n\tcr := c.mustCreateSvcAccount(ctx, accessKey, s.adm)\n\n\t// 1.2 Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, s.adm, accessKey, cr.AccessKey)\n\n\t// 1.3 Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, s.adm, accessKey, cr.AccessKey, false)\n\n\t// 2. Check that svc account can access the bucket\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// 3. Check that svc account can restrict the policy, and that the\n\t// session policy can be updated.\n\tc.assertSvcAccSessionPolicyUpdate(ctx, s, s.adm, accessKey, bucket)\n\n\t// 4. Check that service account's secret key and account status can be\n\t// updated.\n\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, s.adm, accessKey, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, s.adm, accessKey, bucket)\n}\n\nfunc (s *TestSuiteIAM) TestServiceAccountPrivilegeEscalationBug(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\terr := s.client.MakeBucket(ctx, \"public\", minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\terr = s.client.MakeBucket(ctx, \"private\", minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\tpubPolicyBytes := []byte(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:*\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::public\",\n    \"arn:aws:s3:::public/*\"\n   ]\n  }\n ]\n}`)\n\n\tfullS3PolicyBytes := []byte(`{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"s3:*\"\n      ],\n      \"Resource\": [\n        \"arn:aws:s3:::*\"\n      ]\n    }\n  ]\n}\n`)\n\n\t// Create a service account for the root user.\n\tcr, err := s.adm.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n\t\tTargetUser: globalActiveCred.AccessKey,\n\t\tPolicy:     pubPolicyBytes,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"admin should be able to create service account for themselves %s\", err)\n\t}\n\n\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n\n\t// Check that the service account can access the public bucket.\n\tbuckets, err := svcClient.ListBuckets(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"err fetching buckets %s\", err)\n\t}\n\tif len(buckets) != 1 || buckets[0].Name != \"public\" {\n\t\tc.Fatalf(\"service account should only have access to public bucket\")\n\t}\n\n\t// Create an madmin client with the service account creds.\n\tsvcAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  credentials.NewStaticV4(cr.AccessKey, cr.SecretKey, \"\"),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating svcacct admin client: %v\", err)\n\t}\n\tsvcAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Attempt to update the policy on the service account.\n\terr = svcAdmClient.UpdateServiceAccount(ctx, cr.AccessKey,\n\t\tmadmin.UpdateServiceAccountReq{\n\t\t\tNewPolicy: fullS3PolicyBytes,\n\t\t})\n\n\tif err == nil {\n\t\tc.Fatalf(\"service account should not be able to update policy on itself\")\n\t} else if !strings.Contains(err.Error(), \"Access Denied\") {\n\t\tc.Fatalf(\"unexpected error: %v\", err)\n\t}\n}\n\nfunc (s *TestSuiteIAM) SetUpAccMgmtPlugin(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tpluginEndpoint := env.Get(\"_MINIO_POLICY_PLUGIN_ENDPOINT\", \"\")\n\tif pluginEndpoint == \"\" {\n\t\tc.Skip(\"_MINIO_POLICY_PLUGIN_ENDPOINT not given - skipping.\")\n\t}\n\n\tconfigCmds := []string{\n\t\t\"policy_plugin\",\n\t\t\"url=\" + pluginEndpoint,\n\t}\n\n\t_, err := s.adm.SetConfigKV(ctx, strings.Join(configCmds, \" \"))\n\tif err != nil {\n\t\tc.Fatalf(\"unable to setup access management plugin for tests: %v\", err)\n\t}\n\n\ts.RestartIAMSuite(c)\n}\n\n// TestIAM_AMPInternalIDPServerSuite - tests for access management plugin\nfunc TestIAM_AMPInternalIDPServerSuite(t *testing.T) {\n\tfor i, testCase := range iamTestSuites {\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s\", i+1, testCase.ServerTypeDescription),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tsuite := testCase\n\t\t\t\tc := &check{t, testCase.serverType}\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tdefer suite.TearDownSuite(c)\n\n\t\t\t\tsuite.SetUpAccMgmtPlugin(c)\n\n\t\t\t\tsuite.TestAccMgmtPlugin(c)\n\t\t\t},\n\t\t)\n\t}\n}\n\n// TestAccMgmtPlugin - this test assumes that the access-management-plugin is\n// the same as the example in `docs/iam/access-manager-plugin.go` -\n// specifically, it denies only `s3:Put*` operations on non-root accounts.\nfunc (s *TestSuiteIAM) TestAccMgmtPlugin(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\t// 0. Check that owner is able to make-bucket.\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// 1. Create a user.\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\t// 2. Check new user appears in listing\n\tusersMap, err := s.adm.ListUsers(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"error listing: %v\", err)\n\t}\n\tv, ok := usersMap[accessKey]\n\tif !ok {\n\t\tc.Fatalf(\"user not listed: %s\", accessKey)\n\t}\n\tc.Assert(v.Status, madmin.AccountEnabled)\n\n\t// 3. Check that user is able to make a bucket.\n\tclient := s.getUserClient(c, accessKey, secretKey, \"\")\n\terr = client.MakeBucket(ctx, getRandomBucketName(), minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"user not create bucket: %v\", err)\n\t}\n\n\t// 3.1 check user has access to bucket\n\tc.mustListObjects(ctx, client, bucket)\n\n\t// 3.2 check that user cannot upload an object.\n\t_, err = client.PutObject(ctx, bucket, \"objectName\", bytes.NewBuffer([]byte(\"some content\")), 12, minio.PutObjectOptions{})\n\tif err == nil {\n\t\tc.Fatalf(\"user was able to upload unexpectedly\")\n\t}\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  credentials.NewStaticV4(accessKey, secretKey, \"\"),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, accessKey, userAdmClient)\n\n\t// 1. Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, userAdmClient, accessKey, cr.AccessKey)\n\n\t// 2. Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, userAdmClient, accessKey, cr.AccessKey, false)\n\n\t// 3. Check S3 access\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// Check that session policies do not apply - as policy enforcement is\n\t// delegated to plugin.\n\t{\n\t\tsvcAK, svcSK := mustGenerateCredentials(c)\n\n\t\t// This policy does not allow listing objects.\n\t\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\t\tcr, err := userAdmClient.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n\t\t\tPolicy:     policyBytes,\n\t\t\tTargetUser: accessKey,\n\t\t\tAccessKey:  svcAK,\n\t\t\tSecretKey:  svcSK,\n\t\t})\n\t\tif err != nil {\n\t\t\tc.Fatalf(\"Unable to create svc acc: %v\", err)\n\t\t}\n\t\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n\t\t// Though the attached policy does not allow listing, it will be\n\t\t// ignored because the plugin allows it.\n\t\tc.mustListObjects(ctx, svcClient, bucket)\n\t}\n\n\t// 4. Check that service account's secret key and account status can be\n\t// updated.\n\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, userAdmClient, accessKey, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, userAdmClient, accessKey, bucket)\n\n\t// 6. Check that service account **can** be created for some other user.\n\t// This is possible because the policy enforced in the plugin.\n\tc.mustCreateSvcAccount(ctx, globalActiveCred.AccessKey, userAdmClient)\n}\n\nfunc (c *check) mustCreateIAMUser(ctx context.Context, admClnt *madmin.AdminClient) madmin.Credentials {\n\tc.Helper()\n\trandUser := mustGetUUID()\n\trandPass := mustGetUUID()\n\terr := admClnt.AddUser(ctx, randUser, randPass)\n\tif err != nil {\n\t\tc.Fatalf(\"should be able to create a user: %v\", err)\n\t}\n\treturn madmin.Credentials{\n\t\tAccessKey: randUser,\n\t\tSecretKey: randPass,\n\t}\n}\n\nfunc (c *check) mustGetIAMUserInfo(ctx context.Context, admClnt *madmin.AdminClient, accessKey string) madmin.UserInfo {\n\tc.Helper()\n\tui, err := admClnt.GetUserInfo(ctx, accessKey)\n\tif err != nil {\n\t\tc.Fatalf(\"should be able to get user info: %v\", err)\n\t}\n\treturn ui\n}\n\nfunc (c *check) mustNotCreateIAMUser(ctx context.Context, admClnt *madmin.AdminClient) {\n\tc.Helper()\n\trandUser := mustGetUUID()\n\trandPass := mustGetUUID()\n\terr := admClnt.AddUser(ctx, randUser, randPass)\n\tif err == nil {\n\t\tc.Fatalf(\"should not be able to create a user\")\n\t}\n}\n\nfunc (c *check) mustCreateSvcAccount(ctx context.Context, tgtUser string, admClnt *madmin.AdminClient) madmin.Credentials {\n\tc.Helper()\n\tcr, err := admClnt.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n\t\tTargetUser: tgtUser,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"user should be able to create service accounts %s\", err)\n\t}\n\treturn cr\n}\n\nfunc (c *check) mustNotCreateSvcAccount(ctx context.Context, tgtUser string, admClnt *madmin.AdminClient) {\n\tc.Helper()\n\t_, err := admClnt.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n\t\tTargetUser: tgtUser,\n\t})\n\tif err == nil {\n\t\tc.Fatalf(\"user was able to add service accounts unexpectedly!\")\n\t}\n}\n\nfunc (c *check) mustNotListObjects(ctx context.Context, client *minio.Client, bucket string) {\n\tc.Helper()\n\tres := client.ListObjects(ctx, bucket, minio.ListObjectsOptions{})\n\tv, ok := <-res\n\tif !ok || v.Err == nil {\n\t\tc.Fatalf(\"user was able to list unexpectedly! on %s\", bucket)\n\t}\n}\n\nfunc (c *check) mustPutObjectWithTags(ctx context.Context, client *minio.Client, bucket, object string) {\n\tc.Helper()\n\t_, err := client.PutObject(ctx, bucket, object, bytes.NewBuffer([]byte(\"stuff\")), 5, minio.PutObjectOptions{\n\t\tUserTags: map[string]string{\n\t\t\t\"security\": \"public\",\n\t\t\t\"virus\":    \"true\",\n\t\t},\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"user was unable to upload the object: %v\", err)\n\t}\n}\n\nfunc (c *check) mustGetObject(ctx context.Context, client *minio.Client, bucket, object string) {\n\tc.Helper()\n\n\tr, err := client.GetObject(ctx, bucket, object, minio.GetObjectOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"user was unable to download the object: %v\", err)\n\t}\n\tdefer r.Close()\n\n\t_, err = io.Copy(io.Discard, r)\n\tif err != nil {\n\t\tc.Fatalf(\"user was unable to download the object: %v\", err)\n\t}\n}\n\nfunc (c *check) mustHeadObject(ctx context.Context, client *minio.Client, bucket, object string, tagCount int) {\n\tc.Helper()\n\n\toinfo, err := client.StatObject(ctx, bucket, object, minio.StatObjectOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"user was unable to download the object: %v\", err)\n\t}\n\n\tif oinfo.UserTagCount != tagCount {\n\t\tc.Fatalf(\"expected tagCount: %d, got %d\", tagCount, oinfo.UserTagCount)\n\t}\n}\n\nfunc (c *check) mustListObjects(ctx context.Context, client *minio.Client, bucket string) {\n\tc.Helper()\n\tres := client.ListObjects(ctx, bucket, minio.ListObjectsOptions{})\n\tv, ok := <-res\n\tif ok && v.Err != nil {\n\t\tc.Fatalf(\"user was unable to list: %v\", v.Err)\n\t}\n}\n\nfunc (c *check) mustListBuckets(ctx context.Context, client *minio.Client) {\n\tc.Helper()\n\t_, err := client.ListBuckets(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"user was unable to list buckets: %v\", err)\n\t}\n}\n\nfunc (c *check) mustNotDelete(ctx context.Context, client *minio.Client, bucket string, vid string) {\n\tc.Helper()\n\n\terr := client.RemoveObject(ctx, bucket, \"some-object\", minio.RemoveObjectOptions{VersionID: vid})\n\tif err == nil {\n\t\tc.Fatalf(\"user must not be allowed to delete\")\n\t}\n\n\terr = client.RemoveObject(ctx, bucket, \"some-object\", minio.RemoveObjectOptions{})\n\tif err != nil {\n\t\tc.Fatal(\"user must be able to create delete marker\")\n\t}\n}\n\nfunc (c *check) mustDownload(ctx context.Context, client *minio.Client, bucket string) {\n\tc.Helper()\n\trd, err := client.GetObject(ctx, bucket, \"some-object\", minio.GetObjectOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"download did not succeed got %#v\", err)\n\t}\n\tif _, err = io.Copy(io.Discard, rd); err != nil {\n\t\tc.Fatalf(\"download did not succeed got %#v\", err)\n\t}\n}\n\nfunc (c *check) mustUploadReturnVersions(ctx context.Context, client *minio.Client, bucket string) []string {\n\tc.Helper()\n\tversions := []string{}\n\tfor i := 0; i < 5; i++ {\n\t\tui, err := client.PutObject(ctx, bucket, \"some-object\", bytes.NewBuffer([]byte(\"stuff\")), 5, minio.PutObjectOptions{})\n\t\tif err != nil {\n\t\t\tc.Fatalf(\"upload did not succeed got %#v\", err)\n\t\t}\n\t\tversions = append(versions, ui.VersionID)\n\t}\n\treturn versions\n}\n\nfunc (c *check) mustUpload(ctx context.Context, client *minio.Client, bucket string) {\n\tc.Helper()\n\t_, err := client.PutObject(ctx, bucket, \"some-object\", bytes.NewBuffer([]byte(\"stuff\")), 5, minio.PutObjectOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"upload did not succeed got %#v\", err)\n\t}\n}\n\nfunc (c *check) mustNotUpload(ctx context.Context, client *minio.Client, bucket string) {\n\tc.Helper()\n\t_, err := client.PutObject(ctx, bucket, \"some-object\", bytes.NewBuffer([]byte(\"stuff\")), 5, minio.PutObjectOptions{})\n\tif e, ok := err.(minio.ErrorResponse); ok {\n\t\tif e.Code == \"AccessDenied\" {\n\t\t\treturn\n\t\t}\n\t}\n\tc.Fatalf(\"upload did not get an AccessDenied error - got %#v instead\", err)\n}\n\nfunc (c *check) assertSvcAccS3Access(ctx context.Context, s *TestSuiteIAM, cr madmin.Credentials, bucket string) {\n\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n\tc.mustListObjects(ctx, svcClient, bucket)\n}\n\nfunc (c *check) assertSvcAccAppearsInListing(ctx context.Context, madmClient *madmin.AdminClient, parentAK, svcAK string) {\n\tc.Helper()\n\tlistResp, err := madmClient.ListServiceAccounts(ctx, parentAK)\n\tif err != nil {\n\t\tc.Fatalf(\"unable to list svc accounts: %v\", err)\n\t}\n\tvar accessKeys []string\n\tfor _, item := range listResp.Accounts {\n\t\taccessKeys = append(accessKeys, item.AccessKey)\n\t}\n\tif !set.CreateStringSet(accessKeys...).Contains(svcAK) {\n\t\tc.Fatalf(\"service account did not appear in listing!\")\n\t}\n}\n\nfunc (c *check) assertSvcAccInfoQueryable(ctx context.Context, madmClient *madmin.AdminClient, parentAK, svcAK string, skipParentUserCheck bool) {\n\tinfoResp, err := madmClient.InfoServiceAccount(ctx, svcAK)\n\tif err != nil {\n\t\tc.Fatalf(\"unable to get svc acc info: %v\", err)\n\t}\n\tif !skipParentUserCheck {\n\t\tc.Assert(infoResp.ParentUser, parentAK)\n\t}\n\tc.Assert(infoResp.AccountStatus, \"on\")\n\tc.Assert(infoResp.ImpliedPolicy, true)\n}\n\n// This test assumes that the policy for `accessKey` allows listing on the given\n// bucket. It creates a session policy that restricts listing on the bucket and\n// then enables it again in a session policy update call.\nfunc (c *check) assertSvcAccSessionPolicyUpdate(ctx context.Context, s *TestSuiteIAM, madmClient *madmin.AdminClient, accessKey, bucket string) {\n\tc.Helper()\n\tsvcAK, svcSK := mustGenerateCredentials(c)\n\n\t// This policy does not allow listing objects.\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\tcr, err := madmClient.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n\t\tPolicy:     policyBytes,\n\t\tTargetUser: accessKey,\n\t\tAccessKey:  svcAK,\n\t\tSecretKey:  svcSK,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to create svc acc: %v\", err)\n\t}\n\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n\tc.mustNotListObjects(ctx, svcClient, bucket)\n\n\t// This policy allows listing objects.\n\tnewPolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = madmClient.UpdateServiceAccount(ctx, svcAK, madmin.UpdateServiceAccountReq{\n\t\tNewPolicy: newPolicyBytes,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"unable to update session policy for svc acc: %v\", err)\n\t}\n\tc.mustListObjects(ctx, svcClient, bucket)\n}\n\nfunc (c *check) assertSvcAccSecretKeyAndStatusUpdate(ctx context.Context, s *TestSuiteIAM, madmClient *madmin.AdminClient, accessKey, bucket string) {\n\tc.Helper()\n\tsvcAK, svcSK := mustGenerateCredentials(c)\n\tcr, err := madmClient.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n\t\tTargetUser: accessKey,\n\t\tAccessKey:  svcAK,\n\t\tSecretKey:  svcSK,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to create svc acc: %v\", err)\n\t}\n\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n\tc.mustListObjects(ctx, svcClient, bucket)\n\n\t_, svcSK2 := mustGenerateCredentials(c)\n\terr = madmClient.UpdateServiceAccount(ctx, svcAK, madmin.UpdateServiceAccountReq{\n\t\tNewSecretKey: svcSK2,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"unable to update secret key for svc acc: %v\", err)\n\t}\n\t// old creds should not work:\n\tc.mustNotListObjects(ctx, svcClient, bucket)\n\t// new creds work:\n\tsvcClient2 := s.getUserClient(c, cr.AccessKey, svcSK2, \"\")\n\tc.mustListObjects(ctx, svcClient2, bucket)\n\n\t// update status to disabled\n\terr = madmClient.UpdateServiceAccount(ctx, svcAK, madmin.UpdateServiceAccountReq{\n\t\tNewStatus: \"off\",\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"unable to update secret key for svc acc: %v\", err)\n\t}\n\tc.mustNotListObjects(ctx, svcClient2, bucket)\n}\n\nfunc (c *check) assertSvcAccDeletion(ctx context.Context, s *TestSuiteIAM, madmClient *madmin.AdminClient, accessKey, bucket string) {\n\tc.Helper()\n\tsvcAK, svcSK := mustGenerateCredentials(c)\n\tcr, err := madmClient.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n\t\tTargetUser: accessKey,\n\t\tAccessKey:  svcAK,\n\t\tSecretKey:  svcSK,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to create svc acc: %v\", err)\n\t}\n\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n\tc.mustListObjects(ctx, svcClient, bucket)\n\n\terr = madmClient.DeleteServiceAccount(ctx, svcAK)\n\tif err != nil {\n\t\tc.Fatalf(\"unable to delete svc acc: %v\", err)\n\t}\n\tc.mustNotListObjects(ctx, svcClient, bucket)\n}\n\nfunc mustGenerateCredentials(c *check) (string, string) {\n\tc.Helper()\n\tak, sk, err := auth.GenerateCredentials()\n\tif err != nil {\n\t\tc.Fatalf(\"unable to generate credentials: %v\", err)\n\t}\n\treturn ak, sk\n}\n", "// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/subtle\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"io\"\n\t\"mime\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/minio/minio/internal/auth\"\n\tobjectlock \"github.com/minio/minio/internal/bucket/object/lock\"\n\t\"github.com/minio/minio/internal/etag\"\n\t\"github.com/minio/minio/internal/hash\"\n\txhttp \"github.com/minio/minio/internal/http\"\n\txjwt \"github.com/minio/minio/internal/jwt\"\n\t\"github.com/minio/minio/internal/logger\"\n\t\"github.com/minio/minio/internal/mcontext\"\n\t\"github.com/minio/pkg/v2/policy\"\n)\n\n// Verify if request has JWT.\nfunc isRequestJWT(r *http.Request) bool {\n\treturn strings.HasPrefix(r.Header.Get(xhttp.Authorization), jwtAlgorithm)\n}\n\n// Verify if request has AWS Signature Version '4'.\nfunc isRequestSignatureV4(r *http.Request) bool {\n\treturn strings.HasPrefix(r.Header.Get(xhttp.Authorization), signV4Algorithm)\n}\n\n// Verify if request has AWS Signature Version '2'.\nfunc isRequestSignatureV2(r *http.Request) bool {\n\treturn (!strings.HasPrefix(r.Header.Get(xhttp.Authorization), signV4Algorithm) &&\n\t\tstrings.HasPrefix(r.Header.Get(xhttp.Authorization), signV2Algorithm))\n}\n\n// Verify if request has AWS PreSign Version '4'.\nfunc isRequestPresignedSignatureV4(r *http.Request) bool {\n\t_, ok := r.Form[xhttp.AmzCredential]\n\treturn ok\n}\n\n// Verify request has AWS PreSign Version '2'.\nfunc isRequestPresignedSignatureV2(r *http.Request) bool {\n\t_, ok := r.Form[xhttp.AmzAccessKeyID]\n\treturn ok\n}\n\n// Verify if request has AWS Post policy Signature Version '4'.\nfunc isRequestPostPolicySignatureV4(r *http.Request) bool {\n\tmediaType, _, err := mime.ParseMediaType(r.Header.Get(xhttp.ContentType))\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn mediaType == \"multipart/form-data\" && r.Method == http.MethodPost\n}\n\n// Verify if the request has AWS Streaming Signature Version '4'. This is only valid for 'PUT' operation.\nfunc isRequestSignStreamingV4(r *http.Request) bool {\n\treturn r.Header.Get(xhttp.AmzContentSha256) == streamingContentSHA256 &&\n\t\tr.Method == http.MethodPut\n}\n\n// Verify if the request has AWS Streaming Signature Version '4'. This is only valid for 'PUT' operation.\nfunc isRequestSignStreamingTrailerV4(r *http.Request) bool {\n\treturn r.Header.Get(xhttp.AmzContentSha256) == streamingContentSHA256Trailer &&\n\t\tr.Method == http.MethodPut\n}\n\n// Verify if the request has AWS Streaming Signature Version '4', with unsigned content and trailer.\nfunc isRequestUnsignedTrailerV4(r *http.Request) bool {\n\treturn r.Header.Get(xhttp.AmzContentSha256) == unsignedPayloadTrailer &&\n\t\tr.Method == http.MethodPut && strings.Contains(r.Header.Get(xhttp.ContentEncoding), streamingContentEncoding)\n}\n\n// Authorization type.\n//\n//go:generate stringer -type=authType -trimprefix=authType $GOFILE\ntype authType int\n\n// List of all supported auth types.\nconst (\n\tauthTypeUnknown authType = iota\n\tauthTypeAnonymous\n\tauthTypePresigned\n\tauthTypePresignedV2\n\tauthTypePostPolicy\n\tauthTypeStreamingSigned\n\tauthTypeSigned\n\tauthTypeSignedV2\n\tauthTypeJWT\n\tauthTypeSTS\n\tauthTypeStreamingSignedTrailer\n\tauthTypeStreamingUnsignedTrailer\n)\n\n// Get request authentication type.\nfunc getRequestAuthType(r *http.Request) (at authType) {\n\tif r.URL != nil {\n\t\tvar err error\n\t\tr.Form, err = url.ParseQuery(r.URL.RawQuery)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(r.Context(), err)\n\t\t\treturn authTypeUnknown\n\t\t}\n\t}\n\tif isRequestSignatureV2(r) {\n\t\treturn authTypeSignedV2\n\t} else if isRequestPresignedSignatureV2(r) {\n\t\treturn authTypePresignedV2\n\t} else if isRequestSignStreamingV4(r) {\n\t\treturn authTypeStreamingSigned\n\t} else if isRequestSignStreamingTrailerV4(r) {\n\t\treturn authTypeStreamingSignedTrailer\n\t} else if isRequestUnsignedTrailerV4(r) {\n\t\treturn authTypeStreamingUnsignedTrailer\n\t} else if isRequestSignatureV4(r) {\n\t\treturn authTypeSigned\n\t} else if isRequestPresignedSignatureV4(r) {\n\t\treturn authTypePresigned\n\t} else if isRequestJWT(r) {\n\t\treturn authTypeJWT\n\t} else if isRequestPostPolicySignatureV4(r) {\n\t\treturn authTypePostPolicy\n\t} else if _, ok := r.Form[xhttp.Action]; ok {\n\t\treturn authTypeSTS\n\t} else if _, ok := r.Header[xhttp.Authorization]; !ok {\n\t\treturn authTypeAnonymous\n\t}\n\treturn authTypeUnknown\n}\n\nfunc validateAdminSignature(ctx context.Context, r *http.Request, region string) (auth.Credentials, bool, APIErrorCode) {\n\tvar cred auth.Credentials\n\tvar owner bool\n\ts3Err := ErrAccessDenied\n\tif _, ok := r.Header[xhttp.AmzContentSha256]; ok &&\n\t\tgetRequestAuthType(r) == authTypeSigned {\n\n\t\t// Get credential information from the request.\n\t\tcred, owner, s3Err = getReqAccessKeyV4(r, region, serviceS3)\n\t\tif s3Err != ErrNone {\n\t\t\treturn cred, owner, s3Err\n\t\t}\n\n\t\t// we only support V4 (no presign) with auth body\n\t\ts3Err = isReqAuthenticated(ctx, r, region, serviceS3)\n\t}\n\tif s3Err != ErrNone {\n\t\treturn cred, owner, s3Err\n\t}\n\n\tlogger.GetReqInfo(ctx).Cred = cred\n\tlogger.GetReqInfo(ctx).Owner = owner\n\tlogger.GetReqInfo(ctx).Region = globalSite.Region\n\n\treturn cred, owner, ErrNone\n}\n\n// checkAdminRequestAuth checks for authentication and authorization for the incoming\n// request. It only accepts V2 and V4 requests. Presigned, JWT and anonymous requests\n// are automatically rejected.\nfunc checkAdminRequestAuth(ctx context.Context, r *http.Request, action policy.AdminAction, region string) (auth.Credentials, APIErrorCode) {\n\tcred, owner, s3Err := validateAdminSignature(ctx, r, region)\n\tif s3Err != ErrNone {\n\t\treturn cred, s3Err\n\t}\n\tif globalIAMSys.IsAllowed(policy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          policy.Action(action),\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t}) {\n\t\t// Request is allowed return the appropriate access key.\n\t\treturn cred, ErrNone\n\t}\n\n\treturn cred, ErrAccessDenied\n}\n\n// Fetch the security token set by the client.\nfunc getSessionToken(r *http.Request) (token string) {\n\ttoken = r.Header.Get(xhttp.AmzSecurityToken)\n\tif token != \"\" {\n\t\treturn token\n\t}\n\treturn r.Form.Get(xhttp.AmzSecurityToken)\n}\n\n// Fetch claims in the security token returned by the client, doesn't return\n// errors - upon errors the returned claims map will be empty.\nfunc mustGetClaimsFromToken(r *http.Request) map[string]interface{} {\n\tclaims, _ := getClaimsFromToken(getSessionToken(r))\n\treturn claims\n}\n\nfunc getClaimsFromTokenWithSecret(token, secret string) (map[string]interface{}, error) {\n\t// JWT token for x-amz-security-token is signed with admin\n\t// secret key, temporary credentials become invalid if\n\t// server admin credentials change. This is done to ensure\n\t// that clients cannot decode the token using the temp\n\t// secret keys and generate an entirely new claim by essentially\n\t// hijacking the policies. We need to make sure that this is\n\t// based on admin credential such that token cannot be decoded\n\t// on the client side and is treated like an opaque value.\n\tclaims, err := auth.ExtractClaims(token, secret)\n\tif err != nil {\n\t\tif subtle.ConstantTimeCompare([]byte(secret), []byte(globalActiveCred.SecretKey)) == 1 {\n\t\t\treturn nil, errAuthentication\n\t\t}\n\t\tclaims, err = auth.ExtractClaims(token, globalActiveCred.SecretKey)\n\t\tif err != nil {\n\t\t\treturn nil, errAuthentication\n\t\t}\n\t}\n\n\t// If AuthZPlugin is set, return without any further checks.\n\tif newGlobalAuthZPluginFn() != nil {\n\t\treturn claims.Map(), nil\n\t}\n\n\t// Check if a session policy is set. If so, decode it here.\n\tsp, spok := claims.Lookup(policy.SessionPolicyName)\n\tif spok {\n\t\t// Looks like subpolicy is set and is a string, if set then its\n\t\t// base64 encoded, decode it. Decoding fails reject such\n\t\t// requests.\n\t\tspBytes, err := base64.StdEncoding.DecodeString(sp)\n\t\tif err != nil {\n\t\t\t// Base64 decoding fails, we should log to indicate\n\t\t\t// something is malforming the request sent by client.\n\t\t\tlogger.LogIf(GlobalContext, err, logger.Application)\n\t\t\treturn nil, errAuthentication\n\t\t}\n\t\tclaims.MapClaims[sessionPolicyNameExtracted] = string(spBytes)\n\t}\n\n\treturn claims.Map(), nil\n}\n\n// Fetch claims in the security token returned by the client.\nfunc getClaimsFromToken(token string) (map[string]interface{}, error) {\n\treturn getClaimsFromTokenWithSecret(token, globalActiveCred.SecretKey)\n}\n\n// Fetch claims in the security token returned by the client and validate the token.\nfunc checkClaimsFromToken(r *http.Request, cred auth.Credentials) (map[string]interface{}, APIErrorCode) {\n\ttoken := getSessionToken(r)\n\tif token != \"\" && cred.AccessKey == \"\" {\n\t\t// x-amz-security-token is not allowed for anonymous access.\n\t\treturn nil, ErrNoAccessKey\n\t}\n\n\tif token == \"\" && cred.IsTemp() && !cred.IsServiceAccount() {\n\t\t// Temporary credentials should always have x-amz-security-token\n\t\treturn nil, ErrInvalidToken\n\t}\n\n\tif token != \"\" && !cred.IsTemp() {\n\t\t// x-amz-security-token should not present for static credentials.\n\t\treturn nil, ErrInvalidToken\n\t}\n\n\tif !cred.IsServiceAccount() && cred.IsTemp() && subtle.ConstantTimeCompare([]byte(token), []byte(cred.SessionToken)) != 1 {\n\t\t// validate token for temporary credentials only.\n\t\treturn nil, ErrInvalidToken\n\t}\n\n\tsecret := globalActiveCred.SecretKey\n\tif cred.IsServiceAccount() {\n\t\ttoken = cred.SessionToken\n\t\tsecret = cred.SecretKey\n\t}\n\n\tif token != \"\" {\n\t\tclaims, err := getClaimsFromTokenWithSecret(token, secret)\n\t\tif err != nil {\n\t\t\treturn nil, toAPIErrorCode(r.Context(), err)\n\t\t}\n\t\treturn claims, ErrNone\n\t}\n\n\tclaims := xjwt.NewMapClaims()\n\treturn claims.Map(), ErrNone\n}\n\n// Check request auth type verifies the incoming http request\n//   - validates the request signature\n//   - validates the policy action if anonymous tests bucket policies if any,\n//     for authenticated requests validates IAM policies.\n//\n// returns APIErrorCode if any to be replied to the client.\nfunc checkRequestAuthType(ctx context.Context, r *http.Request, action policy.Action, bucketName, objectName string) (s3Err APIErrorCode) {\n\tlogger.GetReqInfo(ctx).BucketName = bucketName\n\tlogger.GetReqInfo(ctx).ObjectName = objectName\n\n\t_, _, s3Err = checkRequestAuthTypeCredential(ctx, r, action)\n\treturn s3Err\n}\n\n// checkRequestAuthTypeWithVID is similar to checkRequestAuthType\n// passes versionID additionally.\nfunc checkRequestAuthTypeWithVID(ctx context.Context, r *http.Request, action policy.Action, bucketName, objectName, versionID string) (s3Err APIErrorCode) {\n\tlogger.GetReqInfo(ctx).BucketName = bucketName\n\tlogger.GetReqInfo(ctx).ObjectName = objectName\n\tlogger.GetReqInfo(ctx).VersionID = versionID\n\n\t_, _, s3Err = checkRequestAuthTypeCredential(ctx, r, action)\n\treturn s3Err\n}\n\nfunc authenticateRequest(ctx context.Context, r *http.Request, action policy.Action) (s3Err APIErrorCode) {\n\tif logger.GetReqInfo(ctx) == nil {\n\t\tlogger.LogIf(ctx, errors.New(\"unexpected context.Context does not have a logger.ReqInfo\"), logger.Minio)\n\t\treturn ErrAccessDenied\n\t}\n\n\tvar cred auth.Credentials\n\tvar owner bool\n\tswitch getRequestAuthType(r) {\n\tcase authTypeUnknown, authTypeStreamingSigned:\n\t\treturn ErrSignatureVersionNotSupported\n\tcase authTypePresignedV2, authTypeSignedV2:\n\t\tif s3Err = isReqAuthenticatedV2(r); s3Err != ErrNone {\n\t\t\treturn s3Err\n\t\t}\n\t\tcred, owner, s3Err = getReqAccessKeyV2(r)\n\tcase authTypeSigned, authTypePresigned:\n\t\tregion := globalSite.Region\n\t\tswitch action {\n\t\tcase policy.GetBucketLocationAction, policy.ListAllMyBucketsAction:\n\t\t\tregion = \"\"\n\t\t}\n\t\tif s3Err = isReqAuthenticated(ctx, r, region, serviceS3); s3Err != ErrNone {\n\t\t\treturn s3Err\n\t\t}\n\t\tcred, owner, s3Err = getReqAccessKeyV4(r, region, serviceS3)\n\t}\n\tif s3Err != ErrNone {\n\t\treturn s3Err\n\t}\n\n\tlogger.GetReqInfo(ctx).Cred = cred\n\tlogger.GetReqInfo(ctx).Owner = owner\n\tlogger.GetReqInfo(ctx).Region = globalSite.Region\n\n\t// region is valid only for CreateBucketAction.\n\tvar region string\n\tif action == policy.CreateBucketAction {\n\t\t// To extract region from XML in request body, get copy of request body.\n\t\tpayload, err := io.ReadAll(io.LimitReader(r.Body, maxLocationConstraintSize))\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, err, logger.Application)\n\t\t\treturn ErrMalformedXML\n\t\t}\n\n\t\t// Populate payload to extract location constraint.\n\t\tr.Body = io.NopCloser(bytes.NewReader(payload))\n\t\tregion, s3Err = parseLocationConstraint(r)\n\t\tif s3Err != ErrNone {\n\t\t\treturn s3Err\n\t\t}\n\n\t\t// Populate payload again to handle it in HTTP handler.\n\t\tr.Body = io.NopCloser(bytes.NewReader(payload))\n\t}\n\n\tlogger.GetReqInfo(ctx).Region = region\n\n\treturn s3Err\n}\n\nfunc authorizeRequest(ctx context.Context, r *http.Request, action policy.Action) (s3Err APIErrorCode) {\n\treqInfo := logger.GetReqInfo(ctx)\n\tif reqInfo == nil {\n\t\treturn ErrAccessDenied\n\t}\n\n\tcred := reqInfo.Cred\n\towner := reqInfo.Owner\n\tregion := reqInfo.Region\n\tbucket := reqInfo.BucketName\n\tobject := reqInfo.ObjectName\n\tversionID := reqInfo.VersionID\n\n\tif action != policy.ListAllMyBucketsAction && cred.AccessKey == \"\" {\n\t\t// Anonymous checks are not meant for ListAllBuckets action\n\t\tif globalPolicySys.IsAllowed(policy.BucketPolicyArgs{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          action,\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, region, auth.AnonymousCredentials),\n\t\t\tIsOwner:         false,\n\t\t\tObjectName:      object,\n\t\t}) {\n\t\t\t// Request is allowed return the appropriate access key.\n\t\t\treturn ErrNone\n\t\t}\n\n\t\tif action == policy.ListBucketVersionsAction {\n\t\t\t// In AWS S3 s3:ListBucket permission is same as s3:ListBucketVersions permission\n\t\t\t// verify as a fallback.\n\t\t\tif globalPolicySys.IsAllowed(policy.BucketPolicyArgs{\n\t\t\t\tAccountName:     cred.AccessKey,\n\t\t\t\tGroups:          cred.Groups,\n\t\t\t\tAction:          policy.ListBucketAction,\n\t\t\t\tBucketName:      bucket,\n\t\t\t\tConditionValues: getConditionValues(r, region, auth.AnonymousCredentials),\n\t\t\t\tIsOwner:         false,\n\t\t\t\tObjectName:      object,\n\t\t\t}) {\n\t\t\t\t// Request is allowed return the appropriate access key.\n\t\t\t\treturn ErrNone\n\t\t\t}\n\t\t}\n\n\t\treturn ErrAccessDenied\n\t}\n\tif action == policy.DeleteObjectAction && versionID != \"\" {\n\t\tif !globalIAMSys.IsAllowed(policy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          policy.Action(policy.DeleteObjectVersionAction),\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\t\tObjectName:      object,\n\t\t\tIsOwner:         owner,\n\t\t\tClaims:          cred.Claims,\n\t\t\tDenyOnly:        true,\n\t\t}) { // Request is not allowed if Deny action on DeleteObjectVersionAction\n\t\t\treturn ErrAccessDenied\n\t\t}\n\t}\n\tif globalIAMSys.IsAllowed(policy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          action,\n\t\tBucketName:      bucket,\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tObjectName:      object,\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t}) {\n\t\t// Request is allowed return the appropriate access key.\n\t\treturn ErrNone\n\t}\n\n\tif action == policy.ListBucketVersionsAction {\n\t\t// In AWS S3 s3:ListBucket permission is same as s3:ListBucketVersions permission\n\t\t// verify as a fallback.\n\t\tif globalIAMSys.IsAllowed(policy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          policy.ListBucketAction,\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\t\tObjectName:      object,\n\t\t\tIsOwner:         owner,\n\t\t\tClaims:          cred.Claims,\n\t\t}) {\n\t\t\t// Request is allowed return the appropriate access key.\n\t\t\treturn ErrNone\n\t\t}\n\t}\n\n\treturn ErrAccessDenied\n}\n\n// Check request auth type verifies the incoming http request\n//   - validates the request signature\n//   - validates the policy action if anonymous tests bucket policies if any,\n//     for authenticated requests validates IAM policies.\n//\n// returns APIErrorCode if any to be replied to the client.\n// Additionally returns the accessKey used in the request, and if this request is by an admin.\nfunc checkRequestAuthTypeCredential(ctx context.Context, r *http.Request, action policy.Action) (cred auth.Credentials, owner bool, s3Err APIErrorCode) {\n\ts3Err = authenticateRequest(ctx, r, action)\n\treqInfo := logger.GetReqInfo(ctx)\n\tif reqInfo == nil {\n\t\treturn cred, owner, ErrAccessDenied\n\t}\n\n\tcred = reqInfo.Cred\n\towner = reqInfo.Owner\n\tif s3Err != ErrNone {\n\t\treturn cred, owner, s3Err\n\t}\n\n\treturn cred, owner, authorizeRequest(ctx, r, action)\n}\n\n// Verify if request has valid AWS Signature Version '2'.\nfunc isReqAuthenticatedV2(r *http.Request) (s3Error APIErrorCode) {\n\tif isRequestSignatureV2(r) {\n\t\treturn doesSignV2Match(r)\n\t}\n\treturn doesPresignV2SignatureMatch(r)\n}\n\nfunc reqSignatureV4Verify(r *http.Request, region string, stype serviceType) (s3Error APIErrorCode) {\n\tsha256sum := getContentSha256Cksum(r, stype)\n\tswitch {\n\tcase isRequestSignatureV4(r):\n\t\treturn doesSignatureMatch(sha256sum, r, region, stype)\n\tcase isRequestPresignedSignatureV4(r):\n\t\treturn doesPresignedSignatureMatch(sha256sum, r, region, stype)\n\tdefault:\n\t\treturn ErrAccessDenied\n\t}\n}\n\n// Verify if request has valid AWS Signature Version '4'.\nfunc isReqAuthenticated(ctx context.Context, r *http.Request, region string, stype serviceType) (s3Error APIErrorCode) {\n\tif errCode := reqSignatureV4Verify(r, region, stype); errCode != ErrNone {\n\t\treturn errCode\n\t}\n\n\tclientETag, err := etag.FromContentMD5(r.Header)\n\tif err != nil {\n\t\treturn ErrInvalidDigest\n\t}\n\n\t// Extract either 'X-Amz-Content-Sha256' header or 'X-Amz-Content-Sha256' query parameter (if V4 presigned)\n\t// Do not verify 'X-Amz-Content-Sha256' if skipSHA256.\n\tvar contentSHA256 []byte\n\tif skipSHA256 := skipContentSha256Cksum(r); !skipSHA256 && isRequestPresignedSignatureV4(r) {\n\t\tif sha256Sum, ok := r.Form[xhttp.AmzContentSha256]; ok && len(sha256Sum) > 0 {\n\t\t\tcontentSHA256, err = hex.DecodeString(sha256Sum[0])\n\t\t\tif err != nil {\n\t\t\t\treturn ErrContentSHA256Mismatch\n\t\t\t}\n\t\t}\n\t} else if _, ok := r.Header[xhttp.AmzContentSha256]; !skipSHA256 && ok {\n\t\tcontentSHA256, err = hex.DecodeString(r.Header.Get(xhttp.AmzContentSha256))\n\t\tif err != nil || len(contentSHA256) == 0 {\n\t\t\treturn ErrContentSHA256Mismatch\n\t\t}\n\t}\n\n\t// Verify 'Content-Md5' and/or 'X-Amz-Content-Sha256' if present.\n\t// The verification happens implicit during reading.\n\treader, err := hash.NewReader(ctx, r.Body, -1, clientETag.String(), hex.EncodeToString(contentSHA256), -1)\n\tif err != nil {\n\t\treturn toAPIErrorCode(ctx, err)\n\t}\n\tr.Body = reader\n\treturn ErrNone\n}\n\n// List of all support S3 auth types.\nvar supportedS3AuthTypes = map[authType]struct{}{\n\tauthTypeAnonymous:                {},\n\tauthTypePresigned:                {},\n\tauthTypePresignedV2:              {},\n\tauthTypeSigned:                   {},\n\tauthTypeSignedV2:                 {},\n\tauthTypePostPolicy:               {},\n\tauthTypeStreamingSigned:          {},\n\tauthTypeStreamingSignedTrailer:   {},\n\tauthTypeStreamingUnsignedTrailer: {},\n}\n\n// Validate if the authType is valid and supported.\nfunc isSupportedS3AuthType(aType authType) bool {\n\t_, ok := supportedS3AuthTypes[aType]\n\treturn ok\n}\n\n// setAuthMiddleware to validate authorization header for the incoming request.\nfunc setAuthMiddleware(h http.Handler) http.Handler {\n\t// handler for validating incoming authorization headers.\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttc, ok := r.Context().Value(mcontext.ContextTraceKey).(*mcontext.TraceCtxt)\n\n\t\taType := getRequestAuthType(r)\n\t\tswitch aType {\n\t\tcase authTypeSigned, authTypeSignedV2, authTypeStreamingSigned, authTypeStreamingSignedTrailer:\n\t\t\t// Verify if date headers are set, if not reject the request\n\t\t\tamzDate, errCode := parseAmzDateHeader(r)\n\t\t\tif errCode != ErrNone {\n\t\t\t\tif ok {\n\t\t\t\t\ttc.FuncName = \"handler.Auth\"\n\t\t\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t\t\t}\n\n\t\t\t\t// All our internal APIs are sensitive towards Date\n\t\t\t\t// header, for all requests where Date header is not\n\t\t\t\t// present we will reject such clients.\n\t\t\t\tdefer logger.AuditLog(r.Context(), w, r, mustGetClaimsFromToken(r))\n\t\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(errCode), r.URL)\n\t\t\t\tatomic.AddUint64(&globalHTTPStats.rejectedRequestsTime, 1)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Verify if the request date header is shifted by less than globalMaxSkewTime parameter in the past\n\t\t\t// or in the future, reject request otherwise.\n\t\t\tcurTime := UTCNow()\n\t\t\tif curTime.Sub(amzDate) > globalMaxSkewTime || amzDate.Sub(curTime) > globalMaxSkewTime {\n\t\t\t\tif ok {\n\t\t\t\t\ttc.FuncName = \"handler.Auth\"\n\t\t\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t\t\t}\n\n\t\t\t\tdefer logger.AuditLog(r.Context(), w, r, mustGetClaimsFromToken(r))\n\t\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrRequestTimeTooSkewed), r.URL)\n\t\t\t\tatomic.AddUint64(&globalHTTPStats.rejectedRequestsTime, 1)\n\t\t\t\treturn\n\t\t\t}\n\t\t\th.ServeHTTP(w, r)\n\t\t\treturn\n\t\tcase authTypeJWT, authTypeSTS:\n\t\t\th.ServeHTTP(w, r)\n\t\t\treturn\n\t\tdefault:\n\t\t\tif isSupportedS3AuthType(aType) {\n\t\t\t\th.ServeHTTP(w, r)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif ok {\n\t\t\ttc.FuncName = \"handler.Auth\"\n\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t}\n\n\t\tdefer logger.AuditLog(r.Context(), w, r, mustGetClaimsFromToken(r))\n\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrSignatureVersionNotSupported), r.URL)\n\t\tatomic.AddUint64(&globalHTTPStats.rejectedRequestsAuth, 1)\n\t})\n}\n\nfunc validateSignature(atype authType, r *http.Request) (auth.Credentials, bool, APIErrorCode) {\n\tvar cred auth.Credentials\n\tvar owner bool\n\tvar s3Err APIErrorCode\n\tswitch atype {\n\tcase authTypeUnknown, authTypeStreamingSigned:\n\t\treturn cred, owner, ErrSignatureVersionNotSupported\n\tcase authTypeSignedV2, authTypePresignedV2:\n\t\tif s3Err = isReqAuthenticatedV2(r); s3Err != ErrNone {\n\t\t\treturn cred, owner, s3Err\n\t\t}\n\t\tcred, owner, s3Err = getReqAccessKeyV2(r)\n\tcase authTypePresigned, authTypeSigned:\n\t\tregion := globalSite.Region\n\t\tif s3Err = isReqAuthenticated(GlobalContext, r, region, serviceS3); s3Err != ErrNone {\n\t\t\treturn cred, owner, s3Err\n\t\t}\n\t\tcred, owner, s3Err = getReqAccessKeyV4(r, region, serviceS3)\n\t}\n\tif s3Err != ErrNone {\n\t\treturn cred, owner, s3Err\n\t}\n\n\treturn cred, owner, ErrNone\n}\n\nfunc isPutRetentionAllowed(bucketName, objectName string, retDays int, retDate time.Time, retMode objectlock.RetMode, byPassSet bool, r *http.Request, cred auth.Credentials, owner bool) (s3Err APIErrorCode) {\n\tvar retSet bool\n\tif cred.AccessKey == \"\" {\n\t\treturn ErrAccessDenied\n\t}\n\n\tconditions := getConditionValues(r, \"\", cred)\n\tconditions[\"object-lock-mode\"] = []string{string(retMode)}\n\tconditions[\"object-lock-retain-until-date\"] = []string{retDate.UTC().Format(time.RFC3339)}\n\tif retDays > 0 {\n\t\tconditions[\"object-lock-remaining-retention-days\"] = []string{strconv.Itoa(retDays)}\n\t}\n\tif retMode == objectlock.RetGovernance && byPassSet {\n\t\tbyPassSet = globalIAMSys.IsAllowed(policy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          policy.BypassGovernanceRetentionAction,\n\t\t\tBucketName:      bucketName,\n\t\t\tObjectName:      objectName,\n\t\t\tConditionValues: conditions,\n\t\t\tIsOwner:         owner,\n\t\t\tClaims:          cred.Claims,\n\t\t})\n\t}\n\tif globalIAMSys.IsAllowed(policy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          policy.PutObjectRetentionAction,\n\t\tBucketName:      bucketName,\n\t\tConditionValues: conditions,\n\t\tObjectName:      objectName,\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t}) {\n\t\tretSet = true\n\t}\n\tif byPassSet || retSet {\n\t\treturn ErrNone\n\t}\n\treturn ErrAccessDenied\n}\n\n// isPutActionAllowed - check if PUT operation is allowed on the resource, this\n// call verifies bucket policies and IAM policies, supports multi user\n// checks etc.\nfunc isPutActionAllowed(ctx context.Context, atype authType, bucketName, objectName string, r *http.Request, action policy.Action) (s3Err APIErrorCode) {\n\tvar cred auth.Credentials\n\tvar owner bool\n\tregion := globalSite.Region\n\tswitch atype {\n\tcase authTypeUnknown:\n\t\treturn ErrSignatureVersionNotSupported\n\tcase authTypeSignedV2, authTypePresignedV2:\n\t\tcred, owner, s3Err = getReqAccessKeyV2(r)\n\tcase authTypeStreamingSigned, authTypePresigned, authTypeSigned, authTypeStreamingSignedTrailer, authTypeStreamingUnsignedTrailer:\n\t\tcred, owner, s3Err = getReqAccessKeyV4(r, region, serviceS3)\n\t}\n\tif s3Err != ErrNone {\n\t\treturn s3Err\n\t}\n\n\tlogger.GetReqInfo(ctx).Cred = cred\n\tlogger.GetReqInfo(ctx).Owner = owner\n\tlogger.GetReqInfo(ctx).Region = region\n\n\t// Do not check for PutObjectRetentionAction permission,\n\t// if mode and retain until date are not set.\n\t// Can happen when bucket has default lock config set\n\tif action == policy.PutObjectRetentionAction &&\n\t\tr.Header.Get(xhttp.AmzObjectLockMode) == \"\" &&\n\t\tr.Header.Get(xhttp.AmzObjectLockRetainUntilDate) == \"\" {\n\t\treturn ErrNone\n\t}\n\n\tif cred.AccessKey == \"\" {\n\t\tif globalPolicySys.IsAllowed(policy.BucketPolicyArgs{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          action,\n\t\t\tBucketName:      bucketName,\n\t\t\tConditionValues: getConditionValues(r, \"\", auth.AnonymousCredentials),\n\t\t\tIsOwner:         false,\n\t\t\tObjectName:      objectName,\n\t\t}) {\n\t\t\treturn ErrNone\n\t\t}\n\t\treturn ErrAccessDenied\n\t}\n\n\tif globalIAMSys.IsAllowed(policy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          action,\n\t\tBucketName:      bucketName,\n\t\tConditionValues: getConditionValues(r, \"\", cred),\n\t\tObjectName:      objectName,\n\t\tIsOwner:         owner,\n\t\tClaims:          cred.Claims,\n\t}) {\n\t\treturn ErrNone\n\t}\n\treturn ErrAccessDenied\n}\n", "// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"path\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/minio/madmin-go/v3\"\n\t\"github.com/minio/minio-go/v7/pkg/set\"\n\t\"github.com/minio/minio/internal/arn\"\n\t\"github.com/minio/minio/internal/auth\"\n\t\"github.com/minio/minio/internal/color\"\n\t\"github.com/minio/minio/internal/config\"\n\txldap \"github.com/minio/minio/internal/config/identity/ldap\"\n\t\"github.com/minio/minio/internal/config/identity/openid\"\n\tidplugin \"github.com/minio/minio/internal/config/identity/plugin\"\n\txtls \"github.com/minio/minio/internal/config/identity/tls\"\n\t\"github.com/minio/minio/internal/config/policy/opa\"\n\tpolplugin \"github.com/minio/minio/internal/config/policy/plugin\"\n\txhttp \"github.com/minio/minio/internal/http\"\n\txioutil \"github.com/minio/minio/internal/ioutil\"\n\t\"github.com/minio/minio/internal/jwt\"\n\t\"github.com/minio/minio/internal/logger\"\n\t\"github.com/minio/pkg/v2/policy\"\n\tetcd \"go.etcd.io/etcd/client/v3\"\n)\n\n// UsersSysType - defines the type of users and groups system that is\n// active on the server.\ntype UsersSysType string\n\n// Types of users configured in the server.\nconst (\n\t// This mode uses the internal users system in MinIO.\n\tMinIOUsersSysType UsersSysType = \"MinIOUsersSys\"\n\n\t// This mode uses users and groups from a configured LDAP\n\t// server.\n\tLDAPUsersSysType UsersSysType = \"LDAPUsersSys\"\n)\n\nconst (\n\tstatusEnabled  = \"enabled\"\n\tstatusDisabled = \"disabled\"\n)\n\nconst (\n\tembeddedPolicyType  = \"embedded-policy\"\n\tinheritedPolicyType = \"inherited-policy\"\n)\n\n// IAMSys - config system.\ntype IAMSys struct {\n\t// Need to keep them here to keep alignment - ref: https://golang.org/pkg/sync/atomic/#pkg-note-BUG\n\t// metrics\n\tLastRefreshTimeUnixNano         uint64\n\tLastRefreshDurationMilliseconds uint64\n\tTotalRefreshSuccesses           uint64\n\tTotalRefreshFailures            uint64\n\n\tsync.Mutex\n\n\tiamRefreshInterval time.Duration\n\n\tLDAPConfig   xldap.Config  // only valid if usersSysType is LDAPUsers\n\tOpenIDConfig openid.Config // only valid if OpenID is configured\n\tSTSTLSConfig xtls.Config   // only valid if STS TLS is configured\n\n\tusersSysType UsersSysType\n\n\trolesMap map[arn.ARN]string\n\n\t// Persistence layer for IAM subsystem\n\tstore *IAMStoreSys\n\n\t// configLoaded will be closed and remain so after first load.\n\tconfigLoaded chan struct{}\n}\n\n// IAMUserType represents a user type inside MinIO server\ntype IAMUserType int\n\nconst (\n\tunknownIAMUserType IAMUserType = iota - 1\n\tregUser\n\tstsUser\n\tsvcUser\n)\n\n// LoadGroup - loads a specific group from storage, and updates the\n// memberships cache. If the specified group does not exist in\n// storage, it is removed from in-memory maps as well - this\n// simplifies the implementation for group removal. This is called\n// only via IAM notifications.\nfunc (sys *IAMSys) LoadGroup(ctx context.Context, objAPI ObjectLayer, group string) error {\n\tif !sys.Initialized() {\n\t\treturn errServerNotInitialized\n\t}\n\n\treturn sys.store.GroupNotificationHandler(ctx, group)\n}\n\n// LoadPolicy - reloads a specific canned policy from backend disks or etcd.\nfunc (sys *IAMSys) LoadPolicy(ctx context.Context, objAPI ObjectLayer, policyName string) error {\n\tif !sys.Initialized() {\n\t\treturn errServerNotInitialized\n\t}\n\n\treturn sys.store.PolicyNotificationHandler(ctx, policyName)\n}\n\n// LoadPolicyMapping - loads the mapped policy for a user or group\n// from storage into server memory.\nfunc (sys *IAMSys) LoadPolicyMapping(ctx context.Context, objAPI ObjectLayer, userOrGroup string, userType IAMUserType, isGroup bool) error {\n\tif !sys.Initialized() {\n\t\treturn errServerNotInitialized\n\t}\n\n\treturn sys.store.PolicyMappingNotificationHandler(ctx, userOrGroup, isGroup, userType)\n}\n\n// LoadUser - reloads a specific user from backend disks or etcd.\nfunc (sys *IAMSys) LoadUser(ctx context.Context, objAPI ObjectLayer, accessKey string, userType IAMUserType) error {\n\tif !sys.Initialized() {\n\t\treturn errServerNotInitialized\n\t}\n\n\treturn sys.store.UserNotificationHandler(ctx, accessKey, userType)\n}\n\n// LoadServiceAccount - reloads a specific service account from backend disks or etcd.\nfunc (sys *IAMSys) LoadServiceAccount(ctx context.Context, accessKey string) error {\n\tif !sys.Initialized() {\n\t\treturn errServerNotInitialized\n\t}\n\n\treturn sys.store.UserNotificationHandler(ctx, accessKey, svcUser)\n}\n\n// initStore initializes IAM stores\nfunc (sys *IAMSys) initStore(objAPI ObjectLayer, etcdClient *etcd.Client) {\n\tif sys.LDAPConfig.Enabled() {\n\t\tsys.SetUsersSysType(LDAPUsersSysType)\n\t}\n\n\tif etcdClient == nil {\n\t\tsys.store = &IAMStoreSys{newIAMObjectStore(objAPI, sys.usersSysType)}\n\t} else {\n\t\tsys.store = &IAMStoreSys{newIAMEtcdStore(etcdClient, sys.usersSysType)}\n\t}\n}\n\n// Initialized checks if IAM is initialized\nfunc (sys *IAMSys) Initialized() bool {\n\tif sys == nil {\n\t\treturn false\n\t}\n\tsys.Lock()\n\tdefer sys.Unlock()\n\treturn sys.store != nil\n}\n\n// Load - loads all credentials, policies and policy mappings.\nfunc (sys *IAMSys) Load(ctx context.Context, firstTime bool) error {\n\tloadStartTime := time.Now()\n\terr := sys.store.LoadIAMCache(ctx, firstTime)\n\tif err != nil {\n\t\tatomic.AddUint64(&sys.TotalRefreshFailures, 1)\n\t\treturn err\n\t}\n\tloadDuration := time.Since(loadStartTime)\n\n\tatomic.StoreUint64(&sys.LastRefreshDurationMilliseconds, uint64(loadDuration.Milliseconds()))\n\tatomic.StoreUint64(&sys.LastRefreshTimeUnixNano, uint64(loadStartTime.Add(loadDuration).UnixNano()))\n\tatomic.AddUint64(&sys.TotalRefreshSuccesses, 1)\n\n\tif firstTime {\n\t\tbootstrapTraceMsg(fmt.Sprintf(\"globalIAMSys.Load(): (duration: %s)\", loadDuration))\n\t}\n\n\tselect {\n\tcase <-sys.configLoaded:\n\tdefault:\n\t\txioutil.SafeClose(sys.configLoaded)\n\t}\n\treturn nil\n}\n\n// Init - initializes config system by reading entries from config/iam\nfunc (sys *IAMSys) Init(ctx context.Context, objAPI ObjectLayer, etcdClient *etcd.Client, iamRefreshInterval time.Duration) {\n\tbootstrapTraceMsg(\"IAM initialization started\")\n\tglobalServerConfigMu.RLock()\n\ts := globalServerConfig\n\tglobalServerConfigMu.RUnlock()\n\n\topenidConfig, err := openid.LookupConfig(s,\n\t\tNewHTTPTransport(), xhttp.DrainBody, globalSite.Region)\n\tif err != nil {\n\t\tlogger.LogIf(ctx, fmt.Errorf(\"Unable to initialize OpenID: %w\", err))\n\t}\n\n\t// Initialize if LDAP is enabled\n\tldapConfig, err := xldap.Lookup(s, globalRootCAs)\n\tif err != nil {\n\t\tlogger.LogIf(ctx, fmt.Errorf(\"Unable to parse LDAP configuration: %w\", err))\n\t}\n\n\tstsTLSConfig, err := xtls.Lookup(s[config.IdentityTLSSubSys][config.Default])\n\tif err != nil {\n\t\tlogger.LogIf(ctx, fmt.Errorf(\"Unable to initialize X.509/TLS STS API: %w\", err))\n\t}\n\n\tif stsTLSConfig.InsecureSkipVerify {\n\t\tlogger.LogIf(ctx, fmt.Errorf(\"CRITICAL: enabling %s is not recommended in a production environment\", xtls.EnvIdentityTLSSkipVerify))\n\t}\n\n\tauthNPluginCfg, err := idplugin.LookupConfig(s[config.IdentityPluginSubSys][config.Default],\n\t\tNewHTTPTransport(), xhttp.DrainBody, globalSite.Region)\n\tif err != nil {\n\t\tlogger.LogIf(ctx, fmt.Errorf(\"Unable to initialize AuthNPlugin: %w\", err))\n\t}\n\n\tsetGlobalAuthNPlugin(idplugin.New(GlobalContext, authNPluginCfg))\n\n\tauthZPluginCfg, err := polplugin.LookupConfig(s, GetDefaultConnSettings(), xhttp.DrainBody)\n\tif err != nil {\n\t\tlogger.LogIf(ctx, fmt.Errorf(\"Unable to initialize AuthZPlugin: %w\", err))\n\t}\n\n\tif authZPluginCfg.URL == nil {\n\t\topaCfg, err := opa.LookupConfig(s[config.PolicyOPASubSys][config.Default],\n\t\t\tNewHTTPTransport(), xhttp.DrainBody)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, fmt.Errorf(\"Unable to initialize AuthZPlugin from legacy OPA config: %w\", err))\n\t\t} else {\n\t\t\tauthZPluginCfg.URL = opaCfg.URL\n\t\t\tauthZPluginCfg.AuthToken = opaCfg.AuthToken\n\t\t\tauthZPluginCfg.Transport = opaCfg.Transport\n\t\t\tauthZPluginCfg.CloseRespFn = opaCfg.CloseRespFn\n\t\t}\n\t}\n\n\tsetGlobalAuthZPlugin(polplugin.New(authZPluginCfg))\n\n\tsys.Lock()\n\tdefer sys.Unlock()\n\n\tsys.LDAPConfig = ldapConfig\n\tsys.OpenIDConfig = openidConfig\n\tsys.STSTLSConfig = stsTLSConfig\n\n\tsys.iamRefreshInterval = iamRefreshInterval\n\n\t// Initialize IAM store\n\tsys.initStore(objAPI, etcdClient)\n\n\tretryCtx, cancel := context.WithCancel(ctx)\n\n\t// Indicate to our routine to exit cleanly upon return.\n\tdefer cancel()\n\n\tr := rand.New(rand.NewSource(time.Now().UnixNano()))\n\n\t// Migrate storage format if needed.\n\tfor {\n\t\t// Migrate IAM configuration, if necessary.\n\t\tif err := saveIAMFormat(retryCtx, sys.store); err != nil {\n\t\t\tif configRetriableErrors(err) {\n\t\t\t\tlogger.Info(\"Waiting for all MinIO IAM sub-system to be initialized.. possible cause (%v)\", err)\n\t\t\t\ttime.Sleep(time.Duration(r.Float64() * float64(time.Second)))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlogger.LogIf(ctx, fmt.Errorf(\"IAM sub-system is partially initialized, unable to write the IAM format: %w\", err))\n\t\t\treturn\n\t\t}\n\n\t\tbreak\n\t}\n\n\t// Load IAM data from storage.\n\tfor {\n\t\tif err := sys.Load(retryCtx, true); err != nil {\n\t\t\tif configRetriableErrors(err) {\n\t\t\t\tlogger.Info(\"Waiting for all MinIO IAM sub-system to be initialized.. possible cause (%v)\", err)\n\t\t\t\ttime.Sleep(time.Duration(r.Float64() * float64(time.Second)))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tlogger.LogIf(ctx, fmt.Errorf(\"Unable to initialize IAM sub-system, some users may not be available: %w\", err))\n\t\t\t}\n\t\t}\n\t\tbreak\n\t}\n\n\trefreshInterval := sys.iamRefreshInterval\n\n\tgo sys.periodicRoutines(ctx, refreshInterval)\n\n\t// Load RoleARNs\n\tsys.rolesMap = make(map[arn.ARN]string)\n\n\t// From OpenID\n\tif riMap := sys.OpenIDConfig.GetRoleInfo(); riMap != nil {\n\t\tsys.validateAndAddRolePolicyMappings(ctx, riMap)\n\t}\n\n\t// From AuthN plugin if enabled.\n\tif authn := newGlobalAuthNPluginFn(); authn != nil {\n\t\triMap := authn.GetRoleInfo()\n\t\tsys.validateAndAddRolePolicyMappings(ctx, riMap)\n\t}\n\n\tsys.printIAMRoles()\n\n\tbootstrapTraceMsg(\"finishing IAM loading\")\n}\n\nfunc (sys *IAMSys) periodicRoutines(ctx context.Context, baseInterval time.Duration) {\n\t// Watch for IAM config changes for iamStorageWatcher.\n\twatcher, isWatcher := sys.store.IAMStorageAPI.(iamStorageWatcher)\n\tif isWatcher {\n\t\tgo func() {\n\t\t\tch := watcher.watch(ctx, iamConfigPrefix)\n\t\t\tfor event := range ch {\n\t\t\t\tif err := sys.loadWatchedEvent(ctx, event); err != nil {\n\t\t\t\t\t// we simply log errors\n\t\t\t\t\tlogger.LogIf(ctx, fmt.Errorf(\"Failure in loading watch event: %v\", err))\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\tr := rand.New(rand.NewSource(time.Now().UnixNano()))\n\t// Add a random interval of up to 20% of the base interval.\n\trandInterval := func() time.Duration {\n\t\treturn time.Duration(r.Float64() * float64(baseInterval) * 0.2)\n\t}\n\n\tvar maxDurationSecondsForLog float64 = 5\n\ttimer := time.NewTimer(baseInterval + randInterval())\n\tdefer timer.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-timer.C:\n\t\t\t// Load all IAM items (except STS creds) periodically.\n\t\t\trefreshStart := time.Now()\n\t\t\tif err := sys.Load(ctx, false); err != nil {\n\t\t\t\tlogger.LogIf(ctx, fmt.Errorf(\"Failure in periodic refresh for IAM (took %.2fs): %v\", time.Since(refreshStart).Seconds(), err))\n\t\t\t} else {\n\t\t\t\ttook := time.Since(refreshStart).Seconds()\n\t\t\t\tif took > maxDurationSecondsForLog {\n\t\t\t\t\t// Log if we took a lot of time to load.\n\t\t\t\t\tlogger.Info(\"IAM refresh took %.2fs\", took)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// The following actions are performed about once in 4 times that\n\t\t\t// IAM is refreshed:\n\t\t\tif r.Intn(4) == 0 {\n\t\t\t\t// Purge expired STS credentials.\n\t\t\t\tpurgeStart := time.Now()\n\t\t\t\tif err := sys.store.PurgeExpiredSTS(ctx); err != nil {\n\t\t\t\t\tlogger.LogIf(ctx, fmt.Errorf(\"Failure in periodic STS purge for IAM (took %.2fs): %v\", time.Since(purgeStart).Seconds(), err))\n\t\t\t\t} else {\n\t\t\t\t\ttook := time.Since(purgeStart).Seconds()\n\t\t\t\t\tif took > maxDurationSecondsForLog {\n\t\t\t\t\t\t// Log if we took a lot of time to load.\n\t\t\t\t\t\tlogger.Info(\"IAM expired STS purge took %.2fs\", took)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Poll and remove accounts for those users who were removed\n\t\t\t\t// from LDAP/OpenID.\n\t\t\t\tif sys.LDAPConfig.Enabled() {\n\t\t\t\t\tsys.purgeExpiredCredentialsForLDAP(ctx)\n\t\t\t\t\tsys.updateGroupMembershipsForLDAP(ctx)\n\t\t\t\t}\n\t\t\t\tif sys.OpenIDConfig.ProviderEnabled() {\n\t\t\t\t\tsys.purgeExpiredCredentialsForExternalSSO(ctx)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttimer.Reset(baseInterval + randInterval())\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (sys *IAMSys) validateAndAddRolePolicyMappings(ctx context.Context, m map[arn.ARN]string) {\n\t// Validate that policies associated with roles are defined. If\n\t// authZ plugin is set, role policies are just claims sent to\n\t// the plugin and they need not exist.\n\t//\n\t// If some mapped policies do not exist, we print some error\n\t// messages but continue any way - they can be fixed in the\n\t// running server by creating the policies after start up.\n\tfor arn, rolePolicies := range m {\n\t\tspecifiedPoliciesSet := newMappedPolicy(rolePolicies).policySet()\n\t\tvalidPolicies, _ := sys.store.FilterPolicies(rolePolicies, \"\")\n\t\tknownPoliciesSet := newMappedPolicy(validPolicies).policySet()\n\t\tunknownPoliciesSet := specifiedPoliciesSet.Difference(knownPoliciesSet)\n\t\tif len(unknownPoliciesSet) > 0 {\n\t\t\tauthz := newGlobalAuthZPluginFn()\n\t\t\tif authz == nil {\n\t\t\t\t// Print a warning that some policies mapped to a role are not defined.\n\t\t\t\terrMsg := fmt.Errorf(\n\t\t\t\t\t\"The policies \\\"%s\\\" mapped to role ARN %s are not defined - this role may not work as expected.\",\n\t\t\t\t\tunknownPoliciesSet.ToSlice(), arn.String())\n\t\t\t\tlogger.LogIf(ctx, errMsg)\n\t\t\t}\n\t\t}\n\t\tsys.rolesMap[arn] = rolePolicies\n\t}\n}\n\n// Prints IAM role ARNs.\nfunc (sys *IAMSys) printIAMRoles() {\n\tif len(sys.rolesMap) == 0 {\n\t\treturn\n\t}\n\tvar arns []string\n\tfor arn := range sys.rolesMap {\n\t\tarns = append(arns, arn.String())\n\t}\n\tsort.Strings(arns)\n\tmsgs := make([]string, 0, len(arns))\n\tfor _, arn := range arns {\n\t\tmsgs = append(msgs, color.Bold(arn))\n\t}\n\n\tlogger.Info(fmt.Sprintf(\"%s %s\", color.Blue(\"IAM Roles:\"), strings.Join(msgs, \" \")))\n}\n\n// HasWatcher - returns if the IAM system has a watcher to be notified of\n// changes.\nfunc (sys *IAMSys) HasWatcher() bool {\n\treturn sys.store.HasWatcher()\n}\n\nfunc (sys *IAMSys) loadWatchedEvent(ctx context.Context, event iamWatchEvent) (err error) {\n\tusersPrefix := strings.HasPrefix(event.keyPath, iamConfigUsersPrefix)\n\tgroupsPrefix := strings.HasPrefix(event.keyPath, iamConfigGroupsPrefix)\n\tstsPrefix := strings.HasPrefix(event.keyPath, iamConfigSTSPrefix)\n\tsvcPrefix := strings.HasPrefix(event.keyPath, iamConfigServiceAccountsPrefix)\n\tpolicyPrefix := strings.HasPrefix(event.keyPath, iamConfigPoliciesPrefix)\n\tpolicyDBUsersPrefix := strings.HasPrefix(event.keyPath, iamConfigPolicyDBUsersPrefix)\n\tpolicyDBSTSUsersPrefix := strings.HasPrefix(event.keyPath, iamConfigPolicyDBSTSUsersPrefix)\n\tpolicyDBGroupsPrefix := strings.HasPrefix(event.keyPath, iamConfigPolicyDBGroupsPrefix)\n\n\tctx, cancel := context.WithTimeout(ctx, defaultContextTimeout)\n\tdefer cancel()\n\n\tswitch {\n\tcase usersPrefix:\n\t\taccessKey := path.Dir(strings.TrimPrefix(event.keyPath, iamConfigUsersPrefix))\n\t\terr = sys.store.UserNotificationHandler(ctx, accessKey, regUser)\n\tcase stsPrefix:\n\t\taccessKey := path.Dir(strings.TrimPrefix(event.keyPath, iamConfigSTSPrefix))\n\t\terr = sys.store.UserNotificationHandler(ctx, accessKey, stsUser)\n\tcase svcPrefix:\n\t\taccessKey := path.Dir(strings.TrimPrefix(event.keyPath, iamConfigServiceAccountsPrefix))\n\t\terr = sys.store.UserNotificationHandler(ctx, accessKey, svcUser)\n\tcase groupsPrefix:\n\t\tgroup := path.Dir(strings.TrimPrefix(event.keyPath, iamConfigGroupsPrefix))\n\t\terr = sys.store.GroupNotificationHandler(ctx, group)\n\tcase policyPrefix:\n\t\tpolicyName := path.Dir(strings.TrimPrefix(event.keyPath, iamConfigPoliciesPrefix))\n\t\terr = sys.store.PolicyNotificationHandler(ctx, policyName)\n\tcase policyDBUsersPrefix:\n\t\tpolicyMapFile := strings.TrimPrefix(event.keyPath, iamConfigPolicyDBUsersPrefix)\n\t\tuser := strings.TrimSuffix(policyMapFile, \".json\")\n\t\terr = sys.store.PolicyMappingNotificationHandler(ctx, user, false, regUser)\n\tcase policyDBSTSUsersPrefix:\n\t\tpolicyMapFile := strings.TrimPrefix(event.keyPath, iamConfigPolicyDBSTSUsersPrefix)\n\t\tuser := strings.TrimSuffix(policyMapFile, \".json\")\n\t\terr = sys.store.PolicyMappingNotificationHandler(ctx, user, false, stsUser)\n\tcase policyDBGroupsPrefix:\n\t\tpolicyMapFile := strings.TrimPrefix(event.keyPath, iamConfigPolicyDBGroupsPrefix)\n\t\tuser := strings.TrimSuffix(policyMapFile, \".json\")\n\t\terr = sys.store.PolicyMappingNotificationHandler(ctx, user, true, regUser)\n\t}\n\treturn err\n}\n\n// HasRolePolicy - returns if a role policy is configured for IAM.\nfunc (sys *IAMSys) HasRolePolicy() bool {\n\treturn len(sys.rolesMap) > 0\n}\n\n// GetRolePolicy - returns policies associated with a role ARN.\nfunc (sys *IAMSys) GetRolePolicy(arnStr string) (arn.ARN, string, error) {\n\troleArn, err := arn.Parse(arnStr)\n\tif err != nil {\n\t\treturn arn.ARN{}, \"\", fmt.Errorf(\"RoleARN parse err: %v\", err)\n\t}\n\trolePolicy, ok := sys.rolesMap[roleArn]\n\tif !ok {\n\t\treturn arn.ARN{}, \"\", fmt.Errorf(\"RoleARN %s is not defined.\", arnStr)\n\t}\n\treturn roleArn, rolePolicy, nil\n}\n\n// DeletePolicy - deletes a canned policy from backend or etcd.\nfunc (sys *IAMSys) DeletePolicy(ctx context.Context, policyName string, notifyPeers bool) error {\n\tif !sys.Initialized() {\n\t\treturn errServerNotInitialized\n\t}\n\n\tfor _, v := range policy.DefaultPolicies {\n\t\tif v.Name == policyName {\n\t\t\tif err := checkConfig(ctx, globalObjectAPI, getPolicyDocPath(policyName)); err != nil && err == errConfigNotFound {\n\t\t\t\treturn fmt.Errorf(\"inbuilt policy `%s` not allowed to be deleted\", policyName)\n\t\t\t}\n\t\t}\n\t}\n\n\terr := sys.store.DeletePolicy(ctx, policyName)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !notifyPeers || sys.HasWatcher() {\n\t\treturn nil\n\t}\n\n\t// Notify all other MinIO peers to delete policy\n\tfor _, nerr := range globalNotificationSys.DeletePolicy(policyName) {\n\t\tif nerr.Err != nil {\n\t\t\tlogger.GetReqInfo(ctx).SetTags(\"peerAddress\", nerr.Host.String())\n\t\t\tlogger.LogIf(ctx, nerr.Err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// InfoPolicy - returns the policy definition with some metadata.\nfunc (sys *IAMSys) InfoPolicy(policyName string) (*madmin.PolicyInfo, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\n\td, err := sys.store.GetPolicyDoc(policyName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpdata, err := json.Marshal(d.Policy)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &madmin.PolicyInfo{\n\t\tPolicyName: policyName,\n\t\tPolicy:     pdata,\n\t\tCreateDate: d.CreateDate,\n\t\tUpdateDate: d.UpdateDate,\n\t}, nil\n}\n\n// ListPolicies - lists all canned policies.\nfunc (sys *IAMSys) ListPolicies(ctx context.Context, bucketName string) (map[string]policy.Policy, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\n\treturn sys.store.ListPolicies(ctx, bucketName)\n}\n\n// ListPolicyDocs - lists all canned policy docs.\nfunc (sys *IAMSys) ListPolicyDocs(ctx context.Context, bucketName string) (map[string]PolicyDoc, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\n\treturn sys.store.ListPolicyDocs(ctx, bucketName)\n}\n\n// SetPolicy - sets a new named policy.\nfunc (sys *IAMSys) SetPolicy(ctx context.Context, policyName string, p policy.Policy) (time.Time, error) {\n\tif !sys.Initialized() {\n\t\treturn time.Time{}, errServerNotInitialized\n\t}\n\n\tupdatedAt, err := sys.store.SetPolicy(ctx, policyName, p)\n\tif err != nil {\n\t\treturn updatedAt, err\n\t}\n\n\tif !sys.HasWatcher() {\n\t\t// Notify all other MinIO peers to reload policy\n\t\tfor _, nerr := range globalNotificationSys.LoadPolicy(policyName) {\n\t\t\tif nerr.Err != nil {\n\t\t\t\tlogger.GetReqInfo(ctx).SetTags(\"peerAddress\", nerr.Host.String())\n\t\t\t\tlogger.LogIf(ctx, nerr.Err)\n\t\t\t}\n\t\t}\n\t}\n\treturn updatedAt, nil\n}\n\n// DeleteUser - delete user (only for long-term users not STS users).\nfunc (sys *IAMSys) DeleteUser(ctx context.Context, accessKey string, notifyPeers bool) error {\n\tif !sys.Initialized() {\n\t\treturn errServerNotInitialized\n\t}\n\n\tif err := sys.store.DeleteUser(ctx, accessKey, regUser); err != nil {\n\t\treturn err\n\t}\n\n\t// Notify all other MinIO peers to delete user.\n\tif notifyPeers && !sys.HasWatcher() {\n\t\tfor _, nerr := range globalNotificationSys.DeleteUser(accessKey) {\n\t\t\tif nerr.Err != nil {\n\t\t\t\tlogger.GetReqInfo(ctx).SetTags(\"peerAddress\", nerr.Host.String())\n\t\t\t\tlogger.LogIf(ctx, nerr.Err)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// CurrentPolicies - returns comma separated policy string, from\n// an input policy after validating if there are any current\n// policies which exist on MinIO corresponding to the input.\nfunc (sys *IAMSys) CurrentPolicies(policyName string) string {\n\tif !sys.Initialized() {\n\t\treturn \"\"\n\t}\n\n\tpolicies, _ := sys.store.FilterPolicies(policyName, \"\")\n\treturn policies\n}\n\nfunc (sys *IAMSys) notifyForUser(ctx context.Context, accessKey string, isTemp bool) {\n\t// Notify all other MinIO peers to reload user.\n\tif !sys.HasWatcher() {\n\t\tfor _, nerr := range globalNotificationSys.LoadUser(accessKey, isTemp) {\n\t\t\tif nerr.Err != nil {\n\t\t\t\tlogger.GetReqInfo(ctx).SetTags(\"peerAddress\", nerr.Host.String())\n\t\t\t\tlogger.LogIf(ctx, nerr.Err)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// SetTempUser - set temporary user credentials, these credentials have an\n// expiry. The permissions for these STS credentials is determined in one of the\n// following ways:\n//\n// - RoleARN - if a role-arn is specified in the request, the STS credential's\n// policy is the role's policy.\n//\n// - inherited from parent - this is the case for AssumeRole API, where the\n// parent user is an actual real user with their own (permanent) credentials and\n// policy association.\n//\n// - inherited from \"virtual\" parent - this is the case for AssumeRoleWithLDAP\n// where the parent user is the DN of the actual LDAP user. The parent user\n// itself cannot login, but the policy associated with them determines the base\n// policy for the STS credential. The policy mapping can be updated by the\n// administrator.\n//\n// - from `Subject.CommonName` field from the STS request for\n// AssumeRoleWithCertificate. In this case, the policy for the STS credential\n// has the same name as the value of this field.\n//\n// - from special JWT claim from STS request for AssumeRoleWithOIDC API (when\n// not using RoleARN). The claim value can be a string or a list and refers to\n// the names of access policies.\n//\n// For all except the RoleARN case, the implementation is the same - the policy\n// for the STS credential is associated with a parent user. For the\n// AssumeRoleWithCertificate case, the \"virtual\" parent user is the value of the\n// `Subject.CommonName` field. For the OIDC (without RoleARN) case the \"virtual\"\n// parent is derived as a concatenation of the `sub` and `iss` fields. The\n// policies applicable to the STS credential are associated with this \"virtual\"\n// parent.\n//\n// When a policyName is given to this function, the policy association is\n// created and stored in the IAM store. Thus, it should NOT be given for the\n// role-arn case (because the role-to-policy mapping is separately stored\n// elsewhere), the AssumeRole case (because the parent user is real and their\n// policy is associated via policy-set API) and the AssumeRoleWithLDAP case\n// (because the policy association is made via policy-set API).\nfunc (sys *IAMSys) SetTempUser(ctx context.Context, accessKey string, cred auth.Credentials, policyName string) (time.Time, error) {\n\tif !sys.Initialized() {\n\t\treturn time.Time{}, errServerNotInitialized\n\t}\n\n\tif newGlobalAuthZPluginFn() != nil {\n\t\t// If OPA is set, we do not need to set a policy mapping.\n\t\tpolicyName = \"\"\n\t}\n\n\tupdatedAt, err := sys.store.SetTempUser(ctx, accessKey, cred, policyName)\n\tif err != nil {\n\t\treturn time.Time{}, err\n\t}\n\n\tsys.notifyForUser(ctx, cred.AccessKey, true)\n\n\treturn updatedAt, nil\n}\n\n// ListBucketUsers - list all users who can access this 'bucket'\nfunc (sys *IAMSys) ListBucketUsers(ctx context.Context, bucket string) (map[string]madmin.UserInfo, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\n\tselect {\n\tcase <-sys.configLoaded:\n\t\treturn sys.store.GetBucketUsers(bucket)\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\t}\n}\n\n// ListUsers - list all users.\nfunc (sys *IAMSys) ListUsers(ctx context.Context) (map[string]madmin.UserInfo, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\tselect {\n\tcase <-sys.configLoaded:\n\t\treturn sys.store.GetUsers(), nil\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\t}\n}\n\n// ListLDAPUsers - list LDAP users which has\nfunc (sys *IAMSys) ListLDAPUsers(ctx context.Context) (map[string]madmin.UserInfo, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\n\tif sys.usersSysType != LDAPUsersSysType {\n\t\treturn nil, errIAMActionNotAllowed\n\t}\n\n\tselect {\n\tcase <-sys.configLoaded:\n\t\tldapUsers := make(map[string]madmin.UserInfo)\n\t\tfor user, policy := range sys.store.GetUsersWithMappedPolicies() {\n\t\t\tldapUsers[user] = madmin.UserInfo{\n\t\t\t\tPolicyName: policy,\n\t\t\t\tStatus:     madmin.AccountEnabled,\n\t\t\t}\n\t\t}\n\t\treturn ldapUsers, nil\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\t}\n}\n\n// QueryLDAPPolicyEntities - queries policy associations for LDAP users/groups/policies.\nfunc (sys *IAMSys) QueryLDAPPolicyEntities(ctx context.Context, q madmin.PolicyEntitiesQuery) (*madmin.PolicyEntitiesResult, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\n\tif !sys.LDAPConfig.Enabled() {\n\t\treturn nil, errIAMActionNotAllowed\n\t}\n\n\tselect {\n\tcase <-sys.configLoaded:\n\t\tpe := sys.store.ListPolicyMappings(q, sys.LDAPConfig.IsLDAPUserDN, sys.LDAPConfig.IsLDAPGroupDN)\n\t\tpe.Timestamp = UTCNow()\n\t\treturn &pe, nil\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\t}\n}\n\n// IsTempUser - returns if given key is a temporary user and parent user.\nfunc (sys *IAMSys) IsTempUser(name string) (bool, string, error) {\n\tif !sys.Initialized() {\n\t\treturn false, \"\", errServerNotInitialized\n\t}\n\n\tu, found := sys.store.GetUser(name)\n\tif !found {\n\t\treturn false, \"\", errNoSuchUser\n\t}\n\tcred := u.Credentials\n\tif cred.IsTemp() {\n\t\treturn true, cred.ParentUser, nil\n\t}\n\n\treturn false, \"\", nil\n}\n\n// IsServiceAccount - returns if given key is a service account\nfunc (sys *IAMSys) IsServiceAccount(name string) (bool, string, error) {\n\tif !sys.Initialized() {\n\t\treturn false, \"\", errServerNotInitialized\n\t}\n\n\tu, found := sys.store.GetUser(name)\n\tif !found {\n\t\treturn false, \"\", errNoSuchUser\n\t}\n\tcred := u.Credentials\n\tif cred.IsServiceAccount() {\n\t\treturn true, cred.ParentUser, nil\n\t}\n\n\treturn false, \"\", nil\n}\n\n// GetUserInfo - get info on a user.\nfunc (sys *IAMSys) GetUserInfo(ctx context.Context, name string) (u madmin.UserInfo, err error) {\n\tif !sys.Initialized() {\n\t\treturn u, errServerNotInitialized\n\t}\n\n\tloadUserCalled := false\n\tselect {\n\tcase <-sys.configLoaded:\n\tdefault:\n\t\tsys.store.LoadUser(ctx, name)\n\t\tloadUserCalled = true\n\t}\n\n\tuserInfo, err := sys.store.GetUserInfo(name)\n\tif err == errNoSuchUser && !loadUserCalled {\n\t\tsys.store.LoadUser(ctx, name)\n\t\tuserInfo, err = sys.store.GetUserInfo(name)\n\t}\n\treturn userInfo, err\n}\n\n// QueryPolicyEntities - queries policy associations for builtin users/groups/policies.\nfunc (sys *IAMSys) QueryPolicyEntities(ctx context.Context, q madmin.PolicyEntitiesQuery) (*madmin.PolicyEntitiesResult, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\n\tselect {\n\tcase <-sys.configLoaded:\n\t\tvar userPredicate, groupPredicate func(string) bool\n\t\tif sys.LDAPConfig.Enabled() {\n\t\t\tuserPredicate = func(s string) bool {\n\t\t\t\treturn !sys.LDAPConfig.IsLDAPUserDN(s)\n\t\t\t}\n\t\t\tgroupPredicate = func(s string) bool {\n\t\t\t\treturn !sys.LDAPConfig.IsLDAPGroupDN(s)\n\t\t\t}\n\t\t}\n\t\tpe := sys.store.ListPolicyMappings(q, userPredicate, groupPredicate)\n\t\tpe.Timestamp = UTCNow()\n\t\treturn &pe, nil\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\t}\n}\n\n// SetUserStatus - sets current user status, supports disabled or enabled.\nfunc (sys *IAMSys) SetUserStatus(ctx context.Context, accessKey string, status madmin.AccountStatus) (updatedAt time.Time, err error) {\n\tif !sys.Initialized() {\n\t\treturn updatedAt, errServerNotInitialized\n\t}\n\n\tif sys.usersSysType != MinIOUsersSysType {\n\t\treturn updatedAt, errIAMActionNotAllowed\n\t}\n\n\tupdatedAt, err = sys.store.SetUserStatus(ctx, accessKey, status)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tsys.notifyForUser(ctx, accessKey, false)\n\treturn updatedAt, nil\n}\n\nfunc (sys *IAMSys) notifyForServiceAccount(ctx context.Context, accessKey string) {\n\t// Notify all other Minio peers to reload the service account\n\tif !sys.HasWatcher() {\n\t\tfor _, nerr := range globalNotificationSys.LoadServiceAccount(accessKey) {\n\t\t\tif nerr.Err != nil {\n\t\t\t\tlogger.GetReqInfo(ctx).SetTags(\"peerAddress\", nerr.Host.String())\n\t\t\t\tlogger.LogIf(ctx, nerr.Err)\n\t\t\t}\n\t\t}\n\t}\n}\n\ntype newServiceAccountOpts struct {\n\tsessionPolicy              *policy.Policy\n\taccessKey                  string\n\tsecretKey                  string\n\tname, description          string\n\texpiration                 *time.Time\n\tallowSiteReplicatorAccount bool // allow creating internal service account for site-replication.\n\n\tclaims map[string]interface{}\n}\n\n// NewServiceAccount - create a new service account\nfunc (sys *IAMSys) NewServiceAccount(ctx context.Context, parentUser string, groups []string, opts newServiceAccountOpts) (auth.Credentials, time.Time, error) {\n\tif !sys.Initialized() {\n\t\treturn auth.Credentials{}, time.Time{}, errServerNotInitialized\n\t}\n\n\tif parentUser == \"\" {\n\t\treturn auth.Credentials{}, time.Time{}, errInvalidArgument\n\t}\n\n\tvar policyBuf []byte\n\tif opts.sessionPolicy != nil {\n\t\terr := opts.sessionPolicy.Validate()\n\t\tif err != nil {\n\t\t\treturn auth.Credentials{}, time.Time{}, err\n\t\t}\n\t\tpolicyBuf, err = json.Marshal(opts.sessionPolicy)\n\t\tif err != nil {\n\t\t\treturn auth.Credentials{}, time.Time{}, err\n\t\t}\n\t\tif len(policyBuf) > 2048 {\n\t\t\treturn auth.Credentials{}, time.Time{}, errSessionPolicyTooLarge\n\t\t}\n\t}\n\n\t// found newly requested service account, to be same as\n\t// parentUser, reject such operations.\n\tif parentUser == opts.accessKey {\n\t\treturn auth.Credentials{}, time.Time{}, errIAMActionNotAllowed\n\t}\n\tif siteReplicatorSvcAcc == opts.accessKey && !opts.allowSiteReplicatorAccount {\n\t\treturn auth.Credentials{}, time.Time{}, errIAMActionNotAllowed\n\t}\n\tm := make(map[string]interface{})\n\tm[parentClaim] = parentUser\n\n\tif len(policyBuf) > 0 {\n\t\tm[policy.SessionPolicyName] = base64.StdEncoding.EncodeToString(policyBuf)\n\t\tm[iamPolicyClaimNameSA()] = embeddedPolicyType\n\t} else {\n\t\tm[iamPolicyClaimNameSA()] = inheritedPolicyType\n\t}\n\n\t// Add all the necessary claims for the service account.\n\tfor k, v := range opts.claims {\n\t\t_, ok := m[k]\n\t\tif !ok {\n\t\t\tm[k] = v\n\t\t}\n\t}\n\n\tvar accessKey, secretKey string\n\tvar err error\n\tif len(opts.accessKey) > 0 {\n\t\taccessKey, secretKey = opts.accessKey, opts.secretKey\n\t} else {\n\t\taccessKey, secretKey, err = auth.GenerateCredentials()\n\t\tif err != nil {\n\t\t\treturn auth.Credentials{}, time.Time{}, err\n\t\t}\n\t}\n\tcred, err := auth.CreateNewCredentialsWithMetadata(accessKey, secretKey, m, secretKey)\n\tif err != nil {\n\t\treturn auth.Credentials{}, time.Time{}, err\n\t}\n\tcred.ParentUser = parentUser\n\tcred.Groups = groups\n\tcred.Status = string(auth.AccountOn)\n\tcred.Name = opts.name\n\tcred.Description = opts.description\n\n\tif opts.expiration != nil {\n\t\texpirationInUTC := opts.expiration.UTC()\n\t\tif err := validateSvcExpirationInUTC(expirationInUTC); err != nil {\n\t\t\treturn auth.Credentials{}, time.Time{}, err\n\t\t}\n\t\tcred.Expiration = expirationInUTC\n\t}\n\n\tupdatedAt, err := sys.store.AddServiceAccount(ctx, cred)\n\tif err != nil {\n\t\treturn auth.Credentials{}, time.Time{}, err\n\t}\n\n\tsys.notifyForServiceAccount(ctx, cred.AccessKey)\n\treturn cred, updatedAt, nil\n}\n\ntype updateServiceAccountOpts struct {\n\tsessionPolicy     *policy.Policy\n\tsecretKey         string\n\tstatus            string\n\tname, description string\n\texpiration        *time.Time\n}\n\n// UpdateServiceAccount - edit a service account\nfunc (sys *IAMSys) UpdateServiceAccount(ctx context.Context, accessKey string, opts updateServiceAccountOpts) (updatedAt time.Time, err error) {\n\tif !sys.Initialized() {\n\t\treturn updatedAt, errServerNotInitialized\n\t}\n\n\tupdatedAt, err = sys.store.UpdateServiceAccount(ctx, accessKey, opts)\n\tif err != nil {\n\t\treturn updatedAt, err\n\t}\n\n\tsys.notifyForServiceAccount(ctx, accessKey)\n\treturn updatedAt, nil\n}\n\n// ListServiceAccounts - lists all service accounts associated to a specific user\nfunc (sys *IAMSys) ListServiceAccounts(ctx context.Context, accessKey string) ([]auth.Credentials, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\n\tselect {\n\tcase <-sys.configLoaded:\n\t\treturn sys.store.ListServiceAccounts(ctx, accessKey)\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\t}\n}\n\n// ListTempAccounts - lists all temporary service accounts associated to a specific user\nfunc (sys *IAMSys) ListTempAccounts(ctx context.Context, accessKey string) ([]UserIdentity, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\n\tselect {\n\tcase <-sys.configLoaded:\n\t\treturn sys.store.ListTempAccounts(ctx, accessKey)\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\t}\n}\n\n// ListSTSAccounts - lists all STS accounts associated to a specific user\nfunc (sys *IAMSys) ListSTSAccounts(ctx context.Context, accessKey string) ([]auth.Credentials, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\n\tselect {\n\tcase <-sys.configLoaded:\n\t\treturn sys.store.ListSTSAccounts(ctx, accessKey)\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\t}\n}\n\n// GetServiceAccount - wrapper method to get information about a service account\nfunc (sys *IAMSys) GetServiceAccount(ctx context.Context, accessKey string) (auth.Credentials, *policy.Policy, error) {\n\tsa, embeddedPolicy, err := sys.getServiceAccount(ctx, accessKey)\n\tif err != nil {\n\t\treturn auth.Credentials{}, nil, err\n\t}\n\t// Hide secret & session keys\n\tsa.Credentials.SecretKey = \"\"\n\tsa.Credentials.SessionToken = \"\"\n\treturn sa.Credentials, embeddedPolicy, nil\n}\n\nfunc (sys *IAMSys) getServiceAccount(ctx context.Context, accessKey string) (UserIdentity, *policy.Policy, error) {\n\tsa, jwtClaims, err := sys.getAccountWithClaims(ctx, accessKey)\n\tif err != nil {\n\t\tif err == errNoSuchAccount {\n\t\t\treturn UserIdentity{}, nil, errNoSuchServiceAccount\n\t\t}\n\t\treturn UserIdentity{}, nil, err\n\t}\n\tif !sa.Credentials.IsServiceAccount() {\n\t\treturn UserIdentity{}, nil, errNoSuchServiceAccount\n\t}\n\n\tvar embeddedPolicy *policy.Policy\n\n\tpt, ptok := jwtClaims.Lookup(iamPolicyClaimNameSA())\n\tsp, spok := jwtClaims.Lookup(policy.SessionPolicyName)\n\tif ptok && spok && pt == embeddedPolicyType {\n\t\tpolicyBytes, err := base64.StdEncoding.DecodeString(sp)\n\t\tif err != nil {\n\t\t\treturn UserIdentity{}, nil, err\n\t\t}\n\t\tembeddedPolicy, err = policy.ParseConfig(bytes.NewReader(policyBytes))\n\t\tif err != nil {\n\t\t\treturn UserIdentity{}, nil, err\n\t\t}\n\t}\n\n\treturn sa, embeddedPolicy, nil\n}\n\n// GetTemporaryAccount - wrapper method to get information about a temporary account\nfunc (sys *IAMSys) GetTemporaryAccount(ctx context.Context, accessKey string) (auth.Credentials, *policy.Policy, error) {\n\ttmpAcc, embeddedPolicy, err := sys.getTempAccount(ctx, accessKey)\n\tif err != nil {\n\t\treturn auth.Credentials{}, nil, err\n\t}\n\t// Hide secret & session keys\n\ttmpAcc.Credentials.SecretKey = \"\"\n\ttmpAcc.Credentials.SessionToken = \"\"\n\treturn tmpAcc.Credentials, embeddedPolicy, nil\n}\n\nfunc (sys *IAMSys) getTempAccount(ctx context.Context, accessKey string) (UserIdentity, *policy.Policy, error) {\n\ttmpAcc, claims, err := sys.getAccountWithClaims(ctx, accessKey)\n\tif err != nil {\n\t\tif err == errNoSuchAccount {\n\t\t\treturn UserIdentity{}, nil, errNoSuchTempAccount\n\t\t}\n\t\treturn UserIdentity{}, nil, err\n\t}\n\tif !tmpAcc.Credentials.IsTemp() {\n\t\treturn UserIdentity{}, nil, errNoSuchTempAccount\n\t}\n\n\tvar embeddedPolicy *policy.Policy\n\n\tsp, spok := claims.Lookup(policy.SessionPolicyName)\n\tif spok {\n\t\tpolicyBytes, err := base64.StdEncoding.DecodeString(sp)\n\t\tif err != nil {\n\t\t\treturn UserIdentity{}, nil, err\n\t\t}\n\t\tembeddedPolicy, err = policy.ParseConfig(bytes.NewReader(policyBytes))\n\t\tif err != nil {\n\t\t\treturn UserIdentity{}, nil, err\n\t\t}\n\t}\n\n\treturn tmpAcc, embeddedPolicy, nil\n}\n\n// getAccountWithClaims - gets information about an account with claims\nfunc (sys *IAMSys) getAccountWithClaims(ctx context.Context, accessKey string) (UserIdentity, *jwt.MapClaims, error) {\n\tif !sys.Initialized() {\n\t\treturn UserIdentity{}, nil, errServerNotInitialized\n\t}\n\n\tacc, ok := sys.store.GetUser(accessKey)\n\tif !ok {\n\t\treturn UserIdentity{}, nil, errNoSuchAccount\n\t}\n\n\tjwtClaims, err := extractJWTClaims(acc)\n\tif err != nil {\n\t\treturn UserIdentity{}, nil, err\n\t}\n\n\treturn acc, jwtClaims, nil\n}\n\n// GetClaimsForSvcAcc - gets the claims associated with the service account.\nfunc (sys *IAMSys) GetClaimsForSvcAcc(ctx context.Context, accessKey string) (map[string]interface{}, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\n\tif sys.usersSysType != LDAPUsersSysType {\n\t\treturn nil, nil\n\t}\n\n\tsa, ok := sys.store.GetUser(accessKey)\n\tif !ok || !sa.Credentials.IsServiceAccount() {\n\t\treturn nil, errNoSuchServiceAccount\n\t}\n\n\tjwtClaims, err := extractJWTClaims(sa)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn jwtClaims.Map(), nil\n}\n\n// DeleteServiceAccount - delete a service account\nfunc (sys *IAMSys) DeleteServiceAccount(ctx context.Context, accessKey string, notifyPeers bool) error {\n\tif !sys.Initialized() {\n\t\treturn errServerNotInitialized\n\t}\n\n\tsa, ok := sys.store.GetUser(accessKey)\n\tif !ok || !sa.Credentials.IsServiceAccount() {\n\t\treturn nil\n\t}\n\n\tif err := sys.store.DeleteUser(ctx, accessKey, svcUser); err != nil {\n\t\treturn err\n\t}\n\n\tif notifyPeers && !sys.HasWatcher() {\n\t\tfor _, nerr := range globalNotificationSys.DeleteServiceAccount(accessKey) {\n\t\t\tif nerr.Err != nil {\n\t\t\t\tlogger.GetReqInfo(ctx).SetTags(\"peerAddress\", nerr.Host.String())\n\t\t\t\tlogger.LogIf(ctx, nerr.Err)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// CreateUser - create new user credentials and policy, if user already exists\n// they shall be rewritten with new inputs.\nfunc (sys *IAMSys) CreateUser(ctx context.Context, accessKey string, ureq madmin.AddOrUpdateUserReq) (updatedAt time.Time, err error) {\n\tif !sys.Initialized() {\n\t\treturn updatedAt, errServerNotInitialized\n\t}\n\n\tif sys.usersSysType != MinIOUsersSysType {\n\t\treturn updatedAt, errIAMActionNotAllowed\n\t}\n\n\tif !auth.IsAccessKeyValid(accessKey) {\n\t\treturn updatedAt, auth.ErrInvalidAccessKeyLength\n\t}\n\n\tif !auth.IsSecretKeyValid(ureq.SecretKey) {\n\t\treturn updatedAt, auth.ErrInvalidSecretKeyLength\n\t}\n\n\tupdatedAt, err = sys.store.AddUser(ctx, accessKey, ureq)\n\tif err != nil {\n\t\treturn updatedAt, err\n\t}\n\n\tsys.notifyForUser(ctx, accessKey, false)\n\treturn updatedAt, nil\n}\n\n// SetUserSecretKey - sets user secret key\nfunc (sys *IAMSys) SetUserSecretKey(ctx context.Context, accessKey string, secretKey string) error {\n\tif !sys.Initialized() {\n\t\treturn errServerNotInitialized\n\t}\n\n\tif sys.usersSysType != MinIOUsersSysType {\n\t\treturn errIAMActionNotAllowed\n\t}\n\n\tif !auth.IsAccessKeyValid(accessKey) {\n\t\treturn auth.ErrInvalidAccessKeyLength\n\t}\n\n\tif !auth.IsSecretKeyValid(secretKey) {\n\t\treturn auth.ErrInvalidSecretKeyLength\n\t}\n\n\treturn sys.store.UpdateUserSecretKey(ctx, accessKey, secretKey)\n}\n\n// purgeExpiredCredentialsForExternalSSO - validates if local credentials are still valid\n// by checking remote IDP if the relevant users are still active and present.\nfunc (sys *IAMSys) purgeExpiredCredentialsForExternalSSO(ctx context.Context) {\n\tparentUsersMap := sys.store.GetAllParentUsers()\n\tvar expiredUsers []string\n\tfor parentUser, puInfo := range parentUsersMap {\n\t\t// There are multiple role ARNs for parent user only when there\n\t\t// are multiple openid provider configurations with the same ID\n\t\t// provider. We lookup the provider associated with some one of\n\t\t// the roleARNs to check if the user still exists. If they don't\n\t\t// we can safely remove credentials for this parent user\n\t\t// associated with any of the provider configurations.\n\t\t//\n\t\t// If there is no roleARN mapped to the user, the user may be\n\t\t// coming from a policy claim based openid provider.\n\t\troleArns := puInfo.roleArns.ToSlice()\n\t\tvar roleArn string\n\t\tif len(roleArns) == 0 {\n\t\t\tlogger.LogIf(GlobalContext,\n\t\t\t\tfmt.Errorf(\"parentUser: %s had no roleArns mapped!\", parentUser))\n\t\t\tcontinue\n\t\t}\n\t\troleArn = roleArns[0]\n\t\tu, err := sys.OpenIDConfig.LookupUser(roleArn, puInfo.subClaimValue)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(GlobalContext, err)\n\t\t\tcontinue\n\t\t}\n\t\t// If user is set to \"disabled\", we will remove them\n\t\t// subsequently.\n\t\tif !u.Enabled {\n\t\t\texpiredUsers = append(expiredUsers, parentUser)\n\t\t}\n\t}\n\n\t// We ignore any errors\n\t_ = sys.store.DeleteUsers(ctx, expiredUsers)\n}\n\n// purgeExpiredCredentialsForLDAP - validates if local credentials are still\n// valid by checking LDAP server if the relevant users are still present.\nfunc (sys *IAMSys) purgeExpiredCredentialsForLDAP(ctx context.Context) {\n\tparentUsers := sys.store.GetAllParentUsers()\n\tvar allDistNames []string\n\tfor parentUser := range parentUsers {\n\t\tif !sys.LDAPConfig.IsLDAPUserDN(parentUser) {\n\t\t\tcontinue\n\t\t}\n\n\t\tallDistNames = append(allDistNames, parentUser)\n\t}\n\n\texpiredUsers, err := sys.LDAPConfig.GetNonEligibleUserDistNames(allDistNames)\n\tif err != nil {\n\t\t// Log and return on error - perhaps it'll work the next time.\n\t\tlogger.LogIf(GlobalContext, err)\n\t\treturn\n\t}\n\n\t// We ignore any errors\n\t_ = sys.store.DeleteUsers(ctx, expiredUsers)\n}\n\n// updateGroupMembershipsForLDAP - updates the list of groups associated with the credential.\nfunc (sys *IAMSys) updateGroupMembershipsForLDAP(ctx context.Context) {\n\t// 1. Collect all LDAP users with active creds.\n\tallCreds := sys.store.GetSTSAndServiceAccounts()\n\t// List of unique LDAP (parent) user DNs that have active creds\n\tvar parentUsers []string\n\t// Map of LDAP user to list of active credential objects\n\tparentUserToCredsMap := make(map[string][]auth.Credentials)\n\t// DN to ldap username mapping for each LDAP user\n\tparentUserToLDAPUsernameMap := make(map[string]string)\n\tfor _, cred := range allCreds {\n\t\t// Expired credentials don't need parent user updates.\n\t\tif cred.IsExpired() {\n\t\t\tcontinue\n\t\t}\n\n\t\tif !sys.LDAPConfig.IsLDAPUserDN(cred.ParentUser) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Check if this is the first time we are\n\t\t// encountering this LDAP user.\n\t\tif _, ok := parentUserToCredsMap[cred.ParentUser]; !ok {\n\t\t\t// Try to find the ldapUsername for this\n\t\t\t// parentUser by extracting JWT claims\n\t\t\tvar (\n\t\t\t\tjwtClaims *jwt.MapClaims\n\t\t\t\terr       error\n\t\t\t)\n\n\t\t\tif cred.SessionToken == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif cred.IsServiceAccount() {\n\t\t\t\tjwtClaims, err = auth.ExtractClaims(cred.SessionToken, cred.SecretKey)\n\t\t\t\tif err != nil {\n\t\t\t\t\tjwtClaims, err = auth.ExtractClaims(cred.SessionToken, globalActiveCred.SecretKey)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjwtClaims, err = auth.ExtractClaims(cred.SessionToken, globalActiveCred.SecretKey)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\t// skip this cred - session token seems invalid\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tldapUsername, ok := jwtClaims.Lookup(ldapUserN)\n\t\t\tif !ok {\n\t\t\t\t// skip this cred - we dont have the\n\t\t\t\t// username info needed\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Collect each new cred.ParentUser into parentUsers\n\t\t\tparentUsers = append(parentUsers, cred.ParentUser)\n\n\t\t\t// Update the ldapUsernameMap\n\t\t\tparentUserToLDAPUsernameMap[cred.ParentUser] = ldapUsername\n\t\t}\n\t\tparentUserToCredsMap[cred.ParentUser] = append(parentUserToCredsMap[cred.ParentUser], cred)\n\n\t}\n\n\t// 2. Query LDAP server for groups of the LDAP users collected.\n\tupdatedGroups, err := sys.LDAPConfig.LookupGroupMemberships(parentUsers, parentUserToLDAPUsernameMap)\n\tif err != nil {\n\t\t// Log and return on error - perhaps it'll work the next time.\n\t\tlogger.LogIf(GlobalContext, err)\n\t\treturn\n\t}\n\n\t// 3. Update creds for those users whose groups are changed\n\tfor _, parentUser := range parentUsers {\n\t\tcurrGroupsSet := updatedGroups[parentUser]\n\t\tcurrGroups := currGroupsSet.ToSlice()\n\t\tfor _, cred := range parentUserToCredsMap[parentUser] {\n\t\t\tgSet := set.CreateStringSet(cred.Groups...)\n\t\t\tif gSet.Equals(currGroupsSet) {\n\t\t\t\t// No change to groups memberships for this\n\t\t\t\t// credential.\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Expired credentials don't need group membership updates.\n\t\t\tif cred.IsExpired() {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tcred.Groups = currGroups\n\t\t\tif err := sys.store.UpdateUserIdentity(ctx, cred); err != nil {\n\t\t\t\t// Log and continue error - perhaps it'll work the next time.\n\t\t\t\tlogger.LogIf(GlobalContext, err)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// GetUser - get user credentials\nfunc (sys *IAMSys) GetUser(ctx context.Context, accessKey string) (u UserIdentity, ok bool) {\n\tif !sys.Initialized() {\n\t\treturn u, false\n\t}\n\n\tif accessKey == globalActiveCred.AccessKey {\n\t\treturn newUserIdentity(globalActiveCred), true\n\t}\n\n\tloadUserCalled := false\n\tselect {\n\tcase <-sys.configLoaded:\n\tdefault:\n\t\tsys.store.LoadUser(ctx, accessKey)\n\t\tloadUserCalled = true\n\t}\n\n\tu, ok = sys.store.GetUser(accessKey)\n\tif !ok && !loadUserCalled {\n\t\tsys.store.LoadUser(ctx, accessKey)\n\t\tu, ok = sys.store.GetUser(accessKey)\n\t}\n\n\treturn u, ok && u.Credentials.IsValid()\n}\n\n// Notify all other MinIO peers to load group.\nfunc (sys *IAMSys) notifyForGroup(ctx context.Context, group string) {\n\tif !sys.HasWatcher() {\n\t\tfor _, nerr := range globalNotificationSys.LoadGroup(group) {\n\t\t\tif nerr.Err != nil {\n\t\t\t\tlogger.GetReqInfo(ctx).SetTags(\"peerAddress\", nerr.Host.String())\n\t\t\t\tlogger.LogIf(ctx, nerr.Err)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// AddUsersToGroup - adds users to a group, creating the group if\n// needed. No error if user(s) already are in the group.\nfunc (sys *IAMSys) AddUsersToGroup(ctx context.Context, group string, members []string) (updatedAt time.Time, err error) {\n\tif !sys.Initialized() {\n\t\treturn updatedAt, errServerNotInitialized\n\t}\n\n\tif sys.usersSysType != MinIOUsersSysType {\n\t\treturn updatedAt, errIAMActionNotAllowed\n\t}\n\n\tupdatedAt, err = sys.store.AddUsersToGroup(ctx, group, members)\n\tif err != nil {\n\t\treturn updatedAt, err\n\t}\n\n\tsys.notifyForGroup(ctx, group)\n\treturn updatedAt, nil\n}\n\n// RemoveUsersFromGroup - remove users from group. If no users are\n// given, and the group is empty, deletes the group as well.\nfunc (sys *IAMSys) RemoveUsersFromGroup(ctx context.Context, group string, members []string) (updatedAt time.Time, err error) {\n\tif !sys.Initialized() {\n\t\treturn updatedAt, errServerNotInitialized\n\t}\n\n\tif sys.usersSysType != MinIOUsersSysType {\n\t\treturn updatedAt, errIAMActionNotAllowed\n\t}\n\n\tupdatedAt, err = sys.store.RemoveUsersFromGroup(ctx, group, members)\n\tif err != nil {\n\t\treturn updatedAt, err\n\t}\n\n\tsys.notifyForGroup(ctx, group)\n\treturn updatedAt, nil\n}\n\n// SetGroupStatus - enable/disabled a group\nfunc (sys *IAMSys) SetGroupStatus(ctx context.Context, group string, enabled bool) (updatedAt time.Time, err error) {\n\tif !sys.Initialized() {\n\t\treturn updatedAt, errServerNotInitialized\n\t}\n\n\tif sys.usersSysType != MinIOUsersSysType {\n\t\treturn updatedAt, errIAMActionNotAllowed\n\t}\n\n\tupdatedAt, err = sys.store.SetGroupStatus(ctx, group, enabled)\n\tif err != nil {\n\t\treturn updatedAt, err\n\t}\n\n\tsys.notifyForGroup(ctx, group)\n\treturn updatedAt, nil\n}\n\n// GetGroupDescription - builds up group description\nfunc (sys *IAMSys) GetGroupDescription(group string) (gd madmin.GroupDesc, err error) {\n\tif !sys.Initialized() {\n\t\treturn gd, errServerNotInitialized\n\t}\n\n\treturn sys.store.GetGroupDescription(group)\n}\n\n// ListGroups - lists groups.\nfunc (sys *IAMSys) ListGroups(ctx context.Context) (r []string, err error) {\n\tif !sys.Initialized() {\n\t\treturn r, errServerNotInitialized\n\t}\n\n\tselect {\n\tcase <-sys.configLoaded:\n\t\treturn sys.store.ListGroups(ctx)\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\t}\n}\n\n// PolicyDBSet - sets a policy for a user or group in the PolicyDB - the user doesn't have to exist since sometimes they are virtuals\nfunc (sys *IAMSys) PolicyDBSet(ctx context.Context, name, policy string, userType IAMUserType, isGroup bool) (updatedAt time.Time, err error) {\n\tif !sys.Initialized() {\n\t\treturn updatedAt, errServerNotInitialized\n\t}\n\n\tupdatedAt, err = sys.store.PolicyDBSet(ctx, name, policy, userType, isGroup)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// Notify all other MinIO peers to reload policy\n\tif !sys.HasWatcher() {\n\t\tfor _, nerr := range globalNotificationSys.LoadPolicyMapping(name, userType, isGroup) {\n\t\t\tif nerr.Err != nil {\n\t\t\t\tlogger.GetReqInfo(ctx).SetTags(\"peerAddress\", nerr.Host.String())\n\t\t\t\tlogger.LogIf(ctx, nerr.Err)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn updatedAt, nil\n}\n\n// PolicyDBUpdateBuiltin - adds or removes policies from a user or a group\n// verified to be an internal IDP user.\nfunc (sys *IAMSys) PolicyDBUpdateBuiltin(ctx context.Context, isAttach bool,\n\tr madmin.PolicyAssociationReq,\n) (updatedAt time.Time, addedOrRemoved, effectivePolicies []string, err error) {\n\tif !sys.Initialized() {\n\t\terr = errServerNotInitialized\n\t\treturn\n\t}\n\n\tuserOrGroup := r.User\n\tvar isGroup bool\n\tif userOrGroup == \"\" {\n\t\tisGroup = true\n\t\tuserOrGroup = r.Group\n\t}\n\n\tif isGroup {\n\t\t_, err = sys.GetGroupDescription(userOrGroup)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t} else {\n\t\tvar isTemp bool\n\t\tisTemp, _, err = sys.IsTempUser(userOrGroup)\n\t\tif err != nil && err != errNoSuchUser {\n\t\t\treturn\n\t\t}\n\t\tif isTemp {\n\t\t\terr = errIAMActionNotAllowed\n\t\t\treturn\n\t\t}\n\n\t\t// When the user is root credential you are not allowed to\n\t\t// add policies for root user.\n\t\tif userOrGroup == globalActiveCred.AccessKey {\n\t\t\terr = errIAMActionNotAllowed\n\t\t\treturn\n\t\t}\n\n\t\t// Validate that user exists.\n\t\tvar userExists bool\n\t\t_, userExists = sys.GetUser(ctx, userOrGroup)\n\t\tif !userExists {\n\t\t\terr = errNoSuchUser\n\t\t\treturn\n\t\t}\n\t}\n\n\tupdatedAt, addedOrRemoved, effectivePolicies, err = sys.store.PolicyDBUpdate(ctx, userOrGroup, isGroup,\n\t\tregUser, r.Policies, isAttach)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// Notify all other MinIO peers to reload policy\n\tif !sys.HasWatcher() {\n\t\tfor _, nerr := range globalNotificationSys.LoadPolicyMapping(userOrGroup, regUser, isGroup) {\n\t\t\tif nerr.Err != nil {\n\t\t\t\tlogger.GetReqInfo(ctx).SetTags(\"peerAddress\", nerr.Host.String())\n\t\t\t\tlogger.LogIf(ctx, nerr.Err)\n\t\t\t}\n\t\t}\n\t}\n\n\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemPolicyMapping,\n\t\tPolicyMapping: &madmin.SRPolicyMapping{\n\t\t\tUserOrGroup: userOrGroup,\n\t\t\tUserType:    int(regUser),\n\t\t\tIsGroup:     isGroup,\n\t\t\tPolicy:      strings.Join(effectivePolicies, \",\"),\n\t\t},\n\t\tUpdatedAt: updatedAt,\n\t}))\n\n\treturn\n}\n\n// PolicyDBUpdateLDAP - adds or removes policies from a user or a group verified\n// to be in the LDAP directory.\nfunc (sys *IAMSys) PolicyDBUpdateLDAP(ctx context.Context, isAttach bool,\n\tr madmin.PolicyAssociationReq,\n) (updatedAt time.Time, addedOrRemoved, effectivePolicies []string, err error) {\n\tif !sys.Initialized() {\n\t\terr = errServerNotInitialized\n\t\treturn\n\t}\n\n\tvar dn string\n\tvar isGroup bool\n\tif r.User != \"\" {\n\t\tdn, err = sys.LDAPConfig.DoesUsernameExist(r.User)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, err)\n\t\t\treturn\n\t\t}\n\t\tif dn == \"\" {\n\t\t\t// Still attempt to detach if provided user is a DN.\n\t\t\tif !isAttach && sys.LDAPConfig.IsLDAPUserDN(r.User) {\n\t\t\t\tdn = r.User\n\t\t\t} else {\n\t\t\t\terr = errNoSuchUser\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tisGroup = false\n\t} else {\n\t\tif isAttach {\n\t\t\tvar exists bool\n\t\t\tif exists, err = sys.LDAPConfig.DoesGroupDNExist(r.Group); err != nil {\n\t\t\t\tlogger.LogIf(ctx, err)\n\t\t\t\treturn\n\t\t\t} else if !exists {\n\t\t\t\terr = errNoSuchGroup\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tdn = r.Group\n\t\tisGroup = true\n\t}\n\n\tuserType := stsUser\n\tupdatedAt, addedOrRemoved, effectivePolicies, err = sys.store.PolicyDBUpdate(ctx, dn, isGroup,\n\t\tuserType, r.Policies, isAttach)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// Notify all other MinIO peers to reload policy\n\tif !sys.HasWatcher() {\n\t\tfor _, nerr := range globalNotificationSys.LoadPolicyMapping(dn, userType, isGroup) {\n\t\t\tif nerr.Err != nil {\n\t\t\t\tlogger.GetReqInfo(ctx).SetTags(\"peerAddress\", nerr.Host.String())\n\t\t\t\tlogger.LogIf(ctx, nerr.Err)\n\t\t\t}\n\t\t}\n\t}\n\n\tlogger.LogIf(ctx, globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemPolicyMapping,\n\t\tPolicyMapping: &madmin.SRPolicyMapping{\n\t\t\tUserOrGroup: dn,\n\t\t\tUserType:    int(userType),\n\t\t\tIsGroup:     isGroup,\n\t\t\tPolicy:      strings.Join(effectivePolicies, \",\"),\n\t\t},\n\t\tUpdatedAt: updatedAt,\n\t}))\n\n\treturn\n}\n\n// PolicyDBGet - gets policy set on a user or group. If a list of groups is\n// given, policies associated with them are included as well.\nfunc (sys *IAMSys) PolicyDBGet(name string, groups ...string) ([]string, error) {\n\tif !sys.Initialized() {\n\t\treturn nil, errServerNotInitialized\n\t}\n\n\treturn sys.store.PolicyDBGet(name, groups...)\n}\n\nconst sessionPolicyNameExtracted = policy.SessionPolicyName + \"-extracted\"\n\n// IsAllowedServiceAccount - checks if the given service account is allowed to perform\n// actions. The permission of the parent user is checked first\nfunc (sys *IAMSys) IsAllowedServiceAccount(args policy.Args, parentUser string) bool {\n\t// Verify if the parent claim matches the parentUser.\n\tp, ok := args.Claims[parentClaim]\n\tif ok {\n\t\tparentInClaim, ok := p.(string)\n\t\tif !ok {\n\t\t\t// Reject malformed/malicious requests.\n\t\t\treturn false\n\t\t}\n\t\t// The parent claim in the session token should be equal\n\t\t// to the parent detected in the backend\n\t\tif parentInClaim != parentUser {\n\t\t\treturn false\n\t\t}\n\t} else {\n\t\t// This is needed so a malicious user cannot\n\t\t// use a leaked session key of another user\n\t\t// to widen its privileges.\n\t\treturn false\n\t}\n\n\tisOwnerDerived := parentUser == globalActiveCred.AccessKey\n\n\tvar err error\n\tvar svcPolicies []string\n\troleArn := args.GetRoleArn()\n\n\tswitch {\n\tcase isOwnerDerived:\n\t\t// All actions are allowed by default and no policy evaluation is\n\t\t// required.\n\n\tcase roleArn != \"\":\n\t\tarn, err := arn.Parse(roleArn)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(GlobalContext, fmt.Errorf(\"error parsing role ARN %s: %v\", roleArn, err))\n\t\t\treturn false\n\t\t}\n\t\tsvcPolicies = newMappedPolicy(sys.rolesMap[arn]).toSlice()\n\n\tdefault:\n\t\t// Check policy for parent user of service account.\n\t\tsvcPolicies, err = sys.PolicyDBGet(parentUser, args.Groups...)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(GlobalContext, err)\n\t\t\treturn false\n\t\t}\n\n\t\t// Finally, if there is no parent policy, check if a policy claim is\n\t\t// present.\n\t\tif len(svcPolicies) == 0 {\n\t\t\tpolicySet, _ := policy.GetPoliciesFromClaims(args.Claims, iamPolicyClaimNameOpenID())\n\t\t\tsvcPolicies = policySet.ToSlice()\n\t\t}\n\t}\n\n\t// Defensive code: Do not allow any operation if no policy is found.\n\tif !isOwnerDerived && len(svcPolicies) == 0 {\n\t\treturn false\n\t}\n\n\tvar combinedPolicy policy.Policy\n\t// Policies were found, evaluate all of them.\n\tif !isOwnerDerived {\n\t\tavailablePoliciesStr, c := sys.store.FilterPolicies(strings.Join(svcPolicies, \",\"), \"\")\n\t\tif availablePoliciesStr == \"\" {\n\t\t\treturn false\n\t\t}\n\t\tcombinedPolicy = c\n\t}\n\n\tparentArgs := args\n\tparentArgs.AccountName = parentUser\n\n\tsaPolicyClaim, ok := args.Claims[iamPolicyClaimNameSA()]\n\tif !ok {\n\t\treturn false\n\t}\n\n\tsaPolicyClaimStr, ok := saPolicyClaim.(string)\n\tif !ok {\n\t\t// Sub policy if set, should be a string reject\n\t\t// malformed/malicious requests.\n\t\treturn false\n\t}\n\n\tif saPolicyClaimStr == inheritedPolicyType {\n\t\treturn isOwnerDerived || combinedPolicy.IsAllowed(parentArgs)\n\t}\n\n\t// 3. If an inline session-policy is present, evaluate it.\n\thasSessionPolicy, isAllowedSP := isAllowedBySessionPolicy(args)\n\tif hasSessionPolicy {\n\t\treturn isAllowedSP && (isOwnerDerived || combinedPolicy.IsAllowed(parentArgs))\n\t}\n\n\t// Sub policy not set. Evaluate only the parent policies.\n\treturn (isOwnerDerived || combinedPolicy.IsAllowed(parentArgs))\n}\n\n// IsAllowedSTS is meant for STS based temporary credentials,\n// which implements claims validation and verification other than\n// applying policies.\nfunc (sys *IAMSys) IsAllowedSTS(args policy.Args, parentUser string) bool {\n\t// 1. Determine mapped policies\n\n\tisOwnerDerived := parentUser == globalActiveCred.AccessKey\n\tvar policies []string\n\troleArn := args.GetRoleArn()\n\n\tswitch {\n\tcase isOwnerDerived:\n\t\t// All actions are allowed by default and no policy evaluation is\n\t\t// required.\n\n\tcase roleArn != \"\":\n\t\t// If a roleARN is present, the role policy is applied.\n\t\tarn, err := arn.Parse(roleArn)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(GlobalContext, fmt.Errorf(\"error parsing role ARN %s: %v\", roleArn, err))\n\t\t\treturn false\n\t\t}\n\t\tpolicies = newMappedPolicy(sys.rolesMap[arn]).toSlice()\n\n\tdefault:\n\t\t// Otherwise, inherit parent user's policy\n\t\tvar err error\n\t\tpolicies, err = sys.store.PolicyDBGet(parentUser, args.Groups...)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(GlobalContext, fmt.Errorf(\"error fetching policies on %s: %v\", parentUser, err))\n\t\t\treturn false\n\t\t}\n\n\t\t// Finally, if there is no parent policy, check if a policy claim is\n\t\t// present in the session token.\n\t\tif len(policies) == 0 {\n\t\t\t// If there is no parent policy mapping, we fall back to\n\t\t\t// using policy claim from JWT.\n\t\t\tpolicySet, ok := args.GetPolicies(iamPolicyClaimNameOpenID())\n\t\t\tif !ok {\n\t\t\t\t// When claims are set, it should have a policy claim field.\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tpolicies = policySet.ToSlice()\n\t\t}\n\n\t}\n\n\t// Defensive code: Do not allow any operation if no policy is found in the session token\n\tif !isOwnerDerived && len(policies) == 0 {\n\t\treturn false\n\t}\n\n\t// 2. Combine the mapped policies into a single combined policy.\n\n\tvar combinedPolicy policy.Policy\n\tif !isOwnerDerived {\n\t\tvar err error\n\t\tcombinedPolicy, err = sys.store.GetPolicy(strings.Join(policies, \",\"))\n\t\tif errors.Is(err, errNoSuchPolicy) {\n\t\t\tfor _, pname := range policies {\n\t\t\t\t_, err := sys.store.GetPolicy(pname)\n\t\t\t\tif errors.Is(err, errNoSuchPolicy) {\n\t\t\t\t\t// all policies presented in the claim should exist\n\t\t\t\t\tlogger.LogIf(GlobalContext, fmt.Errorf(\"expected policy (%s) missing from the JWT claim %s, rejecting the request\", pname, iamPolicyClaimNameOpenID()))\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t\tlogger.LogIf(GlobalContext, fmt.Errorf(\"all policies were unexpectedly present!\"))\n\t\t\treturn false\n\t\t}\n\n\t}\n\n\t// 3. If an inline session-policy is present, evaluate it.\n\n\t// Now check if we have a sessionPolicy.\n\thasSessionPolicy, isAllowedSP := isAllowedBySessionPolicy(args)\n\tif hasSessionPolicy {\n\t\treturn isAllowedSP && (isOwnerDerived || combinedPolicy.IsAllowed(args))\n\t}\n\n\t// Sub policy not set, this is most common since subPolicy\n\t// is optional, use the inherited policies.\n\treturn isOwnerDerived || combinedPolicy.IsAllowed(args)\n}\n\nfunc isAllowedBySessionPolicy(args policy.Args) (hasSessionPolicy bool, isAllowed bool) {\n\thasSessionPolicy = false\n\tisAllowed = false\n\n\t// Now check if we have a sessionPolicy.\n\tspolicy, ok := args.Claims[sessionPolicyNameExtracted]\n\tif !ok {\n\t\treturn\n\t}\n\n\thasSessionPolicy = true\n\n\tspolicyStr, ok := spolicy.(string)\n\tif !ok {\n\t\t// Sub policy if set, should be a string reject\n\t\t// malformed/malicious requests.\n\t\treturn\n\t}\n\n\t// Check if policy is parseable.\n\tsubPolicy, err := policy.ParseConfig(bytes.NewReader([]byte(spolicyStr)))\n\tif err != nil {\n\t\t// Log any error in input session policy config.\n\t\tlogger.LogIf(GlobalContext, err)\n\t\treturn\n\t}\n\n\t// Policy without Version string value reject it.\n\tif subPolicy.Version == \"\" {\n\t\treturn\n\t}\n\n\t// As the session policy exists, even if the parent is the root account, it\n\t// must be restricted by it. So, we set `.IsOwner` to false here\n\t// unconditionally.\n\tsessionPolicyArgs := args\n\tsessionPolicyArgs.IsOwner = false\n\n\t// Sub policy is set and valid.\n\treturn hasSessionPolicy, subPolicy.IsAllowed(sessionPolicyArgs)\n}\n\n// GetCombinedPolicy returns a combined policy combining all policies\nfunc (sys *IAMSys) GetCombinedPolicy(policies ...string) policy.Policy {\n\t_, policy := sys.store.FilterPolicies(strings.Join(policies, \",\"), \"\")\n\treturn policy\n}\n\n// IsAllowed - checks given policy args is allowed to continue the Rest API.\nfunc (sys *IAMSys) IsAllowed(args policy.Args) bool {\n\t// If opa is configured, use OPA always.\n\tif authz := newGlobalAuthZPluginFn(); authz != nil {\n\t\tok, err := authz.IsAllowed(args)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(GlobalContext, err)\n\t\t}\n\t\treturn ok\n\t}\n\n\t// Policies don't apply to the owner.\n\tif args.IsOwner {\n\t\treturn true\n\t}\n\n\t// If the credential is temporary, perform STS related checks.\n\tok, parentUser, err := sys.IsTempUser(args.AccountName)\n\tif err != nil {\n\t\treturn false\n\t}\n\tif ok {\n\t\treturn sys.IsAllowedSTS(args, parentUser)\n\t}\n\n\t// If the credential is for a service account, perform related check\n\tok, parentUser, err = sys.IsServiceAccount(args.AccountName)\n\tif err != nil {\n\t\treturn false\n\t}\n\tif ok {\n\t\treturn sys.IsAllowedServiceAccount(args, parentUser)\n\t}\n\n\t// Continue with the assumption of a regular user\n\tpolicies, err := sys.PolicyDBGet(args.AccountName, args.Groups...)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tif len(policies) == 0 {\n\t\t// No policy found.\n\t\treturn false\n\t}\n\n\t// Policies were found, evaluate all of them.\n\treturn sys.GetCombinedPolicy(policies...).IsAllowed(args)\n}\n\n// SetUsersSysType - sets the users system type, regular or LDAP.\nfunc (sys *IAMSys) SetUsersSysType(t UsersSysType) {\n\tsys.usersSysType = t\n}\n\n// GetUsersSysType - returns the users system type for this IAM\nfunc (sys *IAMSys) GetUsersSysType() UsersSysType {\n\treturn sys.usersSysType\n}\n\n// NewIAMSys - creates new config system object.\nfunc NewIAMSys() *IAMSys {\n\treturn &IAMSys{\n\t\tusersSysType: MinIOUsersSysType,\n\t\tconfigLoaded: make(chan struct{}),\n\t}\n}\n", "// Copyright (c) 2015-2023 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"crypto/hmac\"\n\t\"encoding/hex\"\n\t\"io\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/minio/minio/internal/auth\"\n\t\"github.com/minio/minio/internal/hash/sha256\"\n\txhttp \"github.com/minio/minio/internal/http\"\n\t\"github.com/minio/minio/internal/logger\"\n\t\"github.com/minio/pkg/v2/policy\"\n\t\"golang.org/x/exp/slices\"\n)\n\n// http Header \"x-amz-content-sha256\" == \"UNSIGNED-PAYLOAD\" indicates that the\n// client did not calculate sha256 of the payload.\nconst unsignedPayload = \"UNSIGNED-PAYLOAD\"\n\n// http Header \"x-amz-content-sha256\" == \"STREAMING-UNSIGNED-PAYLOAD-TRAILER\" indicates that the\n// client did not calculate sha256 of the payload and there is a trailer.\nconst unsignedPayloadTrailer = \"STREAMING-UNSIGNED-PAYLOAD-TRAILER\"\n\n// skipContentSha256Cksum returns true if caller needs to skip\n// payload checksum, false if not.\nfunc skipContentSha256Cksum(r *http.Request) bool {\n\tvar (\n\t\tv  []string\n\t\tok bool\n\t)\n\n\tif isRequestPresignedSignatureV4(r) {\n\t\tv, ok = r.Form[xhttp.AmzContentSha256]\n\t\tif !ok {\n\t\t\tv, ok = r.Header[xhttp.AmzContentSha256]\n\t\t}\n\t} else {\n\t\tv, ok = r.Header[xhttp.AmzContentSha256]\n\t}\n\n\t// Skip if no header was set.\n\tif !ok {\n\t\treturn true\n\t}\n\n\t// If x-amz-content-sha256 is set and the value is not\n\t// 'UNSIGNED-PAYLOAD' we should validate the content sha256.\n\tswitch v[0] {\n\tcase unsignedPayload, unsignedPayloadTrailer:\n\t\treturn true\n\tcase emptySHA256:\n\t\t// some broken clients set empty-sha256\n\t\t// with > 0 content-length in the body,\n\t\t// we should skip such clients and allow\n\t\t// blindly such insecure clients only if\n\t\t// S3 strict compatibility is disabled.\n\n\t\t// We return true only in situations when\n\t\t// deployment has asked MinIO to allow for\n\t\t// such broken clients and content-length > 0.\n\t\treturn r.ContentLength > 0 && !globalServerCtxt.StrictS3Compat\n\t}\n\treturn false\n}\n\n// Returns SHA256 for calculating canonical-request.\nfunc getContentSha256Cksum(r *http.Request, stype serviceType) string {\n\tif stype == serviceSTS {\n\t\tpayload, err := io.ReadAll(io.LimitReader(r.Body, stsRequestBodyLimit))\n\t\tif err != nil {\n\t\t\tlogger.CriticalIf(GlobalContext, err)\n\t\t}\n\t\tsum256 := sha256.Sum256(payload)\n\t\tr.Body = io.NopCloser(bytes.NewReader(payload))\n\t\treturn hex.EncodeToString(sum256[:])\n\t}\n\n\tvar (\n\t\tdefaultSha256Cksum string\n\t\tv                  []string\n\t\tok                 bool\n\t)\n\n\t// For a presigned request we look at the query param for sha256.\n\tif isRequestPresignedSignatureV4(r) {\n\t\t// X-Amz-Content-Sha256, if not set in presigned requests, checksum\n\t\t// will default to 'UNSIGNED-PAYLOAD'.\n\t\tdefaultSha256Cksum = unsignedPayload\n\t\tv, ok = r.Form[xhttp.AmzContentSha256]\n\t\tif !ok {\n\t\t\tv, ok = r.Header[xhttp.AmzContentSha256]\n\t\t}\n\t} else {\n\t\t// X-Amz-Content-Sha256, if not set in signed requests, checksum\n\t\t// will default to sha256([]byte(\"\")).\n\t\tdefaultSha256Cksum = emptySHA256\n\t\tv, ok = r.Header[xhttp.AmzContentSha256]\n\t}\n\n\t// We found 'X-Amz-Content-Sha256' return the captured value.\n\tif ok {\n\t\treturn v[0]\n\t}\n\n\t// We couldn't find 'X-Amz-Content-Sha256'.\n\treturn defaultSha256Cksum\n}\n\n// isValidRegion - verify if incoming region value is valid with configured Region.\nfunc isValidRegion(reqRegion string, confRegion string) bool {\n\tif confRegion == \"\" {\n\t\treturn true\n\t}\n\tif confRegion == \"US\" {\n\t\tconfRegion = globalMinioDefaultRegion\n\t}\n\t// Some older s3 clients set region as \"US\" instead of\n\t// globalMinioDefaultRegion, handle it.\n\tif reqRegion == \"US\" {\n\t\treqRegion = globalMinioDefaultRegion\n\t}\n\treturn reqRegion == confRegion\n}\n\n// check if the access key is valid and recognized, additionally\n// also returns if the access key is owner/admin.\nfunc checkKeyValid(r *http.Request, accessKey string) (auth.Credentials, bool, APIErrorCode) {\n\tcred := globalActiveCred\n\tif cred.AccessKey != accessKey {\n\t\tif !globalIAMSys.Initialized() {\n\t\t\t// Check if server has initialized, then only proceed\n\t\t\t// to check for IAM users otherwise its okay for clients\n\t\t\t// to retry with 503 errors when server is coming up.\n\t\t\treturn auth.Credentials{}, false, ErrServerNotInitialized\n\t\t}\n\n\t\t// Check if the access key is part of users credentials.\n\t\tu, ok := globalIAMSys.GetUser(r.Context(), accessKey)\n\t\tif !ok {\n\t\t\t// Credentials could be valid but disabled - return a different\n\t\t\t// error in such a scenario.\n\t\t\tif u.Credentials.Status == auth.AccountOff {\n\t\t\t\treturn cred, false, ErrAccessKeyDisabled\n\t\t\t}\n\t\t\treturn cred, false, ErrInvalidAccessKeyID\n\t\t}\n\t\tcred = u.Credentials\n\t}\n\n\tclaims, s3Err := checkClaimsFromToken(r, cred)\n\tif s3Err != ErrNone {\n\t\treturn cred, false, s3Err\n\t}\n\tcred.Claims = claims\n\n\towner := cred.AccessKey == globalActiveCred.AccessKey || (cred.ParentUser == globalActiveCred.AccessKey && cred.AccessKey != siteReplicatorSvcAcc)\n\tif owner && !globalAPIConfig.permitRootAccess() {\n\t\t// We disable root access and its service accounts if asked for.\n\t\treturn cred, owner, ErrAccessKeyDisabled\n\t}\n\n\tif _, ok := claims[policy.SessionPolicyName]; ok {\n\t\towner = false\n\t}\n\n\treturn cred, owner, ErrNone\n}\n\n// sumHMAC calculate hmac between two input byte array.\nfunc sumHMAC(key []byte, data []byte) []byte {\n\thash := hmac.New(sha256.New, key)\n\thash.Write(data)\n\treturn hash.Sum(nil)\n}\n\n// extractSignedHeaders extract signed headers from Authorization header\nfunc extractSignedHeaders(signedHeaders []string, r *http.Request) (http.Header, APIErrorCode) {\n\treqHeaders := r.Header\n\treqQueries := r.Form\n\t// find whether \"host\" is part of list of signed headers.\n\t// if not return ErrUnsignedHeaders. \"host\" is mandatory.\n\tif !slices.Contains(signedHeaders, \"host\") {\n\t\treturn nil, ErrUnsignedHeaders\n\t}\n\textractedSignedHeaders := make(http.Header)\n\tfor _, header := range signedHeaders {\n\t\t// `host` will not be found in the headers, can be found in r.Host.\n\t\t// but its always necessary that the list of signed headers containing host in it.\n\t\tval, ok := reqHeaders[http.CanonicalHeaderKey(header)]\n\t\tif !ok {\n\t\t\t// try to set headers from Query String\n\t\t\tval, ok = reqQueries[header]\n\t\t}\n\t\tif ok {\n\t\t\textractedSignedHeaders[http.CanonicalHeaderKey(header)] = val\n\t\t\tcontinue\n\t\t}\n\t\tswitch header {\n\t\tcase \"expect\":\n\t\t\t// Golang http server strips off 'Expect' header, if the\n\t\t\t// client sent this as part of signed headers we need to\n\t\t\t// handle otherwise we would see a signature mismatch.\n\t\t\t// `aws-cli` sets this as part of signed headers.\n\t\t\t//\n\t\t\t// According to\n\t\t\t// http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.20\n\t\t\t// Expect header is always of form:\n\t\t\t//\n\t\t\t//   Expect       =  \"Expect\" \":\" 1#expectation\n\t\t\t//   expectation  =  \"100-continue\" | expectation-extension\n\t\t\t//\n\t\t\t// So it safe to assume that '100-continue' is what would\n\t\t\t// be sent, for the time being keep this work around.\n\t\t\t// Adding a *TODO* to remove this later when Golang server\n\t\t\t// doesn't filter out the 'Expect' header.\n\t\t\textractedSignedHeaders.Set(header, \"100-continue\")\n\t\tcase \"host\":\n\t\t\t// Go http server removes \"host\" from Request.Header\n\t\t\textractedSignedHeaders.Set(header, r.Host)\n\t\tcase \"transfer-encoding\":\n\t\t\t// Go http server removes \"host\" from Request.Header\n\t\t\textractedSignedHeaders[http.CanonicalHeaderKey(header)] = r.TransferEncoding\n\t\tcase \"content-length\":\n\t\t\t// Signature-V4 spec excludes Content-Length from signed headers list for signature calculation.\n\t\t\t// But some clients deviate from this rule. Hence we consider Content-Length for signature\n\t\t\t// calculation to be compatible with such clients.\n\t\t\textractedSignedHeaders.Set(header, strconv.FormatInt(r.ContentLength, 10))\n\t\tdefault:\n\t\t\treturn nil, ErrUnsignedHeaders\n\t\t}\n\t}\n\treturn extractedSignedHeaders, ErrNone\n}\n\n// Trim leading and trailing spaces and replace sequential spaces with one space, following Trimall()\n// in http://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html\nfunc signV4TrimAll(input string) string {\n\t// Compress adjacent spaces (a space is determined by\n\t// unicode.IsSpace() internally here) to one space and return\n\treturn strings.Join(strings.Fields(input), \" \")\n}\n\n// checkMetaHeaders will check if the metadata from header/url is the same with the one from signed headers\nfunc checkMetaHeaders(signedHeadersMap http.Header, r *http.Request) APIErrorCode {\n\t// check values from http header\n\tfor k, val := range r.Header {\n\t\tif stringsHasPrefixFold(k, \"X-Amz-Meta-\") {\n\t\t\tif signedHeadersMap.Get(k) == val[0] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn ErrUnsignedHeaders\n\t\t}\n\t}\n\n\treturn ErrNone\n}\n", "// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/minio/madmin-go/v3\"\n\tminio \"github.com/minio/minio-go/v7\"\n\tcr \"github.com/minio/minio-go/v7/pkg/credentials\"\n\t\"github.com/minio/minio-go/v7/pkg/set\"\n)\n\nfunc runAllIAMSTSTests(suite *TestSuiteIAM, c *check) {\n\tsuite.SetUpSuite(c)\n\t// The STS for root test needs to be the first one after setup.\n\tsuite.TestSTSForRoot(c)\n\tsuite.TestSTS(c)\n\tsuite.TestSTSWithDenyDeleteVersion(c)\n\tsuite.TestSTSWithTags(c)\n\tsuite.TestSTSServiceAccountsWithUsername(c)\n\tsuite.TestSTSWithGroupPolicy(c)\n\tsuite.TearDownSuite(c)\n}\n\nfunc TestIAMInternalIDPSTSServerSuite(t *testing.T) {\n\tbaseTestCases := []TestSuiteCommon{\n\t\t// Init and run test on ErasureSD backend with signature v4.\n\t\t{serverType: \"ErasureSD\", signer: signerV4},\n\t\t// Init and run test on ErasureSD backend, with tls enabled.\n\t\t{serverType: \"ErasureSD\", signer: signerV4, secure: true},\n\t\t// Init and run test on Erasure backend.\n\t\t{serverType: \"Erasure\", signer: signerV4},\n\t\t// Init and run test on ErasureSet backend.\n\t\t{serverType: \"ErasureSet\", signer: signerV4},\n\t}\n\ttestCases := []*TestSuiteIAM{}\n\tfor _, bt := range baseTestCases {\n\t\ttestCases = append(testCases,\n\t\t\tnewTestSuiteIAM(bt, false),\n\t\t\tnewTestSuiteIAM(bt, true),\n\t\t)\n\t}\n\tfor i, testCase := range testCases {\n\t\tetcdStr := \"\"\n\t\tif testCase.withEtcdBackend {\n\t\t\tetcdStr = \" (with etcd backend)\"\n\t\t}\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s%s\", i+1, testCase.serverType, etcdStr),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\trunAllIAMSTSTests(testCase, &check{t, testCase.serverType})\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestSTSServiceAccountsWithUsername(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := \"dillon-bucket\"\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Create policy\n\tpolicy := \"mypolicy-username\"\n\tpolicyBytes := []byte(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:*\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::${aws:username}-*\"\n   ]\n  }\n ]\n}`)\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tif err = s.adm.AddUser(ctx, \"dillon\", \"dillon-123\"); err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, \"dillon\", false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\tassumeRole := cr.STSAssumeRole{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tOptions: cr.STSAssumeRoleOptions{\n\t\t\tAccessKey: \"dillon\",\n\t\t\tSecretKey: \"dillon-123\",\n\t\t\tLocation:  \"\",\n\t\t},\n\t}\n\n\tvalue, err := assumeRole.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Check that the LDAP sts cred is actually working.\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, value.AccessKeyID, userAdmClient)\n\n\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n\n\t// 1. Check S3 access for service account ListObjects()\n\tc.mustListObjects(ctx, svcClient, bucket)\n\n\t// 2. Check S3 access for upload\n\tc.mustUpload(ctx, svcClient, bucket)\n\n\t// 3. Check S3 access for download\n\tc.mustDownload(ctx, svcClient, bucket)\n}\n\nfunc (s *TestSuiteIAM) TestSTSWithDenyDeleteVersion(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{ObjectLocking: true})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// Create policy, user and associate policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n   {\n    \"Sid\": \"ObjectActionsRW\",\n    \"Effect\": \"Allow\",\n    \"Action\": [\n     \"s3:PutObject\",\n     \"s3:PutObjectTagging\",\n     \"s3:AbortMultipartUpload\",\n     \"s3:DeleteObject\",\n     \"s3:GetObject\",\n     \"s3:GetObjectTagging\",\n     \"s3:GetObjectVersion\",\n     \"s3:ListMultipartUploadParts\"\n    ],\n    \"Resource\": [\n     \"arn:aws:s3:::%s/*\"\n    ]\n   },\n   {\n    \"Sid\": \"DenyDeleteVersionAction\",\n    \"Effect\": \"Deny\",\n    \"Action\": [\n     \"s3:DeleteObjectVersion\"\n    ],\n    \"Resource\": [\n     \"arn:aws:s3:::%s/*\"\n    ]\n   }\n  ]\n }\n`, bucket, bucket))\n\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\t// confirm that the user is able to access the bucket\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tversions := c.mustUploadReturnVersions(ctx, uClient, bucket)\n\tc.mustNotDelete(ctx, uClient, bucket, versions[0])\n\n\tassumeRole := cr.STSAssumeRole{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tOptions: cr.STSAssumeRoleOptions{\n\t\t\tAccessKey: accessKey,\n\t\t\tSecretKey: secretKey,\n\t\t\tLocation:  \"\",\n\t\t},\n\t}\n\n\tvalue, err := assumeRole.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"err calling assumeRole: %v\", err)\n\t}\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\tversions = c.mustUploadReturnVersions(ctx, minioClient, bucket)\n\tc.mustNotDelete(ctx, minioClient, bucket, versions[0])\n}\n\nfunc (s *TestSuiteIAM) TestSTSWithTags(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\tobject := getRandomObjectName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// Create policy, user and associate policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\":     \"Allow\",\n      \"Action\":     \"s3:GetObject\",\n      \"Resource\":    \"arn:aws:s3:::%s/*\",\n      \"Condition\": {  \"StringEquals\": {\"s3:ExistingObjectTag/security\": \"public\" } }\n    },\n    {\n      \"Effect\":     \"Allow\",\n      \"Action\":     \"s3:DeleteObjectTagging\",\n      \"Resource\":    \"arn:aws:s3:::%s/*\",\n      \"Condition\": {  \"StringEquals\": {\"s3:ExistingObjectTag/security\": \"public\" } }\n    },\n    {\n      \"Effect\":     \"Allow\",\n      \"Action\":     \"s3:DeleteObject\",\n      \"Resource\":    \"arn:aws:s3:::%s/*\"\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"s3:PutObject\"\n      ],\n      \"Resource\": [\n        \"arn:aws:s3:::%s/*\"\n      ],\n      \"Condition\": {\n        \"ForAllValues:StringLike\": {\n          \"s3:RequestObjectTagKeys\": [\n            \"security\",\n            \"virus\"\n          ]\n        }\n      }\n    }\n  ]\n}`, bucket, bucket, bucket, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\t// confirm that the user is able to access the bucket\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustPutObjectWithTags(ctx, uClient, bucket, object)\n\tc.mustGetObject(ctx, uClient, bucket, object)\n\n\tassumeRole := cr.STSAssumeRole{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tOptions: cr.STSAssumeRoleOptions{\n\t\t\tAccessKey: accessKey,\n\t\t\tSecretKey: secretKey,\n\t\t\tLocation:  \"\",\n\t\t},\n\t}\n\n\tvalue, err := assumeRole.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"err calling assumeRole: %v\", err)\n\t}\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate sts creds can access the object\n\tc.mustPutObjectWithTags(ctx, minioClient, bucket, object)\n\tc.mustGetObject(ctx, minioClient, bucket, object)\n\tc.mustHeadObject(ctx, minioClient, bucket, object, 2)\n\n\t// Validate that the client can remove objects\n\tif err = minioClient.RemoveObjectTagging(ctx, bucket, object, minio.RemoveObjectTaggingOptions{}); err != nil {\n\t\tc.Fatalf(\"user is unable to delete the object tags: %v\", err)\n\t}\n\n\tif err = minioClient.RemoveObject(ctx, bucket, object, minio.RemoveObjectOptions{}); err != nil {\n\t\tc.Fatalf(\"user is unable to delete the object: %v\", err)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestSTS(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// Create policy, user and associate policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\t// confirm that the user is able to access the bucket\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustListObjects(ctx, uClient, bucket)\n\n\tassumeRole := cr.STSAssumeRole{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tOptions: cr.STSAssumeRoleOptions{\n\t\t\tAccessKey: accessKey,\n\t\t\tSecretKey: secretKey,\n\t\t\tLocation:  \"\",\n\t\t},\n\t}\n\n\tvalue, err := assumeRole.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"err calling assumeRole: %v\", err)\n\t}\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that the client cannot remove any objects\n\terr = minioClient.RemoveObject(ctx, bucket, \"someobject\", minio.RemoveObjectOptions{})\n\tif err.Error() != \"Access Denied.\" {\n\t\tc.Fatalf(\"unexpected non-access-denied err: %v\", err)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestSTSWithGroupPolicy(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// Create policy, user and associate policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\t// confirm that the user is unable to access the bucket - we have not\n\t// yet set any policy\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustNotListObjects(ctx, uClient, bucket)\n\n\terr = s.adm.UpdateGroupMembers(ctx, madmin.GroupAddRemove{\n\t\tGroup:   \"test-group\",\n\t\tMembers: []string{accessKey},\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"unable to add user to group: %v\", err)\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, \"test-group\", true)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\t// confirm that the user is able to access the bucket - permission comes\n\t// from group.\n\tc.mustListObjects(ctx, uClient, bucket)\n\n\t// Create STS user.\n\tassumeRole := cr.STSAssumeRole{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tOptions: cr.STSAssumeRoleOptions{\n\t\t\tAccessKey: accessKey,\n\t\t\tSecretKey: secretKey,\n\t\t\tLocation:  \"\",\n\t\t},\n\t}\n\tvalue, err := assumeRole.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"err calling assumeRole: %v\", err)\n\t}\n\n\t// Check that STS user client has access coming from parent user's\n\t// group.\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that the client cannot remove any objects\n\terr = minioClient.RemoveObject(ctx, bucket, \"someobject\", minio.RemoveObjectOptions{})\n\tif err.Error() != \"Access Denied.\" {\n\t\tc.Fatalf(\"unexpected non-access-denied err: %v\", err)\n\t}\n}\n\n// TestSTSForRoot - needs to be the first test after server setup due to the\n// buckets list check.\nfunc (s *TestSuiteIAM) TestSTSForRoot(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\tassumeRole := cr.STSAssumeRole{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tOptions: cr.STSAssumeRoleOptions{\n\t\t\tAccessKey: globalActiveCred.AccessKey,\n\t\t\tSecretKey: globalActiveCred.SecretKey,\n\t\t\tLocation:  \"\",\n\t\t},\n\t}\n\n\tvalue, err := assumeRole.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"err calling assumeRole: %v\", err)\n\t}\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that a bucket can be created\n\tbucket2 := getRandomBucketName()\n\terr = minioClient.MakeBucket(ctx, bucket2, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// Validate that admin APIs can be called - create an madmin client with\n\t// user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\ttime.Sleep(2 * time.Second) // wait for listbuckets cache to be invalidated\n\n\taccInfo, err := userAdmClient.AccountInfo(ctx, madmin.AccountOpts{})\n\tif err != nil {\n\t\tc.Fatalf(\"root user STS should be able to get account info: %v\", err)\n\t}\n\n\tgotBuckets := set.NewStringSet()\n\tfor _, b := range accInfo.Buckets {\n\t\tgotBuckets.Add(b.Name)\n\t\tif !(b.Access.Read && b.Access.Write) {\n\t\t\tc.Fatalf(\"root user should have read and write access to bucket: %v\", b.Name)\n\t\t}\n\t}\n\tshouldHaveBuckets := set.CreateStringSet(bucket2, bucket)\n\tif !gotBuckets.Equals(shouldHaveBuckets) {\n\t\tc.Fatalf(\"root user should have access to all buckets\")\n\t}\n\n\t// This must fail.\n\tif err := userAdmClient.AddUser(ctx, globalActiveCred.AccessKey, globalActiveCred.SecretKey); err == nil {\n\t\tc.Fatal(\"AddUser() for root credential must fail via root STS creds\")\n\t}\n}\n\n// SetUpLDAP - expects to setup an LDAP test server using the test LDAP\n// container and canned data from https://github.com/minio/minio-ldap-testing\nfunc (s *TestSuiteIAM) SetUpLDAP(c *check, serverAddr string) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tconfigCmds := []string{\n\t\t\"identity_ldap\",\n\t\tfmt.Sprintf(\"server_addr=%s\", serverAddr),\n\t\t\"server_insecure=on\",\n\t\t\"lookup_bind_dn=cn=admin,dc=min,dc=io\",\n\t\t\"lookup_bind_password=admin\",\n\t\t\"user_dn_search_base_dn=dc=min,dc=io\",\n\t\t\"user_dn_search_filter=(uid=%s)\",\n\t\t\"group_search_base_dn=ou=swengg,dc=min,dc=io\",\n\t\t\"group_search_filter=(&(objectclass=groupofnames)(member=%d))\",\n\t}\n\t_, err := s.adm.SetConfigKV(ctx, strings.Join(configCmds, \" \"))\n\tif err != nil {\n\t\tc.Fatalf(\"unable to setup LDAP for tests: %v\", err)\n\t}\n\n\ts.RestartIAMSuite(c)\n}\n\nconst (\n\tEnvTestLDAPServer = \"_MINIO_LDAP_TEST_SERVER\"\n)\n\nfunc TestIAMWithLDAPServerSuite(t *testing.T) {\n\tfor i, testCase := range iamTestSuites {\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s\", i+1, testCase.ServerTypeDescription),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tc := &check{t, testCase.serverType}\n\t\t\t\tsuite := testCase\n\n\t\t\t\tldapServer := os.Getenv(EnvTestLDAPServer)\n\t\t\t\tif ldapServer == \"\" {\n\t\t\t\t\tc.Skip(\"Skipping LDAP test as no LDAP server is provided.\")\n\t\t\t\t}\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tsuite.SetUpLDAP(c, ldapServer)\n\t\t\t\tsuite.TestLDAPSTS(c)\n\t\t\t\tsuite.TestLDAPSTSServiceAccounts(c)\n\t\t\t\tsuite.TestLDAPSTSServiceAccountsWithUsername(c)\n\t\t\t\tsuite.TestLDAPSTSServiceAccountsWithGroups(c)\n\t\t\t\tsuite.TearDownSuite(c)\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestLDAPSTS(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Create policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tldapID := cr.LDAPIdentity{\n\t\tClient:       s.TestSuiteCommon.client,\n\t\tSTSEndpoint:  s.endPoint,\n\t\tLDAPUsername: \"dillon\",\n\t\tLDAPPassword: \"dillon\",\n\t}\n\n\t_, err = ldapID.Retrieve()\n\tif err == nil {\n\t\tc.Fatalf(\"Expected to fail to create STS cred with no associated policy!\")\n\t}\n\n\t// Attempting to set a non-existent policy should fail.\n\tuserDN := \"uid=dillon,ou=people,ou=swengg,dc=min,dc=io\"\n\terr = s.adm.SetPolicy(ctx, policy+\"x\", userDN, false)\n\tif err == nil {\n\t\tc.Fatalf(\"should not be able to set non-existent policy\")\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, userDN, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\tvalue, err := ldapID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that user listing does not return any entries\n\tusersList, err := s.adm.ListUsers(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"list users should not fail: %v\", err)\n\t}\n\tif len(usersList) != 1 {\n\t\tc.Fatalf(\"expected user listing output: %v\", usersList)\n\t}\n\tuinfo := usersList[userDN]\n\tif uinfo.PolicyName != policy || uinfo.Status != madmin.AccountEnabled {\n\t\tc.Fatalf(\"expected user listing content: %v\", uinfo)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that the client cannot remove any objects\n\terr = minioClient.RemoveObject(ctx, bucket, \"someobject\", minio.RemoveObjectOptions{})\n\tif err.Error() != \"Access Denied.\" {\n\t\tc.Fatalf(\"unexpected non-access-denied err: %v\", err)\n\t}\n\n\t// Remove the policy assignment on the user DN:\n\terr = s.adm.SetPolicy(ctx, \"\", userDN, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to remove policy setting: %v\", err)\n\t}\n\n\t_, err = ldapID.Retrieve()\n\tif err == nil {\n\t\tc.Fatalf(\"Expected to fail to create a user with no associated policy!\")\n\t}\n\n\t// Set policy via group and validate policy assignment.\n\tgroupDN := \"cn=projectb,ou=groups,ou=swengg,dc=min,dc=io\"\n\terr = s.adm.SetPolicy(ctx, policy, groupDN, true)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set group policy: %v\", err)\n\t}\n\n\tvalue, err = ldapID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\tminioClient, err = minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that the client cannot remove any objects\n\terr = minioClient.RemoveObject(ctx, bucket, \"someobject\", minio.RemoveObjectOptions{})\n\tc.Assert(err.Error(), \"Access Denied.\")\n}\n\nfunc (s *TestSuiteIAM) TestLDAPSTSServiceAccounts(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Create policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tuserDN := \"uid=dillon,ou=people,ou=swengg,dc=min,dc=io\"\n\terr = s.adm.SetPolicy(ctx, policy, userDN, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\tldapID := cr.LDAPIdentity{\n\t\tClient:       s.TestSuiteCommon.client,\n\t\tSTSEndpoint:  s.endPoint,\n\t\tLDAPUsername: \"dillon\",\n\t\tLDAPPassword: \"dillon\",\n\t}\n\n\tvalue, err := ldapID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Check that the LDAP sts cred is actually working.\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, value.AccessKeyID, userAdmClient)\n\n\t// 1. Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey)\n\n\t// 2. Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey, true)\n\n\t// 3. Check S3 access\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 6. Check that service account cannot be created for some other user.\n\tc.mustNotCreateSvcAccount(ctx, globalActiveCred.AccessKey, userAdmClient)\n}\n\nfunc (s *TestSuiteIAM) TestLDAPSTSServiceAccountsWithUsername(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := \"dillon\"\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Create policy\n\tpolicy := \"mypolicy-username\"\n\tpolicyBytes := []byte(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::${ldap:username}/*\"\n   ]\n  }\n ]\n}`)\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tuserDN := \"uid=dillon,ou=people,ou=swengg,dc=min,dc=io\"\n\terr = s.adm.SetPolicy(ctx, policy, userDN, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\tldapID := cr.LDAPIdentity{\n\t\tClient:       s.TestSuiteCommon.client,\n\t\tSTSEndpoint:  s.endPoint,\n\t\tLDAPUsername: \"dillon\",\n\t\tLDAPPassword: \"dillon\",\n\t}\n\n\tvalue, err := ldapID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Check that the LDAP sts cred is actually working.\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, value.AccessKeyID, userAdmClient)\n\n\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n\n\t// 1. Check S3 access for service account ListObjects()\n\tc.mustListObjects(ctx, svcClient, bucket)\n\n\t// 2. Check S3 access for upload\n\tc.mustUpload(ctx, svcClient, bucket)\n\n\t// 3. Check S3 access for download\n\tc.mustDownload(ctx, svcClient, bucket)\n}\n\n// In this test, the parent users gets their permissions from a group, rather\n// than having a policy set directly on them.\nfunc (s *TestSuiteIAM) TestLDAPSTSServiceAccountsWithGroups(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Create policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tgroupDN := \"cn=projecta,ou=groups,ou=swengg,dc=min,dc=io\"\n\terr = s.adm.SetPolicy(ctx, policy, groupDN, true)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\tldapID := cr.LDAPIdentity{\n\t\tClient:       s.TestSuiteCommon.client,\n\t\tSTSEndpoint:  s.endPoint,\n\t\tLDAPUsername: \"dillon\",\n\t\tLDAPPassword: \"dillon\",\n\t}\n\n\tvalue, err := ldapID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Check that the LDAP sts cred is actually working.\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, value.AccessKeyID, userAdmClient)\n\n\t// 1. Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey)\n\n\t// 2. Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey, true)\n\n\t// 3. Check S3 access\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 6. Check that service account cannot be created for some other user.\n\tc.mustNotCreateSvcAccount(ctx, globalActiveCred.AccessKey, userAdmClient)\n}\n\nfunc (s *TestSuiteIAM) TestOpenIDSTS(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Generate web identity STS token by interacting with OpenID IDP.\n\ttoken, err := MockOpenIDTestUserInteraction(ctx, testAppParams, \"dillon@example.io\", \"dillon\")\n\tif err != nil {\n\t\tc.Fatalf(\"mock user err: %v\", err)\n\t}\n\t// fmt.Printf(\"TOKEN: %s\\n\", token)\n\n\twebID := cr.STSWebIdentity{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\tToken: token,\n\t\t\t}, nil\n\t\t},\n\t}\n\n\t// Create policy - with name as one of the groups in OpenID the user is\n\t// a member of.\n\tpolicy := \"projecta\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tvalue, err := webID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that the client cannot remove any objects\n\terr = minioClient.RemoveObject(ctx, bucket, \"someobject\", minio.RemoveObjectOptions{})\n\tif err.Error() != \"Access Denied.\" {\n\t\tc.Fatalf(\"unexpected non-access-denied err: %v\", err)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestOpenIDSTSAddUser(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Generate web identity STS token by interacting with OpenID IDP.\n\ttoken, err := MockOpenIDTestUserInteraction(ctx, testAppParams, \"dillon@example.io\", \"dillon\")\n\tif err != nil {\n\t\tc.Fatalf(\"mock user err: %v\", err)\n\t}\n\n\twebID := cr.STSWebIdentity{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\tToken: token,\n\t\t\t}, nil\n\t\t},\n\t}\n\n\t// Create policy - with name as one of the groups in OpenID the user is\n\t// a member of.\n\tpolicy := \"projecta\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tvalue, err := webID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\tc.mustNotCreateIAMUser(ctx, userAdmClient)\n\n\t// Create admin user policy.\n\tpolicyBytes = []byte(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"admin:*\"\n   ]\n  }\n ]\n}`)\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tcr := c.mustCreateIAMUser(ctx, userAdmClient)\n\n\tuserInfo := c.mustGetIAMUserInfo(ctx, userAdmClient, cr.AccessKey)\n\tc.Assert(userInfo.Status, madmin.AccountEnabled)\n}\n\nfunc (s *TestSuiteIAM) TestOpenIDServiceAcc(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Generate web identity STS token by interacting with OpenID IDP.\n\ttoken, err := MockOpenIDTestUserInteraction(ctx, testAppParams, \"dillon@example.io\", \"dillon\")\n\tif err != nil {\n\t\tc.Fatalf(\"mock user err: %v\", err)\n\t}\n\n\twebID := cr.STSWebIdentity{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\tToken: token,\n\t\t\t}, nil\n\t\t},\n\t}\n\n\t// Create policy - with name as one of the groups in OpenID the user is\n\t// a member of.\n\tpolicy := \"projecta\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tvalue, err := webID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, value.AccessKeyID, userAdmClient)\n\n\t// 1. Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey)\n\n\t// 2. Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey, true)\n\n\t// 3. Check S3 access\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 6. Check that service account cannot be created for some other user.\n\tc.mustNotCreateSvcAccount(ctx, globalActiveCred.AccessKey, userAdmClient)\n}\n\nvar testAppParams = OpenIDClientAppParams{\n\tClientID:     \"minio-client-app\",\n\tClientSecret: \"minio-client-app-secret\",\n\tProviderURL:  \"http://127.0.0.1:5556/dex\",\n\tRedirectURL:  \"http://127.0.0.1:10000/oauth_callback\",\n}\n\nconst (\n\tEnvTestOpenIDServer  = \"_MINIO_OPENID_TEST_SERVER\"\n\tEnvTestOpenIDServer2 = \"_MINIO_OPENID_TEST_SERVER_2\"\n)\n\n// SetUpOpenIDs - sets up one or more OpenID test servers using the test OpenID\n// container and canned data from https://github.com/minio/minio-ldap-testing\n//\n// Each set of client app params corresponds to a separate openid server, and\n// the i-th server in this will be applied the i-th policy in `rolePolicies`. If\n// a rolePolicies entry is an empty string, that server will be configured as\n// policy-claim based openid server. NOTE that a valid configuration can have a\n// policy claim based provider only if it is the only OpenID provider.\nfunc (s *TestSuiteIAM) SetUpOpenIDs(c *check, testApps []OpenIDClientAppParams, rolePolicies []string) error {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tfor i, testApp := range testApps {\n\t\tconfigCmds := []string{\n\t\t\tfmt.Sprintf(\"identity_openid:%d\", i),\n\t\t\tfmt.Sprintf(\"config_url=%s/.well-known/openid-configuration\", testApp.ProviderURL),\n\t\t\tfmt.Sprintf(\"client_id=%s\", testApp.ClientID),\n\t\t\tfmt.Sprintf(\"client_secret=%s\", testApp.ClientSecret),\n\t\t\t\"scopes=openid,groups\",\n\t\t\tfmt.Sprintf(\"redirect_uri=%s\", testApp.RedirectURL),\n\t\t}\n\t\tif rolePolicies[i] != \"\" {\n\t\t\tconfigCmds = append(configCmds, fmt.Sprintf(\"role_policy=%s\", rolePolicies[i]))\n\t\t} else {\n\t\t\tconfigCmds = append(configCmds, \"claim_name=groups\")\n\t\t}\n\t\t_, err := s.adm.SetConfigKV(ctx, strings.Join(configCmds, \" \"))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to setup OpenID for tests: %v\", err)\n\t\t}\n\t}\n\n\ts.RestartIAMSuite(c)\n\treturn nil\n}\n\n// SetUpOpenID - expects to setup an OpenID test server using the test OpenID\n// container and canned data from https://github.com/minio/minio-ldap-testing\nfunc (s *TestSuiteIAM) SetUpOpenID(c *check, serverAddr string, rolePolicy string) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tconfigCmds := []string{\n\t\t\"identity_openid\",\n\t\tfmt.Sprintf(\"config_url=%s/.well-known/openid-configuration\", serverAddr),\n\t\t\"client_id=minio-client-app\",\n\t\t\"client_secret=minio-client-app-secret\",\n\t\t\"scopes=openid,groups\",\n\t\t\"redirect_uri=http://127.0.0.1:10000/oauth_callback\",\n\t}\n\tif rolePolicy != \"\" {\n\t\tconfigCmds = append(configCmds, fmt.Sprintf(\"role_policy=%s\", rolePolicy))\n\t} else {\n\t\tconfigCmds = append(configCmds, \"claim_name=groups\")\n\t}\n\t_, err := s.adm.SetConfigKV(ctx, strings.Join(configCmds, \" \"))\n\tif err != nil {\n\t\tc.Fatalf(\"unable to setup OpenID for tests: %v\", err)\n\t}\n\n\ts.RestartIAMSuite(c)\n}\n\nfunc TestIAMWithOpenIDServerSuite(t *testing.T) {\n\tfor i, testCase := range iamTestSuites {\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s\", i+1, testCase.ServerTypeDescription),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tc := &check{t, testCase.serverType}\n\t\t\t\tsuite := testCase\n\n\t\t\t\topenIDServer := os.Getenv(EnvTestOpenIDServer)\n\t\t\t\tif openIDServer == \"\" {\n\t\t\t\t\tc.Skip(\"Skipping OpenID test as no OpenID server is provided.\")\n\t\t\t\t}\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tsuite.SetUpOpenID(c, openIDServer, \"\")\n\t\t\t\tsuite.TestOpenIDSTS(c)\n\t\t\t\tsuite.TestOpenIDServiceAcc(c)\n\t\t\t\tsuite.TestOpenIDSTSAddUser(c)\n\t\t\t\tsuite.TearDownSuite(c)\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc TestIAMWithOpenIDWithRolePolicyServerSuite(t *testing.T) {\n\tfor i, testCase := range iamTestSuites {\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s\", i+1, testCase.ServerTypeDescription),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tc := &check{t, testCase.serverType}\n\t\t\t\tsuite := testCase\n\n\t\t\t\topenIDServer := os.Getenv(EnvTestOpenIDServer)\n\t\t\t\tif openIDServer == \"\" {\n\t\t\t\t\tc.Skip(\"Skipping OpenID test as no OpenID server is provided.\")\n\t\t\t\t}\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tsuite.SetUpOpenID(c, openIDServer, \"readwrite\")\n\t\t\t\tsuite.TestOpenIDSTSWithRolePolicy(c, testRoleARNs[0], testRoleMap[testRoleARNs[0]])\n\t\t\t\tsuite.TestOpenIDServiceAccWithRolePolicy(c)\n\t\t\t\tsuite.TearDownSuite(c)\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc TestIAMWithOpenIDWithRolePolicyWithPolicyVariablesServerSuite(t *testing.T) {\n\tfor i, testCase := range iamTestSuites {\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s\", i+1, testCase.ServerTypeDescription),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tc := &check{t, testCase.serverType}\n\t\t\t\tsuite := testCase\n\n\t\t\t\topenIDServer := os.Getenv(EnvTestOpenIDServer)\n\t\t\t\tif openIDServer == \"\" {\n\t\t\t\t\tc.Skip(\"Skipping OpenID test as no OpenID server is provided.\")\n\t\t\t\t}\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tsuite.SetUpOpenID(c, openIDServer, \"projecta,projectb,projectaorb\")\n\t\t\t\tsuite.TestOpenIDSTSWithRolePolicyWithPolVar(c, testRoleARNs[0], testRoleMap[testRoleARNs[0]])\n\t\t\t\tsuite.TearDownSuite(c)\n\t\t\t},\n\t\t)\n\t}\n}\n\nconst (\n\ttestRoleARN  = \"arn:minio:iam:::role/nOybJqMNzNmroqEKq5D0EUsRZw0\"\n\ttestRoleARN2 = \"arn:minio:iam:::role/domXb70kze7Ugc1SaxaeFchhLP4\"\n)\n\nvar (\n\ttestRoleARNs = []string{testRoleARN, testRoleARN2}\n\n\t// Load test client app and test role mapping depending on test\n\t// environment.\n\ttestClientApps, testRoleMap = func() ([]OpenIDClientAppParams, map[string]OpenIDClientAppParams) {\n\t\tvar apps []OpenIDClientAppParams\n\t\tm := map[string]OpenIDClientAppParams{}\n\n\t\topenIDServer := os.Getenv(EnvTestOpenIDServer)\n\t\tif openIDServer != \"\" {\n\t\t\tapps = append(apps, OpenIDClientAppParams{\n\t\t\t\tClientID:     \"minio-client-app\",\n\t\t\t\tClientSecret: \"minio-client-app-secret\",\n\t\t\t\tProviderURL:  openIDServer,\n\t\t\t\tRedirectURL:  \"http://127.0.0.1:10000/oauth_callback\",\n\t\t\t})\n\t\t\tm[testRoleARNs[len(apps)-1]] = apps[len(apps)-1]\n\t\t}\n\n\t\topenIDServer2 := os.Getenv(EnvTestOpenIDServer2)\n\t\tif openIDServer2 != \"\" {\n\t\t\tapps = append(apps, OpenIDClientAppParams{\n\t\t\t\tClientID:     \"minio-client-app-2\",\n\t\t\t\tClientSecret: \"minio-client-app-secret-2\",\n\t\t\t\tProviderURL:  openIDServer2,\n\t\t\t\tRedirectURL:  \"http://127.0.0.1:10000/oauth_callback\",\n\t\t\t})\n\t\t\tm[testRoleARNs[len(apps)-1]] = apps[len(apps)-1]\n\t\t}\n\n\t\treturn apps, m\n\t}()\n)\n\nfunc (s *TestSuiteIAM) TestOpenIDSTSWithRolePolicy(c *check, roleARN string, clientApp OpenIDClientAppParams) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Generate web identity JWT by interacting with OpenID IDP.\n\ttoken, err := MockOpenIDTestUserInteraction(ctx, clientApp, \"dillon@example.io\", \"dillon\")\n\tif err != nil {\n\t\tc.Fatalf(\"mock user err: %v\", err)\n\t}\n\n\t// Generate STS credential.\n\twebID := cr.STSWebIdentity{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\tToken: token,\n\t\t\t}, nil\n\t\t},\n\t\tRoleARN: roleARN,\n\t}\n\n\tvalue, err := webID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\t// fmt.Printf(\"value: %#v\\n\", value)\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n}\n\nfunc (s *TestSuiteIAM) TestOpenIDServiceAccWithRolePolicy(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Generate web identity STS token by interacting with OpenID IDP.\n\ttoken, err := MockOpenIDTestUserInteraction(ctx, testAppParams, \"dillon@example.io\", \"dillon\")\n\tif err != nil {\n\t\tc.Fatalf(\"mock user err: %v\", err)\n\t}\n\n\twebID := cr.STSWebIdentity{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\tToken: token,\n\t\t\t}, nil\n\t\t},\n\t\tRoleARN: testRoleARN,\n\t}\n\n\tvalue, err := webID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, value.AccessKeyID, userAdmClient)\n\n\t// 1. Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey)\n\n\t// 2. Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey, true)\n\n\t// 3. Check S3 access\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n}\n\n// Constants for Policy Variables test.\nvar (\n\tpolicyProjectA = `{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                        \"s3:GetBucketLocation\",\n                        \"s3:ListAllMyBuckets\"\n                      ],\n            \"Resource\": \"arn:aws:s3:::*\"\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": \"s3:*\",\n            \"Resource\": [\n                \"arn:aws:s3:::projecta\",\n                \"arn:aws:s3:::projecta/*\"\n            ],\n            \"Condition\": {\n                \"ForAnyValue:StringEquals\": {\n                    \"jwt:groups\": [\n                        \"projecta\"\n                    ]\n                }\n            }\n        }\n    ]\n}\n`\n\tpolicyProjectB = `{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                        \"s3:GetBucketLocation\",\n                        \"s3:ListAllMyBuckets\"\n                      ],\n            \"Resource\": \"arn:aws:s3:::*\"\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": \"s3:*\",\n            \"Resource\": [\n                \"arn:aws:s3:::projectb\",\n                \"arn:aws:s3:::projectb/*\"\n            ],\n            \"Condition\": {\n                \"ForAnyValue:StringEquals\": {\n                    \"jwt:groups\": [\n                        \"projectb\"\n                    ]\n                }\n            }\n        }\n    ]\n}\n`\n\tpolicyProjectAorB = `{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                        \"s3:GetBucketLocation\",\n                        \"s3:ListAllMyBuckets\"\n                      ],\n            \"Resource\": \"arn:aws:s3:::*\"\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": \"s3:*\",\n            \"Resource\": [\n                \"arn:aws:s3:::projectaorb\",\n                \"arn:aws:s3:::projectaorb/*\"\n            ],\n            \"Condition\": {\n                \"ForAnyValue:StringEquals\": {\n                    \"jwt:groups\": [\n                        \"projecta\",\n                        \"projectb\"\n                    ]\n                }\n            }\n        }\n    ]\n}`\n\n\tpolicyProjectsMap = map[string]string{\n\t\t// grants access to bucket `projecta` if user is in group `projecta`\n\t\t\"projecta\": policyProjectA,\n\n\t\t// grants access to bucket `projectb` if user is in group `projectb`\n\t\t\"projectb\": policyProjectB,\n\n\t\t// grants access to bucket `projectaorb` if user is in either group\n\t\t// `projecta` or `projectb`\n\t\t\"projectaorb\": policyProjectAorB,\n\t}\n)\n\nfunc (s *TestSuiteIAM) TestOpenIDSTSWithRolePolicyWithPolVar(c *check, roleARN string, clientApp OpenIDClientAppParams) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\t// Create project buckets\n\tbuckets := []string{\"projecta\", \"projectb\", \"projectaorb\", \"other\"}\n\tfor _, bucket := range buckets {\n\t\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\t\tif err != nil {\n\t\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t\t}\n\t}\n\n\t// Create policies\n\tfor polName, polContent := range policyProjectsMap {\n\t\terr := s.adm.AddCannedPolicy(ctx, polName, []byte(polContent))\n\t\tif err != nil {\n\t\t\tc.Fatalf(\"policy add error: %v\", err)\n\t\t}\n\t}\n\n\tmakeSTSClient := func(user, password string) *minio.Client {\n\t\t// Generate web identity JWT by interacting with OpenID IDP.\n\t\ttoken, err := MockOpenIDTestUserInteraction(ctx, clientApp, user, password)\n\t\tif err != nil {\n\t\t\tc.Fatalf(\"mock user err: %v\", err)\n\t\t}\n\n\t\t// Generate STS credential.\n\t\twebID := cr.STSWebIdentity{\n\t\t\tClient:      s.TestSuiteCommon.client,\n\t\t\tSTSEndpoint: s.endPoint,\n\t\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\t\tToken: token,\n\t\t\t\t}, nil\n\t\t\t},\n\t\t\tRoleARN: roleARN,\n\t\t}\n\n\t\tvalue, err := webID.Retrieve()\n\t\tif err != nil {\n\t\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t\t}\n\t\t// fmt.Printf(\"value: %#v\\n\", value)\n\n\t\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\t\tSecure:    s.secure,\n\t\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t\t})\n\t\tif err != nil {\n\t\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t\t}\n\n\t\treturn minioClient\n\t}\n\n\t// user dillon's groups attribute is [\"projecta\", \"projectb\"]\n\tdillonClient := makeSTSClient(\"dillon@example.io\", \"dillon\")\n\t// Validate client's permissions\n\tc.mustListBuckets(ctx, dillonClient)\n\tc.mustListObjects(ctx, dillonClient, \"projecta\")\n\tc.mustListObjects(ctx, dillonClient, \"projectb\")\n\tc.mustListObjects(ctx, dillonClient, \"projectaorb\")\n\tc.mustNotListObjects(ctx, dillonClient, \"other\")\n\n\t// this user's groups attribute is [\"projectb\"]\n\tlisaClient := makeSTSClient(\"ejones@example.io\", \"liza\")\n\t// Validate client's permissions\n\tc.mustListBuckets(ctx, lisaClient)\n\tc.mustNotListObjects(ctx, lisaClient, \"projecta\")\n\tc.mustListObjects(ctx, lisaClient, \"projectb\")\n\tc.mustListObjects(ctx, lisaClient, \"projectaorb\")\n\tc.mustNotListObjects(ctx, lisaClient, \"other\")\n}\n\nfunc TestIAMWithOpenIDMultipleConfigsValidation1(t *testing.T) {\n\topenIDServer := os.Getenv(EnvTestOpenIDServer)\n\topenIDServer2 := os.Getenv(EnvTestOpenIDServer2)\n\tif openIDServer == \"\" || openIDServer2 == \"\" {\n\t\tt.Skip(\"Skipping OpenID test as enough OpenID servers are not provided.\")\n\t}\n\ttestApps := testClientApps\n\n\trolePolicies := []string{\n\t\t\"\", // Treated as claim-based provider as no role policy is given.\n\t\t\"readwrite\",\n\t}\n\n\tfor i, testCase := range iamTestSuites {\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s\", i+1, testCase.ServerTypeDescription),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tc := &check{t, testCase.serverType}\n\t\t\t\tsuite := testCase\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tdefer suite.TearDownSuite(c)\n\n\t\t\t\terr := suite.SetUpOpenIDs(c, testApps, rolePolicies)\n\t\t\t\tif err != nil {\n\t\t\t\t\tc.Fatalf(\"config with 1 claim based and 1 role based provider should pass but got: %v\", err)\n\t\t\t\t}\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc TestIAMWithOpenIDMultipleConfigsValidation2(t *testing.T) {\n\topenIDServer := os.Getenv(EnvTestOpenIDServer)\n\topenIDServer2 := os.Getenv(EnvTestOpenIDServer2)\n\tif openIDServer == \"\" || openIDServer2 == \"\" {\n\t\tt.Skip(\"Skipping OpenID test as enough OpenID servers are not provided.\")\n\t}\n\ttestApps := testClientApps\n\n\trolePolicies := []string{\n\t\t\"\", // Treated as claim-based provider as no role policy is given.\n\t\t\"\", // Treated as claim-based provider as no role policy is given.\n\t}\n\n\tfor i, testCase := range iamTestSuites {\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s\", i+1, testCase.ServerTypeDescription),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tc := &check{t, testCase.serverType}\n\t\t\t\tsuite := testCase\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tdefer suite.TearDownSuite(c)\n\n\t\t\t\terr := suite.SetUpOpenIDs(c, testApps, rolePolicies)\n\t\t\t\tif err == nil {\n\t\t\t\t\tc.Fatalf(\"config with 2 claim based provider should fail\")\n\t\t\t\t}\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc TestIAMWithOpenIDWithMultipleRolesServerSuite(t *testing.T) {\n\topenIDServer := os.Getenv(EnvTestOpenIDServer)\n\topenIDServer2 := os.Getenv(EnvTestOpenIDServer2)\n\tif openIDServer == \"\" || openIDServer2 == \"\" {\n\t\tt.Skip(\"Skipping OpenID test as enough OpenID servers are not provided.\")\n\t}\n\ttestApps := testClientApps\n\n\trolePolicies := []string{\n\t\t\"consoleAdmin\",\n\t\t\"readwrite\",\n\t}\n\n\tfor i, testCase := range iamTestSuites {\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s\", i+1, testCase.ServerTypeDescription),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tc := &check{t, testCase.serverType}\n\t\t\t\tsuite := testCase\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\terr := suite.SetUpOpenIDs(c, testApps, rolePolicies)\n\t\t\t\tif err != nil {\n\t\t\t\t\tc.Fatalf(\"Error setting up openid providers for tests: %v\", err)\n\t\t\t\t}\n\t\t\t\tsuite.TestOpenIDSTSWithRolePolicy(c, testRoleARNs[0], testRoleMap[testRoleARNs[0]])\n\t\t\t\tsuite.TestOpenIDSTSWithRolePolicy(c, testRoleARNs[1], testRoleMap[testRoleARNs[1]])\n\t\t\t\tsuite.TestOpenIDServiceAccWithRolePolicy(c)\n\t\t\t\tsuite.TearDownSuite(c)\n\t\t\t},\n\t\t)\n\t}\n}\n\n// Access Management Plugin tests\nfunc TestIAM_AMPWithOpenIDWithMultipleRolesServerSuite(t *testing.T) {\n\topenIDServer := os.Getenv(EnvTestOpenIDServer)\n\topenIDServer2 := os.Getenv(EnvTestOpenIDServer2)\n\tif openIDServer == \"\" || openIDServer2 == \"\" {\n\t\tt.Skip(\"Skipping OpenID test as enough OpenID servers are not provided.\")\n\t}\n\ttestApps := testClientApps\n\n\trolePolicies := []string{\n\t\t\"consoleAdmin\",\n\t\t\"readwrite\",\n\t}\n\n\tfor i, testCase := range iamTestSuites {\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s\", i+1, testCase.ServerTypeDescription),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tc := &check{t, testCase.serverType}\n\t\t\t\tsuite := testCase\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tdefer suite.TearDownSuite(c)\n\n\t\t\t\terr := suite.SetUpOpenIDs(c, testApps, rolePolicies)\n\t\t\t\tif err != nil {\n\t\t\t\t\tc.Fatalf(\"Error setting up openid providers for tests: %v\", err)\n\t\t\t\t}\n\n\t\t\t\tsuite.SetUpAccMgmtPlugin(c)\n\n\t\t\t\tsuite.TestOpenIDSTSWithRolePolicyUnderAMP(c, testRoleARNs[0], testRoleMap[testRoleARNs[0]])\n\t\t\t\tsuite.TestOpenIDSTSWithRolePolicyUnderAMP(c, testRoleARNs[1], testRoleMap[testRoleARNs[1]])\n\t\t\t\tsuite.TestOpenIDServiceAccWithRolePolicyUnderAMP(c)\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestOpenIDSTSWithRolePolicyUnderAMP(c *check, roleARN string, clientApp OpenIDClientAppParams) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Generate web identity JWT by interacting with OpenID IDP.\n\ttoken, err := MockOpenIDTestUserInteraction(ctx, clientApp, \"dillon@example.io\", \"dillon\")\n\tif err != nil {\n\t\tc.Fatalf(\"mock user err: %v\", err)\n\t}\n\n\t// Generate STS credential.\n\twebID := cr.STSWebIdentity{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\tToken: token,\n\t\t\t}, nil\n\t\t},\n\t\tRoleARN: roleARN,\n\t}\n\n\tvalue, err := webID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\t// fmt.Printf(\"value: %#v\\n\", value)\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that the client from STS creds cannot upload any object as\n\t// it is denied by the plugin.\n\tc.mustNotUpload(ctx, minioClient, bucket)\n}\n\nfunc (s *TestSuiteIAM) TestOpenIDServiceAccWithRolePolicyUnderAMP(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Generate web identity STS token by interacting with OpenID IDP.\n\ttoken, err := MockOpenIDTestUserInteraction(ctx, testAppParams, \"dillon@example.io\", \"dillon\")\n\tif err != nil {\n\t\tc.Fatalf(\"mock user err: %v\", err)\n\t}\n\n\twebID := cr.STSWebIdentity{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\tToken: token,\n\t\t\t}, nil\n\t\t},\n\t\tRoleARN: testRoleARN,\n\t}\n\n\tvalue, err := webID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, value.AccessKeyID, userAdmClient)\n\n\t// 1. Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey)\n\n\t// 2. Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey, true)\n\n\t// 3. Check S3 access\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\t// 3.1 Validate that the client from STS creds cannot upload any object as\n\t// it is denied by the plugin.\n\tc.mustNotUpload(ctx, s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\"), bucket)\n\n\t// Check that session policies do not apply - as policy enforcement is\n\t// delegated to plugin.\n\t{\n\t\tsvcAK, svcSK := mustGenerateCredentials(c)\n\n\t\t// This policy does not allow listing objects.\n\t\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\t\tcr, err := userAdmClient.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n\t\t\tPolicy:     policyBytes,\n\t\t\tTargetUser: value.AccessKeyID,\n\t\t\tAccessKey:  svcAK,\n\t\t\tSecretKey:  svcSK,\n\t\t})\n\t\tif err != nil {\n\t\t\tc.Fatalf(\"Unable to create svc acc: %v\", err)\n\t\t}\n\t\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n\t\t// Though the attached policy does not allow listing, it will be\n\t\t// ignored because the plugin allows it.\n\t\tc.mustListObjects(ctx, svcClient, bucket)\n\t}\n\n\t// 4. Check that service account's secret key and account status can be\n\t// updated.\n\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n}\n"], "filenames": ["cmd/admin-handlers-users.go", "cmd/admin-handlers-users_test.go", "cmd/auth-handler.go", "cmd/iam.go", "cmd/signature-v4-utils.go", "cmd/sts-handlers_test.go"], "buggy_code_start_loc": [776, 208, 165, 977, 161, 912], "buggy_code_end_loc": [794, 979, 166, 2005, 163, 1668], "fixing_code_start_loc": [777, 209, 165, 977, 161, 911], "fixing_code_end_loc": [797, 1062, 167, 1988, 163, 1635], "type": "CWE-269", "message": "MinIO is a High Performance Object Storage. When someone creates an access key, it inherits the permissions of the parent key. Not only for `s3:*` actions, but also `admin:*` actions. Which means unless somewhere above in the access-key hierarchy, the `admin` rights are denied, access keys will be able to simply override their own `s3` permissions to something more permissive. The vulnerability is fixed in RELEASE.2024-01-31T20-20-33Z.", "other": {"cve": {"id": "CVE-2024-24747", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-31T22:15:54.813", "lastModified": "2024-02-09T15:18:00.510", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "MinIO is a High Performance Object Storage. When someone creates an access key, it inherits the permissions of the parent key. Not only for `s3:*` actions, but also `admin:*` actions. Which means unless somewhere above in the access-key hierarchy, the `admin` rights are denied, access keys will be able to simply override their own `s3` permissions to something more permissive. The vulnerability is fixed in RELEASE.2024-01-31T20-20-33Z."}, {"lang": "es", "value": "MinIO es un almacenamiento de objetos de alto rendimiento. Cuando alguien crea una clave de acceso, hereda los permisos de la clave principal. No solo para acciones `s3:*`, sino tambi\u00e9n para acciones `admin:*`. Lo que significa que, a menos que en alg\u00fan lugar superior de la jerarqu\u00eda de claves de acceso se denieguen los derechos de \"administrador\", las claves de acceso podr\u00e1n simplemente anular sus propios permisos \"s3\" por algo m\u00e1s permisivo. La vulnerabilidad se solucion\u00f3 en RELEASE.2024-01-31T20-20-33Z."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:minio:minio:2024-01-31t20-20-33z:*:*:*:*:*:*:*", "matchCriteriaId": "67E9B6B4-7A63-40A3-B815-3ADCA52DE423"}]}]}], "references": [{"url": "https://github.com/minio/minio/commit/0ae4915a9391ef4b3ec80f5fcdcf24ee6884e776", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/minio/minio/releases/tag/RELEASE.2024-01-31T20-20-33Z", "source": "security-advisories@github.com", "tags": ["Patch", "Release Notes"]}, {"url": "https://github.com/minio/minio/security/advisories/GHSA-xx8w-mq23-29g4", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/minio/minio/commit/0ae4915a9391ef4b3ec80f5fcdcf24ee6884e776"}}