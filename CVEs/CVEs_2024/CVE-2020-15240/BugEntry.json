{"buggy_code": ["require 'base64'\nrequire 'uri'\nrequire 'json'\nrequire 'omniauth'\nrequire 'omniauth/auth0/errors'\n\nmodule OmniAuth\n  module Auth0\n    # JWT Validator class\n    class JWTValidator\n      attr_accessor :issuer, :domain\n\n      # Initializer\n      # @param options object\n      #   options.domain - Application domain.\n      #   options.issuer - Application issuer (optional).\n      #   options.client_id - Application Client ID.\n      #   options.client_secret - Application Client Secret.\n\n      def initialize(options, authorize_params = {})\n        @domain = uri_string(options.domain)\n\n        # Use custom issuer if provided, otherwise use domain\n        @issuer = @domain\n        @issuer = uri_string(options.issuer) if options.respond_to?(:issuer)\n\n        @client_id = options.client_id\n        @client_secret = options.client_secret\n      end\n\n      def verify_signature(jwt)\n        head = token_head(jwt)\n\n        # Make sure the algorithm is supported and get the decode key.\n        if head[:alg] == 'RS256'\n          [rs256_decode_key(head[:kid]), head[:alg]]\n        elsif head[:alg] == 'HS256'\n          [@client_secret, head[:alg]]\n        else\n          raise OmniAuth::Auth0::TokenValidationError.new(\"Signature algorithm of #{head[:alg]} is not supported. Expected the ID token to be signed with RS256 or HS256\")\n        end\n      end\n\n      # Verify a JWT.\n      # @param jwt string - JWT to verify.\n      # @param authorize_params hash - Authorization params to verify on the JWT\n      # @return hash - The verified token, if there were no exceptions.\n      def verify(jwt, authorize_params = {})\n        if !jwt\n          raise OmniAuth::Auth0::TokenValidationError.new('ID token is required but missing')\n        end\n\n        parts = jwt.split('.')\n        if parts.length != 3\n          raise OmniAuth::Auth0::TokenValidationError.new('ID token could not be decoded')\n        end\n\n        key, alg = verify_signature(jwt)\n        id_token, header = JWT.decode(jwt, key, false)\n        verify_claims(id_token, authorize_params)\n\n        return id_token\n      end\n\n      # Get the decoded head segment from a JWT.\n      # @return hash - The parsed head of the JWT passed, empty hash if not.\n      def token_head(jwt)\n        jwt_parts = jwt.split('.')\n        return {} if blank?(jwt_parts) || blank?(jwt_parts[0])\n\n        json_parse(Base64.decode64(jwt_parts[0]))\n      end\n\n      # Get the JWKS from the issuer and return a public key.\n      # @param x5c string - X.509 certificate chain from a JWKS.\n      # @return key - The X.509 certificate public key.\n      def jwks_public_cert(x5c)\n        x5c = Base64.decode64(x5c)\n\n        # https://docs.ruby-lang.org/en/2.4.0/OpenSSL/X509/Certificate.html\n        OpenSSL::X509::Certificate.new(x5c).public_key\n      end\n\n      # Return a specific key from a JWKS object.\n      # @param key string - Key to find in the JWKS.\n      # @param kid string - Key ID to identify the right JWK.\n      # @return nil|string\n      def jwks_key(key, kid)\n        return nil if blank?(jwks[:keys])\n\n        matching_jwk = jwks[:keys].find { |jwk| jwk[:kid] == kid }\n        matching_jwk[key] if matching_jwk\n      end\n\n      private\n      def rs256_decode_key(kid)\n        jwks_x5c = jwks_key(:x5c, kid)\n\n        if jwks_x5c.nil?\n          raise OmniAuth::Auth0::TokenValidationError.new(\"Could not find a public key for Key ID (kid) '#{kid}''\")\n        end\n\n        jwks_public_cert(jwks_x5c.first)\n      end\n\n      # Get a JWKS from the domain\n      # @return void\n      def jwks\n        jwks_uri = URI(@domain + '.well-known/jwks.json')\n        @jwks ||= json_parse(Net::HTTP.get(jwks_uri))\n      end\n\n      # Rails Active Support blank method.\n      # @param obj object - Object to check for blankness.\n      # @return boolean\n      def blank?(obj)\n        obj.respond_to?(:empty?) ? obj.empty? : !obj\n      end\n\n      # Parse JSON with symbolized names.\n      # @param json string - JSON to parse.\n      # @return hash\n      def json_parse(json)\n        JSON.parse(json, symbolize_names: true)\n      end\n\n      # Parse a URI into the desired string format\n      # @param uri - the URI to parse\n      # @return string\n      def uri_string(uri)\n        temp_domain = URI(uri)\n        temp_domain = URI(\"https://#{uri}\") unless temp_domain.scheme\n        \"#{temp_domain}/\"\n      end\n\n      def verify_claims(id_token, authorize_params)\n        leeway = authorize_params[:leeway] || 60\n        max_age = authorize_params[:max_age]\n        nonce = authorize_params[:nonce]\n\n        verify_iss(id_token)\n        verify_sub(id_token)\n        verify_aud(id_token)\n        verify_expiration(id_token, leeway)\n        verify_iat(id_token)\n        verify_nonce(id_token, nonce)\n        verify_azp(id_token)\n        verify_auth_time(id_token, leeway, max_age)\n      end\n\n      def verify_iss(id_token)\n        issuer = id_token['iss']\n        if !issuer\n          raise OmniAuth::Auth0::TokenValidationError.new(\"Issuer (iss) claim must be a string present in the ID token\")\n        elsif @issuer != issuer\n          raise OmniAuth::Auth0::TokenValidationError.new(\"Issuer (iss) claim mismatch in the ID token, expected (#{@issuer}), found (#{id_token['iss']})\")\n        end\n      end\n\n      def verify_sub(id_token)\n        subject = id_token['sub']\n        if !subject || !subject.is_a?(String) || subject.empty?\n          raise OmniAuth::Auth0::TokenValidationError.new('Subject (sub) claim must be a string present in the ID token')\n        end\n      end\n\n      def verify_aud(id_token)\n        audience = id_token['aud']\n        if !audience || !(audience.is_a?(String) || audience.is_a?(Array))\n          raise OmniAuth::Auth0::TokenValidationError.new(\"Audience (aud) claim must be a string or array of strings present in the ID token\")\n        elsif audience.is_a?(Array) && !audience.include?(@client_id)\n          raise OmniAuth::Auth0::TokenValidationError.new(\"Audience (aud) claim mismatch in the ID token; expected #{@client_id} but was not one of #{audience.join(', ')}\")\n        elsif audience.is_a?(String) && audience != @client_id\n          raise OmniAuth::Auth0::TokenValidationError.new(\"Audience (aud) claim mismatch in the ID token; expected #{@client_id} but found #{audience}\")\n        end\n      end\n\n      def verify_expiration(id_token, leeway)\n        expiration = id_token['exp']\n        if !expiration || !expiration.is_a?(Integer)\n          raise OmniAuth::Auth0::TokenValidationError.new(\"Expiration time (exp) claim must be a number present in the ID token\")\n        elsif expiration <= Time.now.to_i - leeway\n          raise OmniAuth::Auth0::TokenValidationError.new(\"Expiration time (exp) claim error in the ID token; current time (#{Time.now}) is after expiration time (#{Time.at(expiration + leeway)})\")\n        end\n      end\n\n      def verify_iat(id_token)\n        if !id_token['iat']\n          raise OmniAuth::Auth0::TokenValidationError.new(\"Issued At (iat) claim must be a number present in the ID token\")\n        end\n      end\n\n      def verify_nonce(id_token, nonce)\n        if nonce\n          received_nonce = id_token['nonce']\n          if !received_nonce\n            raise OmniAuth::Auth0::TokenValidationError.new(\"Nonce (nonce) claim must be a string present in the ID token\")\n          elsif nonce != received_nonce\n            raise OmniAuth::Auth0::TokenValidationError.new(\"Nonce (nonce) claim value mismatch in the ID token; expected (#{nonce}), found (#{received_nonce})\")\n          end\n        end\n      end\n\n      def verify_azp(id_token)\n        audience = id_token['aud']\n        if audience.is_a?(Array) && audience.length > 1\n          azp = id_token['azp']\n          if !azp || !azp.is_a?(String)\n            raise OmniAuth::Auth0::TokenValidationError.new(\"Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values\")\n          elsif azp != @client_id\n            raise OmniAuth::Auth0::TokenValidationError.new(\"Authorized Party (azp) claim mismatch in the ID token; expected (#{@client_id}), found (#{azp})\")\n          end\n        end\n      end\n\n      def verify_auth_time(id_token, leeway, max_age)\n        if max_age\n          auth_time = id_token['auth_time']\n          if !auth_time || !auth_time.is_a?(Integer)\n            raise OmniAuth::Auth0::TokenValidationError.new(\"Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified\")\n          elsif Time.now.to_i >  auth_time + max_age + leeway;\n            raise OmniAuth::Auth0::TokenValidationError.new(\"Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time (#{Time.now}) is after last auth time (#{Time.at(auth_time + max_age + leeway)})\")\n          end\n        end\n      end\n    end\n  end\nend\n", "require 'spec_helper'\nrequire 'json'\nrequire 'jwt'\n\ndescribe OmniAuth::Auth0::JWTValidator do\n  #\n  # Reused data\n  #\n\n  let(:client_id) { 'CLIENT_ID' }\n  let(:client_secret) { 'CLIENT_SECRET' }\n  let(:domain) { 'samples.auth0.com' }\n  let(:future_timecode) { 32_503_680_000 }\n  let(:past_timecode) { 303_912_000 }\n  let(:jwks_kid) { 'NkJCQzIyQzRBMEU4NjhGNUU4MzU4RkY0M0ZDQzkwOUQ0Q0VGNUMwQg' }\n\n  let(:rsa_private_key) do\n    OpenSSL::PKey::RSA.generate 2048\n  end\n\n  let(:rsa_token_jwks) do\n    {\n      keys: [\n        {\n          kid: jwks_kid,\n          x5c: [Base64.encode64(make_cert(rsa_private_key).to_der)]\n        }\n      ]\n    }.to_json\n  end\n\n  let(:jwks) do\n    current_dir = File.dirname(__FILE__)\n    jwks_file = File.read(\"#{current_dir}/../../resources/jwks.json\")\n    JSON.parse(jwks_file, symbolize_names: true)\n  end\n\n  #\n  # Specs\n  #\n\n  describe 'JWT verifier default values' do\n    let(:jwt_validator) do\n      make_jwt_validator\n    end\n\n    it 'should have the correct issuer' do\n      expect(jwt_validator.issuer).to eq('https://samples.auth0.com/')\n    end\n  end\n\n  describe 'JWT verifier token_head' do\n    let(:jwt_validator) do\n      make_jwt_validator\n    end\n\n    it 'should parse the head of a valid JWT' do\n      expect(jwt_validator.token_head(make_hs256_token)[:alg]).to eq('HS256')\n    end\n\n    it 'should fail parsing the head of a blank JWT' do\n      expect(jwt_validator.token_head('')).to eq({})\n    end\n\n    it 'should fail parsing the head of an invalid JWT' do\n      expect(jwt_validator.token_head('.')).to eq({})\n    end\n\n    it 'should throw an exception for invalid JSON' do\n      expect do\n        jwt_validator.token_head('QXV0aDA=')\n      end.to raise_error(JSON::ParserError)\n    end\n  end\n\n  describe 'JWT verifier jwks_public_cert' do\n    let(:jwt_validator) do\n      make_jwt_validator\n    end\n\n    it 'should return a public_key' do\n      x5c = jwks[:keys].first[:x5c].first\n      public_cert = jwt_validator.jwks_public_cert(x5c)\n      expect(public_cert.instance_of?(OpenSSL::PKey::RSA)).to eq(true)\n    end\n\n    it 'should fail with an invalid x5c' do\n      expect do\n        jwt_validator.jwks_public_cert('QXV0aDA=')\n      end.to raise_error(OpenSSL::X509::CertificateError)\n    end\n  end\n\n  describe 'JWT verifier jwks_key' do\n    let(:jwt_validator) do\n      make_jwt_validator\n    end\n\n    before do\n      stub_jwks\n    end\n\n    it 'should return a key' do\n      expect(jwt_validator.jwks_key(:alg, jwks_kid)).to eq('RS256')\n    end\n\n    it 'should return an x5c key' do\n      expect(jwt_validator.jwks_key(:x5c, jwks_kid).length).to eq(1)\n    end\n\n    it 'should return nil if there is not key' do\n      expect(jwt_validator.jwks_key(:auth0, jwks_kid)).to eq(nil)\n    end\n\n    it 'should return nil if the key ID is invalid' do\n      expect(jwt_validator.jwks_key(:alg, \"#{jwks_kid}_invalid\")).to eq(nil)\n    end\n  end\n\n  describe 'JWT verifier custom issuer' do\n    context 'same as domain' do\n      let(:jwt_validator) do\n        make_jwt_validator(opt_issuer: domain)\n      end\n\n      it 'should have the correct issuer' do\n        expect(jwt_validator.issuer).to eq('https://samples.auth0.com/')\n      end\n\n      it 'should have the correct domain' do\n        expect(jwt_validator.issuer).to eq('https://samples.auth0.com/')\n      end\n    end\n\n    context 'different from domain' do\n      let(:jwt_validator) do\n        make_jwt_validator(opt_issuer: 'different.auth0.com')\n      end\n\n      it 'should have the correct issuer' do\n        expect(jwt_validator.issuer).to eq('https://different.auth0.com/')\n      end\n\n      it 'should have the correct domain' do\n        expect(jwt_validator.domain).to eq('https://samples.auth0.com/')\n      end\n    end\n  end\n\n  describe 'JWT verifier verify' do\n    let(:jwt_validator) do\n      make_jwt_validator\n    end\n\n    before do\n      stub_jwks\n      stub_dummy_jwks\n    end\n\n    it 'should fail with missing issuer' do\n      expect do\n        jwt_validator.verify(make_hs256_token)\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Issuer (iss) claim must be a string present in the ID token\"\n      }))\n    end\n\n    it 'should fail with invalid issuer' do\n      payload = {\n        iss: 'https://auth0.com/'\n      }\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token)\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Issuer (iss) claim mismatch in the ID token, expected (https://samples.auth0.com/), found (https://auth0.com/)\"\n      }))\n    end\n\n    it 'should fail when subject is missing' do\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: ''\n      }\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token)\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Subject (sub) claim must be a string present in the ID token\"\n      }))\n    end\n\n    it 'should fail with missing audience' do\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub'\n      }\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token)\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Audience (aud) claim must be a string or array of strings present in the ID token\"\n      }))\n    end\n\n    it 'should fail with invalid audience' do\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: 'Auth0'\n      }\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token)\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Audience (aud) claim mismatch in the ID token; expected #{client_id} but found Auth0\"\n      }))\n    end\n\n    it 'should fail when missing expiration' do\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: client_id\n      }\n\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token)\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Expiration time (exp) claim must be a number present in the ID token\"\n      }))\n    end\n\n    it 'should fail when past expiration' do\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: client_id,\n        exp: past_timecode\n      }\n\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token)\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Expiration time (exp) claim error in the ID token; current time (#{Time.now}) is after expiration time (#{Time.at(past_timecode + 60)})\"\n      }))\n    end\n\n    it 'should fail when missing iat' do\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: client_id,\n        exp: future_timecode\n      }\n\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token)\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Issued At (iat) claim must be a number present in the ID token\"\n      }))\n    end\n\n    it 'should fail when authorize params has nonce but nonce is missing in the token' do\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: client_id,\n        exp: future_timecode,\n        iat: past_timecode\n      }\n\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token, { nonce: 'noncey' })\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Nonce (nonce) claim must be a string present in the ID token\"\n      }))\n    end\n\n    it 'should fail when authorize params has nonce but token nonce does not match' do\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: client_id,\n        exp: future_timecode,\n        iat: past_timecode,\n        nonce: 'mismatch'\n      }\n\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token, { nonce: 'noncey' })\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Nonce (nonce) claim value mismatch in the ID token; expected (noncey), found (mismatch)\"\n      }))\n    end\n    \n    it 'should fail when \u201caud\u201d is an array of strings and azp claim is not present' do\n      aud = [\n        client_id,\n        \"https://#{domain}/userinfo\"\n      ]\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: aud,\n        exp: future_timecode,\n        iat: past_timecode\n      }\n\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token)\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values\"\n      }))\n    end\n\n    it 'should fail when \"azp\" claim doesnt match the expected aud' do\n      aud = [\n        client_id,\n        \"https://#{domain}/userinfo\"\n      ]\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: aud,\n        exp: future_timecode,\n        iat: past_timecode,\n        azp: 'not_expected'\n      }\n\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token)\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Authorized Party (azp) claim mismatch in the ID token; expected (#{client_id}), found (not_expected)\"\n      }))\n    end\n\n    it 'should fail when \u201cmax_age\u201d sent on the authentication request and this claim is not present' do\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: client_id,\n        exp: future_timecode,\n        iat: past_timecode\n      }\n\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token, { max_age: 60 })\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified\"\n      }))\n    end\n\n    it 'should fail when \u201cmax_age\u201d sent on the authentication request and this claim added the \u201cmax_age\u201d value doesn\u2019t represent a date in the future' do\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: client_id,\n        exp: future_timecode,\n        iat: past_timecode,\n        auth_time: past_timecode\n      }\n\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token, { max_age: 60 })\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time (#{Time.now}) is after last auth time (#{Time.at(past_timecode + 60 + 60)})\"\n      }))\n    end\n\n    it 'should verify a valid HS256 token with multiple audiences' do\n      audience = [\n        client_id,\n        \"https://#{domain}/userinfo\"\n      ]\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: audience,\n        exp: future_timecode,\n        iat: past_timecode,\n        azp: client_id\n      }\n      token = make_hs256_token(payload)\n      id_token = jwt_validator.verify(token)\n      expect(id_token['aud']).to eq(audience)\n    end\n\n    it 'should verify a standard HS256 token' do\n      sub = 'abc123'\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: sub,\n        aud: client_id,\n        exp: future_timecode,\n        iat: past_timecode\n      }\n      token = make_hs256_token(payload)\n      verified_token = jwt_validator.verify(token)\n      expect(verified_token['sub']).to eq(sub)\n    end\n\n    it 'should verify a standard RS256 token' do\n      domain = 'example.org'\n      sub = 'abc123'\n      payload = {\n        sub: sub,\n        exp: future_timecode,\n        iss: \"https://#{domain}/\",\n        iat: past_timecode,\n        aud: client_id,\n        kid: jwks_kid\n      }\n      token = make_rs256_token(payload)\n      verified_token = make_jwt_validator(opt_domain: domain).verify(token)\n      expect(verified_token['sub']).to eq(sub)\n    end\n  end\n\n  private\n\n  def make_jwt_validator(opt_domain: domain, opt_issuer: nil)\n    opts = OpenStruct.new(\n      domain: opt_domain,\n      client_id: client_id,\n      client_secret: client_secret\n    )\n    opts[:issuer] = opt_issuer unless opt_issuer.nil?\n\n    OmniAuth::Auth0::JWTValidator.new(opts)\n  end\n\n  def make_hs256_token(payload = nil)\n    payload = { sub: 'abc123' } if payload.nil?\n    JWT.encode payload, client_secret, 'HS256'\n  end\n\n  def make_rs256_token(payload = nil)\n    payload = { sub: 'abc123' } if payload.nil?\n    JWT.encode payload, rsa_private_key, 'RS256', kid: jwks_kid\n  end\n\n  def make_cert(private_key)\n    cert = OpenSSL::X509::Certificate.new\n    cert.issuer = OpenSSL::X509::Name.parse('/C=BE/O=Auth0/OU=Auth0/CN=Auth0')\n    cert.subject = cert.issuer\n    cert.not_before = Time.now\n    cert.not_after = Time.now + 365 * 24 * 60 * 60\n    cert.public_key = private_key.public_key\n    cert.serial = 0x0\n    cert.version = 2\n\n    ef = OpenSSL::X509::ExtensionFactory.new\n    ef.subject_certificate = cert\n    ef.issuer_certificate = cert\n    cert.extensions = [\n      ef.create_extension('basicConstraints', 'CA:TRUE', true),\n      ef.create_extension('subjectKeyIdentifier', 'hash')\n    ]\n    cert.add_extension ef.create_extension(\n      'authorityKeyIdentifier',\n      'keyid:always,issuer:always'\n    )\n\n    cert.sign private_key, OpenSSL::Digest::SHA1.new\n  end\n\n  def stub_jwks\n    stub_request(:get, 'https://samples.auth0.com/.well-known/jwks.json')\n      .to_return(\n        headers: { 'Content-Type' => 'application/json' },\n        body: jwks.to_json,\n        status: 200\n      )\n  end\n\n  def stub_bad_jwks\n    stub_request(:get, 'https://samples.auth0.com/.well-known/jwks-bad.json')\n      .to_return(\n        status: 404\n      )\n  end\n\n  def stub_dummy_jwks\n    stub_request(:get, 'https://example.org/.well-known/jwks.json')\n      .to_return(\n        headers: { 'Content-Type' => 'application/json' },\n        body: rsa_token_jwks,\n        status: 200\n      )\n  end\nend\n"], "fixing_code": ["require 'base64'\nrequire 'uri'\nrequire 'json'\nrequire 'omniauth'\nrequire 'omniauth/auth0/errors'\n\nmodule OmniAuth\n  module Auth0\n    # JWT Validator class\n    class JWTValidator\n      attr_accessor :issuer, :domain\n\n      # Initializer\n      # @param options object\n      #   options.domain - Application domain.\n      #   options.issuer - Application issuer (optional).\n      #   options.client_id - Application Client ID.\n      #   options.client_secret - Application Client Secret.\n\n      def initialize(options, authorize_params = {})\n        @domain = uri_string(options.domain)\n\n        # Use custom issuer if provided, otherwise use domain\n        @issuer = @domain\n        @issuer = uri_string(options.issuer) if options.respond_to?(:issuer)\n\n        @client_id = options.client_id\n        @client_secret = options.client_secret\n      end\n\n      # Verify a token's signature. Only tokens signed with the RS256 or HS256 signatures are supported.\n      # @return array - The token's key and signing algorithm\n      def verify_signature(jwt)\n        head = token_head(jwt)\n\n        # Make sure the algorithm is supported and get the decode key.\n        if head[:alg] == 'RS256'\n          key, alg = [rs256_decode_key(head[:kid]), head[:alg]]\n        elsif head[:alg] == 'HS256'\n          key, alg = [@client_secret, head[:alg]]\n        else\n          raise OmniAuth::Auth0::TokenValidationError.new(\"Signature algorithm of #{head[:alg]} is not supported. Expected the ID token to be signed with RS256 or HS256\")\n        end\n\n        # Call decode to verify the signature\n        JWT.decode(jwt, key, true, decode_opts(alg))\n\n        return key, alg\n      end\n\n      # Verify a JWT.\n      # @param jwt string - JWT to verify.\n      # @param authorize_params hash - Authorization params to verify on the JWT\n      # @return hash - The verified token, if there were no exceptions.\n      def verify(jwt, authorize_params = {})\n        if !jwt\n          raise OmniAuth::Auth0::TokenValidationError.new('ID token is required but missing')\n        end\n\n        parts = jwt.split('.')\n        if parts.length != 3\n          raise OmniAuth::Auth0::TokenValidationError.new('ID token could not be decoded')\n        end\n\n        key, alg = verify_signature(jwt)\n        id_token, header = JWT.decode(jwt, key, false)\n        verify_claims(id_token, authorize_params)\n\n        return id_token\n      end\n\n      # Get the decoded head segment from a JWT.\n      # @return hash - The parsed head of the JWT passed, empty hash if not.\n      def token_head(jwt)\n        jwt_parts = jwt.split('.')\n        return {} if blank?(jwt_parts) || blank?(jwt_parts[0])\n\n        json_parse(Base64.decode64(jwt_parts[0]))\n      end\n\n      # Get the JWKS from the issuer and return a public key.\n      # @param x5c string - X.509 certificate chain from a JWKS.\n      # @return key - The X.509 certificate public key.\n      def jwks_public_cert(x5c)\n        x5c = Base64.decode64(x5c)\n\n        # https://docs.ruby-lang.org/en/2.4.0/OpenSSL/X509/Certificate.html\n        OpenSSL::X509::Certificate.new(x5c).public_key\n      end\n\n      # Return a specific key from a JWKS object.\n      # @param key string - Key to find in the JWKS.\n      # @param kid string - Key ID to identify the right JWK.\n      # @return nil|string\n      def jwks_key(key, kid)\n        return nil if blank?(jwks[:keys])\n\n        matching_jwk = jwks[:keys].find { |jwk| jwk[:kid] == kid }\n        matching_jwk[key] if matching_jwk\n      end\n\n      private\n      # Get the JWT decode options. We disable the claim checks since we perform our claim validation logic\n      # Docs: https://github.com/jwt/ruby-jwt\n      # @return hash\n      def decode_opts(alg)\n        {\n          algorithm: alg,\n          verify_expiration: false,\n          verify_iat: false,\n          verify_iss: false,\n          verify_aud: false,\n          verify_jti: false,\n          verify_subj: false,\n          verify_not_before: false\n        }\n      end\n\n      def rs256_decode_key(kid)\n        jwks_x5c = jwks_key(:x5c, kid)\n\n        if jwks_x5c.nil?\n          raise OmniAuth::Auth0::TokenValidationError.new(\"Could not find a public key for Key ID (kid) '#{kid}'\")\n        end\n\n        jwks_public_cert(jwks_x5c.first)\n      end\n\n      # Get a JWKS from the domain\n      # @return void\n      def jwks\n        jwks_uri = URI(@domain + '.well-known/jwks.json')\n        @jwks ||= json_parse(Net::HTTP.get(jwks_uri))\n      end\n\n      # Rails Active Support blank method.\n      # @param obj object - Object to check for blankness.\n      # @return boolean\n      def blank?(obj)\n        obj.respond_to?(:empty?) ? obj.empty? : !obj\n      end\n\n      # Parse JSON with symbolized names.\n      # @param json string - JSON to parse.\n      # @return hash\n      def json_parse(json)\n        JSON.parse(json, symbolize_names: true)\n      end\n\n      # Parse a URI into the desired string format\n      # @param uri - the URI to parse\n      # @return string\n      def uri_string(uri)\n        temp_domain = URI(uri)\n        temp_domain = URI(\"https://#{uri}\") unless temp_domain.scheme\n        \"#{temp_domain}/\"\n      end\n\n      def verify_claims(id_token, authorize_params)\n        leeway = authorize_params[:leeway] || 60\n        max_age = authorize_params[:max_age]\n        nonce = authorize_params[:nonce]\n\n        verify_iss(id_token)\n        verify_sub(id_token)\n        verify_aud(id_token)\n        verify_expiration(id_token, leeway)\n        verify_iat(id_token)\n        verify_nonce(id_token, nonce)\n        verify_azp(id_token)\n        verify_auth_time(id_token, leeway, max_age)\n      end\n\n      def verify_iss(id_token)\n        issuer = id_token['iss']\n        if !issuer\n          raise OmniAuth::Auth0::TokenValidationError.new(\"Issuer (iss) claim must be a string present in the ID token\")\n        elsif @issuer != issuer\n          raise OmniAuth::Auth0::TokenValidationError.new(\"Issuer (iss) claim mismatch in the ID token, expected (#{@issuer}), found (#{id_token['iss']})\")\n        end\n      end\n\n      def verify_sub(id_token)\n        subject = id_token['sub']\n        if !subject || !subject.is_a?(String) || subject.empty?\n          raise OmniAuth::Auth0::TokenValidationError.new('Subject (sub) claim must be a string present in the ID token')\n        end\n      end\n\n      def verify_aud(id_token)\n        audience = id_token['aud']\n        if !audience || !(audience.is_a?(String) || audience.is_a?(Array))\n          raise OmniAuth::Auth0::TokenValidationError.new(\"Audience (aud) claim must be a string or array of strings present in the ID token\")\n        elsif audience.is_a?(Array) && !audience.include?(@client_id)\n          raise OmniAuth::Auth0::TokenValidationError.new(\"Audience (aud) claim mismatch in the ID token; expected #{@client_id} but was not one of #{audience.join(', ')}\")\n        elsif audience.is_a?(String) && audience != @client_id\n          raise OmniAuth::Auth0::TokenValidationError.new(\"Audience (aud) claim mismatch in the ID token; expected #{@client_id} but found #{audience}\")\n        end\n      end\n\n      def verify_expiration(id_token, leeway)\n        expiration = id_token['exp']\n        if !expiration || !expiration.is_a?(Integer)\n          raise OmniAuth::Auth0::TokenValidationError.new(\"Expiration time (exp) claim must be a number present in the ID token\")\n        elsif expiration <= Time.now.to_i - leeway\n          raise OmniAuth::Auth0::TokenValidationError.new(\"Expiration time (exp) claim error in the ID token; current time (#{Time.now}) is after expiration time (#{Time.at(expiration + leeway)})\")\n        end\n      end\n\n      def verify_iat(id_token)\n        if !id_token['iat']\n          raise OmniAuth::Auth0::TokenValidationError.new(\"Issued At (iat) claim must be a number present in the ID token\")\n        end\n      end\n\n      def verify_nonce(id_token, nonce)\n        if nonce\n          received_nonce = id_token['nonce']\n          if !received_nonce\n            raise OmniAuth::Auth0::TokenValidationError.new(\"Nonce (nonce) claim must be a string present in the ID token\")\n          elsif nonce != received_nonce\n            raise OmniAuth::Auth0::TokenValidationError.new(\"Nonce (nonce) claim value mismatch in the ID token; expected (#{nonce}), found (#{received_nonce})\")\n          end\n        end\n      end\n\n      def verify_azp(id_token)\n        audience = id_token['aud']\n        if audience.is_a?(Array) && audience.length > 1\n          azp = id_token['azp']\n          if !azp || !azp.is_a?(String)\n            raise OmniAuth::Auth0::TokenValidationError.new(\"Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values\")\n          elsif azp != @client_id\n            raise OmniAuth::Auth0::TokenValidationError.new(\"Authorized Party (azp) claim mismatch in the ID token; expected (#{@client_id}), found (#{azp})\")\n          end\n        end\n      end\n\n      def verify_auth_time(id_token, leeway, max_age)\n        if max_age\n          auth_time = id_token['auth_time']\n          if !auth_time || !auth_time.is_a?(Integer)\n            raise OmniAuth::Auth0::TokenValidationError.new(\"Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified\")\n          elsif Time.now.to_i >  auth_time + max_age + leeway;\n            raise OmniAuth::Auth0::TokenValidationError.new(\"Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time (#{Time.now}) is after last auth time (#{Time.at(auth_time + max_age + leeway)})\")\n          end\n        end\n      end\n    end\n  end\nend\n", "require 'spec_helper'\nrequire 'json'\nrequire 'jwt'\n\ndescribe OmniAuth::Auth0::JWTValidator do\n  #\n  # Reused data\n  #\n\n  let(:client_id) { 'CLIENT_ID' }\n  let(:client_secret) { 'CLIENT_SECRET' }\n  let(:domain) { 'samples.auth0.com' }\n  let(:future_timecode) { 32_503_680_000 }\n  let(:past_timecode) { 303_912_000 }\n  let(:valid_jwks_kid) { 'NkJCQzIyQzRBMEU4NjhGNUU4MzU4RkY0M0ZDQzkwOUQ0Q0VGNUMwQg' }\n\n  let(:rsa_private_key) do\n    OpenSSL::PKey::RSA.generate 2048\n  end\n\n  let(:valid_jwks) do\n    {\n      keys: [\n        {\n          kid: valid_jwks_kid,\n          x5c: [Base64.encode64(make_cert(rsa_private_key).to_der)]\n        }\n      ]\n    }.to_json\n  end\n\n  let(:jwks) do\n    current_dir = File.dirname(__FILE__)\n    jwks_file = File.read(\"#{current_dir}/../../resources/jwks.json\")\n    JSON.parse(jwks_file, symbolize_names: true)\n  end\n\n  #\n  # Specs\n  #\n\n  describe 'JWT verifier default values' do\n    let(:jwt_validator) do\n      make_jwt_validator\n    end\n\n    it 'should have the correct issuer' do\n      expect(jwt_validator.issuer).to eq('https://samples.auth0.com/')\n    end\n  end\n\n  describe 'JWT verifier token_head' do\n    let(:jwt_validator) do\n      make_jwt_validator\n    end\n\n    it 'should parse the head of a valid JWT' do\n      expect(jwt_validator.token_head(make_hs256_token)[:alg]).to eq('HS256')\n    end\n\n    it 'should fail parsing the head of a blank JWT' do\n      expect(jwt_validator.token_head('')).to eq({})\n    end\n\n    it 'should fail parsing the head of an invalid JWT' do\n      expect(jwt_validator.token_head('.')).to eq({})\n    end\n\n    it 'should throw an exception for invalid JSON' do\n      expect do\n        jwt_validator.token_head('QXV0aDA=')\n      end.to raise_error(JSON::ParserError)\n    end\n  end\n\n  describe 'JWT verifier jwks_public_cert' do\n    let(:jwt_validator) do\n      make_jwt_validator\n    end\n\n    it 'should return a public_key' do\n      x5c = jwks[:keys].first[:x5c].first\n      public_cert = jwt_validator.jwks_public_cert(x5c)\n      expect(public_cert.instance_of?(OpenSSL::PKey::RSA)).to eq(true)\n    end\n\n    it 'should fail with an invalid x5c' do\n      expect do\n        jwt_validator.jwks_public_cert('QXV0aDA=')\n      end.to raise_error(OpenSSL::X509::CertificateError)\n    end\n  end\n\n  describe 'JWT verifier jwks key parsing' do\n    let(:jwt_validator) do\n      make_jwt_validator\n    end\n\n    before do\n      stub_complete_jwks\n    end\n\n    it 'should return a key' do\n      expect(jwt_validator.jwks_key(:alg, valid_jwks_kid)).to eq('RS256')\n    end\n\n    it 'should return an x5c key' do\n      expect(jwt_validator.jwks_key(:x5c, valid_jwks_kid).length).to eq(1)\n    end\n\n    it 'should return nil if there is not key' do\n      expect(jwt_validator.jwks_key(:auth0, valid_jwks_kid)).to eq(nil)\n    end\n\n    it 'should return nil if the key ID is invalid' do\n      expect(jwt_validator.jwks_key(:alg, \"#{valid_jwks_kid}_invalid\")).to eq(nil)\n    end\n  end\n\n  describe 'JWT verifier custom issuer' do\n    context 'same as domain' do\n      let(:jwt_validator) do\n        make_jwt_validator(opt_issuer: domain)\n      end\n\n      it 'should have the correct issuer' do\n        expect(jwt_validator.issuer).to eq('https://samples.auth0.com/')\n      end\n\n      it 'should have the correct domain' do\n        expect(jwt_validator.issuer).to eq('https://samples.auth0.com/')\n      end\n    end\n\n    context 'different from domain' do\n      let(:jwt_validator) do\n        make_jwt_validator(opt_issuer: 'different.auth0.com')\n      end\n\n      it 'should have the correct issuer' do\n        expect(jwt_validator.issuer).to eq('https://different.auth0.com/')\n      end\n\n      it 'should have the correct domain' do\n        expect(jwt_validator.domain).to eq('https://samples.auth0.com/')\n      end\n    end\n  end\n\n  describe 'JWT verifier verify' do\n    let(:jwt_validator) do\n      make_jwt_validator\n    end\n\n    before do\n      stub_complete_jwks\n      stub_expected_jwks\n    end\n\n    it 'should fail when JWT is nil' do\n      expect do\n        jwt_validator.verify(nil)\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"ID token is required but missing\"\n      }))\n    end\n\n    it 'should fail when JWT is not well-formed' do\n      expect do\n        jwt_validator.verify('abc.123')\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"ID token could not be decoded\"\n      }))\n    end\n\n    it 'should fail with missing issuer' do\n      expect do\n        jwt_validator.verify(make_hs256_token)\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Issuer (iss) claim must be a string present in the ID token\"\n      }))\n    end\n\n    it 'should fail with invalid issuer' do\n      payload = {\n        iss: 'https://auth0.com/'\n      }\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token)\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Issuer (iss) claim mismatch in the ID token, expected (https://samples.auth0.com/), found (https://auth0.com/)\"\n      }))\n    end\n\n    it 'should fail when subject is missing' do\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: ''\n      }\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token)\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Subject (sub) claim must be a string present in the ID token\"\n      }))\n    end\n\n    it 'should fail with missing audience' do\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub'\n      }\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token)\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Audience (aud) claim must be a string or array of strings present in the ID token\"\n      }))\n    end\n\n    it 'should fail with invalid audience' do\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: 'Auth0'\n      }\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token)\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Audience (aud) claim mismatch in the ID token; expected #{client_id} but found Auth0\"\n      }))\n    end\n\n    it 'should fail when missing expiration' do\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: client_id\n      }\n\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token)\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Expiration time (exp) claim must be a number present in the ID token\"\n      }))\n    end\n\n    it 'should fail when past expiration' do\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: client_id,\n        exp: past_timecode\n      }\n\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token)\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Expiration time (exp) claim error in the ID token; current time (#{Time.now}) is after expiration time (#{Time.at(past_timecode + 60)})\"\n      }))\n    end\n\n    it 'should pass when past expiration but within default leeway' do\n      exp = Time.now.to_i - 59\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: client_id,\n        exp: exp,\n        iat: past_timecode\n      }\n\n      token = make_hs256_token(payload)\n      id_token = jwt_validator.verify(token)\n      expect(id_token['exp']).to eq(exp)\n    end\n\n    it 'should fail when past expiration and outside default leeway' do\n      exp = Time.now.to_i - 61\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: client_id,\n        exp: exp,\n        iat: past_timecode\n      }\n\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token)\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Expiration time (exp) claim error in the ID token; current time (#{Time.now}) is after expiration time (#{Time.at(exp + 60)})\"\n      }))\n    end\n\n    it 'should fail when missing iat' do\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: client_id,\n        exp: future_timecode\n      }\n\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token)\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Issued At (iat) claim must be a number present in the ID token\"\n      }))\n    end\n\n    it 'should fail when authorize params has nonce but nonce is missing in the token' do\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: client_id,\n        exp: future_timecode,\n        iat: past_timecode\n      }\n\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token, { nonce: 'noncey' })\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Nonce (nonce) claim must be a string present in the ID token\"\n      }))\n    end\n\n    it 'should fail when authorize params has nonce but token nonce does not match' do\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: client_id,\n        exp: future_timecode,\n        iat: past_timecode,\n        nonce: 'mismatch'\n      }\n\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token, { nonce: 'noncey' })\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Nonce (nonce) claim value mismatch in the ID token; expected (noncey), found (mismatch)\"\n      }))\n    end\n    \n    it 'should fail when \u201caud\u201d is an array of strings and azp claim is not present' do\n      aud = [\n        client_id,\n        \"https://#{domain}/userinfo\"\n      ]\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: aud,\n        exp: future_timecode,\n        iat: past_timecode\n      }\n\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token)\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values\"\n      }))\n    end\n\n    it 'should fail when \"azp\" claim doesnt match the expected aud' do\n      aud = [\n        client_id,\n        \"https://#{domain}/userinfo\"\n      ]\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: aud,\n        exp: future_timecode,\n        iat: past_timecode,\n        azp: 'not_expected'\n      }\n\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token)\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Authorized Party (azp) claim mismatch in the ID token; expected (#{client_id}), found (not_expected)\"\n      }))\n    end\n\n    it 'should fail when \u201cmax_age\u201d sent on the authentication request and this claim is not present' do\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: client_id,\n        exp: future_timecode,\n        iat: past_timecode\n      }\n\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token, { max_age: 60 })\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified\"\n      }))\n    end\n\n    it 'should fail when \u201cmax_age\u201d sent on the authentication request and this claim added the \u201cmax_age\u201d value doesn\u2019t represent a date in the future' do\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: client_id,\n        exp: future_timecode,\n        iat: past_timecode,\n        auth_time: past_timecode\n      }\n\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token, { max_age: 60 })\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time (#{Time.now}) is after last auth time (#{Time.at(past_timecode + 60 + 60)})\"\n      }))\n    end\n\n    it 'should fail when \u201cmax_age\u201d sent on the authentication request and this claim added the \u201cmax_age\u201d value doesn\u2019t represent a date in the future, outside the default leeway' do\n      now = Time.now.to_i\n      auth_time = now - 121\n      max_age = 60\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: client_id,\n        exp: future_timecode,\n        iat: past_timecode,\n        auth_time: auth_time\n      }\n\n      token = make_hs256_token(payload)\n      expect do\n        jwt_validator.verify(token, { max_age: max_age })\n        # Time.at(auth_time + max_age + leeway\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time (#{Time.now}) is after last auth time (#{Time.at(auth_time + max_age + 60)})\"\n      }))\n    end\n\n    it 'should verify when \u201cmax_age\u201d sent on the authentication request and this claim added the \u201cmax_age\u201d value doesn\u2019t represent a date in the future, outside the default leeway' do\n      now = Time.now.to_i\n      auth_time = now - 119\n      max_age = 60\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: client_id,\n        exp: future_timecode,\n        iat: past_timecode,\n        auth_time: auth_time\n      }\n\n      token = make_hs256_token(payload)\n      id_token = jwt_validator.verify(token, { max_age: max_age })\n      expect(id_token['auth_time']).to eq(auth_time)\n    end\n\n    it 'should fail for RS256 token when kid is incorrect' do\n      domain = 'example.org'\n      sub = 'abc123'\n      payload = {\n        sub: sub,\n        exp: future_timecode,\n        iss: \"https://#{domain}/\",\n        iat: past_timecode,\n        aud: client_id\n      }\n      invalid_kid = 'invalid-kid'\n      token = make_rs256_token(payload, invalid_kid)\n      expect do\n        verified_token = make_jwt_validator(opt_domain: domain).verify(token)\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Could not find a public key for Key ID (kid) 'invalid-kid'\"\n      }))\n    end\n\n    it 'should fail when RS256 token has invalid signature' do\n      domain = 'example.org'\n      sub = 'abc123'\n      payload = {\n        sub: sub,\n        exp: future_timecode,\n        iss: \"https://#{domain}/\",\n        iat: past_timecode,\n        aud: client_id\n      }\n      token = make_rs256_token(payload) + 'bad'\n      expect do\n        verified_token = make_jwt_validator(opt_domain: domain).verify(token)\n      end.to raise_error(an_instance_of(JWT::VerificationError).and having_attributes({\n        message: \"Signature verification raised\"\n      }))\n    end\n\n    it 'should fail when algorithm is not RS256 or HS256' do\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'abc123',\n        aud: client_id,\n        exp: future_timecode,\n        iat: past_timecode\n      }\n      token = JWT.encode payload, 'secret', 'HS384'\n      expect do\n        jwt_validator.verify(token)\n      end.to raise_error(an_instance_of(OmniAuth::Auth0::TokenValidationError).and having_attributes({\n        message: \"Signature algorithm of HS384 is not supported. Expected the ID token to be signed with RS256 or HS256\"\n      }))\n    end\n\n    it 'should fail when HS256 token has invalid signature' do\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'abc123',\n        aud: client_id,\n        exp: future_timecode,\n        iat: past_timecode\n      }\n      token = make_hs256_token(payload, 'bad_secret')\n      expect do\n        # validator is configured to use \"CLIENT_SECRET\" by default\n        jwt_validator.verify(token)\n      end.to raise_error(an_instance_of(JWT::VerificationError))\n    end\n\n    it 'should verify a valid HS256 token with multiple audiences' do\n      audience = [\n        client_id,\n        \"https://#{domain}/userinfo\"\n      ]\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: 'sub',\n        aud: audience,\n        exp: future_timecode,\n        iat: past_timecode,\n        azp: client_id\n      }\n      token = make_hs256_token(payload)\n      id_token = jwt_validator.verify(token)\n      expect(id_token['aud']).to eq(audience)\n    end\n\n    it 'should verify a standard HS256 token' do\n      sub = 'abc123'\n      payload = {\n        iss: \"https://#{domain}/\",\n        sub: sub,\n        aud: client_id,\n        exp: future_timecode,\n        iat: past_timecode\n      }\n      token = make_hs256_token(payload)\n      verified_token = jwt_validator.verify(token)\n      expect(verified_token['sub']).to eq(sub)\n    end\n\n    it 'should verify a standard RS256 token' do\n      domain = 'example.org'\n      sub = 'abc123'\n      payload = {\n        sub: sub,\n        exp: future_timecode,\n        iss: \"https://#{domain}/\",\n        iat: past_timecode,\n        aud: client_id\n      }\n      token = make_rs256_token(payload)\n      verified_token = make_jwt_validator(opt_domain: domain).verify(token)\n      expect(verified_token['sub']).to eq(sub)\n    end\n\n    it 'should verify a HS256 JWT signature when calling verify signature directly' do\n      sub = 'abc123'\n        payload = {\n          iss: \"https://#{domain}/\",\n          sub: sub,\n          aud: client_id,\n          exp: future_timecode,\n          iat: past_timecode\n        }\n        token = make_hs256_token(payload)\n        verified_token_signature = jwt_validator.verify_signature(token)\n        expect(verified_token_signature[0]).to eq('CLIENT_SECRET')\n        expect(verified_token_signature[1]).to eq('HS256')\n    end\n\n    it 'should verify a RS256 JWT signature verify signature directly' do\n      domain = 'example.org'\n      sub = 'abc123'\n      payload = {\n        sub: sub,\n        exp: future_timecode,\n        iss: \"https://#{domain}/\",\n        iat: past_timecode,\n        aud: client_id\n      }\n      token = make_rs256_token(payload)\n      verified_token_signature = make_jwt_validator(opt_domain: domain).verify_signature(token)\n      expect(verified_token_signature.length).to be(2)\n      expect(verified_token_signature[0]).to be_a(OpenSSL::PKey::RSA)\n      expect(verified_token_signature[1]).to eq('RS256')\n    end\n  end\n\n  private\n\n  def make_jwt_validator(opt_domain: domain, opt_issuer: nil)\n    opts = OpenStruct.new(\n      domain: opt_domain,\n      client_id: client_id,\n      client_secret: client_secret\n    )\n    opts[:issuer] = opt_issuer unless opt_issuer.nil?\n\n    OmniAuth::Auth0::JWTValidator.new(opts)\n  end\n\n  def make_hs256_token(payload = nil, secret = nil)\n    payload = { sub: 'abc123' } if payload.nil?\n    secret = client_secret if secret.nil?\n    JWT.encode payload, secret, 'HS256'\n  end\n\n  def make_rs256_token(payload = nil, kid = nil)\n    payload = { sub: 'abc123' } if payload.nil?\n    kid = valid_jwks_kid if kid.nil?\n    JWT.encode payload, rsa_private_key, 'RS256', kid: kid\n  end\n\n  def make_cert(private_key)\n    cert = OpenSSL::X509::Certificate.new\n    cert.issuer = OpenSSL::X509::Name.parse('/C=BE/O=Auth0/OU=Auth0/CN=Auth0')\n    cert.subject = cert.issuer\n    cert.not_before = Time.now\n    cert.not_after = Time.now + 365 * 24 * 60 * 60\n    cert.public_key = private_key.public_key\n    cert.serial = 0x0\n    cert.version = 2\n\n    ef = OpenSSL::X509::ExtensionFactory.new\n    ef.subject_certificate = cert\n    ef.issuer_certificate = cert\n    cert.extensions = [\n      ef.create_extension('basicConstraints', 'CA:TRUE', true),\n      ef.create_extension('subjectKeyIdentifier', 'hash')\n    ]\n    cert.add_extension ef.create_extension(\n      'authorityKeyIdentifier',\n      'keyid:always,issuer:always'\n    )\n\n    cert.sign private_key, OpenSSL::Digest::SHA1.new\n  end\n\n  def stub_complete_jwks\n    stub_request(:get, 'https://samples.auth0.com/.well-known/jwks.json')\n      .to_return(\n        headers: { 'Content-Type' => 'application/json' },\n        body: jwks.to_json,\n        status: 200\n      )\n  end\n\n  def stub_expected_jwks\n    stub_request(:get, 'https://example.org/.well-known/jwks.json')\n      .to_return(\n        headers: { 'Content-Type' => 'application/json' },\n        body: valid_jwks,\n        status: 200\n      )\n  end\nend\n"], "filenames": ["lib/omniauth/auth0/jwt_validator.rb", "spec/omniauth/auth0/jwt_validator_spec.rb"], "buggy_code_start_loc": [30, 15], "buggy_code_end_loc": [101, 498], "fixing_code_start_loc": [31, 15], "fixing_code_end_loc": [124, 681], "type": "CWE-347", "message": "omniauth-auth0 (rubygems) versions >= 2.3.0 and < 2.4.1 improperly validate the JWT token signature when using the `jwt_validator.verify` method. Improper validation of the JWT token signature can allow an attacker to bypass authentication and authorization. You are affected by this vulnerability if all of the following conditions apply: 1. You are using `omniauth-auth0`. 2. You are using `JWTValidator.verify` method directly OR you are not authenticating using the SDK\u2019s default Authorization Code Flow. The issue is patched in version 2.4.1.", "other": {"cve": {"id": "CVE-2020-15240", "sourceIdentifier": "security-advisories@github.com", "published": "2020-10-21T18:15:12.813", "lastModified": "2021-11-18T16:21:41.270", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "omniauth-auth0 (rubygems) versions >= 2.3.0 and < 2.4.1 improperly validate the JWT token signature when using the `jwt_validator.verify` method. Improper validation of the JWT token signature can allow an attacker to bypass authentication and authorization. You are affected by this vulnerability if all of the following conditions apply: 1. You are using `omniauth-auth0`. 2. You are using `JWTValidator.verify` method directly OR you are not authenticating using the SDK\u2019s default Authorization Code Flow. The issue is patched in version 2.4.1."}, {"lang": "es", "value": "omniauth-auth0 (rubygems) versiones posteriores a 2.3.0 incluy\u00e9ndola y versiones anteriores a 2.4.1, comprueban inapropiadamente la firma del token de JWT cuando utiliza el m\u00e9todo \"jwt_validator.verify\".&#xa0;La comprobaci\u00f3n inapropiada de la firma del token de JWT puede permitir a un atacante omitir la autenticaci\u00f3n y la autorizaci\u00f3n.&#xa0;Estas afectado por esta vulnerabilidad si se cumplen todas las condiciones siguientes: 1. Est\u00e1 utilizando \"omniauth-auth0\".&#xa0;2. Est\u00e1 usando el m\u00e9todo \"JWTValidator.verify\" directamente O no est\u00e1 autentic\u00e1ndose usando el Authorization Code Flow predeterminado del SDK.&#xa0;El problema est\u00e1 parcheado en la versi\u00f3n 2.4.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-347"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-287"}, {"lang": "en", "value": "CWE-347"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:auth0:omniauth-auth0:*:*:*:*:*:ruby:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.4.1", "matchCriteriaId": "8273AC75-02BD-48A7-A599-36E93B268A73"}]}]}], "references": [{"url": "https://github.com/auth0/omniauth-auth0/commit/fd3a14f4ccdfbc515d1121d6378ff88bf55a7a7a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/auth0/omniauth-auth0/security/advisories/GHSA-58r4-h6v8-jcvm", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://rubygems.org/gems/omniauth-auth0", "source": "security-advisories@github.com", "tags": ["Product", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/auth0/omniauth-auth0/commit/fd3a14f4ccdfbc515d1121d6378ff88bf55a7a7a"}}