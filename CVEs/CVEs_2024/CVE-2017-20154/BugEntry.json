{"buggy_code": ["// Copyright (c) 2009-2010 Satoshi Nakamoto\n// Copyright (c) 2009-2012 The Bitcoin developers\n// Copyright (c) 2011-2012 Litecoin Developers\n// Copyright (c) 2013-2014 Phoenixcoin Developers\n// Distributed under the MIT/X11 software license, see the accompanying\n// file LICENCE or http://www.opensource.org/licenses/mit-license.php\n\n#include \"checkpoints.h\"\n#include \"db.h\"\n#include \"net.h\"\n#include \"init.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"checkpointsync.h\"\n#include <boost/algorithm/string/replace.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/filesystem/fstream.hpp>\n\nusing namespace std;\nusing namespace boost;\n\n//\n// Global state\n//\n\nCCriticalSection cs_setpwalletRegistered;\nset<CWallet*> setpwalletRegistered;\n\nCCriticalSection cs_main;\n\nCTxMemPool mempool;\nunsigned int nTransactionsUpdated = 0;\n\nint nBaseMaturity = BASE_MATURITY;\n\nmap<uint256, CBlockIndex*> mapBlockIndex;\nuint256 hashGenesisBlock(\"0xbe2f30f9e8db8f430056869c43503a992d232b28508e83eda101161a18cf7c73\");\n// The lowest possible difficulty which is also the starting difficulty (1 / 2^12)\nstatic CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\n/* The difficulty after switching to NeoScrypt (0.015625) */\nstatic CBigNum bnNeoScryptSwitch(~uint256(0) >> 26);\nCBlockIndex* pindexGenesisBlock = NULL;\nint nBestHeight = -1;\nCBigNum bnBestChainWork = 0;\nCBigNum bnBestInvalidWork = 0;\nuint256 hashBestChain = 0;\nCBlockIndex* pindexBest = NULL;\nint64 nTimeBestReceived = 0;\n\nCMedianFilter<int> cPeerBlockCounts(5, 0); // Amount of blocks that other nodes claim to have\n\nmap<uint256, CBlock*> mapOrphanBlocks;\nmultimap<uint256, CBlock*> mapOrphanBlocksByPrev;\n\nmap<uint256, CDataStream*> mapOrphanTransactions;\nmap<uint256, map<uint256, CDataStream*> > mapOrphanTransactionsByPrev;\n\n// Constant stuff for coinbase transactions we create:\nCScript COINBASE_FLAGS;\n\nconst string strMessageMagic = \"Phoenixcoin Signed Message:\\n\";\n\ndouble dHashesPerSec;\nint64 nHPSTimerStart;\n\n// Settings\nint64 nTransactionFee = 0;\nint64 nMinimumInputValue = CENT / 100;\n\n\n/* Old network magic number */\nuchar pchMessageStart[4]    = { 0xFB, 0xC0, 0xB6, 0xDB };\n/* New network magic number;\n * 0xFE and ASCII 'P' 'X' 'C' mapped into extended characters */\nuchar pchMessageStartNew[4] = { 0xFE, 0xD0, 0xD8, 0xC3 };\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// dispatching functions\n//\n\n// These functions dispatch to one or all registered wallets\n\n\nvoid RegisterWallet(CWallet* pwalletIn)\n{\n    {\n        LOCK(cs_setpwalletRegistered);\n        setpwalletRegistered.insert(pwalletIn);\n    }\n}\n\nvoid UnregisterWallet(CWallet* pwalletIn)\n{\n    {\n        LOCK(cs_setpwalletRegistered);\n        setpwalletRegistered.erase(pwalletIn);\n    }\n}\n\n// check whether the passed transaction is from us\nbool static IsFromMe(CTransaction& tx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        if (pwallet->IsFromMe(tx))\n            return true;\n    return false;\n}\n\n// get the wallet transaction with the given hash (if it exists)\nbool static GetTransaction(const uint256& hashTx, CWalletTx& wtx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        if (pwallet->GetTransaction(hashTx,wtx))\n            return true;\n    return false;\n}\n\n// erases transaction with the given hash from all wallets\nvoid static EraseFromWallets(uint256 hash)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->EraseFromWallet(hash);\n}\n\n// make sure all wallets know about the given transaction, in the given block\nvoid SyncWithWallets(const CTransaction& tx, const CBlock* pblock, bool fUpdate)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->AddToWalletIfInvolvingMe(tx, pblock, fUpdate);\n}\n\n// notify wallets about a new best chain\nvoid static SetBestChain(const CBlockLocator& loc)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->SetBestChain(loc);\n}\n\n// notify wallets about an updated transaction\nvoid static UpdatedTransaction(const uint256& hashTx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->UpdatedTransaction(hashTx);\n}\n\n// dump all wallets\nvoid static PrintWallets(const CBlock& block)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->PrintWallet(block);\n}\n\n// notify wallets about an incoming inventory (for request counts)\nvoid static Inventory(const uint256& hash)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->Inventory(hash);\n}\n\n// ask wallets to resend their transactions\nvoid ResendWalletTransactions(bool fForce)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->ResendWalletTransactions(fForce);\n}\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// mapOrphanTransactions\n//\n\nbool AddOrphanTx(const CDataStream& vMsg)\n{\n    CTransaction tx;\n    CDataStream(vMsg) >> tx;\n    uint256 hash = tx.GetHash();\n    if (mapOrphanTransactions.count(hash))\n        return false;\n\n    CDataStream* pvMsg = new CDataStream(vMsg);\n\n    // Ignore big transactions, to avoid a\n    // send-big-orphans memory exhaustion attack. If a peer has a legitimate\n    // large transaction with a missing parent then we assume\n    // it will rebroadcast it later, after the parent transaction(s)\n    // have been mined or received.\n    // 10,000 orphans, each of which is at most 5,000 bytes big is\n    // at most 500 megabytes of orphans:\n    if (pvMsg->size() > 5000)\n    {\n        printf(\"ignoring large orphan tx (size: %u, hash: %s)\\n\", pvMsg->size(), hash.ToString().substr(0,10).c_str());\n        delete pvMsg;\n        return false;\n    }\n\n    mapOrphanTransactions[hash] = pvMsg;\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n        mapOrphanTransactionsByPrev[txin.prevout.hash].insert(make_pair(hash, pvMsg));\n\n    printf(\"stored orphan tx %s (mapsz %u)\\n\", hash.ToString().substr(0,10).c_str(),\n        mapOrphanTransactions.size());\n    return true;\n}\n\nvoid static EraseOrphanTx(uint256 hash)\n{\n    if (!mapOrphanTransactions.count(hash))\n        return;\n    const CDataStream* pvMsg = mapOrphanTransactions[hash];\n    CTransaction tx;\n    CDataStream(*pvMsg) >> tx;\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n    {\n        mapOrphanTransactionsByPrev[txin.prevout.hash].erase(hash);\n        if (mapOrphanTransactionsByPrev[txin.prevout.hash].empty())\n            mapOrphanTransactionsByPrev.erase(txin.prevout.hash);\n    }\n    delete pvMsg;\n    mapOrphanTransactions.erase(hash);\n}\n\nunsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n{\n    unsigned int nEvicted = 0;\n    while (mapOrphanTransactions.size() > nMaxOrphans)\n    {\n        // Evict a random orphan:\n        uint256 randomhash = GetRandHash();\n        map<uint256, CDataStream*>::iterator it = mapOrphanTransactions.lower_bound(randomhash);\n        if (it == mapOrphanTransactions.end())\n            it = mapOrphanTransactions.begin();\n        EraseOrphanTx(it->first);\n        ++nEvicted;\n    }\n    return nEvicted;\n}\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CTransaction and CTxIndex\n//\n\nbool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet)\n{\n    SetNull();\n    if (!txdb.ReadTxIndex(prevout.hash, txindexRet))\n        return false;\n    if (!ReadFromDisk(txindexRet.pos))\n        return false;\n    if (prevout.n >= vout.size())\n    {\n        SetNull();\n        return false;\n    }\n    return true;\n}\n\nbool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout)\n{\n    CTxIndex txindex;\n    return ReadFromDisk(txdb, prevout, txindex);\n}\n\nbool CTransaction::ReadFromDisk(COutPoint prevout)\n{\n    CTxDB txdb(\"r\");\n    CTxIndex txindex;\n    return ReadFromDisk(txdb, prevout, txindex);\n}\n\nbool CTransaction::IsStandard() const\n{\n    if (nVersion > CTransaction::CURRENT_VERSION)\n        return false;\n\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        // Biggest 'standard' txin is a 3-signature 3-of-3 CHECKMULTISIG\n        // pay-to-script-hash, which is 3 ~80-byte signatures, 3\n        // ~65-byte public keys, plus a few script ops.\n        if (txin.scriptSig.size() > 500)\n            return false;\n        if (!txin.scriptSig.IsPushOnly())\n            return false;\n    }\n    BOOST_FOREACH(const CTxOut& txout, vout)\n        if (!::IsStandard(txout.scriptPubKey))\n            return false;\n    return true;\n}\n\n//\n// Check transaction inputs, and make sure any\n// pay-to-script-hash transactions are evaluating IsStandard scripts\n//\n// Why bother? To avoid denial-of-service attacks; an attacker\n// can submit a standard HASH... OP_EQUAL transaction,\n// which will get accepted into blocks. The redemption\n// script can be anything; an attacker could use a very\n// expensive-to-check-upon-redemption script like:\n//   DUP CHECKSIG DROP ... repeated 100 times... OP_1\n//\nbool CTransaction::AreInputsStandard(const MapPrevTx& mapInputs) const\n{\n    if (IsCoinBase())\n        return true; // Coinbases don't use vin normally\n\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        const CTxOut& prev = GetOutputFor(vin[i], mapInputs);\n\n        vector<vector<unsigned char> > vSolutions;\n        txnouttype whichType;\n        // get the scriptPubKey corresponding to this input:\n        const CScript& prevScript = prev.scriptPubKey;\n        if (!Solver(prevScript, whichType, vSolutions))\n            return false;\n        int nArgsExpected = ScriptSigArgsExpected(whichType, vSolutions);\n        if (nArgsExpected < 0)\n            return false;\n\n        // Transactions with extra stuff in their scriptSigs are\n        // non-standard. Note that this EvalScript() call will\n        // be quick, because if there are any operations\n        // beside \"push data\" in the scriptSig the\n        // IsStandard() call returns false\n        vector<vector<unsigned char> > stack;\n        if (!EvalScript(stack, vin[i].scriptSig, *this, i, 0))\n            return false;\n\n        if (whichType == TX_SCRIPTHASH)\n        {\n            if (stack.empty())\n                return false;\n            CScript subscript(stack.back().begin(), stack.back().end());\n            vector<vector<unsigned char> > vSolutions2;\n            txnouttype whichType2;\n            if (!Solver(subscript, whichType2, vSolutions2))\n                return false;\n            if (whichType2 == TX_SCRIPTHASH)\n                return false;\n\n            int tmpExpected;\n            tmpExpected = ScriptSigArgsExpected(whichType2, vSolutions2);\n            if (tmpExpected < 0)\n                return false;\n            nArgsExpected += tmpExpected;\n        }\n\n        if (stack.size() != (unsigned int)nArgsExpected)\n            return false;\n    }\n\n    return true;\n}\n\nunsigned int\nCTransaction::GetLegacySigOpCount() const\n{\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        nSigOps += txin.scriptSig.GetSigOpCount(false);\n    }\n    BOOST_FOREACH(const CTxOut& txout, vout)\n    {\n        nSigOps += txout.scriptPubKey.GetSigOpCount(false);\n    }\n    return nSigOps;\n}\n\n\nint CMerkleTx::SetMerkleBranch(const CBlock *pblock) {\n\n    CBlock blockTmp;\n    if(pblock == NULL) {\n        // Load the block this tx is in\n        CTxIndex txindex;\n        if(!CTxDB(\"r\").ReadTxIndex(GetHash(), txindex))\n          return(0);\n        if(!blockTmp.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos))\n          return(0);\n        pblock = &blockTmp;\n    }\n\n    // Update the tx's hashBlock\n    hashBlock = pblock->GetHash();\n\n    // Locate the transaction\n    for(nIndex = 0; nIndex < (int)pblock->vtx.size(); nIndex++)\n      if(pblock->vtx[nIndex] == *(CTransaction *)this) break;\n\n    if(nIndex == (int)pblock->vtx.size()) {\n        vMerkleBranch.clear();\n        nIndex = -1;\n        printf(\"ERROR: SetMerkleBranch() : couldn't find tx in block\\n\");\n        return(0);\n    }\n\n    // Fill in merkle branch\n    vMerkleBranch = pblock->GetMerkleBranch(nIndex);\n\n    // Is the tx in a block that's in the main chain\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n    if (mi == mapBlockIndex.end())\n        return 0;\n    CBlockIndex* pindex = (*mi).second;\n    if (!pindex || !pindex->IsInMainChain())\n        return 0;\n\n    return pindexBest->nHeight - pindex->nHeight + 1;\n}\n\n\n\n\n\n\n\nbool CTransaction::CheckTransaction() const\n{\n    // Basic checks that don't depend on any context\n    if (vin.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vin empty\"));\n    if (vout.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vout empty\"));\n    // Size limits\n    if (::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\"CTransaction::CheckTransaction() : size limits failed\"));\n\n    // Check for negative or overflow output values\n    int64 nValueOut = 0;\n    BOOST_FOREACH(const CTxOut& txout, vout)\n    {\n        if (txout.nValue < 0)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue negative\"));\n        if (txout.nValue > MAX_MONEY)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue too high\"));\n        nValueOut += txout.nValue;\n        if (!MoneyRange(nValueOut))\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout total out of range\"));\n    }\n\n    // Check for duplicate inputs\n    set<COutPoint> vInOutPoints;\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        if (vInOutPoints.count(txin.prevout))\n            return false;\n        vInOutPoints.insert(txin.prevout);\n    }\n\n    if (IsCoinBase())\n    {\n        if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : coinbase script size\"));\n    }\n    else\n    {\n        BOOST_FOREACH(const CTxIn& txin, vin)\n            if (txin.prevout.IsNull())\n                return DoS(10, error(\"CTransaction::CheckTransaction() : prevout is null\"));\n    }\n\n    return true;\n}\n\n\nbool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n                        bool* pfMissingInputs)\n{\n    if (pfMissingInputs)\n        *pfMissingInputs = false;\n\n    if (!tx.CheckTransaction())\n        return error(\"CTxMemPool::accept() : CheckTransaction failed\");\n\n    // Coinbase is only valid in a block, not as a loose transaction\n    if (tx.IsCoinBase())\n        return tx.DoS(100, error(\"CTxMemPool::accept() : coinbase as individual tx\"));\n\n    // To help v0.1.5 clients who would see it as a negative number\n    if ((int64)tx.nLockTime > std::numeric_limits<int>::max())\n        return error(\"CTxMemPool::accept() : not accepting nLockTime beyond 2038 yet\");\n\n    // Rather not work on nonstandard transactions (unless -testnet)\n    if (!fTestNet && !tx.IsStandard())\n        return error(\"CTxMemPool::accept() : nonstandard transaction type\");\n\n    // Do we already have it?\n    uint256 hash = tx.GetHash();\n    {\n        LOCK(cs);\n        if (mapTx.count(hash))\n            return false;\n    }\n    if (fCheckInputs)\n        if (txdb.ContainsTx(hash))\n            return false;\n\n    // Check for conflicts with in-memory transactions\n    CTransaction* ptxOld = NULL;\n    for (unsigned int i = 0; i < tx.vin.size(); i++)\n    {\n        COutPoint outpoint = tx.vin[i].prevout;\n        if (mapNextTx.count(outpoint))\n        {\n            // Disable replacement feature for now\n            return false;\n\n            // Allow replacing with a newer version of the same transaction\n            if (i != 0)\n                return false;\n            ptxOld = mapNextTx[outpoint].ptx;\n            if (ptxOld->IsFinal())\n                return false;\n            if (!tx.IsNewerThan(*ptxOld))\n                return false;\n            for (unsigned int i = 0; i < tx.vin.size(); i++)\n            {\n                COutPoint outpoint = tx.vin[i].prevout;\n                if (!mapNextTx.count(outpoint) || mapNextTx[outpoint].ptx != ptxOld)\n                    return false;\n            }\n            break;\n        }\n    }\n\n    if (fCheckInputs)\n    {\n        MapPrevTx mapInputs;\n        map<uint256, CTxIndex> mapUnused;\n        bool fInvalid = false;\n        if (!tx.FetchInputs(txdb, mapUnused, false, false, mapInputs, fInvalid))\n        {\n            if (fInvalid)\n                return error(\"CTxMemPool::accept() : FetchInputs found invalid tx %s\", hash.ToString().substr(0,10).c_str());\n            if (pfMissingInputs)\n                *pfMissingInputs = true;\n            return false;\n        }\n\n        // Check for non-standard pay-to-script-hash in inputs\n        if (!tx.AreInputsStandard(mapInputs) && !fTestNet)\n            return error(\"CTxMemPool::accept() : nonstandard transaction input\");\n\n        // Note: if you modify this code to accept non-standard transactions, then\n        // you should add code here to check that the transaction does a\n        // reasonable number of ECDSA signature verifications.\n\n        int64 nFees = tx.GetValueIn(mapInputs)-tx.GetValueOut();\n        unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n\n        // Don't accept it if it can't get into a block\n        if(nFees < tx.GetMinFee(nTxSize, true, GMF_RELAY))\n            return error(\"CTxMemPool::accept() : not enough fees\");\n\n        // Continuously rate-limit free transactions\n        // This mitigates 'penny-flooding' -- sending thousands of free transactions just to\n        // be annoying or make other's transactions take longer to confirm.\n        if (nFees < MIN_RELAY_TX_FEE)\n        {\n            static CCriticalSection cs;\n            static double dFreeCount;\n            static int64 nLastTime;\n            int64 nNow = GetTime();\n\n            {\n                LOCK(cs);\n                // Use an exponentially decaying ~10-minute window:\n                dFreeCount *= pow(1.0 - 1.0/600.0, (double)(nNow - nLastTime));\n                nLastTime = nNow;\n                // -limitfreerelay unit is thousand-bytes-per-minute\n                // At default rate it would take over a month to fill 1GB\n                if (dFreeCount > GetArg(\"-limitfreerelay\", 15)*10*1000 && !IsFromMe(tx))\n                    return error(\"CTxMemPool::accept() : free transaction rejected by rate limiter\");\n                if (fDebug)\n                    printf(\"Rate limit dFreeCount: %g => %g\\n\", dFreeCount, dFreeCount+nTxSize);\n                dFreeCount += nTxSize;\n            }\n        }\n\n        // Check against previous transactions\n        // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n        if (!tx.ConnectInputs(mapInputs, mapUnused, CDiskTxPos(1,1,1), pindexBest, false, false))\n        {\n            return error(\"CTxMemPool::accept() : ConnectInputs failed %s\", hash.ToString().substr(0,10).c_str());\n        }\n    }\n\n    // Store transaction in memory\n    {\n        LOCK(cs);\n        if (ptxOld)\n        {\n            printf(\"CTxMemPool::accept() : replacing tx %s with new version\\n\", ptxOld->GetHash().ToString().c_str());\n            remove(*ptxOld);\n        }\n        addUnchecked(hash, tx);\n    }\n\n    ///// are we sure this is ok when loading transactions or restoring block txes\n    // If updated, erase old tx from wallet\n    if (ptxOld)\n        EraseFromWallets(ptxOld->GetHash());\n\n    printf(\"CTxMemPool::accept() : accepted %s (poolsz %u)\\n\",\n           hash.ToString().substr(0,10).c_str(),\n           mapTx.size());\n    return true;\n}\n\nbool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMissingInputs)\n{\n    return mempool.accept(txdb, *this, fCheckInputs, pfMissingInputs);\n}\n\nbool CTxMemPool::addUnchecked(const uint256& hash, CTransaction &tx)\n{\n    // Add to memory pool without checking anything.  Don't call this directly,\n    // call CTxMemPool::accept to properly check the transaction first.\n    {\n        mapTx[hash] = tx;\n        for (unsigned int i = 0; i < tx.vin.size(); i++)\n            mapNextTx[tx.vin[i].prevout] = CInPoint(&mapTx[hash], i);\n        nTransactionsUpdated++;\n    }\n    return true;\n}\n\n/* Removes a transaction from the memory pool */\nbool CTxMemPool::remove(const CTransaction &tx, bool fRecursive) {\n\n    LOCK(cs);\n    uint256 hash = tx.GetHash();\n    if(mapTx.count(hash)) {\n        if(fRecursive) {\n            uint i;\n            for(i = 0; i < tx.vout.size(); i++) {\n                std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(COutPoint(hash, i));\n                if(it != mapNextTx.end())\n                  remove(*it->second.ptx, true);\n            }\n        }\n        BOOST_FOREACH(const CTxIn &txin, tx.vin)\n          mapNextTx.erase(txin.prevout);\n        mapTx.erase(hash);\n        nTransactionsUpdated++;\n    }\n    return(true);\n}\n\n/* Removes transactions from the memory pool which depend on inputs of this transaction */\nbool CTxMemPool::removeConflicts(const CTransaction &tx) {\n\n    LOCK(cs);\n    BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n        std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(txin.prevout);\n        if(it != mapNextTx.end()) {\n            const CTransaction &txConflict = *it->second.ptx;\n            if(txConflict != tx)\n              remove(txConflict, true);\n        }\n    }\n    return(true);\n}\n\nvoid CTxMemPool::queryHashes(std::vector<uint256>& vtxid)\n{\n    vtxid.clear();\n\n    LOCK(cs);\n    vtxid.reserve(mapTx.size());\n    for (map<uint256, CTransaction>::iterator mi = mapTx.begin(); mi != mapTx.end(); ++mi)\n        vtxid.push_back((*mi).first);\n}\n\n\n\n\n/* Returns a transaction depth in the main chain or\n *  0 = in the memory pool, not yet in the main chain\n * -1 = failed transaction */\nint CMerkleTx::GetDepthInMainChain(CBlockIndex* &pindexRet) const {\n    bool fTxMempool = mempool.exists(GetHash());\n\n    if((hashBlock == 0) || (nIndex == -1))\n      return(fTxMempool ? 0 : -1);\n\n    // Find the block it claims to be in\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n    if(mi == mapBlockIndex.end())\n      return(fTxMempool ? 0 : -1);\n\n    CBlockIndex* pindex = (*mi).second;\n    if(!pindex || !pindex->IsInMainChain())\n      return(fTxMempool ? 0 : -1);\n\n    // Make sure the merkle branch connects to this block\n    if(!fMerkleVerified) {\n        if(CBlock::CheckMerkleBranch(GetHash(), vMerkleBranch, nIndex) != pindex->hashMerkleRoot)\n          return(fTxMempool ? 0 : -1);\n        fMerkleVerified = true;\n    }\n\n    pindexRet = pindex;\n    return(pindexBest->nHeight - pindex->nHeight + 1);\n}\n\n\nint CMerkleTx::GetBlocksToMaturity() const\n{\n    if (!IsCoinBase())\n        return 0;\n    return max(0, (nBaseMaturity + BASE_MATURITY_OFFSET) - GetDepthInMainChain());\n}\n\n\nbool CMerkleTx::AcceptToMemoryPool(CTxDB &txdb, bool fCheckInputs) {\n\n    return(CTransaction::AcceptToMemoryPool(txdb, fCheckInputs));\n}\n\nbool CMerkleTx::AcceptToMemoryPool()\n{\n    CTxDB txdb(\"r\");\n    return AcceptToMemoryPool(txdb);\n}\n\n\n\nbool CWalletTx::AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs)\n{\n\n    {\n        LOCK(mempool.cs);\n        // Add previous supporting transactions first\n        BOOST_FOREACH(CMerkleTx& tx, vtxPrev)\n        {\n            if (!tx.IsCoinBase())\n            {\n                uint256 hash = tx.GetHash();\n                if (!mempool.exists(hash) && !txdb.ContainsTx(hash))\n                    tx.AcceptToMemoryPool(txdb, fCheckInputs);\n            }\n        }\n        return AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n    return false;\n}\n\nbool CWalletTx::AcceptWalletTransaction()\n{\n    CTxDB txdb(\"r\");\n    return AcceptWalletTransaction(txdb);\n}\n\n\n// Return transaction in tx, and if it was found inside a block, its hash is placed in hashBlock\nbool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock)\n{\n    {\n        LOCK(cs_main);\n        {\n            LOCK(mempool.cs);\n            if (mempool.exists(hash))\n            {\n                tx = mempool.lookup(hash);\n                return true;\n            }\n        }\n        CTxDB txdb(\"r\");\n        CTxIndex txindex;\n        if (tx.ReadFromDisk(txdb, COutPoint(hash, 0), txindex))\n        {\n            CBlock block;\n            if (block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n                hashBlock = block.GetHash();\n            return true;\n        }\n    }\n    return false;\n}\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CBlock and CBlockIndex\n//\n\nbool CBlock::ReadFromDisk(const CBlockIndex* pindex, bool fReadTransactions)\n{\n    if (!fReadTransactions)\n    {\n        *this = pindex->GetBlockHeader();\n        return true;\n    }\n    if (!ReadFromDisk(pindex->nFile, pindex->nBlockPos, fReadTransactions))\n        return false;\n    if (GetHash() != pindex->GetBlockHash())\n        return error(\"CBlock::ReadFromDisk() : GetHash() doesn't match index\");\n    return true;\n}\n\nuint256 static GetOrphanRoot(const CBlock* pblock)\n{\n    // Work back to the first block in the orphan chain\n    while (mapOrphanBlocks.count(pblock->hashPrevBlock))\n        pblock = mapOrphanBlocks[pblock->hashPrevBlock];\n    return pblock->GetHash();\n}\n\nint64 GetBlockValue(int nHeight, int64 nFees) {\n\n    int64 nSubsidy = 50 * COIN;\n    // 25 PXC per block between the 3rd and 4th hard fork\n    // 25 PXC per block before the 1st testnet hard fork\n    if(((nHeight >= nForkThree) && (nHeight < nForkFour)) || (fTestNet && (nHeight < nTestnetForkOne)))\n      nSubsidy = 25 * COIN;\n\n    // Block reward halves every 1M blocks (~2.85 years)\n    nSubsidy >>= (nHeight / 1000000);\n\n    return nSubsidy + nFees;\n}\n\nunsigned int static GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlock *pblock)\n{\n    unsigned int nProofOfWorkLimit = bnProofOfWorkLimit.GetCompact();\n\n    // The genesis block\n    if(pindexLast == NULL) return nProofOfWorkLimit;\n\n    // The next block\n    int nHeight = pindexLast->nHeight + 1;\n\n    // The initial settings\n    int nTargetSpacing  = nTargetSpacingZero;\n    int nTargetTimespan = nTargetTimespanZero;\n\n    // The 1st hard fork\n    if(nHeight >= nForkOne) {\n        nTargetSpacing  = nTargetSpacingOne;\n        nTargetTimespan = nTargetTimespanOne;\n    }\n\n    // The 2nd hard fork\n    if(nHeight >= nForkTwo) {\n        nTargetSpacing  = nTargetSpacingTwo;\n        nTargetTimespan = nTargetTimespanTwo;\n    }\n\n    // The 3nd hard fork; testnet starts here\n    if(nHeight >= nForkThree || fTestNet) {\n        nTargetSpacing  = nTargetSpacingThree;\n        nTargetTimespan = nTargetTimespanThree;\n    }\n\n    // The 4th hard fork; testnet hard forks as well\n    if((nHeight >= nForkFour) || (fTestNet && (nHeight >= nTestnetForkOne))) {\n        nTargetSpacing  = nTargetSpacingFour;\n        nTargetTimespan = nTargetTimespanFour;\n    }\n\n    /* The 5th hard fork and 2nd testnet hard fork */\n    if((nHeight >= nForkFive) || (fTestNet && (nHeight >= nTestnetForkTwo))) {\n        if(!fNeoScrypt) fNeoScrypt = true;\n        /* Difficulty reset after the switch */\n        if(nHeight == nForkFive)\n          return(bnNeoScryptSwitch.GetCompact());\n    }\n\n    // 2400, 600, 108, 126 and 20 blocks respectively\n    int nInterval = nTargetTimespan / nTargetSpacing;\n\n    // Just in case a hard fork isn't aligned properly\n    bool fHardFork = (nHeight == nForkOne) || (nHeight == nForkTwo) || (nHeight == nForkThree) || (nHeight == nForkFour) || (nHeight == nForkFive);\n    if(fTestNet) {\n        if((nHeight == nTestnetForkOne) || (nHeight == nTestnetForkTwo)) fHardFork = true;\n        else fHardFork = false;\n    }\n\n    // Difficulty rules for regular blocks\n    if((nHeight % nInterval != 0) && !(fHardFork)) {\n\n        // Testnet has a special difficulty rule\n        if(fTestNet) {\n            // Reset the difficulty if the difference in time stamps between\n            // this and the previous block is over 2x of nTargetSpacing\n            if(pblock->nTime > pindexLast->nTime + nTargetSpacing*2)\n              return nProofOfWorkLimit;\n            else {\n                // Return the difficulty of the last regular block\n                // with no minimal difficulty set as above\n                const CBlockIndex* pindex = pindexLast;\n                while(pindex->pprev && (pindex->nHeight % nInterval != 0) && (pindex->nBits == nProofOfWorkLimit))\n                  pindex = pindex->pprev;\n                return pindex->nBits;\n            }\n        }\n\n        return pindexLast->nBits;\n    }\n\n    // Basic 100 blocks averaging after the 4th livenet or 1st testnet hard fork\n    if((nHeight >= nForkFour) || (fTestNet && (nHeight >= nTestnetForkOne))) {\n        nInterval *= 5;\n        nTargetTimespan *= 5;\n    }\n\n    // The 1st retarget after the genesis\n    if(nInterval >= nHeight) nInterval = nHeight - 1;\n\n    // Go back by nInterval\n    const CBlockIndex* pindexFirst = pindexLast;\n    for(int i = 0; pindexFirst && (i < nInterval); i++)\n      pindexFirst = pindexFirst->pprev;\n    assert(pindexFirst);\n\n    int nActualTimespan = pindexLast->GetBlockTime() - pindexFirst->GetBlockTime();\n\n    printf(\"RETARGET: nActualTimespan = %d before bounds\\n\", nActualTimespan);\n\n    // Extended 500 blocks averaging after the 4th livenet or 1st testnet hard fork\n    if((nHeight >= nForkFour) || (fTestNet && (nHeight >= nTestnetForkOne))) {\n        nInterval *= 4;\n\n        for(int i = 0; pindexFirst && (i < nInterval); i++)\n          pindexFirst = pindexFirst->pprev;\n\n        int nActualTimespanExtended =\n          (pindexLast->GetBlockTime() - pindexFirst->GetBlockTime())/5;\n\n        // Average between the basic and extended windows\n        int nActualTimespanAvg = (nActualTimespan + nActualTimespanExtended)/2;\n\n        // Apply 0.1 damping\n        nActualTimespan = nActualTimespanAvg + 9*nTargetTimespan;\n        nActualTimespan /= 10;\n\n        printf(\"RETARGET: nActualTimespanExtended = %d (%d), nActualTimeSpanAvg = %d, nActualTimespan (damped) = %d\\n\",\n          nActualTimespanExtended, nActualTimespanExtended*5, nActualTimespanAvg, nActualTimespan);\n    }\n\n    // The initial settings (4.0 difficulty limiter)\n    int nActualTimespanMax = nTargetTimespan*4;\n    int nActualTimespanMin = nTargetTimespan/4;\n\n    // The 1st hard fork (1.8 difficulty limiter)\n    if(nHeight >= nForkOne) {\n        nActualTimespanMax = nTargetTimespan*99/55;\n        nActualTimespanMin = nTargetTimespan*55/99;\n    }\n\n    // The 3rd hard fork (1.09 difficulty limiter)\n    if(nHeight >= nForkThree) {\n        nActualTimespanMax = nTargetTimespan*109/100;\n        nActualTimespanMin = nTargetTimespan*100/109;\n    }\n\n    // The 4th livenet or 1st testnet hard fork (1.02 difficulty limiter)\n    if((nHeight >= nForkFour) || (fTestNet && (nHeight >= nTestnetForkOne))) {\n        nActualTimespanMax = nTargetTimespan*102/100;\n        nActualTimespanMin = nTargetTimespan*100/102;\n    }\n\n    /* The 5th livenet or 2nd testnet hard fork (+2% to -5% difficulty limiter) */\n    if((nHeight >= nForkFive) || (fTestNet && (nHeight >= nTestnetForkTwo))) {\n        nActualTimespanMax = nTargetTimespan * 105 / 100;\n    }\n\n    if(nActualTimespan < nActualTimespanMin) nActualTimespan = nActualTimespanMin;\n    if(nActualTimespan > nActualTimespanMax) nActualTimespan = nActualTimespanMax;\n\n    printf(\"RETARGET: nActualTimespan = %d after bounds\\n\", nActualTimespan);\n    printf(\"RETARGET: nTargetTimespan = %d, nTargetTimespan/nActualTimespan = %.4f\\n\",\n      nTargetTimespan, (float) nTargetTimespan/nActualTimespan);\n\n    // Retarget\n    CBigNum bnNew;\n    bnNew.SetCompact(pindexLast->nBits);\n    bnNew *= nActualTimespan;\n    bnNew /= nTargetTimespan;\n\n    if(bnNew > bnProofOfWorkLimit) bnNew = bnProofOfWorkLimit;\n\n    printf(\"GetNextWorkRequired RETARGET\\n\");\n    printf(\"Before: %08x  %s\\n\", pindexLast->nBits, CBigNum().SetCompact(pindexLast->nBits).getuint256().ToString().c_str());\n    printf(\"After:  %08x  %s\\n\", bnNew.GetCompact(), bnNew.getuint256().ToString().c_str());\n\n    return bnNew.GetCompact();\n}\n\nbool CheckProofOfWork(uint256 hash, unsigned int nBits)\n{\n    CBigNum bnTarget;\n    bnTarget.SetCompact(nBits);\n\n    // Check range\n    if (bnTarget <= 0 || bnTarget > bnProofOfWorkLimit)\n        return error(\"CheckProofOfWork() : nBits below minimum work\");\n\n    // Check proof of work matches claimed amount\n    if (hash > bnTarget.getuint256())\n        return error(\"CheckProofOfWork() : hash doesn't match nBits\");\n\n    return true;\n}\n\n// Return maximum amount of blocks that other nodes claim to have\nint GetNumBlocksOfPeers()\n{\n    return std::max(cPeerBlockCounts.median(), Checkpoints::GetTotalBlocksEstimate());\n}\n\nbool IsInitialBlockDownload()\n{\n    if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n        return true;\n    static int64 nLastUpdate;\n    static CBlockIndex* pindexLastBest;\n    if (pindexBest != pindexLastBest)\n    {\n        pindexLastBest = pindexBest;\n        nLastUpdate = GetTime();\n    }\n    return(((GetTime() - nLastUpdate) < 10) &&\n      (pindexBest->GetBlockTime() < (GetTime() - 4 * 60 * 60)));\n}\n\nvoid static InvalidChainFound(CBlockIndex* pindexNew)\n{\n    if (pindexNew->bnChainWork > bnBestInvalidWork)\n    {\n        bnBestInvalidWork = pindexNew->bnChainWork;\n        CTxDB().WriteBestInvalidWork(bnBestInvalidWork);\n        uiInterface.NotifyBlocksChanged();\n    }\n    printf(\"InvalidChainFound: invalid block=%s  height=%d  work=%s  date=%s\\n\",\n      pindexNew->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->nHeight,\n      pindexNew->bnChainWork.ToString().c_str(), DateTimeStrFormat(\"%x %H:%M:%S\",\n      pindexNew->GetBlockTime()).c_str());\n    printf(\"InvalidChainFound:  current best=%s  height=%d  work=%s  date=%s\\n\",\n      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight, bnBestChainWork.ToString().c_str(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n    if (pindexBest && bnBestInvalidWork > bnBestChainWork + pindexBest->GetBlockWork() * 6)\n        printf(\"InvalidChainFound: WARNING: Displayed transactions may not be correct!  You may need to upgrade, or other nodes may need to upgrade.\\n\");\n}\n\nvoid CBlock::UpdateTime(const CBlockIndex* pindexPrev)\n{\n    nTime = max((pindexPrev->GetMedianTimePast() + BLOCK_LIMITER_TIME + 1), GetAdjustedTime());\n\n    // Updating time can change work required on testnet:\n    if (fTestNet)\n        nBits = GetNextWorkRequired(pindexPrev, this);\n}\n\n\n\n\n\n\n\n\n\n\n\nbool CTransaction::DisconnectInputs(CTxDB& txdb)\n{\n    // Relinquish previous transactions' spent pointers\n    if (!IsCoinBase())\n    {\n        BOOST_FOREACH(const CTxIn& txin, vin)\n        {\n            COutPoint prevout = txin.prevout;\n\n            // Get prev txindex from disk\n            CTxIndex txindex;\n            if (!txdb.ReadTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : ReadTxIndex failed\");\n\n            if (prevout.n >= txindex.vSpent.size())\n                return error(\"DisconnectInputs() : prevout.n out of range\");\n\n            // Mark outpoint as not spent\n            txindex.vSpent[prevout.n].SetNull();\n\n            // Write back\n            if (!txdb.UpdateTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : UpdateTxIndex failed\");\n        }\n    }\n\n    // Remove transaction from index\n    // This can fail if a duplicate of this transaction was in a chain that got\n    // reorganized away. This is only possible if this transaction was completely\n    // spent, so erasing it would be a no-op anway.\n    txdb.EraseTxIndex(*this);\n\n    return true;\n}\n\n\nbool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTestPool,\n                               bool fBlock, bool fMiner, MapPrevTx& inputsRet, bool& fInvalid)\n{\n    // FetchInputs can return false either because we just haven't seen some inputs\n    // (in which case the transaction should be stored as an orphan)\n    // or because the transaction is malformed (in which case the transaction should\n    // be dropped).  If tx is definitely invalid, fInvalid will be set to true.\n    fInvalid = false;\n\n    if (IsCoinBase())\n        return true; // Coinbase transactions have no inputs to fetch.\n\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        COutPoint prevout = vin[i].prevout;\n        if (inputsRet.count(prevout.hash))\n            continue; // Got it already\n\n        // Read txindex\n        CTxIndex& txindex = inputsRet[prevout.hash].first;\n        bool fFound = true;\n        if ((fBlock || fMiner) && mapTestPool.count(prevout.hash))\n        {\n            // Get txindex from current proposed changes\n            txindex = mapTestPool.find(prevout.hash)->second;\n        }\n        else\n        {\n            // Read txindex from txdb\n            fFound = txdb.ReadTxIndex(prevout.hash, txindex);\n        }\n        if (!fFound && (fBlock || fMiner))\n            return fMiner ? false : error(\"FetchInputs() : %s prev Tx %s index entry not found\", \\\n              GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n\n        // Read txPrev\n        CTransaction& txPrev = inputsRet[prevout.hash].second;\n        if (!fFound || txindex.pos == CDiskTxPos(1,1,1))\n        {\n            // Get prev tx from single transactions in memory\n            {\n                LOCK(mempool.cs);\n                if (!mempool.exists(prevout.hash))\n                    return error(\"FetchInputs() : %s mempool Tx prev not found %s\", \\\n                      GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n                txPrev = mempool.lookup(prevout.hash);\n            }\n            if (!fFound)\n                txindex.vSpent.resize(txPrev.vout.size());\n        }\n        else\n        {\n            // Get prev tx from disk\n            if (!txPrev.ReadFromDisk(txindex.pos))\n                return error(\"FetchInputs() : %s ReadFromDisk prev Tx %s failed\", \\\n                  GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n        }\n\n        // Verify\n        if((prevout.n >= txPrev.vout.size()) || (prevout.n >= txindex.vSpent.size())) {\n            fInvalid = true;\n            return error(\"FetchInputs() : %s prevout.n %d exceeds %d or %d prev Tx %s\\n%s\", \\\n              GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), \\\n              prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str());\n        }\n\n        // Double spend check\n        if(!txindex.vSpent[prevout.n].IsNull())\n          return fMiner ? false : error(\"FetchInputs() : %s prev Tx already used at %s\", \\\n            GetHash().ToString().substr(0,10).c_str(), txindex.vSpent[prevout.n].ToString().c_str());\n    }\n\n    return true;\n}\n\nconst CTxOut& CTransaction::GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const\n{\n    MapPrevTx::const_iterator mi = inputs.find(input.prevout.hash);\n    if (mi == inputs.end())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.hash not found\");\n\n    const CTransaction& txPrev = (mi->second).second;\n    if (input.prevout.n >= txPrev.vout.size())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.n out of range\");\n\n    return txPrev.vout[input.prevout.n];\n}\n\nint64 CTransaction::GetValueIn(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    int64 nResult = 0;\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        nResult += GetOutputFor(vin[i], inputs).nValue;\n    }\n    return nResult;\n\n}\n\nunsigned int CTransaction::GetP2SHSigOpCount(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    unsigned int nSigOps = 0;\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        const CTxOut& prevout = GetOutputFor(vin[i], inputs);\n        if (prevout.scriptPubKey.IsPayToScriptHash())\n            nSigOps += prevout.scriptPubKey.GetSigOpCount(vin[i].scriptSig);\n    }\n    return nSigOps;\n}\n\nbool CTransaction::ConnectInputs(MapPrevTx inputs,\n                                 map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n                                 const CBlockIndex* pindexBlock, bool fBlock, bool fMiner, bool fStrictPayToScriptHash)\n{\n    // Take over previous transactions' spent pointers\n    // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain\n    // fMiner is true when called from the internal Phoenixcoin miner\n    // ... both are false when called from CTransaction::AcceptToMemoryPool\n    if (!IsCoinBase())\n    {\n        int64 nValueIn = 0;\n        int64 nFees = 0;\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            // prevout.n verification moved to FetchInputs()\n\n            // If prev is coinbase, check that it's matured\n            if (txPrev.IsCoinBase())\n                for (const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < nBaseMaturity; pindex = pindex->pprev)\n                    if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)\n                        return error(\"ConnectInputs() : tried to spend coinbase at depth %d\", pindexBlock->nHeight - pindex->nHeight);\n\n            // Check for negative or overflow input values\n            nValueIn += txPrev.vout[prevout.n].nValue;\n            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n\n        }\n        // The first loop above does all the inexpensive checks.\n        // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n        // Helps prevent CPU exhaustion attacks.\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            // Double spend check moved to FetchInputs()\n\n            // Skip ECDSA signature verification when connecting blocks (fBlock=true)\n            // before the last blockchain checkpoint. This is safe because block merkle hashes are\n            // still computed and checked, and any change will be caught at the next checkpoint.\n            if (!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate())))\n            {\n                // Verify signature\n                if (!VerifySignature(txPrev, *this, i, fStrictPayToScriptHash, 0))\n                {\n                    // only during transition phase for P2SH: do not invoke anti-DoS code for\n                    // potentially old clients relaying bad P2SH transactions\n                    if (fStrictPayToScriptHash && VerifySignature(txPrev, *this, i, false, 0))\n                        return error(\"ConnectInputs() : %s P2SH VerifySignature failed\", GetHash().ToString().substr(0,10).c_str());\n\n                    return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n                }\n            }\n\n            // Mark outpoints as spent\n            txindex.vSpent[prevout.n] = posThisTx;\n\n            // Write back\n            if (fBlock || fMiner)\n            {\n                mapTestPool[prevout.hash] = txindex;\n            }\n        }\n\n        if (nValueIn < GetValueOut())\n            return DoS(100, error(\"ConnectInputs() : %s value in < value out\", GetHash().ToString().substr(0,10).c_str()));\n\n        // Tally transaction fees\n        int64 nTxFee = nValueIn - GetValueOut();\n        if (nTxFee < 0)\n            return DoS(100, error(\"ConnectInputs() : %s nTxFee < 0\", GetHash().ToString().substr(0,10).c_str()));\n        nFees += nTxFee;\n        if (!MoneyRange(nFees))\n            return DoS(100, error(\"ConnectInputs() : nFees out of range\"));\n    }\n\n    return true;\n}\n\n\nbool CTransaction::ClientConnectInputs()\n{\n    if (IsCoinBase())\n        return false;\n\n    // Take over previous transactions' spent pointers\n    {\n        LOCK(mempool.cs);\n        int64 nValueIn = 0;\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            // Get prev tx from single transactions in memory\n            COutPoint prevout = vin[i].prevout;\n            if (!mempool.exists(prevout.hash))\n                return false;\n            CTransaction& txPrev = mempool.lookup(prevout.hash);\n\n            if (prevout.n >= txPrev.vout.size())\n                return false;\n\n            // Verify signature\n            if (!VerifySignature(txPrev, *this, i, true, 0))\n                return error(\"ConnectInputs() : VerifySignature failed\");\n\n            nValueIn += txPrev.vout[prevout.n].nValue;\n\n            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                return error(\"ClientConnectInputs() : txin values out of range\");\n        }\n        if (GetValueOut() > nValueIn)\n            return false;\n    }\n\n    return true;\n}\n\n\n\n\nbool CBlock::DisconnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n{\n    // Disconnect in reverse order\n    for (int i = vtx.size()-1; i >= 0; i--)\n        if (!vtx[i].DisconnectInputs(txdb))\n            return false;\n\n    // Update block index on disk without changing it in memory.\n    // The memory index structure will be changed after the db commits.\n    if (pindex->pprev)\n    {\n        CDiskBlockIndex blockindexPrev(pindex->pprev);\n        blockindexPrev.hashNext = 0;\n        if (!txdb.WriteBlockIndex(blockindexPrev))\n            return error(\"DisconnectBlock() : WriteBlockIndex failed\");\n    }\n\n    return true;\n}\n\nbool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n{\n    // Check it again in case a previous version let a bad block in\n    if (!CheckBlock())\n        return false;\n\n    // Do not allow blocks that contain transactions which 'overwrite' older transactions,\n    // unless those are already completely spent.\n    // If such overwrites are allowed, coinbases and transactions depending upon those\n    // can be duplicated to remove the ability to spend the first instance -- even after\n    // being sent to another address.\n    // See BIP30 and http://r6.ca/blog/20120206T005236Z.html for more information.\n    // This logic is not necessary for memory pool transactions, as AcceptToMemoryPool\n    // already refuses previously-known transaction id's entirely.\n    // This rule applies to all blocks whose timestamp is after October 1, 2012, 0:00 UTC.\n//    int64 nBIP30SwitchTime = 1349049600;\n//    bool fEnforceBIP30 = (pindex->nTime > nBIP30SwitchTime);\n    /* always active for Phoenixcoin */\n    bool fEnforceBIP30 = true;\n\n    // BIP16 didn't become active until October 1 2012\n//    int64 nBIP16SwitchTime = 1349049600;\n//    bool fStrictPayToScriptHash = (pindex->nTime >= nBIP16SwitchTime);\n    /* always active for Phoenixcoin */\n    bool fStrictPayToScriptHash = true;\n\n    //// issue here: it doesn't know the version\n    unsigned int nTxPos = pindex->nBlockPos + ::GetSerializeSize(CBlock(), SER_DISK, CLIENT_VERSION) - 1 + GetSizeOfCompactSize(vtx.size());\n\n    map<uint256, CTxIndex> mapQueuedChanges;\n    int64 nFees = 0;\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(CTransaction& tx, vtx)\n    {\n        uint256 hashTx = tx.GetHash();\n\n        if (fEnforceBIP30) {\n            CTxIndex txindexOld;\n            if (txdb.ReadTxIndex(hashTx, txindexOld)) {\n                BOOST_FOREACH(CDiskTxPos &pos, txindexOld.vSpent)\n                    if (pos.IsNull())\n                        return false;\n            }\n        }\n\n        nSigOps += tx.GetLegacySigOpCount();\n        if (nSigOps > MAX_BLOCK_SIGOPS)\n            return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n\n        CDiskTxPos posThisTx(pindex->nFile, pindex->nBlockPos, nTxPos);\n        nTxPos += ::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION);\n\n        MapPrevTx mapInputs;\n        if (!tx.IsCoinBase())\n        {\n            bool fInvalid;\n            if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs, fInvalid))\n                return false;\n\n            if (fStrictPayToScriptHash)\n            {\n                // Add in sigops done by pay-to-script-hash inputs;\n                // this is to prevent a \"rogue miner\" from creating\n                // an incredibly-expensive-to-validate block.\n                nSigOps += tx.GetP2SHSigOpCount(mapInputs);\n                if (nSigOps > MAX_BLOCK_SIGOPS)\n                    return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n            }\n\n            nFees += tx.GetValueIn(mapInputs)-tx.GetValueOut();\n\n            if (!tx.ConnectInputs(mapInputs, mapQueuedChanges, posThisTx, pindex, true, false, fStrictPayToScriptHash))\n                return false;\n        }\n\n        mapQueuedChanges[hashTx] = CTxIndex(posThisTx, tx.vout.size());\n    }\n\n    // Write queued txindex changes\n    for (map<uint256, CTxIndex>::iterator mi = mapQueuedChanges.begin(); mi != mapQueuedChanges.end(); ++mi)\n    {\n        if (!txdb.UpdateTxIndex((*mi).first, (*mi).second))\n            return error(\"ConnectBlock() : UpdateTxIndex failed\");\n    }\n\n    if (vtx[0].GetValueOut() > GetBlockValue(pindex->nHeight, nFees))\n        return false;\n\n    // No more blocks with bogus reward accepted\n    if((fTestNet || (pindex->nHeight >= nForkFour)) &&\n      (vtx[0].GetValueOut() != GetBlockValue(pindex->nHeight, nFees)))\n        return false;\n\n    // Update block index on disk without changing it in memory.\n    // The memory index structure will be changed after the db commits.\n    if (pindex->pprev)\n    {\n        CDiskBlockIndex blockindexPrev(pindex->pprev);\n        blockindexPrev.hashNext = pindex->GetBlockHash();\n        if (!txdb.WriteBlockIndex(blockindexPrev))\n            return error(\"ConnectBlock() : WriteBlockIndex failed\");\n    }\n\n    // Watch for transactions paying to me\n    BOOST_FOREACH(CTransaction& tx, vtx)\n        SyncWithWallets(tx, this, true);\n\n    return true;\n}\n\nbool static Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)\n{\n    printf(\"REORGANIZE\\n\");\n\n    // Find the fork\n    CBlockIndex* pfork = pindexBest;\n    CBlockIndex* plonger = pindexNew;\n    while (pfork != plonger)\n    {\n        while (plonger->nHeight > pfork->nHeight)\n            if (!(plonger = plonger->pprev))\n                return error(\"Reorganize() : plonger->pprev is null\");\n        if (pfork == plonger)\n            break;\n        if (!(pfork = pfork->pprev))\n            return error(\"Reorganize() : pfork->pprev is null\");\n    }\n\n    // List of what to disconnect\n    vector<CBlockIndex*> vDisconnect;\n    for (CBlockIndex* pindex = pindexBest; pindex != pfork; pindex = pindex->pprev)\n        vDisconnect.push_back(pindex);\n\n    // List of what to connect\n    vector<CBlockIndex*> vConnect;\n    for (CBlockIndex* pindex = pindexNew; pindex != pfork; pindex = pindex->pprev)\n        vConnect.push_back(pindex);\n    reverse(vConnect.begin(), vConnect.end());\n\n    printf(\"REORGANIZE: Disconnect %i blocks; %s..%s\\n\", vDisconnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexBest->GetBlockHash().ToString().substr(0,20).c_str());\n    printf(\"REORGANIZE: Connect %i blocks; %s..%s\\n\", vConnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->GetBlockHash().ToString().substr(0,20).c_str());\n\n    // Disconnect shorter branch\n    vector<CTransaction> vResurrect;\n    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n    {\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"Reorganize() : ReadFromDisk for disconnect failed\");\n        if (!block.DisconnectBlock(txdb, pindex))\n            return error(\"Reorganize() : DisconnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n\n        // Queue memory transactions to resurrect\n        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n            if (!tx.IsCoinBase())\n                vResurrect.push_back(tx);\n    }\n\n    // Connect longer branch\n    vector<CTransaction> vDelete;\n    for (unsigned int i = 0; i < vConnect.size(); i++)\n    {\n        CBlockIndex* pindex = vConnect[i];\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"Reorganize() : ReadFromDisk for connect failed\");\n        if (!block.ConnectBlock(txdb, pindex))\n        {\n            // Invalid block\n            return error(\"Reorganize() : ConnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n        }\n\n        // Queue memory transactions to delete\n        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n            vDelete.push_back(tx);\n    }\n    if (!txdb.WriteHashBestChain(pindexNew->GetBlockHash()))\n        return error(\"Reorganize() : WriteHashBestChain failed\");\n\n    // Make sure it's successfully written to disk before changing memory structure\n    if (!txdb.TxnCommit())\n        return error(\"Reorganize() : TxnCommit failed\");\n\n    // Disconnect shorter branch\n    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = NULL;\n\n    // Connect longer branch\n    BOOST_FOREACH(CBlockIndex* pindex, vConnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = pindex;\n\n    // Resurrect memory transactions that were in the disconnected branch\n    BOOST_FOREACH(CTransaction& tx, vResurrect)\n        tx.AcceptToMemoryPool(txdb, false);\n\n    // Delete redundant memory transactions that are in the connected branch\n    BOOST_FOREACH(CTransaction &tx, vDelete) {\n        mempool.remove(tx);\n        mempool.removeConflicts(tx);\n    }\n\n    printf(\"REORGANIZE: done\\n\");\n\n    return true;\n}\n\n\n// Called from inside SetBestChain: attaches a block to the new best chain being built\nbool CBlock::SetBestChainInner(CTxDB& txdb, CBlockIndex *pindexNew)\n{\n    uint256 hash = GetHash();\n\n    // Adding to current best branch\n    if (!ConnectBlock(txdb, pindexNew) || !txdb.WriteHashBestChain(hash))\n    {\n        txdb.TxnAbort();\n        InvalidChainFound(pindexNew);\n        return false;\n    }\n    if (!txdb.TxnCommit())\n        return error(\"SetBestChain() : TxnCommit failed\");\n\n    // Add to current best branch\n    pindexNew->pprev->pnext = pindexNew;\n\n    // Delete redundant memory transactions\n    BOOST_FOREACH(CTransaction& tx, vtx)\n        mempool.remove(tx);\n\n    return true;\n}\n\nbool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n{\n    uint256 hash = GetHash();\n\n    if (!txdb.TxnBegin())\n        return error(\"SetBestChain() : TxnBegin failed\");\n\n    if (pindexGenesisBlock == NULL && hash == hashGenesisBlock)\n    {\n        txdb.WriteHashBestChain(hash);\n        if (!txdb.TxnCommit())\n            return error(\"SetBestChain() : TxnCommit failed\");\n        pindexGenesisBlock = pindexNew;\n    }\n    else if (hashPrevBlock == hashBestChain)\n    {\n        if (!SetBestChainInner(txdb, pindexNew))\n            return error(\"SetBestChain() : SetBestChainInner failed\");\n    }\n    else\n    {\n        // the first block in the new chain that will cause it to become the new best chain\n        CBlockIndex *pindexIntermediate = pindexNew;\n\n        // list of blocks that need to be connected afterwards\n        std::vector<CBlockIndex*> vpindexSecondary;\n\n        // Reorganize is costly in terms of db load, as it works in a single db transaction.\n        // Try to limit how much needs to be done inside\n        while (pindexIntermediate->pprev && pindexIntermediate->pprev->bnChainWork > pindexBest->bnChainWork)\n        {\n            vpindexSecondary.push_back(pindexIntermediate);\n            pindexIntermediate = pindexIntermediate->pprev;\n        }\n\n        if (!vpindexSecondary.empty())\n            printf(\"Postponing %i reconnects\\n\", vpindexSecondary.size());\n\n        // Switch to new best branch\n        if (!Reorganize(txdb, pindexIntermediate))\n        {\n            txdb.TxnAbort();\n            InvalidChainFound(pindexNew);\n            return error(\"SetBestChain() : Reorganize failed\");\n        }\n\n        // Connect futher blocks\n        BOOST_REVERSE_FOREACH(CBlockIndex *pindex, vpindexSecondary)\n        {\n            CBlock block;\n            if (!block.ReadFromDisk(pindex))\n            {\n                printf(\"SetBestChain() : ReadFromDisk failed\\n\");\n                break;\n            }\n            if (!txdb.TxnBegin()) {\n                printf(\"SetBestChain() : TxnBegin 2 failed\\n\");\n                break;\n            }\n            // errors now are not fatal, we still did a reorganisation to a new chain in a valid way\n            if (!block.SetBestChainInner(txdb, pindex))\n                break;\n        }\n    }\n\n    // Update best block in wallet (so we can detect restored wallets)\n    bool fIsInitialDownload = IsInitialBlockDownload();\n    if (!fIsInitialDownload)\n    {\n        const CBlockLocator locator(pindexNew);\n        ::SetBestChain(locator);\n    }\n\n    // New best block\n    hashBestChain = hash;\n    pindexBest = pindexNew;\n    nBestHeight = pindexBest->nHeight;\n    bnBestChainWork = pindexNew->bnChainWork;\n    nTimeBestReceived = GetTime();\n    nTransactionsUpdated++;\n    printf(\"SetBestChain: new best=%s  height=%d  work=%s  date=%s\\n\",\n      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight, bnBestChainWork.ToString().c_str(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n\n    // Advanced checkpointing mode control\n    if (!IsSyncCheckpointEnforced())\n    {\n        if (pindexBest->pprev && !CheckSyncCheckpoint(pindexBest->GetBlockHash(), pindexBest->pprev))\n            strCheckpointWarning = _(\"Warning: advanced checkpoint on a block chain fork, report to the developers\");\n        else\n            strCheckpointWarning = \"\";\n    }\n\n    std::string strCmd = GetArg(\"-blocknotify\", \"\");\n\n    if (!fIsInitialDownload && !strCmd.empty())\n    {\n        boost::replace_all(strCmd, \"%s\", hashBestChain.GetHex());\n        boost::thread t(runCommand, strCmd); // thread runs free\n    }\n\n    return true;\n}\n\n\nbool CBlock::AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos)\n{\n    // Check for duplicate\n    uint256 hash = GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"AddToBlockIndex() : %s already exists\", hash.ToString().substr(0,20).c_str());\n\n    // Construct new block index object\n    CBlockIndex* pindexNew = new CBlockIndex(nFile, nBlockPos, *this);\n    if (!pindexNew)\n        return error(\"AddToBlockIndex() : new CBlockIndex failed\");\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n    pindexNew->phashBlock = &((*mi).first);\n    map<uint256, CBlockIndex*>::iterator miPrev = mapBlockIndex.find(hashPrevBlock);\n    if (miPrev != mapBlockIndex.end())\n    {\n        pindexNew->pprev = (*miPrev).second;\n        pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n    }\n    pindexNew->bnChainWork = (pindexNew->pprev ? pindexNew->pprev->bnChainWork : 0) + pindexNew->GetBlockWork();\n\n    CTxDB txdb;\n    if (!txdb.TxnBegin())\n        return false;\n    txdb.WriteBlockIndex(CDiskBlockIndex(pindexNew));\n    if (!txdb.TxnCommit())\n        return false;\n\n    // New best\n    if (pindexNew->bnChainWork > bnBestChainWork)\n        if (!SetBestChain(txdb, pindexNew))\n            return false;\n\n    txdb.Close();\n\n    if (pindexNew == pindexBest)\n    {\n        // Notify UI to display prev block's coinbase if it was ours\n        static uint256 hashPrevBestCoinBase;\n        UpdatedTransaction(hashPrevBestCoinBase);\n        hashPrevBestCoinBase = vtx[0].GetHash();\n    }\n\n    uiInterface.NotifyBlocksChanged();\n    return true;\n}\n\n\n\n\nbool CBlock::CheckBlock() const\n{\n    // These are checks that are independent of context\n    // that can be verified before saving an orphan block.\n\n    // Size limits\n    if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\"CheckBlock() : size limits failed\"));\n\n    /* Verify proof-of-work */\n    if(!CheckProofOfWork(GetPoWHash(), nBits))\n      return(DoS(50, error(\"CheckBlock() : proof-of-work verification failed\")));\n\n    // First transaction must be coinbase, the rest must not be\n    if (vtx.empty() || !vtx[0].IsCoinBase())\n        return DoS(100, error(\"CheckBlock() : the 1st transaction isn't the coin base\"));\n    for (unsigned int i = 1; i < vtx.size(); i++)\n        if (vtx[i].IsCoinBase())\n            return DoS(100, error(\"CheckBlock() : more than one coin base\"));\n\n    // Check transactions\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n        if (!tx.CheckTransaction())\n            return DoS(tx.nDoS, error(\"CheckBlock() : CheckTransaction failed\"));\n\n    // Check for duplicate txids. This is caught by ConnectInputs(),\n    // but catching it earlier avoids a potential DoS attack:\n    set<uint256> uniqueTx;\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        uniqueTx.insert(tx.GetHash());\n    }\n    if (uniqueTx.size() != vtx.size())\n        return DoS(100, error(\"CheckBlock() : duplicate transaction\"));\n\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        nSigOps += tx.GetLegacySigOpCount();\n    }\n    if (nSigOps > MAX_BLOCK_SIGOPS)\n        return DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"));\n\n    // Check merkleroot\n    if (hashMerkleRoot != BuildMerkleTree())\n        return DoS(100, error(\"CheckBlock() : hashMerkleRoot mismatch\"));\n\n    return true;\n}\n\nbool CBlock::AcceptBlock()\n{\n    // Check for duplicate\n    uint256 hash = GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"AcceptBlock() : block already in mapBlockIndex\");\n\n    // Get the previous block index\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashPrevBlock);\n    if (mi == mapBlockIndex.end())\n        return DoS(10, error(\"AcceptBlock() : cannot locate the previous block\"));\n    CBlockIndex* pindexPrev = (*mi).second;\n    int nHeight = pindexPrev->nHeight+1;\n\n    /* Don't accept v1 blocks after this point */\n    if((fTestNet && (nTime > nTestnetSwitchV2)) || (!fTestNet && (nTime > nSwitchV2))) {\n        CScript expect = CScript() << nHeight;\n        if(!std::equal(expect.begin(), expect.end(), vtx[0].vin[0].scriptSig.begin()))\n          return(DoS(100, error(\"AcceptBlock() : incorrect block height in coin base\")));\n    }\n\n    /* Don't accept blocks with bogus nVersion numbers after this point */\n    if((nHeight >= nForkFive) || (fTestNet && (nHeight >= nTestnetForkTwo))) {\n        if(nVersion != 2)\n          return(DoS(100, error(\"AcceptBlock() : incorrect block version\")));\n    }\n\n    // Check for proof of work\n    if (nBits != GetNextWorkRequired(pindexPrev, this))\n        return DoS(100, error(\"AcceptBlock() : incorrect proof of work for block %d\", nHeight));\n\n    uint nOurTime   = (uint)GetAdjustedTime();\n\n    // Check for time stamp (past limit #1)\n    if(nTime <= (uint)pindexPrev->GetMedianTimePast())\n      return(DoS(20, error(\"AcceptBlock() : block %s height %d has a time stamp behind the median\",\n        hash.ToString().substr(0,20).c_str(), nHeight)));\n\n    // Soft fork 1: further restrictions\n    if((fTestNet && (nHeight >= nTestnetSoftForkOne)) || (nHeight >= nSoftForkOne)) {\n\n        if(nTime > (nOurTime + 10 * 60))\n          return(DoS(5, error(\"AcceptBlock() : block %s height %d has a time stamp too far in the future\",\n            hash.ToString().substr(0,20).c_str(), nHeight)));\n\n        if(nTime <= (pindexPrev->GetMedianTimePast() + BLOCK_LIMITER_TIME))\n          return(DoS(5, error(\"AcceptBlock() : block %s height %d rejected by the block limiter\",\n            hash.ToString().substr(0,20).c_str(), nHeight)));\n\n        if(nTime <= (pindexPrev->GetBlockTime() - 10 * 60))\n          return(DoS(20, error(\"AcceptBlock() : block %s height %d has a time stamp too far in the past\",\n            hash.ToString().substr(0,20).c_str(), nHeight)));\n\n    }\n\n    /* Soft fork 2 */\n    if(!IsInitialBlockDownload() &&\n      ((fTestNet && (nHeight >= nTestnetSoftForkTwo)) || (nHeight >= nSoftForkTwo))) {\n\n        /* Check for time stamp (future limit) */\n        if(nTime > (nOurTime + 5 * 60))\n          return(DoS(5, error(\"AcceptBlock() [Soft Fork 2] : block %s height %d has a time stamp too far in the future\",\n            hash.ToString().substr(0,20).c_str(), nHeight)));\n\n        /* Future travel detector for the block limiter */\n        if((nTime > (nOurTime + 60)) &&\n          ((pindexPrev->GetAverageTimePast(5, 45) + BLOCK_LIMITER_TIME) > nOurTime))\n          return(DoS(5, error(\"AcceptBlock() : block %s height %d rejected by the future travel detector\",\n            hash.ToString().substr(0,20).c_str(), nHeight)));\n\n    }\n\n    // Check that all transactions are finalized\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n        if (!tx.IsFinal(nHeight, GetBlockTime()))\n            return DoS(10, error(\"AcceptBlock() : block %d contains a non-final transaction\", nHeight));\n\n    // Check if the block chain matches the known block chain up to a checkpoint\n    if (!Checkpoints::CheckBlock(nHeight, hash))\n        return DoS(100, error(\"AcceptBlock() : block %d is rejected by a regular checkpoint\", nHeight));\n\n    /* Check against advanced checkpoints */\n    if(IsSyncCheckpointEnforced() &&\n      !CheckSyncCheckpoint(hash, pindexPrev) &&\n      !IsInitialBlockDownload())\n      return(error(\"AcceptBlock() : block %s height %d rejected by the ACP\",\n        hash.ToString().substr(0,20).c_str(), nHeight));\n\n    // Write block to history file\n    if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION)))\n        return error(\"AcceptBlock() : out of disk space\");\n    unsigned int nFile = -1;\n    unsigned int nBlockPos = 0;\n    if (!WriteToDisk(nFile, nBlockPos))\n        return error(\"AcceptBlock() : WriteToDisk failed\");\n    if (!AddToBlockIndex(nFile, nBlockPos))\n        return error(\"AcceptBlock() : AddToBlockIndex failed\");\n\n    // Relay inventory, but don't relay old inventory during initial block download\n    int nBlockEstimate = Checkpoints::GetTotalBlocksEstimate();\n    if (hashBestChain == hash)\n    {\n        LOCK(cs_vNodes);\n        BOOST_FOREACH(CNode* pnode, vNodes)\n            if (nBestHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))\n                pnode->PushInventory(CInv(MSG_BLOCK, hash));\n    }\n\n    /* Process an advanced checkpoint pending */\n    if(!IsInitialBlockDownload()) AcceptPendingSyncCheckpoint();\n\n    return true;\n}\n\nbool ProcessBlock(CNode* pfrom, CBlock* pblock)\n{\n    // Check for duplicate\n    uint256 hash = pblock->GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n    if (mapOrphanBlocks.count(hash))\n        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n\n    /* Ask for a pending advanced checkpoint if any */\n    if(!IsInitialBlockDownload()) AskForPendingSyncCheckpoint(pfrom);\n\n    /* Basic block integrity checks */\n    if(!pblock->CheckBlock())\n      return(error(\"ProcessBlock() : CheckBlock FAILED\"));\n\n    CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(mapBlockIndex);\n    if (pcheckpoint && pblock->hashPrevBlock != hashBestChain)\n    {\n\n        if((pblock->GetBlockTime() - pcheckpoint->nTime) < 0) {\n            if(pfrom) pfrom->Misbehaving(100);\n            return error(\"ProcessBlock() : block has a time stamp of %u before the last checkpoint of %u\", pblock->GetBlockTime(), pcheckpoint->nTime);\n        }\n\n        // Here was some code to verify block difficulty upon block and checkpoint\n        // time difference which had never worked well in general and was broken\n        // across the hard forks for Phoenixcoin in particular\n\n    }\n\n    // If don't already have its previous block, shunt it off to holding area until we get it\n    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n    {\n        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n        CBlock* pblock2 = new CBlock(*pblock);\n        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n\n        // Ask this guy to fill in what we're missing\n        if (pfrom)\n            pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));\n        return true;\n    }\n\n    // Store to disk\n    if (!pblock->AcceptBlock())\n        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n\n    // Recursively process any orphan blocks that depended on this one\n    vector<uint256> vWorkQueue;\n    vWorkQueue.push_back(hash);\n    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n    {\n        uint256 hashPrev = vWorkQueue[i];\n        for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n             mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n             ++mi)\n        {\n            CBlock* pblockOrphan = (*mi).second;\n            if (pblockOrphan->AcceptBlock())\n                vWorkQueue.push_back(pblockOrphan->GetHash());\n            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n            delete pblockOrphan;\n        }\n        mapOrphanBlocksByPrev.erase(hashPrev);\n    }\n\n    printf(\"ProcessBlock: ACCEPTED\\n\");\n\n    /* Checkpoint master sends a new advanced checkpoint\n     * according to the depth specified by -checkpointdepth */\n    if(pfrom && !CSyncCheckpoint::strMasterPrivKey.empty())\n      SendSyncCheckpoint(AutoSelectSyncCheckpoint());\n\n    return true;\n}\n\n\n\n\n\n\n\n\nbool CheckDiskSpace(uint64 nAdditionalBytes)\n{\n    uint64 nFreeBytesAvailable = filesystem::space(GetDataDir()).available;\n\n    // Check for nMinDiskSpace bytes (currently 50MB)\n    if (nFreeBytesAvailable < nMinDiskSpace + nAdditionalBytes)\n    {\n        fShutdown = true;\n        string strMessage = _(\"Warning: Disk space is low\");\n        strMiscWarning = strMessage;\n        printf(\"*** %s\\n\", strMessage.c_str());\n        uiInterface.ThreadSafeMessageBox(strMessage, \"Phoenixcoin\", CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL);\n        StartShutdown();\n        return false;\n    }\n    return true;\n}\n\nFILE* OpenBlockFile(unsigned int nFile, unsigned int nBlockPos, const char* pszMode)\n{\n    if ((nFile < 1) || (nFile == (unsigned int) -1))\n        return NULL;\n    FILE* file = fopen((GetDataDir() / strprintf(\"blk%04d.dat\", nFile)).string().c_str(), pszMode);\n    if (!file)\n        return NULL;\n    if (nBlockPos != 0 && !strchr(pszMode, 'a') && !strchr(pszMode, 'w'))\n    {\n        if (fseek(file, nBlockPos, SEEK_SET) != 0)\n        {\n            fclose(file);\n            return NULL;\n        }\n    }\n    return file;\n}\n\nstatic unsigned int nCurrentBlockFile = 1;\n\nFILE* AppendBlockFile(unsigned int& nFileRet)\n{\n    nFileRet = 0;\n    loop\n    {\n        FILE* file = OpenBlockFile(nCurrentBlockFile, 0, \"ab\");\n        if (!file)\n            return NULL;\n        if (fseek(file, 0, SEEK_END) != 0)\n            return NULL;\n        // FAT32 filesize max 4GB, fseek and ftell max 2GB, so we must stay under 2GB\n        if((unsigned int)ftell(file) < (0x7F000000 - MAX_SIZE))\n        {\n            nFileRet = nCurrentBlockFile;\n            return file;\n        }\n        fclose(file);\n        nCurrentBlockFile++;\n    }\n}\n\nbool LoadBlockIndex(bool fAllowNew) {\n\n    if(fTestNet) {\n        pchMessageStart[0] = 0xFF;\n        pchMessageStart[1] = 0xC4;\n        pchMessageStart[2] = 0xBA;\n        pchMessageStart[3] = 0xDF;\n        pchMessageStartNew[0] = 0xFE;\n        pchMessageStartNew[1] = 0xD0;\n        pchMessageStartNew[2] = 0xD8;\n        pchMessageStartNew[3] = 0xD4;\n        hashGenesisBlock = uint256(\"0xecd47eee16536f7d03d64643cfc8c61b22093f8bf2c9358bf8b6f4dcb5f13192\");\n        nBaseMaturity = BASE_MATURITY_TESTNET;\n    }\n\n    //\n    // Load block index\n    //\n    CTxDB txdb(\"cr\");\n    if (!txdb.LoadBlockIndex())\n        return false;\n    txdb.Close();\n\n    //\n    // Init with genesis block\n    //\n    if(mapBlockIndex.empty()) {\n\n        if(!fAllowNew) return false;\n\n        CTransaction txNew;\n        CBlock block;\n\n        if(!fTestNet) {\n\n            // The Phoenixcoin genesis block:\n            // CBlock(hash=be2f30f9e8db8f430056, PoW=00000e9c6e417d3d8068, ver=1, hashPrevBlock=00000000000000000000, hashMerkleRoot=ff2aa75842, nTime=1317972665, nBits=1e0ffff0, nNonce=2084931085, vtx=1)\n            //  CTransaction(hash=ff2aa75842, ver=1, vin.size=1, vout.size=1, nLockTime=0)\n            //    CTxIn(COutPoint(0000000000, -1), coinbase 04ffff001d010446552e532e204973205765696768696e672057696465204f7665726861756c206f662057697265746170204c617773202d204e592054696d6573202d204d617920382032303133)\n            //    CTxOut(error)\n            //  vMerkleTree: ff2aa75842\n\n            const char* pszTimestamp = \"U.S. Is Weighing Wide Overhaul of Wiretap Laws - NY Times - May 8 2013\";\n            txNew.vin.resize(1);\n            txNew.vout.resize(1);\n            txNew.vin[0].scriptSig = CScript() << 486604799 << CBigNum(4) << vector<unsigned char>((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));\n            txNew.vout[0].nValue = 50 * COIN;\n            txNew.vout[0].scriptPubKey = CScript() << 0x00 << OP_CHECKSIG;\n            block.vtx.push_back(txNew);\n            block.hashPrevBlock = 0;\n            block.hashMerkleRoot = block.BuildMerkleTree();\n            block.nVersion = 1;\n            block.nTime    = 1317972665;\n            block.nBits    = 0x1e0ffff0;\n            block.nNonce   = 2084931085;\n\n        } else {\n\n            // The Phoenixcoin testnet genesis block:\n            // CBlock(hash=ecd47eee16536f7d03d6, PoW=000004b4022863f9ecf0, ver=1, hashPrevBlock=00000000000000000000, hashMerkleRoot=9bf4ade403, nTime=1383768000, nBits=1e0ffff0, nNonce=1029893, vtx=1)\n            //  CTransaction(hash=9bf4ade403, ver=1, vin.size=1, vout.size=1, nLockTime=0)\n            //    CTxIn(COutPoint(0000000000, -1), coinbase 04ffff001d01044a57656220466f756e6465722044656e6f756e636573204e534120456e6372797074696f6e20437261636b696e67202d2054686520477561726469616e202d2030362f4e6f762f32303133)\n            //    CTxOut(nValue=500.00000000, scriptPubKey=049023f10bccda76f971d6417d420c)\n            //  vMerkleTree: 9bf4ade403 \n\n            const char* pszTimestamp = \"Web Founder Denounces NSA Encryption Cracking - The Guardian - 06/Nov/2013\";\n            txNew.vin.resize(1);\n            txNew.vout.resize(1);\n            txNew.vin[0].scriptSig = CScript() << 486604799 << CBigNum(4) << vector<unsigned char>((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));\n            txNew.vout[0].nValue = 500 * COIN;\n            txNew.vout[0].scriptPubKey = CScript() << ParseHex(\"049023F10BCCDA76F971D6417D420C6BB5735D3286669CE03B49C5FEA07078F0E07B19518EE1C0A4F81BCF56A5497AD7D8200CE470EEA8C6E2CF65F1EE503F0D3E\") << OP_CHECKSIG;\n            block.vtx.push_back(txNew);\n            block.hashPrevBlock = 0;\n            block.hashMerkleRoot = block.BuildMerkleTree();\n            block.nVersion = 1;\n            block.nTime    = 1383768000;\n            block.nBits    = 0x1e0ffff0;\n            block.nNonce   = 1029893;\n\n        }\n\n        //// debug print\n        printf(\"%s\\n\", block.GetHash().ToString().c_str());\n        printf(\"%s\\n\", hashGenesisBlock.ToString().c_str());\n        printf(\"%s\\n\", block.hashMerkleRoot.ToString().c_str());\n\n        if(!fTestNet) assert(block.hashMerkleRoot == uint256(\"0xff2aa75842fae1bfb100b656c57229ce37b03643434da2043ddab7a11cfe69a6\"));\n        else assert(block.hashMerkleRoot == uint256(\"0x9bf4ade403d775b44e872935609367aee5bd7df698e0f4c73e5f30f46b30a537\"));\n\n        // If genesis block hash does not match, then generate new genesis hash.\n        if (false && block.GetHash() != hashGenesisBlock)\n        {\n            printf(\"Searching for genesis block...\\n\");\n            // This will figure out a valid hash and Nonce if you're\n            // creating a different genesis block:\n            uint profile = fNeoScrypt ? 0x0 : 0x3;\n            uint256 hashTarget = CBigNum().SetCompact(block.nBits).getuint256();\n            uint256 hash;\n\n            while(true) {\n                neoscrypt((uchar *) &block.nVersion, (uchar *) &hash, profile);\n                if(hash <= hashTarget) break;\n                if ((block.nNonce & 0xFFF) == 0)\n                {\n                    printf(\"nonce %08X: hash = %s (target = %s)\\n\", block.nNonce, hash.ToString().c_str(), hashTarget.ToString().c_str());\n                }\n                ++block.nNonce;\n                if (block.nNonce == 0)\n                {\n                    printf(\"NONCE WRAPPED, incrementing time\\n\");\n                    ++block.nTime;\n                }\n            }\n            printf(\"block.nTime = %u \\n\", block.nTime);\n            printf(\"block.nNonce = %u \\n\", block.nNonce);\n            printf(\"block.GetHash = %s\\n\", block.GetHash().ToString().c_str());\n        }\n\n        block.print();\n        assert(block.GetHash() == hashGenesisBlock);\n\n        // Start new block file\n        unsigned int nFile;\n        unsigned int nBlockPos;\n        if (!block.WriteToDisk(nFile, nBlockPos))\n            return error(\"LoadBlockIndex() : writing genesis block to disk failed\");\n        if (!block.AddToBlockIndex(nFile, nBlockPos))\n            return error(\"LoadBlockIndex() : genesis block not accepted\");\n\n        // Initialise advanced checkpointing\n        if (!WriteSyncCheckpoint(hashGenesisBlock))\n            return error(\"LoadBlockIndex() : failed to initialise advanced checkpointing\");\n    }\n\n    // Verify the master public key and reset advanced checkpointing if changed\n    if (!CheckCheckpointPubKey())\n        return error(\"LoadBlockIndex() : failed to reset advanced checkpointing\");\n\n    return true;\n}\n\n\n\nvoid PrintBlockTree()\n{\n    // precompute tree structure\n    map<CBlockIndex*, vector<CBlockIndex*> > mapNext;\n    for (map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.begin(); mi != mapBlockIndex.end(); ++mi)\n    {\n        CBlockIndex* pindex = (*mi).second;\n        mapNext[pindex->pprev].push_back(pindex);\n        // test\n        //while (rand() % 3 == 0)\n        //    mapNext[pindex->pprev].push_back(pindex);\n    }\n\n    vector<pair<int, CBlockIndex*> > vStack;\n    vStack.push_back(make_pair(0, pindexGenesisBlock));\n\n    int nPrevCol = 0;\n    while (!vStack.empty())\n    {\n        int nCol = vStack.back().first;\n        CBlockIndex* pindex = vStack.back().second;\n        vStack.pop_back();\n\n        // print split or gap\n        if (nCol > nPrevCol)\n        {\n            for (int i = 0; i < nCol-1; i++)\n                printf(\"| \");\n            printf(\"|\\\\\\n\");\n        }\n        else if (nCol < nPrevCol)\n        {\n            for (int i = 0; i < nCol; i++)\n                printf(\"| \");\n            printf(\"|\\n\");\n       }\n        nPrevCol = nCol;\n\n        // print columns\n        for (int i = 0; i < nCol; i++)\n            printf(\"| \");\n\n        // print item\n        CBlock block;\n        block.ReadFromDisk(pindex);\n        printf(\"%d (%u,%u) %s  %s  tx %d\",\n            pindex->nHeight,\n            pindex->nFile,\n            pindex->nBlockPos,\n            block.GetHash().ToString().substr(0,20).c_str(),\n            DateTimeStrFormat(\"%x %H:%M:%S\", block.GetBlockTime()).c_str(),\n            block.vtx.size());\n\n        PrintWallets(block);\n\n        // put the main timechain first\n        vector<CBlockIndex*>& vNext = mapNext[pindex];\n        for (unsigned int i = 0; i < vNext.size(); i++)\n        {\n            if (vNext[i]->pnext)\n            {\n                swap(vNext[0], vNext[i]);\n                break;\n            }\n        }\n\n        // iterate children\n        for (unsigned int i = 0; i < vNext.size(); i++)\n            vStack.push_back(make_pair(nCol+i, vNext[i]));\n    }\n}\n\nbool LoadExternalBlockFile(FILE* fileIn)\n{\n    int nLoaded = 0;\n    {\n        LOCK(cs_main);\n        try {\n            CAutoFile blkdat(fileIn, SER_DISK, CLIENT_VERSION);\n            unsigned int nPos = 0;\n            while (nPos != (unsigned int)-1 && blkdat.good() && !fRequestShutdown)\n            {\n                unsigned char pchData[65536];\n                do {\n                    fseek(blkdat, nPos, SEEK_SET);\n                    int nRead = fread(pchData, 1, sizeof(pchData), blkdat);\n                    if (nRead <= 8)\n                    {\n                        nPos = (unsigned int)-1;\n                        break;\n                    }\n                    void* nFind = memchr(pchData, pchMessageStart[0], nRead+1-sizeof(pchMessageStart));\n                    if (nFind)\n                    {\n                        if (memcmp(nFind, pchMessageStart, sizeof(pchMessageStart))==0)\n                        {\n                            nPos += ((unsigned char*)nFind - pchData) + sizeof(pchMessageStart);\n                            break;\n                        }\n                        nPos += ((unsigned char*)nFind - pchData) + 1;\n                    }\n                    else\n                        nPos += sizeof(pchData) - sizeof(pchMessageStart) + 1;\n                } while(!fRequestShutdown);\n                if (nPos == (unsigned int)-1)\n                    break;\n                fseek(blkdat, nPos, SEEK_SET);\n                unsigned int nSize;\n                blkdat >> nSize;\n                if (nSize > 0 && nSize <= MAX_BLOCK_SIZE)\n                {\n                    CBlock block;\n                    blkdat >> block;\n                    if (ProcessBlock(NULL,&block))\n                    {\n                        nLoaded++;\n                        nPos += 4 + nSize;\n                    }\n                }\n            }\n        }\n        catch (std::exception &e) {\n            printf(\"%s() : Deserialize or I/O error caught during load\\n\",\n                   __PRETTY_FUNCTION__);\n        }\n    }\n    printf(\"Loaded %i blocks from external file\\n\", nLoaded);\n    return nLoaded > 0;\n}\n\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CAlert\n//\n\nmap<uint256, CAlert> mapAlerts;\nCCriticalSection cs_mapAlerts;\n\nstring GetWarnings(string strFor)\n{\n    int nPriority = 0;\n    string strStatusBar;\n    string strRPC;\n    if (GetBoolArg(\"-testsafemode\"))\n        strRPC = \"test\";\n\n    // Checkpoint warning\n    if (strCheckpointWarning != \"\")\n    {\n        nPriority = 900;\n        strStatusBar = strCheckpointWarning;\n    }\n\n    // Misc warnings like out of disk space and clock is wrong\n    if (strMiscWarning != \"\")\n    {\n        nPriority = 1000;\n        strStatusBar = strMiscWarning;\n    }\n\n    // Longer invalid proof-of-work chain\n    if (pindexBest && bnBestInvalidWork > bnBestChainWork + pindexBest->GetBlockWork() * 6)\n    {\n        nPriority = 2000;\n        strStatusBar = strRPC = \"WARNING: Displayed transactions may not be correct!  You may need to upgrade, or other nodes may need to upgrade.\";\n    }\n\n    // Activate safe mode upon failure of advanced checkpointing\n    if (hashInvalidCheckpoint != 0)\n    {\n        nPriority = 3000;\n        strStatusBar = strRPC = \"WARNING: Inconsistent advanced checkpoint found! Please report to the developers.\";\n    }\n\n    // Alerts\n    {\n        LOCK(cs_mapAlerts);\n        BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n        {\n            const CAlert& alert = item.second;\n            if (alert.AppliesToMe() && alert.nPriority > nPriority)\n            {\n                nPriority = alert.nPriority;\n                strStatusBar = alert.strStatusBar;\n            }\n        }\n    }\n\n    if (strFor == \"statusbar\")\n        return strStatusBar;\n    else if (strFor == \"rpc\")\n        return strRPC;\n    assert(!\"GetWarnings() : invalid parameter\");\n    return \"error\";\n}\n\nCAlert CAlert::getAlertByHash(const uint256 &hash)\n{\n    CAlert retval;\n    {\n        LOCK(cs_mapAlerts);\n        map<uint256, CAlert>::iterator mi = mapAlerts.find(hash);\n        if(mi != mapAlerts.end())\n            retval = mi->second;\n    }\n    return retval;\n}\n\nbool CAlert::ProcessAlert()\n{\n    if (!CheckSignature())\n        return false;\n    if (!IsInEffect())\n        return false;\n\n    {\n        LOCK(cs_mapAlerts);\n        // Cancel previous alerts\n        for (map<uint256, CAlert>::iterator mi = mapAlerts.begin(); mi != mapAlerts.end();)\n        {\n            const CAlert& alert = (*mi).second;\n            if (Cancels(alert))\n            {\n                printf(\"cancelling alert %d\\n\", alert.nID);\n                uiInterface.NotifyAlertChanged((*mi).first, CT_DELETED);\n                mapAlerts.erase(mi++);\n            }\n            else if (!alert.IsInEffect())\n            {\n                printf(\"expiring alert %d\\n\", alert.nID);\n                uiInterface.NotifyAlertChanged((*mi).first, CT_DELETED);\n                mapAlerts.erase(mi++);\n            }\n            else\n                mi++;\n        }\n\n        // Check if this alert has been cancelled\n        BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n        {\n            const CAlert& alert = item.second;\n            if (alert.Cancels(*this))\n            {\n                printf(\"alert already cancelled by %d\\n\", alert.nID);\n                return false;\n            }\n        }\n\n        // Add to mapAlerts\n        mapAlerts.insert(make_pair(GetHash(), *this));\n        // Notify UI if it applies to me\n        if(AppliesToMe())\n            uiInterface.NotifyAlertChanged(GetHash(), CT_NEW);\n    }\n\n    printf(\"accepted alert %d, AppliesToMe()=%d\\n\", nID, AppliesToMe());\n    return true;\n}\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Messages\n//\n\n\nbool static AlreadyHave(CTxDB& txdb, const CInv& inv)\n{\n    switch (inv.type)\n    {\n    case MSG_TX:\n        {\n        bool txInMap = false;\n            {\n            LOCK(mempool.cs);\n            txInMap = (mempool.exists(inv.hash));\n            }\n        return txInMap ||\n               mapOrphanTransactions.count(inv.hash) ||\n               txdb.ContainsTx(inv.hash);\n        }\n\n    case MSG_BLOCK:\n        return mapBlockIndex.count(inv.hash) ||\n               mapOrphanBlocks.count(inv.hash);\n    }\n    // Don't know what it is, just say we already got one\n    return true;\n}\n\n\n/* Relays an address to a limited number of nodes connected */\nvoid static RelayAddress(CAddress& addr, bool fReachable) {\n\n    LOCK(cs_vNodes);\n\n    // Use deterministic randomness to send to the same nodes for 12 hours\n    // at a time so the setAddrKnowns of the chosen nodes prevent repeats\n    static uint256 hashSalt;\n    if(hashSalt == 0)\n      RAND_bytes((uchar*)&hashSalt, sizeof(hashSalt));\n    int64 hashAddr = addr.GetHash();\n    uint256 hashRand = hashSalt ^ (hashAddr << 32) ^ ((GetTime() + hashAddr) / (12 * 60 * 60));\n    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n    multimap<uint256, CNode*> mapMix;\n    BOOST_FOREACH(CNode* pnode, vNodes) {\n        uint nPointer;\n        memcpy(&nPointer, &pnode, sizeof(nPointer));\n        uint256 hashKey = hashRand ^ nPointer;\n        hashKey = Hash(BEGIN(hashKey), END(hashKey));\n        mapMix.insert(make_pair(hashKey, pnode));\n    }\n    int nRelayNodes = fReachable ? 2 : 1;\n    for(multimap<uint256, CNode*>::iterator mi = mapMix.begin();\n      mi != mapMix.end() && nRelayNodes-- > 0; ++mi) {\n        ((*mi).second)->PushAddress(addr);\n        if(fDebug) printf(\"relaying: address %s\\n\", addr.ToString().c_str());\n    }\n}\n\n\nbool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n{\n    static map<CService, CPubKey> mapReuseKey;\n    RandAddSeedPerfmon();\n    if (fDebug)\n        printf(\"received: %s (%d bytes)\\n\", strCommand.c_str(), vRecv.size());\n    if (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)\n    {\n        printf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n        return true;\n    }\n\n\n\n\n\n    if (strCommand == \"version\")\n    {\n        /* Process the 1st version message received per connection\n         * and ignore the others if any */\n        if(pfrom->nVersion)\n          return(true);\n\n        int64 nTime;\n        CAddress addrMe;\n        CAddress addrFrom;\n        uint64 nNonce = 1;\n        vRecv >> pfrom->nVersion >> pfrom->nServices >> nTime >> addrMe;\n\n        // Do not connect to these clients as they're not Phoenixcoin ones or too old\n        if((pfrom->nVersion > MAX_PROTOCOL_VERSION) || (pfrom->nVersion < MIN_PROTOCOL_VERSION)) {\n            printf(\"peer %s reports incompatible version %i; disconnecting\\n\", pfrom->addr.ToString().c_str(), pfrom->nVersion);\n            pfrom->fDisconnect = true;\n            return false;\n        }\n\n        if (!vRecv.empty())\n            vRecv >> addrFrom >> nNonce;\n        if (!vRecv.empty())\n            vRecv >> pfrom->strSubVer;\n        if (!vRecv.empty())\n            vRecv >> pfrom->nStartingHeight;\n\n        if (pfrom->fInbound && addrMe.IsRoutable())\n        {\n            pfrom->addrLocal = addrMe;\n            SeenLocal(addrMe);\n        }\n\n        // Disconnect if we connected to ourself\n        if (nNonce == nLocalHostNonce && nNonce > 1)\n        {\n            printf(\"connected to self at %s; disconnecting\\n\", pfrom->addr.ToString().c_str());\n            pfrom->fDisconnect = true;\n            return true;\n        }\n\n        // Our external IP for getinfo\n        if(addrFrom.IsRoutable() && addrMe.IsRoutable()) addrExternal = addrMe;\n\n        // Be shy and don't send version until we hear\n        if (pfrom->fInbound)\n            pfrom->PushVersion();\n\n        pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);\n\n        AddTimeData(pfrom->addr, nTime);\n\n        // Change version\n        pfrom->PushMessage(\"verack\");\n        pfrom->vSend.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n\n        if (!pfrom->fInbound)\n        {\n            // Advertise our address\n            if (!fNoListen && !IsInitialBlockDownload())\n            {\n                CAddress addr = GetLocalAddress(&pfrom->addr);\n                if (addr.IsRoutable())\n                    pfrom->PushAddress(addr);\n            }\n\n            // Get recent addresses\n            int nAddrSize;\n            if(fBerkeleyAddrDB)\n              nAddrSize = mapAddresses.size();\n            else\n              nAddrSize = addrman.size();\n            if(pfrom->fOneShot || (nAddrSize < 1000)) {\n                pfrom->PushMessage(\"getaddr\");\n                pfrom->fGetAddr = true;\n            }\n            if(!fBerkeleyAddrDB)\n              addrman.Good(pfrom->addr);\n        } else {\n            if(!fBerkeleyAddrDB && ((CNetAddr)pfrom->addr == (CNetAddr)addrFrom)) {\n                addrman.Add(addrFrom, addrFrom);\n                addrman.Good(addrFrom);\n            }\n        }\n\n        // Another Ghostlander's quick hack to deal with nodes advertising\n        // compatible version numbers while confusing our Qt client;\n        // if their nStartingHeight is much higher of what we estimate it\n        // to be, disconnect them.\n        // nRefHeight and nRefTime should be updated periodically\n        long nRefHeight = 745000, nRefTime = 1438677830; // block #745000\n        long nOurTime = GetAdjustedTime();\n        long nHeightOffset = (nOurTime - nRefTime) / nTargetSpacingFour;\n        // Add 10000 blocks to be safe\n        if(pfrom->nStartingHeight > (nRefHeight + nHeightOffset + 10000)) {\n            printf(\"peer %s reports height %i, estimated height is %i; disconnecting\\n\",\n              pfrom->addr.ToString().c_str(), pfrom->nStartingHeight, nRefHeight + nHeightOffset);\n            pfrom->fDisconnect = true;\n            return false;\n        }\n\n        // Ask the first connected node for block updates\n        static int nAskedForBlocks = 0;\n        if (!pfrom->fClient && !pfrom->fOneShot &&\n            (pfrom->nVersion < NOBLKS_VERSION_START ||\n             pfrom->nVersion >= NOBLKS_VERSION_END) &&\n             (nAskedForBlocks < 1 || vNodes.size() <= 1))\n        {\n            nAskedForBlocks++;\n            pfrom->PushGetBlocks(pindexBest, uint256(0));\n        }\n\n        // Relay alerts\n        {\n            LOCK(cs_mapAlerts);\n            BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n                item.second.RelayTo(pfrom);\n        }\n\n        // Relay advanced checkpoints\n        {\n            LOCK(cs_hashSyncCheckpoint);\n            if (!checkpointMessage.IsNull())\n                checkpointMessage.RelayTo(pfrom);\n        }\n\n        pfrom->fSuccessfullyConnected = true;\n\n        printf(\"received version message from %s, version %d, blocks=%d, us=%s, them=%s\\n\",\n          pfrom->addr.ToString().c_str(), pfrom->nVersion, pfrom->nStartingHeight, addrMe.ToString().c_str(), addrFrom.ToString().c_str());\n\n        cPeerBlockCounts.input(pfrom->nStartingHeight);\n\n        // Check for any advanced checkpoint pending\n        if (!IsInitialBlockDownload())\n            AskForPendingSyncCheckpoint(pfrom);\n    }\n\n\n    else if (pfrom->nVersion == 0)\n    {\n        // Must have a version message before anything else\n        pfrom->Misbehaving(1);\n        return false;\n    }\n\n\n    else if (strCommand == \"verack\")\n    {\n        pfrom->vRecv.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n    }\n\n\n    else if (strCommand == \"addr\")\n    {\n        vector<CAddress> vAddr;\n        vRecv >> vAddr;\n\n        if(vAddr.size() > 1000) {\n            pfrom->Misbehaving(20);\n            return(error(\"Address message size = %d\", vAddr.size()));\n        }\n\n        int64 nNow = GetAdjustedTime();\n        int64 nSince = nNow - 10 * 60;\n        bool fReachable;\n\n        if(fBerkeleyAddrDB) {\n\n            CBerkeleyAddrDB adb;\n            adb.TxnBegin();\n\n            BOOST_FOREACH(CAddress& addr, vAddr) {\n\n                if(fShutdown)\n                  return(true);\n\n                /* Simple port filter */\n                ushort nPort = addr.GetPort();\n                if(nPort != GetDefaultPort())\n                  continue;\n\n                if((addr.nTime <= 100000000) || (addr.nTime > nNow + 10 * 60))\n                  addr.nTime = nNow - 5 * 24 * 60 * 60;\n\n                fReachable = IsReachable(addr);\n\n                if(fReachable)\n                  AddAddress(addr, 2 * 60 * 60, &adb);\n\n                pfrom->AddAddressKnown(addr);\n\n                if((addr.nTime > nSince) && !pfrom->fGetAddr &&\n                  (vAddr.size() <= 10) && addr.IsRoutable())\n                  RelayAddress(addr, fReachable);\n\n            }\n\n            adb.TxnCommit();\n\n        } else {\n\n            vector<CAddress> vAddrOk;\n\n            BOOST_FOREACH(CAddress& addr, vAddr) {\n\n                if(fShutdown)\n                  return(true);\n\n                /* Simple port filter */\n                ushort nPort = addr.GetPort();\n                if(nPort != GetDefaultPort())\n                  continue;\n\n                if((addr.nTime <= 100000000) || (addr.nTime > nNow + 10 * 60))\n                  addr.nTime = nNow - 5 * 24 * 60 * 60;\n\n                fReachable = IsReachable(addr);\n\n                if(fReachable)\n                  vAddrOk.push_back(addr);\n\n                pfrom->AddAddressKnown(addr);\n\n                if((addr.nTime > nSince) && !pfrom->fGetAddr &&\n                  (vAddr.size() <= 10) && addr.IsRoutable())\n                  RelayAddress(addr, fReachable);\n\n            }\n\n            addrman.Add(vAddrOk, pfrom->addr, 2 * 60 * 60);\n\n        }\n\n        if(vAddr.size() < 1000)\n          pfrom->fGetAddr = false;\n\n        if(pfrom->fOneShot)\n          pfrom->fDisconnect = true;\n\n    }\n\n    else if (strCommand == \"inv\")\n    {\n        vector<CInv> vInv;\n        vRecv >> vInv;\n        if (vInv.size() > 50000)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message inv size() = %d\", vInv.size());\n        }\n\n        // find last block in inv vector\n        unsigned int nLastBlock = (unsigned int)(-1);\n        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++) {\n            if (vInv[vInv.size() - 1 - nInv].type == MSG_BLOCK) {\n                nLastBlock = vInv.size() - 1 - nInv;\n                break;\n            }\n        }\n        CTxDB txdb(\"r\");\n        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n        {\n            const CInv &inv = vInv[nInv];\n\n            if (fShutdown)\n                return true;\n            pfrom->AddInventoryKnown(inv);\n\n            bool fAlreadyHave = AlreadyHave(txdb, inv);\n            if (fDebug)\n                printf(\"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fAlreadyHave ? \"have\" : \"new\");\n\n            if (!fAlreadyHave)\n                pfrom->AskFor(inv);\n            else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash)) {\n                pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(mapOrphanBlocks[inv.hash]));\n            } else if (nInv == nLastBlock) {\n                // In case we are on a very long side-chain, it is possible that we already have\n                // the last block in an inv bundle sent in response to getblocks. Try to detect\n                // this situation and push another getblocks to continue.\n                std::vector<CInv> vGetData(1,inv);\n                pfrom->PushGetBlocks(mapBlockIndex[inv.hash], uint256(0));\n                if (fDebug)\n                    printf(\"force request: %s\\n\", inv.ToString().c_str());\n            }\n\n            // Track requests for our stuff\n            Inventory(inv.hash);\n        }\n    }\n\n\n    else if (strCommand == \"getdata\")\n    {\n        vector<CInv> vInv;\n        vRecv >> vInv;\n        if (vInv.size() > 50000)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message getdata size() = %d\", vInv.size());\n        }\n\n        if (fDebugNet || (vInv.size() != 1))\n            printf(\"received getdata (%d invsz)\\n\", vInv.size());\n\n        BOOST_FOREACH(const CInv& inv, vInv)\n        {\n            if (fShutdown)\n                return true;\n            if (fDebugNet || (vInv.size() == 1))\n                printf(\"received getdata for: %s\\n\", inv.ToString().c_str());\n\n            if (inv.type == MSG_BLOCK)\n            {\n                // Send block from disk\n                map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(inv.hash);\n                if (mi != mapBlockIndex.end())\n                {\n                    CBlock block;\n                    block.ReadFromDisk((*mi).second);\n                    pfrom->PushMessage(\"block\", block);\n\n                    // Trigger them to send a getblocks request for the next batch of inventory\n                    if (inv.hash == pfrom->hashContinue)\n                    {\n                        // Bypass PushInventory, this must send even if redundant,\n                        // and we want it right after the last block so they don't\n                        // wait for other stuff first.\n                        vector<CInv> vInv;\n                        vInv.push_back(CInv(MSG_BLOCK, hashBestChain));\n                        pfrom->PushMessage(\"inv\", vInv);\n                        pfrom->hashContinue = 0;\n                    }\n                }\n            }\n            else if (inv.IsKnownType())\n            {\n                // Send stream from relay memory\n                {\n                    LOCK(cs_mapRelay);\n                    map<CInv, CDataStream>::iterator mi = mapRelay.find(inv);\n                    if (mi != mapRelay.end())\n                        pfrom->PushMessage(inv.GetCommand(), (*mi).second);\n                }\n            }\n\n            // Track requests for our stuff\n            Inventory(inv.hash);\n        }\n    }\n\n\n    else if (strCommand == \"getblocks\")\n    {\n        CBlockLocator locator;\n        uint256 hashStop;\n        vRecv >> locator >> hashStop;\n\n        // Find the last block the caller has in the main chain\n        CBlockIndex* pindex = locator.GetBlockIndex();\n\n        // Send the rest of the chain\n        if (pindex)\n            pindex = pindex->pnext;\n        int nLimit = 1000;\n        printf(\"getblocks %d to %s limit %d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str(), nLimit);\n        for (; pindex; pindex = pindex->pnext)\n        {\n            if (pindex->GetBlockHash() == hashStop)\n            {\n                printf(\"  getblocks stopping at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str());\n                break;\n            }\n            pfrom->PushInventory(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n            if (--nLimit <= 0)\n            {\n                // When this block is requested, we'll send an inv that'll make them\n                // getblocks the next batch of inventory.\n                printf(\"  getblocks stopping at limit %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str());\n                pfrom->hashContinue = pindex->GetBlockHash();\n                break;\n            }\n        }\n    }\n\n\n    else if (strCommand == \"getheaders\")\n    {\n        CBlockLocator locator;\n        uint256 hashStop;\n        vRecv >> locator >> hashStop;\n\n        CBlockIndex* pindex = NULL;\n        if (locator.IsNull())\n        {\n            // If locator is null, return the hashStop block\n            map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashStop);\n            if (mi == mapBlockIndex.end())\n                return true;\n            pindex = (*mi).second;\n        }\n        else\n        {\n            // Find the last block the caller has in the main chain\n            pindex = locator.GetBlockIndex();\n            if (pindex)\n                pindex = pindex->pnext;\n        }\n\n        vector<CBlock> vHeaders;\n        int nLimit = 2000;\n        printf(\"getheaders %d to %s\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str());\n        for (; pindex; pindex = pindex->pnext)\n        {\n            vHeaders.push_back(pindex->GetBlockHeader());\n            if (--nLimit <= 0 || pindex->GetBlockHash() == hashStop)\n                break;\n        }\n        pfrom->PushMessage(\"headers\", vHeaders);\n    }\n\n\n    else if (strCommand == \"tx\")\n    {\n        vector<uint256> vWorkQueue;\n        vector<uint256> vEraseQueue;\n        CDataStream vMsg(vRecv);\n        CTxDB txdb(\"r\");\n        CTransaction tx;\n        vRecv >> tx;\n\n        CInv inv(MSG_TX, tx.GetHash());\n        pfrom->AddInventoryKnown(inv);\n\n        // Truncate a message to the actual transaction size\n        unsigned int nSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n        unsigned int oldSize = vMsg.size();\n        if(nSize < oldSize) {\n            printf(\"truncating oversized transaction message %s (%u -> %u)\\n\",\n              tx.GetHash().ToString().c_str(), oldSize, nSize);\n            vMsg.resize(nSize);\n        }\n\n        bool fMissingInputs = false;\n        if (tx.AcceptToMemoryPool(txdb, true, &fMissingInputs))\n        {\n            SyncWithWallets(tx, NULL, true);\n            RelayMessage(inv, vMsg);\n            mapAlreadyAskedFor.erase(inv);\n            vWorkQueue.push_back(inv.hash);\n            vEraseQueue.push_back(inv.hash);\n\n            // Recursively process any orphan transactions that depended on this one\n            for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n            {\n                uint256 hashPrev = vWorkQueue[i];\n                for (map<uint256, CDataStream*>::iterator mi = mapOrphanTransactionsByPrev[hashPrev].begin();\n                     mi != mapOrphanTransactionsByPrev[hashPrev].end();\n                     ++mi)\n                {\n                    const CDataStream& vMsg = *((*mi).second);\n                    CTransaction tx;\n                    CDataStream(vMsg) >> tx;\n                    CInv inv(MSG_TX, tx.GetHash());\n                    bool fMissingInputs2 = false;\n\n                    if (tx.AcceptToMemoryPool(txdb, true, &fMissingInputs2))\n                    {\n                        printf(\"   accepted orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n                        SyncWithWallets(tx, NULL, true);\n                        RelayMessage(inv, vMsg);\n                        mapAlreadyAskedFor.erase(inv);\n                        vWorkQueue.push_back(inv.hash);\n                        vEraseQueue.push_back(inv.hash);\n                    }\n                    else if (!fMissingInputs2)\n                    {\n                        // invalid orphan\n                        vEraseQueue.push_back(inv.hash);\n                        printf(\"   removed invalid orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n                    }\n                }\n            }\n\n            BOOST_FOREACH(uint256 hash, vEraseQueue)\n                EraseOrphanTx(hash);\n        }\n        else if (fMissingInputs)\n        {\n            AddOrphanTx(vMsg);\n\n            // DoS prevention: do not allow mapOrphanTransactions to grow unbounded\n            unsigned int nEvicted = LimitOrphanTxSize(MAX_ORPHAN_TRANSACTIONS);\n            if (nEvicted > 0)\n                printf(\"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n        }\n        if (tx.nDoS) pfrom->Misbehaving(tx.nDoS);\n    }\n\n\n    else if (strCommand == \"block\")\n    {\n        CBlock block;\n        vRecv >> block;\n        uint256 hashBlock = block.GetHash();\n        int nBlockHeight = block.GetBlockHeight();\n\n        printf(\"received block %s height %d\\n\",\n          hashBlock.ToString().substr(0,20).c_str(), nBlockHeight);\n\n        CInv inv(MSG_BLOCK, hashBlock);\n        pfrom->AddInventoryKnown(inv);\n\n        if(ProcessBlock(pfrom, &block))\n          mapAlreadyAskedFor.erase(inv);\n\n        if(block.nDoS)\n          pfrom->Misbehaving(block.nDoS);\n    }\n\n\n    else if (strCommand == \"getaddr\")\n    {\n        pfrom->vAddrToSend.clear();\n        vector<CAddress> vAddr = addrman.GetAddr();\n        BOOST_FOREACH(const CAddress &addr, vAddr)\n            pfrom->PushAddress(addr);\n    }\n\n\n    else if (strCommand == \"checkorder\")\n    {\n        uint256 hashReply;\n        vRecv >> hashReply;\n\n        if (!GetBoolArg(\"-allowreceivebyip\"))\n        {\n            pfrom->PushMessage(\"reply\", hashReply, (int)2, string(\"\"));\n            return true;\n        }\n\n        CWalletTx order;\n        vRecv >> order;\n\n        /// we have a chance to check the order here\n\n        // Keep giving the same key to the same ip until they use it\n        if (!mapReuseKey.count(pfrom->addr))\n            pwalletMain->GetKeyFromPool(mapReuseKey[pfrom->addr], true);\n\n        // Send back approval of order and pubkey to use\n        CScript scriptPubKey;\n        scriptPubKey << mapReuseKey[pfrom->addr] << OP_CHECKSIG;\n        pfrom->PushMessage(\"reply\", hashReply, (int)0, scriptPubKey);\n    }\n\n\n    else if (strCommand == \"reply\")\n    {\n        uint256 hashReply;\n        vRecv >> hashReply;\n\n        CRequestTracker tracker;\n        {\n            LOCK(pfrom->cs_mapRequests);\n            map<uint256, CRequestTracker>::iterator mi = pfrom->mapRequests.find(hashReply);\n            if (mi != pfrom->mapRequests.end())\n            {\n                tracker = (*mi).second;\n                pfrom->mapRequests.erase(mi);\n            }\n        }\n        if (!tracker.IsNull())\n            tracker.fn(tracker.param1, vRecv);\n    }\n\n\n    else if (strCommand == \"ping\")\n    {\n        if (pfrom->nVersion > BIP0031_VERSION)\n        {\n            uint64 nonce = 0;\n            vRecv >> nonce;\n            // Echo the message back with the nonce. This allows for two useful features:\n            //\n            // 1) A remote node can quickly check if the connection is operational\n            // 2) Remote nodes can measure the latency of the network thread. If this node\n            //    is overloaded it won't respond to pings quickly and the remote node can\n            //    avoid sending us more work, like chain download requests.\n            //\n            // The nonce stops the remote getting confused between different pings: without\n            // it, if the remote node sends a ping once per second and this node takes 5\n            // seconds to respond to each, the 5th ping the remote sends would appear to\n            // return very quickly.\n            pfrom->PushMessage(\"pong\", nonce);\n        }\n    }\n\n\n    else if (strCommand == \"alert\")\n    {\n        if(pfrom->fDisconnect) {\n            printf(\"alert received from a disconnected peer %s of version %i; ignoring\\n\",\n              pfrom->addr.ToString().c_str(), pfrom->nVersion);\n            return false;\n        }\n\n        CAlert alert;\n        vRecv >> alert;\n\n        if (alert.ProcessAlert())\n        {\n            // Relay\n            pfrom->setKnown.insert(alert.GetHash());\n            {\n                LOCK(cs_vNodes);\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                    alert.RelayTo(pnode);\n            }\n        } else {\n             // DDoS protection\n             pfrom->Misbehaving(20);\n        }\n    }\n\n\n    // Advanced checkpoint\n    else if (strCommand == \"checkpoint\")\n    {\n        if(pfrom->fDisconnect) {\n            printf(\"sync-checkpoint received from a disconnected peer %s of version %i; ignoring\\n\",\n              pfrom->addr.ToString().c_str(), pfrom->nVersion);\n            return false;\n        }\n\n        CSyncCheckpoint checkpoint;\n        vRecv >> checkpoint;\n\n        if (checkpoint.ProcessSyncCheckpoint(pfrom))\n        {\n            // Relay\n            pfrom->hashCheckpointKnown = checkpoint.hashCheckpoint;\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodes)\n                checkpoint.RelayTo(pnode);\n        }\n    }\n\n\n    else\n    {\n        // Ignore unknown commands for extensibility\n    }\n\n\n    // Update the last seen time for this node's address\n    if (pfrom->fNetworkNode)\n        if (strCommand == \"version\" || strCommand == \"addr\" || strCommand == \"inv\" || strCommand == \"getdata\" || strCommand == \"ping\")\n            AddressCurrentlyConnected(pfrom->addr);\n\n\n    return true;\n}\n\nbool ProcessMessages(CNode* pfrom)\n{\n    CDataStream& vRecv = pfrom->vRecv;\n    if (vRecv.empty())\n        return true;\n    //if (fDebug)\n    //    printf(\"ProcessMessages(%u bytes)\\n\", vRecv.size());\n\n    //\n    // Message format\n    //  (4) message start\n    //  (12) command\n    //  (4) size\n    //  (4) checksum\n    //  (x) data\n    //\n\n    while(true) {\n\n        // Don't bother if send buffer is too full to respond anyway\n        if (pfrom->vSend.size() >= SendBufferSize())\n            break;\n\n        // Scan for message start\n        CDataStream::iterator pstart;\n        int nHeaderSize;\n        bool fMagic;\n\n        /* Message start detector */\n        if(pfrom->nVersion) {\n            /* If a protocol version is known, the detection is easy */\n            if(pfrom->nVersion >= NEW_MAGIC_VERSION) {\n                pstart = search(vRecv.begin(), vRecv.end(), BEGIN(pchMessageStartNew), END(pchMessageStartNew));\n                fMagic = true;\n            } else {\n                pstart = search(vRecv.begin(), vRecv.end(), BEGIN(pchMessageStart), END(pchMessageStart));\n                fMagic = false;\n            }\n        } else {\n            /* Check for the old magic number first */\n            pstart = search(vRecv.begin(), vRecv.end(), BEGIN(pchMessageStart), END(pchMessageStart));\n            fMagic = false;\n            if(vRecv.end() == pstart) {\n                /* Must be the new magic number */\n                pstart = search(vRecv.begin(), vRecv.end(), BEGIN(pchMessageStartNew), END(pchMessageStartNew));\n                fMagic = true;\n            }\n        }\n\n        nHeaderSize = vRecv.GetSerializeSize(CMessageHeader(fMagic));\n\n        if (vRecv.end() - pstart < nHeaderSize)\n        {\n            if ((int)vRecv.size() > nHeaderSize)\n            {\n                printf(\"\\n\\nPROCESSMESSAGE MESSAGESTART NOT FOUND\\n\\n\");\n                vRecv.erase(vRecv.begin(), vRecv.end() - nHeaderSize);\n            }\n            break;\n        }\n        if (pstart - vRecv.begin() > 0)\n            printf(\"\\n\\nPROCESSMESSAGE SKIPPED %d BYTES\\n\\n\", pstart - vRecv.begin());\n        vRecv.erase(vRecv.begin(), pstart);\n\n        // Read header\n        vector<char> vHeaderSave(vRecv.begin(), vRecv.begin() + nHeaderSize);\n        CMessageHeader hdr;\n        vRecv >> hdr;\n        if(!hdr.IsValid(fMagic)) {\n            printf(\"\\n\\nPROCESSMESSAGE: ERRORS IN HEADER %s\\n\\n\\n\", hdr.GetCommand().c_str());\n            continue;\n        }\n        string strCommand = hdr.GetCommand();\n\n        // Message size\n        unsigned int nMessageSize = hdr.nMessageSize;\n        if (nMessageSize > MAX_SIZE)\n        {\n            printf(\"ProcessMessages(%s, %u bytes) : nMessageSize > MAX_SIZE\\n\", strCommand.c_str(), nMessageSize);\n            continue;\n        }\n        if (nMessageSize > vRecv.size())\n        {\n            // Rewind and wait for rest of message\n            vRecv.insert(vRecv.begin(), vHeaderSave.begin(), vHeaderSave.end());\n            break;\n        }\n\n        // Checksum\n        uint256 hash = Hash(vRecv.begin(), vRecv.begin() + nMessageSize);\n        unsigned int nChecksum = 0;\n        memcpy(&nChecksum, &hash, sizeof(nChecksum));\n        if (nChecksum != hdr.nChecksum)\n        {\n            printf(\"ProcessMessages(%s, %u bytes) : CHECKSUM ERROR nChecksum=%08x hdr.nChecksum=%08x\\n\",\n               strCommand.c_str(), nMessageSize, nChecksum, hdr.nChecksum);\n            continue;\n        }\n\n        // Copy message to its own buffer\n        CDataStream vMsg(vRecv.begin(), vRecv.begin() + nMessageSize, vRecv.nType, vRecv.nVersion);\n        vRecv.ignore(nMessageSize);\n\n        // Process message\n        bool fRet = false;\n        try\n        {\n            {\n                LOCK(cs_main);\n                fRet = ProcessMessage(pfrom, strCommand, vMsg);\n            }\n            if (fShutdown)\n                return true;\n        }\n        catch (std::ios_base::failure& e)\n        {\n            if (strstr(e.what(), \"end of data\"))\n            {\n                // Allow exceptions from underlength message on vRecv\n                printf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", strCommand.c_str(), nMessageSize, e.what());\n            }\n            else if (strstr(e.what(), \"size too large\"))\n            {\n                // Allow exceptions from overlong size\n                printf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught\\n\", strCommand.c_str(), nMessageSize, e.what());\n            }\n            else\n            {\n                PrintExceptionContinue(&e, \"ProcessMessages()\");\n            }\n        }\n        catch (std::exception& e) {\n            PrintExceptionContinue(&e, \"ProcessMessages()\");\n        } catch (...) {\n            PrintExceptionContinue(NULL, \"ProcessMessages()\");\n        }\n\n        if (!fRet)\n            printf(\"ProcessMessage(%s, %u bytes) FAILED\\n\", strCommand.c_str(), nMessageSize);\n    }\n\n    vRecv.Compact();\n    return true;\n}\n\n\nbool SendMessages(CNode* pto, bool fSendTrickle)\n{\n    TRY_LOCK(cs_main, lockMain);\n    if (lockMain) {\n        // Don't send anything until we get their version message\n        if (pto->nVersion == 0)\n            return true;\n\n        // Keep-alive ping. We send a nonce of zero because we don't use it anywhere\n        // right now.\n        if (pto->nLastSend && GetTime() - pto->nLastSend > 30 * 60 && pto->vSend.empty()) {\n            uint64 nonce = 0;\n            if (pto->nVersion > BIP0031_VERSION)\n                pto->PushMessage(\"ping\", nonce);\n            else\n                pto->PushMessage(\"ping\");\n        }\n\n        // Resend wallet transactions that haven't gotten in a block yet\n        ResendWalletTransactions(false);\n\n        // Address refresh broadcast\n        static int64 nLastRebroadcast;\n        if (!IsInitialBlockDownload() && (GetTime() - nLastRebroadcast > 24 * 60 * 60))\n        {\n            {\n                LOCK(cs_vNodes);\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                {\n                    // Periodically clear setAddrKnown to allow refresh broadcasts\n                    if (nLastRebroadcast)\n                        pnode->setAddrKnown.clear();\n\n                    // Rebroadcast our address\n                    if (!fNoListen)\n                    {\n                        CAddress addr = GetLocalAddress(&pnode->addr);\n                        if (addr.IsRoutable())\n                            pnode->PushAddress(addr);\n                    }\n                }\n            }\n            nLastRebroadcast = GetTime();\n        }\n\n        if(fBerkeleyAddrDB) {\n            // Clear out old addresses periodically so it's not too much work at once\n            static int64 nLastClear;\n            if(nLastClear == 0)\n              nLastClear = GetTime();\n            if(((GetTime() - nLastClear) > (10 * 60)) &&\n             (vNodes.size() >= (MAX_OUTBOUND_CONNECTIONS / 4))) {\n                nLastClear = GetTime();\n                LOCK(cs_mapAddresses);\n                CBerkeleyAddrDB adb;\n                int64 nSince = GetAdjustedTime() - 14 * 24 * 60 * 60;\n                for(map<vector<uchar>, CAddress>::iterator mi = mapAddresses.begin();\n                  mi != mapAddresses.end();) {\n                    const CAddress& addr = (*mi).second;\n                    if(addr.nTime < nSince) {\n                        if((mapAddresses.size() < 1000) || (GetTime() > nLastClear + 20))\n                          break;\n                        adb.EraseAddress(addr);\n                        mapAddresses.erase(mi++);\n                    } else mi++;\n                }\n            }\n        }\n\n        //\n        // Message: addr\n        //\n        if (fSendTrickle)\n        {\n            vector<CAddress> vAddr;\n            vAddr.reserve(pto->vAddrToSend.size());\n            BOOST_FOREACH(const CAddress& addr, pto->vAddrToSend)\n            {\n                // returns true if wasn't already contained in the set\n                if (pto->setAddrKnown.insert(addr).second)\n                {\n                    vAddr.push_back(addr);\n                    // receiver rejects addr messages larger than 1000\n                    if (vAddr.size() >= 1000)\n                    {\n                        pto->PushMessage(\"addr\", vAddr);\n                        vAddr.clear();\n                    }\n                }\n            }\n            pto->vAddrToSend.clear();\n            if (!vAddr.empty())\n                pto->PushMessage(\"addr\", vAddr);\n        }\n\n\n        //\n        // Message: inventory\n        //\n        vector<CInv> vInv;\n        vector<CInv> vInvWait;\n        {\n            LOCK(pto->cs_inventory);\n            vInv.reserve(pto->vInventoryToSend.size());\n            vInvWait.reserve(pto->vInventoryToSend.size());\n            BOOST_FOREACH(const CInv& inv, pto->vInventoryToSend)\n            {\n                if (pto->setInventoryKnown.count(inv))\n                    continue;\n\n                // trickle out tx inv to protect privacy\n                if (inv.type == MSG_TX && !fSendTrickle)\n                {\n                    // 1/4 of tx invs blast to all immediately\n                    static uint256 hashSalt;\n                    if (hashSalt == 0)\n                        hashSalt = GetRandHash();\n                    uint256 hashRand = inv.hash ^ hashSalt;\n                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n                    bool fTrickleWait = ((hashRand & 3) != 0);\n\n                    // always trickle our own transactions\n                    if (!fTrickleWait)\n                    {\n                        CWalletTx wtx;\n                        if (GetTransaction(inv.hash, wtx))\n                            if (wtx.fFromMe)\n                                fTrickleWait = true;\n                    }\n\n                    if (fTrickleWait)\n                    {\n                        vInvWait.push_back(inv);\n                        continue;\n                    }\n                }\n\n                // returns true if wasn't already contained in the set\n                if (pto->setInventoryKnown.insert(inv).second)\n                {\n                    vInv.push_back(inv);\n                    if (vInv.size() >= 1000)\n                    {\n                        pto->PushMessage(\"inv\", vInv);\n                        vInv.clear();\n                    }\n                }\n            }\n            pto->vInventoryToSend = vInvWait;\n        }\n        if (!vInv.empty())\n            pto->PushMessage(\"inv\", vInv);\n\n\n        //\n        // Message: getdata\n        //\n        vector<CInv> vGetData;\n        int64 nNow = GetTime() * 1000000;\n        CTxDB txdb(\"r\");\n        while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)\n        {\n            const CInv& inv = (*pto->mapAskFor.begin()).second;\n            if (!AlreadyHave(txdb, inv))\n            {\n                if (fDebugNet)\n                    printf(\"sending getdata: %s\\n\", inv.ToString().c_str());\n                vGetData.push_back(inv);\n                if (vGetData.size() >= 1000)\n                {\n                    pto->PushMessage(\"getdata\", vGetData);\n                    vGetData.clear();\n                }\n                mapAlreadyAskedFor[inv] = nNow;\n            }\n            pto->mapAskFor.erase(pto->mapAskFor.begin());\n        }\n        if (!vGetData.empty())\n            pto->PushMessage(\"getdata\", vGetData);\n\n    }\n    return true;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// PhoenixcoinMiner\n//\n\nstatic const unsigned int pSHA256InitState[8] =\n{0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};\n\n\n// Some explaining would be appreciated\nclass COrphan\n{\npublic:\n    CTransaction* ptx;\n    set<uint256> setDependsOn;\n    double dPriority;\n\n    COrphan(CTransaction* ptxIn)\n    {\n        ptx = ptxIn;\n        dPriority = 0;\n    }\n\n    void print() const\n    {\n        printf(\"COrphan(hash=%s, dPriority=%.1f)\\n\", ptx->GetHash().ToString().substr(0,10).c_str(), dPriority);\n        BOOST_FOREACH(uint256 hash, setDependsOn)\n            printf(\"   setDependsOn %s\\n\", hash.ToString().substr(0,10).c_str());\n    }\n};\n\n\nuint64 nLastBlockTx = 0;\nuint64 nLastBlockSize = 0;\n\n/* Creates a new block and collects transactions into */\nCBlock* CreateNewBlock(CReserveKey& reservekey) {\n    CBlockIndex* pindexPrev;\n\n    // Create new block\n    auto_ptr<CBlock> pblock(new CBlock());\n    if (!pblock.get())\n        return NULL;\n\n    // Create coinbase tx\n    CTransaction txNew;\n    txNew.vin.resize(1);\n    txNew.vin[0].prevout.SetNull();\n    txNew.vout.resize(1);\n    txNew.vout[0].scriptPubKey << reservekey.GetReservedKey() << OP_CHECKSIG;\n\n    // Add our coinbase tx as first transaction\n    pblock->vtx.push_back(txNew);\n\n    // Collect memory pool transactions into the block\n    int64 nFees = 0;\n    {\n        LOCK2(cs_main, mempool.cs);\n        pindexPrev = pindexBest;\n        CTxDB txdb(\"r\");\n\n        // Priority order to process transactions\n        list<COrphan> vOrphan; // list memory doesn't move\n        map<uint256, vector<COrphan*> > mapDependers;\n        multimap<double, CTransaction*> mapPriority;\n        for (map<uint256, CTransaction>::iterator mi = mempool.mapTx.begin(); mi != mempool.mapTx.end(); ++mi)\n        {\n            CTransaction& tx = (*mi).second;\n            if (tx.IsCoinBase() || !tx.IsFinal())\n                continue;\n\n            COrphan* porphan = NULL;\n            double dPriority = 0;\n            bool fMissingInputs = false;\n            BOOST_FOREACH(const CTxIn& txin, tx.vin)\n            {\n                // Read prev transaction\n                CTransaction txPrev;\n                CTxIndex txindex;\n                if(!txPrev.ReadFromDisk(txdb, txin.prevout, txindex)) {\n\n                    /* A safety check as this should never happen */\n                    if(!mempool.mapTx.count(txin.prevout.hash)) {\n                        printf(\"ERROR: mempool transaction missing input\\n\");\n                        fMissingInputs = true;\n                        if(porphan) vOrphan.pop_back();\n                        break;\n                    }\n\n                    // Has to wait for dependencies\n                    if (!porphan)\n                    {\n                        // Use list for automatic deletion\n                        vOrphan.push_back(COrphan(&tx));\n                        porphan = &vOrphan.back();\n                    }\n                    mapDependers[txin.prevout.hash].push_back(porphan);\n                    porphan->setDependsOn.insert(txin.prevout.hash);\n                    continue;\n                }\n\n                int64 nValueIn = txPrev.vout[txin.prevout.n].nValue;\n\n                int nConf = 1;\n                CBlock block;\n                /* Read the block including transactions */\n                if(block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, true)) {\n                    int nHeight = block.GetBlockHeight();\n                    if(nHeight > 0)\n                      /* Precise calculation */\n                      nConf = pindexPrev->nHeight - nHeight;\n                    else\n                      /* Acceptable approximation */\n                      nConf = (pindexPrev->nTime - block.nTime) / nTargetSpacingZero;\n                }\n\n                dPriority += (double)nValueIn * nConf;\n\n            }\n            if(fMissingInputs) continue;\n\n            // Priority is sum(valuein * age) / txsize\n            dPriority /= ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n\n            if (porphan)\n                porphan->dPriority = dPriority;\n            else\n                mapPriority.insert(make_pair(-dPriority, &(*mi).second));\n\n        }\n\n        // Collect transactions into block\n        map<uint256, CTxIndex> mapTestPool;\n        uint64 nBlockSize = 1000;\n        uint64 nBlockTx = 0;\n        int nBlockSigOps = 100;\n        while (!mapPriority.empty())\n        {\n            // Take highest priority transaction off priority queue\n            double dPriority = -(*mapPriority.begin()).first;\n            CTransaction& tx = *(*mapPriority.begin()).second;\n            mapPriority.erase(mapPriority.begin());\n\n            // Size limits\n            unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n            if (nBlockSize + nTxSize >= MAX_BLOCK_SIZE_GEN)\n                continue;\n\n            // Legacy limits on sigOps:\n            unsigned int nTxSigOps = tx.GetLegacySigOpCount();\n            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n                continue;\n\n            // Transaction fee required depends on block size\n            // Phoenixcoin: low priority transactions up to 500 bytes in size\n            // are free unless they get caught by the dust spam filter\n            bool fAllowFree = ((nBlockSize + nTxSize < 1500) || CTransaction::AllowFree(dPriority));\n            int64 nMinFee = tx.GetMinFee(nTxSize, fAllowFree, GMF_BLOCK);\n\n            // Connecting shouldn't fail due to dependency on other memory pool transactions\n            // because we're already processing them in order of dependency\n            map<uint256, CTxIndex> mapTestPoolTmp(mapTestPool);\n            MapPrevTx mapInputs;\n            bool fInvalid;\n            if (!tx.FetchInputs(txdb, mapTestPoolTmp, false, true, mapInputs, fInvalid))\n                continue;\n\n            int64 nTxFees = tx.GetValueIn(mapInputs)-tx.GetValueOut();\n            if (nTxFees < nMinFee)\n                continue;\n\n            nTxSigOps += tx.GetP2SHSigOpCount(mapInputs);\n            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n                continue;\n\n            if (!tx.ConnectInputs(mapInputs, mapTestPoolTmp, CDiskTxPos(1,1,1), pindexPrev, false, true))\n                continue;\n            mapTestPoolTmp[tx.GetHash()] = CTxIndex(CDiskTxPos(1,1,1), tx.vout.size());\n            swap(mapTestPool, mapTestPoolTmp);\n\n            // Added\n            pblock->vtx.push_back(tx);\n            nBlockSize += nTxSize;\n            ++nBlockTx;\n            nBlockSigOps += nTxSigOps;\n            nFees += nTxFees;\n\n            // Add transactions that depend on this one to the priority queue\n            uint256 hash = tx.GetHash();\n            if (mapDependers.count(hash))\n            {\n                BOOST_FOREACH(COrphan* porphan, mapDependers[hash])\n                {\n                    if (!porphan->setDependsOn.empty())\n                    {\n                        porphan->setDependsOn.erase(hash);\n                        if (porphan->setDependsOn.empty())\n                            mapPriority.insert(make_pair(-porphan->dPriority, porphan->ptx));\n                    }\n                }\n            }\n        }\n\n        nLastBlockTx = nBlockTx;\n        nLastBlockSize = nBlockSize;\n        printf(\"CreateNewBlock() : total size %lu\\n\", nBlockSize);\n\n    }\n\n    pblock->vtx[0].vout[0].nValue = GetBlockValue(pindexPrev->nHeight+1, nFees);\n\n    // Fill in header\n    pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\n    pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n    pblock->UpdateTime(pindexPrev);\n    pblock->nBits          = GetNextWorkRequired(pindexPrev, pblock.get());\n    pblock->nNonce         = 0;\n\n    return pblock.release();\n}\n\n\nvoid IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int& nExtraNonce)\n{\n    // Update nExtraNonce\n    static uint256 hashPrevBlock;\n    if (hashPrevBlock != pblock->hashPrevBlock)\n    {\n        nExtraNonce = 0;\n        hashPrevBlock = pblock->hashPrevBlock;\n    }\n    ++nExtraNonce;\n\n    /* Blocks v1: nTime in coin base\n     * Blocks v2: nHeight in coin base */\n    uint nHeight = pindexPrev->nHeight + 1;\n    pblock->vtx[0].vin[0].scriptSig = (CScript() << nHeight << CBigNum(nExtraNonce)) + COINBASE_FLAGS;\n    assert(pblock->vtx[0].vin[0].scriptSig.size() <= 100);\n\n    pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n}\n\n/* Prepares a block header for transmission using RPC getwork */\nvoid FormatDataBuffer(CBlock *pblock, uint *pdata) {\n    uint i;\n\n    struct {\n        int nVersion;\n        uint256 hashPrevBlock;\n        uint256 hashMerkleRoot;\n        uint nTime;\n        uint nBits;\n        uint nNonce;\n    } data;\n\n    data.nVersion       = pblock->nVersion;\n    data.hashPrevBlock  = pblock->hashPrevBlock;\n    data.hashMerkleRoot = pblock->hashMerkleRoot;\n    data.nTime          = pblock->nTime;\n    data.nBits          = pblock->nBits;\n    data.nNonce         = pblock->nNonce;\n\n    if(fNeoScrypt) {\n        /* Copy the LE data */\n        for(i = 0; i < 20; i++)\n          pdata[i] = ((uint *) &data)[i];\n    } else {\n        /* Block header size in bits */\n        pdata[31] = 640;\n        /* Convert LE to BE and copy */\n        for(i = 0; i < 20; i++)\n          pdata[i] = ByteReverse(((uint *) &data)[i]);\n        /* Erase the remaining part */\n        for(i = 20; i < 31; i++)\n          pdata[i] = 0;\n    }\n}\n\n\nbool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey) {\n    uint256 hash = pblock->GetPoWHash();\n    uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n\n    if(hash > hashTarget)\n      return(false);\n\n    //// debug print\n    printf(\"PhoenixcoinMiner:\\n\");\n    printf(\"proof-of-work found  \\n  hash: %s  \\ntarget: %s\\n\", hash.GetHex().c_str(), hashTarget.GetHex().c_str());\n    pblock->print();\n    printf(\"generated %s\\n\", FormatMoney(pblock->vtx[0].vout[0].nValue).c_str());\n\n    // Found a solution\n    {\n        LOCK(cs_main);\n        if (pblock->hashPrevBlock != hashBestChain)\n            return error(\"PhoenixcoinMiner : generated block is stale\");\n\n        // Remove key from key pool\n        reservekey.KeepKey();\n\n        // Track how many getdata requests this block gets\n        {\n            LOCK(wallet.cs_wallet);\n            wallet.mapRequestCount[pblock->GetHash()] = 0;\n        }\n\n        // Process this block the same as if we had received it from another node\n        if (!ProcessBlock(NULL, pblock))\n            return error(\"PhoenixcoinMiner : ProcessBlock, block not accepted\");\n    }\n\n    return true;\n}\n\nvoid static ThreadPhoenixcoinMiner(void* parg);\n\nstatic bool fLimitProcessors = false;\nstatic int nLimitProcessors = -1;\n\nvoid static PhoenixcoinMiner(CWallet *pwallet)\n{\n    printf(\"PhoenixcoinMiner started\\n\");\n    SetThreadPriority(THREAD_PRIORITY_LOWEST);\n\n    // Make this thread recognisable as the mining thread\n    RenameThread(\"pxc-miner\");\n\n    // Each thread has its own key and counter\n    CReserveKey reservekey(pwallet);\n    unsigned int nExtraNonce = 0;\n\n    while (fGenerateCoins)\n    {\n        if (fShutdown)\n            return;\n        while (vNodes.empty() || IsInitialBlockDownload())\n        {\n            Sleep(1000);\n            if (fShutdown)\n                return;\n            if (!fGenerateCoins)\n                return;\n        }\n\n\n        //\n        // Create new block\n        //\n        unsigned int nTransactionsUpdatedLast = nTransactionsUpdated;\n        CBlockIndex* pindexPrev = pindexBest;\n\n        auto_ptr<CBlock> pblock(CreateNewBlock(reservekey));\n\n        if (!pblock.get())\n            return;\n\n        IncrementExtraNonce(pblock.get(), pindexPrev, nExtraNonce);\n\n        printf(\"Running PhoenixcoinMiner with %d transactions in block\\n\", pblock->vtx.size());\n\n        //\n        // Search\n        //\n        int64 nStart = GetTime();\n        uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n\n        while(true) {\n            unsigned int nHashesDone = 0;\n            uint profile = fNeoScrypt ? 0x0 : 0x3;\n            uint256 hash;\n\n            while(true) {\n                neoscrypt((uchar *) &pblock->nVersion, (uchar *) &hash, profile);\n                if(hash <= hashTarget) {\n                    // Found a solution\n                    SetThreadPriority(THREAD_PRIORITY_NORMAL);\n                    CheckWork(pblock.get(), *pwalletMain, reservekey);\n                    SetThreadPriority(THREAD_PRIORITY_LOWEST);\n                    break;\n                }\n                pblock->nNonce += 1;\n                nHashesDone += 1;\n                if ((pblock->nNonce & 0xFF) == 0)\n                    break;\n            }\n\n            // Meter hashes/sec\n            static int64 nHashCounter;\n            if (nHPSTimerStart == 0)\n            {\n                nHPSTimerStart = GetTimeMillis();\n                nHashCounter = 0;\n            }\n            else\n                nHashCounter += nHashesDone;\n            if (GetTimeMillis() - nHPSTimerStart > 4000)\n            {\n                static CCriticalSection cs;\n                {\n                    LOCK(cs);\n                    if (GetTimeMillis() - nHPSTimerStart > 4000)\n                    {\n                        dHashesPerSec = 1000.0 * nHashCounter / (GetTimeMillis() - nHPSTimerStart);\n                        nHPSTimerStart = GetTimeMillis();\n                        nHashCounter = 0;\n                        string strStatus = strprintf(\"    %.0f khash/s\", dHashesPerSec/1000.0);\n                        static int64 nLogTime;\n                        if (GetTime() - nLogTime > 30 * 60)\n                        {\n                            nLogTime = GetTime();\n                            printf(\"%s \", DateTimeStrFormat(\"%x %H:%M\", GetTime()).c_str());\n                            printf(\"hashmeter %3d CPUs %6.0f khash/s\\n\", vnThreadsRunning[THREAD_MINER], dHashesPerSec/1000.0);\n                        }\n                    }\n                }\n            }\n\n            // Check for stop or if block needs to be rebuilt\n            if (fShutdown)\n                return;\n            if (!fGenerateCoins)\n                return;\n            if (fLimitProcessors && vnThreadsRunning[THREAD_MINER] > nLimitProcessors)\n                return;\n            if (vNodes.empty())\n                break;\n            if (pblock->nNonce >= 0xffff0000)\n                break;\n            if (nTransactionsUpdated != nTransactionsUpdatedLast && GetTime() - nStart > 60)\n                break;\n            if (pindexPrev != pindexBest)\n                break;\n\n            pblock->UpdateTime(pindexPrev);\n\n            if(fTestNet)\n                /* UpdateTime() can change work required on testnet */\n                hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n        }\n    }\n}\n\nvoid static ThreadPhoenixcoinMiner(void* parg)\n{\n    CWallet* pwallet = (CWallet*)parg;\n    try\n    {\n        vnThreadsRunning[THREAD_MINER]++;\n        PhoenixcoinMiner(pwallet);\n        vnThreadsRunning[THREAD_MINER]--;\n    }\n    catch (std::exception& e) {\n        vnThreadsRunning[THREAD_MINER]--;\n        PrintException(&e, \"ThreadPhoenixcoinMiner()\");\n    } catch (...) {\n        vnThreadsRunning[THREAD_MINER]--;\n        PrintException(NULL, \"ThreadPhoenixcoinMiner()\");\n    }\n    nHPSTimerStart = 0;\n    if (vnThreadsRunning[THREAD_MINER] == 0)\n        dHashesPerSec = 0;\n    printf(\"ThreadPhoenixcoinMiner exiting, %d threads remaining\\n\", vnThreadsRunning[THREAD_MINER]);\n}\n\n\nvoid GenerateCoins(bool fGenerate, CWallet* pwallet)\n{\n    fGenerateCoins = fGenerate;\n    nLimitProcessors = GetArg(\"-genproclimit\", -1);\n    if (nLimitProcessors == 0)\n        fGenerateCoins = false;\n    fLimitProcessors = (nLimitProcessors != -1);\n\n    if (fGenerate)\n    {\n        int nProcessors = boost::thread::hardware_concurrency();\n        printf(\"%d processors\\n\", nProcessors);\n        if (nProcessors < 1)\n            nProcessors = 1;\n        if (fLimitProcessors && nProcessors > nLimitProcessors)\n            nProcessors = nLimitProcessors;\n        int nAddThreads = nProcessors - vnThreadsRunning[THREAD_MINER];\n        printf(\"Starting %d PhoenixcoinMiner threads\\n\", nAddThreads);\n        for (int i = 0; i < nAddThreads; i++)\n        {\n            if (!CreateThread(ThreadPhoenixcoinMiner, pwallet))\n                printf(\"Error: CreateThread(ThreadPhoenixcoinMiner) failed\\n\");\n            Sleep(10);\n        }\n    }\n}\n", "// Copyright (c) 2009-2010 Satoshi Nakamoto\n// Copyright (c) 2009-2012 The Bitcoin developers\n// Copyright (c) 2011-2013 Litecoin Developers\n// Copyright (c) 2013-2014 Phoenixcoin Developers\n// Distributed under the MIT/X11 software license, see the accompanying\n// file LICENCE or http://www.opensource.org/licenses/mit-license.php\n\n#ifndef BITCOIN_MAIN_H\n#define BITCOIN_MAIN_H\n\n#include \"bignum.h\"\n#include \"net.h\"\n#include \"key.h\"\n#include \"script.h\"\n#include \"db.h\"\n#include \"neoscrypt.h\"\n\n#include <list>\n\nclass CWallet;\nclass CBlock;\nclass CBlockIndex;\nclass CKeyItem;\nclass CReserveKey;\n\nclass CAddress;\nclass CInv;\nclass CRequestTracker;\nclass CNode;\n\n/* Maturity threshold for PoW base transactions, in blocks (confirmations) */\nextern int nBaseMaturity;\nstatic const int BASE_MATURITY = 100;\nstatic const int BASE_MATURITY_TESTNET = 100;\n/* Offset for the above to allow safe network propagation, in blocks (confirmations) */\nstatic const int BASE_MATURITY_OFFSET = 1;\n/* Maturity threshold for regular transactions, in blocks (confirmations) */\nstatic const int TX_MATURITY = 6;\n\n// The max. allowed size for a serialised block, in bytes\nstatic const uint MAX_BLOCK_SIZE = 524288;\n// The max. allowed size for a mined block, in bytes\nstatic const uint MAX_BLOCK_SIZE_GEN = (MAX_BLOCK_SIZE >> 1);\n// The max. allowed number of signature check operations per block\nstatic const uint MAX_BLOCK_SIGOPS = (MAX_BLOCK_SIZE >> 6);\n// The max. number of orphan transactions kept in memory\nstatic const uint MAX_ORPHAN_TRANSACTIONS = (MAX_BLOCK_SIZE >> 8);\n/* The current time frame of block limiter */\nstatic const int64 BLOCK_LIMITER_TIME = 120;\n// The min. transaction fee (0.1 PXC) if required\nstatic const int64 MIN_TX_FEE = 10000000;\n// Fees below this value (0.05 PXC) are considered absent while relaying\nstatic const int64 MIN_RELAY_TX_FEE = 5000000;\n// The dust threshold (0.01 PXC)\nstatic const int64 TX_DUST = 1000000;\n// The max. amount for a single transaction;\n// set to ~10% of the total coin supply in our case (10 million PXC)\nstatic const int64 MAX_MONEY = 10000000 * COIN;\ninline bool MoneyRange(int64 nValue) { return (nValue >= 0 && nValue <= MAX_MONEY); }\n// Threshold for nLockTime: below this value it is interpreted as block number, otherwise as UNIX timestamp.\nstatic const unsigned int LOCKTIME_THRESHOLD = 500000000; // Tue Nov  5 00:53:20 1985 UTC\n#ifdef USE_UPNP\nstatic const int fHaveUPnP = true;\n#else\nstatic const int fHaveUPnP = false;\n#endif\n\n\n/* Hard & soft fork related data */\nstatic const int nForkOne   = 46500;   /* the 1st hard fork */\nstatic const int nForkTwo   = 69444;   /* the 2nd hard fork */\nstatic const int nForkThree = 74100;   /* the 3rd hard fork */\nstatic const int nForkFour  = 154000;  /* the 4th hard fork */\nstatic const int nForkFive  = 400000;  /* the 5th hard fork */\n\nstatic const int nSoftForkOne   = 270000;\nstatic const int nSoftForkTwo   = 340000;\n\nstatic const int nTestnetForkOne   = 600;\nstatic const int nTestnetForkTwo   = 3600;\n\nstatic const int nTestnetSoftForkOne   = 3400;\nstatic const int nTestnetSoftForkTwo   = 3500;\n\nstatic const uint nSwitchV2            = 1406851200;   /* 01 Aug 2014 00:00:00 GMT */\nstatic const uint nTestnetSwitchV2     = 1404777600;   /* 08 Jul 2014 00:00:00 GMT */\n\nstatic const int nTargetSpacingZero    = 90;  /* 1.5 minutes */\nstatic const int nTargetSpacingOne     = nTargetSpacingZero;\nstatic const int nTargetSpacingTwo     = 50;  /* 50 seconds */\nstatic const int nTargetSpacingThree   = 45;  /* 45 seconds */\nstatic const int nTargetSpacingFour    = 90;  /* 1.5 minutes */\n\nstatic const int nTargetTimespanZero   = 2400 * nTargetSpacingZero;  /* 60 hours */\nstatic const int nTargetTimespanOne    = 600  * nTargetSpacingOne;   /* 15 hours */\nstatic const int nTargetTimespanTwo    = 108  * nTargetSpacingTwo;   /* 1.5 hours */\nstatic const int nTargetTimespanThree  = 126  * nTargetSpacingThree; /* 1.575 hours */\nstatic const int nTargetTimespanFour   = 20   * nTargetSpacingFour;  /* 0.5 hours */\n\n\nextern CScript COINBASE_FLAGS;\n\nextern CCriticalSection cs_main;\nextern std::map<uint256, CBlockIndex*> mapBlockIndex;\nextern uint256 hashGenesisBlock;\nextern CBlockIndex* pindexGenesisBlock;\nextern int nBestHeight;\nextern CBigNum bnBestChainWork;\nextern CBigNum bnBestInvalidWork;\nextern uint256 hashBestChain;\nextern CBlockIndex* pindexBest;\nextern unsigned int nTransactionsUpdated;\nextern uint64 nLastBlockTx;\nextern uint64 nLastBlockSize;\nextern const std::string strMessageMagic;\nextern double dHashesPerSec;\nextern int64 nHPSTimerStart;\nextern int64 nTimeBestReceived;\nextern CCriticalSection cs_setpwalletRegistered;\nextern std::set<CWallet*> setpwalletRegistered;\nextern std::map<uint256, CBlock*> mapOrphanBlocks;\nextern unsigned char pchMessageStart[4];\n\n// Settings\nextern int64 nTransactionFee;\nextern int64 nMinimumInputValue;\n\n// Minimum disk space required - used in CheckDiskSpace()\nstatic const uint64 nMinDiskSpace = 52428800;\n\n\nclass CReserveKey;\nclass CTxDB;\nclass CTxIndex;\n\nvoid RegisterWallet(CWallet* pwalletIn);\nvoid UnregisterWallet(CWallet* pwalletIn);\nvoid SyncWithWallets(const CTransaction& tx, const CBlock* pblock = NULL, bool fUpdate = false);\nbool ProcessBlock(CNode* pfrom, CBlock* pblock);\nbool CheckDiskSpace(uint64 nAdditionalBytes=0);\nFILE* OpenBlockFile(unsigned int nFile, unsigned int nBlockPos, const char* pszMode=\"rb\");\nFILE* AppendBlockFile(unsigned int& nFileRet);\nbool LoadBlockIndex(bool fAllowNew=true);\nvoid PrintBlockTree();\nbool ProcessMessages(CNode* pfrom);\nbool SendMessages(CNode* pto, bool fSendTrickle);\nbool LoadExternalBlockFile(FILE* fileIn);\nvoid GenerateCoins(bool fGenerate, CWallet* pwallet);\nCBlock* CreateNewBlock(CReserveKey& reservekey);\nvoid IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int& nExtraNonce);\nvoid FormatDataBuffer(CBlock *pblock, uint *pdata);\nbool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey);\nbool CheckProofOfWork(uint256 hash, unsigned int nBits);\nint GetNumBlocksOfPeers();\nbool IsInitialBlockDownload();\nstd::string GetWarnings(std::string strFor);\nbool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock);\nint64 GetBlockValue(int nHeight, int64 nFees);\nvoid ResendWalletTransactions(bool fForce);\n\n\nbool GetWalletFile(CWallet* pwallet, std::string &strWalletFileOut);\n\n/** Position on disk for a particular transaction. */\nclass CDiskTxPos\n{\npublic:\n    unsigned int nFile;\n    unsigned int nBlockPos;\n    unsigned int nTxPos;\n\n    CDiskTxPos()\n    {\n        SetNull();\n    }\n\n    CDiskTxPos(unsigned int nFileIn, unsigned int nBlockPosIn, unsigned int nTxPosIn)\n    {\n        nFile = nFileIn;\n        nBlockPos = nBlockPosIn;\n        nTxPos = nTxPosIn;\n    }\n\n    IMPLEMENT_SERIALIZE( READWRITE(FLATDATA(*this)); )\n    void SetNull() { nFile = (unsigned int) -1; nBlockPos = 0; nTxPos = 0; }\n    bool IsNull() const { return (nFile == (unsigned int) -1); }\n\n    friend bool operator==(const CDiskTxPos& a, const CDiskTxPos& b)\n    {\n        return (a.nFile     == b.nFile &&\n                a.nBlockPos == b.nBlockPos &&\n                a.nTxPos    == b.nTxPos);\n    }\n\n    friend bool operator!=(const CDiskTxPos& a, const CDiskTxPos& b)\n    {\n        return !(a == b);\n    }\n\n    std::string ToString() const\n    {\n        if (IsNull())\n            return \"null\";\n        else\n            return strprintf(\"(nFile=%d, nBlockPos=%d, nTxPos=%d)\", nFile, nBlockPos, nTxPos);\n    }\n\n    void print() const\n    {\n        printf(\"%s\", ToString().c_str());\n    }\n};\n\n\n\n/** An inpoint - a combination of a transaction and an index n into its vin */\nclass CInPoint\n{\npublic:\n    CTransaction* ptx;\n    unsigned int n;\n\n    CInPoint() { SetNull(); }\n    CInPoint(CTransaction* ptxIn, unsigned int nIn) { ptx = ptxIn; n = nIn; }\n    void SetNull() { ptx = NULL; n = (unsigned int) -1; }\n    bool IsNull() const { return (ptx == NULL && n == (unsigned int) -1); }\n};\n\n\n\n/** An outpoint - a combination of a transaction hash and an index n into its vout */\nclass COutPoint\n{\npublic:\n    uint256 hash;\n    unsigned int n;\n\n    COutPoint() { SetNull(); }\n    COutPoint(uint256 hashIn, unsigned int nIn) { hash = hashIn; n = nIn; }\n    IMPLEMENT_SERIALIZE( READWRITE(FLATDATA(*this)); )\n    void SetNull() { hash = 0; n = (unsigned int) -1; }\n    bool IsNull() const { return (hash == 0 && n == (unsigned int) -1); }\n\n    friend bool operator<(const COutPoint& a, const COutPoint& b)\n    {\n        return (a.hash < b.hash || (a.hash == b.hash && a.n < b.n));\n    }\n\n    friend bool operator==(const COutPoint& a, const COutPoint& b)\n    {\n        return (a.hash == b.hash && a.n == b.n);\n    }\n\n    friend bool operator!=(const COutPoint& a, const COutPoint& b)\n    {\n        return !(a == b);\n    }\n\n    std::string ToString() const\n    {\n        return strprintf(\"COutPoint(%s, %d)\", hash.ToString().substr(0,10).c_str(), n);\n    }\n\n    void print() const\n    {\n        printf(\"%s\\n\", ToString().c_str());\n    }\n};\n\n\n\n\n/** An input of a transaction.  It contains the location of the previous\n * transaction's output that it claims and a signature that matches the\n * output's public key.\n */\nclass CTxIn\n{\npublic:\n    COutPoint prevout;\n    CScript scriptSig;\n    unsigned int nSequence;\n\n    CTxIn()\n    {\n        nSequence = std::numeric_limits<unsigned int>::max();\n    }\n\n    explicit CTxIn(COutPoint prevoutIn, CScript scriptSigIn=CScript(), unsigned int nSequenceIn=std::numeric_limits<unsigned int>::max())\n    {\n        prevout = prevoutIn;\n        scriptSig = scriptSigIn;\n        nSequence = nSequenceIn;\n    }\n\n    CTxIn(uint256 hashPrevTx, unsigned int nOut, CScript scriptSigIn=CScript(), unsigned int nSequenceIn=std::numeric_limits<unsigned int>::max())\n    {\n        prevout = COutPoint(hashPrevTx, nOut);\n        scriptSig = scriptSigIn;\n        nSequence = nSequenceIn;\n    }\n\n    IMPLEMENT_SERIALIZE\n    (\n        READWRITE(prevout);\n        READWRITE(scriptSig);\n        READWRITE(nSequence);\n    )\n\n    bool IsFinal() const\n    {\n        return (nSequence == std::numeric_limits<unsigned int>::max());\n    }\n\n    friend bool operator==(const CTxIn& a, const CTxIn& b)\n    {\n        return (a.prevout   == b.prevout &&\n                a.scriptSig == b.scriptSig &&\n                a.nSequence == b.nSequence);\n    }\n\n    friend bool operator!=(const CTxIn& a, const CTxIn& b)\n    {\n        return !(a == b);\n    }\n\n    std::string ToString() const\n    {\n        std::string str;\n        str += \"CTxIn(\";\n        str += prevout.ToString();\n        if (prevout.IsNull())\n            str += strprintf(\", coinbase %s\", HexStr(scriptSig).c_str());\n        else\n            str += strprintf(\", scriptSig=%s\", scriptSig.ToString().substr(0,24).c_str());\n        if (nSequence != std::numeric_limits<unsigned int>::max())\n            str += strprintf(\", nSequence=%u\", nSequence);\n        str += \")\";\n        return str;\n    }\n\n    void print() const\n    {\n        printf(\"%s\\n\", ToString().c_str());\n    }\n};\n\n\n\n\n/** An output of a transaction.  It contains the public key that the next input\n * must be able to sign with to claim it.\n */\nclass CTxOut\n{\npublic:\n    int64 nValue;\n    CScript scriptPubKey;\n\n    CTxOut()\n    {\n        SetNull();\n    }\n\n    CTxOut(int64 nValueIn, CScript scriptPubKeyIn)\n    {\n        nValue = nValueIn;\n        scriptPubKey = scriptPubKeyIn;\n    }\n\n    IMPLEMENT_SERIALIZE\n    (\n        READWRITE(nValue);\n        READWRITE(scriptPubKey);\n    )\n\n    void SetNull()\n    {\n        nValue = -1;\n        scriptPubKey.clear();\n    }\n\n    bool IsNull()\n    {\n        return (nValue == -1);\n    }\n\n    uint256 GetHash() const\n    {\n        return SerializeHash(*this);\n    }\n\n    friend bool operator==(const CTxOut& a, const CTxOut& b)\n    {\n        return (a.nValue       == b.nValue &&\n                a.scriptPubKey == b.scriptPubKey);\n    }\n\n    friend bool operator!=(const CTxOut& a, const CTxOut& b)\n    {\n        return !(a == b);\n    }\n\n    std::string ToString() const\n    {\n        if (scriptPubKey.size() < 6)\n            return \"CTxOut(error)\";\n        return strprintf(\"CTxOut(nValue=%\"PRI64d\".%08\"PRI64d\", scriptPubKey=%s)\", nValue / COIN, nValue % COIN, scriptPubKey.ToString().substr(0,30).c_str());\n    }\n\n    void print() const\n    {\n        printf(\"%s\\n\", ToString().c_str());\n    }\n};\n\n\n\n\nenum GetMinFee_mode\n{\n    GMF_BLOCK,\n    GMF_RELAY,\n    GMF_SEND,\n};\n\ntypedef std::map<uint256, std::pair<CTxIndex, CTransaction> > MapPrevTx;\n\n/** The basic transaction that is broadcasted on the network and contained in\n * blocks.  A transaction can contain multiple inputs and outputs.\n */\nclass CTransaction\n{\npublic:\n    static const int CURRENT_VERSION=1;\n    int nVersion;\n    std::vector<CTxIn> vin;\n    std::vector<CTxOut> vout;\n    unsigned int nLockTime;\n\n    // Denial-of-service detection:\n    mutable int nDoS;\n    bool DoS(int nDoSIn, bool fIn) const { nDoS += nDoSIn; return fIn; }\n\n    CTransaction()\n    {\n        SetNull();\n    }\n\n    IMPLEMENT_SERIALIZE\n    (\n        READWRITE(this->nVersion);\n        nVersion = this->nVersion;\n        READWRITE(vin);\n        READWRITE(vout);\n        READWRITE(nLockTime);\n    )\n\n    void SetNull()\n    {\n        nVersion = CTransaction::CURRENT_VERSION;\n        vin.clear();\n        vout.clear();\n        nLockTime = 0;\n        nDoS = 0;  // Denial-of-service prevention\n    }\n\n    bool IsNull() const\n    {\n        return (vin.empty() && vout.empty());\n    }\n\n    uint256 GetHash() const\n    {\n        return SerializeHash(*this);\n    }\n\n    bool IsFinal(int nBlockHeight=0, int64 nBlockTime=0) const\n    {\n        // Time based nLockTime implemented in 0.1.6\n        if (nLockTime == 0)\n            return true;\n        if (nBlockHeight == 0)\n            nBlockHeight = nBestHeight;\n        if (nBlockTime == 0)\n            nBlockTime = GetAdjustedTime();\n        if ((int64)nLockTime < ((int64)nLockTime < LOCKTIME_THRESHOLD ? (int64)nBlockHeight : nBlockTime))\n            return true;\n        BOOST_FOREACH(const CTxIn& txin, vin)\n            if (!txin.IsFinal())\n                return false;\n        return true;\n    }\n\n    bool IsNewerThan(const CTransaction& old) const\n    {\n        if (vin.size() != old.vin.size())\n            return false;\n        for (unsigned int i = 0; i < vin.size(); i++)\n            if (vin[i].prevout != old.vin[i].prevout)\n                return false;\n\n        bool fNewer = false;\n        unsigned int nLowest = std::numeric_limits<unsigned int>::max();\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            if (vin[i].nSequence != old.vin[i].nSequence)\n            {\n                if (vin[i].nSequence <= nLowest)\n                {\n                    fNewer = false;\n                    nLowest = vin[i].nSequence;\n                }\n                if (old.vin[i].nSequence < nLowest)\n                {\n                    fNewer = true;\n                    nLowest = old.vin[i].nSequence;\n                }\n            }\n        }\n        return fNewer;\n    }\n\n    bool IsCoinBase() const\n    {\n        return (vin.size() == 1 && vin[0].prevout.IsNull());\n    }\n\n    /** Check for standard transaction types\n        @return True if all outputs (scriptPubKeys) use only standard transaction forms\n    */\n    bool IsStandard() const;\n\n    /** Check for standard transaction types\n        @param[in] mapInputs\tMap of previous transactions that have outputs we're spending\n        @return True if all inputs (scriptSigs) use only standard transaction forms\n        @see CTransaction::FetchInputs\n    */\n    bool AreInputsStandard(const MapPrevTx& mapInputs) const;\n\n    /** Count ECDSA signature operations the old-fashioned (pre-0.6) way\n        @return number of sigops this transaction's outputs will produce when spent\n        @see CTransaction::FetchInputs\n    */\n    unsigned int GetLegacySigOpCount() const;\n\n    /** Count ECDSA signature operations in pay-to-script-hash inputs.\n\n        @param[in] mapInputs\tMap of previous transactions that have outputs we're spending\n        @return maximum number of sigops required to validate this transaction's inputs\n        @see CTransaction::FetchInputs\n     */\n    unsigned int GetP2SHSigOpCount(const MapPrevTx& mapInputs) const;\n\n    /** Amount of bitcoins spent by this transaction.\n        @return sum of all outputs (note: does not include fees)\n     */\n    int64 GetValueOut() const\n    {\n        int64 nValueOut = 0;\n        BOOST_FOREACH(const CTxOut& txout, vout)\n        {\n            nValueOut += txout.nValue;\n            if (!MoneyRange(txout.nValue) || !MoneyRange(nValueOut))\n                throw std::runtime_error(\"CTransaction::GetValueOut() : value out of range\");\n        }\n        return nValueOut;\n    }\n\n    /** Amount of bitcoins coming in to this transaction\n        Note that lightweight clients may not know anything besides the hash of previous transactions,\n        so may not be able to calculate this.\n\n        @param[in] mapInputs\tMap of previous transactions that have outputs we're spending\n        @return\tSum of value of all inputs (scriptSigs)\n        @see CTransaction::FetchInputs\n     */\n    int64 GetValueIn(const MapPrevTx& mapInputs) const;\n\n    static bool AllowFree(double dPriority)\n    {\n        // High priority transactions are exempt of mandatory fees usually\n        // Phoenixcoin: 960 blocks per day target, priority boundary is 1 PXC day / 250 bytes\n        return dPriority > COIN * 960 / 250;\n    }\n\n    int64 GetMinFee(unsigned int nTxSize, bool fAllowFree, enum GetMinFee_mode mode) const {\n\n        // Base fee is either MIN_TX_FEE or MIN_RELAY_TX_FEE\n        int64 nBaseFee = (mode == GMF_RELAY) ? MIN_RELAY_TX_FEE : MIN_TX_FEE;\n\n        unsigned int nNewBlockSize = (mode == GMF_SEND) ? nTxSize : 1000 + nTxSize;\n        // Add a base fee per every 1000 bytes of transaction data\n        int64 nMinFee = (1 + (int64)nTxSize / 1000) * nBaseFee;\n\n        if(fAllowFree) {\n            if(mode == GMF_SEND) {\n                // Limit size of free high priority transactions\n                if(nTxSize < 2000) nMinFee = 0;\n            } else {\n                // GMF_BLOCK, GMF_RELAY:\n                // Limit block space for free transactions\n                if(nNewBlockSize < 16000) nMinFee = 0;\n            }\n        }\n\n        // Dust spam filter: require a base fee for any micro output\n        BOOST_FOREACH(const CTxOut& txout, vout)\n          if(txout.nValue < TX_DUST) nMinFee += nBaseFee;\n\n        // Raise the price as the block approaches full\n        if((mode != GMF_SEND) && (nNewBlockSize >= MAX_BLOCK_SIZE_GEN/2)) {\n            if(nNewBlockSize >= MAX_BLOCK_SIZE_GEN) return MAX_MONEY;\n            nMinFee *= MAX_BLOCK_SIZE_GEN / (MAX_BLOCK_SIZE_GEN - nNewBlockSize);\n            if(!MoneyRange(nMinFee)) nMinFee = MAX_MONEY;\n        }\n\n        return nMinFee;\n    }\n\n    bool ReadFromDisk(CDiskTxPos pos, FILE** pfileRet=NULL)\n    {\n        CAutoFile filein = CAutoFile(OpenBlockFile(pos.nFile, 0, pfileRet ? \"rb+\" : \"rb\"), SER_DISK, CLIENT_VERSION);\n        if (!filein)\n            return error(\"CTransaction::ReadFromDisk() : OpenBlockFile failed\");\n\n        // Read transaction\n        if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n            return error(\"CTransaction::ReadFromDisk() : fseek failed\");\n\n        try {\n            filein >> *this;\n        }\n        catch (std::exception &e) {\n            return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n        }\n\n        // Return file pointer\n        if (pfileRet)\n        {\n            if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n                return error(\"CTransaction::ReadFromDisk() : second fseek failed\");\n            *pfileRet = filein.release();\n        }\n        return true;\n    }\n\n    friend bool operator==(const CTransaction& a, const CTransaction& b)\n    {\n        return (a.nVersion  == b.nVersion &&\n                a.vin       == b.vin &&\n                a.vout      == b.vout &&\n                a.nLockTime == b.nLockTime);\n    }\n\n    friend bool operator!=(const CTransaction& a, const CTransaction& b)\n    {\n        return !(a == b);\n    }\n\n\n    std::string ToString() const\n    {\n        std::string str;\n        str += strprintf(\"CTransaction(hash=%s, ver=%d, vin.size=%d, vout.size=%d, nLockTime=%d)\\n\",\n            GetHash().ToString().substr(0,10).c_str(),\n            nVersion,\n            vin.size(),\n            vout.size(),\n            nLockTime);\n        for (unsigned int i = 0; i < vin.size(); i++)\n            str += \"    \" + vin[i].ToString() + \"\\n\";\n        for (unsigned int i = 0; i < vout.size(); i++)\n            str += \"    \" + vout[i].ToString() + \"\\n\";\n        return str;\n    }\n\n    void print() const\n    {\n        printf(\"%s\", ToString().c_str());\n    }\n\n\n    bool ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet);\n    bool ReadFromDisk(CTxDB& txdb, COutPoint prevout);\n    bool ReadFromDisk(COutPoint prevout);\n    bool DisconnectInputs(CTxDB& txdb);\n\n    /** Fetch from memory and/or disk. inputsRet keys are transaction hashes.\n\n     @param[in] txdb\tTransaction database\n     @param[in] mapTestPool\tList of pending changes to the transaction index database\n     @param[in] fBlock\tTrue if being called to add a new best-block to the chain\n     @param[in] fMiner\tTrue if being called by CreateNewBlock\n     @param[out] inputsRet\tPointers to this transaction's inputs\n     @param[out] fInvalid\treturns true if transaction is invalid\n     @return\tReturns true if all inputs are in txdb or mapTestPool\n     */\n    bool FetchInputs(CTxDB& txdb, const std::map<uint256, CTxIndex>& mapTestPool,\n                     bool fBlock, bool fMiner, MapPrevTx& inputsRet, bool& fInvalid);\n\n    /** Sanity check previous transactions, then, if all checks succeed,\n        mark them as spent by this transaction.\n\n        @param[in] inputs\tPrevious transactions (from FetchInputs)\n        @param[out] mapTestPool\tKeeps track of inputs that need to be updated on disk\n        @param[in] posThisTx\tPosition of this transaction on disk\n        @param[in] pindexBlock\n        @param[in] fBlock\ttrue if called from ConnectBlock\n        @param[in] fMiner\ttrue if called from CreateNewBlock\n        @param[in] fStrictPayToScriptHash\ttrue if fully validating p2sh transactions\n        @return Returns true if all checks succeed\n     */\n    bool ConnectInputs(MapPrevTx inputs,\n                       std::map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n                       const CBlockIndex* pindexBlock, bool fBlock, bool fMiner, bool fStrictPayToScriptHash=true);\n    bool ClientConnectInputs();\n    bool CheckTransaction() const;\n    bool AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs=true, bool* pfMissingInputs=NULL);\n\nprotected:\n    const CTxOut& GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const;\n};\n\n\n\n\n\n/** A transaction with a merkle branch linking it to the block chain. */\nclass CMerkleTx : public CTransaction\n{\npublic:\n    uint256 hashBlock;\n    std::vector<uint256> vMerkleBranch;\n    int nIndex;\n\n    // memory only\n    mutable bool fMerkleVerified;\n\n\n    CMerkleTx()\n    {\n        Init();\n    }\n\n    CMerkleTx(const CTransaction& txIn) : CTransaction(txIn)\n    {\n        Init();\n    }\n\n    void Init()\n    {\n        hashBlock = 0;\n        nIndex = -1;\n        fMerkleVerified = false;\n    }\n\n\n    IMPLEMENT_SERIALIZE\n    (\n        nSerSize += SerReadWrite(s, *(CTransaction*)this, nType, nVersion, ser_action);\n        nVersion = this->nVersion;\n        READWRITE(hashBlock);\n        READWRITE(vMerkleBranch);\n        READWRITE(nIndex);\n    )\n\n\n    int SetMerkleBranch(const CBlock* pblock=NULL);\n    int GetDepthInMainChain(CBlockIndex* &pindexRet) const;\n    int GetDepthInMainChain() const { CBlockIndex *pindexRet; return GetDepthInMainChain(pindexRet); }\n    bool IsInMainChain() const { return GetDepthInMainChain() > 0; }\n    int GetBlocksToMaturity() const;\n    bool AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs=true);\n    bool AcceptToMemoryPool();\n};\n\n\n\n\n/**  A txdb record that contains the disk location of a transaction and the\n * locations of transactions that spend its outputs.  vSpent is really only\n * used as a flag, but having the location is very helpful for debugging.\n */\nclass CTxIndex\n{\npublic:\n    CDiskTxPos pos;\n    std::vector<CDiskTxPos> vSpent;\n\n    CTxIndex()\n    {\n        SetNull();\n    }\n\n    CTxIndex(const CDiskTxPos& posIn, unsigned int nOutputs)\n    {\n        pos = posIn;\n        vSpent.resize(nOutputs);\n    }\n\n    IMPLEMENT_SERIALIZE\n    (\n        if (!(nType & SER_GETHASH))\n            READWRITE(nVersion);\n        READWRITE(pos);\n        READWRITE(vSpent);\n    )\n\n    void SetNull()\n    {\n        pos.SetNull();\n        vSpent.clear();\n    }\n\n    bool IsNull()\n    {\n        return pos.IsNull();\n    }\n\n    friend bool operator==(const CTxIndex& a, const CTxIndex& b)\n    {\n        return (a.pos    == b.pos &&\n                a.vSpent == b.vSpent);\n    }\n\n    friend bool operator!=(const CTxIndex& a, const CTxIndex& b)\n    {\n        return !(a == b);\n    }\n \n};\n\n\n\n\n\n/** Nodes collect new transactions into a block, hash them into a hash tree,\n * and scan through nonce values to make the block's hash satisfy proof-of-work\n * requirements.  When they solve the proof-of-work, they broadcast the block\n * to everyone and the block is added to the block chain.  The first transaction\n * in the block is a special one that creates a new coin owned by the creator\n * of the block.\n *\n * Blocks are appended to blk0001.dat files on disk.  Their location on disk\n * is indexed by CBlockIndex objects in memory.\n */\nclass CBlock\n{\npublic:\n    // header\n    static const int CURRENT_VERSION = 2;\n    int nVersion;\n    uint256 hashPrevBlock;\n    uint256 hashMerkleRoot;\n    unsigned int nTime;\n    unsigned int nBits;\n    unsigned int nNonce;\n\n    // network and disk\n    std::vector<CTransaction> vtx;\n\n    // memory only\n    mutable std::vector<uint256> vMerkleTree;\n\n    // Denial-of-service detection:\n    mutable int nDoS;\n    bool DoS(int nDoSIn, bool fIn) const { nDoS += nDoSIn; return fIn; }\n\n    CBlock()\n    {\n        SetNull();\n    }\n\n    IMPLEMENT_SERIALIZE\n    (\n        READWRITE(this->nVersion);\n        nVersion = this->nVersion;\n        READWRITE(hashPrevBlock);\n        READWRITE(hashMerkleRoot);\n        READWRITE(nTime);\n        READWRITE(nBits);\n        READWRITE(nNonce);\n\n        // ConnectBlock depends on vtx being last so it can calculate offset\n        if (!(nType & (SER_GETHASH|SER_BLOCKHEADERONLY)))\n            READWRITE(vtx);\n        else if (fRead)\n            const_cast<CBlock*>(this)->vtx.clear();\n    )\n\n    void SetNull()\n    {\n        nVersion = CBlock::CURRENT_VERSION;\n        hashPrevBlock = 0;\n        hashMerkleRoot = 0;\n        nTime = 0;\n        nBits = 0;\n        nNonce = 0;\n        vtx.clear();\n        vMerkleTree.clear();\n        nDoS = 0;\n    }\n\n    bool IsNull() const\n    {\n        return (nBits == 0);\n    }\n\n    uint256 GetHash() const\n    {\n        return Hash(BEGIN(nVersion), END(nNonce));\n    }\n\n    /* Calculates block proof-of-work hash using either NeoScrypt or Scrypt */\n    uint256 GetPoWHash() const {\n        uint profile = 0x0;\n        uint256 hash;\n\n        /* All blocks generated up to this time point are Scrypt only */\n        if((fTestNet && (nTime < nTestnetSwitchV2)) ||\n          (!fTestNet && (nTime < nSwitchV2))) {\n            profile = 0x3;\n        } else {\n            /* All these blocks must be v2+ with valid nHeight */\n            int nHeight = GetBlockHeight();\n            if(fTestNet) {\n                if(nHeight < nTestnetForkTwo)\n                  profile = 0x3;\n            } else {\n                if(nHeight < nForkFive)\n                  profile = 0x3;\n            }\n        }\n\n        neoscrypt((uchar *) &nVersion, (uchar *) &hash, profile);\n\n        return(hash);\n    }\n\n    /* Extracts block height from v2+ coin base;\n     * ignores nVersion because it's unrealiable */\n    int GetBlockHeight() const {\n        /* Prevents a crash if called on a block header alone */\n        if(vtx.size()) {\n            /* Serialised CScript */\n            std::vector<uchar>::const_iterator scriptsig = vtx[0].vin[0].scriptSig.begin();\n            uchar i, scount = scriptsig[0];\n            /* Optimise: nTime is 4 bytes always,\n             * nHeight must be less for a long time;\n             * check against a threshold when the time comes */\n            if(scount < 4) {\n                int height = 0;\n                uchar *pheight = (uchar *) &height;\n                for(i = 0; i < scount; i++)\n                  pheight[i] = scriptsig[i + 1];\n                /* v2+ block with nHeight in coin base */\n                return(height);\n            }\n        }\n        /* Not found */\n        return(-1);\n    }\n\n    int64 GetBlockTime() const\n    {\n        return (int64)nTime;\n    }\n\n    void UpdateTime(const CBlockIndex* pindexPrev);\n\n\n    uint256 BuildMerkleTree() const\n    {\n        vMerkleTree.clear();\n        BOOST_FOREACH(const CTransaction& tx, vtx)\n            vMerkleTree.push_back(tx.GetHash());\n        int j = 0;\n        for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n        {\n            for (int i = 0; i < nSize; i += 2)\n            {\n                int i2 = std::min(i+1, nSize-1);\n                vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n                                           BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n            }\n            j += nSize;\n        }\n        return (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n    }\n\n    std::vector<uint256> GetMerkleBranch(int nIndex) const\n    {\n        if (vMerkleTree.empty())\n            BuildMerkleTree();\n        std::vector<uint256> vMerkleBranch;\n        int j = 0;\n        for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n        {\n            int i = std::min(nIndex^1, nSize-1);\n            vMerkleBranch.push_back(vMerkleTree[j+i]);\n            nIndex >>= 1;\n            j += nSize;\n        }\n        return vMerkleBranch;\n    }\n\n    static uint256 CheckMerkleBranch(uint256 hash, const std::vector<uint256>& vMerkleBranch, int nIndex)\n    {\n        if (nIndex == -1)\n            return 0;\n        BOOST_FOREACH(const uint256& otherside, vMerkleBranch)\n        {\n            if (nIndex & 1)\n                hash = Hash(BEGIN(otherside), END(otherside), BEGIN(hash), END(hash));\n            else\n                hash = Hash(BEGIN(hash), END(hash), BEGIN(otherside), END(otherside));\n            nIndex >>= 1;\n        }\n        return hash;\n    }\n\n\n    bool WriteToDisk(unsigned int& nFileRet, unsigned int& nBlockPosRet)\n    {\n        // Open history file to append\n        CAutoFile fileout = CAutoFile(AppendBlockFile(nFileRet), SER_DISK, CLIENT_VERSION);\n        if(!fileout)\n          return error(\"CBlock::WriteToDisk() : AppendBlockFile() failed\");\n\n        // Write index header\n        unsigned int nSize = fileout.GetSerializeSize(*this);\n        fileout << FLATDATA(pchMessageStart) << nSize;\n\n        // Write block\n        long fileOutPos = ftell(fileout);\n        if(fileOutPos < 0)\n          return error(\"CBlock::WriteToDisk() : ftell() failed\");\n        nBlockPosRet = fileOutPos;\n        fileout << *this;\n\n        // Flush stdio buffers and commit to disk before returning\n        fflush(fileout);\n        if(!IsInitialBlockDownload() || ((nBestHeight+1) % 100 == 0)) {\n            if(FileCommit(fileout))\n              return error(\"CBlock::WriteToDisk() : FileCommit() failed\");\n        }\n\n        return true;\n    }\n\n    bool ReadFromDisk(unsigned int nFile, unsigned int nBlockPos, bool fReadTransactions=true)\n    {\n        SetNull();\n\n        // Open history file to read\n        CAutoFile filein = CAutoFile(OpenBlockFile(nFile, nBlockPos, \"rb\"), SER_DISK, CLIENT_VERSION);\n        if(!filein)\n          return error(\"CBlock::ReadFromDisk() : OpenBlockFile() failed\");\n        if(!fReadTransactions) filein.nType |= SER_BLOCKHEADERONLY;\n\n        // Read block\n        try {\n            filein >> *this;\n        }\n        catch(std::exception &e) {\n            return error(\"CBlock::ReadFromDisk() : I/O error\");\n        }\n\n        return true;\n    }\n\n\n\n    void print() const\n    {\n        printf(\"CBlock(hash=%s, PoW=%s, ver=%d, hashPrevBlock=%s, hashMerkleRoot=%s, nTime=%u, nBits=%08x, nNonce=%u, vtx=%d)\\n\",\n            GetHash().ToString().substr(0,20).c_str(),\n            GetPoWHash().ToString().substr(0,20).c_str(),\n            nVersion,\n            hashPrevBlock.ToString().substr(0,20).c_str(),\n            hashMerkleRoot.ToString().substr(0,10).c_str(),\n            nTime, nBits, nNonce,\n            vtx.size());\n        for (unsigned int i = 0; i < vtx.size(); i++)\n        {\n            printf(\"  \");\n            vtx[i].print();\n        }\n        printf(\"  vMerkleTree: \");\n        for (unsigned int i = 0; i < vMerkleTree.size(); i++)\n            printf(\"%s \", vMerkleTree[i].ToString().substr(0,10).c_str());\n        printf(\"\\n\");\n    }\n\n\n    bool DisconnectBlock(CTxDB& txdb, CBlockIndex* pindex);\n    bool ConnectBlock(CTxDB& txdb, CBlockIndex* pindex);\n    bool ReadFromDisk(const CBlockIndex* pindex, bool fReadTransactions=true);\n    bool SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew);\n    bool AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos);\n    bool CheckBlock() const;\n    bool AcceptBlock();\n\nprivate:\n    bool SetBestChainInner(CTxDB& txdb, CBlockIndex *pindexNew);\n};\n\n\n\n\n\n\n/** The block chain is a tree shaped structure starting with the\n * genesis block at the root, with each block potentially having multiple\n * candidates to be the next block.  pprev and pnext link a path through the\n * main/longest chain.  A blockindex may have multiple pprev pointing back\n * to it, but pnext will only point forward to the longest branch, or will\n * be null if the block is not part of the longest chain.\n */\nclass CBlockIndex\n{\npublic:\n    const uint256* phashBlock;\n    CBlockIndex* pprev;\n    CBlockIndex* pnext;\n    unsigned int nFile;\n    unsigned int nBlockPos;\n    int nHeight;\n    CBigNum bnChainWork;\n\n    // block header\n    int nVersion;\n    uint256 hashMerkleRoot;\n    unsigned int nTime;\n    unsigned int nBits;\n    unsigned int nNonce;\n\n\n    CBlockIndex()\n    {\n        phashBlock = NULL;\n        pprev = NULL;\n        pnext = NULL;\n        nFile = 0;\n        nBlockPos = 0;\n        nHeight = 0;\n        bnChainWork = 0;\n\n        nVersion       = 0;\n        hashMerkleRoot = 0;\n        nTime          = 0;\n        nBits          = 0;\n        nNonce         = 0;\n    }\n\n    CBlockIndex(unsigned int nFileIn, unsigned int nBlockPosIn, CBlock& block)\n    {\n        phashBlock = NULL;\n        pprev = NULL;\n        pnext = NULL;\n        nFile = nFileIn;\n        nBlockPos = nBlockPosIn;\n        nHeight = 0;\n        bnChainWork = 0;\n\n        nVersion       = block.nVersion;\n        hashMerkleRoot = block.hashMerkleRoot;\n        nTime          = block.nTime;\n        nBits          = block.nBits;\n        nNonce         = block.nNonce;\n    }\n\n    CBlock GetBlockHeader() const\n    {\n        CBlock block;\n        block.nVersion       = nVersion;\n        if (pprev)\n            block.hashPrevBlock = pprev->GetBlockHash();\n        block.hashMerkleRoot = hashMerkleRoot;\n        block.nTime          = nTime;\n        block.nBits          = nBits;\n        block.nNonce         = nNonce;\n        return block;\n    }\n\n    uint256 GetBlockHash() const\n    {\n        return *phashBlock;\n    }\n\n    int64 GetBlockTime() const\n    {\n        return (int64)nTime;\n    }\n\n    CBigNum GetBlockWork() const\n    {\n        CBigNum bnTarget;\n        bnTarget.SetCompact(nBits);\n        if (bnTarget <= 0)\n            return 0;\n        return (CBigNum(1)<<256) / (bnTarget+1);\n    }\n\n    bool IsInMainChain() const\n    {\n        return (pnext || this == pindexBest);\n    }\n\n    bool CheckIndex() const\n    {\n        return true; // CheckProofOfWork(GetBlockHash(), nBits);\n    }\n\n    enum { nMedianTimeSpan=11 };\n\n    int64 GetMedianTimePast() const\n    {\n        int64 pmedian[nMedianTimeSpan];\n        int64* pbegin = &pmedian[nMedianTimeSpan];\n        int64* pend = &pmedian[nMedianTimeSpan];\n\n        const CBlockIndex* pindex = this;\n        for (int i = 0; i < nMedianTimeSpan && pindex; i++, pindex = pindex->pprev)\n            *(--pbegin) = pindex->GetBlockTime();\n\n        std::sort(pbegin, pend);\n        return pbegin[(pend - pbegin)/2];\n    }\n\n    int64 GetMedianTime() const\n    {\n        const CBlockIndex* pindex = this;\n        for (int i = 0; i < nMedianTimeSpan/2; i++)\n        {\n            if (!pindex->pnext)\n                return GetBlockTime();\n            pindex = pindex->pnext;\n        }\n        return pindex->GetMedianTimePast();\n    }\n\n    /* Advanced average block time calculator */\n    uint GetAverageTimePast(uint nAvgTimeSpan, uint nMinDelay) const {\n        uint avg[nAvgTimeSpan], nTempTime, i;\n        uint64 nAvgAccum;\n        const CBlockIndex* pindex = this;\n\n        /* Keep it fail safe */\n        if(!nAvgTimeSpan) return(0);\n\n        /* Initialise the elements to zero */\n        for(i = 0; i < nAvgTimeSpan; i++)\n          avg[i] = 0;\n\n        /* Fill with the time stamps */\n        for(i = nAvgTimeSpan; i && pindex; i--, pindex = pindex->pprev)\n          avg[i-1] = pindex->nTime;\n\n        /* Not enough input blocks */\n        if(!avg[0]) return(0);\n\n        /* Time travel aware accumulator */\n        nTempTime = avg[0];\n        for(i = 1, nAvgAccum = nTempTime; i < nAvgTimeSpan; i++) { \n            /* Update the accumulator either with an actual or minimal\n             * delay supplied to prevent extremely fast blocks */\n            if(avg[i] < (nTempTime + nMinDelay))\n              nTempTime += nMinDelay;\n            else\n              nTempTime  = avg[i];\n            nAvgAccum += nTempTime;\n        }\n\n        nTempTime = (uint)(nAvgAccum/(uint64)nAvgTimeSpan);\n\n        return(nTempTime);\n    }\n\n    std::string ToString() const\n    {\n        return strprintf(\"CBlockIndex(nprev=%08x, pnext=%08x, nFile=%d, nBlockPos=%-6d nHeight=%d, merkle=%s, hashBlock=%s)\",\n            pprev, pnext, nFile, nBlockPos, nHeight,\n            hashMerkleRoot.ToString().substr(0,10).c_str(),\n            GetBlockHash().ToString().substr(0,20).c_str());\n    }\n\n    void print() const\n    {\n        printf(\"%s\\n\", ToString().c_str());\n    }\n};\n\n\n\n/** Used to marshal pointers into hashes for db storage. */\nclass CDiskBlockIndex : public CBlockIndex\n{\npublic:\n    uint256 hashPrev;\n    uint256 hashNext;\n\n    CDiskBlockIndex()\n    {\n        hashPrev = 0;\n        hashNext = 0;\n    }\n\n    explicit CDiskBlockIndex(CBlockIndex* pindex) : CBlockIndex(*pindex)\n    {\n        hashPrev = (pprev ? pprev->GetBlockHash() : 0);\n        hashNext = (pnext ? pnext->GetBlockHash() : 0);\n    }\n\n    IMPLEMENT_SERIALIZE\n    (\n        if (!(nType & SER_GETHASH))\n            READWRITE(nVersion);\n\n        READWRITE(hashNext);\n        READWRITE(nFile);\n        READWRITE(nBlockPos);\n        READWRITE(nHeight);\n\n        // block header\n        READWRITE(this->nVersion);\n        READWRITE(hashPrev);\n        READWRITE(hashMerkleRoot);\n        READWRITE(nTime);\n        READWRITE(nBits);\n        READWRITE(nNonce);\n    )\n\n    uint256 GetBlockHash() const\n    {\n        CBlock block;\n        block.nVersion        = nVersion;\n        block.hashPrevBlock   = hashPrev;\n        block.hashMerkleRoot  = hashMerkleRoot;\n        block.nTime           = nTime;\n        block.nBits           = nBits;\n        block.nNonce          = nNonce;\n        return block.GetHash();\n    }\n\n\n    std::string ToString() const\n    {\n        std::string str = \"CDiskBlockIndex(\";\n        str += CBlockIndex::ToString();\n        str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n            GetBlockHash().ToString().c_str(),\n            hashPrev.ToString().substr(0,20).c_str(),\n            hashNext.ToString().substr(0,20).c_str());\n        return str;\n    }\n\n    void print() const\n    {\n        printf(\"%s\\n\", ToString().c_str());\n    }\n};\n\n\n\n\n\n\n\n\n/** Describes a place in the block chain to another node such that if the\n * other node doesn't have the same branch, it can find a recent common trunk.\n * The further back it is, the further before the fork it may be.\n */\nclass CBlockLocator\n{\nprotected:\n    std::vector<uint256> vHave;\npublic:\n\n    CBlockLocator()\n    {\n    }\n\n    explicit CBlockLocator(const CBlockIndex* pindex)\n    {\n        Set(pindex);\n    }\n\n    explicit CBlockLocator(uint256 hashBlock)\n    {\n        std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n        if (mi != mapBlockIndex.end())\n            Set((*mi).second);\n    }\n\n    CBlockLocator(const std::vector<uint256>& vHaveIn)\n    {\n        vHave = vHaveIn;\n    }\n\n    IMPLEMENT_SERIALIZE\n    (\n        if (!(nType & SER_GETHASH))\n            READWRITE(nVersion);\n        READWRITE(vHave);\n    )\n\n    void SetNull()\n    {\n        vHave.clear();\n    }\n\n    bool IsNull()\n    {\n        return vHave.empty();\n    }\n\n    void Set(const CBlockIndex* pindex)\n    {\n        vHave.clear();\n        int nStep = 1;\n        while (pindex)\n        {\n            vHave.push_back(pindex->GetBlockHash());\n\n            // Exponentially larger steps back\n            for (int i = 0; pindex && i < nStep; i++)\n                pindex = pindex->pprev;\n            if (vHave.size() > 10)\n                nStep *= 2;\n        }\n        vHave.push_back(hashGenesisBlock);\n    }\n\n    int GetDistanceBack()\n    {\n        // Retrace how far back it was in the sender's branch\n        int nDistance = 0;\n        int nStep = 1;\n        BOOST_FOREACH(const uint256& hash, vHave)\n        {\n            std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n            if (mi != mapBlockIndex.end())\n            {\n                CBlockIndex* pindex = (*mi).second;\n                if (pindex->IsInMainChain())\n                    return nDistance;\n            }\n            nDistance += nStep;\n            if (nDistance > 10)\n                nStep *= 2;\n        }\n        return nDistance;\n    }\n\n    CBlockIndex* GetBlockIndex()\n    {\n        // Find the first block the caller has in the main chain\n        BOOST_FOREACH(const uint256& hash, vHave)\n        {\n            std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n            if (mi != mapBlockIndex.end())\n            {\n                CBlockIndex* pindex = (*mi).second;\n                if (pindex->IsInMainChain())\n                    return pindex;\n            }\n        }\n        return pindexGenesisBlock;\n    }\n\n    uint256 GetBlockHash()\n    {\n        // Find the first block the caller has in the main chain\n        BOOST_FOREACH(const uint256& hash, vHave)\n        {\n            std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n            if (mi != mapBlockIndex.end())\n            {\n                CBlockIndex* pindex = (*mi).second;\n                if (pindex->IsInMainChain())\n                    return hash;\n            }\n        }\n        return hashGenesisBlock;\n    }\n\n    int GetHeight()\n    {\n        CBlockIndex* pindex = GetBlockIndex();\n        if (!pindex)\n            return 0;\n        return pindex->nHeight;\n    }\n};\n\n\n\n\n\n\n\n\n\n/** Alerts are for notifying old versions if they become too obsolete and\n * need to upgrade.  The message is displayed in the status bar.\n * Alert messages are broadcast as a vector of signed data.  Unserializing may\n * not read the entire buffer if the alert is for a newer version, but older\n * versions can still relay the original data.\n */\n\nstatic const char* pszMainKey = \"04f62e0a932afc0190785e5a1f0d58ce4be8da4ff4581e8e297991245bf2f0b4c1a226847afb802887e9812ff0346fbdbca984f518fce550977f08dae190fa5c0a\";\nstatic const char* pszTestKey = \"04e2aeb8d9997e92f5d98fd7f276ae1f83550f4bfffdf68c37e9d00783fbb5b3f959426ab048d30495dbef27c17e9162fb3929b189ef0f294e6d713999470d307b\";\n\nclass CUnsignedAlert\n{\npublic:\n    int nVersion;\n    int64 nRelayUntil;      // when newer nodes stop relaying to newer nodes\n    int64 nExpiration;\n    int nID;\n    int nCancel;\n    std::set<int> setCancel;\n    int nMinVer;            // lowest version inclusive\n    int nMaxVer;            // highest version inclusive\n    std::set<std::string> setSubVer;  // empty matches all\n    int nPriority;\n\n    // Actions\n    std::string strComment;\n    std::string strStatusBar;\n    std::string strReserved;\n\n    IMPLEMENT_SERIALIZE\n    (\n        READWRITE(this->nVersion);\n        nVersion = this->nVersion;\n        READWRITE(nRelayUntil);\n        READWRITE(nExpiration);\n        READWRITE(nID);\n        READWRITE(nCancel);\n        READWRITE(setCancel);\n        READWRITE(nMinVer);\n        READWRITE(nMaxVer);\n        READWRITE(setSubVer);\n        READWRITE(nPriority);\n\n        READWRITE(strComment);\n        READWRITE(strStatusBar);\n        READWRITE(strReserved);\n    )\n\n    void SetNull()\n    {\n        nVersion = 1;\n        nRelayUntil = 0;\n        nExpiration = 0;\n        nID = 0;\n        nCancel = 0;\n        setCancel.clear();\n        nMinVer = 0;\n        nMaxVer = 0;\n        setSubVer.clear();\n        nPriority = 0;\n\n        strComment.clear();\n        strStatusBar.clear();\n        strReserved.clear();\n    }\n\n    std::string ToString() const\n    {\n        std::string strSetCancel;\n        BOOST_FOREACH(int n, setCancel)\n            strSetCancel += strprintf(\"%d \", n);\n        std::string strSetSubVer;\n        BOOST_FOREACH(std::string str, setSubVer)\n            strSetSubVer += \"\\\"\" + str + \"\\\" \";\n        return strprintf(\n                \"CAlert(\\n\"\n                \"    nVersion     = %d\\n\"\n                \"    nRelayUntil  = %\"PRI64d\"\\n\"\n                \"    nExpiration  = %\"PRI64d\"\\n\"\n                \"    nID          = %d\\n\"\n                \"    nCancel      = %d\\n\"\n                \"    setCancel    = %s\\n\"\n                \"    nMinVer      = %d\\n\"\n                \"    nMaxVer      = %d\\n\"\n                \"    setSubVer    = %s\\n\"\n                \"    nPriority    = %d\\n\"\n                \"    strComment   = \\\"%s\\\"\\n\"\n                \"    strStatusBar = \\\"%s\\\"\\n\"\n                \")\\n\",\n            nVersion,\n            nRelayUntil,\n            nExpiration,\n            nID,\n            nCancel,\n            strSetCancel.c_str(),\n            nMinVer,\n            nMaxVer,\n            strSetSubVer.c_str(),\n            nPriority,\n            strComment.c_str(),\n            strStatusBar.c_str());\n    }\n\n    void print() const\n    {\n        printf(\"%s\", ToString().c_str());\n    }\n};\n\n/** An alert is a combination of a serialized CUnsignedAlert and a signature. */\nclass CAlert : public CUnsignedAlert\n{\npublic:\n    std::vector<unsigned char> vchMsg;\n    std::vector<unsigned char> vchSig;\n\n    CAlert()\n    {\n        SetNull();\n    }\n\n    IMPLEMENT_SERIALIZE\n    (\n        READWRITE(vchMsg);\n        READWRITE(vchSig);\n    )\n\n    void SetNull()\n    {\n        CUnsignedAlert::SetNull();\n        vchMsg.clear();\n        vchSig.clear();\n    }\n\n    bool IsNull() const\n    {\n        return (nExpiration == 0);\n    }\n\n    uint256 GetHash() const\n    {\n        return SerializeHash(*this);\n    }\n\n    bool IsInEffect() const\n    {\n        return (GetAdjustedTime() < nExpiration);\n    }\n\n    bool Cancels(const CAlert& alert) const\n    {\n        if (!IsInEffect())\n            return false; // this was a no-op before 31403\n        return (alert.nID <= nCancel || setCancel.count(alert.nID));\n    }\n\n    bool AppliesTo(int nVersion, std::string strSubVerIn) const\n    {\n        // TODO: rework for client-version-embedded-in-strSubVer ?\n        return (IsInEffect() &&\n                nMinVer <= nVersion && nVersion <= nMaxVer &&\n                (setSubVer.empty() || setSubVer.count(strSubVerIn)));\n    }\n\n    bool AppliesToMe() const\n    {\n        return AppliesTo(PROTOCOL_VERSION, FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, std::vector<std::string>()));\n    }\n\n    bool RelayTo(CNode* pnode) const\n    {\n        if (!IsInEffect())\n            return false;\n        // returns true if wasn't already contained in the set\n        if (pnode->setKnown.insert(GetHash()).second)\n        {\n            if (AppliesTo(pnode->nVersion, pnode->strSubVer) ||\n                AppliesToMe() ||\n                GetAdjustedTime() < nRelayUntil)\n            {\n                pnode->PushMessage(\"alert\", *this);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    bool CheckSignature() const\n    {\n\n        CKey key;\n        if (!key.SetPubKey(ParseHex(fTestNet ? pszTestKey : pszMainKey)))\n          return error(\"CAlert::CheckSignature(): failed to set public key\");\n        if (!key.Verify(Hash(vchMsg.begin(), vchMsg.end()), vchSig))\n          return error(\"CAlert::CheckSignature(): failed to verify signature\");\n\n        // Now unserialize the data\n        CDataStream sMsg(vchMsg, SER_NETWORK, PROTOCOL_VERSION);\n        sMsg >> *(CUnsignedAlert*)this;\n        return true;\n    }\n\n    bool ProcessAlert();\n\n    /*\n     * Get copy of (active) alert object by hash. Returns a null alert if it is not found.\n     */\n    static CAlert getAlertByHash(const uint256 &hash);\n};\n\nclass CTxMemPool\n{\npublic:\n    mutable CCriticalSection cs;\n    std::map<uint256, CTransaction> mapTx;\n    std::map<COutPoint, CInPoint> mapNextTx;\n\n    bool accept(CTxDB& txdb, CTransaction &tx,\n                bool fCheckInputs, bool* pfMissingInputs);\n    bool addUnchecked(const uint256& hash, CTransaction &tx);\n    bool remove(const CTransaction &tx, bool fRecursive = false);\n    bool removeConflicts(const CTransaction &tx);\n    void queryHashes(std::vector<uint256>& vtxid);\n\n    unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }\n\n    bool exists(uint256 hash)\n    {\n        return (mapTx.count(hash) != 0);\n    }\n\n    CTransaction& lookup(uint256 hash)\n    {\n        return mapTx[hash];\n    }\n};\n\nextern CTxMemPool mempool;\n\n#endif\n", "// Copyright (c) 2010 Satoshi Nakamoto\n// Copyright (c) 2009-2012 The Bitcoin developers\n// Copyright (c) 2013-2014 Phoenixcoin Developers\n// Distributed under the MIT/X11 software license, see the accompanying\n// file LICENCE or http://www.opensource.org/licenses/mit-license.php\n\n#include <boost/assign/list_of.hpp>\n\n#include \"base58.h\"\n#include \"bitcoinrpc.h\"\n#include \"db.h\"\n#include \"init.h\"\n#include \"main.h\"\n#include \"net.h\"\n#include \"wallet.h\"\n\nusing namespace std;\nusing namespace boost;\nusing namespace boost::assign;\nusing namespace json_spirit;\n\n// These are all in bitcoinrpc.cpp:\nextern Object JSONRPCError(int code, const string& message);\nextern int64 AmountFromValue(const Value& value);\nextern Value ValueFromAmount(int64 amount);\nextern std::string HelpRequiringPassphrase();\nextern void EnsureWalletIsUnlocked();\n\nvoid\nScriptPubKeyToJSON(const CScript& scriptPubKey, Object& out)\n{\n    txnouttype type;\n    vector<CTxDestination> addresses;\n    int nRequired;\n\n    out.push_back(Pair(\"asm\", scriptPubKey.ToString()));\n    out.push_back(Pair(\"hex\", HexStr(scriptPubKey.begin(), scriptPubKey.end())));\n\n    if (!ExtractDestinations(scriptPubKey, type, addresses, nRequired))\n    {\n        out.push_back(Pair(\"type\", GetTxnOutputType(TX_NONSTANDARD)));\n        return;\n    }\n\n    out.push_back(Pair(\"reqSigs\", nRequired));\n    out.push_back(Pair(\"type\", GetTxnOutputType(type)));\n\n    Array a;\n    BOOST_FOREACH(const CTxDestination& addr, addresses)\n        a.push_back(CBitcoinAddress(addr).ToString());\n    out.push_back(Pair(\"addresses\", a));\n}\n\nvoid\nTxToJSON(const CTransaction& tx, const uint256 hashBlock, Object& entry)\n{\n    entry.push_back(Pair(\"txid\", tx.GetHash().GetHex()));\n    entry.push_back(Pair(\"version\", tx.nVersion));\n    entry.push_back(Pair(\"locktime\", (boost::int64_t)tx.nLockTime));\n    Array vin;\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n    {\n        Object in;\n        if (tx.IsCoinBase())\n            in.push_back(Pair(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n        else\n        {\n            in.push_back(Pair(\"txid\", txin.prevout.hash.GetHex()));\n            in.push_back(Pair(\"vout\", (boost::int64_t)txin.prevout.n));\n            Object o;\n            o.push_back(Pair(\"asm\", txin.scriptSig.ToString()));\n            o.push_back(Pair(\"hex\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n            in.push_back(Pair(\"scriptSig\", o));\n        }\n        in.push_back(Pair(\"sequence\", (boost::int64_t)txin.nSequence));\n        vin.push_back(in);\n    }\n    entry.push_back(Pair(\"vin\", vin));\n    Array vout;\n    for (unsigned int i = 0; i < tx.vout.size(); i++)\n    {\n        const CTxOut& txout = tx.vout[i];\n        Object out;\n        out.push_back(Pair(\"value\", ValueFromAmount(txout.nValue)));\n        out.push_back(Pair(\"n\", (boost::int64_t)i));\n        Object o;\n        ScriptPubKeyToJSON(txout.scriptPubKey, o);\n        out.push_back(Pair(\"scriptPubKey\", o));\n        vout.push_back(out);\n    }\n    entry.push_back(Pair(\"vout\", vout));\n\n    if (hashBlock != 0)\n    {\n        entry.push_back(Pair(\"blockhash\", hashBlock.GetHex()));\n        map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n        if (mi != mapBlockIndex.end() && (*mi).second)\n        {\n            CBlockIndex* pindex = (*mi).second;\n            if (pindex->IsInMainChain())\n            {\n                entry.push_back(Pair(\"confirmations\", 1 + nBestHeight - pindex->nHeight));\n                entry.push_back(Pair(\"time\", (boost::int64_t)pindex->nTime));\n            }\n            else\n                entry.push_back(Pair(\"confirmations\", 0));\n        }\n    }\n}\n\nValue getrawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() < 1 || params.size() > 2)\n        throw runtime_error(\n            \"getrawtransaction <txid> [verbose=0]\\n\"\n            \"If verbose=0, returns a string that is\\n\"\n            \"serialized, hex-encoded data for <txid>.\\n\"\n            \"If verbose is non-zero, returns an Object\\n\"\n            \"with information about <txid>.\");\n\n    uint256 hash;\n    hash.SetHex(params[0].get_str());\n\n    bool fVerbose = false;\n    if (params.size() > 1)\n        fVerbose = (params[1].get_int() != 0);\n\n    CTransaction tx;\n    uint256 hashBlock = 0;\n    if (!GetTransaction(hash, tx, hashBlock))\n        throw JSONRPCError(-5, \"No information available about transaction\");\n\n    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n    ssTx << tx;\n    string strHex = HexStr(ssTx.begin(), ssTx.end());\n\n    if (!fVerbose)\n        return strHex;\n\n    Object result;\n    result.push_back(Pair(\"hex\", strHex));\n    TxToJSON(tx, hashBlock, result);\n    return result;\n}\n\nValue listunspent(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() > 2)\n        throw runtime_error(\n            \"listunspent [minconf=1] [maxconf=999999]\\n\"\n            \"Returns array of unspent transaction outputs\\n\"\n            \"with between minconf and maxconf (inclusive) confirmations.\\n\"\n            \"Results are an array of Objects, each of which has:\\n\"\n            \"{txid, vout, scriptPubKey, amount, confirmations}\");\n\n    RPCTypeCheck(params, list_of(int_type)(int_type));\n\n    int nMinDepth = 1;\n    if (params.size() > 0)\n        nMinDepth = params[0].get_int();\n\n    int nMaxDepth = 999999;\n    if (params.size() > 1)\n        nMaxDepth = params[1].get_int();\n\n    Array results;\n    vector<COutput> vecOutputs;\n    pwalletMain->AvailableCoins(vecOutputs, false);\n    BOOST_FOREACH(const COutput& out, vecOutputs)\n    {\n        if (out.nDepth < nMinDepth || out.nDepth > nMaxDepth)\n            continue;\n\n        int64 nValue = out.tx->vout[out.i].nValue;\n        const CScript& pk = out.tx->vout[out.i].scriptPubKey;\n        Object entry;\n        entry.push_back(Pair(\"txid\", out.tx->GetHash().GetHex()));\n        entry.push_back(Pair(\"vout\", out.i));\n        entry.push_back(Pair(\"scriptPubKey\", HexStr(pk.begin(), pk.end())));\n        entry.push_back(Pair(\"amount\",ValueFromAmount(nValue)));\n        entry.push_back(Pair(\"confirmations\",out.nDepth));\n        results.push_back(entry);\n    }\n\n    return results;\n}\n\nValue createrawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() != 2)\n        throw runtime_error(\n            \"createrawtransaction [{\\\"txid\\\":txid,\\\"vout\\\":n},...] {address:amount,...}\\n\"\n            \"Create a transaction spending given inputs\\n\"\n            \"(array of objects containing transaction id and output number),\\n\"\n            \"sending to given address(es).\\n\"\n            \"Returns hex-encoded raw transaction.\\n\"\n            \"Note that the transaction's inputs are not signed, and\\n\"\n            \"it is not stored in the wallet or transmitted to the network.\");\n\n    RPCTypeCheck(params, list_of(array_type)(obj_type));\n\n    Array inputs = params[0].get_array();\n    Object sendTo = params[1].get_obj();\n\n    CTransaction rawTx;\n\n    BOOST_FOREACH(Value& input, inputs)\n    {\n        const Object& o = input.get_obj();\n\n        const Value& txid_v = find_value(o, \"txid\");\n        if (txid_v.type() != str_type)\n            throw JSONRPCError(-8, \"Invalid parameter, missing txid key\");\n        string txid = txid_v.get_str();\n        if (!IsHex(txid))\n            throw JSONRPCError(-8, \"Invalid parameter, expected hex txid\");\n\n        const Value& vout_v = find_value(o, \"vout\");\n        if (vout_v.type() != int_type)\n            throw JSONRPCError(-8, \"Invalid parameter, missing vout key\");\n        int nOutput = vout_v.get_int();\n        if (nOutput < 0)\n            throw JSONRPCError(-8, \"Invalid parameter, vout must be positive\");\n\n        CTxIn in(COutPoint(uint256(txid), nOutput));\n        rawTx.vin.push_back(in);\n    }\n\n    set<CBitcoinAddress> setAddress;\n    BOOST_FOREACH(const Pair& s, sendTo)\n    {\n        CBitcoinAddress address(s.name_);\n        if (!address.IsValid())\n            throw JSONRPCError(-5, string(\"Invalid Bitcoin address:\")+s.name_);\n\n        if (setAddress.count(address))\n            throw JSONRPCError(-8, string(\"Invalid parameter, duplicated address: \")+s.name_);\n        setAddress.insert(address);\n\n        CScript scriptPubKey;\n        scriptPubKey.SetDestination(address.Get());\n        int64 nAmount = AmountFromValue(s.value_);\n\n        CTxOut out(nAmount, scriptPubKey);\n        rawTx.vout.push_back(out);\n    }\n\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << rawTx;\n    return HexStr(ss.begin(), ss.end());\n}\n\nValue decoderawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() != 1)\n        throw runtime_error(\n            \"decoderawtransaction <hex string>\\n\"\n            \"Return a JSON object representing the serialized, hex-encoded transaction.\");\n\n    RPCTypeCheck(params, list_of(str_type));\n\n    vector<unsigned char> txData(ParseHex(params[0].get_str()));\n    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n    CTransaction tx;\n    try {\n        ssData >> tx;\n    }\n    catch (std::exception &e) {\n        throw JSONRPCError(-22, \"TX decode failed\");\n    }\n\n    Object result;\n    TxToJSON(tx, 0, result);\n\n    return result;\n}\n\nValue signrawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() < 1 || params.size() > 4)\n        throw runtime_error(\n            \"signrawtransaction <hex string> [{\\\"txid\\\":txid,\\\"vout\\\":n,\\\"scriptPubKey\\\":hex},...] [<privatekey1>,...] [sighashtype=\\\"ALL\\\"]\\n\"\n            \"Sign inputs for raw transaction (serialized, hex-encoded).\\n\"\n            \"Second optional argument is an array of previous transaction outputs that\\n\"\n            \"this transaction depends on but may not yet be in the blockchain.\\n\"\n            \"Third optional argument is an array of base58-encoded private\\n\"\n            \"keys that, if given, will be the only keys used to sign the transaction.\\n\"\n            \"Fourth option is a string that is one of six values; ALL, NONE, SINGLE or\\n\"\n            \"ALL|ANYONECANPAY, NONE|ANYONECANPAY, SINGLE|ANYONECANPAY.\\n\"\n            \"Returns json object with keys:\\n\"\n            \"  hex : raw transaction with signature(s) (hex-encoded string)\\n\"\n            \"  complete : 1 if transaction has a complete set of signature (0 if not)\"\n            + HelpRequiringPassphrase());\n\n    if (params.size() < 3)\n        EnsureWalletIsUnlocked();\n\n    RPCTypeCheck(params, list_of(str_type)(array_type)(array_type));\n\n    vector<unsigned char> txData(ParseHex(params[0].get_str()));\n    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n    vector<CTransaction> txVariants;\n    while (!ssData.empty())\n    {\n        try {\n            CTransaction tx;\n            ssData >> tx;\n            txVariants.push_back(tx);\n        }\n        catch (std::exception &e) {\n            throw JSONRPCError(-22, \"TX decode failed\");\n        }\n    }\n\n    if (txVariants.empty())\n        throw JSONRPCError(-22, \"Missing transaction\");\n\n    // mergedTx will end up with all the signatures; it\n    // starts as a clone of the rawtx:\n    CTransaction mergedTx(txVariants[0]);\n    bool fComplete = true;\n\n    // Fetch previous transactions (inputs):\n    map<COutPoint, CScript> mapPrevOut;\n    {\n        MapPrevTx mapPrevTx;\n        CTxDB txdb(\"r\");\n        map<uint256, CTxIndex> unused;\n        bool fInvalid;\n        mergedTx.FetchInputs(txdb, unused, false, false, mapPrevTx, fInvalid);\n\n        // Copy results into mapPrevOut:\n        BOOST_FOREACH(const CTxIn& txin, mergedTx.vin)\n        {\n            const uint256& prevHash = txin.prevout.hash;\n            if (mapPrevTx.count(prevHash))\n                mapPrevOut[txin.prevout] = mapPrevTx[prevHash].second.vout[txin.prevout.n].scriptPubKey;\n        }\n    }\n\n    // Add previous txouts given in the RPC call:\n    if (params.size() > 1)\n    {\n        Array prevTxs = params[1].get_array();\n        BOOST_FOREACH(Value& p, prevTxs)\n        {\n            if (p.type() != obj_type)\n                throw JSONRPCError(-22, \"expected object with {\\\"txid'\\\",\\\"vout\\\",\\\"scriptPubKey\\\"}\");\n\n            Object prevOut = p.get_obj();\n\n            RPCTypeCheck(prevOut, map_list_of(\"txid\", str_type)(\"vout\", int_type)(\"scriptPubKey\", str_type));\n\n            string txidHex = find_value(prevOut, \"txid\").get_str();\n            if (!IsHex(txidHex))\n                throw JSONRPCError(-22, \"txid must be hexadecimal\");\n            uint256 txid;\n            txid.SetHex(txidHex);\n\n            int nOut = find_value(prevOut, \"vout\").get_int();\n            if (nOut < 0)\n                throw JSONRPCError(-22, \"vout must be positive\");\n\n            string pkHex = find_value(prevOut, \"scriptPubKey\").get_str();\n            if (!IsHex(pkHex))\n                throw JSONRPCError(-22, \"scriptPubKey must be hexadecimal\");\n            vector<unsigned char> pkData(ParseHex(pkHex));\n            CScript scriptPubKey(pkData.begin(), pkData.end());\n\n            COutPoint outpoint(txid, nOut);\n            if (mapPrevOut.count(outpoint))\n            {\n                // Complain if scriptPubKey doesn't match\n                if (mapPrevOut[outpoint] != scriptPubKey)\n                {\n                    string err(\"Previous output scriptPubKey mismatch:\\n\");\n                    err = err + mapPrevOut[outpoint].ToString() + \"\\nvs:\\n\"+\n                        scriptPubKey.ToString();\n                    throw JSONRPCError(-22, err);\n                }\n            }\n            else\n                mapPrevOut[outpoint] = scriptPubKey;\n        }\n    }\n\n    bool fGivenKeys = false;\n    CBasicKeyStore tempKeystore;\n    if (params.size() > 2)\n    {\n        fGivenKeys = true;\n        Array keys = params[2].get_array();\n        BOOST_FOREACH(Value k, keys)\n        {\n            CBitcoinSecret vchSecret;\n            bool fGood = vchSecret.SetString(k.get_str());\n            if (!fGood)\n                throw JSONRPCError(-5,\"Invalid private key\");\n            CKey key;\n            bool fCompressed;\n            CSecret secret = vchSecret.GetSecret(fCompressed);\n            key.SetSecret(secret, fCompressed);\n            tempKeystore.AddKey(key);\n        }\n    }\n    const CKeyStore& keystore = (fGivenKeys ? tempKeystore : *pwalletMain);\n\n    int nHashType = SIGHASH_ALL;\n    if (params.size() > 3)\n    {\n        static map<string, int> mapSigHashValues =\n            boost::assign::map_list_of\n            (string(\"ALL\"), int(SIGHASH_ALL))\n            (string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY))\n            (string(\"NONE\"), int(SIGHASH_NONE))\n            (string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY))\n            (string(\"SINGLE\"), int(SIGHASH_SINGLE))\n            (string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY))\n            ;\n        string strHashType = params[3].get_str();\n        if (mapSigHashValues.count(strHashType))\n            nHashType = mapSigHashValues[strHashType];\n        else\n            throw JSONRPCError(-8, \"Invalid sighash param\");\n    }\n\n    // Sign what we can:\n    for (unsigned int i = 0; i < mergedTx.vin.size(); i++)\n    {\n        CTxIn& txin = mergedTx.vin[i];\n        if (mapPrevOut.count(txin.prevout) == 0)\n        {\n            fComplete = false;\n            continue;\n        }\n        const CScript& prevPubKey = mapPrevOut[txin.prevout];\n\n        txin.scriptSig.clear();\n        SignSignature(keystore, prevPubKey, mergedTx, i, nHashType);\n\n        // ... and merge in other signatures:\n        BOOST_FOREACH(const CTransaction& txv, txVariants)\n        {\n            txin.scriptSig = CombineSignatures(prevPubKey, mergedTx, i, txin.scriptSig, txv.vin[i].scriptSig);\n        }\n        if (!VerifyScript(txin.scriptSig, prevPubKey, mergedTx, i, true, 0))\n            fComplete = false;\n    }\n\n    Object result;\n    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n    ssTx << mergedTx;\n    result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n    result.push_back(Pair(\"complete\", fComplete));\n\n    return result;\n}\n\nValue sendrawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() < 1 || params.size() > 1)\n        throw runtime_error(\n            \"sendrawtransaction <hex string>\\n\"\n            \"Submits raw transaction (serialized, hex-encoded) to local node and network.\");\n\n    RPCTypeCheck(params, list_of(str_type));\n\n    // parse hex string from parameter\n    vector<unsigned char> txData(ParseHex(params[0].get_str()));\n    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n    CTransaction tx;\n\n    // deserialize binary data stream\n    try {\n        ssData >> tx;\n    }\n    catch (std::exception &e) {\n        throw JSONRPCError(-22, \"TX decode failed\");\n    }\n    uint256 hashTx = tx.GetHash();\n\n    // See if the transaction is already in a block\n    // or in the memory pool:\n    CTransaction existingTx;\n    uint256 hashBlock = 0;\n    if (GetTransaction(hashTx, existingTx, hashBlock))\n    {\n        if (hashBlock != 0)\n            throw JSONRPCError(-5, string(\"transaction already in block \")+hashBlock.GetHex());\n        // Not in block, but already in the memory pool; will drop\n        // through to re-relay it.\n    }\n    else\n    {\n        // push to local node\n        CTxDB txdb(\"r\");\n        if (!tx.AcceptToMemoryPool(txdb))\n            throw JSONRPCError(-22, \"TX rejected\");\n\n        SyncWithWallets(tx, NULL, true);\n    }\n    RelayMessage(CInv(MSG_TX, hashTx), tx);\n\n    return hashTx.GetHex();\n}\n", "// Copyright (c) 2009-2010 Satoshi Nakamoto\n// Copyright (c) 2009-2012 The Bitcoin developers\n// Copyright (c) 2011-2012 Litecoin Developers\n// Copyright (c) 2013-2014 Phoenixcoin Developers\n// Distributed under the MIT/X11 software license, see the accompanying\n// file LICENCE or http://www.opensource.org/licenses/mit-license.php\n\n#include \"wallet.h\"\n#include \"walletdb.h\"\n#include \"crypter.h\"\n#include \"ui_interface.h\"\n#include \"base58.h\"\n#include \"coincontrol.h\"\n\nusing namespace std;\n\nstatic int64 nNextResendTxTime = 0;\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// mapWallet\n//\n\nstruct CompareValueOnly\n{\n    bool operator()(const pair<int64, pair<const CWalletTx*, unsigned int> >& t1,\n                    const pair<int64, pair<const CWalletTx*, unsigned int> >& t2) const\n    {\n        return t1.first < t2.first;\n    }\n};\n\nCPubKey CWallet::GenerateNewKey()\n{\n    bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets\n\n    RandAddSeedPerfmon();\n    CKey key;\n    key.MakeNewKey(fCompressed);\n\n    // Compressed public keys were introduced in version 0.6.0\n    if (fCompressed)\n        SetMinVersion(FEATURE_COMPRPUBKEY);\n\n    if (!AddKey(key))\n        throw std::runtime_error(\"CWallet::GenerateNewKey() : AddKey failed\");\n    return key.GetPubKey();\n}\n\nbool CWallet::AddKey(const CKey& key)\n{\n    if (!CCryptoKeyStore::AddKey(key))\n        return false;\n    if (!fFileBacked)\n        return true;\n    if (!IsCrypted())\n        return CWalletDB(strWalletFile).WriteKey(key.GetPubKey(), key.GetPrivKey());\n    return true;\n}\n\nbool CWallet::AddCryptedKey(const CPubKey &vchPubKey, const vector<unsigned char> &vchCryptedSecret)\n{\n    if (!CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret))\n        return false;\n    if (!fFileBacked)\n        return true;\n    {\n        LOCK(cs_wallet);\n        if (pwalletdbEncryption)\n            return pwalletdbEncryption->WriteCryptedKey(vchPubKey, vchCryptedSecret);\n        else\n            return CWalletDB(strWalletFile).WriteCryptedKey(vchPubKey, vchCryptedSecret);\n    }\n    return false;\n}\n\nbool CWallet::AddCScript(const CScript& redeemScript)\n{\n    if (!CCryptoKeyStore::AddCScript(redeemScript))\n        return false;\n    if (!fFileBacked)\n        return true;\n    return CWalletDB(strWalletFile).WriteCScript(Hash160(redeemScript), redeemScript);\n}\n\nbool CWallet::Unlock(const SecureString& strWalletPassphrase)\n{\n    if (!IsLocked())\n        return false;\n\n    CCrypter crypter;\n    CKeyingMaterial vMasterKey;\n\n    {\n        LOCK(cs_wallet);\n        BOOST_FOREACH(const MasterKeyMap::value_type& pMasterKey, mapMasterKeys)\n        {\n            if(!crypter.SetKeyFromPassphrase(strWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                return false;\n            if (!crypter.Decrypt(pMasterKey.second.vchCryptedKey, vMasterKey))\n                return false;\n            if (CCryptoKeyStore::Unlock(vMasterKey))\n                return true;\n        }\n    }\n    return false;\n}\n\nbool CWallet::ChangeWalletPassphrase(const SecureString& strOldWalletPassphrase, const SecureString& strNewWalletPassphrase)\n{\n    bool fWasLocked = IsLocked();\n\n    {\n        LOCK(cs_wallet);\n        Lock();\n\n        CCrypter crypter;\n        CKeyingMaterial vMasterKey;\n        BOOST_FOREACH(MasterKeyMap::value_type& pMasterKey, mapMasterKeys)\n        {\n            if(!crypter.SetKeyFromPassphrase(strOldWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                return false;\n            if (!crypter.Decrypt(pMasterKey.second.vchCryptedKey, vMasterKey))\n                return false;\n            if (CCryptoKeyStore::Unlock(vMasterKey))\n            {\n                int64 nStartTime = GetTimeMillis();\n                crypter.SetKeyFromPassphrase(strNewWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod);\n                pMasterKey.second.nDeriveIterations = pMasterKey.second.nDeriveIterations * (100 / ((double)(GetTimeMillis() - nStartTime)));\n\n                nStartTime = GetTimeMillis();\n                crypter.SetKeyFromPassphrase(strNewWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod);\n                pMasterKey.second.nDeriveIterations = (pMasterKey.second.nDeriveIterations + pMasterKey.second.nDeriveIterations * 100 / ((double)(GetTimeMillis() - nStartTime))) / 2;\n\n                if (pMasterKey.second.nDeriveIterations < 25000)\n                    pMasterKey.second.nDeriveIterations = 25000;\n\n                printf(\"Wallet passphrase changed to an nDeriveIterations of %i\\n\", pMasterKey.second.nDeriveIterations);\n\n                if (!crypter.SetKeyFromPassphrase(strNewWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                    return false;\n                if (!crypter.Encrypt(vMasterKey, pMasterKey.second.vchCryptedKey))\n                    return false;\n                CWalletDB(strWalletFile).WriteMasterKey(pMasterKey.first, pMasterKey.second);\n                if (fWasLocked)\n                    Lock();\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nvoid CWallet::SetBestChain(const CBlockLocator& loc)\n{\n    CWalletDB walletdb(strWalletFile);\n    walletdb.WriteBestBlock(loc);\n}\n\n// This class implements an addrIncoming entry that causes pre-0.4\n// clients to crash on startup if reading a private-key-encrypted wallet.\nclass CCorruptAddress\n{\npublic:\n    IMPLEMENT_SERIALIZE\n    (\n        if (nType & SER_DISK)\n            READWRITE(nVersion);\n    )\n};\n\nbool CWallet::SetMinVersion(enum WalletFeature nVersion, CWalletDB* pwalletdbIn, bool fExplicit)\n{\n    if (nWalletVersion >= nVersion)\n        return true;\n\n    // when doing an explicit upgrade, if we pass the max version permitted, upgrade all the way\n    if (fExplicit && nVersion > nWalletMaxVersion)\n            nVersion = FEATURE_LATEST;\n\n    nWalletVersion = nVersion;\n\n    if (nVersion > nWalletMaxVersion)\n        nWalletMaxVersion = nVersion;\n\n    if (fFileBacked)\n    {\n        CWalletDB* pwalletdb = pwalletdbIn ? pwalletdbIn : new CWalletDB(strWalletFile);\n        if (nWalletVersion >= 40000)\n        {\n            // Versions prior to 0.4.0 did not support the \"minversion\" record.\n            // Use a CCorruptAddress to make them crash instead.\n            CCorruptAddress corruptAddress;\n            pwalletdb->WriteSetting(\"addrIncoming\", corruptAddress);\n        }\n        if (nWalletVersion > 40000)\n            pwalletdb->WriteMinVersion(nWalletVersion);\n        if (!pwalletdbIn)\n            delete pwalletdb;\n    }\n\n    return true;\n}\n\nbool CWallet::SetMaxVersion(int nVersion)\n{\n    // cannot downgrade below current version\n    if (nWalletVersion > nVersion)\n        return false;\n\n    nWalletMaxVersion = nVersion;\n\n    return true;\n}\n\nbool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n{\n    if (IsCrypted())\n        return false;\n\n    CKeyingMaterial vMasterKey;\n    RandAddSeedPerfmon();\n\n    vMasterKey.resize(WALLET_CRYPTO_KEY_SIZE);\n    RAND_bytes(&vMasterKey[0], WALLET_CRYPTO_KEY_SIZE);\n\n    CMasterKey kMasterKey;\n\n    RandAddSeedPerfmon();\n    kMasterKey.vchSalt.resize(WALLET_CRYPTO_SALT_SIZE);\n    RAND_bytes(&kMasterKey.vchSalt[0], WALLET_CRYPTO_SALT_SIZE);\n\n    CCrypter crypter;\n    int64 nStartTime = GetTimeMillis();\n    crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, 25000, kMasterKey.nDerivationMethod);\n    kMasterKey.nDeriveIterations = 2500000 / ((double)(GetTimeMillis() - nStartTime));\n\n    nStartTime = GetTimeMillis();\n    crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, kMasterKey.nDeriveIterations, kMasterKey.nDerivationMethod);\n    kMasterKey.nDeriveIterations = (kMasterKey.nDeriveIterations + kMasterKey.nDeriveIterations * 100 / ((double)(GetTimeMillis() - nStartTime))) / 2;\n\n    if (kMasterKey.nDeriveIterations < 25000)\n        kMasterKey.nDeriveIterations = 25000;\n\n    printf(\"Encrypting Wallet with an nDeriveIterations of %i\\n\", kMasterKey.nDeriveIterations);\n\n    if (!crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, kMasterKey.nDeriveIterations, kMasterKey.nDerivationMethod))\n        return false;\n    if (!crypter.Encrypt(vMasterKey, kMasterKey.vchCryptedKey))\n        return false;\n\n    {\n        LOCK(cs_wallet);\n        mapMasterKeys[++nMasterKeyMaxID] = kMasterKey;\n        if (fFileBacked)\n        {\n            pwalletdbEncryption = new CWalletDB(strWalletFile);\n            if (!pwalletdbEncryption->TxnBegin())\n                return false;\n            pwalletdbEncryption->WriteMasterKey(nMasterKeyMaxID, kMasterKey);\n        }\n\n        if (!EncryptKeys(vMasterKey))\n        {\n            if (fFileBacked)\n                pwalletdbEncryption->TxnAbort();\n            exit(1); //We now probably have half of our keys encrypted in memory, and half not...die and let the user reload their unencrypted wallet.\n        }\n\n        // Encryption was introduced in version 0.4.0\n        SetMinVersion(FEATURE_WALLETCRYPT, pwalletdbEncryption, true);\n\n        if (fFileBacked)\n        {\n            if (!pwalletdbEncryption->TxnCommit())\n                exit(1); //We now have keys encrypted in memory, but no on disk...die to avoid confusion and let the user reload their unencrypted wallet.\n\n            delete pwalletdbEncryption;\n            pwalletdbEncryption = NULL;\n        }\n\n        Lock();\n        Unlock(strWalletPassphrase);\n        NewKeyPool();\n        Lock();\n\n        // Need to completely rewrite the wallet file; if we don't, bdb might keep\n        // bits of the unencrypted private key in slack space in the database file.\n        CDB::Rewrite(strWalletFile);\n\n    }\n    NotifyStatusChanged(this);\n\n    return true;\n}\n\nvoid CWallet::WalletUpdateSpent(const CTransaction &tx)\n{\n    // Anytime a signature is successfully verified, it's proof the outpoint is spent.\n    // Update the wallet spent flag if it doesn't know due to wallet.dat being\n    // restored from backup or the user making copies of wallet.dat.\n    {\n        LOCK(cs_wallet);\n        BOOST_FOREACH(const CTxIn& txin, tx.vin)\n        {\n            map<uint256, CWalletTx>::iterator mi = mapWallet.find(txin.prevout.hash);\n            if (mi != mapWallet.end())\n            {\n                CWalletTx& wtx = (*mi).second;\n                if (!wtx.IsSpent(txin.prevout.n) && IsMine(wtx.vout[txin.prevout.n]))\n                {\n                    printf(\"WalletUpdateSpent found spent coin %sbc %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n                    wtx.MarkSpent(txin.prevout.n);\n                    wtx.WriteToDisk();\n                    NotifyTransactionChanged(this, txin.prevout.hash, CT_UPDATED);\n                }\n            }\n        }\n    }\n}\n\nvoid CWallet::MarkDirty()\n{\n    {\n        LOCK(cs_wallet);\n        BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n            item.second.MarkDirty();\n    }\n}\n\nbool CWallet::AddToWallet(const CWalletTx& wtxIn)\n{\n    uint256 hash = wtxIn.GetHash();\n    {\n        LOCK(cs_wallet);\n        // Inserts only if not already there, returns tx inserted or tx found\n        pair<map<uint256, CWalletTx>::iterator, bool> ret = mapWallet.insert(make_pair(hash, wtxIn));\n        CWalletTx& wtx = (*ret.first).second;\n        wtx.BindWallet(this);\n        bool fInsertedNew = ret.second;\n        if (fInsertedNew)\n            wtx.nTimeReceived = GetAdjustedTime();\n\n        bool fUpdated = false;\n        if (!fInsertedNew)\n        {\n            // Merge\n            if (wtxIn.hashBlock != 0 && wtxIn.hashBlock != wtx.hashBlock)\n            {\n                wtx.hashBlock = wtxIn.hashBlock;\n                fUpdated = true;\n            }\n            if (wtxIn.nIndex != -1 && (wtxIn.vMerkleBranch != wtx.vMerkleBranch || wtxIn.nIndex != wtx.nIndex))\n            {\n                wtx.vMerkleBranch = wtxIn.vMerkleBranch;\n                wtx.nIndex = wtxIn.nIndex;\n                fUpdated = true;\n            }\n            if (wtxIn.fFromMe && wtxIn.fFromMe != wtx.fFromMe)\n            {\n                wtx.fFromMe = wtxIn.fFromMe;\n                fUpdated = true;\n            }\n            fUpdated |= wtx.UpdateSpent(wtxIn.vfSpent);\n        }\n\n        //// debug print\n        printf(\"AddToWallet %s  %s%s\\n\", wtxIn.GetHash().ToString().substr(0,10).c_str(), (fInsertedNew ? \"new\" : \"\"), (fUpdated ? \"update\" : \"\"));\n\n        // Write to disk\n        if (fInsertedNew || fUpdated)\n            if (!wtx.WriteToDisk())\n                return false;\n#ifndef QT_GUI\n        // If default receiving address gets used, replace it with a new one\n        CScript scriptDefaultKey;\n        scriptDefaultKey.SetDestination(vchDefaultKey.GetID());\n        BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n        {\n            if (txout.scriptPubKey == scriptDefaultKey)\n            {\n                CPubKey newDefaultKey;\n                if (GetKeyFromPool(newDefaultKey, false))\n                {\n                    SetDefaultKey(newDefaultKey);\n                    SetAddressBookName(vchDefaultKey.GetID(), \"\");\n                }\n            }\n        }\n#endif\n        // since AddToWallet is called directly for self-originating transactions, check for consumption of own coins\n        WalletUpdateSpent(wtx);\n\n        // Notify UI of new or updated transaction\n        NotifyTransactionChanged(this, hash, fInsertedNew ? CT_NEW : CT_UPDATED);\n    }\n    return true;\n}\n\n// Add a transaction to the wallet, or update it.\n// pblock is optional, but should be provided if the transaction is known to be in a block.\n// If fUpdate is true, existing transactions will be updated.\nbool CWallet::AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate, bool fFindBlock)\n{\n    uint256 hash = tx.GetHash();\n    {\n        LOCK(cs_wallet);\n        bool fExisted = mapWallet.count(hash);\n        if (fExisted && !fUpdate) return false;\n        if (fExisted || IsMine(tx) || IsFromMe(tx))\n        {\n            CWalletTx wtx(this,tx);\n            // Get merkle branch if transaction was found in a block\n            if (pblock)\n                wtx.SetMerkleBranch(pblock);\n            return AddToWallet(wtx);\n        }\n        else\n            WalletUpdateSpent(tx);\n    }\n    return false;\n}\n\nbool CWallet::EraseFromWallet(uint256 hash)\n{\n    if (!fFileBacked)\n        return false;\n    {\n        LOCK(cs_wallet);\n        if (mapWallet.erase(hash))\n            CWalletDB(strWalletFile).EraseTx(hash);\n    }\n    return true;\n}\n\n\nbool CWallet::IsMine(const CTxIn &txin) const\n{\n    {\n        LOCK(cs_wallet);\n        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n        if (mi != mapWallet.end())\n        {\n            const CWalletTx& prev = (*mi).second;\n            if (txin.prevout.n < prev.vout.size())\n                if (IsMine(prev.vout[txin.prevout.n]))\n                    return true;\n        }\n    }\n    return false;\n}\n\nint64 CWallet::GetDebit(const CTxIn &txin) const\n{\n    {\n        LOCK(cs_wallet);\n        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n        if (mi != mapWallet.end())\n        {\n            const CWalletTx& prev = (*mi).second;\n            if (txin.prevout.n < prev.vout.size())\n                if (IsMine(prev.vout[txin.prevout.n]))\n                    return prev.vout[txin.prevout.n].nValue;\n        }\n    }\n    return 0;\n}\n\nbool CWallet::IsChange(const CTxOut& txout) const\n{\n    CTxDestination address;\n\n    // TODO: fix handling of 'change' outputs. The assumption is that any\n    // payment to a TX_PUBKEYHASH that is mine but isn't in the address book\n    // is change. That assumption is likely to break when we implement multisignature\n    // wallets that return change back into a multi-signature-protected address;\n    // a better way of identifying which outputs are 'the send' and which are\n    // 'the change' will need to be implemented (maybe extend CWalletTx to remember\n    // which output, if any, was change).\n    if (ExtractDestination(txout.scriptPubKey, address) && ::IsMine(*this, address))\n    {\n        LOCK(cs_wallet);\n        if (!mapAddressBook.count(address))\n            return true;\n    }\n    return false;\n}\n\nint64 CWalletTx::GetTxTime() const\n{\n    return nTimeReceived;\n}\n\nint CWalletTx::GetRequestCount() const\n{\n    // Returns -1 if it wasn't being tracked\n    int nRequests = -1;\n    {\n        LOCK(pwallet->cs_wallet);\n        if (IsCoinBase())\n        {\n            // Generated block\n            if (hashBlock != 0)\n            {\n                map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(hashBlock);\n                if (mi != pwallet->mapRequestCount.end())\n                    nRequests = (*mi).second;\n            }\n        }\n        else\n        {\n            // Did anyone request this transaction?\n            map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(GetHash());\n            if (mi != pwallet->mapRequestCount.end())\n            {\n                nRequests = (*mi).second;\n\n                // How about the block it's in?\n                if (nRequests == 0 && hashBlock != 0)\n                {\n                    map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(hashBlock);\n                    if (mi != pwallet->mapRequestCount.end())\n                        nRequests = (*mi).second;\n                    else\n                        nRequests = 1; // If it's in someone else's block it must have got out\n                }\n            }\n        }\n    }\n    return nRequests;\n}\n\nvoid CWalletTx::GetAmounts(int64& nGeneratedImmature, int64& nGeneratedMature, list<pair<CTxDestination, int64> >& listReceived,\n                           list<pair<CTxDestination, int64> >& listSent, int64& nFee, string& strSentAccount) const\n{\n    nGeneratedImmature = nGeneratedMature = nFee = 0;\n    listReceived.clear();\n    listSent.clear();\n    strSentAccount = strFromAccount;\n\n    if (IsCoinBase())\n    {\n        if (GetBlocksToMaturity() > 0)\n            nGeneratedImmature = pwallet->GetCredit(*this);\n        else\n            nGeneratedMature = GetCredit();\n        return;\n    }\n\n    // Compute fee:\n    int64 nDebit = GetDebit();\n    if (nDebit > 0) // debit>0 means we signed/sent this transaction\n    {\n        int64 nValueOut = GetValueOut();\n        nFee = nDebit - nValueOut;\n    }\n\n    // Sent/received.\n    BOOST_FOREACH(const CTxOut& txout, vout)\n    {\n        CTxDestination address;\n        vector<unsigned char> vchPubKey;\n        if (!ExtractDestination(txout.scriptPubKey, address))\n        {\n            printf(\"CWalletTx::GetAmounts: Unknown transaction type found, txid %s\\n\",\n                   this->GetHash().ToString().c_str());\n        }\n\n        // Don't report 'change' txouts\n        if (nDebit > 0 && pwallet->IsChange(txout))\n            continue;\n\n        if (nDebit > 0)\n            listSent.push_back(make_pair(address, txout.nValue));\n\n        if (pwallet->IsMine(txout))\n            listReceived.push_back(make_pair(address, txout.nValue));\n    }\n\n}\n\nvoid CWalletTx::GetAccountAmounts(const string& strAccount, int64& nGenerated, int64& nReceived,\n                                  int64& nSent, int64& nFee) const\n{\n    nGenerated = nReceived = nSent = nFee = 0;\n\n    int64 allGeneratedImmature, allGeneratedMature, allFee;\n    allGeneratedImmature = allGeneratedMature = allFee = 0;\n    string strSentAccount;\n    list<pair<CTxDestination, int64> > listReceived;\n    list<pair<CTxDestination, int64> > listSent;\n    GetAmounts(allGeneratedImmature, allGeneratedMature, listReceived, listSent, allFee, strSentAccount);\n\n    if (strAccount == \"\")\n        nGenerated = allGeneratedMature;\n    if (strAccount == strSentAccount)\n    {\n        BOOST_FOREACH(const PAIRTYPE(CTxDestination,int64)& s, listSent)\n            nSent += s.second;\n        nFee = allFee;\n    }\n    {\n        LOCK(pwallet->cs_wallet);\n        BOOST_FOREACH(const PAIRTYPE(CTxDestination,int64)& r, listReceived)\n        {\n            if (pwallet->mapAddressBook.count(r.first))\n            {\n                map<CTxDestination, string>::const_iterator mi = pwallet->mapAddressBook.find(r.first);\n                if (mi != pwallet->mapAddressBook.end() && (*mi).second == strAccount)\n                    nReceived += r.second;\n            }\n            else if (strAccount.empty())\n            {\n                nReceived += r.second;\n            }\n        }\n    }\n}\n\nvoid CWalletTx::AddSupportingTransactions(CTxDB& txdb)\n{\n    vtxPrev.clear();\n\n    const int COPY_DEPTH = 3;\n    if (SetMerkleBranch() < COPY_DEPTH)\n    {\n        vector<uint256> vWorkQueue;\n        BOOST_FOREACH(const CTxIn& txin, vin)\n            vWorkQueue.push_back(txin.prevout.hash);\n\n        // This critsect is OK because txdb is already open\n        {\n            LOCK(pwallet->cs_wallet);\n            map<uint256, const CMerkleTx*> mapWalletPrev;\n            set<uint256> setAlreadyDone;\n            for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n            {\n                uint256 hash = vWorkQueue[i];\n                if (setAlreadyDone.count(hash))\n                    continue;\n                setAlreadyDone.insert(hash);\n\n                CMerkleTx tx;\n                map<uint256, CWalletTx>::const_iterator mi = pwallet->mapWallet.find(hash);\n                if (mi != pwallet->mapWallet.end())\n                {\n                    tx = (*mi).second;\n                    BOOST_FOREACH(const CMerkleTx& txWalletPrev, (*mi).second.vtxPrev)\n                        mapWalletPrev[txWalletPrev.GetHash()] = &txWalletPrev;\n                }\n                else if (mapWalletPrev.count(hash))\n                {\n                    tx = *mapWalletPrev[hash];\n                }\n                else if(txdb.ReadDiskTx(hash, tx)) {\n                    ;\n                }\n                else\n                {\n                    printf(\"ERROR: AddSupportingTransactions() : unsupported transaction\\n\");\n                    continue;\n                }\n\n                int nDepth = tx.SetMerkleBranch();\n                vtxPrev.push_back(tx);\n\n                if (nDepth < COPY_DEPTH)\n                {\n                    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n                        vWorkQueue.push_back(txin.prevout.hash);\n                }\n            }\n        }\n    }\n\n    reverse(vtxPrev.begin(), vtxPrev.end());\n}\n\nbool CWalletTx::WriteToDisk()\n{\n    return CWalletDB(pwallet->strWalletFile).WriteTx(GetHash(), *this);\n}\n\n// Scan the block chain (starting in pindexStart) for transactions\n// from or to us. If fUpdate is true, found transactions that already\n// exist in the wallet will be updated.\nint CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n{\n    int ret = 0;\n\n    CBlockIndex* pindex = pindexStart;\n    {\n        LOCK(cs_wallet);\n        while (pindex)\n        {\n            CBlock block;\n            block.ReadFromDisk(pindex, true);\n            BOOST_FOREACH(CTransaction& tx, block.vtx)\n            {\n                if (AddToWalletIfInvolvingMe(tx, &block, fUpdate))\n                    ret++;\n            }\n            pindex = pindex->pnext;\n        }\n    }\n    return ret;\n}\n\nint CWallet::ScanForWalletTransaction(const uint256& hashTx)\n{\n    CTransaction tx;\n    tx.ReadFromDisk(COutPoint(hashTx, 0));\n    if (AddToWalletIfInvolvingMe(tx, NULL, true, true))\n        return 1;\n    return 0;\n}\n\nvoid CWallet::ReacceptWalletTransactions()\n{\n    CTxDB txdb(\"r\");\n    bool fRepeat = true;\n    while (fRepeat)\n    {\n        LOCK(cs_wallet);\n        fRepeat = false;\n        vector<CDiskTxPos> vMissingTx;\n        BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n        {\n            CWalletTx& wtx = item.second;\n            if (wtx.IsCoinBase() && wtx.IsSpent(0))\n                continue;\n\n            CTxIndex txindex;\n            bool fUpdated = false;\n            if (txdb.ReadTxIndex(wtx.GetHash(), txindex))\n            {\n                // Update fSpent if a tx got spent somewhere else by a copy of wallet.dat\n                if (txindex.vSpent.size() != wtx.vout.size())\n                {\n                    printf(\"ERROR: ReacceptWalletTransactions() : txindex.vSpent.size() %d != wtx.vout.size() %d\\n\", txindex.vSpent.size(), wtx.vout.size());\n                    continue;\n                }\n                for (unsigned int i = 0; i < txindex.vSpent.size(); i++)\n                {\n                    if (wtx.IsSpent(i))\n                        continue;\n                    if (!txindex.vSpent[i].IsNull() && IsMine(wtx.vout[i]))\n                    {\n                        wtx.MarkSpent(i);\n                        fUpdated = true;\n                        vMissingTx.push_back(txindex.vSpent[i]);\n                    }\n                }\n                if (fUpdated)\n                {\n                    printf(\"ReacceptWalletTransactions found spent coin %sbc %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n                    wtx.MarkDirty();\n                    wtx.WriteToDisk();\n                }\n            }\n            else\n            {\n                // Reaccept any txes of ours that aren't already in a block\n                if (!wtx.IsCoinBase())\n                    wtx.AcceptWalletTransaction(txdb, false);\n            }\n        }\n        if (!vMissingTx.empty())\n        {\n            // TODO: optimize this to scan just part of the block chain?\n            if (ScanForWalletTransactions(pindexGenesisBlock))\n                fRepeat = true;  // Found missing transactions: re-do Reaccept.\n        }\n    }\n}\n\nvoid CWalletTx::RelayWalletTransaction(CTxDB& txdb)\n{\n    BOOST_FOREACH(const CMerkleTx& tx, vtxPrev)\n    {\n        if (!tx.IsCoinBase())\n        {\n            uint256 hash = tx.GetHash();\n            if (!txdb.ContainsTx(hash))\n                RelayMessage(CInv(MSG_TX, hash), (CTransaction)tx);\n        }\n    }\n    if (!IsCoinBase())\n    {\n        uint256 hash = GetHash();\n        if (!txdb.ContainsTx(hash))\n        {\n            printf(\"Relaying wtx %s\\n\", hash.ToString().substr(0,10).c_str());\n            RelayMessage(CInv(MSG_TX, hash), (CTransaction)*this);\n        }\n    }\n}\n\nvoid CWalletTx::RelayWalletTransaction()\n{\n   CTxDB txdb(\"r\");\n   RelayWalletTransaction(txdb);\n}\n\nvoid CWallet::ResendWalletTransactions(bool fForce) {\n    int64 nCurrentTime = GetTime();\n\n    if(fForce || (nCurrentTime >= nNextResendTxTime)) {\n        /* Schedule the next resend time */\n        nNextResendTxTime = nCurrentTime + (5 * 60) + GetRand(30 * 60);\n    } else {\n        if(!fForce) return;\n    }\n\n    // Rebroadcast any of our txes that aren't in a block yet\n    printf(\"ResendWalletTransactions()\\n\");\n    CTxDB txdb(\"r\");\n    {\n        LOCK(cs_wallet);\n        // Sort them in chronological order\n        multimap<unsigned int, CWalletTx*> mapSorted;\n        BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n        {\n            CWalletTx& wtx = item.second;\n            // Don't rebroadcast until it's had plenty of time that\n            // it should have gotten in already by now.\n            if (nTimeBestReceived - (int64)wtx.nTimeReceived > 5 * 60)\n                mapSorted.insert(make_pair(wtx.nTimeReceived, &wtx));\n        }\n        BOOST_FOREACH(PAIRTYPE(const unsigned int, CWalletTx*)& item, mapSorted)\n        {\n            CWalletTx& wtx = *item.second;\n            wtx.RelayWalletTransaction(txdb);\n        }\n    }\n}\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Actions\n//\n\n/* Calculates either available or unconfirmed balance or both:\n * bit 0 = available balance;\n * bit 1 = unconfirmed balance\n * NOTE: this code makes use of TX_MATURITY rather than IsConfirmed() */\nint64 CWallet::GetBalance(uint nSettings) const {\n    int64 nTotal = 0;\n    LOCK(cs_wallet);\n    for(map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it) {\n        const CWalletTx* pcoin = &(*it).second;\n        int nDepth = pcoin->GetDepthInMainChain();\n        if((nSettings & 0x1) && (nDepth >= TX_MATURITY))\n          nTotal += pcoin->GetAvailableCredit();\n        if((nSettings & 0x2) && (nDepth < TX_MATURITY) && (nDepth >= 0))\n          nTotal += pcoin->GetAvailableCredit();\n    }\n    return(nTotal);\n}\n\n/* Calculates minted rewards, either immature or complete, for PoW:\n * bit 0 = PoW rewards;\n * bit 2 = immature only */\nint64 CWallet::GetMinted(uint nSettings) const {\n    int64 nTotal = 0;\n    LOCK(cs_wallet);\n    for(map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it) {\n        const CWalletTx* pcoin = &(*it).second;\n        if(((nSettings & 0x1) && pcoin->IsCoinBase())) {\n            int nDepth = pcoin->GetDepthInMainChain();\n            if(nDepth > 0) {\n                if(((nSettings & 0x4) && (nDepth < nBaseMaturity)) || !(nSettings & 0x4)) {\n                    /* PoW base transactions have zero debit */                \n                      nTotal += CWallet::GetCredit(*pcoin);\n                }\n            }\n        }\n    }\n    return(nTotal);\n}\n\n// populate vCoins with vector of spendable COutputs\nvoid CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl) const\n{\n    vCoins.clear();\n\n    {\n        LOCK(cs_wallet);\n        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        {\n            const CWalletTx* pcoin = &(*it).second;\n\n            if (!pcoin->IsFinal())\n                continue;\n\n            if (fOnlyConfirmed && !pcoin->IsConfirmed())\n                continue;\n\n            if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n                continue;\n\n            // If output is less than minimum value, then don't include transaction.\n            // This is to help deal with dust spam clogging up create transactions.\n            for(unsigned int i = 0; i < pcoin->vout.size(); i++)\n                if(!(pcoin->IsSpent(i)) &&\n                  IsMine(pcoin->vout[i]) &&\n                  !IsLockedCoin((*it).first, i) && \n                  (pcoin->vout[i].nValue >= nMinimumInputValue) &&\n                  (!coinControl || !coinControl->HasSelected() || coinControl->IsSelected((*it).first, i)))\n                    vCoins.push_back(COutput(pcoin, i, pcoin->GetDepthInMainChain()));\n        }\n    }\n}\n\nstatic void ApproximateBestSubset(vector<pair<int64, pair<const CWalletTx*,unsigned int> > >vValue, int64 nTotalLower, int64 nTargetValue,\n                                  vector<char>& vfBest, int64& nBest, int iterations = 1000)\n{\n    vector<char> vfIncluded;\n\n    vfBest.assign(vValue.size(), true);\n    nBest = nTotalLower;\n\n    for (int nRep = 0; nRep < iterations && nBest != nTargetValue; nRep++)\n    {\n        vfIncluded.assign(vValue.size(), false);\n        int64 nTotal = 0;\n        bool fReachedTarget = false;\n        for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)\n        {\n            for (unsigned int i = 0; i < vValue.size(); i++)\n            {\n                if (nPass == 0 ? rand() % 2 : !vfIncluded[i])\n                {\n                    nTotal += vValue[i].first;\n                    vfIncluded[i] = true;\n                    if (nTotal >= nTargetValue)\n                    {\n                        fReachedTarget = true;\n                        if (nTotal < nBest)\n                        {\n                            nBest = nTotal;\n                            vfBest = vfIncluded;\n                        }\n                        nTotal -= vValue[i].first;\n                        vfIncluded[i] = false;\n                    }\n                }\n            }\n        }\n    }\n}\n\nbool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfTheirs, vector<COutput> vCoins,\n                                 set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const\n{\n    setCoinsRet.clear();\n    nValueRet = 0;\n\n    // List of values less than target\n    pair<int64, pair<const CWalletTx*,unsigned int> > coinLowestLarger;\n    coinLowestLarger.first = std::numeric_limits<int64>::max();\n    coinLowestLarger.second.first = NULL;\n    vector<pair<int64, pair<const CWalletTx*,unsigned int> > > vValue;\n    int64 nTotalLower = 0;\n\n    random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n\n    BOOST_FOREACH(COutput output, vCoins)\n    {\n        const CWalletTx *pcoin = output.tx;\n\n        if (output.nDepth < (pcoin->IsFromMe() ? nConfMine : nConfTheirs))\n            continue;\n\n        int i = output.i;\n        int64 n = pcoin->vout[i].nValue;\n\n        pair<int64,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin, i));\n\n        if (n == nTargetValue)\n        {\n            setCoinsRet.insert(coin.second);\n            nValueRet += coin.first;\n            return true;\n        }\n        else if (n < nTargetValue + CENT)\n        {\n            vValue.push_back(coin);\n            nTotalLower += n;\n        }\n        else if (n < coinLowestLarger.first)\n        {\n            coinLowestLarger = coin;\n        }\n    }\n\n    if (nTotalLower == nTargetValue)\n    {\n        for (unsigned int i = 0; i < vValue.size(); ++i)\n        {\n            setCoinsRet.insert(vValue[i].second);\n            nValueRet += vValue[i].first;\n        }\n        return true;\n    }\n\n    if (nTotalLower < nTargetValue)\n    {\n        if (coinLowestLarger.second.first == NULL)\n            return false;\n        setCoinsRet.insert(coinLowestLarger.second);\n        nValueRet += coinLowestLarger.first;\n        return true;\n    }\n\n    // Solve subset sum by stochastic approximation\n    sort(vValue.rbegin(), vValue.rend(), CompareValueOnly());\n    vector<char> vfBest;\n    int64 nBest;\n\n    ApproximateBestSubset(vValue, nTotalLower, nTargetValue, vfBest, nBest, 1000);\n    if (nBest != nTargetValue && nTotalLower >= nTargetValue + CENT)\n        ApproximateBestSubset(vValue, nTotalLower, nTargetValue + CENT, vfBest, nBest, 1000);\n\n    // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,\n    //                                   or the next bigger coin is closer), return the bigger coin\n    if (coinLowestLarger.second.first &&\n        ((nBest != nTargetValue && nBest < nTargetValue + CENT) || coinLowestLarger.first <= nBest))\n    {\n        setCoinsRet.insert(coinLowestLarger.second);\n        nValueRet += coinLowestLarger.first;\n    }\n    else {\n        for (unsigned int i = 0; i < vValue.size(); i++)\n            if (vfBest[i])\n            {\n                setCoinsRet.insert(vValue[i].second);\n                nValueRet += vValue[i].first;\n            }\n\n        //// debug print\n        printf(\"SelectCoins() best subset: \");\n        for (unsigned int i = 0; i < vValue.size(); i++)\n            if (vfBest[i])\n                printf(\"%s \", FormatMoney(vValue[i].first).c_str());\n        printf(\"total %s\\n\", FormatMoney(nBest).c_str());\n    }\n\n    return true;\n}\n\nbool CWallet::SelectCoins(int64 nTargetValue, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet, const CCoinControl* coinControl) const\n{\n    vector<COutput> vCoins;\n    AvailableCoins(vCoins, true, coinControl);\n    \n    // Coin Control -> return all selected outputs \n    // (we want all selected to go into the transaction for sure)\n    if (coinControl && coinControl->HasSelected())\n    {\n        BOOST_FOREACH(const COutput& out, vCoins)\n        {\n            nValueRet += out.tx->vout[out.i].nValue;\n            setCoinsRet.insert(make_pair(out.tx, out.i));\n        }\n        return (nValueRet >= nTargetValue);\n    }\n\n    return (SelectCoinsMinConf(nTargetValue, 1, 6, vCoins, setCoinsRet, nValueRet) ||\n            SelectCoinsMinConf(nTargetValue, 1, 1, vCoins, setCoinsRet, nValueRet) ||\n            SelectCoinsMinConf(nTargetValue, 0, 1, vCoins, setCoinsRet, nValueRet));\n}\n\n\n\n\nbool CWallet::CreateTransaction(const vector<pair<CScript, int64> >& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, int64& nFeeRet, const CCoinControl* coinControl)\n{\n    int64 nValue = 0;\n    BOOST_FOREACH (const PAIRTYPE(CScript, int64)& s, vecSend)\n    {\n        if (nValue < 0)\n            return false;\n        nValue += s.second;\n    }\n    if (vecSend.empty() || nValue < 0)\n        return false;\n\n    wtxNew.BindWallet(this);\n\n    {\n        LOCK2(cs_main, cs_wallet);\n        // txdb must be opened before the mapWallet lock\n        CTxDB txdb(\"r\");\n        {\n            nFeeRet = nTransactionFee;\n            loop\n            {\n                wtxNew.vin.clear();\n                wtxNew.vout.clear();\n                wtxNew.fFromMe = true;\n\n                int64 nTotalValue = nValue + nFeeRet;\n                double dPriority = 0;\n                // vouts to the payees\n                BOOST_FOREACH (const PAIRTYPE(CScript, int64)& s, vecSend)\n                    wtxNew.vout.push_back(CTxOut(s.second, s.first));\n\n                // Choose coins to use\n                set<pair<const CWalletTx*,unsigned int> > setCoins;\n                int64 nValueIn = 0;\n                if(!SelectCoins(nTotalValue, setCoins, nValueIn, coinControl))\n                  return false;\n                BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins) {\n                    int64 nCredit = pcoin.first->vout[pcoin.second].nValue;\n                    dPriority += (double)nCredit * pcoin.first->GetDepthInMainChain();\n                }\n\n                int64 nChange = nValueIn - nValue - nFeeRet;\n\n                if(nChange >= TX_DUST) {\n\n                    // Fill a vout to ourself\n                    // TODO: pass in scriptChange instead of reservekey so\n                    // change transaction isn't always pay-to-bitcoin-address\n                    CScript scriptChange;\n\n                    // Coin Control: send the change to a custom address\n                    if(coinControl && !boost::get<CNoDestination>(&coinControl->destChange)) {\n\n                       // Select the Coin Control destination address\n                       scriptChange.SetDestination(coinControl->destChange);\n                       // Return the unused key pair to the pool\n                       reservekey.ReturnKey();\n\n                    } else {\n\n                    // Send the change to a new address\n\n// Note: We use a new key here to keep it from being obvious which side is the change.\n// The drawback is that by not reusing a previous key, the change may be lost if a\n// backup is restored, if the backup doesn't have the new private key for the change.\n// If we reused the old key, it would be possible to add code to look for and\n// rediscover unknown transactions that were written with keys of ours to recover\n// post-backup change.\n\n                        // Reserve a new key pair from key pool\n                        CPubKey vchPubKey = reservekey.GetReservedKey();\n\n                        scriptChange.SetDestination(vchPubKey.GetID());\n                    }\n\n                    // Insert the change at a random position\n                    vector<CTxOut>::iterator position = wtxNew.vout.begin()+GetRandInt(wtxNew.vout.size());\n                    wtxNew.vout.insert(position, CTxOut(nChange, scriptChange));\n\n                } else {\n\n                    // To avoid dust outputs, any change smaller\n                    // than TX_DUST is added to transaction fees\n                    nFeeRet += nChange;\n                    nChange  = 0;\n                    reservekey.ReturnKey();\n\n                }\n\n                // Fill vin\n                BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n                    wtxNew.vin.push_back(CTxIn(coin.first->GetHash(),coin.second));\n\n                // Sign\n                int nIn = 0;\n                BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n                    if (!SignSignature(*this, *coin.first, wtxNew, nIn++))\n                        return false;\n\n                // Limit size\n                unsigned int nTxSize = ::GetSerializeSize(*(CTransaction*)&wtxNew, SER_NETWORK, PROTOCOL_VERSION);\n                if(nTxSize >= MAX_BLOCK_SIZE_GEN/5) return false;\n                dPriority /= nTxSize;\n\n                // Check that enough fee is included\n                int64 nPayFee = nTransactionFee * (1 + (int64)nTxSize / 1000);\n                bool fAllowFree = CTransaction::AllowFree(dPriority);\n                int64 nMinFee = wtxNew.GetMinFee(nTxSize, fAllowFree, GMF_SEND);\n                if (nFeeRet < max(nPayFee, nMinFee))\n                {\n                    nFeeRet = max(nPayFee, nMinFee);\n                    continue;\n                }\n\n                // Fill vtxPrev by copying from previous transactions vtxPrev\n                wtxNew.AddSupportingTransactions(txdb);\n                wtxNew.fTimeReceivedIsTxTime = true;\n\n                break;\n            }\n        }\n    }\n    return true;\n}\n\nbool CWallet::CreateTransaction(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, CReserveKey& reservekey, int64& nFeeRet, const CCoinControl* coinControl)\n{\n    vector< pair<CScript, int64> > vecSend;\n    vecSend.push_back(make_pair(scriptPubKey, nValue));\n    return CreateTransaction(vecSend, wtxNew, reservekey, nFeeRet, coinControl);\n}\n\n// Call after CreateTransaction unless you want to abort\nbool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n{\n    {\n        LOCK2(cs_main, cs_wallet);\n        printf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n        {\n            // This is only to keep the database open to defeat the auto-flush for the\n            // duration of this scope.  This is the only place where this optimization\n            // maybe makes sense; please don't do it anywhere else.\n            CWalletDB* pwalletdb = fFileBacked ? new CWalletDB(strWalletFile,\"r\") : NULL;\n\n            // Take key pair from key pool so it won't be used again\n            reservekey.KeepKey();\n\n            // Add tx to wallet, because if it has change it's also ours,\n            // otherwise just for transaction history.\n            AddToWallet(wtxNew);\n\n            // Mark old coins as spent\n            set<CWalletTx*> setCoins;\n            BOOST_FOREACH(const CTxIn& txin, wtxNew.vin)\n            {\n                CWalletTx &coin = mapWallet[txin.prevout.hash];\n                coin.BindWallet(this);\n                coin.MarkSpent(txin.prevout.n);\n                coin.WriteToDisk();\n                NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED);\n            }\n\n            if (fFileBacked)\n                delete pwalletdb;\n        }\n\n        // Track how many getdata requests our transaction gets\n        mapRequestCount[wtxNew.GetHash()] = 0;\n\n        // Broadcast\n        if (!wtxNew.AcceptToMemoryPool())\n        {\n            // This must not fail. The transaction has already been signed and recorded.\n            printf(\"CommitTransaction() : Error: Transaction not valid\");\n            return false;\n        }\n        wtxNew.RelayWalletTransaction();\n    }\n    return true;\n}\n\n\n\n\nstring CWallet::SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, bool fAskFee)\n{\n    CReserveKey reservekey(this);\n    int64 nFeeRequired;\n\n    if (IsLocked())\n    {\n        string strError = _(\"Error: Wallet locked, unable to create transaction  \");\n        printf(\"SendMoney() : %s\", strError.c_str());\n        return strError;\n    }\n    if (!CreateTransaction(scriptPubKey, nValue, wtxNew, reservekey, nFeeRequired))\n    {\n        string strError;\n        if (nValue + nFeeRequired > GetBalance(0x3))\n            strError = strprintf(_(\"Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds  \"), FormatMoney(nFeeRequired).c_str());\n        else\n            strError = _(\"Error: Transaction creation failed  \");\n        printf(\"SendMoney() : %s\", strError.c_str());\n        return strError;\n    }\n\n    if (fAskFee && !uiInterface.ThreadSafeAskFee(nFeeRequired, _(\"Sending...\")))\n        return \"ABORTED\";\n\n    if (!CommitTransaction(wtxNew, reservekey))\n        return _(\"Error: The transaction was rejected.  This might happen if some of the coins in your wallet were already spent, such as if you used a copy of wallet.dat and coins were spent in the copy but not marked as spent here.\");\n\n    return \"\";\n}\n\n\n\nstring CWallet::SendMoneyToDestination(const CTxDestination& address, int64 nValue, CWalletTx& wtxNew, bool fAskFee)\n{\n    // Check amount\n    if (nValue <= 0)\n        return _(\"Invalid amount\");\n    if (nValue + nTransactionFee > GetBalance(0x3))\n        return _(\"Insufficient funds\");\n\n    // Parse Bitcoin address\n    CScript scriptPubKey;\n    scriptPubKey.SetDestination(address);\n\n    return SendMoney(scriptPubKey, nValue, wtxNew, fAskFee);\n}\n\n\n\n\nint CWallet::LoadWallet(bool& fFirstRunRet)\n{\n    if (!fFileBacked)\n        return false;\n    fFirstRunRet = false;\n    int nLoadWalletRet = CWalletDB(strWalletFile,\"cr+\").LoadWallet(this);\n    if (nLoadWalletRet == DB_NEED_REWRITE)\n    {\n        if (CDB::Rewrite(strWalletFile, \"\\x04pool\"))\n        {\n            setKeyPool.clear();\n            // Note: can't top-up keypool here, because wallet is locked.\n            // User will be prompted to unlock wallet the next operation\n            // the requires a new key.\n        }\n        nLoadWalletRet = DB_NEED_REWRITE;\n    }\n\n    if (nLoadWalletRet != DB_LOAD_OK)\n        return nLoadWalletRet;\n    fFirstRunRet = !vchDefaultKey.IsValid();\n\n    CreateThread(ThreadFlushWalletDB, &strWalletFile);\n    return DB_LOAD_OK;\n}\n\n\nbool CWallet::SetAddressBookName(const CTxDestination& address, const string& strName)\n{\n    std::map<CTxDestination, std::string>::iterator mi = mapAddressBook.find(address);\n    mapAddressBook[address] = strName;\n    NotifyAddressBookChanged(this, address, strName, ::IsMine(*this, address), (mi == mapAddressBook.end()) ? CT_NEW : CT_UPDATED);\n    if (!fFileBacked)\n        return false;\n    return CWalletDB(strWalletFile).WriteName(CBitcoinAddress(address).ToString(), strName);\n}\n\nbool CWallet::DelAddressBookName(const CTxDestination& address)\n{\n    mapAddressBook.erase(address);\n    NotifyAddressBookChanged(this, address, \"\", ::IsMine(*this, address), CT_DELETED);\n    if (!fFileBacked)\n        return false;\n    return CWalletDB(strWalletFile).EraseName(CBitcoinAddress(address).ToString());\n}\n\n\nvoid CWallet::PrintWallet(const CBlock& block)\n{\n    {\n        LOCK(cs_wallet);\n        if (mapWallet.count(block.vtx[0].GetHash()))\n        {\n            CWalletTx& wtx = mapWallet[block.vtx[0].GetHash()];\n            printf(\"    mine:  %d  %d  %d\", wtx.GetDepthInMainChain(), wtx.GetBlocksToMaturity(), wtx.GetCredit());\n        }\n    }\n    printf(\"\\n\");\n}\n\nbool CWallet::GetTransaction(const uint256 &hashTx, CWalletTx& wtx)\n{\n    {\n        LOCK(cs_wallet);\n        map<uint256, CWalletTx>::iterator mi = mapWallet.find(hashTx);\n        if (mi != mapWallet.end())\n        {\n            wtx = (*mi).second;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool CWallet::SetDefaultKey(const CPubKey &vchPubKey)\n{\n    if (fFileBacked)\n    {\n        if (!CWalletDB(strWalletFile).WriteDefaultKey(vchPubKey))\n            return false;\n    }\n    vchDefaultKey = vchPubKey;\n    return true;\n}\n\nbool GetWalletFile(CWallet* pwallet, string &strWalletFileOut)\n{\n    if (!pwallet->fFileBacked)\n        return false;\n    strWalletFileOut = pwallet->strWalletFile;\n    return true;\n}\n\n//\n// Mark old keypool keys as used,\n// and generate all new keys\n//\nbool CWallet::NewKeyPool()\n{\n    {\n        LOCK(cs_wallet);\n        CWalletDB walletdb(strWalletFile);\n        BOOST_FOREACH(int64 nIndex, setKeyPool)\n            walletdb.ErasePool(nIndex);\n        setKeyPool.clear();\n\n        if (IsLocked())\n            return false;\n\n        int64 nKeys = max(GetArg(\"-keypool\", 100), (int64)0);\n        for (int i = 0; i < nKeys; i++)\n        {\n            int64 nIndex = i+1;\n            walletdb.WritePool(nIndex, CKeyPool(GenerateNewKey()));\n            setKeyPool.insert(nIndex);\n        }\n        printf(\"CWallet::NewKeyPool wrote %\"PRI64d\" new keys\\n\", nKeys);\n    }\n    return true;\n}\n\nbool CWallet::TopUpKeyPool()\n{\n    {\n        LOCK(cs_wallet);\n\n        if (IsLocked())\n            return false;\n\n        CWalletDB walletdb(strWalletFile);\n\n        // Top up key pool\n        unsigned int nTargetSize = max(GetArg(\"-keypool\", 100), 0LL);\n        while (setKeyPool.size() < (nTargetSize + 1))\n        {\n            int64 nEnd = 1;\n            if (!setKeyPool.empty())\n                nEnd = *(--setKeyPool.end()) + 1;\n            if (!walletdb.WritePool(nEnd, CKeyPool(GenerateNewKey())))\n                throw runtime_error(\"TopUpKeyPool() : writing generated key failed\");\n            setKeyPool.insert(nEnd);\n            printf(\"keypool added key %\"PRI64d\", size=%d\\n\", nEnd, setKeyPool.size());\n        }\n    }\n    return true;\n}\n\nvoid CWallet::ReserveKeyFromKeyPool(int64& nIndex, CKeyPool& keypool)\n{\n    nIndex = -1;\n    keypool.vchPubKey = CPubKey();\n    {\n        LOCK(cs_wallet);\n\n        if (!IsLocked())\n            TopUpKeyPool();\n\n        // Get the oldest key\n        if(setKeyPool.empty())\n            return;\n\n        CWalletDB walletdb(strWalletFile);\n\n        nIndex = *(setKeyPool.begin());\n        setKeyPool.erase(setKeyPool.begin());\n        if (!walletdb.ReadPool(nIndex, keypool))\n            throw runtime_error(\"ReserveKeyFromKeyPool() : read failed\");\n        if (!HaveKey(keypool.vchPubKey.GetID()))\n            throw runtime_error(\"ReserveKeyFromKeyPool() : unknown key in key pool\");\n        assert(keypool.vchPubKey.IsValid());\n        printf(\"keypool reserve %\"PRI64d\"\\n\", nIndex);\n    }\n}\n\nint64 CWallet::AddReserveKey(const CKeyPool& keypool)\n{\n    {\n        LOCK2(cs_main, cs_wallet);\n        CWalletDB walletdb(strWalletFile);\n\n        int64 nIndex = 1 + *(--setKeyPool.end());\n        if (!walletdb.WritePool(nIndex, keypool))\n            throw runtime_error(\"AddReserveKey() : writing added key failed\");\n        setKeyPool.insert(nIndex);\n        return nIndex;\n    }\n    return -1;\n}\n\nvoid CWallet::KeepKey(int64 nIndex)\n{\n    // Remove from key pool\n    if (fFileBacked)\n    {\n        CWalletDB walletdb(strWalletFile);\n        walletdb.ErasePool(nIndex);\n    }\n    printf(\"keypool keep %\"PRI64d\"\\n\", nIndex);\n}\n\nvoid CWallet::ReturnKey(int64 nIndex)\n{\n    // Return to key pool\n    {\n        LOCK(cs_wallet);\n        setKeyPool.insert(nIndex);\n    }\n    printf(\"keypool return %\"PRI64d\"\\n\", nIndex);\n}\n\nbool CWallet::GetKeyFromPool(CPubKey& result, bool fAllowReuse)\n{\n    int64 nIndex = 0;\n    CKeyPool keypool;\n    {\n        LOCK(cs_wallet);\n        ReserveKeyFromKeyPool(nIndex, keypool);\n        if (nIndex == -1)\n        {\n            if (fAllowReuse && vchDefaultKey.IsValid())\n            {\n                result = vchDefaultKey;\n                return true;\n            }\n            if (IsLocked()) return false;\n            result = GenerateNewKey();\n            return true;\n        }\n        KeepKey(nIndex);\n        result = keypool.vchPubKey;\n    }\n    return true;\n}\n\nint64 CWallet::GetOldestKeyPoolTime()\n{\n    int64 nIndex = 0;\n    CKeyPool keypool;\n    ReserveKeyFromKeyPool(nIndex, keypool);\n    if (nIndex == -1)\n        return GetTime();\n    ReturnKey(nIndex);\n    return keypool.nTime;\n}\n\nCPubKey CReserveKey::GetReservedKey()\n{\n    if(nIndex == -1) {\n        if(fDefaultKey) vchPubKey = pwallet->vchDefaultKey;\n        else {\n            CKeyPool keypool;\n            pwallet->ReserveKeyFromKeyPool(nIndex, keypool);\n            if(nIndex != -1) vchPubKey = keypool.vchPubKey;\n            else {\n                printf(\"CReserveKey::GetReservedKey(): key pool is empty, using the default key\\n\");\n                vchPubKey = pwallet->vchDefaultKey;\n            }\n        }\n    } \n    assert(vchPubKey.IsValid());\n    return vchPubKey;\n}\n\nvoid CReserveKey::KeepKey()\n{\n    if (nIndex != -1)\n        pwallet->KeepKey(nIndex);\n    nIndex = -1;\n    vchPubKey = CPubKey();\n}\n\nvoid CReserveKey::ReturnKey()\n{\n    if (nIndex != -1)\n        pwallet->ReturnKey(nIndex);\n    nIndex = -1;\n    vchPubKey = CPubKey();\n}\n\nvoid CWallet::GetAllReserveKeys(set<CKeyID>& setAddress)\n{\n    setAddress.clear();\n\n    CWalletDB walletdb(strWalletFile);\n\n    LOCK2(cs_main, cs_wallet);\n    BOOST_FOREACH(const int64& id, setKeyPool)\n    {\n        CKeyPool keypool;\n        if (!walletdb.ReadPool(id, keypool))\n            throw runtime_error(\"GetAllReserveKeyHashes() : read failed\");\n        assert(keypool.vchPubKey.IsValid());\n        CKeyID keyID = keypool.vchPubKey.GetID();\n        if (!HaveKey(keyID))\n            throw runtime_error(\"GetAllReserveKeyHashes() : unknown key in key pool\");\n        setAddress.insert(keyID);\n    }\n}\n\nvoid CWallet::UpdatedTransaction(const uint256 &hashTx)\n{\n    {\n        LOCK(cs_wallet);\n        // Only notify UI if this transaction is in this wallet\n        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(hashTx);\n        if (mi != mapWallet.end())\n            NotifyTransactionChanged(this, hashTx, CT_UPDATED);\n    }\n}\n\nvoid CWallet::LockCoin(COutPoint& output)\n{\n    setLockedCoins.insert(output);\n}\n\nvoid CWallet::UnlockCoin(COutPoint& output)\n{\n    setLockedCoins.erase(output);\n}\n\nvoid CWallet::UnlockAllCoins()\n{\n    setLockedCoins.clear();\n}\n\nbool CWallet::IsLockedCoin(uint256 hash, unsigned int n) const\n{\n    COutPoint outpt(hash, n);\n\n    return (setLockedCoins.count(outpt) > 0);\n}\n\nvoid CWallet::ListLockedCoins(std::vector<COutPoint>& vOutpts)\n{\n    for (std::set<COutPoint>::iterator it = setLockedCoins.begin();\n         it != setLockedCoins.end(); it++) {\n        COutPoint outpt = (*it);\n        vOutpts.push_back(outpt);\n    }\n}\n\n\n/* Checks for wallet vs. transaction index consistency;\n * reports any spent state inconsistency found and\n * (optionally) fixes the wallet according to the transaction index */\nvoid CWallet::FixSpentCoins(int& nMismatchFound, int& nOrphansFound, int64& nBalanceInQuestion,\n  bool fCheckOnly) {\n    nMismatchFound = 0;\n    nBalanceInQuestion = 0;\n    nOrphansFound = 0;\n\n    LOCK(cs_wallet);\n    vector<CWalletTx*> vCoins;\n    vCoins.reserve(mapWallet.size());\n    for(map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n      vCoins.push_back(&(*it).second);\n\n    CTxDB txdb(\"r\");\n    BOOST_FOREACH(CWalletTx* pcoin, vCoins) {\n        uint256 hash = pcoin->GetHash();\n        CTxIndex txindex;\n        uint n;\n\n        if(!txdb.ReadTxIndex(hash, txindex) && !pcoin->IsCoinBase())\n          continue;\n\n        for(n = 0; n < pcoin->vout.size(); n++) {\n            bool fUpdated = false;\n\n            if(IsMine(pcoin->vout[n])) {\n                if(pcoin->IsSpent(n) &&\n                  ((txindex.vSpent.size() <= n) || txindex.vSpent[n].IsNull())) {\n                    printf(\"FixSpentCoins() found lost coins %s %s[%d], %s\\n\",\n                      FormatMoney(pcoin->vout[n].nValue).c_str(), hash.ToString().c_str(), n,\n                        fCheckOnly? \"repair not attempted\" : \"repairing\");\n                    nMismatchFound++;\n                    nBalanceInQuestion += pcoin->vout[n].nValue;\n                    if(!fCheckOnly) {\n                        fUpdated = true;\n                        pcoin->MarkUnspent(n);\n                        pcoin->WriteToDisk();\n                    }\n                } else if(!pcoin->IsSpent(n) &&\n                  (txindex.vSpent.size() > n && !txindex.vSpent[n].IsNull())) {\n                    printf(\"FixSpentCoins() found spent coins %s %s[%d], %s\\n\",\n                      FormatMoney(pcoin->vout[n].nValue).c_str(), hash.ToString().c_str(), n,\n                        fCheckOnly? \"repair not attempted\" : \"repairing\");\n                    nMismatchFound++;\n                    nBalanceInQuestion += pcoin->vout[n].nValue;\n                    if(!fCheckOnly) {\n                        fUpdated = true;\n                        pcoin->MarkSpent(n);\n                        pcoin->WriteToDisk();\n                    }\n                }\n\n            }\n\n            if(fUpdated)\n              NotifyTransactionChanged(this, hash, CT_UPDATED);\n        }\n\n        if(pcoin->IsCoinBase() && (pcoin->GetDepthInMainChain() < 0)) {\n           nOrphansFound++;\n           if(!fCheckOnly) {\n               EraseFromWallet(hash);\n               NotifyTransactionChanged(this, hash, CT_DELETED);\n           }\n           printf(\"FixSpentCoins() %s orphaned generation tx %s\\n\",\n             fCheckOnly ? \"found\" : \"removed\", hash.ToString().c_str());\n        }\n    }\n}\n"], "fixing_code": ["// Copyright (c) 2009-2010 Satoshi Nakamoto\n// Copyright (c) 2009-2012 The Bitcoin developers\n// Copyright (c) 2011-2012 Litecoin Developers\n// Copyright (c) 2013-2014 Phoenixcoin Developers\n// Distributed under the MIT/X11 software license, see the accompanying\n// file LICENCE or http://www.opensource.org/licenses/mit-license.php\n\n#include \"checkpoints.h\"\n#include \"db.h\"\n#include \"net.h\"\n#include \"init.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"checkpointsync.h\"\n#include <boost/algorithm/string/replace.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/filesystem/fstream.hpp>\n\nusing namespace std;\nusing namespace boost;\n\n//\n// Global state\n//\n\nCCriticalSection cs_setpwalletRegistered;\nset<CWallet*> setpwalletRegistered;\n\nCCriticalSection cs_main;\n\nCTxMemPool mempool;\nunsigned int nTransactionsUpdated = 0;\n\nint nBaseMaturity = BASE_MATURITY;\n\nmap<uint256, CBlockIndex*> mapBlockIndex;\nuint256 hashGenesisBlock(\"0xbe2f30f9e8db8f430056869c43503a992d232b28508e83eda101161a18cf7c73\");\n// The lowest possible difficulty which is also the starting difficulty (1 / 2^12)\nstatic CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\n/* The difficulty after switching to NeoScrypt (0.015625) */\nstatic CBigNum bnNeoScryptSwitch(~uint256(0) >> 26);\nCBlockIndex* pindexGenesisBlock = NULL;\nint nBestHeight = -1;\nCBigNum bnBestChainWork = 0;\nCBigNum bnBestInvalidWork = 0;\nuint256 hashBestChain = 0;\nCBlockIndex* pindexBest = NULL;\nint64 nTimeBestReceived = 0;\n\nCMedianFilter<int> cPeerBlockCounts(5, 0); // Amount of blocks that other nodes claim to have\n\nmap<uint256, CBlock*> mapOrphanBlocks;\nmultimap<uint256, CBlock*> mapOrphanBlocksByPrev;\n\nmap<uint256, CDataStream*> mapOrphanTransactions;\nmap<uint256, map<uint256, CDataStream*> > mapOrphanTransactionsByPrev;\n\n// Constant stuff for coinbase transactions we create:\nCScript COINBASE_FLAGS;\n\nconst string strMessageMagic = \"Phoenixcoin Signed Message:\\n\";\n\ndouble dHashesPerSec;\nint64 nHPSTimerStart;\n\n// Settings\nint64 nTransactionFee = 0;\nint64 nMinimumInputValue = CENT / 100;\n\n\n/* Old network magic number */\nuchar pchMessageStart[4]    = { 0xFB, 0xC0, 0xB6, 0xDB };\n/* New network magic number;\n * 0xFE and ASCII 'P' 'X' 'C' mapped into extended characters */\nuchar pchMessageStartNew[4] = { 0xFE, 0xD0, 0xD8, 0xC3 };\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// dispatching functions\n//\n\n// These functions dispatch to one or all registered wallets\n\n\nvoid RegisterWallet(CWallet* pwalletIn)\n{\n    {\n        LOCK(cs_setpwalletRegistered);\n        setpwalletRegistered.insert(pwalletIn);\n    }\n}\n\nvoid UnregisterWallet(CWallet* pwalletIn)\n{\n    {\n        LOCK(cs_setpwalletRegistered);\n        setpwalletRegistered.erase(pwalletIn);\n    }\n}\n\n// check whether the passed transaction is from us\nbool static IsFromMe(CTransaction& tx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        if (pwallet->IsFromMe(tx))\n            return true;\n    return false;\n}\n\n// get the wallet transaction with the given hash (if it exists)\nbool static GetTransaction(const uint256& hashTx, CWalletTx& wtx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        if (pwallet->GetTransaction(hashTx,wtx))\n            return true;\n    return false;\n}\n\n// erases transaction with the given hash from all wallets\nvoid static EraseFromWallets(uint256 hash)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->EraseFromWallet(hash);\n}\n\n// make sure all wallets know about the given transaction, in the given block\nvoid SyncWithWallets(const CTransaction& tx, const CBlock* pblock, bool fUpdate)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->AddToWalletIfInvolvingMe(tx, pblock, fUpdate);\n}\n\n// notify wallets about a new best chain\nvoid static SetBestChain(const CBlockLocator& loc)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->SetBestChain(loc);\n}\n\n// notify wallets about an updated transaction\nvoid static UpdatedTransaction(const uint256& hashTx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->UpdatedTransaction(hashTx);\n}\n\n// dump all wallets\nvoid static PrintWallets(const CBlock& block)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->PrintWallet(block);\n}\n\n// notify wallets about an incoming inventory (for request counts)\nvoid static Inventory(const uint256& hash)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->Inventory(hash);\n}\n\n// ask wallets to resend their transactions\nvoid ResendWalletTransactions(bool fForce)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->ResendWalletTransactions(fForce);\n}\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// mapOrphanTransactions\n//\n\nbool AddOrphanTx(const CDataStream& vMsg)\n{\n    CTransaction tx;\n    CDataStream(vMsg) >> tx;\n    uint256 hash = tx.GetHash();\n    if (mapOrphanTransactions.count(hash))\n        return false;\n\n    CDataStream* pvMsg = new CDataStream(vMsg);\n\n    // Ignore big transactions, to avoid a\n    // send-big-orphans memory exhaustion attack. If a peer has a legitimate\n    // large transaction with a missing parent then we assume\n    // it will rebroadcast it later, after the parent transaction(s)\n    // have been mined or received.\n    // 10,000 orphans, each of which is at most 5,000 bytes big is\n    // at most 500 megabytes of orphans:\n    if (pvMsg->size() > 5000)\n    {\n        printf(\"ignoring large orphan tx (size: %u, hash: %s)\\n\", pvMsg->size(), hash.ToString().substr(0,10).c_str());\n        delete pvMsg;\n        return false;\n    }\n\n    mapOrphanTransactions[hash] = pvMsg;\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n        mapOrphanTransactionsByPrev[txin.prevout.hash].insert(make_pair(hash, pvMsg));\n\n    printf(\"stored orphan tx %s (mapsz %u)\\n\", hash.ToString().substr(0,10).c_str(),\n        mapOrphanTransactions.size());\n    return true;\n}\n\nvoid static EraseOrphanTx(uint256 hash)\n{\n    if (!mapOrphanTransactions.count(hash))\n        return;\n    const CDataStream* pvMsg = mapOrphanTransactions[hash];\n    CTransaction tx;\n    CDataStream(*pvMsg) >> tx;\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n    {\n        mapOrphanTransactionsByPrev[txin.prevout.hash].erase(hash);\n        if (mapOrphanTransactionsByPrev[txin.prevout.hash].empty())\n            mapOrphanTransactionsByPrev.erase(txin.prevout.hash);\n    }\n    delete pvMsg;\n    mapOrphanTransactions.erase(hash);\n}\n\nunsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n{\n    unsigned int nEvicted = 0;\n    while (mapOrphanTransactions.size() > nMaxOrphans)\n    {\n        // Evict a random orphan:\n        uint256 randomhash = GetRandHash();\n        map<uint256, CDataStream*>::iterator it = mapOrphanTransactions.lower_bound(randomhash);\n        if (it == mapOrphanTransactions.end())\n            it = mapOrphanTransactions.begin();\n        EraseOrphanTx(it->first);\n        ++nEvicted;\n    }\n    return nEvicted;\n}\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CTransaction and CTxIndex\n//\n\nbool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet)\n{\n    SetNull();\n    if (!txdb.ReadTxIndex(prevout.hash, txindexRet))\n        return false;\n    if (!ReadFromDisk(txindexRet.pos))\n        return false;\n    if (prevout.n >= vout.size())\n    {\n        SetNull();\n        return false;\n    }\n    return true;\n}\n\nbool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout)\n{\n    CTxIndex txindex;\n    return ReadFromDisk(txdb, prevout, txindex);\n}\n\nbool CTransaction::ReadFromDisk(COutPoint prevout)\n{\n    CTxDB txdb(\"r\");\n    CTxIndex txindex;\n    return ReadFromDisk(txdb, prevout, txindex);\n}\n\nbool CTransaction::IsStandard() const\n{\n    if (nVersion > CTransaction::CURRENT_VERSION)\n        return false;\n\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        // Biggest 'standard' txin is a 3-signature 3-of-3 CHECKMULTISIG\n        // pay-to-script-hash, which is 3 ~80-byte signatures, 3\n        // ~65-byte public keys, plus a few script ops.\n        if (txin.scriptSig.size() > 500)\n            return false;\n        if (!txin.scriptSig.IsPushOnly())\n            return false;\n    }\n    BOOST_FOREACH(const CTxOut& txout, vout)\n        if (!::IsStandard(txout.scriptPubKey))\n            return false;\n    return true;\n}\n\n//\n// Check transaction inputs, and make sure any\n// pay-to-script-hash transactions are evaluating IsStandard scripts\n//\n// Why bother? To avoid denial-of-service attacks; an attacker\n// can submit a standard HASH... OP_EQUAL transaction,\n// which will get accepted into blocks. The redemption\n// script can be anything; an attacker could use a very\n// expensive-to-check-upon-redemption script like:\n//   DUP CHECKSIG DROP ... repeated 100 times... OP_1\n//\nbool CTransaction::AreInputsStandard(const MapPrevTx& mapInputs) const\n{\n    if (IsCoinBase())\n        return true; // Coinbases don't use vin normally\n\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        const CTxOut& prev = GetOutputFor(vin[i], mapInputs);\n\n        vector<vector<unsigned char> > vSolutions;\n        txnouttype whichType;\n        // get the scriptPubKey corresponding to this input:\n        const CScript& prevScript = prev.scriptPubKey;\n        if (!Solver(prevScript, whichType, vSolutions))\n            return false;\n        int nArgsExpected = ScriptSigArgsExpected(whichType, vSolutions);\n        if (nArgsExpected < 0)\n            return false;\n\n        // Transactions with extra stuff in their scriptSigs are\n        // non-standard. Note that this EvalScript() call will\n        // be quick, because if there are any operations\n        // beside \"push data\" in the scriptSig the\n        // IsStandard() call returns false\n        vector<vector<unsigned char> > stack;\n        if (!EvalScript(stack, vin[i].scriptSig, *this, i, 0))\n            return false;\n\n        if (whichType == TX_SCRIPTHASH)\n        {\n            if (stack.empty())\n                return false;\n            CScript subscript(stack.back().begin(), stack.back().end());\n            vector<vector<unsigned char> > vSolutions2;\n            txnouttype whichType2;\n            if (!Solver(subscript, whichType2, vSolutions2))\n                return false;\n            if (whichType2 == TX_SCRIPTHASH)\n                return false;\n\n            int tmpExpected;\n            tmpExpected = ScriptSigArgsExpected(whichType2, vSolutions2);\n            if (tmpExpected < 0)\n                return false;\n            nArgsExpected += tmpExpected;\n        }\n\n        if (stack.size() != (unsigned int)nArgsExpected)\n            return false;\n    }\n\n    return true;\n}\n\nunsigned int\nCTransaction::GetLegacySigOpCount() const\n{\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        nSigOps += txin.scriptSig.GetSigOpCount(false);\n    }\n    BOOST_FOREACH(const CTxOut& txout, vout)\n    {\n        nSigOps += txout.scriptPubKey.GetSigOpCount(false);\n    }\n    return nSigOps;\n}\n\n\nint CMerkleTx::SetMerkleBranch(const CBlock *pblock) {\n\n    CBlock blockTmp;\n    if(pblock == NULL) {\n        // Load the block this tx is in\n        CTxIndex txindex;\n        if(!CTxDB(\"r\").ReadTxIndex(GetHash(), txindex))\n          return(0);\n        if(!blockTmp.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos))\n          return(0);\n        pblock = &blockTmp;\n    }\n\n    // Update the tx's hashBlock\n    hashBlock = pblock->GetHash();\n\n    // Locate the transaction\n    for(nIndex = 0; nIndex < (int)pblock->vtx.size(); nIndex++)\n      if(pblock->vtx[nIndex] == *(CTransaction *)this) break;\n\n    if(nIndex == (int)pblock->vtx.size()) {\n        vMerkleBranch.clear();\n        nIndex = -1;\n        printf(\"ERROR: SetMerkleBranch() : couldn't find tx in block\\n\");\n        return(0);\n    }\n\n    // Fill in merkle branch\n    vMerkleBranch = pblock->GetMerkleBranch(nIndex);\n\n    // Is the tx in a block that's in the main chain\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n    if (mi == mapBlockIndex.end())\n        return 0;\n    CBlockIndex* pindex = (*mi).second;\n    if (!pindex || !pindex->IsInMainChain())\n        return 0;\n\n    return pindexBest->nHeight - pindex->nHeight + 1;\n}\n\n\n\n\n\n\n\nbool CTransaction::CheckTransaction() const\n{\n    // Basic checks that don't depend on any context\n    if (vin.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vin empty\"));\n    if (vout.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vout empty\"));\n    // Size limits\n    if (::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\"CTransaction::CheckTransaction() : size limits failed\"));\n\n    // Check for negative or overflow output values\n    int64 nValueOut = 0;\n    BOOST_FOREACH(const CTxOut& txout, vout)\n    {\n        if (txout.nValue < 0)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue negative\"));\n        if (txout.nValue > MAX_MONEY)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue too high\"));\n        nValueOut += txout.nValue;\n        if (!MoneyRange(nValueOut))\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout total out of range\"));\n    }\n\n    // Check for duplicate inputs\n    set<COutPoint> vInOutPoints;\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        if (vInOutPoints.count(txin.prevout))\n            return false;\n        vInOutPoints.insert(txin.prevout);\n    }\n\n    if (IsCoinBase())\n    {\n        if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : coinbase script size\"));\n    }\n    else\n    {\n        BOOST_FOREACH(const CTxIn& txin, vin)\n            if (txin.prevout.IsNull())\n                return DoS(10, error(\"CTransaction::CheckTransaction() : prevout is null\"));\n    }\n\n    return true;\n}\n\n\nbool CTxMemPool::accept(CTxDB &txdb, CTransaction &tx, bool fCheckInputs,\n  bool fLimitFree, bool *pfMissingInputs) {\n\n    if (pfMissingInputs)\n        *pfMissingInputs = false;\n\n    if (!tx.CheckTransaction())\n        return error(\"CTxMemPool::accept() : CheckTransaction failed\");\n\n    // Coinbase is only valid in a block, not as a loose transaction\n    if (tx.IsCoinBase())\n        return tx.DoS(100, error(\"CTxMemPool::accept() : coinbase as individual tx\"));\n\n    // To help v0.1.5 clients who would see it as a negative number\n    if ((int64)tx.nLockTime > std::numeric_limits<int>::max())\n        return error(\"CTxMemPool::accept() : not accepting nLockTime beyond 2038 yet\");\n\n    // Rather not work on nonstandard transactions (unless -testnet)\n    if (!fTestNet && !tx.IsStandard())\n        return error(\"CTxMemPool::accept() : nonstandard transaction type\");\n\n    // Do we already have it?\n    uint256 hash = tx.GetHash();\n    {\n        LOCK(cs);\n        if (mapTx.count(hash))\n            return false;\n    }\n    if (fCheckInputs)\n        if (txdb.ContainsTx(hash))\n            return false;\n\n    // Check for conflicts with in-memory transactions\n    CTransaction* ptxOld = NULL;\n    for (unsigned int i = 0; i < tx.vin.size(); i++)\n    {\n        COutPoint outpoint = tx.vin[i].prevout;\n        if (mapNextTx.count(outpoint))\n        {\n            // Disable replacement feature for now\n            return false;\n\n            // Allow replacing with a newer version of the same transaction\n            if (i != 0)\n                return false;\n            ptxOld = mapNextTx[outpoint].ptx;\n            if (ptxOld->IsFinal())\n                return false;\n            if (!tx.IsNewerThan(*ptxOld))\n                return false;\n            for (unsigned int i = 0; i < tx.vin.size(); i++)\n            {\n                COutPoint outpoint = tx.vin[i].prevout;\n                if (!mapNextTx.count(outpoint) || mapNextTx[outpoint].ptx != ptxOld)\n                    return false;\n            }\n            break;\n        }\n    }\n\n    if (fCheckInputs)\n    {\n        MapPrevTx mapInputs;\n        map<uint256, CTxIndex> mapUnused;\n        bool fInvalid = false;\n        if (!tx.FetchInputs(txdb, mapUnused, false, false, mapInputs, fInvalid))\n        {\n            if (fInvalid)\n                return error(\"CTxMemPool::accept() : FetchInputs found invalid tx %s\", hash.ToString().substr(0,10).c_str());\n            if (pfMissingInputs)\n                *pfMissingInputs = true;\n            return false;\n        }\n\n        // Check for non-standard pay-to-script-hash in inputs\n        if (!tx.AreInputsStandard(mapInputs) && !fTestNet)\n            return error(\"CTxMemPool::accept() : nonstandard transaction input\");\n\n        // Note: if you modify this code to accept non-standard transactions, then\n        // you should add code here to check that the transaction does a\n        // reasonable number of ECDSA signature verifications.\n\n        int64 nFees = tx.GetValueIn(mapInputs)-tx.GetValueOut();\n        unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n\n        // Don't accept it if it can't get into a block\n        if(fLimitFree && (nFees < tx.GetMinFee(nTxSize, true, GMF_RELAY)))\n          return(error(\"CTxMemPool::accept() : not enough fees\"));\n\n        // Continuously rate-limit free transactions\n        // This mitigates 'penny-flooding' -- sending thousands of free transactions just to\n        // be annoying or make other's transactions take longer to confirm.\n        if(fLimitFree && (nFees < MIN_RELAY_TX_FEE)) {\n            static double dFreeCount;\n            static int64 nLastTime;\n            int64 nNow = GetTime();\n\n            LOCK(cs);\n\n            // Use an exponentially decaying ~10-minute window:\n            dFreeCount *= pow(1.0 - 1.0 / 600.0, (double)(nNow - nLastTime));\n            nLastTime = nNow;\n            // -limitfreerelay unit is thousand-bytes-per-minute\n            // At default rate it would take over a month to fill 1GB\n            if(dFreeCount > GetArg(\"-limitfreerelay\", 15) * 10 * 1000)\n              return(error(\"CTxMemPool::accept() : free transaction rejected by rate limiter\"));\n            if(fDebug)\n              printf(\"Rate limit dFreeCount: %g => %g\\n\", dFreeCount, dFreeCount + nTxSize);\n            dFreeCount += nTxSize;\n        }\n\n        // Check against previous transactions\n        // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n        if (!tx.ConnectInputs(mapInputs, mapUnused, CDiskTxPos(1,1,1), pindexBest, false, false))\n        {\n            return error(\"CTxMemPool::accept() : ConnectInputs failed %s\", hash.ToString().substr(0,10).c_str());\n        }\n    }\n\n    // Store transaction in memory\n    {\n        LOCK(cs);\n        if (ptxOld)\n        {\n            printf(\"CTxMemPool::accept() : replacing tx %s with new version\\n\", ptxOld->GetHash().ToString().c_str());\n            remove(*ptxOld);\n        }\n        addUnchecked(hash, tx);\n    }\n\n    ///// are we sure this is ok when loading transactions or restoring block txes\n    // If updated, erase old tx from wallet\n    if (ptxOld)\n        EraseFromWallets(ptxOld->GetHash());\n\n    printf(\"CTxMemPool::accept() : accepted %s (poolsz %u)\\n\",\n           hash.ToString().substr(0,10).c_str(),\n           mapTx.size());\n    return true;\n}\n\nbool CTransaction::AcceptToMemoryPool(CTxDB &txdb, bool fCheckInputs, bool fLimitFree,\n  bool *pfMissingInputs) {\n\n    return mempool.accept(txdb, *this, fCheckInputs, fLimitFree, pfMissingInputs);\n}\n\nbool CTxMemPool::addUnchecked(const uint256& hash, CTransaction &tx)\n{\n    // Add to memory pool without checking anything.  Don't call this directly,\n    // call CTxMemPool::accept to properly check the transaction first.\n    {\n        mapTx[hash] = tx;\n        for (unsigned int i = 0; i < tx.vin.size(); i++)\n            mapNextTx[tx.vin[i].prevout] = CInPoint(&mapTx[hash], i);\n        nTransactionsUpdated++;\n    }\n    return true;\n}\n\n/* Removes a transaction from the memory pool */\nbool CTxMemPool::remove(const CTransaction &tx, bool fRecursive) {\n\n    LOCK(cs);\n    uint256 hash = tx.GetHash();\n    if(mapTx.count(hash)) {\n        if(fRecursive) {\n            uint i;\n            for(i = 0; i < tx.vout.size(); i++) {\n                std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(COutPoint(hash, i));\n                if(it != mapNextTx.end())\n                  remove(*it->second.ptx, true);\n            }\n        }\n        BOOST_FOREACH(const CTxIn &txin, tx.vin)\n          mapNextTx.erase(txin.prevout);\n        mapTx.erase(hash);\n        nTransactionsUpdated++;\n    }\n    return(true);\n}\n\n/* Removes transactions from the memory pool which depend on inputs of this transaction */\nbool CTxMemPool::removeConflicts(const CTransaction &tx) {\n\n    LOCK(cs);\n    BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n        std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(txin.prevout);\n        if(it != mapNextTx.end()) {\n            const CTransaction &txConflict = *it->second.ptx;\n            if(txConflict != tx)\n              remove(txConflict, true);\n        }\n    }\n    return(true);\n}\n\nvoid CTxMemPool::queryHashes(std::vector<uint256>& vtxid)\n{\n    vtxid.clear();\n\n    LOCK(cs);\n    vtxid.reserve(mapTx.size());\n    for (map<uint256, CTransaction>::iterator mi = mapTx.begin(); mi != mapTx.end(); ++mi)\n        vtxid.push_back((*mi).first);\n}\n\n\n\n\n/* Returns a transaction depth in the main chain or\n *  0 = in the memory pool, not yet in the main chain\n * -1 = failed transaction */\nint CMerkleTx::GetDepthInMainChain(CBlockIndex* &pindexRet) const {\n    bool fTxMempool = mempool.exists(GetHash());\n\n    if((hashBlock == 0) || (nIndex == -1))\n      return(fTxMempool ? 0 : -1);\n\n    // Find the block it claims to be in\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n    if(mi == mapBlockIndex.end())\n      return(fTxMempool ? 0 : -1);\n\n    CBlockIndex* pindex = (*mi).second;\n    if(!pindex || !pindex->IsInMainChain())\n      return(fTxMempool ? 0 : -1);\n\n    // Make sure the merkle branch connects to this block\n    if(!fMerkleVerified) {\n        if(CBlock::CheckMerkleBranch(GetHash(), vMerkleBranch, nIndex) != pindex->hashMerkleRoot)\n          return(fTxMempool ? 0 : -1);\n        fMerkleVerified = true;\n    }\n\n    pindexRet = pindex;\n    return(pindexBest->nHeight - pindex->nHeight + 1);\n}\n\n\nint CMerkleTx::GetBlocksToMaturity() const\n{\n    if (!IsCoinBase())\n        return 0;\n    return max(0, (nBaseMaturity + BASE_MATURITY_OFFSET) - GetDepthInMainChain());\n}\n\n\nbool CMerkleTx::AcceptToMemoryPool(CTxDB &txdb, bool fCheckInputs, bool fLimitFree) {\n\n    return(CTransaction::AcceptToMemoryPool(txdb, fCheckInputs, fLimitFree));\n}\n\nbool CMerkleTx::AcceptToMemoryPool()\n{\n    CTxDB txdb(\"r\");\n    return AcceptToMemoryPool(txdb);\n}\n\n\n\nbool CWalletTx::AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs)\n{\n\n    {\n        LOCK(mempool.cs);\n        // Add previous supporting transactions first\n        BOOST_FOREACH(CMerkleTx& tx, vtxPrev)\n        {\n            if (!tx.IsCoinBase())\n            {\n                uint256 hash = tx.GetHash();\n                if (!mempool.exists(hash) && !txdb.ContainsTx(hash))\n                    tx.AcceptToMemoryPool(txdb, fCheckInputs, false);\n            }\n        }\n        return(AcceptToMemoryPool(txdb, fCheckInputs, false));\n    }\n    return false;\n}\n\nbool CWalletTx::AcceptWalletTransaction()\n{\n    CTxDB txdb(\"r\");\n    return AcceptWalletTransaction(txdb);\n}\n\n\n// Return transaction in tx, and if it was found inside a block, its hash is placed in hashBlock\nbool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock)\n{\n    {\n        LOCK(cs_main);\n        {\n            LOCK(mempool.cs);\n            if (mempool.exists(hash))\n            {\n                tx = mempool.lookup(hash);\n                return true;\n            }\n        }\n        CTxDB txdb(\"r\");\n        CTxIndex txindex;\n        if (tx.ReadFromDisk(txdb, COutPoint(hash, 0), txindex))\n        {\n            CBlock block;\n            if (block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n                hashBlock = block.GetHash();\n            return true;\n        }\n    }\n    return false;\n}\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CBlock and CBlockIndex\n//\n\nbool CBlock::ReadFromDisk(const CBlockIndex* pindex, bool fReadTransactions)\n{\n    if (!fReadTransactions)\n    {\n        *this = pindex->GetBlockHeader();\n        return true;\n    }\n    if (!ReadFromDisk(pindex->nFile, pindex->nBlockPos, fReadTransactions))\n        return false;\n    if (GetHash() != pindex->GetBlockHash())\n        return error(\"CBlock::ReadFromDisk() : GetHash() doesn't match index\");\n    return true;\n}\n\nuint256 static GetOrphanRoot(const CBlock* pblock)\n{\n    // Work back to the first block in the orphan chain\n    while (mapOrphanBlocks.count(pblock->hashPrevBlock))\n        pblock = mapOrphanBlocks[pblock->hashPrevBlock];\n    return pblock->GetHash();\n}\n\nint64 GetBlockValue(int nHeight, int64 nFees) {\n\n    int64 nSubsidy = 50 * COIN;\n    // 25 PXC per block between the 3rd and 4th hard fork\n    // 25 PXC per block before the 1st testnet hard fork\n    if(((nHeight >= nForkThree) && (nHeight < nForkFour)) || (fTestNet && (nHeight < nTestnetForkOne)))\n      nSubsidy = 25 * COIN;\n\n    // Block reward halves every 1M blocks (~2.85 years)\n    nSubsidy >>= (nHeight / 1000000);\n\n    return nSubsidy + nFees;\n}\n\nunsigned int static GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlock *pblock)\n{\n    unsigned int nProofOfWorkLimit = bnProofOfWorkLimit.GetCompact();\n\n    // The genesis block\n    if(pindexLast == NULL) return nProofOfWorkLimit;\n\n    // The next block\n    int nHeight = pindexLast->nHeight + 1;\n\n    // The initial settings\n    int nTargetSpacing  = nTargetSpacingZero;\n    int nTargetTimespan = nTargetTimespanZero;\n\n    // The 1st hard fork\n    if(nHeight >= nForkOne) {\n        nTargetSpacing  = nTargetSpacingOne;\n        nTargetTimespan = nTargetTimespanOne;\n    }\n\n    // The 2nd hard fork\n    if(nHeight >= nForkTwo) {\n        nTargetSpacing  = nTargetSpacingTwo;\n        nTargetTimespan = nTargetTimespanTwo;\n    }\n\n    // The 3nd hard fork; testnet starts here\n    if(nHeight >= nForkThree || fTestNet) {\n        nTargetSpacing  = nTargetSpacingThree;\n        nTargetTimespan = nTargetTimespanThree;\n    }\n\n    // The 4th hard fork; testnet hard forks as well\n    if((nHeight >= nForkFour) || (fTestNet && (nHeight >= nTestnetForkOne))) {\n        nTargetSpacing  = nTargetSpacingFour;\n        nTargetTimespan = nTargetTimespanFour;\n    }\n\n    /* The 5th hard fork and 2nd testnet hard fork */\n    if((nHeight >= nForkFive) || (fTestNet && (nHeight >= nTestnetForkTwo))) {\n        if(!fNeoScrypt) fNeoScrypt = true;\n        /* Difficulty reset after the switch */\n        if(nHeight == nForkFive)\n          return(bnNeoScryptSwitch.GetCompact());\n    }\n\n    // 2400, 600, 108, 126 and 20 blocks respectively\n    int nInterval = nTargetTimespan / nTargetSpacing;\n\n    // Just in case a hard fork isn't aligned properly\n    bool fHardFork = (nHeight == nForkOne) || (nHeight == nForkTwo) || (nHeight == nForkThree) || (nHeight == nForkFour) || (nHeight == nForkFive);\n    if(fTestNet) {\n        if((nHeight == nTestnetForkOne) || (nHeight == nTestnetForkTwo)) fHardFork = true;\n        else fHardFork = false;\n    }\n\n    // Difficulty rules for regular blocks\n    if((nHeight % nInterval != 0) && !(fHardFork)) {\n\n        // Testnet has a special difficulty rule\n        if(fTestNet) {\n            // Reset the difficulty if the difference in time stamps between\n            // this and the previous block is over 2x of nTargetSpacing\n            if(pblock->nTime > pindexLast->nTime + nTargetSpacing*2)\n              return nProofOfWorkLimit;\n            else {\n                // Return the difficulty of the last regular block\n                // with no minimal difficulty set as above\n                const CBlockIndex* pindex = pindexLast;\n                while(pindex->pprev && (pindex->nHeight % nInterval != 0) && (pindex->nBits == nProofOfWorkLimit))\n                  pindex = pindex->pprev;\n                return pindex->nBits;\n            }\n        }\n\n        return pindexLast->nBits;\n    }\n\n    // Basic 100 blocks averaging after the 4th livenet or 1st testnet hard fork\n    if((nHeight >= nForkFour) || (fTestNet && (nHeight >= nTestnetForkOne))) {\n        nInterval *= 5;\n        nTargetTimespan *= 5;\n    }\n\n    // The 1st retarget after the genesis\n    if(nInterval >= nHeight) nInterval = nHeight - 1;\n\n    // Go back by nInterval\n    const CBlockIndex* pindexFirst = pindexLast;\n    for(int i = 0; pindexFirst && (i < nInterval); i++)\n      pindexFirst = pindexFirst->pprev;\n    assert(pindexFirst);\n\n    int nActualTimespan = pindexLast->GetBlockTime() - pindexFirst->GetBlockTime();\n\n    printf(\"RETARGET: nActualTimespan = %d before bounds\\n\", nActualTimespan);\n\n    // Extended 500 blocks averaging after the 4th livenet or 1st testnet hard fork\n    if((nHeight >= nForkFour) || (fTestNet && (nHeight >= nTestnetForkOne))) {\n        nInterval *= 4;\n\n        for(int i = 0; pindexFirst && (i < nInterval); i++)\n          pindexFirst = pindexFirst->pprev;\n\n        int nActualTimespanExtended =\n          (pindexLast->GetBlockTime() - pindexFirst->GetBlockTime())/5;\n\n        // Average between the basic and extended windows\n        int nActualTimespanAvg = (nActualTimespan + nActualTimespanExtended)/2;\n\n        // Apply 0.1 damping\n        nActualTimespan = nActualTimespanAvg + 9*nTargetTimespan;\n        nActualTimespan /= 10;\n\n        printf(\"RETARGET: nActualTimespanExtended = %d (%d), nActualTimeSpanAvg = %d, nActualTimespan (damped) = %d\\n\",\n          nActualTimespanExtended, nActualTimespanExtended*5, nActualTimespanAvg, nActualTimespan);\n    }\n\n    // The initial settings (4.0 difficulty limiter)\n    int nActualTimespanMax = nTargetTimespan*4;\n    int nActualTimespanMin = nTargetTimespan/4;\n\n    // The 1st hard fork (1.8 difficulty limiter)\n    if(nHeight >= nForkOne) {\n        nActualTimespanMax = nTargetTimespan*99/55;\n        nActualTimespanMin = nTargetTimespan*55/99;\n    }\n\n    // The 3rd hard fork (1.09 difficulty limiter)\n    if(nHeight >= nForkThree) {\n        nActualTimespanMax = nTargetTimespan*109/100;\n        nActualTimespanMin = nTargetTimespan*100/109;\n    }\n\n    // The 4th livenet or 1st testnet hard fork (1.02 difficulty limiter)\n    if((nHeight >= nForkFour) || (fTestNet && (nHeight >= nTestnetForkOne))) {\n        nActualTimespanMax = nTargetTimespan*102/100;\n        nActualTimespanMin = nTargetTimespan*100/102;\n    }\n\n    /* The 5th livenet or 2nd testnet hard fork (+2% to -5% difficulty limiter) */\n    if((nHeight >= nForkFive) || (fTestNet && (nHeight >= nTestnetForkTwo))) {\n        nActualTimespanMax = nTargetTimespan * 105 / 100;\n    }\n\n    if(nActualTimespan < nActualTimespanMin) nActualTimespan = nActualTimespanMin;\n    if(nActualTimespan > nActualTimespanMax) nActualTimespan = nActualTimespanMax;\n\n    printf(\"RETARGET: nActualTimespan = %d after bounds\\n\", nActualTimespan);\n    printf(\"RETARGET: nTargetTimespan = %d, nTargetTimespan/nActualTimespan = %.4f\\n\",\n      nTargetTimespan, (float) nTargetTimespan/nActualTimespan);\n\n    // Retarget\n    CBigNum bnNew;\n    bnNew.SetCompact(pindexLast->nBits);\n    bnNew *= nActualTimespan;\n    bnNew /= nTargetTimespan;\n\n    if(bnNew > bnProofOfWorkLimit) bnNew = bnProofOfWorkLimit;\n\n    printf(\"GetNextWorkRequired RETARGET\\n\");\n    printf(\"Before: %08x  %s\\n\", pindexLast->nBits, CBigNum().SetCompact(pindexLast->nBits).getuint256().ToString().c_str());\n    printf(\"After:  %08x  %s\\n\", bnNew.GetCompact(), bnNew.getuint256().ToString().c_str());\n\n    return bnNew.GetCompact();\n}\n\nbool CheckProofOfWork(uint256 hash, unsigned int nBits)\n{\n    CBigNum bnTarget;\n    bnTarget.SetCompact(nBits);\n\n    // Check range\n    if (bnTarget <= 0 || bnTarget > bnProofOfWorkLimit)\n        return error(\"CheckProofOfWork() : nBits below minimum work\");\n\n    // Check proof of work matches claimed amount\n    if (hash > bnTarget.getuint256())\n        return error(\"CheckProofOfWork() : hash doesn't match nBits\");\n\n    return true;\n}\n\n// Return maximum amount of blocks that other nodes claim to have\nint GetNumBlocksOfPeers()\n{\n    return std::max(cPeerBlockCounts.median(), Checkpoints::GetTotalBlocksEstimate());\n}\n\nbool IsInitialBlockDownload()\n{\n    if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n        return true;\n    static int64 nLastUpdate;\n    static CBlockIndex* pindexLastBest;\n    if (pindexBest != pindexLastBest)\n    {\n        pindexLastBest = pindexBest;\n        nLastUpdate = GetTime();\n    }\n    return(((GetTime() - nLastUpdate) < 10) &&\n      (pindexBest->GetBlockTime() < (GetTime() - 4 * 60 * 60)));\n}\n\nvoid static InvalidChainFound(CBlockIndex* pindexNew)\n{\n    if (pindexNew->bnChainWork > bnBestInvalidWork)\n    {\n        bnBestInvalidWork = pindexNew->bnChainWork;\n        CTxDB().WriteBestInvalidWork(bnBestInvalidWork);\n        uiInterface.NotifyBlocksChanged();\n    }\n    printf(\"InvalidChainFound: invalid block=%s  height=%d  work=%s  date=%s\\n\",\n      pindexNew->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->nHeight,\n      pindexNew->bnChainWork.ToString().c_str(), DateTimeStrFormat(\"%x %H:%M:%S\",\n      pindexNew->GetBlockTime()).c_str());\n    printf(\"InvalidChainFound:  current best=%s  height=%d  work=%s  date=%s\\n\",\n      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight, bnBestChainWork.ToString().c_str(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n    if (pindexBest && bnBestInvalidWork > bnBestChainWork + pindexBest->GetBlockWork() * 6)\n        printf(\"InvalidChainFound: WARNING: Displayed transactions may not be correct!  You may need to upgrade, or other nodes may need to upgrade.\\n\");\n}\n\nvoid CBlock::UpdateTime(const CBlockIndex* pindexPrev)\n{\n    nTime = max((pindexPrev->GetMedianTimePast() + BLOCK_LIMITER_TIME + 1), GetAdjustedTime());\n\n    // Updating time can change work required on testnet:\n    if (fTestNet)\n        nBits = GetNextWorkRequired(pindexPrev, this);\n}\n\n\n\n\n\n\n\n\n\n\n\nbool CTransaction::DisconnectInputs(CTxDB& txdb)\n{\n    // Relinquish previous transactions' spent pointers\n    if (!IsCoinBase())\n    {\n        BOOST_FOREACH(const CTxIn& txin, vin)\n        {\n            COutPoint prevout = txin.prevout;\n\n            // Get prev txindex from disk\n            CTxIndex txindex;\n            if (!txdb.ReadTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : ReadTxIndex failed\");\n\n            if (prevout.n >= txindex.vSpent.size())\n                return error(\"DisconnectInputs() : prevout.n out of range\");\n\n            // Mark outpoint as not spent\n            txindex.vSpent[prevout.n].SetNull();\n\n            // Write back\n            if (!txdb.UpdateTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : UpdateTxIndex failed\");\n        }\n    }\n\n    // Remove transaction from index\n    // This can fail if a duplicate of this transaction was in a chain that got\n    // reorganized away. This is only possible if this transaction was completely\n    // spent, so erasing it would be a no-op anway.\n    txdb.EraseTxIndex(*this);\n\n    return true;\n}\n\n\nbool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTestPool,\n                               bool fBlock, bool fMiner, MapPrevTx& inputsRet, bool& fInvalid)\n{\n    // FetchInputs can return false either because we just haven't seen some inputs\n    // (in which case the transaction should be stored as an orphan)\n    // or because the transaction is malformed (in which case the transaction should\n    // be dropped).  If tx is definitely invalid, fInvalid will be set to true.\n    fInvalid = false;\n\n    if (IsCoinBase())\n        return true; // Coinbase transactions have no inputs to fetch.\n\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        COutPoint prevout = vin[i].prevout;\n        if (inputsRet.count(prevout.hash))\n            continue; // Got it already\n\n        // Read txindex\n        CTxIndex& txindex = inputsRet[prevout.hash].first;\n        bool fFound = true;\n        if ((fBlock || fMiner) && mapTestPool.count(prevout.hash))\n        {\n            // Get txindex from current proposed changes\n            txindex = mapTestPool.find(prevout.hash)->second;\n        }\n        else\n        {\n            // Read txindex from txdb\n            fFound = txdb.ReadTxIndex(prevout.hash, txindex);\n        }\n        if (!fFound && (fBlock || fMiner))\n            return fMiner ? false : error(\"FetchInputs() : %s prev Tx %s index entry not found\", \\\n              GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n\n        // Read txPrev\n        CTransaction& txPrev = inputsRet[prevout.hash].second;\n        if (!fFound || txindex.pos == CDiskTxPos(1,1,1))\n        {\n            // Get prev tx from single transactions in memory\n            {\n                LOCK(mempool.cs);\n                if (!mempool.exists(prevout.hash))\n                    return error(\"FetchInputs() : %s mempool Tx prev not found %s\", \\\n                      GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n                txPrev = mempool.lookup(prevout.hash);\n            }\n            if (!fFound)\n                txindex.vSpent.resize(txPrev.vout.size());\n        }\n        else\n        {\n            // Get prev tx from disk\n            if (!txPrev.ReadFromDisk(txindex.pos))\n                return error(\"FetchInputs() : %s ReadFromDisk prev Tx %s failed\", \\\n                  GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n        }\n\n        // Verify\n        if((prevout.n >= txPrev.vout.size()) || (prevout.n >= txindex.vSpent.size())) {\n            fInvalid = true;\n            return error(\"FetchInputs() : %s prevout.n %d exceeds %d or %d prev Tx %s\\n%s\", \\\n              GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), \\\n              prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str());\n        }\n\n        // Double spend check\n        if(!txindex.vSpent[prevout.n].IsNull())\n          return fMiner ? false : error(\"FetchInputs() : %s prev Tx already used at %s\", \\\n            GetHash().ToString().substr(0,10).c_str(), txindex.vSpent[prevout.n].ToString().c_str());\n    }\n\n    return true;\n}\n\nconst CTxOut& CTransaction::GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const\n{\n    MapPrevTx::const_iterator mi = inputs.find(input.prevout.hash);\n    if (mi == inputs.end())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.hash not found\");\n\n    const CTransaction& txPrev = (mi->second).second;\n    if (input.prevout.n >= txPrev.vout.size())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.n out of range\");\n\n    return txPrev.vout[input.prevout.n];\n}\n\nint64 CTransaction::GetValueIn(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    int64 nResult = 0;\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        nResult += GetOutputFor(vin[i], inputs).nValue;\n    }\n    return nResult;\n\n}\n\nunsigned int CTransaction::GetP2SHSigOpCount(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    unsigned int nSigOps = 0;\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        const CTxOut& prevout = GetOutputFor(vin[i], inputs);\n        if (prevout.scriptPubKey.IsPayToScriptHash())\n            nSigOps += prevout.scriptPubKey.GetSigOpCount(vin[i].scriptSig);\n    }\n    return nSigOps;\n}\n\nbool CTransaction::ConnectInputs(MapPrevTx inputs,\n                                 map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n                                 const CBlockIndex* pindexBlock, bool fBlock, bool fMiner, bool fStrictPayToScriptHash)\n{\n    // Take over previous transactions' spent pointers\n    // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain\n    // fMiner is true when called from the internal Phoenixcoin miner\n    // ... both are false when called from CTransaction::AcceptToMemoryPool\n    if (!IsCoinBase())\n    {\n        int64 nValueIn = 0;\n        int64 nFees = 0;\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            // prevout.n verification moved to FetchInputs()\n\n            // If prev is coinbase, check that it's matured\n            if (txPrev.IsCoinBase())\n                for (const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < nBaseMaturity; pindex = pindex->pprev)\n                    if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)\n                        return error(\"ConnectInputs() : tried to spend coinbase at depth %d\", pindexBlock->nHeight - pindex->nHeight);\n\n            // Check for negative or overflow input values\n            nValueIn += txPrev.vout[prevout.n].nValue;\n            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n\n        }\n        // The first loop above does all the inexpensive checks.\n        // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n        // Helps prevent CPU exhaustion attacks.\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            // Double spend check moved to FetchInputs()\n\n            // Skip ECDSA signature verification when connecting blocks (fBlock=true)\n            // before the last blockchain checkpoint. This is safe because block merkle hashes are\n            // still computed and checked, and any change will be caught at the next checkpoint.\n            if (!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate())))\n            {\n                // Verify signature\n                if (!VerifySignature(txPrev, *this, i, fStrictPayToScriptHash, 0))\n                {\n                    // only during transition phase for P2SH: do not invoke anti-DoS code for\n                    // potentially old clients relaying bad P2SH transactions\n                    if (fStrictPayToScriptHash && VerifySignature(txPrev, *this, i, false, 0))\n                        return error(\"ConnectInputs() : %s P2SH VerifySignature failed\", GetHash().ToString().substr(0,10).c_str());\n\n                    return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n                }\n            }\n\n            // Mark outpoints as spent\n            txindex.vSpent[prevout.n] = posThisTx;\n\n            // Write back\n            if (fBlock || fMiner)\n            {\n                mapTestPool[prevout.hash] = txindex;\n            }\n        }\n\n        if (nValueIn < GetValueOut())\n            return DoS(100, error(\"ConnectInputs() : %s value in < value out\", GetHash().ToString().substr(0,10).c_str()));\n\n        // Tally transaction fees\n        int64 nTxFee = nValueIn - GetValueOut();\n        if (nTxFee < 0)\n            return DoS(100, error(\"ConnectInputs() : %s nTxFee < 0\", GetHash().ToString().substr(0,10).c_str()));\n        nFees += nTxFee;\n        if (!MoneyRange(nFees))\n            return DoS(100, error(\"ConnectInputs() : nFees out of range\"));\n    }\n\n    return true;\n}\n\n\nbool CTransaction::ClientConnectInputs()\n{\n    if (IsCoinBase())\n        return false;\n\n    // Take over previous transactions' spent pointers\n    {\n        LOCK(mempool.cs);\n        int64 nValueIn = 0;\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            // Get prev tx from single transactions in memory\n            COutPoint prevout = vin[i].prevout;\n            if (!mempool.exists(prevout.hash))\n                return false;\n            CTransaction& txPrev = mempool.lookup(prevout.hash);\n\n            if (prevout.n >= txPrev.vout.size())\n                return false;\n\n            // Verify signature\n            if (!VerifySignature(txPrev, *this, i, true, 0))\n                return error(\"ConnectInputs() : VerifySignature failed\");\n\n            nValueIn += txPrev.vout[prevout.n].nValue;\n\n            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                return error(\"ClientConnectInputs() : txin values out of range\");\n        }\n        if (GetValueOut() > nValueIn)\n            return false;\n    }\n\n    return true;\n}\n\n\n\n\nbool CBlock::DisconnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n{\n    // Disconnect in reverse order\n    for (int i = vtx.size()-1; i >= 0; i--)\n        if (!vtx[i].DisconnectInputs(txdb))\n            return false;\n\n    // Update block index on disk without changing it in memory.\n    // The memory index structure will be changed after the db commits.\n    if (pindex->pprev)\n    {\n        CDiskBlockIndex blockindexPrev(pindex->pprev);\n        blockindexPrev.hashNext = 0;\n        if (!txdb.WriteBlockIndex(blockindexPrev))\n            return error(\"DisconnectBlock() : WriteBlockIndex failed\");\n    }\n\n    return true;\n}\n\nbool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n{\n    // Check it again in case a previous version let a bad block in\n    if (!CheckBlock())\n        return false;\n\n    // Do not allow blocks that contain transactions which 'overwrite' older transactions,\n    // unless those are already completely spent.\n    // If such overwrites are allowed, coinbases and transactions depending upon those\n    // can be duplicated to remove the ability to spend the first instance -- even after\n    // being sent to another address.\n    // See BIP30 and http://r6.ca/blog/20120206T005236Z.html for more information.\n    // This logic is not necessary for memory pool transactions, as AcceptToMemoryPool\n    // already refuses previously-known transaction id's entirely.\n    // This rule applies to all blocks whose timestamp is after October 1, 2012, 0:00 UTC.\n//    int64 nBIP30SwitchTime = 1349049600;\n//    bool fEnforceBIP30 = (pindex->nTime > nBIP30SwitchTime);\n    /* always active for Phoenixcoin */\n    bool fEnforceBIP30 = true;\n\n    // BIP16 didn't become active until October 1 2012\n//    int64 nBIP16SwitchTime = 1349049600;\n//    bool fStrictPayToScriptHash = (pindex->nTime >= nBIP16SwitchTime);\n    /* always active for Phoenixcoin */\n    bool fStrictPayToScriptHash = true;\n\n    //// issue here: it doesn't know the version\n    unsigned int nTxPos = pindex->nBlockPos + ::GetSerializeSize(CBlock(), SER_DISK, CLIENT_VERSION) - 1 + GetSizeOfCompactSize(vtx.size());\n\n    map<uint256, CTxIndex> mapQueuedChanges;\n    int64 nFees = 0;\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(CTransaction& tx, vtx)\n    {\n        uint256 hashTx = tx.GetHash();\n\n        if (fEnforceBIP30) {\n            CTxIndex txindexOld;\n            if (txdb.ReadTxIndex(hashTx, txindexOld)) {\n                BOOST_FOREACH(CDiskTxPos &pos, txindexOld.vSpent)\n                    if (pos.IsNull())\n                        return false;\n            }\n        }\n\n        nSigOps += tx.GetLegacySigOpCount();\n        if (nSigOps > MAX_BLOCK_SIGOPS)\n            return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n\n        CDiskTxPos posThisTx(pindex->nFile, pindex->nBlockPos, nTxPos);\n        nTxPos += ::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION);\n\n        MapPrevTx mapInputs;\n        if (!tx.IsCoinBase())\n        {\n            bool fInvalid;\n            if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs, fInvalid))\n                return false;\n\n            if (fStrictPayToScriptHash)\n            {\n                // Add in sigops done by pay-to-script-hash inputs;\n                // this is to prevent a \"rogue miner\" from creating\n                // an incredibly-expensive-to-validate block.\n                nSigOps += tx.GetP2SHSigOpCount(mapInputs);\n                if (nSigOps > MAX_BLOCK_SIGOPS)\n                    return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n            }\n\n            nFees += tx.GetValueIn(mapInputs)-tx.GetValueOut();\n\n            if (!tx.ConnectInputs(mapInputs, mapQueuedChanges, posThisTx, pindex, true, false, fStrictPayToScriptHash))\n                return false;\n        }\n\n        mapQueuedChanges[hashTx] = CTxIndex(posThisTx, tx.vout.size());\n    }\n\n    // Write queued txindex changes\n    for (map<uint256, CTxIndex>::iterator mi = mapQueuedChanges.begin(); mi != mapQueuedChanges.end(); ++mi)\n    {\n        if (!txdb.UpdateTxIndex((*mi).first, (*mi).second))\n            return error(\"ConnectBlock() : UpdateTxIndex failed\");\n    }\n\n    if (vtx[0].GetValueOut() > GetBlockValue(pindex->nHeight, nFees))\n        return false;\n\n    // No more blocks with bogus reward accepted\n    if((fTestNet || (pindex->nHeight >= nForkFour)) &&\n      (vtx[0].GetValueOut() != GetBlockValue(pindex->nHeight, nFees)))\n        return false;\n\n    // Update block index on disk without changing it in memory.\n    // The memory index structure will be changed after the db commits.\n    if (pindex->pprev)\n    {\n        CDiskBlockIndex blockindexPrev(pindex->pprev);\n        blockindexPrev.hashNext = pindex->GetBlockHash();\n        if (!txdb.WriteBlockIndex(blockindexPrev))\n            return error(\"ConnectBlock() : WriteBlockIndex failed\");\n    }\n\n    // Watch for transactions paying to me\n    BOOST_FOREACH(CTransaction& tx, vtx)\n        SyncWithWallets(tx, this, true);\n\n    return true;\n}\n\nbool static Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)\n{\n    printf(\"REORGANIZE\\n\");\n\n    // Find the fork\n    CBlockIndex* pfork = pindexBest;\n    CBlockIndex* plonger = pindexNew;\n    while (pfork != plonger)\n    {\n        while (plonger->nHeight > pfork->nHeight)\n            if (!(plonger = plonger->pprev))\n                return error(\"Reorganize() : plonger->pprev is null\");\n        if (pfork == plonger)\n            break;\n        if (!(pfork = pfork->pprev))\n            return error(\"Reorganize() : pfork->pprev is null\");\n    }\n\n    // List of what to disconnect\n    vector<CBlockIndex*> vDisconnect;\n    for (CBlockIndex* pindex = pindexBest; pindex != pfork; pindex = pindex->pprev)\n        vDisconnect.push_back(pindex);\n\n    // List of what to connect\n    vector<CBlockIndex*> vConnect;\n    for (CBlockIndex* pindex = pindexNew; pindex != pfork; pindex = pindex->pprev)\n        vConnect.push_back(pindex);\n    reverse(vConnect.begin(), vConnect.end());\n\n    printf(\"REORGANIZE: Disconnect %i blocks; %s..%s\\n\", vDisconnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexBest->GetBlockHash().ToString().substr(0,20).c_str());\n    printf(\"REORGANIZE: Connect %i blocks; %s..%s\\n\", vConnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->GetBlockHash().ToString().substr(0,20).c_str());\n\n    // Disconnect shorter branch\n    vector<CTransaction> vResurrect;\n    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n    {\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"Reorganize() : ReadFromDisk for disconnect failed\");\n        if (!block.DisconnectBlock(txdb, pindex))\n            return error(\"Reorganize() : DisconnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n\n        // Queue memory transactions to resurrect\n        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n            if (!tx.IsCoinBase())\n                vResurrect.push_back(tx);\n    }\n\n    // Connect longer branch\n    vector<CTransaction> vDelete;\n    for (unsigned int i = 0; i < vConnect.size(); i++)\n    {\n        CBlockIndex* pindex = vConnect[i];\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"Reorganize() : ReadFromDisk for connect failed\");\n        if (!block.ConnectBlock(txdb, pindex))\n        {\n            // Invalid block\n            return error(\"Reorganize() : ConnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n        }\n\n        // Queue memory transactions to delete\n        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n            vDelete.push_back(tx);\n    }\n    if (!txdb.WriteHashBestChain(pindexNew->GetBlockHash()))\n        return error(\"Reorganize() : WriteHashBestChain failed\");\n\n    // Make sure it's successfully written to disk before changing memory structure\n    if (!txdb.TxnCommit())\n        return error(\"Reorganize() : TxnCommit failed\");\n\n    // Disconnect shorter branch\n    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = NULL;\n\n    // Connect longer branch\n    BOOST_FOREACH(CBlockIndex* pindex, vConnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = pindex;\n\n    // Resurrect memory transactions that were in the disconnected branch\n    BOOST_FOREACH(CTransaction& tx, vResurrect)\n      tx.AcceptToMemoryPool(txdb, true, false);\n\n    // Delete redundant memory transactions that are in the connected branch\n    BOOST_FOREACH(CTransaction &tx, vDelete) {\n        mempool.remove(tx);\n        mempool.removeConflicts(tx);\n    }\n\n    printf(\"REORGANIZE: done\\n\");\n\n    return true;\n}\n\n\n// Called from inside SetBestChain: attaches a block to the new best chain being built\nbool CBlock::SetBestChainInner(CTxDB& txdb, CBlockIndex *pindexNew)\n{\n    uint256 hash = GetHash();\n\n    // Adding to current best branch\n    if (!ConnectBlock(txdb, pindexNew) || !txdb.WriteHashBestChain(hash))\n    {\n        txdb.TxnAbort();\n        InvalidChainFound(pindexNew);\n        return false;\n    }\n    if (!txdb.TxnCommit())\n        return error(\"SetBestChain() : TxnCommit failed\");\n\n    // Add to current best branch\n    pindexNew->pprev->pnext = pindexNew;\n\n    // Delete redundant memory transactions\n    BOOST_FOREACH(CTransaction& tx, vtx)\n        mempool.remove(tx);\n\n    return true;\n}\n\nbool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n{\n    uint256 hash = GetHash();\n\n    if (!txdb.TxnBegin())\n        return error(\"SetBestChain() : TxnBegin failed\");\n\n    if (pindexGenesisBlock == NULL && hash == hashGenesisBlock)\n    {\n        txdb.WriteHashBestChain(hash);\n        if (!txdb.TxnCommit())\n            return error(\"SetBestChain() : TxnCommit failed\");\n        pindexGenesisBlock = pindexNew;\n    }\n    else if (hashPrevBlock == hashBestChain)\n    {\n        if (!SetBestChainInner(txdb, pindexNew))\n            return error(\"SetBestChain() : SetBestChainInner failed\");\n    }\n    else\n    {\n        // the first block in the new chain that will cause it to become the new best chain\n        CBlockIndex *pindexIntermediate = pindexNew;\n\n        // list of blocks that need to be connected afterwards\n        std::vector<CBlockIndex*> vpindexSecondary;\n\n        // Reorganize is costly in terms of db load, as it works in a single db transaction.\n        // Try to limit how much needs to be done inside\n        while (pindexIntermediate->pprev && pindexIntermediate->pprev->bnChainWork > pindexBest->bnChainWork)\n        {\n            vpindexSecondary.push_back(pindexIntermediate);\n            pindexIntermediate = pindexIntermediate->pprev;\n        }\n\n        if (!vpindexSecondary.empty())\n            printf(\"Postponing %i reconnects\\n\", vpindexSecondary.size());\n\n        // Switch to new best branch\n        if (!Reorganize(txdb, pindexIntermediate))\n        {\n            txdb.TxnAbort();\n            InvalidChainFound(pindexNew);\n            return error(\"SetBestChain() : Reorganize failed\");\n        }\n\n        // Connect futher blocks\n        BOOST_REVERSE_FOREACH(CBlockIndex *pindex, vpindexSecondary)\n        {\n            CBlock block;\n            if (!block.ReadFromDisk(pindex))\n            {\n                printf(\"SetBestChain() : ReadFromDisk failed\\n\");\n                break;\n            }\n            if (!txdb.TxnBegin()) {\n                printf(\"SetBestChain() : TxnBegin 2 failed\\n\");\n                break;\n            }\n            // errors now are not fatal, we still did a reorganisation to a new chain in a valid way\n            if (!block.SetBestChainInner(txdb, pindex))\n                break;\n        }\n    }\n\n    // Update best block in wallet (so we can detect restored wallets)\n    bool fIsInitialDownload = IsInitialBlockDownload();\n    if (!fIsInitialDownload)\n    {\n        const CBlockLocator locator(pindexNew);\n        ::SetBestChain(locator);\n    }\n\n    // New best block\n    hashBestChain = hash;\n    pindexBest = pindexNew;\n    nBestHeight = pindexBest->nHeight;\n    bnBestChainWork = pindexNew->bnChainWork;\n    nTimeBestReceived = GetTime();\n    nTransactionsUpdated++;\n    printf(\"SetBestChain: new best=%s  height=%d  work=%s  date=%s\\n\",\n      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight, bnBestChainWork.ToString().c_str(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n\n    // Advanced checkpointing mode control\n    if (!IsSyncCheckpointEnforced())\n    {\n        if (pindexBest->pprev && !CheckSyncCheckpoint(pindexBest->GetBlockHash(), pindexBest->pprev))\n            strCheckpointWarning = _(\"Warning: advanced checkpoint on a block chain fork, report to the developers\");\n        else\n            strCheckpointWarning = \"\";\n    }\n\n    std::string strCmd = GetArg(\"-blocknotify\", \"\");\n\n    if (!fIsInitialDownload && !strCmd.empty())\n    {\n        boost::replace_all(strCmd, \"%s\", hashBestChain.GetHex());\n        boost::thread t(runCommand, strCmd); // thread runs free\n    }\n\n    return true;\n}\n\n\nbool CBlock::AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos)\n{\n    // Check for duplicate\n    uint256 hash = GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"AddToBlockIndex() : %s already exists\", hash.ToString().substr(0,20).c_str());\n\n    // Construct new block index object\n    CBlockIndex* pindexNew = new CBlockIndex(nFile, nBlockPos, *this);\n    if (!pindexNew)\n        return error(\"AddToBlockIndex() : new CBlockIndex failed\");\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n    pindexNew->phashBlock = &((*mi).first);\n    map<uint256, CBlockIndex*>::iterator miPrev = mapBlockIndex.find(hashPrevBlock);\n    if (miPrev != mapBlockIndex.end())\n    {\n        pindexNew->pprev = (*miPrev).second;\n        pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n    }\n    pindexNew->bnChainWork = (pindexNew->pprev ? pindexNew->pprev->bnChainWork : 0) + pindexNew->GetBlockWork();\n\n    CTxDB txdb;\n    if (!txdb.TxnBegin())\n        return false;\n    txdb.WriteBlockIndex(CDiskBlockIndex(pindexNew));\n    if (!txdb.TxnCommit())\n        return false;\n\n    // New best\n    if (pindexNew->bnChainWork > bnBestChainWork)\n        if (!SetBestChain(txdb, pindexNew))\n            return false;\n\n    txdb.Close();\n\n    if (pindexNew == pindexBest)\n    {\n        // Notify UI to display prev block's coinbase if it was ours\n        static uint256 hashPrevBestCoinBase;\n        UpdatedTransaction(hashPrevBestCoinBase);\n        hashPrevBestCoinBase = vtx[0].GetHash();\n    }\n\n    uiInterface.NotifyBlocksChanged();\n    return true;\n}\n\n\n\n\nbool CBlock::CheckBlock() const\n{\n    // These are checks that are independent of context\n    // that can be verified before saving an orphan block.\n\n    // Size limits\n    if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\"CheckBlock() : size limits failed\"));\n\n    /* Verify proof-of-work */\n    if(!CheckProofOfWork(GetPoWHash(), nBits))\n      return(DoS(50, error(\"CheckBlock() : proof-of-work verification failed\")));\n\n    // First transaction must be coinbase, the rest must not be\n    if (vtx.empty() || !vtx[0].IsCoinBase())\n        return DoS(100, error(\"CheckBlock() : the 1st transaction isn't the coin base\"));\n    for (unsigned int i = 1; i < vtx.size(); i++)\n        if (vtx[i].IsCoinBase())\n            return DoS(100, error(\"CheckBlock() : more than one coin base\"));\n\n    // Check transactions\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n        if (!tx.CheckTransaction())\n            return DoS(tx.nDoS, error(\"CheckBlock() : CheckTransaction failed\"));\n\n    // Check for duplicate txids. This is caught by ConnectInputs(),\n    // but catching it earlier avoids a potential DoS attack:\n    set<uint256> uniqueTx;\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        uniqueTx.insert(tx.GetHash());\n    }\n    if (uniqueTx.size() != vtx.size())\n        return DoS(100, error(\"CheckBlock() : duplicate transaction\"));\n\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        nSigOps += tx.GetLegacySigOpCount();\n    }\n    if (nSigOps > MAX_BLOCK_SIGOPS)\n        return DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"));\n\n    // Check merkleroot\n    if (hashMerkleRoot != BuildMerkleTree())\n        return DoS(100, error(\"CheckBlock() : hashMerkleRoot mismatch\"));\n\n    return true;\n}\n\nbool CBlock::AcceptBlock()\n{\n    // Check for duplicate\n    uint256 hash = GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"AcceptBlock() : block already in mapBlockIndex\");\n\n    // Get the previous block index\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashPrevBlock);\n    if (mi == mapBlockIndex.end())\n        return DoS(10, error(\"AcceptBlock() : cannot locate the previous block\"));\n    CBlockIndex* pindexPrev = (*mi).second;\n    int nHeight = pindexPrev->nHeight+1;\n\n    /* Don't accept v1 blocks after this point */\n    if((fTestNet && (nTime > nTestnetSwitchV2)) || (!fTestNet && (nTime > nSwitchV2))) {\n        CScript expect = CScript() << nHeight;\n        if(!std::equal(expect.begin(), expect.end(), vtx[0].vin[0].scriptSig.begin()))\n          return(DoS(100, error(\"AcceptBlock() : incorrect block height in coin base\")));\n    }\n\n    /* Don't accept blocks with bogus nVersion numbers after this point */\n    if((nHeight >= nForkFive) || (fTestNet && (nHeight >= nTestnetForkTwo))) {\n        if(nVersion != 2)\n          return(DoS(100, error(\"AcceptBlock() : incorrect block version\")));\n    }\n\n    // Check for proof of work\n    if (nBits != GetNextWorkRequired(pindexPrev, this))\n        return DoS(100, error(\"AcceptBlock() : incorrect proof of work for block %d\", nHeight));\n\n    uint nOurTime   = (uint)GetAdjustedTime();\n\n    // Check for time stamp (past limit #1)\n    if(nTime <= (uint)pindexPrev->GetMedianTimePast())\n      return(DoS(20, error(\"AcceptBlock() : block %s height %d has a time stamp behind the median\",\n        hash.ToString().substr(0,20).c_str(), nHeight)));\n\n    // Soft fork 1: further restrictions\n    if((fTestNet && (nHeight >= nTestnetSoftForkOne)) || (nHeight >= nSoftForkOne)) {\n\n        if(nTime > (nOurTime + 10 * 60))\n          return(DoS(5, error(\"AcceptBlock() : block %s height %d has a time stamp too far in the future\",\n            hash.ToString().substr(0,20).c_str(), nHeight)));\n\n        if(nTime <= (pindexPrev->GetMedianTimePast() + BLOCK_LIMITER_TIME))\n          return(DoS(5, error(\"AcceptBlock() : block %s height %d rejected by the block limiter\",\n            hash.ToString().substr(0,20).c_str(), nHeight)));\n\n        if(nTime <= (pindexPrev->GetBlockTime() - 10 * 60))\n          return(DoS(20, error(\"AcceptBlock() : block %s height %d has a time stamp too far in the past\",\n            hash.ToString().substr(0,20).c_str(), nHeight)));\n\n    }\n\n    /* Soft fork 2 */\n    if(!IsInitialBlockDownload() &&\n      ((fTestNet && (nHeight >= nTestnetSoftForkTwo)) || (nHeight >= nSoftForkTwo))) {\n\n        /* Check for time stamp (future limit) */\n        if(nTime > (nOurTime + 5 * 60))\n          return(DoS(5, error(\"AcceptBlock() [Soft Fork 2] : block %s height %d has a time stamp too far in the future\",\n            hash.ToString().substr(0,20).c_str(), nHeight)));\n\n        /* Future travel detector for the block limiter */\n        if((nTime > (nOurTime + 60)) &&\n          ((pindexPrev->GetAverageTimePast(5, 45) + BLOCK_LIMITER_TIME) > nOurTime))\n          return(DoS(5, error(\"AcceptBlock() : block %s height %d rejected by the future travel detector\",\n            hash.ToString().substr(0,20).c_str(), nHeight)));\n\n    }\n\n    // Check that all transactions are finalized\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n        if (!tx.IsFinal(nHeight, GetBlockTime()))\n            return DoS(10, error(\"AcceptBlock() : block %d contains a non-final transaction\", nHeight));\n\n    // Check if the block chain matches the known block chain up to a checkpoint\n    if (!Checkpoints::CheckBlock(nHeight, hash))\n        return DoS(100, error(\"AcceptBlock() : block %d is rejected by a regular checkpoint\", nHeight));\n\n    /* Check against advanced checkpoints */\n    if(IsSyncCheckpointEnforced() &&\n      !CheckSyncCheckpoint(hash, pindexPrev) &&\n      !IsInitialBlockDownload())\n      return(error(\"AcceptBlock() : block %s height %d rejected by the ACP\",\n        hash.ToString().substr(0,20).c_str(), nHeight));\n\n    // Write block to history file\n    if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION)))\n        return error(\"AcceptBlock() : out of disk space\");\n    unsigned int nFile = -1;\n    unsigned int nBlockPos = 0;\n    if (!WriteToDisk(nFile, nBlockPos))\n        return error(\"AcceptBlock() : WriteToDisk failed\");\n    if (!AddToBlockIndex(nFile, nBlockPos))\n        return error(\"AcceptBlock() : AddToBlockIndex failed\");\n\n    // Relay inventory, but don't relay old inventory during initial block download\n    int nBlockEstimate = Checkpoints::GetTotalBlocksEstimate();\n    if (hashBestChain == hash)\n    {\n        LOCK(cs_vNodes);\n        BOOST_FOREACH(CNode* pnode, vNodes)\n            if (nBestHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))\n                pnode->PushInventory(CInv(MSG_BLOCK, hash));\n    }\n\n    /* Process an advanced checkpoint pending */\n    if(!IsInitialBlockDownload()) AcceptPendingSyncCheckpoint();\n\n    return true;\n}\n\nbool ProcessBlock(CNode* pfrom, CBlock* pblock)\n{\n    // Check for duplicate\n    uint256 hash = pblock->GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n    if (mapOrphanBlocks.count(hash))\n        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n\n    /* Ask for a pending advanced checkpoint if any */\n    if(!IsInitialBlockDownload()) AskForPendingSyncCheckpoint(pfrom);\n\n    /* Basic block integrity checks */\n    if(!pblock->CheckBlock())\n      return(error(\"ProcessBlock() : CheckBlock FAILED\"));\n\n    CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(mapBlockIndex);\n    if (pcheckpoint && pblock->hashPrevBlock != hashBestChain)\n    {\n\n        if((pblock->GetBlockTime() - pcheckpoint->nTime) < 0) {\n            if(pfrom) pfrom->Misbehaving(100);\n            return error(\"ProcessBlock() : block has a time stamp of %u before the last checkpoint of %u\", pblock->GetBlockTime(), pcheckpoint->nTime);\n        }\n\n        // Here was some code to verify block difficulty upon block and checkpoint\n        // time difference which had never worked well in general and was broken\n        // across the hard forks for Phoenixcoin in particular\n\n    }\n\n    // If don't already have its previous block, shunt it off to holding area until we get it\n    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n    {\n        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n        CBlock* pblock2 = new CBlock(*pblock);\n        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n\n        // Ask this guy to fill in what we're missing\n        if (pfrom)\n            pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));\n        return true;\n    }\n\n    // Store to disk\n    if (!pblock->AcceptBlock())\n        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n\n    // Recursively process any orphan blocks that depended on this one\n    vector<uint256> vWorkQueue;\n    vWorkQueue.push_back(hash);\n    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n    {\n        uint256 hashPrev = vWorkQueue[i];\n        for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n             mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n             ++mi)\n        {\n            CBlock* pblockOrphan = (*mi).second;\n            if (pblockOrphan->AcceptBlock())\n                vWorkQueue.push_back(pblockOrphan->GetHash());\n            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n            delete pblockOrphan;\n        }\n        mapOrphanBlocksByPrev.erase(hashPrev);\n    }\n\n    printf(\"ProcessBlock: ACCEPTED\\n\");\n\n    /* Checkpoint master sends a new advanced checkpoint\n     * according to the depth specified by -checkpointdepth */\n    if(pfrom && !CSyncCheckpoint::strMasterPrivKey.empty())\n      SendSyncCheckpoint(AutoSelectSyncCheckpoint());\n\n    return true;\n}\n\n\n\n\n\n\n\n\nbool CheckDiskSpace(uint64 nAdditionalBytes)\n{\n    uint64 nFreeBytesAvailable = filesystem::space(GetDataDir()).available;\n\n    // Check for nMinDiskSpace bytes (currently 50MB)\n    if (nFreeBytesAvailable < nMinDiskSpace + nAdditionalBytes)\n    {\n        fShutdown = true;\n        string strMessage = _(\"Warning: Disk space is low\");\n        strMiscWarning = strMessage;\n        printf(\"*** %s\\n\", strMessage.c_str());\n        uiInterface.ThreadSafeMessageBox(strMessage, \"Phoenixcoin\", CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL);\n        StartShutdown();\n        return false;\n    }\n    return true;\n}\n\nFILE* OpenBlockFile(unsigned int nFile, unsigned int nBlockPos, const char* pszMode)\n{\n    if ((nFile < 1) || (nFile == (unsigned int) -1))\n        return NULL;\n    FILE* file = fopen((GetDataDir() / strprintf(\"blk%04d.dat\", nFile)).string().c_str(), pszMode);\n    if (!file)\n        return NULL;\n    if (nBlockPos != 0 && !strchr(pszMode, 'a') && !strchr(pszMode, 'w'))\n    {\n        if (fseek(file, nBlockPos, SEEK_SET) != 0)\n        {\n            fclose(file);\n            return NULL;\n        }\n    }\n    return file;\n}\n\nstatic unsigned int nCurrentBlockFile = 1;\n\nFILE* AppendBlockFile(unsigned int& nFileRet)\n{\n    nFileRet = 0;\n    loop\n    {\n        FILE* file = OpenBlockFile(nCurrentBlockFile, 0, \"ab\");\n        if (!file)\n            return NULL;\n        if (fseek(file, 0, SEEK_END) != 0)\n            return NULL;\n        // FAT32 filesize max 4GB, fseek and ftell max 2GB, so we must stay under 2GB\n        if((unsigned int)ftell(file) < (0x7F000000 - MAX_SIZE))\n        {\n            nFileRet = nCurrentBlockFile;\n            return file;\n        }\n        fclose(file);\n        nCurrentBlockFile++;\n    }\n}\n\nbool LoadBlockIndex(bool fAllowNew) {\n\n    if(fTestNet) {\n        pchMessageStart[0] = 0xFF;\n        pchMessageStart[1] = 0xC4;\n        pchMessageStart[2] = 0xBA;\n        pchMessageStart[3] = 0xDF;\n        pchMessageStartNew[0] = 0xFE;\n        pchMessageStartNew[1] = 0xD0;\n        pchMessageStartNew[2] = 0xD8;\n        pchMessageStartNew[3] = 0xD4;\n        hashGenesisBlock = uint256(\"0xecd47eee16536f7d03d64643cfc8c61b22093f8bf2c9358bf8b6f4dcb5f13192\");\n        nBaseMaturity = BASE_MATURITY_TESTNET;\n    }\n\n    //\n    // Load block index\n    //\n    CTxDB txdb(\"cr\");\n    if (!txdb.LoadBlockIndex())\n        return false;\n    txdb.Close();\n\n    //\n    // Init with genesis block\n    //\n    if(mapBlockIndex.empty()) {\n\n        if(!fAllowNew) return false;\n\n        CTransaction txNew;\n        CBlock block;\n\n        if(!fTestNet) {\n\n            // The Phoenixcoin genesis block:\n            // CBlock(hash=be2f30f9e8db8f430056, PoW=00000e9c6e417d3d8068, ver=1, hashPrevBlock=00000000000000000000, hashMerkleRoot=ff2aa75842, nTime=1317972665, nBits=1e0ffff0, nNonce=2084931085, vtx=1)\n            //  CTransaction(hash=ff2aa75842, ver=1, vin.size=1, vout.size=1, nLockTime=0)\n            //    CTxIn(COutPoint(0000000000, -1), coinbase 04ffff001d010446552e532e204973205765696768696e672057696465204f7665726861756c206f662057697265746170204c617773202d204e592054696d6573202d204d617920382032303133)\n            //    CTxOut(error)\n            //  vMerkleTree: ff2aa75842\n\n            const char* pszTimestamp = \"U.S. Is Weighing Wide Overhaul of Wiretap Laws - NY Times - May 8 2013\";\n            txNew.vin.resize(1);\n            txNew.vout.resize(1);\n            txNew.vin[0].scriptSig = CScript() << 486604799 << CBigNum(4) << vector<unsigned char>((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));\n            txNew.vout[0].nValue = 50 * COIN;\n            txNew.vout[0].scriptPubKey = CScript() << 0x00 << OP_CHECKSIG;\n            block.vtx.push_back(txNew);\n            block.hashPrevBlock = 0;\n            block.hashMerkleRoot = block.BuildMerkleTree();\n            block.nVersion = 1;\n            block.nTime    = 1317972665;\n            block.nBits    = 0x1e0ffff0;\n            block.nNonce   = 2084931085;\n\n        } else {\n\n            // The Phoenixcoin testnet genesis block:\n            // CBlock(hash=ecd47eee16536f7d03d6, PoW=000004b4022863f9ecf0, ver=1, hashPrevBlock=00000000000000000000, hashMerkleRoot=9bf4ade403, nTime=1383768000, nBits=1e0ffff0, nNonce=1029893, vtx=1)\n            //  CTransaction(hash=9bf4ade403, ver=1, vin.size=1, vout.size=1, nLockTime=0)\n            //    CTxIn(COutPoint(0000000000, -1), coinbase 04ffff001d01044a57656220466f756e6465722044656e6f756e636573204e534120456e6372797074696f6e20437261636b696e67202d2054686520477561726469616e202d2030362f4e6f762f32303133)\n            //    CTxOut(nValue=500.00000000, scriptPubKey=049023f10bccda76f971d6417d420c)\n            //  vMerkleTree: 9bf4ade403 \n\n            const char* pszTimestamp = \"Web Founder Denounces NSA Encryption Cracking - The Guardian - 06/Nov/2013\";\n            txNew.vin.resize(1);\n            txNew.vout.resize(1);\n            txNew.vin[0].scriptSig = CScript() << 486604799 << CBigNum(4) << vector<unsigned char>((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));\n            txNew.vout[0].nValue = 500 * COIN;\n            txNew.vout[0].scriptPubKey = CScript() << ParseHex(\"049023F10BCCDA76F971D6417D420C6BB5735D3286669CE03B49C5FEA07078F0E07B19518EE1C0A4F81BCF56A5497AD7D8200CE470EEA8C6E2CF65F1EE503F0D3E\") << OP_CHECKSIG;\n            block.vtx.push_back(txNew);\n            block.hashPrevBlock = 0;\n            block.hashMerkleRoot = block.BuildMerkleTree();\n            block.nVersion = 1;\n            block.nTime    = 1383768000;\n            block.nBits    = 0x1e0ffff0;\n            block.nNonce   = 1029893;\n\n        }\n\n        //// debug print\n        printf(\"%s\\n\", block.GetHash().ToString().c_str());\n        printf(\"%s\\n\", hashGenesisBlock.ToString().c_str());\n        printf(\"%s\\n\", block.hashMerkleRoot.ToString().c_str());\n\n        if(!fTestNet) assert(block.hashMerkleRoot == uint256(\"0xff2aa75842fae1bfb100b656c57229ce37b03643434da2043ddab7a11cfe69a6\"));\n        else assert(block.hashMerkleRoot == uint256(\"0x9bf4ade403d775b44e872935609367aee5bd7df698e0f4c73e5f30f46b30a537\"));\n\n        // If genesis block hash does not match, then generate new genesis hash.\n        if (false && block.GetHash() != hashGenesisBlock)\n        {\n            printf(\"Searching for genesis block...\\n\");\n            // This will figure out a valid hash and Nonce if you're\n            // creating a different genesis block:\n            uint profile = fNeoScrypt ? 0x0 : 0x3;\n            uint256 hashTarget = CBigNum().SetCompact(block.nBits).getuint256();\n            uint256 hash;\n\n            while(true) {\n                neoscrypt((uchar *) &block.nVersion, (uchar *) &hash, profile);\n                if(hash <= hashTarget) break;\n                if ((block.nNonce & 0xFFF) == 0)\n                {\n                    printf(\"nonce %08X: hash = %s (target = %s)\\n\", block.nNonce, hash.ToString().c_str(), hashTarget.ToString().c_str());\n                }\n                ++block.nNonce;\n                if (block.nNonce == 0)\n                {\n                    printf(\"NONCE WRAPPED, incrementing time\\n\");\n                    ++block.nTime;\n                }\n            }\n            printf(\"block.nTime = %u \\n\", block.nTime);\n            printf(\"block.nNonce = %u \\n\", block.nNonce);\n            printf(\"block.GetHash = %s\\n\", block.GetHash().ToString().c_str());\n        }\n\n        block.print();\n        assert(block.GetHash() == hashGenesisBlock);\n\n        // Start new block file\n        unsigned int nFile;\n        unsigned int nBlockPos;\n        if (!block.WriteToDisk(nFile, nBlockPos))\n            return error(\"LoadBlockIndex() : writing genesis block to disk failed\");\n        if (!block.AddToBlockIndex(nFile, nBlockPos))\n            return error(\"LoadBlockIndex() : genesis block not accepted\");\n\n        // Initialise advanced checkpointing\n        if (!WriteSyncCheckpoint(hashGenesisBlock))\n            return error(\"LoadBlockIndex() : failed to initialise advanced checkpointing\");\n    }\n\n    // Verify the master public key and reset advanced checkpointing if changed\n    if (!CheckCheckpointPubKey())\n        return error(\"LoadBlockIndex() : failed to reset advanced checkpointing\");\n\n    return true;\n}\n\n\n\nvoid PrintBlockTree()\n{\n    // precompute tree structure\n    map<CBlockIndex*, vector<CBlockIndex*> > mapNext;\n    for (map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.begin(); mi != mapBlockIndex.end(); ++mi)\n    {\n        CBlockIndex* pindex = (*mi).second;\n        mapNext[pindex->pprev].push_back(pindex);\n        // test\n        //while (rand() % 3 == 0)\n        //    mapNext[pindex->pprev].push_back(pindex);\n    }\n\n    vector<pair<int, CBlockIndex*> > vStack;\n    vStack.push_back(make_pair(0, pindexGenesisBlock));\n\n    int nPrevCol = 0;\n    while (!vStack.empty())\n    {\n        int nCol = vStack.back().first;\n        CBlockIndex* pindex = vStack.back().second;\n        vStack.pop_back();\n\n        // print split or gap\n        if (nCol > nPrevCol)\n        {\n            for (int i = 0; i < nCol-1; i++)\n                printf(\"| \");\n            printf(\"|\\\\\\n\");\n        }\n        else if (nCol < nPrevCol)\n        {\n            for (int i = 0; i < nCol; i++)\n                printf(\"| \");\n            printf(\"|\\n\");\n       }\n        nPrevCol = nCol;\n\n        // print columns\n        for (int i = 0; i < nCol; i++)\n            printf(\"| \");\n\n        // print item\n        CBlock block;\n        block.ReadFromDisk(pindex);\n        printf(\"%d (%u,%u) %s  %s  tx %d\",\n            pindex->nHeight,\n            pindex->nFile,\n            pindex->nBlockPos,\n            block.GetHash().ToString().substr(0,20).c_str(),\n            DateTimeStrFormat(\"%x %H:%M:%S\", block.GetBlockTime()).c_str(),\n            block.vtx.size());\n\n        PrintWallets(block);\n\n        // put the main timechain first\n        vector<CBlockIndex*>& vNext = mapNext[pindex];\n        for (unsigned int i = 0; i < vNext.size(); i++)\n        {\n            if (vNext[i]->pnext)\n            {\n                swap(vNext[0], vNext[i]);\n                break;\n            }\n        }\n\n        // iterate children\n        for (unsigned int i = 0; i < vNext.size(); i++)\n            vStack.push_back(make_pair(nCol+i, vNext[i]));\n    }\n}\n\nbool LoadExternalBlockFile(FILE* fileIn)\n{\n    int nLoaded = 0;\n    {\n        LOCK(cs_main);\n        try {\n            CAutoFile blkdat(fileIn, SER_DISK, CLIENT_VERSION);\n            unsigned int nPos = 0;\n            while (nPos != (unsigned int)-1 && blkdat.good() && !fRequestShutdown)\n            {\n                unsigned char pchData[65536];\n                do {\n                    fseek(blkdat, nPos, SEEK_SET);\n                    int nRead = fread(pchData, 1, sizeof(pchData), blkdat);\n                    if (nRead <= 8)\n                    {\n                        nPos = (unsigned int)-1;\n                        break;\n                    }\n                    void* nFind = memchr(pchData, pchMessageStart[0], nRead+1-sizeof(pchMessageStart));\n                    if (nFind)\n                    {\n                        if (memcmp(nFind, pchMessageStart, sizeof(pchMessageStart))==0)\n                        {\n                            nPos += ((unsigned char*)nFind - pchData) + sizeof(pchMessageStart);\n                            break;\n                        }\n                        nPos += ((unsigned char*)nFind - pchData) + 1;\n                    }\n                    else\n                        nPos += sizeof(pchData) - sizeof(pchMessageStart) + 1;\n                } while(!fRequestShutdown);\n                if (nPos == (unsigned int)-1)\n                    break;\n                fseek(blkdat, nPos, SEEK_SET);\n                unsigned int nSize;\n                blkdat >> nSize;\n                if (nSize > 0 && nSize <= MAX_BLOCK_SIZE)\n                {\n                    CBlock block;\n                    blkdat >> block;\n                    if (ProcessBlock(NULL,&block))\n                    {\n                        nLoaded++;\n                        nPos += 4 + nSize;\n                    }\n                }\n            }\n        }\n        catch (std::exception &e) {\n            printf(\"%s() : Deserialize or I/O error caught during load\\n\",\n                   __PRETTY_FUNCTION__);\n        }\n    }\n    printf(\"Loaded %i blocks from external file\\n\", nLoaded);\n    return nLoaded > 0;\n}\n\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CAlert\n//\n\nmap<uint256, CAlert> mapAlerts;\nCCriticalSection cs_mapAlerts;\n\nstring GetWarnings(string strFor)\n{\n    int nPriority = 0;\n    string strStatusBar;\n    string strRPC;\n    if (GetBoolArg(\"-testsafemode\"))\n        strRPC = \"test\";\n\n    // Checkpoint warning\n    if (strCheckpointWarning != \"\")\n    {\n        nPriority = 900;\n        strStatusBar = strCheckpointWarning;\n    }\n\n    // Misc warnings like out of disk space and clock is wrong\n    if (strMiscWarning != \"\")\n    {\n        nPriority = 1000;\n        strStatusBar = strMiscWarning;\n    }\n\n    // Longer invalid proof-of-work chain\n    if (pindexBest && bnBestInvalidWork > bnBestChainWork + pindexBest->GetBlockWork() * 6)\n    {\n        nPriority = 2000;\n        strStatusBar = strRPC = \"WARNING: Displayed transactions may not be correct!  You may need to upgrade, or other nodes may need to upgrade.\";\n    }\n\n    // Activate safe mode upon failure of advanced checkpointing\n    if (hashInvalidCheckpoint != 0)\n    {\n        nPriority = 3000;\n        strStatusBar = strRPC = \"WARNING: Inconsistent advanced checkpoint found! Please report to the developers.\";\n    }\n\n    // Alerts\n    {\n        LOCK(cs_mapAlerts);\n        BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n        {\n            const CAlert& alert = item.second;\n            if (alert.AppliesToMe() && alert.nPriority > nPriority)\n            {\n                nPriority = alert.nPriority;\n                strStatusBar = alert.strStatusBar;\n            }\n        }\n    }\n\n    if (strFor == \"statusbar\")\n        return strStatusBar;\n    else if (strFor == \"rpc\")\n        return strRPC;\n    assert(!\"GetWarnings() : invalid parameter\");\n    return \"error\";\n}\n\nCAlert CAlert::getAlertByHash(const uint256 &hash)\n{\n    CAlert retval;\n    {\n        LOCK(cs_mapAlerts);\n        map<uint256, CAlert>::iterator mi = mapAlerts.find(hash);\n        if(mi != mapAlerts.end())\n            retval = mi->second;\n    }\n    return retval;\n}\n\nbool CAlert::ProcessAlert()\n{\n    if (!CheckSignature())\n        return false;\n    if (!IsInEffect())\n        return false;\n\n    {\n        LOCK(cs_mapAlerts);\n        // Cancel previous alerts\n        for (map<uint256, CAlert>::iterator mi = mapAlerts.begin(); mi != mapAlerts.end();)\n        {\n            const CAlert& alert = (*mi).second;\n            if (Cancels(alert))\n            {\n                printf(\"cancelling alert %d\\n\", alert.nID);\n                uiInterface.NotifyAlertChanged((*mi).first, CT_DELETED);\n                mapAlerts.erase(mi++);\n            }\n            else if (!alert.IsInEffect())\n            {\n                printf(\"expiring alert %d\\n\", alert.nID);\n                uiInterface.NotifyAlertChanged((*mi).first, CT_DELETED);\n                mapAlerts.erase(mi++);\n            }\n            else\n                mi++;\n        }\n\n        // Check if this alert has been cancelled\n        BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n        {\n            const CAlert& alert = item.second;\n            if (alert.Cancels(*this))\n            {\n                printf(\"alert already cancelled by %d\\n\", alert.nID);\n                return false;\n            }\n        }\n\n        // Add to mapAlerts\n        mapAlerts.insert(make_pair(GetHash(), *this));\n        // Notify UI if it applies to me\n        if(AppliesToMe())\n            uiInterface.NotifyAlertChanged(GetHash(), CT_NEW);\n    }\n\n    printf(\"accepted alert %d, AppliesToMe()=%d\\n\", nID, AppliesToMe());\n    return true;\n}\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Messages\n//\n\n\nbool static AlreadyHave(CTxDB& txdb, const CInv& inv)\n{\n    switch (inv.type)\n    {\n    case MSG_TX:\n        {\n        bool txInMap = false;\n            {\n            LOCK(mempool.cs);\n            txInMap = (mempool.exists(inv.hash));\n            }\n        return txInMap ||\n               mapOrphanTransactions.count(inv.hash) ||\n               txdb.ContainsTx(inv.hash);\n        }\n\n    case MSG_BLOCK:\n        return mapBlockIndex.count(inv.hash) ||\n               mapOrphanBlocks.count(inv.hash);\n    }\n    // Don't know what it is, just say we already got one\n    return true;\n}\n\n\n/* Relays an address to a limited number of nodes connected */\nvoid static RelayAddress(CAddress& addr, bool fReachable) {\n\n    LOCK(cs_vNodes);\n\n    // Use deterministic randomness to send to the same nodes for 12 hours\n    // at a time so the setAddrKnowns of the chosen nodes prevent repeats\n    static uint256 hashSalt;\n    if(hashSalt == 0)\n      RAND_bytes((uchar*)&hashSalt, sizeof(hashSalt));\n    int64 hashAddr = addr.GetHash();\n    uint256 hashRand = hashSalt ^ (hashAddr << 32) ^ ((GetTime() + hashAddr) / (12 * 60 * 60));\n    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n    multimap<uint256, CNode*> mapMix;\n    BOOST_FOREACH(CNode* pnode, vNodes) {\n        uint nPointer;\n        memcpy(&nPointer, &pnode, sizeof(nPointer));\n        uint256 hashKey = hashRand ^ nPointer;\n        hashKey = Hash(BEGIN(hashKey), END(hashKey));\n        mapMix.insert(make_pair(hashKey, pnode));\n    }\n    int nRelayNodes = fReachable ? 2 : 1;\n    for(multimap<uint256, CNode*>::iterator mi = mapMix.begin();\n      mi != mapMix.end() && nRelayNodes-- > 0; ++mi) {\n        ((*mi).second)->PushAddress(addr);\n        if(fDebug) printf(\"relaying: address %s\\n\", addr.ToString().c_str());\n    }\n}\n\n\nbool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n{\n    static map<CService, CPubKey> mapReuseKey;\n    RandAddSeedPerfmon();\n    if (fDebug)\n        printf(\"received: %s (%d bytes)\\n\", strCommand.c_str(), vRecv.size());\n    if (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)\n    {\n        printf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n        return true;\n    }\n\n\n\n\n\n    if (strCommand == \"version\")\n    {\n        /* Process the 1st version message received per connection\n         * and ignore the others if any */\n        if(pfrom->nVersion)\n          return(true);\n\n        int64 nTime;\n        CAddress addrMe;\n        CAddress addrFrom;\n        uint64 nNonce = 1;\n        vRecv >> pfrom->nVersion >> pfrom->nServices >> nTime >> addrMe;\n\n        // Do not connect to these clients as they're not Phoenixcoin ones or too old\n        if((pfrom->nVersion > MAX_PROTOCOL_VERSION) || (pfrom->nVersion < MIN_PROTOCOL_VERSION)) {\n            printf(\"peer %s reports incompatible version %i; disconnecting\\n\", pfrom->addr.ToString().c_str(), pfrom->nVersion);\n            pfrom->fDisconnect = true;\n            return false;\n        }\n\n        if (!vRecv.empty())\n            vRecv >> addrFrom >> nNonce;\n        if (!vRecv.empty())\n            vRecv >> pfrom->strSubVer;\n        if (!vRecv.empty())\n            vRecv >> pfrom->nStartingHeight;\n\n        if (pfrom->fInbound && addrMe.IsRoutable())\n        {\n            pfrom->addrLocal = addrMe;\n            SeenLocal(addrMe);\n        }\n\n        // Disconnect if we connected to ourself\n        if (nNonce == nLocalHostNonce && nNonce > 1)\n        {\n            printf(\"connected to self at %s; disconnecting\\n\", pfrom->addr.ToString().c_str());\n            pfrom->fDisconnect = true;\n            return true;\n        }\n\n        // Our external IP for getinfo\n        if(addrFrom.IsRoutable() && addrMe.IsRoutable()) addrExternal = addrMe;\n\n        // Be shy and don't send version until we hear\n        if (pfrom->fInbound)\n            pfrom->PushVersion();\n\n        pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);\n\n        AddTimeData(pfrom->addr, nTime);\n\n        // Change version\n        pfrom->PushMessage(\"verack\");\n        pfrom->vSend.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n\n        if (!pfrom->fInbound)\n        {\n            // Advertise our address\n            if (!fNoListen && !IsInitialBlockDownload())\n            {\n                CAddress addr = GetLocalAddress(&pfrom->addr);\n                if (addr.IsRoutable())\n                    pfrom->PushAddress(addr);\n            }\n\n            // Get recent addresses\n            int nAddrSize;\n            if(fBerkeleyAddrDB)\n              nAddrSize = mapAddresses.size();\n            else\n              nAddrSize = addrman.size();\n            if(pfrom->fOneShot || (nAddrSize < 1000)) {\n                pfrom->PushMessage(\"getaddr\");\n                pfrom->fGetAddr = true;\n            }\n            if(!fBerkeleyAddrDB)\n              addrman.Good(pfrom->addr);\n        } else {\n            if(!fBerkeleyAddrDB && ((CNetAddr)pfrom->addr == (CNetAddr)addrFrom)) {\n                addrman.Add(addrFrom, addrFrom);\n                addrman.Good(addrFrom);\n            }\n        }\n\n        // Another Ghostlander's quick hack to deal with nodes advertising\n        // compatible version numbers while confusing our Qt client;\n        // if their nStartingHeight is much higher of what we estimate it\n        // to be, disconnect them.\n        // nRefHeight and nRefTime should be updated periodically\n        long nRefHeight = 745000, nRefTime = 1438677830; // block #745000\n        long nOurTime = GetAdjustedTime();\n        long nHeightOffset = (nOurTime - nRefTime) / nTargetSpacingFour;\n        // Add 10000 blocks to be safe\n        if(pfrom->nStartingHeight > (nRefHeight + nHeightOffset + 10000)) {\n            printf(\"peer %s reports height %i, estimated height is %i; disconnecting\\n\",\n              pfrom->addr.ToString().c_str(), pfrom->nStartingHeight, nRefHeight + nHeightOffset);\n            pfrom->fDisconnect = true;\n            return false;\n        }\n\n        // Ask the first connected node for block updates\n        static int nAskedForBlocks = 0;\n        if (!pfrom->fClient && !pfrom->fOneShot &&\n            (pfrom->nVersion < NOBLKS_VERSION_START ||\n             pfrom->nVersion >= NOBLKS_VERSION_END) &&\n             (nAskedForBlocks < 1 || vNodes.size() <= 1))\n        {\n            nAskedForBlocks++;\n            pfrom->PushGetBlocks(pindexBest, uint256(0));\n        }\n\n        // Relay alerts\n        {\n            LOCK(cs_mapAlerts);\n            BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n                item.second.RelayTo(pfrom);\n        }\n\n        // Relay advanced checkpoints\n        {\n            LOCK(cs_hashSyncCheckpoint);\n            if (!checkpointMessage.IsNull())\n                checkpointMessage.RelayTo(pfrom);\n        }\n\n        pfrom->fSuccessfullyConnected = true;\n\n        printf(\"received version message from %s, version %d, blocks=%d, us=%s, them=%s\\n\",\n          pfrom->addr.ToString().c_str(), pfrom->nVersion, pfrom->nStartingHeight, addrMe.ToString().c_str(), addrFrom.ToString().c_str());\n\n        cPeerBlockCounts.input(pfrom->nStartingHeight);\n\n        // Check for any advanced checkpoint pending\n        if (!IsInitialBlockDownload())\n            AskForPendingSyncCheckpoint(pfrom);\n    }\n\n\n    else if (pfrom->nVersion == 0)\n    {\n        // Must have a version message before anything else\n        pfrom->Misbehaving(1);\n        return false;\n    }\n\n\n    else if (strCommand == \"verack\")\n    {\n        pfrom->vRecv.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n    }\n\n\n    else if (strCommand == \"addr\")\n    {\n        vector<CAddress> vAddr;\n        vRecv >> vAddr;\n\n        if(vAddr.size() > 1000) {\n            pfrom->Misbehaving(20);\n            return(error(\"Address message size = %d\", vAddr.size()));\n        }\n\n        int64 nNow = GetAdjustedTime();\n        int64 nSince = nNow - 10 * 60;\n        bool fReachable;\n\n        if(fBerkeleyAddrDB) {\n\n            CBerkeleyAddrDB adb;\n            adb.TxnBegin();\n\n            BOOST_FOREACH(CAddress& addr, vAddr) {\n\n                if(fShutdown)\n                  return(true);\n\n                /* Simple port filter */\n                ushort nPort = addr.GetPort();\n                if(nPort != GetDefaultPort())\n                  continue;\n\n                if((addr.nTime <= 100000000) || (addr.nTime > nNow + 10 * 60))\n                  addr.nTime = nNow - 5 * 24 * 60 * 60;\n\n                fReachable = IsReachable(addr);\n\n                if(fReachable)\n                  AddAddress(addr, 2 * 60 * 60, &adb);\n\n                pfrom->AddAddressKnown(addr);\n\n                if((addr.nTime > nSince) && !pfrom->fGetAddr &&\n                  (vAddr.size() <= 10) && addr.IsRoutable())\n                  RelayAddress(addr, fReachable);\n\n            }\n\n            adb.TxnCommit();\n\n        } else {\n\n            vector<CAddress> vAddrOk;\n\n            BOOST_FOREACH(CAddress& addr, vAddr) {\n\n                if(fShutdown)\n                  return(true);\n\n                /* Simple port filter */\n                ushort nPort = addr.GetPort();\n                if(nPort != GetDefaultPort())\n                  continue;\n\n                if((addr.nTime <= 100000000) || (addr.nTime > nNow + 10 * 60))\n                  addr.nTime = nNow - 5 * 24 * 60 * 60;\n\n                fReachable = IsReachable(addr);\n\n                if(fReachable)\n                  vAddrOk.push_back(addr);\n\n                pfrom->AddAddressKnown(addr);\n\n                if((addr.nTime > nSince) && !pfrom->fGetAddr &&\n                  (vAddr.size() <= 10) && addr.IsRoutable())\n                  RelayAddress(addr, fReachable);\n\n            }\n\n            addrman.Add(vAddrOk, pfrom->addr, 2 * 60 * 60);\n\n        }\n\n        if(vAddr.size() < 1000)\n          pfrom->fGetAddr = false;\n\n        if(pfrom->fOneShot)\n          pfrom->fDisconnect = true;\n\n    }\n\n    else if (strCommand == \"inv\")\n    {\n        vector<CInv> vInv;\n        vRecv >> vInv;\n        if (vInv.size() > 50000)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message inv size() = %d\", vInv.size());\n        }\n\n        // find last block in inv vector\n        unsigned int nLastBlock = (unsigned int)(-1);\n        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++) {\n            if (vInv[vInv.size() - 1 - nInv].type == MSG_BLOCK) {\n                nLastBlock = vInv.size() - 1 - nInv;\n                break;\n            }\n        }\n        CTxDB txdb(\"r\");\n        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n        {\n            const CInv &inv = vInv[nInv];\n\n            if (fShutdown)\n                return true;\n            pfrom->AddInventoryKnown(inv);\n\n            bool fAlreadyHave = AlreadyHave(txdb, inv);\n            if (fDebug)\n                printf(\"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fAlreadyHave ? \"have\" : \"new\");\n\n            if (!fAlreadyHave)\n                pfrom->AskFor(inv);\n            else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash)) {\n                pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(mapOrphanBlocks[inv.hash]));\n            } else if (nInv == nLastBlock) {\n                // In case we are on a very long side-chain, it is possible that we already have\n                // the last block in an inv bundle sent in response to getblocks. Try to detect\n                // this situation and push another getblocks to continue.\n                std::vector<CInv> vGetData(1,inv);\n                pfrom->PushGetBlocks(mapBlockIndex[inv.hash], uint256(0));\n                if (fDebug)\n                    printf(\"force request: %s\\n\", inv.ToString().c_str());\n            }\n\n            // Track requests for our stuff\n            Inventory(inv.hash);\n        }\n    }\n\n\n    else if (strCommand == \"getdata\")\n    {\n        vector<CInv> vInv;\n        vRecv >> vInv;\n        if (vInv.size() > 50000)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message getdata size() = %d\", vInv.size());\n        }\n\n        if (fDebugNet || (vInv.size() != 1))\n            printf(\"received getdata (%d invsz)\\n\", vInv.size());\n\n        BOOST_FOREACH(const CInv& inv, vInv)\n        {\n            if (fShutdown)\n                return true;\n            if (fDebugNet || (vInv.size() == 1))\n                printf(\"received getdata for: %s\\n\", inv.ToString().c_str());\n\n            if (inv.type == MSG_BLOCK)\n            {\n                // Send block from disk\n                map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(inv.hash);\n                if (mi != mapBlockIndex.end())\n                {\n                    CBlock block;\n                    block.ReadFromDisk((*mi).second);\n                    pfrom->PushMessage(\"block\", block);\n\n                    // Trigger them to send a getblocks request for the next batch of inventory\n                    if (inv.hash == pfrom->hashContinue)\n                    {\n                        // Bypass PushInventory, this must send even if redundant,\n                        // and we want it right after the last block so they don't\n                        // wait for other stuff first.\n                        vector<CInv> vInv;\n                        vInv.push_back(CInv(MSG_BLOCK, hashBestChain));\n                        pfrom->PushMessage(\"inv\", vInv);\n                        pfrom->hashContinue = 0;\n                    }\n                }\n            }\n            else if (inv.IsKnownType())\n            {\n                // Send stream from relay memory\n                {\n                    LOCK(cs_mapRelay);\n                    map<CInv, CDataStream>::iterator mi = mapRelay.find(inv);\n                    if (mi != mapRelay.end())\n                        pfrom->PushMessage(inv.GetCommand(), (*mi).second);\n                }\n            }\n\n            // Track requests for our stuff\n            Inventory(inv.hash);\n        }\n    }\n\n\n    else if (strCommand == \"getblocks\")\n    {\n        CBlockLocator locator;\n        uint256 hashStop;\n        vRecv >> locator >> hashStop;\n\n        // Find the last block the caller has in the main chain\n        CBlockIndex* pindex = locator.GetBlockIndex();\n\n        // Send the rest of the chain\n        if (pindex)\n            pindex = pindex->pnext;\n        int nLimit = 1000;\n        printf(\"getblocks %d to %s limit %d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str(), nLimit);\n        for (; pindex; pindex = pindex->pnext)\n        {\n            if (pindex->GetBlockHash() == hashStop)\n            {\n                printf(\"  getblocks stopping at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str());\n                break;\n            }\n            pfrom->PushInventory(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n            if (--nLimit <= 0)\n            {\n                // When this block is requested, we'll send an inv that'll make them\n                // getblocks the next batch of inventory.\n                printf(\"  getblocks stopping at limit %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str());\n                pfrom->hashContinue = pindex->GetBlockHash();\n                break;\n            }\n        }\n    }\n\n\n    else if (strCommand == \"getheaders\")\n    {\n        CBlockLocator locator;\n        uint256 hashStop;\n        vRecv >> locator >> hashStop;\n\n        CBlockIndex* pindex = NULL;\n        if (locator.IsNull())\n        {\n            // If locator is null, return the hashStop block\n            map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashStop);\n            if (mi == mapBlockIndex.end())\n                return true;\n            pindex = (*mi).second;\n        }\n        else\n        {\n            // Find the last block the caller has in the main chain\n            pindex = locator.GetBlockIndex();\n            if (pindex)\n                pindex = pindex->pnext;\n        }\n\n        vector<CBlock> vHeaders;\n        int nLimit = 2000;\n        printf(\"getheaders %d to %s\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str());\n        for (; pindex; pindex = pindex->pnext)\n        {\n            vHeaders.push_back(pindex->GetBlockHeader());\n            if (--nLimit <= 0 || pindex->GetBlockHash() == hashStop)\n                break;\n        }\n        pfrom->PushMessage(\"headers\", vHeaders);\n    }\n\n\n    else if (strCommand == \"tx\")\n    {\n        vector<uint256> vWorkQueue;\n        vector<uint256> vEraseQueue;\n        CDataStream vMsg(vRecv);\n        CTxDB txdb(\"r\");\n        CTransaction tx;\n        vRecv >> tx;\n\n        CInv inv(MSG_TX, tx.GetHash());\n        pfrom->AddInventoryKnown(inv);\n\n        // Truncate a message to the actual transaction size\n        unsigned int nSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n        unsigned int oldSize = vMsg.size();\n        if(nSize < oldSize) {\n            printf(\"truncating oversized transaction message %s (%u -> %u)\\n\",\n              tx.GetHash().ToString().c_str(), oldSize, nSize);\n            vMsg.resize(nSize);\n        }\n\n        bool fMissingInputs = false;\n        if(tx.AcceptToMemoryPool(txdb, true, true, &fMissingInputs)) {\n            SyncWithWallets(tx, NULL, true);\n            RelayMessage(inv, vMsg);\n            mapAlreadyAskedFor.erase(inv);\n            vWorkQueue.push_back(inv.hash);\n            vEraseQueue.push_back(inv.hash);\n\n            // Recursively process any orphan transactions that depended on this one\n            for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n            {\n                uint256 hashPrev = vWorkQueue[i];\n                for (map<uint256, CDataStream*>::iterator mi = mapOrphanTransactionsByPrev[hashPrev].begin();\n                     mi != mapOrphanTransactionsByPrev[hashPrev].end();\n                     ++mi)\n                {\n                    const CDataStream& vMsg = *((*mi).second);\n                    CTransaction tx;\n                    CDataStream(vMsg) >> tx;\n                    CInv inv(MSG_TX, tx.GetHash());\n                    bool fMissingInputs2 = false;\n\n                    if(tx.AcceptToMemoryPool(txdb, true, true, &fMissingInputs2)) {\n                        printf(\"   accepted orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n                        SyncWithWallets(tx, NULL, true);\n                        RelayMessage(inv, vMsg);\n                        mapAlreadyAskedFor.erase(inv);\n                        vWorkQueue.push_back(inv.hash);\n                        vEraseQueue.push_back(inv.hash);\n                    }\n                    else if(!fMissingInputs2) {\n                        /* Invalid or insufficient fee orphan */\n                        vEraseQueue.push_back(inv.hash);\n                        printf(\"   removed orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n                    }\n                }\n            }\n\n            BOOST_FOREACH(uint256 hash, vEraseQueue)\n                EraseOrphanTx(hash);\n        }\n        else if (fMissingInputs)\n        {\n            AddOrphanTx(vMsg);\n\n            // DoS prevention: do not allow mapOrphanTransactions to grow unbounded\n            unsigned int nEvicted = LimitOrphanTxSize(MAX_ORPHAN_TRANSACTIONS);\n            if (nEvicted > 0)\n                printf(\"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n        }\n        if (tx.nDoS) pfrom->Misbehaving(tx.nDoS);\n    }\n\n\n    else if (strCommand == \"block\")\n    {\n        CBlock block;\n        vRecv >> block;\n        uint256 hashBlock = block.GetHash();\n        int nBlockHeight = block.GetBlockHeight();\n\n        printf(\"received block %s height %d\\n\",\n          hashBlock.ToString().substr(0,20).c_str(), nBlockHeight);\n\n        CInv inv(MSG_BLOCK, hashBlock);\n        pfrom->AddInventoryKnown(inv);\n\n        if(ProcessBlock(pfrom, &block))\n          mapAlreadyAskedFor.erase(inv);\n\n        if(block.nDoS)\n          pfrom->Misbehaving(block.nDoS);\n    }\n\n\n    else if (strCommand == \"getaddr\")\n    {\n        pfrom->vAddrToSend.clear();\n        vector<CAddress> vAddr = addrman.GetAddr();\n        BOOST_FOREACH(const CAddress &addr, vAddr)\n            pfrom->PushAddress(addr);\n    }\n\n\n    else if (strCommand == \"checkorder\")\n    {\n        uint256 hashReply;\n        vRecv >> hashReply;\n\n        if (!GetBoolArg(\"-allowreceivebyip\"))\n        {\n            pfrom->PushMessage(\"reply\", hashReply, (int)2, string(\"\"));\n            return true;\n        }\n\n        CWalletTx order;\n        vRecv >> order;\n\n        /// we have a chance to check the order here\n\n        // Keep giving the same key to the same ip until they use it\n        if (!mapReuseKey.count(pfrom->addr))\n            pwalletMain->GetKeyFromPool(mapReuseKey[pfrom->addr], true);\n\n        // Send back approval of order and pubkey to use\n        CScript scriptPubKey;\n        scriptPubKey << mapReuseKey[pfrom->addr] << OP_CHECKSIG;\n        pfrom->PushMessage(\"reply\", hashReply, (int)0, scriptPubKey);\n    }\n\n\n    else if (strCommand == \"reply\")\n    {\n        uint256 hashReply;\n        vRecv >> hashReply;\n\n        CRequestTracker tracker;\n        {\n            LOCK(pfrom->cs_mapRequests);\n            map<uint256, CRequestTracker>::iterator mi = pfrom->mapRequests.find(hashReply);\n            if (mi != pfrom->mapRequests.end())\n            {\n                tracker = (*mi).second;\n                pfrom->mapRequests.erase(mi);\n            }\n        }\n        if (!tracker.IsNull())\n            tracker.fn(tracker.param1, vRecv);\n    }\n\n\n    else if (strCommand == \"ping\")\n    {\n        if (pfrom->nVersion > BIP0031_VERSION)\n        {\n            uint64 nonce = 0;\n            vRecv >> nonce;\n            // Echo the message back with the nonce. This allows for two useful features:\n            //\n            // 1) A remote node can quickly check if the connection is operational\n            // 2) Remote nodes can measure the latency of the network thread. If this node\n            //    is overloaded it won't respond to pings quickly and the remote node can\n            //    avoid sending us more work, like chain download requests.\n            //\n            // The nonce stops the remote getting confused between different pings: without\n            // it, if the remote node sends a ping once per second and this node takes 5\n            // seconds to respond to each, the 5th ping the remote sends would appear to\n            // return very quickly.\n            pfrom->PushMessage(\"pong\", nonce);\n        }\n    }\n\n\n    else if (strCommand == \"alert\")\n    {\n        if(pfrom->fDisconnect) {\n            printf(\"alert received from a disconnected peer %s of version %i; ignoring\\n\",\n              pfrom->addr.ToString().c_str(), pfrom->nVersion);\n            return false;\n        }\n\n        CAlert alert;\n        vRecv >> alert;\n\n        if (alert.ProcessAlert())\n        {\n            // Relay\n            pfrom->setKnown.insert(alert.GetHash());\n            {\n                LOCK(cs_vNodes);\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                    alert.RelayTo(pnode);\n            }\n        } else {\n             // DDoS protection\n             pfrom->Misbehaving(20);\n        }\n    }\n\n\n    // Advanced checkpoint\n    else if (strCommand == \"checkpoint\")\n    {\n        if(pfrom->fDisconnect) {\n            printf(\"sync-checkpoint received from a disconnected peer %s of version %i; ignoring\\n\",\n              pfrom->addr.ToString().c_str(), pfrom->nVersion);\n            return false;\n        }\n\n        CSyncCheckpoint checkpoint;\n        vRecv >> checkpoint;\n\n        if (checkpoint.ProcessSyncCheckpoint(pfrom))\n        {\n            // Relay\n            pfrom->hashCheckpointKnown = checkpoint.hashCheckpoint;\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodes)\n                checkpoint.RelayTo(pnode);\n        }\n    }\n\n\n    else\n    {\n        // Ignore unknown commands for extensibility\n    }\n\n\n    // Update the last seen time for this node's address\n    if (pfrom->fNetworkNode)\n        if (strCommand == \"version\" || strCommand == \"addr\" || strCommand == \"inv\" || strCommand == \"getdata\" || strCommand == \"ping\")\n            AddressCurrentlyConnected(pfrom->addr);\n\n\n    return true;\n}\n\nbool ProcessMessages(CNode* pfrom)\n{\n    CDataStream& vRecv = pfrom->vRecv;\n    if (vRecv.empty())\n        return true;\n    //if (fDebug)\n    //    printf(\"ProcessMessages(%u bytes)\\n\", vRecv.size());\n\n    //\n    // Message format\n    //  (4) message start\n    //  (12) command\n    //  (4) size\n    //  (4) checksum\n    //  (x) data\n    //\n\n    while(true) {\n\n        // Don't bother if send buffer is too full to respond anyway\n        if (pfrom->vSend.size() >= SendBufferSize())\n            break;\n\n        // Scan for message start\n        CDataStream::iterator pstart;\n        int nHeaderSize;\n        bool fMagic;\n\n        /* Message start detector */\n        if(pfrom->nVersion) {\n            /* If a protocol version is known, the detection is easy */\n            if(pfrom->nVersion >= NEW_MAGIC_VERSION) {\n                pstart = search(vRecv.begin(), vRecv.end(), BEGIN(pchMessageStartNew), END(pchMessageStartNew));\n                fMagic = true;\n            } else {\n                pstart = search(vRecv.begin(), vRecv.end(), BEGIN(pchMessageStart), END(pchMessageStart));\n                fMagic = false;\n            }\n        } else {\n            /* Check for the old magic number first */\n            pstart = search(vRecv.begin(), vRecv.end(), BEGIN(pchMessageStart), END(pchMessageStart));\n            fMagic = false;\n            if(vRecv.end() == pstart) {\n                /* Must be the new magic number */\n                pstart = search(vRecv.begin(), vRecv.end(), BEGIN(pchMessageStartNew), END(pchMessageStartNew));\n                fMagic = true;\n            }\n        }\n\n        nHeaderSize = vRecv.GetSerializeSize(CMessageHeader(fMagic));\n\n        if (vRecv.end() - pstart < nHeaderSize)\n        {\n            if ((int)vRecv.size() > nHeaderSize)\n            {\n                printf(\"\\n\\nPROCESSMESSAGE MESSAGESTART NOT FOUND\\n\\n\");\n                vRecv.erase(vRecv.begin(), vRecv.end() - nHeaderSize);\n            }\n            break;\n        }\n        if (pstart - vRecv.begin() > 0)\n            printf(\"\\n\\nPROCESSMESSAGE SKIPPED %d BYTES\\n\\n\", pstart - vRecv.begin());\n        vRecv.erase(vRecv.begin(), pstart);\n\n        // Read header\n        vector<char> vHeaderSave(vRecv.begin(), vRecv.begin() + nHeaderSize);\n        CMessageHeader hdr;\n        vRecv >> hdr;\n        if(!hdr.IsValid(fMagic)) {\n            printf(\"\\n\\nPROCESSMESSAGE: ERRORS IN HEADER %s\\n\\n\\n\", hdr.GetCommand().c_str());\n            continue;\n        }\n        string strCommand = hdr.GetCommand();\n\n        // Message size\n        unsigned int nMessageSize = hdr.nMessageSize;\n        if (nMessageSize > MAX_SIZE)\n        {\n            printf(\"ProcessMessages(%s, %u bytes) : nMessageSize > MAX_SIZE\\n\", strCommand.c_str(), nMessageSize);\n            continue;\n        }\n        if (nMessageSize > vRecv.size())\n        {\n            // Rewind and wait for rest of message\n            vRecv.insert(vRecv.begin(), vHeaderSave.begin(), vHeaderSave.end());\n            break;\n        }\n\n        // Checksum\n        uint256 hash = Hash(vRecv.begin(), vRecv.begin() + nMessageSize);\n        unsigned int nChecksum = 0;\n        memcpy(&nChecksum, &hash, sizeof(nChecksum));\n        if (nChecksum != hdr.nChecksum)\n        {\n            printf(\"ProcessMessages(%s, %u bytes) : CHECKSUM ERROR nChecksum=%08x hdr.nChecksum=%08x\\n\",\n               strCommand.c_str(), nMessageSize, nChecksum, hdr.nChecksum);\n            continue;\n        }\n\n        // Copy message to its own buffer\n        CDataStream vMsg(vRecv.begin(), vRecv.begin() + nMessageSize, vRecv.nType, vRecv.nVersion);\n        vRecv.ignore(nMessageSize);\n\n        // Process message\n        bool fRet = false;\n        try\n        {\n            {\n                LOCK(cs_main);\n                fRet = ProcessMessage(pfrom, strCommand, vMsg);\n            }\n            if (fShutdown)\n                return true;\n        }\n        catch (std::ios_base::failure& e)\n        {\n            if (strstr(e.what(), \"end of data\"))\n            {\n                // Allow exceptions from underlength message on vRecv\n                printf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", strCommand.c_str(), nMessageSize, e.what());\n            }\n            else if (strstr(e.what(), \"size too large\"))\n            {\n                // Allow exceptions from overlong size\n                printf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught\\n\", strCommand.c_str(), nMessageSize, e.what());\n            }\n            else\n            {\n                PrintExceptionContinue(&e, \"ProcessMessages()\");\n            }\n        }\n        catch (std::exception& e) {\n            PrintExceptionContinue(&e, \"ProcessMessages()\");\n        } catch (...) {\n            PrintExceptionContinue(NULL, \"ProcessMessages()\");\n        }\n\n        if (!fRet)\n            printf(\"ProcessMessage(%s, %u bytes) FAILED\\n\", strCommand.c_str(), nMessageSize);\n    }\n\n    vRecv.Compact();\n    return true;\n}\n\n\nbool SendMessages(CNode* pto, bool fSendTrickle)\n{\n    TRY_LOCK(cs_main, lockMain);\n    if (lockMain) {\n        // Don't send anything until we get their version message\n        if (pto->nVersion == 0)\n            return true;\n\n        // Keep-alive ping. We send a nonce of zero because we don't use it anywhere\n        // right now.\n        if (pto->nLastSend && GetTime() - pto->nLastSend > 30 * 60 && pto->vSend.empty()) {\n            uint64 nonce = 0;\n            if (pto->nVersion > BIP0031_VERSION)\n                pto->PushMessage(\"ping\", nonce);\n            else\n                pto->PushMessage(\"ping\");\n        }\n\n        // Resend wallet transactions that haven't gotten in a block yet\n        ResendWalletTransactions(false);\n\n        // Address refresh broadcast\n        static int64 nLastRebroadcast;\n        if (!IsInitialBlockDownload() && (GetTime() - nLastRebroadcast > 24 * 60 * 60))\n        {\n            {\n                LOCK(cs_vNodes);\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                {\n                    // Periodically clear setAddrKnown to allow refresh broadcasts\n                    if (nLastRebroadcast)\n                        pnode->setAddrKnown.clear();\n\n                    // Rebroadcast our address\n                    if (!fNoListen)\n                    {\n                        CAddress addr = GetLocalAddress(&pnode->addr);\n                        if (addr.IsRoutable())\n                            pnode->PushAddress(addr);\n                    }\n                }\n            }\n            nLastRebroadcast = GetTime();\n        }\n\n        if(fBerkeleyAddrDB) {\n            // Clear out old addresses periodically so it's not too much work at once\n            static int64 nLastClear;\n            if(nLastClear == 0)\n              nLastClear = GetTime();\n            if(((GetTime() - nLastClear) > (10 * 60)) &&\n             (vNodes.size() >= (MAX_OUTBOUND_CONNECTIONS / 4))) {\n                nLastClear = GetTime();\n                LOCK(cs_mapAddresses);\n                CBerkeleyAddrDB adb;\n                int64 nSince = GetAdjustedTime() - 14 * 24 * 60 * 60;\n                for(map<vector<uchar>, CAddress>::iterator mi = mapAddresses.begin();\n                  mi != mapAddresses.end();) {\n                    const CAddress& addr = (*mi).second;\n                    if(addr.nTime < nSince) {\n                        if((mapAddresses.size() < 1000) || (GetTime() > nLastClear + 20))\n                          break;\n                        adb.EraseAddress(addr);\n                        mapAddresses.erase(mi++);\n                    } else mi++;\n                }\n            }\n        }\n\n        //\n        // Message: addr\n        //\n        if (fSendTrickle)\n        {\n            vector<CAddress> vAddr;\n            vAddr.reserve(pto->vAddrToSend.size());\n            BOOST_FOREACH(const CAddress& addr, pto->vAddrToSend)\n            {\n                // returns true if wasn't already contained in the set\n                if (pto->setAddrKnown.insert(addr).second)\n                {\n                    vAddr.push_back(addr);\n                    // receiver rejects addr messages larger than 1000\n                    if (vAddr.size() >= 1000)\n                    {\n                        pto->PushMessage(\"addr\", vAddr);\n                        vAddr.clear();\n                    }\n                }\n            }\n            pto->vAddrToSend.clear();\n            if (!vAddr.empty())\n                pto->PushMessage(\"addr\", vAddr);\n        }\n\n\n        //\n        // Message: inventory\n        //\n        vector<CInv> vInv;\n        vector<CInv> vInvWait;\n        {\n            LOCK(pto->cs_inventory);\n            vInv.reserve(pto->vInventoryToSend.size());\n            vInvWait.reserve(pto->vInventoryToSend.size());\n            BOOST_FOREACH(const CInv& inv, pto->vInventoryToSend)\n            {\n                if (pto->setInventoryKnown.count(inv))\n                    continue;\n\n                // trickle out tx inv to protect privacy\n                if (inv.type == MSG_TX && !fSendTrickle)\n                {\n                    // 1/4 of tx invs blast to all immediately\n                    static uint256 hashSalt;\n                    if (hashSalt == 0)\n                        hashSalt = GetRandHash();\n                    uint256 hashRand = inv.hash ^ hashSalt;\n                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n                    bool fTrickleWait = ((hashRand & 3) != 0);\n\n                    // always trickle our own transactions\n                    if (!fTrickleWait)\n                    {\n                        CWalletTx wtx;\n                        if (GetTransaction(inv.hash, wtx))\n                            if (wtx.fFromMe)\n                                fTrickleWait = true;\n                    }\n\n                    if (fTrickleWait)\n                    {\n                        vInvWait.push_back(inv);\n                        continue;\n                    }\n                }\n\n                // returns true if wasn't already contained in the set\n                if (pto->setInventoryKnown.insert(inv).second)\n                {\n                    vInv.push_back(inv);\n                    if (vInv.size() >= 1000)\n                    {\n                        pto->PushMessage(\"inv\", vInv);\n                        vInv.clear();\n                    }\n                }\n            }\n            pto->vInventoryToSend = vInvWait;\n        }\n        if (!vInv.empty())\n            pto->PushMessage(\"inv\", vInv);\n\n\n        //\n        // Message: getdata\n        //\n        vector<CInv> vGetData;\n        int64 nNow = GetTime() * 1000000;\n        CTxDB txdb(\"r\");\n        while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)\n        {\n            const CInv& inv = (*pto->mapAskFor.begin()).second;\n            if (!AlreadyHave(txdb, inv))\n            {\n                if (fDebugNet)\n                    printf(\"sending getdata: %s\\n\", inv.ToString().c_str());\n                vGetData.push_back(inv);\n                if (vGetData.size() >= 1000)\n                {\n                    pto->PushMessage(\"getdata\", vGetData);\n                    vGetData.clear();\n                }\n                mapAlreadyAskedFor[inv] = nNow;\n            }\n            pto->mapAskFor.erase(pto->mapAskFor.begin());\n        }\n        if (!vGetData.empty())\n            pto->PushMessage(\"getdata\", vGetData);\n\n    }\n    return true;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// PhoenixcoinMiner\n//\n\nstatic const unsigned int pSHA256InitState[8] =\n{0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};\n\n\n// Some explaining would be appreciated\nclass COrphan\n{\npublic:\n    CTransaction* ptx;\n    set<uint256> setDependsOn;\n    double dPriority;\n\n    COrphan(CTransaction* ptxIn)\n    {\n        ptx = ptxIn;\n        dPriority = 0;\n    }\n\n    void print() const\n    {\n        printf(\"COrphan(hash=%s, dPriority=%.1f)\\n\", ptx->GetHash().ToString().substr(0,10).c_str(), dPriority);\n        BOOST_FOREACH(uint256 hash, setDependsOn)\n            printf(\"   setDependsOn %s\\n\", hash.ToString().substr(0,10).c_str());\n    }\n};\n\n\nuint64 nLastBlockTx = 0;\nuint64 nLastBlockSize = 0;\n\n/* Creates a new block and collects transactions into */\nCBlock* CreateNewBlock(CReserveKey& reservekey) {\n    CBlockIndex* pindexPrev;\n\n    // Create new block\n    auto_ptr<CBlock> pblock(new CBlock());\n    if (!pblock.get())\n        return NULL;\n\n    // Create coinbase tx\n    CTransaction txNew;\n    txNew.vin.resize(1);\n    txNew.vin[0].prevout.SetNull();\n    txNew.vout.resize(1);\n    txNew.vout[0].scriptPubKey << reservekey.GetReservedKey() << OP_CHECKSIG;\n\n    // Add our coinbase tx as first transaction\n    pblock->vtx.push_back(txNew);\n\n    // Collect memory pool transactions into the block\n    int64 nFees = 0;\n    {\n        LOCK2(cs_main, mempool.cs);\n        pindexPrev = pindexBest;\n        CTxDB txdb(\"r\");\n\n        // Priority order to process transactions\n        list<COrphan> vOrphan; // list memory doesn't move\n        map<uint256, vector<COrphan*> > mapDependers;\n        multimap<double, CTransaction*> mapPriority;\n        for (map<uint256, CTransaction>::iterator mi = mempool.mapTx.begin(); mi != mempool.mapTx.end(); ++mi)\n        {\n            CTransaction& tx = (*mi).second;\n            if (tx.IsCoinBase() || !tx.IsFinal())\n                continue;\n\n            COrphan* porphan = NULL;\n            double dPriority = 0;\n            bool fMissingInputs = false;\n            BOOST_FOREACH(const CTxIn& txin, tx.vin)\n            {\n                // Read prev transaction\n                CTransaction txPrev;\n                CTxIndex txindex;\n                if(!txPrev.ReadFromDisk(txdb, txin.prevout, txindex)) {\n\n                    /* A safety check as this should never happen */\n                    if(!mempool.mapTx.count(txin.prevout.hash)) {\n                        printf(\"ERROR: mempool transaction missing input\\n\");\n                        fMissingInputs = true;\n                        if(porphan) vOrphan.pop_back();\n                        break;\n                    }\n\n                    // Has to wait for dependencies\n                    if (!porphan)\n                    {\n                        // Use list for automatic deletion\n                        vOrphan.push_back(COrphan(&tx));\n                        porphan = &vOrphan.back();\n                    }\n                    mapDependers[txin.prevout.hash].push_back(porphan);\n                    porphan->setDependsOn.insert(txin.prevout.hash);\n                    continue;\n                }\n\n                int64 nValueIn = txPrev.vout[txin.prevout.n].nValue;\n\n                int nConf = 1;\n                CBlock block;\n                /* Read the block including transactions */\n                if(block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, true)) {\n                    int nHeight = block.GetBlockHeight();\n                    if(nHeight > 0)\n                      /* Precise calculation */\n                      nConf = pindexPrev->nHeight - nHeight;\n                    else\n                      /* Acceptable approximation */\n                      nConf = (pindexPrev->nTime - block.nTime) / nTargetSpacingZero;\n                }\n\n                dPriority += (double)nValueIn * nConf;\n\n            }\n            if(fMissingInputs) continue;\n\n            // Priority is sum(valuein * age) / txsize\n            dPriority /= ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n\n            if (porphan)\n                porphan->dPriority = dPriority;\n            else\n                mapPriority.insert(make_pair(-dPriority, &(*mi).second));\n\n        }\n\n        // Collect transactions into block\n        map<uint256, CTxIndex> mapTestPool;\n        uint64 nBlockSize = 1000;\n        uint64 nBlockTx = 0;\n        int nBlockSigOps = 100;\n        while (!mapPriority.empty())\n        {\n            // Take highest priority transaction off priority queue\n            double dPriority = -(*mapPriority.begin()).first;\n            CTransaction& tx = *(*mapPriority.begin()).second;\n            mapPriority.erase(mapPriority.begin());\n\n            // Size limits\n            unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n            if (nBlockSize + nTxSize >= MAX_BLOCK_SIZE_GEN)\n                continue;\n\n            // Legacy limits on sigOps:\n            unsigned int nTxSigOps = tx.GetLegacySigOpCount();\n            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n                continue;\n\n            // Transaction fee required depends on block size\n            // Phoenixcoin: low priority transactions up to 500 bytes in size\n            // are free unless they get caught by the dust spam filter\n            bool fAllowFree = ((nBlockSize + nTxSize < 1500) || CTransaction::AllowFree(dPriority));\n            int64 nMinFee = tx.GetMinFee(nTxSize, fAllowFree, GMF_BLOCK);\n\n            // Connecting shouldn't fail due to dependency on other memory pool transactions\n            // because we're already processing them in order of dependency\n            map<uint256, CTxIndex> mapTestPoolTmp(mapTestPool);\n            MapPrevTx mapInputs;\n            bool fInvalid;\n            if (!tx.FetchInputs(txdb, mapTestPoolTmp, false, true, mapInputs, fInvalid))\n                continue;\n\n            int64 nTxFees = tx.GetValueIn(mapInputs)-tx.GetValueOut();\n            if (nTxFees < nMinFee)\n                continue;\n\n            nTxSigOps += tx.GetP2SHSigOpCount(mapInputs);\n            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n                continue;\n\n            if (!tx.ConnectInputs(mapInputs, mapTestPoolTmp, CDiskTxPos(1,1,1), pindexPrev, false, true))\n                continue;\n            mapTestPoolTmp[tx.GetHash()] = CTxIndex(CDiskTxPos(1,1,1), tx.vout.size());\n            swap(mapTestPool, mapTestPoolTmp);\n\n            // Added\n            pblock->vtx.push_back(tx);\n            nBlockSize += nTxSize;\n            ++nBlockTx;\n            nBlockSigOps += nTxSigOps;\n            nFees += nTxFees;\n\n            // Add transactions that depend on this one to the priority queue\n            uint256 hash = tx.GetHash();\n            if (mapDependers.count(hash))\n            {\n                BOOST_FOREACH(COrphan* porphan, mapDependers[hash])\n                {\n                    if (!porphan->setDependsOn.empty())\n                    {\n                        porphan->setDependsOn.erase(hash);\n                        if (porphan->setDependsOn.empty())\n                            mapPriority.insert(make_pair(-porphan->dPriority, porphan->ptx));\n                    }\n                }\n            }\n        }\n\n        nLastBlockTx = nBlockTx;\n        nLastBlockSize = nBlockSize;\n        printf(\"CreateNewBlock() : total size %lu\\n\", nBlockSize);\n\n    }\n\n    pblock->vtx[0].vout[0].nValue = GetBlockValue(pindexPrev->nHeight+1, nFees);\n\n    // Fill in header\n    pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\n    pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n    pblock->UpdateTime(pindexPrev);\n    pblock->nBits          = GetNextWorkRequired(pindexPrev, pblock.get());\n    pblock->nNonce         = 0;\n\n    return pblock.release();\n}\n\n\nvoid IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int& nExtraNonce)\n{\n    // Update nExtraNonce\n    static uint256 hashPrevBlock;\n    if (hashPrevBlock != pblock->hashPrevBlock)\n    {\n        nExtraNonce = 0;\n        hashPrevBlock = pblock->hashPrevBlock;\n    }\n    ++nExtraNonce;\n\n    /* Blocks v1: nTime in coin base\n     * Blocks v2: nHeight in coin base */\n    uint nHeight = pindexPrev->nHeight + 1;\n    pblock->vtx[0].vin[0].scriptSig = (CScript() << nHeight << CBigNum(nExtraNonce)) + COINBASE_FLAGS;\n    assert(pblock->vtx[0].vin[0].scriptSig.size() <= 100);\n\n    pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n}\n\n/* Prepares a block header for transmission using RPC getwork */\nvoid FormatDataBuffer(CBlock *pblock, uint *pdata) {\n    uint i;\n\n    struct {\n        int nVersion;\n        uint256 hashPrevBlock;\n        uint256 hashMerkleRoot;\n        uint nTime;\n        uint nBits;\n        uint nNonce;\n    } data;\n\n    data.nVersion       = pblock->nVersion;\n    data.hashPrevBlock  = pblock->hashPrevBlock;\n    data.hashMerkleRoot = pblock->hashMerkleRoot;\n    data.nTime          = pblock->nTime;\n    data.nBits          = pblock->nBits;\n    data.nNonce         = pblock->nNonce;\n\n    if(fNeoScrypt) {\n        /* Copy the LE data */\n        for(i = 0; i < 20; i++)\n          pdata[i] = ((uint *) &data)[i];\n    } else {\n        /* Block header size in bits */\n        pdata[31] = 640;\n        /* Convert LE to BE and copy */\n        for(i = 0; i < 20; i++)\n          pdata[i] = ByteReverse(((uint *) &data)[i]);\n        /* Erase the remaining part */\n        for(i = 20; i < 31; i++)\n          pdata[i] = 0;\n    }\n}\n\n\nbool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey) {\n    uint256 hash = pblock->GetPoWHash();\n    uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n\n    if(hash > hashTarget)\n      return(false);\n\n    //// debug print\n    printf(\"PhoenixcoinMiner:\\n\");\n    printf(\"proof-of-work found  \\n  hash: %s  \\ntarget: %s\\n\", hash.GetHex().c_str(), hashTarget.GetHex().c_str());\n    pblock->print();\n    printf(\"generated %s\\n\", FormatMoney(pblock->vtx[0].vout[0].nValue).c_str());\n\n    // Found a solution\n    {\n        LOCK(cs_main);\n        if (pblock->hashPrevBlock != hashBestChain)\n            return error(\"PhoenixcoinMiner : generated block is stale\");\n\n        // Remove key from key pool\n        reservekey.KeepKey();\n\n        // Track how many getdata requests this block gets\n        {\n            LOCK(wallet.cs_wallet);\n            wallet.mapRequestCount[pblock->GetHash()] = 0;\n        }\n\n        // Process this block the same as if we had received it from another node\n        if (!ProcessBlock(NULL, pblock))\n            return error(\"PhoenixcoinMiner : ProcessBlock, block not accepted\");\n    }\n\n    return true;\n}\n\nvoid static ThreadPhoenixcoinMiner(void* parg);\n\nstatic bool fLimitProcessors = false;\nstatic int nLimitProcessors = -1;\n\nvoid static PhoenixcoinMiner(CWallet *pwallet)\n{\n    printf(\"PhoenixcoinMiner started\\n\");\n    SetThreadPriority(THREAD_PRIORITY_LOWEST);\n\n    // Make this thread recognisable as the mining thread\n    RenameThread(\"pxc-miner\");\n\n    // Each thread has its own key and counter\n    CReserveKey reservekey(pwallet);\n    unsigned int nExtraNonce = 0;\n\n    while (fGenerateCoins)\n    {\n        if (fShutdown)\n            return;\n        while (vNodes.empty() || IsInitialBlockDownload())\n        {\n            Sleep(1000);\n            if (fShutdown)\n                return;\n            if (!fGenerateCoins)\n                return;\n        }\n\n\n        //\n        // Create new block\n        //\n        unsigned int nTransactionsUpdatedLast = nTransactionsUpdated;\n        CBlockIndex* pindexPrev = pindexBest;\n\n        auto_ptr<CBlock> pblock(CreateNewBlock(reservekey));\n\n        if (!pblock.get())\n            return;\n\n        IncrementExtraNonce(pblock.get(), pindexPrev, nExtraNonce);\n\n        printf(\"Running PhoenixcoinMiner with %d transactions in block\\n\", pblock->vtx.size());\n\n        //\n        // Search\n        //\n        int64 nStart = GetTime();\n        uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n\n        while(true) {\n            unsigned int nHashesDone = 0;\n            uint profile = fNeoScrypt ? 0x0 : 0x3;\n            uint256 hash;\n\n            while(true) {\n                neoscrypt((uchar *) &pblock->nVersion, (uchar *) &hash, profile);\n                if(hash <= hashTarget) {\n                    // Found a solution\n                    SetThreadPriority(THREAD_PRIORITY_NORMAL);\n                    CheckWork(pblock.get(), *pwalletMain, reservekey);\n                    SetThreadPriority(THREAD_PRIORITY_LOWEST);\n                    break;\n                }\n                pblock->nNonce += 1;\n                nHashesDone += 1;\n                if ((pblock->nNonce & 0xFF) == 0)\n                    break;\n            }\n\n            // Meter hashes/sec\n            static int64 nHashCounter;\n            if (nHPSTimerStart == 0)\n            {\n                nHPSTimerStart = GetTimeMillis();\n                nHashCounter = 0;\n            }\n            else\n                nHashCounter += nHashesDone;\n            if (GetTimeMillis() - nHPSTimerStart > 4000)\n            {\n                static CCriticalSection cs;\n                {\n                    LOCK(cs);\n                    if (GetTimeMillis() - nHPSTimerStart > 4000)\n                    {\n                        dHashesPerSec = 1000.0 * nHashCounter / (GetTimeMillis() - nHPSTimerStart);\n                        nHPSTimerStart = GetTimeMillis();\n                        nHashCounter = 0;\n                        string strStatus = strprintf(\"    %.0f khash/s\", dHashesPerSec/1000.0);\n                        static int64 nLogTime;\n                        if (GetTime() - nLogTime > 30 * 60)\n                        {\n                            nLogTime = GetTime();\n                            printf(\"%s \", DateTimeStrFormat(\"%x %H:%M\", GetTime()).c_str());\n                            printf(\"hashmeter %3d CPUs %6.0f khash/s\\n\", vnThreadsRunning[THREAD_MINER], dHashesPerSec/1000.0);\n                        }\n                    }\n                }\n            }\n\n            // Check for stop or if block needs to be rebuilt\n            if (fShutdown)\n                return;\n            if (!fGenerateCoins)\n                return;\n            if (fLimitProcessors && vnThreadsRunning[THREAD_MINER] > nLimitProcessors)\n                return;\n            if (vNodes.empty())\n                break;\n            if (pblock->nNonce >= 0xffff0000)\n                break;\n            if (nTransactionsUpdated != nTransactionsUpdatedLast && GetTime() - nStart > 60)\n                break;\n            if (pindexPrev != pindexBest)\n                break;\n\n            pblock->UpdateTime(pindexPrev);\n\n            if(fTestNet)\n                /* UpdateTime() can change work required on testnet */\n                hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n        }\n    }\n}\n\nvoid static ThreadPhoenixcoinMiner(void* parg)\n{\n    CWallet* pwallet = (CWallet*)parg;\n    try\n    {\n        vnThreadsRunning[THREAD_MINER]++;\n        PhoenixcoinMiner(pwallet);\n        vnThreadsRunning[THREAD_MINER]--;\n    }\n    catch (std::exception& e) {\n        vnThreadsRunning[THREAD_MINER]--;\n        PrintException(&e, \"ThreadPhoenixcoinMiner()\");\n    } catch (...) {\n        vnThreadsRunning[THREAD_MINER]--;\n        PrintException(NULL, \"ThreadPhoenixcoinMiner()\");\n    }\n    nHPSTimerStart = 0;\n    if (vnThreadsRunning[THREAD_MINER] == 0)\n        dHashesPerSec = 0;\n    printf(\"ThreadPhoenixcoinMiner exiting, %d threads remaining\\n\", vnThreadsRunning[THREAD_MINER]);\n}\n\n\nvoid GenerateCoins(bool fGenerate, CWallet* pwallet)\n{\n    fGenerateCoins = fGenerate;\n    nLimitProcessors = GetArg(\"-genproclimit\", -1);\n    if (nLimitProcessors == 0)\n        fGenerateCoins = false;\n    fLimitProcessors = (nLimitProcessors != -1);\n\n    if (fGenerate)\n    {\n        int nProcessors = boost::thread::hardware_concurrency();\n        printf(\"%d processors\\n\", nProcessors);\n        if (nProcessors < 1)\n            nProcessors = 1;\n        if (fLimitProcessors && nProcessors > nLimitProcessors)\n            nProcessors = nLimitProcessors;\n        int nAddThreads = nProcessors - vnThreadsRunning[THREAD_MINER];\n        printf(\"Starting %d PhoenixcoinMiner threads\\n\", nAddThreads);\n        for (int i = 0; i < nAddThreads; i++)\n        {\n            if (!CreateThread(ThreadPhoenixcoinMiner, pwallet))\n                printf(\"Error: CreateThread(ThreadPhoenixcoinMiner) failed\\n\");\n            Sleep(10);\n        }\n    }\n}\n", "// Copyright (c) 2009-2010 Satoshi Nakamoto\n// Copyright (c) 2009-2012 The Bitcoin developers\n// Copyright (c) 2011-2013 Litecoin Developers\n// Copyright (c) 2013-2014 Phoenixcoin Developers\n// Distributed under the MIT/X11 software license, see the accompanying\n// file LICENCE or http://www.opensource.org/licenses/mit-license.php\n\n#ifndef BITCOIN_MAIN_H\n#define BITCOIN_MAIN_H\n\n#include \"bignum.h\"\n#include \"net.h\"\n#include \"key.h\"\n#include \"script.h\"\n#include \"db.h\"\n#include \"neoscrypt.h\"\n\n#include <list>\n\nclass CWallet;\nclass CBlock;\nclass CBlockIndex;\nclass CKeyItem;\nclass CReserveKey;\n\nclass CAddress;\nclass CInv;\nclass CRequestTracker;\nclass CNode;\n\n/* Maturity threshold for PoW base transactions, in blocks (confirmations) */\nextern int nBaseMaturity;\nstatic const int BASE_MATURITY = 100;\nstatic const int BASE_MATURITY_TESTNET = 100;\n/* Offset for the above to allow safe network propagation, in blocks (confirmations) */\nstatic const int BASE_MATURITY_OFFSET = 1;\n/* Maturity threshold for regular transactions, in blocks (confirmations) */\nstatic const int TX_MATURITY = 6;\n\n// The max. allowed size for a serialised block, in bytes\nstatic const uint MAX_BLOCK_SIZE = 524288;\n// The max. allowed size for a mined block, in bytes\nstatic const uint MAX_BLOCK_SIZE_GEN = (MAX_BLOCK_SIZE >> 1);\n// The max. allowed number of signature check operations per block\nstatic const uint MAX_BLOCK_SIGOPS = (MAX_BLOCK_SIZE >> 6);\n// The max. number of orphan transactions kept in memory\nstatic const uint MAX_ORPHAN_TRANSACTIONS = (MAX_BLOCK_SIZE >> 8);\n/* The current time frame of block limiter */\nstatic const int64 BLOCK_LIMITER_TIME = 120;\n// The min. transaction fee (0.1 PXC) if required\nstatic const int64 MIN_TX_FEE = 10000000;\n// Fees below this value (0.05 PXC) are considered absent while relaying\nstatic const int64 MIN_RELAY_TX_FEE = 5000000;\n// The dust threshold (0.01 PXC)\nstatic const int64 TX_DUST = 1000000;\n// The max. amount for a single transaction;\n// set to ~10% of the total coin supply in our case (10 million PXC)\nstatic const int64 MAX_MONEY = 10000000 * COIN;\ninline bool MoneyRange(int64 nValue) { return (nValue >= 0 && nValue <= MAX_MONEY); }\n// Threshold for nLockTime: below this value it is interpreted as block number, otherwise as UNIX timestamp.\nstatic const unsigned int LOCKTIME_THRESHOLD = 500000000; // Tue Nov  5 00:53:20 1985 UTC\n#ifdef USE_UPNP\nstatic const int fHaveUPnP = true;\n#else\nstatic const int fHaveUPnP = false;\n#endif\n\n\n/* Hard & soft fork related data */\nstatic const int nForkOne   = 46500;   /* the 1st hard fork */\nstatic const int nForkTwo   = 69444;   /* the 2nd hard fork */\nstatic const int nForkThree = 74100;   /* the 3rd hard fork */\nstatic const int nForkFour  = 154000;  /* the 4th hard fork */\nstatic const int nForkFive  = 400000;  /* the 5th hard fork */\n\nstatic const int nSoftForkOne   = 270000;\nstatic const int nSoftForkTwo   = 340000;\n\nstatic const int nTestnetForkOne   = 600;\nstatic const int nTestnetForkTwo   = 3600;\n\nstatic const int nTestnetSoftForkOne   = 3400;\nstatic const int nTestnetSoftForkTwo   = 3500;\n\nstatic const uint nSwitchV2            = 1406851200;   /* 01 Aug 2014 00:00:00 GMT */\nstatic const uint nTestnetSwitchV2     = 1404777600;   /* 08 Jul 2014 00:00:00 GMT */\n\nstatic const int nTargetSpacingZero    = 90;  /* 1.5 minutes */\nstatic const int nTargetSpacingOne     = nTargetSpacingZero;\nstatic const int nTargetSpacingTwo     = 50;  /* 50 seconds */\nstatic const int nTargetSpacingThree   = 45;  /* 45 seconds */\nstatic const int nTargetSpacingFour    = 90;  /* 1.5 minutes */\n\nstatic const int nTargetTimespanZero   = 2400 * nTargetSpacingZero;  /* 60 hours */\nstatic const int nTargetTimespanOne    = 600  * nTargetSpacingOne;   /* 15 hours */\nstatic const int nTargetTimespanTwo    = 108  * nTargetSpacingTwo;   /* 1.5 hours */\nstatic const int nTargetTimespanThree  = 126  * nTargetSpacingThree; /* 1.575 hours */\nstatic const int nTargetTimespanFour   = 20   * nTargetSpacingFour;  /* 0.5 hours */\n\n\nextern CScript COINBASE_FLAGS;\n\nextern CCriticalSection cs_main;\nextern std::map<uint256, CBlockIndex*> mapBlockIndex;\nextern uint256 hashGenesisBlock;\nextern CBlockIndex* pindexGenesisBlock;\nextern int nBestHeight;\nextern CBigNum bnBestChainWork;\nextern CBigNum bnBestInvalidWork;\nextern uint256 hashBestChain;\nextern CBlockIndex* pindexBest;\nextern unsigned int nTransactionsUpdated;\nextern uint64 nLastBlockTx;\nextern uint64 nLastBlockSize;\nextern const std::string strMessageMagic;\nextern double dHashesPerSec;\nextern int64 nHPSTimerStart;\nextern int64 nTimeBestReceived;\nextern CCriticalSection cs_setpwalletRegistered;\nextern std::set<CWallet*> setpwalletRegistered;\nextern std::map<uint256, CBlock*> mapOrphanBlocks;\nextern unsigned char pchMessageStart[4];\n\n// Settings\nextern int64 nTransactionFee;\nextern int64 nMinimumInputValue;\n\n// Minimum disk space required - used in CheckDiskSpace()\nstatic const uint64 nMinDiskSpace = 52428800;\n\n\nclass CReserveKey;\nclass CTxDB;\nclass CTxIndex;\n\nvoid RegisterWallet(CWallet* pwalletIn);\nvoid UnregisterWallet(CWallet* pwalletIn);\nvoid SyncWithWallets(const CTransaction& tx, const CBlock* pblock = NULL, bool fUpdate = false);\nbool ProcessBlock(CNode* pfrom, CBlock* pblock);\nbool CheckDiskSpace(uint64 nAdditionalBytes=0);\nFILE* OpenBlockFile(unsigned int nFile, unsigned int nBlockPos, const char* pszMode=\"rb\");\nFILE* AppendBlockFile(unsigned int& nFileRet);\nbool LoadBlockIndex(bool fAllowNew=true);\nvoid PrintBlockTree();\nbool ProcessMessages(CNode* pfrom);\nbool SendMessages(CNode* pto, bool fSendTrickle);\nbool LoadExternalBlockFile(FILE* fileIn);\nvoid GenerateCoins(bool fGenerate, CWallet* pwallet);\nCBlock* CreateNewBlock(CReserveKey& reservekey);\nvoid IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int& nExtraNonce);\nvoid FormatDataBuffer(CBlock *pblock, uint *pdata);\nbool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey);\nbool CheckProofOfWork(uint256 hash, unsigned int nBits);\nint GetNumBlocksOfPeers();\nbool IsInitialBlockDownload();\nstd::string GetWarnings(std::string strFor);\nbool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock);\nint64 GetBlockValue(int nHeight, int64 nFees);\nvoid ResendWalletTransactions(bool fForce);\n\n\nbool GetWalletFile(CWallet* pwallet, std::string &strWalletFileOut);\n\n/** Position on disk for a particular transaction. */\nclass CDiskTxPos\n{\npublic:\n    unsigned int nFile;\n    unsigned int nBlockPos;\n    unsigned int nTxPos;\n\n    CDiskTxPos()\n    {\n        SetNull();\n    }\n\n    CDiskTxPos(unsigned int nFileIn, unsigned int nBlockPosIn, unsigned int nTxPosIn)\n    {\n        nFile = nFileIn;\n        nBlockPos = nBlockPosIn;\n        nTxPos = nTxPosIn;\n    }\n\n    IMPLEMENT_SERIALIZE( READWRITE(FLATDATA(*this)); )\n    void SetNull() { nFile = (unsigned int) -1; nBlockPos = 0; nTxPos = 0; }\n    bool IsNull() const { return (nFile == (unsigned int) -1); }\n\n    friend bool operator==(const CDiskTxPos& a, const CDiskTxPos& b)\n    {\n        return (a.nFile     == b.nFile &&\n                a.nBlockPos == b.nBlockPos &&\n                a.nTxPos    == b.nTxPos);\n    }\n\n    friend bool operator!=(const CDiskTxPos& a, const CDiskTxPos& b)\n    {\n        return !(a == b);\n    }\n\n    std::string ToString() const\n    {\n        if (IsNull())\n            return \"null\";\n        else\n            return strprintf(\"(nFile=%d, nBlockPos=%d, nTxPos=%d)\", nFile, nBlockPos, nTxPos);\n    }\n\n    void print() const\n    {\n        printf(\"%s\", ToString().c_str());\n    }\n};\n\n\n\n/** An inpoint - a combination of a transaction and an index n into its vin */\nclass CInPoint\n{\npublic:\n    CTransaction* ptx;\n    unsigned int n;\n\n    CInPoint() { SetNull(); }\n    CInPoint(CTransaction* ptxIn, unsigned int nIn) { ptx = ptxIn; n = nIn; }\n    void SetNull() { ptx = NULL; n = (unsigned int) -1; }\n    bool IsNull() const { return (ptx == NULL && n == (unsigned int) -1); }\n};\n\n\n\n/** An outpoint - a combination of a transaction hash and an index n into its vout */\nclass COutPoint\n{\npublic:\n    uint256 hash;\n    unsigned int n;\n\n    COutPoint() { SetNull(); }\n    COutPoint(uint256 hashIn, unsigned int nIn) { hash = hashIn; n = nIn; }\n    IMPLEMENT_SERIALIZE( READWRITE(FLATDATA(*this)); )\n    void SetNull() { hash = 0; n = (unsigned int) -1; }\n    bool IsNull() const { return (hash == 0 && n == (unsigned int) -1); }\n\n    friend bool operator<(const COutPoint& a, const COutPoint& b)\n    {\n        return (a.hash < b.hash || (a.hash == b.hash && a.n < b.n));\n    }\n\n    friend bool operator==(const COutPoint& a, const COutPoint& b)\n    {\n        return (a.hash == b.hash && a.n == b.n);\n    }\n\n    friend bool operator!=(const COutPoint& a, const COutPoint& b)\n    {\n        return !(a == b);\n    }\n\n    std::string ToString() const\n    {\n        return strprintf(\"COutPoint(%s, %d)\", hash.ToString().substr(0,10).c_str(), n);\n    }\n\n    void print() const\n    {\n        printf(\"%s\\n\", ToString().c_str());\n    }\n};\n\n\n\n\n/** An input of a transaction.  It contains the location of the previous\n * transaction's output that it claims and a signature that matches the\n * output's public key.\n */\nclass CTxIn\n{\npublic:\n    COutPoint prevout;\n    CScript scriptSig;\n    unsigned int nSequence;\n\n    CTxIn()\n    {\n        nSequence = std::numeric_limits<unsigned int>::max();\n    }\n\n    explicit CTxIn(COutPoint prevoutIn, CScript scriptSigIn=CScript(), unsigned int nSequenceIn=std::numeric_limits<unsigned int>::max())\n    {\n        prevout = prevoutIn;\n        scriptSig = scriptSigIn;\n        nSequence = nSequenceIn;\n    }\n\n    CTxIn(uint256 hashPrevTx, unsigned int nOut, CScript scriptSigIn=CScript(), unsigned int nSequenceIn=std::numeric_limits<unsigned int>::max())\n    {\n        prevout = COutPoint(hashPrevTx, nOut);\n        scriptSig = scriptSigIn;\n        nSequence = nSequenceIn;\n    }\n\n    IMPLEMENT_SERIALIZE\n    (\n        READWRITE(prevout);\n        READWRITE(scriptSig);\n        READWRITE(nSequence);\n    )\n\n    bool IsFinal() const\n    {\n        return (nSequence == std::numeric_limits<unsigned int>::max());\n    }\n\n    friend bool operator==(const CTxIn& a, const CTxIn& b)\n    {\n        return (a.prevout   == b.prevout &&\n                a.scriptSig == b.scriptSig &&\n                a.nSequence == b.nSequence);\n    }\n\n    friend bool operator!=(const CTxIn& a, const CTxIn& b)\n    {\n        return !(a == b);\n    }\n\n    std::string ToString() const\n    {\n        std::string str;\n        str += \"CTxIn(\";\n        str += prevout.ToString();\n        if (prevout.IsNull())\n            str += strprintf(\", coinbase %s\", HexStr(scriptSig).c_str());\n        else\n            str += strprintf(\", scriptSig=%s\", scriptSig.ToString().substr(0,24).c_str());\n        if (nSequence != std::numeric_limits<unsigned int>::max())\n            str += strprintf(\", nSequence=%u\", nSequence);\n        str += \")\";\n        return str;\n    }\n\n    void print() const\n    {\n        printf(\"%s\\n\", ToString().c_str());\n    }\n};\n\n\n\n\n/** An output of a transaction.  It contains the public key that the next input\n * must be able to sign with to claim it.\n */\nclass CTxOut\n{\npublic:\n    int64 nValue;\n    CScript scriptPubKey;\n\n    CTxOut()\n    {\n        SetNull();\n    }\n\n    CTxOut(int64 nValueIn, CScript scriptPubKeyIn)\n    {\n        nValue = nValueIn;\n        scriptPubKey = scriptPubKeyIn;\n    }\n\n    IMPLEMENT_SERIALIZE\n    (\n        READWRITE(nValue);\n        READWRITE(scriptPubKey);\n    )\n\n    void SetNull()\n    {\n        nValue = -1;\n        scriptPubKey.clear();\n    }\n\n    bool IsNull()\n    {\n        return (nValue == -1);\n    }\n\n    uint256 GetHash() const\n    {\n        return SerializeHash(*this);\n    }\n\n    friend bool operator==(const CTxOut& a, const CTxOut& b)\n    {\n        return (a.nValue       == b.nValue &&\n                a.scriptPubKey == b.scriptPubKey);\n    }\n\n    friend bool operator!=(const CTxOut& a, const CTxOut& b)\n    {\n        return !(a == b);\n    }\n\n    std::string ToString() const\n    {\n        if (scriptPubKey.size() < 6)\n            return \"CTxOut(error)\";\n        return strprintf(\"CTxOut(nValue=%\"PRI64d\".%08\"PRI64d\", scriptPubKey=%s)\", nValue / COIN, nValue % COIN, scriptPubKey.ToString().substr(0,30).c_str());\n    }\n\n    void print() const\n    {\n        printf(\"%s\\n\", ToString().c_str());\n    }\n};\n\n\n\n\nenum GetMinFee_mode\n{\n    GMF_BLOCK,\n    GMF_RELAY,\n    GMF_SEND,\n};\n\ntypedef std::map<uint256, std::pair<CTxIndex, CTransaction> > MapPrevTx;\n\n/** The basic transaction that is broadcasted on the network and contained in\n * blocks.  A transaction can contain multiple inputs and outputs.\n */\nclass CTransaction\n{\npublic:\n    static const int CURRENT_VERSION=1;\n    int nVersion;\n    std::vector<CTxIn> vin;\n    std::vector<CTxOut> vout;\n    unsigned int nLockTime;\n\n    // Denial-of-service detection:\n    mutable int nDoS;\n    bool DoS(int nDoSIn, bool fIn) const { nDoS += nDoSIn; return fIn; }\n\n    CTransaction()\n    {\n        SetNull();\n    }\n\n    IMPLEMENT_SERIALIZE\n    (\n        READWRITE(this->nVersion);\n        nVersion = this->nVersion;\n        READWRITE(vin);\n        READWRITE(vout);\n        READWRITE(nLockTime);\n    )\n\n    void SetNull()\n    {\n        nVersion = CTransaction::CURRENT_VERSION;\n        vin.clear();\n        vout.clear();\n        nLockTime = 0;\n        nDoS = 0;  // Denial-of-service prevention\n    }\n\n    bool IsNull() const\n    {\n        return (vin.empty() && vout.empty());\n    }\n\n    uint256 GetHash() const\n    {\n        return SerializeHash(*this);\n    }\n\n    bool IsFinal(int nBlockHeight=0, int64 nBlockTime=0) const\n    {\n        // Time based nLockTime implemented in 0.1.6\n        if (nLockTime == 0)\n            return true;\n        if (nBlockHeight == 0)\n            nBlockHeight = nBestHeight;\n        if (nBlockTime == 0)\n            nBlockTime = GetAdjustedTime();\n        if ((int64)nLockTime < ((int64)nLockTime < LOCKTIME_THRESHOLD ? (int64)nBlockHeight : nBlockTime))\n            return true;\n        BOOST_FOREACH(const CTxIn& txin, vin)\n            if (!txin.IsFinal())\n                return false;\n        return true;\n    }\n\n    bool IsNewerThan(const CTransaction& old) const\n    {\n        if (vin.size() != old.vin.size())\n            return false;\n        for (unsigned int i = 0; i < vin.size(); i++)\n            if (vin[i].prevout != old.vin[i].prevout)\n                return false;\n\n        bool fNewer = false;\n        unsigned int nLowest = std::numeric_limits<unsigned int>::max();\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            if (vin[i].nSequence != old.vin[i].nSequence)\n            {\n                if (vin[i].nSequence <= nLowest)\n                {\n                    fNewer = false;\n                    nLowest = vin[i].nSequence;\n                }\n                if (old.vin[i].nSequence < nLowest)\n                {\n                    fNewer = true;\n                    nLowest = old.vin[i].nSequence;\n                }\n            }\n        }\n        return fNewer;\n    }\n\n    bool IsCoinBase() const\n    {\n        return (vin.size() == 1 && vin[0].prevout.IsNull());\n    }\n\n    /** Check for standard transaction types\n        @return True if all outputs (scriptPubKeys) use only standard transaction forms\n    */\n    bool IsStandard() const;\n\n    /** Check for standard transaction types\n        @param[in] mapInputs\tMap of previous transactions that have outputs we're spending\n        @return True if all inputs (scriptSigs) use only standard transaction forms\n        @see CTransaction::FetchInputs\n    */\n    bool AreInputsStandard(const MapPrevTx& mapInputs) const;\n\n    /** Count ECDSA signature operations the old-fashioned (pre-0.6) way\n        @return number of sigops this transaction's outputs will produce when spent\n        @see CTransaction::FetchInputs\n    */\n    unsigned int GetLegacySigOpCount() const;\n\n    /** Count ECDSA signature operations in pay-to-script-hash inputs.\n\n        @param[in] mapInputs\tMap of previous transactions that have outputs we're spending\n        @return maximum number of sigops required to validate this transaction's inputs\n        @see CTransaction::FetchInputs\n     */\n    unsigned int GetP2SHSigOpCount(const MapPrevTx& mapInputs) const;\n\n    /** Amount of bitcoins spent by this transaction.\n        @return sum of all outputs (note: does not include fees)\n     */\n    int64 GetValueOut() const\n    {\n        int64 nValueOut = 0;\n        BOOST_FOREACH(const CTxOut& txout, vout)\n        {\n            nValueOut += txout.nValue;\n            if (!MoneyRange(txout.nValue) || !MoneyRange(nValueOut))\n                throw std::runtime_error(\"CTransaction::GetValueOut() : value out of range\");\n        }\n        return nValueOut;\n    }\n\n    /** Amount of bitcoins coming in to this transaction\n        Note that lightweight clients may not know anything besides the hash of previous transactions,\n        so may not be able to calculate this.\n\n        @param[in] mapInputs\tMap of previous transactions that have outputs we're spending\n        @return\tSum of value of all inputs (scriptSigs)\n        @see CTransaction::FetchInputs\n     */\n    int64 GetValueIn(const MapPrevTx& mapInputs) const;\n\n    static bool AllowFree(double dPriority)\n    {\n        // High priority transactions are exempt of mandatory fees usually\n        // Phoenixcoin: 960 blocks per day target, priority boundary is 1 PXC day / 250 bytes\n        return dPriority > COIN * 960 / 250;\n    }\n\n    int64 GetMinFee(unsigned int nTxSize, bool fAllowFree, enum GetMinFee_mode mode) const {\n\n        // Base fee is either MIN_TX_FEE or MIN_RELAY_TX_FEE\n        int64 nBaseFee = (mode == GMF_RELAY) ? MIN_RELAY_TX_FEE : MIN_TX_FEE;\n\n        unsigned int nNewBlockSize = (mode == GMF_SEND) ? nTxSize : 1000 + nTxSize;\n        // Add a base fee per every 1000 bytes of transaction data\n        int64 nMinFee = (1 + (int64)nTxSize / 1000) * nBaseFee;\n\n        if(fAllowFree) {\n            if(mode == GMF_SEND) {\n                // Limit size of free high priority transactions\n                if(nTxSize < 2000) nMinFee = 0;\n            } else {\n                // GMF_BLOCK, GMF_RELAY:\n                // Limit block space for free transactions\n                if(nNewBlockSize < 16000) nMinFee = 0;\n            }\n        }\n\n        // Dust spam filter: require a base fee for any micro output\n        BOOST_FOREACH(const CTxOut& txout, vout)\n          if(txout.nValue < TX_DUST) nMinFee += nBaseFee;\n\n        // Raise the price as the block approaches full\n        if((mode != GMF_SEND) && (nNewBlockSize >= MAX_BLOCK_SIZE_GEN/2)) {\n            if(nNewBlockSize >= MAX_BLOCK_SIZE_GEN) return MAX_MONEY;\n            nMinFee *= MAX_BLOCK_SIZE_GEN / (MAX_BLOCK_SIZE_GEN - nNewBlockSize);\n            if(!MoneyRange(nMinFee)) nMinFee = MAX_MONEY;\n        }\n\n        return nMinFee;\n    }\n\n    bool ReadFromDisk(CDiskTxPos pos, FILE** pfileRet=NULL)\n    {\n        CAutoFile filein = CAutoFile(OpenBlockFile(pos.nFile, 0, pfileRet ? \"rb+\" : \"rb\"), SER_DISK, CLIENT_VERSION);\n        if (!filein)\n            return error(\"CTransaction::ReadFromDisk() : OpenBlockFile failed\");\n\n        // Read transaction\n        if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n            return error(\"CTransaction::ReadFromDisk() : fseek failed\");\n\n        try {\n            filein >> *this;\n        }\n        catch (std::exception &e) {\n            return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n        }\n\n        // Return file pointer\n        if (pfileRet)\n        {\n            if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n                return error(\"CTransaction::ReadFromDisk() : second fseek failed\");\n            *pfileRet = filein.release();\n        }\n        return true;\n    }\n\n    friend bool operator==(const CTransaction& a, const CTransaction& b)\n    {\n        return (a.nVersion  == b.nVersion &&\n                a.vin       == b.vin &&\n                a.vout      == b.vout &&\n                a.nLockTime == b.nLockTime);\n    }\n\n    friend bool operator!=(const CTransaction& a, const CTransaction& b)\n    {\n        return !(a == b);\n    }\n\n\n    std::string ToString() const\n    {\n        std::string str;\n        str += strprintf(\"CTransaction(hash=%s, ver=%d, vin.size=%d, vout.size=%d, nLockTime=%d)\\n\",\n            GetHash().ToString().substr(0,10).c_str(),\n            nVersion,\n            vin.size(),\n            vout.size(),\n            nLockTime);\n        for (unsigned int i = 0; i < vin.size(); i++)\n            str += \"    \" + vin[i].ToString() + \"\\n\";\n        for (unsigned int i = 0; i < vout.size(); i++)\n            str += \"    \" + vout[i].ToString() + \"\\n\";\n        return str;\n    }\n\n    void print() const\n    {\n        printf(\"%s\", ToString().c_str());\n    }\n\n\n    bool ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet);\n    bool ReadFromDisk(CTxDB& txdb, COutPoint prevout);\n    bool ReadFromDisk(COutPoint prevout);\n    bool DisconnectInputs(CTxDB& txdb);\n\n    /** Fetch from memory and/or disk. inputsRet keys are transaction hashes.\n\n     @param[in] txdb\tTransaction database\n     @param[in] mapTestPool\tList of pending changes to the transaction index database\n     @param[in] fBlock\tTrue if being called to add a new best-block to the chain\n     @param[in] fMiner\tTrue if being called by CreateNewBlock\n     @param[out] inputsRet\tPointers to this transaction's inputs\n     @param[out] fInvalid\treturns true if transaction is invalid\n     @return\tReturns true if all inputs are in txdb or mapTestPool\n     */\n    bool FetchInputs(CTxDB& txdb, const std::map<uint256, CTxIndex>& mapTestPool,\n                     bool fBlock, bool fMiner, MapPrevTx& inputsRet, bool& fInvalid);\n\n    /** Sanity check previous transactions, then, if all checks succeed,\n        mark them as spent by this transaction.\n\n        @param[in] inputs\tPrevious transactions (from FetchInputs)\n        @param[out] mapTestPool\tKeeps track of inputs that need to be updated on disk\n        @param[in] posThisTx\tPosition of this transaction on disk\n        @param[in] pindexBlock\n        @param[in] fBlock\ttrue if called from ConnectBlock\n        @param[in] fMiner\ttrue if called from CreateNewBlock\n        @param[in] fStrictPayToScriptHash\ttrue if fully validating p2sh transactions\n        @return Returns true if all checks succeed\n     */\n    bool ConnectInputs(MapPrevTx inputs,\n                       std::map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n                       const CBlockIndex* pindexBlock, bool fBlock, bool fMiner, bool fStrictPayToScriptHash=true);\n    bool ClientConnectInputs();\n    bool CheckTransaction() const;\n    bool AcceptToMemoryPool(CTxDB &txdb, bool fCheckInputs=true, bool fLimitFree=true,\n      bool *pfMissingInputs=NULL);\n\nprotected:\n    const CTxOut& GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const;\n};\n\n\n\n\n\n/** A transaction with a merkle branch linking it to the block chain. */\nclass CMerkleTx : public CTransaction\n{\npublic:\n    uint256 hashBlock;\n    std::vector<uint256> vMerkleBranch;\n    int nIndex;\n\n    // memory only\n    mutable bool fMerkleVerified;\n\n\n    CMerkleTx()\n    {\n        Init();\n    }\n\n    CMerkleTx(const CTransaction& txIn) : CTransaction(txIn)\n    {\n        Init();\n    }\n\n    void Init()\n    {\n        hashBlock = 0;\n        nIndex = -1;\n        fMerkleVerified = false;\n    }\n\n\n    IMPLEMENT_SERIALIZE\n    (\n        nSerSize += SerReadWrite(s, *(CTransaction*)this, nType, nVersion, ser_action);\n        nVersion = this->nVersion;\n        READWRITE(hashBlock);\n        READWRITE(vMerkleBranch);\n        READWRITE(nIndex);\n    )\n\n\n    int SetMerkleBranch(const CBlock* pblock=NULL);\n    int GetDepthInMainChain(CBlockIndex* &pindexRet) const;\n    int GetDepthInMainChain() const { CBlockIndex *pindexRet; return GetDepthInMainChain(pindexRet); }\n    bool IsInMainChain() const { return GetDepthInMainChain() > 0; }\n    int GetBlocksToMaturity() const;\n    bool AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs=true, bool fLimitFree=true);\n    bool AcceptToMemoryPool();\n};\n\n\n\n\n/**  A txdb record that contains the disk location of a transaction and the\n * locations of transactions that spend its outputs.  vSpent is really only\n * used as a flag, but having the location is very helpful for debugging.\n */\nclass CTxIndex\n{\npublic:\n    CDiskTxPos pos;\n    std::vector<CDiskTxPos> vSpent;\n\n    CTxIndex()\n    {\n        SetNull();\n    }\n\n    CTxIndex(const CDiskTxPos& posIn, unsigned int nOutputs)\n    {\n        pos = posIn;\n        vSpent.resize(nOutputs);\n    }\n\n    IMPLEMENT_SERIALIZE\n    (\n        if (!(nType & SER_GETHASH))\n            READWRITE(nVersion);\n        READWRITE(pos);\n        READWRITE(vSpent);\n    )\n\n    void SetNull()\n    {\n        pos.SetNull();\n        vSpent.clear();\n    }\n\n    bool IsNull()\n    {\n        return pos.IsNull();\n    }\n\n    friend bool operator==(const CTxIndex& a, const CTxIndex& b)\n    {\n        return (a.pos    == b.pos &&\n                a.vSpent == b.vSpent);\n    }\n\n    friend bool operator!=(const CTxIndex& a, const CTxIndex& b)\n    {\n        return !(a == b);\n    }\n \n};\n\n\n\n\n\n/** Nodes collect new transactions into a block, hash them into a hash tree,\n * and scan through nonce values to make the block's hash satisfy proof-of-work\n * requirements.  When they solve the proof-of-work, they broadcast the block\n * to everyone and the block is added to the block chain.  The first transaction\n * in the block is a special one that creates a new coin owned by the creator\n * of the block.\n *\n * Blocks are appended to blk0001.dat files on disk.  Their location on disk\n * is indexed by CBlockIndex objects in memory.\n */\nclass CBlock\n{\npublic:\n    // header\n    static const int CURRENT_VERSION = 2;\n    int nVersion;\n    uint256 hashPrevBlock;\n    uint256 hashMerkleRoot;\n    unsigned int nTime;\n    unsigned int nBits;\n    unsigned int nNonce;\n\n    // network and disk\n    std::vector<CTransaction> vtx;\n\n    // memory only\n    mutable std::vector<uint256> vMerkleTree;\n\n    // Denial-of-service detection:\n    mutable int nDoS;\n    bool DoS(int nDoSIn, bool fIn) const { nDoS += nDoSIn; return fIn; }\n\n    CBlock()\n    {\n        SetNull();\n    }\n\n    IMPLEMENT_SERIALIZE\n    (\n        READWRITE(this->nVersion);\n        nVersion = this->nVersion;\n        READWRITE(hashPrevBlock);\n        READWRITE(hashMerkleRoot);\n        READWRITE(nTime);\n        READWRITE(nBits);\n        READWRITE(nNonce);\n\n        // ConnectBlock depends on vtx being last so it can calculate offset\n        if (!(nType & (SER_GETHASH|SER_BLOCKHEADERONLY)))\n            READWRITE(vtx);\n        else if (fRead)\n            const_cast<CBlock*>(this)->vtx.clear();\n    )\n\n    void SetNull()\n    {\n        nVersion = CBlock::CURRENT_VERSION;\n        hashPrevBlock = 0;\n        hashMerkleRoot = 0;\n        nTime = 0;\n        nBits = 0;\n        nNonce = 0;\n        vtx.clear();\n        vMerkleTree.clear();\n        nDoS = 0;\n    }\n\n    bool IsNull() const\n    {\n        return (nBits == 0);\n    }\n\n    uint256 GetHash() const\n    {\n        return Hash(BEGIN(nVersion), END(nNonce));\n    }\n\n    /* Calculates block proof-of-work hash using either NeoScrypt or Scrypt */\n    uint256 GetPoWHash() const {\n        uint profile = 0x0;\n        uint256 hash;\n\n        /* All blocks generated up to this time point are Scrypt only */\n        if((fTestNet && (nTime < nTestnetSwitchV2)) ||\n          (!fTestNet && (nTime < nSwitchV2))) {\n            profile = 0x3;\n        } else {\n            /* All these blocks must be v2+ with valid nHeight */\n            int nHeight = GetBlockHeight();\n            if(fTestNet) {\n                if(nHeight < nTestnetForkTwo)\n                  profile = 0x3;\n            } else {\n                if(nHeight < nForkFive)\n                  profile = 0x3;\n            }\n        }\n\n        neoscrypt((uchar *) &nVersion, (uchar *) &hash, profile);\n\n        return(hash);\n    }\n\n    /* Extracts block height from v2+ coin base;\n     * ignores nVersion because it's unrealiable */\n    int GetBlockHeight() const {\n        /* Prevents a crash if called on a block header alone */\n        if(vtx.size()) {\n            /* Serialised CScript */\n            std::vector<uchar>::const_iterator scriptsig = vtx[0].vin[0].scriptSig.begin();\n            uchar i, scount = scriptsig[0];\n            /* Optimise: nTime is 4 bytes always,\n             * nHeight must be less for a long time;\n             * check against a threshold when the time comes */\n            if(scount < 4) {\n                int height = 0;\n                uchar *pheight = (uchar *) &height;\n                for(i = 0; i < scount; i++)\n                  pheight[i] = scriptsig[i + 1];\n                /* v2+ block with nHeight in coin base */\n                return(height);\n            }\n        }\n        /* Not found */\n        return(-1);\n    }\n\n    int64 GetBlockTime() const\n    {\n        return (int64)nTime;\n    }\n\n    void UpdateTime(const CBlockIndex* pindexPrev);\n\n\n    uint256 BuildMerkleTree() const\n    {\n        vMerkleTree.clear();\n        BOOST_FOREACH(const CTransaction& tx, vtx)\n            vMerkleTree.push_back(tx.GetHash());\n        int j = 0;\n        for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n        {\n            for (int i = 0; i < nSize; i += 2)\n            {\n                int i2 = std::min(i+1, nSize-1);\n                vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n                                           BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n            }\n            j += nSize;\n        }\n        return (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n    }\n\n    std::vector<uint256> GetMerkleBranch(int nIndex) const\n    {\n        if (vMerkleTree.empty())\n            BuildMerkleTree();\n        std::vector<uint256> vMerkleBranch;\n        int j = 0;\n        for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n        {\n            int i = std::min(nIndex^1, nSize-1);\n            vMerkleBranch.push_back(vMerkleTree[j+i]);\n            nIndex >>= 1;\n            j += nSize;\n        }\n        return vMerkleBranch;\n    }\n\n    static uint256 CheckMerkleBranch(uint256 hash, const std::vector<uint256>& vMerkleBranch, int nIndex)\n    {\n        if (nIndex == -1)\n            return 0;\n        BOOST_FOREACH(const uint256& otherside, vMerkleBranch)\n        {\n            if (nIndex & 1)\n                hash = Hash(BEGIN(otherside), END(otherside), BEGIN(hash), END(hash));\n            else\n                hash = Hash(BEGIN(hash), END(hash), BEGIN(otherside), END(otherside));\n            nIndex >>= 1;\n        }\n        return hash;\n    }\n\n\n    bool WriteToDisk(unsigned int& nFileRet, unsigned int& nBlockPosRet)\n    {\n        // Open history file to append\n        CAutoFile fileout = CAutoFile(AppendBlockFile(nFileRet), SER_DISK, CLIENT_VERSION);\n        if(!fileout)\n          return error(\"CBlock::WriteToDisk() : AppendBlockFile() failed\");\n\n        // Write index header\n        unsigned int nSize = fileout.GetSerializeSize(*this);\n        fileout << FLATDATA(pchMessageStart) << nSize;\n\n        // Write block\n        long fileOutPos = ftell(fileout);\n        if(fileOutPos < 0)\n          return error(\"CBlock::WriteToDisk() : ftell() failed\");\n        nBlockPosRet = fileOutPos;\n        fileout << *this;\n\n        // Flush stdio buffers and commit to disk before returning\n        fflush(fileout);\n        if(!IsInitialBlockDownload() || ((nBestHeight+1) % 100 == 0)) {\n            if(FileCommit(fileout))\n              return error(\"CBlock::WriteToDisk() : FileCommit() failed\");\n        }\n\n        return true;\n    }\n\n    bool ReadFromDisk(unsigned int nFile, unsigned int nBlockPos, bool fReadTransactions=true)\n    {\n        SetNull();\n\n        // Open history file to read\n        CAutoFile filein = CAutoFile(OpenBlockFile(nFile, nBlockPos, \"rb\"), SER_DISK, CLIENT_VERSION);\n        if(!filein)\n          return error(\"CBlock::ReadFromDisk() : OpenBlockFile() failed\");\n        if(!fReadTransactions) filein.nType |= SER_BLOCKHEADERONLY;\n\n        // Read block\n        try {\n            filein >> *this;\n        }\n        catch(std::exception &e) {\n            return error(\"CBlock::ReadFromDisk() : I/O error\");\n        }\n\n        return true;\n    }\n\n\n\n    void print() const\n    {\n        printf(\"CBlock(hash=%s, PoW=%s, ver=%d, hashPrevBlock=%s, hashMerkleRoot=%s, nTime=%u, nBits=%08x, nNonce=%u, vtx=%d)\\n\",\n            GetHash().ToString().substr(0,20).c_str(),\n            GetPoWHash().ToString().substr(0,20).c_str(),\n            nVersion,\n            hashPrevBlock.ToString().substr(0,20).c_str(),\n            hashMerkleRoot.ToString().substr(0,10).c_str(),\n            nTime, nBits, nNonce,\n            vtx.size());\n        for (unsigned int i = 0; i < vtx.size(); i++)\n        {\n            printf(\"  \");\n            vtx[i].print();\n        }\n        printf(\"  vMerkleTree: \");\n        for (unsigned int i = 0; i < vMerkleTree.size(); i++)\n            printf(\"%s \", vMerkleTree[i].ToString().substr(0,10).c_str());\n        printf(\"\\n\");\n    }\n\n\n    bool DisconnectBlock(CTxDB& txdb, CBlockIndex* pindex);\n    bool ConnectBlock(CTxDB& txdb, CBlockIndex* pindex);\n    bool ReadFromDisk(const CBlockIndex* pindex, bool fReadTransactions=true);\n    bool SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew);\n    bool AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos);\n    bool CheckBlock() const;\n    bool AcceptBlock();\n\nprivate:\n    bool SetBestChainInner(CTxDB& txdb, CBlockIndex *pindexNew);\n};\n\n\n\n\n\n\n/** The block chain is a tree shaped structure starting with the\n * genesis block at the root, with each block potentially having multiple\n * candidates to be the next block.  pprev and pnext link a path through the\n * main/longest chain.  A blockindex may have multiple pprev pointing back\n * to it, but pnext will only point forward to the longest branch, or will\n * be null if the block is not part of the longest chain.\n */\nclass CBlockIndex\n{\npublic:\n    const uint256* phashBlock;\n    CBlockIndex* pprev;\n    CBlockIndex* pnext;\n    unsigned int nFile;\n    unsigned int nBlockPos;\n    int nHeight;\n    CBigNum bnChainWork;\n\n    // block header\n    int nVersion;\n    uint256 hashMerkleRoot;\n    unsigned int nTime;\n    unsigned int nBits;\n    unsigned int nNonce;\n\n\n    CBlockIndex()\n    {\n        phashBlock = NULL;\n        pprev = NULL;\n        pnext = NULL;\n        nFile = 0;\n        nBlockPos = 0;\n        nHeight = 0;\n        bnChainWork = 0;\n\n        nVersion       = 0;\n        hashMerkleRoot = 0;\n        nTime          = 0;\n        nBits          = 0;\n        nNonce         = 0;\n    }\n\n    CBlockIndex(unsigned int nFileIn, unsigned int nBlockPosIn, CBlock& block)\n    {\n        phashBlock = NULL;\n        pprev = NULL;\n        pnext = NULL;\n        nFile = nFileIn;\n        nBlockPos = nBlockPosIn;\n        nHeight = 0;\n        bnChainWork = 0;\n\n        nVersion       = block.nVersion;\n        hashMerkleRoot = block.hashMerkleRoot;\n        nTime          = block.nTime;\n        nBits          = block.nBits;\n        nNonce         = block.nNonce;\n    }\n\n    CBlock GetBlockHeader() const\n    {\n        CBlock block;\n        block.nVersion       = nVersion;\n        if (pprev)\n            block.hashPrevBlock = pprev->GetBlockHash();\n        block.hashMerkleRoot = hashMerkleRoot;\n        block.nTime          = nTime;\n        block.nBits          = nBits;\n        block.nNonce         = nNonce;\n        return block;\n    }\n\n    uint256 GetBlockHash() const\n    {\n        return *phashBlock;\n    }\n\n    int64 GetBlockTime() const\n    {\n        return (int64)nTime;\n    }\n\n    CBigNum GetBlockWork() const\n    {\n        CBigNum bnTarget;\n        bnTarget.SetCompact(nBits);\n        if (bnTarget <= 0)\n            return 0;\n        return (CBigNum(1)<<256) / (bnTarget+1);\n    }\n\n    bool IsInMainChain() const\n    {\n        return (pnext || this == pindexBest);\n    }\n\n    bool CheckIndex() const\n    {\n        return true; // CheckProofOfWork(GetBlockHash(), nBits);\n    }\n\n    enum { nMedianTimeSpan=11 };\n\n    int64 GetMedianTimePast() const\n    {\n        int64 pmedian[nMedianTimeSpan];\n        int64* pbegin = &pmedian[nMedianTimeSpan];\n        int64* pend = &pmedian[nMedianTimeSpan];\n\n        const CBlockIndex* pindex = this;\n        for (int i = 0; i < nMedianTimeSpan && pindex; i++, pindex = pindex->pprev)\n            *(--pbegin) = pindex->GetBlockTime();\n\n        std::sort(pbegin, pend);\n        return pbegin[(pend - pbegin)/2];\n    }\n\n    int64 GetMedianTime() const\n    {\n        const CBlockIndex* pindex = this;\n        for (int i = 0; i < nMedianTimeSpan/2; i++)\n        {\n            if (!pindex->pnext)\n                return GetBlockTime();\n            pindex = pindex->pnext;\n        }\n        return pindex->GetMedianTimePast();\n    }\n\n    /* Advanced average block time calculator */\n    uint GetAverageTimePast(uint nAvgTimeSpan, uint nMinDelay) const {\n        uint avg[nAvgTimeSpan], nTempTime, i;\n        uint64 nAvgAccum;\n        const CBlockIndex* pindex = this;\n\n        /* Keep it fail safe */\n        if(!nAvgTimeSpan) return(0);\n\n        /* Initialise the elements to zero */\n        for(i = 0; i < nAvgTimeSpan; i++)\n          avg[i] = 0;\n\n        /* Fill with the time stamps */\n        for(i = nAvgTimeSpan; i && pindex; i--, pindex = pindex->pprev)\n          avg[i-1] = pindex->nTime;\n\n        /* Not enough input blocks */\n        if(!avg[0]) return(0);\n\n        /* Time travel aware accumulator */\n        nTempTime = avg[0];\n        for(i = 1, nAvgAccum = nTempTime; i < nAvgTimeSpan; i++) { \n            /* Update the accumulator either with an actual or minimal\n             * delay supplied to prevent extremely fast blocks */\n            if(avg[i] < (nTempTime + nMinDelay))\n              nTempTime += nMinDelay;\n            else\n              nTempTime  = avg[i];\n            nAvgAccum += nTempTime;\n        }\n\n        nTempTime = (uint)(nAvgAccum/(uint64)nAvgTimeSpan);\n\n        return(nTempTime);\n    }\n\n    std::string ToString() const\n    {\n        return strprintf(\"CBlockIndex(nprev=%08x, pnext=%08x, nFile=%d, nBlockPos=%-6d nHeight=%d, merkle=%s, hashBlock=%s)\",\n            pprev, pnext, nFile, nBlockPos, nHeight,\n            hashMerkleRoot.ToString().substr(0,10).c_str(),\n            GetBlockHash().ToString().substr(0,20).c_str());\n    }\n\n    void print() const\n    {\n        printf(\"%s\\n\", ToString().c_str());\n    }\n};\n\n\n\n/** Used to marshal pointers into hashes for db storage. */\nclass CDiskBlockIndex : public CBlockIndex\n{\npublic:\n    uint256 hashPrev;\n    uint256 hashNext;\n\n    CDiskBlockIndex()\n    {\n        hashPrev = 0;\n        hashNext = 0;\n    }\n\n    explicit CDiskBlockIndex(CBlockIndex* pindex) : CBlockIndex(*pindex)\n    {\n        hashPrev = (pprev ? pprev->GetBlockHash() : 0);\n        hashNext = (pnext ? pnext->GetBlockHash() : 0);\n    }\n\n    IMPLEMENT_SERIALIZE\n    (\n        if (!(nType & SER_GETHASH))\n            READWRITE(nVersion);\n\n        READWRITE(hashNext);\n        READWRITE(nFile);\n        READWRITE(nBlockPos);\n        READWRITE(nHeight);\n\n        // block header\n        READWRITE(this->nVersion);\n        READWRITE(hashPrev);\n        READWRITE(hashMerkleRoot);\n        READWRITE(nTime);\n        READWRITE(nBits);\n        READWRITE(nNonce);\n    )\n\n    uint256 GetBlockHash() const\n    {\n        CBlock block;\n        block.nVersion        = nVersion;\n        block.hashPrevBlock   = hashPrev;\n        block.hashMerkleRoot  = hashMerkleRoot;\n        block.nTime           = nTime;\n        block.nBits           = nBits;\n        block.nNonce          = nNonce;\n        return block.GetHash();\n    }\n\n\n    std::string ToString() const\n    {\n        std::string str = \"CDiskBlockIndex(\";\n        str += CBlockIndex::ToString();\n        str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n            GetBlockHash().ToString().c_str(),\n            hashPrev.ToString().substr(0,20).c_str(),\n            hashNext.ToString().substr(0,20).c_str());\n        return str;\n    }\n\n    void print() const\n    {\n        printf(\"%s\\n\", ToString().c_str());\n    }\n};\n\n\n\n\n\n\n\n\n/** Describes a place in the block chain to another node such that if the\n * other node doesn't have the same branch, it can find a recent common trunk.\n * The further back it is, the further before the fork it may be.\n */\nclass CBlockLocator\n{\nprotected:\n    std::vector<uint256> vHave;\npublic:\n\n    CBlockLocator()\n    {\n    }\n\n    explicit CBlockLocator(const CBlockIndex* pindex)\n    {\n        Set(pindex);\n    }\n\n    explicit CBlockLocator(uint256 hashBlock)\n    {\n        std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n        if (mi != mapBlockIndex.end())\n            Set((*mi).second);\n    }\n\n    CBlockLocator(const std::vector<uint256>& vHaveIn)\n    {\n        vHave = vHaveIn;\n    }\n\n    IMPLEMENT_SERIALIZE\n    (\n        if (!(nType & SER_GETHASH))\n            READWRITE(nVersion);\n        READWRITE(vHave);\n    )\n\n    void SetNull()\n    {\n        vHave.clear();\n    }\n\n    bool IsNull()\n    {\n        return vHave.empty();\n    }\n\n    void Set(const CBlockIndex* pindex)\n    {\n        vHave.clear();\n        int nStep = 1;\n        while (pindex)\n        {\n            vHave.push_back(pindex->GetBlockHash());\n\n            // Exponentially larger steps back\n            for (int i = 0; pindex && i < nStep; i++)\n                pindex = pindex->pprev;\n            if (vHave.size() > 10)\n                nStep *= 2;\n        }\n        vHave.push_back(hashGenesisBlock);\n    }\n\n    int GetDistanceBack()\n    {\n        // Retrace how far back it was in the sender's branch\n        int nDistance = 0;\n        int nStep = 1;\n        BOOST_FOREACH(const uint256& hash, vHave)\n        {\n            std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n            if (mi != mapBlockIndex.end())\n            {\n                CBlockIndex* pindex = (*mi).second;\n                if (pindex->IsInMainChain())\n                    return nDistance;\n            }\n            nDistance += nStep;\n            if (nDistance > 10)\n                nStep *= 2;\n        }\n        return nDistance;\n    }\n\n    CBlockIndex* GetBlockIndex()\n    {\n        // Find the first block the caller has in the main chain\n        BOOST_FOREACH(const uint256& hash, vHave)\n        {\n            std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n            if (mi != mapBlockIndex.end())\n            {\n                CBlockIndex* pindex = (*mi).second;\n                if (pindex->IsInMainChain())\n                    return pindex;\n            }\n        }\n        return pindexGenesisBlock;\n    }\n\n    uint256 GetBlockHash()\n    {\n        // Find the first block the caller has in the main chain\n        BOOST_FOREACH(const uint256& hash, vHave)\n        {\n            std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n            if (mi != mapBlockIndex.end())\n            {\n                CBlockIndex* pindex = (*mi).second;\n                if (pindex->IsInMainChain())\n                    return hash;\n            }\n        }\n        return hashGenesisBlock;\n    }\n\n    int GetHeight()\n    {\n        CBlockIndex* pindex = GetBlockIndex();\n        if (!pindex)\n            return 0;\n        return pindex->nHeight;\n    }\n};\n\n\n\n\n\n\n\n\n\n/** Alerts are for notifying old versions if they become too obsolete and\n * need to upgrade.  The message is displayed in the status bar.\n * Alert messages are broadcast as a vector of signed data.  Unserializing may\n * not read the entire buffer if the alert is for a newer version, but older\n * versions can still relay the original data.\n */\n\nstatic const char* pszMainKey = \"04f62e0a932afc0190785e5a1f0d58ce4be8da4ff4581e8e297991245bf2f0b4c1a226847afb802887e9812ff0346fbdbca984f518fce550977f08dae190fa5c0a\";\nstatic const char* pszTestKey = \"04e2aeb8d9997e92f5d98fd7f276ae1f83550f4bfffdf68c37e9d00783fbb5b3f959426ab048d30495dbef27c17e9162fb3929b189ef0f294e6d713999470d307b\";\n\nclass CUnsignedAlert\n{\npublic:\n    int nVersion;\n    int64 nRelayUntil;      // when newer nodes stop relaying to newer nodes\n    int64 nExpiration;\n    int nID;\n    int nCancel;\n    std::set<int> setCancel;\n    int nMinVer;            // lowest version inclusive\n    int nMaxVer;            // highest version inclusive\n    std::set<std::string> setSubVer;  // empty matches all\n    int nPriority;\n\n    // Actions\n    std::string strComment;\n    std::string strStatusBar;\n    std::string strReserved;\n\n    IMPLEMENT_SERIALIZE\n    (\n        READWRITE(this->nVersion);\n        nVersion = this->nVersion;\n        READWRITE(nRelayUntil);\n        READWRITE(nExpiration);\n        READWRITE(nID);\n        READWRITE(nCancel);\n        READWRITE(setCancel);\n        READWRITE(nMinVer);\n        READWRITE(nMaxVer);\n        READWRITE(setSubVer);\n        READWRITE(nPriority);\n\n        READWRITE(strComment);\n        READWRITE(strStatusBar);\n        READWRITE(strReserved);\n    )\n\n    void SetNull()\n    {\n        nVersion = 1;\n        nRelayUntil = 0;\n        nExpiration = 0;\n        nID = 0;\n        nCancel = 0;\n        setCancel.clear();\n        nMinVer = 0;\n        nMaxVer = 0;\n        setSubVer.clear();\n        nPriority = 0;\n\n        strComment.clear();\n        strStatusBar.clear();\n        strReserved.clear();\n    }\n\n    std::string ToString() const\n    {\n        std::string strSetCancel;\n        BOOST_FOREACH(int n, setCancel)\n            strSetCancel += strprintf(\"%d \", n);\n        std::string strSetSubVer;\n        BOOST_FOREACH(std::string str, setSubVer)\n            strSetSubVer += \"\\\"\" + str + \"\\\" \";\n        return strprintf(\n                \"CAlert(\\n\"\n                \"    nVersion     = %d\\n\"\n                \"    nRelayUntil  = %\"PRI64d\"\\n\"\n                \"    nExpiration  = %\"PRI64d\"\\n\"\n                \"    nID          = %d\\n\"\n                \"    nCancel      = %d\\n\"\n                \"    setCancel    = %s\\n\"\n                \"    nMinVer      = %d\\n\"\n                \"    nMaxVer      = %d\\n\"\n                \"    setSubVer    = %s\\n\"\n                \"    nPriority    = %d\\n\"\n                \"    strComment   = \\\"%s\\\"\\n\"\n                \"    strStatusBar = \\\"%s\\\"\\n\"\n                \")\\n\",\n            nVersion,\n            nRelayUntil,\n            nExpiration,\n            nID,\n            nCancel,\n            strSetCancel.c_str(),\n            nMinVer,\n            nMaxVer,\n            strSetSubVer.c_str(),\n            nPriority,\n            strComment.c_str(),\n            strStatusBar.c_str());\n    }\n\n    void print() const\n    {\n        printf(\"%s\", ToString().c_str());\n    }\n};\n\n/** An alert is a combination of a serialized CUnsignedAlert and a signature. */\nclass CAlert : public CUnsignedAlert\n{\npublic:\n    std::vector<unsigned char> vchMsg;\n    std::vector<unsigned char> vchSig;\n\n    CAlert()\n    {\n        SetNull();\n    }\n\n    IMPLEMENT_SERIALIZE\n    (\n        READWRITE(vchMsg);\n        READWRITE(vchSig);\n    )\n\n    void SetNull()\n    {\n        CUnsignedAlert::SetNull();\n        vchMsg.clear();\n        vchSig.clear();\n    }\n\n    bool IsNull() const\n    {\n        return (nExpiration == 0);\n    }\n\n    uint256 GetHash() const\n    {\n        return SerializeHash(*this);\n    }\n\n    bool IsInEffect() const\n    {\n        return (GetAdjustedTime() < nExpiration);\n    }\n\n    bool Cancels(const CAlert& alert) const\n    {\n        if (!IsInEffect())\n            return false; // this was a no-op before 31403\n        return (alert.nID <= nCancel || setCancel.count(alert.nID));\n    }\n\n    bool AppliesTo(int nVersion, std::string strSubVerIn) const\n    {\n        // TODO: rework for client-version-embedded-in-strSubVer ?\n        return (IsInEffect() &&\n                nMinVer <= nVersion && nVersion <= nMaxVer &&\n                (setSubVer.empty() || setSubVer.count(strSubVerIn)));\n    }\n\n    bool AppliesToMe() const\n    {\n        return AppliesTo(PROTOCOL_VERSION, FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, std::vector<std::string>()));\n    }\n\n    bool RelayTo(CNode* pnode) const\n    {\n        if (!IsInEffect())\n            return false;\n        // returns true if wasn't already contained in the set\n        if (pnode->setKnown.insert(GetHash()).second)\n        {\n            if (AppliesTo(pnode->nVersion, pnode->strSubVer) ||\n                AppliesToMe() ||\n                GetAdjustedTime() < nRelayUntil)\n            {\n                pnode->PushMessage(\"alert\", *this);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    bool CheckSignature() const\n    {\n\n        CKey key;\n        if (!key.SetPubKey(ParseHex(fTestNet ? pszTestKey : pszMainKey)))\n          return error(\"CAlert::CheckSignature(): failed to set public key\");\n        if (!key.Verify(Hash(vchMsg.begin(), vchMsg.end()), vchSig))\n          return error(\"CAlert::CheckSignature(): failed to verify signature\");\n\n        // Now unserialize the data\n        CDataStream sMsg(vchMsg, SER_NETWORK, PROTOCOL_VERSION);\n        sMsg >> *(CUnsignedAlert*)this;\n        return true;\n    }\n\n    bool ProcessAlert();\n\n    /*\n     * Get copy of (active) alert object by hash. Returns a null alert if it is not found.\n     */\n    static CAlert getAlertByHash(const uint256 &hash);\n};\n\nclass CTxMemPool\n{\npublic:\n    mutable CCriticalSection cs;\n    std::map<uint256, CTransaction> mapTx;\n    std::map<COutPoint, CInPoint> mapNextTx;\n\n    bool accept(CTxDB &txdb, CTransaction &tx, bool fCheckInputs, bool fLimitFree,\n      bool *pfMissingInputs);\n    bool addUnchecked(const uint256& hash, CTransaction &tx);\n    bool remove(const CTransaction &tx, bool fRecursive = false);\n    bool removeConflicts(const CTransaction &tx);\n    void queryHashes(std::vector<uint256>& vtxid);\n\n    unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }\n\n    bool exists(uint256 hash)\n    {\n        return (mapTx.count(hash) != 0);\n    }\n\n    CTransaction& lookup(uint256 hash)\n    {\n        return mapTx[hash];\n    }\n};\n\nextern CTxMemPool mempool;\n\n#endif\n", "// Copyright (c) 2010 Satoshi Nakamoto\n// Copyright (c) 2009-2012 The Bitcoin developers\n// Copyright (c) 2013-2014 Phoenixcoin Developers\n// Distributed under the MIT/X11 software license, see the accompanying\n// file LICENCE or http://www.opensource.org/licenses/mit-license.php\n\n#include <boost/assign/list_of.hpp>\n\n#include \"base58.h\"\n#include \"bitcoinrpc.h\"\n#include \"db.h\"\n#include \"init.h\"\n#include \"main.h\"\n#include \"net.h\"\n#include \"wallet.h\"\n\nusing namespace std;\nusing namespace boost;\nusing namespace boost::assign;\nusing namespace json_spirit;\n\n// These are all in bitcoinrpc.cpp:\nextern Object JSONRPCError(int code, const string& message);\nextern int64 AmountFromValue(const Value& value);\nextern Value ValueFromAmount(int64 amount);\nextern std::string HelpRequiringPassphrase();\nextern void EnsureWalletIsUnlocked();\n\nvoid\nScriptPubKeyToJSON(const CScript& scriptPubKey, Object& out)\n{\n    txnouttype type;\n    vector<CTxDestination> addresses;\n    int nRequired;\n\n    out.push_back(Pair(\"asm\", scriptPubKey.ToString()));\n    out.push_back(Pair(\"hex\", HexStr(scriptPubKey.begin(), scriptPubKey.end())));\n\n    if (!ExtractDestinations(scriptPubKey, type, addresses, nRequired))\n    {\n        out.push_back(Pair(\"type\", GetTxnOutputType(TX_NONSTANDARD)));\n        return;\n    }\n\n    out.push_back(Pair(\"reqSigs\", nRequired));\n    out.push_back(Pair(\"type\", GetTxnOutputType(type)));\n\n    Array a;\n    BOOST_FOREACH(const CTxDestination& addr, addresses)\n        a.push_back(CBitcoinAddress(addr).ToString());\n    out.push_back(Pair(\"addresses\", a));\n}\n\nvoid\nTxToJSON(const CTransaction& tx, const uint256 hashBlock, Object& entry)\n{\n    entry.push_back(Pair(\"txid\", tx.GetHash().GetHex()));\n    entry.push_back(Pair(\"version\", tx.nVersion));\n    entry.push_back(Pair(\"locktime\", (boost::int64_t)tx.nLockTime));\n    Array vin;\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n    {\n        Object in;\n        if (tx.IsCoinBase())\n            in.push_back(Pair(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n        else\n        {\n            in.push_back(Pair(\"txid\", txin.prevout.hash.GetHex()));\n            in.push_back(Pair(\"vout\", (boost::int64_t)txin.prevout.n));\n            Object o;\n            o.push_back(Pair(\"asm\", txin.scriptSig.ToString()));\n            o.push_back(Pair(\"hex\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n            in.push_back(Pair(\"scriptSig\", o));\n        }\n        in.push_back(Pair(\"sequence\", (boost::int64_t)txin.nSequence));\n        vin.push_back(in);\n    }\n    entry.push_back(Pair(\"vin\", vin));\n    Array vout;\n    for (unsigned int i = 0; i < tx.vout.size(); i++)\n    {\n        const CTxOut& txout = tx.vout[i];\n        Object out;\n        out.push_back(Pair(\"value\", ValueFromAmount(txout.nValue)));\n        out.push_back(Pair(\"n\", (boost::int64_t)i));\n        Object o;\n        ScriptPubKeyToJSON(txout.scriptPubKey, o);\n        out.push_back(Pair(\"scriptPubKey\", o));\n        vout.push_back(out);\n    }\n    entry.push_back(Pair(\"vout\", vout));\n\n    if (hashBlock != 0)\n    {\n        entry.push_back(Pair(\"blockhash\", hashBlock.GetHex()));\n        map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n        if (mi != mapBlockIndex.end() && (*mi).second)\n        {\n            CBlockIndex* pindex = (*mi).second;\n            if (pindex->IsInMainChain())\n            {\n                entry.push_back(Pair(\"confirmations\", 1 + nBestHeight - pindex->nHeight));\n                entry.push_back(Pair(\"time\", (boost::int64_t)pindex->nTime));\n            }\n            else\n                entry.push_back(Pair(\"confirmations\", 0));\n        }\n    }\n}\n\nValue getrawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() < 1 || params.size() > 2)\n        throw runtime_error(\n            \"getrawtransaction <txid> [verbose=0]\\n\"\n            \"If verbose=0, returns a string that is\\n\"\n            \"serialized, hex-encoded data for <txid>.\\n\"\n            \"If verbose is non-zero, returns an Object\\n\"\n            \"with information about <txid>.\");\n\n    uint256 hash;\n    hash.SetHex(params[0].get_str());\n\n    bool fVerbose = false;\n    if (params.size() > 1)\n        fVerbose = (params[1].get_int() != 0);\n\n    CTransaction tx;\n    uint256 hashBlock = 0;\n    if (!GetTransaction(hash, tx, hashBlock))\n        throw JSONRPCError(-5, \"No information available about transaction\");\n\n    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n    ssTx << tx;\n    string strHex = HexStr(ssTx.begin(), ssTx.end());\n\n    if (!fVerbose)\n        return strHex;\n\n    Object result;\n    result.push_back(Pair(\"hex\", strHex));\n    TxToJSON(tx, hashBlock, result);\n    return result;\n}\n\nValue listunspent(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() > 2)\n        throw runtime_error(\n            \"listunspent [minconf=1] [maxconf=999999]\\n\"\n            \"Returns array of unspent transaction outputs\\n\"\n            \"with between minconf and maxconf (inclusive) confirmations.\\n\"\n            \"Results are an array of Objects, each of which has:\\n\"\n            \"{txid, vout, scriptPubKey, amount, confirmations}\");\n\n    RPCTypeCheck(params, list_of(int_type)(int_type));\n\n    int nMinDepth = 1;\n    if (params.size() > 0)\n        nMinDepth = params[0].get_int();\n\n    int nMaxDepth = 999999;\n    if (params.size() > 1)\n        nMaxDepth = params[1].get_int();\n\n    Array results;\n    vector<COutput> vecOutputs;\n    pwalletMain->AvailableCoins(vecOutputs, false);\n    BOOST_FOREACH(const COutput& out, vecOutputs)\n    {\n        if (out.nDepth < nMinDepth || out.nDepth > nMaxDepth)\n            continue;\n\n        int64 nValue = out.tx->vout[out.i].nValue;\n        const CScript& pk = out.tx->vout[out.i].scriptPubKey;\n        Object entry;\n        entry.push_back(Pair(\"txid\", out.tx->GetHash().GetHex()));\n        entry.push_back(Pair(\"vout\", out.i));\n        entry.push_back(Pair(\"scriptPubKey\", HexStr(pk.begin(), pk.end())));\n        entry.push_back(Pair(\"amount\",ValueFromAmount(nValue)));\n        entry.push_back(Pair(\"confirmations\",out.nDepth));\n        results.push_back(entry);\n    }\n\n    return results;\n}\n\nValue createrawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() != 2)\n        throw runtime_error(\n            \"createrawtransaction [{\\\"txid\\\":txid,\\\"vout\\\":n},...] {address:amount,...}\\n\"\n            \"Create a transaction spending given inputs\\n\"\n            \"(array of objects containing transaction id and output number),\\n\"\n            \"sending to given address(es).\\n\"\n            \"Returns hex-encoded raw transaction.\\n\"\n            \"Note that the transaction's inputs are not signed, and\\n\"\n            \"it is not stored in the wallet or transmitted to the network.\");\n\n    RPCTypeCheck(params, list_of(array_type)(obj_type));\n\n    Array inputs = params[0].get_array();\n    Object sendTo = params[1].get_obj();\n\n    CTransaction rawTx;\n\n    BOOST_FOREACH(Value& input, inputs)\n    {\n        const Object& o = input.get_obj();\n\n        const Value& txid_v = find_value(o, \"txid\");\n        if (txid_v.type() != str_type)\n            throw JSONRPCError(-8, \"Invalid parameter, missing txid key\");\n        string txid = txid_v.get_str();\n        if (!IsHex(txid))\n            throw JSONRPCError(-8, \"Invalid parameter, expected hex txid\");\n\n        const Value& vout_v = find_value(o, \"vout\");\n        if (vout_v.type() != int_type)\n            throw JSONRPCError(-8, \"Invalid parameter, missing vout key\");\n        int nOutput = vout_v.get_int();\n        if (nOutput < 0)\n            throw JSONRPCError(-8, \"Invalid parameter, vout must be positive\");\n\n        CTxIn in(COutPoint(uint256(txid), nOutput));\n        rawTx.vin.push_back(in);\n    }\n\n    set<CBitcoinAddress> setAddress;\n    BOOST_FOREACH(const Pair& s, sendTo)\n    {\n        CBitcoinAddress address(s.name_);\n        if (!address.IsValid())\n            throw JSONRPCError(-5, string(\"Invalid Bitcoin address:\")+s.name_);\n\n        if (setAddress.count(address))\n            throw JSONRPCError(-8, string(\"Invalid parameter, duplicated address: \")+s.name_);\n        setAddress.insert(address);\n\n        CScript scriptPubKey;\n        scriptPubKey.SetDestination(address.Get());\n        int64 nAmount = AmountFromValue(s.value_);\n\n        CTxOut out(nAmount, scriptPubKey);\n        rawTx.vout.push_back(out);\n    }\n\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << rawTx;\n    return HexStr(ss.begin(), ss.end());\n}\n\nValue decoderawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() != 1)\n        throw runtime_error(\n            \"decoderawtransaction <hex string>\\n\"\n            \"Return a JSON object representing the serialized, hex-encoded transaction.\");\n\n    RPCTypeCheck(params, list_of(str_type));\n\n    vector<unsigned char> txData(ParseHex(params[0].get_str()));\n    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n    CTransaction tx;\n    try {\n        ssData >> tx;\n    }\n    catch (std::exception &e) {\n        throw JSONRPCError(-22, \"TX decode failed\");\n    }\n\n    Object result;\n    TxToJSON(tx, 0, result);\n\n    return result;\n}\n\nValue signrawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() < 1 || params.size() > 4)\n        throw runtime_error(\n            \"signrawtransaction <hex string> [{\\\"txid\\\":txid,\\\"vout\\\":n,\\\"scriptPubKey\\\":hex},...] [<privatekey1>,...] [sighashtype=\\\"ALL\\\"]\\n\"\n            \"Sign inputs for raw transaction (serialized, hex-encoded).\\n\"\n            \"Second optional argument is an array of previous transaction outputs that\\n\"\n            \"this transaction depends on but may not yet be in the blockchain.\\n\"\n            \"Third optional argument is an array of base58-encoded private\\n\"\n            \"keys that, if given, will be the only keys used to sign the transaction.\\n\"\n            \"Fourth option is a string that is one of six values; ALL, NONE, SINGLE or\\n\"\n            \"ALL|ANYONECANPAY, NONE|ANYONECANPAY, SINGLE|ANYONECANPAY.\\n\"\n            \"Returns json object with keys:\\n\"\n            \"  hex : raw transaction with signature(s) (hex-encoded string)\\n\"\n            \"  complete : 1 if transaction has a complete set of signature (0 if not)\"\n            + HelpRequiringPassphrase());\n\n    if (params.size() < 3)\n        EnsureWalletIsUnlocked();\n\n    RPCTypeCheck(params, list_of(str_type)(array_type)(array_type));\n\n    vector<unsigned char> txData(ParseHex(params[0].get_str()));\n    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n    vector<CTransaction> txVariants;\n    while (!ssData.empty())\n    {\n        try {\n            CTransaction tx;\n            ssData >> tx;\n            txVariants.push_back(tx);\n        }\n        catch (std::exception &e) {\n            throw JSONRPCError(-22, \"TX decode failed\");\n        }\n    }\n\n    if (txVariants.empty())\n        throw JSONRPCError(-22, \"Missing transaction\");\n\n    // mergedTx will end up with all the signatures; it\n    // starts as a clone of the rawtx:\n    CTransaction mergedTx(txVariants[0]);\n    bool fComplete = true;\n\n    // Fetch previous transactions (inputs):\n    map<COutPoint, CScript> mapPrevOut;\n    {\n        MapPrevTx mapPrevTx;\n        CTxDB txdb(\"r\");\n        map<uint256, CTxIndex> unused;\n        bool fInvalid;\n        mergedTx.FetchInputs(txdb, unused, false, false, mapPrevTx, fInvalid);\n\n        // Copy results into mapPrevOut:\n        BOOST_FOREACH(const CTxIn& txin, mergedTx.vin)\n        {\n            const uint256& prevHash = txin.prevout.hash;\n            if (mapPrevTx.count(prevHash))\n                mapPrevOut[txin.prevout] = mapPrevTx[prevHash].second.vout[txin.prevout.n].scriptPubKey;\n        }\n    }\n\n    // Add previous txouts given in the RPC call:\n    if (params.size() > 1)\n    {\n        Array prevTxs = params[1].get_array();\n        BOOST_FOREACH(Value& p, prevTxs)\n        {\n            if (p.type() != obj_type)\n                throw JSONRPCError(-22, \"expected object with {\\\"txid'\\\",\\\"vout\\\",\\\"scriptPubKey\\\"}\");\n\n            Object prevOut = p.get_obj();\n\n            RPCTypeCheck(prevOut, map_list_of(\"txid\", str_type)(\"vout\", int_type)(\"scriptPubKey\", str_type));\n\n            string txidHex = find_value(prevOut, \"txid\").get_str();\n            if (!IsHex(txidHex))\n                throw JSONRPCError(-22, \"txid must be hexadecimal\");\n            uint256 txid;\n            txid.SetHex(txidHex);\n\n            int nOut = find_value(prevOut, \"vout\").get_int();\n            if (nOut < 0)\n                throw JSONRPCError(-22, \"vout must be positive\");\n\n            string pkHex = find_value(prevOut, \"scriptPubKey\").get_str();\n            if (!IsHex(pkHex))\n                throw JSONRPCError(-22, \"scriptPubKey must be hexadecimal\");\n            vector<unsigned char> pkData(ParseHex(pkHex));\n            CScript scriptPubKey(pkData.begin(), pkData.end());\n\n            COutPoint outpoint(txid, nOut);\n            if (mapPrevOut.count(outpoint))\n            {\n                // Complain if scriptPubKey doesn't match\n                if (mapPrevOut[outpoint] != scriptPubKey)\n                {\n                    string err(\"Previous output scriptPubKey mismatch:\\n\");\n                    err = err + mapPrevOut[outpoint].ToString() + \"\\nvs:\\n\"+\n                        scriptPubKey.ToString();\n                    throw JSONRPCError(-22, err);\n                }\n            }\n            else\n                mapPrevOut[outpoint] = scriptPubKey;\n        }\n    }\n\n    bool fGivenKeys = false;\n    CBasicKeyStore tempKeystore;\n    if (params.size() > 2)\n    {\n        fGivenKeys = true;\n        Array keys = params[2].get_array();\n        BOOST_FOREACH(Value k, keys)\n        {\n            CBitcoinSecret vchSecret;\n            bool fGood = vchSecret.SetString(k.get_str());\n            if (!fGood)\n                throw JSONRPCError(-5,\"Invalid private key\");\n            CKey key;\n            bool fCompressed;\n            CSecret secret = vchSecret.GetSecret(fCompressed);\n            key.SetSecret(secret, fCompressed);\n            tempKeystore.AddKey(key);\n        }\n    }\n    const CKeyStore& keystore = (fGivenKeys ? tempKeystore : *pwalletMain);\n\n    int nHashType = SIGHASH_ALL;\n    if (params.size() > 3)\n    {\n        static map<string, int> mapSigHashValues =\n            boost::assign::map_list_of\n            (string(\"ALL\"), int(SIGHASH_ALL))\n            (string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY))\n            (string(\"NONE\"), int(SIGHASH_NONE))\n            (string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY))\n            (string(\"SINGLE\"), int(SIGHASH_SINGLE))\n            (string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY))\n            ;\n        string strHashType = params[3].get_str();\n        if (mapSigHashValues.count(strHashType))\n            nHashType = mapSigHashValues[strHashType];\n        else\n            throw JSONRPCError(-8, \"Invalid sighash param\");\n    }\n\n    // Sign what we can:\n    for (unsigned int i = 0; i < mergedTx.vin.size(); i++)\n    {\n        CTxIn& txin = mergedTx.vin[i];\n        if (mapPrevOut.count(txin.prevout) == 0)\n        {\n            fComplete = false;\n            continue;\n        }\n        const CScript& prevPubKey = mapPrevOut[txin.prevout];\n\n        txin.scriptSig.clear();\n        SignSignature(keystore, prevPubKey, mergedTx, i, nHashType);\n\n        // ... and merge in other signatures:\n        BOOST_FOREACH(const CTransaction& txv, txVariants)\n        {\n            txin.scriptSig = CombineSignatures(prevPubKey, mergedTx, i, txin.scriptSig, txv.vin[i].scriptSig);\n        }\n        if (!VerifyScript(txin.scriptSig, prevPubKey, mergedTx, i, true, 0))\n            fComplete = false;\n    }\n\n    Object result;\n    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n    ssTx << mergedTx;\n    result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n    result.push_back(Pair(\"complete\", fComplete));\n\n    return result;\n}\n\nValue sendrawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() < 1 || params.size() > 1)\n        throw runtime_error(\n            \"sendrawtransaction <hex string>\\n\"\n            \"Submits raw transaction (serialized, hex-encoded) to local node and network.\");\n\n    RPCTypeCheck(params, list_of(str_type));\n\n    // parse hex string from parameter\n    vector<unsigned char> txData(ParseHex(params[0].get_str()));\n    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n    CTransaction tx;\n\n    // deserialize binary data stream\n    try {\n        ssData >> tx;\n    }\n    catch (std::exception &e) {\n        throw JSONRPCError(-22, \"TX decode failed\");\n    }\n    uint256 hashTx = tx.GetHash();\n\n    // See if the transaction is already in a block\n    // or in the memory pool:\n    CTransaction existingTx;\n    uint256 hashBlock = 0;\n    if (GetTransaction(hashTx, existingTx, hashBlock))\n    {\n        if (hashBlock != 0)\n            throw JSONRPCError(-5, string(\"transaction already in block \")+hashBlock.GetHex());\n        // Not in block, but already in the memory pool; will drop\n        // through to re-relay it.\n    }\n    else\n    {\n        // push to local node\n        CTxDB txdb(\"r\");\n        if(!tx.AcceptToMemoryPool(txdb, true, false))\n          throw(JSONRPCError(-22, \"TX rejected\"));\n\n        SyncWithWallets(tx, NULL, true);\n    }\n    RelayMessage(CInv(MSG_TX, hashTx), tx);\n\n    return hashTx.GetHex();\n}\n", "// Copyright (c) 2009-2010 Satoshi Nakamoto\n// Copyright (c) 2009-2012 The Bitcoin developers\n// Copyright (c) 2011-2012 Litecoin Developers\n// Copyright (c) 2013-2014 Phoenixcoin Developers\n// Distributed under the MIT/X11 software license, see the accompanying\n// file LICENCE or http://www.opensource.org/licenses/mit-license.php\n\n#include \"wallet.h\"\n#include \"walletdb.h\"\n#include \"crypter.h\"\n#include \"ui_interface.h\"\n#include \"base58.h\"\n#include \"coincontrol.h\"\n\nusing namespace std;\n\nstatic int64 nNextResendTxTime = 0;\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// mapWallet\n//\n\nstruct CompareValueOnly\n{\n    bool operator()(const pair<int64, pair<const CWalletTx*, unsigned int> >& t1,\n                    const pair<int64, pair<const CWalletTx*, unsigned int> >& t2) const\n    {\n        return t1.first < t2.first;\n    }\n};\n\nCPubKey CWallet::GenerateNewKey()\n{\n    bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets\n\n    RandAddSeedPerfmon();\n    CKey key;\n    key.MakeNewKey(fCompressed);\n\n    // Compressed public keys were introduced in version 0.6.0\n    if (fCompressed)\n        SetMinVersion(FEATURE_COMPRPUBKEY);\n\n    if (!AddKey(key))\n        throw std::runtime_error(\"CWallet::GenerateNewKey() : AddKey failed\");\n    return key.GetPubKey();\n}\n\nbool CWallet::AddKey(const CKey& key)\n{\n    if (!CCryptoKeyStore::AddKey(key))\n        return false;\n    if (!fFileBacked)\n        return true;\n    if (!IsCrypted())\n        return CWalletDB(strWalletFile).WriteKey(key.GetPubKey(), key.GetPrivKey());\n    return true;\n}\n\nbool CWallet::AddCryptedKey(const CPubKey &vchPubKey, const vector<unsigned char> &vchCryptedSecret)\n{\n    if (!CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret))\n        return false;\n    if (!fFileBacked)\n        return true;\n    {\n        LOCK(cs_wallet);\n        if (pwalletdbEncryption)\n            return pwalletdbEncryption->WriteCryptedKey(vchPubKey, vchCryptedSecret);\n        else\n            return CWalletDB(strWalletFile).WriteCryptedKey(vchPubKey, vchCryptedSecret);\n    }\n    return false;\n}\n\nbool CWallet::AddCScript(const CScript& redeemScript)\n{\n    if (!CCryptoKeyStore::AddCScript(redeemScript))\n        return false;\n    if (!fFileBacked)\n        return true;\n    return CWalletDB(strWalletFile).WriteCScript(Hash160(redeemScript), redeemScript);\n}\n\nbool CWallet::Unlock(const SecureString& strWalletPassphrase)\n{\n    if (!IsLocked())\n        return false;\n\n    CCrypter crypter;\n    CKeyingMaterial vMasterKey;\n\n    {\n        LOCK(cs_wallet);\n        BOOST_FOREACH(const MasterKeyMap::value_type& pMasterKey, mapMasterKeys)\n        {\n            if(!crypter.SetKeyFromPassphrase(strWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                return false;\n            if (!crypter.Decrypt(pMasterKey.second.vchCryptedKey, vMasterKey))\n                return false;\n            if (CCryptoKeyStore::Unlock(vMasterKey))\n                return true;\n        }\n    }\n    return false;\n}\n\nbool CWallet::ChangeWalletPassphrase(const SecureString& strOldWalletPassphrase, const SecureString& strNewWalletPassphrase)\n{\n    bool fWasLocked = IsLocked();\n\n    {\n        LOCK(cs_wallet);\n        Lock();\n\n        CCrypter crypter;\n        CKeyingMaterial vMasterKey;\n        BOOST_FOREACH(MasterKeyMap::value_type& pMasterKey, mapMasterKeys)\n        {\n            if(!crypter.SetKeyFromPassphrase(strOldWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                return false;\n            if (!crypter.Decrypt(pMasterKey.second.vchCryptedKey, vMasterKey))\n                return false;\n            if (CCryptoKeyStore::Unlock(vMasterKey))\n            {\n                int64 nStartTime = GetTimeMillis();\n                crypter.SetKeyFromPassphrase(strNewWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod);\n                pMasterKey.second.nDeriveIterations = pMasterKey.second.nDeriveIterations * (100 / ((double)(GetTimeMillis() - nStartTime)));\n\n                nStartTime = GetTimeMillis();\n                crypter.SetKeyFromPassphrase(strNewWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod);\n                pMasterKey.second.nDeriveIterations = (pMasterKey.second.nDeriveIterations + pMasterKey.second.nDeriveIterations * 100 / ((double)(GetTimeMillis() - nStartTime))) / 2;\n\n                if (pMasterKey.second.nDeriveIterations < 25000)\n                    pMasterKey.second.nDeriveIterations = 25000;\n\n                printf(\"Wallet passphrase changed to an nDeriveIterations of %i\\n\", pMasterKey.second.nDeriveIterations);\n\n                if (!crypter.SetKeyFromPassphrase(strNewWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                    return false;\n                if (!crypter.Encrypt(vMasterKey, pMasterKey.second.vchCryptedKey))\n                    return false;\n                CWalletDB(strWalletFile).WriteMasterKey(pMasterKey.first, pMasterKey.second);\n                if (fWasLocked)\n                    Lock();\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nvoid CWallet::SetBestChain(const CBlockLocator& loc)\n{\n    CWalletDB walletdb(strWalletFile);\n    walletdb.WriteBestBlock(loc);\n}\n\n// This class implements an addrIncoming entry that causes pre-0.4\n// clients to crash on startup if reading a private-key-encrypted wallet.\nclass CCorruptAddress\n{\npublic:\n    IMPLEMENT_SERIALIZE\n    (\n        if (nType & SER_DISK)\n            READWRITE(nVersion);\n    )\n};\n\nbool CWallet::SetMinVersion(enum WalletFeature nVersion, CWalletDB* pwalletdbIn, bool fExplicit)\n{\n    if (nWalletVersion >= nVersion)\n        return true;\n\n    // when doing an explicit upgrade, if we pass the max version permitted, upgrade all the way\n    if (fExplicit && nVersion > nWalletMaxVersion)\n            nVersion = FEATURE_LATEST;\n\n    nWalletVersion = nVersion;\n\n    if (nVersion > nWalletMaxVersion)\n        nWalletMaxVersion = nVersion;\n\n    if (fFileBacked)\n    {\n        CWalletDB* pwalletdb = pwalletdbIn ? pwalletdbIn : new CWalletDB(strWalletFile);\n        if (nWalletVersion >= 40000)\n        {\n            // Versions prior to 0.4.0 did not support the \"minversion\" record.\n            // Use a CCorruptAddress to make them crash instead.\n            CCorruptAddress corruptAddress;\n            pwalletdb->WriteSetting(\"addrIncoming\", corruptAddress);\n        }\n        if (nWalletVersion > 40000)\n            pwalletdb->WriteMinVersion(nWalletVersion);\n        if (!pwalletdbIn)\n            delete pwalletdb;\n    }\n\n    return true;\n}\n\nbool CWallet::SetMaxVersion(int nVersion)\n{\n    // cannot downgrade below current version\n    if (nWalletVersion > nVersion)\n        return false;\n\n    nWalletMaxVersion = nVersion;\n\n    return true;\n}\n\nbool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n{\n    if (IsCrypted())\n        return false;\n\n    CKeyingMaterial vMasterKey;\n    RandAddSeedPerfmon();\n\n    vMasterKey.resize(WALLET_CRYPTO_KEY_SIZE);\n    RAND_bytes(&vMasterKey[0], WALLET_CRYPTO_KEY_SIZE);\n\n    CMasterKey kMasterKey;\n\n    RandAddSeedPerfmon();\n    kMasterKey.vchSalt.resize(WALLET_CRYPTO_SALT_SIZE);\n    RAND_bytes(&kMasterKey.vchSalt[0], WALLET_CRYPTO_SALT_SIZE);\n\n    CCrypter crypter;\n    int64 nStartTime = GetTimeMillis();\n    crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, 25000, kMasterKey.nDerivationMethod);\n    kMasterKey.nDeriveIterations = 2500000 / ((double)(GetTimeMillis() - nStartTime));\n\n    nStartTime = GetTimeMillis();\n    crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, kMasterKey.nDeriveIterations, kMasterKey.nDerivationMethod);\n    kMasterKey.nDeriveIterations = (kMasterKey.nDeriveIterations + kMasterKey.nDeriveIterations * 100 / ((double)(GetTimeMillis() - nStartTime))) / 2;\n\n    if (kMasterKey.nDeriveIterations < 25000)\n        kMasterKey.nDeriveIterations = 25000;\n\n    printf(\"Encrypting Wallet with an nDeriveIterations of %i\\n\", kMasterKey.nDeriveIterations);\n\n    if (!crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, kMasterKey.nDeriveIterations, kMasterKey.nDerivationMethod))\n        return false;\n    if (!crypter.Encrypt(vMasterKey, kMasterKey.vchCryptedKey))\n        return false;\n\n    {\n        LOCK(cs_wallet);\n        mapMasterKeys[++nMasterKeyMaxID] = kMasterKey;\n        if (fFileBacked)\n        {\n            pwalletdbEncryption = new CWalletDB(strWalletFile);\n            if (!pwalletdbEncryption->TxnBegin())\n                return false;\n            pwalletdbEncryption->WriteMasterKey(nMasterKeyMaxID, kMasterKey);\n        }\n\n        if (!EncryptKeys(vMasterKey))\n        {\n            if (fFileBacked)\n                pwalletdbEncryption->TxnAbort();\n            exit(1); //We now probably have half of our keys encrypted in memory, and half not...die and let the user reload their unencrypted wallet.\n        }\n\n        // Encryption was introduced in version 0.4.0\n        SetMinVersion(FEATURE_WALLETCRYPT, pwalletdbEncryption, true);\n\n        if (fFileBacked)\n        {\n            if (!pwalletdbEncryption->TxnCommit())\n                exit(1); //We now have keys encrypted in memory, but no on disk...die to avoid confusion and let the user reload their unencrypted wallet.\n\n            delete pwalletdbEncryption;\n            pwalletdbEncryption = NULL;\n        }\n\n        Lock();\n        Unlock(strWalletPassphrase);\n        NewKeyPool();\n        Lock();\n\n        // Need to completely rewrite the wallet file; if we don't, bdb might keep\n        // bits of the unencrypted private key in slack space in the database file.\n        CDB::Rewrite(strWalletFile);\n\n    }\n    NotifyStatusChanged(this);\n\n    return true;\n}\n\nvoid CWallet::WalletUpdateSpent(const CTransaction &tx)\n{\n    // Anytime a signature is successfully verified, it's proof the outpoint is spent.\n    // Update the wallet spent flag if it doesn't know due to wallet.dat being\n    // restored from backup or the user making copies of wallet.dat.\n    {\n        LOCK(cs_wallet);\n        BOOST_FOREACH(const CTxIn& txin, tx.vin)\n        {\n            map<uint256, CWalletTx>::iterator mi = mapWallet.find(txin.prevout.hash);\n            if (mi != mapWallet.end())\n            {\n                CWalletTx& wtx = (*mi).second;\n                if (!wtx.IsSpent(txin.prevout.n) && IsMine(wtx.vout[txin.prevout.n]))\n                {\n                    printf(\"WalletUpdateSpent found spent coin %sbc %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n                    wtx.MarkSpent(txin.prevout.n);\n                    wtx.WriteToDisk();\n                    NotifyTransactionChanged(this, txin.prevout.hash, CT_UPDATED);\n                }\n            }\n        }\n    }\n}\n\nvoid CWallet::MarkDirty()\n{\n    {\n        LOCK(cs_wallet);\n        BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n            item.second.MarkDirty();\n    }\n}\n\nbool CWallet::AddToWallet(const CWalletTx& wtxIn)\n{\n    uint256 hash = wtxIn.GetHash();\n    {\n        LOCK(cs_wallet);\n        // Inserts only if not already there, returns tx inserted or tx found\n        pair<map<uint256, CWalletTx>::iterator, bool> ret = mapWallet.insert(make_pair(hash, wtxIn));\n        CWalletTx& wtx = (*ret.first).second;\n        wtx.BindWallet(this);\n        bool fInsertedNew = ret.second;\n        if (fInsertedNew)\n            wtx.nTimeReceived = GetAdjustedTime();\n\n        bool fUpdated = false;\n        if (!fInsertedNew)\n        {\n            // Merge\n            if (wtxIn.hashBlock != 0 && wtxIn.hashBlock != wtx.hashBlock)\n            {\n                wtx.hashBlock = wtxIn.hashBlock;\n                fUpdated = true;\n            }\n            if (wtxIn.nIndex != -1 && (wtxIn.vMerkleBranch != wtx.vMerkleBranch || wtxIn.nIndex != wtx.nIndex))\n            {\n                wtx.vMerkleBranch = wtxIn.vMerkleBranch;\n                wtx.nIndex = wtxIn.nIndex;\n                fUpdated = true;\n            }\n            if (wtxIn.fFromMe && wtxIn.fFromMe != wtx.fFromMe)\n            {\n                wtx.fFromMe = wtxIn.fFromMe;\n                fUpdated = true;\n            }\n            fUpdated |= wtx.UpdateSpent(wtxIn.vfSpent);\n        }\n\n        //// debug print\n        printf(\"AddToWallet %s  %s%s\\n\", wtxIn.GetHash().ToString().substr(0,10).c_str(), (fInsertedNew ? \"new\" : \"\"), (fUpdated ? \"update\" : \"\"));\n\n        // Write to disk\n        if (fInsertedNew || fUpdated)\n            if (!wtx.WriteToDisk())\n                return false;\n#ifndef QT_GUI\n        // If default receiving address gets used, replace it with a new one\n        CScript scriptDefaultKey;\n        scriptDefaultKey.SetDestination(vchDefaultKey.GetID());\n        BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n        {\n            if (txout.scriptPubKey == scriptDefaultKey)\n            {\n                CPubKey newDefaultKey;\n                if (GetKeyFromPool(newDefaultKey, false))\n                {\n                    SetDefaultKey(newDefaultKey);\n                    SetAddressBookName(vchDefaultKey.GetID(), \"\");\n                }\n            }\n        }\n#endif\n        // since AddToWallet is called directly for self-originating transactions, check for consumption of own coins\n        WalletUpdateSpent(wtx);\n\n        // Notify UI of new or updated transaction\n        NotifyTransactionChanged(this, hash, fInsertedNew ? CT_NEW : CT_UPDATED);\n    }\n    return true;\n}\n\n// Add a transaction to the wallet, or update it.\n// pblock is optional, but should be provided if the transaction is known to be in a block.\n// If fUpdate is true, existing transactions will be updated.\nbool CWallet::AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate, bool fFindBlock)\n{\n    uint256 hash = tx.GetHash();\n    {\n        LOCK(cs_wallet);\n        bool fExisted = mapWallet.count(hash);\n        if (fExisted && !fUpdate) return false;\n        if (fExisted || IsMine(tx) || IsFromMe(tx))\n        {\n            CWalletTx wtx(this,tx);\n            // Get merkle branch if transaction was found in a block\n            if (pblock)\n                wtx.SetMerkleBranch(pblock);\n            return AddToWallet(wtx);\n        }\n        else\n            WalletUpdateSpent(tx);\n    }\n    return false;\n}\n\nbool CWallet::EraseFromWallet(uint256 hash)\n{\n    if (!fFileBacked)\n        return false;\n    {\n        LOCK(cs_wallet);\n        if (mapWallet.erase(hash))\n            CWalletDB(strWalletFile).EraseTx(hash);\n    }\n    return true;\n}\n\n\nbool CWallet::IsMine(const CTxIn &txin) const\n{\n    {\n        LOCK(cs_wallet);\n        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n        if (mi != mapWallet.end())\n        {\n            const CWalletTx& prev = (*mi).second;\n            if (txin.prevout.n < prev.vout.size())\n                if (IsMine(prev.vout[txin.prevout.n]))\n                    return true;\n        }\n    }\n    return false;\n}\n\nint64 CWallet::GetDebit(const CTxIn &txin) const\n{\n    {\n        LOCK(cs_wallet);\n        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n        if (mi != mapWallet.end())\n        {\n            const CWalletTx& prev = (*mi).second;\n            if (txin.prevout.n < prev.vout.size())\n                if (IsMine(prev.vout[txin.prevout.n]))\n                    return prev.vout[txin.prevout.n].nValue;\n        }\n    }\n    return 0;\n}\n\nbool CWallet::IsChange(const CTxOut& txout) const\n{\n    CTxDestination address;\n\n    // TODO: fix handling of 'change' outputs. The assumption is that any\n    // payment to a TX_PUBKEYHASH that is mine but isn't in the address book\n    // is change. That assumption is likely to break when we implement multisignature\n    // wallets that return change back into a multi-signature-protected address;\n    // a better way of identifying which outputs are 'the send' and which are\n    // 'the change' will need to be implemented (maybe extend CWalletTx to remember\n    // which output, if any, was change).\n    if (ExtractDestination(txout.scriptPubKey, address) && ::IsMine(*this, address))\n    {\n        LOCK(cs_wallet);\n        if (!mapAddressBook.count(address))\n            return true;\n    }\n    return false;\n}\n\nint64 CWalletTx::GetTxTime() const\n{\n    return nTimeReceived;\n}\n\nint CWalletTx::GetRequestCount() const\n{\n    // Returns -1 if it wasn't being tracked\n    int nRequests = -1;\n    {\n        LOCK(pwallet->cs_wallet);\n        if (IsCoinBase())\n        {\n            // Generated block\n            if (hashBlock != 0)\n            {\n                map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(hashBlock);\n                if (mi != pwallet->mapRequestCount.end())\n                    nRequests = (*mi).second;\n            }\n        }\n        else\n        {\n            // Did anyone request this transaction?\n            map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(GetHash());\n            if (mi != pwallet->mapRequestCount.end())\n            {\n                nRequests = (*mi).second;\n\n                // How about the block it's in?\n                if (nRequests == 0 && hashBlock != 0)\n                {\n                    map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(hashBlock);\n                    if (mi != pwallet->mapRequestCount.end())\n                        nRequests = (*mi).second;\n                    else\n                        nRequests = 1; // If it's in someone else's block it must have got out\n                }\n            }\n        }\n    }\n    return nRequests;\n}\n\nvoid CWalletTx::GetAmounts(int64& nGeneratedImmature, int64& nGeneratedMature, list<pair<CTxDestination, int64> >& listReceived,\n                           list<pair<CTxDestination, int64> >& listSent, int64& nFee, string& strSentAccount) const\n{\n    nGeneratedImmature = nGeneratedMature = nFee = 0;\n    listReceived.clear();\n    listSent.clear();\n    strSentAccount = strFromAccount;\n\n    if (IsCoinBase())\n    {\n        if (GetBlocksToMaturity() > 0)\n            nGeneratedImmature = pwallet->GetCredit(*this);\n        else\n            nGeneratedMature = GetCredit();\n        return;\n    }\n\n    // Compute fee:\n    int64 nDebit = GetDebit();\n    if (nDebit > 0) // debit>0 means we signed/sent this transaction\n    {\n        int64 nValueOut = GetValueOut();\n        nFee = nDebit - nValueOut;\n    }\n\n    // Sent/received.\n    BOOST_FOREACH(const CTxOut& txout, vout)\n    {\n        CTxDestination address;\n        vector<unsigned char> vchPubKey;\n        if (!ExtractDestination(txout.scriptPubKey, address))\n        {\n            printf(\"CWalletTx::GetAmounts: Unknown transaction type found, txid %s\\n\",\n                   this->GetHash().ToString().c_str());\n        }\n\n        // Don't report 'change' txouts\n        if (nDebit > 0 && pwallet->IsChange(txout))\n            continue;\n\n        if (nDebit > 0)\n            listSent.push_back(make_pair(address, txout.nValue));\n\n        if (pwallet->IsMine(txout))\n            listReceived.push_back(make_pair(address, txout.nValue));\n    }\n\n}\n\nvoid CWalletTx::GetAccountAmounts(const string& strAccount, int64& nGenerated, int64& nReceived,\n                                  int64& nSent, int64& nFee) const\n{\n    nGenerated = nReceived = nSent = nFee = 0;\n\n    int64 allGeneratedImmature, allGeneratedMature, allFee;\n    allGeneratedImmature = allGeneratedMature = allFee = 0;\n    string strSentAccount;\n    list<pair<CTxDestination, int64> > listReceived;\n    list<pair<CTxDestination, int64> > listSent;\n    GetAmounts(allGeneratedImmature, allGeneratedMature, listReceived, listSent, allFee, strSentAccount);\n\n    if (strAccount == \"\")\n        nGenerated = allGeneratedMature;\n    if (strAccount == strSentAccount)\n    {\n        BOOST_FOREACH(const PAIRTYPE(CTxDestination,int64)& s, listSent)\n            nSent += s.second;\n        nFee = allFee;\n    }\n    {\n        LOCK(pwallet->cs_wallet);\n        BOOST_FOREACH(const PAIRTYPE(CTxDestination,int64)& r, listReceived)\n        {\n            if (pwallet->mapAddressBook.count(r.first))\n            {\n                map<CTxDestination, string>::const_iterator mi = pwallet->mapAddressBook.find(r.first);\n                if (mi != pwallet->mapAddressBook.end() && (*mi).second == strAccount)\n                    nReceived += r.second;\n            }\n            else if (strAccount.empty())\n            {\n                nReceived += r.second;\n            }\n        }\n    }\n}\n\nvoid CWalletTx::AddSupportingTransactions(CTxDB& txdb)\n{\n    vtxPrev.clear();\n\n    const int COPY_DEPTH = 3;\n    if (SetMerkleBranch() < COPY_DEPTH)\n    {\n        vector<uint256> vWorkQueue;\n        BOOST_FOREACH(const CTxIn& txin, vin)\n            vWorkQueue.push_back(txin.prevout.hash);\n\n        // This critsect is OK because txdb is already open\n        {\n            LOCK(pwallet->cs_wallet);\n            map<uint256, const CMerkleTx*> mapWalletPrev;\n            set<uint256> setAlreadyDone;\n            for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n            {\n                uint256 hash = vWorkQueue[i];\n                if (setAlreadyDone.count(hash))\n                    continue;\n                setAlreadyDone.insert(hash);\n\n                CMerkleTx tx;\n                map<uint256, CWalletTx>::const_iterator mi = pwallet->mapWallet.find(hash);\n                if (mi != pwallet->mapWallet.end())\n                {\n                    tx = (*mi).second;\n                    BOOST_FOREACH(const CMerkleTx& txWalletPrev, (*mi).second.vtxPrev)\n                        mapWalletPrev[txWalletPrev.GetHash()] = &txWalletPrev;\n                }\n                else if (mapWalletPrev.count(hash))\n                {\n                    tx = *mapWalletPrev[hash];\n                }\n                else if(txdb.ReadDiskTx(hash, tx)) {\n                    ;\n                }\n                else\n                {\n                    printf(\"ERROR: AddSupportingTransactions() : unsupported transaction\\n\");\n                    continue;\n                }\n\n                int nDepth = tx.SetMerkleBranch();\n                vtxPrev.push_back(tx);\n\n                if (nDepth < COPY_DEPTH)\n                {\n                    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n                        vWorkQueue.push_back(txin.prevout.hash);\n                }\n            }\n        }\n    }\n\n    reverse(vtxPrev.begin(), vtxPrev.end());\n}\n\nbool CWalletTx::WriteToDisk()\n{\n    return CWalletDB(pwallet->strWalletFile).WriteTx(GetHash(), *this);\n}\n\n// Scan the block chain (starting in pindexStart) for transactions\n// from or to us. If fUpdate is true, found transactions that already\n// exist in the wallet will be updated.\nint CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n{\n    int ret = 0;\n\n    CBlockIndex* pindex = pindexStart;\n    {\n        LOCK(cs_wallet);\n        while (pindex)\n        {\n            CBlock block;\n            block.ReadFromDisk(pindex, true);\n            BOOST_FOREACH(CTransaction& tx, block.vtx)\n            {\n                if (AddToWalletIfInvolvingMe(tx, &block, fUpdate))\n                    ret++;\n            }\n            pindex = pindex->pnext;\n        }\n    }\n    return ret;\n}\n\nint CWallet::ScanForWalletTransaction(const uint256& hashTx)\n{\n    CTransaction tx;\n    tx.ReadFromDisk(COutPoint(hashTx, 0));\n    if (AddToWalletIfInvolvingMe(tx, NULL, true, true))\n        return 1;\n    return 0;\n}\n\nvoid CWallet::ReacceptWalletTransactions()\n{\n    CTxDB txdb(\"r\");\n    bool fRepeat = true;\n    while (fRepeat)\n    {\n        LOCK(cs_wallet);\n        fRepeat = false;\n        vector<CDiskTxPos> vMissingTx;\n        BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n        {\n            CWalletTx& wtx = item.second;\n            if (wtx.IsCoinBase() && wtx.IsSpent(0))\n                continue;\n\n            CTxIndex txindex;\n            bool fUpdated = false;\n            if (txdb.ReadTxIndex(wtx.GetHash(), txindex))\n            {\n                // Update fSpent if a tx got spent somewhere else by a copy of wallet.dat\n                if (txindex.vSpent.size() != wtx.vout.size())\n                {\n                    printf(\"ERROR: ReacceptWalletTransactions() : txindex.vSpent.size() %d != wtx.vout.size() %d\\n\", txindex.vSpent.size(), wtx.vout.size());\n                    continue;\n                }\n                for (unsigned int i = 0; i < txindex.vSpent.size(); i++)\n                {\n                    if (wtx.IsSpent(i))\n                        continue;\n                    if (!txindex.vSpent[i].IsNull() && IsMine(wtx.vout[i]))\n                    {\n                        wtx.MarkSpent(i);\n                        fUpdated = true;\n                        vMissingTx.push_back(txindex.vSpent[i]);\n                    }\n                }\n                if (fUpdated)\n                {\n                    printf(\"ReacceptWalletTransactions found spent coin %sbc %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n                    wtx.MarkDirty();\n                    wtx.WriteToDisk();\n                }\n            }\n            else\n            {\n                // Reaccept any txes of ours that aren't already in a block\n                if (!wtx.IsCoinBase())\n                    wtx.AcceptWalletTransaction(txdb, false);\n            }\n        }\n        if (!vMissingTx.empty())\n        {\n            // TODO: optimize this to scan just part of the block chain?\n            if (ScanForWalletTransactions(pindexGenesisBlock))\n                fRepeat = true;  // Found missing transactions: re-do Reaccept.\n        }\n    }\n}\n\nvoid CWalletTx::RelayWalletTransaction(CTxDB& txdb)\n{\n    BOOST_FOREACH(const CMerkleTx& tx, vtxPrev)\n    {\n        if (!tx.IsCoinBase())\n        {\n            uint256 hash = tx.GetHash();\n            if (!txdb.ContainsTx(hash))\n                RelayMessage(CInv(MSG_TX, hash), (CTransaction)tx);\n        }\n    }\n    if (!IsCoinBase())\n    {\n        uint256 hash = GetHash();\n        if (!txdb.ContainsTx(hash))\n        {\n            printf(\"Relaying wtx %s\\n\", hash.ToString().substr(0,10).c_str());\n            RelayMessage(CInv(MSG_TX, hash), (CTransaction)*this);\n        }\n    }\n}\n\nvoid CWalletTx::RelayWalletTransaction()\n{\n   CTxDB txdb(\"r\");\n   RelayWalletTransaction(txdb);\n}\n\nvoid CWallet::ResendWalletTransactions(bool fForce) {\n    int64 nCurrentTime = GetTime();\n\n    if(fForce || (nCurrentTime >= nNextResendTxTime)) {\n        /* Schedule the next resend time */\n        nNextResendTxTime = nCurrentTime + (5 * 60) + GetRand(30 * 60);\n    } else {\n        if(!fForce) return;\n    }\n\n    // Rebroadcast any of our txes that aren't in a block yet\n    printf(\"ResendWalletTransactions()\\n\");\n    CTxDB txdb(\"r\");\n    {\n        LOCK(cs_wallet);\n        // Sort them in chronological order\n        multimap<unsigned int, CWalletTx*> mapSorted;\n        BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n        {\n            CWalletTx& wtx = item.second;\n            // Don't rebroadcast until it's had plenty of time that\n            // it should have gotten in already by now.\n            if (nTimeBestReceived - (int64)wtx.nTimeReceived > 5 * 60)\n                mapSorted.insert(make_pair(wtx.nTimeReceived, &wtx));\n        }\n        BOOST_FOREACH(PAIRTYPE(const unsigned int, CWalletTx*)& item, mapSorted)\n        {\n            CWalletTx& wtx = *item.second;\n            wtx.RelayWalletTransaction(txdb);\n        }\n    }\n}\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Actions\n//\n\n/* Calculates either available or unconfirmed balance or both:\n * bit 0 = available balance;\n * bit 1 = unconfirmed balance\n * NOTE: this code makes use of TX_MATURITY rather than IsConfirmed() */\nint64 CWallet::GetBalance(uint nSettings) const {\n    int64 nTotal = 0;\n    LOCK(cs_wallet);\n    for(map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it) {\n        const CWalletTx* pcoin = &(*it).second;\n        int nDepth = pcoin->GetDepthInMainChain();\n        if((nSettings & 0x1) && (nDepth >= TX_MATURITY))\n          nTotal += pcoin->GetAvailableCredit();\n        if((nSettings & 0x2) && (nDepth < TX_MATURITY) && (nDepth >= 0))\n          nTotal += pcoin->GetAvailableCredit();\n    }\n    return(nTotal);\n}\n\n/* Calculates minted rewards, either immature or complete, for PoW:\n * bit 0 = PoW rewards;\n * bit 2 = immature only */\nint64 CWallet::GetMinted(uint nSettings) const {\n    int64 nTotal = 0;\n    LOCK(cs_wallet);\n    for(map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it) {\n        const CWalletTx* pcoin = &(*it).second;\n        if(((nSettings & 0x1) && pcoin->IsCoinBase())) {\n            int nDepth = pcoin->GetDepthInMainChain();\n            if(nDepth > 0) {\n                if(((nSettings & 0x4) && (nDepth < nBaseMaturity)) || !(nSettings & 0x4)) {\n                    /* PoW base transactions have zero debit */                \n                      nTotal += CWallet::GetCredit(*pcoin);\n                }\n            }\n        }\n    }\n    return(nTotal);\n}\n\n// populate vCoins with vector of spendable COutputs\nvoid CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl) const\n{\n    vCoins.clear();\n\n    {\n        LOCK(cs_wallet);\n        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        {\n            const CWalletTx* pcoin = &(*it).second;\n\n            if (!pcoin->IsFinal())\n                continue;\n\n            if (fOnlyConfirmed && !pcoin->IsConfirmed())\n                continue;\n\n            if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n                continue;\n\n            // If output is less than minimum value, then don't include transaction.\n            // This is to help deal with dust spam clogging up create transactions.\n            for(unsigned int i = 0; i < pcoin->vout.size(); i++)\n                if(!(pcoin->IsSpent(i)) &&\n                  IsMine(pcoin->vout[i]) &&\n                  !IsLockedCoin((*it).first, i) && \n                  (pcoin->vout[i].nValue >= nMinimumInputValue) &&\n                  (!coinControl || !coinControl->HasSelected() || coinControl->IsSelected((*it).first, i)))\n                    vCoins.push_back(COutput(pcoin, i, pcoin->GetDepthInMainChain()));\n        }\n    }\n}\n\nstatic void ApproximateBestSubset(vector<pair<int64, pair<const CWalletTx*,unsigned int> > >vValue, int64 nTotalLower, int64 nTargetValue,\n                                  vector<char>& vfBest, int64& nBest, int iterations = 1000)\n{\n    vector<char> vfIncluded;\n\n    vfBest.assign(vValue.size(), true);\n    nBest = nTotalLower;\n\n    for (int nRep = 0; nRep < iterations && nBest != nTargetValue; nRep++)\n    {\n        vfIncluded.assign(vValue.size(), false);\n        int64 nTotal = 0;\n        bool fReachedTarget = false;\n        for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)\n        {\n            for (unsigned int i = 0; i < vValue.size(); i++)\n            {\n                if (nPass == 0 ? rand() % 2 : !vfIncluded[i])\n                {\n                    nTotal += vValue[i].first;\n                    vfIncluded[i] = true;\n                    if (nTotal >= nTargetValue)\n                    {\n                        fReachedTarget = true;\n                        if (nTotal < nBest)\n                        {\n                            nBest = nTotal;\n                            vfBest = vfIncluded;\n                        }\n                        nTotal -= vValue[i].first;\n                        vfIncluded[i] = false;\n                    }\n                }\n            }\n        }\n    }\n}\n\nbool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfTheirs, vector<COutput> vCoins,\n                                 set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const\n{\n    setCoinsRet.clear();\n    nValueRet = 0;\n\n    // List of values less than target\n    pair<int64, pair<const CWalletTx*,unsigned int> > coinLowestLarger;\n    coinLowestLarger.first = std::numeric_limits<int64>::max();\n    coinLowestLarger.second.first = NULL;\n    vector<pair<int64, pair<const CWalletTx*,unsigned int> > > vValue;\n    int64 nTotalLower = 0;\n\n    random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n\n    BOOST_FOREACH(COutput output, vCoins)\n    {\n        const CWalletTx *pcoin = output.tx;\n\n        if (output.nDepth < (pcoin->IsFromMe() ? nConfMine : nConfTheirs))\n            continue;\n\n        int i = output.i;\n        int64 n = pcoin->vout[i].nValue;\n\n        pair<int64,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin, i));\n\n        if (n == nTargetValue)\n        {\n            setCoinsRet.insert(coin.second);\n            nValueRet += coin.first;\n            return true;\n        }\n        else if (n < nTargetValue + CENT)\n        {\n            vValue.push_back(coin);\n            nTotalLower += n;\n        }\n        else if (n < coinLowestLarger.first)\n        {\n            coinLowestLarger = coin;\n        }\n    }\n\n    if (nTotalLower == nTargetValue)\n    {\n        for (unsigned int i = 0; i < vValue.size(); ++i)\n        {\n            setCoinsRet.insert(vValue[i].second);\n            nValueRet += vValue[i].first;\n        }\n        return true;\n    }\n\n    if (nTotalLower < nTargetValue)\n    {\n        if (coinLowestLarger.second.first == NULL)\n            return false;\n        setCoinsRet.insert(coinLowestLarger.second);\n        nValueRet += coinLowestLarger.first;\n        return true;\n    }\n\n    // Solve subset sum by stochastic approximation\n    sort(vValue.rbegin(), vValue.rend(), CompareValueOnly());\n    vector<char> vfBest;\n    int64 nBest;\n\n    ApproximateBestSubset(vValue, nTotalLower, nTargetValue, vfBest, nBest, 1000);\n    if (nBest != nTargetValue && nTotalLower >= nTargetValue + CENT)\n        ApproximateBestSubset(vValue, nTotalLower, nTargetValue + CENT, vfBest, nBest, 1000);\n\n    // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,\n    //                                   or the next bigger coin is closer), return the bigger coin\n    if (coinLowestLarger.second.first &&\n        ((nBest != nTargetValue && nBest < nTargetValue + CENT) || coinLowestLarger.first <= nBest))\n    {\n        setCoinsRet.insert(coinLowestLarger.second);\n        nValueRet += coinLowestLarger.first;\n    }\n    else {\n        for (unsigned int i = 0; i < vValue.size(); i++)\n            if (vfBest[i])\n            {\n                setCoinsRet.insert(vValue[i].second);\n                nValueRet += vValue[i].first;\n            }\n\n        //// debug print\n        printf(\"SelectCoins() best subset: \");\n        for (unsigned int i = 0; i < vValue.size(); i++)\n            if (vfBest[i])\n                printf(\"%s \", FormatMoney(vValue[i].first).c_str());\n        printf(\"total %s\\n\", FormatMoney(nBest).c_str());\n    }\n\n    return true;\n}\n\nbool CWallet::SelectCoins(int64 nTargetValue, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet, const CCoinControl* coinControl) const\n{\n    vector<COutput> vCoins;\n    AvailableCoins(vCoins, true, coinControl);\n    \n    // Coin Control -> return all selected outputs \n    // (we want all selected to go into the transaction for sure)\n    if (coinControl && coinControl->HasSelected())\n    {\n        BOOST_FOREACH(const COutput& out, vCoins)\n        {\n            nValueRet += out.tx->vout[out.i].nValue;\n            setCoinsRet.insert(make_pair(out.tx, out.i));\n        }\n        return (nValueRet >= nTargetValue);\n    }\n\n    return (SelectCoinsMinConf(nTargetValue, 1, 6, vCoins, setCoinsRet, nValueRet) ||\n            SelectCoinsMinConf(nTargetValue, 1, 1, vCoins, setCoinsRet, nValueRet) ||\n            SelectCoinsMinConf(nTargetValue, 0, 1, vCoins, setCoinsRet, nValueRet));\n}\n\n\n\n\nbool CWallet::CreateTransaction(const vector<pair<CScript, int64> >& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, int64& nFeeRet, const CCoinControl* coinControl)\n{\n    int64 nValue = 0;\n    BOOST_FOREACH (const PAIRTYPE(CScript, int64)& s, vecSend)\n    {\n        if (nValue < 0)\n            return false;\n        nValue += s.second;\n    }\n    if (vecSend.empty() || nValue < 0)\n        return false;\n\n    wtxNew.BindWallet(this);\n\n    {\n        LOCK2(cs_main, cs_wallet);\n        // txdb must be opened before the mapWallet lock\n        CTxDB txdb(\"r\");\n        {\n            nFeeRet = nTransactionFee;\n            loop\n            {\n                wtxNew.vin.clear();\n                wtxNew.vout.clear();\n                wtxNew.fFromMe = true;\n\n                int64 nTotalValue = nValue + nFeeRet;\n                double dPriority = 0;\n                // vouts to the payees\n                BOOST_FOREACH (const PAIRTYPE(CScript, int64)& s, vecSend)\n                    wtxNew.vout.push_back(CTxOut(s.second, s.first));\n\n                // Choose coins to use\n                set<pair<const CWalletTx*,unsigned int> > setCoins;\n                int64 nValueIn = 0;\n                if(!SelectCoins(nTotalValue, setCoins, nValueIn, coinControl))\n                  return false;\n                BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins) {\n                    int64 nCredit = pcoin.first->vout[pcoin.second].nValue;\n                    dPriority += (double)nCredit * pcoin.first->GetDepthInMainChain();\n                }\n\n                int64 nChange = nValueIn - nValue - nFeeRet;\n\n                if(nChange >= TX_DUST) {\n\n                    // Fill a vout to ourself\n                    // TODO: pass in scriptChange instead of reservekey so\n                    // change transaction isn't always pay-to-bitcoin-address\n                    CScript scriptChange;\n\n                    // Coin Control: send the change to a custom address\n                    if(coinControl && !boost::get<CNoDestination>(&coinControl->destChange)) {\n\n                       // Select the Coin Control destination address\n                       scriptChange.SetDestination(coinControl->destChange);\n                       // Return the unused key pair to the pool\n                       reservekey.ReturnKey();\n\n                    } else {\n\n                    // Send the change to a new address\n\n// Note: We use a new key here to keep it from being obvious which side is the change.\n// The drawback is that by not reusing a previous key, the change may be lost if a\n// backup is restored, if the backup doesn't have the new private key for the change.\n// If we reused the old key, it would be possible to add code to look for and\n// rediscover unknown transactions that were written with keys of ours to recover\n// post-backup change.\n\n                        // Reserve a new key pair from key pool\n                        CPubKey vchPubKey = reservekey.GetReservedKey();\n\n                        scriptChange.SetDestination(vchPubKey.GetID());\n                    }\n\n                    // Insert the change at a random position\n                    vector<CTxOut>::iterator position = wtxNew.vout.begin()+GetRandInt(wtxNew.vout.size());\n                    wtxNew.vout.insert(position, CTxOut(nChange, scriptChange));\n\n                } else {\n\n                    // To avoid dust outputs, any change smaller\n                    // than TX_DUST is added to transaction fees\n                    nFeeRet += nChange;\n                    nChange  = 0;\n                    reservekey.ReturnKey();\n\n                }\n\n                // Fill vin\n                BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n                    wtxNew.vin.push_back(CTxIn(coin.first->GetHash(),coin.second));\n\n                // Sign\n                int nIn = 0;\n                BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n                    if (!SignSignature(*this, *coin.first, wtxNew, nIn++))\n                        return false;\n\n                // Limit size\n                unsigned int nTxSize = ::GetSerializeSize(*(CTransaction*)&wtxNew, SER_NETWORK, PROTOCOL_VERSION);\n                if(nTxSize >= MAX_BLOCK_SIZE_GEN/5) return false;\n                dPriority /= nTxSize;\n\n                // Check that enough fee is included\n                int64 nPayFee = nTransactionFee * (1 + (int64)nTxSize / 1000);\n                bool fAllowFree = CTransaction::AllowFree(dPriority);\n                int64 nMinFee = wtxNew.GetMinFee(nTxSize, fAllowFree, GMF_SEND);\n                if (nFeeRet < max(nPayFee, nMinFee))\n                {\n                    nFeeRet = max(nPayFee, nMinFee);\n                    continue;\n                }\n\n                // Fill vtxPrev by copying from previous transactions vtxPrev\n                wtxNew.AddSupportingTransactions(txdb);\n                wtxNew.fTimeReceivedIsTxTime = true;\n\n                break;\n            }\n        }\n    }\n    return true;\n}\n\nbool CWallet::CreateTransaction(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, CReserveKey& reservekey, int64& nFeeRet, const CCoinControl* coinControl)\n{\n    vector< pair<CScript, int64> > vecSend;\n    vecSend.push_back(make_pair(scriptPubKey, nValue));\n    return CreateTransaction(vecSend, wtxNew, reservekey, nFeeRet, coinControl);\n}\n\n// Call after CreateTransaction unless you want to abort\nbool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n{\n    {\n        LOCK2(cs_main, cs_wallet);\n        printf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n        {\n            // This is only to keep the database open to defeat the auto-flush for the\n            // duration of this scope.  This is the only place where this optimization\n            // maybe makes sense; please don't do it anywhere else.\n            CWalletDB* pwalletdb = fFileBacked ? new CWalletDB(strWalletFile,\"r\") : NULL;\n\n            // Take key pair from key pool so it won't be used again\n            reservekey.KeepKey();\n\n            // Add tx to wallet, because if it has change it's also ours,\n            // otherwise just for transaction history.\n            AddToWallet(wtxNew);\n\n            // Mark old coins as spent\n            set<CWalletTx*> setCoins;\n            BOOST_FOREACH(const CTxIn& txin, wtxNew.vin)\n            {\n                CWalletTx &coin = mapWallet[txin.prevout.hash];\n                coin.BindWallet(this);\n                coin.MarkSpent(txin.prevout.n);\n                coin.WriteToDisk();\n                NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED);\n            }\n\n            if (fFileBacked)\n                delete pwalletdb;\n        }\n\n        // Track how many getdata requests our transaction gets\n        mapRequestCount[wtxNew.GetHash()] = 0;\n\n        // Broadcast\n        CTxDB txdb(\"r\");\n        if(!wtxNew.AcceptToMemoryPool(txdb, true, false)) {\n            // This must not fail. The transaction has already been signed and recorded.\n            printf(\"CommitTransaction() : Error: Transaction not valid\");\n            return false;\n        }\n        wtxNew.RelayWalletTransaction();\n    }\n    return true;\n}\n\n\n\n\nstring CWallet::SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, bool fAskFee)\n{\n    CReserveKey reservekey(this);\n    int64 nFeeRequired;\n\n    if (IsLocked())\n    {\n        string strError = _(\"Error: Wallet locked, unable to create transaction  \");\n        printf(\"SendMoney() : %s\", strError.c_str());\n        return strError;\n    }\n    if (!CreateTransaction(scriptPubKey, nValue, wtxNew, reservekey, nFeeRequired))\n    {\n        string strError;\n        if (nValue + nFeeRequired > GetBalance(0x3))\n            strError = strprintf(_(\"Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds  \"), FormatMoney(nFeeRequired).c_str());\n        else\n            strError = _(\"Error: Transaction creation failed  \");\n        printf(\"SendMoney() : %s\", strError.c_str());\n        return strError;\n    }\n\n    if (fAskFee && !uiInterface.ThreadSafeAskFee(nFeeRequired, _(\"Sending...\")))\n        return \"ABORTED\";\n\n    if (!CommitTransaction(wtxNew, reservekey))\n        return _(\"Error: The transaction was rejected.  This might happen if some of the coins in your wallet were already spent, such as if you used a copy of wallet.dat and coins were spent in the copy but not marked as spent here.\");\n\n    return \"\";\n}\n\n\n\nstring CWallet::SendMoneyToDestination(const CTxDestination& address, int64 nValue, CWalletTx& wtxNew, bool fAskFee)\n{\n    // Check amount\n    if (nValue <= 0)\n        return _(\"Invalid amount\");\n    if (nValue + nTransactionFee > GetBalance(0x3))\n        return _(\"Insufficient funds\");\n\n    // Parse Bitcoin address\n    CScript scriptPubKey;\n    scriptPubKey.SetDestination(address);\n\n    return SendMoney(scriptPubKey, nValue, wtxNew, fAskFee);\n}\n\n\n\n\nint CWallet::LoadWallet(bool& fFirstRunRet)\n{\n    if (!fFileBacked)\n        return false;\n    fFirstRunRet = false;\n    int nLoadWalletRet = CWalletDB(strWalletFile,\"cr+\").LoadWallet(this);\n    if (nLoadWalletRet == DB_NEED_REWRITE)\n    {\n        if (CDB::Rewrite(strWalletFile, \"\\x04pool\"))\n        {\n            setKeyPool.clear();\n            // Note: can't top-up keypool here, because wallet is locked.\n            // User will be prompted to unlock wallet the next operation\n            // the requires a new key.\n        }\n        nLoadWalletRet = DB_NEED_REWRITE;\n    }\n\n    if (nLoadWalletRet != DB_LOAD_OK)\n        return nLoadWalletRet;\n    fFirstRunRet = !vchDefaultKey.IsValid();\n\n    CreateThread(ThreadFlushWalletDB, &strWalletFile);\n    return DB_LOAD_OK;\n}\n\n\nbool CWallet::SetAddressBookName(const CTxDestination& address, const string& strName)\n{\n    std::map<CTxDestination, std::string>::iterator mi = mapAddressBook.find(address);\n    mapAddressBook[address] = strName;\n    NotifyAddressBookChanged(this, address, strName, ::IsMine(*this, address), (mi == mapAddressBook.end()) ? CT_NEW : CT_UPDATED);\n    if (!fFileBacked)\n        return false;\n    return CWalletDB(strWalletFile).WriteName(CBitcoinAddress(address).ToString(), strName);\n}\n\nbool CWallet::DelAddressBookName(const CTxDestination& address)\n{\n    mapAddressBook.erase(address);\n    NotifyAddressBookChanged(this, address, \"\", ::IsMine(*this, address), CT_DELETED);\n    if (!fFileBacked)\n        return false;\n    return CWalletDB(strWalletFile).EraseName(CBitcoinAddress(address).ToString());\n}\n\n\nvoid CWallet::PrintWallet(const CBlock& block)\n{\n    {\n        LOCK(cs_wallet);\n        if (mapWallet.count(block.vtx[0].GetHash()))\n        {\n            CWalletTx& wtx = mapWallet[block.vtx[0].GetHash()];\n            printf(\"    mine:  %d  %d  %d\", wtx.GetDepthInMainChain(), wtx.GetBlocksToMaturity(), wtx.GetCredit());\n        }\n    }\n    printf(\"\\n\");\n}\n\nbool CWallet::GetTransaction(const uint256 &hashTx, CWalletTx& wtx)\n{\n    {\n        LOCK(cs_wallet);\n        map<uint256, CWalletTx>::iterator mi = mapWallet.find(hashTx);\n        if (mi != mapWallet.end())\n        {\n            wtx = (*mi).second;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool CWallet::SetDefaultKey(const CPubKey &vchPubKey)\n{\n    if (fFileBacked)\n    {\n        if (!CWalletDB(strWalletFile).WriteDefaultKey(vchPubKey))\n            return false;\n    }\n    vchDefaultKey = vchPubKey;\n    return true;\n}\n\nbool GetWalletFile(CWallet* pwallet, string &strWalletFileOut)\n{\n    if (!pwallet->fFileBacked)\n        return false;\n    strWalletFileOut = pwallet->strWalletFile;\n    return true;\n}\n\n//\n// Mark old keypool keys as used,\n// and generate all new keys\n//\nbool CWallet::NewKeyPool()\n{\n    {\n        LOCK(cs_wallet);\n        CWalletDB walletdb(strWalletFile);\n        BOOST_FOREACH(int64 nIndex, setKeyPool)\n            walletdb.ErasePool(nIndex);\n        setKeyPool.clear();\n\n        if (IsLocked())\n            return false;\n\n        int64 nKeys = max(GetArg(\"-keypool\", 100), (int64)0);\n        for (int i = 0; i < nKeys; i++)\n        {\n            int64 nIndex = i+1;\n            walletdb.WritePool(nIndex, CKeyPool(GenerateNewKey()));\n            setKeyPool.insert(nIndex);\n        }\n        printf(\"CWallet::NewKeyPool wrote %\"PRI64d\" new keys\\n\", nKeys);\n    }\n    return true;\n}\n\nbool CWallet::TopUpKeyPool()\n{\n    {\n        LOCK(cs_wallet);\n\n        if (IsLocked())\n            return false;\n\n        CWalletDB walletdb(strWalletFile);\n\n        // Top up key pool\n        unsigned int nTargetSize = max(GetArg(\"-keypool\", 100), 0LL);\n        while (setKeyPool.size() < (nTargetSize + 1))\n        {\n            int64 nEnd = 1;\n            if (!setKeyPool.empty())\n                nEnd = *(--setKeyPool.end()) + 1;\n            if (!walletdb.WritePool(nEnd, CKeyPool(GenerateNewKey())))\n                throw runtime_error(\"TopUpKeyPool() : writing generated key failed\");\n            setKeyPool.insert(nEnd);\n            printf(\"keypool added key %\"PRI64d\", size=%d\\n\", nEnd, setKeyPool.size());\n        }\n    }\n    return true;\n}\n\nvoid CWallet::ReserveKeyFromKeyPool(int64& nIndex, CKeyPool& keypool)\n{\n    nIndex = -1;\n    keypool.vchPubKey = CPubKey();\n    {\n        LOCK(cs_wallet);\n\n        if (!IsLocked())\n            TopUpKeyPool();\n\n        // Get the oldest key\n        if(setKeyPool.empty())\n            return;\n\n        CWalletDB walletdb(strWalletFile);\n\n        nIndex = *(setKeyPool.begin());\n        setKeyPool.erase(setKeyPool.begin());\n        if (!walletdb.ReadPool(nIndex, keypool))\n            throw runtime_error(\"ReserveKeyFromKeyPool() : read failed\");\n        if (!HaveKey(keypool.vchPubKey.GetID()))\n            throw runtime_error(\"ReserveKeyFromKeyPool() : unknown key in key pool\");\n        assert(keypool.vchPubKey.IsValid());\n        printf(\"keypool reserve %\"PRI64d\"\\n\", nIndex);\n    }\n}\n\nint64 CWallet::AddReserveKey(const CKeyPool& keypool)\n{\n    {\n        LOCK2(cs_main, cs_wallet);\n        CWalletDB walletdb(strWalletFile);\n\n        int64 nIndex = 1 + *(--setKeyPool.end());\n        if (!walletdb.WritePool(nIndex, keypool))\n            throw runtime_error(\"AddReserveKey() : writing added key failed\");\n        setKeyPool.insert(nIndex);\n        return nIndex;\n    }\n    return -1;\n}\n\nvoid CWallet::KeepKey(int64 nIndex)\n{\n    // Remove from key pool\n    if (fFileBacked)\n    {\n        CWalletDB walletdb(strWalletFile);\n        walletdb.ErasePool(nIndex);\n    }\n    printf(\"keypool keep %\"PRI64d\"\\n\", nIndex);\n}\n\nvoid CWallet::ReturnKey(int64 nIndex)\n{\n    // Return to key pool\n    {\n        LOCK(cs_wallet);\n        setKeyPool.insert(nIndex);\n    }\n    printf(\"keypool return %\"PRI64d\"\\n\", nIndex);\n}\n\nbool CWallet::GetKeyFromPool(CPubKey& result, bool fAllowReuse)\n{\n    int64 nIndex = 0;\n    CKeyPool keypool;\n    {\n        LOCK(cs_wallet);\n        ReserveKeyFromKeyPool(nIndex, keypool);\n        if (nIndex == -1)\n        {\n            if (fAllowReuse && vchDefaultKey.IsValid())\n            {\n                result = vchDefaultKey;\n                return true;\n            }\n            if (IsLocked()) return false;\n            result = GenerateNewKey();\n            return true;\n        }\n        KeepKey(nIndex);\n        result = keypool.vchPubKey;\n    }\n    return true;\n}\n\nint64 CWallet::GetOldestKeyPoolTime()\n{\n    int64 nIndex = 0;\n    CKeyPool keypool;\n    ReserveKeyFromKeyPool(nIndex, keypool);\n    if (nIndex == -1)\n        return GetTime();\n    ReturnKey(nIndex);\n    return keypool.nTime;\n}\n\nCPubKey CReserveKey::GetReservedKey()\n{\n    if(nIndex == -1) {\n        if(fDefaultKey) vchPubKey = pwallet->vchDefaultKey;\n        else {\n            CKeyPool keypool;\n            pwallet->ReserveKeyFromKeyPool(nIndex, keypool);\n            if(nIndex != -1) vchPubKey = keypool.vchPubKey;\n            else {\n                printf(\"CReserveKey::GetReservedKey(): key pool is empty, using the default key\\n\");\n                vchPubKey = pwallet->vchDefaultKey;\n            }\n        }\n    } \n    assert(vchPubKey.IsValid());\n    return vchPubKey;\n}\n\nvoid CReserveKey::KeepKey()\n{\n    if (nIndex != -1)\n        pwallet->KeepKey(nIndex);\n    nIndex = -1;\n    vchPubKey = CPubKey();\n}\n\nvoid CReserveKey::ReturnKey()\n{\n    if (nIndex != -1)\n        pwallet->ReturnKey(nIndex);\n    nIndex = -1;\n    vchPubKey = CPubKey();\n}\n\nvoid CWallet::GetAllReserveKeys(set<CKeyID>& setAddress)\n{\n    setAddress.clear();\n\n    CWalletDB walletdb(strWalletFile);\n\n    LOCK2(cs_main, cs_wallet);\n    BOOST_FOREACH(const int64& id, setKeyPool)\n    {\n        CKeyPool keypool;\n        if (!walletdb.ReadPool(id, keypool))\n            throw runtime_error(\"GetAllReserveKeyHashes() : read failed\");\n        assert(keypool.vchPubKey.IsValid());\n        CKeyID keyID = keypool.vchPubKey.GetID();\n        if (!HaveKey(keyID))\n            throw runtime_error(\"GetAllReserveKeyHashes() : unknown key in key pool\");\n        setAddress.insert(keyID);\n    }\n}\n\nvoid CWallet::UpdatedTransaction(const uint256 &hashTx)\n{\n    {\n        LOCK(cs_wallet);\n        // Only notify UI if this transaction is in this wallet\n        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(hashTx);\n        if (mi != mapWallet.end())\n            NotifyTransactionChanged(this, hashTx, CT_UPDATED);\n    }\n}\n\nvoid CWallet::LockCoin(COutPoint& output)\n{\n    setLockedCoins.insert(output);\n}\n\nvoid CWallet::UnlockCoin(COutPoint& output)\n{\n    setLockedCoins.erase(output);\n}\n\nvoid CWallet::UnlockAllCoins()\n{\n    setLockedCoins.clear();\n}\n\nbool CWallet::IsLockedCoin(uint256 hash, unsigned int n) const\n{\n    COutPoint outpt(hash, n);\n\n    return (setLockedCoins.count(outpt) > 0);\n}\n\nvoid CWallet::ListLockedCoins(std::vector<COutPoint>& vOutpts)\n{\n    for (std::set<COutPoint>::iterator it = setLockedCoins.begin();\n         it != setLockedCoins.end(); it++) {\n        COutPoint outpt = (*it);\n        vOutpts.push_back(outpt);\n    }\n}\n\n\n/* Checks for wallet vs. transaction index consistency;\n * reports any spent state inconsistency found and\n * (optionally) fixes the wallet according to the transaction index */\nvoid CWallet::FixSpentCoins(int& nMismatchFound, int& nOrphansFound, int64& nBalanceInQuestion,\n  bool fCheckOnly) {\n    nMismatchFound = 0;\n    nBalanceInQuestion = 0;\n    nOrphansFound = 0;\n\n    LOCK(cs_wallet);\n    vector<CWalletTx*> vCoins;\n    vCoins.reserve(mapWallet.size());\n    for(map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n      vCoins.push_back(&(*it).second);\n\n    CTxDB txdb(\"r\");\n    BOOST_FOREACH(CWalletTx* pcoin, vCoins) {\n        uint256 hash = pcoin->GetHash();\n        CTxIndex txindex;\n        uint n;\n\n        if(!txdb.ReadTxIndex(hash, txindex) && !pcoin->IsCoinBase())\n          continue;\n\n        for(n = 0; n < pcoin->vout.size(); n++) {\n            bool fUpdated = false;\n\n            if(IsMine(pcoin->vout[n])) {\n                if(pcoin->IsSpent(n) &&\n                  ((txindex.vSpent.size() <= n) || txindex.vSpent[n].IsNull())) {\n                    printf(\"FixSpentCoins() found lost coins %s %s[%d], %s\\n\",\n                      FormatMoney(pcoin->vout[n].nValue).c_str(), hash.ToString().c_str(), n,\n                        fCheckOnly? \"repair not attempted\" : \"repairing\");\n                    nMismatchFound++;\n                    nBalanceInQuestion += pcoin->vout[n].nValue;\n                    if(!fCheckOnly) {\n                        fUpdated = true;\n                        pcoin->MarkUnspent(n);\n                        pcoin->WriteToDisk();\n                    }\n                } else if(!pcoin->IsSpent(n) &&\n                  (txindex.vSpent.size() > n && !txindex.vSpent[n].IsNull())) {\n                    printf(\"FixSpentCoins() found spent coins %s %s[%d], %s\\n\",\n                      FormatMoney(pcoin->vout[n].nValue).c_str(), hash.ToString().c_str(), n,\n                        fCheckOnly? \"repair not attempted\" : \"repairing\");\n                    nMismatchFound++;\n                    nBalanceInQuestion += pcoin->vout[n].nValue;\n                    if(!fCheckOnly) {\n                        fUpdated = true;\n                        pcoin->MarkSpent(n);\n                        pcoin->WriteToDisk();\n                    }\n                }\n\n            }\n\n            if(fUpdated)\n              NotifyTransactionChanged(this, hash, CT_UPDATED);\n        }\n\n        if(pcoin->IsCoinBase() && (pcoin->GetDepthInMainChain() < 0)) {\n           nOrphansFound++;\n           if(!fCheckOnly) {\n               EraseFromWallet(hash);\n               NotifyTransactionChanged(this, hash, CT_DELETED);\n           }\n           printf(\"FixSpentCoins() %s orphaned generation tx %s\\n\",\n             fCheckOnly ? \"found\" : \"removed\", hash.ToString().c_str());\n        }\n    }\n}\n"], "filenames": ["src/main.cpp", "src/main.h", "src/rpcrawtransaction.cpp", "src/wallet.cpp"], "buggy_code_start_loc": [483, 719, 497, 1254], "buggy_code_end_loc": [3061, 1726, 499, 1256], "fixing_code_start_loc": [483, 719, 497, 1254], "fixing_code_end_loc": [3056, 1727, 499, 1256], "type": "CWE-404", "message": "A vulnerability was found in ghostlander Phoenixcoin. It has been classified as problematic. Affected is the function CTxMemPool::accept of the file src/main.cpp. The manipulation leads to denial of service. Upgrading to version 0.6.6.1-pxc is able to address this issue. The name of the patch is 987dd68f71a7d8276cef3b6c3d578fd4845b5699. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217068.", "other": {"cve": {"id": "CVE-2017-20154", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-30T21:15:09.787", "lastModified": "2023-01-06T19:02:44.550", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in ghostlander Phoenixcoin. It has been classified as problematic. Affected is the function CTxMemPool::accept of the file src/main.cpp. The manipulation leads to denial of service. Upgrading to version 0.6.6.1-pxc is able to address this issue. The name of the patch is 987dd68f71a7d8276cef3b6c3d578fd4845b5699. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217068."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:M/Au:S/C:N/I:N/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.3}, "baseSeverity": "LOW", "exploitabilityScore": 4.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-404"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:phoenixcoin_project:phoenixcoin:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.6.6.1", "matchCriteriaId": "EAC54760-4362-4DC9-B382-4C2A0AB219CF"}]}]}], "references": [{"url": "https://github.com/ghostlander/Phoenixcoin/commit/987dd68f71a7d8276cef3b6c3d578fd4845b5699", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ghostlander/Phoenixcoin/releases/tag/v0.6.6.1-pxc", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217068", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217068", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ghostlander/Phoenixcoin/commit/987dd68f71a7d8276cef3b6c3d578fd4845b5699"}}