{"buggy_code": ["<?php defined('BASEPATH') OR exit('No direct script access allowed');\n\n/* ==============================================================\n *\n * This file defines the abstract Task class, a subclass of which\n * must be defined for each implemented language.\n *\n * ==============================================================\n *\n * @copyright  2014 Richard Lobb, University of Canterbury\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nrequire_once('application/libraries/resultobject.php');\n\ndefine('ACTIVE_USERS', 1);  // The key for the shared memory active users array\ndefine('MAX_RETRIES', 8);   // Maximum retries (1 secs per retry), waiting for free user account\n\nclass OverloadException extends Exception {\n}\n\n\nabstract class Task {\n\n    // Symbolic constants as per ideone API\n\n    const RESULT_COMPILATION_ERROR = 11;\n    const RESULT_RUNTIME_ERROR = 12;\n    const RESULT_TIME_LIMIT   = 13;\n    const RESULT_SUCCESS      = 15;\n    const RESULT_MEMORY_LIMIT    = 17;\n    const RESULT_ILLEGAL_SYSCALL = 19;\n    const RESULT_INTERNAL_ERR = 20;\n    const RESULT_SERVER_OVERLOAD = 21;\n\n    const PROJECT_KEY = 'j';  // For ftok function. Irrelevant (?)\n\n    // Global default parameter values. Can be overridden by subclasses,\n    // and then further overridden by the individual run requests.\n    public $default_params = array(\n        'disklimit'     => 20,      // MB (for normal files)\n        'streamsize'    => 2,       // MB (for stdout/stderr)\n        'cputime'       => 5,       // secs\n        'memorylimit'   => 200,     // MB\n        'numprocs'      => 20,\n        'compileargs'   => array(),\n        'linkargs'      => array(),\n        'interpreterargs' => array(),\n        'runargs'       => array()\n    );\n\n\n    // Global minima settings for runguard sandbox when compiling.\n    // These override the default and task specific settings when a task\n    // is compiling in the sense that the parameter value used cannot be\n    // less than the one specified here.\n    public $min_params_compile = array(\n        'disklimit'     => 20,      // MB\n        'cputime'       => 2,       // secs\n        'memorylimit'   => 200,     // MB\n        'numprocs'      => 5        // processes\n    );\n\n    public $id;             // The task id - use the workdir basename\n    public $input;          // Stdin for this task\n    public $sourceFileName; // The name to give the source file\n    public $params;         // Request parameters\n\n    public $userId = null;  // The user id (number counting from 0).\n    public $user;           // The corresponding user name (e.g. jobe01).\n\n    public $cmpinfo = '';   // Output from compilation\n    public $time = 0;       // Execution time (secs)\n    public $memory = 0;     // Memory used (MB)\n    public $signal = 0;\n    public $stdout = '';    // Output from execution\n    public $stderr = '';\n    public $result = Task::RESULT_INTERNAL_ERR;  // Should get overwritten\n    public $workdir = '';   // The temporary working directory created in constructor\n\n    // ************************************************\n    //   MAIN METHODS THAT HANDLE THE FLOW OF ONE JOB\n    // ************************************************\n\n    public function __construct($filename, $input, $params) {\n        $this->input = $input;\n        $this->sourceFileName = $filename;\n        $this->params = $params;\n        $this->cmpinfo = '';  // Optimism (always look on the bright side of life).\n    }\n\n\n    // Grab any resources that will be needed to run the task. The contract\n    // is that if prepare_execution_environment has been called, then\n    // the close method will be called before the request using this object\n    // is finished.\n    //\n    // For all languages it is necessary to store the source code in a\n    // temporary file. A temporary directory is made to hold the source code.\n    //\n    // WARNING: the /home/jobe/runs directory (below) is generated by the installer.\n    // If you change that directory for some reason, make sure the directory\n    // exists, is owned by jobe, with group www-data (or whatever your web\n    // server user is) and has access rights of 771. If it's readable by\n    // any of the jobe<n> users, running programs will be able\n    // to hoover up other students' submissions.\n    public function prepare_execution_environment($sourceCode) {\n        // Create the temporary directory that will be used.\n        $this->workdir = tempnam(\"/home/jobe/runs\", \"jobe_\");\n        if (!unlink($this->workdir) || !mkdir($this->workdir)) {\n            log_message('error', 'LanguageTask constructor: error making temp directory');\n            throw new Exception(\"Task: error making temp directory (race error?)\");\n        }\n        chdir($this->workdir);\n\n        $this->id = basename($this->workdir);\n\n        // Save the source there.\n        if (empty($this->sourceFileName)) {\n            $this->sourceFileName = $this->defaultFileName($sourceCode);\n        }\n        file_put_contents($this->workdir . '/' . $this->sourceFileName, $sourceCode);\n\n        // Allocate one of the Jobe users.\n        $this->userId = $this->getFreeUser();\n        $this->user = sprintf(\"jobe%02d\", $this->userId);\n\n        // Give the user RW access.\n        exec(\"setfacl -m u:{$this->user}:rwX {$this->workdir}\");\n    }\n\n\n    // Load the specified files into the working directory.\n    // The file list is an array of (fileId, filename) pairs.\n    // Throws an exception if any are not present.\n    public function load_files($fileList) {\n        foreach ($fileList as $file) {\n            $fileId = $file[0];\n            $filename = $file[1];\n            $destPath = $this->workdir . '/' . $filename;\n            if (!FileCache::file_exists($fileId) ||\n               ($contents = FileCache::file_get_contents($fileId)) === FALSE ||\n               (file_put_contents($destPath, $contents)) === FALSE) {\n                throw new JobException('One or more of the specified files is missing/unavailable',\n                        'file(s) not found', 404);\n            }\n        }\n    }\n\n    // Compile the current source file in the current directory, saving\n    // the compiled output in a file $this->executableFileName.\n    // Sets $this->cmpinfo accordingly.\n    public abstract function compile();\n\n\n    // Execute this task, which must already have been compiled if necessary\n    public function execute() {\n        try {\n            $cmd = implode(' ', $this->getRunCommand());\n            list($this->stdout, $this->stderr) = $this->run_in_sandbox($cmd, false, $this->input);\n            $this->stderr = $this->filteredStderr();\n            $this->diagnose_result();  // Analyse output and set result\n        }\n        catch (OverloadException $e) {\n            $this->result = Task::RESULT_SERVER_OVERLOAD;\n            $this->stderr = $e->getMessage();\n        }\n        catch (Exception $e) {\n            $this->result = Task::RESULT_INTERNAL_ERR;\n            $this->stderr = $e->getMessage();\n        }\n    }\n\n\n    // Called to clean up task when done\n    public function close($deleteFiles = true) {\n\n        if ($this->userId !== null) {\n            exec(\"sudo /usr/bin/pkill -9 -u {$this->user}\"); // Kill any remaining processes\n            $this->removeTemporaryFiles($this->user);\n            $this->freeUser($this->userId);\n            $this->userId = null;\n            $this->user = null;\n        }\n\n        if ($deleteFiles && $this->workdir) {\n            $dir = $this->workdir;\n            exec(\"sudo rm -R $dir\");\n            $this->workdir = null;\n        }\n    }\n\n    // ************************************************\n    //    METHODS TO ALLOCATE AND FREE ONE JOBE USER\n    // ************************************************\n\n    // Find a currently unused jobe user account.\n    // Uses a shared memory segment containing one byte (used as a 'busy'\n    // boolean) for each of the possible user accounts.\n    // If no free accounts exist at present, the function sleeps for a\n    // second then retries, up to a maximum of MAX_RETRIES retries.\n    // Throws OverloadException if a free user cannot be found, otherwise\n    // returns an integer in the range 0 to jobe_max_users - 1 inclusive.\n    private function getFreeUser() {\n        global $CI;\n\n        $numUsers = $CI->config->item('jobe_max_users');\n        $key = ftok(__FILE__,  TASK::PROJECT_KEY);\n        $sem = sem_get($key);\n        $user = -1;\n        $retries = 0;\n        while ($user == -1) {  // Loop until we have a user (or an OverloadException is thrown)\n            sem_acquire($sem);\n            $shm = shm_attach($key);\n            if (!shm_has_var($shm, ACTIVE_USERS)) {\n                // First time since boot -- initialise active list\n                $active = array();\n                for($i = 0; $i < $numUsers; $i++) {\n                    $active[$i] = FALSE;\n                }\n                shm_put_var($shm, ACTIVE_USERS, $active);\n            }\n            $active = shm_get_var($shm, ACTIVE_USERS);\n            for ($user = 0; $user < $numUsers; $user++) {\n                if (!$active[$user]) {\n                    $active[$user] = TRUE;\n                    shm_put_var($shm, ACTIVE_USERS, $active);\n                    break;\n                }\n            }\n            shm_detach($shm);\n            sem_release($sem);\n            if ($user == $numUsers) {\n                $user = -1;\n                $retries += 1;\n                if ($retries <= MAX_RETRIES) {\n                    sleep(1);\n                } else {\n                    throw new OverloadException();\n                }\n            }\n        }\n        return $user;\n    }\n\n\n    // Mark the given user number (0 to jobe_max_users - 1) as free.\n    private function freeUser($userNum) {\n        $key = ftok(__FILE__, 'j');\n        $sem = sem_get($key);\n        sem_acquire($sem);\n        $shm = shm_attach($key);\n        $active = shm_get_var($shm, ACTIVE_USERS);\n        $active[$userNum] = FALSE;\n        shm_put_var($shm, ACTIVE_USERS, $active);\n        shm_detach($shm);\n        sem_release($sem);\n    }\n\n    // ************************************************\n    //                  HELPER METHODS\n    // ************************************************\n\n    /**\n     * Run the given shell command in the runguard sandbox, using the given\n     * string for stdin (if given).\n     * @param string $wrappedCmd The shell command to execute\n     * @param boolean $iscompile true if this is a compilation (in which case\n     * parameter values must be greater than or equal to those in $min_params_compile.\n     * @param string $stdin The string to use as standard input. If not given use /dev/null\n     * @return array a two element array of the standard output and the standard error\n     * from running the given command.\n     */\n    public function run_in_sandbox($wrappedCmd, $iscompile=true, $stdin=null) {\n        $filesize = 1000 * $this->getParam('disklimit', $iscompile); // MB -> kB\n        $streamsize = 1000 * $this->getParam('streamsize', $iscompile); // MB -> kB\n        $memsize = 1000 * $this->getParam('memorylimit', $iscompile);\n        $cputime = $this->getParam('cputime', $iscompile);\n        $killtime = 2 * $cputime; // Kill the job after twice the allowed cpu time\n        $numProcs = $this->getParam('numprocs', $iscompile) + 1; // The + 1 allows for the sh command below.\n        $sandboxCommandBits = array(\n                \"sudo \" . dirname(__FILE__)  . \"/../../runguard/runguard\",\n                \"--user={$this->user}\",\n                \"--group=jobe\",\n                \"--cputime=$cputime\",      // Seconds of execution time allowed\n                \"--time=$killtime\",        // Wall clock kill time\n                \"--filesize=$filesize\",    // Max file sizes\n                \"--nproc=$numProcs\",       // Max num processes/threads for this *user*\n                \"--no-core\",\n                \"--streamsize=$streamsize\");   // Max stdout/stderr sizes\n\n        if ($memsize != 0) {  // Special case: Matlab won't run with a memsize set. TODO: WHY NOT!\n            $sandboxCommandBits[] = \"--memsize=$memsize\";\n        }\n        $sandboxCmd = implode(' ', $sandboxCommandBits) .\n                ' sh -c ' . escapeshellarg($wrappedCmd) . ' >prog.out 2>prog.err';\n\n        // CD into the work directory and run the job\n        $workdir = $this->workdir;\n        chdir($workdir);\n\n        if ($stdin) {\n            $f = fopen('prog.in', 'w');\n            fwrite($f, $stdin);\n            fclose($f);\n            $sandboxCmd .= \" <prog.in\\n\";\n        }\n        else {\n            $sandboxCmd .= \" </dev/null\\n\";\n        }\n\n        file_put_contents('prog.cmd', $sandboxCmd);\n        exec('bash prog.cmd');\n\n        $output = file_get_contents(\"$workdir/prog.out\");\n        if (file_exists(\"{$this->workdir}/prog.err\")) {\n            $stderr = file_get_contents(\"{$this->workdir}/prog.err\");\n        } else {\n            $stderr = '';\n        }\n        return array($output, $stderr);\n    }\n\n\n    /*\n     * Get the value of the job parameter $key, which is taken from the\n     * value copied into $this from the run request if present of from the\n     * system defaults otherwise.\n     * If $iscompile is true and the parameter value is less than that specified\n     * in $min_params_compile (except if it's 0 meaning no limit), the minimum\n     * value is used instead.\n     */\n    protected function getParam($key, $iscompile=false) {\n        if (isset($this->params) && array_key_exists($key, $this->params)) {\n            $param = $this->params[$key];\n        } else {\n            $param = $this->default_params[$key];\n        }\n        // ** BUG ** The min_params_compile value is being applied even if\n        // this is not a compile. I'm reluctant to fix, however, as it may\n        // break existing questions with inappropriately low resource settings.\n        if ($param != 0 && array_key_exists($key, $this->min_params_compile) &&\n                $this->min_params_compile[$key] > $param) {\n            $param = $this->min_params_compile[$key];\n        }\n        return $param;\n    }\n\n\n    // Check if PHP exec environment includes a PATH. If not, set up a\n    // default, or gcc misbehaves. [Thanks to Binoj D for this bug fix,\n    // needed on his CentOS system.]\n    protected function setPath() {\n        $envVars = array();\n        exec('printenv', $envVars);\n        $hasPath = FALSE;\n        foreach ($envVars as $var) {\n            if (strpos($var, 'PATH=') === 0) {\n                $hasPath = TRUE;\n                break;\n            }\n        }\n        if (!$hasPath) {\n            putenv(\"PATH=/sbin:/bin:/usr/sbin:/usr/bin\");\n        }\n    }\n\n\n    // Return the Linux command to use to run the current job with the given\n    // standard input. It's an array of strings, which when joined with a\n    // a space character makes a bash command. The default is to use the\n    // name of the executable from getExecutablePath() followed by the strings\n    // in the 'interpreterargs' parameter followed by the name of the target file\n    // as returned by getTargetFile() followed by the strings in the\n    // 'runargs' parameter. For compiled languages, getExecutablePath\n    // should generally return the path to the compiled object file and\n    // getTargetFile() should return the empty string. The interpreterargs\n    // and runargs parameters are then just added (in that order) to the\n    // run command. For interpreted languages getExecutablePath should return\n    // the path to the interpreter and getTargetFile() should return the\n    // name of the file to be interpreted (in the current directory).\n    // This design allows for commands like java -Xss256k thing -blah.\n    public function getRunCommand() {\n        $cmd = array($this->getExecutablePath());\n        $cmd = array_merge($cmd, $this->getParam('interpreterargs'));\n        if ($this->getTargetFile()) {\n            $cmd[] = $this->getTargetFile();\n        }\n        $cmd = array_merge($cmd, $this->getParam('runargs'));\n        return $cmd;\n    }\n\n\n    // Return a suitable default filename for the given sourcecode.\n    // Usually of form prog.py, prog.cpp etc but Java is a special case.\n    public abstract function defaultFileName($sourcecode);\n\n\n    // Return the path to the executable that runs this job. For compiled\n    // languages this will be the output from the compilation. For interpreted\n    // languages it will be the path to the interpreter or JVM etc.\n    public abstract function getExecutablePath();\n\n\n    // Return the name of the so called \"target file\", which will typically be empty\n    // for compiled languages and will be the name of the file to be interpreted\n    // (usually just $this->executableFileName) for interpreted languages.\n    public abstract function getTargetFile();\n\n\n    // Override the following function if the output from executing a program\n    // in this language needs post-filtering to remove stuff like\n    // header output.\n    public function filteredStdout() {\n        return $this->stdout;\n    }\n\n\n    // Override the following function if the stderr from executing a program\n    // in this language needs post-filtering to remove stuff like\n    // backspaces and bells.\n    public function filteredStderr() {\n        return $this->stderr;\n    }\n\n\n    // Called after each run to set the task result value. Default is to\n    // set the result to SUCCESS if there's no stderr output or to timelimit\n    // exceeded if the appropriate warning message is found in stdout or\n    // to runtime error otherwise.\n    // Note that Runguard does not identify memorylimit exceeded as a special\n    // type of runtime error so that value is not returned by default.\n\n    // Subclasses may wish to add further postprocessing, e.g. for memory\n    // limit exceeded if the language identifies this specifically.\n    public function diagnose_result() {\n        if (strlen($this->filteredStderr())) {\n            $this->result = TASK::RESULT_RUNTIME_ERROR;\n        } else {\n            $this->result = TASK::RESULT_SUCCESS;\n        }\n\n        // Refine RuntimeError if possible\n        if (strpos($this->stderr, \"warning: timelimit exceeded\")) {\n            $this->result = Task::RESULT_TIME_LIMIT;\n            $this->signal = 9;\n            $this->stderr = '';\n        } else if(strpos($this->stderr, \"warning: command terminated with signal 11\")) {\n            $this->signal = 11;\n            $this->stderr = '';\n        }\n    }\n\n\n    // Return the JobeAPI result object to describe the state of this task\n    public function resultObject() {\n        if ($this->cmpinfo) {\n            $this->result = Task::RESULT_COMPILATION_ERROR;\n        }\n        return new ResultObject(\n                $this->workdir,\n                $this->result,\n                $this->cmpinfo,\n                $this->filteredStdout(),\n                $this->filteredStderr()\n        );\n    }\n\n\n    // Remove any temporary files created by the given user on completion\n    // of a run\n    protected function removeTemporaryFiles($user) {\n        global $CI;\n        $path = $CI->config->item('clean_up_path');\n        $dirs = explode(';', $path);\n        foreach($dirs as $dir) {\n            exec(\"sudo /usr/bin/find $dir/ -user $user -delete\");\n        }\n    }\n\n    // ************************************************\n    //  METHODS FOR DIAGNOSING THE AVAILABLE LANGUAGES\n    // ************************************************\n\n    // Return a two-element array of the shell command to be run to obtain\n    // a version number and the RE pattern with which to extract the version\n    // string from the output. This should have a capturing parenthesised\n    // group so that $matches[1] is the required string after a call to\n    // preg_match. See getVersion below for details.\n    // Should be implemented by all subclasses. [Older versions of PHP\n    // don't allow me to declare this abstract. But it is!!]\n    public static function getVersionCommand() {}\n\n\n    // Return a string giving the version of language supported by this\n    // particular Language/Task.\n    // Return NULL if the version command (supplied by the subclass's\n    // getVersionCommand) fails or produces no output. This can be interpreted\n    // as a non-existent language that should be removed from the list of\n    // languages handled by this Jobe server.\n    // If the version command runs but yields a result in\n    // an unexpected format, returns the string \"Unknown\".\n    public static function getVersion() {\n        list($command, $pattern) = static::getVersionCommand();\n        $output = array();\n        $retvalue = null;\n        exec($command . ' 2>&1', $output, $retvalue);\n        if ($retvalue != 0 || count($output) == 0) {\n            return NULL;\n        } else {\n            $matches = array();\n            $allOutput = implode(\"\\n\", $output);\n            $isMatch = preg_match($pattern, $allOutput, $matches);\n            return $isMatch ? $matches[1] : \"Unknown\";\n        }\n    }\n}\n"], "fixing_code": ["<?php defined('BASEPATH') OR exit('No direct script access allowed');\n\n/* ==============================================================\n *\n * This file defines the abstract Task class, a subclass of which\n * must be defined for each implemented language.\n *\n * ==============================================================\n *\n * @copyright  2014 Richard Lobb, University of Canterbury\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nrequire_once('application/libraries/resultobject.php');\n\ndefine('ACTIVE_USERS', 1);  // The key for the shared memory active users array\ndefine('MAX_RETRIES', 8);   // Maximum retries (1 secs per retry), waiting for free user account\n\nclass OverloadException extends Exception {\n}\n\n\nabstract class Task {\n\n    // Symbolic constants as per ideone API\n\n    const RESULT_COMPILATION_ERROR = 11;\n    const RESULT_RUNTIME_ERROR = 12;\n    const RESULT_TIME_LIMIT   = 13;\n    const RESULT_SUCCESS      = 15;\n    const RESULT_MEMORY_LIMIT    = 17;\n    const RESULT_ILLEGAL_SYSCALL = 19;\n    const RESULT_INTERNAL_ERR = 20;\n    const RESULT_SERVER_OVERLOAD = 21;\n\n    const PROJECT_KEY = 'j';  // For ftok function. Irrelevant (?)\n\n    // Global default parameter values. Can be overridden by subclasses,\n    // and then further overridden by the individual run requests.\n    public $default_params = array(\n        'disklimit'     => 20,      // MB (for normal files)\n        'streamsize'    => 2,       // MB (for stdout/stderr)\n        'cputime'       => 5,       // secs\n        'memorylimit'   => 200,     // MB\n        'numprocs'      => 20,\n        'compileargs'   => array(),\n        'linkargs'      => array(),\n        'interpreterargs' => array(),\n        'runargs'       => array()\n    );\n\n\n    // Global minima settings for runguard sandbox when compiling.\n    // These override the default and task specific settings when a task\n    // is compiling in the sense that the parameter value used cannot be\n    // less than the one specified here.\n    public $min_params_compile = array(\n        'disklimit'     => 20,      // MB\n        'cputime'       => 2,       // secs\n        'memorylimit'   => 200,     // MB\n        'numprocs'      => 5        // processes\n    );\n\n    public $id;             // The task id - use the workdir basename\n    public $input;          // Stdin for this task\n    public $sourceFileName; // The name to give the source file\n    public $params;         // Request parameters\n\n    public $userId = null;  // The user id (number counting from 0).\n    public $user;           // The corresponding user name (e.g. jobe01).\n\n    public $cmpinfo = '';   // Output from compilation\n    public $time = 0;       // Execution time (secs)\n    public $memory = 0;     // Memory used (MB)\n    public $signal = 0;\n    public $stdout = '';    // Output from execution\n    public $stderr = '';\n    public $result = Task::RESULT_INTERNAL_ERR;  // Should get overwritten\n    public $workdir = '';   // The temporary working directory created in constructor\n\n    // ************************************************\n    //   MAIN METHODS THAT HANDLE THE FLOW OF ONE JOB\n    // ************************************************\n\n    public function __construct($filename, $input, $params) {\n        $this->input = $input;\n        $this->sourceFileName = $filename;\n        $this->params = $params;\n        $this->cmpinfo = '';  // Optimism (always look on the bright side of life).\n    }\n\n\n    // Grab any resources that will be needed to run the task. The contract\n    // is that if prepare_execution_environment has been called, then\n    // the close method will be called before the request using this object\n    // is finished.\n    //\n    // For all languages it is necessary to store the source code in a\n    // temporary file. A temporary directory is made to hold the source code.\n    //\n    // WARNING: the /home/jobe/runs directory (below) is generated by the installer.\n    // If you change that directory for some reason, make sure the directory\n    // exists, is owned by jobe, with group www-data (or whatever your web\n    // server user is) and has access rights of 771. If it's readable by\n    // any of the jobe<n> users, running programs will be able\n    // to hoover up other students' submissions.\n    public function prepare_execution_environment($sourceCode) {\n        // Create the temporary directory that will be used.\n        $this->workdir = tempnam(\"/home/jobe/runs\", \"jobe_\");\n        if (!unlink($this->workdir) || !mkdir($this->workdir)) {\n            log_message('error', 'LanguageTask constructor: error making temp directory');\n            throw new Exception(\"Task: error making temp directory (race error?)\");\n        }\n        chdir($this->workdir);\n\n        $this->id = basename($this->workdir);\n\n        // Save the source there.\n        if (empty($this->sourceFileName)) {\n            $this->sourceFileName = $this->defaultFileName($sourceCode);\n        }\n        file_put_contents($this->workdir . '/' . $this->sourceFileName, $sourceCode);\n\n        // Allocate one of the Jobe users.\n        $this->userId = $this->getFreeUser();\n        $this->user = sprintf(\"jobe%02d\", $this->userId);\n\n        // Give the user RW access.\n        exec(\"setfacl -m u:{$this->user}:rwX {$this->workdir}\");\n    }\n\n\n    // Load the specified files into the working directory.\n    // The file list is an array of (fileId, filename) pairs.\n    // Throws an exception if any are not present.\n    public function load_files($fileList) {\n        foreach ($fileList as $file) {\n            $fileId = $file[0];\n            $filename = $file[1];\n            $destPath = $this->workdir . '/' . $filename;\n            if (!FileCache::file_exists($fileId) ||\n               ($contents = FileCache::file_get_contents($fileId)) === FALSE ||\n               (file_put_contents($destPath, $contents)) === FALSE) {\n                throw new JobException('One or more of the specified files is missing/unavailable',\n                        'file(s) not found', 404);\n            }\n        }\n    }\n\n    // Compile the current source file in the current directory, saving\n    // the compiled output in a file $this->executableFileName.\n    // Sets $this->cmpinfo accordingly.\n    public abstract function compile();\n\n\n    // Execute this task, which must already have been compiled if necessary\n    public function execute() {\n        try {\n            $cmd = implode(' ', $this->getRunCommand());\n            list($this->stdout, $this->stderr) = $this->run_in_sandbox($cmd, false, $this->input);\n            $this->stderr = $this->filteredStderr();\n            $this->diagnose_result();  // Analyse output and set result\n        }\n        catch (OverloadException $e) {\n            $this->result = Task::RESULT_SERVER_OVERLOAD;\n            $this->stderr = $e->getMessage();\n        }\n        catch (Exception $e) {\n            $this->result = Task::RESULT_INTERNAL_ERR;\n            $this->stderr = $e->getMessage();\n        }\n    }\n\n\n    // Called to clean up task when done\n    public function close($deleteFiles = true) {\n\n        if ($this->userId !== null) {\n            exec(\"sudo /usr/bin/pkill -9 -u {$this->user}\"); // Kill any remaining processes\n            $this->removeTemporaryFiles($this->user);\n            $this->freeUser($this->userId);\n            $this->userId = null;\n            $this->user = null;\n        }\n\n        if ($deleteFiles && $this->workdir) {\n            $dir = $this->workdir;\n            exec(\"sudo rm -R $dir\");\n            $this->workdir = null;\n        }\n    }\n\n    // ************************************************\n    //    METHODS TO ALLOCATE AND FREE ONE JOBE USER\n    // ************************************************\n\n    // Find a currently unused jobe user account.\n    // Uses a shared memory segment containing one byte (used as a 'busy'\n    // boolean) for each of the possible user accounts.\n    // If no free accounts exist at present, the function sleeps for a\n    // second then retries, up to a maximum of MAX_RETRIES retries.\n    // Throws OverloadException if a free user cannot be found, otherwise\n    // returns an integer in the range 0 to jobe_max_users - 1 inclusive.\n    private function getFreeUser() {\n        global $CI;\n\n        $numUsers = $CI->config->item('jobe_max_users');\n        $key = ftok(__FILE__,  TASK::PROJECT_KEY);\n        $sem = sem_get($key);\n        $user = -1;\n        $retries = 0;\n        while ($user == -1) {  // Loop until we have a user (or an OverloadException is thrown)\n            sem_acquire($sem);\n            $shm = shm_attach($key);\n            if (!shm_has_var($shm, ACTIVE_USERS)) {\n                // First time since boot -- initialise active list\n                $active = array();\n                for($i = 0; $i < $numUsers; $i++) {\n                    $active[$i] = FALSE;\n                }\n                shm_put_var($shm, ACTIVE_USERS, $active);\n            }\n            $active = shm_get_var($shm, ACTIVE_USERS);\n            for ($user = 0; $user < $numUsers; $user++) {\n                if (!$active[$user]) {\n                    $active[$user] = TRUE;\n                    shm_put_var($shm, ACTIVE_USERS, $active);\n                    break;\n                }\n            }\n            shm_detach($shm);\n            sem_release($sem);\n            if ($user == $numUsers) {\n                $user = -1;\n                $retries += 1;\n                if ($retries <= MAX_RETRIES) {\n                    sleep(1);\n                } else {\n                    throw new OverloadException();\n                }\n            }\n        }\n        return $user;\n    }\n\n\n    // Mark the given user number (0 to jobe_max_users - 1) as free.\n    private function freeUser($userNum) {\n        $key = ftok(__FILE__, 'j');\n        $sem = sem_get($key);\n        sem_acquire($sem);\n        $shm = shm_attach($key);\n        $active = shm_get_var($shm, ACTIVE_USERS);\n        $active[$userNum] = FALSE;\n        shm_put_var($shm, ACTIVE_USERS, $active);\n        shm_detach($shm);\n        sem_release($sem);\n    }\n\n    // ************************************************\n    //                  HELPER METHODS\n    // ************************************************\n\n    /**\n     * Run the given shell command in the runguard sandbox, using the given\n     * string for stdin (if given).\n     * @param string $wrappedCmd The shell command to execute\n     * @param boolean $iscompile true if this is a compilation (in which case\n     * parameter values must be greater than or equal to those in $min_params_compile.\n     * @param string $stdin The string to use as standard input. If not given use /dev/null\n     * @return array a two element array of the standard output and the standard error\n     * from running the given command.\n     */\n    public function run_in_sandbox($wrappedCmd, $iscompile=true, $stdin=null) {\n        $filesize = 1000 * $this->getParam('disklimit', $iscompile); // MB -> kB\n        $streamsize = 1000 * $this->getParam('streamsize', $iscompile); // MB -> kB\n        $memsize = 1000 * $this->getParam('memorylimit', $iscompile);\n        $cputime = $this->getParam('cputime', $iscompile);\n        $killtime = 2 * $cputime; // Kill the job after twice the allowed cpu time\n        $numProcs = $this->getParam('numprocs', $iscompile) + 1; // The + 1 allows for the sh command below.\n        $sandboxCommandBits = array(\n                \"sudo \" . dirname(__FILE__)  . \"/../../runguard/runguard\",\n                \"--user={$this->user}\",\n                \"--group=jobe\",\n                \"--cputime=$cputime\",      // Seconds of execution time allowed\n                \"--time=$killtime\",        // Wall clock kill time\n                \"--filesize=$filesize\",    // Max file sizes\n                \"--nproc=$numProcs\",       // Max num processes/threads for this *user*\n                \"--no-core\",\n                \"--streamsize=$streamsize\");   // Max stdout/stderr sizes\n\n        if ($memsize != 0) {  // Special case: Matlab won't run with a memsize set. TODO: WHY NOT!\n            $sandboxCommandBits[] = \"--memsize=$memsize\";\n        }\n        $sandboxCmd = implode(' ', $sandboxCommandBits) .\n                ' sh -c ' . escapeshellarg($wrappedCmd) . ' >prog.out 2>prog.err';\n\n        // CD into the work directory and run the job\n        $workdir = $this->workdir;\n        chdir($workdir);\n\n        if ($stdin) {\n            $f = fopen('prog.in', 'w');\n            fwrite($f, $stdin);\n            fclose($f);\n            $sandboxCmd .= \" <prog.in\\n\";\n        }\n        else {\n            $sandboxCmd .= \" </dev/null\\n\";\n        }\n\n        file_put_contents('prog.cmd', $sandboxCmd);\n        exec('bash prog.cmd');\n\n        $output = file_get_contents(\"$workdir/prog.out\");\n        if (file_exists(\"{$this->workdir}/prog.err\")) {\n            $stderr = file_get_contents(\"{$this->workdir}/prog.err\");\n        } else {\n            $stderr = '';\n        }\n        return array($output, $stderr);\n    }\n\n\n    /*\n     * Get the value of the job parameter $key, which is taken from the\n     * value copied into $this from the run request if present or from the\n     * system defaults otherwise.\n     * If a non-numeric value is provided for a parameter that has a numeric\n     * default, the default is used instead. This prevents command injection\n     * as per issue #39 (https://github.com/trampgeek/jobe/issues/39). Thanks\n     * Marlon (myxl).\n     * If $iscompile is true and the parameter value is less than that specified\n     * in $min_params_compile (except if it's 0 meaning no limit), the minimum\n     * value is used instead.\n     */\n    protected function getParam($key, $iscompile=false) {\n        $default = $this->default_params[$key];\n        if (isset($this->params) && array_key_exists($key, $this->params)) {\n            $param = $this->params[$key];\n            if (is_numeric($default) && !is_numeric($param)) {\n                $param = $default; // Prevent command injection attacks.\n            }\n        } else {\n            $param = $default;\n        }\n        // ** BUG ** The min_params_compile value is being applied even if\n        // this is not a compile. I'm reluctant to fix, however, as it may\n        // break existing questions with inappropriately low resource settings.\n        if ($param != 0 && array_key_exists($key, $this->min_params_compile) &&\n                $this->min_params_compile[$key] > $param) {\n            $param = $this->min_params_compile[$key];\n        }\n        return $param;\n    }\n\n\n    \n    // Check if PHP exec environment includes a PATH. If not, set up a\n    // default, or gcc misbehaves. [Thanks to Binoj D for this bug fix,\n    // needed on his CentOS system.]\n    protected function setPath() {\n        $envVars = array();\n        exec('printenv', $envVars);\n        $hasPath = FALSE;\n        foreach ($envVars as $var) {\n            if (strpos($var, 'PATH=') === 0) {\n                $hasPath = TRUE;\n                break;\n            }\n        }\n        if (!$hasPath) {\n            putenv(\"PATH=/sbin:/bin:/usr/sbin:/usr/bin\");\n        }\n    }\n\n\n    // Return the Linux command to use to run the current job with the given\n    // standard input. It's an array of strings, which when joined with a\n    // a space character makes a bash command. The default is to use the\n    // name of the executable from getExecutablePath() followed by the strings\n    // in the 'interpreterargs' parameter followed by the name of the target file\n    // as returned by getTargetFile() followed by the strings in the\n    // 'runargs' parameter. For compiled languages, getExecutablePath\n    // should generally return the path to the compiled object file and\n    // getTargetFile() should return the empty string. The interpreterargs\n    // and runargs parameters are then just added (in that order) to the\n    // run command. For interpreted languages getExecutablePath should return\n    // the path to the interpreter and getTargetFile() should return the\n    // name of the file to be interpreted (in the current directory).\n    // This design allows for commands like java -Xss256k thing -blah.\n    public function getRunCommand() {\n        $cmd = array($this->getExecutablePath());\n        $cmd = array_merge($cmd, $this->getParam('interpreterargs'));\n        if ($this->getTargetFile()) {\n            $cmd[] = $this->getTargetFile();\n        }\n        $cmd = array_merge($cmd, $this->getParam('runargs'));\n        return $cmd;\n    }\n\n\n    // Return a suitable default filename for the given sourcecode.\n    // Usually of form prog.py, prog.cpp etc but Java is a special case.\n    public abstract function defaultFileName($sourcecode);\n\n\n    // Return the path to the executable that runs this job. For compiled\n    // languages this will be the output from the compilation. For interpreted\n    // languages it will be the path to the interpreter or JVM etc.\n    public abstract function getExecutablePath();\n\n\n    // Return the name of the so called \"target file\", which will typically be empty\n    // for compiled languages and will be the name of the file to be interpreted\n    // (usually just $this->executableFileName) for interpreted languages.\n    public abstract function getTargetFile();\n\n\n    // Override the following function if the output from executing a program\n    // in this language needs post-filtering to remove stuff like\n    // header output.\n    public function filteredStdout() {\n        return $this->stdout;\n    }\n\n\n    // Override the following function if the stderr from executing a program\n    // in this language needs post-filtering to remove stuff like\n    // backspaces and bells.\n    public function filteredStderr() {\n        return $this->stderr;\n    }\n\n\n    // Called after each run to set the task result value. Default is to\n    // set the result to SUCCESS if there's no stderr output or to timelimit\n    // exceeded if the appropriate warning message is found in stdout or\n    // to runtime error otherwise.\n    // Note that Runguard does not identify memorylimit exceeded as a special\n    // type of runtime error so that value is not returned by default.\n\n    // Subclasses may wish to add further postprocessing, e.g. for memory\n    // limit exceeded if the language identifies this specifically.\n    public function diagnose_result() {\n        if (strlen($this->filteredStderr())) {\n            $this->result = TASK::RESULT_RUNTIME_ERROR;\n        } else {\n            $this->result = TASK::RESULT_SUCCESS;\n        }\n\n        // Refine RuntimeError if possible\n        if (strpos($this->stderr, \"warning: timelimit exceeded\")) {\n            $this->result = Task::RESULT_TIME_LIMIT;\n            $this->signal = 9;\n            $this->stderr = '';\n        } else if(strpos($this->stderr, \"warning: command terminated with signal 11\")) {\n            $this->signal = 11;\n            $this->stderr = '';\n        }\n    }\n\n\n    // Return the JobeAPI result object to describe the state of this task\n    public function resultObject() {\n        if ($this->cmpinfo) {\n            $this->result = Task::RESULT_COMPILATION_ERROR;\n        }\n        return new ResultObject(\n                $this->workdir,\n                $this->result,\n                $this->cmpinfo,\n                $this->filteredStdout(),\n                $this->filteredStderr()\n        );\n    }\n\n\n    // Remove any temporary files created by the given user on completion\n    // of a run\n    protected function removeTemporaryFiles($user) {\n        global $CI;\n        $path = $CI->config->item('clean_up_path');\n        $dirs = explode(';', $path);\n        foreach($dirs as $dir) {\n            exec(\"sudo /usr/bin/find $dir/ -user $user -delete\");\n        }\n    }\n\n    // ************************************************\n    //  METHODS FOR DIAGNOSING THE AVAILABLE LANGUAGES\n    // ************************************************\n\n    // Return a two-element array of the shell command to be run to obtain\n    // a version number and the RE pattern with which to extract the version\n    // string from the output. This should have a capturing parenthesised\n    // group so that $matches[1] is the required string after a call to\n    // preg_match. See getVersion below for details.\n    // Should be implemented by all subclasses. [Older versions of PHP\n    // don't allow me to declare this abstract. But it is!!]\n    public static function getVersionCommand() {}\n\n\n    // Return a string giving the version of language supported by this\n    // particular Language/Task.\n    // Return NULL if the version command (supplied by the subclass's\n    // getVersionCommand) fails or produces no output. This can be interpreted\n    // as a non-existent language that should be removed from the list of\n    // languages handled by this Jobe server.\n    // If the version command runs but yields a result in\n    // an unexpected format, returns the string \"Unknown\".\n    public static function getVersion() {\n        list($command, $pattern) = static::getVersionCommand();\n        $output = array();\n        $retvalue = null;\n        exec($command . ' 2>&1', $output, $retvalue);\n        if ($retvalue != 0 || count($output) == 0) {\n            return NULL;\n        } else {\n            $matches = array();\n            $allOutput = implode(\"\\n\", $output);\n            $isMatch = preg_match($pattern, $allOutput, $matches);\n            return $isMatch ? $matches[1] : \"Unknown\";\n        }\n    }\n}\n"], "filenames": ["application/libraries/LanguageTask.php"], "buggy_code_start_loc": [327], "buggy_code_end_loc": [349], "fixing_code_start_loc": [327], "fixing_code_end_loc": [359], "type": "CWE-77", "message": "A vulnerability was found in trampgeek jobe up to 1.6.x and classified as critical. This issue affects the function run_in_sandbox of the file application/libraries/LanguageTask.php. The manipulation leads to command injection. Upgrading to version 1.7.0 is able to address this issue. The name of the patch is 8f43daf50c943b98eaf0c542da901a4a16e85b02. It is recommended to upgrade the affected component. The identifier VDB-217553 was assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2020-36642", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-06T11:15:09.443", "lastModified": "2023-01-12T15:52:22.447", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in trampgeek jobe up to 1.6.x and classified as critical. This issue affects the function run_in_sandbox of the file application/libraries/LanguageTask.php. The manipulation leads to command injection. Upgrading to version 1.7.0 is able to address this issue. The name of the patch is 8f43daf50c943b98eaf0c542da901a4a16e85b02. It is recommended to upgrade the affected component. The identifier VDB-217553 was assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.1, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jobe_project:jobe:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.7.0", "matchCriteriaId": "C5E85CFB-6C3C-43D7-A2FC-29B1AB822AA9"}]}]}], "references": [{"url": "https://github.com/trampgeek/jobe/commit/8f43daf50c943b98eaf0c542da901a4a16e85b02", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/trampgeek/jobe/issues/39", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/trampgeek/jobe/releases/tag/v1.7.0", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217553", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217553", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/trampgeek/jobe/commit/8f43daf50c943b98eaf0c542da901a4a16e85b02"}}