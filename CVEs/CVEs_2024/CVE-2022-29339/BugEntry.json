{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n#include <gpac/internal/media_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n\nBool gf_isom_is_nalu_based_entry(GF_MediaBox *mdia, GF_SampleEntryBox *_entry)\n{\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (!gf_isom_is_video_handler_type(mdia->handler->handlerType))\n\t\treturn GF_FALSE;\n\tif (!_entry) return GF_FALSE;\n\tentry = (GF_MPEGVisualSampleEntryBox*)_entry;\n\n\tswitch (_entry->type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_SVC2:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC2:\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_LHV1:\n\tcase GF_ISOM_BOX_TYPE_LHE1:\n\tcase GF_ISOM_BOX_TYPE_MHV1:\n\tcase GF_ISOM_BOX_TYPE_MHC1:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\tcase GF_ISOM_BOX_TYPE_LHT1:\n\t\treturn GF_TRUE;\n\tcase GF_ISOM_BOX_TYPE_GNRV:\n\tcase GF_ISOM_BOX_TYPE_GNRA:\n\tcase GF_ISOM_BOX_TYPE_GNRM:\n\t\treturn GF_FALSE;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!gf_isom_is_video_handler_type(entry->internal_type))\n\t\treturn GF_FALSE;\n\n\tif (entry->avc_config || entry->svc_config || entry->mvc_config || entry->hevc_config || entry->lhvc_config) {\n\t\tGF_ProtectionSchemeInfoBox *schi = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\tif (!schi || !schi->scheme_type) return GF_TRUE;\n\t\tswitch (schi->scheme_type->scheme_type) {\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\t\treturn GF_TRUE;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_FALSE;\n}\n\n\nstatic void rewrite_nalus_list(GF_List *nalus, GF_BitStream *bs, Bool rewrite_start_codes, u32 nal_unit_size_field)\n{\n\tu32 i, count = gf_list_count(nalus);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam*)gf_list_get(nalus, i);\n\t\tif (rewrite_start_codes) gf_bs_write_u32(bs, 1);\n\t\telse gf_bs_write_int(bs, sl->size, 8*nal_unit_size_field);\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n}\n\n\nstatic GF_Err process_extractor(GF_ISOFile *file, GF_MediaBox *mdia, u32 sampleNumber, u64 sampleDTS, u32 nal_size, u16 nal_hdr, u32 nal_unit_size_field, Bool is_hevc, Bool rewrite_ps, Bool rewrite_start_codes, u32 extractor_mode)\n{\n\tGF_Err e;\n\tu32 di, ref_track_index, ref_track_num, data_offset, data_length, cur_extract_mode, ref_extract_mode, ref_nalu_size, nb_bytes_nalh;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_TrackBox *ref_trak;\n\ts8 sample_offset;\n\tu32 last_byte, ref_sample_num, prev_ref_sample_num;\n\tBool header_written = GF_FALSE;\n\tnb_bytes_nalh = is_hevc ? 2 : 1;\n\n\tswitch (extractor_mode) {\n\tcase 0:\n\t\tlast_byte = (u32) gf_bs_get_position(mdia->nalu_parser) + nal_size - (is_hevc ? 2 : 1);\n\t\tif (!is_hevc) gf_bs_read_int(mdia->nalu_parser, 24); //1 byte for HEVC , 3 bytes for AVC of NALUHeader in extractor\n\t\twhile (gf_bs_get_position(mdia->nalu_parser) < last_byte) {\n\t\t\tu32 xmode = 0;\n\t\t\t//hevc extractors use constructors\n\t\t\tif (is_hevc) xmode = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\tif (xmode) {\n\t\t\t\tu8 done=0, len = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\t\twhile (done<len) {\n\t\t\t\t\tu8 c = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\t\t\tdone++;\n\t\t\t\t\tif (header_written) {\n\t\t\t\t\t\tgf_bs_write_u8(mdia->nalu_out_bs, c);\n\t\t\t\t\t} else if (done==nal_unit_size_field) {\n\t\t\t\t\t\tif (rewrite_start_codes) {\n\t\t\t\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 1, 32);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_bs_write_u8(mdia->nalu_out_bs, c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\theader_written = GF_TRUE;\n\t\t\t\t\t} else if (!rewrite_start_codes) {\n\t\t\t\t\t\tgf_bs_write_u8(mdia->nalu_out_bs, c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tref_track_index = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\tsample_offset = (s8) gf_bs_read_int(mdia->nalu_parser, 8);\n\t\t\tdata_offset = gf_bs_read_int(mdia->nalu_parser, nal_unit_size_field*8);\n\t\t\tdata_length = gf_bs_read_int(mdia->nalu_parser, nal_unit_size_field*8);\n\n\t\t\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_SCAL, &dpnd);\n\t\t\tref_track_num = 0;\n\t\t\tif (dpnd && ref_track_index && (ref_track_index<=dpnd->trackIDCount))\n\t\t\t\tref_track_num = gf_isom_get_track_by_id(file, dpnd->trackIDs[ref_track_index-1]);\n\n\t\t\tif (!ref_track_num) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"ISOBMF: Extractor target track is not present in file - skipping.\\n\"));\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\n\t\t\tcur_extract_mode = gf_isom_get_nalu_extract_mode(file, ref_track_num);\n\n\t\t\t//we must be in inspect mode only otherwise the reference sample will not be the one stored on file (change in start codes, PS inserted or other NALUs inserted)\n\t\t\t//and this will corrupt extraction (wrong data offsets)\n\t\t\tref_extract_mode = GF_ISOM_NALU_EXTRACT_INSPECT;\n\t\t\tgf_isom_set_nalu_extract_mode(file, ref_track_num, ref_extract_mode);\n\n\t\t\tref_trak = gf_isom_get_track_from_file(file, ref_track_num);\n\t\t\tif (!ref_trak) return GF_ISOM_INVALID_FILE;\n\n\t\t\tif (!mdia->extracted_samp) {\n\t\t\t\tmdia->extracted_samp = gf_isom_sample_new();\n\t\t\t\tif (!mdia->extracted_samp) return GF_IO_ERR;\n\t\t\t}\n\t\t\tif (!mdia->extracted_bs) {\n\t\t\t\tmdia->extracted_bs = gf_bs_new(\"a\", 1, GF_BITSTREAM_READ);\n\t\t\t\tif (!mdia->extracted_bs) return GF_IO_ERR;\n\t\t\t}\n\n\t\t\te = stbl_findEntryForTime(ref_trak->Media->information->sampleTable, sampleDTS, 0, &ref_sample_num, &prev_ref_sample_num);\n\t\t\tif (e) return e;\n\t\t\tif (!ref_sample_num) ref_sample_num = prev_ref_sample_num;\n\t\t\tif (!ref_sample_num) return GF_ISOM_INVALID_FILE;\n\t\t\tif ((sample_offset<0) && (ref_sample_num > (u32) -sample_offset)) return GF_ISOM_INVALID_FILE;\n\t\t\tref_sample_num = (u32) ( (s32) ref_sample_num + sample_offset);\n\n\t\t\te = Media_GetSample(ref_trak->Media, ref_sample_num, &mdia->extracted_samp, &di, GF_FALSE, NULL);\n\t\t\tif (e) return e;\n\t\t\tif (!mdia->extracted_samp->alloc_size)\n\t\t\t\tmdia->extracted_samp->alloc_size = mdia->extracted_samp->dataLength;\n#if 0\n\t\t\tif (!header_written && rewrite_start_codes) {\n\t\t\t\tgf_bs_write_int(dst_bs, 1, 32);\n\t\t\t\tif (is_hevc) {\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0, 1);\n\t\t\t\t\tgf_bs_write_int(dst_bs, GF_HEVC_NALU_ACCESS_UNIT, 6);\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0, 9);\n\t\t\t\t\t/*pic-type - by default we signal all slice types possible*/\n\t\t\t\t\tgf_bs_write_int(dst_bs, 2, 3);\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0, 5);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_write_int(dst_bs, (ref_samp->data[0] & 0x60) | GF_AVC_NALU_ACCESS_UNIT, 8);\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0xF0 , 8); /*7 \"all supported NALUs\" (=111) + rbsp trailing (10000)*/;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tgf_bs_reassign_buffer(mdia->extracted_bs, mdia->extracted_samp->data + data_offset, mdia->extracted_samp->dataLength - data_offset);\n\n\t\t\tif (mdia->extracted_samp->dataLength - data_offset >= data_length) {\n\n\t\t\t\twhile (data_length && gf_bs_available(mdia->extracted_bs)) {\n\t\t\t\t\tif (!header_written) {\n\t\t\t\t\t\tref_nalu_size = gf_bs_read_int(mdia->extracted_bs, 8*nal_unit_size_field);\n\n\t\t\t\t\t\tassert(data_length>nal_unit_size_field);\n\t\t\t\t\t\tdata_length -= nal_unit_size_field;\n\t\t\t\t\t\tif (data_length > gf_bs_available(mdia->extracted_bs)) {\n\t\t\t\t\t\t\tdata_length = (u32)gf_bs_available(mdia->extracted_bs);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tref_nalu_size = data_length;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ref_nalu_size > mdia->tmp_nal_copy_buffer_alloc) {\n\t\t\t\t\t\tmdia->tmp_nal_copy_buffer_alloc = ref_nalu_size;\n\t\t\t\t\t\tmdia->tmp_nal_copy_buffer = (char*) gf_realloc(mdia->tmp_nal_copy_buffer, sizeof(char) * ref_nalu_size );\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_read_data(mdia->extracted_bs, mdia->tmp_nal_copy_buffer, ref_nalu_size);\n\n\t\t\t\t\tif (!header_written) {\n\t\t\t\t\t\tif (rewrite_start_codes)\n\t\t\t\t\t\t\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, ref_nalu_size, 8*nal_unit_size_field);\n\t\t\t\t\t}\n\t\t\t\t\tassert(data_length >= ref_nalu_size);\n\t\t\t\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, ref_nalu_size);\n\t\t\t\t\tdata_length -= ref_nalu_size;\n\n\t\t\t\t\theader_written = GF_FALSE;\n\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"ISOBMF: Extractor size is larger than referred sample size - skipping.\\n\"));\n\t\t\t}\n\t\t\tgf_isom_set_nalu_extract_mode(file, ref_track_num, cur_extract_mode);\n\n\t\t\tif (!is_hevc) break;\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\t//skip to end of this NALU\n\t\tgf_bs_skip_bytes(mdia->nalu_parser, nal_size - nb_bytes_nalh);\n\t\tbreak;\n\tcase 2:\n\t\tif (nal_size - nb_bytes_nalh > mdia->tmp_nal_copy_buffer_alloc) {\n\t\t\tmdia->tmp_nal_copy_buffer_alloc = nal_size - nb_bytes_nalh;\n\t\t\tmdia->tmp_nal_copy_buffer = (char*) gf_realloc(mdia->tmp_nal_copy_buffer, sizeof(char) * (nal_size - nb_bytes_nalh) );\n\t\t}\n\t\tgf_bs_read_data(mdia->nalu_parser, mdia->tmp_nal_copy_buffer, nal_size - nb_bytes_nalh);\n\t\tif (rewrite_start_codes)\n\t\t\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\n\t\telse\n\t\t\tgf_bs_write_int(mdia->nalu_out_bs, nal_size, 8*nal_unit_size_field);\n\n\t\tgf_bs_write_u8(mdia->nalu_out_bs, nal_hdr);\n\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, nal_size - nb_bytes_nalh);\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_HEVC\n/* returns the SAP type as defined in the 14496-12 specification */\nstatic GF_ISOSAPType sap_type_from_nal_type(u8 nal_type) {\n\tswitch (nal_type) {\n\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\treturn SAP_TYPE_3;\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\treturn SAP_TYPE_1;\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\t\treturn SAP_TYPE_2;\n\tdefault:\n\t\treturn RAP_NO;\n\t}\n}\n#endif\n\nstatic GF_ISOSAPType is_sample_idr(GF_MediaBox *mdia, GF_ISOSample *sample, GF_MPEGVisualSampleEntryBox *entry)\n{\n\tBool is_hevc = GF_FALSE;\n\tu32 nalu_size_field = 0;\n\tif (entry->avc_config && entry->avc_config->config) nalu_size_field = entry->avc_config->config->nal_unit_size;\n\telse if (entry->svc_config && entry->svc_config->config) nalu_size_field = entry->svc_config->config->nal_unit_size;\n\telse if (entry->mvc_config && entry->mvc_config->config) nalu_size_field = entry->mvc_config->config->nal_unit_size;\n\telse if (entry->hevc_config && entry->hevc_config->config) {\n\t\tnalu_size_field = entry->hevc_config->config->nal_unit_size;\n\t\tis_hevc = GF_TRUE;\n\t}\n\telse if (entry->lhvc_config && entry->lhvc_config->config) {\n\t\tnalu_size_field = entry->lhvc_config->config->nal_unit_size;\n\t\tis_hevc = GF_TRUE;\n\t}\n\tif (!nalu_size_field) return RAP_NO;\n\n\tif (!mdia->nalu_parser)\n\t\tmdia->nalu_parser = gf_bs_new(sample->data, sample->dataLength, GF_BITSTREAM_READ);\n\telse\n\t\tgf_bs_reassign_buffer(mdia->nalu_parser, sample->data, sample->dataLength);\n\n\tif (!mdia->nalu_parser) return RAP_NO;\n\n\twhile (gf_bs_available(mdia->nalu_parser)) {\n\t\tu8 nal_type;\n\t\tu32 size = gf_bs_read_int(mdia->nalu_parser, 8*nalu_size_field);\n\n\t\tif (is_hevc) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\tu16 nal_hdr = gf_bs_read_u16(mdia->nalu_parser);\n\t\t\tnal_type = (nal_hdr&0x7E00) >> 9;\n\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\t\t\treturn SAP_TYPE_3;\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\t\t\treturn SAP_TYPE_1;\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\t\t\t\treturn SAP_TYPE_2;\n\t\t\tcase GF_HEVC_NALU_ACCESS_UNIT:\n\t\t\tcase GF_HEVC_NALU_FILLER_DATA:\n\t\t\tcase GF_HEVC_NALU_SEI_PREFIX:\n\t\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn RAP_NO;\n\t\t\t}\n\t\t\tgf_bs_skip_bytes(mdia->nalu_parser, size - 2);\n#endif\n\t\t} else {\n\t\t\tu8 nal_hdr = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\tnal_type = nal_hdr & 0x1F;\n\n\t\t\tif (nal_type==GF_AVC_NALU_IDR_SLICE) return SAP_TYPE_1;\n\t\t\tif (nal_type<GF_AVC_NALU_IDR_SLICE) return RAP_NO;\n\t\t\tgf_bs_skip_bytes(mdia->nalu_parser, size - 1);\n\t\t}\n\t}\n\treturn RAP_NO;\n}\n\nstatic void nalu_merge_ps(GF_BitStream *ps_bs, Bool rewrite_start_codes, u32 nal_unit_size_field, GF_MPEGVisualSampleEntryBox *entry, Bool is_hevc, Bool *has_vps)\n{\n\tu32 i, count;\n\tif (is_hevc) {\n\t\tif (entry->hevc_config) {\n\t\t\tcount = gf_list_count(entry->hevc_config->config->param_array);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_NALUFFParamArray *ar = (GF_NALUFFParamArray*)gf_list_get(entry->hevc_config->config->param_array, i);\n\t\t\t\tif (ar->type == GF_HEVC_NALU_VID_PARAM) {\n\t\t\t\t\tif (! *has_vps)  *has_vps = GF_TRUE;\n\t\t\t\t\telse continue;\n\t\t\t\t}\n\t\t\t\trewrite_nalus_list(ar->nalus, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t\t}\n\t\t}\n\t\tif (entry->lhvc_config) {\n\t\t\tcount = gf_list_count(entry->lhvc_config->config->param_array);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_NALUFFParamArray *ar = (GF_NALUFFParamArray*)gf_list_get(entry->lhvc_config->config->param_array, i);\n\t\t\t\tif (ar->type == GF_HEVC_NALU_VID_PARAM) {\n\t\t\t\t\tif (! *has_vps)  *has_vps = GF_TRUE;\n\t\t\t\t\telse continue;\n\t\t\t\t}\n\t\t\t\trewrite_nalus_list(ar->nalus, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (entry->avc_config) {\n\t\t\trewrite_nalus_list(entry->avc_config->config->sequenceParameterSets, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t\trewrite_nalus_list(entry->avc_config->config->sequenceParameterSetExtensions, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t\trewrite_nalus_list(entry->avc_config->config->pictureParameterSets, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t}\n\n\t\t/*add svc config */\n\t\tif (entry->svc_config) {\n\t\t\trewrite_nalus_list(entry->svc_config->config->sequenceParameterSets, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t\trewrite_nalus_list(entry->svc_config->config->pictureParameterSets, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t}\n\t\t/*add mvc config */\n\t\tif (entry->mvc_config) {\n\t\t\trewrite_nalus_list(entry->mvc_config->config->sequenceParameterSets, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t\trewrite_nalus_list(entry->mvc_config->config->pictureParameterSets, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t}\n\t}\n}\n\n\nGF_Err gf_isom_nalu_sample_rewrite(GF_MediaBox *mdia, GF_ISOSample *sample, u32 sampleNumber, GF_MPEGVisualSampleEntryBox *entry)\n{\n\tBool is_hevc = GF_FALSE;\n\t//if only one sync given in the sample sync table, insert sps/pps/vps before cra/bla in hevc\n//\tBool check_cra_bla = (mdia->information->sampleTable->SyncSample && mdia->information->sampleTable->SyncSample->nb_entries>1) ? 0 : 1;\n\tBool check_cra_bla = GF_TRUE;\n\tBool insert_nalu_delim = GF_TRUE;\n\tBool force_sei_inspect = GF_FALSE;\n\tGF_Err e = GF_OK;\n\tGF_BitStream *sei_suffix_bs = NULL;\n\tBool ps_transfered = GF_FALSE;\n\tu32 nal_size, nal_unit_size_field, extractor_mode;\n\tBool rewrite_ps, rewrite_start_codes, insert_vdrd_code;\n\tu8 nal_type;\n\tu32 nal_hdr, sabt_ref, i, track_num;\n\tu32 temporal_id = 0;\n\tGF_ISOFile *file = mdia->mediaTrack->moov->mov;\n\tGF_TrackReferenceTypeBox *scal = NULL;\n\n\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_SCAL, &scal);\n\n\trewrite_ps = (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_INBAND_PS_FLAG) ? GF_TRUE : GF_FALSE;\n\trewrite_start_codes = (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_ANNEXB_FLAG) ? GF_TRUE : GF_FALSE;\n\tinsert_vdrd_code = (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_VDRD_FLAG) ? GF_TRUE : GF_FALSE;\n\tif (!entry->svc_config && !entry->mvc_config && !entry->lhvc_config) insert_vdrd_code = GF_FALSE;\n\textractor_mode = mdia->mediaTrack->extractor_mode&0x0000FFFF;\n\n\tif (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_TILE_ONLY) {\n\t\tinsert_nalu_delim = GF_FALSE;\n\t}\n\n\ttrack_num = 1 + gf_list_find(mdia->mediaTrack->moov->trackList, mdia->mediaTrack);\n\n\tif ( (extractor_mode != GF_ISOM_NALU_EXTRACT_INSPECT) && !(mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_TILE_ONLY) ) {\n\t\tu32 ref_track, di;\n\t\t//aggregate all sabt samples with the same DTS\n\t\tif (entry->lhvc_config && !entry->hevc_config && !(mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_LAYER_ONLY)) {\n\t\t\tif (gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_SCAL) <= 0) {\n\t\t\t\t//FIXME - for now we only support two layers (base + enh) in implicit\n\t\t\t\tif ( gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_BASE) >= 1) {\n\t\t\t\t\tGF_ISOSample *base_samp;\n\t\t\t\t\tgf_isom_get_reference(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_BASE, 1, &ref_track);\n\t\t\t\t\tswitch (gf_isom_get_media_subtype(mdia->mediaTrack->moov->mov , ref_track, 1)) {\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\n\t\t\t\t\t\tif (!mdia->extracted_samp) {\n\t\t\t\t\t\t\tmdia->extracted_samp = gf_isom_sample_new();\n\t\t\t\t\t\t\tif (!mdia->extracted_samp) return GF_OUT_OF_MEM;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbase_samp = gf_isom_get_sample_ex(mdia->mediaTrack->moov->mov, ref_track, sampleNumber + mdia->mediaTrack->sample_count_at_seg_start, &di, mdia->extracted_samp, NULL);\n\t\t\t\t\t\tif (base_samp && base_samp->data) {\n\t\t\t\t\t\t\tif (!sample->alloc_size || (sample->alloc_size<sample->dataLength+base_samp->dataLength) ) {\n\t\t\t\t\t\t\t\tsample->data = gf_realloc(sample->data, sample->dataLength+base_samp->dataLength);\n\t\t\t\t\t\t\t\tif (sample->alloc_size) sample->alloc_size = sample->dataLength+base_samp->dataLength;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmemmove(sample->data + base_samp->dataLength, sample->data , sample->dataLength);\n\t\t\t\t\t\t\tmemcpy(sample->data, base_samp->data, base_samp->dataLength);\n\t\t\t\t\t\t\tsample->dataLength += base_samp->dataLength;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_BASE, &scal);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsabt_ref = gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_SABT);\n\t\tif ((s32) sabt_ref > 0) {\n\t\t\tforce_sei_inspect = GF_TRUE;\n\t\t\tfor (i=0; i<sabt_ref; i++) {\n\t\t\t\tGF_ISOSample *tile_samp;\n\t\t\t\tgf_isom_get_reference(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_SABT, i+1, &ref_track);\n\n\t\t\t\tif (!mdia->extracted_samp) {\n\t\t\t\t\tmdia->extracted_samp = gf_isom_sample_new();\n\t\t\t\t\tif (!mdia->extracted_samp) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\n\t\t\t\ttile_samp = gf_isom_get_sample_ex(mdia->mediaTrack->moov->mov, ref_track, sampleNumber + mdia->mediaTrack->sample_count_at_seg_start, &di, mdia->extracted_samp, NULL);\n\t\t\t\tif (tile_samp  && tile_samp ->data) {\n\t\t\t\t\tif (!sample->alloc_size || (sample->alloc_size<sample->dataLength+tile_samp->dataLength) ) {\n\t\t\t\t\t\tsample->data = gf_realloc(sample->data, sample->dataLength+tile_samp->dataLength);\n\t\t\t\t\t\tif (sample->alloc_size) sample->alloc_size = sample->dataLength+tile_samp->dataLength;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(sample->data + sample->dataLength, tile_samp->data, tile_samp->dataLength);\n\t\t\t\t\tsample->dataLength += tile_samp->dataLength;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_TBAS) >= 1) {\n\t\tu32 ref_track;\n\t\tu32 idx = gf_list_find(mdia->information->sampleTable->SampleDescription->child_boxes, entry);\n\t\tGF_TrackBox *tbas;\n\t\tgf_isom_get_reference(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\ttbas = (GF_TrackBox *)gf_list_get(mdia->mediaTrack->moov->trackList, ref_track-1);\n\t\tentry = gf_list_get(tbas->Media->information->sampleTable->SampleDescription->child_boxes, idx);\n\t}\n\n\n\tif (sample->IsRAP < SAP_TYPE_2) {\n\t\tif (mdia->information->sampleTable->no_sync_found || (!sample->IsRAP && check_cra_bla) ) {\n\t\t\tsample->IsRAP = is_sample_idr(mdia, sample, entry);\n\t\t}\n\t}\n\tif (!sample->IsRAP)\n\t\trewrite_ps = GF_FALSE;\n\n\tif (extractor_mode != GF_ISOM_NALU_EXTRACT_LAYER_ONLY)\n\t\tinsert_vdrd_code = GF_FALSE;\n\n\tif (!entry) return GF_BAD_PARAM;\n\n\t//this is a compatible HEVC, don't insert VDRD, insert NALU delim\n\tif (entry->lhvc_config && entry->hevc_config)\n\t\tinsert_vdrd_code = GF_FALSE;\n\n\tif (extractor_mode == GF_ISOM_NALU_EXTRACT_INSPECT) {\n\t\tif (!rewrite_ps && !rewrite_start_codes)\n\t\t\treturn GF_OK;\n\t}\n\n\tnal_unit_size_field = 0;\n\t/*if svc rewrite*/\n\tif (entry->svc_config && entry->svc_config->config)\n\t\tnal_unit_size_field = entry->svc_config->config->nal_unit_size;\n\t/*if mvc rewrite*/\n\tif (entry->mvc_config && entry->mvc_config->config)\n\t\tnal_unit_size_field = entry->mvc_config->config->nal_unit_size;\n\n\t/*if lhvc rewrite*/\n\telse if (entry->lhvc_config && entry->lhvc_config->config)  {\n\t\tis_hevc = GF_TRUE;\n\t\tnal_unit_size_field = entry->lhvc_config->config->nal_unit_size;\n\t}\n\n\t/*otherwise do nothing*/\n\telse if (!rewrite_ps && !rewrite_start_codes && !scal && !force_sei_inspect) {\n\t\treturn GF_OK;\n\t}\n\n\tif (!nal_unit_size_field) {\n\t\tif (entry->avc_config && entry->avc_config->config)\n\t\t\tnal_unit_size_field = entry->avc_config->config->nal_unit_size;\n\t\telse if (entry->lhvc_config && entry->lhvc_config->config) {\n\t\t\tnal_unit_size_field = entry->lhvc_config->config->nal_unit_size;\n\t\t\tis_hevc = GF_TRUE;\n\t\t}\n\t\telse if (entry->hevc_config && entry->hevc_config->config) {\n\t\t\tnal_unit_size_field = entry->hevc_config->config->nal_unit_size;\n\t\t\tis_hevc = GF_TRUE;\n\t\t}\n\t}\n\n\tif (!nal_unit_size_field) return GF_ISOM_INVALID_FILE;\n\n\t//setup PS rewriter\n\tif (!mdia->nalu_ps_bs)\n\t\tmdia->nalu_ps_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_bs_seek(mdia->nalu_ps_bs, 0);\n\n\t//setup sample reader\n\tif (mdia->in_sample_buffer_alloc<sample->dataLength) {\n\t\tmdia->in_sample_buffer_alloc = sample->dataLength;\n\t\tmdia->in_sample_buffer = gf_realloc(mdia->in_sample_buffer, sample->dataLength);\n\t}\n\tmemcpy(mdia->in_sample_buffer, sample->data, sample->dataLength);\n\n\tif (!mdia->nalu_parser) {\n\t\tmdia->nalu_parser = gf_bs_new(mdia->in_sample_buffer, sample->dataLength, GF_BITSTREAM_READ);\n\t\tif (!mdia->nalu_parser && sample->data) return GF_ISOM_INVALID_FILE;\n\t} else {\n\t\te = gf_bs_reassign_buffer(mdia->nalu_parser, mdia->in_sample_buffer, sample->dataLength);\n\t\tif (e) return e;\n\t}\n\t//setup output\n\tif (!mdia->nalu_out_bs) {\n\t\tu8 *output;\n\t\tu32 outSize;\n\t\tmdia->nalu_out_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_get_content(mdia->nalu_out_bs, &output, &outSize);\n\t}\n\n\tgf_bs_reassign_buffer(mdia->nalu_out_bs, sample->data, sample->alloc_size ? sample->alloc_size : sample->dataLength);\n\n\t/*rewrite start code with NALU delim*/\n\tif (rewrite_start_codes) {\n\n\t\t//we are SVC, don't write NALU delim, only insert VDRD NALU\n\t\tif (insert_vdrd_code) {\n\t\t\tif (is_hevc) {\n\t\t\t\t//spec is not clear here, we don't insert an NALU AU delimiter before the layer starts since it breaks openHEVC\n//\t\t\t\tinsert_nalu_delim=0;\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 1, 32);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, GF_AVC_NALU_VDRD , 8);\n\t\t\t\tinsert_nalu_delim=0;\n\t\t\t}\n\t\t}\n\n\t\t//AVC/HEVC base, insert NALU delim\n\t\tif (insert_nalu_delim) {\n\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 1, 32);\n\t\t\tif (is_hevc) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 0, 1);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, GF_HEVC_NALU_ACCESS_UNIT, 6);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, insert_vdrd_code ? 1 : 0, 6); //we should pick the layerID of the following nalus ...\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 1, 3); //nuh_temporal_id_plus1 - cannot be 0, we use 1 by default, and overwrite it if needed at the end\n\n\t\t\t\t/*pic-type - by default we signal all slice types possible*/\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 2, 3);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 0, 5);\n#endif\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, (sample->data[0] & 0x60) | GF_AVC_NALU_ACCESS_UNIT, 8);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 0xF0 , 8); /*7 \"all supported NALUs\" (=111) + rbsp trailing (10000)*/;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rewrite_ps) {\n\t\tBool has_vps = GF_FALSE;\n\t\t//in inspect mode or single-layer mode just use the xPS from this layer\n\t\tif (extractor_mode == GF_ISOM_NALU_EXTRACT_DEFAULT) {\n\t\t\tif (scal) {\n\t\t\t\tfor (i=0; i<scal->trackIDCount; i++) {\n\t\t\t\t\tGF_TrackBox *a_track = GetTrackbyID(mdia->mediaTrack->moov, scal->trackIDs[i]);\n\t\t\t\t\tGF_MPEGVisualSampleEntryBox *an_entry = NULL;\n\t\t\t\t\tif (a_track && a_track->Media && a_track->Media->information && a_track->Media->information->sampleTable && a_track->Media->information->sampleTable->SampleDescription)\n\t\t\t\t\t\tan_entry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(a_track->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\n\t\t\t\t\tif (an_entry)\n\t\t\t\t\t\tnalu_merge_ps(mdia->nalu_ps_bs, rewrite_start_codes, nal_unit_size_field, an_entry, is_hevc, &has_vps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnalu_merge_ps(mdia->nalu_ps_bs, rewrite_start_codes, nal_unit_size_field, entry, is_hevc, &has_vps);\n\n\n\t\tif (is_hevc) {\n\t\t\t/*little optimization if we are not asked to start codes: copy over the sample*/\n\t\t\tif (!rewrite_start_codes && !entry->lhvc_config && !scal) {\n\t\t\t\tif (! ps_transfered) {\n\t\t\t\t\tnal_type = (sample->data[nal_unit_size_field] & 0x7E) >> 1;\n\t\t\t\t\t//temp fix - if we detect xPS in the beginning of the sample do NOT copy the ps bitstream\n\t\t\t\t\t//this is not correct since we are not sure whether they are the same xPS or not, but it crashes openHEVC ...\n\t\t\t\t\tswitch (nal_type) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\t\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\t\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\t\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\t\t\t\tbreak;\n#endif\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgf_bs_transfer(mdia->nalu_out_bs, mdia->nalu_ps_bs, GF_TRUE);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->in_sample_buffer, sample->dataLength);\n\t\t\t\tgf_bs_get_content_no_truncate(mdia->nalu_out_bs, &sample->data, &sample->dataLength, &sample->alloc_size);\n\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tps_transfered = GF_TRUE;\n\t}\n\n\t/*little optimization if we are not asked to rewrite extractors or start codes: copy over the sample*/\n\tif (!scal && !rewrite_start_codes && !rewrite_ps && !force_sei_inspect) {\n\t\tif (! ps_transfered)\n\t\t{\n\t\t\tgf_bs_transfer(mdia->nalu_out_bs, mdia->nalu_ps_bs, GF_TRUE);\n\t\t}\n\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->in_sample_buffer, sample->dataLength);\n\t\tgf_bs_get_content_no_truncate(mdia->nalu_out_bs, &sample->data, &sample->dataLength, &sample->alloc_size);\n\t\treturn GF_OK;\n\t}\n\n\tif (!mdia->tmp_nal_copy_buffer) {\n\t\tmdia->tmp_nal_copy_buffer = gf_malloc(sizeof(char) * 4096);\n\t\tmdia->tmp_nal_copy_buffer_alloc = 4096;\n\t}\n\n\n\twhile (gf_bs_available(mdia->nalu_parser)) {\n\t\tnal_size = gf_bs_read_int(mdia->nalu_parser, 8*nal_unit_size_field);\n\t\tif (gf_bs_get_position(mdia->nalu_parser) + nal_size > sample->dataLength) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"Sample %u (size %u) rewrite: corrupted NAL Unit (size %u)\\n\", sampleNumber, sample->dataLength, nal_size));\n\t\t\tgoto exit;\n\t\t}\n\t\tif (nal_size > mdia->tmp_nal_copy_buffer_alloc) {\n\t\t\tmdia->tmp_nal_copy_buffer_alloc = nal_size;\n\t\t\tmdia->tmp_nal_copy_buffer = (char*) gf_realloc(mdia->tmp_nal_copy_buffer, sizeof(char)*nal_size);\n\t\t}\n\t\tif (is_hevc) {\n\t\t\tnal_hdr = gf_bs_read_u16(mdia->nalu_parser);\n\t\t\tnal_type = (nal_hdr&0x7E00) >> 9;\n\t\t} else {\n\t\t\tnal_hdr = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\tnal_type = nal_hdr & 0x1F;\n\t\t}\n\n\t\tif (is_hevc) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\tGF_BitStream *write_to_bs = mdia->nalu_out_bs;\n#endif\n\n\t\t\tif (!ps_transfered) {\n\t\t\t\tgf_bs_transfer(mdia->nalu_out_bs, mdia->nalu_ps_bs, GF_TRUE);\n\t\t\t\tps_transfered = GF_TRUE;\n\t\t\t}\n\n#ifndef GPAC_DISABLE_HEVC\n\t\t\tswitch (nal_type) {\n\t\t\t/*we already wrote AU delim, and we trash aggregators*/\n\t\t\tcase GF_HEVC_NALU_ACCESS_UNIT:\n\t\t\tcase GF_HEVC_NALU_FF_AGGREGATOR:\n\t\t\t\tgf_bs_skip_bytes(mdia->nalu_parser, nal_size-2);\n\t\t\t\tcontinue;\n\n\t\t\t//extractor\n\t\t\tcase GF_HEVC_NALU_FF_EXTRACTOR:\n\t\t\t\te = process_extractor(file, mdia, sampleNumber, sample->DTS, nal_size, nal_hdr, nal_unit_size_field, GF_TRUE, rewrite_ps, rewrite_start_codes, extractor_mode);\n\t\t\t\tif (e) goto exit;\n\t\t\t\tbreak;\n\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_R:\n\t\t\t\tif (temporal_id < (nal_hdr & 0x7))\n\t\t\t\t\ttemporal_id = (nal_hdr & 0x7);\n\t\t\t\t/*rewrite nal*/\n\t\t\t\tgf_bs_read_data(mdia->nalu_parser, mdia->tmp_nal_copy_buffer, nal_size-2);\n\t\t\t\tif (rewrite_start_codes)\n\t\t\t\t\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\n\t\t\t\telse\n\t\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, nal_size, 8*nal_unit_size_field);\n\n\t\t\t\tgf_bs_write_u16(mdia->nalu_out_bs, nal_hdr);\n\t\t\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, nal_size-2);\n\t\t\t\tbreak;\n\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\t\t\t//insert xPS before CRA/BLA\n\t\t\t\tif (check_cra_bla && !sample->IsRAP) {\n\t\t\t\t\tsample->IsRAP = sap_type_from_nal_type(nal_type);\n\t\t\t\t\tif (sei_suffix_bs) gf_bs_del(sei_suffix_bs);\n\t\t\t\t\treturn gf_isom_nalu_sample_rewrite(mdia, sample, sampleNumber, entry);\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\t/*rewrite nal*/\n\t\t\t\tif (nal_size<2) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid nal size %d in sample %d\\n\", nal_type, sampleNumber));\n\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\n\t\t\t\tgf_bs_read_data(mdia->nalu_parser, mdia->tmp_nal_copy_buffer, nal_size-2);\n\n\t\t\t\tif (nal_type==GF_HEVC_NALU_SEI_SUFFIX) {\n\t\t\t\t\tif (!sei_suffix_bs) sei_suffix_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\t\twrite_to_bs = sei_suffix_bs;\n\t\t\t\t}\n\n\t\t\t\tif (rewrite_start_codes)\n\t\t\t\t\tgf_bs_write_u32(write_to_bs, 1);\n\t\t\t\telse\n\t\t\t\t\tgf_bs_write_int(write_to_bs, nal_size, 8*nal_unit_size_field);\n\n\t\t\t\tgf_bs_write_u16(write_to_bs, nal_hdr);\n\t\t\t\tgf_bs_write_data(write_to_bs, mdia->tmp_nal_copy_buffer, nal_size-2);\n\t\t\t}\n#endif\n\n\t\t\t//done with HEVC\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch(nal_type) {\n\t\tcase GF_AVC_NALU_ACCESS_UNIT:\n\t\tcase GF_AVC_NALU_FF_AGGREGATOR:\n\t\t\t/*we already wrote this stuff, and we trash aggregators*/\n\t\t\tgf_bs_skip_bytes(mdia->nalu_parser, nal_size-1);\n\t\t\tcontinue;\n\t\t//extractor\n\t\tcase GF_AVC_NALU_FF_EXTRACTOR:\n\t\t\te = process_extractor(file, mdia, sampleNumber, sample->DTS, nal_size, nal_hdr, nal_unit_size_field, GF_FALSE, rewrite_ps, rewrite_start_codes, extractor_mode);\n\t\t\tif (e) goto exit;\n\t\t\tbreak;\n//\t\t\tcase GF_AVC_NALU_SEI:\n\t\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\t\t// we will rewrite the sps/pps if and only if there is no sps/pps in bistream\n\t\t\tif (!ps_transfered) {\n\t\t\t\tps_transfered = GF_TRUE;\n\t\t\t}\n\t\tdefault:\n\t\t\tif (!ps_transfered) {\n\t\t\t\tgf_bs_transfer(mdia->nalu_out_bs, mdia->nalu_ps_bs, GF_TRUE);\n\t\t\t\tps_transfered = GF_TRUE;\n\t\t\t}\n\t\t\tgf_bs_read_data(mdia->nalu_parser, mdia->tmp_nal_copy_buffer, nal_size-1);\n\t\t\tif (rewrite_start_codes)\n\t\t\t\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\n\t\t\telse\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, nal_size, 8*nal_unit_size_field);\n\n\t\t\tgf_bs_write_u8(mdia->nalu_out_bs, nal_hdr);\n\t\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, nal_size-1);\n\t\t}\n\t}\n\n\tif (sei_suffix_bs) {\n\t\tgf_bs_transfer(mdia->nalu_out_bs, sei_suffix_bs, GF_FALSE);\n\t}\n\t/*done*/\n\tgf_bs_get_content_no_truncate(mdia->nalu_out_bs, &sample->data, &sample->dataLength, &sample->alloc_size);\n\n\t/*rewrite temporal ID of AU Ddelim NALU (first one)*/\n\tif (rewrite_start_codes && is_hevc && temporal_id) {\n\t\tsample->data[6] = (sample->data[6] & 0xF8) | (temporal_id+1);\n\t}\n\n\nexit:\n\tif (sei_suffix_bs)\n\t\tgf_bs_del(sei_suffix_bs);\n\n\treturn e;\n}\n\nGF_HEVCConfig *HEVC_DuplicateConfig(GF_HEVCConfig *cfg)\n{\n\tu8 *data;\n\tu32 data_size;\n\tGF_HEVCConfig *new_cfg;\n\tGF_BitStream *bs;\n\n\tif (!cfg) return NULL;\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_odf_hevc_cfg_write_bs(cfg, bs);\n\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\n\tnew_cfg = gf_odf_hevc_cfg_read_bs(bs, cfg->is_lhvc);\n\tnew_cfg->is_lhvc = cfg->is_lhvc;\n\tgf_bs_del(bs);\n\tgf_free(data);\n\treturn new_cfg;\n}\n\nGF_VVCConfig *VVC_DuplicateConfig(GF_VVCConfig *cfg)\n{\n\tu8 *data;\n\tu32 data_size;\n\tGF_VVCConfig *new_cfg;\n\tGF_BitStream *bs;\n\n\tif (!cfg) return NULL;\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_odf_vvc_cfg_write_bs(cfg, bs);\n\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\n\tnew_cfg = gf_odf_vvc_cfg_read_bs(bs);\n\tgf_bs_del(bs);\n\tgf_free(data);\n\treturn new_cfg;\n}\n\nstatic GF_AVCConfig *AVC_DuplicateConfig(GF_AVCConfig *cfg)\n{\n\tu32 i, count;\n\tGF_NALUFFParam *p1, *p2;\n\tGF_AVCConfig *cfg_new;\n\tif (!cfg)\n\t\treturn NULL;\n\tcfg_new = gf_odf_avc_cfg_new();\n\tcfg_new->AVCLevelIndication = cfg->AVCLevelIndication;\n\tcfg_new->AVCProfileIndication = cfg->AVCProfileIndication;\n\tcfg_new->configurationVersion = cfg->configurationVersion;\n\tcfg_new->nal_unit_size = cfg->nal_unit_size;\n\tcfg_new->profile_compatibility = cfg->profile_compatibility;\n\tcfg_new->complete_representation = cfg->complete_representation;\n\tcfg_new->chroma_bit_depth = cfg->chroma_bit_depth;\n\tcfg_new->luma_bit_depth = cfg->luma_bit_depth;\n\tcfg_new->chroma_format = cfg->chroma_format;\n\n\tcount = gf_list_count(cfg->sequenceParameterSets);\n\tfor (i=0; i<count; i++) {\n\t\tp1 = (GF_NALUFFParam*)gf_list_get(cfg->sequenceParameterSets, i);\n\t\tp2 = (GF_NALUFFParam*)gf_malloc(sizeof(GF_NALUFFParam));\n\t\tp2->size = p1->size;\n\t\tp2->id = p1->id;\n\t\tp2->data = (char *)gf_malloc(sizeof(char)*p1->size);\n\t\tmemcpy(p2->data, p1->data, sizeof(char)*p1->size);\n\t\tgf_list_add(cfg_new->sequenceParameterSets, p2);\n\t}\n\n\tcount = gf_list_count(cfg->pictureParameterSets);\n\tfor (i=0; i<count; i++) {\n\t\tp1 = (GF_NALUFFParam*)gf_list_get(cfg->pictureParameterSets, i);\n\t\tp2 = (GF_NALUFFParam*)gf_malloc(sizeof(GF_NALUFFParam));\n\t\tp2->size = p1->size;\n\t\tp2->id = p1->id;\n\t\tp2->data = (char*)gf_malloc(sizeof(char)*p1->size);\n\t\tmemcpy(p2->data, p1->data, sizeof(char)*p1->size);\n\t\tgf_list_add(cfg_new->pictureParameterSets, p2);\n\t}\n\n\tif (cfg->sequenceParameterSetExtensions) {\n\t\tcfg_new->sequenceParameterSetExtensions = gf_list_new();\n\t\tcount = gf_list_count(cfg->sequenceParameterSetExtensions);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tp1 = (GF_NALUFFParam*)gf_list_get(cfg->sequenceParameterSetExtensions, i);\n\t\t\tp2 = (GF_NALUFFParam*)gf_malloc(sizeof(GF_NALUFFParam));\n\t\t\tp2->size = p1->size;\n\t\t\tp2->id = p1->id;\n\t\t\tp2->data = (char*)gf_malloc(sizeof(char)*p1->size);\n\t\t\tmemcpy(p2->data, p1->data, sizeof(char)*p1->size);\n\t\t\tgf_list_add(cfg_new->sequenceParameterSetExtensions, p2);\n\t\t}\n\t}\n\treturn cfg_new;\n}\n\nstatic void merge_avc_config(GF_AVCConfig *dst_cfg, GF_AVCConfig *src_cfg)\n{\n\tGF_AVCConfig *cfg;\n\tif (!src_cfg || !dst_cfg) return;\n\tcfg = AVC_DuplicateConfig(src_cfg);\n\tif (!cfg) return;\n\n\twhile (gf_list_count(cfg->sequenceParameterSets)) {\n\t\tGF_NALUFFParam *p = (GF_NALUFFParam*)gf_list_get(cfg->sequenceParameterSets, 0);\n\t\tgf_list_rem(cfg->sequenceParameterSets, 0);\n\t\tgf_list_insert(dst_cfg->sequenceParameterSets, p, 0);\n\t}\n\twhile (gf_list_count(cfg->pictureParameterSets)) {\n\t\tGF_NALUFFParam *p = (GF_NALUFFParam*)gf_list_get(cfg->pictureParameterSets, 0);\n\t\tgf_list_rem(cfg->pictureParameterSets, 0);\n\t\tgf_list_insert(dst_cfg->pictureParameterSets, p, 0);\n\t}\n\tgf_odf_avc_cfg_del(cfg);\n}\n\nvoid merge_hevc_config(GF_HEVCConfig *dst_cfg, GF_HEVCConfig *src_cfg, Bool force_insert)\n{\n\tGF_HEVCConfig *cfg = HEVC_DuplicateConfig(src_cfg);\n\t//merge all xPS\n\tu32 i, j, count = cfg->param_array ? gf_list_count(cfg->param_array) : 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParamArray *ar_h = NULL;\n\t\tu32 count2 = dst_cfg->param_array ? gf_list_count(dst_cfg->param_array) : 0;\n\t\tGF_NALUFFParamArray *ar = (GF_NALUFFParamArray*)gf_list_get(cfg->param_array, i);\n\t\tfor (j=0; j<count2; j++) {\n\t\t\tar_h = (GF_NALUFFParamArray*)gf_list_get(dst_cfg->param_array, j);\n\t\t\tif (ar_h->type==ar->type) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tar_h = NULL;\n\t\t}\n\t\tif (!ar_h) {\n\t\t\tgf_list_add(dst_cfg->param_array, ar);\n\t\t\tgf_list_rem(cfg->param_array, i);\n\t\t\tcount--;\n\t\t\ti--;\n\t\t} else {\n\t\t\twhile (gf_list_count(ar->nalus)) {\n\t\t\t\tGF_NALUFFParam *p = (GF_NALUFFParam*)gf_list_get(ar->nalus, 0);\n\t\t\t\tgf_list_rem(ar->nalus, 0);\n\t\t\t\tif (force_insert)\n\t\t\t\t\tgf_list_insert(ar_h->nalus, p, 0);\n\t\t\t\telse\n\t\t\t\t\tgf_list_add(ar_h->nalus, p);\n\t\t\t}\n\n\t\t}\n\t}\n\tgf_odf_hevc_cfg_del(cfg);\n\n#define CHECK_CODE(__code)\tif (dst_cfg->__code < src_cfg->__code) dst_cfg->__code = src_cfg->__code;\n\n\tCHECK_CODE(configurationVersion)\n\tCHECK_CODE(profile_idc)\n\tCHECK_CODE(profile_space)\n\tCHECK_CODE(tier_flag)\n\tCHECK_CODE(general_profile_compatibility_flags)\n\tCHECK_CODE(progressive_source_flag)\n\tCHECK_CODE(interlaced_source_flag)\n\tCHECK_CODE(constraint_indicator_flags)\n\tCHECK_CODE(level_idc)\n\tCHECK_CODE(min_spatial_segmentation_idc)\n\n}\n\nvoid merge_all_config(GF_AVCConfig *avc_cfg, GF_HEVCConfig *hevc_cfg, GF_MediaBox *mdia)\n{\n\tu32 i;\n\tGF_TrackReferenceTypeBox *scal = NULL;\n\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_SCAL, &scal);\n\n\tif (!scal) return;\n\n\tfor (i=0; i<scal->trackIDCount; i++) {\n\t\tGF_TrackBox *a_track = GetTrackbyID(mdia->mediaTrack->moov, scal->trackIDs[i]);\n\t\tGF_MPEGVisualSampleEntryBox *an_entry = NULL;\n\t\tif (a_track && a_track->Media && a_track->Media->information && a_track->Media->information->sampleTable && a_track->Media->information->sampleTable->SampleDescription)\n\t\t\tan_entry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(a_track->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\n\t\tif (!an_entry) continue;\n\n\t\tif (avc_cfg && an_entry->svc_config && an_entry->svc_config->config)\n\t\t\tmerge_avc_config(avc_cfg, an_entry->svc_config->config);\n\n\t\tif (avc_cfg && an_entry->mvc_config && an_entry->mvc_config->config)\n\t\t\tmerge_avc_config(avc_cfg, an_entry->mvc_config->config);\n\n\t\tif (avc_cfg && an_entry->avc_config && an_entry->avc_config->config)\n\t\t\tmerge_avc_config(avc_cfg, an_entry->avc_config->config);\n\n\t\tif (hevc_cfg && an_entry->lhvc_config && an_entry->lhvc_config->config)\n\t\t\tmerge_hevc_config(hevc_cfg, an_entry->lhvc_config->config, GF_TRUE);\n\n\t\tif (hevc_cfg && an_entry->hevc_config && an_entry->hevc_config->config)\n\t\t\tmerge_hevc_config(hevc_cfg, an_entry->hevc_config->config, GF_TRUE);\n\t}\n\n\tif (hevc_cfg) hevc_cfg->is_lhvc = GF_FALSE;\n}\n\nvoid AVC_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *avc, GF_MediaBox *mdia)\n{\n\tGF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)avc, GF_FALSE);\n\n\tif (avc->emul_esd) gf_odf_desc_del((GF_Descriptor *)avc->emul_esd);\n\tavc->emul_esd = gf_odf_desc_esd_new(2);\n\tavc->emul_esd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t/*AVC OTI is 0x21, AVC parameter set stream OTI (not supported in gpac) is 0x22, SVC OTI is 0x24*/\n\t/*if we have only SVC stream, set objectTypeIndication to AVC OTI; else set it to AVC OTI*/\n\tif (avc->svc_config && !avc->avc_config)\n\t\tavc->emul_esd->decoderConfig->objectTypeIndication = GF_CODECID_SVC;\n\telse if (avc->mvc_config && !avc->avc_config)\n\t\tavc->emul_esd->decoderConfig->objectTypeIndication = GF_CODECID_MVC;\n\telse\n\t\tavc->emul_esd->decoderConfig->objectTypeIndication = GF_CODECID_AVC;\n\n\tif (btrt) {\n\t\tavc->emul_esd->decoderConfig->bufferSizeDB = btrt->bufferSizeDB;\n\t\tavc->emul_esd->decoderConfig->avgBitrate = btrt->avgBitrate;\n\t\tavc->emul_esd->decoderConfig->maxBitrate = btrt->maxBitrate;\n\t}\n\tGF_MPEG4ExtensionDescriptorsBox *mdesc = (GF_MPEG4ExtensionDescriptorsBox *) gf_isom_box_find_child(avc->child_boxes, GF_ISOM_BOX_TYPE_M4DS);\n\tif (mdesc) {\n\t\tu32 i=0;\n\t\tGF_Descriptor *desc,*clone;\n\t\ti=0;\n\t\twhile ((desc = (GF_Descriptor *)gf_list_enum(mdesc->descriptors, &i))) {\n\t\t\tclone = NULL;\n\t\t\tgf_odf_desc_copy(desc, &clone);\n\t\t\tif (gf_odf_desc_add_desc((GF_Descriptor *)avc->emul_esd, clone) != GF_OK)\n\t\t\t\tgf_odf_desc_del(clone);\n\t\t}\n\t}\n\tif (avc->avc_config) {\n\t\tGF_AVCConfig *avcc = avc->avc_config->config ? AVC_DuplicateConfig(avc->avc_config->config) : NULL;\n\t\t/*merge SVC config*/\n\t\tif (avc->svc_config) {\n\t\t\tmerge_avc_config(avcc, avc->svc_config->config);\n\t\t}\n\t\t/*merge MVC config*/\n\t\tif (avc->mvc_config) {\n\t\t\tmerge_avc_config(avcc, avc->mvc_config->config);\n\t\t}\n\t\tif (avcc) {\n\t\t\tif (mdia) merge_all_config(avcc, NULL, mdia);\n\n\t\t\tgf_odf_avc_cfg_write(avcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t}\n\t} else if (avc->svc_config) {\n\t\tGF_AVCConfig *svcc = AVC_DuplicateConfig(avc->svc_config->config);\n\n\t\tif (mdia) merge_all_config(svcc, NULL, mdia);\n\n\t\tgf_odf_avc_cfg_write(svcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_odf_avc_cfg_del(svcc);\n\t}\n\telse if (avc->mvc_config) {\n\t\tGF_AVCConfig *mvcc = AVC_DuplicateConfig(avc->mvc_config->config);\n\n\t\tif (mdia) merge_all_config(mvcc, NULL, mdia);\n\n\t\tgf_odf_avc_cfg_write(mvcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_odf_avc_cfg_del(mvcc);\n\t}\n}\n\nvoid AVC_RewriteESDescriptor(GF_MPEGVisualSampleEntryBox *avc)\n{\n\tAVC_RewriteESDescriptorEx(avc, NULL);\n}\n\nvoid HEVC_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *hevc, GF_MediaBox *mdia)\n{\n\tGF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)hevc, GF_FALSE);\n\n\tif (hevc->emul_esd) gf_odf_desc_del((GF_Descriptor *)hevc->emul_esd);\n\thevc->emul_esd = gf_odf_desc_esd_new(2);\n\thevc->emul_esd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\thevc->emul_esd->decoderConfig->objectTypeIndication = GF_CODECID_HEVC;\n\n\tif (btrt) {\n\t\thevc->emul_esd->decoderConfig->bufferSizeDB = btrt->bufferSizeDB;\n\t\thevc->emul_esd->decoderConfig->avgBitrate = btrt->avgBitrate;\n\t\thevc->emul_esd->decoderConfig->maxBitrate = btrt->maxBitrate;\n\t}\n\tGF_MPEG4ExtensionDescriptorsBox *mdesc = (GF_MPEG4ExtensionDescriptorsBox *) gf_isom_box_find_child(hevc->child_boxes, GF_ISOM_BOX_TYPE_M4DS);\n\tif (mdesc) {\n\t\tu32 i=0;\n\t\tGF_Descriptor *desc,*clone;\n\t\ti=0;\n\t\twhile ((desc = (GF_Descriptor *)gf_list_enum(mdesc->descriptors, &i))) {\n\t\t\tclone = NULL;\n\t\t\tgf_odf_desc_copy(desc, &clone);\n\t\t\tif (gf_odf_desc_add_desc((GF_Descriptor *)hevc->emul_esd, clone) != GF_OK)\n\t\t\t\tgf_odf_desc_del(clone);\n\t\t}\n\t}\n\n\tif (hevc->hevc_config || hevc->lhvc_config) {\n\t\tGF_HEVCConfig *hcfg = HEVC_DuplicateConfig(hevc->hevc_config ? hevc->hevc_config->config : hevc->lhvc_config->config);\n\n\t\tif (hevc->hevc_config && hevc->lhvc_config) {\n\t\t\t//merge LHVC config to HEVC conf, so we add entry rather than insert\n\t\t\tmerge_hevc_config(hcfg, hevc->lhvc_config->config, GF_FALSE);\n\t\t}\n\n\t\tif (mdia) merge_all_config(NULL, hcfg, mdia);\n\n\t\tif (hcfg) {\n\t\t\tif (mdia && ((mdia->mediaTrack->extractor_mode&0x0000FFFF) != GF_ISOM_NALU_EXTRACT_INSPECT)) {\n\t\t\t\thcfg->is_lhvc=GF_FALSE;\n\t\t\t}\n\n\t\t\tgf_odf_hevc_cfg_write(hcfg, &hevc->emul_esd->decoderConfig->decoderSpecificInfo->data, &hevc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_odf_hevc_cfg_del(hcfg);\n\t\t}\n\t}\n}\nvoid HEVC_RewriteESDescriptor(GF_MPEGVisualSampleEntryBox *hevc)\n{\n\tHEVC_RewriteESDescriptorEx(hevc, NULL);\n}\n\nGF_Err AVC_HEVC_UpdateESD(GF_MPEGVisualSampleEntryBox *avc, GF_ESD *esd)\n{\n\tGF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)avc, GF_TRUE);\n\n\tGF_MPEG4ExtensionDescriptorsBox *mdesc = (GF_MPEG4ExtensionDescriptorsBox *) gf_isom_box_find_child(avc->child_boxes, GF_ISOM_BOX_TYPE_M4DS);\n\tif (mdesc) {\n\t\tgf_isom_box_del_parent(&avc->child_boxes, (GF_Box *) mdesc);\n\t}\n\tbtrt->avgBitrate = esd->decoderConfig->avgBitrate;\n\tbtrt->maxBitrate = esd->decoderConfig->maxBitrate;\n\tbtrt->bufferSizeDB = esd->decoderConfig->bufferSizeDB;\n\n\tif (gf_list_count(esd->IPIDataSet)\n\t        || gf_list_count(esd->IPMPDescriptorPointers)\n\t        || esd->langDesc\n\t        || gf_list_count(esd->extensionDescriptors)\n\t        || esd->ipiPtr || esd->qos || esd->RegDescriptor) {\n\n\t\tmdesc = (GF_MPEG4ExtensionDescriptorsBox *) gf_isom_box_new_parent(&avc->child_boxes, GF_ISOM_BOX_TYPE_M4DS);\n\t\tif (!mdesc) return GF_OUT_OF_MEM;\n\n\t\tif (esd->RegDescriptor) {\n\t\t\tgf_list_add(mdesc->descriptors, esd->RegDescriptor);\n\t\t\tesd->RegDescriptor = NULL;\n\t\t}\n\t\tif (esd->qos) {\n\t\t\tgf_list_add(mdesc->descriptors, esd->qos);\n\t\t\tesd->qos = NULL;\n\t\t}\n\t\tif (esd->ipiPtr) {\n\t\t\tgf_list_add(mdesc->descriptors, esd->ipiPtr);\n\t\t\tesd->ipiPtr= NULL;\n\t\t}\n\n\t\twhile (gf_list_count(esd->IPIDataSet)) {\n\t\t\tGF_Descriptor *desc = (GF_Descriptor *)gf_list_get(esd->IPIDataSet, 0);\n\t\t\tgf_list_rem(esd->IPIDataSet, 0);\n\t\t\tgf_list_add(mdesc->descriptors, desc);\n\t\t}\n\t\twhile (gf_list_count(esd->IPMPDescriptorPointers)) {\n\t\t\tGF_Descriptor *desc = (GF_Descriptor *)gf_list_get(esd->IPMPDescriptorPointers, 0);\n\t\t\tgf_list_rem(esd->IPMPDescriptorPointers, 0);\n\t\t\tgf_list_add(mdesc->descriptors, desc);\n\t\t}\n\t\tif (esd->langDesc) {\n\t\t\tgf_list_add(mdesc->descriptors, esd->langDesc);\n\t\t\tesd->langDesc = NULL;\n\t\t}\n\t\twhile (gf_list_count(esd->extensionDescriptors)) {\n\t\t\tGF_Descriptor *desc = (GF_Descriptor *)gf_list_get(esd->extensionDescriptors, 0);\n\t\t\tgf_list_rem(esd->extensionDescriptors, 0);\n\t\t\tgf_list_add(mdesc->descriptors, desc);\n\t\t}\n\t}\n\n\n\tif (!avc->lhvc_config && (esd->decoderConfig->objectTypeIndication==GF_CODECID_HEVC)) {\n\t\tif (!avc->hevc_config) {\n\t\t\tavc->hevc_config = (GF_HEVCConfigurationBox *)gf_isom_box_new_parent(&avc->child_boxes, GF_ISOM_BOX_TYPE_HVCC);\n\t\t\tif (!avc->hevc_config) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\tif (avc->hevc_config->config) gf_odf_hevc_cfg_del(avc->hevc_config->config);\n\t\t\tavc->hevc_config->config = gf_odf_hevc_cfg_read(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, GF_FALSE);\n\t\t}\n\t}\n\telse if (!avc->svc_config && !avc->mvc_config && (esd->decoderConfig->objectTypeIndication==GF_CODECID_AVC)) {\n\t\tif (!avc->avc_config) {\n\t\t\tavc->avc_config = (GF_AVCConfigurationBox *)gf_isom_box_new_parent(&avc->child_boxes, GF_ISOM_BOX_TYPE_AVCC);\n\t\t\tif (!avc->avc_config) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\tif (avc->avc_config->config) gf_odf_avc_cfg_del(avc->avc_config->config);\n\t\t\tavc->avc_config->config = gf_odf_avc_cfg_read(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t}\n\t}\n\n\tgf_odf_desc_del((GF_Descriptor *)esd);\n\tif (avc->hevc_config) {\n\t\tHEVC_RewriteESDescriptor(avc);\n\t} else {\n\t\tAVC_RewriteESDescriptor(avc);\n\t}\n\treturn GF_OK;\n}\n\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\nvoid gf_hevc_parse_ps(GF_HEVCConfig* hevccfg, HEVCState* hevc, u32 nal_type)\n{\n\tu32 i, j;\n\tif (!hevccfg) return;\n\n\tfor (i = 0; i < gf_list_count(hevccfg->param_array); i++) {\n\t\tGF_NALUFFParamArray* ar = gf_list_get(hevccfg->param_array, i);\n\t\tif (ar->type != nal_type) continue;\n\t\tfor (j = 0; j < gf_list_count(ar->nalus); j++) {\n\t\t\tu8 ntype, tid, lid;\n\t\t\tGF_NALUFFParam* sl = gf_list_get(ar->nalus, j);\n\t\t\tgf_hevc_parse_nalu(sl->data, sl->size, hevc, &ntype, &tid, &lid);\n\t\t}\n\t}\n}\n#endif\n\n#if !defined(GPAC_DISABLE_AV_PARSERS)\nvoid gf_vvc_parse_ps(GF_VVCConfig* vvccfg, VVCState* vvc, u32 nal_type)\n{\n\tu32 i, j;\n\tif (!vvccfg) return;\n\n\tfor (i = 0; i < gf_list_count(vvccfg->param_array); i++) {\n\t\tGF_NALUFFParamArray* ar = gf_list_get(vvccfg->param_array, i);\n\t\tif (ar->type != nal_type) continue;\n\t\tfor (j = 0; j < gf_list_count(ar->nalus); j++) {\n\t\t\tu8 ntype, tid, lid;\n\t\t\tGF_NALUFFParam* sl = gf_list_get(ar->nalus, j);\n\t\t\tgf_vvc_parse_nalu(sl->data, sl->size, vvc, &ntype, &tid, &lid);\n\t\t}\n\t}\n}\n#endif\n\n\nstatic GF_Err gf_isom_check_mvc(GF_ISOFile *the_file, GF_TrackBox *trak, GF_MPEGVisualSampleEntryBox *entry)\n{\n\tu32 i;\n\tGF_Box *mvci;\n\tGF_MultiviewGroupBox *mvcg;\n\tGF_ViewIdentifierBox *vwid;\n\n\tif (entry->mvc_config) {}\n\telse if (entry->avc_config && entry->avc_config->config && entry->avc_config->config->sequenceParameterSetExtensions) {}\n\telse\n\t\treturn GF_OK;\n\n\tmvci = gf_isom_box_find_child(trak->Media->information->child_boxes, GF_ISOM_BOX_TYPE_MVCI);\n\tif (!mvci) {\n\t\tmvci = gf_isom_box_new_parent(&trak->Media->information->child_boxes, GF_ISOM_BOX_TYPE_MVCI);\n\t\tif (!mvci) return GF_OUT_OF_MEM;\n\t}\n\tmvcg = (GF_MultiviewGroupBox *) gf_isom_box_find_child(mvci->child_boxes, GF_ISOM_BOX_TYPE_MVCG);\n\tif (!mvcg) {\n\t\tmvcg = (GF_MultiviewGroupBox *)gf_isom_box_new_parent(&mvci->child_boxes, GF_ISOM_BOX_TYPE_MVCG);\n\t\tif (!mvcg) return GF_OUT_OF_MEM;\n\t}\n\t//this is very crude, we should try to parse the bitstream to fill these\n\tmvcg->num_entries = 0;\n\tif (mvcg->entries) {\n\t\tgf_free(mvcg->entries);\n\t\tmvcg->entries = NULL;\n\t}\n\tif (entry->avc_config) {\n\t\tif (gf_list_count(entry->avc_config->config->sequenceParameterSets))\n\t\t\tmvcg->num_entries += 1;\n\t\tmvcg->num_entries += gf_list_count(entry->avc_config->config->sequenceParameterSetExtensions);\n\t}\n\tif (entry->mvc_config && entry->mvc_config->config) {\n\t\tmvcg->num_entries += gf_list_count(entry->mvc_config->config->sequenceParameterSets);\n\t}\n\tmvcg->entries = gf_malloc(sizeof(MVCIEntry)*mvcg->num_entries);\n\tif (!mvcg->entries) return GF_OUT_OF_MEM;\n\tmemset(mvcg->entries, 0, sizeof(MVCIEntry)*mvcg->num_entries);\n\tfor (i=0; i<mvcg->num_entries; i++) {\n\t\tmvcg->entries[i].entry_type = 2;\n\t\tmvcg->entries[i].output_view_id = i;\n\t}\n\tvwid = (GF_ViewIdentifierBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_VWID);\n\tif (!vwid) {\n\t\tvwid = (GF_ViewIdentifierBox *)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_VWID);\n\t\tif (!mvcg) return GF_OUT_OF_MEM;\n\t}\n\tif (vwid->views) gf_free(vwid->views);\n\tvwid->num_views = mvcg->num_entries;\n\tvwid->views = gf_malloc(sizeof(ViewIDEntry)*vwid->num_views);\n\tif (!vwid->views) return GF_OUT_OF_MEM;\n\tmemset(vwid->views, 0, sizeof(ViewIDEntry)*vwid->num_views);\n\n\tfor (i=0; i<vwid->num_views; i++) {\n\t\tvwid->views[i].base_view_type = i ? 0 : 1;\n\t\tvwid->views[i].view_id = i;\n\t\tvwid->views[i].view_order_index = i;\n\t}\n\n\treturn GF_OK;\n}\n\nstatic GF_AV1Config* AV1_DuplicateConfig(GF_AV1Config const * const cfg)\n{\n\tu32 i = 0;\n\tGF_AV1Config *out = gf_malloc(sizeof(GF_AV1Config));\n\n\tout->marker = cfg->marker;\n\tout->version = cfg->version;\n\tout->seq_profile = cfg->seq_profile;\n\tout->seq_level_idx_0 = cfg->seq_level_idx_0;\n\tout->seq_tier_0 = cfg->seq_tier_0;\n\tout->high_bitdepth = cfg->high_bitdepth;\n\tout->twelve_bit = cfg->twelve_bit;\n\tout->monochrome = cfg->monochrome;\n\tout->chroma_subsampling_x = cfg->chroma_subsampling_x;\n\tout->chroma_subsampling_y = cfg->chroma_subsampling_y;\n\tout->chroma_sample_position = cfg->chroma_sample_position;\n\n\tout->initial_presentation_delay_present = cfg->initial_presentation_delay_present;\n\tout->initial_presentation_delay_minus_one = cfg->initial_presentation_delay_minus_one;\n\tout->obu_array = gf_list_new();\n\tfor (i = 0; i<gf_list_count(cfg->obu_array); ++i) {\n\t\tGF_AV1_OBUArrayEntry *dst = gf_malloc(sizeof(GF_AV1_OBUArrayEntry)), *src = gf_list_get(cfg->obu_array, i);\n\t\tdst->obu_length = src->obu_length;\n\t\tdst->obu_type = src->obu_type;\n\t\tdst->obu = gf_malloc((size_t)dst->obu_length);\n\t\tmemcpy(dst->obu, src->obu, (size_t)src->obu_length);\n\t\tgf_list_add(out->obu_array, dst);\n\t}\n\treturn out;\n}\n\nvoid AV1_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *av1, GF_MediaBox *mdia)\n{\n\tGF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)av1, GF_FALSE);\n\n\tif (av1->emul_esd) gf_odf_desc_del((GF_Descriptor *)av1->emul_esd);\n\tav1->emul_esd = gf_odf_desc_esd_new(2);\n\tav1->emul_esd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\tav1->emul_esd->decoderConfig->objectTypeIndication = GF_CODECID_AV1;\n\n\tif (btrt) {\n\t\tav1->emul_esd->decoderConfig->bufferSizeDB = btrt->bufferSizeDB;\n\t\tav1->emul_esd->decoderConfig->avgBitrate = btrt->avgBitrate;\n\t\tav1->emul_esd->decoderConfig->maxBitrate = btrt->maxBitrate;\n\t}\n\tif (av1->av1_config && av1->av1_config->config) {\n\t\tGF_AV1Config *av1_cfg = AV1_DuplicateConfig(av1->av1_config->config);\n\t\tif (av1_cfg) {\n\t\t\tgf_odf_av1_cfg_write(av1_cfg, &av1->emul_esd->decoderConfig->decoderSpecificInfo->data, &av1->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_odf_av1_cfg_del(av1_cfg);\n\t\t}\n\t}\n}\n\nvoid AV1_RewriteESDescriptor(GF_MPEGVisualSampleEntryBox *av1)\n{\n\tAV1_RewriteESDescriptorEx(av1, NULL);\n}\n\n\n\nstatic GF_VPConfig* VP_DuplicateConfig(GF_VPConfig const * const cfg)\n{\n\tGF_VPConfig *out = gf_odf_vp_cfg_new();\n\tif (out) {\n\t\tout->profile = cfg->profile;\n\t\tout->level = cfg->level;\n\t\tout->bit_depth = cfg->bit_depth;\n\t\tout->chroma_subsampling = cfg->chroma_subsampling;\n\t\tout->video_fullRange_flag = cfg->video_fullRange_flag;\n\t\tout->colour_primaries = cfg->colour_primaries;\n\t\tout->transfer_characteristics = cfg->transfer_characteristics;\n\t\tout->matrix_coefficients = cfg->matrix_coefficients;\n\t}\n\n\treturn out;\n}\n\nvoid VP9_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *vp9, GF_MediaBox *mdia)\n{\n\tGF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)vp9, GF_FALSE);\n\n\tif (vp9->emul_esd) gf_odf_desc_del((GF_Descriptor *)vp9->emul_esd);\n\tvp9->emul_esd = gf_odf_desc_esd_new(2);\n\tvp9->emul_esd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\tif (vp9->type == GF_ISOM_BOX_TYPE_VP08)\n\t\tvp9->emul_esd->decoderConfig->objectTypeIndication = GF_CODECID_VP8;\n\telse\n\t\tvp9->emul_esd->decoderConfig->objectTypeIndication = GF_CODECID_VP9;\n\n\tif (btrt) {\n\t\tvp9->emul_esd->decoderConfig->bufferSizeDB = btrt->bufferSizeDB;\n\t\tvp9->emul_esd->decoderConfig->avgBitrate = btrt->avgBitrate;\n\t\tvp9->emul_esd->decoderConfig->maxBitrate = btrt->maxBitrate;\n\t}\n\n\tif (vp9->vp_config && vp9->vp_config->config) {\n\t\tGF_VPConfig *vp9_cfg = VP_DuplicateConfig(vp9->vp_config->config);\n\t\tif (vp9_cfg) {\n\t\t\tgf_odf_vp_cfg_write(vp9_cfg, &vp9->emul_esd->decoderConfig->decoderSpecificInfo->data, &vp9->emul_esd->decoderConfig->decoderSpecificInfo->dataLength, GF_FALSE);\n\t\t\tgf_odf_vp_cfg_del(vp9_cfg);\n\t\t}\n\t}\n}\n\nvoid VP9_RewriteESDescriptor(GF_MPEGVisualSampleEntryBox *vp9)\n{\n\tVP9_RewriteESDescriptorEx(vp9, NULL);\n}\n\n\n\nstatic GF_DOVIDecoderConfigurationRecord* DOVI_DuplicateConfig(GF_DOVIDecoderConfigurationRecord *cfg)\n{\n\tGF_DOVIDecoderConfigurationRecord* out = NULL;\n\tGF_SAFEALLOC(out, GF_DOVIDecoderConfigurationRecord);\n\tif (!out) return NULL;\n\n\tout->dv_version_major = cfg->dv_version_major;\n\tout->dv_version_minor = cfg->dv_version_minor;\n\tout->dv_profile = cfg->dv_profile;\n\tout->dv_level = cfg->dv_level;\n\tout->rpu_present_flag = cfg->rpu_present_flag;\n\tout->el_present_flag = cfg->el_present_flag;\n\tout->bl_present_flag = cfg->bl_present_flag;\n\n\treturn out;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_EXPORT\nGF_Err gf_isom_avc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_AVCConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_SampleDescriptionBox *stsd;\n\tu32 dataRefIndex;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !cfg) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(the_file, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!the_file->keep_utc && !gf_sys_is_test_mode() )\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\n\t//create a new entry\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new_parent(&stsd->child_boxes, GF_ISOM_BOX_TYPE_AVC1);\n\tif (!entry) return GF_OUT_OF_MEM;\n\t*outDescriptionIndex = gf_list_count(stsd->child_boxes);\n\n\tentry->avc_config = (GF_AVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_AVCC);\n\tif (!entry->avc_config) return GF_OUT_OF_MEM;\n\tentry->avc_config->config = AVC_DuplicateConfig(cfg);\n\tif (!entry->avc_config->config) return GF_OUT_OF_MEM;\n\tentry->dataReferenceIndex = dataRefIndex;\n\tAVC_RewriteESDescriptor(entry);\n\treturn e;\n}\n\nstatic GF_Err gf_isom_avc_config_update_ex(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_AVCConfig *cfg, u32 op_type, Bool keep_xps)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 i;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_BAD_PARAM;\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tswitch (op_type) {\n\t/*AVCC replacement*/\n\tcase 0:\n\t\tif (!cfg) return GF_BAD_PARAM;\n\t\tif (!entry->avc_config) {\n\t\t\tentry->avc_config = (GF_AVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_AVCC);\n\t\t\tif (!entry->avc_config) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (entry->avc_config->config) gf_odf_avc_cfg_del(entry->avc_config->config);\n\t\tentry->avc_config->config = AVC_DuplicateConfig(cfg);\n\t\tif (!entry->avc_config->config) return GF_OUT_OF_MEM;\n\t\tentry->type = GF_ISOM_BOX_TYPE_AVC1;\n\t\tbreak;\n\t/*SVCC replacement*/\n\tcase 1:\n\t\tif (!cfg) return GF_BAD_PARAM;\n\t\tif (!entry->svc_config) {\n\t\t\tentry->svc_config = (GF_AVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_SVCC);\n\t\t\tif (!entry->svc_config) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (entry->svc_config->config) gf_odf_avc_cfg_del(entry->svc_config->config);\n\t\tentry->svc_config->config = AVC_DuplicateConfig(cfg);\n\t\tif (!entry->svc_config->config) return GF_OUT_OF_MEM;\n\t\tentry->type = GF_ISOM_BOX_TYPE_AVC1;\n\t\tbreak;\n\t/*SVCC replacement and AVC removal*/\n\tcase 2:\n\t\tif (!cfg) return GF_BAD_PARAM;\n\t\tif (entry->avc_config) {\n\t\t\tgf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)entry->avc_config);\n\t\t\tentry->avc_config = NULL;\n\t\t}\n\t\tif (!entry->svc_config) {\n\t\t\tentry->svc_config = (GF_AVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_SVCC);\n\t\t\tif (!entry->svc_config) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (entry->svc_config->config) gf_odf_avc_cfg_del(entry->svc_config->config);\n\t\tentry->svc_config->config = AVC_DuplicateConfig(cfg);\n\t\tif (!entry->svc_config->config) return GF_OUT_OF_MEM;\n\t\tentry->type = GF_ISOM_BOX_TYPE_SVC1;\n\t\tbreak;\n\t/*AVCC removal and switch to avc3*/\n\tcase 3:\n\t\tif (!entry->avc_config || !entry->avc_config->config)\n\t\t\treturn GF_BAD_PARAM;\n\t\tif (!keep_xps) {\n\t\t\tfor (i=0; i<3; i++) {\n\t\t\t\tGF_AVCConfigurationBox *a_cfg = entry->avc_config;\n\t\t\t\tif (i==1) a_cfg = entry->svc_config;\n\t\t\t\telse if (i==2) a_cfg = entry->mvc_config;\n\t\t\t\tif (!a_cfg) continue;\n\n\n\t\t\t\twhile (gf_list_count(a_cfg->config->sequenceParameterSets)) {\n\t\t\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam*)gf_list_get(a_cfg->config->sequenceParameterSets, 0);\n\t\t\t\t\tgf_list_rem(a_cfg->config->sequenceParameterSets, 0);\n\t\t\t\t\tif (sl->data) gf_free(sl->data);\n\t\t\t\t\tgf_free(sl);\n\t\t\t\t}\n\n\t\t\t\twhile (gf_list_count(a_cfg->config->pictureParameterSets)) {\n\t\t\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam*)gf_list_get(a_cfg->config->pictureParameterSets, 0);\n\t\t\t\t\tgf_list_rem(a_cfg->config->pictureParameterSets, 0);\n\t\t\t\t\tif (sl->data) gf_free(sl->data);\n\t\t\t\t\tgf_free(sl);\n\t\t\t\t}\n\n\t\t\t\twhile (gf_list_count(a_cfg->config->sequenceParameterSetExtensions)) {\n\t\t\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam*)gf_list_get(a_cfg->config->sequenceParameterSetExtensions, 0);\n\t\t\t\t\tgf_list_rem(a_cfg->config->sequenceParameterSetExtensions, 0);\n\t\t\t\t\tif (sl->data) gf_free(sl->data);\n\t\t\t\t\tgf_free(sl);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (entry->type == GF_ISOM_BOX_TYPE_AVC1)\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_AVC3;\n\t\telse if (entry->type == GF_ISOM_BOX_TYPE_AVC2)\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_AVC4;\n\t\tbreak;\n\t/*MVCC replacement*/\n\tcase 4:\n\t\tif (!cfg) return GF_BAD_PARAM;\n\t\tif (!entry->mvc_config) {\n\t\t\tentry->mvc_config = (GF_AVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_MVCC);\n\t\t\tif (!entry->mvc_config) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (entry->mvc_config->config) gf_odf_avc_cfg_del(entry->mvc_config->config);\n\t\tentry->mvc_config->config = AVC_DuplicateConfig(cfg);\n\t\tif (!entry->mvc_config->config) return GF_OUT_OF_MEM;\n\t\tentry->type = GF_ISOM_BOX_TYPE_AVC1;\n\t\te = gf_isom_check_mvc(the_file, trak, entry);\n\t\tif (e) return e;\n\t\tbreak;\n\t/*MVCC replacement and AVC removal*/\n\tcase 5:\n\t\tif (!cfg) return GF_BAD_PARAM;\n\t\tif (entry->avc_config) {\n\t\t\tgf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)entry->avc_config);\n\t\t\tentry->avc_config = NULL;\n\t\t}\n\t\tif (!entry->mvc_config) {\n\t\t\tentry->mvc_config = (GF_AVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_MVCC);\n\t\t\tif (!entry->mvc_config) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (entry->mvc_config->config) gf_odf_avc_cfg_del(entry->mvc_config->config);\n\t\tentry->mvc_config->config = AVC_DuplicateConfig(cfg);\n\t\tif (!entry->mvc_config->config) return GF_OUT_OF_MEM;\n\t\tentry->type = GF_ISOM_BOX_TYPE_MVC1;\n\t\te = gf_isom_check_mvc(the_file, trak, entry);\n\t\tif (e) return e;\n\t\tbreak;\n\t}\n\tAVC_RewriteESDescriptor(entry);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_avc_set_inband_config(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, Bool keep_xps)\n{\n\treturn gf_isom_avc_config_update_ex(the_file, trackNumber, DescriptionIndex, NULL, 3, keep_xps);\n}\n\nGF_EXPORT\nGF_Err gf_isom_avc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_AVCConfig *cfg)\n{\n\treturn gf_isom_avc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, 0, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_svc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_AVCConfig *cfg, Bool is_add)\n{\n\treturn gf_isom_avc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, is_add ? 1 : 2, GF_FALSE);\n}\n\nGF_Err gf_isom_mvc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_AVCConfig *cfg, Bool is_add)\n{\n\treturn gf_isom_avc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, is_add ? 4 : 5, GF_FALSE);\n}\n\nstatic GF_Err gf_isom_svc_mvc_config_del(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, Bool is_mvc)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_BAD_PARAM;\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (is_mvc && entry->mvc_config) {\n\t\tgf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)entry->mvc_config);\n\t\tentry->mvc_config = NULL;\n\t}\n\telse if (!is_mvc && entry->svc_config) {\n\t\tgf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)entry->svc_config);\n\t\tentry->svc_config = NULL;\n\t}\n\tAVC_RewriteESDescriptor(entry);\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_svc_config_del(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\treturn gf_isom_svc_mvc_config_del(the_file, trackNumber, DescriptionIndex, GF_FALSE);\n}\n\nGF_Err gf_isom_mvc_config_del(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\treturn gf_isom_svc_mvc_config_del(the_file, trackNumber, DescriptionIndex, GF_TRUE);\n}\n\nstatic GF_Err gf_isom_svc_mvc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_AVCConfig *cfg, Bool is_mvc, char *URLname, char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !cfg) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, URLname, URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(the_file, trak->Media->information->dataInformation->dref, URLname, URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!the_file->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\t//create a new entry\n\tif (is_mvc) {\n\t\tentry = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new_parent(&stsd->child_boxes, GF_ISOM_BOX_TYPE_MVC1);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\tentry->mvc_config = (GF_AVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_MVCC);\n\t\tif (!entry->mvc_config) return GF_OUT_OF_MEM;\n\t\tentry->mvc_config->config = AVC_DuplicateConfig(cfg);\n\t\tif (!entry->mvc_config->config) return GF_OUT_OF_MEM;\n\t} else {\n\t\tentry = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new_parent(&stsd->child_boxes,GF_ISOM_BOX_TYPE_SVC1);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\tentry->svc_config = (GF_AVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes,GF_ISOM_BOX_TYPE_SVCC);\n\t\tif (!entry->svc_config) return GF_OUT_OF_MEM;\n\t\tentry->svc_config->config = AVC_DuplicateConfig(cfg);\n\t\tif (!entry->svc_config->config) return GF_OUT_OF_MEM;\n\t}\n\tentry->dataReferenceIndex = dataRefIndex;\n\t*outDescriptionIndex = gf_list_count(stsd->child_boxes);\n\tAVC_RewriteESDescriptor(entry);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_svc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_AVCConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\treturn gf_isom_svc_mvc_config_new(the_file, trackNumber, cfg, GF_FALSE, (char *) URLname, (char *) URNname,outDescriptionIndex);\n}\n\nGF_EXPORT\nGF_Err gf_isom_mvc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_AVCConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\treturn gf_isom_svc_mvc_config_new(the_file, trackNumber, cfg, GF_TRUE, (char *) URLname, (char *) URNname,outDescriptionIndex);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_hevc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_HEVCConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !cfg) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(the_file, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!the_file->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\t//create a new entry\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new_parent(&stsd->child_boxes, GF_ISOM_BOX_TYPE_HVC1);\n\tif (!entry) return GF_OUT_OF_MEM;\n\tentry->hevc_config = (GF_HEVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_HVCC);\n\tif (!entry->hevc_config) return GF_OUT_OF_MEM;\n\tentry->hevc_config->config = HEVC_DuplicateConfig(cfg);\n\tif (!entry->hevc_config->config) return GF_OUT_OF_MEM;\n\tentry->dataReferenceIndex = dataRefIndex;\n\t*outDescriptionIndex = gf_list_count(stsd->child_boxes);\n\tHEVC_RewriteESDescriptor(entry);\n\treturn e;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_vvc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_VVCConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !cfg) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(the_file, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!the_file->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\t//create a new entry\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new_parent(&stsd->child_boxes, GF_ISOM_BOX_TYPE_VVC1);\n\tif (!entry) return GF_OUT_OF_MEM;\n\tentry->vvc_config = (GF_VVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_VVCC);\n\tif (!entry->vvc_config) return GF_OUT_OF_MEM;\n\tentry->vvc_config->config = VVC_DuplicateConfig(cfg);\n\tif (!entry->vvc_config->config) return GF_OUT_OF_MEM;\n\tentry->dataReferenceIndex = dataRefIndex;\n\t*outDescriptionIndex = gf_list_count(stsd->child_boxes);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_vp_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_VPConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex, u32 vpx_type)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !cfg) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(the_file, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!the_file->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\t//create a new entry\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_isom_box_new_parent(&stsd->child_boxes, vpx_type);\n\tif (!entry) return GF_OUT_OF_MEM;\n\n\tentry->vp_config = (GF_VPConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_VPCC);\n\tif (!entry->vp_config) return GF_OUT_OF_MEM;\n\tentry->vp_config->config = VP_DuplicateConfig(cfg);\n\tif (!entry->vp_config->config) return GF_OUT_OF_MEM;\n\tstrncpy(entry->compressor_name, \"\\012VPC Coding\", sizeof(entry->compressor_name)-1);\n\tentry->dataReferenceIndex = dataRefIndex;\n\t*outDescriptionIndex = gf_list_count(stsd->child_boxes);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_av1_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_AV1Config *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !cfg) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(the_file, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!the_file->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\t//create a new entry\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_isom_box_new_parent(&stsd->child_boxes, GF_ISOM_BOX_TYPE_AV01);\n\tif (!entry) return GF_OUT_OF_MEM;\n\tentry->av1_config = (GF_AV1ConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_AV1C);\n\tif (!entry->av1_config) return GF_OUT_OF_MEM;\n\tentry->av1_config->config = AV1_DuplicateConfig(cfg);\n\tif (!entry->av1_config->config) return GF_OUT_OF_MEM;\n\tentry->dataReferenceIndex = dataRefIndex;\n\t*outDescriptionIndex = gf_list_count(stsd->child_boxes);\n\treturn e;\n}\n\n\ntypedef enum\n{\n\tGF_ISOM_HVCC_UPDATE = 0,\n\tGF_ISOM_HVCC_SET_INBAND,\n\tGF_ISOM_HVCC_SET_TILE,\n\tGF_ISOM_HVCC_SET_TILE_BASE_TRACK,\n\tGF_ISOM_HVCC_SET_LHVC,\n\tGF_ISOM_HVCC_SET_LHVC_WITH_BASE,\n\tGF_ISOM_HVCC_SET_LHVC_WITH_BASE_BACKWARD,\n\tGF_ISOM_HVCC_SET_HEVC_TILE_BASE,\n\tGF_ISOM_LHCC_SET_INBAND\n} HevcConfigUpdateType;\n\nstatic Bool nalu_cleanup_config(GF_List *param_array, Bool set_inband, Bool keep_xps)\n{\n\tu32 i;\n\tBool array_incomplete = set_inband;\n\tif (!param_array) return 0;\n\n\tfor (i=0; i<gf_list_count(param_array); i++) {\n\t\tGF_NALUFFParamArray *ar = (GF_NALUFFParamArray*)gf_list_get(param_array, i);\n\n\t\t/*we want to force inband signaling*/\n\t\tif (set_inband) {\n\t\t\tar->array_completeness = 0;\n\t\t\tif (keep_xps) {\n\t\t\t\tarray_incomplete=1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhile (gf_list_count(ar->nalus)) {\n\t\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam*)gf_list_get(ar->nalus, 0);\n\t\t\t\tgf_list_rem(ar->nalus, 0);\n\t\t\t\tif (sl->data) gf_free(sl->data);\n\t\t\t\tgf_free(sl);\n\t\t\t}\n\t\t\tgf_list_del(ar->nalus);\n\t\t\tgf_free(ar);\n\t\t\tar=NULL;\n\t\t\tgf_list_rem(param_array, i);\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ar && !ar->array_completeness)\n\t\t\tarray_incomplete = 1;\n\t}\n\treturn array_incomplete;\n}\n\nstatic\nGF_Err gf_isom_hevc_config_update_ex(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_HEVCConfig *cfg, u32 operand_type, Bool keep_xps)\n{\n\tu32 array_incomplete;\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_BAD_PARAM;\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_list_get(stsd->child_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_LHV1:\n\tcase GF_ISOM_BOX_TYPE_LHE1:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\n\tif (operand_type == GF_ISOM_HVCC_SET_TILE_BASE_TRACK) {\n\t\tif (entry->type==GF_ISOM_BOX_TYPE_HVC1)\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_HVC2;\n\t\telse if (entry->type==GF_ISOM_BOX_TYPE_HEV1)\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_HEV2;\n\t} else if (operand_type == GF_ISOM_HVCC_SET_TILE) {\n\t\tif (!entry->hevc_config) entry->hevc_config = (GF_HEVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_HVCC);\n\t\tif (!entry->hevc_config) return GF_OUT_OF_MEM;\n\t\tif (entry->hevc_config->config) gf_odf_hevc_cfg_del(entry->hevc_config->config);\n\t\tentry->hevc_config->config = NULL;\n\t\tentry->type = GF_ISOM_BOX_TYPE_HVT1;\n\t} else if (operand_type < GF_ISOM_HVCC_SET_LHVC) {\n\t\tif ((operand_type != GF_ISOM_HVCC_SET_INBAND) && !entry->hevc_config) {\n\t\t\tentry->hevc_config = (GF_HEVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_HVCC);\n\t\t\tif (!entry->hevc_config) return GF_OUT_OF_MEM;\n\t\t}\n\n\t\tif (cfg) {\n\t\t\tif (entry->hevc_config->config) gf_odf_hevc_cfg_del(entry->hevc_config->config);\n\t\t\tentry->hevc_config->config = HEVC_DuplicateConfig(cfg);\n\t\t} else {\n\t\t\toperand_type=GF_ISOM_HVCC_SET_INBAND;\n\t\t}\n\t\tarray_incomplete = (operand_type==GF_ISOM_HVCC_SET_INBAND) ? 1 : 0;\n\t\tif (entry->hevc_config && nalu_cleanup_config(entry->hevc_config->config ? entry->hevc_config->config->param_array : NULL,\n\t\t\t(operand_type==GF_ISOM_HVCC_SET_INBAND) ? GF_TRUE:GF_FALSE,\n\t\t\tkeep_xps)\n\t\t) {\n\t\t\tarray_incomplete=1;\n\t\t}\n\n\t\tif (entry->lhvc_config && nalu_cleanup_config(entry->lhvc_config->config ? entry->lhvc_config->config->param_array : NULL,\n\t\t\t(operand_type==GF_ISOM_HVCC_SET_INBAND),\n\t\t\tkeep_xps)\n\t\t)\n\t\t\tarray_incomplete=1;\n\n\t\tswitch (entry->type) {\n\t\tcase GF_ISOM_BOX_TYPE_HEV1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC1:\n\t\t\tentry->type = array_incomplete ? GF_ISOM_BOX_TYPE_HEV1 : GF_ISOM_BOX_TYPE_HVC1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_HEV2:\n\t\tcase GF_ISOM_BOX_TYPE_HVC2:\n\t\t\tentry->type = array_incomplete ? GF_ISOM_BOX_TYPE_HEV2 : GF_ISOM_BOX_TYPE_HVC2;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_LHE1:\n\t\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\t\tentry->type = array_incomplete ? GF_ISOM_BOX_TYPE_LHE1 : GF_ISOM_BOX_TYPE_LHV1;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\n\t\t/*SVCC replacement/removal with HEVC base, backward compatible signaling*/\n\t\tif ((operand_type==GF_ISOM_HVCC_SET_LHVC_WITH_BASE_BACKWARD) || (operand_type==GF_ISOM_HVCC_SET_LHVC_WITH_BASE) || (operand_type==GF_ISOM_HVCC_SET_HEVC_TILE_BASE) ) {\n\t\t\tif (!entry->hevc_config) return GF_BAD_PARAM;\n\t\t\tif (!cfg) {\n\t\t\t\tif (entry->lhvc_config) {\n\t\t\t\t\tgf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)entry->lhvc_config);\n\t\t\t\t\tentry->lhvc_config = NULL;\n\t\t\t\t}\n\t\t\t\tif (entry->type==GF_ISOM_BOX_TYPE_LHE1) entry->type = (operand_type==GF_ISOM_HVCC_SET_LHVC_WITH_BASE) ? GF_ISOM_BOX_TYPE_HEV2 : GF_ISOM_BOX_TYPE_HEV1;\n\t\t\t\telse if (entry->type==GF_ISOM_BOX_TYPE_HEV1) entry->type = (operand_type==GF_ISOM_HVCC_SET_LHVC_WITH_BASE) ? GF_ISOM_BOX_TYPE_HEV2 : GF_ISOM_BOX_TYPE_HEV1;\n\t\t\t\telse entry->type =  (operand_type==GF_ISOM_HVCC_SET_LHVC_WITH_BASE) ? GF_ISOM_BOX_TYPE_HVC2 : GF_ISOM_BOX_TYPE_HVC1;\n\t\t\t} else {\n\t\t\t\tif (operand_type != GF_ISOM_HVCC_SET_HEVC_TILE_BASE) {\n\t\t\t\t\tif (!entry->lhvc_config) {\n\t\t\t\t\t\tentry->lhvc_config = (GF_HEVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_LHVC);\n\t\t\t\t\t\tif (!entry->lhvc_config) return GF_OUT_OF_MEM;\n\t\t\t\t\t}\n\t\t\t\t\tif (entry->lhvc_config->config) gf_odf_hevc_cfg_del(entry->lhvc_config->config);\n\t\t\t\t\tentry->lhvc_config->config = HEVC_DuplicateConfig(cfg);\n\t\t\t\t\tif (!entry->lhvc_config->config) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\n\t\t\t\tif (operand_type==GF_ISOM_HVCC_SET_LHVC_WITH_BASE_BACKWARD) {\n\t\t\t\t\tif (entry->type==GF_ISOM_BOX_TYPE_HEV2) entry->type = GF_ISOM_BOX_TYPE_HEV1;\n\t\t\t\t\telse entry->type = GF_ISOM_BOX_TYPE_HVC1;\n\t\t\t\t} else {\n\t\t\t\t\tif (entry->type==GF_ISOM_BOX_TYPE_HEV1) entry->type = GF_ISOM_BOX_TYPE_HEV2;\n\t\t\t\t\telse entry->type = GF_ISOM_BOX_TYPE_HVC2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*LHEVC track without base*/\n\t\telse if (operand_type==GF_ISOM_HVCC_SET_LHVC) {\n\t\t\tif (entry->hevc_config) {\n\t\t\t\tgf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)entry->hevc_config);\n\t\t\t\tentry->hevc_config=NULL;\n\t\t\t}\n\t\t\tif (!cfg) return GF_BAD_PARAM;\n\n\t\t\tif (!entry->lhvc_config) {\n\t\t\t\tentry->lhvc_config = (GF_HEVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_LHVC);\n\t\t\t\tif (!entry->lhvc_config) return GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tif (entry->lhvc_config->config) gf_odf_hevc_cfg_del(entry->lhvc_config->config);\n\t\t\tentry->lhvc_config->config = HEVC_DuplicateConfig(cfg);\n\t\t\tif (!entry->lhvc_config->config) return GF_OUT_OF_MEM;\n\n\t\t\tif ((entry->type==GF_ISOM_BOX_TYPE_HEV1) || (entry->type==GF_ISOM_BOX_TYPE_HEV2)) entry->type = GF_ISOM_BOX_TYPE_LHE1;\n\t\t\telse entry->type = GF_ISOM_BOX_TYPE_LHV1;\n\t\t}\n\t\t/*LHEVC inband, no config change*/\n\t\telse if (operand_type==GF_ISOM_LHCC_SET_INBAND) {\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_LHE1;\n\t\t}\n\t}\n\n\tHEVC_RewriteESDescriptor(entry);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_hevc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_HEVCConfig *cfg)\n{\n\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, GF_ISOM_HVCC_UPDATE, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_hevc_set_inband_config(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, Bool keep_xps)\n{\n\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, NULL, GF_ISOM_HVCC_SET_INBAND, keep_xps);\n}\n\nGF_EXPORT\nGF_Err gf_isom_lhvc_force_inband_config(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, NULL, GF_ISOM_LHCC_SET_INBAND, GF_FALSE);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_hevc_set_tile_config(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_HEVCConfig *cfg, Bool is_base_track)\n{\n\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, is_base_track ? GF_ISOM_HVCC_SET_TILE_BASE_TRACK : GF_ISOM_HVCC_SET_TILE, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_lhvc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_HEVCConfig *cfg, GF_ISOMLHEVCTrackType track_type)\n{\n\tif (cfg) cfg->is_lhvc = GF_TRUE;\n\tswitch (track_type) {\n\tcase GF_ISOM_LEHVC_ONLY:\n\t\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, GF_ISOM_HVCC_SET_LHVC, GF_FALSE);\n\tcase GF_ISOM_LEHVC_WITH_BASE:\n\t\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, GF_ISOM_HVCC_SET_LHVC_WITH_BASE, GF_FALSE);\n\tcase GF_ISOM_LEHVC_WITH_BASE_BACKWARD:\n\t\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, GF_ISOM_HVCC_SET_LHVC_WITH_BASE_BACKWARD, GF_FALSE);\n\tcase GF_ISOM_HEVC_TILE_BASE:\n\t\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, GF_ISOM_HVCC_SET_HEVC_TILE_BASE, GF_FALSE);\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\n\ntypedef enum\n{\n\tGF_ISOM_VVCC_UPDATE = 0,\n\tGF_ISOM_VVCC_SET_INBAND,\n} VvcConfigUpdateType;\n\n\nstatic\nGF_Err gf_isom_vvc_config_update_ex(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_VVCConfig *cfg, u32 operand_type, Bool keep_xps)\n{\n\tu32 array_incomplete;\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_BAD_PARAM;\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_list_get(stsd->child_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_VVC1:\n\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\n\tif (operand_type <= GF_ISOM_VVCC_SET_INBAND) {\n\t\tif ((operand_type != GF_ISOM_VVCC_SET_INBAND) && !entry->vvc_config) {\n\t\t\tentry->vvc_config = (GF_VVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_VVCC);\n\t\t\tif (!entry->vvc_config) return GF_OUT_OF_MEM;\n\t\t}\n\n\t\tif (cfg) {\n\t\t\tif (entry->vvc_config->config) gf_odf_vvc_cfg_del(entry->vvc_config->config);\n\t\t\tentry->vvc_config->config = VVC_DuplicateConfig(cfg);\n\t\t} else {\n\t\t\toperand_type = GF_ISOM_VVCC_SET_INBAND;\n\t\t}\n\t\tif (operand_type == GF_ISOM_VVCC_UPDATE) {\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tarray_incomplete = (operand_type==GF_ISOM_VVCC_SET_INBAND) ? 1 : 0;\n\t\tif (entry->vvc_config && nalu_cleanup_config(entry->vvc_config->config ? entry->vvc_config->config->param_array : NULL,\n\t\t\t(operand_type==GF_ISOM_VVCC_SET_INBAND),\n\t\t\tkeep_xps)\n\t\t) {\n\t\t\tarray_incomplete=1;\n\t\t}\n\t\tswitch (entry->type) {\n\t\tcase GF_ISOM_BOX_TYPE_VVC1:\n\t\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\t\tentry->type = array_incomplete ? GF_ISOM_BOX_TYPE_VVI1 : GF_ISOM_BOX_TYPE_VVC1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_vvc_set_inband_config(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, Bool keep_xps)\n{\n\treturn gf_isom_vvc_config_update_ex(the_file, trackNumber, DescriptionIndex, NULL, GF_ISOM_VVCC_SET_INBAND, keep_xps);\n}\n\nGF_EXPORT\nGF_Err gf_isom_vvc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_VVCConfig *cfg)\n{\n\treturn gf_isom_vvc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, GF_ISOM_VVCC_UPDATE, GF_FALSE);\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_EXPORT\nGF_Box *gf_isom_clone_config_box(GF_Box *box)\n{\n\tu8 *data=NULL;\n\tu32 size=0;\n\tGF_Err e;\n\tGF_Box *clone=NULL;\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\te = gf_isom_box_size(box);\n\tif (!e)\n\t\te = gf_isom_box_write(box, bs);\n\n\tgf_bs_get_content(bs, &data, &size);\n\tgf_bs_del(bs);\n\tif (!e) {\n\t\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\t\te = gf_isom_box_parse(&clone, bs);\n\t\tgf_bs_del(bs);\n\t}\n\tif (data)\n\t\tgf_free(data);\n\tif (e) {\n\t\tif (clone)\n\t\t\tgf_isom_box_del(clone);\n\t\tclone = NULL;\n\t}\n\treturn clone;\n}\n\nGF_EXPORT\nGF_AVCConfig *gf_isom_avc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_avc_svc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_AVCTYPE_NONE)\n\t\treturn NULL;\n\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\tif (!entry->avc_config) return NULL;\n\treturn AVC_DuplicateConfig(entry->avc_config->config);\n}\n\nGF_EXPORT\nGF_HEVCConfig *gf_isom_hevc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_hevc_lhvc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_HEVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\tif (!entry->hevc_config) return NULL;\n\treturn HEVC_DuplicateConfig(entry->hevc_config->config);\n}\n\nGF_EXPORT\nGF_ISOMVVCType gf_isom_get_vvc_type(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tu32 type;\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_ISOM_VVCTYPE_NONE;\n\tif (!gf_isom_is_video_handler_type(trak->Media->handler->handlerType))\n\t\treturn GF_ISOM_VVCTYPE_NONE;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_ISOM_VVCTYPE_NONE;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_ISOM_VVCTYPE_NONE;\n\ttype = entry->type;\n\n\tif (type == GF_ISOM_BOX_TYPE_ENCV) {\n\t\tGF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\tif (sinf && sinf->original_format) type = sinf->original_format->data_format;\n\t}\n\telse if (type == GF_ISOM_BOX_TYPE_RESV) {\n\t\tif (entry->rinf && entry->rinf->original_format) type = entry->rinf->original_format->data_format;\n\t}\n\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_VVC1:\n\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\treturn GF_ISOM_VVCTYPE_ONLY;\n\tcase GF_ISOM_SUBTYPE_VVS1:\n\t\treturn GF_ISOM_VVCTYPE_SUBPIC;\n\tcase GF_ISOM_SUBTYPE_VVCN:\n\t\treturn GF_ISOM_VVCTYPE_NVCL;\n\tdefault:\n\t\treturn GF_ISOM_VVCTYPE_NONE;\n\t}\n\treturn GF_ISOM_VVCTYPE_NONE;\n}\n\nGF_EXPORT\nGF_VVCConfig *gf_isom_vvc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tu32 type;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\t/*todo, add support for subpic track and nvcl tracks*/\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\ttype = gf_isom_get_vvc_type(the_file, trackNumber, DescriptionIndex);\n\tif (type==GF_ISOM_VVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\n\tif ((type==GF_ISOM_VVCTYPE_SUBPIC) || (type==GF_ISOM_VVCTYPE_NVCL)) {\n\t\tGF_VVCNaluConfigurationBox *vvnc = (GF_VVCNaluConfigurationBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_VVNC);\n\t\tif (!vvnc) return NULL;\n\t\tGF_VVCConfig *vvcc = gf_odf_vvc_cfg_new();\n\t\tvvcc->nal_unit_size = vvnc->nal_unit_size;\n\t\treturn vvcc;\n\t}\n\tif (!entry->vvc_config) return NULL;\n\treturn VVC_DuplicateConfig(entry->vvc_config->config);\n}\n\nGF_EXPORT\nGF_AVCConfig *gf_isom_svc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_avc_svc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_AVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\tif (!entry->svc_config) return NULL;\n\treturn AVC_DuplicateConfig(entry->svc_config->config);\n}\n\n\nGF_EXPORT\nGF_AVCConfig *gf_isom_mvc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_avc_svc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_AVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\tif (!entry->mvc_config) return NULL;\n\treturn AVC_DuplicateConfig(entry->mvc_config->config);\n}\n\nGF_EXPORT\nGF_AV1Config *gf_isom_av1_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex - 1);\n\tif (!entry) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\tif (!entry->av1_config|| !entry->av1_config->config) return NULL;\n\treturn AV1_DuplicateConfig(entry->av1_config->config);\n}\n\n\nGF_EXPORT\nGF_VPConfig *gf_isom_vp_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex - 1);\n\tif (!entry) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\tif (!entry->vp_config || !entry->vp_config->config) return NULL;\n\treturn VP_DuplicateConfig(entry->vp_config->config);\n}\n\nGF_EXPORT\nGF_DOVIDecoderConfigurationRecord *gf_isom_dovi_config_get(GF_ISOFile* the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox* trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex - 1);\n\tif (!entry) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\tif (!entry->size || !entry->dovi_config) return NULL;\n\treturn DOVI_DuplicateConfig(&entry->dovi_config->DOVIConfig);\n}\n\nGF_EXPORT\nGF_ISOMAVCType gf_isom_get_avc_svc_type(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tu32 type;\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->handler || !DescriptionIndex) return GF_ISOM_AVCTYPE_NONE;\n\tif (!gf_isom_is_video_handler_type(trak->Media->handler->handlerType))\n\t\treturn GF_ISOM_AVCTYPE_NONE;\n\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_ISOM_AVCTYPE_NONE;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_ISOM_AVCTYPE_NONE;\n\n\ttype = entry->type;\n\n\tif (type == GF_ISOM_BOX_TYPE_ENCV) {\n\t\tGF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\tif (sinf && sinf->original_format) type = sinf->original_format->data_format;\n\t}\n\telse if (type == GF_ISOM_BOX_TYPE_RESV) {\n\t\tif (entry->rinf && entry->rinf->original_format) type = entry->rinf->original_format->data_format;\n\t}\n\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\tcase GF_ISOM_BOX_TYPE_DVA1:\n\tcase GF_ISOM_BOX_TYPE_DVAV:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_AVCTYPE_NONE;\n\t}\n\tif (entry->avc_config && !entry->svc_config && !entry->mvc_config) return GF_ISOM_AVCTYPE_AVC_ONLY;\n\tif (entry->avc_config && entry->svc_config) return GF_ISOM_AVCTYPE_AVC_SVC;\n\tif (entry->avc_config && entry->mvc_config) return GF_ISOM_AVCTYPE_AVC_MVC;\n\tif (!entry->avc_config && entry->svc_config) return GF_ISOM_AVCTYPE_SVC_ONLY;\n\tif (!entry->avc_config && entry->mvc_config) return GF_ISOM_AVCTYPE_MVC_ONLY;\n\treturn GF_ISOM_AVCTYPE_NONE;\n}\n\nGF_EXPORT\nGF_ISOMHEVCType gf_isom_get_hevc_lhvc_type(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tu32 type;\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_ISOM_HEVCTYPE_NONE;\n\tif (!gf_isom_is_video_handler_type(trak->Media->handler->handlerType))\n\t\treturn GF_ISOM_HEVCTYPE_NONE;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_ISOM_HEVCTYPE_NONE;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_ISOM_HEVCTYPE_NONE;\n\ttype = entry->type;\n\n\tif (type == GF_ISOM_BOX_TYPE_ENCV) {\n\t\tGF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\tif (sinf && sinf->original_format) type = sinf->original_format->data_format;\n\t}\n\telse if (type == GF_ISOM_BOX_TYPE_RESV) {\n\t\tif (entry->rinf && entry->rinf->original_format) type = entry->rinf->original_format->data_format;\n\t}\n\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_LHV1:\n\tcase GF_ISOM_BOX_TYPE_LHE1:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\tcase GF_ISOM_BOX_TYPE_DVHE:\n\tcase GF_ISOM_BOX_TYPE_DVH1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_HEVCTYPE_NONE;\n\t}\n\tif (entry->hevc_config && !entry->lhvc_config) return GF_ISOM_HEVCTYPE_HEVC_ONLY;\n\tif (entry->hevc_config && entry->lhvc_config) return GF_ISOM_HEVCTYPE_HEVC_LHVC;\n\tif (!entry->hevc_config && entry->lhvc_config) return GF_ISOM_HEVCTYPE_LHVC_ONLY;\n\treturn GF_ISOM_HEVCTYPE_NONE;\n}\n\nGF_EXPORT\nGF_HEVCConfig *gf_isom_lhvc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_HEVCConfig *lhvc;\n\tGF_OperatingPointsInformation *oinf=NULL;\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_hevc_lhvc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_HEVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\tif (!entry->lhvc_config) return NULL;\n\tlhvc = HEVC_DuplicateConfig(entry->lhvc_config->config);\n\tif (!lhvc) return NULL;\n\n\tgf_isom_get_oinf_info(the_file, trackNumber, &oinf);\n\tif (oinf) {\n\t\tLHEVC_ProfileTierLevel *ptl = (LHEVC_ProfileTierLevel *)gf_list_last(oinf->profile_tier_levels);\n\t\tif (ptl) {\n\t\t\tlhvc->profile_space  = ptl->general_profile_space;\n\t\t\tlhvc->tier_flag = ptl->general_tier_flag;\n\t\t\tlhvc->profile_idc = ptl->general_profile_idc;\n\t\t\tlhvc->general_profile_compatibility_flags = ptl->general_profile_compatibility_flags;\n\t\t\tlhvc->constraint_indicator_flags = ptl->general_constraint_indicator_flags;\n\t\t}\n\t}\n\treturn lhvc;\n}\n\n\nvoid btrt_box_del(GF_Box *s)\n{\n\tGF_BitRateBox *ptr = (GF_BitRateBox *)s;\n\tif (ptr) gf_free(ptr);\n}\nGF_Err btrt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_BitRateBox *ptr = (GF_BitRateBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 12)\n\tptr->bufferSizeDB = gf_bs_read_u32(bs);\n\tptr->maxBitrate = gf_bs_read_u32(bs);\n\tptr->avgBitrate = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *btrt_box_new()\n{\n\tGF_BitRateBox *tmp = (GF_BitRateBox *) gf_malloc(sizeof(GF_BitRateBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_BitRateBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_BTRT;\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err btrt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_BitRateBox *ptr = (GF_BitRateBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->bufferSizeDB);\n\tgf_bs_write_u32(bs, ptr->maxBitrate);\n\tgf_bs_write_u32(bs, ptr->avgBitrate);\n\treturn GF_OK;\n}\nGF_Err btrt_box_size(GF_Box *s)\n{\n\tGF_BitRateBox *ptr = (GF_BitRateBox *)s;\n\tptr->size += 12;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid m4ds_box_del(GF_Box *s)\n{\n\tGF_MPEG4ExtensionDescriptorsBox *ptr = (GF_MPEG4ExtensionDescriptorsBox *)s;\n\tgf_odf_desc_list_del(ptr->descriptors);\n\tgf_list_del(ptr->descriptors);\n\tgf_free(ptr);\n}\nGF_Err m4ds_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tchar *enc_od;\n\tGF_MPEG4ExtensionDescriptorsBox *ptr = (GF_MPEG4ExtensionDescriptorsBox *)s;\n\tu32 od_size = (u32) ptr->size;\n\tif (!od_size) return GF_OK;\n\tenc_od = (char *)gf_malloc(sizeof(char) * od_size);\n\tgf_bs_read_data(bs, enc_od, od_size);\n\te = gf_odf_desc_list_read((char *)enc_od, od_size, ptr->descriptors);\n\tgf_free(enc_od);\n\treturn e;\n}\nGF_Box *m4ds_box_new()\n{\n\tGF_MPEG4ExtensionDescriptorsBox *tmp = (GF_MPEG4ExtensionDescriptorsBox *) gf_malloc(sizeof(GF_MPEG4ExtensionDescriptorsBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_MPEG4ExtensionDescriptorsBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_M4DS;\n\ttmp->descriptors = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err m4ds_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu8 *enc_ods;\n\tu32 enc_od_size;\n\tGF_MPEG4ExtensionDescriptorsBox *ptr = (GF_MPEG4ExtensionDescriptorsBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tenc_ods = NULL;\n\tenc_od_size = 0;\n\te = gf_odf_desc_list_write(ptr->descriptors, &enc_ods, &enc_od_size);\n\tif (e) return e;\n\tif (enc_od_size) {\n\t\tgf_bs_write_data(bs, enc_ods, enc_od_size);\n\t\tgf_free(enc_ods);\n\t}\n\treturn GF_OK;\n}\nGF_Err m4ds_box_size(GF_Box *s)\n{\n\tGF_Err e;\n\tu32 descSize = 0;\n\tGF_MPEG4ExtensionDescriptorsBox *ptr = (GF_MPEG4ExtensionDescriptorsBox *)s;\n\te = gf_odf_desc_list_size(ptr->descriptors, &descSize);\n\tptr->size += descSize;\n\treturn e;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid avcc_box_del(GF_Box *s)\n{\n\tGF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *)s;\n\tif (ptr->config) gf_odf_avc_cfg_del(ptr->config);\n\tptr->config = NULL;\n\tgf_free(ptr);\n}\n\nGF_Err avcc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, count;\n\tGF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *)s;\n\n\tif (ptr->config) gf_odf_avc_cfg_del(ptr->config);\n\tptr->config = gf_odf_avc_cfg_new();\n\n\tISOM_DECREASE_SIZE(ptr, 7) //7 includes the 2 counts of sps and pps\n\n\tBool is_avcc;\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_AVCC) || (ptr->type==GF_ISOM_BOX_TYPE_AVCE))\n\t\tis_avcc = GF_TRUE;\n\telse\n\t\tis_avcc = GF_FALSE;\n\n\t//we don't use gf_odf_avc_cfg_read to deal with missing rext profile signaling on many files\n\tptr->config->configurationVersion = gf_bs_read_u8(bs);\n\tptr->config->AVCProfileIndication = gf_bs_read_u8(bs);\n\tptr->config->profile_compatibility = gf_bs_read_u8(bs);\n\tptr->config->AVCLevelIndication = gf_bs_read_u8(bs);\n\tif (is_avcc) {\n\t\tgf_bs_read_int(bs, 6);\n\t} else {\n\t\tptr->config->complete_representation = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 5);\n\t}\n\tptr->config->nal_unit_size = 1 + gf_bs_read_int(bs, 2);\n\tgf_bs_read_int(bs, 3);\n\tcount = gf_bs_read_int(bs, 5);\n\n\tfor (i=0; i<count; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *) gf_malloc(sizeof(GF_NALUFFParam));\n\t\tsl->size = gf_bs_read_u16(bs);\n\t\tif (!sl->size || (gf_bs_available(bs) < sl->size) || (ptr->size < sl->size) ) {\n\t\t\tgf_free(sl);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"AVCC: Not enough bits to parse. Aborting.\\n\"));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tsl->data = (char *)gf_malloc(sizeof(char) * sl->size);\n\t\tgf_bs_read_data(bs, sl->data, sl->size);\n\t\tgf_list_add(ptr->config->sequenceParameterSets, sl);\n\t\tptr->size -= sl->size;\n\t}\n\n\tcount = gf_bs_read_u8(bs);\n\tfor (i=0; i<count; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_malloc(sizeof(GF_NALUFFParam));\n\t\tsl->size = gf_bs_read_u16(bs);\n\t\tif (!sl->size || (gf_bs_available(bs) < sl->size) || (ptr->size<sl->size)) {\n\t\t\tgf_free(sl);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"AVCC: Not enough bits to parse. Aborting.\\n\"));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tsl->data = (char *)gf_malloc(sizeof(char) * sl->size);\n\t\tgf_bs_read_data(bs, sl->data, sl->size);\n\t\tgf_list_add(ptr->config->pictureParameterSets, sl);\n\t\tptr->size -= sl->size;\n\t}\n\n\t//not avcC (svcC; mvcC), no check for rext signaling\n\tif (!is_avcc)\n\t\treturn GF_OK;\n\n\t//not REXT profile, no check for rext signaling\n\tif (!gf_avcc_use_extensions(ptr->config->AVCProfileIndication))\n\t\treturn GF_OK;\n\n\t//non-compliant file (rext signaling missing), try to fill in values from SPS\n\tif (!ptr->size) {\n\t\t/*set default values ...*/\n\t\tptr->config->chroma_format = 1;\n\t\tptr->config->luma_bit_depth = 8;\n\t\tptr->config->chroma_bit_depth = 8;\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam*)gf_list_get(ptr->config->sequenceParameterSets, 0);\n\t\tif (sl) {\n\t\t\tAVCState avc;\n\t\t\ts32 idx;\n\t\t\tmemset(&avc, 0, sizeof(AVCState));\n\t\t\tidx = gf_avc_read_sps(sl->data, sl->size, &avc, 0, NULL);\n\t\t\tif (idx>=0) {\n\t\t\t\tptr->config->chroma_format = avc.sps[idx].chroma_format;\n\t\t\t\tptr->config->luma_bit_depth = 8 + avc.sps[idx].luma_bit_depth_m8;\n\t\t\t\tptr->config->chroma_bit_depth = 8 + avc.sps[idx].chroma_bit_depth_m8;\n\t\t\t}\n\t\t}\n#endif\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[isom/avcc] Missing REXT profile signaling, patching.\\n\"));\n\t\treturn GF_OK;\n\t}\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tgf_bs_read_int(bs, 6);\n\tptr->config->chroma_format = gf_bs_read_int(bs, 2);\n\tgf_bs_read_int(bs, 5);\n\tptr->config->luma_bit_depth = 8 + gf_bs_read_int(bs, 3);\n\tgf_bs_read_int(bs, 5);\n\tptr->config->chroma_bit_depth = 8 + gf_bs_read_int(bs, 3);\n\n\tcount = gf_bs_read_int(bs, 8);\n\tif (count*2 > ptr->size) {\n\t\t//ffmpeg just ignores this part while allocating bytes (filled with garbage?)\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"AVCC: invalid numOfSequenceParameterSetExt value. Skipping.\\n\"));\n\t\treturn GF_OK;\n\t}\n\tif (count) {\n\t\tptr->config->sequenceParameterSetExtensions = gf_list_new();\n\t\tfor (i=0; i<count; i++) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_malloc(sizeof(GF_NALUFFParam));\n\t\t\tsl->size = gf_bs_read_u16(bs);\n\t\t\tif ((gf_bs_available(bs) < sl->size) || (ptr->size<sl->size)) {\n\t\t\t\tgf_free(sl);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"AVCC: Not enough bits to parse. Aborting.\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tsl->data = (char *)gf_malloc(sizeof(char) * sl->size);\n\t\t\tgf_bs_read_data(bs, sl->data, sl->size);\n\t\t\tgf_list_add(ptr->config->sequenceParameterSetExtensions, sl);\n\t\t\tptr->size -= sl->size;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *avcc_box_new()\n{\n\tGF_AVCConfigurationBox *tmp = (GF_AVCConfigurationBox *) gf_malloc(sizeof(GF_AVCConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_AVCConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_AVCC;\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err avcc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, count;\n\tGF_Err e;\n\tGF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (!ptr->config) return GF_OK;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tBool is_avcc;\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_AVCC) || (ptr->type==GF_ISOM_BOX_TYPE_AVCE))\n\t\tis_avcc = GF_TRUE;\n\telse\n\t\tis_avcc = GF_FALSE;\n\n\tgf_bs_write_u8(bs, ptr->config->configurationVersion);\n\tgf_bs_write_u8(bs, ptr->config->AVCProfileIndication);\n\tgf_bs_write_u8(bs, ptr->config->profile_compatibility);\n\tgf_bs_write_u8(bs, ptr->config->AVCLevelIndication);\n\tif (is_avcc) {\n\t\tgf_bs_write_int(bs, 0x3F, 6);\n\t} else {\n\t\tgf_bs_write_int(bs, ptr->config->complete_representation, 1);\n\t\tgf_bs_write_int(bs, 0x1F, 5);\n\t}\n\tgf_bs_write_int(bs, ptr->config->nal_unit_size - 1, 2);\n\tgf_bs_write_int(bs, 0x7, 3);\n\tcount = gf_list_count(ptr->config->sequenceParameterSets);\n\tgf_bs_write_int(bs, count, 5);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *) gf_list_get(ptr->config->sequenceParameterSets, i);\n\t\tgf_bs_write_u16(bs, sl->size);\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n\n\tcount = gf_list_count(ptr->config->pictureParameterSets);\n\tgf_bs_write_u8(bs, count);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *) gf_list_get(ptr->config->pictureParameterSets, i);\n\t\tgf_bs_write_u16(bs, sl->size);\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n\n\n\tif (is_avcc) {\n\t\tif (gf_avcc_use_extensions(ptr->config->AVCProfileIndication)) {\n\t\t\tgf_bs_write_int(bs, 0xFF, 6);\n\t\t\tgf_bs_write_int(bs, ptr->config->chroma_format, 2);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, ptr->config->luma_bit_depth - 8, 3);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, ptr->config->chroma_bit_depth - 8, 3);\n\n\t\t\tcount = ptr->config->sequenceParameterSetExtensions ? gf_list_count(ptr->config->sequenceParameterSetExtensions) : 0;\n\t\t\tgf_bs_write_u8(bs, count);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *) gf_list_get(ptr->config->sequenceParameterSetExtensions, i);\n\t\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\nGF_Err avcc_box_size(GF_Box *s)\n{\n\tu32 i, count;\n\tGF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *)s;\n\n\tif (!ptr->config) {\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\tptr->size += 7;\n\tcount = gf_list_count(ptr->config->sequenceParameterSets);\n\tfor (i=0; i<count; i++)\n\t\tptr->size += 2 + ((GF_NALUFFParam *)gf_list_get(ptr->config->sequenceParameterSets, i))->size;\n\n\tcount = gf_list_count(ptr->config->pictureParameterSets);\n\tfor (i=0; i<count; i++)\n\t\tptr->size += 2 + ((GF_NALUFFParam *)gf_list_get(ptr->config->pictureParameterSets, i))->size;\n\n\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_AVCC) || (ptr->type==GF_ISOM_BOX_TYPE_AVCE)) {\n\t\tif (gf_avcc_use_extensions(ptr->config->AVCProfileIndication)) {\n\t\t\tptr->size += 4;\n\t\t\tcount = ptr->config->sequenceParameterSetExtensions ?gf_list_count(ptr->config->sequenceParameterSetExtensions) : 0;\n\t\t\tfor (i=0; i<count; i++)\n\t\t\t\tptr->size += 2 + ((GF_NALUFFParam *)gf_list_get(ptr->config->sequenceParameterSetExtensions, i))->size;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid hvcc_box_del(GF_Box *s)\n{\n\tGF_HEVCConfigurationBox *ptr = (GF_HEVCConfigurationBox*)s;\n\tif (ptr->config) gf_odf_hevc_cfg_del(ptr->config);\n\tgf_free(ptr);\n}\n\nGF_Err hvcc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu64 consumed;\n\tGF_HEVCConfigurationBox *ptr = (GF_HEVCConfigurationBox *)s;\n\n\tif (ptr->config) gf_odf_hevc_cfg_del(ptr->config);\n\n\tconsumed = gf_bs_get_position(bs);\n\tswitch (s->type) {\n\tcase GF_ISOM_BOX_TYPE_HVCC:\n\tcase GF_ISOM_BOX_TYPE_HVCE:\n\t\tptr->config = gf_odf_hevc_cfg_read_bs(bs, GF_FALSE);\n\t\tbreak;\n\tdefault:\n\t\tptr->config = gf_odf_hevc_cfg_read_bs(bs, GF_TRUE);\n\t\tbreak;\n\t}\n\tconsumed = gf_bs_get_position(bs) - consumed ;\n\tISOM_DECREASE_SIZE(ptr, (u32)consumed)\n\n\treturn ptr->config ? GF_OK : GF_ISOM_INVALID_FILE;\n}\n\nGF_Box *hvcc_box_new()\n{\n\tGF_HEVCConfigurationBox *tmp = (GF_HEVCConfigurationBox *) gf_malloc(sizeof(GF_HEVCConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_HEVCConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_HVCC;\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err hvcc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HEVCConfigurationBox *ptr = (GF_HEVCConfigurationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (!ptr->config) return GF_OK;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\treturn gf_odf_hevc_cfg_write_bs(ptr->config, bs);\n}\n\nGF_Err hvcc_box_size(GF_Box *s)\n{\n\tu32 i, count, j, subcount;\n\tGF_HEVCConfigurationBox *ptr = (GF_HEVCConfigurationBox *)s;\n\n\tif (!ptr->config) {\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\n\tif (!ptr->config->is_lhvc)\n\t\tptr->size += 23;\n\telse\n\t\tptr->size += 6;\n\n\tcount = gf_list_count(ptr->config->param_array);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParamArray *ar = (GF_NALUFFParamArray*)gf_list_get(ptr->config->param_array, i);\n\t\tptr->size += 3;\n\t\tsubcount = gf_list_count(ar->nalus);\n\t\tfor (j=0; j<subcount; j++) {\n\t\t\tptr->size += 2 + ((GF_NALUFFParam *)gf_list_get(ar->nalus, j))->size;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\n\nvoid vvcc_box_del(GF_Box *s)\n{\n\tGF_VVCConfigurationBox *ptr = (GF_VVCConfigurationBox*)s;\n\tif (ptr->config) gf_odf_vvc_cfg_del(ptr->config);\n\tgf_free(ptr);\n}\n\nGF_Err vvcc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu64 consumed;\n\tGF_VVCConfigurationBox *ptr = (GF_VVCConfigurationBox *)s;\n\n\tif (ptr->config) gf_odf_vvc_cfg_del(ptr->config);\n\n\tconsumed = gf_bs_get_position(bs);\n\tptr->config = gf_odf_vvc_cfg_read_bs(bs);\n\tconsumed = gf_bs_get_position(bs) - consumed ;\n\tISOM_DECREASE_SIZE(ptr, (u32)consumed)\n\n\treturn ptr->config ? GF_OK : GF_ISOM_INVALID_FILE;\n}\n\nGF_Box *vvcc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_VVCConfigurationBox, GF_ISOM_BOX_TYPE_VVCC);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err vvcc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_VVCConfigurationBox *ptr = (GF_VVCConfigurationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (!ptr->config) return GF_OK;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\treturn gf_odf_vvc_cfg_write_bs(ptr->config, bs);\n}\n\nGF_Err vvcc_box_size(GF_Box *s)\n{\n\tu32 i, count, j, subcount;\n\tGF_VVCConfigurationBox *ptr = (GF_VVCConfigurationBox *)s;\n\n\tif (!ptr->config) {\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\n\tptr->size += 1;\n\tif (ptr->config->ptl_present) {\n\t\tptr->size += 3;\n\t\t//size PTL\n\t\tif (!ptr->config->general_constraint_info)\n\t\t\tptr->config->num_constraint_info = 0;\n\t\tif (!ptr->config->sub_profiles_idc)\n\t\t\tptr->config->num_sub_profiles = 0;\n\n\t\tptr->size += 3 + ptr->config->num_constraint_info;\n\t\tif (ptr->config->numTemporalLayers>1)\n\t\t\tptr->size += 1;\n\t\tfor (i=0; i<ptr->config->numTemporalLayers; i++) {\n\t\t\tif (ptr->config->ptl_sublayer_present_mask & (1<<i))\n\t\t\t\tptr->size+=1;\n\t\t}\n\t\tptr->size += 1 + ptr->config->num_sub_profiles*4;\n\t\t//end size PTL\n\t\tptr->size += 6;\n\t}\n\n\tptr->size += 1;\n\tcount = gf_list_count(ptr->config->param_array);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParamArray *ar = (GF_NALUFFParamArray*)gf_list_get(ptr->config->param_array, i);\n\t\tif ((ar->type != GF_VVC_NALU_DEC_PARAM) && (ar->type != GF_VVC_NALU_OPI))\n\t\t\tptr->size += 3;\n\t\telse\n\t\t\tptr->size += 1;\n\n\t\tsubcount = gf_list_count(ar->nalus);\n\t\tfor (j=0; j<subcount; j++) {\n\t\t\tptr->size += 2 + ((GF_NALUFFParam *)gf_list_get(ar->nalus, j))->size;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif\n\n\nvoid vvnc_box_del(GF_Box *s)\n{\n\tGF_VVCNaluConfigurationBox *ptr = (GF_VVCNaluConfigurationBox*)s;\n\tgf_free(ptr);\n}\n\nGF_Err vvnc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_VVCNaluConfigurationBox *ptr = (GF_VVCNaluConfigurationBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tgf_bs_read_int(bs, 6);\n\tptr->nal_unit_size = 1 + gf_bs_read_int(bs, 2);\n\treturn GF_OK;\n}\n\nGF_Box *vvnc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_VVCNaluConfigurationBox, GF_ISOM_BOX_TYPE_VVNC);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err vvnc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_VVCNaluConfigurationBox *ptr = (GF_VVCNaluConfigurationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, 0, 6);\n\tgf_bs_write_int(bs, ptr->nal_unit_size-1, 2);\n\treturn GF_OK;\n}\n\nGF_Err vvnc_box_size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n#endif\n\nGF_Box *av1c_box_new() {\n\tGF_AV1ConfigurationBox *tmp = (GF_AV1ConfigurationBox *)gf_malloc(sizeof(GF_AV1ConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_AV1ConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_AV1C;\n\treturn (GF_Box *)tmp;\n}\n\nvoid av1c_box_del(GF_Box *s) {\n\tGF_AV1ConfigurationBox *ptr = (GF_AV1ConfigurationBox*)s;\n\tif (ptr->config) gf_odf_av1_cfg_del(ptr->config);\n\tgf_free(ptr);\n}\n\nGF_Err av1c_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu64 pos, read;\n\tGF_AV1ConfigurationBox *ptr = (GF_AV1ConfigurationBox*)s;\n\n\tif (ptr->config) gf_odf_av1_cfg_del(ptr->config);\n\n\tpos = gf_bs_get_position(bs);\n\n\tptr->config = gf_odf_av1_cfg_read_bs_size(bs, (u32) ptr->size);\n\n\tread = gf_bs_get_position(bs) - pos;\n\n\tif (read < ptr->size)\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[ISOBMFF] AV1ConfigurationBox: read only \"LLU\" bytes (expected \"LLU\").\\n\", read, ptr->size));\n\tif (read > ptr->size)\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] AV1ConfigurationBox overflow read \"LLU\" bytes, of box size \"LLU\".\\n\", read, ptr->size));\n\n\treturn GF_OK;\n}\n\nGF_Err av1c_box_write(GF_Box *s, GF_BitStream *bs) {\n\tGF_Err e;\n\tGF_AV1ConfigurationBox *ptr = (GF_AV1ConfigurationBox*)s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (!ptr->config) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\treturn gf_odf_av1_cfg_write_bs(ptr->config, bs);\n}\n\nGF_Err av1c_box_size(GF_Box *s) {\n\tu32 i;\n\tGF_AV1ConfigurationBox *ptr = (GF_AV1ConfigurationBox *)s;\n\n\tif (!ptr->config) {\n\t\tptr->size = 0;\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tptr->size += 4;\n\n\tfor (i = 0; i < gf_list_count(ptr->config->obu_array); ++i) {\n\t\tGF_AV1_OBUArrayEntry *a = gf_list_get(ptr->config->obu_array, i);\n\t\tptr->size += a->obu_length;\n\t}\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nvoid vpcc_box_del(GF_Box *s)\n{\n\tGF_VPConfigurationBox *ptr = (GF_VPConfigurationBox*)s;\n\tif (ptr->config) gf_odf_vp_cfg_del(ptr->config);\n\tptr->config = NULL;\n\tgf_free(ptr);\n}\n\nGF_Err vpcc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu64 pos;\n\tGF_VPConfigurationBox *ptr = (GF_VPConfigurationBox *)s;\n\n\tif (ptr->config) gf_odf_vp_cfg_del(ptr->config);\n\tptr->config = NULL;\n\n\tpos = gf_bs_get_position(bs);\n\tptr->config = gf_odf_vp_cfg_read_bs(bs, ptr->version == 0);\n\tpos = gf_bs_get_position(bs) - pos ;\n\n\tif (pos < ptr->size)\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[ISOBMFF] VPConfigurationBox: read only \"LLU\" bytes (expected \"LLU\").\\n\", pos, ptr->size));\n\tif (pos > ptr->size)\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] VPConfigurationBox overflow read \"LLU\" bytes, of box size \"LLU\".\\n\", pos, ptr->size));\n\n\treturn ptr->config ? GF_OK : GF_ISOM_INVALID_FILE;\n}\n\nGF_Box *vpcc_box_new()\n{\n\tGF_VPConfigurationBox *tmp = (GF_VPConfigurationBox *) gf_malloc(sizeof(GF_VPConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_VPConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_VPCC;\n\ttmp->version = 1;\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err vpcc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_VPConfigurationBox *ptr = (GF_VPConfigurationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (!ptr->config) return GF_OK;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\treturn gf_odf_vp_cfg_write_bs(ptr->config, bs, ptr->version == 0);\n}\n#endif\n\nGF_Err vpcc_box_size(GF_Box *s)\n{\n\tGF_VPConfigurationBox *ptr = (GF_VPConfigurationBox *)s;\n\n\tif (!ptr->config) {\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\n\tif (ptr->version == 0) {\n\t\tptr->size += 6;\n\t} else {\n\t\tif (ptr->config->codec_initdata_size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] VPConfigurationBox: codec_initdata_size MUST be 0, was %d\\n\", ptr->config->codec_initdata_size));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\tptr->size += 8;\n\t}\n\n\treturn GF_OK;\n}\n\n\nGF_Box *SmDm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SMPTE2086MasteringDisplayMetadataBox, GF_ISOM_BOX_TYPE_SMDM);\n\treturn (GF_Box *)tmp;\n}\n\nvoid SmDm_box_del(GF_Box *a)\n{\n\tGF_SMPTE2086MasteringDisplayMetadataBox *p = (GF_SMPTE2086MasteringDisplayMetadataBox *)a;\n\tgf_free(p);\n}\n\nGF_Err SmDm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SMPTE2086MasteringDisplayMetadataBox *p = (GF_SMPTE2086MasteringDisplayMetadataBox *)s;\n\tISOM_DECREASE_SIZE(p, 24)\n\tp->primaryRChromaticity_x = gf_bs_read_u16(bs);\n\tp->primaryRChromaticity_y = gf_bs_read_u16(bs);\n\tp->primaryGChromaticity_x = gf_bs_read_u16(bs);\n\tp->primaryGChromaticity_y = gf_bs_read_u16(bs);\n\tp->primaryBChromaticity_x = gf_bs_read_u16(bs);\n\tp->primaryBChromaticity_y = gf_bs_read_u16(bs);\n\tp->whitePointChromaticity_x = gf_bs_read_u16(bs);\n\tp->whitePointChromaticity_y = gf_bs_read_u16(bs);\n\tp->luminanceMax = gf_bs_read_u32(bs);\n\tp->luminanceMin = gf_bs_read_u32(bs);\n\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err SmDm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SMPTE2086MasteringDisplayMetadataBox *p = (GF_SMPTE2086MasteringDisplayMetadataBox*)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, p->primaryRChromaticity_x);\n\tgf_bs_write_u16(bs, p->primaryRChromaticity_y);\n\tgf_bs_write_u16(bs, p->primaryGChromaticity_x);\n\tgf_bs_write_u16(bs, p->primaryGChromaticity_y);\n\tgf_bs_write_u16(bs, p->primaryBChromaticity_x);\n\tgf_bs_write_u16(bs, p->primaryBChromaticity_y);\n\tgf_bs_write_u16(bs, p->whitePointChromaticity_x);\n\tgf_bs_write_u16(bs, p->whitePointChromaticity_y);\n\tgf_bs_write_u32(bs, p->luminanceMax);\n\tgf_bs_write_u32(bs, p->luminanceMin);\n\n\treturn GF_OK;\n}\n\nGF_Err SmDm_box_size(GF_Box *s)\n{\n\tGF_SMPTE2086MasteringDisplayMetadataBox *p = (GF_SMPTE2086MasteringDisplayMetadataBox*)s;\n\tp->size += 24;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *CoLL_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_VPContentLightLevelBox, GF_ISOM_BOX_TYPE_COLL);\n\treturn (GF_Box *)tmp;\n}\n\nvoid CoLL_box_del(GF_Box *a)\n{\n\tGF_VPContentLightLevelBox *p = (GF_VPContentLightLevelBox *)a;\n\tgf_free(p);\n}\n\nGF_Err CoLL_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_VPContentLightLevelBox *p = (GF_VPContentLightLevelBox *)s;\n\tISOM_DECREASE_SIZE(p, 4)\n\tp->maxCLL = gf_bs_read_u16(bs);\n\tp->maxFALL = gf_bs_read_u16(bs);\n\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err CoLL_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_VPContentLightLevelBox *p = (GF_VPContentLightLevelBox*)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, p->maxCLL);\n\tgf_bs_write_u16(bs, p->maxFALL);\n\n\treturn GF_OK;\n}\n\nGF_Err CoLL_box_size(GF_Box *s)\n{\n\tGF_VPContentLightLevelBox *p = (GF_VPContentLightLevelBox*)s;\n\tp->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_OperatingPointsInformation *gf_isom_oinf_new_entry()\n{\n\tGF_OperatingPointsInformation* ptr;\n\tGF_SAFEALLOC(ptr, GF_OperatingPointsInformation);\n\tif (ptr) {\n\t\tptr->profile_tier_levels = gf_list_new();\n\t\tptr->operating_points = gf_list_new();\n\t\tptr->dependency_layers = gf_list_new();\n\t}\n\treturn ptr;\n\n}\n\nvoid gf_isom_oinf_del_entry(void *entry)\n{\n\tGF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;\n\tif (!ptr) return;\n\tif (ptr->profile_tier_levels) {\n\t\twhile (gf_list_count(ptr->profile_tier_levels)) {\n\t\t\tLHEVC_ProfileTierLevel *ptl = (LHEVC_ProfileTierLevel *)gf_list_get(ptr->profile_tier_levels, 0);\n\t\t\tgf_free(ptl);\n\t\t\tgf_list_rem(ptr->profile_tier_levels, 0);\n\t\t}\n\t\tgf_list_del(ptr->profile_tier_levels);\n\t}\n\tif (ptr->operating_points) {\n\t\twhile (gf_list_count(ptr->operating_points)) {\n\t\t\tLHEVC_OperatingPoint *op = (LHEVC_OperatingPoint *)gf_list_get(ptr->operating_points, 0);\n\t\t\tgf_free(op);\n\t\t\tgf_list_rem(ptr->operating_points, 0);\n\t\t}\n\t\tgf_list_del(ptr->operating_points);\n\t}\n\tif (ptr->dependency_layers) {\n\t\twhile (gf_list_count(ptr->dependency_layers)) {\n\t\t\tLHEVC_DependentLayer *dep = (LHEVC_DependentLayer *)gf_list_get(ptr->dependency_layers, 0);\n\t\t\tgf_free(dep);\n\t\t\tgf_list_rem(ptr->dependency_layers, 0);\n\t\t}\n\t\tgf_list_del(ptr->dependency_layers);\n\t}\n\tgf_free(ptr);\n\treturn;\n}\n\nGF_Err gf_isom_oinf_read_entry(void *entry, GF_BitStream *bs)\n{\n\tGF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;\n\tu32 i, j, count;\n\n\tif (!ptr) return GF_BAD_PARAM;\n\tptr->scalability_mask = gf_bs_read_u16(bs);\n\tgf_bs_read_int(bs, 2);//reserved\n\tcount = gf_bs_read_int(bs, 6);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_ProfileTierLevel *ptl;\n\t\tGF_SAFEALLOC(ptl, LHEVC_ProfileTierLevel);\n\t\tif (!ptl) return GF_OUT_OF_MEM;\n\t\tptl->general_profile_space = gf_bs_read_int(bs, 2);\n\t\tptl->general_tier_flag= gf_bs_read_int(bs, 1);\n\t\tptl->general_profile_idc = gf_bs_read_int(bs, 5);\n\t\tptl->general_profile_compatibility_flags = gf_bs_read_u32(bs);\n\t\tptl->general_constraint_indicator_flags = gf_bs_read_long_int(bs, 48);\n\t\tptl->general_level_idc = gf_bs_read_u8(bs);\n\t\tgf_list_add(ptr->profile_tier_levels, ptl);\n\t}\n\tcount = gf_bs_read_u16(bs);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_OperatingPoint *op;\n\t\tGF_SAFEALLOC(op, LHEVC_OperatingPoint);\n\t\tif (!op) return GF_OUT_OF_MEM;\n\t\top->output_layer_set_idx = gf_bs_read_u16(bs);\n\t\top->max_temporal_id = gf_bs_read_u8(bs);\n\t\top->layer_count = gf_bs_read_u8(bs);\n\t\tif (op->layer_count > GF_ARRAY_LENGTH(op->layers_info)) {\n\t\t\tgf_free(op);\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tfor (j = 0; j < op->layer_count; j++) {\n\t\t\top->layers_info[j].ptl_idx = gf_bs_read_u8(bs);\n\t\t\top->layers_info[j].layer_id = gf_bs_read_int(bs, 6);\n\t\t\top->layers_info[j].is_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\t\top->layers_info[j].is_alternate_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\t}\n\t\top->minPicWidth = gf_bs_read_u16(bs);\n\t\top->minPicHeight = gf_bs_read_u16(bs);\n\t\top->maxPicWidth = gf_bs_read_u16(bs);\n\t\top->maxPicHeight = gf_bs_read_u16(bs);\n\t\top->maxChromaFormat = gf_bs_read_int(bs, 2);\n\t\top->maxBitDepth = gf_bs_read_int(bs, 3) + 8;\n\t\tgf_bs_read_int(bs, 1);//reserved\n\t\top->frame_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\top->bit_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\tif (op->frame_rate_info_flag) {\n\t\t\top->avgFrameRate = gf_bs_read_u16(bs);\n\t\t\tgf_bs_read_int(bs, 6); //reserved\n\t\t\top->constantFrameRate = gf_bs_read_int(bs, 2);\n\t\t}\n\t\tif (op->bit_rate_info_flag) {\n\t\t\top->maxBitRate = gf_bs_read_u32(bs);\n\t\t\top->avgBitRate = gf_bs_read_u32(bs);\n\t\t}\n\t\tgf_list_add(ptr->operating_points, op);\n\t}\n\tcount = gf_bs_read_u8(bs);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_DependentLayer *dep;\n\t\tGF_SAFEALLOC(dep, LHEVC_DependentLayer);\n\t\tif (!dep) return GF_OUT_OF_MEM;\n\t\tdep->dependent_layerID = gf_bs_read_u8(bs);\n\t\tdep->num_layers_dependent_on = gf_bs_read_u8(bs);\n\t\tif (dep->num_layers_dependent_on > GF_ARRAY_LENGTH(dep->dependent_on_layerID)) {\n\t\t\tgf_free(dep);\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tfor (j = 0; j < dep->num_layers_dependent_on; j++)\n\t\t\tdep->dependent_on_layerID[j] = gf_bs_read_u8(bs);\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tif (ptr->scalability_mask & (1 << j))\n\t\t\t\tdep->dimension_identifier[j] = gf_bs_read_u8(bs);\n\t\t}\n\t\tgf_list_add(ptr->dependency_layers, dep);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_oinf_write_entry(void *entry, GF_BitStream *bs)\n{\n\tGF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;\n\tu32 i, j, count;\n\tif (!ptr) return GF_OK;\n\n\tgf_bs_write_u16(bs, ptr->scalability_mask);\n\tgf_bs_write_int(bs, 0xFF, 2);//reserved\n\tcount=gf_list_count(ptr->profile_tier_levels);\n\tgf_bs_write_int(bs, count, 6);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_ProfileTierLevel *ptl = (LHEVC_ProfileTierLevel *)gf_list_get(ptr->profile_tier_levels, i);\n\t\tgf_bs_write_int(bs, ptl->general_profile_space, 2);\n\t\tgf_bs_write_int(bs, ptl->general_tier_flag, 1);\n\t\tgf_bs_write_int(bs, ptl->general_profile_idc, 5);\n\t\tgf_bs_write_u32(bs, ptl->general_profile_compatibility_flags);\n\t\tgf_bs_write_long_int(bs, ptl->general_constraint_indicator_flags, 48);\n\t\tgf_bs_write_u8(bs, ptl->general_level_idc);\n\t}\n\tcount=gf_list_count(ptr->operating_points);\n\tgf_bs_write_u16(bs, count);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_OperatingPoint *op = (LHEVC_OperatingPoint *)gf_list_get(ptr->operating_points, i);\n\t\tgf_bs_write_u16(bs, op->output_layer_set_idx);\n\t\tgf_bs_write_u8(bs, op->max_temporal_id);\n\t\tgf_bs_write_u8(bs, op->layer_count);\n\t\tfor (j = 0; j < op->layer_count; j++) {\n\t\t\tgf_bs_write_u8(bs, op->layers_info[j].ptl_idx);\n\t\t\tgf_bs_write_int(bs, op->layers_info[j].layer_id, 6);\n\t\t\top->layers_info[j].is_outputlayer ? gf_bs_write_int(bs, 0x1, 1)  : gf_bs_write_int(bs, 0x0, 1);\n\t\t\top->layers_info[j].is_alternate_outputlayer ? gf_bs_write_int(bs, 0x1, 1)  : gf_bs_write_int(bs, 0x0, 1);\n\t\t}\n\t\tgf_bs_write_u16(bs, op->minPicWidth);\n\t\tgf_bs_write_u16(bs, op->minPicHeight);\n\t\tgf_bs_write_u16(bs, op->maxPicWidth);\n\t\tgf_bs_write_u16(bs, op->maxPicHeight);\n\t\tgf_bs_write_int(bs, op->maxChromaFormat, 2);\n\t\tgf_bs_write_int(bs, op->maxBitDepth - 8, 3);\n\t\tgf_bs_write_int(bs, 0x1, 1);//resereved\n\t\top->frame_rate_info_flag ? gf_bs_write_int(bs, 0x1, 1)  : gf_bs_write_int(bs, 0x0, 1);\n\t\top->bit_rate_info_flag ? gf_bs_write_int(bs, 0x1, 1)  : gf_bs_write_int(bs, 0x0, 1);\n\t\tif (op->frame_rate_info_flag) {\n\t\t\tgf_bs_write_u16(bs, op->avgFrameRate);\n\t\t\tgf_bs_write_int(bs, 0xFF, 6); //reserved\n\t\t\tgf_bs_write_int(bs, op->constantFrameRate, 2);\n\t\t}\n\t\tif (op->bit_rate_info_flag) {\n\t\t\tgf_bs_write_u32(bs, op->maxBitRate);\n\t\t\tgf_bs_write_u32(bs, op->avgBitRate);\n\t\t}\n\t}\n\tcount=gf_list_count(ptr->dependency_layers);\n\tgf_bs_write_u8(bs, count);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_DependentLayer *dep = (LHEVC_DependentLayer *)gf_list_get(ptr->dependency_layers, i);\n\t\tgf_bs_write_u8(bs, dep->dependent_layerID);\n\t\tgf_bs_write_u8(bs, dep->num_layers_dependent_on);\n\t\tfor (j = 0; j < dep->num_layers_dependent_on; j++)\n\t\t\tgf_bs_write_u8(bs, dep->dependent_on_layerID[j]);\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tif (ptr->scalability_mask & (1 << j))\n\t\t\t\tgf_bs_write_u8(bs, dep->dimension_identifier[j]);\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\nu32 gf_isom_oinf_size_entry(void *entry)\n{\n\tGF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;\n\tu32 size = 0, i ,j, count;\n\tif (!ptr) return 0;\n\n\tsize += 3; //scalability_mask + reserved + num_profile_tier_level\n\tcount=gf_list_count(ptr->profile_tier_levels);\n\tsize += count * 12; //general_profile_space + general_tier_flag + general_profile_idc + general_profile_compatibility_flags + general_constraint_indicator_flags + general_level_idc\n\tsize += 2;//num_operating_points\n\tcount=gf_list_count(ptr->operating_points);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_OperatingPoint *op = (LHEVC_OperatingPoint *)gf_list_get(ptr->operating_points, i);\n\t\tsize += 2/*output_layer_set_idx*/ + 1/*max_temporal_id*/ + 1/*layer_count*/;\n\t\tsize += op->layer_count * 2;\n\t\tsize += 9;\n\t\tif (op->frame_rate_info_flag) {\n\t\t\tsize += 3;\n\t\t}\n\t\tif (op->bit_rate_info_flag) {\n\t\t\tsize += 8;\n\t\t}\n\t}\n\tsize += 1;//max_layer_count\n\tcount=gf_list_count(ptr->dependency_layers);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_DependentLayer *dep = (LHEVC_DependentLayer *)gf_list_get(ptr->dependency_layers, i);\n\t\tsize += 1/*dependent_layerID*/ + 1/*num_layers_dependent_on*/;\n\t\tsize += dep->num_layers_dependent_on * 1;//dependent_on_layerID\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tif (ptr->scalability_mask & (1 << j))\n\t\t\t\tsize += 1;//dimension_identifier\n\t\t}\n\t}\n\treturn size;\n}\n\n\nGF_LHVCLayerInformation *gf_isom_linf_new_entry()\n{\n\tGF_LHVCLayerInformation* ptr;\n\tGF_SAFEALLOC(ptr, GF_LHVCLayerInformation);\n\tif (ptr) ptr->num_layers_in_track = gf_list_new();\n\n\treturn ptr;\n\n}\n\nvoid gf_isom_linf_del_entry(void *entry)\n{\n\tGF_LHVCLayerInformation* ptr = (GF_LHVCLayerInformation *)entry;\n\tif (!ptr) return;\n\twhile (gf_list_count(ptr->num_layers_in_track)) {\n\t\tLHVCLayerInfoItem *li = (LHVCLayerInfoItem *)gf_list_get(ptr->num_layers_in_track, 0);\n\t\tgf_free(li);\n\t\tgf_list_rem(ptr->num_layers_in_track, 0);\n\t}\n\tgf_list_del(ptr->num_layers_in_track);\n\tgf_free(ptr);\n\treturn;\n}\n\nGF_Err gf_isom_linf_read_entry(void *entry, GF_BitStream *bs)\n{\n\tGF_LHVCLayerInformation* ptr = (GF_LHVCLayerInformation *)entry;\n\tu32 i, count;\n\n\tif (!ptr) return GF_BAD_PARAM;\n\tgf_bs_read_int(bs, 2);\n\tcount = gf_bs_read_int(bs, 6);\n\tfor (i = 0; i < count; i++) {\n\t\tLHVCLayerInfoItem *li;\n\t\tGF_SAFEALLOC(li, LHVCLayerInfoItem);\n\t\tif (!li) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_int(bs, 4);\n\t\tli->layer_id = gf_bs_read_int(bs, 6);\n\t\tli->min_TemporalId = gf_bs_read_int(bs, 3);\n\t\tli->max_TemporalId = gf_bs_read_int(bs, 3);\n\t\tgf_bs_read_int(bs, 1);\n\t\tli->sub_layer_presence_flags = gf_bs_read_int(bs, 7);\n\t\tgf_list_add(ptr->num_layers_in_track, li);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_linf_write_entry(void *entry, GF_BitStream *bs)\n{\n\tGF_LHVCLayerInformation* ptr = (GF_LHVCLayerInformation *)entry;\n\tu32 i, count;\n\tif (!ptr) return GF_OK;\n\n\tgf_bs_write_int(bs, 0, 2);\n\tcount=gf_list_count(ptr->num_layers_in_track);\n\tgf_bs_write_int(bs, count, 6);\n\tfor (i = 0; i < count; i++) {\n\t\tLHVCLayerInfoItem *li = (LHVCLayerInfoItem *)gf_list_get(ptr->num_layers_in_track, i);\n\t\tgf_bs_write_int(bs, 0, 4);\n\t\tgf_bs_write_int(bs, li->layer_id, 6);\n\t\tgf_bs_write_int(bs, li->min_TemporalId, 3);\n\t\tgf_bs_write_int(bs, li->max_TemporalId, 3);\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\tgf_bs_write_int(bs, li->sub_layer_presence_flags, 7);\n\t}\n\treturn GF_OK;\n}\n\nu32 gf_isom_linf_size_entry(void *entry)\n{\n\tGF_LHVCLayerInformation* ptr = (GF_LHVCLayerInformation *)entry;\n\tu32 size = 0, count;\n\tif (!ptr) return 0;\n\n\tsize += 1;\n\tcount=gf_list_count(ptr->num_layers_in_track);\n\tsize += count * 3;\n\treturn size;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2020\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / common tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/bitstream.h>\n\n/*the default size for new streams allocation...*/\n#define BS_MEM_BLOCK_ALLOC_SIZE\t\t512\n\n/*private types*/\nenum\n{\n\tGF_BITSTREAM_FILE_READ = GF_BITSTREAM_WRITE_DYN + 1,\n\tGF_BITSTREAM_FILE_WRITE,\n};\n\nstruct __tag_bitstream\n{\n\t/*original stream data*/\n\tFILE *stream;\n\n\t/*or original data*/\n\tchar *original;\n\t/*the size of our buffer in bytes*/\n\tu64 size;\n\t/*current position in BYTES*/\n\tu64 position;\n\t/*the byte readen/written*/\n\tu32 current;\n\t/*the number of bits in the current byte*/\n\tu32 nbBits;\n\t/*the bitstream mode*/\n\tu32 bsmode;\n\n\tvoid (*EndOfStream)(void *par);\n\tvoid *par;\n\n\n\tchar *cache_write;\n\tu32 cache_write_size, buffer_written;\n\n\tBool remove_emul_prevention_byte;\n\tu32 nb_zeros;\n\n\tGF_Err (*on_block_out)(void *cbk, u8 *data, u32 block_size);\n\tvoid *usr_data;\n\tu64 bytes_out;\n\tu32 prevent_dispatch;\n\n\tu64 cookie;\n\n\tu8 *cache_read;\n\tu32 cache_read_size, cache_read_pos, cache_read_alloc;\n\n\tvoid (*on_log)(void *udta, const char *field_name, u32 nb_bits, u64 field_val, s32 idx1, s32 idx2, s32 idx3);\n\tvoid *log_udta;\n\n\tu32 total_bits_read;\n\tu32 overflow_state;\n};\n\nGF_Err gf_bs_reassign_buffer(GF_BitStream *bs, const u8 *buffer, u64 BufferSize)\n{\n\tif (!bs) return GF_BAD_PARAM;\n\tbs->total_bits_read = 0;\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tbs->original = (char*)buffer;\n\t\tbs->size = BufferSize;\n\t\tbs->position = 0;\n\t\tbs->current = 0;\n\t\tbs->nbBits = 8;\n\t\tbs->current = 0;\n\t\tbs->nb_zeros = 0;\n\t\treturn GF_OK;\n\t}\n\tif (bs->bsmode==GF_BITSTREAM_WRITE) {\n\t\tif (!buffer || !BufferSize) return GF_BAD_PARAM;\n\t\tbs->original = (char*)buffer;\n\t\tbs->size = BufferSize;\n\t\tbs->position = 0;\n\t\tbs->current = 0;\n\t\tbs->nbBits = 0;\n\t\tbs->current = 0;\n\t\treturn GF_OK;\n\t}\n\tif (bs->bsmode!=GF_BITSTREAM_WRITE_DYN) return GF_BAD_PARAM;\n\tif (bs->original) return GF_BAD_PARAM;\n\n\tbs->position = 0;\n\tbs->current = 0;\n\tbs->nbBits = 0;\n\tbs->current = 0;\n\tbs->size = BufferSize ? BufferSize : BS_MEM_BLOCK_ALLOC_SIZE;\n\tif (buffer) {\n\t\tbs->original = (char *) buffer;\n\t} else {\n\t\tbs->original = (char *) gf_malloc(sizeof(char) * ((u32) bs->size));\n\t\tif (! bs->original) {\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_BitStream *gf_bs_new(const u8 *buffer, u64 BufferSize, u32 mode)\n{\n\tGF_BitStream *tmp = (GF_BitStream *)gf_malloc(sizeof(GF_BitStream));\n\tif (!tmp) return NULL;\n\tmemset(tmp, 0, sizeof(GF_BitStream));\n\n\ttmp->original = (char*)buffer;\n\ttmp->size = BufferSize;\n\n\ttmp->bsmode = mode;\n\n\tswitch (tmp->bsmode) {\n\tcase GF_BITSTREAM_READ:\n\t\ttmp->nbBits = 8;\n\t\ttmp->current = 0;\n\t\tbreak;\n\tcase GF_BITSTREAM_WRITE:\n\tcase GF_BITSTREAM_WRITE_DYN:\n\t\ttmp->nbBits = 0;\n\t\tif (! buffer) {\n\t\t\t/*if BufferSize is specified, use it. This is typically used when AvgSize of\n\t\t\tsome buffers is known, but some exceed it.*/\n\t\t\tif (BufferSize) {\n\t\t\t\ttmp->size = BufferSize;\n\t\t\t} else {\n\t\t\t\ttmp->size = BS_MEM_BLOCK_ALLOC_SIZE;\n\t\t\t}\n\t\t\ttmp->original = (char *) gf_malloc(sizeof(char) * ((u32) tmp->size));\n\t\t\tif (! tmp->original) {\n\t\t\t\tgf_free(tmp);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttmp->bsmode = GF_BITSTREAM_WRITE_DYN;\n\t\t} else {\n\t\t\ttmp->original = (char*)buffer;\n\t\t\ttmp->size = BufferSize;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t/*the stream constructor is not the same...*/\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn tmp;\n}\n\nGF_EXPORT\nGF_BitStream *gf_bs_from_file(FILE *f, u32 mode)\n{\n\tGF_BitStream *tmp;\n\tif (!f) return NULL;\n\n\ttmp = (GF_BitStream *)gf_malloc(sizeof(GF_BitStream));\n\tif (!tmp) return NULL;\n\tmemset(tmp, 0, sizeof(GF_BitStream));\n\t/*switch to internal mode*/\n\tmode = (mode==GF_BITSTREAM_READ) ? GF_BITSTREAM_FILE_READ : GF_BITSTREAM_FILE_WRITE;\n\ttmp->bsmode = mode;\n\ttmp->current = 0;\n\ttmp->nbBits = (mode == GF_BITSTREAM_FILE_READ) ? 8 : 0;\n\ttmp->original = NULL;\n\ttmp->position = 0;\n\ttmp->stream = f;\n\n\t/*get the size of this file (for read streams)*/\n\ttmp->position = gf_ftell(f);\n\ttmp->size = gf_fsize(f);\n\tgf_fseek(f, tmp->position, SEEK_SET);\n\n\n\tif (mode==GF_BITSTREAM_FILE_READ) {\n\t\ttmp->cache_read_alloc = gf_opts_get_int(\"core\", \"bs-cache-size\");\n\t\tif (tmp->cache_read_alloc) {\n\t\t\ttmp->cache_read_pos = tmp->cache_read_size = tmp->cache_read_alloc;\n\t\t\ttmp->cache_read = gf_malloc(tmp->cache_read_alloc);\n\t\t\tif (!tmp->cache_read) {\n\t\t\t\tgf_free(tmp);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\tif (mode == GF_BITSTREAM_FILE_WRITE) {\n\t\ttmp->cache_write_size = gf_opts_get_int(\"core\", \"bs-cache-size\");\n\t\tif (tmp->cache_write_size) {\n\t\t\ttmp->cache_write = (char*)gf_malloc(tmp->cache_write_size);\n\t\t\tif (!tmp->cache_write) {\n\t\t\t\tgf_free(tmp);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttmp->buffer_written = 0;\n\t\t}\n\t}\n\n\treturn tmp;\n}\n\n\nGF_BitStream *gf_bs_new_cbk_buffer(GF_Err (*on_block_out)(void *cbk, u8 *data, u32 block_size), void *usr_data, u8 *buffer, u32 buffer_size)\n{\n\tGF_BitStream *tmp;\n\n\tif (!on_block_out) return NULL;\n\n\ttmp = (GF_BitStream *)gf_malloc(sizeof(GF_BitStream));\n\tif (!tmp) return NULL;\n\tmemset(tmp, 0, sizeof(GF_BitStream));\n\n\tif (buffer && buffer_size) {\n\t\ttmp->size = buffer_size;\n\t\ttmp->original = buffer;\n\t} else {\n\t\ttmp->size = buffer_size ? buffer_size : 10*BS_MEM_BLOCK_ALLOC_SIZE;\n\t\ttmp->original = (char *) gf_malloc(sizeof(char) * ((u32) tmp->size));\n\t\tif (! tmp->original) {\n\t\t\tgf_free(tmp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\ttmp->bsmode = GF_BITSTREAM_WRITE_DYN;\n\ttmp->on_block_out = on_block_out;\n\ttmp->usr_data = usr_data;\n\n\treturn tmp;\n}\n\nGF_BitStream *gf_bs_new_cbk(GF_Err (*on_block_out)(void *cbk, u8 *data, u32 block_size), void *usr_data, u32 block_size)\n{\n\treturn gf_bs_new_cbk_buffer(on_block_out, usr_data, NULL, block_size);\n\n}\nvoid gf_bs_prevent_dispatch(GF_BitStream *bs, Bool prevent_dispatch)\n{\n\tif (!bs) return;\n\tif (prevent_dispatch) {\n\t\tbs->prevent_dispatch ++;\n\t\treturn;\n\t}\n\tif (!bs->prevent_dispatch) return;\n\tbs->prevent_dispatch --;\n\n\tif (bs->on_block_out && !bs->prevent_dispatch) {\n\t\tassert(bs->position >= bs->bytes_out);\n\t\tif (bs->position > bs->bytes_out) {\n\t\t\tbs->on_block_out(bs->usr_data, bs->original, (u32) (bs->position - bs->bytes_out));\n\t\t\tbs->bytes_out = bs->position;\n\t\t}\n\t}\n}\n\nstatic void bs_flush_write_cache(GF_BitStream *bs)\n{\n\tif (bs->buffer_written) {\n\t\tu32 nb_write;\n\t\tnb_write = (u32) gf_fwrite(bs->cache_write, bs->buffer_written, bs->stream);\n\n\t\t//check we didn't rewind the bitstream\n\t\tif (bs->size == bs->position)\n\t\t\tbs->size += nb_write;\n\t\tbs->position += nb_write;\n\t\tbs->buffer_written = 0;\n\t}\n}\n\n\n\nGF_EXPORT\nvoid gf_bs_del(GF_BitStream *bs)\n{\n\tif (!bs) return;\n\tif (bs->on_block_out && bs->position>bs->bytes_out) {\n\t\tbs->on_block_out(bs->usr_data, bs->original, (u32) (bs->position - bs->bytes_out) );\n\t}\n\t/*if we are in dynamic mode (alloc done by the bitstream), free the buffer if still present*/\n\tif ((bs->bsmode == GF_BITSTREAM_WRITE_DYN) && bs->original) gf_free(bs->original);\n\tif (bs->cache_write) {\n\t\tbs_flush_write_cache(bs);\n\t\tgf_free(bs->cache_write);\n\t}\n\tif (bs->cache_read)\n\t\tgf_free(bs->cache_read);\n\tgf_free(bs);\n}\n\nGF_EXPORT\nvoid gf_bs_enable_emulation_byte_removal(GF_BitStream *bs, Bool do_remove)\n{\n\tif (bs) {\n\t\tbs->remove_emul_prevention_byte = do_remove;\n\t\tbs->nb_zeros = 0;\n\t}\n}\n\n/*returns 1 if aligned wrt current mode, 0 otherwise*/\nBool gf_bs_is_align(GF_BitStream *bs)\n{\n\tswitch (bs->bsmode) {\n\tcase GF_BITSTREAM_READ:\n\tcase GF_BITSTREAM_FILE_READ:\n\t\treturn ( (8 == bs->nbBits) ? GF_TRUE : GF_FALSE);\n\tdefault:\n\t\treturn !bs->nbBits;\n\t}\n}\n\nstatic GFINLINE u8 gf_bs_load_byte(GF_BitStream *bs, Bool *is_eos)\n{\n\tu8 res;\n\tif (bs->cache_read) {\n\t\tif (bs->cache_read_pos == bs->cache_read_size) {\n\t\t\tbs->cache_read_size = (u32) gf_fread(bs->cache_read, bs->cache_read_alloc, bs->stream);\n\t\t\tbs->cache_read_pos = 0;\n\t\t\tif (!bs->cache_read_size) {\n\t\t\t\t*is_eos = GF_TRUE;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tres = bs->cache_read[bs->cache_read_pos];\n\t\tbs->cache_read_pos++;\n\t} else {\n\t\tres = gf_fgetc(bs->stream);\n\t}\n\treturn res;\n}\n\n/*fetch a new byte in the bitstream switch between packets*/\nstatic u8 BS_ReadByte(GF_BitStream *bs)\n{\n\tBool is_eos;\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tu8 res;\n\t\tif (bs->position >= bs->size) {\n\t\t\tif (bs->EndOfStream) bs->EndOfStream(bs->par);\n\t\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t\t\treturn 0;\n\t\t}\n\t\tres = bs->original[bs->position++];\n\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\tif ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size) && (bs->original[bs->position]<0x04)) {\n\t\t\t\tbs->nb_zeros = 0;\n\t\t\t\tres = bs->original[bs->position++];\n\t\t\t}\n\t\t\tif (!res) bs->nb_zeros++;\n\t\t\telse bs->nb_zeros = 0;\n\t\t}\n\t\treturn res;\n\t}\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\n\tis_eos = gf_feof(bs->stream);\n\n\t/*we are in FILE mode, test for end of file*/\n\tif (!is_eos || bs->cache_read) {\n\t\tu8 res;\n\t\tBool loc_eos=GF_FALSE;\n\t\tassert(bs->position<=bs->size);\n\t\tbs->position++;\n\n\t\tres = gf_bs_load_byte(bs, &loc_eos);\n\t\tif (loc_eos) goto bs_eof;\n\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\tif ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size)) {\n\t\t\t\tu8 next = gf_bs_load_byte(bs, &loc_eos);\n\t\t\t\tif (next < 0x04) {\n\t\t\t\t\tbs->nb_zeros = 0;\n\t\t\t\t\tres = next;\n\t\t\t\t\tbs->position++;\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_seek(bs, bs->position);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!res) bs->nb_zeros++;\n\t\t\telse bs->nb_zeros = 0;\n\t\t}\n\t\treturn res;\n\t}\n\nbs_eof:\n\tif (bs->EndOfStream) {\n\t\tbs->EndOfStream(bs->par);\n\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t} else {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to overread bitstream\\n\"));\n\t}\n\tassert(bs->position <= 1+bs->size);\n\treturn 0;\n}\n\n#define NO_OPTS\n\n#ifndef NO_OPTS\nstatic u32 bit_mask[] = {0x80, 0x40, 0x20, 0x10, 0x8, 0x4, 0x2, 0x1};\nstatic u32 bits_mask[] = {0x0, 0x1, 0x3, 0x7, 0xF, 0x1F, 0x3F, 0x7F};\n#endif\n\nGF_EXPORT\nu8 gf_bs_read_bit(GF_BitStream *bs)\n{\n\tif (bs->nbBits == 8) {\n\t\tbs->current = BS_ReadByte(bs);\n\t\tbs->nbBits = 0;\n\t}\n#ifdef NO_OPTS\n\t{\n\t\ts32 ret;\n\t\tbs->current <<= 1;\n\t\tbs->nbBits++;\n\t\tret = (bs->current & 0x100) >> 8;\n\t\treturn (u8) ret;\n\t}\n#else\n\treturn (u8) (bs->current & bit_mask[bs->nbBits++]) ? 1 : 0;\n#endif\n\n}\n\nGF_EXPORT\nu32 gf_bs_read_int(GF_BitStream *bs, u32 nBits)\n{\n\tu32 ret;\n\tbs->total_bits_read+= nBits;\n\n#ifndef NO_OPTS\n\tif (nBits + bs->nbBits <= 8) {\n\t\tbs->nbBits += nBits;\n\t\tret = (bs->current >> (8 - bs->nbBits) ) & bits_mask[nBits];\n\t\treturn ret;\n\t}\n#endif\n\tret = 0;\n\twhile (nBits-- > 0) {\n\t\tret <<= 1;\n\t\tret |= gf_bs_read_bit(bs);\n\t}\n\treturn ret;\n}\n\nGF_EXPORT\nu32 gf_bs_read_u8(GF_BitStream *bs)\n{\n\tassert(bs->nbBits==8);\n\tif (bs->cache_read && (bs->cache_read_pos+1<bs->cache_read_size) ) {\n\t\tu32 ret = bs->cache_read[bs->cache_read_pos];\n\t\tbs->cache_read_pos+=1;\n\t\tbs->position+=1;\n\t\treturn ret;\n\t}\n\n\treturn (u32) BS_ReadByte(bs);\n}\n\n#if 0\nGF_EXPORT\nu32 gf_bs_read_u8_until_delimiter(GF_BitStream *bs, u8 delimiter, u8* out, u32 max_length) {\n\tu32 i = 0;\n\tchar token=0;\n\tu64 cur_pos = gf_bs_get_position(bs);\n\n\tif (!max_length) out = NULL;\n\n\twhile(gf_bs_available(bs) && (!max_length || i < max_length)) {\n\t\tgf_bs_read_data(bs, &token, 1);\n\t\tif (token == delimiter) goto found;\n\t\tif (out) out[i] = token;\n\t\ti++;\n\t}\n\n\t/* Delimiter not found */\n\tgf_bs_seek(bs, cur_pos);\n\treturn 0;\n\nfound:\n\treturn i;\n}\n#endif\n\nGF_EXPORT\nu32 gf_bs_read_u16(GF_BitStream *bs)\n{\n\tu32 ret;\n\tassert(bs->nbBits==8);\n\tif (bs->cache_read && (bs->cache_read_pos+2<bs->cache_read_size) ) {\n\t\tret = bs->cache_read[bs->cache_read_pos];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+1];\n\t\tbs->cache_read_pos+=2;\n\t\tbs->position+=2;\n\t\treturn ret;\n\t}\n\n\tret = BS_ReadByte(bs);\n\tret<<=8;\n\tret |= BS_ReadByte(bs);\n\treturn ret;\n}\n\n\nGF_EXPORT\nu32 gf_bs_read_u24(GF_BitStream *bs)\n{\n\tu32 ret;\n\tassert(bs->nbBits==8);\n\n\tif (bs->cache_read && (bs->cache_read_pos+3<bs->cache_read_size) ) {\n\t\tret = bs->cache_read[bs->cache_read_pos];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+1];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+2];\n\t\tbs->cache_read_pos+=3;\n\t\tbs->position+=3;\n\t\treturn ret;\n\t}\n\n\tret = BS_ReadByte(bs);\n\tret<<=8;\n\tret |= BS_ReadByte(bs);\n\tret<<=8;\n\tret |= BS_ReadByte(bs);\n\treturn ret;\n}\n\nGF_EXPORT\nu32 gf_bs_read_u32(GF_BitStream *bs)\n{\n\tu32 ret;\n\tassert(bs->nbBits==8);\n\n\tif (bs->cache_read && (bs->cache_read_pos+4<bs->cache_read_size) ) {\n\t\tret = bs->cache_read[bs->cache_read_pos];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+1];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+2];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+3];\n\t\tbs->cache_read_pos+=4;\n\t\tbs->position+=4;\n\t\treturn ret;\n\t}\n\tret = BS_ReadByte(bs);\n\tret<<=8;\n\tret |= BS_ReadByte(bs);\n\tret<<=8;\n\tret |= BS_ReadByte(bs);\n\tret<<=8;\n\tret |= BS_ReadByte(bs);\n\treturn ret;\n}\n\nGF_EXPORT\nu64 gf_bs_read_u64(GF_BitStream *bs)\n{\n\tu64 ret;\n\n\tif (bs->cache_read && (bs->cache_read_pos+8<bs->cache_read_size) ) {\n\t\tret = bs->cache_read[bs->cache_read_pos];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+1];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+2];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+3];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+4];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+5];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+6];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+7];\n\t\tbs->cache_read_pos+=8;\n\t\tbs->position+=8;\n\t\treturn ret;\n\t}\n\tret = gf_bs_read_u32(bs);\n\tret<<=32;\n\tret |= gf_bs_read_u32(bs);\n\treturn ret;\n}\n\nGF_EXPORT\nu64 gf_bs_read_long_int(GF_BitStream *bs, u32 nBits)\n{\n\tu64 ret = 0;\n\tif (nBits>64) {\n\t\tu32 skip = nBits-64;\n\t\tif (gf_bs_available(bs) * 8 < nBits-8) {\n\t\t\tif (bs->EndOfStream) bs->EndOfStream(bs->par);\n\t\t\tbs->position = bs->size;\n\t\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t\t\treturn 0;\n\t\t}\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"Reading %d bits but max should be 64, skipping %d most significants bits\\n\", nBits, nBits-64));\n\t\t//avoid recursion\n\t\twhile (skip) {\n\t\t\tif (skip>32) {\n\t\t\t\tgf_bs_read_int(bs, 32);\n\t\t\t\tskip-=32;\n\t\t\t} else {\n\t\t\t\tgf_bs_read_int(bs, skip);\n\t\t\t\tskip=0;\n\t\t\t}\n\t\t}\n\t\tret = gf_bs_read_long_int(bs, 64);\n\t} else {\n\t\twhile (nBits-- > 0) {\n\t\t\tret <<= 1;\n\t\t\tret |= gf_bs_read_bit(bs);\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nGF_EXPORT\nFloat gf_bs_read_float(GF_BitStream *bs)\n{\n\tchar buf [4] = \"\\0\\0\\0\";\n#ifdef NO_OPTS\n\ts32 i;\n\tfor (i = 0; i < 32; i++)\n\t\tbuf[3-i/8] |= gf_bs_read_bit(bs) << (7 - i%8);\n#else\n\tbuf[3] = gf_bs_read_int(bs, 8);\n\tbuf[2] = gf_bs_read_int(bs, 8);\n\tbuf[1] = gf_bs_read_int(bs, 8);\n\tbuf[0] = gf_bs_read_int(bs, 8);\n#endif\n\treturn (* (Float *) buf);\n}\n\nGF_EXPORT\nDouble gf_bs_read_double(GF_BitStream *bs)\n{\n\tchar buf [8] = \"\\0\\0\\0\\0\\0\\0\\0\";\n\ts32 i;\n\tfor (i = 0; i < 64; i++)\n\t\tbuf[7-i/8] |= gf_bs_read_bit(bs) << (7 - i%8);\n\treturn (* (Double *) buf);\n}\n\nGF_EXPORT\nu32 gf_bs_read_data(GF_BitStream *bs, u8 *data, u32 nbBytes)\n{\n\tu64 orig = bs->position;\n\n\tif (bs->position+nbBytes > bs->size) return 0;\n\n\tif (gf_bs_is_align(bs) ) {\n\t\ts32 bytes_read, bytes_read_cache;\n\t\tswitch (bs->bsmode) {\n\t\tcase GF_BITSTREAM_READ:\n\t\tcase GF_BITSTREAM_WRITE:\n\t\tcase GF_BITSTREAM_WRITE_DYN:\n\t\t\tmemcpy(data, bs->original + bs->position, nbBytes);\n\t\t\tbs->position += nbBytes;\n\t\t\treturn nbBytes;\n\t\tcase GF_BITSTREAM_FILE_READ:\n\t\tcase GF_BITSTREAM_FILE_WRITE:\n\t\t\tif (bs->cache_write)\n\t\t\t\tbs_flush_write_cache(bs);\n\n\t\t\tbytes_read = bytes_read_cache = 0;\n\t\t\tif (bs->cache_read) {\n\t\t\t\tu32 csize = bs->cache_read_size-bs->cache_read_pos;\n\t\t\t\tif (csize>nbBytes) csize = nbBytes;\n\t\t\t\tmemcpy(data, bs->cache_read + bs->cache_read_pos, csize);\n\t\t\t\tbs->cache_read_pos += csize;\n\t\t\t\tnbBytes -= csize;\n\t\t\t\tbytes_read_cache = csize;\n\t\t\t}\n\t\t\tif (nbBytes) {\n\t\t\t\tbytes_read = (s32) gf_fread(data + bytes_read_cache, nbBytes, bs->stream);\n\t\t\t\tif (bytes_read<0) return bytes_read_cache;\n\t\t\t}\n\t\t\tbs->position += bytes_read + bytes_read_cache;\n\t\t\treturn bytes_read + bytes_read_cache;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\twhile (nbBytes-- > 0) {\n\t\t*data++ = gf_bs_read_int(bs, 8);\n\t}\n\treturn (u32) (bs->position - orig);\n\n}\n\n\n\nstatic void BS_WriteByte(GF_BitStream *bs, u8 val)\n{\n\t/*we don't allow write on READ buffers*/\n\tif ( (bs->bsmode == GF_BITSTREAM_READ) || (bs->bsmode == GF_BITSTREAM_FILE_READ) ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to write on read bitstream\\n\"));\n\t\treturn;\n\t}\n\tif (!bs->original && !bs->stream) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to write on unassigned bitstream\\n\"));\n\t\treturn;\n\t}\n\t/*we are in MEM mode*/\n\tif ( (bs->bsmode == GF_BITSTREAM_WRITE) || (bs->bsmode == GF_BITSTREAM_WRITE_DYN) ) {\n\t\t//if callback mode and dispatch is not blocked, dispatch\n\t\tif (bs->on_block_out && !bs->prevent_dispatch) {\n\t\t\tassert(bs->position >= bs->bytes_out);\n\t\t\tif (bs->position - bs->bytes_out == bs->size) {\n\t\t\t\tbs->on_block_out(bs->usr_data, bs->original, (u32) (bs->position - bs->bytes_out));\n\t\t\t\tbs->bytes_out = bs->position;\n\t\t\t}\n\t\t\tif (bs->original)\n\t\t\t\tbs->original[bs->position - bs->bytes_out] = val;\n\t\t\tbs->position++;\n\t\t\tassert(bs->position >= bs->bytes_out);\n\t\t\treturn;\n\t\t}\n\t\t//otherwise store\n\t\tif (bs->position - bs->bytes_out == bs->size) {\n\t\t\t/*no more space...*/\n\t\t\tif (bs->bsmode != GF_BITSTREAM_WRITE_DYN) return;\n\t\t\t/*gf_realloc if enough space...*/\n\t\t\tif (bs->size > 0xFFFFFFFF) return;\n\t\t\tbs->size = bs->size ? (bs->size * 2) : BS_MEM_BLOCK_ALLOC_SIZE;\n\t\t\tbs->original = (char*)gf_realloc(bs->original, (u32)bs->size);\n\t\t\tif (!bs->original) return;\n\t\t}\n\t\tif (bs->original)\n\t\t\tbs->original[bs->position - bs->bytes_out] = val;\n\t\tbs->position++;\n\t\treturn;\n\t}\n\tif (bs->cache_write) {\n\t\tif (bs->buffer_written == bs->cache_write_size) {\n\t\t\tbs_flush_write_cache(bs);\n\t\t}\n\t\tbs->cache_write[bs->buffer_written] = val;\n\t\tbs->buffer_written++;\n\t\tif (bs->buffer_written == bs->cache_write_size) {\n\t\t\tbs_flush_write_cache(bs);\n\t\t}\n\t\treturn;\n\t}\n\t/*we are in FILE mode, no pb for any gf_realloc...*/\n\tgf_fputc(val, bs->stream);\n\n\t/*check we didn't rewind the stream*/\n\tif (bs->size == bs->position) bs->size++;\n\tbs->position += 1;\n}\n\nstatic void BS_WriteBit(GF_BitStream *bs, u32 bit)\n{\n\tbs->current <<= 1;\n\tbs->current |= bit;\n\tif (++ bs->nbBits == 8) {\n\t\tbs->nbBits = 0;\n\t\tBS_WriteByte(bs, (u8) bs->current);\n\t\tbs->current = 0;\n\t}\n}\n\nstatic s32 bs_handle_nbits_overflow(GF_BitStream* bs, s32 nBits, s32 max_shift)\n{\n\tif (nBits > max_shift) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to write %d bits, when max is %d\\n\", nBits, max_shift));\n\t}\n\twhile (nBits > max_shift) {\n\t\tgf_bs_write_long_int(bs, 0, max_shift);\n\t\tnBits -= max_shift;\n\t}\n\n\treturn nBits;\n}\n\nGF_EXPORT\nvoid gf_bs_write_int(GF_BitStream *bs, s32 _value, s32 nBits)\n{\n\tu32 value, nb_shift;\n\ts32 max_shift = sizeof(s32) * 8;\n\tif (!nBits) return;\n\tnBits = bs_handle_nbits_overflow(bs, nBits, max_shift);\n\t//move to unsigned to avoid sanitizer warnings when we pass a value not codable on the given number of bits\n\t//we do this when setting bit fields to all 1's\n\tvalue = (u32) _value;\n\tnb_shift = max_shift - nBits;\n\tif (nb_shift)\n\t\tvalue <<= nb_shift;\n\n\twhile (--nBits >= 0) {\n\t\t//but check value as signed\n\t\tBS_WriteBit (bs, ((s32)value) < 0);\n\t\tvalue <<= 1;\n\t}\n}\n\nGF_EXPORT\nvoid gf_bs_write_long_int(GF_BitStream *bs, s64 _value, s32 nBits)\n{\n\ts32 max_shift = sizeof(s64) * 8;\n\tif (!nBits) return;\n\tnBits = bs_handle_nbits_overflow(bs, nBits, max_shift);\n\n\t//cf note in gf_bs_write_int\n\tu64 value = (u64) _value;\n\tvalue <<= max_shift - nBits;\n\twhile (--nBits >= 0) {\n\t\tBS_WriteBit (bs, ((s64)value) < 0);\n\t\tvalue <<= 1;\n\t}\n}\n\nGF_EXPORT\nvoid gf_bs_write_u8(GF_BitStream *bs, u32 value)\n{\n\tassert(!bs->nbBits);\n\n\tif (bs->cache_write && (bs->buffer_written+1 < bs->cache_write_size) ) {\n\t\tbs->cache_write[bs->buffer_written] = (u8) value;\n\t\tbs->buffer_written += 1;\n\t} else {\n\t\tBS_WriteByte(bs, (u8) value);\n\t}\n}\n\nGF_EXPORT\nvoid gf_bs_write_u16(GF_BitStream *bs, u32 value)\n{\n\tassert(!bs->nbBits);\n\tif (bs->cache_write && (bs->buffer_written+2 < bs->cache_write_size) ) {\n\t\tbs->cache_write[bs->buffer_written] = (u8) ((value>>8)&0xff);\n\t\tbs->cache_write[bs->buffer_written+1] = (u8) ((value)&0xff);\n\t\tbs->buffer_written += 2;\n\t} else {\n\t\tBS_WriteByte(bs, (u8) ((value>>8)&0xff));\n\t\tBS_WriteByte(bs, (u8) ((value)&0xff));\n\t}\n}\n\nGF_EXPORT\nvoid gf_bs_write_u24(GF_BitStream *bs, u32 value)\n{\n\tassert(!bs->nbBits);\n\tif (bs->cache_write && (bs->buffer_written+3 < bs->cache_write_size) ) {\n\t\tbs->cache_write[bs->buffer_written] = (u8) ((value>>16)&0xff);\n\t\tbs->cache_write[bs->buffer_written+1] = (u8) ((value>>8)&0xff);\n\t\tbs->cache_write[bs->buffer_written+2] = (u8) ((value)&0xff);\n\t\tbs->buffer_written += 3;\n\t} else {\n\t\tBS_WriteByte(bs, (u8) ((value>>16)&0xff));\n\t\tBS_WriteByte(bs, (u8) ((value>>8)&0xff));\n\t\tBS_WriteByte(bs, (u8) ((value)&0xff));\n\t}\n}\n\nGF_EXPORT\nvoid gf_bs_write_u32(GF_BitStream *bs, u32 value)\n{\n\tassert(!bs->nbBits);\n\tif (bs->cache_write && (bs->buffer_written+4 < bs->cache_write_size) ) {\n\t\tbs->cache_write[bs->buffer_written] = (u8) ((value>>24)&0xff);\n\t\tbs->cache_write[bs->buffer_written+1] = (u8) ((value>>16)&0xff);\n\t\tbs->cache_write[bs->buffer_written+2] = (u8) ((value>>8)&0xff);\n\t\tbs->cache_write[bs->buffer_written+3] = (u8) ((value)&0xff);\n\t\tbs->buffer_written += 4;\n\t} else {\n\t\tBS_WriteByte(bs, (u8) ((value>>24)&0xff));\n\t\tBS_WriteByte(bs, (u8) ((value>>16)&0xff));\n\t\tBS_WriteByte(bs, (u8) ((value>>8)&0xff));\n\t\tBS_WriteByte(bs, (u8) ((value)&0xff));\n\t}\n}\n\nGF_EXPORT\nvoid gf_bs_write_u64(GF_BitStream *bs, u64 value)\n{\n\tassert(!bs->nbBits);\n\tgf_bs_write_u32(bs, (u32) ((value>>32)&0xffffffff));\n\tgf_bs_write_u32(bs, (u32) (value&0xffffffff));\n}\n\nGF_EXPORT\nu32 gf_bs_write_byte(GF_BitStream *bs, u8 byte, u32 repeat_count)\n{\n\tif (!gf_bs_is_align(bs) || bs->cache_write) {\n\t\tu32 count = 0;\n\t\twhile (count<repeat_count) {\n\t\t\tgf_bs_write_int(bs, byte, 8);\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n\n\tswitch (bs->bsmode) {\n\tcase GF_BITSTREAM_WRITE:\n\t\tif (bs->position + repeat_count > bs->size)\n\t\t\treturn 0;\n\t\tmemset(bs->original + bs->position, byte, repeat_count);\n\t\tbs->position += repeat_count;\n\t\treturn repeat_count;\n\tcase GF_BITSTREAM_WRITE_DYN:\n\t\t/*need to gf_realloc ...*/\n\t\tif (bs->position+repeat_count> bs->size) {\n\t\t\tu32 new_size = (u32) (bs->size*2);\n\t\t\tif (!new_size) new_size = BS_MEM_BLOCK_ALLOC_SIZE;\n\n\t\t\tif (bs->size + repeat_count > 0xFFFFFFFF)\n\t\t\t\treturn 0;\n\t\t\twhile (new_size < (u32) ( bs->size + repeat_count))\n\t\t\t\tnew_size *= 2;\n\t\t\tbs->original = (char*)gf_realloc(bs->original, sizeof(u32)*new_size);\n\t\t\tif (!bs->original)\n\t\t\t\treturn 0;\n\t\t\tbs->size = new_size;\n\t\t}\n\t\tmemset(bs->original + bs->position, byte, repeat_count);\n\t\tbs->position += repeat_count;\n\t\treturn repeat_count;\n\tcase GF_BITSTREAM_FILE_READ:\n\tcase GF_BITSTREAM_FILE_WRITE:\n\t\tif (gf_fwrite(&byte, repeat_count, bs->stream) != repeat_count)\n\t\t\treturn 0;\n\t\tif (bs->size == bs->position) bs->size += repeat_count;\n\t\tbs->position += repeat_count;\n\t\treturn repeat_count;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n\n\nGF_EXPORT\nvoid gf_bs_write_float(GF_BitStream *bs, Float value)\n{\n\tu32 i;\n\tunion\n\t{\tfloat f;\n\t\tchar sz [4];\n\t} float_value;\n\tfloat_value.f = value;\n\n\tfor (i = 0; i < 32; i++)\n\t\tBS_WriteBit(bs, (float_value.sz [3 - i / 8] & 1 << (7 - i % 8)) != 0);\n\n}\n\nGF_EXPORT\nvoid gf_bs_write_double (GF_BitStream *bs, Double value)\n{\n\tu32 i;\n\tunion\n\t{\tDouble d;\n\t\tchar sz [8];\n\t} double_value;\n\tdouble_value.d = value;\n\tfor (i = 0; i < 64; i++) {\n\t\tBS_WriteBit(bs, (double_value.sz [7 - i / 8] & 1 << (7 - i % 8)) != 0);\n\t}\n}\n\n\nGF_EXPORT\nu32 gf_bs_write_data(GF_BitStream *bs, const u8 *data, u32 nbBytes)\n{\n\t/*we need some feedback for this guy...*/\n\tu64 begin = bs->position;\n\tif (!nbBytes) return 0;\n\n\tif (gf_bs_is_align(bs)) {\n\t\tswitch (bs->bsmode) {\n\t\tcase GF_BITSTREAM_WRITE:\n\t\t\tif (bs->position+nbBytes > bs->size) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to overwrite bitstream by %d bytes\\n\", bs->position + nbBytes - bs->size));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmemcpy(bs->original + bs->position, data, nbBytes);\n\t\t\tbs->position += nbBytes;\n\t\t\treturn nbBytes;\n\t\tcase GF_BITSTREAM_WRITE_DYN:\n\t\t\t//if callback mode and dispatch not disabled, dispatch bytes\n\t\t\tif (bs->on_block_out && !bs->prevent_dispatch) {\n\t\t\t\tassert(bs->position >= bs->bytes_out);\n\n\t\t\t\tif (bs->position - bs->bytes_out + nbBytes <= bs->size) {\n\t\t\t\t\tmemcpy(bs->original + bs->position - bs->bytes_out, data, nbBytes);\n\t\t\t\t\tbs->position += nbBytes;\n\t\t\t\t} else {\n\t\t\t\t\tif (bs->position > bs->bytes_out)\n\t\t\t\t\t\tbs->on_block_out(bs->usr_data, bs->original, (u32) (bs->position - bs->bytes_out) );\n\t\t\t\t\tif (nbBytes)\n\t\t\t\t\t\tbs->on_block_out(bs->usr_data, (char *) data, nbBytes);\n\n\t\t\t\t\tbs->position += nbBytes;\n\t\t\t\t\tbs->bytes_out = bs->position;\n\t\t\t\t}\n\t\t\t\tassert(bs->position >= bs->bytes_out);\n\t\t\t\treturn nbBytes;\n\t\t\t}\n\t\t\t//otherwise store\n\t\t\t/*need to gf_realloc ...*/\n\t\t\tif (bs->position + nbBytes - bs->bytes_out > bs->size) {\n\t\t\t\tu32 new_size = (u32) (bs->size*2);\n\t\t\t\tif (!new_size) new_size = BS_MEM_BLOCK_ALLOC_SIZE;\n\n\t\t\t\tif (bs->size + nbBytes > 0xFFFFFFFF)\n\t\t\t\t\treturn 0;\n\n\t\t\t\twhile (new_size < (u32) ( bs->size + nbBytes))\n\t\t\t\t\tnew_size *= 2;\n\t\t\t\tbs->original = (char*)gf_realloc(bs->original, sizeof(u32)*new_size);\n\t\t\t\tif (!bs->original)\n\t\t\t\t\treturn 0;\n\t\t\t\tbs->size = new_size;\n\t\t\t}\n\t\t\tmemcpy(bs->original + bs->position - bs->bytes_out, data, nbBytes);\n\t\t\tbs->position += nbBytes;\n\t\t\treturn nbBytes;\n\t\tcase GF_BITSTREAM_FILE_READ:\n\t\tcase GF_BITSTREAM_FILE_WRITE:\n\t\t\tif (bs->cache_write) {\n\t\t\t\t//if block fits in our write cache, write it\n\t\t\t\tif (bs->buffer_written + nbBytes < bs->cache_write_size) {\n\t\t\t\t\tmemcpy(bs->cache_write+bs->buffer_written, data, nbBytes);\n\t\t\t\t\tbs->buffer_written+=nbBytes;\n\t\t\t\t\treturn nbBytes;\n\t\t\t\t}\n\t\t\t\t//otherwise flush cache and use file write\n\t\t\t\tbs_flush_write_cache(bs);\n\t\t\t}\n\n\t\t\tif (gf_fwrite(data, nbBytes, bs->stream) != nbBytes) return 0;\n\n\t\t\tif (bs->size == bs->position) bs->size += nbBytes;\n\t\t\tbs->position += nbBytes;\n\t\t\treturn nbBytes;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\twhile (nbBytes) {\n\t\tgf_bs_write_int(bs, (s32) *data, 8);\n\t\tdata++;\n\t\tnbBytes--;\n\t}\n\treturn (u32) (bs->position - begin);\n}\n\n/*align return the num of bits read in READ mode, 0 in WRITE*/\nGF_EXPORT\nu8 gf_bs_align(GF_BitStream *bs)\n{\n\tu8 res = 8 - bs->nbBits;\n\tif ( (bs->bsmode == GF_BITSTREAM_READ) || (bs->bsmode == GF_BITSTREAM_FILE_READ)) {\n\t\tif (res > 0) {\n\t\t\tgf_bs_read_int(bs, res);\n\t\t}\n\t\treturn res;\n\t}\n\tif (bs->nbBits > 0) {\n\t\tgf_bs_write_int (bs, 0, res);\n\t\treturn res;\n\t}\n\treturn 0;\n}\n\n\n/*size available in the bitstream*/\nGF_EXPORT\nu64 gf_bs_available(GF_BitStream *bs)\n{\n\ts64 cur, end;\n\n\t/*in WRITE mode only, this should not be called, but return something big in case ...*/\n\tif ( (bs->bsmode == GF_BITSTREAM_WRITE)\n\t        || (bs->bsmode == GF_BITSTREAM_WRITE_DYN)\n\t   )\n\t\treturn (u64) -1;\n\n\t/*we are in MEM mode*/\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tif (bs->size < bs->position)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn (bs->size - bs->position);\n\t}\n\t/*FILE READ: assume size hasn't changed, otherwise the user shall call gf_bs_get_refreshed_size*/\n\tif (bs->bsmode==GF_BITSTREAM_FILE_READ) {\n\t\tif (bs->position>bs->size) return 0;\n\t\treturn (bs->size - bs->position);\n\t}\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\n\tcur = gf_ftell(bs->stream);\n\tend = gf_fsize(bs->stream);\n\tgf_fseek(bs->stream, cur, SEEK_SET);\n\n\treturn (u64) (end - cur);\n}\n\n/*call this funct to set the buffer size to the nb of bytes written\nUsed only in WRITE mode, as we don't know the real size during allocation...\nreturn -1 for bad param or gf_malloc failed\nreturn nbBytes cut*/\nstatic s32 BS_CutBuffer(GF_BitStream *bs)\n{\n\ts32 nbBytes;\n\tif ( (bs->bsmode != GF_BITSTREAM_WRITE_DYN) && (bs->bsmode != GF_BITSTREAM_WRITE)) return (u32) -1;\n\t/*Align our buffer or we're dead!*/\n\tgf_bs_align(bs);\n\n\tnbBytes = (u32) (bs->size - bs->position);\n\tif (!nbBytes || (nbBytes == 0xFFFFFFFF) || (bs->position >= 0xFFFFFFFF)) return 0;\n\t/*\n\t\tbs->original = (char*)gf_realloc(bs->original, (u32) bs->position);\n\t\tif (! bs->original) return (u32) -1;\n\t*/\n\t/*just in case, re-adjust..*/\n\tbs->size = bs->position;\n\treturn nbBytes;\n}\n\n/*For DYN mode, this gets the content out without cutting the buffer to the number of written bytes*/\nGF_EXPORT\nvoid gf_bs_get_content_no_truncate(GF_BitStream *bs, u8 **output, u32 *outSize, u32 *alloc_size)\n{\n\t/*only in WRITE MEM mode*/\n\tif (!bs || bs->bsmode != GF_BITSTREAM_WRITE_DYN) return;\n\n\tif (bs->on_block_out && bs->position>bs->bytes_out) {\n\t\tbs->on_block_out(bs->usr_data, bs->original, (u32) (bs->position - bs->bytes_out) );\n\t}\n\n\tif (!bs->position && !bs->nbBits) {\n\t\tif (!alloc_size) {\n\t\t\t*output = NULL;\n\t\t\tgf_free(bs->original);\n\t\t} else {\n\t\t\t*alloc_size = (u32) bs->size;\n\t\t\t*output = bs->original;\n\t\t}\n\t\t*outSize = 0;\n\t} else {\n\t\tif (alloc_size) {\n\t\t\t/*Align our buffer or we're dead!*/\n\t\t\tgf_bs_align(bs);\n\t\t\t*alloc_size = (u32) bs->size;\n\t\t\t*outSize = (u32) bs->position;\n\t\t\t*output = bs->original;\n\t\t} else {\n\t\t\ts32 copy = BS_CutBuffer(bs);\n\t\t\tif (copy < 0) {\n\t\t\t\t*output = NULL;\n\t\t\t} else\n\t\t\t\t*output = bs->original;\n\t\t\t*outSize = (u32) bs->size;\n\t\t}\n\t}\n\tbs->original = NULL;\n\tbs->size = 0;\n\tbs->position = 0;\n}\n\n/*For DYN mode, this gets the content out*/\nGF_EXPORT\nvoid gf_bs_get_content(GF_BitStream *bs, u8 **output, u32 *outSize)\n{\n\tgf_bs_get_content_no_truncate(bs, output, outSize, NULL);\n}\n\n/*\tSkip nbytes.\n\tAlign\n\tIf READ (MEM or FILE) mode, just read n times 8 bit\n\tIf WRITE (MEM or FILE) mode, write n times 0 on 8 bit\n*/\nGF_EXPORT\nvoid gf_bs_skip_bytes(GF_BitStream *bs, u64 nbBytes)\n{\n\tif (!bs || !nbBytes) return;\n\n\tgf_bs_align(bs);\n\n\t/*special case for file skipping...*/\n\tif ((bs->bsmode == GF_BITSTREAM_FILE_WRITE) || (bs->bsmode == GF_BITSTREAM_FILE_READ)) {\n\t\tif (bs->cache_write)\n\t\t\tbs_flush_write_cache(bs);\n\n\t\tif (bs->cache_read) {\n\t\t\tu32 csize = bs->cache_read_size - bs->cache_read_pos;\n\t\t\tif (csize>=nbBytes) {\n\t\t\t\tbs->cache_read_pos += (u32) nbBytes;\n\t\t\t\tbs->position += nbBytes;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnbBytes -= csize;\n\t\t\tbs->position += csize;\n\t\t\tbs->cache_read_pos = bs->cache_read_size;\n\t\t}\n\t\t//weird msys2 bug resulting in broken seek on some files ?!?  -the bug is not happening when doing absolute seek\n//\t\tgf_fseek(bs->stream, nbBytes, SEEK_CUR);\n\t\tbs->position += nbBytes;\n\t\tif (bs->bsmode == GF_BITSTREAM_FILE_READ) {\n\t\t\tif (bs->position > bs->size) bs->position = bs->size;\n\t\t}\n\t\tgf_fseek(bs->stream, bs->position, SEEK_SET);\n\t\treturn;\n\t}\n\n\t/*special case for reading*/\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\twhile (nbBytes) {\n\t\t\t\tgf_bs_read_u8(bs);\n\t\t\t\tnbBytes--;\n\t\t\t}\n\t\t} else {\n\t\t\tbs->position += nbBytes;\n\t\t}\n\t\treturn;\n\t}\n\t/*for writing we must do it this way, otherwise pb in dynamic buffers*/\n\twhile (nbBytes) {\n\t\tgf_bs_write_int(bs, 0, 8);\n\t\tnbBytes--;\n\t}\n}\n\n#ifdef GPAC_ENABLE_BIFS_PMF\n\nvoid gf_bs_rewind_bits(GF_BitStream *bs, u64 nbBits)\n{\n\tu64 nbBytes;\n\tif (bs->bsmode != GF_BITSTREAM_READ) return;\n\n\tnbBits -= (bs->nbBits);\n\tnbBytes = (nbBits+8)>>3;\n\tnbBits = nbBytes*8 - nbBits;\n\tgf_bs_align(bs);\n\tassert(bs->position >= nbBytes);\n\tbs->position -= nbBytes + 1;\n\tgf_bs_read_int(bs, (u32)nbBits);\n\treturn;\n}\n\n#endif\n\n/*seek from beginning of stream: use internally even when non aligned!*/\nstatic GF_Err BS_SeekIntern(GF_BitStream *bs, u64 offset)\n{\n\tu32 i;\n\t/*if mem, do it */\n\tif ((bs->bsmode == GF_BITSTREAM_READ) || (bs->bsmode == GF_BITSTREAM_WRITE) || (bs->bsmode == GF_BITSTREAM_WRITE_DYN)) {\n\t\tif (offset > 0xFFFFFFFF) return GF_IO_ERR;\n\t\tif (!bs->original) return GF_BAD_PARAM;\n\t\t/*0 for write, read will be done automatically*/\n\t\tif (offset >= bs->size) {\n\t\t\tif ( (bs->bsmode == GF_BITSTREAM_READ) || (bs->bsmode == GF_BITSTREAM_WRITE) ) {\n\t\t\t\tif (offset > bs->size) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"[BS] Attempt to seek to %d after end of bitstream %d, assuming seek to end\\n\", offset, bs->size));\n\t\t\t\t}\n\t\t\t\tbs->position = bs->size;\n\t\t\t\tbs->nbBits = (bs->bsmode == GF_BITSTREAM_READ) ? 8 : 0;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\t/*in DYN, gf_realloc ...*/\n\t\t\tbs->original = (char*)gf_realloc(bs->original, (u32) (offset + 1));\n\t\t\tif (!bs->original)\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\tfor (i = 0; i < (u32) (offset + 1 - bs->size); i++) {\n\t\t\t\tbs->original[bs->size + i] = 0;\n\t\t\t}\n\t\t\tbs->size = offset + 1;\n\t\t}\n\t\tbs->current = bs->original[offset];\n\t\tbs->position = offset;\n\t\tbs->nbBits = (bs->bsmode == GF_BITSTREAM_READ) ? 8 : 0;\n\t\treturn GF_OK;\n\t}\n\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\n\tif (bs->cache_read) {\n\t\tbs->cache_read_pos = bs->cache_read_size;\n\t}\n\n\tgf_fseek(bs->stream, offset, SEEK_SET);\n\n\tbs->position = offset;\n\tbs->current = 0;\n\t/*setup NbBits so that next acccess to the buffer will trigger read/write*/\n\tbs->nbBits = (bs->bsmode == GF_BITSTREAM_FILE_READ) ? 8 : 0;\n\treturn GF_OK;\n}\n\n/*seek from beginning of stream: align before anything else*/\nGF_EXPORT\nGF_Err gf_bs_seek(GF_BitStream *bs, u64 offset)\n{\n\tbs->overflow_state = 0;\n\tif (bs->on_block_out) {\n\t\tGF_Err e;\n\t\tif (offset < bs->bytes_out) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to seek on byte range already forwarded\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\t/*warning: we allow offset = bs->size for WRITE buffers*/\n\t\tif (offset - bs->bytes_out > bs->size)\n\t\t\treturn GF_BAD_PARAM;\n\t\tgf_bs_align(bs);\n\t\te = BS_SeekIntern(bs, offset - bs->bytes_out);\n\t\tbs->position += bs->bytes_out;\n\t\treturn e;\n\t}\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\n\t/*warning: we allow offset = bs->size for WRITE buffers*/\n\tif (offset > bs->size) return GF_BAD_PARAM;\n\n\tgf_bs_align(bs);\n\treturn BS_SeekIntern(bs, offset);\n}\n\n/*peek bits (as int!!) from orig position (ON BYTE BOUNDARIES, from 0) - only for read ...*/\nGF_EXPORT\nu32 gf_bs_peek_bits(GF_BitStream *bs, u32 numBits, u64 byte_offset)\n{\n\tu64 curPos;\n\tu32 curBits, ret, current, nb_zeros;\n\n\tif ( (bs->bsmode != GF_BITSTREAM_READ) && (bs->bsmode != GF_BITSTREAM_FILE_READ)) return 0;\n\tif (!numBits || (bs->size < bs->position + byte_offset)) return 0;\n\n\t/*store our state*/\n\tcurPos = bs->position;\n\tcurBits = bs->nbBits;\n\tcurrent = bs->current;\n\tnb_zeros = bs->nb_zeros;\n\n\tif (byte_offset) {\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\twhile (byte_offset) {\n\t\t\t\tgf_bs_read_int(bs, 8);\n\t\t\t\tbyte_offset--;\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bs_seek(bs, bs->position + byte_offset);\n\t\t}\n\t}\n\tret = gf_bs_read_int(bs, numBits);\n\n\t/*restore our cache - position*/\n\tgf_bs_seek(bs, curPos);\n\t/*to avoid re-reading our bits ...*/\n\tbs->nbBits = curBits;\n\tbs->current = current;\n\tbs->nb_zeros = nb_zeros;\n\treturn ret;\n}\n\nGF_EXPORT\nu64 gf_bs_get_refreshed_size(GF_BitStream *bs)\n{\n\ts64 offset;\n\n\tswitch (bs->bsmode) {\n\tcase GF_BITSTREAM_READ:\n\tcase GF_BITSTREAM_WRITE:\n\t\treturn bs->size;\n\n\tdefault:\n\t\tif (bs->cache_write)\n\t\t\tbs_flush_write_cache(bs);\n\n\t\tif (bs->stream) {\n\t\t\toffset = gf_ftell(bs->stream);\n\t\t\tbs->size = gf_fsize(bs->stream);\n\t\t\tgf_fseek(bs->stream, offset, SEEK_SET);\n\t\t}\n\t\treturn bs->size;\n\t}\n}\n\nGF_EXPORT\nu64 gf_bs_get_size(GF_BitStream *bs)\n{\n\tif (bs->cache_write) {\n\t\tif (bs->size == bs->position)\n\t\t\treturn bs->size + bs->buffer_written;\n\t\telse\n\t\t\treturn bs->size;\n\t}\n\tif (bs->on_block_out)\n\t\treturn bs->position;\n\treturn bs->size;\n}\n\nGF_EXPORT\nu64 gf_bs_get_position(GF_BitStream *bs)\n{\n\tif (bs->cache_write)\n\t\treturn bs->position + bs->buffer_written;\n\treturn bs->position;\n}\n\nGF_EXPORT\nu8 gf_bs_bits_available(GF_BitStream *bs)\n{\n\tif (bs->size > bs->position) return 8;\n\tif (bs->nbBits < 8) return (8-bs->nbBits);\n\treturn 0;\n}\n\nGF_EXPORT\nvoid gf_bs_set_eos_callback(GF_BitStream *bs, void (*EndOfStream)(void *par), void *par)\n{\n\tbs->EndOfStream = EndOfStream;\n\tbs->par = par;\n}\n\n\nGF_EXPORT\nu64 gf_bs_read_u64_le(GF_BitStream *bs)\n{\n\tu64 ret, v;\n\tret = gf_bs_read_int(bs, 8);\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=8;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=16;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=24;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=32;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=40;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=48;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=56;\n\tret |= v;\n\treturn ret;\n}\n\nGF_EXPORT\nu32 gf_bs_read_u32_le(GF_BitStream *bs)\n{\n\tu32 ret, v;\n\tret = gf_bs_read_int(bs, 8);\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=8;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=16;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=24;\n\tret |= v;\n\treturn ret;\n}\n\nGF_EXPORT\nu16 gf_bs_read_u16_le(GF_BitStream *bs)\n{\n\tu32 ret, v;\n\tret = gf_bs_read_int(bs, 8);\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=8;\n\tret |= v;\n\treturn ret;\n}\n\nGF_EXPORT\nvoid gf_bs_write_u64_le(GF_BitStream *bs, u64 val)\n{\n\tgf_bs_write_int(bs, val & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>8) & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>16) & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>24) & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>32) & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>40) & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>48) & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>56) & 0xFF, 8);\n}\n\nGF_EXPORT\nvoid gf_bs_write_u32_le(GF_BitStream *bs, u32 val)\n{\n\tgf_bs_write_int(bs, val & 0xFF, 8);\n\tgf_bs_write_int(bs, val>>8, 8);\n\tgf_bs_write_int(bs, val>>16, 8);\n\tgf_bs_write_int(bs, val>>24, 8);\n}\n\nGF_EXPORT\nvoid gf_bs_write_u16_le(GF_BitStream *bs, u32 val)\n{\n\tgf_bs_write_int(bs, val & 0xFF, 8);\n\tgf_bs_write_int(bs, val>>8, 8);\n}\n\nGF_EXPORT\nu32 gf_bs_get_bit_offset(GF_BitStream *bs)\n{\n\tif (bs->bsmode==GF_BITSTREAM_READ) return (u32) ( (bs->position - 1) * 8 + bs->nbBits);\n\treturn (u32) ( (bs->position ) * 8 + bs->nbBits);\n}\n\nGF_EXPORT\nu32 gf_bs_get_bit_position(GF_BitStream *bs)\n{\n\treturn bs->nbBits;\n}\n\nGF_EXPORT\nu32 gf_bs_read_vluimsbf5(GF_BitStream *bs)\n{\n\tu32 nb_words = 0;\n\twhile (gf_bs_read_int(bs, 1)) nb_words++;\n\tnb_words++;\n\treturn gf_bs_read_int(bs, 4*nb_words);\n}\n\nGF_EXPORT\nvoid gf_bs_truncate(GF_BitStream *bs)\n{\n\tbs->size = bs->position;\n}\n\n\nGF_EXPORT\nGF_Err gf_bs_transfer(GF_BitStream *dst, GF_BitStream *src, Bool keep_src)\n{\n\tu8 *data;\n\tu32 data_len, written;\n\n\tdata = NULL;\n\tdata_len = 0;\n\tgf_bs_get_content(src, &data, &data_len);\n\tif (!data || !data_len)\n\t{\n\t\tif (data) {\n\t\t\tif (keep_src) {\n\t\t\t\tsrc->original = data;\n\t\t\t\tsrc->size = data_len;\n\t\t\t} else {\n\t\t\t\tgf_free(data);\n\t\t\t}\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\twritten = gf_bs_write_data(dst, data, data_len);\n\tif (keep_src) {\n\t\tsrc->original = data;\n\t\tsrc->size = data_len;\n\t} else {\n\t\tgf_free(data);\n\t}\n\tif (written<data_len) return GF_IO_ERR;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_bs_flush(GF_BitStream *bs)\n{\n\tif (!bs->stream) return;\n\tif (bs->bsmode != GF_BITSTREAM_FILE_WRITE) return;\n\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\n\tgf_fflush(bs->stream);\n}\n\n#if 0 //unused\n/*!\n\\brief Reassigns FILE object for stream-based bitstreams\n *\n *Reassigns FILE object for stream-based bitstreams. Automatically sets the stream position to the bitstream position\n\\param bs the target bitstream\n\\param stream the new stream to assign\n */\nvoid gf_bs_reassign(GF_BitStream *bs, FILE *stream)\n{\n\tif (!bs) return;\n\tswitch (bs->bsmode) {\n\tcase GF_BITSTREAM_FILE_WRITE:\n\tcase GF_BITSTREAM_FILE_READ:\n\t\tbs->stream = stream;\n\t\tif (gf_ftell(stream) != bs->position)\n\t\t\tgf_bs_seek(bs, bs->position);\n\t\tbreak;\n\t}\n}\n#endif\n\nu64 gf_bs_set_cookie(GF_BitStream *bs, u64 cookie)\n{\n\tu64 res = 0;\n\tif (bs) {\n\t\tres = bs->cookie;\n\t\tbs->cookie = cookie;\n\t}\n\treturn res;\n}\n\nu64 gf_bs_get_cookie(GF_BitStream *bs)\n{\n\tif (!bs) return 0;\n\treturn bs->cookie;\n}\n\nGF_EXPORT\nGF_Err gf_bs_insert_data(GF_BitStream *bs, u8 *data, u32 size, u64 offset)\n{\n\tu64 cur_r, cur_w, pos;\n\tu32 nb_io;\n\n\tif (bs->on_block_out) return GF_BAD_PARAM;\n\n\tpos = bs->position;\n\tnb_io = gf_bs_write_data(bs, data, size);\n\tif (nb_io != size) goto exit;\n\n\tcur_w = bs->position;\n\tgf_bs_seek(bs, pos);\n\tcur_r = pos;\n\tpos = cur_w;\n\twhile (cur_r > offset) {\n\t\tu8 block[8196];\n\t\tu32 move_bytes = 8196;\n\t\tif (cur_r - offset < move_bytes)\n\t\t\tmove_bytes = (u32) (cur_r - offset);\n\n\t\tgf_bs_seek(bs, cur_r - move_bytes);\n\t\tnb_io = gf_bs_read_data(bs, block, move_bytes);\n\t\tif (nb_io != move_bytes) goto exit;\n\t\tgf_bs_seek(bs, cur_w - move_bytes);\n\t\tnb_io = gf_bs_write_data(bs, block, move_bytes);\n\t\tif (nb_io != move_bytes) goto exit;\n\t\tcur_r -= move_bytes;\n\t\tcur_w -= move_bytes;\n\t}\n\n\tgf_bs_seek(bs, offset);\n\tnb_io = gf_bs_write_data(bs, data, size);\n\tif (nb_io != size) goto exit;\n\n\tgf_bs_seek(bs, pos);\n\treturn GF_OK;\n\nexit:\n\tgf_bs_seek(bs, pos);\n\treturn GF_IO_ERR;\n}\n\n\nGF_Err gf_bs_set_logger(GF_BitStream *bs, void (*on_bs_log)(void *udta, const char *field_name, u32 nb_bits, u64 field_val, s32 idx1, s32 idx2, s32 idx3), void *udta)\n{\n\tif (!bs) return GF_BAD_PARAM;\n\tbs->on_log = on_bs_log;\n\tbs->log_udta = udta;\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_AVPARSE_LOGS\nvoid gf_bs_log_idx(GF_BitStream *bs, u32 nBits, const char *fname, s64 val, s32 idx1, s32 idx2, s32 idx3)\n{\n\tassert(bs);\n\tif (bs->on_log) bs->on_log(bs->log_udta, fname, nBits, val, idx1, idx2, idx3);\n}\n#endif\n\n\nvoid gf_bs_mark_overflow(GF_BitStream *bs, Bool reset)\n{\n\tbs->overflow_state = reset ? 0 : 2;\n}\nu32 gf_bs_is_overflow(GF_BitStream *bs)\n{\n\treturn bs->overflow_state;\n}\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n#include <gpac/internal/media_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n\nBool gf_isom_is_nalu_based_entry(GF_MediaBox *mdia, GF_SampleEntryBox *_entry)\n{\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (!gf_isom_is_video_handler_type(mdia->handler->handlerType))\n\t\treturn GF_FALSE;\n\tif (!_entry) return GF_FALSE;\n\tentry = (GF_MPEGVisualSampleEntryBox*)_entry;\n\n\tswitch (_entry->type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_SVC2:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC2:\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_LHV1:\n\tcase GF_ISOM_BOX_TYPE_LHE1:\n\tcase GF_ISOM_BOX_TYPE_MHV1:\n\tcase GF_ISOM_BOX_TYPE_MHC1:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\tcase GF_ISOM_BOX_TYPE_LHT1:\n\t\treturn GF_TRUE;\n\tcase GF_ISOM_BOX_TYPE_GNRV:\n\tcase GF_ISOM_BOX_TYPE_GNRA:\n\tcase GF_ISOM_BOX_TYPE_GNRM:\n\t\treturn GF_FALSE;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!gf_isom_is_video_handler_type(entry->internal_type))\n\t\treturn GF_FALSE;\n\n\tif (entry->avc_config || entry->svc_config || entry->mvc_config || entry->hevc_config || entry->lhvc_config) {\n\t\tGF_ProtectionSchemeInfoBox *schi = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\tif (!schi || !schi->scheme_type) return GF_TRUE;\n\t\tswitch (schi->scheme_type->scheme_type) {\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\t\treturn GF_TRUE;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_FALSE;\n}\n\n\nstatic void rewrite_nalus_list(GF_List *nalus, GF_BitStream *bs, Bool rewrite_start_codes, u32 nal_unit_size_field)\n{\n\tu32 i, count = gf_list_count(nalus);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam*)gf_list_get(nalus, i);\n\t\tif (rewrite_start_codes) gf_bs_write_u32(bs, 1);\n\t\telse gf_bs_write_int(bs, sl->size, 8*nal_unit_size_field);\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n}\n\n\nstatic GF_Err process_extractor(GF_ISOFile *file, GF_MediaBox *mdia, u32 sampleNumber, u64 sampleDTS, u32 nal_size, u16 nal_hdr, u32 nal_unit_size_field, Bool is_hevc, Bool rewrite_ps, Bool rewrite_start_codes, u32 extractor_mode)\n{\n\tGF_Err e;\n\tu32 di, ref_track_index, ref_track_num, data_offset, data_length, cur_extract_mode, ref_extract_mode, ref_nalu_size, nb_bytes_nalh;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_TrackBox *ref_trak;\n\ts8 sample_offset;\n\tu32 last_byte, ref_sample_num, prev_ref_sample_num;\n\tBool header_written = GF_FALSE;\n\tnb_bytes_nalh = is_hevc ? 2 : 1;\n\n\tswitch (extractor_mode) {\n\tcase 0:\n\t\tlast_byte = (u32) gf_bs_get_position(mdia->nalu_parser) + nal_size - (is_hevc ? 2 : 1);\n\t\tif (!is_hevc) gf_bs_read_int(mdia->nalu_parser, 24); //1 byte for HEVC , 3 bytes for AVC of NALUHeader in extractor\n\t\twhile (gf_bs_get_position(mdia->nalu_parser) < last_byte) {\n\t\t\tu32 xmode = 0;\n\t\t\t//hevc extractors use constructors\n\t\t\tif (is_hevc) xmode = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\tif (xmode) {\n\t\t\t\tu8 done=0, len = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\t\twhile (done<len) {\n\t\t\t\t\tu8 c = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\t\t\tdone++;\n\t\t\t\t\tif (header_written) {\n\t\t\t\t\t\tgf_bs_write_u8(mdia->nalu_out_bs, c);\n\t\t\t\t\t} else if (done==nal_unit_size_field) {\n\t\t\t\t\t\tif (rewrite_start_codes) {\n\t\t\t\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 1, 32);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_bs_write_u8(mdia->nalu_out_bs, c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\theader_written = GF_TRUE;\n\t\t\t\t\t} else if (!rewrite_start_codes) {\n\t\t\t\t\t\tgf_bs_write_u8(mdia->nalu_out_bs, c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tref_track_index = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\tsample_offset = (s8) gf_bs_read_int(mdia->nalu_parser, 8);\n\t\t\tdata_offset = gf_bs_read_int(mdia->nalu_parser, nal_unit_size_field*8);\n\t\t\tdata_length = gf_bs_read_int(mdia->nalu_parser, nal_unit_size_field*8);\n\n\t\t\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_SCAL, &dpnd);\n\t\t\tref_track_num = 0;\n\t\t\tif (dpnd && ref_track_index && (ref_track_index<=dpnd->trackIDCount))\n\t\t\t\tref_track_num = gf_isom_get_track_by_id(file, dpnd->trackIDs[ref_track_index-1]);\n\n\t\t\tif (!ref_track_num) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"ISOBMF: Extractor target track is not present in file - skipping.\\n\"));\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\n\t\t\tcur_extract_mode = gf_isom_get_nalu_extract_mode(file, ref_track_num);\n\n\t\t\t//we must be in inspect mode only otherwise the reference sample will not be the one stored on file (change in start codes, PS inserted or other NALUs inserted)\n\t\t\t//and this will corrupt extraction (wrong data offsets)\n\t\t\tref_extract_mode = GF_ISOM_NALU_EXTRACT_INSPECT;\n\t\t\tgf_isom_set_nalu_extract_mode(file, ref_track_num, ref_extract_mode);\n\n\t\t\tref_trak = gf_isom_get_track_from_file(file, ref_track_num);\n\t\t\tif (!ref_trak) return GF_ISOM_INVALID_FILE;\n\n\t\t\tif (!mdia->extracted_samp) {\n\t\t\t\tmdia->extracted_samp = gf_isom_sample_new();\n\t\t\t\tif (!mdia->extracted_samp) return GF_IO_ERR;\n\t\t\t}\n\t\t\tif (!mdia->extracted_bs) {\n\t\t\t\tmdia->extracted_bs = gf_bs_new(\"a\", 1, GF_BITSTREAM_READ);\n\t\t\t\tif (!mdia->extracted_bs) return GF_IO_ERR;\n\t\t\t}\n\n\t\t\te = stbl_findEntryForTime(ref_trak->Media->information->sampleTable, sampleDTS, 0, &ref_sample_num, &prev_ref_sample_num);\n\t\t\tif (e) return e;\n\t\t\tif (!ref_sample_num) ref_sample_num = prev_ref_sample_num;\n\t\t\tif (!ref_sample_num) return GF_ISOM_INVALID_FILE;\n\t\t\tif ((sample_offset<0) && (ref_sample_num > (u32) -sample_offset)) return GF_ISOM_INVALID_FILE;\n\t\t\tref_sample_num = (u32) ( (s32) ref_sample_num + sample_offset);\n\n\t\t\te = Media_GetSample(ref_trak->Media, ref_sample_num, &mdia->extracted_samp, &di, GF_FALSE, NULL);\n\t\t\tif (e) return e;\n\t\t\tif (!mdia->extracted_samp->alloc_size)\n\t\t\t\tmdia->extracted_samp->alloc_size = mdia->extracted_samp->dataLength;\n#if 0\n\t\t\tif (!header_written && rewrite_start_codes) {\n\t\t\t\tgf_bs_write_int(dst_bs, 1, 32);\n\t\t\t\tif (is_hevc) {\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0, 1);\n\t\t\t\t\tgf_bs_write_int(dst_bs, GF_HEVC_NALU_ACCESS_UNIT, 6);\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0, 9);\n\t\t\t\t\t/*pic-type - by default we signal all slice types possible*/\n\t\t\t\t\tgf_bs_write_int(dst_bs, 2, 3);\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0, 5);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_write_int(dst_bs, (ref_samp->data[0] & 0x60) | GF_AVC_NALU_ACCESS_UNIT, 8);\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0xF0 , 8); /*7 \"all supported NALUs\" (=111) + rbsp trailing (10000)*/;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tgf_bs_reassign_buffer(mdia->extracted_bs, mdia->extracted_samp->data + data_offset, mdia->extracted_samp->dataLength - data_offset);\n\n\t\t\tif (mdia->extracted_samp->dataLength - data_offset >= data_length) {\n\n\t\t\t\twhile (data_length && gf_bs_available(mdia->extracted_bs)) {\n\t\t\t\t\tif (!header_written) {\n\t\t\t\t\t\tref_nalu_size = gf_bs_read_int(mdia->extracted_bs, 8*nal_unit_size_field);\n\n\t\t\t\t\t\tassert(data_length>nal_unit_size_field);\n\t\t\t\t\t\tdata_length -= nal_unit_size_field;\n\t\t\t\t\t\tif (data_length > gf_bs_available(mdia->extracted_bs)) {\n\t\t\t\t\t\t\tdata_length = (u32)gf_bs_available(mdia->extracted_bs);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tref_nalu_size = data_length;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ref_nalu_size > mdia->tmp_nal_copy_buffer_alloc) {\n\t\t\t\t\t\tmdia->tmp_nal_copy_buffer_alloc = ref_nalu_size;\n\t\t\t\t\t\tmdia->tmp_nal_copy_buffer = (char*) gf_realloc(mdia->tmp_nal_copy_buffer, sizeof(char) * ref_nalu_size );\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_read_data(mdia->extracted_bs, mdia->tmp_nal_copy_buffer, ref_nalu_size);\n\n\t\t\t\t\tif (!header_written) {\n\t\t\t\t\t\tif (rewrite_start_codes)\n\t\t\t\t\t\t\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, ref_nalu_size, 8*nal_unit_size_field);\n\t\t\t\t\t}\n\t\t\t\t\tassert(data_length >= ref_nalu_size);\n\t\t\t\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, ref_nalu_size);\n\t\t\t\t\tdata_length -= ref_nalu_size;\n\n\t\t\t\t\theader_written = GF_FALSE;\n\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"ISOBMF: Extractor size is larger than referred sample size - skipping.\\n\"));\n\t\t\t}\n\t\t\tgf_isom_set_nalu_extract_mode(file, ref_track_num, cur_extract_mode);\n\n\t\t\tif (!is_hevc) break;\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\t//skip to end of this NALU\n\t\tgf_bs_skip_bytes(mdia->nalu_parser, nal_size - nb_bytes_nalh);\n\t\tbreak;\n\tcase 2:\n\t\tif (nal_size - nb_bytes_nalh > mdia->tmp_nal_copy_buffer_alloc) {\n\t\t\tmdia->tmp_nal_copy_buffer_alloc = nal_size - nb_bytes_nalh;\n\t\t\tmdia->tmp_nal_copy_buffer = (char*) gf_realloc(mdia->tmp_nal_copy_buffer, sizeof(char) * (nal_size - nb_bytes_nalh) );\n\t\t}\n\t\tgf_bs_read_data(mdia->nalu_parser, mdia->tmp_nal_copy_buffer, nal_size - nb_bytes_nalh);\n\t\tif (rewrite_start_codes)\n\t\t\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\n\t\telse\n\t\t\tgf_bs_write_int(mdia->nalu_out_bs, nal_size, 8*nal_unit_size_field);\n\n\t\tgf_bs_write_u8(mdia->nalu_out_bs, nal_hdr);\n\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, nal_size - nb_bytes_nalh);\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_HEVC\n/* returns the SAP type as defined in the 14496-12 specification */\nstatic GF_ISOSAPType sap_type_from_nal_type(u8 nal_type) {\n\tswitch (nal_type) {\n\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\treturn SAP_TYPE_3;\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\treturn SAP_TYPE_1;\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\t\treturn SAP_TYPE_2;\n\tdefault:\n\t\treturn RAP_NO;\n\t}\n}\n#endif\n\nstatic GF_ISOSAPType is_sample_idr(GF_MediaBox *mdia, GF_ISOSample *sample, GF_MPEGVisualSampleEntryBox *entry)\n{\n\tBool is_hevc = GF_FALSE;\n\tu32 nalu_size_field = 0;\n\tif (entry->avc_config && entry->avc_config->config) nalu_size_field = entry->avc_config->config->nal_unit_size;\n\telse if (entry->svc_config && entry->svc_config->config) nalu_size_field = entry->svc_config->config->nal_unit_size;\n\telse if (entry->mvc_config && entry->mvc_config->config) nalu_size_field = entry->mvc_config->config->nal_unit_size;\n\telse if (entry->hevc_config && entry->hevc_config->config) {\n\t\tnalu_size_field = entry->hevc_config->config->nal_unit_size;\n\t\tis_hevc = GF_TRUE;\n\t}\n\telse if (entry->lhvc_config && entry->lhvc_config->config) {\n\t\tnalu_size_field = entry->lhvc_config->config->nal_unit_size;\n\t\tis_hevc = GF_TRUE;\n\t}\n\tif (!nalu_size_field) return RAP_NO;\n\n\tif (!mdia->nalu_parser)\n\t\tmdia->nalu_parser = gf_bs_new(sample->data, sample->dataLength, GF_BITSTREAM_READ);\n\telse\n\t\tgf_bs_reassign_buffer(mdia->nalu_parser, sample->data, sample->dataLength);\n\n\tif (!mdia->nalu_parser) return RAP_NO;\n\n\twhile (gf_bs_available(mdia->nalu_parser)) {\n\t\tu8 nal_type;\n\t\tu32 size = gf_bs_read_int(mdia->nalu_parser, 8*nalu_size_field);\n\n\t\tif (is_hevc) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\tu16 nal_hdr = gf_bs_read_u16(mdia->nalu_parser);\n\t\t\tnal_type = (nal_hdr&0x7E00) >> 9;\n\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\t\t\treturn SAP_TYPE_3;\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\t\t\treturn SAP_TYPE_1;\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\t\t\t\treturn SAP_TYPE_2;\n\t\t\tcase GF_HEVC_NALU_ACCESS_UNIT:\n\t\t\tcase GF_HEVC_NALU_FILLER_DATA:\n\t\t\tcase GF_HEVC_NALU_SEI_PREFIX:\n\t\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn RAP_NO;\n\t\t\t}\n\t\t\tgf_bs_skip_bytes(mdia->nalu_parser, size - 2);\n#endif\n\t\t} else {\n\t\t\tu8 nal_hdr = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\tnal_type = nal_hdr & 0x1F;\n\n\t\t\tif (nal_type==GF_AVC_NALU_IDR_SLICE) return SAP_TYPE_1;\n\t\t\tif (nal_type<GF_AVC_NALU_IDR_SLICE) return RAP_NO;\n\t\t\tgf_bs_skip_bytes(mdia->nalu_parser, size - 1);\n\t\t}\n\t}\n\treturn RAP_NO;\n}\n\nstatic void nalu_merge_ps(GF_BitStream *ps_bs, Bool rewrite_start_codes, u32 nal_unit_size_field, GF_MPEGVisualSampleEntryBox *entry, Bool is_hevc, Bool *has_vps)\n{\n\tu32 i, count;\n\tif (is_hevc) {\n\t\tif (entry->hevc_config) {\n\t\t\tcount = gf_list_count(entry->hevc_config->config->param_array);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_NALUFFParamArray *ar = (GF_NALUFFParamArray*)gf_list_get(entry->hevc_config->config->param_array, i);\n\t\t\t\tif (ar->type == GF_HEVC_NALU_VID_PARAM) {\n\t\t\t\t\tif (! *has_vps)  *has_vps = GF_TRUE;\n\t\t\t\t\telse continue;\n\t\t\t\t}\n\t\t\t\trewrite_nalus_list(ar->nalus, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t\t}\n\t\t}\n\t\tif (entry->lhvc_config) {\n\t\t\tcount = gf_list_count(entry->lhvc_config->config->param_array);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_NALUFFParamArray *ar = (GF_NALUFFParamArray*)gf_list_get(entry->lhvc_config->config->param_array, i);\n\t\t\t\tif (ar->type == GF_HEVC_NALU_VID_PARAM) {\n\t\t\t\t\tif (! *has_vps)  *has_vps = GF_TRUE;\n\t\t\t\t\telse continue;\n\t\t\t\t}\n\t\t\t\trewrite_nalus_list(ar->nalus, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (entry->avc_config) {\n\t\t\trewrite_nalus_list(entry->avc_config->config->sequenceParameterSets, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t\trewrite_nalus_list(entry->avc_config->config->sequenceParameterSetExtensions, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t\trewrite_nalus_list(entry->avc_config->config->pictureParameterSets, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t}\n\n\t\t/*add svc config */\n\t\tif (entry->svc_config) {\n\t\t\trewrite_nalus_list(entry->svc_config->config->sequenceParameterSets, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t\trewrite_nalus_list(entry->svc_config->config->pictureParameterSets, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t}\n\t\t/*add mvc config */\n\t\tif (entry->mvc_config) {\n\t\t\trewrite_nalus_list(entry->mvc_config->config->sequenceParameterSets, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t\trewrite_nalus_list(entry->mvc_config->config->pictureParameterSets, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t}\n\t}\n}\n\n\nGF_Err gf_isom_nalu_sample_rewrite(GF_MediaBox *mdia, GF_ISOSample *sample, u32 sampleNumber, GF_MPEGVisualSampleEntryBox *entry)\n{\n\tBool is_hevc = GF_FALSE;\n\t//if only one sync given in the sample sync table, insert sps/pps/vps before cra/bla in hevc\n//\tBool check_cra_bla = (mdia->information->sampleTable->SyncSample && mdia->information->sampleTable->SyncSample->nb_entries>1) ? 0 : 1;\n\tBool check_cra_bla = GF_TRUE;\n\tBool insert_nalu_delim = GF_TRUE;\n\tBool force_sei_inspect = GF_FALSE;\n\tGF_Err e = GF_OK;\n\tGF_BitStream *sei_suffix_bs = NULL;\n\tBool ps_transfered = GF_FALSE;\n\tu32 nal_size, nal_unit_size_field, extractor_mode;\n\tBool rewrite_ps, rewrite_start_codes, insert_vdrd_code;\n\tu8 nal_type;\n\tu32 nal_hdr, sabt_ref, i, track_num;\n\tu32 temporal_id = 0;\n\tGF_ISOFile *file = mdia->mediaTrack->moov->mov;\n\tGF_TrackReferenceTypeBox *scal = NULL;\n\n\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_SCAL, &scal);\n\n\trewrite_ps = (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_INBAND_PS_FLAG) ? GF_TRUE : GF_FALSE;\n\trewrite_start_codes = (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_ANNEXB_FLAG) ? GF_TRUE : GF_FALSE;\n\tinsert_vdrd_code = (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_VDRD_FLAG) ? GF_TRUE : GF_FALSE;\n\tif (!entry->svc_config && !entry->mvc_config && !entry->lhvc_config) insert_vdrd_code = GF_FALSE;\n\textractor_mode = mdia->mediaTrack->extractor_mode&0x0000FFFF;\n\n\tif (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_TILE_ONLY) {\n\t\tinsert_nalu_delim = GF_FALSE;\n\t}\n\n\ttrack_num = 1 + gf_list_find(mdia->mediaTrack->moov->trackList, mdia->mediaTrack);\n\n\tif ( (extractor_mode != GF_ISOM_NALU_EXTRACT_INSPECT) && !(mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_TILE_ONLY) ) {\n\t\tu32 ref_track, di;\n\t\t//aggregate all sabt samples with the same DTS\n\t\tif (entry->lhvc_config && !entry->hevc_config && !(mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_LAYER_ONLY)) {\n\t\t\tif (gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_SCAL) <= 0) {\n\t\t\t\t//FIXME - for now we only support two layers (base + enh) in implicit\n\t\t\t\tif ( gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_BASE) >= 1) {\n\t\t\t\t\tGF_ISOSample *base_samp;\n\t\t\t\t\tgf_isom_get_reference(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_BASE, 1, &ref_track);\n\t\t\t\t\tswitch (gf_isom_get_media_subtype(mdia->mediaTrack->moov->mov , ref_track, 1)) {\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\n\t\t\t\t\t\tif (!mdia->extracted_samp) {\n\t\t\t\t\t\t\tmdia->extracted_samp = gf_isom_sample_new();\n\t\t\t\t\t\t\tif (!mdia->extracted_samp) return GF_OUT_OF_MEM;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbase_samp = gf_isom_get_sample_ex(mdia->mediaTrack->moov->mov, ref_track, sampleNumber + mdia->mediaTrack->sample_count_at_seg_start, &di, mdia->extracted_samp, NULL);\n\t\t\t\t\t\tif (base_samp && base_samp->data) {\n\t\t\t\t\t\t\tif (!sample->alloc_size || (sample->alloc_size<sample->dataLength+base_samp->dataLength) ) {\n\t\t\t\t\t\t\t\tsample->data = gf_realloc(sample->data, sample->dataLength+base_samp->dataLength);\n\t\t\t\t\t\t\t\tif (sample->alloc_size) sample->alloc_size = sample->dataLength+base_samp->dataLength;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmemmove(sample->data + base_samp->dataLength, sample->data , sample->dataLength);\n\t\t\t\t\t\t\tmemcpy(sample->data, base_samp->data, base_samp->dataLength);\n\t\t\t\t\t\t\tsample->dataLength += base_samp->dataLength;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_BASE, &scal);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsabt_ref = gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_SABT);\n\t\tif ((s32) sabt_ref > 0) {\n\t\t\tforce_sei_inspect = GF_TRUE;\n\t\t\tfor (i=0; i<sabt_ref; i++) {\n\t\t\t\tGF_ISOSample *tile_samp;\n\t\t\t\tgf_isom_get_reference(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_SABT, i+1, &ref_track);\n\n\t\t\t\tif (!mdia->extracted_samp) {\n\t\t\t\t\tmdia->extracted_samp = gf_isom_sample_new();\n\t\t\t\t\tif (!mdia->extracted_samp) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\n\t\t\t\ttile_samp = gf_isom_get_sample_ex(mdia->mediaTrack->moov->mov, ref_track, sampleNumber + mdia->mediaTrack->sample_count_at_seg_start, &di, mdia->extracted_samp, NULL);\n\t\t\t\tif (tile_samp  && tile_samp ->data) {\n\t\t\t\t\tif (!sample->alloc_size || (sample->alloc_size<sample->dataLength+tile_samp->dataLength) ) {\n\t\t\t\t\t\tsample->data = gf_realloc(sample->data, sample->dataLength+tile_samp->dataLength);\n\t\t\t\t\t\tif (sample->alloc_size) sample->alloc_size = sample->dataLength+tile_samp->dataLength;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(sample->data + sample->dataLength, tile_samp->data, tile_samp->dataLength);\n\t\t\t\t\tsample->dataLength += tile_samp->dataLength;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_TBAS) >= 1) {\n\t\tu32 ref_track;\n\t\tu32 idx = gf_list_find(mdia->information->sampleTable->SampleDescription->child_boxes, entry);\n\t\tGF_TrackBox *tbas;\n\t\tgf_isom_get_reference(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\ttbas = (GF_TrackBox *)gf_list_get(mdia->mediaTrack->moov->trackList, ref_track-1);\n\t\tentry = gf_list_get(tbas->Media->information->sampleTable->SampleDescription->child_boxes, idx);\n\t}\n\n\n\tif (sample->IsRAP < SAP_TYPE_2) {\n\t\tif (mdia->information->sampleTable->no_sync_found || (!sample->IsRAP && check_cra_bla) ) {\n\t\t\tsample->IsRAP = is_sample_idr(mdia, sample, entry);\n\t\t}\n\t}\n\tif (!sample->IsRAP)\n\t\trewrite_ps = GF_FALSE;\n\n\tif (extractor_mode != GF_ISOM_NALU_EXTRACT_LAYER_ONLY)\n\t\tinsert_vdrd_code = GF_FALSE;\n\n\tif (!entry) return GF_BAD_PARAM;\n\n\t//this is a compatible HEVC, don't insert VDRD, insert NALU delim\n\tif (entry->lhvc_config && entry->hevc_config)\n\t\tinsert_vdrd_code = GF_FALSE;\n\n\tif (extractor_mode == GF_ISOM_NALU_EXTRACT_INSPECT) {\n\t\tif (!rewrite_ps && !rewrite_start_codes)\n\t\t\treturn GF_OK;\n\t}\n\n\tnal_unit_size_field = 0;\n\t/*if svc rewrite*/\n\tif (entry->svc_config && entry->svc_config->config)\n\t\tnal_unit_size_field = entry->svc_config->config->nal_unit_size;\n\t/*if mvc rewrite*/\n\tif (entry->mvc_config && entry->mvc_config->config)\n\t\tnal_unit_size_field = entry->mvc_config->config->nal_unit_size;\n\n\t/*if lhvc rewrite*/\n\telse if (entry->lhvc_config && entry->lhvc_config->config)  {\n\t\tis_hevc = GF_TRUE;\n\t\tnal_unit_size_field = entry->lhvc_config->config->nal_unit_size;\n\t}\n\n\t/*otherwise do nothing*/\n\telse if (!rewrite_ps && !rewrite_start_codes && !scal && !force_sei_inspect) {\n\t\treturn GF_OK;\n\t}\n\n\tif (!nal_unit_size_field) {\n\t\tif (entry->avc_config && entry->avc_config->config)\n\t\t\tnal_unit_size_field = entry->avc_config->config->nal_unit_size;\n\t\telse if (entry->lhvc_config && entry->lhvc_config->config) {\n\t\t\tnal_unit_size_field = entry->lhvc_config->config->nal_unit_size;\n\t\t\tis_hevc = GF_TRUE;\n\t\t}\n\t\telse if (entry->hevc_config && entry->hevc_config->config) {\n\t\t\tnal_unit_size_field = entry->hevc_config->config->nal_unit_size;\n\t\t\tis_hevc = GF_TRUE;\n\t\t}\n\t}\n\n\tif (!nal_unit_size_field) return GF_ISOM_INVALID_FILE;\n\n\t//setup PS rewriter\n\tif (!mdia->nalu_ps_bs)\n\t\tmdia->nalu_ps_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_bs_seek(mdia->nalu_ps_bs, 0);\n\n\t//setup sample reader\n\tif (mdia->in_sample_buffer_alloc<sample->dataLength) {\n\t\tmdia->in_sample_buffer_alloc = sample->dataLength;\n\t\tmdia->in_sample_buffer = gf_realloc(mdia->in_sample_buffer, sample->dataLength);\n\t}\n\tmemcpy(mdia->in_sample_buffer, sample->data, sample->dataLength);\n\n\tif (!mdia->nalu_parser) {\n\t\tmdia->nalu_parser = gf_bs_new(mdia->in_sample_buffer, sample->dataLength, GF_BITSTREAM_READ);\n\t\tif (!mdia->nalu_parser && sample->data) return GF_ISOM_INVALID_FILE;\n\t} else {\n\t\te = gf_bs_reassign_buffer(mdia->nalu_parser, mdia->in_sample_buffer, sample->dataLength);\n\t\tif (e) return e;\n\t}\n\t//setup output\n\tif (!mdia->nalu_out_bs) {\n\t\tu8 *output;\n\t\tu32 outSize;\n\t\tmdia->nalu_out_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_get_content(mdia->nalu_out_bs, &output, &outSize);\n\t}\n\n\tgf_bs_reassign_buffer(mdia->nalu_out_bs, sample->data, sample->alloc_size ? sample->alloc_size : sample->dataLength);\n\n\t/*rewrite start code with NALU delim*/\n\tif (rewrite_start_codes) {\n\n\t\t//we are SVC, don't write NALU delim, only insert VDRD NALU\n\t\tif (insert_vdrd_code) {\n\t\t\tif (is_hevc) {\n\t\t\t\t//spec is not clear here, we don't insert an NALU AU delimiter before the layer starts since it breaks openHEVC\n//\t\t\t\tinsert_nalu_delim=0;\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 1, 32);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, GF_AVC_NALU_VDRD , 8);\n\t\t\t\tinsert_nalu_delim=0;\n\t\t\t}\n\t\t}\n\n\t\t//AVC/HEVC base, insert NALU delim\n\t\tif (insert_nalu_delim) {\n\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 1, 32);\n\t\t\tif (is_hevc) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 0, 1);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, GF_HEVC_NALU_ACCESS_UNIT, 6);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, insert_vdrd_code ? 1 : 0, 6); //we should pick the layerID of the following nalus ...\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 1, 3); //nuh_temporal_id_plus1 - cannot be 0, we use 1 by default, and overwrite it if needed at the end\n\n\t\t\t\t/*pic-type - by default we signal all slice types possible*/\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 2, 3);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 0, 5);\n#endif\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, (sample->data[0] & 0x60) | GF_AVC_NALU_ACCESS_UNIT, 8);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 0xF0 , 8); /*7 \"all supported NALUs\" (=111) + rbsp trailing (10000)*/;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rewrite_ps) {\n\t\tBool has_vps = GF_FALSE;\n\t\t//in inspect mode or single-layer mode just use the xPS from this layer\n\t\tif (extractor_mode == GF_ISOM_NALU_EXTRACT_DEFAULT) {\n\t\t\tif (scal) {\n\t\t\t\tfor (i=0; i<scal->trackIDCount; i++) {\n\t\t\t\t\tGF_TrackBox *a_track = GetTrackbyID(mdia->mediaTrack->moov, scal->trackIDs[i]);\n\t\t\t\t\tGF_MPEGVisualSampleEntryBox *an_entry = NULL;\n\t\t\t\t\tif (a_track && a_track->Media && a_track->Media->information && a_track->Media->information->sampleTable && a_track->Media->information->sampleTable->SampleDescription)\n\t\t\t\t\t\tan_entry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(a_track->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\n\t\t\t\t\tif (an_entry)\n\t\t\t\t\t\tnalu_merge_ps(mdia->nalu_ps_bs, rewrite_start_codes, nal_unit_size_field, an_entry, is_hevc, &has_vps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnalu_merge_ps(mdia->nalu_ps_bs, rewrite_start_codes, nal_unit_size_field, entry, is_hevc, &has_vps);\n\n\n\t\tif (is_hevc) {\n\t\t\t/*little optimization if we are not asked to start codes: copy over the sample*/\n\t\t\tif (!rewrite_start_codes && !entry->lhvc_config && !scal) {\n\t\t\t\tif (! ps_transfered) {\n\t\t\t\t\tnal_type = (sample->data[nal_unit_size_field] & 0x7E) >> 1;\n\t\t\t\t\t//temp fix - if we detect xPS in the beginning of the sample do NOT copy the ps bitstream\n\t\t\t\t\t//this is not correct since we are not sure whether they are the same xPS or not, but it crashes openHEVC ...\n\t\t\t\t\tswitch (nal_type) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\t\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\t\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\t\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\t\t\t\tbreak;\n#endif\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgf_bs_transfer(mdia->nalu_out_bs, mdia->nalu_ps_bs, GF_TRUE);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->in_sample_buffer, sample->dataLength);\n\t\t\t\tgf_bs_get_content_no_truncate(mdia->nalu_out_bs, &sample->data, &sample->dataLength, &sample->alloc_size);\n\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tps_transfered = GF_TRUE;\n\t}\n\n\t/*little optimization if we are not asked to rewrite extractors or start codes: copy over the sample*/\n\tif (!scal && !rewrite_start_codes && !rewrite_ps && !force_sei_inspect) {\n\t\tif (! ps_transfered)\n\t\t{\n\t\t\tgf_bs_transfer(mdia->nalu_out_bs, mdia->nalu_ps_bs, GF_TRUE);\n\t\t}\n\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->in_sample_buffer, sample->dataLength);\n\t\tgf_bs_get_content_no_truncate(mdia->nalu_out_bs, &sample->data, &sample->dataLength, &sample->alloc_size);\n\t\treturn GF_OK;\n\t}\n\n\tif (!mdia->tmp_nal_copy_buffer) {\n\t\tmdia->tmp_nal_copy_buffer = gf_malloc(sizeof(char) * 4096);\n\t\tmdia->tmp_nal_copy_buffer_alloc = 4096;\n\t}\n\n\n\twhile (gf_bs_available(mdia->nalu_parser)) {\n\t\tnal_size = gf_bs_read_int(mdia->nalu_parser, 8*nal_unit_size_field);\n\t\tif (gf_bs_get_position(mdia->nalu_parser) + nal_size > sample->dataLength) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"Sample %u (size %u) rewrite: corrupted NAL Unit (size %u)\\n\", sampleNumber, sample->dataLength, nal_size));\n\t\t\tgoto exit;\n\t\t}\n\t\tif (nal_size > mdia->tmp_nal_copy_buffer_alloc) {\n\t\t\tmdia->tmp_nal_copy_buffer_alloc = nal_size;\n\t\t\tmdia->tmp_nal_copy_buffer = (char*) gf_realloc(mdia->tmp_nal_copy_buffer, sizeof(char)*nal_size);\n\t\t}\n\t\tif (is_hevc) {\n\t\t\tnal_hdr = gf_bs_read_u16(mdia->nalu_parser);\n\t\t\tnal_type = (nal_hdr&0x7E00) >> 9;\n\t\t} else {\n\t\t\tnal_hdr = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\tnal_type = nal_hdr & 0x1F;\n\t\t}\n\n\t\tif (is_hevc) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\tGF_BitStream *write_to_bs = mdia->nalu_out_bs;\n#endif\n\n\t\t\tif (!ps_transfered) {\n\t\t\t\tgf_bs_transfer(mdia->nalu_out_bs, mdia->nalu_ps_bs, GF_TRUE);\n\t\t\t\tps_transfered = GF_TRUE;\n\t\t\t}\n\n#ifndef GPAC_DISABLE_HEVC\n\t\t\tswitch (nal_type) {\n\t\t\t/*we already wrote AU delim, and we trash aggregators*/\n\t\t\tcase GF_HEVC_NALU_ACCESS_UNIT:\n\t\t\tcase GF_HEVC_NALU_FF_AGGREGATOR:\n\t\t\t\tgf_bs_skip_bytes(mdia->nalu_parser, nal_size-2);\n\t\t\t\tcontinue;\n\n\t\t\t//extractor\n\t\t\tcase GF_HEVC_NALU_FF_EXTRACTOR:\n\t\t\t\te = process_extractor(file, mdia, sampleNumber, sample->DTS, nal_size, nal_hdr, nal_unit_size_field, GF_TRUE, rewrite_ps, rewrite_start_codes, extractor_mode);\n\t\t\t\tif (e) goto exit;\n\t\t\t\tbreak;\n\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_R:\n\t\t\t\tif (temporal_id < (nal_hdr & 0x7))\n\t\t\t\t\ttemporal_id = (nal_hdr & 0x7);\n\t\t\t\t/*rewrite nal*/\n\t\t\t\tgf_bs_read_data(mdia->nalu_parser, mdia->tmp_nal_copy_buffer, nal_size-2);\n\t\t\t\tif (rewrite_start_codes)\n\t\t\t\t\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\n\t\t\t\telse\n\t\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, nal_size, 8*nal_unit_size_field);\n\n\t\t\t\tgf_bs_write_u16(mdia->nalu_out_bs, nal_hdr);\n\t\t\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, nal_size-2);\n\t\t\t\tbreak;\n\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\t\t\t//insert xPS before CRA/BLA\n\t\t\t\tif (check_cra_bla && !sample->IsRAP) {\n\t\t\t\t\tsample->IsRAP = sap_type_from_nal_type(nal_type);\n\t\t\t\t\tif (sei_suffix_bs) gf_bs_del(sei_suffix_bs);\n\t\t\t\t\treturn gf_isom_nalu_sample_rewrite(mdia, sample, sampleNumber, entry);\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\t/*rewrite nal*/\n\t\t\t\tif (nal_size<2) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid nal size %d in sample %d\\n\", nal_type, sampleNumber));\n\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\n\t\t\t\tgf_bs_read_data(mdia->nalu_parser, mdia->tmp_nal_copy_buffer, nal_size-2);\n\n\t\t\t\tif (nal_type==GF_HEVC_NALU_SEI_SUFFIX) {\n\t\t\t\t\tif (!sei_suffix_bs) sei_suffix_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\t\twrite_to_bs = sei_suffix_bs;\n\t\t\t\t}\n\n\t\t\t\tif (rewrite_start_codes)\n\t\t\t\t\tgf_bs_write_u32(write_to_bs, 1);\n\t\t\t\telse\n\t\t\t\t\tgf_bs_write_int(write_to_bs, nal_size, 8*nal_unit_size_field);\n\n\t\t\t\tgf_bs_write_u16(write_to_bs, nal_hdr);\n\t\t\t\tgf_bs_write_data(write_to_bs, mdia->tmp_nal_copy_buffer, nal_size-2);\n\t\t\t}\n#endif\n\n\t\t\t//done with HEVC\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch(nal_type) {\n\t\tcase GF_AVC_NALU_ACCESS_UNIT:\n\t\tcase GF_AVC_NALU_FF_AGGREGATOR:\n\t\t\t/*we already wrote this stuff, and we trash aggregators*/\n\t\t\tgf_bs_skip_bytes(mdia->nalu_parser, nal_size-1);\n\t\t\tcontinue;\n\t\t//extractor\n\t\tcase GF_AVC_NALU_FF_EXTRACTOR:\n\t\t\te = process_extractor(file, mdia, sampleNumber, sample->DTS, nal_size, nal_hdr, nal_unit_size_field, GF_FALSE, rewrite_ps, rewrite_start_codes, extractor_mode);\n\t\t\tif (e) goto exit;\n\t\t\tbreak;\n//\t\t\tcase GF_AVC_NALU_SEI:\n\t\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\t\t// we will rewrite the sps/pps if and only if there is no sps/pps in bistream\n\t\t\tif (!ps_transfered) {\n\t\t\t\tps_transfered = GF_TRUE;\n\t\t\t}\n\t\tdefault:\n\t\t\tif (!ps_transfered) {\n\t\t\t\tgf_bs_transfer(mdia->nalu_out_bs, mdia->nalu_ps_bs, GF_TRUE);\n\t\t\t\tps_transfered = GF_TRUE;\n\t\t\t}\n\t\t\tgf_bs_read_data(mdia->nalu_parser, mdia->tmp_nal_copy_buffer, nal_size-1);\n\t\t\tif (rewrite_start_codes)\n\t\t\t\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\n\t\t\telse\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, nal_size, 8*nal_unit_size_field);\n\n\t\t\tgf_bs_write_u8(mdia->nalu_out_bs, nal_hdr);\n\t\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, nal_size-1);\n\t\t}\n\t}\n\n\tif (sei_suffix_bs) {\n\t\tgf_bs_transfer(mdia->nalu_out_bs, sei_suffix_bs, GF_FALSE);\n\t}\n\t/*done*/\n\tgf_bs_get_content_no_truncate(mdia->nalu_out_bs, &sample->data, &sample->dataLength, &sample->alloc_size);\n\n\t/*rewrite temporal ID of AU Ddelim NALU (first one)*/\n\tif (rewrite_start_codes && is_hevc && temporal_id) {\n\t\tsample->data[6] = (sample->data[6] & 0xF8) | (temporal_id+1);\n\t}\n\n\nexit:\n\tif (sei_suffix_bs)\n\t\tgf_bs_del(sei_suffix_bs);\n\n\treturn e;\n}\n\nGF_HEVCConfig *HEVC_DuplicateConfig(GF_HEVCConfig *cfg)\n{\n\tu8 *data;\n\tu32 data_size;\n\tGF_HEVCConfig *new_cfg;\n\tGF_BitStream *bs;\n\n\tif (!cfg) return NULL;\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_odf_hevc_cfg_write_bs(cfg, bs);\n\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\n\tnew_cfg = gf_odf_hevc_cfg_read_bs(bs, cfg->is_lhvc);\n\tnew_cfg->is_lhvc = cfg->is_lhvc;\n\tgf_bs_del(bs);\n\tgf_free(data);\n\treturn new_cfg;\n}\n\nGF_VVCConfig *VVC_DuplicateConfig(GF_VVCConfig *cfg)\n{\n\tu8 *data;\n\tu32 data_size;\n\tGF_VVCConfig *new_cfg;\n\tGF_BitStream *bs;\n\n\tif (!cfg) return NULL;\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_odf_vvc_cfg_write_bs(cfg, bs);\n\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\n\tnew_cfg = gf_odf_vvc_cfg_read_bs(bs);\n\tgf_bs_del(bs);\n\tgf_free(data);\n\treturn new_cfg;\n}\n\nstatic GF_AVCConfig *AVC_DuplicateConfig(GF_AVCConfig *cfg)\n{\n\tu32 i, count;\n\tGF_NALUFFParam *p1, *p2;\n\tGF_AVCConfig *cfg_new;\n\tif (!cfg)\n\t\treturn NULL;\n\tcfg_new = gf_odf_avc_cfg_new();\n\tcfg_new->AVCLevelIndication = cfg->AVCLevelIndication;\n\tcfg_new->AVCProfileIndication = cfg->AVCProfileIndication;\n\tcfg_new->configurationVersion = cfg->configurationVersion;\n\tcfg_new->nal_unit_size = cfg->nal_unit_size;\n\tcfg_new->profile_compatibility = cfg->profile_compatibility;\n\tcfg_new->complete_representation = cfg->complete_representation;\n\tcfg_new->chroma_bit_depth = cfg->chroma_bit_depth;\n\tcfg_new->luma_bit_depth = cfg->luma_bit_depth;\n\tcfg_new->chroma_format = cfg->chroma_format;\n\n\tcount = gf_list_count(cfg->sequenceParameterSets);\n\tfor (i=0; i<count; i++) {\n\t\tp1 = (GF_NALUFFParam*)gf_list_get(cfg->sequenceParameterSets, i);\n\t\tp2 = (GF_NALUFFParam*)gf_malloc(sizeof(GF_NALUFFParam));\n\t\tp2->size = p1->size;\n\t\tp2->id = p1->id;\n\t\tp2->data = (char *)gf_malloc(sizeof(char)*p1->size);\n\t\tmemcpy(p2->data, p1->data, sizeof(char)*p1->size);\n\t\tgf_list_add(cfg_new->sequenceParameterSets, p2);\n\t}\n\n\tcount = gf_list_count(cfg->pictureParameterSets);\n\tfor (i=0; i<count; i++) {\n\t\tp1 = (GF_NALUFFParam*)gf_list_get(cfg->pictureParameterSets, i);\n\t\tp2 = (GF_NALUFFParam*)gf_malloc(sizeof(GF_NALUFFParam));\n\t\tp2->size = p1->size;\n\t\tp2->id = p1->id;\n\t\tp2->data = (char*)gf_malloc(sizeof(char)*p1->size);\n\t\tmemcpy(p2->data, p1->data, sizeof(char)*p1->size);\n\t\tgf_list_add(cfg_new->pictureParameterSets, p2);\n\t}\n\n\tif (cfg->sequenceParameterSetExtensions) {\n\t\tcfg_new->sequenceParameterSetExtensions = gf_list_new();\n\t\tcount = gf_list_count(cfg->sequenceParameterSetExtensions);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tp1 = (GF_NALUFFParam*)gf_list_get(cfg->sequenceParameterSetExtensions, i);\n\t\t\tp2 = (GF_NALUFFParam*)gf_malloc(sizeof(GF_NALUFFParam));\n\t\t\tp2->size = p1->size;\n\t\t\tp2->id = p1->id;\n\t\t\tp2->data = (char*)gf_malloc(sizeof(char)*p1->size);\n\t\t\tmemcpy(p2->data, p1->data, sizeof(char)*p1->size);\n\t\t\tgf_list_add(cfg_new->sequenceParameterSetExtensions, p2);\n\t\t}\n\t}\n\treturn cfg_new;\n}\n\nstatic void merge_avc_config(GF_AVCConfig *dst_cfg, GF_AVCConfig *src_cfg)\n{\n\tGF_AVCConfig *cfg;\n\tif (!src_cfg || !dst_cfg) return;\n\tcfg = AVC_DuplicateConfig(src_cfg);\n\tif (!cfg) return;\n\n\twhile (gf_list_count(cfg->sequenceParameterSets)) {\n\t\tGF_NALUFFParam *p = (GF_NALUFFParam*)gf_list_get(cfg->sequenceParameterSets, 0);\n\t\tgf_list_rem(cfg->sequenceParameterSets, 0);\n\t\tgf_list_insert(dst_cfg->sequenceParameterSets, p, 0);\n\t}\n\twhile (gf_list_count(cfg->pictureParameterSets)) {\n\t\tGF_NALUFFParam *p = (GF_NALUFFParam*)gf_list_get(cfg->pictureParameterSets, 0);\n\t\tgf_list_rem(cfg->pictureParameterSets, 0);\n\t\tgf_list_insert(dst_cfg->pictureParameterSets, p, 0);\n\t}\n\tgf_odf_avc_cfg_del(cfg);\n}\n\nvoid merge_hevc_config(GF_HEVCConfig *dst_cfg, GF_HEVCConfig *src_cfg, Bool force_insert)\n{\n\tGF_HEVCConfig *cfg = HEVC_DuplicateConfig(src_cfg);\n\t//merge all xPS\n\tu32 i, j, count = cfg->param_array ? gf_list_count(cfg->param_array) : 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParamArray *ar_h = NULL;\n\t\tu32 count2 = dst_cfg->param_array ? gf_list_count(dst_cfg->param_array) : 0;\n\t\tGF_NALUFFParamArray *ar = (GF_NALUFFParamArray*)gf_list_get(cfg->param_array, i);\n\t\tfor (j=0; j<count2; j++) {\n\t\t\tar_h = (GF_NALUFFParamArray*)gf_list_get(dst_cfg->param_array, j);\n\t\t\tif (ar_h->type==ar->type) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tar_h = NULL;\n\t\t}\n\t\tif (!ar_h) {\n\t\t\tgf_list_add(dst_cfg->param_array, ar);\n\t\t\tgf_list_rem(cfg->param_array, i);\n\t\t\tcount--;\n\t\t\ti--;\n\t\t} else {\n\t\t\twhile (gf_list_count(ar->nalus)) {\n\t\t\t\tGF_NALUFFParam *p = (GF_NALUFFParam*)gf_list_get(ar->nalus, 0);\n\t\t\t\tgf_list_rem(ar->nalus, 0);\n\t\t\t\tif (force_insert)\n\t\t\t\t\tgf_list_insert(ar_h->nalus, p, 0);\n\t\t\t\telse\n\t\t\t\t\tgf_list_add(ar_h->nalus, p);\n\t\t\t}\n\n\t\t}\n\t}\n\tgf_odf_hevc_cfg_del(cfg);\n\n#define CHECK_CODE(__code)\tif (dst_cfg->__code < src_cfg->__code) dst_cfg->__code = src_cfg->__code;\n\n\tCHECK_CODE(configurationVersion)\n\tCHECK_CODE(profile_idc)\n\tCHECK_CODE(profile_space)\n\tCHECK_CODE(tier_flag)\n\tCHECK_CODE(general_profile_compatibility_flags)\n\tCHECK_CODE(progressive_source_flag)\n\tCHECK_CODE(interlaced_source_flag)\n\tCHECK_CODE(constraint_indicator_flags)\n\tCHECK_CODE(level_idc)\n\tCHECK_CODE(min_spatial_segmentation_idc)\n\n}\n\nvoid merge_all_config(GF_AVCConfig *avc_cfg, GF_HEVCConfig *hevc_cfg, GF_MediaBox *mdia)\n{\n\tu32 i;\n\tGF_TrackReferenceTypeBox *scal = NULL;\n\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_SCAL, &scal);\n\n\tif (!scal) return;\n\n\tfor (i=0; i<scal->trackIDCount; i++) {\n\t\tGF_TrackBox *a_track = GetTrackbyID(mdia->mediaTrack->moov, scal->trackIDs[i]);\n\t\tGF_MPEGVisualSampleEntryBox *an_entry = NULL;\n\t\tif (a_track && a_track->Media && a_track->Media->information && a_track->Media->information->sampleTable && a_track->Media->information->sampleTable->SampleDescription)\n\t\t\tan_entry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(a_track->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\n\t\tif (!an_entry) continue;\n\n\t\tif (avc_cfg && an_entry->svc_config && an_entry->svc_config->config)\n\t\t\tmerge_avc_config(avc_cfg, an_entry->svc_config->config);\n\n\t\tif (avc_cfg && an_entry->mvc_config && an_entry->mvc_config->config)\n\t\t\tmerge_avc_config(avc_cfg, an_entry->mvc_config->config);\n\n\t\tif (avc_cfg && an_entry->avc_config && an_entry->avc_config->config)\n\t\t\tmerge_avc_config(avc_cfg, an_entry->avc_config->config);\n\n\t\tif (hevc_cfg && an_entry->lhvc_config && an_entry->lhvc_config->config)\n\t\t\tmerge_hevc_config(hevc_cfg, an_entry->lhvc_config->config, GF_TRUE);\n\n\t\tif (hevc_cfg && an_entry->hevc_config && an_entry->hevc_config->config)\n\t\t\tmerge_hevc_config(hevc_cfg, an_entry->hevc_config->config, GF_TRUE);\n\t}\n\n\tif (hevc_cfg) hevc_cfg->is_lhvc = GF_FALSE;\n}\n\nvoid AVC_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *avc, GF_MediaBox *mdia)\n{\n\tGF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)avc, GF_FALSE);\n\n\tif (avc->emul_esd) gf_odf_desc_del((GF_Descriptor *)avc->emul_esd);\n\tavc->emul_esd = gf_odf_desc_esd_new(2);\n\tavc->emul_esd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t/*AVC OTI is 0x21, AVC parameter set stream OTI (not supported in gpac) is 0x22, SVC OTI is 0x24*/\n\t/*if we have only SVC stream, set objectTypeIndication to AVC OTI; else set it to AVC OTI*/\n\tif (avc->svc_config && !avc->avc_config)\n\t\tavc->emul_esd->decoderConfig->objectTypeIndication = GF_CODECID_SVC;\n\telse if (avc->mvc_config && !avc->avc_config)\n\t\tavc->emul_esd->decoderConfig->objectTypeIndication = GF_CODECID_MVC;\n\telse\n\t\tavc->emul_esd->decoderConfig->objectTypeIndication = GF_CODECID_AVC;\n\n\tif (btrt) {\n\t\tavc->emul_esd->decoderConfig->bufferSizeDB = btrt->bufferSizeDB;\n\t\tavc->emul_esd->decoderConfig->avgBitrate = btrt->avgBitrate;\n\t\tavc->emul_esd->decoderConfig->maxBitrate = btrt->maxBitrate;\n\t}\n\tGF_MPEG4ExtensionDescriptorsBox *mdesc = (GF_MPEG4ExtensionDescriptorsBox *) gf_isom_box_find_child(avc->child_boxes, GF_ISOM_BOX_TYPE_M4DS);\n\tif (mdesc) {\n\t\tu32 i=0;\n\t\tGF_Descriptor *desc,*clone;\n\t\ti=0;\n\t\twhile ((desc = (GF_Descriptor *)gf_list_enum(mdesc->descriptors, &i))) {\n\t\t\tclone = NULL;\n\t\t\tgf_odf_desc_copy(desc, &clone);\n\t\t\tif (gf_odf_desc_add_desc((GF_Descriptor *)avc->emul_esd, clone) != GF_OK)\n\t\t\t\tgf_odf_desc_del(clone);\n\t\t}\n\t}\n\tif (avc->avc_config) {\n\t\tGF_AVCConfig *avcc = avc->avc_config->config ? AVC_DuplicateConfig(avc->avc_config->config) : NULL;\n\t\t/*merge SVC config*/\n\t\tif (avc->svc_config) {\n\t\t\tmerge_avc_config(avcc, avc->svc_config->config);\n\t\t}\n\t\t/*merge MVC config*/\n\t\tif (avc->mvc_config) {\n\t\t\tmerge_avc_config(avcc, avc->mvc_config->config);\n\t\t}\n\t\tif (avcc) {\n\t\t\tif (mdia) merge_all_config(avcc, NULL, mdia);\n\n\t\t\tgf_odf_avc_cfg_write(avcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t}\n\t} else if (avc->svc_config) {\n\t\tGF_AVCConfig *svcc = AVC_DuplicateConfig(avc->svc_config->config);\n\n\t\tif (mdia) merge_all_config(svcc, NULL, mdia);\n\n\t\tgf_odf_avc_cfg_write(svcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_odf_avc_cfg_del(svcc);\n\t}\n\telse if (avc->mvc_config) {\n\t\tGF_AVCConfig *mvcc = AVC_DuplicateConfig(avc->mvc_config->config);\n\n\t\tif (mdia) merge_all_config(mvcc, NULL, mdia);\n\n\t\tgf_odf_avc_cfg_write(mvcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_odf_avc_cfg_del(mvcc);\n\t}\n}\n\nvoid AVC_RewriteESDescriptor(GF_MPEGVisualSampleEntryBox *avc)\n{\n\tAVC_RewriteESDescriptorEx(avc, NULL);\n}\n\nvoid HEVC_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *hevc, GF_MediaBox *mdia)\n{\n\tGF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)hevc, GF_FALSE);\n\n\tif (hevc->emul_esd) gf_odf_desc_del((GF_Descriptor *)hevc->emul_esd);\n\thevc->emul_esd = gf_odf_desc_esd_new(2);\n\thevc->emul_esd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\thevc->emul_esd->decoderConfig->objectTypeIndication = GF_CODECID_HEVC;\n\n\tif (btrt) {\n\t\thevc->emul_esd->decoderConfig->bufferSizeDB = btrt->bufferSizeDB;\n\t\thevc->emul_esd->decoderConfig->avgBitrate = btrt->avgBitrate;\n\t\thevc->emul_esd->decoderConfig->maxBitrate = btrt->maxBitrate;\n\t}\n\tGF_MPEG4ExtensionDescriptorsBox *mdesc = (GF_MPEG4ExtensionDescriptorsBox *) gf_isom_box_find_child(hevc->child_boxes, GF_ISOM_BOX_TYPE_M4DS);\n\tif (mdesc) {\n\t\tu32 i=0;\n\t\tGF_Descriptor *desc,*clone;\n\t\ti=0;\n\t\twhile ((desc = (GF_Descriptor *)gf_list_enum(mdesc->descriptors, &i))) {\n\t\t\tclone = NULL;\n\t\t\tgf_odf_desc_copy(desc, &clone);\n\t\t\tif (gf_odf_desc_add_desc((GF_Descriptor *)hevc->emul_esd, clone) != GF_OK)\n\t\t\t\tgf_odf_desc_del(clone);\n\t\t}\n\t}\n\n\tif (hevc->hevc_config || hevc->lhvc_config) {\n\t\tGF_HEVCConfig *hcfg = HEVC_DuplicateConfig(hevc->hevc_config ? hevc->hevc_config->config : hevc->lhvc_config->config);\n\n\t\tif (hevc->hevc_config && hevc->lhvc_config) {\n\t\t\t//merge LHVC config to HEVC conf, so we add entry rather than insert\n\t\t\tmerge_hevc_config(hcfg, hevc->lhvc_config->config, GF_FALSE);\n\t\t}\n\n\t\tif (mdia) merge_all_config(NULL, hcfg, mdia);\n\n\t\tif (hcfg) {\n\t\t\tif (mdia && ((mdia->mediaTrack->extractor_mode&0x0000FFFF) != GF_ISOM_NALU_EXTRACT_INSPECT)) {\n\t\t\t\thcfg->is_lhvc=GF_FALSE;\n\t\t\t}\n\n\t\t\tgf_odf_hevc_cfg_write(hcfg, &hevc->emul_esd->decoderConfig->decoderSpecificInfo->data, &hevc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_odf_hevc_cfg_del(hcfg);\n\t\t}\n\t}\n}\nvoid HEVC_RewriteESDescriptor(GF_MPEGVisualSampleEntryBox *hevc)\n{\n\tHEVC_RewriteESDescriptorEx(hevc, NULL);\n}\n\nGF_Err AVC_HEVC_UpdateESD(GF_MPEGVisualSampleEntryBox *avc, GF_ESD *esd)\n{\n\tGF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)avc, GF_TRUE);\n\n\tGF_MPEG4ExtensionDescriptorsBox *mdesc = (GF_MPEG4ExtensionDescriptorsBox *) gf_isom_box_find_child(avc->child_boxes, GF_ISOM_BOX_TYPE_M4DS);\n\tif (mdesc) {\n\t\tgf_isom_box_del_parent(&avc->child_boxes, (GF_Box *) mdesc);\n\t}\n\tbtrt->avgBitrate = esd->decoderConfig->avgBitrate;\n\tbtrt->maxBitrate = esd->decoderConfig->maxBitrate;\n\tbtrt->bufferSizeDB = esd->decoderConfig->bufferSizeDB;\n\n\tif (gf_list_count(esd->IPIDataSet)\n\t        || gf_list_count(esd->IPMPDescriptorPointers)\n\t        || esd->langDesc\n\t        || gf_list_count(esd->extensionDescriptors)\n\t        || esd->ipiPtr || esd->qos || esd->RegDescriptor) {\n\n\t\tmdesc = (GF_MPEG4ExtensionDescriptorsBox *) gf_isom_box_new_parent(&avc->child_boxes, GF_ISOM_BOX_TYPE_M4DS);\n\t\tif (!mdesc) return GF_OUT_OF_MEM;\n\n\t\tif (esd->RegDescriptor) {\n\t\t\tgf_list_add(mdesc->descriptors, esd->RegDescriptor);\n\t\t\tesd->RegDescriptor = NULL;\n\t\t}\n\t\tif (esd->qos) {\n\t\t\tgf_list_add(mdesc->descriptors, esd->qos);\n\t\t\tesd->qos = NULL;\n\t\t}\n\t\tif (esd->ipiPtr) {\n\t\t\tgf_list_add(mdesc->descriptors, esd->ipiPtr);\n\t\t\tesd->ipiPtr= NULL;\n\t\t}\n\n\t\twhile (gf_list_count(esd->IPIDataSet)) {\n\t\t\tGF_Descriptor *desc = (GF_Descriptor *)gf_list_get(esd->IPIDataSet, 0);\n\t\t\tgf_list_rem(esd->IPIDataSet, 0);\n\t\t\tgf_list_add(mdesc->descriptors, desc);\n\t\t}\n\t\twhile (gf_list_count(esd->IPMPDescriptorPointers)) {\n\t\t\tGF_Descriptor *desc = (GF_Descriptor *)gf_list_get(esd->IPMPDescriptorPointers, 0);\n\t\t\tgf_list_rem(esd->IPMPDescriptorPointers, 0);\n\t\t\tgf_list_add(mdesc->descriptors, desc);\n\t\t}\n\t\tif (esd->langDesc) {\n\t\t\tgf_list_add(mdesc->descriptors, esd->langDesc);\n\t\t\tesd->langDesc = NULL;\n\t\t}\n\t\twhile (gf_list_count(esd->extensionDescriptors)) {\n\t\t\tGF_Descriptor *desc = (GF_Descriptor *)gf_list_get(esd->extensionDescriptors, 0);\n\t\t\tgf_list_rem(esd->extensionDescriptors, 0);\n\t\t\tgf_list_add(mdesc->descriptors, desc);\n\t\t}\n\t}\n\n\n\tif (!avc->lhvc_config && (esd->decoderConfig->objectTypeIndication==GF_CODECID_HEVC)) {\n\t\tif (!avc->hevc_config) {\n\t\t\tavc->hevc_config = (GF_HEVCConfigurationBox *)gf_isom_box_new_parent(&avc->child_boxes, GF_ISOM_BOX_TYPE_HVCC);\n\t\t\tif (!avc->hevc_config) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\tif (avc->hevc_config->config) gf_odf_hevc_cfg_del(avc->hevc_config->config);\n\t\t\tavc->hevc_config->config = gf_odf_hevc_cfg_read(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, GF_FALSE);\n\t\t}\n\t}\n\telse if (!avc->svc_config && !avc->mvc_config && (esd->decoderConfig->objectTypeIndication==GF_CODECID_AVC)) {\n\t\tif (!avc->avc_config) {\n\t\t\tavc->avc_config = (GF_AVCConfigurationBox *)gf_isom_box_new_parent(&avc->child_boxes, GF_ISOM_BOX_TYPE_AVCC);\n\t\t\tif (!avc->avc_config) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\tif (avc->avc_config->config) gf_odf_avc_cfg_del(avc->avc_config->config);\n\t\t\tavc->avc_config->config = gf_odf_avc_cfg_read(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t}\n\t}\n\n\tgf_odf_desc_del((GF_Descriptor *)esd);\n\tif (avc->hevc_config) {\n\t\tHEVC_RewriteESDescriptor(avc);\n\t} else {\n\t\tAVC_RewriteESDescriptor(avc);\n\t}\n\treturn GF_OK;\n}\n\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\nvoid gf_hevc_parse_ps(GF_HEVCConfig* hevccfg, HEVCState* hevc, u32 nal_type)\n{\n\tu32 i, j;\n\tif (!hevccfg) return;\n\n\tfor (i = 0; i < gf_list_count(hevccfg->param_array); i++) {\n\t\tGF_NALUFFParamArray* ar = gf_list_get(hevccfg->param_array, i);\n\t\tif (ar->type != nal_type) continue;\n\t\tfor (j = 0; j < gf_list_count(ar->nalus); j++) {\n\t\t\tu8 ntype, tid, lid;\n\t\t\tGF_NALUFFParam* sl = gf_list_get(ar->nalus, j);\n\t\t\tgf_hevc_parse_nalu(sl->data, sl->size, hevc, &ntype, &tid, &lid);\n\t\t}\n\t}\n}\n#endif\n\n#if !defined(GPAC_DISABLE_AV_PARSERS)\nvoid gf_vvc_parse_ps(GF_VVCConfig* vvccfg, VVCState* vvc, u32 nal_type)\n{\n\tu32 i, j;\n\tif (!vvccfg) return;\n\n\tfor (i = 0; i < gf_list_count(vvccfg->param_array); i++) {\n\t\tGF_NALUFFParamArray* ar = gf_list_get(vvccfg->param_array, i);\n\t\tif (ar->type != nal_type) continue;\n\t\tfor (j = 0; j < gf_list_count(ar->nalus); j++) {\n\t\t\tu8 ntype, tid, lid;\n\t\t\tGF_NALUFFParam* sl = gf_list_get(ar->nalus, j);\n\t\t\tgf_vvc_parse_nalu(sl->data, sl->size, vvc, &ntype, &tid, &lid);\n\t\t}\n\t}\n}\n#endif\n\n\nstatic GF_Err gf_isom_check_mvc(GF_ISOFile *the_file, GF_TrackBox *trak, GF_MPEGVisualSampleEntryBox *entry)\n{\n\tu32 i;\n\tGF_Box *mvci;\n\tGF_MultiviewGroupBox *mvcg;\n\tGF_ViewIdentifierBox *vwid;\n\n\tif (entry->mvc_config) {}\n\telse if (entry->avc_config && entry->avc_config->config && entry->avc_config->config->sequenceParameterSetExtensions) {}\n\telse\n\t\treturn GF_OK;\n\n\tmvci = gf_isom_box_find_child(trak->Media->information->child_boxes, GF_ISOM_BOX_TYPE_MVCI);\n\tif (!mvci) {\n\t\tmvci = gf_isom_box_new_parent(&trak->Media->information->child_boxes, GF_ISOM_BOX_TYPE_MVCI);\n\t\tif (!mvci) return GF_OUT_OF_MEM;\n\t}\n\tmvcg = (GF_MultiviewGroupBox *) gf_isom_box_find_child(mvci->child_boxes, GF_ISOM_BOX_TYPE_MVCG);\n\tif (!mvcg) {\n\t\tmvcg = (GF_MultiviewGroupBox *)gf_isom_box_new_parent(&mvci->child_boxes, GF_ISOM_BOX_TYPE_MVCG);\n\t\tif (!mvcg) return GF_OUT_OF_MEM;\n\t}\n\t//this is very crude, we should try to parse the bitstream to fill these\n\tmvcg->num_entries = 0;\n\tif (mvcg->entries) {\n\t\tgf_free(mvcg->entries);\n\t\tmvcg->entries = NULL;\n\t}\n\tif (entry->avc_config) {\n\t\tif (gf_list_count(entry->avc_config->config->sequenceParameterSets))\n\t\t\tmvcg->num_entries += 1;\n\t\tmvcg->num_entries += gf_list_count(entry->avc_config->config->sequenceParameterSetExtensions);\n\t}\n\tif (entry->mvc_config && entry->mvc_config->config) {\n\t\tmvcg->num_entries += gf_list_count(entry->mvc_config->config->sequenceParameterSets);\n\t}\n\tmvcg->entries = gf_malloc(sizeof(MVCIEntry)*mvcg->num_entries);\n\tif (!mvcg->entries) return GF_OUT_OF_MEM;\n\tmemset(mvcg->entries, 0, sizeof(MVCIEntry)*mvcg->num_entries);\n\tfor (i=0; i<mvcg->num_entries; i++) {\n\t\tmvcg->entries[i].entry_type = 2;\n\t\tmvcg->entries[i].output_view_id = i;\n\t}\n\tvwid = (GF_ViewIdentifierBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_VWID);\n\tif (!vwid) {\n\t\tvwid = (GF_ViewIdentifierBox *)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_VWID);\n\t\tif (!mvcg) return GF_OUT_OF_MEM;\n\t}\n\tif (vwid->views) gf_free(vwid->views);\n\tvwid->num_views = mvcg->num_entries;\n\tvwid->views = gf_malloc(sizeof(ViewIDEntry)*vwid->num_views);\n\tif (!vwid->views) return GF_OUT_OF_MEM;\n\tmemset(vwid->views, 0, sizeof(ViewIDEntry)*vwid->num_views);\n\n\tfor (i=0; i<vwid->num_views; i++) {\n\t\tvwid->views[i].base_view_type = i ? 0 : 1;\n\t\tvwid->views[i].view_id = i;\n\t\tvwid->views[i].view_order_index = i;\n\t}\n\n\treturn GF_OK;\n}\n\nstatic GF_AV1Config* AV1_DuplicateConfig(GF_AV1Config const * const cfg)\n{\n\tu32 i = 0;\n\tGF_AV1Config *out = gf_malloc(sizeof(GF_AV1Config));\n\n\tout->marker = cfg->marker;\n\tout->version = cfg->version;\n\tout->seq_profile = cfg->seq_profile;\n\tout->seq_level_idx_0 = cfg->seq_level_idx_0;\n\tout->seq_tier_0 = cfg->seq_tier_0;\n\tout->high_bitdepth = cfg->high_bitdepth;\n\tout->twelve_bit = cfg->twelve_bit;\n\tout->monochrome = cfg->monochrome;\n\tout->chroma_subsampling_x = cfg->chroma_subsampling_x;\n\tout->chroma_subsampling_y = cfg->chroma_subsampling_y;\n\tout->chroma_sample_position = cfg->chroma_sample_position;\n\n\tout->initial_presentation_delay_present = cfg->initial_presentation_delay_present;\n\tout->initial_presentation_delay_minus_one = cfg->initial_presentation_delay_minus_one;\n\tout->obu_array = gf_list_new();\n\tfor (i = 0; i<gf_list_count(cfg->obu_array); ++i) {\n\t\tGF_AV1_OBUArrayEntry *dst = gf_malloc(sizeof(GF_AV1_OBUArrayEntry)), *src = gf_list_get(cfg->obu_array, i);\n\t\tdst->obu_length = src->obu_length;\n\t\tdst->obu_type = src->obu_type;\n\t\tdst->obu = gf_malloc((size_t)dst->obu_length);\n\t\tmemcpy(dst->obu, src->obu, (size_t)src->obu_length);\n\t\tgf_list_add(out->obu_array, dst);\n\t}\n\treturn out;\n}\n\nvoid AV1_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *av1, GF_MediaBox *mdia)\n{\n\tGF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)av1, GF_FALSE);\n\n\tif (av1->emul_esd) gf_odf_desc_del((GF_Descriptor *)av1->emul_esd);\n\tav1->emul_esd = gf_odf_desc_esd_new(2);\n\tav1->emul_esd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\tav1->emul_esd->decoderConfig->objectTypeIndication = GF_CODECID_AV1;\n\n\tif (btrt) {\n\t\tav1->emul_esd->decoderConfig->bufferSizeDB = btrt->bufferSizeDB;\n\t\tav1->emul_esd->decoderConfig->avgBitrate = btrt->avgBitrate;\n\t\tav1->emul_esd->decoderConfig->maxBitrate = btrt->maxBitrate;\n\t}\n\tif (av1->av1_config && av1->av1_config->config) {\n\t\tGF_AV1Config *av1_cfg = AV1_DuplicateConfig(av1->av1_config->config);\n\t\tif (av1_cfg) {\n\t\t\tgf_odf_av1_cfg_write(av1_cfg, &av1->emul_esd->decoderConfig->decoderSpecificInfo->data, &av1->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_odf_av1_cfg_del(av1_cfg);\n\t\t}\n\t}\n}\n\nvoid AV1_RewriteESDescriptor(GF_MPEGVisualSampleEntryBox *av1)\n{\n\tAV1_RewriteESDescriptorEx(av1, NULL);\n}\n\n\n\nstatic GF_VPConfig* VP_DuplicateConfig(GF_VPConfig const * const cfg)\n{\n\tGF_VPConfig *out = gf_odf_vp_cfg_new();\n\tif (out) {\n\t\tout->profile = cfg->profile;\n\t\tout->level = cfg->level;\n\t\tout->bit_depth = cfg->bit_depth;\n\t\tout->chroma_subsampling = cfg->chroma_subsampling;\n\t\tout->video_fullRange_flag = cfg->video_fullRange_flag;\n\t\tout->colour_primaries = cfg->colour_primaries;\n\t\tout->transfer_characteristics = cfg->transfer_characteristics;\n\t\tout->matrix_coefficients = cfg->matrix_coefficients;\n\t}\n\n\treturn out;\n}\n\nvoid VP9_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *vp9, GF_MediaBox *mdia)\n{\n\tGF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)vp9, GF_FALSE);\n\n\tif (vp9->emul_esd) gf_odf_desc_del((GF_Descriptor *)vp9->emul_esd);\n\tvp9->emul_esd = gf_odf_desc_esd_new(2);\n\tvp9->emul_esd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\tif (vp9->type == GF_ISOM_BOX_TYPE_VP08)\n\t\tvp9->emul_esd->decoderConfig->objectTypeIndication = GF_CODECID_VP8;\n\telse\n\t\tvp9->emul_esd->decoderConfig->objectTypeIndication = GF_CODECID_VP9;\n\n\tif (btrt) {\n\t\tvp9->emul_esd->decoderConfig->bufferSizeDB = btrt->bufferSizeDB;\n\t\tvp9->emul_esd->decoderConfig->avgBitrate = btrt->avgBitrate;\n\t\tvp9->emul_esd->decoderConfig->maxBitrate = btrt->maxBitrate;\n\t}\n\n\tif (vp9->vp_config && vp9->vp_config->config) {\n\t\tGF_VPConfig *vp9_cfg = VP_DuplicateConfig(vp9->vp_config->config);\n\t\tif (vp9_cfg) {\n\t\t\tgf_odf_vp_cfg_write(vp9_cfg, &vp9->emul_esd->decoderConfig->decoderSpecificInfo->data, &vp9->emul_esd->decoderConfig->decoderSpecificInfo->dataLength, GF_FALSE);\n\t\t\tgf_odf_vp_cfg_del(vp9_cfg);\n\t\t}\n\t}\n}\n\nvoid VP9_RewriteESDescriptor(GF_MPEGVisualSampleEntryBox *vp9)\n{\n\tVP9_RewriteESDescriptorEx(vp9, NULL);\n}\n\n\n\nstatic GF_DOVIDecoderConfigurationRecord* DOVI_DuplicateConfig(GF_DOVIDecoderConfigurationRecord *cfg)\n{\n\tGF_DOVIDecoderConfigurationRecord* out = NULL;\n\tGF_SAFEALLOC(out, GF_DOVIDecoderConfigurationRecord);\n\tif (!out) return NULL;\n\n\tout->dv_version_major = cfg->dv_version_major;\n\tout->dv_version_minor = cfg->dv_version_minor;\n\tout->dv_profile = cfg->dv_profile;\n\tout->dv_level = cfg->dv_level;\n\tout->rpu_present_flag = cfg->rpu_present_flag;\n\tout->el_present_flag = cfg->el_present_flag;\n\tout->bl_present_flag = cfg->bl_present_flag;\n\n\treturn out;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_EXPORT\nGF_Err gf_isom_avc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_AVCConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_SampleDescriptionBox *stsd;\n\tu32 dataRefIndex;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !cfg) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(the_file, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!the_file->keep_utc && !gf_sys_is_test_mode() )\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\n\t//create a new entry\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new_parent(&stsd->child_boxes, GF_ISOM_BOX_TYPE_AVC1);\n\tif (!entry) return GF_OUT_OF_MEM;\n\t*outDescriptionIndex = gf_list_count(stsd->child_boxes);\n\n\tentry->avc_config = (GF_AVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_AVCC);\n\tif (!entry->avc_config) return GF_OUT_OF_MEM;\n\tentry->avc_config->config = AVC_DuplicateConfig(cfg);\n\tif (!entry->avc_config->config) return GF_OUT_OF_MEM;\n\tentry->dataReferenceIndex = dataRefIndex;\n\tAVC_RewriteESDescriptor(entry);\n\treturn e;\n}\n\nstatic GF_Err gf_isom_avc_config_update_ex(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_AVCConfig *cfg, u32 op_type, Bool keep_xps)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 i;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_BAD_PARAM;\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tswitch (op_type) {\n\t/*AVCC replacement*/\n\tcase 0:\n\t\tif (!cfg) return GF_BAD_PARAM;\n\t\tif (!entry->avc_config) {\n\t\t\tentry->avc_config = (GF_AVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_AVCC);\n\t\t\tif (!entry->avc_config) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (entry->avc_config->config) gf_odf_avc_cfg_del(entry->avc_config->config);\n\t\tentry->avc_config->config = AVC_DuplicateConfig(cfg);\n\t\tif (!entry->avc_config->config) return GF_OUT_OF_MEM;\n\t\tentry->type = GF_ISOM_BOX_TYPE_AVC1;\n\t\tbreak;\n\t/*SVCC replacement*/\n\tcase 1:\n\t\tif (!cfg) return GF_BAD_PARAM;\n\t\tif (!entry->svc_config) {\n\t\t\tentry->svc_config = (GF_AVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_SVCC);\n\t\t\tif (!entry->svc_config) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (entry->svc_config->config) gf_odf_avc_cfg_del(entry->svc_config->config);\n\t\tentry->svc_config->config = AVC_DuplicateConfig(cfg);\n\t\tif (!entry->svc_config->config) return GF_OUT_OF_MEM;\n\t\tentry->type = GF_ISOM_BOX_TYPE_AVC1;\n\t\tbreak;\n\t/*SVCC replacement and AVC removal*/\n\tcase 2:\n\t\tif (!cfg) return GF_BAD_PARAM;\n\t\tif (entry->avc_config) {\n\t\t\tgf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)entry->avc_config);\n\t\t\tentry->avc_config = NULL;\n\t\t}\n\t\tif (!entry->svc_config) {\n\t\t\tentry->svc_config = (GF_AVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_SVCC);\n\t\t\tif (!entry->svc_config) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (entry->svc_config->config) gf_odf_avc_cfg_del(entry->svc_config->config);\n\t\tentry->svc_config->config = AVC_DuplicateConfig(cfg);\n\t\tif (!entry->svc_config->config) return GF_OUT_OF_MEM;\n\t\tentry->type = GF_ISOM_BOX_TYPE_SVC1;\n\t\tbreak;\n\t/*AVCC removal and switch to avc3*/\n\tcase 3:\n\t\tif (!entry->avc_config || !entry->avc_config->config)\n\t\t\treturn GF_BAD_PARAM;\n\t\tif (!keep_xps) {\n\t\t\tfor (i=0; i<3; i++) {\n\t\t\t\tGF_AVCConfigurationBox *a_cfg = entry->avc_config;\n\t\t\t\tif (i==1) a_cfg = entry->svc_config;\n\t\t\t\telse if (i==2) a_cfg = entry->mvc_config;\n\t\t\t\tif (!a_cfg) continue;\n\n\n\t\t\t\twhile (gf_list_count(a_cfg->config->sequenceParameterSets)) {\n\t\t\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam*)gf_list_get(a_cfg->config->sequenceParameterSets, 0);\n\t\t\t\t\tgf_list_rem(a_cfg->config->sequenceParameterSets, 0);\n\t\t\t\t\tif (sl->data) gf_free(sl->data);\n\t\t\t\t\tgf_free(sl);\n\t\t\t\t}\n\n\t\t\t\twhile (gf_list_count(a_cfg->config->pictureParameterSets)) {\n\t\t\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam*)gf_list_get(a_cfg->config->pictureParameterSets, 0);\n\t\t\t\t\tgf_list_rem(a_cfg->config->pictureParameterSets, 0);\n\t\t\t\t\tif (sl->data) gf_free(sl->data);\n\t\t\t\t\tgf_free(sl);\n\t\t\t\t}\n\n\t\t\t\twhile (gf_list_count(a_cfg->config->sequenceParameterSetExtensions)) {\n\t\t\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam*)gf_list_get(a_cfg->config->sequenceParameterSetExtensions, 0);\n\t\t\t\t\tgf_list_rem(a_cfg->config->sequenceParameterSetExtensions, 0);\n\t\t\t\t\tif (sl->data) gf_free(sl->data);\n\t\t\t\t\tgf_free(sl);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (entry->type == GF_ISOM_BOX_TYPE_AVC1)\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_AVC3;\n\t\telse if (entry->type == GF_ISOM_BOX_TYPE_AVC2)\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_AVC4;\n\t\tbreak;\n\t/*MVCC replacement*/\n\tcase 4:\n\t\tif (!cfg) return GF_BAD_PARAM;\n\t\tif (!entry->mvc_config) {\n\t\t\tentry->mvc_config = (GF_AVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_MVCC);\n\t\t\tif (!entry->mvc_config) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (entry->mvc_config->config) gf_odf_avc_cfg_del(entry->mvc_config->config);\n\t\tentry->mvc_config->config = AVC_DuplicateConfig(cfg);\n\t\tif (!entry->mvc_config->config) return GF_OUT_OF_MEM;\n\t\tentry->type = GF_ISOM_BOX_TYPE_AVC1;\n\t\te = gf_isom_check_mvc(the_file, trak, entry);\n\t\tif (e) return e;\n\t\tbreak;\n\t/*MVCC replacement and AVC removal*/\n\tcase 5:\n\t\tif (!cfg) return GF_BAD_PARAM;\n\t\tif (entry->avc_config) {\n\t\t\tgf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)entry->avc_config);\n\t\t\tentry->avc_config = NULL;\n\t\t}\n\t\tif (!entry->mvc_config) {\n\t\t\tentry->mvc_config = (GF_AVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_MVCC);\n\t\t\tif (!entry->mvc_config) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (entry->mvc_config->config) gf_odf_avc_cfg_del(entry->mvc_config->config);\n\t\tentry->mvc_config->config = AVC_DuplicateConfig(cfg);\n\t\tif (!entry->mvc_config->config) return GF_OUT_OF_MEM;\n\t\tentry->type = GF_ISOM_BOX_TYPE_MVC1;\n\t\te = gf_isom_check_mvc(the_file, trak, entry);\n\t\tif (e) return e;\n\t\tbreak;\n\t}\n\tAVC_RewriteESDescriptor(entry);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_avc_set_inband_config(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, Bool keep_xps)\n{\n\treturn gf_isom_avc_config_update_ex(the_file, trackNumber, DescriptionIndex, NULL, 3, keep_xps);\n}\n\nGF_EXPORT\nGF_Err gf_isom_avc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_AVCConfig *cfg)\n{\n\treturn gf_isom_avc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, 0, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_svc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_AVCConfig *cfg, Bool is_add)\n{\n\treturn gf_isom_avc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, is_add ? 1 : 2, GF_FALSE);\n}\n\nGF_Err gf_isom_mvc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_AVCConfig *cfg, Bool is_add)\n{\n\treturn gf_isom_avc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, is_add ? 4 : 5, GF_FALSE);\n}\n\nstatic GF_Err gf_isom_svc_mvc_config_del(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, Bool is_mvc)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_BAD_PARAM;\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (is_mvc && entry->mvc_config) {\n\t\tgf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)entry->mvc_config);\n\t\tentry->mvc_config = NULL;\n\t}\n\telse if (!is_mvc && entry->svc_config) {\n\t\tgf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)entry->svc_config);\n\t\tentry->svc_config = NULL;\n\t}\n\tAVC_RewriteESDescriptor(entry);\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_svc_config_del(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\treturn gf_isom_svc_mvc_config_del(the_file, trackNumber, DescriptionIndex, GF_FALSE);\n}\n\nGF_Err gf_isom_mvc_config_del(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\treturn gf_isom_svc_mvc_config_del(the_file, trackNumber, DescriptionIndex, GF_TRUE);\n}\n\nstatic GF_Err gf_isom_svc_mvc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_AVCConfig *cfg, Bool is_mvc, char *URLname, char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !cfg) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, URLname, URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(the_file, trak->Media->information->dataInformation->dref, URLname, URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!the_file->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\t//create a new entry\n\tif (is_mvc) {\n\t\tentry = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new_parent(&stsd->child_boxes, GF_ISOM_BOX_TYPE_MVC1);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\tentry->mvc_config = (GF_AVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_MVCC);\n\t\tif (!entry->mvc_config) return GF_OUT_OF_MEM;\n\t\tentry->mvc_config->config = AVC_DuplicateConfig(cfg);\n\t\tif (!entry->mvc_config->config) return GF_OUT_OF_MEM;\n\t} else {\n\t\tentry = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new_parent(&stsd->child_boxes,GF_ISOM_BOX_TYPE_SVC1);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\tentry->svc_config = (GF_AVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes,GF_ISOM_BOX_TYPE_SVCC);\n\t\tif (!entry->svc_config) return GF_OUT_OF_MEM;\n\t\tentry->svc_config->config = AVC_DuplicateConfig(cfg);\n\t\tif (!entry->svc_config->config) return GF_OUT_OF_MEM;\n\t}\n\tentry->dataReferenceIndex = dataRefIndex;\n\t*outDescriptionIndex = gf_list_count(stsd->child_boxes);\n\tAVC_RewriteESDescriptor(entry);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_svc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_AVCConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\treturn gf_isom_svc_mvc_config_new(the_file, trackNumber, cfg, GF_FALSE, (char *) URLname, (char *) URNname,outDescriptionIndex);\n}\n\nGF_EXPORT\nGF_Err gf_isom_mvc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_AVCConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\treturn gf_isom_svc_mvc_config_new(the_file, trackNumber, cfg, GF_TRUE, (char *) URLname, (char *) URNname,outDescriptionIndex);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_hevc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_HEVCConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !cfg) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(the_file, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!the_file->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\t//create a new entry\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new_parent(&stsd->child_boxes, GF_ISOM_BOX_TYPE_HVC1);\n\tif (!entry) return GF_OUT_OF_MEM;\n\tentry->hevc_config = (GF_HEVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_HVCC);\n\tif (!entry->hevc_config) return GF_OUT_OF_MEM;\n\tentry->hevc_config->config = HEVC_DuplicateConfig(cfg);\n\tif (!entry->hevc_config->config) return GF_OUT_OF_MEM;\n\tentry->dataReferenceIndex = dataRefIndex;\n\t*outDescriptionIndex = gf_list_count(stsd->child_boxes);\n\tHEVC_RewriteESDescriptor(entry);\n\treturn e;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_vvc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_VVCConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !cfg) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(the_file, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!the_file->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\t//create a new entry\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new_parent(&stsd->child_boxes, GF_ISOM_BOX_TYPE_VVC1);\n\tif (!entry) return GF_OUT_OF_MEM;\n\tentry->vvc_config = (GF_VVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_VVCC);\n\tif (!entry->vvc_config) return GF_OUT_OF_MEM;\n\tentry->vvc_config->config = VVC_DuplicateConfig(cfg);\n\tif (!entry->vvc_config->config) return GF_OUT_OF_MEM;\n\tentry->dataReferenceIndex = dataRefIndex;\n\t*outDescriptionIndex = gf_list_count(stsd->child_boxes);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_vp_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_VPConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex, u32 vpx_type)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !cfg) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(the_file, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!the_file->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\t//create a new entry\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_isom_box_new_parent(&stsd->child_boxes, vpx_type);\n\tif (!entry) return GF_OUT_OF_MEM;\n\n\tentry->vp_config = (GF_VPConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_VPCC);\n\tif (!entry->vp_config) return GF_OUT_OF_MEM;\n\tentry->vp_config->config = VP_DuplicateConfig(cfg);\n\tif (!entry->vp_config->config) return GF_OUT_OF_MEM;\n\tstrncpy(entry->compressor_name, \"\\012VPC Coding\", sizeof(entry->compressor_name)-1);\n\tentry->dataReferenceIndex = dataRefIndex;\n\t*outDescriptionIndex = gf_list_count(stsd->child_boxes);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_av1_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_AV1Config *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !cfg) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(the_file, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!the_file->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\t//create a new entry\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_isom_box_new_parent(&stsd->child_boxes, GF_ISOM_BOX_TYPE_AV01);\n\tif (!entry) return GF_OUT_OF_MEM;\n\tentry->av1_config = (GF_AV1ConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_AV1C);\n\tif (!entry->av1_config) return GF_OUT_OF_MEM;\n\tentry->av1_config->config = AV1_DuplicateConfig(cfg);\n\tif (!entry->av1_config->config) return GF_OUT_OF_MEM;\n\tentry->dataReferenceIndex = dataRefIndex;\n\t*outDescriptionIndex = gf_list_count(stsd->child_boxes);\n\treturn e;\n}\n\n\ntypedef enum\n{\n\tGF_ISOM_HVCC_UPDATE = 0,\n\tGF_ISOM_HVCC_SET_INBAND,\n\tGF_ISOM_HVCC_SET_TILE,\n\tGF_ISOM_HVCC_SET_TILE_BASE_TRACK,\n\tGF_ISOM_HVCC_SET_LHVC,\n\tGF_ISOM_HVCC_SET_LHVC_WITH_BASE,\n\tGF_ISOM_HVCC_SET_LHVC_WITH_BASE_BACKWARD,\n\tGF_ISOM_HVCC_SET_HEVC_TILE_BASE,\n\tGF_ISOM_LHCC_SET_INBAND\n} HevcConfigUpdateType;\n\nstatic Bool nalu_cleanup_config(GF_List *param_array, Bool set_inband, Bool keep_xps)\n{\n\tu32 i;\n\tBool array_incomplete = set_inband;\n\tif (!param_array) return 0;\n\n\tfor (i=0; i<gf_list_count(param_array); i++) {\n\t\tGF_NALUFFParamArray *ar = (GF_NALUFFParamArray*)gf_list_get(param_array, i);\n\n\t\t/*we want to force inband signaling*/\n\t\tif (set_inband) {\n\t\t\tar->array_completeness = 0;\n\t\t\tif (keep_xps) {\n\t\t\t\tarray_incomplete=1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhile (gf_list_count(ar->nalus)) {\n\t\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam*)gf_list_get(ar->nalus, 0);\n\t\t\t\tgf_list_rem(ar->nalus, 0);\n\t\t\t\tif (sl->data) gf_free(sl->data);\n\t\t\t\tgf_free(sl);\n\t\t\t}\n\t\t\tgf_list_del(ar->nalus);\n\t\t\tgf_free(ar);\n\t\t\tar=NULL;\n\t\t\tgf_list_rem(param_array, i);\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ar && !ar->array_completeness)\n\t\t\tarray_incomplete = 1;\n\t}\n\treturn array_incomplete;\n}\n\nstatic\nGF_Err gf_isom_hevc_config_update_ex(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_HEVCConfig *cfg, u32 operand_type, Bool keep_xps)\n{\n\tu32 array_incomplete;\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_BAD_PARAM;\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_list_get(stsd->child_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_LHV1:\n\tcase GF_ISOM_BOX_TYPE_LHE1:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\n\tif (operand_type == GF_ISOM_HVCC_SET_TILE_BASE_TRACK) {\n\t\tif (entry->type==GF_ISOM_BOX_TYPE_HVC1)\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_HVC2;\n\t\telse if (entry->type==GF_ISOM_BOX_TYPE_HEV1)\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_HEV2;\n\t} else if (operand_type == GF_ISOM_HVCC_SET_TILE) {\n\t\tif (!entry->hevc_config) entry->hevc_config = (GF_HEVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_HVCC);\n\t\tif (!entry->hevc_config) return GF_OUT_OF_MEM;\n\t\tif (entry->hevc_config->config) gf_odf_hevc_cfg_del(entry->hevc_config->config);\n\t\tentry->hevc_config->config = NULL;\n\t\tentry->type = GF_ISOM_BOX_TYPE_HVT1;\n\t} else if (operand_type < GF_ISOM_HVCC_SET_LHVC) {\n\t\tif ((operand_type != GF_ISOM_HVCC_SET_INBAND) && !entry->hevc_config) {\n\t\t\tentry->hevc_config = (GF_HEVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_HVCC);\n\t\t\tif (!entry->hevc_config) return GF_OUT_OF_MEM;\n\t\t}\n\n\t\tif (cfg) {\n\t\t\tif (entry->hevc_config->config) gf_odf_hevc_cfg_del(entry->hevc_config->config);\n\t\t\tentry->hevc_config->config = HEVC_DuplicateConfig(cfg);\n\t\t} else {\n\t\t\toperand_type=GF_ISOM_HVCC_SET_INBAND;\n\t\t}\n\t\tarray_incomplete = (operand_type==GF_ISOM_HVCC_SET_INBAND) ? 1 : 0;\n\t\tif (entry->hevc_config && nalu_cleanup_config(entry->hevc_config->config ? entry->hevc_config->config->param_array : NULL,\n\t\t\t(operand_type==GF_ISOM_HVCC_SET_INBAND) ? GF_TRUE:GF_FALSE,\n\t\t\tkeep_xps)\n\t\t) {\n\t\t\tarray_incomplete=1;\n\t\t}\n\n\t\tif (entry->lhvc_config && nalu_cleanup_config(entry->lhvc_config->config ? entry->lhvc_config->config->param_array : NULL,\n\t\t\t(operand_type==GF_ISOM_HVCC_SET_INBAND),\n\t\t\tkeep_xps)\n\t\t)\n\t\t\tarray_incomplete=1;\n\n\t\tswitch (entry->type) {\n\t\tcase GF_ISOM_BOX_TYPE_HEV1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC1:\n\t\t\tentry->type = array_incomplete ? GF_ISOM_BOX_TYPE_HEV1 : GF_ISOM_BOX_TYPE_HVC1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_HEV2:\n\t\tcase GF_ISOM_BOX_TYPE_HVC2:\n\t\t\tentry->type = array_incomplete ? GF_ISOM_BOX_TYPE_HEV2 : GF_ISOM_BOX_TYPE_HVC2;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_LHE1:\n\t\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\t\tentry->type = array_incomplete ? GF_ISOM_BOX_TYPE_LHE1 : GF_ISOM_BOX_TYPE_LHV1;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\n\t\t/*SVCC replacement/removal with HEVC base, backward compatible signaling*/\n\t\tif ((operand_type==GF_ISOM_HVCC_SET_LHVC_WITH_BASE_BACKWARD) || (operand_type==GF_ISOM_HVCC_SET_LHVC_WITH_BASE) || (operand_type==GF_ISOM_HVCC_SET_HEVC_TILE_BASE) ) {\n\t\t\tif (!entry->hevc_config) return GF_BAD_PARAM;\n\t\t\tif (!cfg) {\n\t\t\t\tif (entry->lhvc_config) {\n\t\t\t\t\tgf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)entry->lhvc_config);\n\t\t\t\t\tentry->lhvc_config = NULL;\n\t\t\t\t}\n\t\t\t\tif (entry->type==GF_ISOM_BOX_TYPE_LHE1) entry->type = (operand_type==GF_ISOM_HVCC_SET_LHVC_WITH_BASE) ? GF_ISOM_BOX_TYPE_HEV2 : GF_ISOM_BOX_TYPE_HEV1;\n\t\t\t\telse if (entry->type==GF_ISOM_BOX_TYPE_HEV1) entry->type = (operand_type==GF_ISOM_HVCC_SET_LHVC_WITH_BASE) ? GF_ISOM_BOX_TYPE_HEV2 : GF_ISOM_BOX_TYPE_HEV1;\n\t\t\t\telse entry->type =  (operand_type==GF_ISOM_HVCC_SET_LHVC_WITH_BASE) ? GF_ISOM_BOX_TYPE_HVC2 : GF_ISOM_BOX_TYPE_HVC1;\n\t\t\t} else {\n\t\t\t\tif (operand_type != GF_ISOM_HVCC_SET_HEVC_TILE_BASE) {\n\t\t\t\t\tif (!entry->lhvc_config) {\n\t\t\t\t\t\tentry->lhvc_config = (GF_HEVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_LHVC);\n\t\t\t\t\t\tif (!entry->lhvc_config) return GF_OUT_OF_MEM;\n\t\t\t\t\t}\n\t\t\t\t\tif (entry->lhvc_config->config) gf_odf_hevc_cfg_del(entry->lhvc_config->config);\n\t\t\t\t\tentry->lhvc_config->config = HEVC_DuplicateConfig(cfg);\n\t\t\t\t\tif (!entry->lhvc_config->config) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\n\t\t\t\tif (operand_type==GF_ISOM_HVCC_SET_LHVC_WITH_BASE_BACKWARD) {\n\t\t\t\t\tif (entry->type==GF_ISOM_BOX_TYPE_HEV2) entry->type = GF_ISOM_BOX_TYPE_HEV1;\n\t\t\t\t\telse entry->type = GF_ISOM_BOX_TYPE_HVC1;\n\t\t\t\t} else {\n\t\t\t\t\tif (entry->type==GF_ISOM_BOX_TYPE_HEV1) entry->type = GF_ISOM_BOX_TYPE_HEV2;\n\t\t\t\t\telse entry->type = GF_ISOM_BOX_TYPE_HVC2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*LHEVC track without base*/\n\t\telse if (operand_type==GF_ISOM_HVCC_SET_LHVC) {\n\t\t\tif (entry->hevc_config) {\n\t\t\t\tgf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)entry->hevc_config);\n\t\t\t\tentry->hevc_config=NULL;\n\t\t\t}\n\t\t\tif (!cfg) return GF_BAD_PARAM;\n\n\t\t\tif (!entry->lhvc_config) {\n\t\t\t\tentry->lhvc_config = (GF_HEVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_LHVC);\n\t\t\t\tif (!entry->lhvc_config) return GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tif (entry->lhvc_config->config) gf_odf_hevc_cfg_del(entry->lhvc_config->config);\n\t\t\tentry->lhvc_config->config = HEVC_DuplicateConfig(cfg);\n\t\t\tif (!entry->lhvc_config->config) return GF_OUT_OF_MEM;\n\n\t\t\tif ((entry->type==GF_ISOM_BOX_TYPE_HEV1) || (entry->type==GF_ISOM_BOX_TYPE_HEV2)) entry->type = GF_ISOM_BOX_TYPE_LHE1;\n\t\t\telse entry->type = GF_ISOM_BOX_TYPE_LHV1;\n\t\t}\n\t\t/*LHEVC inband, no config change*/\n\t\telse if (operand_type==GF_ISOM_LHCC_SET_INBAND) {\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_LHE1;\n\t\t}\n\t}\n\n\tHEVC_RewriteESDescriptor(entry);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_hevc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_HEVCConfig *cfg)\n{\n\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, GF_ISOM_HVCC_UPDATE, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_hevc_set_inband_config(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, Bool keep_xps)\n{\n\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, NULL, GF_ISOM_HVCC_SET_INBAND, keep_xps);\n}\n\nGF_EXPORT\nGF_Err gf_isom_lhvc_force_inband_config(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, NULL, GF_ISOM_LHCC_SET_INBAND, GF_FALSE);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_hevc_set_tile_config(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_HEVCConfig *cfg, Bool is_base_track)\n{\n\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, is_base_track ? GF_ISOM_HVCC_SET_TILE_BASE_TRACK : GF_ISOM_HVCC_SET_TILE, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_lhvc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_HEVCConfig *cfg, GF_ISOMLHEVCTrackType track_type)\n{\n\tif (cfg) cfg->is_lhvc = GF_TRUE;\n\tswitch (track_type) {\n\tcase GF_ISOM_LEHVC_ONLY:\n\t\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, GF_ISOM_HVCC_SET_LHVC, GF_FALSE);\n\tcase GF_ISOM_LEHVC_WITH_BASE:\n\t\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, GF_ISOM_HVCC_SET_LHVC_WITH_BASE, GF_FALSE);\n\tcase GF_ISOM_LEHVC_WITH_BASE_BACKWARD:\n\t\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, GF_ISOM_HVCC_SET_LHVC_WITH_BASE_BACKWARD, GF_FALSE);\n\tcase GF_ISOM_HEVC_TILE_BASE:\n\t\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, GF_ISOM_HVCC_SET_HEVC_TILE_BASE, GF_FALSE);\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\n\ntypedef enum\n{\n\tGF_ISOM_VVCC_UPDATE = 0,\n\tGF_ISOM_VVCC_SET_INBAND,\n} VvcConfigUpdateType;\n\n\nstatic\nGF_Err gf_isom_vvc_config_update_ex(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_VVCConfig *cfg, u32 operand_type, Bool keep_xps)\n{\n\tu32 array_incomplete;\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_BAD_PARAM;\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_list_get(stsd->child_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_VVC1:\n\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\n\tif (operand_type <= GF_ISOM_VVCC_SET_INBAND) {\n\t\tif ((operand_type != GF_ISOM_VVCC_SET_INBAND) && !entry->vvc_config) {\n\t\t\tentry->vvc_config = (GF_VVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_VVCC);\n\t\t\tif (!entry->vvc_config) return GF_OUT_OF_MEM;\n\t\t}\n\n\t\tif (cfg) {\n\t\t\tif (entry->vvc_config->config) gf_odf_vvc_cfg_del(entry->vvc_config->config);\n\t\t\tentry->vvc_config->config = VVC_DuplicateConfig(cfg);\n\t\t} else {\n\t\t\toperand_type = GF_ISOM_VVCC_SET_INBAND;\n\t\t}\n\t\tif (operand_type == GF_ISOM_VVCC_UPDATE) {\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tarray_incomplete = (operand_type==GF_ISOM_VVCC_SET_INBAND) ? 1 : 0;\n\t\tif (entry->vvc_config && nalu_cleanup_config(entry->vvc_config->config ? entry->vvc_config->config->param_array : NULL,\n\t\t\t(operand_type==GF_ISOM_VVCC_SET_INBAND),\n\t\t\tkeep_xps)\n\t\t) {\n\t\t\tarray_incomplete=1;\n\t\t}\n\t\tswitch (entry->type) {\n\t\tcase GF_ISOM_BOX_TYPE_VVC1:\n\t\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\t\tentry->type = array_incomplete ? GF_ISOM_BOX_TYPE_VVI1 : GF_ISOM_BOX_TYPE_VVC1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_vvc_set_inband_config(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, Bool keep_xps)\n{\n\treturn gf_isom_vvc_config_update_ex(the_file, trackNumber, DescriptionIndex, NULL, GF_ISOM_VVCC_SET_INBAND, keep_xps);\n}\n\nGF_EXPORT\nGF_Err gf_isom_vvc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_VVCConfig *cfg)\n{\n\treturn gf_isom_vvc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, GF_ISOM_VVCC_UPDATE, GF_FALSE);\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_EXPORT\nGF_Box *gf_isom_clone_config_box(GF_Box *box)\n{\n\tu8 *data=NULL;\n\tu32 size=0;\n\tGF_Err e;\n\tGF_Box *clone=NULL;\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\te = gf_isom_box_size(box);\n\tif (!e)\n\t\te = gf_isom_box_write(box, bs);\n\n\tgf_bs_get_content(bs, &data, &size);\n\tgf_bs_del(bs);\n\tif (!e) {\n\t\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\t\te = gf_isom_box_parse(&clone, bs);\n\t\tgf_bs_del(bs);\n\t}\n\tif (data)\n\t\tgf_free(data);\n\tif (e) {\n\t\tif (clone)\n\t\t\tgf_isom_box_del(clone);\n\t\tclone = NULL;\n\t}\n\treturn clone;\n}\n\nGF_EXPORT\nGF_AVCConfig *gf_isom_avc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_avc_svc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_AVCTYPE_NONE)\n\t\treturn NULL;\n\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\tif (!entry->avc_config) return NULL;\n\treturn AVC_DuplicateConfig(entry->avc_config->config);\n}\n\nGF_EXPORT\nGF_HEVCConfig *gf_isom_hevc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_hevc_lhvc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_HEVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\tif (!entry->hevc_config) return NULL;\n\treturn HEVC_DuplicateConfig(entry->hevc_config->config);\n}\n\nGF_EXPORT\nGF_ISOMVVCType gf_isom_get_vvc_type(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tu32 type;\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_ISOM_VVCTYPE_NONE;\n\tif (!gf_isom_is_video_handler_type(trak->Media->handler->handlerType))\n\t\treturn GF_ISOM_VVCTYPE_NONE;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_ISOM_VVCTYPE_NONE;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_ISOM_VVCTYPE_NONE;\n\ttype = entry->type;\n\n\tif (type == GF_ISOM_BOX_TYPE_ENCV) {\n\t\tGF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\tif (sinf && sinf->original_format) type = sinf->original_format->data_format;\n\t}\n\telse if (type == GF_ISOM_BOX_TYPE_RESV) {\n\t\tif (entry->rinf && entry->rinf->original_format) type = entry->rinf->original_format->data_format;\n\t}\n\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_VVC1:\n\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\treturn GF_ISOM_VVCTYPE_ONLY;\n\tcase GF_ISOM_SUBTYPE_VVS1:\n\t\treturn GF_ISOM_VVCTYPE_SUBPIC;\n\tcase GF_ISOM_SUBTYPE_VVCN:\n\t\treturn GF_ISOM_VVCTYPE_NVCL;\n\tdefault:\n\t\treturn GF_ISOM_VVCTYPE_NONE;\n\t}\n\treturn GF_ISOM_VVCTYPE_NONE;\n}\n\nGF_EXPORT\nGF_VVCConfig *gf_isom_vvc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tu32 type;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\t/*todo, add support for subpic track and nvcl tracks*/\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\ttype = gf_isom_get_vvc_type(the_file, trackNumber, DescriptionIndex);\n\tif (type==GF_ISOM_VVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\n\tif ((type==GF_ISOM_VVCTYPE_SUBPIC) || (type==GF_ISOM_VVCTYPE_NVCL)) {\n\t\tGF_VVCNaluConfigurationBox *vvnc = (GF_VVCNaluConfigurationBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_VVNC);\n\t\tif (!vvnc) return NULL;\n\t\tGF_VVCConfig *vvcc = gf_odf_vvc_cfg_new();\n\t\tvvcc->nal_unit_size = vvnc->nal_unit_size;\n\t\treturn vvcc;\n\t}\n\tif (!entry->vvc_config) return NULL;\n\treturn VVC_DuplicateConfig(entry->vvc_config->config);\n}\n\nGF_EXPORT\nGF_AVCConfig *gf_isom_svc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_avc_svc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_AVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\tif (!entry->svc_config) return NULL;\n\treturn AVC_DuplicateConfig(entry->svc_config->config);\n}\n\n\nGF_EXPORT\nGF_AVCConfig *gf_isom_mvc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_avc_svc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_AVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\tif (!entry->mvc_config) return NULL;\n\treturn AVC_DuplicateConfig(entry->mvc_config->config);\n}\n\nGF_EXPORT\nGF_AV1Config *gf_isom_av1_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex - 1);\n\tif (!entry) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\tif (!entry->av1_config|| !entry->av1_config->config) return NULL;\n\treturn AV1_DuplicateConfig(entry->av1_config->config);\n}\n\n\nGF_EXPORT\nGF_VPConfig *gf_isom_vp_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex - 1);\n\tif (!entry) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\tif (!entry->vp_config || !entry->vp_config->config) return NULL;\n\treturn VP_DuplicateConfig(entry->vp_config->config);\n}\n\nGF_EXPORT\nGF_DOVIDecoderConfigurationRecord *gf_isom_dovi_config_get(GF_ISOFile* the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox* trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex - 1);\n\tif (!entry) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\tif (!entry->size || !entry->dovi_config) return NULL;\n\treturn DOVI_DuplicateConfig(&entry->dovi_config->DOVIConfig);\n}\n\nGF_EXPORT\nGF_ISOMAVCType gf_isom_get_avc_svc_type(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tu32 type;\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->handler || !DescriptionIndex) return GF_ISOM_AVCTYPE_NONE;\n\tif (!gf_isom_is_video_handler_type(trak->Media->handler->handlerType))\n\t\treturn GF_ISOM_AVCTYPE_NONE;\n\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_ISOM_AVCTYPE_NONE;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_ISOM_AVCTYPE_NONE;\n\n\ttype = entry->type;\n\n\tif (type == GF_ISOM_BOX_TYPE_ENCV) {\n\t\tGF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\tif (sinf && sinf->original_format) type = sinf->original_format->data_format;\n\t}\n\telse if (type == GF_ISOM_BOX_TYPE_RESV) {\n\t\tif (entry->rinf && entry->rinf->original_format) type = entry->rinf->original_format->data_format;\n\t}\n\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\tcase GF_ISOM_BOX_TYPE_DVA1:\n\tcase GF_ISOM_BOX_TYPE_DVAV:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_AVCTYPE_NONE;\n\t}\n\tif (entry->avc_config && !entry->svc_config && !entry->mvc_config) return GF_ISOM_AVCTYPE_AVC_ONLY;\n\tif (entry->avc_config && entry->svc_config) return GF_ISOM_AVCTYPE_AVC_SVC;\n\tif (entry->avc_config && entry->mvc_config) return GF_ISOM_AVCTYPE_AVC_MVC;\n\tif (!entry->avc_config && entry->svc_config) return GF_ISOM_AVCTYPE_SVC_ONLY;\n\tif (!entry->avc_config && entry->mvc_config) return GF_ISOM_AVCTYPE_MVC_ONLY;\n\treturn GF_ISOM_AVCTYPE_NONE;\n}\n\nGF_EXPORT\nGF_ISOMHEVCType gf_isom_get_hevc_lhvc_type(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tu32 type;\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_ISOM_HEVCTYPE_NONE;\n\tif (!gf_isom_is_video_handler_type(trak->Media->handler->handlerType))\n\t\treturn GF_ISOM_HEVCTYPE_NONE;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_ISOM_HEVCTYPE_NONE;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_ISOM_HEVCTYPE_NONE;\n\ttype = entry->type;\n\n\tif (type == GF_ISOM_BOX_TYPE_ENCV) {\n\t\tGF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\tif (sinf && sinf->original_format) type = sinf->original_format->data_format;\n\t}\n\telse if (type == GF_ISOM_BOX_TYPE_RESV) {\n\t\tif (entry->rinf && entry->rinf->original_format) type = entry->rinf->original_format->data_format;\n\t}\n\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_LHV1:\n\tcase GF_ISOM_BOX_TYPE_LHE1:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\tcase GF_ISOM_BOX_TYPE_DVHE:\n\tcase GF_ISOM_BOX_TYPE_DVH1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_HEVCTYPE_NONE;\n\t}\n\tif (entry->hevc_config && !entry->lhvc_config) return GF_ISOM_HEVCTYPE_HEVC_ONLY;\n\tif (entry->hevc_config && entry->lhvc_config) return GF_ISOM_HEVCTYPE_HEVC_LHVC;\n\tif (!entry->hevc_config && entry->lhvc_config) return GF_ISOM_HEVCTYPE_LHVC_ONLY;\n\treturn GF_ISOM_HEVCTYPE_NONE;\n}\n\nGF_EXPORT\nGF_HEVCConfig *gf_isom_lhvc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_HEVCConfig *lhvc;\n\tGF_OperatingPointsInformation *oinf=NULL;\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_hevc_lhvc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_HEVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\tif (!entry->lhvc_config) return NULL;\n\tlhvc = HEVC_DuplicateConfig(entry->lhvc_config->config);\n\tif (!lhvc) return NULL;\n\n\tgf_isom_get_oinf_info(the_file, trackNumber, &oinf);\n\tif (oinf) {\n\t\tLHEVC_ProfileTierLevel *ptl = (LHEVC_ProfileTierLevel *)gf_list_last(oinf->profile_tier_levels);\n\t\tif (ptl) {\n\t\t\tlhvc->profile_space  = ptl->general_profile_space;\n\t\t\tlhvc->tier_flag = ptl->general_tier_flag;\n\t\t\tlhvc->profile_idc = ptl->general_profile_idc;\n\t\t\tlhvc->general_profile_compatibility_flags = ptl->general_profile_compatibility_flags;\n\t\t\tlhvc->constraint_indicator_flags = ptl->general_constraint_indicator_flags;\n\t\t}\n\t}\n\treturn lhvc;\n}\n\n\nvoid btrt_box_del(GF_Box *s)\n{\n\tGF_BitRateBox *ptr = (GF_BitRateBox *)s;\n\tif (ptr) gf_free(ptr);\n}\nGF_Err btrt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_BitRateBox *ptr = (GF_BitRateBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 12)\n\tptr->bufferSizeDB = gf_bs_read_u32(bs);\n\tptr->maxBitrate = gf_bs_read_u32(bs);\n\tptr->avgBitrate = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *btrt_box_new()\n{\n\tGF_BitRateBox *tmp = (GF_BitRateBox *) gf_malloc(sizeof(GF_BitRateBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_BitRateBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_BTRT;\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err btrt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_BitRateBox *ptr = (GF_BitRateBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->bufferSizeDB);\n\tgf_bs_write_u32(bs, ptr->maxBitrate);\n\tgf_bs_write_u32(bs, ptr->avgBitrate);\n\treturn GF_OK;\n}\nGF_Err btrt_box_size(GF_Box *s)\n{\n\tGF_BitRateBox *ptr = (GF_BitRateBox *)s;\n\tptr->size += 12;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid m4ds_box_del(GF_Box *s)\n{\n\tGF_MPEG4ExtensionDescriptorsBox *ptr = (GF_MPEG4ExtensionDescriptorsBox *)s;\n\tgf_odf_desc_list_del(ptr->descriptors);\n\tgf_list_del(ptr->descriptors);\n\tgf_free(ptr);\n}\nGF_Err m4ds_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tchar *enc_od;\n\tGF_MPEG4ExtensionDescriptorsBox *ptr = (GF_MPEG4ExtensionDescriptorsBox *)s;\n\tu32 od_size = (u32) ptr->size;\n\tif (!od_size) return GF_OK;\n\tenc_od = (char *)gf_malloc(sizeof(char) * od_size);\n\tgf_bs_read_data(bs, enc_od, od_size);\n\te = gf_odf_desc_list_read((char *)enc_od, od_size, ptr->descriptors);\n\tgf_free(enc_od);\n\treturn e;\n}\nGF_Box *m4ds_box_new()\n{\n\tGF_MPEG4ExtensionDescriptorsBox *tmp = (GF_MPEG4ExtensionDescriptorsBox *) gf_malloc(sizeof(GF_MPEG4ExtensionDescriptorsBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_MPEG4ExtensionDescriptorsBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_M4DS;\n\ttmp->descriptors = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err m4ds_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu8 *enc_ods;\n\tu32 enc_od_size;\n\tGF_MPEG4ExtensionDescriptorsBox *ptr = (GF_MPEG4ExtensionDescriptorsBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tenc_ods = NULL;\n\tenc_od_size = 0;\n\te = gf_odf_desc_list_write(ptr->descriptors, &enc_ods, &enc_od_size);\n\tif (e) return e;\n\tif (enc_od_size) {\n\t\tgf_bs_write_data(bs, enc_ods, enc_od_size);\n\t\tgf_free(enc_ods);\n\t}\n\treturn GF_OK;\n}\nGF_Err m4ds_box_size(GF_Box *s)\n{\n\tGF_Err e;\n\tu32 descSize = 0;\n\tGF_MPEG4ExtensionDescriptorsBox *ptr = (GF_MPEG4ExtensionDescriptorsBox *)s;\n\te = gf_odf_desc_list_size(ptr->descriptors, &descSize);\n\tptr->size += descSize;\n\treturn e;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid avcc_box_del(GF_Box *s)\n{\n\tGF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *)s;\n\tif (ptr->config) gf_odf_avc_cfg_del(ptr->config);\n\tptr->config = NULL;\n\tgf_free(ptr);\n}\n\nGF_Err avcc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, count;\n\tGF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *)s;\n\n\tif (ptr->config) gf_odf_avc_cfg_del(ptr->config);\n\tptr->config = gf_odf_avc_cfg_new();\n\n\tISOM_DECREASE_SIZE(ptr, 7) //7 includes the 2 counts of sps and pps\n\n\tBool is_avcc;\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_AVCC) || (ptr->type==GF_ISOM_BOX_TYPE_AVCE))\n\t\tis_avcc = GF_TRUE;\n\telse\n\t\tis_avcc = GF_FALSE;\n\n\t//we don't use gf_odf_avc_cfg_read to deal with missing rext profile signaling on many files\n\tptr->config->configurationVersion = gf_bs_read_u8(bs);\n\tptr->config->AVCProfileIndication = gf_bs_read_u8(bs);\n\tptr->config->profile_compatibility = gf_bs_read_u8(bs);\n\tptr->config->AVCLevelIndication = gf_bs_read_u8(bs);\n\tif (is_avcc) {\n\t\tgf_bs_read_int(bs, 6);\n\t} else {\n\t\tptr->config->complete_representation = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 5);\n\t}\n\tptr->config->nal_unit_size = 1 + gf_bs_read_int(bs, 2);\n\tgf_bs_read_int(bs, 3);\n\tcount = gf_bs_read_int(bs, 5);\n\n\tfor (i=0; i<count; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *) gf_malloc(sizeof(GF_NALUFFParam));\n\t\tsl->size = gf_bs_read_u16(bs);\n\t\tif (!sl->size || (gf_bs_available(bs) < sl->size) || (ptr->size < sl->size) ) {\n\t\t\tgf_free(sl);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"AVCC: Not enough bits to parse. Aborting.\\n\"));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tsl->data = (char *)gf_malloc(sizeof(char) * sl->size);\n\t\tgf_bs_read_data(bs, sl->data, sl->size);\n\t\tgf_list_add(ptr->config->sequenceParameterSets, sl);\n\t\tptr->size -= sl->size;\n\t}\n\n\tcount = gf_bs_read_u8(bs);\n\tfor (i=0; i<count; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_malloc(sizeof(GF_NALUFFParam));\n\t\tsl->size = gf_bs_read_u16(bs);\n\t\tif (!sl->size || (gf_bs_available(bs) < sl->size) || (ptr->size<sl->size)) {\n\t\t\tgf_free(sl);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"AVCC: Not enough bits to parse. Aborting.\\n\"));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tsl->data = (char *)gf_malloc(sizeof(char) * sl->size);\n\t\tgf_bs_read_data(bs, sl->data, sl->size);\n\t\tgf_list_add(ptr->config->pictureParameterSets, sl);\n\t\tptr->size -= sl->size;\n\t}\n\n\t//not avcC (svcC; mvcC), no check for rext signaling\n\tif (!is_avcc)\n\t\treturn GF_OK;\n\n\t//not REXT profile, no check for rext signaling\n\tif (!gf_avcc_use_extensions(ptr->config->AVCProfileIndication))\n\t\treturn GF_OK;\n\n\t//non-compliant file (rext signaling missing), try to fill in values from SPS\n\tif (!ptr->size) {\n\t\t/*set default values ...*/\n\t\tptr->config->chroma_format = 1;\n\t\tptr->config->luma_bit_depth = 8;\n\t\tptr->config->chroma_bit_depth = 8;\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam*)gf_list_get(ptr->config->sequenceParameterSets, 0);\n\t\tif (sl) {\n\t\t\tAVCState avc;\n\t\t\ts32 idx;\n\t\t\tmemset(&avc, 0, sizeof(AVCState));\n\t\t\tidx = gf_avc_read_sps(sl->data, sl->size, &avc, 0, NULL);\n\t\t\tif (idx>=0) {\n\t\t\t\tptr->config->chroma_format = avc.sps[idx].chroma_format;\n\t\t\t\tptr->config->luma_bit_depth = 8 + avc.sps[idx].luma_bit_depth_m8;\n\t\t\t\tptr->config->chroma_bit_depth = 8 + avc.sps[idx].chroma_bit_depth_m8;\n\t\t\t}\n\t\t}\n#endif\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[isom/avcc] Missing REXT profile signaling, patching.\\n\"));\n\t\treturn GF_OK;\n\t}\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tgf_bs_read_int(bs, 6);\n\tptr->config->chroma_format = gf_bs_read_int(bs, 2);\n\tgf_bs_read_int(bs, 5);\n\tptr->config->luma_bit_depth = 8 + gf_bs_read_int(bs, 3);\n\tgf_bs_read_int(bs, 5);\n\tptr->config->chroma_bit_depth = 8 + gf_bs_read_int(bs, 3);\n\n\tcount = gf_bs_read_int(bs, 8);\n\tif (count*2 > ptr->size) {\n\t\t//ffmpeg just ignores this part while allocating bytes (filled with garbage?)\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"AVCC: invalid numOfSequenceParameterSetExt value. Skipping.\\n\"));\n\t\treturn GF_OK;\n\t}\n\tif (count) {\n\t\tptr->config->sequenceParameterSetExtensions = gf_list_new();\n\t\tfor (i=0; i<count; i++) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_malloc(sizeof(GF_NALUFFParam));\n\t\t\tsl->size = gf_bs_read_u16(bs);\n\t\t\tif ((gf_bs_available(bs) < sl->size) || (ptr->size<sl->size)) {\n\t\t\t\tgf_free(sl);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"AVCC: Not enough bits to parse. Aborting.\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tsl->data = (char *)gf_malloc(sizeof(char) * sl->size);\n\t\t\tgf_bs_read_data(bs, sl->data, sl->size);\n\t\t\tgf_list_add(ptr->config->sequenceParameterSetExtensions, sl);\n\t\t\tptr->size -= sl->size;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *avcc_box_new()\n{\n\tGF_AVCConfigurationBox *tmp = (GF_AVCConfigurationBox *) gf_malloc(sizeof(GF_AVCConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_AVCConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_AVCC;\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err avcc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, count;\n\tGF_Err e;\n\tGF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (!ptr->config) return GF_OK;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tBool is_avcc;\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_AVCC) || (ptr->type==GF_ISOM_BOX_TYPE_AVCE))\n\t\tis_avcc = GF_TRUE;\n\telse\n\t\tis_avcc = GF_FALSE;\n\n\tgf_bs_write_u8(bs, ptr->config->configurationVersion);\n\tgf_bs_write_u8(bs, ptr->config->AVCProfileIndication);\n\tgf_bs_write_u8(bs, ptr->config->profile_compatibility);\n\tgf_bs_write_u8(bs, ptr->config->AVCLevelIndication);\n\tif (is_avcc) {\n\t\tgf_bs_write_int(bs, 0x3F, 6);\n\t} else {\n\t\tgf_bs_write_int(bs, ptr->config->complete_representation, 1);\n\t\tgf_bs_write_int(bs, 0x1F, 5);\n\t}\n\tgf_bs_write_int(bs, ptr->config->nal_unit_size - 1, 2);\n\tgf_bs_write_int(bs, 0x7, 3);\n\tcount = gf_list_count(ptr->config->sequenceParameterSets);\n\tgf_bs_write_int(bs, count, 5);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *) gf_list_get(ptr->config->sequenceParameterSets, i);\n\t\tgf_bs_write_u16(bs, sl->size);\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n\n\tcount = gf_list_count(ptr->config->pictureParameterSets);\n\tgf_bs_write_u8(bs, count);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *) gf_list_get(ptr->config->pictureParameterSets, i);\n\t\tgf_bs_write_u16(bs, sl->size);\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n\n\n\tif (is_avcc) {\n\t\tif (gf_avcc_use_extensions(ptr->config->AVCProfileIndication)) {\n\t\t\tgf_bs_write_int(bs, 0xFF, 6);\n\t\t\tgf_bs_write_int(bs, ptr->config->chroma_format, 2);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, ptr->config->luma_bit_depth - 8, 3);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, ptr->config->chroma_bit_depth - 8, 3);\n\n\t\t\tcount = ptr->config->sequenceParameterSetExtensions ? gf_list_count(ptr->config->sequenceParameterSetExtensions) : 0;\n\t\t\tgf_bs_write_u8(bs, count);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *) gf_list_get(ptr->config->sequenceParameterSetExtensions, i);\n\t\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\nGF_Err avcc_box_size(GF_Box *s)\n{\n\tu32 i, count;\n\tGF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *)s;\n\n\tif (!ptr->config) {\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\tptr->size += 7;\n\tcount = gf_list_count(ptr->config->sequenceParameterSets);\n\tfor (i=0; i<count; i++)\n\t\tptr->size += 2 + ((GF_NALUFFParam *)gf_list_get(ptr->config->sequenceParameterSets, i))->size;\n\n\tcount = gf_list_count(ptr->config->pictureParameterSets);\n\tfor (i=0; i<count; i++)\n\t\tptr->size += 2 + ((GF_NALUFFParam *)gf_list_get(ptr->config->pictureParameterSets, i))->size;\n\n\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_AVCC) || (ptr->type==GF_ISOM_BOX_TYPE_AVCE)) {\n\t\tif (gf_avcc_use_extensions(ptr->config->AVCProfileIndication)) {\n\t\t\tptr->size += 4;\n\t\t\tcount = ptr->config->sequenceParameterSetExtensions ?gf_list_count(ptr->config->sequenceParameterSetExtensions) : 0;\n\t\t\tfor (i=0; i<count; i++)\n\t\t\t\tptr->size += 2 + ((GF_NALUFFParam *)gf_list_get(ptr->config->sequenceParameterSetExtensions, i))->size;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid hvcc_box_del(GF_Box *s)\n{\n\tGF_HEVCConfigurationBox *ptr = (GF_HEVCConfigurationBox*)s;\n\tif (ptr->config) gf_odf_hevc_cfg_del(ptr->config);\n\tgf_free(ptr);\n}\n\nGF_Err hvcc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu64 consumed;\n\tGF_HEVCConfigurationBox *ptr = (GF_HEVCConfigurationBox *)s;\n\n\tif (ptr->config) gf_odf_hevc_cfg_del(ptr->config);\n\n\tconsumed = gf_bs_get_position(bs);\n\tswitch (s->type) {\n\tcase GF_ISOM_BOX_TYPE_HVCC:\n\tcase GF_ISOM_BOX_TYPE_HVCE:\n\t\tptr->config = gf_odf_hevc_cfg_read_bs(bs, GF_FALSE);\n\t\tbreak;\n\tdefault:\n\t\tptr->config = gf_odf_hevc_cfg_read_bs(bs, GF_TRUE);\n\t\tbreak;\n\t}\n\tconsumed = gf_bs_get_position(bs) - consumed ;\n\tISOM_DECREASE_SIZE(ptr, (u32)consumed)\n\n\treturn ptr->config ? GF_OK : GF_ISOM_INVALID_FILE;\n}\n\nGF_Box *hvcc_box_new()\n{\n\tGF_HEVCConfigurationBox *tmp = (GF_HEVCConfigurationBox *) gf_malloc(sizeof(GF_HEVCConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_HEVCConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_HVCC;\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err hvcc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HEVCConfigurationBox *ptr = (GF_HEVCConfigurationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (!ptr->config) return GF_OK;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\treturn gf_odf_hevc_cfg_write_bs(ptr->config, bs);\n}\n\nGF_Err hvcc_box_size(GF_Box *s)\n{\n\tu32 i, count, j, subcount;\n\tGF_HEVCConfigurationBox *ptr = (GF_HEVCConfigurationBox *)s;\n\n\tif (!ptr->config) {\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\n\tif (!ptr->config->is_lhvc)\n\t\tptr->size += 23;\n\telse\n\t\tptr->size += 6;\n\n\tcount = gf_list_count(ptr->config->param_array);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParamArray *ar = (GF_NALUFFParamArray*)gf_list_get(ptr->config->param_array, i);\n\t\tptr->size += 3;\n\t\tsubcount = gf_list_count(ar->nalus);\n\t\tfor (j=0; j<subcount; j++) {\n\t\t\tptr->size += 2 + ((GF_NALUFFParam *)gf_list_get(ar->nalus, j))->size;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\n\nvoid vvcc_box_del(GF_Box *s)\n{\n\tGF_VVCConfigurationBox *ptr = (GF_VVCConfigurationBox*)s;\n\tif (ptr->config) gf_odf_vvc_cfg_del(ptr->config);\n\tgf_free(ptr);\n}\n\nGF_Err vvcc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu64 consumed;\n\tGF_VVCConfigurationBox *ptr = (GF_VVCConfigurationBox *)s;\n\n\tif (ptr->config) gf_odf_vvc_cfg_del(ptr->config);\n\n\tconsumed = gf_bs_get_position(bs);\n\tptr->config = gf_odf_vvc_cfg_read_bs(bs);\n\tconsumed = gf_bs_get_position(bs) - consumed ;\n\tISOM_DECREASE_SIZE(ptr, (u32)consumed)\n\n\treturn ptr->config ? GF_OK : GF_ISOM_INVALID_FILE;\n}\n\nGF_Box *vvcc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_VVCConfigurationBox, GF_ISOM_BOX_TYPE_VVCC);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err vvcc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_VVCConfigurationBox *ptr = (GF_VVCConfigurationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (!ptr->config) return GF_OK;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\treturn gf_odf_vvc_cfg_write_bs(ptr->config, bs);\n}\n\nGF_Err vvcc_box_size(GF_Box *s)\n{\n\tu32 i, count, j, subcount;\n\tGF_VVCConfigurationBox *ptr = (GF_VVCConfigurationBox *)s;\n\n\tif (!ptr->config) {\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\n\tptr->size += 1;\n\tif (ptr->config->ptl_present) {\n\t\tptr->size += 3;\n\t\t//size PTL\n\t\tif (!ptr->config->general_constraint_info)\n\t\t\tptr->config->num_constraint_info = 0;\n\t\tif (!ptr->config->sub_profiles_idc)\n\t\t\tptr->config->num_sub_profiles = 0;\n\n\t\tptr->size += 3 + ptr->config->num_constraint_info;\n\t\tif (ptr->config->numTemporalLayers>1)\n\t\t\tptr->size += 1;\n\t\tfor (i=0; i<ptr->config->numTemporalLayers; i++) {\n\t\t\tif (ptr->config->ptl_sublayer_present_mask & (1<<i))\n\t\t\t\tptr->size+=1;\n\t\t}\n\t\tptr->size += 1 + ptr->config->num_sub_profiles*4;\n\t\t//end size PTL\n\t\tptr->size += 6;\n\t}\n\n\tptr->size += 1;\n\tcount = gf_list_count(ptr->config->param_array);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParamArray *ar = (GF_NALUFFParamArray*)gf_list_get(ptr->config->param_array, i);\n\t\tif ((ar->type != GF_VVC_NALU_DEC_PARAM) && (ar->type != GF_VVC_NALU_OPI))\n\t\t\tptr->size += 3;\n\t\telse\n\t\t\tptr->size += 1;\n\n\t\tsubcount = gf_list_count(ar->nalus);\n\t\tfor (j=0; j<subcount; j++) {\n\t\t\tptr->size += 2 + ((GF_NALUFFParam *)gf_list_get(ar->nalus, j))->size;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif\n\n\nvoid vvnc_box_del(GF_Box *s)\n{\n\tGF_VVCNaluConfigurationBox *ptr = (GF_VVCNaluConfigurationBox*)s;\n\tgf_free(ptr);\n}\n\nGF_Err vvnc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_VVCNaluConfigurationBox *ptr = (GF_VVCNaluConfigurationBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tgf_bs_read_int(bs, 6);\n\tptr->nal_unit_size = 1 + gf_bs_read_int(bs, 2);\n\treturn GF_OK;\n}\n\nGF_Box *vvnc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_VVCNaluConfigurationBox, GF_ISOM_BOX_TYPE_VVNC);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err vvnc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_VVCNaluConfigurationBox *ptr = (GF_VVCNaluConfigurationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, 0, 6);\n\tgf_bs_write_int(bs, ptr->nal_unit_size-1, 2);\n\treturn GF_OK;\n}\n\nGF_Err vvnc_box_size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n#endif\n\nGF_Box *av1c_box_new() {\n\tGF_AV1ConfigurationBox *tmp = (GF_AV1ConfigurationBox *)gf_malloc(sizeof(GF_AV1ConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_AV1ConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_AV1C;\n\treturn (GF_Box *)tmp;\n}\n\nvoid av1c_box_del(GF_Box *s) {\n\tGF_AV1ConfigurationBox *ptr = (GF_AV1ConfigurationBox*)s;\n\tif (ptr->config) gf_odf_av1_cfg_del(ptr->config);\n\tgf_free(ptr);\n}\n\nGF_Err av1c_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu64 pos, read;\n\tGF_AV1ConfigurationBox *ptr = (GF_AV1ConfigurationBox*)s;\n\n\tif (ptr->config) gf_odf_av1_cfg_del(ptr->config);\n\n\tpos = gf_bs_get_position(bs);\n\n\tptr->config = gf_odf_av1_cfg_read_bs_size(bs, (u32) ptr->size);\n\n\tread = gf_bs_get_position(bs) - pos;\n\n\tif (read < ptr->size)\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[ISOBMFF] AV1ConfigurationBox: read only \"LLU\" bytes (expected \"LLU\").\\n\", read, ptr->size));\n\tif (read > ptr->size)\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] AV1ConfigurationBox overflow read \"LLU\" bytes, of box size \"LLU\".\\n\", read, ptr->size));\n\n\treturn GF_OK;\n}\n\nGF_Err av1c_box_write(GF_Box *s, GF_BitStream *bs) {\n\tGF_Err e;\n\tGF_AV1ConfigurationBox *ptr = (GF_AV1ConfigurationBox*)s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (!ptr->config) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\treturn gf_odf_av1_cfg_write_bs(ptr->config, bs);\n}\n\nGF_Err av1c_box_size(GF_Box *s) {\n\tu32 i;\n\tGF_AV1ConfigurationBox *ptr = (GF_AV1ConfigurationBox *)s;\n\n\tif (!ptr->config) {\n\t\tptr->size = 0;\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tptr->size += 4;\n\n\tfor (i = 0; i < gf_list_count(ptr->config->obu_array); ++i) {\n\t\tGF_AV1_OBUArrayEntry *a = gf_list_get(ptr->config->obu_array, i);\n\t\tptr->size += a->obu_length;\n\t}\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nvoid vpcc_box_del(GF_Box *s)\n{\n\tGF_VPConfigurationBox *ptr = (GF_VPConfigurationBox*)s;\n\tif (ptr->config) gf_odf_vp_cfg_del(ptr->config);\n\tptr->config = NULL;\n\tgf_free(ptr);\n}\n\nGF_Err vpcc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu64 pos;\n\tGF_VPConfigurationBox *ptr = (GF_VPConfigurationBox *)s;\n\n\tif (ptr->config) gf_odf_vp_cfg_del(ptr->config);\n\tptr->config = NULL;\n\n\tpos = gf_bs_get_position(bs);\n\tptr->config = gf_odf_vp_cfg_read_bs(bs, ptr->version == 0);\n\tpos = gf_bs_get_position(bs) - pos ;\n\n\tif (pos < ptr->size)\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[ISOBMFF] VPConfigurationBox: read only \"LLU\" bytes (expected \"LLU\").\\n\", pos, ptr->size));\n\tif (pos > ptr->size)\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] VPConfigurationBox overflow read \"LLU\" bytes, of box size \"LLU\".\\n\", pos, ptr->size));\n\n\treturn ptr->config ? GF_OK : GF_ISOM_INVALID_FILE;\n}\n\nGF_Box *vpcc_box_new()\n{\n\tGF_VPConfigurationBox *tmp = (GF_VPConfigurationBox *) gf_malloc(sizeof(GF_VPConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_VPConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_VPCC;\n\ttmp->version = 1;\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err vpcc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_VPConfigurationBox *ptr = (GF_VPConfigurationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (!ptr->config) return GF_OK;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\treturn gf_odf_vp_cfg_write_bs(ptr->config, bs, ptr->version == 0);\n}\n#endif\n\nGF_Err vpcc_box_size(GF_Box *s)\n{\n\tGF_VPConfigurationBox *ptr = (GF_VPConfigurationBox *)s;\n\n\tif (!ptr->config) {\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\n\tif (ptr->version == 0) {\n\t\tptr->size += 6;\n\t} else {\n\t\tif (ptr->config->codec_initdata_size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] VPConfigurationBox: codec_initdata_size MUST be 0, was %d\\n\", ptr->config->codec_initdata_size));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\tptr->size += 8;\n\t}\n\n\treturn GF_OK;\n}\n\n\nGF_Box *SmDm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SMPTE2086MasteringDisplayMetadataBox, GF_ISOM_BOX_TYPE_SMDM);\n\treturn (GF_Box *)tmp;\n}\n\nvoid SmDm_box_del(GF_Box *a)\n{\n\tGF_SMPTE2086MasteringDisplayMetadataBox *p = (GF_SMPTE2086MasteringDisplayMetadataBox *)a;\n\tgf_free(p);\n}\n\nGF_Err SmDm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SMPTE2086MasteringDisplayMetadataBox *p = (GF_SMPTE2086MasteringDisplayMetadataBox *)s;\n\tISOM_DECREASE_SIZE(p, 24)\n\tp->primaryRChromaticity_x = gf_bs_read_u16(bs);\n\tp->primaryRChromaticity_y = gf_bs_read_u16(bs);\n\tp->primaryGChromaticity_x = gf_bs_read_u16(bs);\n\tp->primaryGChromaticity_y = gf_bs_read_u16(bs);\n\tp->primaryBChromaticity_x = gf_bs_read_u16(bs);\n\tp->primaryBChromaticity_y = gf_bs_read_u16(bs);\n\tp->whitePointChromaticity_x = gf_bs_read_u16(bs);\n\tp->whitePointChromaticity_y = gf_bs_read_u16(bs);\n\tp->luminanceMax = gf_bs_read_u32(bs);\n\tp->luminanceMin = gf_bs_read_u32(bs);\n\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err SmDm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SMPTE2086MasteringDisplayMetadataBox *p = (GF_SMPTE2086MasteringDisplayMetadataBox*)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, p->primaryRChromaticity_x);\n\tgf_bs_write_u16(bs, p->primaryRChromaticity_y);\n\tgf_bs_write_u16(bs, p->primaryGChromaticity_x);\n\tgf_bs_write_u16(bs, p->primaryGChromaticity_y);\n\tgf_bs_write_u16(bs, p->primaryBChromaticity_x);\n\tgf_bs_write_u16(bs, p->primaryBChromaticity_y);\n\tgf_bs_write_u16(bs, p->whitePointChromaticity_x);\n\tgf_bs_write_u16(bs, p->whitePointChromaticity_y);\n\tgf_bs_write_u32(bs, p->luminanceMax);\n\tgf_bs_write_u32(bs, p->luminanceMin);\n\n\treturn GF_OK;\n}\n\nGF_Err SmDm_box_size(GF_Box *s)\n{\n\tGF_SMPTE2086MasteringDisplayMetadataBox *p = (GF_SMPTE2086MasteringDisplayMetadataBox*)s;\n\tp->size += 24;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *CoLL_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_VPContentLightLevelBox, GF_ISOM_BOX_TYPE_COLL);\n\treturn (GF_Box *)tmp;\n}\n\nvoid CoLL_box_del(GF_Box *a)\n{\n\tGF_VPContentLightLevelBox *p = (GF_VPContentLightLevelBox *)a;\n\tgf_free(p);\n}\n\nGF_Err CoLL_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_VPContentLightLevelBox *p = (GF_VPContentLightLevelBox *)s;\n\tISOM_DECREASE_SIZE(p, 4)\n\tp->maxCLL = gf_bs_read_u16(bs);\n\tp->maxFALL = gf_bs_read_u16(bs);\n\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err CoLL_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_VPContentLightLevelBox *p = (GF_VPContentLightLevelBox*)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, p->maxCLL);\n\tgf_bs_write_u16(bs, p->maxFALL);\n\n\treturn GF_OK;\n}\n\nGF_Err CoLL_box_size(GF_Box *s)\n{\n\tGF_VPContentLightLevelBox *p = (GF_VPContentLightLevelBox*)s;\n\tp->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_OperatingPointsInformation *gf_isom_oinf_new_entry()\n{\n\tGF_OperatingPointsInformation* ptr;\n\tGF_SAFEALLOC(ptr, GF_OperatingPointsInformation);\n\tif (ptr) {\n\t\tptr->profile_tier_levels = gf_list_new();\n\t\tptr->operating_points = gf_list_new();\n\t\tptr->dependency_layers = gf_list_new();\n\t}\n\treturn ptr;\n\n}\n\nvoid gf_isom_oinf_del_entry(void *entry)\n{\n\tGF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;\n\tif (!ptr) return;\n\tif (ptr->profile_tier_levels) {\n\t\twhile (gf_list_count(ptr->profile_tier_levels)) {\n\t\t\tLHEVC_ProfileTierLevel *ptl = (LHEVC_ProfileTierLevel *)gf_list_get(ptr->profile_tier_levels, 0);\n\t\t\tgf_free(ptl);\n\t\t\tgf_list_rem(ptr->profile_tier_levels, 0);\n\t\t}\n\t\tgf_list_del(ptr->profile_tier_levels);\n\t}\n\tif (ptr->operating_points) {\n\t\twhile (gf_list_count(ptr->operating_points)) {\n\t\t\tLHEVC_OperatingPoint *op = (LHEVC_OperatingPoint *)gf_list_get(ptr->operating_points, 0);\n\t\t\tgf_free(op);\n\t\t\tgf_list_rem(ptr->operating_points, 0);\n\t\t}\n\t\tgf_list_del(ptr->operating_points);\n\t}\n\tif (ptr->dependency_layers) {\n\t\twhile (gf_list_count(ptr->dependency_layers)) {\n\t\t\tLHEVC_DependentLayer *dep = (LHEVC_DependentLayer *)gf_list_get(ptr->dependency_layers, 0);\n\t\t\tgf_free(dep);\n\t\t\tgf_list_rem(ptr->dependency_layers, 0);\n\t\t}\n\t\tgf_list_del(ptr->dependency_layers);\n\t}\n\tgf_free(ptr);\n\treturn;\n}\n\nGF_Err gf_isom_oinf_read_entry(void *entry, GF_BitStream *bs)\n{\n\tGF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;\n\tu32 i, j, count;\n\n\tif (!ptr) return GF_BAD_PARAM;\n\tptr->scalability_mask = gf_bs_read_u16(bs);\n\tgf_bs_read_int(bs, 2);//reserved\n\tcount = gf_bs_read_int(bs, 6);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_ProfileTierLevel *ptl;\n\t\tGF_SAFEALLOC(ptl, LHEVC_ProfileTierLevel);\n\t\tif (!ptl) return GF_OUT_OF_MEM;\n\t\tptl->general_profile_space = gf_bs_read_int(bs, 2);\n\t\tptl->general_tier_flag= gf_bs_read_int(bs, 1);\n\t\tptl->general_profile_idc = gf_bs_read_int(bs, 5);\n\t\tptl->general_profile_compatibility_flags = gf_bs_read_u32(bs);\n\t\tptl->general_constraint_indicator_flags = gf_bs_read_long_int(bs, 48);\n\t\tptl->general_level_idc = gf_bs_read_u8(bs);\n\t\tgf_list_add(ptr->profile_tier_levels, ptl);\n\t}\n\tcount = gf_bs_read_u16(bs);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_OperatingPoint *op;\n\t\tGF_SAFEALLOC(op, LHEVC_OperatingPoint);\n\t\tif (!op) return GF_OUT_OF_MEM;\n\t\top->output_layer_set_idx = gf_bs_read_u16(bs);\n\t\top->max_temporal_id = gf_bs_read_u8(bs);\n\t\top->layer_count = gf_bs_read_u8(bs);\n\t\tif (op->layer_count > GF_ARRAY_LENGTH(op->layers_info)) {\n\t\t\tgf_free(op);\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tfor (j = 0; j < op->layer_count; j++) {\n\t\t\top->layers_info[j].ptl_idx = gf_bs_read_u8(bs);\n\t\t\top->layers_info[j].layer_id = gf_bs_read_int(bs, 6);\n\t\t\top->layers_info[j].is_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\t\top->layers_info[j].is_alternate_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\n\t\t\tif (gf_bs_is_overflow(bs)) {\n\t\t\t\tgf_free(op);\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t}\n\t\top->minPicWidth = gf_bs_read_u16(bs);\n\t\top->minPicHeight = gf_bs_read_u16(bs);\n\t\top->maxPicWidth = gf_bs_read_u16(bs);\n\t\top->maxPicHeight = gf_bs_read_u16(bs);\n\t\top->maxChromaFormat = gf_bs_read_int(bs, 2);\n\t\top->maxBitDepth = gf_bs_read_int(bs, 3) + 8;\n\t\tgf_bs_read_int(bs, 1);//reserved\n\t\top->frame_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\top->bit_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\tif (op->frame_rate_info_flag) {\n\t\t\top->avgFrameRate = gf_bs_read_u16(bs);\n\t\t\tgf_bs_read_int(bs, 6); //reserved\n\t\t\top->constantFrameRate = gf_bs_read_int(bs, 2);\n\t\t}\n\t\tif (op->bit_rate_info_flag) {\n\t\t\top->maxBitRate = gf_bs_read_u32(bs);\n\t\t\top->avgBitRate = gf_bs_read_u32(bs);\n\t\t}\n\t\tif (gf_bs_is_overflow(bs)) {\n\t\t\tgf_free(op);\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tgf_list_add(ptr->operating_points, op);\n\t}\n\tcount = gf_bs_read_u8(bs);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_DependentLayer *dep;\n\t\tGF_SAFEALLOC(dep, LHEVC_DependentLayer);\n\t\tif (!dep) return GF_OUT_OF_MEM;\n\t\tdep->dependent_layerID = gf_bs_read_u8(bs);\n\t\tdep->num_layers_dependent_on = gf_bs_read_u8(bs);\n\t\tif (dep->num_layers_dependent_on > GF_ARRAY_LENGTH(dep->dependent_on_layerID)) {\n\t\t\tgf_free(dep);\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tfor (j = 0; j < dep->num_layers_dependent_on; j++)\n\t\t\tdep->dependent_on_layerID[j] = gf_bs_read_u8(bs);\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tif (ptr->scalability_mask & (1 << j))\n\t\t\t\tdep->dimension_identifier[j] = gf_bs_read_u8(bs);\n\t\t}\n\t\tif (gf_bs_is_overflow(bs)) {\n\t\t\tgf_free(dep);\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tgf_list_add(ptr->dependency_layers, dep);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_oinf_write_entry(void *entry, GF_BitStream *bs)\n{\n\tGF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;\n\tu32 i, j, count;\n\tif (!ptr) return GF_OK;\n\n\tgf_bs_write_u16(bs, ptr->scalability_mask);\n\tgf_bs_write_int(bs, 0xFF, 2);//reserved\n\tcount=gf_list_count(ptr->profile_tier_levels);\n\tgf_bs_write_int(bs, count, 6);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_ProfileTierLevel *ptl = (LHEVC_ProfileTierLevel *)gf_list_get(ptr->profile_tier_levels, i);\n\t\tgf_bs_write_int(bs, ptl->general_profile_space, 2);\n\t\tgf_bs_write_int(bs, ptl->general_tier_flag, 1);\n\t\tgf_bs_write_int(bs, ptl->general_profile_idc, 5);\n\t\tgf_bs_write_u32(bs, ptl->general_profile_compatibility_flags);\n\t\tgf_bs_write_long_int(bs, ptl->general_constraint_indicator_flags, 48);\n\t\tgf_bs_write_u8(bs, ptl->general_level_idc);\n\t}\n\tcount=gf_list_count(ptr->operating_points);\n\tgf_bs_write_u16(bs, count);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_OperatingPoint *op = (LHEVC_OperatingPoint *)gf_list_get(ptr->operating_points, i);\n\t\tgf_bs_write_u16(bs, op->output_layer_set_idx);\n\t\tgf_bs_write_u8(bs, op->max_temporal_id);\n\t\tgf_bs_write_u8(bs, op->layer_count);\n\t\tfor (j = 0; j < op->layer_count; j++) {\n\t\t\tgf_bs_write_u8(bs, op->layers_info[j].ptl_idx);\n\t\t\tgf_bs_write_int(bs, op->layers_info[j].layer_id, 6);\n\t\t\top->layers_info[j].is_outputlayer ? gf_bs_write_int(bs, 0x1, 1)  : gf_bs_write_int(bs, 0x0, 1);\n\t\t\top->layers_info[j].is_alternate_outputlayer ? gf_bs_write_int(bs, 0x1, 1)  : gf_bs_write_int(bs, 0x0, 1);\n\t\t}\n\t\tgf_bs_write_u16(bs, op->minPicWidth);\n\t\tgf_bs_write_u16(bs, op->minPicHeight);\n\t\tgf_bs_write_u16(bs, op->maxPicWidth);\n\t\tgf_bs_write_u16(bs, op->maxPicHeight);\n\t\tgf_bs_write_int(bs, op->maxChromaFormat, 2);\n\t\tgf_bs_write_int(bs, op->maxBitDepth - 8, 3);\n\t\tgf_bs_write_int(bs, 0x1, 1);//resereved\n\t\top->frame_rate_info_flag ? gf_bs_write_int(bs, 0x1, 1)  : gf_bs_write_int(bs, 0x0, 1);\n\t\top->bit_rate_info_flag ? gf_bs_write_int(bs, 0x1, 1)  : gf_bs_write_int(bs, 0x0, 1);\n\t\tif (op->frame_rate_info_flag) {\n\t\t\tgf_bs_write_u16(bs, op->avgFrameRate);\n\t\t\tgf_bs_write_int(bs, 0xFF, 6); //reserved\n\t\t\tgf_bs_write_int(bs, op->constantFrameRate, 2);\n\t\t}\n\t\tif (op->bit_rate_info_flag) {\n\t\t\tgf_bs_write_u32(bs, op->maxBitRate);\n\t\t\tgf_bs_write_u32(bs, op->avgBitRate);\n\t\t}\n\t}\n\tcount=gf_list_count(ptr->dependency_layers);\n\tgf_bs_write_u8(bs, count);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_DependentLayer *dep = (LHEVC_DependentLayer *)gf_list_get(ptr->dependency_layers, i);\n\t\tgf_bs_write_u8(bs, dep->dependent_layerID);\n\t\tgf_bs_write_u8(bs, dep->num_layers_dependent_on);\n\t\tfor (j = 0; j < dep->num_layers_dependent_on; j++)\n\t\t\tgf_bs_write_u8(bs, dep->dependent_on_layerID[j]);\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tif (ptr->scalability_mask & (1 << j))\n\t\t\t\tgf_bs_write_u8(bs, dep->dimension_identifier[j]);\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\nu32 gf_isom_oinf_size_entry(void *entry)\n{\n\tGF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;\n\tu32 size = 0, i ,j, count;\n\tif (!ptr) return 0;\n\n\tsize += 3; //scalability_mask + reserved + num_profile_tier_level\n\tcount=gf_list_count(ptr->profile_tier_levels);\n\tsize += count * 12; //general_profile_space + general_tier_flag + general_profile_idc + general_profile_compatibility_flags + general_constraint_indicator_flags + general_level_idc\n\tsize += 2;//num_operating_points\n\tcount=gf_list_count(ptr->operating_points);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_OperatingPoint *op = (LHEVC_OperatingPoint *)gf_list_get(ptr->operating_points, i);\n\t\tsize += 2/*output_layer_set_idx*/ + 1/*max_temporal_id*/ + 1/*layer_count*/;\n\t\tsize += op->layer_count * 2;\n\t\tsize += 9;\n\t\tif (op->frame_rate_info_flag) {\n\t\t\tsize += 3;\n\t\t}\n\t\tif (op->bit_rate_info_flag) {\n\t\t\tsize += 8;\n\t\t}\n\t}\n\tsize += 1;//max_layer_count\n\tcount=gf_list_count(ptr->dependency_layers);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_DependentLayer *dep = (LHEVC_DependentLayer *)gf_list_get(ptr->dependency_layers, i);\n\t\tsize += 1/*dependent_layerID*/ + 1/*num_layers_dependent_on*/;\n\t\tsize += dep->num_layers_dependent_on * 1;//dependent_on_layerID\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tif (ptr->scalability_mask & (1 << j))\n\t\t\t\tsize += 1;//dimension_identifier\n\t\t}\n\t}\n\treturn size;\n}\n\n\nGF_LHVCLayerInformation *gf_isom_linf_new_entry()\n{\n\tGF_LHVCLayerInformation* ptr;\n\tGF_SAFEALLOC(ptr, GF_LHVCLayerInformation);\n\tif (ptr) ptr->num_layers_in_track = gf_list_new();\n\n\treturn ptr;\n\n}\n\nvoid gf_isom_linf_del_entry(void *entry)\n{\n\tGF_LHVCLayerInformation* ptr = (GF_LHVCLayerInformation *)entry;\n\tif (!ptr) return;\n\twhile (gf_list_count(ptr->num_layers_in_track)) {\n\t\tLHVCLayerInfoItem *li = (LHVCLayerInfoItem *)gf_list_get(ptr->num_layers_in_track, 0);\n\t\tgf_free(li);\n\t\tgf_list_rem(ptr->num_layers_in_track, 0);\n\t}\n\tgf_list_del(ptr->num_layers_in_track);\n\tgf_free(ptr);\n\treturn;\n}\n\nGF_Err gf_isom_linf_read_entry(void *entry, GF_BitStream *bs)\n{\n\tGF_LHVCLayerInformation* ptr = (GF_LHVCLayerInformation *)entry;\n\tu32 i, count;\n\n\tif (!ptr) return GF_BAD_PARAM;\n\tgf_bs_read_int(bs, 2);\n\tcount = gf_bs_read_int(bs, 6);\n\tfor (i = 0; i < count; i++) {\n\t\tLHVCLayerInfoItem *li;\n\t\tGF_SAFEALLOC(li, LHVCLayerInfoItem);\n\t\tif (!li) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_int(bs, 4);\n\t\tli->layer_id = gf_bs_read_int(bs, 6);\n\t\tli->min_TemporalId = gf_bs_read_int(bs, 3);\n\t\tli->max_TemporalId = gf_bs_read_int(bs, 3);\n\t\tgf_bs_read_int(bs, 1);\n\t\tli->sub_layer_presence_flags = gf_bs_read_int(bs, 7);\n\t\tgf_list_add(ptr->num_layers_in_track, li);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_linf_write_entry(void *entry, GF_BitStream *bs)\n{\n\tGF_LHVCLayerInformation* ptr = (GF_LHVCLayerInformation *)entry;\n\tu32 i, count;\n\tif (!ptr) return GF_OK;\n\n\tgf_bs_write_int(bs, 0, 2);\n\tcount=gf_list_count(ptr->num_layers_in_track);\n\tgf_bs_write_int(bs, count, 6);\n\tfor (i = 0; i < count; i++) {\n\t\tLHVCLayerInfoItem *li = (LHVCLayerInfoItem *)gf_list_get(ptr->num_layers_in_track, i);\n\t\tgf_bs_write_int(bs, 0, 4);\n\t\tgf_bs_write_int(bs, li->layer_id, 6);\n\t\tgf_bs_write_int(bs, li->min_TemporalId, 3);\n\t\tgf_bs_write_int(bs, li->max_TemporalId, 3);\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\tgf_bs_write_int(bs, li->sub_layer_presence_flags, 7);\n\t}\n\treturn GF_OK;\n}\n\nu32 gf_isom_linf_size_entry(void *entry)\n{\n\tGF_LHVCLayerInformation* ptr = (GF_LHVCLayerInformation *)entry;\n\tu32 size = 0, count;\n\tif (!ptr) return 0;\n\n\tsize += 1;\n\tcount=gf_list_count(ptr->num_layers_in_track);\n\tsize += count * 3;\n\treturn size;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2020\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / common tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/bitstream.h>\n\n/*the default size for new streams allocation...*/\n#define BS_MEM_BLOCK_ALLOC_SIZE\t\t512\n\n/*private types*/\nenum\n{\n\tGF_BITSTREAM_FILE_READ = GF_BITSTREAM_WRITE_DYN + 1,\n\tGF_BITSTREAM_FILE_WRITE,\n};\n\nstruct __tag_bitstream\n{\n\t/*original stream data*/\n\tFILE *stream;\n\n\t/*or original data*/\n\tchar *original;\n\t/*the size of our buffer in bytes*/\n\tu64 size;\n\t/*current position in BYTES*/\n\tu64 position;\n\t/*the byte readen/written*/\n\tu32 current;\n\t/*the number of bits in the current byte*/\n\tu32 nbBits;\n\t/*the bitstream mode*/\n\tu32 bsmode;\n\n\tvoid (*EndOfStream)(void *par);\n\tvoid *par;\n\n\n\tchar *cache_write;\n\tu32 cache_write_size, buffer_written;\n\n\tBool remove_emul_prevention_byte;\n\tu32 nb_zeros;\n\n\tGF_Err (*on_block_out)(void *cbk, u8 *data, u32 block_size);\n\tvoid *usr_data;\n\tu64 bytes_out;\n\tu32 prevent_dispatch;\n\n\tu64 cookie;\n\n\tu8 *cache_read;\n\tu32 cache_read_size, cache_read_pos, cache_read_alloc;\n\n\tvoid (*on_log)(void *udta, const char *field_name, u32 nb_bits, u64 field_val, s32 idx1, s32 idx2, s32 idx3);\n\tvoid *log_udta;\n\n\tu32 total_bits_read;\n\tu32 overflow_state;\n};\n\nGF_Err gf_bs_reassign_buffer(GF_BitStream *bs, const u8 *buffer, u64 BufferSize)\n{\n\tif (!bs) return GF_BAD_PARAM;\n\tbs->total_bits_read = 0;\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tbs->original = (char*)buffer;\n\t\tbs->size = BufferSize;\n\t\tbs->position = 0;\n\t\tbs->current = 0;\n\t\tbs->nbBits = 8;\n\t\tbs->current = 0;\n\t\tbs->nb_zeros = 0;\n\t\treturn GF_OK;\n\t}\n\tif (bs->bsmode==GF_BITSTREAM_WRITE) {\n\t\tif (!buffer || !BufferSize) return GF_BAD_PARAM;\n\t\tbs->original = (char*)buffer;\n\t\tbs->size = BufferSize;\n\t\tbs->position = 0;\n\t\tbs->current = 0;\n\t\tbs->nbBits = 0;\n\t\tbs->current = 0;\n\t\treturn GF_OK;\n\t}\n\tif (bs->bsmode!=GF_BITSTREAM_WRITE_DYN) return GF_BAD_PARAM;\n\tif (bs->original) return GF_BAD_PARAM;\n\n\tbs->position = 0;\n\tbs->current = 0;\n\tbs->nbBits = 0;\n\tbs->current = 0;\n\tbs->size = BufferSize ? BufferSize : BS_MEM_BLOCK_ALLOC_SIZE;\n\tif (buffer) {\n\t\tbs->original = (char *) buffer;\n\t} else {\n\t\tbs->original = (char *) gf_malloc(sizeof(char) * ((u32) bs->size));\n\t\tif (! bs->original) {\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_BitStream *gf_bs_new(const u8 *buffer, u64 BufferSize, u32 mode)\n{\n\tGF_BitStream *tmp = (GF_BitStream *)gf_malloc(sizeof(GF_BitStream));\n\tif (!tmp) return NULL;\n\tmemset(tmp, 0, sizeof(GF_BitStream));\n\n\ttmp->original = (char*)buffer;\n\ttmp->size = BufferSize;\n\n\ttmp->bsmode = mode;\n\n\tswitch (tmp->bsmode) {\n\tcase GF_BITSTREAM_READ:\n\t\ttmp->nbBits = 8;\n\t\ttmp->current = 0;\n\t\tbreak;\n\tcase GF_BITSTREAM_WRITE:\n\tcase GF_BITSTREAM_WRITE_DYN:\n\t\ttmp->nbBits = 0;\n\t\tif (! buffer) {\n\t\t\t/*if BufferSize is specified, use it. This is typically used when AvgSize of\n\t\t\tsome buffers is known, but some exceed it.*/\n\t\t\tif (BufferSize) {\n\t\t\t\ttmp->size = BufferSize;\n\t\t\t} else {\n\t\t\t\ttmp->size = BS_MEM_BLOCK_ALLOC_SIZE;\n\t\t\t}\n\t\t\ttmp->original = (char *) gf_malloc(sizeof(char) * ((u32) tmp->size));\n\t\t\tif (! tmp->original) {\n\t\t\t\tgf_free(tmp);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttmp->bsmode = GF_BITSTREAM_WRITE_DYN;\n\t\t} else {\n\t\t\ttmp->original = (char*)buffer;\n\t\t\ttmp->size = BufferSize;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t/*the stream constructor is not the same...*/\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn tmp;\n}\n\nGF_EXPORT\nGF_BitStream *gf_bs_from_file(FILE *f, u32 mode)\n{\n\tGF_BitStream *tmp;\n\tif (!f) return NULL;\n\n\ttmp = (GF_BitStream *)gf_malloc(sizeof(GF_BitStream));\n\tif (!tmp) return NULL;\n\tmemset(tmp, 0, sizeof(GF_BitStream));\n\t/*switch to internal mode*/\n\tmode = (mode==GF_BITSTREAM_READ) ? GF_BITSTREAM_FILE_READ : GF_BITSTREAM_FILE_WRITE;\n\ttmp->bsmode = mode;\n\ttmp->current = 0;\n\ttmp->nbBits = (mode == GF_BITSTREAM_FILE_READ) ? 8 : 0;\n\ttmp->original = NULL;\n\ttmp->position = 0;\n\ttmp->stream = f;\n\n\t/*get the size of this file (for read streams)*/\n\ttmp->position = gf_ftell(f);\n\ttmp->size = gf_fsize(f);\n\tgf_fseek(f, tmp->position, SEEK_SET);\n\n\n\tif (mode==GF_BITSTREAM_FILE_READ) {\n\t\ttmp->cache_read_alloc = gf_opts_get_int(\"core\", \"bs-cache-size\");\n\t\tif (tmp->cache_read_alloc) {\n\t\t\ttmp->cache_read_pos = tmp->cache_read_size = tmp->cache_read_alloc;\n\t\t\ttmp->cache_read = gf_malloc(tmp->cache_read_alloc);\n\t\t\tif (!tmp->cache_read) {\n\t\t\t\tgf_free(tmp);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\tif (mode == GF_BITSTREAM_FILE_WRITE) {\n\t\ttmp->cache_write_size = gf_opts_get_int(\"core\", \"bs-cache-size\");\n\t\tif (tmp->cache_write_size) {\n\t\t\ttmp->cache_write = (char*)gf_malloc(tmp->cache_write_size);\n\t\t\tif (!tmp->cache_write) {\n\t\t\t\tgf_free(tmp);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttmp->buffer_written = 0;\n\t\t}\n\t}\n\n\treturn tmp;\n}\n\n\nGF_BitStream *gf_bs_new_cbk_buffer(GF_Err (*on_block_out)(void *cbk, u8 *data, u32 block_size), void *usr_data, u8 *buffer, u32 buffer_size)\n{\n\tGF_BitStream *tmp;\n\n\tif (!on_block_out) return NULL;\n\n\ttmp = (GF_BitStream *)gf_malloc(sizeof(GF_BitStream));\n\tif (!tmp) return NULL;\n\tmemset(tmp, 0, sizeof(GF_BitStream));\n\n\tif (buffer && buffer_size) {\n\t\ttmp->size = buffer_size;\n\t\ttmp->original = buffer;\n\t} else {\n\t\ttmp->size = buffer_size ? buffer_size : 10*BS_MEM_BLOCK_ALLOC_SIZE;\n\t\ttmp->original = (char *) gf_malloc(sizeof(char) * ((u32) tmp->size));\n\t\tif (! tmp->original) {\n\t\t\tgf_free(tmp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\ttmp->bsmode = GF_BITSTREAM_WRITE_DYN;\n\ttmp->on_block_out = on_block_out;\n\ttmp->usr_data = usr_data;\n\n\treturn tmp;\n}\n\nGF_BitStream *gf_bs_new_cbk(GF_Err (*on_block_out)(void *cbk, u8 *data, u32 block_size), void *usr_data, u32 block_size)\n{\n\treturn gf_bs_new_cbk_buffer(on_block_out, usr_data, NULL, block_size);\n\n}\nvoid gf_bs_prevent_dispatch(GF_BitStream *bs, Bool prevent_dispatch)\n{\n\tif (!bs) return;\n\tif (prevent_dispatch) {\n\t\tbs->prevent_dispatch ++;\n\t\treturn;\n\t}\n\tif (!bs->prevent_dispatch) return;\n\tbs->prevent_dispatch --;\n\n\tif (bs->on_block_out && !bs->prevent_dispatch) {\n\t\tassert(bs->position >= bs->bytes_out);\n\t\tif (bs->position > bs->bytes_out) {\n\t\t\tbs->on_block_out(bs->usr_data, bs->original, (u32) (bs->position - bs->bytes_out));\n\t\t\tbs->bytes_out = bs->position;\n\t\t}\n\t}\n}\n\nstatic void bs_flush_write_cache(GF_BitStream *bs)\n{\n\tif (bs->buffer_written) {\n\t\tu32 nb_write;\n\t\tnb_write = (u32) gf_fwrite(bs->cache_write, bs->buffer_written, bs->stream);\n\n\t\t//check we didn't rewind the bitstream\n\t\tif (bs->size == bs->position)\n\t\t\tbs->size += nb_write;\n\t\tbs->position += nb_write;\n\t\tbs->buffer_written = 0;\n\t}\n}\n\n\n\nGF_EXPORT\nvoid gf_bs_del(GF_BitStream *bs)\n{\n\tif (!bs) return;\n\tif (bs->on_block_out && bs->position>bs->bytes_out) {\n\t\tbs->on_block_out(bs->usr_data, bs->original, (u32) (bs->position - bs->bytes_out) );\n\t}\n\t/*if we are in dynamic mode (alloc done by the bitstream), free the buffer if still present*/\n\tif ((bs->bsmode == GF_BITSTREAM_WRITE_DYN) && bs->original) gf_free(bs->original);\n\tif (bs->cache_write) {\n\t\tbs_flush_write_cache(bs);\n\t\tgf_free(bs->cache_write);\n\t}\n\tif (bs->cache_read)\n\t\tgf_free(bs->cache_read);\n\tgf_free(bs);\n}\n\nGF_EXPORT\nvoid gf_bs_enable_emulation_byte_removal(GF_BitStream *bs, Bool do_remove)\n{\n\tif (bs) {\n\t\tbs->remove_emul_prevention_byte = do_remove;\n\t\tbs->nb_zeros = 0;\n\t}\n}\n\n/*returns 1 if aligned wrt current mode, 0 otherwise*/\nBool gf_bs_is_align(GF_BitStream *bs)\n{\n\tswitch (bs->bsmode) {\n\tcase GF_BITSTREAM_READ:\n\tcase GF_BITSTREAM_FILE_READ:\n\t\treturn ( (8 == bs->nbBits) ? GF_TRUE : GF_FALSE);\n\tdefault:\n\t\treturn !bs->nbBits;\n\t}\n}\n\nstatic GFINLINE u8 gf_bs_load_byte(GF_BitStream *bs, Bool *is_eos)\n{\n\tu8 res;\n\tif (bs->cache_read) {\n\t\tif (bs->cache_read_pos == bs->cache_read_size) {\n\t\t\tbs->cache_read_size = (u32) gf_fread(bs->cache_read, bs->cache_read_alloc, bs->stream);\n\t\t\tbs->cache_read_pos = 0;\n\t\t\tif (!bs->cache_read_size) {\n\t\t\t\t*is_eos = GF_TRUE;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tres = bs->cache_read[bs->cache_read_pos];\n\t\tbs->cache_read_pos++;\n\t} else {\n\t\tres = gf_fgetc(bs->stream);\n\t}\n\treturn res;\n}\n\n/*fetch a new byte in the bitstream switch between packets*/\nstatic u8 BS_ReadByte(GF_BitStream *bs)\n{\n\tBool is_eos;\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tu8 res;\n\t\tif (bs->position >= bs->size) {\n\t\t\tif (bs->EndOfStream) bs->EndOfStream(bs->par);\n\t\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t\t\treturn 0;\n\t\t}\n\t\tres = bs->original[bs->position++];\n\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\tif ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size) && (bs->original[bs->position]<0x04)) {\n\t\t\t\tbs->nb_zeros = 0;\n\t\t\t\tres = bs->original[bs->position++];\n\t\t\t}\n\t\t\tif (!res) bs->nb_zeros++;\n\t\t\telse bs->nb_zeros = 0;\n\t\t}\n\t\treturn res;\n\t}\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\n\tis_eos = gf_feof(bs->stream);\n\t//cache not fully read, reset EOS\n\tif (bs->cache_read && (bs->cache_read_pos<bs->cache_read_size))\n\t\tis_eos = GF_FALSE;\n\n\t/*we are in FILE mode, test for end of file*/\n\tif (!is_eos) {\n\t\tu8 res;\n\t\tBool loc_eos=GF_FALSE;\n\t\tassert(bs->position<=bs->size);\n\t\tbs->position++;\n\n\t\tres = gf_bs_load_byte(bs, &loc_eos);\n\t\tif (loc_eos) goto bs_eof;\n\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\tif ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size)) {\n\t\t\t\tu8 next = gf_bs_load_byte(bs, &loc_eos);\n\t\t\t\tif (next < 0x04) {\n\t\t\t\t\tbs->nb_zeros = 0;\n\t\t\t\t\tres = next;\n\t\t\t\t\tbs->position++;\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_seek(bs, bs->position);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!res) bs->nb_zeros++;\n\t\t\telse bs->nb_zeros = 0;\n\t\t}\n\t\treturn res;\n\t}\n\nbs_eof:\n\tif (bs->EndOfStream) {\n\t\tbs->EndOfStream(bs->par);\n\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t} else {\n\t\tif (!bs->overflow_state) {\n\t\t\tbs->overflow_state = 1;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to overread bitstream\\n\"));\n\t\t}\n\t}\n\tassert(bs->position <= 1+bs->size);\n\treturn 0;\n}\n\n#define NO_OPTS\n\n#ifndef NO_OPTS\nstatic u32 bit_mask[] = {0x80, 0x40, 0x20, 0x10, 0x8, 0x4, 0x2, 0x1};\nstatic u32 bits_mask[] = {0x0, 0x1, 0x3, 0x7, 0xF, 0x1F, 0x3F, 0x7F};\n#endif\n\nGF_EXPORT\nu8 gf_bs_read_bit(GF_BitStream *bs)\n{\n\tif (bs->nbBits == 8) {\n\t\tbs->current = BS_ReadByte(bs);\n\t\tbs->nbBits = 0;\n\t}\n#ifdef NO_OPTS\n\t{\n\t\ts32 ret;\n\t\tbs->current <<= 1;\n\t\tbs->nbBits++;\n\t\tret = (bs->current & 0x100) >> 8;\n\t\treturn (u8) ret;\n\t}\n#else\n\treturn (u8) (bs->current & bit_mask[bs->nbBits++]) ? 1 : 0;\n#endif\n\n}\n\nGF_EXPORT\nu32 gf_bs_read_int(GF_BitStream *bs, u32 nBits)\n{\n\tu32 ret;\n\tbs->total_bits_read+= nBits;\n\n#ifndef NO_OPTS\n\tif (nBits + bs->nbBits <= 8) {\n\t\tbs->nbBits += nBits;\n\t\tret = (bs->current >> (8 - bs->nbBits) ) & bits_mask[nBits];\n\t\treturn ret;\n\t}\n#endif\n\tret = 0;\n\twhile (nBits-- > 0) {\n\t\tret <<= 1;\n\t\tret |= gf_bs_read_bit(bs);\n\t}\n\treturn ret;\n}\n\nGF_EXPORT\nu32 gf_bs_read_u8(GF_BitStream *bs)\n{\n\tassert(bs->nbBits==8);\n\tif (bs->cache_read && (bs->cache_read_pos+1<bs->cache_read_size) ) {\n\t\tu32 ret = bs->cache_read[bs->cache_read_pos];\n\t\tbs->cache_read_pos+=1;\n\t\tbs->position+=1;\n\t\treturn ret;\n\t}\n\n\treturn (u32) BS_ReadByte(bs);\n}\n\n#if 0\nGF_EXPORT\nu32 gf_bs_read_u8_until_delimiter(GF_BitStream *bs, u8 delimiter, u8* out, u32 max_length) {\n\tu32 i = 0;\n\tchar token=0;\n\tu64 cur_pos = gf_bs_get_position(bs);\n\n\tif (!max_length) out = NULL;\n\n\twhile(gf_bs_available(bs) && (!max_length || i < max_length)) {\n\t\tgf_bs_read_data(bs, &token, 1);\n\t\tif (token == delimiter) goto found;\n\t\tif (out) out[i] = token;\n\t\ti++;\n\t}\n\n\t/* Delimiter not found */\n\tgf_bs_seek(bs, cur_pos);\n\treturn 0;\n\nfound:\n\treturn i;\n}\n#endif\n\nGF_EXPORT\nu32 gf_bs_read_u16(GF_BitStream *bs)\n{\n\tu32 ret;\n\tassert(bs->nbBits==8);\n\tif (bs->cache_read && (bs->cache_read_pos+2<bs->cache_read_size) ) {\n\t\tret = bs->cache_read[bs->cache_read_pos];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+1];\n\t\tbs->cache_read_pos+=2;\n\t\tbs->position+=2;\n\t\treturn ret;\n\t}\n\n\tret = BS_ReadByte(bs);\n\tret<<=8;\n\tret |= BS_ReadByte(bs);\n\treturn ret;\n}\n\n\nGF_EXPORT\nu32 gf_bs_read_u24(GF_BitStream *bs)\n{\n\tu32 ret;\n\tassert(bs->nbBits==8);\n\n\tif (bs->cache_read && (bs->cache_read_pos+3<bs->cache_read_size) ) {\n\t\tret = bs->cache_read[bs->cache_read_pos];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+1];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+2];\n\t\tbs->cache_read_pos+=3;\n\t\tbs->position+=3;\n\t\treturn ret;\n\t}\n\n\tret = BS_ReadByte(bs);\n\tret<<=8;\n\tret |= BS_ReadByte(bs);\n\tret<<=8;\n\tret |= BS_ReadByte(bs);\n\treturn ret;\n}\n\nGF_EXPORT\nu32 gf_bs_read_u32(GF_BitStream *bs)\n{\n\tu32 ret;\n\tassert(bs->nbBits==8);\n\n\tif (bs->cache_read && (bs->cache_read_pos+4<bs->cache_read_size) ) {\n\t\tret = bs->cache_read[bs->cache_read_pos];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+1];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+2];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+3];\n\t\tbs->cache_read_pos+=4;\n\t\tbs->position+=4;\n\t\treturn ret;\n\t}\n\tret = BS_ReadByte(bs);\n\tret<<=8;\n\tret |= BS_ReadByte(bs);\n\tret<<=8;\n\tret |= BS_ReadByte(bs);\n\tret<<=8;\n\tret |= BS_ReadByte(bs);\n\treturn ret;\n}\n\nGF_EXPORT\nu64 gf_bs_read_u64(GF_BitStream *bs)\n{\n\tu64 ret;\n\n\tif (bs->cache_read && (bs->cache_read_pos+8<bs->cache_read_size) ) {\n\t\tret = bs->cache_read[bs->cache_read_pos];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+1];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+2];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+3];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+4];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+5];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+6];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+7];\n\t\tbs->cache_read_pos+=8;\n\t\tbs->position+=8;\n\t\treturn ret;\n\t}\n\tret = gf_bs_read_u32(bs);\n\tret<<=32;\n\tret |= gf_bs_read_u32(bs);\n\treturn ret;\n}\n\nGF_EXPORT\nu64 gf_bs_read_long_int(GF_BitStream *bs, u32 nBits)\n{\n\tu64 ret = 0;\n\tif (nBits>64) {\n\t\tu32 skip = nBits-64;\n\t\tif (gf_bs_available(bs) * 8 < nBits-8) {\n\t\t\tif (bs->EndOfStream) bs->EndOfStream(bs->par);\n\t\t\tbs->position = bs->size;\n\t\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t\t\treturn 0;\n\t\t}\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"Reading %d bits but max should be 64, skipping %d most significants bits\\n\", nBits, nBits-64));\n\t\t//avoid recursion\n\t\twhile (skip) {\n\t\t\tif (skip>32) {\n\t\t\t\tgf_bs_read_int(bs, 32);\n\t\t\t\tskip-=32;\n\t\t\t} else {\n\t\t\t\tgf_bs_read_int(bs, skip);\n\t\t\t\tskip=0;\n\t\t\t}\n\t\t}\n\t\tret = gf_bs_read_long_int(bs, 64);\n\t} else {\n\t\twhile (nBits-- > 0) {\n\t\t\tret <<= 1;\n\t\t\tret |= gf_bs_read_bit(bs);\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nGF_EXPORT\nFloat gf_bs_read_float(GF_BitStream *bs)\n{\n\tchar buf [4] = \"\\0\\0\\0\";\n#ifdef NO_OPTS\n\ts32 i;\n\tfor (i = 0; i < 32; i++)\n\t\tbuf[3-i/8] |= gf_bs_read_bit(bs) << (7 - i%8);\n#else\n\tbuf[3] = gf_bs_read_int(bs, 8);\n\tbuf[2] = gf_bs_read_int(bs, 8);\n\tbuf[1] = gf_bs_read_int(bs, 8);\n\tbuf[0] = gf_bs_read_int(bs, 8);\n#endif\n\treturn (* (Float *) buf);\n}\n\nGF_EXPORT\nDouble gf_bs_read_double(GF_BitStream *bs)\n{\n\tchar buf [8] = \"\\0\\0\\0\\0\\0\\0\\0\";\n\ts32 i;\n\tfor (i = 0; i < 64; i++)\n\t\tbuf[7-i/8] |= gf_bs_read_bit(bs) << (7 - i%8);\n\treturn (* (Double *) buf);\n}\n\nGF_EXPORT\nu32 gf_bs_read_data(GF_BitStream *bs, u8 *data, u32 nbBytes)\n{\n\tu64 orig = bs->position;\n\n\tif (bs->position+nbBytes > bs->size) return 0;\n\n\tif (gf_bs_is_align(bs) ) {\n\t\ts32 bytes_read, bytes_read_cache;\n\t\tswitch (bs->bsmode) {\n\t\tcase GF_BITSTREAM_READ:\n\t\tcase GF_BITSTREAM_WRITE:\n\t\tcase GF_BITSTREAM_WRITE_DYN:\n\t\t\tmemcpy(data, bs->original + bs->position, nbBytes);\n\t\t\tbs->position += nbBytes;\n\t\t\treturn nbBytes;\n\t\tcase GF_BITSTREAM_FILE_READ:\n\t\tcase GF_BITSTREAM_FILE_WRITE:\n\t\t\tif (bs->cache_write)\n\t\t\t\tbs_flush_write_cache(bs);\n\n\t\t\tbytes_read = bytes_read_cache = 0;\n\t\t\tif (bs->cache_read) {\n\t\t\t\tu32 csize = bs->cache_read_size-bs->cache_read_pos;\n\t\t\t\tif (csize>nbBytes) csize = nbBytes;\n\t\t\t\tmemcpy(data, bs->cache_read + bs->cache_read_pos, csize);\n\t\t\t\tbs->cache_read_pos += csize;\n\t\t\t\tnbBytes -= csize;\n\t\t\t\tbytes_read_cache = csize;\n\t\t\t}\n\t\t\tif (nbBytes) {\n\t\t\t\tbytes_read = (s32) gf_fread(data + bytes_read_cache, nbBytes, bs->stream);\n\t\t\t\tif (bytes_read<0) return bytes_read_cache;\n\t\t\t}\n\t\t\tbs->position += bytes_read + bytes_read_cache;\n\t\t\treturn bytes_read + bytes_read_cache;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\twhile (nbBytes-- > 0) {\n\t\t*data++ = gf_bs_read_int(bs, 8);\n\t}\n\treturn (u32) (bs->position - orig);\n\n}\n\n\n\nstatic void BS_WriteByte(GF_BitStream *bs, u8 val)\n{\n\t/*we don't allow write on READ buffers*/\n\tif ( (bs->bsmode == GF_BITSTREAM_READ) || (bs->bsmode == GF_BITSTREAM_FILE_READ) ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to write on read bitstream\\n\"));\n\t\treturn;\n\t}\n\tif (!bs->original && !bs->stream) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to write on unassigned bitstream\\n\"));\n\t\treturn;\n\t}\n\t/*we are in MEM mode*/\n\tif ( (bs->bsmode == GF_BITSTREAM_WRITE) || (bs->bsmode == GF_BITSTREAM_WRITE_DYN) ) {\n\t\t//if callback mode and dispatch is not blocked, dispatch\n\t\tif (bs->on_block_out && !bs->prevent_dispatch) {\n\t\t\tassert(bs->position >= bs->bytes_out);\n\t\t\tif (bs->position - bs->bytes_out == bs->size) {\n\t\t\t\tbs->on_block_out(bs->usr_data, bs->original, (u32) (bs->position - bs->bytes_out));\n\t\t\t\tbs->bytes_out = bs->position;\n\t\t\t}\n\t\t\tif (bs->original)\n\t\t\t\tbs->original[bs->position - bs->bytes_out] = val;\n\t\t\tbs->position++;\n\t\t\tassert(bs->position >= bs->bytes_out);\n\t\t\treturn;\n\t\t}\n\t\t//otherwise store\n\t\tif (bs->position - bs->bytes_out == bs->size) {\n\t\t\t/*no more space...*/\n\t\t\tif (bs->bsmode != GF_BITSTREAM_WRITE_DYN) return;\n\t\t\t/*gf_realloc if enough space...*/\n\t\t\tif (bs->size > 0xFFFFFFFF) return;\n\t\t\tbs->size = bs->size ? (bs->size * 2) : BS_MEM_BLOCK_ALLOC_SIZE;\n\t\t\tbs->original = (char*)gf_realloc(bs->original, (u32)bs->size);\n\t\t\tif (!bs->original) return;\n\t\t}\n\t\tif (bs->original)\n\t\t\tbs->original[bs->position - bs->bytes_out] = val;\n\t\tbs->position++;\n\t\treturn;\n\t}\n\tif (bs->cache_write) {\n\t\tif (bs->buffer_written == bs->cache_write_size) {\n\t\t\tbs_flush_write_cache(bs);\n\t\t}\n\t\tbs->cache_write[bs->buffer_written] = val;\n\t\tbs->buffer_written++;\n\t\tif (bs->buffer_written == bs->cache_write_size) {\n\t\t\tbs_flush_write_cache(bs);\n\t\t}\n\t\treturn;\n\t}\n\t/*we are in FILE mode, no pb for any gf_realloc...*/\n\tgf_fputc(val, bs->stream);\n\n\t/*check we didn't rewind the stream*/\n\tif (bs->size == bs->position) bs->size++;\n\tbs->position += 1;\n}\n\nstatic void BS_WriteBit(GF_BitStream *bs, u32 bit)\n{\n\tbs->current <<= 1;\n\tbs->current |= bit;\n\tif (++ bs->nbBits == 8) {\n\t\tbs->nbBits = 0;\n\t\tBS_WriteByte(bs, (u8) bs->current);\n\t\tbs->current = 0;\n\t}\n}\n\nstatic s32 bs_handle_nbits_overflow(GF_BitStream* bs, s32 nBits, s32 max_shift)\n{\n\tif (nBits > max_shift) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to write %d bits, when max is %d\\n\", nBits, max_shift));\n\t}\n\twhile (nBits > max_shift) {\n\t\tgf_bs_write_long_int(bs, 0, max_shift);\n\t\tnBits -= max_shift;\n\t}\n\n\treturn nBits;\n}\n\nGF_EXPORT\nvoid gf_bs_write_int(GF_BitStream *bs, s32 _value, s32 nBits)\n{\n\tu32 value, nb_shift;\n\ts32 max_shift = sizeof(s32) * 8;\n\tif (!nBits) return;\n\tnBits = bs_handle_nbits_overflow(bs, nBits, max_shift);\n\t//move to unsigned to avoid sanitizer warnings when we pass a value not codable on the given number of bits\n\t//we do this when setting bit fields to all 1's\n\tvalue = (u32) _value;\n\tnb_shift = max_shift - nBits;\n\tif (nb_shift)\n\t\tvalue <<= nb_shift;\n\n\twhile (--nBits >= 0) {\n\t\t//but check value as signed\n\t\tBS_WriteBit (bs, ((s32)value) < 0);\n\t\tvalue <<= 1;\n\t}\n}\n\nGF_EXPORT\nvoid gf_bs_write_long_int(GF_BitStream *bs, s64 _value, s32 nBits)\n{\n\ts32 max_shift = sizeof(s64) * 8;\n\tif (!nBits) return;\n\tnBits = bs_handle_nbits_overflow(bs, nBits, max_shift);\n\n\t//cf note in gf_bs_write_int\n\tu64 value = (u64) _value;\n\tvalue <<= max_shift - nBits;\n\twhile (--nBits >= 0) {\n\t\tBS_WriteBit (bs, ((s64)value) < 0);\n\t\tvalue <<= 1;\n\t}\n}\n\nGF_EXPORT\nvoid gf_bs_write_u8(GF_BitStream *bs, u32 value)\n{\n\tassert(!bs->nbBits);\n\n\tif (bs->cache_write && (bs->buffer_written+1 < bs->cache_write_size) ) {\n\t\tbs->cache_write[bs->buffer_written] = (u8) value;\n\t\tbs->buffer_written += 1;\n\t} else {\n\t\tBS_WriteByte(bs, (u8) value);\n\t}\n}\n\nGF_EXPORT\nvoid gf_bs_write_u16(GF_BitStream *bs, u32 value)\n{\n\tassert(!bs->nbBits);\n\tif (bs->cache_write && (bs->buffer_written+2 < bs->cache_write_size) ) {\n\t\tbs->cache_write[bs->buffer_written] = (u8) ((value>>8)&0xff);\n\t\tbs->cache_write[bs->buffer_written+1] = (u8) ((value)&0xff);\n\t\tbs->buffer_written += 2;\n\t} else {\n\t\tBS_WriteByte(bs, (u8) ((value>>8)&0xff));\n\t\tBS_WriteByte(bs, (u8) ((value)&0xff));\n\t}\n}\n\nGF_EXPORT\nvoid gf_bs_write_u24(GF_BitStream *bs, u32 value)\n{\n\tassert(!bs->nbBits);\n\tif (bs->cache_write && (bs->buffer_written+3 < bs->cache_write_size) ) {\n\t\tbs->cache_write[bs->buffer_written] = (u8) ((value>>16)&0xff);\n\t\tbs->cache_write[bs->buffer_written+1] = (u8) ((value>>8)&0xff);\n\t\tbs->cache_write[bs->buffer_written+2] = (u8) ((value)&0xff);\n\t\tbs->buffer_written += 3;\n\t} else {\n\t\tBS_WriteByte(bs, (u8) ((value>>16)&0xff));\n\t\tBS_WriteByte(bs, (u8) ((value>>8)&0xff));\n\t\tBS_WriteByte(bs, (u8) ((value)&0xff));\n\t}\n}\n\nGF_EXPORT\nvoid gf_bs_write_u32(GF_BitStream *bs, u32 value)\n{\n\tassert(!bs->nbBits);\n\tif (bs->cache_write && (bs->buffer_written+4 < bs->cache_write_size) ) {\n\t\tbs->cache_write[bs->buffer_written] = (u8) ((value>>24)&0xff);\n\t\tbs->cache_write[bs->buffer_written+1] = (u8) ((value>>16)&0xff);\n\t\tbs->cache_write[bs->buffer_written+2] = (u8) ((value>>8)&0xff);\n\t\tbs->cache_write[bs->buffer_written+3] = (u8) ((value)&0xff);\n\t\tbs->buffer_written += 4;\n\t} else {\n\t\tBS_WriteByte(bs, (u8) ((value>>24)&0xff));\n\t\tBS_WriteByte(bs, (u8) ((value>>16)&0xff));\n\t\tBS_WriteByte(bs, (u8) ((value>>8)&0xff));\n\t\tBS_WriteByte(bs, (u8) ((value)&0xff));\n\t}\n}\n\nGF_EXPORT\nvoid gf_bs_write_u64(GF_BitStream *bs, u64 value)\n{\n\tassert(!bs->nbBits);\n\tgf_bs_write_u32(bs, (u32) ((value>>32)&0xffffffff));\n\tgf_bs_write_u32(bs, (u32) (value&0xffffffff));\n}\n\nGF_EXPORT\nu32 gf_bs_write_byte(GF_BitStream *bs, u8 byte, u32 repeat_count)\n{\n\tif (!gf_bs_is_align(bs) || bs->cache_write) {\n\t\tu32 count = 0;\n\t\twhile (count<repeat_count) {\n\t\t\tgf_bs_write_int(bs, byte, 8);\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n\n\tswitch (bs->bsmode) {\n\tcase GF_BITSTREAM_WRITE:\n\t\tif (bs->position + repeat_count > bs->size)\n\t\t\treturn 0;\n\t\tmemset(bs->original + bs->position, byte, repeat_count);\n\t\tbs->position += repeat_count;\n\t\treturn repeat_count;\n\tcase GF_BITSTREAM_WRITE_DYN:\n\t\t/*need to gf_realloc ...*/\n\t\tif (bs->position+repeat_count> bs->size) {\n\t\t\tu32 new_size = (u32) (bs->size*2);\n\t\t\tif (!new_size) new_size = BS_MEM_BLOCK_ALLOC_SIZE;\n\n\t\t\tif (bs->size + repeat_count > 0xFFFFFFFF)\n\t\t\t\treturn 0;\n\t\t\twhile (new_size < (u32) ( bs->size + repeat_count))\n\t\t\t\tnew_size *= 2;\n\t\t\tbs->original = (char*)gf_realloc(bs->original, sizeof(u32)*new_size);\n\t\t\tif (!bs->original)\n\t\t\t\treturn 0;\n\t\t\tbs->size = new_size;\n\t\t}\n\t\tmemset(bs->original + bs->position, byte, repeat_count);\n\t\tbs->position += repeat_count;\n\t\treturn repeat_count;\n\tcase GF_BITSTREAM_FILE_READ:\n\tcase GF_BITSTREAM_FILE_WRITE:\n\t\tif (gf_fwrite(&byte, repeat_count, bs->stream) != repeat_count)\n\t\t\treturn 0;\n\t\tif (bs->size == bs->position) bs->size += repeat_count;\n\t\tbs->position += repeat_count;\n\t\treturn repeat_count;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n\n\nGF_EXPORT\nvoid gf_bs_write_float(GF_BitStream *bs, Float value)\n{\n\tu32 i;\n\tunion\n\t{\tfloat f;\n\t\tchar sz [4];\n\t} float_value;\n\tfloat_value.f = value;\n\n\tfor (i = 0; i < 32; i++)\n\t\tBS_WriteBit(bs, (float_value.sz [3 - i / 8] & 1 << (7 - i % 8)) != 0);\n\n}\n\nGF_EXPORT\nvoid gf_bs_write_double (GF_BitStream *bs, Double value)\n{\n\tu32 i;\n\tunion\n\t{\tDouble d;\n\t\tchar sz [8];\n\t} double_value;\n\tdouble_value.d = value;\n\tfor (i = 0; i < 64; i++) {\n\t\tBS_WriteBit(bs, (double_value.sz [7 - i / 8] & 1 << (7 - i % 8)) != 0);\n\t}\n}\n\n\nGF_EXPORT\nu32 gf_bs_write_data(GF_BitStream *bs, const u8 *data, u32 nbBytes)\n{\n\t/*we need some feedback for this guy...*/\n\tu64 begin = bs->position;\n\tif (!nbBytes) return 0;\n\n\tif (gf_bs_is_align(bs)) {\n\t\tswitch (bs->bsmode) {\n\t\tcase GF_BITSTREAM_WRITE:\n\t\t\tif (bs->position+nbBytes > bs->size) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to overwrite bitstream by %d bytes\\n\", bs->position + nbBytes - bs->size));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmemcpy(bs->original + bs->position, data, nbBytes);\n\t\t\tbs->position += nbBytes;\n\t\t\treturn nbBytes;\n\t\tcase GF_BITSTREAM_WRITE_DYN:\n\t\t\t//if callback mode and dispatch not disabled, dispatch bytes\n\t\t\tif (bs->on_block_out && !bs->prevent_dispatch) {\n\t\t\t\tassert(bs->position >= bs->bytes_out);\n\n\t\t\t\tif (bs->position - bs->bytes_out + nbBytes <= bs->size) {\n\t\t\t\t\tmemcpy(bs->original + bs->position - bs->bytes_out, data, nbBytes);\n\t\t\t\t\tbs->position += nbBytes;\n\t\t\t\t} else {\n\t\t\t\t\tif (bs->position > bs->bytes_out)\n\t\t\t\t\t\tbs->on_block_out(bs->usr_data, bs->original, (u32) (bs->position - bs->bytes_out) );\n\t\t\t\t\tif (nbBytes)\n\t\t\t\t\t\tbs->on_block_out(bs->usr_data, (char *) data, nbBytes);\n\n\t\t\t\t\tbs->position += nbBytes;\n\t\t\t\t\tbs->bytes_out = bs->position;\n\t\t\t\t}\n\t\t\t\tassert(bs->position >= bs->bytes_out);\n\t\t\t\treturn nbBytes;\n\t\t\t}\n\t\t\t//otherwise store\n\t\t\t/*need to gf_realloc ...*/\n\t\t\tif (bs->position + nbBytes - bs->bytes_out > bs->size) {\n\t\t\t\tu32 new_size = (u32) (bs->size*2);\n\t\t\t\tif (!new_size) new_size = BS_MEM_BLOCK_ALLOC_SIZE;\n\n\t\t\t\tif (bs->size + nbBytes > 0xFFFFFFFF)\n\t\t\t\t\treturn 0;\n\n\t\t\t\twhile (new_size < (u32) ( bs->size + nbBytes))\n\t\t\t\t\tnew_size *= 2;\n\t\t\t\tbs->original = (char*)gf_realloc(bs->original, sizeof(u32)*new_size);\n\t\t\t\tif (!bs->original)\n\t\t\t\t\treturn 0;\n\t\t\t\tbs->size = new_size;\n\t\t\t}\n\t\t\tmemcpy(bs->original + bs->position - bs->bytes_out, data, nbBytes);\n\t\t\tbs->position += nbBytes;\n\t\t\treturn nbBytes;\n\t\tcase GF_BITSTREAM_FILE_READ:\n\t\tcase GF_BITSTREAM_FILE_WRITE:\n\t\t\tif (bs->cache_write) {\n\t\t\t\t//if block fits in our write cache, write it\n\t\t\t\tif (bs->buffer_written + nbBytes < bs->cache_write_size) {\n\t\t\t\t\tmemcpy(bs->cache_write+bs->buffer_written, data, nbBytes);\n\t\t\t\t\tbs->buffer_written+=nbBytes;\n\t\t\t\t\treturn nbBytes;\n\t\t\t\t}\n\t\t\t\t//otherwise flush cache and use file write\n\t\t\t\tbs_flush_write_cache(bs);\n\t\t\t}\n\n\t\t\tif (gf_fwrite(data, nbBytes, bs->stream) != nbBytes) return 0;\n\n\t\t\tif (bs->size == bs->position) bs->size += nbBytes;\n\t\t\tbs->position += nbBytes;\n\t\t\treturn nbBytes;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\twhile (nbBytes) {\n\t\tgf_bs_write_int(bs, (s32) *data, 8);\n\t\tdata++;\n\t\tnbBytes--;\n\t}\n\treturn (u32) (bs->position - begin);\n}\n\n/*align return the num of bits read in READ mode, 0 in WRITE*/\nGF_EXPORT\nu8 gf_bs_align(GF_BitStream *bs)\n{\n\tu8 res = 8 - bs->nbBits;\n\tif ( (bs->bsmode == GF_BITSTREAM_READ) || (bs->bsmode == GF_BITSTREAM_FILE_READ)) {\n\t\tif (res > 0) {\n\t\t\tgf_bs_read_int(bs, res);\n\t\t}\n\t\treturn res;\n\t}\n\tif (bs->nbBits > 0) {\n\t\tgf_bs_write_int (bs, 0, res);\n\t\treturn res;\n\t}\n\treturn 0;\n}\n\n\n/*size available in the bitstream*/\nGF_EXPORT\nu64 gf_bs_available(GF_BitStream *bs)\n{\n\ts64 cur, end;\n\n\t/*in WRITE mode only, this should not be called, but return something big in case ...*/\n\tif ( (bs->bsmode == GF_BITSTREAM_WRITE)\n\t        || (bs->bsmode == GF_BITSTREAM_WRITE_DYN)\n\t   )\n\t\treturn (u64) -1;\n\n\t/*we are in MEM mode*/\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tif (bs->size < bs->position)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn (bs->size - bs->position);\n\t}\n\t/*FILE READ: assume size hasn't changed, otherwise the user shall call gf_bs_get_refreshed_size*/\n\tif (bs->bsmode==GF_BITSTREAM_FILE_READ) {\n\t\tif (bs->position>bs->size) return 0;\n\t\treturn (bs->size - bs->position);\n\t}\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\n\tcur = gf_ftell(bs->stream);\n\tend = gf_fsize(bs->stream);\n\tgf_fseek(bs->stream, cur, SEEK_SET);\n\n\treturn (u64) (end - cur);\n}\n\n/*call this funct to set the buffer size to the nb of bytes written\nUsed only in WRITE mode, as we don't know the real size during allocation...\nreturn -1 for bad param or gf_malloc failed\nreturn nbBytes cut*/\nstatic s32 BS_CutBuffer(GF_BitStream *bs)\n{\n\ts32 nbBytes;\n\tif ( (bs->bsmode != GF_BITSTREAM_WRITE_DYN) && (bs->bsmode != GF_BITSTREAM_WRITE)) return (u32) -1;\n\t/*Align our buffer or we're dead!*/\n\tgf_bs_align(bs);\n\n\tnbBytes = (u32) (bs->size - bs->position);\n\tif (!nbBytes || (nbBytes == 0xFFFFFFFF) || (bs->position >= 0xFFFFFFFF)) return 0;\n\t/*\n\t\tbs->original = (char*)gf_realloc(bs->original, (u32) bs->position);\n\t\tif (! bs->original) return (u32) -1;\n\t*/\n\t/*just in case, re-adjust..*/\n\tbs->size = bs->position;\n\treturn nbBytes;\n}\n\n/*For DYN mode, this gets the content out without cutting the buffer to the number of written bytes*/\nGF_EXPORT\nvoid gf_bs_get_content_no_truncate(GF_BitStream *bs, u8 **output, u32 *outSize, u32 *alloc_size)\n{\n\t/*only in WRITE MEM mode*/\n\tif (!bs || bs->bsmode != GF_BITSTREAM_WRITE_DYN) return;\n\n\tif (bs->on_block_out && bs->position>bs->bytes_out) {\n\t\tbs->on_block_out(bs->usr_data, bs->original, (u32) (bs->position - bs->bytes_out) );\n\t}\n\n\tif (!bs->position && !bs->nbBits) {\n\t\tif (!alloc_size) {\n\t\t\t*output = NULL;\n\t\t\tgf_free(bs->original);\n\t\t} else {\n\t\t\t*alloc_size = (u32) bs->size;\n\t\t\t*output = bs->original;\n\t\t}\n\t\t*outSize = 0;\n\t} else {\n\t\tif (alloc_size) {\n\t\t\t/*Align our buffer or we're dead!*/\n\t\t\tgf_bs_align(bs);\n\t\t\t*alloc_size = (u32) bs->size;\n\t\t\t*outSize = (u32) bs->position;\n\t\t\t*output = bs->original;\n\t\t} else {\n\t\t\ts32 copy = BS_CutBuffer(bs);\n\t\t\tif (copy < 0) {\n\t\t\t\t*output = NULL;\n\t\t\t} else\n\t\t\t\t*output = bs->original;\n\t\t\t*outSize = (u32) bs->size;\n\t\t}\n\t}\n\tbs->original = NULL;\n\tbs->size = 0;\n\tbs->position = 0;\n}\n\n/*For DYN mode, this gets the content out*/\nGF_EXPORT\nvoid gf_bs_get_content(GF_BitStream *bs, u8 **output, u32 *outSize)\n{\n\tgf_bs_get_content_no_truncate(bs, output, outSize, NULL);\n}\n\n/*\tSkip nbytes.\n\tAlign\n\tIf READ (MEM or FILE) mode, just read n times 8 bit\n\tIf WRITE (MEM or FILE) mode, write n times 0 on 8 bit\n*/\nGF_EXPORT\nvoid gf_bs_skip_bytes(GF_BitStream *bs, u64 nbBytes)\n{\n\tif (!bs || !nbBytes) return;\n\n\tgf_bs_align(bs);\n\n\t/*special case for file skipping...*/\n\tif ((bs->bsmode == GF_BITSTREAM_FILE_WRITE) || (bs->bsmode == GF_BITSTREAM_FILE_READ)) {\n\t\tif (bs->cache_write)\n\t\t\tbs_flush_write_cache(bs);\n\n\t\tif (bs->cache_read) {\n\t\t\tu32 csize = bs->cache_read_size - bs->cache_read_pos;\n\t\t\tif (csize>=nbBytes) {\n\t\t\t\tbs->cache_read_pos += (u32) nbBytes;\n\t\t\t\tbs->position += nbBytes;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnbBytes -= csize;\n\t\t\tbs->position += csize;\n\t\t\tbs->cache_read_pos = bs->cache_read_size;\n\t\t}\n\t\t//weird msys2 bug resulting in broken seek on some files ?!?  -the bug is not happening when doing absolute seek\n//\t\tgf_fseek(bs->stream, nbBytes, SEEK_CUR);\n\t\tbs->position += nbBytes;\n\t\tif (bs->bsmode == GF_BITSTREAM_FILE_READ) {\n\t\t\tif (bs->position > bs->size) bs->position = bs->size;\n\t\t}\n\t\tgf_fseek(bs->stream, bs->position, SEEK_SET);\n\t\treturn;\n\t}\n\n\t/*special case for reading*/\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\twhile (nbBytes) {\n\t\t\t\tgf_bs_read_u8(bs);\n\t\t\t\tnbBytes--;\n\t\t\t}\n\t\t} else {\n\t\t\tbs->position += nbBytes;\n\t\t}\n\t\treturn;\n\t}\n\t/*for writing we must do it this way, otherwise pb in dynamic buffers*/\n\twhile (nbBytes) {\n\t\tgf_bs_write_int(bs, 0, 8);\n\t\tnbBytes--;\n\t}\n}\n\n#ifdef GPAC_ENABLE_BIFS_PMF\n\nvoid gf_bs_rewind_bits(GF_BitStream *bs, u64 nbBits)\n{\n\tu64 nbBytes;\n\tif (bs->bsmode != GF_BITSTREAM_READ) return;\n\n\tnbBits -= (bs->nbBits);\n\tnbBytes = (nbBits+8)>>3;\n\tnbBits = nbBytes*8 - nbBits;\n\tgf_bs_align(bs);\n\tassert(bs->position >= nbBytes);\n\tbs->position -= nbBytes + 1;\n\tgf_bs_read_int(bs, (u32)nbBits);\n\treturn;\n}\n\n#endif\n\n/*seek from beginning of stream: use internally even when non aligned!*/\nstatic GF_Err BS_SeekIntern(GF_BitStream *bs, u64 offset)\n{\n\tu32 i;\n\t/*if mem, do it */\n\tif ((bs->bsmode == GF_BITSTREAM_READ) || (bs->bsmode == GF_BITSTREAM_WRITE) || (bs->bsmode == GF_BITSTREAM_WRITE_DYN)) {\n\t\tif (offset > 0xFFFFFFFF) return GF_IO_ERR;\n\t\tif (!bs->original) return GF_BAD_PARAM;\n\t\t/*0 for write, read will be done automatically*/\n\t\tif (offset >= bs->size) {\n\t\t\tif ( (bs->bsmode == GF_BITSTREAM_READ) || (bs->bsmode == GF_BITSTREAM_WRITE) ) {\n\t\t\t\tif (offset > bs->size) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"[BS] Attempt to seek to %d after end of bitstream %d, assuming seek to end\\n\", offset, bs->size));\n\t\t\t\t}\n\t\t\t\tbs->position = bs->size;\n\t\t\t\tbs->nbBits = (bs->bsmode == GF_BITSTREAM_READ) ? 8 : 0;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\t/*in DYN, gf_realloc ...*/\n\t\t\tbs->original = (char*)gf_realloc(bs->original, (u32) (offset + 1));\n\t\t\tif (!bs->original)\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\tfor (i = 0; i < (u32) (offset + 1 - bs->size); i++) {\n\t\t\t\tbs->original[bs->size + i] = 0;\n\t\t\t}\n\t\t\tbs->size = offset + 1;\n\t\t}\n\t\tbs->current = bs->original[offset];\n\t\tbs->position = offset;\n\t\tbs->nbBits = (bs->bsmode == GF_BITSTREAM_READ) ? 8 : 0;\n\t\treturn GF_OK;\n\t}\n\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\n\tif (bs->cache_read) {\n\t\tbs->cache_read_pos = bs->cache_read_size;\n\t}\n\n\tgf_fseek(bs->stream, offset, SEEK_SET);\n\n\tbs->position = offset;\n\tbs->current = 0;\n\t/*setup NbBits so that next acccess to the buffer will trigger read/write*/\n\tbs->nbBits = (bs->bsmode == GF_BITSTREAM_FILE_READ) ? 8 : 0;\n\treturn GF_OK;\n}\n\n/*seek from beginning of stream: align before anything else*/\nGF_EXPORT\nGF_Err gf_bs_seek(GF_BitStream *bs, u64 offset)\n{\n\tbs->overflow_state = 0;\n\tif (bs->on_block_out) {\n\t\tGF_Err e;\n\t\tif (offset < bs->bytes_out) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to seek on byte range already forwarded\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\t/*warning: we allow offset = bs->size for WRITE buffers*/\n\t\tif (offset - bs->bytes_out > bs->size)\n\t\t\treturn GF_BAD_PARAM;\n\t\tgf_bs_align(bs);\n\t\te = BS_SeekIntern(bs, offset - bs->bytes_out);\n\t\tbs->position += bs->bytes_out;\n\t\treturn e;\n\t}\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\n\t/*warning: we allow offset = bs->size for WRITE buffers*/\n\tif (offset > bs->size) return GF_BAD_PARAM;\n\n\tgf_bs_align(bs);\n\treturn BS_SeekIntern(bs, offset);\n}\n\n/*peek bits (as int!!) from orig position (ON BYTE BOUNDARIES, from 0) - only for read ...*/\nGF_EXPORT\nu32 gf_bs_peek_bits(GF_BitStream *bs, u32 numBits, u64 byte_offset)\n{\n\tu64 curPos;\n\tu32 curBits, ret, current, nb_zeros;\n\n\tif ( (bs->bsmode != GF_BITSTREAM_READ) && (bs->bsmode != GF_BITSTREAM_FILE_READ)) return 0;\n\tif (!numBits || (bs->size < bs->position + byte_offset)) return 0;\n\n\t/*store our state*/\n\tcurPos = bs->position;\n\tcurBits = bs->nbBits;\n\tcurrent = bs->current;\n\tnb_zeros = bs->nb_zeros;\n\n\tif (byte_offset) {\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\twhile (byte_offset) {\n\t\t\t\tgf_bs_read_int(bs, 8);\n\t\t\t\tbyte_offset--;\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bs_seek(bs, bs->position + byte_offset);\n\t\t}\n\t}\n\tret = gf_bs_read_int(bs, numBits);\n\n\t/*restore our cache - position*/\n\tgf_bs_seek(bs, curPos);\n\t/*to avoid re-reading our bits ...*/\n\tbs->nbBits = curBits;\n\tbs->current = current;\n\tbs->nb_zeros = nb_zeros;\n\treturn ret;\n}\n\nGF_EXPORT\nu64 gf_bs_get_refreshed_size(GF_BitStream *bs)\n{\n\ts64 offset;\n\n\tswitch (bs->bsmode) {\n\tcase GF_BITSTREAM_READ:\n\tcase GF_BITSTREAM_WRITE:\n\t\treturn bs->size;\n\n\tdefault:\n\t\tif (bs->cache_write)\n\t\t\tbs_flush_write_cache(bs);\n\n\t\tif (bs->stream) {\n\t\t\toffset = gf_ftell(bs->stream);\n\t\t\tbs->size = gf_fsize(bs->stream);\n\t\t\tgf_fseek(bs->stream, offset, SEEK_SET);\n\t\t}\n\t\treturn bs->size;\n\t}\n}\n\nGF_EXPORT\nu64 gf_bs_get_size(GF_BitStream *bs)\n{\n\tif (bs->cache_write) {\n\t\tif (bs->size == bs->position)\n\t\t\treturn bs->size + bs->buffer_written;\n\t\telse\n\t\t\treturn bs->size;\n\t}\n\tif (bs->on_block_out)\n\t\treturn bs->position;\n\treturn bs->size;\n}\n\nGF_EXPORT\nu64 gf_bs_get_position(GF_BitStream *bs)\n{\n\tif (bs->cache_write)\n\t\treturn bs->position + bs->buffer_written;\n\treturn bs->position;\n}\n\nGF_EXPORT\nu8 gf_bs_bits_available(GF_BitStream *bs)\n{\n\tif (bs->size > bs->position) return 8;\n\tif (bs->nbBits < 8) return (8-bs->nbBits);\n\treturn 0;\n}\n\nGF_EXPORT\nvoid gf_bs_set_eos_callback(GF_BitStream *bs, void (*EndOfStream)(void *par), void *par)\n{\n\tbs->EndOfStream = EndOfStream;\n\tbs->par = par;\n}\n\n\nGF_EXPORT\nu64 gf_bs_read_u64_le(GF_BitStream *bs)\n{\n\tu64 ret, v;\n\tret = gf_bs_read_int(bs, 8);\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=8;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=16;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=24;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=32;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=40;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=48;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=56;\n\tret |= v;\n\treturn ret;\n}\n\nGF_EXPORT\nu32 gf_bs_read_u32_le(GF_BitStream *bs)\n{\n\tu32 ret, v;\n\tret = gf_bs_read_int(bs, 8);\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=8;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=16;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=24;\n\tret |= v;\n\treturn ret;\n}\n\nGF_EXPORT\nu16 gf_bs_read_u16_le(GF_BitStream *bs)\n{\n\tu32 ret, v;\n\tret = gf_bs_read_int(bs, 8);\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=8;\n\tret |= v;\n\treturn ret;\n}\n\nGF_EXPORT\nvoid gf_bs_write_u64_le(GF_BitStream *bs, u64 val)\n{\n\tgf_bs_write_int(bs, val & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>8) & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>16) & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>24) & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>32) & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>40) & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>48) & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>56) & 0xFF, 8);\n}\n\nGF_EXPORT\nvoid gf_bs_write_u32_le(GF_BitStream *bs, u32 val)\n{\n\tgf_bs_write_int(bs, val & 0xFF, 8);\n\tgf_bs_write_int(bs, val>>8, 8);\n\tgf_bs_write_int(bs, val>>16, 8);\n\tgf_bs_write_int(bs, val>>24, 8);\n}\n\nGF_EXPORT\nvoid gf_bs_write_u16_le(GF_BitStream *bs, u32 val)\n{\n\tgf_bs_write_int(bs, val & 0xFF, 8);\n\tgf_bs_write_int(bs, val>>8, 8);\n}\n\nGF_EXPORT\nu32 gf_bs_get_bit_offset(GF_BitStream *bs)\n{\n\tif (bs->bsmode==GF_BITSTREAM_READ) return (u32) ( (bs->position - 1) * 8 + bs->nbBits);\n\treturn (u32) ( (bs->position ) * 8 + bs->nbBits);\n}\n\nGF_EXPORT\nu32 gf_bs_get_bit_position(GF_BitStream *bs)\n{\n\treturn bs->nbBits;\n}\n\nGF_EXPORT\nu32 gf_bs_read_vluimsbf5(GF_BitStream *bs)\n{\n\tu32 nb_words = 0;\n\twhile (gf_bs_read_int(bs, 1)) nb_words++;\n\tnb_words++;\n\treturn gf_bs_read_int(bs, 4*nb_words);\n}\n\nGF_EXPORT\nvoid gf_bs_truncate(GF_BitStream *bs)\n{\n\tbs->size = bs->position;\n}\n\n\nGF_EXPORT\nGF_Err gf_bs_transfer(GF_BitStream *dst, GF_BitStream *src, Bool keep_src)\n{\n\tu8 *data;\n\tu32 data_len, written;\n\n\tdata = NULL;\n\tdata_len = 0;\n\tgf_bs_get_content(src, &data, &data_len);\n\tif (!data || !data_len)\n\t{\n\t\tif (data) {\n\t\t\tif (keep_src) {\n\t\t\t\tsrc->original = data;\n\t\t\t\tsrc->size = data_len;\n\t\t\t} else {\n\t\t\t\tgf_free(data);\n\t\t\t}\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\twritten = gf_bs_write_data(dst, data, data_len);\n\tif (keep_src) {\n\t\tsrc->original = data;\n\t\tsrc->size = data_len;\n\t} else {\n\t\tgf_free(data);\n\t}\n\tif (written<data_len) return GF_IO_ERR;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_bs_flush(GF_BitStream *bs)\n{\n\tif (!bs->stream) return;\n\tif (bs->bsmode != GF_BITSTREAM_FILE_WRITE) return;\n\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\n\tgf_fflush(bs->stream);\n}\n\n#if 0 //unused\n/*!\n\\brief Reassigns FILE object for stream-based bitstreams\n *\n *Reassigns FILE object for stream-based bitstreams. Automatically sets the stream position to the bitstream position\n\\param bs the target bitstream\n\\param stream the new stream to assign\n */\nvoid gf_bs_reassign(GF_BitStream *bs, FILE *stream)\n{\n\tif (!bs) return;\n\tswitch (bs->bsmode) {\n\tcase GF_BITSTREAM_FILE_WRITE:\n\tcase GF_BITSTREAM_FILE_READ:\n\t\tbs->stream = stream;\n\t\tif (gf_ftell(stream) != bs->position)\n\t\t\tgf_bs_seek(bs, bs->position);\n\t\tbreak;\n\t}\n}\n#endif\n\nu64 gf_bs_set_cookie(GF_BitStream *bs, u64 cookie)\n{\n\tu64 res = 0;\n\tif (bs) {\n\t\tres = bs->cookie;\n\t\tbs->cookie = cookie;\n\t}\n\treturn res;\n}\n\nu64 gf_bs_get_cookie(GF_BitStream *bs)\n{\n\tif (!bs) return 0;\n\treturn bs->cookie;\n}\n\nGF_EXPORT\nGF_Err gf_bs_insert_data(GF_BitStream *bs, u8 *data, u32 size, u64 offset)\n{\n\tu64 cur_r, cur_w, pos;\n\tu32 nb_io;\n\n\tif (bs->on_block_out) return GF_BAD_PARAM;\n\n\tpos = bs->position;\n\tnb_io = gf_bs_write_data(bs, data, size);\n\tif (nb_io != size) goto exit;\n\n\tcur_w = bs->position;\n\tgf_bs_seek(bs, pos);\n\tcur_r = pos;\n\tpos = cur_w;\n\twhile (cur_r > offset) {\n\t\tu8 block[8196];\n\t\tu32 move_bytes = 8196;\n\t\tif (cur_r - offset < move_bytes)\n\t\t\tmove_bytes = (u32) (cur_r - offset);\n\n\t\tgf_bs_seek(bs, cur_r - move_bytes);\n\t\tnb_io = gf_bs_read_data(bs, block, move_bytes);\n\t\tif (nb_io != move_bytes) goto exit;\n\t\tgf_bs_seek(bs, cur_w - move_bytes);\n\t\tnb_io = gf_bs_write_data(bs, block, move_bytes);\n\t\tif (nb_io != move_bytes) goto exit;\n\t\tcur_r -= move_bytes;\n\t\tcur_w -= move_bytes;\n\t}\n\n\tgf_bs_seek(bs, offset);\n\tnb_io = gf_bs_write_data(bs, data, size);\n\tif (nb_io != size) goto exit;\n\n\tgf_bs_seek(bs, pos);\n\treturn GF_OK;\n\nexit:\n\tgf_bs_seek(bs, pos);\n\treturn GF_IO_ERR;\n}\n\n\nGF_Err gf_bs_set_logger(GF_BitStream *bs, void (*on_bs_log)(void *udta, const char *field_name, u32 nb_bits, u64 field_val, s32 idx1, s32 idx2, s32 idx3), void *udta)\n{\n\tif (!bs) return GF_BAD_PARAM;\n\tbs->on_log = on_bs_log;\n\tbs->log_udta = udta;\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_AVPARSE_LOGS\nvoid gf_bs_log_idx(GF_BitStream *bs, u32 nBits, const char *fname, s64 val, s32 idx1, s32 idx2, s32 idx3)\n{\n\tassert(bs);\n\tif (bs->on_log) bs->on_log(bs->log_udta, fname, nBits, val, idx1, idx2, idx3);\n}\n#endif\n\n\nvoid gf_bs_mark_overflow(GF_BitStream *bs, Bool reset)\n{\n\tbs->overflow_state = reset ? 0 : 2;\n}\nu32 gf_bs_is_overflow(GF_BitStream *bs)\n{\n\treturn bs->overflow_state;\n}\n"], "filenames": ["src/isomedia/avc_ext.c", "src/utils/bitstream.c"], "buggy_code_start_loc": [3525, 377], "buggy_code_end_loc": [3562, 412], "fixing_code_start_loc": [3526, 378], "fixing_code_end_loc": [3576, 418], "type": "CWE-617", "message": "In GPAC 2.1-DEV-rev87-g053aae8-master, function BS_ReadByte() in utils/bitstream.c has a failed assertion, which causes a Denial of Service. This vulnerability was fixed in commit 9ea93a2.", "other": {"cve": {"id": "CVE-2022-29339", "sourceIdentifier": "cve@mitre.org", "published": "2022-05-05T13:15:07.927", "lastModified": "2022-05-13T18:24:28.463", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In GPAC 2.1-DEV-rev87-g053aae8-master, function BS_ReadByte() in utils/bitstream.c has a failed assertion, which causes a Denial of Service. This vulnerability was fixed in commit 9ea93a2."}, {"lang": "es", "value": "En GPAC versi\u00f3n 2.1-DEV-rev87-g053aae8-master, la funci\u00f3n BS_ReadByte() en el archivo utils/bitstream.c presenta una aserci\u00f3n fallida, que causa una Denegaci\u00f3n de Servicio. Esta vulnerabilidad fue corregida en el commit 9ea93a2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-04-12", "matchCriteriaId": "A97931ED-0014-4D2C-969E-5B41DDFF9DD2"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/9ea93a2ec8f555ceed1ee27294cf94822f14f10f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/2165", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/9ea93a2ec8f555ceed1ee27294cf94822f14f10f"}}