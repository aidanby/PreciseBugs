{"buggy_code": ["/*\n   Unix SMB/Netbios implementation.\n   Version 1.9.\n   SMB parameters and setup\n   Copyright (C) Andrew Tridgell 1992-2000\n   Copyright (C) Luke Kenneth Casson Leighton 1996-2000\n   Modified by Jeremy Allison 1995.\n   Copyright (C) Andrew Bartlett <abartlet@samba.org> 2002-2003\n   Modified by Steve French (sfrench@us.ibm.com) 2002-2003\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n*/\n\n#include <crypto/skcipher.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/random.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n\n#ifndef false\n#define false 0\n#endif\n#ifndef true\n#define true 1\n#endif\n\n/* following came from the other byteorder.h to avoid include conflicts */\n#define CVAL(buf,pos) (((unsigned char *)(buf))[pos])\n#define SSVALX(buf,pos,val) (CVAL(buf,pos)=(val)&0xFF,CVAL(buf,pos+1)=(val)>>8)\n#define SSVAL(buf,pos,val) SSVALX((buf),(pos),((__u16)(val)))\n\nstatic void\nstr_to_key(unsigned char *str, unsigned char *key)\n{\n\tint i;\n\n\tkey[0] = str[0] >> 1;\n\tkey[1] = ((str[0] & 0x01) << 6) | (str[1] >> 2);\n\tkey[2] = ((str[1] & 0x03) << 5) | (str[2] >> 3);\n\tkey[3] = ((str[2] & 0x07) << 4) | (str[3] >> 4);\n\tkey[4] = ((str[3] & 0x0F) << 3) | (str[4] >> 5);\n\tkey[5] = ((str[4] & 0x1F) << 2) | (str[5] >> 6);\n\tkey[6] = ((str[5] & 0x3F) << 1) | (str[6] >> 7);\n\tkey[7] = str[6] & 0x7F;\n\tfor (i = 0; i < 8; i++)\n\t\tkey[i] = (key[i] << 1);\n}\n\nstatic int\nsmbhash(unsigned char *out, const unsigned char *in, unsigned char *key)\n{\n\tint rc;\n\tunsigned char key2[8];\n\tstruct crypto_skcipher *tfm_des;\n\tstruct scatterlist sgin, sgout;\n\tstruct skcipher_request *req;\n\n\tstr_to_key(key, key2);\n\n\ttfm_des = crypto_alloc_skcipher(\"ecb(des)\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm_des)) {\n\t\trc = PTR_ERR(tfm_des);\n\t\tcifs_dbg(VFS, \"could not allocate des crypto API\\n\");\n\t\tgoto smbhash_err;\n\t}\n\n\treq = skcipher_request_alloc(tfm_des, GFP_KERNEL);\n\tif (!req) {\n\t\trc = -ENOMEM;\n\t\tcifs_dbg(VFS, \"could not allocate des crypto API\\n\");\n\t\tgoto smbhash_free_skcipher;\n\t}\n\n\tcrypto_skcipher_setkey(tfm_des, key2, 8);\n\n\tsg_init_one(&sgin, in, 8);\n\tsg_init_one(&sgout, out, 8);\n\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, &sgin, &sgout, 8, NULL);\n\n\trc = crypto_skcipher_encrypt(req);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"could not encrypt crypt key rc: %d\\n\", rc);\n\n\tskcipher_request_free(req);\n\nsmbhash_free_skcipher:\n\tcrypto_free_skcipher(tfm_des);\nsmbhash_err:\n\treturn rc;\n}\n\nstatic int\nE_P16(unsigned char *p14, unsigned char *p16)\n{\n\tint rc;\n\tunsigned char sp8[8] =\n\t    { 0x4b, 0x47, 0x53, 0x21, 0x40, 0x23, 0x24, 0x25 };\n\n\trc = smbhash(p16, sp8, p14);\n\tif (rc)\n\t\treturn rc;\n\trc = smbhash(p16 + 8, sp8, p14 + 7);\n\treturn rc;\n}\n\nstatic int\nE_P24(unsigned char *p21, const unsigned char *c8, unsigned char *p24)\n{\n\tint rc;\n\n\trc = smbhash(p24, c8, p21);\n\tif (rc)\n\t\treturn rc;\n\trc = smbhash(p24 + 8, c8, p21 + 7);\n\tif (rc)\n\t\treturn rc;\n\trc = smbhash(p24 + 16, c8, p21 + 14);\n\treturn rc;\n}\n\n/* produce a md4 message digest from data of length n bytes */\nint\nmdfour(unsigned char *md4_hash, unsigned char *link_str, int link_len)\n{\n\tint rc;\n\tunsigned int size;\n\tstruct crypto_shash *md4;\n\tstruct sdesc *sdescmd4;\n\n\tmd4 = crypto_alloc_shash(\"md4\", 0, 0);\n\tif (IS_ERR(md4)) {\n\t\trc = PTR_ERR(md4);\n\t\tcifs_dbg(VFS, \"%s: Crypto md4 allocation error %d\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(md4);\n\tsdescmd4 = kmalloc(size, GFP_KERNEL);\n\tif (!sdescmd4) {\n\t\trc = -ENOMEM;\n\t\tgoto mdfour_err;\n\t}\n\tsdescmd4->shash.tfm = md4;\n\tsdescmd4->shash.flags = 0x0;\n\n\trc = crypto_shash_init(&sdescmd4->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init md4 shash\\n\", __func__);\n\t\tgoto mdfour_err;\n\t}\n\trc = crypto_shash_update(&sdescmd4->shash, link_str, link_len);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with link_str\\n\", __func__);\n\t\tgoto mdfour_err;\n\t}\n\trc = crypto_shash_final(&sdescmd4->shash, md4_hash);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md4 hash\\n\", __func__);\n\nmdfour_err:\n\tcrypto_free_shash(md4);\n\tkfree(sdescmd4);\n\n\treturn rc;\n}\n\n/*\n   This implements the X/Open SMB password encryption\n   It takes a password, a 8 byte \"crypt key\" and puts 24 bytes of\n   encrypted password into p24 */\n/* Note that password must be uppercased and null terminated */\nint\nSMBencrypt(unsigned char *passwd, const unsigned char *c8, unsigned char *p24)\n{\n\tint rc;\n\tunsigned char p14[14], p16[16], p21[21];\n\n\tmemset(p14, '\\0', 14);\n\tmemset(p16, '\\0', 16);\n\tmemset(p21, '\\0', 21);\n\n\tmemcpy(p14, passwd, 14);\n\trc = E_P16(p14, p16);\n\tif (rc)\n\t\treturn rc;\n\n\tmemcpy(p21, p16, 16);\n\trc = E_P24(p21, c8, p24);\n\n\treturn rc;\n}\n\n/*\n * Creates the MD4 Hash of the users password in NT UNICODE.\n */\n\nint\nE_md4hash(const unsigned char *passwd, unsigned char *p16,\n\tconst struct nls_table *codepage)\n{\n\tint rc;\n\tint len;\n\t__le16 wpwd[129];\n\n\t/* Password cannot be longer than 128 characters */\n\tif (passwd) /* Password must be converted to NT unicode */\n\t\tlen = cifs_strtoUTF16(wpwd, passwd, 128, codepage);\n\telse {\n\t\tlen = 0;\n\t\t*wpwd = 0; /* Ensure string is null terminated */\n\t}\n\n\trc = mdfour(p16, (unsigned char *) wpwd, len * sizeof(__le16));\n\tmemzero_explicit(wpwd, sizeof(wpwd));\n\n\treturn rc;\n}\n\n/* Does the NT MD4 hash then des encryption. */\nint\nSMBNTencrypt(unsigned char *passwd, unsigned char *c8, unsigned char *p24,\n\t\tconst struct nls_table *codepage)\n{\n\tint rc;\n\tunsigned char p16[16], p21[21];\n\n\tmemset(p16, '\\0', 16);\n\tmemset(p21, '\\0', 21);\n\n\trc = E_md4hash(passwd, p16, codepage);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s Can't generate NT hash, error: %d\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\tmemcpy(p21, p16, 16);\n\trc = E_P24(p21, c8, p24);\n\treturn rc;\n}\n"], "fixing_code": ["/*\n   Unix SMB/Netbios implementation.\n   Version 1.9.\n   SMB parameters and setup\n   Copyright (C) Andrew Tridgell 1992-2000\n   Copyright (C) Luke Kenneth Casson Leighton 1996-2000\n   Modified by Jeremy Allison 1995.\n   Copyright (C) Andrew Bartlett <abartlet@samba.org> 2002-2003\n   Modified by Steve French (sfrench@us.ibm.com) 2002-2003\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n*/\n\n#include <linux/crypto.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/random.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n\n#ifndef false\n#define false 0\n#endif\n#ifndef true\n#define true 1\n#endif\n\n/* following came from the other byteorder.h to avoid include conflicts */\n#define CVAL(buf,pos) (((unsigned char *)(buf))[pos])\n#define SSVALX(buf,pos,val) (CVAL(buf,pos)=(val)&0xFF,CVAL(buf,pos+1)=(val)>>8)\n#define SSVAL(buf,pos,val) SSVALX((buf),(pos),((__u16)(val)))\n\nstatic void\nstr_to_key(unsigned char *str, unsigned char *key)\n{\n\tint i;\n\n\tkey[0] = str[0] >> 1;\n\tkey[1] = ((str[0] & 0x01) << 6) | (str[1] >> 2);\n\tkey[2] = ((str[1] & 0x03) << 5) | (str[2] >> 3);\n\tkey[3] = ((str[2] & 0x07) << 4) | (str[3] >> 4);\n\tkey[4] = ((str[3] & 0x0F) << 3) | (str[4] >> 5);\n\tkey[5] = ((str[4] & 0x1F) << 2) | (str[5] >> 6);\n\tkey[6] = ((str[5] & 0x3F) << 1) | (str[6] >> 7);\n\tkey[7] = str[6] & 0x7F;\n\tfor (i = 0; i < 8; i++)\n\t\tkey[i] = (key[i] << 1);\n}\n\nstatic int\nsmbhash(unsigned char *out, const unsigned char *in, unsigned char *key)\n{\n\tunsigned char key2[8];\n\tstruct crypto_cipher *tfm_des;\n\n\tstr_to_key(key, key2);\n\n\ttfm_des = crypto_alloc_cipher(\"des\", 0, 0);\n\tif (IS_ERR(tfm_des)) {\n\t\tcifs_dbg(VFS, \"could not allocate des crypto API\\n\");\n\t\treturn PTR_ERR(tfm_des);\n\t}\n\n\tcrypto_cipher_setkey(tfm_des, key2, 8);\n\tcrypto_cipher_encrypt_one(tfm_des, out, in);\n\tcrypto_free_cipher(tfm_des);\n\n\treturn 0;\n}\n\nstatic int\nE_P16(unsigned char *p14, unsigned char *p16)\n{\n\tint rc;\n\tunsigned char sp8[8] =\n\t    { 0x4b, 0x47, 0x53, 0x21, 0x40, 0x23, 0x24, 0x25 };\n\n\trc = smbhash(p16, sp8, p14);\n\tif (rc)\n\t\treturn rc;\n\trc = smbhash(p16 + 8, sp8, p14 + 7);\n\treturn rc;\n}\n\nstatic int\nE_P24(unsigned char *p21, const unsigned char *c8, unsigned char *p24)\n{\n\tint rc;\n\n\trc = smbhash(p24, c8, p21);\n\tif (rc)\n\t\treturn rc;\n\trc = smbhash(p24 + 8, c8, p21 + 7);\n\tif (rc)\n\t\treturn rc;\n\trc = smbhash(p24 + 16, c8, p21 + 14);\n\treturn rc;\n}\n\n/* produce a md4 message digest from data of length n bytes */\nint\nmdfour(unsigned char *md4_hash, unsigned char *link_str, int link_len)\n{\n\tint rc;\n\tunsigned int size;\n\tstruct crypto_shash *md4;\n\tstruct sdesc *sdescmd4;\n\n\tmd4 = crypto_alloc_shash(\"md4\", 0, 0);\n\tif (IS_ERR(md4)) {\n\t\trc = PTR_ERR(md4);\n\t\tcifs_dbg(VFS, \"%s: Crypto md4 allocation error %d\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(md4);\n\tsdescmd4 = kmalloc(size, GFP_KERNEL);\n\tif (!sdescmd4) {\n\t\trc = -ENOMEM;\n\t\tgoto mdfour_err;\n\t}\n\tsdescmd4->shash.tfm = md4;\n\tsdescmd4->shash.flags = 0x0;\n\n\trc = crypto_shash_init(&sdescmd4->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init md4 shash\\n\", __func__);\n\t\tgoto mdfour_err;\n\t}\n\trc = crypto_shash_update(&sdescmd4->shash, link_str, link_len);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with link_str\\n\", __func__);\n\t\tgoto mdfour_err;\n\t}\n\trc = crypto_shash_final(&sdescmd4->shash, md4_hash);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md4 hash\\n\", __func__);\n\nmdfour_err:\n\tcrypto_free_shash(md4);\n\tkfree(sdescmd4);\n\n\treturn rc;\n}\n\n/*\n   This implements the X/Open SMB password encryption\n   It takes a password, a 8 byte \"crypt key\" and puts 24 bytes of\n   encrypted password into p24 */\n/* Note that password must be uppercased and null terminated */\nint\nSMBencrypt(unsigned char *passwd, const unsigned char *c8, unsigned char *p24)\n{\n\tint rc;\n\tunsigned char p14[14], p16[16], p21[21];\n\n\tmemset(p14, '\\0', 14);\n\tmemset(p16, '\\0', 16);\n\tmemset(p21, '\\0', 21);\n\n\tmemcpy(p14, passwd, 14);\n\trc = E_P16(p14, p16);\n\tif (rc)\n\t\treturn rc;\n\n\tmemcpy(p21, p16, 16);\n\trc = E_P24(p21, c8, p24);\n\n\treturn rc;\n}\n\n/*\n * Creates the MD4 Hash of the users password in NT UNICODE.\n */\n\nint\nE_md4hash(const unsigned char *passwd, unsigned char *p16,\n\tconst struct nls_table *codepage)\n{\n\tint rc;\n\tint len;\n\t__le16 wpwd[129];\n\n\t/* Password cannot be longer than 128 characters */\n\tif (passwd) /* Password must be converted to NT unicode */\n\t\tlen = cifs_strtoUTF16(wpwd, passwd, 128, codepage);\n\telse {\n\t\tlen = 0;\n\t\t*wpwd = 0; /* Ensure string is null terminated */\n\t}\n\n\trc = mdfour(p16, (unsigned char *) wpwd, len * sizeof(__le16));\n\tmemzero_explicit(wpwd, sizeof(wpwd));\n\n\treturn rc;\n}\n\n/* Does the NT MD4 hash then des encryption. */\nint\nSMBNTencrypt(unsigned char *passwd, unsigned char *c8, unsigned char *p24,\n\t\tconst struct nls_table *codepage)\n{\n\tint rc;\n\tunsigned char p16[16], p21[21];\n\n\tmemset(p16, '\\0', 16);\n\tmemset(p21, '\\0', 21);\n\n\trc = E_md4hash(passwd, p16, codepage);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s Can't generate NT hash, error: %d\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\tmemcpy(p21, p16, 16);\n\trc = E_P24(p21, c8, p24);\n\treturn rc;\n}\n"], "filenames": ["fs/cifs/smbencrypt.c"], "buggy_code_start_loc": [26], "buggy_code_end_loc": [112], "fixing_code_start_loc": [26], "fixing_code_end_loc": [88], "type": "CWE-119", "message": "The smbhash function in fs/cifs/smbencrypt.c in the Linux kernel 4.9.x before 4.9.1 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a scatterlist.", "other": {"cve": {"id": "CVE-2016-10154", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-06T06:59:00.310", "lastModified": "2017-02-09T21:55:39.400", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The smbhash function in fs/cifs/smbencrypt.c in the Linux kernel 4.9.x before 4.9.1 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a scatterlist."}, {"lang": "es", "value": "La funci\u00f3n smbhash en fs/cifs/smbencrypt.c en el kernel de Linux 4.9.x en versiones anteriores a 4.9.1 interact\u00faa incorrectamente con la opci\u00f3n CONFIG_VMAP_STACK, que permite a usuarios locales provocar una denegaci\u00f3n de servicio (ca\u00edda del sistema o corrupci\u00f3n de memoria) o posiblemente tener otro impacto no especificado aprovechando el uso de m\u00e1s de una p\u00e1gina virtual para una lista de dispersi\u00f3n ."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9:*:*:*:*:*:*:*", "matchCriteriaId": "27B10B33-5F64-4039-8351-694A7AB6E4E4"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=06deeec77a5a689cc94b21a8a91a76e42176685d", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.9.1", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/21/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95714", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1416104", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/torvalds/linux/commit/06deeec77a5a689cc94b21a8a91a76e42176685d", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/06deeec77a5a689cc94b21a8a91a76e42176685d"}}