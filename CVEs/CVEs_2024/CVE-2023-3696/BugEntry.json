{"buggy_code": ["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\nconst InternalCache = require('./internal');\nconst MongooseError = require('./error/index');\nconst MixedSchema = require('./schema/mixed');\nconst ObjectExpectedError = require('./error/objectExpected');\nconst ObjectParameterError = require('./error/objectParameter');\nconst ParallelValidateError = require('./error/parallelValidate');\nconst Schema = require('./schema');\nconst StrictModeError = require('./error/strict');\nconst ValidationError = require('./error/validation');\nconst ValidatorError = require('./error/validator');\nconst $__hasIncludedChildren = require('./helpers/projection/hasIncludedChildren');\nconst promiseOrCallback = require('./helpers/promiseOrCallback');\nconst applyDefaults = require('./helpers/document/applyDefaults');\nconst cleanModifiedSubpaths = require('./helpers/document/cleanModifiedSubpaths');\nconst compile = require('./helpers/document/compile').compile;\nconst defineKey = require('./helpers/document/compile').defineKey;\nconst flatten = require('./helpers/common').flatten;\nconst flattenObjectWithDottedPaths = require('./helpers/path/flattenObjectWithDottedPaths');\nconst get = require('./helpers/get');\nconst getEmbeddedDiscriminatorPath = require('./helpers/document/getEmbeddedDiscriminatorPath');\nconst getKeysInSchemaOrder = require('./helpers/schema/getKeysInSchemaOrder');\nconst handleSpreadDoc = require('./helpers/document/handleSpreadDoc');\nconst immediate = require('./helpers/immediate');\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\nconst isExclusive = require('./helpers/projection/isExclusive');\nconst inspect = require('util').inspect;\nconst internalToObjectOptions = require('./options').internalToObjectOptions;\nconst markArraySubdocsPopulated = require('./helpers/populate/markArraySubdocsPopulated');\nconst mpath = require('mpath');\nconst queryhelpers = require('./queryhelpers');\nconst utils = require('./utils');\nconst isPromise = require('./helpers/isPromise');\n\nconst clone = utils.clone;\nconst deepEqual = utils.deepEqual;\nconst isMongooseObject = utils.isMongooseObject;\n\nconst arrayAtomicsBackupSymbol = require('./helpers/symbols').arrayAtomicsBackupSymbol;\nconst arrayAtomicsSymbol = require('./helpers/symbols').arrayAtomicsSymbol;\nconst documentArrayParent = require('./helpers/symbols').documentArrayParent;\nconst documentIsModified = require('./helpers/symbols').documentIsModified;\nconst documentModifiedPaths = require('./helpers/symbols').documentModifiedPaths;\nconst documentSchemaSymbol = require('./helpers/symbols').documentSchemaSymbol;\nconst getSymbol = require('./helpers/symbols').getSymbol;\nconst populateModelSymbol = require('./helpers/symbols').populateModelSymbol;\nconst scopeSymbol = require('./helpers/symbols').scopeSymbol;\nconst schemaMixedSymbol = require('./schema/symbols').schemaMixedSymbol;\nconst parentPaths = require('./helpers/path/parentPaths');\n\nlet DocumentArray;\nlet MongooseArray;\nlet Embedded;\n\nconst specialProperties = utils.specialProperties;\n\n/**\n * The core Mongoose document constructor. You should not call this directly,\n * the Mongoose [Model constructor](./api/model.html#Model) calls this for you.\n *\n * @param {Object} obj the values to set\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Object} [options] various configuration options for the document\n * @param {Boolean} [options.defaults=true] if `false`, skip applying default values to this document.\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\n * @event `init`: Emitted on a document after it has been retrieved from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, fields, skipId, options) {\n  if (typeof skipId === 'object' && skipId != null) {\n    options = skipId;\n    skipId = options.skipId;\n  }\n  options = Object.assign({}, options);\n\n  // Support `browserDocument.js` syntax\n  if (this.$__schema == null) {\n    const _schema = utils.isObject(fields) && !fields.instanceOfSchema ?\n      new Schema(fields) :\n      fields;\n    this.$__setSchema(_schema);\n    fields = skipId;\n    skipId = options;\n    options = arguments[4] || {};\n  }\n\n  this.$__ = new InternalCache();\n\n  // Avoid setting `isNew` to `true`, because it is `true` by default\n  if (options.isNew != null && options.isNew !== true) {\n    this.$isNew = options.isNew;\n  }\n\n  if (options.priorDoc != null) {\n    this.$__.priorDoc = options.priorDoc;\n  }\n\n  if (skipId) {\n    this.$__.skipId = skipId;\n  }\n\n  if (obj != null && typeof obj !== 'object') {\n    throw new ObjectParameterError(obj, 'obj', 'Document');\n  }\n\n  let defaults = true;\n  if (options.defaults !== undefined) {\n    this.$__.defaults = options.defaults;\n    defaults = options.defaults;\n  }\n\n  const schema = this.$__schema;\n\n  if (typeof fields === 'boolean' || fields === 'throw') {\n    if (fields !== true) {\n      this.$__.strictMode = fields;\n    }\n    fields = undefined;\n  } else if (schema.options.strict !== true) {\n    this.$__.strictMode = schema.options.strict;\n  }\n\n  const requiredPaths = schema.requiredPaths(true);\n  for (const path of requiredPaths) {\n    this.$__.activePaths.require(path);\n  }\n\n  let exclude = null;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n  if (utils.isPOJO(fields) && Object.keys(fields).length > 0) {\n    exclude = isExclusive(fields);\n    this.$__.selected = fields;\n    this.$__.exclude = exclude;\n  }\n\n  const hasIncludedChildren = exclude === false && fields ?\n    $__hasIncludedChildren(fields) :\n    null;\n\n  if (this._doc == null) {\n    this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);\n\n    // By default, defaults get applied **before** setting initial values\n    // Re: gh-6155\n    if (defaults) {\n      applyDefaults(this, fields, exclude, hasIncludedChildren, true, null);\n    }\n  }\n  if (obj) {\n    // Skip set hooks\n    if (this.$__original_set) {\n      this.$__original_set(obj, undefined, true, options);\n    } else {\n      this.$set(obj, undefined, true, options);\n    }\n\n    if (obj instanceof Document) {\n      this.$isNew = obj.$isNew;\n    }\n  }\n\n  // Function defaults get applied **after** setting initial values so they\n  // see the full doc rather than an empty one, unless they opt out.\n  // Re: gh-3781, gh-6155\n  if (options.willInit && defaults) {\n    if (options.skipDefaults) {\n      this.$__.skipDefaults = options.skipDefaults;\n    }\n  } else if (defaults) {\n    applyDefaults(this, fields, exclude, hasIncludedChildren, false, options.skipDefaults);\n  }\n\n  if (!this.$__.strictMode && obj) {\n    const _this = this;\n    const keys = Object.keys(this._doc);\n\n    keys.forEach(function(key) {\n      // Avoid methods, virtuals, existing fields, and `$` keys. The latter is to avoid overwriting\n      // Mongoose internals.\n      if (!(key in schema.tree) && !(key in schema.methods) && !(key in schema.virtuals) && !key.startsWith('$')) {\n        defineKey({ prop: key, subprops: null, prototype: _this });\n      }\n    });\n  }\n\n  applyQueue(this);\n}\n\nDocument.prototype.$isMongooseDocumentPrototype = true;\n\n/**\n * Boolean flag specifying if the document is new. If you create a document\n * using `new`, this document will be considered \"new\". `$isNew` is how\n * Mongoose determines whether `save()` should use `insertOne()` to create\n * a new document or `updateOne()` to update an existing document.\n *\n * #### Example:\n *\n *     const user = new User({ name: 'John Smith' });\n *     user.$isNew; // true\n *\n *     await user.save(); // Sends an `insertOne` to MongoDB\n *\n * On the other hand, if you load an existing document from the database\n * using `findOne()` or another [query operation](/docs/queries.html),\n * `$isNew` will be false.\n *\n * #### Example:\n *\n *     const user = await User.findOne({ name: 'John Smith' });\n *     user.$isNew; // false\n *\n * Mongoose sets `$isNew` to `false` immediately after `save()` succeeds.\n * That means Mongoose sets `$isNew` to false **before** `post('save')` hooks run.\n * In `post('save')` hooks, `$isNew` will be `false` if `save()` succeeded.\n *\n * #### Example:\n *\n *     userSchema.post('save', function() {\n *       this.$isNew; // false\n *     });\n *     await User.create({ name: 'John Smith' });\n *\n * For subdocuments, `$isNew` is true if either the parent has `$isNew` set,\n * or if you create a new subdocument.\n *\n * #### Example:\n *\n *     // Assume `Group` has a document array `users`\n *     const group = await Group.findOne();\n *     group.users[0].$isNew; // false\n *\n *     group.users.push({ name: 'John Smith' });\n *     group.users[1].$isNew; // true\n *\n * @api public\n * @property $isNew\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, 'isNew', {\n  get: function() {\n    return this.$isNew;\n  },\n  set: function(value) {\n    this.$isNew = value;\n  }\n});\n\n/**\n * Hash containing current validation errors.\n *\n * @api public\n * @property errors\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, 'errors', {\n  get: function() {\n    return this.$errors;\n  },\n  set: function(value) {\n    this.$errors = value;\n  }\n});\n\n/*!\n * ignore\n */\n\nDocument.prototype.$isNew = true;\n\n/*!\n * Document exposes the NodeJS event emitter API, so you can use\n * `on`, `once`, etc.\n */\nutils.each(\n  ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',\n    'removeAllListeners', 'addListener'],\n  function(emitterFn) {\n    Document.prototype[emitterFn] = function() {\n      // Delay creating emitter until necessary because emitters take up a lot of memory,\n      // especially for subdocuments.\n      if (!this.$__.emitter) {\n        if (emitterFn === 'emit') {\n          return;\n        }\n        this.$__.emitter = new EventEmitter();\n        this.$__.emitter.setMaxListeners(0);\n      }\n      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n    };\n    Document.prototype[`$${emitterFn}`] = Document.prototype[emitterFn];\n  });\n\nDocument.prototype.constructor = Document;\n\nfor (const i in EventEmitter.prototype) {\n  Document[i] = EventEmitter.prototype[i];\n}\n\n/**\n * The document's internal schema.\n *\n * @api private\n * @property schema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__schema;\n\n/**\n * The document's schema.\n *\n * @api public\n * @property schema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.schema;\n\n/**\n * Empty object that you can use for storing properties on the document. This\n * is handy for passing data to middleware without conflicting with Mongoose\n * internals.\n *\n * #### Example:\n *\n *     schema.pre('save', function() {\n *       // Mongoose will set `isNew` to `false` if `save()` succeeds\n *       this.$locals.wasNew = this.isNew;\n *     });\n *\n *     schema.post('save', function() {\n *       // Prints true if `isNew` was set before `save()`\n *       console.log(this.$locals.wasNew);\n *     });\n *\n * @api public\n * @property $locals\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$locals', {\n  configurable: false,\n  enumerable: false,\n  get: function() {\n    if (this.$__.locals == null) {\n      this.$__.locals = {};\n    }\n    return this.$__.locals;\n  },\n  set: function(v) {\n    this.$__.locals = v;\n  }\n});\n\n/**\n * Legacy alias for `$isNew`.\n *\n * @api public\n * @property isNew\n * @memberOf Document\n * @see $isNew #document_Document-$isNew\n * @instance\n */\n\nDocument.prototype.isNew;\n\n/**\n * Set this property to add additional query filters when Mongoose saves this document and `isNew` is false.\n *\n * #### Example:\n *\n *     // Make sure `save()` never updates a soft deleted document.\n *     schema.pre('save', function() {\n *       this.$where = { isDeleted: false };\n *     });\n *\n * @api public\n * @property $where\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$where', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\n * The string version of this documents _id.\n *\n * #### Note:\n *\n * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.\n *\n *     new Schema({ name: String }, { id: false });\n *\n * @api public\n * @see Schema options /docs/guide.html#options\n * @property id\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.id;\n\n/**\n * Hash containing current validation $errors.\n *\n * @api public\n * @property $errors\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$errors;\n\n/**\n * A string containing the current operation that Mongoose is executing\n * on this document. May be `null`, `'save'`, `'validate'`, or `'remove'`.\n *\n * #### Example:\n *\n *     const doc = new Model({ name: 'test' });\n *     doc.$op; // null\n *\n *     const promise = doc.save();\n *     doc.$op; // 'save'\n *\n *     await promise;\n *     doc.$op; // null\n *\n * @api public\n * @property $op\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$op', {\n  get: function() {\n    return this.$__.op || null;\n  },\n  set: function(value) {\n    this.$__.op = value;\n  }\n});\n\n/*!\n * ignore\n */\n\nfunction $applyDefaultsToNested(val, path, doc) {\n  if (val == null) {\n    return;\n  }\n\n  flattenObjectWithDottedPaths(val);\n\n  const paths = Object.keys(doc.$__schema.paths);\n  const plen = paths.length;\n\n  const pathPieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n\n  for (let i = 0; i < plen; ++i) {\n    let curPath = '';\n    const p = paths[i];\n\n    if (!p.startsWith(path + '.')) {\n      continue;\n    }\n\n    const type = doc.$__schema.paths[p];\n    const pieces = type.splitPath().slice(pathPieces.length);\n    const len = pieces.length;\n\n    if (type.defaultValue === void 0) {\n      continue;\n    }\n\n    let cur = val;\n\n    for (let j = 0; j < len; ++j) {\n      if (cur == null) {\n        break;\n      }\n\n      const piece = pieces[j];\n\n      if (j === len - 1) {\n        if (cur[piece] !== void 0) {\n          break;\n        }\n\n        try {\n          const def = type.getDefault(doc, false);\n          if (def !== void 0) {\n            cur[piece] = def;\n          }\n        } catch (err) {\n          doc.invalidate(path + '.' + curPath, err);\n          break;\n        }\n\n        break;\n      }\n\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      cur[piece] = cur[piece] || {};\n      cur = cur[piece];\n    }\n  }\n}\n\n/**\n * Builds the default doc structure\n *\n * @param {Object} obj\n * @param {Object} [fields]\n * @param {Boolean} [skipId]\n * @param {Boolean} [exclude]\n * @param {Object} [hasIncludedChildren]\n * @api private\n * @method $__buildDoc\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__buildDoc = function(obj, fields, skipId, exclude, hasIncludedChildren) {\n  const doc = {};\n\n  const paths = Object.keys(this.$__schema.paths).\n    // Don't build up any paths that are underneath a map, we don't know\n    // what the keys will be\n    filter(p => !p.includes('$*'));\n  const plen = paths.length;\n  let ii = 0;\n\n  for (; ii < plen; ++ii) {\n    const p = paths[ii];\n\n    if (p === '_id') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && '_id' in obj) {\n        continue;\n      }\n    }\n\n    const path = this.$__schema.paths[p].splitPath();\n    const len = path.length;\n    const last = len - 1;\n    let curPath = '';\n    let doc_ = doc;\n    let included = false;\n\n    for (let i = 0; i < len; ++i) {\n      const piece = path[i];\n\n      if (!curPath.length) {\n        curPath = piece;\n      } else {\n        curPath += '.' + piece;\n      }\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i < last) {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  this._doc = doc;\n};\n\n/*!\n * Converts to POJO when you use the document for querying\n */\n\nDocument.prototype.toBSON = function() {\n  return this.toObject(internalToObjectOptions);\n};\n\n/**\n * Initializes the document without setters or marking anything modified.\n *\n * Called internally after a document is returned from mongodb. Normally,\n * you do **not** need to call this function on your own.\n *\n * This function triggers `init` [middleware](/docs/middleware.html).\n * Note that `init` hooks are [synchronous](/docs/middleware.html#synchronous).\n *\n * @param {Object} doc document returned by mongo\n * @param {Object} [opts]\n * @param {Function} [fn]\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.init = function(doc, opts, fn) {\n  if (typeof opts === 'function') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.$__init(doc, opts);\n\n  if (fn) {\n    fn(null, this);\n  }\n\n  return this;\n};\n\n/**\n * Alias for [`.init`](#document_Document-init)\n *\n * @api public\n */\n\nDocument.prototype.$init = function() {\n  return this.constructor.prototype.init.apply(this, arguments);\n};\n\n/**\n * Internal \"init\" function\n *\n * @param {Document} doc\n * @param {Object} [opts]\n * @returns {Document} this\n * @api private\n */\n\nDocument.prototype.$__init = function(doc, opts) {\n  this.$isNew = false;\n  opts = opts || {};\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id != null && opts.populated && opts.populated.length) {\n    const id = String(doc._id);\n    for (const item of opts.populated) {\n      if (item.isVirtual) {\n        this.$populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.$populated(item.path, item._docs[id], item);\n      }\n\n      if (item._childDocs == null) {\n        continue;\n      }\n      for (const child of item._childDocs) {\n        if (child == null || child.$__ == null) {\n          continue;\n        }\n        child.$__.parent = this;\n      }\n      item._childDocs = [];\n    }\n  }\n\n  init(this, doc, this._doc, opts);\n\n  markArraySubdocsPopulated(this, opts.populated);\n\n  this.$emit('init', this);\n  this.constructor.emit('init', this);\n\n  const hasIncludedChildren = this.$__.exclude === false && this.$__.selected ?\n    $__hasIncludedChildren(this.$__.selected) :\n    null;\n\n  applyDefaults(this, this.$__.selected, this.$__.exclude, hasIncludedChildren, false, this.$__.skipDefaults);\n\n  return this;\n};\n\n/**\n * Init helper.\n *\n * @param {Object} self document instance\n * @param {Object} obj raw mongodb doc\n * @param {Object} doc object we are initializing\n * @param {Object} [opts] Optional Options\n * @param {Boolean} [opts.setters] Call `applySetters` instead of `cast`\n * @param {String} [prefix] Prefix to add to each path\n * @api private\n */\n\nfunction init(self, obj, doc, opts, prefix) {\n  prefix = prefix || '';\n\n  if (obj.$__ != null) {\n    obj = obj._doc;\n  }\n  const keys = Object.keys(obj);\n  const len = keys.length;\n  let schemaType;\n  let path;\n  let i;\n  let index = 0;\n  const strict = self.$__.strictMode;\n  const docSchema = self.$__schema;\n\n  while (index < len) {\n    _init(index++);\n  }\n\n  function _init(index) {\n    i = keys[index];\n    path = prefix + i;\n    schemaType = docSchema.path(path);\n\n    // Should still work if not a model-level discriminator, but should not be\n    // necessary. This is *only* to catch the case where we queried using the\n    // base model and the discriminated model has a projection\n    if (docSchema.$isRootDiscriminator && !self.$__isSelected(path)) {\n      return;\n    }\n\n    if (!schemaType && utils.isPOJO(obj[i])) {\n      // assume nested object\n      if (!doc[i]) {\n        doc[i] = {};\n        if (!strict && !(i in docSchema.tree) && !(i in docSchema.methods) && !(i in docSchema.virtuals)) {\n          self[i] = doc[i];\n        }\n      }\n      init(self, obj[i], doc[i], opts, path + '.');\n    } else if (!schemaType) {\n      doc[i] = obj[i];\n      if (!strict && !prefix) {\n        self[i] = obj[i];\n      }\n    } else {\n      // Retain order when overwriting defaults\n      if (doc.hasOwnProperty(i) && obj[i] !== void 0) {\n        delete doc[i];\n      }\n      if (obj[i] === null) {\n        doc[i] = schemaType._castNullish(null);\n      } else if (obj[i] !== undefined) {\n        const wasPopulated = obj[i].$__ == null ? null : obj[i].$__.wasPopulated;\n\n        if (schemaType && !wasPopulated) {\n          try {\n            if (opts && opts.setters) {\n              // Call applySetters with `init = false` because otherwise setters are a noop\n              const overrideInit = false;\n              doc[i] = schemaType.applySetters(obj[i], self, overrideInit);\n            } else {\n              doc[i] = schemaType.cast(obj[i], self, true);\n            }\n          } catch (e) {\n            self.invalidate(e.path, new ValidatorError({\n              path: e.path,\n              message: e.message,\n              type: 'cast',\n              value: e.value,\n              reason: e\n            }));\n          }\n        } else {\n          doc[i] = obj[i];\n        }\n      }\n      // mark as hydrated\n      if (!self.$isModified(path)) {\n        self.$__.activePaths.init(path);\n      }\n    }\n  }\n}\n\n/**\n * Sends an update command with this document `_id` as the query selector.\n *\n * #### Example:\n *\n *     weirdCar.update({ $inc: { wheels:1 } }, { w: 1 }, callback);\n *\n * #### Valid options:\n *\n *  - same as in [Model.update](#model_Model-update)\n *\n * @see Model.update #model_Model-update\n * @param {...Object} ops\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query} this\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.update = function update() {\n  const args = [...arguments];\n  args.unshift({ _id: this._id });\n  const query = this.constructor.update.apply(this.constructor, args);\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  return query;\n};\n\n/**\n * Sends an updateOne command with this document `_id` as the query selector.\n *\n * #### Example:\n *\n *     weirdCar.updateOne({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * #### Valid options:\n *\n *  - same as in [Model.updateOne](#model_Model-updateOne)\n *\n * @see Model.updateOne #model_Model-updateOne\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#query_Query-setOptions)\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](/docs/api/query.html#query_Query-lean) and the [Mongoose lean tutorial](/docs/tutorials/lean.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.updateOne = function updateOne(doc, options, callback) {\n  const query = this.constructor.updateOne({ _id: this._id }, doc, options);\n  const self = this;\n  query.pre(function queryPreUpdateOne(cb) {\n    self.constructor._middleware.execPre('updateOne', self, [self], cb);\n  });\n  query.post(function queryPostUpdateOne(cb) {\n    self.constructor._middleware.execPost('updateOne', self, [self], {}, cb);\n  });\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  if (callback != null) {\n    return query.exec(callback);\n  }\n\n  return query;\n};\n\n/**\n * Sends a replaceOne command with this document `_id` as the query selector.\n *\n * #### Valid options:\n *\n *  - same as in [Model.replaceOne](https://mongoosejs.com/docs/api/model.html#model_Model-replaceOne)\n *\n * @see Model.replaceOne #model_Model-replaceOne\n * @param {Object} doc\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.replaceOne = function replaceOne() {\n  const args = [...arguments];\n  args.unshift({ _id: this._id });\n  return this.constructor.replaceOne.apply(this.constructor, args);\n};\n\n/**\n * Getter/setter around the session associated with this document. Used to\n * automatically set `session` if you `save()` a doc that you got from a\n * query with an associated session.\n *\n * #### Example:\n *\n *     const session = MyModel.startSession();\n *     const doc = await MyModel.findOne().session(session);\n *     doc.$session() === session; // true\n *     doc.$session(null);\n *     doc.$session() === null; // true\n *\n * If this is a top-level document, setting the session propagates to all child\n * docs.\n *\n * @param {ClientSession} [session] overwrite the current session\n * @return {ClientSession}\n * @method $session\n * @api public\n * @memberOf Document\n */\n\nDocument.prototype.$session = function $session(session) {\n  if (arguments.length === 0) {\n    if (this.$__.session != null && this.$__.session.hasEnded) {\n      this.$__.session = null;\n      return null;\n    }\n    return this.$__.session;\n  }\n\n  if (session != null && session.hasEnded) {\n    throw new MongooseError('Cannot set a document\\'s session to a session that has ended. Make sure you haven\\'t ' +\n      'called `endSession()` on the session you are passing to `$session()`.');\n  }\n\n  if (session == null && this.$__.session == null) {\n    return;\n  }\n\n  this.$__.session = session;\n\n  if (!this.$isSubdocument) {\n    const subdocs = this.$getAllSubdocs();\n    for (const child of subdocs) {\n      child.$session(session);\n    }\n  }\n\n  return session;\n};\n\n/**\n * Getter/setter around whether this document will apply timestamps by\n * default when using `save()` and `bulkSave()`.\n *\n * #### Example:\n *\n *     const TestModel = mongoose.model('Test', new Schema({ name: String }, { timestamps: true }));\n *     const doc = new TestModel({ name: 'John Smith' });\n *\n *     doc.$timestamps(); // true\n *\n *     doc.$timestamps(false);\n *     await doc.save(); // Does **not** apply timestamps\n *\n * @param {Boolean} [value] overwrite the current session\n * @return {Document|boolean|undefined} When used as a getter (no argument), a boolean will be returned indicating the timestamps option state or if unset \"undefined\" will be used, otherwise will return \"this\"\n * @method $timestamps\n * @api public\n * @memberOf Document\n */\n\nDocument.prototype.$timestamps = function $timestamps(value) {\n  if (arguments.length === 0) {\n    if (this.$__.timestamps != null) {\n      return this.$__.timestamps;\n    }\n\n    if (this.$__schema) {\n      return this.$__schema.options.timestamps;\n    }\n\n    return undefined;\n  }\n\n  const currentValue = this.$timestamps();\n  if (value !== currentValue) {\n    this.$__.timestamps = value;\n  }\n\n  return this;\n};\n\n/**\n * Overwrite all values in this document with the values of `obj`, except\n * for immutable properties. Behaves similarly to `set()`, except for it\n * unsets all properties that aren't in `obj`.\n *\n * @param {Object} obj the object to overwrite this document with\n * @method overwrite\n * @memberOf Document\n * @instance\n * @api public\n * @return {Document} this\n */\n\nDocument.prototype.overwrite = function overwrite(obj) {\n  const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));\n\n  for (const key of keys) {\n    if (key === '_id') {\n      continue;\n    }\n    // Explicitly skip version key\n    if (this.$__schema.options.versionKey && key === this.$__schema.options.versionKey) {\n      continue;\n    }\n    if (this.$__schema.options.discriminatorKey && key === this.$__schema.options.discriminatorKey) {\n      continue;\n    }\n    this.$set(key, obj[key]);\n  }\n\n  return this;\n};\n\n/**\n * Alias for `set()`, used internally to avoid conflicts\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @param {Boolean} [options.merge=false] if true, setting a [nested path](/docs/subdocs.html#subdocuments-versus-nested-paths) will merge existing values rather than overwrite the whole object. So `doc.set('nested', { a: 1, b: 2 })` becomes `doc.set('nested.a', 1); doc.set('nested.b', 2);`\n * @return {Document} this\n * @method $set\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$set = function $set(path, val, type, options) {\n  if (utils.isPOJO(type)) {\n    options = type;\n    type = undefined;\n  }\n\n  const merge = options && options.merge;\n  const adhoc = type && type !== true;\n  const constructing = type === true;\n  let adhocs;\n  let keys;\n  let i = 0;\n  let pathtype;\n  let key;\n  let prefix;\n\n  const strict = options && 'strict' in options\n    ? options.strict\n    : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n\n  if (path == null) {\n    [path, val] = [val, path];\n  } else if (typeof path !== 'string') {\n    // new Document({ key: val })\n    if (path instanceof Document) {\n      if (path.$__isNested) {\n        path = path.toObject();\n      } else {\n        path = path._doc;\n      }\n    }\n    if (path == null) {\n      [path, val] = [val, path];\n    }\n\n    prefix = val ? val + '.' : '';\n    keys = getKeysInSchemaOrder(this.$__schema, path);\n\n    const len = keys.length;\n\n    // `_skipMinimizeTopLevel` is because we may have deleted the top-level\n    // nested key to ensure key order.\n    const _skipMinimizeTopLevel = options && options._skipMinimizeTopLevel || false;\n    if (len === 0 && _skipMinimizeTopLevel) {\n      delete options._skipMinimizeTopLevel;\n      if (val) {\n        this.$set(val, {});\n      }\n      return this;\n    }\n\n    for (let i = 0; i < len; ++i) {\n      key = keys[i];\n      const pathName = prefix + key;\n      pathtype = this.$__schema.pathType(pathName);\n      const valForKey = path[key];\n\n      // On initial set, delete any nested keys if we're going to overwrite\n      // them to ensure we keep the user's key order.\n      if (type === true &&\n          !prefix &&\n          valForKey != null &&\n          pathtype === 'nested' &&\n          this._doc[key] != null) {\n        delete this._doc[key];\n        // Make sure we set `{}` back even if we minimize re: gh-8565\n        options = Object.assign({}, options, { _skipMinimizeTopLevel: true });\n      } else {\n        // Make sure we set `{_skipMinimizeTopLevel: false}` if don't have overwrite: gh-10441\n        options = Object.assign({}, options, { _skipMinimizeTopLevel: false });\n      }\n\n      if (utils.isNonBuiltinObject(valForKey) && pathtype === 'nested') {\n        this.$set(prefix + key, path[key], constructing, Object.assign({}, options, { _skipMarkModified: true }));\n        $applyDefaultsToNested(this.$get(prefix + key), prefix + key, this);\n        continue;\n      } else if (strict) {\n        // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)\n        if (constructing && path[key] === void 0 &&\n            this.$get(pathName) !== void 0) {\n          continue;\n        }\n\n        if (pathtype === 'adhocOrUndefined') {\n          pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });\n        }\n\n        if (pathtype === 'real' || pathtype === 'virtual') {\n          const p = path[key];\n          this.$set(prefix + key, p, constructing, options);\n        } else if (pathtype === 'nested' && path[key] instanceof Document) {\n          this.$set(prefix + key,\n            path[key].toObject({ transform: false }), constructing, options);\n        } else if (strict === 'throw') {\n          if (pathtype === 'nested') {\n            throw new ObjectExpectedError(key, path[key]);\n          } else {\n            throw new StrictModeError(key);\n          }\n        }\n      } else if (path[key] !== void 0) {\n        this.$set(prefix + key, path[key], constructing, options);\n      }\n    }\n\n    // Ensure all properties are in correct order\n    const orderedDoc = {};\n    const orderedKeys = Object.keys(this.$__schema.tree);\n    for (let i = 0, len = orderedKeys.length; i < len; ++i) {\n      (key = orderedKeys[i]) &&\n      (this._doc.hasOwnProperty(key)) &&\n      (orderedDoc[key] = undefined);\n    }\n    this._doc = Object.assign(orderedDoc, this._doc);\n\n    return this;\n  }\n\n  let pathType = this.$__schema.pathType(path);\n  if (pathType === 'adhocOrUndefined') {\n    pathType = getEmbeddedDiscriminatorPath(this, path, { typeOnly: true });\n  }\n\n  // Assume this is a Mongoose document that was copied into a POJO using\n  // `Object.assign()` or `{...doc}`\n  val = handleSpreadDoc(val);\n\n  // if this doc is being constructed we should not trigger getters\n  const priorVal = (() => {\n    if (this.$__.priorDoc != null) {\n      return this.$__.priorDoc.$__getValue(path);\n    }\n    if (constructing) {\n      return void 0;\n    }\n    return this.$__getValue(path);\n  })();\n\n  if (pathType === 'nested' && val) {\n    if (typeof val === 'object' && val != null) {\n      if (val.$__ != null) {\n        val = val.toObject(internalToObjectOptions);\n      }\n      if (val == null) {\n        this.invalidate(path, new MongooseError.CastError('Object', val, path));\n        return this;\n      }\n      const hasInitialVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);\n      if (this.$__.savedState != null && !this.$isNew && !this.$__.savedState.hasOwnProperty(path)) {\n        const initialVal = this.$__getValue(path);\n        this.$__.savedState[path] = initialVal;\n\n        const keys = Object.keys(initialVal || {});\n        for (const key of keys) {\n          this.$__.savedState[path + '.' + key] = initialVal[key];\n        }\n      }\n\n      if (!merge) {\n        this.$__setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        return this.$set(val, path, constructing);\n      }\n\n      const keys = getKeysInSchemaOrder(this.$__schema, val, path);\n\n      this.$__setValue(path, {});\n      for (const key of keys) {\n        this.$set(path + '.' + key, val[key], constructing, options);\n      }\n      if (priorVal != null && utils.deepEqual(hasInitialVal ? this.$__.savedState[path] : priorVal, val)) {\n        this.unmarkModified(path);\n      } else {\n        this.markModified(path);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError('Object', val, path));\n    return this;\n  }\n\n  let schema;\n  const parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n\n  // Might need to change path for top-level alias\n  if (typeof this.$__schema.aliases[parts[0]] === 'string') {\n    parts[0] = this.$__schema.aliases[parts[0]];\n  }\n\n  if (pathType === 'adhocOrUndefined' && strict) {\n    // check for roots that are Mixed types\n    let mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.$__schema.pathType(subpath) === 'virtual') {\n        mpath.set(path, val, this);\n        return this;\n      }\n\n      schema = this.$__schema.path(subpath);\n      if (schema == null) {\n        continue;\n      }\n\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n    }\n\n    if (schema == null) {\n      // Check for embedded discriminators\n      schema = getEmbeddedDiscriminatorPath(this, path);\n    }\n\n    if (!mixed && !schema) {\n      if (strict === 'throw') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === 'virtual') {\n    schema = this.$__schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it\n  let cur = this._doc;\n  let curPath = '';\n  for (i = 0; i < parts.length - 1; ++i) {\n    cur = cur[parts[i]];\n    curPath += (curPath.length !== 0 ? '.' : '') + parts[i];\n    if (!cur) {\n      this.$set(curPath, {});\n      // Hack re: gh-5800. If nested field is not selected, it probably exists\n      // so `MongoServerError: cannot use the part (nested of nested.num) to\n      // traverse the element ({nested: null})` is not likely. If user gets\n      // that error, its their fault for now. We should reconsider disallowing\n      // modifying not selected paths for 6.x\n      if (!this.$__isSelected(curPath)) {\n        this.unmarkModified(curPath);\n      }\n      cur = this.$__getValue(curPath);\n    }\n  }\n\n  let pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: \"LEFT_SUBFIELD only supports Object\"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    const len = parts.length;\n    for (i = 0; i < len; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n      if (this.$get(subpath, null, { getters: false }) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  if (!schema) {\n    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);\n\n    if (pathType === 'nested' && val == null) {\n      cleanModifiedSubpaths(this, path);\n    }\n    return this;\n  }\n\n  // If overwriting a subdocument path, make sure to clear out\n  // any errors _before_ setting, so new errors that happen\n  // get persisted. Re: #9080\n  if (schema.$isSingleNested || schema.$isMongooseArray) {\n    _markValidSubpaths(this, path);\n  }\n\n  if (val != null && merge && schema.$isSingleNested) {\n    if (val instanceof Document) {\n      val = val.toObject({ virtuals: false, transform: false });\n    }\n    const keys = Object.keys(val);\n    for (const key of keys) {\n      this.$set(path + '.' + key, val[key], constructing, options);\n    }\n\n    return this;\n  }\n\n  let shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    const refMatches = (() => {\n      if (schema.options == null) {\n        return false;\n      }\n      if (!(val instanceof Document)) {\n        return false;\n      }\n      const model = val.constructor;\n\n      // Check ref\n      const ref = schema.options.ref;\n      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {\n        return true;\n      }\n\n      // Check refPath\n      const refPath = schema.options.refPath;\n      if (refPath == null) {\n        return false;\n      }\n      const modelName = val.get(refPath);\n      return modelName === model.modelName || modelName === model.baseModelName;\n    })();\n\n    let didPopulate = false;\n    if (refMatches && val instanceof Document && (!val.$__.wasPopulated || utils.deepEqual(val.$__.wasPopulated.value, val._id))) {\n      const unpopulatedValue = (schema && schema.$isSingleNested) ? schema.cast(val, this) : val._id;\n      this.$populated(path, unpopulatedValue, { [populateModelSymbol]: val.constructor });\n      val.$__.wasPopulated = { value: unpopulatedValue };\n      didPopulate = true;\n    }\n\n    let popOpts;\n    const typeKey = this.$__schema.options.typeKey;\n    if (schema.options &&\n        Array.isArray(schema.options[typeKey]) &&\n        schema.options[typeKey].length &&\n        schema.options[typeKey][0].ref &&\n        _isManuallyPopulatedArray(val, schema.options[typeKey][0].ref)) {\n      popOpts = { [populateModelSymbol]: val[0].constructor };\n      this.$populated(path, val.map(function(v) { return v._id; }), popOpts);\n\n      for (const doc of val) {\n        doc.$__.wasPopulated = { value: doc._id };\n      }\n      didPopulate = true;\n    }\n\n    if (this.$__schema.singleNestedPaths[path] == null && (!refMatches || !schema.$isSingleNested || !val.$__)) {\n      // If this path is underneath a single nested schema, we'll call the setter\n      // later in `$__set()` because we don't take `_doc` when we iterate through\n      // a single nested doc. That's to make sure we get the correct context.\n      // Otherwise we would double-call the setter, see gh-7196.\n      if (options != null && options.overwriteImmutable) {\n        val = schema.applySetters(val, this, false, priorVal, { overwriteImmutable: true });\n      } else {\n        val = schema.applySetters(val, this, false, priorVal);\n      }\n    }\n\n    if (Array.isArray(val) &&\n        !Array.isArray(schema) &&\n        schema.$isMongooseDocumentArray &&\n        val.length !== 0 &&\n        val[0] != null &&\n        val[0].$__ != null &&\n        val[0].$__.populated != null) {\n      const populatedPaths = Object.keys(val[0].$__.populated);\n      for (const populatedPath of populatedPaths) {\n        this.$populated(path + '.' + populatedPath,\n          val.map(v => v.$populated(populatedPath)),\n          val[0].$__.populated[populatedPath].options);\n      }\n      didPopulate = true;\n    }\n\n    if (!didPopulate && this.$__.populated) {\n      // If this array partially contains populated documents, convert them\n      // all to ObjectIds re: #8443\n      if (Array.isArray(val) && this.$__.populated[path]) {\n        for (let i = 0; i < val.length; ++i) {\n          if (val[i] instanceof Document) {\n            val.set(i, val[i]._id, true);\n          }\n        }\n      }\n      delete this.$__.populated[path];\n    }\n\n    if (val != null && schema.$isSingleNested) {\n      _checkImmutableSubpaths(val, schema, priorVal);\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {\n      this.invalidate(path, e);\n    } else if (e instanceof MongooseError.CastError) {\n      this.invalidate(e.path, e);\n      if (e.$originalErrorPath) {\n        this.invalidate(path,\n          new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));\n      }\n    } else {\n      this.invalidate(path,\n        new MongooseError.CastError(schema.instance, val, path, e));\n    }\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    let savedState = null;\n    let savedStatePath = null;\n    if (!constructing) {\n      const doc = this.$isSubdocument ? this.ownerDocument() : this;\n      savedState = doc.$__.savedState;\n      savedStatePath = this.$isSubdocument ? this.$__.fullPath + '.' + path : path;\n      doc.$__saveInitialState(savedStatePath);\n    }\n\n    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);\n\n    if (savedState != null && savedState.hasOwnProperty(savedStatePath) && utils.deepEqual(val, savedState[savedStatePath])) {\n      this.unmarkModified(path);\n    }\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _isManuallyPopulatedArray(val, ref) {\n  if (!Array.isArray(val)) {\n    return false;\n  }\n  if (val.length === 0) {\n    return false;\n  }\n\n  for (const el of val) {\n    if (!(el instanceof Document)) {\n      return false;\n    }\n    const modelName = el.constructor.modelName;\n    if (modelName == null) {\n      return false;\n    }\n    if (el.constructor.modelName != ref && el.constructor.baseModelName != ref) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Sets the value of a path, or many paths.\n * Alias for [`.$set`](#document_Document-$set).\n *\n * #### Example:\n *\n *     // path, value\n *     doc.set(path, value)\n *\n *     // object\n *     doc.set({\n *         path  : value\n *       , path2 : {\n *            path  : value\n *         }\n *     })\n *\n *     // on-the-fly cast to number\n *     doc.set(path, value, Number)\n *\n *     // on-the-fly cast to string\n *     doc.set(path, value, String)\n *\n *     // changing strict mode behavior\n *     doc.set(path, value, { strict: false });\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @return {Document} this\n * @api public\n * @method set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.set = Document.prototype.$set;\n\n/**\n * Determine if we should mark this change as modified.\n *\n * @param {never} pathToMark UNUSED\n * @param {String|Symbol} path\n * @param {Object} options\n * @param {Any} constructing\n * @param {never} parts UNUSED\n * @param {Schema} schema\n * @param {Any} val\n * @param {Any} priorVal\n * @return {Boolean}\n * @api private\n * @method $__shouldModify\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__shouldModify = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {\n  if (options && options._skipMarkModified) {\n    return false;\n  }\n  if (this.$isNew) {\n    return true;\n  }\n  // Is path already modified? If so, always modify. We may unmark modified later.\n  if (path in this.$__.activePaths.getStatePaths('modify')) {\n    return true;\n  }\n\n  // Re: the note about gh-7196, `val` is the raw value without casting or\n  // setters if the full path is under a single nested subdoc because we don't\n  // want to double run setters. So don't set it as modified. See gh-7264.\n  if (this.$__schema.singleNestedPaths[path] != null) {\n    return false;\n  }\n\n  if (val === void 0 && !this.$__isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (val === void 0 && path in this.$__.activePaths.getStatePaths('default')) {\n    // we're just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don't mark modified\n  // if they have the same _id\n  if (this.$populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal !== undefined ? priorVal : utils.getValue(path, this))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.getStatePaths('default') &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n};\n\n/**\n * Handles the actual setting of the value and marking the path modified if appropriate.\n *\n * @param {String} pathToMark\n * @param {String|Symbol} path\n * @param {Object} options\n * @param {Any} constructing\n * @param {Array} parts\n * @param {Schema} schema\n * @param {Any} val\n * @param {Any} priorVal\n * @api private\n * @method $__set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__set = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require('./types/ArraySubdocument');\n\n  const shouldModify = this.$__shouldModify(pathToMark, path, options, constructing, parts,\n    schema, val, priorVal);\n\n  if (shouldModify) {\n    if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[path]) {\n      delete this.$__.primitiveAtomics[path];\n      if (Object.keys(this.$__.primitiveAtomics).length === 0) {\n        delete this.$__.primitiveAtomics;\n      }\n    }\n    this.markModified(pathToMark);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require('./types/array'));\n    if (val && utils.isMongooseArray(val)) {\n      val._registerAtomic('$set', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (utils.isMongooseDocumentArray(val)) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n    }\n  } else if (Array.isArray(val) && Array.isArray(priorVal) && utils.isMongooseArray(val) && utils.isMongooseArray(priorVal)) {\n    val[arrayAtomicsSymbol] = priorVal[arrayAtomicsSymbol];\n    val[arrayAtomicsBackupSymbol] = priorVal[arrayAtomicsBackupSymbol];\n    if (utils.isMongooseDocumentArray(val)) {\n      val.forEach(doc => { doc.isNew = false; });\n    }\n  }\n\n  let obj = this._doc;\n  let i = 0;\n  const l = parts.length;\n  let cur = '';\n\n  for (; i < l; i++) {\n    const next = i + 1;\n    const last = next === l;\n    cur += (cur ? '.' + parts[i] : parts[i]);\n    if (specialProperties.has(parts[i])) {\n      return;\n    }\n\n    if (last) {\n      if (obj instanceof Map) {\n        obj.set(parts[i], val);\n      } else {\n        obj[parts[i]] = val;\n      }\n    } else {\n      if (utils.isPOJO(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && !Array.isArray(obj[parts[i]]) && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        obj[parts[i]] = obj[parts[i]] || {};\n        obj = obj[parts[i]];\n      }\n    }\n  }\n};\n\n/**\n * Gets a raw value from a path (no getters)\n *\n * @param {String} path\n * @return {Any} Returns the value from the given `path`.\n * @api private\n */\n\nDocument.prototype.$__getValue = function(path) {\n  return utils.getValue(path, this._doc);\n};\n\n/**\n * Increments the numeric value at `path` by the given `val`.\n * When you call `save()` on this document, Mongoose will send a\n * [`$inc`](https://www.mongodb.com/docs/manual/reference/operator/update/inc/)\n * as opposed to a `$set`.\n *\n * #### Example:\n *\n *     const schema = new Schema({ counter: Number });\n *     const Test = db.model('Test', schema);\n *\n *     const doc = await Test.create({ counter: 0 });\n *     doc.$inc('counter', 2);\n *     await doc.save(); // Sends a `{ $inc: { counter: 2 } }` to MongoDB\n *     doc.counter; // 2\n *\n *     doc.counter += 2;\n *     await doc.save(); // Sends a `{ $set: { counter: 2 } }` to MongoDB\n *\n * @param {String|Array} path path or paths to update\n * @param {Number} val increment `path` by this value\n * @return {Document} this\n */\n\nDocument.prototype.$inc = function $inc(path, val) {\n  if (val == null) {\n    val = 1;\n  }\n\n  if (Array.isArray(path)) {\n    path.forEach((p) => this.$inc(p, val));\n    return this;\n  }\n\n  const schemaType = this.$__path(path);\n  if (schemaType == null) {\n    if (this.$__.strictMode === 'throw') {\n      throw new StrictModeError(path);\n    } else if (this.$__.strictMode === true) {\n      return this;\n    }\n  } else if (schemaType.instance !== 'Number') {\n    this.invalidate(path, new MongooseError.CastError(schemaType.instance, val, path));\n    return this;\n  }\n\n  const currentValue = this.$__getValue(path) || 0;\n  let shouldSet = false;\n  let valToSet = null;\n  let valToInc = val;\n\n  try {\n    val = schemaType.cast(val);\n    valToSet = schemaType.applySetters(currentValue + val, this);\n    valToInc = valToSet - currentValue;\n    shouldSet = true;\n  } catch (err) {\n    this.invalidate(path, new MongooseError.CastError('number', val, path, err));\n  }\n\n  if (shouldSet) {\n    this.$__.primitiveAtomics = this.$__.primitiveAtomics || {};\n    if (this.$__.primitiveAtomics[path] == null) {\n      this.$__.primitiveAtomics[path] = { $inc: valToInc };\n    } else {\n      this.$__.primitiveAtomics[path].$inc += valToInc;\n    }\n    this.markModified(path);\n    this.$__setValue(path, valToSet);\n  }\n\n  return this;\n};\n\n/**\n * Sets a raw value for a path (no casting, setters, transformations)\n *\n * @param {String} path\n * @param {Object} value\n * @return {Document} this\n * @api private\n */\n\nDocument.prototype.$__setValue = function(path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n};\n\n/**\n * Returns the value of a path.\n *\n * #### Example:\n *\n *     // path\n *     doc.get('age') // 47\n *\n *     // dynamic casting to a string\n *     doc.get('age', String) // \"47\"\n *\n * @param {String} path\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes\n * @param {Object} [options]\n * @param {Boolean} [options.virtuals=false] Apply virtuals before getting this path\n * @param {Boolean} [options.getters=true] If false, skip applying getters and just get the raw value\n * @return {Any}\n * @api public\n */\n\nDocument.prototype.get = function(path, type, options) {\n  let adhoc;\n  if (options == null) {\n    options = {};\n  }\n  if (type) {\n    adhoc = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n  const noDottedPath = options.noDottedPath;\n\n  // Fast path if we know we're just accessing top-level path on the document:\n  // just get the schema path, avoid `$__path()` because that does string manipulation\n  let schema = noDottedPath ? this.$__schema.paths[path] : this.$__path(path);\n  if (schema == null) {\n    schema = this.$__schema.virtualpath(path);\n\n    if (schema != null) {\n      return schema.applyGetters(void 0, this);\n    }\n  }\n\n  if (noDottedPath) {\n    let obj = this._doc[path];\n    if (adhoc) {\n      obj = adhoc.cast(obj);\n    }\n    if (schema != null && options.getters !== false) {\n      return schema.applyGetters(obj, this);\n    }\n    return obj;\n  }\n\n  if (schema != null && schema.instance === 'Mixed') {\n    const virtual = this.$__schema.virtualpath(path);\n    if (virtual != null) {\n      schema = virtual;\n    }\n  }\n\n  const hasDot = path.indexOf('.') !== -1;\n  let obj = this._doc;\n\n  const pieces = hasDot ? path.split('.') : [path];\n  // Might need to change path for top-level alias\n  if (typeof this.$__schema.aliases[pieces[0]] === 'string') {\n    pieces[0] = this.$__schema.aliases[pieces[0]];\n  }\n\n  for (let i = 0, l = pieces.length; i < l; i++) {\n    if (obj && obj._doc) {\n      obj = obj._doc;\n    }\n\n    if (obj == null) {\n      obj = void 0;\n    } else if (obj instanceof Map) {\n      obj = obj.get(pieces[i], { getters: false });\n    } else if (i === l - 1) {\n      obj = utils.getValue(pieces[i], obj);\n    } else {\n      obj = obj[pieces[i]];\n    }\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  if (schema != null && options.getters !== false) {\n    obj = schema.applyGetters(obj, this);\n  } else if (this.$__schema.nested[path] && options.virtuals) {\n    // Might need to apply virtuals if this is a nested path\n    return applyVirtuals(this, utils.clone(obj) || {}, { path: path });\n  }\n\n  return obj;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype[getSymbol] = Document.prototype.get;\nDocument.prototype.$get = Document.prototype.get;\n\n/**\n * Returns the schematype for the given `path`.\n *\n * @param {String} path\n * @return {SchemaPath}\n * @api private\n * @method $__path\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__path = function(path) {\n  const adhocs = this.$__.adhocPaths;\n  const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.$__schema.path(path);\n};\n\n/**\n * Marks the path as having pending changes to write to the db.\n *\n * _Very helpful when using [Mixed](https://mongoosejs.com/docs/schematypes.html#mixed) types._\n *\n * #### Example:\n *\n *     doc.mixed.type = 'changed';\n *     doc.markModified('mixed.type');\n *     doc.save() // changes to mixed.type are now persisted\n *\n * @param {String} path the path to mark modified\n * @param {Document} [scope] the scope to run validators with\n * @api public\n */\n\nDocument.prototype.markModified = function(path, scope) {\n  this.$__saveInitialState(path);\n\n  this.$__.activePaths.modify(path);\n  if (scope != null && !this.$isSubdocument) {\n    this.$__.pathsToScopes = this.$__pathsToScopes || {};\n    this.$__.pathsToScopes[path] = scope;\n  }\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__saveInitialState = function $__saveInitialState(path) {\n  const savedState = this.$__.savedState;\n  const savedStatePath = path;\n  if (savedState != null) {\n    const firstDot = savedStatePath.indexOf('.');\n    const topLevelPath = firstDot === -1 ? savedStatePath : savedStatePath.slice(0, firstDot);\n    if (!savedState.hasOwnProperty(topLevelPath)) {\n      savedState[topLevelPath] = utils.clone(this.$__getValue(topLevelPath));\n    }\n  }\n};\n\n/**\n * Clears the modified state on the specified path.\n *\n * #### Example:\n *\n *     doc.foo = 'bar';\n *     doc.unmarkModified('foo');\n *     doc.save(); // changes to foo will not be persisted\n *\n * @param {String} path the path to unmark modified\n * @api public\n */\n\nDocument.prototype.unmarkModified = function(path) {\n  this.$__.activePaths.init(path);\n  if (this.$__.pathsToScopes != null) {\n    delete this.$__.pathsToScopes[path];\n  }\n};\n\n/**\n * Don't run validation on this path or persist changes to this path.\n *\n * #### Example:\n *\n *     doc.foo = null;\n *     doc.$ignore('foo');\n *     doc.save(); // changes to foo will not be persisted and validators won't be run\n *\n * @memberOf Document\n * @instance\n * @method $ignore\n * @param {String} path the path to ignore\n * @api public\n */\n\nDocument.prototype.$ignore = function(path) {\n  this.$__.activePaths.ignore(path);\n};\n\n/**\n * Returns the list of paths that have been directly modified. A direct\n * modified path is a path that you explicitly set, whether via `doc.foo = 'bar'`,\n * `Object.assign(doc, { foo: 'bar' })`, or `doc.set('foo', 'bar')`.\n *\n * A path `a` may be in `modifiedPaths()` but not in `directModifiedPaths()`\n * because a child of `a` was directly modified.\n *\n * #### Example:\n *\n *     const schema = new Schema({ foo: String, nested: { bar: String } });\n *     const Model = mongoose.model('Test', schema);\n *     await Model.create({ foo: 'original', nested: { bar: 'original' } });\n *\n *     const doc = await Model.findOne();\n *     doc.nested.bar = 'modified';\n *     doc.directModifiedPaths(); // ['nested.bar']\n *     doc.modifiedPaths(); // ['nested', 'nested.bar']\n *\n * @return {String[]}\n * @api public\n */\n\nDocument.prototype.directModifiedPaths = function() {\n  return Object.keys(this.$__.activePaths.getStatePaths('modify'));\n};\n\n/**\n * Returns true if the given path is nullish or only contains empty objects.\n * Useful for determining whether this subdoc will get stripped out by the\n * [minimize option](/docs/guide.html#minimize).\n *\n * #### Example:\n *\n *     const schema = new Schema({ nested: { foo: String } });\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model({});\n *     doc.$isEmpty('nested'); // true\n *     doc.nested.$isEmpty(); // true\n *\n *     doc.nested.foo = 'bar';\n *     doc.$isEmpty('nested'); // false\n *     doc.nested.$isEmpty(); // false\n *\n * @param {String} [path]\n * @memberOf Document\n * @instance\n * @api public\n * @method $isEmpty\n * @return {Boolean}\n */\n\nDocument.prototype.$isEmpty = function(path) {\n  const isEmptyOptions = {\n    minimize: true,\n    virtuals: false,\n    getters: false,\n    transform: false\n  };\n\n  if (arguments.length !== 0) {\n    const v = this.$get(path);\n    if (v == null) {\n      return true;\n    }\n    if (typeof v !== 'object') {\n      return false;\n    }\n    if (utils.isPOJO(v)) {\n      return _isEmpty(v);\n    }\n    return Object.keys(v.toObject(isEmptyOptions)).length === 0;\n  }\n\n  return Object.keys(this.toObject(isEmptyOptions)).length === 0;\n};\n\n/*!\n * ignore\n */\n\nfunction _isEmpty(v) {\n  if (v == null) {\n    return true;\n  }\n  if (typeof v !== 'object' || Array.isArray(v)) {\n    return false;\n  }\n  for (const key of Object.keys(v)) {\n    if (!_isEmpty(v[key])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns the list of paths that have been modified.\n *\n * @param {Object} [options]\n * @param {Boolean} [options.includeChildren=false] if true, returns children of modified paths as well. For example, if false, the list of modified paths for `doc.colors = { primary: 'blue' };` will **not** contain `colors.primary`. If true, `modifiedPaths()` will return an array that contains `colors.primary`.\n * @return {String[]}\n * @api public\n */\n\nDocument.prototype.modifiedPaths = function(options) {\n  options = options || {};\n\n  const directModifiedPaths = Object.keys(this.$__.activePaths.getStatePaths('modify'));\n  const result = new Set();\n\n  let i = 0;\n  let j = 0;\n  const len = directModifiedPaths.length;\n\n  for (i = 0; i < len; ++i) {\n    const path = directModifiedPaths[i];\n    const parts = parentPaths(path);\n    const pLen = parts.length;\n\n    for (j = 0; j < pLen; ++j) {\n      result.add(parts[j]);\n    }\n\n    if (!options.includeChildren) {\n      continue;\n    }\n\n    let ii = 0;\n    let cur = this.$get(path);\n    if (typeof cur === 'object' && cur !== null) {\n      if (cur._doc) {\n        cur = cur._doc;\n      }\n      const len = cur.length;\n      if (Array.isArray(cur)) {\n        for (ii = 0; ii < len; ++ii) {\n          const subPath = path + '.' + ii;\n          if (!result.has(subPath)) {\n            result.add(subPath);\n            if (cur[ii] != null && cur[ii].$__) {\n              const modified = cur[ii].modifiedPaths();\n              let iii = 0;\n              const iiiLen = modified.length;\n              for (iii = 0; iii < iiiLen; ++iii) {\n                result.add(subPath + '.' + modified[iii]);\n              }\n            }\n          }\n        }\n      } else {\n        const keys = Object.keys(cur);\n        let ii = 0;\n        const len = keys.length;\n        for (ii = 0; ii < len; ++ii) {\n          result.add(path + '.' + keys[ii]);\n        }\n      }\n    }\n  }\n  return Array.from(result);\n};\n\nDocument.prototype[documentModifiedPaths] = Document.prototype.modifiedPaths;\n\n/**\n * Returns true if any of the given paths is modified, else false. If no arguments, returns `true` if any path\n * in this document is modified.\n *\n * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\n *\n * #### Example:\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isModified()                      // true\n *     doc.isModified('documents')           // true\n *     doc.isModified('documents.0.title')   // true\n *     doc.isModified('documents otherProp') // true\n *     doc.isDirectModified('documents')     // false\n *\n * @param {String} [path] optional\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isModified = function(paths, modifiedPaths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.indexOf(' ') === -1 ? [paths] : paths.split(' ');\n    }\n\n    const directModifiedPathsObj = this.$__.activePaths.states.modify;\n    if (directModifiedPathsObj == null) {\n      return false;\n    }\n    for (const path of paths) {\n      if (Object.prototype.hasOwnProperty.call(directModifiedPathsObj, path)) {\n        return true;\n      }\n    }\n\n    const modified = modifiedPaths || this[documentModifiedPaths]();\n    const isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n\n    const directModifiedPaths = Object.keys(directModifiedPathsObj);\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.startsWith(mod + '.');\n      });\n    });\n  }\n\n  return this.$__.activePaths.some('modify');\n};\n\n/**\n * Alias of [`.isModified`](#document_Document-isModified)\n *\n * @method $isModified\n * @memberOf Document\n * @api public\n */\n\nDocument.prototype.$isModified = Document.prototype.isModified;\n\nDocument.prototype[documentIsModified] = Document.prototype.isModified;\n\n/**\n * Checks if a path is set to its default.\n *\n * #### Example:\n *\n *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });\n *     const m = new MyModel();\n *     m.$isDefault('name'); // true\n *\n * @memberOf Document\n * @instance\n * @method $isDefault\n * @param {String} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.$isDefault = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('default');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.getStatePaths('default').hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.getStatePaths('default').hasOwnProperty(path));\n};\n\n/**\n * Getter/setter, determines whether the document was removed or not.\n *\n * #### Example:\n *\n *     const product = await product.remove();\n *     product.$isDeleted(); // true\n *     product.remove(); // no-op, doesn't send anything to the db\n *\n *     product.$isDeleted(false);\n *     product.$isDeleted(); // false\n *     product.remove(); // will execute a remove against the db\n *\n *\n * @param {Boolean} [val] optional, overrides whether mongoose thinks the doc is deleted\n * @return {Boolean|Document} whether mongoose thinks this doc is deleted.\n * @method $isDeleted\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$isDeleted = function(val) {\n  if (arguments.length === 0) {\n    return !!this.$__.isDeleted;\n  }\n\n  this.$__.isDeleted = !!val;\n  return this;\n};\n\n/**\n * Returns true if `path` was directly set and modified, else false.\n *\n * #### Example:\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isDirectModified('documents.0.title') // true\n *     doc.isDirectModified('documents') // false\n *\n * @param {String|String[]} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectModified = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('modify');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.getStatePaths('modify').hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.getStatePaths('modify').hasOwnProperty(path));\n};\n\n/**\n * Checks if `path` is in the `init` state, that is, it was set by `Document#init()` and not modified since.\n *\n * @param {String} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isInit = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('init');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.getStatePaths('init').hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.getStatePaths('init').hasOwnProperty(path));\n};\n\n/**\n * Checks if `path` was selected in the source query which initialized this document.\n *\n * #### Example:\n *\n *     const doc = await Thing.findOne().select('name');\n *     doc.isSelected('name') // true\n *     doc.isSelected('age')  // false\n *\n * @param {String|String[]} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isSelected = function isSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n  if (!path) {\n    return false;\n  }\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__isSelected(p));\n  }\n\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n\n  if (inclusive === null) {\n    return true;\n  }\n\n  if (path in this.$__.selected) {\n    return inclusive;\n  }\n\n  const pathDot = path + '.';\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n\n    if (cur.startsWith(pathDot)) {\n      return inclusive || cur !== pathDot;\n    }\n\n    if (pathDot.startsWith(cur + '.')) {\n      return inclusive;\n    }\n  }\n\n  return !inclusive;\n};\n\nDocument.prototype.$__isSelected = Document.prototype.isSelected;\n\n/**\n * Checks if `path` was explicitly selected. If no projection, always returns\n * true.\n *\n * #### Example:\n *\n *     Thing.findOne().select('nested.name').exec(function (err, doc) {\n *        doc.isDirectSelected('nested.name') // true\n *        doc.isDirectSelected('nested.otherName') // false\n *        doc.isDirectSelected('nested')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectSelected = function isDirectSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.isDirectSelected(p));\n  }\n\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n\n  if (inclusive === null) {\n    return true;\n  }\n\n  if (this.$__.selected.hasOwnProperty(path)) {\n    return inclusive;\n  }\n\n  return !inclusive;\n};\n\n/**\n * Executes registered validation rules for this document.\n *\n * #### Note:\n *\n * This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned to your `callback`.\n *\n * #### Example:\n *\n *     doc.validate(function (err) {\n *       if (err) handleError(err);\n *       else // validation passed\n *     });\n *\n * @param {Array|String} [pathsToValidate] list of paths to validate. If set, Mongoose will validate only the modified paths that are in the given list.\n * @param {Object} [options] internal options\n * @param {Boolean} [options.validateModifiedOnly=false] if `true` mongoose validates only modified paths.\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n * @param {Function} [callback] optional callback called after validation completes, passing an error if one occurred\n * @return {Promise} Returns a Promise if no `callback` is given.\n * @api public\n */\n\nDocument.prototype.validate = function(pathsToValidate, options, callback) {\n  let parallelValidate;\n  this.$op = 'validate';\n\n  if (this.$isSubdocument != null) {\n    // Skip parallel validate check for subdocuments\n  } else if (this.$__.validating) {\n    parallelValidate = new ParallelValidateError(this, {\n      parentStack: options && options.parentStack,\n      conflictStack: this.$__.validating.stack\n    });\n  } else {\n    this.$__.validating = new ParallelValidateError(this, { parentStack: options && options.parentStack });\n  }\n\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n      options = arguments[0];\n      callback = null;\n      pathsToValidate = null;\n    } else if (typeof arguments[0] === 'function') {\n      callback = arguments[0];\n      options = null;\n      pathsToValidate = null;\n    }\n  } else if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = pathsToValidate;\n    pathsToValidate = null;\n  }\n  if (options && typeof options.pathsToSkip === 'string') {\n    const isOnePathOnly = options.pathsToSkip.indexOf(' ') === -1;\n    options.pathsToSkip = isOnePathOnly ? [options.pathsToSkip] : options.pathsToSkip.split(' ');\n  }\n\n  return promiseOrCallback(callback, cb => {\n    if (parallelValidate != null) {\n      return cb(parallelValidate);\n    }\n\n    this.$__validate(pathsToValidate, options, (error) => {\n      this.$op = null;\n      this.$__.validating = null;\n      cb(error);\n    });\n  }, this.constructor.events);\n};\n\n/**\n * Alias of [`.validate`](#document_Document-validate)\n *\n * @method $validate\n * @memberOf Document\n * @api public\n */\n\nDocument.prototype.$validate = Document.prototype.validate;\n\n/*!\n * ignore\n */\n\nfunction _evaluateRequiredFunctions(doc) {\n  const requiredFields = Object.keys(doc.$__.activePaths.getStatePaths('require'));\n  let i = 0;\n  const len = requiredFields.length;\n  for (i = 0; i < len; ++i) {\n    const path = requiredFields[i];\n\n    const p = doc.$__schema.path(path);\n\n    if (p != null && typeof p.originalRequiredValue === 'function') {\n      doc.$__.cachedRequired = doc.$__.cachedRequired || {};\n      try {\n        doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc, doc);\n      } catch (err) {\n        doc.invalidate(path, err);\n      }\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _getPathsToValidate(doc) {\n  const skipSchemaValidators = {};\n\n  _evaluateRequiredFunctions(doc);\n  // only validate required fields when necessary\n  let paths = new Set(Object.keys(doc.$__.activePaths.getStatePaths('require')).filter(function(path) {\n    if (!doc.$__isSelected(path) && !doc.$isModified(path)) {\n      return false;\n    }\n    if (doc.$__.cachedRequired != null && path in doc.$__.cachedRequired) {\n      return doc.$__.cachedRequired[path];\n    }\n    return true;\n  }));\n\n  Object.keys(doc.$__.activePaths.getStatePaths('init')).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.getStatePaths('modify')).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.getStatePaths('default')).forEach(addToPaths);\n  function addToPaths(p) { paths.add(p); }\n\n  const subdocs = doc.$getAllSubdocs();\n  const modifiedPaths = doc.modifiedPaths();\n  for (const subdoc of subdocs) {\n    if (subdoc.$basePath) {\n      // Remove child paths for now, because we'll be validating the whole\n      // subdoc\n      const fullPathToSubdoc = subdoc.$__fullPathWithIndexes();\n\n      for (const p of paths) {\n        if (p == null || p.startsWith(fullPathToSubdoc + '.')) {\n          paths.delete(p);\n        }\n      }\n\n      if (doc.$isModified(fullPathToSubdoc, modifiedPaths) &&\n            !doc.isDirectModified(fullPathToSubdoc) &&\n            !doc.$isDefault(fullPathToSubdoc)) {\n        paths.add(fullPathToSubdoc);\n\n        skipSchemaValidators[fullPathToSubdoc] = true;\n      }\n    }\n  }\n\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType) {\n      continue;\n    }\n\n    if (_pathType.$isMongooseDocumentArray) {\n      for (const p of paths) {\n        if (p == null || p.startsWith(_pathType.path + '.')) {\n          paths.delete(p);\n        }\n      }\n    }\n\n    // Optimization: if primitive path with no validators, or array of primitives\n    // with no validators, skip validating this path entirely.\n    if (!_pathType.caster && _pathType.validators.length === 0) {\n      paths.delete(path);\n    } else if (_pathType.$isMongooseArray &&\n      !_pathType.$isMongooseDocumentArray && // Skip document arrays...\n      !_pathType.$embeddedSchemaType.$isMongooseArray && // and arrays of arrays\n      _pathType.validators.length === 0 && // and arrays with top-level validators\n      _pathType.$embeddedSchemaType.validators.length === 0) {\n      paths.delete(path);\n    }\n  }\n\n  // from here on we're not removing items from paths\n\n  // gh-661: if a whole array is modified, make sure to run validation on all\n  // the children as well\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType) {\n      continue;\n    }\n\n    if (!_pathType.$isMongooseArray ||\n        // To avoid potential performance issues, skip doc arrays whose children\n        // are not required. `getPositionalPathType()` may be slow, so avoid\n        // it unless we have a case of #6364\n        (!Array.isArray(_pathType) &&\n          _pathType.$isMongooseDocumentArray &&\n          !(_pathType && _pathType.schemaOptions && _pathType.schemaOptions.required))) {\n      continue;\n    }\n\n    // gh-11380: optimization. If the array isn't a document array and there's no validators\n    // on the array type, there's no need to run validation on the individual array elements.\n    if (_pathType.$isMongooseArray &&\n        !_pathType.$isMongooseDocumentArray && // Skip document arrays...\n        !_pathType.$embeddedSchemaType.$isMongooseArray && // and arrays of arrays\n        _pathType.$embeddedSchemaType.validators.length === 0) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n    _pushNestedArrayPaths(val, paths, path);\n  }\n\n  function _pushNestedArrayPaths(val, paths, path) {\n    if (val != null) {\n      const numElements = val.length;\n      for (let j = 0; j < numElements; ++j) {\n        if (Array.isArray(val[j])) {\n          _pushNestedArrayPaths(val[j], paths, path + '.' + j);\n        } else {\n          paths.add(path + '.' + j);\n        }\n      }\n    }\n  }\n\n  const flattenOptions = { skipArrays: true };\n  for (const pathToCheck of paths) {\n    if (doc.$__schema.nested[pathToCheck]) {\n      let _v = doc.$__getValue(pathToCheck);\n      if (isMongooseObject(_v)) {\n        _v = _v.toObject({ transform: false });\n      }\n      const flat = flatten(_v, pathToCheck, flattenOptions, doc.$__schema);\n      Object.keys(flat).forEach(addToPaths);\n    }\n  }\n\n  for (const path of paths) {\n    // Single nested paths (paths embedded under single nested subdocs) will\n    // be validated on their own when we call `validate()` on the subdoc itself.\n    // Re: gh-8468\n    if (doc.$__schema.singleNestedPaths.hasOwnProperty(path)) {\n      paths.delete(path);\n      continue;\n    }\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType || !_pathType.$isSchemaMap) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n    if (val == null) {\n      continue;\n    }\n    for (const key of val.keys()) {\n      paths.add(path + '.' + key);\n    }\n  }\n\n  paths = Array.from(paths);\n  return [paths, skipSchemaValidators];\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__validate = function(pathsToValidate, options, callback) {\n  if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options &&\n      (typeof options === 'object') &&\n      ('validateModifiedOnly' in options);\n\n  const pathsToSkip = (options && options.pathsToSkip) || null;\n\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n\n  const _this = this;\n  const _complete = () => {\n    let validationError = this.$__.validationError;\n    this.$__.validationError = null;\n    this.$__.validating = null;\n\n    if (shouldValidateModifiedOnly && validationError != null) {\n      // Remove any validation errors that aren't from modified paths\n      const errors = Object.keys(validationError.errors);\n      for (const errPath of errors) {\n        if (!this.$isModified(errPath)) {\n          delete validationError.errors[errPath];\n        }\n      }\n      if (Object.keys(validationError.errors).length === 0) {\n        validationError = void 0;\n      }\n    }\n\n    this.$__.cachedRequired = {};\n    this.$emit('validate', _this);\n    this.constructor.emit('validate', _this);\n\n    if (validationError) {\n      for (const key in validationError.errors) {\n        // Make sure cast errors persist\n        if (!this[documentArrayParent] &&\n            validationError.errors[key] instanceof MongooseError.CastError) {\n          this.invalidate(key, validationError.errors[key]);\n        }\n      }\n\n      return validationError;\n    }\n  };\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this);\n  let paths = shouldValidateModifiedOnly ?\n    pathDetails[0].filter((path) => this.$isModified(path)) :\n    pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n  if (typeof pathsToValidate === 'string') {\n    pathsToValidate = pathsToValidate.split(' ');\n  }\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  } else if (pathsToSkip) {\n    paths = _handlePathsToSkip(paths, pathsToSkip);\n  }\n\n  if (paths.length === 0) {\n    return immediate(function() {\n      const error = _complete();\n      if (error) {\n        return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback(null, _this);\n    });\n  }\n\n  const validated = {};\n  let total = 0;\n\n  for (const path of paths) {\n    validatePath(path);\n  }\n\n  function validatePath(path) {\n    if (path == null || validated[path]) {\n      return;\n    }\n\n    validated[path] = true;\n    total++;\n\n    immediate(function() {\n      const schemaType = _this.$__schema.path(path);\n\n      if (!schemaType) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don't validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      // If setting a path under a mixed path, avoid using the mixed path validator (gh-10141)\n      if (schemaType[schemaMixedSymbol] != null && path !== schemaType.path) {\n        return --total || complete();\n      }\n\n      let val = _this.$__getValue(path);\n\n      // If you `populate()` and get back a null value, required validators\n      // shouldn't fail (gh-8018). We should always fall back to the populated\n      // value.\n      let pop;\n      if ((pop = _this.$populated(path))) {\n        val = pop;\n      } else if (val != null && val.$__ != null && val.$__.wasPopulated) {\n        // Array paths, like `somearray.1`, do not show up as populated with `$populated()`,\n        // so in that case pull out the document's id\n        val = val._id;\n      }\n      const scope = _this.$__.pathsToScopes != null && path in _this.$__.pathsToScopes ?\n        _this.$__.pathsToScopes[path] :\n        _this;\n\n      const doValidateOptions = {\n        skipSchemaValidators: skipSchemaValidators[path],\n        path: path,\n        validateModifiedOnly: shouldValidateModifiedOnly\n      };\n\n      schemaType.doValidate(val, function(err) {\n        if (err) {\n          const isSubdoc = schemaType.$isSingleNested ||\n            schemaType.$isArraySubdocument ||\n            schemaType.$isMongooseDocumentArray;\n          if (isSubdoc && err instanceof ValidationError) {\n            return --total || complete();\n          }\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, scope, doValidateOptions);\n    });\n  }\n\n  function complete() {\n    const error = _complete();\n    if (error) {\n      return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback(null, _this);\n  }\n\n};\n\n/*!\n * ignore\n */\n\nfunction _handlePathsToValidate(paths, pathsToValidate) {\n  const _pathsToValidate = new Set(pathsToValidate);\n  const parentPaths = new Map([]);\n  for (const path of pathsToValidate) {\n    if (path.indexOf('.') === -1) {\n      continue;\n    }\n    const pieces = path.split('.');\n    let cur = pieces[0];\n    for (let i = 1; i < pieces.length; ++i) {\n      // Since we skip subpaths under single nested subdocs to\n      // avoid double validation, we need to add back the\n      // single nested subpath if the user asked for it (gh-8626)\n      parentPaths.set(cur, path);\n      cur = cur + '.' + pieces[i];\n    }\n  }\n\n  const ret = [];\n  for (const path of paths) {\n    if (_pathsToValidate.has(path)) {\n      ret.push(path);\n    } else if (parentPaths.has(path)) {\n      ret.push(parentPaths.get(path));\n    }\n  }\n  return ret;\n}\n\n/*!\n * ignore\n */\n\nfunction _handlePathsToSkip(paths, pathsToSkip) {\n  pathsToSkip = new Set(pathsToSkip);\n  paths = paths.filter(p => !pathsToSkip.has(p));\n  return paths;\n}\n\n/**\n * Executes registered validation rules (skipping asynchronous validators) for this document.\n *\n * #### Note:\n *\n * This method is useful if you need synchronous validation.\n *\n * #### Example:\n *\n *     const err = doc.validateSync();\n *     if (err) {\n *       handleError(err);\n *     } else {\n *       // validation passed\n *     }\n *\n * @param {Array|string} [pathsToValidate] only validate the given paths\n * @param {Object} [options] options for validation\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n * @return {ValidationError|undefined} ValidationError if there are errors during validation, or undefined if there is no error.\n * @api public\n */\n\nDocument.prototype.validateSync = function(pathsToValidate, options) {\n  const _this = this;\n\n  if (arguments.length === 1 && typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n    options = arguments[0];\n    pathsToValidate = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options &&\n      (typeof options === 'object') &&\n      ('validateModifiedOnly' in options);\n\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n\n  let pathsToSkip = options && options.pathsToSkip;\n\n  if (typeof pathsToValidate === 'string') {\n    const isOnePathOnly = pathsToValidate.indexOf(' ') === -1;\n    pathsToValidate = isOnePathOnly ? [pathsToValidate] : pathsToValidate.split(' ');\n  } else if (typeof pathsToSkip === 'string' && pathsToSkip.indexOf(' ') !== -1) {\n    pathsToSkip = pathsToSkip.split(' ');\n  }\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this);\n  let paths = shouldValidateModifiedOnly ?\n    pathDetails[0].filter((path) => this.$isModified(path)) :\n    pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  } else if (Array.isArray(pathsToSkip)) {\n    paths = _handlePathsToSkip(paths, pathsToSkip);\n  }\n  const validating = {};\n\n  for (let i = 0, len = paths.length; i < len; ++i) {\n    const path = paths[i];\n\n    if (validating[path]) {\n      continue;\n    }\n\n    validating[path] = true;\n\n    const p = _this.$__schema.path(path);\n    if (!p) {\n      continue;\n    }\n    if (!_this.$isValid(path)) {\n      continue;\n    }\n\n    const val = _this.$__getValue(path);\n    const err = p.doValidateSync(val, _this, {\n      skipSchemaValidators: skipSchemaValidators[path],\n      path: path,\n      validateModifiedOnly: shouldValidateModifiedOnly\n    });\n    if (err) {\n      const isSubdoc = p.$isSingleNested ||\n        p.$isArraySubdocument ||\n        p.$isMongooseDocumentArray;\n      if (isSubdoc && err instanceof ValidationError) {\n        continue;\n      }\n      _this.invalidate(path, err, undefined, true);\n    }\n  }\n\n  const err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.$emit('validate', _this);\n  _this.constructor.emit('validate', _this);\n\n  if (err) {\n    for (const key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n};\n\n/**\n * Marks a path as invalid, causing validation to fail.\n *\n * The `errorMsg` argument will become the message of the `ValidationError`.\n *\n * The `value` argument (if passed) will be available through the `ValidationError.value` property.\n *\n *     doc.invalidate('size', 'must be less than 20', 14);\n *\n *     doc.validate(function (err) {\n *       console.log(err)\n *       // prints\n *       { message: 'Validation failed',\n *         name: 'ValidationError',\n *         errors:\n *          { size:\n *             { message: 'must be less than 20',\n *               name: 'ValidatorError',\n *               path: 'size',\n *               type: 'user defined',\n *               value: 14 } } }\n *     })\n *\n * @param {String} path the field to invalidate. For array elements, use the `array.i.field` syntax, where `i` is the 0-based index in the array.\n * @param {String|Error} err the error which states the reason `path` was invalid\n * @param {Object|String|Number|any} val optional invalid value\n * @param {String} [kind] optional `kind` property for the error\n * @return {ValidationError} the current ValidationError, with all currently invalidated paths\n * @api public\n */\n\nDocument.prototype.invalidate = function(path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === 'string') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || 'user defined',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.addError(path, err);\n  return this.$__.validationError;\n};\n\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api public\n * @memberOf Document\n * @instance\n * @method $markValid\n */\n\nDocument.prototype.$markValid = function(path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _markValidSubpaths(doc, path) {\n  if (!doc.$__.validationError) {\n    return;\n  }\n\n  const keys = Object.keys(doc.$__.validationError.errors);\n  for (const key of keys) {\n    if (key.startsWith(path + '.')) {\n      delete doc.$__.validationError.errors[key];\n    }\n  }\n  if (Object.keys(doc.$__.validationError.errors).length === 0) {\n    doc.$__.validationError = null;\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _checkImmutableSubpaths(subdoc, schematype, priorVal) {\n  const schema = schematype.schema;\n  if (schema == null) {\n    return;\n  }\n\n  for (const key of Object.keys(schema.paths)) {\n    const path = schema.paths[key];\n    if (path.$immutableSetter == null) {\n      continue;\n    }\n    const oldVal = priorVal == null ? void 0 : priorVal.$__getValue(key);\n    // Calling immutableSetter with `oldVal` even though it expects `newVal`\n    // is intentional. That's because `$immutableSetter` compares its param\n    // to the current value.\n    path.$immutableSetter.call(subdoc, oldVal);\n  }\n}\n\n/**\n * Saves this document by inserting a new document into the database if [document.isNew](#document_Document-isNew) is `true`,\n * or sends an [updateOne](#document_Document-updateOne) operation **only** with the modifications to the database, it does not replace the whole document in the latter case.\n *\n * #### Example:\n *\n *     product.sold = Date.now();\n *     product = await product.save();\n *\n * If save is successful, the returned promise will fulfill with the document\n * saved.\n *\n * #### Example:\n *\n *     const newProduct = await product.save();\n *     newProduct === product; // true\n *\n * @param {Object} [options] options optional options\n * @param {Session} [options.session=null] the [session](https://www.mongodb.com/docs/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](#document_Document-$session).\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](https://mongoosejs.com//docs/guide.html#safe). Use the `w` option instead.\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Number|String} [options.w] set the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern).\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://www.mongodb.com/docs/manual/reference/limits/#Restrictions-on-Field-Names)\n * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this `save()`.\n * @param {Function} [fn] optional callback\n * @method save\n * @memberOf Document\n * @instance\n * @throws {DocumentNotFoundError} if this [save updates an existing document](#document_Document-isNew) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).\n * @return {Promise|undefined} Returns undefined if used with callback or a Promise otherwise.\n * @api public\n * @see middleware https://mongoosejs.com/docs/middleware.html\n */\n\n/**\n * Checks if a path is invalid\n *\n * @param {String|String[]} [path] the field to check. If unset will always return \"false\"\n * @method $isValid\n * @memberOf Document\n * @instance\n * @api private\n */\n\nDocument.prototype.$isValid = function(path) {\n  if (this.$__.validationError == null || Object.keys(this.$__.validationError.errors).length === 0) {\n    return true;\n  }\n  if (path == null) {\n    return false;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__.validationError.errors[p] == null);\n  }\n\n  return this.$__.validationError.errors[path] == null;\n};\n\n/**\n * Resets the internal modified state of this document.\n *\n * @api private\n * @return {Document} this\n * @method $__reset\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__reset = function reset() {\n  let _this = this;\n\n  // Skip for subdocuments\n  const subdocs = this.$parent() === this ? this.$getAllSubdocs() : [];\n  const resetArrays = new Set();\n  for (const subdoc of subdocs) {\n    const fullPathWithIndexes = subdoc.$__fullPathWithIndexes();\n    if (this.isModified(fullPathWithIndexes) || isParentInit(fullPathWithIndexes)) {\n      subdoc.$__reset();\n      if (subdoc.$isDocumentArrayElement) {\n        if (!resetArrays.has(subdoc.parentArray())) {\n          const array = subdoc.parentArray();\n          this.$__.activePaths.clearPath(fullPathWithIndexes.replace(/\\.\\d+$/, '').slice(-subdoc.$basePath - 1));\n          array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];\n          array[arrayAtomicsSymbol] = {};\n\n          resetArrays.add(array);\n        }\n      } else {\n        if (subdoc.$parent() === this) {\n          this.$__.activePaths.clearPath(subdoc.$basePath);\n        } else if (subdoc.$parent() != null && subdoc.$parent().$isSubdocument) {\n          // If map path underneath subdocument, may end up with a case where\n          // map path is modified but parent still needs to be reset. See gh-10295\n          subdoc.$parent().$__reset();\n        }\n      }\n    }\n  }\n\n  function isParentInit(path) {\n    path = path.indexOf('.') === -1 ? [path] : path.split('.');\n    let cur = '';\n    for (let i = 0; i < path.length; ++i) {\n      cur += (cur.length ? '.' : '') + path[i];\n      if (_this.$__.activePaths[cur] === 'init') {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol]) {\n      type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];\n      type[arrayAtomicsSymbol] = {};\n    }\n  });\n\n  this.$__.backup = {};\n  this.$__.backup.activePaths = {\n    modify: Object.assign({}, this.$__.activePaths.getStatePaths('modify')),\n    default: Object.assign({}, this.$__.activePaths.getStatePaths('default'))\n  };\n  this.$__.backup.validationError = this.$__.validationError;\n  this.$__.backup.errors = this.$errors;\n\n  // Clear 'dirty' cache\n  this.$__.activePaths.clear('modify');\n  this.$__.activePaths.clear('default');\n  this.$__.validationError = undefined;\n  this.$errors = undefined;\n  _this = this;\n  this.$__schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__undoReset = function $__undoReset() {\n  if (this.$__.backup == null || this.$__.backup.activePaths == null) {\n    return;\n  }\n\n  this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;\n  this.$__.activePaths.states.default = this.$__.backup.activePaths.default;\n\n  this.$__.validationError = this.$__.backup.validationError;\n  this.$errors = this.$__.backup.errors;\n\n  for (const dirt of this.$__dirty()) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {\n      type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];\n    }\n  }\n\n  for (const subdoc of this.$getAllSubdocs()) {\n    subdoc.$__undoReset();\n  }\n};\n\n/**\n * Returns this documents dirty paths / vals.\n *\n * @return {Array}\n * @api private\n * @method $__dirty\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__dirty = function() {\n  const _this = this;\n  let all = this.$__.activePaths.map('modify', function(path) {\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map('default', function(path) {\n    if (path === '_id' || _this.$__getValue(path) == null) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  const allPaths = new Map(all.filter((el) => el != null).map((el) => [el.path, el.value]));\n  // Ignore \"foo.a\" if \"foo\" is dirty already.\n  const minimal = [];\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n\n    let top = null;\n\n    const array = parentPaths(item.path);\n    for (let i = 0; i < array.length - 1; i++) {\n      if (allPaths.has(array[i])) {\n        top = allPaths.get(array[i]);\n        break;\n      }\n    }\n    if (top == null) {\n      minimal.push(item);\n    } else if (top != null &&\n        top[arrayAtomicsSymbol] != null &&\n        top.hasAtomics()) {\n      // special case for top level MongooseArrays\n      // the `top` array itself and a sub path of `top` are being set.\n      // the only way to honor all of both modifications is through a $set\n      // of entire array.\n      top[arrayAtomicsSymbol] = {};\n      top[arrayAtomicsSymbol].$set = top;\n    }\n  });\n  return minimal;\n};\n\n/**\n * Assigns/compiles `schema` into this documents prototype.\n *\n * @param {Schema} schema\n * @api private\n * @method $__setSchema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__setSchema = function(schema) {\n  compile(schema.tree, this, undefined, schema.options);\n\n  // Apply default getters if virtual doesn't have any (gh-6262)\n  for (const key of Object.keys(schema.virtuals)) {\n    schema.virtuals[key]._applyDefaultGetters();\n  }\n  if (schema.path('schema') == null) {\n    this.schema = schema;\n  }\n  this.$__schema = schema;\n  this[documentSchemaSymbol] = schema;\n};\n\n\n/**\n * Get active path that were changed and are arrays\n *\n * @return {Array}\n * @api private\n * @method $__getArrayPathsToValidate\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__getArrayPathsToValidate = function() {\n  DocumentArray || (DocumentArray = require('./types/DocumentArray'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n    .map('init', 'modify', function(i) {\n      return this.$__getValue(i);\n    }.bind(this))\n    .filter(function(val) {\n      return val && Array.isArray(val) && utils.isMongooseDocumentArray(val) && val.length;\n    }).reduce(function(seed, array) {\n      return seed.concat(array);\n    }, [])\n    .filter(function(doc) {\n      return doc;\n    });\n};\n\n\n/**\n * Get all subdocs (by bfs)\n *\n * @return {Array}\n * @api public\n * @method $getAllSubdocs\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$getAllSubdocs = function() {\n  DocumentArray || (DocumentArray = require('./types/DocumentArray'));\n  Embedded = Embedded || require('./types/ArraySubdocument');\n\n  function docReducer(doc, seed, path) {\n    let val = doc;\n    let isNested = false;\n    if (path) {\n      if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {\n        val = doc._doc[path];\n      } else if (doc instanceof Document && doc[documentSchemaSymbol].nested[path]) {\n        val = doc._doc[path];\n        isNested = true;\n      } else {\n        val = doc[path];\n      }\n    }\n    if (val instanceof Embedded) {\n      seed.push(val);\n    } else if (val instanceof Map) {\n      seed = Array.from(val.keys()).reduce(function(seed, path) {\n        return docReducer(val.get(path), seed, null);\n      }, seed);\n    } else if (val && !Array.isArray(val) && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(function(seed, path) {\n        return docReducer(val, seed, path);\n      }, seed);\n      seed.push(val);\n    } else if (val && utils.isMongooseDocumentArray(val)) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        seed = Object.keys(doc._doc).reduce(function(seed, path) {\n          return docReducer(doc._doc, seed, path);\n        }, seed);\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n      });\n    } else if (isNested && val != null) {\n      for (const path of Object.keys(val)) {\n        docReducer(val, seed, path);\n      }\n    }\n    return seed;\n  }\n\n  const subDocs = [];\n  for (const path of Object.keys(this._doc)) {\n    docReducer(this, subDocs, path);\n  }\n\n  return subDocs;\n};\n\n/*!\n * Runs queued functions\n */\n\nfunction applyQueue(doc) {\n  const q = doc.$__schema && doc.$__schema.callQueue;\n  if (!q.length) {\n    return;\n  }\n\n  for (const pair of q) {\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      doc[pair[0]].apply(doc, pair[1]);\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__handleReject = function handleReject(err) {\n  // emit on the Model if listening\n  if (this.$listeners('error').length) {\n    this.$emit('error', err);\n  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {\n    this.constructor.emit('error', err);\n  }\n};\n\n/**\n * Internal helper for toObject() and toJSON() that doesn't manipulate options\n *\n * @return {Object}\n * @api private\n * @method $toObject\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$toObject = function(options, json) {\n  let defaultOptions = {\n    transform: true,\n    flattenDecimals: true\n  };\n\n  const path = json ? 'toJSON' : 'toObject';\n  const baseOptions = this.constructor &&\n    this.constructor.base &&\n    this.constructor.base.options &&\n    get(this.constructor.base.options, path) || {};\n  const schemaOptions = this.$__schema && this.$__schema.options || {};\n  // merge base default options with Schema's set default options if available.\n  // `clone` is necessary here because `utils.options` directly modifies the second input.\n  defaultOptions = utils.options(defaultOptions, clone(baseOptions));\n  defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path] || {}));\n\n  // If options do not exist or is not an object, set it to empty object\n  options = utils.isPOJO(options) ? { ...options } : {};\n  options._calledWithOptions = options._calledWithOptions || { ...options };\n\n  let _minimize;\n  if (options._calledWithOptions.minimize != null) {\n    _minimize = options.minimize;\n  } else if (defaultOptions.minimize != null) {\n    _minimize = defaultOptions.minimize;\n  } else {\n    _minimize = schemaOptions.minimize;\n  }\n\n  let flattenMaps;\n  if (options._calledWithOptions.flattenMaps != null) {\n    flattenMaps = options.flattenMaps;\n  } else if (defaultOptions.flattenMaps != null) {\n    flattenMaps = defaultOptions.flattenMaps;\n  } else {\n    flattenMaps = schemaOptions.flattenMaps;\n  }\n\n  // The original options that will be passed to `clone()`. Important because\n  // `clone()` will recursively call `$toObject()` on embedded docs, so we\n  // need the original options the user passed in, plus `_isNested` and\n  // `_parentOptions` for checking whether we need to depopulate.\n  const cloneOptions = Object.assign({}, options, {\n    _isNested: true,\n    json: json,\n    minimize: _minimize,\n    flattenMaps: flattenMaps,\n    _seen: (options && options._seen) || new Map()\n  });\n\n  if (utils.hasUserDefinedProperty(options, 'getters')) {\n    cloneOptions.getters = options.getters;\n  }\n  if (utils.hasUserDefinedProperty(options, 'virtuals')) {\n    cloneOptions.virtuals = options.virtuals;\n  }\n\n  const depopulate = options.depopulate ||\n    (options._parentOptions && options._parentOptions.depopulate || false);\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate the top-level document\n  if (depopulate && options._isNested && this.$__.wasPopulated) {\n    return clone(this.$__.wasPopulated.value || this._id, cloneOptions);\n  }\n\n  // merge default options with input options.\n  options = utils.options(defaultOptions, options);\n  options._isNested = true;\n  options.json = json;\n  options.minimize = _minimize;\n\n  cloneOptions._parentOptions = options;\n  cloneOptions._skipSingleNestedGetters = false;\n\n  const gettersOptions = Object.assign({}, cloneOptions);\n  gettersOptions._skipSingleNestedGetters = true;\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  const originalTransform = options.transform;\n\n  let ret = clone(this._doc, cloneOptions) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, gettersOptions);\n\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || (options.getters && options.virtuals !== false)) {\n    applyVirtuals(this, ret, gettersOptions, options);\n  }\n\n  if (options.versionKey === false && this.$__schema.options.versionKey) {\n    delete ret[this.$__schema.options.versionKey];\n  }\n\n  let transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema's transform and\n  // not the parent schema's\n  if (transform) {\n    applySchemaTypeTransforms(this, ret);\n  }\n\n  if (options.useProjection) {\n    omitDeselectedFields(this, ret);\n  }\n\n  if (transform === true || (schemaOptions.toObject && transform)) {\n    const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === 'function') {\n    const xformed = transform(this, ret, options);\n    if (typeof xformed !== 'undefined') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Converts this document into a plain-old JavaScript object ([POJO](https://masteringjs.io/tutorials/fundamentals/pojo)).\n *\n * Buffers are converted to instances of [mongodb.Binary](https://mongodb.github.io/node-mongodb-native/4.9/classes/Binary.html) for proper storage.\n *\n * #### Getters/Virtuals\n *\n * Example of only applying path getters\n *\n *     doc.toObject({ getters: true, virtuals: false })\n *\n * Example of only applying virtual getters\n *\n *     doc.toObject({ virtuals: true })\n *\n * Example of applying both path and virtual getters\n *\n *     doc.toObject({ getters: true })\n *\n * To apply these options to every document of your schema by default, set your [schemas](#schema_Schema) `toObject` option to the same argument.\n *\n *     schema.set('toObject', { virtuals: true })\n *\n * #### Transform:\n *\n * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.\n *\n * Transform functions receive three arguments\n *\n *     function (doc, ret, options) {}\n *\n * - `doc` The mongoose document which is being converted\n * - `ret` The plain object representation which has been converted\n * - `options` The options in use (either schema options or the options passed inline)\n *\n * #### Example:\n *\n *     // specify the transform schema option\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       // remove the _id of every document before returning the result\n *       delete ret._id;\n *       return ret;\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { name: 'Wreck-it Ralph' }\n *\n * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       return { movie: ret.name }\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { movie: 'Wreck-it Ralph' }\n *\n * _Note: if a transform function returns `undefined`, the return value will be ignored._\n *\n * Transformations may also be applied inline, overridding any transform set in the options:\n *\n *     function xform (doc, ret, options) {\n *       return { inline: ret.name, custom: true }\n *     }\n *\n *     // pass the transform as an inline option\n *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }\n *\n * If you want to skip transformations, use `transform: false`:\n *\n *     schema.options.toObject.hide = '_id';\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       if (options.hide) {\n *         options.hide.split(' ').forEach(function (prop) {\n *           delete ret[prop];\n *         });\n *       }\n *       return ret;\n *     }\n *\n *     const doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });\n *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: false });// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }\n *\n * If you pass a transform in `toObject()` options, Mongoose will apply the transform\n * to [subdocuments](/docs/subdocs.html) in addition to the top-level document.\n * Similarly, `transform: false` skips transforms for all subdocuments.\n * Note that this behavior is different for transforms defined in the schema:\n * if you define a transform in `schema.options.toObject.transform`, that transform\n * will **not** apply to subdocuments.\n *\n *     const memberSchema = new Schema({ name: String, email: String });\n *     const groupSchema = new Schema({ members: [memberSchema], name: String, email });\n *     const Group = mongoose.model('Group', groupSchema);\n *\n *     const doc = new Group({\n *       name: 'Engineering',\n *       email: 'dev@mongoosejs.io',\n *       members: [{ name: 'Val', email: 'val@mongoosejs.io' }]\n *     });\n *\n *     // Removes `email` from both top-level document **and** array elements\n *     // { name: 'Engineering', members: [{ name: 'Val' }] }\n *     doc.toObject({ transform: (doc, ret) => { delete ret.email; return ret; } });\n *\n * Transforms, like all of these options, are also available for `toJSON`. See [this guide to `JSON.stringify()`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html) to learn why `toJSON()` and `toObject()` are separate functions.\n *\n * See [schema options](/docs/guide.html#toObject) for some more details.\n *\n * _During save, no custom options are applied to the document before being sent to the database._\n *\n * @param {Object} [options]\n * @param {Boolean} [options.getters=false] if true, apply all getters, including virtuals\n * @param {Boolean} [options.virtuals=false] if true, apply virtuals, including aliases. Use `{ getters: true, virtuals: false }` to just apply getters, not virtuals\n * @param {Boolean} [options.aliases=true] if `options.virtuals = true`, you can set `options.aliases = false` to skip applying aliases. This option is a no-op if `options.virtuals = false`.\n * @param {Boolean} [options.minimize=true] if true, omit any empty objects from the output\n * @param {Function|null} [options.transform=null] if set, mongoose will call this function to allow you to transform the returned object\n * @param {Boolean} [options.depopulate=false] if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths.\n * @param {Boolean} [options.versionKey=true] if false, exclude the version key (`__v` by default) from the output\n * @param {Boolean} [options.flattenMaps=false] if true, convert Maps to POJOs. Useful if you want to `JSON.stringify()` the result of `toObject()`.\n * @param {Boolean} [options.useProjection=false] - If true, omits fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.\n * @return {Object} js object (not a POJO)\n * @see mongodb.Binary https://mongodb.github.io/node-mongodb-native/4.9/classes/Binary.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toObject = function(options) {\n  return this.$toObject(options);\n};\n\n/**\n * Minimizes an object, removing undefined values and empty objects\n *\n * @param {Object} object to minimize\n * @return {Object}\n * @api private\n */\n\nfunction minimize(obj) {\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys;\n  let key;\n  let val;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if (utils.isPOJO(val)) {\n      obj[key] = minimize(val);\n    }\n\n    if (undefined === obj[key]) {\n      delete obj[key];\n      continue;\n    }\n\n    hasKeys = true;\n  }\n\n  return hasKeys\n    ? obj\n    : undefined;\n}\n\n/*!\n * Applies virtuals properties to `json`.\n */\n\nfunction applyVirtuals(self, json, options, toObjectOptions) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.virtuals);\n  let i = paths.length;\n  const numPaths = i;\n  let path;\n  let assignPath;\n  let cur = self._doc;\n  let v;\n  const aliases = typeof (toObjectOptions && toObjectOptions.aliases) === 'boolean'\n    ? toObjectOptions.aliases\n    : true;\n\n  let virtualsToApply = null;\n  if (Array.isArray(options.virtuals)) {\n    virtualsToApply = new Set(options.virtuals);\n  }\n  else if (options.virtuals && options.virtuals.pathsToSkip) {\n    virtualsToApply = new Set(paths);\n    for (let i = 0; i < options.virtuals.pathsToSkip.length; i++) {\n      if (virtualsToApply.has(options.virtuals.pathsToSkip[i])) {\n        virtualsToApply.delete(options.virtuals.pathsToSkip[i]);\n      }\n    }\n  }\n\n  if (!cur) {\n    return json;\n  }\n\n  options = options || {};\n  for (i = 0; i < numPaths; ++i) {\n    path = paths[i];\n\n    if (virtualsToApply != null && !virtualsToApply.has(path)) {\n      continue;\n    }\n\n    // Allow skipping aliases with `toObject({ virtuals: true, aliases: false })`\n    if (!aliases && schema.aliases.hasOwnProperty(path)) {\n      continue;\n    }\n\n    // We may be applying virtuals to a nested object, for example if calling\n    // `doc.nestedProp.toJSON()`. If so, the path we assign to, `assignPath`,\n    // will be a trailing substring of the `path`.\n    assignPath = path;\n    if (options.path != null) {\n      if (!path.startsWith(options.path + '.')) {\n        continue;\n      }\n      assignPath = path.substring(options.path.length + 1);\n    }\n    const parts = assignPath.split('.');\n    v = clone(self.get(path), options);\n    if (v === void 0) {\n      continue;\n    }\n    const plen = parts.length;\n    cur = json;\n    for (let j = 0; j < plen - 1; ++j) {\n      cur[parts[j]] = cur[parts[j]] || {};\n      cur = cur[parts[j]];\n    }\n    cur[parts[plen - 1]] = v;\n  }\n\n  return json;\n}\n\n\n/**\n * Applies virtuals properties to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @param {Object} [options]\n * @return {Object} `json`\n * @api private\n */\n\nfunction applyGetters(self, json, options) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths);\n  let i = paths.length;\n  let path;\n  let cur = self._doc;\n  let v;\n\n  if (!cur) {\n    return json;\n  }\n\n  while (i--) {\n    path = paths[i];\n\n    const parts = path.split('.');\n    const plen = parts.length;\n    const last = plen - 1;\n    let branch = json;\n    let part;\n    cur = self._doc;\n\n    if (!self.$__isSelected(path)) {\n      continue;\n    }\n\n    for (let ii = 0; ii < plen; ++ii) {\n      part = parts[ii];\n      v = cur[part];\n      if (ii === last) {\n        const val = self.$get(path);\n        branch[part] = clone(val, options);\n      } else if (v == null) {\n        if (part in cur) {\n          branch[part] = v;\n        }\n        break;\n      } else {\n        branch = branch[part] || (branch[part] = {});\n      }\n      cur = v;\n    }\n  }\n\n  return json;\n}\n\n/**\n * Applies schema type transforms to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @return {Object} `json`\n * @api private\n */\n\nfunction applySchemaTypeTransforms(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  for (const path of paths) {\n    const schematype = schema.paths[path];\n    if (typeof schematype.options.transform === 'function') {\n      const val = self.$get(path);\n      if (val === undefined) {\n        continue;\n      }\n      const transformedValue = schematype.options.transform.call(self, val);\n      throwErrorIfPromise(path, transformedValue);\n      utils.setValue(path, transformedValue, json);\n    } else if (schematype.$embeddedSchemaType != null &&\n        typeof schematype.$embeddedSchemaType.options.transform === 'function') {\n      const val = self.$get(path);\n      if (val === undefined) {\n        continue;\n      }\n      const vals = [].concat(val);\n      const transform = schematype.$embeddedSchemaType.options.transform;\n      for (let i = 0; i < vals.length; ++i) {\n        const transformedValue = transform.call(self, vals[i]);\n        vals[i] = transformedValue;\n        throwErrorIfPromise(path, transformedValue);\n      }\n\n      json[path] = vals;\n    }\n  }\n\n  return json;\n}\n\nfunction throwErrorIfPromise(path, transformedValue) {\n  if (isPromise(transformedValue)) {\n    throw new Error('`transform` function must be synchronous, but the transform on path `' + path + '` returned a promise.');\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction omitDeselectedFields(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  let selected = self.$__.selected;\n  if (selected === void 0) {\n    selected = {};\n    queryhelpers.applyPaths(selected, schema);\n  }\n  if (selected == null || Object.keys(selected).length === 0) {\n    return json;\n  }\n\n  for (const path of paths) {\n    if (selected[path] != null && !selected[path]) {\n      delete json[path];\n    }\n  }\n\n  return json;\n}\n\n/**\n * The return value of this method is used in calls to [`JSON.stringify(doc)`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript#the-tojson-function).\n *\n * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.\n *\n *     schema.set('toJSON', { virtuals: true });\n *\n * There is one difference between `toJSON()` and `toObject()` options.\n * When you call `toJSON()`, the [`flattenMaps` option](./document.html#document_Document-toObject) defaults to `true`, because `JSON.stringify()` doesn't convert maps to objects by default.\n * When you call `toObject()`, the `flattenMaps` option is `false` by default.\n *\n * See [schema options](/docs/guide.html#toJSON) for more information on setting `toJSON` option defaults.\n *\n * @param {Object} options\n * @param {Boolean} [options.flattenMaps=true] if true, convert Maps to [POJOs](https://masteringjs.io/tutorials/fundamentals/pojo). Useful if you want to `JSON.stringify()` the result.\n * @return {Object}\n * @see Document#toObject #document_Document-toObject\n * @see JSON.stringify() in JavaScript https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toJSON = function(options) {\n  return this.$toObject(options, true);\n};\n\n\nDocument.prototype.ownerDocument = function() {\n  return this;\n};\n\n\n/**\n * If this document is a subdocument or populated document, returns the document's\n * parent. Returns the original document if there is no parent.\n *\n * @return {Document}\n * @api public\n * @method parent\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.parent = function() {\n  if (this.$isSubdocument || this.$__.wasPopulated) {\n    return this.$__.parent;\n  }\n  return this;\n};\n\n/**\n * Alias for [`parent()`](#document_Document-parent). If this document is a subdocument or populated\n * document, returns the document's parent. Returns `undefined` otherwise.\n *\n * @return {Document}\n * @api public\n * @method $parent\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$parent = Document.prototype.parent;\n\n/**\n * Helper for console.log\n *\n * @return {String}\n * @api public\n * @method inspect\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.inspect = function(options) {\n  const isPOJO = utils.isPOJO(options);\n  let opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n  }\n  const ret = this.toObject(opts);\n\n  if (ret == null) {\n    // If `toObject()` returns null, `this` is still an object, so if `inspect()`\n    // prints out null this can cause some serious confusion. See gh-7942.\n    return 'MongooseDocument { ' + ret + ' }';\n  }\n\n  return ret;\n};\n\nif (inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  Document.prototype[inspect.custom] = Document.prototype.inspect;\n}\n\n/**\n * Helper for console.log\n *\n * @return {String}\n * @api public\n * @method toString\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toString = function() {\n  const ret = this.inspect();\n  if (typeof ret === 'string') {\n    return ret;\n  }\n  return inspect(ret);\n};\n\n/**\n * Returns true if this document is equal to another document.\n *\n * Documents are considered equal when they have matching `_id`s, unless neither\n * document has an `_id`, in which case this function falls back to using\n * `deepEqual()`.\n *\n * @param {Document} [doc] a document to compare. If falsy, will always return \"false\".\n * @return {Boolean}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.equals = function(doc) {\n  if (!doc) {\n    return false;\n  }\n\n  const tid = this.$__getValue('_id');\n  const docid = doc.$__ != null ? doc.$__getValue('_id') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n    ? tid.equals(docid)\n    : tid === docid;\n};\n\n/**\n * Populates paths on an existing document.\n *\n * #### Example:\n *\n *     // Given a document, `populate()` lets you pull in referenced docs\n *     await doc.populate([\n *       'stories',\n *       { path: 'fans', sort: { name: -1 } }\n *     ]);\n *     doc.populated('stories'); // Array of ObjectIds\n *     doc.stories[0].title; // 'Casino Royale'\n *     doc.populated('fans'); // Array of ObjectIds\n *\n *     // If the referenced doc has been deleted, `populate()` will\n *     // remove that entry from the array.\n *     await Story.delete({ title: 'Casino Royale' });\n *     await doc.populate('stories'); // Empty array\n *\n *     // You can also pass additional query options to `populate()`,\n *     // like projections:\n *     await doc.populate('fans', '-email');\n *     doc.fans[0].email // undefined because of 2nd param `select`\n *\n * @param {String|Object|Array} path either the path to populate or an object specifying all parameters, or either an array of those\n * @param {Object|String} [select] Field selection for the population query\n * @param {Model} [model] The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.\n * @param {Object} [match] Conditions for the population query\n * @param {Object} [options] Options for the population query (sort, etc)\n * @param {String} [options.path=null] The path to populate.\n * @param {string|PopulateOptions} [options.populate=null] Recursively populate paths in the populated documents. See [deep populate docs](/docs/populate.html#deep-populate).\n * @param {boolean} [options.retainNullValues=false] by default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n * @param {boolean} [options.getters=false] if true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](/docs/schematypes.html#schematype-options).\n * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.\n * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @param {Function} [callback] Callback\n * @see population /docs/populate.html\n * @see Query#select #query_Query-select\n * @see Model.populate #model_Model-populate\n * @memberOf Document\n * @instance\n * @return {Promise|null} Returns a Promise if no `callback` is given.\n * @api public\n */\n\nDocument.prototype.populate = function populate() {\n  const pop = {};\n  const args = [...arguments];\n  let fn;\n\n  if (args.length !== 0) {\n    if (typeof args[args.length - 1] === 'function') {\n      fn = args.pop();\n    }\n\n    // use hash to remove duplicate paths\n    const res = utils.populate.apply(null, args);\n    for (const populateOptions of res) {\n      pop[populateOptions.path] = populateOptions;\n    }\n  }\n\n  const paths = utils.object.vals(pop);\n  let topLevelModel = this.constructor;\n  if (this.$__isNested) {\n    topLevelModel = this.$__[scopeSymbol].constructor;\n    const nestedPath = this.$__.nestedPath;\n    paths.forEach(function(populateOptions) {\n      populateOptions.path = nestedPath + '.' + populateOptions.path;\n    });\n  }\n\n  // Use `$session()` by default if the document has an associated session\n  // See gh-6754\n  if (this.$session() != null) {\n    const session = this.$session();\n    paths.forEach(path => {\n      if (path.options == null) {\n        path.options = { session: session };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  paths.forEach(p => {\n    p._localModel = topLevelModel;\n  });\n\n  return topLevelModel.populate(this, paths, fn);\n};\n\n/**\n * Gets all populated documents associated with this document.\n *\n * @api public\n * @return {Document[]} array of populated documents. Empty array if there are no populated documents associated with this document.\n * @memberOf Document\n * @method $getPopulatedDocs\n * @instance\n */\n\nDocument.prototype.$getPopulatedDocs = function $getPopulatedDocs() {\n  let keys = [];\n  if (this.$__.populated != null) {\n    keys = keys.concat(Object.keys(this.$__.populated));\n  }\n  let result = [];\n  for (const key of keys) {\n    const value = this.$get(key);\n    if (Array.isArray(value)) {\n      result = result.concat(value);\n    } else if (value instanceof Document) {\n      result.push(value);\n    }\n  }\n  return result;\n};\n\n/**\n * Gets _id(s) used during population of the given `path`.\n *\n * #### Example:\n *\n *     const doc = await Model.findOne().populate('author');\n *\n *     console.log(doc.author.name); // Dr.Seuss\n *     console.log(doc.populated('author')); // '5144cf8050f071d979c118a7'\n *\n * If the path was not populated, returns `undefined`.\n *\n * @param {String} path\n * @param {Any} [val]\n * @param {Object} [options]\n * @return {Array|ObjectId|Number|Buffer|String|undefined}\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.populated = function(path, val, options) {\n  // val and options are internal\n  if (val == null || val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    if (typeof path !== 'string') {\n      return undefined;\n    }\n\n    // Map paths can be populated with either `path.$*` or just `path`\n    const _path = path.endsWith('.$*') ? path.replace(/\\.\\$\\*$/, '') : path;\n\n    const v = this.$__.populated[_path];\n    if (v) {\n      return val === true ? v : v.value;\n    }\n    return undefined;\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = { value: val, options: options };\n\n  // If this was a nested populate, make sure each populated doc knows\n  // about its populated children (gh-7685)\n  const pieces = path.split('.');\n  for (let i = 0; i < pieces.length - 1; ++i) {\n    const subpath = pieces.slice(0, i + 1).join('.');\n    const subdoc = this.$get(subpath);\n    if (subdoc != null && subdoc.$__ != null && this.$populated(subpath)) {\n      const rest = pieces.slice(i + 1).join('.');\n      subdoc.$populated(rest, val, options);\n      // No need to continue because the above recursion should take care of\n      // marking the rest of the docs as populated\n      break;\n    }\n  }\n\n  return val;\n};\n\n/**\n * Alias of [`.populated`](#document_Document-populated).\n *\n * @method $populated\n * @memberOf Document\n * @api public\n */\n\nDocument.prototype.$populated = Document.prototype.populated;\n\n/**\n * Throws an error if a given path is not populated\n *\n * #### Example:\n *\n *     const doc = await Model.findOne().populate('author');\n *\n *     doc.$assertPopulated('author'); // does not throw\n *     doc.$assertPopulated('other path'); // throws an error\n *\n *     // Manually populate and assert in one call. The following does\n *     // `doc.$set({ likes })` before asserting.\n *     doc.$assertPopulated('likes', { likes });\n *\n *\n * @param {String|String[]} path path or array of paths to check. `$assertPopulated` throws if any of the given paths is not populated.\n * @param {Object} [values] optional values to `$set()`. Convenient if you want to manually populate a path and assert that the path was populated in 1 call.\n * @return {Document} this\n * @memberOf Document\n * @method $assertPopulated\n * @instance\n * @api public\n */\n\nDocument.prototype.$assertPopulated = function $assertPopulated(path, values) {\n  if (Array.isArray(path)) {\n    path.forEach(p => this.$assertPopulated(p, values));\n    return this;\n  }\n\n  if (arguments.length > 1) {\n    this.$set(values);\n  }\n\n  if (!this.$populated(path)) {\n    throw new MongooseError(`Expected path \"${path}\" to be populated`);\n  }\n\n  return this;\n};\n\n/**\n * Takes a populated field and returns it to its unpopulated state.\n *\n * #### Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name); // Dr.Seuss\n *       console.log(doc.depopulate('author'));\n *       console.log(doc.author); // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not provided, then all populated fields are returned to their unpopulated state.\n *\n * @param {String|String[]} [path] Specific Path to depopulate. If unset, will depopulate all paths on the Document. Or multiple space-delimited paths.\n * @return {Document} this\n * @see Document.populate #document_Document-populate\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.depopulate = function(path) {\n  if (typeof path === 'string') {\n    path = path.indexOf(' ') === -1 ? [path] : path.split(' ');\n  }\n\n  let populatedIds;\n  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];\n  const populated = this.$__ && this.$__.populated || {};\n\n  if (arguments.length === 0) {\n    // Depopulate all\n    for (const virtualKey of virtualKeys) {\n      delete this.$$populatedVirtuals[virtualKey];\n      delete this._doc[virtualKey];\n      delete populated[virtualKey];\n    }\n\n    const keys = Object.keys(populated);\n\n    for (const key of keys) {\n      populatedIds = this.$populated(key);\n      if (!populatedIds) {\n        continue;\n      }\n      delete populated[key];\n      utils.setValue(key, populatedIds, this._doc);\n    }\n    return this;\n  }\n\n  for (const singlePath of path) {\n    populatedIds = this.$populated(singlePath);\n    delete populated[singlePath];\n\n    if (virtualKeys.indexOf(singlePath) !== -1) {\n      delete this.$$populatedVirtuals[singlePath];\n      delete this._doc[singlePath];\n    } else if (populatedIds) {\n      utils.setValue(singlePath, populatedIds, this._doc);\n    }\n  }\n  return this;\n};\n\n\n/**\n * Returns the full path to this document.\n *\n * @param {String} [path]\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__fullPath = function(path) {\n  // overridden in SubDocuments\n  return path || '';\n};\n\n/**\n * Returns the changes that happened to the document\n * in the format that will be sent to MongoDB.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({\n *       name: String,\n *       age: Number,\n *       country: String\n *     });\n *     const User = mongoose.model('User', userSchema);\n *     const user = await User.create({\n *       name: 'Hafez',\n *       age: 25,\n *       country: 'Egypt'\n *     });\n *\n *     // returns an empty object, no changes happened yet\n *     user.getChanges(); // { }\n *\n *     user.country = undefined;\n *     user.age = 26;\n *\n *     user.getChanges(); // { $set: { age: 26 }, { $unset: { country: 1 } } }\n *\n *     await user.save();\n *\n *     user.getChanges(); // { }\n *\n * Modifying the object that `getChanges()` returns does not affect the document's\n * change tracking state. Even if you `delete user.getChanges().$set`, Mongoose\n * will still send a `$set` to the server.\n *\n * @return {Object}\n * @api public\n * @method getChanges\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.getChanges = function() {\n  const delta = this.$__delta();\n  const changes = delta ? delta[1] : {};\n  return changes;\n};\n\n/**\n * Returns a copy of this document with a deep clone of `_doc` and `$__`.\n *\n * @return {Document} a copy of this document\n * @api public\n * @method $clone\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$clone = function() {\n  const Model = this.constructor;\n  const clonedDoc = new Model();\n  clonedDoc.$isNew = this.$isNew;\n  if (this._doc) {\n    clonedDoc._doc = clone(this._doc);\n  }\n  if (this.$__) {\n    const Cache = this.$__.constructor;\n    const clonedCache = new Cache();\n    for (const key of Object.getOwnPropertyNames(this.$__)) {\n      if (key === 'activePaths') {\n        continue;\n      }\n      clonedCache[key] = clone(this.$__[key]);\n    }\n    Object.assign(clonedCache.activePaths, clone({ ...this.$__.activePaths }));\n    clonedDoc.$__ = clonedCache;\n  }\n  return clonedDoc;\n};\n\n/*!\n * Module exports.\n */\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;\n", "'use strict';\n\n/**\n * Module dependencies.\n */\n\nconst start = require('./common');\n\nconst Document = require('../lib/document');\nconst EventEmitter = require('events').EventEmitter;\nconst ArraySubdocument = require('../lib/types/ArraySubdocument');\nconst Query = require('../lib/query');\nconst assert = require('assert');\nconst idGetter = require('../lib/helpers/schema/idGetter');\nconst util = require('./util');\nconst utils = require('../lib/utils');\n\nconst mongoose = start.mongoose;\nconst Schema = mongoose.Schema;\nconst ObjectId = Schema.ObjectId;\nconst DocumentObjectId = mongoose.Types.ObjectId;\nconst SchemaType = mongoose.SchemaType;\nconst ValidatorError = SchemaType.ValidatorError;\nconst ValidationError = mongoose.Document.ValidationError;\nconst VersionError = mongoose.Error.VersionError;\nconst MongooseError = mongoose.Error;\nconst DocumentNotFoundError = mongoose.Error.DocumentNotFoundError;\n\n/**\n * Test Document constructor.\n */\n\nfunction TestDocument() {\n  Document.apply(this, arguments);\n}\n\n/**\n * Inherits from Document.\n */\n\nObject.setPrototypeOf(TestDocument.prototype, Document.prototype);\n\nfor (const i in EventEmitter.prototype) {\n  TestDocument[i] = EventEmitter.prototype[i];\n}\n\n/**\n * Set a dummy schema to simulate compilation.\n */\n\nconst em = new Schema({ title: String, body: String });\nem.virtual('works').get(function() {\n  return 'em virtual works';\n});\nconst schema = new Schema({\n  test: String,\n  oids: [ObjectId],\n  numbers: [Number],\n  nested: {\n    age: Number,\n    cool: ObjectId,\n    deep: { x: String },\n    path: String,\n    setr: String\n  },\n  nested2: {\n    nested: String,\n    yup: {\n      nested: Boolean,\n      yup: String,\n      age: Number\n    }\n  },\n  em: [em],\n  date: Date\n});\n\nTestDocument.prototype.$__setSchema(idGetter(schema));\n\nschema.virtual('nested.agePlus2').get(function() {\n  return this.nested.age + 2;\n});\nschema.virtual('nested.setAge').set(function(v) {\n  this.nested.age = v;\n});\nschema.path('nested.path').get(function(v) {\n  return (this.nested.age || '') + (v ? v : '');\n});\nschema.path('nested.setr').set(function(v) {\n  return v + ' setter';\n});\n\nlet dateSetterCalled = false;\nschema.path('date').set(function(v) {\n  // should not have been cast to a Date yet\n  if (v !== undefined) {\n    assert.equal(typeof v, 'string');\n  }\n  dateSetterCalled = true;\n  return v;\n});\n\n/**\n * Method subject to hooks. Simply fires the callback once the hooks are\n * executed.\n */\n\nTestDocument.prototype.hooksTest = function(fn) {\n  fn(null, arguments);\n};\n\nconst childSchema = new Schema({ counter: Number });\n\nconst parentSchema = new Schema({\n  name: String,\n  children: [childSchema]\n});\n\n/**\n * Test.\n */\n\ndescribe('document', function() {\n  let db;\n\n  before(function() {\n    db = start();\n  });\n\n  after(async function() {\n    await db.close();\n  });\n\n  beforeEach(() => db.deleteModel(/.*/));\n  afterEach(() => util.clearTestData(db));\n  afterEach(() => util.stopRemainingOps(db));\n\n  describe('constructor', function() {\n    it('supports passing in schema directly (gh-8237)', function() {\n      const myUserDoc = new Document({}, { name: String });\n      assert.ok(!myUserDoc.name);\n      myUserDoc.name = 123;\n      assert.strictEqual(myUserDoc.name, '123');\n\n      assert.ifError(myUserDoc.validateSync());\n    });\n  });\n\n  describe('delete', function() {\n    it('deletes the document', async function() {\n      const schema = new Schema({ x: String });\n      const Test = db.model('Test', schema);\n\n      const test = new Test({ x: 'test' });\n      const doc = await test.save();\n      await doc.delete();\n      const found = await Test.findOne({ _id: doc._id });\n      assert.strictEqual(found, null);\n\n    });\n  });\n\n  describe('updateOne', function() {\n    let Test;\n\n    before(function() {\n      const schema = new Schema({ x: String, y: String });\n      db.deleteModel(/^Test$/);\n      Test = db.model('Test', schema);\n    });\n\n    it('updates the document', async function() {\n      const test = new Test({ x: 'test' });\n      const doc = await test.save();\n      await doc.updateOne({ y: 'test' });\n      const found = await Test.findOne({ _id: doc._id });\n      assert.strictEqual(found.y, 'test');\n    });\n\n    it('returns a query', function() {\n      const doc = new Test({ x: 'test' });\n      assert.ok(doc.updateOne() instanceof Test.Query);\n    });\n\n    it('middleware (gh-8262)', async function() {\n      const schema = new Schema({ x: String, y: String });\n      const docs = [];\n      schema.post('updateOne', { document: true, query: false }, function(doc, next) {\n        docs.push(doc);\n        next();\n      });\n      const Model = db.model('Test', schema);\n\n\n      const doc = await Model.create({ x: 2, y: 4 });\n\n      await doc.updateOne({ x: 4 });\n      assert.equal(docs.length, 1);\n      assert.equal(docs[0], doc);\n    });\n  });\n\n  describe('replaceOne', function() {\n    it('replaces the document', async function() {\n      const schema = new Schema({ x: String });\n      const Test = db.model('Test', schema);\n\n      const test = new Test({ x: 'test' });\n      const doc = await test.save();\n      await doc.replaceOne({ x: 'updated' });\n      const found = await Test.findOne({ _id: doc._id });\n      assert.strictEqual(found.x, 'updated');\n\n    });\n  });\n\n  describe('shortcut getters', function() {\n    it('return undefined for properties with a null/undefined parent object (gh-1326)', function() {\n      const doc = new TestDocument();\n      doc.init({ nested: null });\n      assert.strictEqual(undefined, doc.nested.age);\n    });\n\n    it('work', function() {\n      const doc = new TestDocument();\n      doc.init({\n        test: 'test',\n        oids: [],\n        nested: {\n          age: 5,\n          cool: DocumentObjectId.createFromHexString('4c6c2d6240ced95d0e00003c'),\n          path: 'my path'\n        }\n      });\n\n      assert.equal(doc.test, 'test');\n      assert.ok(doc.oids instanceof Array);\n      assert.equal(doc.nested.age, 5);\n      assert.equal(String(doc.nested.cool), '4c6c2d6240ced95d0e00003c');\n      assert.equal(doc.nested.agePlus2, 7);\n      assert.equal(doc.nested.path, '5my path');\n      doc.nested.setAge = 10;\n      assert.equal(doc.nested.age, 10);\n      doc.nested.setr = 'set it';\n      assert.equal(doc.$__getValue('nested.setr'), 'set it setter');\n\n      const doc2 = new TestDocument();\n      doc2.init({\n        test: 'toop',\n        oids: [],\n        nested: {\n          age: 2,\n          cool: DocumentObjectId.createFromHexString('4cf70857337498f95900001c'),\n          deep: { x: 'yay' }\n        }\n      });\n\n      assert.equal(doc2.test, 'toop');\n      assert.ok(doc2.oids instanceof Array);\n      assert.equal(doc2.nested.age, 2);\n\n      // GH-366\n      assert.equal(doc2.nested.bonk, undefined);\n      assert.equal(doc2.nested.nested, undefined);\n      assert.equal(doc2.nested.test, undefined);\n      assert.equal(doc2.nested.age.test, undefined);\n      assert.equal(doc2.nested.age.nested, undefined);\n      assert.equal(doc2.oids.nested, undefined);\n      assert.equal(doc2.nested.deep.x, 'yay');\n      assert.equal(doc2.nested.deep.nested, undefined);\n      assert.equal(doc2.nested.deep.cool, undefined);\n      assert.equal(doc2.nested2.yup.nested, undefined);\n      assert.equal(doc2.nested2.yup.nested2, undefined);\n      assert.equal(doc2.nested2.yup.yup, undefined);\n      assert.equal(doc2.nested2.yup.age, undefined);\n      assert.equal(typeof doc2.nested2.yup, 'object');\n\n      doc2.nested2.yup = {\n        age: 150,\n        yup: 'Yesiree',\n        nested: true\n      };\n\n      assert.equal(doc2.nested2.nested, undefined);\n      assert.equal(doc2.nested2.yup.nested, true);\n      assert.equal(doc2.nested2.yup.yup, 'Yesiree');\n      assert.equal(doc2.nested2.yup.age, 150);\n      doc2.nested2.nested = 'y';\n      assert.equal(doc2.nested2.nested, 'y');\n      assert.equal(doc2.nested2.yup.nested, true);\n      assert.equal(doc2.nested2.yup.yup, 'Yesiree');\n      assert.equal(doc2.nested2.yup.age, 150);\n\n      assert.equal(String(doc2.nested.cool), '4cf70857337498f95900001c');\n\n      assert.ok(doc.oids !== doc2.oids);\n    });\n  });\n\n  it('test shortcut setters', function() {\n    const doc = new TestDocument();\n\n    doc.init({\n      test: 'Test',\n      nested: {\n        age: 5\n      }\n    });\n\n    assert.equal(doc.isModified('test'), false);\n    doc.test = 'Woot';\n    assert.equal(doc.test, 'Woot');\n    assert.equal(doc.isModified('test'), true);\n\n    assert.equal(doc.isModified('nested.age'), false);\n    doc.nested.age = 2;\n    assert.equal(doc.nested.age, 2);\n    assert.ok(doc.isModified('nested.age'));\n\n    doc.nested = { path: 'overwrite the entire nested object' };\n    assert.equal(doc.nested.age, undefined);\n    assert.equal(Object.keys(doc._doc.nested).length, 1);\n    assert.equal(doc.nested.path, 'overwrite the entire nested object');\n    assert.ok(doc.isModified('nested'));\n  });\n\n  it('test accessor of id', function() {\n    const doc = new TestDocument();\n    assert.ok(doc._id instanceof DocumentObjectId);\n  });\n\n  it('test shortcut of id hexString', function() {\n    const doc = new TestDocument();\n    assert.equal(typeof doc.id, 'string');\n  });\n\n  it('toObject options', function() {\n    const doc = new TestDocument();\n\n    doc.init({\n      test: 'test',\n      oids: [],\n      em: [{ title: 'asdf' }],\n      nested: {\n        age: 5,\n        cool: DocumentObjectId.createFromHexString('4c6c2d6240ced95d0e00003c'),\n        path: 'my path'\n      },\n      nested2: {},\n      date: new Date()\n    });\n\n    let clone = doc.toObject({ getters: true, virtuals: false });\n\n    assert.equal(clone.test, 'test');\n    assert.ok(clone.oids instanceof Array);\n    assert.equal(clone.nested.age, 5);\n    assert.equal(clone.nested.cool.toString(), '4c6c2d6240ced95d0e00003c');\n    assert.equal(clone.nested.path, '5my path');\n    assert.equal(clone.nested.agePlus2, undefined);\n    assert.equal(clone.em[0].works, undefined);\n    assert.ok(clone.date instanceof Date);\n\n    clone = doc.toObject({ virtuals: true });\n\n    assert.equal(clone.test, 'test');\n    assert.ok(clone.oids instanceof Array);\n    assert.equal(clone.nested.age, 5);\n    assert.equal(clone.nested.cool.toString(), '4c6c2d6240ced95d0e00003c');\n    assert.equal(clone.nested.path, 'my path');\n    assert.equal(clone.nested.agePlus2, 7);\n    assert.equal(clone.em[0].works, 'em virtual works');\n\n    clone = doc.toObject({ getters: true });\n\n    assert.equal(clone.test, 'test');\n    assert.ok(clone.oids instanceof Array);\n    assert.equal(clone.nested.age, 5);\n    assert.equal(clone.nested.cool.toString(), '4c6c2d6240ced95d0e00003c');\n    assert.equal(clone.nested.path, '5my path');\n    assert.equal(clone.nested.agePlus2, 7);\n    assert.equal(clone.em[0].works, 'em virtual works');\n\n    // test toObject options\n    doc.schema.options.toObject = { virtuals: true };\n    clone = doc.toObject({ transform: false, virtuals: true });\n    assert.equal(clone.test, 'test');\n    assert.ok(clone.oids instanceof Array);\n    assert.equal(clone.nested.age, 5);\n    assert.equal(clone.nested.cool.toString(), '4c6c2d6240ced95d0e00003c');\n\n    assert.equal(clone.nested.path, 'my path');\n    assert.equal(clone.nested.agePlus2, 7);\n    assert.equal(clone.em[0].title, 'asdf');\n    delete doc.schema.options.toObject;\n\n    // minimize\n    clone = doc.toObject({ minimize: true });\n    assert.equal(clone.nested2, undefined);\n    clone = doc.toObject({ minimize: true, getters: true });\n    assert.equal(clone.nested2, undefined);\n    clone = doc.toObject({ minimize: false });\n    assert.equal(clone.nested2.constructor.name, 'Object');\n    assert.equal(Object.keys(clone.nested2).length, 1);\n    clone = doc.toObject('2');\n    assert.equal(clone.nested2, undefined);\n\n    doc.schema.options.toObject = { minimize: false };\n    clone = doc.toObject({ transform: false, minimize: false });\n    assert.equal(clone.nested2.constructor.name, 'Object');\n    assert.equal(Object.keys(clone.nested2).length, 1);\n    delete doc.schema.options.toObject;\n\n    doc.schema.options.minimize = false;\n    clone = doc.toObject();\n    assert.equal(clone.nested2.constructor.name, 'Object');\n    assert.equal(Object.keys(clone.nested2).length, 1);\n    doc.schema.options.minimize = true;\n    clone = doc.toObject();\n    assert.equal(clone.nested2, undefined);\n\n    // transform\n    doc.schema.options.toObject = {};\n    doc.schema.options.toObject.transform = function xform(doc, ret) {\n      // ignore embedded docs\n      if (doc.$isSubdocument) {\n        return;\n      }\n\n      delete ret.em;\n      delete ret.numbers;\n      delete ret.oids;\n      ret._id = ret._id.toString();\n    };\n    clone = doc.toObject();\n    assert.equal(doc.id, clone._id);\n    assert.ok(undefined === clone.em);\n    assert.ok(undefined === clone.numbers);\n    assert.ok(undefined === clone.oids);\n    assert.equal(clone.test, 'test');\n    assert.equal(clone.nested.age, 5);\n\n    // transform with return value\n    const out = { myid: doc._id.toString() };\n    doc.schema.options.toObject.transform = function(doc, ret) {\n      // ignore embedded docs\n      if (doc.$isSubdocument) {\n        return;\n      }\n\n      return { myid: ret._id.toString() };\n    };\n\n    clone = doc.toObject();\n    assert.deepEqual(out, clone);\n\n    // ignored transform with inline options\n    clone = doc.toObject({ x: 1, transform: false });\n    assert.ok(!('myid' in clone));\n    assert.equal(clone.test, 'test');\n    assert.ok(clone.oids instanceof Array);\n    assert.equal(clone.nested.age, 5);\n    assert.equal(clone.nested.cool.toString(), '4c6c2d6240ced95d0e00003c');\n    assert.equal(clone.nested.path, 'my path');\n    assert.equal(clone.em[0].constructor.name, 'Object');\n\n    // applied transform when inline transform is true\n    clone = doc.toObject({ x: 1 });\n    assert.deepEqual(out, clone);\n\n    // transform passed inline\n    function xform(self, doc, opts) {\n      opts.fields.split(' ').forEach(function(field) {\n        delete doc[field];\n      });\n    }\n\n    clone = doc.toObject({\n      transform: xform,\n      fields: '_id em numbers oids nested'\n    });\n    assert.equal(doc.test, 'test');\n    assert.ok(undefined === clone.em);\n    assert.ok(undefined === clone.numbers);\n    assert.ok(undefined === clone.oids);\n    assert.ok(undefined === clone._id);\n    assert.ok(undefined === clone.nested);\n\n    // all done\n    delete doc.schema.options.toObject;\n  });\n\n  it('toObject transform', async function() {\n    const schema = new Schema({\n      name: String,\n      places: [{ type: ObjectId, ref: 'Place' }]\n    });\n\n    const schemaPlaces = new Schema({\n      identity: String\n    });\n\n    schemaPlaces.set('toObject', {\n      transform: function(doc, ret) {\n        assert.equal(doc.constructor.modelName, 'Place');\n        return ret;\n      }\n    });\n\n    const Test = db.model('Test', schema);\n    const Places = db.model('Place', schemaPlaces);\n\n    const [a, b, c] = await Places.create({ identity: 'a' }, { identity: 'b' }, { identity: 'c' });\n\n    await Test.create({ name: 'chetverikov', places: [a, b, c] });\n\n    const docs = await Test.findOne({}).populate('places').exec();\n\n    docs.toObject({ transform: true });\n  });\n\n  it('disabling aliases in toObject options (gh-7548)', function() {\n    const schema = new mongoose.Schema({\n      name: {\n        type: String,\n        alias: 'nameAlias'\n      },\n      age: Number\n    });\n    schema.virtual('answer').get(() => 42);\n\n    const Model = db.model('Person', schema);\n\n    const doc = new Model({ name: 'Jean-Luc Picard', age: 59 });\n\n    let obj = doc.toObject({ virtuals: true });\n    assert.equal(obj.nameAlias, 'Jean-Luc Picard');\n    assert.equal(obj.answer, 42);\n\n    obj = doc.toObject({ virtuals: true, aliases: false });\n    assert.ok(!obj.nameAlias);\n    assert.equal(obj.answer, 42);\n  });\n\n  it('can save multiple times with changes to complex subdocuments (gh-8531)', () => {\n    const clipSchema = Schema({\n      height: Number,\n      rows: Number,\n      width: Number\n    }, { _id: false, id: false });\n    const questionSchema = Schema({\n      type: String,\n      age: Number,\n      clip: {\n        type: clipSchema\n      }\n    }, { _id: false, id: false });\n    const keySchema = Schema({ ql: [questionSchema] }, { _id: false, id: false });\n    const Model = db.model('Test', Schema({\n      name: String,\n      keys: [keySchema]\n    }));\n    const doc = new Model({\n      name: 'test',\n      keys: [\n        { ql: [\n          { type: 'mc', clip: { width: 1 } },\n          { type: 'mc', clip: { height: 1, rows: 1 } },\n          { type: 'mc', clip: { height: 2, rows: 1 } },\n          { type: 'mc', clip: { height: 3, rows: 1 } }\n        ] }\n      ]\n    });\n    return doc.save().then(() => {\n      // The following was failing before fixing gh-8531 because\n      // the validation was called for the \"clip\" document twice in the\n      // same stack, causing a \"can't validate() the same doc multiple times in\n      // parallel\" warning\n      doc.keys[0].ql[0].clip = { width: 4.3, rows: 3 };\n      doc.keys[0].ql[0].age = 42;\n\n      return doc.save();\n    }); // passes\n  });\n\n  it('saves even if `_id` is null (gh-6406)', async function() {\n    const schema = new Schema({ _id: Number, val: String });\n    const Model = db.model('Test', schema);\n\n\n    await Model.updateOne({ _id: null }, { val: 'test' }, { upsert: true });\n\n    let doc = await Model.findOne();\n\n    doc.val = 'test2';\n\n    // Should not throw\n    await doc.save();\n\n    doc = await Model.findOne();\n    assert.strictEqual(doc._id, null);\n    assert.equal(doc.val, 'test2');\n  });\n\n  it('allows you to skip validation on save (gh-2981)', function() {\n    const schema = new Schema({ name: { type: String, required: true } });\n    const MyModel = db.model('Test', schema);\n\n    const doc = new MyModel();\n    return doc.save({ validateBeforeSave: false });\n  });\n\n  it('doesnt use custom toObject options on save', async function() {\n    const schema = new Schema({\n      name: String,\n      iWillNotBeDelete: Boolean,\n      nested: {\n        iWillNotBeDeleteToo: Boolean\n      }\n    });\n\n    schema.set('toObject', {\n      transform: function(doc, ret) {\n        delete ret.iWillNotBeDelete;\n        delete ret.nested.iWillNotBeDeleteToo;\n\n        return ret;\n      }\n    });\n    const Test = db.model('Test', schema);\n\n    await Test.create({ name: 'chetverikov', iWillNotBeDelete: true, 'nested.iWillNotBeDeleteToo': true });\n\n    const doc = await Test.findOne({});\n\n\n    assert.equal(doc._doc.iWillNotBeDelete, true);\n    assert.equal(doc._doc.nested.iWillNotBeDeleteToo, true);\n  });\n\n  describe('toObject', function() {\n    it('does not apply toObject functions of subdocuments to root document', async function() {\n      const subdocSchema = new Schema({\n        test: String,\n        wow: String\n      });\n\n      subdocSchema.options.toObject = {};\n      subdocSchema.options.toObject.transform = function(doc, ret) {\n        delete ret.wow;\n      };\n\n      const docSchema = new Schema({\n        foo: String,\n        wow: Boolean,\n        sub: [subdocSchema]\n      });\n\n      const Doc = db.model('Test', docSchema);\n\n      const doc = await Doc.create({\n        foo: 'someString',\n        wow: true,\n        sub: [{\n          test: 'someOtherString',\n          wow: 'thisIsAString'\n        }]\n      });\n\n      const obj = doc.toObject({\n        transform: function(doc, ret) {\n          ret.phew = 'new';\n        }\n      });\n\n      assert.equal(obj.phew, 'new');\n      assert.ok(!doc.sub.wow);\n    });\n\n    it('handles child schema transforms', function() {\n      const userSchema = new Schema({\n        name: String,\n        email: String\n      });\n      const topicSchema = new Schema({\n        title: String,\n        email: String,\n        followers: [userSchema]\n      });\n\n      userSchema.options.toObject = {\n        transform: function(doc, ret) {\n          delete ret.email;\n        }\n      };\n\n      topicSchema.options.toObject = {\n        transform: function(doc, ret) {\n          ret.title = ret.title.toLowerCase();\n        }\n      };\n\n      const Topic = db.model('Test', topicSchema);\n\n      const topic = new Topic({\n        title: 'Favorite Foods',\n        email: 'a@b.co',\n        followers: [{ name: 'Val', email: 'val@test.co' }]\n      });\n\n      const output = topic.toObject({ transform: true });\n      assert.equal(output.title, 'favorite foods');\n      assert.equal(output.email, 'a@b.co');\n      assert.equal(output.followers[0].name, 'Val');\n      assert.equal(output.followers[0].email, undefined);\n    });\n\n    it('doesnt clobber child schema options when called with no params (gh-2035)', async function() {\n      const userSchema = new Schema({\n        firstName: String,\n        lastName: String,\n        password: String\n      });\n\n      userSchema.virtual('fullName').get(function() {\n        return this.firstName + ' ' + this.lastName;\n      });\n\n      userSchema.set('toObject', { virtuals: false });\n\n      const postSchema = new Schema({\n        owner: { type: Schema.Types.ObjectId, ref: 'User' },\n        content: String\n      });\n\n      postSchema.virtual('capContent').get(function() {\n        return this.content.toUpperCase();\n      });\n\n      postSchema.set('toObject', { virtuals: true });\n      const User = db.model('User', userSchema);\n      const Post = db.model('BlogPost', postSchema);\n\n      const user = new User({ firstName: 'Joe', lastName: 'Smith', password: 'password' });\n\n      const savedUser = await user.save();\n\n      const post = await Post.create({ owner: savedUser._id, content: 'lorem ipsum' });\n\n      const newPost = await Post.findById(post._id).populate('owner').exec();\n\n      const obj = newPost.toObject();\n      assert.equal(obj.owner.fullName, undefined);\n    });\n\n    it('respects child schemas minimize (gh-9405)', function() {\n      const postSchema = new Schema({\n        owner: { type: Schema.Types.ObjectId, ref: 'User' },\n        props: { type: Object, default: {} }\n      });\n      const userSchema = new Schema({\n        firstName: String,\n        props: { type: Object, default: {} }\n      }, { minimize: false });\n\n      const User = db.model('User', userSchema);\n      const Post = db.model('BlogPost', postSchema);\n\n      const user = new User({ firstName: 'test' });\n      const post = new Post({ owner: user });\n\n      let obj = post.toObject();\n      assert.strictEqual(obj.props, void 0);\n      assert.deepEqual(obj.owner.props, {});\n\n      obj = post.toObject({ minimize: false });\n      assert.deepEqual(obj.props, {});\n      assert.deepEqual(obj.owner.props, {});\n\n      obj = post.toObject({ minimize: true });\n      assert.strictEqual(obj.props, void 0);\n      assert.strictEqual(obj.owner.props, void 0);\n    });\n\n    it('minimizes single nested subdocs (gh-11247)', async function() {\n      const nestedSchema = Schema({ bar: String }, { _id: false });\n      const schema = Schema({ foo: nestedSchema });\n\n      const MyModel = db.model('Test', schema);\n\n      const myModel = await MyModel.create({ foo: {} });\n\n      assert.strictEqual(myModel.toObject().foo, void 0);\n    });\n  });\n\n  describe('toJSON', function() {\n    it('toJSON options', function() {\n      const doc = new TestDocument();\n\n      doc.init({\n        test: 'test',\n        oids: [],\n        em: [{ title: 'asdf' }],\n        nested: {\n          age: 5,\n          cool: DocumentObjectId.createFromHexString('4c6c2d6240ced95d0e00003c'),\n          path: 'my path'\n        },\n        nested2: {}\n      });\n\n      // override to check if toJSON gets fired\n      const path = TestDocument.prototype.schema.path('em');\n      path.casterConstructor.prototype.toJSON = function() {\n        return {};\n      };\n\n      doc.schema.options.toJSON = { virtuals: true };\n      let clone = doc.toJSON();\n      assert.equal(clone.test, 'test');\n      assert.ok(clone.oids instanceof Array);\n      assert.equal(clone.nested.age, 5);\n      assert.equal(clone.nested.cool.toString(), '4c6c2d6240ced95d0e00003c');\n      assert.equal(clone.nested.path, 'my path');\n      assert.equal(clone.nested.agePlus2, 7);\n      assert.equal(clone.em[0].constructor.name, 'Object');\n      assert.equal(Object.keys(clone.em[0]).length, 0);\n      delete doc.schema.options.toJSON;\n      delete path.casterConstructor.prototype.toJSON;\n\n      doc.schema.options.toJSON = { minimize: false };\n      clone = doc.toJSON();\n      assert.equal(clone.nested2.constructor.name, 'Object');\n      assert.equal(Object.keys(clone.nested2).length, 1);\n      clone = doc.toJSON('8');\n      assert.equal(clone.nested2.constructor.name, 'Object');\n      assert.equal(Object.keys(clone.nested2).length, 1);\n\n      // gh-852\n      const arr = [doc];\n      let err = false;\n      let str;\n      try {\n        str = JSON.stringify(arr);\n      } catch (_) {\n        err = true;\n      }\n      assert.equal(err, false);\n      assert.ok(/nested2/.test(str));\n      assert.equal(clone.nested2.constructor.name, 'Object');\n      assert.equal(Object.keys(clone.nested2).length, 1);\n\n      // transform\n      doc.schema.options.toJSON = {};\n      doc.schema.options.toJSON.transform = function xform(doc, ret) {\n        // ignore embedded docs\n        if (doc.$isSubdocument) {\n          return;\n        }\n\n        delete ret.em;\n        delete ret.numbers;\n        delete ret.oids;\n        ret._id = ret._id.toString();\n      };\n\n      clone = doc.toJSON();\n      assert.equal(clone._id, doc.id);\n      assert.ok(undefined === clone.em);\n      assert.ok(undefined === clone.numbers);\n      assert.ok(undefined === clone.oids);\n      assert.equal(clone.test, 'test');\n      assert.equal(clone.nested.age, 5);\n\n      // transform with return value\n      const out = { myid: doc._id.toString() };\n      doc.schema.options.toJSON.transform = function(doc, ret) {\n        // ignore embedded docs\n        if (doc.$isSubdocument) {\n          return;\n        }\n\n        return { myid: ret._id.toString() };\n      };\n\n      clone = doc.toJSON();\n      assert.deepEqual(out, clone);\n\n      // ignored transform with inline options\n      clone = doc.toJSON({ x: 1, transform: false });\n      assert.ok(!('myid' in clone));\n      assert.equal(clone.test, 'test');\n      assert.ok(clone.oids instanceof Array);\n      assert.equal(clone.nested.age, 5);\n      assert.equal(clone.nested.cool.toString(), '4c6c2d6240ced95d0e00003c');\n      assert.equal(clone.nested.path, 'my path');\n      assert.equal(clone.em[0].constructor.name, 'Object');\n\n      // applied transform when inline transform is true\n      clone = doc.toJSON({ x: 1 });\n      assert.deepEqual(out, clone);\n\n      // transform passed inline\n      function xform(self, doc, opts) {\n        opts.fields.split(' ').forEach(function(field) {\n          delete doc[field];\n        });\n      }\n\n      clone = doc.toJSON({\n        transform: xform,\n        fields: '_id em numbers oids nested'\n      });\n      assert.equal(doc.test, 'test');\n      assert.ok(undefined === clone.em);\n      assert.ok(undefined === clone.numbers);\n      assert.ok(undefined === clone.oids);\n      assert.ok(undefined === clone._id);\n      assert.ok(undefined === clone.nested);\n\n      // all done\n      delete doc.schema.options.toJSON;\n    });\n\n    it('jsonifying an object', function() {\n      const doc = new TestDocument({ test: 'woot' });\n      const oidString = doc._id.toString();\n      // convert to json string\n      const json = JSON.stringify(doc);\n      // parse again\n      const obj = JSON.parse(json);\n\n      assert.equal(obj.test, 'woot');\n      assert.equal(obj._id, oidString);\n    });\n\n    it('jsonifying an object\\'s populated items works (gh-1376)', async function() {\n      const userSchema = new Schema({ name: String });\n      // includes virtual path when 'toJSON'\n      userSchema.set('toJSON', { getters: true });\n      userSchema.virtual('hello').get(function() {\n        return 'Hello, ' + this.name;\n      });\n      const User = db.model('User', userSchema);\n\n      const groupSchema = new Schema({\n        name: String,\n        _users: [{ type: Schema.ObjectId, ref: 'User' }]\n      });\n\n      const Group = db.model('Group', groupSchema);\n\n      const [alice, bob] = await User.create({ name: 'Alice' }, { name: 'Bob' });\n\n\n      const group = await Group.create({ name: 'mongoose', _users: [alice, bob] });\n      const foundGroup = await Group.findById(group).populate('_users').exec();\n\n      assert.ok(foundGroup.toJSON()._users[0].hello);\n    });\n\n    it('jsonifying with undefined path (gh-11922)', async function() {\n      const userSchema = new Schema({\n        name: String,\n        friends: [{\n          type: String,\n          transform(friendName) {\n            return `Hi, ${friendName}`;\n          }\n        }]\n      });\n      const User = db.model('User', userSchema);\n      const alice = await User.create({ name: 'Alic', friends: ['Bob', 'Jack'] });\n      const foundAlice = await User.findById(alice._id, { name: true });\n      assert.equal(foundAlice.friends, undefined);\n      const foundAlicJson = foundAlice.toJSON();\n      assert.equal(foundAlicJson.friends, undefined);\n      assert.equal(foundAlicJson.name, 'Alic');\n    });\n  });\n\n  describe('inspect', function() {\n    it('inspect inherits schema options (gh-4001)', async function() {\n      const opts = {\n        toObject: { virtuals: true },\n        toJSON: { virtuals: true }\n      };\n      const taskSchema = mongoose.Schema({\n        name: {\n          type: String,\n          required: true\n        }\n      }, opts);\n\n      taskSchema.virtual('title').\n        get(function() {\n          return this.name;\n        }).\n        set(function(title) {\n          this.name = title;\n        });\n\n      const Task = db.model('Test', taskSchema);\n\n      const doc = { name: 'task1', title: 'task999' };\n      await Task.collection.insertOne(doc);\n\n      const foundDoc = await Task.findById(doc._id);\n\n      assert.equal(foundDoc.inspect().title, 'task1');\n    });\n\n    it('does not apply transform to populated docs (gh-4213)', async function() {\n      const UserSchema = new Schema({\n        name: String\n      });\n\n      const PostSchema = new Schema({\n        title: String,\n        postedBy: {\n          type: mongoose.Schema.Types.ObjectId,\n          ref: 'User'\n        }\n      },\n      {\n        toObject: {\n          transform: function(doc, ret) {\n            delete ret._id;\n          }\n        },\n        toJSON: {\n          transform: function(doc, ret) {\n            delete ret._id;\n          }\n        }\n      });\n\n      const User = db.model('User', UserSchema);\n      const Post = db.model('BlogPost', PostSchema);\n\n      const val = new User({ name: 'Val' });\n      const post = new Post({ title: 'Test', postedBy: val._id });\n\n      await Post.create(post);\n\n      await User.create(val);\n\n      const posts = await Post.find({}).\n        populate('postedBy').\n        exec();\n\n      assert.equal(posts.length, 1);\n      assert.ok(posts[0].postedBy._id);\n    });\n\n    it('handles infinite recursion (gh-11756)', function() {\n      const User = db.model('User', Schema({\n        name: { type: String, required: true },\n        posts: [{ type: mongoose.Types.ObjectId, ref: 'Post' }]\n      }));\n\n      const Post = db.model('Post', Schema({\n        creator: { type: Schema.Types.ObjectId, ref: 'User' }\n      }));\n\n      const user = new User({ name: 'Test', posts: [] });\n      const post = new Post({ creator: user });\n      user.posts.push(post);\n\n      const inspected = post.inspect();\n      assert.ok(inspected);\n      assert.equal(inspected.creator.posts[0].creator.name, 'Test');\n    });\n\n    it('populate on nested path (gh-5703)', function() {\n      const toySchema = new mongoose.Schema({ color: String });\n      const Toy = db.model('Cat', toySchema);\n\n      const childSchema = new mongoose.Schema({\n        name: String,\n        values: {\n          toy: { type: mongoose.Schema.Types.ObjectId, ref: 'Cat' }\n        }\n      });\n      const Child = db.model('Child', childSchema);\n\n      return Toy.create({ color: 'brown' }).\n        then(function(toy) {\n          return Child.create({ values: { toy: toy._id } });\n        }).\n        then(function(child) {\n          return Child.findById(child._id);\n        }).\n        then(function(child) {\n          return child.values.populate('toy').then(function() {\n            return child;\n          });\n        }).\n        then(function(child) {\n          assert.equal(child.values.toy.color, 'brown');\n        });\n    });\n  });\n\n  describe.skip('#update', function() {\n    it('returns a Query', function() {\n      const mg = new mongoose.Mongoose();\n      const M = mg.model('Test', { s: String });\n      const doc = new M();\n      assert.ok(doc.update() instanceof Query);\n    });\n    it('calling update on document should relay to its model (gh-794)', async function() {\n      const Docs = new Schema({ text: String });\n      const docs = db.model('Test', Docs);\n      const d = new docs({ text: 'A doc' });\n      let called = false;\n      await d.save();\n\n      const oldUpdate = docs.update;\n      docs.update = function(query, operation) {\n        assert.equal(Object.keys(query).length, 1);\n        assert.equal(d._id, query._id);\n        assert.equal(Object.keys(operation).length, 1);\n        assert.equal(Object.keys(operation.$set).length, 1);\n        assert.equal(operation.$set.text, 'A changed doc');\n        called = true;\n        docs.update = oldUpdate;\n        oldUpdate.apply(docs, arguments);\n      };\n\n      await d.update({ $set: { text: 'A changed doc' } });\n\n      assert.equal(called, true);\n    });\n  });\n\n  it('toObject should not set undefined values to null', function() {\n    const doc = new TestDocument();\n    const obj = doc.toObject();\n\n    delete obj._id;\n    assert.deepEqual(obj, { numbers: [], oids: [], em: [] });\n  });\n\n  describe('Errors', function() {\n    it('MongooseErrors should be instances of Error (gh-209)', function() {\n      const MongooseError = require('../lib/error');\n      const err = new MongooseError('Some message');\n      assert.ok(err instanceof Error);\n    });\n    it('ValidationErrors should be instances of Error', function() {\n      const ValidationError = Document.ValidationError;\n      const err = new ValidationError(new TestDocument());\n      assert.ok(err instanceof Error);\n    });\n  });\n\n  it('methods on embedded docs should work', function() {\n    const ESchema = new Schema({ name: String });\n\n    ESchema.methods.test = function() {\n      return this.name + ' butter';\n    };\n    ESchema.statics.ten = function() {\n      return 10;\n    };\n\n    const E = db.model('Test', ESchema);\n    const PSchema = new Schema({ embed: [ESchema] });\n    const P = db.model('Test2', PSchema);\n\n    let p = new P({ embed: [{ name: 'peanut' }] });\n    assert.equal(typeof p.embed[0].test, 'function');\n    assert.equal(typeof E.ten, 'function');\n    assert.equal(p.embed[0].test(), 'peanut butter');\n    assert.equal(E.ten(), 10);\n\n    // test push casting\n    p = new P();\n    p.embed.push({ name: 'apple' });\n    assert.equal(typeof p.embed[0].test, 'function');\n    assert.equal(typeof E.ten, 'function');\n    assert.equal(p.embed[0].test(), 'apple butter');\n  });\n\n  it('setting a positional path does not cast value to array', function() {\n    const doc = new TestDocument();\n    doc.init({ numbers: [1, 3] });\n    assert.equal(doc.numbers[0], 1);\n    assert.equal(doc.numbers[1], 3);\n    doc.set('numbers.1', 2);\n    assert.equal(doc.numbers[0], 1);\n    assert.equal(doc.numbers[1], 2);\n  });\n\n  it('no maxListeners warning should occur', function() {\n    let traced = false;\n    const trace = console.trace;\n\n    console.trace = function() {\n      traced = true;\n      console.trace = trace;\n    };\n\n    const schema = new Schema({\n      title: String,\n      embed1: [new Schema({ name: String })],\n      embed2: [new Schema({ name: String })],\n      embed3: [new Schema({ name: String })],\n      embed4: [new Schema({ name: String })],\n      embed5: [new Schema({ name: String })],\n      embed6: [new Schema({ name: String })],\n      embed7: [new Schema({ name: String })],\n      embed8: [new Schema({ name: String })],\n      embed9: [new Schema({ name: String })],\n      embed10: [new Schema({ name: String })],\n      embed11: [new Schema({ name: String })]\n    });\n\n    const S = db.model('Test', schema);\n\n    new S({ title: 'test' });\n    assert.equal(traced, false);\n  });\n\n  it('unselected required fields should pass validation', async function() {\n    const userSchema = new Schema({\n      name: String,\n      req: { type: String, required: true }\n    });\n    const User = db.model('Test', userSchema);\n\n    const user = await User.create({ name: 'teeee', req: 'i am required' });\n\n    const user1 = await User.findById(user).select('name').exec();\n    assert.equal(user1.req, void 0);\n\n    user1.name = 'wooo';\n    await user1.save();\n    const user2 = await User.findById(user1).select('name').exec();\n\n    user2.req = undefined;\n    let err = await user2.save().then(() => null, err => err);\n    err = String(err);\n\n    const invalid = /Path `req` is required./.test(err);\n    assert.ok(invalid);\n\n    user2.req = 'it works again';\n    await user2.save();\n\n    const user3 = await User.findById(user2).select('_id').exec();\n    await user3.save();\n  });\n\n  describe('#validate', function() {\n    it('works (gh-891)', async function() {\n      let schema = null;\n      let called = false;\n\n      const validate = [function() {\n        called = true;\n        return true;\n      }, 'BAM'];\n\n      schema = new Schema({\n        prop: { type: String, required: true, validate: validate },\n        nick: { type: String, required: true }\n      });\n\n      const M = db.model('Test', schema);\n      const m = new M({ prop: 'gh891', nick: 'validation test' });\n      await m.save();\n\n      assert.equal(called, true);\n      called = false;\n\n      const m2 = await M.findById(m, 'nick');\n      assert.equal(called, false);\n\n      m2.nick = 'gh-891';\n      await m2.save();\n\n      assert.equal(called, false);\n    });\n\n    it('can return a promise', async function() {\n      let schema = null;\n\n      const validate = [function() {\n        return true;\n      }, 'BAM'];\n\n      schema = new Schema({\n        prop: { type: String, required: true, validate: validate },\n        nick: { type: String, required: true }\n      });\n\n      const M = db.model('Test', schema);\n      const m = new M({ prop: 'gh891', nick: 'validation test' });\n      const mBad = new M({ prop: 'other' });\n\n      await m.validate().then(res => res);\n\n      const err = await mBad.validate().then(() => null, err => err);\n      assert.ok(err);\n    });\n\n    it('doesnt have stale cast errors (gh-2766)', async function() {\n      const testSchema = new Schema({ name: String });\n      const M = db.model('Test', testSchema);\n\n      const m = new M({ _id: 'this is not a valid _id' });\n      assert.ok(!m.$isValid('_id'));\n      assert.ok(m.validateSync().errors['_id'].name, 'CastError');\n\n      m._id = '000000000000000000000001';\n      assert.ok(m.$isValid('_id'));\n      assert.ifError(m.validateSync());\n      await m.validate();\n    });\n\n    it('cast errors persist across validate() calls (gh-2766)', async function() {\n      const db = start();\n      const testSchema = new Schema({ name: String });\n      const M = db.model('Test', testSchema);\n\n      const m = new M({ _id: 'this is not a valid _id' });\n      assert.ok(!m.$isValid('_id'));\n      const error = await m.validate().then(() => null, err => err);\n\n      assert.ok(error);\n      assert.equal(error.errors['_id'].name, 'CastError');\n      const error2 = await m.validate().then(() => null, err => err);\n\n      assert.ok(error2);\n      assert.equal(error2.errors['_id'].name, 'CastError');\n\n      const err1 = m.validateSync();\n      const err2 = m.validateSync();\n      assert.equal(err1.errors['_id'].name, 'CastError');\n      assert.equal(err2.errors['_id'].name, 'CastError');\n      await db.close();\n    });\n\n    it('returns a promise when there are no validators', function(done) {\n      let schema = null;\n\n      schema = new Schema({ _id: String });\n\n      const M = db.model('Test', schema);\n      const m = new M();\n\n      const promise = m.validate();\n      promise.then(function() {\n        clearTimeout(timeout);\n        done();\n      });\n\n      const timeout = setTimeout(function() {\n        db.close();\n        throw new Error('Promise not fulfilled!');\n      }, 500);\n    });\n\n    describe('works on arrays', function() {\n      it('with required', function(done) {\n        const schema = new Schema({\n          name: String,\n          arr: { type: [], required: true }\n        });\n        const M = db.model('Test', schema);\n        const m = new M({ name: 'gh1109-1', arr: null });\n        m.save(function(err) {\n          assert.ok(/Path `arr` is required/.test(err));\n          m.arr = null;\n          m.save(function(err) {\n            assert.ok(/Path `arr` is required/.test(err));\n            m.arr = [];\n            m.arr.push('works');\n            m.save(function(err) {\n              assert.ifError(err);\n              done();\n            });\n          });\n        });\n      });\n\n      it('with custom validator', function(done) {\n        let called = false;\n\n        function validator(val) {\n          called = true;\n          return val && val.length > 1;\n        }\n\n        const validate = [validator, 'BAM'];\n\n        const schema = new Schema({\n          arr: { type: [], validate: validate }\n        });\n\n        const M = db.model('Test', schema);\n        const m = new M({ name: 'gh1109-2', arr: [1] });\n        assert.equal(called, false);\n        m.save(function(err) {\n          assert.equal(String(err), 'ValidationError: arr: BAM');\n          assert.equal(called, true);\n          m.arr.push(2);\n          called = false;\n          m.save(function(err) {\n            assert.equal(called, true);\n            assert.ifError(err);\n            done();\n          });\n        });\n      });\n\n      it('with both required + custom validator', function(done) {\n        function validator(val) {\n          return val && val.length > 1;\n        }\n\n        const validate = [validator, 'BAM'];\n\n        const schema = new Schema({\n          arr: { type: [], required: true, validate: validate }\n        });\n\n        const M = db.model('Test', schema);\n        const m = new M({ name: 'gh1109-3', arr: null });\n        m.save(function(err) {\n          assert.equal(err.errors.arr.message, 'Path `arr` is required.');\n          m.arr = [{ nice: true }];\n          m.save(function(err) {\n            assert.equal(String(err), 'ValidationError: arr: BAM');\n            m.arr.push(95);\n            m.save(function(err) {\n              assert.ifError(err);\n              done();\n            });\n          });\n        });\n      });\n    });\n\n    it('validator should run only once gh-1743', function(done) {\n      let count = 0;\n\n      const Control = new Schema({\n        test: {\n          type: String,\n          validate: function(value, done) {\n            count++;\n            return done(true);\n          }\n        }\n      });\n      const PostSchema = new Schema({\n        controls: [Control]\n      });\n\n      const Post = db.model('BlogPost', PostSchema);\n\n      const post = new Post({\n        controls: [{\n          test: 'xx'\n        }]\n      });\n\n      post.save(function() {\n        assert.equal(count, 1);\n        done();\n      });\n    });\n\n    it('validator should run only once per sub-doc gh-1743', async function() {\n      this.timeout(4500);\n\n      let count = 0;\n      const db = start();\n\n      const Control = new Schema({\n        test: {\n          type: String,\n          validate: function() {\n            count++;\n          }\n        }\n      });\n      const PostSchema = new Schema({\n        controls: [Control]\n      });\n\n      const Post = db.model('BlogPost', PostSchema);\n\n      const post = new Post({\n        controls: [\n          { test: 'xx' },\n          { test: 'yy' }\n        ]\n      });\n\n      await post.save();\n\n      assert.equal(count, post.controls.length);\n      await db.close();\n    });\n  });\n\n  it('#invalidate', function(done) {\n    let InvalidateSchema = null;\n    let Post = null;\n    let post = null;\n\n    InvalidateSchema = new Schema({ prop: { type: String } },\n      { strict: false });\n\n    Post = db.model('Test', InvalidateSchema);\n    post = new Post();\n    post.set({ baz: 'val' });\n    const _err = post.invalidate('baz', 'validation failed for path {PATH}',\n      'val', 'custom error');\n    assert.ok(_err instanceof ValidationError);\n\n    post.save(function(err) {\n      assert.ok(err instanceof MongooseError);\n      assert.ok(err instanceof ValidationError);\n      assert.ok(err.errors.baz instanceof ValidatorError);\n      assert.equal(err.errors.baz.message, 'validation failed for path baz');\n      assert.equal(err.errors.baz.path, 'baz');\n      assert.equal(err.errors.baz.value, 'val');\n      assert.equal(err.errors.baz.kind, 'custom error');\n\n      post.save(function(err) {\n        assert.strictEqual(err, null);\n        done();\n      });\n    });\n  });\n\n  describe('#equals', function() {\n    describe('should work', function() {\n      let S;\n      let N;\n      let O;\n      let B;\n      let M;\n\n      before(function() {\n        db.deleteModel(/^Test/);\n        S = db.model('Test', new Schema({ _id: String }));\n        N = db.model('Test2', new Schema({ _id: Number }));\n        O = db.model('Test3', new Schema({ _id: Schema.ObjectId }));\n        B = db.model('Test4', new Schema({ _id: Buffer }));\n        M = db.model('Test5', new Schema({ name: String }, { _id: false }));\n      });\n\n      it('with string _ids', function() {\n        const s1 = new S({ _id: 'one' });\n        const s2 = new S({ _id: 'one' });\n        assert.ok(s1.equals(s2));\n      });\n      it('with number _ids', function() {\n        const n1 = new N({ _id: 0 });\n        const n2 = new N({ _id: 0 });\n        assert.ok(n1.equals(n2));\n      });\n      it('with ObjectId _ids', function() {\n        let id = new mongoose.Types.ObjectId();\n        let o1 = new O({ _id: id });\n        let o2 = new O({ _id: id });\n        assert.ok(o1.equals(o2));\n\n        id = String(new mongoose.Types.ObjectId());\n        o1 = new O({ _id: id });\n        o2 = new O({ _id: id });\n        assert.ok(o1.equals(o2));\n      });\n      it('with Buffer _ids', function() {\n        const n1 = new B({ _id: 0 });\n        const n2 = new B({ _id: 0 });\n        assert.ok(n1.equals(n2));\n      });\n      it('with _id disabled (gh-1687)', function() {\n        const m1 = new M();\n        const m2 = new M();\n        assert.doesNotThrow(function() {\n          m1.equals(m2);\n        });\n      });\n    });\n  });\n\n  describe('setter', function() {\n    describe('order', function() {\n      it('is applied correctly', function() {\n        const date = 'Thu Aug 16 2012 09:45:59 GMT-0700';\n        const d = new TestDocument();\n        dateSetterCalled = false;\n        d.date = date;\n        assert.ok(dateSetterCalled);\n        dateSetterCalled = false;\n        assert.ok(d._doc.date instanceof Date);\n        assert.ok(d.date instanceof Date);\n        assert.equal(+d.date, +new Date(date));\n      });\n    });\n\n    it('works with undefined (gh-1892)', function(done) {\n      const d = new TestDocument();\n      d.nested.setr = undefined;\n      assert.equal(d.nested.setr, 'undefined setter');\n      dateSetterCalled = false;\n      d.date = undefined;\n      d.validate(function(err) {\n        assert.ifError(err);\n        assert.ok(dateSetterCalled);\n        done();\n      });\n    });\n\n    it('passes priorVal (gh-8629)', function() {\n      const names = [];\n      const profiles = [];\n      const Model = db.model('Test', Schema({\n        name: {\n          type: String,\n          set: (v, priorVal) => {\n            names.push(priorVal);\n            return v;\n          }\n        },\n        profile: {\n          type: Schema({ age: Number }, { _id: false }),\n          set: (v, priorVal) => {\n            profiles.push(priorVal == null ? priorVal : priorVal.toObject());\n            return v;\n          }\n        }\n      }));\n      const doc = new Model({ name: 'test', profile: { age: 29 } });\n      assert.deepEqual(names, [null]);\n      assert.deepEqual(profiles, [null]);\n\n      doc.name = 'test2';\n      doc.profile = { age: 30 };\n      assert.deepEqual(names, [null, 'test']);\n      assert.deepEqual(profiles, [null, { age: 29 }]);\n    });\n\n    describe('on nested paths', function() {\n      describe('using set(path, object)', function() {\n        it('overwrites the entire object', function() {\n          const doc = new TestDocument();\n\n          doc.init({\n            test: 'Test',\n            nested: {\n              age: 5\n            }\n          });\n\n          doc.set('nested', { path: 'overwrite the entire nested object' });\n          assert.equal(doc.nested.age, undefined);\n          assert.equal(Object.keys(doc._doc.nested).length, 1);\n          assert.equal(doc.nested.path, 'overwrite the entire nested object');\n          assert.ok(doc.isModified('nested'));\n        });\n\n        it('allows positional syntax on mixed nested paths (gh-6738)', function() {\n          const schema = new Schema({ nested: {} });\n          const M = db.model('Test', schema);\n          const doc = new M({\n            'nested.x': 'foo',\n            'nested.y': 42,\n            'nested.a.b.c': { d: { e: { f: 'g' } } }\n          });\n          assert.strictEqual(doc.nested.x, 'foo');\n          assert.strictEqual(doc.nested.y, 42);\n          assert.strictEqual(doc.nested.a.b.c.d.e.f, 'g');\n        });\n\n        it('gh-1954', function() {\n          const schema = new Schema({\n            schedule: [new Schema({ open: Number, close: Number })]\n          });\n\n          const M = db.model('BlogPost', schema);\n\n          const doc = new M({\n            schedule: [{\n              open: 1000,\n              close: 1900\n            }]\n          });\n\n          assert.ok(doc.schedule[0] instanceof ArraySubdocument);\n          doc.set('schedule.0.open', 1100);\n          assert.ok(doc.schedule);\n          assert.ok(doc.schedule.isMongooseDocumentArray);\n          assert.ok(doc.schedule[0] instanceof ArraySubdocument);\n          assert.equal(doc.schedule[0].open, 1100);\n          assert.equal(doc.schedule[0].close, 1900);\n        });\n      });\n\n      describe('when overwriting with a document instance', function() {\n        it('does not cause StackOverflows (gh-1234)', function() {\n          const doc = new TestDocument({ nested: { age: 35 } });\n          doc.nested = doc.nested;\n          assert.doesNotThrow(function() {\n            doc.nested.age;\n          });\n        });\n      });\n    });\n  });\n\n  describe('virtual', function() {\n    describe('setter', function() {\n      let val;\n      let M;\n\n      beforeEach(function() {\n        const schema = new mongoose.Schema({ v: Number });\n        schema.virtual('thang').set(function(v) {\n          val = v;\n        });\n\n        db.deleteModel(/Test/);\n        M = db.model('Test', schema);\n      });\n\n      it('works with objects', function() {\n        new M({ thang: {} });\n        assert.deepEqual({}, val);\n      });\n      it('works with arrays', function() {\n        new M({ thang: [] });\n        assert.deepEqual([], val);\n      });\n      it('works with numbers', function() {\n        new M({ thang: 4 });\n        assert.deepEqual(4, val);\n      });\n      it('works with strings', function() {\n        new M({ thang: '3' });\n        assert.deepEqual('3', val);\n      });\n    });\n\n    it('passes doc as third param for arrow functions (gh-4143)', function() {\n      const schema = new mongoose.Schema({\n        name: {\n          first: String,\n          last: String\n        }\n      });\n      schema.virtual('fullname').\n        get((v, virtual, doc) => `${doc.name.first} ${doc.name.last}`).\n        set((v, virtual, doc) => {\n          const parts = v.split(' ');\n          doc.name.last = parts[parts.length - 1];\n          doc.name.first = parts.slice(0, parts.length - 1).join(' ');\n        });\n      const Model = db.model('Person', schema);\n\n      const doc = new Model({ name: { first: 'Jean-Luc', last: 'Picard' } });\n      assert.equal(doc.fullname, 'Jean-Luc Picard');\n\n      doc.fullname = 'Will Riker';\n      assert.equal(doc.name.first, 'Will');\n      assert.equal(doc.name.last, 'Riker');\n    });\n  });\n\n  describe('gh-2082', function() {\n    it('works', async function() {\n      const Parent = db.model('Test', parentSchema);\n\n      const parent = new Parent({ name: 'Hello' });\n      await parent.save();\n\n      parent.children.push({ counter: 0 });\n      await parent.save();\n\n      parent.children[0].counter += 1;\n      await parent.save();\n\n      parent.children[0].counter += 1;\n      await parent.save();\n\n      await Parent.findOne({});\n\n      assert.equal(parent.children[0].counter, 2);\n    });\n  });\n\n  describe('gh-1933', function() {\n    it('works', async function() {\n      const M = db.model('Test', new Schema({ id: String, field: Number }));\n\n      const doc = await M.create({});\n\n      doc.__v = 123;\n      doc.field = 5;\n\n      // Does not throw\n      await doc.save();\n    });\n  });\n\n  describe('gh-1638', function() {\n    it('works', async function() {\n      const ItemChildSchema = new mongoose.Schema({\n        name: { type: String, required: true, default: 'hello' }\n      });\n\n      const ItemParentSchema = new mongoose.Schema({\n        children: [ItemChildSchema]\n      });\n\n      const ItemParent = db.model('Parent', ItemParentSchema);\n      const ItemChild = db.model('Child', ItemChildSchema);\n\n      const c1 = new ItemChild({ name: 'first child' });\n      const c2 = new ItemChild({ name: 'second child' });\n\n      const p = new ItemParent({\n        children: [c1, c2]\n      });\n\n      await p.save();\n\n      c2.name = 'updated 2';\n      p.children = [c2];\n      await p.save();\n\n      assert.equal(p.children.length, 1);\n    });\n  });\n\n  describe('gh-2434', function() {\n    it('will save the new value', async function() {\n      const ItemSchema = new mongoose.Schema({\n        st: Number,\n        s: []\n      });\n\n      const Item = db.model('Test', ItemSchema);\n\n      const item = new Item({ st: 1 });\n\n      await item.save();\n\n      item.st = 3;\n      item.s = [];\n      await item.save();\n\n      // item.st is 3 but may not be saved to DB\n      const doc = await Item.findById(item._id);\n      assert.equal(doc.st, 3);\n    });\n  });\n\n  describe('gh-8371', function() {\n    beforeEach(async() => {\n      const Person = db.model('Person', Schema({ name: String }));\n\n      await Person.deleteMany({});\n\n      db.deleteModel('Person');\n    });\n\n    it('setting isNew to true makes save tries to insert a new document (gh-8371)', async function() {\n      const personSchema = new Schema({ name: String });\n      const Person = db.model('Person', personSchema);\n\n      const createdPerson = await Person.create({ name: 'Hafez' });\n      const removedPerson = await Person.findOneAndRemove({ _id: createdPerson._id });\n\n      removedPerson.isNew = true;\n\n      await removedPerson.save();\n\n      const foundPerson = await Person.findOne({ _id: removedPerson._id });\n      assert.ok(foundPerson);\n    });\n\n    it('setting isNew to true throws an error when a document already exists (gh-8371)', async function() {\n\n      const personSchema = new Schema({ name: String });\n      const Person = db.model('Person', personSchema);\n\n      const createdPerson = await Person.create({ name: 'Hafez' });\n\n      createdPerson.isNew = true;\n\n      let threw = false;\n      try {\n        await createdPerson.save();\n      }\n      catch (err) {\n        threw = true;\n        assert.equal(err.code, 11000);\n      }\n\n      assert.equal(threw, true);\n    });\n\n    it('saving a document with no changes, throws an error when document is not found', async function() {\n      const personSchema = new Schema({ name: String });\n      const Person = db.model('Person', personSchema);\n\n      const person = await Person.create({ name: 'Hafez' });\n\n      await Person.deleteOne({ _id: person._id });\n\n      const err = await person.save().then(() => null, err => err);\n      assert.equal(err instanceof DocumentNotFoundError, true);\n      assert.equal(err.message, `No document found for query \"{ _id: new ObjectId(\"${person._id}\") }\" on model \"Person\"`);\n    });\n\n    it('saving a document when version bump required, throws a VersionError when document is not found (gh-10974)', async function() {\n      const personSchema = new Schema({ tags: [String] });\n      const Person = db.model('Person', personSchema);\n\n      const person = await Person.create({ tags: ['tag1', 'tag2'] });\n\n      await Person.deleteOne({ _id: person._id });\n\n      person.tags.splice(0, 1);\n\n      const err = await person.save().then(() => null, err => err);\n      assert.ok(err instanceof VersionError);\n      assert.equal(err.message, `No matching document found for id \"${person._id}\" version 0 modifiedPaths \"tags\"`);\n    });\n\n    it('saving a document with changes, throws an error when document is not found', async function() {\n\n      const personSchema = new Schema({ name: String });\n      const Person = db.model('Person', personSchema);\n\n      const person = await Person.create({ name: 'Hafez' });\n\n      await Person.deleteOne({ _id: person._id });\n\n      person.name = 'Different Name';\n\n      let threw = false;\n      try {\n        await person.save();\n      }\n      catch (err) {\n        assert.equal(err instanceof DocumentNotFoundError, true);\n        assert.equal(err.message, `No document found for query \"{ _id: new ObjectId(\"${person._id}\") }\" on model \"Person\"`);\n        threw = true;\n      }\n\n      assert.equal(threw, true);\n    });\n\n    it('passes save custom options to Model.exists(...) when no changes are present (gh-8739)', async function() {\n      const personSchema = new Schema({ name: String });\n\n      let optionInMiddleware;\n\n      personSchema.pre('findOne', function(next) {\n        optionInMiddleware = this.getOptions().customOption;\n\n        return next();\n      });\n\n      const Person = db.model('Person', personSchema);\n\n      const person = await Person.create({ name: 'Hafez' });\n      await person.save({ customOption: 'test' });\n\n      assert.equal(optionInMiddleware, 'test');\n    });\n  });\n\n  it('properly calls queue functions (gh-2856)', function() {\n    const personSchema = new mongoose.Schema({\n      name: String\n    });\n\n    let calledName;\n    personSchema.methods.fn = function() {\n      calledName = this.name;\n    };\n    personSchema.queue('fn');\n\n    const Person = db.model('Person', personSchema);\n    new Person({ name: 'Val' });\n    assert.equal(calledName, 'Val');\n  });\n\n  describe('bug fixes', function() {\n    it('applies toJSON transform correctly for populated docs (gh-2910) (gh-2990)', async function() {\n      const parentSchema = mongoose.Schema({\n        c: { type: mongoose.Schema.Types.ObjectId, ref: 'Child' }\n      });\n\n      let called = [];\n      parentSchema.options.toJSON = {\n        transform: function(doc, ret) {\n          called.push(ret);\n          return ret;\n        }\n      };\n\n      const childSchema = mongoose.Schema({\n        name: String\n      });\n\n      let childCalled = [];\n      childSchema.options.toJSON = {\n        transform: function(doc, ret) {\n          childCalled.push(ret);\n          return ret;\n        }\n      };\n\n      const Child = db.model('Child', childSchema);\n      const Parent = db.model('Parent', parentSchema);\n\n      const c = await Child.create({ name: 'test' });\n\n      const createdParent = await Parent.create({ c: c._id });\n\n      const p = await Parent.findOne({ _id: createdParent._id }).populate('c').exec();\n\n      let doc = p.toJSON();\n      assert.equal(called.length, 1);\n      assert.equal(called[0]._id.toString(), p._id.toString());\n      assert.equal(doc._id.toString(), p._id.toString());\n      assert.equal(childCalled.length, 1);\n      assert.equal(childCalled[0]._id.toString(), c._id.toString());\n\n      called = [];\n      childCalled = [];\n\n      // JSON.stringify() passes field name, so make sure we don't treat\n      // that as a param to toJSON (gh-2990)\n      doc = JSON.parse(JSON.stringify({ parent: p })).parent;\n      assert.equal(called.length, 1);\n      assert.equal(called[0]._id.toString(), p._id.toString());\n      assert.equal(doc._id.toString(), p._id.toString());\n      assert.equal(childCalled.length, 1);\n      assert.equal(childCalled[0]._id.toString(), c._id.toString());\n    });\n\n    it('single nested schema transform with save() (gh-5807)', function() {\n      const embeddedSchema = new Schema({\n        test: String\n      });\n\n      let called = false;\n      embeddedSchema.options.toObject = {\n        transform: function(doc, ret) {\n          called = true;\n          delete ret.test;\n          return ret;\n        }\n      };\n      const topLevelSchema = new Schema({\n        embedded: embeddedSchema\n      });\n      const MyModel = db.model('Test', topLevelSchema);\n\n      return MyModel.create({}).\n        then(function(doc) {\n          doc.embedded = { test: '123' };\n          return doc.save();\n        }).\n        then(function(doc) {\n          return MyModel.findById(doc._id);\n        }).\n        then(function(doc) {\n          assert.equal(doc.embedded.test, '123');\n          assert.ok(!called);\n        });\n    });\n\n    it('setters firing with objects on real paths (gh-2943)', function() {\n      const M = db.model('Test', {\n        myStr: {\n          type: String, set: function(v) {\n            return v.value;\n          }\n        },\n        otherStr: String\n      });\n\n      const t = new M({ myStr: { value: 'test' } });\n      assert.equal(t.myStr, 'test');\n\n      new M({ otherStr: { value: 'test' } });\n      assert.ok(!t.otherStr);\n    });\n\n    describe('gh-2782', function() {\n      it('should set data from a sub doc', function() {\n        const schema1 = new mongoose.Schema({\n          data: {\n            email: String\n          }\n        });\n        const schema2 = new mongoose.Schema({\n          email: String\n        });\n        const Model1 = db.model('Test', schema1);\n        const Model2 = db.model('Test1', schema2);\n\n        const doc1 = new Model1({ 'data.email': 'some@example.com' });\n        assert.equal(doc1.data.email, 'some@example.com');\n        const doc2 = new Model2();\n        doc2.set(doc1.data);\n        assert.equal(doc2.email, 'some@example.com');\n      });\n    });\n\n    it('set data from subdoc keys (gh-3346)', function() {\n      const schema1 = new mongoose.Schema({\n        data: {\n          email: String\n        }\n      });\n      const Model1 = db.model('Test', schema1);\n\n      const doc1 = new Model1({ 'data.email': 'some@example.com' });\n      assert.equal(doc1.data.email, 'some@example.com');\n      const doc2 = new Model1({ data: doc1.data });\n      assert.equal(doc2.data.email, 'some@example.com');\n    });\n\n    it('doesnt attempt to cast generic objects as strings (gh-3030)', function(done) {\n      const M = db.model('Test', {\n        myStr: {\n          type: String\n        }\n      });\n\n      const t = new M({ myStr: { thisIs: 'anObject' } });\n      assert.ok(!t.myStr);\n      t.validate(function(error) {\n        assert.ok(error);\n        done();\n      });\n    });\n\n    it('single embedded schemas 1 (gh-2689)', function(done) {\n      const userSchema = new mongoose.Schema({\n        name: String,\n        email: String\n      }, { _id: false, id: false });\n\n      let userHookCount = 0;\n      userSchema.pre('save', function(next) {\n        ++userHookCount;\n        next();\n      });\n\n      const eventSchema = new mongoose.Schema({\n        user: userSchema,\n        name: String\n      });\n\n      let eventHookCount = 0;\n      eventSchema.pre('save', function(next) {\n        ++eventHookCount;\n        next();\n      });\n\n      const Event = db.model('Event', eventSchema);\n\n      const e = new Event({ name: 'test', user: { name: 123, email: 'val' } });\n      e.save(function(error) {\n        assert.ifError(error);\n        assert.strictEqual(e.user.name, '123');\n        assert.equal(eventHookCount, 1);\n        assert.equal(userHookCount, 1);\n\n        Event.findOne({ user: { name: '123', email: 'val' } }, function(err, doc) {\n          assert.ifError(err);\n          assert.ok(doc);\n\n          Event.findOne({ user: { $in: [{ name: '123', email: 'val' }] } }, function(err, doc) {\n            assert.ifError(err);\n            assert.ok(doc);\n            done();\n          });\n        });\n      });\n    });\n\n    it('single embedded schemas with validation (gh-2689)', function() {\n      const userSchema = new mongoose.Schema({\n        name: String,\n        email: { type: String, required: true, match: /.+@.+/ }\n      }, { _id: false, id: false });\n\n      const eventSchema = new mongoose.Schema({\n        user: userSchema,\n        name: String\n      });\n\n      const Event = db.model('Event', eventSchema);\n\n      const e = new Event({ name: 'test', user: {} });\n      let error = e.validateSync();\n      assert.ok(error);\n      assert.ok(error.errors['user.email']);\n      assert.equal(error.errors['user.email'].kind, 'required');\n\n      e.user.email = 'val';\n      error = e.validateSync();\n\n      assert.ok(error);\n      assert.ok(error.errors['user.email']);\n      assert.equal(error.errors['user.email'].kind, 'regexp');\n    });\n\n    it('single embedded parent() (gh-5134)', function() {\n      const userSchema = new mongoose.Schema({\n        name: String,\n        email: { type: String, required: true, match: /.+@.+/ }\n      }, { _id: false, id: false });\n\n      const eventSchema = new mongoose.Schema({\n        user: userSchema,\n        name: String\n      });\n\n      const Event = db.model('Event', eventSchema);\n\n      const e = new Event({ name: 'test', user: {} });\n      assert.strictEqual(e.user.parent(), e.user.ownerDocument());\n    });\n\n    it('single embedded schemas with markmodified (gh-2689)', async function() {\n      const userSchema = new mongoose.Schema({\n        name: String,\n        email: { type: String, required: true, match: /.+@.+/ }\n      }, { _id: false, id: false });\n\n      const eventSchema = new mongoose.Schema({\n        user: userSchema,\n        name: String\n      });\n\n      const Event = db.model('Event', eventSchema);\n\n      const e = new Event({ name: 'test', user: { email: 'a@b' } });\n      const doc = await e.save();\n\n      assert.ok(doc);\n      assert.ok(!doc.isModified('user'));\n      assert.ok(!doc.isModified('user.email'));\n      assert.ok(!doc.isModified('user.name'));\n      doc.user.name = 'Val';\n      assert.ok(doc.isModified('user'));\n      assert.ok(!doc.isModified('user.email'));\n      assert.ok(doc.isModified('user.name'));\n\n      const delta = doc.$__delta()[1];\n      assert.deepEqual(delta, {\n        $set: { 'user.name': 'Val' }\n      });\n\n      await doc.save();\n\n      const event = await Event.findOne({ _id: doc._id });\n\n      assert.deepEqual(event.user.toObject(), { email: 'a@b', name: 'Val' });\n    });\n\n    it('single embedded schemas + update validators (gh-2689)', async function() {\n      const userSchema = new mongoose.Schema({\n        name: { type: String, default: 'Val' },\n        email: { type: String, required: true, match: /.+@.+/ }\n      }, { _id: false, id: false });\n\n      const eventSchema = new mongoose.Schema({\n        user: userSchema,\n        name: String\n      });\n\n      const Event = db.model('Event', eventSchema);\n\n      const badUpdate = { $set: { 'user.email': 'a' } };\n      const options = { runValidators: true };\n\n      const error = await Event.updateOne({}, badUpdate, options).then(() => null, err => err);\n\n      assert.ok(error);\n      assert.equal(error.errors['user.email'].kind, 'regexp');\n\n      const nestedUpdate = { name: 'test', user: {} };\n\n      // Does not throw\n      await Event.updateOne({}, nestedUpdate, { upsert: true });\n\n      const ev = await Event.findOne({ name: 'test' });\n\n      assert.equal(ev.user.name, 'Val');\n    });\n\n    it('single embedded schema update validators ignore _id (gh-6269)', async function() {\n\n      const subDocSchema = new mongoose.Schema({ name: String });\n\n      const schema = new mongoose.Schema({\n        subDoc: subDocSchema,\n        test: String\n      });\n\n      const Model = db.model('Test', schema);\n\n      const fakeDoc = new Model({});\n      await Model.create({});\n\n      const res = await Model.findOneAndUpdate(\n        { _id: fakeDoc._id },\n        { test: 'test' },\n        { upsert: true, new: true }\n      );\n\n      assert.equal(res.test, 'test');\n      assert.ok(!res.subDoc);\n    });\n  });\n\n  describe('error processing (gh-2284)', async function() {\n    it('save errors', async function() {\n      const schema = new Schema({\n        name: { type: String, required: true }\n      });\n\n      schema.post('save', function(error, doc, next) {\n        assert.ok(doc instanceof Model);\n        next(new Error('Catch all'));\n      });\n\n      schema.post('save', function(error, doc, next) {\n        assert.ok(doc instanceof Model);\n        next(new Error('Catch all #2'));\n      });\n\n      const Model = db.model('Test', schema);\n\n      const error = await Model.create({}).then(() => null, err => err);\n\n      assert.ok(error);\n      assert.equal(error.message, 'Catch all #2');\n    });\n\n    it('validate errors (gh-4885)', async function() {\n      const testSchema = new Schema({ title: { type: String, required: true } });\n\n      let called = 0;\n      testSchema.post('validate', function(error, doc, next) {\n        ++called;\n        next(error);\n      });\n\n      const Test = db.model('Test', testSchema);\n\n      const error = await Test.create({}).then(() => null, err => err);\n\n      assert.ok(error);\n      assert.equal(called, 1);\n    });\n\n    it('does not filter validation on unmodified paths when validateModifiedOnly not set (gh-7421)', async function() {\n      const testSchema = new Schema({ title: { type: String, required: true }, other: String });\n\n      const Test = db.model('Test', testSchema);\n\n      const docs = await Test.create([{}], { validateBeforeSave: false });\n\n      const doc = docs[0];\n      doc.other = 'something';\n      assert.ok(doc.validateSync().errors);\n      const error = await doc.save().then(() => null, err => err);\n      assert.ok(error.errors);\n    });\n\n    it('filters out validation on unmodified paths when validateModifiedOnly set (gh-7421) (gh-9963)', async function() {\n      const testSchema = new Schema({\n        title: { type: String, required: true },\n        other: String,\n        subdocs: [{ name: { type: String, required: true } }]\n      });\n\n      const Test = db.model('Test', testSchema);\n\n      const docs = await Test.create(\n        [{ subdocs: [{ name: null }, { name: 'test' }] }],\n        { validateBeforeSave: false }\n      );\n\n      const doc = docs[0];\n      doc.other = 'something';\n      doc.subdocs[1].name = 'test2';\n      assert.equal(doc.validateSync({ validateModifiedOnly: true }), null);\n      assert.equal(doc.validateSync('other'), null);\n      assert.ok(doc.validateSync('other title').errors['title']);\n\n      // Does not throw\n      await doc.save({ validateModifiedOnly: true });\n    });\n\n    it('does not filter validation on modified paths when validateModifiedOnly set (gh-7421)', async function() {\n      const testSchema = new Schema({ title: { type: String, required: true }, other: String });\n\n      const Test = db.model('Test', testSchema);\n\n      const docs = await Test.create([{ title: 'title' }], { validateBeforeSave: false });\n\n      const doc = docs[0];\n      doc.title = '';\n      assert.ok(doc.validateSync({ validateModifiedOnly: true }).errors);\n      const error = await doc.save({ validateModifiedOnly: true }).then(() => null, err => err);\n\n      assert.ok(error.errors);\n    });\n\n    it('validateModifiedOnly with pre existing validation error (gh-8091)', async function() {\n      const schema = mongoose.Schema({\n        title: String,\n        coverId: Number\n      }, { validateModifiedOnly: true });\n\n      const Model = db.model('Test', schema);\n\n\n      await Model.collection.insertOne({ title: 'foo', coverId: parseFloat('not a number') });\n\n      const doc = await Model.findOne();\n      doc.title = 'bar';\n      // Should not throw\n      await doc.save();\n    });\n\n    it('handles non-errors', async function() {\n      const schema = new Schema({\n        name: { type: String, required: true }\n      });\n\n      schema.post('save', function(error, doc, next) {\n        next(new Error('Catch all'));\n      });\n\n      schema.post('save', function(error, doc, next) {\n        next(new Error('Catch all #2'));\n      });\n\n      const Model = db.model('Test', schema);\n\n      // Does not throw\n      await Model.create({ name: 'test' });\n    });\n  });\n\n  describe('bug fixes', function() {\n    beforeEach(() => db.deleteModel(/.*/));\n\n    it('single embedded schemas with populate (gh-3501)', async function() {\n      const PopulateMeSchema = new Schema({});\n\n      const Child = db.model('Child', PopulateMeSchema);\n\n      const SingleNestedSchema = new Schema({\n        populateMeArray: [{\n          type: Schema.Types.ObjectId,\n          ref: 'Child'\n        }]\n      });\n\n      const parentSchema = new Schema({\n        singleNested: SingleNestedSchema\n      });\n\n      const P = db.model('Parent', parentSchema);\n\n      const docs = await Child.create([{}, {}]);\n\n      const obj = {\n        singleNested: { populateMeArray: [docs[0]._id, docs[1]._id] }\n      };\n      const doc = await P.create(obj);\n\n      const foundDoc = await P.\n        findById(doc._id).\n        populate('singleNested.populateMeArray').\n        exec();\n\n      assert.ok(foundDoc.singleNested.populateMeArray[0]._id);\n    });\n\n    it('single embedded schemas with methods (gh-3534)', function() {\n      const personSchema = new Schema({ name: String });\n      personSchema.methods.firstName = function() {\n        return this.name.substring(0, this.name.indexOf(' '));\n      };\n\n      const bandSchema = new Schema({ leadSinger: personSchema });\n      const Band = db.model('Band', bandSchema);\n\n      const gnr = new Band({ leadSinger: { name: 'Axl Rose' } });\n      assert.equal(gnr.leadSinger.firstName(), 'Axl');\n    });\n\n    it('single embedded schemas with models (gh-3535)', function(done) {\n      const personSchema = new Schema({ name: String });\n      const Person = db.model('Person', personSchema);\n\n      const bandSchema = new Schema({ leadSinger: personSchema });\n      const Band = db.model('Band', bandSchema);\n\n      const axl = new Person({ name: 'Axl Rose' });\n      const gnr = new Band({ leadSinger: axl });\n\n      gnr.save(function(error) {\n        assert.ifError(error);\n        assert.equal(gnr.leadSinger.name, 'Axl Rose');\n        done();\n      });\n    });\n\n    it('single embedded schemas with indexes (gh-3594)', function() {\n      const personSchema = new Schema({ name: { type: String, unique: true } });\n\n      const bandSchema = new Schema({ leadSinger: personSchema });\n\n      assert.equal(bandSchema.indexes().length, 1);\n      const index = bandSchema.indexes()[0];\n      assert.deepEqual(index[0], { 'leadSinger.name': 1 });\n      assert.ok(index[1].unique);\n    });\n\n    it('removing single embedded docs (gh-3596)', async function() {\n      const personSchema = new Schema({ name: String });\n\n      const bandSchema = new Schema({ guitarist: personSchema, name: String });\n      const Band = db.model('Band', bandSchema);\n\n      const gnr = new Band({\n        name: 'Guns N\\' Roses',\n        guitarist: { name: 'Slash' }\n      });\n\n      await gnr.save();\n\n      gnr.guitarist = undefined;\n      await gnr.save();\n\n      assert.ok(!gnr.guitarist);\n    });\n\n    it('setting single embedded docs (gh-3601)', async function() {\n      const personSchema = new Schema({ name: String });\n\n      const bandSchema = new Schema({ guitarist: personSchema, name: String });\n      const Band = db.model('Band', bandSchema);\n\n      const gnr = new Band({\n        name: 'Guns N\\' Roses',\n        guitarist: { name: 'Slash' }\n      });\n      const velvetRevolver = new Band({\n        name: 'Velvet Revolver'\n      });\n      velvetRevolver.guitarist = gnr.guitarist;\n      await velvetRevolver.save();\n\n      assert.equal(velvetRevolver.guitarist.name, 'Slash');\n    });\n\n    it('single embedded docs init obeys strict mode (gh-3642)', async function() {\n      const personSchema = new Schema({ name: String });\n\n      const bandSchema = new Schema({ guitarist: personSchema, name: String });\n      const Band = db.model('Band', bandSchema);\n\n      const velvetRevolver = new Band({\n        name: 'Velvet Revolver',\n        guitarist: { name: 'Slash', realName: 'Saul Hudson' }\n      });\n\n      await velvetRevolver.save();\n\n      const query = { name: 'Velvet Revolver' };\n      const band = await Band.collection.findOne(query);\n\n      assert.ok(!band.guitarist.realName);\n    });\n\n    it('single embedded docs post hooks (gh-3679)', async function() {\n      const postHookCalls = [];\n      const personSchema = new Schema({ name: String });\n      personSchema.post('save', function() {\n        postHookCalls.push(this);\n      });\n\n      const bandSchema = new Schema({ guitarist: personSchema, name: String });\n      const Band = db.model('Band', bandSchema);\n      const obj = { name: 'Guns N\\' Roses', guitarist: { name: 'Slash' } };\n\n      await Band.create(obj);\n      await new Promise((resolve) => {\n        setTimeout(function() {\n          assert.equal(postHookCalls.length, 1);\n          assert.equal(postHookCalls[0].name, 'Slash');\n          resolve();\n        });\n      });\n\n    });\n\n    it('single embedded docs .set() (gh-3686)', async function() {\n      const personSchema = new Schema({ name: String, realName: String });\n\n      const bandSchema = new Schema({\n        guitarist: personSchema,\n        name: String\n      });\n      const Band = db.model('Band', bandSchema);\n      const obj = {\n        name: 'Guns N\\' Roses',\n        guitarist: { name: 'Slash', realName: 'Saul Hudson' }\n      };\n\n      const gnr = await Band.create(obj);\n\n      gnr.set('guitarist.name', 'Buckethead');\n      await gnr.save();\n\n      assert.equal(gnr.guitarist.name, 'Buckethead');\n      assert.equal(gnr.guitarist.realName, 'Saul Hudson');\n    });\n\n    it('single embedded docs with arrays pre hooks (gh-3680)', async function() {\n      const childSchema = new Schema({ count: Number });\n\n      let preCalls = 0;\n      childSchema.pre('save', function(next) {\n        ++preCalls;\n        next();\n      });\n\n      const SingleNestedSchema = new Schema({\n        children: [childSchema]\n      });\n\n      const ParentSchema = new Schema({\n        singleNested: SingleNestedSchema\n      });\n\n      const Parent = db.model('Parent', ParentSchema);\n      const obj = { singleNested: { children: [{ count: 0 }] } };\n      await Parent.create(obj);\n\n      assert.equal(preCalls, 1);\n    });\n\n    it('nested single embedded doc validation (gh-3702)', function(done) {\n      const childChildSchema = new Schema({ count: { type: Number, min: 1 } });\n      const childSchema = new Schema({ child: childChildSchema });\n      const parentSchema = new Schema({ child: childSchema });\n\n      const Parent = db.model('Parent', parentSchema);\n      const obj = { child: { child: { count: 0 } } };\n      Parent.create(obj, function(error) {\n        assert.ok(error);\n        assert.ok(/ValidationError/.test(error.toString()));\n        done();\n      });\n    });\n\n    it('handles virtuals with dots correctly (gh-3618)', function() {\n      const testSchema = new Schema({ nested: { type: Object, default: {} } });\n      testSchema.virtual('nested.test').get(function() {\n        return true;\n      });\n\n      const Test = db.model('Test', testSchema);\n\n      const test = new Test();\n\n      let doc = test.toObject({ getters: true, virtuals: true });\n      delete doc._id;\n      delete doc.id;\n      assert.deepEqual(doc, { nested: { test: true } });\n\n      doc = test.toObject({ getters: false, virtuals: true });\n      delete doc._id;\n      delete doc.id;\n      assert.deepEqual(doc, { nested: { test: true } });\n    });\n\n    it('handles pushing with numeric keys (gh-3623)', async function() {\n      const schema = new Schema({\n        array: [{\n          1: {\n            date: Date\n          },\n          2: {\n            date: Date\n          },\n          3: {\n            date: Date\n          }\n        }]\n      });\n\n      const MyModel = db.model('Test', schema);\n\n      const doc = { array: [{ 2: {} }] };\n      await MyModel.collection.insertOne(doc);\n\n      const foundDoc = await MyModel.findOne({ _id: doc._id });\n\n      foundDoc.array.push({ 2: {} });\n      await foundDoc.save();\n    });\n\n    it('handles 0 for numeric subdoc ids (gh-3776)', async function() {\n      const personSchema = new Schema({\n        _id: Number,\n        name: String,\n        age: Number,\n        friends: [{ type: Number, ref: 'Person' }]\n      });\n\n      const Person = db.model('Person', personSchema);\n\n\n      const people = await Person.create([\n        { _id: 0, name: 'Alice' },\n        { _id: 1, name: 'Bob' }\n      ]);\n\n      const alice = people[0];\n      alice.friends.push(people[1]);\n\n      // Should not throw\n      await alice.save();\n    });\n\n    it('handles conflicting names (gh-3867)', function() {\n      const testSchema = new Schema({\n        name: {\n          type: String,\n          required: true\n        },\n        things: [{\n          name: {\n            type: String,\n            required: true\n          }\n        }]\n      });\n\n      const M = db.model('Test', testSchema);\n\n      const doc = M({\n        things: [{}]\n      });\n\n      const fields = Object.keys(doc.validateSync().errors).sort();\n      assert.deepEqual(fields, ['name', 'things.0.name']);\n    });\n\n    it('populate with lean (gh-3873)', async function() {\n      const companySchema = new mongoose.Schema({\n        name: String,\n        description: String,\n        userCnt: { type: Number, default: 0, select: false }\n      });\n\n      const userSchema = new mongoose.Schema({\n        name: String,\n        company: { type: mongoose.Schema.Types.ObjectId, ref: 'Company' }\n      });\n\n      const Company = db.model('Company', companySchema);\n      const User = db.model('User', userSchema);\n\n      const company = new Company({ name: 'IniTech', userCnt: 1 });\n      const user = new User({ name: 'Peter', company: company._id });\n\n      await company.save();\n\n      await user.save();\n\n      const pop = { path: 'company', select: 'name', options: { lean: true } };\n      const docs = await User.find({}).populate(pop).exec();\n\n      assert.equal(docs.length, 1);\n      assert.strictEqual(docs[0].company.userCnt, undefined);\n    });\n\n    it('init single nested subdoc with select (gh-3880)', async function() {\n      const childSchema = new mongoose.Schema({\n        name: { type: String },\n        friends: [{ type: String }]\n      });\n\n      const parentSchema = new mongoose.Schema({\n        name: { type: String },\n        child: childSchema\n      });\n\n      const Parent = db.model('Parent', parentSchema);\n      const p = new Parent({\n        name: 'Mufasa',\n        child: {\n          name: 'Simba',\n          friends: ['Pumbaa', 'Timon', 'Nala']\n        }\n      });\n\n      await p.save();\n\n      const fields = 'name child.name';\n      const doc = await Parent.findById(p._id).select(fields).exec();\n\n      assert.strictEqual(doc.child.friends, void 0);\n    });\n\n    it('single nested subdoc isModified() (gh-3910)', async function() {\n      let called = 0;\n\n      const ChildSchema = new Schema({\n        name: String\n      });\n\n      ChildSchema.pre('save', function(next) {\n        assert.ok(this.isModified('name'));\n        ++called;\n        next();\n      });\n\n      const ParentSchema = new Schema({\n        name: String,\n        child: ChildSchema\n      });\n\n      const Parent = db.model('Parent', ParentSchema);\n\n      const p = new Parent({\n        name: 'Darth Vader',\n        child: {\n          name: 'Luke Skywalker'\n        }\n      });\n\n      await p.save();\n\n      assert.strictEqual(called, 1);\n    });\n\n    it('pre and post as schema keys (gh-3902)', async function() {\n      const schema = new mongoose.Schema({\n        pre: String,\n        post: String\n      }, { versionKey: false });\n\n      const MyModel = db.model('Test', schema);\n\n      const doc = await MyModel.create({ pre: 'test', post: 'test' });\n\n      assert.deepEqual(\n        utils.omit(doc.toObject(), '_id'),\n        { pre: 'test', post: 'test' }\n      );\n    });\n\n    it('manual population and isNew (gh-3982)', async function() {\n      const NestedModelSchema = new mongoose.Schema({\n        field: String\n      });\n\n      const NestedModel = db.model('Test', NestedModelSchema);\n\n      const ModelSchema = new mongoose.Schema({\n        field: String,\n        array: [{\n          type: mongoose.Schema.ObjectId,\n          ref: 'Test',\n          required: true\n        }]\n      });\n\n      const Model = db.model('Test1', ModelSchema);\n\n      const nestedModel = new NestedModel({\n        field: 'nestedModel'\n      });\n\n      await nestedModel.save();\n\n      const doc = await Model.create({ array: [nestedModel._id] });\n\n      const foundDoc = await Model.findById(doc._id).populate('array').exec();\n\n      foundDoc.array.push(nestedModel);\n      assert.strictEqual(foundDoc.isNew, false);\n      assert.strictEqual(foundDoc.array[0].isNew, false);\n      assert.strictEqual(foundDoc.array[1].isNew, false);\n      assert.strictEqual(nestedModel.isNew, false);\n    });\n\n    it('manual population with refPath (gh-7070)', async function() {\n      const ChildModelSchema = new mongoose.Schema({\n        name: String\n      });\n\n      const ChildModel = db.model('Child', ChildModelSchema);\n\n      const ParentModelSchema = new mongoose.Schema({\n        model: String,\n        childId: { type: mongoose.ObjectId, refPath: 'model' },\n        otherId: mongoose.ObjectId\n      });\n\n      const ParentModel = db.model('Parent', ParentModelSchema);\n\n\n      const child = await ChildModel.create({ name: 'test' });\n\n      let parent = await ParentModel.create({\n        model: 'Child',\n        childId: child._id\n      });\n\n      parent = await ParentModel.findOne();\n\n      parent.childId = child;\n      parent.otherId = child;\n\n      assert.equal(parent.childId.name, 'test');\n      assert.ok(parent.otherId instanceof mongoose.Types.ObjectId);\n    });\n\n    it('doesnt skipId for single nested subdocs (gh-4008)', async function() {\n      const childSchema = new Schema({\n        name: String\n      });\n\n      const parentSchema = new Schema({\n        child: childSchema\n      });\n\n      const Parent = db.model('Parent', parentSchema);\n\n      const doc = await Parent.create({ child: { name: 'My child' } });\n\n      const foundDoc = await Parent.collection.findOne({ _id: doc._id });\n      assert.ok(foundDoc.child._id);\n    });\n\n    it('single embedded docs with $near (gh-4014)', async function() {\n      const schema = new mongoose.Schema({\n        placeName: String\n      });\n\n      const geoSchema = new mongoose.Schema({\n        type: {\n          type: String,\n          enum: 'Point',\n          default: 'Point'\n        },\n        coordinates: {\n          type: [Number],\n          default: [0, 0]\n        }\n      });\n\n      schema.add({ geo: geoSchema });\n      schema.index({ geo: '2dsphere' });\n\n      const MyModel = db.model('Test', schema);\n      await MyModel.init();\n\n      await MyModel.\n        where('geo').near({ center: [50, 50], spherical: true }).\n        exec();\n    });\n\n    it('skip validation if required returns false (gh-4094)', function() {\n      const schema = new Schema({\n        div: {\n          type: Number,\n          required: function() { return false; },\n          validate: function(v) { return !!v; }\n        }\n      });\n      const Model = db.model('Test', schema);\n      const m = new Model();\n      assert.ifError(m.validateSync());\n    });\n\n    it('ability to overwrite array default (gh-4109)', async function() {\n      const schema = new Schema({\n        names: {\n          type: [String],\n          default: void 0\n        }\n      });\n\n      const Model = db.model('Test', schema);\n      const m = new Model();\n      assert.ok(!m.names);\n      await m.save();\n\n      const doc = await Model.collection.findOne({ _id: m._id });\n\n      assert.ok(!('names' in doc));\n    });\n\n    it('validation works when setting array index (gh-3816)', async function() {\n      const mySchema = new mongoose.Schema({\n        items: [\n          { month: Number, date: Date }\n        ]\n      });\n\n      const Test = db.model('test', mySchema);\n\n      const a = [\n        { month: 0, date: new Date() },\n        { month: 1, date: new Date() }\n      ];\n      const doc = await Test.create({ items: a });\n\n      const foundDoc = await Test.findById(doc._id).exec();\n\n      assert.ok(foundDoc);\n      foundDoc.items[0] = {\n        month: 5,\n        date: new Date()\n      };\n      foundDoc.markModified('items');\n\n      // Should not throw\n      await foundDoc.save();\n    });\n\n    it('validateSync works when setting array index nested (gh-5389)', async function() {\n      const childSchema = new mongoose.Schema({\n        _id: false,\n        name: String,\n        age: Number\n      });\n\n      const schema = new mongoose.Schema({\n        name: String,\n        children: [childSchema]\n      });\n\n      const Model = db.model('Test', schema);\n\n      const doc = await Model.create({\n        name: 'test',\n        children: [\n          { name: 'test-child', age: 24 }\n        ]\n      });\n\n      const foundDoc = await Model.findById(doc._id);\n\n      foundDoc.children[0] = { name: 'updated-child', age: 53 };\n      const errors = foundDoc.validateSync();\n      assert.ok(!errors);\n    });\n\n    it('single embedded with defaults have $parent (gh-4115)', function() {\n      const ChildSchema = new Schema({\n        name: {\n          type: String,\n          default: 'child'\n        }\n      });\n\n      const ParentSchema = new Schema({\n        child: {\n          type: ChildSchema,\n          default: {}\n        }\n      });\n\n      const Parent = db.model('Parent', ParentSchema);\n\n      const p = new Parent();\n      assert.equal(p.child.$parent(), p);\n    });\n\n    it('removing parent doc calls remove hooks on subdocs (gh-2348) (gh-4566)', async function() {\n      const ChildSchema = new Schema({\n        name: String\n      });\n\n      const called = {};\n      ChildSchema.pre('remove', function(next) {\n        called[this.name] = true;\n        next();\n      });\n\n      const ParentSchema = new Schema({\n        children: [ChildSchema],\n        child: ChildSchema\n      });\n\n      const Parent = db.model('Parent', ParentSchema);\n\n      const doc = await Parent.create({\n        children: [{ name: 'Jacen' }, { name: 'Jaina' }],\n        child: { name: 'Anakin' }\n      });\n\n      await doc.remove();\n\n      assert.deepEqual(called, {\n        Jacen: true,\n        Jaina: true,\n        Anakin: true\n      });\n\n      const arr = doc.children.toObject().map(function(v) { return v.name; });\n      assert.deepEqual(arr, ['Jacen', 'Jaina']);\n      assert.equal(doc.child.name, 'Anakin');\n    });\n\n    it('strings of length 12 are valid oids (gh-3365)', async function() {\n      const schema = new Schema({ myId: mongoose.Schema.Types.ObjectId });\n      const M = db.model('Test', schema);\n      const doc = new M({ myId: 'blablablabla' });\n      await doc.validate();\n    });\n\n    it('set() empty obj unmodifies subpaths (gh-4182)', async function() {\n      const omeletteSchema = new Schema({\n        topping: {\n          meat: {\n            type: String,\n            enum: ['bacon', 'sausage']\n          },\n          cheese: Boolean\n        }\n      });\n      const Omelette = db.model('Test', omeletteSchema);\n      const doc = new Omelette({\n        topping: {\n          meat: 'bacon',\n          cheese: true\n        }\n      });\n      doc.topping = {};\n      await doc.save();\n      assert.strictEqual(doc.topping.meat, void 0);\n    });\n\n    it('emits cb errors on model for save (gh-3499)', function(done) {\n      const testSchema = new Schema({ name: String });\n\n      const Test = db.model('Test', testSchema);\n      Test.on('error', function(error) {\n        assert.equal(error.message, 'fail!');\n        done();\n      });\n\n      new Test({}).save(function() {\n        throw new Error('fail!');\n      });\n    });\n\n    it('emits cb errors on model for save with hooks (gh-3499)', function(done) {\n      const testSchema = new Schema({ name: String });\n\n      testSchema.pre('save', function(next) {\n        next();\n      });\n\n      testSchema.post('save', function(doc, next) {\n        next();\n      });\n\n      const Test = db.model('Test', testSchema);\n\n      Test.on('error', function(error) {\n        assert.equal(error.message, 'fail!');\n        done();\n      });\n\n      new Test({}).save(function() {\n        throw new Error('fail!');\n      });\n    });\n\n    it('emits cb errors on model for find() (gh-3499)', function(done) {\n      const testSchema = new Schema({ name: String });\n\n      const Test = db.model('Test', testSchema);\n\n      Test.on('error', function(error) {\n        assert.equal(error.message, 'fail!');\n        done();\n      });\n\n      Test.find({}, function() {\n        throw new Error('fail!');\n      });\n    });\n\n    it('emits cb errors on model for find() + hooks (gh-3499)', function(done) {\n      const testSchema = new Schema({ name: String });\n\n      testSchema.post('find', function(results, next) {\n        assert.equal(results.length, 0);\n        next();\n      });\n\n      const Test = db.model('Test', testSchema);\n\n      Test.on('error', function(error) {\n        assert.equal(error.message, 'fail!');\n        done();\n      });\n\n      Test.find({}, function() {\n        throw new Error('fail!');\n      });\n    });\n\n    it('clears subpaths when removing single nested (gh-4216)', function(done) {\n      const RecurrenceSchema = new Schema({\n        frequency: Number,\n        interval: {\n          type: String,\n          enum: ['days', 'weeks', 'months', 'years']\n        }\n      }, { _id: false });\n\n      const EventSchema = new Schema({\n        name: {\n          type: String,\n          trim: true\n        },\n        recurrence: RecurrenceSchema\n      });\n\n      const Event = db.model('Test', EventSchema);\n      const ev = new Event({\n        name: 'test',\n        recurrence: { frequency: 2, interval: 'days' }\n      });\n      ev.recurrence = null;\n      ev.save(function(error) {\n        assert.ifError(error);\n        done();\n      });\n    });\n\n    it('setting path to empty object works (gh-4218)', async function() {\n      const schema = new Schema({\n        object: {\n          nested: {\n            field1: { type: Number, default: 1 }\n          }\n        }\n      });\n\n      const MyModel = db.model('Test', schema);\n\n\n      let doc = await MyModel.create({});\n      doc.object.nested = {};\n      await doc.save();\n      doc = await MyModel.collection.findOne({ _id: doc._id });\n      assert.deepEqual(doc.object.nested, {});\n    });\n\n    it('setting path to object with strict and no paths in the schema (gh-6436) (gh-4218)', async function() {\n      const schema = new Schema({\n        object: {\n          nested: {\n            field1: { type: Number, default: 1 }\n          }\n        }\n      });\n\n      const MyModel = db.model('Test', schema);\n\n\n      let doc = await MyModel.create({});\n      doc.object.nested = { field2: 'foo' }; // `field2` not in the schema\n      await doc.save();\n      doc = await MyModel.collection.findOne({ _id: doc._id });\n      assert.deepEqual(doc.object.nested, {});\n    });\n\n    it('minimize + empty object (gh-4337)', function() {\n      const SomeModelSchema = new mongoose.Schema(\n        {},\n        { minimize: false }\n      );\n\n      const SomeModel = db.model('Test', SomeModelSchema);\n\n      assert.doesNotThrow(function() {\n        new SomeModel({});\n      });\n    });\n\n    it('directModifiedPaths() (gh-7373)', async function() {\n      const schema = new Schema({ foo: String, nested: { bar: String } });\n      const Model = db.model('Test', schema);\n\n\n      await Model.create({ foo: 'original', nested: { bar: 'original' } });\n\n      const doc = await Model.findOne();\n      doc.nested.bar = 'modified';\n\n      assert.deepEqual(doc.directModifiedPaths(), ['nested.bar']);\n      assert.deepEqual(doc.modifiedPaths().sort(), ['nested', 'nested.bar']);\n    });\n\n    describe('modifiedPaths', function() {\n      it('doesnt markModified child paths if parent is modified (gh-4224)', async function() {\n        const childSchema = new Schema({\n          name: String\n        });\n        const parentSchema = new Schema({\n          child: childSchema\n        });\n\n        const Parent = db.model('Test', parentSchema);\n        const doc = await Parent.create({ child: { name: 'Jacen' } });\n\n        doc.child = { name: 'Jaina' };\n        doc.child.name = 'Anakin';\n        assert.deepEqual(doc.modifiedPaths(), ['child']);\n        assert.ok(doc.isModified('child.name'));\n      });\n\n      it('includeChildren option (gh-6134)', function() {\n        const personSchema = new mongoose.Schema({\n          name: { type: String },\n          colors: {\n            primary: {\n              type: String,\n              default: 'white',\n              enum: ['blue', 'green', 'red', 'purple', 'yellow']\n            }\n          }\n        });\n\n        const Person = db.model('Person', personSchema);\n\n        const luke = new Person({\n          name: 'Luke',\n          colors: {\n            primary: 'blue'\n          }\n        });\n        assert.deepEqual(luke.modifiedPaths(), ['name', 'colors']);\n\n        const obiwan = new Person({ name: 'Obi-Wan' });\n        obiwan.colors.primary = 'blue';\n        assert.deepEqual(obiwan.modifiedPaths(), ['name', 'colors', 'colors.primary']);\n\n        const anakin = new Person({ name: 'Anakin' });\n        anakin.colors = { primary: 'blue' };\n        assert.deepEqual(anakin.modifiedPaths({ includeChildren: true }), ['name', 'colors', 'colors.primary']);\n      });\n\n      it('includeChildren option with arrays (gh-5904)', function() {\n        const teamSchema = new mongoose.Schema({\n          name: String,\n          colors: {\n            primary: {\n              type: String,\n              enum: ['blue', 'green', 'red', 'purple', 'yellow', 'white', 'black']\n            }\n          },\n          members: [{\n            name: String\n          }]\n        });\n\n        const Team = db.model('Team', teamSchema);\n\n        const jedis = new Team({\n          name: 'Jedis',\n          colors: {\n            primary: 'blue'\n          },\n          members: [{ name: 'luke' }]\n        });\n\n        const paths = jedis.modifiedPaths({ includeChildren: true });\n        assert.deepEqual(paths, [\n          'name',\n          'colors',\n          'colors.primary',\n          'members',\n          'members.0',\n          'members.0.name'\n        ]);\n      });\n\n      it('1 level down nested paths get marked modified on initial set (gh-7313) (gh-6944)', function() {\n        const testSchema = new Schema({\n          name: {\n            first: String,\n            last: String\n          },\n          relatives: {\n            aunt: {\n              name: String\n            },\n            uncle: {\n              name: String\n            }\n          }\n        });\n        const M = db.model('Test', testSchema);\n\n        const doc = new M({\n          name: { first: 'A', last: 'B' },\n          relatives: {\n            aunt: { name: 'foo' },\n            uncle: { name: 'bar' }\n          }\n        });\n\n        assert.ok(doc.modifiedPaths().indexOf('name') !== -1);\n        assert.ok(doc.modifiedPaths().indexOf('relatives') !== -1);\n        assert.ok(doc.modifiedPaths({ includeChildren: true }).indexOf('name.first') !== -1);\n        assert.ok(doc.modifiedPaths({ includeChildren: true }).indexOf('name.last') !== -1);\n        assert.ok(doc.modifiedPaths({ includeChildren: true }).indexOf('relatives.aunt') !== -1);\n        assert.ok(doc.modifiedPaths({ includeChildren: true }).indexOf('relatives.uncle') !== -1);\n\n        return Promise.resolve();\n      });\n    });\n\n    it('single nested isNew (gh-4369)', function(done) {\n      const childSchema = new Schema({\n        name: String\n      });\n      const parentSchema = new Schema({\n        child: childSchema\n      });\n\n      const Parent = db.model('Test', parentSchema);\n      let remaining = 2;\n\n      const doc = new Parent({ child: { name: 'Jacen' } });\n      doc.child.on('isNew', function(val) {\n        assert.ok(!val);\n        assert.ok(!doc.child.isNew);\n        --remaining || done();\n      });\n\n      doc.save(function(error, doc) {\n        assert.ifError(error);\n        assert.ok(!doc.child.isNew);\n        --remaining || done();\n      });\n    });\n\n    it('deep default array values (gh-4540)', function() {\n      const schema = new Schema({\n        arr: [{\n          test: {\n            type: Array,\n            default: ['test']\n          }\n        }]\n      });\n      assert.doesNotThrow(function() {\n        db.model('Test', schema);\n      });\n    });\n\n    it('default values with subdoc array (gh-4390)', function(done) {\n      const childSchema = new Schema({\n        name: String\n      });\n      const parentSchema = new Schema({\n        child: [childSchema]\n      });\n\n      parentSchema.path('child').default([{ name: 'test' }]);\n\n      const Parent = db.model('Parent', parentSchema);\n\n      Parent.create({}, function(error, doc) {\n        assert.ifError(error);\n        const arr = doc.toObject().child.map(function(doc) {\n          assert.ok(doc._id);\n          delete doc._id;\n          return doc;\n        });\n        assert.deepEqual(arr, [{ name: 'test' }]);\n        done();\n      });\n    });\n\n    it('handles invalid dates (gh-4404)', function(done) {\n      const testSchema = new Schema({\n        date: Date\n      });\n\n      const Test = db.model('Test', testSchema);\n\n      Test.create({ date: new Date('invalid date') }, function(error) {\n        assert.ok(error);\n        assert.equal(error.errors['date'].name, 'CastError');\n        done();\n      });\n    });\n\n    it('setting array subpath (gh-4472)', function() {\n      const ChildSchema = new mongoose.Schema({\n        name: String,\n        age: Number\n      }, { _id: false });\n\n      const ParentSchema = new mongoose.Schema({\n        data: {\n          children: [ChildSchema]\n        }\n      });\n\n      const Parent = db.model('Parent', ParentSchema);\n\n      const p = new Parent();\n      p.set('data.children.0', {\n        name: 'Bob',\n        age: 900\n      });\n\n      assert.deepEqual(p.toObject().data.children, [{ name: 'Bob', age: 900 }]);\n    });\n\n    it('ignore paths (gh-4480)', async function() {\n      const TestSchema = new Schema({\n        name: { type: String, required: true }\n      });\n\n      const Test = db.model('Parent', TestSchema);\n\n\n      await Test.create({ name: 'val' });\n\n      let doc = await Test.findOne();\n\n      doc.name = null;\n      doc.$ignore('name');\n\n      await doc.save();\n\n      doc = await Test.findById(doc._id);\n\n      assert.equal(doc.name, 'val');\n    });\n\n    it('ignore subdocs paths (gh-4480) (gh-6152)', async function() {\n      const childSchema = new Schema({\n        name: { type: String, required: true }\n      });\n      const testSchema = new Schema({\n        child: childSchema,\n        children: [childSchema]\n      });\n\n      const Test = db.model('Test', testSchema);\n\n\n      await Test.create({\n        child: { name: 'testSingle' },\n        children: [{ name: 'testArr' }]\n      });\n\n      let doc = await Test.findOne();\n      doc.child.name = null;\n      doc.child.$ignore('name');\n\n      await doc.save();\n\n      doc = await Test.findById(doc._id);\n\n      assert.equal(doc.child.name, 'testSingle');\n\n      doc.children[0].name = null;\n      doc.children[0].$ignore('name');\n\n      await doc.save();\n\n      doc = await Test.findById(doc._id);\n\n      assert.equal(doc.children[0].name, 'testArr');\n    });\n\n    it('composite _ids (gh-4542)', function(done) {\n      const schema = new Schema({\n        _id: {\n          key1: String,\n          key2: String\n        },\n        content: String\n      });\n\n      const Model = db.model('Test', schema);\n\n      const object = new Model();\n      object._id = { key1: 'foo', key2: 'bar' };\n      object.save().\n        then(function(obj) {\n          obj.content = 'Hello';\n          return obj.save();\n        }).\n        then(function(obj) {\n          return Model.findOne({ _id: obj._id });\n        }).\n        then(function(obj) {\n          assert.equal(obj.content, 'Hello');\n          done();\n        }).\n        catch(done);\n    });\n\n    it('validateSync with undefined and conditional required (gh-4607)', function() {\n      const schema = new mongoose.Schema({\n        type: mongoose.SchemaTypes.Number,\n        conditional: {\n          type: mongoose.SchemaTypes.String,\n          required: function() {\n            return this.type === 1;\n          },\n          maxlength: 128\n        }\n      });\n\n      const Model = db.model('Test', schema);\n\n      assert.doesNotThrow(function() {\n        new Model({\n          type: 2,\n          conditional: void 0\n        }).validateSync();\n      });\n    });\n\n    it('conditional required on single nested (gh-4663)', function() {\n      const childSchema = new Schema({\n        name: String\n      });\n      const schema = new Schema({\n        child: {\n          type: childSchema,\n          required: function() {\n            assert.equal(this.child.name, 'test');\n          }\n        }\n      });\n\n      const M = db.model('Test', schema);\n\n      const err = new M({ child: { name: 'test' } }).validateSync();\n      assert.ifError(err);\n    });\n\n    it('setting full path under single nested schema works (gh-4578) (gh-4528)', function(done) {\n      const ChildSchema = new mongoose.Schema({\n        age: Number\n      });\n\n      const ParentSchema = new mongoose.Schema({\n        age: Number,\n        family: {\n          child: ChildSchema\n        }\n      });\n\n      const M = db.model('Test', ParentSchema);\n\n      M.create({ age: 45 }, function(error, doc) {\n        assert.ifError(error);\n        assert.ok(!doc.family.child);\n        doc.set('family.child.age', 15);\n        assert.ok(doc.family.child.schema);\n        assert.ok(doc.isModified('family.child'));\n        assert.ok(doc.isModified('family.child.age'));\n        assert.equal(doc.family.child.toObject().age, 15);\n        done();\n      });\n    });\n\n    it('setting a nested path retains nested modified paths (gh-5206)', async function() {\n      const testSchema = new mongoose.Schema({\n        name: String,\n        surnames: {\n          docarray: [{ name: String }]\n        }\n      });\n\n      const Cat = db.model('Cat', testSchema);\n\n      const kitty = new Cat({\n        name: 'Test',\n        surnames: {\n          docarray: [{ name: 'test1' }, { name: 'test2' }]\n        }\n      });\n\n      await kitty.save();\n\n      kitty.surnames = {\n        docarray: [{ name: 'test1' }, { name: 'test2' }, { name: 'test3' }]\n      };\n\n      assert.deepEqual(\n        kitty.modifiedPaths(),\n        ['surnames', 'surnames.docarray']\n      );\n    });\n\n    it('toObject() does not depopulate top level (gh-3057)', function() {\n      const Cat = db.model('Cat', { name: String });\n      const Human = db.model('Person', {\n        name: String,\n        petCat: { type: mongoose.Schema.Types.ObjectId, ref: 'Cat' }\n      });\n\n      const kitty = new Cat({ name: 'Zildjian' });\n      const person = new Human({ name: 'Val', petCat: kitty });\n\n      assert.equal(kitty.toObject({ depopulate: true }).name, 'Zildjian');\n      assert.ok(!person.toObject({ depopulate: true }).petCat.name);\n    });\n\n    it('toObject() respects schema-level depopulate (gh-6313)', function() {\n      const personSchema = Schema({\n        name: String,\n        car: {\n          type: Schema.Types.ObjectId,\n          ref: 'Car'\n        }\n      });\n\n      personSchema.set('toObject', {\n        depopulate: true\n      });\n\n      const carSchema = Schema({\n        name: String\n      });\n\n      const Car = db.model('Car', carSchema);\n      const Person = db.model('Person', personSchema);\n\n      const car = new Car({\n        name: 'Ford'\n      });\n\n      const person = new Person({\n        name: 'John',\n        car: car\n      });\n\n      assert.equal(person.toObject().car.toHexString(), car._id.toHexString());\n    });\n\n    it('single nested doc conditional required (gh-4654)', function(done) {\n      const ProfileSchema = new Schema({\n        firstName: String,\n        lastName: String\n      });\n\n      function validator() {\n        assert.equal(this.email, 'test');\n        return true;\n      }\n\n      const UserSchema = new Schema({\n        email: String,\n        profile: {\n          type: ProfileSchema,\n          required: [validator, 'profile required']\n        }\n      });\n\n      const User = db.model('User', UserSchema);\n      User.create({ email: 'test' }, function(error) {\n        assert.equal(error.errors['profile'].message, 'profile required');\n        done();\n      });\n    });\n\n    it('handles setting single nested schema to equal value (gh-4676)', function(done) {\n      const companySchema = new mongoose.Schema({\n        _id: false,\n        name: String,\n        description: String\n      });\n\n      const userSchema = new mongoose.Schema({\n        name: String,\n        company: companySchema\n      });\n\n      const User = db.model('User', userSchema);\n\n      const user = new User({ company: { name: 'Test' } });\n      user.save(function(error) {\n        assert.ifError(error);\n        user.company.description = 'test';\n        assert.ok(user.isModified('company'));\n        user.company = user.company;\n        assert.ok(user.isModified('company'));\n        done();\n      });\n    });\n\n    it('handles setting single nested doc to null after setting (gh-4766)', function(done) {\n      const EntitySchema = new Schema({\n        company: {\n          type: String,\n          required: true\n        },\n        name: {\n          type: String,\n          required: false\n        },\n        email: {\n          type: String,\n          required: false\n        }\n      }, { _id: false, id: false });\n\n      const ShipmentSchema = new Schema({\n        entity: {\n          shipper: {\n            type: EntitySchema,\n            required: false\n          },\n          manufacturer: {\n            type: EntitySchema,\n            required: false\n          }\n        }\n      });\n\n      const Shipment = db.model('Test', ShipmentSchema);\n      const doc = new Shipment({\n        entity: {\n          shipper: null,\n          manufacturer: {\n            company: 'test',\n            name: 'test',\n            email: 'test@email'\n          }\n        }\n      });\n\n      doc.save().\n        then(function() { return Shipment.findById(doc._id); }).\n        then(function(shipment) {\n          shipment.entity = shipment.entity;\n          shipment.entity.manufacturer = null;\n          return shipment.save();\n        }).\n        then(function() {\n          done();\n        }).\n        catch(done);\n    });\n\n    it('buffers with subtypes as ids (gh-4506)', function(done) {\n      const uuid = require('uuid');\n\n      const UserSchema = new mongoose.Schema({\n        _id: {\n          type: Buffer,\n          default: function() {\n            return mongoose.Types.Buffer(uuid.parse(uuid.v4())).toObject(4);\n          },\n          required: true\n        },\n        email: {\n          type: String,\n          lowercase: true,\n          required: true\n        },\n        name: String\n      });\n\n      const User = db.model('User', UserSchema);\n\n      const user = new User({\n        email: 'me@email.com',\n        name: 'My name'\n      });\n\n      user.save().\n        then(function() {\n          return User.findOne({ email: 'me@email.com' });\n        }).\n        then(function(user) {\n          user.name = 'other';\n          return user.save();\n        }).\n        then(function() {\n          return User.findOne({ email: 'me@email.com' });\n        }).\n        then(function(doc) {\n          assert.equal(doc.name, 'other');\n          done();\n        }).\n        catch(done);\n    });\n\n    it('embedded docs dont mark parent as invalid (gh-4681)', function(done) {\n      const NestedSchema = new mongoose.Schema({\n        nestedName: { type: String, required: true },\n        createdAt: { type: Date, required: true }\n      });\n      const RootSchema = new mongoose.Schema({\n        rootName: String,\n        nested: { type: [NestedSchema] }\n      });\n\n      const Root = db.model('Test', RootSchema);\n      const root = new Root({ rootName: 'root', nested: [{ }] });\n      root.save(function(error) {\n        assert.ok(error);\n        assert.deepEqual(Object.keys(error.errors).sort(),\n          ['nested.0.createdAt', 'nested.0.nestedName']);\n        done();\n      });\n    });\n\n    it('should depopulate the shard key when saving (gh-4658)', function(done) {\n      const ChildSchema = new mongoose.Schema({\n        name: String\n      });\n\n      const ChildModel = db.model('Child', ChildSchema);\n\n      const ParentSchema = new mongoose.Schema({\n        name: String,\n        child: { type: Schema.Types.ObjectId, ref: 'Child' }\n      }, { shardKey: { child: 1, _id: 1 } });\n\n      const ParentModel = db.model('Parent', ParentSchema);\n\n      ChildModel.create({ name: 'Luke' }).\n        then(function(child) {\n          const p = new ParentModel({ name: 'Vader' });\n          p.child = child;\n          return p.save();\n        }).\n        then(function(p) {\n          p.name = 'Anakin';\n          return p.save();\n        }).\n        then(function(p) {\n          return ParentModel.findById(p);\n        }).\n        then(function(doc) {\n          assert.equal(doc.name, 'Anakin');\n          done();\n        }).\n        catch(done);\n    });\n\n    it('handles setting virtual subpaths (gh-4716)', function() {\n      const childSchema = new Schema({\n        name: { type: String, default: 'John' },\n        favorites: {\n          color: {\n            type: String,\n            default: 'Blue'\n          }\n        }\n      });\n\n      const parentSchema = new Schema({\n        name: { type: String },\n        children: {\n          type: [childSchema],\n          default: [{}]\n        }\n      });\n\n      parentSchema.virtual('favorites').set(function(v) {\n        return this.children[0].set('favorites', v);\n      }).get(function() {\n        return this.children[0].get('favorites');\n      });\n\n      const Parent = db.model('Parent', parentSchema);\n      const p = new Parent({ name: 'Anakin' });\n      p.set('children.0.name', 'Leah');\n      p.set('favorites.color', 'Red');\n      assert.equal(p.children[0].favorites.color, 'Red');\n    });\n\n    it('handles selected nested elements with defaults (gh-4739) (gh-11376)', async function() {\n      const userSchema = new Schema({\n        preferences: {\n          sleep: { type: Boolean, default: false },\n          test: { type: Boolean, default: true }\n        },\n        arr: [{ test: Number, test2: Number }],\n        name: String\n      });\n\n      const User = db.model('User', userSchema);\n\n      let user = { name: 'test' };\n      await User.collection.insertOne(user);\n      user = await User.findById(user, { 'preferences.sleep': 1, name: 1 });\n      assert.strictEqual(user.preferences.sleep, false);\n      assert.ok(!user.preferences.test);\n\n      user = await User.findById(user, { 'arr.test': 1 });\n      assert.strictEqual(user.name, undefined);\n      assert.strictEqual(user.toObject().preferences, undefined);\n      assert.deepEqual(user.toObject().arr, []);\n    });\n\n    it('handles mark valid in subdocs correctly (gh-4778)', function() {\n      const SubSchema = new mongoose.Schema({\n        field: {\n          nestedField: {\n            type: mongoose.Schema.ObjectId,\n            required: false\n          }\n        }\n      }, { _id: false, id: false });\n\n      const Model2Schema = new mongoose.Schema({\n        sub: {\n          type: SubSchema,\n          required: false\n        }\n      });\n      const Model2 = db.model('Test', Model2Schema);\n\n      const doc = new Model2({\n        sub: {}\n      });\n\n      doc.sub.field.nestedField = { };\n      doc.sub.field.nestedField = '574b69d0d9daf106aaa62974';\n      assert.ok(!doc.validateSync());\n    });\n\n    it('timestamps set to false works (gh-7074)', async function() {\n      const schema = new Schema({ name: String }, { timestamps: false });\n      const Test = db.model('Test', schema);\n\n      const doc = await Test.create({ name: 'test' });\n      assert.strictEqual(doc.updatedAt, undefined);\n      assert.strictEqual(doc.createdAt, undefined);\n    });\n\n    it('timestamps with nested paths (gh-5051)', function(done) {\n      const schema = new Schema({ props: {} }, {\n        timestamps: {\n          createdAt: 'props.createdAt',\n          updatedAt: 'props.updatedAt'\n        }\n      });\n\n      const M = db.model('Test', schema);\n      const now = Date.now();\n      M.create({}, function(error, doc) {\n        assert.ok(doc.props.createdAt);\n        assert.ok(doc.props.createdAt instanceof Date);\n        assert.ok(doc.props.createdAt.valueOf() >= now);\n        assert.ok(doc.props.updatedAt);\n        assert.ok(doc.props.updatedAt instanceof Date);\n        assert.ok(doc.props.updatedAt.valueOf() >= now);\n        done();\n      });\n    });\n\n    it('Declaring defaults in your schema with timestamps defined (gh-6024)', function() {\n      const schemaDefinition = {\n        name: String,\n        misc: {\n          hometown: String,\n          isAlive: { type: Boolean, default: true }\n        }\n      };\n\n      const schemaWithTimestamps = new Schema(schemaDefinition, { timestamps: { createdAt: 'misc.createdAt' } });\n      const PersonWithTimestamps = db.model('Person', schemaWithTimestamps);\n      const dude = new PersonWithTimestamps({ name: 'Keanu', misc: { hometown: 'Beirut' } });\n      assert.equal(dude.misc.isAlive, true);\n    });\n\n    it('supports $where in pre save hook (gh-4004)', function(done) {\n      const Promise = global.Promise;\n\n      const schema = new Schema({\n        name: String\n      }, { timestamps: true, versionKey: null });\n\n      schema.pre('save', function(next) {\n        this.$where = { updatedAt: this.updatedAt };\n        next();\n      });\n\n      schema.post('save', function(error, res, next) {\n        assert.ok(error instanceof MongooseError.DocumentNotFoundError);\n        assert.ok(error.message.indexOf('Test') !== -1, error.message);\n\n        error = new Error('Somebody else updated the document!');\n        next(error);\n      });\n\n      const MyModel = db.model('Test', schema);\n\n      MyModel.create({ name: 'test' }).\n        then(function() {\n          return Promise.all([\n            MyModel.findOne(),\n            MyModel.findOne()\n          ]);\n        }).\n        then(function(docs) {\n          docs[0].name = 'test2';\n          return Promise.all([\n            docs[0].save(),\n            Promise.resolve(docs[1])\n          ]);\n        }).\n        then(function(docs) {\n          docs[1].name = 'test3';\n          return docs[1].save();\n        }).\n        then(function() {\n          done(new Error('Should not get here'));\n        }).\n        catch(function(error) {\n          assert.equal(error.message, 'Somebody else updated the document!');\n          done();\n        });\n    });\n\n    it('toObject() with buffer and minimize (gh-4800)', function(done) {\n      const TestSchema = new mongoose.Schema({ buf: Buffer }, {\n        toObject: {\n          virtuals: true,\n          getters: true\n        }\n      });\n\n      const Test = db.model('Test', TestSchema);\n\n      Test.create({ buf: Buffer.from('abcd') }).\n        then(function(doc) {\n          return Test.findById(doc._id);\n        }).\n        then(function(doc) {\n          assert.doesNotThrow(function() {\n            require('util').inspect(doc);\n          });\n          done();\n        }).\n        catch(done);\n    });\n\n    it('buffer subtype prop (gh-5530)', function() {\n      const TestSchema = new mongoose.Schema({\n        uuid: {\n          type: Buffer,\n          subtype: 4\n        }\n      });\n\n      const Test = db.model('Test', TestSchema);\n\n      const doc = new Test({ uuid: 'test1' });\n      assert.equal(doc.uuid._subtype, 4);\n    });\n\n    it('runs validate hooks on single nested subdocs if not directly modified (gh-3884)', function(done) {\n      const childSchema = new Schema({\n        name: { type: String },\n        friends: [{ type: String }]\n      });\n      let count = 0;\n\n      childSchema.pre('validate', function(next) {\n        ++count;\n        next();\n      });\n\n      const parentSchema = new Schema({\n        name: { type: String },\n        child: childSchema\n      });\n\n      const Parent = db.model('Parent', parentSchema);\n\n      const p = new Parent({\n        name: 'Mufasa',\n        child: {\n          name: 'Simba',\n          friends: ['Pumbaa', 'Timon', 'Nala']\n        }\n      });\n\n      p.save().\n        then(function(p) {\n          assert.equal(count, 1);\n          p.child.friends.push('Rafiki');\n          return p.save();\n        }).\n        then(function() {\n          assert.equal(count, 2);\n          done();\n        }).\n        catch(done);\n    });\n\n    it('runs validate hooks on arrays subdocs if not directly modified (gh-5861)', function(done) {\n      const childSchema = new Schema({\n        name: { type: String },\n        friends: [{ type: String }]\n      });\n      let count = 0;\n\n      childSchema.pre('validate', function(next) {\n        ++count;\n        next();\n      });\n\n      const parentSchema = new Schema({\n        name: { type: String },\n        children: [childSchema]\n      });\n\n      const Parent = db.model('Parent', parentSchema);\n\n      const p = new Parent({\n        name: 'Mufasa',\n        children: [{\n          name: 'Simba',\n          friends: ['Pumbaa', 'Timon', 'Nala']\n        }]\n      });\n\n      p.save().\n        then(function(p) {\n          assert.equal(count, 1);\n          p.children[0].friends.push('Rafiki');\n          return p.save();\n        }).\n        then(function() {\n          assert.equal(count, 2);\n          done();\n        }).\n        catch(done);\n    });\n\n    it('does not run schema type validator on single nested if not direct modified (gh-5885)', async function() {\n      let childValidateCalls = 0;\n      const childSchema = new Schema({\n        name: String,\n        otherProp: {\n          type: String,\n          validate: () => {\n            ++childValidateCalls;\n            return true;\n          }\n        }\n      });\n\n      let validateCalls = 0;\n      const parentSchema = new Schema({\n        child: {\n          type: childSchema,\n          validate: () => {\n            ++validateCalls;\n            return true;\n          }\n        }\n      });\n\n\n      const Parent = db.model('Parent', parentSchema);\n\n      const doc = await Parent.create({\n        child: {\n          name: 'test',\n          otherProp: 'test'\n        }\n      });\n\n      assert.equal(childValidateCalls, 1);\n      assert.equal(validateCalls, 1);\n      childValidateCalls = 0;\n      validateCalls = 0;\n\n      doc.set('child.name', 'test2');\n      await doc.validate();\n\n      assert.equal(childValidateCalls, 0);\n      assert.equal(validateCalls, 0);\n    });\n\n    it('runs schema type validator on single nested if parent has default (gh-7493)', function() {\n      const childSchema = new Schema({\n        test: String\n      });\n      const parentSchema = new Schema({\n        child: {\n          type: childSchema,\n          default: {},\n          validate: () => false\n        }\n      });\n      const Parent = db.model('Test', parentSchema);\n\n      const parentDoc = new Parent({});\n\n      parentDoc.child.test = 'foo';\n\n      const err = parentDoc.validateSync();\n      assert.ok(err);\n      assert.ok(err.errors['child']);\n      return Promise.resolve();\n    });\n\n    it('does not overwrite when setting nested (gh-4793)', function() {\n      const grandchildSchema = new mongoose.Schema();\n      grandchildSchema.method({\n        foo: function() { return 'bar'; }\n      });\n      const Grandchild = db.model('Test', grandchildSchema);\n\n      const childSchema = new mongoose.Schema({\n        grandchild: grandchildSchema\n      });\n      const Child = db.model('Child', childSchema);\n\n      const parentSchema = new mongoose.Schema({\n        children: [childSchema]\n      });\n      const Parent = db.model('Parent', parentSchema);\n\n      const grandchild = new Grandchild();\n      const child = new Child({ grandchild: grandchild });\n\n      assert.equal(child.grandchild.foo(), 'bar');\n\n      const p = new Parent({ children: [child] });\n\n      assert.equal(child.grandchild.foo(), 'bar');\n      assert.equal(p.children[0].grandchild.foo(), 'bar');\n    });\n\n    it('hooks/middleware for custom methods (gh-6385) (gh-7456)', async function() {\n      const mySchema = new Schema({\n        name: String\n      });\n\n      mySchema.methods.foo = function(cb) {\n        return cb(null, this.name);\n      };\n      mySchema.methods.bar = function() {\n        return this.name;\n      };\n      mySchema.methods.baz = function(arg) {\n        return Promise.resolve(arg);\n      };\n\n      let preFoo = 0;\n      let postFoo = 0;\n      mySchema.pre('foo', function() {\n        ++preFoo;\n      });\n      mySchema.post('foo', function() {\n        ++postFoo;\n      });\n\n      let preBaz = 0;\n      let postBaz = 0;\n      mySchema.pre('baz', function() {\n        ++preBaz;\n      });\n      mySchema.post('baz', function() {\n        ++postBaz;\n      });\n\n      const MyModel = db.model('Test', mySchema);\n\n\n      const doc = new MyModel({ name: 'test' });\n\n      assert.equal(doc.bar(), 'test');\n\n      assert.equal(preFoo, 0);\n      assert.equal(postFoo, 0);\n\n      const fooResult = await doc.foo();\n      assert.equal(fooResult, 'test');\n      assert.equal(preFoo, 1);\n      assert.equal(postFoo, 1);\n\n      assert.equal(preBaz, 0);\n      assert.equal(postBaz, 0);\n\n      assert.equal(await doc.baz('foobar'), 'foobar');\n      assert.equal(preBaz, 1);\n      assert.equal(preBaz, 1);\n    });\n\n    it('custom methods with promises (gh-6385)', async function() {\n      const mySchema = new Schema({\n        name: String\n      });\n\n      mySchema.methods.foo = function() {\n        return Promise.resolve(this.name + ' foo');\n      };\n      mySchema.methods.bar = function() {\n        return this.name + ' bar';\n      };\n\n      let preFoo = 0;\n      let preBar = 0;\n      mySchema.pre('foo', function() {\n        ++preFoo;\n      });\n      mySchema.pre('bar', function() {\n        ++preBar;\n      });\n\n      const MyModel = db.model('Test', mySchema);\n\n\n      const doc = new MyModel({ name: 'test' });\n\n      assert.equal(preFoo, 0);\n      assert.equal(preBar, 0);\n\n      let foo = doc.foo();\n      let bar = doc.bar();\n      assert.ok(foo instanceof Promise);\n      assert.ok(bar instanceof Promise);\n\n      foo = await foo;\n      bar = await bar;\n\n      assert.equal(preFoo, 1);\n      assert.equal(preBar, 1);\n      assert.equal(foo, 'test foo');\n      assert.equal(bar, 'test bar');\n    });\n\n    it('toString() as custom method (gh-6538)', function() {\n      const commentSchema = new Schema({ title: String });\n      commentSchema.methods.toString = function() {\n        return `${this.constructor.modelName}(${this.title})`;\n      };\n      const Comment = db.model('Comment', commentSchema);\n      const c = new Comment({ title: 'test' });\n      assert.strictEqual('Comment(test)', `${c}`);\n    });\n\n    it('setting to discriminator (gh-4935)', function() {\n      const Buyer = db.model('Test1', new Schema({\n        name: String,\n        vehicle: { type: Schema.Types.ObjectId, ref: 'Test' }\n      }));\n      const Vehicle = db.model('Test', new Schema({ name: String }));\n      const Car = Vehicle.discriminator('gh4935_1', new Schema({\n        model: String\n      }));\n\n      const eleanor = new Car({ name: 'Eleanor', model: 'Shelby Mustang GT' });\n      const nick = new Buyer({ name: 'Nicolas', vehicle: eleanor });\n\n      assert.ok(!!nick.vehicle);\n      assert.ok(nick.vehicle === eleanor);\n      assert.ok(nick.vehicle instanceof Car);\n      assert.equal(nick.vehicle.name, 'Eleanor');\n    });\n\n    it('handles errors in sync validators (gh-2185)', function(done) {\n      const schema = new Schema({\n        name: {\n          type: String,\n          validate: function() {\n            throw new Error('woops!');\n          }\n        }\n      });\n\n      const M = db.model('Test', schema);\n\n      const error = (new M({ name: 'test' })).validateSync();\n      assert.ok(error);\n      assert.equal(error.errors['name'].reason.message, 'woops!');\n\n      new M({ name: 'test' }).validate(function(error) {\n        assert.ok(error);\n        assert.equal(error.errors['name'].reason.message, 'woops!');\n        done();\n      });\n    });\n\n    it('allows hook as a schema key (gh-5047)', function(done) {\n      const schema = new mongoose.Schema({\n        name: String,\n        hook: { type: String }\n      });\n\n      const Model = db.model('Test', schema);\n\n      Model.create({ hook: 'test ' }, function(error) {\n        assert.ifError(error);\n        done();\n      });\n    });\n\n    it('save errors with callback and promise work (gh-5216)', function(done) {\n      const schema = new mongoose.Schema({});\n\n      const Model = db.model('Test', schema);\n\n      const _id = new mongoose.Types.ObjectId();\n      const doc1 = new Model({ _id: _id });\n      const doc2 = new Model({ _id: _id });\n\n      let remaining = 2;\n      Model.on('error', function(error) {\n        assert.ok(error);\n        --remaining || done();\n      });\n\n      doc1.save().\n        then(function() { return doc2.save(); }).\n        catch(function(error) {\n          assert.ok(error);\n          --remaining || done();\n        });\n    });\n\n    it('post hooks on child subdocs run after save (gh-5085)', function(done) {\n      const ChildModelSchema = new mongoose.Schema({\n        text: {\n          type: String\n        }\n      });\n      ChildModelSchema.post('save', function(doc) {\n        doc.text = 'bar';\n      });\n      const ParentModelSchema = new mongoose.Schema({\n        children: [ChildModelSchema]\n      });\n\n      const Model = db.model('Parent', ParentModelSchema);\n\n      Model.create({ children: [{ text: 'test' }] }, function(error) {\n        assert.ifError(error);\n        Model.findOne({}, function(error, doc) {\n          assert.ifError(error);\n          assert.equal(doc.children.length, 1);\n          assert.equal(doc.children[0].text, 'test');\n          done();\n        });\n      });\n    });\n\n    it('post hooks on array child subdocs run after save (gh-5085) (gh-6926)', function() {\n      const subSchema = new Schema({\n        val: String\n      });\n\n      subSchema.post('save', function() {\n        return Promise.reject(new Error('Oops'));\n      });\n\n      const schema = new Schema({\n        sub: subSchema\n      });\n\n      const Test = db.model('Test', schema);\n\n      const test = new Test({ sub: { val: 'test' } });\n\n      return test.save().\n        then(() => assert.ok(false), err => assert.equal(err.message, 'Oops')).\n        then(() => Test.findOne()).\n        then(doc => assert.equal(doc.sub.val, 'test'));\n    });\n\n    it('nested docs toObject() clones (gh-5008)', function() {\n      const schema = new mongoose.Schema({\n        sub: {\n          height: Number\n        }\n      });\n\n      const Model = db.model('Test', schema);\n\n      const doc = new Model({\n        sub: {\n          height: 3\n        }\n      });\n\n      assert.equal(doc.sub.height, 3);\n\n      const leanDoc = doc.sub.toObject();\n      assert.equal(leanDoc.height, 3);\n\n      doc.sub.height = 55;\n      assert.equal(doc.sub.height, 55);\n      assert.equal(leanDoc.height, 3);\n    });\n\n    it('toObject() with null (gh-5143)', function() {\n      const schema = new mongoose.Schema({\n        customer: {\n          name: { type: String, required: false }\n        }\n      });\n\n      const Model = db.model('Test', schema);\n\n      const model = new Model();\n      model.customer = null;\n      assert.strictEqual(model.toObject().customer, null);\n      assert.strictEqual(model.toObject({ getters: true }).customer, null);\n    });\n\n    it('handles array subdocs with single nested subdoc default (gh-5162)', function() {\n      const RatingsItemSchema = new mongoose.Schema({\n        value: Number\n      }, { versionKey: false, _id: false });\n\n      const RatingsSchema = new mongoose.Schema({\n        ratings: {\n          type: RatingsItemSchema,\n          default: { id: 1, value: 0 }\n        },\n        _id: false\n      });\n\n      const RestaurantSchema = new mongoose.Schema({\n        menu: {\n          type: [RatingsSchema]\n        }\n      });\n\n      const Restaurant = db.model('Test', RestaurantSchema);\n\n      // Should not throw\n      const r = new Restaurant();\n      assert.deepEqual(r.toObject().menu, []);\n    });\n\n    it('iterating through nested doc keys (gh-5078)', function() {\n      const schema = new Schema({\n        nested: {\n          test1: String,\n          test2: String\n        }\n      });\n\n      schema.virtual('tests').get(function() {\n        return Object.values(this.nested);\n      });\n\n      const M = db.model('Test', schema);\n\n      const doc = new M({ nested: { test1: 'a', test2: 'b' } });\n\n      assert.deepEqual(doc.toObject({ virtuals: true }).tests, ['a', 'b']);\n\n      assert.doesNotThrow(function() {\n        require('util').inspect(doc);\n      });\n      JSON.stringify(doc);\n    });\n\n    it('deeply nested virtual paths (gh-5250)', function() {\n      const TestSchema = new Schema({});\n      TestSchema.\n        virtual('a.b.c').\n        get(function() {\n          return this.v;\n        }).\n        set(function(value) {\n          this.v = value;\n        });\n\n      const TestModel = db.model('Test', TestSchema);\n      const t = new TestModel({ 'a.b.c': 5 });\n      assert.equal(t.a.b.c, 5);\n    });\n\n    it('nested virtual when populating with parent projected out (gh-7491)', async function() {\n      const childSchema = Schema({\n        _id: Number,\n        nested: { childPath: String },\n        otherPath: String\n      }, { toObject: { virtuals: true } });\n\n      childSchema.virtual('nested.childVirtual').get(() => true);\n\n      const parentSchema = Schema({\n        child: { type: Number, ref: 'Child' }\n      }, { toObject: { virtuals: true } });\n\n      parentSchema.virtual('_nested').get(function() {\n        return this.child.nested;\n      });\n\n      const Child = db.model('Child', childSchema);\n      const Parent = db.model('Parent', parentSchema);\n\n\n      await Child.create({\n        _id: 1,\n        nested: { childPath: 'foo' },\n        otherPath: 'bar'\n      });\n      await Parent.create({ child: 1 });\n\n      const doc = await Parent.findOne().populate('child', 'otherPath').\n        then(doc => doc.toObject());\n\n      assert.ok(!doc.child.nested.childPath);\n    });\n\n    it('JSON.stringify nested errors (gh-5208)', function(done) {\n      const AdditionalContactSchema = new Schema({\n        contactName: {\n          type: String,\n          required: true\n        },\n        contactValue: {\n          type: String,\n          required: true\n        }\n      });\n\n      const ContactSchema = new Schema({\n        name: {\n          type: String,\n          required: true\n        },\n        email: {\n          type: String,\n          required: true\n        },\n        additionalContacts: [AdditionalContactSchema]\n      });\n\n      const EmergencyContactSchema = new Schema({\n        contactName: {\n          type: String,\n          required: true\n        },\n        contact: ContactSchema\n      });\n\n      const EmergencyContact = db.model('Test', EmergencyContactSchema);\n\n      const contact = new EmergencyContact({\n        contactName: 'Electrical Service',\n        contact: {\n          name: 'John Smith',\n          email: 'john@gmail.com',\n          additionalContacts: [\n            {\n              contactName: 'skype'\n              // Forgotten value\n            }\n          ]\n        }\n      });\n      contact.validate(function(error) {\n        assert.ok(error);\n        assert.ok(error.errors['contact.additionalContacts.0.contactValue']);\n\n        // This `JSON.stringify()` should not throw\n        assert.ok(JSON.stringify(error).indexOf('contactValue') !== -1);\n        done();\n      });\n    });\n\n    it('handles errors in subdoc pre validate (gh-5215)', function(done) {\n      const childSchema = new mongoose.Schema({});\n\n      childSchema.pre('validate', function(next) {\n        next(new Error('child pre validate'));\n      });\n\n      const parentSchema = new mongoose.Schema({\n        child: childSchema\n      });\n\n      const Parent = db.model('Parent', parentSchema);\n\n      Parent.create({ child: {} }, function(error) {\n        assert.ok(error);\n        assert.ok(error.errors['child']);\n        assert.equal(error.errors['child'].message, 'child pre validate');\n        done();\n      });\n    });\n\n    it('custom error types (gh-4009)', function(done) {\n      const CustomError = function() {};\n\n      const testSchema = new mongoose.Schema({\n        num: {\n          type: Number,\n          required: {\n            ErrorConstructor: CustomError\n          },\n          min: 5\n        }\n      });\n\n      const Test = db.model('Test', testSchema);\n\n      Test.create({}, function(error) {\n        assert.ok(error);\n        assert.ok(error.errors['num']);\n        assert.ok(error.errors['num'] instanceof CustomError);\n        Test.create({ num: 1 }, function(error) {\n          assert.ok(error);\n          assert.ok(error.errors['num']);\n          assert.ok(error.errors['num'].constructor.name, 'ValidatorError');\n          assert.ok(!(error.errors['num'] instanceof CustomError));\n          done();\n        });\n      });\n    });\n\n    it('saving a doc with nested string array (gh-5282)', function(done) {\n      const testSchema = new mongoose.Schema({\n        strs: [[String]]\n      });\n\n      const Test = db.model('Test', testSchema);\n\n      const t = new Test({\n        strs: [['a', 'b']]\n      });\n\n      t.save(function(error, t) {\n        assert.ifError(error);\n        assert.deepEqual(t.toObject().strs, [['a', 'b']]);\n        done();\n      });\n    });\n\n    it('push() onto a nested doc array (gh-6398)', async function() {\n      const schema = new mongoose.Schema({\n        name: String,\n        array: [[{ key: String, value: Number }]]\n      });\n\n      const Model = db.model('Test', schema);\n\n\n      await Model.create({\n        name: 'small',\n        array: [[{ key: 'answer', value: 42 }]]\n      });\n\n      let doc = await Model.findOne();\n\n      assert.ok(doc);\n      doc.array[0].push({ key: 'lucky', value: 7 });\n\n      await doc.save();\n\n      doc = await Model.findOne();\n      assert.equal(doc.array.length, 1);\n      assert.equal(doc.array[0].length, 2);\n      assert.equal(doc.array[0][1].key, 'lucky');\n    });\n\n    it('push() onto a triple nested doc array (gh-6602) (gh-6398)', async function() {\n      const schema = new mongoose.Schema({\n        array: [[[{ key: String, value: Number }]]]\n      });\n\n      const Model = db.model('Test', schema);\n\n\n      await Model.create({\n        array: [[[{ key: 'answer', value: 42 }]]]\n      });\n\n      let doc = await Model.findOne();\n\n      assert.ok(doc);\n      doc.array[0][0].push({ key: 'lucky', value: 7 });\n\n      await doc.save();\n\n      doc = await Model.findOne();\n      assert.equal(doc.array.length, 1);\n      assert.equal(doc.array[0].length, 1);\n      assert.equal(doc.array[0][0].length, 2);\n      assert.equal(doc.array[0][0][1].key, 'lucky');\n    });\n\n    it('null _id (gh-5236)', function(done) {\n      const childSchema = new mongoose.Schema({});\n\n      const M = db.model('Test', childSchema);\n\n      const m = new M({ _id: null });\n      m.save(function(error, doc) {\n        assert.equal(doc._id, null);\n        done();\n      });\n    });\n\n    it('setting populated path with typeKey (gh-5313)', function() {\n      const personSchema = Schema({\n        name: { $type: String },\n        favorite: { $type: Schema.Types.ObjectId, ref: 'Book' },\n        books: [{ $type: Schema.Types.ObjectId, ref: 'Book' }]\n      }, { typeKey: '$type' });\n\n      const bookSchema = Schema({\n        title: String\n      });\n\n      const Book = db.model('Book', bookSchema);\n      const Person = db.model('Person', personSchema);\n\n      const book1 = new Book({ title: 'The Jungle Book' });\n      const book2 = new Book({ title: '1984' });\n\n      const person = new Person({\n        name: 'Bob',\n        favorite: book1,\n        books: [book1, book2]\n      });\n\n      assert.equal(person.books[0].title, 'The Jungle Book');\n      assert.equal(person.books[1].title, '1984');\n    });\n\n    it('save twice with write concern (gh-5294)', function(done) {\n      const schema = new mongoose.Schema({\n        name: String\n      }, {\n        w: 'majority',\n        wtimeout: 1e4\n      });\n\n      const M = db.model('Test', schema);\n\n      M.create({ name: 'Test' }, function(error, doc) {\n        assert.ifError(error);\n        doc.name = 'test2';\n        doc.save(function(error) {\n          assert.ifError(error);\n          done();\n        });\n      });\n    });\n\n    it('undefined field with conditional required (gh-5296)', function(done) {\n      const schema = Schema({\n        name: {\n          type: String,\n          maxlength: 63,\n          required: function() {\n            return false;\n          }\n        }\n      });\n\n      const Model = db.model('Test', schema);\n\n      Model.create({ name: undefined }, function(error) {\n        assert.ifError(error);\n        done();\n      });\n    });\n\n    it('dotted virtuals in toObject (gh-5473)', function() {\n      const schema = new mongoose.Schema({}, {\n        toObject: { virtuals: true },\n        toJSON: { virtuals: true }\n      });\n      schema.virtual('test.a').get(function() {\n        return 1;\n      });\n      schema.virtual('test.b').get(function() {\n        return 2;\n      });\n\n      const Model = db.model('Test', schema);\n\n      const m = new Model({});\n      assert.deepEqual(m.toJSON().test, {\n        a: 1,\n        b: 2\n      });\n      assert.deepEqual(m.toObject().test, {\n        a: 1,\n        b: 2\n      });\n      assert.equal(m.toObject({ virtuals: false }).test, void 0);\n    });\n\n    it('dotted virtuals in toObject (gh-5506)', function(done) {\n      const childSchema = new Schema({\n        name: String,\n        _id: false\n      });\n      const parentSchema = new Schema({\n        child: {\n          type: childSchema,\n          default: {}\n        }\n      });\n\n      const Parent = db.model('Parent', parentSchema);\n\n      const p = new Parent({ child: { name: 'myName' } });\n\n      p.save().\n        then(function() {\n          return Parent.findOne();\n        }).\n        then(function(doc) {\n          doc.child = {};\n          return doc.save();\n        }).\n        then(function() {\n          return Parent.findOne();\n        }).\n        then(function(doc) {\n          assert.deepEqual(doc.toObject({ minimize: false }).child, {});\n          done();\n        }).\n        catch(done);\n    });\n\n    it('parent props not in child (gh-5470)', function() {\n      const employeeSchema = new mongoose.Schema({\n        name: {\n          first: String,\n          last: String\n        },\n        department: String\n      });\n      const Employee = db.model('Test', employeeSchema);\n\n      const employee = new Employee({\n        name: {\n          first: 'Ron',\n          last: 'Swanson'\n        },\n        department: 'Parks and Recreation'\n      });\n      const ownPropertyNames = Object.getOwnPropertyNames(employee.name);\n\n      assert.ok(ownPropertyNames.indexOf('department') === -1, ownPropertyNames.join(','));\n      assert.ok(ownPropertyNames.indexOf('first') !== -1, ownPropertyNames.join(','));\n      assert.ok(ownPropertyNames.indexOf('last') !== -1, ownPropertyNames.join(','));\n    });\n\n    it('modifying array with existing ids (gh-5523)', function(done) {\n      const friendSchema = new mongoose.Schema(\n        {\n          _id: String,\n          name: String,\n          age: Number,\n          dob: Date\n        },\n        { _id: false });\n\n      const socialSchema = new mongoose.Schema(\n        {\n          friends: [friendSchema]\n        },\n        { _id: false });\n\n      const userSchema = new mongoose.Schema({\n        social: {\n          type: socialSchema,\n          required: true\n        }\n      });\n\n      const User = db.model('User', userSchema);\n\n      const user = new User({\n        social: {\n          friends: [\n            { _id: 'val', age: 28 }\n          ]\n        }\n      });\n\n      user.social.friends = [{ _id: 'val', name: 'Val' }];\n\n      assert.deepEqual(user.toObject().social.friends[0], {\n        _id: 'val',\n        name: 'Val'\n      });\n\n      user.save(function(error) {\n        assert.ifError(error);\n        User.findOne({ _id: user._id }, function(error, doc) {\n          assert.ifError(error);\n          assert.deepEqual(doc.toObject().social.friends[0], {\n            _id: 'val',\n            name: 'Val'\n          });\n          done();\n        });\n      });\n    });\n\n    it('consistent setter context for single nested (gh-5363)', function(done) {\n      const contentSchema = new Schema({\n        blocks: [{ type: String }],\n        previous: [{ type: String }]\n      });\n\n      // Subdocument setter\n      const oldVals = [];\n      contentSchema.path('blocks').set(function(newVal, oldVal) {\n        if (!this.ownerDocument().isNew && oldVal != null) {\n          oldVals.push(oldVal.toObject());\n          this.set('previous', [].concat(oldVal.toObject()));\n        }\n\n        return newVal;\n      });\n\n      const noteSchema = new Schema({\n        title: { type: String, required: true },\n        body: contentSchema\n      });\n\n      const Note = db.model('Test', noteSchema);\n\n      const note = new Note({\n        title: 'Lorem Ipsum Dolor',\n        body: {\n          summary: 'Summary Test',\n          blocks: ['html']\n        }\n      });\n\n      note.save().\n        then(function(note) {\n          assert.equal(oldVals.length, 0);\n          note.set('body', {\n            blocks: ['gallery', 'html']\n          });\n          return note.save();\n        }).\n        then(function() {\n          assert.equal(oldVals.length, 1);\n          assert.deepEqual(oldVals[0], ['html']);\n          assert.deepEqual(note.body.previous, ['html']);\n          done();\n        }).\n        catch(done);\n    });\n\n    it('deeply nested subdocs and markModified (gh-5406)', function(done) {\n      const nestedValueSchema = new mongoose.Schema({\n        _id: false,\n        value: Number\n      });\n      const nestedPropertySchema = new mongoose.Schema({\n        _id: false,\n        active: Boolean,\n        nestedValue: nestedValueSchema\n      });\n      const nestedSchema = new mongoose.Schema({\n        _id: false,\n        nestedProperty: nestedPropertySchema,\n        nestedTwoProperty: nestedPropertySchema\n      });\n      const optionsSchema = new mongoose.Schema({\n        _id: false,\n        nestedField: nestedSchema\n      });\n      const TestSchema = new mongoose.Schema({\n        fieldOne: String,\n        options: optionsSchema\n      });\n\n      const Test = db.model('Test', TestSchema);\n\n      const doc = new Test({\n        fieldOne: 'Test One',\n        options: {\n          nestedField: {\n            nestedProperty: {\n              active: true,\n              nestedValue: {\n                value: 42\n              }\n            }\n          }\n        }\n      });\n\n      doc.\n        save().\n        then(function(doc) {\n          doc.options.nestedField.nestedTwoProperty = {\n            active: true,\n            nestedValue: {\n              value: 1337\n            }\n          };\n\n          assert.ok(doc.isModified('options'));\n\n          return doc.save();\n        }).\n        then(function(doc) {\n          return Test.findById(doc._id);\n        }).\n        then(function(doc) {\n          assert.equal(doc.options.nestedField.nestedTwoProperty.nestedValue.value,\n            1337);\n          done();\n        }).\n        catch(done);\n    });\n\n    it('single nested subdoc post remove hooks (gh-5388)', function(done) {\n      const contentSchema = new Schema({\n        blocks: [{ type: String }],\n        summary: { type: String }\n      });\n\n      let called = 0;\n\n      contentSchema.post('remove', function() {\n        ++called;\n      });\n\n      const noteSchema = new Schema({\n        body: { type: contentSchema }\n      });\n\n      const Note = db.model('Test', noteSchema);\n\n      const note = new Note({\n        title: 'Lorem Ipsum Dolor',\n        body: {\n          summary: 'Summary Test',\n          blocks: ['html']\n        }\n      });\n\n      note.save(function(error) {\n        assert.ifError(error);\n        note.remove(function(error) {\n          assert.ifError(error);\n          setTimeout(function() {\n            assert.equal(called, 1);\n            done();\n          }, 50);\n        });\n      });\n    });\n\n    it('push populated doc onto empty array triggers manual population (gh-5504)', function() {\n      const ReferringSchema = new Schema({\n        reference: [{\n          type: Schema.Types.ObjectId,\n          ref: 'Test'\n        }]\n      });\n\n      const Referrer = db.model('Test', ReferringSchema);\n\n      const referenceA = new Referrer();\n      const referenceB = new Referrer();\n\n      const referrerA = new Referrer({ reference: [referenceA] });\n      const referrerB = new Referrer();\n      const referrerC = new Referrer();\n      const referrerD = new Referrer();\n      const referrerE = new Referrer();\n\n      referrerA.reference.push(referenceB);\n      assert.ok(referrerA.reference[0] instanceof Referrer);\n      assert.ok(referrerA.reference[1] instanceof Referrer);\n\n      referrerB.reference.push(referenceB);\n      assert.ok(referrerB.reference[0] instanceof Referrer);\n\n      referrerC.reference.unshift(referenceB);\n      assert.ok(referrerC.reference[0] instanceof Referrer);\n\n      referrerD.reference.splice(0, 0, referenceB);\n      assert.ok(referrerD.reference[0] instanceof Referrer);\n\n      referrerE.reference.addToSet(referenceB);\n      assert.ok(referrerE.reference[0] instanceof Referrer);\n    });\n\n    it('single nested conditional required scope (gh-5569)', function(done) {\n      const scopes = [];\n\n      const ThingSchema = new mongoose.Schema({\n        undefinedDisallowed: {\n          type: String,\n          required: function() {\n            scopes.push(this);\n            return this.undefinedDisallowed === undefined;\n          },\n          default: null\n        }\n      });\n\n      const SuperDocumentSchema = new mongoose.Schema({\n        thing: {\n          type: ThingSchema,\n          default: function() { return {}; }\n        }\n      });\n\n      const SuperDocument = db.model('Test', SuperDocumentSchema);\n\n      let doc = new SuperDocument();\n      doc.thing.undefinedDisallowed = null;\n\n      doc.save(function(error) {\n        assert.ifError(error);\n        doc = new SuperDocument();\n        doc.thing.undefinedDisallowed = undefined;\n        doc.save(function(error) {\n          assert.ok(error);\n          assert.ok(error.errors['thing.undefinedDisallowed']);\n          done();\n        });\n      });\n    });\n\n    it('single nested setters only get called once (gh-5601)', function() {\n      const vals = [];\n      const ChildSchema = new mongoose.Schema({\n        number: {\n          type: String,\n          set: function(v) {\n            vals.push(v);\n            return v;\n          }\n        },\n        _id: false\n      });\n      ChildSchema.set('toObject', { getters: true, minimize: false });\n\n      const ParentSchema = new mongoose.Schema({\n        child: {\n          type: ChildSchema,\n          default: {}\n        }\n      });\n\n      const Parent = db.model('Parent', ParentSchema);\n      const p = new Parent();\n      p.child = { number: '555.555.0123' };\n      assert.equal(vals.length, 1);\n      assert.equal(vals[0], '555.555.0123');\n    });\n\n    it('single getters only get called once (gh-7442)', function() {\n      let called = 0;\n\n      const childSchema = new Schema({\n        value: {\n          type: String,\n          get: function(v) {\n            ++called;\n            return v;\n          }\n        }\n      });\n\n      const schema = new Schema({\n        name: childSchema\n      });\n      const Model = db.model('Test', schema);\n\n      const doc = new Model({ 'name.value': 'test' });\n\n      called = 0;\n\n      doc.toObject({ getters: true });\n      assert.equal(called, 1);\n\n      doc.toObject({ getters: false });\n      assert.equal(called, 1);\n    });\n\n    it('calls subdocument getters if child schema has getters: true (gh-12105)', function() {\n      let called = 0;\n\n      const childSchema = new Schema({\n        _id: false,\n        value: {\n          type: String,\n          get: function(v) {\n            ++called;\n            return v.toUpperCase();\n          }\n        }\n      }, { toJSON: { getters: true } });\n      const schema = new Schema({ name: childSchema });\n      const Test = db.model('Test', schema);\n\n      const doc = new Test({ name: { value: 'John Smith' } });\n\n      const res = doc.toJSON();\n      assert.equal(called, 1);\n      assert.deepStrictEqual(res.name, { value: 'JOHN SMITH' });\n    });\n\n    it('setting doc array to array of top-level docs works (gh-5632)', function(done) {\n      const MainSchema = new Schema({\n        name: { type: String },\n        children: [{\n          name: { type: String }\n        }]\n      });\n      const RelatedSchema = new Schema({ name: { type: String } });\n      const Model = db.model('Test', MainSchema);\n      const RelatedModel = db.model('Test1', RelatedSchema);\n\n      RelatedModel.create({ name: 'test' }, function(error, doc) {\n        assert.ifError(error);\n        Model.create({ name: 'test1', children: [doc] }, function(error, m) {\n          assert.ifError(error);\n          m.children = [doc];\n          m.save(function(error) {\n            assert.ifError(error);\n            assert.equal(m.children.length, 1);\n            assert.equal(m.children[0].name, 'test');\n            done();\n          });\n        });\n      });\n    });\n\n    it('Using set as a schema path (gh-1939)', function(done) {\n      const testSchema = new Schema({ set: String });\n\n      const Test = db.model('Test', testSchema);\n\n      const t = new Test({ set: 'test 1' });\n      assert.equal(t.set, 'test 1');\n      t.save(function(error) {\n        assert.ifError(error);\n        t.set = 'test 2';\n        t.save(function(error) {\n          assert.ifError(error);\n          assert.equal(t.set, 'test 2');\n          done();\n        });\n      });\n    });\n\n    it('handles array defaults correctly (gh-5780)', function() {\n      const testSchema = new Schema({\n        nestedArr: {\n          type: [[Number]],\n          default: [[0, 1]]\n        }\n      });\n\n      const Test = db.model('Test', testSchema);\n\n      const t = new Test({});\n      assert.deepEqual(t.toObject().nestedArr, [[0, 1]]);\n\n      t.nestedArr.push([1, 2]);\n      const t2 = new Test({});\n      assert.deepEqual(t2.toObject().nestedArr, [[0, 1]]);\n    });\n\n    it('sets path to the empty string on save after query (gh-6477)', async function() {\n      const schema = new Schema({\n        name: String,\n        s: {\n          type: String,\n          default: ''\n        }\n      });\n\n      const Test = db.model('Test', schema);\n\n      const test = new Test();\n      assert.strictEqual(test.s, '');\n\n      // use native driver directly to insert an empty doc\n      await Test.collection.insertOne({});\n\n      // udate the doc with the expectation that default booleans will be saved.\n      const found = await Test.findOne({});\n      found.name = 'Max';\n      await found.save();\n\n      // use native driver directly to check doc for saved string\n      const final = await Test.collection.findOne({});\n      assert.strictEqual(final.name, 'Max');\n      assert.strictEqual(final.s, '');\n    });\n\n    it('sets path to the default boolean on save after query (gh-6477)', async function() {\n      const schema = new Schema({\n        name: String,\n        f: {\n          type: Boolean,\n          default: false\n        },\n        t: {\n          type: Boolean,\n          default: true\n        }\n      });\n\n      const Test = db.model('Test', schema);\n\n      // use native driver directly to kill the fields\n      await Test.collection.insertOne({});\n\n      // udate the doc with the expectation that default booleans will be saved.\n      const found = await Test.findOne({});\n      found.name = 'Britney';\n      await found.save();\n\n      // use native driver directly to check doc for saved string\n      const final = await Test.collection.findOne({});\n      assert.strictEqual(final.name, 'Britney');\n      assert.strictEqual(final.t, true);\n      assert.strictEqual(final.f, false);\n    });\n\n    it('virtuals with no getters return undefined (gh-6223)', function() {\n      const personSchema = new mongoose.Schema({\n        name: { type: String },\n        children: [{\n          name: { type: String }\n        }]\n      }, {\n        toObject: { getters: true, virtuals: true },\n        toJSON: { getters: true, virtuals: true },\n        id: false\n      });\n\n      personSchema.virtual('favoriteChild').set(function(v) {\n        return this.set('children.0', v);\n      });\n\n      personSchema.virtual('heir').get(function() {\n        return this.get('children.0');\n      });\n\n      const Person = db.model('Person', personSchema);\n\n      const person = new Person({\n        name: 'Anakin'\n      });\n\n      assert.strictEqual(person.favoriteChild, void 0);\n      assert.ok(!('favoriteChild' in person.toJSON()));\n      assert.ok(!('favoriteChild' in person.toObject()));\n    });\n\n    it('add default getter/setter (gh-6262)', function() {\n      const testSchema = new mongoose.Schema({});\n\n      testSchema.virtual('totalValue');\n\n      const Test = db.model('Test', testSchema);\n\n      assert.equal(Test.schema.virtuals.totalValue.getters.length, 1);\n      assert.equal(Test.schema.virtuals.totalValue.setters.length, 1);\n\n      const doc = new Test();\n      doc.totalValue = 5;\n      assert.equal(doc.totalValue, 5);\n    });\n\n    it('calls array getters (gh-9889)', function() {\n      let called = 0;\n      const testSchema = new mongoose.Schema({\n        arr: [{\n          type: 'ObjectId',\n          ref: 'Doesnt Matter',\n          get: () => {\n            ++called;\n            return 42;\n          }\n        }]\n      });\n\n      const Test = db.model('Test', testSchema);\n\n      const doc = new Test({ arr: [new mongoose.Types.ObjectId()] });\n      assert.deepEqual(doc.toObject({ getters: true }).arr, [42]);\n      assert.equal(called, 1);\n    });\n\n    it('doesnt call setters when init-ing an array (gh-9889)', async function() {\n      let called = 0;\n      const testSchema = new mongoose.Schema({\n        arr: [{\n          type: 'ObjectId',\n          set: v => {\n            ++called;\n            return v;\n          }\n        }]\n      });\n\n      const Test = db.model('Test', testSchema);\n\n\n      let doc = await Test.create({ arr: [new mongoose.Types.ObjectId()] });\n      assert.equal(called, 1);\n\n      called = 0;\n      doc = await Test.findById(doc._id);\n      assert.ok(doc);\n      assert.equal(called, 0);\n    });\n\n    it('nested virtuals + nested toJSON (gh-6294)', function() {\n      const schema = mongoose.Schema({\n        nested: {\n          prop: String\n        }\n      }, { _id: false, id: false });\n\n      schema.virtual('nested.virtual').get(() => 'test 2');\n\n      schema.set('toJSON', {\n        virtuals: true\n      });\n\n      const MyModel = db.model('Test', schema);\n\n      const doc = new MyModel({ nested: { prop: 'test 1' } });\n\n      assert.deepEqual(doc.toJSON(), {\n        nested: { prop: 'test 1', virtual: 'test 2' }\n      });\n      assert.deepEqual(doc.nested.toJSON(), {\n        prop: 'test 1', virtual: 'test 2'\n      });\n    });\n\n    it('Disallows writing to __proto__ and other special properties', function() {\n      const schema = new mongoose.Schema({\n        name: String\n      }, { strict: false });\n\n      const Model = db.model('Test', schema);\n      const doc = new Model({ '__proto__.x': 'foo' });\n\n      assert.strictEqual(Model.x, void 0);\n      doc.set('__proto__.y', 'bar');\n\n      assert.strictEqual(Model.y, void 0);\n\n      doc.set('constructor.prototype.z', 'baz');\n\n      assert.strictEqual(Model.z, void 0);\n    });\n\n    it('save() depopulates pushed arrays (gh-6048)', async function() {\n      const blogPostSchema = new Schema({\n        comments: [{\n          type: mongoose.Schema.Types.ObjectId,\n          ref: 'Comment'\n        }]\n      });\n\n      const BlogPost = db.model('BlogPost', blogPostSchema);\n\n      const commentSchema = new Schema({\n        text: String\n      });\n\n      const Comment = db.model('Comment', commentSchema);\n\n\n      let blogPost = await BlogPost.create({});\n      const comment = await Comment.create({ text: 'Hello' });\n\n      blogPost = await BlogPost.findById(blogPost);\n      blogPost.comments.push(comment);\n      await blogPost.save();\n\n      const savedBlogPost = await BlogPost.collection.\n        findOne({ _id: blogPost._id });\n      assert.equal(savedBlogPost.comments.length, 1);\n      assert.equal(savedBlogPost.comments[0].constructor.name, 'ObjectId');\n      assert.equal(savedBlogPost.comments[0].toString(),\n        blogPost.comments[0]._id.toString());\n    });\n\n    it('Handles setting populated path set via `Document#populate()` (gh-7302)', function() {\n      const authorSchema = new Schema({ name: String });\n      const bookSchema = new Schema({\n        author: { type: mongoose.Schema.Types.ObjectId, ref: 'Author' }\n      });\n\n      const Author = db.model('Author', authorSchema);\n      const Book = db.model('Book', bookSchema);\n\n      return Author.create({ name: 'Victor Hugo' }).\n        then(function(author) { return Book.create({ author: author._id }); }).\n        then(function() { return Book.findOne(); }).\n        then(function(doc) { return doc.populate('author'); }).\n        then(function(doc) {\n          doc.author = {};\n          assert.ok(!doc.author.name);\n          assert.ifError(doc.validateSync());\n        });\n    });\n\n    it('Single nested subdocs using discriminator can be modified (gh-5693)', function(done) {\n      const eventSchema = new Schema({ message: String }, {\n        discriminatorKey: 'kind',\n        _id: false\n      });\n\n      const trackSchema = new Schema({ event: eventSchema });\n\n      trackSchema.path('event').discriminator('Clicked', new Schema({\n        element: String\n      }, { _id: false }));\n\n      trackSchema.path('event').discriminator('Purchased', new Schema({\n        product: String\n      }, { _id: false }));\n\n      const MyModel = db.model('Test', trackSchema);\n\n      const doc = new MyModel({\n        event: {\n          message: 'Test',\n          kind: 'Clicked',\n          element: 'Amazon Link'\n        }\n      });\n\n      doc.save(function(error) {\n        assert.ifError(error);\n        assert.equal(doc.event.message, 'Test');\n        assert.equal(doc.event.kind, 'Clicked');\n        assert.equal(doc.event.element, 'Amazon Link');\n\n        doc.set('event', {\n          kind: 'Purchased',\n          product: 'Professional AngularJS'\n        });\n\n        doc.save(function(error) {\n          assert.ifError(error);\n          assert.equal(doc.event.kind, 'Purchased');\n          assert.equal(doc.event.product, 'Professional AngularJS');\n          assert.ok(!doc.event.element);\n          assert.ok(!doc.event.message);\n          done();\n        });\n      });\n    });\n\n    it('required function only gets called once (gh-6801)', function() {\n      let reqCount = 0;\n      const childSchema = new Schema({\n        name: {\n          type: String,\n          required: function() {\n            reqCount++;\n            return true;\n          }\n        }\n      });\n      const Child = db.model('Child', childSchema);\n\n      const parentSchema = new Schema({\n        name: String,\n        child: childSchema\n      });\n      const Parent = db.model('Parent', parentSchema);\n\n      const child = new Child(/* name is required */);\n      const parent = new Parent({ child: child });\n\n      return parent.validate().then(\n        () => assert.ok(false),\n        error => {\n          assert.equal(reqCount, 1);\n          assert.ok(error.errors['child.name']);\n        }\n      );\n    });\n\n    it('required function called again after save() (gh-6892)', async function() {\n      const schema = new mongoose.Schema({\n        field: {\n          type: String,\n          default: null,\n          required: function() { return this && this.field === undefined; }\n        }\n      });\n      const Model = db.model('Test', schema);\n\n\n      await Model.create({});\n      const doc1 = await Model.findOne({}).select({ _id: 1 });\n      await doc1.save();\n\n      // Should not throw\n      await Model.create({});\n    });\n\n    it('doc array: set then remove (gh-3511)', function(done) {\n      const ItemChildSchema = new mongoose.Schema({\n        name: {\n          type: String,\n          required: true\n        }\n      });\n\n      const ItemParentSchema = new mongoose.Schema({\n        children: [ItemChildSchema]\n      });\n\n      const ItemParent = db.model('Parent', ItemParentSchema);\n\n      const p = new ItemParent({\n        children: [{ name: 'test1' }, { name: 'test2' }]\n      });\n\n      p.save(function(error) {\n        assert.ifError(error);\n        ItemParent.findById(p._id, function(error, doc) {\n          assert.ifError(error);\n          assert.ok(doc);\n          assert.equal(doc.children.length, 2);\n\n          doc.children[1].name = 'test3';\n          doc.children.remove(doc.children[0]);\n\n          doc.save(function(error) {\n            assert.ifError(error);\n            ItemParent.findById(doc._id, function(error, doc) {\n              assert.ifError(error);\n              assert.equal(doc.children.length, 1);\n              assert.equal(doc.children[0].name, 'test3');\n              done();\n            });\n          });\n        });\n      });\n    });\n\n    it('doc array: modify then sort (gh-7556)', async function() {\n      const assetSchema = new Schema({\n        name: { type: String, required: true },\n        namePlural: { type: String, required: true }\n      });\n      assetSchema.pre('validate', function() {\n        if (this.isNew) {\n          this.namePlural = this.name + 's';\n        }\n      });\n      const personSchema = new Schema({\n        name: String,\n        assets: [assetSchema]\n      });\n\n      const Person = db.model('Person', personSchema);\n\n      await Person.create({\n        name: 'test',\n        assets: [{ name: 'Cash', namePlural: 'Cash' }]\n      });\n      const p = await Person.findOne();\n\n      p.assets.push({ name: 'Home' });\n      p.assets.id(p.assets[0].id).set('name', 'Cash');\n      p.assets.id(p.assets[0].id).set('namePlural', 'Cash');\n\n      p.assets.sort((doc1, doc2) => doc1.name > doc2.name ? -1 : 1);\n\n      await p.save();\n    });\n\n    it('modifying unselected nested object (gh-5800)', function() {\n      const MainSchema = new mongoose.Schema({\n        a: {\n          b: { type: String, default: 'some default' },\n          c: { type: Number, default: 0 },\n          d: { type: String }\n        },\n        e: { type: String }\n      });\n\n      MainSchema.pre('save', function(next) {\n        if (this.isModified()) {\n          this.set('a.c', 100, Number);\n        }\n        next();\n      });\n\n      const Main = db.model('Test', MainSchema);\n\n      const doc = { a: { b: 'not the default', d: 'some value' }, e: 'e' };\n      return Main.create(doc).\n        then(function(doc) {\n          assert.equal(doc.a.b, 'not the default');\n          assert.equal(doc.a.d, 'some value');\n          return Main.findOne().select('e');\n        }).\n        then(function(doc) {\n          doc.e = 'e modified';\n          return doc.save();\n        }).\n        then(function() {\n          return Main.findOne();\n        }).\n        then(function(doc) {\n          assert.equal(doc.a.b, 'not the default');\n          assert.equal(doc.a.d, 'some value');\n        });\n    });\n\n    it('set() underneath embedded discriminator (gh-6482)', async function() {\n      const mediaSchema = new Schema({ file: String },\n        { discriminatorKey: 'kind', _id: false });\n\n      const photoSchema = new Schema({ position: String });\n      const pageSchema = new Schema({ media: mediaSchema });\n\n      pageSchema.path('media').discriminator('photo', photoSchema);\n\n      const Page = db.model('Test', pageSchema);\n\n\n      let doc = await Page.create({\n        media: { kind: 'photo', file: 'cover.jpg', position: 'left' }\n      });\n\n      // Using positional args syntax\n      doc.set('media.position', 'right');\n      assert.equal(doc.media.position, 'right');\n\n      await doc.save();\n\n      doc = await Page.findById(doc._id);\n      assert.equal(doc.media.position, 'right');\n\n      // Using object syntax\n      doc.set({ 'media.position': 'left' });\n      assert.equal(doc.media.position, 'left');\n\n      await doc.save();\n\n      doc = await Page.findById(doc._id);\n      assert.equal(doc.media.position, 'left');\n    });\n\n    it('set() underneath array embedded discriminator (gh-6526)', async function() {\n      const mediaSchema = new Schema({ file: String },\n        { discriminatorKey: 'kind', _id: false });\n\n      const photoSchema = new Schema({ position: String });\n      const pageSchema = new Schema({ media: [mediaSchema] });\n\n      pageSchema.path('media').discriminator('photo', photoSchema);\n\n      const Page = db.model('Test', pageSchema);\n\n\n      let doc = await Page.create({\n        media: [{ kind: 'photo', file: 'cover.jpg', position: 'left' }]\n      });\n\n      // Using positional args syntax\n      doc.set('media.0.position', 'right');\n      assert.equal(doc.media[0].position, 'right');\n\n      await doc.save();\n\n      doc = await Page.findById(doc._id);\n      assert.equal(doc.media[0].position, 'right');\n    });\n\n    it('consistent context for nested docs (gh-5347)', function(done) {\n      const contexts = [];\n      const childSchema = new mongoose.Schema({\n        phoneNumber: {\n          type: String,\n          required: function() {\n            contexts.push(this);\n            return this.notifications.isEnabled;\n          }\n        },\n        notifications: {\n          isEnabled: { type: Boolean, required: true }\n        }\n      });\n\n      const parentSchema = new mongoose.Schema({\n        name: String,\n        children: [childSchema]\n      });\n\n      const Parent = db.model('Parent', parentSchema);\n\n      Parent.create({\n        name: 'test',\n        children: [\n          {\n            phoneNumber: '123',\n            notifications: {\n              isEnabled: true\n            }\n          }\n        ]\n      }, function(error, doc) {\n        assert.ifError(error);\n        const child = doc.children.id(doc.children[0]._id);\n        child.phoneNumber = '345';\n        assert.equal(contexts.length, 1);\n        doc.save(function(error) {\n          assert.ifError(error);\n          assert.equal(contexts.length, 2);\n          assert.ok(contexts[0].toObject().notifications.isEnabled);\n          assert.ok(contexts[1].toObject().notifications.isEnabled);\n          done();\n        });\n      });\n    });\n\n    it('accessing arrays in setters on initial document creation (gh-6155)', function() {\n      const artistSchema = new mongoose.Schema({\n        name: {\n          type: String,\n          set: function(v) {\n            const splitStrings = v.split(' ');\n            for (const keyword of splitStrings) {\n              this.keywords.push(keyword);\n            }\n            return v;\n          }\n        },\n        keywords: [String]\n      });\n\n      const Artist = db.model('Test', artistSchema);\n\n      const artist = new Artist({ name: 'Motley Crue' });\n      assert.deepEqual(artist.toObject().keywords, ['Motley', 'Crue']);\n    });\n\n    it('handles 2nd level nested field with null child (gh-6187)', function() {\n      const NestedSchema = new Schema({\n        parent: new Schema({\n          name: String,\n          child: {\n            name: String\n          }\n        }, { strict: false })\n      });\n      const NestedModel = db.model('Test', NestedSchema);\n      const n = new NestedModel({\n        parent: {\n          name: 'foo',\n          child: null // does not fail if undefined\n        }\n      });\n\n      assert.equal(n.parent.name, 'foo');\n    });\n\n    it('does not call default function on init if value set (gh-6410)', async function() {\n      let called = 0;\n\n      function generateRandomID() {\n        called++;\n        return called;\n      }\n\n      const TestDefaultsWithFunction = db.model('Test', new Schema({\n        randomID: { type: Number, default: generateRandomID }\n      }));\n\n      const post = new TestDefaultsWithFunction();\n      assert.equal(post.get('randomID'), 1);\n      assert.equal(called, 1);\n\n\n      await post.save();\n\n      await TestDefaultsWithFunction.findById(post._id);\n\n      assert.equal(called, 1);\n    });\n\n    describe('convertToFalse and convertToTrue (gh-6758)', function() {\n      let convertToFalse = null;\n      let convertToTrue = null;\n\n      beforeEach(function() {\n        convertToFalse = new Set(mongoose.Schema.Types.Boolean.convertToFalse);\n        convertToTrue = new Set(mongoose.Schema.Types.Boolean.convertToTrue);\n      });\n\n      afterEach(function() {\n        mongoose.Schema.Types.Boolean.convertToFalse = convertToFalse;\n        mongoose.Schema.Types.Boolean.convertToTrue = convertToTrue;\n      });\n\n      it('lets you add custom strings that get converted to true/false', function() {\n        const TestSchema = new Schema({ b: Boolean });\n        const Test = db.model('Test', TestSchema);\n\n        mongoose.Schema.Types.Boolean.convertToTrue.add('aye');\n        mongoose.Schema.Types.Boolean.convertToFalse.add('nay');\n\n        const doc1 = new Test({ b: 'aye' });\n        const doc2 = new Test({ b: 'nay' });\n\n        assert.strictEqual(doc1.b, true);\n        assert.strictEqual(doc2.b, false);\n\n        return doc1.save().\n          then(() => Test.findOne({ b: { $exists: 'aye' } })).\n          then(doc => assert.ok(doc)).\n          then(() => {\n            mongoose.Schema.Types.Boolean.convertToTrue.delete('aye');\n            mongoose.Schema.Types.Boolean.convertToFalse.delete('nay');\n          });\n      });\n\n      it('allows adding `null` to list of values that convert to false (gh-9223)', function() {\n        const TestSchema = new Schema({ b: Boolean });\n        const Test = db.model('Test', TestSchema);\n\n        mongoose.Schema.Types.Boolean.convertToFalse.add(null);\n\n        const doc1 = new Test({ b: null });\n        const doc2 = new Test();\n        doc2.init({ b: null });\n\n        assert.strictEqual(doc1.b, false);\n        assert.strictEqual(doc2.b, false);\n      });\n    });\n\n    it('doesnt double-call getters when using get() (gh-6779)', function() {\n      const schema = new Schema({\n        nested: {\n          arr: [{ key: String }]\n        }\n      });\n\n      schema.path('nested.arr.0.key').get(v => {\n        return 'foobar' + v;\n      });\n\n      const M = db.model('Test', schema);\n      const test = new M();\n\n      test.nested.arr.push({ key: 'value' });\n      test.nested.arr.push({ key: 'value2' });\n\n      assert.equal(test.get('nested.arr.0.key'), 'foobarvalue');\n      assert.equal(test.get('nested.arr.1.key'), 'foobarvalue2');\n\n      return Promise.resolve();\n    });\n\n    it('returns doubly nested field in inline sub schema when using get() (gh-6925)', function() {\n      const child = new Schema({\n        nested: {\n          key: String\n        }\n      });\n      const parent = new Schema({\n        child: child\n      });\n\n      const M = db.model('Test', parent);\n      const test = new M({\n        child: {\n          nested: {\n            key: 'foobarvalue'\n          }\n        }\n      });\n\n      assert.equal(test.get('child.nested.key'), 'foobarvalue');\n\n      return Promise.resolve();\n    });\n\n    it('defaults should see correct isNew (gh-3793)', async function() {\n      let isNew = [];\n      const TestSchema = new mongoose.Schema({\n        test: {\n          type: Date,\n          default: function() {\n            isNew.push(this.isNew);\n            if (this.isNew) {\n              return Date.now();\n            }\n            return void 0;\n          }\n        }\n      });\n\n      const TestModel = db.model('Test', TestSchema);\n\n\n      await Promise.resolve(db);\n\n      await TestModel.collection.insertOne({});\n\n      let doc = await TestModel.findOne({});\n      assert.strictEqual(doc.test, void 0);\n      assert.deepEqual(isNew, [false]);\n\n      isNew = [];\n\n      doc = await TestModel.create({});\n      assert.ok(doc.test instanceof Date);\n      assert.deepEqual(isNew, [true]);\n    });\n\n    it('modify multiple subdoc paths (gh-4405)', function(done) {\n      const ChildObjectSchema = new Schema({\n        childProperty1: String,\n        childProperty2: String,\n        childProperty3: String\n      });\n\n      const ParentObjectSchema = new Schema({\n        parentProperty1: String,\n        parentProperty2: String,\n        child: ChildObjectSchema\n      });\n\n      const Parent = db.model('Parent', ParentObjectSchema);\n\n      const p = new Parent({\n        parentProperty1: 'abc',\n        parentProperty2: '123',\n        child: {\n          childProperty1: 'a',\n          childProperty2: 'b',\n          childProperty3: 'c'\n        }\n      });\n      p.save(function(error) {\n        assert.ifError(error);\n        Parent.findById(p._id, function(error, p) {\n          assert.ifError(error);\n          p.parentProperty1 = 'foo';\n          p.parentProperty2 = 'bar';\n          p.child.childProperty1 = 'ping';\n          p.child.childProperty2 = 'pong';\n          p.child.childProperty3 = 'weee';\n          p.save(function(error) {\n            assert.ifError(error);\n            Parent.findById(p._id, function(error, p) {\n              assert.ifError(error);\n              assert.equal(p.child.childProperty1, 'ping');\n              assert.equal(p.child.childProperty2, 'pong');\n              assert.equal(p.child.childProperty3, 'weee');\n              done();\n            });\n          });\n        });\n      });\n    });\n\n    it('doesnt try to cast populated embedded docs (gh-6390)', async function() {\n      const otherSchema = new Schema({\n        name: String\n      });\n\n      const subSchema = new Schema({\n        my: String,\n        other: {\n          type: Schema.Types.ObjectId,\n          refPath: 'sub.my'\n        }\n      });\n\n      const schema = new Schema({\n        name: String,\n        sub: subSchema\n      });\n\n      const Other = db.model('Test1', otherSchema);\n      const Test = db.model('Test', schema);\n\n      const other = new Other({ name: 'Nicole' });\n\n      const test = new Test({\n        name: 'abc',\n        sub: {\n          my: 'Test1',\n          other: other._id\n        }\n      });\n\n      await other.save();\n      await test.save();\n      const doc = await Test.findOne({}).populate('sub.other');\n      assert.strictEqual('Nicole', doc.sub.other.name);\n\n    });\n  });\n\n  describe('clobbered Array.prototype', function() {\n    beforeEach(() => db.deleteModel(/.*/));\n\n    afterEach(function() {\n      delete Array.prototype.remove;\n    });\n\n    it('handles clobbered Array.prototype.remove (gh-6431)', function() {\n      Object.defineProperty(Array.prototype, 'remove', {\n        value: 42,\n        configurable: true,\n        writable: false\n      });\n\n      const schema = new Schema({ arr: [{ name: String }] });\n      const MyModel = db.model('Test', schema);\n\n      const doc = new MyModel();\n      assert.deepEqual(doc.toObject().arr, []);\n    });\n\n    it('calls array validators again after save (gh-6818)', async function() {\n      const schema = new Schema({\n        roles: {\n          type: [{\n            name: String,\n            folders: {\n              type: [{ folderId: String }],\n              validate: v => assert.ok(v.length === new Set(v.map(el => el.folderId)).size, 'Duplicate')\n            }\n          }]\n        }\n      });\n      const Model = db.model('Test', schema);\n\n      await Model.create({\n        roles: [\n          { name: 'admin' },\n          { name: 'mod', folders: [{ folderId: 'foo' }] }\n        ]\n      });\n\n      const doc = await Model.findOne();\n\n      doc.roles[1].folders.push({ folderId: 'bar' });\n\n      await doc.save();\n\n      doc.roles[1].folders[1].folderId = 'foo';\n      let threw = false;\n      try {\n        await doc.save();\n      } catch (error) {\n        threw = true;\n        assert.equal(error.errors['roles.1.folders'].reason.message, 'Duplicate');\n      }\n      assert.ok(threw);\n    });\n\n    it('set single nested to num throws ObjectExpectedError (gh-6710) (gh-6753)', function() {\n      const schema = new Schema({\n        nested: new Schema({\n          num: Number\n        })\n      });\n\n      const Test = db.model('Test', schema);\n\n      const doc = new Test({ nested: { num: 123 } });\n      doc.nested = 123;\n\n      return doc.validate().\n        then(() => { throw new Error('Should have errored'); }).\n        catch(err => {\n          assert.ok(err.message.indexOf('Cast to Embedded') !== -1, err.message);\n          assert.equal(err.errors['nested'].reason.name, 'ObjectExpectedError');\n\n          const doc = new Test({ nested: { num: 123 } });\n          doc.nested = [];\n          return doc.validate();\n        }).\n        then(() => { throw new Error('Should have errored'); }).\n        catch(err => {\n          assert.ok(err.message.indexOf('Cast to Embedded') !== -1, err.message);\n          assert.equal(err.errors['nested'].reason.name, 'ObjectExpectedError');\n        });\n    });\n\n    it('set array to false throws ObjectExpectedError (gh-7242)', function() {\n      const Child = new mongoose.Schema({});\n      const Parent = new mongoose.Schema({\n        children: [Child]\n      });\n      const ParentModel = db.model('Parent', Parent);\n      const doc = new ParentModel({ children: false });\n\n      return doc.save().then(\n        () => assert.ok(false),\n        err => {\n          assert.ok(err.errors['children']);\n          assert.equal(err.errors['children'].name, 'ObjectParameterError');\n        }\n      );\n    });\n  });\n\n  it('does not save duplicate items after two saves (gh-6900)', async function() {\n    const M = db.model('Test', { items: [{ name: String }] });\n    const doc = new M();\n    doc.items.push({ name: '1' });\n\n\n    await doc.save();\n    doc.items.push({ name: '2' });\n    await doc.save();\n\n    const found = await M.findById(doc.id);\n    assert.equal(found.items.length, 2);\n  });\n\n  it('validateSync() on embedded doc (gh-6931)', async function() {\n    const innerSchema = new mongoose.Schema({\n      innerField: {\n        type: mongoose.Schema.Types.ObjectId,\n        required: true\n      }\n    });\n\n    const schema = new mongoose.Schema({\n      field: {\n        type: mongoose.Schema.Types.ObjectId,\n        required: true\n      },\n      inner: [innerSchema]\n    });\n\n    const Model = db.model('Test', schema);\n\n\n    const doc2 = new Model();\n    doc2.field = new mongoose.Types.ObjectId();\n    doc2.inner.push({\n      innerField: new mongoose.Types.ObjectId()\n    });\n    doc2.inner[0].innerField = '';\n\n    let err = doc2.inner[0].validateSync();\n    assert.ok(err);\n    assert.ok(err.errors['innerField']);\n\n    err = await doc2.inner[0].validate().then(() => assert.ok(false), err => err);\n    assert.ok(err);\n    assert.ok(err.errors['innerField']);\n  });\n\n  it('retains user-defined key order with nested docs (gh-6944)', function() {\n    const schema = new Schema({\n      _id: String,\n      foo: String,\n      bar: {\n        a: String\n      }\n    });\n\n    const Model = db.model('Test', schema);\n\n    const doc = new Model({ _id: 'test', foo: 'hello', bar: { a: 'world' } });\n\n    // Same order as in the initial set above\n    assert.deepEqual(Object.keys(doc._doc), ['_id', 'foo', 'bar']);\n\n    return Promise.resolve();\n  });\n\n  it('does not mark modified if setting nested subdoc to same value (gh-7048)', async function() {\n    const BarSchema = new Schema({ bar: String }, { _id: false });\n    const FooNestedSchema = new Schema({ foo: BarSchema });\n\n    const Model = db.model('Test', FooNestedSchema);\n\n\n    const doc = await Model.create({ foo: { bar: 'test' } });\n    doc.set({ foo: { bar: 'test' } });\n\n    assert.deepEqual(doc.modifiedPaths(), []);\n\n    doc.set('foo.bar', 'test');\n\n    assert.deepEqual(doc.modifiedPaths(), []);\n  });\n\n  it('allow saving validation error in db (gh-7127)', async function() {\n\n    const schema = new Schema({\n      error: mongoose.Schema.Types.Mixed,\n      name: { type: String, required: true }\n    });\n    const Model = db.model('Test', schema);\n\n    const doc = new Model();\n\n    const error = await doc.validate().catch(error => error);\n\n    doc.name = 'foo';\n    doc.error = error;\n\n    await doc.save();\n\n    const fromDb = await Model.findOne();\n    assert.ok(fromDb.error.errors.name);\n  });\n\n  it('handles mixed arrays with all syntaxes (gh-7109)', function() {\n    const schema = new Schema({\n      arr1: [Schema.Types.Mixed],\n      arr2: [{}],\n      arr3: [Object]\n    });\n\n    const Test = db.model('Test', schema);\n\n    const test = new Test({\n      arr1: ['test1', { two: 'three' }, [4, 'five', 6]],\n      arr2: ['test2', { three: 'four' }, [5, 'six', 7]],\n      arr3: ['test3', { four: 'five' }, [6, 'seven', 8]]\n    });\n\n    assert.ok(test.validateSync() == null, test.validateSync());\n\n    return Promise.resolve();\n  });\n\n  it('propsParameter option (gh-7145)', async function() {\n    const schema = new Schema({\n      name: {\n        type: String,\n        validate: {\n          validator: (v, props) => props.validator != null,\n          propsParameter: true\n        }\n      }\n    });\n\n    const Test = db.model('Test', schema);\n\n    const doc = new Test({ name: 'foo' });\n    const syncValidationError = doc.validateSync();\n    assert.ok(syncValidationError == null, syncValidationError);\n\n\n    const asyncValidationError = await doc.validate().then(() => null, err => err);\n\n    assert.ok(asyncValidationError == null, asyncValidationError);\n  });\n\n  it('surfaces errors in subdoc pre validate (gh-7187)', function() {\n    const InnerSchema = new Schema({ name: String });\n\n    InnerSchema.pre('validate', function() {\n      throw new Error('Oops!');\n    });\n\n    const TestSchema = new Schema({ subdocs: [InnerSchema] });\n\n    const Test = db.model('Test', TestSchema);\n\n    return Test.create({ subdocs: [{ name: 'foo' }] }).then(\n      () => { throw new Error('Fail'); },\n      err => { assert.ok(err.message.indexOf('Oops!') !== -1, err.message); }\n    );\n  });\n\n  it('runs setter only once when doing .set() underneath single nested (gh-7196)', function() {\n    let called = [];\n    const InnerSchema = new Schema({\n      name: String,\n      withSetter: {\n        type: String,\n        set: function(v) {\n          called.push(this);\n          return v;\n        }\n      }\n    });\n\n    const TestSchema = new Schema({ nested: InnerSchema });\n\n    const Model = db.model('Test', TestSchema);\n\n    const doc = new Model({ nested: { name: 'foo' } });\n\n    // Make sure setter only gets called once\n    called = [];\n    doc.set('nested.withSetter', 'bar');\n\n    assert.equal(called.length, 1);\n    assert.equal(called[0].name, 'foo');\n\n    return Promise.resolve();\n  });\n\n  it('should enable key with dot(.) on mixed types with checkKeys (gh-7144)', async function() {\n    const s = new Schema({ raw: { type: Schema.Types.Mixed } });\n    const M = db.model('Test', s);\n\n    const raw = { 'foo.bar': 'baz' };\n\n\n    let doc = await M.create([{ raw: raw }], { checkKeys: false }).\n      then(res => res[0]);\n    assert.deepEqual(doc.raw, raw);\n\n    doc = await M.findOneAndUpdate({}, { raw: { 'a.b': 2 } }, { new: true });\n    assert.deepEqual(doc.raw, { 'a.b': 2 });\n  });\n\n  it('doesnt mark array as modified on init if embedded schema has default (gh-7227)', async function() {\n    const subSchema = new mongoose.Schema({\n      users: {\n        type: [{ name: { type: String } }],\n        // This test ensures the whole array won't be modified on init because\n        // of this default\n        default: [{ name: 'test' }]\n      }\n    });\n\n    const schema = new mongoose.Schema({\n      sub: [subSchema]\n    });\n    const Model = db.model('Test', schema);\n\n\n    let doc = new Model({ name: 'test', sub: [{}] });\n    await doc.save();\n\n    assert.ok(!doc.isModified());\n\n    doc = await Model.findOne();\n    assert.ok(!doc.isModified());\n  });\n\n  it('casts defaults for doc arrays (gh-7337)', async function() {\n    const accountSchema = new mongoose.Schema({\n      roles: {\n        type: [{\n          otherProperties: {\n            example: Boolean\n          },\n          name: String\n        }],\n        default: function() {\n          return [\n            { otherProperties: { example: true }, name: 'First' },\n            { otherProperties: { example: false }, name: 'Second' }\n          ];\n        }\n      }\n    });\n\n    const Account = db.model('Test', accountSchema);\n\n\n    await Account.create({});\n\n    const doc = await Account.findOne();\n\n    assert.ok(doc.roles[0]._id);\n    assert.ok(doc.roles[1]._id);\n  });\n\n  it('updateOne() hooks (gh-7133) (gh-7423)', async function() {\n    const schema = new mongoose.Schema({ name: String });\n\n    let queryCount = 0;\n    let docCount = 0;\n    let docPostCount = 0;\n\n    let docRegexCount = 0;\n    let docPostRegexCount = 0;\n\n    schema.pre('updateOne', () => ++queryCount);\n    schema.pre('updateOne', { document: true, query: false }, () => ++docCount);\n    schema.post('updateOne', { document: true, query: false }, () => ++docPostCount);\n\n    schema.pre(/^updateOne$/, { document: true, query: false }, () => ++docRegexCount);\n    schema.post(/^updateOne$/, { document: true, query: false }, () => ++docPostRegexCount);\n\n    let removeCount1 = 0;\n    let removeCount2 = 0;\n    schema.pre('remove', () => ++removeCount1);\n    schema.pre('remove', { document: true, query: false }, () => ++removeCount2);\n\n    const Model = db.model('Test', schema);\n\n\n    const doc = new Model({ name: 'test' });\n    await doc.save();\n\n    assert.equal(queryCount, 0);\n    assert.equal(docCount, 0);\n    assert.equal(docPostCount, 0);\n    assert.equal(docRegexCount, 0);\n    assert.equal(docPostRegexCount, 0);\n\n    await doc.updateOne({ name: 'test2' });\n\n    assert.equal(queryCount, 1);\n    assert.equal(docCount, 1);\n    assert.equal(docPostCount, 1);\n    assert.equal(docRegexCount, 1);\n    assert.equal(docPostRegexCount, 1);\n\n    assert.equal(removeCount1, 0);\n    assert.equal(removeCount2, 0);\n\n    await doc.remove();\n\n    assert.equal(removeCount1, 1);\n    assert.equal(removeCount2, 1);\n  });\n\n  it('doesnt mark single nested doc date as modified if setting with string (gh-7264)', async function() {\n    const subSchema = new mongoose.Schema({\n      date2: Date\n    });\n\n    const schema = new mongoose.Schema({\n      date1: Date,\n      sub: subSchema\n    });\n\n    const Model = db.model('Test', schema);\n\n\n    const date = '2018-11-22T09:00:00.000Z';\n\n    const doc = await Model.create({\n      date1: date,\n      sub: { date2: date }\n    });\n\n    assert.deepEqual(doc.modifiedPaths(), []);\n\n    doc.set('date1', date);\n    doc.set('sub.date2', date);\n\n    assert.deepEqual(doc.modifiedPaths(), []);\n  });\n\n  it('handles null `fields` param to constructor (gh-7271)', function() {\n    const ActivityBareSchema = new Schema({\n      _id: {\n        type: Schema.Types.ObjectId,\n        ref: 'Activity'\n      },\n      name: String\n    });\n\n    const EventSchema = new Schema({\n      activity: ActivityBareSchema,\n      name: String\n    });\n\n    const data = {\n      name: 'Test',\n      activity: {\n        _id: '5bf606f6471b6056b3f2bfc9',\n        name: 'Activity name'\n      }\n    };\n\n    const Event = db.model('Test', EventSchema);\n    const event = new Event(data, null);\n\n    assert.equal(event.activity.name, 'Activity name');\n\n    return event.validate();\n  });\n\n  it('flattenMaps option for toObject() (gh-10872) (gh-7274) (gh-10486)', function() {\n    const subSchema = new Schema({ name: String });\n\n    let schema = new Schema({\n      test: {\n        type: Map,\n        of: subSchema,\n        default: new Map()\n      }\n    }, { versionKey: false });\n\n    let Test = db.model('Test', schema);\n\n    let mapTest = new Test({});\n    mapTest.test.set('key1', { name: 'value1' });\n    // getters: true for gh-10486\n    assert.equal(mapTest.toObject({ getters: true, flattenMaps: true }).test.key1.name, 'value1');\n\n    assert.equal(mapTest.toJSON({ getters: true, flattenMaps: true }).test.key1.name, 'value1');\n    assert.equal(mapTest.toJSON({ getters: true, flattenMaps: false }).test.get('key1').name, 'value1');\n\n    schema = new Schema({\n      test: {\n        type: Map,\n        of: subSchema,\n        default: new Map()\n      }\n    }, { versionKey: false });\n    schema.set('toObject', { flattenMaps: true });\n\n    db.deleteModel('Test');\n    Test = db.model('Test', schema);\n\n    mapTest = new Test({});\n    mapTest.test.set('key1', { name: 'value1' });\n    assert.equal(mapTest.toObject({}).test.key1.name, 'value1');\n  });\n\n  it('`collection` property with strict: false (gh-7276)', async function() {\n    const schema = new Schema({}, { strict: false, versionKey: false });\n    const Model = db.model('Test', schema);\n\n    let doc = new Model({ test: 'foo', collection: 'bar' });\n\n    await doc.save();\n\n    assert.equal(doc.collection, 'bar');\n\n    doc = await Model.findOne();\n    assert.equal(doc.toObject().collection, 'bar');\n  });\n\n  it('should validateSync() all elements in doc array (gh-6746)', function() {\n    const Model = db.model('Test', new Schema({\n      colors: [{\n        name: { type: String, required: true },\n        hex: { type: String, required: true }\n      }]\n    }));\n\n    const model = new Model({\n      colors: [\n        { name: 'steelblue' },\n        { hex: '#4682B4' }\n      ]\n    });\n\n    const errors = model.validateSync().errors;\n    const keys = Object.keys(errors).sort();\n    assert.deepEqual(keys, ['colors.0.hex', 'colors.1.name']);\n  });\n\n  it('handles fake constructor (gh-7290)', async function() {\n    const TestSchema = new Schema({ test: String });\n\n    const TestModel = db.model('Test', TestSchema);\n\n    const badQuery = {\n      test: {\n        length: 1e10,\n        constructor: {\n          name: 'Array'\n        }\n      }\n    };\n\n\n    let err = await TestModel.findOne(badQuery).then(() => null, e => e);\n    assert.equal(err.name, 'CastError', err.stack);\n\n    err = await TestModel.updateOne(badQuery, { name: 'foo' }).\n      then(() => null, err => err);\n    assert.equal(err.name, 'CastError', err.stack);\n\n    err = await TestModel.updateOne({}, badQuery).then(() => null, e => e);\n    assert.equal(err.name, 'CastError', err.stack);\n\n    err = await TestModel.deleteOne(badQuery).then(() => null, e => e);\n    assert.equal(err.name, 'CastError', err.stack);\n  });\n\n  it('handles fake __proto__ (gh-7290)', async function() {\n    const TestSchema = new Schema({ test: String, name: String });\n\n    const TestModel = db.model('Test', TestSchema);\n\n    const badQuery = JSON.parse('{\"test\":{\"length\":1000000000,\"__proto__\":[]}}');\n\n\n    let err = await TestModel.findOne(badQuery).then(() => null, e => e);\n    assert.equal(err.name, 'CastError', err.stack);\n\n    err = await TestModel.updateOne(badQuery, { name: 'foo' }).\n      then(() => null, err => err);\n    assert.equal(err.name, 'CastError', err.stack);\n\n    err = await TestModel.updateOne({}, badQuery).then(() => null, e => e);\n    assert.equal(err.name, 'CastError', err.stack);\n\n    err = await TestModel.deleteOne(badQuery).then(() => null, e => e);\n    assert.equal(err.name, 'CastError', err.stack);\n  });\n\n  it('cast error with string path set to array in db (gh-7619)', async function() {\n    const TestSchema = new Schema({ name: String });\n\n    const TestModel = db.model('Test', TestSchema);\n\n\n    await TestModel.findOne();\n\n    await TestModel.collection.insertOne({ name: ['foo', 'bar'] });\n\n    const doc = await TestModel.findOne();\n    assert.ok(!doc.name);\n    const err = doc.validateSync();\n    assert.ok(err);\n    assert.ok(err.errors['name']);\n  });\n\n  it('doesnt crash if nested path with `get()` (gh-7316)', function() {\n    const schema = new mongoose.Schema({ http: { get: Number } });\n    const Model = db.model('Test', schema);\n\n    return Model.create({ http: { get: 400 } }); // Should succeed\n  });\n\n  it('copies atomics from existing document array when setting doc array (gh-7472)', async function() {\n    const Dog = db.model('Test', new mongoose.Schema({\n      name: String,\n      toys: [{\n        name: String\n      }]\n    }));\n\n\n    const dog = new Dog({ name: 'Dash' });\n\n    dog.toys.push({ name: '1' });\n    dog.toys.push({ name: '2' });\n    dog.toys.push({ name: '3' });\n\n    await dog.save();\n\n    for (const toy of ['4', '5', '6']) {\n      dog.toys = dog.toys || [];\n      dog.toys.push({ name: toy, count: 1 });\n    }\n\n    await dog.save();\n\n    const fromDb = await Dog.findOne();\n    assert.deepEqual(fromDb.toys.map(t => t.name), ['1', '2', '3', '4', '5', '6']);\n  });\n\n  it('doesnt fail with custom update function (gh-7342)', async function() {\n    const catalogSchema = new mongoose.Schema({\n      name: String,\n      sub: new Schema({ name: String })\n    }, { runSettersOnQuery: true });\n\n    catalogSchema.methods.update = function(data) {\n      for (const key in data) {\n        this[key] = data[key];\n      }\n      return this.save();\n    };\n\n    const Catalog = db.model('Test', catalogSchema);\n\n\n    let doc = await Catalog.create({ name: 'test', sub: { name: 'foo' } });\n    doc = await doc.update({ name: 'test2' });\n    assert.equal(doc.name, 'test2');\n  });\n\n  it('setters that modify `this` should work on single nested when overwriting (gh-7585)', function() {\n    const NameSchema = new Schema({\n      full: {\n        type: String,\n        set: function(v) {\n          this.first = 'foo';\n          this.last = 'bar';\n          return v + ' baz';\n        }\n      },\n      first: String,\n      last: String\n    }, { _id: false });\n\n    const User = db.model('User', new Schema({\n      name: {\n        type: NameSchema,\n        default: {}\n      }\n    }));\n\n    const s = new User();\n    s.name = { full: 'test' };\n    assert.equal(s.name.first, 'foo');\n    assert.equal(s.name.last, 'bar');\n    assert.equal(s.name.full, 'test baz');\n\n    return Promise.resolve();\n  });\n\n  it('handles setting embedded doc to Object.assign() from another doc (gh-7645)', function() {\n    const profileSchema = new Schema({ name: String, email: String });\n    const companyUserSchema = new Schema({\n      profile: {\n        type: profileSchema,\n        default: {}\n      }\n    });\n\n    const CompanyUser = db.model('User', companyUserSchema);\n\n    const cu = new CompanyUser({ profile: { name: 'foo', email: 'bar' } });\n    cu.profile = Object.assign({}, cu.profile);\n\n    assert.equal(cu.profile.name, 'foo');\n    assert.equal(cu.profile.email, 'bar');\n    assert.doesNotThrow(function() {\n      cu.toObject();\n    });\n  });\n\n  it('setting single nested subdoc with custom date types and getters/setters (gh-7601)', async function() {\n    const moment = require('moment');\n\n    const schema = new Schema({\n      start: { type: Date, get: get, set: set, required: true },\n      end: { type: Date, get: get, set: set, required: true }\n    }, { toObject: { getters: true } });\n    function get(v) {\n      return moment(v);\n    }\n    function set(v) {\n      return v.toDate();\n    }\n    const parentSchema = new Schema({\n      nested: schema\n    });\n    const Model = db.model('Parent', parentSchema);\n\n\n    const doc = await Model.create({\n      nested: { start: moment('2019-01-01'), end: moment('2019-01-02') }\n    });\n\n    doc.nested = { start: moment('2019-03-01'), end: moment('2019-04-01') };\n    await doc.save();\n\n    const _doc = await Model.collection.findOne();\n    assert.ok(_doc.nested.start instanceof Date);\n    assert.ok(_doc.nested.end instanceof Date);\n  });\n\n  it('get() and set() underneath alias (gh-7592)', async function() {\n    const photoSchema = new Schema({\n      foo: String\n    });\n\n    const pageSchema = new Schema({\n      p: { type: [photoSchema], alias: 'photos' }\n    });\n    const Page = db.model('Test', pageSchema);\n\n\n    const doc = await Page.create({ p: [{ foo: 'test' }] });\n\n    assert.equal(doc.p[0].foo, 'test');\n    assert.equal(doc.get('photos.0.foo'), 'test');\n\n    doc.set('photos.0.foo', 'bar');\n    assert.equal(doc.p[0].foo, 'bar');\n    assert.equal(doc.get('photos.0.foo'), 'bar');\n  });\n\n  it('get() with getters: false (gh-7233)', function() {\n    const testSchema = new Schema({\n      foo: { type: String, get: v => v.toLowerCase() }\n    });\n    const Test = db.model('Test', testSchema);\n\n    const doc = new Test({ foo: 'Bar' });\n    assert.equal(doc.foo, 'bar');\n    assert.equal(doc._doc.foo, 'Bar');\n\n    assert.equal(doc.get('foo'), 'bar');\n    assert.equal(doc.get('foo', null, { getters: false }), 'Bar');\n\n    return Promise.resolve();\n  });\n\n  it('overwriting single nested (gh-7660)', function() {\n    const childSchema = new mongoose.Schema({\n      foo: String,\n      bar: Number\n    }, { _id: false, id: false });\n\n    const parentSchema = new mongoose.Schema({\n      child: childSchema\n    });\n    const Test = db.model('Test', parentSchema);\n\n    const test = new Test({\n      child: {\n        foo: 'test',\n        bar: 42\n      }\n    });\n\n    test.set({\n      child: {\n        foo: 'modified',\n        bar: 43\n      }\n    });\n\n    assert.deepEqual(test.toObject().child, {\n      foo: 'modified',\n      bar: 43\n    });\n\n    return Promise.resolve();\n  });\n\n  it('setting path to non-POJO object (gh-7639)', function() {\n    class Nested {\n      constructor(prop) {\n        this.prop = prop;\n      }\n    }\n\n    const schema = new Schema({ nested: { prop: String } });\n    const Model = db.model('Test', schema);\n\n    const doc = new Model({ nested: { prop: '1' } });\n\n    doc.set('nested', new Nested('2'));\n    assert.equal(doc.nested.prop, '2');\n\n    doc.set({ nested: new Nested('3') });\n    assert.equal(doc.nested.prop, '3');\n  });\n\n  it('supports setting date properties with strict: false (gh-7907)', function() {\n    const schema = Schema({}, { strict: false });\n    const SettingsModel = db.model('Test', schema);\n\n    const date = new Date();\n    const obj = new SettingsModel({\n      timestamp: date,\n      subDoc: {\n        timestamp: date\n      }\n    });\n\n    assert.strictEqual(obj.timestamp, date);\n    assert.strictEqual(obj.subDoc.timestamp, date);\n  });\n\n  it('handles .set() on doc array within embedded discriminator (gh-7656)', function() {\n    const pageElementSchema = new Schema({\n      type: { type: String, required: true }\n    }, { discriminatorKey: 'type' });\n\n    const textElementSchema = new Schema({\n      body: { type: String }\n    });\n\n    const blockElementSchema = new Schema({\n      elements: [pageElementSchema]\n    });\n\n    blockElementSchema.path('elements').discriminator('block', blockElementSchema);\n    blockElementSchema.path('elements').discriminator('text', textElementSchema);\n\n    const pageSchema = new Schema({ elements: [pageElementSchema] });\n\n    pageSchema.path('elements').discriminator('block', blockElementSchema);\n    pageSchema.path('elements').discriminator('text', textElementSchema);\n\n    const Page = db.model('Test', pageSchema);\n    const page = new Page({\n      elements: [\n        { type: 'text', body: 'Page Title' },\n        { type: 'block', elements: [{ type: 'text', body: 'Page Content' }] }\n      ]\n    });\n\n    page.set('elements.0.body', 'Page Heading');\n    assert.equal(page.elements[0].body, 'Page Heading');\n    assert.equal(page.get('elements.0.body'), 'Page Heading');\n\n    page.set('elements.1.elements.0.body', 'Page Body');\n    assert.equal(page.elements[1].elements[0].body, 'Page Body');\n    assert.equal(page.get('elements.1.elements.0.body'), 'Page Body');\n\n    page.elements[1].elements[0].body = 'Page Body';\n    assert.equal(page.elements[1].elements[0].body, 'Page Body');\n    assert.equal(page.get('elements.1.elements.0.body'), 'Page Body');\n  });\n\n  it('$isEmpty() (gh-5369)', function() {\n    const schema = new Schema({\n      nested: { foo: String },\n      subdoc: new Schema({ bar: String }, { _id: false }),\n      docArr: [new Schema({ baz: String }, { _id: false })],\n      mixed: {}\n    });\n\n    const Model = db.model('Test', schema);\n    const doc = new Model({ subdoc: {}, docArr: [{}] });\n\n    assert.ok(doc.nested.$isEmpty());\n    assert.ok(doc.subdoc.$isEmpty());\n    assert.ok(doc.docArr[0].$isEmpty());\n    assert.ok(doc.$isEmpty('nested'));\n    assert.ok(doc.$isEmpty('subdoc'));\n    assert.ok(doc.$isEmpty('docArr.0'));\n    assert.ok(doc.$isEmpty('mixed'));\n\n    doc.nested.foo = 'test';\n    assert.ok(!doc.nested.$isEmpty());\n    assert.ok(doc.subdoc.$isEmpty());\n    assert.ok(doc.docArr[0].$isEmpty());\n    assert.ok(!doc.$isEmpty('nested'));\n    assert.ok(doc.$isEmpty('subdoc'));\n    assert.ok(doc.$isEmpty('docArr.0'));\n    assert.ok(doc.$isEmpty('mixed'));\n\n    doc.subdoc.bar = 'test';\n    assert.ok(!doc.nested.$isEmpty());\n    assert.ok(!doc.subdoc.$isEmpty());\n    assert.ok(doc.docArr[0].$isEmpty());\n    assert.ok(!doc.$isEmpty('nested'));\n    assert.ok(!doc.$isEmpty('subdoc'));\n    assert.ok(doc.$isEmpty('docArr.0'));\n    assert.ok(doc.$isEmpty('mixed'));\n\n    doc.docArr[0].baz = 'test';\n    assert.ok(!doc.nested.$isEmpty());\n    assert.ok(!doc.subdoc.$isEmpty());\n    assert.ok(!doc.docArr[0].$isEmpty());\n    assert.ok(!doc.$isEmpty('nested'));\n    assert.ok(!doc.$isEmpty('subdoc'));\n    assert.ok(!doc.$isEmpty('docArr.0'));\n    assert.ok(doc.$isEmpty('mixed'));\n\n    doc.mixed = {};\n    assert.ok(doc.$isEmpty('mixed'));\n\n    doc.mixed.test = 1;\n    assert.ok(!doc.$isEmpty('mixed'));\n\n    return Promise.resolve();\n  });\n\n  it('push() onto discriminator doc array (gh-7704)', function() {\n    const opts = {\n      minimize: false, // So empty objects are returned\n      strict: true,\n      typeKey: '$type', // So that we can use fields named `type`\n      discriminatorKey: 'type'\n    };\n\n    const IssueSchema = new mongoose.Schema({\n      _id: String,\n      text: String,\n      type: String\n    }, opts);\n\n    const IssueModel = db.model('Test', IssueSchema);\n\n    const SubIssueSchema = new mongoose.Schema({\n      checklist: [{\n        completed: { $type: Boolean, default: false }\n      }]\n    }, opts);\n    IssueModel.discriminator('gh7704_sub', SubIssueSchema);\n\n    const doc = new IssueModel({ _id: 'foo', text: 'text', type: 'gh7704_sub' });\n    doc.checklist.push({ completed: true });\n\n    assert.ifError(doc.validateSync());\n\n    return Promise.resolve();\n  });\n\n  it('doesnt call getter when saving (gh-7719)', function() {\n    let called = 0;\n    const kittySchema = new mongoose.Schema({\n      name: {\n        type: String,\n        get: function(v) {\n          ++called;\n          return v;\n        }\n      }\n    });\n    const Kitten = db.model('Test', kittySchema);\n\n    const k = new Kitten({ name: 'Mr Sprinkles' });\n    return k.save().then(() => assert.equal(called, 0));\n  });\n\n  it('skips malformed validators property (gh-7720)', function() {\n    const NewSchema = new Schema({\n      object: {\n        type: 'string',\n        validators: ['string'] // This caused the issue\n      }\n    });\n\n    const TestModel = db.model('Test', NewSchema);\n    const instance = new TestModel();\n    instance.object = 'value';\n\n    assert.ifError(instance.validateSync());\n\n    return instance.validate();\n  });\n\n  it('nested set on subdocs works (gh-7748)', async function() {\n    const geojsonSchema = new Schema({\n      type: { type: String, default: 'Feature' },\n      geometry: {\n        type: {\n          type: String,\n          required: true\n        },\n        coordinates: { type: [] }\n      },\n      properties: { type: Object }\n    });\n\n    const userSchema = new Schema({\n      position: geojsonSchema\n    });\n\n    const User = db.model('User', userSchema);\n\n    const position = {\n      geometry: {\n        type: 'Point',\n        coordinates: [1.11111, 2.22222]\n      },\n      properties: {\n        a: 'b'\n      }\n    };\n\n    const newUser = new User({\n      position: position\n    });\n\n    await newUser.save();\n\n    const editUser = await User.findById(newUser._id);\n    editUser.position = position;\n\n    await editUser.validate();\n    await editUser.save();\n\n    const fromDb = await User.findById(newUser._id);\n    assert.equal(fromDb.position.properties.a, 'b');\n    assert.equal(fromDb.position.geometry.coordinates[0], 1.11111);\n  });\n\n  it('does not convert array to object with strict: false (gh-7733)', async function() {\n    const ProductSchema = new mongoose.Schema({}, { strict: false });\n    const Product = db.model('Test', ProductSchema);\n\n\n    await Product.create({ arr: [{ test: 1 }, { test: 2 }] });\n\n    const doc = await Product.collection.findOne();\n    assert.ok(Array.isArray(doc.arr));\n    assert.deepEqual(doc.arr, [{ test: 1 }, { test: 2 }]);\n  });\n\n  it('does not crash with array property named \"undefined\" (gh-7756)', async function() {\n    const schema = new Schema({ undefined: [String] });\n    const Model = db.model('Test', schema);\n\n\n    const doc = await Model.create({ undefined: ['foo'] });\n\n    doc['undefined'].push('bar');\n    await doc.save();\n\n    const _doc = await Model.collection.findOne();\n    assert.equal(_doc['undefined'][0], 'foo');\n  });\n\n  it('fires pre save hooks on nested child schemas (gh-7792)', function() {\n    const childSchema1 = new mongoose.Schema({ name: String });\n    let called1 = 0;\n    childSchema1.pre('save', function() {\n      ++called1;\n    });\n\n    const childSchema2 = new mongoose.Schema({ name: String });\n    let called2 = 0;\n    childSchema2.pre('save', function() {\n      ++called2;\n    });\n\n    const parentSchema = new mongoose.Schema({\n      nested: {\n        child: childSchema1,\n        arr: [childSchema2]\n      }\n    });\n\n    const Parent = db.model('Parent', parentSchema);\n\n    const obj = { nested: { child: { name: 'foo' }, arr: [{ name: 'bar' }] } };\n    return Parent.create(obj).then(() => {\n      assert.equal(called1, 1);\n      assert.equal(called2, 1);\n    });\n  });\n\n  it('takes message from async custom validator promise rejection (gh-4913)', function() {\n    const schema = new Schema({\n      name: {\n        type: String,\n        validate: async function() {\n          await Promise.resolve((resolve) => setImmediate(resolve));\n          throw new Error('Oops!');\n        }\n      }\n    });\n    const Model = db.model('Test', schema);\n\n    return Model.create({ name: 'foo' }).then(() => assert.ok(false), err => {\n      assert.equal(err.errors['name'].message, 'Oops!');\n      assert.ok(err.message.indexOf('Oops!') !== -1, err.message);\n    });\n  });\n\n  it('handles nested properties named `schema` (gh-7831)', async function() {\n    const schema = new mongoose.Schema({ nested: { schema: String } });\n    const Model = db.model('Test', schema);\n\n    await Model.collection.insertOne({ nested: { schema: 'test' } });\n\n    const doc = await Model.findOne();\n    assert.strictEqual(doc.nested.schema, 'test');\n  });\n\n  it('handles nested properties named `on` (gh-11656)', async function() {\n    const schema = new mongoose.Schema({ on: String }, { supressReservedKeysWarning: true });\n    const Model = db.model('Test', schema);\n\n    await Model.create({ on: 'test string' });\n\n    const doc = await Model.findOne();\n    assert.strictEqual(doc.on, 'test string');\n  });\n\n  describe('overwrite() (gh-7830)', function() {\n    let Model;\n\n    beforeEach(function() {\n      const schema = new Schema({\n        _id: Number,\n        name: String,\n        nested: {\n          prop: String\n        },\n        arr: [Number],\n        immutable: {\n          type: String,\n          immutable: true\n        }\n      });\n      Model = db.model('Test', schema);\n    });\n\n    it('works', async function() {\n\n      const doc = await Model.create({\n        _id: 1,\n        name: 'test',\n        nested: { prop: 'foo' },\n        immutable: 'bar'\n      });\n      doc.overwrite({ name: 'test2' });\n\n      assert.deepEqual(doc.toObject(), {\n        _id: 1,\n        __v: 0,\n        name: 'test2',\n        immutable: 'bar'\n      });\n    });\n\n    it('skips version key', async function() {\n\n      await Model.collection.insertOne({\n        _id: 2,\n        __v: 5,\n        name: 'test',\n        nested: { prop: 'foo' },\n        immutable: 'bar'\n      });\n      const doc = await Model.findOne({ _id: 2 });\n      doc.overwrite({ _id: 2, name: 'test2' });\n\n      assert.deepEqual(doc.toObject(), {\n        _id: 2,\n        __v: 5,\n        name: 'test2',\n        immutable: 'bar'\n      });\n    });\n\n    it('skips discriminator key', async function() {\n\n      const D = Model.discriminator('D', Schema({ other: String }));\n      await Model.collection.insertOne({\n        _id: 2,\n        __v: 5,\n        __t: 'D',\n        name: 'test',\n        nested: { prop: 'foo' },\n        immutable: 'bar',\n        other: 'baz'\n      });\n      const doc = await D.findOne({ _id: 2 });\n      doc.overwrite({ _id: 2, name: 'test2' });\n\n      assert.deepEqual(doc.toObject(), {\n        _id: 2,\n        __v: 5,\n        __t: 'D',\n        name: 'test2',\n        immutable: 'bar'\n      });\n      return doc.validate();\n    });\n\n    it('overwrites maps (gh-9549)', async function() {\n      const schema = new Schema({\n        name: String,\n        myMap: { type: Map, of: String }\n      });\n      db.deleteModel(/Test/);\n      const Test = db.model('Test', schema);\n\n      let doc = new Test({ name: 'test', myMap: { a: 1, b: 2 } });\n\n\n      await doc.save();\n\n      doc = await Test.findById(doc);\n      doc.overwrite({ name: 'test2', myMap: { b: 2, c: 3 } });\n      await doc.save();\n\n      doc = await Test.findById(doc);\n      assert.deepEqual(Array.from(doc.toObject().myMap.values()), [2, 3]);\n    });\n  });\n\n  it('copies virtuals from array subdocs when casting array of docs with same schema (gh-7898)', function() {\n    const ChildSchema = new Schema({ name: String },\n      { _id: false, id: false });\n\n    ChildSchema.virtual('foo').\n      set(function(foo) { this.__foo = foo; }).\n      get(function() { return this.__foo || 0; });\n\n    const ParentSchema = new Schema({\n      name: String,\n      children: [ChildSchema]\n    }, { _id: false, id: false });\n\n    const WrapperSchema = new Schema({\n      name: String,\n      parents: [ParentSchema]\n    }, { _id: false, id: false });\n\n    const Parent = db.model('Parent', ParentSchema);\n    const Wrapper = db.model('Test', WrapperSchema);\n\n    const data = { name: 'P1', children: [{ name: 'C1' }, { name: 'C2' }] };\n    const parent = new Parent(data);\n    parent.children[0].foo = 123;\n\n    const wrapper = new Wrapper({ name: 'test', parents: [parent] });\n    assert.equal(wrapper.parents[0].children[0].foo, 123);\n  });\n\n  describe('immutable properties (gh-7671)', function() {\n    let Model;\n\n    beforeEach(function() {\n      const schema = new Schema({\n        createdAt: {\n          type: Date,\n          immutable: true,\n          default: new Date('6/1/2019')\n        },\n        name: String\n      });\n      Model = db.model('Test', schema);\n    });\n\n    it('SchemaType#immutable()', function() {\n      const schema = new Schema({\n        createdAt: {\n          type: Date,\n          default: new Date('6/1/2019')\n        },\n        name: String\n      });\n\n      assert.ok(!schema.path('createdAt').$immutable);\n\n      schema.path('createdAt').immutable(true);\n      assert.ok(schema.path('createdAt').$immutable);\n      assert.equal(schema.path('createdAt').setters.length, 1);\n\n      schema.path('createdAt').immutable(false);\n      assert.ok(!schema.path('createdAt').$immutable);\n      assert.equal(schema.path('createdAt').setters.length, 0);\n    });\n\n    it('with save()', async function() {\n      let doc = new Model({ name: 'Foo' });\n\n      assert.equal(doc.createdAt.toLocaleDateString('en-us'), '6/1/2019');\n      await doc.save();\n\n      doc = await Model.findOne({ createdAt: new Date('6/1/2019') });\n      doc.createdAt = new Date('6/1/2017');\n      assert.equal(doc.createdAt.toLocaleDateString('en-us'), '6/1/2019');\n\n      doc.set({ createdAt: new Date('6/1/2021') });\n      assert.equal(doc.createdAt.toLocaleDateString('en-us'), '6/1/2019');\n\n      await doc.save();\n\n      doc = await Model.findOne({ createdAt: new Date('6/1/2019') });\n      assert.ok(doc);\n    });\n\n    it('with update', async function() {\n      let doc = new Model({ name: 'Foo' });\n\n      assert.equal(doc.createdAt.toLocaleDateString('en-us'), '6/1/2019');\n      await doc.save();\n\n      const update = { createdAt: new Date('6/1/2020') };\n\n      await Model.updateOne({}, update);\n\n      doc = await Model.findOne();\n      assert.equal(doc.createdAt.toLocaleDateString('en-us'), '6/1/2019');\n\n      const err = await Model.updateOne({}, update, { strict: 'throw' }).\n        then(() => null, err => err);\n      assert.equal(err.name, 'StrictModeError');\n      assert.ok(err.message.indexOf('createdAt') !== -1, err.message);\n    });\n\n    it('conditional immutable (gh-8001)', async function() {\n      const schema = new Schema({\n        name: String,\n        test: {\n          type: String,\n          immutable: doc => doc.name === 'foo'\n        }\n      });\n      const Model = db.model('Test1', schema);\n\n\n      const doc1 = await Model.create({ name: 'foo', test: 'before' });\n      const doc2 = await Model.create({ name: 'bar', test: 'before' });\n\n      doc1.set({ test: 'after' });\n      doc2.set({ test: 'after' });\n      await doc1.save();\n      await doc2.save();\n\n      const fromDb1 = await Model.collection.findOne({ name: 'foo' });\n      const fromDb2 = await Model.collection.findOne({ name: 'bar' });\n      assert.equal(fromDb1.test, 'before');\n      assert.equal(fromDb2.test, 'after');\n    });\n\n    it('immutable with strict mode (gh-8149)', async function() {\n\n      const schema = new mongoose.Schema({\n        name: String,\n        yearOfBirth: { type: Number, immutable: true }\n      }, { strict: 'throw' });\n      const Person = db.model('Person', schema);\n      const joe = await Person.create({ name: 'Joe', yearOfBirth: 2001 });\n\n      joe.set({ yearOfBirth: 2002 });\n      const err = await joe.save().then(() => null, err => err);\n      assert.ok(err);\n      assert.equal(err.errors['yearOfBirth'].name, 'StrictModeError');\n    });\n  });\n\n  it('consistent post order traversal for array subdocs (gh-7929)', function() {\n    const Grandchild = Schema({ value: Number });\n    const Child = Schema({ children: [Grandchild] });\n    const Parent = Schema({ children: [Child] });\n\n    const calls = [];\n    Grandchild.pre('save', () => calls.push(1));\n    Child.pre('save', () => calls.push(2));\n    Parent.pre('save', () => calls.push(3));\n\n    const Model = db.model('Parent', Parent);\n\n    return Model.create({ children: [{ children: [{ value: 3 }] }] }).then(() => {\n      assert.deepEqual(calls, [1, 2, 3]);\n    });\n  });\n\n  it('respects projection for getters (gh-7940)', async function() {\n    const schema = new Schema({\n      foo: String,\n      bar: {\n        type: String,\n        get: () => {\n          return 'getter value';\n        }\n      }\n    }, { toObject: { getters: true } });\n\n    const Model = db.model('Test', schema);\n\n\n    await Model.create({ foo: 'test', bar: 'baz' });\n\n    const doc = await Model.findOne({ foo: 'test' }, 'foo');\n\n    assert.ok(!doc.toObject().bar);\n  });\n\n  it('loads doc with a `once` property successfully (gh-7958)', async function() {\n    const eventSchema = Schema({ once: { prop: String } });\n    const Event = db.model('Test', eventSchema);\n\n\n    await Event.create({ once: { prop: 'test' } });\n\n    const doc = await Event.findOne();\n    assert.equal(doc.once.prop, 'test');\n  });\n\n  it('caster that converts to Number class works (gh-8150)', async function() {\n\n    const mySchema = new Schema({\n      id: {\n        type: Number,\n        set: value => new Number(value.valueOf())\n      }\n    });\n\n    const MyModel = db.model('Test', mySchema);\n\n    await MyModel.create({ id: 12345 });\n\n    const doc = await MyModel.findOne({ id: 12345 });\n    assert.ok(doc);\n  });\n\n  it('handles objectids and decimals with strict: false (gh-7973)', async function() {\n    const testSchema = Schema({}, { strict: false });\n    const Test = db.model('Test', testSchema);\n\n    let doc = new Test({\n      testId: new mongoose.Types.ObjectId(),\n      testDecimal: new mongoose.Types.Decimal128('1.23')\n    });\n\n    assert.ok(doc.testId instanceof mongoose.Types.ObjectId);\n    assert.ok(doc.testDecimal instanceof mongoose.Types.Decimal128);\n\n\n    await doc.save();\n\n    doc = await Test.collection.findOne();\n    assert.ok(doc.testId instanceof mongoose.Types.ObjectId);\n    assert.ok(doc.testDecimal instanceof mongoose.Types.Decimal128);\n  });\n\n  it('allows enum on array of array of strings (gh-7926)', function() {\n    const schema = new Schema({\n      test: {\n        type: [[String]],\n        enum: ['bar']\n      }\n    });\n\n    const Model = db.model('Test', schema);\n\n    return Model.create({ test: [['foo']] }).then(() => assert.ok(false), err => {\n      assert.ok(err);\n      assert.ok(err.errors['test.0.0']);\n      assert.ok(err.errors['test.0.0'].message.indexOf('foo') !== -1,\n        err.errors['test.0.0'].message);\n    });\n  });\n\n  it('allows saving an unchanged document if required populated path is null (gh-8018)', async function() {\n    const schema = Schema({ test: String });\n    const schema2 = Schema({\n      keyToPopulate: {\n        type: mongoose.Schema.Types.ObjectId,\n        ref: 'Child',\n        required: true\n      }\n    });\n\n    const Child = db.model('Child', schema);\n    const Parent = db.model('Parent', schema2);\n\n\n    const child = await Child.create({ test: 'test' });\n    await Parent.create({ keyToPopulate: child._id });\n\n    await child.deleteOne();\n\n    const doc = await Parent.findOne().populate('keyToPopulate');\n\n    // Should not throw\n    await doc.save();\n  });\n\n  it('only calls validator once on mixed validator (gh-8067)', function() {\n    let called = 0;\n    function validator() {\n      ++called;\n      return true;\n    }\n\n    const itemArray = new Schema({\n      timer: {\n        time: {\n          type: {},\n          validate: {\n            validator: validator\n          }\n        }\n      }\n    });\n\n    const schema = new Schema({\n      items: [itemArray]\n    });\n    const Model = db.model('Test', schema);\n\n    const obj = new Model({\n      items: [\n        { timer: { time: { type: { hours: 24, allowed: true } } } }\n      ]\n    });\n\n    obj.validateSync();\n    assert.equal(called, 1);\n  });\n\n  it('only calls validator once on nested mixed validator (gh-8117)', function() {\n    const called = [];\n    const Model = db.model('Test', Schema({\n      name: { type: String },\n      level1: {\n        level2: {\n          type: Object,\n          validate: {\n            validator: v => {\n              called.push(v);\n              return true;\n            }\n          }\n        }\n      }\n    }));\n\n    const doc = new Model({ name: 'bob' });\n    doc.level1 = { level2: { a: 'one', b: 'two', c: 'three' } };\n    return doc.validate().then(() => {\n      assert.equal(called.length, 1);\n      assert.deepEqual(called[0], { a: 'one', b: 'two', c: 'three' });\n    });\n  });\n\n  it('handles populate() with custom type that does not cast to doc (gh-8062)', async function() {\n    class Gh8062 extends mongoose.SchemaType {\n      cast(val) {\n        if (typeof val === 'string') {\n          return val;\n        }\n        throw new Error('Failed!');\n      }\n    }\n\n    mongoose.Schema.Types.Gh8062 = Gh8062;\n\n    const schema = new Schema({ arr: [{ type: Gh8062, ref: 'Child' }] });\n    const Model = db.model('Test', schema);\n    const Child = db.model('Child', Schema({ _id: Gh8062 }));\n\n\n    await Child.create({ _id: 'test' });\n    await Model.create({ arr: ['test'] });\n\n    const doc = await Model.findOne().populate('arr');\n    assert.ok(doc.populated('arr'));\n    assert.equal(doc.arr[0]._id, 'test');\n    assert.ok(doc.arr[0].$__ != null);\n  });\n\n  it('can inspect() on a document array (gh-8037)', function() {\n    const subdocSchema = mongoose.Schema({ a: String });\n    const schema = mongoose.Schema({ subdocs: { type: [subdocSchema] } });\n    const Model = db.model('Test', schema);\n    const data = { _id: new mongoose.Types.ObjectId(), subdocs: [{ a: 'a' }] };\n    const doc = new Model();\n    doc.init(data);\n    require('util').inspect(doc.subdocs);\n  });\n\n  it('always passes unpopulated paths to validators (gh-8042)', async function() {\n    const schema = Schema({ test: String });\n\n    const calledWith = [];\n    function validate(v) {\n      calledWith.push(v);\n      return true;\n    }\n    const schema2 = Schema({\n      keyToPopulate: {\n        type: mongoose.Schema.Types.ObjectId,\n        ref: 'gh8018_child',\n        required: true,\n        validate: validate\n      },\n      array: [{\n        type: mongoose.Schema.Types.ObjectId,\n        ref: 'gh8018_child',\n        required: true,\n        validate: validate\n      }],\n      subdoc: Schema({\n        keyToPopulate: {\n          type: mongoose.Schema.Types.ObjectId,\n          ref: 'gh8018_child',\n          required: true,\n          validate: validate\n        }\n      })\n    });\n\n    const Child = db.model('gh8018_child', schema);\n    const Parent = db.model('gh8018_parent', schema2);\n\n\n    const child = await Child.create({ test: 'test' });\n    await Parent.create({ keyToPopulate: child, array: [child], subdoc: { keyToPopulate: child } });\n\n    assert.equal(calledWith.length, 3);\n\n    assert.ok(calledWith[0] instanceof mongoose.Types.ObjectId);\n    assert.ok(calledWith[1] instanceof mongoose.Types.ObjectId);\n    assert.ok(calledWith[2] instanceof mongoose.Types.ObjectId);\n\n    await child.deleteOne();\n\n    const doc = await Parent.findOne().populate(['keyToPopulate', 'array', 'subdoc']);\n    assert.equal(doc.keyToPopulate, null);\n\n    // Should not throw\n    await doc.save();\n  });\n\n  it('set() merge option with single nested (gh-8201)', async function() {\n    const AddressSchema = Schema({\n      street: { type: String, required: true },\n      city: { type: String, required: true }\n    });\n    const PersonSchema = Schema({\n      name: { type: String, required: true },\n      address: { type: AddressSchema, required: true }\n    });\n    const Person = db.model('Person', PersonSchema);\n\n\n    await Person.create({\n      name: 'John Smith',\n      address: {\n        street: 'Real Street',\n        city: 'Somewhere'\n      }\n    });\n\n    const person = await Person.findOne();\n    const obj = {\n      name: 'John Smythe',\n      address: { street: 'Fake Street' }\n    };\n    person.set(obj, undefined, { merge: true });\n\n    assert.equal(person.address.city, 'Somewhere');\n    await person.save();\n  });\n\n  it('setting single nested subdoc with timestamps (gh-8251)', async function() {\n    const ActivitySchema = Schema({ description: String }, { timestamps: true });\n    const RequestSchema = Schema({ activity: ActivitySchema });\n    const Request = db.model('Test', RequestSchema);\n\n\n    const doc = await Request.create({\n      activity: { description: 'before' }\n    });\n    doc.activity.set({ description: 'after' });\n    await doc.save();\n\n    const fromDb = await Request.findOne().lean();\n    assert.equal(fromDb.activity.description, 'after');\n  });\n\n  it('passing an object with toBSON() into `save()` (gh-8299)', async function() {\n    const ActivitySchema = Schema({ description: String });\n    const RequestSchema = Schema({ activity: ActivitySchema });\n    const Request = db.model('Test', RequestSchema);\n\n\n    const doc = await Request.create({\n      activity: { description: 'before' }\n    });\n    doc.activity.set({ description: 'after' });\n    await doc.save();\n\n    const fromDb = await Request.findOne().lean();\n    assert.equal(fromDb.activity.description, 'after');\n  });\n\n  it('handles getter setting virtual on manually populated doc when calling toJSON (gh-8295)', function() {\n    const childSchema = Schema({}, { toJSON: { getters: true } });\n    childSchema.virtual('field').\n      get(function() { return this._field; }).\n      set(function(v) { return this._field = v; });\n    const Child = db.model('Child', childSchema);\n\n    const parentSchema = Schema({\n      child: { type: mongoose.ObjectId, ref: 'Child', get: get }\n    }, { toJSON: { getters: true } });\n    const Parent = db.model('Parent', parentSchema);\n\n    function get(child) {\n      child.field = true;\n      return child;\n    }\n\n    let p = new Parent({ child: new Child({}) });\n    assert.strictEqual(p.toJSON().child.field, true);\n\n    p = new Parent({ child: new Child({}) });\n    assert.strictEqual(p.child.toJSON().field, true);\n  });\n\n  it('enum validator for number (gh-8139)', function() {\n    const schema = Schema({\n      num: {\n        type: Number,\n        enum: [1, 2, 3]\n      }\n    });\n    const Model = db.model('Test', schema);\n\n    let doc = new Model({});\n    let err = doc.validateSync();\n    assert.ifError(err);\n\n    doc = new Model({ num: 4 });\n    err = doc.validateSync();\n    assert.ok(err);\n    assert.equal(err.errors['num'].name, 'ValidatorError');\n\n    doc = new Model({ num: 2 });\n    err = doc.validateSync();\n    assert.ifError(err);\n  });\n\n  it('enum object syntax for number (gh-10648) (gh-8139)', function() {\n    const schema = Schema({\n      num: {\n        type: Number,\n        enum: {\n          values: [1, 2, 3],\n          message: 'Invalid number'\n        }\n      }\n    });\n    const Model = db.model('Test', schema);\n\n    let doc = new Model({});\n    let err = doc.validateSync();\n    assert.ifError(err);\n\n    doc = new Model({ num: 4 });\n    err = doc.validateSync();\n    assert.ok(err);\n    assert.equal(err.errors['num'].name, 'ValidatorError');\n    assert.equal(err.errors['num'].message, 'Invalid number');\n\n    doc = new Model({ num: 2 });\n    err = doc.validateSync();\n    assert.ifError(err);\n  });\n\n  it('support `pathsToValidate()` option for `validate()` (gh-7587)', async function() {\n    const schema = Schema({\n      name: {\n        type: String,\n        required: true\n      },\n      age: {\n        type: Number,\n        required: true\n      },\n      rank: String\n    });\n    const Model = db.model('Test', schema);\n\n\n    const doc = new Model({});\n\n    let err = await doc.validate(['name', 'rank']).catch(err => err);\n    assert.deepEqual(Object.keys(err.errors), ['name']);\n\n    err = await doc.validate(['age', 'rank']).catch(err => err);\n    assert.deepEqual(Object.keys(err.errors), ['age']);\n  });\n\n  it('array push with $position (gh-4322)', async function() {\n    const schema = Schema({\n      nums: [Number]\n    });\n    const Model = db.model('Test', schema);\n\n\n    const doc = await Model.create({ nums: [3, 4] });\n\n    doc.nums.push({\n      $each: [1, 2],\n      $position: 0\n    });\n    assert.deepEqual(doc.toObject().nums, [1, 2, 3, 4]);\n\n    await doc.save();\n\n    const fromDb = await Model.findOne({ _id: doc._id });\n    assert.deepEqual(fromDb.toObject().nums, [1, 2, 3, 4]);\n\n    doc.nums.push({\n      $each: [0],\n      $position: 0\n    });\n    assert.throws(() => {\n      doc.nums.push({ $each: [5] });\n    }, /Cannot call.*multiple times/);\n    assert.throws(() => {\n      doc.nums.push(5);\n    }, /Cannot call.*multiple times/);\n  });\n\n  it('setting a path to a single nested document should update the single nested doc parent (gh-8400)', function() {\n    const schema = Schema({\n      name: String,\n      subdoc: new Schema({\n        name: String\n      })\n    });\n    const Model = db.model('Test', schema);\n\n    const doc1 = new Model({ name: 'doc1', subdoc: { name: 'subdoc1' } });\n    const doc2 = new Model({ name: 'doc2', subdoc: { name: 'subdoc2' } });\n\n    doc1.subdoc = doc2.subdoc;\n    assert.equal(doc1.subdoc.name, 'subdoc2');\n    assert.equal(doc2.subdoc.name, 'subdoc2');\n    assert.strictEqual(doc1.subdoc.ownerDocument(), doc1);\n    assert.strictEqual(doc2.subdoc.ownerDocument(), doc2);\n  });\n\n  it('setting an array to an array with some populated documents depopulates the whole array (gh-8443)', async function() {\n    const A = db.model('Test1', Schema({\n      name: String,\n      rel: [{ type: mongoose.ObjectId, ref: 'Test' }]\n    }));\n\n    const B = db.model('Test', Schema({ name: String }));\n\n\n    const b = await B.create({ name: 'testb' });\n    await A.create({ name: 'testa', rel: [b._id] });\n\n    const a = await A.findOne().populate('rel');\n\n    const b2 = await B.create({ name: 'testb2' });\n    a.rel = [a.rel[0], b2._id];\n    await a.save();\n\n    assert.ok(!a.populated('rel'));\n    assert.ok(a.rel[0] instanceof mongoose.Types.ObjectId);\n    assert.ok(a.rel[1] instanceof mongoose.Types.ObjectId);\n  });\n\n  it('handles errors with name set to \"ValidationError\" (gh-8466)', () => {\n    const childSchema = Schema({ name: String });\n\n    childSchema.pre('validate', function() {\n      if (this.name === 'Invalid') {\n        const error = new Error('invalid name');\n        error.name = 'ValidationError';\n        throw error;\n      }\n    });\n\n    const fatherSchema = Schema({ children: [childSchema] });\n    const Father = db.model('Test', fatherSchema);\n\n    const doc = new Father({\n      children: [{ name: 'Valid' }, { name: 'Invalid' }]\n    });\n\n    return doc.validate().then(() => assert.ok(false), err => {\n      assert.ok(err);\n      assert.ok(err.errors['children']);\n      assert.equal(err.errors['children'].message, 'invalid name');\n    });\n  });\n\n  it('throws an error if running validate() multiple times in parallel (gh-8468)', () => {\n    const Model = db.model('Test', Schema({ name: String }));\n\n    const doc = new Model({ name: 'test' });\n\n    doc.validate();\n\n    return doc.save().then(() => assert.ok(false), err => {\n      assert.equal(err.name, 'ParallelValidateError');\n    });\n  });\n\n  it('avoids parallel validate error when validating nested path with double nested subdocs (gh-8486)', async function() {\n    const testSchema = new Schema({\n      foo: {\n        bar: Schema({\n          baz: Schema({\n            num: Number\n          })\n        })\n      }\n    });\n    const Test = db.model('Test', testSchema);\n\n\n    const doc = await Test.create({});\n\n    doc.foo = {\n      bar: {\n        baz: {\n          num: 1\n        }\n      }\n    };\n\n    // Should not throw\n    await doc.save();\n\n    const raw = await Test.collection.findOne();\n    assert.equal(raw.foo.bar.baz.num, 1);\n  });\n\n  it('supports function for date min/max validator error (gh-8512)', function() {\n    const schema = Schema({\n      startDate: {\n        type: Date,\n        required: true,\n        min: [new Date('2020-01-01'), () => 'test']\n      }\n    });\n\n    db.deleteModel(/Test/);\n    const Model = db.model('Test', schema);\n    const doc = new Model({ startDate: new Date('2019-06-01') });\n\n    const err = doc.validateSync();\n    assert.ok(err.errors['startDate']);\n    assert.equal(err.errors['startDate'].message, 'test');\n  });\n\n  it('sets parent and ownerDocument correctly with document array default (gh-8509)', async function() {\n    const locationSchema = Schema({\n      name: String,\n      city: String\n    });\n    const owners = [];\n\n    // Middleware to set a default location name derived from the parent organization doc\n    locationSchema.pre('validate', function(next) {\n      const owner = this.ownerDocument();\n      owners.push(owner);\n      if (this.isNew && !this.get('name') && owner.get('name')) {\n        this.set('name', `${owner.get('name')} Office`);\n      }\n      next();\n    });\n\n    const organizationSchema = Schema({\n      name: String,\n      // Having a default doc this way causes issues\n      locations: { type: [locationSchema], default: [{}] }\n    });\n    const Organization = db.model('Test', organizationSchema);\n\n    const org = new Organization();\n    org.set('name', 'MongoDB');\n\n    await org.save();\n\n    assert.equal(owners.length, 1);\n    assert.ok(owners[0] === org);\n\n    assert.equal(org.locations[0].name, 'MongoDB Office');\n  });\n\n  it('doesnt add `null` if property is undefined with minimize false (gh-8504)', async function() {\n    const minimize = false;\n    const schema = Schema({\n      num: Number,\n      beta: { type: String }\n    },\n    {\n      toObject: { virtuals: true, minimize: minimize },\n      toJSON: { virtuals: true, minimize: minimize }\n    }\n    );\n    const Test = db.model('Test', schema);\n\n    const dummy1 = new Test({ num: 1, beta: null });\n    const dummy2 = new Test({ num: 2, beta: void 0 });\n\n\n    await dummy1.save();\n    await dummy2.save();\n\n    const res = await Test.find().lean().sort({ num: 1 });\n\n    assert.strictEqual(res[0].beta, null);\n    assert.ok(!res[1].hasOwnProperty('beta'));\n  });\n\n  it('creates document array defaults in forward order, not reverse (gh-8514)', function() {\n    let num = 0;\n    const schema = Schema({\n      arr: [{ val: { type: Number, default: () => ++num } }]\n    });\n    const Model = db.model('Test', schema);\n\n    const doc = new Model({ arr: [{}, {}, {}] });\n    assert.deepEqual(doc.toObject().arr.map(v => v.val), [1, 2, 3]);\n  });\n\n  it('can call subdocument validate multiple times in parallel (gh-8539)', async function() {\n    const schema = Schema({\n      arr: [{ val: String }],\n      single: Schema({ val: String })\n    });\n    const Model = db.model('Test', schema);\n\n\n    const doc = new Model({ arr: [{ val: 'test' }], single: { val: 'test' } });\n\n    await Promise.all([doc.arr[0].validate(), doc.arr[0].validate()]);\n    await Promise.all([doc.single.validate(), doc.single.validate()]);\n  });\n\n  it('sets `Document#op` when calling `validate()` (gh-8439)', function() {\n    const schema = Schema({ name: String });\n    const ops = [];\n    schema.pre('validate', function() {\n      ops.push(this.$op);\n    });\n    schema.post('validate', function() {\n      ops.push(this.$op);\n    });\n\n    const Model = db.model('Test', schema);\n    const doc = new Model({ name: 'test' });\n\n    const promise = doc.validate();\n    assert.equal(doc.$op, 'validate');\n\n    return promise.then(() => assert.deepEqual(ops, ['validate', 'validate']));\n  });\n\n  it('schema-level transform (gh-8403)', function() {\n    const schema = Schema({\n      myDate: {\n        type: Date,\n        transform: v => v.getFullYear()\n      },\n      dates: [{\n        type: Date,\n        transform: v => v.getFullYear()\n      }],\n      arr: [{\n        myDate: {\n          type: Date,\n          transform: v => v.getFullYear()\n        }\n      }]\n    });\n    const Model = db.model('Test', schema);\n\n    const doc = new Model({\n      myDate: new Date('2015/06/01'),\n      dates: [new Date('2016/06/01')],\n      arr: [{ myDate: new Date('2017/06/01') }]\n    });\n    assert.equal(doc.toObject({ transform: true }).myDate, '2015');\n    assert.equal(doc.toObject({ transform: true }).dates[0], '2016');\n    assert.equal(doc.toObject({ transform: true }).arr[0].myDate, '2017');\n  });\n\n  it('transforms nested paths (gh-9543)', function() {\n    const schema = Schema({\n      nested: {\n        date: {\n          type: Date,\n          transform: v => v.getFullYear()\n        }\n      }\n    });\n    const Model = db.model('Test', schema);\n\n    const doc = new Model({\n      nested: {\n        date: new Date('2020-06-01')\n      }\n    });\n    assert.equal(doc.toObject({ transform: true }).nested.date, '2020');\n  });\n\n  it('handles setting numeric paths with single nested subdocs (gh-8583)', async function() {\n    const placedItemSchema = Schema({ image: String }, { _id: false });\n\n    const subdocumentSchema = Schema({\n      placedItems: {\n        1: placedItemSchema,\n        first: placedItemSchema\n      }\n    });\n    const Model = db.model('Test', subdocumentSchema);\n\n\n    const doc = await Model.create({\n      placedItems: { 1: { image: 'original' }, first: { image: 'original' } }\n    });\n\n    doc.set({\n      'placedItems.1.image': 'updated',\n      'placedItems.first.image': 'updated'\n    });\n\n    await doc.save();\n\n    assert.equal(doc.placedItems['1'].image, 'updated');\n\n    const fromDb = await Model.findById(doc);\n    assert.equal(fromDb.placedItems['1'].image, 'updated');\n  });\n\n  it('setting nested array path to non-nested array wraps values top-down (gh-8544)', function() {\n    const positionSchema = mongoose.Schema({\n      coordinates: {\n        type: [[Number]],\n        required: true\n      },\n      lines: {\n        type: [[[Number]]],\n        required: true\n      }\n    });\n\n    const Position = db.model('Test', positionSchema);\n    const position = new Position();\n\n    position.coordinates = [1, 2];\n    position.lines = [3, 4];\n\n    const obj = position.toObject();\n    assert.deepEqual(obj.coordinates, [[1, 2]]);\n    assert.deepEqual(obj.lines, [[[3, 4]]]);\n  });\n\n  it('doesnt wrap empty nested array with insufficient depth', function() {\n    const weekSchema = mongoose.Schema({\n      days: {\n        type: [[[Number]]],\n        required: true\n      }\n    });\n\n    const Week = db.model('Test', weekSchema);\n    const emptyWeek = new Week();\n\n    emptyWeek.days = [[], [], [], [], [], [], []];\n    const obj = emptyWeek.toObject();\n    assert.deepEqual(obj.days, [[], [], [], [], [], [], []]);\n  });\n\n  it('doesnt wipe out nested keys when setting nested key to empty object with minimize (gh-8565)', function() {\n    const opts = { autoIndex: false, autoCreate: false };\n    const schema1 = Schema({ plaid: { nestedKey: String } }, opts);\n    const schema2 = Schema({ plaid: { nestedKey: String } }, opts);\n    const schema3 = Schema({ plaid: { nestedKey: String } }, opts);\n\n    const Test1 = db.model('Test1', schema1);\n    const Test2 = db.model('Test2', schema2);\n    const Test3 = db.model('Test3', schema3);\n\n    const doc1 = new Test1({});\n    assert.deepEqual(doc1.toObject({ minimize: false }).plaid, {});\n\n    const doc2 = new Test2({ plaid: doc1.plaid });\n    assert.deepEqual(doc2.toObject({ minimize: false }).plaid, {});\n\n    const doc3 = new Test3({});\n    doc3.set({ plaid: doc2.plaid });\n    assert.deepEqual(doc3.toObject({ minimize: false }).plaid, {});\n  });\n\n  it('allows calling `validate()` in post validate hook without causing parallel validation error (gh-8597)', async function() {\n    const EmployeeSchema = Schema({\n      name: String,\n      employeeNumber: {\n        type: String,\n        validate: v => v.length > 5\n      }\n    });\n    let called = 0;\n\n    EmployeeSchema.post('validate', function() {\n      ++called;\n      if (!this.employeeNumber && !this._employeeNumberRetrieved) {\n        this.employeeNumber = '123456';\n        this._employeeNumberRetrieved = true;\n        return this.validate();\n      }\n    });\n\n    const Employee = db.model('Test', EmployeeSchema);\n\n\n    const e = await Employee.create({ name: 'foo' });\n    assert.equal(e.employeeNumber, '123456');\n    assert.ok(e._employeeNumberRetrieved);\n    assert.equal(called, 2);\n  });\n\n  it('sets defaults when setting single nested subdoc (gh-8603)', async function() {\n    const nestedSchema = Schema({\n      name: String,\n      status: { type: String, default: 'Pending' }\n    });\n\n    const Test = db.model('Test', {\n      nested: nestedSchema\n    });\n\n\n    let doc = await Test.create({ nested: { name: 'foo' } });\n    assert.equal(doc.nested.status, 'Pending');\n\n    doc = await Test.findById(doc);\n    assert.equal(doc.nested.status, 'Pending');\n\n    Object.assign(doc, { nested: { name: 'bar' } });\n    assert.equal(doc.nested.status, 'Pending');\n    await doc.save();\n\n    doc = await Test.findById(doc);\n    assert.equal(doc.nested.status, 'Pending');\n  });\n\n  it('handles validating single nested paths when specified in `pathsToValidate` (gh-8626)', function() {\n    const nestedSchema = Schema({\n      name: { type: String, validate: v => v.length > 2 },\n      age: { type: Number, validate: v => v < 200 }\n    });\n    const schema = Schema({ nested: nestedSchema });\n\n    mongoose.deleteModel(/Test/);\n    const Model = mongoose.model('Test', schema);\n\n    const doc = new Model({ nested: { name: 'a', age: 9001 } });\n    return doc.validate(['nested.name']).then(() => assert.ok(false), err => {\n      assert.ok(err.errors['nested.name']);\n      assert.ok(!err.errors['nested.age']);\n    });\n  });\n\n  it('copies immutable fields when constructing new doc from old doc (gh-8642)', function() {\n    const schema = Schema({ name: { type: String, immutable: true } });\n    const Model = db.model('Test', schema);\n\n    const doc = new Model({ name: 'test' });\n    doc.isNew = false;\n\n    const newDoc = new Model(doc);\n    assert.equal(newDoc.name, 'test');\n  });\n\n  it('can save nested array after setting (gh-8689)', async function() {\n    const schema = new mongoose.Schema({\n      name: String,\n      array: [[{\n        label: String,\n        value: String\n      }]]\n    });\n    const MyModel = db.model('Test', schema);\n\n\n    const doc = await MyModel.create({ name: 'foo' });\n\n    doc.set({\n      'array.0': [{\n        label: 'hello',\n        value: 'world'\n      }]\n    });\n    await doc.save();\n\n    const updatedDoc = await MyModel.findOne({ _id: doc._id });\n    assert.equal(updatedDoc.array[0][0].label, 'hello');\n    assert.equal(updatedDoc.array[0][0].value, 'world');\n  });\n\n  it('handles validator errors on subdoc paths (gh-5226)', function() {\n    const schema = Schema({\n      child: {\n        type: Schema({ name: String }),\n        validate: () => false\n      },\n      children: {\n        type: [{ name: String }],\n        validate: () => false\n      }\n    });\n    const Model = db.model('Test', schema);\n\n    const doc = new Model({ child: {}, children: [] });\n    return doc.validate().then(() => assert.ok(false), err => {\n      assert.ok(err);\n      assert.ok(err.errors);\n      assert.ok(err.errors.child);\n      assert.ok(err.errors.children);\n    });\n  });\n\n  it('reports array cast error with index (gh-8888)', function() {\n    const schema = Schema({ test: [Number] },\n      { autoIndex: false, autoCreate: false });\n    const Test = db.model('test', schema);\n\n    const t = new Test({ test: [1, 'world'] });\n    const err = t.validateSync();\n    assert.ok(err);\n    assert.ok(err.errors);\n    assert.ok(err.errors['test.1']);\n  });\n\n  it('sets defaults if setting nested path to empty object with minimize false (gh-8829)', function() {\n    const cartSchema = Schema({\n      _id: 'String',\n      item: {\n        name: { type: 'String', default: 'Default Name' }\n      }\n    },\n    { minimize: false });\n    const Test = db.model('Test', cartSchema);\n\n    const doc = new Test({ _id: 'foobar', item: {} });\n\n    return doc.save().\n      then(() => Test.collection.findOne()).\n      then(doc => assert.equal(doc.item.name, 'Default Name'));\n  });\n\n  it('clears cast errors when setting an array subpath (gh-9080)', function() {\n    const userSchema = new Schema({ tags: [Schema.ObjectId] });\n    const User = db.model('User', userSchema);\n\n    const user = new User({ tags: ['hey'] });\n    user.tags = [];\n\n    const err = user.validateSync();\n    assert.ifError(err);\n  });\n\n  it('saves successfully if you splice() a sliced array (gh-9011)', async function() {\n    const childSchema = Schema({ values: [Number] });\n    const parentSchema = Schema({ children: [childSchema] });\n\n    const Parent = db.model('Parent', parentSchema);\n\n\n    await Parent.create({\n      children: [\n        { values: [1, 2, 3] },\n        { values: [4, 5, 6] }\n      ]\n    });\n\n    const parent = await Parent.findOne();\n    const copy = parent.children[0].values.slice();\n    copy.splice(1);\n\n    await parent.save();\n    const _parent = await Parent.findOne();\n    assert.deepEqual(_parent.toObject().children[0].values, [1, 2, 3]);\n  });\n\n  it('handles modifying a subpath of a nested array of documents (gh-8926)', async function() {\n    const bookSchema = new Schema({ title: String });\n    const aisleSchema = new Schema({\n      shelves: [[bookSchema]]\n    });\n    const librarySchema = new Schema({ aisles: [aisleSchema] });\n\n    const Library = db.model('Test', librarySchema);\n\n\n    await Library.create({\n      aisles: [{ shelves: [[{ title: 'Clean Code' }]] }]\n    });\n\n    const library = await Library.findOne();\n    library.aisles[0].shelves[0][0].title = 'Refactoring';\n    await library.save();\n\n    const foundLibrary = await Library.findOne().lean();\n    assert.equal(foundLibrary.aisles[0].shelves[0][0].title, 'Refactoring');\n  });\n\n  it('Document#save accepts `timestamps` option (gh-8947) for update', async function() {\n\n    // Arrange\n    const userSchema = new Schema({ name: String }, { timestamps: true });\n    const User = db.model('User', userSchema);\n\n    const createdUser = await User.create({ name: 'Hafez' });\n\n    const user = await User.findOne({ _id: createdUser._id });\n\n    // Act\n    user.name = 'John';\n    await user.save({ timestamps: false });\n\n    // Assert\n    assert.deepEqual(createdUser.updatedAt, user.updatedAt);\n  });\n\n  it('Document#save accepts `timestamps` option (gh-8947) on inserting a new document', async function() {\n\n    // Arrange\n    const userSchema = new Schema({ name: String }, { timestamps: true });\n    const User = db.model('User', userSchema);\n\n    const user = new User({ name: 'Hafez' });\n\n    // Act\n    await user.save({ timestamps: false });\n\n    // Assert\n    assert.ok(!user.createdAt);\n    assert.ok(!user.updatedAt);\n  });\n\n  it('Sets default when passing undefined as value for a key in a nested subdoc (gh-12102) (gh-9039)', async function() {\n    const Test = db.model('Test', {\n      nested: {\n        prop: {\n          type: String,\n          default: 'some default value'\n        }\n      }\n    });\n\n    const obj = { nested: { prop: undefined } };\n    const doc = await Test.create(obj);\n    assert.equal(doc.nested.prop, 'some default value');\n\n    assert.deepStrictEqual(obj, { nested: { prop: undefined } });\n  });\n\n  it('allows accessing $locals when initializing (gh-9098)', function() {\n    const personSchema = new mongoose.Schema({\n      name: {\n        first: String,\n        last: String\n      }\n    });\n\n    personSchema.virtual('fullName').\n      get(function() { return this.$locals.fullName; }).\n      set(function(newFullName) { this.$locals.fullName = newFullName; });\n\n    const Person = db.model('Person', personSchema);\n\n    const axl = new Person({ fullName: 'Axl Rose' });\n    assert.equal(axl.fullName, 'Axl Rose');\n  });\n\n  describe('Document#getChanges(...) (gh-9096)', function() {\n    it('returns an empty object when there are no changes', async function() {\n\n      const User = db.model('User', { name: String, age: Number, country: String });\n      const user = await User.create({ name: 'Hafez', age: 25, country: 'Egypt' });\n\n      const changes = user.getChanges();\n      assert.deepEqual(changes, {});\n    });\n\n    it('returns only the changed paths', async function() {\n\n      const User = db.model('User', { name: String, age: Number, country: String });\n      const user = await User.create({ name: 'Hafez', age: 25, country: 'Egypt' });\n\n      user.country = undefined;\n      user.age = 26;\n\n      const changes = user.getChanges();\n      assert.deepEqual(changes, { $set: { age: 26 }, $unset: { country: 1 } });\n    });\n  });\n\n  it('supports skipping defaults on a document (gh-8271)', function() {\n    const testSchema = new mongoose.Schema({\n      testTopLevel: { type: String, default: 'foo' },\n      testNested: {\n        prop: { type: String, default: 'bar' }\n      },\n      testArray: [{ prop: { type: String, default: 'baz' } }],\n      testSingleNested: new Schema({\n        prop: { type: String, default: 'qux' }\n      })\n    });\n    const Test = db.model('Test', testSchema);\n\n    const doc = new Test({ testArray: [{}], testSingleNested: {} }, null,\n      { defaults: false });\n    assert.ok(!doc.testTopLevel);\n    assert.ok(!doc.testNested.prop);\n    assert.ok(!doc.testArray[0].prop);\n    assert.ok(!doc.testSingleNested.prop);\n  });\n\n  it('throws an error when `transform` returns a promise (gh-9163)', function() {\n    const userSchema = new Schema({\n      name: {\n        type: String,\n        transform: function() {\n          return new Promise(() => {});\n        }\n      }\n    });\n\n    const User = db.model('User', userSchema);\n\n    const user = new User({ name: 'Hafez' });\n    assert.throws(function() {\n      user.toJSON();\n    }, /must be synchronous/);\n\n    assert.throws(function() {\n      user.toObject();\n    }, /must be synchronous/);\n  });\n\n  it('uses strict equality when checking mixed paths for modifications (gh-9165)', function() {\n    const schema = Schema({ obj: {} });\n    const Model = db.model('gh9165', schema);\n\n    return Model.create({ obj: { key: '2' } }).\n      then(doc => {\n        doc.obj = { key: 2 };\n        assert.ok(doc.modifiedPaths().indexOf('obj') !== -1);\n        return doc.save();\n      }).\n      then(doc => Model.findById(doc)).\n      then(doc => assert.strictEqual(doc.obj.key, 2));\n  });\n\n  it('supports `useProjection` option for `toObject()` (gh-9118)', function() {\n    const authorSchema = new mongoose.Schema({\n      name: String,\n      hiddenField: { type: String, select: false }\n    });\n\n    const Author = db.model('Author', authorSchema);\n\n    const example = new Author({ name: 'John', hiddenField: 'A secret' });\n    assert.strictEqual(example.toJSON({ useProjection: true }).hiddenField, void 0);\n  });\n\n  it('clears out priorDoc after overwriting single nested subdoc (gh-9208)', async function() {\n    const TestModel = db.model('Test', Schema({\n      nested: Schema({\n        myBool: Boolean,\n        myString: String\n      })\n    }));\n\n\n    const test = new TestModel();\n\n    test.nested = { myBool: true };\n    await test.save();\n\n    test.nested = { myString: 'asdf' };\n    await test.save();\n\n    test.nested.myBool = true;\n    await test.save();\n\n    const doc = await TestModel.findById(test);\n    assert.strictEqual(doc.nested.myBool, true);\n  });\n\n  it('handles immutable properties underneath single nested subdocs when overwriting (gh-9281)', async function() {\n    const SubSchema = Schema({\n      nestedProp: {\n        type: String,\n        immutable: true\n      }\n    }, { strict: 'throw' });\n\n    const TestSchema = Schema({ object: SubSchema }, { strict: 'throw' });\n    const Test = db.model('Test', TestSchema);\n\n\n    await Test.create({ object: { nestedProp: 'A' } });\n    const doc = await Test.findOne();\n\n    doc.object = {};\n    const err = await doc.save().then(() => null, err => err);\n\n    assert.ok(err);\n    assert.ok(err.errors['object']);\n    assert.ok(err.message.includes('Path `nestedProp` is immutable'), err.message);\n\n    // Setting to the same value as the previous doc is ok.\n    doc.object = { nestedProp: 'A' };\n    await doc.save();\n  });\n\n  it('allows removing boolean key by setting it to `undefined` (gh-9275)', async function() {\n    const Test = db.model('Test', Schema({ a: Boolean }));\n\n\n    const doc = await Test.create({ a: true });\n    doc.a = undefined;\n    await doc.save();\n\n    const fromDb = await Test.findOne().lean();\n    assert.ok(!('a' in fromDb));\n  });\n\n  it('keeps manually populated paths when setting a nested path to itself (gh-9293)', async function() {\n    const StepSchema = Schema({\n      ride: { type: ObjectId, ref: 'Ride' },\n      status: Number\n    });\n\n    const RideSchema = Schema({\n      status: Number,\n      steps: {\n        taxi: [{ type: ObjectId, ref: 'Step' }],\n        rent: [{ type: ObjectId, ref: 'Step' }],\n        vehicle: [{ type: ObjectId, ref: 'Step' }]\n      }\n    });\n\n    const Step = db.model('Step', StepSchema);\n    const Ride = db.model('Ride', RideSchema);\n\n\n    let ride = await Ride.create({ status: 0 });\n    const steps = await Step.create([\n      { ride: ride, status: 0 },\n      { ride: ride, status: 1 },\n      { ride: ride, status: 2 }\n    ]);\n\n    ride.steps = { taxi: [steps[0]], rent: [steps[1]], vehicle: [steps[2]] };\n    await ride.save();\n\n    ride = await Ride.findOne({}).populate('steps.taxi steps.vehicle steps.rent');\n\n    assert.equal(ride.steps.taxi[0].status, 0);\n    assert.equal(ride.steps.rent[0].status, 1);\n    assert.equal(ride.steps.vehicle[0].status, 2);\n\n    ride.steps = ride.steps;\n    assert.equal(ride.steps.taxi[0].status, 0);\n    assert.equal(ride.steps.rent[0].status, 1);\n    assert.equal(ride.steps.vehicle[0].status, 2);\n  });\n\n  it('doesnt wipe out nested paths when setting a nested path to itself (gh-9313)', async function() {\n    const schema = new Schema({\n      nested: {\n        prop1: { type: Number, default: 50 },\n        prop2: {\n          type: String,\n          enum: ['val1', 'val2'],\n          default: 'val1',\n          required: true\n        },\n        prop3: {\n          prop4: { type: Number, default: 0 }\n        }\n      }\n    });\n\n    const Model = db.model('Test', schema);\n\n\n    let doc = await Model.create({});\n\n    doc = await Model.findById(doc);\n\n    doc.nested = doc.nested;\n\n    assert.equal(doc.nested.prop2, 'val1');\n    await doc.save();\n\n    const fromDb = await Model.collection.findOne({ _id: doc._id });\n    assert.equal(fromDb.nested.prop2, 'val1');\n  });\n\n  it('allows saving after setting document array to itself (gh-9266)', async function() {\n    const Model = db.model('Test', Schema({ keys: [{ _id: false, name: String }] }));\n\n\n    const document = new Model({});\n\n    document.keys[0] = { name: 'test' };\n    document.keys = document.keys;\n\n    await document.save();\n\n    const fromDb = await Model.findOne();\n    assert.deepEqual(fromDb.toObject().keys, [{ name: 'test' }]);\n  });\n\n  it('allows accessing document values from function default on array (gh-9351) (gh-6155)', function() {\n    const schema = Schema({\n      publisher: String,\n      authors: {\n        type: [String],\n        default: function() {\n          return [this.publisher];\n        }\n      }\n    });\n    const Test = db.model('Test', schema);\n\n    const doc = new Test({ publisher: 'Mastering JS' });\n    assert.deepEqual(doc.toObject().authors, ['Mastering JS']);\n  });\n\n  it('handles pulling array subdocs when _id is an alias (gh-9319)', async function() {\n    const childSchema = Schema({\n      field: {\n        type: String,\n        alias: '_id'\n      }\n    }, { _id: false });\n\n    const parentSchema = Schema({ children: [childSchema] });\n    const Parent = db.model('Parent', parentSchema);\n\n\n    await Parent.create({ children: [{ field: '1' }] });\n    const p = await Parent.findOne();\n\n    p.children.pull('1');\n    await p.save();\n\n    assert.equal(p.children.length, 0);\n\n    const fromDb = await Parent.findOne();\n    assert.equal(fromDb.children.length, 0);\n  });\n\n  it('allows setting nested path to instance of model (gh-9392)', function() {\n    const def = { test: String };\n    const Child = db.model('Child', def);\n\n    const Parent = db.model('Parent', { nested: def });\n\n    const c = new Child({ test: 'new' });\n\n    const p = new Parent({ nested: { test: 'old' } });\n    p.nested = c;\n\n    assert.equal(p.nested.test, 'new');\n  });\n\n  it('unmarks modified if setting a value to the same value as it was previously (gh-9396)', async function() {\n    const schema = new Schema({\n      bar: String\n    });\n\n    const Test = db.model('Test', schema);\n\n    const foo = new Test({ bar: 'bar' });\n    await foo.save();\n    assert.ok(!foo.isModified('bar'));\n\n    foo.bar = 'baz';\n    assert.ok(foo.isModified('bar'));\n\n    foo.bar = 'bar';\n    assert.ok(!foo.isModified('bar'));\n  });\n\n  it('unmarks modified if setting a value to the same subdoc as it was previously (gh-9396)', async function() {\n    const schema = new Schema({\n      nested: { bar: String },\n      subdoc: new Schema({ bar: String }, { _id: false })\n    });\n    const Test = db.model('Test', schema);\n\n\n    const foo = new Test({ nested: { bar: 'bar' }, subdoc: { bar: 'bar' } });\n    await foo.save();\n    assert.ok(!foo.isModified('nested'));\n    assert.ok(!foo.isModified('subdoc'));\n\n    foo.nested = { bar: 'baz' };\n    foo.subdoc = { bar: 'baz' };\n    assert.ok(foo.isModified('nested'));\n    assert.ok(foo.isModified('subdoc'));\n\n    foo.nested = { bar: 'bar' };\n    foo.subdoc = { bar: 'bar' };\n    assert.ok(!foo.isModified('nested'));\n    assert.ok(!foo.isModified('subdoc'));\n    assert.ok(!foo.isModified('subdoc.bar'));\n\n    foo.nested = { bar: 'baz' };\n    foo.subdoc = { bar: 'baz' };\n    assert.ok(foo.isModified('nested'));\n    assert.ok(foo.isModified('subdoc'));\n    await foo.save();\n\n    foo.nested = { bar: 'bar' };\n    foo.subdoc = { bar: 'bar' };\n    assert.ok(foo.isModified('nested'));\n    assert.ok(foo.isModified('subdoc'));\n    assert.ok(foo.isModified('subdoc.bar'));\n  });\n\n  it('correctly tracks saved state for deeply nested objects (gh-10773) (gh-9396)', async function() {\n    const PaymentSchema = Schema({ status: String }, { _id: false });\n    const OrderSchema = new Schema({\n      status: String,\n      payments: {\n        payout: PaymentSchema\n      }\n    });\n\n    const Order = db.model('Order', OrderSchema);\n\n    const order = new Order({\n      status: 'unpaid',\n      payments: {\n        payout: {\n          status: 'unpaid'\n        }\n      }\n    });\n\n    await order.save();\n\n    const newPaymentsStatus = Object.assign({}, order.payments);\n\n    newPaymentsStatus.payout.status = 'paid';\n\n    order.payments = newPaymentsStatus;\n    assert.ok(order.isModified('payments'));\n\n    await order.save();\n\n    const fromDb = await Order.findById(order._id).lean();\n    assert.equal(fromDb.payments.payout.status, 'paid');\n  });\n\n  it('marks path as errored if default function throws (gh-9408)', function() {\n    const jobSchema = new Schema({\n      deliveryAt: Date,\n      subJob: [{\n        deliveryAt: Date,\n        shippingAt: {\n          type: Date,\n          default: () => { throw new Error('Oops!'); }\n        },\n        prop: { type: String, default: 'default' }\n      }]\n    });\n\n    const Job = db.model('Test', jobSchema);\n\n    const doc = new Job({ subJob: [{ deliveryAt: new Date() }] });\n    assert.equal(doc.subJob[0].prop, 'default');\n  });\n\n  it('passes subdoc with initial values set to default function when init-ing (gh-9408)', function() {\n    const jobSchema = new Schema({\n      deliveryAt: Date,\n      subJob: [{\n        deliveryAt: Date,\n        shippingAt: {\n          type: Date,\n          default: function() {\n            return this.deliveryAt;\n          }\n        }\n      }]\n    });\n\n    const Job = db.model('Test', jobSchema);\n\n    const date = new Date();\n    const doc = new Job({ subJob: [{ deliveryAt: date }] });\n\n    assert.equal(doc.subJob[0].shippingAt.valueOf(), date.valueOf());\n  });\n\n  it('passes document as an argument for `required` function in schema definition (gh-9433)', function() {\n    let docFromValidation;\n\n    const userSchema = new Schema({\n      name: {\n        type: String,\n        required: (doc) => {\n          docFromValidation = doc;\n          return doc.age > 18;\n        }\n      },\n      age: Number\n    });\n\n    const User = db.model('User', userSchema);\n    const user = new User({ age: 26 });\n    const err = user.validateSync();\n    assert.ok(err);\n\n    assert.ok(docFromValidation === user);\n  });\n\n  it('works with path named isSelected (gh-9438)', function() {\n    const categorySchema = new Schema({\n      name: String,\n      categoryUrl: { type: String, required: true }, // Makes test fail\n      isSelected: Boolean\n    });\n\n    const siteSchema = new Schema({ categoryUrls: [categorySchema] });\n\n    const Test = db.model('Test', siteSchema);\n    const test = new Test({\n      categoryUrls: [\n        { name: 'A', categoryUrl: 'B', isSelected: false, isModified: false }\n      ]\n    });\n    const err = test.validateSync();\n    assert.ifError(err);\n  });\n\n  it('init tracks cast error reason (gh-9448)', function() {\n    const Test = db.model('Test', Schema({\n      num: Number\n    }));\n\n    const doc = new Test();\n    doc.init({ num: 'not a number' });\n\n    const err = doc.validateSync();\n    assert.ok(err.errors['num'].reason);\n  });\n\n  it('correctly handles setting nested path underneath single nested subdocs (gh-9459)', function() {\n    const preferencesSchema = mongoose.Schema({\n      notifications: {\n        email: Boolean,\n        push: Boolean\n      },\n      keepSession: Boolean\n    }, { _id: false });\n\n    const User = db.model('User', Schema({\n      email: String,\n      username: String,\n      preferences: preferencesSchema\n    }));\n\n    const userFixture = {\n      email: 'foo@bar.com',\n      username: 'foobars',\n      preferences: {\n        keepSession: true,\n        notifications: {\n          email: false,\n          push: false\n        }\n      }\n    };\n\n    let userWithEmailNotifications = Object.assign({}, userFixture, {\n      'preferences.notifications': { email: true }\n    });\n    let testUser = new User(userWithEmailNotifications);\n\n    assert.deepEqual(testUser.toObject().preferences.notifications, { email: true });\n\n    userWithEmailNotifications = Object.assign({}, userFixture, {\n      'preferences.notifications.email': true\n    });\n    testUser = new User(userWithEmailNotifications);\n\n    assert.deepEqual(testUser.toObject().preferences.notifications, { email: true, push: false });\n  });\n\n  it('$isValid() with space-delimited and array syntax (gh-9474)', function() {\n    const Test = db.model('Test', Schema({\n      name: String,\n      email: String,\n      age: Number,\n      answer: Number\n    }));\n\n    const doc = new Test({ name: 'test', email: 'test@gmail.com', age: 'bad', answer: 'bad' });\n\n    assert.ok(doc.$isValid('name'));\n    assert.ok(doc.$isValid('email'));\n    assert.ok(!doc.$isValid('age'));\n    assert.ok(!doc.$isValid('answer'));\n\n    assert.ok(doc.$isValid('name email'));\n    assert.ok(doc.$isValid('name age'));\n    assert.ok(!doc.$isValid('age answer'));\n\n    assert.ok(doc.$isValid(['name', 'email']));\n    assert.ok(doc.$isValid(['name', 'age']));\n    assert.ok(!doc.$isValid(['age', 'answer']));\n  });\n\n  it('avoids overwriting array subdocument when setting dotted path that is not selected (gh-9427)', async function() {\n    const Test = db.model('Test', Schema({\n      arr: [{ _id: false, val: Number }],\n      name: String,\n      age: Number\n    }));\n\n\n    let doc = await Test.create({\n      name: 'Test',\n      arr: [{ val: 1 }, { val: 2 }],\n      age: 30\n    });\n\n    doc = await Test.findById(doc._id).select('name');\n    doc.set('arr.0.val', 2);\n    await doc.save();\n\n    const fromDb = await Test.findById(doc._id);\n    assert.deepEqual(fromDb.toObject().arr, [{ val: 2 }, { val: 2 }]);\n  });\n\n  it('ignore getters when diffing objects for change tracking (gh-9501)', async function() {\n    const schema = new Schema({\n      title: {\n        type: String,\n        required: true\n      },\n      price: {\n        type: Number,\n        min: 0\n      },\n      taxPercent: {\n        type: Number,\n        required: function() {\n          return this.price != null;\n        },\n        min: 0,\n        max: 100,\n        get: value => value || 10\n      }\n    });\n\n    const Test = db.model('Test', schema);\n\n\n    const doc = await Test.create({\n      title: 'original'\n    });\n\n    doc.set({\n      title: 'updated',\n      price: 10,\n      taxPercent: 10\n    });\n\n    assert.ok(doc.modifiedPaths().indexOf('taxPercent') !== -1);\n\n    await doc.save();\n\n    const fromDb = await Test.findById(doc).lean();\n    assert.equal(fromDb.taxPercent, 10);\n  });\n\n  it('allows defining middleware for all document hooks using regexp (gh-9190)', async function() {\n    const schema = Schema({ name: String });\n\n    let called = 0;\n    schema.pre(/.*/, { document: true, query: false }, function() {\n      ++called;\n    });\n    const Model = db.model('Test', schema);\n\n\n    await Model.find();\n    assert.equal(called, 0);\n\n    await Model.findOne();\n    assert.equal(called, 0);\n\n    await Model.countDocuments();\n    assert.equal(called, 0);\n\n    const docs = await Model.create([{ name: 'test' }], { validateBeforeSave: false });\n    assert.equal(called, 1);\n\n    await docs[0].validate();\n    assert.equal(called, 2);\n\n    await docs[0].updateOne({ name: 'test2' });\n    assert.equal(called, 3);\n\n    await Model.aggregate([{ $match: { name: 'test' } }]);\n    assert.equal(called, 3);\n  });\n\n  it('correctly handles setting nested props to other nested props (gh-9519)', async function() {\n    const schemaA = Schema({\n      propX: {\n        nested1: { prop: Number },\n        nested2: { prop: Number },\n        nested3: { prop: Number }\n      },\n      propY: {\n        nested1: { prop: Number },\n        nested2: { prop: Number },\n        nested3: { prop: Number }\n      }\n    });\n\n    const schemaB = Schema({ prop: { prop: Number } });\n\n    const ModelA = db.model('Test1', schemaA);\n    const ModelB = db.model('Test2', schemaB);\n\n\n    const saved = await ModelA.create({\n      propX: {\n        nested1: { prop: 1 },\n        nested2: { prop: 1 },\n        nested3: { prop: 1 }\n      },\n      propY: {\n        nested1: { prop: 2 },\n        nested2: { prop: 2 },\n        nested3: { prop: 2 }\n      }\n    });\n\n    const objA = await ModelA.findById(saved._id);\n    const objB = new ModelB();\n\n    objB.prop = objA.propX.nested1;\n\n    assert.strictEqual(objB.prop.prop, 1);\n  });\n\n  it('sets fields after an undefined field (gh-9585)', function() {\n    const personSchema = new Schema({\n      items: { type: Array },\n      email: { type: String }\n    });\n\n    const Person = db.model('Person', personSchema);\n\n\n    const person = new Person({ items: undefined, email: 'test@gmail.com' });\n    assert.equal(person.email, 'test@gmail.com');\n  });\n\n  it('passes document to `default` functions (gh-9633)', function() {\n    let documentFromDefault;\n    const userSchema = new Schema({\n      name: { type: String },\n      age: {\n        type: Number,\n        default: function(doc) {\n          documentFromDefault = doc;\n        }\n      }\n\n    });\n\n    const User = db.model('User', userSchema);\n\n    const user = new User({ name: 'Hafez' });\n\n    assert.ok(documentFromDefault === user);\n    assert.equal(documentFromDefault.name, 'Hafez');\n  });\n\n  it('handles pre hook throwing a sync error (gh-9659)', async function() {\n    const TestSchema = new Schema({ name: String });\n\n    TestSchema.pre('save', function() {\n      throw new Error('test err');\n    });\n    const TestModel = db.model('Test', TestSchema);\n\n\n    const testObject = new TestModel({ name: 't' });\n\n    const err = await testObject.save().then(() => null, err => err);\n    assert.ok(err);\n    assert.equal(err.message, 'test err');\n  });\n\n  it('returns undefined rather than entire object when calling `get()` with empty string (gh-9681)', function() {\n    const TestSchema = new Schema({ name: String });\n    const TestModel = db.model('Test', TestSchema);\n\n    const testObject = new TestModel({ name: 't' });\n\n    assert.strictEqual(testObject.get(''), void 0);\n  });\n\n  it('keeps atomics when assigning array to filtered array (gh-9651)', async function() {\n    const Model = db.model('Test', { arr: [{ abc: String }] });\n\n\n    const m1 = new Model({ arr: [{ abc: 'old' }] });\n    await m1.save();\n\n    const m2 = await Model.findOne({ _id: m1._id });\n\n    m2.arr = [];\n    m2.arr = m2.arr.filter(() => true);\n    m2.arr.push({ abc: 'ghi' });\n    await m2.save();\n\n    const fromDb = await Model.findById(m1._id);\n    assert.equal(fromDb.arr.length, 1);\n    assert.equal(fromDb.arr[0].abc, 'ghi');\n  });\n\n  it('does not pass doc to ObjectId or Date.now (gh-9633) (gh-9636)', function() {\n    const userSchema = new Schema({\n      parentId: { type: Schema.ObjectId, ref: 'User', default: () => new mongoose.Types.ObjectId() },\n      createdAt: { type: Date, default: Date.now }\n    });\n\n    const User = db.model('User', userSchema);\n\n    const user = new User();\n\n    assert.ok(user.parentId instanceof mongoose.Types.ObjectId);\n    assert.ok(user.createdAt instanceof Date);\n  });\n\n  it('supports getting a list of populated docs (gh-9702)', async function() {\n    const Child = db.model('Child', Schema({ name: String }));\n    const Parent = db.model('Parent', {\n      children: [{ type: ObjectId, ref: 'Child' }],\n      child: { type: ObjectId, ref: 'Child' }\n    });\n\n\n    const c = await Child.create({ name: 'test' });\n    await Parent.create({\n      children: [c._id],\n      child: c._id\n    });\n\n    const p = await Parent.findOne();\n    await p.populate('children');\n    await p.populate('child');\n\n    p.children; // [{ _id: '...', name: 'test' }]\n\n    assert.equal(p.$getPopulatedDocs().length, 2);\n    assert.equal(p.$getPopulatedDocs()[0], p.children[0]);\n    assert.equal(p.$getPopulatedDocs()[0].name, 'test');\n    assert.equal(p.$getPopulatedDocs()[1], p.child);\n    assert.equal(p.$getPopulatedDocs()[1].name, 'test');\n  });\n\n  it('with virtual populate (gh-10148)', async function() {\n    const childSchema = Schema({ name: String, parentId: 'ObjectId' });\n    childSchema.virtual('parent', {\n      ref: 'Parent',\n      localField: 'parentId',\n      foreignField: '_id',\n      justOne: true\n    });\n    const Child = db.model('Child', childSchema);\n\n    const Parent = db.model('Parent', Schema({ name: String }));\n\n\n    const p = await Parent.create({ name: 'Anakin' });\n    await Child.create({ name: 'Luke', parentId: p._id });\n\n    const res = await Child.findOne().populate('parent');\n    assert.equal(res.parent.name, 'Anakin');\n    const docs = res.$getPopulatedDocs();\n    assert.equal(docs.length, 1);\n    assert.equal(docs[0].name, 'Anakin');\n  });\n\n  it('handles paths named `db` (gh-9798)', async function() {\n    const schema = new Schema({\n      db: String\n    });\n    const Test = db.model('Test', schema);\n\n\n    const doc = await Test.create({ db: 'foo' });\n    doc.db = 'bar';\n    await doc.save();\n    await doc.deleteOne();\n\n    const _doc = await Test.findOne({ db: 'bar' });\n    assert.ok(!_doc);\n  });\n\n  it('handles paths named `schema` gh-8798', async function() {\n    const schema = new Schema({\n      schema: String,\n      name: String\n    });\n    const Test = db.model('Test', schema);\n\n\n    const doc = await Test.create({ schema: 'test', name: 'test' });\n    await doc.save();\n    assert.ok(doc);\n    assert.equal(doc.schema, 'test');\n    assert.equal(doc.name, 'test');\n\n    const fromDb = await Test.findById(doc);\n    assert.equal(fromDb.schema, 'test');\n    assert.equal(fromDb.name, 'test');\n\n    doc.schema = 'test2';\n    await doc.save();\n\n    await fromDb.remove();\n    doc.name = 'test3';\n    const err = await doc.save().then(() => null, err => err);\n    assert.ok(err);\n    assert.equal(err.name, 'DocumentNotFoundError');\n  });\n\n  it('handles nested paths named `schema` gh-8798', async function() {\n    const schema = new Schema({\n      nested: {\n        schema: String\n      },\n      name: String\n    });\n    const Test = db.model('Test', schema);\n\n\n    const doc = await Test.create({ nested: { schema: 'test' }, name: 'test' });\n    await doc.save();\n    assert.ok(doc);\n    assert.equal(doc.nested.schema, 'test');\n    assert.equal(doc.name, 'test');\n\n    const fromDb = await Test.findById(doc);\n    assert.equal(fromDb.nested.schema, 'test');\n    assert.equal(fromDb.name, 'test');\n\n    doc.nested.schema = 'test2';\n    await doc.save();\n  });\n\n  it('object setters will be applied for each object in array after populate (gh-9838)', async function() {\n    const updatedElID = '123456789012345678901234';\n\n    const ElementSchema = new Schema({\n      name: 'string',\n      nested: [{ type: Schema.Types.ObjectId, ref: 'Nested' }]\n    });\n\n    const NestedSchema = new Schema({});\n\n    const Element = db.model('Test', ElementSchema);\n    const NestedElement = db.model('Nested', NestedSchema);\n\n\n    const nes = new NestedElement({});\n    await nes.save();\n    const ele = new Element({ nested: [nes.id], name: 'test' });\n    await ele.save();\n\n    const ss = await Element.findById(ele._id).populate({ path: 'nested', model: NestedElement });\n    ss.nested = [updatedElID];\n    await ss.save();\n\n    assert.ok(typeof ss.nested[0] !== 'string');\n    assert.equal(ss.nested[0].toHexString(), updatedElID);\n  });\n  it('gh9884', async function() {\n\n\n    const obi = new Schema({\n      eType: {\n        type: String,\n        required: true,\n        uppercase: true\n      },\n      eOrigin: {\n        type: String,\n        required: true\n      },\n      eIds: [\n        {\n          type: String\n        }\n      ]\n    }, { _id: false });\n\n    const schema = new Schema({\n      name: String,\n      description: String,\n      isSelected: {\n        type: Boolean,\n        default: false\n      },\n      wan: {\n        type: [obi],\n        default: undefined,\n        required: true\n      }\n    });\n\n    const newDoc = {\n      name: 'name',\n      description: 'new desc',\n      isSelected: true,\n      wan: [\n        {\n          eType: 'X',\n          eOrigin: 'Y',\n          eIds: ['Y', 'Z']\n        }\n      ]\n    };\n\n    const Model = db.model('Test', schema);\n    await Model.create(newDoc);\n    const doc = await Model.findOne();\n    assert.ok(doc);\n  });\n\n  it('Makes sure pre remove hook is executed gh-9885', async function() {\n    const SubSchema = new Schema({\n      myValue: {\n        type: String\n      }\n    }, {});\n    let count = 0;\n    SubSchema.pre('remove', function(next) {\n      count++;\n      next();\n    });\n    const thisSchema = new Schema({\n      foo: {\n        type: String,\n        required: true\n      },\n      mySubdoc: {\n        type: [SubSchema],\n        required: true\n      }\n    }, { minimize: false, collection: 'test' });\n\n    const Model = db.model('TestModel', thisSchema);\n\n\n    await Model.deleteMany({}); // remove all existing documents\n    const newModel = {\n      foo: 'bar',\n      mySubdoc: [{ myValue: 'some value' }]\n    };\n    const document = await Model.create(newModel);\n    document.mySubdoc[0].remove();\n    await document.save().catch((error) => {\n      console.error(error);\n    });\n    assert.equal(count, 1);\n  });\n\n  it('gh9880', function(done) {\n    const testSchema = new Schema({\n      prop: String,\n      nestedProp: {\n        prop: String\n      }\n    });\n    const Test = db.model('Test', testSchema);\n\n    new Test({\n      prop: 'Test',\n      nestedProp: null\n    }).save((err, doc) => {\n      doc.id;\n      doc.nestedProp;\n\n      // let's clone this document:\n      new Test({\n        prop: 'Test 2',\n        nestedProp: doc.nestedProp\n      });\n\n      Test.updateOne({\n        _id: doc._id\n      }, {\n        nestedProp: null\n      }, (err) => {\n        assert.ifError(err);\n        Test.findOne({\n          _id: doc._id\n        }, (err, updatedDoc) => {\n          assert.ifError(err);\n          new Test({\n            prop: 'Test 3',\n            nestedProp: updatedDoc.nestedProp\n          });\n          done();\n        });\n      });\n    });\n  });\n\n  it('handles directly setting embedded document array element with projection (gh-9909)', async function() {\n    const schema = Schema({\n      elements: [{\n        text: String,\n        subelements: [{\n          text: String\n        }]\n      }]\n    });\n\n    const Test = db.model('Test', schema);\n\n\n    let doc = await Test.create({ elements: [{ text: 'hello' }] });\n    doc = await Test.findById(doc).select('elements');\n\n    doc.elements[0].subelements[0] = { text: 'my text' };\n    await doc.save();\n\n    const fromDb = await Test.findById(doc).lean();\n    assert.equal(fromDb.elements.length, 1);\n    assert.equal(fromDb.elements[0].subelements.length, 1);\n    assert.equal(fromDb.elements[0].subelements[0].text, 'my text');\n  });\n\n  it('toObject() uses child schema `flattenMaps` option by default (gh-9995)', async function() {\n    const MapSchema = new Schema({\n      value: { type: Number }\n    }, { _id: false });\n\n    const ChildSchema = new Schema({\n      map: { type: Map, of: MapSchema }\n    });\n    ChildSchema.set('toObject', { flattenMaps: true });\n\n    const ParentSchema = new Schema({\n      child: { type: Schema.ObjectId, ref: 'Child' }\n    });\n\n    const ChildModel = db.model('Child', ChildSchema);\n    const ParentModel = db.model('Parent', ParentSchema);\n\n\n    const childDocument = new ChildModel({\n      map: { first: { value: 1 }, second: { value: 2 } }\n    });\n    await childDocument.save();\n\n    const parentDocument = new ParentModel({ child: childDocument });\n    await parentDocument.save();\n\n    const resultDocument = await ParentModel.findOne().populate('child').exec();\n\n    let resultObject = resultDocument.toObject();\n    assert.ok(resultObject.child.map);\n    assert.ok(!(resultObject.child.map instanceof Map));\n\n    resultObject = resultDocument.toObject({ flattenMaps: false });\n    assert.ok(resultObject.child.map instanceof Map);\n  });\n\n  it('does not double validate paths under mixed objects (gh-10141)', async function() {\n    let validatorCallCount = 0;\n    const Test = db.model('Test', Schema({\n      name: String,\n      object: {\n        type: Object,\n        validate: () => {\n          validatorCallCount++;\n          return true;\n        }\n      }\n    }));\n\n\n    const doc = await Test.create({ name: 'test', object: { answer: 42 } });\n\n    validatorCallCount = 0;\n    doc.set('object.question', 'secret');\n    doc.set('object.answer', 0);\n    await doc.validate();\n    assert.equal(validatorCallCount, 0);\n  });\n\n  it('clears child document modified when setting map path underneath single nested (gh-10295)', async function() {\n    const SecondMapSchema = new mongoose.Schema({\n      data: { type: Map, of: Number, default: {}, _id: false }\n    });\n\n    const FirstMapSchema = new mongoose.Schema({\n      data: { type: Map, of: SecondMapSchema, default: {}, _id: false }\n    });\n\n    const NestedSchema = new mongoose.Schema({\n      data: { type: Map, of: SecondMapSchema, default: {}, _id: false }\n    });\n\n    const TestSchema = new mongoose.Schema({\n      _id: Number,\n      firstMap: { type: Map, of: FirstMapSchema, default: {}, _id: false },\n      nested: { type: NestedSchema, default: {}, _id: false }\n    });\n\n    const Test = db.model('Test', TestSchema);\n\n\n    const doc = await Test.create({ _id: Date.now() });\n\n    doc.nested.data.set('second', {});\n    assert.ok(doc.modifiedPaths().indexOf('nested.data.second') !== -1, doc.modifiedPaths());\n    await doc.save();\n\n    doc.nested.data.get('second').data.set('final', 3);\n    assert.ok(doc.modifiedPaths().indexOf('nested.data.second.data.final') !== -1, doc.modifiedPaths());\n    await doc.save();\n\n    const fromDb = await Test.findById(doc).lean();\n    assert.equal(fromDb.nested.data.second.data.final, 3);\n  });\n\n  it('avoids infinite recursion when setting single nested subdoc to array (gh-10351)', async function() {\n    const userInfoSchema = new mongoose.Schema({ _id: String }, { _id: false });\n    const observerSchema = new mongoose.Schema({ user: {} }, { _id: false });\n\n    const entrySchema = new mongoose.Schema({\n      creator: userInfoSchema,\n      observers: [observerSchema]\n    });\n\n    entrySchema.pre('save', function(next) {\n      this.observers = [{ user: this.creator }];\n\n      next();\n    });\n\n    const Test = db.model('Test', entrySchema);\n\n\n    const entry = new Test({\n      creator: { _id: 'u1' }\n    });\n\n    await entry.save();\n\n    const fromDb = await Test.findById(entry);\n    assert.equal(fromDb.observers.length, 1);\n  });\n\n  describe('reserved keywords can be used optionally (gh-9010)', () => {\n    describe('Document#validate(...)', () => {\n      it('is available as `$validate`', async() => {\n        const userSchema = new Schema({\n          name: String\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ name: 'Sam' });\n        const err = await user.$validate();\n        assert.ok(err == null);\n        assert.equal(user.$validate, user.validate);\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: String,\n          validate: Boolean\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ name: 'Sam', validate: true });\n        assert.equal(user.validate, true);\n      });\n    });\n    describe('Document#save(...)', () => {\n      it('is available as `$save`', async() => {\n        const userSchema = new Schema({\n          name: String\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ name: 'Sam' });\n        const userFromSave = await user.$save();\n        assert.ok(userFromSave === user);\n        assert.equal(user.$save, user.save);\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: String,\n          save: Boolean\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ name: 'Sam', save: true });\n        assert.equal(user.save, true);\n      });\n    });\n    describe('Document#isModified(...)', () => {\n      it('is available as `$isModified`', async() => {\n        const userSchema = new Schema({\n          name: String\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ name: 'Sam' });\n        await user.save();\n\n        assert.ok(user.$isModified() === false);\n\n        user.name = 'John';\n        assert.ok(user.$isModified() === true);\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: String,\n          isModified: String\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ name: 'Sam', isModified: 'nope' });\n        assert.equal(user.isModified, 'nope');\n      });\n    });\n    describe('Document#isNew', () => {\n      it('is available as `$isNew`', async() => {\n        const userSchema = new Schema({\n          name: String\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ name: 'Sam' });\n\n        assert.ok(user.$isNew === true);\n        await user.save();\n        assert.ok(user.$isNew === false);\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: String,\n          isNew: String\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ name: 'Sam', isNew: 'yep' });\n        assert.equal(user.isNew, 'yep');\n      });\n    });\n    describe('Document#populated(...)', () => {\n      it('is available as `$populated`', async() => {\n        const userSchema = new Schema({ name: String });\n        const User = db.model('User', userSchema);\n\n        const postSchema = new Schema({\n          title: String,\n          userId: { type: Schema.ObjectId, ref: 'User' }\n        });\n        const Post = db.model('Post', postSchema);\n\n        const user = await User.create({ name: 'Sam' });\n\n        const postFromCreate = await Post.create({ title: 'I am a title', userId: user._id });\n\n        const post = await Post.findOne({ _id: postFromCreate }).populate({ path: 'userId' });\n\n        assert.ok(post.$populated('userId'));\n        post.depopulate('userId');\n        assert.ok(!post.$populated('userId'));\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: String,\n          populated: String\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ name: 'Sam', populated: 'yep' });\n        assert.equal(user.populated, 'yep');\n      });\n    });\n    describe('Document#toObject(...)', () => {\n      it('is available as `$toObject`', async() => {\n        const userSchema = new Schema({ name: String });\n        const User = db.model('User', userSchema);\n\n        const user = await User.create({ name: 'Sam' });\n\n        assert.deepEqual(user.$toObject(), user.toObject());\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: String,\n          toObject: String\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ name: 'Sam', toObject: 'yep' });\n        assert.equal(user.toObject, 'yep');\n      });\n    });\n    describe('Document#init(...)', () => {\n      it('is available as `$init`', async() => {\n        const userSchema = new Schema({ name: String });\n        const User = db.model('User', userSchema);\n\n        const user = new User();\n        const sam = new User({ name: 'Sam' });\n\n        assert.equal(user.$init(sam).name, 'Sam');\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: String,\n          init: Number\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ name: 'Sam', init: 12 });\n        assert.equal(user.init, 12);\n      });\n    });\n    xdescribe('Document#collection', () => {\n      it('is available as `$collection`', async() => {\n        const userSchema = new Schema({ name: String });\n        const User = db.model('User', userSchema);\n\n        const user = await User.create({ name: 'Hafez' });\n        const userFromCollection = await user.$collection.findOne({ _id: user._id });\n        assert.ok(userFromCollection);\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          collection: Number\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ collection: 12 });\n        assert.equal(user.collection, 12);\n        assert.ok(user.$collection !== user.collection);\n        assert.ok(user.$collection);\n      });\n    });\n    describe('Document#errors', () => {\n      it('is available as `$errors`', async() => {\n        const userSchema = new Schema({ name: { type: String, required: true } });\n        const User = db.model('User', userSchema);\n\n        const user = new User();\n        user.validateSync();\n\n        assert.ok(user.$errors.name.kind === 'required');\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: { type: String, required: true },\n          errors: Number\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ errors: 12 });\n        user.validateSync();\n\n        assert.equal(user.errors, 12);\n\n        assert.ok(user.$errors.name.kind === 'required');\n      });\n    });\n    describe('Document#removeListener', () => {\n      it('is available as `$removeListener`', async() => {\n        const userSchema = new Schema({ name: String });\n        const User = db.model('User', userSchema);\n\n        const user = new User({ name: 'Hafez' });\n\n        assert.ok(user.$removeListener('save', () => {}));\n        assert.ok(user.$removeListener === user.removeListener);\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: { type: String, required: true },\n          removeListener: Number\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ removeListener: 12 });\n\n        assert.equal(user.removeListener, 12);\n      });\n    });\n    describe('Document#listeners', () => {\n      it('is available as `$listeners`', async() => {\n        const userSchema = new Schema({ name: String });\n        const User = db.model('User', userSchema);\n\n        const user = new User({ name: 'Hafez' });\n\n        assert.ok(user.$listeners === user.listeners);\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: { type: String, required: true },\n          listeners: Number\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ listeners: 12 });\n\n        assert.equal(user.listeners, 12);\n      });\n    });\n    describe('Document#on', () => {\n      it('is available as `$on`', async() => {\n        const userSchema = new Schema({ name: String });\n        const User = db.model('User', userSchema);\n\n        const user = new User({ name: 'Hafez' });\n\n        assert.ok(user.$on === user.on);\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: { type: String, required: true },\n          on: Number\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ on: 12 });\n\n        assert.equal(user.on, 12);\n      });\n    });\n    describe('Document#emit', () => {\n      it('is available as `$emit`', async() => {\n        const userSchema = new Schema({ name: String });\n        const User = db.model('User', userSchema);\n\n        const user = new User({ name: 'Hafez' });\n\n        assert.ok(user.$emit === user.emit);\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: { type: String, required: true },\n          emit: Number\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ emit: 12 });\n\n        assert.equal(user.emit, 12);\n      });\n    });\n    describe('Document#get', () => {\n      it('is available as `$get`', async() => {\n        const userSchema = new Schema({ name: String });\n        const User = db.model('User', userSchema);\n\n        const user = new User({ name: 'Hafez' });\n\n        assert.ok(user.$get === user.get);\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: { type: String, required: true },\n          get: Number\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ get: 12 });\n\n        assert.equal(user.get, 12);\n      });\n    });\n    describe('Document#remove', () => {\n      it('is available as `$remove`', async() => {\n        const userSchema = new Schema({ name: String });\n        const User = db.model('User', userSchema);\n\n        const user = new User({ name: 'Hafez' });\n        await user.save();\n        await user.$remove();\n        const userFromDB = await User.findOne({ _id: user._id });\n\n        assert.ok(userFromDB == null);\n      });\n      it('can be used as a property in documents', async() => {\n        const userSchema = new Schema({\n          remove: Number\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ remove: 12 });\n\n        assert.equal(user.remove, 12);\n\n        await user.save();\n        await user.$remove();\n        const userFromDB = await User.findOne({ _id: user._id });\n\n        assert.ok(userFromDB == null);\n      });\n    });\n  });\n\n  describe('virtuals `pathsToSkip` (gh-10120)', () => {\n    it('adds support for `pathsToSkip` for virtuals feat-10120', function() {\n      const schema = new mongoose.Schema({\n        name: String,\n        age: Number,\n        nested: {\n          test: String\n        }\n      });\n      schema.virtual('nameUpper').get(function() { return this.name.toUpperCase(); });\n      schema.virtual('answer').get(() => 42);\n      schema.virtual('nested.hello').get(() => 'world');\n\n      const Model = db.model('Person', schema);\n      const doc = new Model({ name: 'Jean-Luc Picard', age: 59, nested: { test: 'hello' } });\n      let obj = doc.toObject({ virtuals: { pathsToSkip: ['answer'] } });\n      assert.ok(obj.nameUpper);\n      assert.equal(obj.answer, null);\n      assert.equal(obj.nested.hello, 'world');\n      obj = doc.toObject({ virtuals: { pathsToSkip: ['nested.hello'] } });\n      assert.equal(obj.nameUpper, 'JEAN-LUC PICARD');\n      assert.equal(obj.answer, 42);\n      assert.equal(obj.nested.hello, null);\n    });\n\n    it('supports passing a list of virtuals to `toObject()` (gh-10120)', function() {\n      const schema = new mongoose.Schema({\n        name: String,\n        age: Number,\n        nested: {\n          test: String\n        }\n      });\n      schema.virtual('nameUpper').get(function() { return this.name.toUpperCase(); });\n      schema.virtual('answer').get(() => 42);\n      schema.virtual('nested.hello').get(() => 'world');\n\n      const Model = db.model('Person', schema);\n\n      const doc = new Model({ name: 'Jean-Luc Picard', age: 59, nested: { test: 'hello' } });\n\n      let obj = doc.toObject({ virtuals: true });\n      assert.equal(obj.nameUpper, 'JEAN-LUC PICARD');\n      assert.equal(obj.answer, 42);\n      assert.equal(obj.nested.hello, 'world');\n\n      obj = doc.toObject({ virtuals: ['answer'] });\n      assert.ok(!obj.nameUpper);\n      assert.equal(obj.answer, 42);\n      assert.equal(obj.nested.hello, null);\n\n      obj = doc.toObject({ virtuals: ['nameUpper'] });\n      assert.equal(obj.nameUpper, 'JEAN-LUC PICARD');\n      assert.equal(obj.answer, null);\n      assert.equal(obj.nested.hello, null);\n\n      obj = doc.toObject({ virtuals: ['nested.hello'] });\n      assert.equal(obj.nameUpper, null);\n      assert.equal(obj.answer, null);\n      assert.equal(obj.nested.hello, 'world');\n    });\n  });\n  describe('validation `pathsToSkip` (gh-10230)', () => {\n    it('support `pathsToSkip` option for `Document#validate()`', async function() {\n\n      const User = getUserModel();\n      const user = new User();\n\n      const err1 = await user.validate({ pathsToSkip: ['age'] }).then(() => null, err => err);\n      assert.deepEqual(Object.keys(err1.errors), ['name']);\n\n      const err2 = await user.validate({ pathsToSkip: ['name'] }).then(() => null, err => err);\n      assert.deepEqual(Object.keys(err2.errors), ['age']);\n    });\n\n    it('support `pathsToSkip` option for `Document#validate()`', async function() {\n\n      const User = getUserModel();\n      const user = new User();\n\n      const err1 = await user.validate({ pathsToSkip: ['age'] }).then(() => null, err => err);\n      assert.deepEqual(Object.keys(err1.errors), ['name']);\n\n      const err2 = await user.validate({ pathsToSkip: ['name'] }).then(() => null, err => err);\n      assert.deepEqual(Object.keys(err2.errors), ['age']);\n    });\n\n    it('support `pathsToSkip` option for `Document#validateSync()`', () => {\n      const User = getUserModel();\n\n      const user = new User();\n\n      const err1 = user.validateSync({ pathsToSkip: ['age'] });\n      assert.deepEqual(Object.keys(err1.errors), ['name']);\n\n      const err2 = user.validateSync({ pathsToSkip: ['name'] });\n      assert.deepEqual(Object.keys(err2.errors), ['age']);\n    });\n\n    // skip until gh-10367 is implemented\n    xit('support `pathsToSkip` option for `Model.validate()`', async() => {\n\n      const User = getUserModel();\n      const err1 = await User.validate({}, { pathsToSkip: ['age'] });\n      assert.deepEqual(Object.keys(err1.errors), ['name']);\n\n      const err2 = await User.validate({}, { pathsToSkip: ['name'] });\n      assert.deepEqual(Object.keys(err2.errors), ['age']);\n    });\n\n    it('`pathsToSkip` accepts space separated paths', async() => {\n      const userSchema = Schema({\n        name: { type: String, required: true },\n        age: { type: Number, required: true },\n        country: { type: String, required: true },\n        rank: { type: String, required: true }\n      });\n\n      const User = db.model('User', userSchema);\n\n      const user = new User({ name: 'Sam', age: 26 });\n\n      const err1 = user.validateSync({ pathsToSkip: 'country rank' });\n      assert.ok(err1 == null);\n\n      const err2 = await user.validate({ pathsToSkip: 'country rank' }).then(() => null, err => err);\n      assert.ok(err2 == null);\n    });\n\n\n    function getUserModel() {\n      const userSchema = Schema({\n        name: { type: String, required: true },\n        age: { type: Number, required: true },\n        rank: String\n      });\n\n      const User = db.model('User', userSchema);\n      return User;\n    }\n  });\n\n  it('skips recursive merging (gh-9121)', function() {\n    // Subdocument\n    const subdocumentSchema = new mongoose.Schema({\n      child: new mongoose.Schema({ name: String, age: Number }, { _id: false })\n    });\n    const Subdoc = mongoose.model('Subdoc', subdocumentSchema);\n\n    // Nested path\n    const nestedSchema = new mongoose.Schema({\n      child: { name: String, age: Number }\n    });\n    const Nested = mongoose.model('Nested', nestedSchema);\n\n    const doc1 = new Subdoc({ child: { name: 'Luke', age: 19 } });\n    doc1.set({ child: { age: 21 } });\n    assert.deepEqual(doc1.toObject().child, { age: 21 });\n\n    const doc2 = new Nested({ child: { name: 'Luke', age: 19 } });\n    doc2.set({ child: { age: 21 } });\n    assert.deepEqual(doc2.toObject().child, { age: 21 });\n  });\n\n  it('does not pull non-schema paths from parent documents into nested paths (gh-10449)', function() {\n    const schema = new Schema({\n      name: String,\n      nested: {\n        data: String\n      }\n    });\n    const Test = db.model('Test', schema);\n\n    const doc = new Test({});\n    doc.otherProp = 'test';\n\n    assert.ok(!doc.nested.otherProp);\n  });\n\n  it('sets properties in the order they are defined in the schema (gh-4665)', async function() {\n    const schema = new Schema({\n      test: String,\n      internal: {\n        status: String,\n        createdAt: Date\n      },\n      profile: {\n        name: {\n          first: String,\n          last: String\n        }\n      }\n    });\n    const Test = db.model('Test', schema);\n\n\n    const doc = new Test({\n      profile: { name: { last: 'Musashi', first: 'Miyamoto' } },\n      internal: { createdAt: new Date('1603-06-01'), status: 'approved' },\n      test: 'test'\n    });\n\n    assert.deepEqual(Object.keys(doc.toObject()), ['test', 'internal', 'profile', '_id']);\n    assert.deepEqual(Object.keys(doc.toObject().profile.name), ['first', 'last']);\n    assert.deepEqual(Object.keys(doc.toObject().internal), ['status', 'createdAt']);\n\n    await doc.save();\n    const res = await Test.findOne({ _id: doc._id, 'profile.name': { first: 'Miyamoto', last: 'Musashi' } });\n    assert.ok(res);\n  });\n\n  it('depopulate all should depopulate nested array population (gh-10592)', async function() {\n    const Person = db.model('Person', {\n      name: String\n    });\n\n    const Band = db.model('Band', {\n      name: String,\n      members: [{ type: Schema.Types.ObjectId, ref: 'Person' }],\n      lead: { type: Schema.Types.ObjectId, ref: 'Person' },\n      embeddedMembers: [{\n        active: Boolean,\n        member: {\n          type: Schema.Types.ObjectId, ref: 'Person'\n        }\n      }]\n    });\n\n    const people = [{ name: 'Axl Rose' }, { name: 'Slash' }];\n\n    const docs = await Person.create(people);\n    let band = {\n      name: 'Guns N\\' Roses',\n      members: [docs[0]._id, docs[1]],\n      lead: docs[0]._id,\n      embeddedMembers: [{ active: true, member: docs[0]._id }, { active: false, member: docs[1]._id }]\n    };\n\n    band = await Band.create(band);\n    await band.populate('members lead embeddedMembers.member');\n    assert.ok(band.populated('members'));\n    assert.ok(band.populated('lead'));\n    assert.ok(band.populated('embeddedMembers.member'));\n    assert.equal(band.members[0].name, 'Axl Rose');\n    assert.equal(band.embeddedMembers[0].member.name, 'Axl Rose');\n    band.depopulate();\n\n    assert.ok(!band.populated('members'));\n    assert.ok(!band.populated('lead'));\n    assert.ok(!band.populated('embeddedMembers.member'));\n    assert.ok(!band.embeddedMembers[0].member.name);\n  });\n\n  it('should allow dashes in the path name (gh-10677)', async function() {\n    const schema = new mongoose.Schema({\n      values: {\n        type: Map,\n        of: { entries: String },\n        default: {}\n      }\n    });\n\n    const Model = db.model('test', schema, 'test');\n\n    const saved = new Model({});\n    await saved.save();\n    const document = await Model.findById({ _id: saved._id });\n    document.values.set('abc', { entries: 'a' });\n    document.values.set('abc-d', { entries: 'b' });\n    await document.save();\n  });\n\n  it('inits non-schema values if strict is false (gh-10828)', function() {\n    const FooSchema = new Schema({}, {\n      id: false,\n      _id: false,\n      strict: false\n    });\n    const BarSchema = new Schema({\n      name: String,\n      foo: FooSchema\n    });\n\n    const Test = db.model('Test', BarSchema);\n\n    const doc = new Test();\n    doc.init({\n      name: 'Test',\n      foo: {\n        something: 'A',\n        other: 2\n      }\n    });\n\n    assert.strictEqual(doc.foo.something, 'A');\n    assert.strictEqual(doc.foo.other, 2);\n  });\n\n  it('avoids depopulating when setting array of subdocs from different doc (gh-10819)', function() {\n    const Model1 = db.model('Test', Schema({ someField: String }));\n    const Model2 = db.model('Test2', Schema({\n      subDocuments: [{\n        subDocument: {\n          type: 'ObjectId',\n          ref: 'Test'\n        }\n      }]\n    }));\n\n    const doc1 = new Model1({ someField: '111' });\n    const doc2 = new Model2({\n      subDocuments: {\n        subDocument: doc1\n      }\n    });\n\n    const doc3 = new Model2(doc2);\n    assert.ok(doc3.populated('subDocuments.subDocument'));\n    assert.equal(doc3.subDocuments[0].subDocument.someField, '111');\n\n    const doc4 = new Model2();\n    doc4.subDocuments = doc2.subDocuments;\n    assert.ok(doc4.populated('subDocuments.subDocument'));\n    assert.equal(doc4.subDocuments[0].subDocument.someField, '111');\n  });\n\n  it('allows validating doc again if pre validate errors out (gh-10830)', async function() {\n    const BookSchema = Schema({\n      name: String,\n      price: Number,\n      quantity: Number\n    });\n\n    BookSchema.pre('validate', disallownumflows);\n\n    const Book = db.model('Test', BookSchema);\n\n    function disallownumflows(next) {\n      const self = this;\n      if (self.isNew) return next();\n\n      if (self.quantity === 27) {\n        return next(new Error('Wrong Quantity'));\n      }\n\n      next();\n    }\n\n    const { _id } = await Book.create({ name: 'Hello', price: 50, quantity: 25 });\n\n    const doc = await Book.findById(_id);\n\n    doc.quantity = 27;\n    const err = await doc.save().then(() => null, err => err);\n    assert.ok(err);\n\n    doc.quantity = 26;\n    await doc.save();\n  });\n\n  it('ensures that doc.ownerDocument() and doc.parent() by default return this on the root document (gh-10884)', async function() {\n    const userSchema = new mongoose.Schema({\n      name: String,\n      email: String\n    });\n\n    const Event = db.model('Rainbow', userSchema);\n\n    const e = new Event({ name: 'test' });\n    assert.strictEqual(e, e.parent());\n    assert.strictEqual(e, e.ownerDocument());\n  });\n\n  it('catches errors in `required` functions (gh-10968)', async function() {\n    const TestSchema = new Schema({\n      url: {\n        type: String,\n        required: function() {\n          throw new Error('oops!');\n        }\n      }\n    });\n    const Test = db.model('Test', TestSchema);\n\n    const err = await Test.create({}).then(() => null, err => err);\n    assert.ok(err);\n    assert.equal(err.errors['url'].message, 'oops!');\n  });\n\n  it('does not allow overwriting schema methods with strict: false (gh-11001)', async function() {\n    const TestSchema = new Schema({\n      text: { type: String, default: 'text' }\n    }, { strict: false });\n    TestSchema.methods.someFn = () => 'good';\n    const Test = db.model('Test', TestSchema);\n\n    const unTrusted = { someFn: () => 'bad' };\n\n    let x = await Test.create(unTrusted);\n    await x.save();\n    assert.equal(x.someFn(), 'good');\n\n    x = new Test(unTrusted);\n    await x.save();\n    assert.equal(x.someFn(), 'good');\n\n    x = await Test.create({});\n    await x.set(unTrusted);\n    assert.equal(x.someFn(), 'good');\n  });\n\n  it('allows setting nested to instance of document (gh-11011)', async function() {\n    const TransactionSchema = new Schema({\n      payments: [\n        {\n          id: { type: String },\n          terminal: {\n            _id: { type: Schema.Types.ObjectId },\n            name: { type: String }\n          }\n        }\n      ]\n    });\n\n    const TerminalSchema = new Schema({\n      name: { type: String },\n      apiKey: { type: String }\n    });\n\n    const Transaction = db.model('Test1', TransactionSchema);\n    const Terminal = db.model('Test2', TerminalSchema);\n\n    const transaction = new Transaction();\n    const terminal = new Terminal({\n      name: 'Front desk',\n      apiKey: 'somesecret'\n    });\n    transaction.payments.push({\n      id: 'testPayment',\n      terminal: terminal\n    });\n    assert.equal(transaction.payments[0].terminal.name, 'Front desk');\n  });\n\n  it('cleans modified paths on deeply nested subdocuments (gh-11060)', async function() {\n    const childSchema = new Schema({ status: String });\n\n    const deploymentsSchema = new Schema({\n      before: { type: childSchema, required: false },\n      after: { type: childSchema, required: false }\n    }, { _id: false });\n\n    const testSchema = new Schema({\n      name: String,\n      deployments: { type: deploymentsSchema }\n    });\n    const Test = db.model('Test', testSchema);\n\n    await Test.create({\n      name: 'hello',\n      deployments: {\n        before: { status: 'foo' }\n      }\n    });\n\n    const entry = await Test.findOne({ name: 'hello' });\n    const deployment = entry.deployments.before;\n    deployment.status = 'bar';\n    entry.deployments.before = null;\n    entry.deployments.after = deployment;\n\n    assert.ok(!entry.isDirectModified('deployments.before.status'));\n    await entry.save();\n  });\n\n  it('can manually populate subdocument refs (gh-10856)', async function() {\n    // Bar model, has a name property and some other properties that we are interested in\n    const BarSchema = new Schema({\n      name: String,\n      more: String,\n      another: Number\n    });\n    const Bar = db.model('Bar', BarSchema);\n\n    // Denormalised Bar schema with just the name, for use on the Foo model\n    const BarNameSchema = new Schema({\n      _id: {\n        type: Schema.Types.ObjectId,\n        ref: 'Bar'\n      },\n      name: String\n    });\n\n    // Foo model, which contains denormalized bar data (just the name)\n    const FooSchema = new Schema({\n      something: String,\n      other: Number,\n      bar: {\n        type: BarNameSchema,\n        ref: 'Bar'\n      }\n    });\n    const Foo = db.model('Foo', FooSchema);\n\n    const bar2 = await Bar.create({\n      name: 'I am another Bar',\n      more: 'With even more data',\n      another: 3\n    });\n    const foo2 = await Foo.create({\n      something: 'I am another Foo',\n      other: 4\n    });\n\n    foo2.bar = bar2;\n    assert.ok(foo2.bar instanceof Bar);\n    assert.equal(foo2.bar.another, 3);\n    assert.equal(foo2.get('bar.another'), 3);\n\n    const obj = foo2.toObject({ depopulate: true });\n    assert.equal(obj.bar.name, 'I am another Bar');\n    assert.strictEqual(obj.bar.another, undefined);\n\n    await foo2.save();\n    const fromDb = await Foo.findById(foo2).lean();\n    assert.strictEqual(fromDb.bar.name, 'I am another Bar');\n    assert.strictEqual(fromDb.bar.another, undefined);\n  });\n\n  it('can manually populate subdocument refs in `create()` (gh-10856)', async function() {\n    // Bar model, has a name property and some other properties that we are interested in\n    const BarSchema = new Schema({\n      name: String,\n      more: String,\n      another: Number\n    });\n    const Bar = db.model('Bar', BarSchema);\n\n    // Denormalised Bar schema with just the name, for use on the Foo model\n    const BarNameSchema = new Schema({\n      _id: {\n        type: Schema.Types.ObjectId,\n        ref: 'Bar'\n      },\n      name: String\n    });\n\n    // Foo model, which contains denormalized bar data (just the name)\n    const FooSchema = new Schema({\n      something: String,\n      other: Number,\n      bar: {\n        type: BarNameSchema,\n        ref: 'Bar'\n      }\n    });\n    const Foo = db.model('Foo', FooSchema);\n\n    const bar = await Bar.create({\n      name: 'I am Bar',\n      more: 'With more data',\n      another: 2\n    });\n    const foo = await Foo.create({\n      something: 'I am Foo',\n      other: 1,\n      bar\n    });\n\n    assert.ok(foo.bar instanceof Bar);\n    assert.equal(foo.bar.another, 2);\n    assert.equal(foo.get('bar.another'), 2);\n  });\n\n  it('populating subdocument refs underneath maps throws (gh-12494) (gh-10856)', async function() {\n    // Bar model, has a name property and some other properties that we are interested in\n    const BarSchema = new Schema({\n      name: String,\n      more: String,\n      another: Number\n    });\n    const Bar = db.model('Bar', BarSchema);\n\n    // Denormalised Bar schema with just the name, for use on the Foo model\n    const BarNameSchema = new Schema({\n      _id: {\n        type: Schema.Types.ObjectId,\n        ref: 'Bar'\n      },\n      name: String\n    });\n\n    // Foo model, which contains denormalized bar data (just the name)\n    const FooSchema = new Schema({\n      something: String,\n      other: Number,\n      map: {\n        type: Map,\n        of: {\n          type: BarNameSchema,\n          ref: 'Bar'\n        }\n      }\n    });\n    const Foo = db.model('Foo', FooSchema);\n\n    const bar = await Bar.create({\n      name: 'I am Bar',\n      more: 'With more data',\n      another: 2\n    });\n    const { _id } = await Foo.create({\n      something: 'I am Foo',\n      other: 1,\n      map: { test: bar }\n    });\n\n    const err = await Foo.findById(_id).populate('map').then(() => null, err => err);\n    assert.ok(err);\n    assert.ok(err.message.includes('Cannot manually populate single nested subdoc underneath Map'), err.message);\n  });\n\n  it('handles save with undefined nested doc under subdoc (gh-11110)', async function() {\n    const testSchema = new Schema({\n      level_1_array: [new Schema({\n        level_1: {\n          level_2: new Schema({\n            level_3: {\n              name_3: String,\n              level_4: {\n                name_4: String\n              }\n            }\n          })\n        }\n      })]\n    });\n\n    const Test = db.model('Test', testSchema);\n\n    const doc = {\n      level_1_array: [{\n        level_1: {\n          level_2: {\n            level_3: {\n              name_3: 'test',\n              level_4: undefined\n            }\n          }\n        }\n      }]\n    };\n\n    await new Test(doc).save();\n  });\n\n  it('correctly handles modifying array subdoc after setting array subdoc to same value (gh-11172)', async function() {\n    const Order = db.model('Order', new Schema({\n      cumulativeConsumption: [{\n        _id: false,\n        unit: String,\n        value: Number\n      }]\n    }));\n\n    await Order.create({\n      cumulativeConsumption: [{ unit: 'foo', value: 123 }, { unit: 'bar', value: 42 }]\n    });\n\n    const doc = await Order.findOne();\n    doc.cumulativeConsumption = doc.toObject().cumulativeConsumption;\n\n    const match = doc.cumulativeConsumption.find(o => o.unit === 'bar');\n    match.value = 43;\n    match.unit = 'baz';\n\n    assert.ok(doc.isModified());\n    assert.ok(doc.isModified('cumulativeConsumption.1'));\n  });\n\n  it('handles `String` with `type` (gh-11199)', function() {\n    String.type = String;\n    const schema = new mongoose.Schema({\n      something: String,\n      somethingElse: { type: String, trim: true }\n    });\n\n    const Test = db.model('Test', schema);\n    const doc = new Test({ something: 'test', somethingElse: 'test 2' });\n    assert.equal(typeof doc.something, 'string');\n    assert.equal(typeof doc.somethingElse, 'string');\n    delete String.type;\n  });\n\n  it('applies subdocument defaults when projecting dotted subdocument fields', async function() {\n    const version = await start.mongodVersion();\n    if (version[0] < 5) {\n      return this.skip();\n    }\n\n    const grandChildSchema = new mongoose.Schema({\n      name: {\n        type: mongoose.Schema.Types.String,\n        default: () => 'grandchild'\n      }\n    });\n\n    const childSchema = new mongoose.Schema({\n      name: {\n        type: mongoose.Schema.Types.String,\n        default: () => 'child'\n      },\n      grandChild: {\n        type: grandChildSchema,\n        default: () => ({})\n      }\n    });\n\n    const parentSchema = new mongoose.Schema({\n      name: mongoose.Schema.Types.String,\n      child: {\n        type: childSchema,\n        default: () => ({})\n      }\n    });\n\n    const ParentModel = db.model('Parent', parentSchema);\n    // insert an object without mongoose adding missing defaults\n    const result = await db.collection('Parent').insertOne({ name: 'parent' });\n\n    // ensure that the defaults are populated when no projections are used\n    const doc = await ParentModel.findById(result.insertedId).exec();\n    assert.equal(doc.name, 'parent');\n    assert.equal(doc.child.name, 'child');\n    assert.equal(doc.child.grandChild.name, 'grandchild');\n\n    // ensure that defaults are populated when using an object projection\n    const projectedDoc = await ParentModel.findById(result.insertedId, {\n      name: 1,\n      child: {\n        name: 1,\n        grandChild: {\n          name: 1\n        }\n      }\n    }).exec();\n    assert.equal(projectedDoc.name, 'parent');\n    assert.equal(projectedDoc.child.name, 'child');\n    assert.equal(projectedDoc.child.grandChild.name, 'grandchild');\n\n    // ensure that defaults are populated when using dotted path projections\n    const dottedProjectedDoc = await ParentModel.findById(result.insertedId, {\n      name: 1,\n      'child.name': 1,\n      'child.grandChild.name': 1\n    }).exec();\n    assert.equal(dottedProjectedDoc.name, 'parent');\n    assert.equal(dottedProjectedDoc.child.name, 'child');\n    assert.equal(dottedProjectedDoc.child.grandChild.name, 'grandchild');\n  });\n\n  it('handles initing nested properties in non-strict documents (gh-11309)', async function() {\n    const NestedSchema = new Schema({}, {\n      id: false,\n      _id: false,\n      strict: false\n    });\n\n    const ItemSchema = new Schema({\n      name: {\n        type: String\n      },\n      nested: NestedSchema\n    });\n\n    const Test = db.model('Test', ItemSchema);\n\n    const item = await Test.create({\n      nested: {\n        foo: {\n          bar: 55\n        }\n      }\n    });\n\n    // Modify nested data\n    item.nested.foo.bar = 66;\n    item.markModified('nested.foo.bar');\n    await item.save();\n\n    const reloaded = await Test.findOne({ _id: item._id });\n\n    assert.deepEqual(reloaded.nested.foo, { bar: 66 });\n    assert.ok(!reloaded.nested.foo.$__isNested);\n    assert.strictEqual(reloaded.nested.foo.bar, 66);\n  });\n\n  it('saves changes when setting a nested path to itself (gh-11395)', async function() {\n    const Test = db.model('Test', new Schema({\n      co: { value: Number }\n    }));\n\n    await Test.create({});\n\n    const doc = await Test.findOne();\n    doc.co.value = 123;\n    doc.co = doc.co;\n    await doc.save();\n\n    const res = await Test.findById(doc._id);\n    assert.strictEqual(res.co.value, 123);\n  });\n\n  it('avoids setting nested properties on top-level document when init-ing with strict: false (gh-11526) (gh-11309)', async function() {\n    const testSchema = Schema({ name: String }, { strict: false, strictQuery: false });\n    const Test = db.model('Test', testSchema);\n\n    const doc = new Test();\n    doc.init({\n      details: {\n        person: {\n          name: 'Baz'\n        }\n      }\n    });\n\n    assert.strictEqual(doc.name, void 0);\n  });\n\n  it('handles deeply nested subdocuments when getting paths to validate (gh-11501)', async function() {\n    const schema = Schema({\n      parameters: {\n        test: {\n          type: new Schema({\n            value: 'Mixed'\n          })\n        }\n      },\n      nested: Schema({\n        parameters: {\n          type: Map,\n          of: Schema({\n            value: 'Mixed'\n          })\n        }\n      })\n    });\n    const Test = db.model('Test', schema);\n\n    await Test.create({\n      nested: {\n        parameters: new Map([['test', { answer: 42 }]])\n      }\n    });\n  });\n\n  it('handles casting array of spread documents (gh-11522)', async function() {\n    const Test = db.model('Test', new Schema({\n      arr: [{ _id: false, prop1: String, prop2: String }]\n    }));\n\n    const doc = new Test({ arr: [{ prop1: 'test' }] });\n\n    doc.arr = doc.arr.map(member => ({\n      ...member,\n      prop2: 'foo'\n    }));\n\n    assert.deepStrictEqual(doc.toObject().arr, [{ prop1: 'test', prop2: 'foo' }]);\n\n    await doc.validate();\n  });\n\n  it('avoids setting modified on subdocument defaults (gh-11528)', async function() {\n    const textSchema = new Schema({\n      text: { type: String }\n    }, { _id: false });\n\n    const messageSchema = new Schema({\n      body: { type: textSchema, default: { text: 'hello' } },\n      date: { type: Date, default: Date.now }\n    });\n\n\n    const Message = db.model('Test', messageSchema);\n\n    const entry = await Message.create({});\n\n    const failure = await Message.findById({ _id: entry._id });\n\n    assert.deepEqual(failure.modifiedPaths(), []);\n  });\n\n  it('works when passing dot notation to mixed property (gh-1946)', async function() {\n    const schema = Schema({\n      name: String,\n      mix: { type: Schema.Types.Mixed },\n      nested: { prop: String }\n    });\n    const M = db.model('Test', schema);\n    const m1 = new M({ name: 'test', 'mix.val': 'foo', 'nested.prop': 'bar' });\n    assert.equal(m1.name, 'test');\n    assert.equal(m1.mix.val, 'foo');\n    assert.equal(m1.nested.prop, 'bar');\n    await m1.save();\n    assert.equal(m1.name, 'test');\n    assert.equal(m1.mix.val, 'foo');\n\n    const doc = await M.findById(m1);\n    assert.equal(doc.name, 'test');\n    assert.equal(doc.mix.val, 'foo');\n  });\n\n  it('correctly validates deeply nested document arrays (gh-11564)', async function() {\n    const testSchemaSub3 = new mongoose.Schema({\n      name: {\n        type: String,\n        required: true\n      }\n    });\n\n    const testSchemaSub2 = new mongoose.Schema({\n      name: {\n        type: String,\n        required: true\n      },\n      list: [testSchemaSub3]\n    });\n\n    const testSchemaSub1 = new mongoose.Schema({\n      name: {\n        type: String,\n        required: true\n      },\n      list: [testSchemaSub2]\n    });\n\n    const testSchema = new mongoose.Schema({\n      name: String,\n      list: [testSchemaSub1]\n    });\n\n    const testModel = db.model('Test', testSchema);\n\n    await testModel.create({\n      name: 'lvl1',\n      list: [{\n        name: 'lvl2',\n        list: [{\n          name: 'lvl3'\n        }]\n      }]\n    });\n  });\n\n  it('reruns validation when modifying a document array path under a nested path after save (gh-11672)', async function() {\n    const ChildSchema = new Schema({\n      price: {\n        type: Number,\n        validate: function(val) {\n          return val > 0;\n        }\n      }\n    });\n\n    const ParentSchema = new Schema({\n      rootField: { nestedSubdocArray: [ChildSchema] }\n    });\n    const Test = db.model('Test', ParentSchema);\n\n    const parentDoc = new Test({\n      rootField: {\n        nestedSubdocArray: [\n          {\n            price: 1\n          }\n        ]\n      }\n    });\n\n    await parentDoc.save();\n\n    // Now we try editing to an invalid value which should throw\n    parentDoc.rootField.nestedSubdocArray[0].price = -1;\n    const err = await parentDoc.save().then(() => null, err => err);\n\n    assert.ok(err);\n    assert.equal(err.name, 'ValidationError');\n    assert.ok(err.message.includes('failed for path'), err.message);\n    assert.ok(err.message.includes('value `-1`'), err.message);\n  });\n\n  it('avoids setting nested paths to null when they are set to `undefined` (gh-11723)', async function() {\n    const nestedSchema = new mongoose.Schema({\n      count: Number\n    }, { _id: false });\n\n    const mySchema = new mongoose.Schema({\n      name: String,\n      nested: { count: Number },\n      nestedSchema: nestedSchema\n    }, { minimize: false });\n\n    const Test = db.model('Test', mySchema);\n\n    const instance1 = new Test({ name: 'test1', nested: { count: 1 }, nestedSchema: { count: 1 } });\n    await instance1.save();\n\n    const update = { nested: { count: undefined }, nestedSchema: { count: undefined } };\n    instance1.set(update);\n    await instance1.save();\n\n    const doc = await Test.findById(instance1);\n    assert.strictEqual(doc.nested.count, undefined);\n    assert.strictEqual(doc.nestedSchema.count, undefined);\n  });\n\n  it('cleans modified subpaths when setting nested path under array to null when subpaths are modified (gh-11764)', async function() {\n    const Test = db.model('Test', new Schema({\n      list: [{\n        quantity: {\n          value: Number,\n          unit: String\n        }\n      }]\n    }));\n\n    let doc = await Test.create({ list: [{ quantity: { value: 1, unit: 'case' } }] });\n\n    doc = await Test.findById(doc);\n    doc.list[0].quantity.value = null;\n    doc.list[0].quantity.unit = null;\n    doc.list[0].quantity = null;\n\n    await doc.save();\n\n    doc = await Test.findById(doc);\n    assert.strictEqual(doc.list[0].toObject().quantity, null);\n  });\n\n  it('avoids manually populating document that is manually populated in another doc with different unpopulatedValue (gh-11442) (gh-11008)', async function() {\n    const BarSchema = new Schema({\n      name: String,\n      more: String\n    });\n    const Bar = db.model('Bar', BarSchema);\n\n    // Denormalised Bar schema with just the name, for use on the Foo model\n    const BarNameSchema = new Schema({\n      _id: {\n        type: Schema.Types.ObjectId,\n        ref: 'Bar'\n      },\n      name: String\n    });\n\n    // Foo model, which contains denormalized bar data (just the name)\n    const FooSchema = new Schema({\n      something: String,\n      other: Number,\n      bar: {\n        type: BarNameSchema,\n        ref: 'Bar'\n      }\n    });\n    const Foo = db.model('Foo', FooSchema);\n\n    const Baz = db.model('Baz', new Schema({ bar: { type: 'ObjectId', ref: 'Bar' } }));\n\n    const bar = await Bar.create({\n      name: 'I am another Bar',\n      more: 'With even more data'\n    });\n    const foo = await Foo.create({\n      something: 'I am another Foo',\n      other: 4\n    });\n    foo.bar = bar;\n    const baz = await Baz.create({});\n    baz.bar = bar;\n\n    assert.ok(foo.populated('bar'));\n    assert.ok(!baz.populated('bar'));\n\n    let res = foo.toObject({ depopulate: true });\n    assert.strictEqual(res.bar._id.toString(), bar._id.toString());\n    assert.strictEqual(res.bar.name, 'I am another Bar');\n\n    res = baz.toObject({ depopulate: true });\n    assert.strictEqual(res.bar.toString(), bar._id.toString());\n\n    const bar2 = await Bar.create({\n      name: 'test2'\n    });\n    baz.bar = bar2;\n    assert.ok(baz.populated('bar'));\n\n    const baz2 = await Baz.create({});\n    baz2.bar = bar2;\n    assert.ok(baz.populated('bar'));\n  });\n\n  it('$getAllSubdocs gets document arrays underneath a nested path (gh-11917)', function() {\n    const nestedSettingsSchema = new Schema({\n      value: String,\n      active: Boolean\n    });\n\n    const userSettingsSchema = new Schema({\n      nestedSettings: {\n        settingsProps: [nestedSettingsSchema]\n      }\n    });\n\n    const userSchema = new Schema({\n      first_name: String,\n      last_name: String,\n      settings: userSettingsSchema\n    });\n\n    const User = db.model('User', userSchema);\n\n    const doc = new User({\n      settings: {\n        nestedSettings: {\n          settingsProps: [{ value: 'test', active: true }]\n        }\n      }\n    });\n\n    const subdocs = doc.$getAllSubdocs();\n    assert.equal(subdocs.length, 2);\n    assert.equal(subdocs[0].value, 'test');\n    assert.ok(subdocs[1].nestedSettings);\n  });\n\n  it('handles validation errors on deeply nested subdocuments underneath a nested path (gh-12021)', async function() {\n    const SubSubSchema = new mongoose.Schema(\n      {\n        from: {\n          type: mongoose.Schema.Types.String,\n          required: true\n        }\n      },\n      { _id: false }\n    );\n\n    const SubSchema = new mongoose.Schema(\n      {\n        nested: {\n          type: SubSubSchema,\n          required: false // <-- important\n        }\n      },\n      { _id: false }\n    );\n\n    const TestLeafSchema = new mongoose.Schema({\n      testProp: {\n        testSubProp: {\n          type: SubSchema,\n          required: true\n        }\n      }\n    });\n\n    const TestLeafModel = mongoose.model('test-leaf-model', TestLeafSchema);\n\n    const testModelInstance = new TestLeafModel({\n      testProp: {\n        testSubProp: {\n          nested: { from: null }\n        }\n      }\n    });\n\n    const err = await testModelInstance.validate().then(() => null, err => err);\n    assert.ok(err);\n    assert.ok(err.errors['testProp.testSubProp.nested.from']);\n  });\n\n  describe('$inc (gh-11915)', function() {\n    describe('top-level path', function() {\n      let Test;\n\n      beforeEach(function() {\n        const schema = new Schema({\n          counter: Number\n        });\n        Test = db.model('Test', schema);\n      });\n\n      it('sends a $inc command for a given path', async function() {\n        await Test.create({ counter: 0 });\n        const doc = await Test.findOne();\n        assert.strictEqual(doc.counter, 0);\n        const doc2 = await Test.findOne();\n\n        doc2.counter = 1;\n        await doc2.save();\n\n        doc.$inc('counter', 1);\n        await doc.save();\n\n        const res = await Test.findById(doc);\n        assert.equal(res.counter, 2);\n      });\n\n      it('calls setters on the value passed to `$inc()` (gh-13158)', async function() {\n        const called = [];\n        const Test2 = db.model('Test2', Schema({\n          counter: {\n            type: Number,\n            set: v => { called.push(v); return v.toFixed(2); }\n          }\n        }));\n        const doc = await Test2.create({ counter: 2 });\n        assert.deepEqual(called, [2]);\n\n        doc.$inc('counter', 1.14159);\n        assert.deepEqual(called, [2, 3.14159]);\n        assert.equal(doc.counter, 3.14);\n        await doc.save();\n\n        const res = await Test2.findById(doc);\n        assert.equal(res.counter, 3.14);\n      });\n\n      it('avoids updating value if setter fails (gh-13158)', async function() {\n        const called = [];\n        const Test2 = db.model('Test2', Schema({\n          counter: {\n            type: Number,\n            set: v => {\n              called.push(v);\n              if (v > 3) {\n                throw new Error('Oops!');\n              }\n              return v;\n            }\n          }\n        }));\n        const doc = await Test2.create({ counter: 2 });\n        assert.deepEqual(called, [2]);\n\n        doc.$inc('counter', 3);\n        assert.deepEqual(called, [2, 5]);\n        assert.equal(doc.counter, 2);\n        const err = await doc.save().then(() => null, err => err);\n        assert.ok(err);\n        assert.ok(err.errors['counter']);\n      });\n\n      it('works as a $set if the document is new', async function() {\n        const doc = new Test({ counter: 0 });\n        doc.$inc('counter', 2);\n        assert.equal(doc.counter, 2);\n\n        await doc.save();\n\n        const res = await Test.findById(doc);\n        assert.equal(res.counter, 2);\n      });\n\n      it('treats as a $set if set after $inc', async function() {\n        await Test.create({ counter: 0 });\n        const doc = await Test.findOne();\n\n        doc.$inc('counter', 2);\n        doc.counter = 5;\n        assert.deepStrictEqual(doc.getChanges(), { $set: { counter: 5 } });\n        await doc.save();\n\n        const res = await Test.findOne();\n        assert.equal(res.counter, 5);\n      });\n\n      it('tries to cast to number', async function() {\n        await Test.create({ counter: 0 });\n        const doc = await Test.findOne();\n\n        doc.$inc('counter', '2');\n        assert.deepStrictEqual(doc.getChanges(), { $inc: { counter: 2 } });\n        await doc.save();\n\n        const res = await Test.findOne();\n        assert.equal(res.counter, 2);\n      });\n\n      it('stores CastError if can\\'t convert to number', async function() {\n        await Test.create({ counter: 0 });\n        const doc = await Test.findOne();\n\n        doc.$inc('counter', 'foobar');\n        const err = await doc.save().then(() => null, err => err);\n        assert.ok(err);\n        assert.equal(err.errors['counter'].name, 'CastError');\n      });\n    });\n\n    describe('nested paths', function() {\n      let Test;\n\n      beforeEach(function() {\n        const schema = new Schema({\n          nested: {\n            counter: Number\n          }\n        });\n        Test = db.model('Test', schema);\n      });\n\n      it('handles nested paths', async function() {\n        await Test.create({ nested: { counter: 0 } });\n        const doc = await Test.findOne();\n\n        doc.$inc('nested.counter', 2);\n        await doc.save();\n\n        const res = await Test.findById(doc);\n        assert.equal(res.nested.counter, 2);\n      });\n\n      it('treats as $set if overwriting nested path', async function() {\n        await Test.create({ nested: { counter: 0 } });\n        const doc = await Test.findOne();\n\n        doc.$inc('nested.counter', 2);\n        doc.nested.counter += 3;\n        await doc.save();\n\n        const res = await Test.findById(doc);\n        assert.equal(res.nested.counter, 5);\n      });\n    });\n\n    describe('subdocuments', function() {\n      let Test;\n\n      beforeEach(function() {\n        const schema = new Schema({\n          subdoc: new Schema({\n            counter: Number\n          })\n        });\n        Test = db.model('Test', schema);\n      });\n\n      it('handles paths underneath subdocuments', async function() {\n        await Test.create({ subdoc: { counter: 0 } });\n        const doc = await Test.findOne();\n\n        doc.$inc('subdoc.counter', 2);\n        await doc.save();\n\n        const res = await Test.findById(doc);\n        assert.equal(res.subdoc.counter, 2);\n      });\n\n      it('treats as a $set if setting subdocument after $inc', async function() {\n        await Test.create({ subdoc: { counter: 0 } });\n        const doc = await Test.findOne();\n\n        doc.$inc('subdoc.counter', 2);\n        doc.subdoc = { counter: 5 };\n        await doc.save();\n\n        const res = await Test.findById(doc);\n        assert.equal(res.subdoc.counter, 5);\n      });\n    });\n\n    describe('document array', function() {\n      let Test;\n\n      beforeEach(function() {\n        const schema = new Schema({\n          docArr: [{ counter: Number }]\n        });\n        Test = db.model('Test', schema);\n      });\n\n      it('handles paths underneath subdocuments', async function() {\n        await Test.create({ docArr: [{ counter: 0 }] });\n        const doc = await Test.findOne();\n\n        doc.docArr[0].$inc('counter');\n        await doc.save();\n\n        const res = await Test.findById(doc);\n        assert.equal(res.docArr[0].counter, 1);\n      });\n\n      it('works on pushed subdocs', async function() {\n        await Test.create({ docArr: [] });\n        const doc = await Test.findOne();\n\n        doc.docArr.push({ counter: 0 });\n        doc.docArr[0].$inc('counter');\n        await doc.save();\n\n        const res = await Test.findById(doc);\n        assert.equal(res.docArr[0].counter, 1);\n      });\n      it('Splice call registers path modification', async function() {\n        await Test.create({ docArr: [{ counter: 0 }, { counter: 2 }, { counter: 3 }, { counter: 4 }] });\n        const doc = await Test.findOne();\n        doc.docArr.splice(1, 0, { counter: 1 });\n        assert.equal(doc.isModified('docArr'), true);\n      });\n    });\n\n    it('stores CastError if trying to $inc a non-numeric path', async function() {\n      const schema = new Schema({\n        prop: String\n      });\n      const Test = db.model('Test', schema);\n\n      await Test.create({ prop: '' });\n      const doc = await Test.findOne();\n\n      doc.$inc('prop', 2);\n      const err = await doc.save().then(() => null, err => err);\n      assert.ok(err);\n      assert.equal(err.errors['prop'].name, 'CastError');\n    });\n    it('should correctly increment even if the document has not saved after each increment gh-13274', async function() {\n      const schema = new Schema({\n        coins: Number\n      });\n      const Test = db.model('gh13274', schema);\n      await Test.create({ coins: 0 });\n      const doc = await Test.findOne();\n      doc.$inc('coins', 1000);\n      doc.$inc('coins', 2000);\n      await doc.save();\n      const check = await Test.findOne();\n      assert.equal(check.coins, 3000);\n    });\n  });\n\n  it('supports virtuals named `isValid` (gh-12124) (gh-6262)', async function() {\n    const Schema = new mongoose.Schema({\n      test: String,\n      data: { sub: String }\n    });\n\n    Schema.virtual('isValid');\n\n    const Test = db.model('Test', Schema);\n    let doc = new Test();\n\n    assert.ok(doc.$isValid('test'));\n    await doc.save();\n\n    doc = await Test.findOne();\n\n    doc.set('isValid', true);\n    assert.ok(doc.$isValid('test'));\n\n    doc.set({ test: 'test' });\n    await doc.save();\n    assert.equal(doc.test, 'test');\n\n    doc.set({ data: { sub: 'sub' } });\n    await doc.save();\n    assert.equal(doc.data.sub, 'sub');\n  });\n\n  it('handles maps when applying defaults to nested paths (gh-12220)', async function() {\n    const nestedSchema = new mongoose.Schema({\n      1: {\n        type: Number,\n        default: 0\n      }\n    });\n\n    const topSchema = new mongoose.Schema({\n      nestedPath1: {\n        mapOfSchema: {\n          type: Map,\n          of: nestedSchema\n        }\n      }\n    });\n\n    const Test = db.model('Test', topSchema);\n\n    const data = {\n      nestedPath1: {\n        mapOfSchema: {}\n      }\n    };\n    const doc = await Test.create(data);\n\n    assert.ok(doc.nestedPath1.mapOfSchema);\n  });\n\n  it('correct context for default functions in subdocuments with init (gh-12328)', async function() {\n    let called = 0;\n\n    const subSchema = new mongoose.Schema({\n      propertyA: { type: String },\n      propertyB: {\n        type: String,\n        default: function() {\n          ++called;\n          return this.propertyA;\n        }\n      }\n    });\n\n    const testSchema = new mongoose.Schema(\n      {\n        name: String,\n        sub: { type: subSchema, default: () => ({}) }\n      }\n    );\n\n    const Test = db.model('Test', testSchema);\n\n    await Test.collection.insertOne({ name: 'test', sub: { propertyA: 'foo' } });\n    assert.strictEqual(called, 0);\n\n    const doc = await Test.findOne({ name: 'test' });\n    assert.strictEqual(doc.sub.propertyB, 'foo');\n    assert.strictEqual(called, 1);\n  });\n\n  it('applies defaults to pushed subdocs after initing document (gh-12515)', async function() {\n    const animalSchema = new Schema({ title: String });\n    const animalsSchema = new Schema({\n      species: [animalSchema],\n      totalAnimals: Number\n    });\n    const Userschema = new Schema({\n      animals: animalsSchema\n    });\n    const UserModel = db.model('User', Userschema);\n\n    const doc = new UserModel();\n    doc.animals = { totalAnimals: 1 };\n    doc.animals.species = [{ title: 'Lion' }];\n    await doc.save();\n    // once created we fetch it again\n    let user = await UserModel.findById(doc._id);\n\n    // add new animal\n    user.animals.species.push({ title: 'Elephant' });\n    await user.save();\n    assert.ok(user.animals.species[0]._id);\n    assert.ok(user.animals.species[1]._id);\n    user = await UserModel.collection.findOne({ _id: user._id });\n\n    assert.ok(user.animals.species[0]._id);\n    assert.ok(user.animals.species[1]._id);\n  });\n\n  it('If the field does not exist, $inc should create it and set is value to the specified one (gh-12435)', async function() {\n    const schema = new mongoose.Schema({\n      name: String,\n      count: Number\n    });\n    const Model = db.model('IncTest', schema);\n    const doc = new Model({ name: 'Test' });\n    await doc.save();\n    doc.$inc('count', 1);\n    await doc.save();\n\n    assert.strictEqual(doc.count, 1);\n\n    const addedDoc = await Model.findOne({ name: 'Test' });\n    assert.strictEqual(addedDoc.count, 1);\n  });\n\n  it('avoids overwriting array if saving with no changes with array deselected (gh-12414)', async function() {\n    const schema = new mongoose.Schema({\n      name: String,\n      tags: [String]\n    });\n    const Test = db.model('Test', schema);\n\n    const { _id } = await Test.create({ name: 'Mongoose', tags: ['mongodb'] });\n\n    const doc = await Test.findById(_id).select('name');\n    assert.deepStrictEqual(doc.getChanges(), {});\n    await doc.save();\n\n    const rawDoc = await Test.collection.findOne({ _id });\n    assert.ok(rawDoc);\n    assert.deepStrictEqual(rawDoc.tags, ['mongodb']);\n  });\n\n  it('$clone() (gh-11849)', async function() {\n    const schema = new mongoose.Schema({\n      name: {\n        type: String,\n        validate: {\n          validator: (v) => v !== 'Invalid'\n        }\n      }\n    });\n    const Test = db.model('Test', schema);\n\n    const item = await Test.create({ name: 'Test' });\n\n    const doc = await Test.findById(item._id);\n    const clonedDoc = doc.$clone();\n\n    assert.deepEqual(clonedDoc, doc);\n    assert.deepEqual(clonedDoc._doc, doc._doc);\n    assert.deepEqual(clonedDoc.$__, doc.$__);\n\n    // Editing a field in the cloned doc does not effect\n    // the original doc\n    clonedDoc.name = 'Test 2';\n    assert.equal(doc.name, 'Test');\n    assert.equal(clonedDoc.name, 'Test 2');\n    assert.ok(!doc.$isModified('name'));\n    assert.ok(clonedDoc.$isModified('name'));\n\n    // Saving the cloned doc does not effect `modifiedPaths`\n    // in the original doc\n    const modifiedPaths = [...doc.modifiedPaths()];\n    await clonedDoc.save();\n    assert.deepEqual(doc.modifiedPaths(), modifiedPaths);\n\n    // Cloning a doc with invalid field preserve the\n    // invalid field value\n    doc.name = 'Invalid';\n    await assert.rejects(async() => {\n      await doc.validate();\n    });\n\n    await clonedDoc.validate();\n\n    const invalidClonedDoc = doc.$clone();\n    doc.name = 'Test';\n    await doc.validate();\n    await assert.rejects(async() => {\n      await invalidClonedDoc.validate();\n    });\n\n    // Setting a session on the cloned doc does not\n    // affect the session in the original doc\n    const session = await Test.startSession();\n    clonedDoc.$session(session);\n    assert.strictEqual(doc.$session(), null);\n    assert.strictEqual(clonedDoc.$session(), session);\n  });\n\n  it('can create document with document array and top-level key named `schema` (gh-12480)', async function() {\n    const AuthorSchema = new Schema({\n      fullName: { type: 'String', required: true }\n    });\n\n    const BookSchema = new Schema({\n      schema: { type: 'String', required: true },\n      title: { type: 'String', required: true },\n      authors: [AuthorSchema]\n    }, { supressReservedKeysWarning: true });\n\n    const Book = db.model('Book', BookSchema);\n\n    await Book.create({\n      schema: 'design',\n      authors: [{ fullName: 'Sourabh Bagrecha' }],\n      title: 'The power of JavaScript'\n    });\n  });\n\n  it('handles setting array to itself after saving and pushing a new value (gh-12656)', async function() {\n    const Test = db.model('Test', new Schema({\n      list: [{\n        a: Number\n      }]\n    }));\n    await Test.create({ list: [{ a: 1, b: 11 }] });\n\n    let doc = await Test.findOne();\n    doc.list.push({ a: 2 });\n    doc.list = [...doc.list];\n    await doc.save();\n\n    doc.list.push({ a: 3 });\n    doc.list = [...doc.list];\n    await doc.save();\n\n    doc = await Test.findOne();\n    assert.equal(doc.list.length, 3);\n    assert.deepStrictEqual(doc.list.map(el => el.a), [1, 2, 3]);\n  });\n\n  it('should not trigger isModified when setting a nested boolean to the same value as previously  (gh-12992)', async function() {\n    const Test = db.model('Test', new Schema({\n      result: new Schema(\n        {\n          score: Number,\n          passed: Boolean\n        },\n        { _id: false }\n      )\n    }));\n    const newTest = await Test.create({\n      result: {\n        score: 40,\n        passed: false\n      }\n    });\n\n    const existingTest = await Test.findById(newTest._id);\n    existingTest.result = {\n      score: 40,\n      passed: false\n    };\n\n    assert.equal(existingTest.isModified(), false);\n    assert.equal(existingTest.modifiedPaths().length, 0);\n\n    existingTest.result = {\n      score: 40,\n      passed: true\n    };\n\n    assert.equal(existingTest.isModified(), true);\n    assert.equal(existingTest.modifiedPaths().length, 1);\n  });\n\n  it('saves single nested subdoc defaults (gh-12905)', async function() {\n    const nestedSchema = new mongoose.Schema({\n      refOriginal: String,\n      refAnother: {\n        type: String,\n        default: () => 'goodbye'\n      }\n    });\n    const testSchema = new mongoose.Schema({\n      original: String,\n      another: {\n        type: String,\n        default: 'hello'\n      },\n      referenced: {\n        type: nestedSchema,\n        default: () => ({})\n      }\n    });\n    const Test = db.model('Test', testSchema);\n\n    const _id = new mongoose.Types.ObjectId();\n    await Test.collection.insertOne({\n      _id,\n      original: 'foo',\n      referenced: { refOriginal: 'hello' }\n    });\n\n    const doc = await Test.findById(_id);\n    assert.equal(doc.referenced.refOriginal, 'hello');\n    assert.equal(doc.referenced.refAnother, 'goodbye');\n\n    await doc.save();\n    const rawDoc = await Test.findById(_id).lean();\n    assert.equal(rawDoc.referenced.refOriginal, 'hello');\n    assert.equal(rawDoc.referenced.refAnother, 'goodbye');\n  });\n\n  it('$shift() triggers $pop', function() {\n    const Test = db.model('Test', mongoose.Schema({\n      arr: [String]\n    }, { autoCreate: false, autoIndex: false }));\n\n    const doc = Test.hydrate({ arr: ['a', 'b', 'c'] });\n    doc.arr.$shift();\n\n    assert.deepStrictEqual(\n      doc.getChanges(),\n      { $pop: { arr: -1 }, $inc: { __v: 1 } }\n    );\n  });\n\n  it('avoids setting array default if document array projected out by sibling projection (gh-13003)', async function() {\n    const schema = new mongoose.Schema({\n      name: String,\n      arr: [String],\n      properties: {\n        foo: String,\n        bar: [{ baz: String, qux: Boolean }],\n        baz: String\n      }\n    });\n    const Test = db.model('Test', schema);\n\n    const doc = new Test({}, { 'properties.foo': 1 });\n    doc.init({ properties: { foo: 'foo' } });\n    assert.strictEqual(doc.properties.bar, undefined);\n  });\n\n  it('avoids overwriting array with sibling projection (gh-13043)', async function() {\n    const testSchema = new mongoose.Schema({\n      str: 'string',\n      obj: {\n        subObj: {\n          str: 'string'\n        },\n        subArr: [{\n          str: 'string'\n        }]\n      },\n      arr: [{\n        str: 'string'\n      }]\n    });\n    const Test = db.model('Test', testSchema);\n    // Create one test document : obj.subArr[0].str === 'subArr.test1'\n    await Test.create({\n      str: 'test1',\n      obj: {\n        subObj: {\n          str: 'subObj.test1'\n        },\n        subArr: [{\n          str: 'subArr.test1'\n        }]\n      },\n      arr: [{ str: 'arr.test1' }]\n    });\n\n    const test = await Test.findOne({ str: 'test1' }, 'str obj.subObj');\n\n    // Update one property\n    test.str = test.str + ' - updated';\n    await test.save();\n\n    const fromDb = await Test.findById(test);\n    assert.equal(fromDb.obj.subArr.length, 1);\n    assert.equal(fromDb.obj.subArr[0].str, 'subArr.test1');\n  });\n});\n\ndescribe('Check if instance function that is supplied in schema option is availabe', function() {\n  it('should give an instance function back rather than undefined', function ModelJS() {\n    const testSchema = new mongoose.Schema({}, { methods: { instanceFn() { return 'Returned from DocumentInstanceFn'; } } });\n    const TestModel = mongoose.model('TestModel', testSchema);\n    const TestDocument = new TestModel({});\n    assert.equal(TestDocument.instanceFn(), 'Returned from DocumentInstanceFn');\n  });\n});\n"], "fixing_code": ["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\nconst InternalCache = require('./internal');\nconst MongooseError = require('./error/index');\nconst MixedSchema = require('./schema/mixed');\nconst ObjectExpectedError = require('./error/objectExpected');\nconst ObjectParameterError = require('./error/objectParameter');\nconst ParallelValidateError = require('./error/parallelValidate');\nconst Schema = require('./schema');\nconst StrictModeError = require('./error/strict');\nconst ValidationError = require('./error/validation');\nconst ValidatorError = require('./error/validator');\nconst $__hasIncludedChildren = require('./helpers/projection/hasIncludedChildren');\nconst promiseOrCallback = require('./helpers/promiseOrCallback');\nconst applyDefaults = require('./helpers/document/applyDefaults');\nconst cleanModifiedSubpaths = require('./helpers/document/cleanModifiedSubpaths');\nconst compile = require('./helpers/document/compile').compile;\nconst defineKey = require('./helpers/document/compile').defineKey;\nconst flatten = require('./helpers/common').flatten;\nconst flattenObjectWithDottedPaths = require('./helpers/path/flattenObjectWithDottedPaths');\nconst get = require('./helpers/get');\nconst getEmbeddedDiscriminatorPath = require('./helpers/document/getEmbeddedDiscriminatorPath');\nconst getKeysInSchemaOrder = require('./helpers/schema/getKeysInSchemaOrder');\nconst handleSpreadDoc = require('./helpers/document/handleSpreadDoc');\nconst immediate = require('./helpers/immediate');\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\nconst isExclusive = require('./helpers/projection/isExclusive');\nconst inspect = require('util').inspect;\nconst internalToObjectOptions = require('./options').internalToObjectOptions;\nconst markArraySubdocsPopulated = require('./helpers/populate/markArraySubdocsPopulated');\nconst mpath = require('mpath');\nconst queryhelpers = require('./queryhelpers');\nconst utils = require('./utils');\nconst isPromise = require('./helpers/isPromise');\n\nconst clone = utils.clone;\nconst deepEqual = utils.deepEqual;\nconst isMongooseObject = utils.isMongooseObject;\n\nconst arrayAtomicsBackupSymbol = require('./helpers/symbols').arrayAtomicsBackupSymbol;\nconst arrayAtomicsSymbol = require('./helpers/symbols').arrayAtomicsSymbol;\nconst documentArrayParent = require('./helpers/symbols').documentArrayParent;\nconst documentIsModified = require('./helpers/symbols').documentIsModified;\nconst documentModifiedPaths = require('./helpers/symbols').documentModifiedPaths;\nconst documentSchemaSymbol = require('./helpers/symbols').documentSchemaSymbol;\nconst getSymbol = require('./helpers/symbols').getSymbol;\nconst populateModelSymbol = require('./helpers/symbols').populateModelSymbol;\nconst scopeSymbol = require('./helpers/symbols').scopeSymbol;\nconst schemaMixedSymbol = require('./schema/symbols').schemaMixedSymbol;\nconst parentPaths = require('./helpers/path/parentPaths');\n\nlet DocumentArray;\nlet MongooseArray;\nlet Embedded;\n\nconst specialProperties = utils.specialProperties;\n\n/**\n * The core Mongoose document constructor. You should not call this directly,\n * the Mongoose [Model constructor](./api/model.html#Model) calls this for you.\n *\n * @param {Object} obj the values to set\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Object} [options] various configuration options for the document\n * @param {Boolean} [options.defaults=true] if `false`, skip applying default values to this document.\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\n * @event `init`: Emitted on a document after it has been retrieved from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, fields, skipId, options) {\n  if (typeof skipId === 'object' && skipId != null) {\n    options = skipId;\n    skipId = options.skipId;\n  }\n  options = Object.assign({}, options);\n\n  // Support `browserDocument.js` syntax\n  if (this.$__schema == null) {\n    const _schema = utils.isObject(fields) && !fields.instanceOfSchema ?\n      new Schema(fields) :\n      fields;\n    this.$__setSchema(_schema);\n    fields = skipId;\n    skipId = options;\n    options = arguments[4] || {};\n  }\n\n  this.$__ = new InternalCache();\n\n  // Avoid setting `isNew` to `true`, because it is `true` by default\n  if (options.isNew != null && options.isNew !== true) {\n    this.$isNew = options.isNew;\n  }\n\n  if (options.priorDoc != null) {\n    this.$__.priorDoc = options.priorDoc;\n  }\n\n  if (skipId) {\n    this.$__.skipId = skipId;\n  }\n\n  if (obj != null && typeof obj !== 'object') {\n    throw new ObjectParameterError(obj, 'obj', 'Document');\n  }\n\n  let defaults = true;\n  if (options.defaults !== undefined) {\n    this.$__.defaults = options.defaults;\n    defaults = options.defaults;\n  }\n\n  const schema = this.$__schema;\n\n  if (typeof fields === 'boolean' || fields === 'throw') {\n    if (fields !== true) {\n      this.$__.strictMode = fields;\n    }\n    fields = undefined;\n  } else if (schema.options.strict !== true) {\n    this.$__.strictMode = schema.options.strict;\n  }\n\n  const requiredPaths = schema.requiredPaths(true);\n  for (const path of requiredPaths) {\n    this.$__.activePaths.require(path);\n  }\n\n  let exclude = null;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n  if (utils.isPOJO(fields) && Object.keys(fields).length > 0) {\n    exclude = isExclusive(fields);\n    this.$__.selected = fields;\n    this.$__.exclude = exclude;\n  }\n\n  const hasIncludedChildren = exclude === false && fields ?\n    $__hasIncludedChildren(fields) :\n    null;\n\n  if (this._doc == null) {\n    this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);\n\n    // By default, defaults get applied **before** setting initial values\n    // Re: gh-6155\n    if (defaults) {\n      applyDefaults(this, fields, exclude, hasIncludedChildren, true, null);\n    }\n  }\n  if (obj) {\n    // Skip set hooks\n    if (this.$__original_set) {\n      this.$__original_set(obj, undefined, true, options);\n    } else {\n      this.$set(obj, undefined, true, options);\n    }\n\n    if (obj instanceof Document) {\n      this.$isNew = obj.$isNew;\n    }\n  }\n\n  // Function defaults get applied **after** setting initial values so they\n  // see the full doc rather than an empty one, unless they opt out.\n  // Re: gh-3781, gh-6155\n  if (options.willInit && defaults) {\n    if (options.skipDefaults) {\n      this.$__.skipDefaults = options.skipDefaults;\n    }\n  } else if (defaults) {\n    applyDefaults(this, fields, exclude, hasIncludedChildren, false, options.skipDefaults);\n  }\n\n  if (!this.$__.strictMode && obj) {\n    const _this = this;\n    const keys = Object.keys(this._doc);\n\n    keys.forEach(function(key) {\n      // Avoid methods, virtuals, existing fields, and `$` keys. The latter is to avoid overwriting\n      // Mongoose internals.\n      if (!(key in schema.tree) && !(key in schema.methods) && !(key in schema.virtuals) && !key.startsWith('$')) {\n        defineKey({ prop: key, subprops: null, prototype: _this });\n      }\n    });\n  }\n\n  applyQueue(this);\n}\n\nDocument.prototype.$isMongooseDocumentPrototype = true;\n\n/**\n * Boolean flag specifying if the document is new. If you create a document\n * using `new`, this document will be considered \"new\". `$isNew` is how\n * Mongoose determines whether `save()` should use `insertOne()` to create\n * a new document or `updateOne()` to update an existing document.\n *\n * #### Example:\n *\n *     const user = new User({ name: 'John Smith' });\n *     user.$isNew; // true\n *\n *     await user.save(); // Sends an `insertOne` to MongoDB\n *\n * On the other hand, if you load an existing document from the database\n * using `findOne()` or another [query operation](/docs/queries.html),\n * `$isNew` will be false.\n *\n * #### Example:\n *\n *     const user = await User.findOne({ name: 'John Smith' });\n *     user.$isNew; // false\n *\n * Mongoose sets `$isNew` to `false` immediately after `save()` succeeds.\n * That means Mongoose sets `$isNew` to false **before** `post('save')` hooks run.\n * In `post('save')` hooks, `$isNew` will be `false` if `save()` succeeded.\n *\n * #### Example:\n *\n *     userSchema.post('save', function() {\n *       this.$isNew; // false\n *     });\n *     await User.create({ name: 'John Smith' });\n *\n * For subdocuments, `$isNew` is true if either the parent has `$isNew` set,\n * or if you create a new subdocument.\n *\n * #### Example:\n *\n *     // Assume `Group` has a document array `users`\n *     const group = await Group.findOne();\n *     group.users[0].$isNew; // false\n *\n *     group.users.push({ name: 'John Smith' });\n *     group.users[1].$isNew; // true\n *\n * @api public\n * @property $isNew\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, 'isNew', {\n  get: function() {\n    return this.$isNew;\n  },\n  set: function(value) {\n    this.$isNew = value;\n  }\n});\n\n/**\n * Hash containing current validation errors.\n *\n * @api public\n * @property errors\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, 'errors', {\n  get: function() {\n    return this.$errors;\n  },\n  set: function(value) {\n    this.$errors = value;\n  }\n});\n\n/*!\n * ignore\n */\n\nDocument.prototype.$isNew = true;\n\n/*!\n * Document exposes the NodeJS event emitter API, so you can use\n * `on`, `once`, etc.\n */\nutils.each(\n  ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',\n    'removeAllListeners', 'addListener'],\n  function(emitterFn) {\n    Document.prototype[emitterFn] = function() {\n      // Delay creating emitter until necessary because emitters take up a lot of memory,\n      // especially for subdocuments.\n      if (!this.$__.emitter) {\n        if (emitterFn === 'emit') {\n          return;\n        }\n        this.$__.emitter = new EventEmitter();\n        this.$__.emitter.setMaxListeners(0);\n      }\n      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n    };\n    Document.prototype[`$${emitterFn}`] = Document.prototype[emitterFn];\n  });\n\nDocument.prototype.constructor = Document;\n\nfor (const i in EventEmitter.prototype) {\n  Document[i] = EventEmitter.prototype[i];\n}\n\n/**\n * The document's internal schema.\n *\n * @api private\n * @property schema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__schema;\n\n/**\n * The document's schema.\n *\n * @api public\n * @property schema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.schema;\n\n/**\n * Empty object that you can use for storing properties on the document. This\n * is handy for passing data to middleware without conflicting with Mongoose\n * internals.\n *\n * #### Example:\n *\n *     schema.pre('save', function() {\n *       // Mongoose will set `isNew` to `false` if `save()` succeeds\n *       this.$locals.wasNew = this.isNew;\n *     });\n *\n *     schema.post('save', function() {\n *       // Prints true if `isNew` was set before `save()`\n *       console.log(this.$locals.wasNew);\n *     });\n *\n * @api public\n * @property $locals\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$locals', {\n  configurable: false,\n  enumerable: false,\n  get: function() {\n    if (this.$__.locals == null) {\n      this.$__.locals = {};\n    }\n    return this.$__.locals;\n  },\n  set: function(v) {\n    this.$__.locals = v;\n  }\n});\n\n/**\n * Legacy alias for `$isNew`.\n *\n * @api public\n * @property isNew\n * @memberOf Document\n * @see $isNew #document_Document-$isNew\n * @instance\n */\n\nDocument.prototype.isNew;\n\n/**\n * Set this property to add additional query filters when Mongoose saves this document and `isNew` is false.\n *\n * #### Example:\n *\n *     // Make sure `save()` never updates a soft deleted document.\n *     schema.pre('save', function() {\n *       this.$where = { isDeleted: false };\n *     });\n *\n * @api public\n * @property $where\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$where', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\n * The string version of this documents _id.\n *\n * #### Note:\n *\n * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.\n *\n *     new Schema({ name: String }, { id: false });\n *\n * @api public\n * @see Schema options /docs/guide.html#options\n * @property id\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.id;\n\n/**\n * Hash containing current validation $errors.\n *\n * @api public\n * @property $errors\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$errors;\n\n/**\n * A string containing the current operation that Mongoose is executing\n * on this document. May be `null`, `'save'`, `'validate'`, or `'remove'`.\n *\n * #### Example:\n *\n *     const doc = new Model({ name: 'test' });\n *     doc.$op; // null\n *\n *     const promise = doc.save();\n *     doc.$op; // 'save'\n *\n *     await promise;\n *     doc.$op; // null\n *\n * @api public\n * @property $op\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$op', {\n  get: function() {\n    return this.$__.op || null;\n  },\n  set: function(value) {\n    this.$__.op = value;\n  }\n});\n\n/*!\n * ignore\n */\n\nfunction $applyDefaultsToNested(val, path, doc) {\n  if (val == null) {\n    return;\n  }\n\n  flattenObjectWithDottedPaths(val);\n\n  const paths = Object.keys(doc.$__schema.paths);\n  const plen = paths.length;\n\n  const pathPieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n\n  for (let i = 0; i < plen; ++i) {\n    let curPath = '';\n    const p = paths[i];\n\n    if (!p.startsWith(path + '.')) {\n      continue;\n    }\n\n    const type = doc.$__schema.paths[p];\n    const pieces = type.splitPath().slice(pathPieces.length);\n    const len = pieces.length;\n\n    if (type.defaultValue === void 0) {\n      continue;\n    }\n\n    let cur = val;\n\n    for (let j = 0; j < len; ++j) {\n      if (cur == null) {\n        break;\n      }\n\n      const piece = pieces[j];\n\n      if (j === len - 1) {\n        if (cur[piece] !== void 0) {\n          break;\n        }\n\n        try {\n          const def = type.getDefault(doc, false);\n          if (def !== void 0) {\n            cur[piece] = def;\n          }\n        } catch (err) {\n          doc.invalidate(path + '.' + curPath, err);\n          break;\n        }\n\n        break;\n      }\n\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      cur[piece] = cur[piece] || {};\n      cur = cur[piece];\n    }\n  }\n}\n\n/**\n * Builds the default doc structure\n *\n * @param {Object} obj\n * @param {Object} [fields]\n * @param {Boolean} [skipId]\n * @param {Boolean} [exclude]\n * @param {Object} [hasIncludedChildren]\n * @api private\n * @method $__buildDoc\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__buildDoc = function(obj, fields, skipId, exclude, hasIncludedChildren) {\n  const doc = {};\n\n  const paths = Object.keys(this.$__schema.paths).\n    // Don't build up any paths that are underneath a map, we don't know\n    // what the keys will be\n    filter(p => !p.includes('$*'));\n  const plen = paths.length;\n  let ii = 0;\n\n  for (; ii < plen; ++ii) {\n    const p = paths[ii];\n\n    if (p === '_id') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && '_id' in obj) {\n        continue;\n      }\n    }\n\n    const path = this.$__schema.paths[p].splitPath();\n    const len = path.length;\n    const last = len - 1;\n    let curPath = '';\n    let doc_ = doc;\n    let included = false;\n\n    for (let i = 0; i < len; ++i) {\n      const piece = path[i];\n\n      if (!curPath.length) {\n        curPath = piece;\n      } else {\n        curPath += '.' + piece;\n      }\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i < last) {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  this._doc = doc;\n};\n\n/*!\n * Converts to POJO when you use the document for querying\n */\n\nDocument.prototype.toBSON = function() {\n  return this.toObject(internalToObjectOptions);\n};\n\n/**\n * Initializes the document without setters or marking anything modified.\n *\n * Called internally after a document is returned from mongodb. Normally,\n * you do **not** need to call this function on your own.\n *\n * This function triggers `init` [middleware](/docs/middleware.html).\n * Note that `init` hooks are [synchronous](/docs/middleware.html#synchronous).\n *\n * @param {Object} doc document returned by mongo\n * @param {Object} [opts]\n * @param {Function} [fn]\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.init = function(doc, opts, fn) {\n  if (typeof opts === 'function') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.$__init(doc, opts);\n\n  if (fn) {\n    fn(null, this);\n  }\n\n  return this;\n};\n\n/**\n * Alias for [`.init`](#document_Document-init)\n *\n * @api public\n */\n\nDocument.prototype.$init = function() {\n  return this.constructor.prototype.init.apply(this, arguments);\n};\n\n/**\n * Internal \"init\" function\n *\n * @param {Document} doc\n * @param {Object} [opts]\n * @returns {Document} this\n * @api private\n */\n\nDocument.prototype.$__init = function(doc, opts) {\n  this.$isNew = false;\n  opts = opts || {};\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id != null && opts.populated && opts.populated.length) {\n    const id = String(doc._id);\n    for (const item of opts.populated) {\n      if (item.isVirtual) {\n        this.$populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.$populated(item.path, item._docs[id], item);\n      }\n\n      if (item._childDocs == null) {\n        continue;\n      }\n      for (const child of item._childDocs) {\n        if (child == null || child.$__ == null) {\n          continue;\n        }\n        child.$__.parent = this;\n      }\n      item._childDocs = [];\n    }\n  }\n\n  init(this, doc, this._doc, opts);\n\n  markArraySubdocsPopulated(this, opts.populated);\n\n  this.$emit('init', this);\n  this.constructor.emit('init', this);\n\n  const hasIncludedChildren = this.$__.exclude === false && this.$__.selected ?\n    $__hasIncludedChildren(this.$__.selected) :\n    null;\n\n  applyDefaults(this, this.$__.selected, this.$__.exclude, hasIncludedChildren, false, this.$__.skipDefaults);\n\n  return this;\n};\n\n/**\n * Init helper.\n *\n * @param {Object} self document instance\n * @param {Object} obj raw mongodb doc\n * @param {Object} doc object we are initializing\n * @param {Object} [opts] Optional Options\n * @param {Boolean} [opts.setters] Call `applySetters` instead of `cast`\n * @param {String} [prefix] Prefix to add to each path\n * @api private\n */\n\nfunction init(self, obj, doc, opts, prefix) {\n  prefix = prefix || '';\n\n  if (obj.$__ != null) {\n    obj = obj._doc;\n  }\n  const keys = Object.keys(obj);\n  const len = keys.length;\n  let schemaType;\n  let path;\n  let i;\n  let index = 0;\n  const strict = self.$__.strictMode;\n  const docSchema = self.$__schema;\n\n  while (index < len) {\n    _init(index++);\n  }\n\n  function _init(index) {\n    i = keys[index];\n    // avoid prototype pollution\n    if (i === '__proto__' || i === 'constructor') {\n      return;\n    }\n    path = prefix + i;\n    schemaType = docSchema.path(path);\n\n    // Should still work if not a model-level discriminator, but should not be\n    // necessary. This is *only* to catch the case where we queried using the\n    // base model and the discriminated model has a projection\n    if (docSchema.$isRootDiscriminator && !self.$__isSelected(path)) {\n      return;\n    }\n\n    if (!schemaType && utils.isPOJO(obj[i])) {\n      // assume nested object\n      if (!doc[i]) {\n        doc[i] = {};\n        if (!strict && !(i in docSchema.tree) && !(i in docSchema.methods) && !(i in docSchema.virtuals)) {\n          self[i] = doc[i];\n        }\n      }\n      init(self, obj[i], doc[i], opts, path + '.');\n    } else if (!schemaType) {\n      doc[i] = obj[i];\n      if (!strict && !prefix) {\n        self[i] = obj[i];\n      }\n    } else {\n      // Retain order when overwriting defaults\n      if (doc.hasOwnProperty(i) && obj[i] !== void 0) {\n        delete doc[i];\n      }\n      if (obj[i] === null) {\n        doc[i] = schemaType._castNullish(null);\n      } else if (obj[i] !== undefined) {\n        const wasPopulated = obj[i].$__ == null ? null : obj[i].$__.wasPopulated;\n\n        if (schemaType && !wasPopulated) {\n          try {\n            if (opts && opts.setters) {\n              // Call applySetters with `init = false` because otherwise setters are a noop\n              const overrideInit = false;\n              doc[i] = schemaType.applySetters(obj[i], self, overrideInit);\n            } else {\n              doc[i] = schemaType.cast(obj[i], self, true);\n            }\n          } catch (e) {\n            self.invalidate(e.path, new ValidatorError({\n              path: e.path,\n              message: e.message,\n              type: 'cast',\n              value: e.value,\n              reason: e\n            }));\n          }\n        } else {\n          doc[i] = obj[i];\n        }\n      }\n      // mark as hydrated\n      if (!self.$isModified(path)) {\n        self.$__.activePaths.init(path);\n      }\n    }\n  }\n}\n\n/**\n * Sends an update command with this document `_id` as the query selector.\n *\n * #### Example:\n *\n *     weirdCar.update({ $inc: { wheels:1 } }, { w: 1 }, callback);\n *\n * #### Valid options:\n *\n *  - same as in [Model.update](#model_Model-update)\n *\n * @see Model.update #model_Model-update\n * @param {...Object} ops\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query} this\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.update = function update() {\n  const args = [...arguments];\n  args.unshift({ _id: this._id });\n  const query = this.constructor.update.apply(this.constructor, args);\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  return query;\n};\n\n/**\n * Sends an updateOne command with this document `_id` as the query selector.\n *\n * #### Example:\n *\n *     weirdCar.updateOne({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * #### Valid options:\n *\n *  - same as in [Model.updateOne](#model_Model-updateOne)\n *\n * @see Model.updateOne #model_Model-updateOne\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#query_Query-setOptions)\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](/docs/api/query.html#query_Query-lean) and the [Mongoose lean tutorial](/docs/tutorials/lean.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.updateOne = function updateOne(doc, options, callback) {\n  const query = this.constructor.updateOne({ _id: this._id }, doc, options);\n  const self = this;\n  query.pre(function queryPreUpdateOne(cb) {\n    self.constructor._middleware.execPre('updateOne', self, [self], cb);\n  });\n  query.post(function queryPostUpdateOne(cb) {\n    self.constructor._middleware.execPost('updateOne', self, [self], {}, cb);\n  });\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  if (callback != null) {\n    return query.exec(callback);\n  }\n\n  return query;\n};\n\n/**\n * Sends a replaceOne command with this document `_id` as the query selector.\n *\n * #### Valid options:\n *\n *  - same as in [Model.replaceOne](https://mongoosejs.com/docs/api/model.html#model_Model-replaceOne)\n *\n * @see Model.replaceOne #model_Model-replaceOne\n * @param {Object} doc\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.replaceOne = function replaceOne() {\n  const args = [...arguments];\n  args.unshift({ _id: this._id });\n  return this.constructor.replaceOne.apply(this.constructor, args);\n};\n\n/**\n * Getter/setter around the session associated with this document. Used to\n * automatically set `session` if you `save()` a doc that you got from a\n * query with an associated session.\n *\n * #### Example:\n *\n *     const session = MyModel.startSession();\n *     const doc = await MyModel.findOne().session(session);\n *     doc.$session() === session; // true\n *     doc.$session(null);\n *     doc.$session() === null; // true\n *\n * If this is a top-level document, setting the session propagates to all child\n * docs.\n *\n * @param {ClientSession} [session] overwrite the current session\n * @return {ClientSession}\n * @method $session\n * @api public\n * @memberOf Document\n */\n\nDocument.prototype.$session = function $session(session) {\n  if (arguments.length === 0) {\n    if (this.$__.session != null && this.$__.session.hasEnded) {\n      this.$__.session = null;\n      return null;\n    }\n    return this.$__.session;\n  }\n\n  if (session != null && session.hasEnded) {\n    throw new MongooseError('Cannot set a document\\'s session to a session that has ended. Make sure you haven\\'t ' +\n      'called `endSession()` on the session you are passing to `$session()`.');\n  }\n\n  if (session == null && this.$__.session == null) {\n    return;\n  }\n\n  this.$__.session = session;\n\n  if (!this.$isSubdocument) {\n    const subdocs = this.$getAllSubdocs();\n    for (const child of subdocs) {\n      child.$session(session);\n    }\n  }\n\n  return session;\n};\n\n/**\n * Getter/setter around whether this document will apply timestamps by\n * default when using `save()` and `bulkSave()`.\n *\n * #### Example:\n *\n *     const TestModel = mongoose.model('Test', new Schema({ name: String }, { timestamps: true }));\n *     const doc = new TestModel({ name: 'John Smith' });\n *\n *     doc.$timestamps(); // true\n *\n *     doc.$timestamps(false);\n *     await doc.save(); // Does **not** apply timestamps\n *\n * @param {Boolean} [value] overwrite the current session\n * @return {Document|boolean|undefined} When used as a getter (no argument), a boolean will be returned indicating the timestamps option state or if unset \"undefined\" will be used, otherwise will return \"this\"\n * @method $timestamps\n * @api public\n * @memberOf Document\n */\n\nDocument.prototype.$timestamps = function $timestamps(value) {\n  if (arguments.length === 0) {\n    if (this.$__.timestamps != null) {\n      return this.$__.timestamps;\n    }\n\n    if (this.$__schema) {\n      return this.$__schema.options.timestamps;\n    }\n\n    return undefined;\n  }\n\n  const currentValue = this.$timestamps();\n  if (value !== currentValue) {\n    this.$__.timestamps = value;\n  }\n\n  return this;\n};\n\n/**\n * Overwrite all values in this document with the values of `obj`, except\n * for immutable properties. Behaves similarly to `set()`, except for it\n * unsets all properties that aren't in `obj`.\n *\n * @param {Object} obj the object to overwrite this document with\n * @method overwrite\n * @memberOf Document\n * @instance\n * @api public\n * @return {Document} this\n */\n\nDocument.prototype.overwrite = function overwrite(obj) {\n  const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));\n\n  for (const key of keys) {\n    if (key === '_id') {\n      continue;\n    }\n    // Explicitly skip version key\n    if (this.$__schema.options.versionKey && key === this.$__schema.options.versionKey) {\n      continue;\n    }\n    if (this.$__schema.options.discriminatorKey && key === this.$__schema.options.discriminatorKey) {\n      continue;\n    }\n    this.$set(key, obj[key]);\n  }\n\n  return this;\n};\n\n/**\n * Alias for `set()`, used internally to avoid conflicts\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @param {Boolean} [options.merge=false] if true, setting a [nested path](/docs/subdocs.html#subdocuments-versus-nested-paths) will merge existing values rather than overwrite the whole object. So `doc.set('nested', { a: 1, b: 2 })` becomes `doc.set('nested.a', 1); doc.set('nested.b', 2);`\n * @return {Document} this\n * @method $set\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$set = function $set(path, val, type, options) {\n  if (utils.isPOJO(type)) {\n    options = type;\n    type = undefined;\n  }\n\n  const merge = options && options.merge;\n  const adhoc = type && type !== true;\n  const constructing = type === true;\n  let adhocs;\n  let keys;\n  let i = 0;\n  let pathtype;\n  let key;\n  let prefix;\n\n  const strict = options && 'strict' in options\n    ? options.strict\n    : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n\n  if (path == null) {\n    [path, val] = [val, path];\n  } else if (typeof path !== 'string') {\n    // new Document({ key: val })\n    if (path instanceof Document) {\n      if (path.$__isNested) {\n        path = path.toObject();\n      } else {\n        path = path._doc;\n      }\n    }\n    if (path == null) {\n      [path, val] = [val, path];\n    }\n\n    prefix = val ? val + '.' : '';\n    keys = getKeysInSchemaOrder(this.$__schema, path);\n\n    const len = keys.length;\n\n    // `_skipMinimizeTopLevel` is because we may have deleted the top-level\n    // nested key to ensure key order.\n    const _skipMinimizeTopLevel = options && options._skipMinimizeTopLevel || false;\n    if (len === 0 && _skipMinimizeTopLevel) {\n      delete options._skipMinimizeTopLevel;\n      if (val) {\n        this.$set(val, {});\n      }\n      return this;\n    }\n\n    for (let i = 0; i < len; ++i) {\n      key = keys[i];\n      const pathName = prefix + key;\n      pathtype = this.$__schema.pathType(pathName);\n      const valForKey = path[key];\n\n      // On initial set, delete any nested keys if we're going to overwrite\n      // them to ensure we keep the user's key order.\n      if (type === true &&\n          !prefix &&\n          valForKey != null &&\n          pathtype === 'nested' &&\n          this._doc[key] != null) {\n        delete this._doc[key];\n        // Make sure we set `{}` back even if we minimize re: gh-8565\n        options = Object.assign({}, options, { _skipMinimizeTopLevel: true });\n      } else {\n        // Make sure we set `{_skipMinimizeTopLevel: false}` if don't have overwrite: gh-10441\n        options = Object.assign({}, options, { _skipMinimizeTopLevel: false });\n      }\n\n      if (utils.isNonBuiltinObject(valForKey) && pathtype === 'nested') {\n        this.$set(prefix + key, path[key], constructing, Object.assign({}, options, { _skipMarkModified: true }));\n        $applyDefaultsToNested(this.$get(prefix + key), prefix + key, this);\n        continue;\n      } else if (strict) {\n        // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)\n        if (constructing && path[key] === void 0 &&\n            this.$get(pathName) !== void 0) {\n          continue;\n        }\n\n        if (pathtype === 'adhocOrUndefined') {\n          pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });\n        }\n\n        if (pathtype === 'real' || pathtype === 'virtual') {\n          const p = path[key];\n          this.$set(prefix + key, p, constructing, options);\n        } else if (pathtype === 'nested' && path[key] instanceof Document) {\n          this.$set(prefix + key,\n            path[key].toObject({ transform: false }), constructing, options);\n        } else if (strict === 'throw') {\n          if (pathtype === 'nested') {\n            throw new ObjectExpectedError(key, path[key]);\n          } else {\n            throw new StrictModeError(key);\n          }\n        }\n      } else if (path[key] !== void 0) {\n        this.$set(prefix + key, path[key], constructing, options);\n      }\n    }\n\n    // Ensure all properties are in correct order\n    const orderedDoc = {};\n    const orderedKeys = Object.keys(this.$__schema.tree);\n    for (let i = 0, len = orderedKeys.length; i < len; ++i) {\n      (key = orderedKeys[i]) &&\n      (this._doc.hasOwnProperty(key)) &&\n      (orderedDoc[key] = undefined);\n    }\n    this._doc = Object.assign(orderedDoc, this._doc);\n\n    return this;\n  }\n\n  let pathType = this.$__schema.pathType(path);\n  if (pathType === 'adhocOrUndefined') {\n    pathType = getEmbeddedDiscriminatorPath(this, path, { typeOnly: true });\n  }\n\n  // Assume this is a Mongoose document that was copied into a POJO using\n  // `Object.assign()` or `{...doc}`\n  val = handleSpreadDoc(val);\n\n  // if this doc is being constructed we should not trigger getters\n  const priorVal = (() => {\n    if (this.$__.priorDoc != null) {\n      return this.$__.priorDoc.$__getValue(path);\n    }\n    if (constructing) {\n      return void 0;\n    }\n    return this.$__getValue(path);\n  })();\n\n  if (pathType === 'nested' && val) {\n    if (typeof val === 'object' && val != null) {\n      if (val.$__ != null) {\n        val = val.toObject(internalToObjectOptions);\n      }\n      if (val == null) {\n        this.invalidate(path, new MongooseError.CastError('Object', val, path));\n        return this;\n      }\n      const hasInitialVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);\n      if (this.$__.savedState != null && !this.$isNew && !this.$__.savedState.hasOwnProperty(path)) {\n        const initialVal = this.$__getValue(path);\n        this.$__.savedState[path] = initialVal;\n\n        const keys = Object.keys(initialVal || {});\n        for (const key of keys) {\n          this.$__.savedState[path + '.' + key] = initialVal[key];\n        }\n      }\n\n      if (!merge) {\n        this.$__setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        return this.$set(val, path, constructing);\n      }\n\n      const keys = getKeysInSchemaOrder(this.$__schema, val, path);\n\n      this.$__setValue(path, {});\n      for (const key of keys) {\n        this.$set(path + '.' + key, val[key], constructing, options);\n      }\n      if (priorVal != null && utils.deepEqual(hasInitialVal ? this.$__.savedState[path] : priorVal, val)) {\n        this.unmarkModified(path);\n      } else {\n        this.markModified(path);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError('Object', val, path));\n    return this;\n  }\n\n  let schema;\n  const parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n\n  // Might need to change path for top-level alias\n  if (typeof this.$__schema.aliases[parts[0]] === 'string') {\n    parts[0] = this.$__schema.aliases[parts[0]];\n  }\n\n  if (pathType === 'adhocOrUndefined' && strict) {\n    // check for roots that are Mixed types\n    let mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.$__schema.pathType(subpath) === 'virtual') {\n        mpath.set(path, val, this);\n        return this;\n      }\n\n      schema = this.$__schema.path(subpath);\n      if (schema == null) {\n        continue;\n      }\n\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n    }\n\n    if (schema == null) {\n      // Check for embedded discriminators\n      schema = getEmbeddedDiscriminatorPath(this, path);\n    }\n\n    if (!mixed && !schema) {\n      if (strict === 'throw') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === 'virtual') {\n    schema = this.$__schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it\n  let cur = this._doc;\n  let curPath = '';\n  for (i = 0; i < parts.length - 1; ++i) {\n    cur = cur[parts[i]];\n    curPath += (curPath.length !== 0 ? '.' : '') + parts[i];\n    if (!cur) {\n      this.$set(curPath, {});\n      // Hack re: gh-5800. If nested field is not selected, it probably exists\n      // so `MongoServerError: cannot use the part (nested of nested.num) to\n      // traverse the element ({nested: null})` is not likely. If user gets\n      // that error, its their fault for now. We should reconsider disallowing\n      // modifying not selected paths for 6.x\n      if (!this.$__isSelected(curPath)) {\n        this.unmarkModified(curPath);\n      }\n      cur = this.$__getValue(curPath);\n    }\n  }\n\n  let pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: \"LEFT_SUBFIELD only supports Object\"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    const len = parts.length;\n    for (i = 0; i < len; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n      if (this.$get(subpath, null, { getters: false }) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  if (!schema) {\n    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);\n\n    if (pathType === 'nested' && val == null) {\n      cleanModifiedSubpaths(this, path);\n    }\n    return this;\n  }\n\n  // If overwriting a subdocument path, make sure to clear out\n  // any errors _before_ setting, so new errors that happen\n  // get persisted. Re: #9080\n  if (schema.$isSingleNested || schema.$isMongooseArray) {\n    _markValidSubpaths(this, path);\n  }\n\n  if (val != null && merge && schema.$isSingleNested) {\n    if (val instanceof Document) {\n      val = val.toObject({ virtuals: false, transform: false });\n    }\n    const keys = Object.keys(val);\n    for (const key of keys) {\n      this.$set(path + '.' + key, val[key], constructing, options);\n    }\n\n    return this;\n  }\n\n  let shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    const refMatches = (() => {\n      if (schema.options == null) {\n        return false;\n      }\n      if (!(val instanceof Document)) {\n        return false;\n      }\n      const model = val.constructor;\n\n      // Check ref\n      const ref = schema.options.ref;\n      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {\n        return true;\n      }\n\n      // Check refPath\n      const refPath = schema.options.refPath;\n      if (refPath == null) {\n        return false;\n      }\n      const modelName = val.get(refPath);\n      return modelName === model.modelName || modelName === model.baseModelName;\n    })();\n\n    let didPopulate = false;\n    if (refMatches && val instanceof Document && (!val.$__.wasPopulated || utils.deepEqual(val.$__.wasPopulated.value, val._id))) {\n      const unpopulatedValue = (schema && schema.$isSingleNested) ? schema.cast(val, this) : val._id;\n      this.$populated(path, unpopulatedValue, { [populateModelSymbol]: val.constructor });\n      val.$__.wasPopulated = { value: unpopulatedValue };\n      didPopulate = true;\n    }\n\n    let popOpts;\n    const typeKey = this.$__schema.options.typeKey;\n    if (schema.options &&\n        Array.isArray(schema.options[typeKey]) &&\n        schema.options[typeKey].length &&\n        schema.options[typeKey][0].ref &&\n        _isManuallyPopulatedArray(val, schema.options[typeKey][0].ref)) {\n      popOpts = { [populateModelSymbol]: val[0].constructor };\n      this.$populated(path, val.map(function(v) { return v._id; }), popOpts);\n\n      for (const doc of val) {\n        doc.$__.wasPopulated = { value: doc._id };\n      }\n      didPopulate = true;\n    }\n\n    if (this.$__schema.singleNestedPaths[path] == null && (!refMatches || !schema.$isSingleNested || !val.$__)) {\n      // If this path is underneath a single nested schema, we'll call the setter\n      // later in `$__set()` because we don't take `_doc` when we iterate through\n      // a single nested doc. That's to make sure we get the correct context.\n      // Otherwise we would double-call the setter, see gh-7196.\n      if (options != null && options.overwriteImmutable) {\n        val = schema.applySetters(val, this, false, priorVal, { overwriteImmutable: true });\n      } else {\n        val = schema.applySetters(val, this, false, priorVal);\n      }\n    }\n\n    if (Array.isArray(val) &&\n        !Array.isArray(schema) &&\n        schema.$isMongooseDocumentArray &&\n        val.length !== 0 &&\n        val[0] != null &&\n        val[0].$__ != null &&\n        val[0].$__.populated != null) {\n      const populatedPaths = Object.keys(val[0].$__.populated);\n      for (const populatedPath of populatedPaths) {\n        this.$populated(path + '.' + populatedPath,\n          val.map(v => v.$populated(populatedPath)),\n          val[0].$__.populated[populatedPath].options);\n      }\n      didPopulate = true;\n    }\n\n    if (!didPopulate && this.$__.populated) {\n      // If this array partially contains populated documents, convert them\n      // all to ObjectIds re: #8443\n      if (Array.isArray(val) && this.$__.populated[path]) {\n        for (let i = 0; i < val.length; ++i) {\n          if (val[i] instanceof Document) {\n            val.set(i, val[i]._id, true);\n          }\n        }\n      }\n      delete this.$__.populated[path];\n    }\n\n    if (val != null && schema.$isSingleNested) {\n      _checkImmutableSubpaths(val, schema, priorVal);\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {\n      this.invalidate(path, e);\n    } else if (e instanceof MongooseError.CastError) {\n      this.invalidate(e.path, e);\n      if (e.$originalErrorPath) {\n        this.invalidate(path,\n          new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));\n      }\n    } else {\n      this.invalidate(path,\n        new MongooseError.CastError(schema.instance, val, path, e));\n    }\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    let savedState = null;\n    let savedStatePath = null;\n    if (!constructing) {\n      const doc = this.$isSubdocument ? this.ownerDocument() : this;\n      savedState = doc.$__.savedState;\n      savedStatePath = this.$isSubdocument ? this.$__.fullPath + '.' + path : path;\n      doc.$__saveInitialState(savedStatePath);\n    }\n\n    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);\n\n    if (savedState != null && savedState.hasOwnProperty(savedStatePath) && utils.deepEqual(val, savedState[savedStatePath])) {\n      this.unmarkModified(path);\n    }\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _isManuallyPopulatedArray(val, ref) {\n  if (!Array.isArray(val)) {\n    return false;\n  }\n  if (val.length === 0) {\n    return false;\n  }\n\n  for (const el of val) {\n    if (!(el instanceof Document)) {\n      return false;\n    }\n    const modelName = el.constructor.modelName;\n    if (modelName == null) {\n      return false;\n    }\n    if (el.constructor.modelName != ref && el.constructor.baseModelName != ref) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Sets the value of a path, or many paths.\n * Alias for [`.$set`](#document_Document-$set).\n *\n * #### Example:\n *\n *     // path, value\n *     doc.set(path, value)\n *\n *     // object\n *     doc.set({\n *         path  : value\n *       , path2 : {\n *            path  : value\n *         }\n *     })\n *\n *     // on-the-fly cast to number\n *     doc.set(path, value, Number)\n *\n *     // on-the-fly cast to string\n *     doc.set(path, value, String)\n *\n *     // changing strict mode behavior\n *     doc.set(path, value, { strict: false });\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @return {Document} this\n * @api public\n * @method set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.set = Document.prototype.$set;\n\n/**\n * Determine if we should mark this change as modified.\n *\n * @param {never} pathToMark UNUSED\n * @param {String|Symbol} path\n * @param {Object} options\n * @param {Any} constructing\n * @param {never} parts UNUSED\n * @param {Schema} schema\n * @param {Any} val\n * @param {Any} priorVal\n * @return {Boolean}\n * @api private\n * @method $__shouldModify\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__shouldModify = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {\n  if (options && options._skipMarkModified) {\n    return false;\n  }\n  if (this.$isNew) {\n    return true;\n  }\n  // Is path already modified? If so, always modify. We may unmark modified later.\n  if (path in this.$__.activePaths.getStatePaths('modify')) {\n    return true;\n  }\n\n  // Re: the note about gh-7196, `val` is the raw value without casting or\n  // setters if the full path is under a single nested subdoc because we don't\n  // want to double run setters. So don't set it as modified. See gh-7264.\n  if (this.$__schema.singleNestedPaths[path] != null) {\n    return false;\n  }\n\n  if (val === void 0 && !this.$__isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (val === void 0 && path in this.$__.activePaths.getStatePaths('default')) {\n    // we're just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don't mark modified\n  // if they have the same _id\n  if (this.$populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal !== undefined ? priorVal : utils.getValue(path, this))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.getStatePaths('default') &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n};\n\n/**\n * Handles the actual setting of the value and marking the path modified if appropriate.\n *\n * @param {String} pathToMark\n * @param {String|Symbol} path\n * @param {Object} options\n * @param {Any} constructing\n * @param {Array} parts\n * @param {Schema} schema\n * @param {Any} val\n * @param {Any} priorVal\n * @api private\n * @method $__set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__set = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require('./types/ArraySubdocument');\n\n  const shouldModify = this.$__shouldModify(pathToMark, path, options, constructing, parts,\n    schema, val, priorVal);\n\n  if (shouldModify) {\n    if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[path]) {\n      delete this.$__.primitiveAtomics[path];\n      if (Object.keys(this.$__.primitiveAtomics).length === 0) {\n        delete this.$__.primitiveAtomics;\n      }\n    }\n    this.markModified(pathToMark);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require('./types/array'));\n    if (val && utils.isMongooseArray(val)) {\n      val._registerAtomic('$set', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (utils.isMongooseDocumentArray(val)) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n    }\n  } else if (Array.isArray(val) && Array.isArray(priorVal) && utils.isMongooseArray(val) && utils.isMongooseArray(priorVal)) {\n    val[arrayAtomicsSymbol] = priorVal[arrayAtomicsSymbol];\n    val[arrayAtomicsBackupSymbol] = priorVal[arrayAtomicsBackupSymbol];\n    if (utils.isMongooseDocumentArray(val)) {\n      val.forEach(doc => { doc.isNew = false; });\n    }\n  }\n\n  let obj = this._doc;\n  let i = 0;\n  const l = parts.length;\n  let cur = '';\n\n  for (; i < l; i++) {\n    const next = i + 1;\n    const last = next === l;\n    cur += (cur ? '.' + parts[i] : parts[i]);\n    if (specialProperties.has(parts[i])) {\n      return;\n    }\n\n    if (last) {\n      if (obj instanceof Map) {\n        obj.set(parts[i], val);\n      } else {\n        obj[parts[i]] = val;\n      }\n    } else {\n      if (utils.isPOJO(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && !Array.isArray(obj[parts[i]]) && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        obj[parts[i]] = obj[parts[i]] || {};\n        obj = obj[parts[i]];\n      }\n    }\n  }\n};\n\n/**\n * Gets a raw value from a path (no getters)\n *\n * @param {String} path\n * @return {Any} Returns the value from the given `path`.\n * @api private\n */\n\nDocument.prototype.$__getValue = function(path) {\n  return utils.getValue(path, this._doc);\n};\n\n/**\n * Increments the numeric value at `path` by the given `val`.\n * When you call `save()` on this document, Mongoose will send a\n * [`$inc`](https://www.mongodb.com/docs/manual/reference/operator/update/inc/)\n * as opposed to a `$set`.\n *\n * #### Example:\n *\n *     const schema = new Schema({ counter: Number });\n *     const Test = db.model('Test', schema);\n *\n *     const doc = await Test.create({ counter: 0 });\n *     doc.$inc('counter', 2);\n *     await doc.save(); // Sends a `{ $inc: { counter: 2 } }` to MongoDB\n *     doc.counter; // 2\n *\n *     doc.counter += 2;\n *     await doc.save(); // Sends a `{ $set: { counter: 2 } }` to MongoDB\n *\n * @param {String|Array} path path or paths to update\n * @param {Number} val increment `path` by this value\n * @return {Document} this\n */\n\nDocument.prototype.$inc = function $inc(path, val) {\n  if (val == null) {\n    val = 1;\n  }\n\n  if (Array.isArray(path)) {\n    path.forEach((p) => this.$inc(p, val));\n    return this;\n  }\n\n  const schemaType = this.$__path(path);\n  if (schemaType == null) {\n    if (this.$__.strictMode === 'throw') {\n      throw new StrictModeError(path);\n    } else if (this.$__.strictMode === true) {\n      return this;\n    }\n  } else if (schemaType.instance !== 'Number') {\n    this.invalidate(path, new MongooseError.CastError(schemaType.instance, val, path));\n    return this;\n  }\n\n  const currentValue = this.$__getValue(path) || 0;\n  let shouldSet = false;\n  let valToSet = null;\n  let valToInc = val;\n\n  try {\n    val = schemaType.cast(val);\n    valToSet = schemaType.applySetters(currentValue + val, this);\n    valToInc = valToSet - currentValue;\n    shouldSet = true;\n  } catch (err) {\n    this.invalidate(path, new MongooseError.CastError('number', val, path, err));\n  }\n\n  if (shouldSet) {\n    this.$__.primitiveAtomics = this.$__.primitiveAtomics || {};\n    if (this.$__.primitiveAtomics[path] == null) {\n      this.$__.primitiveAtomics[path] = { $inc: valToInc };\n    } else {\n      this.$__.primitiveAtomics[path].$inc += valToInc;\n    }\n    this.markModified(path);\n    this.$__setValue(path, valToSet);\n  }\n\n  return this;\n};\n\n/**\n * Sets a raw value for a path (no casting, setters, transformations)\n *\n * @param {String} path\n * @param {Object} value\n * @return {Document} this\n * @api private\n */\n\nDocument.prototype.$__setValue = function(path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n};\n\n/**\n * Returns the value of a path.\n *\n * #### Example:\n *\n *     // path\n *     doc.get('age') // 47\n *\n *     // dynamic casting to a string\n *     doc.get('age', String) // \"47\"\n *\n * @param {String} path\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes\n * @param {Object} [options]\n * @param {Boolean} [options.virtuals=false] Apply virtuals before getting this path\n * @param {Boolean} [options.getters=true] If false, skip applying getters and just get the raw value\n * @return {Any}\n * @api public\n */\n\nDocument.prototype.get = function(path, type, options) {\n  let adhoc;\n  if (options == null) {\n    options = {};\n  }\n  if (type) {\n    adhoc = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n  const noDottedPath = options.noDottedPath;\n\n  // Fast path if we know we're just accessing top-level path on the document:\n  // just get the schema path, avoid `$__path()` because that does string manipulation\n  let schema = noDottedPath ? this.$__schema.paths[path] : this.$__path(path);\n  if (schema == null) {\n    schema = this.$__schema.virtualpath(path);\n\n    if (schema != null) {\n      return schema.applyGetters(void 0, this);\n    }\n  }\n\n  if (noDottedPath) {\n    let obj = this._doc[path];\n    if (adhoc) {\n      obj = adhoc.cast(obj);\n    }\n    if (schema != null && options.getters !== false) {\n      return schema.applyGetters(obj, this);\n    }\n    return obj;\n  }\n\n  if (schema != null && schema.instance === 'Mixed') {\n    const virtual = this.$__schema.virtualpath(path);\n    if (virtual != null) {\n      schema = virtual;\n    }\n  }\n\n  const hasDot = path.indexOf('.') !== -1;\n  let obj = this._doc;\n\n  const pieces = hasDot ? path.split('.') : [path];\n  // Might need to change path for top-level alias\n  if (typeof this.$__schema.aliases[pieces[0]] === 'string') {\n    pieces[0] = this.$__schema.aliases[pieces[0]];\n  }\n\n  for (let i = 0, l = pieces.length; i < l; i++) {\n    if (obj && obj._doc) {\n      obj = obj._doc;\n    }\n\n    if (obj == null) {\n      obj = void 0;\n    } else if (obj instanceof Map) {\n      obj = obj.get(pieces[i], { getters: false });\n    } else if (i === l - 1) {\n      obj = utils.getValue(pieces[i], obj);\n    } else {\n      obj = obj[pieces[i]];\n    }\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  if (schema != null && options.getters !== false) {\n    obj = schema.applyGetters(obj, this);\n  } else if (this.$__schema.nested[path] && options.virtuals) {\n    // Might need to apply virtuals if this is a nested path\n    return applyVirtuals(this, utils.clone(obj) || {}, { path: path });\n  }\n\n  return obj;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype[getSymbol] = Document.prototype.get;\nDocument.prototype.$get = Document.prototype.get;\n\n/**\n * Returns the schematype for the given `path`.\n *\n * @param {String} path\n * @return {SchemaPath}\n * @api private\n * @method $__path\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__path = function(path) {\n  const adhocs = this.$__.adhocPaths;\n  const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.$__schema.path(path);\n};\n\n/**\n * Marks the path as having pending changes to write to the db.\n *\n * _Very helpful when using [Mixed](https://mongoosejs.com/docs/schematypes.html#mixed) types._\n *\n * #### Example:\n *\n *     doc.mixed.type = 'changed';\n *     doc.markModified('mixed.type');\n *     doc.save() // changes to mixed.type are now persisted\n *\n * @param {String} path the path to mark modified\n * @param {Document} [scope] the scope to run validators with\n * @api public\n */\n\nDocument.prototype.markModified = function(path, scope) {\n  this.$__saveInitialState(path);\n\n  this.$__.activePaths.modify(path);\n  if (scope != null && !this.$isSubdocument) {\n    this.$__.pathsToScopes = this.$__pathsToScopes || {};\n    this.$__.pathsToScopes[path] = scope;\n  }\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__saveInitialState = function $__saveInitialState(path) {\n  const savedState = this.$__.savedState;\n  const savedStatePath = path;\n  if (savedState != null) {\n    const firstDot = savedStatePath.indexOf('.');\n    const topLevelPath = firstDot === -1 ? savedStatePath : savedStatePath.slice(0, firstDot);\n    if (!savedState.hasOwnProperty(topLevelPath)) {\n      savedState[topLevelPath] = utils.clone(this.$__getValue(topLevelPath));\n    }\n  }\n};\n\n/**\n * Clears the modified state on the specified path.\n *\n * #### Example:\n *\n *     doc.foo = 'bar';\n *     doc.unmarkModified('foo');\n *     doc.save(); // changes to foo will not be persisted\n *\n * @param {String} path the path to unmark modified\n * @api public\n */\n\nDocument.prototype.unmarkModified = function(path) {\n  this.$__.activePaths.init(path);\n  if (this.$__.pathsToScopes != null) {\n    delete this.$__.pathsToScopes[path];\n  }\n};\n\n/**\n * Don't run validation on this path or persist changes to this path.\n *\n * #### Example:\n *\n *     doc.foo = null;\n *     doc.$ignore('foo');\n *     doc.save(); // changes to foo will not be persisted and validators won't be run\n *\n * @memberOf Document\n * @instance\n * @method $ignore\n * @param {String} path the path to ignore\n * @api public\n */\n\nDocument.prototype.$ignore = function(path) {\n  this.$__.activePaths.ignore(path);\n};\n\n/**\n * Returns the list of paths that have been directly modified. A direct\n * modified path is a path that you explicitly set, whether via `doc.foo = 'bar'`,\n * `Object.assign(doc, { foo: 'bar' })`, or `doc.set('foo', 'bar')`.\n *\n * A path `a` may be in `modifiedPaths()` but not in `directModifiedPaths()`\n * because a child of `a` was directly modified.\n *\n * #### Example:\n *\n *     const schema = new Schema({ foo: String, nested: { bar: String } });\n *     const Model = mongoose.model('Test', schema);\n *     await Model.create({ foo: 'original', nested: { bar: 'original' } });\n *\n *     const doc = await Model.findOne();\n *     doc.nested.bar = 'modified';\n *     doc.directModifiedPaths(); // ['nested.bar']\n *     doc.modifiedPaths(); // ['nested', 'nested.bar']\n *\n * @return {String[]}\n * @api public\n */\n\nDocument.prototype.directModifiedPaths = function() {\n  return Object.keys(this.$__.activePaths.getStatePaths('modify'));\n};\n\n/**\n * Returns true if the given path is nullish or only contains empty objects.\n * Useful for determining whether this subdoc will get stripped out by the\n * [minimize option](/docs/guide.html#minimize).\n *\n * #### Example:\n *\n *     const schema = new Schema({ nested: { foo: String } });\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model({});\n *     doc.$isEmpty('nested'); // true\n *     doc.nested.$isEmpty(); // true\n *\n *     doc.nested.foo = 'bar';\n *     doc.$isEmpty('nested'); // false\n *     doc.nested.$isEmpty(); // false\n *\n * @param {String} [path]\n * @memberOf Document\n * @instance\n * @api public\n * @method $isEmpty\n * @return {Boolean}\n */\n\nDocument.prototype.$isEmpty = function(path) {\n  const isEmptyOptions = {\n    minimize: true,\n    virtuals: false,\n    getters: false,\n    transform: false\n  };\n\n  if (arguments.length !== 0) {\n    const v = this.$get(path);\n    if (v == null) {\n      return true;\n    }\n    if (typeof v !== 'object') {\n      return false;\n    }\n    if (utils.isPOJO(v)) {\n      return _isEmpty(v);\n    }\n    return Object.keys(v.toObject(isEmptyOptions)).length === 0;\n  }\n\n  return Object.keys(this.toObject(isEmptyOptions)).length === 0;\n};\n\n/*!\n * ignore\n */\n\nfunction _isEmpty(v) {\n  if (v == null) {\n    return true;\n  }\n  if (typeof v !== 'object' || Array.isArray(v)) {\n    return false;\n  }\n  for (const key of Object.keys(v)) {\n    if (!_isEmpty(v[key])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns the list of paths that have been modified.\n *\n * @param {Object} [options]\n * @param {Boolean} [options.includeChildren=false] if true, returns children of modified paths as well. For example, if false, the list of modified paths for `doc.colors = { primary: 'blue' };` will **not** contain `colors.primary`. If true, `modifiedPaths()` will return an array that contains `colors.primary`.\n * @return {String[]}\n * @api public\n */\n\nDocument.prototype.modifiedPaths = function(options) {\n  options = options || {};\n\n  const directModifiedPaths = Object.keys(this.$__.activePaths.getStatePaths('modify'));\n  const result = new Set();\n\n  let i = 0;\n  let j = 0;\n  const len = directModifiedPaths.length;\n\n  for (i = 0; i < len; ++i) {\n    const path = directModifiedPaths[i];\n    const parts = parentPaths(path);\n    const pLen = parts.length;\n\n    for (j = 0; j < pLen; ++j) {\n      result.add(parts[j]);\n    }\n\n    if (!options.includeChildren) {\n      continue;\n    }\n\n    let ii = 0;\n    let cur = this.$get(path);\n    if (typeof cur === 'object' && cur !== null) {\n      if (cur._doc) {\n        cur = cur._doc;\n      }\n      const len = cur.length;\n      if (Array.isArray(cur)) {\n        for (ii = 0; ii < len; ++ii) {\n          const subPath = path + '.' + ii;\n          if (!result.has(subPath)) {\n            result.add(subPath);\n            if (cur[ii] != null && cur[ii].$__) {\n              const modified = cur[ii].modifiedPaths();\n              let iii = 0;\n              const iiiLen = modified.length;\n              for (iii = 0; iii < iiiLen; ++iii) {\n                result.add(subPath + '.' + modified[iii]);\n              }\n            }\n          }\n        }\n      } else {\n        const keys = Object.keys(cur);\n        let ii = 0;\n        const len = keys.length;\n        for (ii = 0; ii < len; ++ii) {\n          result.add(path + '.' + keys[ii]);\n        }\n      }\n    }\n  }\n  return Array.from(result);\n};\n\nDocument.prototype[documentModifiedPaths] = Document.prototype.modifiedPaths;\n\n/**\n * Returns true if any of the given paths is modified, else false. If no arguments, returns `true` if any path\n * in this document is modified.\n *\n * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\n *\n * #### Example:\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isModified()                      // true\n *     doc.isModified('documents')           // true\n *     doc.isModified('documents.0.title')   // true\n *     doc.isModified('documents otherProp') // true\n *     doc.isDirectModified('documents')     // false\n *\n * @param {String} [path] optional\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isModified = function(paths, modifiedPaths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.indexOf(' ') === -1 ? [paths] : paths.split(' ');\n    }\n\n    const directModifiedPathsObj = this.$__.activePaths.states.modify;\n    if (directModifiedPathsObj == null) {\n      return false;\n    }\n    for (const path of paths) {\n      if (Object.prototype.hasOwnProperty.call(directModifiedPathsObj, path)) {\n        return true;\n      }\n    }\n\n    const modified = modifiedPaths || this[documentModifiedPaths]();\n    const isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n\n    const directModifiedPaths = Object.keys(directModifiedPathsObj);\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.startsWith(mod + '.');\n      });\n    });\n  }\n\n  return this.$__.activePaths.some('modify');\n};\n\n/**\n * Alias of [`.isModified`](#document_Document-isModified)\n *\n * @method $isModified\n * @memberOf Document\n * @api public\n */\n\nDocument.prototype.$isModified = Document.prototype.isModified;\n\nDocument.prototype[documentIsModified] = Document.prototype.isModified;\n\n/**\n * Checks if a path is set to its default.\n *\n * #### Example:\n *\n *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });\n *     const m = new MyModel();\n *     m.$isDefault('name'); // true\n *\n * @memberOf Document\n * @instance\n * @method $isDefault\n * @param {String} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.$isDefault = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('default');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.getStatePaths('default').hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.getStatePaths('default').hasOwnProperty(path));\n};\n\n/**\n * Getter/setter, determines whether the document was removed or not.\n *\n * #### Example:\n *\n *     const product = await product.remove();\n *     product.$isDeleted(); // true\n *     product.remove(); // no-op, doesn't send anything to the db\n *\n *     product.$isDeleted(false);\n *     product.$isDeleted(); // false\n *     product.remove(); // will execute a remove against the db\n *\n *\n * @param {Boolean} [val] optional, overrides whether mongoose thinks the doc is deleted\n * @return {Boolean|Document} whether mongoose thinks this doc is deleted.\n * @method $isDeleted\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$isDeleted = function(val) {\n  if (arguments.length === 0) {\n    return !!this.$__.isDeleted;\n  }\n\n  this.$__.isDeleted = !!val;\n  return this;\n};\n\n/**\n * Returns true if `path` was directly set and modified, else false.\n *\n * #### Example:\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isDirectModified('documents.0.title') // true\n *     doc.isDirectModified('documents') // false\n *\n * @param {String|String[]} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectModified = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('modify');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.getStatePaths('modify').hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.getStatePaths('modify').hasOwnProperty(path));\n};\n\n/**\n * Checks if `path` is in the `init` state, that is, it was set by `Document#init()` and not modified since.\n *\n * @param {String} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isInit = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('init');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.getStatePaths('init').hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.getStatePaths('init').hasOwnProperty(path));\n};\n\n/**\n * Checks if `path` was selected in the source query which initialized this document.\n *\n * #### Example:\n *\n *     const doc = await Thing.findOne().select('name');\n *     doc.isSelected('name') // true\n *     doc.isSelected('age')  // false\n *\n * @param {String|String[]} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isSelected = function isSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n  if (!path) {\n    return false;\n  }\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__isSelected(p));\n  }\n\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n\n  if (inclusive === null) {\n    return true;\n  }\n\n  if (path in this.$__.selected) {\n    return inclusive;\n  }\n\n  const pathDot = path + '.';\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n\n    if (cur.startsWith(pathDot)) {\n      return inclusive || cur !== pathDot;\n    }\n\n    if (pathDot.startsWith(cur + '.')) {\n      return inclusive;\n    }\n  }\n\n  return !inclusive;\n};\n\nDocument.prototype.$__isSelected = Document.prototype.isSelected;\n\n/**\n * Checks if `path` was explicitly selected. If no projection, always returns\n * true.\n *\n * #### Example:\n *\n *     Thing.findOne().select('nested.name').exec(function (err, doc) {\n *        doc.isDirectSelected('nested.name') // true\n *        doc.isDirectSelected('nested.otherName') // false\n *        doc.isDirectSelected('nested')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectSelected = function isDirectSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.isDirectSelected(p));\n  }\n\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n\n  if (inclusive === null) {\n    return true;\n  }\n\n  if (this.$__.selected.hasOwnProperty(path)) {\n    return inclusive;\n  }\n\n  return !inclusive;\n};\n\n/**\n * Executes registered validation rules for this document.\n *\n * #### Note:\n *\n * This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned to your `callback`.\n *\n * #### Example:\n *\n *     doc.validate(function (err) {\n *       if (err) handleError(err);\n *       else // validation passed\n *     });\n *\n * @param {Array|String} [pathsToValidate] list of paths to validate. If set, Mongoose will validate only the modified paths that are in the given list.\n * @param {Object} [options] internal options\n * @param {Boolean} [options.validateModifiedOnly=false] if `true` mongoose validates only modified paths.\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n * @param {Function} [callback] optional callback called after validation completes, passing an error if one occurred\n * @return {Promise} Returns a Promise if no `callback` is given.\n * @api public\n */\n\nDocument.prototype.validate = function(pathsToValidate, options, callback) {\n  let parallelValidate;\n  this.$op = 'validate';\n\n  if (this.$isSubdocument != null) {\n    // Skip parallel validate check for subdocuments\n  } else if (this.$__.validating) {\n    parallelValidate = new ParallelValidateError(this, {\n      parentStack: options && options.parentStack,\n      conflictStack: this.$__.validating.stack\n    });\n  } else {\n    this.$__.validating = new ParallelValidateError(this, { parentStack: options && options.parentStack });\n  }\n\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n      options = arguments[0];\n      callback = null;\n      pathsToValidate = null;\n    } else if (typeof arguments[0] === 'function') {\n      callback = arguments[0];\n      options = null;\n      pathsToValidate = null;\n    }\n  } else if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = pathsToValidate;\n    pathsToValidate = null;\n  }\n  if (options && typeof options.pathsToSkip === 'string') {\n    const isOnePathOnly = options.pathsToSkip.indexOf(' ') === -1;\n    options.pathsToSkip = isOnePathOnly ? [options.pathsToSkip] : options.pathsToSkip.split(' ');\n  }\n\n  return promiseOrCallback(callback, cb => {\n    if (parallelValidate != null) {\n      return cb(parallelValidate);\n    }\n\n    this.$__validate(pathsToValidate, options, (error) => {\n      this.$op = null;\n      this.$__.validating = null;\n      cb(error);\n    });\n  }, this.constructor.events);\n};\n\n/**\n * Alias of [`.validate`](#document_Document-validate)\n *\n * @method $validate\n * @memberOf Document\n * @api public\n */\n\nDocument.prototype.$validate = Document.prototype.validate;\n\n/*!\n * ignore\n */\n\nfunction _evaluateRequiredFunctions(doc) {\n  const requiredFields = Object.keys(doc.$__.activePaths.getStatePaths('require'));\n  let i = 0;\n  const len = requiredFields.length;\n  for (i = 0; i < len; ++i) {\n    const path = requiredFields[i];\n\n    const p = doc.$__schema.path(path);\n\n    if (p != null && typeof p.originalRequiredValue === 'function') {\n      doc.$__.cachedRequired = doc.$__.cachedRequired || {};\n      try {\n        doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc, doc);\n      } catch (err) {\n        doc.invalidate(path, err);\n      }\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _getPathsToValidate(doc) {\n  const skipSchemaValidators = {};\n\n  _evaluateRequiredFunctions(doc);\n  // only validate required fields when necessary\n  let paths = new Set(Object.keys(doc.$__.activePaths.getStatePaths('require')).filter(function(path) {\n    if (!doc.$__isSelected(path) && !doc.$isModified(path)) {\n      return false;\n    }\n    if (doc.$__.cachedRequired != null && path in doc.$__.cachedRequired) {\n      return doc.$__.cachedRequired[path];\n    }\n    return true;\n  }));\n\n  Object.keys(doc.$__.activePaths.getStatePaths('init')).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.getStatePaths('modify')).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.getStatePaths('default')).forEach(addToPaths);\n  function addToPaths(p) { paths.add(p); }\n\n  const subdocs = doc.$getAllSubdocs();\n  const modifiedPaths = doc.modifiedPaths();\n  for (const subdoc of subdocs) {\n    if (subdoc.$basePath) {\n      // Remove child paths for now, because we'll be validating the whole\n      // subdoc\n      const fullPathToSubdoc = subdoc.$__fullPathWithIndexes();\n\n      for (const p of paths) {\n        if (p == null || p.startsWith(fullPathToSubdoc + '.')) {\n          paths.delete(p);\n        }\n      }\n\n      if (doc.$isModified(fullPathToSubdoc, modifiedPaths) &&\n            !doc.isDirectModified(fullPathToSubdoc) &&\n            !doc.$isDefault(fullPathToSubdoc)) {\n        paths.add(fullPathToSubdoc);\n\n        skipSchemaValidators[fullPathToSubdoc] = true;\n      }\n    }\n  }\n\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType) {\n      continue;\n    }\n\n    if (_pathType.$isMongooseDocumentArray) {\n      for (const p of paths) {\n        if (p == null || p.startsWith(_pathType.path + '.')) {\n          paths.delete(p);\n        }\n      }\n    }\n\n    // Optimization: if primitive path with no validators, or array of primitives\n    // with no validators, skip validating this path entirely.\n    if (!_pathType.caster && _pathType.validators.length === 0) {\n      paths.delete(path);\n    } else if (_pathType.$isMongooseArray &&\n      !_pathType.$isMongooseDocumentArray && // Skip document arrays...\n      !_pathType.$embeddedSchemaType.$isMongooseArray && // and arrays of arrays\n      _pathType.validators.length === 0 && // and arrays with top-level validators\n      _pathType.$embeddedSchemaType.validators.length === 0) {\n      paths.delete(path);\n    }\n  }\n\n  // from here on we're not removing items from paths\n\n  // gh-661: if a whole array is modified, make sure to run validation on all\n  // the children as well\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType) {\n      continue;\n    }\n\n    if (!_pathType.$isMongooseArray ||\n        // To avoid potential performance issues, skip doc arrays whose children\n        // are not required. `getPositionalPathType()` may be slow, so avoid\n        // it unless we have a case of #6364\n        (!Array.isArray(_pathType) &&\n          _pathType.$isMongooseDocumentArray &&\n          !(_pathType && _pathType.schemaOptions && _pathType.schemaOptions.required))) {\n      continue;\n    }\n\n    // gh-11380: optimization. If the array isn't a document array and there's no validators\n    // on the array type, there's no need to run validation on the individual array elements.\n    if (_pathType.$isMongooseArray &&\n        !_pathType.$isMongooseDocumentArray && // Skip document arrays...\n        !_pathType.$embeddedSchemaType.$isMongooseArray && // and arrays of arrays\n        _pathType.$embeddedSchemaType.validators.length === 0) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n    _pushNestedArrayPaths(val, paths, path);\n  }\n\n  function _pushNestedArrayPaths(val, paths, path) {\n    if (val != null) {\n      const numElements = val.length;\n      for (let j = 0; j < numElements; ++j) {\n        if (Array.isArray(val[j])) {\n          _pushNestedArrayPaths(val[j], paths, path + '.' + j);\n        } else {\n          paths.add(path + '.' + j);\n        }\n      }\n    }\n  }\n\n  const flattenOptions = { skipArrays: true };\n  for (const pathToCheck of paths) {\n    if (doc.$__schema.nested[pathToCheck]) {\n      let _v = doc.$__getValue(pathToCheck);\n      if (isMongooseObject(_v)) {\n        _v = _v.toObject({ transform: false });\n      }\n      const flat = flatten(_v, pathToCheck, flattenOptions, doc.$__schema);\n      Object.keys(flat).forEach(addToPaths);\n    }\n  }\n\n  for (const path of paths) {\n    // Single nested paths (paths embedded under single nested subdocs) will\n    // be validated on their own when we call `validate()` on the subdoc itself.\n    // Re: gh-8468\n    if (doc.$__schema.singleNestedPaths.hasOwnProperty(path)) {\n      paths.delete(path);\n      continue;\n    }\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType || !_pathType.$isSchemaMap) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n    if (val == null) {\n      continue;\n    }\n    for (const key of val.keys()) {\n      paths.add(path + '.' + key);\n    }\n  }\n\n  paths = Array.from(paths);\n  return [paths, skipSchemaValidators];\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__validate = function(pathsToValidate, options, callback) {\n  if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options &&\n      (typeof options === 'object') &&\n      ('validateModifiedOnly' in options);\n\n  const pathsToSkip = (options && options.pathsToSkip) || null;\n\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n\n  const _this = this;\n  const _complete = () => {\n    let validationError = this.$__.validationError;\n    this.$__.validationError = null;\n    this.$__.validating = null;\n\n    if (shouldValidateModifiedOnly && validationError != null) {\n      // Remove any validation errors that aren't from modified paths\n      const errors = Object.keys(validationError.errors);\n      for (const errPath of errors) {\n        if (!this.$isModified(errPath)) {\n          delete validationError.errors[errPath];\n        }\n      }\n      if (Object.keys(validationError.errors).length === 0) {\n        validationError = void 0;\n      }\n    }\n\n    this.$__.cachedRequired = {};\n    this.$emit('validate', _this);\n    this.constructor.emit('validate', _this);\n\n    if (validationError) {\n      for (const key in validationError.errors) {\n        // Make sure cast errors persist\n        if (!this[documentArrayParent] &&\n            validationError.errors[key] instanceof MongooseError.CastError) {\n          this.invalidate(key, validationError.errors[key]);\n        }\n      }\n\n      return validationError;\n    }\n  };\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this);\n  let paths = shouldValidateModifiedOnly ?\n    pathDetails[0].filter((path) => this.$isModified(path)) :\n    pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n  if (typeof pathsToValidate === 'string') {\n    pathsToValidate = pathsToValidate.split(' ');\n  }\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  } else if (pathsToSkip) {\n    paths = _handlePathsToSkip(paths, pathsToSkip);\n  }\n\n  if (paths.length === 0) {\n    return immediate(function() {\n      const error = _complete();\n      if (error) {\n        return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback(null, _this);\n    });\n  }\n\n  const validated = {};\n  let total = 0;\n\n  for (const path of paths) {\n    validatePath(path);\n  }\n\n  function validatePath(path) {\n    if (path == null || validated[path]) {\n      return;\n    }\n\n    validated[path] = true;\n    total++;\n\n    immediate(function() {\n      const schemaType = _this.$__schema.path(path);\n\n      if (!schemaType) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don't validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      // If setting a path under a mixed path, avoid using the mixed path validator (gh-10141)\n      if (schemaType[schemaMixedSymbol] != null && path !== schemaType.path) {\n        return --total || complete();\n      }\n\n      let val = _this.$__getValue(path);\n\n      // If you `populate()` and get back a null value, required validators\n      // shouldn't fail (gh-8018). We should always fall back to the populated\n      // value.\n      let pop;\n      if ((pop = _this.$populated(path))) {\n        val = pop;\n      } else if (val != null && val.$__ != null && val.$__.wasPopulated) {\n        // Array paths, like `somearray.1`, do not show up as populated with `$populated()`,\n        // so in that case pull out the document's id\n        val = val._id;\n      }\n      const scope = _this.$__.pathsToScopes != null && path in _this.$__.pathsToScopes ?\n        _this.$__.pathsToScopes[path] :\n        _this;\n\n      const doValidateOptions = {\n        skipSchemaValidators: skipSchemaValidators[path],\n        path: path,\n        validateModifiedOnly: shouldValidateModifiedOnly\n      };\n\n      schemaType.doValidate(val, function(err) {\n        if (err) {\n          const isSubdoc = schemaType.$isSingleNested ||\n            schemaType.$isArraySubdocument ||\n            schemaType.$isMongooseDocumentArray;\n          if (isSubdoc && err instanceof ValidationError) {\n            return --total || complete();\n          }\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, scope, doValidateOptions);\n    });\n  }\n\n  function complete() {\n    const error = _complete();\n    if (error) {\n      return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback(null, _this);\n  }\n\n};\n\n/*!\n * ignore\n */\n\nfunction _handlePathsToValidate(paths, pathsToValidate) {\n  const _pathsToValidate = new Set(pathsToValidate);\n  const parentPaths = new Map([]);\n  for (const path of pathsToValidate) {\n    if (path.indexOf('.') === -1) {\n      continue;\n    }\n    const pieces = path.split('.');\n    let cur = pieces[0];\n    for (let i = 1; i < pieces.length; ++i) {\n      // Since we skip subpaths under single nested subdocs to\n      // avoid double validation, we need to add back the\n      // single nested subpath if the user asked for it (gh-8626)\n      parentPaths.set(cur, path);\n      cur = cur + '.' + pieces[i];\n    }\n  }\n\n  const ret = [];\n  for (const path of paths) {\n    if (_pathsToValidate.has(path)) {\n      ret.push(path);\n    } else if (parentPaths.has(path)) {\n      ret.push(parentPaths.get(path));\n    }\n  }\n  return ret;\n}\n\n/*!\n * ignore\n */\n\nfunction _handlePathsToSkip(paths, pathsToSkip) {\n  pathsToSkip = new Set(pathsToSkip);\n  paths = paths.filter(p => !pathsToSkip.has(p));\n  return paths;\n}\n\n/**\n * Executes registered validation rules (skipping asynchronous validators) for this document.\n *\n * #### Note:\n *\n * This method is useful if you need synchronous validation.\n *\n * #### Example:\n *\n *     const err = doc.validateSync();\n *     if (err) {\n *       handleError(err);\n *     } else {\n *       // validation passed\n *     }\n *\n * @param {Array|string} [pathsToValidate] only validate the given paths\n * @param {Object} [options] options for validation\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n * @return {ValidationError|undefined} ValidationError if there are errors during validation, or undefined if there is no error.\n * @api public\n */\n\nDocument.prototype.validateSync = function(pathsToValidate, options) {\n  const _this = this;\n\n  if (arguments.length === 1 && typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n    options = arguments[0];\n    pathsToValidate = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options &&\n      (typeof options === 'object') &&\n      ('validateModifiedOnly' in options);\n\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n\n  let pathsToSkip = options && options.pathsToSkip;\n\n  if (typeof pathsToValidate === 'string') {\n    const isOnePathOnly = pathsToValidate.indexOf(' ') === -1;\n    pathsToValidate = isOnePathOnly ? [pathsToValidate] : pathsToValidate.split(' ');\n  } else if (typeof pathsToSkip === 'string' && pathsToSkip.indexOf(' ') !== -1) {\n    pathsToSkip = pathsToSkip.split(' ');\n  }\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this);\n  let paths = shouldValidateModifiedOnly ?\n    pathDetails[0].filter((path) => this.$isModified(path)) :\n    pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  } else if (Array.isArray(pathsToSkip)) {\n    paths = _handlePathsToSkip(paths, pathsToSkip);\n  }\n  const validating = {};\n\n  for (let i = 0, len = paths.length; i < len; ++i) {\n    const path = paths[i];\n\n    if (validating[path]) {\n      continue;\n    }\n\n    validating[path] = true;\n\n    const p = _this.$__schema.path(path);\n    if (!p) {\n      continue;\n    }\n    if (!_this.$isValid(path)) {\n      continue;\n    }\n\n    const val = _this.$__getValue(path);\n    const err = p.doValidateSync(val, _this, {\n      skipSchemaValidators: skipSchemaValidators[path],\n      path: path,\n      validateModifiedOnly: shouldValidateModifiedOnly\n    });\n    if (err) {\n      const isSubdoc = p.$isSingleNested ||\n        p.$isArraySubdocument ||\n        p.$isMongooseDocumentArray;\n      if (isSubdoc && err instanceof ValidationError) {\n        continue;\n      }\n      _this.invalidate(path, err, undefined, true);\n    }\n  }\n\n  const err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.$emit('validate', _this);\n  _this.constructor.emit('validate', _this);\n\n  if (err) {\n    for (const key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n};\n\n/**\n * Marks a path as invalid, causing validation to fail.\n *\n * The `errorMsg` argument will become the message of the `ValidationError`.\n *\n * The `value` argument (if passed) will be available through the `ValidationError.value` property.\n *\n *     doc.invalidate('size', 'must be less than 20', 14);\n *\n *     doc.validate(function (err) {\n *       console.log(err)\n *       // prints\n *       { message: 'Validation failed',\n *         name: 'ValidationError',\n *         errors:\n *          { size:\n *             { message: 'must be less than 20',\n *               name: 'ValidatorError',\n *               path: 'size',\n *               type: 'user defined',\n *               value: 14 } } }\n *     })\n *\n * @param {String} path the field to invalidate. For array elements, use the `array.i.field` syntax, where `i` is the 0-based index in the array.\n * @param {String|Error} err the error which states the reason `path` was invalid\n * @param {Object|String|Number|any} val optional invalid value\n * @param {String} [kind] optional `kind` property for the error\n * @return {ValidationError} the current ValidationError, with all currently invalidated paths\n * @api public\n */\n\nDocument.prototype.invalidate = function(path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === 'string') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || 'user defined',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.addError(path, err);\n  return this.$__.validationError;\n};\n\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api public\n * @memberOf Document\n * @instance\n * @method $markValid\n */\n\nDocument.prototype.$markValid = function(path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _markValidSubpaths(doc, path) {\n  if (!doc.$__.validationError) {\n    return;\n  }\n\n  const keys = Object.keys(doc.$__.validationError.errors);\n  for (const key of keys) {\n    if (key.startsWith(path + '.')) {\n      delete doc.$__.validationError.errors[key];\n    }\n  }\n  if (Object.keys(doc.$__.validationError.errors).length === 0) {\n    doc.$__.validationError = null;\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _checkImmutableSubpaths(subdoc, schematype, priorVal) {\n  const schema = schematype.schema;\n  if (schema == null) {\n    return;\n  }\n\n  for (const key of Object.keys(schema.paths)) {\n    const path = schema.paths[key];\n    if (path.$immutableSetter == null) {\n      continue;\n    }\n    const oldVal = priorVal == null ? void 0 : priorVal.$__getValue(key);\n    // Calling immutableSetter with `oldVal` even though it expects `newVal`\n    // is intentional. That's because `$immutableSetter` compares its param\n    // to the current value.\n    path.$immutableSetter.call(subdoc, oldVal);\n  }\n}\n\n/**\n * Saves this document by inserting a new document into the database if [document.isNew](#document_Document-isNew) is `true`,\n * or sends an [updateOne](#document_Document-updateOne) operation **only** with the modifications to the database, it does not replace the whole document in the latter case.\n *\n * #### Example:\n *\n *     product.sold = Date.now();\n *     product = await product.save();\n *\n * If save is successful, the returned promise will fulfill with the document\n * saved.\n *\n * #### Example:\n *\n *     const newProduct = await product.save();\n *     newProduct === product; // true\n *\n * @param {Object} [options] options optional options\n * @param {Session} [options.session=null] the [session](https://www.mongodb.com/docs/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](#document_Document-$session).\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](https://mongoosejs.com//docs/guide.html#safe). Use the `w` option instead.\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Number|String} [options.w] set the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern).\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://www.mongodb.com/docs/manual/reference/limits/#Restrictions-on-Field-Names)\n * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this `save()`.\n * @param {Function} [fn] optional callback\n * @method save\n * @memberOf Document\n * @instance\n * @throws {DocumentNotFoundError} if this [save updates an existing document](#document_Document-isNew) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).\n * @return {Promise|undefined} Returns undefined if used with callback or a Promise otherwise.\n * @api public\n * @see middleware https://mongoosejs.com/docs/middleware.html\n */\n\n/**\n * Checks if a path is invalid\n *\n * @param {String|String[]} [path] the field to check. If unset will always return \"false\"\n * @method $isValid\n * @memberOf Document\n * @instance\n * @api private\n */\n\nDocument.prototype.$isValid = function(path) {\n  if (this.$__.validationError == null || Object.keys(this.$__.validationError.errors).length === 0) {\n    return true;\n  }\n  if (path == null) {\n    return false;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__.validationError.errors[p] == null);\n  }\n\n  return this.$__.validationError.errors[path] == null;\n};\n\n/**\n * Resets the internal modified state of this document.\n *\n * @api private\n * @return {Document} this\n * @method $__reset\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__reset = function reset() {\n  let _this = this;\n\n  // Skip for subdocuments\n  const subdocs = this.$parent() === this ? this.$getAllSubdocs() : [];\n  const resetArrays = new Set();\n  for (const subdoc of subdocs) {\n    const fullPathWithIndexes = subdoc.$__fullPathWithIndexes();\n    if (this.isModified(fullPathWithIndexes) || isParentInit(fullPathWithIndexes)) {\n      subdoc.$__reset();\n      if (subdoc.$isDocumentArrayElement) {\n        if (!resetArrays.has(subdoc.parentArray())) {\n          const array = subdoc.parentArray();\n          this.$__.activePaths.clearPath(fullPathWithIndexes.replace(/\\.\\d+$/, '').slice(-subdoc.$basePath - 1));\n          array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];\n          array[arrayAtomicsSymbol] = {};\n\n          resetArrays.add(array);\n        }\n      } else {\n        if (subdoc.$parent() === this) {\n          this.$__.activePaths.clearPath(subdoc.$basePath);\n        } else if (subdoc.$parent() != null && subdoc.$parent().$isSubdocument) {\n          // If map path underneath subdocument, may end up with a case where\n          // map path is modified but parent still needs to be reset. See gh-10295\n          subdoc.$parent().$__reset();\n        }\n      }\n    }\n  }\n\n  function isParentInit(path) {\n    path = path.indexOf('.') === -1 ? [path] : path.split('.');\n    let cur = '';\n    for (let i = 0; i < path.length; ++i) {\n      cur += (cur.length ? '.' : '') + path[i];\n      if (_this.$__.activePaths[cur] === 'init') {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol]) {\n      type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];\n      type[arrayAtomicsSymbol] = {};\n    }\n  });\n\n  this.$__.backup = {};\n  this.$__.backup.activePaths = {\n    modify: Object.assign({}, this.$__.activePaths.getStatePaths('modify')),\n    default: Object.assign({}, this.$__.activePaths.getStatePaths('default'))\n  };\n  this.$__.backup.validationError = this.$__.validationError;\n  this.$__.backup.errors = this.$errors;\n\n  // Clear 'dirty' cache\n  this.$__.activePaths.clear('modify');\n  this.$__.activePaths.clear('default');\n  this.$__.validationError = undefined;\n  this.$errors = undefined;\n  _this = this;\n  this.$__schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__undoReset = function $__undoReset() {\n  if (this.$__.backup == null || this.$__.backup.activePaths == null) {\n    return;\n  }\n\n  this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;\n  this.$__.activePaths.states.default = this.$__.backup.activePaths.default;\n\n  this.$__.validationError = this.$__.backup.validationError;\n  this.$errors = this.$__.backup.errors;\n\n  for (const dirt of this.$__dirty()) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {\n      type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];\n    }\n  }\n\n  for (const subdoc of this.$getAllSubdocs()) {\n    subdoc.$__undoReset();\n  }\n};\n\n/**\n * Returns this documents dirty paths / vals.\n *\n * @return {Array}\n * @api private\n * @method $__dirty\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__dirty = function() {\n  const _this = this;\n  let all = this.$__.activePaths.map('modify', function(path) {\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map('default', function(path) {\n    if (path === '_id' || _this.$__getValue(path) == null) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  const allPaths = new Map(all.filter((el) => el != null).map((el) => [el.path, el.value]));\n  // Ignore \"foo.a\" if \"foo\" is dirty already.\n  const minimal = [];\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n\n    let top = null;\n\n    const array = parentPaths(item.path);\n    for (let i = 0; i < array.length - 1; i++) {\n      if (allPaths.has(array[i])) {\n        top = allPaths.get(array[i]);\n        break;\n      }\n    }\n    if (top == null) {\n      minimal.push(item);\n    } else if (top != null &&\n        top[arrayAtomicsSymbol] != null &&\n        top.hasAtomics()) {\n      // special case for top level MongooseArrays\n      // the `top` array itself and a sub path of `top` are being set.\n      // the only way to honor all of both modifications is through a $set\n      // of entire array.\n      top[arrayAtomicsSymbol] = {};\n      top[arrayAtomicsSymbol].$set = top;\n    }\n  });\n  return minimal;\n};\n\n/**\n * Assigns/compiles `schema` into this documents prototype.\n *\n * @param {Schema} schema\n * @api private\n * @method $__setSchema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__setSchema = function(schema) {\n  compile(schema.tree, this, undefined, schema.options);\n\n  // Apply default getters if virtual doesn't have any (gh-6262)\n  for (const key of Object.keys(schema.virtuals)) {\n    schema.virtuals[key]._applyDefaultGetters();\n  }\n  if (schema.path('schema') == null) {\n    this.schema = schema;\n  }\n  this.$__schema = schema;\n  this[documentSchemaSymbol] = schema;\n};\n\n\n/**\n * Get active path that were changed and are arrays\n *\n * @return {Array}\n * @api private\n * @method $__getArrayPathsToValidate\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__getArrayPathsToValidate = function() {\n  DocumentArray || (DocumentArray = require('./types/DocumentArray'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n    .map('init', 'modify', function(i) {\n      return this.$__getValue(i);\n    }.bind(this))\n    .filter(function(val) {\n      return val && Array.isArray(val) && utils.isMongooseDocumentArray(val) && val.length;\n    }).reduce(function(seed, array) {\n      return seed.concat(array);\n    }, [])\n    .filter(function(doc) {\n      return doc;\n    });\n};\n\n\n/**\n * Get all subdocs (by bfs)\n *\n * @return {Array}\n * @api public\n * @method $getAllSubdocs\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$getAllSubdocs = function() {\n  DocumentArray || (DocumentArray = require('./types/DocumentArray'));\n  Embedded = Embedded || require('./types/ArraySubdocument');\n\n  function docReducer(doc, seed, path) {\n    let val = doc;\n    let isNested = false;\n    if (path) {\n      if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {\n        val = doc._doc[path];\n      } else if (doc instanceof Document && doc[documentSchemaSymbol].nested[path]) {\n        val = doc._doc[path];\n        isNested = true;\n      } else {\n        val = doc[path];\n      }\n    }\n    if (val instanceof Embedded) {\n      seed.push(val);\n    } else if (val instanceof Map) {\n      seed = Array.from(val.keys()).reduce(function(seed, path) {\n        return docReducer(val.get(path), seed, null);\n      }, seed);\n    } else if (val && !Array.isArray(val) && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(function(seed, path) {\n        return docReducer(val, seed, path);\n      }, seed);\n      seed.push(val);\n    } else if (val && utils.isMongooseDocumentArray(val)) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        seed = Object.keys(doc._doc).reduce(function(seed, path) {\n          return docReducer(doc._doc, seed, path);\n        }, seed);\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n      });\n    } else if (isNested && val != null) {\n      for (const path of Object.keys(val)) {\n        docReducer(val, seed, path);\n      }\n    }\n    return seed;\n  }\n\n  const subDocs = [];\n  for (const path of Object.keys(this._doc)) {\n    docReducer(this, subDocs, path);\n  }\n\n  return subDocs;\n};\n\n/*!\n * Runs queued functions\n */\n\nfunction applyQueue(doc) {\n  const q = doc.$__schema && doc.$__schema.callQueue;\n  if (!q.length) {\n    return;\n  }\n\n  for (const pair of q) {\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      doc[pair[0]].apply(doc, pair[1]);\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__handleReject = function handleReject(err) {\n  // emit on the Model if listening\n  if (this.$listeners('error').length) {\n    this.$emit('error', err);\n  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {\n    this.constructor.emit('error', err);\n  }\n};\n\n/**\n * Internal helper for toObject() and toJSON() that doesn't manipulate options\n *\n * @return {Object}\n * @api private\n * @method $toObject\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$toObject = function(options, json) {\n  let defaultOptions = {\n    transform: true,\n    flattenDecimals: true\n  };\n\n  const path = json ? 'toJSON' : 'toObject';\n  const baseOptions = this.constructor &&\n    this.constructor.base &&\n    this.constructor.base.options &&\n    get(this.constructor.base.options, path) || {};\n  const schemaOptions = this.$__schema && this.$__schema.options || {};\n  // merge base default options with Schema's set default options if available.\n  // `clone` is necessary here because `utils.options` directly modifies the second input.\n  defaultOptions = utils.options(defaultOptions, clone(baseOptions));\n  defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path] || {}));\n\n  // If options do not exist or is not an object, set it to empty object\n  options = utils.isPOJO(options) ? { ...options } : {};\n  options._calledWithOptions = options._calledWithOptions || { ...options };\n\n  let _minimize;\n  if (options._calledWithOptions.minimize != null) {\n    _minimize = options.minimize;\n  } else if (defaultOptions.minimize != null) {\n    _minimize = defaultOptions.minimize;\n  } else {\n    _minimize = schemaOptions.minimize;\n  }\n\n  let flattenMaps;\n  if (options._calledWithOptions.flattenMaps != null) {\n    flattenMaps = options.flattenMaps;\n  } else if (defaultOptions.flattenMaps != null) {\n    flattenMaps = defaultOptions.flattenMaps;\n  } else {\n    flattenMaps = schemaOptions.flattenMaps;\n  }\n\n  // The original options that will be passed to `clone()`. Important because\n  // `clone()` will recursively call `$toObject()` on embedded docs, so we\n  // need the original options the user passed in, plus `_isNested` and\n  // `_parentOptions` for checking whether we need to depopulate.\n  const cloneOptions = Object.assign({}, options, {\n    _isNested: true,\n    json: json,\n    minimize: _minimize,\n    flattenMaps: flattenMaps,\n    _seen: (options && options._seen) || new Map()\n  });\n\n  if (utils.hasUserDefinedProperty(options, 'getters')) {\n    cloneOptions.getters = options.getters;\n  }\n  if (utils.hasUserDefinedProperty(options, 'virtuals')) {\n    cloneOptions.virtuals = options.virtuals;\n  }\n\n  const depopulate = options.depopulate ||\n    (options._parentOptions && options._parentOptions.depopulate || false);\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate the top-level document\n  if (depopulate && options._isNested && this.$__.wasPopulated) {\n    return clone(this.$__.wasPopulated.value || this._id, cloneOptions);\n  }\n\n  // merge default options with input options.\n  options = utils.options(defaultOptions, options);\n  options._isNested = true;\n  options.json = json;\n  options.minimize = _minimize;\n\n  cloneOptions._parentOptions = options;\n  cloneOptions._skipSingleNestedGetters = false;\n\n  const gettersOptions = Object.assign({}, cloneOptions);\n  gettersOptions._skipSingleNestedGetters = true;\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  const originalTransform = options.transform;\n\n  let ret = clone(this._doc, cloneOptions) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, gettersOptions);\n\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || (options.getters && options.virtuals !== false)) {\n    applyVirtuals(this, ret, gettersOptions, options);\n  }\n\n  if (options.versionKey === false && this.$__schema.options.versionKey) {\n    delete ret[this.$__schema.options.versionKey];\n  }\n\n  let transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema's transform and\n  // not the parent schema's\n  if (transform) {\n    applySchemaTypeTransforms(this, ret);\n  }\n\n  if (options.useProjection) {\n    omitDeselectedFields(this, ret);\n  }\n\n  if (transform === true || (schemaOptions.toObject && transform)) {\n    const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === 'function') {\n    const xformed = transform(this, ret, options);\n    if (typeof xformed !== 'undefined') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Converts this document into a plain-old JavaScript object ([POJO](https://masteringjs.io/tutorials/fundamentals/pojo)).\n *\n * Buffers are converted to instances of [mongodb.Binary](https://mongodb.github.io/node-mongodb-native/4.9/classes/Binary.html) for proper storage.\n *\n * #### Getters/Virtuals\n *\n * Example of only applying path getters\n *\n *     doc.toObject({ getters: true, virtuals: false })\n *\n * Example of only applying virtual getters\n *\n *     doc.toObject({ virtuals: true })\n *\n * Example of applying both path and virtual getters\n *\n *     doc.toObject({ getters: true })\n *\n * To apply these options to every document of your schema by default, set your [schemas](#schema_Schema) `toObject` option to the same argument.\n *\n *     schema.set('toObject', { virtuals: true })\n *\n * #### Transform:\n *\n * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.\n *\n * Transform functions receive three arguments\n *\n *     function (doc, ret, options) {}\n *\n * - `doc` The mongoose document which is being converted\n * - `ret` The plain object representation which has been converted\n * - `options` The options in use (either schema options or the options passed inline)\n *\n * #### Example:\n *\n *     // specify the transform schema option\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       // remove the _id of every document before returning the result\n *       delete ret._id;\n *       return ret;\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { name: 'Wreck-it Ralph' }\n *\n * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       return { movie: ret.name }\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { movie: 'Wreck-it Ralph' }\n *\n * _Note: if a transform function returns `undefined`, the return value will be ignored._\n *\n * Transformations may also be applied inline, overridding any transform set in the options:\n *\n *     function xform (doc, ret, options) {\n *       return { inline: ret.name, custom: true }\n *     }\n *\n *     // pass the transform as an inline option\n *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }\n *\n * If you want to skip transformations, use `transform: false`:\n *\n *     schema.options.toObject.hide = '_id';\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       if (options.hide) {\n *         options.hide.split(' ').forEach(function (prop) {\n *           delete ret[prop];\n *         });\n *       }\n *       return ret;\n *     }\n *\n *     const doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });\n *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: false });// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }\n *\n * If you pass a transform in `toObject()` options, Mongoose will apply the transform\n * to [subdocuments](/docs/subdocs.html) in addition to the top-level document.\n * Similarly, `transform: false` skips transforms for all subdocuments.\n * Note that this behavior is different for transforms defined in the schema:\n * if you define a transform in `schema.options.toObject.transform`, that transform\n * will **not** apply to subdocuments.\n *\n *     const memberSchema = new Schema({ name: String, email: String });\n *     const groupSchema = new Schema({ members: [memberSchema], name: String, email });\n *     const Group = mongoose.model('Group', groupSchema);\n *\n *     const doc = new Group({\n *       name: 'Engineering',\n *       email: 'dev@mongoosejs.io',\n *       members: [{ name: 'Val', email: 'val@mongoosejs.io' }]\n *     });\n *\n *     // Removes `email` from both top-level document **and** array elements\n *     // { name: 'Engineering', members: [{ name: 'Val' }] }\n *     doc.toObject({ transform: (doc, ret) => { delete ret.email; return ret; } });\n *\n * Transforms, like all of these options, are also available for `toJSON`. See [this guide to `JSON.stringify()`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html) to learn why `toJSON()` and `toObject()` are separate functions.\n *\n * See [schema options](/docs/guide.html#toObject) for some more details.\n *\n * _During save, no custom options are applied to the document before being sent to the database._\n *\n * @param {Object} [options]\n * @param {Boolean} [options.getters=false] if true, apply all getters, including virtuals\n * @param {Boolean} [options.virtuals=false] if true, apply virtuals, including aliases. Use `{ getters: true, virtuals: false }` to just apply getters, not virtuals\n * @param {Boolean} [options.aliases=true] if `options.virtuals = true`, you can set `options.aliases = false` to skip applying aliases. This option is a no-op if `options.virtuals = false`.\n * @param {Boolean} [options.minimize=true] if true, omit any empty objects from the output\n * @param {Function|null} [options.transform=null] if set, mongoose will call this function to allow you to transform the returned object\n * @param {Boolean} [options.depopulate=false] if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths.\n * @param {Boolean} [options.versionKey=true] if false, exclude the version key (`__v` by default) from the output\n * @param {Boolean} [options.flattenMaps=false] if true, convert Maps to POJOs. Useful if you want to `JSON.stringify()` the result of `toObject()`.\n * @param {Boolean} [options.useProjection=false] - If true, omits fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.\n * @return {Object} js object (not a POJO)\n * @see mongodb.Binary https://mongodb.github.io/node-mongodb-native/4.9/classes/Binary.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toObject = function(options) {\n  return this.$toObject(options);\n};\n\n/**\n * Minimizes an object, removing undefined values and empty objects\n *\n * @param {Object} object to minimize\n * @return {Object}\n * @api private\n */\n\nfunction minimize(obj) {\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys;\n  let key;\n  let val;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if (utils.isPOJO(val)) {\n      obj[key] = minimize(val);\n    }\n\n    if (undefined === obj[key]) {\n      delete obj[key];\n      continue;\n    }\n\n    hasKeys = true;\n  }\n\n  return hasKeys\n    ? obj\n    : undefined;\n}\n\n/*!\n * Applies virtuals properties to `json`.\n */\n\nfunction applyVirtuals(self, json, options, toObjectOptions) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.virtuals);\n  let i = paths.length;\n  const numPaths = i;\n  let path;\n  let assignPath;\n  let cur = self._doc;\n  let v;\n  const aliases = typeof (toObjectOptions && toObjectOptions.aliases) === 'boolean'\n    ? toObjectOptions.aliases\n    : true;\n\n  let virtualsToApply = null;\n  if (Array.isArray(options.virtuals)) {\n    virtualsToApply = new Set(options.virtuals);\n  }\n  else if (options.virtuals && options.virtuals.pathsToSkip) {\n    virtualsToApply = new Set(paths);\n    for (let i = 0; i < options.virtuals.pathsToSkip.length; i++) {\n      if (virtualsToApply.has(options.virtuals.pathsToSkip[i])) {\n        virtualsToApply.delete(options.virtuals.pathsToSkip[i]);\n      }\n    }\n  }\n\n  if (!cur) {\n    return json;\n  }\n\n  options = options || {};\n  for (i = 0; i < numPaths; ++i) {\n    path = paths[i];\n\n    if (virtualsToApply != null && !virtualsToApply.has(path)) {\n      continue;\n    }\n\n    // Allow skipping aliases with `toObject({ virtuals: true, aliases: false })`\n    if (!aliases && schema.aliases.hasOwnProperty(path)) {\n      continue;\n    }\n\n    // We may be applying virtuals to a nested object, for example if calling\n    // `doc.nestedProp.toJSON()`. If so, the path we assign to, `assignPath`,\n    // will be a trailing substring of the `path`.\n    assignPath = path;\n    if (options.path != null) {\n      if (!path.startsWith(options.path + '.')) {\n        continue;\n      }\n      assignPath = path.substring(options.path.length + 1);\n    }\n    const parts = assignPath.split('.');\n    v = clone(self.get(path), options);\n    if (v === void 0) {\n      continue;\n    }\n    const plen = parts.length;\n    cur = json;\n    for (let j = 0; j < plen - 1; ++j) {\n      cur[parts[j]] = cur[parts[j]] || {};\n      cur = cur[parts[j]];\n    }\n    cur[parts[plen - 1]] = v;\n  }\n\n  return json;\n}\n\n\n/**\n * Applies virtuals properties to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @param {Object} [options]\n * @return {Object} `json`\n * @api private\n */\n\nfunction applyGetters(self, json, options) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths);\n  let i = paths.length;\n  let path;\n  let cur = self._doc;\n  let v;\n\n  if (!cur) {\n    return json;\n  }\n\n  while (i--) {\n    path = paths[i];\n\n    const parts = path.split('.');\n    const plen = parts.length;\n    const last = plen - 1;\n    let branch = json;\n    let part;\n    cur = self._doc;\n\n    if (!self.$__isSelected(path)) {\n      continue;\n    }\n\n    for (let ii = 0; ii < plen; ++ii) {\n      part = parts[ii];\n      v = cur[part];\n      if (ii === last) {\n        const val = self.$get(path);\n        branch[part] = clone(val, options);\n      } else if (v == null) {\n        if (part in cur) {\n          branch[part] = v;\n        }\n        break;\n      } else {\n        branch = branch[part] || (branch[part] = {});\n      }\n      cur = v;\n    }\n  }\n\n  return json;\n}\n\n/**\n * Applies schema type transforms to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @return {Object} `json`\n * @api private\n */\n\nfunction applySchemaTypeTransforms(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  for (const path of paths) {\n    const schematype = schema.paths[path];\n    if (typeof schematype.options.transform === 'function') {\n      const val = self.$get(path);\n      if (val === undefined) {\n        continue;\n      }\n      const transformedValue = schematype.options.transform.call(self, val);\n      throwErrorIfPromise(path, transformedValue);\n      utils.setValue(path, transformedValue, json);\n    } else if (schematype.$embeddedSchemaType != null &&\n        typeof schematype.$embeddedSchemaType.options.transform === 'function') {\n      const val = self.$get(path);\n      if (val === undefined) {\n        continue;\n      }\n      const vals = [].concat(val);\n      const transform = schematype.$embeddedSchemaType.options.transform;\n      for (let i = 0; i < vals.length; ++i) {\n        const transformedValue = transform.call(self, vals[i]);\n        vals[i] = transformedValue;\n        throwErrorIfPromise(path, transformedValue);\n      }\n\n      json[path] = vals;\n    }\n  }\n\n  return json;\n}\n\nfunction throwErrorIfPromise(path, transformedValue) {\n  if (isPromise(transformedValue)) {\n    throw new Error('`transform` function must be synchronous, but the transform on path `' + path + '` returned a promise.');\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction omitDeselectedFields(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  let selected = self.$__.selected;\n  if (selected === void 0) {\n    selected = {};\n    queryhelpers.applyPaths(selected, schema);\n  }\n  if (selected == null || Object.keys(selected).length === 0) {\n    return json;\n  }\n\n  for (const path of paths) {\n    if (selected[path] != null && !selected[path]) {\n      delete json[path];\n    }\n  }\n\n  return json;\n}\n\n/**\n * The return value of this method is used in calls to [`JSON.stringify(doc)`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript#the-tojson-function).\n *\n * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.\n *\n *     schema.set('toJSON', { virtuals: true });\n *\n * There is one difference between `toJSON()` and `toObject()` options.\n * When you call `toJSON()`, the [`flattenMaps` option](./document.html#document_Document-toObject) defaults to `true`, because `JSON.stringify()` doesn't convert maps to objects by default.\n * When you call `toObject()`, the `flattenMaps` option is `false` by default.\n *\n * See [schema options](/docs/guide.html#toJSON) for more information on setting `toJSON` option defaults.\n *\n * @param {Object} options\n * @param {Boolean} [options.flattenMaps=true] if true, convert Maps to [POJOs](https://masteringjs.io/tutorials/fundamentals/pojo). Useful if you want to `JSON.stringify()` the result.\n * @return {Object}\n * @see Document#toObject #document_Document-toObject\n * @see JSON.stringify() in JavaScript https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toJSON = function(options) {\n  return this.$toObject(options, true);\n};\n\n\nDocument.prototype.ownerDocument = function() {\n  return this;\n};\n\n\n/**\n * If this document is a subdocument or populated document, returns the document's\n * parent. Returns the original document if there is no parent.\n *\n * @return {Document}\n * @api public\n * @method parent\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.parent = function() {\n  if (this.$isSubdocument || this.$__.wasPopulated) {\n    return this.$__.parent;\n  }\n  return this;\n};\n\n/**\n * Alias for [`parent()`](#document_Document-parent). If this document is a subdocument or populated\n * document, returns the document's parent. Returns `undefined` otherwise.\n *\n * @return {Document}\n * @api public\n * @method $parent\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$parent = Document.prototype.parent;\n\n/**\n * Helper for console.log\n *\n * @return {String}\n * @api public\n * @method inspect\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.inspect = function(options) {\n  const isPOJO = utils.isPOJO(options);\n  let opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n  }\n  const ret = this.toObject(opts);\n\n  if (ret == null) {\n    // If `toObject()` returns null, `this` is still an object, so if `inspect()`\n    // prints out null this can cause some serious confusion. See gh-7942.\n    return 'MongooseDocument { ' + ret + ' }';\n  }\n\n  return ret;\n};\n\nif (inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  Document.prototype[inspect.custom] = Document.prototype.inspect;\n}\n\n/**\n * Helper for console.log\n *\n * @return {String}\n * @api public\n * @method toString\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toString = function() {\n  const ret = this.inspect();\n  if (typeof ret === 'string') {\n    return ret;\n  }\n  return inspect(ret);\n};\n\n/**\n * Returns true if this document is equal to another document.\n *\n * Documents are considered equal when they have matching `_id`s, unless neither\n * document has an `_id`, in which case this function falls back to using\n * `deepEqual()`.\n *\n * @param {Document} [doc] a document to compare. If falsy, will always return \"false\".\n * @return {Boolean}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.equals = function(doc) {\n  if (!doc) {\n    return false;\n  }\n\n  const tid = this.$__getValue('_id');\n  const docid = doc.$__ != null ? doc.$__getValue('_id') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n    ? tid.equals(docid)\n    : tid === docid;\n};\n\n/**\n * Populates paths on an existing document.\n *\n * #### Example:\n *\n *     // Given a document, `populate()` lets you pull in referenced docs\n *     await doc.populate([\n *       'stories',\n *       { path: 'fans', sort: { name: -1 } }\n *     ]);\n *     doc.populated('stories'); // Array of ObjectIds\n *     doc.stories[0].title; // 'Casino Royale'\n *     doc.populated('fans'); // Array of ObjectIds\n *\n *     // If the referenced doc has been deleted, `populate()` will\n *     // remove that entry from the array.\n *     await Story.delete({ title: 'Casino Royale' });\n *     await doc.populate('stories'); // Empty array\n *\n *     // You can also pass additional query options to `populate()`,\n *     // like projections:\n *     await doc.populate('fans', '-email');\n *     doc.fans[0].email // undefined because of 2nd param `select`\n *\n * @param {String|Object|Array} path either the path to populate or an object specifying all parameters, or either an array of those\n * @param {Object|String} [select] Field selection for the population query\n * @param {Model} [model] The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.\n * @param {Object} [match] Conditions for the population query\n * @param {Object} [options] Options for the population query (sort, etc)\n * @param {String} [options.path=null] The path to populate.\n * @param {string|PopulateOptions} [options.populate=null] Recursively populate paths in the populated documents. See [deep populate docs](/docs/populate.html#deep-populate).\n * @param {boolean} [options.retainNullValues=false] by default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n * @param {boolean} [options.getters=false] if true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](/docs/schematypes.html#schematype-options).\n * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.\n * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @param {Function} [callback] Callback\n * @see population /docs/populate.html\n * @see Query#select #query_Query-select\n * @see Model.populate #model_Model-populate\n * @memberOf Document\n * @instance\n * @return {Promise|null} Returns a Promise if no `callback` is given.\n * @api public\n */\n\nDocument.prototype.populate = function populate() {\n  const pop = {};\n  const args = [...arguments];\n  let fn;\n\n  if (args.length !== 0) {\n    if (typeof args[args.length - 1] === 'function') {\n      fn = args.pop();\n    }\n\n    // use hash to remove duplicate paths\n    const res = utils.populate.apply(null, args);\n    for (const populateOptions of res) {\n      pop[populateOptions.path] = populateOptions;\n    }\n  }\n\n  const paths = utils.object.vals(pop);\n  let topLevelModel = this.constructor;\n  if (this.$__isNested) {\n    topLevelModel = this.$__[scopeSymbol].constructor;\n    const nestedPath = this.$__.nestedPath;\n    paths.forEach(function(populateOptions) {\n      populateOptions.path = nestedPath + '.' + populateOptions.path;\n    });\n  }\n\n  // Use `$session()` by default if the document has an associated session\n  // See gh-6754\n  if (this.$session() != null) {\n    const session = this.$session();\n    paths.forEach(path => {\n      if (path.options == null) {\n        path.options = { session: session };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  paths.forEach(p => {\n    p._localModel = topLevelModel;\n  });\n\n  return topLevelModel.populate(this, paths, fn);\n};\n\n/**\n * Gets all populated documents associated with this document.\n *\n * @api public\n * @return {Document[]} array of populated documents. Empty array if there are no populated documents associated with this document.\n * @memberOf Document\n * @method $getPopulatedDocs\n * @instance\n */\n\nDocument.prototype.$getPopulatedDocs = function $getPopulatedDocs() {\n  let keys = [];\n  if (this.$__.populated != null) {\n    keys = keys.concat(Object.keys(this.$__.populated));\n  }\n  let result = [];\n  for (const key of keys) {\n    const value = this.$get(key);\n    if (Array.isArray(value)) {\n      result = result.concat(value);\n    } else if (value instanceof Document) {\n      result.push(value);\n    }\n  }\n  return result;\n};\n\n/**\n * Gets _id(s) used during population of the given `path`.\n *\n * #### Example:\n *\n *     const doc = await Model.findOne().populate('author');\n *\n *     console.log(doc.author.name); // Dr.Seuss\n *     console.log(doc.populated('author')); // '5144cf8050f071d979c118a7'\n *\n * If the path was not populated, returns `undefined`.\n *\n * @param {String} path\n * @param {Any} [val]\n * @param {Object} [options]\n * @return {Array|ObjectId|Number|Buffer|String|undefined}\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.populated = function(path, val, options) {\n  // val and options are internal\n  if (val == null || val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    if (typeof path !== 'string') {\n      return undefined;\n    }\n\n    // Map paths can be populated with either `path.$*` or just `path`\n    const _path = path.endsWith('.$*') ? path.replace(/\\.\\$\\*$/, '') : path;\n\n    const v = this.$__.populated[_path];\n    if (v) {\n      return val === true ? v : v.value;\n    }\n    return undefined;\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = { value: val, options: options };\n\n  // If this was a nested populate, make sure each populated doc knows\n  // about its populated children (gh-7685)\n  const pieces = path.split('.');\n  for (let i = 0; i < pieces.length - 1; ++i) {\n    const subpath = pieces.slice(0, i + 1).join('.');\n    const subdoc = this.$get(subpath);\n    if (subdoc != null && subdoc.$__ != null && this.$populated(subpath)) {\n      const rest = pieces.slice(i + 1).join('.');\n      subdoc.$populated(rest, val, options);\n      // No need to continue because the above recursion should take care of\n      // marking the rest of the docs as populated\n      break;\n    }\n  }\n\n  return val;\n};\n\n/**\n * Alias of [`.populated`](#document_Document-populated).\n *\n * @method $populated\n * @memberOf Document\n * @api public\n */\n\nDocument.prototype.$populated = Document.prototype.populated;\n\n/**\n * Throws an error if a given path is not populated\n *\n * #### Example:\n *\n *     const doc = await Model.findOne().populate('author');\n *\n *     doc.$assertPopulated('author'); // does not throw\n *     doc.$assertPopulated('other path'); // throws an error\n *\n *     // Manually populate and assert in one call. The following does\n *     // `doc.$set({ likes })` before asserting.\n *     doc.$assertPopulated('likes', { likes });\n *\n *\n * @param {String|String[]} path path or array of paths to check. `$assertPopulated` throws if any of the given paths is not populated.\n * @param {Object} [values] optional values to `$set()`. Convenient if you want to manually populate a path and assert that the path was populated in 1 call.\n * @return {Document} this\n * @memberOf Document\n * @method $assertPopulated\n * @instance\n * @api public\n */\n\nDocument.prototype.$assertPopulated = function $assertPopulated(path, values) {\n  if (Array.isArray(path)) {\n    path.forEach(p => this.$assertPopulated(p, values));\n    return this;\n  }\n\n  if (arguments.length > 1) {\n    this.$set(values);\n  }\n\n  if (!this.$populated(path)) {\n    throw new MongooseError(`Expected path \"${path}\" to be populated`);\n  }\n\n  return this;\n};\n\n/**\n * Takes a populated field and returns it to its unpopulated state.\n *\n * #### Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name); // Dr.Seuss\n *       console.log(doc.depopulate('author'));\n *       console.log(doc.author); // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not provided, then all populated fields are returned to their unpopulated state.\n *\n * @param {String|String[]} [path] Specific Path to depopulate. If unset, will depopulate all paths on the Document. Or multiple space-delimited paths.\n * @return {Document} this\n * @see Document.populate #document_Document-populate\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.depopulate = function(path) {\n  if (typeof path === 'string') {\n    path = path.indexOf(' ') === -1 ? [path] : path.split(' ');\n  }\n\n  let populatedIds;\n  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];\n  const populated = this.$__ && this.$__.populated || {};\n\n  if (arguments.length === 0) {\n    // Depopulate all\n    for (const virtualKey of virtualKeys) {\n      delete this.$$populatedVirtuals[virtualKey];\n      delete this._doc[virtualKey];\n      delete populated[virtualKey];\n    }\n\n    const keys = Object.keys(populated);\n\n    for (const key of keys) {\n      populatedIds = this.$populated(key);\n      if (!populatedIds) {\n        continue;\n      }\n      delete populated[key];\n      utils.setValue(key, populatedIds, this._doc);\n    }\n    return this;\n  }\n\n  for (const singlePath of path) {\n    populatedIds = this.$populated(singlePath);\n    delete populated[singlePath];\n\n    if (virtualKeys.indexOf(singlePath) !== -1) {\n      delete this.$$populatedVirtuals[singlePath];\n      delete this._doc[singlePath];\n    } else if (populatedIds) {\n      utils.setValue(singlePath, populatedIds, this._doc);\n    }\n  }\n  return this;\n};\n\n\n/**\n * Returns the full path to this document.\n *\n * @param {String} [path]\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__fullPath = function(path) {\n  // overridden in SubDocuments\n  return path || '';\n};\n\n/**\n * Returns the changes that happened to the document\n * in the format that will be sent to MongoDB.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({\n *       name: String,\n *       age: Number,\n *       country: String\n *     });\n *     const User = mongoose.model('User', userSchema);\n *     const user = await User.create({\n *       name: 'Hafez',\n *       age: 25,\n *       country: 'Egypt'\n *     });\n *\n *     // returns an empty object, no changes happened yet\n *     user.getChanges(); // { }\n *\n *     user.country = undefined;\n *     user.age = 26;\n *\n *     user.getChanges(); // { $set: { age: 26 }, { $unset: { country: 1 } } }\n *\n *     await user.save();\n *\n *     user.getChanges(); // { }\n *\n * Modifying the object that `getChanges()` returns does not affect the document's\n * change tracking state. Even if you `delete user.getChanges().$set`, Mongoose\n * will still send a `$set` to the server.\n *\n * @return {Object}\n * @api public\n * @method getChanges\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.getChanges = function() {\n  const delta = this.$__delta();\n  const changes = delta ? delta[1] : {};\n  return changes;\n};\n\n/**\n * Returns a copy of this document with a deep clone of `_doc` and `$__`.\n *\n * @return {Document} a copy of this document\n * @api public\n * @method $clone\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$clone = function() {\n  const Model = this.constructor;\n  const clonedDoc = new Model();\n  clonedDoc.$isNew = this.$isNew;\n  if (this._doc) {\n    clonedDoc._doc = clone(this._doc);\n  }\n  if (this.$__) {\n    const Cache = this.$__.constructor;\n    const clonedCache = new Cache();\n    for (const key of Object.getOwnPropertyNames(this.$__)) {\n      if (key === 'activePaths') {\n        continue;\n      }\n      clonedCache[key] = clone(this.$__[key]);\n    }\n    Object.assign(clonedCache.activePaths, clone({ ...this.$__.activePaths }));\n    clonedDoc.$__ = clonedCache;\n  }\n  return clonedDoc;\n};\n\n/*!\n * Module exports.\n */\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;\n", "'use strict';\n\n/**\n * Module dependencies.\n */\n\nconst start = require('./common');\n\nconst Document = require('../lib/document');\nconst EventEmitter = require('events').EventEmitter;\nconst ArraySubdocument = require('../lib/types/ArraySubdocument');\nconst Query = require('../lib/query');\nconst assert = require('assert');\nconst idGetter = require('../lib/helpers/schema/idGetter');\nconst util = require('./util');\nconst utils = require('../lib/utils');\n\nconst mongoose = start.mongoose;\nconst Schema = mongoose.Schema;\nconst ObjectId = Schema.ObjectId;\nconst DocumentObjectId = mongoose.Types.ObjectId;\nconst SchemaType = mongoose.SchemaType;\nconst ValidatorError = SchemaType.ValidatorError;\nconst ValidationError = mongoose.Document.ValidationError;\nconst VersionError = mongoose.Error.VersionError;\nconst MongooseError = mongoose.Error;\nconst DocumentNotFoundError = mongoose.Error.DocumentNotFoundError;\n\n/**\n * Test Document constructor.\n */\n\nfunction TestDocument() {\n  Document.apply(this, arguments);\n}\n\n/**\n * Inherits from Document.\n */\n\nObject.setPrototypeOf(TestDocument.prototype, Document.prototype);\n\nfor (const i in EventEmitter.prototype) {\n  TestDocument[i] = EventEmitter.prototype[i];\n}\n\n/**\n * Set a dummy schema to simulate compilation.\n */\n\nconst em = new Schema({ title: String, body: String });\nem.virtual('works').get(function() {\n  return 'em virtual works';\n});\nconst schema = new Schema({\n  test: String,\n  oids: [ObjectId],\n  numbers: [Number],\n  nested: {\n    age: Number,\n    cool: ObjectId,\n    deep: { x: String },\n    path: String,\n    setr: String\n  },\n  nested2: {\n    nested: String,\n    yup: {\n      nested: Boolean,\n      yup: String,\n      age: Number\n    }\n  },\n  em: [em],\n  date: Date\n});\n\nTestDocument.prototype.$__setSchema(idGetter(schema));\n\nschema.virtual('nested.agePlus2').get(function() {\n  return this.nested.age + 2;\n});\nschema.virtual('nested.setAge').set(function(v) {\n  this.nested.age = v;\n});\nschema.path('nested.path').get(function(v) {\n  return (this.nested.age || '') + (v ? v : '');\n});\nschema.path('nested.setr').set(function(v) {\n  return v + ' setter';\n});\n\nlet dateSetterCalled = false;\nschema.path('date').set(function(v) {\n  // should not have been cast to a Date yet\n  if (v !== undefined) {\n    assert.equal(typeof v, 'string');\n  }\n  dateSetterCalled = true;\n  return v;\n});\n\n/**\n * Method subject to hooks. Simply fires the callback once the hooks are\n * executed.\n */\n\nTestDocument.prototype.hooksTest = function(fn) {\n  fn(null, arguments);\n};\n\nconst childSchema = new Schema({ counter: Number });\n\nconst parentSchema = new Schema({\n  name: String,\n  children: [childSchema]\n});\n\n/**\n * Test.\n */\n\ndescribe('document', function() {\n  let db;\n\n  before(function() {\n    db = start();\n  });\n\n  after(async function() {\n    await db.close();\n  });\n\n  beforeEach(() => db.deleteModel(/.*/));\n  afterEach(() => util.clearTestData(db));\n  afterEach(() => util.stopRemainingOps(db));\n\n  describe('constructor', function() {\n    it('supports passing in schema directly (gh-8237)', function() {\n      const myUserDoc = new Document({}, { name: String });\n      assert.ok(!myUserDoc.name);\n      myUserDoc.name = 123;\n      assert.strictEqual(myUserDoc.name, '123');\n\n      assert.ifError(myUserDoc.validateSync());\n    });\n  });\n\n  describe('delete', function() {\n    it('deletes the document', async function() {\n      const schema = new Schema({ x: String });\n      const Test = db.model('Test', schema);\n\n      const test = new Test({ x: 'test' });\n      const doc = await test.save();\n      await doc.delete();\n      const found = await Test.findOne({ _id: doc._id });\n      assert.strictEqual(found, null);\n\n    });\n  });\n\n  describe('updateOne', function() {\n    let Test;\n\n    before(function() {\n      const schema = new Schema({ x: String, y: String });\n      db.deleteModel(/^Test$/);\n      Test = db.model('Test', schema);\n    });\n\n    it('updates the document', async function() {\n      const test = new Test({ x: 'test' });\n      const doc = await test.save();\n      await doc.updateOne({ y: 'test' });\n      const found = await Test.findOne({ _id: doc._id });\n      assert.strictEqual(found.y, 'test');\n    });\n\n    it('returns a query', function() {\n      const doc = new Test({ x: 'test' });\n      assert.ok(doc.updateOne() instanceof Test.Query);\n    });\n\n    it('middleware (gh-8262)', async function() {\n      const schema = new Schema({ x: String, y: String });\n      const docs = [];\n      schema.post('updateOne', { document: true, query: false }, function(doc, next) {\n        docs.push(doc);\n        next();\n      });\n      const Model = db.model('Test', schema);\n\n\n      const doc = await Model.create({ x: 2, y: 4 });\n\n      await doc.updateOne({ x: 4 });\n      assert.equal(docs.length, 1);\n      assert.equal(docs[0], doc);\n    });\n  });\n\n  describe('replaceOne', function() {\n    it('replaces the document', async function() {\n      const schema = new Schema({ x: String });\n      const Test = db.model('Test', schema);\n\n      const test = new Test({ x: 'test' });\n      const doc = await test.save();\n      await doc.replaceOne({ x: 'updated' });\n      const found = await Test.findOne({ _id: doc._id });\n      assert.strictEqual(found.x, 'updated');\n\n    });\n  });\n\n  describe('shortcut getters', function() {\n    it('return undefined for properties with a null/undefined parent object (gh-1326)', function() {\n      const doc = new TestDocument();\n      doc.init({ nested: null });\n      assert.strictEqual(undefined, doc.nested.age);\n    });\n\n    it('work', function() {\n      const doc = new TestDocument();\n      doc.init({\n        test: 'test',\n        oids: [],\n        nested: {\n          age: 5,\n          cool: DocumentObjectId.createFromHexString('4c6c2d6240ced95d0e00003c'),\n          path: 'my path'\n        }\n      });\n\n      assert.equal(doc.test, 'test');\n      assert.ok(doc.oids instanceof Array);\n      assert.equal(doc.nested.age, 5);\n      assert.equal(String(doc.nested.cool), '4c6c2d6240ced95d0e00003c');\n      assert.equal(doc.nested.agePlus2, 7);\n      assert.equal(doc.nested.path, '5my path');\n      doc.nested.setAge = 10;\n      assert.equal(doc.nested.age, 10);\n      doc.nested.setr = 'set it';\n      assert.equal(doc.$__getValue('nested.setr'), 'set it setter');\n\n      const doc2 = new TestDocument();\n      doc2.init({\n        test: 'toop',\n        oids: [],\n        nested: {\n          age: 2,\n          cool: DocumentObjectId.createFromHexString('4cf70857337498f95900001c'),\n          deep: { x: 'yay' }\n        }\n      });\n\n      assert.equal(doc2.test, 'toop');\n      assert.ok(doc2.oids instanceof Array);\n      assert.equal(doc2.nested.age, 2);\n\n      // GH-366\n      assert.equal(doc2.nested.bonk, undefined);\n      assert.equal(doc2.nested.nested, undefined);\n      assert.equal(doc2.nested.test, undefined);\n      assert.equal(doc2.nested.age.test, undefined);\n      assert.equal(doc2.nested.age.nested, undefined);\n      assert.equal(doc2.oids.nested, undefined);\n      assert.equal(doc2.nested.deep.x, 'yay');\n      assert.equal(doc2.nested.deep.nested, undefined);\n      assert.equal(doc2.nested.deep.cool, undefined);\n      assert.equal(doc2.nested2.yup.nested, undefined);\n      assert.equal(doc2.nested2.yup.nested2, undefined);\n      assert.equal(doc2.nested2.yup.yup, undefined);\n      assert.equal(doc2.nested2.yup.age, undefined);\n      assert.equal(typeof doc2.nested2.yup, 'object');\n\n      doc2.nested2.yup = {\n        age: 150,\n        yup: 'Yesiree',\n        nested: true\n      };\n\n      assert.equal(doc2.nested2.nested, undefined);\n      assert.equal(doc2.nested2.yup.nested, true);\n      assert.equal(doc2.nested2.yup.yup, 'Yesiree');\n      assert.equal(doc2.nested2.yup.age, 150);\n      doc2.nested2.nested = 'y';\n      assert.equal(doc2.nested2.nested, 'y');\n      assert.equal(doc2.nested2.yup.nested, true);\n      assert.equal(doc2.nested2.yup.yup, 'Yesiree');\n      assert.equal(doc2.nested2.yup.age, 150);\n\n      assert.equal(String(doc2.nested.cool), '4cf70857337498f95900001c');\n\n      assert.ok(doc.oids !== doc2.oids);\n    });\n  });\n\n  it('test shortcut setters', function() {\n    const doc = new TestDocument();\n\n    doc.init({\n      test: 'Test',\n      nested: {\n        age: 5\n      }\n    });\n\n    assert.equal(doc.isModified('test'), false);\n    doc.test = 'Woot';\n    assert.equal(doc.test, 'Woot');\n    assert.equal(doc.isModified('test'), true);\n\n    assert.equal(doc.isModified('nested.age'), false);\n    doc.nested.age = 2;\n    assert.equal(doc.nested.age, 2);\n    assert.ok(doc.isModified('nested.age'));\n\n    doc.nested = { path: 'overwrite the entire nested object' };\n    assert.equal(doc.nested.age, undefined);\n    assert.equal(Object.keys(doc._doc.nested).length, 1);\n    assert.equal(doc.nested.path, 'overwrite the entire nested object');\n    assert.ok(doc.isModified('nested'));\n  });\n\n  it('test accessor of id', function() {\n    const doc = new TestDocument();\n    assert.ok(doc._id instanceof DocumentObjectId);\n  });\n\n  it('test shortcut of id hexString', function() {\n    const doc = new TestDocument();\n    assert.equal(typeof doc.id, 'string');\n  });\n\n  it('toObject options', function() {\n    const doc = new TestDocument();\n\n    doc.init({\n      test: 'test',\n      oids: [],\n      em: [{ title: 'asdf' }],\n      nested: {\n        age: 5,\n        cool: DocumentObjectId.createFromHexString('4c6c2d6240ced95d0e00003c'),\n        path: 'my path'\n      },\n      nested2: {},\n      date: new Date()\n    });\n\n    let clone = doc.toObject({ getters: true, virtuals: false });\n\n    assert.equal(clone.test, 'test');\n    assert.ok(clone.oids instanceof Array);\n    assert.equal(clone.nested.age, 5);\n    assert.equal(clone.nested.cool.toString(), '4c6c2d6240ced95d0e00003c');\n    assert.equal(clone.nested.path, '5my path');\n    assert.equal(clone.nested.agePlus2, undefined);\n    assert.equal(clone.em[0].works, undefined);\n    assert.ok(clone.date instanceof Date);\n\n    clone = doc.toObject({ virtuals: true });\n\n    assert.equal(clone.test, 'test');\n    assert.ok(clone.oids instanceof Array);\n    assert.equal(clone.nested.age, 5);\n    assert.equal(clone.nested.cool.toString(), '4c6c2d6240ced95d0e00003c');\n    assert.equal(clone.nested.path, 'my path');\n    assert.equal(clone.nested.agePlus2, 7);\n    assert.equal(clone.em[0].works, 'em virtual works');\n\n    clone = doc.toObject({ getters: true });\n\n    assert.equal(clone.test, 'test');\n    assert.ok(clone.oids instanceof Array);\n    assert.equal(clone.nested.age, 5);\n    assert.equal(clone.nested.cool.toString(), '4c6c2d6240ced95d0e00003c');\n    assert.equal(clone.nested.path, '5my path');\n    assert.equal(clone.nested.agePlus2, 7);\n    assert.equal(clone.em[0].works, 'em virtual works');\n\n    // test toObject options\n    doc.schema.options.toObject = { virtuals: true };\n    clone = doc.toObject({ transform: false, virtuals: true });\n    assert.equal(clone.test, 'test');\n    assert.ok(clone.oids instanceof Array);\n    assert.equal(clone.nested.age, 5);\n    assert.equal(clone.nested.cool.toString(), '4c6c2d6240ced95d0e00003c');\n\n    assert.equal(clone.nested.path, 'my path');\n    assert.equal(clone.nested.agePlus2, 7);\n    assert.equal(clone.em[0].title, 'asdf');\n    delete doc.schema.options.toObject;\n\n    // minimize\n    clone = doc.toObject({ minimize: true });\n    assert.equal(clone.nested2, undefined);\n    clone = doc.toObject({ minimize: true, getters: true });\n    assert.equal(clone.nested2, undefined);\n    clone = doc.toObject({ minimize: false });\n    assert.equal(clone.nested2.constructor.name, 'Object');\n    assert.equal(Object.keys(clone.nested2).length, 1);\n    clone = doc.toObject('2');\n    assert.equal(clone.nested2, undefined);\n\n    doc.schema.options.toObject = { minimize: false };\n    clone = doc.toObject({ transform: false, minimize: false });\n    assert.equal(clone.nested2.constructor.name, 'Object');\n    assert.equal(Object.keys(clone.nested2).length, 1);\n    delete doc.schema.options.toObject;\n\n    doc.schema.options.minimize = false;\n    clone = doc.toObject();\n    assert.equal(clone.nested2.constructor.name, 'Object');\n    assert.equal(Object.keys(clone.nested2).length, 1);\n    doc.schema.options.minimize = true;\n    clone = doc.toObject();\n    assert.equal(clone.nested2, undefined);\n\n    // transform\n    doc.schema.options.toObject = {};\n    doc.schema.options.toObject.transform = function xform(doc, ret) {\n      // ignore embedded docs\n      if (doc.$isSubdocument) {\n        return;\n      }\n\n      delete ret.em;\n      delete ret.numbers;\n      delete ret.oids;\n      ret._id = ret._id.toString();\n    };\n    clone = doc.toObject();\n    assert.equal(doc.id, clone._id);\n    assert.ok(undefined === clone.em);\n    assert.ok(undefined === clone.numbers);\n    assert.ok(undefined === clone.oids);\n    assert.equal(clone.test, 'test');\n    assert.equal(clone.nested.age, 5);\n\n    // transform with return value\n    const out = { myid: doc._id.toString() };\n    doc.schema.options.toObject.transform = function(doc, ret) {\n      // ignore embedded docs\n      if (doc.$isSubdocument) {\n        return;\n      }\n\n      return { myid: ret._id.toString() };\n    };\n\n    clone = doc.toObject();\n    assert.deepEqual(out, clone);\n\n    // ignored transform with inline options\n    clone = doc.toObject({ x: 1, transform: false });\n    assert.ok(!('myid' in clone));\n    assert.equal(clone.test, 'test');\n    assert.ok(clone.oids instanceof Array);\n    assert.equal(clone.nested.age, 5);\n    assert.equal(clone.nested.cool.toString(), '4c6c2d6240ced95d0e00003c');\n    assert.equal(clone.nested.path, 'my path');\n    assert.equal(clone.em[0].constructor.name, 'Object');\n\n    // applied transform when inline transform is true\n    clone = doc.toObject({ x: 1 });\n    assert.deepEqual(out, clone);\n\n    // transform passed inline\n    function xform(self, doc, opts) {\n      opts.fields.split(' ').forEach(function(field) {\n        delete doc[field];\n      });\n    }\n\n    clone = doc.toObject({\n      transform: xform,\n      fields: '_id em numbers oids nested'\n    });\n    assert.equal(doc.test, 'test');\n    assert.ok(undefined === clone.em);\n    assert.ok(undefined === clone.numbers);\n    assert.ok(undefined === clone.oids);\n    assert.ok(undefined === clone._id);\n    assert.ok(undefined === clone.nested);\n\n    // all done\n    delete doc.schema.options.toObject;\n  });\n\n  it('toObject transform', async function() {\n    const schema = new Schema({\n      name: String,\n      places: [{ type: ObjectId, ref: 'Place' }]\n    });\n\n    const schemaPlaces = new Schema({\n      identity: String\n    });\n\n    schemaPlaces.set('toObject', {\n      transform: function(doc, ret) {\n        assert.equal(doc.constructor.modelName, 'Place');\n        return ret;\n      }\n    });\n\n    const Test = db.model('Test', schema);\n    const Places = db.model('Place', schemaPlaces);\n\n    const [a, b, c] = await Places.create({ identity: 'a' }, { identity: 'b' }, { identity: 'c' });\n\n    await Test.create({ name: 'chetverikov', places: [a, b, c] });\n\n    const docs = await Test.findOne({}).populate('places').exec();\n\n    docs.toObject({ transform: true });\n  });\n\n  it('disabling aliases in toObject options (gh-7548)', function() {\n    const schema = new mongoose.Schema({\n      name: {\n        type: String,\n        alias: 'nameAlias'\n      },\n      age: Number\n    });\n    schema.virtual('answer').get(() => 42);\n\n    const Model = db.model('Person', schema);\n\n    const doc = new Model({ name: 'Jean-Luc Picard', age: 59 });\n\n    let obj = doc.toObject({ virtuals: true });\n    assert.equal(obj.nameAlias, 'Jean-Luc Picard');\n    assert.equal(obj.answer, 42);\n\n    obj = doc.toObject({ virtuals: true, aliases: false });\n    assert.ok(!obj.nameAlias);\n    assert.equal(obj.answer, 42);\n  });\n\n  it('can save multiple times with changes to complex subdocuments (gh-8531)', () => {\n    const clipSchema = Schema({\n      height: Number,\n      rows: Number,\n      width: Number\n    }, { _id: false, id: false });\n    const questionSchema = Schema({\n      type: String,\n      age: Number,\n      clip: {\n        type: clipSchema\n      }\n    }, { _id: false, id: false });\n    const keySchema = Schema({ ql: [questionSchema] }, { _id: false, id: false });\n    const Model = db.model('Test', Schema({\n      name: String,\n      keys: [keySchema]\n    }));\n    const doc = new Model({\n      name: 'test',\n      keys: [\n        { ql: [\n          { type: 'mc', clip: { width: 1 } },\n          { type: 'mc', clip: { height: 1, rows: 1 } },\n          { type: 'mc', clip: { height: 2, rows: 1 } },\n          { type: 'mc', clip: { height: 3, rows: 1 } }\n        ] }\n      ]\n    });\n    return doc.save().then(() => {\n      // The following was failing before fixing gh-8531 because\n      // the validation was called for the \"clip\" document twice in the\n      // same stack, causing a \"can't validate() the same doc multiple times in\n      // parallel\" warning\n      doc.keys[0].ql[0].clip = { width: 4.3, rows: 3 };\n      doc.keys[0].ql[0].age = 42;\n\n      return doc.save();\n    }); // passes\n  });\n\n  it('saves even if `_id` is null (gh-6406)', async function() {\n    const schema = new Schema({ _id: Number, val: String });\n    const Model = db.model('Test', schema);\n\n\n    await Model.updateOne({ _id: null }, { val: 'test' }, { upsert: true });\n\n    let doc = await Model.findOne();\n\n    doc.val = 'test2';\n\n    // Should not throw\n    await doc.save();\n\n    doc = await Model.findOne();\n    assert.strictEqual(doc._id, null);\n    assert.equal(doc.val, 'test2');\n  });\n\n  it('allows you to skip validation on save (gh-2981)', function() {\n    const schema = new Schema({ name: { type: String, required: true } });\n    const MyModel = db.model('Test', schema);\n\n    const doc = new MyModel();\n    return doc.save({ validateBeforeSave: false });\n  });\n\n  it('doesnt use custom toObject options on save', async function() {\n    const schema = new Schema({\n      name: String,\n      iWillNotBeDelete: Boolean,\n      nested: {\n        iWillNotBeDeleteToo: Boolean\n      }\n    });\n\n    schema.set('toObject', {\n      transform: function(doc, ret) {\n        delete ret.iWillNotBeDelete;\n        delete ret.nested.iWillNotBeDeleteToo;\n\n        return ret;\n      }\n    });\n    const Test = db.model('Test', schema);\n\n    await Test.create({ name: 'chetverikov', iWillNotBeDelete: true, 'nested.iWillNotBeDeleteToo': true });\n\n    const doc = await Test.findOne({});\n\n\n    assert.equal(doc._doc.iWillNotBeDelete, true);\n    assert.equal(doc._doc.nested.iWillNotBeDeleteToo, true);\n  });\n\n  describe('toObject', function() {\n    it('does not apply toObject functions of subdocuments to root document', async function() {\n      const subdocSchema = new Schema({\n        test: String,\n        wow: String\n      });\n\n      subdocSchema.options.toObject = {};\n      subdocSchema.options.toObject.transform = function(doc, ret) {\n        delete ret.wow;\n      };\n\n      const docSchema = new Schema({\n        foo: String,\n        wow: Boolean,\n        sub: [subdocSchema]\n      });\n\n      const Doc = db.model('Test', docSchema);\n\n      const doc = await Doc.create({\n        foo: 'someString',\n        wow: true,\n        sub: [{\n          test: 'someOtherString',\n          wow: 'thisIsAString'\n        }]\n      });\n\n      const obj = doc.toObject({\n        transform: function(doc, ret) {\n          ret.phew = 'new';\n        }\n      });\n\n      assert.equal(obj.phew, 'new');\n      assert.ok(!doc.sub.wow);\n    });\n\n    it('handles child schema transforms', function() {\n      const userSchema = new Schema({\n        name: String,\n        email: String\n      });\n      const topicSchema = new Schema({\n        title: String,\n        email: String,\n        followers: [userSchema]\n      });\n\n      userSchema.options.toObject = {\n        transform: function(doc, ret) {\n          delete ret.email;\n        }\n      };\n\n      topicSchema.options.toObject = {\n        transform: function(doc, ret) {\n          ret.title = ret.title.toLowerCase();\n        }\n      };\n\n      const Topic = db.model('Test', topicSchema);\n\n      const topic = new Topic({\n        title: 'Favorite Foods',\n        email: 'a@b.co',\n        followers: [{ name: 'Val', email: 'val@test.co' }]\n      });\n\n      const output = topic.toObject({ transform: true });\n      assert.equal(output.title, 'favorite foods');\n      assert.equal(output.email, 'a@b.co');\n      assert.equal(output.followers[0].name, 'Val');\n      assert.equal(output.followers[0].email, undefined);\n    });\n\n    it('doesnt clobber child schema options when called with no params (gh-2035)', async function() {\n      const userSchema = new Schema({\n        firstName: String,\n        lastName: String,\n        password: String\n      });\n\n      userSchema.virtual('fullName').get(function() {\n        return this.firstName + ' ' + this.lastName;\n      });\n\n      userSchema.set('toObject', { virtuals: false });\n\n      const postSchema = new Schema({\n        owner: { type: Schema.Types.ObjectId, ref: 'User' },\n        content: String\n      });\n\n      postSchema.virtual('capContent').get(function() {\n        return this.content.toUpperCase();\n      });\n\n      postSchema.set('toObject', { virtuals: true });\n      const User = db.model('User', userSchema);\n      const Post = db.model('BlogPost', postSchema);\n\n      const user = new User({ firstName: 'Joe', lastName: 'Smith', password: 'password' });\n\n      const savedUser = await user.save();\n\n      const post = await Post.create({ owner: savedUser._id, content: 'lorem ipsum' });\n\n      const newPost = await Post.findById(post._id).populate('owner').exec();\n\n      const obj = newPost.toObject();\n      assert.equal(obj.owner.fullName, undefined);\n    });\n\n    it('respects child schemas minimize (gh-9405)', function() {\n      const postSchema = new Schema({\n        owner: { type: Schema.Types.ObjectId, ref: 'User' },\n        props: { type: Object, default: {} }\n      });\n      const userSchema = new Schema({\n        firstName: String,\n        props: { type: Object, default: {} }\n      }, { minimize: false });\n\n      const User = db.model('User', userSchema);\n      const Post = db.model('BlogPost', postSchema);\n\n      const user = new User({ firstName: 'test' });\n      const post = new Post({ owner: user });\n\n      let obj = post.toObject();\n      assert.strictEqual(obj.props, void 0);\n      assert.deepEqual(obj.owner.props, {});\n\n      obj = post.toObject({ minimize: false });\n      assert.deepEqual(obj.props, {});\n      assert.deepEqual(obj.owner.props, {});\n\n      obj = post.toObject({ minimize: true });\n      assert.strictEqual(obj.props, void 0);\n      assert.strictEqual(obj.owner.props, void 0);\n    });\n\n    it('minimizes single nested subdocs (gh-11247)', async function() {\n      const nestedSchema = Schema({ bar: String }, { _id: false });\n      const schema = Schema({ foo: nestedSchema });\n\n      const MyModel = db.model('Test', schema);\n\n      const myModel = await MyModel.create({ foo: {} });\n\n      assert.strictEqual(myModel.toObject().foo, void 0);\n    });\n  });\n\n  describe('toJSON', function() {\n    it('toJSON options', function() {\n      const doc = new TestDocument();\n\n      doc.init({\n        test: 'test',\n        oids: [],\n        em: [{ title: 'asdf' }],\n        nested: {\n          age: 5,\n          cool: DocumentObjectId.createFromHexString('4c6c2d6240ced95d0e00003c'),\n          path: 'my path'\n        },\n        nested2: {}\n      });\n\n      // override to check if toJSON gets fired\n      const path = TestDocument.prototype.schema.path('em');\n      path.casterConstructor.prototype.toJSON = function() {\n        return {};\n      };\n\n      doc.schema.options.toJSON = { virtuals: true };\n      let clone = doc.toJSON();\n      assert.equal(clone.test, 'test');\n      assert.ok(clone.oids instanceof Array);\n      assert.equal(clone.nested.age, 5);\n      assert.equal(clone.nested.cool.toString(), '4c6c2d6240ced95d0e00003c');\n      assert.equal(clone.nested.path, 'my path');\n      assert.equal(clone.nested.agePlus2, 7);\n      assert.equal(clone.em[0].constructor.name, 'Object');\n      assert.equal(Object.keys(clone.em[0]).length, 0);\n      delete doc.schema.options.toJSON;\n      delete path.casterConstructor.prototype.toJSON;\n\n      doc.schema.options.toJSON = { minimize: false };\n      clone = doc.toJSON();\n      assert.equal(clone.nested2.constructor.name, 'Object');\n      assert.equal(Object.keys(clone.nested2).length, 1);\n      clone = doc.toJSON('8');\n      assert.equal(clone.nested2.constructor.name, 'Object');\n      assert.equal(Object.keys(clone.nested2).length, 1);\n\n      // gh-852\n      const arr = [doc];\n      let err = false;\n      let str;\n      try {\n        str = JSON.stringify(arr);\n      } catch (_) {\n        err = true;\n      }\n      assert.equal(err, false);\n      assert.ok(/nested2/.test(str));\n      assert.equal(clone.nested2.constructor.name, 'Object');\n      assert.equal(Object.keys(clone.nested2).length, 1);\n\n      // transform\n      doc.schema.options.toJSON = {};\n      doc.schema.options.toJSON.transform = function xform(doc, ret) {\n        // ignore embedded docs\n        if (doc.$isSubdocument) {\n          return;\n        }\n\n        delete ret.em;\n        delete ret.numbers;\n        delete ret.oids;\n        ret._id = ret._id.toString();\n      };\n\n      clone = doc.toJSON();\n      assert.equal(clone._id, doc.id);\n      assert.ok(undefined === clone.em);\n      assert.ok(undefined === clone.numbers);\n      assert.ok(undefined === clone.oids);\n      assert.equal(clone.test, 'test');\n      assert.equal(clone.nested.age, 5);\n\n      // transform with return value\n      const out = { myid: doc._id.toString() };\n      doc.schema.options.toJSON.transform = function(doc, ret) {\n        // ignore embedded docs\n        if (doc.$isSubdocument) {\n          return;\n        }\n\n        return { myid: ret._id.toString() };\n      };\n\n      clone = doc.toJSON();\n      assert.deepEqual(out, clone);\n\n      // ignored transform with inline options\n      clone = doc.toJSON({ x: 1, transform: false });\n      assert.ok(!('myid' in clone));\n      assert.equal(clone.test, 'test');\n      assert.ok(clone.oids instanceof Array);\n      assert.equal(clone.nested.age, 5);\n      assert.equal(clone.nested.cool.toString(), '4c6c2d6240ced95d0e00003c');\n      assert.equal(clone.nested.path, 'my path');\n      assert.equal(clone.em[0].constructor.name, 'Object');\n\n      // applied transform when inline transform is true\n      clone = doc.toJSON({ x: 1 });\n      assert.deepEqual(out, clone);\n\n      // transform passed inline\n      function xform(self, doc, opts) {\n        opts.fields.split(' ').forEach(function(field) {\n          delete doc[field];\n        });\n      }\n\n      clone = doc.toJSON({\n        transform: xform,\n        fields: '_id em numbers oids nested'\n      });\n      assert.equal(doc.test, 'test');\n      assert.ok(undefined === clone.em);\n      assert.ok(undefined === clone.numbers);\n      assert.ok(undefined === clone.oids);\n      assert.ok(undefined === clone._id);\n      assert.ok(undefined === clone.nested);\n\n      // all done\n      delete doc.schema.options.toJSON;\n    });\n\n    it('jsonifying an object', function() {\n      const doc = new TestDocument({ test: 'woot' });\n      const oidString = doc._id.toString();\n      // convert to json string\n      const json = JSON.stringify(doc);\n      // parse again\n      const obj = JSON.parse(json);\n\n      assert.equal(obj.test, 'woot');\n      assert.equal(obj._id, oidString);\n    });\n\n    it('jsonifying an object\\'s populated items works (gh-1376)', async function() {\n      const userSchema = new Schema({ name: String });\n      // includes virtual path when 'toJSON'\n      userSchema.set('toJSON', { getters: true });\n      userSchema.virtual('hello').get(function() {\n        return 'Hello, ' + this.name;\n      });\n      const User = db.model('User', userSchema);\n\n      const groupSchema = new Schema({\n        name: String,\n        _users: [{ type: Schema.ObjectId, ref: 'User' }]\n      });\n\n      const Group = db.model('Group', groupSchema);\n\n      const [alice, bob] = await User.create({ name: 'Alice' }, { name: 'Bob' });\n\n\n      const group = await Group.create({ name: 'mongoose', _users: [alice, bob] });\n      const foundGroup = await Group.findById(group).populate('_users').exec();\n\n      assert.ok(foundGroup.toJSON()._users[0].hello);\n    });\n\n    it('jsonifying with undefined path (gh-11922)', async function() {\n      const userSchema = new Schema({\n        name: String,\n        friends: [{\n          type: String,\n          transform(friendName) {\n            return `Hi, ${friendName}`;\n          }\n        }]\n      });\n      const User = db.model('User', userSchema);\n      const alice = await User.create({ name: 'Alic', friends: ['Bob', 'Jack'] });\n      const foundAlice = await User.findById(alice._id, { name: true });\n      assert.equal(foundAlice.friends, undefined);\n      const foundAlicJson = foundAlice.toJSON();\n      assert.equal(foundAlicJson.friends, undefined);\n      assert.equal(foundAlicJson.name, 'Alic');\n    });\n  });\n\n  describe('inspect', function() {\n    it('inspect inherits schema options (gh-4001)', async function() {\n      const opts = {\n        toObject: { virtuals: true },\n        toJSON: { virtuals: true }\n      };\n      const taskSchema = mongoose.Schema({\n        name: {\n          type: String,\n          required: true\n        }\n      }, opts);\n\n      taskSchema.virtual('title').\n        get(function() {\n          return this.name;\n        }).\n        set(function(title) {\n          this.name = title;\n        });\n\n      const Task = db.model('Test', taskSchema);\n\n      const doc = { name: 'task1', title: 'task999' };\n      await Task.collection.insertOne(doc);\n\n      const foundDoc = await Task.findById(doc._id);\n\n      assert.equal(foundDoc.inspect().title, 'task1');\n    });\n\n    it('does not apply transform to populated docs (gh-4213)', async function() {\n      const UserSchema = new Schema({\n        name: String\n      });\n\n      const PostSchema = new Schema({\n        title: String,\n        postedBy: {\n          type: mongoose.Schema.Types.ObjectId,\n          ref: 'User'\n        }\n      },\n      {\n        toObject: {\n          transform: function(doc, ret) {\n            delete ret._id;\n          }\n        },\n        toJSON: {\n          transform: function(doc, ret) {\n            delete ret._id;\n          }\n        }\n      });\n\n      const User = db.model('User', UserSchema);\n      const Post = db.model('BlogPost', PostSchema);\n\n      const val = new User({ name: 'Val' });\n      const post = new Post({ title: 'Test', postedBy: val._id });\n\n      await Post.create(post);\n\n      await User.create(val);\n\n      const posts = await Post.find({}).\n        populate('postedBy').\n        exec();\n\n      assert.equal(posts.length, 1);\n      assert.ok(posts[0].postedBy._id);\n    });\n\n    it('handles infinite recursion (gh-11756)', function() {\n      const User = db.model('User', Schema({\n        name: { type: String, required: true },\n        posts: [{ type: mongoose.Types.ObjectId, ref: 'Post' }]\n      }));\n\n      const Post = db.model('Post', Schema({\n        creator: { type: Schema.Types.ObjectId, ref: 'User' }\n      }));\n\n      const user = new User({ name: 'Test', posts: [] });\n      const post = new Post({ creator: user });\n      user.posts.push(post);\n\n      const inspected = post.inspect();\n      assert.ok(inspected);\n      assert.equal(inspected.creator.posts[0].creator.name, 'Test');\n    });\n\n    it('populate on nested path (gh-5703)', function() {\n      const toySchema = new mongoose.Schema({ color: String });\n      const Toy = db.model('Cat', toySchema);\n\n      const childSchema = new mongoose.Schema({\n        name: String,\n        values: {\n          toy: { type: mongoose.Schema.Types.ObjectId, ref: 'Cat' }\n        }\n      });\n      const Child = db.model('Child', childSchema);\n\n      return Toy.create({ color: 'brown' }).\n        then(function(toy) {\n          return Child.create({ values: { toy: toy._id } });\n        }).\n        then(function(child) {\n          return Child.findById(child._id);\n        }).\n        then(function(child) {\n          return child.values.populate('toy').then(function() {\n            return child;\n          });\n        }).\n        then(function(child) {\n          assert.equal(child.values.toy.color, 'brown');\n        });\n    });\n  });\n\n  describe.skip('#update', function() {\n    it('returns a Query', function() {\n      const mg = new mongoose.Mongoose();\n      const M = mg.model('Test', { s: String });\n      const doc = new M();\n      assert.ok(doc.update() instanceof Query);\n    });\n    it('calling update on document should relay to its model (gh-794)', async function() {\n      const Docs = new Schema({ text: String });\n      const docs = db.model('Test', Docs);\n      const d = new docs({ text: 'A doc' });\n      let called = false;\n      await d.save();\n\n      const oldUpdate = docs.update;\n      docs.update = function(query, operation) {\n        assert.equal(Object.keys(query).length, 1);\n        assert.equal(d._id, query._id);\n        assert.equal(Object.keys(operation).length, 1);\n        assert.equal(Object.keys(operation.$set).length, 1);\n        assert.equal(operation.$set.text, 'A changed doc');\n        called = true;\n        docs.update = oldUpdate;\n        oldUpdate.apply(docs, arguments);\n      };\n\n      await d.update({ $set: { text: 'A changed doc' } });\n\n      assert.equal(called, true);\n    });\n  });\n\n  it('toObject should not set undefined values to null', function() {\n    const doc = new TestDocument();\n    const obj = doc.toObject();\n\n    delete obj._id;\n    assert.deepEqual(obj, { numbers: [], oids: [], em: [] });\n  });\n\n  describe('Errors', function() {\n    it('MongooseErrors should be instances of Error (gh-209)', function() {\n      const MongooseError = require('../lib/error');\n      const err = new MongooseError('Some message');\n      assert.ok(err instanceof Error);\n    });\n    it('ValidationErrors should be instances of Error', function() {\n      const ValidationError = Document.ValidationError;\n      const err = new ValidationError(new TestDocument());\n      assert.ok(err instanceof Error);\n    });\n  });\n\n  it('methods on embedded docs should work', function() {\n    const ESchema = new Schema({ name: String });\n\n    ESchema.methods.test = function() {\n      return this.name + ' butter';\n    };\n    ESchema.statics.ten = function() {\n      return 10;\n    };\n\n    const E = db.model('Test', ESchema);\n    const PSchema = new Schema({ embed: [ESchema] });\n    const P = db.model('Test2', PSchema);\n\n    let p = new P({ embed: [{ name: 'peanut' }] });\n    assert.equal(typeof p.embed[0].test, 'function');\n    assert.equal(typeof E.ten, 'function');\n    assert.equal(p.embed[0].test(), 'peanut butter');\n    assert.equal(E.ten(), 10);\n\n    // test push casting\n    p = new P();\n    p.embed.push({ name: 'apple' });\n    assert.equal(typeof p.embed[0].test, 'function');\n    assert.equal(typeof E.ten, 'function');\n    assert.equal(p.embed[0].test(), 'apple butter');\n  });\n\n  it('setting a positional path does not cast value to array', function() {\n    const doc = new TestDocument();\n    doc.init({ numbers: [1, 3] });\n    assert.equal(doc.numbers[0], 1);\n    assert.equal(doc.numbers[1], 3);\n    doc.set('numbers.1', 2);\n    assert.equal(doc.numbers[0], 1);\n    assert.equal(doc.numbers[1], 2);\n  });\n\n  it('no maxListeners warning should occur', function() {\n    let traced = false;\n    const trace = console.trace;\n\n    console.trace = function() {\n      traced = true;\n      console.trace = trace;\n    };\n\n    const schema = new Schema({\n      title: String,\n      embed1: [new Schema({ name: String })],\n      embed2: [new Schema({ name: String })],\n      embed3: [new Schema({ name: String })],\n      embed4: [new Schema({ name: String })],\n      embed5: [new Schema({ name: String })],\n      embed6: [new Schema({ name: String })],\n      embed7: [new Schema({ name: String })],\n      embed8: [new Schema({ name: String })],\n      embed9: [new Schema({ name: String })],\n      embed10: [new Schema({ name: String })],\n      embed11: [new Schema({ name: String })]\n    });\n\n    const S = db.model('Test', schema);\n\n    new S({ title: 'test' });\n    assert.equal(traced, false);\n  });\n\n  it('unselected required fields should pass validation', async function() {\n    const userSchema = new Schema({\n      name: String,\n      req: { type: String, required: true }\n    });\n    const User = db.model('Test', userSchema);\n\n    const user = await User.create({ name: 'teeee', req: 'i am required' });\n\n    const user1 = await User.findById(user).select('name').exec();\n    assert.equal(user1.req, void 0);\n\n    user1.name = 'wooo';\n    await user1.save();\n    const user2 = await User.findById(user1).select('name').exec();\n\n    user2.req = undefined;\n    let err = await user2.save().then(() => null, err => err);\n    err = String(err);\n\n    const invalid = /Path `req` is required./.test(err);\n    assert.ok(invalid);\n\n    user2.req = 'it works again';\n    await user2.save();\n\n    const user3 = await User.findById(user2).select('_id').exec();\n    await user3.save();\n  });\n\n  describe('#validate', function() {\n    it('works (gh-891)', async function() {\n      let schema = null;\n      let called = false;\n\n      const validate = [function() {\n        called = true;\n        return true;\n      }, 'BAM'];\n\n      schema = new Schema({\n        prop: { type: String, required: true, validate: validate },\n        nick: { type: String, required: true }\n      });\n\n      const M = db.model('Test', schema);\n      const m = new M({ prop: 'gh891', nick: 'validation test' });\n      await m.save();\n\n      assert.equal(called, true);\n      called = false;\n\n      const m2 = await M.findById(m, 'nick');\n      assert.equal(called, false);\n\n      m2.nick = 'gh-891';\n      await m2.save();\n\n      assert.equal(called, false);\n    });\n\n    it('can return a promise', async function() {\n      let schema = null;\n\n      const validate = [function() {\n        return true;\n      }, 'BAM'];\n\n      schema = new Schema({\n        prop: { type: String, required: true, validate: validate },\n        nick: { type: String, required: true }\n      });\n\n      const M = db.model('Test', schema);\n      const m = new M({ prop: 'gh891', nick: 'validation test' });\n      const mBad = new M({ prop: 'other' });\n\n      await m.validate().then(res => res);\n\n      const err = await mBad.validate().then(() => null, err => err);\n      assert.ok(err);\n    });\n\n    it('doesnt have stale cast errors (gh-2766)', async function() {\n      const testSchema = new Schema({ name: String });\n      const M = db.model('Test', testSchema);\n\n      const m = new M({ _id: 'this is not a valid _id' });\n      assert.ok(!m.$isValid('_id'));\n      assert.ok(m.validateSync().errors['_id'].name, 'CastError');\n\n      m._id = '000000000000000000000001';\n      assert.ok(m.$isValid('_id'));\n      assert.ifError(m.validateSync());\n      await m.validate();\n    });\n\n    it('cast errors persist across validate() calls (gh-2766)', async function() {\n      const db = start();\n      const testSchema = new Schema({ name: String });\n      const M = db.model('Test', testSchema);\n\n      const m = new M({ _id: 'this is not a valid _id' });\n      assert.ok(!m.$isValid('_id'));\n      const error = await m.validate().then(() => null, err => err);\n\n      assert.ok(error);\n      assert.equal(error.errors['_id'].name, 'CastError');\n      const error2 = await m.validate().then(() => null, err => err);\n\n      assert.ok(error2);\n      assert.equal(error2.errors['_id'].name, 'CastError');\n\n      const err1 = m.validateSync();\n      const err2 = m.validateSync();\n      assert.equal(err1.errors['_id'].name, 'CastError');\n      assert.equal(err2.errors['_id'].name, 'CastError');\n      await db.close();\n    });\n\n    it('returns a promise when there are no validators', function(done) {\n      let schema = null;\n\n      schema = new Schema({ _id: String });\n\n      const M = db.model('Test', schema);\n      const m = new M();\n\n      const promise = m.validate();\n      promise.then(function() {\n        clearTimeout(timeout);\n        done();\n      });\n\n      const timeout = setTimeout(function() {\n        db.close();\n        throw new Error('Promise not fulfilled!');\n      }, 500);\n    });\n\n    describe('works on arrays', function() {\n      it('with required', function(done) {\n        const schema = new Schema({\n          name: String,\n          arr: { type: [], required: true }\n        });\n        const M = db.model('Test', schema);\n        const m = new M({ name: 'gh1109-1', arr: null });\n        m.save(function(err) {\n          assert.ok(/Path `arr` is required/.test(err));\n          m.arr = null;\n          m.save(function(err) {\n            assert.ok(/Path `arr` is required/.test(err));\n            m.arr = [];\n            m.arr.push('works');\n            m.save(function(err) {\n              assert.ifError(err);\n              done();\n            });\n          });\n        });\n      });\n\n      it('with custom validator', function(done) {\n        let called = false;\n\n        function validator(val) {\n          called = true;\n          return val && val.length > 1;\n        }\n\n        const validate = [validator, 'BAM'];\n\n        const schema = new Schema({\n          arr: { type: [], validate: validate }\n        });\n\n        const M = db.model('Test', schema);\n        const m = new M({ name: 'gh1109-2', arr: [1] });\n        assert.equal(called, false);\n        m.save(function(err) {\n          assert.equal(String(err), 'ValidationError: arr: BAM');\n          assert.equal(called, true);\n          m.arr.push(2);\n          called = false;\n          m.save(function(err) {\n            assert.equal(called, true);\n            assert.ifError(err);\n            done();\n          });\n        });\n      });\n\n      it('with both required + custom validator', function(done) {\n        function validator(val) {\n          return val && val.length > 1;\n        }\n\n        const validate = [validator, 'BAM'];\n\n        const schema = new Schema({\n          arr: { type: [], required: true, validate: validate }\n        });\n\n        const M = db.model('Test', schema);\n        const m = new M({ name: 'gh1109-3', arr: null });\n        m.save(function(err) {\n          assert.equal(err.errors.arr.message, 'Path `arr` is required.');\n          m.arr = [{ nice: true }];\n          m.save(function(err) {\n            assert.equal(String(err), 'ValidationError: arr: BAM');\n            m.arr.push(95);\n            m.save(function(err) {\n              assert.ifError(err);\n              done();\n            });\n          });\n        });\n      });\n    });\n\n    it('validator should run only once gh-1743', function(done) {\n      let count = 0;\n\n      const Control = new Schema({\n        test: {\n          type: String,\n          validate: function(value, done) {\n            count++;\n            return done(true);\n          }\n        }\n      });\n      const PostSchema = new Schema({\n        controls: [Control]\n      });\n\n      const Post = db.model('BlogPost', PostSchema);\n\n      const post = new Post({\n        controls: [{\n          test: 'xx'\n        }]\n      });\n\n      post.save(function() {\n        assert.equal(count, 1);\n        done();\n      });\n    });\n\n    it('validator should run only once per sub-doc gh-1743', async function() {\n      this.timeout(4500);\n\n      let count = 0;\n      const db = start();\n\n      const Control = new Schema({\n        test: {\n          type: String,\n          validate: function() {\n            count++;\n          }\n        }\n      });\n      const PostSchema = new Schema({\n        controls: [Control]\n      });\n\n      const Post = db.model('BlogPost', PostSchema);\n\n      const post = new Post({\n        controls: [\n          { test: 'xx' },\n          { test: 'yy' }\n        ]\n      });\n\n      await post.save();\n\n      assert.equal(count, post.controls.length);\n      await db.close();\n    });\n  });\n\n  it('#invalidate', function(done) {\n    let InvalidateSchema = null;\n    let Post = null;\n    let post = null;\n\n    InvalidateSchema = new Schema({ prop: { type: String } },\n      { strict: false });\n\n    Post = db.model('Test', InvalidateSchema);\n    post = new Post();\n    post.set({ baz: 'val' });\n    const _err = post.invalidate('baz', 'validation failed for path {PATH}',\n      'val', 'custom error');\n    assert.ok(_err instanceof ValidationError);\n\n    post.save(function(err) {\n      assert.ok(err instanceof MongooseError);\n      assert.ok(err instanceof ValidationError);\n      assert.ok(err.errors.baz instanceof ValidatorError);\n      assert.equal(err.errors.baz.message, 'validation failed for path baz');\n      assert.equal(err.errors.baz.path, 'baz');\n      assert.equal(err.errors.baz.value, 'val');\n      assert.equal(err.errors.baz.kind, 'custom error');\n\n      post.save(function(err) {\n        assert.strictEqual(err, null);\n        done();\n      });\n    });\n  });\n\n  describe('#equals', function() {\n    describe('should work', function() {\n      let S;\n      let N;\n      let O;\n      let B;\n      let M;\n\n      before(function() {\n        db.deleteModel(/^Test/);\n        S = db.model('Test', new Schema({ _id: String }));\n        N = db.model('Test2', new Schema({ _id: Number }));\n        O = db.model('Test3', new Schema({ _id: Schema.ObjectId }));\n        B = db.model('Test4', new Schema({ _id: Buffer }));\n        M = db.model('Test5', new Schema({ name: String }, { _id: false }));\n      });\n\n      it('with string _ids', function() {\n        const s1 = new S({ _id: 'one' });\n        const s2 = new S({ _id: 'one' });\n        assert.ok(s1.equals(s2));\n      });\n      it('with number _ids', function() {\n        const n1 = new N({ _id: 0 });\n        const n2 = new N({ _id: 0 });\n        assert.ok(n1.equals(n2));\n      });\n      it('with ObjectId _ids', function() {\n        let id = new mongoose.Types.ObjectId();\n        let o1 = new O({ _id: id });\n        let o2 = new O({ _id: id });\n        assert.ok(o1.equals(o2));\n\n        id = String(new mongoose.Types.ObjectId());\n        o1 = new O({ _id: id });\n        o2 = new O({ _id: id });\n        assert.ok(o1.equals(o2));\n      });\n      it('with Buffer _ids', function() {\n        const n1 = new B({ _id: 0 });\n        const n2 = new B({ _id: 0 });\n        assert.ok(n1.equals(n2));\n      });\n      it('with _id disabled (gh-1687)', function() {\n        const m1 = new M();\n        const m2 = new M();\n        assert.doesNotThrow(function() {\n          m1.equals(m2);\n        });\n      });\n    });\n  });\n\n  describe('setter', function() {\n    describe('order', function() {\n      it('is applied correctly', function() {\n        const date = 'Thu Aug 16 2012 09:45:59 GMT-0700';\n        const d = new TestDocument();\n        dateSetterCalled = false;\n        d.date = date;\n        assert.ok(dateSetterCalled);\n        dateSetterCalled = false;\n        assert.ok(d._doc.date instanceof Date);\n        assert.ok(d.date instanceof Date);\n        assert.equal(+d.date, +new Date(date));\n      });\n    });\n\n    it('works with undefined (gh-1892)', function(done) {\n      const d = new TestDocument();\n      d.nested.setr = undefined;\n      assert.equal(d.nested.setr, 'undefined setter');\n      dateSetterCalled = false;\n      d.date = undefined;\n      d.validate(function(err) {\n        assert.ifError(err);\n        assert.ok(dateSetterCalled);\n        done();\n      });\n    });\n\n    it('passes priorVal (gh-8629)', function() {\n      const names = [];\n      const profiles = [];\n      const Model = db.model('Test', Schema({\n        name: {\n          type: String,\n          set: (v, priorVal) => {\n            names.push(priorVal);\n            return v;\n          }\n        },\n        profile: {\n          type: Schema({ age: Number }, { _id: false }),\n          set: (v, priorVal) => {\n            profiles.push(priorVal == null ? priorVal : priorVal.toObject());\n            return v;\n          }\n        }\n      }));\n      const doc = new Model({ name: 'test', profile: { age: 29 } });\n      assert.deepEqual(names, [null]);\n      assert.deepEqual(profiles, [null]);\n\n      doc.name = 'test2';\n      doc.profile = { age: 30 };\n      assert.deepEqual(names, [null, 'test']);\n      assert.deepEqual(profiles, [null, { age: 29 }]);\n    });\n\n    describe('on nested paths', function() {\n      describe('using set(path, object)', function() {\n        it('overwrites the entire object', function() {\n          const doc = new TestDocument();\n\n          doc.init({\n            test: 'Test',\n            nested: {\n              age: 5\n            }\n          });\n\n          doc.set('nested', { path: 'overwrite the entire nested object' });\n          assert.equal(doc.nested.age, undefined);\n          assert.equal(Object.keys(doc._doc.nested).length, 1);\n          assert.equal(doc.nested.path, 'overwrite the entire nested object');\n          assert.ok(doc.isModified('nested'));\n        });\n\n        it('allows positional syntax on mixed nested paths (gh-6738)', function() {\n          const schema = new Schema({ nested: {} });\n          const M = db.model('Test', schema);\n          const doc = new M({\n            'nested.x': 'foo',\n            'nested.y': 42,\n            'nested.a.b.c': { d: { e: { f: 'g' } } }\n          });\n          assert.strictEqual(doc.nested.x, 'foo');\n          assert.strictEqual(doc.nested.y, 42);\n          assert.strictEqual(doc.nested.a.b.c.d.e.f, 'g');\n        });\n\n        it('gh-1954', function() {\n          const schema = new Schema({\n            schedule: [new Schema({ open: Number, close: Number })]\n          });\n\n          const M = db.model('BlogPost', schema);\n\n          const doc = new M({\n            schedule: [{\n              open: 1000,\n              close: 1900\n            }]\n          });\n\n          assert.ok(doc.schedule[0] instanceof ArraySubdocument);\n          doc.set('schedule.0.open', 1100);\n          assert.ok(doc.schedule);\n          assert.ok(doc.schedule.isMongooseDocumentArray);\n          assert.ok(doc.schedule[0] instanceof ArraySubdocument);\n          assert.equal(doc.schedule[0].open, 1100);\n          assert.equal(doc.schedule[0].close, 1900);\n        });\n      });\n\n      describe('when overwriting with a document instance', function() {\n        it('does not cause StackOverflows (gh-1234)', function() {\n          const doc = new TestDocument({ nested: { age: 35 } });\n          doc.nested = doc.nested;\n          assert.doesNotThrow(function() {\n            doc.nested.age;\n          });\n        });\n      });\n    });\n  });\n\n  describe('virtual', function() {\n    describe('setter', function() {\n      let val;\n      let M;\n\n      beforeEach(function() {\n        const schema = new mongoose.Schema({ v: Number });\n        schema.virtual('thang').set(function(v) {\n          val = v;\n        });\n\n        db.deleteModel(/Test/);\n        M = db.model('Test', schema);\n      });\n\n      it('works with objects', function() {\n        new M({ thang: {} });\n        assert.deepEqual({}, val);\n      });\n      it('works with arrays', function() {\n        new M({ thang: [] });\n        assert.deepEqual([], val);\n      });\n      it('works with numbers', function() {\n        new M({ thang: 4 });\n        assert.deepEqual(4, val);\n      });\n      it('works with strings', function() {\n        new M({ thang: '3' });\n        assert.deepEqual('3', val);\n      });\n    });\n\n    it('passes doc as third param for arrow functions (gh-4143)', function() {\n      const schema = new mongoose.Schema({\n        name: {\n          first: String,\n          last: String\n        }\n      });\n      schema.virtual('fullname').\n        get((v, virtual, doc) => `${doc.name.first} ${doc.name.last}`).\n        set((v, virtual, doc) => {\n          const parts = v.split(' ');\n          doc.name.last = parts[parts.length - 1];\n          doc.name.first = parts.slice(0, parts.length - 1).join(' ');\n        });\n      const Model = db.model('Person', schema);\n\n      const doc = new Model({ name: { first: 'Jean-Luc', last: 'Picard' } });\n      assert.equal(doc.fullname, 'Jean-Luc Picard');\n\n      doc.fullname = 'Will Riker';\n      assert.equal(doc.name.first, 'Will');\n      assert.equal(doc.name.last, 'Riker');\n    });\n  });\n\n  describe('gh-2082', function() {\n    it('works', async function() {\n      const Parent = db.model('Test', parentSchema);\n\n      const parent = new Parent({ name: 'Hello' });\n      await parent.save();\n\n      parent.children.push({ counter: 0 });\n      await parent.save();\n\n      parent.children[0].counter += 1;\n      await parent.save();\n\n      parent.children[0].counter += 1;\n      await parent.save();\n\n      await Parent.findOne({});\n\n      assert.equal(parent.children[0].counter, 2);\n    });\n  });\n\n  describe('gh-1933', function() {\n    it('works', async function() {\n      const M = db.model('Test', new Schema({ id: String, field: Number }));\n\n      const doc = await M.create({});\n\n      doc.__v = 123;\n      doc.field = 5;\n\n      // Does not throw\n      await doc.save();\n    });\n  });\n\n  describe('gh-1638', function() {\n    it('works', async function() {\n      const ItemChildSchema = new mongoose.Schema({\n        name: { type: String, required: true, default: 'hello' }\n      });\n\n      const ItemParentSchema = new mongoose.Schema({\n        children: [ItemChildSchema]\n      });\n\n      const ItemParent = db.model('Parent', ItemParentSchema);\n      const ItemChild = db.model('Child', ItemChildSchema);\n\n      const c1 = new ItemChild({ name: 'first child' });\n      const c2 = new ItemChild({ name: 'second child' });\n\n      const p = new ItemParent({\n        children: [c1, c2]\n      });\n\n      await p.save();\n\n      c2.name = 'updated 2';\n      p.children = [c2];\n      await p.save();\n\n      assert.equal(p.children.length, 1);\n    });\n  });\n\n  describe('gh-2434', function() {\n    it('will save the new value', async function() {\n      const ItemSchema = new mongoose.Schema({\n        st: Number,\n        s: []\n      });\n\n      const Item = db.model('Test', ItemSchema);\n\n      const item = new Item({ st: 1 });\n\n      await item.save();\n\n      item.st = 3;\n      item.s = [];\n      await item.save();\n\n      // item.st is 3 but may not be saved to DB\n      const doc = await Item.findById(item._id);\n      assert.equal(doc.st, 3);\n    });\n  });\n\n  describe('gh-8371', function() {\n    beforeEach(async() => {\n      const Person = db.model('Person', Schema({ name: String }));\n\n      await Person.deleteMany({});\n\n      db.deleteModel('Person');\n    });\n\n    it('setting isNew to true makes save tries to insert a new document (gh-8371)', async function() {\n      const personSchema = new Schema({ name: String });\n      const Person = db.model('Person', personSchema);\n\n      const createdPerson = await Person.create({ name: 'Hafez' });\n      const removedPerson = await Person.findOneAndRemove({ _id: createdPerson._id });\n\n      removedPerson.isNew = true;\n\n      await removedPerson.save();\n\n      const foundPerson = await Person.findOne({ _id: removedPerson._id });\n      assert.ok(foundPerson);\n    });\n\n    it('setting isNew to true throws an error when a document already exists (gh-8371)', async function() {\n\n      const personSchema = new Schema({ name: String });\n      const Person = db.model('Person', personSchema);\n\n      const createdPerson = await Person.create({ name: 'Hafez' });\n\n      createdPerson.isNew = true;\n\n      let threw = false;\n      try {\n        await createdPerson.save();\n      }\n      catch (err) {\n        threw = true;\n        assert.equal(err.code, 11000);\n      }\n\n      assert.equal(threw, true);\n    });\n\n    it('saving a document with no changes, throws an error when document is not found', async function() {\n      const personSchema = new Schema({ name: String });\n      const Person = db.model('Person', personSchema);\n\n      const person = await Person.create({ name: 'Hafez' });\n\n      await Person.deleteOne({ _id: person._id });\n\n      const err = await person.save().then(() => null, err => err);\n      assert.equal(err instanceof DocumentNotFoundError, true);\n      assert.equal(err.message, `No document found for query \"{ _id: new ObjectId(\"${person._id}\") }\" on model \"Person\"`);\n    });\n\n    it('saving a document when version bump required, throws a VersionError when document is not found (gh-10974)', async function() {\n      const personSchema = new Schema({ tags: [String] });\n      const Person = db.model('Person', personSchema);\n\n      const person = await Person.create({ tags: ['tag1', 'tag2'] });\n\n      await Person.deleteOne({ _id: person._id });\n\n      person.tags.splice(0, 1);\n\n      const err = await person.save().then(() => null, err => err);\n      assert.ok(err instanceof VersionError);\n      assert.equal(err.message, `No matching document found for id \"${person._id}\" version 0 modifiedPaths \"tags\"`);\n    });\n\n    it('saving a document with changes, throws an error when document is not found', async function() {\n\n      const personSchema = new Schema({ name: String });\n      const Person = db.model('Person', personSchema);\n\n      const person = await Person.create({ name: 'Hafez' });\n\n      await Person.deleteOne({ _id: person._id });\n\n      person.name = 'Different Name';\n\n      let threw = false;\n      try {\n        await person.save();\n      }\n      catch (err) {\n        assert.equal(err instanceof DocumentNotFoundError, true);\n        assert.equal(err.message, `No document found for query \"{ _id: new ObjectId(\"${person._id}\") }\" on model \"Person\"`);\n        threw = true;\n      }\n\n      assert.equal(threw, true);\n    });\n\n    it('passes save custom options to Model.exists(...) when no changes are present (gh-8739)', async function() {\n      const personSchema = new Schema({ name: String });\n\n      let optionInMiddleware;\n\n      personSchema.pre('findOne', function(next) {\n        optionInMiddleware = this.getOptions().customOption;\n\n        return next();\n      });\n\n      const Person = db.model('Person', personSchema);\n\n      const person = await Person.create({ name: 'Hafez' });\n      await person.save({ customOption: 'test' });\n\n      assert.equal(optionInMiddleware, 'test');\n    });\n  });\n\n  it('properly calls queue functions (gh-2856)', function() {\n    const personSchema = new mongoose.Schema({\n      name: String\n    });\n\n    let calledName;\n    personSchema.methods.fn = function() {\n      calledName = this.name;\n    };\n    personSchema.queue('fn');\n\n    const Person = db.model('Person', personSchema);\n    new Person({ name: 'Val' });\n    assert.equal(calledName, 'Val');\n  });\n\n  describe('bug fixes', function() {\n    it('applies toJSON transform correctly for populated docs (gh-2910) (gh-2990)', async function() {\n      const parentSchema = mongoose.Schema({\n        c: { type: mongoose.Schema.Types.ObjectId, ref: 'Child' }\n      });\n\n      let called = [];\n      parentSchema.options.toJSON = {\n        transform: function(doc, ret) {\n          called.push(ret);\n          return ret;\n        }\n      };\n\n      const childSchema = mongoose.Schema({\n        name: String\n      });\n\n      let childCalled = [];\n      childSchema.options.toJSON = {\n        transform: function(doc, ret) {\n          childCalled.push(ret);\n          return ret;\n        }\n      };\n\n      const Child = db.model('Child', childSchema);\n      const Parent = db.model('Parent', parentSchema);\n\n      const c = await Child.create({ name: 'test' });\n\n      const createdParent = await Parent.create({ c: c._id });\n\n      const p = await Parent.findOne({ _id: createdParent._id }).populate('c').exec();\n\n      let doc = p.toJSON();\n      assert.equal(called.length, 1);\n      assert.equal(called[0]._id.toString(), p._id.toString());\n      assert.equal(doc._id.toString(), p._id.toString());\n      assert.equal(childCalled.length, 1);\n      assert.equal(childCalled[0]._id.toString(), c._id.toString());\n\n      called = [];\n      childCalled = [];\n\n      // JSON.stringify() passes field name, so make sure we don't treat\n      // that as a param to toJSON (gh-2990)\n      doc = JSON.parse(JSON.stringify({ parent: p })).parent;\n      assert.equal(called.length, 1);\n      assert.equal(called[0]._id.toString(), p._id.toString());\n      assert.equal(doc._id.toString(), p._id.toString());\n      assert.equal(childCalled.length, 1);\n      assert.equal(childCalled[0]._id.toString(), c._id.toString());\n    });\n\n    it('single nested schema transform with save() (gh-5807)', function() {\n      const embeddedSchema = new Schema({\n        test: String\n      });\n\n      let called = false;\n      embeddedSchema.options.toObject = {\n        transform: function(doc, ret) {\n          called = true;\n          delete ret.test;\n          return ret;\n        }\n      };\n      const topLevelSchema = new Schema({\n        embedded: embeddedSchema\n      });\n      const MyModel = db.model('Test', topLevelSchema);\n\n      return MyModel.create({}).\n        then(function(doc) {\n          doc.embedded = { test: '123' };\n          return doc.save();\n        }).\n        then(function(doc) {\n          return MyModel.findById(doc._id);\n        }).\n        then(function(doc) {\n          assert.equal(doc.embedded.test, '123');\n          assert.ok(!called);\n        });\n    });\n\n    it('setters firing with objects on real paths (gh-2943)', function() {\n      const M = db.model('Test', {\n        myStr: {\n          type: String, set: function(v) {\n            return v.value;\n          }\n        },\n        otherStr: String\n      });\n\n      const t = new M({ myStr: { value: 'test' } });\n      assert.equal(t.myStr, 'test');\n\n      new M({ otherStr: { value: 'test' } });\n      assert.ok(!t.otherStr);\n    });\n\n    describe('gh-2782', function() {\n      it('should set data from a sub doc', function() {\n        const schema1 = new mongoose.Schema({\n          data: {\n            email: String\n          }\n        });\n        const schema2 = new mongoose.Schema({\n          email: String\n        });\n        const Model1 = db.model('Test', schema1);\n        const Model2 = db.model('Test1', schema2);\n\n        const doc1 = new Model1({ 'data.email': 'some@example.com' });\n        assert.equal(doc1.data.email, 'some@example.com');\n        const doc2 = new Model2();\n        doc2.set(doc1.data);\n        assert.equal(doc2.email, 'some@example.com');\n      });\n    });\n\n    it('set data from subdoc keys (gh-3346)', function() {\n      const schema1 = new mongoose.Schema({\n        data: {\n          email: String\n        }\n      });\n      const Model1 = db.model('Test', schema1);\n\n      const doc1 = new Model1({ 'data.email': 'some@example.com' });\n      assert.equal(doc1.data.email, 'some@example.com');\n      const doc2 = new Model1({ data: doc1.data });\n      assert.equal(doc2.data.email, 'some@example.com');\n    });\n\n    it('doesnt attempt to cast generic objects as strings (gh-3030)', function(done) {\n      const M = db.model('Test', {\n        myStr: {\n          type: String\n        }\n      });\n\n      const t = new M({ myStr: { thisIs: 'anObject' } });\n      assert.ok(!t.myStr);\n      t.validate(function(error) {\n        assert.ok(error);\n        done();\n      });\n    });\n\n    it('single embedded schemas 1 (gh-2689)', function(done) {\n      const userSchema = new mongoose.Schema({\n        name: String,\n        email: String\n      }, { _id: false, id: false });\n\n      let userHookCount = 0;\n      userSchema.pre('save', function(next) {\n        ++userHookCount;\n        next();\n      });\n\n      const eventSchema = new mongoose.Schema({\n        user: userSchema,\n        name: String\n      });\n\n      let eventHookCount = 0;\n      eventSchema.pre('save', function(next) {\n        ++eventHookCount;\n        next();\n      });\n\n      const Event = db.model('Event', eventSchema);\n\n      const e = new Event({ name: 'test', user: { name: 123, email: 'val' } });\n      e.save(function(error) {\n        assert.ifError(error);\n        assert.strictEqual(e.user.name, '123');\n        assert.equal(eventHookCount, 1);\n        assert.equal(userHookCount, 1);\n\n        Event.findOne({ user: { name: '123', email: 'val' } }, function(err, doc) {\n          assert.ifError(err);\n          assert.ok(doc);\n\n          Event.findOne({ user: { $in: [{ name: '123', email: 'val' }] } }, function(err, doc) {\n            assert.ifError(err);\n            assert.ok(doc);\n            done();\n          });\n        });\n      });\n    });\n\n    it('single embedded schemas with validation (gh-2689)', function() {\n      const userSchema = new mongoose.Schema({\n        name: String,\n        email: { type: String, required: true, match: /.+@.+/ }\n      }, { _id: false, id: false });\n\n      const eventSchema = new mongoose.Schema({\n        user: userSchema,\n        name: String\n      });\n\n      const Event = db.model('Event', eventSchema);\n\n      const e = new Event({ name: 'test', user: {} });\n      let error = e.validateSync();\n      assert.ok(error);\n      assert.ok(error.errors['user.email']);\n      assert.equal(error.errors['user.email'].kind, 'required');\n\n      e.user.email = 'val';\n      error = e.validateSync();\n\n      assert.ok(error);\n      assert.ok(error.errors['user.email']);\n      assert.equal(error.errors['user.email'].kind, 'regexp');\n    });\n\n    it('single embedded parent() (gh-5134)', function() {\n      const userSchema = new mongoose.Schema({\n        name: String,\n        email: { type: String, required: true, match: /.+@.+/ }\n      }, { _id: false, id: false });\n\n      const eventSchema = new mongoose.Schema({\n        user: userSchema,\n        name: String\n      });\n\n      const Event = db.model('Event', eventSchema);\n\n      const e = new Event({ name: 'test', user: {} });\n      assert.strictEqual(e.user.parent(), e.user.ownerDocument());\n    });\n\n    it('single embedded schemas with markmodified (gh-2689)', async function() {\n      const userSchema = new mongoose.Schema({\n        name: String,\n        email: { type: String, required: true, match: /.+@.+/ }\n      }, { _id: false, id: false });\n\n      const eventSchema = new mongoose.Schema({\n        user: userSchema,\n        name: String\n      });\n\n      const Event = db.model('Event', eventSchema);\n\n      const e = new Event({ name: 'test', user: { email: 'a@b' } });\n      const doc = await e.save();\n\n      assert.ok(doc);\n      assert.ok(!doc.isModified('user'));\n      assert.ok(!doc.isModified('user.email'));\n      assert.ok(!doc.isModified('user.name'));\n      doc.user.name = 'Val';\n      assert.ok(doc.isModified('user'));\n      assert.ok(!doc.isModified('user.email'));\n      assert.ok(doc.isModified('user.name'));\n\n      const delta = doc.$__delta()[1];\n      assert.deepEqual(delta, {\n        $set: { 'user.name': 'Val' }\n      });\n\n      await doc.save();\n\n      const event = await Event.findOne({ _id: doc._id });\n\n      assert.deepEqual(event.user.toObject(), { email: 'a@b', name: 'Val' });\n    });\n\n    it('single embedded schemas + update validators (gh-2689)', async function() {\n      const userSchema = new mongoose.Schema({\n        name: { type: String, default: 'Val' },\n        email: { type: String, required: true, match: /.+@.+/ }\n      }, { _id: false, id: false });\n\n      const eventSchema = new mongoose.Schema({\n        user: userSchema,\n        name: String\n      });\n\n      const Event = db.model('Event', eventSchema);\n\n      const badUpdate = { $set: { 'user.email': 'a' } };\n      const options = { runValidators: true };\n\n      const error = await Event.updateOne({}, badUpdate, options).then(() => null, err => err);\n\n      assert.ok(error);\n      assert.equal(error.errors['user.email'].kind, 'regexp');\n\n      const nestedUpdate = { name: 'test', user: {} };\n\n      // Does not throw\n      await Event.updateOne({}, nestedUpdate, { upsert: true });\n\n      const ev = await Event.findOne({ name: 'test' });\n\n      assert.equal(ev.user.name, 'Val');\n    });\n\n    it('single embedded schema update validators ignore _id (gh-6269)', async function() {\n\n      const subDocSchema = new mongoose.Schema({ name: String });\n\n      const schema = new mongoose.Schema({\n        subDoc: subDocSchema,\n        test: String\n      });\n\n      const Model = db.model('Test', schema);\n\n      const fakeDoc = new Model({});\n      await Model.create({});\n\n      const res = await Model.findOneAndUpdate(\n        { _id: fakeDoc._id },\n        { test: 'test' },\n        { upsert: true, new: true }\n      );\n\n      assert.equal(res.test, 'test');\n      assert.ok(!res.subDoc);\n    });\n  });\n\n  describe('error processing (gh-2284)', async function() {\n    it('save errors', async function() {\n      const schema = new Schema({\n        name: { type: String, required: true }\n      });\n\n      schema.post('save', function(error, doc, next) {\n        assert.ok(doc instanceof Model);\n        next(new Error('Catch all'));\n      });\n\n      schema.post('save', function(error, doc, next) {\n        assert.ok(doc instanceof Model);\n        next(new Error('Catch all #2'));\n      });\n\n      const Model = db.model('Test', schema);\n\n      const error = await Model.create({}).then(() => null, err => err);\n\n      assert.ok(error);\n      assert.equal(error.message, 'Catch all #2');\n    });\n\n    it('validate errors (gh-4885)', async function() {\n      const testSchema = new Schema({ title: { type: String, required: true } });\n\n      let called = 0;\n      testSchema.post('validate', function(error, doc, next) {\n        ++called;\n        next(error);\n      });\n\n      const Test = db.model('Test', testSchema);\n\n      const error = await Test.create({}).then(() => null, err => err);\n\n      assert.ok(error);\n      assert.equal(called, 1);\n    });\n\n    it('does not filter validation on unmodified paths when validateModifiedOnly not set (gh-7421)', async function() {\n      const testSchema = new Schema({ title: { type: String, required: true }, other: String });\n\n      const Test = db.model('Test', testSchema);\n\n      const docs = await Test.create([{}], { validateBeforeSave: false });\n\n      const doc = docs[0];\n      doc.other = 'something';\n      assert.ok(doc.validateSync().errors);\n      const error = await doc.save().then(() => null, err => err);\n      assert.ok(error.errors);\n    });\n\n    it('filters out validation on unmodified paths when validateModifiedOnly set (gh-7421) (gh-9963)', async function() {\n      const testSchema = new Schema({\n        title: { type: String, required: true },\n        other: String,\n        subdocs: [{ name: { type: String, required: true } }]\n      });\n\n      const Test = db.model('Test', testSchema);\n\n      const docs = await Test.create(\n        [{ subdocs: [{ name: null }, { name: 'test' }] }],\n        { validateBeforeSave: false }\n      );\n\n      const doc = docs[0];\n      doc.other = 'something';\n      doc.subdocs[1].name = 'test2';\n      assert.equal(doc.validateSync({ validateModifiedOnly: true }), null);\n      assert.equal(doc.validateSync('other'), null);\n      assert.ok(doc.validateSync('other title').errors['title']);\n\n      // Does not throw\n      await doc.save({ validateModifiedOnly: true });\n    });\n\n    it('does not filter validation on modified paths when validateModifiedOnly set (gh-7421)', async function() {\n      const testSchema = new Schema({ title: { type: String, required: true }, other: String });\n\n      const Test = db.model('Test', testSchema);\n\n      const docs = await Test.create([{ title: 'title' }], { validateBeforeSave: false });\n\n      const doc = docs[0];\n      doc.title = '';\n      assert.ok(doc.validateSync({ validateModifiedOnly: true }).errors);\n      const error = await doc.save({ validateModifiedOnly: true }).then(() => null, err => err);\n\n      assert.ok(error.errors);\n    });\n\n    it('validateModifiedOnly with pre existing validation error (gh-8091)', async function() {\n      const schema = mongoose.Schema({\n        title: String,\n        coverId: Number\n      }, { validateModifiedOnly: true });\n\n      const Model = db.model('Test', schema);\n\n\n      await Model.collection.insertOne({ title: 'foo', coverId: parseFloat('not a number') });\n\n      const doc = await Model.findOne();\n      doc.title = 'bar';\n      // Should not throw\n      await doc.save();\n    });\n\n    it('handles non-errors', async function() {\n      const schema = new Schema({\n        name: { type: String, required: true }\n      });\n\n      schema.post('save', function(error, doc, next) {\n        next(new Error('Catch all'));\n      });\n\n      schema.post('save', function(error, doc, next) {\n        next(new Error('Catch all #2'));\n      });\n\n      const Model = db.model('Test', schema);\n\n      // Does not throw\n      await Model.create({ name: 'test' });\n    });\n  });\n\n  describe('bug fixes', function() {\n    beforeEach(() => db.deleteModel(/.*/));\n\n    it('single embedded schemas with populate (gh-3501)', async function() {\n      const PopulateMeSchema = new Schema({});\n\n      const Child = db.model('Child', PopulateMeSchema);\n\n      const SingleNestedSchema = new Schema({\n        populateMeArray: [{\n          type: Schema.Types.ObjectId,\n          ref: 'Child'\n        }]\n      });\n\n      const parentSchema = new Schema({\n        singleNested: SingleNestedSchema\n      });\n\n      const P = db.model('Parent', parentSchema);\n\n      const docs = await Child.create([{}, {}]);\n\n      const obj = {\n        singleNested: { populateMeArray: [docs[0]._id, docs[1]._id] }\n      };\n      const doc = await P.create(obj);\n\n      const foundDoc = await P.\n        findById(doc._id).\n        populate('singleNested.populateMeArray').\n        exec();\n\n      assert.ok(foundDoc.singleNested.populateMeArray[0]._id);\n    });\n\n    it('single embedded schemas with methods (gh-3534)', function() {\n      const personSchema = new Schema({ name: String });\n      personSchema.methods.firstName = function() {\n        return this.name.substring(0, this.name.indexOf(' '));\n      };\n\n      const bandSchema = new Schema({ leadSinger: personSchema });\n      const Band = db.model('Band', bandSchema);\n\n      const gnr = new Band({ leadSinger: { name: 'Axl Rose' } });\n      assert.equal(gnr.leadSinger.firstName(), 'Axl');\n    });\n\n    it('single embedded schemas with models (gh-3535)', function(done) {\n      const personSchema = new Schema({ name: String });\n      const Person = db.model('Person', personSchema);\n\n      const bandSchema = new Schema({ leadSinger: personSchema });\n      const Band = db.model('Band', bandSchema);\n\n      const axl = new Person({ name: 'Axl Rose' });\n      const gnr = new Band({ leadSinger: axl });\n\n      gnr.save(function(error) {\n        assert.ifError(error);\n        assert.equal(gnr.leadSinger.name, 'Axl Rose');\n        done();\n      });\n    });\n\n    it('single embedded schemas with indexes (gh-3594)', function() {\n      const personSchema = new Schema({ name: { type: String, unique: true } });\n\n      const bandSchema = new Schema({ leadSinger: personSchema });\n\n      assert.equal(bandSchema.indexes().length, 1);\n      const index = bandSchema.indexes()[0];\n      assert.deepEqual(index[0], { 'leadSinger.name': 1 });\n      assert.ok(index[1].unique);\n    });\n\n    it('removing single embedded docs (gh-3596)', async function() {\n      const personSchema = new Schema({ name: String });\n\n      const bandSchema = new Schema({ guitarist: personSchema, name: String });\n      const Band = db.model('Band', bandSchema);\n\n      const gnr = new Band({\n        name: 'Guns N\\' Roses',\n        guitarist: { name: 'Slash' }\n      });\n\n      await gnr.save();\n\n      gnr.guitarist = undefined;\n      await gnr.save();\n\n      assert.ok(!gnr.guitarist);\n    });\n\n    it('setting single embedded docs (gh-3601)', async function() {\n      const personSchema = new Schema({ name: String });\n\n      const bandSchema = new Schema({ guitarist: personSchema, name: String });\n      const Band = db.model('Band', bandSchema);\n\n      const gnr = new Band({\n        name: 'Guns N\\' Roses',\n        guitarist: { name: 'Slash' }\n      });\n      const velvetRevolver = new Band({\n        name: 'Velvet Revolver'\n      });\n      velvetRevolver.guitarist = gnr.guitarist;\n      await velvetRevolver.save();\n\n      assert.equal(velvetRevolver.guitarist.name, 'Slash');\n    });\n\n    it('single embedded docs init obeys strict mode (gh-3642)', async function() {\n      const personSchema = new Schema({ name: String });\n\n      const bandSchema = new Schema({ guitarist: personSchema, name: String });\n      const Band = db.model('Band', bandSchema);\n\n      const velvetRevolver = new Band({\n        name: 'Velvet Revolver',\n        guitarist: { name: 'Slash', realName: 'Saul Hudson' }\n      });\n\n      await velvetRevolver.save();\n\n      const query = { name: 'Velvet Revolver' };\n      const band = await Band.collection.findOne(query);\n\n      assert.ok(!band.guitarist.realName);\n    });\n\n    it('single embedded docs post hooks (gh-3679)', async function() {\n      const postHookCalls = [];\n      const personSchema = new Schema({ name: String });\n      personSchema.post('save', function() {\n        postHookCalls.push(this);\n      });\n\n      const bandSchema = new Schema({ guitarist: personSchema, name: String });\n      const Band = db.model('Band', bandSchema);\n      const obj = { name: 'Guns N\\' Roses', guitarist: { name: 'Slash' } };\n\n      await Band.create(obj);\n      await new Promise((resolve) => {\n        setTimeout(function() {\n          assert.equal(postHookCalls.length, 1);\n          assert.equal(postHookCalls[0].name, 'Slash');\n          resolve();\n        });\n      });\n\n    });\n\n    it('single embedded docs .set() (gh-3686)', async function() {\n      const personSchema = new Schema({ name: String, realName: String });\n\n      const bandSchema = new Schema({\n        guitarist: personSchema,\n        name: String\n      });\n      const Band = db.model('Band', bandSchema);\n      const obj = {\n        name: 'Guns N\\' Roses',\n        guitarist: { name: 'Slash', realName: 'Saul Hudson' }\n      };\n\n      const gnr = await Band.create(obj);\n\n      gnr.set('guitarist.name', 'Buckethead');\n      await gnr.save();\n\n      assert.equal(gnr.guitarist.name, 'Buckethead');\n      assert.equal(gnr.guitarist.realName, 'Saul Hudson');\n    });\n\n    it('single embedded docs with arrays pre hooks (gh-3680)', async function() {\n      const childSchema = new Schema({ count: Number });\n\n      let preCalls = 0;\n      childSchema.pre('save', function(next) {\n        ++preCalls;\n        next();\n      });\n\n      const SingleNestedSchema = new Schema({\n        children: [childSchema]\n      });\n\n      const ParentSchema = new Schema({\n        singleNested: SingleNestedSchema\n      });\n\n      const Parent = db.model('Parent', ParentSchema);\n      const obj = { singleNested: { children: [{ count: 0 }] } };\n      await Parent.create(obj);\n\n      assert.equal(preCalls, 1);\n    });\n\n    it('nested single embedded doc validation (gh-3702)', function(done) {\n      const childChildSchema = new Schema({ count: { type: Number, min: 1 } });\n      const childSchema = new Schema({ child: childChildSchema });\n      const parentSchema = new Schema({ child: childSchema });\n\n      const Parent = db.model('Parent', parentSchema);\n      const obj = { child: { child: { count: 0 } } };\n      Parent.create(obj, function(error) {\n        assert.ok(error);\n        assert.ok(/ValidationError/.test(error.toString()));\n        done();\n      });\n    });\n\n    it('handles virtuals with dots correctly (gh-3618)', function() {\n      const testSchema = new Schema({ nested: { type: Object, default: {} } });\n      testSchema.virtual('nested.test').get(function() {\n        return true;\n      });\n\n      const Test = db.model('Test', testSchema);\n\n      const test = new Test();\n\n      let doc = test.toObject({ getters: true, virtuals: true });\n      delete doc._id;\n      delete doc.id;\n      assert.deepEqual(doc, { nested: { test: true } });\n\n      doc = test.toObject({ getters: false, virtuals: true });\n      delete doc._id;\n      delete doc.id;\n      assert.deepEqual(doc, { nested: { test: true } });\n    });\n\n    it('handles pushing with numeric keys (gh-3623)', async function() {\n      const schema = new Schema({\n        array: [{\n          1: {\n            date: Date\n          },\n          2: {\n            date: Date\n          },\n          3: {\n            date: Date\n          }\n        }]\n      });\n\n      const MyModel = db.model('Test', schema);\n\n      const doc = { array: [{ 2: {} }] };\n      await MyModel.collection.insertOne(doc);\n\n      const foundDoc = await MyModel.findOne({ _id: doc._id });\n\n      foundDoc.array.push({ 2: {} });\n      await foundDoc.save();\n    });\n\n    it('handles 0 for numeric subdoc ids (gh-3776)', async function() {\n      const personSchema = new Schema({\n        _id: Number,\n        name: String,\n        age: Number,\n        friends: [{ type: Number, ref: 'Person' }]\n      });\n\n      const Person = db.model('Person', personSchema);\n\n\n      const people = await Person.create([\n        { _id: 0, name: 'Alice' },\n        { _id: 1, name: 'Bob' }\n      ]);\n\n      const alice = people[0];\n      alice.friends.push(people[1]);\n\n      // Should not throw\n      await alice.save();\n    });\n\n    it('handles conflicting names (gh-3867)', function() {\n      const testSchema = new Schema({\n        name: {\n          type: String,\n          required: true\n        },\n        things: [{\n          name: {\n            type: String,\n            required: true\n          }\n        }]\n      });\n\n      const M = db.model('Test', testSchema);\n\n      const doc = M({\n        things: [{}]\n      });\n\n      const fields = Object.keys(doc.validateSync().errors).sort();\n      assert.deepEqual(fields, ['name', 'things.0.name']);\n    });\n\n    it('populate with lean (gh-3873)', async function() {\n      const companySchema = new mongoose.Schema({\n        name: String,\n        description: String,\n        userCnt: { type: Number, default: 0, select: false }\n      });\n\n      const userSchema = new mongoose.Schema({\n        name: String,\n        company: { type: mongoose.Schema.Types.ObjectId, ref: 'Company' }\n      });\n\n      const Company = db.model('Company', companySchema);\n      const User = db.model('User', userSchema);\n\n      const company = new Company({ name: 'IniTech', userCnt: 1 });\n      const user = new User({ name: 'Peter', company: company._id });\n\n      await company.save();\n\n      await user.save();\n\n      const pop = { path: 'company', select: 'name', options: { lean: true } };\n      const docs = await User.find({}).populate(pop).exec();\n\n      assert.equal(docs.length, 1);\n      assert.strictEqual(docs[0].company.userCnt, undefined);\n    });\n\n    it('init single nested subdoc with select (gh-3880)', async function() {\n      const childSchema = new mongoose.Schema({\n        name: { type: String },\n        friends: [{ type: String }]\n      });\n\n      const parentSchema = new mongoose.Schema({\n        name: { type: String },\n        child: childSchema\n      });\n\n      const Parent = db.model('Parent', parentSchema);\n      const p = new Parent({\n        name: 'Mufasa',\n        child: {\n          name: 'Simba',\n          friends: ['Pumbaa', 'Timon', 'Nala']\n        }\n      });\n\n      await p.save();\n\n      const fields = 'name child.name';\n      const doc = await Parent.findById(p._id).select(fields).exec();\n\n      assert.strictEqual(doc.child.friends, void 0);\n    });\n\n    it('single nested subdoc isModified() (gh-3910)', async function() {\n      let called = 0;\n\n      const ChildSchema = new Schema({\n        name: String\n      });\n\n      ChildSchema.pre('save', function(next) {\n        assert.ok(this.isModified('name'));\n        ++called;\n        next();\n      });\n\n      const ParentSchema = new Schema({\n        name: String,\n        child: ChildSchema\n      });\n\n      const Parent = db.model('Parent', ParentSchema);\n\n      const p = new Parent({\n        name: 'Darth Vader',\n        child: {\n          name: 'Luke Skywalker'\n        }\n      });\n\n      await p.save();\n\n      assert.strictEqual(called, 1);\n    });\n\n    it('pre and post as schema keys (gh-3902)', async function() {\n      const schema = new mongoose.Schema({\n        pre: String,\n        post: String\n      }, { versionKey: false });\n\n      const MyModel = db.model('Test', schema);\n\n      const doc = await MyModel.create({ pre: 'test', post: 'test' });\n\n      assert.deepEqual(\n        utils.omit(doc.toObject(), '_id'),\n        { pre: 'test', post: 'test' }\n      );\n    });\n\n    it('manual population and isNew (gh-3982)', async function() {\n      const NestedModelSchema = new mongoose.Schema({\n        field: String\n      });\n\n      const NestedModel = db.model('Test', NestedModelSchema);\n\n      const ModelSchema = new mongoose.Schema({\n        field: String,\n        array: [{\n          type: mongoose.Schema.ObjectId,\n          ref: 'Test',\n          required: true\n        }]\n      });\n\n      const Model = db.model('Test1', ModelSchema);\n\n      const nestedModel = new NestedModel({\n        field: 'nestedModel'\n      });\n\n      await nestedModel.save();\n\n      const doc = await Model.create({ array: [nestedModel._id] });\n\n      const foundDoc = await Model.findById(doc._id).populate('array').exec();\n\n      foundDoc.array.push(nestedModel);\n      assert.strictEqual(foundDoc.isNew, false);\n      assert.strictEqual(foundDoc.array[0].isNew, false);\n      assert.strictEqual(foundDoc.array[1].isNew, false);\n      assert.strictEqual(nestedModel.isNew, false);\n    });\n\n    it('manual population with refPath (gh-7070)', async function() {\n      const ChildModelSchema = new mongoose.Schema({\n        name: String\n      });\n\n      const ChildModel = db.model('Child', ChildModelSchema);\n\n      const ParentModelSchema = new mongoose.Schema({\n        model: String,\n        childId: { type: mongoose.ObjectId, refPath: 'model' },\n        otherId: mongoose.ObjectId\n      });\n\n      const ParentModel = db.model('Parent', ParentModelSchema);\n\n\n      const child = await ChildModel.create({ name: 'test' });\n\n      let parent = await ParentModel.create({\n        model: 'Child',\n        childId: child._id\n      });\n\n      parent = await ParentModel.findOne();\n\n      parent.childId = child;\n      parent.otherId = child;\n\n      assert.equal(parent.childId.name, 'test');\n      assert.ok(parent.otherId instanceof mongoose.Types.ObjectId);\n    });\n\n    it('doesnt skipId for single nested subdocs (gh-4008)', async function() {\n      const childSchema = new Schema({\n        name: String\n      });\n\n      const parentSchema = new Schema({\n        child: childSchema\n      });\n\n      const Parent = db.model('Parent', parentSchema);\n\n      const doc = await Parent.create({ child: { name: 'My child' } });\n\n      const foundDoc = await Parent.collection.findOne({ _id: doc._id });\n      assert.ok(foundDoc.child._id);\n    });\n\n    it('single embedded docs with $near (gh-4014)', async function() {\n      const schema = new mongoose.Schema({\n        placeName: String\n      });\n\n      const geoSchema = new mongoose.Schema({\n        type: {\n          type: String,\n          enum: 'Point',\n          default: 'Point'\n        },\n        coordinates: {\n          type: [Number],\n          default: [0, 0]\n        }\n      });\n\n      schema.add({ geo: geoSchema });\n      schema.index({ geo: '2dsphere' });\n\n      const MyModel = db.model('Test', schema);\n      await MyModel.init();\n\n      await MyModel.\n        where('geo').near({ center: [50, 50], spherical: true }).\n        exec();\n    });\n\n    it('skip validation if required returns false (gh-4094)', function() {\n      const schema = new Schema({\n        div: {\n          type: Number,\n          required: function() { return false; },\n          validate: function(v) { return !!v; }\n        }\n      });\n      const Model = db.model('Test', schema);\n      const m = new Model();\n      assert.ifError(m.validateSync());\n    });\n\n    it('ability to overwrite array default (gh-4109)', async function() {\n      const schema = new Schema({\n        names: {\n          type: [String],\n          default: void 0\n        }\n      });\n\n      const Model = db.model('Test', schema);\n      const m = new Model();\n      assert.ok(!m.names);\n      await m.save();\n\n      const doc = await Model.collection.findOne({ _id: m._id });\n\n      assert.ok(!('names' in doc));\n    });\n\n    it('validation works when setting array index (gh-3816)', async function() {\n      const mySchema = new mongoose.Schema({\n        items: [\n          { month: Number, date: Date }\n        ]\n      });\n\n      const Test = db.model('test', mySchema);\n\n      const a = [\n        { month: 0, date: new Date() },\n        { month: 1, date: new Date() }\n      ];\n      const doc = await Test.create({ items: a });\n\n      const foundDoc = await Test.findById(doc._id).exec();\n\n      assert.ok(foundDoc);\n      foundDoc.items[0] = {\n        month: 5,\n        date: new Date()\n      };\n      foundDoc.markModified('items');\n\n      // Should not throw\n      await foundDoc.save();\n    });\n\n    it('validateSync works when setting array index nested (gh-5389)', async function() {\n      const childSchema = new mongoose.Schema({\n        _id: false,\n        name: String,\n        age: Number\n      });\n\n      const schema = new mongoose.Schema({\n        name: String,\n        children: [childSchema]\n      });\n\n      const Model = db.model('Test', schema);\n\n      const doc = await Model.create({\n        name: 'test',\n        children: [\n          { name: 'test-child', age: 24 }\n        ]\n      });\n\n      const foundDoc = await Model.findById(doc._id);\n\n      foundDoc.children[0] = { name: 'updated-child', age: 53 };\n      const errors = foundDoc.validateSync();\n      assert.ok(!errors);\n    });\n\n    it('single embedded with defaults have $parent (gh-4115)', function() {\n      const ChildSchema = new Schema({\n        name: {\n          type: String,\n          default: 'child'\n        }\n      });\n\n      const ParentSchema = new Schema({\n        child: {\n          type: ChildSchema,\n          default: {}\n        }\n      });\n\n      const Parent = db.model('Parent', ParentSchema);\n\n      const p = new Parent();\n      assert.equal(p.child.$parent(), p);\n    });\n\n    it('removing parent doc calls remove hooks on subdocs (gh-2348) (gh-4566)', async function() {\n      const ChildSchema = new Schema({\n        name: String\n      });\n\n      const called = {};\n      ChildSchema.pre('remove', function(next) {\n        called[this.name] = true;\n        next();\n      });\n\n      const ParentSchema = new Schema({\n        children: [ChildSchema],\n        child: ChildSchema\n      });\n\n      const Parent = db.model('Parent', ParentSchema);\n\n      const doc = await Parent.create({\n        children: [{ name: 'Jacen' }, { name: 'Jaina' }],\n        child: { name: 'Anakin' }\n      });\n\n      await doc.remove();\n\n      assert.deepEqual(called, {\n        Jacen: true,\n        Jaina: true,\n        Anakin: true\n      });\n\n      const arr = doc.children.toObject().map(function(v) { return v.name; });\n      assert.deepEqual(arr, ['Jacen', 'Jaina']);\n      assert.equal(doc.child.name, 'Anakin');\n    });\n\n    it('strings of length 12 are valid oids (gh-3365)', async function() {\n      const schema = new Schema({ myId: mongoose.Schema.Types.ObjectId });\n      const M = db.model('Test', schema);\n      const doc = new M({ myId: 'blablablabla' });\n      await doc.validate();\n    });\n\n    it('set() empty obj unmodifies subpaths (gh-4182)', async function() {\n      const omeletteSchema = new Schema({\n        topping: {\n          meat: {\n            type: String,\n            enum: ['bacon', 'sausage']\n          },\n          cheese: Boolean\n        }\n      });\n      const Omelette = db.model('Test', omeletteSchema);\n      const doc = new Omelette({\n        topping: {\n          meat: 'bacon',\n          cheese: true\n        }\n      });\n      doc.topping = {};\n      await doc.save();\n      assert.strictEqual(doc.topping.meat, void 0);\n    });\n\n    it('emits cb errors on model for save (gh-3499)', function(done) {\n      const testSchema = new Schema({ name: String });\n\n      const Test = db.model('Test', testSchema);\n      Test.on('error', function(error) {\n        assert.equal(error.message, 'fail!');\n        done();\n      });\n\n      new Test({}).save(function() {\n        throw new Error('fail!');\n      });\n    });\n\n    it('emits cb errors on model for save with hooks (gh-3499)', function(done) {\n      const testSchema = new Schema({ name: String });\n\n      testSchema.pre('save', function(next) {\n        next();\n      });\n\n      testSchema.post('save', function(doc, next) {\n        next();\n      });\n\n      const Test = db.model('Test', testSchema);\n\n      Test.on('error', function(error) {\n        assert.equal(error.message, 'fail!');\n        done();\n      });\n\n      new Test({}).save(function() {\n        throw new Error('fail!');\n      });\n    });\n\n    it('emits cb errors on model for find() (gh-3499)', function(done) {\n      const testSchema = new Schema({ name: String });\n\n      const Test = db.model('Test', testSchema);\n\n      Test.on('error', function(error) {\n        assert.equal(error.message, 'fail!');\n        done();\n      });\n\n      Test.find({}, function() {\n        throw new Error('fail!');\n      });\n    });\n\n    it('emits cb errors on model for find() + hooks (gh-3499)', function(done) {\n      const testSchema = new Schema({ name: String });\n\n      testSchema.post('find', function(results, next) {\n        assert.equal(results.length, 0);\n        next();\n      });\n\n      const Test = db.model('Test', testSchema);\n\n      Test.on('error', function(error) {\n        assert.equal(error.message, 'fail!');\n        done();\n      });\n\n      Test.find({}, function() {\n        throw new Error('fail!');\n      });\n    });\n\n    it('clears subpaths when removing single nested (gh-4216)', function(done) {\n      const RecurrenceSchema = new Schema({\n        frequency: Number,\n        interval: {\n          type: String,\n          enum: ['days', 'weeks', 'months', 'years']\n        }\n      }, { _id: false });\n\n      const EventSchema = new Schema({\n        name: {\n          type: String,\n          trim: true\n        },\n        recurrence: RecurrenceSchema\n      });\n\n      const Event = db.model('Test', EventSchema);\n      const ev = new Event({\n        name: 'test',\n        recurrence: { frequency: 2, interval: 'days' }\n      });\n      ev.recurrence = null;\n      ev.save(function(error) {\n        assert.ifError(error);\n        done();\n      });\n    });\n\n    it('setting path to empty object works (gh-4218)', async function() {\n      const schema = new Schema({\n        object: {\n          nested: {\n            field1: { type: Number, default: 1 }\n          }\n        }\n      });\n\n      const MyModel = db.model('Test', schema);\n\n\n      let doc = await MyModel.create({});\n      doc.object.nested = {};\n      await doc.save();\n      doc = await MyModel.collection.findOne({ _id: doc._id });\n      assert.deepEqual(doc.object.nested, {});\n    });\n\n    it('setting path to object with strict and no paths in the schema (gh-6436) (gh-4218)', async function() {\n      const schema = new Schema({\n        object: {\n          nested: {\n            field1: { type: Number, default: 1 }\n          }\n        }\n      });\n\n      const MyModel = db.model('Test', schema);\n\n\n      let doc = await MyModel.create({});\n      doc.object.nested = { field2: 'foo' }; // `field2` not in the schema\n      await doc.save();\n      doc = await MyModel.collection.findOne({ _id: doc._id });\n      assert.deepEqual(doc.object.nested, {});\n    });\n\n    it('minimize + empty object (gh-4337)', function() {\n      const SomeModelSchema = new mongoose.Schema(\n        {},\n        { minimize: false }\n      );\n\n      const SomeModel = db.model('Test', SomeModelSchema);\n\n      assert.doesNotThrow(function() {\n        new SomeModel({});\n      });\n    });\n\n    it('directModifiedPaths() (gh-7373)', async function() {\n      const schema = new Schema({ foo: String, nested: { bar: String } });\n      const Model = db.model('Test', schema);\n\n\n      await Model.create({ foo: 'original', nested: { bar: 'original' } });\n\n      const doc = await Model.findOne();\n      doc.nested.bar = 'modified';\n\n      assert.deepEqual(doc.directModifiedPaths(), ['nested.bar']);\n      assert.deepEqual(doc.modifiedPaths().sort(), ['nested', 'nested.bar']);\n    });\n\n    describe('modifiedPaths', function() {\n      it('doesnt markModified child paths if parent is modified (gh-4224)', async function() {\n        const childSchema = new Schema({\n          name: String\n        });\n        const parentSchema = new Schema({\n          child: childSchema\n        });\n\n        const Parent = db.model('Test', parentSchema);\n        const doc = await Parent.create({ child: { name: 'Jacen' } });\n\n        doc.child = { name: 'Jaina' };\n        doc.child.name = 'Anakin';\n        assert.deepEqual(doc.modifiedPaths(), ['child']);\n        assert.ok(doc.isModified('child.name'));\n      });\n\n      it('includeChildren option (gh-6134)', function() {\n        const personSchema = new mongoose.Schema({\n          name: { type: String },\n          colors: {\n            primary: {\n              type: String,\n              default: 'white',\n              enum: ['blue', 'green', 'red', 'purple', 'yellow']\n            }\n          }\n        });\n\n        const Person = db.model('Person', personSchema);\n\n        const luke = new Person({\n          name: 'Luke',\n          colors: {\n            primary: 'blue'\n          }\n        });\n        assert.deepEqual(luke.modifiedPaths(), ['name', 'colors']);\n\n        const obiwan = new Person({ name: 'Obi-Wan' });\n        obiwan.colors.primary = 'blue';\n        assert.deepEqual(obiwan.modifiedPaths(), ['name', 'colors', 'colors.primary']);\n\n        const anakin = new Person({ name: 'Anakin' });\n        anakin.colors = { primary: 'blue' };\n        assert.deepEqual(anakin.modifiedPaths({ includeChildren: true }), ['name', 'colors', 'colors.primary']);\n      });\n\n      it('includeChildren option with arrays (gh-5904)', function() {\n        const teamSchema = new mongoose.Schema({\n          name: String,\n          colors: {\n            primary: {\n              type: String,\n              enum: ['blue', 'green', 'red', 'purple', 'yellow', 'white', 'black']\n            }\n          },\n          members: [{\n            name: String\n          }]\n        });\n\n        const Team = db.model('Team', teamSchema);\n\n        const jedis = new Team({\n          name: 'Jedis',\n          colors: {\n            primary: 'blue'\n          },\n          members: [{ name: 'luke' }]\n        });\n\n        const paths = jedis.modifiedPaths({ includeChildren: true });\n        assert.deepEqual(paths, [\n          'name',\n          'colors',\n          'colors.primary',\n          'members',\n          'members.0',\n          'members.0.name'\n        ]);\n      });\n\n      it('1 level down nested paths get marked modified on initial set (gh-7313) (gh-6944)', function() {\n        const testSchema = new Schema({\n          name: {\n            first: String,\n            last: String\n          },\n          relatives: {\n            aunt: {\n              name: String\n            },\n            uncle: {\n              name: String\n            }\n          }\n        });\n        const M = db.model('Test', testSchema);\n\n        const doc = new M({\n          name: { first: 'A', last: 'B' },\n          relatives: {\n            aunt: { name: 'foo' },\n            uncle: { name: 'bar' }\n          }\n        });\n\n        assert.ok(doc.modifiedPaths().indexOf('name') !== -1);\n        assert.ok(doc.modifiedPaths().indexOf('relatives') !== -1);\n        assert.ok(doc.modifiedPaths({ includeChildren: true }).indexOf('name.first') !== -1);\n        assert.ok(doc.modifiedPaths({ includeChildren: true }).indexOf('name.last') !== -1);\n        assert.ok(doc.modifiedPaths({ includeChildren: true }).indexOf('relatives.aunt') !== -1);\n        assert.ok(doc.modifiedPaths({ includeChildren: true }).indexOf('relatives.uncle') !== -1);\n\n        return Promise.resolve();\n      });\n    });\n\n    it('single nested isNew (gh-4369)', function(done) {\n      const childSchema = new Schema({\n        name: String\n      });\n      const parentSchema = new Schema({\n        child: childSchema\n      });\n\n      const Parent = db.model('Test', parentSchema);\n      let remaining = 2;\n\n      const doc = new Parent({ child: { name: 'Jacen' } });\n      doc.child.on('isNew', function(val) {\n        assert.ok(!val);\n        assert.ok(!doc.child.isNew);\n        --remaining || done();\n      });\n\n      doc.save(function(error, doc) {\n        assert.ifError(error);\n        assert.ok(!doc.child.isNew);\n        --remaining || done();\n      });\n    });\n\n    it('deep default array values (gh-4540)', function() {\n      const schema = new Schema({\n        arr: [{\n          test: {\n            type: Array,\n            default: ['test']\n          }\n        }]\n      });\n      assert.doesNotThrow(function() {\n        db.model('Test', schema);\n      });\n    });\n\n    it('default values with subdoc array (gh-4390)', function(done) {\n      const childSchema = new Schema({\n        name: String\n      });\n      const parentSchema = new Schema({\n        child: [childSchema]\n      });\n\n      parentSchema.path('child').default([{ name: 'test' }]);\n\n      const Parent = db.model('Parent', parentSchema);\n\n      Parent.create({}, function(error, doc) {\n        assert.ifError(error);\n        const arr = doc.toObject().child.map(function(doc) {\n          assert.ok(doc._id);\n          delete doc._id;\n          return doc;\n        });\n        assert.deepEqual(arr, [{ name: 'test' }]);\n        done();\n      });\n    });\n\n    it('handles invalid dates (gh-4404)', function(done) {\n      const testSchema = new Schema({\n        date: Date\n      });\n\n      const Test = db.model('Test', testSchema);\n\n      Test.create({ date: new Date('invalid date') }, function(error) {\n        assert.ok(error);\n        assert.equal(error.errors['date'].name, 'CastError');\n        done();\n      });\n    });\n\n    it('setting array subpath (gh-4472)', function() {\n      const ChildSchema = new mongoose.Schema({\n        name: String,\n        age: Number\n      }, { _id: false });\n\n      const ParentSchema = new mongoose.Schema({\n        data: {\n          children: [ChildSchema]\n        }\n      });\n\n      const Parent = db.model('Parent', ParentSchema);\n\n      const p = new Parent();\n      p.set('data.children.0', {\n        name: 'Bob',\n        age: 900\n      });\n\n      assert.deepEqual(p.toObject().data.children, [{ name: 'Bob', age: 900 }]);\n    });\n\n    it('ignore paths (gh-4480)', async function() {\n      const TestSchema = new Schema({\n        name: { type: String, required: true }\n      });\n\n      const Test = db.model('Parent', TestSchema);\n\n\n      await Test.create({ name: 'val' });\n\n      let doc = await Test.findOne();\n\n      doc.name = null;\n      doc.$ignore('name');\n\n      await doc.save();\n\n      doc = await Test.findById(doc._id);\n\n      assert.equal(doc.name, 'val');\n    });\n\n    it('ignore subdocs paths (gh-4480) (gh-6152)', async function() {\n      const childSchema = new Schema({\n        name: { type: String, required: true }\n      });\n      const testSchema = new Schema({\n        child: childSchema,\n        children: [childSchema]\n      });\n\n      const Test = db.model('Test', testSchema);\n\n\n      await Test.create({\n        child: { name: 'testSingle' },\n        children: [{ name: 'testArr' }]\n      });\n\n      let doc = await Test.findOne();\n      doc.child.name = null;\n      doc.child.$ignore('name');\n\n      await doc.save();\n\n      doc = await Test.findById(doc._id);\n\n      assert.equal(doc.child.name, 'testSingle');\n\n      doc.children[0].name = null;\n      doc.children[0].$ignore('name');\n\n      await doc.save();\n\n      doc = await Test.findById(doc._id);\n\n      assert.equal(doc.children[0].name, 'testArr');\n    });\n\n    it('composite _ids (gh-4542)', function(done) {\n      const schema = new Schema({\n        _id: {\n          key1: String,\n          key2: String\n        },\n        content: String\n      });\n\n      const Model = db.model('Test', schema);\n\n      const object = new Model();\n      object._id = { key1: 'foo', key2: 'bar' };\n      object.save().\n        then(function(obj) {\n          obj.content = 'Hello';\n          return obj.save();\n        }).\n        then(function(obj) {\n          return Model.findOne({ _id: obj._id });\n        }).\n        then(function(obj) {\n          assert.equal(obj.content, 'Hello');\n          done();\n        }).\n        catch(done);\n    });\n\n    it('validateSync with undefined and conditional required (gh-4607)', function() {\n      const schema = new mongoose.Schema({\n        type: mongoose.SchemaTypes.Number,\n        conditional: {\n          type: mongoose.SchemaTypes.String,\n          required: function() {\n            return this.type === 1;\n          },\n          maxlength: 128\n        }\n      });\n\n      const Model = db.model('Test', schema);\n\n      assert.doesNotThrow(function() {\n        new Model({\n          type: 2,\n          conditional: void 0\n        }).validateSync();\n      });\n    });\n\n    it('conditional required on single nested (gh-4663)', function() {\n      const childSchema = new Schema({\n        name: String\n      });\n      const schema = new Schema({\n        child: {\n          type: childSchema,\n          required: function() {\n            assert.equal(this.child.name, 'test');\n          }\n        }\n      });\n\n      const M = db.model('Test', schema);\n\n      const err = new M({ child: { name: 'test' } }).validateSync();\n      assert.ifError(err);\n    });\n\n    it('setting full path under single nested schema works (gh-4578) (gh-4528)', function(done) {\n      const ChildSchema = new mongoose.Schema({\n        age: Number\n      });\n\n      const ParentSchema = new mongoose.Schema({\n        age: Number,\n        family: {\n          child: ChildSchema\n        }\n      });\n\n      const M = db.model('Test', ParentSchema);\n\n      M.create({ age: 45 }, function(error, doc) {\n        assert.ifError(error);\n        assert.ok(!doc.family.child);\n        doc.set('family.child.age', 15);\n        assert.ok(doc.family.child.schema);\n        assert.ok(doc.isModified('family.child'));\n        assert.ok(doc.isModified('family.child.age'));\n        assert.equal(doc.family.child.toObject().age, 15);\n        done();\n      });\n    });\n\n    it('setting a nested path retains nested modified paths (gh-5206)', async function() {\n      const testSchema = new mongoose.Schema({\n        name: String,\n        surnames: {\n          docarray: [{ name: String }]\n        }\n      });\n\n      const Cat = db.model('Cat', testSchema);\n\n      const kitty = new Cat({\n        name: 'Test',\n        surnames: {\n          docarray: [{ name: 'test1' }, { name: 'test2' }]\n        }\n      });\n\n      await kitty.save();\n\n      kitty.surnames = {\n        docarray: [{ name: 'test1' }, { name: 'test2' }, { name: 'test3' }]\n      };\n\n      assert.deepEqual(\n        kitty.modifiedPaths(),\n        ['surnames', 'surnames.docarray']\n      );\n    });\n\n    it('toObject() does not depopulate top level (gh-3057)', function() {\n      const Cat = db.model('Cat', { name: String });\n      const Human = db.model('Person', {\n        name: String,\n        petCat: { type: mongoose.Schema.Types.ObjectId, ref: 'Cat' }\n      });\n\n      const kitty = new Cat({ name: 'Zildjian' });\n      const person = new Human({ name: 'Val', petCat: kitty });\n\n      assert.equal(kitty.toObject({ depopulate: true }).name, 'Zildjian');\n      assert.ok(!person.toObject({ depopulate: true }).petCat.name);\n    });\n\n    it('toObject() respects schema-level depopulate (gh-6313)', function() {\n      const personSchema = Schema({\n        name: String,\n        car: {\n          type: Schema.Types.ObjectId,\n          ref: 'Car'\n        }\n      });\n\n      personSchema.set('toObject', {\n        depopulate: true\n      });\n\n      const carSchema = Schema({\n        name: String\n      });\n\n      const Car = db.model('Car', carSchema);\n      const Person = db.model('Person', personSchema);\n\n      const car = new Car({\n        name: 'Ford'\n      });\n\n      const person = new Person({\n        name: 'John',\n        car: car\n      });\n\n      assert.equal(person.toObject().car.toHexString(), car._id.toHexString());\n    });\n\n    it('single nested doc conditional required (gh-4654)', function(done) {\n      const ProfileSchema = new Schema({\n        firstName: String,\n        lastName: String\n      });\n\n      function validator() {\n        assert.equal(this.email, 'test');\n        return true;\n      }\n\n      const UserSchema = new Schema({\n        email: String,\n        profile: {\n          type: ProfileSchema,\n          required: [validator, 'profile required']\n        }\n      });\n\n      const User = db.model('User', UserSchema);\n      User.create({ email: 'test' }, function(error) {\n        assert.equal(error.errors['profile'].message, 'profile required');\n        done();\n      });\n    });\n\n    it('handles setting single nested schema to equal value (gh-4676)', function(done) {\n      const companySchema = new mongoose.Schema({\n        _id: false,\n        name: String,\n        description: String\n      });\n\n      const userSchema = new mongoose.Schema({\n        name: String,\n        company: companySchema\n      });\n\n      const User = db.model('User', userSchema);\n\n      const user = new User({ company: { name: 'Test' } });\n      user.save(function(error) {\n        assert.ifError(error);\n        user.company.description = 'test';\n        assert.ok(user.isModified('company'));\n        user.company = user.company;\n        assert.ok(user.isModified('company'));\n        done();\n      });\n    });\n\n    it('handles setting single nested doc to null after setting (gh-4766)', function(done) {\n      const EntitySchema = new Schema({\n        company: {\n          type: String,\n          required: true\n        },\n        name: {\n          type: String,\n          required: false\n        },\n        email: {\n          type: String,\n          required: false\n        }\n      }, { _id: false, id: false });\n\n      const ShipmentSchema = new Schema({\n        entity: {\n          shipper: {\n            type: EntitySchema,\n            required: false\n          },\n          manufacturer: {\n            type: EntitySchema,\n            required: false\n          }\n        }\n      });\n\n      const Shipment = db.model('Test', ShipmentSchema);\n      const doc = new Shipment({\n        entity: {\n          shipper: null,\n          manufacturer: {\n            company: 'test',\n            name: 'test',\n            email: 'test@email'\n          }\n        }\n      });\n\n      doc.save().\n        then(function() { return Shipment.findById(doc._id); }).\n        then(function(shipment) {\n          shipment.entity = shipment.entity;\n          shipment.entity.manufacturer = null;\n          return shipment.save();\n        }).\n        then(function() {\n          done();\n        }).\n        catch(done);\n    });\n\n    it('buffers with subtypes as ids (gh-4506)', function(done) {\n      const uuid = require('uuid');\n\n      const UserSchema = new mongoose.Schema({\n        _id: {\n          type: Buffer,\n          default: function() {\n            return mongoose.Types.Buffer(uuid.parse(uuid.v4())).toObject(4);\n          },\n          required: true\n        },\n        email: {\n          type: String,\n          lowercase: true,\n          required: true\n        },\n        name: String\n      });\n\n      const User = db.model('User', UserSchema);\n\n      const user = new User({\n        email: 'me@email.com',\n        name: 'My name'\n      });\n\n      user.save().\n        then(function() {\n          return User.findOne({ email: 'me@email.com' });\n        }).\n        then(function(user) {\n          user.name = 'other';\n          return user.save();\n        }).\n        then(function() {\n          return User.findOne({ email: 'me@email.com' });\n        }).\n        then(function(doc) {\n          assert.equal(doc.name, 'other');\n          done();\n        }).\n        catch(done);\n    });\n\n    it('embedded docs dont mark parent as invalid (gh-4681)', function(done) {\n      const NestedSchema = new mongoose.Schema({\n        nestedName: { type: String, required: true },\n        createdAt: { type: Date, required: true }\n      });\n      const RootSchema = new mongoose.Schema({\n        rootName: String,\n        nested: { type: [NestedSchema] }\n      });\n\n      const Root = db.model('Test', RootSchema);\n      const root = new Root({ rootName: 'root', nested: [{ }] });\n      root.save(function(error) {\n        assert.ok(error);\n        assert.deepEqual(Object.keys(error.errors).sort(),\n          ['nested.0.createdAt', 'nested.0.nestedName']);\n        done();\n      });\n    });\n\n    it('should depopulate the shard key when saving (gh-4658)', function(done) {\n      const ChildSchema = new mongoose.Schema({\n        name: String\n      });\n\n      const ChildModel = db.model('Child', ChildSchema);\n\n      const ParentSchema = new mongoose.Schema({\n        name: String,\n        child: { type: Schema.Types.ObjectId, ref: 'Child' }\n      }, { shardKey: { child: 1, _id: 1 } });\n\n      const ParentModel = db.model('Parent', ParentSchema);\n\n      ChildModel.create({ name: 'Luke' }).\n        then(function(child) {\n          const p = new ParentModel({ name: 'Vader' });\n          p.child = child;\n          return p.save();\n        }).\n        then(function(p) {\n          p.name = 'Anakin';\n          return p.save();\n        }).\n        then(function(p) {\n          return ParentModel.findById(p);\n        }).\n        then(function(doc) {\n          assert.equal(doc.name, 'Anakin');\n          done();\n        }).\n        catch(done);\n    });\n\n    it('handles setting virtual subpaths (gh-4716)', function() {\n      const childSchema = new Schema({\n        name: { type: String, default: 'John' },\n        favorites: {\n          color: {\n            type: String,\n            default: 'Blue'\n          }\n        }\n      });\n\n      const parentSchema = new Schema({\n        name: { type: String },\n        children: {\n          type: [childSchema],\n          default: [{}]\n        }\n      });\n\n      parentSchema.virtual('favorites').set(function(v) {\n        return this.children[0].set('favorites', v);\n      }).get(function() {\n        return this.children[0].get('favorites');\n      });\n\n      const Parent = db.model('Parent', parentSchema);\n      const p = new Parent({ name: 'Anakin' });\n      p.set('children.0.name', 'Leah');\n      p.set('favorites.color', 'Red');\n      assert.equal(p.children[0].favorites.color, 'Red');\n    });\n\n    it('handles selected nested elements with defaults (gh-4739) (gh-11376)', async function() {\n      const userSchema = new Schema({\n        preferences: {\n          sleep: { type: Boolean, default: false },\n          test: { type: Boolean, default: true }\n        },\n        arr: [{ test: Number, test2: Number }],\n        name: String\n      });\n\n      const User = db.model('User', userSchema);\n\n      let user = { name: 'test' };\n      await User.collection.insertOne(user);\n      user = await User.findById(user, { 'preferences.sleep': 1, name: 1 });\n      assert.strictEqual(user.preferences.sleep, false);\n      assert.ok(!user.preferences.test);\n\n      user = await User.findById(user, { 'arr.test': 1 });\n      assert.strictEqual(user.name, undefined);\n      assert.strictEqual(user.toObject().preferences, undefined);\n      assert.deepEqual(user.toObject().arr, []);\n    });\n\n    it('handles mark valid in subdocs correctly (gh-4778)', function() {\n      const SubSchema = new mongoose.Schema({\n        field: {\n          nestedField: {\n            type: mongoose.Schema.ObjectId,\n            required: false\n          }\n        }\n      }, { _id: false, id: false });\n\n      const Model2Schema = new mongoose.Schema({\n        sub: {\n          type: SubSchema,\n          required: false\n        }\n      });\n      const Model2 = db.model('Test', Model2Schema);\n\n      const doc = new Model2({\n        sub: {}\n      });\n\n      doc.sub.field.nestedField = { };\n      doc.sub.field.nestedField = '574b69d0d9daf106aaa62974';\n      assert.ok(!doc.validateSync());\n    });\n\n    it('timestamps set to false works (gh-7074)', async function() {\n      const schema = new Schema({ name: String }, { timestamps: false });\n      const Test = db.model('Test', schema);\n\n      const doc = await Test.create({ name: 'test' });\n      assert.strictEqual(doc.updatedAt, undefined);\n      assert.strictEqual(doc.createdAt, undefined);\n    });\n\n    it('timestamps with nested paths (gh-5051)', function(done) {\n      const schema = new Schema({ props: {} }, {\n        timestamps: {\n          createdAt: 'props.createdAt',\n          updatedAt: 'props.updatedAt'\n        }\n      });\n\n      const M = db.model('Test', schema);\n      const now = Date.now();\n      M.create({}, function(error, doc) {\n        assert.ok(doc.props.createdAt);\n        assert.ok(doc.props.createdAt instanceof Date);\n        assert.ok(doc.props.createdAt.valueOf() >= now);\n        assert.ok(doc.props.updatedAt);\n        assert.ok(doc.props.updatedAt instanceof Date);\n        assert.ok(doc.props.updatedAt.valueOf() >= now);\n        done();\n      });\n    });\n\n    it('Declaring defaults in your schema with timestamps defined (gh-6024)', function() {\n      const schemaDefinition = {\n        name: String,\n        misc: {\n          hometown: String,\n          isAlive: { type: Boolean, default: true }\n        }\n      };\n\n      const schemaWithTimestamps = new Schema(schemaDefinition, { timestamps: { createdAt: 'misc.createdAt' } });\n      const PersonWithTimestamps = db.model('Person', schemaWithTimestamps);\n      const dude = new PersonWithTimestamps({ name: 'Keanu', misc: { hometown: 'Beirut' } });\n      assert.equal(dude.misc.isAlive, true);\n    });\n\n    it('supports $where in pre save hook (gh-4004)', function(done) {\n      const Promise = global.Promise;\n\n      const schema = new Schema({\n        name: String\n      }, { timestamps: true, versionKey: null });\n\n      schema.pre('save', function(next) {\n        this.$where = { updatedAt: this.updatedAt };\n        next();\n      });\n\n      schema.post('save', function(error, res, next) {\n        assert.ok(error instanceof MongooseError.DocumentNotFoundError);\n        assert.ok(error.message.indexOf('Test') !== -1, error.message);\n\n        error = new Error('Somebody else updated the document!');\n        next(error);\n      });\n\n      const MyModel = db.model('Test', schema);\n\n      MyModel.create({ name: 'test' }).\n        then(function() {\n          return Promise.all([\n            MyModel.findOne(),\n            MyModel.findOne()\n          ]);\n        }).\n        then(function(docs) {\n          docs[0].name = 'test2';\n          return Promise.all([\n            docs[0].save(),\n            Promise.resolve(docs[1])\n          ]);\n        }).\n        then(function(docs) {\n          docs[1].name = 'test3';\n          return docs[1].save();\n        }).\n        then(function() {\n          done(new Error('Should not get here'));\n        }).\n        catch(function(error) {\n          assert.equal(error.message, 'Somebody else updated the document!');\n          done();\n        });\n    });\n\n    it('toObject() with buffer and minimize (gh-4800)', function(done) {\n      const TestSchema = new mongoose.Schema({ buf: Buffer }, {\n        toObject: {\n          virtuals: true,\n          getters: true\n        }\n      });\n\n      const Test = db.model('Test', TestSchema);\n\n      Test.create({ buf: Buffer.from('abcd') }).\n        then(function(doc) {\n          return Test.findById(doc._id);\n        }).\n        then(function(doc) {\n          assert.doesNotThrow(function() {\n            require('util').inspect(doc);\n          });\n          done();\n        }).\n        catch(done);\n    });\n\n    it('buffer subtype prop (gh-5530)', function() {\n      const TestSchema = new mongoose.Schema({\n        uuid: {\n          type: Buffer,\n          subtype: 4\n        }\n      });\n\n      const Test = db.model('Test', TestSchema);\n\n      const doc = new Test({ uuid: 'test1' });\n      assert.equal(doc.uuid._subtype, 4);\n    });\n\n    it('runs validate hooks on single nested subdocs if not directly modified (gh-3884)', function(done) {\n      const childSchema = new Schema({\n        name: { type: String },\n        friends: [{ type: String }]\n      });\n      let count = 0;\n\n      childSchema.pre('validate', function(next) {\n        ++count;\n        next();\n      });\n\n      const parentSchema = new Schema({\n        name: { type: String },\n        child: childSchema\n      });\n\n      const Parent = db.model('Parent', parentSchema);\n\n      const p = new Parent({\n        name: 'Mufasa',\n        child: {\n          name: 'Simba',\n          friends: ['Pumbaa', 'Timon', 'Nala']\n        }\n      });\n\n      p.save().\n        then(function(p) {\n          assert.equal(count, 1);\n          p.child.friends.push('Rafiki');\n          return p.save();\n        }).\n        then(function() {\n          assert.equal(count, 2);\n          done();\n        }).\n        catch(done);\n    });\n\n    it('runs validate hooks on arrays subdocs if not directly modified (gh-5861)', function(done) {\n      const childSchema = new Schema({\n        name: { type: String },\n        friends: [{ type: String }]\n      });\n      let count = 0;\n\n      childSchema.pre('validate', function(next) {\n        ++count;\n        next();\n      });\n\n      const parentSchema = new Schema({\n        name: { type: String },\n        children: [childSchema]\n      });\n\n      const Parent = db.model('Parent', parentSchema);\n\n      const p = new Parent({\n        name: 'Mufasa',\n        children: [{\n          name: 'Simba',\n          friends: ['Pumbaa', 'Timon', 'Nala']\n        }]\n      });\n\n      p.save().\n        then(function(p) {\n          assert.equal(count, 1);\n          p.children[0].friends.push('Rafiki');\n          return p.save();\n        }).\n        then(function() {\n          assert.equal(count, 2);\n          done();\n        }).\n        catch(done);\n    });\n\n    it('does not run schema type validator on single nested if not direct modified (gh-5885)', async function() {\n      let childValidateCalls = 0;\n      const childSchema = new Schema({\n        name: String,\n        otherProp: {\n          type: String,\n          validate: () => {\n            ++childValidateCalls;\n            return true;\n          }\n        }\n      });\n\n      let validateCalls = 0;\n      const parentSchema = new Schema({\n        child: {\n          type: childSchema,\n          validate: () => {\n            ++validateCalls;\n            return true;\n          }\n        }\n      });\n\n\n      const Parent = db.model('Parent', parentSchema);\n\n      const doc = await Parent.create({\n        child: {\n          name: 'test',\n          otherProp: 'test'\n        }\n      });\n\n      assert.equal(childValidateCalls, 1);\n      assert.equal(validateCalls, 1);\n      childValidateCalls = 0;\n      validateCalls = 0;\n\n      doc.set('child.name', 'test2');\n      await doc.validate();\n\n      assert.equal(childValidateCalls, 0);\n      assert.equal(validateCalls, 0);\n    });\n\n    it('runs schema type validator on single nested if parent has default (gh-7493)', function() {\n      const childSchema = new Schema({\n        test: String\n      });\n      const parentSchema = new Schema({\n        child: {\n          type: childSchema,\n          default: {},\n          validate: () => false\n        }\n      });\n      const Parent = db.model('Test', parentSchema);\n\n      const parentDoc = new Parent({});\n\n      parentDoc.child.test = 'foo';\n\n      const err = parentDoc.validateSync();\n      assert.ok(err);\n      assert.ok(err.errors['child']);\n      return Promise.resolve();\n    });\n\n    it('does not overwrite when setting nested (gh-4793)', function() {\n      const grandchildSchema = new mongoose.Schema();\n      grandchildSchema.method({\n        foo: function() { return 'bar'; }\n      });\n      const Grandchild = db.model('Test', grandchildSchema);\n\n      const childSchema = new mongoose.Schema({\n        grandchild: grandchildSchema\n      });\n      const Child = db.model('Child', childSchema);\n\n      const parentSchema = new mongoose.Schema({\n        children: [childSchema]\n      });\n      const Parent = db.model('Parent', parentSchema);\n\n      const grandchild = new Grandchild();\n      const child = new Child({ grandchild: grandchild });\n\n      assert.equal(child.grandchild.foo(), 'bar');\n\n      const p = new Parent({ children: [child] });\n\n      assert.equal(child.grandchild.foo(), 'bar');\n      assert.equal(p.children[0].grandchild.foo(), 'bar');\n    });\n\n    it('hooks/middleware for custom methods (gh-6385) (gh-7456)', async function() {\n      const mySchema = new Schema({\n        name: String\n      });\n\n      mySchema.methods.foo = function(cb) {\n        return cb(null, this.name);\n      };\n      mySchema.methods.bar = function() {\n        return this.name;\n      };\n      mySchema.methods.baz = function(arg) {\n        return Promise.resolve(arg);\n      };\n\n      let preFoo = 0;\n      let postFoo = 0;\n      mySchema.pre('foo', function() {\n        ++preFoo;\n      });\n      mySchema.post('foo', function() {\n        ++postFoo;\n      });\n\n      let preBaz = 0;\n      let postBaz = 0;\n      mySchema.pre('baz', function() {\n        ++preBaz;\n      });\n      mySchema.post('baz', function() {\n        ++postBaz;\n      });\n\n      const MyModel = db.model('Test', mySchema);\n\n\n      const doc = new MyModel({ name: 'test' });\n\n      assert.equal(doc.bar(), 'test');\n\n      assert.equal(preFoo, 0);\n      assert.equal(postFoo, 0);\n\n      const fooResult = await doc.foo();\n      assert.equal(fooResult, 'test');\n      assert.equal(preFoo, 1);\n      assert.equal(postFoo, 1);\n\n      assert.equal(preBaz, 0);\n      assert.equal(postBaz, 0);\n\n      assert.equal(await doc.baz('foobar'), 'foobar');\n      assert.equal(preBaz, 1);\n      assert.equal(preBaz, 1);\n    });\n\n    it('custom methods with promises (gh-6385)', async function() {\n      const mySchema = new Schema({\n        name: String\n      });\n\n      mySchema.methods.foo = function() {\n        return Promise.resolve(this.name + ' foo');\n      };\n      mySchema.methods.bar = function() {\n        return this.name + ' bar';\n      };\n\n      let preFoo = 0;\n      let preBar = 0;\n      mySchema.pre('foo', function() {\n        ++preFoo;\n      });\n      mySchema.pre('bar', function() {\n        ++preBar;\n      });\n\n      const MyModel = db.model('Test', mySchema);\n\n\n      const doc = new MyModel({ name: 'test' });\n\n      assert.equal(preFoo, 0);\n      assert.equal(preBar, 0);\n\n      let foo = doc.foo();\n      let bar = doc.bar();\n      assert.ok(foo instanceof Promise);\n      assert.ok(bar instanceof Promise);\n\n      foo = await foo;\n      bar = await bar;\n\n      assert.equal(preFoo, 1);\n      assert.equal(preBar, 1);\n      assert.equal(foo, 'test foo');\n      assert.equal(bar, 'test bar');\n    });\n\n    it('toString() as custom method (gh-6538)', function() {\n      const commentSchema = new Schema({ title: String });\n      commentSchema.methods.toString = function() {\n        return `${this.constructor.modelName}(${this.title})`;\n      };\n      const Comment = db.model('Comment', commentSchema);\n      const c = new Comment({ title: 'test' });\n      assert.strictEqual('Comment(test)', `${c}`);\n    });\n\n    it('setting to discriminator (gh-4935)', function() {\n      const Buyer = db.model('Test1', new Schema({\n        name: String,\n        vehicle: { type: Schema.Types.ObjectId, ref: 'Test' }\n      }));\n      const Vehicle = db.model('Test', new Schema({ name: String }));\n      const Car = Vehicle.discriminator('gh4935_1', new Schema({\n        model: String\n      }));\n\n      const eleanor = new Car({ name: 'Eleanor', model: 'Shelby Mustang GT' });\n      const nick = new Buyer({ name: 'Nicolas', vehicle: eleanor });\n\n      assert.ok(!!nick.vehicle);\n      assert.ok(nick.vehicle === eleanor);\n      assert.ok(nick.vehicle instanceof Car);\n      assert.equal(nick.vehicle.name, 'Eleanor');\n    });\n\n    it('handles errors in sync validators (gh-2185)', function(done) {\n      const schema = new Schema({\n        name: {\n          type: String,\n          validate: function() {\n            throw new Error('woops!');\n          }\n        }\n      });\n\n      const M = db.model('Test', schema);\n\n      const error = (new M({ name: 'test' })).validateSync();\n      assert.ok(error);\n      assert.equal(error.errors['name'].reason.message, 'woops!');\n\n      new M({ name: 'test' }).validate(function(error) {\n        assert.ok(error);\n        assert.equal(error.errors['name'].reason.message, 'woops!');\n        done();\n      });\n    });\n\n    it('allows hook as a schema key (gh-5047)', function(done) {\n      const schema = new mongoose.Schema({\n        name: String,\n        hook: { type: String }\n      });\n\n      const Model = db.model('Test', schema);\n\n      Model.create({ hook: 'test ' }, function(error) {\n        assert.ifError(error);\n        done();\n      });\n    });\n\n    it('save errors with callback and promise work (gh-5216)', function(done) {\n      const schema = new mongoose.Schema({});\n\n      const Model = db.model('Test', schema);\n\n      const _id = new mongoose.Types.ObjectId();\n      const doc1 = new Model({ _id: _id });\n      const doc2 = new Model({ _id: _id });\n\n      let remaining = 2;\n      Model.on('error', function(error) {\n        assert.ok(error);\n        --remaining || done();\n      });\n\n      doc1.save().\n        then(function() { return doc2.save(); }).\n        catch(function(error) {\n          assert.ok(error);\n          --remaining || done();\n        });\n    });\n\n    it('post hooks on child subdocs run after save (gh-5085)', function(done) {\n      const ChildModelSchema = new mongoose.Schema({\n        text: {\n          type: String\n        }\n      });\n      ChildModelSchema.post('save', function(doc) {\n        doc.text = 'bar';\n      });\n      const ParentModelSchema = new mongoose.Schema({\n        children: [ChildModelSchema]\n      });\n\n      const Model = db.model('Parent', ParentModelSchema);\n\n      Model.create({ children: [{ text: 'test' }] }, function(error) {\n        assert.ifError(error);\n        Model.findOne({}, function(error, doc) {\n          assert.ifError(error);\n          assert.equal(doc.children.length, 1);\n          assert.equal(doc.children[0].text, 'test');\n          done();\n        });\n      });\n    });\n\n    it('post hooks on array child subdocs run after save (gh-5085) (gh-6926)', function() {\n      const subSchema = new Schema({\n        val: String\n      });\n\n      subSchema.post('save', function() {\n        return Promise.reject(new Error('Oops'));\n      });\n\n      const schema = new Schema({\n        sub: subSchema\n      });\n\n      const Test = db.model('Test', schema);\n\n      const test = new Test({ sub: { val: 'test' } });\n\n      return test.save().\n        then(() => assert.ok(false), err => assert.equal(err.message, 'Oops')).\n        then(() => Test.findOne()).\n        then(doc => assert.equal(doc.sub.val, 'test'));\n    });\n\n    it('nested docs toObject() clones (gh-5008)', function() {\n      const schema = new mongoose.Schema({\n        sub: {\n          height: Number\n        }\n      });\n\n      const Model = db.model('Test', schema);\n\n      const doc = new Model({\n        sub: {\n          height: 3\n        }\n      });\n\n      assert.equal(doc.sub.height, 3);\n\n      const leanDoc = doc.sub.toObject();\n      assert.equal(leanDoc.height, 3);\n\n      doc.sub.height = 55;\n      assert.equal(doc.sub.height, 55);\n      assert.equal(leanDoc.height, 3);\n    });\n\n    it('toObject() with null (gh-5143)', function() {\n      const schema = new mongoose.Schema({\n        customer: {\n          name: { type: String, required: false }\n        }\n      });\n\n      const Model = db.model('Test', schema);\n\n      const model = new Model();\n      model.customer = null;\n      assert.strictEqual(model.toObject().customer, null);\n      assert.strictEqual(model.toObject({ getters: true }).customer, null);\n    });\n\n    it('handles array subdocs with single nested subdoc default (gh-5162)', function() {\n      const RatingsItemSchema = new mongoose.Schema({\n        value: Number\n      }, { versionKey: false, _id: false });\n\n      const RatingsSchema = new mongoose.Schema({\n        ratings: {\n          type: RatingsItemSchema,\n          default: { id: 1, value: 0 }\n        },\n        _id: false\n      });\n\n      const RestaurantSchema = new mongoose.Schema({\n        menu: {\n          type: [RatingsSchema]\n        }\n      });\n\n      const Restaurant = db.model('Test', RestaurantSchema);\n\n      // Should not throw\n      const r = new Restaurant();\n      assert.deepEqual(r.toObject().menu, []);\n    });\n\n    it('iterating through nested doc keys (gh-5078)', function() {\n      const schema = new Schema({\n        nested: {\n          test1: String,\n          test2: String\n        }\n      });\n\n      schema.virtual('tests').get(function() {\n        return Object.values(this.nested);\n      });\n\n      const M = db.model('Test', schema);\n\n      const doc = new M({ nested: { test1: 'a', test2: 'b' } });\n\n      assert.deepEqual(doc.toObject({ virtuals: true }).tests, ['a', 'b']);\n\n      assert.doesNotThrow(function() {\n        require('util').inspect(doc);\n      });\n      JSON.stringify(doc);\n    });\n\n    it('deeply nested virtual paths (gh-5250)', function() {\n      const TestSchema = new Schema({});\n      TestSchema.\n        virtual('a.b.c').\n        get(function() {\n          return this.v;\n        }).\n        set(function(value) {\n          this.v = value;\n        });\n\n      const TestModel = db.model('Test', TestSchema);\n      const t = new TestModel({ 'a.b.c': 5 });\n      assert.equal(t.a.b.c, 5);\n    });\n\n    it('nested virtual when populating with parent projected out (gh-7491)', async function() {\n      const childSchema = Schema({\n        _id: Number,\n        nested: { childPath: String },\n        otherPath: String\n      }, { toObject: { virtuals: true } });\n\n      childSchema.virtual('nested.childVirtual').get(() => true);\n\n      const parentSchema = Schema({\n        child: { type: Number, ref: 'Child' }\n      }, { toObject: { virtuals: true } });\n\n      parentSchema.virtual('_nested').get(function() {\n        return this.child.nested;\n      });\n\n      const Child = db.model('Child', childSchema);\n      const Parent = db.model('Parent', parentSchema);\n\n\n      await Child.create({\n        _id: 1,\n        nested: { childPath: 'foo' },\n        otherPath: 'bar'\n      });\n      await Parent.create({ child: 1 });\n\n      const doc = await Parent.findOne().populate('child', 'otherPath').\n        then(doc => doc.toObject());\n\n      assert.ok(!doc.child.nested.childPath);\n    });\n\n    it('JSON.stringify nested errors (gh-5208)', function(done) {\n      const AdditionalContactSchema = new Schema({\n        contactName: {\n          type: String,\n          required: true\n        },\n        contactValue: {\n          type: String,\n          required: true\n        }\n      });\n\n      const ContactSchema = new Schema({\n        name: {\n          type: String,\n          required: true\n        },\n        email: {\n          type: String,\n          required: true\n        },\n        additionalContacts: [AdditionalContactSchema]\n      });\n\n      const EmergencyContactSchema = new Schema({\n        contactName: {\n          type: String,\n          required: true\n        },\n        contact: ContactSchema\n      });\n\n      const EmergencyContact = db.model('Test', EmergencyContactSchema);\n\n      const contact = new EmergencyContact({\n        contactName: 'Electrical Service',\n        contact: {\n          name: 'John Smith',\n          email: 'john@gmail.com',\n          additionalContacts: [\n            {\n              contactName: 'skype'\n              // Forgotten value\n            }\n          ]\n        }\n      });\n      contact.validate(function(error) {\n        assert.ok(error);\n        assert.ok(error.errors['contact.additionalContacts.0.contactValue']);\n\n        // This `JSON.stringify()` should not throw\n        assert.ok(JSON.stringify(error).indexOf('contactValue') !== -1);\n        done();\n      });\n    });\n\n    it('handles errors in subdoc pre validate (gh-5215)', function(done) {\n      const childSchema = new mongoose.Schema({});\n\n      childSchema.pre('validate', function(next) {\n        next(new Error('child pre validate'));\n      });\n\n      const parentSchema = new mongoose.Schema({\n        child: childSchema\n      });\n\n      const Parent = db.model('Parent', parentSchema);\n\n      Parent.create({ child: {} }, function(error) {\n        assert.ok(error);\n        assert.ok(error.errors['child']);\n        assert.equal(error.errors['child'].message, 'child pre validate');\n        done();\n      });\n    });\n\n    it('custom error types (gh-4009)', function(done) {\n      const CustomError = function() {};\n\n      const testSchema = new mongoose.Schema({\n        num: {\n          type: Number,\n          required: {\n            ErrorConstructor: CustomError\n          },\n          min: 5\n        }\n      });\n\n      const Test = db.model('Test', testSchema);\n\n      Test.create({}, function(error) {\n        assert.ok(error);\n        assert.ok(error.errors['num']);\n        assert.ok(error.errors['num'] instanceof CustomError);\n        Test.create({ num: 1 }, function(error) {\n          assert.ok(error);\n          assert.ok(error.errors['num']);\n          assert.ok(error.errors['num'].constructor.name, 'ValidatorError');\n          assert.ok(!(error.errors['num'] instanceof CustomError));\n          done();\n        });\n      });\n    });\n\n    it('saving a doc with nested string array (gh-5282)', function(done) {\n      const testSchema = new mongoose.Schema({\n        strs: [[String]]\n      });\n\n      const Test = db.model('Test', testSchema);\n\n      const t = new Test({\n        strs: [['a', 'b']]\n      });\n\n      t.save(function(error, t) {\n        assert.ifError(error);\n        assert.deepEqual(t.toObject().strs, [['a', 'b']]);\n        done();\n      });\n    });\n\n    it('push() onto a nested doc array (gh-6398)', async function() {\n      const schema = new mongoose.Schema({\n        name: String,\n        array: [[{ key: String, value: Number }]]\n      });\n\n      const Model = db.model('Test', schema);\n\n\n      await Model.create({\n        name: 'small',\n        array: [[{ key: 'answer', value: 42 }]]\n      });\n\n      let doc = await Model.findOne();\n\n      assert.ok(doc);\n      doc.array[0].push({ key: 'lucky', value: 7 });\n\n      await doc.save();\n\n      doc = await Model.findOne();\n      assert.equal(doc.array.length, 1);\n      assert.equal(doc.array[0].length, 2);\n      assert.equal(doc.array[0][1].key, 'lucky');\n    });\n\n    it('push() onto a triple nested doc array (gh-6602) (gh-6398)', async function() {\n      const schema = new mongoose.Schema({\n        array: [[[{ key: String, value: Number }]]]\n      });\n\n      const Model = db.model('Test', schema);\n\n\n      await Model.create({\n        array: [[[{ key: 'answer', value: 42 }]]]\n      });\n\n      let doc = await Model.findOne();\n\n      assert.ok(doc);\n      doc.array[0][0].push({ key: 'lucky', value: 7 });\n\n      await doc.save();\n\n      doc = await Model.findOne();\n      assert.equal(doc.array.length, 1);\n      assert.equal(doc.array[0].length, 1);\n      assert.equal(doc.array[0][0].length, 2);\n      assert.equal(doc.array[0][0][1].key, 'lucky');\n    });\n\n    it('null _id (gh-5236)', function(done) {\n      const childSchema = new mongoose.Schema({});\n\n      const M = db.model('Test', childSchema);\n\n      const m = new M({ _id: null });\n      m.save(function(error, doc) {\n        assert.equal(doc._id, null);\n        done();\n      });\n    });\n\n    it('setting populated path with typeKey (gh-5313)', function() {\n      const personSchema = Schema({\n        name: { $type: String },\n        favorite: { $type: Schema.Types.ObjectId, ref: 'Book' },\n        books: [{ $type: Schema.Types.ObjectId, ref: 'Book' }]\n      }, { typeKey: '$type' });\n\n      const bookSchema = Schema({\n        title: String\n      });\n\n      const Book = db.model('Book', bookSchema);\n      const Person = db.model('Person', personSchema);\n\n      const book1 = new Book({ title: 'The Jungle Book' });\n      const book2 = new Book({ title: '1984' });\n\n      const person = new Person({\n        name: 'Bob',\n        favorite: book1,\n        books: [book1, book2]\n      });\n\n      assert.equal(person.books[0].title, 'The Jungle Book');\n      assert.equal(person.books[1].title, '1984');\n    });\n\n    it('save twice with write concern (gh-5294)', function(done) {\n      const schema = new mongoose.Schema({\n        name: String\n      }, {\n        w: 'majority',\n        wtimeout: 1e4\n      });\n\n      const M = db.model('Test', schema);\n\n      M.create({ name: 'Test' }, function(error, doc) {\n        assert.ifError(error);\n        doc.name = 'test2';\n        doc.save(function(error) {\n          assert.ifError(error);\n          done();\n        });\n      });\n    });\n\n    it('undefined field with conditional required (gh-5296)', function(done) {\n      const schema = Schema({\n        name: {\n          type: String,\n          maxlength: 63,\n          required: function() {\n            return false;\n          }\n        }\n      });\n\n      const Model = db.model('Test', schema);\n\n      Model.create({ name: undefined }, function(error) {\n        assert.ifError(error);\n        done();\n      });\n    });\n\n    it('dotted virtuals in toObject (gh-5473)', function() {\n      const schema = new mongoose.Schema({}, {\n        toObject: { virtuals: true },\n        toJSON: { virtuals: true }\n      });\n      schema.virtual('test.a').get(function() {\n        return 1;\n      });\n      schema.virtual('test.b').get(function() {\n        return 2;\n      });\n\n      const Model = db.model('Test', schema);\n\n      const m = new Model({});\n      assert.deepEqual(m.toJSON().test, {\n        a: 1,\n        b: 2\n      });\n      assert.deepEqual(m.toObject().test, {\n        a: 1,\n        b: 2\n      });\n      assert.equal(m.toObject({ virtuals: false }).test, void 0);\n    });\n\n    it('dotted virtuals in toObject (gh-5506)', function(done) {\n      const childSchema = new Schema({\n        name: String,\n        _id: false\n      });\n      const parentSchema = new Schema({\n        child: {\n          type: childSchema,\n          default: {}\n        }\n      });\n\n      const Parent = db.model('Parent', parentSchema);\n\n      const p = new Parent({ child: { name: 'myName' } });\n\n      p.save().\n        then(function() {\n          return Parent.findOne();\n        }).\n        then(function(doc) {\n          doc.child = {};\n          return doc.save();\n        }).\n        then(function() {\n          return Parent.findOne();\n        }).\n        then(function(doc) {\n          assert.deepEqual(doc.toObject({ minimize: false }).child, {});\n          done();\n        }).\n        catch(done);\n    });\n\n    it('parent props not in child (gh-5470)', function() {\n      const employeeSchema = new mongoose.Schema({\n        name: {\n          first: String,\n          last: String\n        },\n        department: String\n      });\n      const Employee = db.model('Test', employeeSchema);\n\n      const employee = new Employee({\n        name: {\n          first: 'Ron',\n          last: 'Swanson'\n        },\n        department: 'Parks and Recreation'\n      });\n      const ownPropertyNames = Object.getOwnPropertyNames(employee.name);\n\n      assert.ok(ownPropertyNames.indexOf('department') === -1, ownPropertyNames.join(','));\n      assert.ok(ownPropertyNames.indexOf('first') !== -1, ownPropertyNames.join(','));\n      assert.ok(ownPropertyNames.indexOf('last') !== -1, ownPropertyNames.join(','));\n    });\n\n    it('modifying array with existing ids (gh-5523)', function(done) {\n      const friendSchema = new mongoose.Schema(\n        {\n          _id: String,\n          name: String,\n          age: Number,\n          dob: Date\n        },\n        { _id: false });\n\n      const socialSchema = new mongoose.Schema(\n        {\n          friends: [friendSchema]\n        },\n        { _id: false });\n\n      const userSchema = new mongoose.Schema({\n        social: {\n          type: socialSchema,\n          required: true\n        }\n      });\n\n      const User = db.model('User', userSchema);\n\n      const user = new User({\n        social: {\n          friends: [\n            { _id: 'val', age: 28 }\n          ]\n        }\n      });\n\n      user.social.friends = [{ _id: 'val', name: 'Val' }];\n\n      assert.deepEqual(user.toObject().social.friends[0], {\n        _id: 'val',\n        name: 'Val'\n      });\n\n      user.save(function(error) {\n        assert.ifError(error);\n        User.findOne({ _id: user._id }, function(error, doc) {\n          assert.ifError(error);\n          assert.deepEqual(doc.toObject().social.friends[0], {\n            _id: 'val',\n            name: 'Val'\n          });\n          done();\n        });\n      });\n    });\n\n    it('consistent setter context for single nested (gh-5363)', function(done) {\n      const contentSchema = new Schema({\n        blocks: [{ type: String }],\n        previous: [{ type: String }]\n      });\n\n      // Subdocument setter\n      const oldVals = [];\n      contentSchema.path('blocks').set(function(newVal, oldVal) {\n        if (!this.ownerDocument().isNew && oldVal != null) {\n          oldVals.push(oldVal.toObject());\n          this.set('previous', [].concat(oldVal.toObject()));\n        }\n\n        return newVal;\n      });\n\n      const noteSchema = new Schema({\n        title: { type: String, required: true },\n        body: contentSchema\n      });\n\n      const Note = db.model('Test', noteSchema);\n\n      const note = new Note({\n        title: 'Lorem Ipsum Dolor',\n        body: {\n          summary: 'Summary Test',\n          blocks: ['html']\n        }\n      });\n\n      note.save().\n        then(function(note) {\n          assert.equal(oldVals.length, 0);\n          note.set('body', {\n            blocks: ['gallery', 'html']\n          });\n          return note.save();\n        }).\n        then(function() {\n          assert.equal(oldVals.length, 1);\n          assert.deepEqual(oldVals[0], ['html']);\n          assert.deepEqual(note.body.previous, ['html']);\n          done();\n        }).\n        catch(done);\n    });\n\n    it('deeply nested subdocs and markModified (gh-5406)', function(done) {\n      const nestedValueSchema = new mongoose.Schema({\n        _id: false,\n        value: Number\n      });\n      const nestedPropertySchema = new mongoose.Schema({\n        _id: false,\n        active: Boolean,\n        nestedValue: nestedValueSchema\n      });\n      const nestedSchema = new mongoose.Schema({\n        _id: false,\n        nestedProperty: nestedPropertySchema,\n        nestedTwoProperty: nestedPropertySchema\n      });\n      const optionsSchema = new mongoose.Schema({\n        _id: false,\n        nestedField: nestedSchema\n      });\n      const TestSchema = new mongoose.Schema({\n        fieldOne: String,\n        options: optionsSchema\n      });\n\n      const Test = db.model('Test', TestSchema);\n\n      const doc = new Test({\n        fieldOne: 'Test One',\n        options: {\n          nestedField: {\n            nestedProperty: {\n              active: true,\n              nestedValue: {\n                value: 42\n              }\n            }\n          }\n        }\n      });\n\n      doc.\n        save().\n        then(function(doc) {\n          doc.options.nestedField.nestedTwoProperty = {\n            active: true,\n            nestedValue: {\n              value: 1337\n            }\n          };\n\n          assert.ok(doc.isModified('options'));\n\n          return doc.save();\n        }).\n        then(function(doc) {\n          return Test.findById(doc._id);\n        }).\n        then(function(doc) {\n          assert.equal(doc.options.nestedField.nestedTwoProperty.nestedValue.value,\n            1337);\n          done();\n        }).\n        catch(done);\n    });\n\n    it('single nested subdoc post remove hooks (gh-5388)', function(done) {\n      const contentSchema = new Schema({\n        blocks: [{ type: String }],\n        summary: { type: String }\n      });\n\n      let called = 0;\n\n      contentSchema.post('remove', function() {\n        ++called;\n      });\n\n      const noteSchema = new Schema({\n        body: { type: contentSchema }\n      });\n\n      const Note = db.model('Test', noteSchema);\n\n      const note = new Note({\n        title: 'Lorem Ipsum Dolor',\n        body: {\n          summary: 'Summary Test',\n          blocks: ['html']\n        }\n      });\n\n      note.save(function(error) {\n        assert.ifError(error);\n        note.remove(function(error) {\n          assert.ifError(error);\n          setTimeout(function() {\n            assert.equal(called, 1);\n            done();\n          }, 50);\n        });\n      });\n    });\n\n    it('push populated doc onto empty array triggers manual population (gh-5504)', function() {\n      const ReferringSchema = new Schema({\n        reference: [{\n          type: Schema.Types.ObjectId,\n          ref: 'Test'\n        }]\n      });\n\n      const Referrer = db.model('Test', ReferringSchema);\n\n      const referenceA = new Referrer();\n      const referenceB = new Referrer();\n\n      const referrerA = new Referrer({ reference: [referenceA] });\n      const referrerB = new Referrer();\n      const referrerC = new Referrer();\n      const referrerD = new Referrer();\n      const referrerE = new Referrer();\n\n      referrerA.reference.push(referenceB);\n      assert.ok(referrerA.reference[0] instanceof Referrer);\n      assert.ok(referrerA.reference[1] instanceof Referrer);\n\n      referrerB.reference.push(referenceB);\n      assert.ok(referrerB.reference[0] instanceof Referrer);\n\n      referrerC.reference.unshift(referenceB);\n      assert.ok(referrerC.reference[0] instanceof Referrer);\n\n      referrerD.reference.splice(0, 0, referenceB);\n      assert.ok(referrerD.reference[0] instanceof Referrer);\n\n      referrerE.reference.addToSet(referenceB);\n      assert.ok(referrerE.reference[0] instanceof Referrer);\n    });\n\n    it('single nested conditional required scope (gh-5569)', function(done) {\n      const scopes = [];\n\n      const ThingSchema = new mongoose.Schema({\n        undefinedDisallowed: {\n          type: String,\n          required: function() {\n            scopes.push(this);\n            return this.undefinedDisallowed === undefined;\n          },\n          default: null\n        }\n      });\n\n      const SuperDocumentSchema = new mongoose.Schema({\n        thing: {\n          type: ThingSchema,\n          default: function() { return {}; }\n        }\n      });\n\n      const SuperDocument = db.model('Test', SuperDocumentSchema);\n\n      let doc = new SuperDocument();\n      doc.thing.undefinedDisallowed = null;\n\n      doc.save(function(error) {\n        assert.ifError(error);\n        doc = new SuperDocument();\n        doc.thing.undefinedDisallowed = undefined;\n        doc.save(function(error) {\n          assert.ok(error);\n          assert.ok(error.errors['thing.undefinedDisallowed']);\n          done();\n        });\n      });\n    });\n\n    it('single nested setters only get called once (gh-5601)', function() {\n      const vals = [];\n      const ChildSchema = new mongoose.Schema({\n        number: {\n          type: String,\n          set: function(v) {\n            vals.push(v);\n            return v;\n          }\n        },\n        _id: false\n      });\n      ChildSchema.set('toObject', { getters: true, minimize: false });\n\n      const ParentSchema = new mongoose.Schema({\n        child: {\n          type: ChildSchema,\n          default: {}\n        }\n      });\n\n      const Parent = db.model('Parent', ParentSchema);\n      const p = new Parent();\n      p.child = { number: '555.555.0123' };\n      assert.equal(vals.length, 1);\n      assert.equal(vals[0], '555.555.0123');\n    });\n\n    it('single getters only get called once (gh-7442)', function() {\n      let called = 0;\n\n      const childSchema = new Schema({\n        value: {\n          type: String,\n          get: function(v) {\n            ++called;\n            return v;\n          }\n        }\n      });\n\n      const schema = new Schema({\n        name: childSchema\n      });\n      const Model = db.model('Test', schema);\n\n      const doc = new Model({ 'name.value': 'test' });\n\n      called = 0;\n\n      doc.toObject({ getters: true });\n      assert.equal(called, 1);\n\n      doc.toObject({ getters: false });\n      assert.equal(called, 1);\n    });\n\n    it('calls subdocument getters if child schema has getters: true (gh-12105)', function() {\n      let called = 0;\n\n      const childSchema = new Schema({\n        _id: false,\n        value: {\n          type: String,\n          get: function(v) {\n            ++called;\n            return v.toUpperCase();\n          }\n        }\n      }, { toJSON: { getters: true } });\n      const schema = new Schema({ name: childSchema });\n      const Test = db.model('Test', schema);\n\n      const doc = new Test({ name: { value: 'John Smith' } });\n\n      const res = doc.toJSON();\n      assert.equal(called, 1);\n      assert.deepStrictEqual(res.name, { value: 'JOHN SMITH' });\n    });\n\n    it('setting doc array to array of top-level docs works (gh-5632)', function(done) {\n      const MainSchema = new Schema({\n        name: { type: String },\n        children: [{\n          name: { type: String }\n        }]\n      });\n      const RelatedSchema = new Schema({ name: { type: String } });\n      const Model = db.model('Test', MainSchema);\n      const RelatedModel = db.model('Test1', RelatedSchema);\n\n      RelatedModel.create({ name: 'test' }, function(error, doc) {\n        assert.ifError(error);\n        Model.create({ name: 'test1', children: [doc] }, function(error, m) {\n          assert.ifError(error);\n          m.children = [doc];\n          m.save(function(error) {\n            assert.ifError(error);\n            assert.equal(m.children.length, 1);\n            assert.equal(m.children[0].name, 'test');\n            done();\n          });\n        });\n      });\n    });\n\n    it('Using set as a schema path (gh-1939)', function(done) {\n      const testSchema = new Schema({ set: String });\n\n      const Test = db.model('Test', testSchema);\n\n      const t = new Test({ set: 'test 1' });\n      assert.equal(t.set, 'test 1');\n      t.save(function(error) {\n        assert.ifError(error);\n        t.set = 'test 2';\n        t.save(function(error) {\n          assert.ifError(error);\n          assert.equal(t.set, 'test 2');\n          done();\n        });\n      });\n    });\n\n    it('handles array defaults correctly (gh-5780)', function() {\n      const testSchema = new Schema({\n        nestedArr: {\n          type: [[Number]],\n          default: [[0, 1]]\n        }\n      });\n\n      const Test = db.model('Test', testSchema);\n\n      const t = new Test({});\n      assert.deepEqual(t.toObject().nestedArr, [[0, 1]]);\n\n      t.nestedArr.push([1, 2]);\n      const t2 = new Test({});\n      assert.deepEqual(t2.toObject().nestedArr, [[0, 1]]);\n    });\n\n    it('sets path to the empty string on save after query (gh-6477)', async function() {\n      const schema = new Schema({\n        name: String,\n        s: {\n          type: String,\n          default: ''\n        }\n      });\n\n      const Test = db.model('Test', schema);\n\n      const test = new Test();\n      assert.strictEqual(test.s, '');\n\n      // use native driver directly to insert an empty doc\n      await Test.collection.insertOne({});\n\n      // udate the doc with the expectation that default booleans will be saved.\n      const found = await Test.findOne({});\n      found.name = 'Max';\n      await found.save();\n\n      // use native driver directly to check doc for saved string\n      const final = await Test.collection.findOne({});\n      assert.strictEqual(final.name, 'Max');\n      assert.strictEqual(final.s, '');\n    });\n\n    it('sets path to the default boolean on save after query (gh-6477)', async function() {\n      const schema = new Schema({\n        name: String,\n        f: {\n          type: Boolean,\n          default: false\n        },\n        t: {\n          type: Boolean,\n          default: true\n        }\n      });\n\n      const Test = db.model('Test', schema);\n\n      // use native driver directly to kill the fields\n      await Test.collection.insertOne({});\n\n      // udate the doc with the expectation that default booleans will be saved.\n      const found = await Test.findOne({});\n      found.name = 'Britney';\n      await found.save();\n\n      // use native driver directly to check doc for saved string\n      const final = await Test.collection.findOne({});\n      assert.strictEqual(final.name, 'Britney');\n      assert.strictEqual(final.t, true);\n      assert.strictEqual(final.f, false);\n    });\n\n    it('virtuals with no getters return undefined (gh-6223)', function() {\n      const personSchema = new mongoose.Schema({\n        name: { type: String },\n        children: [{\n          name: { type: String }\n        }]\n      }, {\n        toObject: { getters: true, virtuals: true },\n        toJSON: { getters: true, virtuals: true },\n        id: false\n      });\n\n      personSchema.virtual('favoriteChild').set(function(v) {\n        return this.set('children.0', v);\n      });\n\n      personSchema.virtual('heir').get(function() {\n        return this.get('children.0');\n      });\n\n      const Person = db.model('Person', personSchema);\n\n      const person = new Person({\n        name: 'Anakin'\n      });\n\n      assert.strictEqual(person.favoriteChild, void 0);\n      assert.ok(!('favoriteChild' in person.toJSON()));\n      assert.ok(!('favoriteChild' in person.toObject()));\n    });\n\n    it('add default getter/setter (gh-6262)', function() {\n      const testSchema = new mongoose.Schema({});\n\n      testSchema.virtual('totalValue');\n\n      const Test = db.model('Test', testSchema);\n\n      assert.equal(Test.schema.virtuals.totalValue.getters.length, 1);\n      assert.equal(Test.schema.virtuals.totalValue.setters.length, 1);\n\n      const doc = new Test();\n      doc.totalValue = 5;\n      assert.equal(doc.totalValue, 5);\n    });\n\n    it('calls array getters (gh-9889)', function() {\n      let called = 0;\n      const testSchema = new mongoose.Schema({\n        arr: [{\n          type: 'ObjectId',\n          ref: 'Doesnt Matter',\n          get: () => {\n            ++called;\n            return 42;\n          }\n        }]\n      });\n\n      const Test = db.model('Test', testSchema);\n\n      const doc = new Test({ arr: [new mongoose.Types.ObjectId()] });\n      assert.deepEqual(doc.toObject({ getters: true }).arr, [42]);\n      assert.equal(called, 1);\n    });\n\n    it('doesnt call setters when init-ing an array (gh-9889)', async function() {\n      let called = 0;\n      const testSchema = new mongoose.Schema({\n        arr: [{\n          type: 'ObjectId',\n          set: v => {\n            ++called;\n            return v;\n          }\n        }]\n      });\n\n      const Test = db.model('Test', testSchema);\n\n\n      let doc = await Test.create({ arr: [new mongoose.Types.ObjectId()] });\n      assert.equal(called, 1);\n\n      called = 0;\n      doc = await Test.findById(doc._id);\n      assert.ok(doc);\n      assert.equal(called, 0);\n    });\n\n    it('nested virtuals + nested toJSON (gh-6294)', function() {\n      const schema = mongoose.Schema({\n        nested: {\n          prop: String\n        }\n      }, { _id: false, id: false });\n\n      schema.virtual('nested.virtual').get(() => 'test 2');\n\n      schema.set('toJSON', {\n        virtuals: true\n      });\n\n      const MyModel = db.model('Test', schema);\n\n      const doc = new MyModel({ nested: { prop: 'test 1' } });\n\n      assert.deepEqual(doc.toJSON(), {\n        nested: { prop: 'test 1', virtual: 'test 2' }\n      });\n      assert.deepEqual(doc.nested.toJSON(), {\n        prop: 'test 1', virtual: 'test 2'\n      });\n    });\n\n    it('Disallows writing to __proto__ and other special properties', function() {\n      const schema = new mongoose.Schema({\n        name: String\n      }, { strict: false });\n\n      const Model = db.model('Test', schema);\n      const doc = new Model({ '__proto__.x': 'foo' });\n\n      assert.strictEqual(Model.x, void 0);\n      doc.set('__proto__.y', 'bar');\n\n      assert.strictEqual(Model.y, void 0);\n\n      doc.set('constructor.prototype.z', 'baz');\n\n      assert.strictEqual(Model.z, void 0);\n    });\n\n    it('save() depopulates pushed arrays (gh-6048)', async function() {\n      const blogPostSchema = new Schema({\n        comments: [{\n          type: mongoose.Schema.Types.ObjectId,\n          ref: 'Comment'\n        }]\n      });\n\n      const BlogPost = db.model('BlogPost', blogPostSchema);\n\n      const commentSchema = new Schema({\n        text: String\n      });\n\n      const Comment = db.model('Comment', commentSchema);\n\n\n      let blogPost = await BlogPost.create({});\n      const comment = await Comment.create({ text: 'Hello' });\n\n      blogPost = await BlogPost.findById(blogPost);\n      blogPost.comments.push(comment);\n      await blogPost.save();\n\n      const savedBlogPost = await BlogPost.collection.\n        findOne({ _id: blogPost._id });\n      assert.equal(savedBlogPost.comments.length, 1);\n      assert.equal(savedBlogPost.comments[0].constructor.name, 'ObjectId');\n      assert.equal(savedBlogPost.comments[0].toString(),\n        blogPost.comments[0]._id.toString());\n    });\n\n    it('Handles setting populated path set via `Document#populate()` (gh-7302)', function() {\n      const authorSchema = new Schema({ name: String });\n      const bookSchema = new Schema({\n        author: { type: mongoose.Schema.Types.ObjectId, ref: 'Author' }\n      });\n\n      const Author = db.model('Author', authorSchema);\n      const Book = db.model('Book', bookSchema);\n\n      return Author.create({ name: 'Victor Hugo' }).\n        then(function(author) { return Book.create({ author: author._id }); }).\n        then(function() { return Book.findOne(); }).\n        then(function(doc) { return doc.populate('author'); }).\n        then(function(doc) {\n          doc.author = {};\n          assert.ok(!doc.author.name);\n          assert.ifError(doc.validateSync());\n        });\n    });\n\n    it('Single nested subdocs using discriminator can be modified (gh-5693)', function(done) {\n      const eventSchema = new Schema({ message: String }, {\n        discriminatorKey: 'kind',\n        _id: false\n      });\n\n      const trackSchema = new Schema({ event: eventSchema });\n\n      trackSchema.path('event').discriminator('Clicked', new Schema({\n        element: String\n      }, { _id: false }));\n\n      trackSchema.path('event').discriminator('Purchased', new Schema({\n        product: String\n      }, { _id: false }));\n\n      const MyModel = db.model('Test', trackSchema);\n\n      const doc = new MyModel({\n        event: {\n          message: 'Test',\n          kind: 'Clicked',\n          element: 'Amazon Link'\n        }\n      });\n\n      doc.save(function(error) {\n        assert.ifError(error);\n        assert.equal(doc.event.message, 'Test');\n        assert.equal(doc.event.kind, 'Clicked');\n        assert.equal(doc.event.element, 'Amazon Link');\n\n        doc.set('event', {\n          kind: 'Purchased',\n          product: 'Professional AngularJS'\n        });\n\n        doc.save(function(error) {\n          assert.ifError(error);\n          assert.equal(doc.event.kind, 'Purchased');\n          assert.equal(doc.event.product, 'Professional AngularJS');\n          assert.ok(!doc.event.element);\n          assert.ok(!doc.event.message);\n          done();\n        });\n      });\n    });\n\n    it('required function only gets called once (gh-6801)', function() {\n      let reqCount = 0;\n      const childSchema = new Schema({\n        name: {\n          type: String,\n          required: function() {\n            reqCount++;\n            return true;\n          }\n        }\n      });\n      const Child = db.model('Child', childSchema);\n\n      const parentSchema = new Schema({\n        name: String,\n        child: childSchema\n      });\n      const Parent = db.model('Parent', parentSchema);\n\n      const child = new Child(/* name is required */);\n      const parent = new Parent({ child: child });\n\n      return parent.validate().then(\n        () => assert.ok(false),\n        error => {\n          assert.equal(reqCount, 1);\n          assert.ok(error.errors['child.name']);\n        }\n      );\n    });\n\n    it('required function called again after save() (gh-6892)', async function() {\n      const schema = new mongoose.Schema({\n        field: {\n          type: String,\n          default: null,\n          required: function() { return this && this.field === undefined; }\n        }\n      });\n      const Model = db.model('Test', schema);\n\n\n      await Model.create({});\n      const doc1 = await Model.findOne({}).select({ _id: 1 });\n      await doc1.save();\n\n      // Should not throw\n      await Model.create({});\n    });\n\n    it('doc array: set then remove (gh-3511)', function(done) {\n      const ItemChildSchema = new mongoose.Schema({\n        name: {\n          type: String,\n          required: true\n        }\n      });\n\n      const ItemParentSchema = new mongoose.Schema({\n        children: [ItemChildSchema]\n      });\n\n      const ItemParent = db.model('Parent', ItemParentSchema);\n\n      const p = new ItemParent({\n        children: [{ name: 'test1' }, { name: 'test2' }]\n      });\n\n      p.save(function(error) {\n        assert.ifError(error);\n        ItemParent.findById(p._id, function(error, doc) {\n          assert.ifError(error);\n          assert.ok(doc);\n          assert.equal(doc.children.length, 2);\n\n          doc.children[1].name = 'test3';\n          doc.children.remove(doc.children[0]);\n\n          doc.save(function(error) {\n            assert.ifError(error);\n            ItemParent.findById(doc._id, function(error, doc) {\n              assert.ifError(error);\n              assert.equal(doc.children.length, 1);\n              assert.equal(doc.children[0].name, 'test3');\n              done();\n            });\n          });\n        });\n      });\n    });\n\n    it('doc array: modify then sort (gh-7556)', async function() {\n      const assetSchema = new Schema({\n        name: { type: String, required: true },\n        namePlural: { type: String, required: true }\n      });\n      assetSchema.pre('validate', function() {\n        if (this.isNew) {\n          this.namePlural = this.name + 's';\n        }\n      });\n      const personSchema = new Schema({\n        name: String,\n        assets: [assetSchema]\n      });\n\n      const Person = db.model('Person', personSchema);\n\n      await Person.create({\n        name: 'test',\n        assets: [{ name: 'Cash', namePlural: 'Cash' }]\n      });\n      const p = await Person.findOne();\n\n      p.assets.push({ name: 'Home' });\n      p.assets.id(p.assets[0].id).set('name', 'Cash');\n      p.assets.id(p.assets[0].id).set('namePlural', 'Cash');\n\n      p.assets.sort((doc1, doc2) => doc1.name > doc2.name ? -1 : 1);\n\n      await p.save();\n    });\n\n    it('modifying unselected nested object (gh-5800)', function() {\n      const MainSchema = new mongoose.Schema({\n        a: {\n          b: { type: String, default: 'some default' },\n          c: { type: Number, default: 0 },\n          d: { type: String }\n        },\n        e: { type: String }\n      });\n\n      MainSchema.pre('save', function(next) {\n        if (this.isModified()) {\n          this.set('a.c', 100, Number);\n        }\n        next();\n      });\n\n      const Main = db.model('Test', MainSchema);\n\n      const doc = { a: { b: 'not the default', d: 'some value' }, e: 'e' };\n      return Main.create(doc).\n        then(function(doc) {\n          assert.equal(doc.a.b, 'not the default');\n          assert.equal(doc.a.d, 'some value');\n          return Main.findOne().select('e');\n        }).\n        then(function(doc) {\n          doc.e = 'e modified';\n          return doc.save();\n        }).\n        then(function() {\n          return Main.findOne();\n        }).\n        then(function(doc) {\n          assert.equal(doc.a.b, 'not the default');\n          assert.equal(doc.a.d, 'some value');\n        });\n    });\n\n    it('set() underneath embedded discriminator (gh-6482)', async function() {\n      const mediaSchema = new Schema({ file: String },\n        { discriminatorKey: 'kind', _id: false });\n\n      const photoSchema = new Schema({ position: String });\n      const pageSchema = new Schema({ media: mediaSchema });\n\n      pageSchema.path('media').discriminator('photo', photoSchema);\n\n      const Page = db.model('Test', pageSchema);\n\n\n      let doc = await Page.create({\n        media: { kind: 'photo', file: 'cover.jpg', position: 'left' }\n      });\n\n      // Using positional args syntax\n      doc.set('media.position', 'right');\n      assert.equal(doc.media.position, 'right');\n\n      await doc.save();\n\n      doc = await Page.findById(doc._id);\n      assert.equal(doc.media.position, 'right');\n\n      // Using object syntax\n      doc.set({ 'media.position': 'left' });\n      assert.equal(doc.media.position, 'left');\n\n      await doc.save();\n\n      doc = await Page.findById(doc._id);\n      assert.equal(doc.media.position, 'left');\n    });\n\n    it('set() underneath array embedded discriminator (gh-6526)', async function() {\n      const mediaSchema = new Schema({ file: String },\n        { discriminatorKey: 'kind', _id: false });\n\n      const photoSchema = new Schema({ position: String });\n      const pageSchema = new Schema({ media: [mediaSchema] });\n\n      pageSchema.path('media').discriminator('photo', photoSchema);\n\n      const Page = db.model('Test', pageSchema);\n\n\n      let doc = await Page.create({\n        media: [{ kind: 'photo', file: 'cover.jpg', position: 'left' }]\n      });\n\n      // Using positional args syntax\n      doc.set('media.0.position', 'right');\n      assert.equal(doc.media[0].position, 'right');\n\n      await doc.save();\n\n      doc = await Page.findById(doc._id);\n      assert.equal(doc.media[0].position, 'right');\n    });\n\n    it('consistent context for nested docs (gh-5347)', function(done) {\n      const contexts = [];\n      const childSchema = new mongoose.Schema({\n        phoneNumber: {\n          type: String,\n          required: function() {\n            contexts.push(this);\n            return this.notifications.isEnabled;\n          }\n        },\n        notifications: {\n          isEnabled: { type: Boolean, required: true }\n        }\n      });\n\n      const parentSchema = new mongoose.Schema({\n        name: String,\n        children: [childSchema]\n      });\n\n      const Parent = db.model('Parent', parentSchema);\n\n      Parent.create({\n        name: 'test',\n        children: [\n          {\n            phoneNumber: '123',\n            notifications: {\n              isEnabled: true\n            }\n          }\n        ]\n      }, function(error, doc) {\n        assert.ifError(error);\n        const child = doc.children.id(doc.children[0]._id);\n        child.phoneNumber = '345';\n        assert.equal(contexts.length, 1);\n        doc.save(function(error) {\n          assert.ifError(error);\n          assert.equal(contexts.length, 2);\n          assert.ok(contexts[0].toObject().notifications.isEnabled);\n          assert.ok(contexts[1].toObject().notifications.isEnabled);\n          done();\n        });\n      });\n    });\n\n    it('accessing arrays in setters on initial document creation (gh-6155)', function() {\n      const artistSchema = new mongoose.Schema({\n        name: {\n          type: String,\n          set: function(v) {\n            const splitStrings = v.split(' ');\n            for (const keyword of splitStrings) {\n              this.keywords.push(keyword);\n            }\n            return v;\n          }\n        },\n        keywords: [String]\n      });\n\n      const Artist = db.model('Test', artistSchema);\n\n      const artist = new Artist({ name: 'Motley Crue' });\n      assert.deepEqual(artist.toObject().keywords, ['Motley', 'Crue']);\n    });\n\n    it('handles 2nd level nested field with null child (gh-6187)', function() {\n      const NestedSchema = new Schema({\n        parent: new Schema({\n          name: String,\n          child: {\n            name: String\n          }\n        }, { strict: false })\n      });\n      const NestedModel = db.model('Test', NestedSchema);\n      const n = new NestedModel({\n        parent: {\n          name: 'foo',\n          child: null // does not fail if undefined\n        }\n      });\n\n      assert.equal(n.parent.name, 'foo');\n    });\n\n    it('does not call default function on init if value set (gh-6410)', async function() {\n      let called = 0;\n\n      function generateRandomID() {\n        called++;\n        return called;\n      }\n\n      const TestDefaultsWithFunction = db.model('Test', new Schema({\n        randomID: { type: Number, default: generateRandomID }\n      }));\n\n      const post = new TestDefaultsWithFunction();\n      assert.equal(post.get('randomID'), 1);\n      assert.equal(called, 1);\n\n\n      await post.save();\n\n      await TestDefaultsWithFunction.findById(post._id);\n\n      assert.equal(called, 1);\n    });\n\n    describe('convertToFalse and convertToTrue (gh-6758)', function() {\n      let convertToFalse = null;\n      let convertToTrue = null;\n\n      beforeEach(function() {\n        convertToFalse = new Set(mongoose.Schema.Types.Boolean.convertToFalse);\n        convertToTrue = new Set(mongoose.Schema.Types.Boolean.convertToTrue);\n      });\n\n      afterEach(function() {\n        mongoose.Schema.Types.Boolean.convertToFalse = convertToFalse;\n        mongoose.Schema.Types.Boolean.convertToTrue = convertToTrue;\n      });\n\n      it('lets you add custom strings that get converted to true/false', function() {\n        const TestSchema = new Schema({ b: Boolean });\n        const Test = db.model('Test', TestSchema);\n\n        mongoose.Schema.Types.Boolean.convertToTrue.add('aye');\n        mongoose.Schema.Types.Boolean.convertToFalse.add('nay');\n\n        const doc1 = new Test({ b: 'aye' });\n        const doc2 = new Test({ b: 'nay' });\n\n        assert.strictEqual(doc1.b, true);\n        assert.strictEqual(doc2.b, false);\n\n        return doc1.save().\n          then(() => Test.findOne({ b: { $exists: 'aye' } })).\n          then(doc => assert.ok(doc)).\n          then(() => {\n            mongoose.Schema.Types.Boolean.convertToTrue.delete('aye');\n            mongoose.Schema.Types.Boolean.convertToFalse.delete('nay');\n          });\n      });\n\n      it('allows adding `null` to list of values that convert to false (gh-9223)', function() {\n        const TestSchema = new Schema({ b: Boolean });\n        const Test = db.model('Test', TestSchema);\n\n        mongoose.Schema.Types.Boolean.convertToFalse.add(null);\n\n        const doc1 = new Test({ b: null });\n        const doc2 = new Test();\n        doc2.init({ b: null });\n\n        assert.strictEqual(doc1.b, false);\n        assert.strictEqual(doc2.b, false);\n      });\n    });\n\n    it('doesnt double-call getters when using get() (gh-6779)', function() {\n      const schema = new Schema({\n        nested: {\n          arr: [{ key: String }]\n        }\n      });\n\n      schema.path('nested.arr.0.key').get(v => {\n        return 'foobar' + v;\n      });\n\n      const M = db.model('Test', schema);\n      const test = new M();\n\n      test.nested.arr.push({ key: 'value' });\n      test.nested.arr.push({ key: 'value2' });\n\n      assert.equal(test.get('nested.arr.0.key'), 'foobarvalue');\n      assert.equal(test.get('nested.arr.1.key'), 'foobarvalue2');\n\n      return Promise.resolve();\n    });\n\n    it('returns doubly nested field in inline sub schema when using get() (gh-6925)', function() {\n      const child = new Schema({\n        nested: {\n          key: String\n        }\n      });\n      const parent = new Schema({\n        child: child\n      });\n\n      const M = db.model('Test', parent);\n      const test = new M({\n        child: {\n          nested: {\n            key: 'foobarvalue'\n          }\n        }\n      });\n\n      assert.equal(test.get('child.nested.key'), 'foobarvalue');\n\n      return Promise.resolve();\n    });\n\n    it('defaults should see correct isNew (gh-3793)', async function() {\n      let isNew = [];\n      const TestSchema = new mongoose.Schema({\n        test: {\n          type: Date,\n          default: function() {\n            isNew.push(this.isNew);\n            if (this.isNew) {\n              return Date.now();\n            }\n            return void 0;\n          }\n        }\n      });\n\n      const TestModel = db.model('Test', TestSchema);\n\n\n      await Promise.resolve(db);\n\n      await TestModel.collection.insertOne({});\n\n      let doc = await TestModel.findOne({});\n      assert.strictEqual(doc.test, void 0);\n      assert.deepEqual(isNew, [false]);\n\n      isNew = [];\n\n      doc = await TestModel.create({});\n      assert.ok(doc.test instanceof Date);\n      assert.deepEqual(isNew, [true]);\n    });\n\n    it('modify multiple subdoc paths (gh-4405)', function(done) {\n      const ChildObjectSchema = new Schema({\n        childProperty1: String,\n        childProperty2: String,\n        childProperty3: String\n      });\n\n      const ParentObjectSchema = new Schema({\n        parentProperty1: String,\n        parentProperty2: String,\n        child: ChildObjectSchema\n      });\n\n      const Parent = db.model('Parent', ParentObjectSchema);\n\n      const p = new Parent({\n        parentProperty1: 'abc',\n        parentProperty2: '123',\n        child: {\n          childProperty1: 'a',\n          childProperty2: 'b',\n          childProperty3: 'c'\n        }\n      });\n      p.save(function(error) {\n        assert.ifError(error);\n        Parent.findById(p._id, function(error, p) {\n          assert.ifError(error);\n          p.parentProperty1 = 'foo';\n          p.parentProperty2 = 'bar';\n          p.child.childProperty1 = 'ping';\n          p.child.childProperty2 = 'pong';\n          p.child.childProperty3 = 'weee';\n          p.save(function(error) {\n            assert.ifError(error);\n            Parent.findById(p._id, function(error, p) {\n              assert.ifError(error);\n              assert.equal(p.child.childProperty1, 'ping');\n              assert.equal(p.child.childProperty2, 'pong');\n              assert.equal(p.child.childProperty3, 'weee');\n              done();\n            });\n          });\n        });\n      });\n    });\n\n    it('doesnt try to cast populated embedded docs (gh-6390)', async function() {\n      const otherSchema = new Schema({\n        name: String\n      });\n\n      const subSchema = new Schema({\n        my: String,\n        other: {\n          type: Schema.Types.ObjectId,\n          refPath: 'sub.my'\n        }\n      });\n\n      const schema = new Schema({\n        name: String,\n        sub: subSchema\n      });\n\n      const Other = db.model('Test1', otherSchema);\n      const Test = db.model('Test', schema);\n\n      const other = new Other({ name: 'Nicole' });\n\n      const test = new Test({\n        name: 'abc',\n        sub: {\n          my: 'Test1',\n          other: other._id\n        }\n      });\n\n      await other.save();\n      await test.save();\n      const doc = await Test.findOne({}).populate('sub.other');\n      assert.strictEqual('Nicole', doc.sub.other.name);\n\n    });\n  });\n\n  describe('clobbered Array.prototype', function() {\n    beforeEach(() => db.deleteModel(/.*/));\n\n    afterEach(function() {\n      delete Array.prototype.remove;\n    });\n\n    it('handles clobbered Array.prototype.remove (gh-6431)', function() {\n      Object.defineProperty(Array.prototype, 'remove', {\n        value: 42,\n        configurable: true,\n        writable: false\n      });\n\n      const schema = new Schema({ arr: [{ name: String }] });\n      const MyModel = db.model('Test', schema);\n\n      const doc = new MyModel();\n      assert.deepEqual(doc.toObject().arr, []);\n    });\n\n    it('calls array validators again after save (gh-6818)', async function() {\n      const schema = new Schema({\n        roles: {\n          type: [{\n            name: String,\n            folders: {\n              type: [{ folderId: String }],\n              validate: v => assert.ok(v.length === new Set(v.map(el => el.folderId)).size, 'Duplicate')\n            }\n          }]\n        }\n      });\n      const Model = db.model('Test', schema);\n\n      await Model.create({\n        roles: [\n          { name: 'admin' },\n          { name: 'mod', folders: [{ folderId: 'foo' }] }\n        ]\n      });\n\n      const doc = await Model.findOne();\n\n      doc.roles[1].folders.push({ folderId: 'bar' });\n\n      await doc.save();\n\n      doc.roles[1].folders[1].folderId = 'foo';\n      let threw = false;\n      try {\n        await doc.save();\n      } catch (error) {\n        threw = true;\n        assert.equal(error.errors['roles.1.folders'].reason.message, 'Duplicate');\n      }\n      assert.ok(threw);\n    });\n\n    it('set single nested to num throws ObjectExpectedError (gh-6710) (gh-6753)', function() {\n      const schema = new Schema({\n        nested: new Schema({\n          num: Number\n        })\n      });\n\n      const Test = db.model('Test', schema);\n\n      const doc = new Test({ nested: { num: 123 } });\n      doc.nested = 123;\n\n      return doc.validate().\n        then(() => { throw new Error('Should have errored'); }).\n        catch(err => {\n          assert.ok(err.message.indexOf('Cast to Embedded') !== -1, err.message);\n          assert.equal(err.errors['nested'].reason.name, 'ObjectExpectedError');\n\n          const doc = new Test({ nested: { num: 123 } });\n          doc.nested = [];\n          return doc.validate();\n        }).\n        then(() => { throw new Error('Should have errored'); }).\n        catch(err => {\n          assert.ok(err.message.indexOf('Cast to Embedded') !== -1, err.message);\n          assert.equal(err.errors['nested'].reason.name, 'ObjectExpectedError');\n        });\n    });\n\n    it('set array to false throws ObjectExpectedError (gh-7242)', function() {\n      const Child = new mongoose.Schema({});\n      const Parent = new mongoose.Schema({\n        children: [Child]\n      });\n      const ParentModel = db.model('Parent', Parent);\n      const doc = new ParentModel({ children: false });\n\n      return doc.save().then(\n        () => assert.ok(false),\n        err => {\n          assert.ok(err.errors['children']);\n          assert.equal(err.errors['children'].name, 'ObjectParameterError');\n        }\n      );\n    });\n  });\n\n  it('does not save duplicate items after two saves (gh-6900)', async function() {\n    const M = db.model('Test', { items: [{ name: String }] });\n    const doc = new M();\n    doc.items.push({ name: '1' });\n\n\n    await doc.save();\n    doc.items.push({ name: '2' });\n    await doc.save();\n\n    const found = await M.findById(doc.id);\n    assert.equal(found.items.length, 2);\n  });\n\n  it('validateSync() on embedded doc (gh-6931)', async function() {\n    const innerSchema = new mongoose.Schema({\n      innerField: {\n        type: mongoose.Schema.Types.ObjectId,\n        required: true\n      }\n    });\n\n    const schema = new mongoose.Schema({\n      field: {\n        type: mongoose.Schema.Types.ObjectId,\n        required: true\n      },\n      inner: [innerSchema]\n    });\n\n    const Model = db.model('Test', schema);\n\n\n    const doc2 = new Model();\n    doc2.field = new mongoose.Types.ObjectId();\n    doc2.inner.push({\n      innerField: new mongoose.Types.ObjectId()\n    });\n    doc2.inner[0].innerField = '';\n\n    let err = doc2.inner[0].validateSync();\n    assert.ok(err);\n    assert.ok(err.errors['innerField']);\n\n    err = await doc2.inner[0].validate().then(() => assert.ok(false), err => err);\n    assert.ok(err);\n    assert.ok(err.errors['innerField']);\n  });\n\n  it('retains user-defined key order with nested docs (gh-6944)', function() {\n    const schema = new Schema({\n      _id: String,\n      foo: String,\n      bar: {\n        a: String\n      }\n    });\n\n    const Model = db.model('Test', schema);\n\n    const doc = new Model({ _id: 'test', foo: 'hello', bar: { a: 'world' } });\n\n    // Same order as in the initial set above\n    assert.deepEqual(Object.keys(doc._doc), ['_id', 'foo', 'bar']);\n\n    return Promise.resolve();\n  });\n\n  it('does not mark modified if setting nested subdoc to same value (gh-7048)', async function() {\n    const BarSchema = new Schema({ bar: String }, { _id: false });\n    const FooNestedSchema = new Schema({ foo: BarSchema });\n\n    const Model = db.model('Test', FooNestedSchema);\n\n\n    const doc = await Model.create({ foo: { bar: 'test' } });\n    doc.set({ foo: { bar: 'test' } });\n\n    assert.deepEqual(doc.modifiedPaths(), []);\n\n    doc.set('foo.bar', 'test');\n\n    assert.deepEqual(doc.modifiedPaths(), []);\n  });\n\n  it('allow saving validation error in db (gh-7127)', async function() {\n\n    const schema = new Schema({\n      error: mongoose.Schema.Types.Mixed,\n      name: { type: String, required: true }\n    });\n    const Model = db.model('Test', schema);\n\n    const doc = new Model();\n\n    const error = await doc.validate().catch(error => error);\n\n    doc.name = 'foo';\n    doc.error = error;\n\n    await doc.save();\n\n    const fromDb = await Model.findOne();\n    assert.ok(fromDb.error.errors.name);\n  });\n\n  it('handles mixed arrays with all syntaxes (gh-7109)', function() {\n    const schema = new Schema({\n      arr1: [Schema.Types.Mixed],\n      arr2: [{}],\n      arr3: [Object]\n    });\n\n    const Test = db.model('Test', schema);\n\n    const test = new Test({\n      arr1: ['test1', { two: 'three' }, [4, 'five', 6]],\n      arr2: ['test2', { three: 'four' }, [5, 'six', 7]],\n      arr3: ['test3', { four: 'five' }, [6, 'seven', 8]]\n    });\n\n    assert.ok(test.validateSync() == null, test.validateSync());\n\n    return Promise.resolve();\n  });\n\n  it('propsParameter option (gh-7145)', async function() {\n    const schema = new Schema({\n      name: {\n        type: String,\n        validate: {\n          validator: (v, props) => props.validator != null,\n          propsParameter: true\n        }\n      }\n    });\n\n    const Test = db.model('Test', schema);\n\n    const doc = new Test({ name: 'foo' });\n    const syncValidationError = doc.validateSync();\n    assert.ok(syncValidationError == null, syncValidationError);\n\n\n    const asyncValidationError = await doc.validate().then(() => null, err => err);\n\n    assert.ok(asyncValidationError == null, asyncValidationError);\n  });\n\n  it('surfaces errors in subdoc pre validate (gh-7187)', function() {\n    const InnerSchema = new Schema({ name: String });\n\n    InnerSchema.pre('validate', function() {\n      throw new Error('Oops!');\n    });\n\n    const TestSchema = new Schema({ subdocs: [InnerSchema] });\n\n    const Test = db.model('Test', TestSchema);\n\n    return Test.create({ subdocs: [{ name: 'foo' }] }).then(\n      () => { throw new Error('Fail'); },\n      err => { assert.ok(err.message.indexOf('Oops!') !== -1, err.message); }\n    );\n  });\n\n  it('runs setter only once when doing .set() underneath single nested (gh-7196)', function() {\n    let called = [];\n    const InnerSchema = new Schema({\n      name: String,\n      withSetter: {\n        type: String,\n        set: function(v) {\n          called.push(this);\n          return v;\n        }\n      }\n    });\n\n    const TestSchema = new Schema({ nested: InnerSchema });\n\n    const Model = db.model('Test', TestSchema);\n\n    const doc = new Model({ nested: { name: 'foo' } });\n\n    // Make sure setter only gets called once\n    called = [];\n    doc.set('nested.withSetter', 'bar');\n\n    assert.equal(called.length, 1);\n    assert.equal(called[0].name, 'foo');\n\n    return Promise.resolve();\n  });\n\n  it('should enable key with dot(.) on mixed types with checkKeys (gh-7144)', async function() {\n    const s = new Schema({ raw: { type: Schema.Types.Mixed } });\n    const M = db.model('Test', s);\n\n    const raw = { 'foo.bar': 'baz' };\n\n\n    let doc = await M.create([{ raw: raw }], { checkKeys: false }).\n      then(res => res[0]);\n    assert.deepEqual(doc.raw, raw);\n\n    doc = await M.findOneAndUpdate({}, { raw: { 'a.b': 2 } }, { new: true });\n    assert.deepEqual(doc.raw, { 'a.b': 2 });\n  });\n\n  it('doesnt mark array as modified on init if embedded schema has default (gh-7227)', async function() {\n    const subSchema = new mongoose.Schema({\n      users: {\n        type: [{ name: { type: String } }],\n        // This test ensures the whole array won't be modified on init because\n        // of this default\n        default: [{ name: 'test' }]\n      }\n    });\n\n    const schema = new mongoose.Schema({\n      sub: [subSchema]\n    });\n    const Model = db.model('Test', schema);\n\n\n    let doc = new Model({ name: 'test', sub: [{}] });\n    await doc.save();\n\n    assert.ok(!doc.isModified());\n\n    doc = await Model.findOne();\n    assert.ok(!doc.isModified());\n  });\n\n  it('casts defaults for doc arrays (gh-7337)', async function() {\n    const accountSchema = new mongoose.Schema({\n      roles: {\n        type: [{\n          otherProperties: {\n            example: Boolean\n          },\n          name: String\n        }],\n        default: function() {\n          return [\n            { otherProperties: { example: true }, name: 'First' },\n            { otherProperties: { example: false }, name: 'Second' }\n          ];\n        }\n      }\n    });\n\n    const Account = db.model('Test', accountSchema);\n\n\n    await Account.create({});\n\n    const doc = await Account.findOne();\n\n    assert.ok(doc.roles[0]._id);\n    assert.ok(doc.roles[1]._id);\n  });\n\n  it('updateOne() hooks (gh-7133) (gh-7423)', async function() {\n    const schema = new mongoose.Schema({ name: String });\n\n    let queryCount = 0;\n    let docCount = 0;\n    let docPostCount = 0;\n\n    let docRegexCount = 0;\n    let docPostRegexCount = 0;\n\n    schema.pre('updateOne', () => ++queryCount);\n    schema.pre('updateOne', { document: true, query: false }, () => ++docCount);\n    schema.post('updateOne', { document: true, query: false }, () => ++docPostCount);\n\n    schema.pre(/^updateOne$/, { document: true, query: false }, () => ++docRegexCount);\n    schema.post(/^updateOne$/, { document: true, query: false }, () => ++docPostRegexCount);\n\n    let removeCount1 = 0;\n    let removeCount2 = 0;\n    schema.pre('remove', () => ++removeCount1);\n    schema.pre('remove', { document: true, query: false }, () => ++removeCount2);\n\n    const Model = db.model('Test', schema);\n\n\n    const doc = new Model({ name: 'test' });\n    await doc.save();\n\n    assert.equal(queryCount, 0);\n    assert.equal(docCount, 0);\n    assert.equal(docPostCount, 0);\n    assert.equal(docRegexCount, 0);\n    assert.equal(docPostRegexCount, 0);\n\n    await doc.updateOne({ name: 'test2' });\n\n    assert.equal(queryCount, 1);\n    assert.equal(docCount, 1);\n    assert.equal(docPostCount, 1);\n    assert.equal(docRegexCount, 1);\n    assert.equal(docPostRegexCount, 1);\n\n    assert.equal(removeCount1, 0);\n    assert.equal(removeCount2, 0);\n\n    await doc.remove();\n\n    assert.equal(removeCount1, 1);\n    assert.equal(removeCount2, 1);\n  });\n\n  it('doesnt mark single nested doc date as modified if setting with string (gh-7264)', async function() {\n    const subSchema = new mongoose.Schema({\n      date2: Date\n    });\n\n    const schema = new mongoose.Schema({\n      date1: Date,\n      sub: subSchema\n    });\n\n    const Model = db.model('Test', schema);\n\n\n    const date = '2018-11-22T09:00:00.000Z';\n\n    const doc = await Model.create({\n      date1: date,\n      sub: { date2: date }\n    });\n\n    assert.deepEqual(doc.modifiedPaths(), []);\n\n    doc.set('date1', date);\n    doc.set('sub.date2', date);\n\n    assert.deepEqual(doc.modifiedPaths(), []);\n  });\n\n  it('handles null `fields` param to constructor (gh-7271)', function() {\n    const ActivityBareSchema = new Schema({\n      _id: {\n        type: Schema.Types.ObjectId,\n        ref: 'Activity'\n      },\n      name: String\n    });\n\n    const EventSchema = new Schema({\n      activity: ActivityBareSchema,\n      name: String\n    });\n\n    const data = {\n      name: 'Test',\n      activity: {\n        _id: '5bf606f6471b6056b3f2bfc9',\n        name: 'Activity name'\n      }\n    };\n\n    const Event = db.model('Test', EventSchema);\n    const event = new Event(data, null);\n\n    assert.equal(event.activity.name, 'Activity name');\n\n    return event.validate();\n  });\n\n  it('flattenMaps option for toObject() (gh-10872) (gh-7274) (gh-10486)', function() {\n    const subSchema = new Schema({ name: String });\n\n    let schema = new Schema({\n      test: {\n        type: Map,\n        of: subSchema,\n        default: new Map()\n      }\n    }, { versionKey: false });\n\n    let Test = db.model('Test', schema);\n\n    let mapTest = new Test({});\n    mapTest.test.set('key1', { name: 'value1' });\n    // getters: true for gh-10486\n    assert.equal(mapTest.toObject({ getters: true, flattenMaps: true }).test.key1.name, 'value1');\n\n    assert.equal(mapTest.toJSON({ getters: true, flattenMaps: true }).test.key1.name, 'value1');\n    assert.equal(mapTest.toJSON({ getters: true, flattenMaps: false }).test.get('key1').name, 'value1');\n\n    schema = new Schema({\n      test: {\n        type: Map,\n        of: subSchema,\n        default: new Map()\n      }\n    }, { versionKey: false });\n    schema.set('toObject', { flattenMaps: true });\n\n    db.deleteModel('Test');\n    Test = db.model('Test', schema);\n\n    mapTest = new Test({});\n    mapTest.test.set('key1', { name: 'value1' });\n    assert.equal(mapTest.toObject({}).test.key1.name, 'value1');\n  });\n\n  it('`collection` property with strict: false (gh-7276)', async function() {\n    const schema = new Schema({}, { strict: false, versionKey: false });\n    const Model = db.model('Test', schema);\n\n    let doc = new Model({ test: 'foo', collection: 'bar' });\n\n    await doc.save();\n\n    assert.equal(doc.collection, 'bar');\n\n    doc = await Model.findOne();\n    assert.equal(doc.toObject().collection, 'bar');\n  });\n\n  it('should validateSync() all elements in doc array (gh-6746)', function() {\n    const Model = db.model('Test', new Schema({\n      colors: [{\n        name: { type: String, required: true },\n        hex: { type: String, required: true }\n      }]\n    }));\n\n    const model = new Model({\n      colors: [\n        { name: 'steelblue' },\n        { hex: '#4682B4' }\n      ]\n    });\n\n    const errors = model.validateSync().errors;\n    const keys = Object.keys(errors).sort();\n    assert.deepEqual(keys, ['colors.0.hex', 'colors.1.name']);\n  });\n\n  it('handles fake constructor (gh-7290)', async function() {\n    const TestSchema = new Schema({ test: String });\n\n    const TestModel = db.model('Test', TestSchema);\n\n    const badQuery = {\n      test: {\n        length: 1e10,\n        constructor: {\n          name: 'Array'\n        }\n      }\n    };\n\n\n    let err = await TestModel.findOne(badQuery).then(() => null, e => e);\n    assert.equal(err.name, 'CastError', err.stack);\n\n    err = await TestModel.updateOne(badQuery, { name: 'foo' }).\n      then(() => null, err => err);\n    assert.equal(err.name, 'CastError', err.stack);\n\n    err = await TestModel.updateOne({}, badQuery).then(() => null, e => e);\n    assert.equal(err.name, 'CastError', err.stack);\n\n    err = await TestModel.deleteOne(badQuery).then(() => null, e => e);\n    assert.equal(err.name, 'CastError', err.stack);\n  });\n\n  it('handles fake __proto__ (gh-7290)', async function() {\n    const TestSchema = new Schema({ test: String, name: String });\n\n    const TestModel = db.model('Test', TestSchema);\n\n    const badQuery = JSON.parse('{\"test\":{\"length\":1000000000,\"__proto__\":[]}}');\n\n\n    let err = await TestModel.findOne(badQuery).then(() => null, e => e);\n    assert.equal(err.name, 'CastError', err.stack);\n\n    err = await TestModel.updateOne(badQuery, { name: 'foo' }).\n      then(() => null, err => err);\n    assert.equal(err.name, 'CastError', err.stack);\n\n    err = await TestModel.updateOne({}, badQuery).then(() => null, e => e);\n    assert.equal(err.name, 'CastError', err.stack);\n\n    err = await TestModel.deleteOne(badQuery).then(() => null, e => e);\n    assert.equal(err.name, 'CastError', err.stack);\n  });\n\n  it('cast error with string path set to array in db (gh-7619)', async function() {\n    const TestSchema = new Schema({ name: String });\n\n    const TestModel = db.model('Test', TestSchema);\n\n\n    await TestModel.findOne();\n\n    await TestModel.collection.insertOne({ name: ['foo', 'bar'] });\n\n    const doc = await TestModel.findOne();\n    assert.ok(!doc.name);\n    const err = doc.validateSync();\n    assert.ok(err);\n    assert.ok(err.errors['name']);\n  });\n\n  it('doesnt crash if nested path with `get()` (gh-7316)', function() {\n    const schema = new mongoose.Schema({ http: { get: Number } });\n    const Model = db.model('Test', schema);\n\n    return Model.create({ http: { get: 400 } }); // Should succeed\n  });\n\n  it('copies atomics from existing document array when setting doc array (gh-7472)', async function() {\n    const Dog = db.model('Test', new mongoose.Schema({\n      name: String,\n      toys: [{\n        name: String\n      }]\n    }));\n\n\n    const dog = new Dog({ name: 'Dash' });\n\n    dog.toys.push({ name: '1' });\n    dog.toys.push({ name: '2' });\n    dog.toys.push({ name: '3' });\n\n    await dog.save();\n\n    for (const toy of ['4', '5', '6']) {\n      dog.toys = dog.toys || [];\n      dog.toys.push({ name: toy, count: 1 });\n    }\n\n    await dog.save();\n\n    const fromDb = await Dog.findOne();\n    assert.deepEqual(fromDb.toys.map(t => t.name), ['1', '2', '3', '4', '5', '6']);\n  });\n\n  it('doesnt fail with custom update function (gh-7342)', async function() {\n    const catalogSchema = new mongoose.Schema({\n      name: String,\n      sub: new Schema({ name: String })\n    }, { runSettersOnQuery: true });\n\n    catalogSchema.methods.update = function(data) {\n      for (const key in data) {\n        this[key] = data[key];\n      }\n      return this.save();\n    };\n\n    const Catalog = db.model('Test', catalogSchema);\n\n\n    let doc = await Catalog.create({ name: 'test', sub: { name: 'foo' } });\n    doc = await doc.update({ name: 'test2' });\n    assert.equal(doc.name, 'test2');\n  });\n\n  it('setters that modify `this` should work on single nested when overwriting (gh-7585)', function() {\n    const NameSchema = new Schema({\n      full: {\n        type: String,\n        set: function(v) {\n          this.first = 'foo';\n          this.last = 'bar';\n          return v + ' baz';\n        }\n      },\n      first: String,\n      last: String\n    }, { _id: false });\n\n    const User = db.model('User', new Schema({\n      name: {\n        type: NameSchema,\n        default: {}\n      }\n    }));\n\n    const s = new User();\n    s.name = { full: 'test' };\n    assert.equal(s.name.first, 'foo');\n    assert.equal(s.name.last, 'bar');\n    assert.equal(s.name.full, 'test baz');\n\n    return Promise.resolve();\n  });\n\n  it('handles setting embedded doc to Object.assign() from another doc (gh-7645)', function() {\n    const profileSchema = new Schema({ name: String, email: String });\n    const companyUserSchema = new Schema({\n      profile: {\n        type: profileSchema,\n        default: {}\n      }\n    });\n\n    const CompanyUser = db.model('User', companyUserSchema);\n\n    const cu = new CompanyUser({ profile: { name: 'foo', email: 'bar' } });\n    cu.profile = Object.assign({}, cu.profile);\n\n    assert.equal(cu.profile.name, 'foo');\n    assert.equal(cu.profile.email, 'bar');\n    assert.doesNotThrow(function() {\n      cu.toObject();\n    });\n  });\n\n  it('setting single nested subdoc with custom date types and getters/setters (gh-7601)', async function() {\n    const moment = require('moment');\n\n    const schema = new Schema({\n      start: { type: Date, get: get, set: set, required: true },\n      end: { type: Date, get: get, set: set, required: true }\n    }, { toObject: { getters: true } });\n    function get(v) {\n      return moment(v);\n    }\n    function set(v) {\n      return v.toDate();\n    }\n    const parentSchema = new Schema({\n      nested: schema\n    });\n    const Model = db.model('Parent', parentSchema);\n\n\n    const doc = await Model.create({\n      nested: { start: moment('2019-01-01'), end: moment('2019-01-02') }\n    });\n\n    doc.nested = { start: moment('2019-03-01'), end: moment('2019-04-01') };\n    await doc.save();\n\n    const _doc = await Model.collection.findOne();\n    assert.ok(_doc.nested.start instanceof Date);\n    assert.ok(_doc.nested.end instanceof Date);\n  });\n\n  it('get() and set() underneath alias (gh-7592)', async function() {\n    const photoSchema = new Schema({\n      foo: String\n    });\n\n    const pageSchema = new Schema({\n      p: { type: [photoSchema], alias: 'photos' }\n    });\n    const Page = db.model('Test', pageSchema);\n\n\n    const doc = await Page.create({ p: [{ foo: 'test' }] });\n\n    assert.equal(doc.p[0].foo, 'test');\n    assert.equal(doc.get('photos.0.foo'), 'test');\n\n    doc.set('photos.0.foo', 'bar');\n    assert.equal(doc.p[0].foo, 'bar');\n    assert.equal(doc.get('photos.0.foo'), 'bar');\n  });\n\n  it('get() with getters: false (gh-7233)', function() {\n    const testSchema = new Schema({\n      foo: { type: String, get: v => v.toLowerCase() }\n    });\n    const Test = db.model('Test', testSchema);\n\n    const doc = new Test({ foo: 'Bar' });\n    assert.equal(doc.foo, 'bar');\n    assert.equal(doc._doc.foo, 'Bar');\n\n    assert.equal(doc.get('foo'), 'bar');\n    assert.equal(doc.get('foo', null, { getters: false }), 'Bar');\n\n    return Promise.resolve();\n  });\n\n  it('overwriting single nested (gh-7660)', function() {\n    const childSchema = new mongoose.Schema({\n      foo: String,\n      bar: Number\n    }, { _id: false, id: false });\n\n    const parentSchema = new mongoose.Schema({\n      child: childSchema\n    });\n    const Test = db.model('Test', parentSchema);\n\n    const test = new Test({\n      child: {\n        foo: 'test',\n        bar: 42\n      }\n    });\n\n    test.set({\n      child: {\n        foo: 'modified',\n        bar: 43\n      }\n    });\n\n    assert.deepEqual(test.toObject().child, {\n      foo: 'modified',\n      bar: 43\n    });\n\n    return Promise.resolve();\n  });\n\n  it('setting path to non-POJO object (gh-7639)', function() {\n    class Nested {\n      constructor(prop) {\n        this.prop = prop;\n      }\n    }\n\n    const schema = new Schema({ nested: { prop: String } });\n    const Model = db.model('Test', schema);\n\n    const doc = new Model({ nested: { prop: '1' } });\n\n    doc.set('nested', new Nested('2'));\n    assert.equal(doc.nested.prop, '2');\n\n    doc.set({ nested: new Nested('3') });\n    assert.equal(doc.nested.prop, '3');\n  });\n\n  it('supports setting date properties with strict: false (gh-7907)', function() {\n    const schema = Schema({}, { strict: false });\n    const SettingsModel = db.model('Test', schema);\n\n    const date = new Date();\n    const obj = new SettingsModel({\n      timestamp: date,\n      subDoc: {\n        timestamp: date\n      }\n    });\n\n    assert.strictEqual(obj.timestamp, date);\n    assert.strictEqual(obj.subDoc.timestamp, date);\n  });\n\n  it('handles .set() on doc array within embedded discriminator (gh-7656)', function() {\n    const pageElementSchema = new Schema({\n      type: { type: String, required: true }\n    }, { discriminatorKey: 'type' });\n\n    const textElementSchema = new Schema({\n      body: { type: String }\n    });\n\n    const blockElementSchema = new Schema({\n      elements: [pageElementSchema]\n    });\n\n    blockElementSchema.path('elements').discriminator('block', blockElementSchema);\n    blockElementSchema.path('elements').discriminator('text', textElementSchema);\n\n    const pageSchema = new Schema({ elements: [pageElementSchema] });\n\n    pageSchema.path('elements').discriminator('block', blockElementSchema);\n    pageSchema.path('elements').discriminator('text', textElementSchema);\n\n    const Page = db.model('Test', pageSchema);\n    const page = new Page({\n      elements: [\n        { type: 'text', body: 'Page Title' },\n        { type: 'block', elements: [{ type: 'text', body: 'Page Content' }] }\n      ]\n    });\n\n    page.set('elements.0.body', 'Page Heading');\n    assert.equal(page.elements[0].body, 'Page Heading');\n    assert.equal(page.get('elements.0.body'), 'Page Heading');\n\n    page.set('elements.1.elements.0.body', 'Page Body');\n    assert.equal(page.elements[1].elements[0].body, 'Page Body');\n    assert.equal(page.get('elements.1.elements.0.body'), 'Page Body');\n\n    page.elements[1].elements[0].body = 'Page Body';\n    assert.equal(page.elements[1].elements[0].body, 'Page Body');\n    assert.equal(page.get('elements.1.elements.0.body'), 'Page Body');\n  });\n\n  it('$isEmpty() (gh-5369)', function() {\n    const schema = new Schema({\n      nested: { foo: String },\n      subdoc: new Schema({ bar: String }, { _id: false }),\n      docArr: [new Schema({ baz: String }, { _id: false })],\n      mixed: {}\n    });\n\n    const Model = db.model('Test', schema);\n    const doc = new Model({ subdoc: {}, docArr: [{}] });\n\n    assert.ok(doc.nested.$isEmpty());\n    assert.ok(doc.subdoc.$isEmpty());\n    assert.ok(doc.docArr[0].$isEmpty());\n    assert.ok(doc.$isEmpty('nested'));\n    assert.ok(doc.$isEmpty('subdoc'));\n    assert.ok(doc.$isEmpty('docArr.0'));\n    assert.ok(doc.$isEmpty('mixed'));\n\n    doc.nested.foo = 'test';\n    assert.ok(!doc.nested.$isEmpty());\n    assert.ok(doc.subdoc.$isEmpty());\n    assert.ok(doc.docArr[0].$isEmpty());\n    assert.ok(!doc.$isEmpty('nested'));\n    assert.ok(doc.$isEmpty('subdoc'));\n    assert.ok(doc.$isEmpty('docArr.0'));\n    assert.ok(doc.$isEmpty('mixed'));\n\n    doc.subdoc.bar = 'test';\n    assert.ok(!doc.nested.$isEmpty());\n    assert.ok(!doc.subdoc.$isEmpty());\n    assert.ok(doc.docArr[0].$isEmpty());\n    assert.ok(!doc.$isEmpty('nested'));\n    assert.ok(!doc.$isEmpty('subdoc'));\n    assert.ok(doc.$isEmpty('docArr.0'));\n    assert.ok(doc.$isEmpty('mixed'));\n\n    doc.docArr[0].baz = 'test';\n    assert.ok(!doc.nested.$isEmpty());\n    assert.ok(!doc.subdoc.$isEmpty());\n    assert.ok(!doc.docArr[0].$isEmpty());\n    assert.ok(!doc.$isEmpty('nested'));\n    assert.ok(!doc.$isEmpty('subdoc'));\n    assert.ok(!doc.$isEmpty('docArr.0'));\n    assert.ok(doc.$isEmpty('mixed'));\n\n    doc.mixed = {};\n    assert.ok(doc.$isEmpty('mixed'));\n\n    doc.mixed.test = 1;\n    assert.ok(!doc.$isEmpty('mixed'));\n\n    return Promise.resolve();\n  });\n\n  it('push() onto discriminator doc array (gh-7704)', function() {\n    const opts = {\n      minimize: false, // So empty objects are returned\n      strict: true,\n      typeKey: '$type', // So that we can use fields named `type`\n      discriminatorKey: 'type'\n    };\n\n    const IssueSchema = new mongoose.Schema({\n      _id: String,\n      text: String,\n      type: String\n    }, opts);\n\n    const IssueModel = db.model('Test', IssueSchema);\n\n    const SubIssueSchema = new mongoose.Schema({\n      checklist: [{\n        completed: { $type: Boolean, default: false }\n      }]\n    }, opts);\n    IssueModel.discriminator('gh7704_sub', SubIssueSchema);\n\n    const doc = new IssueModel({ _id: 'foo', text: 'text', type: 'gh7704_sub' });\n    doc.checklist.push({ completed: true });\n\n    assert.ifError(doc.validateSync());\n\n    return Promise.resolve();\n  });\n\n  it('doesnt call getter when saving (gh-7719)', function() {\n    let called = 0;\n    const kittySchema = new mongoose.Schema({\n      name: {\n        type: String,\n        get: function(v) {\n          ++called;\n          return v;\n        }\n      }\n    });\n    const Kitten = db.model('Test', kittySchema);\n\n    const k = new Kitten({ name: 'Mr Sprinkles' });\n    return k.save().then(() => assert.equal(called, 0));\n  });\n\n  it('skips malformed validators property (gh-7720)', function() {\n    const NewSchema = new Schema({\n      object: {\n        type: 'string',\n        validators: ['string'] // This caused the issue\n      }\n    });\n\n    const TestModel = db.model('Test', NewSchema);\n    const instance = new TestModel();\n    instance.object = 'value';\n\n    assert.ifError(instance.validateSync());\n\n    return instance.validate();\n  });\n\n  it('nested set on subdocs works (gh-7748)', async function() {\n    const geojsonSchema = new Schema({\n      type: { type: String, default: 'Feature' },\n      geometry: {\n        type: {\n          type: String,\n          required: true\n        },\n        coordinates: { type: [] }\n      },\n      properties: { type: Object }\n    });\n\n    const userSchema = new Schema({\n      position: geojsonSchema\n    });\n\n    const User = db.model('User', userSchema);\n\n    const position = {\n      geometry: {\n        type: 'Point',\n        coordinates: [1.11111, 2.22222]\n      },\n      properties: {\n        a: 'b'\n      }\n    };\n\n    const newUser = new User({\n      position: position\n    });\n\n    await newUser.save();\n\n    const editUser = await User.findById(newUser._id);\n    editUser.position = position;\n\n    await editUser.validate();\n    await editUser.save();\n\n    const fromDb = await User.findById(newUser._id);\n    assert.equal(fromDb.position.properties.a, 'b');\n    assert.equal(fromDb.position.geometry.coordinates[0], 1.11111);\n  });\n\n  it('does not convert array to object with strict: false (gh-7733)', async function() {\n    const ProductSchema = new mongoose.Schema({}, { strict: false });\n    const Product = db.model('Test', ProductSchema);\n\n\n    await Product.create({ arr: [{ test: 1 }, { test: 2 }] });\n\n    const doc = await Product.collection.findOne();\n    assert.ok(Array.isArray(doc.arr));\n    assert.deepEqual(doc.arr, [{ test: 1 }, { test: 2 }]);\n  });\n\n  it('does not crash with array property named \"undefined\" (gh-7756)', async function() {\n    const schema = new Schema({ undefined: [String] });\n    const Model = db.model('Test', schema);\n\n\n    const doc = await Model.create({ undefined: ['foo'] });\n\n    doc['undefined'].push('bar');\n    await doc.save();\n\n    const _doc = await Model.collection.findOne();\n    assert.equal(_doc['undefined'][0], 'foo');\n  });\n\n  it('fires pre save hooks on nested child schemas (gh-7792)', function() {\n    const childSchema1 = new mongoose.Schema({ name: String });\n    let called1 = 0;\n    childSchema1.pre('save', function() {\n      ++called1;\n    });\n\n    const childSchema2 = new mongoose.Schema({ name: String });\n    let called2 = 0;\n    childSchema2.pre('save', function() {\n      ++called2;\n    });\n\n    const parentSchema = new mongoose.Schema({\n      nested: {\n        child: childSchema1,\n        arr: [childSchema2]\n      }\n    });\n\n    const Parent = db.model('Parent', parentSchema);\n\n    const obj = { nested: { child: { name: 'foo' }, arr: [{ name: 'bar' }] } };\n    return Parent.create(obj).then(() => {\n      assert.equal(called1, 1);\n      assert.equal(called2, 1);\n    });\n  });\n\n  it('takes message from async custom validator promise rejection (gh-4913)', function() {\n    const schema = new Schema({\n      name: {\n        type: String,\n        validate: async function() {\n          await Promise.resolve((resolve) => setImmediate(resolve));\n          throw new Error('Oops!');\n        }\n      }\n    });\n    const Model = db.model('Test', schema);\n\n    return Model.create({ name: 'foo' }).then(() => assert.ok(false), err => {\n      assert.equal(err.errors['name'].message, 'Oops!');\n      assert.ok(err.message.indexOf('Oops!') !== -1, err.message);\n    });\n  });\n\n  it('handles nested properties named `schema` (gh-7831)', async function() {\n    const schema = new mongoose.Schema({ nested: { schema: String } });\n    const Model = db.model('Test', schema);\n\n    await Model.collection.insertOne({ nested: { schema: 'test' } });\n\n    const doc = await Model.findOne();\n    assert.strictEqual(doc.nested.schema, 'test');\n  });\n\n  it('handles nested properties named `on` (gh-11656)', async function() {\n    const schema = new mongoose.Schema({ on: String }, { supressReservedKeysWarning: true });\n    const Model = db.model('Test', schema);\n\n    await Model.create({ on: 'test string' });\n\n    const doc = await Model.findOne();\n    assert.strictEqual(doc.on, 'test string');\n  });\n\n  describe('overwrite() (gh-7830)', function() {\n    let Model;\n\n    beforeEach(function() {\n      const schema = new Schema({\n        _id: Number,\n        name: String,\n        nested: {\n          prop: String\n        },\n        arr: [Number],\n        immutable: {\n          type: String,\n          immutable: true\n        }\n      });\n      Model = db.model('Test', schema);\n    });\n\n    it('works', async function() {\n\n      const doc = await Model.create({\n        _id: 1,\n        name: 'test',\n        nested: { prop: 'foo' },\n        immutable: 'bar'\n      });\n      doc.overwrite({ name: 'test2' });\n\n      assert.deepEqual(doc.toObject(), {\n        _id: 1,\n        __v: 0,\n        name: 'test2',\n        immutable: 'bar'\n      });\n    });\n\n    it('skips version key', async function() {\n\n      await Model.collection.insertOne({\n        _id: 2,\n        __v: 5,\n        name: 'test',\n        nested: { prop: 'foo' },\n        immutable: 'bar'\n      });\n      const doc = await Model.findOne({ _id: 2 });\n      doc.overwrite({ _id: 2, name: 'test2' });\n\n      assert.deepEqual(doc.toObject(), {\n        _id: 2,\n        __v: 5,\n        name: 'test2',\n        immutable: 'bar'\n      });\n    });\n\n    it('skips discriminator key', async function() {\n\n      const D = Model.discriminator('D', Schema({ other: String }));\n      await Model.collection.insertOne({\n        _id: 2,\n        __v: 5,\n        __t: 'D',\n        name: 'test',\n        nested: { prop: 'foo' },\n        immutable: 'bar',\n        other: 'baz'\n      });\n      const doc = await D.findOne({ _id: 2 });\n      doc.overwrite({ _id: 2, name: 'test2' });\n\n      assert.deepEqual(doc.toObject(), {\n        _id: 2,\n        __v: 5,\n        __t: 'D',\n        name: 'test2',\n        immutable: 'bar'\n      });\n      return doc.validate();\n    });\n\n    it('overwrites maps (gh-9549)', async function() {\n      const schema = new Schema({\n        name: String,\n        myMap: { type: Map, of: String }\n      });\n      db.deleteModel(/Test/);\n      const Test = db.model('Test', schema);\n\n      let doc = new Test({ name: 'test', myMap: { a: 1, b: 2 } });\n\n\n      await doc.save();\n\n      doc = await Test.findById(doc);\n      doc.overwrite({ name: 'test2', myMap: { b: 2, c: 3 } });\n      await doc.save();\n\n      doc = await Test.findById(doc);\n      assert.deepEqual(Array.from(doc.toObject().myMap.values()), [2, 3]);\n    });\n  });\n\n  it('copies virtuals from array subdocs when casting array of docs with same schema (gh-7898)', function() {\n    const ChildSchema = new Schema({ name: String },\n      { _id: false, id: false });\n\n    ChildSchema.virtual('foo').\n      set(function(foo) { this.__foo = foo; }).\n      get(function() { return this.__foo || 0; });\n\n    const ParentSchema = new Schema({\n      name: String,\n      children: [ChildSchema]\n    }, { _id: false, id: false });\n\n    const WrapperSchema = new Schema({\n      name: String,\n      parents: [ParentSchema]\n    }, { _id: false, id: false });\n\n    const Parent = db.model('Parent', ParentSchema);\n    const Wrapper = db.model('Test', WrapperSchema);\n\n    const data = { name: 'P1', children: [{ name: 'C1' }, { name: 'C2' }] };\n    const parent = new Parent(data);\n    parent.children[0].foo = 123;\n\n    const wrapper = new Wrapper({ name: 'test', parents: [parent] });\n    assert.equal(wrapper.parents[0].children[0].foo, 123);\n  });\n\n  describe('immutable properties (gh-7671)', function() {\n    let Model;\n\n    beforeEach(function() {\n      const schema = new Schema({\n        createdAt: {\n          type: Date,\n          immutable: true,\n          default: new Date('6/1/2019')\n        },\n        name: String\n      });\n      Model = db.model('Test', schema);\n    });\n\n    it('SchemaType#immutable()', function() {\n      const schema = new Schema({\n        createdAt: {\n          type: Date,\n          default: new Date('6/1/2019')\n        },\n        name: String\n      });\n\n      assert.ok(!schema.path('createdAt').$immutable);\n\n      schema.path('createdAt').immutable(true);\n      assert.ok(schema.path('createdAt').$immutable);\n      assert.equal(schema.path('createdAt').setters.length, 1);\n\n      schema.path('createdAt').immutable(false);\n      assert.ok(!schema.path('createdAt').$immutable);\n      assert.equal(schema.path('createdAt').setters.length, 0);\n    });\n\n    it('with save()', async function() {\n      let doc = new Model({ name: 'Foo' });\n\n      assert.equal(doc.createdAt.toLocaleDateString('en-us'), '6/1/2019');\n      await doc.save();\n\n      doc = await Model.findOne({ createdAt: new Date('6/1/2019') });\n      doc.createdAt = new Date('6/1/2017');\n      assert.equal(doc.createdAt.toLocaleDateString('en-us'), '6/1/2019');\n\n      doc.set({ createdAt: new Date('6/1/2021') });\n      assert.equal(doc.createdAt.toLocaleDateString('en-us'), '6/1/2019');\n\n      await doc.save();\n\n      doc = await Model.findOne({ createdAt: new Date('6/1/2019') });\n      assert.ok(doc);\n    });\n\n    it('with update', async function() {\n      let doc = new Model({ name: 'Foo' });\n\n      assert.equal(doc.createdAt.toLocaleDateString('en-us'), '6/1/2019');\n      await doc.save();\n\n      const update = { createdAt: new Date('6/1/2020') };\n\n      await Model.updateOne({}, update);\n\n      doc = await Model.findOne();\n      assert.equal(doc.createdAt.toLocaleDateString('en-us'), '6/1/2019');\n\n      const err = await Model.updateOne({}, update, { strict: 'throw' }).\n        then(() => null, err => err);\n      assert.equal(err.name, 'StrictModeError');\n      assert.ok(err.message.indexOf('createdAt') !== -1, err.message);\n    });\n\n    it('conditional immutable (gh-8001)', async function() {\n      const schema = new Schema({\n        name: String,\n        test: {\n          type: String,\n          immutable: doc => doc.name === 'foo'\n        }\n      });\n      const Model = db.model('Test1', schema);\n\n\n      const doc1 = await Model.create({ name: 'foo', test: 'before' });\n      const doc2 = await Model.create({ name: 'bar', test: 'before' });\n\n      doc1.set({ test: 'after' });\n      doc2.set({ test: 'after' });\n      await doc1.save();\n      await doc2.save();\n\n      const fromDb1 = await Model.collection.findOne({ name: 'foo' });\n      const fromDb2 = await Model.collection.findOne({ name: 'bar' });\n      assert.equal(fromDb1.test, 'before');\n      assert.equal(fromDb2.test, 'after');\n    });\n\n    it('immutable with strict mode (gh-8149)', async function() {\n\n      const schema = new mongoose.Schema({\n        name: String,\n        yearOfBirth: { type: Number, immutable: true }\n      }, { strict: 'throw' });\n      const Person = db.model('Person', schema);\n      const joe = await Person.create({ name: 'Joe', yearOfBirth: 2001 });\n\n      joe.set({ yearOfBirth: 2002 });\n      const err = await joe.save().then(() => null, err => err);\n      assert.ok(err);\n      assert.equal(err.errors['yearOfBirth'].name, 'StrictModeError');\n    });\n  });\n\n  it('consistent post order traversal for array subdocs (gh-7929)', function() {\n    const Grandchild = Schema({ value: Number });\n    const Child = Schema({ children: [Grandchild] });\n    const Parent = Schema({ children: [Child] });\n\n    const calls = [];\n    Grandchild.pre('save', () => calls.push(1));\n    Child.pre('save', () => calls.push(2));\n    Parent.pre('save', () => calls.push(3));\n\n    const Model = db.model('Parent', Parent);\n\n    return Model.create({ children: [{ children: [{ value: 3 }] }] }).then(() => {\n      assert.deepEqual(calls, [1, 2, 3]);\n    });\n  });\n\n  it('respects projection for getters (gh-7940)', async function() {\n    const schema = new Schema({\n      foo: String,\n      bar: {\n        type: String,\n        get: () => {\n          return 'getter value';\n        }\n      }\n    }, { toObject: { getters: true } });\n\n    const Model = db.model('Test', schema);\n\n\n    await Model.create({ foo: 'test', bar: 'baz' });\n\n    const doc = await Model.findOne({ foo: 'test' }, 'foo');\n\n    assert.ok(!doc.toObject().bar);\n  });\n\n  it('loads doc with a `once` property successfully (gh-7958)', async function() {\n    const eventSchema = Schema({ once: { prop: String } });\n    const Event = db.model('Test', eventSchema);\n\n\n    await Event.create({ once: { prop: 'test' } });\n\n    const doc = await Event.findOne();\n    assert.equal(doc.once.prop, 'test');\n  });\n\n  it('caster that converts to Number class works (gh-8150)', async function() {\n\n    const mySchema = new Schema({\n      id: {\n        type: Number,\n        set: value => new Number(value.valueOf())\n      }\n    });\n\n    const MyModel = db.model('Test', mySchema);\n\n    await MyModel.create({ id: 12345 });\n\n    const doc = await MyModel.findOne({ id: 12345 });\n    assert.ok(doc);\n  });\n\n  it('handles objectids and decimals with strict: false (gh-7973)', async function() {\n    const testSchema = Schema({}, { strict: false });\n    const Test = db.model('Test', testSchema);\n\n    let doc = new Test({\n      testId: new mongoose.Types.ObjectId(),\n      testDecimal: new mongoose.Types.Decimal128('1.23')\n    });\n\n    assert.ok(doc.testId instanceof mongoose.Types.ObjectId);\n    assert.ok(doc.testDecimal instanceof mongoose.Types.Decimal128);\n\n\n    await doc.save();\n\n    doc = await Test.collection.findOne();\n    assert.ok(doc.testId instanceof mongoose.Types.ObjectId);\n    assert.ok(doc.testDecimal instanceof mongoose.Types.Decimal128);\n  });\n\n  it('allows enum on array of array of strings (gh-7926)', function() {\n    const schema = new Schema({\n      test: {\n        type: [[String]],\n        enum: ['bar']\n      }\n    });\n\n    const Model = db.model('Test', schema);\n\n    return Model.create({ test: [['foo']] }).then(() => assert.ok(false), err => {\n      assert.ok(err);\n      assert.ok(err.errors['test.0.0']);\n      assert.ok(err.errors['test.0.0'].message.indexOf('foo') !== -1,\n        err.errors['test.0.0'].message);\n    });\n  });\n\n  it('allows saving an unchanged document if required populated path is null (gh-8018)', async function() {\n    const schema = Schema({ test: String });\n    const schema2 = Schema({\n      keyToPopulate: {\n        type: mongoose.Schema.Types.ObjectId,\n        ref: 'Child',\n        required: true\n      }\n    });\n\n    const Child = db.model('Child', schema);\n    const Parent = db.model('Parent', schema2);\n\n\n    const child = await Child.create({ test: 'test' });\n    await Parent.create({ keyToPopulate: child._id });\n\n    await child.deleteOne();\n\n    const doc = await Parent.findOne().populate('keyToPopulate');\n\n    // Should not throw\n    await doc.save();\n  });\n\n  it('only calls validator once on mixed validator (gh-8067)', function() {\n    let called = 0;\n    function validator() {\n      ++called;\n      return true;\n    }\n\n    const itemArray = new Schema({\n      timer: {\n        time: {\n          type: {},\n          validate: {\n            validator: validator\n          }\n        }\n      }\n    });\n\n    const schema = new Schema({\n      items: [itemArray]\n    });\n    const Model = db.model('Test', schema);\n\n    const obj = new Model({\n      items: [\n        { timer: { time: { type: { hours: 24, allowed: true } } } }\n      ]\n    });\n\n    obj.validateSync();\n    assert.equal(called, 1);\n  });\n\n  it('only calls validator once on nested mixed validator (gh-8117)', function() {\n    const called = [];\n    const Model = db.model('Test', Schema({\n      name: { type: String },\n      level1: {\n        level2: {\n          type: Object,\n          validate: {\n            validator: v => {\n              called.push(v);\n              return true;\n            }\n          }\n        }\n      }\n    }));\n\n    const doc = new Model({ name: 'bob' });\n    doc.level1 = { level2: { a: 'one', b: 'two', c: 'three' } };\n    return doc.validate().then(() => {\n      assert.equal(called.length, 1);\n      assert.deepEqual(called[0], { a: 'one', b: 'two', c: 'three' });\n    });\n  });\n\n  it('handles populate() with custom type that does not cast to doc (gh-8062)', async function() {\n    class Gh8062 extends mongoose.SchemaType {\n      cast(val) {\n        if (typeof val === 'string') {\n          return val;\n        }\n        throw new Error('Failed!');\n      }\n    }\n\n    mongoose.Schema.Types.Gh8062 = Gh8062;\n\n    const schema = new Schema({ arr: [{ type: Gh8062, ref: 'Child' }] });\n    const Model = db.model('Test', schema);\n    const Child = db.model('Child', Schema({ _id: Gh8062 }));\n\n\n    await Child.create({ _id: 'test' });\n    await Model.create({ arr: ['test'] });\n\n    const doc = await Model.findOne().populate('arr');\n    assert.ok(doc.populated('arr'));\n    assert.equal(doc.arr[0]._id, 'test');\n    assert.ok(doc.arr[0].$__ != null);\n  });\n\n  it('can inspect() on a document array (gh-8037)', function() {\n    const subdocSchema = mongoose.Schema({ a: String });\n    const schema = mongoose.Schema({ subdocs: { type: [subdocSchema] } });\n    const Model = db.model('Test', schema);\n    const data = { _id: new mongoose.Types.ObjectId(), subdocs: [{ a: 'a' }] };\n    const doc = new Model();\n    doc.init(data);\n    require('util').inspect(doc.subdocs);\n  });\n\n  it('always passes unpopulated paths to validators (gh-8042)', async function() {\n    const schema = Schema({ test: String });\n\n    const calledWith = [];\n    function validate(v) {\n      calledWith.push(v);\n      return true;\n    }\n    const schema2 = Schema({\n      keyToPopulate: {\n        type: mongoose.Schema.Types.ObjectId,\n        ref: 'gh8018_child',\n        required: true,\n        validate: validate\n      },\n      array: [{\n        type: mongoose.Schema.Types.ObjectId,\n        ref: 'gh8018_child',\n        required: true,\n        validate: validate\n      }],\n      subdoc: Schema({\n        keyToPopulate: {\n          type: mongoose.Schema.Types.ObjectId,\n          ref: 'gh8018_child',\n          required: true,\n          validate: validate\n        }\n      })\n    });\n\n    const Child = db.model('gh8018_child', schema);\n    const Parent = db.model('gh8018_parent', schema2);\n\n\n    const child = await Child.create({ test: 'test' });\n    await Parent.create({ keyToPopulate: child, array: [child], subdoc: { keyToPopulate: child } });\n\n    assert.equal(calledWith.length, 3);\n\n    assert.ok(calledWith[0] instanceof mongoose.Types.ObjectId);\n    assert.ok(calledWith[1] instanceof mongoose.Types.ObjectId);\n    assert.ok(calledWith[2] instanceof mongoose.Types.ObjectId);\n\n    await child.deleteOne();\n\n    const doc = await Parent.findOne().populate(['keyToPopulate', 'array', 'subdoc']);\n    assert.equal(doc.keyToPopulate, null);\n\n    // Should not throw\n    await doc.save();\n  });\n\n  it('set() merge option with single nested (gh-8201)', async function() {\n    const AddressSchema = Schema({\n      street: { type: String, required: true },\n      city: { type: String, required: true }\n    });\n    const PersonSchema = Schema({\n      name: { type: String, required: true },\n      address: { type: AddressSchema, required: true }\n    });\n    const Person = db.model('Person', PersonSchema);\n\n\n    await Person.create({\n      name: 'John Smith',\n      address: {\n        street: 'Real Street',\n        city: 'Somewhere'\n      }\n    });\n\n    const person = await Person.findOne();\n    const obj = {\n      name: 'John Smythe',\n      address: { street: 'Fake Street' }\n    };\n    person.set(obj, undefined, { merge: true });\n\n    assert.equal(person.address.city, 'Somewhere');\n    await person.save();\n  });\n\n  it('setting single nested subdoc with timestamps (gh-8251)', async function() {\n    const ActivitySchema = Schema({ description: String }, { timestamps: true });\n    const RequestSchema = Schema({ activity: ActivitySchema });\n    const Request = db.model('Test', RequestSchema);\n\n\n    const doc = await Request.create({\n      activity: { description: 'before' }\n    });\n    doc.activity.set({ description: 'after' });\n    await doc.save();\n\n    const fromDb = await Request.findOne().lean();\n    assert.equal(fromDb.activity.description, 'after');\n  });\n\n  it('passing an object with toBSON() into `save()` (gh-8299)', async function() {\n    const ActivitySchema = Schema({ description: String });\n    const RequestSchema = Schema({ activity: ActivitySchema });\n    const Request = db.model('Test', RequestSchema);\n\n\n    const doc = await Request.create({\n      activity: { description: 'before' }\n    });\n    doc.activity.set({ description: 'after' });\n    await doc.save();\n\n    const fromDb = await Request.findOne().lean();\n    assert.equal(fromDb.activity.description, 'after');\n  });\n\n  it('handles getter setting virtual on manually populated doc when calling toJSON (gh-8295)', function() {\n    const childSchema = Schema({}, { toJSON: { getters: true } });\n    childSchema.virtual('field').\n      get(function() { return this._field; }).\n      set(function(v) { return this._field = v; });\n    const Child = db.model('Child', childSchema);\n\n    const parentSchema = Schema({\n      child: { type: mongoose.ObjectId, ref: 'Child', get: get }\n    }, { toJSON: { getters: true } });\n    const Parent = db.model('Parent', parentSchema);\n\n    function get(child) {\n      child.field = true;\n      return child;\n    }\n\n    let p = new Parent({ child: new Child({}) });\n    assert.strictEqual(p.toJSON().child.field, true);\n\n    p = new Parent({ child: new Child({}) });\n    assert.strictEqual(p.child.toJSON().field, true);\n  });\n\n  it('enum validator for number (gh-8139)', function() {\n    const schema = Schema({\n      num: {\n        type: Number,\n        enum: [1, 2, 3]\n      }\n    });\n    const Model = db.model('Test', schema);\n\n    let doc = new Model({});\n    let err = doc.validateSync();\n    assert.ifError(err);\n\n    doc = new Model({ num: 4 });\n    err = doc.validateSync();\n    assert.ok(err);\n    assert.equal(err.errors['num'].name, 'ValidatorError');\n\n    doc = new Model({ num: 2 });\n    err = doc.validateSync();\n    assert.ifError(err);\n  });\n\n  it('enum object syntax for number (gh-10648) (gh-8139)', function() {\n    const schema = Schema({\n      num: {\n        type: Number,\n        enum: {\n          values: [1, 2, 3],\n          message: 'Invalid number'\n        }\n      }\n    });\n    const Model = db.model('Test', schema);\n\n    let doc = new Model({});\n    let err = doc.validateSync();\n    assert.ifError(err);\n\n    doc = new Model({ num: 4 });\n    err = doc.validateSync();\n    assert.ok(err);\n    assert.equal(err.errors['num'].name, 'ValidatorError');\n    assert.equal(err.errors['num'].message, 'Invalid number');\n\n    doc = new Model({ num: 2 });\n    err = doc.validateSync();\n    assert.ifError(err);\n  });\n\n  it('support `pathsToValidate()` option for `validate()` (gh-7587)', async function() {\n    const schema = Schema({\n      name: {\n        type: String,\n        required: true\n      },\n      age: {\n        type: Number,\n        required: true\n      },\n      rank: String\n    });\n    const Model = db.model('Test', schema);\n\n\n    const doc = new Model({});\n\n    let err = await doc.validate(['name', 'rank']).catch(err => err);\n    assert.deepEqual(Object.keys(err.errors), ['name']);\n\n    err = await doc.validate(['age', 'rank']).catch(err => err);\n    assert.deepEqual(Object.keys(err.errors), ['age']);\n  });\n\n  it('array push with $position (gh-4322)', async function() {\n    const schema = Schema({\n      nums: [Number]\n    });\n    const Model = db.model('Test', schema);\n\n\n    const doc = await Model.create({ nums: [3, 4] });\n\n    doc.nums.push({\n      $each: [1, 2],\n      $position: 0\n    });\n    assert.deepEqual(doc.toObject().nums, [1, 2, 3, 4]);\n\n    await doc.save();\n\n    const fromDb = await Model.findOne({ _id: doc._id });\n    assert.deepEqual(fromDb.toObject().nums, [1, 2, 3, 4]);\n\n    doc.nums.push({\n      $each: [0],\n      $position: 0\n    });\n    assert.throws(() => {\n      doc.nums.push({ $each: [5] });\n    }, /Cannot call.*multiple times/);\n    assert.throws(() => {\n      doc.nums.push(5);\n    }, /Cannot call.*multiple times/);\n  });\n\n  it('setting a path to a single nested document should update the single nested doc parent (gh-8400)', function() {\n    const schema = Schema({\n      name: String,\n      subdoc: new Schema({\n        name: String\n      })\n    });\n    const Model = db.model('Test', schema);\n\n    const doc1 = new Model({ name: 'doc1', subdoc: { name: 'subdoc1' } });\n    const doc2 = new Model({ name: 'doc2', subdoc: { name: 'subdoc2' } });\n\n    doc1.subdoc = doc2.subdoc;\n    assert.equal(doc1.subdoc.name, 'subdoc2');\n    assert.equal(doc2.subdoc.name, 'subdoc2');\n    assert.strictEqual(doc1.subdoc.ownerDocument(), doc1);\n    assert.strictEqual(doc2.subdoc.ownerDocument(), doc2);\n  });\n\n  it('setting an array to an array with some populated documents depopulates the whole array (gh-8443)', async function() {\n    const A = db.model('Test1', Schema({\n      name: String,\n      rel: [{ type: mongoose.ObjectId, ref: 'Test' }]\n    }));\n\n    const B = db.model('Test', Schema({ name: String }));\n\n\n    const b = await B.create({ name: 'testb' });\n    await A.create({ name: 'testa', rel: [b._id] });\n\n    const a = await A.findOne().populate('rel');\n\n    const b2 = await B.create({ name: 'testb2' });\n    a.rel = [a.rel[0], b2._id];\n    await a.save();\n\n    assert.ok(!a.populated('rel'));\n    assert.ok(a.rel[0] instanceof mongoose.Types.ObjectId);\n    assert.ok(a.rel[1] instanceof mongoose.Types.ObjectId);\n  });\n\n  it('handles errors with name set to \"ValidationError\" (gh-8466)', () => {\n    const childSchema = Schema({ name: String });\n\n    childSchema.pre('validate', function() {\n      if (this.name === 'Invalid') {\n        const error = new Error('invalid name');\n        error.name = 'ValidationError';\n        throw error;\n      }\n    });\n\n    const fatherSchema = Schema({ children: [childSchema] });\n    const Father = db.model('Test', fatherSchema);\n\n    const doc = new Father({\n      children: [{ name: 'Valid' }, { name: 'Invalid' }]\n    });\n\n    return doc.validate().then(() => assert.ok(false), err => {\n      assert.ok(err);\n      assert.ok(err.errors['children']);\n      assert.equal(err.errors['children'].message, 'invalid name');\n    });\n  });\n\n  it('throws an error if running validate() multiple times in parallel (gh-8468)', () => {\n    const Model = db.model('Test', Schema({ name: String }));\n\n    const doc = new Model({ name: 'test' });\n\n    doc.validate();\n\n    return doc.save().then(() => assert.ok(false), err => {\n      assert.equal(err.name, 'ParallelValidateError');\n    });\n  });\n\n  it('avoids parallel validate error when validating nested path with double nested subdocs (gh-8486)', async function() {\n    const testSchema = new Schema({\n      foo: {\n        bar: Schema({\n          baz: Schema({\n            num: Number\n          })\n        })\n      }\n    });\n    const Test = db.model('Test', testSchema);\n\n\n    const doc = await Test.create({});\n\n    doc.foo = {\n      bar: {\n        baz: {\n          num: 1\n        }\n      }\n    };\n\n    // Should not throw\n    await doc.save();\n\n    const raw = await Test.collection.findOne();\n    assert.equal(raw.foo.bar.baz.num, 1);\n  });\n\n  it('supports function for date min/max validator error (gh-8512)', function() {\n    const schema = Schema({\n      startDate: {\n        type: Date,\n        required: true,\n        min: [new Date('2020-01-01'), () => 'test']\n      }\n    });\n\n    db.deleteModel(/Test/);\n    const Model = db.model('Test', schema);\n    const doc = new Model({ startDate: new Date('2019-06-01') });\n\n    const err = doc.validateSync();\n    assert.ok(err.errors['startDate']);\n    assert.equal(err.errors['startDate'].message, 'test');\n  });\n\n  it('sets parent and ownerDocument correctly with document array default (gh-8509)', async function() {\n    const locationSchema = Schema({\n      name: String,\n      city: String\n    });\n    const owners = [];\n\n    // Middleware to set a default location name derived from the parent organization doc\n    locationSchema.pre('validate', function(next) {\n      const owner = this.ownerDocument();\n      owners.push(owner);\n      if (this.isNew && !this.get('name') && owner.get('name')) {\n        this.set('name', `${owner.get('name')} Office`);\n      }\n      next();\n    });\n\n    const organizationSchema = Schema({\n      name: String,\n      // Having a default doc this way causes issues\n      locations: { type: [locationSchema], default: [{}] }\n    });\n    const Organization = db.model('Test', organizationSchema);\n\n    const org = new Organization();\n    org.set('name', 'MongoDB');\n\n    await org.save();\n\n    assert.equal(owners.length, 1);\n    assert.ok(owners[0] === org);\n\n    assert.equal(org.locations[0].name, 'MongoDB Office');\n  });\n\n  it('doesnt add `null` if property is undefined with minimize false (gh-8504)', async function() {\n    const minimize = false;\n    const schema = Schema({\n      num: Number,\n      beta: { type: String }\n    },\n    {\n      toObject: { virtuals: true, minimize: minimize },\n      toJSON: { virtuals: true, minimize: minimize }\n    }\n    );\n    const Test = db.model('Test', schema);\n\n    const dummy1 = new Test({ num: 1, beta: null });\n    const dummy2 = new Test({ num: 2, beta: void 0 });\n\n\n    await dummy1.save();\n    await dummy2.save();\n\n    const res = await Test.find().lean().sort({ num: 1 });\n\n    assert.strictEqual(res[0].beta, null);\n    assert.ok(!res[1].hasOwnProperty('beta'));\n  });\n\n  it('creates document array defaults in forward order, not reverse (gh-8514)', function() {\n    let num = 0;\n    const schema = Schema({\n      arr: [{ val: { type: Number, default: () => ++num } }]\n    });\n    const Model = db.model('Test', schema);\n\n    const doc = new Model({ arr: [{}, {}, {}] });\n    assert.deepEqual(doc.toObject().arr.map(v => v.val), [1, 2, 3]);\n  });\n\n  it('can call subdocument validate multiple times in parallel (gh-8539)', async function() {\n    const schema = Schema({\n      arr: [{ val: String }],\n      single: Schema({ val: String })\n    });\n    const Model = db.model('Test', schema);\n\n\n    const doc = new Model({ arr: [{ val: 'test' }], single: { val: 'test' } });\n\n    await Promise.all([doc.arr[0].validate(), doc.arr[0].validate()]);\n    await Promise.all([doc.single.validate(), doc.single.validate()]);\n  });\n\n  it('sets `Document#op` when calling `validate()` (gh-8439)', function() {\n    const schema = Schema({ name: String });\n    const ops = [];\n    schema.pre('validate', function() {\n      ops.push(this.$op);\n    });\n    schema.post('validate', function() {\n      ops.push(this.$op);\n    });\n\n    const Model = db.model('Test', schema);\n    const doc = new Model({ name: 'test' });\n\n    const promise = doc.validate();\n    assert.equal(doc.$op, 'validate');\n\n    return promise.then(() => assert.deepEqual(ops, ['validate', 'validate']));\n  });\n\n  it('schema-level transform (gh-8403)', function() {\n    const schema = Schema({\n      myDate: {\n        type: Date,\n        transform: v => v.getFullYear()\n      },\n      dates: [{\n        type: Date,\n        transform: v => v.getFullYear()\n      }],\n      arr: [{\n        myDate: {\n          type: Date,\n          transform: v => v.getFullYear()\n        }\n      }]\n    });\n    const Model = db.model('Test', schema);\n\n    const doc = new Model({\n      myDate: new Date('2015/06/01'),\n      dates: [new Date('2016/06/01')],\n      arr: [{ myDate: new Date('2017/06/01') }]\n    });\n    assert.equal(doc.toObject({ transform: true }).myDate, '2015');\n    assert.equal(doc.toObject({ transform: true }).dates[0], '2016');\n    assert.equal(doc.toObject({ transform: true }).arr[0].myDate, '2017');\n  });\n\n  it('transforms nested paths (gh-9543)', function() {\n    const schema = Schema({\n      nested: {\n        date: {\n          type: Date,\n          transform: v => v.getFullYear()\n        }\n      }\n    });\n    const Model = db.model('Test', schema);\n\n    const doc = new Model({\n      nested: {\n        date: new Date('2020-06-01')\n      }\n    });\n    assert.equal(doc.toObject({ transform: true }).nested.date, '2020');\n  });\n\n  it('handles setting numeric paths with single nested subdocs (gh-8583)', async function() {\n    const placedItemSchema = Schema({ image: String }, { _id: false });\n\n    const subdocumentSchema = Schema({\n      placedItems: {\n        1: placedItemSchema,\n        first: placedItemSchema\n      }\n    });\n    const Model = db.model('Test', subdocumentSchema);\n\n\n    const doc = await Model.create({\n      placedItems: { 1: { image: 'original' }, first: { image: 'original' } }\n    });\n\n    doc.set({\n      'placedItems.1.image': 'updated',\n      'placedItems.first.image': 'updated'\n    });\n\n    await doc.save();\n\n    assert.equal(doc.placedItems['1'].image, 'updated');\n\n    const fromDb = await Model.findById(doc);\n    assert.equal(fromDb.placedItems['1'].image, 'updated');\n  });\n\n  it('setting nested array path to non-nested array wraps values top-down (gh-8544)', function() {\n    const positionSchema = mongoose.Schema({\n      coordinates: {\n        type: [[Number]],\n        required: true\n      },\n      lines: {\n        type: [[[Number]]],\n        required: true\n      }\n    });\n\n    const Position = db.model('Test', positionSchema);\n    const position = new Position();\n\n    position.coordinates = [1, 2];\n    position.lines = [3, 4];\n\n    const obj = position.toObject();\n    assert.deepEqual(obj.coordinates, [[1, 2]]);\n    assert.deepEqual(obj.lines, [[[3, 4]]]);\n  });\n\n  it('doesnt wrap empty nested array with insufficient depth', function() {\n    const weekSchema = mongoose.Schema({\n      days: {\n        type: [[[Number]]],\n        required: true\n      }\n    });\n\n    const Week = db.model('Test', weekSchema);\n    const emptyWeek = new Week();\n\n    emptyWeek.days = [[], [], [], [], [], [], []];\n    const obj = emptyWeek.toObject();\n    assert.deepEqual(obj.days, [[], [], [], [], [], [], []]);\n  });\n\n  it('doesnt wipe out nested keys when setting nested key to empty object with minimize (gh-8565)', function() {\n    const opts = { autoIndex: false, autoCreate: false };\n    const schema1 = Schema({ plaid: { nestedKey: String } }, opts);\n    const schema2 = Schema({ plaid: { nestedKey: String } }, opts);\n    const schema3 = Schema({ plaid: { nestedKey: String } }, opts);\n\n    const Test1 = db.model('Test1', schema1);\n    const Test2 = db.model('Test2', schema2);\n    const Test3 = db.model('Test3', schema3);\n\n    const doc1 = new Test1({});\n    assert.deepEqual(doc1.toObject({ minimize: false }).plaid, {});\n\n    const doc2 = new Test2({ plaid: doc1.plaid });\n    assert.deepEqual(doc2.toObject({ minimize: false }).plaid, {});\n\n    const doc3 = new Test3({});\n    doc3.set({ plaid: doc2.plaid });\n    assert.deepEqual(doc3.toObject({ minimize: false }).plaid, {});\n  });\n\n  it('allows calling `validate()` in post validate hook without causing parallel validation error (gh-8597)', async function() {\n    const EmployeeSchema = Schema({\n      name: String,\n      employeeNumber: {\n        type: String,\n        validate: v => v.length > 5\n      }\n    });\n    let called = 0;\n\n    EmployeeSchema.post('validate', function() {\n      ++called;\n      if (!this.employeeNumber && !this._employeeNumberRetrieved) {\n        this.employeeNumber = '123456';\n        this._employeeNumberRetrieved = true;\n        return this.validate();\n      }\n    });\n\n    const Employee = db.model('Test', EmployeeSchema);\n\n\n    const e = await Employee.create({ name: 'foo' });\n    assert.equal(e.employeeNumber, '123456');\n    assert.ok(e._employeeNumberRetrieved);\n    assert.equal(called, 2);\n  });\n\n  it('sets defaults when setting single nested subdoc (gh-8603)', async function() {\n    const nestedSchema = Schema({\n      name: String,\n      status: { type: String, default: 'Pending' }\n    });\n\n    const Test = db.model('Test', {\n      nested: nestedSchema\n    });\n\n\n    let doc = await Test.create({ nested: { name: 'foo' } });\n    assert.equal(doc.nested.status, 'Pending');\n\n    doc = await Test.findById(doc);\n    assert.equal(doc.nested.status, 'Pending');\n\n    Object.assign(doc, { nested: { name: 'bar' } });\n    assert.equal(doc.nested.status, 'Pending');\n    await doc.save();\n\n    doc = await Test.findById(doc);\n    assert.equal(doc.nested.status, 'Pending');\n  });\n\n  it('handles validating single nested paths when specified in `pathsToValidate` (gh-8626)', function() {\n    const nestedSchema = Schema({\n      name: { type: String, validate: v => v.length > 2 },\n      age: { type: Number, validate: v => v < 200 }\n    });\n    const schema = Schema({ nested: nestedSchema });\n\n    mongoose.deleteModel(/Test/);\n    const Model = mongoose.model('Test', schema);\n\n    const doc = new Model({ nested: { name: 'a', age: 9001 } });\n    return doc.validate(['nested.name']).then(() => assert.ok(false), err => {\n      assert.ok(err.errors['nested.name']);\n      assert.ok(!err.errors['nested.age']);\n    });\n  });\n\n  it('copies immutable fields when constructing new doc from old doc (gh-8642)', function() {\n    const schema = Schema({ name: { type: String, immutable: true } });\n    const Model = db.model('Test', schema);\n\n    const doc = new Model({ name: 'test' });\n    doc.isNew = false;\n\n    const newDoc = new Model(doc);\n    assert.equal(newDoc.name, 'test');\n  });\n\n  it('can save nested array after setting (gh-8689)', async function() {\n    const schema = new mongoose.Schema({\n      name: String,\n      array: [[{\n        label: String,\n        value: String\n      }]]\n    });\n    const MyModel = db.model('Test', schema);\n\n\n    const doc = await MyModel.create({ name: 'foo' });\n\n    doc.set({\n      'array.0': [{\n        label: 'hello',\n        value: 'world'\n      }]\n    });\n    await doc.save();\n\n    const updatedDoc = await MyModel.findOne({ _id: doc._id });\n    assert.equal(updatedDoc.array[0][0].label, 'hello');\n    assert.equal(updatedDoc.array[0][0].value, 'world');\n  });\n\n  it('handles validator errors on subdoc paths (gh-5226)', function() {\n    const schema = Schema({\n      child: {\n        type: Schema({ name: String }),\n        validate: () => false\n      },\n      children: {\n        type: [{ name: String }],\n        validate: () => false\n      }\n    });\n    const Model = db.model('Test', schema);\n\n    const doc = new Model({ child: {}, children: [] });\n    return doc.validate().then(() => assert.ok(false), err => {\n      assert.ok(err);\n      assert.ok(err.errors);\n      assert.ok(err.errors.child);\n      assert.ok(err.errors.children);\n    });\n  });\n\n  it('reports array cast error with index (gh-8888)', function() {\n    const schema = Schema({ test: [Number] },\n      { autoIndex: false, autoCreate: false });\n    const Test = db.model('test', schema);\n\n    const t = new Test({ test: [1, 'world'] });\n    const err = t.validateSync();\n    assert.ok(err);\n    assert.ok(err.errors);\n    assert.ok(err.errors['test.1']);\n  });\n\n  it('sets defaults if setting nested path to empty object with minimize false (gh-8829)', function() {\n    const cartSchema = Schema({\n      _id: 'String',\n      item: {\n        name: { type: 'String', default: 'Default Name' }\n      }\n    },\n    { minimize: false });\n    const Test = db.model('Test', cartSchema);\n\n    const doc = new Test({ _id: 'foobar', item: {} });\n\n    return doc.save().\n      then(() => Test.collection.findOne()).\n      then(doc => assert.equal(doc.item.name, 'Default Name'));\n  });\n\n  it('clears cast errors when setting an array subpath (gh-9080)', function() {\n    const userSchema = new Schema({ tags: [Schema.ObjectId] });\n    const User = db.model('User', userSchema);\n\n    const user = new User({ tags: ['hey'] });\n    user.tags = [];\n\n    const err = user.validateSync();\n    assert.ifError(err);\n  });\n\n  it('saves successfully if you splice() a sliced array (gh-9011)', async function() {\n    const childSchema = Schema({ values: [Number] });\n    const parentSchema = Schema({ children: [childSchema] });\n\n    const Parent = db.model('Parent', parentSchema);\n\n\n    await Parent.create({\n      children: [\n        { values: [1, 2, 3] },\n        { values: [4, 5, 6] }\n      ]\n    });\n\n    const parent = await Parent.findOne();\n    const copy = parent.children[0].values.slice();\n    copy.splice(1);\n\n    await parent.save();\n    const _parent = await Parent.findOne();\n    assert.deepEqual(_parent.toObject().children[0].values, [1, 2, 3]);\n  });\n\n  it('handles modifying a subpath of a nested array of documents (gh-8926)', async function() {\n    const bookSchema = new Schema({ title: String });\n    const aisleSchema = new Schema({\n      shelves: [[bookSchema]]\n    });\n    const librarySchema = new Schema({ aisles: [aisleSchema] });\n\n    const Library = db.model('Test', librarySchema);\n\n\n    await Library.create({\n      aisles: [{ shelves: [[{ title: 'Clean Code' }]] }]\n    });\n\n    const library = await Library.findOne();\n    library.aisles[0].shelves[0][0].title = 'Refactoring';\n    await library.save();\n\n    const foundLibrary = await Library.findOne().lean();\n    assert.equal(foundLibrary.aisles[0].shelves[0][0].title, 'Refactoring');\n  });\n\n  it('Document#save accepts `timestamps` option (gh-8947) for update', async function() {\n\n    // Arrange\n    const userSchema = new Schema({ name: String }, { timestamps: true });\n    const User = db.model('User', userSchema);\n\n    const createdUser = await User.create({ name: 'Hafez' });\n\n    const user = await User.findOne({ _id: createdUser._id });\n\n    // Act\n    user.name = 'John';\n    await user.save({ timestamps: false });\n\n    // Assert\n    assert.deepEqual(createdUser.updatedAt, user.updatedAt);\n  });\n\n  it('Document#save accepts `timestamps` option (gh-8947) on inserting a new document', async function() {\n\n    // Arrange\n    const userSchema = new Schema({ name: String }, { timestamps: true });\n    const User = db.model('User', userSchema);\n\n    const user = new User({ name: 'Hafez' });\n\n    // Act\n    await user.save({ timestamps: false });\n\n    // Assert\n    assert.ok(!user.createdAt);\n    assert.ok(!user.updatedAt);\n  });\n\n  it('Sets default when passing undefined as value for a key in a nested subdoc (gh-12102) (gh-9039)', async function() {\n    const Test = db.model('Test', {\n      nested: {\n        prop: {\n          type: String,\n          default: 'some default value'\n        }\n      }\n    });\n\n    const obj = { nested: { prop: undefined } };\n    const doc = await Test.create(obj);\n    assert.equal(doc.nested.prop, 'some default value');\n\n    assert.deepStrictEqual(obj, { nested: { prop: undefined } });\n  });\n\n  it('allows accessing $locals when initializing (gh-9098)', function() {\n    const personSchema = new mongoose.Schema({\n      name: {\n        first: String,\n        last: String\n      }\n    });\n\n    personSchema.virtual('fullName').\n      get(function() { return this.$locals.fullName; }).\n      set(function(newFullName) { this.$locals.fullName = newFullName; });\n\n    const Person = db.model('Person', personSchema);\n\n    const axl = new Person({ fullName: 'Axl Rose' });\n    assert.equal(axl.fullName, 'Axl Rose');\n  });\n\n  describe('Document#getChanges(...) (gh-9096)', function() {\n    it('returns an empty object when there are no changes', async function() {\n\n      const User = db.model('User', { name: String, age: Number, country: String });\n      const user = await User.create({ name: 'Hafez', age: 25, country: 'Egypt' });\n\n      const changes = user.getChanges();\n      assert.deepEqual(changes, {});\n    });\n\n    it('returns only the changed paths', async function() {\n\n      const User = db.model('User', { name: String, age: Number, country: String });\n      const user = await User.create({ name: 'Hafez', age: 25, country: 'Egypt' });\n\n      user.country = undefined;\n      user.age = 26;\n\n      const changes = user.getChanges();\n      assert.deepEqual(changes, { $set: { age: 26 }, $unset: { country: 1 } });\n    });\n  });\n\n  it('supports skipping defaults on a document (gh-8271)', function() {\n    const testSchema = new mongoose.Schema({\n      testTopLevel: { type: String, default: 'foo' },\n      testNested: {\n        prop: { type: String, default: 'bar' }\n      },\n      testArray: [{ prop: { type: String, default: 'baz' } }],\n      testSingleNested: new Schema({\n        prop: { type: String, default: 'qux' }\n      })\n    });\n    const Test = db.model('Test', testSchema);\n\n    const doc = new Test({ testArray: [{}], testSingleNested: {} }, null,\n      { defaults: false });\n    assert.ok(!doc.testTopLevel);\n    assert.ok(!doc.testNested.prop);\n    assert.ok(!doc.testArray[0].prop);\n    assert.ok(!doc.testSingleNested.prop);\n  });\n\n  it('throws an error when `transform` returns a promise (gh-9163)', function() {\n    const userSchema = new Schema({\n      name: {\n        type: String,\n        transform: function() {\n          return new Promise(() => {});\n        }\n      }\n    });\n\n    const User = db.model('User', userSchema);\n\n    const user = new User({ name: 'Hafez' });\n    assert.throws(function() {\n      user.toJSON();\n    }, /must be synchronous/);\n\n    assert.throws(function() {\n      user.toObject();\n    }, /must be synchronous/);\n  });\n\n  it('uses strict equality when checking mixed paths for modifications (gh-9165)', function() {\n    const schema = Schema({ obj: {} });\n    const Model = db.model('gh9165', schema);\n\n    return Model.create({ obj: { key: '2' } }).\n      then(doc => {\n        doc.obj = { key: 2 };\n        assert.ok(doc.modifiedPaths().indexOf('obj') !== -1);\n        return doc.save();\n      }).\n      then(doc => Model.findById(doc)).\n      then(doc => assert.strictEqual(doc.obj.key, 2));\n  });\n\n  it('supports `useProjection` option for `toObject()` (gh-9118)', function() {\n    const authorSchema = new mongoose.Schema({\n      name: String,\n      hiddenField: { type: String, select: false }\n    });\n\n    const Author = db.model('Author', authorSchema);\n\n    const example = new Author({ name: 'John', hiddenField: 'A secret' });\n    assert.strictEqual(example.toJSON({ useProjection: true }).hiddenField, void 0);\n  });\n\n  it('clears out priorDoc after overwriting single nested subdoc (gh-9208)', async function() {\n    const TestModel = db.model('Test', Schema({\n      nested: Schema({\n        myBool: Boolean,\n        myString: String\n      })\n    }));\n\n\n    const test = new TestModel();\n\n    test.nested = { myBool: true };\n    await test.save();\n\n    test.nested = { myString: 'asdf' };\n    await test.save();\n\n    test.nested.myBool = true;\n    await test.save();\n\n    const doc = await TestModel.findById(test);\n    assert.strictEqual(doc.nested.myBool, true);\n  });\n\n  it('handles immutable properties underneath single nested subdocs when overwriting (gh-9281)', async function() {\n    const SubSchema = Schema({\n      nestedProp: {\n        type: String,\n        immutable: true\n      }\n    }, { strict: 'throw' });\n\n    const TestSchema = Schema({ object: SubSchema }, { strict: 'throw' });\n    const Test = db.model('Test', TestSchema);\n\n\n    await Test.create({ object: { nestedProp: 'A' } });\n    const doc = await Test.findOne();\n\n    doc.object = {};\n    const err = await doc.save().then(() => null, err => err);\n\n    assert.ok(err);\n    assert.ok(err.errors['object']);\n    assert.ok(err.message.includes('Path `nestedProp` is immutable'), err.message);\n\n    // Setting to the same value as the previous doc is ok.\n    doc.object = { nestedProp: 'A' };\n    await doc.save();\n  });\n\n  it('allows removing boolean key by setting it to `undefined` (gh-9275)', async function() {\n    const Test = db.model('Test', Schema({ a: Boolean }));\n\n\n    const doc = await Test.create({ a: true });\n    doc.a = undefined;\n    await doc.save();\n\n    const fromDb = await Test.findOne().lean();\n    assert.ok(!('a' in fromDb));\n  });\n\n  it('keeps manually populated paths when setting a nested path to itself (gh-9293)', async function() {\n    const StepSchema = Schema({\n      ride: { type: ObjectId, ref: 'Ride' },\n      status: Number\n    });\n\n    const RideSchema = Schema({\n      status: Number,\n      steps: {\n        taxi: [{ type: ObjectId, ref: 'Step' }],\n        rent: [{ type: ObjectId, ref: 'Step' }],\n        vehicle: [{ type: ObjectId, ref: 'Step' }]\n      }\n    });\n\n    const Step = db.model('Step', StepSchema);\n    const Ride = db.model('Ride', RideSchema);\n\n\n    let ride = await Ride.create({ status: 0 });\n    const steps = await Step.create([\n      { ride: ride, status: 0 },\n      { ride: ride, status: 1 },\n      { ride: ride, status: 2 }\n    ]);\n\n    ride.steps = { taxi: [steps[0]], rent: [steps[1]], vehicle: [steps[2]] };\n    await ride.save();\n\n    ride = await Ride.findOne({}).populate('steps.taxi steps.vehicle steps.rent');\n\n    assert.equal(ride.steps.taxi[0].status, 0);\n    assert.equal(ride.steps.rent[0].status, 1);\n    assert.equal(ride.steps.vehicle[0].status, 2);\n\n    ride.steps = ride.steps;\n    assert.equal(ride.steps.taxi[0].status, 0);\n    assert.equal(ride.steps.rent[0].status, 1);\n    assert.equal(ride.steps.vehicle[0].status, 2);\n  });\n\n  it('doesnt wipe out nested paths when setting a nested path to itself (gh-9313)', async function() {\n    const schema = new Schema({\n      nested: {\n        prop1: { type: Number, default: 50 },\n        prop2: {\n          type: String,\n          enum: ['val1', 'val2'],\n          default: 'val1',\n          required: true\n        },\n        prop3: {\n          prop4: { type: Number, default: 0 }\n        }\n      }\n    });\n\n    const Model = db.model('Test', schema);\n\n\n    let doc = await Model.create({});\n\n    doc = await Model.findById(doc);\n\n    doc.nested = doc.nested;\n\n    assert.equal(doc.nested.prop2, 'val1');\n    await doc.save();\n\n    const fromDb = await Model.collection.findOne({ _id: doc._id });\n    assert.equal(fromDb.nested.prop2, 'val1');\n  });\n\n  it('allows saving after setting document array to itself (gh-9266)', async function() {\n    const Model = db.model('Test', Schema({ keys: [{ _id: false, name: String }] }));\n\n\n    const document = new Model({});\n\n    document.keys[0] = { name: 'test' };\n    document.keys = document.keys;\n\n    await document.save();\n\n    const fromDb = await Model.findOne();\n    assert.deepEqual(fromDb.toObject().keys, [{ name: 'test' }]);\n  });\n\n  it('allows accessing document values from function default on array (gh-9351) (gh-6155)', function() {\n    const schema = Schema({\n      publisher: String,\n      authors: {\n        type: [String],\n        default: function() {\n          return [this.publisher];\n        }\n      }\n    });\n    const Test = db.model('Test', schema);\n\n    const doc = new Test({ publisher: 'Mastering JS' });\n    assert.deepEqual(doc.toObject().authors, ['Mastering JS']);\n  });\n\n  it('handles pulling array subdocs when _id is an alias (gh-9319)', async function() {\n    const childSchema = Schema({\n      field: {\n        type: String,\n        alias: '_id'\n      }\n    }, { _id: false });\n\n    const parentSchema = Schema({ children: [childSchema] });\n    const Parent = db.model('Parent', parentSchema);\n\n\n    await Parent.create({ children: [{ field: '1' }] });\n    const p = await Parent.findOne();\n\n    p.children.pull('1');\n    await p.save();\n\n    assert.equal(p.children.length, 0);\n\n    const fromDb = await Parent.findOne();\n    assert.equal(fromDb.children.length, 0);\n  });\n\n  it('allows setting nested path to instance of model (gh-9392)', function() {\n    const def = { test: String };\n    const Child = db.model('Child', def);\n\n    const Parent = db.model('Parent', { nested: def });\n\n    const c = new Child({ test: 'new' });\n\n    const p = new Parent({ nested: { test: 'old' } });\n    p.nested = c;\n\n    assert.equal(p.nested.test, 'new');\n  });\n\n  it('unmarks modified if setting a value to the same value as it was previously (gh-9396)', async function() {\n    const schema = new Schema({\n      bar: String\n    });\n\n    const Test = db.model('Test', schema);\n\n    const foo = new Test({ bar: 'bar' });\n    await foo.save();\n    assert.ok(!foo.isModified('bar'));\n\n    foo.bar = 'baz';\n    assert.ok(foo.isModified('bar'));\n\n    foo.bar = 'bar';\n    assert.ok(!foo.isModified('bar'));\n  });\n\n  it('unmarks modified if setting a value to the same subdoc as it was previously (gh-9396)', async function() {\n    const schema = new Schema({\n      nested: { bar: String },\n      subdoc: new Schema({ bar: String }, { _id: false })\n    });\n    const Test = db.model('Test', schema);\n\n\n    const foo = new Test({ nested: { bar: 'bar' }, subdoc: { bar: 'bar' } });\n    await foo.save();\n    assert.ok(!foo.isModified('nested'));\n    assert.ok(!foo.isModified('subdoc'));\n\n    foo.nested = { bar: 'baz' };\n    foo.subdoc = { bar: 'baz' };\n    assert.ok(foo.isModified('nested'));\n    assert.ok(foo.isModified('subdoc'));\n\n    foo.nested = { bar: 'bar' };\n    foo.subdoc = { bar: 'bar' };\n    assert.ok(!foo.isModified('nested'));\n    assert.ok(!foo.isModified('subdoc'));\n    assert.ok(!foo.isModified('subdoc.bar'));\n\n    foo.nested = { bar: 'baz' };\n    foo.subdoc = { bar: 'baz' };\n    assert.ok(foo.isModified('nested'));\n    assert.ok(foo.isModified('subdoc'));\n    await foo.save();\n\n    foo.nested = { bar: 'bar' };\n    foo.subdoc = { bar: 'bar' };\n    assert.ok(foo.isModified('nested'));\n    assert.ok(foo.isModified('subdoc'));\n    assert.ok(foo.isModified('subdoc.bar'));\n  });\n\n  it('correctly tracks saved state for deeply nested objects (gh-10773) (gh-9396)', async function() {\n    const PaymentSchema = Schema({ status: String }, { _id: false });\n    const OrderSchema = new Schema({\n      status: String,\n      payments: {\n        payout: PaymentSchema\n      }\n    });\n\n    const Order = db.model('Order', OrderSchema);\n\n    const order = new Order({\n      status: 'unpaid',\n      payments: {\n        payout: {\n          status: 'unpaid'\n        }\n      }\n    });\n\n    await order.save();\n\n    const newPaymentsStatus = Object.assign({}, order.payments);\n\n    newPaymentsStatus.payout.status = 'paid';\n\n    order.payments = newPaymentsStatus;\n    assert.ok(order.isModified('payments'));\n\n    await order.save();\n\n    const fromDb = await Order.findById(order._id).lean();\n    assert.equal(fromDb.payments.payout.status, 'paid');\n  });\n\n  it('marks path as errored if default function throws (gh-9408)', function() {\n    const jobSchema = new Schema({\n      deliveryAt: Date,\n      subJob: [{\n        deliveryAt: Date,\n        shippingAt: {\n          type: Date,\n          default: () => { throw new Error('Oops!'); }\n        },\n        prop: { type: String, default: 'default' }\n      }]\n    });\n\n    const Job = db.model('Test', jobSchema);\n\n    const doc = new Job({ subJob: [{ deliveryAt: new Date() }] });\n    assert.equal(doc.subJob[0].prop, 'default');\n  });\n\n  it('passes subdoc with initial values set to default function when init-ing (gh-9408)', function() {\n    const jobSchema = new Schema({\n      deliveryAt: Date,\n      subJob: [{\n        deliveryAt: Date,\n        shippingAt: {\n          type: Date,\n          default: function() {\n            return this.deliveryAt;\n          }\n        }\n      }]\n    });\n\n    const Job = db.model('Test', jobSchema);\n\n    const date = new Date();\n    const doc = new Job({ subJob: [{ deliveryAt: date }] });\n\n    assert.equal(doc.subJob[0].shippingAt.valueOf(), date.valueOf());\n  });\n\n  it('passes document as an argument for `required` function in schema definition (gh-9433)', function() {\n    let docFromValidation;\n\n    const userSchema = new Schema({\n      name: {\n        type: String,\n        required: (doc) => {\n          docFromValidation = doc;\n          return doc.age > 18;\n        }\n      },\n      age: Number\n    });\n\n    const User = db.model('User', userSchema);\n    const user = new User({ age: 26 });\n    const err = user.validateSync();\n    assert.ok(err);\n\n    assert.ok(docFromValidation === user);\n  });\n\n  it('works with path named isSelected (gh-9438)', function() {\n    const categorySchema = new Schema({\n      name: String,\n      categoryUrl: { type: String, required: true }, // Makes test fail\n      isSelected: Boolean\n    });\n\n    const siteSchema = new Schema({ categoryUrls: [categorySchema] });\n\n    const Test = db.model('Test', siteSchema);\n    const test = new Test({\n      categoryUrls: [\n        { name: 'A', categoryUrl: 'B', isSelected: false, isModified: false }\n      ]\n    });\n    const err = test.validateSync();\n    assert.ifError(err);\n  });\n\n  it('init tracks cast error reason (gh-9448)', function() {\n    const Test = db.model('Test', Schema({\n      num: Number\n    }));\n\n    const doc = new Test();\n    doc.init({ num: 'not a number' });\n\n    const err = doc.validateSync();\n    assert.ok(err.errors['num'].reason);\n  });\n\n  it('correctly handles setting nested path underneath single nested subdocs (gh-9459)', function() {\n    const preferencesSchema = mongoose.Schema({\n      notifications: {\n        email: Boolean,\n        push: Boolean\n      },\n      keepSession: Boolean\n    }, { _id: false });\n\n    const User = db.model('User', Schema({\n      email: String,\n      username: String,\n      preferences: preferencesSchema\n    }));\n\n    const userFixture = {\n      email: 'foo@bar.com',\n      username: 'foobars',\n      preferences: {\n        keepSession: true,\n        notifications: {\n          email: false,\n          push: false\n        }\n      }\n    };\n\n    let userWithEmailNotifications = Object.assign({}, userFixture, {\n      'preferences.notifications': { email: true }\n    });\n    let testUser = new User(userWithEmailNotifications);\n\n    assert.deepEqual(testUser.toObject().preferences.notifications, { email: true });\n\n    userWithEmailNotifications = Object.assign({}, userFixture, {\n      'preferences.notifications.email': true\n    });\n    testUser = new User(userWithEmailNotifications);\n\n    assert.deepEqual(testUser.toObject().preferences.notifications, { email: true, push: false });\n  });\n\n  it('$isValid() with space-delimited and array syntax (gh-9474)', function() {\n    const Test = db.model('Test', Schema({\n      name: String,\n      email: String,\n      age: Number,\n      answer: Number\n    }));\n\n    const doc = new Test({ name: 'test', email: 'test@gmail.com', age: 'bad', answer: 'bad' });\n\n    assert.ok(doc.$isValid('name'));\n    assert.ok(doc.$isValid('email'));\n    assert.ok(!doc.$isValid('age'));\n    assert.ok(!doc.$isValid('answer'));\n\n    assert.ok(doc.$isValid('name email'));\n    assert.ok(doc.$isValid('name age'));\n    assert.ok(!doc.$isValid('age answer'));\n\n    assert.ok(doc.$isValid(['name', 'email']));\n    assert.ok(doc.$isValid(['name', 'age']));\n    assert.ok(!doc.$isValid(['age', 'answer']));\n  });\n\n  it('avoids overwriting array subdocument when setting dotted path that is not selected (gh-9427)', async function() {\n    const Test = db.model('Test', Schema({\n      arr: [{ _id: false, val: Number }],\n      name: String,\n      age: Number\n    }));\n\n\n    let doc = await Test.create({\n      name: 'Test',\n      arr: [{ val: 1 }, { val: 2 }],\n      age: 30\n    });\n\n    doc = await Test.findById(doc._id).select('name');\n    doc.set('arr.0.val', 2);\n    await doc.save();\n\n    const fromDb = await Test.findById(doc._id);\n    assert.deepEqual(fromDb.toObject().arr, [{ val: 2 }, { val: 2 }]);\n  });\n\n  it('ignore getters when diffing objects for change tracking (gh-9501)', async function() {\n    const schema = new Schema({\n      title: {\n        type: String,\n        required: true\n      },\n      price: {\n        type: Number,\n        min: 0\n      },\n      taxPercent: {\n        type: Number,\n        required: function() {\n          return this.price != null;\n        },\n        min: 0,\n        max: 100,\n        get: value => value || 10\n      }\n    });\n\n    const Test = db.model('Test', schema);\n\n\n    const doc = await Test.create({\n      title: 'original'\n    });\n\n    doc.set({\n      title: 'updated',\n      price: 10,\n      taxPercent: 10\n    });\n\n    assert.ok(doc.modifiedPaths().indexOf('taxPercent') !== -1);\n\n    await doc.save();\n\n    const fromDb = await Test.findById(doc).lean();\n    assert.equal(fromDb.taxPercent, 10);\n  });\n\n  it('allows defining middleware for all document hooks using regexp (gh-9190)', async function() {\n    const schema = Schema({ name: String });\n\n    let called = 0;\n    schema.pre(/.*/, { document: true, query: false }, function() {\n      ++called;\n    });\n    const Model = db.model('Test', schema);\n\n\n    await Model.find();\n    assert.equal(called, 0);\n\n    await Model.findOne();\n    assert.equal(called, 0);\n\n    await Model.countDocuments();\n    assert.equal(called, 0);\n\n    const docs = await Model.create([{ name: 'test' }], { validateBeforeSave: false });\n    assert.equal(called, 1);\n\n    await docs[0].validate();\n    assert.equal(called, 2);\n\n    await docs[0].updateOne({ name: 'test2' });\n    assert.equal(called, 3);\n\n    await Model.aggregate([{ $match: { name: 'test' } }]);\n    assert.equal(called, 3);\n  });\n\n  it('correctly handles setting nested props to other nested props (gh-9519)', async function() {\n    const schemaA = Schema({\n      propX: {\n        nested1: { prop: Number },\n        nested2: { prop: Number },\n        nested3: { prop: Number }\n      },\n      propY: {\n        nested1: { prop: Number },\n        nested2: { prop: Number },\n        nested3: { prop: Number }\n      }\n    });\n\n    const schemaB = Schema({ prop: { prop: Number } });\n\n    const ModelA = db.model('Test1', schemaA);\n    const ModelB = db.model('Test2', schemaB);\n\n\n    const saved = await ModelA.create({\n      propX: {\n        nested1: { prop: 1 },\n        nested2: { prop: 1 },\n        nested3: { prop: 1 }\n      },\n      propY: {\n        nested1: { prop: 2 },\n        nested2: { prop: 2 },\n        nested3: { prop: 2 }\n      }\n    });\n\n    const objA = await ModelA.findById(saved._id);\n    const objB = new ModelB();\n\n    objB.prop = objA.propX.nested1;\n\n    assert.strictEqual(objB.prop.prop, 1);\n  });\n\n  it('sets fields after an undefined field (gh-9585)', function() {\n    const personSchema = new Schema({\n      items: { type: Array },\n      email: { type: String }\n    });\n\n    const Person = db.model('Person', personSchema);\n\n\n    const person = new Person({ items: undefined, email: 'test@gmail.com' });\n    assert.equal(person.email, 'test@gmail.com');\n  });\n\n  it('passes document to `default` functions (gh-9633)', function() {\n    let documentFromDefault;\n    const userSchema = new Schema({\n      name: { type: String },\n      age: {\n        type: Number,\n        default: function(doc) {\n          documentFromDefault = doc;\n        }\n      }\n\n    });\n\n    const User = db.model('User', userSchema);\n\n    const user = new User({ name: 'Hafez' });\n\n    assert.ok(documentFromDefault === user);\n    assert.equal(documentFromDefault.name, 'Hafez');\n  });\n\n  it('handles pre hook throwing a sync error (gh-9659)', async function() {\n    const TestSchema = new Schema({ name: String });\n\n    TestSchema.pre('save', function() {\n      throw new Error('test err');\n    });\n    const TestModel = db.model('Test', TestSchema);\n\n\n    const testObject = new TestModel({ name: 't' });\n\n    const err = await testObject.save().then(() => null, err => err);\n    assert.ok(err);\n    assert.equal(err.message, 'test err');\n  });\n\n  it('returns undefined rather than entire object when calling `get()` with empty string (gh-9681)', function() {\n    const TestSchema = new Schema({ name: String });\n    const TestModel = db.model('Test', TestSchema);\n\n    const testObject = new TestModel({ name: 't' });\n\n    assert.strictEqual(testObject.get(''), void 0);\n  });\n\n  it('keeps atomics when assigning array to filtered array (gh-9651)', async function() {\n    const Model = db.model('Test', { arr: [{ abc: String }] });\n\n\n    const m1 = new Model({ arr: [{ abc: 'old' }] });\n    await m1.save();\n\n    const m2 = await Model.findOne({ _id: m1._id });\n\n    m2.arr = [];\n    m2.arr = m2.arr.filter(() => true);\n    m2.arr.push({ abc: 'ghi' });\n    await m2.save();\n\n    const fromDb = await Model.findById(m1._id);\n    assert.equal(fromDb.arr.length, 1);\n    assert.equal(fromDb.arr[0].abc, 'ghi');\n  });\n\n  it('does not pass doc to ObjectId or Date.now (gh-9633) (gh-9636)', function() {\n    const userSchema = new Schema({\n      parentId: { type: Schema.ObjectId, ref: 'User', default: () => new mongoose.Types.ObjectId() },\n      createdAt: { type: Date, default: Date.now }\n    });\n\n    const User = db.model('User', userSchema);\n\n    const user = new User();\n\n    assert.ok(user.parentId instanceof mongoose.Types.ObjectId);\n    assert.ok(user.createdAt instanceof Date);\n  });\n\n  it('supports getting a list of populated docs (gh-9702)', async function() {\n    const Child = db.model('Child', Schema({ name: String }));\n    const Parent = db.model('Parent', {\n      children: [{ type: ObjectId, ref: 'Child' }],\n      child: { type: ObjectId, ref: 'Child' }\n    });\n\n\n    const c = await Child.create({ name: 'test' });\n    await Parent.create({\n      children: [c._id],\n      child: c._id\n    });\n\n    const p = await Parent.findOne();\n    await p.populate('children');\n    await p.populate('child');\n\n    p.children; // [{ _id: '...', name: 'test' }]\n\n    assert.equal(p.$getPopulatedDocs().length, 2);\n    assert.equal(p.$getPopulatedDocs()[0], p.children[0]);\n    assert.equal(p.$getPopulatedDocs()[0].name, 'test');\n    assert.equal(p.$getPopulatedDocs()[1], p.child);\n    assert.equal(p.$getPopulatedDocs()[1].name, 'test');\n  });\n\n  it('with virtual populate (gh-10148)', async function() {\n    const childSchema = Schema({ name: String, parentId: 'ObjectId' });\n    childSchema.virtual('parent', {\n      ref: 'Parent',\n      localField: 'parentId',\n      foreignField: '_id',\n      justOne: true\n    });\n    const Child = db.model('Child', childSchema);\n\n    const Parent = db.model('Parent', Schema({ name: String }));\n\n\n    const p = await Parent.create({ name: 'Anakin' });\n    await Child.create({ name: 'Luke', parentId: p._id });\n\n    const res = await Child.findOne().populate('parent');\n    assert.equal(res.parent.name, 'Anakin');\n    const docs = res.$getPopulatedDocs();\n    assert.equal(docs.length, 1);\n    assert.equal(docs[0].name, 'Anakin');\n  });\n\n  it('handles paths named `db` (gh-9798)', async function() {\n    const schema = new Schema({\n      db: String\n    });\n    const Test = db.model('Test', schema);\n\n\n    const doc = await Test.create({ db: 'foo' });\n    doc.db = 'bar';\n    await doc.save();\n    await doc.deleteOne();\n\n    const _doc = await Test.findOne({ db: 'bar' });\n    assert.ok(!_doc);\n  });\n\n  it('handles paths named `schema` gh-8798', async function() {\n    const schema = new Schema({\n      schema: String,\n      name: String\n    });\n    const Test = db.model('Test', schema);\n\n\n    const doc = await Test.create({ schema: 'test', name: 'test' });\n    await doc.save();\n    assert.ok(doc);\n    assert.equal(doc.schema, 'test');\n    assert.equal(doc.name, 'test');\n\n    const fromDb = await Test.findById(doc);\n    assert.equal(fromDb.schema, 'test');\n    assert.equal(fromDb.name, 'test');\n\n    doc.schema = 'test2';\n    await doc.save();\n\n    await fromDb.remove();\n    doc.name = 'test3';\n    const err = await doc.save().then(() => null, err => err);\n    assert.ok(err);\n    assert.equal(err.name, 'DocumentNotFoundError');\n  });\n\n  it('handles nested paths named `schema` gh-8798', async function() {\n    const schema = new Schema({\n      nested: {\n        schema: String\n      },\n      name: String\n    });\n    const Test = db.model('Test', schema);\n\n\n    const doc = await Test.create({ nested: { schema: 'test' }, name: 'test' });\n    await doc.save();\n    assert.ok(doc);\n    assert.equal(doc.nested.schema, 'test');\n    assert.equal(doc.name, 'test');\n\n    const fromDb = await Test.findById(doc);\n    assert.equal(fromDb.nested.schema, 'test');\n    assert.equal(fromDb.name, 'test');\n\n    doc.nested.schema = 'test2';\n    await doc.save();\n  });\n\n  it('object setters will be applied for each object in array after populate (gh-9838)', async function() {\n    const updatedElID = '123456789012345678901234';\n\n    const ElementSchema = new Schema({\n      name: 'string',\n      nested: [{ type: Schema.Types.ObjectId, ref: 'Nested' }]\n    });\n\n    const NestedSchema = new Schema({});\n\n    const Element = db.model('Test', ElementSchema);\n    const NestedElement = db.model('Nested', NestedSchema);\n\n\n    const nes = new NestedElement({});\n    await nes.save();\n    const ele = new Element({ nested: [nes.id], name: 'test' });\n    await ele.save();\n\n    const ss = await Element.findById(ele._id).populate({ path: 'nested', model: NestedElement });\n    ss.nested = [updatedElID];\n    await ss.save();\n\n    assert.ok(typeof ss.nested[0] !== 'string');\n    assert.equal(ss.nested[0].toHexString(), updatedElID);\n  });\n  it('gh9884', async function() {\n\n\n    const obi = new Schema({\n      eType: {\n        type: String,\n        required: true,\n        uppercase: true\n      },\n      eOrigin: {\n        type: String,\n        required: true\n      },\n      eIds: [\n        {\n          type: String\n        }\n      ]\n    }, { _id: false });\n\n    const schema = new Schema({\n      name: String,\n      description: String,\n      isSelected: {\n        type: Boolean,\n        default: false\n      },\n      wan: {\n        type: [obi],\n        default: undefined,\n        required: true\n      }\n    });\n\n    const newDoc = {\n      name: 'name',\n      description: 'new desc',\n      isSelected: true,\n      wan: [\n        {\n          eType: 'X',\n          eOrigin: 'Y',\n          eIds: ['Y', 'Z']\n        }\n      ]\n    };\n\n    const Model = db.model('Test', schema);\n    await Model.create(newDoc);\n    const doc = await Model.findOne();\n    assert.ok(doc);\n  });\n\n  it('Makes sure pre remove hook is executed gh-9885', async function() {\n    const SubSchema = new Schema({\n      myValue: {\n        type: String\n      }\n    }, {});\n    let count = 0;\n    SubSchema.pre('remove', function(next) {\n      count++;\n      next();\n    });\n    const thisSchema = new Schema({\n      foo: {\n        type: String,\n        required: true\n      },\n      mySubdoc: {\n        type: [SubSchema],\n        required: true\n      }\n    }, { minimize: false, collection: 'test' });\n\n    const Model = db.model('TestModel', thisSchema);\n\n\n    await Model.deleteMany({}); // remove all existing documents\n    const newModel = {\n      foo: 'bar',\n      mySubdoc: [{ myValue: 'some value' }]\n    };\n    const document = await Model.create(newModel);\n    document.mySubdoc[0].remove();\n    await document.save().catch((error) => {\n      console.error(error);\n    });\n    assert.equal(count, 1);\n  });\n\n  it('gh9880', function(done) {\n    const testSchema = new Schema({\n      prop: String,\n      nestedProp: {\n        prop: String\n      }\n    });\n    const Test = db.model('Test', testSchema);\n\n    new Test({\n      prop: 'Test',\n      nestedProp: null\n    }).save((err, doc) => {\n      doc.id;\n      doc.nestedProp;\n\n      // let's clone this document:\n      new Test({\n        prop: 'Test 2',\n        nestedProp: doc.nestedProp\n      });\n\n      Test.updateOne({\n        _id: doc._id\n      }, {\n        nestedProp: null\n      }, (err) => {\n        assert.ifError(err);\n        Test.findOne({\n          _id: doc._id\n        }, (err, updatedDoc) => {\n          assert.ifError(err);\n          new Test({\n            prop: 'Test 3',\n            nestedProp: updatedDoc.nestedProp\n          });\n          done();\n        });\n      });\n    });\n  });\n\n  it('handles directly setting embedded document array element with projection (gh-9909)', async function() {\n    const schema = Schema({\n      elements: [{\n        text: String,\n        subelements: [{\n          text: String\n        }]\n      }]\n    });\n\n    const Test = db.model('Test', schema);\n\n\n    let doc = await Test.create({ elements: [{ text: 'hello' }] });\n    doc = await Test.findById(doc).select('elements');\n\n    doc.elements[0].subelements[0] = { text: 'my text' };\n    await doc.save();\n\n    const fromDb = await Test.findById(doc).lean();\n    assert.equal(fromDb.elements.length, 1);\n    assert.equal(fromDb.elements[0].subelements.length, 1);\n    assert.equal(fromDb.elements[0].subelements[0].text, 'my text');\n  });\n\n  it('toObject() uses child schema `flattenMaps` option by default (gh-9995)', async function() {\n    const MapSchema = new Schema({\n      value: { type: Number }\n    }, { _id: false });\n\n    const ChildSchema = new Schema({\n      map: { type: Map, of: MapSchema }\n    });\n    ChildSchema.set('toObject', { flattenMaps: true });\n\n    const ParentSchema = new Schema({\n      child: { type: Schema.ObjectId, ref: 'Child' }\n    });\n\n    const ChildModel = db.model('Child', ChildSchema);\n    const ParentModel = db.model('Parent', ParentSchema);\n\n\n    const childDocument = new ChildModel({\n      map: { first: { value: 1 }, second: { value: 2 } }\n    });\n    await childDocument.save();\n\n    const parentDocument = new ParentModel({ child: childDocument });\n    await parentDocument.save();\n\n    const resultDocument = await ParentModel.findOne().populate('child').exec();\n\n    let resultObject = resultDocument.toObject();\n    assert.ok(resultObject.child.map);\n    assert.ok(!(resultObject.child.map instanceof Map));\n\n    resultObject = resultDocument.toObject({ flattenMaps: false });\n    assert.ok(resultObject.child.map instanceof Map);\n  });\n\n  it('does not double validate paths under mixed objects (gh-10141)', async function() {\n    let validatorCallCount = 0;\n    const Test = db.model('Test', Schema({\n      name: String,\n      object: {\n        type: Object,\n        validate: () => {\n          validatorCallCount++;\n          return true;\n        }\n      }\n    }));\n\n\n    const doc = await Test.create({ name: 'test', object: { answer: 42 } });\n\n    validatorCallCount = 0;\n    doc.set('object.question', 'secret');\n    doc.set('object.answer', 0);\n    await doc.validate();\n    assert.equal(validatorCallCount, 0);\n  });\n\n  it('clears child document modified when setting map path underneath single nested (gh-10295)', async function() {\n    const SecondMapSchema = new mongoose.Schema({\n      data: { type: Map, of: Number, default: {}, _id: false }\n    });\n\n    const FirstMapSchema = new mongoose.Schema({\n      data: { type: Map, of: SecondMapSchema, default: {}, _id: false }\n    });\n\n    const NestedSchema = new mongoose.Schema({\n      data: { type: Map, of: SecondMapSchema, default: {}, _id: false }\n    });\n\n    const TestSchema = new mongoose.Schema({\n      _id: Number,\n      firstMap: { type: Map, of: FirstMapSchema, default: {}, _id: false },\n      nested: { type: NestedSchema, default: {}, _id: false }\n    });\n\n    const Test = db.model('Test', TestSchema);\n\n\n    const doc = await Test.create({ _id: Date.now() });\n\n    doc.nested.data.set('second', {});\n    assert.ok(doc.modifiedPaths().indexOf('nested.data.second') !== -1, doc.modifiedPaths());\n    await doc.save();\n\n    doc.nested.data.get('second').data.set('final', 3);\n    assert.ok(doc.modifiedPaths().indexOf('nested.data.second.data.final') !== -1, doc.modifiedPaths());\n    await doc.save();\n\n    const fromDb = await Test.findById(doc).lean();\n    assert.equal(fromDb.nested.data.second.data.final, 3);\n  });\n\n  it('avoids infinite recursion when setting single nested subdoc to array (gh-10351)', async function() {\n    const userInfoSchema = new mongoose.Schema({ _id: String }, { _id: false });\n    const observerSchema = new mongoose.Schema({ user: {} }, { _id: false });\n\n    const entrySchema = new mongoose.Schema({\n      creator: userInfoSchema,\n      observers: [observerSchema]\n    });\n\n    entrySchema.pre('save', function(next) {\n      this.observers = [{ user: this.creator }];\n\n      next();\n    });\n\n    const Test = db.model('Test', entrySchema);\n\n\n    const entry = new Test({\n      creator: { _id: 'u1' }\n    });\n\n    await entry.save();\n\n    const fromDb = await Test.findById(entry);\n    assert.equal(fromDb.observers.length, 1);\n  });\n\n  describe('reserved keywords can be used optionally (gh-9010)', () => {\n    describe('Document#validate(...)', () => {\n      it('is available as `$validate`', async() => {\n        const userSchema = new Schema({\n          name: String\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ name: 'Sam' });\n        const err = await user.$validate();\n        assert.ok(err == null);\n        assert.equal(user.$validate, user.validate);\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: String,\n          validate: Boolean\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ name: 'Sam', validate: true });\n        assert.equal(user.validate, true);\n      });\n    });\n    describe('Document#save(...)', () => {\n      it('is available as `$save`', async() => {\n        const userSchema = new Schema({\n          name: String\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ name: 'Sam' });\n        const userFromSave = await user.$save();\n        assert.ok(userFromSave === user);\n        assert.equal(user.$save, user.save);\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: String,\n          save: Boolean\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ name: 'Sam', save: true });\n        assert.equal(user.save, true);\n      });\n    });\n    describe('Document#isModified(...)', () => {\n      it('is available as `$isModified`', async() => {\n        const userSchema = new Schema({\n          name: String\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ name: 'Sam' });\n        await user.save();\n\n        assert.ok(user.$isModified() === false);\n\n        user.name = 'John';\n        assert.ok(user.$isModified() === true);\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: String,\n          isModified: String\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ name: 'Sam', isModified: 'nope' });\n        assert.equal(user.isModified, 'nope');\n      });\n    });\n    describe('Document#isNew', () => {\n      it('is available as `$isNew`', async() => {\n        const userSchema = new Schema({\n          name: String\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ name: 'Sam' });\n\n        assert.ok(user.$isNew === true);\n        await user.save();\n        assert.ok(user.$isNew === false);\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: String,\n          isNew: String\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ name: 'Sam', isNew: 'yep' });\n        assert.equal(user.isNew, 'yep');\n      });\n    });\n    describe('Document#populated(...)', () => {\n      it('is available as `$populated`', async() => {\n        const userSchema = new Schema({ name: String });\n        const User = db.model('User', userSchema);\n\n        const postSchema = new Schema({\n          title: String,\n          userId: { type: Schema.ObjectId, ref: 'User' }\n        });\n        const Post = db.model('Post', postSchema);\n\n        const user = await User.create({ name: 'Sam' });\n\n        const postFromCreate = await Post.create({ title: 'I am a title', userId: user._id });\n\n        const post = await Post.findOne({ _id: postFromCreate }).populate({ path: 'userId' });\n\n        assert.ok(post.$populated('userId'));\n        post.depopulate('userId');\n        assert.ok(!post.$populated('userId'));\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: String,\n          populated: String\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ name: 'Sam', populated: 'yep' });\n        assert.equal(user.populated, 'yep');\n      });\n    });\n    describe('Document#toObject(...)', () => {\n      it('is available as `$toObject`', async() => {\n        const userSchema = new Schema({ name: String });\n        const User = db.model('User', userSchema);\n\n        const user = await User.create({ name: 'Sam' });\n\n        assert.deepEqual(user.$toObject(), user.toObject());\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: String,\n          toObject: String\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ name: 'Sam', toObject: 'yep' });\n        assert.equal(user.toObject, 'yep');\n      });\n    });\n    describe('Document#init(...)', () => {\n      it('is available as `$init`', async() => {\n        const userSchema = new Schema({ name: String });\n        const User = db.model('User', userSchema);\n\n        const user = new User();\n        const sam = new User({ name: 'Sam' });\n\n        assert.equal(user.$init(sam).name, 'Sam');\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: String,\n          init: Number\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ name: 'Sam', init: 12 });\n        assert.equal(user.init, 12);\n      });\n    });\n    xdescribe('Document#collection', () => {\n      it('is available as `$collection`', async() => {\n        const userSchema = new Schema({ name: String });\n        const User = db.model('User', userSchema);\n\n        const user = await User.create({ name: 'Hafez' });\n        const userFromCollection = await user.$collection.findOne({ _id: user._id });\n        assert.ok(userFromCollection);\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          collection: Number\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ collection: 12 });\n        assert.equal(user.collection, 12);\n        assert.ok(user.$collection !== user.collection);\n        assert.ok(user.$collection);\n      });\n    });\n    describe('Document#errors', () => {\n      it('is available as `$errors`', async() => {\n        const userSchema = new Schema({ name: { type: String, required: true } });\n        const User = db.model('User', userSchema);\n\n        const user = new User();\n        user.validateSync();\n\n        assert.ok(user.$errors.name.kind === 'required');\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: { type: String, required: true },\n          errors: Number\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ errors: 12 });\n        user.validateSync();\n\n        assert.equal(user.errors, 12);\n\n        assert.ok(user.$errors.name.kind === 'required');\n      });\n    });\n    describe('Document#removeListener', () => {\n      it('is available as `$removeListener`', async() => {\n        const userSchema = new Schema({ name: String });\n        const User = db.model('User', userSchema);\n\n        const user = new User({ name: 'Hafez' });\n\n        assert.ok(user.$removeListener('save', () => {}));\n        assert.ok(user.$removeListener === user.removeListener);\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: { type: String, required: true },\n          removeListener: Number\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ removeListener: 12 });\n\n        assert.equal(user.removeListener, 12);\n      });\n    });\n    describe('Document#listeners', () => {\n      it('is available as `$listeners`', async() => {\n        const userSchema = new Schema({ name: String });\n        const User = db.model('User', userSchema);\n\n        const user = new User({ name: 'Hafez' });\n\n        assert.ok(user.$listeners === user.listeners);\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: { type: String, required: true },\n          listeners: Number\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ listeners: 12 });\n\n        assert.equal(user.listeners, 12);\n      });\n    });\n    describe('Document#on', () => {\n      it('is available as `$on`', async() => {\n        const userSchema = new Schema({ name: String });\n        const User = db.model('User', userSchema);\n\n        const user = new User({ name: 'Hafez' });\n\n        assert.ok(user.$on === user.on);\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: { type: String, required: true },\n          on: Number\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ on: 12 });\n\n        assert.equal(user.on, 12);\n      });\n    });\n    describe('Document#emit', () => {\n      it('is available as `$emit`', async() => {\n        const userSchema = new Schema({ name: String });\n        const User = db.model('User', userSchema);\n\n        const user = new User({ name: 'Hafez' });\n\n        assert.ok(user.$emit === user.emit);\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: { type: String, required: true },\n          emit: Number\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ emit: 12 });\n\n        assert.equal(user.emit, 12);\n      });\n    });\n    describe('Document#get', () => {\n      it('is available as `$get`', async() => {\n        const userSchema = new Schema({ name: String });\n        const User = db.model('User', userSchema);\n\n        const user = new User({ name: 'Hafez' });\n\n        assert.ok(user.$get === user.get);\n      });\n      it('can be used as a property in documents', () => {\n        const userSchema = new Schema({\n          name: { type: String, required: true },\n          get: Number\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ get: 12 });\n\n        assert.equal(user.get, 12);\n      });\n    });\n    describe('Document#remove', () => {\n      it('is available as `$remove`', async() => {\n        const userSchema = new Schema({ name: String });\n        const User = db.model('User', userSchema);\n\n        const user = new User({ name: 'Hafez' });\n        await user.save();\n        await user.$remove();\n        const userFromDB = await User.findOne({ _id: user._id });\n\n        assert.ok(userFromDB == null);\n      });\n      it('can be used as a property in documents', async() => {\n        const userSchema = new Schema({\n          remove: Number\n        });\n\n        const User = db.model('User', userSchema);\n        const user = new User({ remove: 12 });\n\n        assert.equal(user.remove, 12);\n\n        await user.save();\n        await user.$remove();\n        const userFromDB = await User.findOne({ _id: user._id });\n\n        assert.ok(userFromDB == null);\n      });\n    });\n  });\n\n  describe('virtuals `pathsToSkip` (gh-10120)', () => {\n    it('adds support for `pathsToSkip` for virtuals feat-10120', function() {\n      const schema = new mongoose.Schema({\n        name: String,\n        age: Number,\n        nested: {\n          test: String\n        }\n      });\n      schema.virtual('nameUpper').get(function() { return this.name.toUpperCase(); });\n      schema.virtual('answer').get(() => 42);\n      schema.virtual('nested.hello').get(() => 'world');\n\n      const Model = db.model('Person', schema);\n      const doc = new Model({ name: 'Jean-Luc Picard', age: 59, nested: { test: 'hello' } });\n      let obj = doc.toObject({ virtuals: { pathsToSkip: ['answer'] } });\n      assert.ok(obj.nameUpper);\n      assert.equal(obj.answer, null);\n      assert.equal(obj.nested.hello, 'world');\n      obj = doc.toObject({ virtuals: { pathsToSkip: ['nested.hello'] } });\n      assert.equal(obj.nameUpper, 'JEAN-LUC PICARD');\n      assert.equal(obj.answer, 42);\n      assert.equal(obj.nested.hello, null);\n    });\n\n    it('supports passing a list of virtuals to `toObject()` (gh-10120)', function() {\n      const schema = new mongoose.Schema({\n        name: String,\n        age: Number,\n        nested: {\n          test: String\n        }\n      });\n      schema.virtual('nameUpper').get(function() { return this.name.toUpperCase(); });\n      schema.virtual('answer').get(() => 42);\n      schema.virtual('nested.hello').get(() => 'world');\n\n      const Model = db.model('Person', schema);\n\n      const doc = new Model({ name: 'Jean-Luc Picard', age: 59, nested: { test: 'hello' } });\n\n      let obj = doc.toObject({ virtuals: true });\n      assert.equal(obj.nameUpper, 'JEAN-LUC PICARD');\n      assert.equal(obj.answer, 42);\n      assert.equal(obj.nested.hello, 'world');\n\n      obj = doc.toObject({ virtuals: ['answer'] });\n      assert.ok(!obj.nameUpper);\n      assert.equal(obj.answer, 42);\n      assert.equal(obj.nested.hello, null);\n\n      obj = doc.toObject({ virtuals: ['nameUpper'] });\n      assert.equal(obj.nameUpper, 'JEAN-LUC PICARD');\n      assert.equal(obj.answer, null);\n      assert.equal(obj.nested.hello, null);\n\n      obj = doc.toObject({ virtuals: ['nested.hello'] });\n      assert.equal(obj.nameUpper, null);\n      assert.equal(obj.answer, null);\n      assert.equal(obj.nested.hello, 'world');\n    });\n  });\n  describe('validation `pathsToSkip` (gh-10230)', () => {\n    it('support `pathsToSkip` option for `Document#validate()`', async function() {\n\n      const User = getUserModel();\n      const user = new User();\n\n      const err1 = await user.validate({ pathsToSkip: ['age'] }).then(() => null, err => err);\n      assert.deepEqual(Object.keys(err1.errors), ['name']);\n\n      const err2 = await user.validate({ pathsToSkip: ['name'] }).then(() => null, err => err);\n      assert.deepEqual(Object.keys(err2.errors), ['age']);\n    });\n\n    it('support `pathsToSkip` option for `Document#validate()`', async function() {\n\n      const User = getUserModel();\n      const user = new User();\n\n      const err1 = await user.validate({ pathsToSkip: ['age'] }).then(() => null, err => err);\n      assert.deepEqual(Object.keys(err1.errors), ['name']);\n\n      const err2 = await user.validate({ pathsToSkip: ['name'] }).then(() => null, err => err);\n      assert.deepEqual(Object.keys(err2.errors), ['age']);\n    });\n\n    it('support `pathsToSkip` option for `Document#validateSync()`', () => {\n      const User = getUserModel();\n\n      const user = new User();\n\n      const err1 = user.validateSync({ pathsToSkip: ['age'] });\n      assert.deepEqual(Object.keys(err1.errors), ['name']);\n\n      const err2 = user.validateSync({ pathsToSkip: ['name'] });\n      assert.deepEqual(Object.keys(err2.errors), ['age']);\n    });\n\n    // skip until gh-10367 is implemented\n    xit('support `pathsToSkip` option for `Model.validate()`', async() => {\n\n      const User = getUserModel();\n      const err1 = await User.validate({}, { pathsToSkip: ['age'] });\n      assert.deepEqual(Object.keys(err1.errors), ['name']);\n\n      const err2 = await User.validate({}, { pathsToSkip: ['name'] });\n      assert.deepEqual(Object.keys(err2.errors), ['age']);\n    });\n\n    it('`pathsToSkip` accepts space separated paths', async() => {\n      const userSchema = Schema({\n        name: { type: String, required: true },\n        age: { type: Number, required: true },\n        country: { type: String, required: true },\n        rank: { type: String, required: true }\n      });\n\n      const User = db.model('User', userSchema);\n\n      const user = new User({ name: 'Sam', age: 26 });\n\n      const err1 = user.validateSync({ pathsToSkip: 'country rank' });\n      assert.ok(err1 == null);\n\n      const err2 = await user.validate({ pathsToSkip: 'country rank' }).then(() => null, err => err);\n      assert.ok(err2 == null);\n    });\n\n\n    function getUserModel() {\n      const userSchema = Schema({\n        name: { type: String, required: true },\n        age: { type: Number, required: true },\n        rank: String\n      });\n\n      const User = db.model('User', userSchema);\n      return User;\n    }\n  });\n\n  it('skips recursive merging (gh-9121)', function() {\n    // Subdocument\n    const subdocumentSchema = new mongoose.Schema({\n      child: new mongoose.Schema({ name: String, age: Number }, { _id: false })\n    });\n    const Subdoc = mongoose.model('Subdoc', subdocumentSchema);\n\n    // Nested path\n    const nestedSchema = new mongoose.Schema({\n      child: { name: String, age: Number }\n    });\n    const Nested = mongoose.model('Nested', nestedSchema);\n\n    const doc1 = new Subdoc({ child: { name: 'Luke', age: 19 } });\n    doc1.set({ child: { age: 21 } });\n    assert.deepEqual(doc1.toObject().child, { age: 21 });\n\n    const doc2 = new Nested({ child: { name: 'Luke', age: 19 } });\n    doc2.set({ child: { age: 21 } });\n    assert.deepEqual(doc2.toObject().child, { age: 21 });\n  });\n\n  it('does not pull non-schema paths from parent documents into nested paths (gh-10449)', function() {\n    const schema = new Schema({\n      name: String,\n      nested: {\n        data: String\n      }\n    });\n    const Test = db.model('Test', schema);\n\n    const doc = new Test({});\n    doc.otherProp = 'test';\n\n    assert.ok(!doc.nested.otherProp);\n  });\n\n  it('sets properties in the order they are defined in the schema (gh-4665)', async function() {\n    const schema = new Schema({\n      test: String,\n      internal: {\n        status: String,\n        createdAt: Date\n      },\n      profile: {\n        name: {\n          first: String,\n          last: String\n        }\n      }\n    });\n    const Test = db.model('Test', schema);\n\n\n    const doc = new Test({\n      profile: { name: { last: 'Musashi', first: 'Miyamoto' } },\n      internal: { createdAt: new Date('1603-06-01'), status: 'approved' },\n      test: 'test'\n    });\n\n    assert.deepEqual(Object.keys(doc.toObject()), ['test', 'internal', 'profile', '_id']);\n    assert.deepEqual(Object.keys(doc.toObject().profile.name), ['first', 'last']);\n    assert.deepEqual(Object.keys(doc.toObject().internal), ['status', 'createdAt']);\n\n    await doc.save();\n    const res = await Test.findOne({ _id: doc._id, 'profile.name': { first: 'Miyamoto', last: 'Musashi' } });\n    assert.ok(res);\n  });\n\n  it('depopulate all should depopulate nested array population (gh-10592)', async function() {\n    const Person = db.model('Person', {\n      name: String\n    });\n\n    const Band = db.model('Band', {\n      name: String,\n      members: [{ type: Schema.Types.ObjectId, ref: 'Person' }],\n      lead: { type: Schema.Types.ObjectId, ref: 'Person' },\n      embeddedMembers: [{\n        active: Boolean,\n        member: {\n          type: Schema.Types.ObjectId, ref: 'Person'\n        }\n      }]\n    });\n\n    const people = [{ name: 'Axl Rose' }, { name: 'Slash' }];\n\n    const docs = await Person.create(people);\n    let band = {\n      name: 'Guns N\\' Roses',\n      members: [docs[0]._id, docs[1]],\n      lead: docs[0]._id,\n      embeddedMembers: [{ active: true, member: docs[0]._id }, { active: false, member: docs[1]._id }]\n    };\n\n    band = await Band.create(band);\n    await band.populate('members lead embeddedMembers.member');\n    assert.ok(band.populated('members'));\n    assert.ok(band.populated('lead'));\n    assert.ok(band.populated('embeddedMembers.member'));\n    assert.equal(band.members[0].name, 'Axl Rose');\n    assert.equal(band.embeddedMembers[0].member.name, 'Axl Rose');\n    band.depopulate();\n\n    assert.ok(!band.populated('members'));\n    assert.ok(!band.populated('lead'));\n    assert.ok(!band.populated('embeddedMembers.member'));\n    assert.ok(!band.embeddedMembers[0].member.name);\n  });\n\n  it('should allow dashes in the path name (gh-10677)', async function() {\n    const schema = new mongoose.Schema({\n      values: {\n        type: Map,\n        of: { entries: String },\n        default: {}\n      }\n    });\n\n    const Model = db.model('test', schema, 'test');\n\n    const saved = new Model({});\n    await saved.save();\n    const document = await Model.findById({ _id: saved._id });\n    document.values.set('abc', { entries: 'a' });\n    document.values.set('abc-d', { entries: 'b' });\n    await document.save();\n  });\n\n  it('inits non-schema values if strict is false (gh-10828)', function() {\n    const FooSchema = new Schema({}, {\n      id: false,\n      _id: false,\n      strict: false\n    });\n    const BarSchema = new Schema({\n      name: String,\n      foo: FooSchema\n    });\n\n    const Test = db.model('Test', BarSchema);\n\n    const doc = new Test();\n    doc.init({\n      name: 'Test',\n      foo: {\n        something: 'A',\n        other: 2\n      }\n    });\n\n    assert.strictEqual(doc.foo.something, 'A');\n    assert.strictEqual(doc.foo.other, 2);\n  });\n\n  it('avoids depopulating when setting array of subdocs from different doc (gh-10819)', function() {\n    const Model1 = db.model('Test', Schema({ someField: String }));\n    const Model2 = db.model('Test2', Schema({\n      subDocuments: [{\n        subDocument: {\n          type: 'ObjectId',\n          ref: 'Test'\n        }\n      }]\n    }));\n\n    const doc1 = new Model1({ someField: '111' });\n    const doc2 = new Model2({\n      subDocuments: {\n        subDocument: doc1\n      }\n    });\n\n    const doc3 = new Model2(doc2);\n    assert.ok(doc3.populated('subDocuments.subDocument'));\n    assert.equal(doc3.subDocuments[0].subDocument.someField, '111');\n\n    const doc4 = new Model2();\n    doc4.subDocuments = doc2.subDocuments;\n    assert.ok(doc4.populated('subDocuments.subDocument'));\n    assert.equal(doc4.subDocuments[0].subDocument.someField, '111');\n  });\n\n  it('allows validating doc again if pre validate errors out (gh-10830)', async function() {\n    const BookSchema = Schema({\n      name: String,\n      price: Number,\n      quantity: Number\n    });\n\n    BookSchema.pre('validate', disallownumflows);\n\n    const Book = db.model('Test', BookSchema);\n\n    function disallownumflows(next) {\n      const self = this;\n      if (self.isNew) return next();\n\n      if (self.quantity === 27) {\n        return next(new Error('Wrong Quantity'));\n      }\n\n      next();\n    }\n\n    const { _id } = await Book.create({ name: 'Hello', price: 50, quantity: 25 });\n\n    const doc = await Book.findById(_id);\n\n    doc.quantity = 27;\n    const err = await doc.save().then(() => null, err => err);\n    assert.ok(err);\n\n    doc.quantity = 26;\n    await doc.save();\n  });\n\n  it('ensures that doc.ownerDocument() and doc.parent() by default return this on the root document (gh-10884)', async function() {\n    const userSchema = new mongoose.Schema({\n      name: String,\n      email: String\n    });\n\n    const Event = db.model('Rainbow', userSchema);\n\n    const e = new Event({ name: 'test' });\n    assert.strictEqual(e, e.parent());\n    assert.strictEqual(e, e.ownerDocument());\n  });\n\n  it('catches errors in `required` functions (gh-10968)', async function() {\n    const TestSchema = new Schema({\n      url: {\n        type: String,\n        required: function() {\n          throw new Error('oops!');\n        }\n      }\n    });\n    const Test = db.model('Test', TestSchema);\n\n    const err = await Test.create({}).then(() => null, err => err);\n    assert.ok(err);\n    assert.equal(err.errors['url'].message, 'oops!');\n  });\n\n  it('does not allow overwriting schema methods with strict: false (gh-11001)', async function() {\n    const TestSchema = new Schema({\n      text: { type: String, default: 'text' }\n    }, { strict: false });\n    TestSchema.methods.someFn = () => 'good';\n    const Test = db.model('Test', TestSchema);\n\n    const unTrusted = { someFn: () => 'bad' };\n\n    let x = await Test.create(unTrusted);\n    await x.save();\n    assert.equal(x.someFn(), 'good');\n\n    x = new Test(unTrusted);\n    await x.save();\n    assert.equal(x.someFn(), 'good');\n\n    x = await Test.create({});\n    await x.set(unTrusted);\n    assert.equal(x.someFn(), 'good');\n  });\n\n  it('allows setting nested to instance of document (gh-11011)', async function() {\n    const TransactionSchema = new Schema({\n      payments: [\n        {\n          id: { type: String },\n          terminal: {\n            _id: { type: Schema.Types.ObjectId },\n            name: { type: String }\n          }\n        }\n      ]\n    });\n\n    const TerminalSchema = new Schema({\n      name: { type: String },\n      apiKey: { type: String }\n    });\n\n    const Transaction = db.model('Test1', TransactionSchema);\n    const Terminal = db.model('Test2', TerminalSchema);\n\n    const transaction = new Transaction();\n    const terminal = new Terminal({\n      name: 'Front desk',\n      apiKey: 'somesecret'\n    });\n    transaction.payments.push({\n      id: 'testPayment',\n      terminal: terminal\n    });\n    assert.equal(transaction.payments[0].terminal.name, 'Front desk');\n  });\n\n  it('cleans modified paths on deeply nested subdocuments (gh-11060)', async function() {\n    const childSchema = new Schema({ status: String });\n\n    const deploymentsSchema = new Schema({\n      before: { type: childSchema, required: false },\n      after: { type: childSchema, required: false }\n    }, { _id: false });\n\n    const testSchema = new Schema({\n      name: String,\n      deployments: { type: deploymentsSchema }\n    });\n    const Test = db.model('Test', testSchema);\n\n    await Test.create({\n      name: 'hello',\n      deployments: {\n        before: { status: 'foo' }\n      }\n    });\n\n    const entry = await Test.findOne({ name: 'hello' });\n    const deployment = entry.deployments.before;\n    deployment.status = 'bar';\n    entry.deployments.before = null;\n    entry.deployments.after = deployment;\n\n    assert.ok(!entry.isDirectModified('deployments.before.status'));\n    await entry.save();\n  });\n\n  it('can manually populate subdocument refs (gh-10856)', async function() {\n    // Bar model, has a name property and some other properties that we are interested in\n    const BarSchema = new Schema({\n      name: String,\n      more: String,\n      another: Number\n    });\n    const Bar = db.model('Bar', BarSchema);\n\n    // Denormalised Bar schema with just the name, for use on the Foo model\n    const BarNameSchema = new Schema({\n      _id: {\n        type: Schema.Types.ObjectId,\n        ref: 'Bar'\n      },\n      name: String\n    });\n\n    // Foo model, which contains denormalized bar data (just the name)\n    const FooSchema = new Schema({\n      something: String,\n      other: Number,\n      bar: {\n        type: BarNameSchema,\n        ref: 'Bar'\n      }\n    });\n    const Foo = db.model('Foo', FooSchema);\n\n    const bar2 = await Bar.create({\n      name: 'I am another Bar',\n      more: 'With even more data',\n      another: 3\n    });\n    const foo2 = await Foo.create({\n      something: 'I am another Foo',\n      other: 4\n    });\n\n    foo2.bar = bar2;\n    assert.ok(foo2.bar instanceof Bar);\n    assert.equal(foo2.bar.another, 3);\n    assert.equal(foo2.get('bar.another'), 3);\n\n    const obj = foo2.toObject({ depopulate: true });\n    assert.equal(obj.bar.name, 'I am another Bar');\n    assert.strictEqual(obj.bar.another, undefined);\n\n    await foo2.save();\n    const fromDb = await Foo.findById(foo2).lean();\n    assert.strictEqual(fromDb.bar.name, 'I am another Bar');\n    assert.strictEqual(fromDb.bar.another, undefined);\n  });\n\n  it('can manually populate subdocument refs in `create()` (gh-10856)', async function() {\n    // Bar model, has a name property and some other properties that we are interested in\n    const BarSchema = new Schema({\n      name: String,\n      more: String,\n      another: Number\n    });\n    const Bar = db.model('Bar', BarSchema);\n\n    // Denormalised Bar schema with just the name, for use on the Foo model\n    const BarNameSchema = new Schema({\n      _id: {\n        type: Schema.Types.ObjectId,\n        ref: 'Bar'\n      },\n      name: String\n    });\n\n    // Foo model, which contains denormalized bar data (just the name)\n    const FooSchema = new Schema({\n      something: String,\n      other: Number,\n      bar: {\n        type: BarNameSchema,\n        ref: 'Bar'\n      }\n    });\n    const Foo = db.model('Foo', FooSchema);\n\n    const bar = await Bar.create({\n      name: 'I am Bar',\n      more: 'With more data',\n      another: 2\n    });\n    const foo = await Foo.create({\n      something: 'I am Foo',\n      other: 1,\n      bar\n    });\n\n    assert.ok(foo.bar instanceof Bar);\n    assert.equal(foo.bar.another, 2);\n    assert.equal(foo.get('bar.another'), 2);\n  });\n\n  it('populating subdocument refs underneath maps throws (gh-12494) (gh-10856)', async function() {\n    // Bar model, has a name property and some other properties that we are interested in\n    const BarSchema = new Schema({\n      name: String,\n      more: String,\n      another: Number\n    });\n    const Bar = db.model('Bar', BarSchema);\n\n    // Denormalised Bar schema with just the name, for use on the Foo model\n    const BarNameSchema = new Schema({\n      _id: {\n        type: Schema.Types.ObjectId,\n        ref: 'Bar'\n      },\n      name: String\n    });\n\n    // Foo model, which contains denormalized bar data (just the name)\n    const FooSchema = new Schema({\n      something: String,\n      other: Number,\n      map: {\n        type: Map,\n        of: {\n          type: BarNameSchema,\n          ref: 'Bar'\n        }\n      }\n    });\n    const Foo = db.model('Foo', FooSchema);\n\n    const bar = await Bar.create({\n      name: 'I am Bar',\n      more: 'With more data',\n      another: 2\n    });\n    const { _id } = await Foo.create({\n      something: 'I am Foo',\n      other: 1,\n      map: { test: bar }\n    });\n\n    const err = await Foo.findById(_id).populate('map').then(() => null, err => err);\n    assert.ok(err);\n    assert.ok(err.message.includes('Cannot manually populate single nested subdoc underneath Map'), err.message);\n  });\n\n  it('handles save with undefined nested doc under subdoc (gh-11110)', async function() {\n    const testSchema = new Schema({\n      level_1_array: [new Schema({\n        level_1: {\n          level_2: new Schema({\n            level_3: {\n              name_3: String,\n              level_4: {\n                name_4: String\n              }\n            }\n          })\n        }\n      })]\n    });\n\n    const Test = db.model('Test', testSchema);\n\n    const doc = {\n      level_1_array: [{\n        level_1: {\n          level_2: {\n            level_3: {\n              name_3: 'test',\n              level_4: undefined\n            }\n          }\n        }\n      }]\n    };\n\n    await new Test(doc).save();\n  });\n\n  it('correctly handles modifying array subdoc after setting array subdoc to same value (gh-11172)', async function() {\n    const Order = db.model('Order', new Schema({\n      cumulativeConsumption: [{\n        _id: false,\n        unit: String,\n        value: Number\n      }]\n    }));\n\n    await Order.create({\n      cumulativeConsumption: [{ unit: 'foo', value: 123 }, { unit: 'bar', value: 42 }]\n    });\n\n    const doc = await Order.findOne();\n    doc.cumulativeConsumption = doc.toObject().cumulativeConsumption;\n\n    const match = doc.cumulativeConsumption.find(o => o.unit === 'bar');\n    match.value = 43;\n    match.unit = 'baz';\n\n    assert.ok(doc.isModified());\n    assert.ok(doc.isModified('cumulativeConsumption.1'));\n  });\n\n  it('handles `String` with `type` (gh-11199)', function() {\n    String.type = String;\n    const schema = new mongoose.Schema({\n      something: String,\n      somethingElse: { type: String, trim: true }\n    });\n\n    const Test = db.model('Test', schema);\n    const doc = new Test({ something: 'test', somethingElse: 'test 2' });\n    assert.equal(typeof doc.something, 'string');\n    assert.equal(typeof doc.somethingElse, 'string');\n    delete String.type;\n  });\n\n  it('applies subdocument defaults when projecting dotted subdocument fields', async function() {\n    const version = await start.mongodVersion();\n    if (version[0] < 5) {\n      return this.skip();\n    }\n\n    const grandChildSchema = new mongoose.Schema({\n      name: {\n        type: mongoose.Schema.Types.String,\n        default: () => 'grandchild'\n      }\n    });\n\n    const childSchema = new mongoose.Schema({\n      name: {\n        type: mongoose.Schema.Types.String,\n        default: () => 'child'\n      },\n      grandChild: {\n        type: grandChildSchema,\n        default: () => ({})\n      }\n    });\n\n    const parentSchema = new mongoose.Schema({\n      name: mongoose.Schema.Types.String,\n      child: {\n        type: childSchema,\n        default: () => ({})\n      }\n    });\n\n    const ParentModel = db.model('Parent', parentSchema);\n    // insert an object without mongoose adding missing defaults\n    const result = await db.collection('Parent').insertOne({ name: 'parent' });\n\n    // ensure that the defaults are populated when no projections are used\n    const doc = await ParentModel.findById(result.insertedId).exec();\n    assert.equal(doc.name, 'parent');\n    assert.equal(doc.child.name, 'child');\n    assert.equal(doc.child.grandChild.name, 'grandchild');\n\n    // ensure that defaults are populated when using an object projection\n    const projectedDoc = await ParentModel.findById(result.insertedId, {\n      name: 1,\n      child: {\n        name: 1,\n        grandChild: {\n          name: 1\n        }\n      }\n    }).exec();\n    assert.equal(projectedDoc.name, 'parent');\n    assert.equal(projectedDoc.child.name, 'child');\n    assert.equal(projectedDoc.child.grandChild.name, 'grandchild');\n\n    // ensure that defaults are populated when using dotted path projections\n    const dottedProjectedDoc = await ParentModel.findById(result.insertedId, {\n      name: 1,\n      'child.name': 1,\n      'child.grandChild.name': 1\n    }).exec();\n    assert.equal(dottedProjectedDoc.name, 'parent');\n    assert.equal(dottedProjectedDoc.child.name, 'child');\n    assert.equal(dottedProjectedDoc.child.grandChild.name, 'grandchild');\n  });\n\n  it('handles initing nested properties in non-strict documents (gh-11309)', async function() {\n    const NestedSchema = new Schema({}, {\n      id: false,\n      _id: false,\n      strict: false\n    });\n\n    const ItemSchema = new Schema({\n      name: {\n        type: String\n      },\n      nested: NestedSchema\n    });\n\n    const Test = db.model('Test', ItemSchema);\n\n    const item = await Test.create({\n      nested: {\n        foo: {\n          bar: 55\n        }\n      }\n    });\n\n    // Modify nested data\n    item.nested.foo.bar = 66;\n    item.markModified('nested.foo.bar');\n    await item.save();\n\n    const reloaded = await Test.findOne({ _id: item._id });\n\n    assert.deepEqual(reloaded.nested.foo, { bar: 66 });\n    assert.ok(!reloaded.nested.foo.$__isNested);\n    assert.strictEqual(reloaded.nested.foo.bar, 66);\n  });\n\n  it('saves changes when setting a nested path to itself (gh-11395)', async function() {\n    const Test = db.model('Test', new Schema({\n      co: { value: Number }\n    }));\n\n    await Test.create({});\n\n    const doc = await Test.findOne();\n    doc.co.value = 123;\n    doc.co = doc.co;\n    await doc.save();\n\n    const res = await Test.findById(doc._id);\n    assert.strictEqual(res.co.value, 123);\n  });\n\n  it('avoids setting nested properties on top-level document when init-ing with strict: false (gh-11526) (gh-11309)', async function() {\n    const testSchema = Schema({ name: String }, { strict: false, strictQuery: false });\n    const Test = db.model('Test', testSchema);\n\n    const doc = new Test();\n    doc.init({\n      details: {\n        person: {\n          name: 'Baz'\n        }\n      }\n    });\n\n    assert.strictEqual(doc.name, void 0);\n  });\n\n  it('handles deeply nested subdocuments when getting paths to validate (gh-11501)', async function() {\n    const schema = Schema({\n      parameters: {\n        test: {\n          type: new Schema({\n            value: 'Mixed'\n          })\n        }\n      },\n      nested: Schema({\n        parameters: {\n          type: Map,\n          of: Schema({\n            value: 'Mixed'\n          })\n        }\n      })\n    });\n    const Test = db.model('Test', schema);\n\n    await Test.create({\n      nested: {\n        parameters: new Map([['test', { answer: 42 }]])\n      }\n    });\n  });\n\n  it('handles casting array of spread documents (gh-11522)', async function() {\n    const Test = db.model('Test', new Schema({\n      arr: [{ _id: false, prop1: String, prop2: String }]\n    }));\n\n    const doc = new Test({ arr: [{ prop1: 'test' }] });\n\n    doc.arr = doc.arr.map(member => ({\n      ...member,\n      prop2: 'foo'\n    }));\n\n    assert.deepStrictEqual(doc.toObject().arr, [{ prop1: 'test', prop2: 'foo' }]);\n\n    await doc.validate();\n  });\n\n  it('avoids setting modified on subdocument defaults (gh-11528)', async function() {\n    const textSchema = new Schema({\n      text: { type: String }\n    }, { _id: false });\n\n    const messageSchema = new Schema({\n      body: { type: textSchema, default: { text: 'hello' } },\n      date: { type: Date, default: Date.now }\n    });\n\n\n    const Message = db.model('Test', messageSchema);\n\n    const entry = await Message.create({});\n\n    const failure = await Message.findById({ _id: entry._id });\n\n    assert.deepEqual(failure.modifiedPaths(), []);\n  });\n\n  it('works when passing dot notation to mixed property (gh-1946)', async function() {\n    const schema = Schema({\n      name: String,\n      mix: { type: Schema.Types.Mixed },\n      nested: { prop: String }\n    });\n    const M = db.model('Test', schema);\n    const m1 = new M({ name: 'test', 'mix.val': 'foo', 'nested.prop': 'bar' });\n    assert.equal(m1.name, 'test');\n    assert.equal(m1.mix.val, 'foo');\n    assert.equal(m1.nested.prop, 'bar');\n    await m1.save();\n    assert.equal(m1.name, 'test');\n    assert.equal(m1.mix.val, 'foo');\n\n    const doc = await M.findById(m1);\n    assert.equal(doc.name, 'test');\n    assert.equal(doc.mix.val, 'foo');\n  });\n\n  it('correctly validates deeply nested document arrays (gh-11564)', async function() {\n    const testSchemaSub3 = new mongoose.Schema({\n      name: {\n        type: String,\n        required: true\n      }\n    });\n\n    const testSchemaSub2 = new mongoose.Schema({\n      name: {\n        type: String,\n        required: true\n      },\n      list: [testSchemaSub3]\n    });\n\n    const testSchemaSub1 = new mongoose.Schema({\n      name: {\n        type: String,\n        required: true\n      },\n      list: [testSchemaSub2]\n    });\n\n    const testSchema = new mongoose.Schema({\n      name: String,\n      list: [testSchemaSub1]\n    });\n\n    const testModel = db.model('Test', testSchema);\n\n    await testModel.create({\n      name: 'lvl1',\n      list: [{\n        name: 'lvl2',\n        list: [{\n          name: 'lvl3'\n        }]\n      }]\n    });\n  });\n\n  it('reruns validation when modifying a document array path under a nested path after save (gh-11672)', async function() {\n    const ChildSchema = new Schema({\n      price: {\n        type: Number,\n        validate: function(val) {\n          return val > 0;\n        }\n      }\n    });\n\n    const ParentSchema = new Schema({\n      rootField: { nestedSubdocArray: [ChildSchema] }\n    });\n    const Test = db.model('Test', ParentSchema);\n\n    const parentDoc = new Test({\n      rootField: {\n        nestedSubdocArray: [\n          {\n            price: 1\n          }\n        ]\n      }\n    });\n\n    await parentDoc.save();\n\n    // Now we try editing to an invalid value which should throw\n    parentDoc.rootField.nestedSubdocArray[0].price = -1;\n    const err = await parentDoc.save().then(() => null, err => err);\n\n    assert.ok(err);\n    assert.equal(err.name, 'ValidationError');\n    assert.ok(err.message.includes('failed for path'), err.message);\n    assert.ok(err.message.includes('value `-1`'), err.message);\n  });\n\n  it('avoids setting nested paths to null when they are set to `undefined` (gh-11723)', async function() {\n    const nestedSchema = new mongoose.Schema({\n      count: Number\n    }, { _id: false });\n\n    const mySchema = new mongoose.Schema({\n      name: String,\n      nested: { count: Number },\n      nestedSchema: nestedSchema\n    }, { minimize: false });\n\n    const Test = db.model('Test', mySchema);\n\n    const instance1 = new Test({ name: 'test1', nested: { count: 1 }, nestedSchema: { count: 1 } });\n    await instance1.save();\n\n    const update = { nested: { count: undefined }, nestedSchema: { count: undefined } };\n    instance1.set(update);\n    await instance1.save();\n\n    const doc = await Test.findById(instance1);\n    assert.strictEqual(doc.nested.count, undefined);\n    assert.strictEqual(doc.nestedSchema.count, undefined);\n  });\n\n  it('cleans modified subpaths when setting nested path under array to null when subpaths are modified (gh-11764)', async function() {\n    const Test = db.model('Test', new Schema({\n      list: [{\n        quantity: {\n          value: Number,\n          unit: String\n        }\n      }]\n    }));\n\n    let doc = await Test.create({ list: [{ quantity: { value: 1, unit: 'case' } }] });\n\n    doc = await Test.findById(doc);\n    doc.list[0].quantity.value = null;\n    doc.list[0].quantity.unit = null;\n    doc.list[0].quantity = null;\n\n    await doc.save();\n\n    doc = await Test.findById(doc);\n    assert.strictEqual(doc.list[0].toObject().quantity, null);\n  });\n\n  it('avoids manually populating document that is manually populated in another doc with different unpopulatedValue (gh-11442) (gh-11008)', async function() {\n    const BarSchema = new Schema({\n      name: String,\n      more: String\n    });\n    const Bar = db.model('Bar', BarSchema);\n\n    // Denormalised Bar schema with just the name, for use on the Foo model\n    const BarNameSchema = new Schema({\n      _id: {\n        type: Schema.Types.ObjectId,\n        ref: 'Bar'\n      },\n      name: String\n    });\n\n    // Foo model, which contains denormalized bar data (just the name)\n    const FooSchema = new Schema({\n      something: String,\n      other: Number,\n      bar: {\n        type: BarNameSchema,\n        ref: 'Bar'\n      }\n    });\n    const Foo = db.model('Foo', FooSchema);\n\n    const Baz = db.model('Baz', new Schema({ bar: { type: 'ObjectId', ref: 'Bar' } }));\n\n    const bar = await Bar.create({\n      name: 'I am another Bar',\n      more: 'With even more data'\n    });\n    const foo = await Foo.create({\n      something: 'I am another Foo',\n      other: 4\n    });\n    foo.bar = bar;\n    const baz = await Baz.create({});\n    baz.bar = bar;\n\n    assert.ok(foo.populated('bar'));\n    assert.ok(!baz.populated('bar'));\n\n    let res = foo.toObject({ depopulate: true });\n    assert.strictEqual(res.bar._id.toString(), bar._id.toString());\n    assert.strictEqual(res.bar.name, 'I am another Bar');\n\n    res = baz.toObject({ depopulate: true });\n    assert.strictEqual(res.bar.toString(), bar._id.toString());\n\n    const bar2 = await Bar.create({\n      name: 'test2'\n    });\n    baz.bar = bar2;\n    assert.ok(baz.populated('bar'));\n\n    const baz2 = await Baz.create({});\n    baz2.bar = bar2;\n    assert.ok(baz.populated('bar'));\n  });\n\n  it('$getAllSubdocs gets document arrays underneath a nested path (gh-11917)', function() {\n    const nestedSettingsSchema = new Schema({\n      value: String,\n      active: Boolean\n    });\n\n    const userSettingsSchema = new Schema({\n      nestedSettings: {\n        settingsProps: [nestedSettingsSchema]\n      }\n    });\n\n    const userSchema = new Schema({\n      first_name: String,\n      last_name: String,\n      settings: userSettingsSchema\n    });\n\n    const User = db.model('User', userSchema);\n\n    const doc = new User({\n      settings: {\n        nestedSettings: {\n          settingsProps: [{ value: 'test', active: true }]\n        }\n      }\n    });\n\n    const subdocs = doc.$getAllSubdocs();\n    assert.equal(subdocs.length, 2);\n    assert.equal(subdocs[0].value, 'test');\n    assert.ok(subdocs[1].nestedSettings);\n  });\n\n  it('handles validation errors on deeply nested subdocuments underneath a nested path (gh-12021)', async function() {\n    const SubSubSchema = new mongoose.Schema(\n      {\n        from: {\n          type: mongoose.Schema.Types.String,\n          required: true\n        }\n      },\n      { _id: false }\n    );\n\n    const SubSchema = new mongoose.Schema(\n      {\n        nested: {\n          type: SubSubSchema,\n          required: false // <-- important\n        }\n      },\n      { _id: false }\n    );\n\n    const TestLeafSchema = new mongoose.Schema({\n      testProp: {\n        testSubProp: {\n          type: SubSchema,\n          required: true\n        }\n      }\n    });\n\n    const TestLeafModel = mongoose.model('test-leaf-model', TestLeafSchema);\n\n    const testModelInstance = new TestLeafModel({\n      testProp: {\n        testSubProp: {\n          nested: { from: null }\n        }\n      }\n    });\n\n    const err = await testModelInstance.validate().then(() => null, err => err);\n    assert.ok(err);\n    assert.ok(err.errors['testProp.testSubProp.nested.from']);\n  });\n\n  describe('$inc (gh-11915)', function() {\n    describe('top-level path', function() {\n      let Test;\n\n      beforeEach(function() {\n        const schema = new Schema({\n          counter: Number\n        });\n        Test = db.model('Test', schema);\n      });\n\n      it('sends a $inc command for a given path', async function() {\n        await Test.create({ counter: 0 });\n        const doc = await Test.findOne();\n        assert.strictEqual(doc.counter, 0);\n        const doc2 = await Test.findOne();\n\n        doc2.counter = 1;\n        await doc2.save();\n\n        doc.$inc('counter', 1);\n        await doc.save();\n\n        const res = await Test.findById(doc);\n        assert.equal(res.counter, 2);\n      });\n\n      it('calls setters on the value passed to `$inc()` (gh-13158)', async function() {\n        const called = [];\n        const Test2 = db.model('Test2', Schema({\n          counter: {\n            type: Number,\n            set: v => { called.push(v); return v.toFixed(2); }\n          }\n        }));\n        const doc = await Test2.create({ counter: 2 });\n        assert.deepEqual(called, [2]);\n\n        doc.$inc('counter', 1.14159);\n        assert.deepEqual(called, [2, 3.14159]);\n        assert.equal(doc.counter, 3.14);\n        await doc.save();\n\n        const res = await Test2.findById(doc);\n        assert.equal(res.counter, 3.14);\n      });\n\n      it('avoids updating value if setter fails (gh-13158)', async function() {\n        const called = [];\n        const Test2 = db.model('Test2', Schema({\n          counter: {\n            type: Number,\n            set: v => {\n              called.push(v);\n              if (v > 3) {\n                throw new Error('Oops!');\n              }\n              return v;\n            }\n          }\n        }));\n        const doc = await Test2.create({ counter: 2 });\n        assert.deepEqual(called, [2]);\n\n        doc.$inc('counter', 3);\n        assert.deepEqual(called, [2, 5]);\n        assert.equal(doc.counter, 2);\n        const err = await doc.save().then(() => null, err => err);\n        assert.ok(err);\n        assert.ok(err.errors['counter']);\n      });\n\n      it('works as a $set if the document is new', async function() {\n        const doc = new Test({ counter: 0 });\n        doc.$inc('counter', 2);\n        assert.equal(doc.counter, 2);\n\n        await doc.save();\n\n        const res = await Test.findById(doc);\n        assert.equal(res.counter, 2);\n      });\n\n      it('treats as a $set if set after $inc', async function() {\n        await Test.create({ counter: 0 });\n        const doc = await Test.findOne();\n\n        doc.$inc('counter', 2);\n        doc.counter = 5;\n        assert.deepStrictEqual(doc.getChanges(), { $set: { counter: 5 } });\n        await doc.save();\n\n        const res = await Test.findOne();\n        assert.equal(res.counter, 5);\n      });\n\n      it('tries to cast to number', async function() {\n        await Test.create({ counter: 0 });\n        const doc = await Test.findOne();\n\n        doc.$inc('counter', '2');\n        assert.deepStrictEqual(doc.getChanges(), { $inc: { counter: 2 } });\n        await doc.save();\n\n        const res = await Test.findOne();\n        assert.equal(res.counter, 2);\n      });\n\n      it('stores CastError if can\\'t convert to number', async function() {\n        await Test.create({ counter: 0 });\n        const doc = await Test.findOne();\n\n        doc.$inc('counter', 'foobar');\n        const err = await doc.save().then(() => null, err => err);\n        assert.ok(err);\n        assert.equal(err.errors['counter'].name, 'CastError');\n      });\n    });\n\n    describe('nested paths', function() {\n      let Test;\n\n      beforeEach(function() {\n        const schema = new Schema({\n          nested: {\n            counter: Number\n          }\n        });\n        Test = db.model('Test', schema);\n      });\n\n      it('handles nested paths', async function() {\n        await Test.create({ nested: { counter: 0 } });\n        const doc = await Test.findOne();\n\n        doc.$inc('nested.counter', 2);\n        await doc.save();\n\n        const res = await Test.findById(doc);\n        assert.equal(res.nested.counter, 2);\n      });\n\n      it('treats as $set if overwriting nested path', async function() {\n        await Test.create({ nested: { counter: 0 } });\n        const doc = await Test.findOne();\n\n        doc.$inc('nested.counter', 2);\n        doc.nested.counter += 3;\n        await doc.save();\n\n        const res = await Test.findById(doc);\n        assert.equal(res.nested.counter, 5);\n      });\n    });\n\n    describe('subdocuments', function() {\n      let Test;\n\n      beforeEach(function() {\n        const schema = new Schema({\n          subdoc: new Schema({\n            counter: Number\n          })\n        });\n        Test = db.model('Test', schema);\n      });\n\n      it('handles paths underneath subdocuments', async function() {\n        await Test.create({ subdoc: { counter: 0 } });\n        const doc = await Test.findOne();\n\n        doc.$inc('subdoc.counter', 2);\n        await doc.save();\n\n        const res = await Test.findById(doc);\n        assert.equal(res.subdoc.counter, 2);\n      });\n\n      it('treats as a $set if setting subdocument after $inc', async function() {\n        await Test.create({ subdoc: { counter: 0 } });\n        const doc = await Test.findOne();\n\n        doc.$inc('subdoc.counter', 2);\n        doc.subdoc = { counter: 5 };\n        await doc.save();\n\n        const res = await Test.findById(doc);\n        assert.equal(res.subdoc.counter, 5);\n      });\n    });\n\n    describe('document array', function() {\n      let Test;\n\n      beforeEach(function() {\n        const schema = new Schema({\n          docArr: [{ counter: Number }]\n        });\n        Test = db.model('Test', schema);\n      });\n\n      it('handles paths underneath subdocuments', async function() {\n        await Test.create({ docArr: [{ counter: 0 }] });\n        const doc = await Test.findOne();\n\n        doc.docArr[0].$inc('counter');\n        await doc.save();\n\n        const res = await Test.findById(doc);\n        assert.equal(res.docArr[0].counter, 1);\n      });\n\n      it('works on pushed subdocs', async function() {\n        await Test.create({ docArr: [] });\n        const doc = await Test.findOne();\n\n        doc.docArr.push({ counter: 0 });\n        doc.docArr[0].$inc('counter');\n        await doc.save();\n\n        const res = await Test.findById(doc);\n        assert.equal(res.docArr[0].counter, 1);\n      });\n      it('Splice call registers path modification', async function() {\n        await Test.create({ docArr: [{ counter: 0 }, { counter: 2 }, { counter: 3 }, { counter: 4 }] });\n        const doc = await Test.findOne();\n        doc.docArr.splice(1, 0, { counter: 1 });\n        assert.equal(doc.isModified('docArr'), true);\n      });\n    });\n\n    it('stores CastError if trying to $inc a non-numeric path', async function() {\n      const schema = new Schema({\n        prop: String\n      });\n      const Test = db.model('Test', schema);\n\n      await Test.create({ prop: '' });\n      const doc = await Test.findOne();\n\n      doc.$inc('prop', 2);\n      const err = await doc.save().then(() => null, err => err);\n      assert.ok(err);\n      assert.equal(err.errors['prop'].name, 'CastError');\n    });\n    it('should correctly increment even if the document has not saved after each increment gh-13274', async function() {\n      const schema = new Schema({\n        coins: Number\n      });\n      const Test = db.model('gh13274', schema);\n      await Test.create({ coins: 0 });\n      const doc = await Test.findOne();\n      doc.$inc('coins', 1000);\n      doc.$inc('coins', 2000);\n      await doc.save();\n      const check = await Test.findOne();\n      assert.equal(check.coins, 3000);\n    });\n  });\n\n  it('supports virtuals named `isValid` (gh-12124) (gh-6262)', async function() {\n    const Schema = new mongoose.Schema({\n      test: String,\n      data: { sub: String }\n    });\n\n    Schema.virtual('isValid');\n\n    const Test = db.model('Test', Schema);\n    let doc = new Test();\n\n    assert.ok(doc.$isValid('test'));\n    await doc.save();\n\n    doc = await Test.findOne();\n\n    doc.set('isValid', true);\n    assert.ok(doc.$isValid('test'));\n\n    doc.set({ test: 'test' });\n    await doc.save();\n    assert.equal(doc.test, 'test');\n\n    doc.set({ data: { sub: 'sub' } });\n    await doc.save();\n    assert.equal(doc.data.sub, 'sub');\n  });\n\n  it('handles maps when applying defaults to nested paths (gh-12220)', async function() {\n    const nestedSchema = new mongoose.Schema({\n      1: {\n        type: Number,\n        default: 0\n      }\n    });\n\n    const topSchema = new mongoose.Schema({\n      nestedPath1: {\n        mapOfSchema: {\n          type: Map,\n          of: nestedSchema\n        }\n      }\n    });\n\n    const Test = db.model('Test', topSchema);\n\n    const data = {\n      nestedPath1: {\n        mapOfSchema: {}\n      }\n    };\n    const doc = await Test.create(data);\n\n    assert.ok(doc.nestedPath1.mapOfSchema);\n  });\n\n  it('correct context for default functions in subdocuments with init (gh-12328)', async function() {\n    let called = 0;\n\n    const subSchema = new mongoose.Schema({\n      propertyA: { type: String },\n      propertyB: {\n        type: String,\n        default: function() {\n          ++called;\n          return this.propertyA;\n        }\n      }\n    });\n\n    const testSchema = new mongoose.Schema(\n      {\n        name: String,\n        sub: { type: subSchema, default: () => ({}) }\n      }\n    );\n\n    const Test = db.model('Test', testSchema);\n\n    await Test.collection.insertOne({ name: 'test', sub: { propertyA: 'foo' } });\n    assert.strictEqual(called, 0);\n\n    const doc = await Test.findOne({ name: 'test' });\n    assert.strictEqual(doc.sub.propertyB, 'foo');\n    assert.strictEqual(called, 1);\n  });\n\n  it('applies defaults to pushed subdocs after initing document (gh-12515)', async function() {\n    const animalSchema = new Schema({ title: String });\n    const animalsSchema = new Schema({\n      species: [animalSchema],\n      totalAnimals: Number\n    });\n    const Userschema = new Schema({\n      animals: animalsSchema\n    });\n    const UserModel = db.model('User', Userschema);\n\n    const doc = new UserModel();\n    doc.animals = { totalAnimals: 1 };\n    doc.animals.species = [{ title: 'Lion' }];\n    await doc.save();\n    // once created we fetch it again\n    let user = await UserModel.findById(doc._id);\n\n    // add new animal\n    user.animals.species.push({ title: 'Elephant' });\n    await user.save();\n    assert.ok(user.animals.species[0]._id);\n    assert.ok(user.animals.species[1]._id);\n    user = await UserModel.collection.findOne({ _id: user._id });\n\n    assert.ok(user.animals.species[0]._id);\n    assert.ok(user.animals.species[1]._id);\n  });\n\n  it('If the field does not exist, $inc should create it and set is value to the specified one (gh-12435)', async function() {\n    const schema = new mongoose.Schema({\n      name: String,\n      count: Number\n    });\n    const Model = db.model('IncTest', schema);\n    const doc = new Model({ name: 'Test' });\n    await doc.save();\n    doc.$inc('count', 1);\n    await doc.save();\n\n    assert.strictEqual(doc.count, 1);\n\n    const addedDoc = await Model.findOne({ name: 'Test' });\n    assert.strictEqual(addedDoc.count, 1);\n  });\n\n  it('avoids overwriting array if saving with no changes with array deselected (gh-12414)', async function() {\n    const schema = new mongoose.Schema({\n      name: String,\n      tags: [String]\n    });\n    const Test = db.model('Test', schema);\n\n    const { _id } = await Test.create({ name: 'Mongoose', tags: ['mongodb'] });\n\n    const doc = await Test.findById(_id).select('name');\n    assert.deepStrictEqual(doc.getChanges(), {});\n    await doc.save();\n\n    const rawDoc = await Test.collection.findOne({ _id });\n    assert.ok(rawDoc);\n    assert.deepStrictEqual(rawDoc.tags, ['mongodb']);\n  });\n\n  it('$clone() (gh-11849)', async function() {\n    const schema = new mongoose.Schema({\n      name: {\n        type: String,\n        validate: {\n          validator: (v) => v !== 'Invalid'\n        }\n      }\n    });\n    const Test = db.model('Test', schema);\n\n    const item = await Test.create({ name: 'Test' });\n\n    const doc = await Test.findById(item._id);\n    const clonedDoc = doc.$clone();\n\n    assert.deepEqual(clonedDoc, doc);\n    assert.deepEqual(clonedDoc._doc, doc._doc);\n    assert.deepEqual(clonedDoc.$__, doc.$__);\n\n    // Editing a field in the cloned doc does not effect\n    // the original doc\n    clonedDoc.name = 'Test 2';\n    assert.equal(doc.name, 'Test');\n    assert.equal(clonedDoc.name, 'Test 2');\n    assert.ok(!doc.$isModified('name'));\n    assert.ok(clonedDoc.$isModified('name'));\n\n    // Saving the cloned doc does not effect `modifiedPaths`\n    // in the original doc\n    const modifiedPaths = [...doc.modifiedPaths()];\n    await clonedDoc.save();\n    assert.deepEqual(doc.modifiedPaths(), modifiedPaths);\n\n    // Cloning a doc with invalid field preserve the\n    // invalid field value\n    doc.name = 'Invalid';\n    await assert.rejects(async() => {\n      await doc.validate();\n    });\n\n    await clonedDoc.validate();\n\n    const invalidClonedDoc = doc.$clone();\n    doc.name = 'Test';\n    await doc.validate();\n    await assert.rejects(async() => {\n      await invalidClonedDoc.validate();\n    });\n\n    // Setting a session on the cloned doc does not\n    // affect the session in the original doc\n    const session = await Test.startSession();\n    clonedDoc.$session(session);\n    assert.strictEqual(doc.$session(), null);\n    assert.strictEqual(clonedDoc.$session(), session);\n  });\n\n  it('can create document with document array and top-level key named `schema` (gh-12480)', async function() {\n    const AuthorSchema = new Schema({\n      fullName: { type: 'String', required: true }\n    });\n\n    const BookSchema = new Schema({\n      schema: { type: 'String', required: true },\n      title: { type: 'String', required: true },\n      authors: [AuthorSchema]\n    }, { supressReservedKeysWarning: true });\n\n    const Book = db.model('Book', BookSchema);\n\n    await Book.create({\n      schema: 'design',\n      authors: [{ fullName: 'Sourabh Bagrecha' }],\n      title: 'The power of JavaScript'\n    });\n  });\n\n  it('handles setting array to itself after saving and pushing a new value (gh-12656)', async function() {\n    const Test = db.model('Test', new Schema({\n      list: [{\n        a: Number\n      }]\n    }));\n    await Test.create({ list: [{ a: 1, b: 11 }] });\n\n    let doc = await Test.findOne();\n    doc.list.push({ a: 2 });\n    doc.list = [...doc.list];\n    await doc.save();\n\n    doc.list.push({ a: 3 });\n    doc.list = [...doc.list];\n    await doc.save();\n\n    doc = await Test.findOne();\n    assert.equal(doc.list.length, 3);\n    assert.deepStrictEqual(doc.list.map(el => el.a), [1, 2, 3]);\n  });\n\n  it('should not trigger isModified when setting a nested boolean to the same value as previously  (gh-12992)', async function() {\n    const Test = db.model('Test', new Schema({\n      result: new Schema(\n        {\n          score: Number,\n          passed: Boolean\n        },\n        { _id: false }\n      )\n    }));\n    const newTest = await Test.create({\n      result: {\n        score: 40,\n        passed: false\n      }\n    });\n\n    const existingTest = await Test.findById(newTest._id);\n    existingTest.result = {\n      score: 40,\n      passed: false\n    };\n\n    assert.equal(existingTest.isModified(), false);\n    assert.equal(existingTest.modifiedPaths().length, 0);\n\n    existingTest.result = {\n      score: 40,\n      passed: true\n    };\n\n    assert.equal(existingTest.isModified(), true);\n    assert.equal(existingTest.modifiedPaths().length, 1);\n  });\n\n  it('saves single nested subdoc defaults (gh-12905)', async function() {\n    const nestedSchema = new mongoose.Schema({\n      refOriginal: String,\n      refAnother: {\n        type: String,\n        default: () => 'goodbye'\n      }\n    });\n    const testSchema = new mongoose.Schema({\n      original: String,\n      another: {\n        type: String,\n        default: 'hello'\n      },\n      referenced: {\n        type: nestedSchema,\n        default: () => ({})\n      }\n    });\n    const Test = db.model('Test', testSchema);\n\n    const _id = new mongoose.Types.ObjectId();\n    await Test.collection.insertOne({\n      _id,\n      original: 'foo',\n      referenced: { refOriginal: 'hello' }\n    });\n\n    const doc = await Test.findById(_id);\n    assert.equal(doc.referenced.refOriginal, 'hello');\n    assert.equal(doc.referenced.refAnother, 'goodbye');\n\n    await doc.save();\n    const rawDoc = await Test.findById(_id).lean();\n    assert.equal(rawDoc.referenced.refOriginal, 'hello');\n    assert.equal(rawDoc.referenced.refAnother, 'goodbye');\n  });\n\n  it('$shift() triggers $pop', function() {\n    const Test = db.model('Test', mongoose.Schema({\n      arr: [String]\n    }, { autoCreate: false, autoIndex: false }));\n\n    const doc = Test.hydrate({ arr: ['a', 'b', 'c'] });\n    doc.arr.$shift();\n\n    assert.deepStrictEqual(\n      doc.getChanges(),\n      { $pop: { arr: -1 }, $inc: { __v: 1 } }\n    );\n  });\n\n  it('avoids setting array default if document array projected out by sibling projection (gh-13003)', async function() {\n    const schema = new mongoose.Schema({\n      name: String,\n      arr: [String],\n      properties: {\n        foo: String,\n        bar: [{ baz: String, qux: Boolean }],\n        baz: String\n      }\n    });\n    const Test = db.model('Test', schema);\n\n    const doc = new Test({}, { 'properties.foo': 1 });\n    doc.init({ properties: { foo: 'foo' } });\n    assert.strictEqual(doc.properties.bar, undefined);\n  });\n\n  it('avoids overwriting array with sibling projection (gh-13043)', async function() {\n    const testSchema = new mongoose.Schema({\n      str: 'string',\n      obj: {\n        subObj: {\n          str: 'string'\n        },\n        subArr: [{\n          str: 'string'\n        }]\n      },\n      arr: [{\n        str: 'string'\n      }]\n    });\n    const Test = db.model('Test', testSchema);\n    // Create one test document : obj.subArr[0].str === 'subArr.test1'\n    await Test.create({\n      str: 'test1',\n      obj: {\n        subObj: {\n          str: 'subObj.test1'\n        },\n        subArr: [{\n          str: 'subArr.test1'\n        }]\n      },\n      arr: [{ str: 'arr.test1' }]\n    });\n\n    const test = await Test.findOne({ str: 'test1' }, 'str obj.subObj');\n\n    // Update one property\n    test.str = test.str + ' - updated';\n    await test.save();\n\n    const fromDb = await Test.findById(test);\n    assert.equal(fromDb.obj.subArr.length, 1);\n    assert.equal(fromDb.obj.subArr[0].str, 'subArr.test1');\n  });\n\n  it('avoids prototype pollution on init', async function() {\n    const Example = db.model('Example', new Schema({ hello: String }));\n\n    const example = await new Example({ hello: 'world!' }).save();\n    await Example.findByIdAndUpdate(example._id, {\n      $rename: {\n        hello: '__proto__.polluted'\n      }\n    });\n\n    // this is what causes the pollution\n    await Example.find();\n\n    const test = {};\n    assert.strictEqual(test.polluted, undefined);\n    assert.strictEqual(Object.prototype.polluted, undefined);\n  });\n});\n\ndescribe('Check if instance function that is supplied in schema option is availabe', function() {\n  it('should give an instance function back rather than undefined', function ModelJS() {\n    const testSchema = new mongoose.Schema({}, { methods: { instanceFn() { return 'Returned from DocumentInstanceFn'; } } });\n    const TestModel = mongoose.model('TestModel', testSchema);\n    const TestDocument = new TestModel({});\n    assert.equal(TestDocument.instanceFn(), 'Returned from DocumentInstanceFn');\n  });\n});\n"], "filenames": ["lib/document.js", "test/document.test.js"], "buggy_code_start_loc": [742, 12280], "buggy_code_end_loc": [742, 12280], "fixing_code_start_loc": [743, 12281], "fixing_code_end_loc": [747, 12299], "type": "CWE-1321", "message": "Prototype Pollution in GitHub repository automattic/mongoose prior to 7.3.4.", "other": {"cve": {"id": "CVE-2023-3696", "sourceIdentifier": "security@huntr.dev", "published": "2023-07-17T01:15:08.850", "lastModified": "2023-08-02T17:30:54.240", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Prototype Pollution in GitHub repository automattic/mongoose prior to 7.3.4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.8}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mongoosejs:mongoose:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "5.13.20", "matchCriteriaId": "77E325B5-25B7-4AE9-837F-8CF8D45BF4F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mongoosejs:mongoose:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "6.0.0", "versionEndExcluding": "6.11.3", "matchCriteriaId": "C468CA5A-C50C-4040-A90E-C1100885F619"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mongoosejs:mongoose:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "7.0.0", "versionEndExcluding": "7.3.4", "matchCriteriaId": "FC485773-721B-43D4-A9C9-EF8629675CF8"}]}]}], "references": [{"url": "https://github.com/automattic/mongoose/commit/305ce4ff789261df7e3f6e72363d0703e025f80d", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/1eef5a72-f6ab-4f61-b31d-fc66f5b4b467", "source": "security@huntr.dev", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/automattic/mongoose/commit/305ce4ff789261df7e3f6e72363d0703e025f80d"}}