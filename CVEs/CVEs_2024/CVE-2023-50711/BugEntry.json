{"buggy_code": ["[package]\nname = \"vmm-sys-util\"\nversion = \"0.11.2\"\nauthors = [\"Intel Virtualization Team <vmm-maintainers@intel.com>\"]\ndescription = \"A system utility set\"\nrepository = \"https://github.com/rust-vmm/vmm-sys-util\"\nreadme = \"README.md\"\nkeywords = [\"utils\"]\nedition = \"2021\"\nlicense = \"BSD-3-Clause\"\n\n[package.metadata.docs.rs]\nall-features = true\nrustdoc-args = [\"--cfg\", \"docsrs\"]\n\n[features]\nwith-serde = [\"serde\", \"serde_derive\"]\n\n[dependencies]\nlibc = \"0.2.39\"\nserde = { version = \"1.0.27\", optional = true }\nserde_derive = { version = \"1.0.27\", optional = true }\n\n[target.'cfg(any(target_os = \"linux\", target_os = \"android\"))'.dependencies]\nbitflags = \"1.0\"\n\n[dev-dependencies]\nserde_json = \"1.0.9\"\n", "// Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n//\n// Portions Copyright 2017 The Chromium OS Authors. All rights reserved.\n//\n// SPDX-License-Identifier: BSD-3-Clause\n\n//! Trait and wrapper for working with C defined FAM structures.\n//!\n//! In C 99 an array of unknown size may appear within a struct definition as the last member\n//! (as long as there is at least one other named member).\n//! This is known as a flexible array member (FAM).\n//! Pre C99, the same behavior could be achieved using zero length arrays.\n//!\n//! Flexible Array Members are the go-to choice for working with large amounts of data\n//! prefixed by header values.\n//!\n//! For example the KVM API has many structures of this kind.\n\n#[cfg(feature = \"with-serde\")]\nuse serde::de::{self, Deserialize, Deserializer, SeqAccess, Visitor};\n#[cfg(feature = \"with-serde\")]\nuse serde::{ser::SerializeTuple, Serialize, Serializer};\nuse std::fmt;\n#[cfg(feature = \"with-serde\")]\nuse std::marker::PhantomData;\nuse std::mem::{self, size_of};\n\n/// Errors associated with the [`FamStructWrapper`](struct.FamStructWrapper.html) struct.\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum Error {\n    /// The max size has been exceeded\n    SizeLimitExceeded,\n}\n\nimpl std::error::Error for Error {}\n\nimpl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            Self::SizeLimitExceeded => write!(f, \"The max size has been exceeded\"),\n        }\n    }\n}\n\n/// Trait for accessing properties of C defined FAM structures.\n///\n/// # Safety\n///\n/// This is unsafe due to the number of constraints that aren't checked:\n/// * the implementer should be a POD\n/// * the implementor should contain a flexible array member of elements of type `Entry`\n/// * `Entry` should be a POD\n///\n/// Violating these may cause problems.\n///\n/// # Example\n///\n/// ```\n/// use vmm_sys_util::fam::*;\n///\n/// #[repr(C)]\n/// #[derive(Default)]\n/// pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);\n/// impl<T> __IncompleteArrayField<T> {\n///     #[inline]\n///     pub fn new() -> Self {\n///         __IncompleteArrayField(::std::marker::PhantomData, [])\n///     }\n///     #[inline]\n///     pub unsafe fn as_ptr(&self) -> *const T {\n///         ::std::mem::transmute(self)\n///     }\n///     #[inline]\n///     pub unsafe fn as_mut_ptr(&mut self) -> *mut T {\n///         ::std::mem::transmute(self)\n///     }\n///     #[inline]\n///     pub unsafe fn as_slice(&self, len: usize) -> &[T] {\n///         ::std::slice::from_raw_parts(self.as_ptr(), len)\n///     }\n///     #[inline]\n///     pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {\n///         ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)\n///     }\n/// }\n///\n/// #[repr(C)]\n/// #[derive(Default)]\n/// struct MockFamStruct {\n///     pub len: u32,\n///     pub padding: u32,\n///     pub entries: __IncompleteArrayField<u32>,\n/// }\n///\n/// unsafe impl FamStruct for MockFamStruct {\n///     type Entry = u32;\n///\n///     fn len(&self) -> usize {\n///         self.len as usize\n///     }\n///\n///     fn set_len(&mut self, len: usize) {\n///         self.len = len as u32\n///     }\n///\n///     fn max_len() -> usize {\n///         100\n///     }\n///\n///     fn as_slice(&self) -> &[u32] {\n///         let len = self.len();\n///         unsafe { self.entries.as_slice(len) }\n///     }\n///\n///     fn as_mut_slice(&mut self) -> &mut [u32] {\n///         let len = self.len();\n///         unsafe { self.entries.as_mut_slice(len) }\n///     }\n/// }\n///\n/// type MockFamStructWrapper = FamStructWrapper<MockFamStruct>;\n/// ```\n#[allow(clippy::len_without_is_empty)]\npub unsafe trait FamStruct {\n    /// The type of the FAM entries\n    type Entry: PartialEq + Copy;\n\n    /// Get the FAM length\n    ///\n    /// These type of structures contain a member that holds the FAM length.\n    /// This method will return the value of that member.\n    fn len(&self) -> usize;\n\n    /// Set the FAM length\n    ///\n    /// These type of structures contain a member that holds the FAM length.\n    /// This method will set the value of that member.\n    fn set_len(&mut self, len: usize);\n\n    /// Get max allowed FAM length\n    ///\n    /// This depends on each structure.\n    /// For example a structure representing the cpuid can contain at most 80 entries.\n    fn max_len() -> usize;\n\n    /// Get the FAM entries as slice\n    fn as_slice(&self) -> &[Self::Entry];\n\n    /// Get the FAM entries as mut slice\n    fn as_mut_slice(&mut self) -> &mut [Self::Entry];\n}\n\n/// A wrapper for [`FamStruct`](trait.FamStruct.html).\n///\n/// It helps in treating a [`FamStruct`](trait.FamStruct.html) similarly to an actual `Vec`.\n#[derive(Debug)]\npub struct FamStructWrapper<T: Default + FamStruct> {\n    // This variable holds the FamStruct structure. We use a `Vec<T>` to make the allocation\n    // large enough while still being aligned for `T`. Only the first element of `Vec<T>`\n    // will actually be used as a `T`. The remaining memory in the `Vec<T>` is for `entries`,\n    // which must be contiguous. Since the entries are of type `FamStruct::Entry` we must\n    // be careful to convert the desired capacity of the `FamStructWrapper`\n    // from `FamStruct::Entry` to `T` when reserving or releasing memory.\n    mem_allocator: Vec<T>,\n}\n\nimpl<T: Default + FamStruct> FamStructWrapper<T> {\n    /// Convert FAM len to `mem_allocator` len.\n    ///\n    /// Get the capacity required by mem_allocator in order to hold\n    /// the provided number of [`FamStruct::Entry`](trait.FamStruct.html#associatedtype.Entry).\n    /// Returns `None` if the required length would overflow usize.\n    fn mem_allocator_len(fam_len: usize) -> Option<usize> {\n        let wrapper_size_in_bytes =\n            size_of::<T>().checked_add(fam_len.checked_mul(size_of::<T::Entry>())?)?;\n\n        wrapper_size_in_bytes\n            .checked_add(size_of::<T>().checked_sub(1)?)?\n            .checked_div(size_of::<T>())\n    }\n\n    /// Convert `mem_allocator` len to FAM len.\n    ///\n    /// Get the number of elements of type\n    /// [`FamStruct::Entry`](trait.FamStruct.html#associatedtype.Entry)\n    /// that fit in a mem_allocator of provided len.\n    fn fam_len(mem_allocator_len: usize) -> usize {\n        if mem_allocator_len == 0 {\n            return 0;\n        }\n\n        let array_size_in_bytes = (mem_allocator_len - 1) * size_of::<T>();\n        array_size_in_bytes / size_of::<T::Entry>()\n    }\n\n    /// Create a new FamStructWrapper with `num_elements` elements.\n    ///\n    /// The elements will be zero-initialized. The type of the elements will be\n    /// [`FamStruct::Entry`](trait.FamStruct.html#associatedtype.Entry).\n    ///\n    /// # Arguments\n    ///\n    /// * `num_elements` - The number of elements in the FamStructWrapper.\n    ///\n    /// # Errors\n    ///\n    /// When `num_elements` is greater than the max possible len, it returns\n    /// `Error::SizeLimitExceeded`.\n    pub fn new(num_elements: usize) -> Result<FamStructWrapper<T>, Error> {\n        if num_elements > T::max_len() {\n            return Err(Error::SizeLimitExceeded);\n        }\n        let required_mem_allocator_capacity =\n            FamStructWrapper::<T>::mem_allocator_len(num_elements)\n                .ok_or(Error::SizeLimitExceeded)?;\n\n        let mut mem_allocator = Vec::with_capacity(required_mem_allocator_capacity);\n        mem_allocator.push(T::default());\n        for _ in 1..required_mem_allocator_capacity {\n            // SAFETY: Safe as long T follows the requirements of being POD.\n            mem_allocator.push(unsafe { mem::zeroed() })\n        }\n        mem_allocator[0].set_len(num_elements);\n\n        Ok(FamStructWrapper { mem_allocator })\n    }\n\n    /// Create a new FamStructWrapper from a slice of elements.\n    ///\n    /// # Arguments\n    ///\n    /// * `entries` - The slice of [`FamStruct::Entry`](trait.FamStruct.html#associatedtype.Entry)\n    ///               entries.\n    ///\n    /// # Errors\n    ///\n    /// When the size of `entries` is greater than the max possible len, it returns\n    /// `Error::SizeLimitExceeded`.\n    pub fn from_entries(entries: &[T::Entry]) -> Result<FamStructWrapper<T>, Error> {\n        let mut adapter = FamStructWrapper::<T>::new(entries.len())?;\n\n        {\n            let wrapper_entries = adapter.as_mut_fam_struct().as_mut_slice();\n            wrapper_entries.copy_from_slice(entries);\n        }\n\n        Ok(adapter)\n    }\n\n    /// Create a new FamStructWrapper from the raw content represented as `Vec<T>`.\n    ///\n    /// Sometimes we already have the raw content of an FAM struct represented as `Vec<T>`,\n    /// and want to use the FamStructWrapper as accessors.\n    ///\n    /// # Arguments\n    ///\n    /// * `content` - The raw content represented as `Vec[T]`.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe because the caller needs to ensure that the raw content is\n    /// correctly layed out.\n    pub unsafe fn from_raw(content: Vec<T>) -> Self {\n        FamStructWrapper {\n            mem_allocator: content,\n        }\n    }\n\n    /// Consume the FamStructWrapper and return the raw content as `Vec<T>`.\n    pub fn into_raw(self) -> Vec<T> {\n        self.mem_allocator\n    }\n\n    /// Get a reference to the actual [`FamStruct`](trait.FamStruct.html) instance.\n    pub fn as_fam_struct_ref(&self) -> &T {\n        &self.mem_allocator[0]\n    }\n\n    /// Get a mut reference to the actual [`FamStruct`](trait.FamStruct.html) instance.\n    pub fn as_mut_fam_struct(&mut self) -> &mut T {\n        &mut self.mem_allocator[0]\n    }\n\n    /// Get a pointer to the [`FamStruct`](trait.FamStruct.html) instance.\n    ///\n    /// The caller must ensure that the fam_struct outlives the pointer this\n    /// function returns, or else it will end up pointing to garbage.\n    ///\n    /// Modifying the container referenced by this pointer may cause its buffer\n    /// to be reallocated, which would also make any pointers to it invalid.\n    pub fn as_fam_struct_ptr(&self) -> *const T {\n        self.as_fam_struct_ref()\n    }\n\n    /// Get a mutable pointer to the [`FamStruct`](trait.FamStruct.html) instance.\n    ///\n    /// The caller must ensure that the fam_struct outlives the pointer this\n    /// function returns, or else it will end up pointing to garbage.\n    ///\n    /// Modifying the container referenced by this pointer may cause its buffer\n    /// to be reallocated, which would also make any pointers to it invalid.\n    pub fn as_mut_fam_struct_ptr(&mut self) -> *mut T {\n        self.as_mut_fam_struct()\n    }\n\n    /// Get the elements slice.\n    pub fn as_slice(&self) -> &[T::Entry] {\n        self.as_fam_struct_ref().as_slice()\n    }\n\n    /// Get the mutable elements slice.\n    pub fn as_mut_slice(&mut self) -> &mut [T::Entry] {\n        self.as_mut_fam_struct().as_mut_slice()\n    }\n\n    /// Get the number of elements of type `FamStruct::Entry` currently in the vec.\n    fn len(&self) -> usize {\n        self.as_fam_struct_ref().len()\n    }\n\n    /// Get the capacity of the `FamStructWrapper`\n    ///\n    /// The capacity is measured in elements of type `FamStruct::Entry`.\n    fn capacity(&self) -> usize {\n        FamStructWrapper::<T>::fam_len(self.mem_allocator.capacity())\n    }\n\n    /// Reserve additional capacity.\n    ///\n    /// Reserve capacity for at least `additional` more\n    /// [`FamStruct::Entry`](trait.FamStruct.html#associatedtype.Entry) elements.\n    ///\n    /// If the capacity is already reserved, this method doesn't do anything.\n    /// If not this will trigger a reallocation of the underlying buffer.\n    fn reserve(&mut self, additional: usize) -> Result<(), Error> {\n        let desired_capacity = self.len() + additional;\n        if desired_capacity <= self.capacity() {\n            return Ok(());\n        }\n\n        let current_mem_allocator_len = self.mem_allocator.len();\n        let required_mem_allocator_len = FamStructWrapper::<T>::mem_allocator_len(desired_capacity)\n            .ok_or(Error::SizeLimitExceeded)?;\n        let additional_mem_allocator_len = required_mem_allocator_len - current_mem_allocator_len;\n\n        self.mem_allocator.reserve(additional_mem_allocator_len);\n\n        Ok(())\n    }\n\n    /// Update the length of the FamStructWrapper.\n    ///\n    /// The length of `self` will be updated to the specified value.\n    /// The length of the `T` structure and of `self.mem_allocator` will be updated accordingly.\n    /// If the len is increased additional capacity will be reserved.\n    /// If the len is decreased the unnecessary memory will be deallocated.\n    ///\n    /// This method might trigger reallocations of the underlying buffer.\n    ///\n    /// # Errors\n    ///\n    /// When len is greater than the max possible len it returns Error::SizeLimitExceeded.\n    fn set_len(&mut self, len: usize) -> Result<(), Error> {\n        let additional_elements = isize::try_from(len)\n            .and_then(|len| isize::try_from(self.len()).map(|self_len| len - self_len))\n            .map_err(|_| Error::SizeLimitExceeded)?;\n\n        // If len == self.len there's nothing to do.\n        if additional_elements == 0 {\n            return Ok(());\n        }\n\n        // If the len needs to be increased:\n        if additional_elements > 0 {\n            // Check if the new len is valid.\n            if len > T::max_len() {\n                return Err(Error::SizeLimitExceeded);\n            }\n            // Reserve additional capacity.\n            self.reserve(additional_elements as usize)?;\n        }\n\n        let current_mem_allocator_len = self.mem_allocator.len();\n        let required_mem_allocator_len =\n            FamStructWrapper::<T>::mem_allocator_len(len).ok_or(Error::SizeLimitExceeded)?;\n        // Update the len of the `mem_allocator`.\n        // SAFETY: This is safe since enough capacity has been reserved.\n        unsafe {\n            self.mem_allocator.set_len(required_mem_allocator_len);\n        }\n        // Zero-initialize the additional elements if any.\n        for i in current_mem_allocator_len..required_mem_allocator_len {\n            // SAFETY: Safe as long as the trait is only implemented for POD. This is a requirement\n            // for the trait implementation.\n            self.mem_allocator[i] = unsafe { mem::zeroed() }\n        }\n        // Update the len of the underlying `FamStruct`.\n        self.as_mut_fam_struct().set_len(len);\n\n        // If the len needs to be decreased, deallocate unnecessary memory\n        if additional_elements < 0 {\n            self.mem_allocator.shrink_to_fit();\n        }\n\n        Ok(())\n    }\n\n    /// Append an element.\n    ///\n    /// # Arguments\n    ///\n    /// * `entry` - The element that will be appended to the end of the collection.\n    ///\n    /// # Errors\n    ///\n    /// When len is already equal to max possible len it returns Error::SizeLimitExceeded.\n    pub fn push(&mut self, entry: T::Entry) -> Result<(), Error> {\n        let new_len = self.len() + 1;\n        self.set_len(new_len)?;\n        self.as_mut_slice()[new_len - 1] = entry;\n\n        Ok(())\n    }\n\n    /// Retain only the elements specified by the predicate.\n    ///\n    /// # Arguments\n    ///\n    /// * `f` - The function used to evaluate whether an entry will be kept or not.\n    ///         When `f` returns `true` the entry is kept.\n    pub fn retain<P>(&mut self, mut f: P)\n    where\n        P: FnMut(&T::Entry) -> bool,\n    {\n        let mut num_kept_entries = 0;\n        {\n            let entries = self.as_mut_slice();\n            for entry_idx in 0..entries.len() {\n                let keep = f(&entries[entry_idx]);\n                if keep {\n                    entries[num_kept_entries] = entries[entry_idx];\n                    num_kept_entries += 1;\n                }\n            }\n        }\n\n        // This is safe since this method is not increasing the len\n        self.set_len(num_kept_entries).expect(\"invalid length\");\n    }\n}\n\nimpl<T: Default + FamStruct + PartialEq> PartialEq for FamStructWrapper<T> {\n    fn eq(&self, other: &FamStructWrapper<T>) -> bool {\n        self.as_fam_struct_ref() == other.as_fam_struct_ref() && self.as_slice() == other.as_slice()\n    }\n}\n\nimpl<T: Default + FamStruct> Clone for FamStructWrapper<T> {\n    fn clone(&self) -> Self {\n        // The number of entries (self.as_slice().len()) can't be > T::max_len() since `self` is a\n        // valid `FamStructWrapper`. This makes the .unwrap() safe.\n        let required_mem_allocator_capacity =\n            FamStructWrapper::<T>::mem_allocator_len(self.as_slice().len()).unwrap();\n\n        let mut mem_allocator = Vec::with_capacity(required_mem_allocator_capacity);\n\n        // SAFETY: This is safe as long as the requirements for the `FamStruct` trait to be safe\n        // are met (the implementing type and the entries elements are POD, therefore `Copy`, so\n        // memory safety can't be violated by the ownership of `fam_struct`). It is also safe\n        // because we're trying to read a T from a `&T` that is pointing to a properly initialized\n        // and aligned T.\n        unsafe {\n            let fam_struct: T = std::ptr::read(self.as_fam_struct_ref());\n            mem_allocator.push(fam_struct);\n        }\n        for _ in 1..required_mem_allocator_capacity {\n            mem_allocator.push(\n                // SAFETY: This is safe as long as T respects the FamStruct trait and is a POD.\n                unsafe { mem::zeroed() },\n            )\n        }\n\n        let mut adapter = FamStructWrapper { mem_allocator };\n        {\n            let wrapper_entries = adapter.as_mut_fam_struct().as_mut_slice();\n            wrapper_entries.copy_from_slice(self.as_slice());\n        }\n        adapter\n    }\n}\n\nimpl<T: Default + FamStruct> From<Vec<T>> for FamStructWrapper<T> {\n    fn from(vec: Vec<T>) -> Self {\n        FamStructWrapper { mem_allocator: vec }\n    }\n}\n\n#[cfg(feature = \"with-serde\")]\nimpl<T: Default + FamStruct + Serialize> Serialize for FamStructWrapper<T>\nwhere\n    <T as FamStruct>::Entry: serde::Serialize,\n{\n    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        let mut s = serializer.serialize_tuple(2)?;\n        s.serialize_element(self.as_fam_struct_ref())?;\n        s.serialize_element(self.as_slice())?;\n        s.end()\n    }\n}\n\n#[cfg(feature = \"with-serde\")]\nimpl<'de, T: Default + FamStruct + Deserialize<'de>> Deserialize<'de> for FamStructWrapper<T>\nwhere\n    <T as FamStruct>::Entry: std::marker::Copy + serde::Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        struct FamStructWrapperVisitor<X> {\n            dummy: PhantomData<X>,\n        }\n\n        impl<'de, X: Default + FamStruct + Deserialize<'de>> Visitor<'de> for FamStructWrapperVisitor<X>\n        where\n            <X as FamStruct>::Entry: std::marker::Copy + serde::Deserialize<'de>,\n        {\n            type Value = FamStructWrapper<X>;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"FamStructWrapper\")\n            }\n\n            fn visit_seq<V>(self, mut seq: V) -> Result<FamStructWrapper<X>, V::Error>\n            where\n                V: SeqAccess<'de>,\n            {\n                use serde::de::Error;\n\n                let header = seq\n                    .next_element()?\n                    .ok_or_else(|| de::Error::invalid_length(0, &self))?;\n                let entries: Vec<X::Entry> = seq\n                    .next_element()?\n                    .ok_or_else(|| de::Error::invalid_length(1, &self))?;\n\n                let mut result: Self::Value = FamStructWrapper::from_entries(entries.as_slice())\n                    .map_err(|e| V::Error::custom(format!(\"{:?}\", e)))?;\n                result.mem_allocator[0] = header;\n                Ok(result)\n            }\n        }\n\n        deserializer.deserialize_tuple(2, FamStructWrapperVisitor { dummy: PhantomData })\n    }\n}\n\n/// Generate `FamStruct` implementation for structs with flexible array member.\n#[macro_export]\nmacro_rules! generate_fam_struct_impl {\n    ($struct_type: ty, $entry_type: ty, $entries_name: ident,\n     $field_type: ty, $field_name: ident, $max: expr) => {\n        unsafe impl FamStruct for $struct_type {\n            type Entry = $entry_type;\n\n            fn len(&self) -> usize {\n                self.$field_name as usize\n            }\n\n            fn set_len(&mut self, len: usize) {\n                self.$field_name = len as $field_type;\n            }\n\n            fn max_len() -> usize {\n                $max\n            }\n\n            fn as_slice(&self) -> &[<Self as FamStruct>::Entry] {\n                let len = self.len();\n                unsafe { self.$entries_name.as_slice(len) }\n            }\n\n            fn as_mut_slice(&mut self) -> &mut [<Self as FamStruct>::Entry] {\n                let len = self.len();\n                unsafe { self.$entries_name.as_mut_slice(len) }\n            }\n        }\n    };\n}\n\n#[cfg(test)]\nmod tests {\n    #![allow(clippy::undocumented_unsafe_blocks)]\n\n    #[cfg(feature = \"with-serde\")]\n    use serde_derive::{Deserialize, Serialize};\n\n    use super::*;\n\n    const MAX_LEN: usize = 100;\n\n    #[repr(C)]\n    #[derive(Default, PartialEq, Eq)]\n    pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);\n    impl<T> __IncompleteArrayField<T> {\n        #[inline]\n        pub fn new() -> Self {\n            __IncompleteArrayField(::std::marker::PhantomData, [])\n        }\n        #[inline]\n        pub unsafe fn as_ptr(&self) -> *const T {\n            self as *const __IncompleteArrayField<T> as *const T\n        }\n        #[inline]\n        pub unsafe fn as_mut_ptr(&mut self) -> *mut T {\n            self as *mut __IncompleteArrayField<T> as *mut T\n        }\n        #[inline]\n        pub unsafe fn as_slice(&self, len: usize) -> &[T] {\n            ::std::slice::from_raw_parts(self.as_ptr(), len)\n        }\n        #[inline]\n        pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {\n            ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)\n        }\n    }\n\n    #[cfg(feature = \"with-serde\")]\n    impl<T> Serialize for __IncompleteArrayField<T> {\n        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>\n        where\n            S: Serializer,\n        {\n            [0u8; 0].serialize(serializer)\n        }\n    }\n\n    #[cfg(feature = \"with-serde\")]\n    impl<'de, T> Deserialize<'de> for __IncompleteArrayField<T> {\n        fn deserialize<D>(_: D) -> std::result::Result<Self, D::Error>\n        where\n            D: Deserializer<'de>,\n        {\n            Ok(__IncompleteArrayField::new())\n        }\n    }\n\n    #[repr(C)]\n    #[derive(Default, PartialEq)]\n    struct MockFamStruct {\n        pub len: u32,\n        pub padding: u32,\n        pub entries: __IncompleteArrayField<u32>,\n    }\n\n    generate_fam_struct_impl!(MockFamStruct, u32, entries, u32, len, 100);\n\n    type MockFamStructWrapper = FamStructWrapper<MockFamStruct>;\n\n    const ENTRIES_OFFSET: usize = 2;\n\n    const FAM_LEN_TO_MEM_ALLOCATOR_LEN: &[(usize, usize)] = &[\n        (0, 1),\n        (1, 2),\n        (2, 2),\n        (3, 3),\n        (4, 3),\n        (5, 4),\n        (10, 6),\n        (50, 26),\n        (100, 51),\n    ];\n\n    const MEM_ALLOCATOR_LEN_TO_FAM_LEN: &[(usize, usize)] = &[\n        (0, 0),\n        (1, 0),\n        (2, 2),\n        (3, 4),\n        (4, 6),\n        (5, 8),\n        (10, 18),\n        (50, 98),\n        (100, 198),\n    ];\n\n    #[test]\n    fn test_mem_allocator_len() {\n        for pair in FAM_LEN_TO_MEM_ALLOCATOR_LEN {\n            let fam_len = pair.0;\n            let mem_allocator_len = pair.1;\n            assert_eq!(\n                Some(mem_allocator_len),\n                MockFamStructWrapper::mem_allocator_len(fam_len)\n            );\n        }\n    }\n\n    #[repr(C)]\n    #[derive(Default, PartialEq)]\n    struct MockFamStructU8 {\n        pub len: u32,\n        pub padding: u32,\n        pub entries: __IncompleteArrayField<u8>,\n    }\n    generate_fam_struct_impl!(MockFamStructU8, u8, entries, u32, len, 100);\n    type MockFamStructWrapperU8 = FamStructWrapper<MockFamStructU8>;\n    #[test]\n    fn test_invalid_type_conversion() {\n        let mut adapter = MockFamStructWrapperU8::new(10).unwrap();\n        assert!(matches!(\n            adapter.set_len(0xffff_ffff_ffff_ff00),\n            Err(Error::SizeLimitExceeded)\n        ));\n    }\n\n    #[test]\n    fn test_wrapper_len() {\n        for pair in MEM_ALLOCATOR_LEN_TO_FAM_LEN {\n            let mem_allocator_len = pair.0;\n            let fam_len = pair.1;\n            assert_eq!(fam_len, MockFamStructWrapper::fam_len(mem_allocator_len));\n        }\n    }\n\n    #[test]\n    fn test_new() {\n        let num_entries = 10;\n\n        let adapter = MockFamStructWrapper::new(num_entries).unwrap();\n        assert_eq!(num_entries, adapter.capacity());\n\n        let u32_slice = unsafe {\n            std::slice::from_raw_parts(\n                adapter.as_fam_struct_ptr() as *const u32,\n                num_entries + ENTRIES_OFFSET,\n            )\n        };\n        assert_eq!(num_entries, u32_slice[0] as usize);\n        for entry in u32_slice[1..].iter() {\n            assert_eq!(*entry, 0);\n        }\n\n        // It's okay to create a `FamStructWrapper` with the maximum allowed number of entries.\n        let adapter = MockFamStructWrapper::new(MockFamStruct::max_len()).unwrap();\n        assert_eq!(MockFamStruct::max_len(), adapter.capacity());\n\n        assert!(matches!(\n            MockFamStructWrapper::new(MockFamStruct::max_len() + 1),\n            Err(Error::SizeLimitExceeded)\n        ));\n    }\n\n    #[test]\n    fn test_from_entries() {\n        let num_entries: usize = 10;\n\n        let mut entries = Vec::new();\n        for i in 0..num_entries {\n            entries.push(i as u32);\n        }\n\n        let adapter = MockFamStructWrapper::from_entries(entries.as_slice()).unwrap();\n        let u32_slice = unsafe {\n            std::slice::from_raw_parts(\n                adapter.as_fam_struct_ptr() as *const u32,\n                num_entries + ENTRIES_OFFSET,\n            )\n        };\n        assert_eq!(num_entries, u32_slice[0] as usize);\n        for (i, &value) in entries.iter().enumerate().take(num_entries) {\n            assert_eq!(adapter.as_slice()[i], value);\n        }\n\n        let mut entries = Vec::new();\n        for i in 0..MockFamStruct::max_len() + 1 {\n            entries.push(i as u32);\n        }\n\n        // Can't create a `FamStructWrapper` with a number of entries > MockFamStruct::max_len().\n        assert!(matches!(\n            MockFamStructWrapper::from_entries(entries.as_slice()),\n            Err(Error::SizeLimitExceeded)\n        ));\n    }\n\n    #[test]\n    fn test_entries_slice() {\n        let num_entries = 10;\n        let mut adapter = MockFamStructWrapper::new(num_entries).unwrap();\n\n        let expected_slice = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\n        {\n            let mut_entries_slice = adapter.as_mut_slice();\n            mut_entries_slice.copy_from_slice(expected_slice);\n        }\n\n        let u32_slice = unsafe {\n            std::slice::from_raw_parts(\n                adapter.as_fam_struct_ptr() as *const u32,\n                num_entries + ENTRIES_OFFSET,\n            )\n        };\n        assert_eq!(expected_slice, &u32_slice[ENTRIES_OFFSET..]);\n        assert_eq!(expected_slice, adapter.as_slice());\n    }\n\n    #[test]\n    fn test_reserve() {\n        let mut adapter = MockFamStructWrapper::new(0).unwrap();\n\n        // test that the right capacity is reserved\n        for pair in FAM_LEN_TO_MEM_ALLOCATOR_LEN {\n            let num_elements = pair.0;\n            let required_mem_allocator_len = pair.1;\n\n            adapter.reserve(num_elements).unwrap();\n\n            assert!(adapter.mem_allocator.capacity() >= required_mem_allocator_len);\n            assert_eq!(0, adapter.len());\n            assert!(adapter.capacity() >= num_elements);\n        }\n\n        // test that when the capacity is already reserved, the method doesn't do anything\n        let current_capacity = adapter.capacity();\n        adapter.reserve(current_capacity - 1).unwrap();\n        assert_eq!(current_capacity, adapter.capacity());\n    }\n\n    #[test]\n    fn test_set_len() {\n        let mut desired_len = 0;\n        let mut adapter = MockFamStructWrapper::new(desired_len).unwrap();\n\n        // keep initial len\n        assert!(adapter.set_len(desired_len).is_ok());\n        assert_eq!(adapter.len(), desired_len);\n\n        // increase len\n        desired_len = 10;\n        assert!(adapter.set_len(desired_len).is_ok());\n        // check that the len has been increased and zero-initialized elements have been added\n        assert_eq!(adapter.len(), desired_len);\n        for element in adapter.as_slice() {\n            assert_eq!(*element, 0_u32);\n        }\n\n        // decrease len\n        desired_len = 5;\n        assert!(adapter.set_len(desired_len).is_ok());\n        assert_eq!(adapter.len(), desired_len);\n    }\n\n    #[test]\n    fn test_push() {\n        let mut adapter = MockFamStructWrapper::new(0).unwrap();\n\n        for i in 0..MAX_LEN {\n            assert!(adapter.push(i as u32).is_ok());\n            assert_eq!(adapter.as_slice()[i], i as u32);\n            assert_eq!(adapter.len(), i + 1);\n            assert!(\n                adapter.mem_allocator.capacity()\n                    >= MockFamStructWrapper::mem_allocator_len(i + 1).unwrap()\n            );\n        }\n\n        assert!(adapter.push(0).is_err());\n    }\n\n    #[test]\n    fn test_retain() {\n        let mut adapter = MockFamStructWrapper::new(0).unwrap();\n\n        let mut num_retained_entries = 0;\n        for i in 0..MAX_LEN {\n            assert!(adapter.push(i as u32).is_ok());\n            if i % 2 == 0 {\n                num_retained_entries += 1;\n            }\n        }\n\n        adapter.retain(|entry| entry % 2 == 0);\n\n        for entry in adapter.as_slice().iter() {\n            assert_eq!(0, entry % 2);\n        }\n        assert_eq!(adapter.len(), num_retained_entries);\n        assert!(\n            adapter.mem_allocator.capacity()\n                >= MockFamStructWrapper::mem_allocator_len(num_retained_entries).unwrap()\n        );\n    }\n\n    #[test]\n    fn test_partial_eq() {\n        let mut wrapper_1 = MockFamStructWrapper::new(0).unwrap();\n        let mut wrapper_2 = MockFamStructWrapper::new(0).unwrap();\n        let mut wrapper_3 = MockFamStructWrapper::new(0).unwrap();\n\n        for i in 0..MAX_LEN {\n            assert!(wrapper_1.push(i as u32).is_ok());\n            assert!(wrapper_2.push(i as u32).is_ok());\n            assert!(wrapper_3.push(0).is_ok());\n        }\n\n        assert!(wrapper_1 == wrapper_2);\n        assert!(wrapper_1 != wrapper_3);\n    }\n\n    #[test]\n    fn test_clone() {\n        let mut adapter = MockFamStructWrapper::new(0).unwrap();\n\n        for i in 0..MAX_LEN {\n            assert!(adapter.push(i as u32).is_ok());\n        }\n\n        assert!(adapter == adapter.clone());\n    }\n\n    #[test]\n    fn test_raw_content() {\n        let data = vec![\n            MockFamStruct {\n                len: 2,\n                padding: 5,\n                entries: __IncompleteArrayField::new(),\n            },\n            MockFamStruct {\n                len: 0xA5,\n                padding: 0x1e,\n                entries: __IncompleteArrayField::new(),\n            },\n        ];\n\n        let mut wrapper = unsafe { MockFamStructWrapper::from_raw(data) };\n        {\n            let payload = wrapper.as_slice();\n            assert_eq!(payload[0], 0xA5);\n            assert_eq!(payload[1], 0x1e);\n        }\n        assert_eq!(wrapper.as_mut_fam_struct().padding, 5);\n        let data = wrapper.into_raw();\n        assert_eq!(data[0].len, 2);\n        assert_eq!(data[0].padding, 5);\n    }\n\n    #[cfg(feature = \"with-serde\")]\n    #[test]\n    fn test_ser_deser() {\n        #[repr(C)]\n        #[derive(Default, PartialEq)]\n        #[cfg_attr(feature = \"with-serde\", derive(Deserialize, Serialize))]\n        struct Message {\n            pub len: u32,\n            pub padding: u32,\n            pub value: u32,\n            #[cfg_attr(feature = \"with-serde\", serde(skip))]\n            pub entries: __IncompleteArrayField<u32>,\n        }\n\n        generate_fam_struct_impl!(Message, u32, entries, u32, len, 100);\n\n        type MessageFamStructWrapper = FamStructWrapper<Message>;\n\n        let data = vec![\n            Message {\n                len: 2,\n                padding: 0,\n                value: 42,\n                entries: __IncompleteArrayField::new(),\n            },\n            Message {\n                len: 0xA5,\n                padding: 0x1e,\n                value: 0,\n                entries: __IncompleteArrayField::new(),\n            },\n        ];\n\n        let wrapper = unsafe { MessageFamStructWrapper::from_raw(data) };\n        let data_ser = serde_json::to_string(&wrapper).unwrap();\n        assert_eq!(\n            data_ser,\n            \"[{\\\"len\\\":2,\\\"padding\\\":0,\\\"value\\\":42},[165,30]]\"\n        );\n        let data_deser =\n            serde_json::from_str::<MessageFamStructWrapper>(data_ser.as_str()).unwrap();\n        assert!(wrapper.eq(&data_deser));\n\n        let bad_data_ser = r#\"{\"foo\": \"bar\"}\"#;\n        assert!(serde_json::from_str::<MessageFamStructWrapper>(bad_data_ser).is_err());\n\n        #[repr(C)]\n        #[derive(Default)]\n        #[cfg_attr(feature = \"with-serde\", derive(Deserialize, Serialize))]\n        struct Message2 {\n            pub len: u32,\n            pub padding: u32,\n            pub value: u32,\n            #[cfg_attr(feature = \"with-serde\", serde(skip))]\n            pub entries: __IncompleteArrayField<u32>,\n        }\n\n        // Maximum number of entries = 1, so the deserialization should fail because of this reason.\n        generate_fam_struct_impl!(Message2, u32, entries, u32, len, 1);\n\n        type Message2FamStructWrapper = FamStructWrapper<Message2>;\n        assert!(serde_json::from_str::<Message2FamStructWrapper>(data_ser.as_str()).is_err());\n    }\n\n    #[test]\n    fn test_clone_multiple_fields() {\n        #[derive(Default, PartialEq)]\n        #[repr(C)]\n        struct Foo {\n            index: u32,\n            length: u16,\n            flags: u32,\n            entries: __IncompleteArrayField<u32>,\n        }\n\n        generate_fam_struct_impl!(Foo, u32, entries, u16, length, 100);\n\n        type FooFamStructWrapper = FamStructWrapper<Foo>;\n\n        let mut wrapper = FooFamStructWrapper::new(0).unwrap();\n        wrapper.as_mut_fam_struct().index = 1;\n        wrapper.as_mut_fam_struct().flags = 2;\n        wrapper.as_mut_fam_struct().length = 3;\n        wrapper.push(3).unwrap();\n        wrapper.push(14).unwrap();\n        assert_eq!(wrapper.as_slice().len(), 3 + 2);\n        assert_eq!(wrapper.as_slice()[3], 3);\n        assert_eq!(wrapper.as_slice()[3 + 1], 14);\n\n        let mut wrapper2 = wrapper.clone();\n        assert_eq!(\n            wrapper.as_mut_fam_struct().index,\n            wrapper2.as_mut_fam_struct().index\n        );\n        assert_eq!(\n            wrapper.as_mut_fam_struct().length,\n            wrapper2.as_mut_fam_struct().length\n        );\n        assert_eq!(\n            wrapper.as_mut_fam_struct().flags,\n            wrapper2.as_mut_fam_struct().flags\n        );\n        assert_eq!(wrapper.as_slice(), wrapper2.as_slice());\n        assert_eq!(\n            wrapper2.as_slice().len(),\n            wrapper2.as_mut_fam_struct().length as usize\n        );\n        assert!(wrapper == wrapper2);\n\n        wrapper.as_mut_fam_struct().index = 3;\n        assert!(wrapper != wrapper2);\n\n        wrapper.as_mut_fam_struct().length = 7;\n        assert!(wrapper != wrapper2);\n\n        wrapper.push(1).unwrap();\n        assert_eq!(wrapper.as_mut_fam_struct().length, 8);\n        assert!(wrapper != wrapper2);\n\n        let mut wrapper2 = wrapper.clone();\n        assert!(wrapper == wrapper2);\n\n        // Dropping the original variable should not affect its clone.\n        drop(wrapper);\n        assert_eq!(wrapper2.as_mut_fam_struct().index, 3);\n        assert_eq!(wrapper2.as_mut_fam_struct().length, 8);\n        assert_eq!(wrapper2.as_mut_fam_struct().flags, 2);\n        assert_eq!(wrapper2.as_slice(), [0, 0, 0, 3, 14, 0, 0, 1]);\n    }\n}\n"], "fixing_code": ["[package]\nname = \"vmm-sys-util\"\nversion = \"0.12.0\"\nauthors = [\"Intel Virtualization Team <vmm-maintainers@intel.com>\"]\ndescription = \"A system utility set\"\nrepository = \"https://github.com/rust-vmm/vmm-sys-util\"\nreadme = \"README.md\"\nkeywords = [\"utils\"]\nedition = \"2021\"\nlicense = \"BSD-3-Clause\"\n\n[package.metadata.docs.rs]\nall-features = true\nrustdoc-args = [\"--cfg\", \"docsrs\"]\n\n[features]\nwith-serde = [\"serde\", \"serde_derive\"]\n\n[dependencies]\nlibc = \"0.2.39\"\nserde = { version = \"1.0.27\", optional = true }\nserde_derive = { version = \"1.0.27\", optional = true }\n\n[target.'cfg(any(target_os = \"linux\", target_os = \"android\"))'.dependencies]\nbitflags = \"1.0\"\n\n[dev-dependencies]\nserde_json = \"1.0.9\"\nbincode = \"1.3.3\"\n", "// Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n//\n// Portions Copyright 2017 The Chromium OS Authors. All rights reserved.\n//\n// SPDX-License-Identifier: BSD-3-Clause\n\n//! Trait and wrapper for working with C defined FAM structures.\n//!\n//! In C 99 an array of unknown size may appear within a struct definition as the last member\n//! (as long as there is at least one other named member).\n//! This is known as a flexible array member (FAM).\n//! Pre C99, the same behavior could be achieved using zero length arrays.\n//!\n//! Flexible Array Members are the go-to choice for working with large amounts of data\n//! prefixed by header values.\n//!\n//! For example the KVM API has many structures of this kind.\n\n#[cfg(feature = \"with-serde\")]\nuse serde::de::{self, Deserialize, Deserializer, SeqAccess, Visitor};\n#[cfg(feature = \"with-serde\")]\nuse serde::{ser::SerializeTuple, Serialize, Serializer};\nuse std::fmt;\n#[cfg(feature = \"with-serde\")]\nuse std::marker::PhantomData;\nuse std::mem::{self, size_of};\n\n/// Errors associated with the [`FamStructWrapper`](struct.FamStructWrapper.html) struct.\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum Error {\n    /// The max size has been exceeded\n    SizeLimitExceeded,\n}\n\nimpl std::error::Error for Error {}\n\nimpl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            Self::SizeLimitExceeded => write!(f, \"The max size has been exceeded\"),\n        }\n    }\n}\n\n/// Trait for accessing properties of C defined FAM structures.\n///\n/// # Safety\n///\n/// This is unsafe due to the number of constraints that aren't checked:\n/// * the implementer should be a POD\n/// * the implementor should contain a flexible array member of elements of type `Entry`\n/// * `Entry` should be a POD\n///\n/// Violating these may cause problems.\n///\n/// # Example\n///\n/// ```\n/// use vmm_sys_util::fam::*;\n///\n/// #[repr(C)]\n/// #[derive(Default)]\n/// pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);\n/// impl<T> __IncompleteArrayField<T> {\n///     #[inline]\n///     pub fn new() -> Self {\n///         __IncompleteArrayField(::std::marker::PhantomData, [])\n///     }\n///     #[inline]\n///     pub unsafe fn as_ptr(&self) -> *const T {\n///         ::std::mem::transmute(self)\n///     }\n///     #[inline]\n///     pub unsafe fn as_mut_ptr(&mut self) -> *mut T {\n///         ::std::mem::transmute(self)\n///     }\n///     #[inline]\n///     pub unsafe fn as_slice(&self, len: usize) -> &[T] {\n///         ::std::slice::from_raw_parts(self.as_ptr(), len)\n///     }\n///     #[inline]\n///     pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {\n///         ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)\n///     }\n/// }\n///\n/// #[repr(C)]\n/// #[derive(Default)]\n/// struct MockFamStruct {\n///     pub len: u32,\n///     pub padding: u32,\n///     pub entries: __IncompleteArrayField<u32>,\n/// }\n///\n/// unsafe impl FamStruct for MockFamStruct {\n///     type Entry = u32;\n///\n///     fn len(&self) -> usize {\n///         self.len as usize\n///     }\n///\n///     unsafe fn set_len(&mut self, len: usize) {\n///         self.len = len as u32\n///     }\n///\n///     fn max_len() -> usize {\n///         100\n///     }\n///\n///     fn as_slice(&self) -> &[u32] {\n///         let len = self.len();\n///         unsafe { self.entries.as_slice(len) }\n///     }\n///\n///     fn as_mut_slice(&mut self) -> &mut [u32] {\n///         let len = self.len();\n///         unsafe { self.entries.as_mut_slice(len) }\n///     }\n/// }\n///\n/// type MockFamStructWrapper = FamStructWrapper<MockFamStruct>;\n/// ```\n#[allow(clippy::len_without_is_empty)]\npub unsafe trait FamStruct {\n    /// The type of the FAM entries\n    type Entry: PartialEq + Copy;\n\n    /// Get the FAM length\n    ///\n    /// These type of structures contain a member that holds the FAM length.\n    /// This method will return the value of that member.\n    fn len(&self) -> usize;\n\n    /// Set the FAM length\n    ///\n    /// These type of structures contain a member that holds the FAM length.\n    /// This method will set the value of that member.\n    ///\n    /// # Safety\n    ///\n    /// The caller needs to ensure that `len` here reflects the correct number of entries of the\n    /// flexible array part of the struct.\n    unsafe fn set_len(&mut self, len: usize);\n\n    /// Get max allowed FAM length\n    ///\n    /// This depends on each structure.\n    /// For example a structure representing the cpuid can contain at most 80 entries.\n    fn max_len() -> usize;\n\n    /// Get the FAM entries as slice\n    fn as_slice(&self) -> &[Self::Entry];\n\n    /// Get the FAM entries as mut slice\n    fn as_mut_slice(&mut self) -> &mut [Self::Entry];\n}\n\n/// A wrapper for [`FamStruct`](trait.FamStruct.html).\n///\n/// It helps in treating a [`FamStruct`](trait.FamStruct.html) similarly to an actual `Vec`.\n#[derive(Debug)]\npub struct FamStructWrapper<T: Default + FamStruct> {\n    // This variable holds the FamStruct structure. We use a `Vec<T>` to make the allocation\n    // large enough while still being aligned for `T`. Only the first element of `Vec<T>`\n    // will actually be used as a `T`. The remaining memory in the `Vec<T>` is for `entries`,\n    // which must be contiguous. Since the entries are of type `FamStruct::Entry` we must\n    // be careful to convert the desired capacity of the `FamStructWrapper`\n    // from `FamStruct::Entry` to `T` when reserving or releasing memory.\n    mem_allocator: Vec<T>,\n}\n\nimpl<T: Default + FamStruct> FamStructWrapper<T> {\n    /// Convert FAM len to `mem_allocator` len.\n    ///\n    /// Get the capacity required by mem_allocator in order to hold\n    /// the provided number of [`FamStruct::Entry`](trait.FamStruct.html#associatedtype.Entry).\n    /// Returns `None` if the required length would overflow usize.\n    fn mem_allocator_len(fam_len: usize) -> Option<usize> {\n        let wrapper_size_in_bytes =\n            size_of::<T>().checked_add(fam_len.checked_mul(size_of::<T::Entry>())?)?;\n\n        wrapper_size_in_bytes\n            .checked_add(size_of::<T>().checked_sub(1)?)?\n            .checked_div(size_of::<T>())\n    }\n\n    /// Convert `mem_allocator` len to FAM len.\n    ///\n    /// Get the number of elements of type\n    /// [`FamStruct::Entry`](trait.FamStruct.html#associatedtype.Entry)\n    /// that fit in a mem_allocator of provided len.\n    fn fam_len(mem_allocator_len: usize) -> usize {\n        if mem_allocator_len == 0 {\n            return 0;\n        }\n\n        let array_size_in_bytes = (mem_allocator_len - 1) * size_of::<T>();\n        array_size_in_bytes / size_of::<T::Entry>()\n    }\n\n    /// Create a new FamStructWrapper with `num_elements` elements.\n    ///\n    /// The elements will be zero-initialized. The type of the elements will be\n    /// [`FamStruct::Entry`](trait.FamStruct.html#associatedtype.Entry).\n    ///\n    /// # Arguments\n    ///\n    /// * `num_elements` - The number of elements in the FamStructWrapper.\n    ///\n    /// # Errors\n    ///\n    /// When `num_elements` is greater than the max possible len, it returns\n    /// `Error::SizeLimitExceeded`.\n    pub fn new(num_elements: usize) -> Result<FamStructWrapper<T>, Error> {\n        if num_elements > T::max_len() {\n            return Err(Error::SizeLimitExceeded);\n        }\n        let required_mem_allocator_capacity =\n            FamStructWrapper::<T>::mem_allocator_len(num_elements)\n                .ok_or(Error::SizeLimitExceeded)?;\n\n        let mut mem_allocator = Vec::with_capacity(required_mem_allocator_capacity);\n        mem_allocator.push(T::default());\n        for _ in 1..required_mem_allocator_capacity {\n            // SAFETY: Safe as long T follows the requirements of being POD.\n            mem_allocator.push(unsafe { mem::zeroed() })\n        }\n        // SAFETY: The flexible array part of the struct has `num_elements` capacity. We just\n        // initialized this in `mem_allocator`.\n        unsafe {\n            mem_allocator[0].set_len(num_elements);\n        }\n\n        Ok(FamStructWrapper { mem_allocator })\n    }\n\n    /// Create a new FamStructWrapper from a slice of elements.\n    ///\n    /// # Arguments\n    ///\n    /// * `entries` - The slice of [`FamStruct::Entry`](trait.FamStruct.html#associatedtype.Entry)\n    ///               entries.\n    ///\n    /// # Errors\n    ///\n    /// When the size of `entries` is greater than the max possible len, it returns\n    /// `Error::SizeLimitExceeded`.\n    pub fn from_entries(entries: &[T::Entry]) -> Result<FamStructWrapper<T>, Error> {\n        let mut adapter = FamStructWrapper::<T>::new(entries.len())?;\n\n        {\n            let wrapper_entries = adapter.as_mut_fam_struct().as_mut_slice();\n            wrapper_entries.copy_from_slice(entries);\n        }\n\n        Ok(adapter)\n    }\n\n    /// Create a new FamStructWrapper from the raw content represented as `Vec<T>`.\n    ///\n    /// Sometimes we already have the raw content of an FAM struct represented as `Vec<T>`,\n    /// and want to use the FamStructWrapper as accessors.\n    ///\n    /// # Arguments\n    ///\n    /// * `content` - The raw content represented as `Vec[T]`.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe because the caller needs to ensure that the raw content is\n    /// correctly layed out.\n    pub unsafe fn from_raw(content: Vec<T>) -> Self {\n        FamStructWrapper {\n            mem_allocator: content,\n        }\n    }\n\n    /// Consume the FamStructWrapper and return the raw content as `Vec<T>`.\n    pub fn into_raw(self) -> Vec<T> {\n        self.mem_allocator\n    }\n\n    /// Get a reference to the actual [`FamStruct`](trait.FamStruct.html) instance.\n    pub fn as_fam_struct_ref(&self) -> &T {\n        &self.mem_allocator[0]\n    }\n\n    // Get a mut reference to the actual [`FamStruct`](trait.FamStruct.html) instance.\n    fn as_mut_fam_struct(&mut self) -> &mut T {\n        &mut self.mem_allocator[0]\n    }\n\n    /// Get a pointer to the [`FamStruct`](trait.FamStruct.html) instance.\n    ///\n    /// The caller must ensure that the fam_struct outlives the pointer this\n    /// function returns, or else it will end up pointing to garbage.\n    ///\n    /// Modifying the container referenced by this pointer may cause its buffer\n    /// to be reallocated, which would also make any pointers to it invalid.\n    pub fn as_fam_struct_ptr(&self) -> *const T {\n        self.as_fam_struct_ref()\n    }\n\n    /// Get a mutable pointer to the [`FamStruct`](trait.FamStruct.html) instance.\n    ///\n    /// The caller must ensure that the fam_struct outlives the pointer this\n    /// function returns, or else it will end up pointing to garbage.\n    ///\n    /// Modifying the container referenced by this pointer may cause its buffer\n    /// to be reallocated, which would also make any pointers to it invalid.\n    pub fn as_mut_fam_struct_ptr(&mut self) -> *mut T {\n        self.as_mut_fam_struct()\n    }\n\n    /// Get the elements slice.\n    pub fn as_slice(&self) -> &[T::Entry] {\n        self.as_fam_struct_ref().as_slice()\n    }\n\n    /// Get the mutable elements slice.\n    pub fn as_mut_slice(&mut self) -> &mut [T::Entry] {\n        self.as_mut_fam_struct().as_mut_slice()\n    }\n\n    /// Get the number of elements of type `FamStruct::Entry` currently in the vec.\n    fn len(&self) -> usize {\n        self.as_fam_struct_ref().len()\n    }\n\n    /// Get the capacity of the `FamStructWrapper`\n    ///\n    /// The capacity is measured in elements of type `FamStruct::Entry`.\n    fn capacity(&self) -> usize {\n        FamStructWrapper::<T>::fam_len(self.mem_allocator.capacity())\n    }\n\n    /// Reserve additional capacity.\n    ///\n    /// Reserve capacity for at least `additional` more\n    /// [`FamStruct::Entry`](trait.FamStruct.html#associatedtype.Entry) elements.\n    ///\n    /// If the capacity is already reserved, this method doesn't do anything.\n    /// If not this will trigger a reallocation of the underlying buffer.\n    fn reserve(&mut self, additional: usize) -> Result<(), Error> {\n        let desired_capacity = self.len() + additional;\n        if desired_capacity <= self.capacity() {\n            return Ok(());\n        }\n\n        let current_mem_allocator_len = self.mem_allocator.len();\n        let required_mem_allocator_len = FamStructWrapper::<T>::mem_allocator_len(desired_capacity)\n            .ok_or(Error::SizeLimitExceeded)?;\n        let additional_mem_allocator_len = required_mem_allocator_len - current_mem_allocator_len;\n\n        self.mem_allocator.reserve(additional_mem_allocator_len);\n\n        Ok(())\n    }\n\n    /// Update the length of the FamStructWrapper.\n    ///\n    /// The length of `self` will be updated to the specified value.\n    /// The length of the `T` structure and of `self.mem_allocator` will be updated accordingly.\n    /// If the len is increased additional capacity will be reserved.\n    /// If the len is decreased the unnecessary memory will be deallocated.\n    ///\n    /// This method might trigger reallocations of the underlying buffer.\n    ///\n    /// # Errors\n    ///\n    /// When len is greater than the max possible len it returns Error::SizeLimitExceeded.\n    fn set_len(&mut self, len: usize) -> Result<(), Error> {\n        let additional_elements = isize::try_from(len)\n            .and_then(|len| isize::try_from(self.len()).map(|self_len| len - self_len))\n            .map_err(|_| Error::SizeLimitExceeded)?;\n\n        // If len == self.len there's nothing to do.\n        if additional_elements == 0 {\n            return Ok(());\n        }\n\n        // If the len needs to be increased:\n        if additional_elements > 0 {\n            // Check if the new len is valid.\n            if len > T::max_len() {\n                return Err(Error::SizeLimitExceeded);\n            }\n            // Reserve additional capacity.\n            self.reserve(additional_elements as usize)?;\n        }\n\n        let current_mem_allocator_len = self.mem_allocator.len();\n        let required_mem_allocator_len =\n            FamStructWrapper::<T>::mem_allocator_len(len).ok_or(Error::SizeLimitExceeded)?;\n        // Update the len of the `mem_allocator`.\n        // SAFETY: This is safe since enough capacity has been reserved.\n        unsafe {\n            self.mem_allocator.set_len(required_mem_allocator_len);\n        }\n        // Zero-initialize the additional elements if any.\n        for i in current_mem_allocator_len..required_mem_allocator_len {\n            // SAFETY: Safe as long as the trait is only implemented for POD. This is a requirement\n            // for the trait implementation.\n            self.mem_allocator[i] = unsafe { mem::zeroed() }\n        }\n        // Update the len of the underlying `FamStruct`.\n        // SAFETY: We just adjusted the memory for the underlying `mem_allocator` to hold `len`\n        // entries.\n        unsafe {\n            self.as_mut_fam_struct().set_len(len);\n        }\n\n        // If the len needs to be decreased, deallocate unnecessary memory\n        if additional_elements < 0 {\n            self.mem_allocator.shrink_to_fit();\n        }\n\n        Ok(())\n    }\n\n    /// Append an element.\n    ///\n    /// # Arguments\n    ///\n    /// * `entry` - The element that will be appended to the end of the collection.\n    ///\n    /// # Errors\n    ///\n    /// When len is already equal to max possible len it returns Error::SizeLimitExceeded.\n    pub fn push(&mut self, entry: T::Entry) -> Result<(), Error> {\n        let new_len = self.len() + 1;\n        self.set_len(new_len)?;\n        self.as_mut_slice()[new_len - 1] = entry;\n\n        Ok(())\n    }\n\n    /// Retain only the elements specified by the predicate.\n    ///\n    /// # Arguments\n    ///\n    /// * `f` - The function used to evaluate whether an entry will be kept or not.\n    ///         When `f` returns `true` the entry is kept.\n    pub fn retain<P>(&mut self, mut f: P)\n    where\n        P: FnMut(&T::Entry) -> bool,\n    {\n        let mut num_kept_entries = 0;\n        {\n            let entries = self.as_mut_slice();\n            for entry_idx in 0..entries.len() {\n                let keep = f(&entries[entry_idx]);\n                if keep {\n                    entries[num_kept_entries] = entries[entry_idx];\n                    num_kept_entries += 1;\n                }\n            }\n        }\n\n        // This is safe since this method is not increasing the len\n        self.set_len(num_kept_entries).expect(\"invalid length\");\n    }\n}\n\nimpl<T: Default + FamStruct + PartialEq> PartialEq for FamStructWrapper<T> {\n    fn eq(&self, other: &FamStructWrapper<T>) -> bool {\n        self.as_fam_struct_ref() == other.as_fam_struct_ref() && self.as_slice() == other.as_slice()\n    }\n}\n\nimpl<T: Default + FamStruct> Clone for FamStructWrapper<T> {\n    fn clone(&self) -> Self {\n        // The number of entries (self.as_slice().len()) can't be > T::max_len() since `self` is a\n        // valid `FamStructWrapper`. This makes the .unwrap() safe.\n        let required_mem_allocator_capacity =\n            FamStructWrapper::<T>::mem_allocator_len(self.as_slice().len()).unwrap();\n\n        let mut mem_allocator = Vec::with_capacity(required_mem_allocator_capacity);\n\n        // SAFETY: This is safe as long as the requirements for the `FamStruct` trait to be safe\n        // are met (the implementing type and the entries elements are POD, therefore `Copy`, so\n        // memory safety can't be violated by the ownership of `fam_struct`). It is also safe\n        // because we're trying to read a T from a `&T` that is pointing to a properly initialized\n        // and aligned T.\n        unsafe {\n            let fam_struct: T = std::ptr::read(self.as_fam_struct_ref());\n            mem_allocator.push(fam_struct);\n        }\n        for _ in 1..required_mem_allocator_capacity {\n            mem_allocator.push(\n                // SAFETY: This is safe as long as T respects the FamStruct trait and is a POD.\n                unsafe { mem::zeroed() },\n            )\n        }\n\n        let mut adapter = FamStructWrapper { mem_allocator };\n        {\n            let wrapper_entries = adapter.as_mut_fam_struct().as_mut_slice();\n            wrapper_entries.copy_from_slice(self.as_slice());\n        }\n        adapter\n    }\n}\n\nimpl<T: Default + FamStruct> From<Vec<T>> for FamStructWrapper<T> {\n    fn from(vec: Vec<T>) -> Self {\n        FamStructWrapper { mem_allocator: vec }\n    }\n}\n\n#[cfg(feature = \"with-serde\")]\nimpl<T: Default + FamStruct + Serialize> Serialize for FamStructWrapper<T>\nwhere\n    <T as FamStruct>::Entry: serde::Serialize,\n{\n    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        let mut s = serializer.serialize_tuple(2)?;\n        s.serialize_element(self.as_fam_struct_ref())?;\n        s.serialize_element(self.as_slice())?;\n        s.end()\n    }\n}\n\n#[cfg(feature = \"with-serde\")]\nimpl<'de, T: Default + FamStruct + Deserialize<'de>> Deserialize<'de> for FamStructWrapper<T>\nwhere\n    <T as FamStruct>::Entry: std::marker::Copy + serde::Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        struct FamStructWrapperVisitor<X> {\n            dummy: PhantomData<X>,\n        }\n\n        impl<'de, X: Default + FamStruct + Deserialize<'de>> Visitor<'de> for FamStructWrapperVisitor<X>\n        where\n            <X as FamStruct>::Entry: std::marker::Copy + serde::Deserialize<'de>,\n        {\n            type Value = FamStructWrapper<X>;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"FamStructWrapper\")\n            }\n\n            fn visit_seq<V>(self, mut seq: V) -> Result<FamStructWrapper<X>, V::Error>\n            where\n                V: SeqAccess<'de>,\n            {\n                use serde::de::Error;\n\n                let header: X = seq\n                    .next_element()?\n                    .ok_or_else(|| de::Error::invalid_length(0, &self))?;\n                let entries: Vec<X::Entry> = seq\n                    .next_element()?\n                    .ok_or_else(|| de::Error::invalid_length(1, &self))?;\n\n                if header.len() != entries.len() {\n                    let msg = format!(\n                        \"Mismatch between length of FAM specified in FamStruct header ({}) \\\n                         and actual size of FAM ({})\",\n                        header.len(),\n                        entries.len()\n                    );\n                    return Err(V::Error::custom(msg));\n                }\n\n                let mut result: Self::Value = FamStructWrapper::from_entries(entries.as_slice())\n                    .map_err(|e| V::Error::custom(format!(\"{:?}\", e)))?;\n                result.mem_allocator[0] = header;\n                Ok(result)\n            }\n        }\n\n        deserializer.deserialize_tuple(2, FamStructWrapperVisitor { dummy: PhantomData })\n    }\n}\n\n/// Generate `FamStruct` implementation for structs with flexible array member.\n#[macro_export]\nmacro_rules! generate_fam_struct_impl {\n    ($struct_type: ty, $entry_type: ty, $entries_name: ident,\n     $field_type: ty, $field_name: ident, $max: expr) => {\n        unsafe impl FamStruct for $struct_type {\n            type Entry = $entry_type;\n\n            fn len(&self) -> usize {\n                self.$field_name as usize\n            }\n\n            unsafe fn set_len(&mut self, len: usize) {\n                self.$field_name = len as $field_type;\n            }\n\n            fn max_len() -> usize {\n                $max\n            }\n\n            fn as_slice(&self) -> &[<Self as FamStruct>::Entry] {\n                let len = self.len();\n                unsafe { self.$entries_name.as_slice(len) }\n            }\n\n            fn as_mut_slice(&mut self) -> &mut [<Self as FamStruct>::Entry] {\n                let len = self.len();\n                unsafe { self.$entries_name.as_mut_slice(len) }\n            }\n        }\n    };\n}\n\n#[cfg(test)]\nmod tests {\n    #![allow(clippy::undocumented_unsafe_blocks)]\n\n    #[cfg(feature = \"with-serde\")]\n    use serde_derive::{Deserialize, Serialize};\n\n    use super::*;\n\n    const MAX_LEN: usize = 100;\n\n    #[repr(C)]\n    #[derive(Default, Debug, PartialEq, Eq)]\n    pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);\n    impl<T> __IncompleteArrayField<T> {\n        #[inline]\n        pub fn new() -> Self {\n            __IncompleteArrayField(::std::marker::PhantomData, [])\n        }\n        #[inline]\n        pub unsafe fn as_ptr(&self) -> *const T {\n            self as *const __IncompleteArrayField<T> as *const T\n        }\n        #[inline]\n        pub unsafe fn as_mut_ptr(&mut self) -> *mut T {\n            self as *mut __IncompleteArrayField<T> as *mut T\n        }\n        #[inline]\n        pub unsafe fn as_slice(&self, len: usize) -> &[T] {\n            ::std::slice::from_raw_parts(self.as_ptr(), len)\n        }\n        #[inline]\n        pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {\n            ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)\n        }\n    }\n\n    #[cfg(feature = \"with-serde\")]\n    impl<T> Serialize for __IncompleteArrayField<T> {\n        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>\n        where\n            S: Serializer,\n        {\n            [0u8; 0].serialize(serializer)\n        }\n    }\n\n    #[cfg(feature = \"with-serde\")]\n    impl<'de, T> Deserialize<'de> for __IncompleteArrayField<T> {\n        fn deserialize<D>(_: D) -> std::result::Result<Self, D::Error>\n        where\n            D: Deserializer<'de>,\n        {\n            Ok(__IncompleteArrayField::new())\n        }\n    }\n\n    #[repr(C)]\n    #[derive(Default, PartialEq)]\n    struct MockFamStruct {\n        pub len: u32,\n        pub padding: u32,\n        pub entries: __IncompleteArrayField<u32>,\n    }\n\n    generate_fam_struct_impl!(MockFamStruct, u32, entries, u32, len, 100);\n\n    type MockFamStructWrapper = FamStructWrapper<MockFamStruct>;\n\n    const ENTRIES_OFFSET: usize = 2;\n\n    const FAM_LEN_TO_MEM_ALLOCATOR_LEN: &[(usize, usize)] = &[\n        (0, 1),\n        (1, 2),\n        (2, 2),\n        (3, 3),\n        (4, 3),\n        (5, 4),\n        (10, 6),\n        (50, 26),\n        (100, 51),\n    ];\n\n    const MEM_ALLOCATOR_LEN_TO_FAM_LEN: &[(usize, usize)] = &[\n        (0, 0),\n        (1, 0),\n        (2, 2),\n        (3, 4),\n        (4, 6),\n        (5, 8),\n        (10, 18),\n        (50, 98),\n        (100, 198),\n    ];\n\n    #[test]\n    fn test_mem_allocator_len() {\n        for pair in FAM_LEN_TO_MEM_ALLOCATOR_LEN {\n            let fam_len = pair.0;\n            let mem_allocator_len = pair.1;\n            assert_eq!(\n                Some(mem_allocator_len),\n                MockFamStructWrapper::mem_allocator_len(fam_len)\n            );\n        }\n    }\n\n    #[repr(C)]\n    #[derive(Default, PartialEq)]\n    struct MockFamStructU8 {\n        pub len: u32,\n        pub padding: u32,\n        pub entries: __IncompleteArrayField<u8>,\n    }\n    generate_fam_struct_impl!(MockFamStructU8, u8, entries, u32, len, 100);\n    type MockFamStructWrapperU8 = FamStructWrapper<MockFamStructU8>;\n    #[test]\n    fn test_invalid_type_conversion() {\n        let mut adapter = MockFamStructWrapperU8::new(10).unwrap();\n        assert!(matches!(\n            adapter.set_len(0xffff_ffff_ffff_ff00),\n            Err(Error::SizeLimitExceeded)\n        ));\n    }\n\n    #[test]\n    fn test_wrapper_len() {\n        for pair in MEM_ALLOCATOR_LEN_TO_FAM_LEN {\n            let mem_allocator_len = pair.0;\n            let fam_len = pair.1;\n            assert_eq!(fam_len, MockFamStructWrapper::fam_len(mem_allocator_len));\n        }\n    }\n\n    #[test]\n    fn test_new() {\n        let num_entries = 10;\n\n        let adapter = MockFamStructWrapper::new(num_entries).unwrap();\n        assert_eq!(num_entries, adapter.capacity());\n\n        let u32_slice = unsafe {\n            std::slice::from_raw_parts(\n                adapter.as_fam_struct_ptr() as *const u32,\n                num_entries + ENTRIES_OFFSET,\n            )\n        };\n        assert_eq!(num_entries, u32_slice[0] as usize);\n        for entry in u32_slice[1..].iter() {\n            assert_eq!(*entry, 0);\n        }\n\n        // It's okay to create a `FamStructWrapper` with the maximum allowed number of entries.\n        let adapter = MockFamStructWrapper::new(MockFamStruct::max_len()).unwrap();\n        assert_eq!(MockFamStruct::max_len(), adapter.capacity());\n\n        assert!(matches!(\n            MockFamStructWrapper::new(MockFamStruct::max_len() + 1),\n            Err(Error::SizeLimitExceeded)\n        ));\n    }\n\n    #[test]\n    fn test_from_entries() {\n        let num_entries: usize = 10;\n\n        let mut entries = Vec::new();\n        for i in 0..num_entries {\n            entries.push(i as u32);\n        }\n\n        let adapter = MockFamStructWrapper::from_entries(entries.as_slice()).unwrap();\n        let u32_slice = unsafe {\n            std::slice::from_raw_parts(\n                adapter.as_fam_struct_ptr() as *const u32,\n                num_entries + ENTRIES_OFFSET,\n            )\n        };\n        assert_eq!(num_entries, u32_slice[0] as usize);\n        for (i, &value) in entries.iter().enumerate().take(num_entries) {\n            assert_eq!(adapter.as_slice()[i], value);\n        }\n\n        let mut entries = Vec::new();\n        for i in 0..MockFamStruct::max_len() + 1 {\n            entries.push(i as u32);\n        }\n\n        // Can't create a `FamStructWrapper` with a number of entries > MockFamStruct::max_len().\n        assert!(matches!(\n            MockFamStructWrapper::from_entries(entries.as_slice()),\n            Err(Error::SizeLimitExceeded)\n        ));\n    }\n\n    #[test]\n    fn test_entries_slice() {\n        let num_entries = 10;\n        let mut adapter = MockFamStructWrapper::new(num_entries).unwrap();\n\n        let expected_slice = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\n        {\n            let mut_entries_slice = adapter.as_mut_slice();\n            mut_entries_slice.copy_from_slice(expected_slice);\n        }\n\n        let u32_slice = unsafe {\n            std::slice::from_raw_parts(\n                adapter.as_fam_struct_ptr() as *const u32,\n                num_entries + ENTRIES_OFFSET,\n            )\n        };\n        assert_eq!(expected_slice, &u32_slice[ENTRIES_OFFSET..]);\n        assert_eq!(expected_slice, adapter.as_slice());\n    }\n\n    #[test]\n    fn test_reserve() {\n        let mut adapter = MockFamStructWrapper::new(0).unwrap();\n\n        // test that the right capacity is reserved\n        for pair in FAM_LEN_TO_MEM_ALLOCATOR_LEN {\n            let num_elements = pair.0;\n            let required_mem_allocator_len = pair.1;\n\n            adapter.reserve(num_elements).unwrap();\n\n            assert!(adapter.mem_allocator.capacity() >= required_mem_allocator_len);\n            assert_eq!(0, adapter.len());\n            assert!(adapter.capacity() >= num_elements);\n        }\n\n        // test that when the capacity is already reserved, the method doesn't do anything\n        let current_capacity = adapter.capacity();\n        adapter.reserve(current_capacity - 1).unwrap();\n        assert_eq!(current_capacity, adapter.capacity());\n    }\n\n    #[test]\n    fn test_set_len() {\n        let mut desired_len = 0;\n        let mut adapter = MockFamStructWrapper::new(desired_len).unwrap();\n\n        // keep initial len\n        assert!(adapter.set_len(desired_len).is_ok());\n        assert_eq!(adapter.len(), desired_len);\n\n        // increase len\n        desired_len = 10;\n        assert!(adapter.set_len(desired_len).is_ok());\n        // check that the len has been increased and zero-initialized elements have been added\n        assert_eq!(adapter.len(), desired_len);\n        for element in adapter.as_slice() {\n            assert_eq!(*element, 0_u32);\n        }\n\n        // decrease len\n        desired_len = 5;\n        assert!(adapter.set_len(desired_len).is_ok());\n        assert_eq!(adapter.len(), desired_len);\n    }\n\n    #[test]\n    fn test_push() {\n        let mut adapter = MockFamStructWrapper::new(0).unwrap();\n\n        for i in 0..MAX_LEN {\n            assert!(adapter.push(i as u32).is_ok());\n            assert_eq!(adapter.as_slice()[i], i as u32);\n            assert_eq!(adapter.len(), i + 1);\n            assert!(\n                adapter.mem_allocator.capacity()\n                    >= MockFamStructWrapper::mem_allocator_len(i + 1).unwrap()\n            );\n        }\n\n        assert!(adapter.push(0).is_err());\n    }\n\n    #[test]\n    fn test_retain() {\n        let mut adapter = MockFamStructWrapper::new(0).unwrap();\n\n        let mut num_retained_entries = 0;\n        for i in 0..MAX_LEN {\n            assert!(adapter.push(i as u32).is_ok());\n            if i % 2 == 0 {\n                num_retained_entries += 1;\n            }\n        }\n\n        adapter.retain(|entry| entry % 2 == 0);\n\n        for entry in adapter.as_slice().iter() {\n            assert_eq!(0, entry % 2);\n        }\n        assert_eq!(adapter.len(), num_retained_entries);\n        assert!(\n            adapter.mem_allocator.capacity()\n                >= MockFamStructWrapper::mem_allocator_len(num_retained_entries).unwrap()\n        );\n    }\n\n    #[test]\n    fn test_partial_eq() {\n        let mut wrapper_1 = MockFamStructWrapper::new(0).unwrap();\n        let mut wrapper_2 = MockFamStructWrapper::new(0).unwrap();\n        let mut wrapper_3 = MockFamStructWrapper::new(0).unwrap();\n\n        for i in 0..MAX_LEN {\n            assert!(wrapper_1.push(i as u32).is_ok());\n            assert!(wrapper_2.push(i as u32).is_ok());\n            assert!(wrapper_3.push(0).is_ok());\n        }\n\n        assert!(wrapper_1 == wrapper_2);\n        assert!(wrapper_1 != wrapper_3);\n    }\n\n    #[test]\n    fn test_clone() {\n        let mut adapter = MockFamStructWrapper::new(0).unwrap();\n\n        for i in 0..MAX_LEN {\n            assert!(adapter.push(i as u32).is_ok());\n        }\n\n        assert!(adapter == adapter.clone());\n    }\n\n    #[test]\n    fn test_raw_content() {\n        let data = vec![\n            MockFamStruct {\n                len: 2,\n                padding: 5,\n                entries: __IncompleteArrayField::new(),\n            },\n            MockFamStruct {\n                len: 0xA5,\n                padding: 0x1e,\n                entries: __IncompleteArrayField::new(),\n            },\n        ];\n\n        let mut wrapper = unsafe { MockFamStructWrapper::from_raw(data) };\n        {\n            let payload = wrapper.as_slice();\n            assert_eq!(payload[0], 0xA5);\n            assert_eq!(payload[1], 0x1e);\n        }\n        assert_eq!(wrapper.as_mut_fam_struct().padding, 5);\n        let data = wrapper.into_raw();\n        assert_eq!(data[0].len, 2);\n        assert_eq!(data[0].padding, 5);\n    }\n\n    #[cfg(feature = \"with-serde\")]\n    #[test]\n    fn test_ser_deser() {\n        #[repr(C)]\n        #[derive(Default, PartialEq)]\n        #[cfg_attr(feature = \"with-serde\", derive(Deserialize, Serialize))]\n        struct Message {\n            pub len: u32,\n            pub padding: u32,\n            pub value: u32,\n            #[cfg_attr(feature = \"with-serde\", serde(skip))]\n            pub entries: __IncompleteArrayField<u32>,\n        }\n\n        generate_fam_struct_impl!(Message, u32, entries, u32, len, 100);\n\n        type MessageFamStructWrapper = FamStructWrapper<Message>;\n\n        let data = vec![\n            Message {\n                len: 2,\n                padding: 0,\n                value: 42,\n                entries: __IncompleteArrayField::new(),\n            },\n            Message {\n                len: 0xA5,\n                padding: 0x1e,\n                value: 0,\n                entries: __IncompleteArrayField::new(),\n            },\n        ];\n\n        let wrapper = unsafe { MessageFamStructWrapper::from_raw(data) };\n        let data_ser = serde_json::to_string(&wrapper).unwrap();\n        assert_eq!(\n            data_ser,\n            \"[{\\\"len\\\":2,\\\"padding\\\":0,\\\"value\\\":42},[165,30]]\"\n        );\n        let data_deser =\n            serde_json::from_str::<MessageFamStructWrapper>(data_ser.as_str()).unwrap();\n        assert!(wrapper.eq(&data_deser));\n\n        let bad_data_ser = r#\"{\"foo\": \"bar\"}\"#;\n        assert!(serde_json::from_str::<MessageFamStructWrapper>(bad_data_ser).is_err());\n\n        #[repr(C)]\n        #[derive(Default)]\n        #[cfg_attr(feature = \"with-serde\", derive(Deserialize, Serialize))]\n        struct Message2 {\n            pub len: u32,\n            pub padding: u32,\n            pub value: u32,\n            #[cfg_attr(feature = \"with-serde\", serde(skip))]\n            pub entries: __IncompleteArrayField<u32>,\n        }\n\n        // Maximum number of entries = 1, so the deserialization should fail because of this reason.\n        generate_fam_struct_impl!(Message2, u32, entries, u32, len, 1);\n\n        type Message2FamStructWrapper = FamStructWrapper<Message2>;\n        assert!(serde_json::from_str::<Message2FamStructWrapper>(data_ser.as_str()).is_err());\n    }\n\n    #[test]\n    fn test_clone_multiple_fields() {\n        #[derive(Default, PartialEq)]\n        #[repr(C)]\n        struct Foo {\n            index: u32,\n            length: u16,\n            flags: u32,\n            entries: __IncompleteArrayField<u32>,\n        }\n\n        generate_fam_struct_impl!(Foo, u32, entries, u16, length, 100);\n\n        type FooFamStructWrapper = FamStructWrapper<Foo>;\n\n        let mut wrapper = FooFamStructWrapper::new(0).unwrap();\n        wrapper.as_mut_fam_struct().index = 1;\n        wrapper.as_mut_fam_struct().flags = 2;\n        wrapper.as_mut_fam_struct().length = 3;\n        wrapper.push(3).unwrap();\n        wrapper.push(14).unwrap();\n        assert_eq!(wrapper.as_slice().len(), 3 + 2);\n        assert_eq!(wrapper.as_slice()[3], 3);\n        assert_eq!(wrapper.as_slice()[3 + 1], 14);\n\n        let mut wrapper2 = wrapper.clone();\n        assert_eq!(\n            wrapper.as_mut_fam_struct().index,\n            wrapper2.as_mut_fam_struct().index\n        );\n        assert_eq!(\n            wrapper.as_mut_fam_struct().length,\n            wrapper2.as_mut_fam_struct().length\n        );\n        assert_eq!(\n            wrapper.as_mut_fam_struct().flags,\n            wrapper2.as_mut_fam_struct().flags\n        );\n        assert_eq!(wrapper.as_slice(), wrapper2.as_slice());\n        assert_eq!(\n            wrapper2.as_slice().len(),\n            wrapper2.as_mut_fam_struct().length as usize\n        );\n        assert!(wrapper == wrapper2);\n\n        wrapper.as_mut_fam_struct().index = 3;\n        assert!(wrapper != wrapper2);\n\n        wrapper.as_mut_fam_struct().length = 7;\n        assert!(wrapper != wrapper2);\n\n        wrapper.push(1).unwrap();\n        assert_eq!(wrapper.as_mut_fam_struct().length, 8);\n        assert!(wrapper != wrapper2);\n\n        let mut wrapper2 = wrapper.clone();\n        assert!(wrapper == wrapper2);\n\n        // Dropping the original variable should not affect its clone.\n        drop(wrapper);\n        assert_eq!(wrapper2.as_mut_fam_struct().index, 3);\n        assert_eq!(wrapper2.as_mut_fam_struct().length, 8);\n        assert_eq!(wrapper2.as_mut_fam_struct().flags, 2);\n        assert_eq!(wrapper2.as_slice(), [0, 0, 0, 3, 14, 0, 0, 1]);\n    }\n\n    #[cfg(feature = \"with-serde\")]\n    #[test]\n    fn test_bad_deserialize() {\n        #[repr(C)]\n        #[derive(Default, Debug, PartialEq, Serialize, Deserialize)]\n        struct Foo {\n            pub len: u32,\n            pub padding: u32,\n            pub entries: __IncompleteArrayField<u32>,\n        }\n\n        generate_fam_struct_impl!(Foo, u32, entries, u32, len, 100);\n\n        let state = FamStructWrapper::<Foo>::new(0).unwrap();\n        let mut bytes = bincode::serialize(&state).unwrap();\n\n        // The `len` field of the header is the first to be serialized.\n        // Writing at position 0 of the serialized data should change its value.\n        bytes[0] = 255;\n\n        assert!(\n            matches!(bincode::deserialize::<FamStructWrapper<Foo>>(&bytes).map_err(|boxed| *boxed), Err(bincode::ErrorKind::Custom(s)) if s == *\"Mismatch between length of FAM specified in FamStruct header (255) and actual size of FAM (0)\")\n        );\n    }\n}\n"], "filenames": ["Cargo.toml", "src/fam.rs"], "buggy_code_start_loc": [3, 102], "buggy_code_end_loc": [28, 1080], "fixing_code_start_loc": [3, 102], "fixing_code_end_loc": [30, 1129], "type": "CWE-787", "message": "vmm-sys-util is a collection of modules that provides helpers and utilities used by multiple rust-vmm components. Starting in version 0.5.0 and prior to version 0.12.0, an issue in the `FamStructWrapper::deserialize` implementation provided by the crate for `vmm_sys_util::fam::FamStructWrapper` can lead to out of bounds memory accesses. The deserialization does not check that the length stored in the header matches the flexible array length. Mismatch in the lengths might allow out of bounds memory access through Rust-safe methods. The issue was corrected in version 0.12.0 by inserting a check that verifies the lengths of compared flexible arrays are equal for any deserialized header and aborting deserialization otherwise. Moreover, the API was changed so that header length can only be modified through Rust-unsafe code. This ensures that users cannot trigger out-of-bounds memory access from Rust-safe code.", "other": {"cve": {"id": "CVE-2023-50711", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-02T20:15:10.250", "lastModified": "2024-02-14T03:15:13.793", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "vmm-sys-util is a collection of modules that provides helpers and utilities used by multiple rust-vmm components. Starting in version 0.5.0 and prior to version 0.12.0, an issue in the `FamStructWrapper::deserialize` implementation provided by the crate for `vmm_sys_util::fam::FamStructWrapper` can lead to out of bounds memory accesses. The deserialization does not check that the length stored in the header matches the flexible array length. Mismatch in the lengths might allow out of bounds memory access through Rust-safe methods. The issue was corrected in version 0.12.0 by inserting a check that verifies the lengths of compared flexible arrays are equal for any deserialized header and aborting deserialization otherwise. Moreover, the API was changed so that header length can only be modified through Rust-unsafe code. This ensures that users cannot trigger out-of-bounds memory access from Rust-safe code."}, {"lang": "es", "value": "vmm-sys-util es una colecci\u00f3n de m\u00f3dulos que proporciona ayudas y utilidades utilizadas por m\u00faltiples componentes de Rust-VMM. A partir de la versi\u00f3n 0.5.0 y antes de la versi\u00f3n 0.12.0, un problema en la implementaci\u00f3n de `FamStructWrapper::deserialize` proporcionada por la caja para `vmm_sys_util::fam::FamStructWrapper` puede provocar accesos a la memoria fuera de los l\u00edmites. La deserializaci\u00f3n no verifica que la longitud almacenada en el encabezado coincida con la longitud de la matriz flexible. La falta de coincidencia en las longitudes podr\u00eda permitir el acceso a la memoria fuera de los l\u00edmites a trav\u00e9s de m\u00e9todos seguros para Rust. El problema se corrigi\u00f3 en la versi\u00f3n 0.12.0 insertando una verificaci\u00f3n que verifica que las longitudes de las matrices flexibles comparadas sean iguales para cualquier encabezado deserializado y, en caso contrario, abortando la deserializaci\u00f3n. Adem\u00e1s, la API se cambi\u00f3 para que la longitud del encabezado solo se pueda modificar mediante c\u00f3digo no seguro para Rust. Esto garantiza que los usuarios no puedan activar el acceso a la memoria fuera de los l\u00edmites desde el c\u00f3digo seguro para Rust."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:C/C:N/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 2.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rust-vmm:vmm-sys-util:*:*:*:*:*:rust:*:*", "versionStartIncluding": "0.5.0", "versionEndExcluding": "0.12.0", "matchCriteriaId": "8BF935A7-CACE-4181-AF8F-46107DE2240B"}]}]}], "references": [{"url": "https://github.com/rust-vmm/vmm-sys-util/commit/30172fca2a8e0a38667d934ee56682247e13f167", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/rust-vmm/vmm-sys-util/security/advisories/GHSA-875g-mfp6-g7f9", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/W5XMCLV2P3ANS3XN4NXZTV4PUNTLWUNJ/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YJI7D273R6G5RUC246KTI2YY3AXZKZMD/", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/rust-vmm/vmm-sys-util/commit/30172fca2a8e0a38667d934ee56682247e13f167"}}